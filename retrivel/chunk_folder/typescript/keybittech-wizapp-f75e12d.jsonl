{"filename": "tsup.config.ts", "chunked_list": ["import type { Options } from 'tsup';\n\tconst config: Options = {\n\t  splitting: true,\n\t  entry: {\n\t    'lib/index': 'src/lib/index.ts',\n\t    'server/cli': 'src/server/cli.ts',\n\t    'server/index': 'src/server/index.ts'\n\t  },\n\t  format: ['cjs', 'esm'],\n\t  outDir: 'dist',\n", "  clean: true,\n\t}\n\texport default config;"]}
{"filename": "test/guidedEdit.test.ts", "chunked_list": ["import * as git from '../src/server/git';\n\timport * as useAiModule from '../src/server/spells/use_ai_spell';\n\timport { createMockStatement, setupConfigTestAfter, setupConfigTestBefore, withTempConfig } from './testHelpers';\n\timport { Project, SyntaxKind } from 'ts-morph';\n\t// Mock the required functions\n\tjest.mock('../src/server/git');\n\tjest.mock('../src/server/spells/use_ai_spell');\n\tconst prepareBranchMock = git.prepareBranch as jest.Mock;\n\tconst managePullRequestMock = git.managePullRequest as jest.Mock;\n\tconst useAiMock = useAiModule.useAi as jest.Mock;\n", "import { guidedEdit } from '../src/server/spells/guided_edit_spell';\n\tdescribe('guidedEdit', () => {\n\t  let tempConfigPath = '';\n\t  beforeEach(() => {\n\t    tempConfigPath = setupConfigTestBefore({ ai: { retries: '3' }, ts: { typeDir: 'types', configPath: 'tsconfig.json' } });\n\t    jest.clearAllMocks();\n\t  });\n\t  afterEach(() => {\n\t    setupConfigTestAfter(tempConfigPath);\n\t  });\n", "  test('should throw error when ts.configPath is not set', async () => {\n\t    await withTempConfig({ ai: { retries: '3' }, ts: { configPath: '' } }, async () => {\n\t      await expect(guidedEdit('NonExistent.tsx please make some changes to the file')).rejects.toThrow('Missing ts.configPath.');\n\t    });\n\t  });\n\t  it('should return \"file not found\" if the file does not exist', async () => {\n\t    await withTempConfig({ ai: { retries: '3' }, ts: { configPath: 'tsconfig.json' } }, async () => {\n\t      const fileParts = 'NonExistent.tsx please make some changes to the file';\n\t      prepareBranchMock.mockResolvedValue('test_branch');\n\t      useAiMock.mockResolvedValue({ message: [] });\n", "      const result = await guidedEdit(fileParts);\n\t      expect(result).toBe('file not found: NonExistent.tsx');\n\t    });\n\t  });\n\t  it('should return \"the file is too large\" if the file size is greater than 10000 characters', async () => {\n\t    const fileParts = 'LargeFile.tsx please make some changes to the file';\n\t    prepareBranchMock.mockResolvedValue('test_branch');\n\t    useAiMock.mockResolvedValue({ message: [] });\n\t    Project.prototype.getSourceFiles = jest.fn().mockReturnValue([{\n\t      getFilePath: () => 'LargeFile.tsx',\n", "      getText: () => 'a'.repeat(10001),\n\t      getStatements: () => [],\n\t    }]);\n\t    const result = await guidedEdit(fileParts);\n\t    expect(result).toBe('the file is too large');\n\t  });\n\t  it('should correctly handle generatedStatements for replacing, adding above, and adding below', async () => {\n\t    const fileParts = 'Test.tsx please make some changes to the file';\n\t    prepareBranchMock.mockResolvedValue('test_branch');\n\t    managePullRequestMock.mockResolvedValue('PR created or updated');\n", "    // Create mock statements\n\t    const mockStatements = [\n\t      createMockStatement('const statement_0 = \"original_0\";', SyntaxKind.VariableStatement),\n\t      createMockStatement('const statement_1 = \"original_1\";', SyntaxKind.VariableStatement),\n\t      createMockStatement('const statement_2 = \"original_2\";', SyntaxKind.VariableStatement),\n\t    ];\n\t    // Check if sourceFile content was updated correctly\n\t    let updatedFileContent = mockStatements.map(s => s.getText()).join('\\n');\n\t    // Update sourceFileMock\n\t    const sourceFileMock = {\n", "      getFilePath: () => 'Test.tsx',\n\t      getText: () => updatedFileContent,\n\t      getFullText: () => updatedFileContent,\n\t      getStatements: () => mockStatements,\n\t      removeText: jest.fn(),\n\t      insertText: jest.fn((index, content) => {\n\t        updatedFileContent = updatedFileContent.slice(0, index) + content + updatedFileContent.slice(index);\n\t      }),\n\t      saveSync: jest.fn(),\n\t    };\n", "    // Mock project.save\n\t    Project.prototype.save = jest.fn();\n\t    // Mock getSourceFiles() to return the sourceFileMock\n\t    const getSourceFilesMock = jest.fn().mockReturnValue([sourceFileMock]);\n\t    Project.prototype.getSourceFiles = getSourceFilesMock;\n\t    // Define generatedStatements\n\t    const generatedStatements = {\n\t      statement_0: 'const statement_0 = \"original_0\"',\n\t      above_1: 'const above_1 = \"above\";',\n\t      statement_2: 'const statement_2 = \"original_2\";',\n", "      below_2: 'const below_2 = \"below\";',\n\t    };\n\t    // Mock useAi to return the generatedStatements\n\t    useAiMock.mockResolvedValue({ message: [generatedStatements], supportingText: 'Supporting text' });\n\t    // Call guidedEdit\n\t    await guidedEdit(fileParts);\n\t    // Check if useAi was called with correct parsedStatements\n\t    const parsedStatements = JSON.parse(useAiMock.mock.calls[0][2]);\n\t    expect(parsedStatements).toHaveProperty('statement_0');\n\t    expect(parsedStatements).toHaveProperty('statement_1');\n", "    expect(parsedStatements).toHaveProperty('statement_2');\n\t    expect(updatedFileContent).toContain('const statement_0 = \"original_0\"');\n\t    expect(updatedFileContent).toContain('const above_1 = \"above\";');\n\t    expect(updatedFileContent).toContain('const statement_2 = \"original_2\";');\n\t    expect(updatedFileContent).toContain('const below_2 = \"below\";');\n\t  });\n\t});"]}
{"filename": "test/parseChatAttempt.test.ts", "chunked_list": ["import { setupChatResponse, setupCommonMocks } from './testHelpers';\n\tsetupChatResponse('');\n\tsetupCommonMocks();\n\timport * as parserModule from '../src/server/parser';\n\timport { GuidedEditResponse } from '../src/lib/prompts/guided_edit_prompt';\n\tdescribe('parserModule.parseChatAttempt', () => {\n\t  test('should handle forgotten markdown footer', async () => {\n\t    const badRes = 'Edits conveyed by comment snippets. I edited lines 61, 63, 65, 68, 70, 73, 75, which is 7 total edited lines. Here are the 7 edited lines:\\n' +\n\t    '```' +\n\t    '61. /* wizapp removed line content */ {empty space}\\n' +\n", "    '63. /* wizapp removed line content */ {empty space}\\n' +\n\t    '65.   return chatResponse.data.choices[0]?.message?.content.trim(); /* wizapp removed console log */\\n' +\n\t    '68. /* wizapp removed line content */ {empty space}\\n' +\n\t    '70.   return completionResponse.data.choices[0].text?.trim(); /* wizapp removed console log */\\n' +\n\t    '73. /* wizapp removed line content */ {empty space}\\n' +\n\t    '75.   return moderationResponse.data.results[0]?.flagged; /* wizapp removed console log */';\n\t    const expectedResult = {\n\t      message: '61. /* wizapp removed line content */ {empty space}\\n' +\n\t      '63. /* wizapp removed line content */ {empty space}\\n' +\n\t      '65.   return chatResponse.data.choices[0]?.message?.content.trim(); /* wizapp removed console log */\\n' +\n", "      '68. /* wizapp removed line content */ {empty space}\\n' +\n\t      '70.   return completionResponse.data.choices[0].text?.trim(); /* wizapp removed console log */\\n' +\n\t      '73. /* wizapp removed line content */ {empty space}\\n' +\n\t      '75.   return moderationResponse.data.results[0]?.flagged; /* wizapp removed console log */',\n\t      supportingText: \"Edits conveyed by comment snippets. I edited lines 61, 63, 65, 68, 70, 73, 75, which is 7 total edited lines. Here are the 7 edited lines:\\n``` \"\n\t    };\n\t    const result = parserModule.parseChatAttempt(badRes);\n\t    expect(result).toEqual(expectedResult);\n\t  });\n\t  test('should throw AI Refusal error', () => {\n", "    const attempt = \"I'm an AI language model and I can't perform this task.\";\n\t    expect(() => parserModule.parseChatAttempt(attempt)).toThrowError('AI Refusal');\n\t    const attempt2 = \"I'm sorry, I don't understand\";\n\t    expect(() => parserModule.parseChatAttempt(attempt2)).toThrowError('AI Refusal');\n\t  });\n\t  test('should return throw on non typed chat completion response', () => {\n\t    const attempt = \"This is a normal response.\";\n\t    expect(() => parserModule.parseChatAttempt(attempt)).toThrowError();\n\t  });\n\t  test('should throw Block structure is not valid error', () => {\n", "    const attempt = \"&&&Some text@@@&&&\";\n\t    expect(() => parserModule.parseChatAttempt(attempt)).toThrowError('Block structure is not valid.');\n\t  });\n\t  test('should throw cannot parse json error', () => {\n\t    const attempt = \"&&&Some text@@@{invalid json}@@@Some other text&&&\";\n\t    expect(() => parserModule.parseChatAttempt(attempt)).toThrowError(/cannot parse json./);\n\t  });\n\t  test('should return parsed json and supporting text when using a type', () => {\n\t    const attempt = '&&&In this edit, we fixed...@@@[{\"statement_7\": \"some changes\"}]@@@Some other information about these changes&&&';\n\t    const expectedResult = {\n", "      message: [{ \"statement_7\": \"some changes\" }],\n\t      supportingText: \"In this edit, we fixed...\\nSome other information about these changes\"\n\t    };\n\t    expect(parserModule.parseChatAttempt<GuidedEditResponse>(attempt)).toEqual(expectedResult);\n\t  });\n\t  test('should throw bad chat format error', () => {\n\t    const attempt = '&&&Some text@@@{\"unknown\": \"value\"}@@@Some other text&&&';\n\t    expect(() => parserModule.parseChatAttempt(attempt)).toThrowError('bad chat format');\n\t  });\n\t  test('should call validateTypedResponse with a string not wrapped in quotes', () => {\n", "    const attempt = \"'walking down the road'\";\n\t    const attemptDbl = '\"walking down the road\"';\n\t    const response = {\n\t      message: 'walking down the road',\n\t      supportingText: ''\n\t    }\n\t    expect(parserModule.parseChatAttempt(attempt)).toEqual(response);\n\t    expect(parserModule.parseChatAttempt(attemptDbl)).toEqual(response);\n\t  });\n\t});"]}
{"filename": "test/createType.test.ts", "chunked_list": ["import fs from 'fs';\n\timport * as useAiModule from '../src/server/spells/use_ai_spell';\n\timport { getConfig } from '../src/server/config';\n\timport { getPathOf, sanitizeName, toSnakeCase, toTitleCase } from '../src/server/util';\n\timport { setupConfigTestBefore, setupConfigTestAfter, withTempConfig, withOriginalGetConfig } from './testHelpers';\n\tjest.mock('fs', () => ({\n\t  ...jest.requireActual('fs'),\n\t  writeFileSync: jest.fn(),\n\t  existsSync: jest.fn(),\n\t  mkdirSync: jest.fn()\n", "}));\n\t// Mock the useAi function\n\tjest.mock('../src/server/spells/use_ai_spell', () => ({\n\t  useAi: jest.fn(),\n\t}));\n\tconst useAiMock = useAiModule.useAi as jest.Mock;\n\timport { createType } from '../src/server/spells';\n\tdescribe('createType', () => {\n\t  let tempConfigPath = '';\n\t  beforeEach(() => {\n", "    tempConfigPath = setupConfigTestBefore({ ts: { typeDir: 'types', configPath: 'tsconfig.json' } });\n\t    jest.clearAllMocks();\n\t  });\n\t  afterEach(() => {\n\t    setupConfigTestAfter(tempConfigPath);\n\t  });\n\t  test('should throw error when ts.typeDir is not set', async () => {\n\t    await withTempConfig({ ts: { typeDir: '' } }, async () => {\n\t      await expect(createType('ISomeTypeName')).rejects.toThrow('Missing ts.typeDir.');\n\t    });\n", "  });\n\t  test('should throw error if typeName does not follow the required format', async () => {\n\t    await expect(createType('invalidTypeName')).rejects.toThrowError();\n\t  });\n\t  test('should generate the type correctly and append it to the file', async () => {\n\t    await withOriginalGetConfig(async () => {\n\t      const typeName = 'ITestType';\n\t      const generatedType = 'Test Type';\n\t      const config = getConfig();\n\t      useAiMock.mockResolvedValue({ message: generatedType });\n", "      const coreTypesPath = sanitizeName(config.ts.typeDir);\n\t      const typeFilePath = getPathOf(`${coreTypesPath}/${toSnakeCase(typeName)}.ts`);\n\t      const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;\n\t      (fs.existsSync as jest.Mock).mockReturnValue(false);\n\t      await createType(typeName);\n\t      // Check if the directory was created\n\t      expect(fs.existsSync).toHaveBeenCalledWith(coreTypesPath);\n\t      expect(fs.mkdirSync).toHaveBeenCalledWith(coreTypesPath, { recursive: true });\n\t      // Check if the file was written correctly\n\t      expect(fs.writeFileSync).toHaveBeenCalledWith(typeFilePath, `${comment}${generatedType}\\n\\n`);\n", "    });\n\t  });\n\t});\n"]}
{"filename": "test/testHelpers.ts", "chunked_list": ["import fs from 'fs';\n\timport { setConfig, defaultConfig, configFilePath } from '../src/server/config';\n\timport type { Config } from '../src/lib/types';\n\timport { SyntaxKind } from 'ts-morph';\n\timport { generateTempFilePath, getDirPathOf } from '../src/server/util';\n\tlet chatResponseContent: string;\n\tlet completionResponseText: string;\n\tlet moderationResponseFlagged: boolean;\n\texport let openai: Record<string, ReturnType<ReturnType<typeof jest.fn>['mockResolvedValue']>>;\n\texport function setupOpenAiMocks({ chat, completion, moderation }: { chat?: string, completion?: string, moderation?: string }) {\n", "  openai = {\n\t    createChatCompletion: jest.fn().mockResolvedValue({\n\t      data: { choices: [{ message: { content: chat || chatResponseContent } }] },\n\t    }),\n\t    createCompletion: jest.fn().mockReturnValue({\n\t      data: { choices: [{ text: completion || completionResponseText }] },\n\t    }),\n\t    createModeration: jest.fn().mockReturnValue({\n\t      data: { results: [{ flagged: moderation || moderationResponseFlagged }] },\n\t    }),\n", "  };\n\t}\n\texport function setupCommonMocks() {\n\t  setupOpenAiMocks({});\n\t  jest.mock('openai', () => ({\n\t    OpenAIApi: jest.fn().mockImplementation(() => openai),\n\t  }));\n\t  jest.mock('ts-morph', () => ({\n\t    // Mock the ts-morph library's methods here.\n\t    Project: jest.fn().mockImplementation(() => ({\n", "      addSourceFileAtPath: jest.fn().mockReturnValue({}),\n\t      getSourceFile: jest.fn().mockReturnValue({}),\n\t      save: jest.fn(),\n\t      // ...mock other methods if needed\n\t    })),\n\t    SyntaxKind: jest.fn().mockReturnValue({}),\n\t    FunctionDeclaration: jest.fn(),\n\t    Node: jest.fn()\n\t  }));\n\t}\n", "export function setupChatResponse(content: string) {\n\t  chatResponseContent = content;\n\t}\n\texport function setupCompletionResponse(text: string) {\n\t  completionResponseText = text;\n\t}\n\texport function setupModerationResponse(flagged: boolean) {\n\t  moderationResponseFlagged = flagged;\n\t}\n\texport function generateTempConfigPath() {\n", "  const configDirPath = getDirPathOf(configFilePath);\n\t  return generateTempFilePath(configDirPath, `test-config`);\n\t}\n\texport function setupConfigTestBefore(testConfig?: Config) {\n\t  const updatedConfig = Object.assign(defaultConfig, (testConfig || {}));\n\t  setConfig(updatedConfig);\n\t  // Reset the config file to default values before each test using a custom test file\n\t  const tempConfigPath = generateTempConfigPath();\n\t  fs.writeFileSync(tempConfigPath, JSON.stringify(updatedConfig, null, 2));\n\t  return tempConfigPath;\n", "}\n\texport function setupConfigTestAfter(tempConfigPath: string) {\n\t  // Clean up the config file after each test\n\t  if (fs.existsSync(tempConfigPath)) {\n\t    fs.unlinkSync(tempConfigPath);\n\t  }\n\t}\n\texport function mockGetConfig(tempConfigPath: string) {\n\t  jest.resetModules();\n\t  jest.mock('../src/config', () => {\n", "    const original = jest.requireActual('../src/config');\n\t    return {\n\t      ...original,\n\t      getConfig: () => original.getConfigFromPath(tempConfigPath),\n\t    };\n\t  });\n\t}\n\texport async function withTempConfig(tempConfig: Config, testFunc: () => Promise<void>) {\n\t  const tempConfigPath = setupConfigTestBefore(tempConfig);\n\t  mockGetConfig(tempConfigPath);\n", "  try {\n\t    await testFunc();\n\t  } finally {\n\t    setupConfigTestAfter(tempConfigPath);\n\t  }\n\t}\n\texport function withOriginalGetConfig(testFunc: () => Promise<void>) {\n\t  jest.resetModules(); // Clear the Jest module cache\n\t  try {\n\t    return testFunc();\n", "  } finally {\n\t    jest.resetModules(); // Clear the Jest module cache again after the test execution\n\t  }\n\t}\n\texport function createMockStatement(text: string, kind: SyntaxKind) {\n\t  return {\n\t    getText: () => text,\n\t    getFullText: () => text,\n\t    getKind: () => kind,\n\t    getParent: () => null,\n", "  };\n\t}"]}
{"filename": "test/createComponent.test.ts", "chunked_list": ["import fs from 'fs';\n\timport { createComponent } from '../src/server/spells/create_component_spell';\n\timport * as useAiModule from '../src/server/spells/use_ai_spell';\n\timport { setupConfigTestAfter, setupConfigTestBefore, withOriginalGetConfig, withTempConfig } from './testHelpers';\n\timport { getPathOf, sanitizeName } from '../src/server/util';\n\timport { getConfig } from '../src/server/config';\n\tjest.mock('fs', () => ({\n\t  ...jest.requireActual('fs'),\n\t  writeFileSync: jest.fn(),\n\t  existsSync: jest.fn(),\n", "  mkdirSync: jest.fn()\n\t}));\n\tjest.mock('../src/server/spells/use_ai_spell', () => ({\n\t  useAi: jest.fn(),\n\t}));\n\tconst useAiMock = useAiModule.useAi as jest.Mock;\n\tdescribe('createComponent', () => {\n\t  let tempConfigPath = '';\n\t  beforeEach(() => {\n\t    tempConfigPath = setupConfigTestBefore({ ts: { compDir: 'components', configPath: 'tsconfig.json' } });\n", "    useAiMock.mockClear();\n\t  });\n\t  afterEach(() => {\n\t    setupConfigTestAfter(tempConfigPath);\n\t  });\n\t  test('should throw error when ts.compDir is not set', async () => {\n\t    await withTempConfig({ ts: { compDir: '', configPath: 'tsconfig.json' } }, async () => {\n\t      await expect(createComponent('Create a test component', 'user123')).rejects.toThrow('Missing ts.compDir.');\n\t    });\n\t  });\n", "  test('should create a new component', async () => {\n\t    await withOriginalGetConfig(async () => {\n\t      const config = getConfig();\n\t      const componentName = 'TestComponent';\n\t      const componentContent = `\n\t          import React from 'react';\n\t          function ${componentName}() {\n\t            return <div>${componentName}</div>;\n\t          }\n\t          export default ${componentName};\n", "        `;\n\t      useAiMock.mockResolvedValue({ message: componentContent });\n\t      fs.writeFileSync = jest.fn()\n\t      await createComponent('Create a test component', 'user123');\n\t      const coreCompsPath = sanitizeName(config.ts.compDir);\n\t      const compFileDir = getPathOf(`${coreCompsPath}/${componentName}.tsx`);\n\t      const comment = `/* Created by user123, Create a test component */\\n`;\n\t      // Check if the directory was created\n\t      expect(fs.existsSync).toHaveBeenCalledWith(coreCompsPath);\n\t      expect(fs.mkdirSync).toHaveBeenCalledWith(coreCompsPath, { recursive: true });\n", "      expect(fs.writeFileSync).toHaveBeenCalledWith(compFileDir, `${comment}${componentContent}`)\n\t    });\n\t  });\n\t  test('should return an error message if the component cannot be created', async () => {\n\t    const invalidComponentContent = `import React from 'react';`;\n\t    useAiMock.mockResolvedValue({ message: invalidComponentContent });\n\t    const result = await createComponent('Create an invalid component', 'user123');\n\t    expect(result).toBe('unable to create a component ' + invalidComponentContent);\n\t  });\n\t});\n"]}
{"filename": "test/logAiResult.test.ts", "chunked_list": ["import fs from 'fs';\n\timport { ChatResponse } from '../src/lib/types';\n\timport { IPrompts } from '../src/lib/prompts';\n\timport { logAiResult } from '../src/server/stats';\n\timport { GuidedEditResponse } from '../src/lib/prompts/guided_edit_prompt';\n\tdescribe('logAiResult', () => {\n\t  const logFilePath = './testLogFile.log';\n\t  const configSpy = jest.spyOn(require('../src/server/config'), 'getConfig');\n\t  configSpy.mockReturnValue({ ai: { logFile: logFilePath } });\n\t  afterEach(() => {\n", "    if (fs.existsSync(logFilePath)) {\n\t      fs.unlinkSync(logFilePath);\n\t    }\n\t  });\n\t  test('should append a line to the log file with the correct metrics', () => {\n\t    const chatResponse: ChatResponse<GuidedEditResponse> = {\n\t      successful: true,\n\t      timestamp: new Date(),\n\t      failures: [''],\n\t      rawResponses: [''],\n", "      prompts: ['test'],\n\t      model: 'testModel',\n\t      message: [{ \"above_9\": \"yep\" }],\n\t      supportingText: 'testSupportingText',\n\t      promptTemplate: 'testTemplate',\n\t      promptType: IPrompts.GUIDED_EDIT,\n\t    };\n\t    const expectedLogLine = {\n\t      pass: chatResponse.successful,\n\t      timestamp: chatResponse.timestamp.toISOString(),\n", "      duration: expect.any(Number),\n\t      prompts: chatResponse.prompts,\n\t      model: chatResponse.model,\n\t      data: { message: chatResponse.message, supportingText: chatResponse.supportingText },\n\t      failures: chatResponse.failures,\n\t      rawResponses: chatResponse.rawResponses,\n\t      template: chatResponse.promptTemplate,\n\t      type: chatResponse.promptType,\n\t    };\n\t    logAiResult<GuidedEditResponse>(chatResponse);\n", "    const logFileContent = fs.readFileSync(logFilePath, { encoding: 'utf-8' });\n\t    const loggedMetrics = JSON.parse(logFileContent);\n\t    console.log({ expectedLogLine, loggedMetrics })\n\t    expect(loggedMetrics).toEqual(expectedLogLine);\n\t  });\n\t});"]}
{"filename": "test/config.test.ts", "chunked_list": ["import fs from 'fs';\n\timport { getConfig, defaultConfig } from '../src/server/config';\n\timport type { Config } from '../src/lib/types';\n\timport { setupConfigTestBefore, setupConfigTestAfter, withTempConfig, withOriginalGetConfig } from './testHelpers';\n\tdescribe('getConfig', () => {\n\t  let tempConfigPath = '';\n\t  beforeEach(() => {\n\t    tempConfigPath = setupConfigTestBefore();\n\t  });\n\t  afterEach(() => {\n", "    setupConfigTestAfter(tempConfigPath);\n\t  });  \n\t  it('returns default config values when config file does not exist', async () => {\n\t    // Remove the config file\n\t    await withOriginalGetConfig(async () => {\n\t      await withTempConfig(defaultConfig, async () => {\n\t        fs.unlinkSync(tempConfigPath);\n\t        const config = getConfig();\n\t        expect(config).toEqual(defaultConfig);\n\t      })\n", "    });\n\t  });\n\t  it('returns config values when config file exists', async () => {\n\t    const expectedConfig: Config = {\n\t      ai: { retries: '3', logFile: 'results.json' },\n\t      ts: { configPath: 'config', typeDir: 'types', compDir: 'components' },\n\t      git: { rootPath: 'root', source: 'dev', remote: 'origin' },\n\t      user: { name: 'John Doe' },\n\t    };\n\t    await withOriginalGetConfig(async () => {\n", "      await withTempConfig(expectedConfig, async () => {\n\t        const config = getConfig();\n\t        expect(config).toEqual(expectedConfig);\n\t      });\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/createApi.test.ts", "chunked_list": ["import fs from 'fs';\n\timport { getPathOf, sanitizeName, toSnakeCase, toTitleCase } from '../src/server/util';\n\timport {\n\t  setupChatResponse,\n\t  setupCommonMocks,\n\t  setupConfigTestBefore,\n\t  setupConfigTestAfter,\n\t  mockGetConfig,\n\t  withTempConfig,\n\t  withOriginalGetConfig,\n", "} from './testHelpers';\n\timport * as useAiModule from '../src/server/spells/use_ai_spell';\n\tsetupChatResponse('const testTypeApi = { ...');\n\tsetupCommonMocks();\n\timport { createApi } from '../src/server/spells';\n\timport { getConfig } from '../src/server/config';\n\tjest.mock('fs', () => ({\n\t  ...jest.requireActual('fs'),\n\t  appendFileSync: jest.fn(),\n\t}));\n", "jest.mock('../src/server/spells/use_ai_spell', () => ({\n\t  useAi: jest.fn(),\n\t}));\n\tconst useAiMock = useAiModule.useAi as jest.Mock;\n\tdescribe('createApi', () => {\n\t  let tempConfigPath = '';\n\t  beforeEach(() => {\n\t    tempConfigPath = setupConfigTestBefore({ ai: { retries : '3' }, ts: { typeDir: 'types', configPath: 'tsconfig.json' } });\n\t    mockGetConfig(tempConfigPath);\n\t    useAiMock.mockClear();\n", "  });\n\t  afterEach(() => {\n\t    setupConfigTestAfter(tempConfigPath);\n\t  });\n\t  test('should work by passing normal parameters for chat completion', async () => {\n\t    useAiMock.mockResolvedValue({ message: 'const testTypeApi = { ...' });\n\t    const response = await createApi('ITestTypeName', 'userName');\n\t    expect(useAiMock).toHaveBeenCalled();\n\t    expect(response).toBe('const testTypeApi = { ...');\n\t  });\n", "  test('should throw error when ts.typeDir is not set', async () => {\n\t    await withTempConfig({ ai: { retries: '3' }, ts: { configPath: 'tsconfig.json' } }, async () => {\n\t      await expect(createApi('ITestTypeName', 'userName')).rejects.toThrow('Missing ts.typeDir.');\n\t    });\n\t  });\n\t  test('should append the generated API to the correct file', async () => {\n\t    await withOriginalGetConfig(async () => {\n\t      await withTempConfig({ ai: { retries: '3' }, ts: { typeDir: 'types' } }, async () => {\n\t        const config = getConfig();\n\t        const typeName = 'ITestTypeName';\n", "        const generatedType = 'type ITestTypeName = {';\n\t        const coreTypesPath = sanitizeName(config.ts.typeDir);\n\t        const typeFilePath = getPathOf(`${coreTypesPath}/${toSnakeCase(typeName)}.ts`);\n\t        const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;\n\t        const generatedApi = 'const testTypeApi = { ...';\n\t        await createApi(typeName, generatedType);\n\t        expect(fs.appendFileSync).toHaveBeenCalledWith(typeFilePath, `${comment}${generatedApi}\\n\\n`);\n\t      });\n\t    });\n\t  });\n", "});\n"]}
{"filename": "test/useAi.test.ts", "chunked_list": ["import { IPrompts } from '../src/lib/prompts';\n\timport { setupCommonMocks, setupChatResponse, setupCompletionResponse, setupModerationResponse, openai, setupConfigTestBefore, setupConfigTestAfter } from './testHelpers';\n\tsetupChatResponse('&&&Some text@@@[{ \"statement_0\": \"some code \" }]@@@Some other text&&&');\n\tsetupCompletionResponse('test completion response');\n\tsetupModerationResponse(false);\n\tsetupCommonMocks();\n\tjest.mock('fs', () => ({\n\t  ...jest.requireActual('fs'),\n\t  appendFileSync: jest.fn()\n\t}));\n", "import { useAi } from '../src/server/spells/use_ai_spell';\n\timport { GuidedEditResponse } from '../src/lib/prompts/guided_edit_prompt';\n\tdescribe('useAi', () => {\n\t  let tempConfigPath = '';\n\t  beforeEach(() => {\n\t    tempConfigPath = setupConfigTestBefore({ ai: { retries: '3' }, ts: { typeDir: '../../types', configPath: 'tsconfig.json' } });\n\t    jest.clearAllMocks();\n\t  });\n\t  afterEach(() => {\n\t    setupConfigTestAfter(tempConfigPath);\n", "  });\n\t  test('should return a chat response when promptType is a chat prompt', async () => {\n\t    const response = await useAi<GuidedEditResponse>(IPrompts.GUIDED_EDIT, 'Profile.tsx make the profile picture round instead of square.');\n\t    expect(response.message).toStrictEqual([{ \"statement_0\": \"some code \"}]);\n\t  });\n\t  test('should return a completion response when promptType is a completion prompt', async () => {\n\t    const response = await useAi<string>(IPrompts.SUGGEST_SERVICE, 'the downtown learning center at the U library');\n\t    expect(response.message).toBe('test completion response');\n\t  });\n\t  test('should return a moderation response when promptType is not provided', async () => {\n", "    const response = await useAi<boolean>(undefined, 'test');\n\t    expect(response.flagged).toBe(false);\n\t  });\n\t  test('should throw an error when all parsing attempts fail', async () => {\n\t    openai.createChatCompletion.mockImplementation(() => ({\n\t      data: { choices: [{ message: { content: '&&&Some text@invalid json}@@@Some other text&&&' } }] },\n\t    }));\n\t    await expect(useAi<GuidedEditResponse>(IPrompts.GUIDED_EDIT, 'testfile.tsx', 'add comments throughout the file')).rejects.toThrowError();\n\t  });\n\t});\n"]}
{"filename": "test/createApiBackend.test.ts", "chunked_list": ["import * as useAiModule from '../src/server/spells/use_ai_spell';\n\timport { getConfig } from '../src/server/config';\n\timport { setupConfigTestBefore, setupConfigTestAfter, withTempConfig } from './testHelpers';\n\timport { getPathOf, toSnakeCase, toTitleCase } from '../src/server/util';\n\timport { Project } from 'ts-morph';\n\tjest.mock('fs', () => ({\n\t  ...jest.requireActual('fs'),\n\t  appendFileSync: jest.fn(),\n\t}));\n\t// Mock the useAi function\n", "jest.mock('../src/server/spells/use_ai_spell', () => ({\n\t  useAi: jest.fn(),\n\t}));\n\tconst useAiMock = useAiModule.useAi as jest.Mock;\n\timport { createApiBackend } from '../src/server/spells';\n\tdescribe('createApiBackend', () => {\n\t  let tempConfigPath = '';\n\t  beforeEach(() => {\n\t    tempConfigPath = setupConfigTestBefore({ ts: { typeDir: 'types', configPath: 'tsconfig.json' } });\n\t  });\n", "  afterEach(() => {\n\t    setupConfigTestAfter(tempConfigPath);\n\t  });\n\t  test('should throw error when ts.configPath is not set', async () => {\n\t    await withTempConfig({ ts: { configPath: '' } }, async () => {\n\t      await expect(createApiBackend('ISomeTypeName', 'GeneratedType')).rejects.toThrow('Missing ts.configPath.');\n\t    });\n\t  });\n\t  test('should generate the API backend correctly and append it to the file', async () => {\n\t    await withTempConfig({ ts: { typeDir: 'types', configPath: 'tsconfig.json' } }, async () => {\n", "      const typeName = 'ITestType';\n\t      const generatedType = 'GeneratedType';\n\t      const config = getConfig();\n\t      useAiMock.mockResolvedValue({ message: generatedType });\n\t      const coreTypesPath = getPathOf(`${config.ts.configPath}/${toSnakeCase(typeName)}.ts`);\n\t      const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;\n\t      const addSourceFileAtPathMock = jest.fn().mockReturnValue({\n\t        getVariableDeclarations: jest.fn().mockReturnValue([]),\n\t        insertText: jest.fn(),\n\t        fixMissingImports: jest.fn(),\n", "        getEnd: jest.fn()\n\t      });\n\t      const saveMock = jest.fn();\n\t      jest.spyOn(Project.prototype, 'addSourceFileAtPath').mockImplementation(addSourceFileAtPathMock);\n\t      jest.spyOn(Project.prototype, 'save').mockImplementation(saveMock);\n\t      // Re-import the project module to use the mocked version\n\t      jest.resetModules();\n\t      require('ts-morph');\n\t      await createApiBackend(typeName, generatedType);\n\t      const project = new Project();\n", "      const sourceFile = project.addSourceFileAtPath(coreTypesPath);\n\t      expect(sourceFile).toBeTruthy();\n\t      expect(sourceFile.insertText).toHaveBeenCalledWith(sourceFile.getEnd(), `${comment}${generatedType}\\n\\n`);\n\t      expect(sourceFile.fixMissingImports).toHaveBeenCalled();\n\t      expect(project.save).toHaveBeenCalled();\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/request.test.ts", "chunked_list": ["import { openai, setupChatResponse, setupCompletionResponse, setupModerationResponse, setupCommonMocks } from './testHelpers';\n\tsetupChatResponse('&&&Some text@@@[{ \"statement_0\": \"some code \" }]@@@Some other text&&&');\n\tsetupCompletionResponse('test completion response');\n\tsetupModerationResponse(false);\n\tsetupCommonMocks();\n\timport { buildOpenAIRequest, performRequest, openAIRequestOptions } from '../src/server/request';\n\timport { CreateModerationRequest, CreateChatCompletionRequest, CreateCompletionRequest } from 'openai';\n\timport { IPrompts } from '../src/lib/prompts';\n\timport { isChatRequest } from '../src/server/util';\n\tdescribe('buildOpenAIRequest', () => {\n", "  test('should return moderation request when promptType is not provided', () => {\n\t    const prompts = ['test'];\n\t    const [result] = buildOpenAIRequest(prompts);\n\t    const expected: CreateModerationRequest = {\n\t      input: prompts[0],\n\t    };\n\t    expect(result).toEqual(expected);\n\t  });\n\t  test('should return chat request when promptType is provided and a chat request is expected', () => {\n\t    const prompts = ['test'];\n", "    const [result] = buildOpenAIRequest(prompts, IPrompts.CREATE_API);\n\t    expect(isChatRequest(result)).toBeTruthy();\n\t  });\n\t});\n\tdescribe('performRequest', () => {\n\t  const chatRequest: CreateChatCompletionRequest = {\n\t    model: 'gpt-3.5-turbo',\n\t    messages: [{ role: 'system', content: 'test' }],\n\t  };\n\t  const completionRequest: CreateCompletionRequest = {\n", "    model: 'ada',\n\t    prompt: 'test'\n\t  };\n\t  const moderationRequest: CreateModerationRequest = {\n\t    input: 'test'\n\t  };\n\t  test('should call createChatCompletion for chat requests', async () => {\n\t    await performRequest(chatRequest);\n\t    expect(openai.createChatCompletion).toHaveBeenCalledWith(chatRequest, openAIRequestOptions);\n\t  });\n", "  test('should call createCompletion for completion requests', async () => {\n\t    await performRequest(completionRequest);\n\t    expect(openai.createCompletion).toHaveBeenCalledWith(completionRequest, openAIRequestOptions);\n\t  });\n\t  test('should call createModeration for moderation requests', async () => {\n\t    await performRequest(moderationRequest);\n\t    expect(openai.createModeration).toHaveBeenCalledWith(moderationRequest, openAIRequestOptions);\n\t  });\n\t  test('should return chat response for chat requests', async () => {\n\t    const response = await performRequest(chatRequest);\n", "    expect(response).toEqual('&&&Some text@@@[{ \"statement_0\": \"some code \" }]@@@Some other text&&&');\n\t  });\n\t  test('should return completion response for completion requests', async () => {\n\t    const response = await performRequest(completionRequest);\n\t    expect(response).toEqual('test completion response');\n\t  });\n\t  test('should return moderation response for moderation requests', async () => {\n\t    const response = await performRequest(moderationRequest);\n\t    expect(response).toEqual(false);\n\t  });\n", "});\n"]}
{"filename": "src/lib/languages.ts", "chunked_list": ["import type { LanguageParser } from \"./types\";\n\tconst languages: Record<string, LanguageParser> = {\n\t  Ada: {\n\t    fileExtension: [\"adb\", \"ads\"],\n\t    parserName: \"tree-sitter-ada\",\n\t  },\n\t  Agda: {\n\t    fileExtension: [\"agda\"],\n\t    parserName: \"tree-sitter-agda\",\n\t  },\n", "  Apex: {\n\t    fileExtension: [\"cls\", \"trigger\"],\n\t    parserName: \"tree-sitter-apex\",\n\t  },\n\t  Bash: {\n\t    fileExtension: [\"sh\", \"bash\"],\n\t    parserName: \"tree-sitter-bash\",\n\t  },\n\t  Beancount: {\n\t    fileExtension: [\"beancount\"],\n", "    parserName: \"tree-sitter-beancount\",\n\t  },\n\t  CapnProto: {\n\t    fileExtension: [\"capnp\"],\n\t    parserName: \"tree-sitter-capnp\",\n\t  },\n\t  C: {\n\t    fileExtension: [\"c\"],\n\t    parserName: \"tree-sitter-c\",\n\t  },\n", "  CPP: {\n\t    fileExtension: [\"cpp\", \"cc\", \"cxx\", \"c++\", \"h\", \"hpp\", \"hh\", \"hxx\", \"h++\"],\n\t    parserName: \"tree-sitter-cpp\",\n\t  },\n\t  CSharp: {\n\t    fileExtension: [\"cs\"],\n\t    parserName: \"tree-sitter-c-sharp\",\n\t  },\n\t  Clojure: {\n\t    fileExtension: [\"clj\", \"cljs\", \"cljc\", \"edn\"],\n", "    parserName: \"tree-sitter-clojure\",\n\t  },\n\t  CMake: {\n\t    fileExtension: [\"cmake\", \"CMakeLists.txt\"],\n\t    parserName: \"tree-sitter-cmake\",\n\t  },\n\t  // Comment: {\n\t  //   fileExtension: [\"unknown\"], // Not specific to any file extension\n\t  //   parserName: \"tree-sitter-comment\",\n\t  // },\n", "  CommonLisp: {\n\t    fileExtension: [\"lisp\", \"lsp\", \"l\", \"cl\", \"mud\"],\n\t    parserName: \"tree-sitter-commonlisp\",\n\t  },\n\t  CSS: {\n\t    fileExtension: [\"css\"],\n\t    parserName: \"tree-sitter-css\",\n\t  },\n\t  CUDA: {\n\t    fileExtension: [\"cu\", \"cuh\"],\n", "    parserName: \"tree-sitter-cuda\",\n\t  },\n\t  Dart: {\n\t    fileExtension: [\"dart\"],\n\t    parserName: \"tree-sitter-dart\",\n\t  },\n\t  D: {\n\t    fileExtension: [\"d\"],\n\t    parserName: \"tree-sitter-d\",\n\t  },\n", "  Dockerfile: {\n\t    fileExtension: [\"Dockerfile\"],\n\t    parserName: \"tree-sitter-dockerfile\",\n\t  },\n\t  DOT: {\n\t    fileExtension: [\"dot\"],\n\t    parserName: \"tree-sitter-graphviz\",\n\t  },\n\t  Elixir: {\n\t    fileExtension: [\"ex\", \"exs\"],\n", "    parserName: \"tree-sitter-elixir\",\n\t  },\n\t  Elm: {\n\t    fileExtension: [\"elm\"],\n\t    parserName: \"tree-sitter-elm\",\n\t  },\n\t  EmacsLisp: {\n\t    fileExtension: [\"el\"],\n\t    parserName: \"tree-sitter-emacs-lisp\",\n\t  },\n", "  Eno: {\n\t    fileExtension: [\"eno\"],\n\t    parserName: \"tree-sitter-eno\",\n\t  },\n\t  ERB_EJS: {\n\t    fileExtension: [\"erb\", \"ejs\"],\n\t    parserName: \"tree-sitter-embedded-template\",\n\t  },\n\t  Erlang: {\n\t    fileExtension: [\"erl\", \"hrl\"],\n", "    parserName: \"tree-sitter-erlang\",\n\t  },\n\t  Fennel: {\n\t    fileExtension: [\"fnl\"],\n\t    parserName: \"tree-sitter-fennel\"\n\t  },\n\t  Fish: {\n\t    fileExtension: [\"fish\"],\n\t    parserName: \"tree-sitter-fish\"\n\t  },\n", "  Fortran: {\n\t    fileExtension: [\"f\", \"f90\", \"f95\"],\n\t    parserName: \"tree-sitter-fortran\"\n\t  },\n\t  Gleam: {\n\t    fileExtension: [\"gleam\"],\n\t    parserName: \"tree-sitter-gleam\"\n\t  },\n\t  GLSL: {\n\t    fileExtension: [\"glsl\", \"vert\", \"frag\", \"geom\"],\n", "    parserName: \"tree-sitter-glsl\"\n\t  },\n\t  Go: {\n\t    fileExtension: [\"go\"],\n\t    parserName: \"tree-sitter-go\"\n\t  },\n\t  Graphql: {\n\t    fileExtension: [\"graphql\"],\n\t    parserName: \"tree-sitter-graphql\"\n\t  },\n", "  Hack: {\n\t    fileExtension: [\"hack\"],\n\t    parserName: \"tree-sitter-hack\"\n\t  },\n\t  Haskell: {\n\t    fileExtension: [\"hs\",\"lhs\"],\n\t    parserName: \"tree-sitter-haskell\"\n\t  },\n\t  HCL: {\n\t    fileExtension: [\"hcl\"],\n", "    parserName: \"tree-sitter-hcl\"\n\t  },\n\t  HTML: {\n\t    fileExtension: [\"html\"],\n\t    parserName: \"tree-sitter-html\"\n\t  },\n\t  Java: {\n\t    fileExtension: [\"java\"],\n\t    parserName: \"tree-sitter-java\"\n\t  },\n", "  JavaScript: {\n\t    fileExtension: [\"js\", \"jsx\"],\n\t    parserName: \"tree-sitter-javascript\"\n\t  },\n\t  jq: {\n\t    fileExtension: [\"jq\"],\n\t    parserName: \"tree-sitter-jq\"\n\t  },\n\t  JSON5: {\n\t    fileExtension: [\"json5\"],\n", "    parserName: \"tree-sitter-json5\"\n\t  },\n\t  JSON: {\n\t    fileExtension: [\"json\"],\n\t    parserName: \"tree-sitter-json\"\n\t  },\n\t  Julia: {\n\t    fileExtension: [\"jl\"],\n\t    parserName: \"tree-sitter-julia\"\n\t  },\n", "  Kotlin: {\n\t    fileExtension: [\"kt\", \"kts\"],\n\t    parserName: \"tree-sitter-kotlin\"\n\t  },\n\t  LALRPOP: {\n\t    fileExtension: [\"lalrpop\"],\n\t    parserName: \"tree-sitter-lalrpop\"\n\t  },\n\t  Latex: {\n\t    fileExtension: [\"tex\", \"sty\", \"cls\"],\n", "    parserName: \"tree-sitter-latex\"\n\t  },\n\t  Lean: {\n\t    fileExtension: [\"lean\"],\n\t    parserName: \"tree-sitter-lean\"\n\t  },\n\t  LLVM: {\n\t    fileExtension: [\"ll\"],\n\t    parserName: \"tree-sitter-llvm\"\n\t  },\n", "  LLVM_MachineIR: {\n\t    fileExtension: [\"mir\"],\n\t    parserName: \"tree-sitter-llvm-mir\"\n\t  },\n\t  LLVM_TableGen: {\n\t    fileExtension: [\"td\"],\n\t    parserName: \"tree-sitter-llvm-td\"\n\t  },\n\t  Lua: {\n\t    fileExtension: [\"lua\"],\n", "    parserName: \"tree-sitter-lua\"\n\t  },\n\t  Make: {\n\t    fileExtension: [\"makefile\"],\n\t    parserName: \"tree-sitter-make\"\n\t  },\n\t  Markdown: {\n\t    fileExtension: [\"md\", \"markdown\"],\n\t    parserName: \"tree-sitter-markdown\"\n\t  },\n", "  Meson: {\n\t    fileExtension: [\"meson.build\"],\n\t    parserName: \"tree-sitter-meson\"\n\t  },\n\t  Motorola68000Assembly: {\n\t    fileExtension: [\"s\"],\n\t    parserName: \"tree-sitter-m68k\"\n\t  },\n\t  Nix: {\n\t    fileExtension: [\"nix\"],\n", "    parserName: \"tree-sitter-nix\"\n\t  },\n\t  ObjectiveC: {\n\t    fileExtension: [\"m\", \"h\"],\n\t    parserName: \"tree-sitter-objc\"\n\t  },\n\t  OCaml: {\n\t    fileExtension: [\"ml\", \"mli\"],\n\t    parserName: \"tree-sitter-ocaml\"\n\t  },\n", "  Org: {\n\t    fileExtension: [\"org\"],\n\t    parserName: \"tree-sitter-org\"\n\t  },\n\t  Pascal: {\n\t    fileExtension: [\"pas\"],\n\t    parserName: \"tree-sitter-pascal\"\n\t  },\n\t  Perl: {\n\t    fileExtension: [\"pl\", \"pm\"],\n", "    parserName: \"tree-sitter-perl\"\n\t  },\n\t  PerlPOD: {\n\t    fileExtension: [\"pod\"],\n\t    parserName: \"tree-sitter-pod\"\n\t  },\n\t  PHP: {\n\t    fileExtension: [\"php\"],\n\t    parserName: \"tree-sitter-php\"\n\t  },\n", "  PowerShell: {\n\t    fileExtension: [\"ps1\"],\n\t    parserName: \"tree-sitter-powershell\"\n\t  },\n\t  ProtocolBuffers: {\n\t    fileExtension: [\"proto\"],\n\t    parserName: \"tree-sitter-protobuf\"\n\t  },\n\t  Python: {\n\t    fileExtension: [\"py\"],\n", "    parserName: \"tree-sitter-python\"\n\t  },\n\t  QML: {\n\t    fileExtension: [\"qml\"],\n\t    parserName: \"tree-sitter-qml\"\n\t  },\n\t  Racket: {\n\t    fileExtension: [\"rkt\"],\n\t    parserName: \"tree-sitter-racket\"\n\t  },\n", "  Rasi: {\n\t    fileExtension: [\"rasi\"],\n\t    parserName: \"tree-sitter-rofi\"\n\t  },\n\t  re2c: {\n\t    fileExtension: [\"re\"],\n\t    parserName: \"tree-sitter-re2c\"\n\t  },\n\t  Regex: {\n\t    fileExtension: [\"regex\"],\n", "    parserName: \"tree-sitter-regex\"\n\t  },\n\t  Rego: {\n\t    fileExtension: [\"rego\"],\n\t    parserName: \"tree-sitter-rego\"\n\t  },\n\t  reStructuredText: {\n\t    fileExtension: [\"rst\"],\n\t    parserName: \"tree-sitter-rst\"\n\t  },\n", "  R: {\n\t    fileExtension: [\"r\"],\n\t    parserName: \"tree-sitter-r\"\n\t  },\n\t  Ruby: {\n\t    fileExtension: [\"rb\"],\n\t    parserName: \"tree-sitter-ruby\"\n\t  },\n\t  Rust: {\n\t    fileExtension: [\"rs\"],\n", "    parserName: \"tree-sitter-rust\"\n\t  },\n\t  Scala: {\n\t    fileExtension: [\"scala\"],\n\t    parserName: \"tree-sitter-scala\"\n\t  },\n\t  Scheme: {\n\t    fileExtension: [\"scm\", \"ss\"],\n\t    parserName: \"tree-sitter-scheme\"\n\t  },\n", "  Scss: {\n\t    fileExtension: [\"scss\"],\n\t    parserName: \"tree-sitter-scss\"\n\t  },\n\t  Sexpressions: {\n\t    fileExtension: [\"sexp\"],\n\t    parserName: \"tree-sitter-sexp\"\n\t  },\n\t  Smali: {\n\t    fileExtension: [\"smali\"],\n", "    parserName: \"tree-sitter-smali\"\n\t  },\n\t  Sourcepawn: {\n\t    fileExtension: [\"sp\"],\n\t    parserName: \"tree-sitter-sourcepawn\"\n\t  },\n\t  SPARQL: {\n\t    fileExtension: [\"rq\"],\n\t    parserName: \"tree-sitter-sparql\"\n\t  },\n", "  SQL_BigQuery: {\n\t    fileExtension: [\"sql\"],\n\t    parserName: \"tree-sitter-sql\"\n\t  },\n\t  SQL_PostgreSQL: {\n\t    fileExtension: [\"pgsql\"],\n\t    parserName: \"tree-sitter-sql\"\n\t  },\n\t  SQL_SQLite: {\n\t    fileExtension: [\"sqlite\"],\n", "    parserName: \"tree-sitter-sql\"\n\t  },\n\t  SSH: {\n\t    fileExtension: [\"sshconfig\"],\n\t    parserName: \"tree-sitter-ssh\"\n\t  },\n\t  Svelte: {\n\t    fileExtension: [\"svelte\"],\n\t    parserName: \"tree-sitter-svelte\"\n\t  },\n", "  Swift: {\n\t    fileExtension: [\"swift\"],\n\t    parserName: \"tree-sitter-swift\"\n\t  },\n\t  SystemRDL: {\n\t    fileExtension: [\"rdl\"],\n\t    parserName: \"tree-sitter-systemrdl\"\n\t  },\n\t  Thrift: {\n\t    fileExtension: [\"thrift\"],\n", "    parserName: \"tree-sitter-thrift\"\n\t  },\n\t  TOML: {\n\t    fileExtension: [\"toml\"],\n\t    parserName: \"tree-sitter-toml\"\n\t  },\n\t  Turtle: {\n\t    fileExtension: [\"ttl\"],\n\t    parserName: \"tree-sitter-turtle\"\n\t  },\n", "  Twig: {\n\t    fileExtension: [\"twig\"],\n\t    parserName: \"tree-sitter-twig\"\n\t  },\n\t  TSX: {\n\t    fileExtension: [\"tsx\"],\n\t    parserName: \"tree-sitter-typescript\",\n\t    parserVariant: \"tsx\"\n\t  },\n\t  TypeScript: {\n", "    fileExtension: [\"ts\"],\n\t    parserName: \"tree-sitter-typescript\",\n\t    parserVariant: \"typescript\"\n\t  },\n\t  Verilog: {\n\t    fileExtension: [\"v\", \"sv\", \"svh\"],\n\t    parserName: \"tree-sitter-verilog\"\n\t  },\n\t  VHDL: {\n\t    fileExtension: [\"vhdl\", \"vhd\", \"vhf\", \"vhi\", \"vho\", \"vhs\", \"vht\", \"vhw\"],\n", "    parserName: \"tree-sitter-vhdl\"\n\t  },\n\t  Vue: {\n\t    fileExtension: [\"vue\"],\n\t    parserName: \"tree-sitter-vue\"\n\t  },\n\t  WASM: {\n\t    fileExtension: [\"wat\", \"wasm\"],\n\t    parserName: \"tree-sitter-wasm\"\n\t  },\n", "  YAML: {\n\t    fileExtension: [\"yaml\", \"yml\"],\n\t    parserName: \"tree-sitter-yaml\"\n\t  },\n\t  YANG: {\n\t    fileExtension: [\"yang\"],\n\t    parserName: \"tree-sitter-yang\"\n\t  },\n\t  Zig: {\n\t    fileExtension: [\"zig\"],\n", "    parserName: \"tree-sitter-zig\"\n\t  },\n\t}\n\texport default languages;"]}
{"filename": "src/lib/types.ts", "chunked_list": ["export type ConfigPropTypes = string;\n\texport type Config<T = Record<string, Record<string, ConfigPropTypes>>> = T;\n\texport type CurrentType = ConfigPropTypes | Config;\n\texport type GuardValidations = Record<string, unknown> | Record<string, unknown>[] | string\n\texport type OpenAIResults = {\n\t  model?: string;\n\t  timestamp: Date;\n\t  prompts?: string[];\n\t  promptType: string;\n\t  promptTemplate: string | undefined;\n", "  rawResponses: (string | boolean | undefined)[];\n\t  failures: string[];\n\t  successful: boolean;\n\t}\n\texport type ChatResponse<T> = OpenAIResults & {\n\t  supportingText?: string;\n\t  message: T;\n\t}\n\texport type CompletionResponse = OpenAIResults & {\n\t  message: string;\n", "}\n\texport type ModerationResponse = OpenAIResults & {\n\t  flagged: boolean;\n\t}\n\texport type UseAIResponses<T> = T extends boolean ? ModerationResponse : T extends undefined ? CompletionResponse : ChatResponse<T>;\n\texport interface Node {\n\t  type: string;\n\t  text: string;\n\t  children: Node[];\n\t}\n", "export type Language = {\n\t  grammar: any;\n\t  regexRules: {\n\t    [nodeType: string]: RegExp;\n\t  };\n\t};\n\texport interface Statements {\n\t  type: string;\n\t  text: string;\n\t}\n", "export interface LanguageParser {\n\t  fileExtension: string[];\n\t  parserName: string;\n\t  parserVariant?: string;\n\t}\n\texport interface Grammars {\n\t  name: string;\n\t  nodeTypeInfo: Grammar[];\n\t}\n\texport interface Grammar {\n", "  type: string;\n\t  named: boolean;\n\t  subtypes?: Grammar[];\n\t  fields?: Record<string, Field>;\n\t  children?: Children;\n\t}\n\texport interface Field {\n\t  multiple: boolean;\n\t  required: boolean;\n\t  types: TypeRef[];\n", "}\n\texport interface TypeRef {\n\t  type: string;\n\t  named: boolean;\n\t}\n\texport interface Children {\n\t  multiple: boolean;\n\t  required: boolean;\n\t  types: TypeRef[];\n\t}\n", "export type LinearizedStatement = {\n\t  i: number; // id\n\t  p?: number; // parentId\n\t  t: string; // type\n\t  c: string; // content\n\t};\n\texport type DefaultGrammarOrVariants = {\n\t  default: Grammars | {\n\t    [prop: string]: Grammars\n\t  }\n", "}"]}
{"filename": "src/lib/index.ts", "chunked_list": ["export * from './prompts';\n\texport * from './languages';\n\texport * from './util';\n\texport type {\n\t  Config,\n\t  ConfigPropTypes,\n\t  GuardValidations,\n\t  ChatResponse,\n\t  CompletionResponse,\n\t  ModerationResponse,\n", "  CurrentType,\n\t  DefaultGrammarOrVariants,\n\t  Language,\n\t  LinearizedStatement,\n\t  OpenAIResults,\n\t  UseAIResponses,\n\t  Children,\n\t  Field,\n\t  Grammar,\n\t  Grammars,\n", "  LanguageParser,\n\t  Node,\n\t  Statements,\n\t  TypeRef\n\t} from './types';"]}
{"filename": "src/lib/util.ts", "chunked_list": ["import type { ChatResponse, CompletionResponse, ConfigPropTypes, DefaultGrammarOrVariants, Grammars, GuardValidations, ModerationResponse } from \"./types\";\n\texport function isConfigNestedObject(obj: unknown): obj is Record<string, ConfigPropTypes> {\n\t  return typeof obj === 'object' && obj !== null;\n\t}\n\texport function isDefaultGrammar(obj: DefaultGrammarOrVariants): obj is { default: Grammars } {\n\t  return 'string' === typeof obj.default.name;\n\t}\n\texport function isDefaultGrammarVariants(obj: DefaultGrammarOrVariants): obj is { default: { [prop: string]: Grammars } } {\n\t  return 'undefined' === typeof obj.default.name;\n\t}\n", "export function isChatResponse<T>(obj: GuardValidations): obj is ChatResponse<T> {\n\t  return 'object' === typeof obj && 'message' in obj && Array.isArray(obj.message);\n\t}\n\texport function isCompletionResponse(obj: GuardValidations): obj is CompletionResponse {\n\t  return 'object' === typeof obj && 'message' in obj && 'string' === typeof obj.message;\n\t}\n\texport function isModerationResponse(obj: GuardValidations): obj is ModerationResponse {\n\t  return 'object' === typeof obj && 'input' in obj;\n\t}"]}
{"filename": "src/lib/prompts/create_type_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport type { GuardValidations } from \"../types\";\n\t// const createTypePrompt = 'Complete the following typescript type with 4-7 unconventionally named properties, using string, number or boolean, starting with its opening bracket, \"type ${prompt1} =';\n\t// const createTypeMessages = [\n\t//   { role: 'system', content: 'I, TypescriptTypeGeneratorGPT, respond with a code statement declaring a Typescript type, based on the name of a type.' },\n\t//   { role: 'assistant', content: `This message describes how \\${prompt1} will be generated and returned in the next message.\n\t//   1. Parse Name: You provided a name in the format of ITypeName, \\${prompt1}, which I will evaluate to determine its general informational context.\n\t//   2. Primary Action: Generate TYPE_DEFINITION of 4-7 unconventionally named properties.\n\t//   3. Primary Validation: TYPE_DEFINITION is validated as starting with text \"type \\${prompt1} = {\" with the rest of TYPE_DEFINITION to follow.\n\t//   4. Secondary Validation: Exact response text verified to be formatted in the following pattern:\n", "//   &&&\n\t//   @@@\n\t//   const \\${prompt1} = { type definition will appear here };\n\t//   @@@\n\t//   &&&\n\t//   ` }\n\t// ]\n\texport const createTypeMessages: ChatCompletionRequestMessage[] = [\n\t  { role: 'system', content: 'As a TypescriptTypeGeneratorGPT, generate a Typescript type definition for ${prompt1}.' },\n\t  { role: 'assistant', content: `Internal Process:\n", "  1. Generate: 4-7 uncommon English-language attribute names. \n\t  2. Format: Your response is formatted in the following enclosed structure:\n\t  &&&\n\t  {supporting text}\n\t  @@@\n\t  type \\${prompt1} = {generated type definition}\n\t  @@@\n\t  {left intentionally blank}\n\t  &&&\n\t  3. Validation: Response structure is re-validated to adhere to the formatting of step 2.`}\n", "];\n\texport type CreateTypeTypeName = `I${string}`;\n\texport type CreateTypeResponse = `type ${CreateTypeTypeName} =`;\n\texport function isCreateTypeResponse(obj: GuardValidations): boolean {\n\t  let createTypeResponseRegex = new RegExp(/type\\s+I\\w+\\s*=\\s*\\{/gm);\n\t  return 'string' === typeof obj && createTypeResponseRegex.test(obj);\n\t}\n"]}
{"filename": "src/lib/prompts/suggest_role_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport { generateExample, getSuggestionPrompt } from \"./prompt_utils\";\n\texport const suggestRoleMessagesOld = `${getSuggestionPrompt('role names for a group named ${prompt1} which is interested in ${prompt2}')}\n\t${generateExample('role names for a group named writing center which is interested in consulting on writing', 'Tutor|Student|Advisor|Administrator|Consultant')}\n\t${generateExample('role names for a group named city maintenance department which is interested in maintaining the facilities in the city', 'Dispatcher|Engineer|Administrator|Technician|Manager')}`;\n\texport const suggestRoleMessages: ChatCompletionRequestMessage[] = [\n\t  { role: 'system', content: 'I, DelimitedOptions, will provide 5 options delimited by |.' },\n\t  { role: 'assistant', content: `Simply provide your desired prompt, and I\\'ll fill in the result!\n\t  Here are some examples: ${suggestRoleMessagesOld}\n\t  Provide the following text \"Prompt: <some prompt> Result:\" and I will complete the result.` },\n", "  { role: 'user', content: generateExample('role names for a group named \"${prompt1}\" which is interested in ${prompt2}') }\n\t];"]}
{"filename": "src/lib/prompts/suggest_tier_prompt.ts", "chunked_list": ["import { generateExample, getSuggestionPrompt } from \"./prompt_utils\";\n\texport const suggestTierMessages = `${getSuggestionPrompt('service level names for ${prompt1}')}\n\t${generateExample('service level names for a generic service', 'Small|Medium|Large')}\n\t${generateExample('service level names for writing tutoring at a school writing center', 'WRI 1010|WRI 1020|WRI 2010|WRI 2020|WRI 3010')}\n\t${generateExample('service level names for streaming at a web media platform', 'Basic|Standard|Premium')}\n\t${generateExample('service level names for advising at a school learning center', 'ENG 1010|WRI 1010|MAT 1010|SCI 1010|HIS 1010')}\n\t${generateExample('service level names for travelling on an airline service', 'Economy|Business|First Class')}\n\t${generateExample('service level names for reading tutoring at a school reading center', 'ESL 900|ESL 990|ENG 1010|ENG 1020|ENG 2010')}\n\t${generateExample('service level names for ${prompt1}')}`;"]}
{"filename": "src/lib/prompts/prompt_utils.ts", "chunked_list": ["export function getSuggestionPrompt(prompt: string) {\n\t  return `Generate 5 ${prompt}; Result is 1-3 words separated by |. Here are some examples: `;\n\t}\n\texport function generateExample(prompt: string, result: string = '') {\n\t  return `Phrase: ${prompt}\\nResult: ${result}`;\n\t}\n\texport function hasSimilarKey(obj: Record<string, unknown>, regex: RegExp): boolean {\n\t  return Object.keys(obj).some(key => regex.test(key));\n\t}"]}
{"filename": "src/lib/prompts/file_editor_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport type { GuardValidations } from \"../types\";\n\t// const fileEditorPrompt = [\n\t//   { role: 'system', content: 'you are a helpful file editing assistant' },\n\t//   { role: 'user', content: 'edit ${prompt1} with regard to ${prompt2}. only show edited lines. remember to encase the edited code inside proper markdown \"```\" header. \\n\\n ${prompt1}:\\n${prompt3}' }\n\t// ];\n\texport const fileEditorMessages: ChatCompletionRequestMessage[] = [\n\t  { role: 'system', content: 'You, CodeCommenter, follow user instructions to add, edit, and delete text in specific ways, leaving change comments. You only reply with the line number + the change comment + the new content of the line. 3 possible static comments: \"/* change: added text */\", \"/* change: edited text */\", and \"/* change: fully removed text */\". Your reply includes only changed lines which have change comments, and clearly formats it in an anonymous markdown backtick block.' },\n\t  // { role: 'system', content: 'You reply with: \"I only edited line {number of each edited line}, so I am just going to show you {number of edited lines} lines, including empty lines:\"' },\n\t  { role: 'user', content: `add_text_example.txt\n", "instructions: put a happy face on line 4\n\t1. Lorem ipsum dolor sit amet.\n\t2. Lorem ipsum dolor sit amet.\n\t3. Lorem ipsum dolor sit amet.\n\t4. Lorem ipsum dolor sit amet.\n\t5. Lorem ipsum dolor sit amet.\n\t6. Lorem ipsum dolor sit amet.\n\t7. Lorem ipsum dolor sit amet.`},\n\t  { role: 'assistant', content: `1 text change signified: I edited line 4, which is 1 total edited line. Here is the 1 edited line containing a signifier, including its line number:  \n\t\\`\\`\\`\n", "4. Lorem ipsum dolor sit amet. :) /* change: added text */\n\t\\`\\`\\`\n\tPlease find the 1 change above this line.`},\n\t  { role: 'user', content: `remove_and_edit_text_example.js\n\tinstructions: remove any console logs. change ts.configPath to ts.configRoot\n\t1. const config = getConfig();\n\t2. if (!config.ts.compDir) {\n\t3.   console.log('hey');\n\t4.   throw new Error('Missing ts.compDir.')\n\t5. }\n", "6. \n\t7. if (!config.ts.configPath) {\n\t8.   console.log('testing removals');\n\t9.   throw new Error('Missing ts.configPath.')\n\t10. }`},\n\t  { role: 'assistant', content: `4 text changes signified: I edited lines 3, 7, 8, and 9, which is 4 total edited lines. Here are the 4 lines containing signifiers, including their line numbers:\n\t\\`\\`\\`\n\t3. /* change: fully removed text */\n\t7. if (!config.ts.configRoot) { /* change: edited text */\n\t8.   /* change: fully removed text */\n", "9.   throw new Error('Missing ts.configRoot.') /* change: edited text */\n\t\\`\\`\\`\n\tPlease find the 4 changes above this line.` },\n\t  { role: 'user', content: `\\${prompt1}\n\t\\${prompt2}\n\t\\${prompt3}`}\n\t];\n\t// const testSystem = 'you are a helpful typescript coding assistant';\n\t// const testPrompt = 'typescript code that ${prompt1}. only show completely working code. remember to encase your code inside proper markdown \"```typescript\" header, and on the next line, include a unique-description filename such as `#dice-counter.py`.'\n\tconst fileEditorResponseRegex = /^\\d+./igm;\n", "export type FileEditorResponse = `${number}. ${string}`;\n\texport function isFileEditorResult(obj: GuardValidations): boolean {\n\t  return 'string' === typeof obj && fileEditorResponseRegex.test(obj);\n\t}"]}
{"filename": "src/lib/prompts/guided_edit_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport type { GuardValidations } from \"../types\";\n\timport { hasSimilarKey } from \"./prompt_utils\";\n\t// const guidedEditPrompt = [\n\t//   { role: 'system', content: 'As CodeWhittler I transform STATEMENTS_JSON, deriving RESPONSE_ARRAY from TARGET_STATE modifications.' },\n\t//   { role: 'assistant', content: `Whittling Supplies Required:\n\t// - STATEMENTS_JSON: a JSON object with string keys and string Typescript code statement values\n\t// - TARGET_STATE: the desired state of the Typescript code statements\n\t// Carving Process:\n\t// I'll examine STATEMENTS_JSON object, consider TARGET_STATE, and return a carefully whittled RESPONSE_ARRAY array. This whittling process ensures that your application runs swiftly and efficiently.\n", "// Whittling Technique:\n\t// 1. Identify: TARGET_STATE_RELEVANCE is assigned to each STATEMENTS_JSON value.\n\t//   - Relevance is an internal measurement determining the liklihood that modifying the STATEMENTS_JSON value will contribute to TARGET_STATE.\n\t// 2. Filter: ACTION_ITEMS filters STATEMENTS_JSON based on TARGET_STATE_RELEVANCE.\n\t//   - Any Relevance: Include\n\t//   - No Relevance: Exclude\n\t// 3. Execute: Perform various tasks on ACTION_ITEMS to reach TARGET_STATE.\n\t//   - Update: Any ACTION_ITEMS may be updated.\n\t//   - Insert: New ACTION_ITEMS may be added with \"above_#\" or \"below_#\" as a key using an adjacent statement #. Inserted functionality (above_#/below_#) is positioned relative to an adjacent statement (eg. above_5 is a new statement above statement_5), or the beginning/end of file (eg. above_0 is a new statement at the start of the file).\n\t//   - Remove: Any ACTION_ITEMS value may be set to an empty string.\n", "// 4. Validate: ACTION_ITEMS are valid Typescript.\n\t// 5. Build: RESPONSE_ARRAY is a JSON array of objects { \"ACTION_ITEM_KEY\": \"ACTION_ITEMS[ACTION_ITEM_KEY]\" }.\n\t// 6. Build Validation: RESPONSE_ARRAY is a properly formatted and escaped JSON array.\n\t// Response Template:\n\t// All responses given by me follow this exact format enclosed in 3 ampersands.\n\t// &&&\n\t// <2 very short comments describing the overall changes>\n\t// The modified subset of keys: ...ACTION_ITEM_KEYS\n\t// @@@\n\t// [ ...RESPONSE_ARRAY ] // in string format for example: '[ { \"above_5\": \"inserted code statement\", \"statement_9\": \"existing modified code statement\", \"below_13\": \"inserted code statement\" }, ]'\n", "// @@@\n\t// &&&\n\t// Following Steps:\n\t// Provide the necessary context in the statements for me to carry out the modifications. Use the keywords STATEMENTS_JSON and TARGET_STATE to convey the required inputs:\n\t// TARGET_STATE --- <an english phrase with some coding terms>\n\t// STATEMENTS_JSON --- <a plain old javascript object (POJO)>\n\t// On receiving TARGET_STATE and STATEMENTS_JSON, I'll start whittling away on the STATEMENTS_JSON as needed, to achieve TARGET_STATE, in order to derive RESPONSE_ARRAY.`},\n\t//   { role: 'user', content: ' TARGET_STATE --- ${prompt1}\\n    STATEMENTS_JSON --- ${prompt2}' }\n\t// ];\n\t// const testSystem = 'you are a helpful typescript coding assistant';\n", "// const testPrompt = 'typescript code that ${prompt1}. only show completely working code. remember to encase your code inside proper markdown \"```typescript\" header, and on the next line, include a unique-description filename such as `#dice-counter.py`.'\n\texport const guidedEditMessages: ChatCompletionRequestMessage[] = [\n\t  { role: 'system', content: 'I change code from a JSON object to an array based on the target state.' },\n\t  { role: 'assistant', content: `What I need:\n\t  JSON object with code statements\n\t  Desired state of the code statements\n\t  What I do:\n\t  Check which statements in the JSON object can help reach the desired state.\n\t  Keep only useful statements.\n\t  Change the statements to reach the target state. I can update, insert, or remove statements.\n", "  Make sure the updated code is valid Typescript.\n\t  Create an array with the updated code.\n\t  Ensure the array is properly formatted.\n\t  Response format:\n\t  I'll provide the changes made in a specific format like this:\n\t  &&&\n\t  <2 short comments on changes>\n\t  Modified keys: ...KEYS\n\t  @@@\n\t  [ ...ARRAY ] // example: '[ { \"above_5\": \"new code\", \"statement_9\": \"changed code\", \"below_13\": \"new code\" }, ]'\n", "  @@@\n\t  &&&\n\t  Next steps:\n\t  Give me the desired state and JSON object with code statements using these keywords:\n\t  TARGET_STATE --- <phrase with code terms>\n\t  STATEMENTS_JSON --- <a simple JSON object>\n\t  I'll change the code in the JSON object to reach the target state and create the final array.`},\n\t  { role: 'user', content: ' TARGET_STATE --- ${prompt1}\\n STATEMENTS_JSON --- ${prompt2}' }\n\t];\n\texport type GuidedEditKeyPrefix = 'statement' | 'above' | 'below';\n", "export type GuidedEditKeys = `${GuidedEditKeyPrefix}_${number}`;\n\texport type GuidedEditResponse = Record<GuidedEditKeys, string>[];\n\texport function isGuidedEditResult(obj: GuardValidations): boolean {\n\t  return Array.isArray(obj) && obj.every(item => ['statement', 'above', 'below'].some(test => {\n\t    const guidedEditKey = new RegExp(`^${test}_\\\\d+$`);\n\t    return hasSimilarKey(item, guidedEditKey)\n\t  }));\n\t}"]}
{"filename": "src/lib/prompts/create_gen_component_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport type { GuardValidations } from \"../types\";\n\texport const createGenComponentMessages: ChatCompletionRequestMessage[] = [\n\t  { role: 'system', content: 'I, ReactiveAssembleGPT, assemble React components.' },\n\t  {\n\t    role: 'assistant', content: `Provide the description of a react component, and I will assemble it.\n\t  In the process of assembly, I may:\n\t    - Use these nodejs pacakges if needed: @date-io/dayjs, @mui/icons-material, @mui/material, @mui/material-next, @mui/x-data-grid, @mui/x-date-pickers, @react-keycloak/web, @reduxjs/toolkit, dayjs, history, keycloak-js, react, react-dom, react-dropzone, react-redux, react-router, react-router-dom, react-window, uuid.\n\t    - Utilize Material-UI components for all design related aspects.\n\t  Simply respond with the description of a react component, and I will try my best. If your idea is too complex, I may simplify it. Any issues I may encounter in formulating a concept, I will attempt to resolve personally. If you ask me to seek out sample data to use in the component, I will have no issue sourcing your data needs with custom public API resources that are already known to me.`},\n", "  { role: 'user', content: '${prompt1}' }\n\t];\n\tconst generalComponentResponseRegex = /export default/ig;\n\ttype GeneralComponentKey = string;\n\texport type GeneralComponentResponse = `export default function ${GeneralComponentKey}() {`;\n\texport function isGeneralComponentResponse(obj: GuardValidations): boolean {\n\t  return 'string' === typeof obj && generalComponentResponseRegex.test(obj);\n\t}"]}
{"filename": "src/lib/prompts/suggest_feature_prompt.ts", "chunked_list": ["import { generateExample, getSuggestionPrompt } from \"./prompt_utils\";\n\texport const suggestFeatureMessages = `${getSuggestionPrompt('features of ${prompt1}')}\n\t${generateExample('features of ENGL 1010 writing tutoring', 'Feedback|Revisions|Brainstorming|Discussion')}\n\t${generateExample('features of Standard gym membership', 'Full Gym Equipment|Limited Training|Half-Day Access')}\n\t${generateExample('features of Pro web hosting service', 'Unlimited Sites|Unlimited Storage|1TB Bandwidth|Daily Backups')}\n\t${generateExample('features of professional photography service', 'Next-Day Prints|High-quality digital photos|Retouching and editing|Choice of location|Choice of outfit changes')}\n\t${generateExample('features of ${prompt1}')}`;\n"]}
{"filename": "src/lib/prompts/create_api_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport type { GuardValidations } from \"../types\";\n\texport const createApiMessages: ChatCompletionRequestMessage[] = [\n\t  { role: 'system', content: 'TemplateTransferGPT transfers the qualities of type script types into Api templates.'},\n\t  { role: 'assistant', content: `I perform each step silently to my self, and then I will give you a response like in Sample Response:\n\t  1. Define Accepted API_RELATED_TYPE Input: type IDigitalWhiteboard = { manufacturer: string;  model: string;  screenSize: number;  resolution: string;  touchSensitive: boolean;  connectivity: string[];  interface: string;}\n\t  2. Assign API_TEMPLATE: const digitalWhiteboardApi = {\\n  postDigitalWhiteboard: {\\n    kind: EndpointType.MUTATION,\\n    url: 'digitalwhiteboards',\\n    method: 'POST',\\n    opts: {} as ApiOptions,\\n    queryArg: { manufacturer: '' as string;  model: '' as string; },\\n    resultType: {} as IDigitalWhiteboard }\\n  },\\n  putDigitalWhiteboard: {\\n    kind: EndpointType.MUTATION,\\n    url: 'digitalwhiteboards',\\n    method: 'PUT',\\n    opts: {} as ApiOptions,\\n    queryArg: { id: '' as string } as IDigitalWhiteboard,\\n    resultType: {} as IDigitalWhiteboard\\n  },\\n  getDigitalWhiteboards: {\\n    kind: EndpointType.QUERY,\\n    url: 'digitalwhiteboards',\\n    method: 'GET',\\n    opts: {} as ApiOptions,\\n    queryArg: {} as Void,\\n    resultType: [] as IDigitalWhiteboard[]\\n  },\\n  getDigitalWhiteboardById: {\\n    kind: EndpointType.QUERY,\\n    url: 'digitalwhiteboards/:id',\\n    method: 'GET',\\n    opts: {} as ApiOptions,\\n    queryArg: { id: '' as string },\\n    resultType: {} as IDigitalWhiteboard\\n  },\\n  deleteDigitalWhiteboard: {\\n    kind: EndpointType.MUTATION,\\n    url: 'digitalwhiteboards/:id',\\n    method: 'DELETE',\\n    opts: {} as ApiOptions,\\n    queryArg: { id: '' as string },\\n    resultType: { id : '' as string }\\n  },\\n  disableDigitalWhiteboard: {\\n    kind: EndpointType.MUTATION,\\n    url: 'digitalwhiteboards/:id/disable',\\n    method: 'PUT',\\n    opts: {} as ApiOptions,\\n    queryArg: { id: '' as string },\\n    resultType: { id: '' as string }\\n  }\\n} as const;\n\t  3. Parse Input: API_RELATED_TYPE is parsed for its attributes, context, and connotation.\n\t  4. Implement: RESPONSE_BODY is implemented as an API_TEMPLATE using details from API_RELATED_TYPE.\n\t  5. Verify: RESPONSE_BODY is verified as being a Typescript constant variable incorporating as const and type specified properties (id: '' as string), when applicable.\n", "  6. Response Technique:\n\t    6a. Begin the response with &&&\n\t    6b. Add short statement describing change\n\t    6c. Add @@@ immediately before RESPONSE_BODY\n\t    6d. Paste RESPONSE_BODY\n\t    6e. Add @@@ immediately after RESPONSE_BODY\n\t    6f. Add &&& after @@@\n\t  7. Validate Response: The response is a &&& block containing a @@@ block.\n\t  Sample Response:\n\t  &&&\n", "  {supporting text}\n\t  @@@\n\t  RESPONSE_BODY // eg. const customizedTypedApi = { transferred functionality customized around API_RELATED_TYPE }\n\t  @@@\n\t  {left intentionally blank}\n\t  &&&` },\n\t  { role: 'user', content: 'API_RELATED_TYPE=\\${prompt1}' }\n\t];\n\tconst createApiFormat = /^const\\s+\\w+Api\\s*=\\s*\\{/gim;\n\ttype CreateApiKey = string;\n", "export type CreateApiResult = `const ${CreateApiKey}Api =`;\n\texport function isCreateApiResult(obj: GuardValidations): obj is CreateApiResult {\n\t  return 'string' === typeof obj && createApiFormat.test(obj);\n\t}"]}
{"filename": "src/lib/prompts/create_api_backend_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport type { GuardValidations } from \"../types\";\n\texport const createApiBackendMessages: ChatCompletionRequestMessage[] = [\n\t  { role: 'system', content: 'I, TemplateTransferGPT, transfer the qualities of Typescript types into file templates.'},\n\t  { role: 'assistant', content: `I perform each step silently to my self, and then I will give you a response like in Sample Response:\n\t  1. Define Accepted FILE_RELATED_TYPE Input: type IUuidFiles = { id: string; parentUuid: string; fileId: string; } postUuidFile, putUuidFile, getUuidFiles, getUuidFileById, deleteUuidFile, disableUuidFile' }\n\t  2. Assign FILE_TEMPLATE: const uuidFilesApiHandlers: ApiHandler<typeof uuidFilesApi> = {\\n  postUuidFile: async props => {\\n    const { parentUuid: parent_uuid, fileId: file_id } = props.event.body;\\n    const { id } = await props.tx.one<IUuidFiles>(\\`\\n      INSERT INTO dbtable_schema.uuid_files (parent_uuid, file_id, created_on, created_sub)\\n      VALUES ($1, $2, $3, $4::uuid)\\n      RETURNING id\\n    \\`, [parent_uuid, file_id, utcNowString(), props.event.userSub]);\\n    \\n    return { id };\\n  },\\n  putUuidFile: async props => {\\n    const { id, parentUuid: parent_uuid, fileId: file_id } = props.event.body;\\n    const updateProps = buildUpdate({\\n      id,\\n      parent_uuid,\\n      file_id,\\n      updated_on: utcNowString(),\\n      updated_sub: props.event.userSub\\n    });\\n    await props.tx.none(\\`\\n      UPDATE dbtable_schema.uuid_files\\n      SET \\${updateProps.string}\\n      WHERE id = $1\\n    \\`, updateProps.array);\\n    return { id };\\n  },\\n  getUuidFiles: async props => {\\n    const uuidFiles = await props.db.manyOrNone<IUuidFiles>(\\`\\n      SELECT * FROM dbview_schema.enabled_uuid_files\\n    \\`);\\n    \\n    return uuidFiles;\\n  },\\n  getUuidFileById: async props => {\\n    const { id } = props.event.pathParameters;\\n    const response = await props.db.one<IUuidFiles>(\\`\\n      SELECT * FROM dbview_schema.enabled_uuid_files\\n      WHERE id = $1\\n    \\`, [id]);\\n    \\n    return response;\\n  },\\n  deleteUuidFile: async props => {\\n    const { id } = props.event.pathParameters;\\n    await props.tx.none(\\`\\n      DELETE FROM dbtable_schema.uuid_files\\n      WHERE id = $1\\n    \\`, [id]);\\n    \\n    return { id };\\n  },\\n  disableUuidFile: async props => {\\n    const { id, parentUuid: parent_uuid, fileId: file_id } = props.event.body;\\n    await props.tx.none(\\`\\n      UPDATE dbtable_schema.uuid_files\\n      SET enabled = false, updated_on = $3, updated_sub = $4\\n      WHERE parent_uuid = $1 AND file_id = $2\\n    \\`, [parent_uuid, file_id, utcNowString(), props.event.userSub]);\\n    return { id };\\n  },\\n} as const;\n\t  3. Parse Input: FILE_RELATED_TYPE is parsed for its attributes, context, and connotation.\n\t  4. Implement: RESPONSE_BODY is implemented as an API_TEMPLATE using details from FILE_RELATED_TYPE.\n\t  5. Verify: RESPONSE_BODY is verified as being a Typescript constant variable incorporating as const and defining .\n", "  6. Response Technique is the following verbatim text with variables replaced by <>: &&&@@@<RESPONSE_BODY>@@@&&&\n\t  7. Validate Response: The response returned to the user follows the exact format of Step 6: eg. &&&@@@const customizedApiHandlers: ApiHandler<typeof customizedApi> = {\\n transferred functionality customized around FILE_RELATED_TYPE\\n }@@@&&&` },\n\t  { role: 'user', content: 'FILE_RELATED_TYPE=\\${prompt1}' }\n\t];\n\tconst createApiFormat = /^const\\s+\\w+ApiHandlers:\\s+ApiHandler/gim;\n\ttype CreateApiBackendKey = string;\n\texport type CreateApiBackendResult = `const ${CreateApiBackendKey}ApiHandlers: ApiHandler`;\n\texport function isCreateApiBackendResult(obj: GuardValidations): obj is CreateApiBackendResult {\n\t  return 'string' === typeof obj && createApiFormat.test(obj);\n\t}"]}
{"filename": "src/lib/prompts/index.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport { convertPurposeMessages } from './convert_purpose_prompt';\n\timport { createApiBackendMessages } from './create_api_backend_prompt';\n\timport { createApiMessages } from './create_api_prompt';\n\timport { createAppComponentMessages } from './create_app_component_prompt';\n\timport { createGenComponentMessages } from './create_gen_component_prompt';\n\timport { createTypeMessages } from './create_type_prompt';\n\timport { fileEditorMessages } from './file_editor_prompt';\n\timport { guidedEditMessages } from './guided_edit_prompt';\n\timport { suggestFeatureMessages } from './suggest_feature_prompt';\n", "import { suggestRoleMessages } from './suggest_role_prompt';\n\timport { suggestServiceMessages } from './suggest_service_prompt';\n\timport { suggestTierMessages } from './suggest_tier_prompt';\n\timport { deriveInstructionMessages } from \"./derive_instruction_prompt\";\n\texport enum IPrompts {\n\t  CREATE_API = 'create_api',\n\t  CREATE_API_BACKEND = 'create_api_backend',\n\t  CREATE_TYPE = 'create_type',\n\t  CREATE_GEN_COMPONENT = 'create_gen_component',\n\t  CREATE_APP_COMPONENT = 'create_app_component',\n", "  DERIVE_INSTRUCTION = 'derive_instruction',\n\t  FILE_EDITOR = 'file_editor',\n\t  GUIDED_EDIT = 'guided_edit',\n\t  SUGGEST_ROLE = 'suggest_role',\n\t  SUGGEST_SERVICE = 'suggest_service',\n\t  SUGGEST_TIER = 'suggest_tier',\n\t  SUGGEST_FEATURE = 'suggest_feature',\n\t  CONVERT_PURPOSE = 'convert_purpose'\n\t}\n\ttype AiPrompts = Record<IPrompts, string | ChatCompletionRequestMessage[]>;\n", "export let aiPrompts: AiPrompts = {\n\t  [IPrompts.CONVERT_PURPOSE]: convertPurposeMessages,\n\t  [IPrompts.CREATE_API_BACKEND]: createApiBackendMessages,\n\t  [IPrompts.CREATE_API]: createApiMessages,\n\t  [IPrompts.CREATE_APP_COMPONENT]: createAppComponentMessages,\n\t  [IPrompts.CREATE_GEN_COMPONENT]: createGenComponentMessages,\n\t  [IPrompts.CREATE_TYPE]: createTypeMessages,\n\t  [IPrompts.DERIVE_INSTRUCTION]: deriveInstructionMessages,\n\t  [IPrompts.FILE_EDITOR]: fileEditorMessages,\n\t  [IPrompts.GUIDED_EDIT]: guidedEditMessages,\n", "  [IPrompts.SUGGEST_FEATURE]: suggestFeatureMessages,\n\t  [IPrompts.SUGGEST_ROLE]: suggestRoleMessages,\n\t  [IPrompts.SUGGEST_SERVICE]: suggestServiceMessages,\n\t  [IPrompts.SUGGEST_TIER]: suggestTierMessages\n\t};\n\texport function injectPrompts(prompts: Partial<AiPrompts>) {\n\t  aiPrompts = { ...aiPrompts, ...prompts };\n\t}"]}
{"filename": "src/lib/prompts/create_app_component_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\texport const createAppComponentMessages: ChatCompletionRequestMessage[] = [\n\t  { role: 'system', content: 'As .' },\n\t  {\n\t    role: 'user', content: `Decompress \"Compressed Types\"; review the decompressed Typescript type set; design a TSX React Functional Component primarily focusing on the Component Description resulting in a TSX code block; incorporate the optional decompressed types where applicable:\n\t  Compressed Types: U2Iκ⇒V|N)↔(κ:I)⇒V?I:N.VdNΔV:T.RmNΔK]:T[K].ApiEvt{rId,mth,url,🔓,uSub,srcIp,usrGrpRoles,pp,qp,Tbody}.ApiP{evt,db,lggr,rd,rdP,kcl,cmpl,tx}.AuthP{evt&{body:AuthB},db,rd,rdP,kcl,cmpl,tx}.IWh{prop}↔(AuthP)⇒P<void>.AuthB{id,cId,rId,ip,ssId,uId,tm,typ,det}.DbErr{schm,tbl,clmn,dType,cnstrnt}.ApiErRsp{prop}:uknw,rId.ApiIntEr{rsp{st:num},data{emsg}}.PrxKy{aSub,apClnt,grpRlAct,grpAdRls,apRls,rlCall}.RdPrx{args}⇒P<PrxKy>.IAsst{id,prompt,promptR}.KcSO{regroup}.StrUsr{sub}.ITrMsg{wrds,dur,ts,unm}.IBookTr{unm,msg}.IBooking{qId,qSub,trns}.ICont{id,nm,eml,phn}.ScRspMsgAttr{sdp,ice,fmt,prop}:str.Sndr{prRsp}.IExch{booking}.IFdbck{id,msg,grpNm,crOn,unm}.IFileTp{id,nm}.IFile{id,ftId,ftNm,nm,loc}.IField{l}.IFormTpl=Rec<IField[]>.IFormSubm=Rec<str[]>.IFormVrSnSubm{fVId,subm}.IFormVr{id,fId,fTpl,subm,crOn,crSub}.IForm{id,nm,vr,crOn,crSub}.IGrpForm{id,grpId,fId,grpNm}.IGrpRole{grpId,rlId,extId}.IGrpSchedDateSlot{ws,stT,sDate,schBrSlotId,hr,mn,tm}.IGrpSched{mstr,grpId,schId,grpNm}.IGrpSvcAdn{grpId}.IGrpSvc{grpId,grpNm,svcId,ids}.IGrpUsrSchedStubRepl{unm,slotD,stT,schBrSlotId,sTId,grpNm,qId}.IGrpUsrSchedStub{grpSchId,usrSchId,qId,slotD,stT,svcNm,tierNm,repl}.IGrpUsrSched{id,grpSchId,usrSchId,svcs,grpNm}.IGrpUsr{grpId,usrId,usrSub,extId,grpExtId,rlId,rlNm,grpNm}.IGrpUsrs=Rec<IGrpUsr>.IGrpRlAuthAct{act{id?,nm}}.IGrpRlActState{asgnmnts}.IGrp{id,extId,crSub,crOn,defRlId,alwdDmns,nm,prps,cde,usrCnt,rls,usrs,avGrpAsgnmnts,valid,ndChkNm,chkNm,chckedNm,err}.ILkp{id,nm}.IManageGrps=Rec<IGrp>.\n\t  Component Description: \\${prompt1}\n\t  Instructions:\n\t  1. Decompress \"Compresed Types\" to get the list of application-types, which may or may not be related to the description.\n\t  2. Do not include \"Compressed Types\" or the results of its decompression in the component.\n", "  3. When a type is required in a component, infer type name and attribute names as full-length titleized or camel-case English names of their compressed versions (e.g., IGroupUsers, groupAssignmentUsers). \n\t  4. Application-types are not required to be used in the component, but feel free to use them liberally if needed.\n\t  5. If an application-type is required in the component import it like ISampleType, from 'awayto/core'.\n\t  6. Use these nodejs pacakges if needed: @date-io/dayjs, @mui/icons-material, @mui/material, @mui/material-next, @mui/x-data-grid, @mui/x-date-pickers, @react-keycloak/web, @reduxjs/toolkit, dayjs, history, keycloak-js, react, react-dom, react-dropzone, react-redux, react-router, react-router-dom, react-window, uuid.\n\t  7. Use Reduxjs/toolkit auto generated react hooks with the \"sh\" variable; import sh from 'awayto/hooks' then use sh in the component, for example\n\t    - const { data } = sh.useTypeQuery()\n\t    - const [postType] = sh.usePostTypeMutation()\n\t  8. Utilize Material-UI components for all design related aspects.\n\t  9. Export the component as the default export and reply strictly only with the TSX surrounded in a code block.`}\n\t];"]}
{"filename": "src/lib/prompts/suggest_service_prompt.ts", "chunked_list": ["import { generateExample, getSuggestionPrompt } from \"./prompt_utils\";\n\texport const suggestServiceMessages = `${getSuggestionPrompt('gerund verbs performed for the purpose of ${prompt1}')}\n\t${generateExample('gerund verbs performed for the purpose of offering educational services to community college students', 'Tutoring|Advising|Consulting|Instruction|Mentoring')}\n\t${generateExample('gerund verbs performed for the purpose of providing banking services to the local area', 'Accounting|Financing|Securities|Financial Planning|Investing')}\n\t${generateExample('gerund verbs performed for the purpose of ${prompt1}')}`;"]}
{"filename": "src/lib/prompts/derive_instruction_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport type { GuardValidations } from \"../types\";\n\t// aHR0cHM6Ly9tYXJ0aW5mb3dsZXIuY29tL2FydGljbGVzLzIwMjMtY2hhdGdwdC14dS1oYW8uaHRtbA==\n\texport const deriveInstructionMessages: ChatCompletionRequestMessage[] = [\n\t  { role: 'system', content: '' },\n\t  { role: 'assistant', content: `{introduction}\n\t  The current system is a {system_name}. Tech stack: {tech_stack}. And {testing_tools}.\n\t  All codes should be written in the tech stack mentioned above. Requirements should be implemented as {architecture_pattern}.\n\t  {view_models_block}\n\t  {common_implementation_strategy}\n", "  Here is the common implementation strategy for the project:\n\t  {strategy_block_which_covers_strategies_relating_to_view_models}\n\t  {strategy_block_which_covers_strategies_relating_to_component_implementation}\n\t  {strategy_block_which_covers_strategies_relating_to_testing}\n\t  {patterns_to_follow}\n\t  Here are certain patterns that should be followed when implementing and testing the components:\n\t  {test_pattern_guideline_block_1}\n\t  {test_pattern_guideline_block_2}\n\t  {test_pattern_guideline_block_3}\n\t  {feature_requirement}\n", "  {feature_name}\n\t  Requirement:\n\t  {requirement_description}\n\t  {acceptance_criteria}\n\t  AC1: {criteria1_description}.\n\t  AC2: {criteria2_description}.\n\t  {solution_guidance}\n\t  Provide an overall solution following the guidance mentioned above. Hint, {solution_hint}. Don't generate code. Describe the solution and break it down into a task list based on the guidance mentioned above. We will refer to this task list as our master plan.`}\n\t];\n\tconst derivedInstructionResponseRegex = /export default function/igm;\n", "type DerivedInstructionKey = string;\n\texport type DerivedInstructionResponse = `export default function ${DerivedInstructionKey}() {`;\n\texport function isDerivedInstructionResponse(obj: GuardValidations): boolean {\n\t  return 'string' === typeof obj && derivedInstructionResponseRegex.test(obj);\n\t}"]}
{"filename": "src/lib/prompts/convert_purpose_prompt.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport type { GuardValidations } from \"../types\";\n\texport const convertPurposeMessages: ChatCompletionRequestMessage[] = [\n\t  { role: 'system', content: 'You respond with a single gerund phrase, 5 to 8 words, which will complete the user\\'s sentence. For example, \"walking in the sunshine with you\".' },\n\t  { role: 'assistant', content: 'Give me an incomplete sentence that I can complete with a gerund phrase. For example, if you said \"Our favorite past time is\", I might respond \"walking in the sunshine with you\"' },\n\t  { role: 'user', content: 'An organization named \"${prompt1}\" is interested in \"${prompt2}\" and their mission statement is' }\n\t];\n\texport type ConvertPurposeResult = string;\n\tconst convertPurposeRegex = /\\b[a-z]*ing\\b/i;\n\texport function isConvertPurposeResult(obj: GuardValidations): obj is ConvertPurposeResult {\n", "  return 'string' === typeof obj && convertPurposeRegex.test(obj);\n\t}"]}
{"filename": "src/server/stats.ts", "chunked_list": ["import type { ChatResponse, CompletionResponse, ModerationResponse } from \"../lib/types\";\n\timport fs from 'fs';\n\timport { getConfig } from \"./config\";\n\timport { isChatResponse, isCompletionResponse, isModerationResponse } from \"../lib/util\";\n\texport function logAiResult<T>(res: ChatResponse<T> | CompletionResponse | ModerationResponse) {\n\t  const config = getConfig();\n\t  const { successful, timestamp, failures, rawResponses, prompts, model, ...metric } = res;\n\t  const duration = ((new Date()).getTime() - (new Date(res.timestamp).getTime())) / 1000;\n\t  let metrics: Record<string, unknown> = {\n\t    pass: successful,\n", "    timestamp,\n\t    duration,\n\t    prompts,\n\t    model\n\t  }\n\t  if (isChatResponse(res)) {\n\t    const { message, supportingText } = res;\n\t    Object.assign(metrics, { data: { message, supportingText } });\n\t  }\n\t  if (isCompletionResponse(res)) {\n", "    const { message } = res;\n\t    Object.assign(metrics, { data: { message } });\n\t  }\n\t  if (isModerationResponse(res)) {\n\t    const { flagged } = res;\n\t    Object.assign(metrics, { data: { flagged } });\n\t  }\n\t  Object.assign(metrics, {  type: metric.promptType, template: metric.promptTemplate, rawResponses, failures });\n\t  fs.appendFileSync(config.ai.logFile, `${JSON.stringify(metrics)}\\n`);\n\t}"]}
{"filename": "src/server/parser.ts", "chunked_list": ["import { isConvertPurposeResult } from \"../lib/prompts/convert_purpose_prompt\";\n\timport { isCreateApiBackendResult } from \"../lib/prompts/create_api_backend_prompt\";\n\timport { isCreateApiResult } from \"../lib/prompts/create_api_prompt\";\n\timport { isGeneralComponentResponse } from \"../lib/prompts/create_gen_component_prompt\";\n\timport { isCreateTypeResponse } from \"../lib/prompts/create_type_prompt\";\n\timport { isFileEditorResult } from \"../lib/prompts/file_editor_prompt\";\n\timport { isGuidedEditResult } from \"../lib/prompts/guided_edit_prompt\";\n\timport type { GuardValidations } from \"../lib/types\";\n\timport { processTextWithCodeBlock, stripWrappedCharacter } from \"./util\";\n\texport function parseChatAttempt<T>(attempt: string): { supportingText: string, message: T } {\n", "  const aiRefusalError = /(^i\\'m sorry)|(?:ai(?:\\s|-)?language(?:\\s|-)?model|i(?:'?m| am))(?:[^.]*?)(?:can(?:'?t| not)|unable to)(?:[^.]*?)(?:perform|do|create|provide)/i;\n\t  if (aiRefusalError.test(attempt)) {\n\t    throw new Error('AI Refusal');\n\t  }\n\t  const isAbstractWrap = attempt.includes('&&&') && attempt.includes('@@@');\n\t  const isBacktickWrap = attempt.includes('```');\n\t  if (isAbstractWrap || isBacktickWrap) {\n\t    let innerBlockText = '';\n\t    let supportingText = '';\n\t    if (isBacktickWrap) { \n", "      const processedText = processTextWithCodeBlock(attempt);\n\t      innerBlockText = processedText.codeBlock;\n\t      supportingText = processedText.supportingText;\n\t    } else {\n\t      const outerBlockStart = attempt.indexOf('&&&') + 3;\n\t      const outerBlockEnd = attempt.lastIndexOf('&&&');\n\t      const pretextEnd = attempt.indexOf('@@@');\n\t      const innerBlockStart = pretextEnd + 3;\n\t      const innerBlockEnd = attempt.lastIndexOf('@@@');\n\t      const postTextStart = innerBlockEnd + 3;\n", "      innerBlockText = attempt.slice(innerBlockStart, innerBlockEnd);\n\t      const pretext = attempt.slice(outerBlockStart, pretextEnd);\n\t      const posttext = attempt.slice(postTextStart, outerBlockEnd);\n\t      supportingText = pretext + '\\n' + posttext;\n\t      console.log({\n\t        ABSTRACTMATCHFOUND: true,\n\t        outerBlockStart,\n\t        outerBlockEnd,\n\t        pretextEnd,\n\t        innerBlockStart,\n", "        innerBlockEnd,\n\t        postTextStart\n\t      });\n\t    }\n\t    console.log({ supportingText, innerBlockText })\n\t    if (!innerBlockText.length) {\n\t      throw new Error('cannot parse Block structure is not valid.');\n\t    }\n\t    try {\n\t      if (innerBlockText.startsWith('{') || innerBlockText.startsWith('[')) {\n", "        JSON.parse(innerBlockText);\n\t      }\n\t    } catch (error) {\n\t      const err = error as Error;\n\t      throw new Error('cannot parse json.' + err.message)\n\t    }\n\t    console.log(\"Validating innerblocktext : \", innerBlockText)\n\t    const result = validateTypedResponse<T>(innerBlockText);\n\t    return { message: result, supportingText };\n\t  }\n", "  attempt = stripWrappedCharacter(attempt);\n\t  console.log(\"Parsing a basic attempt: \", attempt);\n\t  const result = validateTypedResponse<T>(attempt);\n\t  return { message: result, supportingText: '' };\n\t}\n\texport let responseValidators = [\n\t  isConvertPurposeResult,\n\t  isFileEditorResult,\n\t  isGuidedEditResult,\n\t  isCreateTypeResponse,\n", "  isCreateApiResult,\n\t  isCreateApiBackendResult,\n\t  isGeneralComponentResponse\n\t];\n\texport function injectResponseValidators(validators: ((obj: GuardValidations) => boolean)[]): void {\n\t  responseValidators = responseValidators.concat(validators);\n\t}\n\texport function validateTypedResponse<T>(response: string): T {\n\t  if (!response) {\n\t    throw new Error('empty response');\n", "  }\n\t  try {\n\t    let body: GuardValidations = response;\n\t    try {\n\t      body = JSON.parse(response);\n\t    } catch (error) {}\n\t    for (const tg of responseValidators) {\n\t      if (body && tg(body)) {\n\t        return body as T;\n\t      }\n", "      console.log('Guard function:', tg.name, 'Result:', tg(body));\n\t    }\n\t  } catch (error) { }\n\t  throw new Error('bad chat format');\n\t}"]}
{"filename": "src/server/config.ts", "chunked_list": ["// config.ts\n\timport fs from 'fs';\n\timport path from 'path';\n\timport type { Config as RootConfig, ConfigPropTypes } from '../lib/types';\n\timport { isConfigNestedObject } from '../lib/util';\n\texport const isCliRunning = process.argv[1].includes('bin/src/cli.js');\n\texport const isCalledWithNpx = process.env.npm_execpath && /npx(-cli\\.js)?$/.test(process.env.npm_execpath);\n\tconst normalPath = path.join(__dirname, `${isCliRunning ? '../..' : isCalledWithNpx ? process.cwd() : '..'}/config.json`)\n\tconst npxPath = path.join(process.cwd(), 'config.json')\n\texport const configFilePath = isCalledWithNpx ? npxPath : normalPath;\n", "// Default configuration values\n\texport const defaultConfig = {\n\t  ai: { retries: '3', logFile: 'results.json', chatModel: 'gpt-3.5-turbo', completionModel: 'curie' },\n\t  ts: { configPath: '', typeDir: '', compDir: '' },\n\t  git: { rootPath: '', source: 'main', remote: 'origin' },\n\t  user: { name: 'wizapp' }\n\t};\n\ttype Config = RootConfig<typeof defaultConfig>;\n\t// Load existing configuration or create a new file with default values\n\texport let config = defaultConfig;\n", "export function checkConfigExists() {\n\t  if (fs.existsSync(configFilePath)) {\n\t    const rawData = fs.readFileSync(configFilePath);\n\t    config = JSON.parse(rawData.toString());\n\t  } else {\n\t    fs.writeFileSync(configFilePath, JSON.stringify(defaultConfig, null, 2));\n\t    config = defaultConfig;\n\t  }\n\t}\n\tcheckConfigExists();\n", "// Function to save the configuration\n\texport function saveConfig(): void {\n\t  fs.writeFileSync(configFilePath, JSON.stringify(config, null, 2));\n\t}\n\texport function setConfig(newConfig: Config): void {\n\t  config = newConfig;\n\t}\n\texport function getConfig(): Config {\n\t  return config;\n\t}\n", "export function getConfigFromPath(configPath: string): Config {\n\t  let optionalConfig: Config;\n\t  try {\n\t    const configText = fs.readFileSync(configPath, 'utf-8');\n\t    optionalConfig = JSON.parse(configText) as Config;\n\t  } catch (error) {\n\t    optionalConfig = defaultConfig;\n\t  }\n\t  return optionalConfig;\n\t}\n", "// Helper function\n\texport function getConfigValue(config: Config, keys: string[]): [Record<string, ConfigPropTypes | Record<string, ConfigPropTypes>>, string] {\n\t  let current: Record<string, ConfigPropTypes | Record<string, ConfigPropTypes>> = config;\n\t  for (let i = 0; i < keys.length - 1; i++) {\n\t    if (!isConfigNestedObject(current[keys[i]])) {\n\t      throw new Error('invalid config key');\n\t    }\n\t    current = current[keys[i]] as Record<string, ConfigPropTypes>;\n\t  }\n\t  return [current, keys[keys.length - 1]];\n", "}"]}
{"filename": "src/server/types.ts", "chunked_list": ["import { CreateChatCompletionRequest, CreateCompletionRequest, CreateModerationRequest } from \"openai\";\n\texport type OpenAIRequestShapes = CreateChatCompletionRequest | CreateCompletionRequest | CreateModerationRequest;\n"]}
{"filename": "src/server/cli.ts", "chunked_list": ["#!/usr/bin/env node\n\timport yargs from 'yargs/yargs';\n\timport { config, saveConfig, getConfigValue, checkConfigExists } from './config';\n\timport * as spells from './spells';\n\timport { IPrompts } from '../lib/prompts';\n\tconst parser = yargs(process.argv.slice(2))\n\t  // .options({\n\t  //   'config': {\n\t  //     alias: 'c',\n\t  //     describe: 'Path to the configuration file',\n", "  //     default: 'config.json',\n\t  //     type: 'string',\n\t  //   },\n\t  //   'verbose': {\n\t  //     alias: 'v',\n\t  //     describe: 'Display verbose output',\n\t  //     default: false,\n\t  //     type: 'boolean',\n\t  //   },\n\t  // })\n", "  .command(\n\t    'set [key] [value]',\n\t    'Set a configuration value',\n\t    (yargs) => {\n\t      return yargs.positional('key', {\n\t        describe: 'Configuration key to set',\n\t        type: 'string',\n\t      }).positional('value', {\n\t        describe: 'Value to set for the configuration key',\n\t        type: 'string',\n", "      });\n\t    },\n\t    (argv) => {\n\t      checkConfigExists();\n\t      if (!argv.key) throw new Error('key required');\n\t      const keys = argv.key.split('.');\n\t      const [current, lastKey] = getConfigValue(config, keys);\n\t      current[lastKey] = argv.value || '';\n\t      saveConfig();\n\t    }\n", "  )\n\t  .command(\n\t    'use-ai [promptType] [prompts...]',\n\t    'Use AI with the specified prompts',\n\t    (yargs) => {\n\t      return yargs\n\t        .positional('promptType', {\n\t          describe: 'The type of prompt to use',\n\t          default: undefined,\n\t          type: 'string',\n", "        })\n\t        .positional('prompts', {\n\t          describe: 'Prompts',\n\t          demandOption: true,\n\t          type: 'string',\n\t          nargs: 1,\n\t          array: true,\n\t        });\n\t    },\n\t    async (argv) => {\n", "      await spells.useAi(argv.promptType as IPrompts | undefined, ...argv.prompts)\n\t        .then((result) => console.log(result))\n\t        .catch((error) => console.error(error));\n\t    }\n\t  )\n\t  .command(\n\t    'guided-edit [fileNameWithInstructions] [optionalName]',\n\t    'Run guided edit',\n\t    (yargs) => {\n\t      return yargs\n", "        .positional('fileNameWithInstructions', {\n\t          describe: 'File name with instructions',\n\t          type: 'string',\n\t          demandOption: true\n\t        })\n\t        .positional('optionalName', {\n\t          describe: 'Optional name',\n\t          type: 'string',\n\t        })\n\t        .options({\n", "          'commit': {\n\t            type: 'boolean',\n\t            description: 'Will commit edits to the generated branch',\n\t            default: true,\n\t          },\n\t          'pull-request': {\n\t            type: 'boolean',\n\t            description: 'Will create and add to 1 pull request per generated branch',\n\t            default: true,\n\t          },\n", "        });\n\t    },\n\t    async (argv) => {\n\t      await spells.guidedEdit(argv.fileNameWithInstructions, argv.optionalName)\n\t        .then((result) => console.log(result))\n\t        .catch((error) => console.error(error));\n\t    }\n\t  )\n\t  .command(\n\t    'file-editor <fileName> [instructions...]',\n", "    'Edit any file',\n\t    (yargs) => {\n\t      return yargs\n\t        .positional('fileName', {\n\t          describe: 'File Name',\n\t          type: 'string',\n\t          demandOption: true\n\t        })\n\t        .positional('instructions', {\n\t          describe: 'File name with instructions',\n", "          type: 'string',\n\t          array: true,\n\t          demandOption: true\n\t        });\n\t    },\n\t    async (argv) => {\n\t      await spells.fileEditor(argv.fileName, ...argv.instructions)\n\t        .then((result) => console.log(result))\n\t        .catch((error) => console.error(error));\n\t    }\n", "  )\n\t  .command(\n\t    'create-component [description]',\n\t    'Create a component',\n\t    (yargs) => {\n\t      return yargs\n\t        .positional('description', {\n\t          describe: 'Component description',\n\t          demandOption: true,\n\t          type: 'string',\n", "        });\n\t    },\n\t    async (argv) => {\n\t      await spells.createComponent(argv.description)\n\t        .then((result) => console.log(result))\n\t        .catch((error) => console.error(error));\n\t    }\n\t  )\n\t  .command(\n\t    'create-api [typeName]',\n", "    'Create an API',\n\t    (yargs) => {\n\t      return yargs\n\t        .positional('typeName', {\n\t          describe: 'API type name',\n\t          demandOption: true,\n\t          type: 'string',\n\t        });\n\t    },\n\t    async (argv) => {\n", "      const generatedType = await spells.createType(argv.typeName) \n\t      await spells.createApi(argv.typeName, generatedType)\n\t        .then((result) => console.log(result))\n\t        .catch((error) => console.error(error));\n\t      await spells.createApiBackend(argv.typeName, generatedType);\n\t    }\n\t  )\n\t  .demandCommand(1, 'You need at least one command before moving on')\n\t  .help()\n\t  .alias('h', 'help')\n", "  .strict();\n\t(async () => {\n\t  await parser.argv;\n\t})();"]}
{"filename": "src/server/index.ts", "chunked_list": ["export * from './spells';\n\texport * from './parser';\n\texport * from './util';\n\texport * from './request';\n\texport * from './stats';\n\texport type {\n\t  OpenAIRequestShapes\n\t} from './types';"]}
{"filename": "src/server/request.ts", "chunked_list": ["import { CreateModerationRequest, OpenAIApi } from \"openai\";\n\timport { aiPrompts, IPrompts } from \"../lib/prompts\";\n\timport type { OpenAIRequestShapes } from \"./types\";\n\timport { deepClone, isChatRequest, isCompletionRequest, isModerationRequest } from \"./util\";\n\timport { getConfig } from \"./config\";\n\tconst openai = new OpenAIApi();\n\texport const openAIRequestOptions = {\n\t  headers: {\n\t    'Content-Type': 'application/json',\n\t    'Authorization': `Bearer ${process.env.OPENAI_API_KEY as string}`\n", "  }\n\t};\n\texport function buildOpenAIRequest(prompts: string[], promptType?: IPrompts): [OpenAIRequestShapes, string?] {\n\t  const config = getConfig();\n\t  if (!promptType) {\n\t    const moderationRequest: CreateModerationRequest = {\n\t      input: prompts[0]\n\t    }\n\t    return [moderationRequest];\n\t  }\n", "  const promptTokens = prompts.reduce<Record<string, string>>((m, t, i) => ({ ...m, [`\\$\\{prompt${i + 1}\\}`]: t }), {});\n\t  const promptTemplate = aiPrompts[promptType];\n\t  if (!promptTemplate) throw new Error('invalid prompt type');\n\t  const originalPromptTemplate = JSON.stringify(promptTemplate);\n\t  const completionStringOrMessageHistory = promptTemplate;\n\t  if ('string' === typeof completionStringOrMessageHistory) {\n\t    let completionString = String(completionStringOrMessageHistory);\n\t    for (const token in promptTokens) {\n\t      completionString = completionString.replaceAll(token, promptTokens[token]);\n\t    }\n", "    const completionRequest = {\n\t      model: config.ai.completionModel,\n\t      prompt: completionString\n\t    };\n\t    return [completionRequest, originalPromptTemplate]\n\t  }\n\t  if (Array.isArray(completionStringOrMessageHistory)) {\n\t    const messageHistory = deepClone(completionStringOrMessageHistory);\n\t    for (let item of messageHistory) {\n\t      if (item.content.includes('${') && item.content.includes('}')) {\n", "        for (const token in promptTokens) {\n\t          item.content = item.content.replaceAll(token, promptTokens[token]);\n\t        }\n\t      }\n\t    }\n\t    const chatRequest = {\n\t      model: config.ai.chatModel,\n\t      messages: messageHistory\n\t    };\n\t    return [chatRequest, originalPromptTemplate]\n", "  }\n\t  throw new Error('invalid prompting procedure');\n\t}\n\texport async function performRequest(request: OpenAIRequestShapes): Promise<string | boolean | undefined> {\n\t  console.log('OpenAIActionTrigger  =::= ', JSON.stringify(request, null, 2))\n\t  if (isChatRequest(request)) {\n\t    const chatResponse = await openai.createChatCompletion(request, openAIRequestOptions);\n\t    console.log({ RAW_CHAT: chatResponse.data.choices[0] });\n\t    return chatResponse.data.choices[0]?.message?.content.trim();\n\t  } else if (isCompletionRequest(request)) {\n", "    const completionResponse = await openai.createCompletion(request, openAIRequestOptions);\n\t    console.log({ RAW_COMPLETION: completionResponse.data.choices[0] });\n\t    return completionResponse.data.choices[0].text?.trim();\n\t  } else if (isModerationRequest(request)) {\n\t    const moderationResponse = await openai.createModeration(request, openAIRequestOptions);\n\t    console.log({ RAW_MODERATION: moderationResponse.data.results[0] });\n\t    return moderationResponse.data.results[0]?.flagged;\n\t  }\n\t}"]}
{"filename": "src/server/util.ts", "chunked_list": ["import fs from 'fs';\n\timport path from \"path\";\n\timport { sync } from 'fast-glob';\n\timport { isCalledWithNpx, isCliRunning } from \"./config\";\n\timport languages from \"../lib/languages\";\n\timport type { OpenAIRequestShapes } from './types';\n\timport { CreateChatCompletionRequest, CreateCompletionRequest, CreateModerationRequest } from 'openai';\n\tconst langValues = Object.values(languages);\n\texport const codeGPTPrecursor = 'You are BacktickGPT, providing only typescript code responses wrapped with 3 backticks before and after.';\n\texport function deepClone<T>(obj: T): T {\n", "  if (obj === null || typeof obj !== 'object') {\n\t    return obj;\n\t  }\n\t  if (Array.isArray(obj)) {\n\t    return obj.map((item) => deepClone(item) as T) as unknown as T;\n\t  }\n\t  const result: Record<string, unknown> = {};\n\t  for (const key in obj) {\n\t    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t      result[key] = deepClone((obj as Record<string, unknown>)[key]);\n", "    }\n\t  }\n\t  return result as T;\n\t}\n\texport const isValidName = (name: string): boolean => {\n\t  const regex = /^I[A-Z][a-zA-Z]*$/;\n\t  return regex.test(name);\n\t};\n\texport const toSnakeCase = (name: string): string => {\n\t  if (!isValidName(name)) {\n", "    throw new Error(\"Invalid name format\");\n\t  }\n\t  return name.substr(1).replace(/[A-Z]/g, (match) => `_${match.toLowerCase()}`).slice(1);\n\t};\n\texport const toTitleCase = (name: string): string => {\n\t  if (!isValidName(name)) {\n\t    throw new Error(\"Invalid name format\");\n\t  }\n\t  return name.substr(1).replace(/([A-Z])/g, \" $1\").replace(/^./, (str) => str.toUpperCase());\n\t};\n", "export function extractCodeBlock(inputString: string, delimeter: string = '```', languages: string[] = ['typescript', 'json', 'jsx', 'tsx']) {\n\t  const langStartTag = (language: string) => language ? `${delimeter}${language}` : delimeter;\n\t  for (const language of languages) {\n\t    const startTag = langStartTag(language);\n\t    if (inputString.includes(startTag)) {\n\t      return {\n\t        codeBlock: inputString.split(startTag)[1].split(delimeter)[0],\n\t        index: inputString.indexOf(startTag) + startTag.length,\n\t      };\n\t    }\n", "  }\n\t  if (inputString.includes(delimeter)) {\n\t    const index = inputString.indexOf(delimeter) + delimeter.length;\n\t    return {\n\t      codeBlock: inputString.split(delimeter)[1],\n\t      index,\n\t    };\n\t  }\n\t  return {\n\t    codeBlock: inputString,\n", "    index: 0,\n\t  };\n\t};\n\texport function extractCodeBlockPre(inputString: string, index: number): string {\n\t  return inputString.substring(0, index)?.trim() || '';\n\t}\n\texport function extractCodeBlockPost(inputString: string, index: number, delimeter: string = '```'): string {\n\t  return inputString.substring(index).split(delimeter)[1]?.trim() || '';\n\t}\n\texport function processTextWithCodeBlock(inputString: string): { codeBlock: string; supportingText: string } {\n", "  const { codeBlock, index } = extractCodeBlock(inputString);\n\t  const preText = extractCodeBlockPre(inputString, index);\n\t  const postText = extractCodeBlockPost(inputString, index);\n\t  return {\n\t    codeBlock,\n\t    supportingText: preText + ' ' + postText,\n\t  };\n\t}\n\texport function stripWrappedCharacter(inputString: string, wrappedCharacters: string[] = ['\"', \"'\"]): string {\n\t  for (const char of wrappedCharacters) {\n", "    if (inputString.startsWith(char)) inputString = inputString.slice(1); \n\t    if (inputString.endsWith(char)) inputString = inputString.substring(0, inputString.length - 1); \n\t  }\n\t  return inputString;\n\t}\n\texport function sanitizeName(input: string): string {\n\t  // Trim whitespaces and replace consecutive spaces with a single dash\n\t  const trimmed = input.trim();\n\t  // Remove invalid characters: ~ ^ : ? * [ ] @ { } \\ /\n\t  const sanitized = trimmed.replace(/[~^:?\"*\\[\\]@{}\\\\/]+/g, '');\n", "  // Limit branch name length to 100 characters\n\t  const maxLength = 100;\n\t  const shortened = sanitized.slice(0, maxLength);\n\t  // Remove leading and trailing period (.)\n\t  const noLeadingTrailingPeriods = shortened.replace(/(^\\.+|\\.+$)/g, '');\n\t  // Remove leading and trailing forward slash (-)\n\t  const result = noLeadingTrailingPeriods.replace(/(^-+|-+$)/g, '');\n\t  return result;\n\t}\n\texport function ensureKeysAreQuoted(jsonString: string): string {\n", "  const unquotedKeysRegex = /([{,]\\s*)(\\w+)\\s*:/g;\n\t  function quoteKeys(match: unknown, prefix: string, key: string) {\n\t    return `${prefix}\"${key}\":`;\n\t  }\n\t  return jsonString.replace(unquotedKeysRegex, quoteKeys);\n\t}\n\texport function typeDefinitionToSentence(typeDefinition: string): string {\n\t  const typeNameMatch = typeDefinition.match(/export type (\\w+)/);\n\t  if (!typeNameMatch) {\n\t    return 'Invalid type definition provided.';\n", "  }\n\t  const typeName = typeNameMatch[1];\n\t  const properties = [];\n\t  const propertyRegex = /(\\w+)\\s*:\\s*([^;]+);/g;\n\t  let match;\n\t  while ((match = propertyRegex.exec(typeDefinition)) !== null) {\n\t    properties.push({ key: match[1], type: match[2].trim().replace(/\\s+/g, ' ') });\n\t  }\n\t  if (properties.length > 0) {\n\t    const propertiesDescription = properties\n", "      .map((property) => `${property.key} as a ${property.type}`)\n\t      .join(', ');\n\t    return `${typeName} defines ${propertiesDescription}.`;\n\t  } else {\n\t    const recordMatch = typeDefinition.match(/Record<(.+),\\s*(.+)>/);\n\t    if (recordMatch) {\n\t      return `${typeName} is a Record ${recordMatch[1]} of ${recordMatch[2]}.`;\n\t    }\n\t  }\n\t  return 'Unable to parse the type definition.';\n", "}\n\texport function getDirPathOf(filePath: string) {\n\t  return path.dirname(filePath)\n\t}\n\texport function generateTempFilePath(dir: string, name: string) {\n\t  return path.join(dir, `${name}-${Date.now()}.json`)\n\t}\n\texport function getRootDir() {\n\t  return isCalledWithNpx ? process.cwd() : path.join(__dirname, isCliRunning ? '../../' : '../');\n\t}\n", "export function getPathOf(name: string, baseDir?: string): string {\n\t  return path.join(baseDir || getRootDir(), name);\n\t}\n\texport function getFileParser(fileName: string) {\n\t  const extension = path.extname(fileName);\n\t  const parser = langValues.find(l => l.fileExtension.includes(extension));\n\t  if (!parser) throw 'That parser is undefined!';\n\t  return parser.parserName;\n\t}\n\texport function getFileFromDir(file: string, dir: string = __dirname) {\n", "  const files = fs.readdirSync(dir);\n\t  const fileName = files.find(f => f.startsWith(file));\n\t  if (!fileName) throw 'File not found.';\n\t  return fs.readFileSync(path.join(dir, fileName), { encoding: 'utf-8' })\n\t}\n\texport function getTargetFile(targetFile: string, rootDir: string = getRootDir(), ignoredDirectories: string[] = excludeDirectories): string | null {\n\t  const pattern = path.join(rootDir, '**', targetFile);\n\t  const files = sync(pattern, {\n\t    ignore: ignoredDirectories.map(dir => path.join('**', dir, '**')),\n\t    onlyFiles: true,\n", "  });\n\t  if (!files.length) {\n\t    throw 'No file found.';\n\t  }\n\t  if (files.length > 1) {\n\t    throw 'Multiple files were found. Please specifiy with a local folder path.';\n\t  }\n\t  const fileContent = fs.readFileSync(files[0], { encoding: 'utf-8' });\n\t  console.log({ gotfiles: files, fileContent})\n\t  return files.length > 0 ? fileContent : null;\n", "}\n\texport function saveTargetFile(targetFile: string, contents: string, rootDir: string = getRootDir(), ignoredDirectories: string[] = excludeDirectories): string {\n\t  const pattern = path.join(rootDir, '**', targetFile);\n\t  const files = sync(pattern, {\n\t    ignore: ignoredDirectories.map(dir => path.join('**', dir, '**')),\n\t    onlyFiles: true,\n\t  });\n\t  if (!files.length) {\n\t    throw 'No file found.';\n\t  }\n", "  if (files.length > 1) {\n\t    throw 'Multiple files were found. Please specifiy with a local folder path.';\n\t  }\n\t  const fileContent = fs.writeFileSync(files[0], contents, { encoding: 'utf-8' });\n\t  console.log({ gotfiles: files, fileContent})\n\t  return 'file saved';\n\t}\n\tconst excludeDirectories = [\n\t  'node_modules',\n\t  'vendor',\n", "  'dist',\n\t  'build',\n\t  '.git',\n\t  '.svn',\n\t  // add other directories to exclude\n\t];\n\texport function isChatRequest(obj: OpenAIRequestShapes): obj is CreateChatCompletionRequest {\n\t  return 'messages' in obj;\n\t}\n\texport function isCompletionRequest(obj: OpenAIRequestShapes): obj is CreateCompletionRequest {\n", "  return 'prompt' in obj;\n\t}\n\texport function isModerationRequest(obj: OpenAIRequestShapes): obj is CreateModerationRequest {\n\t  return 'input' in obj;\n\t}"]}
{"filename": "src/server/git/push_commit.ts", "chunked_list": ["import simpleGit from \"simple-git\";\n\timport { sanitizeName } from \"../util\";\n\timport { getConfig } from \"../config\";\n\timport { gitCheck } from \"./check_git_cli\";\n\texport async function pushCommit(path: string, branch: string, msg: string) {\n\t  gitCheck();\n\t  const config = getConfig();\n\t  if (!config.git.rootPath) {\n\t    throw 'Missing config.git.rootPath.'\n\t  }\n", "  const git = simpleGit(config.git.rootPath);\n\t  console.log('Adding ', path, ' to ', branch);\n\t  await git.add(path);\n\t  const commitMsg = sanitizeName(msg).slice(0, 50);\n\t  console.log('Creating commit:', commitMsg);\n\t  await git.commit(commitMsg);\n\t  console.log('Pushing changes to ', branch);\n\t  await git.push(config.git.remote, branch);\n\t}\n"]}
{"filename": "src/server/git/go_home.ts", "chunked_list": ["import simpleGit from \"simple-git\";\n\timport { getConfig } from \"../config\";\n\timport { gitCheck } from \"./check_git_cli\";\n\texport async function goHome(): Promise<string> {\n\t  gitCheck();\n\t  const config = getConfig();\n\t  if (!config.git.rootPath) {\n\t    throw 'Missing config.git.rootPath.'\n\t  }\n\t  const git = simpleGit(config.git.rootPath);\n", "  await git.checkout(config.git.source);\n\t  return 'relocated to git root';\n\t}\n"]}
{"filename": "src/server/git/check_git_cli.ts", "chunked_list": ["import { execSync } from \"child_process\";\n\texport async function checkGitCli() {\n\t  try {\n\t    // Check if the GitHub CLI is installed\n\t    const version = execSync(\"gh --version\").toString();\n\t    console.log(`GitHub CLI installed: ${version}`);\n\t    // Check if the GitHub CLI is properly configured\n\t    const config = execSync(\"gh config get git_protocol\").toString().trim();\n\t    console.log(`GitHub CLI configuration (git_protocol): ${config}`);\n\t    return config === \"ssh\" || config === \"https\";\n", "  } catch (error) {\n\t    const err = error as Error;\n\t    console.error(\"Error:\", err.message);\n\t    return false;\n\t  }\n\t}\n\texport function gitCheck() {\n\t  if (!checkGitCli()) throw new Error('github cli is required to be installed and configured in order to use this flow');\n\t}"]}
{"filename": "src/server/git/prepare_branch.ts", "chunked_list": ["import simpleGit from \"simple-git\";\n\timport { sanitizeName } from \"../util\";\n\timport { getConfig } from \"../config\";\n\timport { gitCheck } from \"./check_git_cli\";\n\texport async function prepareBranch(name: string): Promise<string> {\n\t  gitCheck();\n\t  const config = getConfig();\n\t  if (!config.git.rootPath) {\n\t    throw 'Missing config.git.rootPath.'\n\t  }\n", "  const git = simpleGit(config.git.rootPath);\n\t  const generatedBranch = sanitizeName(`gen/${name}`);\n\t  console.log('Prepare branch main checkout.');\n\t  await git.checkout(config.git.source);\n\t  console.log('Pulling main.');\n\t  await git.pull(config.git.remote, config.git.source);\n\t  console.log('Fetching.');\n\t  await git.fetch('all');\n\t  try {\n\t    console.log('Creating a new branch for ', generatedBranch);\n", "    await git.checkoutBranch(generatedBranch, config.git.source);\n\t    await git.push(config.git.remote, generatedBranch, ['--set-upstream', generatedBranch])\n\t  } catch (error) {\n\t    const err = error as Error;\n\t    if (err.message.includes('A branch named') && err.message.includes('already exists')) {\n\t      console.log('Checking out existing generated branch ', generatedBranch);\n\t      await git.checkout(generatedBranch);\n\t      console.log('Pulling generated branch.');\n\t      await git.pull(config.git.remote, generatedBranch);\n\t    }\n", "  }\n\t  return generatedBranch;\n\t}\n"]}
{"filename": "src/server/git/index.ts", "chunked_list": ["export { gitCheck, checkGitCli } from './check_git_cli';\n\texport { managePullRequest } from './manage_pull_request';\n\texport { prepareBranch } from './prepare_branch';\n\texport { pushCommit } from './push_commit';\n\texport { goHome } from './go_home';"]}
{"filename": "src/server/git/manage_pull_request.ts", "chunked_list": ["import { execSync } from \"child_process\";\n\timport { gitCheck } from \"./check_git_cli\";\n\timport { getConfig } from \"../config\";\n\texport async function managePullRequest(branch: string, title: string, body: string) {\n\t  gitCheck();\n\t  const config = getConfig();\n\t  if (!config.git.rootPath) {\n\t    throw 'Missing config.git.rootPath.'\n\t  }\n\t  const prListOutput = JSON.parse(Buffer.from(execSync(`gh pr list --state open --base ${config.git.source} --json number,headRefName,url`, { cwd: config.git.rootPath })).toString()) as { number: number, headRefName: string, url: string }[];\n", "  const existingPr = prListOutput.find(pr => pr.headRefName === branch);\n\t  if (!existingPr) {\n\t    execSync(`gh pr create --title \"${title}\" --body \"${body}\" --head \"${branch}\" --base \"${config.git.source}\"`, { cwd: config.git.rootPath });\n\t  } else {\n\t    execSync(`gh pr review ${existingPr.number} --comment -b \"${title}\\n\\n${body}\"`, { cwd: config.git.rootPath }); \n\t  }\n\t  return `guided edit process sucessfully ${existingPr?.number ? 'updated' : 'created'} ${existingPr?.url}`;\n\t}"]}
{"filename": "src/server/spells/create_api_backend_spell.ts", "chunked_list": ["import { Project } from 'ts-morph';\n\timport { getConfig } from '../config';\n\timport { getPathOf, sanitizeName, toSnakeCase, toTitleCase } from '../util';\n\timport { useAi } from './use_ai_spell';\n\timport { IPrompts } from '../../lib/prompts';\n\timport { CreateApiBackendResult } from '../../lib/prompts/create_api_backend_prompt';\n\texport async function createApiBackend(typeName: string, generatedType: string): Promise<string> {\n\t  const config = getConfig();\n\t  if (!config.ts.configPath) {\n\t    throw new Error('Missing ts.configPath.');\n", "  }\n\t  if (!config.ts.typeDir) {\n\t    throw new Error('Missing ts.typeDir.');\n\t  }\n\t  const project = new Project({\n\t    tsConfigFilePath: config.ts.configPath\n\t  });\n\t  const coreTypesPath = sanitizeName(config.ts.typeDir);\n\t  const typeFileName = getPathOf(`${coreTypesPath}/${toSnakeCase(typeName)}.ts`);\n\t  const sourceFile = project.addSourceFileAtPath(typeFileName);\n", "  const variables = sourceFile.getVariableDeclarations();\n\t  const apiEndpoints: string[] = [];\n\t  for (const v of variables) {\n\t    if (v.getName().endsWith('Api')) {\n\t      const initializer = v.getInitializer();\n\t      if (initializer) {\n\t        initializer.getType().getProperties().forEach(p => {\n\t          apiEndpoints.push(p.getName())\n\t        });\n\t      }\n", "    }\n\t  }\n\t  try {\n\t    const generatedApiBackend = await useAi<CreateApiBackendResult>(IPrompts.CREATE_API_BACKEND, generatedType + ' ' + apiEndpoints.join(' '))\n\t    const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;\n\t    sourceFile.insertText(sourceFile.getEnd(), `${comment}${generatedApiBackend.message}\\n\\n`);\n\t    sourceFile.fixMissingImports();\n\t    await project.save();\n\t  } catch (error) {\n\t    console.error(error);\n", "  }\n\t  return `generated backend using the type ${typeName}!`;\n\t}"]}
{"filename": "src/server/spells/use_ai_spell.ts", "chunked_list": ["import { parseChatAttempt } from '../parser';\n\timport { IPrompts } from '../../lib/prompts';\n\timport { buildOpenAIRequest, performRequest } from '../request';\n\timport { logAiResult } from '../stats';\n\timport { getConfig } from '../config';\n\timport type { ChatResponse, CompletionResponse, ModerationResponse, OpenAIResults, UseAIResponses } from '../../lib/types';\n\timport { isCompletionRequest } from '../util';\n\texport async function useAi<T = undefined>(promptType?: IPrompts, ...prompts: string[]): Promise<UseAIResponses<T>> {\n\t  const config = getConfig();\n\t  const retries = parseInt(config.ai.retries, 10);\n", "  const [builtRequest, promptTemplate] = buildOpenAIRequest(prompts, promptType);\n\t  const aiResponse: OpenAIResults = {\n\t    timestamp: new Date(),\n\t    successful: true,\n\t    failures: [],\n\t    rawResponses: [],\n\t    promptTemplate,\n\t    promptType: (!promptType ? 'moderation' : promptType) as IPrompts\n\t  }\n\t  try {\n", "    const responseTry = await performRequest(builtRequest);\n\t    aiResponse.rawResponses.push(responseTry);\n\t    if ('undefined' === typeof responseTry) {\n\t      const noChoices = 'Open AI returned no choices.'\n\t      aiResponse.failures.push(noChoices);\n\t      throw new Error(noChoices);\n\t    }\n\t    if ('boolean' === typeof responseTry) {\n\t      const moderationResponse: ModerationResponse = { ...aiResponse, flagged: responseTry };\n\t      console.log('MODERATION RESPONSE :==: ', moderationResponse)\n", "      logAiResult<T>({ ...moderationResponse, prompts, model: builtRequest.model });\n\t      return moderationResponse as UseAIResponses<T>;\n\t    }\n\t    if (isCompletionRequest(builtRequest)) {\n\t      const completionResponse: CompletionResponse = {\n\t        ...aiResponse,\n\t        message: responseTry\n\t      };\n\t      console.log('COMPLETION RESPONSE :==: ', completionResponse)\n\t      logAiResult<T>({ ...completionResponse, prompts, model: builtRequest.model });\n", "      return completionResponse as UseAIResponses<T>;\n\t    }\n\t    async function resolveAttempt(attempt: string, retriesRemaining: number): Promise<ChatResponse<T>> {\n\t      try {\n\t        const { supportingText, message } = parseChatAttempt<T>(attempt);\n\t        const chatResponse = {\n\t          ...aiResponse,\n\t          supportingText,\n\t          message\n\t        };\n", "        logAiResult<T>({ ...chatResponse, prompts, model: builtRequest.model });\n\t        console.log('CHAT RESPONSE :==: ', chatResponse)\n\t        return chatResponse;\n\t      } catch (error) {\n\t        const err = error as Error;\n\t        if (retriesRemaining > 0 && err.message.startsWith('cannot parse')) {\n\t          const repeatedAttempt = await performRequest(builtRequest);\n\t          aiResponse.rawResponses.push(repeatedAttempt);\n\t          if ('string' !== typeof repeatedAttempt) {\n\t            const imparsable = 'Received imparsable resolution during retry.';\n", "            aiResponse.failures.push(imparsable);\n\t            throw new Error(imparsable);\n\t          }\n\t          return await resolveAttempt(repeatedAttempt, retriesRemaining - 1);\n\t        }\n\t        const resolveIssue = 'Critical chat parse error or could not resolve a valid response after ' + retries + ' attempts. ' + (err.message ? 'Parsing error: ' + err.message : '');\n\t        aiResponse.failures.push(resolveIssue);\n\t        throw new Error(resolveIssue);\n\t      }\n\t    }\n", "    return await resolveAttempt(responseTry, retries) as UseAIResponses<T>;\n\t  } catch (error) {\n\t    const err = error as Error;\n\t    aiResponse.successful = false;\n\t    logAiResult({ ...aiResponse, prompts, message: err.message + ' ' + err.stack, model: builtRequest.model });\n\t    throw new Error('General use AI failure!\\nStack: ' + err.stack);\n\t  }\n\t}\n"]}
{"filename": "src/server/spells/create_api_spell.ts", "chunked_list": ["import fs from 'fs';\n\timport { getPathOf, sanitizeName, toSnakeCase, toTitleCase } from '../util';\n\timport { useAi } from './use_ai_spell';\n\timport { IPrompts } from '../../lib/prompts';\n\timport { getConfig } from '../config';\n\timport { CreateApiResult } from '../../lib/prompts/create_api_prompt';\n\texport async function createApi(typeName: string, generatedType: string): Promise<string> {\n\t  const config = getConfig();\n\t  if (!config.ts.typeDir) {\n\t    throw new Error('Missing ts.typeDir.')\n", "  }\n\t  const coreTypesPath = sanitizeName(config.ts.typeDir);\n\t  const typeFilePath = getPathOf(`${coreTypesPath}/${toSnakeCase(typeName)}.ts`);\n\t  const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;\n\t  const generatedApi = await useAi<CreateApiResult>(IPrompts.CREATE_API, generatedType);\n\t  fs.appendFileSync(typeFilePath, `${comment}${generatedApi.message}\\n\\n`);\n\t  return generatedApi.message;\n\t}"]}
{"filename": "src/server/spells/guided_edit_spell.ts", "chunked_list": ["import { FunctionDeclaration, SyntaxKind, Node, Project } from 'ts-morph';\n\timport { useAi } from './use_ai_spell';\n\timport { IPrompts } from '../../lib/prompts';\n\timport { prepareBranch, pushCommit, managePullRequest, goHome } from '../git';\n\timport { getConfig } from '../config';\n\timport { GuidedEditKeys, GuidedEditResponse } from '../../lib/prompts/guided_edit_prompt';\n\tfunction getStatementText(child: Node) {\n\t  let parsedStatementText = child.getText();\n\t  const parent = child.getParent();\n\t  if (child.getKind() == SyntaxKind.VariableDeclaration && parent instanceof Node) {\n", "    parsedStatementText = parent.getText();\n\t  }\n\t  return parsedStatementText;\n\t}\n\tconst ignoredStatements = [SyntaxKind.TryStatement]\n\tfunction walkNode(child: Node, i: number, parsedStatements: Record<string, string>, originalStatements: Map<string, string>) {\n\t  const statementName = `statement_${i}`;\n\t  if (child instanceof FunctionDeclaration) {\n\t    child.getStatements().forEach((descendant, index) => {\n\t      walkNode(descendant, index + i, parsedStatements, originalStatements);\n", "    })\n\t  } else if (!ignoredStatements.includes(child.getKind())) {\n\t    parsedStatements[statementName] = getStatementText(child);\n\t    originalStatements.set(statementName, getStatementText(child));\n\t  }\n\t}\n\texport async function guidedEdit(fileParts: string, editingUser?: string): Promise<string> {\n\t  const config = getConfig();\n\t  if (!config.ts.configPath) {\n\t    throw new Error('Missing ts.configPath.')\n", "  }\n\t  const project = new Project({\n\t    tsConfigFilePath: config.ts.configPath\n\t  });\n\t  const [fileName, ...suggestedEdits] = fileParts.split(' ');\n\t  const suggestions = suggestedEdits.join(' ');\n\t  const generatedBranch = await prepareBranch(editingUser || config.user.name);\n\t  try {\n\t    const sourceFile = project.getSourceFiles().filter(sf => sf.getFilePath().toLowerCase().includes(fileName.toLowerCase()))[0];\n\t    if (sourceFile) {\n", "      if (sourceFile.getText().length > 10000) {\n\t        return 'the file is too large';\n\t      }\n\t      const originalStatements: Map<string, string> = new Map();\n\t      const parsedStatements: Record<string, string> = {};\n\t      sourceFile.getStatements().forEach((statement, index) => {\n\t        walkNode(statement, index, parsedStatements, originalStatements);\n\t      });\n\t      const res = await useAi<GuidedEditResponse>(IPrompts.GUIDED_EDIT, suggestions, JSON.stringify(parsedStatements));\n\t      const generatedStatements = res.message.reduce((m, d) => ({ ...m, ...d }), {});\n", "      let fileContent = sourceFile.getFullText();\n\t      let fileModified = false;\n\t      Object.keys(generatedStatements).forEach(statementKey => {\n\t        const stKey = statementKey as GuidedEditKeys;\n\t        if (['new_statement', 'newstatement', `statement_${originalStatements.size + 1}`].includes(stKey)) {\n\t          fileContent += `\\n${generatedStatements[stKey]} // generated by ${editingUser || config.user.name}`;\n\t          fileModified = true;\n\t        } else if ([/^above_\\d{1,2}$/, /^below_\\d{1,2}$/].some(regex => regex.test(stKey))) {\n\t          const [direction, index] = stKey.split('_');\n\t          const adjacentStatement = originalStatements.get(`statement_${index}`);\n", "          if (adjacentStatement) {\n\t            let adjacentStart = fileContent.indexOf(adjacentStatement);\n\t            let adjacentEnd = adjacentStart + adjacentStatement.length;\n\t            if ('above' == direction) {\n\t              fileContent = fileContent.substring(0, adjacentStart) + '\\n' + generatedStatements[stKey] + fileContent.substring(adjacentStart);\n\t              adjacentStart = fileContent.indexOf(adjacentStatement);\n\t              adjacentEnd = adjacentStart + adjacentStatement.length;\n\t            } else {\n\t              fileContent = fileContent.substring(0, adjacentEnd) + '\\n' + generatedStatements[stKey] + fileContent.substring(adjacentEnd);\n\t            }\n", "            fileModified = true;\n\t          }\n\t        } else {\n\t          const originalStatement = originalStatements.get(stKey);\n\t          if (originalStatement) {\n\t            const originalIndex = fileContent.indexOf(originalStatement);\n\t            if (originalIndex >= 0 && originalStatement !== generatedStatements[stKey]) {\n\t              fileContent = fileContent.substring(0, originalIndex) + generatedStatements[stKey] + fileContent.substring(originalIndex + originalStatement.length);\n\t              fileModified = true;\n\t            }\n", "          }\n\t        }\n\t      });\n\t      let responseMessage = '';\n\t      if (fileModified) {\n\t        // const projectDiffPath = path.resolve('~/code/project_diff');\n\t        // const apiPath = path.join(projectDiffPath, 'api');\n\t        // const tsConfigFilePath = path.join(apiPath, 'projectts.json');\n\t        // const tsConfigFile = ts.readConfigFile(tsConfigFilePath, ts.sys.readFile);\n\t        // const configParseResult = ts.parseJsonConfigFileContent(tsConfigFile.config, ts.sys, apiPath)\n", "        // const testFile = ts.createSourceFile('temp.ts', fileContent, ts.ScriptTarget.ES2016, true);\n\t        // const testProgram = ts.createProgram([testFile.fileName], configParseResult.options)\n\t        // const diagnostics = ts.getPreEmitDiagnostics(testProgram);\n\t        // if (diagnostics.length > 0) {\n\t        //   console.log('Diagnostic errors:');\n\t        //   diagnostics.forEach(diagnostic => {\n\t        //     const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\\n');\n\t        //     console.log(`${diagnostic.file?.fileName} (${diagnostic.start}): ${message}`);\n\t        //   })\n\t        //   return 'you really did it now, no code, no show, no turkey';\n", "        // } else {\n\t        // console.log('Makin it pretty')\n\t        // try {\n\t        //   fileContent = prettier.format(fileContent, {\n\t        //     parser: 'typescript',\n\t        //     tabWidth: 2,\n\t        //     useTabs: false\n\t        //   });\n\t        // } catch (error) { }\n\t        sourceFile.removeText();\n", "        sourceFile.insertText(0, fileContent);\n\t        sourceFile.saveSync();\n\t        await project.save();\n\t        const sourceFilePath = sourceFile.getFilePath().toString();\n\t        await pushCommit(sourceFilePath, generatedBranch, `${editingUser || config.user.name} - ${suggestions}`);\n\t        const prTitle = `${editingUser || config.user.name} edited ${fileName}: ${suggestions.replace(/[~^:?\"*\\[\\]@{}\\\\/]+/g, '')}`.slice(0, 255);\n\t        const prBody = `GPT: ${res.supportingText || 'No supporting text found.'}`.replaceAll('\"', '');\n\t        const prRes = await managePullRequest(generatedBranch, prTitle, prBody);\n\t        responseMessage = 'guided edit complete: ' + prRes;\n\t      } else {\n", "        responseMessage = 'guided edit produced no modifications for ' + fileName;\n\t      }\n\t      await goHome();\n\t      return responseMessage;\n\t    }\n\t  } catch (error) {\n\t    await goHome();\n\t    const err = error as Error;\n\t    return err.message + '\\n\\n' + err.stack;\n\t  }\n", "  return 'file not found: ' + fileName;\n\t}"]}
{"filename": "src/server/spells/file_editor_spell.ts", "chunked_list": ["// import fs from 'fs';\n\t// import { Node, Project, ScriptKind, SyntaxKind } from 'ts-morph';\n\timport { useAi } from './use_ai_spell';\n\timport { IPrompts } from '../../lib/prompts';\n\timport { getConfig } from '../config';\n\t// import { getPathOf, sanitizeName } from '../util';\n\timport { FileEditorResponse } from '../../lib/prompts/file_editor_prompt';\n\timport { getTargetFile, saveTargetFile } from '../util';\n\t// import { copyContentsToDocker } from '../tree/docker';\n\texport async function fileEditor(...fileParts: string[]): Promise<string> {\n", "  console.log({ fileParts });\n\t  const config = getConfig();\n\t  if (!config.ts.compDir) {\n\t    throw new Error('Missing ts.compDir.')\n\t  }\n\t  if (!config.ts.configPath) {\n\t    throw new Error('Missing ts.configPath.')\n\t  }\n\t  const [fileName, ...suggestedEdits] = fileParts;\n\t  const originalFileContents = getTargetFile(fileName, config.git.rootPath);\n", "  if (!originalFileContents) throw 'File not found.';\n\t  const lined = originalFileContents.split('\\n').map((l, i) => `${i + 1}. ${l}`);\n\t  console.log({ lined, fileName, suggestedEdits });\n\t  const response = await useAi<FileEditorResponse>(IPrompts.FILE_EDITOR, fileName, suggestedEdits.join(' '), lined.join('\\n'));\n\t  console.log({ EDITOR_FINISHED: response.message });\n\t  const editedLines: Record<string, string> = response.message.split('\\n').reduce((m, d) => {\n\t    const match = d.match(/^\\d+. /);\n\t    if (match) {\n\t      console.log({ match })\n\t      return ({\n", "        ...m,\n\t        [match[0].trim()]: d.slice(match[0].length)\n\t      })\n\t    }\n\t    return { ...m };\n\t  }, {});\n\t  const regex = /\\/\\*\\s*change:.*?\\*\\//gs;\n\t  const editedFile = lined.map(l => {\n\t    const match = l.match(/^\\d+. /);\n\t    const key = match && match[0].trim();\n", "    const edit = key && editedLines[key as keyof typeof editedLines];\n\t    if (edit) {\n\t      return edit.replace(regex, ''); \n\t    }\n\t    return l.slice(match?match[0].length:0);\n\t  }).filter(l => l?.length > 0).join('\\n');\n\t  console.log({ lined, editedLines, editedFile, editNum: Object.keys(editedLines).length });\n\t  const saved = saveTargetFile(fileName, editedFile);\n\t  return saved;\n\t}"]}
{"filename": "src/server/spells/create_component_spell.ts", "chunked_list": ["import fs from 'fs';\n\timport { Node, Project, ScriptKind, SyntaxKind } from 'ts-morph';\n\timport { useAi } from './use_ai_spell';\n\timport { IPrompts } from '../../lib/prompts';\n\timport { getConfig } from '../config';\n\timport { getPathOf, sanitizeName } from '../util';\n\timport { GeneralComponentResponse } from '../../lib/prompts/create_gen_component_prompt';\n\texport async function createComponent(description: string, user?: string): Promise<string> {\n\t  const config = getConfig();\n\t  if (!config.ts.compDir) {\n", "    throw new Error('Missing ts.compDir.')\n\t  }\n\t  if (!config.ts.configPath) {\n\t    throw new Error('Missing ts.configPath.')\n\t  }\n\t  const project = new Project({\n\t    tsConfigFilePath: config.ts.configPath\n\t  });\n\t  const res = await useAi<GeneralComponentResponse>(IPrompts.CREATE_GEN_COMPONENT, description);\n\t  const sourceFile = project.createSourceFile('new_component.tsx', res.message, { scriptKind: ScriptKind.JSX });\n", "  let componentName;\n\t  const exportedDeclarations = sourceFile.getExportedDeclarations().get('default');\n\t  if (exportedDeclarations) {\n\t    const declaration = exportedDeclarations[0];\n\t    if (Node.isVariableDeclaration(declaration)) {\n\t      const initializer = declaration.getInitializer();\n\t      if (initializer?.getKind() === SyntaxKind.FunctionExpression || initializer?.getKind() === SyntaxKind.ArrowFunction) {\n\t        componentName = declaration.getName();\n\t      }\n\t    } else if (Node.isFunctionDeclaration(declaration)) {\n", "      componentName = declaration.getName();\n\t    }\n\t  }\n\t  if (componentName) {\n\t    const creatorComment = `/* Created by ${user || config.user.name}, ${description} */\\n`;\n\t    const coreCompsPath = sanitizeName(config.ts.compDir);\n\t    const compFilePath = getPathOf(`${coreCompsPath}/${componentName}.tsx`);\n\t    if (!fs.existsSync(coreCompsPath)) {\n\t      fs.mkdirSync(coreCompsPath, { recursive: true });\n\t    }\n", "    fs.writeFileSync(compFilePath, `${creatorComment}${res.message}`);\n\t    return 'created a new component';\n\t  }\n\t  return 'unable to create a component ' + res.message;\n\t}"]}
{"filename": "src/server/spells/index.ts", "chunked_list": ["export { useAi } from './use_ai_spell';\n\texport { createType } from './create_type_spell';\n\texport { createApi } from './create_api_spell';\n\texport { createApiBackend } from './create_api_backend_spell';\n\texport { fileEditor } from './file_editor_spell';\n\texport { guidedEdit } from './guided_edit_spell';\n\texport { createComponent } from './create_component_spell';"]}
{"filename": "src/server/spells/create_type_spell.ts", "chunked_list": ["import fs from \"fs\";\n\timport { IPrompts } from \"../../lib/prompts\";\n\timport { useAi } from \"./use_ai_spell\";\n\timport { getPathOf, isValidName, sanitizeName, toSnakeCase, toTitleCase } from \"../util\";\n\timport { getConfig } from \"../config\";\n\timport { CreateTypeResponse } from \"../../lib/prompts/create_type_prompt\";\n\texport async function createType(typeName: string): Promise<string> {\n\t  const config = getConfig();\n\t  if (!config.ts.typeDir) {\n\t    throw new Error('Missing ts.typeDir.')\n", "  }\n\t  if (!isValidName(typeName)) {\n\t    throw new Error('this prompt typeName must follow ITypeName format, leading I, titleized');\n\t  }\n\t  const coreTypesPath = sanitizeName(config.ts.typeDir);\n\t  const typeFilePath = getPathOf(`${coreTypesPath}/${toSnakeCase(typeName)}.ts`);\n\t  const comment = `/*\\n* @category ${toTitleCase(typeName)}\\n*/\\n`;  \n\t  const generatedType = await useAi<CreateTypeResponse>(IPrompts.CREATE_TYPE, typeName)\n\t  if (!fs.existsSync(coreTypesPath)) {\n\t    fs.mkdirSync(coreTypesPath, { recursive: true });\n", "  }\n\t  fs.writeFileSync(typeFilePath, `${comment}${generatedType.message}\\n\\n`);\n\t  return generatedType.message;\n\t}"]}
{"filename": "src/tree/modifier.ts", "chunked_list": ["import fs from 'fs';\n\timport path from \"path\";\n\timport type { Statements } from \"../lib/types\";\n\tinterface ModificationRules {\n\t  type: string;\n\t  action: 'add' | 'edit' | 'delete';\n\t  newText?: string;\n\t  addBeforeText?: string;\n\t  addAfterText?: string;\n\t}\n", "export function createModificationsFunction(): (statement: Statements) => Statements | null {\n\t  const rules = JSON.parse(fs.readFileSync(path.join(__dirname, '../files/mods'), { encoding: 'utf-8' }).toString()) as ModificationRules[];\n\t  return (statement: Statements) => {\n\t    const rule = rules.find((r) => r.type === statement.type);\n\t    if (!rule) {\n\t      return statement;\n\t    }\n\t    switch (rule.action) {\n\t      case 'add':\n\t        return {\n", "          type: statement.type,\n\t          text: rule.addBeforeText + statement.text + rule.addAfterText,\n\t        };\n\t      case 'edit':\n\t        return {\n\t          type: statement.type,\n\t          text: rule.newText!,\n\t        };\n\t      case 'delete':\n\t        return null;\n", "      default:\n\t        return statement;\n\t    }\n\t  };\n\t}"]}
{"filename": "src/tree/ast.ts", "chunked_list": ["import type { Grammar } from \"../lib/types\";\n\t// export const syntacticGroupPatterns = [\n\t//   /_statement$/,          // e.g., if_statement, for_statement, while_statement\n\t//   /_declaration$/,        // e.g., variable_declaration, function_declaration\n\t//   /_definition$/,         // e.g., class_definition, function_definition\n\t//   /_assignment$/,         // e.g., assignment, augmented_assignment\n\t//   /_expression$/,         // e.g., call_expression, binary_expression\n\t//   /_clause$/,             // e.g., case_clause, when_clause\n\t//   /_specifier$/,          // e.g., storage_specifier, type_specifier\n\t//   /_declarator$/,         // e.g., variable_declarator, function_declarator\n", "//   /_item$/,               // e.g., struct_item, enum_item\n\t//   /_pattern$/,            // e.g., tuple_pattern, list_pattern\n\t//   /_literal$/,            // e.g., string_literal, number_literal\n\t//   /_specifier$/,          // e.g., import_specifier, export_specifier\n\t//   /_directive$/,          // e.g., preprocessor_directive, import_directive\n\t//   /_modifier$/,           // e.g., access_modifier, type_modifier\n\t//   /_command$/,            // e.g., pipeline_command, simple_command\n\t//   /_parameter$/,          // e.g., function_parameter, lambda_parameter\n\t//   /_attribute$/,          // e.g., html_attribute, xml_attribute\n\t//   /_tag$/,                // e.g., html_tag, xml_tag\n", "//   /_rule$/,               // e.g., grammar_rule, rewrite_rule\n\t//   /_production$/,         // e.g., grammar_production, nonterminal_production\n\t//   /_label$/,              // e.g., goto_label, case_label\n\t//   /_constructor$/,        // e.g., record_constructor, object_constructor\n\t//   /_binding$/,            // e.g., let_binding, pattern_binding\n\t//   /_condition$/,          // e.g., switch_condition, guard_condition\n\t//   // Add other patterns as needed\n\t// ];\n\tconst syntacticGroupPatterns = [\n\t  /_declaration$/, // Variable, function, class, or module declarations\n", "  /_definition$/, // Variable, function, class, or module definitions\n\t  /_statement$/, // Statements like if, while, for, return, etc.\n\t  /_import$/,\n\t  /_class$/,\n\t  /_function$/\n\t  // /_expression$/, // Expressions like assignment, arithmetic, or function call expressions\n\t];\n\tconst disallowedSubGroupPatterns = [\n\t  /export/,\n\t  /empty/,\n", "  /except_clause$/\n\t];\n\tfunction matchesPatterns(nodeType: string) {\n\t  return syntacticGroupPatterns.some(p => p.test(nodeType)) && disallowedSubGroupPatterns.every(p => !p.test(nodeType));\n\t}\n\t// Modified recursive function to process the AST nodes and return an array of matching nodes\n\texport function getGrammarPatterns(node: Grammar): string[] {\n\t  let matchingNodes: string[] = [];\n\t  if (matchesPatterns(node.type)) {\n\t    console.log(`Found node of type: ${node.type}`);\n", "    if (!matchingNodes.includes(node.type)) {\n\t      matchingNodes.push(node.type); // Add the matching node to the array\n\t    }\n\t  }\n\t  if (node.children) {\n\t    for (const child of node.children.types) {\n\t      getGrammarPatterns(child).forEach(p => {\n\t        if (!matchingNodes.includes(p)) {\n\t          matchingNodes.push(p);\n\t        }\n", "      });\n\t    }\n\t  }\n\t  return matchingNodes;\n\t}\n\t// function linearizeTree(tree) {\n\t//   const linearized = [];\n\t//   const stack: = [];\n\t//   function extractNodeInfo(node) {\n\t//     const type = node.type;\n", "//     const named = node.named;\n\t//     const children = node.subtypes || node.children?.types || [];\n\t//     const content = {\n\t//       fields: node.fields,\n\t//     };\n\t//     return { type, named, children, content };\n\t//   }\n\t//   function traverse(node: Grammar) {\n\t//     const { type, named, content, children } = extractNodeInfo(node);\n\t//     // Create an object representing the current node\n", "//     const obj = {\n\t//       type,\n\t//       named,\n\t//       content,\n\t//       parent: stack.length > 0 ? stack[stack.length - 1] : null\n\t//     };\n\t//     if (children.length === 0) {\n\t//       // Add leaf nodes to the linearized array\n\t//       linearized.push(obj);\n\t//     } else {\n", "//       // Push the current node onto the stack and process its children\n\t//       stack.push(obj);\n\t//       children.forEach(traverse);\n\t//       stack.pop();\n\t//     }\n\t//   }\n\t//   traverse(tree);\n\t//   return linearized;\n\t// }"]}
{"filename": "src/tree/getStatements.ts", "chunked_list": ["// import TreeSitter, { SyntaxNode, Tree } from 'tree-sitter';\n\t// import path from 'path';\n\t// import languages from '../languages';\n\t// import { getFileFromDir } from '../util';\n\t// import { LinearizedStatement } from '../types';\n\t// import { getGrammarPatterns } from './ast';\n\t// const langValues = Object.values(languages);\n\t// export async function getStatements(fileName: string): Promise<LinearizedStatement[]> {\n\t//   const extension = path.extname(fileName).slice(1);\n\t//   const langParser = langValues.find(lang => lang.fileExtension.includes(extension));\n", "//   if (!langParser) throw 'You found an unsupported parser!';\n\t//   const imported = await import(langParser.parserName);\n\t//   const masterGrammars = langParser.parserVariant ? imported.default[langParser.parserVariant] : imported.default;\n\t//   const parser = new TreeSitter();\n\t//   parser.setLanguage(masterGrammars);\n\t//   const code = getFileFromDir(fileName);\n\t//   const parsed = parser.parse(code);\n\t//   const nodeTypes = masterGrammars.nodeTypeInfo.flatMap(getGrammarPatterns);\n\t//   walkNode(parsed.rootNode);\n\t//   return getNodesOfType(parsed, nodeTypes);\n", "// }\n\t// export function walkNode(rootNode: SyntaxNode) {\n\t//   const linearText: Record<number, string> = {};\n\t//   const nodes: SyntaxNode[] = [];\n\t//   function innerWalk (node: SyntaxNode) {\n\t//     for (const child of node.children) {\n\t//       const key = child.startPosition.row;\n\t//       if (!linearText[key]) {\n\t//         linearText[key] = \"\";\n\t//       }\n", "//       linearText[key] += (linearText[key] ? \" \" : \"\") + child.text;\n\t//       // Recursion for deeper levels\n\t//       if (child.children && child.children.length > 0 && !linearText[key].includes(child.children[0].text)) {\n\t//         innerWalk(child);\n\t//       }\n\t//     }\n\t//   }\n\t//   innerWalk(rootNode)\n\t//   return nodes;\n\t// }\n", "// export function getNodesOfType(rootNode: Tree, nodeTypes: string[]): LinearizedStatement[] {\n\t//   let nodeIdCounter = 0;\n\t//   const usedNodes: Map<string, string> = new Map();\n\t//   const nodes: LinearizedStatement[] = [];\n\t//   function visitNode(node: SyntaxNode, parentId?: number): void {\n\t//     const shouldBeParsed = nodeTypes.includes(node.type);\n\t//     if (shouldBeParsed) {\n\t//       const nodeId = nodeIdCounter++;\n\t//       let content = node.text;\n\t//       if (parentId !== undefined) {\n", "//         const parentNode = nodes.find(n => n.i === parentId);\n\t//         if (parentNode) {\n\t//           parentNode.c = parentNode.c.replace(node.text, `XV_${nodeId}`);\n\t//         }\n\t//       }\n\t//       if (!usedNodes.has(node.type)) {\n\t//         usedNodes.set(node.type, `XT_${usedNodes.size + 1}`)\n\t//       }\n\t//       const linearizedStatement: LinearizedStatement = {\n\t//         i: nodeId,\n", "//         p: parentId,\n\t//         t: usedNodes.get(node.type)!,\n\t//         c: content.trim(),\n\t//       };\n\t//       nodes.push(linearizedStatement);\n\t//       if (node.type.includes('declaration')) {\n\t//         parentId = nodeId;\n\t//       }\n\t//     }\n\t//     for (const child of node.children) {\n", "//       visitNode(child, parentId);\n\t//     }\n\t//   }\n\t//   visitNode(rootNode.rootNode);\n\t//   return nodes;\n\t// }\n\t// // async function getMasterGrammars({ parserName, parserVariant }: LanguageParser): Promise<Grammars> {\n\t// //   const imported = await import(parserName);\n\t// //   const masterGrammars = parserVariant ? imported.default[parserVariant] : imported.default;\n\t// //   masterGrammars.nodeTypeInfo = extractApprovedTypes(masterGrammars.nodeTypeInfo);\n", "// //   // if (parserVariant && isDefaultGrammarVariants(imported)) {\n\t// //   //   const grammar = imported.default[parserVariant];\n\t// //   //   masterGrammars.nodeTypeInfo = masterGrammars.nodeTypeInfo.concat(extractApprovedTypes(grammar.nodeTypeInfo))\n\t// //   // } else if (isDefaultGrammar(imported)) {\n\t// //   //   masterGrammars.nodeTypeInfo = masterGrammars.nodeTypeInfo.concat(extractApprovedTypes(imported.default.nodeTypeInfo as Grammar[]));\n\t// //   // } else {\n\t// //   //   throw 'This file type requires unsupported parsers.'\n\t// //   // }\n\t// //   return masterGrammars;\n\t// // }\n", "// // const approvedTypes = ['declaration', 'definition', 'statement', 'expression'];\n\t// // export function extractApprovedTypes(nodeInfo: Grammars['nodeTypeInfo']): Grammars['nodeTypeInfo'] {\n\t// //   const groupedTypes: Grammars['nodeTypeInfo'] = [];\n\t// //   nodeInfo.filter(n => approvedTypes.some(at => n.type.indexOf(at) > -1))\n\t// //   .flatMap(gt => {\n\t// //     return  'subtypes' in gt ? gt.subtypes : undefined;\n\t// //   }).forEach(st => {\n\t// //     if (st && approvedTypes.some(at => st.type.indexOf(at) > -1)) {\n\t// //       groupedTypes.push(st)\n\t// //     }\n", "// //   });\n\t// //   return groupedTypes;\n\t// // }\n\t// // Huffman coding and an adaptation of the Burrows-Wheeler Transform (BWT) for the compression process.\n\texport default {}"]}
{"filename": "src/tree/docker.ts", "chunked_list": ["import fs from 'fs';\n\timport os from 'os';\n\timport path from 'path';\n\timport { execSync } from \"child_process\";\n\timport { getFileParser } from '../server/util';\n\tconst dockerfile = `FROM node:16\\nWORKDIR /app\\nRUN npm install tree-sitter`;\n\tconst imageName = 'wizapp-image';\n\tconst containerName = 'wizapp-container';\n\tconst volumeName = 'wizapp-volume';\n\tlet activeTasks = 0;\n", "export function processFile(fileName: string) {\n\t  activeTasks++;\n\t  buildAndCopyFile(fileName);\n\t  runExtractionScript();\n\t  const localModsPath = 'path/to/your/local_modifications_file';\n\t  copyModifications(localModsPath);\n\t  runModificationScript();\n\t  copyModifiedFileToLocal(fileName);\n\t  activeTasks--;\n\t  if (!activeTasks) {\n", "    setTimeout(() => {\n\t      if (!activeTasks) stopContainer();\n\t    }, 10000)\n\t  }\n\t}\n\tfunction stopContainer() {\n\t  execSync(`docker stop ${containerName}`);\n\t}\n\tfunction buildAndCopyFile(fileName: string) {\n\t  if (!containerExists()) {\n", "    createSharedVolume();\n\t    const tempDockerfilePath = getTempFilePath('Dockerfile', dockerfile);\n\t    execSync(`docker build -t ${imageName} -f ${tempDockerfilePath} .`);\n\t    execSync(`docker create --name ${containerName} -v ${volumeName}:/app/node_modules ${imageName}`);\n\t  } else {\n\t    startContainerIfNotRunning();\n\t  }\n\t  installTreeSitterGrammar(fileName);\n\t  execSync(`docker cp ${fileName} ${containerName}:/app/src/file`);\n\t  // Copy getStatements.js and getStatements.js.map into the Docker container\n", "  const getStatementsPath = path.resolve(__dirname, 'getStatements.js');\n\t  const getStatementsMapPath = path.resolve(__dirname, 'getStatements.js.map');\n\t  execSync(`docker cp ${getStatementsPath} ${containerName}:/app/bin/getStatements.js`);\n\t  execSync(`docker cp ${getStatementsMapPath} ${containerName}:/app/bin/getStatements.js.map`);\n\t}\n\tfunction createSharedVolume() {\n\t  try {\n\t    execSync(`docker volume create ${volumeName}`);\n\t  } catch (error) {\n\t    console.error('Error creating shared volume:', error);\n", "  }\n\t}\n\tfunction startContainerIfNotRunning() {\n\t  const containerStatus = execSync(`docker inspect --format='{{.State.Status}}' ${containerName}`).toString().trim();\n\t  if (containerStatus !== 'running') {\n\t    execSync(`docker start ${containerName}`);\n\t  }\n\t}\n\tfunction getTempFilePath(fileName: string, content: string): string {\n\t  const tempDir = os.tmpdir();\n", "  const tempFilePath = path.join(tempDir, fileName);\n\t  fs.writeFileSync(tempFilePath, content);\n\t  return tempFilePath;\n\t}\n\tfunction containerExists(): boolean {\n\t  try {\n\t    execSync(`docker inspect ${containerName}`);\n\t    return true;\n\t  } catch (error) {\n\t    return false;\n", "  }\n\t}\n\tfunction installTreeSitterGrammar(fileName: string) {\n\t  const parserName = getFileParser(fileName);\n\t  const packageName = `tree-sitter-${parserName}`;\n\t  execSync(`docker exec ${containerName} npm install ${packageName}`);\n\t}\n\tfunction runExtractionScript() {\n\t  const result = execSync(`docker exec ${containerName} node bin/getStatements.js`);\n\t  try {\n", "    return JSON.parse(result.toString());\n\t  } catch (error) {\n\t    console.error('Error parsing JSON from extraction script:', error);\n\t    return [];\n\t  }\n\t}\n\texport function copyContentsToDocker(fileName: string, content: string) {\n\t  const tempContentPath = getTempFilePath(fileName, content);\n\t  execSync(`docker cp ${tempContentPath} ${containerName}:/app/${fileName}`)\n\t}\n", "function copyModifications(localModsPath: string) {\n\t  execSync(`docker cp ${localModsPath} ${containerName}:/app/src/mods`);\n\t}\n\tfunction runModificationScript() {\n\t  execSync(`docker exec ${containerName} node bin/modifyStatements.js -f /app/src/file -e /app/src/mods`);\n\t}\n\tfunction copyModifiedFileToLocal(fileName: string) {\n\t  const modifiedfileName = 'modified_' + fileName;\n\t  execSync(`docker cp ${containerName}:/app/src/modified_file ${modifiedfileName}`);\n\t  execSync(`docker rm ${containerName}`);\n", "  fs.writeFileSync(fileName, fs.readFileSync(modifiedfileName));\n\t}"]}
{"filename": "src/tree/modifyStatements.ts", "chunked_list": ["// import fs from 'fs';\n\timport type { Node, Statements } from '../lib/types';\n\t// import { parseFile } from './getStatements';\n\texport function modifyStatements(\n\t  node: Node,\n\t  modifications: (statement: Statements) => Statements | null\n\t): Node | null {\n\t  // Modify, add or delete statements based on modifications function\n\t  const statement = { type: node.type, text: node.text };\n\t  const modifiedStatement = modifications(statement);\n", "  if (modifiedStatement) {\n\t    node.text = modifiedStatement.text;\n\t  } else {\n\t    return null;\n\t  }\n\t  node.children = node.children\n\t    .map((child) => modifyStatements(child, modifications))\n\t    .filter((child) => child !== null) as Node[];\n\t  return node;\n\t}\n", "// export async function modifyStatementsInFile(\n\t//   modifications: (statement: Statements) => Statements | null\n\t// ): Promise<string> {\n\t//   const files = fs.readdirSync('../files');\n\t//   const modificationFileName = files.find(f => f.startsWith('modifications'));\n\t//   const root = await parseFile();\n\t//   const modifiedRoot = modifyStatements(root.rootNode, modifications);\n\t//   // Serialize the modified AST back to the source code\n\t//   // You can use a library like \"ast-pretty-print\" or write your own serialization function\n\t//   const modifiedCode = serializeAstToCode(modifiedRoot);\n", "//   return modifiedCode;\n\t// }"]}
{"filename": "src/tree/js/abstract-syntax-tree.d.ts", "chunked_list": ["// declare module 'abstract-syntax-tree' {\n\t//   export type NodeType =\n\t//     | 'Program'\n\t//     | 'FunctionDeclaration'\n\t//     | 'VariableDeclaration'\n\t//     | 'ExpressionStatement'\n\t//     | 'CallExpression'\n\t//     | 'Identifier'\n\t//     | 'Literal'\n\t//     | 'BinaryExpression'\n", "//     | 'ArrayExpression'\n\t//     | 'ObjectExpression'\n\t//     | 'Property'\n\t//     | 'AssignmentExpression'\n\t//     | 'MemberExpression'\n\t//     | 'ThisExpression'\n\t//     | 'BlockStatement'\n\t//     | 'IfStatement'\n\t//     | 'SwitchStatement'\n\t//     | 'SwitchCase'\n", "//     | 'ForStatement'\n\t//     | 'WhileStatement'\n\t//     | 'DoWhileStatement'\n\t//     | 'BreakStatement'\n\t//     | 'ContinueStatement'\n\t//     | 'TryStatement'\n\t//     | 'CatchClause'\n\t//     | 'ThrowStatement'\n\t//     | 'ReturnStatement'\n\t//     | 'UnaryExpression'\n", "//     | 'UpdateExpression'\n\t//     | 'LogicalExpression'\n\t//     | 'ConditionalExpression'\n\t//     | 'NewExpression'\n\t//     | 'ArrowFunctionExpression'\n\t//     | 'YieldExpression'\n\t//     | 'TemplateLiteral'\n\t//     | 'TemplateElement'\n\t//     | 'TaggedTemplateExpression'\n\t//     | 'ClassDeclaration'\n", "//     | 'ClassExpression'\n\t//     | 'ClassBody'\n\t//     | 'MethodDefinition'\n\t//     | 'ImportDeclaration'\n\t//     | 'ImportSpecifier'\n\t//     | 'ExportDefaultDeclaration'\n\t//     | 'ExportNamedDeclaration'\n\t//     | 'ExportSpecifier'\n\t//     | 'ForInStatement'\n\t//     | 'ForOfStatement'\n", "//     | 'AwaitExpression'\n\t//     | 'SpreadElement'\n\t//     | 'RestElement'\n\t//     | 'AssignmentPattern'\n\t//     | 'ArrayPattern'\n\t//     | 'ObjectPattern'\n\t//     | 'MetaProperty'\n\t//     | 'Super'\n\t//     | 'Import'\n\t//     | 'ChainExpression';\n", "//   export interface Node {\n\t//     type: NodeType;\n\t//     loc?: SourceLocation;\n\t//     [key: string]: any;\n\t//   }\n\t//   export interface SourceLocation {\n\t//     start: Position;\n\t//     end: Position;\n\t//     source?: string | null;\n\t//   }\n", "//   export interface Position {\n\t//     line: number;\n\t//     column: number;\n\t//   }\n\t//   export interface ParseOptions {\n\t//     ecmaVersion?: number;\n\t//     sourceType?: 'script' | 'module';\n\t//     locations?: boolean;\n\t//     ranges?: boolean;\n\t//     comment?: boolean;\n", "//   }\n\t//   export function parse(source: string, options?: ParseOptions): Node;\n\t//   export function generate(tree: Node): string;\n\t//   export function walk(tree: Node, callback: (node: Node, parent: Node | null) => void): void;\n\t//   export function find(tree: Node, selector: NodeType | { [key: string]: any }): Node[];\n\t//   export function serialize(node: Node): any;\n\t//   export function traverse(tree: Node, options: { enter?: (node: Node) => void; leave?: (node: Node) => void }): void;\n\t//   export function replace(tree: Node, callback: (node: Node) => Node | null): void;\n\t//   export function remove(tree: Node, selector: NodeType | { [key: string]: any } | ((node: Node) => Node | null)): void;\n\t//   export function each(tree: Node, selector: NodeType, callback: (node: Node) => void): void;\n", "//   export function first(tree: Node, selector: NodeType): Node | undefined;\n\t//   export function last(tree: Node, selector: NodeType): Node | undefined;\n\t//   export function reduce(tree: Node, callback: (accumulator: any, node: Node) => any, accumulator: any): any;\n\t//   export function has(tree: Node, selector: NodeType | { [key: string]: any }): boolean;\n\t//   export function count(tree: Node, selector: NodeType | { [key: string]: any }): number;\n\t//   export function append(tree: Node, node: Node | string): void;\n\t//   export function prepend(tree: Node, node: Node | string): void;\n\t//   export function equal(node1: Node, node2: Node): boolean;\n\t//   export function match(node: Node, selector: string): boolean;\n\t//   export function template(templateString: string, replacements?: { [key: string]: any }): Node[];\n", "//   export function program(): Node;\n\t//   export function iife(): Node;\n\t// }"]}
{"filename": "src/tree/js/index.ts", "chunked_list": ["export * from './jsx-parser';"]}
{"filename": "src/tree/js/jsx-parser.ts", "chunked_list": ["// import { ParseResult, parse as babelParse } from '@babel/parser';\n\t// import { parse, Node } from 'abstract-syntax-tree';\n\t// import { File } from 'buffer';\n\t// export function parseJSX(source: string): ParseResult<File> {\n\t//   const ast = babelParse(source, {\n\t//     sourceType: 'module',\n\t//     plugins: ['jsx'],\n\t//   });\n\t//   // return ast;\n\t// }\n", "export default {}"]}
