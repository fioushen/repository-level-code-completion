{"filename": "test/providers/auth.service.spec.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport * as bcrypt from 'bcrypt';\n\timport * as request from 'supertest';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { Test, TestingModule } from '@nestjs/testing';\n\timport { databaseConfig } from 'src/config/configuration';\n\timport { SequelizeConfigService } from 'src/config/sequelizeConfig.service';\n\timport { User } from 'src/users/users.model';\n\timport { AuthModule } from 'src/auth/auth.module';\n", "import { AuthService } from 'src/auth/auth.service';\n\tconst mockedUser = {\n\t  username: 'Jhon',\n\t  email: 'jhon@gmail.com',\n\t  password: 'jhon123',\n\t};\n\tdescribe('Auth Service', () => {\n\t  let app: INestApplication;\n\t  let authService: AuthService;\n\t  beforeEach(async () => {\n", "    const testModule: TestingModule = await Test.createTestingModule({\n\t      imports: [\n\t        SequelizeModule.forRootAsync({\n\t          imports: [ConfigModule],\n\t          useClass: SequelizeConfigService,\n\t        }),\n\t        ConfigModule.forRoot({\n\t          load: [databaseConfig],\n\t        }),\n\t        AuthModule,\n", "      ],\n\t    }).compile();\n\t    authService = testModule.get<AuthService>(AuthService);\n\t    app = testModule.createNestApplication();\n\t    await app.init();\n\t  });\n\t  beforeEach(async () => {\n\t    const user = new User();\n\t    const hashedPassword = await bcrypt.hash(mockedUser.password, 10);\n\t    user.username = mockedUser.username;\n", "    user.password = hashedPassword;\n\t    user.email = mockedUser.email;\n\t    return user.save();\n\t  });\n\t  afterEach(async () => {\n\t    await User.destroy({ where: { username: mockedUser.username } });\n\t  });\n\t  it('should login user', async () => {\n\t    const user = await authService.validateUser(\n\t      mockedUser.username,\n", "      mockedUser.password,\n\t    );\n\t    expect(user.username).toBe(mockedUser.username);\n\t    expect(user.email).toBe(mockedUser.email);\n\t  });\n\t});\n"]}
{"filename": "test/providers/users.service.spec.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport * as bcrypt from 'bcrypt';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { Test, TestingModule } from '@nestjs/testing';\n\timport { databaseConfig } from 'src/config/configuration';\n\timport { SequelizeConfigService } from 'src/config/sequelizeConfig.service';\n\timport { User } from 'src/users/users.model';\n\timport { UsersModule } from 'src/users/users.module';\n\timport { UsersService } from 'src/users/users.service';\n", "describe('Users Service', () => {\n\t  let app: INestApplication;\n\t  let usersService: UsersService;\n\t  beforeEach(async () => {\n\t    const testModule: TestingModule = await Test.createTestingModule({\n\t      imports: [\n\t        SequelizeModule.forRootAsync({\n\t          imports: [ConfigModule],\n\t          useClass: SequelizeConfigService,\n\t        }),\n", "        ConfigModule.forRoot({\n\t          load: [databaseConfig],\n\t        }),\n\t        UsersModule,\n\t      ],\n\t    }).compile();\n\t    usersService = testModule.get<UsersService>(UsersService);\n\t    app = testModule.createNestApplication();\n\t    await app.init();\n\t  });\n", "  afterEach(async () => {\n\t    await User.destroy({ where: { username: 'Test' } });\n\t  });\n\t  it('should create user', async () => {\n\t    const newUser = {\n\t      username: 'Test',\n\t      email: 'test@gmail.com',\n\t      password: 'test123',\n\t    };\n\t    const user = (await usersService.create(newUser)) as User;\n", "    const passwordIsValid = await bcrypt.compare(\n\t      newUser.password,\n\t      user.password,\n\t    );\n\t    expect(user.username).toBe(newUser.username);\n\t    expect(passwordIsValid).toBe(true);\n\t    expect(user.email).toBe(newUser.email);\n\t  });\n\t});\n"]}
{"filename": "test/providers/payment.service.spec.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport * as request from 'supertest';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { Test, TestingModule } from '@nestjs/testing';\n\timport { databaseConfig } from 'src/config/configuration';\n\timport { SequelizeConfigService } from 'src/config/sequelizeConfig.service';\n\timport { PaymentModule } from '../../src/payment/payment.module';\n\timport { PaymentService } from 'src/payment/payment.service';\n\tdescribe('Payment Service', () => {\n", "  let app: INestApplication;\n\t  let paymentService: PaymentService;\n\t  beforeEach(async () => {\n\t    const testModule: TestingModule = await Test.createTestingModule({\n\t      imports: [\n\t        SequelizeModule.forRootAsync({\n\t          imports: [ConfigModule],\n\t          useClass: SequelizeConfigService,\n\t        }),\n\t        ConfigModule.forRoot({\n", "          load: [databaseConfig],\n\t        }),\n\t        PaymentModule,\n\t      ],\n\t    }).compile();\n\t    paymentService = testModule.get<PaymentService>(PaymentService);\n\t    app = testModule.createNestApplication();\n\t    await app.init();\n\t  });\n\t  it('should make payment', async () => {\n", "    const data = await paymentService.makePayment({ amount: 100 });\n\t    expect(data).toEqual(\n\t      expect.objectContaining({\n\t        id: expect.any(String),\n\t        status: expect.any(String),\n\t        amount: {\n\t          value: expect.any(String),\n\t          currency: expect.any(String),\n\t        },\n\t        description: expect.any(String),\n", "        recipient: {\n\t          account_id: expect.any(String),\n\t          gateway_id: expect.any(String),\n\t        },\n\t        created_at: expect.any(String),\n\t        confirmation: {\n\t          type: expect.any(String),\n\t          confirmation_url: expect.any(String),\n\t        },\n\t        test: expect.any(Boolean),\n", "        paid: expect.any(Boolean),\n\t        refundable: expect.any(Boolean),\n\t        metadata: expect.any(Object),\n\t      }),\n\t    );\n\t  });\n\t});\n"]}
{"filename": "test/providers/boiler-parts.service.spec.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport * as bcrypt from 'bcrypt';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { Test, TestingModule } from '@nestjs/testing';\n\timport { databaseConfig } from 'src/config/configuration';\n\timport { SequelizeConfigService } from 'src/config/sequelizeConfig.service';\n\timport { User } from 'src/users/users.model';\n\timport { BoilerPartsModule } from '../../src/boiler-parts/boiler-parts.module';\n\timport { BoilerPartsService } from 'src/boiler-parts/boiler-parts.service';\n", "describe('Auth Service', () => {\n\t  let app: INestApplication;\n\t  let boilerPartsService: BoilerPartsService;\n\t  beforeEach(async () => {\n\t    const testModule: TestingModule = await Test.createTestingModule({\n\t      imports: [\n\t        SequelizeModule.forRootAsync({\n\t          imports: [ConfigModule],\n\t          useClass: SequelizeConfigService,\n\t        }),\n", "        ConfigModule.forRoot({\n\t          load: [databaseConfig],\n\t        }),\n\t        BoilerPartsModule,\n\t      ],\n\t    }).compile();\n\t    boilerPartsService = testModule.get<BoilerPartsService>(BoilerPartsService);\n\t    app = testModule.createNestApplication();\n\t    await app.init();\n\t  });\n", "  it('should find by id', async () => {\n\t    const part = await boilerPartsService.findOne(1);\n\t    expect(part.dataValues).toEqual(\n\t      expect.objectContaining({\n\t        id: 1,\n\t        price: expect.any(Number),\n\t        boiler_manufacturer: expect.any(String),\n\t        parts_manufacturer: expect.any(String),\n\t        vendor_code: expect.any(String),\n\t        name: expect.any(String),\n", "        description: expect.any(String),\n\t        images: expect.any(String),\n\t        in_stock: expect.any(Number),\n\t        bestseller: expect.any(Boolean),\n\t        new: expect.any(Boolean),\n\t        popularity: expect.any(Number),\n\t        compatibility: expect.any(String),\n\t        createdAt: expect.any(Date),\n\t        updatedAt: expect.any(Date),\n\t      }),\n", "    );\n\t  });\n\t  it('should find by name', async () => {\n\t    const part = await boilerPartsService.findOneByName('Voluptas saepe.');\n\t    expect(part.dataValues).toEqual(\n\t      expect.objectContaining({\n\t        id: expect.any(Number),\n\t        price: expect.any(Number),\n\t        boiler_manufacturer: expect.any(String),\n\t        parts_manufacturer: expect.any(String),\n", "        vendor_code: expect.any(String),\n\t        name: 'Voluptas saepe.',\n\t        description: expect.any(String),\n\t        images: expect.any(String),\n\t        in_stock: expect.any(Number),\n\t        bestseller: expect.any(Boolean),\n\t        new: expect.any(Boolean),\n\t        popularity: expect.any(Number),\n\t        compatibility: expect.any(String),\n\t        createdAt: expect.any(Date),\n", "        updatedAt: expect.any(Date),\n\t      }),\n\t    );\n\t  });\n\t  it('should find by search string', async () => {\n\t    const parts = await boilerPartsService.searchByString('nos');\n\t    expect(parts.rows.length).toBeLessThanOrEqual(20);\n\t    parts.rows.forEach((item) => {\n\t      expect(item.name.toLowerCase()).toContain('nos');\n\t      expect(item.dataValues).toEqual(\n", "        expect.objectContaining({\n\t          id: expect.any(Number),\n\t          price: expect.any(Number),\n\t          boiler_manufacturer: expect.any(String),\n\t          parts_manufacturer: expect.any(String),\n\t          vendor_code: expect.any(String),\n\t          name: expect.any(String),\n\t          description: expect.any(String),\n\t          images: expect.any(String),\n\t          in_stock: expect.any(Number),\n", "          bestseller: expect.any(Boolean),\n\t          new: expect.any(Boolean),\n\t          popularity: expect.any(Number),\n\t          compatibility: expect.any(String),\n\t          createdAt: expect.any(Date),\n\t          updatedAt: expect.any(Date),\n\t        }),\n\t      );\n\t    });\n\t  });\n", "  it('should find bestsellers', async () => {\n\t    const parts = await boilerPartsService.bestsellers();\n\t    parts.rows.forEach((item) => {\n\t      expect(item.dataValues).toEqual(\n\t        expect.objectContaining({\n\t          id: expect.any(Number),\n\t          price: expect.any(Number),\n\t          boiler_manufacturer: expect.any(String),\n\t          parts_manufacturer: expect.any(String),\n\t          vendor_code: expect.any(String),\n", "          name: expect.any(String),\n\t          description: expect.any(String),\n\t          images: expect.any(String),\n\t          in_stock: expect.any(Number),\n\t          bestseller: true,\n\t          new: expect.any(Boolean),\n\t          popularity: expect.any(Number),\n\t          compatibility: expect.any(String),\n\t          createdAt: expect.any(Date),\n\t          updatedAt: expect.any(Date),\n", "        }),\n\t      );\n\t    });\n\t  });\n\t  it('should find new parts', async () => {\n\t    const parts = await boilerPartsService.new();\n\t    parts.rows.forEach((item) => {\n\t      expect(item.dataValues).toEqual(\n\t        expect.objectContaining({\n\t          id: expect.any(Number),\n", "          price: expect.any(Number),\n\t          boiler_manufacturer: expect.any(String),\n\t          parts_manufacturer: expect.any(String),\n\t          vendor_code: expect.any(String),\n\t          name: expect.any(String),\n\t          description: expect.any(String),\n\t          images: expect.any(String),\n\t          in_stock: expect.any(Number),\n\t          bestseller: expect.any(Boolean),\n\t          new: true,\n", "          popularity: expect.any(Number),\n\t          compatibility: expect.any(String),\n\t          createdAt: expect.any(Date),\n\t          updatedAt: expect.any(Date),\n\t        }),\n\t      );\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/providers/shopping-cart.service.spec.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport * as bcrypt from 'bcrypt';\n\timport * as request from 'supertest';\n\timport * as session from 'express-session';\n\timport * as passport from 'passport';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { Test, TestingModule } from '@nestjs/testing';\n\timport { databaseConfig } from 'src/config/configuration';\n\timport { SequelizeConfigService } from 'src/config/sequelizeConfig.service';\n", "import { User } from 'src/users/users.model';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { BoilerPartsModule } from 'src/boiler-parts/boiler-parts.module';\n\timport { BoilerPartsService } from '../../src/boiler-parts/boiler-parts.service';\n\timport { UsersService } from '../../src/users/users.service';\n\timport { ShoppingCart } from '../../src/shopping-cart/shopping-cart.model';\n\timport { ShoppingCartModule } from '../../src/shopping-cart/shopping-cart.module';\n\timport { ShoppingCartService } from '../../src/shopping-cart/shopping-cart.service';\n\tconst mockedUser = {\n\t  username: 'Jhon',\n", "  email: 'jhon@gmail.com',\n\t  password: 'jhon123',\n\t};\n\tdescribe('Shopping Cart Service', () => {\n\t  let app: INestApplication;\n\t  let boilerPartsService: BoilerPartsService;\n\t  let usersService: UsersService;\n\t  let shoppingCartService: ShoppingCartService;\n\t  beforeEach(async () => {\n\t    const testModule: TestingModule = await Test.createTestingModule({\n", "      imports: [\n\t        SequelizeModule.forRootAsync({\n\t          imports: [ConfigModule],\n\t          useClass: SequelizeConfigService,\n\t        }),\n\t        ConfigModule.forRoot({\n\t          load: [databaseConfig],\n\t        }),\n\t        ShoppingCartModule,\n\t        BoilerPartsModule,\n", "      ],\n\t    }).compile();\n\t    boilerPartsService = testModule.get<BoilerPartsService>(BoilerPartsService);\n\t    usersService = testModule.get<UsersService>(UsersService);\n\t    shoppingCartService =\n\t      testModule.get<ShoppingCartService>(ShoppingCartService);\n\t    app = testModule.createNestApplication();\n\t    await app.init();\n\t  });\n\t  beforeEach(async () => {\n", "    const user = new User();\n\t    const hashedPassword = await bcrypt.hash(mockedUser.password, 10);\n\t    user.username = mockedUser.username;\n\t    user.password = hashedPassword;\n\t    user.email = mockedUser.email;\n\t    return user.save();\n\t  });\n\t  beforeEach(async () => {\n\t    const cart = new ShoppingCart();\n\t    const user = await usersService.findOne({\n", "      where: { username: mockedUser.username },\n\t    });\n\t    const part = await boilerPartsService.findOne(1);\n\t    cart.userId = user.id;\n\t    cart.partId = part.id;\n\t    cart.boiler_manufacturer = part.boiler_manufacturer;\n\t    cart.parts_manufacturer = part.parts_manufacturer;\n\t    cart.price = part.price;\n\t    cart.in_stock = part.in_stock;\n\t    cart.image = JSON.parse(part.images)[0];\n", "    cart.name = part.name;\n\t    cart.total_price = part.price;\n\t    return cart.save();\n\t  });\n\t  afterEach(async () => {\n\t    await User.destroy({ where: { username: mockedUser.username } });\n\t    await ShoppingCart.destroy({ where: { partId: 1 } });\n\t  });\n\t  it('should return all cart items', async () => {\n\t    const user = await usersService.findOne({\n", "      where: { username: mockedUser.username },\n\t    });\n\t    const cart = await shoppingCartService.findAll(user.id);\n\t    cart.forEach((item) =>\n\t      expect(item.dataValues).toEqual(\n\t        expect.objectContaining({\n\t          id: expect.any(Number),\n\t          userId: user.id,\n\t          partId: expect.any(Number),\n\t          boiler_manufacturer: expect.any(String),\n", "          price: expect.any(Number),\n\t          parts_manufacturer: expect.any(String),\n\t          name: expect.any(String),\n\t          image: expect.any(String),\n\t          count: expect.any(Number),\n\t          total_price: expect.any(Number),\n\t          in_stock: expect.any(Number),\n\t          createdAt: expect.any(Date),\n\t          updatedAt: expect.any(Date),\n\t        }),\n", "      ),\n\t    );\n\t  });\n\t  it('should add cart items', async () => {\n\t    await shoppingCartService.add({\n\t      username: mockedUser.username,\n\t      partId: 3,\n\t    });\n\t    const user = await usersService.findOne({\n\t      where: { username: mockedUser.username },\n", "    });\n\t    const cart = await shoppingCartService.findAll(user.id);\n\t    expect(cart.find((item) => item.partId === 3)).toEqual(\n\t      expect.objectContaining({\n\t        id: expect.any(Number),\n\t        userId: user.id,\n\t        partId: 3,\n\t        boiler_manufacturer: expect.any(String),\n\t        price: expect.any(Number),\n\t        parts_manufacturer: expect.any(String),\n", "        name: expect.any(String),\n\t        image: expect.any(String),\n\t        count: expect.any(Number),\n\t        total_price: expect.any(Number),\n\t        in_stock: expect.any(Number),\n\t        createdAt: expect.any(Date),\n\t        updatedAt: expect.any(Date),\n\t      }),\n\t    );\n\t  });\n", "  it('should return updated count', async () => {\n\t    const result = await shoppingCartService.updateCount(2, 1);\n\t    expect(result).toEqual({ count: 2 });\n\t  });\n\t  it('should return updated total price', async () => {\n\t    const part = await boilerPartsService.findOne(1);\n\t    const result = await shoppingCartService.updateTotalPrice(\n\t      part.price * 3,\n\t      1,\n\t    );\n", "    expect(result).toEqual({ total_price: part.price * 3 });\n\t  });\n\t  it('should delete cart item', async () => {\n\t    await shoppingCartService.remove(1);\n\t    const user = await usersService.findOne({\n\t      where: { username: mockedUser.username },\n\t    });\n\t    const cart = await shoppingCartService.findAll(user.id);\n\t    expect(cart.find((item) => item.partId === 1)).toBeUndefined();\n\t  });\n", "  it('should delete all cart items', async () => {\n\t    const user = await usersService.findOne({\n\t      where: { username: mockedUser.username },\n\t    });\n\t    await shoppingCartService.removeAll(user.id);\n\t    const cart = await shoppingCartService.findAll(user.id);\n\t    expect(cart).toStrictEqual([]);\n\t  });\n\t});\n"]}
{"filename": "test/controllers/users.controller.spec.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport * as bcrypt from 'bcrypt';\n\timport * as request from 'supertest';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { Test, TestingModule } from '@nestjs/testing';\n\timport { databaseConfig } from 'src/config/configuration';\n\timport { SequelizeConfigService } from 'src/config/sequelizeConfig.service';\n\timport { User } from 'src/users/users.model';\n\timport { UsersModule } from 'src/users/users.module';\n", "describe('Users Controller', () => {\n\t  let app: INestApplication;\n\t  beforeEach(async () => {\n\t    const testModule: TestingModule = await Test.createTestingModule({\n\t      imports: [\n\t        SequelizeModule.forRootAsync({\n\t          imports: [ConfigModule],\n\t          useClass: SequelizeConfigService,\n\t        }),\n\t        ConfigModule.forRoot({\n", "          load: [databaseConfig],\n\t        }),\n\t        UsersModule,\n\t      ],\n\t    }).compile();\n\t    app = testModule.createNestApplication();\n\t    await app.init();\n\t  });\n\t  afterEach(async () => {\n\t    await User.destroy({ where: { username: 'Test' } });\n", "  });\n\t  it('should create user', async () => {\n\t    const newUser = {\n\t      username: 'Test',\n\t      email: 'test@gmail.com',\n\t      password: 'test123',\n\t    };\n\t    const response = await request(app.getHttpServer())\n\t      .post('/users/signup')\n\t      .send(newUser);\n", "    const passwordIsValid = await bcrypt.compare(\n\t      newUser.password,\n\t      response.body.password,\n\t    );\n\t    expect(response.body.username).toBe(newUser.username);\n\t    expect(passwordIsValid).toBe(true);\n\t    expect(response.body.email).toBe(newUser.email);\n\t  });\n\t});\n"]}
{"filename": "test/controllers/payment.controller.spec.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport * as bcrypt from 'bcrypt';\n\timport * as request from 'supertest';\n\timport * as session from 'express-session';\n\timport * as passport from 'passport';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { Test, TestingModule } from '@nestjs/testing';\n\timport { databaseConfig } from 'src/config/configuration';\n\timport { SequelizeConfigService } from 'src/config/sequelizeConfig.service';\n", "import { User } from 'src/users/users.model';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { PaymentModule } from '../../src/payment/payment.module';\n\tconst mockedUser = {\n\t  username: 'Jhon',\n\t  email: 'jhon@gmail.com',\n\t  password: 'jhon123',\n\t};\n\tconst mockedPay = {\n\t  status: 'pending',\n", "  amount: {\n\t    value: '100.00',\n\t    currency: 'RUB',\n\t  },\n\t};\n\tdescribe('Payment Controller', () => {\n\t  let app: INestApplication;\n\t  beforeEach(async () => {\n\t    const testModule: TestingModule = await Test.createTestingModule({\n\t      imports: [\n", "        SequelizeModule.forRootAsync({\n\t          imports: [ConfigModule],\n\t          useClass: SequelizeConfigService,\n\t        }),\n\t        ConfigModule.forRoot({\n\t          load: [databaseConfig],\n\t        }),\n\t        PaymentModule,\n\t        AuthModule,\n\t      ],\n", "    }).compile();\n\t    app = testModule.createNestApplication();\n\t    app.use(\n\t      session({\n\t        secret: 'keyword',\n\t        resave: false,\n\t        saveUninitialized: false,\n\t      }),\n\t    );\n\t    app.use(passport.initialize());\n", "    app.use(passport.session());\n\t    await app.init();\n\t  });\n\t  beforeEach(async () => {\n\t    const user = new User();\n\t    const hashedPassword = await bcrypt.hash(mockedUser.password, 10);\n\t    user.username = mockedUser.username;\n\t    user.password = hashedPassword;\n\t    user.email = mockedUser.email;\n\t    return user.save();\n", "  });\n\t  afterEach(async () => {\n\t    await User.destroy({ where: { username: mockedUser.username } });\n\t  });\n\t  it('should make payment', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    const response = await request(app.getHttpServer())\n\t      .post('/payment')\n", "      .send({ amount: 100 })\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    expect(response.body.status).toEqual(mockedPay.status);\n\t    expect(response.body.amount).toEqual(mockedPay.amount);\n\t  });\n\t});\n"]}
{"filename": "test/controllers/boiler-parts.controller.spec.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport * as bcrypt from 'bcrypt';\n\timport * as request from 'supertest';\n\timport * as session from 'express-session';\n\timport * as passport from 'passport';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { Test, TestingModule } from '@nestjs/testing';\n\timport { databaseConfig } from 'src/config/configuration';\n\timport { SequelizeConfigService } from 'src/config/sequelizeConfig.service';\n", "import { User } from 'src/users/users.model';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { BoilerPartsModule } from 'src/boiler-parts/boiler-parts.module';\n\tconst mockedUser = {\n\t  username: 'Jhon',\n\t  email: 'jhon@gmail.com',\n\t  password: 'jhon123',\n\t};\n\tdescribe('Boiler Parts Controller', () => {\n\t  let app: INestApplication;\n", "  beforeEach(async () => {\n\t    const testModule: TestingModule = await Test.createTestingModule({\n\t      imports: [\n\t        SequelizeModule.forRootAsync({\n\t          imports: [ConfigModule],\n\t          useClass: SequelizeConfigService,\n\t        }),\n\t        ConfigModule.forRoot({\n\t          load: [databaseConfig],\n\t        }),\n", "        BoilerPartsModule,\n\t        AuthModule,\n\t      ],\n\t    }).compile();\n\t    app = testModule.createNestApplication();\n\t    app.use(\n\t      session({\n\t        secret: 'keyword',\n\t        resave: false,\n\t        saveUninitialized: false,\n", "      }),\n\t    );\n\t    app.use(passport.initialize());\n\t    app.use(passport.session());\n\t    await app.init();\n\t  });\n\t  beforeEach(async () => {\n\t    const user = new User();\n\t    const hashedPassword = await bcrypt.hash(mockedUser.password, 10);\n\t    user.username = mockedUser.username;\n", "    user.password = hashedPassword;\n\t    user.email = mockedUser.email;\n\t    return user.save();\n\t  });\n\t  afterEach(async () => {\n\t    await User.destroy({ where: { username: mockedUser.username } });\n\t  });\n\t  it('should get one part', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n", "      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    const response = await request(app.getHttpServer())\n\t      .get('/boiler-parts/find/1')\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    expect(response.body).toEqual(\n\t      expect.objectContaining({\n\t        id: 1,\n\t        price: expect.any(Number),\n\t        boiler_manufacturer: expect.any(String),\n\t        parts_manufacturer: expect.any(String),\n", "        vendor_code: expect.any(String),\n\t        name: expect.any(String),\n\t        description: expect.any(String),\n\t        images: expect.any(String),\n\t        in_stock: expect.any(Number),\n\t        bestseller: expect.any(Boolean),\n\t        new: expect.any(Boolean),\n\t        popularity: expect.any(Number),\n\t        compatibility: expect.any(String),\n\t        createdAt: expect.any(String),\n", "        updatedAt: expect.any(String),\n\t      }),\n\t    );\n\t  });\n\t  it('should get bestsellers', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    const response = await request(app.getHttpServer())\n\t      .get('/boiler-parts/bestsellers')\n", "      .set('Cookie', login.headers['set-cookie']);\n\t    expect(response.body.rows).toEqual(\n\t      expect.arrayContaining([\n\t        {\n\t          id: expect.any(Number),\n\t          price: expect.any(Number),\n\t          boiler_manufacturer: expect.any(String),\n\t          parts_manufacturer: expect.any(String),\n\t          vendor_code: expect.any(String),\n\t          name: expect.any(String),\n", "          description: expect.any(String),\n\t          images: expect.any(String),\n\t          in_stock: expect.any(Number),\n\t          bestseller: true,\n\t          new: expect.any(Boolean),\n\t          popularity: expect.any(Number),\n\t          compatibility: expect.any(String),\n\t          createdAt: expect.any(String),\n\t          updatedAt: expect.any(String),\n\t        },\n", "      ]),\n\t    );\n\t  });\n\t  it('should get new parts', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    const response = await request(app.getHttpServer())\n\t      .get('/boiler-parts/new')\n\t      .set('Cookie', login.headers['set-cookie']);\n", "    expect(response.body.rows).toEqual(\n\t      expect.arrayContaining([\n\t        {\n\t          id: expect.any(Number),\n\t          price: expect.any(Number),\n\t          boiler_manufacturer: expect.any(String),\n\t          parts_manufacturer: expect.any(String),\n\t          vendor_code: expect.any(String),\n\t          name: expect.any(String),\n\t          description: expect.any(String),\n", "          images: expect.any(String),\n\t          in_stock: expect.any(Number),\n\t          bestseller: expect.any(Boolean),\n\t          new: true,\n\t          popularity: expect.any(Number),\n\t          compatibility: expect.any(String),\n\t          createdAt: expect.any(String),\n\t          updatedAt: expect.any(String),\n\t        },\n\t      ]),\n", "    );\n\t  });\n\t  it('should search by string', async () => {\n\t    const body = { search: 'nos' };\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    const response = await request(app.getHttpServer())\n\t      .post('/boiler-parts/search')\n\t      .send(body)\n", "      .set('Cookie', login.headers['set-cookie']);\n\t    expect(response.body.rows.length).toBeLessThanOrEqual(20);\n\t    response.body.rows.forEach((element) => {\n\t      expect(element.name.toLowerCase()).toContain(body.search);\n\t    });\n\t    expect(response.body.rows).toEqual(\n\t      expect.arrayContaining([\n\t        {\n\t          id: expect.any(Number),\n\t          price: expect.any(Number),\n", "          boiler_manufacturer: expect.any(String),\n\t          parts_manufacturer: expect.any(String),\n\t          vendor_code: expect.any(String),\n\t          name: expect.any(String),\n\t          description: expect.any(String),\n\t          images: expect.any(String),\n\t          in_stock: expect.any(Number),\n\t          bestseller: expect.any(Boolean),\n\t          new: expect.any(Boolean),\n\t          popularity: expect.any(Number),\n", "          compatibility: expect.any(String),\n\t          createdAt: expect.any(String),\n\t          updatedAt: expect.any(String),\n\t        },\n\t      ]),\n\t    );\n\t  });\n\t  it('should get by name', async () => {\n\t    const body = { name: 'Voluptas saepe.' };\n\t    const login = await request(app.getHttpServer())\n", "      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    const response = await request(app.getHttpServer())\n\t      .post('/boiler-parts/name')\n\t      .send(body)\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    expect(response.body).toEqual(\n\t      expect.objectContaining({\n\t        id: expect.any(Number),\n\t        price: expect.any(Number),\n", "        boiler_manufacturer: expect.any(String),\n\t        parts_manufacturer: expect.any(String),\n\t        vendor_code: expect.any(String),\n\t        name: 'Voluptas saepe.',\n\t        description: expect.any(String),\n\t        images: expect.any(String),\n\t        in_stock: expect.any(Number),\n\t        bestseller: expect.any(Boolean),\n\t        new: expect.any(Boolean),\n\t        popularity: expect.any(Number),\n", "        compatibility: expect.any(String),\n\t        createdAt: expect.any(String),\n\t        updatedAt: expect.any(String),\n\t      }),\n\t    );\n\t  });\n\t});\n"]}
{"filename": "test/controllers/shopping-cart.controller.spec.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport * as bcrypt from 'bcrypt';\n\timport * as request from 'supertest';\n\timport * as session from 'express-session';\n\timport * as passport from 'passport';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { Test, TestingModule } from '@nestjs/testing';\n\timport { databaseConfig } from 'src/config/configuration';\n\timport { SequelizeConfigService } from 'src/config/sequelizeConfig.service';\n", "import { User } from 'src/users/users.model';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { BoilerPartsModule } from 'src/boiler-parts/boiler-parts.module';\n\timport { BoilerPartsService } from '../../src/boiler-parts/boiler-parts.service';\n\timport { UsersService } from '../../src/users/users.service';\n\timport { ShoppingCart } from '../../src/shopping-cart/shopping-cart.model';\n\timport { ShoppingCartModule } from '../../src/shopping-cart/shopping-cart.module';\n\tconst mockedUser = {\n\t  username: 'Jhon',\n\t  email: 'jhon@gmail.com',\n", "  password: 'jhon123',\n\t};\n\tdescribe('Shopping Cart Controller', () => {\n\t  let app: INestApplication;\n\t  let boilerPartsService: BoilerPartsService;\n\t  let usersService: UsersService;\n\t  beforeEach(async () => {\n\t    const testModule: TestingModule = await Test.createTestingModule({\n\t      imports: [\n\t        SequelizeModule.forRootAsync({\n", "          imports: [ConfigModule],\n\t          useClass: SequelizeConfigService,\n\t        }),\n\t        ConfigModule.forRoot({\n\t          load: [databaseConfig],\n\t        }),\n\t        ShoppingCartModule,\n\t        BoilerPartsModule,\n\t        AuthModule,\n\t      ],\n", "    }).compile();\n\t    boilerPartsService = testModule.get<BoilerPartsService>(BoilerPartsService);\n\t    usersService = testModule.get<UsersService>(UsersService);\n\t    app = testModule.createNestApplication();\n\t    app.use(\n\t      session({\n\t        secret: 'keyword',\n\t        resave: false,\n\t        saveUninitialized: false,\n\t      }),\n", "    );\n\t    app.use(passport.initialize());\n\t    app.use(passport.session());\n\t    await app.init();\n\t  });\n\t  beforeEach(async () => {\n\t    const user = new User();\n\t    const hashedPassword = await bcrypt.hash(mockedUser.password, 10);\n\t    user.username = mockedUser.username;\n\t    user.password = hashedPassword;\n", "    user.email = mockedUser.email;\n\t    return user.save();\n\t  });\n\t  beforeEach(async () => {\n\t    const cart = new ShoppingCart();\n\t    const user = await usersService.findOne({\n\t      where: { username: mockedUser.username },\n\t    });\n\t    const part = await boilerPartsService.findOne(1);\n\t    cart.userId = user.id;\n", "    cart.partId = part.id;\n\t    cart.boiler_manufacturer = part.boiler_manufacturer;\n\t    cart.parts_manufacturer = part.parts_manufacturer;\n\t    cart.price = part.price;\n\t    cart.in_stock = part.in_stock;\n\t    cart.image = JSON.parse(part.images)[0];\n\t    cart.name = part.name;\n\t    cart.total_price = part.price;\n\t    return cart.save();\n\t  });\n", "  afterEach(async () => {\n\t    await User.destroy({ where: { username: mockedUser.username } });\n\t    await ShoppingCart.destroy({ where: { partId: 1 } });\n\t  });\n\t  it('should add cart item', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    const user = await usersService.findOne({\n\t      where: { username: mockedUser.username },\n", "    });\n\t    const response = await request(app.getHttpServer())\n\t      .get(`/shopping-cart/${user.id}`)\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    expect(response.body).toEqual(\n\t      expect.arrayContaining([\n\t        {\n\t          id: expect.any(Number),\n\t          userId: user.id,\n\t          partId: expect.any(Number),\n", "          boiler_manufacturer: expect.any(String),\n\t          price: expect.any(Number),\n\t          parts_manufacturer: expect.any(String),\n\t          name: expect.any(String),\n\t          image: expect.any(String),\n\t          count: expect.any(Number),\n\t          total_price: expect.any(Number),\n\t          in_stock: expect.any(Number),\n\t          createdAt: expect.any(String),\n\t          updatedAt: expect.any(String),\n", "        },\n\t      ]),\n\t    );\n\t  });\n\t  it('should get all cart items', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    await request(app.getHttpServer())\n\t      .post('/shopping-cart/add')\n", "      .send({ username: mockedUser.username, partId: 3 })\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    const user = await usersService.findOne({\n\t      where: { username: mockedUser.username },\n\t    });\n\t    const response = await request(app.getHttpServer())\n\t      .get(`/shopping-cart/${user.id}`)\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    expect(response.body.find((item) => item.partId === 3)).toEqual(\n\t      expect.objectContaining({\n", "        id: expect.any(Number),\n\t        userId: user.id,\n\t        partId: 3,\n\t        boiler_manufacturer: expect.any(String),\n\t        price: expect.any(Number),\n\t        parts_manufacturer: expect.any(String),\n\t        name: expect.any(String),\n\t        image: expect.any(String),\n\t        count: expect.any(Number),\n\t        total_price: expect.any(Number),\n", "        in_stock: expect.any(Number),\n\t        createdAt: expect.any(String),\n\t        updatedAt: expect.any(String),\n\t      }),\n\t    );\n\t  });\n\t  it('should get updated count of cart item', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n", "    const response = await request(app.getHttpServer())\n\t      .patch('/shopping-cart/count/1')\n\t      .send({ count: 2 })\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    expect(response.body).toEqual({ count: 2 });\n\t  });\n\t  it('should get updated total price of cart item', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n", "    const part = await boilerPartsService.findOne(1);\n\t    const response = await request(app.getHttpServer())\n\t      .patch('/shopping-cart/total-price/1')\n\t      .send({ total_price: part.price * 3 })\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    expect(response.body).toEqual({ total_price: part.price * 3 });\n\t  });\n\t  it('should delete cart item', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n", "      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    await request(app.getHttpServer())\n\t      .delete('/shopping-cart/one/1')\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    const user = await usersService.findOne({\n\t      where: { username: mockedUser.username },\n\t    });\n\t    const response = await request(app.getHttpServer())\n\t      .get(`/shopping-cart/${user.id}`)\n\t      .set('Cookie', login.headers['set-cookie']);\n", "    expect(response.body.find((item) => item.partId === 1)).toBeUndefined();\n\t  });\n\t  it('should delete cart item', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    const user = await usersService.findOne({\n\t      where: { username: mockedUser.username },\n\t    });\n\t    await request(app.getHttpServer())\n", "      .delete(`/shopping-cart/all/${user.id}`)\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    const response = await request(app.getHttpServer())\n\t      .get(`/shopping-cart/${user.id}`)\n\t      .set('Cookie', login.headers['set-cookie']);\n\t    expect(response.body).toStrictEqual([]);\n\t  });\n\t});\n"]}
{"filename": "test/controllers/auth.controller.spec.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport * as bcrypt from 'bcrypt';\n\timport * as request from 'supertest';\n\timport * as session from 'express-session';\n\timport * as passport from 'passport';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { Test, TestingModule } from '@nestjs/testing';\n\timport { databaseConfig } from 'src/config/configuration';\n\timport { SequelizeConfigService } from 'src/config/sequelizeConfig.service';\n", "import { User } from 'src/users/users.model';\n\timport { UsersModule } from 'src/users/users.module';\n\timport { AuthModule } from 'src/auth/auth.module';\n\tconst mockedUser = {\n\t  username: 'Jhon',\n\t  email: 'jhon@gmail.com',\n\t  password: 'jhon123',\n\t};\n\tdescribe('Auth Controller', () => {\n\t  let app: INestApplication;\n", "  beforeEach(async () => {\n\t    const testModule: TestingModule = await Test.createTestingModule({\n\t      imports: [\n\t        SequelizeModule.forRootAsync({\n\t          imports: [ConfigModule],\n\t          useClass: SequelizeConfigService,\n\t        }),\n\t        ConfigModule.forRoot({\n\t          load: [databaseConfig],\n\t        }),\n", "        AuthModule,\n\t      ],\n\t    }).compile();\n\t    app = testModule.createNestApplication();\n\t    app.use(\n\t      session({\n\t        secret: 'keyword',\n\t        resave: false,\n\t        saveUninitialized: false,\n\t      }),\n", "    );\n\t    app.use(passport.initialize());\n\t    app.use(passport.session());\n\t    await app.init();\n\t  });\n\t  beforeEach(async () => {\n\t    const user = new User();\n\t    const hashedPassword = await bcrypt.hash(mockedUser.password, 10);\n\t    user.username = mockedUser.username;\n\t    user.password = hashedPassword;\n", "    user.email = mockedUser.email;\n\t    return user.save();\n\t  });\n\t  afterEach(async () => {\n\t    await User.destroy({ where: { username: mockedUser.username } });\n\t  });\n\t  it('should login user', async () => {\n\t    const response = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n", "    expect(response.body.user.username).toBe(mockedUser.username);\n\t    expect(response.body.msg).toBe('Logged in');\n\t    expect(response.body.user.email).toBe(mockedUser.email);\n\t  });\n\t  it('should login check', async () => {\n\t    const login = await request(app.getHttpServer())\n\t      .post('/users/login')\n\t      .send({ username: mockedUser.username, password: mockedUser.password });\n\t    const loginCheck = await request(app.getHttpServer())\n\t      .get('/users/login-check')\n", "      .set('Cookie', login.headers['set-cookie']);\n\t    expect(loginCheck.body.username).toBe(mockedUser.username);\n\t    expect(loginCheck.body.email).toBe(mockedUser.email);\n\t  });\n\t  it('should logout', async () => {\n\t    const response = await request(app.getHttpServer()).get('/users/logout');\n\t    expect(response.body.msg).toBe('session has ended');\n\t  });\n\t});\n"]}
{"filename": "src/main.ts", "chunked_list": ["import * as session from 'express-session';\n\timport * as passport from 'passport';\n\timport { NestFactory } from '@nestjs/core';\n\timport { AppModule } from './app.module';\n\timport { DocumentBuilder } from '@nestjs/swagger';\n\timport { SwaggerModule } from '@nestjs/swagger/dist';\n\tasync function bootstrap() {\n\t  const app = await NestFactory.create(AppModule);\n\t  app.use(\n\t    session({\n", "      secret: 'keyword',\n\t      resave: false,\n\t      saveUninitialized: false,\n\t    }),\n\t  );\n\t  app.use(passport.initialize());\n\t  app.use(passport.session());\n\t  app.enableCors({\n\t    credentials: true,\n\t    origin: ['http://localhost:3001', 'https://shop-client-ijcw.onrender.com'],\n", "  });\n\t  const config = new DocumentBuilder()\n\t    .setTitle('Аква термикс')\n\t    .setDescription('api documentation')\n\t    .setVersion('1.0')\n\t    .addTag('api')\n\t    .build();\n\t  const document = SwaggerModule.createDocument(app, config);\n\t  SwaggerModule.setup('swagger', app, document);\n\t  await app.listen(3000);\n", "}\n\tbootstrap();\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { UsersModule } from './users/users.module';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { ConfigModule } from '@nestjs/config';\n\timport { SequelizeConfigService } from './config/sequelizeConfig.service';\n\timport { databaseConfig } from './config/configuration';\n\timport { AuthModule } from './auth/auth.module';\n\timport { BoilerPartsModule } from './boiler-parts/boiler-parts.module';\n\timport { ShoppingCartModule } from './shopping-cart/shopping-cart.module';\n\timport { PaymentModule } from './payment/payment.module';\n", "@Module({\n\t  imports: [\n\t    SequelizeModule.forRootAsync({\n\t      imports: [ConfigModule],\n\t      useClass: SequelizeConfigService,\n\t    }),\n\t    ConfigModule.forRoot({\n\t      load: [databaseConfig],\n\t    }),\n\t    UsersModule,\n", "    AuthModule,\n\t    BoilerPartsModule,\n\t    ShoppingCartModule,\n\t    PaymentModule,\n\t  ],\n\t})\n\texport class AppModule {}\n"]}
{"filename": "src/users/users.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { UsersController } from './users.controller';\n\timport { User } from './users.model';\n\timport { UsersService } from './users.service';\n\t@Module({\n\t  imports: [SequelizeModule.forFeature([User])],\n\t  controllers: [UsersController],\n\t  providers: [UsersService],\n\t  exports: [UsersService],\n", "})\n\texport class UsersModule {}\n"]}
{"filename": "src/users/users.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\timport { InjectModel } from '@nestjs/sequelize';\n\timport * as bcrypt from 'bcrypt';\n\timport { User } from './users.model';\n\timport { CreateUserDto } from './dto/create-user.dto';\n\t@Injectable()\n\texport class UsersService {\n\t  constructor(\n\t    @InjectModel(User)\n\t    private userModel: typeof User,\n", "  ) {}\n\t  findOne(filter: {\n\t    where: { id?: string; username?: string; email?: string };\n\t  }): Promise<User> {\n\t    return this.userModel.findOne({ ...filter });\n\t  }\n\t  async create(\n\t    createUserDto: CreateUserDto,\n\t  ): Promise<User | { warningMessage: string }> {\n\t    const user = new User();\n", "    const existingByUserName = await this.findOne({\n\t      where: { username: createUserDto.username },\n\t    });\n\t    const existingByEmail = await this.findOne({\n\t      where: { email: createUserDto.email },\n\t    });\n\t    if (existingByUserName) {\n\t      return { warningMessage: 'Пользователь с таким именем уже существует' };\n\t    }\n\t    if (existingByEmail) {\n", "      return { warningMessage: 'Пользователь с таким email уже существует' };\n\t    }\n\t    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);\n\t    user.username = createUserDto.username;\n\t    user.password = hashedPassword;\n\t    user.email = createUserDto.email;\n\t    return user.save();\n\t  }\n\t}\n"]}
{"filename": "src/users/users.model.ts", "chunked_list": ["import { Table, Model, Column } from 'sequelize-typescript';\n\t@Table\n\texport class User extends Model {\n\t  @Column\n\t  username: string;\n\t  @Column\n\t  password: string;\n\t  @Column\n\t  email: string;\n\t}\n"]}
{"filename": "src/users/users.controller.ts", "chunked_list": ["import {\n\t  Body,\n\t  Controller,\n\t  Get,\n\t  Header,\n\t  HttpCode,\n\t  HttpStatus,\n\t  Post,\n\t  Request,\n\t  UseGuards,\n", "} from '@nestjs/common';\n\timport { UsersService } from './users.service';\n\timport { CreateUserDto } from './dto/create-user.dto';\n\timport { LocalAuthGuard } from '../auth/local.auth.guard';\n\timport { AuthenticatedGuard } from 'src/auth/authenticated.guard';\n\timport { ApiBody, ApiOkResponse } from '@nestjs/swagger';\n\timport {\n\t  LoginCheckResponse,\n\t  LoginUserRequest,\n\t  LoginUserResponse,\n", "  LogoutUserResponse,\n\t  SignupResponse,\n\t} from './types';\n\t@Controller('users')\n\texport class UsersController {\n\t  constructor(private readonly usersService: UsersService) {}\n\t  @ApiOkResponse({ type: SignupResponse })\n\t  @Post('/signup')\n\t  @HttpCode(HttpStatus.CREATED)\n\t  @Header('Content-type', 'application/json')\n", "  createUser(@Body() createUserDto: CreateUserDto) {\n\t    return this.usersService.create(createUserDto);\n\t  }\n\t  @ApiBody({ type: LoginUserRequest })\n\t  @ApiOkResponse({ type: LoginUserResponse })\n\t  @Post('/login')\n\t  @UseGuards(LocalAuthGuard)\n\t  @HttpCode(HttpStatus.OK)\n\t  login(@Request() req) {\n\t    return { user: req.user, msg: 'Logged in' };\n", "  }\n\t  @ApiOkResponse({ type: LoginCheckResponse })\n\t  @Get('/login-check')\n\t  @UseGuards(AuthenticatedGuard)\n\t  loginCheck(@Request() req) {\n\t    return req.user;\n\t  }\n\t  @ApiOkResponse({ type: LogoutUserResponse })\n\t  @Get('/logout')\n\t  logout(@Request() req) {\n", "    req.session.destroy();\n\t    return { msg: 'session has ended' };\n\t  }\n\t}\n"]}
{"filename": "src/users/types/index.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\texport class LoginUserRequest {\n\t  @ApiProperty({ example: 'Ivan' })\n\t  username: string;\n\t  @ApiProperty({ example: 'ivan123' })\n\t  password: string;\n\t}\n\texport class LoginUserResponse {\n\t  @ApiProperty({\n\t    example: {\n", "      user: {\n\t        userId: 1,\n\t        username: 'Ivan',\n\t        password: 'ivan123',\n\t      },\n\t    },\n\t  })\n\t  user: {\n\t    userId: number;\n\t    username: string;\n", "    password: string;\n\t  };\n\t  @ApiProperty({ example: 'Logged in' })\n\t  msg: string;\n\t}\n\texport class LogoutUserResponse {\n\t  @ApiProperty({ example: 'session has ended' })\n\t  msg: string;\n\t}\n\texport class LoginCheckResponse {\n", "  @ApiProperty({ example: 1 })\n\t  userId: number;\n\t  @ApiProperty({ example: 'Ivan' })\n\t  username: string;\n\t  @ApiProperty({ example: 'ivan@gmail.com' })\n\t  email: string;\n\t}\n\texport class SignupResponse {\n\t  @ApiProperty({ example: 1 })\n\t  id: number;\n", "  @ApiProperty({ example: 'Ivan' })\n\t  username: string;\n\t  @ApiProperty({\n\t    example: '$2b$10$90H0Hn.6Nx0SbrHQCX2xeeYjq.02nS5VpkIIwFAtDtCHEqHK',\n\t  })\n\t  password: string;\n\t  @ApiProperty({ example: 'ivan@gmail.com' })\n\t  email: string;\n\t  @ApiProperty({ example: '2023-03-17T17:23:33.502Z' })\n\t  updatedAt: string;\n", "  @ApiProperty({ example: '2023-03-17T17:23:33.502Z' })\n\t  createdAt: string;\n\t}\n"]}
{"filename": "src/users/dto/create-user.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\timport { IsNotEmpty } from 'class-validator';\n\texport class CreateUserDto {\n\t  @ApiProperty({ example: 'Ivan' })\n\t  @IsNotEmpty()\n\t  readonly username: string;\n\t  @ApiProperty({ example: 'ivan123' })\n\t  @IsNotEmpty()\n\t  readonly password: string;\n\t  @ApiProperty({ example: 'ivan@gmail.com' })\n", "  @IsNotEmpty()\n\t  readonly email: string;\n\t}\n"]}
{"filename": "src/auth/local.strategy.ts", "chunked_list": ["import { Strategy } from 'passport-local';\n\timport { PassportStrategy } from '@nestjs/passport';\n\timport { Injectable, UnauthorizedException } from '@nestjs/common';\n\timport { AuthService } from './auth.service';\n\t@Injectable()\n\texport class LocalStrategy extends PassportStrategy(Strategy) {\n\t  constructor(private authService: AuthService) {\n\t    super();\n\t  }\n\t  async validate(username: string, password: string): Promise<any> {\n", "    const user = await this.authService.validateUser(\n\t      username.toLowerCase(),\n\t      password,\n\t    );\n\t    if (!user) {\n\t      throw new UnauthorizedException();\n\t    }\n\t    return user;\n\t  }\n\t}\n"]}
{"filename": "src/auth/auth.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { AuthService } from './auth.service';\n\timport { UsersModule } from '../users/users.module';\n\timport { PassportModule } from '@nestjs/passport';\n\timport { LocalStrategy } from './local.strategy';\n\timport { SessionSerializer } from './session.serializer';\n\t@Module({\n\t  imports: [UsersModule, PassportModule.register({ session: true })],\n\t  providers: [AuthService, LocalStrategy, SessionSerializer],\n\t})\n", "export class AuthModule {}\n"]}
{"filename": "src/auth/authenticated.guard.ts", "chunked_list": ["import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\n\t@Injectable()\n\texport class AuthenticatedGuard implements CanActivate {\n\t  async canActivate(context: ExecutionContext) {\n\t    const request = context.switchToHttp().getRequest();\n\t    return request.isAuthenticated();\n\t  }\n\t}\n"]}
{"filename": "src/auth/session.serializer.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\timport { PassportSerializer } from '@nestjs/passport';\n\t@Injectable()\n\texport class SessionSerializer extends PassportSerializer {\n\t  serializeUser(user: any, done: (err: Error, user: any) => void) {\n\t    done(null, user);\n\t  }\n\t  deserializeUser(payload: any, done: (err: Error, user: any) => void) {\n\t    done(null, payload);\n\t  }\n", "}\n"]}
{"filename": "src/auth/auth.service.ts", "chunked_list": ["import { Injectable, UnauthorizedException } from '@nestjs/common';\n\timport * as bcrypt from 'bcrypt';\n\timport { UsersService } from '../users/users.service';\n\t@Injectable()\n\texport class AuthService {\n\t  constructor(private readonly usersService: UsersService) {}\n\t  async validateUser(username: string, password: string) {\n\t    const user = await this.usersService.findOne({ where: { username } });\n\t    if (!user) {\n\t      throw new UnauthorizedException('Invalid credentials');\n", "    }\n\t    const passwordValid = await bcrypt.compare(password, user.password);\n\t    if (!passwordValid) {\n\t      throw new UnauthorizedException('Invalid credentials');\n\t    }\n\t    if (user && passwordValid) {\n\t      return {\n\t        userId: user.id,\n\t        username: user.username,\n\t        email: user.email,\n", "      };\n\t    }\n\t    return null;\n\t  }\n\t}\n"]}
{"filename": "src/auth/local.auth.guard.ts", "chunked_list": ["import { Injectable, ExecutionContext } from '@nestjs/common';\n\timport { AuthGuard } from '@nestjs/passport';\n\t@Injectable()\n\texport class LocalAuthGuard extends AuthGuard('local') {\n\t  async canActivate(context: ExecutionContext) {\n\t    const result = (await super.canActivate(context)) as boolean;\n\t    const request = context.switchToHttp().getRequest();\n\t    await super.logIn(request);\n\t    return result;\n\t  }\n", "}\n"]}
{"filename": "src/config/sql.config.ts", "chunked_list": ["import { registerAs } from '@nestjs/config';\n\timport { Dialect } from 'sequelize';\n\texport const sqlConfig = registerAs('database', () => ({\n\t  dialect: <Dialect>process.env.SQL_DIALECT || 'mysql',\n\t  logging: process.env.SQL_LOGGING === 'true' ? true : false,\n\t  host: process.env.DATABASE_HOST,\n\t  port: +process.env.DATABASE_PORT,\n\t  username: process.env.DATABASE_USER,\n\t  password: process.env.DATABASE_PASSWORD,\n\t  database: process.env.DATABASE_NAME,\n", "  autoLoadEntities: true,\n\t  synchronize: true,\n\t}));\n"]}
{"filename": "src/config/sequelizeConfig.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\timport { ConfigService } from '@nestjs/config';\n\timport { User } from '../users/users.model';\n\timport {\n\t  SequelizeOptionsFactory,\n\t  SequelizeModuleOptions,\n\t} from '@nestjs/sequelize';\n\t@Injectable()\n\texport class SequelizeConfigService implements SequelizeOptionsFactory {\n\t  constructor(private readonly configService: ConfigService) {}\n", "  createSequelizeOptions(): SequelizeModuleOptions {\n\t    const {\n\t      sql: { dialect, logging, host, port, username, password, database },\n\t    } = this.configService.get('database');\n\t    return {\n\t      dialect,\n\t      logging,\n\t      host,\n\t      port,\n\t      username,\n", "      password,\n\t      database,\n\t      models: [User],\n\t      autoLoadModels: true,\n\t      synchronize: true,\n\t      define: {\n\t        charset: 'utf8',\n\t        collate: 'utf8_general_ci',\n\t      },\n\t    };\n", "  }\n\t}\n"]}
{"filename": "src/config/configuration.ts", "chunked_list": ["import { registerAs } from '@nestjs/config';\n\timport { sqlConfig } from './sql.config';\n\texport const databaseConfig = registerAs('database', () => ({\n\t  sql: {\n\t    ...sqlConfig(),\n\t  },\n\t}));\n"]}
{"filename": "src/shopping-cart/shopping-cart.model.ts", "chunked_list": ["import { Table, Model, Column } from 'sequelize-typescript';\n\t@Table\n\texport class ShoppingCart extends Model {\n\t  @Column\n\t  userId: number;\n\t  @Column({ defaultValue: 0 })\n\t  partId: number;\n\t  @Column\n\t  boiler_manufacturer: string;\n\t  @Column({ defaultValue: 0 })\n", "  price: number;\n\t  @Column\n\t  parts_manufacturer: string;\n\t  @Column\n\t  name: string;\n\t  @Column\n\t  image: string;\n\t  @Column({ defaultValue: 0 })\n\t  in_stock: number;\n\t  @Column({ defaultValue: 1 })\n", "  count: number;\n\t  @Column({ defaultValue: 0 })\n\t  total_price: number;\n\t}\n"]}
{"filename": "src/shopping-cart/shopping-cart.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\timport { InjectModel } from '@nestjs/sequelize';\n\timport { BoilerPartsService } from 'src/boiler-parts/boiler-parts.service';\n\timport { UsersService } from 'src/users/users.service';\n\timport { AddToCartDto } from './dto/add-to-cart.dto';\n\timport { ShoppingCart } from './shopping-cart.model';\n\t@Injectable()\n\texport class ShoppingCartService {\n\t  constructor(\n\t    @InjectModel(ShoppingCart)\n", "    private shoppingCartModel: typeof ShoppingCart,\n\t    private readonly usersService: UsersService,\n\t    private readonly boilerPartsService: BoilerPartsService,\n\t  ) {}\n\t  async findAll(userId: number | string): Promise<ShoppingCart[]> {\n\t    return this.shoppingCartModel.findAll({ where: { userId } });\n\t  }\n\t  async add(addToCartDto: AddToCartDto) {\n\t    const cart = new ShoppingCart();\n\t    const user = await this.usersService.findOne({\n", "      where: { username: addToCartDto.username },\n\t    });\n\t    const part = await this.boilerPartsService.findOne(addToCartDto.partId);\n\t    cart.userId = user.id;\n\t    cart.partId = part.id;\n\t    cart.boiler_manufacturer = part.boiler_manufacturer;\n\t    cart.parts_manufacturer = part.parts_manufacturer;\n\t    cart.price = part.price;\n\t    cart.in_stock = part.in_stock;\n\t    cart.image = JSON.parse(part.images)[0];\n", "    cart.name = part.name;\n\t    cart.total_price = part.price;\n\t    return cart.save();\n\t  }\n\t  async updateCount(\n\t    count: number,\n\t    partId: number | string,\n\t  ): Promise<{ count: number }> {\n\t    await this.shoppingCartModel.update({ count }, { where: { partId } });\n\t    const part = await this.shoppingCartModel.findOne({ where: { partId } });\n", "    return { count: part.count };\n\t  }\n\t  async updateTotalPrice(\n\t    total_price: number,\n\t    partId: number | string,\n\t  ): Promise<{ total_price: number }> {\n\t    await this.shoppingCartModel.update({ total_price }, { where: { partId } });\n\t    const part = await this.shoppingCartModel.findOne({ where: { partId } });\n\t    return { total_price: part.total_price };\n\t  }\n", "  async remove(partId: number | string): Promise<void> {\n\t    const part = await this.shoppingCartModel.findOne({ where: { partId } });\n\t    await part.destroy();\n\t  }\n\t  async removeAll(userId: number | string): Promise<void> {\n\t    await this.shoppingCartModel.destroy({ where: { userId } });\n\t  }\n\t}\n"]}
{"filename": "src/shopping-cart/shopping-cart.controller.ts", "chunked_list": ["import {\n\t  Controller,\n\t  Get,\n\t  Param,\n\t  UseGuards,\n\t  Post,\n\t  Body,\n\t  Patch,\n\t  Delete,\n\t} from '@nestjs/common';\n", "import { AuthenticatedGuard } from 'src/auth/authenticated.guard';\n\timport { AddToCartDto } from './dto/add-to-cart.dto';\n\timport { ShoppingCartService } from './shopping-cart.service';\n\timport { ApiOkResponse, ApiBody } from '@nestjs/swagger';\n\timport {\n\t  AddToCardResponse,\n\t  GetAllResponse,\n\t  TotalPriceRequest,\n\t  TotalPriceResponse,\n\t  UpdateCountRequest,\n", "  UpdateCountResponse,\n\t} from './types';\n\t@Controller('shopping-cart')\n\texport class ShoppingCartController {\n\t  constructor(private readonly shoppingCartService: ShoppingCartService) {}\n\t  @ApiOkResponse({ type: [GetAllResponse] })\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Get(':id')\n\t  getAll(@Param('id') userId: string) {\n\t    return this.shoppingCartService.findAll(userId);\n", "  }\n\t  @ApiOkResponse({ type: AddToCardResponse })\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Post('/add')\n\t  addToCar(@Body() addToCartDto: AddToCartDto) {\n\t    return this.shoppingCartService.add(addToCartDto);\n\t  }\n\t  @ApiOkResponse({ type: UpdateCountResponse })\n\t  @ApiBody({ type: UpdateCountRequest })\n\t  @UseGuards(AuthenticatedGuard)\n", "  @Patch('/count/:id')\n\t  updateCount(\n\t    @Body() { count }: { count: number },\n\t    @Param('id') partId: string,\n\t  ) {\n\t    return this.shoppingCartService.updateCount(count, partId);\n\t  }\n\t  @ApiOkResponse({ type: TotalPriceResponse })\n\t  @ApiBody({ type: TotalPriceRequest })\n\t  @UseGuards(AuthenticatedGuard)\n", "  @Patch('/total-price/:id')\n\t  updateTotalPrice(\n\t    @Body() { total_price }: { total_price: number },\n\t    @Param('id') partId: string,\n\t  ) {\n\t    return this.shoppingCartService.updateTotalPrice(total_price, partId);\n\t  }\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Delete('/one/:id')\n\t  removeOne(@Param('id') partId: string) {\n", "    return this.shoppingCartService.remove(partId);\n\t  }\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Delete('/all/:id')\n\t  removeAll(@Param('id') userId: string) {\n\t    return this.shoppingCartService.removeAll(userId);\n\t  }\n\t}\n"]}
{"filename": "src/shopping-cart/shopping-cart.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { ShoppingCartController } from './shopping-cart.controller';\n\timport { ShoppingCartService } from './shopping-cart.service';\n\timport { ShoppingCart } from './shopping-cart.model';\n\timport { UsersModule } from '../users/users.module';\n\timport { BoilerPartsModule } from '../boiler-parts/boiler-parts.module';\n\t@Module({\n\t  imports: [\n\t    SequelizeModule.forFeature([ShoppingCart]),\n", "    UsersModule,\n\t    BoilerPartsModule,\n\t  ],\n\t  controllers: [ShoppingCartController],\n\t  providers: [ShoppingCartService],\n\t})\n\texport class ShoppingCartModule {}\n"]}
{"filename": "src/shopping-cart/types/index.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\tclass ShoppingCartItem {\n\t  @ApiProperty({ example: 1 })\n\t  id: number;\n\t  @ApiProperty({ example: 'Aliquid alias.' })\n\t  name: string;\n\t  @ApiProperty({ example: 2500 })\n\t  price: number;\n\t  @ApiProperty({\n\t    example:\n", "      'https://loremflickr.com/640/480/technics?random=849581742306099411950399951214',\n\t  })\n\t  image: string;\n\t  @ApiProperty({ example: 5 })\n\t  in_stock: number;\n\t  @ApiProperty({ example: 'Salmon' })\n\t  parts_manufacturer: string;\n\t  @ApiProperty({ example: 'Henry' })\n\t  boiler_manufacturer: string;\n\t  @ApiProperty({ example: 1 })\n", "  userId: number;\n\t  @ApiProperty({ example: 1 })\n\t  partId: number;\n\t  @ApiProperty({ example: 3 })\n\t  count: number;\n\t  @ApiProperty({ example: 3 })\n\t  total_price: number;\n\t  @ApiProperty({ example: '2023-03-19T12:45:51.240Z' })\n\t  createdAt: string;\n\t  @ApiProperty({ example: '2023-03-19T12:45:51.240Z' })\n", "  updatedAt: string;\n\t}\n\texport class GetAllResponse extends ShoppingCartItem {}\n\texport class AddToCardResponse extends ShoppingCartItem {}\n\texport class UpdateCountResponse {\n\t  @ApiProperty({ example: 1 })\n\t  count: number;\n\t}\n\texport class UpdateCountRequest {\n\t  @ApiProperty({ example: 1 })\n", "  count: number;\n\t}\n\texport class TotalPriceResponse {\n\t  @ApiProperty({ example: 1000 })\n\t  total_price: number;\n\t}\n\texport class TotalPriceRequest {\n\t  @ApiProperty({ example: 1000 })\n\t  total_price: number;\n\t}\n"]}
{"filename": "src/shopping-cart/dto/add-to-cart.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\timport { IsNotEmpty, IsOptional } from 'class-validator';\n\texport class AddToCartDto {\n\t  @ApiProperty({ example: 'Ivan' })\n\t  @IsNotEmpty()\n\t  readonly username: string;\n\t  @ApiProperty({ example: 1 })\n\t  @IsOptional()\n\t  userId?: number;\n\t  @ApiProperty({ example: 1 })\n", "  @IsNotEmpty()\n\t  readonly partId: number;\n\t}\n"]}
{"filename": "src/payment/payment.controller.ts", "chunked_list": ["import { Body, Controller, Post, UseGuards } from '@nestjs/common';\n\timport { PaymentService } from './payment.service';\n\timport { MakePaymentDto } from './dto/make-paymen.dto';\n\timport { AuthenticatedGuard } from 'src/auth/authenticated.guard';\n\timport { ApiOkResponse } from '@nestjs/swagger';\n\timport { MakePaymentResponse } from './types';\n\timport { CheckPaymentDto } from './dto/check-payment.dto';\n\t@Controller('payment')\n\texport class PaymentController {\n\t  constructor(private paymentService: PaymentService) {}\n", "  @ApiOkResponse({ type: MakePaymentResponse })\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Post()\n\t  makePayment(@Body() makePaymentDto: MakePaymentDto) {\n\t    return this.paymentService.makePayment(makePaymentDto);\n\t  }\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Post('/info')\n\t  checkPayment(@Body() checkPaymentDto: CheckPaymentDto) {\n\t    return this.paymentService.checkPayment(checkPaymentDto);\n", "  }\n\t}\n"]}
{"filename": "src/payment/payment.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { PaymentController } from './payment.controller';\n\timport { PaymentService } from './payment.service';\n\t@Module({\n\t  controllers: [PaymentController],\n\t  providers: [PaymentService],\n\t})\n\texport class PaymentModule {}\n"]}
{"filename": "src/payment/payment.service.ts", "chunked_list": ["import { ForbiddenException, Injectable } from '@nestjs/common';\n\timport axios from 'axios';\n\timport { MakePaymentDto } from './dto/make-paymen.dto';\n\timport { CheckPaymentDto } from './dto/check-payment.dto';\n\t@Injectable()\n\texport class PaymentService {\n\t  async makePayment(makePaymentDto: MakePaymentDto) {\n\t    try {\n\t      const { data } = await axios({\n\t        method: 'POST',\n", "        url: 'https://api.yookassa.ru/v3/payments',\n\t        headers: {\n\t          'Content-Type': 'application/json',\n\t          'Idempotence-Key': Date.now(),\n\t        },\n\t        auth: {\n\t          username: '204971',\n\t          password: 'test_dgisbcPctB1RjjKeSBzdIuXJR0IRTFKm6Rdi9eNGZxE',\n\t        },\n\t        data: {\n", "          amount: {\n\t            value: makePaymentDto.amount,\n\t            currency: 'RUB',\n\t          },\n\t          capture: true,\n\t          confirmation: {\n\t            type: 'redirect',\n\t            return_url: 'http://localhost:3001/order',\n\t          },\n\t          description: makePaymentDto.description,\n", "        },\n\t      });\n\t      return data;\n\t    } catch (error) {\n\t      throw new ForbiddenException(error);\n\t    }\n\t  }\n\t  async checkPayment(checkPaymentDto: CheckPaymentDto) {\n\t    try {\n\t      const { data } = await axios({\n", "        method: 'GET',\n\t        url: `https://api.yookassa.ru/v3/payments/${checkPaymentDto.paymentId}`,\n\t        auth: {\n\t          username: '204971',\n\t          password: 'test_dgisbcPctB1RjjKeSBzdIuXJR0IRTFKm6Rdi9eNGZxE',\n\t        },\n\t      });\n\t      return data;\n\t    } catch (error) {\n\t      throw new ForbiddenException(error);\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src/payment/types/index.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\texport class MakePaymentResponse {\n\t  @ApiProperty({ example: '2b9e50d0' })\n\t  id: string;\n\t  @ApiProperty({ example: 'pending' })\n\t  status: string;\n\t  @ApiProperty({ example: { value: '100', currency: 'RUB' } })\n\t  amount: {\n\t    value: string;\n\t    currency: string;\n", "  };\n\t  @ApiProperty({ example: 'Заказ №1' })\n\t  description: string;\n\t  @ApiProperty({\n\t    example: {\n\t      type: 'redirect',\n\t      confirmation_url:\n\t        'https://yoomoney.ru/checkout/payments/v2/contract?orderId=2b',\n\t    },\n\t  })\n", "  confirmation: {\n\t    type: string;\n\t    confirmation_url: string;\n\t  };\n\t  @ApiProperty({\n\t    example: {\n\t      account_id: '204971',\n\t      gateway_id: '2057935',\n\t    },\n\t  })\n", "  recipient: {\n\t    account_id: string;\n\t    gateway_id: string;\n\t  };\n\t  @ApiProperty({ example: true })\n\t  test: boolean;\n\t  @ApiProperty({ example: false })\n\t  paid: boolean;\n\t  @ApiProperty({ example: false })\n\t  refundable: boolean;\n", "  @ApiProperty({ example: {} })\n\t  metadata: object;\n\t}\n"]}
{"filename": "src/payment/dto/make-paymen.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\timport { IsNotEmpty, IsOptional } from 'class-validator';\n\texport class MakePaymentDto {\n\t  @ApiProperty({ example: 100 })\n\t  @IsNotEmpty()\n\t  readonly amount: number;\n\t  @ApiProperty({ example: 'заказ №1' })\n\t  @IsOptional()\n\t  readonly description?: string;\n\t}\n"]}
{"filename": "src/payment/dto/check-payment.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\timport { IsNotEmpty } from 'class-validator';\n\texport class CheckPaymentDto {\n\t  @ApiProperty({ example: '22e12f66-000f-5000-8000-18db351245c7' })\n\t  @IsNotEmpty()\n\t  readonly paymentId: number;\n\t}\n"]}
{"filename": "src/boiler-parts/boiler-parts.controller.ts", "chunked_list": ["import { Body, Controller, Post } from '@nestjs/common';\n\timport { Get } from '@nestjs/common';\n\timport { Param, Query, UseGuards } from '@nestjs/common';\n\timport { BoilerPartsService } from './boiler-parts.service';\n\timport { AuthenticatedGuard } from '../auth/authenticated.guard';\n\timport { ApiOkResponse, ApiBody } from '@nestjs/swagger';\n\timport {\n\t  PaginateAndFilterResponse,\n\t  FindOneResponse,\n\t  GetBestsellersResponse,\n", "  GetNewResponse,\n\t  SearchResponse,\n\t  SearchRequest,\n\t  GetByNameResponse,\n\t  GetByNameRequest,\n\t} from './types';\n\t@Controller('boiler-parts')\n\texport class BoilerPartsController {\n\t  constructor(private readonly boilerPartsService: BoilerPartsService) {}\n\t  @ApiOkResponse({ type: PaginateAndFilterResponse })\n", "  @UseGuards(AuthenticatedGuard)\n\t  @Get()\n\t  paginateAndFilter(@Query() query) {\n\t    return this.boilerPartsService.paginateAndFilter(query);\n\t  }\n\t  @ApiOkResponse({ type: FindOneResponse })\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Get('find/:id')\n\t  getOne(@Param('id') id: string) {\n\t    return this.boilerPartsService.findOne(id);\n", "  }\n\t  @ApiOkResponse({ type: GetBestsellersResponse })\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Get('bestsellers')\n\t  getBestseller() {\n\t    return this.boilerPartsService.bestsellers();\n\t  }\n\t  @ApiOkResponse({ type: GetNewResponse })\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Get('new')\n", "  getNew() {\n\t    return this.boilerPartsService.new();\n\t  }\n\t  @ApiOkResponse({ type: SearchResponse })\n\t  @ApiBody({ type: SearchRequest })\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Post('search')\n\t  search(@Body() { search }: { search: string }) {\n\t    return this.boilerPartsService.searchByString(search);\n\t  }\n", "  @ApiOkResponse({ type: GetByNameResponse })\n\t  @ApiBody({ type: GetByNameRequest })\n\t  @UseGuards(AuthenticatedGuard)\n\t  @Post('name')\n\t  getByName(@Body() { name }: { name: string }) {\n\t    return this.boilerPartsService.findOneByName(name);\n\t  }\n\t}\n"]}
{"filename": "src/boiler-parts/boiler-parts.model.ts", "chunked_list": ["import { Table, Model, Column } from 'sequelize-typescript';\n\t@Table\n\texport class BoilerParts extends Model {\n\t  @Column\n\t  boiler_manufacturer: string;\n\t  @Column({ defaultValue: 0 })\n\t  price: number;\n\t  @Column\n\t  parts_manufacturer: string;\n\t  @Column\n", "  vendor_code: string;\n\t  @Column\n\t  name: string;\n\t  @Column\n\t  description: string;\n\t  @Column\n\t  images: string;\n\t  @Column({ defaultValue: 0 })\n\t  in_stock: number;\n\t  @Column({ defaultValue: false })\n", "  bestseller: boolean;\n\t  @Column({ defaultValue: false })\n\t  new: boolean;\n\t  @Column\n\t  popularity: number;\n\t  @Column\n\t  compatibility: string;\n\t}\n"]}
{"filename": "src/boiler-parts/boiler-parts.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\timport { InjectModel } from '@nestjs/sequelize';\n\timport { Op } from 'sequelize';\n\timport { BoilerParts } from './boiler-parts.model';\n\timport { IBoilerPartsFilter, IBoilerPartsQuery } from './types';\n\t@Injectable()\n\texport class BoilerPartsService {\n\t  constructor(\n\t    @InjectModel(BoilerParts)\n\t    private boilerPartsModel: typeof BoilerParts,\n", "  ) {}\n\t  async paginateAndFilter(\n\t    query: IBoilerPartsQuery,\n\t  ): Promise<{ count: number; rows: BoilerParts[] }> {\n\t    const limit = +query.limit;\n\t    const offset = +query.offset * 20;\n\t    const filter = {} as Partial<IBoilerPartsFilter>;\n\t    if (query.priceFrom && query.priceTo) {\n\t      filter.price = {\n\t        [Op.between]: [+query.priceFrom, +query.priceTo],\n", "      };\n\t    }\n\t    if (query.boiler) {\n\t      filter.boiler_manufacturer = JSON.parse(decodeURIComponent(query.boiler));\n\t    }\n\t    if (query.parts) {\n\t      filter.parts_manufacturer = JSON.parse(decodeURIComponent(query.parts));\n\t    }\n\t    return this.boilerPartsModel.findAndCountAll({\n\t      limit,\n", "      offset,\n\t      where: filter,\n\t    });\n\t  }\n\t  async bestsellers(): Promise<{ count: number; rows: BoilerParts[] }> {\n\t    return this.boilerPartsModel.findAndCountAll({\n\t      where: { bestseller: true },\n\t    });\n\t  }\n\t  async new(): Promise<{ count: number; rows: BoilerParts[] }> {\n", "    return this.boilerPartsModel.findAndCountAll({\n\t      where: { new: true },\n\t    });\n\t  }\n\t  async findOne(id: number | string): Promise<BoilerParts> {\n\t    return this.boilerPartsModel.findOne({\n\t      where: { id },\n\t    });\n\t  }\n\t  async findOneByName(name: string): Promise<BoilerParts> {\n", "    return this.boilerPartsModel.findOne({\n\t      where: { name },\n\t    });\n\t  }\n\t  async searchByString(\n\t    str: string,\n\t  ): Promise<{ count: number; rows: BoilerParts[] }> {\n\t    return this.boilerPartsModel.findAndCountAll({\n\t      limit: 20,\n\t      where: { name: { [Op.like]: `%${str}%` } },\n", "    });\n\t  }\n\t}\n"]}
{"filename": "src/boiler-parts/boiler-parts.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { BoilerPartsController } from './boiler-parts.controller';\n\timport { BoilerPartsService } from './boiler-parts.service';\n\timport { SequelizeModule } from '@nestjs/sequelize';\n\timport { BoilerParts } from './boiler-parts.model';\n\t@Module({\n\t  imports: [SequelizeModule.forFeature([BoilerParts])],\n\t  controllers: [BoilerPartsController],\n\t  providers: [BoilerPartsService],\n\t  exports: [BoilerPartsService],\n", "})\n\texport class BoilerPartsModule {}\n"]}
{"filename": "src/boiler-parts/types/index.ts", "chunked_list": ["import { faker } from '@faker-js/faker';\n\timport { Op } from 'sequelize';\n\timport { ApiProperty } from '@nestjs/swagger';\n\tclass BoilerParts {\n\t  @ApiProperty({ example: 1 })\n\t  id: number;\n\t  @ApiProperty({ example: faker.lorem.sentence(2) })\n\t  boiler_manufacturer: string;\n\t  @ApiProperty({ example: 12345 })\n\t  price: string;\n", "  @ApiProperty({ example: faker.lorem.sentence(2) })\n\t  parts_manufacturer: string;\n\t  @ApiProperty({ example: faker.internet.password() })\n\t  vendor_code: string;\n\t  @ApiProperty({ example: faker.lorem.word() })\n\t  name: string;\n\t  @ApiProperty({ example: faker.lorem.sentence() })\n\t  description: string;\n\t  @ApiProperty({ example: faker.lorem.sentence() })\n\t  compatibility: string;\n", "  @ApiProperty({ example: faker.image.city() })\n\t  images: string;\n\t  @ApiProperty({ example: 5 })\n\t  in_stock: number;\n\t  @ApiProperty({ example: true })\n\t  bestseller: boolean;\n\t  @ApiProperty({ example: false })\n\t  new: boolean;\n\t  @ApiProperty({ example: 123 })\n\t  popularity: number;\n", "  @ApiProperty({ example: '2023-01-31T19:46:45.000Z' })\n\t  createdAt: string;\n\t  @ApiProperty({ example: '2023-01-31T19:46:45.000Z' })\n\t  updatedAt: string;\n\t}\n\texport class PaginateAndFilterResponse {\n\t  @ApiProperty({ example: 10 })\n\t  count: number;\n\t  @ApiProperty({ type: BoilerParts, isArray: true })\n\t  rows: BoilerParts;\n", "}\n\texport class Bestsellers extends BoilerParts {\n\t  @ApiProperty({ example: true })\n\t  bestseller: boolean;\n\t}\n\texport class GetBestsellersResponse extends PaginateAndFilterResponse {\n\t  @ApiProperty({ example: 10 })\n\t  count: number;\n\t  @ApiProperty({ type: BoilerParts, isArray: true })\n\t  rows: Bestsellers;\n", "}\n\texport class NewParts extends BoilerParts {\n\t  @ApiProperty({ example: true })\n\t  new: boolean;\n\t}\n\texport class GetNewResponse extends PaginateAndFilterResponse {\n\t  @ApiProperty({ example: 10 })\n\t  count: number;\n\t  @ApiProperty({ type: BoilerParts, isArray: true })\n\t  rows: NewParts;\n", "}\n\texport class SearchByLetterResponse extends BoilerParts {\n\t  @ApiProperty({ example: 'Provident incidunt.' })\n\t  name: string;\n\t}\n\texport class SearchResponse extends PaginateAndFilterResponse {\n\t  @ApiProperty({ type: SearchByLetterResponse, isArray: true })\n\t  rows: SearchByLetterResponse;\n\t}\n\texport class SearchRequest {\n", "  @ApiProperty({ example: 'r' })\n\t  search: string;\n\t}\n\texport class GetByNameResponse extends BoilerParts {\n\t  @ApiProperty({ example: 'Provident incidunt.' })\n\t  name: string;\n\t}\n\texport class GetByNameRequest {\n\t  @ApiProperty({ example: 'Provident incidunt.' })\n\t  name: string;\n", "}\n\texport class FindOneResponse extends BoilerParts {}\n\texport interface IBoilerPartsQuery {\n\t  limit: string;\n\t  offset: string;\n\t  boiler: string | undefined;\n\t  parts: string | undefined;\n\t  priceFrom: string | undefined;\n\t  priceTo: string | undefined;\n\t}\n", "export interface IBoilerPartsFilter {\n\t  boiler_manufacturer: string | undefined;\n\t  parts_manufacturer: string | undefined;\n\t  price: { [Op.between]: number[] };\n\t}\n"]}
