{"filename": "test/scratch.ts", "chunked_list": ["import { Test } from '../dist/cjs/test-built.js'\n\timport { TestBaseOpts } from '../dist/cjs/test-base.js'\n\tconst opts: TestBaseOpts = {\n\t  debug: /\\btap\\b/.test(process.env.NODE_DEBUG || ''),\n\t  name: 'TAP',\n\t}\n\tconst t = new Test(opts)\n\tt.stream.pipe(process.stdout)\n\tt.runMain(() => {})\n\tt.beforeEach(() => {\n", "  console.log('first beforeEach')\n\t})\n\tt.beforeEach(() => {\n\t  console.log('second beforeEach')\n\t})\n\tt.afterEach(() => {\n\t  console.log('parent aftereach')\n\t})\n\tt.test('hello', {}, t => {\n\t  t.pass('this is fine')\n", "  t.beforeEach(() => {\n\t    console.log('child beforeeach')\n\t  })\n\t  t.afterEach(() => {\n\t    console.log('child aftereach')\n\t  })\n\t  t.test('hello child', {}, t => {\n\t    t.pass('also fine')\n\t    t.end()\n\t  })\n", "  t.end()\n\t})\n\tt.end()\n"]}
{"filename": "src/diags.ts", "chunked_list": ["import yaml from 'tap-yaml'\n\timport { cleanYamlObject } from './clean-yaml-object.js'\n\timport { TestBaseOpts } from './test-base.js'\n\texport const diags = (\n\t  obj: { [k: string]: any },\n\t  options: TestBaseOpts = {}\n\t) => {\n\t  const clean = cleanYamlObject(obj, options)\n\t  if (\n\t    !clean ||\n", "    typeof clean !== 'object' ||\n\t    !Object.keys(clean).length\n\t  ) {\n\t    return ''\n\t  }\n\t  return (\n\t    '  ---\\n' +\n\t    yaml\n\t      .stringify(clean)\n\t      .split('\\n')\n", "      .map(l => (l.trim() ? '  ' + l : l.trim()))\n\t      .join('\\n') +\n\t    '  ...\\n'\n\t  )\n\t}\n"]}
{"filename": "src/base.ts", "chunked_list": ["// ok, so, export the root PluginBase, PluginHost, and the Base\n\t// Both have the stream stuff, and basic TAP parser stuff\n\t// PluginHost has all the default assertions, so a Plugin can\n\t// do stuff like `return t.ok()`\n\t// Base is a parent of PluginBase, and used for stuff like Spawn,\n\t// Stdin, and Worker subclasses\n\t//\n\t// tap.Test is extended from the generated source, so it has all plugins\n\t/*\n\t## Class heirarchy\n", "Base - streaming, parsing, test status, config loading\n\t+-- Spawn - run a child proc, consume output as tap stream\n\t+-- Stdin - consume stdin as tap stream\n\t+-- Worker - run a worker thread, consume output as tap stream\n\t+-- TestBase - generate tap stream, built-in set of assertions\n\t  +-- (builtin plugins...) - add functions for spawn, assertions, snapshot, mock, etc\n\t    +-- (user plugins...) - whatever the config says to load\n\t      +-- Test - the test class exposed to user\n\t        +-- TAP - the root test runner\n\t*/\n", "import Domain from 'async-hook-domain'\n\timport { AsyncResource } from 'async_hooks'\n\timport Minipass, {\n\t  ContiguousData,\n\t  Encoding,\n\t} from 'minipass'\n\timport { hrtime } from 'node:process'\n\timport { format } from 'node:util'\n\timport {\n\t  FinalResults,\n", "  Parser,\n\t  Result,\n\t  TapError,\n\t} from 'tap-parser'\n\timport Deferred from 'trivial-deferred'\n\timport extraFromError from './extra-from-error'\n\texport class TapWrap extends AsyncResource {\n\t  test: Base\n\t  constructor(test: Base) {\n\t    super(`tap.${test.constructor.name}`)\n", "    this.test = test\n\t  }\n\t}\n\texport class Counts {\n\t  total: number = 0\n\t  pass: number = 0\n\t  fail: number = 0\n\t  skip: number = 0\n\t  todo: number = 0\n\t}\n", "export class Lists {\n\t  fail: Result[] = []\n\t  todo: Result[] = []\n\t  skip: Result[] = []\n\t  pass: Result[] = []\n\t}\n\tconst debug =\n\t  (name: string) =>\n\t  (...args: any[]) => {\n\t    const prefix = `TAP ${process.pid} ${name}: `\n", "    const msg = format(...args).trim()\n\t    console.error(\n\t      prefix + msg.split('\\n').join(`\\n${prefix}`)\n\t    )\n\t  }\n\texport interface BaseOpts {\n\t  // parser-related options\n\t  bail?: boolean\n\t  strict?: boolean\n\t  omitVersion?: boolean\n", "  preserveWhitespace?: boolean\n\t  skip?: boolean | string\n\t  todo?: boolean | string\n\t  timeout?: number\n\t  time?: number\n\t  tapChildBuffer?: string\n\t  stack?: string\n\t  // basically only set when running in this project\n\t  stackIncludesTap?: boolean\n\t  parent?: Base\n", "  name?: string\n\t  childId?: number\n\t  context?: any\n\t  indent?: string\n\t  debug?: boolean\n\t  parser?: Parser\n\t  buffered?: boolean\n\t  silent?: boolean\n\t}\n\texport class Base {\n", "  stream: Minipass<string> = new Minipass<string>({\n\t    encoding: 'utf8',\n\t  })\n\t  readyToProcess: boolean = false\n\t  options: BaseOpts\n\t  indent: string\n\t  hook: TapWrap\n\t  // this actually is deterministically set in the ctor, but\n\t  // in the hook, so tsc doesn't see it.\n\t  hookDomain!: Domain\n", "  timer?: NodeJS.Timeout\n\t  parser: Parser\n\t  debug: (...args: any[]) => void\n\t  counts: Counts\n\t  lists: Lists\n\t  name: string\n\t  results?: FinalResults\n\t  parent?: Base\n\t  bail: boolean\n\t  strict: boolean\n", "  omitVersion: boolean\n\t  preserveWhitespace: boolean\n\t  errors: TapError[]\n\t  childId: number\n\t  context: any\n\t  output: string\n\t  buffered: boolean\n\t  bailedOut: string | boolean\n\t  start: bigint\n\t  time: number\n", "  hrtime: bigint\n\t  silent: boolean\n\t  deferred?: Deferred<FinalResults>\n\t  constructor(options: BaseOpts = {}) {\n\t    // all tap streams are sync string minipasses\n\t    this.hook = new TapWrap(this)\n\t    this.options = options\n\t    this.counts = new Counts()\n\t    this.lists = new Lists()\n\t    this.silent = !!options.silent\n", "    // if it's null or an object, inherit from it.  otherwise, copy it.\n\t    const ctx = options.context\n\t    if (ctx !== undefined) {\n\t      this.context =\n\t        typeof ctx === 'object' ? Object.create(ctx) : ctx\n\t    } else {\n\t      this.context = null\n\t    }\n\t    this.bail = !!options.bail\n\t    this.strict = !!options.strict\n", "    this.omitVersion = !!options.omitVersion\n\t    this.preserveWhitespace = !!options.preserveWhitespace\n\t    this.buffered = !!options.buffered\n\t    this.bailedOut = false\n\t    this.errors = []\n\t    this.parent = options.parent\n\t    this.time = 0\n\t    this.hrtime = 0n\n\t    this.start = 0n\n\t    this.childId = options.childId || 0\n", "    // do we need this?  couldn't we just call the Minipass\n\t    this.output = ''\n\t    this.indent = options.indent || ''\n\t    this.name = options.name || '(unnamed test)'\n\t    this.hook.runInAsyncScope(\n\t      () =>\n\t        (this.hookDomain = new Domain((er, type) => {\n\t          if (!er || typeof er !== 'object')\n\t            er = { error: er }\n\t          er.tapCaught = type\n", "          this.threw(er)\n\t        }))\n\t    )\n\t    this.debug = !!options.debug\n\t      ? debug(this.name)\n\t      : () => {}\n\t    this.parser =\n\t      options.parser ||\n\t      new Parser({\n\t        bail: this.bail,\n", "        strict: this.strict,\n\t        omitVersion: this.omitVersion,\n\t        preserveWhitespace: this.preserveWhitespace,\n\t        name: this.name,\n\t      })\n\t    this.setupParser()\n\t    // ensure that a skip or todo on a child class reverts\n\t    // back to Base's no-op main.\n\t    if (options.skip || options.todo) {\n\t      this.main = Base.prototype.main\n", "    }\n\t  }\n\t  setupParser() {\n\t    this.parser.on('line', l => this.online(l))\n\t    this.parser.once('bailout', reason =>\n\t      this.onbail(reason)\n\t    )\n\t    this.parser.on('complete', result =>\n\t      this.oncomplete(result)\n\t    )\n", "    this.parser.on('result', () => this.counts.total++)\n\t    this.parser.on('pass', () => this.counts.pass++)\n\t    this.parser.on('todo', res => {\n\t      this.counts.todo++\n\t      this.lists.todo.push(res)\n\t    })\n\t    this.parser.on('skip', res => {\n\t      // it is uselessly noisy to print out lists of tests skipped\n\t      // because of a --grep or --only argument.\n\t      if (/^filter: (only|\\/.*\\/)$/.test(res.skip)) return\n", "      this.counts.skip++\n\t      this.lists.skip.push(res)\n\t    })\n\t    this.parser.on('fail', res => {\n\t      this.counts.fail++\n\t      this.lists.fail.push(res)\n\t    })\n\t  }\n\t  setTimeout(n: number) {\n\t    if (n <= 0) {\n", "      if (this.timer) {\n\t        clearTimeout(this.timer)\n\t      }\n\t      this.timer = undefined\n\t    } else {\n\t      this.timer = setTimeout(() => this.timeout(), n)\n\t      this.timer.unref()\n\t    }\n\t  }\n\t  timeout(options?: { [k: string]: any }) {\n", "    this.setTimeout(0)\n\t    options = options || {}\n\t    options.expired = options.expired || this.name\n\t    const threw = this.threw(new Error('timeout!'), options)\n\t    if (threw) {\n\t      this.emit('timeout', threw)\n\t    }\n\t  }\n\t  runMain(cb: () => void) {\n\t    this.debug('BASE runMain')\n", "    this.start = hrtime.bigint()\n\t    this.hook.runInAsyncScope(this.main, this, cb)\n\t  }\n\t  main(cb: () => void) {\n\t    cb()\n\t  }\n\t  onbail(reason?: string) {\n\t    this.bailedOut = reason || true\n\t    this.emit('bailout', reason)\n\t  }\n", "  online(line: string) {\n\t    this.debug('LINE %j', line, [this.name, this.indent])\n\t    return this.write(this.indent + line)\n\t  }\n\t  write(\n\t    c: ContiguousData,\n\t    e?: Encoding | (() => any),\n\t    cb?: () => any\n\t  ) {\n\t    if (this.buffered) {\n", "      this.output += c\n\t      return true\n\t    }\n\t    if (typeof e === 'function') {\n\t      cb = e\n\t      e = undefined\n\t    }\n\t    return this.stream.write(\n\t      c,\n\t      e as Encoding | undefined,\n", "      cb\n\t    )\n\t  }\n\t  oncomplete(results: FinalResults) {\n\t    if (this.start) {\n\t      this.hrtime = hrtime.bigint() - this.start\n\t      this.time =\n\t        results.time || Number(this.hrtime / 1000n)\n\t    }\n\t    this.debug('ONCOMPLETE %j %j', this.name, results)\n", "    if (this.results) {\n\t      Object.assign(results, this.results)\n\t    }\n\t    this.results = results\n\t    this.emit('complete', results)\n\t    const errors = results.failures\n\t      .filter(f => f.tapError)\n\t      .map(f => {\n\t        delete f.diag\n\t        delete f.ok\n", "        return f\n\t      })\n\t    if (errors.length) {\n\t      this.errors = errors\n\t    }\n\t    this.onbeforeend()\n\t    // XXX old tap had a check here to ensure that buffer and pipes\n\t    // are cleared.  But Minipass \"should\" do this now for us, so\n\t    // this ought to be fine, but revisit if it causes problems.\n\t    this.stream.end()\n", "  }\n\t  // extension points for Test, Spawn, etc.\n\t  onbeforeend() {}\n\t  ondone() {}\n\t  once(ev: string, handler: (...a: any[]) => any) {\n\t    return this.stream.once(ev, handler)\n\t  }\n\t  on(ev: string, handler: (...a: any[]) => any) {\n\t    return this.stream.on(ev, handler)\n\t  }\n", "  emit(ev: string, ...data: any[]) {\n\t    const ret = this.stream.emit(ev, ...data)\n\t    if (ev === 'end') {\n\t      this.ondone()\n\t      this.hook.emitDestroy()\n\t      this.hookDomain.destroy()\n\t    }\n\t    return ret\n\t  }\n\t  end() {\n", "    this.stream.end()\n\t    return this\n\t  }\n\t  threw(er: any, extra?: any, proxy?: boolean) {\n\t    this.hook.emitDestroy()\n\t    this.hookDomain.destroy()\n\t    if (typeof er === 'string') {\n\t      er = { message: er }\n\t    } else if (!er || typeof er !== 'object') {\n\t      er = { error: er }\n", "    }\n\t    if (this.name && !proxy) {\n\t      er.test = this.name\n\t    }\n\t    const message = er.message\n\t    if (!extra) {\n\t      extra = extraFromError(er, extra, this.options)\n\t    }\n\t    // if we ended, we have to report it SOMEWHERE, unless we're\n\t    // already in the process of bailing out, in which case it's\n", "    // a bit excessive.\n\t    if (this.results) {\n\t      const alreadyBailing = !this.results.ok && this.bail\n\t      this.results.ok = false\n\t      if (this.parent) {\n\t        this.parent.threw(er, extra, true)\n\t      } else if (alreadyBailing) {\n\t        // we are already bailing out, and this is the top level,\n\t        // just make our way hastily to the nearest exit.\n\t        return\n", "      } else if (!er.stack) {\n\t        console.error(er)\n\t      } else {\n\t        if (message) {\n\t          er.message = message\n\t        }\n\t        delete extra.stack\n\t        delete extra.at\n\t        console.error('%s: %s', er.name || 'Error', message)\n\t        console.error(\n", "          er.stack.split(/\\n/).slice(1).join('\\n')\n\t        )\n\t        console.error(extra)\n\t      }\n\t    } else {\n\t      this.parser.ok = false\n\t    }\n\t    return extra\n\t  }\n\t  passing() {\n", "    return this.parser.ok\n\t  }\n\t}\n"]}
{"filename": "src/clean-yaml-object.ts", "chunked_list": ["import { createTwoFilesPatch } from 'diff'\n\timport { readFileSync } from 'node:fs'\n\timport { resolve } from 'node:path'\n\timport { format, strict } from 'tcompare'\n\timport stack from './stack.js'\n\timport type { TestBaseOpts } from './test-base.js'\n\timport { tapDir } from './tap-dir.js'\n\tconst tryReadFile = (path: string) => {\n\t  try {\n\t    return readFileSync(path, 'utf8')\n", "  } catch (_) {\n\t    return\n\t  }\n\t}\n\tconst hasOwn = (obj: { [k: string]: any }, key: string) =>\n\t  Object.prototype.hasOwnProperty.call(obj, key)\n\texport const cleanYamlObject = (\n\t  object: { [k: string]: any },\n\t  options: TestBaseOpts\n\t) => {\n", "  const res = { ...object }\n\t  if (hasOwn(res, 'stack') && !hasOwn(res, 'at')) {\n\t    res.at = stack.parseLine(res.stack.split('\\n')[0])\n\t  }\n\t  const file = res.at && res.at.file && resolve(res.at.file)\n\t  if (\n\t    !options.stackIncludesTap &&\n\t    file &&\n\t    file.includes(tapDir)\n\t  ) {\n", "    // don't print locations in tap itself, that's almost never useful\n\t    delete res.at\n\t  }\n\t  if (\n\t    file &&\n\t    res.at &&\n\t    res.at.file &&\n\t    res.at.line &&\n\t    !res.source\n\t  ) {\n", "    const content = tryReadFile(file)\n\t    if (content) {\n\t      const lines = content.split('\\n')\n\t      if (res.at.line <= lines.length) {\n\t        const startLine = Math.max(res.at.line - 2, 0)\n\t        const endLine = Math.min(\n\t          res.at.line + 2,\n\t          lines.length\n\t        )\n\t        const caret =\n", "          res.at.column &&\n\t          res.at.column <= lines[res.at.line - 1].length\n\t            ? [new Array(res.at.column).join('-') + '^']\n\t            : []\n\t        const context = lines\n\t          .slice(startLine, res.at.line)\n\t          .concat(caret)\n\t          .concat(lines.slice(res.at.line, endLine))\n\t        const csplit = context.join('\\n').trimEnd()\n\t        if (csplit) res.source = csplit + '\\n'\n", "      }\n\t    }\n\t  }\n\t  // show a line by line string diff\n\t  // diff the yaml, to make it more humane, especially\n\t  // when strings or buffers are very large or multi-line\n\t  // the shipped compare methods will generally supply\n\t  // their own diff, which is much nicer.\n\t  if (\n\t    res.found &&\n", "    res.wanted &&\n\t    res.found !== res.wanted &&\n\t    !res.diff\n\t  ) {\n\t    const f = res.found\n\t    const w = res.wanted\n\t    if (typeof f === 'string' && typeof w === 'string')\n\t      res.diff = createTwoFilesPatch(\n\t        'expected',\n\t        'actual',\n", "        w + '\\n',\n\t        f + '\\n'\n\t      ).replace(/^=+\\n/, '')\n\t    else if (\n\t      f &&\n\t      w &&\n\t      typeof f === 'object' &&\n\t      typeof w === 'object'\n\t    ) {\n\t      const s = strict(f, w)\n", "      if (!s.match) {\n\t        res.diff = s.diff\n\t      } else {\n\t        res.note = 'object identities differ'\n\t      }\n\t    } else {\n\t      // some mixed stringly bits\n\t      // XXX tcompare needs better string diffs\n\t      const ff = format(f)\n\t      const fw = format(w)\n", "      const fs = (typeof f === 'string' ? f : ff) + '\\n'\n\t      const ws = (typeof w === 'string' ? w : fw) + '\\n'\n\t      /* istanbul ignore else - impossible without bug in tcompare */\n\t      if (fw !== ff) {\n\t        res.diff = createTwoFilesPatch(\n\t          'expected',\n\t          'actual',\n\t          ws,\n\t          fs\n\t        ).replace(/^=+\\n/, '')\n", "      } else {\n\t        res.note = 'object identities differ'\n\t      }\n\t    }\n\t    if (res.diff === '--- expected\\n+++ actual\\n') {\n\t      delete res.diff\n\t    }\n\t    if (res.diff) {\n\t      delete res.found\n\t      delete res.wanted\n", "    }\n\t  }\n\t  for (const [key, value] of Object.entries(res)) {\n\t    if (shouldDeleteKey(key, value)) {\n\t      delete res[key]\n\t    }\n\t  }\n\t  return res\n\t}\n\texport const deleteAlways = new Set([\n", "  'todo',\n\t  'time',\n\t  'childId',\n\t  'cb',\n\t  'name',\n\t  'indent',\n\t  'skip',\n\t  'bail',\n\t  'grep',\n\t  'grepInvert',\n", "  'only',\n\t  'diagnostic',\n\t  'buffered',\n\t  'parent',\n\t  'domainEmitter',\n\t  'domainThrew',\n\t  'domain',\n\t  'saveFixture',\n\t])\n\texport const deleteIfEmpty = new Set([\n", "  'at',\n\t  'stack',\n\t  'compareOptions',\n\t])\n\texport const deleteIfMatch = [\n\t  /^_?tapChild/,\n\t  /^tapStream/,\n\t  /^tapMochaTest/,\n\t]\n\tconst shouldDeleteKey = (key: string, value: any) =>\n", "  deleteAlways.has(key) ||\n\t  (deleteIfEmpty.has(key) && isEmpty(value)) ||\n\t  deleteIfMatch.some(r => r.test(key))\n\t// return true if object is empty, including inherited properties\n\tconst isEmpty = (obj: any): obj is {} => {\n\t  if (!obj) {\n\t    return true\n\t  }\n\t  if (typeof obj !== 'object') {\n\t    return false\n", "  }\n\t  for (const _ in obj) {\n\t    return false\n\t  }\n\t  return true\n\t}\n"]}
{"filename": "src/test-built.ts", "chunked_list": ["// This file is automatically generated, please do not edit\n\timport { FinalResults } from 'tap-parser'\n\timport parseTestArgs, {\n\t  TestArgs,\n\t} from './parse-test-args.js'\n\timport { TestBase, TestBaseOpts } from './test-base.js'\n\tconst copyToString = (v: Function) => ({\n\t  toString: Object.assign(() => v.toString(), {\n\t    toString: () => 'function toString() { [native code] }',\n\t  }),\n", "})\n\timport plugin0 from \"./plugin/after-each.js\"\n\timport plugin1 from \"./plugin/before-each.js\"\n\timport plugin2 from \"./plugin/spawn.js\"\n\timport plugin3 from \"./plugin/stdin.js\"\n\ttype PI<O extends TestBaseOpts | any = any> =\n\t  | ((t: Test, opts: O) => Plug)\n\t  | ((t: Test) => Plug)\n\tconst plugins: PI[] = [\n\t  plugin0,\n", "  plugin1,\n\t  plugin2,\n\t  plugin3,\n\t]\n\ttype Plug =\n\t  | TestBase\n\t  | { t: Test }\n\t  | ReturnType<typeof plugin0>\n\t  | ReturnType<typeof plugin1>\n\t  | ReturnType<typeof plugin2>\n", "  | ReturnType<typeof plugin3>\n\ttype PlugKeys =\n\t  | keyof TestBase\n\t  | 't'\n\t  | keyof ReturnType<typeof plugin0>\n\t  | keyof ReturnType<typeof plugin1>\n\t  | keyof ReturnType<typeof plugin2>\n\t  | keyof ReturnType<typeof plugin3>\n\ttype SecondParam<\n\t  T extends [any] | [any, any],\n", "  Fallback extends unknown = unknown\n\t> = T extends [any, any] ? T[1] : Fallback\n\ttype Plugin0Opts = SecondParam<\n\t  Parameters<typeof plugin0>,\n\t  TestBaseOpts\n\t>\n\ttype Plugin1Opts = SecondParam<\n\t  Parameters<typeof plugin1>,\n\t  TestBaseOpts\n\t>\n", "type Plugin2Opts = SecondParam<\n\t  Parameters<typeof plugin2>,\n\t  TestBaseOpts\n\t>\n\ttype Plugin3Opts = SecondParam<\n\t  Parameters<typeof plugin3>,\n\t  TestBaseOpts\n\t>\n\ttype TestOpts = TestBaseOpts\n\t  & Plugin0Opts\n", "  & Plugin1Opts\n\t  & Plugin2Opts\n\t  & Plugin3Opts\n\ttype TTest = TestBase\n\t  & ReturnType<typeof plugin0>\n\t  & ReturnType<typeof plugin1>\n\t  & ReturnType<typeof plugin2>\n\t  & ReturnType<typeof plugin3>\n\texport interface Test extends TTest {\n\t  end(): this\n", "  t: Test\n\t  test(\n\t    name: string,\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  test(\n\t    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n", "  test(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  test(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  test(\n\t    ...args: TestArgs<Test>\n\t  ): Promise<FinalResults | null>\n\t  todo(\n\t    name: string,\n", "    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  todo(\n\t    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  todo(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n", "  ): Promise<FinalResults | null>\n\t  todo(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  todo(\n\t    ...args: TestArgs<Test>\n\t  ): Promise<FinalResults | null>\n\t  skip(\n\t    name: string,\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n", "  skip(\n\t    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  skip(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  skip(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  skip(\n", "    ...args: TestArgs<Test>\n\t  ): Promise<FinalResults | null>\n\t}\n\tconst applyPlugins = (base: Test): Test => {\n\t  const ext: Plug[] = [\n\t    ...plugins.map(p => p(base, base.options)),\n\t    base,\n\t  ]\n\t  const getCache = new Map<any, any>()\n\t  const t = new Proxy(base, {\n", "    has(_, p) {\n\t      for (const t of ext) {\n\t        if (Reflect.has(t, p)) return true\n\t      }\n\t      return false\n\t    },\n\t    ownKeys() {\n\t      const k: PlugKeys[] = []\n\t      for (const t of ext) {\n\t        const keys = Reflect.ownKeys(t) as PlugKeys[]\n", "        k.push(...keys)\n\t      }\n\t      return [...new Set(k)]\n\t    },\n\t    getOwnPropertyDescriptor(_, p) {\n\t      for (const t of ext) {\n\t        const prop = Reflect.getOwnPropertyDescriptor(t, p)\n\t        if (prop) return prop\n\t      }\n\t      return undefined\n", "    },\n\t    set(_, p, v) {\n\t      // check to see if there's any setters, and if so, set it there\n\t      // otherwise, just set on the base\n\t      for (const t of ext) {\n\t        let o: Object | null = t\n\t        while (o) {\n\t          if (Reflect.getOwnPropertyDescriptor(o, p)?.set) {\n\t            //@ts-ignore\n\t            t[p] = v\n", "            return true\n\t          }\n\t          o = Reflect.getPrototypeOf(o)\n\t        }\n\t      }\n\t      //@ts-ignore\n\t      base[p as keyof TestBase] = v\n\t      return true\n\t    },\n\t    get(_, p) {\n", "      // cache get results so t.blah === t.blah\n\t      // we only cache functions, so that getters aren't memoized\n\t      // Of course, a getter that returns a function will be broken,\n\t      // at least when accessed from outside the plugin, but that's\n\t      // a pretty narrow caveat, and easily documented.\n\t      if (getCache.has(p)) return getCache.get(p)\n\t      for (const plug of ext) {\n\t        if (p in plug) {\n\t          //@ts-ignore\n\t          const v = plug[p]\n", "          // Functions need special handling so that they report\n\t          // the correct toString and are called on the correct object\n\t          // Otherwise attempting to access #private props will fail.\n\t          if (typeof v === 'function') {\n\t            const f: (this: Plug, ...args: any) => any =\n\t              function (...args: any[]) {\n\t                const thisArg = this === t ? plug : this\n\t                return v.apply(thisArg, args)\n\t              }\n\t            const vv = Object.assign(f, copyToString(v))\n", "            const nameProp =\n\t              Reflect.getOwnPropertyDescriptor(v, 'name')\n\t            if (nameProp) {\n\t              Reflect.defineProperty(f, 'name', nameProp)\n\t            }\n\t            getCache.set(p, vv)\n\t            return vv\n\t          } else {\n\t            getCache.set(p, v)\n\t            return v\n", "          }\n\t        }\n\t      }\n\t    },\n\t  })\n\t  Object.assign(base, { t })\n\t  ext.unshift({ t })\n\t  return t\n\t}\n\texport class Test extends TestBase {\n", "  constructor(opts: TestOpts) {\n\t    super(opts)\n\t    return applyPlugins(this)\n\t  }\n\t  test(\n\t    name: string,\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  test(\n", "    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  test(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  test(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  test(\n\t    ...args: TestArgs<Test>\n", "  ): Promise<FinalResults | null> {\n\t    const extra = parseTestArgs(...args)\n\t    extra.todo = true\n\t    return this.sub(Test, extra, this.test)\n\t  }\n\t  todo(\n\t    name: string,\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n", "  todo(\n\t    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  todo(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  todo(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  todo(\n", "    ...args: TestArgs<Test>\n\t  ): Promise<FinalResults | null> {\n\t    const extra = parseTestArgs(...args)\n\t    extra.todo = true\n\t    return this.sub(Test, extra, this.todo)\n\t  }\n\t  skip(\n\t    name: string,\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n", "  ): Promise<FinalResults | null>\n\t  skip(\n\t    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  skip(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  skip(cb?: (t: Test) => any): Promise<FinalResults | null>\n", "  skip(\n\t    ...args: TestArgs<Test>\n\t  ): Promise<FinalResults | null> {\n\t    const extra = parseTestArgs(...args)\n\t    extra.skip = true\n\t    return this.sub(Test, extra, this.skip)\n\t  }\n\t}\n"]}
{"filename": "src/test.ts", "chunked_list": ["// the Test class is built up from PluginBase + all the plugins\n\timport { TestBase } from './test-base.js'\n\texport class Test extends TestBase {}\n"]}
{"filename": "src/stack.ts", "chunked_list": ["import StackUtils from 'stack-utils'\n\texport default new StackUtils({\n\t  internals: StackUtils.nodeInternals(),\n\t  ignoredPackages: []\n\t})\n"]}
{"filename": "src/test-template.ts", "chunked_list": ["//{{HEADER COMMENT START}}\n\t// This is the template file used to generate the Test client\n\t// module.  Prior to being built, it's effectively just a copy\n\t// of the TestBase class, without any plugins applied.\n\t//{{HEADER COMMENT END}}\n\timport { FinalResults } from 'tap-parser'\n\timport parseTestArgs, {\n\t  TestArgs,\n\t} from './parse-test-args.js'\n\timport { TestBase, TestBaseOpts } from './test-base.js'\n", "const copyToString = (v: Function) => ({\n\t  toString: Object.assign(() => v.toString(), {\n\t    toString: () => 'function toString() { [native code] }',\n\t  }),\n\t})\n\t//{{PLUGIN IMPORT START}}\n\t//{{PLUGIN IMPORT END}}\n\ttype PI<O extends TestBaseOpts | any = any> =\n\t  | ((t: Test, opts: O) => Plug)\n\t  | ((t: Test) => Plug)\n", "//{{PLUGINS CODE START}}\n\ttype Plug = TestBase | { t: Test }\n\tconst plugins: PI[] = []\n\ttype PlugKeys = keyof TestBase | 't'\n\t//{{PLUGINS CODE END}}\n\t//{{OPTS START}}\n\ttype TestOpts = TestBaseOpts\n\t//{{OPTS END}}\n\t//{{TEST INTERFACE START}}\n\ttype TTest = TestBase\n", "//{{TEST INTERFACE END}}\n\texport interface Test extends TTest {\n\t  end(): this\n\t  t: Test\n\t  test(\n\t    name: string,\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  test(\n", "    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  test(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  test(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  test(\n\t    ...args: TestArgs<Test>\n", "  ): Promise<FinalResults | null>\n\t  todo(\n\t    name: string,\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  todo(\n\t    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n", "  todo(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  todo(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  todo(\n\t    ...args: TestArgs<Test>\n\t  ): Promise<FinalResults | null>\n\t  skip(\n\t    name: string,\n", "    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  skip(\n\t    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  skip(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n", "  ): Promise<FinalResults | null>\n\t  skip(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  skip(\n\t    ...args: TestArgs<Test>\n\t  ): Promise<FinalResults | null>\n\t}\n\tconst applyPlugins = (base: Test): Test => {\n\t  const ext: Plug[] = [\n\t    ...plugins.map(p => p(base, base.options)),\n\t    base,\n", "  ]\n\t  const getCache = new Map<any, any>()\n\t  const t = new Proxy(base, {\n\t    has(_, p) {\n\t      for (const t of ext) {\n\t        if (Reflect.has(t, p)) return true\n\t      }\n\t      return false\n\t    },\n\t    ownKeys() {\n", "      const k: PlugKeys[] = []\n\t      for (const t of ext) {\n\t        const keys = Reflect.ownKeys(t) as PlugKeys[]\n\t        k.push(...keys)\n\t      }\n\t      return [...new Set(k)]\n\t    },\n\t    getOwnPropertyDescriptor(_, p) {\n\t      for (const t of ext) {\n\t        const prop = Reflect.getOwnPropertyDescriptor(t, p)\n", "        if (prop) return prop\n\t      }\n\t      return undefined\n\t    },\n\t    set(_, p, v) {\n\t      // check to see if there's any setters, and if so, set it there\n\t      // otherwise, just set on the base\n\t      for (const t of ext) {\n\t        let o: Object | null = t\n\t        while (o) {\n", "          if (Reflect.getOwnPropertyDescriptor(o, p)?.set) {\n\t            //@ts-ignore\n\t            t[p] = v\n\t            return true\n\t          }\n\t          o = Reflect.getPrototypeOf(o)\n\t        }\n\t      }\n\t      //@ts-ignore\n\t      base[p as keyof TestBase] = v\n", "      return true\n\t    },\n\t    get(_, p) {\n\t      // cache get results so t.blah === t.blah\n\t      // we only cache functions, so that getters aren't memoized\n\t      // Of course, a getter that returns a function will be broken,\n\t      // at least when accessed from outside the plugin, but that's\n\t      // a pretty narrow caveat, and easily documented.\n\t      if (getCache.has(p)) return getCache.get(p)\n\t      for (const plug of ext) {\n", "        if (p in plug) {\n\t          //@ts-ignore\n\t          const v = plug[p]\n\t          // Functions need special handling so that they report\n\t          // the correct toString and are called on the correct object\n\t          // Otherwise attempting to access #private props will fail.\n\t          if (typeof v === 'function') {\n\t            const f: (this: Plug, ...args: any) => any =\n\t              function (...args: any[]) {\n\t                const thisArg = this === t ? plug : this\n", "                return v.apply(thisArg, args)\n\t              }\n\t            const vv = Object.assign(f, copyToString(v))\n\t            const nameProp =\n\t              Reflect.getOwnPropertyDescriptor(v, 'name')\n\t            if (nameProp) {\n\t              Reflect.defineProperty(f, 'name', nameProp)\n\t            }\n\t            getCache.set(p, vv)\n\t            return vv\n", "          } else {\n\t            getCache.set(p, v)\n\t            return v\n\t          }\n\t        }\n\t      }\n\t    },\n\t  })\n\t  Object.assign(base, { t })\n\t  ext.unshift({ t })\n", "  return t\n\t}\n\texport class Test extends TestBase {\n\t  constructor(opts: TestOpts) {\n\t    super(opts)\n\t    return applyPlugins(this)\n\t  }\n\t  test(\n\t    name: string,\n\t    extra: { [k: string]: any },\n", "    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  test(\n\t    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  test(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n", "  test(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  test(\n\t    ...args: TestArgs<Test>\n\t  ): Promise<FinalResults | null> {\n\t    const extra = parseTestArgs(...args)\n\t    extra.todo = true\n\t    return this.sub(Test, extra, this.test)\n\t  }\n\t  todo(\n\t    name: string,\n", "    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  todo(\n\t    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  todo(\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n", "  ): Promise<FinalResults | null>\n\t  todo(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  todo(\n\t    ...args: TestArgs<Test>\n\t  ): Promise<FinalResults | null> {\n\t    const extra = parseTestArgs(...args)\n\t    extra.todo = true\n\t    return this.sub(Test, extra, this.todo)\n\t  }\n\t  skip(\n", "    name: string,\n\t    extra: { [k: string]: any },\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  skip(\n\t    name: string,\n\t    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  skip(\n\t    extra: { [k: string]: any },\n", "    cb?: (t: Test) => any\n\t  ): Promise<FinalResults | null>\n\t  skip(cb?: (t: Test) => any): Promise<FinalResults | null>\n\t  skip(\n\t    ...args: TestArgs<Test>\n\t  ): Promise<FinalResults | null> {\n\t    const extra = parseTestArgs(...args)\n\t    extra.skip = true\n\t    return this.sub(Test, extra, this.skip)\n\t  }\n", "}\n"]}
{"filename": "src/parse-test-args.ts", "chunked_list": ["import type { Base } from './base.js'\n\texport type TestArgs<T extends Base> =\n\t  | [\n\t      name?: string | number,\n\t      extra?: { [k: string]: any },\n\t      cb?: false | ((t: T) => any),\n\t      defaultName?: string\n\t    ]\n\t  | [\n\t      extra: { [k: string]: any },\n", "      cb?: ((t: T) => any) | false\n\t    ]\n\t  | [name: string | number, cb?: ((t: T) => any) | false]\n\t  | [cb?: ((t: T) => any) | false]\n\t  | [name: string]\n\t  | [extra: { [k: string]: any }]\n\texport default function parseTestArgs<T extends Base>(\n\t  ...args: TestArgs<T>\n\t) {\n\t  let name: string | null | undefined = undefined\n", "  let extra: { [k: string]: any } | null | undefined =\n\t    undefined\n\t  let cb: ((t: T) => any) | null | undefined = undefined\n\t  // this only works if it's literally the 4th argument.\n\t  // used internally.\n\t  const defaultName = args[3] || ''\n\t  for (let i = 0; i < 3 && i < args.length; i++) {\n\t    const arg = args[i]\n\t    if (\n\t      name === undefined &&\n", "      (typeof arg === 'string' || typeof arg === 'number')\n\t    )\n\t      name = '' + arg\n\t    else if (arg && typeof arg === 'object') {\n\t      extra = arg\n\t      if (name === undefined) name = null\n\t    } else if (typeof arg === 'function') {\n\t      if (extra === undefined) extra = {}\n\t      if (name === undefined) name = null\n\t      cb = arg\n", "    } else if (arg === false) {\n\t      // it's handy while developing to put a ! in front of a\n\t      // function to temporarily make a test todo\n\t      continue\n\t    } else if (typeof arg !== 'undefined')\n\t      throw new TypeError(\n\t        'unknown argument passed to parseTestArgs: ' +\n\t          typeof arg\n\t      )\n\t  }\n", "  if (!extra) extra = {}\n\t  if (!cb && defaultName !== '/dev/stdin')\n\t    extra.todo = extra.todo || true\n\t  if (!name && extra.name) name = extra.name\n\t  if (!name && cb && cb.name) name = cb.name\n\t  name = name || defaultName\n\t  extra.name = name\n\t  extra.cb = cb || todoCb\n\t  return extra\n\t}\n", "const todoCb = () => {\n\t  throw new Error('callback called for TODO test')\n\t}\n"]}
{"filename": "src/esc.ts", "chunked_list": ["// turn \\ into \\\\ and # into \\#, for stringifying back to TAP\n\texport const esc = (str: string) =>\n\t  str.replace(/\\\\/g, '\\\\\\\\').replace(/#/g, '\\\\#')\n"]}
{"filename": "src/worker.ts", "chunked_list": ["// the .worker() method is only added to the root test object\n\t// See https://github.com/tapjs/node-tap/issues/812\n\texport class Worker {}\n"]}
{"filename": "src/build.ts", "chunked_list": ["#!/usr/bin/env node --loader=ts-node/esm --no-warnings\n\timport {\n\t  readdirSync,\n\t  readFileSync,\n\t  writeFileSync,\n\t} from 'node:fs'\n\timport { dirname, relative, resolve } from 'node:path'\n\tif (typeof process.argv[4] !== 'string') {\n\t  console.error(\n\t    'usage: build.ts <test template> <plugins dir>'\n", "  )\n\t  process.exit(1)\n\t}\n\tlet template = readFileSync(\n\t  resolve(process.argv[2]),\n\t  'utf8'\n\t)\n\tconst out = resolve(process.argv[4])\n\tconst pluginsDir = resolve(process.argv[3])\n\tconst plugins = readdirSync(pluginsDir).map(\n", "  p =>\n\t    './' +\n\t    relative(\n\t      dirname(out),\n\t      resolve(pluginsDir, p).replace(/\\.ts/, '.js')\n\t    )\n\t)\n\tconst pluginImport = plugins\n\t  .map(\n\t    (p, i) =>\n", "      `import plugin${i} from ${JSON.stringify(p)}\\n`\n\t  )\n\t  .join('')\n\tconst pluginsCode = `const plugins: PI[] = [\n\t${plugins.map((_, i) => `  plugin${i},\\n`).join('')}]\n\ttype Plug =\n\t  | TestBase\n\t  | { t: Test }\n\t${plugins\n\t  .map((_, i) => `  | ReturnType<typeof plugin${i}>\\n`)\n", "  .join('')}\n\ttype PlugKeys =\n\t  | keyof TestBase\n\t  | 't'\n\t${plugins\n\t  .map(\n\t    (_, i) => `  | keyof ReturnType<typeof plugin${i}>\\n`\n\t  )\n\t  .join('')}`\n\tconst opts = `type SecondParam<\n", "  T extends [any] | [any, any],\n\t  Fallback extends unknown = unknown\n\t> = T extends [any, any] ? T[1] : Fallback\n\t${plugins\n\t  .map(\n\t    (_, i) => `type Plugin${i}Opts = SecondParam<\n\t  Parameters<typeof plugin${i}>,\n\t  TestBaseOpts\n\t>\\n`\n\t  )\n", "  .join('')}\n\ttype TestOpts = TestBaseOpts${plugins\n\t  .map((_, i) => `\\n  & Plugin${i}Opts`)\n\t  .join('')}\n\t`\n\tconst testInterface = `type TTest = TestBase\n\t${plugins\n\t  .map((_, i) => `  & ReturnType<typeof plugin${i}>\\n`)\n\t  .join('')}\n\t`\n", "const swapTag = (\n\t  src: string,\n\t  tag: string,\n\t  code: string\n\t): string => {\n\t  const st = '//{{' + tag + ' START}}\\n'\n\t  const et = '//{{' + tag + ' END}}\\n'\n\t  const start = src.indexOf(st)\n\t  const end = src.indexOf(et)\n\t  return (\n", "    src.substring(0, start) + code + src.substring(end + et.length)\n\t  )\n\t}\n\tconst swapTags = (\n\t  src: string,\n\t  tags: { [k: string]: string }\n\t): string => {\n\t  let res = src\n\t  for (const [tag, code] of Object.entries(tags)) {\n\t    res = swapTag(res, tag, code)\n", "  }\n\t  return res\n\t}\n\twriteFileSync(\n\t  out,\n\t  swapTags(template, {\n\t    'HEADER COMMENT': `// This file is automatically generated, please do not edit\\n`,\n\t    'PLUGIN IMPORT': pluginImport,\n\t    'PLUGINS CODE': pluginsCode,\n\t    OPTS: opts,\n", "    'TEST INTERFACE': testInterface,\n\t  })\n\t)\n\texport {}\n"]}
{"filename": "src/spawn.ts", "chunked_list": ["import { Base, BaseOpts } from './base'\n\timport ProcessInfo from '@tapjs/processinfo'\n\timport {\n\t  ChildProcess,\n\t  StdioOptions,\n\t} from 'node:child_process'\n\timport { basename } from 'node:path'\n\texport interface SpawnOpts extends BaseOpts {\n\t  cwd?: string\n\t  command?: string\n", "  args?: string[]\n\t  stdio?: StdioOptions\n\t  env?: { [k: string]: string } | typeof process.env\n\t  exitCode?: number | null\n\t  signal?: string | null\n\t}\n\texport class Spawn extends Base {\n\t  public declare options: SpawnOpts\n\t  public cwd: string\n\t  public command: string\n", "  public args: string[]\n\t  public stdio: StdioOptions\n\t  public env: { [k: string]: string } | typeof process.env\n\t  public proc: null | ChildProcess\n\t  public cb: null | (() => void)\n\t  constructor(options: SpawnOpts) {\n\t    // figure out the name before calling super()\n\t    const command = options.command\n\t    if (!command) {\n\t      throw new TypeError('no command provided')\n", "    }\n\t    options = options || {}\n\t    const cwd =\n\t      typeof options.cwd === 'string'\n\t        ? options.cwd\n\t        : process.cwd()\n\t    const args = options.args || []\n\t    options.name =\n\t      options.name || Spawn.procName(cwd, command, args)\n\t    super(options)\n", "    this.cwd = cwd\n\t    this.command = command\n\t    this.args = args\n\t    if (options.stdio) {\n\t      if (typeof options.stdio === 'string')\n\t        this.stdio = [options.stdio, 'pipe', options.stdio]\n\t      else {\n\t        this.stdio = options.stdio.slice(0) as StdioOptions\n\t      }\n\t    } else {\n", "      this.stdio = [0, 'pipe', 2]\n\t    }\n\t    // stdout MUST be a pipe so we can collect tap data\n\t    ;(this.stdio as string[])[1] = 'pipe'\n\t    const env = options.env || process.env\n\t    this.env = {\n\t      ...env,\n\t      TAP_CHILD_ID: String(\n\t        options.childId ||\n\t          env.TAP_CHILD_ID ||\n", "          /* istanbul ignore next */ '0'\n\t      ),\n\t      TAP: '1',\n\t      TAP_BAIL: this.bail ? '1' : '0',\n\t    }\n\t    this.proc = null\n\t    this.cb = null\n\t  }\n\t  endAll() {\n\t    if (this.proc) {\n", "      this.proc.kill('SIGKILL')\n\t    }\n\t    this.parser.abort('test unfinished')\n\t    this.callCb()\n\t  }\n\t  callCb() {\n\t    if (this.cb) {\n\t      this.cb()\n\t    }\n\t    this.cb = null\n", "  }\n\t  main(cb: () => void) {\n\t    this.cb = cb\n\t    this.setTimeout(this.options.timeout || 0)\n\t    this.parser.on('comment', c => {\n\t      const tomatch = c.match(/# timeout=([0-9]+)\\n$/)\n\t      if (tomatch) {\n\t        this.setTimeout(+tomatch[1])\n\t      }\n\t    })\n", "    const options = {\n\t      cwd: this.cwd,\n\t      env: this.env,\n\t      stdio: this.stdio,\n\t      externalID: this.name,\n\t    }\n\t    queueMicrotask(async () => {\n\t      this.emit('preprocess', options)\n\t      const proc = ProcessInfo.spawn(\n\t        this.command,\n", "        this.args,\n\t        options\n\t      )\n\t      /* istanbul ignore next */\n\t      if (!proc.stdout) {\n\t        return this.threw(\n\t          'failed to open child process stdout',\n\t          this.options\n\t        )\n\t      }\n", "      proc.stdout.pipe(this.parser)\n\t      proc.on('close', (code, signal) =>\n\t        this.#onprocclose(code, signal)\n\t      )\n\t      proc.on('error', er => this.threw(er))\n\t      this.emit('process', proc)\n\t      if (this.parent) {\n\t        this.parent.emit('spawn', this)\n\t      }\n\t    })\n", "  }\n\t  #onprocclose(code: number | null, signal: string | null) {\n\t    this.debug('SPAWN close %j %s', code, signal)\n\t    this.options.exitCode = code\n\t    this.options.signal = signal\n\t    // spawn closing with no tests is treated as a skip.\n\t    if (\n\t      this.results &&\n\t      this.results.plan &&\n\t      this.results.plan.skipAll &&\n", "      !code &&\n\t      !signal\n\t    ) {\n\t      this.options.skip =\n\t        this.results.plan.skipReason || true\n\t    }\n\t    if (code || signal) {\n\t      if (this.results) {\n\t        this.results.ok = false\n\t      }\n", "      this.parser.ok = false\n\t    }\n\t    return this.callCb()\n\t  }\n\t  timeout(options?: { [k: string]: any }) {\n\t    if (this.proc) {\n\t      this.proc.kill('SIGTERM')\n\t      const t = setTimeout(() => {\n\t        if (\n\t          this.proc &&\n", "          !this.options.signal &&\n\t          this.options.exitCode === undefined\n\t        ) {\n\t          super.timeout(options)\n\t          this.proc.kill('SIGKILL')\n\t        }\n\t      }, 1000)\n\t      t.unref()\n\t    }\n\t  }\n", "  static procName(\n\t    cwd: string,\n\t    command: string,\n\t    args: string[]\n\t  ) {\n\t    return (\n\t      command === process.execPath\n\t        ? basename(process.execPath) +\n\t          ' ' +\n\t          args\n", "            .map(a =>\n\t              a.indexOf(cwd) === 0\n\t                ? './' +\n\t                  a\n\t                    .substring(cwd.length + 1)\n\t                    .replace(/\\\\/g, '/')\n\t                : a\n\t            )\n\t            .join(' ')\n\t            .trim()\n", "        : command + ' ' + args.join(' ')\n\t    ).replace(/\\\\/g, '/')\n\t  }\n\t}\n"]}
{"filename": "src/test-base.ts", "chunked_list": ["// lifecycle methods like beforeEach, afterEach, teardown\n\t// defined in plugins/lifecycle.ts\n\timport Minipass from 'minipass'\n\timport assert from 'node:assert'\n\timport { hrtime } from 'node:process'\n\timport { Readable } from 'node:stream'\n\timport { format } from 'node:util'\n\timport { CallSiteLike } from 'stack-utils'\n\timport { FinalResults } from 'tap-parser'\n\timport Deferred from 'trivial-deferred'\n", "import { Base, BaseOpts } from './base.js'\n\timport { esc } from './esc.js'\n\timport stack from './stack.js'\n\timport { TestPoint } from './test-point.js'\n\timport { Waiter } from './waiter.js'\n\tconst queueEmpty = <T extends TestBase>(t: T) =>\n\t  t.queue.length === 0 ||\n\t  (t.queue.length === 1 &&\n\t    t.queue[0] === 'TAP version 14\\n')\n\texport interface ClassOf<T> {\n", "  new (): T\n\t}\n\texport type TapPlugin<\n\t  B extends Object,\n\t  O extends TestBaseOpts | any = any\n\t> = ((t: TestBase, opts: O) => B) | ((t: TestBase) => B)\n\texport interface TestBaseOpts extends BaseOpts {\n\t  /**\n\t   * The number of jobs to run in parallel. Defaults to 1\n\t   */\n", "  jobs?: number\n\t  /**\n\t   * Test function called when this Test is executed\n\t   */\n\t  cb?: (...args: any[]) => any\n\t  /**\n\t   * Flag to always/never show diagnostics.  If unset, then\n\t   * diagnostics are shown for failing test points only.\n\t   */\n\t  diagnostic?: boolean\n", "}\n\tconst normalizeMessageExtra = (\n\t  defaultMessage: string,\n\t  message?: string | { [k: string]: any },\n\t  extra?: { [k: string]: any }\n\t): [string, { [k: string]: any }] => {\n\t  if (typeof message === 'string') {\n\t    return [message || defaultMessage, extra || {}]\n\t  } else {\n\t    return [defaultMessage, message || {}]\n", "  }\n\t}\n\t/**\n\t * Sigil for implicit end() calls that should not\n\t * trigger an error if the user then calls t.end()\n\t */\n\tconst IMPLICIT = Symbol('implicit end')\n\t/**\n\t * Sigil to put in the queue to signal the end of all things\n\t */\n", "const EOF = Symbol('EOF')\n\texport type QueueEntry =\n\t  | string\n\t  | TestPoint\n\t  | Base\n\t  | typeof EOF\n\t  | Waiter\n\t  | [method: string, ...args: any[]]\n\t/**\n\t * The TestBaseBase class is the base class for all plugins,\n", " * and eventually thus the Test class.\n\t *\n\t * This implements subtest functionality, TAP stream generation,\n\t * lifecycle events, and only the most basic pass/fail assertions.\n\t *\n\t * All other features are added with plugins.\n\t */\n\texport class TestBase extends Base {\n\t  // NB: generated pluginified Test class needs to declare over this\n\t  declare parent?: TestBase\n", "  promise?: Promise<any>\n\t  jobs: number\n\t  // #beforeEnd: [method: string | Symbol, ...args: any[]][] = []\n\t  subtests: Base[] = []\n\t  pool: Set<Base> = new Set()\n\t  queue: QueueEntry[] = ['TAP version 14\\n']\n\t  cb?: (...args: any[]) => any\n\t  count: number = 0\n\t  ended: boolean = false\n\t  assertAt: CallSiteLike | null = null\n", "  assertStack: string | null = null\n\t  diagnostic: null | boolean = null\n\t  #planEnd: number = -1\n\t  #printedResult: boolean = false\n\t  #explicitEnded: boolean = false\n\t  #multiEndThrew: boolean = false\n\t  #n: number = 0\n\t  #noparallel: boolean = false\n\t  #occupied: null | Waiter | Base = null\n\t  #pushedEnd: boolean = false\n", "  #nextChildId: number = 1\n\t  #currentAssert: null | ((..._: any) => any) = null\n\t  #processing: boolean = false\n\t  #doingStdinOnly: boolean = false\n\t  /**\n\t   * true if the test has printed at least one TestPoint\n\t   */\n\t  get printedResult(): boolean {\n\t    return this.#printedResult\n\t  }\n", "  constructor(options: TestBaseOpts) {\n\t    super(options)\n\t    this.jobs =\n\t      (options.jobs && Math.max(options.jobs, 1)) || 1\n\t    if (typeof options.diagnostic === 'boolean') {\n\t      this.diagnostic = options.diagnostic\n\t    }\n\t    if (options.cb) {\n\t      this.#setCB(options.cb)\n\t    }\n", "  }\n\t  #setCB<T extends TestBase>(this: T, cb: (t: T) => any) {\n\t    this.cb = (...args: any[]) =>\n\t      this.hook.runInAsyncScope(cb, this, ...args)\n\t  }\n\t  // TAP output generating methods\n\t  /**\n\t   * immediately exit this and all parent tests with a TAP\n\t   * Bail out! message.\n\t   */\n", "  bailout(message?: string) {\n\t    if (this.parent && (this.results || this.ended)) {\n\t      this.parent.bailout(message)\n\t    } else {\n\t      this.#process()\n\t      message = message\n\t        ? ' ' + ('' + esc(message)).trim()\n\t        : ''\n\t      message = message.replace(/[\\r\\n]/g, ' ')\n\t      this.parser.write('Bail out!' + message + '\\n')\n", "    }\n\t    this.#end(IMPLICIT)\n\t    this.#process()\n\t  }\n\t  /**\n\t   * output a TAP comment, formatted like console.log()\n\t   */\n\t  comment(...args: any[]) {\n\t    const body = format(...args)\n\t    const message =\n", "      ('# ' + body.split(/\\r?\\n/).join('\\n# ')).trim() +\n\t      '\\n'\n\t    if (this.results) {\n\t      this.write(message)\n\t    } else {\n\t      this.queue.push(message)\n\t    }\n\t    this.#process()\n\t  }\n\t  /**\n", "   * Called when the test times out.\n\t   * Options are passed as diagnostics to the threw() method\n\t   */\n\t  timeout(options: { [k: string]: any }) {\n\t    options = options || {}\n\t    options.expired = options.expired || this.name\n\t    if (this.#occupied && this.#occupied instanceof Base) {\n\t      this.#occupied.timeout(options)\n\t    } else {\n\t      super.timeout(options)\n", "    }\n\t    this.#end(IMPLICIT)\n\t  }\n\t  /**\n\t   * Set TAP pragma configs to affect the behavior of the parser.\n\t   * Only `strict` is supported by the parser.\n\t   */\n\t  pragma(set: { [k: string]: boolean }) {\n\t    const p = Object.keys(set).reduce(\n\t      (acc, i) =>\n", "        acc + 'pragma ' + (set[i] ? '+' : '-') + i + '\\n',\n\t      ''\n\t    )\n\t    this.queue.push(p)\n\t    this.#process()\n\t  }\n\t  /**\n\t   * Specify the number of Test Points expected by this test.\n\t   * Outputs a TAP plan line.\n\t   */\n", "  plan(n: number, comment?: string) {\n\t    if (this.bailedOut) {\n\t      return\n\t    }\n\t    if (this.#planEnd !== -1) {\n\t      throw new Error('Cannot set plan more than once')\n\t    }\n\t    if (typeof n !== 'number' || n < 0) {\n\t      throw new TypeError('plan must be a number')\n\t    }\n", "    // Cannot get any tests after a trailing plan, or a plan of 0\n\t    const ending = this.count !== 0 || n === 0\n\t    if (n === 0 && comment && !this.options.skip) {\n\t      this.options.skip = comment\n\t    }\n\t    this.#planEnd = n\n\t    comment = comment ? ' # ' + esc(comment.trim()) : ''\n\t    this.queue.push('1..' + n + comment + '\\n')\n\t    if (ending) {\n\t      this.#end(IMPLICIT)\n", "    } else {\n\t      this.#process()\n\t    }\n\t  }\n\t  /**\n\t   * A passing (ok) Test Point\n\t   */\n\t  pass(message?: string, extra?: { [k: string]: any }) {\n\t    this.currentAssert = TestBase.prototype.pass\n\t    this.printResult(\n", "      true,\n\t      ...normalizeMessageExtra(\n\t        '(unnamed test)',\n\t        message,\n\t        extra\n\t      )\n\t    )\n\t    return true\n\t  }\n\t  /**\n", "   * A failing (not ok) Test Point\n\t   */\n\t  fail(message?: string, extra?: { [k: string]: any }) {\n\t    this.currentAssert = TestBase.prototype.fail\n\t    const [m, e] = normalizeMessageExtra(\n\t      '(unnamed test)',\n\t      message,\n\t      extra\n\t    )\n\t    this.printResult(false, m, e)\n", "    return !!(e.todo || e.skip)\n\t  }\n\t  /**\n\t   * The current assertion being processed.  May only be set if\n\t   * not already set.\n\t   */\n\t  get currentAssert() {\n\t    return this.#currentAssert\n\t  }\n\t  /**\n", "   * The current assertion being processed.  May only be set if\n\t   * not already set.\n\t   */\n\t  set currentAssert(fn: null | ((...a: any[]) => any)) {\n\t    if (!this.#currentAssert && typeof fn === 'function') {\n\t      this.#currentAssert = fn\n\t    }\n\t  }\n\t  /**\n\t   * Print a Test Point\n", "   */\n\t  printResult(\n\t    ok: boolean,\n\t    message: string,\n\t    extra: { [k: string]: any },\n\t    front: boolean = false\n\t  ) {\n\t    this.#printedResult = true\n\t    const n = this.count + 1\n\t    this.currentAssert = TestBase.prototype.printResult\n", "    const fn = this.#currentAssert\n\t    this.#currentAssert = null\n\t    if (this.#planEnd !== -1 && n > this.#planEnd) {\n\t      if (!this.passing()) return\n\t      const failMessage = this.#explicitEnded\n\t        ? 'test after end() was called'\n\t        : 'test count exceeds plan'\n\t      const er = new Error(failMessage, {\n\t        cause: {\n\t          test: this.name,\n", "          plan: this.#planEnd,\n\t        },\n\t      })\n\t      Error.captureStackTrace(er, fn || undefined)\n\t      this.threw(er)\n\t      return\n\t    }\n\t    extra = extra || {}\n\t    if (extra.expectFail) {\n\t      ok = !ok\n", "    }\n\t    if (this.assertAt) {\n\t      extra.at = this.assertAt\n\t      this.assertAt = null\n\t    }\n\t    if (this.assertStack) {\n\t      extra.stack = this.assertStack\n\t      this.assertStack = null\n\t    }\n\t    if (typeof extra.stack === 'string' && !extra.at) {\n", "      extra.at = stack.parseLine(extra.stack.split('\\n')[0])\n\t    }\n\t    if (\n\t      !ok &&\n\t      !extra.skip &&\n\t      !extra.at &&\n\t      typeof fn === 'function'\n\t    ) {\n\t      extra.at = stack.at(fn)\n\t      if (!extra.todo) {\n", "        extra.stack = stack.captureString(80, fn)\n\t      }\n\t    }\n\t    const diagnostic =\n\t      typeof extra.diagnostic === 'boolean'\n\t        ? extra.diagnostic\n\t        : typeof this.diagnostic === 'boolean'\n\t        ? this.diagnostic\n\t        : extra.skip || extra.todo\n\t        ? false\n", "        : !ok\n\t    if (diagnostic) {\n\t      extra.diagnostic = true\n\t    }\n\t    this.count = n\n\t    message = message + ''\n\t    const res = { ok, message, extra }\n\t    const tp = new TestPoint(ok, message, extra)\n\t    // when we jump the queue, skip an extra line\n\t    if (front) {\n", "      tp.message = tp.message.trimEnd() + '\\n\\n'\n\t    }\n\t    if (\n\t      this.#occupied &&\n\t      this.#occupied instanceof Waiter &&\n\t      this.#occupied.finishing\n\t    ) {\n\t      front = true\n\t    }\n\t    if (front) {\n", "      if (\n\t        extra.tapChildBuffer ||\n\t        extra.tapChildBuffer === ''\n\t      ) {\n\t        this.writeSubComment(tp)\n\t        this.parser.write(extra.tapChildBuffer)\n\t      }\n\t      this.emit('result', res)\n\t      this.parser.write(tp.ok + ++this.#n + tp.message)\n\t      if (this.bail && !ok && !extra.skip && !extra.todo) {\n", "        this.parser.write('Bail out! ' + message + '\\n')\n\t      }\n\t    } else {\n\t      this.queue.push(tp)\n\t      if (this.bail && !ok && !extra.skip && !extra.todo) {\n\t        this.queue.push('Bail out! ' + message + '\\n')\n\t      }\n\t    }\n\t    if (this.#planEnd === this.count) {\n\t      this.#end(IMPLICIT)\n", "    }\n\t    this.#process()\n\t  }\n\t  end(): this {\n\t    this.#end()\n\t    return super.end()\n\t  }\n\t  /**\n\t   * The leading `# Subtest` comment that introduces a child test\n\t   */\n", "  writeSubComment<T extends TestPoint | Base>(p: T) {\n\t    const comment =\n\t      '# Subtest' +\n\t      (p.name ? ': ' + esc(p.name) : '') +\n\t      '\\n'\n\t    this.parser.write(comment)\n\t  }\n\t  // end TAP otput generating methods\n\t  // flow control methods\n\t  /**\n", "   * Await the end of a Promise before proceeding.\n\t   * The supplied callback is called with the Waiter object.\n\t   */\n\t  waitOn(\n\t    promise: Promise<any | void>,\n\t    cb: (w: Waiter) => any,\n\t    expectReject: boolean = false\n\t  ): Promise<void> {\n\t    const w = new Waiter(\n\t      promise,\n", "      w => {\n\t        assert.equal(this.#occupied, w)\n\t        cb(w)\n\t        this.#occupied = null\n\t        this.#process()\n\t      },\n\t      expectReject\n\t    )\n\t    this.queue.push(w)\n\t    this.#process()\n", "    return w.promise\n\t  }\n\t  #end(implicit?: typeof IMPLICIT) {\n\t    if (this.#doingStdinOnly && implicit !== IMPLICIT)\n\t      throw new Error(\n\t        'cannot explicitly end while in stdinOnly mode'\n\t      )\n\t    this.debug('END implicit=%j', implicit === IMPLICIT)\n\t    if (this.ended && implicit === IMPLICIT) return\n\t    // beyond here we have to be actually done with things, or else\n", "    // the semantic checks on counts and such will be off.\n\t    if (!queueEmpty(this) || this.#occupied) {\n\t      if (!this.#pushedEnd) {\n\t        this.queue.push(['#end', implicit])\n\t      }\n\t      this.#pushedEnd = true\n\t      return this.#process()\n\t    }\n\t    this.ended = true\n\t    if (implicit !== IMPLICIT && !this.#multiEndThrew) {\n", "      if (this.#explicitEnded) {\n\t        this.#multiEndThrew = true\n\t        const er = new Error(\n\t          'test end() method called more than once'\n\t        )\n\t        Error.captureStackTrace(\n\t          er,\n\t          this.#currentAssert || this.#end\n\t        )\n\t        er.cause = {\n", "          test: this.name,\n\t        }\n\t        this.threw(er)\n\t        return\n\t      }\n\t      this.#explicitEnded = true\n\t    }\n\t    if (this.#planEnd === -1) {\n\t      this.debug(\n\t        'END(%s) implicit plan',\n", "        this.name,\n\t        this.count\n\t      )\n\t      this.plan(this.count)\n\t    }\n\t    this.queue.push(EOF)\n\t    this.#process()\n\t  }\n\t  #process() {\n\t    if (this.#processing) {\n", "      return this.debug(' < already processing')\n\t    }\n\t    this.debug(\n\t      '\\nPROCESSING(%s)',\n\t      this.name,\n\t      this.queue.length\n\t    )\n\t    this.#processing = true\n\t    while (!this.#occupied) {\n\t      const p = this.queue.shift()\n", "      if (!p) {\n\t        this.debug('> end of queue')\n\t        break\n\t      }\n\t      if (p instanceof Base) {\n\t        this.debug('> subtest in queue', p.name)\n\t        this.#processSubtest(p)\n\t      } else if (p === EOF) {\n\t        this.debug(' > EOF', this.name)\n\t        // I AM BECOME EOF, DESTROYER OF STREAMS\n", "        this.parser.end()\n\t      } else if (p instanceof TestPoint) {\n\t        this.debug(' > TESTPOINT')\n\t        if (\n\t          p.extra.tapChildBuffer ||\n\t          p.extra.tapChildBuffer === ''\n\t        ) {\n\t          this.writeSubComment(p)\n\t          this.parser.write(p.extra.tapChildBuffer)\n\t        }\n", "        this.emit('res', p.res)\n\t        this.parser.write(p.ok + ++this.#n + p.message)\n\t      } else if (typeof p === 'string') {\n\t        this.debug(' > STRING')\n\t        this.parser.write(p)\n\t      } else if (p instanceof Waiter) {\n\t        p.ready = true\n\t        this.#occupied = p\n\t        p.finish()\n\t      } else if (Array.isArray(p)) {\n", "        this.debug(' > METHOD')\n\t        const m = p.shift() as keyof this\n\t        if (typeof this[m] !== 'function') {\n\t          this.debug(\n\t            ' > weird method not found in queue??',\n\t            m,\n\t            typeof this[m]\n\t          )\n\t          continue\n\t        }\n", "        const fn = (m === '#end' ? this.#end : this[m]) as (\n\t          ...a: any[]\n\t        ) => any\n\t        const ret = fn.call(this, ...p)\n\t        if (\n\t          ret &&\n\t          typeof ret === 'object' &&\n\t          typeof ret.then === 'function'\n\t        ) {\n\t          // returned promise\n", "          ret.then(\n\t            () => {\n\t              this.#processing = false\n\t              this.#process()\n\t            },\n\t            (er: unknown) => {\n\t              this.#processing = false\n\t              this.threw(er)\n\t            }\n\t          )\n", "          return\n\t        }\n\t        /* c8 ignore start */\n\t      } else {\n\t        throw new Error('weird thing got in the queue')\n\t      }\n\t      /* c8 ignore stop */\n\t    }\n\t    while (\n\t      !this.#noparallel &&\n", "      this.pool.size < this.jobs\n\t    ) {\n\t      const p = this.subtests.shift()\n\t      if (!p) {\n\t        break\n\t      }\n\t      if (!p.buffered) {\n\t        this.#noparallel = true\n\t        break\n\t      }\n", "      this.debug('start subtest', p)\n\t      this.emit('subtestStart', p)\n\t      this.pool.add(p)\n\t      if (this.bailedOut) {\n\t        this.#onBufferedEnd(p)\n\t      } else {\n\t        p.runMain(() => this.#onBufferedEnd(p))\n\t      }\n\t    }\n\t    this.debug(\n", "      'done processing',\n\t      this.queue,\n\t      this.#occupied\n\t    )\n\t    this.#processing = false\n\t    // just in case any tests ended, and we have sync stuff still\n\t    // waiting around in the queue to be processed\n\t    if (!this.#occupied && this.queue.length) {\n\t      this.#process()\n\t    }\n", "  }\n\t  #onBufferedEnd<T extends Base>(p: T) {\n\t    p.ondone = p.constructor.prototype.ondone\n\t    p.results =\n\t      p.results || new FinalResults(true, p.parser)\n\t    p.readyToProcess = true\n\t    const to = p.options.timeout\n\t    const dur =\n\t      to && p.passing() ? hrtime.bigint() - p.start : null\n\t    if (dur && to && dur > to) {\n", "      p.timeout()\n\t    } else {\n\t      p.setTimeout(0)\n\t    }\n\t    this.debug(\n\t      '%s.#onBufferedEnd',\n\t      this.name,\n\t      p.name,\n\t      p.results.bailout\n\t    )\n", "    this.pool.delete(p)\n\t    p.options.tapChildBuffer = p.output || ''\n\t    p.options.stack = ''\n\t    if (p.time) p.options.time = p.time\n\t    if (this.#occupied === p) this.#occupied = null\n\t    p.deferred?.resolve(p.results)\n\t    this.emit('subtestEnd', p)\n\t    this.#process()\n\t  }\n\t  #onIndentedEnd<T extends Base>(p: T) {\n", "    this.emit('subtestProcess', p)\n\t    p.ondone = p.constructor.prototype.ondone\n\t    p.results =\n\t      p.results || new FinalResults(true, p.parser)\n\t    this.debug('#onIndentedEnd', this.name, p.name)\n\t    this.#noparallel = false\n\t    const sti = this.subtests.indexOf(p)\n\t    if (sti !== -1) this.subtests.splice(sti, 1)\n\t    p.readyToProcess = true\n\t    p.options.time = p.time\n", "    const to = p.options.timeout\n\t    const dur =\n\t      to && p.passing() ? hrtime.bigint() - p.start : null\n\t    if (dur && to && dur > to) {\n\t      p.timeout()\n\t    } else {\n\t      p.setTimeout(0)\n\t    }\n\t    this.debug('#onIndentedEnd %s(%s)', this.name, p.name)\n\t    this.#occupied = null\n", "    this.debug(\n\t      'OIE(%s) b>shift into queue',\n\t      this.name,\n\t      this.queue\n\t    )\n\t    p.options.stack = ''\n\t    this.printResult(p.passing(), p.name, p.options, true)\n\t    this.debug(\n\t      'OIE(%s) shifted into queue',\n\t      this.name,\n", "      this.queue\n\t    )\n\t    p.deferred?.resolve(p.results)\n\t    this.emit('subtestEnd', p)\n\t    this.#process()\n\t  }\n\t  /**\n\t   * @internal\n\t   */\n\t  main(cb: () => void) {\n", "    if (typeof this.options.timeout === 'number') {\n\t      this.setTimeout(this.options.timeout)\n\t    }\n\t    this.debug('MAIN pre', this)\n\t    const end = () => {\n\t      this.debug(' > implicit end for promise')\n\t      this.#end(IMPLICIT)\n\t      done()\n\t    }\n\t    const done = (er?: Error) => {\n", "      if (er) this.threw(er)\n\t      if (this.results || this.bailedOut) cb()\n\t      else this.ondone = () => cb()\n\t    }\n\t    // This bit of overly clever line-noise wraps the call to user-code\n\t    // in a try-catch. We can't rely on the domain for this yet, because\n\t    // the 'end' event can trigger a throw after the domain is unhooked,\n\t    // but before this is no longer the official \"active test\"\n\t    const ret = (() => {\n\t      if (!this.cb) return\n", "      try {\n\t        return this.cb(this)\n\t      } catch (er: any) {\n\t        if (!er || typeof er !== 'object') {\n\t          er = { error: er }\n\t        }\n\t        er.tapCaught = 'testFunctionThrow'\n\t        this.threw(er)\n\t      }\n\t    })()\n", "    if (ret && ret.then) {\n\t      this.promise = ret\n\t      ret.tapAbortPromise = done\n\t      ret.then(end, (er: any) => {\n\t        if (!er || typeof er !== 'object') {\n\t          er = { error: er }\n\t        }\n\t        er.tapCaught = 'returnedPromiseRejection'\n\t        done(er)\n\t      })\n", "    } else done()\n\t    this.debug('MAIN post', this)\n\t  }\n\t  #processSubtest<T extends Base>(p: T) {\n\t    this.debug(' > subtest')\n\t    this.#occupied = p\n\t    if (!p.buffered) {\n\t      this.emit('subtestStart', p)\n\t      this.debug(' > subtest indented')\n\t      p.stream.pipe(this.parser, { end: false })\n", "      this.writeSubComment(p)\n\t      this.debug('calling runMain', p.runMain.toString())\n\t      p.runMain(() => {\n\t        this.debug('in runMain', p.runMain.toString())\n\t        this.#onIndentedEnd(p)\n\t      })\n\t    } else if (p.readyToProcess) {\n\t      this.emit('subtestProcess', p)\n\t      this.debug(' > subtest buffered, finished')\n\t      // finished!  do the thing!\n", "      this.#occupied = null\n\t      if (!p.passing() || !p.silent) {\n\t        this.printResult(\n\t          p.passing(),\n\t          p.name,\n\t          p.options,\n\t          true\n\t        )\n\t      }\n\t    } else {\n", "      this.#occupied = p\n\t      this.debug(' > subtest buffered, unfinished', p)\n\t      // unfinished buffered test.\n\t      // nothing to do yet, just leave it there.\n\t      this.queue.unshift(p)\n\t    }\n\t  }\n\t  /**\n\t   * Parse stdin as the only tap stream (ie, not as a child test)\n\t   * If used, then no other subtests or assertions are allowed.\n", "   */\n\t  stdinOnly<T extends BaseOpts>(\n\t    extra?: T & { tapStream?: Readable | Minipass }\n\t  ) {\n\t    const stream = ((extra && extra.tapStream) ||\n\t      process.stdin) as Minipass\n\t    if (!stream) {\n\t      throw new Error(\n\t        'cannot read stdin without stdin stream'\n\t      )\n", "    }\n\t    if (\n\t      this.queue.length !== 1 ||\n\t      this.queue[0] !== 'TAP version 14\\n' ||\n\t      this.#processing ||\n\t      this.results ||\n\t      this.#occupied ||\n\t      this.pool.size ||\n\t      this.subtests.length\n\t    ) {\n", "      throw new Error(\n\t        'Cannot use stdinOnly on a test in progress'\n\t      )\n\t    }\n\t    this.#doingStdinOnly = true\n\t    this.queue.length = 0\n\t    this.parser.on('child', p => {\n\t      // pretend to be a rooted parser, so it gets counts.\n\t      p.root = p\n\t      const t = new Base({\n", "        name: p.name,\n\t        parent: this,\n\t        parser: p,\n\t        bail: p.bail,\n\t        strict: p.strict,\n\t        omitVersion: p.omitVersion,\n\t        preserveWhitespace: p.preserveWhitespace,\n\t        childId: this.#nextChildId++,\n\t      })\n\t      this.emit('subtestAdd', t)\n", "      this.emit('subtestStart', t)\n\t      this.emit('subtestProcess', t)\n\t      p.on('complete', () => {\n\t        t.time = p.time\n\t        this.emit('subtestEnd', t)\n\t      })\n\t    })\n\t    stream.pause()\n\t    stream.pipe(this.parser)\n\t    stream.resume()\n", "  }\n\t  /**\n\t   * Mount a subtest, using this Test object as a harness.\n\t   * Exposed mainly so that it can be used by builtin plugins.\n\t   *\n\t   * @internal\n\t   */\n\t  sub<T extends Base, O extends TestBaseOpts>(\n\t    Class: { new (options: O): T },\n\t    extra: O,\n", "    caller: (...a: any[]) => unknown\n\t  ): Promise<FinalResults | null> {\n\t    if (this.bailedOut) return Promise.resolve(null)\n\t    if (this.results || this.ended) {\n\t      const er = new Error(\n\t        'cannot create subtest after parent test ends'\n\t      )\n\t      Error.captureStackTrace(er, caller)\n\t      this.threw(er)\n\t      return Promise.resolve(null)\n", "    }\n\t    extra.childId = this.#nextChildId++\n\t    if (this.shouldSkipChild(extra)) {\n\t      this.pass(extra.name, extra)\n\t      return Promise.resolve(null)\n\t    }\n\t    extra.indent = '    '\n\t    if (extra.buffered !== undefined) {\n\t      if (this.jobs > 1) {\n\t        extra.buffered = true\n", "      } else {\n\t        extra.buffered = false\n\t      }\n\t    }\n\t    extra.bail =\n\t      extra.bail !== undefined ? extra.bail : this.bail\n\t    extra.parent = this\n\t    extra.stack = stack.captureString(80, caller)\n\t    extra.context = this.context\n\t    const t = new Class(extra)\n", "    this.queue.push(t)\n\t    this.subtests.push(t)\n\t    this.emit('subtestAdd', t)\n\t    const d = new Deferred<FinalResults>()\n\t    t.deferred = d\n\t    this.#process()\n\t    return d.promise\n\t  }\n\t  /**\n\t   * Return true if the child test represented by the options object\n", "   * should be skipped.  Extended by the grep/only filtering plugins.\n\t   */\n\t  shouldSkipChild(extra: { [k: string]: any }) {\n\t    return !!(extra.skip || extra.todo)\n\t  }\n\t  // end flow control methods\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './test-base.js'\n\texport * from './test.js'\n\texport * from './spawn.js'\n\texport * from './stdin.js'\n\texport * from './base.js'\n"]}
{"filename": "src/generate.ts", "chunked_list": ["#!/usr/bin/env node --require=ts-node/register\n\timport { readFileSync, writeFileSync, mkdirSync, rmSync } from 'node:fs'\n\timport { resolve } from 'node:path'\n\tconst dir = resolve(__dirname, '../node_modules/.tapjs/core')\n\tconst f = resolve(dir, 'index.ts')\n\tconst tsconfig = resolve('../tsconfig.json')\n\tconst tsNodeReg = require.resolve('ts-node/register')\n\t// get the \n\tconst plugins = [...new Set(readFileSync('plugins.txt', 'utf8')\n\t  .trim()\n", "  .split('\\n'))]\n\tconst imports: string[] = [\n\t  '// generated, do not edit',\n\t  '',\n\t  `import { PluginHost } from './plugin-host'`,\n\t  '',\n\t]\n\tconst inst: string[] = [`export const Host =`]\n\tplugins.forEach((p, i) => {\n\t  imports.push(\n", "    `import { plugin as Plugin${i} } from ${JSON.stringify(\n\t      p\n\t    )}`\n\t  )\n\t  inst.push(`Plugin${i}(`)\n\t})\n\tinst.push(`PluginHost`, ')'.repeat(plugins.length))\n\twriteFileSync(\n\t  'host.ts',\n\t  `${imports.join('\\n')}\n", "${inst.join('\\n')}\n\t`\n\t)\n"]}
{"filename": "src/test-point.ts", "chunked_list": ["import { diags } from './diags.js'\n\timport { esc } from './esc.js'\n\timport { TestBaseOpts } from './test-base.js'\n\texport interface Result {\n\t  ok: boolean\n\t  message: string\n\t  extra: { [k: string]: any }\n\t}\n\texport class TestPoint {\n\t  ok: 'ok ' | 'not ok '\n", "  name: string\n\t  message: string\n\t  extra: { [key: string]: any }\n\t  res: Result\n\t  constructor(\n\t    ok: boolean,\n\t    message: string,\n\t    extra?: { [key: string]: any }\n\t  ) {\n\t    this.ok = ok ? 'ok ' : 'not ok '\n", "    extra = extra || {}\n\t    message = message\n\t      .trim()\n\t      .replace(/[\\n\\r]/g, ' ')\n\t      .replace(/\\t/g, '  ')\n\t    this.res = { ok, message, extra }\n\t    this.extra = extra\n\t    this.name = message\n\t    this.message = tpMessage(esc(this.name), extra)\n\t  }\n", "}\n\tconst tpMessage = (\n\t  description: string,\n\t  extra: { [k: string]: any },\n\t  options: TestBaseOpts = {}\n\t): string => {\n\t  let message = description ? ` - ${description}` : ''\n\t  if (extra.skip) {\n\t    message += ' # SKIP'\n\t    if (typeof extra.skip === 'string') {\n", "      message += ' ' + esc(extra.skip)\n\t    }\n\t  } else if (extra.todo) {\n\t    message += ' # TODO'\n\t    if (typeof extra.todo === 'string') {\n\t      message += ' ' + esc(extra.todo)\n\t    }\n\t  } else if (extra.time) {\n\t    message += ' # time=' + extra.time + 'ms'\n\t  }\n", "  const diagYaml = extra.diagnostic\n\t    ? diags(extra, options)\n\t    : ''\n\t  message += diagYaml + '\\n'\n\t  return message\n\t}\n"]}
{"filename": "src/tap-dir-cjs.ts", "chunked_list": ["// this form only works in the cjs.\n\t// it'll overwrite tap-dir.js output in cjs mode\n\timport { dirname } from 'path'\n\t//@ts-ignore\n\texport const tapDir = dirname(__dirname)\n"]}
{"filename": "src/stdin.ts", "chunked_list": ["import Minipass from 'minipass'\n\timport { Base, BaseOpts } from './base'\n\texport interface StdinOpts extends BaseOpts {\n\t  tapStream?: NodeJS.ReadableStream | Minipass\n\t}\n\texport class Stdin extends Base {\n\t  inputStream: NodeJS.ReadableStream | Minipass<string | Buffer>\n\t  constructor(options: StdinOpts) {\n\t    super({\n\t      ...options,\n", "      name: options.name || '/dev/stdin',\n\t    })\n\t    this.inputStream = options.tapStream || process.stdin\n\t    this.inputStream.pause()\n\t  }\n\t  main(cb: () => void) {\n\t    this.inputStream.on('error', er => {\n\t      er.tapCaught = 'stdinError'\n\t      this.threw(er)\n\t    })\n", "    if (this.options.timeout) {\n\t      this.setTimeout(this.options.timeout)\n\t    }\n\t    const s = this.inputStream as Minipass\n\t    s.pipe(this.parser)\n\t    if (this.parent) {\n\t      this.parent.emit('stdin', this)\n\t    }\n\t    this.inputStream.resume()\n\t    this.once('end', cb)\n", "  }\n\t  threw(er: any, extra?: any, proxy?: boolean) {\n\t    extra = super.threw(er, extra, proxy)\n\t    Object.assign(this.options, extra)\n\t    this.parser.abort(er.message, extra)\n\t    this.parser.end()\n\t  }\n\t}\n"]}
{"filename": "src/tap-dir.ts", "chunked_list": ["// this form only works in the mjs.\n\t// it'll be overwritten by the tap-dir-cjs.js output in cjs mode\n\timport { dirname } from 'path'\n\timport {fileURLToPath} from 'url'\n\t//@ts-ignore\n\texport const tapDir = dirname(dirname(fileURLToPath(import.meta.url)))\n"]}
{"filename": "src/extra-from-error.ts", "chunked_list": ["import stack from './stack'\n\timport type {BaseOpts} from './base'\n\texport default (er:any, extra?:{[k: string]:any}, options?:BaseOpts) => {\n\t  // the yaml module puts big stuff here, pluck it off\n\t  if (er.source && typeof er.source === 'object' && er.source.context)\n\t    er.source = { ...er.source, context: null }\n\t  // pull out all fields from options, other than anything starting\n\t  // with tapChild, or anything already set in the extra object.\n\t  extra = Object.fromEntries(Object.entries(options || {}).filter(([k]) =>\n\t    !/^tapChild/.test(k) && !(k in (extra || {}))))\n", "  if (!er || typeof er !== 'object') {\n\t    extra.error = er\n\t    return extra\n\t  }\n\t  // pull out error details\n\t  const message = er.message ? er.message\n\t    : er.stack ? er.stack.split('\\n')[0]\n\t    : ''\n\t  if (er.message) {\n\t    try {\n", "      Object.defineProperty(er, 'message', {\n\t        value: '',\n\t        configurable: true\n\t      })\n\t    } catch {}\n\t  }\n\t  const st = er.stack && er.stack.substr(\n\t    er._babel ? (message + er.codeFrame).length : 0)\n\t  if (st) {\n\t    const splitst = st.split('\\n')\n", "    if (er._babel && er.loc) {\n\t      const msplit = message.split(': ')\n\t      const f = msplit[0].trim()\n\t      extra.message = msplit.slice(1).join(': ')\n\t        .replace(/ \\([0-9]+:[0-9]+\\)$/, '').trim()\n\t      const file = f.indexOf(process.cwd()) === 0\n\t        ? f.substr(process.cwd().length + 1) : f\n\t      if (file !== 'unknown')\n\t        delete er.codeFrame\n\t      extra.at = {\n", "        file,\n\t        line: er.loc.line,\n\t        column: er.loc.column + 1,\n\t      }\n\t    } else {\n\t      // parse out the 'at' bit from the first line.\n\t      extra.at = stack.parseLine(splitst[1])\n\t    }\n\t    extra.stack = stack.clean(splitst)\n\t  }\n", "  if (message) {\n\t    try {\n\t      Object.defineProperty(er, 'message', {\n\t        value: message,\n\t        configurable: true\n\t      })\n\t    } catch {}\n\t  }\n\t  if (er.name && er.name !== 'Error') {\n\t    extra.type = er.name\n", "  }\n\t  Object.assign(extra, Object.fromEntries(Object.entries(er).filter(([k]) =>\n\t    k !== 'message')))\n\t  return extra\n\t}\n"]}
{"filename": "src/waiter.ts", "chunked_list": ["export class Waiter {\n\t  cb: null | ((w:Waiter)=>any)\n\t  ready: boolean = false\n\t  value: any = null\n\t  resolved: boolean = false\n\t  rejected: boolean = false\n\t  done: boolean = false\n\t  finishing: boolean = false\n\t  expectReject: boolean\n\t  promise: Promise<void>\n", "  resolve: null | ((value?:any)=>void) = null\n\t  constructor (promise: Promise<any|void>, cb:(w:Waiter)=>any, expectReject:boolean = false) {\n\t    this.cb = cb\n\t    this.expectReject = !!expectReject\n\t    this.promise = new Promise<void>(res => this.resolve = res)\n\t    promise.then(value => {\n\t      if (this.done) {\n\t        return\n\t      }\n\t      this.resolved = true\n", "      this.value = value\n\t      this.done = true\n\t      this.finish()\n\t    }).catch(er => this.reject(er))\n\t  }\n\t  reject (er:any) {\n\t    if (this.done) {\n\t      return\n\t    }\n\t    this.value = er\n", "    this.rejected = true\n\t    this.done = true\n\t    this.finish()\n\t  }\n\t  abort (er:Error) {\n\t    if (this.done) {\n\t      return\n\t    }\n\t    this.ready = true\n\t    this.finishing = false\n", "    this.done = true\n\t    this.value = er\n\t    // make it clear that this is a problem by doing\n\t    // the opposite of what was requested.\n\t    this.rejected = !this.expectReject\n\t    return this.finish()\n\t  }\n\t  finish () {\n\t    if (this.ready && this.done && !this.finishing) {\n\t      this.finishing = true\n", "      this.cb && this.cb(this)\n\t      this.resolve && this.resolve()\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/plugin/spawn.ts", "chunked_list": ["import { StdioOptions } from 'child_process'\n\timport { FinalResults } from 'tap-parser'\n\timport { BaseOpts } from '../base.js'\n\timport { Spawn } from '../spawn.js'\n\timport { TapPlugin, TestBase } from '../test-base.js'\n\texport interface SpawnOpts extends BaseOpts {\n\t  cwd?: string\n\t  command?: string\n\t  args?: string[]\n\t  stdio?: StdioOptions\n", "  env?: { [k: string]: string } | typeof process.env\n\t  exitCode?: number | null\n\t  signal?: string | null\n\t}\n\tclass SpawnPlugin {\n\t  #t: TestBase\n\t  constructor(t: TestBase) {\n\t    this.#t = t\n\t  }\n\t  spawn(cmd: string): Promise<FinalResults | null>\n", "  spawn(\n\t    cmd: string,\n\t    options: SpawnOpts,\n\t    name?: string\n\t  ): Promise<FinalResults | null>\n\t  spawn(\n\t    cmd: string,\n\t    args: string | string[],\n\t    name?: string\n\t  ): Promise<FinalResults | null>\n", "  spawn(\n\t    cmd: string,\n\t    args: string | string[],\n\t    options: SpawnOpts,\n\t    name?: string\n\t  ): Promise<FinalResults | null>\n\t  spawn(\n\t    cmd: string,\n\t    args?: string | string[] | SpawnOpts,\n\t    options?: SpawnOpts | string,\n", "    name?: string\n\t  ): Promise<FinalResults | null> {\n\t    if (typeof args === 'string') {\n\t      args = [args]\n\t    }\n\t    if (typeof options === 'string') {\n\t      name = options\n\t      options = {}\n\t    }\n\t    if (typeof args === 'object' && !Array.isArray(args)) {\n", "      options = args\n\t      args = []\n\t    }\n\t    options = options || {}\n\t    if (options.name === undefined) {\n\t      options.name = name\n\t    }\n\t    options.command = cmd\n\t    options.args = args\n\t    return this.#t.sub(Spawn, options, this.spawn)\n", "  }\n\t}\n\tconst plugin: TapPlugin<SpawnPlugin> = (t: TestBase) =>\n\t  new SpawnPlugin(t)\n\texport default plugin\n"]}
{"filename": "src/plugin/after-each.ts", "chunked_list": ["import loop from 'function-loop'\n\timport { TapPlugin, TestBase } from '../test-base.js'\n\timport type { Test } from '../test-built.js'\n\tclass AfterEach {\n\t  static #refs = new Map<TestBase, AfterEach>()\n\t  #t: TestBase\n\t  constructor(t: TestBase) {\n\t    this.#t = t\n\t    AfterEach.#refs.set(t, this)\n\t    const runMain = t.runMain\n", "    t.runMain = (cb: () => void) => {\n\t      runMain.call(t, () => this.#runAfterEach(this.#t, cb))\n\t    }\n\t  }\n\t  #onAfterEach: ((t: Test) => void)[] = []\n\t  afterEach(fn: (t: Test) => void | Promise<void>) {\n\t    this.#onAfterEach.push(fn)\n\t  }\n\t  #runAfterEach(who: TestBase, cb: () => void) {\n\t    // run all the afterEach methods from the parent\n", "    const onerr = (er: any) => {\n\t      who.threw(er)\n\t      cb()\n\t    }\n\t    const p = this.#t.parent\n\t    const pae = !!p && AfterEach.#refs.get(p)\n\t    const run = () => {\n\t      if (pae) {\n\t        pae.#runAfterEach(who, cb)\n\t      } else {\n", "        cb()\n\t      }\n\t    }\n\t    if (who !== this.#t) {\n\t      loop(this.#onAfterEach, run, onerr)\n\t    } else {\n\t      run()\n\t    }\n\t  }\n\t}\n", "const plugin: TapPlugin<AfterEach> = (t: TestBase) => new AfterEach(t)\n\texport default plugin\n"]}
{"filename": "src/plugin/before-each.ts", "chunked_list": ["/// <reference types=\"node\" />\n\timport loop from 'function-loop'\n\timport { TestBase } from '../test-base.js'\n\timport type { Test } from '../test-built.js'\n\tclass BeforeEach {\n\t  static #refs = new Map<TestBase, BeforeEach>()\n\t  #t: TestBase\n\t  constructor(t: TestBase) {\n\t    this.#t = t\n\t    BeforeEach.#refs.set(t, this)\n", "    const runMain = t.runMain\n\t    t.runMain = (cb: () => void) => {\n\t      this.#runBeforeEach(this.#t, () =>\n\t        runMain.call(t, cb)\n\t      )\n\t    }\n\t  }\n\t  #onBeforeEach: ((t: Test) => void)[] = []\n\t  beforeEach(fn: (t: Test) => void | Promise<void>) {\n\t    this.#onBeforeEach.push(fn)\n", "  }\n\t  #runBeforeEach(who: TestBase, cb: () => void) {\n\t    // run all the beforeEach methods from the parent\n\t    const onerr = (er: any) => {\n\t      who.threw(er)\n\t      cb()\n\t    }\n\t    const p = this.#t.parent\n\t    const pbe = !!p && BeforeEach.#refs.get(p)\n\t    if (pbe) {\n", "      pbe.#runBeforeEach(who, () => {\n\t        loop(this.#onBeforeEach, cb, onerr)\n\t      })\n\t    } else if (who !== this.#t) {\n\t      loop(this.#onBeforeEach, cb, onerr)\n\t    } else {\n\t      cb()\n\t    }\n\t  }\n\t}\n", "const plugin = (t: TestBase) => new BeforeEach(t)\n\texport default plugin\n"]}
{"filename": "src/plugin/stdin.ts", "chunked_list": ["import { FinalResults } from 'tap-parser'\n\timport parseTestArgs from '../parse-test-args.js'\n\timport { Stdin, StdinOpts } from '../stdin.js'\n\timport { TapPlugin, TestBase } from '../test-base.js'\n\tclass StdinPlugin {\n\t  #t: TestBase\n\t  constructor(t: TestBase) {\n\t    this.#t = t\n\t  }\n\t  stdin(\n", "    name: string,\n\t    extra?: StdinOpts\n\t  ): Promise<FinalResults | null>\n\t  stdin(extra?: StdinOpts): Promise<FinalResults | null>\n\t  stdin(\n\t    name?: string | { [k: string]: any },\n\t    extra?: StdinOpts\n\t  ): Promise<FinalResults | null> {\n\t    if (name && typeof name === 'object') {\n\t      extra = name\n", "      name = undefined\n\t    }\n\t    extra = parseTestArgs<Stdin>(\n\t      name,\n\t      extra,\n\t      false,\n\t      '/dev/stdin'\n\t    )\n\t    return this.#t.sub(Stdin, extra, this.stdin)\n\t  }\n", "}\n\tconst plugin: TapPlugin<StdinPlugin> = (t: TestBase) =>\n\t  new StdinPlugin(t)\n\texport default plugin\n"]}
