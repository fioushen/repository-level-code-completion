{"filename": "vitest.config.ts", "chunked_list": ["import { defineConfig } from \"vitest/config\"\n\texport default defineConfig({})\n"]}
{"filename": "src/typeMap.ts", "chunked_list": ["import * as graphql from \"graphql\"\n\timport { AppContext } from \"./context.js\"\n\texport type TypeMapper = ReturnType<typeof typeMapper>\n\texport const typeMapper = (context: AppContext, config: { preferPrismaModels?: true }) => {\n\t\tconst referencedGraphQLTypes = new Set<string>()\n\t\tconst referencedPrismaModels = new Set<string>()\n\t\tconst customScalars = new Set<string>()\n\t\tconst clear = () => {\n\t\t\treferencedGraphQLTypes.clear()\n\t\t\tcustomScalars.clear()\n", "\t\treferencedPrismaModels.clear()\n\t\t}\n\t\tconst getReferencedGraphQLThingsInMapping = () => {\n\t\t\treturn {\n\t\t\t\ttypes: [...referencedGraphQLTypes.keys()],\n\t\t\t\tscalars: [...customScalars.keys()],\n\t\t\t\tprisma: [...referencedPrismaModels.keys()],\n\t\t\t}\n\t\t}\n\t\tconst map = (\n", "\t\ttype: graphql.GraphQLType,\n\t\t\tmapConfig: {\n\t\t\t\tparentWasNotNull?: true\n\t\t\t\tpreferNullOverUndefined?: true\n\t\t\t\ttypenamePrefix?: string\n\t\t\t}\n\t\t): string | undefined => {\n\t\t\tconst prefix = mapConfig.typenamePrefix ?? \"\"\n\t\t\t// The AST for GQL uses a parent node to indicate the !, we need the opposite\n\t\t\t// for TS which uses '| undefined' after.\n", "\t\tif (graphql.isNonNullType(type)) {\n\t\t\t\treturn map(type.ofType, { parentWasNotNull: true, ...mapConfig })\n\t\t\t}\n\t\t\t// So we can add the | undefined\n\t\t\tconst getInner = () => {\n\t\t\t\tif (graphql.isListType(type)) {\n\t\t\t\t\tconst typeStr = map(type.ofType, mapConfig)\n\t\t\t\t\tif (!typeStr) return \"any\"\n\t\t\t\t\tif (graphql.isNonNullType(type.ofType)) {\n\t\t\t\t\t\treturn `${typeStr}[]`\n", "\t\t\t\t} else {\n\t\t\t\t\t\treturn `Array<${typeStr}>`\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (graphql.isScalarType(type)) {\n\t\t\t\t\tswitch (type.toString()) {\n\t\t\t\t\t\tcase \"Int\":\n\t\t\t\t\t\t\treturn \"number\"\n\t\t\t\t\t\tcase \"Float\":\n\t\t\t\t\t\t\treturn \"number\"\n", "\t\t\t\t\tcase \"String\":\n\t\t\t\t\t\t\treturn \"string\"\n\t\t\t\t\t\tcase \"Boolean\":\n\t\t\t\t\t\t\treturn \"boolean\"\n\t\t\t\t\t}\n\t\t\t\t\tcustomScalars.add(type.name)\n\t\t\t\t\treturn type.name\n\t\t\t\t}\n\t\t\t\tif (graphql.isObjectType(type)) {\n\t\t\t\t\tif (config.preferPrismaModels && context.prisma.has(type.name)) {\n", "\t\t\t\t\treferencedPrismaModels.add(type.name)\n\t\t\t\t\t\treturn \"P\" + type.name\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// GraphQL only type\n\t\t\t\t\t\treferencedGraphQLTypes.add(type.name)\n\t\t\t\t\t\treturn prefix + type.name\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (graphql.isInterfaceType(type)) {\n\t\t\t\t\treturn prefix + type.name\n", "\t\t\t}\n\t\t\t\tif (graphql.isUnionType(type)) {\n\t\t\t\t\tconst types = type.getTypes()\n\t\t\t\t\treturn types.map((t) => map(t, mapConfig)).join(\" | \")\n\t\t\t\t}\n\t\t\t\tif (graphql.isEnumType(type)) {\n\t\t\t\t\treturn prefix + type.name\n\t\t\t\t}\n\t\t\t\tif (graphql.isInputObjectType(type)) {\n\t\t\t\t\treferencedGraphQLTypes.add(type.name)\n", "\t\t\t\treturn prefix + type.name\n\t\t\t\t}\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n\t\t\t\tthrow new Error(`Unknown type ${type} - ${JSON.stringify(type, null, 2)}`)\n\t\t\t}\n\t\t\tconst suffix = mapConfig.parentWasNotNull ? \"\" : mapConfig.preferNullOverUndefined ? \"| null\" : \" | undefined\"\n\t\t\treturn getInner() + suffix\n\t\t}\n\t\treturn { map, clear, getReferencedGraphQLThingsInMapping }\n\t}\n"]}
{"filename": "src/prismaModeller.ts", "chunked_list": ["import { Property as PrismaProperty, Schema as PrismaSchemaBlocks } from \"@mrleebo/prisma-ast\"\n\tinterface Model {\n\t\tleadingComments: string\n\t\tproperties: Map<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tleadingComments: string\n\t\t\t\tproperty: PrismaProperty\n\t\t\t}\n\t\t>\n", "}\n\texport type PrismaMap = ReadonlyMap<string, Model>\n\texport const prismaModeller = (schema: PrismaSchemaBlocks) => {\n\t\tconst types = new Map<string, Model>()\n\t\tlet leadingComments: string[] = []\n\t\tschema.list.forEach((b) => {\n\t\t\tif (b.type === \"comment\") {\n\t\t\t\tleadingComments.push(b.text.replace(\"/// \", \"\").replace(\"// \", \"\"))\n\t\t\t}\n\t\t\tif (b.type === \"model\") {\n", "\t\t\tconst properties = new Map<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tleadingComments: string\n\t\t\t\t\t\tproperty: PrismaProperty\n\t\t\t\t\t}\n\t\t\t\t>()\n\t\t\t\tlet leadingFieldComments: string[] = []\n\t\t\t\t// Loop through all the properties and keep track of the\n\t\t\t\t// comments before them\n", "\t\t\tb.properties.forEach((p) => {\n\t\t\t\t\tif (p.type === \"comment\") {\n\t\t\t\t\t\tleadingFieldComments.push(p.text.replace(\"/// \", \"\").replace(\"// \", \"\"))\n\t\t\t\t\t} else if (p.type === \"break\") {\n\t\t\t\t\t\tleadingFieldComments.push(\"\")\n\t\t\t\t\t} else if (p.type === \"attribute\" || p.type === \"field\") {\n\t\t\t\t\t\tproperties.set(p.name, {\n\t\t\t\t\t\t\tleadingComments: leadingFieldComments.join(\"\\n\"),\n\t\t\t\t\t\t\tproperty: p,\n\t\t\t\t\t\t})\n", "\t\t\t\t\tleadingFieldComments = []\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\ttypes.set(b.name, {\n\t\t\t\t\tproperties,\n\t\t\t\t\tleadingComments: leadingComments.join(\"\\n\"),\n\t\t\t\t})\n\t\t\t\tleadingComments = []\n\t\t\t}\n\t\t})\n", "\treturn types\n\t}\n"]}
{"filename": "src/sharedSchema.ts", "chunked_list": ["/// The main schema for objects and inputs\n\timport * as graphql from \"graphql\"\n\timport * as tsMorph from \"ts-morph\"\n\timport { AppContext } from \"./context.js\"\n\timport { formatDTS, getPrettierConfig } from \"./formatDTS.js\"\n\timport { typeMapper } from \"./typeMap.js\"\n\texport const createSharedSchemaFiles = (context: AppContext) => {\n\t\tcreateSharedExternalSchemaFile(context)\n\t\tcreateSharedReturnPositionSchemaFile(context)\n\t\treturn [\n", "\t\tcontext.join(context.pathSettings.typesFolderRoot, context.pathSettings.sharedFilename),\n\t\t\tcontext.join(context.pathSettings.typesFolderRoot, context.pathSettings.sharedInternalFilename),\n\t\t]\n\t}\n\tfunction createSharedExternalSchemaFile(context: AppContext) {\n\t\tconst gql = context.gql\n\t\tconst types = gql.getTypeMap()\n\t\tconst knownPrimitives = [\"String\", \"Boolean\", \"Int\"]\n\t\tconst { prisma, fieldFacts } = context\n\t\tconst mapper = typeMapper(context, {})\n", "\tconst externalTSFile = context.tsProject.createSourceFile(`/source/${context.pathSettings.sharedFilename}`, \"\")\n\t\tObject.keys(types).forEach((name) => {\n\t\t\tif (name.startsWith(\"__\")) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (knownPrimitives.includes(name)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst type = types[name]\n\t\t\tconst pType = prisma.get(name)\n", "\t\tif (graphql.isObjectType(type) || graphql.isInterfaceType(type) || graphql.isInputObjectType(type)) {\n\t\t\t\t// This is slower than it could be, use the add many at once api\n\t\t\t\tconst docs = []\n\t\t\t\tif (pType?.leadingComments) {\n\t\t\t\t\tdocs.push(pType.leadingComments)\n\t\t\t\t}\n\t\t\t\tif (type.description) {\n\t\t\t\t\tdocs.push(type.description)\n\t\t\t\t}\n\t\t\t\texternalTSFile.addInterface({\n", "\t\t\t\tname: type.name,\n\t\t\t\t\tisExported: true,\n\t\t\t\t\tdocs: [],\n\t\t\t\t\tproperties: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: \"__typename\",\n\t\t\t\t\t\t\ttype: `\"${type.name}\"`,\n\t\t\t\t\t\t\thasQuestionToken: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t...Object.entries(type.getFields()).map(([fieldName, obj]: [string, graphql.GraphQLField<object, object>]) => {\n", "\t\t\t\t\t\tconst docs = []\n\t\t\t\t\t\t\tconst prismaField = pType?.properties.get(fieldName)\n\t\t\t\t\t\t\tconst type = obj.type as graphql.GraphQLType\n\t\t\t\t\t\t\tif (prismaField?.leadingComments.length) {\n\t\t\t\t\t\t\t\tdocs.push(prismaField.leadingComments.trim())\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// if (obj.description) docs.push(obj.description);\n\t\t\t\t\t\t\tconst hasResolverImplementation = fieldFacts.get(name)?.[fieldName]?.hasResolverImplementation\n\t\t\t\t\t\t\tconst isOptionalInSDL = !graphql.isNonNullType(type)\n\t\t\t\t\t\t\tconst doesNotExistInPrisma = false // !prismaField;\n", "\t\t\t\t\t\tconst field: tsMorph.OptionalKind<tsMorph.PropertySignatureStructure> = {\n\t\t\t\t\t\t\t\tname: fieldName,\n\t\t\t\t\t\t\t\ttype: mapper.map(type, { preferNullOverUndefined: true }),\n\t\t\t\t\t\t\t\tdocs,\n\t\t\t\t\t\t\t\thasQuestionToken: hasResolverImplementation ?? (isOptionalInSDL || doesNotExistInPrisma),\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn field\n\t\t\t\t\t\t}),\n\t\t\t\t\t],\n\t\t\t\t})\n", "\t\t}\n\t\t\tif (graphql.isEnumType(type)) {\n\t\t\t\texternalTSFile.addTypeAlias({\n\t\t\t\t\tname: type.name,\n\t\t\t\t\ttype:\n\t\t\t\t\t\t'\"' +\n\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t.getValues()\n\t\t\t\t\t\t\t.map((m) => (m as { value: string }).value)\n\t\t\t\t\t\t\t.join('\" | \"') +\n", "\t\t\t\t\t'\"',\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t\tconst { scalars } = mapper.getReferencedGraphQLThingsInMapping()\n\t\tif (scalars.length) {\n\t\t\texternalTSFile.addTypeAliases(\n\t\t\t\tscalars.map((s) => ({\n\t\t\t\t\tname: s,\n\t\t\t\t\ttype: \"any\",\n", "\t\t\t}))\n\t\t\t)\n\t\t}\n\t\tconst fullPath = context.join(context.pathSettings.typesFolderRoot, context.pathSettings.sharedFilename)\n\t\tconst config = getPrettierConfig(fullPath)\n\t\tconst formatted = formatDTS(fullPath, externalTSFile.getText(), config)\n\t\tcontext.sys.writeFile(fullPath, formatted)\n\t}\n\tfunction createSharedReturnPositionSchemaFile(context: AppContext) {\n\t\tconst { gql, prisma, fieldFacts } = context\n", "\tconst types = gql.getTypeMap()\n\t\tconst mapper = typeMapper(context, { preferPrismaModels: true })\n\t\tconst typesToImport = [] as string[]\n\t\tconst knownPrimitives = [\"String\", \"Boolean\", \"Int\"]\n\t\tconst externalTSFile = context.tsProject.createSourceFile(\n\t\t\t`/source/${context.pathSettings.sharedInternalFilename}`,\n\t\t\t`\n\t// You may very reasonably ask yourself, 'what is this file?' and why do I need it.\n\t// Roughly, this file ensures that when a resolver wants to return a type - that\n\t// type will match a prisma model. This is useful because you can trivially extend\n", "// the type in the SDL and not have to worry about type mis-matches because the thing\n\t// you returned does not include those functions.\n\t// This gets particularly valuable when you want to return a union type, an interface, \n\t// or a model where the prisma model is nested pretty deeply (GraphQL connections, for example.)\n\t`\n\t\t)\n\t\tObject.keys(types).forEach((name) => {\n\t\t\tif (name.startsWith(\"__\")) {\n\t\t\t\treturn\n\t\t\t}\n", "\t\tif (knownPrimitives.includes(name)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst type = types[name]\n\t\t\tconst pType = prisma.get(name)\n\t\t\tif (graphql.isObjectType(type) || graphql.isInterfaceType(type) || graphql.isInputObjectType(type)) {\n\t\t\t\t// Return straight away if we have a matching type in the prisma schema\n\t\t\t\t// as we dont need it\n\t\t\t\tif (pType) {\n\t\t\t\t\ttypesToImport.push(name)\n", "\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\texternalTSFile.addInterface({\n\t\t\t\t\tname: type.name,\n\t\t\t\t\tisExported: true,\n\t\t\t\t\tdocs: [],\n\t\t\t\t\tproperties: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: \"__typename\",\n\t\t\t\t\t\t\ttype: `\"${type.name}\"`,\n", "\t\t\t\t\t\thasQuestionToken: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t...Object.entries(type.getFields()).map(([fieldName, obj]: [string, graphql.GraphQLField<object, object>]) => {\n\t\t\t\t\t\t\tconst hasResolverImplementation = fieldFacts.get(name)?.[fieldName]?.hasResolverImplementation\n\t\t\t\t\t\t\tconst isOptionalInSDL = !graphql.isNonNullType(obj.type)\n\t\t\t\t\t\t\tconst doesNotExistInPrisma = false // !prismaField;\n\t\t\t\t\t\t\tconst field: tsMorph.OptionalKind<tsMorph.PropertySignatureStructure> = {\n\t\t\t\t\t\t\t\tname: fieldName,\n\t\t\t\t\t\t\t\ttype: mapper.map(obj.type, { preferNullOverUndefined: true }),\n\t\t\t\t\t\t\t\thasQuestionToken: hasResolverImplementation || isOptionalInSDL || doesNotExistInPrisma,\n", "\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn field\n\t\t\t\t\t\t}),\n\t\t\t\t\t],\n\t\t\t\t})\n\t\t\t}\n\t\t\tif (graphql.isEnumType(type)) {\n\t\t\t\texternalTSFile.addTypeAlias({\n\t\t\t\t\tname: type.name,\n\t\t\t\t\ttype:\n", "\t\t\t\t\t'\"' +\n\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t.getValues()\n\t\t\t\t\t\t\t.map((m) => (m as { value: string }).value)\n\t\t\t\t\t\t\t.join('\" | \"') +\n\t\t\t\t\t\t'\"',\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t\tconst { scalars, prisma: prismaModels } = mapper.getReferencedGraphQLThingsInMapping()\n", "\tif (scalars.length) {\n\t\t\texternalTSFile.addTypeAliases(\n\t\t\t\tscalars.map((s) => ({\n\t\t\t\t\tname: s,\n\t\t\t\t\ttype: \"any\",\n\t\t\t\t}))\n\t\t\t)\n\t\t}\n\t\tconst allPrismaModels = [...new Set([...prismaModels, ...typesToImport])].sort()\n\t\tif (allPrismaModels.length) {\n", "\t\texternalTSFile.addImportDeclaration({\n\t\t\t\tisTypeOnly: true,\n\t\t\t\tmoduleSpecifier: `@prisma/client`,\n\t\t\t\tnamedImports: allPrismaModels.map((p) => `${p} as P${p}`),\n\t\t\t})\n\t\t\tallPrismaModels.forEach((p) => {\n\t\t\t\texternalTSFile.addTypeAlias({\n\t\t\t\t\tisExported: true,\n\t\t\t\t\tname: p,\n\t\t\t\t\ttype: `P${p}`,\n", "\t\t\t})\n\t\t\t})\n\t\t}\n\t\tconst fullPath = context.join(context.pathSettings.typesFolderRoot, context.pathSettings.sharedInternalFilename)\n\t\tconst config = getPrettierConfig(fullPath)\n\t\tconst formatted = formatDTS(fullPath, externalTSFile.getText(), config)\n\t\tcontext.sys.writeFile(fullPath, formatted)\n\t}\n"]}
{"filename": "src/typeFacts.ts", "chunked_list": ["export type FieldFacts = Record<string, FieldFact>\n\texport interface FieldFact {\n\t\thasResolverImplementation?: true\n\t\t// isPrismaBacked?: true;\n\t}\n\t// The data-model for the service file which contains the SDL matched functions\n\t/** A representation of the code inside the source file's  */\n\texport type CodeFacts = Record<string, ModelResolverFacts | undefined>\n\texport interface ModelResolverFacts {\n\t\t/** Should we type the type as a generic with an override  */\n", "\thasGenericArg: boolean\n\t\t/** Individual resolvers found for this model */\n\t\tresolvers: Map<string, ResolverFuncFact>\n\t\t/** The name (or lack of) for the GraphQL type which we are mapping  */\n\t\ttypeName: string | \"maybe_query_mutation\"\n\t}\n\texport interface ResolverFuncFact {\n\t\t/** How many args are defined? */\n\t\tfuncArgCount: number\n\t\t/** Is it declared as an async fn */\n", "\tisAsync: boolean\n\t\t/** is 'function abc() {}' */\n\t\tisFunc: boolean\n\t\t/** is 'const ABC = {}' */\n\t\tisObjLiteral: boolean\n\t\t/** We don't know what declaration is */\n\t\tisUnknown: boolean\n\t\t/** The name of the fn */\n\t\tname: string\n\t}\n"]}
{"filename": "src/run.ts", "chunked_list": ["// TODO: Remove?\n\timport { basename, join } from \"node:path\"\n\timport { getSchema as getPrismaSchema } from \"@mrleebo/prisma-ast\"\n\timport * as graphql from \"graphql\"\n\timport { Project } from \"ts-morph\"\n\timport typescript from \"typescript\"\n\timport { AppContext } from \"./context.js\"\n\timport { PrismaMap, prismaModeller } from \"./prismaModeller.js\"\n\timport { lookAtServiceFile } from \"./serviceFile.js\"\n\timport { createSharedSchemaFiles } from \"./sharedSchema.js\"\n", "import { CodeFacts, FieldFacts } from \"./typeFacts.js\"\n\texport function run(\n\t\tappRoot: string,\n\t\ttypesRoot: string,\n\t\tconfig: { deleteOldGraphQLDTS?: boolean; runESLint?: boolean; sys?: typescript.System } = {}\n\t) {\n\t\tconst sys = config.sys ?? typescript.sys\n\t\tconst project = new Project({ useInMemoryFileSystem: true })\n\t\tlet gqlSchema: graphql.GraphQLSchema | undefined\n\t\tconst getGraphQLSDLFromFile = (settings: AppContext[\"pathSettings\"]) => {\n", "\t\tconst schema = sys.readFile(settings.graphQLSchemaPath)\n\t\t\tif (!schema) throw new Error(\"No schema found at \" + settings.graphQLSchemaPath)\n\t\t\tgqlSchema = graphql.buildSchema(schema)\n\t\t}\n\t\tlet prismaSchema: PrismaMap = new Map()\n\t\tconst getPrismaSchemaFromFile = (settings: AppContext[\"pathSettings\"]) => {\n\t\t\tconst prismaSchemaText = sys.readFile(settings.prismaDSLPath)\n\t\t\tif (!prismaSchemaText) throw new Error(\"No prisma file found at \" + settings.prismaDSLPath)\n\t\t\tconst prismaSchemaBlocks = getPrismaSchema(prismaSchemaText)\n\t\t\tprismaSchema = prismaModeller(prismaSchemaBlocks)\n", "\t}\n\t\tconst settings: AppContext[\"pathSettings\"] = {\n\t\t\troot: appRoot,\n\t\t\tgraphQLSchemaPath: join(appRoot, \".redwood\", \"schema.graphql\"),\n\t\t\tapiServicesPath: join(appRoot, \"api\", \"src\", \"services\"),\n\t\t\tprismaDSLPath: join(appRoot, \"api\", \"db\", \"schema.prisma\"),\n\t\t\tsharedFilename: \"shared-schema-types.d.ts\",\n\t\t\tsharedInternalFilename: \"shared-return-types.d.ts\",\n\t\t\ttypesFolderRoot: typesRoot,\n\t\t}\n", "\tgetGraphQLSDLFromFile(settings)\n\t\tgetPrismaSchemaFromFile(settings)\n\t\tif (!gqlSchema) throw new Error(\"No GraphQL Schema was created during setup\")\n\t\tconst appContext: AppContext = {\n\t\t\tgql: gqlSchema,\n\t\t\tprisma: prismaSchema,\n\t\t\ttsProject: project,\n\t\t\tcodeFacts: new Map<string, CodeFacts>(),\n\t\t\tfieldFacts: new Map<string, FieldFacts>(),\n\t\t\tpathSettings: settings,\n", "\t\tsys,\n\t\t\tjoin,\n\t\t\tbasename,\n\t\t}\n\t\tconst serviceFilesToLookAt = [] as string[]\n\t\tfor (const dirEntry of sys.readDirectory(appContext.pathSettings.apiServicesPath)) {\n\t\t\t// These are generally the folders\n\t\t\tif (sys.directoryExists(dirEntry)) {\n\t\t\t\tconst folderPath = join(appContext.pathSettings.apiServicesPath, dirEntry)\n\t\t\t\t// And these are the files in them\n", "\t\t\tfor (const subdirEntry of sys.readDirectory(folderPath)) {\n\t\t\t\t\tconst folderPath = join(appContext.pathSettings.apiServicesPath, dirEntry)\n\t\t\t\t\tif (\n\t\t\t\t\t\tsys.fileExists(folderPath) &&\n\t\t\t\t\t\tsubdirEntry.endsWith(\".ts\") &&\n\t\t\t\t\t\t!subdirEntry.includes(\".test.ts\") &&\n\t\t\t\t\t\t!subdirEntry.includes(\"scenarios.ts\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tserviceFilesToLookAt.push(join(folderPath, subdirEntry))\n\t\t\t\t\t}\n", "\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// empty the types folder\n\t\tfor (const dirEntry of sys.readDirectory(appContext.pathSettings.typesFolderRoot)) {\n\t\t\tconst fileToDelete = join(appContext.pathSettings.typesFolderRoot, dirEntry)\n\t\t\tif (sys.deleteFile && sys.fileExists(fileToDelete)) {\n\t\t\t\tsys.deleteFile(fileToDelete)\n\t\t\t}\n\t\t}\n", "\t// This needs to go first, as it sets up fieldFacts\n\t\tfor (const path of serviceFilesToLookAt) {\n\t\t\tlookAtServiceFile(path, appContext)\n\t\t}\n\t\tcreateSharedSchemaFiles(appContext)\n\t\t// console.log(`Updated`, typesRoot)\n\t\tif (config.runESLint) {\n\t\t\t// console.log(\"Running ESLint...\")\n\t\t\t// const process = Deno.run({\n\t\t\t// \tcwd: appRoot,\n", "\t\t// \tcmd: [\"yarn\", \"eslint\", \"--fix\", \"--ext\", \".d.ts\", appContext.settings.typesFolderRoot],\n\t\t\t// \tstdin: \"inherit\",\n\t\t\t// \tstdout: \"inherit\",\n\t\t\t// })\n\t\t\t// await process.status()\n\t\t}\n\t\tif (sys.deleteFile && config.deleteOldGraphQLDTS) {\n\t\t\tconsole.log(\"Deleting old graphql.d.ts\")\n\t\t\tsys.deleteFile(join(appRoot, \"api\", \"src\", \"graphql.d.ts\"))\n\t\t}\n", "}\n"]}
{"filename": "src/main.ts", "chunked_list": ["export const run = () => {\n\t\tconsole.log(\"Hello, world!\")\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import type { System } from \"typescript\"\n\texport interface SDLCodeGenOptions {\n\t\t/** We'll use the one which comes with TypeScript if one isn't given */\n\t\tsystem?: System\n\t}\n\t// These are directly ported from Redwood at\n\t// packages/project-config/src/paths.ts\n\t// Slightly amended to reduce the constraints on the Redwood team to make changes to this obj!\n\tinterface NodeTargetPaths {\n\t\tbase: string\n", "\tconfig: string\n\t\t// dataMigrations: string\n\t\t// db: string\n\t\tdbSchema: string\n\t\tdirectives: string\n\t\t// dist: string\n\t\t// functions: string\n\t\t// generators: string\n\t\tgraphql: string\n\t\tlib: string\n", "\tmodels: string\n\t\tservices: string\n\t\tsrc: string\n\t\ttypes: string\n\t}\n\texport interface RedwoodPaths {\n\t\tapi: NodeTargetPaths\n\t\tbase: string\n\t\tgenerated: {\n\t\t\t// base: string\n", "\t\t// prebuild: string\n\t\t\tschema: string\n\t\t\t// types: {\n\t\t\t// \tincludes: string\n\t\t\t// \tmirror: string\n\t\t\t// }\n\t\t}\n\t\tscripts: string\n\t\tweb: any\n\t}\n"]}
{"filename": "src/serviceFile.ts", "chunked_list": ["import * as graphql from \"graphql\"\n\timport { AppContext } from \"./context.js\"\n\timport { formatDTS, getPrettierConfig } from \"./formatDTS.js\"\n\timport { getCodeFactsForJSTSFileAtPath } from \"./serviceFile.codefacts.js\"\n\timport { CodeFacts, ModelResolverFacts, ResolverFuncFact } from \"./typeFacts.js\"\n\timport { TypeMapper, typeMapper } from \"./typeMap.js\"\n\timport { capitalizeFirstLetter, createAndReferOrInlineArgsForField, inlineArgsForField } from \"./utils.js\"\n\texport const lookAtServiceFile = (file: string, context: AppContext) => {\n\t\tconst { gql, prisma, pathSettings: settings, codeFacts: serviceFacts, fieldFacts } = context\n\t\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n", "\tif (!gql) throw new Error(`No schema when wanting to look at service file: ${file}`)\n\t\tif (!prisma) throw new Error(`No prisma schema when wanting to look at service file: ${file}`)\n\t\t// This isn't good enough, needs to be relative to api/src/services\n\t\tconst fileKey = file.replace(settings.apiServicesPath, \"\")\n\t\tconst thisFact: CodeFacts = {}\n\t\tconst filename = context.basename(file)\n\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\tconst queryType = gql.getQueryType()!\n\t\tif (!queryType) throw new Error(\"No query type\")\n\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n", "\tconst mutationType = gql.getMutationType()!\n\t\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\t\tif (!mutationType) throw new Error(\"No mutation type\")\n\t\tconst externalMapper = typeMapper(context, { preferPrismaModels: true })\n\t\tconst returnTypeMapper = typeMapper(context, {})\n\t\t// The description of the source file\n\t\tconst fileFacts = getCodeFactsForJSTSFileAtPath(file, context)\n\t\tif (Object.keys(fileFacts).length === 0) return\n\t\t// Tracks prospective prisma models which are used in the file\n\t\tconst extraPrismaReferences = new Set<string>()\n", "\t// The file we'll be creating in-memory throughout this fn\n\t\tconst fileDTS = context.tsProject.createSourceFile(`source/${fileKey}.d.ts`, \"\", { overwrite: true })\n\t\t// Basically if a top level resolver reference Query or Mutation\n\t\tconst knownSpecialCasesForGraphQL = new Set<string>()\n\t\t// Add the root function declarations\n\t\tconst rootResolvers = fileFacts.maybe_query_mutation?.resolvers\n\t\tif (rootResolvers)\n\t\t\trootResolvers.forEach((v) => {\n\t\t\t\tconst isQuery = v.name in queryType.getFields()\n\t\t\t\tconst isMutation = v.name in mutationType.getFields()\n", "\t\t\tconst parentName = isQuery ? queryType.name : isMutation ? mutationType.name : undefined\n\t\t\t\tif (parentName) {\n\t\t\t\t\taddDefinitionsForTopLevelResolvers(parentName, v)\n\t\t\t\t} else {\n\t\t\t\t\t// Add warning about unused resolver\n\t\t\t\t\tfileDTS.addStatements(`\\n// ${v.name} does not exist on Query or Mutation`)\n\t\t\t\t}\n\t\t\t})\n\t\t// Add the root function declarations\n\t\tObject.values(fileFacts).forEach((model) => {\n", "\t\tif (!model) return\n\t\t\tconst skip = [\"maybe_query_mutation\", queryType.name, mutationType.name]\n\t\t\tif (skip.includes(model.typeName)) return\n\t\t\taddCustomTypeModel(model)\n\t\t})\n\t\t// Set up the module imports at the top\n\t\tconst sharedGraphQLObjectsReferenced = externalMapper.getReferencedGraphQLThingsInMapping()\n\t\tconst sharedGraphQLObjectsReferencedTypes = [...sharedGraphQLObjectsReferenced.types, ...knownSpecialCasesForGraphQL]\n\t\tconst sharedInternalGraphQLObjectsReferenced = returnTypeMapper.getReferencedGraphQLThingsInMapping()\n\t\tconst aliases = [...new Set([...sharedGraphQLObjectsReferenced.scalars, ...sharedInternalGraphQLObjectsReferenced.scalars])]\n", "\tif (aliases.length) {\n\t\t\tfileDTS.addTypeAliases(\n\t\t\t\taliases.map((s) => ({\n\t\t\t\t\tname: s,\n\t\t\t\t\ttype: \"any\",\n\t\t\t\t}))\n\t\t\t)\n\t\t}\n\t\tconst prismases = [\n\t\t\t...new Set([\n", "\t\t\t...sharedGraphQLObjectsReferenced.prisma,\n\t\t\t\t...sharedInternalGraphQLObjectsReferenced.prisma,\n\t\t\t\t...extraPrismaReferences.values(),\n\t\t\t]),\n\t\t]\n\t\tconst validPrismaObjs = prismases.filter((p) => prisma.has(p))\n\t\tif (validPrismaObjs.length) {\n\t\t\tfileDTS.addImportDeclaration({\n\t\t\t\tisTypeOnly: true,\n\t\t\t\tmoduleSpecifier: \"@prisma/client\",\n", "\t\t\tnamedImports: validPrismaObjs.map((p) => `${p} as P${p}`),\n\t\t\t})\n\t\t}\n\t\tif (fileDTS.getText().includes(\"GraphQLResolveInfo\")) {\n\t\t\tfileDTS.addImportDeclaration({\n\t\t\t\tisTypeOnly: true,\n\t\t\t\tmoduleSpecifier: \"graphql\",\n\t\t\t\tnamedImports: [\"GraphQLResolveInfo\"],\n\t\t\t})\n\t\t}\n", "\tif (fileDTS.getText().includes(\"RedwoodGraphQLContext\")) {\n\t\t\tfileDTS.addImportDeclaration({\n\t\t\t\tisTypeOnly: true,\n\t\t\t\tmoduleSpecifier: \"@redwoodjs/graphql-server/dist/types\",\n\t\t\t\tnamedImports: [\"RedwoodGraphQLContext\"],\n\t\t\t})\n\t\t}\n\t\tif (sharedInternalGraphQLObjectsReferenced.types.length) {\n\t\t\tfileDTS.addImportDeclaration({\n\t\t\t\tisTypeOnly: true,\n", "\t\t\tmoduleSpecifier: `./${settings.sharedInternalFilename.replace(\".d.ts\", \"\")}`,\n\t\t\t\tnamedImports: sharedInternalGraphQLObjectsReferenced.types.map((t) => `${t} as RT${t}`),\n\t\t\t})\n\t\t}\n\t\tif (sharedGraphQLObjectsReferencedTypes.length) {\n\t\t\tfileDTS.addImportDeclaration({\n\t\t\t\tisTypeOnly: true,\n\t\t\t\tmoduleSpecifier: `./${settings.sharedFilename.replace(\".d.ts\", \"\")}`,\n\t\t\t\tnamedImports: sharedGraphQLObjectsReferencedTypes,\n\t\t\t})\n", "\t}\n\t\tserviceFacts.set(fileKey, thisFact)\n\t\tconst dtsFilename = filename.endsWith(\".ts\") ? filename.replace(\".ts\", \".d.ts\") : filename.replace(\".js\", \".d.ts\")\n\t\tconst dtsFilepath = context.join(context.pathSettings.typesFolderRoot, dtsFilename)\n\t\t// Some manual formatting tweaks so we align with Redwood's setup more\n\t\tconst dts = fileDTS\n\t\t\t.getText()\n\t\t\t.replace(`from \"graphql\";`, `from \"graphql\";\\n`)\n\t\t\t.replace(`from \"@redwoodjs/graphql-server/dist/types\";`, `from \"@redwoodjs/graphql-server/dist/types\";\\n`)\n\t\tconst shouldWriteDTS = !!dts.trim().length\n", "\tif (!shouldWriteDTS) return\n\t\tconst config = getPrettierConfig(dtsFilepath)\n\t\tconst formatted = formatDTS(dtsFilepath, dts, config)\n\t\tcontext.sys.writeFile(dtsFilepath, formatted)\n\t\treturn dtsFilepath\n\t\tfunction addDefinitionsForTopLevelResolvers(parentName: string, config: ResolverFuncFact) {\n\t\t\tconst { name } = config\n\t\t\tlet field = queryType.getFields()[name]\n\t\t\tif (!field) {\n\t\t\t\tfield = mutationType.getFields()[name]\n", "\t\t}\n\t\t\tconst interfaceDeclaration = fileDTS.addInterface({\n\t\t\t\tname: `${capitalizeFirstLetter(config.name)}Resolver`,\n\t\t\t\tisExported: true,\n\t\t\t\tdocs: field.astNode\n\t\t\t\t\t? [\"SDL: \" + graphql.print(field.astNode)]\n\t\t\t\t\t: [\"@deprecated: Could not find this field in the schema for Mutation or Query\"],\n\t\t\t})\n\t\t\tconst args = createAndReferOrInlineArgsForField(field, {\n\t\t\t\tname: interfaceDeclaration.getName(),\n", "\t\t\tfile: fileDTS,\n\t\t\t\tmapper: externalMapper.map,\n\t\t\t})\n\t\t\tif (parentName === queryType.name) knownSpecialCasesForGraphQL.add(queryType.name)\n\t\t\tif (parentName === mutationType.name) knownSpecialCasesForGraphQL.add(mutationType.name)\n\t\t\tconst argsParam = args ?? \"object\"\n\t\t\tconst returnType = returnTypeForResolver(returnTypeMapper, field, config)\n\t\t\tinterfaceDeclaration.addCallSignature({\n\t\t\t\tparameters: [\n\t\t\t\t\t{ name: \"args\", type: argsParam, hasQuestionToken: config.funcArgCount < 1 },\n", "\t\t\t\t{\n\t\t\t\t\t\tname: \"obj\",\n\t\t\t\t\t\ttype: `{ root: ${parentName}, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }`,\n\t\t\t\t\t\thasQuestionToken: config.funcArgCount < 2,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\treturnType,\n\t\t\t})\n\t\t}\n\t\t/** Ideally, we want to be able to write the type for just the object  */\n", "\tfunction addCustomTypeModel(modelFacts: ModelResolverFacts) {\n\t\t\tconst modelName = modelFacts.typeName\n\t\t\textraPrismaReferences.add(modelName)\n\t\t\t// Make an interface, this is the version we are replacing from graphql-codegen:\n\t\t\t// Account: MergePrismaWithSdlTypes<PrismaAccount, MakeRelationsOptional<Account, AllMappedModels>, AllMappedModels>;\n\t\t\tconst gqlType = gql.getType(modelName)\n\t\t\tif (!gqlType) {\n\t\t\t\t// throw new Error(`Could not find a GraphQL type named ${d.getName()}`);\n\t\t\t\tfileDTS.addStatements(`\\n// ${modelName} does not exist in the schema`)\n\t\t\t\treturn\n", "\t\t}\n\t\t\tif (!graphql.isObjectType(gqlType)) {\n\t\t\t\tthrow new Error(`In your schema ${modelName} is not an object, which we can only make resolver types for`)\n\t\t\t}\n\t\t\tconst fields = gqlType.getFields()\n\t\t\t// See:   https://github.com/redwoodjs/redwood/pull/6228#issue-1342966511\n\t\t\t// For more ideas\n\t\t\tconst hasGenerics = modelFacts.hasGenericArg\n\t\t\t// This is what they would have to write\n\t\t\tconst resolverInterface = fileDTS.addInterface({\n", "\t\t\tname: `${modelName}TypeResolvers`,\n\t\t\t\ttypeParameters: hasGenerics ? [\"Extended\"] : [],\n\t\t\t\tisExported: true,\n\t\t\t})\n\t\t\t// The parent type for the resolvers\n\t\t\tfileDTS.addTypeAlias({\n\t\t\t\tname: `${modelName}AsParent`,\n\t\t\t\ttypeParameters: hasGenerics ? [\"Extended\"] : [],\n\t\t\t\ttype: `P${modelName} ${createParentAdditionallyDefinedFunctions()} ${hasGenerics ? \" & Extended\" : \"\"}`,\n\t\t\t\t// docs: [\"The prisma model, mixed with fns already defined inside the resolvers.\"],\n", "\t\t})\n\t\t\tconst modelFieldFacts = fieldFacts.get(modelName) ?? {}\n\t\t\t// Loop through the resolvers, adding the fields which have resolvers implemented in the source file\n\t\t\tmodelFacts.resolvers.forEach((resolver) => {\n\t\t\t\tconst field = fields[resolver.name]\n\t\t\t\tif (field) {\n\t\t\t\t\tconst fieldName = resolver.name\n\t\t\t\t\tif (modelFieldFacts[fieldName]) modelFieldFacts[fieldName].hasResolverImplementation = true\n\t\t\t\t\telse modelFieldFacts[fieldName] = { hasResolverImplementation: true }\n\t\t\t\t\tconst argsType = inlineArgsForField(field, { mapper: externalMapper.map }) ?? \"undefined\"\n", "\t\t\t\tconst param = hasGenerics ? \"<Extended>\" : \"\"\n\t\t\t\t\tconst firstQ = resolver.funcArgCount < 1 ? \"?\" : \"\"\n\t\t\t\t\tconst secondQ = resolver.funcArgCount < 2 ? \"?\" : \"\"\n\t\t\t\t\tconst innerArgs = `args${firstQ}: ${argsType}, obj${secondQ}: { root: ${modelName}AsParent${param}, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }`\n\t\t\t\t\tconst returnType = returnTypeForResolver(returnTypeMapper, field, resolver)\n\t\t\t\t\tconst docs = field.astNode ? [`SDL: ${graphql.print(field.astNode)}`] : []\n\t\t\t\t\t// For speed we should switch this out to addProperties eventually\n\t\t\t\t\tresolverInterface.addProperty({\n\t\t\t\t\t\tname: fieldName,\n\t\t\t\t\t\tleadingTrivia: \"\\n\",\n", "\t\t\t\t\tdocs,\n\t\t\t\t\t\ttype: resolver.isFunc || resolver.isUnknown ? `(${innerArgs}) => ${returnType ?? \"any\"}` : returnType,\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tresolverInterface.addCallSignature({\n\t\t\t\t\t\tdocs: [` @deprecated: SDL ${modelName}.${resolver.name} does not exist in your schema`],\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t\tfunction createParentAdditionallyDefinedFunctions() {\n", "\t\t\tconst fns: string[] = []\n\t\t\t\tmodelFacts.resolvers.forEach((resolver) => {\n\t\t\t\t\tconst existsInGraphQLSchema = fields[resolver.name]\n\t\t\t\t\tif (!existsInGraphQLSchema) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`The service file ${filename} has a field ${resolver.name} on ${modelName} that does not exist in the generated schema.graphql`\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tconst prefix = !existsInGraphQLSchema ? \"\\n// This field does not exist in the generated schema.graphql\\n\" : \"\"\n\t\t\t\t\tconst returnType = returnTypeForResolver(externalMapper, existsInGraphQLSchema, resolver)\n", "\t\t\t\t// fns.push(`${prefix}${resolver.name}: () => Promise<${externalMapper.map(type, {})}>`)\n\t\t\t\t\tfns.push(`${prefix}${resolver.name}: () => ${returnType}`)\n\t\t\t\t})\n\t\t\t\tif (fns.length < 1) return \"\"\n\t\t\t\treturn \"& {\" + fns.join(\", \\n\") + \"}\"\n\t\t\t}\n\t\t\tfieldFacts.set(modelName, modelFieldFacts)\n\t\t}\n\t\treturn dtsFilename\n\t}\n", "function returnTypeForResolver(mapper: TypeMapper, field: graphql.GraphQLField<unknown, unknown> | undefined, resolver: ResolverFuncFact) {\n\t\tif (!field) return \"void\"\n\t\tconst tType = mapper.map(field.type, { preferNullOverUndefined: true, typenamePrefix: \"RT\" }) ?? \"void\"\n\t\tlet returnType = tType\n\t\tconst all = `${tType} | Promise<${tType}> | (() => Promise<${tType}>)`\n\t\tif (resolver.isFunc && resolver.isAsync) returnType = `Promise<${tType}>`\n\t\telse if (resolver.isFunc) returnType = all\n\t\telse if (resolver.isObjLiteral) returnType = tType\n\t\telse if (resolver.isUnknown) returnType = all\n\t\treturn returnType\n", "}\n"]}
{"filename": "src/formatDTS.ts", "chunked_list": ["// https://prettier.io/docs/en/api.html\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tlet prettier: any | null = null\n\ttry {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\tprettier = await import(\"prettier\")\n\t} catch (er) {\n\t\tconsole.error(er)\n\t\tprettier = null\n\t}\n", "export const getPrettierConfig = (path: string): unknown => {\n\t\tif (!prettier) return {}\n\t\t// I confirmed that this lookup hits caches in Redwood\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\t\tconst opts = prettier.default.resolveConfig.sync(path) ?? {}\n\t\treturn opts\n\t}\n\texport const formatDTS = (path: string, content: string, config: unknown): string => {\n\t\tif (!prettier) return content\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n", "\treturn prettier.default.format(content, { ...(config as object), filepath: path }) as string\n\t}\n"]}
{"filename": "src/cli.ts", "chunked_list": ["// import { parse, path } from \"./deps.ts\";\n\t// import { run } from \"./run.ts\";\n\t// const args = parse(Deno.args, {\n\t//   boolean: [\n\t//     \"eslint-fix\",\n\t//     \"rm-default-api-types\",\n\t//   ],\n\t// });\n\t// const params = args._;\n\t// let appRoot = Deno.cwd();\n", "// if (params.length > 0) {\n\t//   appRoot = path.join(Deno.cwd(), params[0] as string);\n\t// }\n\t// let types = path.join(appRoot, \"api/src/lib/types\");\n\t// if (params.length > 1) {\n\t//   types = path.join(Deno.cwd(), params[1] as string);\n\t// }\n\t// run(appRoot, types, {\n\t//   runESLint: !!args[\"eslint-fix\"],\n\t//   deleteOldGraphQLDTS: !!args[\"rm-default-api-types\"],\n", "// });\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import * as graphql from \"graphql\"\n\timport * as tsMorph from \"ts-morph\"\n\timport { TypeMapper } from \"./typeMap.js\"\n\texport const varStartsWithUppercase = (v: tsMorph.VariableDeclaration) => v.getName()[0].startsWith(v.getName()[0].toUpperCase())\n\texport const nameDoesNotStartsWithUnderscore = (v: tsMorph.VariableDeclaration) => !v.getName()[0].startsWith(\"_\")\n\texport const capitalizeFirstLetter = (str: string) => str.charAt(0).toUpperCase() + str.slice(1)\n\texport const variableDeclarationIsAsync = (vd: tsMorph.VariableDeclaration) => {\n\t\tconst res = !!vd.getFirstChildByKind(tsMorph.SyntaxKind.AsyncKeyword)\n\t\treturn res\n\t}\n", "export const inlineArgsForField = (field: graphql.GraphQLField<unknown, unknown>, config: { mapper: TypeMapper[\"map\"] }) => {\n\t\treturn field.args.length\n\t\t\t? // Always use an args obj\n\t\t\t  `{${field.args\n\t\t\t\t\t.map((f) => {\n\t\t\t\t\t\tconst type = config.mapper(f.type, {})\n\t\t\t\t\t\tif (!type) throw new Error(`No type for ${f.name} on ${field.name}!`)\n\t\t\t\t\t\tconst q = type.includes(\"undefined\") ? \"?\" : \"\"\n\t\t\t\t\t\tconst displayType = type.replace(\"| undefined\", \"\")\n\t\t\t\t\t\treturn `${f.name}${q}: ${displayType}`\n", "\t\t\t\t})\n\t\t\t\t\t.join(\", \")}}`\n\t\t\t: undefined\n\t}\n\texport const createAndReferOrInlineArgsForField = (\n\t\tfield: graphql.GraphQLField<unknown, unknown>,\n\t\tconfig: {\n\t\t\tfile: tsMorph.SourceFile\n\t\t\tmapper: TypeMapper[\"map\"]\n\t\t\tname: string\n", "\t\tnoSeparateType?: true\n\t\t}\n\t) => {\n\t\tconst inlineArgs = inlineArgsForField(field, config)\n\t\tif (!inlineArgs) return undefined\n\t\tif (inlineArgs.length < 120) return inlineArgs\n\t\tconst argsInterface = config.file.addInterface({\n\t\t\tname: `${config.name}Args`,\n\t\t\tisExported: true,\n\t\t})\n", "\tfield.args.forEach((a) => {\n\t\t\targsInterface.addProperty({\n\t\t\t\tname: a.name,\n\t\t\t\ttype: config.mapper(a.type, {}),\n\t\t\t})\n\t\t})\n\t\treturn `${config.name}Args`\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { getSchema as getPrismaSchema } from \"@mrleebo/prisma-ast\"\n\timport * as graphql from \"graphql\"\n\timport { Project } from \"ts-morph\"\n\timport typescript from \"typescript\"\n\timport { AppContext } from \"./context.js\"\n\timport { PrismaMap, prismaModeller } from \"./prismaModeller.js\"\n\timport { lookAtServiceFile } from \"./serviceFile.js\"\n\timport { createSharedSchemaFiles } from \"./sharedSchema.js\"\n\timport { CodeFacts, FieldFacts } from \"./typeFacts.js\"\n\timport { RedwoodPaths } from \"./types.js\"\n", "export * from \"./main.js\"\n\texport * from \"./types.js\"\n\timport { basename, join } from \"node:path\"\n\t/** The API specifically for Redwood */\n\texport function runFullCodegen(preset: \"redwood\", config: { paths: RedwoodPaths }): { paths: string[] }\n\texport function runFullCodegen(preset: string, config: unknown): { paths: string[] }\n\texport function runFullCodegen(preset: string, config: unknown): { paths: string[] } {\n\t\tif (preset !== \"redwood\") throw new Error(\"Only Redwood codegen is supported at this time\")\n\t\tconst paths = (config as { paths: RedwoodPaths }).paths\n\t\tconst sys = typescript.sys\n", "\tconst pathSettings: AppContext[\"pathSettings\"] = {\n\t\t\troot: paths.base,\n\t\t\tapiServicesPath: paths.api.services,\n\t\t\tprismaDSLPath: paths.api.dbSchema,\n\t\t\tgraphQLSchemaPath: paths.generated.schema,\n\t\t\tsharedFilename: \"shared-schema-types.d.ts\",\n\t\t\tsharedInternalFilename: \"shared-return-types.d.ts\",\n\t\t\ttypesFolderRoot: paths.api.types,\n\t\t}\n\t\tconst project = new Project({ useInMemoryFileSystem: true })\n", "\tlet gqlSchema: graphql.GraphQLSchema | undefined\n\t\tconst getGraphQLSDLFromFile = (settings: AppContext[\"pathSettings\"]) => {\n\t\t\tconst schema = sys.readFile(settings.graphQLSchemaPath)\n\t\t\tif (!schema) throw new Error(\"No schema found at \" + settings.graphQLSchemaPath)\n\t\t\tgqlSchema = graphql.buildSchema(schema)\n\t\t}\n\t\tlet prismaSchema: PrismaMap = new Map()\n\t\tconst getPrismaSchemaFromFile = (settings: AppContext[\"pathSettings\"]) => {\n\t\t\tconst prismaSchemaText = sys.readFile(settings.prismaDSLPath)\n\t\t\tif (!prismaSchemaText) throw new Error(\"No prisma file found at \" + settings.prismaDSLPath)\n", "\t\tconst prismaSchemaBlocks = getPrismaSchema(prismaSchemaText)\n\t\t\tprismaSchema = prismaModeller(prismaSchemaBlocks)\n\t\t}\n\t\tgetGraphQLSDLFromFile(pathSettings)\n\t\tgetPrismaSchemaFromFile(pathSettings)\n\t\tif (!gqlSchema) throw new Error(\"No GraphQL Schema was created during setup\")\n\t\tconst appContext: AppContext = {\n\t\t\tgql: gqlSchema,\n\t\t\tprisma: prismaSchema,\n\t\t\ttsProject: project,\n", "\t\tcodeFacts: new Map<string, CodeFacts>(),\n\t\t\tfieldFacts: new Map<string, FieldFacts>(),\n\t\t\tpathSettings,\n\t\t\tsys,\n\t\t\tjoin,\n\t\t\tbasename,\n\t\t}\n\t\t// TODO: Maybe Redwood has an API for this? Its grabbing all the services\n\t\tconst serviceFiles = appContext.sys.readDirectory(appContext.pathSettings.apiServicesPath)\n\t\tconst serviceFilesToLookAt = serviceFiles.filter((file) => {\n", "\t\tif (file.endsWith(\".test.ts\")) return false\n\t\t\tif (file.endsWith(\"scenarios.ts\")) return false\n\t\t\treturn file.endsWith(\".ts\") || file.endsWith(\".tsx\") || file.endsWith(\".js\")\n\t\t})\n\t\tconst filepaths = [] as string[]\n\t\t// Create the two shared schema files\n\t\tconst sharedDTSes = createSharedSchemaFiles(appContext)\n\t\tfilepaths.push(...sharedDTSes)\n\t\t// This needs to go first, as it sets up fieldFacts\n\t\tfor (const path of serviceFilesToLookAt) {\n", "\t\tconst dts = lookAtServiceFile(path, appContext)\n\t\t\tif (dts) filepaths.push(dts)\n\t\t}\n\t\treturn {\n\t\t\tpaths: filepaths,\n\t\t}\n\t}\n"]}
{"filename": "src/ambient.d.ts", "chunked_list": ["declare module \"prettier\"\n"]}
{"filename": "src/serviceFile.codefacts.ts", "chunked_list": ["import * as tsMorph from \"ts-morph\"\n\timport { AppContext } from \"./context.js\"\n\timport { CodeFacts, ModelResolverFacts, ResolverFuncFact } from \"./typeFacts.js\"\n\timport { varStartsWithUppercase } from \"./utils.js\"\n\texport const getCodeFactsForJSTSFileAtPath = (file: string, context: AppContext) => {\n\t\tconst { pathSettings: settings } = context\n\t\tconst fileKey = file.replace(settings.apiServicesPath, \"\")\n\t\t// const priorFacts = serviceInfo.get(fileKey)\n\t\tconst fileFact: CodeFacts = {}\n\t\tconst fileContents = context.sys.readFile(file)\n", "\tconst referenceFileSourceFile = context.tsProject.createSourceFile(`/source/${fileKey}`, fileContents, { overwrite: true })\n\t\tconst vars = referenceFileSourceFile.getVariableDeclarations().filter((v) => v.isExported())\n\t\tconst resolverContainers = vars.filter(varStartsWithUppercase)\n\t\tconst queryOrMutationResolvers = vars.filter((v) => !varStartsWithUppercase(v))\n\t\tqueryOrMutationResolvers.forEach((v) => {\n\t\t\tconst parent = \"maybe_query_mutation\"\n\t\t\tconst facts = getResolverInformationForDeclaration(v.getInitializer())\n\t\t\t// Start making facts about the services\n\t\t\tconst fact: ModelResolverFacts = fileFact[parent] ?? {\n\t\t\t\ttypeName: parent,\n", "\t\t\tresolvers: new Map(),\n\t\t\t\thasGenericArg: false,\n\t\t\t}\n\t\t\tfact.resolvers.set(v.getName(), { name: v.getName(), ...facts })\n\t\t\tfileFact[parent] = fact\n\t\t})\n\t\t// Next all the capital consts\n\t\tresolverContainers.forEach((c) => {\n\t\t\taddCustomTypeResolvers(c)\n\t\t})\n", "\treturn fileFact\n\t\tfunction addCustomTypeResolvers(variableDeclaration: tsMorph.VariableDeclaration) {\n\t\t\tconst declarations = variableDeclaration.getVariableStatementOrThrow().getDeclarations()\n\t\t\tdeclarations.forEach((d) => {\n\t\t\t\tconst name = d.getName()\n\t\t\t\t// only do it if the first letter is a capital\n\t\t\t\tif (!name.match(/^[A-Z]/)) return\n\t\t\t\tconst type = d.getType()\n\t\t\t\tconst hasGenericArg = type.getText().includes(\"<\")\n\t\t\t\t// Start making facts about the services\n", "\t\t\tconst fact: ModelResolverFacts = fileFact[name] ?? {\n\t\t\t\t\ttypeName: name,\n\t\t\t\t\tresolvers: new Map(),\n\t\t\t\t\thasGenericArg,\n\t\t\t\t}\n\t\t\t\t// Grab the const Thing = { ... }\n\t\t\t\tconst obj = d.getFirstDescendantByKind(tsMorph.SyntaxKind.ObjectLiteralExpression)\n\t\t\t\tif (!obj) {\n\t\t\t\t\tthrow new Error(`Could not find an object literal ( e.g. a { } ) in ${d.getName()}`)\n\t\t\t\t}\n", "\t\t\tobj.getProperties().forEach((p) => {\n\t\t\t\t\tif (p.isKind(tsMorph.SyntaxKind.SpreadAssignment)) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (p.isKind(tsMorph.SyntaxKind.PropertyAssignment) && p.hasInitializer()) {\n\t\t\t\t\t\tconst name = p.getName()\n\t\t\t\t\t\tfact.resolvers.set(name, { name, ...getResolverInformationForDeclaration(p.getInitializerOrThrow()) })\n\t\t\t\t\t}\n\t\t\t\t\tif (p.isKind(tsMorph.SyntaxKind.FunctionDeclaration) && p.getName()) {\n\t\t\t\t\t\tconst name = p.getName()\n", "\t\t\t\t\t// @ts-expect-error - lets let this go for now\n\t\t\t\t\t\tfact.resolvers.set(name, { name, ...getResolverInformationForDeclaration(p) })\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tfileFact[d.getName()] = fact\n\t\t\t})\n\t\t}\n\t}\n\tconst getResolverInformationForDeclaration = (initialiser: tsMorph.Expression | undefined): Omit<ResolverFuncFact, \"name\"> => {\n\t\t// Who knows what folks could do, lets not crash\n", "\tif (!initialiser) {\n\t\t\treturn {\n\t\t\t\tfuncArgCount: 0,\n\t\t\t\tisFunc: false,\n\t\t\t\tisAsync: false,\n\t\t\t\tisUnknown: true,\n\t\t\t\tisObjLiteral: false,\n\t\t\t}\n\t\t}\n\t\t// resolver is a fn\n", "\tif (initialiser.isKind(tsMorph.SyntaxKind.ArrowFunction) || initialiser.isKind(tsMorph.SyntaxKind.FunctionExpression)) {\n\t\t\treturn {\n\t\t\t\tfuncArgCount: initialiser.getParameters().length,\n\t\t\t\tisFunc: true,\n\t\t\t\tisAsync: initialiser.isAsync(),\n\t\t\t\tisUnknown: false,\n\t\t\t\tisObjLiteral: false,\n\t\t\t}\n\t\t}\n\t\t// resolver is a raw obj\n", "\tif (\n\t\t\tinitialiser.isKind(tsMorph.SyntaxKind.ObjectLiteralExpression) ||\n\t\t\tinitialiser.isKind(tsMorph.SyntaxKind.StringLiteral) ||\n\t\t\tinitialiser.isKind(tsMorph.SyntaxKind.NumericLiteral) ||\n\t\t\tinitialiser.isKind(tsMorph.SyntaxKind.TrueKeyword) ||\n\t\t\tinitialiser.isKind(tsMorph.SyntaxKind.FalseKeyword) ||\n\t\t\tinitialiser.isKind(tsMorph.SyntaxKind.NullKeyword) ||\n\t\t\tinitialiser.isKind(tsMorph.SyntaxKind.UndefinedKeyword)\n\t\t) {\n\t\t\treturn {\n", "\t\t\tfuncArgCount: 0,\n\t\t\t\tisFunc: false,\n\t\t\t\tisAsync: false,\n\t\t\t\tisUnknown: false,\n\t\t\t\tisObjLiteral: true,\n\t\t\t}\n\t\t}\n\t\t// who knows\n\t\treturn {\n\t\t\tfuncArgCount: 0,\n", "\t\tisFunc: false,\n\t\t\tisAsync: false,\n\t\t\tisUnknown: true,\n\t\t\tisObjLiteral: false,\n\t\t}\n\t}\n"]}
{"filename": "src/context.ts", "chunked_list": ["import * as graphql from \"graphql\"\n\timport * as tsMorph from \"ts-morph\"\n\timport { FormatCodeSettings, System } from \"typescript\"\n\timport { PrismaMap } from \"./prismaModeller.js\"\n\timport { CodeFacts, FieldFacts } from \"./typeFacts.js\"\n\texport interface AppContext {\n\t\t/** POSIX-y fn not built into System */\n\t\tbasename: (path: string) => string\n\t\t/** \"service\" should be code here */\n\t\tcodeFacts: Map<string, CodeFacts>\n", "\t/** A global set of facts about resolvers focused from the GQL side  */\n\t\tfieldFacts: Map<string, FieldFacts>\n\t\t/** When we emit .d.ts files, it runs the ts formatter over the file first - you can override the default settings  */\n\t\tformatCodeSettings?: FormatCodeSettings\n\t\t/** So you can override the formatter */\n\t\tgql: graphql.GraphQLSchema\n\t\t/** POSXIY- fn not built into System */\n\t\tjoin: (...paths: string[]) => string\n\t\t/** Where to find particular files */\n\t\tpathSettings: {\n", "\t\tapiServicesPath: string\n\t\t\tgraphQLSchemaPath: string\n\t\t\tprismaDSLPath: string\n\t\t\troot: string\n\t\t\tsharedFilename: string\n\t\t\tsharedInternalFilename: string\n\t\t\ttypesFolderRoot: string\n\t\t}\n\t\t/** A map of prisma models */\n\t\tprisma: PrismaMap\n", "\t/** An implementation of the TypeScript system, this can be grabbed pretty\n\t\t * easily from the typescript import, or you can use your own like tsvfs in browsers.\n\t\t */\n\t\tsys: System\n\t\t/** ts-morph is used to abstract over the typescript compiler API, this project file\n\t\t * is a slightly augmented version of the typescript Project api.\n\t\t */\n\t\ttsProject: tsMorph.Project\n\t}\n"]}
{"filename": "src/tests/serviceFile.test.ts", "chunked_list": ["import { readFileSync } from \"fs\"\n\timport { expect, it } from \"vitest\"\n\timport { getCodeFactsForJSTSFileAtPath } from \"../serviceFile.codefacts.js\"\n\timport { lookAtServiceFile } from \"../serviceFile.js\"\n\timport { getDTSFilesForRun } from \"./testRunner.js\"\n\tit(\"reads a service file\", () => {\n\t\tconst { appContext, vfsMap } = getDTSFilesForRun({})\n\t\tvfsMap.set(\n\t\t\t\"/api/src/services/example.ts\",\n\t\t\t`\n", "export const game = () => {}\n\texport function game2() {}\n\t    `\n\t\t)\n\t\texpect(vfsMap.has(\"/types/example.d.ts\")).toBeFalsy()\n\t\tlookAtServiceFile(\"/api/src/services/example.ts\", appContext)\n\t\t// this isn't really very useful as a test, but it proves it doesn't crash?\n\t})\n\tit(\"generates useful service facts from a (truncated) real file\", () => {\n\t\tconst { appContext, vfsMap } = getDTSFilesForRun({})\n", "\tvfsMap.set(\"/api/src/services/userProfile.ts\", readFileSync(\"./src/tests/vendor/puzzmo/one-offs/userProfiles.ts\", \"utf8\"))\n\t\tconst facts = getCodeFactsForJSTSFileAtPath(\"/api/src/services/userProfile.ts\", appContext)\n\t\texpect(facts).toMatchInlineSnapshot(`\n\t\t\t{\n\t\t\t  \"UserProfile\": {\n\t\t\t    \"hasGenericArg\": false,\n\t\t\t    \"resolvers\": Map {\n\t\t\t      \"id\" => {\n\t\t\t        \"funcArgCount\": 2,\n\t\t\t        \"isAsync\": false,\n", "\t\t        \"isFunc\": true,\n\t\t\t        \"isObjLiteral\": false,\n\t\t\t        \"isUnknown\": false,\n\t\t\t        \"name\": \"id\",\n\t\t\t      },\n\t\t\t      \"user\" => {\n\t\t\t        \"funcArgCount\": 2,\n\t\t\t        \"isAsync\": false,\n\t\t\t        \"isFunc\": true,\n\t\t\t        \"isObjLiteral\": false,\n", "\t\t        \"isUnknown\": false,\n\t\t\t        \"name\": \"user\",\n\t\t\t      },\n\t\t\t    },\n\t\t\t    \"typeName\": \"UserProfile\",\n\t\t\t  },\n\t\t\t  \"maybe_query_mutation\": {\n\t\t\t    \"hasGenericArg\": false,\n\t\t\t    \"resolvers\": Map {\n\t\t\t      \"updateUserProfile\" => {\n", "\t\t        \"funcArgCount\": 1,\n\t\t\t        \"isAsync\": false,\n\t\t\t        \"isFunc\": true,\n\t\t\t        \"isObjLiteral\": false,\n\t\t\t        \"isUnknown\": false,\n\t\t\t        \"name\": \"updateUserProfile\",\n\t\t\t      },\n\t\t\t      \"addLeaderboardToUserProfile\" => {\n\t\t\t        \"funcArgCount\": 1,\n\t\t\t        \"isAsync\": true,\n", "\t\t        \"isFunc\": true,\n\t\t\t        \"isObjLiteral\": false,\n\t\t\t        \"isUnknown\": false,\n\t\t\t        \"name\": \"addLeaderboardToUserProfile\",\n\t\t\t      },\n\t\t\t      \"removeLeaderboardFromUserProfile\" => {\n\t\t\t        \"funcArgCount\": 1,\n\t\t\t        \"isAsync\": true,\n\t\t\t        \"isFunc\": true,\n\t\t\t        \"isObjLiteral\": false,\n", "\t\t        \"isUnknown\": false,\n\t\t\t        \"name\": \"removeLeaderboardFromUserProfile\",\n\t\t\t      },\n\t\t\t      \"deleteUserProfile\" => {\n\t\t\t        \"funcArgCount\": 1,\n\t\t\t        \"isAsync\": false,\n\t\t\t        \"isFunc\": true,\n\t\t\t        \"isObjLiteral\": false,\n\t\t\t        \"isUnknown\": false,\n\t\t\t        \"name\": \"deleteUserProfile\",\n", "\t\t      },\n\t\t\t    },\n\t\t\t    \"typeName\": \"maybe_query_mutation\",\n\t\t\t  },\n\t\t\t}\n\t\t`)\n\t})\n"]}
{"filename": "src/tests/testRunner.ts", "chunked_list": ["import { getSchema as getPrismaSchema } from \"@mrleebo/prisma-ast\"\n\timport { createSystem } from \"@typescript/vfs\"\n\timport { buildSchema } from \"graphql\"\n\timport { basename, join } from \"path\"\n\timport { Project } from \"ts-morph\"\n\timport { AppContext } from \"../context.js\"\n\timport { prismaModeller } from \"../prismaModeller.js\"\n\timport { lookAtServiceFile } from \"../serviceFile.js\"\n\timport type { CodeFacts, FieldFacts } from \"../typeFacts.js\"\n\tinterface Run {\n", "\tgamesService?: string\n\t\tprismaSchema?: string\n\t\tsdl?: string\n\t}\n\texport function getDTSFilesForRun(run: Run) {\n\t\tconst prisma = getPrismaSchema(run.prismaSchema ?? \"\")\n\t\tlet gqlSDL = run.sdl ?? \"\"\n\t\tif (!gqlSDL.includes(\"type Query\")) gqlSDL += \"type Query { _: String }\\n\"\n\t\tif (!gqlSDL.includes(\"type Mutation\")) gqlSDL += \"type Mutation { __: String }\"\n\t\tconst schema = buildSchema(gqlSDL)\n", "\tconst project = new Project({ useInMemoryFileSystem: true })\n\t\tconst vfsMap = new Map<string, string>()\n\t\tconst vfs = createSystem(vfsMap)\n\t\tconst appContext: AppContext = {\n\t\t\tgql: schema,\n\t\t\tprisma: prismaModeller(prisma),\n\t\t\ttsProject: project,\n\t\t\tfieldFacts: new Map<string, FieldFacts>(),\n\t\t\tcodeFacts: new Map<string, CodeFacts>(),\n\t\t\tpathSettings: {\n", "\t\t\troot: \"/\",\n\t\t\t\tgraphQLSchemaPath: \"/.redwood/schema.graphql\",\n\t\t\t\tapiServicesPath: \"/api/src/services\",\n\t\t\t\tprismaDSLPath: \"/api/db/schema.prisma\",\n\t\t\t\tsharedFilename: \"shared-schema-types.d.ts\",\n\t\t\t\tsharedInternalFilename: \"shared-return-types.d.ts\",\n\t\t\t\ttypesFolderRoot: \"/types\",\n\t\t\t},\n\t\t\tsys: vfs,\n\t\t\tbasename,\n", "\t\tjoin,\n\t\t}\n\t\tif (run.gamesService) {\n\t\t\tvfsMap.set(\"/api/src/services/games.ts\", run.gamesService)\n\t\t\tlookAtServiceFile(\"/api/src/services/games.ts\", appContext)\n\t\t}\n\t\treturn {\n\t\t\tvfsMap,\n\t\t\tappContext,\n\t\t}\n", "}\n\texport const graphql = (strings: TemplateStringsArray): string => strings[0]\n\texport const prisma = (strings: TemplateStringsArray): string => strings[0]\n"]}
{"filename": "src/tests/features/warnOnSuperfluousResolvers.test.ts", "chunked_list": ["import { expect, it } from \"vitest\"\n\timport { getDTSFilesForRun, graphql, prisma } from \"../testRunner.js\"\n\tit(\"It prints a warning, and doesn't crash when you have resolvers which exist but are not on the parent\", () => {\n\t\tconst prismaSchema = prisma`\n\tmodel Game {\n\t    id            Int          @id @default(autoincrement())\n\t    homeTeamID    Int\n\t    awayTeamID    Int\n\t}\n\t`\n", "\tconst sdl = graphql`\n\t\t\ttype Game {\n\t\t\t\tid: Int!\n\t\t\t\thomeTeamId: Int!\n\t\t\t\tawayTeamId: Int!\n\t\t\t}\n\t\t`\n\t\tconst services = `\n\timport { db } from \"src/lib/db\";\n\texport const Game: GameResolvers = {\n", "    someRandomThing: () => \"hello\"\n\t};\n\t`\n\t\tconst { vfsMap } = getDTSFilesForRun({ sdl, gamesService: services, prismaSchema })\n\t\texpect(vfsMap.get(\"/types/games.d.ts\")!).toContain(\"// This field does not exist in the generated schema.graphql\\n\")\n\t})\n"]}
{"filename": "src/tests/features/supportGenericExtension.test.ts", "chunked_list": ["import { expect, it } from \"vitest\"\n\timport { getDTSFilesForRun, graphql, prisma } from \"../testRunner.js\"\n\tit(\"It allows you to add a generic parameter\", () => {\n\t\tconst prismaSchema = prisma`\n\tmodel Game {\n\t    id            Int          @id @default(autoincrement())\n\t    homeTeamID    Int\n\t    awayTeamID    Int\n\t}\n\t`\n", "\tconst sdl = graphql`\n\t\t\ttype Game {\n\t\t\t\tid: Int!\n\t\t\t\thomeTeamId: Int!\n\t\t\t\tawayTeamId: Int!\n\t\t\t}\n\t\t`\n\t\tconst services = `\n\timport { db } from \"src/lib/db\";\n\texport const Game: GameResolvers<{ type: string }> = {};\n", "`\n\t\tconst { vfsMap } = getDTSFilesForRun({ sdl, gamesService: services, prismaSchema })\n\t\texpect(vfsMap.get(\"/types/games.d.ts\")!).toContain(\"interface GameTypeResolvers<Extended>\")\n\t\texpect(vfsMap.get(\"/types/games.d.ts\")!).toContain(\"GameAsParent<Extended> = PGame & Extended\")\n\t\texpect(vfsMap.get(\"/types/games.d.ts\"))!.toMatchInlineSnapshot(`\n\t\t\t\"import type { Game as PGame } from \\\\\"@prisma/client\\\\\";\n\t\t\texport interface GameTypeResolvers<Extended> {}\n\t\t\ttype GameAsParent<Extended> = PGame & Extended;\n\t\t\t\"\n\t\t`)\n", "})\n"]}
{"filename": "src/tests/features/returnTypePositionsWhichPreferPrisma.test.ts", "chunked_list": ["import { expect, it } from \"vitest\"\n\timport { getDTSFilesForRun, graphql, prisma } from \"../testRunner.js\"\n\tit(\"supports a return position where a prisma object can be given, if the extra fn are defined as resolvers\", () => {\n\t\tconst prismaSchema = prisma`\n\tmodel Game {\n\t    id            Int          @id @default(autoincrement())\n\t    homeTeamID    Int\n\t    awayTeamID    Int\n\t}\n\t`\n", "\tconst sdl = graphql`\n\t\t\ttype Game {\n\t\t\t\tid: Int!\n\t\t\t\thomeTeamID: Int!\n\t\t\t\tawayTeamID: Int!\n\t\t\t\t# This is new, and _not_ on the prisma model\n\t\t\t\tsummary: String!\n\t\t\t}\n\t\t\ttype Query {\n\t\t\t\tgame: Game\n", "\t\t}\n\t\t`\n\t\tconst services = `\n\timport { db } from \"src/lib/db\";\n\texport const game = () => {}\n\texport const Game = {\n\t  summary: (_obj, { root }) => \"\"\n\t};\n\t`\n\t\tconst { vfsMap } = getDTSFilesForRun({ sdl, gamesService: services, prismaSchema })\n", "\tconst dts = vfsMap.get(\"/types/games.d.ts\")!\n\t\texpect(dts.trimStart()).toMatchInlineSnapshot(\n\t\t\t`\n\t\t\t\"import type { Game as PGame } from \\\\\"@prisma/client\\\\\";\n\t\t\timport type { GraphQLResolveInfo } from \\\\\"graphql\\\\\";\n\t\t\timport type { RedwoodGraphQLContext } from \\\\\"@redwoodjs/graphql-server/dist/types\\\\\";\n\t\t\timport type { Game as RTGame } from \\\\\"./shared-return-types\\\\\";\n\t\t\timport type { Query } from \\\\\"./shared-schema-types\\\\\";\n\t\t\t/** SDL: game: Game */\n\t\t\texport interface GameResolver {\n", "\t\t  (\n\t\t\t    args?: object,\n\t\t\t    obj?: {\n\t\t\t      root: Query;\n\t\t\t      context: RedwoodGraphQLContext;\n\t\t\t      info: GraphQLResolveInfo;\n\t\t\t    }\n\t\t\t  ): RTGame | null | Promise<RTGame | null> | (() => Promise<RTGame | null>);\n\t\t\t}\n\t\t\texport interface GameTypeResolvers {\n", "\t\t  /** SDL: summary: String! */\n\t\t\t  summary: (\n\t\t\t    args: undefined,\n\t\t\t    obj: {\n\t\t\t      root: GameAsParent;\n\t\t\t      context: RedwoodGraphQLContext;\n\t\t\t      info: GraphQLResolveInfo;\n\t\t\t    }\n\t\t\t  ) => string | Promise<string> | (() => Promise<string>);\n\t\t\t}\n", "\t\ttype GameAsParent = PGame & {\n\t\t\t  summary: () => string | Promise<string> | (() => Promise<string>);\n\t\t\t};\n\t\t\t\"\n\t\t`\n\t\t)\n\t})\n"]}
{"filename": "src/tests/features/preferPromiseFnWhenKnown.test.ts", "chunked_list": ["import { expect, it } from \"vitest\"\n\timport { getDTSFilesForRun, graphql, prisma } from \"../testRunner.js\"\n\tit(\"uses a rn to promise when we see an async tag\", () => {\n\t\tconst prismaSchema = prisma`\n\tmodel Game {\n\t    id            Int          @id @default(autoincrement())\n\t    homeTeamID    Int\n\t    awayTeamID    Int\n\t}\n\t`\n", "\tconst sdl = graphql`\n\t\t\ttype Game {\n\t\t\t\tid: Int!\n\t\t\t\thomeTeamID: Int!\n\t\t\t\tawayTeamID: Int!\n\t\t\t\tsummarySync: String!\n\t\t\t\tsummaryAsync: String!\n\t\t\t\tsummary: String!\n\t\t\t}\n\t\t\ttype Query {\n", "\t\t\tgameObj: Game\n\t\t\t\tgameSync: Game\n\t\t\t\tgameAsync: Game\n\t\t\t\tgameAsync1Arg: Game\n\t\t\t\tgameAsync2Arg: Game\n\t\t\t}\n\t\t`\n\t\tconst gamesService = `\n\timport { db } from \"src/lib/db\";\n\texport const gameSync = () => {}\n", "export const gameAsync = async () => {}\n\texport const gameAsync1Arg = (arg) => {}\n\texport const gameAsync2Arg = (arg, obj) => {}\n\texport const gameObj = {}\n\texport const Game = {\n\t  summary: \"\",\n\t  summarySync: () => \"\",\n\t  summaryAsync: async () => \"\"\n\t};\n\t`\n", "\tconst { vfsMap } = getDTSFilesForRun({ sdl, gamesService, prismaSchema })\n\t\tconst dts = vfsMap.get(\"/types/games.d.ts\")!\n\t\texpect(dts.trim()).toMatchInlineSnapshot(`\n\t\t\t\"import type { Game as PGame } from \\\\\"@prisma/client\\\\\";\n\t\t\timport type { GraphQLResolveInfo } from \\\\\"graphql\\\\\";\n\t\t\timport type { RedwoodGraphQLContext } from \\\\\"@redwoodjs/graphql-server/dist/types\\\\\";\n\t\t\timport type { Game as RTGame } from \\\\\"./shared-return-types\\\\\";\n\t\t\timport type { Query } from \\\\\"./shared-schema-types\\\\\";\n\t\t\t/** SDL: gameSync: Game */\n\t\t\texport interface GameSyncResolver {\n", "\t\t  (\n\t\t\t    args?: object,\n\t\t\t    obj?: {\n\t\t\t      root: Query;\n\t\t\t      context: RedwoodGraphQLContext;\n\t\t\t      info: GraphQLResolveInfo;\n\t\t\t    }\n\t\t\t  ): RTGame | null | Promise<RTGame | null> | (() => Promise<RTGame | null>);\n\t\t\t}\n\t\t\t/** SDL: gameAsync: Game */\n", "\t\texport interface GameAsyncResolver {\n\t\t\t  (\n\t\t\t    args?: object,\n\t\t\t    obj?: {\n\t\t\t      root: Query;\n\t\t\t      context: RedwoodGraphQLContext;\n\t\t\t      info: GraphQLResolveInfo;\n\t\t\t    }\n\t\t\t  ): Promise<RTGame | null>;\n\t\t\t}\n", "\t\t/** SDL: gameAsync1Arg: Game */\n\t\t\texport interface GameAsync1ArgResolver {\n\t\t\t  (\n\t\t\t    args: object,\n\t\t\t    obj?: {\n\t\t\t      root: Query;\n\t\t\t      context: RedwoodGraphQLContext;\n\t\t\t      info: GraphQLResolveInfo;\n\t\t\t    }\n\t\t\t  ): RTGame | null | Promise<RTGame | null> | (() => Promise<RTGame | null>);\n", "\t\t}\n\t\t\t/** SDL: gameAsync2Arg: Game */\n\t\t\texport interface GameAsync2ArgResolver {\n\t\t\t  (\n\t\t\t    args: object,\n\t\t\t    obj: {\n\t\t\t      root: Query;\n\t\t\t      context: RedwoodGraphQLContext;\n\t\t\t      info: GraphQLResolveInfo;\n\t\t\t    }\n", "\t\t  ): RTGame | null | Promise<RTGame | null> | (() => Promise<RTGame | null>);\n\t\t\t}\n\t\t\t/** SDL: gameObj: Game */\n\t\t\texport interface GameObjResolver {\n\t\t\t  (\n\t\t\t    args?: object,\n\t\t\t    obj?: {\n\t\t\t      root: Query;\n\t\t\t      context: RedwoodGraphQLContext;\n\t\t\t      info: GraphQLResolveInfo;\n", "\t\t    }\n\t\t\t  ): RTGame | null;\n\t\t\t}\n\t\t\texport interface GameTypeResolvers<Extended> {\n\t\t\t  /** SDL: summary: String! */\n\t\t\t  summary: string;\n\t\t\t  /** SDL: summarySync: String! */\n\t\t\t  summarySync: (\n\t\t\t    args?: undefined,\n\t\t\t    obj?: {\n", "\t\t      root: GameAsParent<Extended>;\n\t\t\t      context: RedwoodGraphQLContext;\n\t\t\t      info: GraphQLResolveInfo;\n\t\t\t    }\n\t\t\t  ) => string | Promise<string> | (() => Promise<string>);\n\t\t\t  /** SDL: summaryAsync: String! */\n\t\t\t  summaryAsync: (\n\t\t\t    args?: undefined,\n\t\t\t    obj?: {\n\t\t\t      root: GameAsParent<Extended>;\n", "\t\t      context: RedwoodGraphQLContext;\n\t\t\t      info: GraphQLResolveInfo;\n\t\t\t    }\n\t\t\t  ) => Promise<string>;\n\t\t\t}\n\t\t\ttype GameAsParent<Extended> = PGame & {\n\t\t\t  summary: () => string;\n\t\t\t  summarySync: () => string | Promise<string> | (() => Promise<string>);\n\t\t\t  summaryAsync: () => Promise<string>;\n\t\t\t} & Extended;\"\n", "\t`)\n\t})\n"]}
{"filename": "src/tests/vendor/soccersage-output/predictions.d.ts", "chunked_list": ["import type { CreatePredictionInput, UpdatePredictionInput } from \"./shared-schema-types\";\n\timport type { StandingsResult as RTStandingsResult, Prediction as RTPrediction, User as RTUser, Team as RTTeam, Game as RTGame } from \"./shared-return-types\";\n\timport type { User as PUser, Team as PTeam, Game as PGame, Prediction as PPrediction } from \"@prisma/client\";\n\timport type { GraphQLResolveInfo } from \"graphql\";\n\timport type { RedwoodGraphQLContext } from \"@redwoodjs/graphql-server/dist/functions/types\";\n\t/** SDL: standings(seasonId: Int!): StandingsResult */\n\texport interface StandingsResolver {\n\t  (args: { seasonId: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): Promise<RTStandingsResult | null>;\n\t}\n\t/** SDL: predictions: [Prediction!]! */\n", "export interface PredictionsResolver {\n\t  (args?: object, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction[] | Promise<RTPrediction[]> | (() => Promise<RTPrediction[]>);\n\t}\n\t/** SDL: myPredictions: [Prediction!]! */\n\texport interface MyPredictionsResolver {\n\t  (args: object, obj: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction[] | Promise<RTPrediction[]> | (() => Promise<RTPrediction[]>);\n\t}\n\t/** SDL: prediction(id: Int!): Prediction */\n\texport interface PredictionResolver {\n\t  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction | null | Promise<RTPrediction | null> | (() => Promise<RTPrediction | null>);\n", "}\n\t/** SDL: createPrediction(input: CreatePredictionInput!): Prediction! */\n\texport interface CreatePredictionResolver {\n\t  (args: { input: CreatePredictionInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction | Promise<RTPrediction> | (() => Promise<RTPrediction>);\n\t}\n\t/** SDL: updatePrediction(id: Int!, input: UpdatePredictionInput!): Prediction! */\n\texport interface UpdatePredictionResolver {\n\t  (args: { id: number, input: UpdatePredictionInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction | Promise<RTPrediction> | (() => Promise<RTPrediction>);\n\t}\n\t/** SDL: deletePrediction(id: Int!): Prediction! */\n", "export interface DeletePredictionResolver {\n\t  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTPrediction | Promise<RTPrediction> | (() => Promise<RTPrediction>);\n\t}\n\ttype PredictionAsParent = PPrediction & {\n\t  id: () => Promise<number>,\n\t  teamId: () => Promise<number | undefined>,\n\t  gameId: () => Promise<number>,\n\t  userId: () => Promise<number>,\n\t  prediction: () => Promise<string>,\n\t  user: () => Promise<PUser | undefined>,\n", "  team: () => Promise<PTeam | undefined>,\n\t  game: () => Promise<PGame>\n\t};\n\texport interface PredictionTypeResolvers {\n\t  /** SDL: id: Int! */\n\t  id: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\t  /** SDL: teamId: Int */\n\t  teamId: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | null | Promise<number | null> | (() => Promise<number | null>);\n\t  /** SDL: gameId: Int! */\n\t  gameId: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n", "  /** SDL: userId: Int! */\n\t  userId: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\t  /** SDL: prediction: String! */\n\t  prediction: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\t  /** SDL: user: User */\n\t  user: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTUser | null | Promise<RTUser | null> | (() => Promise<RTUser | null>);\n\t  /** SDL: team: Team */\n\t  team: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTTeam | null | Promise<RTTeam | null> | (() => Promise<RTTeam | null>);\n\t  /** SDL: game: Game! */\n\t  game: (args: undefined, obj: { root: PredictionAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTGame | Promise<RTGame> | (() => Promise<RTGame>);\n", "}\n"]}
{"filename": "src/tests/vendor/soccersage-output/games.d.ts", "chunked_list": ["import type { CreateGameInput, UpdateGameInput } from \"./shared-schema-types\";\n\timport type { Game as RTGame, Prediction as RTPrediction, Team as RTTeam, Season as RTSeason } from \"./shared-return-types\";\n\timport type { Prediction as PPrediction, Team as PTeam, Season as PSeason, Game as PGame } from \"@prisma/client\";\n\timport type { GraphQLResolveInfo } from \"graphql\";\n\timport type { RedwoodGraphQLContext } from \"@redwoodjs/graphql-server/dist/functions/types\";\n\t/** SDL: games: [Game!]! */\n\texport interface GamesResolver {\n\t  (args: object, obj: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame[] | Promise<RTGame[]> | (() => Promise<RTGame[]>);\n\t}\n\t/** SDL: upcomingGames: [Game!]! */\n", "export interface UpcomingGamesResolver {\n\t  (args?: object, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame[] | Promise<RTGame[]> | (() => Promise<RTGame[]>);\n\t}\n\t/** SDL: game(id: Int!): Game */\n\texport interface GameResolver {\n\t  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame | null | Promise<RTGame | null> | (() => Promise<RTGame | null>);\n\t}\n\t/** SDL: createGame(input: CreateGameInput!): Game! */\n\texport interface CreateGameResolver {\n\t  (args: { input: CreateGameInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame | Promise<RTGame> | (() => Promise<RTGame>);\n", "}\n\t/** SDL: updateGame(id: Int!, input: UpdateGameInput!): Game! */\n\texport interface UpdateGameResolver {\n\t  (args: { id: number, input: UpdateGameInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTGame | Promise<RTGame> | (() => Promise<RTGame>);\n\t}\n\t/** SDL: deleteGame(id: Int!): Game! */\n\texport interface DeleteGameResolver {\n\t  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): Promise<RTGame>;\n\t}\n\ttype GameAsParent<Extended> = PGame & {\n", "  predictions: () => Promise<Array<PPrediction>>,\n\t  homeTeam: () => Promise<PTeam>,\n\t  awayTeam: () => Promise<PTeam>,\n\t  season: () => Promise<PSeason>\n\t} & Extended;\n\texport interface GameTypeResolvers<Extended> {\n\t  /** SDL: predictions: [Prediction]! */\n\t  predictions: (args: undefined, obj: { root: GameAsParent<Extended>, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTPrediction> | Promise<Array<RTPrediction>> | (() => Promise<Array<RTPrediction>>);\n\t  /** SDL: homeTeam: Team! */\n\t  homeTeam: (args: undefined, obj: { root: GameAsParent<Extended>, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n", "  /** SDL: awayTeam: Team! */\n\t  awayTeam: (args: undefined, obj: { root: GameAsParent<Extended>, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n\t  /** SDL: season: Season! */\n\t  season: (args: undefined, obj: { root: GameAsParent<Extended>, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => RTSeason | Promise<RTSeason> | (() => Promise<RTSeason>);\n\t}\n"]}
{"filename": "src/tests/vendor/soccersage-output/shared-schema-types.d.ts", "chunked_list": ["export interface CreateGameInput {\n\t  __typename?: \"CreateGameInput\";\n\t  awayTeamId: number;\n\t  awayTeamScore?: number | null;\n\t  homeTeamId: number;\n\t  homeTeamScore?: number | null;\n\t  isCompleted?: boolean | null;\n\t  seasonId: number;\n\t  startDateTime: DateTime;\n\t}\n", "export interface CreatePredictionInput {\n\t  __typename?: \"CreatePredictionInput\";\n\t  gameId: number;\n\t  prediction: string;\n\t  seasonId: number;\n\t  teamId?: number | null;\n\t  userId: number;\n\t}\n\texport interface CreateSeasonInput {\n\t  __typename?: \"CreateSeasonInput\";\n", "  endDate: DateTime;\n\t  name: string;\n\t  startDate: DateTime;\n\t}\n\texport interface CreateTeamInput {\n\t  __typename?: \"CreateTeamInput\";\n\t  logoUrl?: string | null;\n\t  name: string;\n\t}\n\texport interface CreateUserInput {\n", "  __typename?: \"CreateUserInput\";\n\t  email: string;\n\t  hashedPassword: string;\n\t  resetToken?: string | null;\n\t  resetTokenExpiresAt?: DateTime | null;\n\t  roles: string;\n\t  salt: string;\n\t  username: string;\n\t}\n\texport interface Game {\n", "  __typename?: \"Game\";\n\t  awayTeam?: Team;\n\t  awayTeamId: number;\n\t  awayTeamScore?: number | null;\n\t  homeTeam?: Team;\n\t  homeTeamId: number;\n\t  homeTeamScore?: number | null;\n\t  id: number;\n\t  isCompleted: boolean;\n\t  predictions?: Array<Prediction>;\n", "  season?: Season;\n\t  seasonId: number;\n\t  startDateTime: DateTime;\n\t}\n\texport interface Mutation {\n\t  __typename?: \"Mutation\";\n\t  createGame: Game;\n\t  createPrediction: Prediction;\n\t  createSeason: Season;\n\t  createTeam: Team;\n", "  createUser: User;\n\t  deleteGame: Game;\n\t  deletePrediction: Prediction;\n\t  deleteSeason: Season;\n\t  deleteTeam: Team;\n\t  deleteUser: User;\n\t  resetPassword: User;\n\t  sendResetPasswordEmail?: SuccessInput | null;\n\t  updateGame: Game;\n\t  updatePrediction: Prediction;\n", "  updateSeason: Season;\n\t  updateTeam: Team;\n\t  updateUser: User;\n\t}\n\texport interface Prediction {\n\t  __typename?: \"Prediction\";\n\t  game?: Game;\n\t  gameId?: number;\n\t  id?: number;\n\t  prediction?: string;\n", "  team?: Team | null;\n\t  teamId?: number | null;\n\t  user?: User | null;\n\t  userId?: number;\n\t}\n\texport interface Query {\n\t  __typename?: \"Query\";\n\t  game?: Game | null;\n\t  games: Game[];\n\t  myPredictions: Prediction[];\n", "  prediction?: Prediction | null;\n\t  predictions: Prediction[];\n\t  redwood?: Redwood | null;\n\t  season?: Season | null;\n\t  seasons: Season[];\n\t  standings?: StandingsResult | null;\n\t  team?: Team | null;\n\t  teams: Team[];\n\t  upcomingGames: Game[];\n\t  user?: User | null;\n", "  users: User[];\n\t}\n\texport interface Redwood {\n\t  __typename?: \"Redwood\";\n\t  currentUser?: JSON | null;\n\t  prismaVersion?: string | null;\n\t  version?: string | null;\n\t}\n\texport interface Season {\n\t  __typename?: \"Season\";\n", "  Prediction?: Array<Prediction>;\n\t  endDate?: DateTime;\n\t  id?: number;\n\t  name?: string;\n\t  startDate?: DateTime;\n\t}\n\texport interface StandingsData {\n\t  __typename?: \"StandingsData\";\n\t  email: string;\n\t  score: number;\n", "  userId: string;\n\t  username: string;\n\t}\n\texport interface StandingsResult {\n\t  __typename?: \"StandingsResult\";\n\t  userIdRankings: StandingsData[];\n\t}\n\texport interface SuccessInput {\n\t  __typename?: \"SuccessInput\";\n\t  message?: string | null;\n", "  success?: boolean | null;\n\t}\n\texport interface Team {\n\t  __typename?: \"Team\";\n\t  Prediction?: Array<Prediction>;\n\t  awayTeamGames?: Array<Game>;\n\t  homeTeamGames?: Array<Game>;\n\t  id?: number;\n\t  logoUrl?: string | null;\n\t  name?: string;\n", "}\n\texport interface UpdateGameInput {\n\t  __typename?: \"UpdateGameInput\";\n\t  awayTeamId?: number | null;\n\t  awayTeamScore?: number | null;\n\t  homeTeamId?: number | null;\n\t  homeTeamScore?: number | null;\n\t  isCompleted?: boolean | null;\n\t  seasonId?: number | null;\n\t  startDateTime?: DateTime | null;\n", "}\n\texport interface UpdatePredictionInput {\n\t  __typename?: \"UpdatePredictionInput\";\n\t  gameId?: number | null;\n\t  prediction?: string | null;\n\t  teamId?: number | null;\n\t  userId?: number | null;\n\t}\n\texport interface UpdateSeasonInput {\n\t  __typename?: \"UpdateSeasonInput\";\n", "  endDate?: DateTime | null;\n\t  name?: string | null;\n\t  startDate?: DateTime | null;\n\t}\n\texport interface UpdateTeamInput {\n\t  __typename?: \"UpdateTeamInput\";\n\t  logoUrl?: string | null;\n\t  name?: string | null;\n\t}\n\texport interface UpdateUserInput {\n", "  __typename?: \"UpdateUserInput\";\n\t  email?: string | null;\n\t  hashedPassword?: string | null;\n\t  resetToken?: string | null;\n\t  resetTokenExpiresAt?: DateTime | null;\n\t  roles?: string | null;\n\t  salt?: string | null;\n\t  username?: string | null;\n\t}\n\texport interface User {\n", "  __typename?: \"User\";\n\t  email?: string;\n\t  hashedPassword?: string;\n\t  id?: number;\n\t  predictions?: Array<Prediction>;\n\t  resetToken?: string | null;\n\t  resetTokenExpiresAt?: DateTime | null;\n\t  roles?: string;\n\t  salt?: string;\n\t  username?: string;\n", "}\n\ttype DateTime = any;\n\ttype JSON = any;\n"]}
{"filename": "src/tests/vendor/soccersage-output/seasons.d.ts", "chunked_list": ["import type { CreateSeasonInput, UpdateSeasonInput } from \"./shared-schema-types\";\n\timport type { Season as RTSeason, Prediction as RTPrediction } from \"./shared-return-types\";\n\timport type { Prediction as PPrediction, Season as PSeason } from \"@prisma/client\";\n\timport type { GraphQLResolveInfo } from \"graphql\";\n\timport type { RedwoodGraphQLContext } from \"@redwoodjs/graphql-server/dist/functions/types\";\n\t/** SDL: seasons: [Season!]! */\n\texport interface SeasonsResolver {\n\t  (args?: object, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason[] | Promise<RTSeason[]> | (() => Promise<RTSeason[]>);\n\t}\n\t/** SDL: season(id: Int!): Season */\n", "export interface SeasonResolver {\n\t  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason | null | Promise<RTSeason | null> | (() => Promise<RTSeason | null>);\n\t}\n\t/** SDL: createSeason(input: CreateSeasonInput!): Season! */\n\texport interface CreateSeasonResolver {\n\t  (args: { input: CreateSeasonInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason | Promise<RTSeason> | (() => Promise<RTSeason>);\n\t}\n\t/** SDL: updateSeason(id: Int!, input: UpdateSeasonInput!): Season! */\n\texport interface UpdateSeasonResolver {\n\t  (args: { id: number, input: UpdateSeasonInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason | Promise<RTSeason> | (() => Promise<RTSeason>);\n", "}\n\t/** SDL: deleteSeason(id: Int!): Season! */\n\texport interface DeleteSeasonResolver {\n\t  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTSeason | Promise<RTSeason> | (() => Promise<RTSeason>);\n\t}\n\ttype SeasonAsParent = PSeason & {\n\t  id: () => Promise<number>,\n\t  name: () => Promise<string>,\n\t  startDate: () => Promise<DateTime>,\n\t  endDate: () => Promise<DateTime>,\n", "  Prediction: () => Promise<Array<PPrediction>>\n\t};\n\texport interface SeasonTypeResolvers {\n\t  /** SDL: id: Int! */\n\t  id: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\t  /** SDL: name: String! */\n\t  name: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\t  /** SDL: startDate: DateTime! */\n\t  startDate: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => DateTime | Promise<DateTime> | (() => Promise<DateTime>);\n\t  /** SDL: endDate: DateTime! */\n", "  endDate: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => DateTime | Promise<DateTime> | (() => Promise<DateTime>);\n\t  /** SDL: Prediction: [Prediction]! */\n\t  Prediction: (args: undefined, obj: { root: SeasonAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTPrediction> | Promise<Array<RTPrediction>> | (() => Promise<Array<RTPrediction>>);\n\t}\n\ttype DateTime = any;\n"]}
{"filename": "src/tests/vendor/soccersage-output/shared-return-types.d.ts", "chunked_list": ["import type { Game as PGame, Prediction as PPrediction, Season as PSeason, Team as PTeam, User as PUser } from \"@prisma/client\";\n\t// You may very reasonably ask yourself, 'what is this file?' and why do I need it.\n\t// Roughly, this file ensures that when a resolver wants to return a type - that\n\t// type will match a prisma model. This is useful because you can trivially extend\n\t// the type in the SDL and not have to worry about type mis-matches because the thing\n\t// you returned does not include those functions.\n\t// This gets particularly useful when you want to return a union type, an interface, \n\t// or a model where the prisma model is nested pretty deeply (connections, for example.)\n\texport interface CreateGameInput {\n\t  __typename?: \"CreateGameInput\";\n", "  awayTeamId: number;\n\t  awayTeamScore?: number | null;\n\t  homeTeamId: number;\n\t  homeTeamScore?: number | null;\n\t  isCompleted?: boolean | null;\n\t  seasonId: number;\n\t  startDateTime: DateTime;\n\t}\n\texport interface CreatePredictionInput {\n\t  __typename?: \"CreatePredictionInput\";\n", "  gameId: number;\n\t  prediction: string;\n\t  seasonId: number;\n\t  teamId?: number | null;\n\t  userId: number;\n\t}\n\texport interface CreateSeasonInput {\n\t  __typename?: \"CreateSeasonInput\";\n\t  endDate: DateTime;\n\t  name: string;\n", "  startDate: DateTime;\n\t}\n\texport interface CreateTeamInput {\n\t  __typename?: \"CreateTeamInput\";\n\t  logoUrl?: string | null;\n\t  name: string;\n\t}\n\texport interface CreateUserInput {\n\t  __typename?: \"CreateUserInput\";\n\t  email: string;\n", "  hashedPassword: string;\n\t  resetToken?: string | null;\n\t  resetTokenExpiresAt?: DateTime | null;\n\t  roles: string;\n\t  salt: string;\n\t  username: string;\n\t}\n\texport interface Mutation {\n\t  __typename?: \"Mutation\";\n\t  createGame: PGame;\n", "  createPrediction: PPrediction;\n\t  createSeason: PSeason;\n\t  createTeam: PTeam;\n\t  createUser: PUser;\n\t  deleteGame: PGame;\n\t  deletePrediction: PPrediction;\n\t  deleteSeason: PSeason;\n\t  deleteTeam: PTeam;\n\t  deleteUser: PUser;\n\t  resetPassword: PUser;\n", "  sendResetPasswordEmail?: SuccessInput | null;\n\t  updateGame: PGame;\n\t  updatePrediction: PPrediction;\n\t  updateSeason: PSeason;\n\t  updateTeam: PTeam;\n\t  updateUser: PUser;\n\t}\n\texport interface Query {\n\t  __typename?: \"Query\";\n\t  game?: PGame | null;\n", "  games: PGame[];\n\t  myPredictions: PPrediction[];\n\t  prediction?: PPrediction | null;\n\t  predictions: PPrediction[];\n\t  redwood?: Redwood | null;\n\t  season?: PSeason | null;\n\t  seasons: PSeason[];\n\t  standings?: StandingsResult | null;\n\t  team?: PTeam | null;\n\t  teams: PTeam[];\n", "  upcomingGames: PGame[];\n\t  user?: PUser | null;\n\t  users: PUser[];\n\t}\n\texport interface Redwood {\n\t  __typename?: \"Redwood\";\n\t  currentUser?: JSON | null;\n\t  prismaVersion?: string | null;\n\t  version?: string | null;\n\t}\n", "export interface StandingsData {\n\t  __typename?: \"StandingsData\";\n\t  email: string;\n\t  score: number;\n\t  userId: string;\n\t  username: string;\n\t}\n\texport interface StandingsResult {\n\t  __typename?: \"StandingsResult\";\n\t  userIdRankings: StandingsData[];\n", "}\n\texport interface SuccessInput {\n\t  __typename?: \"SuccessInput\";\n\t  message?: string | null;\n\t  success?: boolean | null;\n\t}\n\texport interface UpdateGameInput {\n\t  __typename?: \"UpdateGameInput\";\n\t  awayTeamId?: number | null;\n\t  awayTeamScore?: number | null;\n", "  homeTeamId?: number | null;\n\t  homeTeamScore?: number | null;\n\t  isCompleted?: boolean | null;\n\t  seasonId?: number | null;\n\t  startDateTime?: DateTime | null;\n\t}\n\texport interface UpdatePredictionInput {\n\t  __typename?: \"UpdatePredictionInput\";\n\t  gameId?: number | null;\n\t  prediction?: string | null;\n", "  teamId?: number | null;\n\t  userId?: number | null;\n\t}\n\texport interface UpdateSeasonInput {\n\t  __typename?: \"UpdateSeasonInput\";\n\t  endDate?: DateTime | null;\n\t  name?: string | null;\n\t  startDate?: DateTime | null;\n\t}\n\texport interface UpdateTeamInput {\n", "  __typename?: \"UpdateTeamInput\";\n\t  logoUrl?: string | null;\n\t  name?: string | null;\n\t}\n\texport interface UpdateUserInput {\n\t  __typename?: \"UpdateUserInput\";\n\t  email?: string | null;\n\t  hashedPassword?: string | null;\n\t  resetToken?: string | null;\n\t  resetTokenExpiresAt?: DateTime | null;\n", "  roles?: string | null;\n\t  salt?: string | null;\n\t  username?: string | null;\n\t}\n\ttype DateTime = any;\n\ttype JSON = any;\n\texport type Game = PGame;\n\texport type Prediction = PPrediction;\n\texport type Season = PSeason;\n\texport type Team = PTeam;\n", "export type User = PUser;\n"]}
{"filename": "src/tests/vendor/soccersage-output/users.d.ts", "chunked_list": ["import type { CreateUserInput, UpdateUserInput } from \"./shared-schema-types\";\n\timport type { User as RTUser, SuccessInput as RTSuccessInput, Prediction as RTPrediction } from \"./shared-return-types\";\n\timport type { Prediction as PPrediction, User as PUser } from \"@prisma/client\";\n\timport type { GraphQLResolveInfo } from \"graphql\";\n\timport type { RedwoodGraphQLContext } from \"@redwoodjs/graphql-server/dist/functions/types\";\n\t/** SDL: users: [User!]! */\n\texport interface UsersResolver {\n\t  (args?: object, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser[] | Promise<RTUser[]> | (() => Promise<RTUser[]>);\n\t}\n\t/** SDL: user(id: Int!): User */\n", "export interface UserResolver {\n\t  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser | null | Promise<RTUser | null> | (() => Promise<RTUser | null>);\n\t}\n\t/** SDL: createUser(input: CreateUserInput!): User! */\n\texport interface CreateUserResolver {\n\t  (args: { input: CreateUserInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser | Promise<RTUser> | (() => Promise<RTUser>);\n\t}\n\t/** SDL: updateUser(id: Int!, input: UpdateUserInput!): User! */\n\texport interface UpdateUserResolver {\n\t  (args: { id: number, input: UpdateUserInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser | Promise<RTUser> | (() => Promise<RTUser>);\n", "}\n\t/** SDL: deleteUser(id: Int!): User! */\n\texport interface DeleteUserResolver {\n\t  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTUser | Promise<RTUser> | (() => Promise<RTUser>);\n\t}\n\t/** SDL: sendResetPasswordEmail(email: String!): SuccessInput */\n\texport interface SendResetPasswordEmailResolver {\n\t  (args: { email: string }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): Promise<RTSuccessInput | null>;\n\t}\n\t/** SDL: resetPassword(password: String!, resetToken: String!): User! */\n", "export interface ResetPasswordResolver {\n\t  (args: { password: string, resetToken: string }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): Promise<RTUser>;\n\t}\n\ttype UserAsParent = PUser & {\n\t  id: () => Promise<number>,\n\t  email: () => Promise<string>,\n\t  username: () => Promise<string>,\n\t  hashedPassword: () => Promise<string>,\n\t  resetToken: () => Promise<string | undefined>,\n\t  resetTokenExpiresAt: () => Promise<DateTime | undefined>,\n", "  salt: () => Promise<string>,\n\t  roles: () => Promise<string>,\n\t  predictions: () => Promise<Array<PPrediction>>\n\t};\n\texport interface UserTypeResolvers {\n\t  /** SDL: id: Int! */\n\t  id: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\t  /** SDL: email: String! */\n\t  email: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\t  /** SDL: username: String! */\n", "  username: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\t  /** SDL: hashedPassword: String! */\n\t  hashedPassword: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\t  /** SDL: resetToken: String */\n\t  resetToken: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | null | Promise<string | null> | (() => Promise<string | null>);\n\t  /** SDL: resetTokenExpiresAt: DateTime */\n\t  resetTokenExpiresAt: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => DateTime | null | Promise<DateTime | null> | (() => Promise<DateTime | null>);\n\t  /** SDL: salt: String! */\n\t  salt: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\t  /** SDL: roles: String! */\n", "  roles: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\t  /** SDL: predictions: [Prediction]! */\n\t  predictions: (args: undefined, obj: { root: UserAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTPrediction> | Promise<Array<RTPrediction>> | (() => Promise<Array<RTPrediction>>);\n\t}\n\ttype DateTime = any;\n"]}
{"filename": "src/tests/vendor/soccersage-output/teams.d.ts", "chunked_list": ["import type { CreateTeamInput, UpdateTeamInput } from \"./shared-schema-types\";\n\timport type { Team as RTTeam, Prediction as RTPrediction, Game as RTGame } from \"./shared-return-types\";\n\timport type { Prediction as PPrediction, Game as PGame, Team as PTeam } from \"@prisma/client\";\n\timport type { GraphQLResolveInfo } from \"graphql\";\n\timport type { RedwoodGraphQLContext } from \"@redwoodjs/graphql-server/dist/functions/types\";\n\t/** SDL: teams: [Team!]! */\n\texport interface TeamsResolver {\n\t  (args?: object, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam[] | Promise<RTTeam[]> | (() => Promise<RTTeam[]>);\n\t}\n\t/** SDL: team(id: Int!): Team */\n", "export interface TeamResolver {\n\t  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam | null | Promise<RTTeam | null> | (() => Promise<RTTeam | null>);\n\t}\n\t/** SDL: createTeam(input: CreateTeamInput!): Team! */\n\texport interface CreateTeamResolver {\n\t  (args: { input: CreateTeamInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n\t}\n\t/** SDL: updateTeam(id: Int!, input: UpdateTeamInput!): Team! */\n\texport interface UpdateTeamResolver {\n\t  (args: { id: number, input: UpdateTeamInput }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n", "}\n\t/** SDL: deleteTeam(id: Int!): Team! */\n\texport interface DeleteTeamResolver {\n\t  (args: { id: number }, obj?: { root: object, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }): RTTeam | Promise<RTTeam> | (() => Promise<RTTeam>);\n\t}\n\ttype TeamAsParent = PTeam & {\n\t  id: () => Promise<number>,\n\t  name: () => Promise<string>,\n\t  logoUrl: () => Promise<string | undefined>,\n\t  Prediction: () => Promise<Array<PPrediction>>,\n", "  homeTeamGames: () => Promise<Array<PGame>>,\n\t  awayTeamGames: () => Promise<Array<PGame>>\n\t};\n\texport interface TeamTypeResolvers {\n\t  /** SDL: id: Int! */\n\t  id: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => number | Promise<number> | (() => Promise<number>);\n\t  /** SDL: name: String! */\n\t  name: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | Promise<string> | (() => Promise<string>);\n\t  /** SDL: logoUrl: String */\n\t  logoUrl: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => string | null | Promise<string | null> | (() => Promise<string | null>);\n", "  /** SDL: Prediction: [Prediction]! */\n\t  Prediction: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTPrediction> | Promise<Array<RTPrediction>> | (() => Promise<Array<RTPrediction>>);\n\t  /** SDL: homeTeamGames: [Game]! */\n\t  homeTeamGames: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTGame> | Promise<Array<RTGame>> | (() => Promise<Array<RTGame>>);\n\t  /** SDL: awayTeamGames: [Game]! */\n\t  awayTeamGames: (args: undefined, obj: { root: TeamAsParent, context: RedwoodGraphQLContext, info: GraphQLResolveInfo }) => Array<RTGame> | Promise<Array<RTGame>> | (() => Promise<Array<RTGame>>);\n\t}\n"]}
{"filename": "src/tests/vendor/puzzmo/one-offs/userProfiles.ts", "chunked_list": ["// @ts-ignore\n\timport { dnull } from \"dnull\"\n\timport { db } from \"src/lib/db\"\n\timport {\n\t\tUpdateUserProfileResolver,\n\t\tDeleteUserProfileResolver,\n\t\tUserProfileTypeResolvers,\n\t\tAddLeaderboardToUserProfileResolver,\n\t\tRemoveLeaderboardFromUserProfileResolver,\n\t} from \"src/lib/types/userProfiles\"\n", "export const updateUserProfile: UpdateUserProfileResolver = ({ input, id }) => {}\n\texport const addLeaderboardToUserProfile: AddLeaderboardToUserProfileResolver = async ({ leaderboardStableID }) => {}\n\texport const removeLeaderboardFromUserProfile: RemoveLeaderboardFromUserProfileResolver = async ({ leaderboardStableID }) => {}\n\texport const deleteUserProfile: DeleteUserProfileResolver = (args) => {\n\t\tconst { id } = args\n\t\treturn db.userProfile.delete({ where: { userID: id.replace(\":userprofile\", \"\") } })\n\t}\n\texport const UserProfile: UserProfileTypeResolvers = {\n\t\tid: (_, { root }) => root.userID + \":userprofile\",\n\t\tuser: (_obj, { root }) => db.user.findFirst({ where: { id: root.userID } }),\n", "}\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/graphql/teams.sdl.ts", "chunked_list": ["export const schema = gql`\n\t    type Team {\n\t        id: Int!\n\t        name: String!\n\t        logoUrl: String\n\t        Prediction: [Prediction]!\n\t        homeTeamGames: [Game]!\n\t        awayTeamGames: [Game]!\n\t    }\n\t    type Query {\n", "        teams: [Team!]! @requireAuth\n\t        team(id: Int!): Team @requireAuth\n\t    }\n\t    input CreateTeamInput {\n\t        name: String!\n\t        logoUrl: String\n\t    }\n\t    input UpdateTeamInput {\n\t        name: String\n\t        logoUrl: String\n", "    }\n\t    type Mutation {\n\t        createTeam(input: CreateTeamInput!): Team! @requireAuth\n\t        updateTeam(id: Int!, input: UpdateTeamInput!): Team! @requireAuth\n\t        deleteTeam(id: Int!): Team! @requireAuth\n\t    }\n\t`;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/graphql/games.sdl.ts", "chunked_list": ["export const schema = gql`\n\t    type Game {\n\t        id: Int!\n\t        homeTeamId: Int!\n\t        awayTeamId: Int!\n\t        seasonId: Int!\n\t        homeTeamScore: Int\n\t        awayTeamScore: Int\n\t        isCompleted: Boolean!\n\t        predictions: [Prediction]!\n", "        homeTeam: Team!\n\t        awayTeam: Team!\n\t        season: Season!\n\t        startDateTime: DateTime!\n\t        # This does not exist in prisma, and would\n\t        # screw up a return type of db.game in many places\n\t        teamsWhoPredictedHomeWin: [Team!]!\n\t    }\n\t    type Query {\n\t        games: [Game!]! @skipAuth\n", "        upcomingGames: [Game!]! @skipAuth\n\t        game(id: Int!): Game @requireAuth\n\t    }\n\t    input CreateGameInput {\n\t        homeTeamId: Int!\n\t        awayTeamId: Int!\n\t        seasonId: Int!\n\t        startDateTime: DateTime!\n\t        homeTeamScore: Int\n\t        awayTeamScore: Int\n", "        isCompleted: Boolean\n\t    }\n\t    input UpdateGameInput {\n\t        homeTeamId: Int\n\t        awayTeamId: Int\n\t        homeTeamScore: Int\n\t        awayTeamScore: Int\n\t        seasonId: Int\n\t        isCompleted: Boolean\n\t        startDateTime: DateTime\n", "    }\n\t    type Mutation {\n\t        createGame(input: CreateGameInput!): Game! @requireAuth\n\t        updateGame(id: Int!, input: UpdateGameInput!): Game! @requireAuth\n\t        deleteGame(id: Int!): Game! @requireAuth\n\t    }\n\t`;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/graphql/users.sdl.ts", "chunked_list": ["export const schema = gql`\n\t    type User {\n\t        id: Int!\n\t        username: String!\n\t        email: String!\n\t        hashedPassword: String!\n\t        salt: String!\n\t        resetToken: String\n\t        resetTokenExpiresAt: DateTime\n\t        roles: String!\n", "        predictions: [Prediction]!\n\t    }\n\t    type Query {\n\t        users: [User!]! @requireAuth\n\t        user(id: Int!): User @requireAuth\n\t    }\n\t    input CreateUserInput {\n\t        email: String!\n\t        username: String!\n\t        hashedPassword: String!\n", "        salt: String!\n\t        resetToken: String\n\t        resetTokenExpiresAt: DateTime\n\t        roles: String!\n\t    }\n\t    input UpdateUserInput {\n\t        username: String\n\t        email: String\n\t        hashedPassword: String\n\t        salt: String\n", "        resetToken: String\n\t        resetTokenExpiresAt: DateTime\n\t        roles: String\n\t    }\n\t    type SuccessInput {\n\t        success: Boolean\n\t        message: String\n\t    }\n\t    type Mutation {\n\t        createUser(input: CreateUserInput!): User! @requireAuth\n", "        updateUser(id: Int!, input: UpdateUserInput!): User! @requireAuth\n\t        deleteUser(id: Int!): User! @requireAuth\n\t        sendResetPasswordEmail(email: String!): SuccessInput @skipAuth\n\t        resetPassword(resetToken: String!, password: String!): User! @skipAuth\n\t    }\n\t`;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/graphql/seasons.sdl.ts", "chunked_list": ["export const schema = gql`\n\t    type Season {\n\t        id: Int!\n\t        name: String!\n\t        startDate: DateTime!\n\t        endDate: DateTime!\n\t        Prediction: [Prediction]!\n\t    }\n\t    type Query {\n\t        seasons: [Season!]! @requireAuth\n", "        season(id: Int!): Season @requireAuth\n\t    }\n\t    input CreateSeasonInput {\n\t        name: String!\n\t        startDate: DateTime!\n\t        endDate: DateTime!\n\t    }\n\t    input UpdateSeasonInput {\n\t        name: String\n\t        startDate: DateTime\n", "        endDate: DateTime\n\t    }\n\t    type Mutation {\n\t        createSeason(input: CreateSeasonInput!): Season! @requireAuth\n\t        updateSeason(id: Int!, input: UpdateSeasonInput!): Season! @requireAuth\n\t        deleteSeason(id: Int!): Season! @requireAuth\n\t    }\n\t`;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/graphql/predictions.sdl.ts", "chunked_list": ["export const schema = gql`\n\t    type Prediction {\n\t        id: Int!\n\t        userId: Int!\n\t        gameId: Int!\n\t        teamId: Int\n\t        prediction: String!\n\t        team: Team\n\t        game: Game!\n\t        user: User\n", "    }\n\t    type StandingsData {\n\t        userId: String!\n\t        username: String!\n\t        email: String!\n\t        score: Int!\n\t    }\n\t    type StandingsResult {\n\t        userIdRankings: [StandingsData!]!\n\t    }\n", "    type Query {\n\t        predictions: [Prediction!]! @requireAuth\n\t        myPredictions: [Prediction!]! @requireAuth\n\t        prediction(id: Int!): Prediction @requireAuth\n\t        standings(seasonId: Int!): StandingsResult @skipAuth\n\t    }\n\t    input CreatePredictionInput {\n\t        userId: Int!\n\t        gameId: Int!\n\t        seasonId: Int!\n", "        teamId: Int\n\t        prediction: String!\n\t    }\n\t    input UpdatePredictionInput {\n\t        userId: Int\n\t        gameId: Int\n\t        teamId: Int\n\t        prediction: String\n\t    }\n\t    type Mutation {\n", "        createPrediction(input: CreatePredictionInput!): Prediction!\n\t            @requireAuth\n\t        updatePrediction(id: Int!, input: UpdatePredictionInput!): Prediction!\n\t            @requireAuth\n\t        deletePrediction(id: Int!): Prediction! @requireAuth\n\t    }\n\t`;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/seasons/seasons.ts", "chunked_list": ["import type {\n\t    QueryResolvers,\n\t    MutationResolvers,\n\t    SeasonResolvers,\n\t} from 'types/graphql';\n\timport { db } from 'src/lib/db';\n\texport const seasons: QueryResolvers['seasons'] = () => {\n\t    return db.season.findMany();\n\t};\n\texport const season: QueryResolvers['season'] = ({ id }) => {\n", "    return db.season.findUnique({\n\t        where: { id },\n\t    });\n\t};\n\texport const createSeason: MutationResolvers['createSeason'] = ({ input }) => {\n\t    return db.season.create({\n\t        data: input,\n\t    });\n\t};\n\texport const updateSeason: MutationResolvers['updateSeason'] = ({\n", "    id,\n\t    input,\n\t}) => {\n\t    return db.season.update({\n\t        data: input,\n\t        where: { id },\n\t    });\n\t};\n\texport const deleteSeason: MutationResolvers['deleteSeason'] = ({ id }) => {\n\t    return db.season.delete({\n", "        where: { id },\n\t    });\n\t};\n\texport const Season: SeasonResolvers = {\n\t    id: (_obj, { root }) => root.id,\n\t    name: (_obj, { root }) => root.name,\n\t    startDate: (_obj, { root }) => root.startDate,\n\t    endDate: (_obj, { root }) => root.endDate,\n\t    Prediction: (_obj, { root }) =>\n\t        db.season.findUnique({ where: { id: root.id } }).Prediction(),\n", "};\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/seasons/seasons.scenarios.ts", "chunked_list": ["import type { Prisma } from '@prisma/client';\n\texport const standard = defineScenario<Prisma.SeasonCreateArgs>({\n\t    season: {\n\t        one: {\n\t            data: {\n\t                name: 'String2358270',\n\t                startDate: '2022-06-29T23:14:20Z',\n\t                endDate: '2022-06-29T23:14:20Z',\n\t            },\n\t        },\n", "        two: {\n\t            data: {\n\t                name: 'String9676386',\n\t                startDate: '2022-06-29T23:14:20Z',\n\t                endDate: '2022-06-29T23:14:20Z',\n\t            },\n\t        },\n\t    },\n\t});\n\texport type StandardScenario = typeof standard;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/users/users.ts", "chunked_list": ["import crypto from \"crypto\"\n\timport { addDays } from \"date-fns\"\n\timport nodemailer from \"nodemailer\"\n\timport type { MutationResolvers, QueryResolvers, UserResolvers } from \"types/graphql\"\n\timport { hashPassword } from \"@redwoodjs/api\"\n\timport { RedwoodGraphQLError } from \"@redwoodjs/graphql-server\"\n\timport { db } from \"src/lib/db\"\n\timport { generateResetPasswordToken } from \"src/lib/generate-reset-password-token\"\n\tconst transporter = nodemailer.createTransport({\n\t\tservice: \"gmail\",\n", "\tauth: {\n\t\t\tuser: process.env.EMAIL_USER,\n\t\t\tpass: process.env.EMAIL_PASS,\n\t\t},\n\t})\n\texport const users: QueryResolvers[\"users\"] = () => {\n\t\treturn db.user.findMany()\n\t}\n\texport const user: QueryResolvers[\"user\"] = ({ id }) => {\n\t\treturn db.user.findUnique({\n", "\t\twhere: { id },\n\t\t})\n\t}\n\texport const createUser: MutationResolvers[\"createUser\"] = ({ input }) => {\n\t\treturn db.user.create({\n\t\t\tdata: input,\n\t\t})\n\t}\n\texport const updateUser: MutationResolvers[\"updateUser\"] = ({ id, input }) => {\n\t\treturn db.user.update({\n", "\t\tdata: input,\n\t\t\twhere: { id },\n\t\t})\n\t}\n\texport const deleteUser: MutationResolvers[\"deleteUser\"] = ({ id }) => {\n\t\treturn db.user.delete({\n\t\t\twhere: { id },\n\t\t})\n\t}\n\texport const sendResetPasswordEmail: MutationResolvers[\"sendResetPasswordEmail\"] = async ({ email }) => {\n", "\tconst lowerCaseEmail = email.toLowerCase()\n\t\tconsole.log(\"Received ID to email to reset: \" + lowerCaseEmail)\n\t\tconst associatedUser = await db.user.findUnique({\n\t\t\twhere: { email: lowerCaseEmail },\n\t\t})\n\t\tif (!associatedUser) {\n\t\t\tconsole.log(\"Could not find associated user\")\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: \"Could not find user with email: \" + lowerCaseEmail,\n", "\t\t}\n\t\t}\n\t\tconst resetToken = generateResetPasswordToken(16)\n\t\tawait db.user.update({\n\t\t\twhere: { email: lowerCaseEmail },\n\t\t\tdata: { resetToken, resetTokenExpiresAt: addDays(new Date(), 1) },\n\t\t})\n\t\tconsole.log(\"Prepping mail options\")\n\t\tconst resetPasswordLink = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`\n\t\tconst mailOptions = {\n", "\t\tfrom: process.env.EMAIL_USER,\n\t\t\tto: lowerCaseEmail,\n\t\t\tsubject: \"Please Reset Your Passowrd\",\n\t\t\thtml: `You are receiveing this because you have requested to reseet your password at predictor.io.\n\t            Please click on the following link, or paste this into your browser to complete the process: <br>\n\t            <a href=\"${resetPasswordLink}\">${resetPasswordLink}</a><br><br>\n\t            If you did not request this, please respond to ${process.env.EMAIL_USER} and delete the email.`,\n\t\t}\n\t\tconsole.log(\"Sending reset password email\")\n\t\ttry {\n", "\t\tawait transporter.sendMail(mailOptions)\n\t\t} catch (error) {\n\t\t\tconst errorMessage = \"An unknown error occurred when sending reset password email: \" + error\n\t\t\tconsole.error(errorMessage)\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: errorMessage,\n\t\t\t}\n\t\t}\n\t\tconsole.log(\"Reset password email sent\")\n", "\treturn {\n\t\t\tsuccess: true,\n\t\t\tmessage: \"An email has been sent to: \" + lowerCaseEmail + \". Please check your inbox.\",\n\t\t}\n\t}\n\texport const resetPassword: MutationResolvers[\"resetPassword\"] = async ({ resetToken, password }) => {\n\t\tconst associatedUser = await db.user.findFirst({\n\t\t\twhere: { resetToken },\n\t\t})\n\t\tif (associatedUser.resetToken !== resetToken) {\n", "\t\tthrow new RedwoodGraphQLError(\"Could not find user with reset token.\")\n\t\t}\n\t\tconst salt = crypto.randomBytes(16).toString(\"base64\")\n\t\tconst [hashedPassword] = hashPassword(password, salt)\n\t\treturn await db.user.update({\n\t\t\twhere: {\n\t\t\t\tid: associatedUser.id,\n\t\t\t},\n\t\t\tdata: {\n\t\t\t\thashedPassword,\n", "\t\t\tsalt,\n\t\t\t\tresetToken: null,\n\t\t\t},\n\t\t})\n\t}\n\texport const User: UserResolvers = {\n\t\tid: (_obj, { root }) => root.id,\n\t\temail: (_obj, { root }) => root.email,\n\t\tusername: (_obj, { root }) => root.username,\n\t\thashedPassword: (_obj, { root }) => root.hashedPassword,\n", "\tresetToken: (_obj, { root }) => root.resetToken,\n\t\tresetTokenExpiresAt: (_obj, { root }) => root.resetTokenExpiresAt,\n\t\tsalt: (_obj, { root }) => root.salt,\n\t\troles: (_obj, { root }) => root.roles,\n\t\tpredictions: (_obj, { root }) => db.user.findUnique({ where: { id: root.id } }).predictions(),\n\t}\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/users/users.scenarios.ts", "chunked_list": ["import type { Prisma } from '@prisma/client';\n\texport const standard = defineScenario<Prisma.UserCreateArgs>({\n\t    user: {\n\t        one: {\n\t            data: {\n\t                username: 'test',\n\t                email: 'String8843735',\n\t                hashedPassword: 'String',\n\t                salt: 'String',\n\t                roles: 'String',\n", "            },\n\t        },\n\t        two: {\n\t            data: {\n\t                username: 'test2',\n\t                email: 'String9261536',\n\t                hashedPassword: 'String',\n\t                salt: 'String',\n\t                roles: 'String',\n\t            },\n", "        },\n\t    },\n\t});\n\texport type StandardScenario = typeof standard;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/teams/teams.ts", "chunked_list": ["import type {\n\t    QueryResolvers,\n\t    MutationResolvers,\n\t    TeamResolvers,\n\t} from 'types/graphql';\n\timport { db } from 'src/lib/db';\n\texport const teams: QueryResolvers['teams'] = () => {\n\t    return db.team.findMany();\n\t};\n\texport const team: QueryResolvers['team'] = ({ id }) => {\n", "    return db.team.findUnique({\n\t        where: { id },\n\t    });\n\t};\n\texport const createTeam: MutationResolvers['createTeam'] = ({ input }) => {\n\t    return db.team.create({\n\t        data: input,\n\t    });\n\t};\n\texport const updateTeam: MutationResolvers['updateTeam'] = ({ id, input }) => {\n", "    return db.team.update({\n\t        data: input,\n\t        where: { id },\n\t    });\n\t};\n\texport const deleteTeam: MutationResolvers['deleteTeam'] = ({ id }) => {\n\t    return db.team.delete({\n\t        where: { id },\n\t    });\n\t};\n", "export const Team: TeamResolvers = {\n\t    id: (_obj, { root }) => root.id,\n\t    name: (_obj, { root }) => root.name,\n\t    logoUrl: (_obj, { root }) => root.logoUrl,\n\t    Prediction: (_obj, { root }) =>\n\t        db.team.findUnique({ where: { id: root.id } }).Prediction(),\n\t    homeTeamGames: (_obj, { root }) =>\n\t        db.team.findUnique({ where: { id: root.id } }).homeTeamGames(),\n\t    awayTeamGames: (_obj, { root }) =>\n\t        db.team.findUnique({ where: { id: root.id } }).awayTeamGames(),\n", "};\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/teams/teams.scenarios.ts", "chunked_list": ["import type { Prisma } from '@prisma/client';\n\texport const standard = defineScenario<Prisma.TeamCreateArgs>({\n\t    team: {\n\t        one: { data: { name: 'String7701370' } },\n\t        two: { data: { name: 'String3485322' } },\n\t    },\n\t});\n\texport type StandardScenario = typeof standard;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/games/games.ts", "chunked_list": ["import type {\n\t  CreateGameResolver,\n\t  DeleteGameResolver,\n\t  GameResolver,\n\t  GamesResolver,\n\t  UpcomingGamesResolver,\n\t  UpdateGameResolver,\n\t} from \"../../../../../soccersage-output/games.d.ts\";\n\timport { db } from \"src/lib/db\";\n\texport const games: GamesResolver = (args, obj) => {\n", "  return db.game.findMany({\n\t    orderBy: {\n\t      startDateTime: \"asc\",\n\t    },\n\t  });\n\t};\n\texport const upcomingGames: UpcomingGamesResolver = () => {\n\t  return db.game.findMany({\n\t    where: { isCompleted: false, startDateTime: { gt: new Date() } },\n\t  });\n", "};\n\texport const game: GameResolver = ({ id }) => {\n\t  return db.game.findUnique({\n\t    where: { id },\n\t  });\n\t};\n\texport const createGame: CreateGameResolver = ({ input }) => {\n\t  return db.game.create({\n\t    data: input,\n\t  });\n", "};\n\texport const updateGame: UpdateGameResolver = ({ id, input }) => {\n\t  return db.game.update({\n\t    data: input,\n\t    where: { id },\n\t  });\n\t};\n\texport const deleteGame: DeleteGameResolver = async ({ id }) => {\n\t  await db.prediction.deleteMany({\n\t    where: { gameId: id },\n", "  });\n\t  return db.game.delete({\n\t    where: { id },\n\t  });\n\t};\n\texport const Game: GameResolvers<{ predictions?: any[] }> = {\n\t  predictions: (_obj, { root }) => db.game.findUnique({ where: { id: root.id } }).predictions(),\n\t  homeTeam: (_obj, { root }) => db.game.findUnique({ where: { id: root.id } }).homeTeam(),\n\t  awayTeam: (_obj, { root }) => db.game.findUnique({ where: { id: root.id } }).awayTeam(),\n\t  season: (_obj, { root }) => db.game.findUnique({ where: { id: root.id } }).season(),\n", "};\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/games/games.scenarios.ts", "chunked_list": ["import type { Prisma } from '@prisma/client';\n\texport const standard = defineScenario<Prisma.GameCreateArgs>({\n\t    game: {\n\t        one: {\n\t            data: {\n\t                homeTeam: { create: { name: 'String8184842' } },\n\t                awayTeam: { create: { name: 'String342092' } },\n\t                startDateTime: new Date(),\n\t                season: {\n\t                    create: {\n", "                        name: 'String8184842',\n\t                        startDate: new Date(),\n\t                        endDate: new Date(),\n\t                    },\n\t                },\n\t            },\n\t        },\n\t        two: {\n\t            data: {\n\t                homeTeam: { create: { name: 'String2664163' } },\n", "                awayTeam: { create: { name: 'String9522390' } },\n\t                startDateTime: new Date(),\n\t                season: {\n\t                    create: {\n\t                        name: 'String9522390',\n\t                        startDate: new Date(),\n\t                        endDate: new Date(),\n\t                    },\n\t                },\n\t            },\n", "        },\n\t    },\n\t});\n\texport type StandardScenario = typeof standard;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/predictions/predictions.scenarios.ts", "chunked_list": ["import type { Prisma } from '@prisma/client';\n\texport const standard = defineScenario<Prisma.PredictionCreateArgs>({\n\t    prediction: {\n\t        one: {\n\t            data: {\n\t                user: {\n\t                    create: {\n\t                        username: 'test',\n\t                        email: 'test1',\n\t                        hashedPassword: 'test',\n", "                        salt: 'test',\n\t                        roles: 'test',\n\t                    },\n\t                },\n\t                prediction: 'String',\n\t                game: {\n\t                    create: {\n\t                        homeTeamScore: 5278373,\n\t                        awayTeamScore: 9262607,\n\t                        homeTeam: { create: { name: 'String3223999' } },\n", "                        awayTeam: { create: { name: 'String5108965' } },\n\t                        startDateTime: new Date('2022-10-27'),\n\t                        season: {\n\t                            create: {\n\t                                name: 'String5108965',\n\t                                startDate: new Date(),\n\t                                endDate: new Date(),\n\t                            },\n\t                        },\n\t                    },\n", "                },\n\t                season: {\n\t                    create: {\n\t                        name: 'Test season 1',\n\t                        startDate: new Date('2022-05-01'),\n\t                        endDate: new Date('2022-05-31'),\n\t                    },\n\t                },\n\t            },\n\t        },\n", "        two: {\n\t            data: {\n\t                user: {\n\t                    create: {\n\t                        username: 'test2',\n\t                        email: 'test2',\n\t                        hashedPassword: 'test',\n\t                        salt: 'test',\n\t                        roles: 'test',\n\t                    },\n", "                },\n\t                prediction: 'String',\n\t                game: {\n\t                    create: {\n\t                        homeTeamScore: 2210328,\n\t                        awayTeamScore: 4786303,\n\t                        homeTeam: { create: { name: 'String2218724' } },\n\t                        awayTeam: { create: { name: 'String3400904' } },\n\t                        startDateTime: new Date('2022-06-01'),\n\t                        season: {\n", "                            create: {\n\t                                name: 'String3400904',\n\t                                startDate: new Date(),\n\t                                endDate: new Date(),\n\t                            },\n\t                        },\n\t                    },\n\t                },\n\t                season: {\n\t                    create: {\n", "                        name: 'Test season 2',\n\t                        startDate: new Date('2022-06-01'),\n\t                        endDate: new Date('2022-06-30'),\n\t                    },\n\t                },\n\t            },\n\t        },\n\t    },\n\t});\n\texport type StandardScenario = typeof standard;\n"]}
{"filename": "src/tests/vendor/soccersage.io-main/api/src/services/predictions/predictions.ts", "chunked_list": ["import type {\n\t    Game,\n\t    MutationResolvers,\n\t    Prediction as PredictionType,\n\t    PredictionResolvers,\n\t    QueryResolvers,\n\t    User,\n\t} from 'types/graphql';\n\timport { getFirstUserFromContext } from 'src/lib/auth';\n\timport { db } from 'src/lib/db';\n", "type PartialGame = Omit<\n\t    Game,\n\t    'homeTeam' | 'awayTeam' | 'predictions' | 'season'\n\t>;\n\ttype PartialUser = Omit<User, 'predictions' | 'resetTokenExpiresAt'>;\n\ttype PartialPrediction = Omit<PredictionType, 'game' | 'user'> & {\n\t    game: PartialGame;\n\t    user: PartialUser;\n\t};\n\t//TODO: Re-use these functions from the PredictionCard\n", "const getWinningTeamId = (game: PartialGame) => {\n\t    if (game.homeTeamScore > game.awayTeamScore) {\n\t        return game.homeTeamId;\n\t    } else if (game.awayTeamScore > game.homeTeamScore) {\n\t        return game.awayTeamId;\n\t    }\n\t    return null;\n\t};\n\tconst getPredictionStatus = (\n\t    prediction: PartialPrediction\n", "): 'incomplete' | 'correct' | 'incorrect' => {\n\t    if (!prediction.game.isCompleted) {\n\t        return 'incomplete';\n\t    }\n\t    const winningTeamId = getWinningTeamId(prediction.game);\n\t    return winningTeamId === prediction.teamId ? 'correct' : 'incorrect';\n\t};\n\texport const standings: QueryResolvers['standings'] = async ({ seasonId }) => {\n\t    // TODO: This logic finds all predictions, and includes the associated game for each prediction.\n\t    // While this works with small amounts of data, this will not scale very well, due to the\n", "    // re-retrieval of game data for each prediction.\n\t    // Other options to consider if/when more users join:\n\t    // 1. - Query for all predictions in a season and all games in a season concurrently.\n\t    //   a. - This is still not as performant as possible, but would reduce duplicate data and retain live standings.\n\t    // 2. - Store standings in a separate schema, and have a CRON job that updates them once an hour.\n\t    //   a. - This would allow for a much more performant solution, but would remove the ability to have live standings.\n\t    const predictions = await db.prediction.findMany({\n\t        where: { seasonId },\n\t        include: {\n\t            game: true,\n", "            user: true,\n\t        },\n\t    });\n\t    const userPredictionMap = predictions.reduce<{\n\t        [key: string]: PartialPrediction[];\n\t    }>((acc, prediction) => {\n\t        if (acc[prediction.userId]) {\n\t            acc[prediction.userId].push(prediction);\n\t        } else {\n\t            acc[prediction.userId] = [prediction];\n", "        }\n\t        return acc;\n\t    }, {});\n\t    // TODO: Define the exact scoring algorithm that we would like to use\n\t    const userIdRankings = Object.entries(userPredictionMap).map(\n\t        ([userId, predictions]) => {\n\t            const { email, username } = predictions[0].user;\n\t            const score = predictions.reduce<number>((acc, prediction) => {\n\t                const predictionStatus = getPredictionStatus(prediction);\n\t                switch (predictionStatus) {\n", "                    case 'correct':\n\t                        return acc + 1;\n\t                    default:\n\t                        return acc;\n\t                }\n\t            }, 0);\n\t            return {\n\t                email,\n\t                username,\n\t                userId,\n", "                score,\n\t            };\n\t        }\n\t    );\n\t    return {\n\t        userIdRankings,\n\t    };\n\t};\n\texport const predictions: QueryResolvers['predictions'] = () => {\n\t    return db.prediction.findMany();\n", "};\n\texport const myPredictions: QueryResolvers['myPredictions'] = (\n\t    _temp,\n\t    { context }\n\t) => {\n\t    const user = getFirstUserFromContext(context);\n\t    return db.prediction.findMany({\n\t        where: { userId: user.id },\n\t    });\n\t};\n", "export const prediction: QueryResolvers['prediction'] = ({ id }) => {\n\t    return db.prediction.findUnique({\n\t        where: { id },\n\t    });\n\t};\n\texport const createPrediction: MutationResolvers['createPrediction'] = ({\n\t    input,\n\t}) => {\n\t    return db.prediction.create({\n\t        data: input,\n", "    });\n\t};\n\texport const updatePrediction: MutationResolvers['updatePrediction'] = ({\n\t    id,\n\t    input,\n\t}) => {\n\t    return db.prediction.update({\n\t        data: input,\n\t        where: { id },\n\t    });\n", "};\n\texport const deletePrediction: MutationResolvers['deletePrediction'] = ({\n\t    id,\n\t}) => {\n\t    return db.prediction.delete({\n\t        where: { id },\n\t    });\n\t};\n\texport const Prediction: PredictionResolvers = {\n\t    id: (_obj, { root }) => root.id,\n", "    teamId: (_obj, { root }) => root.teamId,\n\t    gameId: (_obj, { root }) => root.gameId,\n\t    userId: (_obj, { root }) => root.userId,\n\t    prediction: (_obj, { root }) => root.prediction,\n\t    user: (_obj, { root }) =>\n\t        db.user.findUnique({ where: { id: root.userId } }),\n\t    team: (_obj, { root }) =>\n\t        db.prediction.findUnique({ where: { id: root.id } }).team(),\n\t    game: (_obj, { root }) =>\n\t        db.prediction.findUnique({ where: { id: root.id } }).game(),\n", "};\n"]}
