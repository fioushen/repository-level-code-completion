{"filename": "shim.d.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-unused-vars */\n\tdeclare module \"*.vue\" {\n\t\timport { ComponentOptions, DefineComponent } from \"vue\";\n\t\t// const componentOptions: ComponentOptions;\n\t\t// export default componentOptions;\n\t\tconst defineComponent: DefineComponent;\n\t\texport default defineComponent;\n\t}\n"]}
{"filename": "vitest.config.ts", "chunked_list": ["/// <reference types=\"vitest\" />\n\timport { defineConfig } from \"vite\";\n\timport { configDefaults } from \"vitest/config\";\n\timport Vue from \"@vitejs/plugin-vue\";\n\timport TsConfigPath from \"vite-tsconfig-paths\";\n\texport default defineConfig({\n\t\tplugins: [Vue(), TsConfigPath()],\n\t\ttest: {\n\t\t\tglobals: true,\n\t\t\tenvironment: \"happy-dom\",\n", "\t\tcoverage: {\n\t\t\t\texclude: [\n\t\t\t\t\t...configDefaults.exclude,\n\t\t\t\t\t\"**/components/*\",\n\t\t\t\t\t\"**/composable/*\",\n\t\t\t\t\t\"**/views/*\",\n\t\t\t\t\t\"**/tests/*\",\n\t\t\t\t],\n\t\t\t\tprovider: \"istanbul\",\n\t\t\t\treporter: [\"html\"],\n", "\t\t},\n\t\t},\n\t});\n"]}
{"filename": "tests/cardMarkup.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport { SETTINGS_DEFAULT } from \"~/settings\";\n\timport {\n\t\tmockMarkdownCodeBlockTimelineProcessingContext,\n\t\tmockCardContext,\n\t} from \"./obsidianMocks\";\n\timport {\n\t\tgetDateText,\n\t\tcreateCardFromBuiltContext,\n\t\tformatBodyForCard,\n", "} from \"~/cardMarkup\";\n\tdescribe.concurrent(\"Card Markup\", () => {\n\t\ttest(\"[getDateText] - missing start\", () => {\n\t\t\texpect(\n\t\t\t\tgetDateText(\n\t\t\t\t\t{ startDate: undefined, endDate: undefined },\n\t\t\t\t\tSETTINGS_DEFAULT\n\t\t\t\t)\n\t\t\t).toBe(\"Start date missing\");\n\t\t});\n", "\ttest(\"[getDateText] - missing end\", () => {\n\t\t\texpect(\n\t\t\t\tgetDateText(\n\t\t\t\t\t{ startDate: [1000, 0, 0], endDate: undefined },\n\t\t\t\t\tSETTINGS_DEFAULT\n\t\t\t\t)\n\t\t\t).toBe(\"00/00/1000\");\n\t\t});\n\t\ttest(\"[getDateText] - missing end\", () => {\n\t\t\texpect(\n", "\t\t\tgetDateText(\n\t\t\t\t\t{ startDate: [1000, 0, 0], endDate: true },\n\t\t\t\t\tSETTINGS_DEFAULT\n\t\t\t\t)\n\t\t\t).toBe(\"From 00/00/1000 to now\");\n\t\t});\n\t\ttest(\"[createCardFromBuiltContext] - ok\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\tconst cardContent = mockCardContext();\n\t\t\texpect(() =>\n", "\t\t\tcreateCardFromBuiltContext(context, cardContent)\n\t\t\t).not.toThrowError();\n\t\t\t// @ts-expect-error\n\t\t\tcardContent.body = undefined;\n\t\t\t// @ts-expect-error\n\t\t\tcardContent.imageURL = undefined;\n\t\t\texpect(() =>\n\t\t\t\tcreateCardFromBuiltContext(context, cardContent)\n\t\t\t).not.toThrowError();\n\t\t});\n", "\ttest(\"[formatBodyForCard] - ok has other timelines\", () => {\n\t\t\tconst bodyMock = \"Some sample body data\";\n\t\t\tconst timelineTextMock = \"\\n```aat-vertical\\nother timeline\\n```\";\n\t\t\texpect(\n\t\t\t\tformatBodyForCard,\n\t\t\t\t// Add fake note metadata block\n\t\t\t\t\"---\\n---\\n\" + bodyMock + timelineTextMock\n\t\t\t);\n\t\t});\n\t});\n"]}
{"filename": "tests/cardDataExtraction.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport { SETTINGS_DEFAULT } from \"~/settings\";\n\timport { mockMarkdownCodeBlockTimelineProcessingContext } from \"./obsidianMocks\";\n\timport {\n\t\tgetAbstractDateFromMetadata,\n\t\tgetBodyFromContextOrDocument,\n\t\tgetImageUrlFromContextOrDocument,\n\t\tgetTagsFromMetadataOrTagObject,\n\t} from \"~/cardDataExtraction\";\n\timport type { TFile } from \"obsidian\";\n", "describe.concurrent(\"Card Data\", () => {\n\t\ttest(\"[getAbstractDateFromMetadata] - ok\", () => {\n\t\t\tconst date = getAbstractDateFromMetadata(\n\t\t\t\tmockMarkdownCodeBlockTimelineProcessingContext(),\n\t\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventStartDate\"]\n\t\t\t);\n\t\t\texpect(date).toStrictEqual([1000, 1000, 1000]);\n\t\t});\n\t\ttest(\"[getAbstractDateFromMetadata] - missing frontmatter data\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\tcontext.cachedMetadata.frontmatter[\n\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate\n\t\t\t] = undefined;\n\t\t\tconst date = getAbstractDateFromMetadata(\n\t\t\t\tcontext,\n\t\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventStartDate\"]\n\t\t\t);\n\t\t\texpect(date).toBeUndefined();\n", "\t});\n\t\ttest(\"[getAbstractDateFromMetadata] - number frontmatter data\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\tcontext.cachedMetadata.frontmatter[\n\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate\n\t\t\t] = 1000;\n\t\t\tconst date = getAbstractDateFromMetadata(\n\t\t\t\tcontext,\n", "\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventStartDate\"]\n\t\t\t);\n\t\t\texpect(date).toStrictEqual([1000, 0, 0]);\n\t\t});\n\t\ttest(\"[getImageUrlFromContextOrDocument] - ok internal\", () => {\n\t\t\tconst imageURL = getImageUrlFromContextOrDocument(\n\t\t\t\t\"![[Picture.png]]\",\n\t\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t\t);\n\t\t\texpect(imageURL).not.toBeNull();\n", "\t});\n\t\ttest(\"[getImageUrlFromContextOrDocument] - ok external\", () => {\n\t\t\tconst imageURL = getImageUrlFromContextOrDocument(\n\t\t\t\t\"![](https://imgur.com/hehe)\",\n\t\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t\t);\n\t\t\texpect(imageURL).not.toBeNull();\n\t\t});\n\t\ttest(\"[getImageUrlFromContextOrDocument] - ko no picture\", () => {\n\t\t\tconst imageURL = getImageUrlFromContextOrDocument(\n", "\t\t\t\"no pictures to be found in here\",\n\t\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t\t);\n\t\t\texpect(imageURL).toBeNull();\n\t\t});\n\t\ttest(\"[getImageUrlFromContextOrDocument] - ok overrided\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\tcontext.cachedMetadata.frontmatter[\n", "\t\t\tSETTINGS_DEFAULT.metadataKeyEventPictureOverride\n\t\t\t] = \"picture.png\";\n\t\t\tconst imageURL = getImageUrlFromContextOrDocument(\n\t\t\t\t\"no pictures to be found in here\",\n\t\t\t\tcontext\n\t\t\t);\n\t\t\texpect(imageURL).not.toBeNull();\n\t\t});\n\t\ttest(\"[getImageUrlFromContextOrDocument] - ko missing obsidian file\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tcontext.app.metadataCache.getFirstLinkpathDest = vi.fn(\n\t\t\t\t(linkpath: string, sourcePath: string): TFile | null => null\n\t\t\t);\n\t\t\tconst imageURL = getImageUrlFromContextOrDocument(\n\t\t\t\t\"![[Picture.png]]\",\n\t\t\t\tcontext\n\t\t\t);\n\t\t\texpect(imageURL).toBeNull();\n\t\t});\n\t\ttest(\"[getBodyFromContextOrDocument]- ko empty body\", () => {\n", "\t\tconst body = getBodyFromContextOrDocument(\n\t\t\t\t\"\",\n\t\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t\t);\n\t\t\texpect(body).toBeNull();\n\t\t});\n\t\ttest(\"[getBodyFromContextOrDocument]- ok empty body / overrided\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\tconst bodyMock = \"Some sample body data\";\n\t\t\tif (!context.cachedMetadata.frontmatter)\n", "\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\tcontext.cachedMetadata.frontmatter[\n\t\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventBodyOverride\"]\n\t\t\t] = bodyMock;\n\t\t\tconst body = getBodyFromContextOrDocument(\"\", context);\n\t\t\texpect(body).toBe(bodyMock);\n\t\t});\n\t\ttest(\"[getBodyFromContextOrDocument]- ok has body / overrided\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\tconst bodyMock = \"Some sample body data\";\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\tcontext.cachedMetadata.frontmatter[\n\t\t\t\tSETTINGS_DEFAULT[\"metadataKeyEventBodyOverride\"]\n\t\t\t] = bodyMock;\n\t\t\tconst body = getBodyFromContextOrDocument(bodyMock + \"body\", context);\n\t\t\texpect(body).toBe(bodyMock);\n\t\t});\n\t\ttest(\"[getBodyFromContextOrDocument]- ok has only body\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tconst bodyMock = \"Some sample body data\";\n\t\t\tconst body = getBodyFromContextOrDocument(\n\t\t\t\t// Add fake note metadata block\n\t\t\t\t\"---\\n---\\n\" + bodyMock,\n\t\t\t\tcontext\n\t\t\t);\n\t\t\texpect(body).toBe(bodyMock);\n\t\t});\n\t\ttest(\"[getTagsFromMetadataOrTagObject] - ko empty args\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\texpect(\n\t\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\t\tcontext.settings,\n\t\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\t\tundefined\n\t\t\t\t)\n\t\t\t).toStrictEqual([]);\n\t\t});\n", "\ttest(\"[getTagsFromMetadataOrTagObject] - ok frontmater\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\tcontext.cachedMetadata.frontmatter.timelines = [\"sample\"];\n\t\t\texpect(\n\t\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\t\tcontext.settings,\n\t\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\t\tundefined\n", "\t\t\t)\n\t\t\t).toStrictEqual([\"sample\"]);\n\t\t});\n\t\ttest(\"[getTagsFromMetadataOrTagObject] - ok frontmater\", () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\tconst tags = [\n\t\t\t\t{\n\t\t\t\t\ttag: \"#sample 2\",\n", "\t\t\t\tposition: context.cachedMetadata.frontmatter.position,\n\t\t\t\t},\n\t\t\t];\n\t\t\tcontext.cachedMetadata.frontmatter.timelines = [\"sample\"];\n\t\t\texpect(\n\t\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\t\tcontext.settings,\n\t\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\t\ttags\n\t\t\t\t)\n", "\t\t).toStrictEqual([\"sample\"]);\n\t\t\tcontext.settings.lookForTagsForTimeline = true;\n\t\t\texpect(\n\t\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\t\tcontext.settings,\n\t\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\t\ttags\n\t\t\t\t)\n\t\t\t).toStrictEqual([\"sample\", \"sample 2\"]);\n\t\t\tcontext.cachedMetadata.frontmatter.tags = [\"sample 3\"];\n", "\t\texpect(\n\t\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\t\tcontext.settings,\n\t\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\t\ttags\n\t\t\t\t)\n\t\t\t).toStrictEqual([\"sample\", \"sample 2\", \"sample 3\"]);\n\t\t\tcontext.cachedMetadata.frontmatter.tags = \"sample 3\";\n\t\t\texpect(\n\t\t\t\tgetTagsFromMetadataOrTagObject(\n", "\t\t\t\tcontext.settings,\n\t\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\t\ttags\n\t\t\t\t)\n\t\t\t).toStrictEqual([\"sample\", \"sample 2\", \"sample 3\"]);\n\t\t\tcontext.cachedMetadata.frontmatter.tags = undefined;\n\t\t\texpect(\n\t\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\t\tcontext.settings,\n\t\t\t\t\tcontext.cachedMetadata.frontmatter,\n", "\t\t\t\ttags\n\t\t\t\t)\n\t\t\t).toStrictEqual([\"sample\", \"sample 2\"]);\n\t\t\tcontext.settings.lookForTagsForTimeline = false;\n\t\t\texpect(\n\t\t\t\tgetTagsFromMetadataOrTagObject(\n\t\t\t\t\tcontext.settings,\n\t\t\t\t\tcontext.cachedMetadata.frontmatter,\n\t\t\t\t\ttags\n\t\t\t\t)\n", "\t\t).toStrictEqual([\"sample\"]);\n\t\t});\n\t});\n"]}
{"filename": "tests/cardData.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport {\n\t\textractCardData,\n\t\tgetDataFromNoteMetadata,\n\t\tgetDataFromNoteBody,\n\t} from \"~/cardData\";\n\timport { SETTINGS_DEFAULT } from \"~/settings\";\n\timport {\n\t\tmockCompleteCardContext,\n\t\tmockMarkdownCodeBlockTimelineProcessingContext,\n", "} from \"./obsidianMocks\";\n\tdescribe.concurrent(\"Card Data\", () => {\n\t\ttest(\"[extractCardData] - ok no title override\", async () => {\n\t\t\tconst data = await extractCardData(\n\t\t\t\tmockMarkdownCodeBlockTimelineProcessingContext()\n\t\t\t);\n\t\t\texpect(data.title).toBe(\"basename\");\n\t\t});\n\t\ttest(\"[extractCardData] - end date is boolean\", async () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\tcontext.cachedMetadata.frontmatter[\n\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventEndDate\n\t\t\t] = false;\n\t\t\tconst data = await extractCardData(context);\n\t\t\texpect(data.endDate).toBe(true);\n\t\t});\n\t\ttest(\"[getDataFromNoteMetadata] - ko no metaData\", async () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n", "\t\tcontext.cachedMetadata.frontmatter = undefined;\n\t\t\texpect(\n\t\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t\t).toBeUndefined();\n\t\t});\n\t\ttest(\"[getDataFromNoteMetadata] - ko render greenlight is false\", async () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\tcontext.cachedMetadata.frontmatter[\"aat-render-enabled\"] = false;\n", "\t\texpect(\n\t\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t\t).toBeUndefined();\n\t\t});\n\t\ttest(\"[getDataFromNoteMetadata] - ko no timeline tags match\", async () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\t// Try with missing timline metadata\n\t\t\texpect(\n\t\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t\t).toBeUndefined();\n", "\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\t// Set timeline to nothing\n\t\t\tcontext.cachedMetadata.frontmatter.timelines = [];\n\t\t\texpect(\n\t\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t\t).toBeUndefined();\n\t\t\tcontext.cachedMetadata.frontmatter.timelines = [\"not-timeline\"];\n\t\t\texpect(\n\t\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n", "\t\t).toBeUndefined();\n\t\t});\n\t\ttest(\"[getDataFromNoteMetadata] - ok\", async () => {\n\t\t\tconst context = mockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\tif (!context.cachedMetadata.frontmatter)\n\t\t\t\tthrow new Error(\"Missing frontmatter in mock\");\n\t\t\tcontext.cachedMetadata.frontmatter.timelines = [\"timline\"];\n\t\t\texpect(\n\t\t\t\tawait getDataFromNoteMetadata(context, [\"timline\"])\n\t\t\t).not.toBeUndefined();\n", "\t});\n\t\ttest(\"[getDataFromNoteBody] - ok empty\", async () => {\n\t\t\tconst {\n\t\t\t\tcontext,\n\t\t\t\tcardData: { body },\n\t\t\t} = mockCompleteCardContext();\n\t\t\texpect(\n\t\t\t\tawait getDataFromNoteBody(body, context, [\"timeline\"])\n\t\t\t).toStrictEqual([]);\n\t\t});\n", "\ttest(\"[getDataFromNoteBody] - ok nothing to parse\", async () => {\n\t\t\tconst {\n\t\t\t\tcontext,\n\t\t\t\tcardData: { body },\n\t\t\t} = mockCompleteCardContext({\n\t\t\t\tcontext: mockMarkdownCodeBlockTimelineProcessingContext(),\n\t\t\t\tcardData: {\n\t\t\t\t\tbody: \"%%aat-inline-event\\n%%\\nsampletext\",\n\t\t\t\t},\n\t\t\t});\n", "\t\texpect(\n\t\t\t\tawait getDataFromNoteBody(body, context, [\"timeline\"])\n\t\t\t).toStrictEqual([]);\n\t\t});\n\t\ttest(\"[getDataFromNoteBody] - ok tags are not valid\", async () => {\n\t\t\tconst {\n\t\t\t\tcontext,\n\t\t\t\tcardData: { body },\n\t\t\t} = mockCompleteCardContext({\n\t\t\t\tcontext: mockMarkdownCodeBlockTimelineProcessingContext(),\n", "\t\t\tcardData: {\n\t\t\t\t\tbody: \"'%%aat-inline-event\\naat-event-start-date: 54\\naat-event-end-date: true\\naat-render-enabled: true\\ntimelines: [nottimeline]\\n%%\",\n\t\t\t\t},\n\t\t\t});\n\t\t\texpect(\n\t\t\t\tawait getDataFromNoteBody(body, context, [\"timeline\"])\n\t\t\t).toStrictEqual([]);\n\t\t});\n\t\ttest(\"[getDataFromNoteBody] - ok tags are valid\", async () => {\n\t\t\tconst {\n", "\t\t\tcontext,\n\t\t\t\tcardData: { body },\n\t\t\t} = mockCompleteCardContext({\n\t\t\t\tcontext: mockMarkdownCodeBlockTimelineProcessingContext(),\n\t\t\t\tcardData: {\n\t\t\t\t\tbody: \"'%%aat-inline-event\\naat-event-start-date: 54\\naat-event-end-date: true\\naat-render-enabled: true\\ntimelines: [timeline]\\n%%\",\n\t\t\t\t},\n\t\t\t});\n\t\t\texpect(\n\t\t\t\t(await getDataFromNoteBody(body, context, [\"timeline\"])).length\n", "\t\t).toBe(1);\n\t\t});\n\t});\n"]}
{"filename": "tests/settings.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport { vi } from \"vitest\";\n\timport { TimelineSettingTab } from \"~/settings\";\n\timport AprilsAutomaticTimelinesPlugin from \"~/main\";\n\timport manifest from \"~/../manifest.json\";\n\timport { mockObsidianApp } from \"./obsidianMocks\";\n\tvi.mock(\"vue\", async () => {\n\t\tconst actual = (await vi.importActual(\"vue\")) as Record<string, unknown>;\n\t\treturn {\n\t\t\t...actual,\n", "\t\tcreateApp: vi.fn(\n\t\t\t\t(context: { setup: () => Record<string, unknown> }) => {\n\t\t\t\t\tconst e = context.setup();\n\t\t\t\t\tfor (const index in e) {\n\t\t\t\t\t\tconst n = e[index];\n\t\t\t\t\t\tif (typeof n === \"function\") n();\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuse: vi.fn(() => ({\n\t\t\t\t\t\t\tmount: vi.fn(),\n", "\t\t\t\t\t})),\n\t\t\t\t\t\tunmount: vi.fn(),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t),\n\t\t\tref: vi.fn(<T>(value: T) => ({ value })),\n\t\t};\n\t});\n\tvi.mock(\"vue-i18n\", () => {\n\t\treturn {\n", "\t\tcreateI18n: () => ({}),\n\t\t};\n\t});\n\tdescribe.concurrent(\"Settings\", () => {\n\t\ttest(\"Can spawn setting tab\", () => {\n\t\t\tconst app = mockObsidianApp();\n\t\t\tconst plugin = new AprilsAutomaticTimelinesPlugin(app, manifest);\n\t\t\tconst tab = new TimelineSettingTab(app, plugin);\n\t\t\texpect(tab.vueApp).toBeNull();\n\t\t\ttab.display();\n", "\t\texpect(tab.vueApp).not.toBeUndefined();\n\t\t\ttab.hide();\n\t\t\texpect(tab.vueApp).toBeNull();\n\t\t\ttab.hide();\n\t\t\texpect(tab.vueApp).toBeNull();\n\t\t});\n\t});\n"]}
{"filename": "tests/abstractDateFormating.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport { SETTINGS_DEFAULT } from \"~/settings\";\n\timport {\n\t\tapplyConditionBasedFormatting,\n\t\tformatAbstractDate,\n\t\tformatDateToken,\n\t} from \"~/abstractDateFormatting\";\n\timport { Condition, DateTokenConfiguration, DateTokenType } from \"~/types\";\n\timport {\n\t\tcreateNumberDateTokenConfiguration,\n", "\tcreateStringDateTokenConfiguration,\n\t} from \"~/utils\";\n\tdescribe.concurrent(\"Abstract Date Formatting\", () => {\n\t\ttest(\"[formatAbstractDate] - boolean date\", () => {\n\t\t\tconst absctractDateMock = true;\n\t\t\tconst output = formatAbstractDate(absctractDateMock, SETTINGS_DEFAULT);\n\t\t\texpect(output).toBe(\"now\");\n\t\t});\n\t\ttest(\"[formatAbstractDate] - throws on missing configuration\", () => {\n\t\t\tconst absctractDateMock = [1000, 0, 0];\n", "\t\tconst settings = { ...SETTINGS_DEFAULT };\n\t\t\tsettings.dateTokenConfiguration = [];\n\t\t\texpect(() =>\n\t\t\t\tformatAbstractDate(absctractDateMock, settings)\n\t\t\t).toThrowError();\n\t\t});\n\t\ttest(\"[formatAbstractDate] - abstract date\", () => {\n\t\t\tconst absctractDateMock = [1000, 0, 0];\n\t\t\tconst settings = { ...SETTINGS_DEFAULT };\n\t\t\texpect(formatAbstractDate(absctractDateMock, settings)).toBe(\n", "\t\t\t\"00/00/1000\"\n\t\t\t);\n\t\t\tsettings.dateDisplayFormat = \"{month}-{year}-{day}\";\n\t\t\texpect(formatAbstractDate(absctractDateMock, settings)).toBe(\n\t\t\t\t\"00-1000-00\"\n\t\t\t);\n\t\t\tsettings.dateDisplayFormat = \"{year} hehe test\";\n\t\t\texpect(formatAbstractDate(absctractDateMock, settings)).toBe(\n\t\t\t\t\"1000 hehe test\"\n\t\t\t);\n", "\t\tsettings.dateDisplayFormat = \"no template in here\";\n\t\t\texpect(formatAbstractDate(absctractDateMock, settings)).toBe(\n\t\t\t\tsettings.dateDisplayFormat\n\t\t\t);\n\t\t});\n\t\ttest(\"[formatDateToken] - numerical\", () => {\n\t\t\tconst configuration = createNumberDateTokenConfiguration({\n\t\t\t\ttype: DateTokenType.number,\n\t\t\t});\n\t\t\texpect(formatDateToken(2, configuration)).toBe(\"02\");\n", "\t\tconfiguration.minLeght = 10;\n\t\t\texpect(formatDateToken(2, configuration)).toBe(\"0000000002\");\n\t\t\tconfiguration.minLeght = -10;\n\t\t\texpect(formatDateToken(2, configuration)).toBe(\"2\");\n\t\t});\n\t\ttest(\"[formatDateToken] - string\", () => {\n\t\t\tconst configuration = createStringDateTokenConfiguration({\n\t\t\t\tdictionary: [\"a\", \"b\", \"c\", \"d\"],\n\t\t\t});\n\t\t\texpect(formatDateToken(2, configuration)).toBe(\"c\");\n", "\t});\n\t\ttest(\"[formatdateToken] - ko\", () => {\n\t\t\tconst configuration =\n\t\t\t\tcreateNumberDateTokenConfiguration() as DateTokenConfiguration;\n\t\t\t// @ts-expect-error\n\t\t\tconfiguration.type = \"unvalid type\";\n\t\t\t// @ts-expect-error\n\t\t\tconfiguration.dictionary = [\"a\", \"b\", \"c\", \"d\"];\n\t\t\texpect(() => formatDateToken(2, configuration)).toThrowError();\n\t\t});\n", "\ttest(\"[applyConditionBasedFormatting] - ok skip formatting\", () => {\n\t\t\tconst input = \"sample input\";\n\t\t\texpect(\n\t\t\t\tapplyConditionBasedFormatting(\n\t\t\t\t\tinput,\n\t\t\t\t\t0,\n\t\t\t\t\tcreateNumberDateTokenConfiguration(),\n\t\t\t\t\tfalse\n\t\t\t\t)\n\t\t\t).toBe(input);\n", "\t});\n\t\ttest(\"[applyConditionBasedFormatting] - ok no formatting\", () => {\n\t\t\tconst input = \"sample input\";\n\t\t\texpect(\n\t\t\t\tapplyConditionBasedFormatting(\n\t\t\t\t\tinput,\n\t\t\t\t\t0,\n\t\t\t\t\tcreateNumberDateTokenConfiguration(),\n\t\t\t\t\ttrue\n\t\t\t\t)\n", "\t\t).toBe(input);\n\t\t});\n\t\ttest(\"[applyConditionBasedFormatting] - ok full conditions exclusive\", () => {\n\t\t\tconst configuration = createNumberDateTokenConfiguration({\n\t\t\t\tformatting: [\n\t\t\t\t\t{\n\t\t\t\t\t\tevaluations: [\n\t\t\t\t\t\t\t{ condition: Condition.Greater, value: 0 },\n\t\t\t\t\t\t\t{ condition: Condition.Equal, value: -56 },\n\t\t\t\t\t\t],\n", "\t\t\t\t\tconditionsAreExclusive: true,\n\t\t\t\t\t\tformat: \"{value} sample condition formatting\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\tconst input = \"sample\";\n\t\t\texpect(\n\t\t\t\tapplyConditionBasedFormatting(input, -56, configuration, true)\n\t\t\t).toBe(`${input} sample condition formatting`);\n\t\t\texpect(\n", "\t\t\tapplyConditionBasedFormatting(input, 0, configuration, true)\n\t\t\t).toBe(input);\n\t\t});\n\t\ttest(\"[applyConditionBasedFormatting] - ok full conditions inclusive\", () => {\n\t\t\tconst configuration = createNumberDateTokenConfiguration({\n\t\t\t\tformatting: [\n\t\t\t\t\t{\n\t\t\t\t\t\tevaluations: [\n\t\t\t\t\t\t\t{ condition: Condition.Less, value: 0 },\n\t\t\t\t\t\t\t{ condition: Condition.Equal, value: -56 },\n", "\t\t\t\t\t],\n\t\t\t\t\t\tconditionsAreExclusive: false,\n\t\t\t\t\t\tformat: \"{value} sample condition formatting\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\tconst input = \"sample\";\n\t\t\texpect(\n\t\t\t\tapplyConditionBasedFormatting(input, -56, configuration, true)\n\t\t\t).toBe(`${input} sample condition formatting`);\n", "\t\texpect(\n\t\t\t\tapplyConditionBasedFormatting(input, -435, configuration, true)\n\t\t\t).toBe(input);\n\t\t});\n\t});\n"]}
{"filename": "tests/rangeMarkup.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport { mockHTMLElement, mockRange } from \"./obsidianMocks\";\n\timport { vi } from \"vitest\";\n\timport { renderSingleRange, renderRanges } from \"~/rangeMarkup\";\n\tdescribe.concurrent(\"Range Markup\", () => {\n\t\ttest(\"[renderSingleRange] - ko missing HTML element\", () => {\n\t\t\texpect(() =>\n\t\t\t\trenderSingleRange(mockRange(), 0, mockHTMLElement())\n\t\t\t).toThrowError();\n\t\t});\n", "\ttest(\"[renderSingleRange] - ok\", () => {\n\t\t\tconst element = mockHTMLElement();\n\t\t\tconst range = mockRange({\n\t\t\t\trelatedCardData: {\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n", "\t\t\t},\n\t\t\t});\n\t\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\t\tconst output = renderSingleRange(range, 0, mockHTMLElement());\n\t\t\texpect(output).not.toBeUndefined();\n\t\t\texpect(output.onclick).not.toBeNull();\n\t\t\texpect(output.onmouseenter).not.toBeNull();\n\t\t\texpect(output.onmouseover).not.toBeNull();\n\t\t\tconst keepValue = window.document.querySelector;\n\t\t\t// @ts-expect-error\n", "\t\texpect(() => output.onclick()).not.toThrowError();\n\t\t\twindow.document.querySelector = vi.fn(mockHTMLElement);\n\t\t\t// @ts-expect-error\n\t\t\texpect(() => output.onclick()).not.toThrowError();\n\t\t\t// @ts-expect-error\n\t\t\texpect(() => output.onmouseleave()).not.toThrowError();\n\t\t\t// @ts-expect-error\n\t\t\texpect(() => output.onmouseenter()).not.toThrowError();\n\t\t\twindow.document.querySelector = keepValue;\n\t\t});\n", "\ttest(\"[renderRanges] - ko no end date\", () => {\n\t\t\texpect(() =>\n\t\t\t\trenderRanges([mockRange()], mockHTMLElement())\n\t\t\t).toThrowError();\n\t\t});\n\t\ttest(\"[renderRanges] - ok and overflow\", () => {\n\t\t\tconst element = mockHTMLElement();\n\t\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\t\tconst range = mockRange({\n\t\t\t\trelatedCardData: {\n", "\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [0],\n\t\t\t\t\t\tendDate: [1],\n\t\t\t\t\t},\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n", "\t\t\t},\n\t\t\t});\n\t\t\tconst range2 = mockRange({\n\t\t\t\trelatedCardData: {\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [2],\n\t\t\t\t\t\tendDate: true,\n\t\t\t\t\t},\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\telements: {\n", "\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\t\t\texpect(() =>\n\t\t\t\trenderRanges(\n\t\t\t\t\t[\n\t\t\t\t\t\trange,\n", "\t\t\t\t\trange,\n\t\t\t\t\t\trange,\n\t\t\t\t\t\trange,\n\t\t\t\t\t\trange,\n\t\t\t\t\t\trange,\n\t\t\t\t\t\trange,\n\t\t\t\t\t\trange,\n\t\t\t\t\t\trange,\n\t\t\t\t\t\trange2,\n\t\t\t\t\t\trange2,\n", "\t\t\t\t],\n\t\t\t\t\tmockHTMLElement()\n\t\t\t\t)\n\t\t\t).not.toThrowError();\n\t\t});\n\t});\n"]}
{"filename": "tests/obsidianMocks.ts", "chunked_list": ["import { mock } from \"vitest-mock-extended\";\n\timport { SETTINGS_DEFAULT } from \"~/settings\";\n\timport {\n\t\tTFile as TFileClass,\n\t\tComponent as ObsidianComponent,\n\t\tApp as ObsidianApp,\n\t} from \"obsidian\";\n\timport type {\n\t\tApp,\n\t\tVault,\n", "\tTFolder,\n\t\tTFile,\n\t\tFileStats,\n\t\tCachedMetadata,\n\t\tFrontMatterCache,\n\t} from \"obsidian\";\n\timport type { DeepPartial } from \"ts-essentials\";\n\timport type {\n\t\tCardContent,\n\t\tCompleteCardContext,\n", "\tMarkdownCodeBlockTimelineProcessingContext,\n\t\tRange,\n\t} from \"~/types\";\n\tvi.mock(\"obsidian\", () => {\n\t\tclass TFile {\n\t\t\tstat: FileStats;\n\t\t\tbasename: string;\n\t\t\textension: string;\n\t\t\tvault: Vault;\n\t\t\tpath: string;\n", "\t\tname: string;\n\t\t\tparent: TFolder | null;\n\t\t\tconstructor() {\n\t\t\t\tthis.stat = mock<FileStats>();\n\t\t\t\tthis.basename = mock<string>();\n\t\t\t\tthis.extension = mock<string>();\n\t\t\t\tthis.vault = mock<Vault>();\n\t\t\t\tthis.path = mock<string>();\n\t\t\t\tthis.name = mock<string>();\n\t\t\t\tthis.parent = mock<TFolder | null>();\n", "\t\t}\n\t\t}\n\t\tclass Plugin {\n\t\t\tcontainerEl: HTMLElement;\n\t\t\tapp: ObsidianApp;\n\t\t\tconstructor(app: ObsidianApp, manifest: Record<string, unknown>) {\n\t\t\t\tthis.containerEl = mock<HTMLElement>();\n\t\t\t\tthis.app = app;\n\t\t\t\treturn;\n\t\t\t}\n", "\t\tsaveData = vi.fn();\n\t\t\tloadData = vi.fn(async () => ({ someKey: \"someValue\" }));\n\t\t\taddSettingTab = vi.fn();\n\t\t\tregisterMarkdownCodeBlockProcessor = vi.fn();\n\t\t}\n\t\tclass MarkdownRenderChild {\n\t\t\tcontainerEl: HTMLElement;\n\t\t\tconstructor(containerEl: HTMLElement) {\n\t\t\t\tthis.containerEl = containerEl;\n\t\t\t\treturn;\n", "\t\t}\n\t\t}\n\t\treturn {\n\t\t\tPluginSettingTab: Plugin,\n\t\t\tTFile: TFile,\n\t\t\tMarkdownRenderer: {\n\t\t\t\tasync renderMarkdown(\n\t\t\t\t\tmarkdown: string,\n\t\t\t\t\tel: HTMLElement,\n\t\t\t\t\tsourcePath: string,\n", "\t\t\t\tcomponent: ObsidianComponent\n\t\t\t\t): Promise<void> {\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t},\n\t\t\tMarkdownRenderChild,\n\t\t\tPlugin,\n\t\t};\n\t});\n\t/**\n", " * Mock a native HTMLElement object.\n\t *\n\t * @returns - The mocked native HTMLElement object.\n\t */\n\texport function mockHTMLElement(): HTMLElement {\n\t\t// @ts-expect-error\n\t\treturn mock<HTMLElement>({\n\t\t\tchildren: {\n\t\t\t\titem: vi\n\t\t\t\t\t.fn((_: number) => null as Element | null)\n", "\t\t\t\t.mockImplementationOnce(mockHTMLElement),\n\t\t\t},\n\t\t\tcreateDiv: vi.fn(() => {\n\t\t\t\treturn mockHTMLElement() as HTMLDivElement;\n\t\t\t}),\n\t\t\toffsetTop: 0,\n\t\t\tinnerHeight: 0,\n\t\t\t// @ts-expect-error\n\t\t\tcreateEl: vi.fn(\n\t\t\t\t<K extends keyof HTMLElementTagNameMap>(\n", "\t\t\t\t_: K,\n\t\t\t\t\t__?: DomElementInfo | string,\n\t\t\t\t\t___?: (el: HTMLElementTagNameMap[K]) => void\n\t\t\t\t): HTMLElementTagNameMap[K] => {\n\t\t\t\t\treturn mockHTMLElement() as HTMLElementTagNameMap[K];\n\t\t\t\t}\n\t\t\t),\n\t\t\taddClass: vi.fn(() => {\n\t\t\t\treturn;\n\t\t\t}),\n", "\t\tclassList: {\n\t\t\t\tadd: vi.fn(() => {\n\t\t\t\t\treturn;\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\t}\n\t/**\n\t * Quickhand function to mock the obsidian `mockGetFileCache` function.\n\t *\n", " * @returns - The mocked obsidian `mockGetFileCache` function.\n\t */\n\texport function mockGetFileCache() {\n\t\treturn vi.fn<[], CachedMetadata | null>(() => {\n\t\t\treturn {\n\t\t\t\tfrontmatter: {\n\t\t\t\t\t...mock<FrontMatterCache>(),\n\t\t\t\t\ttimelines: [\"timeline\"],\n\t\t\t\t\t\"aat-render-enabled\": true,\n\t\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventStartDate]: mock<number>(),\n", "\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventEndDate]: mock<number>(),\n\t\t\t\t},\n\t\t\t};\n\t\t});\n\t}\n\t/**\n\t * Quickhand function to mock a obsidian App Class.\n\t *\n\t * @returns - the mocked obsidian App class.\n\t */\n", "export function mockObsidianApp(): App {\n\t\treturn mock<App>({\n\t\t\tvault: mockVault(),\n\t\t\tmetadataCache: {\n\t\t\t\tgetFileCache: mockGetFileCache().mockReturnValueOnce(null),\n\t\t\t},\n\t\t});\n\t}\n\t/**\n\t * Quickhand function to mock the obsidian TFile class.\n", " *\n\t * @returns - The mocked obsidian TFile.\n\t */\n\texport function mockTFile() {\n\t\treturn mock<TFile>({\n\t\t\tvault: {\n\t\t\t\tcachedRead: vi.fn(async (file: TFile) => {\n\t\t\t\t\treturn \"---\\n---\\n---\\nSample file data\";\n\t\t\t\t}),\n\t\t\t},\n", "\t});\n\t}\n\t/**\n\t * Quickhand function to mock a Obsidian Vault.\n\t *\n\t * @returns - The mocked vault.\n\t */\n\texport function mockVault(): Vault {\n\t\treturn mock<Vault>({\n\t\t\tgetResourcePath: vi.fn((file: TFile) => {\n", "\t\t\treturn \"sample\";\n\t\t\t}),\n\t\t\tcachedRead: vi.fn(async (file: TFile) => {\n\t\t\t\treturn \"---\\n---\\n---\\nSample file data\";\n\t\t\t}),\n\t\t\tgetMarkdownFiles: vi.fn(() => {\n\t\t\t\treturn [mockTFile(), mockTFile()];\n\t\t\t}),\n\t\t});\n\t}\n", "/**\n\t * Quickly mock a MarkdownCodeBlockTimelineProcessingContext. A lot of default are set so inspect the function for further details.\n\t *\n\t * @returns - The mocked object.\n\t */\n\texport function mockMarkdownCodeBlockTimelineProcessingContext(): MarkdownCodeBlockTimelineProcessingContext {\n\t\tconst vault = mockVault();\n\t\treturn mock<MarkdownCodeBlockTimelineProcessingContext>({\n\t\t\tapp: {\n\t\t\t\tvault,\n", "\t\t\tmetadataCache: {\n\t\t\t\t\tgetFirstLinkpathDest: vi.fn(\n\t\t\t\t\t\t(linkpath: string, sourcePath: string): TFile | null => {\n\t\t\t\t\t\t\treturn new TFileClass();\n\t\t\t\t\t\t}\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t},\n\t\t\tfile: {\n\t\t\t\tbasename: \"basename\",\n", "\t\t\tvault,\n\t\t\t},\n\t\t\telements: {\n\t\t\t\tcardListRootElement: mockHTMLElement(),\n\t\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t\t},\n\t\t\tsettings: SETTINGS_DEFAULT,\n\t\t\tcachedMetadata: {\n\t\t\t\tfrontmatter: {\n\t\t\t\t\t\"aat-render-enabled\": true,\n", "\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventPictureOverride]: undefined,\n\t\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventBodyOverride]: undefined,\n\t\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventStartDate]: \"1000-1000-1000\",\n\t\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventTitleOverride]: undefined,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\t/**\n\t * Quickly mock a card context object.\n", " *\n\t * @returns - The mocked card content.\n\t */\n\texport function mockCardContext() {\n\t\treturn mock<CardContent>({\n\t\t\tstartDate: [1000, 0, 0],\n\t\t\tendDate: true,\n\t\t\tbody: \"Sample body\",\n\t\t\timageURL: \"https://sampleURL.png\",\n\t\t\ttitle: \"Sample title\",\n", "\t});\n\t}\n\t/**\n\t * Mocks a Range object.\n\t *\n\t * @param defaultVal - Value override for user defined cases.\n\t * @returns -  A mocked range object.\n\t */\n\texport function mockRange(defaultVal: DeepPartial<Range> = {}): Range {\n\t\treturn mock<Range>(defaultVal);\n", "}\n\t/**\n\t * Mocks the complete card context.\n\t *\n\t * @param defaultVal - Value override for user defined cases.\n\t * @returns -  The complete card context mock object.\n\t */\n\texport function mockCompleteCardContext(\n\t\tdefaultVal: DeepPartial<CompleteCardContext> = {}\n\t): CompleteCardContext {\n", "\treturn mock<CompleteCardContext>(defaultVal);\n\t}\n"]}
{"filename": "tests/main.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport {\n\t\tmockGetFileCache,\n\t\tmockHTMLElement,\n\t\tmockObsidianApp,\n\t\tmockTFile,\n\t} from \"./obsidianMocks\";\n\timport manifest from \"~/../manifest.json\";\n\timport { SETTINGS_DEFAULT } from \"~/settings\";\n\timport AprilsAutomaticTimelinesPlugin from \"~/main\";\n", "import type { Mock } from \"vitest\";\n\tdescribe.concurrent(\"Main\", () => {\n\t\ttest(\"ok settings call\", async () => {\n\t\t\tconst app = mockObsidianApp();\n\t\t\tconst plugin = new AprilsAutomaticTimelinesPlugin(app, manifest);\n\t\t\texpectTypeOf(plugin).toMatchTypeOf<AprilsAutomaticTimelinesPlugin>();\n\t\t\tlet promise = plugin.loadSettings();\n\t\t\texpect(() => promise).not.toThrowError();\n\t\t\tawait promise;\n\t\t\texpect(plugin.loadData).toHaveBeenCalledOnce();\n", "\t\texpect(Object.keys(plugin.settings)).toContain(\"someKey\");\n\t\t\tpromise = plugin.saveSettings();\n\t\t\texpect(() => promise).not.toThrowError();\n\t\t\tawait promise;\n\t\t\texpect(plugin.saveData).toHaveBeenCalledOnce();\n\t\t});\n\t\ttest(\"ok on/un/load\", async () => {\n\t\t\tconst app = mockObsidianApp();\n\t\t\tapp.metadataCache.getFileCache = mockGetFileCache()\n\t\t\t\t.mockImplementationOnce(() => ({\n", "\t\t\t\t// @ts-expect-error\n\t\t\t\t\tfrontmatter: {\n\t\t\t\t\t\ttimelines: [\"timeline\"],\n\t\t\t\t\t\t\"aat-render-enabled\": true,\n\t\t\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventStartDate]: 87,\n\t\t\t\t\t\t[SETTINGS_DEFAULT.metadataKeyEventEndDate]: true,\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t.mockImplementationOnce(() => ({\n\t\t\t\t\tfrontmatter: undefined,\n", "\t\t\t}));\n\t\t\tconst inlineEventFile = mockTFile();\n\t\t\tinlineEventFile.vault.cachedRead = vi.fn(\n\t\t\t\tasync () =>\n\t\t\t\t\t\"---\\n---\\n---\\nSample file data%%aat-inline-event\\naat-event-start-date: 54\\naat-event-end-date: true\\naat-render-enabled: true\\ntimelines: [timeline]\\n%%\"\n\t\t\t);\n\t\t\tapp.vault.getMarkdownFiles = vi.fn(() => [\n\t\t\t\tmockTFile(),\n\t\t\t\tmockTFile(),\n\t\t\t\tmockTFile(),\n", "\t\t\tinlineEventFile,\n\t\t\t]);\n\t\t\tconst plugin = new AprilsAutomaticTimelinesPlugin(app, manifest);\n\t\t\tconst spy = vi.spyOn(plugin, \"run\");\n\t\t\texpect(() => plugin.onunload()).not.toThrowError();\n\t\t\tconst promise = plugin.onload();\n\t\t\texpect(() => promise).not.toThrowError();\n\t\t\tawait promise;\n\t\t\texpect(\n\t\t\t\tplugin.registerMarkdownCodeBlockProcessor\n", "\t\t).toHaveBeenCalledOnce();\n\t\t\tconst { mock } = plugin.registerMarkdownCodeBlockProcessor as Mock;\n\t\t\texpect(mock.lastCall[0]).toBe(\"aat-vertical\");\n\t\t\texpect(mock.lastCall[1]).toBeTypeOf(\"function\");\n\t\t\texpect(() =>\n\t\t\t\tmock.lastCall[1](\"timeline\", mockHTMLElement(), {\n\t\t\t\t\tsourcePath: \"sample\",\n\t\t\t\t})\n\t\t\t).not.toThrowError();\n\t\t\texpect(spy).toHaveBeenCalledOnce();\n", "\t});\n\t});\n"]}
{"filename": "tests/utils.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport {\n\t\tmockHTMLElement,\n\t\tmockMarkdownCodeBlockTimelineProcessingContext,\n\t} from \"./obsidianMocks\";\n\timport {\n\t\tcompareAbstractDates,\n\t\tcreateElementShort,\n\t\tgetChildAtIndexInHTMLElement,\n\t\tmeasureTime,\n", "\tinLerp,\n\t\tlerp,\n\t\tfindLastIndex,\n\t\tisDefinedAsString,\n\t\tisDefined,\n\t\tgetMetadataKey,\n\t\tcreateNumberDateTokenConfiguration,\n\t\tcreateStringDateTokenConfiguration,\n\t\tparseAbstractDate,\n\t\tevalNumericalCondition,\n", "\tisDefinedAsBoolean,\n\t} from \"~/utils\";\n\timport { SETTINGS_DEFAULT } from \"~/settings\";\n\timport { Condition, DateTokenConfiguration, DateTokenType } from \"~/types\";\n\tdescribe.concurrent(\"Utils\", () => {\n\t\ttest(\"[compareAbstractDates] - no dates\", () => {\n\t\t\texpect(compareAbstractDates(undefined, undefined)).toBe(0);\n\t\t});\n\t\ttest(\"[compareAbstractDates] - only start\", () => {\n\t\t\texpect(compareAbstractDates([1], undefined)).toBe(1);\n", "\t});\n\t\ttest(\"[compareAbstractDates] - only end\", () => {\n\t\t\texpect(compareAbstractDates(undefined, [1])).toBe(-1);\n\t\t});\n\t\ttest(\"[compareAbstractDates] - start is boolean\", () => {\n\t\t\texpect(compareAbstractDates(true, [1])).toBe(1);\n\t\t});\n\t\ttest(\"[compareAbstractDates] - end is boolean\", () => {\n\t\t\texpect(compareAbstractDates([1], true)).toBe(-1);\n\t\t});\n", "\ttest(\"[compareAbstractDates] - both are boolean\", () => {\n\t\t\texpect(compareAbstractDates(true, true)).toBe(0);\n\t\t});\n\t\ttest(\"[compareAbstractDates] - both are abstract dates but equal - 1 deep\", () => {\n\t\t\texpect(compareAbstractDates([1], [1])).toBe(0);\n\t\t});\n\t\ttest(\"[compareAbstractDates] - both are abstract dates but equal - 2 deep\", () => {\n\t\t\texpect(compareAbstractDates([1, 1], [1, 1])).toBe(0);\n\t\t});\n\t\ttest(\"[compareAbstractDates] - both are abstract dates but equal - 10 deep\", () => {\n", "\t\texpect(\n\t\t\t\tcompareAbstractDates([1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1])\n\t\t\t).toBe(0);\n\t\t});\n\t\ttest(\"[compareAbstractDates] - a is further in the future - 3 deep\", () => {\n\t\t\texpect(compareAbstractDates([1, -1, 79], [1, -1, 5])).toBe(1);\n\t\t});\n\t\ttest(\"[compareAbstractDates] - b is further in the future - 3 deep\", () => {\n\t\t\texpect(compareAbstractDates([1, -1, 5], [1, -1, 79])).toBe(-1);\n\t\t});\n", "\ttest(\"[createElementShort] - just the tag\", () => {\n\t\t\tconst htmlElementMock = mockHTMLElement();\n\t\t\tconst output = createElementShort(htmlElementMock, \"div\");\n\t\t\texpect(output).not.toBeUndefined();\n\t\t\texpect(htmlElementMock.createEl).toHaveBeenCalledOnce();\n\t\t\texpect(htmlElementMock.createEl).toHaveBeenCalledWith(\"div\");\n\t\t});\n\t\ttest(\"[createElementShort] - string class addition\", () => {\n\t\t\tconst htmlElementMock = mockHTMLElement();\n\t\t\tconst output = createElementShort(htmlElementMock, \"div\", \"hehe\");\n", "\t\texpect(output).not.toBeUndefined();\n\t\t\texpect(htmlElementMock.createEl).toHaveBeenCalledOnce();\n\t\t\texpect(htmlElementMock.createEl).toHaveBeenCalledWith(\"div\");\n\t\t\texpect(output.addClass).toHaveBeenCalledOnce();\n\t\t\texpect(output.addClass).toHaveBeenCalledWith(\"hehe\");\n\t\t});\n\t\ttest(\"[createElementShort] - array class addition\", () => {\n\t\t\tconst htmlElementMock = mockHTMLElement();\n\t\t\tconst output = createElementShort(htmlElementMock, \"div\", [\n\t\t\t\t\"hehe\",\n", "\t\t\t\"haha\",\n\t\t\t]);\n\t\t\texpect(output.addClass).toHaveBeenCalledOnce();\n\t\t\texpect(output.addClass).toHaveBeenCalledWith(\"hehe\", \"haha\");\n\t\t});\n\t\ttest(\"[createElementShort] - add body but no class\", () => {\n\t\t\tconst htmlElementMock = mockHTMLElement();\n\t\t\tconst output = createElementShort(\n\t\t\t\thtmlElementMock,\n\t\t\t\t\"div\",\n", "\t\t\tundefined,\n\t\t\t\t\"sample content\"\n\t\t\t);\n\t\t\texpect(output.addClass).not.toHaveBeenCalledOnce();\n\t\t\texpect(output.innerHTML).toBe(\"sample content\");\n\t\t});\n\t\ttest(\"[getChildAtIndexInHTMLElement] - ok/ko\", () => {\n\t\t\tconst htmlElementMock = mockHTMLElement();\n\t\t\texpect(\n\t\t\t\tgetChildAtIndexInHTMLElement(htmlElementMock, 0)\n", "\t\t).not.toBeUndefined();\n\t\t\texpect(() =>\n\t\t\t\tgetChildAtIndexInHTMLElement(htmlElementMock, 1)\n\t\t\t).toThrowError();\n\t\t});\n\t\ttest(\"[measureTime] - ok\", () => {\n\t\t\tconst spyOnTime = vi.spyOn(global.console, \"time\");\n\t\t\tconst spyOnTimeEnd = vi.spyOn(global.console, \"timeEnd\");\n\t\t\tconst name = \"timer-name\";\n\t\t\tconst timer = measureTime(name);\n", "\t\texpect(timer).not.toBeUndefined();\n\t\t\texpect(spyOnTime).toHaveBeenCalledOnce();\n\t\t\texpect(spyOnTime).toHaveBeenCalledWith(\n\t\t\t\t`[April's automatic timelines] - ${name}`\n\t\t\t);\n\t\t\ttimer();\n\t\t\texpect(spyOnTimeEnd).toHaveBeenCalledOnce();\n\t\t});\n\t\ttest(\"[inLerp] - ok\", () => {\n\t\t\texpect(inLerp(0, 1, 1)).toBe(1);\n", "\t\texpect(inLerp(0, 10, 1)).toBe(0.1);\n\t\t\texpect(inLerp(0, 10, 5)).toBe(0.5);\n\t\t});\n\t\ttest(\"[lerp] - ok\", () => {\n\t\t\texpect(lerp(0, 1, 1)).toBe(1);\n\t\t\texpect(lerp(0, 10, 1)).toBe(10);\n\t\t\texpect(lerp(0, 10, 5)).toBe(50);\n\t\t});\n\t\ttest(\"[findLastIndex] - ok\", () => {\n\t\t\tconst arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n", "\t\tfor (let index = 0; index < arr.length - 1; index++)\n\t\t\t\texpect(findLastIndex(arr, (e) => e === index)).toBe(index);\n\t\t});\n\t\ttest(\"[findLastIndex] - ko\", () => {\n\t\t\tconst arr = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n\t\t\texpect(findLastIndex(arr, (e) => e === \"never-found\")).toBe(-1);\n\t\t\texpect(findLastIndex([] as string[], (e) => e === \"never-found\")).toBe(\n\t\t\t\t-1\n\t\t\t);\n\t\t\texpect(\n", "\t\t\t// @ts-expect-error\n\t\t\t\tfindLastIndex(undefined as string[], (e) => e === \"never-found\")\n\t\t\t).toBe(-1);\n\t\t});\n\t\ttest(\"[isDefinedAsString] - ok/ko\", () => {\n\t\t\texpect(isDefinedAsString(\"\")).toBe(true);\n\t\t\texpect(isDefinedAsString(45)).toBe(false);\n\t\t});\n\t\ttest(\"[isDefinedAsBoolean] - ok/ko\", () => {\n\t\t\texpect(isDefinedAsBoolean(true)).toBe(true);\n", "\t\texpect(isDefinedAsBoolean(false)).toBe(true);\n\t\t\texpect(isDefinedAsBoolean(45)).toBe(false);\n\t\t});\n\t\ttest(\"[isDefined] - ok/ko\", () => {\n\t\t\texpect(isDefined(\"\")).toBe(true);\n\t\t\texpect(isDefined(45)).toBe(true);\n\t\t\texpect(isDefined(null)).toBe(true);\n\t\t\texpect(isDefined({})).toBe(true);\n\t\t\texpect(isDefined([])).toBe(true);\n\t\t\texpect(isDefined(new Map())).toBe(true);\n", "\t\texpect(isDefined(new WeakMap())).toBe(true);\n\t\t\texpect(isDefined(new WeakSet())).toBe(true);\n\t\t\texpect(isDefined(new Set())).toBe(true);\n\t\t\texpect(isDefined(Symbol())).toBe(true);\n\t\t\texpect(isDefined(undefined)).toBe(false);\n\t\t});\n\t\ttest(\"[getMetadataKey] - ok\", () => {\n\t\t\tconst { cachedMetadata } =\n\t\t\t\tmockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\texpect(\n", "\t\t\tgetMetadataKey(\n\t\t\t\t\tcachedMetadata,\n\t\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate,\n\t\t\t\t\t\"number\"\n\t\t\t\t)\n\t\t\t).toBe(undefined);\n\t\t\texpect(\n\t\t\t\tgetMetadataKey(\n\t\t\t\t\tcachedMetadata,\n\t\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate,\n", "\t\t\t\t\"string\"\n\t\t\t\t)\n\t\t\t).toBe(\"1000-1000-1000\");\n\t\t});\n\t\ttest(\"[getMetadataKey] - ok\", () => {\n\t\t\tconst { cachedMetadata } =\n\t\t\t\tmockMarkdownCodeBlockTimelineProcessingContext();\n\t\t\tcachedMetadata.frontmatter = undefined;\n\t\t\texpect(\n\t\t\t\tgetMetadataKey(\n", "\t\t\t\tcachedMetadata,\n\t\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate,\n\t\t\t\t\t\"string\"\n\t\t\t\t)\n\t\t\t).toBeUndefined();\n\t\t});\n\t\ttest(\"[createNumberDateTokenConfiguration] - ok\", () => {\n\t\t\texpect(createNumberDateTokenConfiguration()).toStrictEqual({\n\t\t\t\tminLeght: 2,\n\t\t\t\tname: \"\",\n", "\t\t\tdisplayWhenZero: true,\n\t\t\t\tformatting: [],\n\t\t\t\ttype: DateTokenType.number,\n\t\t\t\thideSign: false,\n\t\t\t} satisfies DateTokenConfiguration);\n\t\t\texpect(\n\t\t\t\tcreateNumberDateTokenConfiguration({\n\t\t\t\t\tname: \"sample\",\n\t\t\t\t})\n\t\t\t).toStrictEqual({\n", "\t\t\tminLeght: 2,\n\t\t\t\tname: \"sample\",\n\t\t\t\ttype: DateTokenType.number,\n\t\t\t\tdisplayWhenZero: true,\n\t\t\t\thideSign: false,\n\t\t\t\tformatting: [],\n\t\t\t} satisfies DateTokenConfiguration);\n\t\t\texpect(\n\t\t\t\tcreateNumberDateTokenConfiguration({\n\t\t\t\t\tname: \"sample\",\n", "\t\t\t\tminLeght: 234,\n\t\t\t\t})\n\t\t\t).toStrictEqual({\n\t\t\t\tminLeght: 234,\n\t\t\t\tname: \"sample\",\n\t\t\t\ttype: DateTokenType.number,\n\t\t\t\tdisplayWhenZero: true,\n\t\t\t\thideSign: false,\n\t\t\t\tformatting: [],\n\t\t\t} satisfies DateTokenConfiguration);\n", "\t});\n\t\ttest(\"[createStringDateTokenConfiguration] - ok\", () => {\n\t\t\texpect(createStringDateTokenConfiguration()).toStrictEqual({\n\t\t\t\tname: \"\",\n\t\t\t\tdictionary: [\"\"],\n\t\t\t\ttype: DateTokenType.string,\n\t\t\t\tformatting: [],\n\t\t\t} satisfies DateTokenConfiguration);\n\t\t\texpect(\n\t\t\t\tcreateStringDateTokenConfiguration({\n", "\t\t\t\tname: \"sample\",\n\t\t\t\t})\n\t\t\t).toStrictEqual({\n\t\t\t\tname: \"sample\",\n\t\t\t\tdictionary: [\"\"],\n\t\t\t\ttype: DateTokenType.string,\n\t\t\t\tformatting: [],\n\t\t\t} satisfies DateTokenConfiguration);\n\t\t\texpect(\n\t\t\t\tcreateStringDateTokenConfiguration({\n", "\t\t\t\tname: \"sample\",\n\t\t\t\t\tdictionary: [\"a\"],\n\t\t\t\t})\n\t\t\t).toStrictEqual({\n\t\t\t\tname: \"sample\",\n\t\t\t\tdictionary: [\"a\"],\n\t\t\t\ttype: DateTokenType.string,\n\t\t\t\tformatting: [],\n\t\t\t} satisfies DateTokenConfiguration);\n\t\t});\n", "\ttest(\"[parseAbstractDate] - ok\", () => {\n\t\t\tconst date = parseAbstractDate(\n\t\t\t\t[\"year\", \"month\", \"day\"],\n\t\t\t\t\"1000-1000-1000\",\n\t\t\t\tSETTINGS_DEFAULT.dateParserRegex\n\t\t\t);\n\t\t\texpect(date).toStrictEqual([1000, 1000, 1000]);\n\t\t});\n\t\ttest(\"[parseAbstractDate] - faulty regex\", () => {\n\t\t\tconst date = parseAbstractDate(\n", "\t\t\t[\"year\", \"month\", \"day\"],\n\t\t\t\t\"1000-1000-1000\",\n\t\t\t\t\"this-regex-will-not-match\"\n\t\t\t);\n\t\t\texpect(date).toBeUndefined();\n\t\t});\n\t\ttest(\"[parseAbstractDate] - partial regex match\", () => {\n\t\t\tconst date = parseAbstractDate(\n\t\t\t\t[\"year\", \"month\", \"day\"],\n\t\t\t\t\"1000-1000-1000\",\n", "\t\t\t\"(?<year>-?[0-9]*)-\"\n\t\t\t);\n\t\t\texpect(date).toBeUndefined();\n\t\t});\n\t\ttest(\"[evalNumericalCondition] - full suite\", () => {\n\t\t\tconst fn = evalNumericalCondition;\n\t\t\texpect(fn(Condition.Equal, 0, 0)).toBe(true);\n\t\t\texpect(fn(Condition.Equal, 0, 1)).toBe(false);\n\t\t\texpect(fn(Condition.NotEqual, 0, 0)).toBe(false);\n\t\t\texpect(fn(Condition.NotEqual, 0, 1)).toBe(true);\n", "\t\texpect(fn(Condition.Greater, 0, 0)).toBe(false);\n\t\t\texpect(fn(Condition.Greater, 0, 1)).toBe(false);\n\t\t\texpect(fn(Condition.Greater, 2, 1)).toBe(true);\n\t\t\texpect(fn(Condition.GreaterOrEqual, 0, 1)).toBe(false);\n\t\t\texpect(fn(Condition.GreaterOrEqual, 0, 0)).toBe(true);\n\t\t\texpect(fn(Condition.GreaterOrEqual, 1, 0)).toBe(true);\n\t\t\texpect(fn(Condition.Less, 0, 0)).toBe(false);\n\t\t\texpect(fn(Condition.Less, 1, 0)).toBe(false);\n\t\t\texpect(fn(Condition.Less, 0, 1)).toBe(true);\n\t\t\texpect(fn(Condition.LessOrEqual, 0, 0)).toBe(true);\n", "\t\texpect(fn(Condition.LessOrEqual, 1, 0)).toBe(false);\n\t\t\texpect(fn(Condition.LessOrEqual, 0, 1)).toBe(true);\n\t\t});\n\t});\n"]}
{"filename": "tests/rangeData.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport { vi } from \"vitest\";\n\timport { mockCompleteCardContext, mockHTMLElement } from \"./obsidianMocks\";\n\timport {\n\t\tfindBoundaries,\n\t\tgetInLerpValues,\n\t\tfindEndPositionForDate,\n\t\tgetAllRangeData,\n\t} from \"~/rangeData\";\n\tdescribe.concurrent(\"Range Data\", () => {\n", "\ttest(\"[findBoundaries] - ko no start\", () => {\n\t\t\texpect(() =>\n\t\t\t\tfindBoundaries(\n\t\t\t\t\t[5],\n\t\t\t\t\t[mockCompleteCardContext()],\n\t\t\t\t\tmockHTMLElement(),\n\t\t\t\t\t0\n\t\t\t\t)\n\t\t\t).toThrowError(\n\t\t\t\t\"No first over found - Can't draw range since there are no other two start date to referrence it's position\"\n", "\t\t);\n\t\t});\n\t\ttest(\"[findBoundaries] - ko no first last under\", () => {\n\t\t\texpect(() =>\n\t\t\t\tfindBoundaries(\n\t\t\t\t\t[5],\n\t\t\t\t\t[\n\t\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\t\tstartDate: [6],\n", "\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t],\n\t\t\t\t\tmockHTMLElement(),\n\t\t\t\t\t0\n\t\t\t\t)\n\t\t\t).toThrowError(\n\t\t\t\t\"Could not find a firstLastUnderIndex, this means this function was called with un rangeable members\"\n\t\t\t);\n\t\t});\n", "\ttest(\"[findBoundaries] - ko no end\", () => {\n\t\t\texpect(() =>\n\t\t\t\tfindBoundaries(\n\t\t\t\t\t[5],\n\t\t\t\t\t[\n\t\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\t\tstartDate: [5],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n", "\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\t\tstartDate: undefined,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\t\tstartDate: [8],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n", "\t\t\t\t],\n\t\t\t\t\tmockHTMLElement(),\n\t\t\t\t\t0\n\t\t\t\t)\n\t\t\t).toThrowError(\"Missing child @ index 2 for element\");\n\t\t});\n\t\ttest(\"[findBoundaries] - ok\", () => {\n\t\t\tconst element = mockHTMLElement();\n\t\t\tconst collection = [\n\t\t\t\tmockCompleteCardContext({\n", "\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [2],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [3],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tmockCompleteCardContext({\n", "\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [4],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [6],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t];\n", "\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\t\texpect(() =>\n\t\t\t\tfindBoundaries([5], collection, element, 0)\n\t\t\t).not.toThrowError();\n\t\t});\n\t\ttest(\"[findBoundaries] - should not offset start position\", () => {\n\t\t\tconst element = mockHTMLElement();\n\t\t\tconst collection = [\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcardData: {\n", "\t\t\t\t\tstartDate: [3],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcardData: {\n\t\t\t\t\t\tstartDate: [4],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\tcardData: {\n", "\t\t\t\t\tstartDate: [6],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t];\n\t\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\t\texpect(() =>\n\t\t\t\tfindBoundaries([5], collection, element, 0)\n\t\t\t).not.toThrowError();\n\t\t});\n\t\ttest(\"[getInLerpValues] - ok\", () => {\n", "\t\texpect(\n\t\t\t\tgetInLerpValues(\n\t\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 45],\n\t\t\t\t\t[]\n\t\t\t\t)\n\t\t\t).toStrictEqual([5, 45, undefined]);\n\t\t\texpect(\n\t\t\t\tgetInLerpValues(\n\t\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n", "\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 45],\n\t\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 43]\n\t\t\t\t)\n\t\t\t).toStrictEqual([5, 45, 43]);\n\t\t\texpect(\n\t\t\t\tgetInLerpValues(\n\t\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 5],\n\t\t\t\t\t[1, 1, 1, 1, 1, 1, 1, 43]\n\t\t\t\t)\n", "\t\t).toStrictEqual([0, 1, 1]);\n\t\t});\n\t\ttest(\"[findEndPositionForDate] - No collection lenght\", () => {\n\t\t\texpect(\n\t\t\t\tfindEndPositionForDate(\n\t\t\t\t\t[1],\n\t\t\t\t\t[mockCompleteCardContext()],\n\t\t\t\t\t420,\n\t\t\t\t\tmockHTMLElement(),\n\t\t\t\t\t0\n", "\t\t\t)\n\t\t\t).toBe(420);\n\t\t});\n\t\ttest(\"[findEndPositionForDate] - Boundary fetch failure\", () => {\n\t\t\texpect(\n\t\t\t\tfindEndPositionForDate(\n\t\t\t\t\t[1],\n\t\t\t\t\t[mockCompleteCardContext(), mockCompleteCardContext()],\n\t\t\t\t\t420,\n\t\t\t\t\tmockHTMLElement(),\n", "\t\t\t\t0\n\t\t\t\t)\n\t\t\t).toBe(420);\n\t\t});\n\t\ttest(\"[findEndPositionForDate] - ok\", () => {\n\t\t\tconst element = mockHTMLElement();\n\t\t\telement.children.item = vi.fn(mockHTMLElement);\n\t\t\texpect(\n\t\t\t\tfindEndPositionForDate(\n\t\t\t\t\t[3],\n", "\t\t\t\t[\n\t\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\t\tstartDate: [2],\n\t\t\t\t\t\t\t},\n", "\t\t\t\t\t}),\n\t\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\t\tstartDate: [4],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t],\n\t\t\t\t\t420,\n\t\t\t\t\telement,\n\t\t\t\t\t0\n", "\t\t\t)\n\t\t\t).toBe(0);\n\t\t});\n\t\ttest(\"[getAllRangeData] - ko no collection length\", () => {\n\t\t\texpect(getAllRangeData([])).toStrictEqual([]);\n\t\t});\n\t\ttest(\"[getAllRangeData] - ko no start date\", () => {\n\t\t\texpect(\n\t\t\t\tgetAllRangeData([\n\t\t\t\t\tmockCompleteCardContext({\n", "\t\t\t\t\tcontext: {\n\t\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t])\n\t\t\t).toStrictEqual([]);\n\t\t});\n\t\ttest(\"[getAllRangeData] - ko no end date\", () => {\n", "\t\texpect(\n\t\t\t\tgetAllRangeData([\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcontext: {\n\t\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t\t\t\t\t\t\tcardListRootElement: mockHTMLElement(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcardData: {\n", "\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t]).length\n\t\t\t).toBe(1);\n\t\t});\n\t\ttest(\"[getAllRangeData] - ok end date under start date\", () => {\n\t\t\texpect(\n\t\t\t\tgetAllRangeData([\n\t\t\t\t\tmockCompleteCardContext({\n", "\t\t\t\t\tcontext: {\n\t\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\t\ttimelineRootElement: mockHTMLElement(),\n\t\t\t\t\t\t\t\tcardListRootElement: mockHTMLElement(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\t\tendDate: [0],\n\t\t\t\t\t\t},\n", "\t\t\t\t}),\n\t\t\t\t]).length\n\t\t\t).toBe(0);\n\t\t});\n\t\ttest(\"[getAllRangeData] - ko missing HTMLElements\", () => {\n\t\t\tconst element = mockHTMLElement();\n\t\t\telement.children.item = vi.fn(() => null);\n\t\t\texpect(\n\t\t\t\tgetAllRangeData([\n\t\t\t\t\tmockCompleteCardContext({\n", "\t\t\t\t\tcontext: {\n\t\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\t\tendDate: true,\n\t\t\t\t\t\t},\n", "\t\t\t\t}),\n\t\t\t\t]).length\n\t\t\t).toBe(0);\n\t\t});\n\t\ttest(\"[getAllRangeData] - ok end date is infinite\", () => {\n\t\t\tconst element = mockHTMLElement();\n\t\t\texpect(\n\t\t\t\tgetAllRangeData([\n\t\t\t\t\tmockCompleteCardContext({\n\t\t\t\t\t\tcontext: {\n", "\t\t\t\t\t\telements: {\n\t\t\t\t\t\t\t\ttimelineRootElement: element,\n\t\t\t\t\t\t\t\tcardListRootElement: element,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\tstartDate: [1],\n\t\t\t\t\t\t\tendDate: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n", "\t\t\t]).length\n\t\t\t).toBe(1);\n\t\t});\n\t});\n"]}
{"filename": "tests/timelineMarkup.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport { SETTINGS_DEFAULT } from \"~/settings\";\n\timport { setupTimelineCreation } from \"~/timelineMarkup\";\n\timport { mockObsidianApp, mockHTMLElement } from \"./obsidianMocks\";\n\tdescribe.concurrent(\"Timeline Markup\", () => {\n\t\ttest(\"[setupTimelineCreation] - ok\", () => {\n\t\t\tconst ObsidianAppMock = mockObsidianApp();\n\t\t\tconst HTMLElementMock = mockHTMLElement();\n\t\t\tconst data = setupTimelineCreation(\n\t\t\t\tObsidianAppMock,\n", "\t\t\tHTMLElementMock,\n\t\t\t\t\"sample\",\n\t\t\t\tSETTINGS_DEFAULT\n\t\t\t);\n\t\t\texpect(data.length).toBe(1);\n\t\t\texpect(ObsidianAppMock.metadataCache.getFileCache).toBeCalledTimes(2);\n\t\t\texpect(ObsidianAppMock.vault.getMarkdownFiles).toBeCalledTimes(1);\n\t\t\texpect(data[0].settings).toBe(SETTINGS_DEFAULT);\n\t\t\texpectTypeOf(\n\t\t\t\t// @ts-expect-error\n", "\t\t\tdata[0].cachedMetadata.frontmatter[\n\t\t\t\t\tSETTINGS_DEFAULT.metadataKeyEventStartDate\n\t\t\t\t]\n\t\t\t).toMatchTypeOf<number>();\n\t\t});\n\t});\n"]}
{"filename": "tests/markdownBlockData.test.ts", "chunked_list": ["import \"./obsidianMocks\";\n\timport { parseMarkdownBlockSource } from \"~/markdownBlockData\";\n\tdescribe.concurrent(\"Markdown block data\", () => {\n\t\ttest(\"[parseMarkdownBlockSource] - ok no additional settings\", () => {\n\t\t\tconst { tagsToFind, settingsOverride } = parseMarkdownBlockSource(\n\t\t\t\t'       only-timeline-name     \\n    asdjaslkdjasldkja  ajds las jd\\n:::Asdsadada2#$@#$\"@#$@#$'\n\t\t\t);\n\t\t\texpect(tagsToFind).toStrictEqual([\"only-timeline-name\"]);\n\t\t\texpect(settingsOverride).toStrictEqual({});\n\t\t});\n", "\ttest(\"[parseMarkdownBlockSource] - ok empty\", () => {\n\t\t\tconst { tagsToFind, settingsOverride } = parseMarkdownBlockSource(\"\");\n\t\t\texpect(tagsToFind).toStrictEqual([]);\n\t\t\texpect(settingsOverride).toStrictEqual({});\n\t\t});\n\t\ttest(\"[parseMarkdownBlockSource] - ok settings\", () => {\n\t\t\tconst { tagsToFind, settingsOverride } = parseMarkdownBlockSource(\n\t\t\t\t\"timeline-name\\ndateDisplayFormat     :     {year}\\n      faultyKey: notValid\\ndateTokenConfiguration: this is a valid key but the override is not supported yet\\napplyAdditonalConditionFormatting: FaLse\\napplyAdditonalConditionFormatting: true\"\n\t\t\t);\n\t\t\texpect(tagsToFind).toStrictEqual([\"timeline-name\"]);\n", "\t\texpect(settingsOverride).toStrictEqual({\n\t\t\t\tdateDisplayFormat: \"{year}\",\n\t\t\t\tapplyAdditonalConditionFormatting: true,\n\t\t\t});\n\t\t});\n\t\ttest(\"[parseMarkdownBlockSource] - ko settings - faulty value for boolean type\", () => {\n\t\t\texpect(() =>\n\t\t\t\tparseMarkdownBlockSource(\n\t\t\t\t\t\"timeline-name\\ndateDisplayFormat     :     {year}\\n      faultyKey: notValid\\ndateTokenConfiguration: this is a valid key but the override is not supported yet\\napplyAdditonalConditionFormatting: notValidValue\"\n\t\t\t\t)\n", "\t\t).toThrowError(\"notValidValue is supposed to be a boolean\");\n\t\t});\n\t});\n"]}
{"filename": "src/rangeData.ts", "chunked_list": ["import {\n\t\tisDefined,\n\t\tfindLastIndex,\n\t\tlerp,\n\t\tinLerp,\n\t\tgetChildAtIndexInHTMLElement,\n\t\tcompareAbstractDates,\n\t} from \"~/utils\";\n\timport type { CompleteCardContext, AbstractDate } from \"~/types\";\n\t/**\n", " * Will compute all the data needed to build ranges in the timeline.\n\t *\n\t * @param collection - The complete collection of relevant data gathered from notes.\n\t * @returns the needed  data to build ranges in the timeline.\n\t */\n\texport function getAllRangeData(collection: CompleteCardContext[]) {\n\t\tif (!collection.length) return [];\n\t\treturn collection.reduce(\n\t\t\t(accumulator, relatedCardData, index) => {\n\t\t\t\tconst {\n", "\t\t\t\tcontext: {\n\t\t\t\t\t\telements: { timelineRootElement, cardListRootElement },\n\t\t\t\t\t},\n\t\t\t\t\tcardData: { startDate, endDate },\n\t\t\t\t} = relatedCardData;\n\t\t\t\tif (!isDefined(startDate) || !isDefined(endDate))\n\t\t\t\t\treturn accumulator;\n\t\t\t\tif (\n\t\t\t\t\tendDate !== true &&\n\t\t\t\t\tcompareAbstractDates(endDate, startDate) < 0\n", "\t\t\t)\n\t\t\t\t\treturn accumulator;\n\t\t\t\tconst timelineLength = timelineRootElement.offsetHeight;\n\t\t\t\tconst targetCard = cardListRootElement.children.item(\n\t\t\t\t\tindex\n\t\t\t\t) as HTMLElement | null;\n\t\t\t\t// Error handling but should not happen\n\t\t\t\tif (!targetCard) return accumulator;\n\t\t\t\tconst cardRelativeTopPosition = targetCard.offsetTop;\n\t\t\t\tlet targetPosition: number;\n", "\t\t\tif (endDate === true) targetPosition = timelineLength;\n\t\t\t\telse\n\t\t\t\t\ttargetPosition = findEndPositionForDate(\n\t\t\t\t\t\tendDate,\n\t\t\t\t\t\tcollection.slice(index),\n\t\t\t\t\t\ttimelineLength,\n\t\t\t\t\t\tcardListRootElement,\n\t\t\t\t\t\tindex\n\t\t\t\t\t);\n\t\t\t\taccumulator.push({\n", "\t\t\t\trelatedCardData: {\n\t\t\t\t\t\t...relatedCardData,\n\t\t\t\t\t\tcardData: {\n\t\t\t\t\t\t\t...relatedCardData.cardData,\n\t\t\t\t\t\t\tendDate,\n\t\t\t\t\t\t\tstartDate,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttargetPosition,\n\t\t\t\t\tcardRelativeTopPosition,\n", "\t\t\t\tindex,\n\t\t\t\t} as const);\n\t\t\t\treturn accumulator;\n\t\t\t},\n\t\t\t[] as {\n\t\t\t\treadonly relatedCardData: CompleteCardContext & {\n\t\t\t\t\tcardData: CompleteCardContext[\"cardData\"] & {\n\t\t\t\t\t\tstartDate: AbstractDate;\n\t\t\t\t\t\tendDate: AbstractDate | true;\n\t\t\t\t\t};\n", "\t\t\t};\n\t\t\t\treadonly index: number;\n\t\t\t\treadonly targetPosition: number;\n\t\t\t\treadonly cardRelativeTopPosition: number;\n\t\t\t}[]\n\t\t);\n\t}\n\texport type FnGetRangeData = typeof getAllRangeData;\n\t/**\n\t * Finds the end position in pixel relative to the top of the timeline root element for the give endDate of a range.\n", " *\n\t * @param date - The target endDate to position on the timeline.\n\t * @param collection - The collection of cards part of the same timeline.\n\t * @param timelineLength - The length in pixel of the timeline.\n\t * @param rootElement - The root HTMLElement of the cardList.\n\t * @param indexOffset  - Since the date is already sorted by date we can save a little time by skipping all the elements before.\n\t * @returns The expected position relative to the top of the timeline container for this date range.\n\t */\n\texport function findEndPositionForDate(\n\t\tdate: AbstractDate,\n", "\tcollection: CompleteCardContext[],\n\t\ttimelineLength: number,\n\t\trootElement: HTMLElement,\n\t\tindexOffset: number\n\t): number {\n\t\tif (collection.length <= 1) return timelineLength;\n\t\ttry {\n\t\t\tconst { start, end } = findBoundaries(\n\t\t\t\tdate,\n\t\t\t\tcollection,\n", "\t\t\trootElement,\n\t\t\t\tindexOffset\n\t\t\t);\n\t\t\tconst [inLerpStart, inLerpEnd, targetInLerpDate] = getInLerpValues(\n\t\t\t\tstart.date,\n\t\t\t\tend.date,\n\t\t\t\tdate\n\t\t\t);\n\t\t\tconst t = inLerp(inLerpStart, inLerpEnd, targetInLerpDate);\n\t\t\treturn lerp(start.top, end.top, t);\n", "\t} catch (_) {\n\t\t\treturn timelineLength;\n\t\t}\n\t}\n\t/**\n\t * Gets the values to compute the inlerp needed for range gutter renders.\n\t *\n\t * @param a - The start date\n\t * @param b - The end date\n\t * @param c - The date in between\n", " * @returns the first non equal member of a - b when compared from left to right, also returns the same member from c.\n\t */\n\texport function getInLerpValues(\n\t\ta: AbstractDate,\n\t\tb: AbstractDate,\n\t\tc: AbstractDate\n\t): [number, number, number] {\n\t\tfor (let index = 0; index < a.length; index++) {\n\t\t\tif (a[index] === b[index]) continue;\n\t\t\treturn [a[index], b[index], c[index]];\n", "\t}\n\t\treturn [0, 1, 1];\n\t}\n\ttype Boundary = { date: AbstractDate; top: number };\n\t/**\n\t * Find the position of the last card having a lower start date and the first card with a higher start date relative to the endDate of the evaluated range.\n\t *\n\t * @param date - The target endDate to position on the timeline.\n\t * @param collection - The collection of cards part of the same timeline.\n\t * @param rootElement - The root HTMLElement of the cardList.\n", " * @param indexOffset  - Since the date is already sorted by date we can save a little time by skipping all the elements before.\n\t * @returns The start and end boundaries of the target end date.\n\t */\n\texport function findBoundaries(\n\t\tdate: AbstractDate,\n\t\tcollection: CompleteCardContext[],\n\t\trootElement: HTMLElement,\n\t\tindexOffset: number\n\t): { start: Boundary; end: Boundary } {\n\t\tconst firstOverIndex = collection.findIndex(({ cardData: { startDate } }) =>\n", "\t\tisDefined(startDate) ? compareAbstractDates(startDate, date) > 0 : false\n\t\t);\n\t\tif (firstOverIndex === -1)\n\t\t\tthrow new Error(\n\t\t\t\t\"No first over found - Can't draw range since there are no other two start date to referrence it's position\"\n\t\t\t);\n\t\tconst firstLastUnderIndex = findLastIndex(\n\t\t\tcollection,\n\t\t\t({ cardData: { startDate } }) =>\n\t\t\t\tisDefined(startDate)\n", "\t\t\t\t? compareAbstractDates(startDate, date) <= 0\n\t\t\t\t\t: false\n\t\t);\n\t\tif (firstLastUnderIndex === -1)\n\t\t\tthrow new Error(\n\t\t\t\t\"Could not find a firstLastUnderIndex, this means this function was called with un rangeable members\"\n\t\t\t);\n\t\tconst lastUnderIndex = collection.findIndex(\n\t\t\t({ cardData: { startDate } }, index) => {\n\t\t\t\treturn (\n", "\t\t\t\tcompareAbstractDates(\n\t\t\t\t\t\tstartDate,\n\t\t\t\t\t\tcollection[firstLastUnderIndex].cardData.startDate\n\t\t\t\t\t) === 0\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t\tif (lastUnderIndex === -1)\n\t\t\tthrow new Error(\n\t\t\t\t\"No last under found - Can't draw range since there are no other two start date to referrence it's position\"\n", "\t\t);\n\t\tconst startElement = getChildAtIndexInHTMLElement(\n\t\t\trootElement,\n\t\t\tlastUnderIndex + indexOffset\n\t\t);\n\t\tconst startDate = collection[lastUnderIndex].cardData\n\t\t\t.startDate as AbstractDate;\n\t\tconst startIsMoreThanOneCardAway = lastUnderIndex > 1;\n\t\tconst shouldOffsetStartToBottomOfCard =\n\t\t\tstartIsMoreThanOneCardAway &&\n", "\t\tcompareAbstractDates(startDate, date) !== 0;\n\t\treturn {\n\t\t\tstart: {\n\t\t\t\ttop:\n\t\t\t\t\tstartElement.offsetTop +\n\t\t\t\t\t(shouldOffsetStartToBottomOfCard\n\t\t\t\t\t\t? startElement.innerHeight\n\t\t\t\t\t\t: 0),\n\t\t\t\tdate: startDate,\n\t\t\t},\n", "\t\tend: {\n\t\t\t\ttop: getChildAtIndexInHTMLElement(\n\t\t\t\t\trootElement,\n\t\t\t\t\tfirstOverIndex + indexOffset\n\t\t\t\t).offsetTop,\n\t\t\t\tdate: collection[firstOverIndex].cardData.startDate as AbstractDate,\n\t\t\t},\n\t\t};\n\t}\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { MarkdownPostProcessorContext, Plugin } from \"obsidian\";\n\timport type { AutoTimelineSettings, CompleteCardContext } from \"~/types\";\n\timport { compareAbstractDates, isDefined, measureTime } from \"~/utils\";\n\timport { getDataFromNoteMetadata, getDataFromNoteBody } from \"~/cardData\";\n\timport { setupTimelineCreation } from \"~/timelineMarkup\";\n\timport { createCardFromBuiltContext } from \"~/cardMarkup\";\n\timport { getAllRangeData } from \"~/rangeData\";\n\timport { renderRanges } from \"~/rangeMarkup\";\n\timport { SETTINGS_DEFAULT, TimelineSettingTab } from \"~/settings\";\n\timport { parseMarkdownBlockSource } from \"./markdownBlockData\";\n", "export default class AprilsAutomaticTimelinesPlugin extends Plugin {\n\t\tsettings: AutoTimelineSettings;\n\t\t/**\n\t\t * The default onload method of a obsidian plugin\n\t\t * See the official documentation for more details\n\t\t */\n\t\tasync onload() {\n\t\t\tawait this.loadSettings();\n\t\t\tthis.registerMarkdownCodeBlockProcessor(\n\t\t\t\t\"aat-vertical\",\n", "\t\t\t(source, element, context) => {\n\t\t\t\t\tthis.run(source, element, context);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tonunload() {}\n\t\t/**\n\t\t * Main runtime function to process a single timeline.\n\t\t *\n\t\t * @param source - The content found in the markdown block.\n", "\t * @param element - The root element of all the timeline.\n\t\t * @param param2 - The context provided by obsidians `registerMarkdownCodeBlockProcessor()` method.\n\t\t * @param param2.sourcePath - A string representing the fs path of a note.\n\t\t */\n\t\tasync run(\n\t\t\tsource: string,\n\t\t\telement: HTMLElement,\n\t\t\t{ sourcePath }: MarkdownPostProcessorContext\n\t\t) {\n\t\t\tconst runtimeTime = measureTime(\"Run time\");\n", "\t\tconst { app } = this;\n\t\t\tconst { tagsToFind, settingsOverride } =\n\t\t\t\tparseMarkdownBlockSource(source);\n\t\t\tconst finalSettings = { ...this.settings, ...settingsOverride };\n\t\t\tconst creationContext = setupTimelineCreation(\n\t\t\t\tapp,\n\t\t\t\telement,\n\t\t\t\tsourcePath,\n\t\t\t\tfinalSettings\n\t\t\t);\n", "\t\tconst cardDataTime = measureTime(\"Data fetch\");\n\t\t\tconst events: CompleteCardContext[] = [];\n\t\t\tfor (const context of creationContext) {\n\t\t\t\tconst baseData = await getDataFromNoteMetadata(context, tagsToFind);\n\t\t\t\tif (isDefined(baseData)) events.push(baseData);\n\t\t\t\tif (!finalSettings.lookForInlineEventsInNotes) continue;\n\t\t\t\tconst body =\n\t\t\t\t\tbaseData?.cardData.body ||\n\t\t\t\t\t(await context.file.vault.cachedRead(context.file));\n\t\t\t\tconst inlineEvents = (\n", "\t\t\t\tawait getDataFromNoteBody(body, context, tagsToFind)\n\t\t\t\t).filter(isDefined);\n\t\t\t\tif (!inlineEvents.length) continue;\n\t\t\t\tevents.push(...inlineEvents);\n\t\t\t}\n\t\t\tevents.sort(\n\t\t\t\t(\n\t\t\t\t\t{ cardData: { startDate: a, endDate: aE } },\n\t\t\t\t\t{ cardData: { startDate: b, endDate: bE } }\n\t\t\t\t) => {\n", "\t\t\t\tconst score = compareAbstractDates(a, b);\n\t\t\t\t\tif (score) return score;\n\t\t\t\t\treturn compareAbstractDates(aE, bE);\n\t\t\t\t}\n\t\t\t);\n\t\t\tcardDataTime();\n\t\t\tconst cardRenderTime = measureTime(\"Card Render\");\n\t\t\tevents.forEach(({ context, cardData }) =>\n\t\t\t\tcreateCardFromBuiltContext(context, cardData)\n\t\t\t);\n", "\t\tcardRenderTime();\n\t\t\tconst rangeDataFecthTime = measureTime(\"Range Data\");\n\t\t\tconst ranges = getAllRangeData(events);\n\t\t\trangeDataFecthTime();\n\t\t\tconst rangeRenderTime = measureTime(\"Range Render\");\n\t\t\trenderRanges(ranges, element);\n\t\t\trangeRenderTime();\n\t\t\truntimeTime();\n\t\t}\n\t\t/**\n", "\t * Loads the saved settings from the local device and sets up the setting tabs in the plugin options.\n\t\t */\n\t\tasync loadSettings() {\n\t\t\tthis.settings = Object.assign(\n\t\t\t\t{},\n\t\t\t\tSETTINGS_DEFAULT,\n\t\t\t\tawait this.loadData()\n\t\t\t);\n\t\t\tfor (\n\t\t\t\tlet index = 0;\n", "\t\t\tindex < this.settings.dateTokenConfiguration.length;\n\t\t\t\tindex++\n\t\t\t) {\n\t\t\t\tthis.settings.dateTokenConfiguration[index].formatting =\n\t\t\t\t\tthis.settings.dateTokenConfiguration[index].formatting || [];\n\t\t\t}\n\t\t\tthis.addSettingTab(new TimelineSettingTab(this.app, this));\n\t\t}\n\t\t/**\n\t\t * Saves the settings in obsidian.\n", "\t */\n\t\tasync saveSettings() {\n\t\t\tawait this.saveData(this.settings);\n\t\t}\n\t}\n"]}
{"filename": "src/markdownBlockData.ts", "chunked_list": ["import { SETTINGS_DEFAULT } from \"~/settings\";\n\timport { AutoTimelineSettings } from \"./types\";\n\timport { isDefined, isDefinedAsBoolean, isDefinedAsString } from \"./utils\";\n\t/**\n\t * Fetches the tags to find and timeline specific settings override.\n\t *\n\t * @param source - The markdown code block source, a.k.a. the content inside the code block.\n\t * @returns Partial settings to override the global ones.\n\t */\n\texport function parseMarkdownBlockSource(source: string): {\n", "\treadonly tagsToFind: string[];\n\t\treadonly settingsOverride: Partial<AutoTimelineSettings>;\n\t} {\n\t\tconst sourceEntries = source.split(\"\\n\");\n\t\tif (!source.length)\n\t\t\treturn { tagsToFind: [] as string[], settingsOverride: {} } as const;\n\t\tconst tagsToFind = sourceEntries[0]\n\t\t\t.split(SETTINGS_DEFAULT.markdownBlockTagsToFindSeparator)\n\t\t\t.map((e) => e.trim());\n\t\tsourceEntries.shift();\n", "\treturn {\n\t\t\ttagsToFind,\n\t\t\tsettingsOverride: sourceEntries.reduce((accumulator, element) => {\n\t\t\t\treturn {\n\t\t\t\t\t...accumulator,\n\t\t\t\t\t...parseSingleLine(element),\n\t\t\t\t};\n\t\t\t}, {} as Partial<AutoTimelineSettings>),\n\t\t} as const;\n\t}\n", "type OverridableSettingKey = (typeof acceptedSettingsOverride)[number];\n\tconst acceptedSettingsOverride = [\n\t\t\"dateDisplayFormat\",\n\t\t\"applyAdditonalConditionFormatting\",\n\t] as const;\n\t/**\n\t * Checks if a given string is part of the settings keys that can be overriden.\n\t *\n\t * @param value - A given settings key.\n\t * @returns the typeguard boolean `true` if the key is indeed overridable.\n", " */\n\tfunction isOverridableSettingsKey(\n\t\tvalue: string\n\t): value is OverridableSettingKey {\n\t\t// @ts-expect-error\n\t\treturn acceptedSettingsOverride.includes(value);\n\t}\n\t/**\n\t * Will apply the needed formatting to a setting value based of it's key.\n\t *\n", " * @param key - The settings key.\n\t * @param value - The value associated to this value.\n\t * @returns Undefined if unvalid or the actual expected value.\n\t */\n\tfunction formatValueFromKey(\n\t\tkey: string,\n\t\tvalue: string\n\t): AutoTimelineSettings[OverridableSettingKey] | undefined {\n\t\tif (!isOverridableSettingsKey(key)) return undefined;\n\t\tif (isDefinedAsString(SETTINGS_DEFAULT[key])) return value;\n", "\tif (isDefinedAsBoolean(SETTINGS_DEFAULT[key])) {\n\t\t\tconst validBooleanStrings = [\"true\", \"false\"];\n\t\t\tif (!validBooleanStrings.includes(value.toLocaleLowerCase()))\n\t\t\t\tthrow new Error(`${value} is supposed to be a boolean`);\n\t\t\treturn value.toLocaleLowerCase() === \"true\" ? true : false;\n\t\t}\n\t\treturn undefined;\n\t}\n\t/**\n\t * Parse a single line of the timeline markdown block content.\n", " *\n\t * @param line - The line to parse.\n\t * @returns A potencialy partial settings object.\n\t */\n\tfunction parseSingleLine(line: string): Partial<AutoTimelineSettings> {\n\t\tconst reg = /((?<key>(\\s|\\d|[a-z])*):(?<value>.*))/i;\n\t\tconst matches = line.match(reg);\n\t\tif (\n\t\t\t!matches ||\n\t\t\t!matches.groups ||\n", "\t\t!isDefinedAsString(matches.groups.key) ||\n\t\t\t!isDefined(matches.groups.value)\n\t\t)\n\t\t\treturn {};\n\t\tconst key = matches.groups.key.trim();\n\t\tconst value = formatValueFromKey(key, matches.groups.value.trim());\n\t\tif (!isDefined(value)) return {};\n\t\treturn { [key]: value };\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { SETTINGS_DEFAULT } from \"~/settings\";\n\timport { FnGetRangeData } from \"./rangeData\";\n\timport { FnExtractCardData, getDataFromNoteMetadata } from \"~/cardData\";\n\timport type { App, CachedMetadata, TFile } from \"obsidian\";\n\timport type { Merge } from \"ts-essentials\";\n\t/**\n\t * @author https://stackoverflow.com/a/69756175\n\t */\n\texport type PickByType<T, Value> = {\n\t\t[P in keyof T as T[P] extends Value | undefined ? P : never]: T[P];\n", "};\n\texport type AutoTimelineSettings = typeof SETTINGS_DEFAULT;\n\t/**\n\t * The main bundle of data needed to build a timeline.\n\t */\n\texport interface MarkdownCodeBlockTimelineProcessingContext {\n\t\t/**\n\t\t * Obsidian application context.\n\t\t */\n\t\tapp: App;\n", "\t/**\n\t\t * The plugins settings\n\t\t */\n\t\tsettings: AutoTimelineSettings;\n\t\t/**\n\t\t * The formatted metadata of a single note.\n\t\t */\n\t\tcachedMetadata: CachedMetadata;\n\t\t/**\n\t\t * The file data of a single note.\n", "\t */\n\t\tfile: TFile;\n\t\t/**\n\t\t * The filepath of a single timeline.\n\t\t */\n\t\ttimelineFile: string;\n\t\t/**\n\t\t * Shorthand access to HTMLElements for the range timelines and the card list.\n\t\t */\n\t\telements: {\n", "\t\ttimelineRootElement: HTMLElement;\n\t\t\tcardListRootElement: HTMLElement;\n\t\t};\n\t}\n\t/**\n\t * The context extracted from a single note to create a single card in the timeline combined with the more general purpise timeline context.\n\t */\n\texport type CompleteCardContext = Exclude<\n\t\tAwaited<ReturnType<typeof getDataFromNoteMetadata>>,\n\t\tundefined\n", ">;\n\t/**\n\t * The context extracted from a single note to create a single card in the timeline.\n\t */\n\texport type CardContent = Awaited<ReturnType<FnExtractCardData>>;\n\t/**\n\t * The needed data to compute a range in a single timeline.\n\t */\n\texport type Range = ReturnType<FnGetRangeData>[number];\n\t/**\n", " * An abstract representation of a fantasy date.\n\t * Given the fickle nature of story telling and how people will literally almost never stick to standard date formats\n\t * We'll organise the dates in segments, let's take for example our human callendar\n\t * The date will commonly be segmented in 3 parts year, month and day the abstract representation will equate to\n\t * `[year, month, day]`\n\t * Now if someone wants to make a more complex date system like `[cycle, moon, phase, day]` we can treat them the same when sorting and performing computing tasks on those dates.\n\t * The only major limitation to this system is that all the dates must respect the same system.\n\t */\n\texport type AbstractDate = number[];\n\t/**\n", " * Before formatting an abstract date, the end user can configure it's output display\n\t * This DateToken type helps to determine what's the nature of a given token\n\t * E.g. should it be displayed as a number or as a string ?\n\t */\n\texport enum DateTokenType {\n\t\tnumber = \"NUMBER\",\n\t\tstring = \"STRING\",\n\t}\n\texport const availableDateTokenTypeArray = Object.values(DateTokenType);\n\texport enum Condition {\n", "\tGreater = \"GREATER\",\n\t\tLess = \"LESS\",\n\t\tEqual = \"EQUAL\",\n\t\tNotEqual = \"NOTEQUAL\",\n\t\tGreaterOrEqual = \"GREATEROREQUAL\",\n\t\tLessOrEqual = \"LESSOREQUAL\",\n\t}\n\texport const availableConditionArray = Object.values(Condition);\n\texport type Evaluation<T extends number = number> = {\n\t\tcondition: Condition;\n", "\tvalue: T;\n\t};\n\texport type AdditionalDateFormatting<T extends number = number> = {\n\t\tevaluations: Evaluation<T>[];\n\t\t/**\n\t\t * Basically: if `true` the conditions all need to be `true` to return `true`. Else it only need one of the conditions to be checked.\n\t\t */\n\t\tconditionsAreExclusive: boolean;\n\t\t/**\n\t\t * Use `{value}` to include the pre-formated output of the numerical value held.\n", "\t */\n\t\tformat: string;\n\t};\n\t/**\n\t * The data used to compute the output of an abstract date based on it's type\n\t */\n\ttype CommonValues<T extends DateTokenType> = {\n\t\tname: string;\n\t\ttype: T;\n\t\tformatting: AdditionalDateFormatting[];\n", "};\n\texport type DateTokenConfiguration<T extends DateTokenType = DateTokenType> =\n\t\tT extends DateTokenType.number\n\t\t\t? NumberSpecific\n\t\t\t: T extends DateTokenType.string\n\t\t\t? StringSpecific\n\t\t\t: StringSpecific | NumberSpecific;\n\t/**\n\t * Number typed date token.\n\t */\n", "type NumberSpecific = Merge<\n\t\tCommonValues<DateTokenType.number>,\n\t\t{\n\t\t\t/**\n\t\t\t * The minimum ammount of digits when displaying the date\n\t\t\t */\n\t\t\tminLeght: number;\n\t\t\tdisplayWhenZero: boolean;\n\t\t\thideSign: boolean;\n\t\t}\n", ">;\n\t/**\n\t * String typed date token.\n\t */\n\ttype StringSpecific = Merge<\n\t\tCommonValues<DateTokenType.string>,\n\t\t{\n\t\t\t/**\n\t\t\t * The dictionary reference for the token\n\t\t\t */\n", "\t\tdictionary: string[];\n\t\t}\n\t>;\n"]}
{"filename": "src/rangeMarkup.ts", "chunked_list": ["import {\n\t\tcreateElementShort,\n\t\tisDefined,\n\t\tgetChildAtIndexInHTMLElement,\n\t\tcompareAbstractDates,\n\t} from \"~/utils\";\n\timport type { Range } from \"~/types\";\n\t/**\n\t * The color palette that obsidian defined in it's css bundle.\n\t * Useful for applying colors to elements programatically.\n", " */\n\tconst AVAILABLE_COLORS = [\n\t\t\"red\",\n\t\t\"orange\",\n\t\t\"yellow\",\n\t\t\"green\",\n\t\t\"cyan\",\n\t\t\"blue\",\n\t\t\"purple\",\n\t\t\"pink\",\n", "] as const;\n\t/**\n\t * Renders the little stripes in the gutter of the timeline.\n\t *\n\t * @param ranges - A collection of ranges.\n\t * @param rootElement - The root of all elements for this complete timeline.\n\t */\n\texport function renderRanges(ranges: Range[], rootElement: HTMLElement) {\n\t\tconst endDates: (number[] | true | undefined)[] = AVAILABLE_COLORS.map(\n\t\t\t() => undefined\n", "\t);\n\t\tranges.forEach((range) => {\n\t\t\tconst {\n\t\t\t\trelatedCardData: {\n\t\t\t\t\tcardData: { startDate, endDate },\n\t\t\t\t},\n\t\t\t} = range;\n\t\t\tconst offsetIndex = endDates.findIndex(\n\t\t\t\t(date) =>\n\t\t\t\t\t!isDefined(date) ||\n", "\t\t\t\t(date !== true && compareAbstractDates(startDate, date) > 0)\n\t\t\t);\n\t\t\t// Over the color limit\n\t\t\tif (offsetIndex === -1) return;\n\t\t\trenderSingleRange(range, offsetIndex, rootElement);\n\t\t\tendDates[offsetIndex] = endDate;\n\t\t});\n\t}\n\t/**\n\t * Renders a single range element based off the offset computed previously.\n", " *\n\t * @param param0 - A single range.\n\t * @param param0.index - The index of the card.\n\t * @param param0.targetPosition - The target position of a given range. This determines where the rage should end.\n\t * @param param0.cardRelativeTopPosition - The ammount of pixel from the top of the timeline relative to a given card.\n\t * @param param0.relatedCardData - The associated card data.\n\t * @param param0.relatedCardData.context - The associated runtime context for this card.\n\t * @param param0.relatedCardData.context.elements - The HTMLElements exposed for this context.\n\t * @param param0.relatedCardData.context.elements.cardListRootElement - The right side of the timeline, this is where the carads are spawned.\n\t * @param param0.relatedCardData.context.elements.timelineRootElement - The base layer for the timeline.\n", " * @param offset - The left offet index for this range.\n\t * @param rootElelement - The root HTMLElement of the timeline elements.\n\t *\n\t * @returns Nothing, but it renders a single range inside it's target element.\n\t */\n\texport function renderSingleRange(\n\t\t{\n\t\t\trelatedCardData: {\n\t\t\t\tcontext: {\n\t\t\t\t\telements: { timelineRootElement, cardListRootElement },\n", "\t\t\t},\n\t\t\t},\n\t\t\ttargetPosition,\n\t\t\tcardRelativeTopPosition,\n\t\t\tindex,\n\t\t}: Range,\n\t\toffset: number,\n\t\trootElelement: HTMLElement\n\t) {\n\t\tconst el = createElementShort(\n", "\t\ttimelineRootElement,\n\t\t\t\"div\",\n\t\t\t\"aat-range-element\"\n\t\t);\n\t\tel.style.height = `${targetPosition - cardRelativeTopPosition}px`;\n\t\tel.style.top = `${cardRelativeTopPosition}px`;\n\t\tel.style.left = `${offset * 12}px`;\n\t\tel.style.backgroundColor = `var(--color-${AVAILABLE_COLORS[offset]})`;\n\t\t// Setup highlight link\n\t\tconst relativeCardClassName = \"aat-highlight-relative-card-to-range\";\n", "\tel.onmouseenter = () => {\n\t\t\tconst relativeCard = getChildAtIndexInHTMLElement(\n\t\t\t\tcardListRootElement,\n\t\t\t\tindex\n\t\t\t);\n\t\t\trelativeCard.classList.add(relativeCardClassName);\n\t\t};\n\t\tel.onmouseleave = () => {\n\t\t\tconst relativeCard = getChildAtIndexInHTMLElement(\n\t\t\t\tcardListRootElement,\n", "\t\t\tindex\n\t\t\t);\n\t\t\trelativeCard.classList.remove(relativeCardClassName);\n\t\t};\n\t\t// Setup click event\n\t\tel.onclick = () => {\n\t\t\tconst el = window.document.querySelector(\n\t\t\t\t\".markdown-reading-view > .markdown-preview-view\"\n\t\t\t);\n\t\t\tif (!el) return;\n", "\t\tel.scrollTo({\n\t\t\t\ttop: cardRelativeTopPosition + rootElelement.offsetTop - 8,\n\t\t\t\tbehavior: \"smooth\",\n\t\t\t});\n\t\t};\n\t\treturn el;\n\t}\n"]}
{"filename": "src/i18n.config.ts", "chunked_list": ["import { createI18n } from \"vue-i18n\";\n\timport en from \"~/locales/en.json\";\n\texport default () =>\n\t\tcreateI18n({\n\t\t\tlocale: \"en\",\n\t\t\tfallbackLocale: \"en\",\n\t\t\tmessages: {\n\t\t\t\ten,\n\t\t\t},\n\t\t\tallowComposition: true,\n", "\t});\n"]}
{"filename": "src/cardMarkup.ts", "chunked_list": ["import { MarkdownRenderChild, MarkdownRenderer } from \"obsidian\";\n\timport { isDefined, createElementShort } from \"~/utils\";\n\timport type {\n\t\tMarkdownCodeBlockTimelineProcessingContext,\n\t\tCardContent,\n\t\tAutoTimelineSettings,\n\t} from \"~/types\";\n\timport { formatAbstractDate } from \"./abstractDateFormatting\";\n\t/**\n\t * Generates a card in the DOM based on given ccontext.\n", " *\n\t * @param param0 - The context built for this timeline.\n\t * @param param0.elements - The HTMLElements exposed for this context.\n\t * @param param0.elements.cardListRootElement - The right side of the timeline, this is where the carads are spawned.\n\t * @param param0.file - The target note file.\n\t * @param param0.settings - The plugin's settings.\n\t * @param cardContent - The content of a single timeline card.\n\t */\n\texport function createCardFromBuiltContext(\n\t\t{\n", "\t\telements: { cardListRootElement },\n\t\t\tfile,\n\t\t\tsettings,\n\t\t}: MarkdownCodeBlockTimelineProcessingContext,\n\t\tcardContent: CardContent\n\t): void {\n\t\tconst { body, title, imageURL } = cardContent;\n\t\tconst cardBaseDiv = createElementShort(cardListRootElement, \"a\", [\n\t\t\t\"internal-link\",\n\t\t\t\"aat-card\",\n", "\t]);\n\t\tcardBaseDiv.setAttribute(\"href\", file.path);\n\t\tif (imageURL) {\n\t\t\tcreateElementShort(cardBaseDiv, \"img\", \"aat-card-image\").setAttribute(\n\t\t\t\t\"src\",\n\t\t\t\timageURL\n\t\t\t);\n\t\t\tcardBaseDiv.addClass(\"aat-card-has-image\");\n\t\t}\n\t\tconst cardTextWraper = createElementShort(\n", "\t\tcardBaseDiv,\n\t\t\t\"div\",\n\t\t\t\"aat-card-text-wraper\"\n\t\t);\n\t\tconst titleWrap = createElementShort(\n\t\t\tcardTextWraper,\n\t\t\t\"header\",\n\t\t\t\"aat-card-head-wrap\"\n\t\t);\n\t\tcreateElementShort(titleWrap, \"h2\", \"aat-card-title\", title);\n", "\tcreateElementShort(\n\t\t\ttitleWrap,\n\t\t\t\"h4\",\n\t\t\t\"aat-card-start-date\",\n\t\t\tgetDateText(cardContent, settings).trim()\n\t\t);\n\t\tconst markdownTextWrapper = createElementShort(\n\t\t\tcardTextWraper,\n\t\t\t\"div\",\n\t\t\t\"aat-card-body\"\n", "\t);\n\t\tconst rendered = new MarkdownRenderChild(markdownTextWrapper);\n\t\trendered.containerEl = markdownTextWrapper;\n\t\tMarkdownRenderer.renderMarkdown(\n\t\t\tformatBodyForCard(body),\n\t\t\tmarkdownTextWrapper,\n\t\t\tfile.path,\n\t\t\trendered\n\t\t);\n\t}\n", "/**\n\t * Format the body string of the note data for a single card.\n\t *\n\t * @param body - The body string parsed earlier.\n\t * @returns The formated string ready to be displayed.\n\t */\n\texport function formatBodyForCard(body?: string | null): string {\n\t\tif (!body) return \"No body for this note :(\";\n\t\t// Remove external image links\n\t\treturn (\n", "\t\tbody\n\t\t\t\t.replace(/!\\[.*\\]\\(.*\\)/gi, \"\")\n\t\t\t\t// Remove tags\n\t\t\t\t.replace(/#[a-zA-Z\\d-_]*/gi, \"\")\n\t\t\t\t// Remove internal images ![[Pasted image 20230418232101.png]]\n\t\t\t\t.replace(/!\\[\\[.*\\]\\]/gi, \"\")\n\t\t\t\t// Remove other timelines to avoid circular dependencies!\n\t\t\t\t.replace(/```aat-vertical\\n.*\\n```/gi, \"\")\n\t\t\t\t// Trim the text\n\t\t\t\t.trim()\n", "\t);\n\t}\n\t/**\n\t * Get the text displayed in the card where the date should be.\n\t *\n\t * @param param0 - The context for a single card.\n\t * @param param0.startDate - the start date of an event.\n\t * @param param0.endDate - the end date of an event.\n\t * @param settings - The settings of the plugin.\n\t * @returns a formated string representation of the dates included in the card content based off the settings.\n", " */\n\texport function getDateText(\n\t\t{ startDate, endDate }: Pick<CardContent, \"startDate\" | \"endDate\">,\n\t\tsettings: AutoTimelineSettings\n\t): string {\n\t\tif (!isDefined(startDate)) return \"Start date missing\";\n\t\tconst formatedStart = formatAbstractDate(startDate, settings);\n\t\tif (!isDefined(endDate)) return formatedStart;\n\t\treturn `From ${formatedStart} to ${formatAbstractDate(endDate, settings)}`;\n\t}\n"]}
{"filename": "src/timelineMarkup.ts", "chunked_list": ["import type { App } from \"obsidian\";\n\timport type {\n\t\tAutoTimelineSettings,\n\t\tMarkdownCodeBlockTimelineProcessingContext,\n\t} from \"~/types\";\n\t/**\n\t * A preliminary helper to fetch all the needed context to handle the timeline creation.\n\t *\n\t * @param app - The app context provided by obsidian.\n\t * @param element - The root element of this timeline.\n", " * @param timelineFile - The file path of the timeline.\n\t * @param settings - The plugin's settings.\n\t * @returns the nessessary context to build a timeline.\n\t */\n\texport function setupTimelineCreation(\n\t\tapp: App,\n\t\telement: HTMLElement,\n\t\ttimelineFile: string,\n\t\tsettings: AutoTimelineSettings\n\t) {\n", "\tconst { vault, metadataCache } = app;\n\t\tconst fileArray = vault.getMarkdownFiles();\n\t\tconst root = element.createDiv();\n\t\tconst cardListRootElement = root.createDiv();\n\t\tconst timelineRootElement = root.createDiv();\n\t\telement.classList.add(\"aat-root-container\");\n\t\troot.classList.add(\"aat-vertical-timeline\");\n\t\tcardListRootElement.classList.add(\"aat-card-list-root\");\n\t\ttimelineRootElement.classList.add(\"aat-timeline-root\");\n\t\tconst dataBundleArray = fileArray.reduce((accumulator, file) => {\n", "\t\tconst cachedMetadata = metadataCache.getFileCache(file);\n\t\t\tif (cachedMetadata)\n\t\t\t\taccumulator.push({\n\t\t\t\t\tapp,\n\t\t\t\t\tsettings,\n\t\t\t\t\ttimelineFile,\n\t\t\t\t\tfile,\n\t\t\t\t\tcachedMetadata,\n\t\t\t\t\telements: {\n\t\t\t\t\t\ttimelineRootElement,\n", "\t\t\t\t\tcardListRootElement,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\treturn accumulator;\n\t\t}, [] as MarkdownCodeBlockTimelineProcessingContext[]);\n\t\treturn dataBundleArray;\n\t}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import {\n\t\tAbstractDate,\n\t\tDateTokenConfiguration,\n\t\tMarkdownCodeBlockTimelineProcessingContext,\n\t\tDateTokenType,\n\t\tCondition,\n\t} from \"~/types\";\n\t/**\n\t * Quick util to read obsidians metadata object with some type safety.\n\t *\n", " * @param cachedMetadata - cachedMetadata - Obsidians cachedMetadata object.\n\t * @param key - the sought after key in the obsidian metadata object.\n\t * @param type - The expected type of the key value.\n\t * @returns The metadata value assigned to the given key or null if unvalidated or missing.\n\t */\n\texport function getMetadataKey<T extends \"string\" | \"number\" | \"boolean\">(\n\t\tcachedMetadata: MarkdownCodeBlockTimelineProcessingContext[\"cachedMetadata\"],\n\t\tkey: string,\n\t\ttype: T\n\t):\n", "\t| (T extends \"string\" ? string : T extends \"number\" ? number : boolean)\n\t\t| undefined {\n\t\t// Bail if no formatter object or if the key is missing\n\t\tif (!cachedMetadata.frontmatter) return undefined;\n\t\treturn typeof cachedMetadata.frontmatter[key] === type\n\t\t\t? cachedMetadata.frontmatter[key]\n\t\t\t: undefined;\n\t}\n\t/**\n\t * Typeguard to check if a value is indeed defined.\n", " *\n\t * @param argument a possibly undefined argument.\n\t * @returns `true` if the element is defined, `false` if not.\n\t */\n\texport const isDefined = <T>(argument: T | undefined): argument is T =>\n\t\targument !== undefined;\n\t/**\n\t * Check if a runtime value is defined and is a string.\n\t *\n\t * @param argument a possibly undefined argument.\n", " * @returns `true` if the element is indeed a string, `false` if not.\n\t */\n\texport const isDefinedAsString = (argument: unknown): argument is string =>\n\t\ttypeof argument === \"string\";\n\t/**\n\t * Check if a runtime value is defined and is a boolean\n\t *\n\t * @param argument a possibly undefined argument.\n\t * @returns `true` if the element is indeed a boolean, `false` if not.\n\t */\n", "export const isDefinedAsBoolean = (argument: unknown): argument is boolean =>\n\t\ttypeof argument === \"boolean\";\n\t/**\n\t * Same as `Array.findIndex()` but going from right to left.\n\t *\n\t * @param arr - An array of values\n\t * @param predicate - An evaluation function that works like the one you feed `.findIndex()`\n\t * @returns `-1` if no index was found, or the last occurence of the predicament.\n\t */\n\texport function findLastIndex<T extends unknown[]>(\n", "\tarr: T,\n\t\tpredicate: (arg: T[number]) => boolean\n\t): number {\n\t\tconst length = arr ? arr.length : 0;\n\t\tif (!length) return -1;\n\t\tlet index = length - 1;\n\t\twhile (index--) if (predicate(arr[index])) return index;\n\t\treturn -1;\n\t}\n\t/**\n", " * https://en.wikipedia.org/wiki/Linear_interpolation\n\t *\n\t * @description A naive implementation of the linear interpolation function.\n\t * @param a - First point.\n\t * @param b - Last point.\n\t * @param t - From 0f to 1f, represent the percent of advancement.\n\t * @returns the position between `a` and `b` @ `t`.\n\t */\n\texport const lerp = (a: number, b: number, t: number) => a + t * (b - a);\n\t/**\n", " * https://en.wikipedia.org/wiki/Linear_interpolation\n\t *\n\t * @description The inverse of a lerp.\n\t * @param a - First point.\n\t * @param b - Last point.\n\t * @param v - The desired point to look for.\n\t * @returns The percent value of advancement for `v`\n\t */\n\texport const inLerp = (a: number, b: number, v: number) => (v - a) / (b - a);\n\t/**\n", " * Quick util to measure performance.\n\t *\n\t * @param str - Label for the timer.\n\t * @returns the handler that will close the timer.\n\t */\n\texport const measureTime = (str: string) => {\n\t\tconst value = `[April's automatic timelines] - ${str}`;\n\t\tconsole.time(value);\n\t\treturn () => {\n\t\t\tconsole.timeEnd(value);\n", "\t};\n\t};\n\t/**\n\t * Shorthand function to get childs of a given HTML Element.\n\t *\n\t * @param el - Target HTMLElement.\n\t * @param index - The desired child index.\n\t * @returns - The child at the desired index. If the element is missing the function will throw.\n\t */\n\texport function getChildAtIndexInHTMLElement(\n", "\tel: HTMLElement,\n\t\tindex: number\n\t): HTMLElement {\n\t\tconst child = el.children.item(index) as HTMLElement | null;\n\t\tif (!child) throw new Error(`Missing child @ index ${index} for element`);\n\t\treturn child;\n\t}\n\t/**\n\t * Shorthand function to create an HTMLElement in a given HTMLElement.\n\t *\n", " * @param el - The root element.\n\t * @param element - The desired HTML tag.\n\t * @param classes - A single or a collection of tags.\n\t * @param content - The content to inject inside the created element.\n\t * @returns The created element.\n\t */\n\texport function createElementShort(\n\t\tel: HTMLElement,\n\t\telement: keyof HTMLElementTagNameMap,\n\t\tclasses?: string[] | string,\n", "\tcontent?: string | number\n\t) {\n\t\tconst out = el.createEl(element);\n\t\tif (classes instanceof Array) out.addClass(...classes);\n\t\telse if (classes) out.addClass(classes);\n\t\tif (content !== undefined) out.innerHTML = content.toString();\n\t\treturn out;\n\t}\n\t/**\n\t * Compares two Abstract Dates\n", " *\n\t * @param a - first Abstract Date\n\t * @param b - second Abstract Date\n\t * @returns 0 if they are equal 1 if a > b and -1 if a < b\n\t */\n\texport function compareAbstractDates(\n\t\ta: AbstractDate | undefined | true,\n\t\tb: AbstractDate | undefined | true\n\t) {\n\t\t// Since could be numbers we can't check with `!`\n", "\tif (!isDefined(a) && !isDefined(b)) return 0;\n\t\tif (!isDefined(a)) return -1;\n\t\tif (!isDefined(b)) return 1;\n\t\tif (a === true && b !== true) return 1;\n\t\tif (b === true && a !== true) return -1;\n\t\tif (a === true && b === true) return 0;\n\t\ta = a as AbstractDate;\n\t\tb = b as AbstractDate;\n\t\tfor (let index = 0; index < a.length; index++)\n\t\t\tif (a[index] !== b[index]) return a[index] > b[index] ? 1 : -1;\n", "\treturn 0;\n\t}\n\t/**\n\t * Typeguard to check if a value is an array of unknowed sub type.\n\t *\n\t * @param value unknowed value.\n\t * @returns `true` if the element is defined as an array, `false` if not.\n\t */\n\texport function isDefinedAsArray(value: unknown): value is unknown[] {\n\t\treturn isDefined(value) && value instanceof Array;\n", "}\n\t/**\n\t * Typeguard to check if a value is an object of unknowed key values.\n\t *\n\t * @param value unknowed value.\n\t * @returns `true` if the element is defined as an object, `false` if not.\n\t */\n\texport function isDefinedAsObject(\n\t\tvalue: unknown\n\t): value is { [key: string]: unknown } {\n", "\treturn isDefined(value) && value instanceof Object;\n\t}\n\t/**\n\t * Shorthand to quickly get a well typed number date token configuration object.\n\t *\n\t * @param defaultValue - Override the values of the return object.\n\t * @returns DateTokenConfiguration<DateTokenType.number> - A well typed date token configuration object.\n\t */\n\texport function createNumberDateTokenConfiguration(\n\t\tdefaultValue: Partial<DateTokenConfiguration<DateTokenType.number>> = {}\n", "): DateTokenConfiguration<DateTokenType.number> {\n\t\treturn {\n\t\t\tminLeght: 2,\n\t\t\tname: \"\",\n\t\t\ttype: DateTokenType.number,\n\t\t\tdisplayWhenZero: true,\n\t\t\tformatting: [],\n\t\t\thideSign: false,\n\t\t\t...defaultValue,\n\t\t};\n", "}\n\t/**\n\t * Shorthand to quickly get a well typed string date token configuration object.\n\t *\n\t * @param defaultValue - Override the values of the return object.\n\t * @returns DateTokenConfiguration<DateTokenType.string> - A well typed date token configuration object.\n\t */\n\texport function createStringDateTokenConfiguration(\n\t\tdefaultValue: Partial<DateTokenConfiguration<DateTokenType.string>> = {}\n\t): DateTokenConfiguration<DateTokenType.string> {\n", "\treturn {\n\t\t\tname: \"\",\n\t\t\ttype: DateTokenType.string,\n\t\t\tdictionary: [\"\"],\n\t\t\tformatting: [],\n\t\t\t...defaultValue,\n\t\t};\n\t}\n\t/**\n\t * Narrow type down to specific subtype for DateTokenConfigurations.\n", " *\n\t * @param value - Date token configuration.\n\t * @returns typeguard.\n\t */\n\texport function dateTokenConfigurationIsTypeString(\n\t\tvalue: DateTokenConfiguration\n\t): value is DateTokenConfiguration<DateTokenType.string> {\n\t\treturn value.type === DateTokenType.string;\n\t}\n\t/**\n", " * Narrow type down to specific subtype for DateTokenConfigurations.\n\t *\n\t * @param value - Date token configuration.\n\t * @returns typeguard.\n\t */\n\texport function dateTokenConfigurationIsTypeNumber(\n\t\tvalue: DateTokenConfiguration\n\t): value is DateTokenConfiguration<DateTokenType.number> {\n\t\treturn value.type === DateTokenType.number;\n\t}\n", "/**\n\t * Parse a string based off user date extract settings.\n\t *\n\t * @param groupsToCheck - The token names to check.\n\t * @param metadataString - The actual extracted data from the frontmatter.\n\t * @param reg - The user defined regex to apply.\n\t * @returns The parsed abstract date or nothing.\n\t */\n\texport function parseAbstractDate(\n\t\tgroupsToCheck: string[],\n", "\tmetadataString: string,\n\t\treg: RegExp | string\n\t): AbstractDate | undefined {\n\t\tconst matches = metadataString.match(reg);\n\t\tif (!matches || !matches.groups) return undefined;\n\t\tconst { groups } = matches;\n\t\tconst output = groupsToCheck.reduce((accumulator, groupName) => {\n\t\t\tconst value = Number(groups[groupName]);\n\t\t\t// In the case of a faulty regex given by the user in the settings\n\t\t\tif (!isNaN(value)) accumulator.push(value);\n", "\t\treturn accumulator;\n\t\t}, [] as AbstractDate);\n\t\t// Malformed payload bail out\n\t\tif (output.length !== groupsToCheck.length) return undefined;\n\t\treturn output;\n\t}\n\t/**\n\t * Used to quickly assert any programatic conditions configured by the users.\n\t *\n\t * @param condition - A specific condition.\n", " * @param a - Left hand value.\n\t * @param b - Right hand value.\n\t * @returns the evaluated boolean.\n\t */\n\texport function evalNumericalCondition(\n\t\tcondition: Condition,\n\t\ta: number,\n\t\tb: number\n\t): boolean {\n\t\tswitch (condition) {\n", "\t\tcase Condition.Equal:\n\t\t\t\treturn a === b;\n\t\t\tcase Condition.NotEqual:\n\t\t\t\treturn a !== b;\n\t\t\tcase Condition.Greater:\n\t\t\t\treturn a > b;\n\t\t\tcase Condition.GreaterOrEqual:\n\t\t\t\treturn a >= b;\n\t\t\tcase Condition.Less:\n\t\t\t\treturn a < b;\n", "\t\tcase Condition.LessOrEqual:\n\t\t\t\treturn a <= b;\n\t\t}\n\t}\n"]}
{"filename": "src/cardData.ts", "chunked_list": ["import { getMetadataKey, isDefined, isDefinedAsObject } from \"~/utils\";\n\timport type {\n\t\tMarkdownCodeBlockTimelineProcessingContext,\n\t\tCompleteCardContext,\n\t} from \"~/types\";\n\timport { parse } from \"yaml\";\n\timport {\n\t\tgetAbstractDateFromMetadata,\n\t\tgetBodyFromContextOrDocument,\n\t\tgetImageUrlFromContextOrDocument,\n", "\tgetTagsFromMetadataOrTagObject,\n\t} from \"./cardDataExtraction\";\n\t/**\n\t * A un-changeable key used to check if a note is eligeable for render.\n\t */\n\tconst RENDER_GREENLIGHT_METADATA_KEY = [\"aat-render-enabled\"];\n\t/**\n\t * Provides additional context for the creation cards in the DOM.\n\t *\n\t * @param context - Timeline generic context.\n", " * @param tagsToFind - The tags to find in a note to match the current timeline.\n\t * @returns the context or underfined if it could not build it.\n\t */\n\texport async function getDataFromNoteMetadata(\n\t\tcontext: MarkdownCodeBlockTimelineProcessingContext,\n\t\ttagsToFind: string[]\n\t) {\n\t\tconst { cachedMetadata, settings } = context;\n\t\tconst { frontmatter: metaData, tags } = cachedMetadata;\n\t\tif (!metaData) return undefined;\n", "\tif (!RENDER_GREENLIGHT_METADATA_KEY.some((key) => metaData[key] === true))\n\t\t\treturn undefined;\n\t\tconst timelineTags = getTagsFromMetadataOrTagObject(\n\t\t\tsettings,\n\t\t\tmetaData,\n\t\t\ttags\n\t\t);\n\t\tif (!extractedTagsAreValid(timelineTags, tagsToFind)) return undefined;\n\t\treturn {\n\t\t\tcardData: await extractCardData(context),\n", "\t\tcontext,\n\t\t} as const;\n\t}\n\t/**\n\t * Provides additional context for the creation cards in the DOM but reads it from the body\n\t *\n\t * @param body - The extracted body for a single event card.\n\t * @param context - Timeline generic context.\n\t * @param tagsToFind - The tags to find in a note to match the current timeline.\n\t * @returns the context or underfined if it could not build it.\n", " */\n\texport async function getDataFromNoteBody(\n\t\tbody: string | undefined | null,\n\t\tcontext: MarkdownCodeBlockTimelineProcessingContext,\n\t\ttagsToFind: string[]\n\t): Promise<CompleteCardContext[]> {\n\t\tconst { settings } = context;\n\t\tif (!body) return [];\n\t\tconst inlineEventBlockRegExp = new RegExp(\n\t\t\t`%%${settings.noteInlineEventKey}\\n(((\\\\s|\\\\d|[a-z]|-)*):(.*)\\n)*%%`,\n", "\t\t\"gi\"\n\t\t);\n\t\tconst originalFrontmatter = context.cachedMetadata.frontmatter;\n\t\tconst matches = body.match(inlineEventBlockRegExp);\n\t\tif (!matches) return [];\n\t\tmatches.unshift();\n\t\tconst output: CompleteCardContext[] = [];\n\t\tfor (const block of matches) {\n\t\t\tconst sanitizedBlock = block.split(\"\\n\");\n\t\t\tsanitizedBlock.shift();\n", "\t\tsanitizedBlock.pop();\n\t\t\tconst fakeFrontmatter = parse(sanitizedBlock.join(\"\\n\")); // this actually works lmao\n\t\t\t// Replace frontmatter with newly built fake one. Just to re-use all the existing code.\n\t\t\tcontext.cachedMetadata.frontmatter = fakeFrontmatter;\n\t\t\tif (!isDefinedAsObject(fakeFrontmatter)) continue;\n\t\t\tconst timelineTags = getTagsFromMetadataOrTagObject(\n\t\t\t\tsettings,\n\t\t\t\tfakeFrontmatter,\n\t\t\t\tcontext.cachedMetadata.tags\n\t\t\t);\n", "\t\tif (!extractedTagsAreValid(timelineTags, tagsToFind)) continue;\n\t\t\tconst matchPositionInBody = body.indexOf(block);\n\t\t\toutput.push({\n\t\t\t\tcardData: await extractCardData(\n\t\t\t\t\tcontext,\n\t\t\t\t\tmatchPositionInBody !== -1\n\t\t\t\t\t\t? body.slice(matchPositionInBody + block.length)\n\t\t\t\t\t\t: undefined\n\t\t\t\t),\n\t\t\t\tcontext,\n", "\t\t});\n\t\t}\n\t\tcontext.cachedMetadata.frontmatter = originalFrontmatter;\n\t\treturn output;\n\t}\n\t/**\n\t * Checks if the extracted tags match at least one of the tags to find.\n\t *\n\t * @param timelineTags - The extracted tags from the note.\n\t * @param tagsToFind - The tags to find.\n", " * @returns `true` if valid.\n\t */\n\tfunction extractedTagsAreValid(\n\t\ttimelineTags: string[],\n\t\ttagsToFind: string[]\n\t): boolean {\n\t\treturn timelineTags.some((tag) => tagsToFind.includes(tag));\n\t}\n\t/**\n\t * Get the content of a card from a note. This function will parse the raw text content of a note and format it.\n", " *\n\t * @param context - Timeline generic context.\n\t * @param rawFileContent - If you already have it, will avoid reading the file again.\n\t * @returns The extracted data to create a card from a note.\n\t */\n\texport async function extractCardData(\n\t\tcontext: MarkdownCodeBlockTimelineProcessingContext,\n\t\trawFileContent?: string\n\t) {\n\t\tconst { file, cachedMetadata: c, settings } = context;\n", "\tconst fileTitle =\n\t\t\tc.frontmatter?.[settings.metadataKeyEventTitleOverride] ||\n\t\t\tfile.basename;\n\t\trawFileContent = rawFileContent || (await file.vault.cachedRead(file));\n\t\treturn {\n\t\t\ttitle: fileTitle as string,\n\t\t\tbody: getBodyFromContextOrDocument(rawFileContent, context),\n\t\t\timageURL: getImageUrlFromContextOrDocument(rawFileContent, context),\n\t\t\tstartDate: getAbstractDateFromMetadata(\n\t\t\t\tcontext,\n", "\t\t\tsettings.metadataKeyEventStartDate\n\t\t\t),\n\t\t\tendDate:\n\t\t\t\tgetAbstractDateFromMetadata(\n\t\t\t\t\tcontext,\n\t\t\t\t\tsettings.metadataKeyEventEndDate\n\t\t\t\t) ??\n\t\t\t\t(isDefined(\n\t\t\t\t\tgetMetadataKey(c, settings.metadataKeyEventEndDate, \"boolean\")\n\t\t\t\t)\n", "\t\t\t\t? true\n\t\t\t\t\t: undefined),\n\t\t} as const;\n\t}\n\texport type FnExtractCardData = typeof extractCardData;\n"]}
{"filename": "src/cardDataExtraction.ts", "chunked_list": ["import {\n\t\tisDefinedAsString,\n\t\tisDefined,\n\t\tisDefinedAsArray,\n\t\tgetMetadataKey,\n\t\tparseAbstractDate,\n\t} from \"~/utils\";\n\timport { FrontMatterCache, TagCache, TFile } from \"obsidian\";\n\timport type {\n\t\tAutoTimelineSettings,\n", "\tAbstractDate,\n\t\tMarkdownCodeBlockTimelineProcessingContext,\n\t} from \"~/types\";\n\t/**\n\t * Returns a list of tags based off plugin settings, note frontmatter and note tags.\n\t *\n\t * @param settings - The plugins settings.\n\t * @param metaData - The frontematter cache.\n\t * @param tags - Potencial tags.\n\t * @returns A list of tags to look for in a note.\n", " */\n\texport function getTagsFromMetadataOrTagObject(\n\t\tsettings: AutoTimelineSettings,\n\t\tmetaData: Omit<FrontMatterCache, \"position\">,\n\t\ttags?: TagCache[]\n\t): string[] {\n\t\tlet output = [] as string[];\n\t\tconst timelineArray = metaData[settings.metadataKeyEventTimelineTag];\n\t\tif (isDefinedAsArray(timelineArray))\n\t\t\toutput = timelineArray.filter(isDefinedAsString);\n", "\t// Breakout earlier if we don't check the tags\n\t\tif (!settings.lookForTagsForTimeline) return output;\n\t\tif (isDefinedAsArray(tags))\n\t\t\toutput = output.concat(tags.map(({ tag }) => tag.substring(1)));\n\t\t// Tags in the frontmatter\n\t\tconst metadataInlineTags = metaData.tags;\n\t\tif (!isDefined(metadataInlineTags)) return output;\n\t\tif (isDefinedAsString(metadataInlineTags))\n\t\t\toutput = output.concat(\n\t\t\t\tmetadataInlineTags.split(\",\").map((e) => e.trim())\n", "\t\t);\n\t\tif (isDefinedAsArray(metadataInlineTags))\n\t\t\toutput = output.concat(metadataInlineTags.filter(isDefinedAsString));\n\t\t// .substring called to remove the initial `#` in the notes tags\n\t\treturn output;\n\t}\n\t/**\n\t * Extract the body from the raw text of a note.\n\t * After extraction most markdown tokens will be removed and links will be sanitized aswell and wrapped into bold tags for clearner display.\n\t *\n", " * @param rawFileText - The text content of a obsidian note.\n\t * @param context - Timeline generic context.\n\t * @returns the body of a given card or null if none was found.\n\t */\n\texport function getBodyFromContextOrDocument(\n\t\trawFileText: string,\n\t\tcontext: MarkdownCodeBlockTimelineProcessingContext\n\t): string | null {\n\t\tconst {\n\t\t\tcachedMetadata: { frontmatter: metadata },\n", "\t\tsettings: { metadataKeyEventBodyOverride },\n\t\t} = context;\n\t\tconst overrideBody = metadata?.[metadataKeyEventBodyOverride] ?? null;\n\t\tif (!rawFileText.length || overrideBody) return overrideBody;\n\t\tconst rawTextArray = rawFileText.split(\"\\n\");\n\t\trawTextArray.shift();\n\t\tconst processedArray = rawTextArray.slice(rawTextArray.indexOf(\"---\") + 1);\n\t\tconst finalString = processedArray.join(\"\\n\").trim();\n\t\treturn finalString;\n\t}\n", "/**\n\t * Extract the first image from the raw markdown in a note.\n\t *\n\t * @param rawFileText - The text content of a obsidian note.\n\t * @param context - Timeline generic context.\n\t * @returns the URL of the image to be displayed in a card or null if none where found.\n\t */\n\texport function getImageUrlFromContextOrDocument(\n\t\trawFileText: string,\n\t\tcontext: MarkdownCodeBlockTimelineProcessingContext\n", "): string | null {\n\t\tconst {\n\t\t\tcachedMetadata: { frontmatter: metadata },\n\t\t\tfile: currentFile,\n\t\t\tapp,\n\t\t\tsettings: { metadataKeyEventPictureOverride },\n\t\t} = context;\n\t\tconst {\n\t\t\tvault,\n\t\t\tmetadataCache: { getFirstLinkpathDest },\n", "\t} = app;\n\t\tconst override = metadata?.[metadataKeyEventPictureOverride];\n\t\tif (override) return override;\n\t\tconst internalLinkMatch = rawFileText.match(/!\\[\\[(?<src>.*)\\]\\]/);\n\t\tconst matchs =\n\t\t\tinternalLinkMatch || rawFileText.match(/!\\[.*\\]\\((?<src>.*)\\)/);\n\t\tif (!matchs || !matchs.groups || !matchs.groups.src) return null;\n\t\tif (internalLinkMatch) {\n\t\t\t// https://github.com/obsidianmd/obsidian-releases/pull/1882#issuecomment-1512952295\n\t\t\tconst file = getFirstLinkpathDest.bind(app.metadataCache)(\n", "\t\t\tmatchs.groups.src,\n\t\t\t\tcurrentFile.path\n\t\t\t) satisfies TFile | null;\n\t\t\tif (file instanceof TFile) return vault.getResourcePath(file);\n\t\t\t// Thanks https://github.com/joethei\n\t\t\treturn null;\n\t\t} else return encodeURI(matchs.groups.src);\n\t}\n\t/**\n\t * Given a metadata key it'll try to parse the associated data as an `AbstractDate` and return it\n", " *\n\t * @param param0 - Timeline generic context.\n\t * @param param0.cachedMetadata - The cached metadata from a note.\n\t * @param param0.settings - the plugin's settings.\n\t * @param key - The target lookup key in the notes metadata object.\n\t * @returns the abstract date representation or undefined.\n\t */\n\texport function getAbstractDateFromMetadata(\n\t\t{ cachedMetadata, settings }: MarkdownCodeBlockTimelineProcessingContext,\n\t\tkey: string\n", "): AbstractDate | undefined {\n\t\tconst groupsToCheck = settings.dateParserGroupPriority.split(\",\");\n\t\tconst numberValue = getMetadataKey(cachedMetadata, key, \"number\");\n\t\tif (isDefined(numberValue)) {\n\t\t\tconst additionalContentForNumberOnlydate = [\n\t\t\t\t...Array(Math.max(0, groupsToCheck.length - 1)),\n\t\t\t].map(() => 0);\n\t\t\treturn [numberValue, ...additionalContentForNumberOnlydate];\n\t\t}\n\t\tconst stringValue = getMetadataKey(cachedMetadata, key, \"string\");\n", "\tif (!stringValue) return undefined;\n\t\treturn parseAbstractDate(\n\t\t\tgroupsToCheck,\n\t\t\tstringValue,\n\t\t\tsettings.dateParserRegex\n\t\t);\n\t}\n"]}
{"filename": "src/abstractDateFormatting.ts", "chunked_list": ["import {\n\t\tdateTokenConfigurationIsTypeNumber,\n\t\tdateTokenConfigurationIsTypeString,\n\t\tevalNumericalCondition,\n\t} from \"~/utils\";\n\timport type {\n\t\tAutoTimelineSettings,\n\t\tAbstractDate,\n\t\tDateTokenConfiguration,\n\t\tDateTokenType,\n", "\tAdditionalDateFormatting,\n\t} from \"~/types\";\n\t/**\n\t * Handy function to format an abstract date based on the current settings.\n\t *\n\t * @param date - Target date to format.\n\t * @param param1 - The settings of the plugin.\n\t * @param param1.dateDisplayFormat - The target format to displat the date in.\n\t * @param param1.dateParserGroupPriority - The token priority list for the date format.\n\t * @param param1.dateTokenConfiguration - The configuration for the given date format.\n", " * @param param1.applyAdditonalConditionFormatting - The boolean toggle to check or not for additional condition based formattings.\n\t * @returns the formated representation of a given date based off the plugins settings.\n\t */\n\texport function formatAbstractDate(\n\t\tdate: AbstractDate | boolean,\n\t\t{\n\t\t\tdateDisplayFormat,\n\t\t\tdateParserGroupPriority,\n\t\t\tdateTokenConfiguration,\n\t\t\tapplyAdditonalConditionFormatting,\n", "\t}: Pick<\n\t\t\tAutoTimelineSettings,\n\t\t\t| \"dateDisplayFormat\"\n\t\t\t| \"dateParserGroupPriority\"\n\t\t\t| \"dateTokenConfiguration\"\n\t\t\t| \"applyAdditonalConditionFormatting\"\n\t\t>\n\t): string {\n\t\tif (typeof date === \"boolean\") return \"now\";\n\t\tconst prioArray = dateParserGroupPriority.split(\",\");\n", "\tlet output = dateDisplayFormat.toString();\n\t\tprioArray.forEach((token, index) => {\n\t\t\tconst configuration = dateTokenConfiguration.find(\n\t\t\t\t({ name }) => name === token\n\t\t\t);\n\t\t\tif (!configuration)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`[April's not so automatic timelines] - No date token configuration found for ${token}, please setup your date tokens correctly`\n\t\t\t\t);\n\t\t\toutput = output.replace(\n", "\t\t\t`{${token}}`,\n\t\t\t\tapplyConditionBasedFormatting(\n\t\t\t\t\tformatDateToken(date[index], configuration),\n\t\t\t\t\tdate[index],\n\t\t\t\t\tconfiguration,\n\t\t\t\t\tapplyAdditonalConditionFormatting\n\t\t\t\t)\n\t\t\t);\n\t\t});\n\t\treturn output;\n", "}\n\t/**\n\t * Shorthand to format a part of an abstract date.\n\t *\n\t * @param datePart - fragment of an abstract date.\n\t * @param configuration - the configuration bound to that date token.\n\t * @returns the formated token.\n\t */\n\texport function formatDateToken(\n\t\tdatePart: number,\n", "\tconfiguration: DateTokenConfiguration\n\t): string {\n\t\tif (dateTokenConfigurationIsTypeNumber(configuration))\n\t\t\treturn formatNumberDateToken(datePart, configuration);\n\t\tif (dateTokenConfigurationIsTypeString(configuration))\n\t\t\treturn formatStringDateToken(datePart, configuration);\n\t\tthrow new Error(\n\t\t\t`[April's not so automatic timelines] - Corrupted date token configuration, please reset settings`\n\t\t);\n\t}\n", "/**\n\t * This functions processes each tokens additional conditional formatting.\n\t *\n\t * @param formatedDate - The previously processed date token.\n\t * @param date - The numerical value of the token.\n\t * @param configuration - The configuration of the token.\n\t * @param configuration.formatting - The formatting array bound to a token configuration.\n\t * @param applyAdditonalConditionFormatting - The boolean toggle to check or not for additional condition based formattings.\n\t * @returns the fully formated token ready to be inserted in the output string.\n\t */\n", "export function applyConditionBasedFormatting(\n\t\tformatedDate: string,\n\t\tdate: number,\n\t\t{ formatting }: DateTokenConfiguration,\n\t\tapplyAdditonalConditionFormatting: AutoTimelineSettings[\"applyAdditonalConditionFormatting\"]\n\t): string {\n\t\tif (!applyAdditonalConditionFormatting) return formatedDate;\n\t\treturn formatting.reduce(\n\t\t\t(output, { format, conditionsAreExclusive, evaluations }) => {\n\t\t\t\tconst evaluationRestult = (\n", "\t\t\t\tconditionsAreExclusive ? evaluations.some : evaluations.every\n\t\t\t\t).bind(evaluations)(\n\t\t\t\t\t({\n\t\t\t\t\t\tcondition,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t}: AdditionalDateFormatting[\"evaluations\"][number]) =>\n\t\t\t\t\t\tevalNumericalCondition(condition, date, value)\n\t\t\t\t);\n\t\t\t\tif (evaluationRestult) return format.replace(\"{value}\", output);\n\t\t\t\treturn output;\n", "\t\t},\n\t\t\tformatedDate\n\t\t);\n\t}\n\t/**\n\t * Used to quickly format a fragment of an abstract date based off a number typed date token configuration.\n\t *\n\t * @param datePart - fragment of an abstract date.\n\t * @param param1 - A numerical date token configuration to apply.\n\t * @param param1.minLeght - the minimal length of a numerical date input.\n", " * @param param1.hideSign - if `true` the date part will be passed to `Math.abs` before anu further formatting.\n\t * @returns the formated token.\n\t */\n\tfunction formatNumberDateToken(\n\t\tdatePart: number,\n\t\t{ minLeght, hideSign }: DateTokenConfiguration<DateTokenType.number>\n\t): string {\n\t\tlet stringifiedToken = Math.abs(datePart).toString();\n\t\tif (minLeght < 0) return stringifiedToken;\n\t\twhile (stringifiedToken.length < minLeght)\n", "\t\tstringifiedToken = \"0\" + stringifiedToken;\n\t\tif (!hideSign && datePart < 0) stringifiedToken = `-${stringifiedToken}`;\n\t\treturn stringifiedToken;\n\t}\n\t/**\n\t * Used to quickly format a fragment of an abstract date based off a string typed date token configuration.\n\t *\n\t * @param datePart - fragment of an abstract date.\n\t * @param param1 - A string typed date token configuration to apply.\n\t * @param param1.dictionary - the relation dictionary for a date string typed token.\n", " * @returns the formated token.\n\t */\n\tfunction formatStringDateToken(\n\t\tdatePart: number,\n\t\t{ dictionary }: DateTokenConfiguration<DateTokenType.string>\n\t): string {\n\t\treturn dictionary[datePart];\n\t}\n"]}
{"filename": "src/settings.ts", "chunked_list": ["import { PluginSettingTab } from \"obsidian\";\n\timport { createApp, ref } from \"vue\";\n\timport createVueI18nConfig from \"~/i18n.config\";\n\timport VApp from \"~/views/App.vue\";\n\timport type { App as ObsidianApp } from \"obsidian\";\n\timport type AprilsAutomaticTimelinesPlugin from \"~/main\";\n\timport type { AutoTimelineSettings, DateTokenConfiguration } from \"./types\";\n\timport type { App as VueApp } from \"vue\";\n\timport { createNumberDateTokenConfiguration } from \"./utils\";\n\t/**\n", " * Default key value relation for obsidian settings object\n\t */\n\texport const SETTINGS_DEFAULT = {\n\t\tmetadataKeyEventStartDate: \"aat-event-start-date\",\n\t\tmetadataKeyEventEndDate: \"aat-event-end-date\",\n\t\tmetadataKeyEventTitleOverride: \"aat-event-title\",\n\t\tmetadataKeyEventBodyOverride: \"aat-event-body\",\n\t\tmetadataKeyEventPictureOverride: \"aat-event-picture\",\n\t\tmetadataKeyEventTimelineTag: \"timelines\",\n\t\tnoteInlineEventKey: \"aat-inline-event\",\n", "\tmarkdownBlockTagsToFindSeparator: \",\",\n\t\tdateParserRegex: \"(?<year>-?[0-9]*)-(?<month>-?[0-9]*)-(?<day>-?[0-9]*)\",\n\t\tdateParserGroupPriority: \"year,month,day\",\n\t\tdateDisplayFormat: \"{day}/{month}/{year}\",\n\t\tlookForTagsForTimeline: false,\n\t\tlookForInlineEventsInNotes: true,\n\t\tapplyAdditonalConditionFormatting: true,\n\t\tdateTokenConfiguration: [\n\t\t\tcreateNumberDateTokenConfiguration({ name: \"year\", minLeght: 4 }),\n\t\t\tcreateNumberDateTokenConfiguration({ name: \"month\" }),\n", "\t\tcreateNumberDateTokenConfiguration({ name: \"day\" }),\n\t\t] as DateTokenConfiguration[],\n\t};\n\texport const __VUE_PROD_DEVTOOLS__ = true;\n\t/**\n\t * Class designed to display the inputs that allow the end user to change the default keys that are looked for when processing metadata in a single note.\n\t */\n\texport class TimelineSettingTab extends PluginSettingTab {\n\t\tplugin: AprilsAutomaticTimelinesPlugin;\n\t\tvueApp: VueApp<Element> | null;\n", "\tconstructor(app: ObsidianApp, plugin: AprilsAutomaticTimelinesPlugin) {\n\t\t\tsuper(app, plugin);\n\t\t\tthis.plugin = plugin;\n\t\t\tthis.vueApp = null;\n\t\t}\n\t\tdisplay(): void {\n\t\t\tthis.containerEl.empty();\n\t\t\t// TODO Read locale off obsidian.\n\t\t\tconst i18n = createVueI18nConfig();\n\t\t\tthis.vueApp = createApp({\n", "\t\t\tcomponents: { VApp },\n\t\t\t\ttemplate: \"<VApp :value='value' @update:value='save' />\",\n\t\t\t\tsetup: () => {\n\t\t\t\t\tconst value = ref(this.plugin.settings);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tsave: async (payload: Partial<AutoTimelineSettings>) => {\n\t\t\t\t\t\t\tthis.plugin.settings = {\n\t\t\t\t\t\t\t\t...this.plugin.settings,\n\t\t\t\t\t\t\t\t...payload,\n", "\t\t\t\t\t\t};\n\t\t\t\t\t\t\tvalue.value = this.plugin.settings;\n\t\t\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tmethods: {},\n\t\t\t});\n\t\t\tthis.vueApp.use(i18n).mount(this.containerEl);\n\t\t}\n", "\thide() {\n\t\t\tif (!this.vueApp) return;\n\t\t\tthis.vueApp.unmount();\n\t\t\tthis.vueApp = null;\n\t\t}\n\t}\n"]}
{"filename": "src/composable/hasSlot.ts", "chunked_list": ["import { Comment, Text, type Slot, type VNode } from \"vue\";\n\t/**\n\t * Quick composable to check for a slot when using `defineSlots()`\n\t *\n\t * @param slot - A potential Vue slot.\n\t * @param slotProps - The potencial props associated to that slot.\n\t * @returns typeguard boolean, `true` if the slot exists.\n\t */\n\texport function hasSlot(slot: Slot | undefined, slotProps = {}): slot is Slot {\n\t\tif (!slot) return false;\n", "\treturn slot(slotProps).some((vnode: VNode) => {\n\t\t\tif (vnode.type === Comment) return false;\n\t\t\tif (Array.isArray(vnode.children) && !vnode.children.length)\n\t\t\t\treturn false;\n\t\t\treturn (\n\t\t\t\tvnode.type !== Text ||\n\t\t\t\t(typeof vnode.children === \"string\" && vnode.children.trim() !== \"\")\n\t\t\t);\n\t\t});\n\t}\n"]}
