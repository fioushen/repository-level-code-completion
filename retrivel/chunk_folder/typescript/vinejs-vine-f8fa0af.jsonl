{"filename": "index.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { Vine } from './src/vine/main.js'\n\texport { Vine }\n", "export * as symbols from './src/symbols.js'\n\texport * as errors from './src/errors/main.js'\n\texport { VineAny } from './src/schema/any/main.js'\n\texport { VineEnum } from './src/schema/enum/main.js'\n\texport { VineTuple } from './src/schema/tuple/main.js'\n\texport { VineUnion } from './src/schema/union/main.js'\n\texport { VineArray } from './src/schema/array/main.js'\n\texport { VineValidator } from './src/vine/validator.js'\n\texport { VineString } from './src/schema/string/main.js'\n\texport { VineNumber } from './src/schema/number/main.js'\n", "export { VineRecord } from './src/schema/record/main.js'\n\texport { VineObject } from './src/schema/object/main.js'\n\texport { VineLiteral } from './src/schema/literal/main.js'\n\texport { VineBoolean } from './src/schema/boolean/main.js'\n\texport { VineAccepted } from './src/schema/accepted/main.js'\n\texport { BaseLiteralType } from './src/schema/base/literal.js'\n\texport { BaseType, BaseModifiersType } from './src/schema/base/main.js'\n\texport { SimpleErrorReporter } from './src/reporters/simple_error_reporter.js'\n\texport { SimpleMessagesProvider } from './src/messages_provider/simple_messages_provider.js'\n\tconst vine = new Vine()\n", "export default vine\n"]}
{"filename": "bin/test.ts", "chunked_list": ["import { Assert, assert } from '@japa/assert'\n\timport { expectTypeOf } from '@japa/expect-type'\n\timport { processCLIArgs, configure, run } from '@japa/runner'\n\timport { ValidationError } from '../src/errors/validation_error.js'\n\tAssert.macro('validationErrors', async function (this: Assert, promiseLike, messages) {\n\t  let hasFailed = false\n\t  try {\n\t    await promiseLike\n\t  } catch (error) {\n\t    hasFailed = true\n", "    this.instanceOf(error, ValidationError)\n\t    this.deepEqual(error.messages, messages)\n\t  }\n\t  if (!hasFailed) {\n\t    throw new Error('Expected validation to fail, but passed')\n\t  }\n\t})\n\tAssert.macro('validationOutput', async function (this: Assert, promiseLike, messages) {\n\t  this.deepEqual(await promiseLike, messages)\n\t})\n", "/*\n\t|--------------------------------------------------------------------------\n\t| Configure tests\n\t|--------------------------------------------------------------------------\n\t|\n\t| The configure method accepts the configuration to configure the Japa\n\t| tests runner.\n\t|\n\t| The first method call \"processCliArgs\" process the command line arguments\n\t| and turns them into a config object. Using this method is not mandatory.\n", "|\n\t| Please consult japa.dev/runner-config for the config docs.\n\t*/\n\tprocessCLIArgs(process.argv.slice(2))\n\tconfigure({\n\t  suites: [\n\t    {\n\t      name: 'unit',\n\t      files: ['tests/unit/**/*.spec(.js|.ts)'],\n\t    },\n", "    {\n\t      name: 'integration',\n\t      files: ['tests/integration/**/*.spec(.js|.ts)'],\n\t    },\n\t  ],\n\t  plugins: [assert(), expectTypeOf()],\n\t})\n\t/*\n\t|--------------------------------------------------------------------------\n\t| Run tests\n", "|--------------------------------------------------------------------------\n\t|\n\t| The following \"run\" method is required to execute all the tests.\n\t|\n\t*/\n\t// eslint-disable-next-line @typescript-eslint/no-floating-promises\n\trun()\n"]}
{"filename": "bin/japa_types.ts", "chunked_list": ["import '@japa/assert'\n\tdeclare module '@japa/assert' {\n\t  interface Assert {\n\t    validationErrors(promiseLike: Promise<any>, messages: any): Promise<void>\n\t    validationOutput(promiseLike: Promise<any>, output: any): Promise<void>\n\t  }\n\t}\n"]}
{"filename": "tests/integration/validator.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine, {\n", "  Vine,\n\t  VineEnum,\n\t  VineTuple,\n\t  VineArray,\n\t  VineNumber,\n\t  VineObject,\n\t  VineRecord,\n\t  VineString,\n\t  VineLiteral,\n\t  VineBoolean,\n", "} from '../../index.js'\n\ttest.group('Validator | metadata', () => {\n\t  test('pass metadata to the validation pipeline', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const author = vine.object({\n\t      name: vine.string(),\n\t      email: vine.string().email(),\n\t      role: vine.string().in((field) => {\n\t        assert.deepEqual(field.meta, { choices: ['admin', 'guest'] })\n\t        return field.meta.choices\n", "      }),\n\t    })\n\t    const validator = vine.compile(author)\n\t    await assert.validationOutput(\n\t      validator.validate(\n\t        { name: 'virk', email: 'foo@bar.com', role: 'guest' },\n\t        { meta: { choices: ['admin', 'guest'] } }\n\t      ),\n\t      { name: 'virk', email: 'foo@bar.com', role: 'guest' }\n\t    )\n", "  })\n\t  test('define metadata types', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const author = vine.object({\n\t      name: vine.string(),\n\t      email: vine.string().email(),\n\t      role: vine.string().in((field) => {\n\t        assert.deepEqual(field.meta, { choices: ['admin', 'guest'] })\n\t        return field.meta.choices\n\t      }),\n", "    })\n\t    const validator = vine.withMetaData<{ choices: string[] }>().compile(author)\n\t    await assert.validationOutput(\n\t      validator.validate(\n\t        { name: 'virk', email: 'foo@bar.com', role: 'guest' },\n\t        { meta: { choices: ['admin', 'guest'] } }\n\t      ),\n\t      { name: 'virk', email: 'foo@bar.com', role: 'guest' }\n\t    )\n\t  })\n", "  test('validate metadata', async ({ assert }) => {\n\t    assert.plan(3)\n\t    const author = vine.object({\n\t      name: vine.string(),\n\t      email: vine.string().email(),\n\t      role: vine.string().in((field) => {\n\t        assert.deepEqual(field.meta, { choices: ['admin', 'guest'] })\n\t        return field.meta.choices\n\t      }),\n\t    })\n", "    const validator = vine\n\t      .withMetaData<{ choices: string[] }>((meta) => {\n\t        assert.deepEqual(meta, { choices: ['admin', 'guest'] })\n\t      })\n\t      .compile(author)\n\t    await assert.validationOutput(\n\t      validator.validate(\n\t        { name: 'virk', email: 'foo@bar.com', role: 'guest' },\n\t        { meta: { choices: ['admin', 'guest'] } }\n\t      ),\n", "      { name: 'virk', email: 'foo@bar.com', role: 'guest' }\n\t    )\n\t  })\n\t  test('fail when metadata validation fails', async ({ assert }) => {\n\t    const author = vine.object({\n\t      name: vine.string(),\n\t      email: vine.string().email(),\n\t      role: vine.string().in((field) => {\n\t        assert.deepEqual(field.meta, { choices: ['admin', 'guest'] })\n\t        return field.meta.choices\n", "      }),\n\t    })\n\t    const validator = vine\n\t      .withMetaData<{ choices: string[] }>(() => {\n\t        throw new Error('Invalid metadata')\n\t      })\n\t      .compile(author)\n\t    validator.validate(\n\t      { name: 'virk', email: 'foo@bar.com', role: 'guest' },\n\t      { meta: { choices: ['admin', 'guest'] } }\n", "    )\n\t  }).throws('Invalid metadata')\n\t})\n\ttest.group('Validator | extend schema classes', () => {\n\t  test('extend VineString class', ({ assert }) => {\n\t    VineString.macro('notPawned' as any, function (value: string) {\n\t      return value\n\t    })\n\t    assert.equal((vine.string() as any).notPawned('foo@bar.com'), 'foo@bar.com')\n\t  })\n", "  test('extend VineBoolean class', ({ assert }) => {\n\t    VineBoolean.macro('isTrue' as any, function () {\n\t      return true\n\t    })\n\t    assert.isTrue((vine.boolean() as any).isTrue())\n\t  })\n\t  test('extend VineNumber class', ({ assert }) => {\n\t    VineNumber.macro('isPrime' as any, function () {\n\t      return true\n\t    })\n", "    assert.isTrue((vine.number() as any).isPrime())\n\t  })\n\t  test('extend VineObject class', ({ assert }) => {\n\t    VineObject.macro('validatesEmail' as any, function (this: VineObject<any, any, any>) {\n\t      return 'email' in this.getProperties()\n\t    })\n\t    assert.isTrue((vine.object({ email: vine.string() }) as any).validatesEmail())\n\t  })\n\t  test('extend VineArray class', ({ assert }) => {\n\t    VineArray.macro('atLeastOne' as any, function (this: VineArray<any>) {\n", "      return true\n\t    })\n\t    assert.isTrue((vine.array(vine.string()) as any).atLeastOne())\n\t  })\n\t  test('extend VineRecord class', ({ assert }) => {\n\t    VineRecord.macro('atLeastOne' as any, function (this: VineRecord<any>) {\n\t      return true\n\t    })\n\t    assert.isTrue((vine.record(vine.string()) as any).atLeastOne())\n\t  })\n", "  test('extend VineTuple class', ({ assert }) => {\n\t    VineTuple.macro('atLeastOne' as any, function (this: VineTuple<any, any, any>) {\n\t      return true\n\t    })\n\t    assert.isTrue((vine.tuple([vine.string()]) as any).atLeastOne())\n\t  })\n\t  test('extend VineLiteral class', ({ assert }) => {\n\t    VineLiteral.macro('isTruthy' as any, function (this: VineLiteral<any>) {\n\t      return true\n\t    })\n", "    assert.isTrue((vine.literal(true) as any).isTruthy())\n\t  })\n\t  test('extend VineEnum class', ({ assert }) => {\n\t    VineEnum.macro('hasMultipleOptions' as any, function (this: VineEnum<any>) {\n\t      return this.getChoices().length > 0\n\t    })\n\t    assert.isTrue((vine.enum(['guest', 'moderator', 'admin']) as any).hasMultipleOptions())\n\t  })\n\t  test('extend Vine class', ({ assert }) => {\n\t    Vine.macro('money' as any, function (this: Vine) {\n", "      return true\n\t    })\n\t    assert.isTrue((vine as any).money())\n\t  })\n\t})\n"]}
{"filename": "tests/integration/schema/number.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "test.group('VineNumber', () => {\n\t  test('fail when value is not a number', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      age: vine.number().withoutDecimals(),\n\t    })\n\t    const data = { age: 'foo' }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'age',\n\t        message: 'The age field must be a number',\n", "        rule: 'number',\n\t      },\n\t    ])\n\t  })\n\t  test('fail when value has decimal places', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      age: vine.number().withoutDecimals(),\n\t    })\n\t    const data = { age: '22.12' }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n", "      {\n\t        field: 'age',\n\t        message: 'The age field must be an integer',\n\t        rule: 'withoutDecimals',\n\t      },\n\t    ])\n\t  })\n\t  test('pass when value is a valid integer', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      age: vine.number().withoutDecimals(),\n", "    })\n\t    const data = { age: '22' }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      age: 22,\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/integration/schema/enum.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "import { SimpleMessagesProvider } from '../../../src/messages_provider/simple_messages_provider.js'\n\ttest.group('Enum', () => {\n\t  test('fail when value is not a subset of choices', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      role: vine.enum(['admin', 'moderator', 'owner', 'user']),\n\t    })\n\t    const data = {\n\t      role: 'foo',\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n", "      {\n\t        field: 'role',\n\t        message: 'The selected role is invalid',\n\t        rule: 'enum',\n\t        meta: {\n\t          choices: ['admin', 'moderator', 'owner', 'user'],\n\t        },\n\t      },\n\t    ])\n\t  })\n", "  test('pass when value is a subset of choices', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      role: vine.enum(['admin', 'moderator', 'owner', 'user']),\n\t    })\n\t    const data = {\n\t      role: 'admin',\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      role: 'admin',\n\t    })\n", "  })\n\t})\n\ttest.group('Enum | Native enum', () => {\n\t  test('fail when value is not a subset of choices', async ({ assert }) => {\n\t    enum Roles {\n\t      ADMIN = 'admin',\n\t      MOD = 'moderator',\n\t      OWNER = 'owner',\n\t      USER = 'user',\n\t    }\n", "    const schema = vine.object({\n\t      role: vine.enum(Roles),\n\t    })\n\t    const data = {\n\t      role: 'foo',\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'role',\n\t        message: 'The selected role is invalid',\n", "        rule: 'enum',\n\t        meta: {\n\t          choices: ['admin', 'moderator', 'owner', 'user'],\n\t        },\n\t      },\n\t    ])\n\t  })\n\t  test('pass when value is a subset of choices', async ({ assert }) => {\n\t    enum Roles {\n\t      ADMIN = 'admin',\n", "      MOD = 'moderator',\n\t      OWNER = 'owner',\n\t      USER = 'user',\n\t    }\n\t    const schema = vine.object({\n\t      role: vine.enum(Roles),\n\t    })\n\t    const data = {\n\t      role: 'admin',\n\t    }\n", "    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      role: 'admin',\n\t    })\n\t  })\n\t})\n\ttest.group('Enum | Lazily compute enum choices', () => {\n\t  test('fail when value is not a subset of choices', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      creative_device: vine.enum(['mobile', 'desktop']),\n\t      banner_width: vine.enum((field) => {\n", "        if (field.parent.creative_device === 'mobile') {\n\t          return ['320px', '640px'] as const\n\t        }\n\t        return ['1080px', '1280px'] as const\n\t      }),\n\t    })\n\t    const data = {\n\t      creative_device: 'desktop',\n\t      banner_width: '640px',\n\t    }\n", "    const messagesProvider = new SimpleMessagesProvider({}, { banner_width: 'banner width' })\n\t    await assert.validationErrors(vine.validate({ schema, data, messagesProvider }), [\n\t      {\n\t        field: 'banner_width',\n\t        message: 'The selected banner width is invalid',\n\t        rule: 'enum',\n\t        meta: {\n\t          choices: ['1080px', '1280px'],\n\t        },\n\t      },\n", "    ])\n\t  })\n\t  test('pass when value is a subset of choices', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      creative_device: vine.enum(['mobile', 'desktop']),\n\t      banner_width: vine.enum((field) => {\n\t        if (field.parent.creative_device === 'mobile') {\n\t          return ['320px', '640px'] as const\n\t        }\n\t        return ['1080px', '1280px'] as const\n", "      }),\n\t    })\n\t    const data = {\n\t      creative_device: 'mobile',\n\t      banner_width: '640px',\n\t    }\n\t    const messagesProvider = new SimpleMessagesProvider({}, { banner_width: 'banner width' })\n\t    await assert.validationOutput(vine.validate({ schema, data, messagesProvider }), data)\n\t  })\n\t})\n"]}
{"filename": "tests/integration/schema/any.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "import { SimpleMessagesProvider } from '../../../src/messages_provider/simple_messages_provider.js'\n\ttest.group('Accepted', () => {\n\t  test('fail when field is missing', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      secret_message: vine.any(),\n\t    })\n\t    const data = {}\n\t    const messagesProvider = new SimpleMessagesProvider(\n\t      {},\n\t      {\n", "        secret_message: 'message',\n\t      }\n\t    )\n\t    await assert.validationErrors(\n\t      vine.validate({\n\t        schema,\n\t        data,\n\t        messagesProvider,\n\t      }),\n\t      [\n", "        {\n\t          field: 'secret_message',\n\t          message: 'The message field must be defined',\n\t          rule: 'required',\n\t        },\n\t      ]\n\t    )\n\t  })\n\t  test('pass when field value exists', async ({ assert }) => {\n\t    const schema = vine.object({\n", "      secret_message: vine.any(),\n\t    })\n\t    const data = {\n\t      secret_message: false,\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      secret_message: false,\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/integration/schema/literal.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "test.group('Literal', () => {\n\t  test('fail when value is not same as the expected value', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      is_hiring_guide: vine.literal(true),\n\t    })\n\t    const data = {\n\t      is_hiring_guide: false,\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n", "        field: 'is_hiring_guide',\n\t        message: 'The is_hiring_guide field must be true',\n\t        rule: 'literal',\n\t        meta: {\n\t          expectedValue: true,\n\t        },\n\t      },\n\t    ])\n\t  })\n\t  test('pass when value is same as the expected value', async ({ assert }) => {\n", "    const schema = vine.object({\n\t      is_hiring_guide: vine.literal(true),\n\t    })\n\t    const data = {\n\t      is_hiring_guide: 'true',\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      is_hiring_guide: true,\n\t    })\n\t  })\n", "})\n"]}
{"filename": "tests/integration/schema/object.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "test.group('VineObject | flat object', () => {\n\t  test('fail when value is not an object', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      password: vine.string(),\n\t    })\n\t    const data = 'foo'\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: '',\n", "        message: 'The data field must be an object',\n\t        rule: 'object',\n\t      },\n\t    ])\n\t  })\n\t  test('fail when object has missing properties', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      password: vine.string(),\n\t    })\n", "    const data = {}\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'username',\n\t        message: 'The username field must be defined',\n\t        rule: 'required',\n\t      },\n\t      {\n\t        field: 'password',\n\t        message: 'The password field must be defined',\n", "        rule: 'required',\n\t      },\n\t    ])\n\t  })\n\t  test('pass when object has all the properties', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      password: vine.string(),\n\t    })\n\t    const data = {\n", "      username: 'virk',\n\t      password: 'secret',\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), data)\n\t  })\n\t  test('drop unknown properties', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      password: vine.string(),\n\t    })\n", "    const data = {\n\t      username: 'virk',\n\t      password: 'secret',\n\t      rememberMe: true,\n\t      trackLogin: true,\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      username: 'virk',\n\t      password: 'secret',\n\t    })\n", "  })\n\t  test('merge properties from an existing object', async ({ assert }) => {\n\t    const author = vine.object({\n\t      name: vine.string(),\n\t      email: vine.string().email(),\n\t    })\n\t    const schema = vine.object({\n\t      ...author.getProperties(),\n\t      body: vine.string(),\n\t    })\n", "    const data = {\n\t      name: 'virk',\n\t      email: 'foo@bar.com',\n\t      body: 'This is post 101',\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), data)\n\t  })\n\t})\n\ttest.group('VineObject | allow unknown properties', () => {\n\t  test('fail when value is not an object', async ({ assert }) => {\n", "    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t      .allowUnknownProperties()\n\t    const data = 'foo'\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: '',\n", "        message: 'The data field must be an object',\n\t        rule: 'object',\n\t      },\n\t    ])\n\t  })\n\t  test('fail when object has missing properties', async ({ assert }) => {\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n", "      })\n\t      .allowUnknownProperties()\n\t    const data = {}\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'username',\n\t        message: 'The username field must be defined',\n\t        rule: 'required',\n\t      },\n\t      {\n", "        field: 'password',\n\t        message: 'The password field must be defined',\n\t        rule: 'required',\n\t      },\n\t    ])\n\t  })\n\t  test('copy unknown properties to the output', async ({ assert }) => {\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n", "        password: vine.string(),\n\t      })\n\t      .allowUnknownProperties()\n\t    const data = {\n\t      username: 'virk',\n\t      password: 'secret',\n\t      rememberMe: true,\n\t      trackLogin: true,\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), data)\n", "  })\n\t})\n\ttest.group('VineObject | object group', () => {\n\t  test('fail when group schema reports error', async ({ assert }) => {\n\t    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.is_hiring_guide), {\n\t        is_hiring_guide: vine.literal(true),\n\t        guide_id: vine.string(),\n\t        amount: vine.number(),\n\t      }),\n", "      vine.group.else({\n\t        is_hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const schema = vine\n\t      .object({\n\t        name: vine.string(),\n\t        group_size: vine.number(),\n\t        phone_number: vine.string(),\n\t      })\n", "      .merge(guideSchema)\n\t    const data = {\n\t      name: 'virk',\n\t      group_size: 10,\n\t      phone_number: '0001010',\n\t      is_hiring_guide: true,\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'guide_id',\n", "        message: 'The guide_id field must be defined',\n\t        rule: 'required',\n\t      },\n\t      {\n\t        field: 'amount',\n\t        message: 'The amount field must be defined',\n\t        rule: 'required',\n\t      },\n\t    ])\n\t  })\n", "  test('pass when group schema is valid', async ({ assert }) => {\n\t    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.is_hiring_guide), {\n\t        is_hiring_guide: vine.literal(true),\n\t        guide_id: vine.string(),\n\t        amount: vine.number(),\n\t      }),\n\t      vine.group.else({\n\t        is_hiring_guide: vine.literal(false),\n\t      }),\n", "    ])\n\t    const schema = vine\n\t      .object({\n\t        name: vine.string(),\n\t        group_size: vine.number(),\n\t        phone_number: vine.string(),\n\t      })\n\t      .merge(guideSchema)\n\t    const data = {\n\t      name: 'virk',\n", "      group_size: 10,\n\t      phone_number: '0001010',\n\t      is_hiring_guide: false,\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      name: 'virk',\n\t      group_size: 10,\n\t      phone_number: '0001010',\n\t      is_hiring_guide: false,\n\t    })\n", "  })\n\t  test('fail when none of the group conditions match', async ({ assert }) => {\n\t    const fiscalHost = vine.group([\n\t      vine.group.if((data) => data.type === 'stripe', {\n\t        type: vine.literal('stripe'),\n\t        account_id: vine.string(),\n\t      }),\n\t      vine.group.if((data) => data.type === 'paypal', {\n\t        type: vine.literal('paypal'),\n\t        email: vine.string().email(),\n", "      }),\n\t      vine.group.if((data) => data.type === 'open_collective', {\n\t        type: vine.literal('open_collective'),\n\t        project_url: vine.string(),\n\t      }),\n\t    ])\n\t    const schema = vine.object({}).merge(fiscalHost)\n\t    const data = {}\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n", "        field: '',\n\t        message: 'Invalid value provided for data field',\n\t        rule: 'unionGroup',\n\t      },\n\t    ])\n\t  })\n\t  test('fail when group reports an error', async ({ assert }) => {\n\t    const fiscalHost = vine\n\t      .group([\n\t        vine.group.if((data) => data.type === 'stripe', {\n", "          type: vine.literal('stripe'),\n\t          account_id: vine.string(),\n\t        }),\n\t        vine.group.if((data) => data.type === 'paypal', {\n\t          type: vine.literal('paypal'),\n\t          email: vine.string().email(),\n\t        }),\n\t        vine.group.if((data) => data.type === 'open_collective', {\n\t          type: vine.literal('open_collective'),\n\t          project_url: vine.string(),\n", "        }),\n\t      ])\n\t      .otherwise((_, field) => {\n\t        field.report('Missing type property', 'type', field)\n\t      })\n\t    const schema = vine.object({}).merge(fiscalHost)\n\t    const data = {}\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: '',\n", "        message: 'Missing type property',\n\t        rule: 'type',\n\t      },\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/integration/schema/accepted.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "test.group('Accepted', () => {\n\t  test('fail when field is missing', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      terms: vine.accepted(),\n\t    })\n\t    const data = {}\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'terms',\n\t        message: 'The terms field must be defined',\n", "        rule: 'required',\n\t      },\n\t    ])\n\t  })\n\t  test('fail when field is defined but not accepted', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      terms: vine.accepted(),\n\t    })\n\t    const data = {\n\t      terms: 'no',\n", "    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'terms',\n\t        message: 'The terms field must be accepted',\n\t        rule: 'accepted',\n\t      },\n\t    ])\n\t  })\n\t  test('pass when field is accepted', async ({ assert }) => {\n", "    const schema = vine.object({\n\t      terms: vine.boolean(),\n\t    })\n\t    const data = {\n\t      terms: 'on',\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      terms: true,\n\t    })\n\t  })\n", "})\n"]}
{"filename": "tests/integration/schema/record.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "test.group('VineRecord', () => {\n\t  test('fail when value is not an object', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      colors: vine.record(vine.string().hexCode()),\n\t    })\n\t    const data = {\n\t      colors: 'foo',\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n", "        field: 'colors',\n\t        message: 'The colors field must be an object',\n\t        rule: 'object',\n\t      },\n\t    ])\n\t  })\n\t  test('pass when value is an object', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      colors: vine.record(vine.string().hexCode()),\n\t    })\n", "    const data = {\n\t      colors: {\n\t        white: '#ffffff',\n\t        black: '#000000',\n\t        lime: '#99d52a',\n\t      },\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), data)\n\t  })\n\t  test('validate union of types')\n", "})\n"]}
{"filename": "tests/integration/schema/tuple.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "test.group('VineTuple', () => {\n\t  test('fail when value is not an array', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      top_scores: vine.tuple([vine.number(), vine.number(), vine.number()]),\n\t    })\n\t    const data = {\n\t      top_scores: 'foo',\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n", "        field: 'top_scores',\n\t        message: 'The top_scores field must be an array',\n\t        rule: 'array',\n\t      },\n\t    ])\n\t  })\n\t  test('fail when tuple elements are missing', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      top_scores: vine.tuple([vine.number(), vine.number(), vine.number()]),\n\t    })\n", "    const data = {\n\t      top_scores: [1],\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'top_scores.1',\n\t        message: 'The 1 field must be defined',\n\t        rule: 'required',\n\t        index: 1,\n\t      },\n", "      {\n\t        field: 'top_scores.2',\n\t        message: 'The 2 field must be defined',\n\t        rule: 'required',\n\t        index: 2,\n\t      },\n\t    ])\n\t  })\n\t  test('pass when all elements are defined', async ({ assert }) => {\n\t    const schema = vine.object({\n", "      top_scores: vine.tuple([vine.number(), vine.number(), vine.number()]),\n\t    })\n\t    const data = {\n\t      top_scores: [1, 2, 3],\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), data)\n\t  })\n\t  test('drop unknown properties', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      top_scores: vine.tuple([vine.number(), vine.number(), vine.number()]),\n", "    })\n\t    const data = {\n\t      top_scores: [98, 96, 92, 88, 84],\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      top_scores: [98, 96, 92],\n\t    })\n\t  })\n\t})\n\ttest.group('VineTuple | allowUnknownProperties', () => {\n", "  test('fail when tuple elements are missing', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      top_scores: vine\n\t        .tuple([vine.number(), vine.number(), vine.number()])\n\t        .allowUnknownProperties(),\n\t    })\n\t    const data = {\n\t      top_scores: [1],\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n", "      {\n\t        field: 'top_scores.1',\n\t        message: 'The 1 field must be defined',\n\t        rule: 'required',\n\t        index: 1,\n\t      },\n\t      {\n\t        field: 'top_scores.2',\n\t        message: 'The 2 field must be defined',\n\t        rule: 'required',\n", "        index: 2,\n\t      },\n\t    ])\n\t  })\n\t  test('keep unknown elements', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      top_scores: vine\n\t        .tuple([vine.number(), vine.number(), vine.number()])\n\t        .allowUnknownProperties(),\n\t    })\n", "    const data = {\n\t      top_scores: [98, 96, 92, 'foo', 'bar'],\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      top_scores: [98, 96, 92, 'foo', 'bar'],\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/integration/schema/boolean.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "test.group('Boolean', () => {\n\t  test('fail when value is not a boolean', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      is_admin: vine.boolean(),\n\t    })\n\t    const data = {\n\t      is_admin: 'foo',\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n", "        field: 'is_admin',\n\t        message: 'The value must be a boolean',\n\t        rule: 'boolean',\n\t      },\n\t    ])\n\t  })\n\t  test('pass when value is a boolean', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      is_admin: vine.boolean(),\n\t    })\n", "    const data = {\n\t      is_admin: false,\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      is_admin: false,\n\t    })\n\t  })\n\t  test('pass when value is a string representation of boolean', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      is_admin: vine.boolean(),\n", "    })\n\t    const data = {\n\t      is_admin: 'true',\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      is_admin: true,\n\t    })\n\t  })\n\t})\n\ttest.group('Boolean | strict mode', () => {\n", "  test('fail when when is not a boolean', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      is_admin: vine.boolean({ strict: true }),\n\t    })\n\t    const data = {\n\t      is_admin: 'foo',\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'is_admin',\n", "        message: 'The value must be a boolean',\n\t        rule: 'boolean',\n\t      },\n\t    ])\n\t  })\n\t  test('pass when value is a boolean', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      is_admin: vine.boolean({ strict: true }),\n\t    })\n\t    const data = {\n", "      is_admin: false,\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      is_admin: false,\n\t    })\n\t  })\n\t  test('fail when value is a string representation of boolean', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      is_admin: vine.boolean({ strict: true }),\n\t    })\n", "    const data = {\n\t      is_admin: 'true',\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'is_admin',\n\t        message: 'The value must be a boolean',\n\t        rule: 'boolean',\n\t      },\n\t    ])\n", "  })\n\t})\n"]}
{"filename": "tests/integration/schema/array.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "test.group('Array | array of numbers', () => {\n\t  test('fail when array does not have numbers', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      categories: vine.array(vine.number()),\n\t    })\n\t    const data = {\n\t      categories: [1, 'foo', 'bar', 11],\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n", "        field: 'categories.*',\n\t        index: 1,\n\t        message: 'The 1 field must be a number',\n\t        rule: 'number',\n\t      },\n\t      {\n\t        field: 'categories.*',\n\t        index: 2,\n\t        message: 'The 2 field must be a number',\n\t        rule: 'number',\n", "      },\n\t    ])\n\t  })\n\t  test('pass when array has numbers and numerical strings', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      categories: vine.array(vine.number()),\n\t    })\n\t    const data = {\n\t      categories: [1, '2', '20', 11],\n\t    }\n", "    await assert.validationOutput(vine.validate({ schema, data }), {\n\t      categories: [1, 2, 20, 11],\n\t    })\n\t  })\n\t})\n\ttest.group('Array | array of objects', () => {\n\t  test('fail when array does not have an object', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      contacts: vine.array(\n\t        vine.object({\n", "          id: vine.number(),\n\t          is_primary: vine.boolean(),\n\t        })\n\t      ),\n\t    })\n\t    const data = {\n\t      contacts: ['foo'],\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n", "        field: 'contacts.*',\n\t        index: 0,\n\t        message: 'The 0 field must be an object',\n\t        rule: 'object',\n\t      },\n\t    ])\n\t  })\n\t  test('pass when array has objects matching the desired shape', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      contacts: vine.array(\n", "        vine.object({\n\t          id: vine.number(),\n\t          is_primary: vine.boolean(),\n\t        })\n\t      ),\n\t    })\n\t    const data = {\n\t      contacts: [\n\t        { id: 1, is_primary: false },\n\t        { id: 2, is_primary: true },\n", "      ],\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), data)\n\t  })\n\t})\n\ttest.group('Array | array of unions', () => {\n\t  test('fail when none of the conditions match', async ({ assert }) => {\n\t    /**\n\t     * Re-usable helper to check if the field value\n\t     * is an object and has a matching type\n", "     */\n\t    function hasType(value: unknown, type: string) {\n\t      return vine.helpers.isObject(value) && value.type === type\n\t    }\n\t    /**\n\t     * Schema type for email contact\n\t     */\n\t    const emailContact = vine.object({\n\t      type: vine.literal('email'),\n\t      email: vine.string().email(),\n", "    })\n\t    /**\n\t     * Schema type for phone contact\n\t     */\n\t    const phoneContact = vine.object({\n\t      type: vine.literal('phone'),\n\t      phone: vine.string().mobile(),\n\t    })\n\t    /**\n\t     * Define a contact union with conditionals and\n", "     * their associated schema\n\t     */\n\t    const contact = vine.union([\n\t      vine.union.if((value) => hasType(value, 'email'), emailContact),\n\t      vine.union.if((value) => hasType(value, 'phone'), phoneContact),\n\t    ])\n\t    const schema = vine.object({\n\t      contacts: vine.array(contact),\n\t    })\n\t    const data = {\n", "      contacts: ['foo'],\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'contacts.*',\n\t        index: 0,\n\t        message: 'Invalid value provided for 0 field',\n\t        rule: 'union',\n\t      },\n\t    ])\n", "  })\n\t  test('fail when union reports an error', async ({ assert }) => {\n\t    /**\n\t     * Re-usable helper to check if the field value\n\t     * is an object and has a matching type\n\t     */\n\t    function hasType(value: unknown, type: string) {\n\t      return vine.helpers.isObject(value) && value.type === type\n\t    }\n\t    /**\n", "     * Schema type for email contact\n\t     */\n\t    const emailContact = vine.object({\n\t      type: vine.literal('email'),\n\t      email: vine.string().email(),\n\t    })\n\t    /**\n\t     * Schema type for phone contact\n\t     */\n\t    const phoneContact = vine.object({\n", "      type: vine.literal('phone'),\n\t      phone: vine.string().mobile(),\n\t    })\n\t    /**\n\t     * Define a contact union with conditionals and\n\t     * their associated schema\n\t     */\n\t    const contact = vine\n\t      .union([\n\t        vine.union.if((value) => hasType(value, 'email'), emailContact),\n", "        vine.union.if((value) => hasType(value, 'phone'), phoneContact),\n\t      ])\n\t      .otherwise((_, field) => {\n\t        field.report(\n\t          'Invalid contact. Either provide an email or a phone number',\n\t          'unknown_contact_type',\n\t          field\n\t        )\n\t      })\n\t    const schema = vine.object({\n", "      contacts: vine.array(contact),\n\t    })\n\t    const data = {\n\t      contacts: ['foo'],\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'contacts.*',\n\t        index: 0,\n\t        message: 'Invalid contact. Either provide an email or a phone number',\n", "        rule: 'unknown_contact_type',\n\t      },\n\t    ])\n\t  })\n\t  test('fail when union schema reports error', async ({ assert }) => {\n\t    /**\n\t     * Re-usable helper to check if the field value\n\t     * is an object and has a matching type\n\t     */\n\t    function hasType(value: unknown, type: string) {\n", "      return vine.helpers.isObject(value) && value.type === type\n\t    }\n\t    /**\n\t     * Schema type for email contact\n\t     */\n\t    const emailContact = vine.object({\n\t      type: vine.literal('email'),\n\t      email: vine.string().email(),\n\t    })\n\t    /**\n", "     * Schema type for phone contact\n\t     */\n\t    const phoneContact = vine.object({\n\t      type: vine.literal('phone'),\n\t      phone: vine.string().mobile(),\n\t    })\n\t    /**\n\t     * Define a contact union with conditionals and\n\t     * their associated schema\n\t     */\n", "    const contact = vine\n\t      .union([\n\t        vine.union.if((value) => hasType(value, 'email'), emailContact),\n\t        vine.union.if((value) => hasType(value, 'phone'), phoneContact),\n\t      ])\n\t      .otherwise((_, field) => {\n\t        field.report(\n\t          'Invalid contact. Either provide an email or a phone number',\n\t          'unknown_contact_type',\n\t          field\n", "        )\n\t      })\n\t    const schema = vine.object({\n\t      contacts: vine.array(contact),\n\t    })\n\t    const data = {\n\t      contacts: [\n\t        {\n\t          type: 'email',\n\t          email: 'foo',\n", "        },\n\t      ],\n\t    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'contacts.*.email',\n\t        message: 'The email field must be a valid email address',\n\t        rule: 'email',\n\t      },\n\t    ])\n", "  })\n\t  test('pass when union schema is valid', async ({ assert }) => {\n\t    assert.plan(1)\n\t    /**\n\t     * Re-usable helper to check if the field value\n\t     * is an object and has a matching type\n\t     */\n\t    function hasType(value: unknown, type: string) {\n\t      return vine.helpers.isObject(value) && value.type === type\n\t    }\n", "    /**\n\t     * Schema type for email contact\n\t     */\n\t    const emailContact = vine.object({\n\t      type: vine.literal('email'),\n\t      email: vine.string().email(),\n\t    })\n\t    /**\n\t     * Schema type for phone contact\n\t     */\n", "    const phoneContact = vine.object({\n\t      type: vine.literal('phone'),\n\t      phone: vine.string().mobile(),\n\t    })\n\t    /**\n\t     * Define a contact union with conditionals and\n\t     * their associated schema\n\t     */\n\t    const contact = vine\n\t      .union([\n", "        vine.union.if((value) => hasType(value, 'email'), emailContact),\n\t        vine.union.if((value) => hasType(value, 'phone'), phoneContact),\n\t      ])\n\t      .otherwise((_, field) => {\n\t        field.report(\n\t          'Invalid contact. Either provide an email or a phone number',\n\t          'unknown_contact_type',\n\t          field\n\t        )\n\t      })\n", "    const schema = vine.object({\n\t      contacts: vine.array(contact),\n\t    })\n\t    const data = {\n\t      contacts: [\n\t        {\n\t          type: 'email' as const,\n\t          email: 'foo@bar.com',\n\t        },\n\t      ],\n", "    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), data)\n\t  })\n\t})\n"]}
{"filename": "tests/integration/schema/union_of_types.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport vine from '../../../index.js'\n", "test.group('UnionOfTypes', () => {\n\t  test('report error when none of the unions match', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      health_check: vine.unionOfTypes([vine.boolean(), vine.string().url()]),\n\t    })\n\t    const data = {}\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        rule: 'unionOfTypes',\n\t        field: 'health_check',\n", "        message: 'Invalid value provided for health_check field',\n\t      },\n\t    ])\n\t  })\n\t  test('report error when union schema reports error', async ({ assert }) => {\n\t    const schema = vine.object({\n\t      health_check: vine.unionOfTypes([vine.boolean(), vine.string().url()]),\n\t    })\n\t    const data = {\n\t      health_check: 'foo',\n", "    }\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        rule: 'url',\n\t        field: 'health_check',\n\t        message: 'The health_check field must be a valid URL',\n\t      },\n\t    ])\n\t  })\n\t  test('pass validation when data is valid as per union schema', async ({ assert }) => {\n", "    const schema = vine.object({\n\t      health_check: vine.unionOfTypes([vine.boolean(), vine.string().url()]),\n\t    })\n\t    const data = {\n\t      health_check: 'https://foo.com',\n\t    }\n\t    await assert.validationOutput(vine.validate({ schema, data }), data)\n\t  })\n\t  test('report error using otherwise callback', async ({ assert }) => {\n\t    const schema = vine.object({\n", "      health_check: vine\n\t        .unionOfTypes([vine.boolean(), vine.string().url()])\n\t        .otherwise((_, field) => {\n\t          field.report('The health_check url must be a boolean or string', 'invalid_url', field)\n\t        }),\n\t    })\n\t    const data = {}\n\t    await assert.validationErrors(vine.validate({ schema, data }), [\n\t      {\n\t        field: 'health_check',\n", "        message: 'The health_check url must be a boolean or string',\n\t        rule: 'invalid_url',\n\t      },\n\t    ])\n\t  })\n\t  test('disallow duplicate types', async ({ assert }) => {\n\t    assert.throws(\n\t      () => vine.unionOfTypes([vine.string().email(), vine.string().url()]),\n\t      'Cannot use duplicate schema \"vine.string\". \"vine.unionOfTypes\" needs distinct schema types only'\n\t    )\n", "    assert.throws(\n\t      () => vine.unionOfTypes([vine.record(vine.string()), vine.record(vine.number())]),\n\t      'Cannot use duplicate schema \"vine.object\". \"vine.unionOfTypes\" needs distinct schema types only'\n\t    )\n\t  })\n\t  test('disallow union inside union of types', async ({ assert }) => {\n\t    assert.throws(\n\t      () => vine.unionOfTypes([vine.union([])]),\n\t      'Cannot use \"VineUnion\". The schema type is not compatible for use with \"vine.unionOfTypes\"'\n\t    )\n", "  })\n\t})\n"]}
{"filename": "tests/types/types.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { Vine } from '../../src/vine/main.js'\n", "import { Infer, ValidationOptions } from '../../src/types.js'\n\tconst vine = new Vine()\n\ttest.group('Types | Flat schema', () => {\n\t  test('infer types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      email: vine.string(),\n\t      is_admin: vine.boolean(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n", "    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string\n\t      is_admin: boolean\n\t    }>()\n\t  })\n\t  test('infer types with nullable fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      email: vine.string().nullable(),\n", "      is_admin: vine.boolean(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string | null\n\t      is_admin: boolean\n\t    }>()\n\t  })\n\t  test('infer types with optional fields', ({ expectTypeOf }) => {\n", "    const schema = vine.object({\n\t      username: vine.string(),\n\t      email: vine.string().optional().nullable(),\n\t      is_admin: vine.boolean().optional(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string | null | undefined\n\t      is_admin: boolean | undefined\n", "    }>()\n\t  })\n\t  test('infer types with transform function', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      username: vine.string().transform((value) => value),\n\t      email: vine.string().nullable().optional(),\n\t      is_admin: vine\n\t        .boolean()\n\t        .nullable()\n\t        .transform((value) => {\n", "          if (value === null) {\n\t            return false\n\t          }\n\t          return value\n\t        }),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string | null | undefined\n", "      is_admin: boolean\n\t    }>()\n\t  })\n\t  test('convert keys to camelCase', ({ expectTypeOf }) => {\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string().transform((value) => value),\n\t        email: vine.string().nullable().optional(),\n\t        is_admin: vine\n\t          .boolean()\n", "          .nullable()\n\t          .transform((value) => {\n\t            if (value === null) {\n\t              return false\n\t            }\n\t            return value\n\t          }),\n\t      })\n\t      .toCamelCase()\n\t    type Schema = Infer<typeof schema>\n", "    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string | null | undefined\n\t      isAdmin: boolean\n\t    }>()\n\t  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    const schema = vine\n\t      .object({\n\t        username: vine\n", "          .string()\n\t          .clone()\n\t          .transform((value) => value),\n\t        email: vine.string().nullable().optional().clone(),\n\t        is_admin: vine\n\t          .boolean()\n\t          .nullable()\n\t          .transform((value) => {\n\t            if (value === null) {\n\t              return false\n", "            }\n\t            return value\n\t          })\n\t          .clone(),\n\t      })\n\t      .toCamelCase()\n\t      .clone()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n", "      email: string | null | undefined\n\t      isAdmin: boolean\n\t    }>()\n\t  })\n\t})\n\ttest.group('Types | Nested schema', () => {\n\t  test('infer types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      email: vine.string(),\n", "      is_admin: vine.boolean(),\n\t      profile: vine.object({\n\t        twitter_handle: vine.string(),\n\t        github_username: vine.string(),\n\t      }),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string\n", "      is_admin: boolean\n\t      profile: {\n\t        twitter_handle: string\n\t        github_username: string\n\t      }\n\t    }>()\n\t  })\n\t  test('infer types with nullable fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n", "      email: vine.string(),\n\t      is_admin: vine.boolean(),\n\t      profile: vine\n\t        .object({\n\t          twitter_handle: vine.string(),\n\t          github_username: vine.string(),\n\t        })\n\t        .nullable(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n", "    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string\n\t      is_admin: boolean\n\t      profile: {\n\t        twitter_handle: string\n\t        github_username: string\n\t      } | null\n\t    }>()\n\t  })\n", "  test('infer types with optional fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      email: vine.string().optional(),\n\t      is_admin: vine.boolean(),\n\t      profile: vine\n\t        .object({\n\t          twitter_handle: vine.string(),\n\t          github_username: vine.string().optional(),\n\t        })\n", "        .nullable(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string | undefined\n\t      is_admin: boolean\n\t      profile: {\n\t        twitter_handle: string\n\t        github_username: string | undefined\n", "      } | null\n\t    }>()\n\t  })\n\t  test('infer types with transform function', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      email: vine.string().optional(),\n\t      is_admin: vine.boolean(),\n\t      profile: vine\n\t        .object({\n", "          twitter_handle: vine.string(),\n\t          github_username: vine\n\t            .string()\n\t            .nullable()\n\t            .transform((value) => value || true),\n\t        })\n\t        .nullable(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n", "      username: string\n\t      email: string | undefined\n\t      is_admin: boolean\n\t      profile: {\n\t        twitter_handle: string\n\t        github_username: string | true\n\t      } | null\n\t    }>()\n\t  })\n\t  test('convert keys to camelCase', ({ expectTypeOf }) => {\n", "    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n\t        email: vine.string().optional(),\n\t        is_admin: vine.boolean(),\n\t        profile: vine\n\t          .object({\n\t            twitter_handle: vine.string(),\n\t            github_username: vine.string().nullable(),\n\t          })\n", "          .nullable(),\n\t      })\n\t      .toCamelCase()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string | undefined\n\t      isAdmin: boolean\n\t      profile: {\n\t        twitterHandle: string\n", "        githubUsername: string | null\n\t      } | null\n\t    }>()\n\t  })\n\t  test('convert nested object keys to camelCase', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      email: vine.string().optional(),\n\t      is_admin: vine.boolean(),\n\t      profile: vine\n", "        .object({\n\t          twitter_handle: vine.string(),\n\t          github_username: vine.string().nullable(),\n\t        })\n\t        .toCamelCase()\n\t        .nullable(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n", "      email: string | undefined\n\t      is_admin: boolean\n\t      profile: {\n\t        twitterHandle: string\n\t        githubUsername: string | null\n\t      } | null\n\t    }>()\n\t  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    const schema = vine\n", "      .object({\n\t        username: vine.string().clone(),\n\t        email: vine.string().optional().clone(),\n\t        is_admin: vine.boolean(),\n\t        profile: vine\n\t          .object({\n\t            twitter_handle: vine.string(),\n\t            github_username: vine.string().nullable(),\n\t          })\n\t          .clone()\n", "          .nullable(),\n\t      })\n\t      .clone()\n\t      .toCamelCase()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string | undefined\n\t      isAdmin: boolean\n\t      profile: {\n", "        twitterHandle: string\n\t        githubUsername: string | null\n\t      } | null\n\t    }>()\n\t  })\n\t})\n\ttest.group('Types | Object groups', () => {\n\t  test('infer types', ({ expectTypeOf }) => {\n\t    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n", "        hiring_guide: vine.literal(true),\n\t        guide_name: vine.string(),\n\t        fees: vine.string(),\n\t      }),\n\t      vine.group.if(() => true, {\n\t        hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const schema = vine\n\t      .object({\n", "        visitor_name: vine.string(),\n\t      })\n\t      .merge(guideSchema)\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<\n\t      {\n\t        visitor_name: string\n\t      } & (\n\t        | {\n\t            hiring_guide: true\n", "            guide_name: string\n\t            fees: string\n\t          }\n\t        | {\n\t            hiring_guide: false\n\t          }\n\t      )\n\t    >()\n\t  })\n\t  test('infer types with nullable fields', ({ expectTypeOf }) => {\n", "    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n\t        hiring_guide: vine.literal(true),\n\t        guide_name: vine.string(),\n\t        fees: vine.string(),\n\t      }),\n\t      vine.group.if(() => true, {\n\t        hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n", "    const schema = vine\n\t      .object({\n\t        visitor_name: vine.string(),\n\t      })\n\t      .merge(guideSchema)\n\t      .nullable()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<\n\t      | ({\n\t          visitor_name: string\n", "        } & (\n\t          | {\n\t              hiring_guide: true\n\t              guide_name: string\n\t              fees: string\n\t            }\n\t          | {\n\t              hiring_guide: false\n\t            }\n\t        ))\n", "      | null\n\t    >()\n\t  })\n\t  test('infer types with optional fields', ({ expectTypeOf }) => {\n\t    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n\t        hiring_guide: vine.literal(true),\n\t        guide_name: vine.string(),\n\t        fees: vine.string(),\n\t      }),\n", "      vine.group.if(() => true, {\n\t        hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const schema = vine\n\t      .object({\n\t        visitor_name: vine.string(),\n\t      })\n\t      .merge(guideSchema)\n\t      .optional()\n", "    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<\n\t      | ({\n\t          visitor_name: string\n\t        } & (\n\t          | {\n\t              hiring_guide: true\n\t              guide_name: string\n\t              fees: string\n\t            }\n", "          | {\n\t              hiring_guide: false\n\t            }\n\t        ))\n\t      | undefined\n\t    >()\n\t  })\n\t  test('infer types with multiple groups', ({ expectTypeOf }) => {\n\t    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n", "        hiring_guide: vine.literal(true),\n\t        guide_name: vine.string(),\n\t        fees: vine.string(),\n\t      }),\n\t      vine.group.if(() => true, {\n\t        hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const monumentSchema = vine.group([\n\t      vine.group.if((data) => data.monument === 'foo', {\n", "        monument: vine.literal('foo'),\n\t        available_transport: vine.enum(['bus', 'train']),\n\t        has_free_entry: vine.literal(false),\n\t      }),\n\t      vine.group.if((data) => data.monument === 'bar', {\n\t        monument: vine.literal('bar'),\n\t        available_transport: vine.enum(['bus', 'car']),\n\t        has_free_entry: vine.literal(true),\n\t      }),\n\t    ])\n", "    const schema = vine\n\t      .object({\n\t        visitor_name: vine.string(),\n\t      })\n\t      .merge(guideSchema)\n\t      .merge(monumentSchema)\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<\n\t      {\n\t        visitor_name: string\n", "      } & (\n\t        | {\n\t            hiring_guide: true\n\t            guide_name: string\n\t            fees: string\n\t          }\n\t        | {\n\t            hiring_guide: false\n\t          }\n\t      ) &\n", "        (\n\t          | {\n\t              monument: 'foo'\n\t              available_transport: 'bus' | 'train'\n\t              has_free_entry: false\n\t            }\n\t          | {\n\t              monument: 'bar'\n\t              available_transport: 'bus' | 'car'\n\t              has_free_entry: true\n", "            }\n\t        )\n\t    >()\n\t  })\n\t  test('convert keys to camelCase', ({ expectTypeOf }) => {\n\t    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n\t        hiring_guide: vine.literal(true),\n\t        guide_name: vine.string(),\n\t        fees: vine.string(),\n", "      }),\n\t      vine.group.if(() => true, {\n\t        hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const schema = vine\n\t      .object({\n\t        visitor_name: vine.string(),\n\t      })\n\t      .merge(guideSchema)\n", "      .toCamelCase()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<\n\t      {\n\t        visitorName: string\n\t      } & (\n\t        | {\n\t            hiringGuide: true\n\t            guideName: string\n\t            fees: string\n", "          }\n\t        | {\n\t            hiringGuide: false\n\t          }\n\t      )\n\t    >()\n\t  })\n\t  test('infer types when allowUnknownProperties is true', ({ expectTypeOf }) => {\n\t    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n", "        hiring_guide: vine.literal(true),\n\t        guide_name: vine.string(),\n\t        fees: vine.string(),\n\t      }),\n\t      vine.group.if(() => true, {\n\t        hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const schema = vine\n\t      .object({\n", "        visitor_name: vine.string(),\n\t      })\n\t      .merge(guideSchema)\n\t      .allowUnknownProperties()\n\t      .optional()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<\n\t      | (({\n\t          visitor_name: string\n\t        } & (\n", "          | {\n\t              hiring_guide: true\n\t              guide_name: string\n\t              fees: string\n\t            }\n\t          | {\n\t              hiring_guide: false\n\t            }\n\t        )) & { [K: string]: unknown })\n\t      | undefined\n", "    >()\n\t  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n\t        hiring_guide: vine.literal(true),\n\t        guide_name: vine.string(),\n\t        fees: vine.string(),\n\t      }),\n\t      vine.group.if(() => true, {\n", "        hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const schema = vine\n\t      .object({\n\t        visitor_name: vine.string().clone(),\n\t      })\n\t      .merge(guideSchema)\n\t      .allowUnknownProperties()\n\t      .optional()\n", "      .clone()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<\n\t      | (({\n\t          visitor_name: string\n\t        } & (\n\t          | {\n\t              hiring_guide: true\n\t              guide_name: string\n\t              fees: string\n", "            }\n\t          | {\n\t              hiring_guide: false\n\t            }\n\t        )) & { [K: string]: unknown })\n\t      | undefined\n\t    >()\n\t  })\n\t})\n\ttest.group('Types | Arrays', () => {\n", "  test('infer types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      contacts: vine.array(\n\t        vine.object({\n\t          email: vine.string(),\n\t          is_primary: vine.boolean(),\n\t        })\n\t      ),\n\t    })\n\t    type Schema = Infer<typeof schema>\n", "    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      contacts: {\n\t        email: string\n\t        is_primary: boolean\n\t      }[]\n\t    }>()\n\t  })\n\t  test('infer types with nullable fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      contacts: vine\n", "        .array(\n\t          vine.object({\n\t            email: vine.string(),\n\t            is_primary: vine.boolean(),\n\t          })\n\t        )\n\t        .nullable(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n", "      contacts:\n\t        | {\n\t            email: string\n\t            is_primary: boolean\n\t          }[]\n\t        | null\n\t    }>()\n\t  })\n\t  test('infer types with optional fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n", "      contacts: vine\n\t        .array(\n\t          vine.object({\n\t            email: vine.string(),\n\t            is_primary: vine.boolean(),\n\t          })\n\t        )\n\t        .nullable()\n\t        .optional(),\n\t    })\n", "    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      contacts:\n\t        | {\n\t            email: string\n\t            is_primary: boolean\n\t          }[]\n\t        | null\n\t        | undefined\n\t    }>()\n", "  })\n\t  test('convert keys to camelCase', ({ expectTypeOf }) => {\n\t    const schema = vine\n\t      .object({\n\t        contacts: vine\n\t          .array(\n\t            vine.object({\n\t              email: vine.string(),\n\t              is_primary: vine.boolean(),\n\t            })\n", "          )\n\t          .nullable()\n\t          .optional(),\n\t      })\n\t      .toCamelCase()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      contacts:\n\t        | {\n\t            email: string\n", "            isPrimary: boolean\n\t          }[]\n\t        | null\n\t        | undefined\n\t    }>()\n\t  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    const schema = vine\n\t      .object({\n\t        contacts: vine\n", "          .array(\n\t            vine.object({\n\t              email: vine.string().clone(),\n\t              is_primary: vine.boolean().clone(),\n\t            })\n\t          )\n\t          .nullable()\n\t          .clone()\n\t          .optional(),\n\t      })\n", "      .toCamelCase()\n\t      .clone()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      contacts:\n\t        | {\n\t            email: string\n\t            isPrimary: boolean\n\t          }[]\n\t        | null\n", "        | undefined\n\t    }>()\n\t  })\n\t})\n\ttest.group('Types | Tuples', () => {\n\t  test('infer types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      colors: vine.tuple([vine.string(), vine.string(), vine.string()]),\n\t    })\n\t    type Schema = Infer<typeof schema>\n", "    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      colors: [string, string, string]\n\t    }>()\n\t  })\n\t  test('infer types with nullable fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      colors: vine.tuple([vine.string(), vine.string(), vine.string()]).nullable(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n", "      colors: [string, string, string] | null\n\t    }>()\n\t  })\n\t  test('infer types with optional fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      colors: vine.tuple([vine.string(), vine.string(), vine.string()]).nullable().optional(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      colors: [string, string, string] | null | undefined\n", "    }>()\n\t  })\n\t  test('allow unknown properties', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      colors: vine\n\t        .tuple([vine.string(), vine.string(), vine.string()])\n\t        .allowUnknownProperties()\n\t        .nullable()\n\t        .optional(),\n\t    })\n", "    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      colors: [string, string, string, ...unknown[]] | null | undefined\n\t    }>()\n\t  })\n\t  test('convert keys to camelCase', ({ expectTypeOf }) => {\n\t    const schema = vine\n\t      .object({\n\t        colors: vine\n\t          .tuple([\n", "            vine.string(),\n\t            vine.string(),\n\t            vine.object({\n\t              primary_1: vine.string(),\n\t            }),\n\t          ])\n\t          .allowUnknownProperties()\n\t          .nullable()\n\t          .optional(),\n\t      })\n", "      .toCamelCase()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      colors: [string, string, { primary1: string }, ...unknown[]] | null | undefined\n\t    }>()\n\t  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    const schema = vine\n\t      .object({\n\t        colors: vine\n", "          .tuple([\n\t            vine.string().clone(),\n\t            vine.string().clone(),\n\t            vine\n\t              .object({\n\t                primary_1: vine.string(),\n\t              })\n\t              .clone(),\n\t          ])\n\t          .allowUnknownProperties()\n", "          .nullable()\n\t          .clone()\n\t          .optional(),\n\t      })\n\t      .toCamelCase()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      colors: [string, string, { primary1: string }, ...unknown[]] | null | undefined\n\t    }>()\n\t  })\n", "})\n\ttest.group('Types | Union', () => {\n\t  test('infer types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      contact: vine.union([\n\t        vine.union.if(\n\t          (value) => vine.helpers.isObject(value) && 'email' in value,\n\t          vine.object({\n\t            email: vine.string(),\n\t            otp: vine.string(),\n", "          })\n\t        ),\n\t        vine.union.if(\n\t          (value) => vine.helpers.isObject(value) && 'username' in value,\n\t          vine.object({\n\t            username: vine.string(),\n\t            password: vine.string(),\n\t          })\n\t        ),\n\t      ]),\n", "    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      contact:\n\t        | {\n\t            email: string\n\t            otp: string\n\t          }\n\t        | {\n\t            username: string\n", "            password: string\n\t          }\n\t    }>()\n\t  })\n\t  test('infer types of nested unions', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      contact: vine.union([\n\t        vine.union.if(\n\t          (value) => vine.helpers.isObject(value) && 'email' in value,\n\t          vine.union([\n", "            vine.union.if(\n\t              (value) => vine.helpers.isObject(value) && 'otp' in value,\n\t              vine.object({\n\t                otp: vine.string(),\n\t              })\n\t            ),\n\t            vine.union.else(\n\t              vine.object({\n\t                email: vine.string(),\n\t              })\n", "            ),\n\t          ])\n\t        ),\n\t        vine.union.if(\n\t          (value) => vine.helpers.isObject(value) && 'username' in value,\n\t          vine.object({\n\t            username: vine.string(),\n\t            password: vine.string(),\n\t          })\n\t        ),\n", "      ]),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      contact:\n\t        | {\n\t            email: string\n\t          }\n\t        | {\n\t            otp: string\n", "          }\n\t        | {\n\t            username: string\n\t            password: string\n\t          }\n\t    }>()\n\t  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      contact: vine\n", "        .union([\n\t          vine.union.if(\n\t            (value) => vine.helpers.isObject(value) && 'email' in value,\n\t            vine.union([\n\t              vine.union.if(\n\t                (value) => vine.helpers.isObject(value) && 'otp' in value,\n\t                vine\n\t                  .object({\n\t                    otp: vine.string(),\n\t                  })\n", "                  .clone()\n\t              ),\n\t              vine.union.else(\n\t                vine\n\t                  .object({\n\t                    email: vine.string(),\n\t                  })\n\t                  .clone()\n\t              ),\n\t            ])\n", "          ),\n\t          vine.union.if(\n\t            (value) => vine.helpers.isObject(value) && 'username' in value,\n\t            vine.object({\n\t              username: vine.string().clone(),\n\t              password: vine.string().clone(),\n\t            })\n\t          ),\n\t        ])\n\t        .clone(),\n", "    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      contact:\n\t        | {\n\t            email: string\n\t          }\n\t        | {\n\t            otp: string\n\t          }\n", "        | {\n\t            username: string\n\t            password: string\n\t          }\n\t    }>()\n\t  })\n\t})\n\ttest.group('Types | Record', () => {\n\t  test('infer types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n", "      colors: vine.record(vine.string()),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      colors: {\n\t        [K: string]: string\n\t      }\n\t    }>()\n\t  })\n\t  test('infer types with nullable fields', ({ expectTypeOf }) => {\n", "    const schema = vine.object({\n\t      colors: vine.record(vine.string()).nullable(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      colors: {\n\t        [K: string]: string\n\t      } | null\n\t    }>()\n\t  })\n", "  test('infer types with optional fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      colors: vine.record(vine.string()).optional().nullable(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      colors:\n\t        | {\n\t            [K: string]: string\n\t          }\n", "        | undefined\n\t        | null\n\t    }>()\n\t  })\n\t  test('infer union record types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      /**\n\t       * @todo: Use union of types here\n\t       */\n\t      colors: vine.record(vine.string()),\n", "    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      colors: {\n\t        [K: string]: string\n\t      }\n\t    }>()\n\t  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n", "      /**\n\t       * @todo: Use union of types here\n\t       */\n\t      colors: vine.record(vine.string()).clone(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      colors: {\n\t        [K: string]: string\n\t      }\n", "    }>()\n\t  })\n\t})\n\ttest.group('Types | Enum', () => {\n\t  test('infer types', ({ expectTypeOf }) => {\n\t    const schema = vine\n\t      .object({\n\t        role: vine.enum(['admin', 'moderator', 'writer']),\n\t      })\n\t      .clone()\n", "    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      role: 'admin' | 'moderator' | 'writer'\n\t    }>()\n\t  })\n\t  test('infer types with nullable fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      role: vine.enum(['admin', 'moderator', 'writer']).nullable(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n", "    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      role: 'admin' | 'moderator' | 'writer' | null\n\t    }>()\n\t  })\n\t  test('infer types with optional fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      role: vine.enum(['admin', 'moderator', 'writer']).nullable().optional(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n", "      role: 'admin' | 'moderator' | 'writer' | null | undefined\n\t    }>()\n\t  })\n\t  test('infer types from native enum', ({ expectTypeOf }) => {\n\t    enum Role {\n\t      MODERATOR = 'moderator',\n\t      WRITER = 'writer',\n\t      ADMIN = 'admin',\n\t    }\n\t    const schema = vine.object({\n", "      role: vine.enum(Role).nullable().optional(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      role: Role | null | undefined\n\t    }>()\n\t  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    enum Role {\n\t      MODERATOR = 'moderator',\n", "      WRITER = 'writer',\n\t      ADMIN = 'admin',\n\t    }\n\t    const schema = vine\n\t      .object({\n\t        role: vine.enum(Role).nullable().optional().clone(),\n\t      })\n\t      .clone()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n", "      role: Role | null | undefined\n\t    }>()\n\t  })\n\t})\n\ttest.group('Types | Accepted', () => {\n\t  test('infer types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      terms_and_conditions: vine.accepted(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n", "    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      terms_and_conditions: true\n\t    }>()\n\t  })\n\t  test('infer types with nullable fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      terms_and_conditions: vine.accepted().nullable(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n", "      terms_and_conditions: true | null\n\t    }>()\n\t  })\n\t  test('infer types with optional fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      terms_and_conditions: vine.accepted().nullable().optional(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      terms_and_conditions: true | null | undefined\n", "    }>()\n\t  })\n\t  test('infer types with transformer', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      terms_and_conditions: vine\n\t        .accepted()\n\t        .nullable()\n\t        .optional()\n\t        .transform(() => {\n\t          return true\n", "        }),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      terms_and_conditions: boolean\n\t    }>()\n\t  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      terms_and_conditions: vine.accepted().clone().nullable().optional(),\n", "    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      terms_and_conditions: true | null | undefined\n\t    }>()\n\t  })\n\t})\n\ttest.group('Types | Any', () => {\n\t  test('infer types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n", "      secret_message: vine.any(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      secret_message: any\n\t    }>()\n\t  })\n\t  test('infer types with nullable fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      secret_message: vine.any().nullable(),\n", "    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      secret_message: any\n\t    }>()\n\t  })\n\t  test('infer types with optional fields', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      secret_message: vine.any().optional().nullable(),\n\t    })\n", "    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      secret_message: any\n\t    }>()\n\t  })\n\t  test('infer types with transformer', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      secret_message: vine.any().transform(() => {\n\t        return '1234'\n\t      }),\n", "    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      secret_message: string\n\t    }>()\n\t  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      secret_message: vine\n\t        .any()\n", "        .transform(() => {\n\t          return '1234'\n\t        })\n\t        .clone(),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      secret_message: string\n\t    }>()\n\t  })\n", "})\n\ttest.group('Types | UnionOfTypes', () => {\n\t  test('infer types', ({ expectTypeOf }) => {\n\t    const schema = vine.object({\n\t      health_check: vine.unionOfTypes([vine.boolean(), vine.string()]),\n\t    })\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      health_check: boolean | string\n\t    }>()\n", "  })\n\t  test('clone types', ({ expectTypeOf }) => {\n\t    const schema = vine\n\t      .object({\n\t        health_check: vine.unionOfTypes([vine.boolean(), vine.string()]),\n\t      })\n\t      .clone()\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      health_check: boolean | string\n", "    }>()\n\t  })\n\t})\n\ttest.group('Types | compiled schema', () => {\n\t  test('infer types from compiled schema', ({ expectTypeOf }) => {\n\t    const schema = vine.compile(\n\t      vine.object({\n\t        username: vine.string(),\n\t        email: vine.string(),\n\t        is_admin: vine.boolean(),\n", "      })\n\t    )\n\t    type Schema = Infer<typeof schema>\n\t    expectTypeOf<Schema>().toEqualTypeOf<{\n\t      username: string\n\t      email: string\n\t      is_admin: boolean\n\t    }>()\n\t  })\n\t  test('ensure type-safety for metadata', ({ expectTypeOf }) => {\n", "    const schema = vine.withMetaData<{ userId: number }>().compile(\n\t      vine.object({\n\t        username: vine.string(),\n\t        email: vine.string(),\n\t        is_admin: vine.boolean(),\n\t      })\n\t    )\n\t    // @ts-expect-error\n\t    schema.validate({})\n\t    // @ts-expect-error\n", "    schema.validate({}, {})\n\t    // @ts-expect-error\n\t    schema.validate({}, { meta: { foo: 'bar' } })\n\t    expectTypeOf<typeof schema.validate>().parameters.toEqualTypeOf<\n\t      [any, ValidationOptions<{ userId: number }>]\n\t    >\n\t  })\n\t})\n"]}
{"filename": "tests/unit/create_rule.spec.ts", "chunked_list": ["/*\n\t * vinejs\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { createRule } from '../../src/vine/create_rule.js'\n", "test.group('Create rule', () => {\n\t  test('create a custom validation rule', ({ assert }) => {\n\t    function validator() {}\n\t    const ruleFn = createRule(validator)\n\t    assert.strictEqual(ruleFn().rule.validator, validator)\n\t  })\n\t  test('infer options from validator', ({ assert, expectTypeOf }) => {\n\t    function validator(_: unknown, __: { foo: string; bar: boolean }) {}\n\t    const ruleFn = createRule(validator)\n\t    expectTypeOf(ruleFn).parameters.toEqualTypeOf<[{ foo: string; bar: boolean }]>()\n", "    assert.deepEqual(ruleFn({ foo: '1', bar: true }).options, { foo: '1', bar: true })\n\t  })\n\t  test('infer optional options from validator', ({ assert, expectTypeOf }) => {\n\t    function validator(_: unknown, __?: { foo: string; bar: boolean }) {}\n\t    const ruleFn = createRule(validator)\n\t    expectTypeOf(ruleFn).parameters.toEqualTypeOf<[{ foo: string; bar: boolean }?]>()\n\t    assert.deepEqual(ruleFn({ foo: '1', bar: true }).options, { foo: '1', bar: true })\n\t  })\n\t  test('infer async validator functions', ({ assert }) => {\n\t    async function validator() {}\n", "    const ruleFn = createRule(validator)\n\t    assert.isTrue(ruleFn().rule.isAsync)\n\t  })\n\t  test('mark validation as implicit', ({ assert }) => {\n\t    async function validator() {}\n\t    const ruleFn = createRule(validator, { implicit: true })\n\t    assert.isTrue(ruleFn().rule.implicit)\n\t  })\n\t  test('do not allow marking async functions as non-async', ({ assert }) => {\n\t    async function validator() {}\n", "    const ruleFn = createRule(validator, { implicit: true, isAsync: false })\n\t    assert.isTrue(ruleFn().rule.isAsync)\n\t  })\n\t  test('allow marking functions as async', ({ assert }) => {\n\t    function validator() {}\n\t    const ruleFn = createRule(validator, { implicit: true, isAsync: true })\n\t    assert.isTrue(ruleFn().rule.isAsync)\n\t  })\n\t  test('allow marking non async functions as non-async', ({ assert }) => {\n\t    function validator() {}\n", "    const ruleFn = createRule(validator, { implicit: true, isAsync: false })\n\t    assert.isFalse(ruleFn().rule.isAsync)\n\t  })\n\t})\n"]}
{"filename": "tests/unit/validation_error.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { ValidationError } from '../../src/errors/validation_error.js'\n", "test.group('Exception', () => {\n\t  test('create exception with error messages', ({ assert }) => {\n\t    const error = new ValidationError([{ message: 'Field is required' }])\n\t    assert.equal(error.message, 'Validation failure')\n\t    assert.equal(error.status, 422)\n\t    assert.equal(error.code, 'E_VALIDATION_ERROR')\n\t    assert.deepEqual(error.messages, [{ message: 'Field is required' }])\n\t  })\n\t  test('point stack trace to correct file', ({ assert }) => {\n\t    assert.plan(1)\n", "    try {\n\t      throw new ValidationError([{ message: 'Field is required' }])\n\t    } catch (error) {\n\t      assert.match(error.stack.split('\\n')[1], /validation_error.spec.ts/)\n\t    }\n\t  })\n\t  test('convert error to string', ({ assert }) => {\n\t    const error = new ValidationError([{ message: 'Field is required' }])\n\t    assert.equal(error.toString(), 'Error [E_VALIDATION_ERROR]: Validation failure')\n\t  })\n", "  test('get class string name', ({ assert }) => {\n\t    const error = new ValidationError([{ message: 'Field is required' }])\n\t    assert.equal(Object.prototype.toString.call(error), '[object ValidationError]')\n\t  })\n\t})\n"]}
{"filename": "tests/unit/helpers.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { Vine } from '../../src/vine/main.js'\n", "const vine = new Vine()\n\ttest.group('Vine Helpers', () => {\n\t  test('check if the value is true', ({ assert }) => {\n\t    assert.isTrue(vine.helpers.isTrue(true))\n\t    assert.isTrue(vine.helpers.isTrue(1))\n\t    assert.isTrue(vine.helpers.isTrue('true'))\n\t    assert.isTrue(vine.helpers.isTrue('1'))\n\t    assert.isTrue(vine.helpers.isTrue('on'))\n\t    assert.isFalse(vine.helpers.isTrue('foo'))\n\t  })\n", "  test('check if the value is false', ({ assert }) => {\n\t    assert.isTrue(vine.helpers.isFalse(false))\n\t    assert.isTrue(vine.helpers.isFalse(0))\n\t    assert.isTrue(vine.helpers.isFalse('false'))\n\t    assert.isTrue(vine.helpers.isFalse('0'))\n\t    assert.isFalse(vine.helpers.isFalse('on'))\n\t    assert.isFalse(vine.helpers.isFalse('true'))\n\t  })\n\t  test('check if the value is string', ({ assert, expectTypeOf }) => {\n\t    assert.isTrue(vine.helpers.isString('hello'))\n", "    assert.isFalse(vine.helpers.isString(true))\n\t    const value: unknown = 'hello'\n\t    if (vine.helpers.isString(value)) {\n\t      expectTypeOf(value).toEqualTypeOf<string>()\n\t    }\n\t  })\n\t  test('check if the value is object', ({ assert, expectTypeOf }) => {\n\t    assert.isTrue(vine.helpers.isObject({}))\n\t    assert.isFalse(vine.helpers.isObject(null))\n\t    assert.isFalse(vine.helpers.isObject([]))\n", "    assert.isFalse(vine.helpers.isObject('hello'))\n\t    const value: unknown = { foo: 'bar' }\n\t    if (vine.helpers.isObject(value)) {\n\t      expectTypeOf(value).toEqualTypeOf<Record<PropertyKey, unknown>>()\n\t      assert.equal(value.foo, 'bar')\n\t      assert.isUndefined(value.baz)\n\t    }\n\t    if (vine.helpers.isObject<string>(value)) {\n\t      expectTypeOf(value).toEqualTypeOf<Record<PropertyKey, string>>()\n\t    }\n", "  })\n\t  test('check if the value is array', ({ assert, expectTypeOf }) => {\n\t    assert.isTrue(vine.helpers.isArray([]))\n\t    assert.isFalse(vine.helpers.isArray(null))\n\t    assert.isFalse(vine.helpers.isArray({}))\n\t    assert.isFalse(vine.helpers.isArray('hello'))\n\t    const value: unknown = ['hello', 'world']\n\t    if (vine.helpers.isArray(value)) {\n\t      expectTypeOf(value).toEqualTypeOf<unknown[]>()\n\t      assert.equal(value[0], 'hello')\n", "      assert.equal(value[1], 'world')\n\t    }\n\t    if (vine.helpers.isArray<string>(value)) {\n\t      expectTypeOf(value).toEqualTypeOf<string[]>()\n\t    }\n\t  })\n\t  test('check if the value is numeric', ({ assert }) => {\n\t    assert.isTrue(vine.helpers.isNumeric('22'))\n\t    assert.isTrue(vine.helpers.isNumeric('22.12'))\n\t    assert.isTrue(vine.helpers.isNumeric('22.00'))\n", "    assert.isFalse(vine.helpers.isNumeric('foo'))\n\t  })\n\t  test('convert value to number', ({ assert }) => {\n\t    assert.equal(vine.helpers.asNumber('22'), 22)\n\t    assert.equal(vine.helpers.asNumber('22.12'), 22.12)\n\t    assert.equal(vine.helpers.asNumber('22.00'), 22)\n\t    assert.isNaN(vine.helpers.asNumber('foo'))\n\t  })\n\t  test('convert value to boolean', ({ assert }) => {\n\t    assert.equal(vine.helpers.asBoolean(true), true)\n", "    assert.equal(vine.helpers.asBoolean(1), true)\n\t    assert.equal(vine.helpers.asBoolean('true'), true)\n\t    assert.equal(vine.helpers.asBoolean('1'), true)\n\t    assert.equal(vine.helpers.asBoolean('on'), true)\n\t    assert.isNull(vine.helpers.asBoolean('foo'))\n\t    assert.equal(vine.helpers.asBoolean(false), false)\n\t    assert.equal(vine.helpers.asBoolean(0), false)\n\t    assert.equal(vine.helpers.asBoolean('false'), false)\n\t    assert.equal(vine.helpers.asBoolean('0'), false)\n\t    assert.isNull(vine.helpers.asBoolean('foo'))\n", "  })\n\t  test('check if the value is missing', ({ assert }) => {\n\t    assert.isTrue(vine.helpers.isMissing(null))\n\t    assert.isTrue(vine.helpers.isMissing(undefined))\n\t    assert.isFalse(vine.helpers.isMissing(''))\n\t  })\n\t  test('check if the value exists', ({ assert }) => {\n\t    assert.isFalse(vine.helpers.exists(null))\n\t    assert.isFalse(vine.helpers.exists(undefined))\n\t    assert.isTrue(vine.helpers.exists(''))\n", "  })\n\t  test('DNS: return {result} for {url}')\n\t    .with([\n\t      {\n\t        url: 'foo',\n\t        result: false,\n\t      },\n\t      {\n\t        url: 'https://foo',\n\t        result: false,\n", "      },\n\t      {\n\t        url: 'http://google.com',\n\t        result: true,\n\t      },\n\t      {\n\t        url: 'http://www.google.com',\n\t        result: true,\n\t      },\n\t      {\n", "        url: 'http://www.google.com/terms',\n\t        result: true,\n\t      },\n\t    ])\n\t    .run(async ({ assert }, { url, result }) => {\n\t      assert.equal(await vine.helpers.isActiveURL(url), result)\n\t    })\n\t  test('mobileLocales contains the list of mobile locales', ({ assert }) => {\n\t    const codes = vine.helpers.mobileLocales\n\t    assert.containsSubset(codes, ['fr-FR', 'en-GB', 'de-DE'])\n", "  })\n\t  test('postalCountryCodes contains the list of postal country codes', ({ assert }) => {\n\t    const codes = vine.helpers.postalCountryCodes\n\t    assert.containsSubset(codes, ['FR', 'GB', 'IT'])\n\t  })\n\t  test('validator.js functions are working', ({ assert }) => {\n\t    assert.isTrue(vine.helpers.isSlug('hello-world'))\n\t    assert.isTrue(vine.helpers.isPostalCode('69200', 'FR'))\n\t    assert.isTrue(vine.helpers.isMobilePhone('0612345678', 'fr-FR'))\n\t  })\n", "})\n"]}
{"filename": "tests/unit/simple_messages_provider.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { fieldContext } from '../../factories/main.js'\n", "import { SimpleMessagesProvider } from '../../src/messages_provider/simple_messages_provider.js'\n\ttest.group('Simple messages provider | resolving messages', () => {\n\t  test('get custom message for a rule', ({ assert }) => {\n\t    const provider = new SimpleMessagesProvider(\n\t      {\n\t        required: 'The field is required',\n\t      },\n\t      {}\n\t    )\n\t    assert.equal(\n", "      provider.getMessage('Enter value', 'required', fieldContext.create('username', undefined)),\n\t      'The field is required'\n\t    )\n\t  })\n\t  test('give priority to field message', ({ assert }) => {\n\t    const provider = new SimpleMessagesProvider(\n\t      {\n\t        'required': 'The field is required',\n\t        'username.required': 'Username is required',\n\t      },\n", "      {}\n\t    )\n\t    assert.equal(\n\t      provider.getMessage('Enter value', 'required', fieldContext.create('username', undefined)),\n\t      'Username is required'\n\t    )\n\t  })\n\t  test('use default message when no message is provided', ({ assert }) => {\n\t    const provider = new SimpleMessagesProvider(\n\t      {\n", "        'username.required': 'Username is required',\n\t      },\n\t      {}\n\t    )\n\t    assert.equal(\n\t      provider.getMessage('Enter value', 'required', fieldContext.create('email', undefined)),\n\t      'Enter value'\n\t    )\n\t  })\n\t})\n", "test.group('Simple messages provider | resolving fields', () => {\n\t  test('substitue field name in custom message', ({ assert }) => {\n\t    const provider = new SimpleMessagesProvider(\n\t      {\n\t        required: 'The {{ field }} field is required',\n\t      },\n\t      {\n\t        username: 'account id',\n\t      }\n\t    )\n", "    assert.equal(\n\t      provider.getMessage('Enter value', 'required', fieldContext.create('username', undefined)),\n\t      'The account id field is required'\n\t    )\n\t  })\n\t  test('substitue field name in field message', ({ assert }) => {\n\t    const provider = new SimpleMessagesProvider(\n\t      {\n\t        'required': 'The field is required',\n\t        'username.required': 'The {{ field }} is required',\n", "      },\n\t      {\n\t        username: 'account id',\n\t      }\n\t    )\n\t    assert.equal(\n\t      provider.getMessage('Enter value', 'required', fieldContext.create('username', undefined)),\n\t      'The account id is required'\n\t    )\n\t  })\n", "  test('substitue field name in default message', ({ assert }) => {\n\t    const provider = new SimpleMessagesProvider(\n\t      {\n\t        'username.required': 'Username is required',\n\t      },\n\t      {\n\t        email: 'email address',\n\t      }\n\t    )\n\t    assert.equal(\n", "      provider.getMessage('Enter {{ field }}', 'required', fieldContext.create('email', undefined)),\n\t      'Enter email address'\n\t    )\n\t  })\n\t})\n\ttest.group('Simple messages provider | interpolation', () => {\n\t  test('interpolate reported args', ({ assert }) => {\n\t    const provider = new SimpleMessagesProvider(\n\t      {\n\t        min: 'The {{ field }} field must have {{ min }} items',\n", "      },\n\t      {}\n\t    )\n\t    assert.equal(\n\t      provider.getMessage('Enter value', 'min', fieldContext.create('scores', undefined), {\n\t        min: 11,\n\t      }),\n\t      'The scores field must have 11 items'\n\t    )\n\t  })\n", "  test('interpolate nested args', ({ assert }) => {\n\t    const provider = new SimpleMessagesProvider(\n\t      {\n\t        min: 'The {{ field }} field must have {{ items.min }} items',\n\t      },\n\t      {}\n\t    )\n\t    assert.equal(\n\t      provider.getMessage('Enter value', 'min', fieldContext.create('scores', undefined), {\n\t        items: {\n", "          min: 11,\n\t        },\n\t      }),\n\t      'The scores field must have 11 items'\n\t    )\n\t  })\n\t  test('replace missing values with undefined', ({ assert }) => {\n\t    const provider = new SimpleMessagesProvider(\n\t      {\n\t        min: 'The {{ field }} field must have {{ items.min }} items',\n", "      },\n\t      {}\n\t    )\n\t    assert.equal(\n\t      provider.getMessage('Enter value', 'min', fieldContext.create('scores', undefined), {}),\n\t      'The scores field must have undefined items'\n\t    )\n\t  })\n\t})\n"]}
{"filename": "tests/unit/simple_error_reporter.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { fieldContext } from '../../factories/main.js'\n", "import { ValidationError } from '../../src/errors/validation_error.js'\n\timport { SimpleErrorReporter } from '../../src/reporters/simple_error_reporter.js'\n\ttest.group('Simple error reporter', () => {\n\t  test('collect reported errors', ({ assert }) => {\n\t    const reporter = new SimpleErrorReporter()\n\t    const field = fieldContext.create('username', '')\n\t    reporter.report('The username field is required', 'required', field)\n\t    assert.isTrue(reporter.hasErrors)\n\t    assert.deepEqual(reporter.errors, [\n\t      {\n", "        field: 'username',\n\t        message: 'The username field is required',\n\t        rule: 'required',\n\t      },\n\t    ])\n\t  })\n\t  test('collect error meta data', ({ assert }) => {\n\t    const reporter = new SimpleErrorReporter()\n\t    const field = fieldContext.create('username', '')\n\t    reporter.report('The username field is required', 'required', field, {\n", "      requiredWhen: {\n\t        missing: 'email',\n\t      },\n\t    })\n\t    assert.isTrue(reporter.hasErrors)\n\t    assert.deepEqual(reporter.errors, [\n\t      {\n\t        field: 'username',\n\t        message: 'The username field is required',\n\t        rule: 'required',\n", "        meta: {\n\t          requiredWhen: {\n\t            missing: 'email',\n\t          },\n\t        },\n\t      },\n\t    ])\n\t  })\n\t  test('report array index when field is an array member', ({ assert }) => {\n\t    const reporter = new SimpleErrorReporter()\n", "    const field = fieldContext.create('username', '')\n\t    reporter.report('Scores are required', 'required', {\n\t      ...field,\n\t      ...{\n\t        isArrayMember: true,\n\t        name: 0,\n\t        wildCardPath: 'scores.*',\n\t        parent: [],\n\t      },\n\t    })\n", "    assert.isTrue(reporter.hasErrors)\n\t    assert.deepEqual(reporter.errors, [\n\t      {\n\t        field: 'scores.*',\n\t        message: 'Scores are required',\n\t        index: 0,\n\t        rule: 'required',\n\t      },\n\t    ])\n\t  })\n", "  test('convert errors to an instance of validation error', ({ assert }) => {\n\t    const reporter = new SimpleErrorReporter()\n\t    const field = fieldContext.create('username', '')\n\t    reporter.report('The username field is required', 'required', field, {\n\t      requiredWhen: {\n\t        missing: 'email',\n\t      },\n\t    })\n\t    const error = reporter.createError()\n\t    assert.isTrue(reporter.hasErrors)\n", "    assert.instanceOf(error, ValidationError)\n\t    assert.deepEqual(error.messages, [\n\t      {\n\t        field: 'username',\n\t        message: 'The username field is required',\n\t        rule: 'required',\n\t        meta: {\n\t          requiredWhen: {\n\t            missing: 'email',\n\t          },\n", "        },\n\t      },\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/rules/number.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validator } from '../../../factories/main.js'\n", "import {\n\t  minRule,\n\t  maxRule,\n\t  rangeRule,\n\t  numberRule,\n\t  positiveRule,\n\t  negativeRule,\n\t  decimalRule,\n\t  withoutDecimalsRule,\n\t} from '../../../src/schema/number/rules.js'\n", "test.group('Number | number', () => {\n\t  test('report when value is not a number', () => {\n\t    const number = numberRule({})\n\t    const validated = validator.execute(number, 'foo')\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('pass validation when value is a number', () => {\n\t    const number = numberRule({})\n\t    const validated = validator.execute(number, 22)\n\t    validated.assertSucceeded()\n", "    validated.assertOutput(22)\n\t  })\n\t  test('pass validation when value is a string representation of a number', () => {\n\t    const number = numberRule({})\n\t    const validated = validator.execute(number, '22')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput(22)\n\t  })\n\t  test('disallow string representation in strict mode', () => {\n\t    const number = numberRule({ strict: true })\n", "    const validated = validator.execute(number, '22')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t    const withNaN = validator.execute(number, Number.NaN)\n\t    withNaN.assertErrorsCount(1)\n\t    withNaN.assertError('The dummy field must be a number')\n\t  })\n\t  test('report when value is an infinite number', () => {\n\t    const number = numberRule({})\n\t    const validated = validator.execute(\n", "      number,\n\t      '3177777777777777777777777777777777777777777777777777777777777777777777777770000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999991111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n\t    )\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('report when value is a negative infinite number', () => {\n\t    const number = numberRule({})\n\t    const validated = validator.execute(\n\t      number,\n\t      '-3177777777777777777777777777777777777777777777777777777777777777777777777770000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999991111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'\n", "    )\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t})\n\ttest.group('Number | min', () => {\n\t  test('skip validation when value is not a number', () => {\n\t    const number = numberRule({})\n\t    const min = minRule({ min: 18 })\n\t    const validated = validator.execute([number, min], 'foo')\n\t    validated.assertErrorsCount(1)\n", "    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('skip validation when value is not a number with bail mode disabled', () => {\n\t    const number = numberRule({})\n\t    const min = minRule({ min: 18 })\n\t    const validated = validator.bail(false).execute([number, min], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('report error when value is less than the minimum value', () => {\n", "    const number = numberRule({})\n\t    const min = minRule({ min: 18 })\n\t    const validated = validator.execute([number, min], 12)\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be at least 18')\n\t  })\n\t  test('pass validation when value is same or greater than the minimum value', () => {\n\t    const number = numberRule({})\n\t    const min = minRule({ min: 18 })\n\t    validator.execute([number, min], 18).assertErrorsCount(0)\n", "    validator.execute([number, min], 20).assertErrorsCount(0)\n\t  })\n\t})\n\ttest.group('Number | max', () => {\n\t  test('skip validation when value is not a number', () => {\n\t    const number = numberRule({})\n\t    const max = maxRule({ max: 60 })\n\t    const validated = validator.execute([number, max], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n", "  })\n\t  test('skip validation when value is not a number with bail mode disabled', () => {\n\t    const number = numberRule({})\n\t    const max = maxRule({ max: 60 })\n\t    const validated = validator.bail(false).execute([number, max], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('report error when value is greater than the maximum value', () => {\n\t    const number = numberRule({})\n", "    const max = maxRule({ max: 60 })\n\t    const validated = validator.execute([number, max], 72)\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must not be greater than 60')\n\t  })\n\t  test('pass validation when value is same or less than the minimum value', () => {\n\t    const number = numberRule({})\n\t    const max = maxRule({ max: 60 })\n\t    validator.execute([number, max], 60).assertErrorsCount(0)\n\t    validator.execute([number, max], 32).assertErrorsCount(0)\n", "  })\n\t})\n\ttest.group('Number | range', () => {\n\t  test('skip validation when value is not a number', () => {\n\t    const number = numberRule({})\n\t    const range = rangeRule({ min: 18, max: 60 })\n\t    const validated = validator.execute([number, range], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n", "  test('skip validation when value is not a number with bail mode disabled', () => {\n\t    const number = numberRule({})\n\t    const range = rangeRule({ min: 18, max: 60 })\n\t    const validated = validator.bail(false).execute([number, range], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('report error when value is greater than the maximum value', () => {\n\t    const number = numberRule({})\n\t    const range = rangeRule({ min: 18, max: 60 })\n", "    const validated = validator.execute([number, range], 72)\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be between 18 and 60')\n\t  })\n\t  test('report error when value is less than the minimum value', () => {\n\t    const number = numberRule({})\n\t    const range = rangeRule({ min: 18, max: 60 })\n\t    const validated = validator.execute([number, range], 12)\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be between 18 and 60')\n", "  })\n\t  test('pass validation when value is under the range', () => {\n\t    const number = numberRule({})\n\t    const range = rangeRule({ min: 18, max: 60 })\n\t    validator.execute([number, range], 18).assertErrorsCount(0)\n\t    validator.execute([number, range], 60).assertErrorsCount(0)\n\t    validator.execute([number, range], 22).assertErrorsCount(0)\n\t  })\n\t})\n\ttest.group('Number | positive', () => {\n", "  test('skip validation when value is not a number', () => {\n\t    const number = numberRule({})\n\t    const positive = positiveRule()\n\t    const validated = validator.execute([number, positive], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('skip validation when value is not a number with bail mode disabled', () => {\n\t    const number = numberRule({})\n\t    const positive = positiveRule()\n", "    const validated = validator.bail(false).execute([number, positive], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('report error when value is negative', () => {\n\t    const number = numberRule({})\n\t    const positive = positiveRule()\n\t    const validated = validator.execute([number, positive], -10)\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be positive')\n", "    const validated1 = validator.execute([number, positive], '-10')\n\t    validated1.assertErrorsCount(1)\n\t    validated1.assertError('The dummy field must be positive')\n\t  })\n\t  test('pass validation when value is positive', () => {\n\t    const number = numberRule({})\n\t    const positive = positiveRule()\n\t    validator.execute([number, positive], 10).assertErrorsCount(0)\n\t    validator.execute([number, positive], '0').assertErrorsCount(0)\n\t  })\n", "})\n\ttest.group('Number | negative', () => {\n\t  test('skip validation when value is not a number', () => {\n\t    const number = numberRule({})\n\t    const negative = negativeRule()\n\t    const validated = validator.execute([number, negative], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('skip validation when value is not a number with bail mode disabled', () => {\n", "    const number = numberRule({})\n\t    const negative = negativeRule()\n\t    const validated = validator.bail(false).execute([number, negative], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('report error when value is positive', () => {\n\t    const number = numberRule({})\n\t    const negative = negativeRule()\n\t    const validated = validator.execute([number, negative], 0)\n", "    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be negative')\n\t    const validated1 = validator.execute([number, negative], '10')\n\t    validated1.assertErrorsCount(1)\n\t    validated1.assertError('The dummy field must be negative')\n\t  })\n\t  test('pass validation when value is negative', () => {\n\t    const number = numberRule({})\n\t    const negative = negativeRule()\n\t    validator.execute([number, negative], '-10').assertErrorsCount(0)\n", "    validator.execute([number, negative], -1).assertErrorsCount(0)\n\t  })\n\t})\n\ttest.group('Number | decimals', () => {\n\t  test('skip validation when value is not a number', () => {\n\t    const number = numberRule({})\n\t    const decimal = decimalRule({ range: [0, 2] })\n\t    const validated = validator.execute([number, decimal], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n", "  })\n\t  test('skip validation when value is not a number with bail mode disabled', () => {\n\t    const number = numberRule({})\n\t    const decimal = decimalRule({ range: [0, 2] })\n\t    const validated = validator.bail(false).execute([number, decimal], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('report error when value has less than fixed decimal places', () => {\n\t    const number = numberRule({})\n", "    const decimal = decimalRule({ range: [2] })\n\t    const validated = validator.execute([number, decimal], '9')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must have 2 decimal places')\n\t  })\n\t  test('report error when value has more than fixed decimal places', () => {\n\t    const number = numberRule({})\n\t    const decimal = decimalRule({ range: [2] })\n\t    const validated = validator.execute([number, decimal], '9.9899')\n\t    validated.assertErrorsCount(1)\n", "    validated.assertError('The dummy field must have 2 decimal places')\n\t  })\n\t  test('work fine when value has exact decimal places', () => {\n\t    const number = numberRule({})\n\t    const decimal = decimalRule({ range: [2] })\n\t    const validated = validator.execute([number, decimal], '9.99')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput(9.99)\n\t  })\n\t  test('report error when value has less than the range of decimal places', () => {\n", "    const number = numberRule({})\n\t    const decimal = decimalRule({ range: [2, 4] })\n\t    const validated = validator.execute([number, decimal], '9')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must have 2-4 decimal places')\n\t  })\n\t  test('report error when value has more than the range of decimal places', () => {\n\t    const number = numberRule({})\n\t    const decimal = decimalRule({ range: [2, 4] })\n\t    const validated = validator.execute([number, decimal], '9.90009')\n", "    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must have 2-4 decimal places')\n\t  })\n\t  test('work fine when value decimal places are in range', () => {\n\t    const number = numberRule({})\n\t    const decimal = decimalRule({ range: [0, 2] })\n\t    const validated = validator.execute([number, decimal], '9.99')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput(9.99)\n\t    const validated1 = validator.execute([number, decimal], '9')\n", "    validated1.assertSucceeded()\n\t    validated1.assertOutput(9)\n\t  })\n\t})\n\ttest.group('Number | withoutDecimals', () => {\n\t  test('skip validation when value is not a number', () => {\n\t    const number = numberRule({})\n\t    const withoutDecimals = withoutDecimalsRule()\n\t    const validated = validator.execute([number, withoutDecimals], 'foo')\n\t    validated.assertErrorsCount(1)\n", "    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('skip validation when value is not a number with bail mode disabled', () => {\n\t    const number = numberRule({})\n\t    const withoutDecimals = withoutDecimalsRule()\n\t    const validated = validator.bail(false).execute([number, withoutDecimals], 'foo')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a number')\n\t  })\n\t  test('report error when value has decimal places', () => {\n", "    const number = numberRule({})\n\t    const withoutDecimals = withoutDecimalsRule()\n\t    const validated = validator.execute([number, withoutDecimals], '18.11')\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be an integer')\n\t  })\n\t  test('work fine when value is an integer', () => {\n\t    const number = numberRule({})\n\t    const withoutDecimals = withoutDecimalsRule()\n\t    const validated = validator.execute([number, withoutDecimals], '18.00')\n", "    validated.assertSucceeded()\n\t    validated.assertOutput(18)\n\t  })\n\t})\n"]}
{"filename": "tests/unit/rules/enum.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { enumRule } from '../../../src/schema/enum/rules.js'\n", "import { ValidatorFactory } from '../../../factories/validator.js'\n\ttest.group('Rules | enum', () => {\n\t  test('report error when field value is not a subset of pre-defined choices', () => {\n\t    const validation = enumRule({ choices: ['admin', 'moderator', 'guest'] })\n\t    const value = 'foo'\n\t    const validated = new ValidatorFactory().execute(validation, value)\n\t    validated.assertError('The selected dummy is invalid')\n\t  })\n\t  test('do not validate when value is undefined', () => {\n\t    const validation = enumRule({ choices: ['admin', 'moderator', 'guest'] })\n", "    const value = undefined\n\t    const validated = new ValidatorFactory().execute(validation, value)\n\t    validated.assertErrorsCount(0)\n\t  })\n\t  test('do not validate when value is null', () => {\n\t    const validation = enumRule({ choices: ['admin', 'moderator', 'guest'] })\n\t    const value = null\n\t    const validated = new ValidatorFactory().execute(validation, value)\n\t    validated.assertErrorsCount(0)\n\t  })\n", "  test('report error when value is empty string', () => {\n\t    const validation = enumRule({ choices: ['admin', 'moderator', 'guest'] })\n\t    const value = ''\n\t    const validated = new ValidatorFactory().execute(validation, value)\n\t    validated.assertError('The selected dummy is invalid')\n\t  })\n\t  test('pass validation when value is a subset of choices', () => {\n\t    const validation = enumRule({ choices: ['admin', 'moderator', 'guest'] })\n\t    const value = 'admin'\n\t    const validated = new ValidatorFactory().execute(validation, value)\n", "    validated.assertErrorsCount(0)\n\t  })\n\t  test('compute choices from a callback', () => {\n\t    const validation = enumRule({ choices: () => ['admin', 'moderator', 'guest'] })\n\t    const value = 'admin'\n\t    const validated = new ValidatorFactory().execute(validation, value)\n\t    validated.assertErrorsCount(0)\n\t  })\n\t})\n"]}
{"filename": "tests/unit/rules/string.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validator } from '../../../factories/main.js'\n", "import {\n\t  urlRule,\n\t  trimRule,\n\t  regexRule,\n\t  alphaRule,\n\t  emailRule,\n\t  stringRule,\n\t  mobileRule,\n\t  hexCodeRule,\n\t  endsWithRule,\n", "  confirmedRule,\n\t  activeUrlRule,\n\t  minLengthRule,\n\t  maxLengthRule,\n\t  startsWithRule,\n\t  fixedLengthRule,\n\t  alphaNumericRule,\n\t  normalizeEmailRule,\n\t  sameAsRule,\n\t  notSameAsRule,\n", "  inRule,\n\t  notInRule,\n\t  ipAddressRule,\n\t  creditCardRule,\n\t  passportRule,\n\t  postalCodeRule,\n\t  uuidRule,\n\t  asciiRule,\n\t  ibanRule,\n\t  jwtRule,\n", "  coordinatesRule,\n\t  toUpperCaseRule,\n\t  toLowerCaseRule,\n\t  toCamelCaseRule,\n\t  escapeRule,\n\t  normalizeUrlRule,\n\t} from '../../../src/schema/string/rules.js'\n\timport type { FieldContext, Validation } from '../../../src/types.js'\n\ttype DataSet = {\n\t  errorsCount?: number\n", "  error?: string\n\t  bail?: boolean\n\t  rule: Validation<any>\n\t  value: any\n\t  output?: any\n\t  field?: Partial<FieldContext>\n\t}\n\t/**\n\t * Helpers to run string schema type validations\n\t */\n", "async function stringRuleValidator(_: any, dataset: DataSet) {\n\t  const string = stringRule()\n\t  const validated = dataset.rule.rule.isAsync\n\t    ? await validator\n\t        .bail(dataset.bail === false ? false : true)\n\t        .withContext(dataset.field || {})\n\t        .executeAsync([string, dataset.rule], dataset.value)\n\t    : validator\n\t        .bail(dataset.bail === false ? false : true)\n\t        .withContext(dataset.field || {})\n", "        .execute([string, dataset.rule], dataset.value)\n\t  if (dataset.error && dataset.errorsCount) {\n\t    validated.assertErrorsCount(dataset.errorsCount)\n\t    validated.assertError(dataset.error)\n\t  } else {\n\t    validated.assertSucceeded()\n\t    validated.assertOutput(dataset.output || dataset.value)\n\t  }\n\t}\n\ttest.group('String | string', () => {\n", "  test('report when value is not a string', () => {\n\t    const string = stringRule()\n\t    const validated = validator.execute(string, 22)\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('The dummy field must be a string')\n\t  })\n\t  test('pass validation when value is a string', () => {\n\t    const string = stringRule()\n\t    const validated = validator.execute(string, '22')\n\t    validated.assertSucceeded()\n", "    validated.assertOutput('22')\n\t  })\n\t})\n\ttest.group('String | email', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: emailRule(),\n\t        value: 22,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: emailRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: emailRule(),\n\t        value: 'foo',\n\t        error: 'The dummy field must be a valid email address',\n\t      },\n\t      {\n\t        rule: emailRule(),\n\t        value: 'foo@bar.com',\n\t      },\n\t      {\n", "        rule: emailRule({ allow_display_name: true }),\n\t        value: 'Foo <foo@bar.com>',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | mobile', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n", "        errorsCount: 1,\n\t        rule: mobileRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: mobileRule(),\n\t        value: 22,\n\t        bail: false,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: mobileRule(),\n\t        value: '20202',\n\t        error: 'The dummy field must be a valid mobile phone number',\n\t      },\n\t      {\n\t        rule: mobileRule(),\n", "        value: '804 225 1616',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: mobileRule({ locale: ['en-IN'] }),\n\t        value: '(555) 555-1234',\n\t        error: 'The dummy field must be a valid mobile phone number',\n\t      },\n\t      {\n\t        rule: mobileRule({ locale: ['en-IN'] }),\n", "        value: '9883443344',\n\t      },\n\t      {\n\t        rule: mobileRule({ locale: ['en-IN', 'en-US'] }),\n\t        value: '(555) 555-1234',\n\t      },\n\t      {\n\t        rule: mobileRule({ locale: ['en-IN', 'en-US'] }),\n\t        value: '9883443344',\n\t      },\n", "      {\n\t        rule: mobileRule({ locale: ['en-IN', 'en-US'], strictMode: true }),\n\t        value: '+1 (555) 555-1234',\n\t      },\n\t      {\n\t        rule: mobileRule({ locale: ['en-IN', 'en-US'], strictMode: true }),\n\t        value: '+919883443344',\n\t      },\n\t      {\n\t        rule: mobileRule(() => {\n", "          return { locale: ['en-IN', 'en-US'] }\n\t        }),\n\t        value: '(555) 555-1234',\n\t      },\n\t      {\n\t        rule: mobileRule(() => {\n\t          return { locale: ['en-IN', 'en-US'] }\n\t        }),\n\t        value: '9883443344',\n\t      },\n", "      {\n\t        rule: mobileRule(() => {\n\t          return {}\n\t        }),\n\t        value: '(555) 555-1234',\n\t      },\n\t      {\n\t        rule: mobileRule(() => {\n\t          return {}\n\t        }),\n", "        value: '9883443344',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | hexCode', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n", "        rule: hexCodeRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: hexCodeRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: hexCodeRule(),\n\t        value: 'fff',\n\t        error: 'The dummy field must be a valid hex color code',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: hexCodeRule(),\n", "        value: 'red',\n\t        error: 'The dummy field must be a valid hex color code',\n\t      },\n\t      {\n\t        rule: hexCodeRule(),\n\t        value: '#fff',\n\t      },\n\t      {\n\t        rule: hexCodeRule(),\n\t        value: '#ffffff',\n", "      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | url', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: urlRule(),\n", "        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: urlRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n", "      {\n\t        errorsCount: 1,\n\t        rule: urlRule(),\n\t        value: 'foo_bar',\n\t        error: 'The dummy field must be a valid URL',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: urlRule({ allow_underscores: false }),\n\t        value: 'https://foo_bar.com',\n", "        error: 'The dummy field must be a valid URL',\n\t      },\n\t      {\n\t        rule: urlRule(),\n\t        value: 'https://google.com',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | activeUrl', () => {\n", "  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: activeUrlRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n", "        rule: activeUrlRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: activeUrlRule(),\n\t        value: 'foo_bar',\n\t        error: 'The dummy field must be a valid URL',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: activeUrlRule(),\n\t        value: 'https://foo.com',\n\t        error: 'The dummy field must be a valid URL',\n\t      },\n\t      {\n\t        rule: activeUrlRule(),\n\t        value: 'https://google.com',\n", "      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | regex', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: regexRule(/^[a-zA-Z0-9]+$/),\n", "        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: regexRule(/^[a-zA-Z0-9]+$/),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n", "      {\n\t        errorsCount: 1,\n\t        rule: regexRule(/^[a-zA-Z0-9]+$/),\n\t        value: 'foo_bar',\n\t        error: 'The dummy field format is invalid',\n\t      },\n\t      {\n\t        rule: regexRule(/^[a-zA-Z0-9]+$/),\n\t        value: 'hello',\n\t      },\n", "      {\n\t        rule: regexRule(/^[a-zA-Z0-9]+$/),\n\t        value: 'hello1234',\n\t      },\n\t      {\n\t        rule: regexRule(new RegExp('^[a-zA-Z0-9]+$')),\n\t        value: 'hello',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n", "})\n\ttest.group('String | alpha', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: alphaRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n", "      {\n\t        errorsCount: 1,\n\t        rule: alphaRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: alphaRule(),\n", "        value: 'foo_bar',\n\t        error: 'The dummy field must contain only letters',\n\t      },\n\t      {\n\t        rule: alphaRule(),\n\t        value: 'hello',\n\t      },\n\t      {\n\t        rule: alphaRule({ allowSpaces: true }),\n\t        value: 'hello world',\n", "      },\n\t      {\n\t        rule: alphaRule({ allowUnderscores: true }),\n\t        value: 'hello_world',\n\t      },\n\t      {\n\t        rule: alphaRule({ allowDashes: true }),\n\t        value: 'hello-world',\n\t      },\n\t    ])\n", "    .run(stringRuleValidator)\n\t})\n\ttest.group('String | alphaNumeric', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: alphaNumericRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: alphaNumericRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n", "        rule: alphaNumericRule(),\n\t        value: 'foo_bar',\n\t        error: 'The dummy field must contain only letters and numbers',\n\t      },\n\t      {\n\t        rule: alphaNumericRule(),\n\t        value: 'hello1244',\n\t      },\n\t      {\n\t        rule: alphaNumericRule({ allowSpaces: true }),\n", "        value: 'hello 1244',\n\t      },\n\t      {\n\t        rule: alphaNumericRule({ allowUnderscores: true }),\n\t        value: 'hello_1244',\n\t      },\n\t      {\n\t        rule: alphaNumericRule({ allowDashes: true }),\n\t        value: 'hello-1244',\n\t      },\n", "    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | minLength', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: minLengthRule({ min: 10 }),\n\t        value: 22,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: minLengthRule({ min: 10 }),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: minLengthRule({ min: 10 }),\n\t        value: 'foo_bar',\n\t        error: 'The dummy field must have at least 10 characters',\n\t      },\n\t      {\n\t        rule: minLengthRule({ min: 10 }),\n\t        value: 'hello_universe',\n\t      },\n\t    ])\n", "    .run(stringRuleValidator)\n\t})\n\ttest.group('String | maxLength', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: maxLengthRule({ max: 10 }),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: maxLengthRule({ max: 10 }),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n", "        rule: maxLengthRule({ max: 10 }),\n\t        value: 'hello_universe',\n\t        error: 'The dummy field must not be greater than 10 characters',\n\t      },\n\t      {\n\t        rule: maxLengthRule({ max: 10 }),\n\t        value: 'foo_bar',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n", "})\n\ttest.group('String | fixedLength', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: fixedLengthRule({ size: 10 }),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n", "      {\n\t        errorsCount: 1,\n\t        rule: fixedLengthRule({ size: 10 }),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: fixedLengthRule({ size: 10 }),\n", "        value: 'hello_universe',\n\t        error: 'The dummy field must be 10 characters long',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: fixedLengthRule({ size: 10 }),\n\t        value: 'foo',\n\t        error: 'The dummy field must be 10 characters long',\n\t      },\n\t      {\n", "        rule: fixedLengthRule({ size: 10 }),\n\t        value: 'helloworld',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | confirmed', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n", "        errorsCount: 1,\n\t        rule: confirmedRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: confirmedRule(),\n\t        value: 22,\n\t        bail: false,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: confirmedRule(),\n\t        value: 'foo',\n\t        error: 'The dummy field and dummy_confirmation field must be the same',\n\t      },\n\t      {\n\t        errorsCount: 1,\n", "        rule: confirmedRule(),\n\t        value: 'foo',\n\t        field: {\n\t          parent: {\n\t            dummy_confirmation: '',\n\t          },\n\t        },\n\t        error: 'The dummy field and dummy_confirmation field must be the same',\n\t      },\n\t      {\n", "        rule: confirmedRule(),\n\t        value: 'foo',\n\t        field: {\n\t          parent: {\n\t            dummy_confirmation: 'foo',\n\t          },\n\t        },\n\t      },\n\t      {\n\t        rule: confirmedRule({ confirmationField: 'dummyConfirmed' }),\n", "        value: 'foo',\n\t        field: {\n\t          parent: {\n\t            dummyConfirmed: 'foo',\n\t          },\n\t        },\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n", "test.group('String | trim', () => {\n\t  test('trim whitespaces from: {value} to {output}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: trimRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: trimRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        rule: trimRule(),\n\t        value: ' hello worl  ',\n\t        output: 'hello worl',\n", "      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | normalizeEmail', () => {\n\t  test('normalize email: {value} to {output}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: normalizeEmailRule(),\n", "        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: normalizeEmailRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n", "      {\n\t        rule: normalizeEmailRule(),\n\t        value: 'FOO@bar.com',\n\t        output: 'foo@bar.com',\n\t      },\n\t      {\n\t        rule: normalizeEmailRule(),\n\t        value: 'foo.bar@gmail.com',\n\t        output: 'foobar@gmail.com',\n\t      },\n", "      {\n\t        rule: normalizeEmailRule({ gmail_remove_dots: false }),\n\t        value: 'foo.bar@gmail.com',\n\t        output: 'foo.bar@gmail.com',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | startsWith', () => {\n\t  test('validate {value}')\n", "    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: startsWithRule({ substring: 'foo' }),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: startsWithRule({ substring: 'foo' }),\n", "        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: startsWithRule({ substring: 'foo' }),\n\t        value: 'hello world',\n\t        error: 'The dummy field must start with foo',\n\t      },\n", "      {\n\t        rule: startsWithRule({ substring: 'foo' }),\n\t        value: 'foo world',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | endsWith', () => {\n\t  test('validate {value}')\n\t    .with([\n", "      {\n\t        errorsCount: 1,\n\t        rule: endsWithRule({ substring: 'foo' }),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: endsWithRule({ substring: 'foo' }),\n\t        value: 22,\n", "        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: endsWithRule({ substring: 'foo' }),\n\t        value: 'hello world',\n\t        error: 'The dummy field must end with foo',\n\t      },\n\t      {\n", "        rule: endsWithRule({ substring: 'foo' }),\n\t        value: 'world foo',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | sameAs', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n", "        errorsCount: 1,\n\t        rule: sameAsRule({ otherField: 'password' }),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: sameAsRule({ otherField: 'password' }),\n\t        value: 22,\n\t        bail: false,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: sameAsRule({ otherField: 'password' }),\n\t        value: 'foo',\n\t        field: {\n\t          name: 'password_confirmation',\n\t        },\n\t        error: 'The password_confirmation field and password field must be the same',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: sameAsRule({ otherField: 'password' }),\n\t        value: 'foo',\n\t        field: {\n\t          name: 'password_confirmation',\n\t          parent: {\n\t            password: '',\n\t          },\n", "        },\n\t        error: 'The password_confirmation field and password field must be the same',\n\t      },\n\t      {\n\t        rule: sameAsRule({ otherField: 'password' }),\n\t        value: 'foo',\n\t        field: {\n\t          name: 'password_confirmation',\n\t          parent: {\n\t            password: 'foo',\n", "          },\n\t        },\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | notSameAs', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n", "        errorsCount: 1,\n\t        rule: notSameAsRule({ otherField: 'password' }),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: notSameAsRule({ otherField: 'password' }),\n\t        value: 22,\n\t        bail: false,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        rule: notSameAsRule({ otherField: 'password' }),\n\t        value: 'foo',\n\t        field: {\n\t          name: 'password_confirmation',\n\t        },\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: notSameAsRule({ otherField: 'password' }),\n\t        value: 'foo',\n\t        field: {\n\t          name: 'password_confirmation',\n\t          parent: {\n\t            password: 'foo',\n\t          },\n\t        },\n\t        error: 'The password_confirmation field and password field must be different',\n", "      },\n\t      {\n\t        rule: notSameAsRule({ otherField: 'password' }),\n\t        value: 'foo',\n\t        field: {\n\t          name: 'password_confirmation',\n\t          parent: {\n\t            password: 'bar',\n\t          },\n\t        },\n", "      },\n\t      {\n\t        rule: notSameAsRule({ otherField: 'password' }),\n\t        value: 'foo',\n\t        field: {\n\t          name: 'password_confirmation',\n\t          parent: {\n\t            password: '',\n\t          },\n\t        },\n", "      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | in', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: inRule({ choices: ['admin', 'moderator', 'writer'] }),\n", "        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: inRule({ choices: ['admin', 'moderator', 'writer'] }),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n", "      {\n\t        errorsCount: 1,\n\t        rule: inRule({ choices: ['admin', 'moderator', 'writer'] }),\n\t        value: 'foo',\n\t        error: 'The selected dummy is invalid',\n\t      },\n\t      {\n\t        rule: inRule({ choices: ['admin', 'moderator', 'writer'] }),\n\t        value: 'admin',\n\t      },\n", "      {\n\t        errorsCount: 1,\n\t        rule: inRule({ choices: () => ['admin', 'moderator', 'writer'] }),\n\t        value: 'foo',\n\t        error: 'The selected dummy is invalid',\n\t      },\n\t      {\n\t        rule: inRule({ choices: () => ['admin', 'moderator', 'writer'] }),\n\t        value: 'admin',\n\t      },\n", "    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | notIn', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: notInRule({ list: ['admin', 'moderator', 'writer'] }),\n\t        value: 22,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: notInRule({ list: ['admin', 'moderator', 'writer'] }),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: notInRule({ list: ['admin', 'moderator', 'writer'] }),\n\t        value: 'admin',\n\t        error: 'The selected dummy is invalid',\n\t      },\n\t      {\n\t        rule: notInRule({ list: ['admin', 'moderator', 'writer'] }),\n\t        value: 'root',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: notInRule({ list: () => ['admin', 'moderator', 'writer'] }),\n\t        value: 'admin',\n\t        error: 'The selected dummy is invalid',\n\t      },\n\t      {\n\t        rule: notInRule({ list: () => ['admin', 'moderator', 'writer'] }),\n\t        value: 'root',\n\t      },\n\t    ])\n", "    .run(stringRuleValidator)\n\t})\n\ttest.group('String | ipAddress', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: ipAddressRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: ipAddressRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n", "        rule: ipAddressRule(),\n\t        value: 'foobar',\n\t        error: 'The dummy field must be a valid IP address',\n\t      },\n\t      {\n\t        rule: ipAddressRule(),\n\t        value: '192.168.1.2',\n\t      },\n\t      {\n\t        rule: ipAddressRule(),\n", "        value: '::1234:5678',\n\t      },\n\t      {\n\t        rule: ipAddressRule({ version: 4 }),\n\t        value: '192.168.1.2',\n\t      },\n\t      {\n\t        rule: ipAddressRule({ version: 6 }),\n\t        value: '::1234:5678',\n\t      },\n", "      {\n\t        errorsCount: 1,\n\t        rule: ipAddressRule({ version: 6 }),\n\t        value: '192.168.1.2',\n\t        error: 'The dummy field must be a valid IP address',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: ipAddressRule({ version: 4 }),\n\t        value: '::1234:5678',\n", "        error: 'The dummy field must be a valid IP address',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | creditCard', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n", "        rule: creditCardRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: creditCardRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: creditCardRule(),\n\t        value: '123456789',\n\t        error: 'The dummy field must be a valid credit card number',\n\t      },\n\t      {\n\t        rule: creditCardRule(),\n\t        value: '30569309025904',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: creditCardRule({ provider: ['amex'] }),\n\t        value: '30569309025904',\n\t        error: 'The dummy field must be a valid amex card number',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: creditCardRule({ provider: ['amex', 'visa'] }),\n", "        value: '30569309025904',\n\t        error: 'The dummy field must be a valid amex/visa card number',\n\t      },\n\t      {\n\t        rule: creditCardRule({ provider: ['amex', 'visa', 'dinersclub'] }),\n\t        value: '30569309025904',\n\t      },\n\t      {\n\t        rule: creditCardRule(() => {}),\n\t        value: '30569309025904',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: creditCardRule(() => {\n\t          return { provider: ['amex'] }\n\t        }),\n\t        value: '30569309025904',\n\t        error: 'The dummy field must be a valid amex card number',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: creditCardRule(() => {\n\t          return { provider: ['amex', 'visa'] }\n\t        }),\n\t        value: '30569309025904',\n\t        error: 'The dummy field must be a valid amex/visa card number',\n\t      },\n\t      {\n\t        rule: creditCardRule(() => {\n\t          return { provider: ['amex', 'visa', 'dinersclub'] }\n", "        }),\n\t        value: '30569309025904',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | passport', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n", "        errorsCount: 1,\n\t        rule: passportRule({ countryCode: ['IN'] }),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: passportRule({ countryCode: ['IN'] }),\n\t        value: 22,\n\t        bail: false,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: passportRule({ countryCode: ['IN'] }),\n\t        value: '1999010301',\n\t        error: 'The dummy field must be a valid passport number',\n\t      },\n\t      {\n\t        rule: passportRule({ countryCode: ['IN'] }),\n", "        value: 'J8369854',\n\t      },\n\t      {\n\t        rule: passportRule({ countryCode: ['US'] }),\n\t        value: 'J8369854',\n\t        errorsCount: 1,\n\t        error: 'The dummy field must be a valid passport number',\n\t      },\n\t      {\n\t        rule: passportRule({ countryCode: ['IN', 'US'] }),\n", "        value: 'J8369854',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: passportRule(() => {\n\t          return { countryCode: ['IN'] }\n\t        }),\n\t        value: '1999010301',\n\t        error: 'The dummy field must be a valid passport number',\n\t      },\n", "      {\n\t        rule: passportRule(() => {\n\t          return { countryCode: ['IN'] }\n\t        }),\n\t        value: 'J8369854',\n\t      },\n\t      {\n\t        rule: passportRule(() => {\n\t          return { countryCode: ['US'] }\n\t        }),\n", "        value: 'J8369854',\n\t        errorsCount: 1,\n\t        error: 'The dummy field must be a valid passport number',\n\t      },\n\t      {\n\t        rule: passportRule(() => {\n\t          return { countryCode: ['IN', 'US'] }\n\t        }),\n\t        value: 'J8369854',\n\t      },\n", "    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | postalCode', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: postalCodeRule(),\n\t        value: 22,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: postalCodeRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: postalCodeRule(),\n\t        value: '1999010301',\n\t        error: 'The dummy field must be a valid postal code',\n\t      },\n\t      {\n\t        rule: postalCodeRule(),\n\t        value: '110001',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: postalCodeRule({ countryCode: ['US'] }),\n\t        value: '110001',\n\t        error: 'The dummy field must be a valid postal code',\n\t      },\n\t      {\n\t        rule: postalCodeRule({ countryCode: ['US', 'IN'] }),\n\t        value: '110001',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: postalCodeRule(() => {}),\n\t        value: '1999010301',\n\t        error: 'The dummy field must be a valid postal code',\n\t      },\n\t      {\n\t        rule: postalCodeRule(() => {}),\n\t        value: '110001',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: postalCodeRule(() => {\n\t          return { countryCode: ['US'] }\n\t        }),\n\t        value: '110001',\n\t        error: 'The dummy field must be a valid postal code',\n\t      },\n\t      {\n\t        rule: postalCodeRule(() => {\n\t          return { countryCode: ['US', 'IN'] }\n", "        }),\n\t        value: '110001',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | uuid', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n", "        errorsCount: 1,\n\t        rule: uuidRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: uuidRule(),\n\t        value: 22,\n\t        bail: false,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: uuidRule(),\n\t        value: '1999010301',\n\t        error: 'The dummy field must be a valid UUID',\n\t      },\n\t      {\n\t        rule: uuidRule(),\n", "        value: '71e4fbab-3498-447b-a97c-2c6060069678',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: uuidRule({ version: [1] }),\n\t        value: '71e4fbab-3498-447b-a97c-2c6060069678',\n\t        error: 'The dummy field must be a valid UUID',\n\t      },\n\t      {\n\t        rule: uuidRule({ version: [1, 4] }),\n", "        value: '71e4fbab-3498-447b-a97c-2c6060069678',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | ascii', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n", "        rule: asciiRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: asciiRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: asciiRule(),\n\t        value: '456',\n\t        error: 'The dummy field must only contain ASCII characters',\n\t      },\n\t      {\n\t        rule: asciiRule(),\n\t        value: 'foobar',\n", "      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | iban', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: ibanRule(),\n", "        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: ibanRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n", "      {\n\t        errorsCount: 1,\n\t        rule: ibanRule(),\n\t        value: 'foobar',\n\t        error: 'The dummy field must be a valid IBAN number',\n\t      },\n\t      {\n\t        rule: ibanRule(),\n\t        value: 'GB94BARC10201530093459',\n\t      },\n", "    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | jwt', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: jwtRule(),\n\t        value: 22,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: jwtRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: jwtRule(),\n\t        value: 'foobar',\n\t        error: 'The dummy field must be a valid JWT token',\n\t      },\n\t      {\n\t        rule: jwtRule(),\n\t        value:\n\t          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c',\n\t      },\n", "    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | coordinates', () => {\n\t  test('validate {value}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: coordinatesRule(),\n\t        value: 22,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: coordinatesRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: coordinatesRule(),\n\t        value: 'helloworld',\n\t        error: 'The dummy field must contain latitude and longitude coordinates',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: coordinatesRule(),\n\t        value: 'hello,world',\n\t        error: 'The dummy field must contain latitude and longitude coordinates',\n", "      },\n\t      {\n\t        rule: coordinatesRule(),\n\t        value: '(7.264394, 165.058594)',\n\t      },\n\t      {\n\t        rule: coordinatesRule(),\n\t        value: '7.264394,165.058594',\n\t      },\n\t    ])\n", "    .run(stringRuleValidator)\n\t})\n\ttest.group('String | toUpperCase', () => {\n\t  test('convert {value} to {output}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: toUpperCaseRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n", "      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: toUpperCaseRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        rule: toUpperCaseRule(),\n", "        value: 'hello world',\n\t        output: 'HELLO WORLD',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | toLowerCase', () => {\n\t  test('convert {value} to {output}')\n\t    .with([\n\t      {\n", "        errorsCount: 1,\n\t        rule: toLowerCaseRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: toLowerCaseRule(),\n\t        value: 22,\n\t        bail: false,\n", "        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        rule: toLowerCaseRule(),\n\t        value: 'HELLO WORLD',\n\t        output: 'hello world',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n", "test.group('String | toCamelCase', () => {\n\t  test('convert {value} to {output}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: toCamelCaseRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n", "        errorsCount: 1,\n\t        rule: toCamelCaseRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        rule: toCamelCaseRule(),\n\t        value: 'HELLO WORLD',\n\t        output: 'helloWorld',\n", "      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | escape', () => {\n\t  test('convert {value} to {output}')\n\t    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: escapeRule(),\n", "        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: escapeRule(),\n\t        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n", "      {\n\t        rule: escapeRule(),\n\t        value: '<h1> Hello world </h1>',\n\t        output: '&lt;h1&gt; Hello world &lt;&#x2F;h1&gt;',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n\ttest.group('String | normalizeUrl', () => {\n\t  test('convert {value} to {output}')\n", "    .with([\n\t      {\n\t        errorsCount: 1,\n\t        rule: normalizeUrlRule(),\n\t        value: 22,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        errorsCount: 1,\n\t        rule: normalizeUrlRule(),\n", "        value: 22,\n\t        bail: false,\n\t        error: 'The dummy field must be a string',\n\t      },\n\t      {\n\t        rule: normalizeUrlRule(),\n\t        value: 'foobar',\n\t        output: 'http://foobar',\n\t      },\n\t      {\n", "        rule: normalizeUrlRule({ stripWWW: true }),\n\t        value: 'www.foo.com',\n\t        output: 'http://foo.com',\n\t      },\n\t    ])\n\t    .run(stringRuleValidator)\n\t})\n"]}
{"filename": "tests/unit/rules/literal.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validator } from '../../../factories/main.js'\n", "import { equalsRule } from '../../../src/schema/literal/rules.js'\n\ttest.group('Literal | equals', () => {\n\t  test('report when input value is not same as expected value', () => {\n\t    const equals = equalsRule({ expectedValue: 1 })\n\t    const validated = validator.execute(equals, 'foo')\n\t    validated.assertError('The dummy field must be 1')\n\t  })\n\t  test('pass when input value is same as expected value', () => {\n\t    const equals = equalsRule({ expectedValue: 1 })\n\t    const validated = validator.execute(equals, 1)\n", "    validated.assertSucceeded()\n\t    validated.assertOutput(1)\n\t  })\n\t  test('normalize input value when expected value is a number', () => {\n\t    const equals = equalsRule({ expectedValue: 1 })\n\t    const validated = validator.execute(equals, '1')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput(1)\n\t  })\n\t  test('normalize input value when expected value is a boolean', () => {\n", "    const equals = equalsRule({ expectedValue: false })\n\t    const validated = validator.execute(equals, 'false')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput(false)\n\t    const equals1 = equalsRule({ expectedValue: true })\n\t    const validated1 = validator.execute(equals1, 'true')\n\t    validated1.assertSucceeded()\n\t    validated1.assertOutput(true)\n\t  })\n\t})\n"]}
{"filename": "tests/unit/rules/record.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validator } from '../../../factories/main.js'\n", "import {\n\t  maxLengthRule,\n\t  minLengthRule,\n\t  fixedLengthRule,\n\t  validateKeysRule,\n\t} from '../../../src/schema/record/rules.js'\n\ttest.group('Record | minLength', () => {\n\t  test('skip when field is invalid', () => {\n\t    const minLength = minLengthRule({ min: 2 })\n\t    const validated = validator.withContext({ isValid: false }).execute(minLength, 'foo')\n", "    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('skip when field is invalid and bail mode is disabled', () => {\n\t    const minLength = minLengthRule({ min: 2 })\n\t    const validated = validator\n\t      .withContext({ isValid: false })\n\t      .bail(false)\n\t      .execute(minLength, 'foo')\n\t    validated.assertSucceeded()\n", "    validated.assertOutput('foo')\n\t  })\n\t  test('report when object length is less than the expected length', () => {\n\t    const minLength = minLengthRule({ min: 2 })\n\t    const validated = validator.execute(minLength, { foo: 'bar' })\n\t    validated.assertError('The dummy field must have at least 2 items')\n\t  })\n\t  test('pass validation when length is same or greater than expected length', () => {\n\t    const minLength = minLengthRule({ min: 2 })\n\t    const validated = validator.execute(minLength, { foo: 'bar', bar: 'baz' })\n", "    validated.assertSucceeded()\n\t    validated.assertOutput({ foo: 'bar', bar: 'baz' })\n\t    const validated1 = validator.execute(minLength, { foo: 'bar', bar: 'baz', baz: 'foo' })\n\t    validated1.assertSucceeded()\n\t    validated1.assertOutput({ foo: 'bar', bar: 'baz', baz: 'foo' })\n\t  })\n\t})\n\ttest.group('Record | maxLength', () => {\n\t  test('skip when field is invalid', () => {\n\t    const maxLength = maxLengthRule({ max: 2 })\n", "    const validated = validator.withContext({ isValid: false }).execute(maxLength, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('skip when field is invalid and bail mode is disabled', () => {\n\t    const maxLength = maxLengthRule({ max: 2 })\n\t    const validated = validator\n\t      .withContext({ isValid: false })\n\t      .bail(false)\n\t      .execute(maxLength, 'foo')\n", "    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('report when object length is greater than the expected length', () => {\n\t    const maxLength = maxLengthRule({ max: 2 })\n\t    const validated = validator.execute(maxLength, { foo: 'bar', bar: 'baz', baz: 'foo' })\n\t    validated.assertError('The dummy field must not have more than 2 items')\n\t  })\n\t  test('pass validation when length is same or less than expected length', () => {\n\t    const maxLength = maxLengthRule({ max: 2 })\n", "    const validated = validator.execute(maxLength, { foo: 'bar', bar: 'baz' })\n\t    validated.assertSucceeded()\n\t    validated.assertOutput({ foo: 'bar', bar: 'baz' })\n\t    const validated1 = validator.execute(maxLength, { foo: 'bar' })\n\t    validated1.assertSucceeded()\n\t    validated1.assertOutput({ foo: 'bar' })\n\t  })\n\t})\n\ttest.group('Record | fixedLength', () => {\n\t  test('skip when field is invalid', () => {\n", "    const fixedLength = fixedLengthRule({ size: 2 })\n\t    const validated = validator.withContext({ isValid: false }).execute(fixedLength, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('skip when field is invalid and bail mode is disabled', () => {\n\t    const fixedLength = fixedLengthRule({ size: 2 })\n\t    const validated = validator\n\t      .withContext({ isValid: false })\n\t      .bail(false)\n", "      .execute(fixedLength, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('report when object length is greater than the expected length', () => {\n\t    const fixedLength = fixedLengthRule({ size: 2 })\n\t    const validated = validator.execute(fixedLength, { foo: 'bar', bar: 'baz', baz: 'foo' })\n\t    validated.assertError('The dummy field must contain 2 items')\n\t  })\n\t  test('report when object length is less than the expected length', () => {\n", "    const fixedLength = fixedLengthRule({ size: 2 })\n\t    const validated = validator.execute(fixedLength, { foo: 'bar' })\n\t    validated.assertError('The dummy field must contain 2 items')\n\t  })\n\t  test('pass validation when length is same as the expected length', () => {\n\t    const maxLength = fixedLengthRule({ size: 2 })\n\t    const validated = validator.execute(maxLength, { foo: 'bar', bar: 'baz' })\n\t    validated.assertSucceeded()\n\t    validated.assertOutput({ foo: 'bar', bar: 'baz' })\n\t  })\n", "})\n\ttest.group('Record | validateKeys', () => {\n\t  test('skip when field is invalid', () => {\n\t    const validateKeys = validateKeysRule(() => {\n\t      throw new Error('Never expected to be invoked')\n\t    })\n\t    const validated = validator.withContext({ isValid: false }).execute(validateKeys, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n", "  test('skip when field is invalid and bail mode is disabled', () => {\n\t    const validateKeys = validateKeysRule(() => {\n\t      throw new Error('Never expected to be invoked')\n\t    })\n\t    const validated = validator\n\t      .withContext({ isValid: false })\n\t      .bail(false)\n\t      .execute(validateKeys, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n", "  })\n\t  test('invoke callback and pass object keys to it', ({ assert }) => {\n\t    assert.plan(1)\n\t    const validateKeys = validateKeysRule((keys) => {\n\t      assert.deepEqual(keys, ['foo', 'bar', 'baz'])\n\t    })\n\t    const validated = validator.execute(validateKeys, {\n\t      foo: 'bar',\n\t      bar: 'baz',\n\t      baz: 'foo',\n", "    })\n\t    validated.assertSucceeded()\n\t    validated.assertOutput({\n\t      foo: 'bar',\n\t      bar: 'baz',\n\t      baz: 'foo',\n\t    })\n\t  })\n\t  test('fail validation when validate keys reports an error', () => {\n\t    const validateKeys = validateKeysRule((_, field) => {\n", "      field.report('Invalid keys', 'record.keys', field)\n\t    })\n\t    const validated = validator.execute(validateKeys, {\n\t      foo: 'bar',\n\t      bar: 'baz',\n\t      baz: 'foo',\n\t    })\n\t    validated.assertErrorsCount(1)\n\t    validated.assertError('Invalid keys')\n\t  })\n", "})\n"]}
{"filename": "tests/unit/rules/boolean.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validator } from '../../../factories/main.js'\n", "import { booleanRule } from '../../../src/schema/boolean/rules.js'\n\ttest.group('Boolean | boolean', () => {\n\t  test('report when value is not a boolean', () => {\n\t    const boolean = booleanRule({})\n\t    const validated = validator.execute(boolean, 'foo')\n\t    validated.assertError('The value must be a boolean')\n\t  })\n\t  test('pass validation when value is a boolean', () => {\n\t    const boolean = booleanRule({})\n\t    const withTrue = validator.execute(boolean, true)\n", "    withTrue.assertSucceeded()\n\t    withTrue.assertOutput(true)\n\t    const withFalse = validator.execute(boolean, false)\n\t    withFalse.assertSucceeded()\n\t    withFalse.assertOutput(false)\n\t    const withZero = validator.execute(boolean, 0)\n\t    withZero.assertSucceeded()\n\t    withZero.assertOutput(false)\n\t    const withOne = validator.execute(boolean, 1)\n\t    withOne.assertSucceeded()\n", "    withOne.assertOutput(true)\n\t  })\n\t  test('pass validation when value is a string representation of boolean', () => {\n\t    const boolean = booleanRule({})\n\t    const withTrue = validator.execute(boolean, 'true')\n\t    withTrue.assertSucceeded()\n\t    withTrue.assertOutput(true)\n\t    const withFalse = validator.execute(boolean, 'false')\n\t    withFalse.assertSucceeded()\n\t    withFalse.assertOutput(false)\n", "    const withZero = validator.execute(boolean, '0')\n\t    withZero.assertSucceeded()\n\t    withZero.assertOutput(false)\n\t    const withOne = validator.execute(boolean, '1')\n\t    withOne.assertSucceeded()\n\t    withOne.assertOutput(true)\n\t  })\n\t  test('disallow string representation in strict mode', () => {\n\t    const boolean = booleanRule({ strict: true })\n\t    const withTrue = validator.execute(boolean, 'true')\n", "    withTrue.assertError('The value must be a boolean')\n\t    const withFalse = validator.execute(boolean, 'false')\n\t    withFalse.assertError('The value must be a boolean')\n\t    const withZero = validator.execute(boolean, '0')\n\t    withZero.assertError('The value must be a boolean')\n\t    const withOne = validator.execute(boolean, '1')\n\t    withOne.assertError('The value must be a boolean')\n\t  })\n\t  test('report when value is a number other than 0 or 1', () => {\n\t    const boolean = booleanRule({})\n", "    const validated = validator.execute(boolean, 2)\n\t    validated.assertError('The value must be a boolean')\n\t  })\n\t})\n"]}
{"filename": "tests/unit/rules/array.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validator } from '../../../factories/main.js'\n", "import {\n\t  compactRule,\n\t  distinctRule,\n\t  notEmptyRule,\n\t  maxLengthRule,\n\t  minLengthRule,\n\t  fixedLengthRule,\n\t} from '../../../src/schema/array/rules.js'\n\ttest.group('Array | minLength', () => {\n\t  test('skip when field is invalid', () => {\n", "    const minLength = minLengthRule({ min: 2 })\n\t    const validated = validator.withContext({ isValid: false }).execute(minLength, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('skip when field is invalid and bail mode is disabled', () => {\n\t    const minLength = minLengthRule({ min: 2 })\n\t    const validated = validator\n\t      .withContext({ isValid: false })\n\t      .bail(false)\n", "      .execute(minLength, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('report when array length is less than the expected length', () => {\n\t    const minLength = minLengthRule({ min: 2 })\n\t    const validated = validator.execute(minLength, ['foo'])\n\t    validated.assertError('The dummy field must have at least 2 items')\n\t  })\n\t  test('pass validation when length is same or greater than expected length', () => {\n", "    const minLength = minLengthRule({ min: 2 })\n\t    const validated = validator.execute(minLength, ['foo', 'bar'])\n\t    validated.assertSucceeded()\n\t    validated.assertOutput(['foo', 'bar'])\n\t    const validated1 = validator.execute(minLength, ['foo', 'bar', 'baz'])\n\t    validated1.assertSucceeded()\n\t    validated1.assertOutput(['foo', 'bar', 'baz'])\n\t  })\n\t})\n\ttest.group('Array | maxLength', () => {\n", "  test('skip when field is invalid', () => {\n\t    const maxLength = maxLengthRule({ max: 2 })\n\t    const validated = validator.withContext({ isValid: false }).execute(maxLength, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('skip when field is invalid and bail mode is disabled', () => {\n\t    const maxLength = maxLengthRule({ max: 2 })\n\t    const validated = validator\n\t      .withContext({ isValid: false })\n", "      .bail(false)\n\t      .execute(maxLength, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('report when array length is greater than the expected length', () => {\n\t    const maxLength = maxLengthRule({ max: 2 })\n\t    const validated = validator.execute(maxLength, ['foo', 'bar', 'baz'])\n\t    validated.assertError('The dummy field must not have more than 2 items')\n\t  })\n", "  test('pass validation when length is same or less than expected length', () => {\n\t    const maxLength = maxLengthRule({ max: 2 })\n\t    const validated = validator.execute(maxLength, ['foo', 'bar'])\n\t    validated.assertSucceeded()\n\t    validated.assertOutput(['foo', 'bar'])\n\t    const validated1 = validator.execute(maxLength, ['foo'])\n\t    validated1.assertSucceeded()\n\t    validated1.assertOutput(['foo'])\n\t  })\n\t})\n", "test.group('Array | fixedLength', () => {\n\t  test('skip when field is invalid', () => {\n\t    const fixedLength = fixedLengthRule({ size: 2 })\n\t    const validated = validator.withContext({ isValid: false }).execute(fixedLength, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('skip when field is invalid and bail mode is disabled', () => {\n\t    const fixedLength = fixedLengthRule({ size: 2 })\n\t    const validated = validator\n", "      .withContext({ isValid: false })\n\t      .bail(false)\n\t      .execute(fixedLength, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('report when array length is greater than the expected length', () => {\n\t    const fixedLength = fixedLengthRule({ size: 2 })\n\t    const validated = validator.execute(fixedLength, ['foo', 'bar', 'baz'])\n\t    validated.assertError('The dummy field must contain 2 items')\n", "  })\n\t  test('report when array length is less than the expected length', () => {\n\t    const fixedLength = fixedLengthRule({ size: 2 })\n\t    const validated = validator.execute(fixedLength, ['foo'])\n\t    validated.assertError('The dummy field must contain 2 items')\n\t  })\n\t  test('pass validation when length is same as the expected length', () => {\n\t    const maxLength = fixedLengthRule({ size: 2 })\n\t    const validated = validator.execute(maxLength, ['foo', 'bar'])\n\t    validated.assertSucceeded()\n", "    validated.assertOutput(['foo', 'bar'])\n\t  })\n\t})\n\ttest.group('Array | notEmpty', () => {\n\t  test('skip when field is invalid', () => {\n\t    const notEmpty = notEmptyRule()\n\t    const validated = validator.withContext({ isValid: false }).execute(notEmpty, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n", "  test('skip when field is invalid and bail mode is disabled', () => {\n\t    const notEmpty = notEmptyRule()\n\t    const validated = validator.withContext({ isValid: false }).bail(false).execute(notEmpty, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('report when array is empty', () => {\n\t    const notEmpty = notEmptyRule()\n\t    const validated = validator.execute(notEmpty, [])\n\t    validated.assertError('The dummy field must not be empty')\n", "  })\n\t  test('pass validation when array has one or more items', () => {\n\t    const notEmpty = notEmptyRule()\n\t    const validated = validator.execute(notEmpty, ['foo', 'bar'])\n\t    validated.assertSucceeded()\n\t    validated.assertOutput(['foo', 'bar'])\n\t  })\n\t})\n\ttest.group('Array | distinct', () => {\n\t  test('skip when field is invalid', () => {\n", "    const distinct = distinctRule({})\n\t    const validated = validator.withContext({ isValid: false }).execute(distinct, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('skip when field is invalid and bail mode is disabled', () => {\n\t    const distinct = distinctRule({})\n\t    const validated = validator.withContext({ isValid: false }).bail(false).execute(distinct, 'foo')\n\t    validated.assertSucceeded()\n\t    validated.assertOutput('foo')\n", "  })\n\t  test('pass validation when array is empty', () => {\n\t    const distinct = distinctRule({})\n\t    const validated = validator.execute(distinct, [])\n\t    validated.assertSucceeded()\n\t  })\n\t  test('pass validation when array has unique items', () => {\n\t    const distinct = distinctRule({})\n\t    const validated = validator.execute(distinct, ['foo', 'bar', 'baz'])\n\t    validated.assertSucceeded()\n", "    const validated1 = validator.execute(distinct, [11, 12, 13])\n\t    validated1.assertSucceeded()\n\t    const validated2 = validator.execute(distinct, [true, false])\n\t    validated2.assertSucceeded()\n\t  })\n\t  test('report error when array has duplicates', () => {\n\t    const distinct = distinctRule({})\n\t    const validated = validator.execute(distinct, ['foo', 'bar', 'foo'])\n\t    validated.assertError('The dummy field has duplicate values')\n\t    const validated1 = validator.execute(distinct, [11, 12, 11])\n", "    validated1.assertError('The dummy field has duplicate values')\n\t    const validated2 = validator.execute(distinct, [true, true])\n\t    validated2.assertError('The dummy field has duplicate values')\n\t  })\n\t  test('pass validation when array of objects have unique items', () => {\n\t    const distinct = distinctRule({ fields: 'email' })\n\t    const validated = validator.execute(distinct, [\n\t      {\n\t        email: 'foo@bar.com',\n\t      },\n", "      {\n\t        email: 'baz@bar.com',\n\t      },\n\t    ])\n\t    validated.assertSucceeded()\n\t  })\n\t  test('report error when array of objects has duplicate items', () => {\n\t    const distinct = distinctRule({ fields: 'email' })\n\t    const validated = validator.execute(distinct, [\n\t      {\n", "        email: 'foo@bar.com',\n\t      },\n\t      {\n\t        email: 'foo@bar.com',\n\t      },\n\t    ])\n\t    validated.assertError('The dummy field has duplicate values')\n\t  })\n\t  test('pass validation when object has unique items for a composite key', () => {\n\t    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n", "    const validated = validator.execute(distinct, [\n\t      {\n\t        email: 'foo@bar.com',\n\t        company_id: 1,\n\t      },\n\t      {\n\t        email: 'foo@bar.com',\n\t        company_id: 2,\n\t      },\n\t    ])\n", "    validated.assertSucceeded()\n\t  })\n\t  test('report error when object has duplicate items for a composite key', () => {\n\t    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n\t    const validated = validator.execute(distinct, [\n\t      {\n\t        email: 'foo@bar.com',\n\t        company_id: 1,\n\t      },\n\t      {\n", "        email: 'foo@bar.com',\n\t        company_id: 1,\n\t      },\n\t    ])\n\t    validated.assertError('The dummy field has duplicate values')\n\t  })\n\t  test('skip when one or more fields are missing in objects', () => {\n\t    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n\t    const validated = validator.execute(distinct, [\n\t      {\n", "        email: 'foo@bar.com',\n\t      },\n\t      {\n\t        email: 'foo@bar.com',\n\t      },\n\t    ])\n\t    validated.assertSucceeded()\n\t  })\n\t  test('skip when array elements are not objects', () => {\n\t    const distinct = distinctRule({ fields: ['email', 'company_id'] })\n", "    const validated = validator.execute(distinct, [\n\t      {\n\t        email: 'foo@bar.com',\n\t      },\n\t      'foo@bar.com',\n\t    ])\n\t    validated.assertSucceeded()\n\t  })\n\t})\n\ttest.group('Array | compact', () => {\n", "  test('skip when field is invalid', () => {\n\t    const compact = compactRule()\n\t    const validated = validator.withContext({ isValid: false }).execute(compact, 'foo')\n\t    validated.assertOutput('foo')\n\t  })\n\t  test('skip when field is invalid and bail mode is disabled', () => {\n\t    const compact = compactRule()\n\t    const validated = validator.withContext({ isValid: false }).bail(false).execute(compact, 'foo')\n\t    validated.assertOutput('foo')\n\t  })\n", "  test('remove empty strings null and undefined values', () => {\n\t    const compact = compactRule()\n\t    const validated = validator.execute(compact, [\n\t      'foo',\n\t      'bar',\n\t      '',\n\t      null,\n\t      undefined,\n\t      'baz',\n\t      null,\n", "      true,\n\t      false,\n\t      1,\n\t      0,\n\t    ])\n\t    validated.assertOutput(['foo', 'bar', 'baz', true, false, 1, 0])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/number.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { Vine } from '../../../src/vine/main.js'\n\timport { IS_OF_TYPE, PARSE } from '../../../src/symbols.js'\n\timport {\n\t  maxRule,\n\t  minRule,\n\t  rangeRule,\n\t  decimalRule,\n\t  negativeRule,\n\t  positiveRule,\n\t  withoutDecimalsRule,\n", "} from '../../../src/schema/number/rules.js'\n\tconst vine = new Vine()\n\ttest.group('VineNumber', () => {\n\t  test('create number schema', ({ assert }) => {\n\t    const schema = vine.number()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.number().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n", "  })\n\t  test('apply optional modifier', ({ assert }) => {\n\t    const schema = vine.number().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n", "  test('disable bail mode', ({ assert }) => {\n\t    const schema = vine.number().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply rules', ({ assert }) => {\n", "    const schema = vine.number().bail(false).min(10).max(20)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://3',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply transformer', ({ assert }) => {\n\t    const schema = vine.number().transform(() => {})\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply parser', ({ assert }) => {\n\t    const schema = vine.number().parse(() => {})\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('check if value is a number using IS_OF_TYPE method', ({ assert }) => {\n\t    const schema = vine.number()\n\t    assert.isTrue(schema[IS_OF_TYPE]('1'))\n", "    assert.isTrue(schema[IS_OF_TYPE]('0'))\n\t    assert.isTrue(schema[IS_OF_TYPE](1))\n\t    assert.isTrue(schema[IS_OF_TYPE]('9.99'))\n\t    assert.isFalse(schema[IS_OF_TYPE]('foo'))\n\t    assert.isFalse(schema[IS_OF_TYPE](undefined))\n\t    assert.isFalse(schema[IS_OF_TYPE](null))\n\t    assert.isFalse(schema[IS_OF_TYPE]({}))\n\t  })\n\t})\n\ttest.group('VineNumber | clone', () => {\n", "  test('clone number schema', ({ assert }) => {\n\t    const schema = vine.number()\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n", "          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.number()\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n", "          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const schema = vine.number()\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n\t    const schema = vine.number()\n", "    const schema1 = schema.clone().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply rules', ({ assert }) => {\n\t    const schema = vine.number().bail(false).min(10)\n\t    const schema1 = schema.clone().max(20)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://3',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply transformer', ({ assert }) => {\n\t    const schema = vine.number()\n\t    const schema1 = schema.clone().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('clone and apply parser', ({ assert }) => {\n\t    const schema = vine.number()\n\t    const schema1 = schema.clone().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t})\n\ttest.group('VineNumber | applying rules', () => {\n", "  test('apply min rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.number().min(18)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t    const min = minRule({ min: 18 })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: min.rule.validator,\n\t      options: min.options,\n\t    })\n\t  })\n", "  test('apply max rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.number().max(18)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t    const max = maxRule({ max: 18 })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: max.rule.validator,\n\t      options: max.options,\n\t    })\n\t  })\n", "  test('apply range rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.number().range([18, 60])\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t    const range = rangeRule({ min: 18, max: 60 })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: range.rule.validator,\n\t      options: range.options,\n\t    })\n\t  })\n", "  test('apply positive rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.number().positive()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t    const positive = positiveRule()\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: positive.rule.validator,\n\t      options: positive.options,\n\t    })\n\t  })\n", "  test('apply negative rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.number().negative()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t    const negative = negativeRule()\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: negative.rule.validator,\n\t      options: negative.options,\n\t    })\n\t  })\n", "  test('apply decimal rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.number().decimal([0, 2])\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t    const decimal = decimalRule({ range: [0, 2] })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: decimal.rule.validator,\n\t      options: decimal.options,\n\t    })\n\t  })\n", "  test('apply decimal rule with fixed value', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.number().decimal(2)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t    const decimal = decimalRule({ range: [2] })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: decimal.rule.validator,\n\t      options: decimal.options,\n\t    })\n\t  })\n", "  test('apply withoutDecimals rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.number().withoutDecimals()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t    const withoutDecimals = withoutDecimalsRule()\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: withoutDecimals.rule.validator,\n\t      options: withoutDecimals.options,\n\t    })\n\t  })\n", "})\n"]}
{"filename": "tests/unit/schema/enum.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { PARSE } from '../../../src/symbols.js'\n\timport { Vine } from '../../../src/vine/main.js'\n\tconst vine = new Vine()\n\ttest.group('VineEnum', () => {\n\t  test('create enum schema', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator'])\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator']).nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('apply optional modifier', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator']).optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n", "  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator']).bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n", "  test('apply transformer', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator']).transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n", "  test('apply parser', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator']).parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t})\n", "test.group('VineEnum | clone', () => {\n\t  test('clone enum schema', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator'])\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator'])\n\t    const schema1 = schema.clone().nullable()\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator'])\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n", "    const schema = vine.enum(['guest', 'admin', 'moderator'])\n\t    const schema1 = schema.clone().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply transformer', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator'])\n\t    const schema1 = schema.clone().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('clone and apply parser', ({ assert }) => {\n\t    const schema = vine.enum(['guest', 'admin', 'moderator'])\n\t    const schema1 = schema.clone().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/string.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { Vine } from '../../../src/vine/main.js'\n\timport { RuleBuilder } from '../../../src/types.js'\n\timport { createRule } from '../../../src/vine/create_rule.js'\n\timport { IS_OF_TYPE, PARSE, VALIDATION } from '../../../src/symbols.js'\n\timport {\n\t  inRule,\n\t  urlRule,\n\t  emailRule,\n\t  trimRule,\n\t  alphaRule,\n", "  notInRule,\n\t  regexRule,\n\t  sameAsRule,\n\t  endsWithRule,\n\t  notSameAsRule,\n\t  ipAddressRule,\n\t  confirmedRule,\n\t  activeUrlRule,\n\t  maxLengthRule,\n\t  minLengthRule,\n", "  startsWithRule,\n\t  fixedLengthRule,\n\t  alphaNumericRule,\n\t  normalizeEmailRule,\n\t  creditCardRule,\n\t  passportRule,\n\t  postalCodeRule,\n\t  uuidRule,\n\t  asciiRule,\n\t  ibanRule,\n", "  jwtRule,\n\t  coordinatesRule,\n\t  toUpperCaseRule,\n\t  toLowerCaseRule,\n\t  toCamelCaseRule,\n\t  escapeRule,\n\t  normalizeUrlRule,\n\t  mobileRule,\n\t} from '../../../src/schema/string/rules.js'\n\tconst vine = new Vine()\n", "test.group('VineString', () => {\n\t  test('create string schema', ({ assert }) => {\n\t    const schema = vine.string()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n", "  test('apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.string().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply optional modifier', ({ assert }) => {\n", "    const schema = vine.string().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const schema = vine.string().bail(false)\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply transformer', ({ assert }) => {\n\t    const schema = vine.string().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('check if value is an object using IS_OF_TYPE method', ({ assert }) => {\n\t    const schema = vine.string()\n\t    assert.isTrue(schema[IS_OF_TYPE](''))\n", "    assert.isFalse(schema[IS_OF_TYPE]({}))\n\t    assert.isFalse(schema[IS_OF_TYPE](null))\n\t    assert.isFalse(schema[IS_OF_TYPE](undefined))\n\t    assert.isFalse(schema[IS_OF_TYPE]([]))\n\t    assert.isFalse(schema[IS_OF_TYPE](1))\n\t  })\n\t})\n\ttest.group('VineString | clone', () => {\n\t  test('clone string schema', ({ assert }) => {\n\t    const schema = vine.string()\n", "    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.string()\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n", "  test('clone and apply optional modifier', ({ assert }) => {\n\t    const schema = vine.string()\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n", "          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n\t    const schema = vine.string()\n\t    const schema1 = schema.clone().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n", "          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('clone and apply transformer', ({ assert }) => {\n\t    const schema = vine.string()\n\t    const schema1 = schema.clone().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply nullable modifier and clone', ({ assert }) => {\n", "    const schema = vine.string().nullable()\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply optional modifier and clone', ({ assert }) => {\n\t    const schema = vine.string().optional()\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: true,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n", "  })\n\t  test('apply transform modifier and clone', ({ assert }) => {\n\t    const schema = vine.string().transform(() => {})\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t})\n", "test.group('VineString | applying rules', () => {\n\t  test('register rule via rule builder', ({ assert }) => {\n\t    const passwordRule = createRule(() => {})\n\t    class Password implements RuleBuilder {\n\t      [VALIDATION]() {\n\t        return passwordRule()\n\t      }\n\t    }\n\t    const refs = refsBuilder()\n\t    const password = new Password()\n", "    const schema = vine.string().use(password)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n", "      ],\n\t    })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: passwordRule().rule.validator,\n\t      options: passwordRule().options,\n\t    })\n\t  })\n\t  test('apply {name} rule via schema API')\n\t    .with([\n\t      {\n", "        name: 'email',\n\t        schema: vine.string().email(),\n\t        rule: emailRule(),\n\t      },\n\t      {\n\t        name: 'regex',\n\t        schema: vine.string().regex(/^[a-zA-Z0-9]+$/),\n\t        rule: regexRule(/^[a-zA-Z0-9]+$/),\n\t      },\n\t      {\n", "        name: 'url',\n\t        schema: vine.string().url(),\n\t        rule: urlRule(),\n\t      },\n\t      {\n\t        name: 'activeUrl',\n\t        schema: vine.string().activeUrl(),\n\t        rule: activeUrlRule(),\n\t      },\n\t      {\n", "        name: 'alpha',\n\t        schema: vine.string().alpha(),\n\t        rule: alphaRule(),\n\t      },\n\t      {\n\t        name: 'mobile',\n\t        schema: vine.string().mobile(),\n\t        rule: mobileRule(),\n\t      },\n\t      {\n", "        name: 'alphaNumeric',\n\t        schema: vine.string().alphaNumeric(),\n\t        rule: alphaNumericRule(),\n\t      },\n\t      {\n\t        name: 'maxLength',\n\t        schema: vine.string().maxLength(10),\n\t        rule: maxLengthRule({ max: 10 }),\n\t      },\n\t      {\n", "        name: 'minLength',\n\t        schema: vine.string().minLength(10),\n\t        rule: minLengthRule({ min: 10 }),\n\t      },\n\t      {\n\t        name: 'fixedLength',\n\t        schema: vine.string().fixedLength(10),\n\t        rule: fixedLengthRule({ size: 10 }),\n\t      },\n\t      {\n", "        name: 'confirmed',\n\t        schema: vine.string().confirmed(),\n\t        rule: confirmedRule(),\n\t      },\n\t      {\n\t        name: 'trim',\n\t        schema: vine.string().trim(),\n\t        rule: trimRule(),\n\t      },\n\t      {\n", "        name: 'normalizeEmail',\n\t        schema: vine.string().normalizeEmail(),\n\t        rule: normalizeEmailRule(),\n\t      },\n\t      {\n\t        name: 'startsWith',\n\t        schema: vine.string().startsWith('foo'),\n\t        rule: startsWithRule({ substring: 'foo' }),\n\t      },\n\t      {\n", "        name: 'endsWith',\n\t        schema: vine.string().endsWith('foo'),\n\t        rule: endsWithRule({ substring: 'foo' }),\n\t      },\n\t      {\n\t        name: 'sameAs',\n\t        schema: vine.string().sameAs('password'),\n\t        rule: sameAsRule({ otherField: 'password' }),\n\t      },\n\t      {\n", "        name: 'notSameAs',\n\t        schema: vine.string().notSameAs('password'),\n\t        rule: notSameAsRule({ otherField: 'password' }),\n\t      },\n\t      {\n\t        name: 'in',\n\t        schema: vine.string().in(['admin']),\n\t        rule: inRule({ choices: ['admin'] }),\n\t      },\n\t      {\n", "        name: 'notIn',\n\t        schema: vine.string().notIn(['admin']),\n\t        rule: notInRule({ list: ['admin'] }),\n\t      },\n\t      {\n\t        name: 'ipAddress',\n\t        schema: vine.string().ipAddress(),\n\t        rule: ipAddressRule(),\n\t      },\n\t      {\n", "        name: 'ipAddress',\n\t        schema: vine.string().ipAddress(4),\n\t        rule: ipAddressRule({ version: 4 }),\n\t      },\n\t      {\n\t        name: 'creditCard',\n\t        schema: vine.string().creditCard(),\n\t        rule: creditCardRule(),\n\t      },\n\t      {\n", "        name: 'passport',\n\t        schema: vine.string().passport({ countryCode: ['IN'] }),\n\t        rule: passportRule({ countryCode: ['IN'] }),\n\t      },\n\t      {\n\t        name: 'postalCode',\n\t        schema: vine.string().postalCode({ countryCode: ['IN'] }),\n\t        rule: postalCodeRule({ countryCode: ['IN'] }),\n\t      },\n\t      {\n", "        name: 'uuid',\n\t        schema: vine.string().uuid(),\n\t        rule: uuidRule(),\n\t      },\n\t      {\n\t        name: 'ascii',\n\t        schema: vine.string().ascii(),\n\t        rule: asciiRule(),\n\t      },\n\t      {\n", "        name: 'iban',\n\t        schema: vine.string().iban(),\n\t        rule: ibanRule(),\n\t      },\n\t      {\n\t        name: 'jwt',\n\t        schema: vine.string().jwt(),\n\t        rule: jwtRule(),\n\t      },\n\t      {\n", "        name: 'coordinates',\n\t        schema: vine.string().coordinates(),\n\t        rule: coordinatesRule(),\n\t      },\n\t      {\n\t        name: 'toUpperCase',\n\t        schema: vine.string().toUpperCase(),\n\t        rule: toUpperCaseRule(),\n\t      },\n\t      {\n", "        name: 'toLowerCase',\n\t        schema: vine.string().toLowerCase(),\n\t        rule: toLowerCaseRule(),\n\t      },\n\t      {\n\t        name: 'toCamelCase',\n\t        schema: vine.string().toCamelCase(),\n\t        rule: toCamelCaseRule(),\n\t      },\n\t      {\n", "        name: 'escape',\n\t        schema: vine.string().escape(),\n\t        rule: escapeRule(),\n\t      },\n\t      {\n\t        name: 'normalizeUrl',\n\t        schema: vine.string().normalizeUrl(),\n\t        rule: normalizeUrlRule(),\n\t      },\n\t    ])\n", "    .run(({ assert }, { schema, rule }) => {\n\t      const refs = refsBuilder()\n\t      assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        bail: true,\n\t        parseFnId: undefined,\n", "        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n\t          {\n\t            implicit: false,\n\t            isAsync: rule.rule.isAsync,\n\t            ruleFnId: 'ref://2',\n", "          },\n\t        ],\n\t      })\n\t      assert.deepEqual(refs.toJSON()['ref://2'], {\n\t        validator: rule.rule.validator,\n\t        options: rule.options,\n\t      })\n\t    })\n\t})\n"]}
{"filename": "tests/unit/schema/any.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { PARSE } from '../../../src/symbols.js'\n\timport { Vine } from '../../../src/vine/main.js'\n\tconst vine = new Vine()\n\ttest.group('VineAny', () => {\n\t  test('create any schema', ({ assert }) => {\n\t    const schema = vine.any()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.any().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n\t  })\n", "  test('apply optional modifier', ({ assert }) => {\n\t    const schema = vine.any().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [],\n\t    })\n\t  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const schema = vine.any().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n\t  })\n\t  test('apply parser', ({ assert }) => {\n\t    const schema = vine.any().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [],\n\t    })\n\t  })\n\t  test('apply transformer', ({ assert }) => {\n", "    const schema = vine.any().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://1',\n", "      validations: [],\n\t    })\n\t  })\n\t})\n\ttest.group('VineAny | clone', () => {\n\t  test('clone any schema', ({ assert }) => {\n\t    const schema = vine.any()\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n", "    const schema = vine.any()\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [],\n\t    })\n\t  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const schema = vine.any()\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n\t    const schema = vine.any()\n\t    const schema1 = schema.clone().bail(false)\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n", "  })\n\t  test('clone and apply transformer', ({ assert }) => {\n\t    const schema = vine.any()\n\t    const schema1 = schema.clone().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://1',\n\t      validations: [],\n\t    })\n\t  })\n\t  test('clone and apply parser', ({ assert }) => {\n\t    const schema = vine.any()\n\t    const schema1 = schema.clone().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [],\n\t    })\n\t  })\n", "})\n"]}
{"filename": "tests/unit/schema/union.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { PARSE } from '../../../src/symbols.js'\n\timport { Vine } from '../../../src/vine/main.js'\n\tconst vine = new Vine()\n\ttest.group('Vine Union', () => {\n\t  test('construct union schema', ({ assert }) => {\n\t    const schema = vine.union([\n\t      vine.union.if(\n\t        (data) => data.type === 'stripe',\n\t        vine.object({\n\t          type: vine.literal('stripe'),\n", "          account_id: vine.string(),\n\t        })\n\t      ),\n\t      vine.union.if(\n\t        (data) => data.type === 'paypal',\n\t        vine.object({\n\t          type: vine.literal('paypal'),\n\t          email: vine.string(),\n\t        })\n\t      ),\n", "      vine.union.if(\n\t        (data) => data.type === 'open_collective',\n\t        vine.object({\n\t          type: vine.literal('open_collective'),\n\t          project_url: vine.string(),\n\t        })\n\t      ),\n\t    ])\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      conditions: [\n", "        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n", "                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://3',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n", "                fieldName: 'account_id',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'account_id',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://4',\n", "                  },\n\t                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n", "          conditionalFnRefId: 'ref://5',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n", "              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n", "                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://6',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'email',\n", "                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'email',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://7',\n\t                  },\n", "                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://8',\n", "          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n", "                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n", "                    isAsync: false,\n\t                    ruleFnId: 'ref://9',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'project_url',\n\t                isOptional: false,\n", "                parseFnId: undefined,\n\t                propertyName: 'project_url',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://10',\n\t                  },\n\t                ],\n", "              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t      ],\n\t      elseConditionalFnRefId: 'ref://1',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      type: 'union',\n\t    })\n\t  })\n\t  test('define callback schema using union.else', ({ assert }) => {\n\t    const schema = vine.union([\n\t      vine.union.if(\n\t        (data) => data.type === 'stripe',\n\t        vine.object({\n\t          type: vine.literal('stripe'),\n", "          account_id: vine.string(),\n\t        })\n\t      ),\n\t      vine.union.if(\n\t        (data) => data.type === 'paypal',\n\t        vine.object({\n\t          type: vine.literal('paypal'),\n\t          email: vine.string(),\n\t        })\n\t      ),\n", "      vine.union.else(\n\t        vine.object({\n\t          type: vine.literal('open_collective'),\n\t          project_url: vine.string(),\n\t        })\n\t      ),\n\t    ])\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      conditions: [\n\t        {\n", "          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n", "              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n", "                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://3',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'account_id',\n", "                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'account_id',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://4',\n\t                  },\n", "                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://5',\n", "          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n", "                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n", "                    isAsync: false,\n\t                    ruleFnId: 'ref://6',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'email',\n\t                isOptional: false,\n", "                parseFnId: undefined,\n\t                propertyName: 'email',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://7',\n\t                  },\n\t                ],\n", "              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://8',\n\t          schema: {\n", "            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n", "                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n", "                    ruleFnId: 'ref://9',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'project_url',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n", "                propertyName: 'project_url',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://10',\n\t                  },\n\t                ],\n\t              },\n", "            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t      ],\n\t      elseConditionalFnRefId: 'ref://1',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      type: 'union',\n\t    })\n\t  })\n\t  test('clone schema', ({ assert }) => {\n\t    const schema = vine.union([\n\t      vine.union.if(\n\t        (data) => data.type === 'stripe',\n\t        vine.object({\n\t          type: vine.literal('stripe'),\n\t          account_id: vine.string(),\n", "        })\n\t      ),\n\t      vine.union.if(\n\t        (data) => data.type === 'paypal',\n\t        vine.object({\n\t          type: vine.literal('paypal'),\n\t          email: vine.string(),\n\t        })\n\t      ),\n\t      vine.union.if(\n", "        (data) => data.type === 'open_collective',\n\t        vine.object({\n\t          type: vine.literal('open_collective'),\n\t          project_url: vine.string(),\n\t        })\n\t      ),\n\t    ])\n\t    const schema1 = schema.clone().otherwise(() => {})\n\t    const refs = refsBuilder()\n\t    const refs1 = refsBuilder()\n", "    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n", "                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://3',\n\t                  },\n\t                ],\n\t              },\n\t              {\n", "                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'account_id',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'account_id',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n", "                    isAsync: false,\n\t                    ruleFnId: 'ref://4',\n\t                  },\n\t                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n", "        },\n\t        {\n\t          conditionalFnRefId: 'ref://5',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n", "            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n", "                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://6',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n", "                bail: true,\n\t                fieldName: 'email',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'email',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n", "                    ruleFnId: 'ref://7',\n\t                  },\n\t                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n", "        {\n\t          conditionalFnRefId: 'ref://8',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n", "                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://9',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n", "                fieldName: 'project_url',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'project_url',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://10',\n", "                  },\n\t                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t      ],\n", "      elseConditionalFnRefId: 'ref://1',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      type: 'union',\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs1, { toCamelCase: false }), {\n\t      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n", "            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n", "                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n", "                    ruleFnId: 'ref://3',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'account_id',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n", "                propertyName: 'account_id',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://4',\n\t                  },\n\t                ],\n\t              },\n", "            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://5',\n\t          schema: {\n\t            allowNull: false,\n", "            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n", "                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://6',\n", "                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'email',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'email',\n", "                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://7',\n\t                  },\n\t                ],\n\t              },\n\t            ],\n", "            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://8',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n", "            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n", "                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://9',\n\t                  },\n", "                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'project_url',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'project_url',\n\t                type: 'literal',\n", "                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://10',\n\t                  },\n\t                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n", "            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t      ],\n\t      elseConditionalFnRefId: 'ref://1',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      type: 'union',\n\t    })\n", "    assert.notDeepEqual(refs.toJSON()['ref://1'], refs1.toJSON()['ref://1'])\n\t  })\n\t  test('apply camelcase transform to propertyName', ({ assert }) => {\n\t    const schema = vine.union([\n\t      vine.union.if(\n\t        (data) => data.type === 'stripe',\n\t        vine.object({\n\t          type: vine.literal('stripe'),\n\t          account_id: vine.string(),\n\t        })\n", "      ),\n\t      vine.union.if(\n\t        (data) => data.type === 'paypal',\n\t        vine.object({\n\t          type: vine.literal('paypal'),\n\t          email: vine.string(),\n\t        })\n\t      ),\n\t      vine.union.else(\n\t        vine.object({\n", "          type: vine.literal('open_collective'),\n\t          project_url: vine.string(),\n\t        })\n\t      ),\n\t    ])\n\t    assert.deepEqual(schema[PARSE]('fiscal_host', refsBuilder(), { toCamelCase: true }), {\n\t      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n", "            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: 'fiscal_host',\n\t            propertyName: 'fiscalHost',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n", "                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n", "                    isAsync: false,\n\t                    ruleFnId: 'ref://3',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'account_id',\n\t                isOptional: false,\n", "                parseFnId: undefined,\n\t                propertyName: 'accountId',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://4',\n\t                  },\n\t                ],\n", "              },\n\t            ],\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://5',\n\t          schema: {\n\t            allowNull: false,\n", "            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: 'fiscal_host',\n\t            propertyName: 'fiscalHost',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n", "                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n", "                    ruleFnId: 'ref://6',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'email',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n", "                propertyName: 'email',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://7',\n\t                  },\n\t                ],\n\t              },\n", "            ],\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://8',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n", "            bail: true,\n\t            fieldName: 'fiscal_host',\n\t            propertyName: 'fiscalHost',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n", "                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://9',\n", "                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'project_url',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'projectUrl',\n", "                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://10',\n\t                  },\n\t                ],\n\t              },\n\t            ],\n", "            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t      ],\n\t      elseConditionalFnRefId: 'ref://1',\n\t      fieldName: 'fiscal_host',\n\t      propertyName: 'fiscalHost',\n\t      type: 'union',\n\t    })\n", "  })\n\t  test('copy otherwise callback to the cloned schema', ({ assert }) => {\n\t    const schema = vine\n\t      .union([\n\t        vine.union.if(\n\t          (data) => data.type === 'stripe',\n\t          vine.object({\n\t            type: vine.literal('stripe'),\n\t            account_id: vine.string(),\n\t          })\n", "        ),\n\t        vine.union.if(\n\t          (data) => data.type === 'paypal',\n\t          vine.object({\n\t            type: vine.literal('paypal'),\n\t            email: vine.string(),\n\t          })\n\t        ),\n\t        vine.union.if(\n\t          (data) => data.type === 'open_collective',\n", "          vine.object({\n\t            type: vine.literal('open_collective'),\n\t            project_url: vine.string(),\n\t          })\n\t        ),\n\t      ])\n\t      .otherwise(() => {})\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      conditions: [\n", "        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n", "                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://3',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n", "                fieldName: 'account_id',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'account_id',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://4',\n", "                  },\n\t                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n", "          conditionalFnRefId: 'ref://5',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n", "              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n", "                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://6',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'email',\n", "                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'email',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://7',\n\t                  },\n", "                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://8',\n", "          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n", "                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n", "                    isAsync: false,\n\t                    ruleFnId: 'ref://9',\n\t                  },\n\t                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'project_url',\n\t                isOptional: false,\n", "                parseFnId: undefined,\n\t                propertyName: 'project_url',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://10',\n\t                  },\n\t                ],\n", "              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t      ],\n\t      elseConditionalFnRefId: 'ref://1',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      type: 'union',\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n", "            bail: true,\n\t            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n", "                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://3',\n\t                  },\n", "                ],\n\t              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'account_id',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'account_id',\n\t                type: 'literal',\n", "                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://4',\n\t                  },\n\t                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n", "            type: 'object',\n\t            validations: [],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://5',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n", "            fieldName: '*',\n\t            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n", "                parseFnId: undefined,\n\t                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://6',\n\t                  },\n\t                ],\n", "              },\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'email',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'email',\n\t                type: 'literal',\n\t                validations: [\n", "                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://7',\n\t                  },\n\t                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n", "            validations: [],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://8',\n\t          schema: {\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            fieldName: '*',\n", "            groups: [],\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            properties: [\n\t              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'type',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n", "                propertyName: 'type',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n\t                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://9',\n\t                  },\n\t                ],\n\t              },\n", "              {\n\t                allowNull: false,\n\t                bail: true,\n\t                fieldName: 'project_url',\n\t                isOptional: false,\n\t                parseFnId: undefined,\n\t                propertyName: 'project_url',\n\t                type: 'literal',\n\t                validations: [\n\t                  {\n", "                    implicit: false,\n\t                    isAsync: false,\n\t                    ruleFnId: 'ref://10',\n\t                  },\n\t                ],\n\t              },\n\t            ],\n\t            propertyName: '*',\n\t            type: 'object',\n\t            validations: [],\n", "          },\n\t        },\n\t      ],\n\t      elseConditionalFnRefId: 'ref://1',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      type: 'union',\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/literal.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { PARSE } from '../../../src/symbols.js'\n\timport { Vine } from '../../../src/vine/main.js'\n\tconst vine = new Vine()\n\ttest.group('VineLiteral', () => {\n\t  test('create literal schema', ({ assert }) => {\n\t    const schema = vine.literal(22)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.literal(22).nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('apply optional modifier', ({ assert }) => {\n\t    const schema = vine.literal(22).optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n", "  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const schema = vine.literal(22).bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n", "  test('apply transformer', ({ assert }) => {\n\t    const schema = vine.literal(22).transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n", "  test('apply parser', ({ assert }) => {\n\t    const schema = vine.literal(22).parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t})\n", "test.group('VineLiteral | clone', () => {\n\t  test('clone boolean schema', ({ assert }) => {\n\t    const schema = vine.literal(22)\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.literal(22)\n\t    const schema1 = schema.clone().nullable()\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const schema = vine.literal(22)\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n", "    const schema = vine.literal(22)\n\t    const schema1 = schema.clone().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply transformer', ({ assert }) => {\n\t    const schema = vine.literal(22)\n\t    const schema1 = schema.clone().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('clone and apply parser', ({ assert }) => {\n\t    const schema = vine.literal(22)\n\t    const schema1 = schema.clone().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/object.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { Vine } from '../../../src/vine/main.js'\n\timport { IS_OF_TYPE, PARSE } from '../../../src/symbols.js'\n\tconst vine = new Vine()\n\ttest.group('VineObject', () => {\n\t  test('create object', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.object({})\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [],\n\t    })\n", "  })\n\t  test('define object properties', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t    })\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n", "          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n", "            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine\n", "      .object({\n\t        username: vine.string(),\n\t      })\n\t      .nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n", "      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n", "          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply optional modifier', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n", "      })\n\t      .optional()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('allow unknown properties', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n\t      })\n\t      .allowUnknownProperties()\n", "    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: true,\n\t      validations: [],\n\t      groups: [],\n", "      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n", "            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n", "  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n\t      })\n\t      .bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: false,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n", "        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('merge group', ({ assert }) => {\n", "    const hiringGuide = vine.group([\n\t      vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n\t        is_hiring_guide: vine.literal(true),\n\t        name: vine.string(),\n\t        price: vine.string(),\n\t      }),\n\t      vine.group.else({\n\t        is_hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n", "    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t      .merge(hiringGuide)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [\n\t        {\n\t          type: 'group',\n\t          elseConditionalFnRefId: 'ref://3',\n\t          conditions: [\n", "            {\n\t              conditionalFnRefId: 'ref://7',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n", "                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://4',\n\t                      },\n", "                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'name',\n\t                    propertyName: 'name',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n", "                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n", "                    fieldName: 'price',\n\t                    propertyName: 'price',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n", "                        ruleFnId: 'ref://6',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t            {\n\t              conditionalFnRefId: 'ref://9',\n\t              schema: {\n", "                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n", "                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://8',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n", "              },\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n", "          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n", "            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'password',\n\t          propertyName: 'password',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('merge multiple group', ({ assert }) => {\n\t    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n\t        hiring_guide: vine.literal(true),\n\t        guide_name: vine.string(),\n\t        fees: vine.string(),\n\t      }),\n\t      vine.group.if(() => true, {\n", "        hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const monumentSchema = vine.group([\n\t      vine.group.if((data) => data.monument === 'foo', {\n\t        monument: vine.literal('foo'),\n\t        available_transport: vine.enum(['bus', 'train']),\n\t        has_free_entry: vine.literal(false),\n\t      }),\n\t      vine.group.if((data) => data.monument === 'bar', {\n", "        monument: vine.literal('bar'),\n\t        available_transport: vine.enum(['bus', 'car']),\n\t        has_free_entry: vine.literal(true),\n\t      }),\n\t    ])\n\t    const schema = vine\n\t      .object({\n\t        visitor_name: vine.string(),\n\t      })\n\t      .merge(guideSchema)\n", "      .merge(monumentSchema)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      groups: [\n\t        {\n\t          type: 'group',\n\t          elseConditionalFnRefId: 'ref://2',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://6',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n", "                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'hiring_guide',\n\t                    propertyName: 'hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n", "                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://3',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'guide_name',\n", "                    propertyName: 'guide_name',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://4',\n", "                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'fees',\n\t                    propertyName: 'fees',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n", "                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n", "              },\n\t            },\n\t            {\n\t              conditionalFnRefId: 'ref://8',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n", "                    fieldName: 'hiring_guide',\n\t                    propertyName: 'hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n", "                        ruleFnId: 'ref://7',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n\t        },\n\t        {\n", "          type: 'group',\n\t          elseConditionalFnRefId: 'ref://9',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://13',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n", "                    type: 'literal',\n\t                    fieldName: 'monument',\n\t                    propertyName: 'monument',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n", "                        isAsync: false,\n\t                        ruleFnId: 'ref://10',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'available_transport',\n\t                    propertyName: 'available_transport',\n\t                    bail: true,\n", "                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://11',\n\t                      },\n\t                    ],\n", "                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'has_free_entry',\n\t                    propertyName: 'has_free_entry',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n", "                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://12',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n", "            {\n\t              conditionalFnRefId: 'ref://17',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'monument',\n\t                    propertyName: 'monument',\n", "                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://14',\n\t                      },\n", "                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'available_transport',\n\t                    propertyName: 'available_transport',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n", "                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://15',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n", "                    fieldName: 'has_free_entry',\n\t                    propertyName: 'has_free_entry',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n", "                        ruleFnId: 'ref://16',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n\t        },\n\t      ],\n", "      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'visitor_name',\n\t          propertyName: 'visitor_name',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n", "  })\n\t  test('define custom otherwise callback', ({ assert }) => {\n\t    function failOtherwise() {}\n\t    const hiringGuide = vine\n\t      .group([\n\t        vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n\t          is_hiring_guide: vine.literal(true),\n\t          name: vine.string(),\n\t          price: vine.string(),\n\t        }),\n", "        vine.group.else({\n\t          is_hiring_guide: vine.literal(false),\n\t        }),\n\t      ])\n\t      .otherwise(failOtherwise)\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n", "      .merge(hiringGuide)\n\t    const refs = refsBuilder()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      groups: [\n\t        {\n\t          type: 'group',\n\t          elseConditionalFnRefId: 'ref://3',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://7',\n\t              schema: {\n\t                type: 'sub_object',\n", "                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n", "                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://4',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n", "                    fieldName: 'name',\n\t                    propertyName: 'name',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n", "                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'price',\n\t                    propertyName: 'price',\n\t                    bail: true,\n\t                    allowNull: false,\n", "                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://6',\n\t                      },\n\t                    ],\n\t                  },\n", "                ],\n\t              },\n\t            },\n\t            {\n\t              conditionalFnRefId: 'ref://9',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n", "                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n", "                        isAsync: false,\n\t                        ruleFnId: 'ref://8',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n\t        },\n", "      ],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n", "          type: 'literal',\n\t          fieldName: 'password',\n\t          propertyName: 'password',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(refs.toJSON()['ref://3'], failOtherwise)\n\t  })\n\t  test('create nested object', ({ assert }) => {\n", "    const refs = refsBuilder()\n\t    const schema = vine.object({\n\t      user: vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      }),\n\t    })\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n", "          type: 'object',\n\t          fieldName: 'user',\n\t          propertyName: 'user',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          validations: [],\n\t          groups: [],\n\t          parseFnId: undefined,\n", "          properties: [\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'username',\n\t              propertyName: 'username',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n", "                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://1',\n\t                },\n\t              ],\n\t            },\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'password',\n", "              propertyName: 'password',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://2',\n", "                },\n\t              ],\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('deeply apply camelcase transform', ({ assert }) => {\n\t    const refs = refsBuilder()\n", "    const schema = vine\n\t      .object({\n\t        post_id: vine.number(),\n\t        user: vine.object({\n\t          user_name: vine.string(),\n\t          pass_word: vine.string(),\n\t        }),\n\t      })\n\t      .toCamelCase()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n", "      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n", "      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'post_id',\n\t          propertyName: 'postId',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n", "            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'object',\n\t          fieldName: 'user',\n", "          propertyName: 'user',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          validations: [],\n\t          groups: [],\n\t          parseFnId: undefined,\n\t          properties: [\n\t            {\n", "              type: 'literal',\n\t              fieldName: 'user_name',\n\t              propertyName: 'userName',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n", "                  isAsync: false,\n\t                  ruleFnId: 'ref://2',\n\t                },\n\t              ],\n\t            },\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'pass_word',\n\t              propertyName: 'passWord',\n\t              bail: true,\n", "              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n", "            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply camelcase transform to nested object', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.object({\n\t      post_id: vine.number(),\n", "      user: vine\n\t        .object({\n\t          user_name: vine.string(),\n\t          pass_word: vine.string(),\n\t        })\n\t        .toCamelCase(),\n\t    })\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n", "          type: 'literal',\n\t          fieldName: 'post_id',\n\t          propertyName: 'post_id',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'object',\n\t          fieldName: 'user',\n\t          propertyName: 'user',\n\t          bail: true,\n", "          allowNull: false,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          validations: [],\n\t          groups: [],\n\t          parseFnId: undefined,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'user_name',\n", "              propertyName: 'userName',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://2',\n", "                },\n\t              ],\n\t            },\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'pass_word',\n\t              propertyName: 'passWord',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n", "              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n\t            },\n\t          ],\n", "        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply camelcase transform to groups', ({ assert }) => {\n\t    const hiringGuide = vine.group([\n\t      vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n\t        is_hiring_guide: vine.literal(true),\n\t        name: vine.string(),\n\t        price: vine.string(),\n", "      }),\n\t      vine.group.else({\n\t        is_hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n", "      .merge(hiringGuide)\n\t      .toCamelCase()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      groups: [\n\t        {\n\t          type: 'group',\n\t          elseConditionalFnRefId: 'ref://3',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://7',\n\t              schema: {\n\t                type: 'sub_object',\n", "                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'isHiringGuide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n", "                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://4',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n", "                    fieldName: 'name',\n\t                    propertyName: 'name',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n", "                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'price',\n\t                    propertyName: 'price',\n\t                    bail: true,\n\t                    allowNull: false,\n", "                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://6',\n\t                      },\n\t                    ],\n\t                  },\n", "                ],\n\t              },\n\t            },\n\t            {\n\t              conditionalFnRefId: 'ref://9',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n", "                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'isHiringGuide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n", "                        isAsync: false,\n\t                        ruleFnId: 'ref://8',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n\t        },\n", "      ],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n", "          type: 'literal',\n\t          fieldName: 'password',\n\t          propertyName: 'password',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('merge camelcase transform to multiple group', ({ assert }) => {\n\t    const guideSchema = vine.group([\n", "      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n\t        hiring_guide: vine.literal(true),\n\t        guide_name: vine.string(),\n\t        fees: vine.string(),\n\t      }),\n\t      vine.group.if(() => true, {\n\t        hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const monumentSchema = vine.group([\n", "      vine.group.if((data) => data.monument === 'foo', {\n\t        monument: vine.literal('foo'),\n\t        available_transport: vine.enum(['bus', 'train']),\n\t        has_free_entry: vine.literal(false),\n\t      }),\n\t      vine.group.if((data) => data.monument === 'bar', {\n\t        monument: vine.literal('bar'),\n\t        available_transport: vine.enum(['bus', 'car']),\n\t        has_free_entry: vine.literal(true),\n\t      }),\n", "    ])\n\t    const schema = vine\n\t      .object({\n\t        visitor_name: vine.string(),\n\t      })\n\t      .merge(guideSchema)\n\t      .merge(monumentSchema)\n\t      .toCamelCase()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [\n\t        {\n\t          type: 'group',\n", "          elseConditionalFnRefId: 'ref://2',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://6',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n", "                    fieldName: 'hiring_guide',\n\t                    propertyName: 'hiringGuide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n", "                        ruleFnId: 'ref://3',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'guide_name',\n\t                    propertyName: 'guideName',\n\t                    bail: true,\n\t                    allowNull: false,\n", "                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://4',\n\t                      },\n\t                    ],\n\t                  },\n", "                  {\n\t                    type: 'literal',\n\t                    fieldName: 'fees',\n\t                    propertyName: 'fees',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n", "                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t            {\n", "              conditionalFnRefId: 'ref://8',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'hiring_guide',\n\t                    propertyName: 'hiringGuide',\n\t                    bail: true,\n", "                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://7',\n\t                      },\n\t                    ],\n", "                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'group',\n\t          elseConditionalFnRefId: 'ref://9',\n\t          conditions: [\n", "            {\n\t              conditionalFnRefId: 'ref://13',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'monument',\n\t                    propertyName: 'monument',\n", "                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://10',\n\t                      },\n", "                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'available_transport',\n\t                    propertyName: 'availableTransport',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n", "                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://11',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n", "                    fieldName: 'has_free_entry',\n\t                    propertyName: 'hasFreeEntry',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n", "                        ruleFnId: 'ref://12',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t            {\n\t              conditionalFnRefId: 'ref://17',\n\t              schema: {\n", "                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'monument',\n\t                    propertyName: 'monument',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n", "                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://14',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n", "                    type: 'literal',\n\t                    fieldName: 'available_transport',\n\t                    propertyName: 'availableTransport',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n", "                        isAsync: false,\n\t                        ruleFnId: 'ref://15',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'has_free_entry',\n\t                    propertyName: 'hasFreeEntry',\n\t                    bail: true,\n", "                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://16',\n\t                      },\n\t                    ],\n", "                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n", "          type: 'literal',\n\t          fieldName: 'visitor_name',\n\t          propertyName: 'visitorName',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('deeply apply camelcase transform', ({ assert }) => {\n\t    const refs = refsBuilder()\n", "    const schema = vine\n\t      .object({\n\t        post_id: vine.number(),\n\t        user: vine.object({\n\t          user_name: vine.string(),\n\t          pass_word: vine.string(),\n\t        }),\n\t      })\n\t      .toCamelCase()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n", "      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n", "      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'post_id',\n\t          propertyName: 'postId',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n", "            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'object',\n\t          fieldName: 'user',\n", "          propertyName: 'user',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          validations: [],\n\t          groups: [],\n\t          parseFnId: undefined,\n\t          properties: [\n\t            {\n", "              type: 'literal',\n\t              fieldName: 'user_name',\n\t              propertyName: 'userName',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n", "                  isAsync: false,\n\t                  ruleFnId: 'ref://2',\n\t                },\n\t              ],\n\t            },\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'pass_word',\n\t              propertyName: 'passWord',\n\t              bail: true,\n", "              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n", "            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('define parser', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.object({}).parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n", "      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: 'ref://1',\n", "      properties: [],\n\t    })\n\t  })\n\t  test('apply nullable modifier after camelcase modifier', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine\n\t      .object({\n\t        post_id: vine.number(),\n\t        user: vine.object({\n\t          user_name: vine.string(),\n", "          pass_word: vine.string(),\n\t        }),\n\t      })\n\t      .toCamelCase()\n\t      .nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: true,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'post_id',\n", "          propertyName: 'postId',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n", "            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'object',\n\t          fieldName: 'user',\n\t          propertyName: 'user',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          allowUnknownProperties: false,\n\t          validations: [],\n\t          groups: [],\n\t          parseFnId: undefined,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'user_name',\n\t              propertyName: 'userName',\n\t              bail: true,\n", "              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://2',\n\t                },\n\t              ],\n", "            },\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'pass_word',\n\t              propertyName: 'passWord',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n", "                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('apply optional modifier after camelcase modifier', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine\n\t      .object({\n\t        post_id: vine.number(),\n\t        user: vine.object({\n\t          user_name: vine.string(),\n\t          pass_word: vine.string(),\n", "        }),\n\t      })\n\t      .toCamelCase()\n\t      .optional()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n", "      isOptional: true,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'post_id',\n\t          propertyName: 'postId',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n", "          ],\n\t        },\n\t        {\n\t          type: 'object',\n\t          fieldName: 'user',\n\t          propertyName: 'user',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n", "          validations: [],\n\t          groups: [],\n\t          parseFnId: undefined,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'user_name',\n\t              propertyName: 'userName',\n\t              bail: true,\n\t              allowNull: false,\n", "              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://2',\n\t                },\n\t              ],\n\t            },\n", "            {\n\t              type: 'literal',\n\t              fieldName: 'pass_word',\n\t              propertyName: 'passWord',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n", "                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n", "  })\n\t  test('check if value is an object using IS_OF_TYPE method', ({ assert }) => {\n\t    const schema = vine.object({})\n\t    assert.isTrue(schema[IS_OF_TYPE]({}))\n\t    assert.isFalse(schema[IS_OF_TYPE](null))\n\t    assert.isFalse(schema[IS_OF_TYPE](undefined))\n\t    assert.isFalse(schema[IS_OF_TYPE]([]))\n\t    assert.isFalse(schema[IS_OF_TYPE](''))\n\t    assert.isFalse(schema[IS_OF_TYPE](1))\n\t  })\n", "  test('check if value is an object after applying camelcase modifier', ({ assert }) => {\n\t    const schema = vine.object({}).toCamelCase()\n\t    assert.isTrue(schema[IS_OF_TYPE]({}))\n\t    assert.isFalse(schema[IS_OF_TYPE](null))\n\t    assert.isFalse(schema[IS_OF_TYPE](undefined))\n\t    assert.isFalse(schema[IS_OF_TYPE]([]))\n\t    assert.isFalse(schema[IS_OF_TYPE](''))\n\t    assert.isFalse(schema[IS_OF_TYPE](1))\n\t  })\n\t})\n", "test.group('VineObject | clone', () => {\n\t  test('clone object', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.object({})\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [],\n", "    })\n\t  })\n\t  test('copy properties during clone', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t    })\n\t    const schema1 = vine.object({\n\t      ...schema.getProperties(),\n\t      password: vine.string(),\n", "    })\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t        {\n", "          type: 'literal',\n\t          fieldName: 'password',\n\t          propertyName: 'password',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n", "              ruleFnId: 'ref://3',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n\t    const refs = refsBuilder()\n", "    const schema = vine.object({\n\t      username: vine.string(),\n\t    })\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n", "      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n", "          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n", "      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n", "          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t    })\n", "    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('clone and allow unknown properties', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t    })\n\t    const schema1 = schema.clone().allowUnknownProperties()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n", "        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: true,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n", "        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n", "    const refs = refsBuilder()\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t    })\n\t    const schema1 = schema.clone().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n", "          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n", "          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: false,\n", "      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n", "          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n", "          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('merge group to cloned object', ({ assert }) => {\n\t    const hiringGuide = vine.group([\n\t      vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n\t        is_hiring_guide: vine.literal(true),\n", "        name: vine.string(),\n\t        price: vine.string(),\n\t      }),\n\t      vine.group.else({\n\t        is_hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      password: vine.string(),\n", "    })\n\t    const schema1 = schema.clone().merge(hiringGuide)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n", "        {\n\t          type: 'literal',\n\t          fieldName: 'password',\n\t          propertyName: 'password',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n", "              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [\n\t        {\n\t          type: 'group',\n", "          elseConditionalFnRefId: 'ref://3',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://7',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n", "                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n", "                        ruleFnId: 'ref://4',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'name',\n\t                    propertyName: 'name',\n\t                    bail: true,\n\t                    allowNull: false,\n", "                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n\t                  },\n", "                  {\n\t                    type: 'literal',\n\t                    fieldName: 'price',\n\t                    propertyName: 'price',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n", "                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://6',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t            {\n", "              conditionalFnRefId: 'ref://9',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n", "                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://8',\n\t                      },\n\t                    ],\n", "                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n", "          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'password',\n\t          propertyName: 'password',\n\t          bail: true,\n", "          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n", "        },\n\t      ],\n\t    })\n\t  })\n\t  test('merge groups across original and cloned objects', ({ assert }) => {\n\t    const guideSchema = vine.group([\n\t      vine.group.if((data) => vine.helpers.isTrue(data.hiring_guide), {\n\t        hiring_guide: vine.literal(true),\n\t        guide_name: vine.string(),\n\t        fees: vine.string(),\n", "      }),\n\t      vine.group.if(() => true, {\n\t        hiring_guide: vine.literal(false),\n\t      }),\n\t    ])\n\t    const monumentSchema = vine.group([\n\t      vine.group.if((data) => data.monument === 'foo', {\n\t        monument: vine.literal('foo'),\n\t        available_transport: vine.enum(['bus', 'train']),\n\t        has_free_entry: vine.literal(false),\n", "      }),\n\t      vine.group.if((data) => data.monument === 'bar', {\n\t        monument: vine.literal('bar'),\n\t        available_transport: vine.enum(['bus', 'car']),\n\t        has_free_entry: vine.literal(true),\n\t      }),\n\t    ])\n\t    const schema = vine.object({\n\t      visitor_name: vine.string(),\n\t    })\n", "    const schema1 = schema.clone().merge(monumentSchema)\n\t    schema.merge(guideSchema)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      groups: [\n\t        {\n\t          type: 'group',\n\t          elseConditionalFnRefId: 'ref://2',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://6',\n\t              schema: {\n\t                type: 'sub_object',\n", "                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'hiring_guide',\n\t                    propertyName: 'hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n", "                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://3',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n", "                    fieldName: 'guide_name',\n\t                    propertyName: 'guide_name',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n", "                        ruleFnId: 'ref://4',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'fees',\n\t                    propertyName: 'fees',\n\t                    bail: true,\n\t                    allowNull: false,\n", "                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n\t                  },\n", "                ],\n\t              },\n\t            },\n\t            {\n\t              conditionalFnRefId: 'ref://8',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n", "                    type: 'literal',\n\t                    fieldName: 'hiring_guide',\n\t                    propertyName: 'hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n", "                        isAsync: false,\n\t                        ruleFnId: 'ref://7',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n\t        },\n", "      ],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'visitor_name',\n\t          propertyName: 'visitor_name',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      groups: [\n\t        {\n\t          type: 'group',\n\t          elseConditionalFnRefId: 'ref://2',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://6',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n", "                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'monument',\n\t                    propertyName: 'monument',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n", "                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://3',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'available_transport',\n", "                    propertyName: 'available_transport',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://4',\n", "                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'has_free_entry',\n\t                    propertyName: 'has_free_entry',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n", "                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n", "              },\n\t            },\n\t            {\n\t              conditionalFnRefId: 'ref://10',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n", "                    fieldName: 'monument',\n\t                    propertyName: 'monument',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n", "                        ruleFnId: 'ref://7',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'available_transport',\n\t                    propertyName: 'available_transport',\n\t                    bail: true,\n\t                    allowNull: false,\n", "                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://8',\n\t                      },\n\t                    ],\n\t                  },\n", "                  {\n\t                    type: 'literal',\n\t                    fieldName: 'has_free_entry',\n\t                    propertyName: 'has_free_entry',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n", "                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://9',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n", "        },\n\t      ],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'visitor_name',\n\t          propertyName: 'visitor_name',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('clone and deeply apply camelcase transform', ({ assert }) => {\n\t    const schema = vine.object({\n\t      post_id: vine.number(),\n\t      user: vine.object({\n\t        user_name: vine.string(),\n\t        pass_word: vine.string(),\n\t      }),\n", "    })\n\t    const schema1 = schema.clone().toCamelCase()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'post_id',\n\t          propertyName: 'post_id',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n", "        {\n\t          type: 'object',\n\t          fieldName: 'user',\n\t          propertyName: 'user',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          validations: [],\n\t          groups: [],\n", "          parseFnId: undefined,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'user_name',\n\t              propertyName: 'user_name',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n", "              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://2',\n\t                },\n\t              ],\n\t            },\n\t            {\n\t              type: 'literal',\n", "              fieldName: 'pass_word',\n\t              propertyName: 'pass_word',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n", "                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n", "        {\n\t          type: 'literal',\n\t          fieldName: 'post_id',\n\t          propertyName: 'postId',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n", "              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'object',\n\t          fieldName: 'user',\n\t          propertyName: 'user',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          validations: [],\n\t          groups: [],\n\t          parseFnId: undefined,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n", "              fieldName: 'user_name',\n\t              propertyName: 'userName',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n", "                  ruleFnId: 'ref://2',\n\t                },\n\t              ],\n\t            },\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'pass_word',\n\t              propertyName: 'passWord',\n\t              bail: true,\n\t              allowNull: false,\n", "              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n\t            },\n", "          ],\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('re-use schema via cloning', ({ assert }) => {\n\t    const user = vine.object({\n\t      user_name: vine.string(),\n\t      pass_word: vine.string(),\n\t    })\n", "    const schema = vine\n\t      .object({\n\t        post_id: vine.number(),\n\t        user: user.clone(),\n\t      })\n\t      .toCamelCase()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n", "          fieldName: 'post_id',\n\t          propertyName: 'postId',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n", "              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'object',\n\t          fieldName: 'user',\n\t          propertyName: 'user',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          validations: [],\n\t          groups: [],\n\t          parseFnId: undefined,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'user_name',\n\t              propertyName: 'userName',\n", "              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://2',\n\t                },\n", "              ],\n\t            },\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'pass_word',\n\t              propertyName: 'passWord',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n", "              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t        },\n", "      ],\n\t    })\n\t    assert.deepEqual(user[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'user_name',\n\t          propertyName: 'user_name',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n", "        {\n\t          type: 'literal',\n\t          fieldName: 'pass_word',\n\t          propertyName: 'pass_word',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n", "              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone group', ({ assert }) => {\n", "    function failOtherwise() {}\n\t    const hiringGuide = vine.group([\n\t      vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n\t        is_hiring_guide: vine.literal(true),\n\t        name: vine.string(),\n\t        price: vine.string(),\n\t      }),\n\t      vine.group.else({\n\t        is_hiring_guide: vine.literal(false),\n\t      }),\n", "    ])\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      password: vine.string(),\n\t    })\n\t    const schema1 = schema.clone().merge(hiringGuide.clone().otherwise(failOtherwise))\n\t    schema.merge(hiringGuide)\n\t    const refs = refsBuilder()\n\t    const refs1 = refsBuilder()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n", "      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [\n\t        {\n", "          type: 'group',\n\t          elseConditionalFnRefId: 'ref://3',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://7',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n", "                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n", "                        isAsync: false,\n\t                        ruleFnId: 'ref://4',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'name',\n\t                    propertyName: 'name',\n\t                    bail: true,\n", "                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n", "                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'price',\n\t                    propertyName: 'price',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n", "                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://6',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n", "            {\n\t              conditionalFnRefId: 'ref://9',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n", "                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://8',\n\t                      },\n", "                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      properties: [\n", "        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n", "              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'password',\n\t          propertyName: 'password',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n", "          ],\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs1, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n", "      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [\n\t        {\n\t          type: 'group',\n\t          elseConditionalFnRefId: 'ref://3',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://7',\n", "              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n", "                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://4',\n\t                      },\n\t                    ],\n\t                  },\n", "                  {\n\t                    type: 'literal',\n\t                    fieldName: 'name',\n\t                    propertyName: 'name',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n", "                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'price',\n\t                    propertyName: 'price',\n", "                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://6',\n\t                      },\n", "                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t            {\n\t              conditionalFnRefId: 'ref://9',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n", "                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n", "                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://8',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n", "          ],\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n", "          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n", "        },\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'password',\n\t          propertyName: 'password',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n", "            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t    assert.notDeepEqual(refs.toJSON()['ref://3'], refs1.toJSON()['ref://3'])\n", "  })\n\t  test('define otherwise callback and clone group', ({ assert }) => {\n\t    const hiringGuide = vine\n\t      .group([\n\t        vine.group.if((value) => vine.helpers.isTrue(value.is_hiring_guide), {\n\t          is_hiring_guide: vine.literal(true),\n\t          name: vine.string(),\n\t          price: vine.string(),\n\t        }),\n\t        vine.group.else({\n", "          is_hiring_guide: vine.literal(false),\n\t        }),\n\t      ])\n\t      .otherwise(() => {})\n\t    const schema = vine.object({\n\t      username: vine.string(),\n\t      password: vine.string(),\n\t    })\n\t    const schema1 = schema.clone().merge(hiringGuide.clone())\n\t    schema.merge(hiringGuide)\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [\n", "        {\n\t          type: 'group',\n\t          elseConditionalFnRefId: 'ref://3',\n\t          conditions: [\n\t            {\n\t              conditionalFnRefId: 'ref://7',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n", "                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n", "                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://4',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'name',\n\t                    propertyName: 'name',\n", "                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://5',\n\t                      },\n", "                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'price',\n\t                    propertyName: 'price',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n", "                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://6',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n", "            },\n\t            {\n\t              conditionalFnRefId: 'ref://9',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n", "                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://8',\n", "                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n", "      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n", "            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'password',\n", "          propertyName: 'password',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n", "            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [\n\t        {\n\t          type: 'group',\n\t          elseConditionalFnRefId: 'ref://3',\n\t          conditions: [\n\t            {\n", "              conditionalFnRefId: 'ref://7',\n\t              schema: {\n\t                type: 'sub_object',\n\t                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n", "                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://4',\n\t                      },\n\t                    ],\n", "                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'name',\n\t                    propertyName: 'name',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n", "                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://5',\n\t                      },\n\t                    ],\n\t                  },\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'price',\n", "                    propertyName: 'price',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n\t                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://6',\n", "                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t            {\n\t              conditionalFnRefId: 'ref://9',\n\t              schema: {\n\t                type: 'sub_object',\n", "                groups: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    fieldName: 'is_hiring_guide',\n\t                    propertyName: 'is_hiring_guide',\n\t                    bail: true,\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    parseFnId: undefined,\n", "                    validations: [\n\t                      {\n\t                        implicit: false,\n\t                        isAsync: false,\n\t                        ruleFnId: 'ref://8',\n\t                      },\n\t                    ],\n\t                  },\n\t                ],\n\t              },\n", "            },\n\t          ],\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n", "          ],\n\t        },\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'password',\n\t          propertyName: 'password',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n", "  })\n\t  test('apply toCamelCase transform and clone', ({ assert }) => {\n\t    const schema = vine\n\t      .object({\n\t        post_id: vine.number(),\n\t        user: vine.object({\n\t          user_name: vine.string(),\n\t          pass_word: vine.string(),\n\t        }),\n\t      })\n", "      .toCamelCase()\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'post_id',\n\t          propertyName: 'postId',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n", "        {\n\t          type: 'object',\n\t          fieldName: 'user',\n\t          propertyName: 'user',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          validations: [],\n\t          groups: [],\n", "          parseFnId: undefined,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'user_name',\n\t              propertyName: 'userName',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n", "              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://2',\n\t                },\n\t              ],\n\t            },\n\t            {\n\t              type: 'literal',\n", "              fieldName: 'pass_word',\n\t              propertyName: 'passWord',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n", "                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'object',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n", "        {\n\t          type: 'literal',\n\t          fieldName: 'post_id',\n\t          propertyName: 'postId',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          parseFnId: undefined,\n\t          validations: [\n\t            {\n", "              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          type: 'object',\n\t          fieldName: 'user',\n\t          propertyName: 'user',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          validations: [],\n\t          groups: [],\n\t          parseFnId: undefined,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n", "              fieldName: 'user_name',\n\t              propertyName: 'userName',\n\t              bail: true,\n\t              allowNull: false,\n\t              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n", "                  ruleFnId: 'ref://2',\n\t                },\n\t              ],\n\t            },\n\t            {\n\t              type: 'literal',\n\t              fieldName: 'pass_word',\n\t              propertyName: 'passWord',\n\t              bail: true,\n\t              allowNull: false,\n", "              isOptional: false,\n\t              parseFnId: undefined,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n\t            },\n", "          ],\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('allow unknown properties and clone', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n", "      })\n\t      .allowUnknownProperties()\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      allowUnknownProperties: true,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n", "          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n", "        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      allowUnknownProperties: true,\n\t      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n", "          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n", "        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply nullable modifier and clone', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n\t      })\n", "      .nullable()\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n", "      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: true,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('apply optional modifier and clone', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine\n\t      .object({\n\t        username: vine.string(),\n\t      })\n\t      .optional()\n", "    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'object',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: true,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      groups: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: 'username',\n\t          propertyName: 'username',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n", "    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/accepted.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { PARSE } from '../../../src/symbols.js'\n\timport { Vine } from '../../../src/vine/main.js'\n\tconst vine = new Vine()\n\ttest.group('VineAccepted', () => {\n\t  test('create accepted schema', ({ assert }) => {\n\t    const schema = vine.accepted()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.accepted().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('apply optional modifier', ({ assert }) => {\n\t    const schema = vine.accepted().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n", "  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const schema = vine.accepted().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n", "  test('apply parser', ({ assert }) => {\n\t    const schema = vine.accepted().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply transformer', ({ assert }) => {\n", "    const schema = vine.accepted().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t})\n", "test.group('VineAccepted | clone', () => {\n\t  test('clone accepted schema', ({ assert }) => {\n\t    const schema = vine.accepted()\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.accepted()\n\t    const schema1 = schema.clone().nullable()\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const schema = vine.accepted()\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n", "    const schema = vine.accepted()\n\t    const schema1 = schema.clone().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply transformer', ({ assert }) => {\n\t    const schema = vine.accepted()\n\t    const schema1 = schema.clone().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('clone and apply parser', ({ assert }) => {\n\t    const schema = vine.accepted()\n\t    const schema1 = schema.clone().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/record.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { Vine } from '../../../src/vine/main.js'\n\timport { IS_OF_TYPE, PARSE } from '../../../src/symbols.js'\n\timport {\n\t  maxLengthRule,\n\t  minLengthRule,\n\t  fixedLengthRule,\n\t  validateKeysRule,\n\t} from '../../../src/schema/record/rules.js'\n\tconst vine = new Vine()\n\ttest.group('VineRecord', () => {\n", "  test('construct record schema', ({ assert }) => {\n\t    const schema = vine.record(\n\t      vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t    )\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n", "        ],\n\t      },\n\t    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n\t    const schema = vine\n\t      .record(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n", "        })\n\t      )\n\t      .nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: false,\n", "      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n", "        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n", "          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n", "                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n", "  test('apply optional modifier', ({ assert }) => {\n\t    const schema = vine\n\t      .record(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n\t      .optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n", "        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n", "          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n", "                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const schema = vine\n\t      .record(\n\t        vine.object({\n", "          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n\t      .bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: false,\n", "      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n", "        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n", "            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n", "    })\n\t  })\n\t  test('define parser', ({ assert }) => {\n\t    const schema = vine\n\t      .record(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n", "      .parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: 'ref://3',\n", "      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n", "        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t  test('convert propertyName to camelCase', ({ assert }) => {\n\t    const schema = vine\n", "      .record(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n\t      .parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('app_users', refsBuilder(), { toCamelCase: true }), {\n\t      type: 'record',\n\t      fieldName: 'app_users',\n", "      propertyName: 'appUsers',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: 'ref://3',\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n", "        ],\n\t      },\n\t    })\n\t  })\n\t  test('check if value is an object using IS_OF_TYPE method', ({ assert }) => {\n\t    const schema = vine.record(vine.string())\n\t    assert.isTrue(schema[IS_OF_TYPE]({}))\n\t    assert.isFalse(schema[IS_OF_TYPE](null))\n\t    assert.isFalse(schema[IS_OF_TYPE](undefined))\n\t    assert.isFalse(schema[IS_OF_TYPE]([]))\n", "    assert.isFalse(schema[IS_OF_TYPE](''))\n\t    assert.isFalse(schema[IS_OF_TYPE](1))\n\t  })\n\t})\n\ttest.group('VineRecord | clone', () => {\n\t  test('clone record schema', ({ assert }) => {\n\t    const schema = vine.record(\n\t      vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n", "      })\n\t    )\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n", "        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n", "          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n", "                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n", "        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n", "          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n", "                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.record(\n\t      vine.object({\n\t        username: vine.string(),\n", "        password: vine.string(),\n\t      })\n\t    )\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n", "      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n", "        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n", "            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n", "          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n", "              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n", "        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n", "        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n", "              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n", "            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n", "              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const schema = vine.record(\n\t      vine.object({\n", "        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t    )\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n", "        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n", "            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n", "      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n", "        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n\t    const schema = vine.record(\n", "      vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t    )\n\t    const schema1 = schema.clone().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n", "        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n", "            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n", "              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n", "            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: false,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n", "      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n", "        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n", "            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n", "            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n", "                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t  test('apply nullable modifier and clone', ({ assert }) => {\n", "    const schema = vine\n\t      .record(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n\t      .nullable()\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n", "        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n", "          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n", "                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: true,\n\t      isOptional: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n", "        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n", "            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n", "    })\n\t  })\n\t  test('apply optional modifier and clone', ({ assert }) => {\n\t    const schema = vine\n\t      .record(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n", "      .optional()\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      validations: [],\n", "      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n", "        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n", "            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n", "            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n", "                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'record',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n", "        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n", "            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n", "                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n", "            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n", "          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t})\n\ttest.group('VineRecord | applying rules', () => {\n\t  test('apply minLength rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.record(vine.string()).minLength(2)\n", "    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n", "          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n", "        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: undefined,\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const minLength = minLengthRule({ min: 2 })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: minLength.rule.validator,\n\t      options: minLength.options,\n\t    })\n\t  })\n\t  test('apply maxLength rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n", "    const schema = vine.record(vine.string()).maxLength(2)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: undefined,\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n", "        ],\n\t      },\n\t    })\n\t    const maxLength = maxLengthRule({ max: 2 })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: maxLength.rule.validator,\n\t      options: maxLength.options,\n\t    })\n\t  })\n\t  test('apply fixedLength rule', ({ assert }) => {\n", "    const refs = refsBuilder()\n\t    const schema = vine.record(vine.string()).fixedLength(2)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'literal',\n\t        fieldName: '*',\n", "        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: undefined,\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n", "          },\n\t        ],\n\t      },\n\t    })\n\t    const fixedLength = fixedLengthRule({ size: 2 })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: fixedLength.rule.validator,\n\t      options: fixedLength.options,\n\t    })\n\t  })\n", "  test('apply validateKeys rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const callback = () => {}\n\t    const schema = vine.record(vine.string()).validateKeys(callback)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'record',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n", "      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      each: {\n", "        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: undefined,\n\t        validations: [\n\t          {\n\t            implicit: false,\n", "            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const validateKeys = validateKeysRule(callback)\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: validateKeys.rule.validator,\n\t      options: validateKeys.options,\n", "    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/tuple.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { Vine } from '../../../src/vine/main.js'\n\timport { IS_OF_TYPE, PARSE } from '../../../src/symbols.js'\n\tconst vine = new Vine()\n\ttest.group('VineTuple', () => {\n\t  test('create tuple', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([])\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [],\n\t    })\n\t  })\n", "  test('define tuple elements', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()])\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()]).nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: true,\n\t      allowNull: true,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n", "          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n", "          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply optional modifier', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string(), vine.number()]).optional()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n", "      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n", "        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t        {\n\t          type: 'literal',\n\t          fieldName: '1',\n\t          propertyName: '1',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n", "          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('allow unknown properties', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()]).allowUnknownProperties()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n", "          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n", "              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const refs = refsBuilder()\n", "    const schema = vine.tuple([vine.string()]).bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: false,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n", "            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n", "  })\n\t  test('define parser', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()]).parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n", "      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: 'ref://1',\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n", "          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n", "        },\n\t      ],\n\t    })\n\t  })\n\t  test('convert propertyName to camelCase', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()]).parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('user_scores', refs, { toCamelCase: true }), {\n\t      type: 'tuple',\n\t      fieldName: 'user_scores',\n", "      propertyName: 'userScores',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: 'ref://1',\n\t      properties: [\n\t        {\n\t          type: 'literal',\n", "          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n", "            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('check if value is an array using IS_OF_TYPE method', ({ assert }) => {\n\t    const schema = vine.tuple([])\n\t    assert.isTrue(schema[IS_OF_TYPE]([]))\n", "    assert.isFalse(schema[IS_OF_TYPE]({}))\n\t    assert.isFalse(schema[IS_OF_TYPE](null))\n\t    assert.isFalse(schema[IS_OF_TYPE](undefined))\n\t    assert.isFalse(schema[IS_OF_TYPE](''))\n\t  })\n\t})\n\ttest.group('VineTuple | clone', () => {\n\t  test('clone tuple', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([])\n", "    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      parseFnId: undefined,\n\t      properties: [],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [],\n\t    })\n\t  })\n\t  test('clone tuple with elements', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()])\n\t    const schema1 = schema.clone()\n", "    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n", "      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n", "              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n", "      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n", "        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n", "    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()])\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n", "      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string(), vine.number()])\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n", "          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n", "          ],\n\t          parseFnId: undefined,\n\t        },\n\t        {\n\t          type: 'literal',\n\t          fieldName: '1',\n\t          propertyName: '1',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n", "            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://3',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t        {\n\t          type: 'literal',\n", "          fieldName: '1',\n\t          propertyName: '1',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://4',\n", "            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and allow unknown properties', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()])\n", "    const schema1 = schema.clone().allowUnknownProperties()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n", "      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n", "            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n", "    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n", "      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n", "              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n", "  test('clone and disable bail mode', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()])\n\t    const schema1 = schema.clone().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n", "      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n", "          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n", "        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: false,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('clone and define parser', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()])\n\t    const schema1 = schema.clone().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n", "          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n", "            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: 'ref://2',\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n", "          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://3',\n\t            },\n", "          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('allow unknown properties and clone', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()]).allowUnknownProperties()\n\t    const schema1 = schema.clone()\n", "    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n", "      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n", "              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n", "      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      allowUnknownProperties: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n", "        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n", "              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('allow nullable modifier and clone', ({ assert }) => {\n", "    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()]).nullable()\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: false,\n", "      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n", "      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: true,\n\t      allowUnknownProperties: false,\n", "      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('allow optional modifier and clone', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.tuple([vine.string()]).optional()\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n", "          propertyName: '0',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://1',\n\t            },\n", "          ],\n\t          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'tuple',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: true,\n\t      isOptional: true,\n\t      allowUnknownProperties: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      properties: [\n\t        {\n\t          type: 'literal',\n\t          fieldName: '0',\n\t          propertyName: '0',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n\t              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n", "          parseFnId: undefined,\n\t        },\n\t      ],\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/boolean.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { Vine } from '../../../src/vine/main.js'\n\timport { IS_OF_TYPE, PARSE } from '../../../src/symbols.js'\n\timport { booleanRule } from '../../../src/schema/boolean/rules.js'\n\tconst vine = new Vine()\n\ttest.group('VineBoolean', () => {\n\t  test('create boolean schema', ({ assert }) => {\n\t    const schema = vine.boolean()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "        },\n\t      ],\n\t    })\n\t  })\n\t  test('create boolean schema in strict mode', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.boolean({ strict: true })\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "        },\n\t      ],\n\t    })\n\t    const rule = booleanRule({ strict: true })\n\t    assert.deepEqual(refs.toJSON()['ref://1'], {\n\t      validator: rule.rule.validator,\n\t      options: rule.options,\n\t    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n", "    const schema = vine.boolean().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply optional modifier', ({ assert }) => {\n\t    const schema = vine.boolean().optional()\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const schema = vine.boolean().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n", "          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply parser', ({ assert }) => {\n\t    const schema = vine.boolean().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply transformer', ({ assert }) => {\n\t    const schema = vine.boolean().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('check if value is a boolean using IS_OF_TYPE method', ({ assert }) => {\n\t    const schema = vine.boolean()\n\t    const schema1 = vine.boolean({ strict: true })\n\t    assert.isTrue(schema[IS_OF_TYPE](true))\n\t    assert.isTrue(schema[IS_OF_TYPE](false))\n", "    assert.isTrue(schema[IS_OF_TYPE](0))\n\t    assert.isTrue(schema[IS_OF_TYPE](1))\n\t    assert.isTrue(schema[IS_OF_TYPE]('true'))\n\t    assert.isTrue(schema[IS_OF_TYPE]('false'))\n\t    assert.isTrue(schema[IS_OF_TYPE]('on'))\n\t    assert.isFalse(schema[IS_OF_TYPE](null))\n\t    assert.isFalse(schema[IS_OF_TYPE](undefined))\n\t    assert.isFalse(schema[IS_OF_TYPE](''))\n\t    assert.isTrue(schema1[IS_OF_TYPE](true))\n\t    assert.isTrue(schema1[IS_OF_TYPE](false))\n", "    assert.isFalse(schema1[IS_OF_TYPE](0))\n\t    assert.isFalse(schema1[IS_OF_TYPE](1))\n\t    assert.isFalse(schema1[IS_OF_TYPE]('true'))\n\t    assert.isFalse(schema1[IS_OF_TYPE]('false'))\n\t    assert.isFalse(schema1[IS_OF_TYPE]('on'))\n\t    assert.isFalse(schema1[IS_OF_TYPE](null))\n\t    assert.isFalse(schema1[IS_OF_TYPE](undefined))\n\t    assert.isFalse(schema1[IS_OF_TYPE](''))\n\t  })\n\t})\n", "test.group('VineBoolean | clone', () => {\n\t  test('clone boolean schema', ({ assert }) => {\n\t    const schema = vine.boolean()\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.boolean()\n\t    const schema1 = schema.clone().nullable()\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const schema = vine.boolean()\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n", "      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n", "    const schema = vine.boolean()\n\t    const schema1 = schema.clone().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply transformer', ({ assert }) => {\n\t    const schema = vine.boolean()\n\t    const schema1 = schema.clone().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n", "      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('clone and apply parser', ({ assert }) => {\n\t    const schema = vine.boolean()\n\t    const schema1 = schema.clone().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone strict mode boolean', ({ assert }) => {\n\t    const refs = refsBuilder()\n", "    const schema = vine.boolean({ strict: true })\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t    })\n\t    const rule = booleanRule({ strict: true })\n\t    assert.deepEqual(refs.toJSON()['ref://1'], {\n\t      validator: rule.rule.validator,\n\t      options: rule.options,\n\t    })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n", "      validator: rule.rule.validator,\n\t      options: rule.options,\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/native_enum.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { PARSE } from '../../../src/symbols.js'\n\timport { Vine } from '../../../src/vine/main.js'\n\tconst vine = new Vine()\n\tenum Role {\n\t  GUEST = 'guest',\n\t  MODERATOR = 'moderator',\n\t  ADMIN = 'admin',\n\t}\n\ttest.group('VineNativeEnum', () => {\n\t  test('create enum schema', ({ assert }) => {\n", "    const schema = vine.enum(Role)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.enum(Role).nullable()\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply optional modifier', ({ assert }) => {\n\t    const schema = vine.enum(Role).optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n", "          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const schema = vine.enum(Role).bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply transformer', ({ assert }) => {\n\t    const schema = vine.enum(Role).transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('apply parser', ({ assert }) => {\n\t    const schema = vine.enum(Role).parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n", "        },\n\t      ],\n\t    })\n\t  })\n\t})\n\ttest.group('VineNativeEnum | clone', () => {\n\t  test('clone enum schema', ({ assert }) => {\n\t    const schema = vine.enum(Role)\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n", "          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t  test('clone and apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.enum(Role)\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n", "      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n", "    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: true,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const schema = vine.enum(Role)\n", "    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n", "        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: true,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n\t    const schema = vine.enum(Role)\n\t    const schema1 = schema.clone().bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: false,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n", "  test('clone and apply transformer', ({ assert }) => {\n\t    const schema = vine.enum(Role)\n\t    const schema1 = schema.clone().transform(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n", "      parseFnId: undefined,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      transformFnId: 'ref://2',\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t  })\n\t  test('clone and apply parser', ({ assert }) => {\n\t    const schema = vine.enum(Role)\n\t    const schema1 = schema.clone().parse(() => {})\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: undefined,\n\t      validations: [\n\t        {\n", "          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t        },\n\t      ],\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'literal',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      allowNull: false,\n\t      isOptional: false,\n\t      bail: true,\n\t      parseFnId: 'ref://1',\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n", "      ],\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/array.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n\timport { Vine } from '../../../src/vine/main.js'\n", "import type { RuleBuilder } from '../../../src/types.js'\n\timport { IS_OF_TYPE, PARSE, VALIDATION } from '../../../src/symbols.js'\n\timport {\n\t  compactRule,\n\t  distinctRule,\n\t  notEmptyRule,\n\t  maxLengthRule,\n\t  minLengthRule,\n\t  fixedLengthRule,\n\t} from '../../../src/schema/array/rules.js'\n", "const vine = new Vine()\n\ttest.group('VineArray', () => {\n\t  test('construct array schema', ({ assert }) => {\n\t    const schema = vine.array(\n\t      vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t    )\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n", "        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n", "          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n", "                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t  test('apply nullable modifier', ({ assert }) => {\n\t    const schema = vine\n\t      .array(\n\t        vine.object({\n", "          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n\t      .nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: true,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n", "        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n", "            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n", "    })\n\t  })\n\t  test('apply optional modifier', ({ assert }) => {\n\t    const schema = vine\n\t      .array(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n", "      .optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n", "      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n", "        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t  test('disable bail mode', ({ assert }) => {\n\t    const schema = vine\n", "      .array(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n\t      .bail(false)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: false,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n", "        ],\n\t      },\n\t    })\n\t  })\n\t  test('apply rules', ({ assert }) => {\n\t    const schema = vine\n\t      .array(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n", "        })\n\t      )\n\t      .minLength(10)\n\t      .maxLength(20)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n", "      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://3',\n\t        },\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://4',\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n", "        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n", "            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n", "    })\n\t  })\n\t  test('define parser', ({ assert }) => {\n\t    const schema = vine\n\t      .array(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n", "      .parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: 'ref://3',\n", "      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n", "        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t  test('convert property name to camelcase', ({ assert }) => {\n\t    const schema = vine\n", "      .array(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n\t      .parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('app_users', refsBuilder(), { toCamelCase: true }), {\n\t      type: 'array',\n\t      fieldName: 'app_users',\n", "      propertyName: 'appUsers',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: 'ref://3',\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n", "        ],\n\t      },\n\t    })\n\t  })\n\t  test('check if value is an array using IS_OF_TYPE method', ({ assert }) => {\n\t    const schema = vine.array(\n\t      vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n", "    )\n\t    assert.isTrue(schema[IS_OF_TYPE]([]))\n\t    assert.isFalse(schema[IS_OF_TYPE]({}))\n\t    assert.isFalse(schema[IS_OF_TYPE](null))\n\t    assert.isFalse(schema[IS_OF_TYPE](undefined))\n\t    assert.isFalse(schema[IS_OF_TYPE](''))\n\t  })\n\t})\n\ttest.group('VineArray | clone', () => {\n\t  test('clone array schema', ({ assert }) => {\n", "    const schema = vine.array(\n\t      vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t    )\n\t    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n", "        ],\n\t      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n", "        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n", "          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n", "                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n", "  test('clone and apply nullable modifier', ({ assert }) => {\n\t    const schema = vine.array(\n\t      vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t    )\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n", "        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n", "            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n", "                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n", "            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n", "          },\n\t        ],\n\t      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n", "      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n", "        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n", "            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n", "          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n", "              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n", "  })\n\t  test('clone and apply optional modifier', ({ assert }) => {\n\t    const schema = vine.array(\n\t      vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t    )\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n", "      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n", "        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n", "          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n", "                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: false,\n\t      isOptional: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n", "        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n", "            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n", "    })\n\t  })\n\t  test('clone and disable bail mode', ({ assert }) => {\n\t    const schema = vine.array(\n\t      vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t    )\n\t    const schema1 = schema.clone().bail(false)\n", "    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n", "        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n", "        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n", "              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n", "            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n", "              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: false,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n", "        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n", "            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n", "              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n", "            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n", "      },\n\t    })\n\t  })\n\t  test('clone and apply rules', ({ assert }) => {\n\t    const schema = vine\n\t      .array(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n", "      )\n\t      .minLength(10)\n\t    const schema1 = schema.clone().maxLength(20)\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n", "      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://3',\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n", "        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n", "          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n", "                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://3',\n\t        },\n\t        {\n\t          implicit: false,\n", "          isAsync: false,\n\t          ruleFnId: 'ref://4',\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n", "        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n", "            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n", "              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n", "            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n", "      },\n\t    })\n\t  })\n\t  test('clone and define parser', ({ assert }) => {\n\t    const schema = vine.array(\n\t      vine.object({\n\t        username: vine.string(),\n\t        password: vine.string(),\n\t      })\n\t    )\n", "    const schema1 = schema.clone().parse(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n", "      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n", "        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [],\n\t      parseFnId: 'ref://3',\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n", "        ],\n\t      },\n\t    })\n\t  })\n\t  test('apply nullable modifier and clone', ({ assert }) => {\n\t    const schema = vine\n\t      .array(\n\t        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n", "        })\n\t      )\n\t      .nullable()\n\t    const schema1 = schema.clone().optional()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n", "      isOptional: false,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n", "        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n", "            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n", "          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n", "              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n", "    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n", "        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n", "        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n", "              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n", "            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n", "              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n\t  test('apply optional modifier and clone', ({ assert }) => {\n\t    const schema = vine\n\t      .array(\n", "        vine.object({\n\t          username: vine.string(),\n\t          password: vine.string(),\n\t        })\n\t      )\n\t      .optional()\n\t    const schema1 = schema.clone().nullable()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: true,\n\t      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n", "        ],\n\t      },\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: true,\n\t      isOptional: true,\n", "      validations: [],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'object',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n", "        validations: [],\n\t        groups: [],\n\t        parseFnId: undefined,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n\t            bail: true,\n\t            allowNull: false,\n", "            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t              },\n\t            ],\n\t          },\n", "          {\n\t            type: 'literal',\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            validations: [\n\t              {\n", "                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t  })\n", "})\n\ttest.group('VineArray | applying rules', () => {\n\t  test('apply minLength rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.array(vine.string()).minLength(2)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n", "      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n", "      each: {\n\t        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: undefined,\n\t        validations: [\n\t          {\n", "            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const minLength = minLengthRule({ min: 2 })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: minLength.rule.validator,\n", "      options: minLength.options,\n\t    })\n\t  })\n\t  test('apply maxLength rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.array(vine.string()).maxLength(2)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n", "      parseFnId: undefined,\n\t      each: {\n\t        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: undefined,\n\t        validations: [\n", "          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const minLength = maxLengthRule({ max: 2 })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n", "      validator: minLength.rule.validator,\n\t      options: minLength.options,\n\t    })\n\t  })\n\t  test('apply fixedLength rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.array(vine.string()).fixedLength(2)\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n", "      ],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: undefined,\n", "        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const minLength = fixedLengthRule({ size: 2 })\n", "    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: minLength.rule.validator,\n\t      options: minLength.options,\n\t    })\n\t  })\n\t  test('apply notEmpty rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.array(vine.string()).notEmpty()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'array',\n", "      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n", "        },\n\t      ],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n", "        parseFnId: undefined,\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n\t        ],\n\t      },\n\t    })\n", "    const minLength = notEmptyRule()\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: minLength.rule.validator,\n\t      options: minLength.options,\n\t    })\n\t  })\n\t  test('apply distinct rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.array(vine.string()).distinct()\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n", "      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n", "          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n", "        isOptional: false,\n\t        parseFnId: undefined,\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n\t        ],\n\t      },\n", "    })\n\t    const minLength = distinctRule({ fields: undefined })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: minLength.rule.validator,\n\t      options: minLength.options,\n\t    })\n\t  })\n\t  test('apply compact rule', ({ assert }) => {\n\t    const refs = refsBuilder()\n\t    const schema = vine.array(vine.string()).compact()\n", "    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n", "          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n\t      parseFnId: undefined,\n\t      each: {\n\t        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n", "        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: undefined,\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const minLength = compactRule()\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n\t      validator: minLength.rule.validator,\n\t      options: minLength.options,\n\t    })\n\t  })\n\t  test('register rule via rule builder', ({ assert }) => {\n\t    const refs = refsBuilder()\n", "    class LengthAwareValidator implements RuleBuilder {\n\t      [VALIDATION]() {\n\t        return minLengthRule({ min: 2 })\n\t      }\n\t    }\n\t    const schema = vine.array(vine.string()).use(new LengthAwareValidator())\n\t    assert.deepEqual(schema[PARSE]('*', refs, { toCamelCase: false }), {\n\t      type: 'array',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      validations: [\n\t        {\n\t          implicit: false,\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t        },\n\t      ],\n", "      parseFnId: undefined,\n\t      each: {\n\t        type: 'literal',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        bail: true,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: undefined,\n\t        validations: [\n", "          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const minLength = minLengthRule({ min: 2 })\n\t    assert.deepEqual(refs.toJSON()['ref://2'], {\n", "      validator: minLength.rule.validator,\n\t      options: minLength.options,\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/schema/union_of_types.spec.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '@vinejs/compiler'\n", "import { PARSE } from '../../../src/symbols.js'\n\timport { Vine } from '../../../src/vine/main.js'\n\tconst vine = new Vine()\n\ttest.group('Vine UnionOfTypes', () => {\n\t  test('construct union schema', ({ assert }) => {\n\t    const schema = vine.unionOfTypes([vine.boolean(), vine.string()])\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'union',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            allowNull: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: '*',\n", "            type: 'literal',\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://3',\n\t              },\n\t            ],\n\t          },\n\t        },\n", "        {\n\t          conditionalFnRefId: 'ref://4',\n\t          schema: {\n\t            allowNull: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: '*',\n\t            type: 'literal',\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://5',\n\t              },\n\t            ],\n\t          },\n\t        },\n\t      ],\n", "      elseConditionalFnRefId: 'ref://1',\n\t    })\n\t  })\n\t  test('clone schema', ({ assert }) => {\n\t    const schema = vine.unionOfTypes([vine.boolean(), vine.string()])\n\t    const schema1 = schema.clone().otherwise(() => {})\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'union',\n\t      fieldName: '*',\n\t      propertyName: '*',\n", "      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            allowNull: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: '*',\n", "            type: 'literal',\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://3',\n\t              },\n\t            ],\n\t          },\n\t        },\n", "        {\n\t          conditionalFnRefId: 'ref://4',\n\t          schema: {\n\t            allowNull: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: '*',\n\t            type: 'literal',\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://5',\n\t              },\n\t            ],\n\t          },\n\t        },\n\t      ],\n", "      elseConditionalFnRefId: 'ref://1',\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'union',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n", "            allowNull: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: '*',\n\t            type: 'literal',\n\t            validations: [\n\t              {\n\t                implicit: false,\n", "                isAsync: false,\n\t                ruleFnId: 'ref://3',\n\t              },\n\t            ],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://4',\n\t          schema: {\n\t            allowNull: false,\n", "            bail: true,\n\t            fieldName: '*',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: '*',\n\t            type: 'literal',\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://5',\n\t              },\n\t            ],\n\t          },\n\t        },\n\t      ],\n\t      elseConditionalFnRefId: 'ref://1',\n\t    })\n\t  })\n\t  test('apply camelcase transform to propertyName', ({ assert }) => {\n", "    const schema = vine.unionOfTypes([vine.boolean(), vine.string()])\n\t    assert.deepEqual(schema[PARSE]('health_check', refsBuilder(), { toCamelCase: true }), {\n\t      type: 'union',\n\t      fieldName: 'health_check',\n\t      propertyName: 'healthCheck',\n\t      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            allowNull: false,\n", "            bail: true,\n\t            fieldName: 'health_check',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: 'healthCheck',\n\t            type: 'literal',\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://3',\n\t              },\n\t            ],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://4',\n\t          schema: {\n\t            allowNull: false,\n\t            bail: true,\n", "            fieldName: 'health_check',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: 'healthCheck',\n\t            type: 'literal',\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://5',\n", "              },\n\t            ],\n\t          },\n\t        },\n\t      ],\n\t      elseConditionalFnRefId: 'ref://1',\n\t    })\n\t  })\n\t  test('copy otherwise callback to the cloned schema', ({ assert }) => {\n\t    const schema = vine.unionOfTypes([vine.boolean(), vine.string()]).otherwise(() => {})\n", "    const schema1 = schema.clone()\n\t    assert.deepEqual(schema[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'union',\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            allowNull: false,\n", "            bail: true,\n\t            fieldName: '*',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: '*',\n\t            type: 'literal',\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n", "                ruleFnId: 'ref://3',\n\t              },\n\t            ],\n\t          },\n\t        },\n\t        {\n\t          conditionalFnRefId: 'ref://4',\n\t          schema: {\n\t            allowNull: false,\n\t            bail: true,\n", "            fieldName: '*',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: '*',\n\t            type: 'literal',\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://5',\n", "              },\n\t            ],\n\t          },\n\t        },\n\t      ],\n\t      elseConditionalFnRefId: 'ref://1',\n\t    })\n\t    assert.deepEqual(schema1[PARSE]('*', refsBuilder(), { toCamelCase: false }), {\n\t      type: 'union',\n\t      fieldName: '*',\n", "      propertyName: '*',\n\t      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            allowNull: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n", "            propertyName: '*',\n\t            type: 'literal',\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://3',\n\t              },\n\t            ],\n\t          },\n", "        },\n\t        {\n\t          conditionalFnRefId: 'ref://4',\n\t          schema: {\n\t            allowNull: false,\n\t            bail: true,\n\t            fieldName: '*',\n\t            isOptional: false,\n\t            parseFnId: undefined,\n\t            propertyName: '*',\n", "            type: 'literal',\n\t            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://5',\n\t              },\n\t            ],\n\t          },\n\t        },\n", "      ],\n\t      elseConditionalFnRefId: 'ref://1',\n\t    })\n\t  })\n\t})\n"]}
{"filename": "benchmarks/nested_object.ts", "chunked_list": ["// @ts-ignore\n\timport Benchmark from 'benchmark'\n\timport { z } from 'zod'\n\timport yup from 'yup'\n\timport vine from '../index.js'\n\tfunction getData() {\n\t  return {\n\t    username: 'virk',\n\t    password: 'secret',\n\t    contact: {\n", "      name: 'virk',\n\t      address: 'universe',\n\t    },\n\t  }\n\t}\n\tconst zodSchema = z.object({\n\t  username: z.string(),\n\t  password: z.string(),\n\t  contact: z.object({\n\t    name: z.string(),\n", "    address: z.string().optional(),\n\t  }),\n\t})\n\tconst yupSchema = yup\n\t  .object({\n\t    username: yup.string().required(),\n\t    password: yup.string().required(),\n\t    contact: yup\n\t      .object({\n\t        name: yup.string().required(),\n", "        address: yup.string(),\n\t      })\n\t      .required(),\n\t  })\n\t  .required()\n\tconst vineSchema = vine.compile(\n\t  vine.object({\n\t    username: vine.string(),\n\t    password: vine.string(),\n\t    contact: vine.object({\n", "      name: vine.string(),\n\t      address: vine.string().optional(),\n\t    }),\n\t  })\n\t)\n\tconsole.log('=================================')\n\tconsole.log('Benchmarking with nested object')\n\tconsole.log('=================================')\n\tconst suite = new Benchmark.Suite()\n\tsuite\n", "  .add('Vine', {\n\t    defer: true,\n\t    fn: function (deferred: any) {\n\t      vineSchema\n\t        .validate(getData())\n\t        .then(() => deferred.resolve())\n\t        .catch(console.log)\n\t    },\n\t  })\n\t  .add('Zod', {\n", "    defer: true,\n\t    fn: function (deferred: any) {\n\t      zodSchema\n\t        .parseAsync(getData())\n\t        .then(() => deferred.resolve())\n\t        .catch(console.log)\n\t    },\n\t  })\n\t  .add('Yup', {\n\t    defer: true,\n", "    fn: function (deferred: any) {\n\t      yupSchema\n\t        .validate(getData())\n\t        .then(() => deferred.resolve())\n\t        .catch(console.log)\n\t    },\n\t  })\n\t  .on('cycle', function (event: any) {\n\t    console.log(String(event.target))\n\t  })\n", "  .on('complete', function (this: any) {\n\t    console.log('Fastest is ' + this.filter('fastest').map('name'))\n\t  })\n\t  .run({ async: false })\n"]}
{"filename": "benchmarks/array.ts", "chunked_list": ["// @ts-ignore\n\timport Benchmark from 'benchmark'\n\timport { z } from 'zod'\n\timport yup from 'yup'\n\timport vine from '../index.js'\n\tfunction getData() {\n\t  return {\n\t    contacts: [\n\t      {\n\t        type: 'email',\n", "        value: 'foo@bar.com',\n\t      },\n\t      {\n\t        type: 'phone',\n\t        value: '12345678',\n\t      },\n\t    ],\n\t  }\n\t}\n\tconst zodSchema = z.object({\n", "  contacts: z.array(\n\t    z.object({\n\t      type: z.string(),\n\t      value: z.string(),\n\t    })\n\t  ),\n\t})\n\tconst yupSchema = yup\n\t  .object({\n\t    contacts: yup\n", "      .array(\n\t        yup\n\t          .object({\n\t            type: yup.string().required(),\n\t            value: yup.string().required(),\n\t          })\n\t          .required()\n\t      )\n\t      .required(),\n\t  })\n", "  .required()\n\tconst vineSchema = vine.compile(\n\t  vine.object({\n\t    contacts: vine.array(\n\t      vine.object({\n\t        type: vine.string(),\n\t        value: vine.string(),\n\t      })\n\t    ),\n\t  })\n", ")\n\tconsole.log('======================')\n\tconsole.log('Benchmarking arrays')\n\tconsole.log('======================')\n\tconst suite = new Benchmark.Suite()\n\tsuite\n\t  .add('Vine', {\n\t    defer: true,\n\t    fn: function (deferred: any) {\n\t      vineSchema\n", "        .validate(getData())\n\t        .then(() => deferred.resolve())\n\t        .catch(console.log)\n\t    },\n\t  })\n\t  .add('Zod', {\n\t    defer: true,\n\t    fn: function (deferred: any) {\n\t      zodSchema\n\t        .parseAsync(getData())\n", "        .then(() => deferred.resolve())\n\t        .catch(console.log)\n\t    },\n\t  })\n\t  .add('Yup', {\n\t    defer: true,\n\t    fn: function (deferred: any) {\n\t      yupSchema\n\t        .validate(getData())\n\t        .then(() => deferred.resolve())\n", "        .catch(console.log)\n\t    },\n\t  })\n\t  .on('cycle', function (event: any) {\n\t    console.log(String(event.target))\n\t  })\n\t  .on('complete', function (this: any) {\n\t    console.log('Fastest is ' + this.filter('fastest').map('name'))\n\t  })\n\t  .run({ async: false })\n"]}
{"filename": "benchmarks/union.ts", "chunked_list": ["// @ts-ignore\n\timport Benchmark from 'benchmark'\n\timport { z } from 'zod'\n\timport vine from '../index.js'\n\tfunction getData() {\n\t  return {\n\t    contact: {\n\t      type: 'phone',\n\t      mobile_number: '9210210102',\n\t    },\n", "  }\n\t}\n\tconst zodSchema = z.object({\n\t  contact: z.union([\n\t    z.object({\n\t      type: z.literal('email'),\n\t      email: z.string(),\n\t    }),\n\t    z.object({\n\t      type: z.literal('phone'),\n", "      mobile_number: z.string(),\n\t    }),\n\t  ]),\n\t})\n\tconst vineSchema = vine.compile(\n\t  vine.object({\n\t    contact: vine.union([\n\t      vine.union.if(\n\t        (value) => vine.helpers.isObject(value) && value.type === 'email',\n\t        vine.object({\n", "          type: vine.literal('email'),\n\t          email: vine.string(),\n\t        })\n\t      ),\n\t      vine.union.if(\n\t        (value) => vine.helpers.isObject(value) && value.type === 'phone',\n\t        vine.object({\n\t          type: vine.literal('phone'),\n\t          mobile_number: vine.string(),\n\t        })\n", "      ),\n\t    ]),\n\t  })\n\t)\n\tconsole.log('=======================')\n\tconsole.log('Benchmarking unions')\n\tconsole.log('=======================')\n\tconst suite = new Benchmark.Suite()\n\tsuite\n\t  .add('Vine', {\n", "    defer: true,\n\t    fn: function (deferred: any) {\n\t      vineSchema\n\t        .validate(getData())\n\t        .then(() => deferred.resolve())\n\t        .catch(console.log)\n\t    },\n\t  })\n\t  .add('Zod', {\n\t    defer: true,\n", "    fn: function (deferred: any) {\n\t      zodSchema\n\t        .parseAsync(getData())\n\t        .then(() => deferred.resolve())\n\t        .catch(console.log)\n\t    },\n\t  })\n\t  .on('cycle', function (event: any) {\n\t    console.log(String(event.target))\n\t  })\n", "  .on('complete', function (this: any) {\n\t    console.log('Fastest is ' + this.filter('fastest').map('name'))\n\t  })\n\t  .run({ async: false })\n"]}
{"filename": "benchmarks/flat_object.ts", "chunked_list": ["// @ts-ignore\n\timport Benchmark from 'benchmark'\n\timport { z } from 'zod'\n\timport yup from 'yup'\n\timport vine from '../index.js'\n\tfunction getData() {\n\t  return {\n\t    username: 'virk',\n\t    password: 'secret',\n\t  }\n", "}\n\tconst zodSchema = z.object({\n\t  username: z.string(),\n\t  password: z.string(),\n\t})\n\tconst yupSchema = yup\n\t  .object({\n\t    username: yup.string().required(),\n\t    password: yup.string().required(),\n\t  })\n", "  .required()\n\tconst vineSchema = vine.compile(\n\t  vine.object({\n\t    username: vine.string(),\n\t    password: vine.string(),\n\t  })\n\t)\n\tconsole.log('===============================')\n\tconsole.log('Benchmarking with flat object')\n\tconsole.log('===============================')\n", "const suite = new Benchmark.Suite()\n\tsuite\n\t  .add('Vine', {\n\t    defer: true,\n\t    fn: function (deferred: any) {\n\t      vineSchema\n\t        .validate(getData())\n\t        .then(() => deferred.resolve())\n\t        .catch(console.log)\n\t    },\n", "  })\n\t  .add('Zod', {\n\t    defer: true,\n\t    fn: function (deferred: any) {\n\t      zodSchema\n\t        .parseAsync(getData())\n\t        .then(() => deferred.resolve())\n\t        .catch(console.log)\n\t    },\n\t  })\n", "  .add('Yup', {\n\t    defer: true,\n\t    fn: function (deferred: any) {\n\t      yupSchema\n\t        .validate(getData())\n\t        .then(() => deferred.resolve())\n\t        .catch(console.log)\n\t    },\n\t  })\n\t  .on('cycle', function (event: any) {\n", "    console.log(String(event.target))\n\t  })\n\t  .on('complete', function (this: any) {\n\t    console.log('Fastest is ' + this.filter('fastest').map('name'))\n\t  })\n\t  .run({ async: false })\n"]}
{"filename": "factories/main.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { FieldFactory } from './field.js'\n\timport { ValidatorFactory } from './validator.js'\n", "/**\n\t * Validator factory is used for unit testing validation\n\t * rules.\n\t */\n\texport const validator = new ValidatorFactory()\n\texport const fieldContext = new FieldFactory()\n"]}
{"filename": "factories/field.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { ErrorReporterContract } from '@vinejs/compiler/types'\n\timport { helpers } from '../src/vine/helpers.js'\n", "import type { FieldContext, MessagesProviderContact } from '../src/types.js'\n\timport { SimpleErrorReporter } from '../src/reporters/simple_error_reporter.js'\n\timport { SimpleMessagesProvider } from '../src/messages_provider/simple_messages_provider.js'\n\t/**\n\t * Exposes API to create a dummy field context\n\t */\n\texport class FieldFactory {\n\t  create(\n\t    fieldName: string,\n\t    value: any,\n", "    messagesProvider?: MessagesProviderContact,\n\t    errorReporter?: ErrorReporterContract\n\t  ) {\n\t    const reporter = errorReporter || new SimpleErrorReporter()\n\t    const provider = messagesProvider || new SimpleMessagesProvider({}, {})\n\t    return {\n\t      value: value,\n\t      isArrayMember: false,\n\t      parent: { [fieldName]: value } as any,\n\t      data: { [fieldName]: value },\n", "      name: fieldName as any,\n\t      wildCardPath: fieldName,\n\t      isDefined: helpers.exists(value),\n\t      isValid: true,\n\t      meta: {},\n\t      mutate(newValue) {\n\t        this.value = newValue\n\t        this.isDefined = helpers.exists(newValue)\n\t        return this\n\t      },\n", "      report(message, rule, context, args) {\n\t        this.isValid = false\n\t        reporter.report(provider.getMessage(message, rule, context, args), rule, context, args)\n\t      },\n\t    } satisfies FieldContext\n\t  }\n\t}\n"]}
{"filename": "factories/validator.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { AssertionError, deepEqual } from 'node:assert'\n\timport { FieldFactory } from './field.js'\n", "import type { FieldContext, Validation } from '../src/types.js'\n\timport { SimpleErrorReporter } from '../src/reporters/simple_error_reporter.js'\n\t/**\n\t * Exposes APIs for writing validation assertions\n\t */\n\tclass ValidationResult {\n\t  #outputValue: any\n\t  #reporter: SimpleErrorReporter\n\t  constructor(outputValue: any, reporter: SimpleErrorReporter) {\n\t    this.#outputValue = outputValue\n", "    this.#reporter = reporter\n\t  }\n\t  /**\n\t   * Creates an assertion error instance\n\t   */\n\t  #assertionError(\n\t    options: ConstructorParameters<typeof AssertionError>[0] & { showDiff?: boolean }\n\t  ) {\n\t    const assertion = new AssertionError(options)\n\t    Object.defineProperty(assertion, 'showDiff', { value: true })\n", "    return assertion\n\t  }\n\t  /**\n\t   * Returns the validation result output\n\t   */\n\t  getOutput() {\n\t    return this.#outputValue\n\t  }\n\t  /**\n\t   * Returns an array of errors reported to the\n", "   * error reporter\n\t   */\n\t  getErrors() {\n\t    return this.#reporter.errors\n\t  }\n\t  /**\n\t   * Assert one or more validation errors have occurred\n\t   */\n\t  assertSucceeded() {\n\t    if (this.#reporter.hasErrors) {\n", "      const errorsCount = this.#reporter.errors.length\n\t      throw this.#assertionError({\n\t        message: `Expected validation to pass. Instead failed with \"${errorsCount} error(s)\"`,\n\t        operator: 'strictEqual',\n\t        stackStartFn: this.assertSucceeded,\n\t      })\n\t    }\n\t  }\n\t  /**\n\t   * Assert the output value of validation. The output value is\n", "   * same as the input value, unless \"mutate\" method is called\n\t   */\n\t  assertOutput(expectedOutput: any) {\n\t    deepEqual(this.#outputValue, expectedOutput)\n\t  }\n\t  /**\n\t   * Assert one or more validation errors have occurred\n\t   */\n\t  assertFailed() {\n\t    if (!this.#reporter.hasErrors) {\n", "      throw this.#assertionError({\n\t        message: `Expected validation to report one or more errors`,\n\t        operator: 'strictEqual',\n\t        stackStartFn: this.assertFailed,\n\t      })\n\t    }\n\t  }\n\t  /**\n\t   * Assert the number of errors have occurred\n\t   */\n", "  assertErrorsCount(count: number) {\n\t    const errorsCount = this.#reporter.errors.length\n\t    if (errorsCount !== count) {\n\t      throw this.#assertionError({\n\t        message: `Expected validation to report \"${count}\" errors. Received \"${errorsCount}\"`,\n\t        expected: count,\n\t        actual: errorsCount,\n\t        operator: 'strictEqual',\n\t        stackStartFn: this.assertErrorsCount,\n\t        showDiff: true,\n", "      })\n\t    }\n\t  }\n\t  /**\n\t   * Assert error messages to include a given error message\n\t   */\n\t  assertError(message: string) {\n\t    const messages = this.#reporter.errors.map((e) => e.message)\n\t    if (!messages.includes(message)) {\n\t      throw this.#assertionError({\n", "        message: `Expected validation errors to include \"${message}\" message`,\n\t        expected: [message],\n\t        actual: messages,\n\t        operator: 'includes',\n\t        stackStartFn: this.assertError,\n\t        showDiff: true,\n\t      })\n\t    }\n\t  }\n\t}\n", "/**\n\t * Validator factory exposes the API to execute validations\n\t * during tests\n\t */\n\texport class ValidatorFactory {\n\t  #field?: Partial<FieldContext>\n\t  #bail?: boolean\n\t  constructor(field?: Partial<FieldContext>, bail?: boolean) {\n\t    this.#field = field\n\t    this.#bail = bail\n", "  }\n\t  /**\n\t   * Creates an instance of the error reporter required\n\t   * to report errors.\n\t   */\n\t  #getReporter() {\n\t    return new SimpleErrorReporter()\n\t  }\n\t  /**\n\t   * Define field context for the validation\n", "   */\n\t  withContext(field: Partial<FieldContext>) {\n\t    return new ValidatorFactory(field, this.#bail)\n\t  }\n\t  /**\n\t   * Toggle bail mode for the validation\n\t   */\n\t  bail(state: boolean) {\n\t    return new ValidatorFactory(this.#field, state)\n\t  }\n", "  /**\n\t   * Executes a validation against the provided value\n\t   */\n\t  execute(validation: Validation<any> | Validation<any>[], value: any) {\n\t    const errorReporter = this.#getReporter()\n\t    const bail = this.#bail === false ? false : true\n\t    const field: FieldContext = {\n\t      ...new FieldFactory().create('dummy', value, undefined, errorReporter),\n\t      ...this.#field,\n\t    }\n", "    const validations = Array.isArray(validation) ? validation : [validation]\n\t    for (let one of validations) {\n\t      if (one.rule.isAsync) {\n\t        throw new Error(\n\t          `Cannot execute async rule \"${one.rule.validator.name}\". Use \"validator.executeAsync\" instead`\n\t        )\n\t      }\n\t      if ((field.isDefined || one.rule.implicit) && (field.isValid || !bail)) {\n\t        one.rule.validator(field.value, one.options, field)\n\t      }\n", "    }\n\t    return new ValidationResult(field.value, errorReporter)\n\t  }\n\t  /**\n\t   * Executes an async validation against the provided\n\t   * value\n\t   */\n\t  async executeAsync(validation: Validation<any> | Validation<any>[], value: any) {\n\t    const errorReporter = this.#getReporter()\n\t    const bail = this.#bail === false ? false : true\n", "    const field: FieldContext = {\n\t      ...new FieldFactory().create('dummy', value, undefined, errorReporter),\n\t      ...this.#field,\n\t    }\n\t    const validations = Array.isArray(validation) ? validation : [validation]\n\t    for (let one of validations) {\n\t      if ((field.isDefined || one.rule.implicit) && (field.isValid || !bail)) {\n\t        await one.rule.validator(field.value, one.options, field)\n\t      }\n\t    }\n", "    return new ValidationResult(field.value, errorReporter)\n\t  }\n\t}\n"]}
{"filename": "src/defaults.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Collection of default error messages to use\n", " */\n\texport const messages = {\n\t  'required': 'The {{ field }} field must be defined',\n\t  'string': 'The {{ field }} field must be a string',\n\t  'email': 'The {{ field }} field must be a valid email address',\n\t  'mobile': 'The {{ field }} field must be a valid mobile phone number',\n\t  'creditCard': 'The {{ field }} field must be a valid {{ providersList }} card number',\n\t  'passport': 'The {{ field }} field must be a valid passport number',\n\t  'postalCode': 'The {{ field }} field must be a valid postal code',\n\t  'regex': 'The {{ field }} field format is invalid',\n", "  'ascii': 'The {{ field }} field must only contain ASCII characters',\n\t  'iban': 'The {{ field }} field must be a valid IBAN number',\n\t  'jwt': 'The {{ field }} field must be a valid JWT token',\n\t  'coordinates': 'The {{ field }} field must contain latitude and longitude coordinates',\n\t  'url': 'The {{ field }} field must be a valid URL',\n\t  'activeUrl': 'The {{ field }} field must be a valid URL',\n\t  'alpha': 'The {{ field }} field must contain only letters',\n\t  'alphaNumeric': 'The {{ field }} field must contain only letters and numbers',\n\t  'minLength': 'The {{ field }} field must have at least {{ min }} characters',\n\t  'maxLength': 'The {{ field }} field must not be greater than {{ max }} characters',\n", "  'fixedLength': 'The {{ field }} field must be {{ size }} characters long',\n\t  'confirmed': 'The {{ field }} field and {{ otherField }} field must be the same',\n\t  'endsWith': 'The {{ field }} field must end with {{ substring }}',\n\t  'startsWith': 'The {{ field }} field must start with {{ substring }}',\n\t  'sameAs': 'The {{ field }} field and {{ otherField }} field must be the same',\n\t  'notSameAs': 'The {{ field }} field and {{ otherField }} field must be different',\n\t  'in': 'The selected {{ field }} is invalid',\n\t  'notIn': 'The selected {{ field }} is invalid',\n\t  'ipAddress': 'The {{ field }} field must be a valid IP address',\n\t  'uuid': 'The {{ field }} field must be a valid UUID',\n", "  'hexCode': 'The {{ field }} field must be a valid hex color code',\n\t  'boolean': 'The value must be a boolean',\n\t  'number': 'The {{ field }} field must be a number',\n\t  'min': 'The {{ field }} field must be at least {{ min }}',\n\t  'max': 'The {{ field }} field must not be greater than {{ max }}',\n\t  'range': 'The {{ field }} field must be between {{ min }} and {{ max }}',\n\t  'positive': 'The {{ field }} field must be positive',\n\t  'negative': 'The {{ field }} field must be negative',\n\t  'decimal': 'The {{ field }} field must have {{ digits }} decimal places',\n\t  'withoutDecimals': 'The {{ field }} field must be an integer',\n", "  'accepted': 'The {{ field }} field must be accepted',\n\t  'enum': 'The selected {{ field }} is invalid',\n\t  'literal': 'The {{ field }} field must be {{ expectedValue }}',\n\t  'object': 'The {{ field }} field must be an object',\n\t  'array': 'The {{ field }} field must be an array',\n\t  'array.minLength': 'The {{ field }} field must have at least {{ min }} items',\n\t  'array.maxLength': 'The {{ field }} field must not have more than {{ max }} items',\n\t  'array.fixedLength': 'The {{ field }} field must contain {{ size }} items',\n\t  'notEmpty': 'The {{ field }} field must not be empty',\n\t  'distinct': 'The {{ field }} field has duplicate values',\n", "  'record': 'The {{ field }} field must be an object',\n\t  'record.minLength': 'The {{ field }} field must have at least {{ min }} items',\n\t  'record.maxLength': 'The {{ field }} field must not have more than {{ max }} items',\n\t  'record.fixedLength': 'The {{ field }} field must contain {{ size }} items',\n\t  'tuple': 'The {{ field }} field must be an array',\n\t  'union': 'Invalid value provided for {{ field }} field',\n\t  'unionGroup': 'Invalid value provided for {{ field }} field',\n\t  'unionOfTypes': 'Invalid value provided for {{ field }} field',\n\t}\n\t/**\n", " * Collection of default fields\n\t */\n\texport const fields = {\n\t  '': 'data',\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type {\n\t  ParseFn,\n", "  RefsStore,\n\t  TransformFn,\n\t  FieldContext,\n\t  CompilerNodes,\n\t  MessagesProviderContact,\n\t  ErrorReporterContract as BaseReporter,\n\t} from '@vinejs/compiler/types'\n\timport type { Options as UrlOptions } from 'normalize-url'\n\timport type { IsURLOptions } from 'validator/lib/isURL.js'\n\timport type { IsEmailOptions } from 'validator/lib/isEmail.js'\n", "import type { NormalizeEmailOptions } from 'validator/lib/normalizeEmail.js'\n\timport type { IsMobilePhoneOptions, MobilePhoneLocale } from 'validator/lib/isMobilePhone.js'\n\timport type { PostalCodeLocale } from 'validator/lib/isPostalCode.js'\n\timport type { helpers } from './vine/helpers.js'\n\timport type { ValidationError } from './errors/validation_error.js'\n\timport type { OTYPE, COTYPE, PARSE, VALIDATION, UNIQUE_NAME, IS_OF_TYPE } from './symbols.js'\n\t/**\n\t * Options accepted by the mobile number validation\n\t */\n\texport type MobileOptions = { locale?: MobilePhoneLocale[] } & IsMobilePhoneOptions\n", "/**\n\t * Options accepted by the email address validation\n\t */\n\texport type EmailOptions = IsEmailOptions\n\t/**\n\t * Options accepted by the normalize email\n\t */\n\texport { NormalizeEmailOptions }\n\t/**\n\t * Options accepted by the URL validation\n", " */\n\texport type URLOptions = IsURLOptions\n\t/**\n\t * Options accepted by the credit card validation\n\t */\n\texport type CreditCardOptions = {\n\t  provider: ('amex' | 'dinersclub' | 'discover' | 'jcb' | 'mastercard' | 'unionpay' | 'visa')[]\n\t}\n\t/**\n\t * Options accepted by the passport validation\n", " */\n\texport type PassportOptions = {\n\t  countryCode: (typeof helpers)['passportCountryCodes'][number][]\n\t}\n\t/**\n\t * Options accepted by the postal code validation\n\t */\n\texport type PostalCodeOptions = {\n\t  countryCode: PostalCodeLocale[]\n\t}\n", "/**\n\t * Options accepted by the alpha rule\n\t */\n\texport type AlphaOptions = {\n\t  allowSpaces?: boolean\n\t  allowUnderscores?: boolean\n\t  allowDashes?: boolean\n\t}\n\texport type NormalizeUrlOptions = UrlOptions\n\t/**\n", " * Options accepted by the alpha numeric rule\n\t */\n\texport type AlphaNumericOptions = AlphaOptions\n\t/**\n\t * Re-exporting selected types from compiler\n\t */\n\texport type {\n\t  Refs,\n\t  FieldContext,\n\t  RefIdentifier,\n", "  ConditionalFn,\n\t  MessagesProviderContact,\n\t} from '@vinejs/compiler/types'\n\t/**\n\t * Representation of a native enum like type\n\t */\n\texport type EnumLike = { [K: string]: string | number; [number: number]: string }\n\t/**\n\t * Representation of fields and messages accepted by the messages\n\t * provider\n", " */\n\texport type ValidationMessages = Record<string, string>\n\texport type ValidationFields = Record<string, string>\n\t/**\n\t * Constructable schema type refers to any type that can be\n\t * constructed for type inference and compiler output\n\t */\n\texport interface ConstructableSchema<Output, CamelCaseOutput> {\n\t  [OTYPE]: Output\n\t  [COTYPE]: CamelCaseOutput\n", "  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes\n\t  clone(): this\n\t  /**\n\t   * Implement if you want schema type to be used with the unionOfTypes\n\t   */\n\t  [UNIQUE_NAME]?: string\n\t  [IS_OF_TYPE]?: (value: unknown, field: FieldContext) => boolean\n\t}\n\texport type SchemaTypes = ConstructableSchema<any, any>\n\t/**\n", " * Representation of a function that performs validation.\n\t * The function receives the following arguments.\n\t *\n\t * - the current value of the input field\n\t * - runtime options\n\t * - field context\n\t */\n\texport type Validator<Options extends any> = (\n\t  value: unknown,\n\t  options: Options,\n", "  field: FieldContext\n\t) => any | Promise<any>\n\t/**\n\t * A validation rule is a combination of a validator and\n\t * some metadata required at the time of compiling the\n\t * rule.\n\t *\n\t * Think of this type as \"Validator\" + \"metaData\"\n\t */\n\texport type ValidationRule<Options extends any> = {\n", "  validator: Validator<Options>\n\t  isAsync: boolean\n\t  implicit: boolean\n\t}\n\t/**\n\t * Validation is a combination of a validation rule and the options\n\t * to supply to validator at the time of validating the field.\n\t *\n\t * Think of this type as \"ValidationRule\" + \"options\"\n\t */\n", "export type Validation<Options extends any> = {\n\t  /**\n\t   * Options to pass to the validator function.\n\t   */\n\t  options?: Options\n\t  /**\n\t   * The rule to use\n\t   */\n\t  rule: ValidationRule<Options>\n\t}\n", "/**\n\t * A rule builder is an object that implements the \"VALIDATION\"\n\t * method and returns [[Validation]] type\n\t */\n\texport interface RuleBuilder {\n\t  [VALIDATION](): Validation<any>\n\t}\n\t/**\n\t * The transform function to mutate the output value\n\t */\n", "export type Transformer<Schema extends SchemaTypes, Output> = TransformFn<\n\t  Exclude<Schema[typeof OTYPE], undefined>,\n\t  Output\n\t>\n\t/**\n\t * The parser function to mutate the input value\n\t */\n\texport type Parser = ParseFn\n\t/**\n\t * A set of options accepted by the field\n", " */\n\texport type FieldOptions = {\n\t  allowNull: boolean\n\t  bail: boolean\n\t  isOptional: boolean\n\t  parse?: Parser\n\t}\n\t/**\n\t * Options accepted when compiling schema types.\n\t */\n", "export type ParserOptions = {\n\t  toCamelCase: boolean\n\t}\n\t/**\n\t * Method to invoke when union has no match\n\t */\n\texport type UnionNoMatchCallback<Input> = (value: Input, field: FieldContext) => any\n\t/**\n\t * Error reporters must implement the reporter contract interface\n\t */\n", "export interface ErrorReporterContract extends BaseReporter {\n\t  createError(): ValidationError\n\t}\n\t/**\n\t * The validator function to validate metadata given to a validation\n\t * pipeline\n\t */\n\texport type MetaDataValidator = (meta: Record<string, any>) => void\n\t/**\n\t * Options accepted during the validate call.\n", " */\n\texport type ValidationOptions<MetaData extends Record<string, any> | undefined> = {\n\t  /**\n\t   * Messages provider is used to resolve error messages during\n\t   * the validation lifecycle\n\t   */\n\t  messagesProvider?: MessagesProviderContact\n\t  /**\n\t   * Validation errors are reported directly to an error reporter. The reporter\n\t   * can decide how to format and output errors.\n", "   */\n\t  errorReporter?: () => ErrorReporterContract\n\t} & ([undefined] extends MetaData\n\t  ? {\n\t      meta?: MetaData\n\t    }\n\t  : {\n\t      meta: MetaData\n\t    })\n\t/**\n", " * Infers the schema type\n\t */\n\texport type Infer<Schema extends { [OTYPE]: any }> = Schema[typeof OTYPE]\n"]}
{"filename": "src/symbols.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * The symbol to define a unique name for the schema type\n", " */\n\texport const UNIQUE_NAME = Symbol.for('schema_nme')\n\t/**\n\t * The symbol to check if a value is of the given schema\n\t * type\n\t */\n\texport const IS_OF_TYPE = Symbol.for('is_of_type')\n\t/**\n\t * The symbol for the compile method\n\t */\n", "export const PARSE = Symbol.for('parse')\n\t/**\n\t * The symbol for the opaque type\n\t */\n\texport const OTYPE = Symbol.for('opaque_type')\n\t/**\n\t * The symbol for the camelcase opaque type\n\t */\n\texport const COTYPE = Symbol.for('camelcase_opaque_type')\n\t/**\n", " * The symbol to generate a validation rule from rule builder\n\t */\n\texport const VALIDATION = Symbol.for('to_validation')\n"]}
{"filename": "src/messages_provider/simple_messages_provider.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type {\n\t  FieldContext,\n", "  ValidationFields,\n\t  ValidationMessages,\n\t  MessagesProviderContact,\n\t} from '../types.js'\n\t/**\n\t * Default messages provider performs messages lookup inside\n\t * a collection of key-value pair.\n\t */\n\texport class SimpleMessagesProvider implements MessagesProviderContact {\n\t  #messages: ValidationMessages\n", "  #fields: ValidationFields\n\t  constructor(messages: ValidationMessages, fields: ValidationFields) {\n\t    this.#messages = messages\n\t    this.#fields = fields\n\t  }\n\t  /**\n\t   * Interpolates place holders within error messages\n\t   */\n\t  #interpolate(message: string, data: any): string {\n\t    if (!message.includes('{{')) {\n", "      return message\n\t    }\n\t    return message.replace(/(\\\\)?{{(.*?)}}/g, (_, __, key) => {\n\t      const tokens = key.trim().split('.')\n\t      let output = data\n\t      while (tokens.length) {\n\t        if (output === null || typeof output !== 'object') {\n\t          return\n\t        }\n\t        const token = tokens.shift()\n", "        output = Object.hasOwn(output, token) ? output[token] : undefined\n\t      }\n\t      return output\n\t    })\n\t  }\n\t  /**\n\t   * Returns a validation message for a given field + rule.\n\t   */\n\t  getMessage(rawMessage: string, rule: string, field: FieldContext, args?: Record<string, any>) {\n\t    const fieldName = this.#fields[field.name] || field.name\n", "    /**\n\t     * 1st priority is given to the field messages\n\t     */\n\t    const fieldMessage = this.#messages[`${field.wildCardPath}.${rule}`]\n\t    if (fieldMessage) {\n\t      return this.#interpolate(fieldMessage, {\n\t        field: fieldName,\n\t        ...args,\n\t      })\n\t    }\n", "    /**\n\t     * 2nd priority is for rule messages\n\t     */\n\t    const ruleMessage = this.#messages[rule]\n\t    if (ruleMessage) {\n\t      return this.#interpolate(ruleMessage, {\n\t        field: fieldName,\n\t        ...args,\n\t      })\n\t    }\n", "    /**\n\t     * Fallback to raw message\n\t     */\n\t    return this.#interpolate(rawMessage, {\n\t      field: fieldName,\n\t      ...args,\n\t    })\n\t  }\n\t}\n"]}
{"filename": "src/vine/create_rule.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type { Validation, ValidationRule, Validator } from '../types.js'\n\t/**\n", " * Returns args for the validation function.\n\t */\n\ttype GetArgs<T> = undefined extends T ? [options?: T] : [options: T]\n\t/**\n\t * Convert a validator function to a rule that you can apply\n\t * to any schema type using the `schema.use` method.\n\t */\n\texport function createRule<Options = undefined>(\n\t  validator: Validator<Options>,\n\t  metaData?: {\n", "    implicit?: boolean\n\t    isAsync?: boolean\n\t  }\n\t) {\n\t  const rule: ValidationRule<Options> = {\n\t    validator,\n\t    isAsync: metaData?.isAsync || validator.constructor.name === 'AsyncFunction',\n\t    implicit: metaData?.implicit ?? false,\n\t  }\n\t  return function (...options: GetArgs<Options>): Validation<Options> {\n", "    return {\n\t      rule,\n\t      options: options[0],\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/vine/main.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { helpers } from './helpers.js'\n\timport { createRule } from './create_rule.js'\n", "import { SchemaBuilder } from '../schema/builder.js'\n\timport { SimpleMessagesProvider } from '../messages_provider/simple_messages_provider.js'\n\timport { VineValidator } from './validator.js'\n\timport { fields, messages } from '../defaults.js'\n\timport type {\n\t  Infer,\n\t  SchemaTypes,\n\t  MetaDataValidator,\n\t  ValidationOptions,\n\t  ErrorReporterContract,\n", "  MessagesProviderContact,\n\t} from '../types.js'\n\timport { SimpleErrorReporter } from '../reporters/simple_error_reporter.js'\n\t/**\n\t * Validate user input with type-safety using a pre-compiled schema.\n\t */\n\texport class Vine extends SchemaBuilder {\n\t  /**\n\t   * Messages provider to use on the validator\n\t   */\n", "  messagesProvider: MessagesProviderContact = new SimpleMessagesProvider(messages, fields)\n\t  /**\n\t   * Error reporter to use on the validator\n\t   */\n\t  errorReporter: () => ErrorReporterContract = () => new SimpleErrorReporter()\n\t  /**\n\t   * Control whether or not to convert empty strings to null\n\t   */\n\t  convertEmptyStringsToNull: boolean = false\n\t  /**\n", "   * Helpers to perform type-checking or cast types keeping\n\t   * HTML forms serialization behavior in mind.\n\t   */\n\t  helpers = helpers\n\t  /**\n\t   * Convert a validation function to a Vine schema rule\n\t   */\n\t  createRule = createRule\n\t  /**\n\t   * Pre-compiles a schema into a validation function.\n", "   *\n\t   * ```ts\n\t   * const validate = vine.compile(schema)\n\t   * await validate({ data })\n\t   * ```\n\t   */\n\t  compile<Schema extends SchemaTypes>(schema: Schema) {\n\t    return new VineValidator<Schema, Record<string, any> | undefined>(schema, {\n\t      convertEmptyStringsToNull: this.convertEmptyStringsToNull,\n\t      messagesProvider: this.messagesProvider,\n", "      errorReporter: this.errorReporter,\n\t    })\n\t  }\n\t  /**\n\t   * Define a callback to validate the metadata given to the validator\n\t   * at runtime\n\t   */\n\t  withMetaData<MetaData extends Record<string, any>>(callback?: MetaDataValidator) {\n\t    return {\n\t      compile: <Schema extends SchemaTypes>(schema: Schema) => {\n", "        return new VineValidator<Schema, MetaData>(schema, {\n\t          convertEmptyStringsToNull: this.convertEmptyStringsToNull,\n\t          messagesProvider: this.messagesProvider,\n\t          errorReporter: this.errorReporter,\n\t          metaDataValidator: callback,\n\t        })\n\t      },\n\t    }\n\t  }\n\t  /**\n", "   * Validate data against a schema. Optionally, you can define\n\t   * error messages, fields, a custom messages provider,\n\t   * or an error reporter.\n\t   *\n\t   * ```ts\n\t   * await vine.validate({ schema, data })\n\t   * await vine.validate({ schema, data, messages, fields })\n\t   *\n\t   * await vine.validate({ schema, data, messages, fields }, {\n\t   *   errorReporter\n", "   * })\n\t   * ```\n\t   */\n\t  validate<Schema extends SchemaTypes>(\n\t    options: {\n\t      /**\n\t       * Schema to use for validation\n\t       */\n\t      schema: Schema\n\t      /**\n", "       * Data to validate\n\t       */\n\t      data: any\n\t    } & ValidationOptions<Record<string, any> | undefined>\n\t  ): Promise<Infer<Schema>> {\n\t    const validator = this.compile(options.schema)\n\t    return validator.validate(options.data, options)\n\t  }\n\t}\n"]}
{"filename": "src/vine/helpers.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport isEmail from 'validator/lib/isEmail.js'\n\timport isURL from 'validator/lib/isURL.js'\n", "import isAlpha from 'validator/lib/isAlpha.js'\n\timport isAlphanumeric from 'validator/lib/isAlphanumeric.js'\n\timport isIP from 'validator/lib/isIP.js'\n\timport isUUID from 'validator/lib/isUUID.js'\n\timport isAscii from 'validator/lib/isAscii.js'\n\timport isCreditCard from 'validator/lib/isCreditCard.js'\n\timport isIBAN from 'validator/lib/isIBAN.js'\n\timport isJWT from 'validator/lib/isJWT.js'\n\timport isLatLong from 'validator/lib/isLatLong.js'\n\timport isPassportNumber from 'validator/lib/isPassportNumber.js'\n", "import isSlug from 'validator/lib/isSlug.js'\n\timport isDecimal from 'validator/lib/isDecimal.js'\n\timport isHexColor from 'validator/lib/isHexColor.js'\n\timport isMobilePhone, { type MobilePhoneLocale } from 'validator/lib/isMobilePhone.js'\n\timport isPostalCode, { type PostalCodeLocale } from 'validator/lib/isPostalCode.js'\n\t// @ts-ignore type missing from @types/validator\n\timport { locales as mobilePhoneLocales } from 'validator/lib/isMobilePhone.js'\n\t// @ts-ignore type missing from @types/validator\n\timport { locales as postalCodeLocales } from 'validator/lib/isPostalCode.js'\n\timport { resolve4, resolve6 } from 'node:dns/promises'\n", "const BOOLEAN_POSITIVES = ['1', 1, 'true', true, 'on']\n\tconst BOOLEAN_NEGATIVES = ['0', 0, 'false', false]\n\t/**\n\t * Collection of helpers used across the codebase to coerce\n\t * and type-check values from HTML forms.\n\t */\n\texport const helpers = {\n\t  /**\n\t   * Returns true when value is not null and neither\n\t   * undefined\n", "   */\n\t  exists(value: any): boolean {\n\t    return value !== null && value !== undefined\n\t  },\n\t  /**\n\t   * Returns true when value is null or value is undefined\n\t   */\n\t  isMissing(value: any): boolean {\n\t    return !this.exists(value)\n\t  },\n", "  /**\n\t   * Returns true when the value is one of the following.\n\t   *\n\t   * true\n\t   * 1\n\t   * \"1\"\n\t   * \"true\"\n\t   * \"on\"\n\t   */\n\t  isTrue(value: any): boolean {\n", "    return BOOLEAN_POSITIVES.includes(value)\n\t  },\n\t  /**\n\t   * Returns true when the value is one of the following.\n\t   *\n\t   * false\n\t   * 0\n\t   * \"0\"\n\t   * \"false\"\n\t   */\n", "  isFalse(value: any) {\n\t    return BOOLEAN_NEGATIVES.includes(value)\n\t  },\n\t  /**\n\t   * Check if the value is a valid string. This method narrows\n\t   * the type of value to string.\n\t   */\n\t  isString(value: unknown): value is string {\n\t    return typeof value === 'string'\n\t  },\n", "  /**\n\t   * Check if the value is a plain JavaScript object. This method\n\t   * filters out null and Arrays and does not consider them as Objects.\n\t   */\n\t  isObject<Value>(value: unknown): value is Record<PropertyKey, Value> {\n\t    return !!(value && typeof value === 'object' && !Array.isArray(value))\n\t  },\n\t  /**\n\t   * Check if an object has all the mentioned keys\n\t   */\n", "  hasKeys(value: Record<string, any>, keys: string[]) {\n\t    for (let key of keys) {\n\t      if (key in value === false) {\n\t        return false\n\t      }\n\t    }\n\t    return true\n\t  },\n\t  /**\n\t   * Check if the value is an Array.\n", "   */\n\t  isArray<Value>(value: unknown): value is Value[] {\n\t    return Array.isArray(value)\n\t  },\n\t  /**\n\t   * Check if the value is a number or a string representation of a number.\n\t   */\n\t  isNumeric(value: any): boolean {\n\t    return !Number.isNaN(Number(value))\n\t  },\n", "  /**\n\t   * Casts the value to a number using the Number method.\n\t   * Returns NaN when unable to cast.\n\t   */\n\t  asNumber(value: any): number {\n\t    return value === null ? Number.NaN : Number(value)\n\t  },\n\t  /**\n\t   * Casts the value to a boolean.\n\t   *\n", "   * - [true, 1, \"1\", \"true\", \"on\"] will be converted to true.\n\t   * - [false, 0, \"0\", \"false\"] will be converted to false.\n\t   * - Everything else will return null. So make sure to handle that case.\n\t   */\n\t  asBoolean(value: any): boolean | null {\n\t    if (this.isTrue(value)) {\n\t      return true\n\t    }\n\t    if (this.isFalse(value)) {\n\t      return false\n", "    }\n\t    return null\n\t  },\n\t  isEmail: isEmail.default,\n\t  isURL: isURL.default,\n\t  isAlpha: isAlpha.default,\n\t  isAlphaNumeric: isAlphanumeric.default,\n\t  isIP: isIP.default,\n\t  isUUID: isUUID.default,\n\t  isAscii: isAscii.default,\n", "  isCreditCard: isCreditCard.default,\n\t  isIBAN: isIBAN.default,\n\t  isJWT: isJWT.default,\n\t  isLatLong: isLatLong.default,\n\t  isMobilePhone: isMobilePhone.default,\n\t  isPassportNumber: isPassportNumber.default,\n\t  isPostalCode: isPostalCode.default,\n\t  isSlug: isSlug.default,\n\t  isDecimal: isDecimal.default,\n\t  mobileLocales: mobilePhoneLocales as MobilePhoneLocale[],\n", "  postalCountryCodes: postalCodeLocales as PostalCodeLocale[],\n\t  passportCountryCodes: [\n\t    'AM',\n\t    'AR',\n\t    'AT',\n\t    'AU',\n\t    'AZ',\n\t    'BE',\n\t    'BG',\n\t    'BR',\n", "    'BY',\n\t    'CA',\n\t    'CH',\n\t    'CY',\n\t    'CZ',\n\t    'DE',\n\t    'DK',\n\t    'DZ',\n\t    'ES',\n\t    'FI',\n", "    'FR',\n\t    'GB',\n\t    'GR',\n\t    'HR',\n\t    'HU',\n\t    'IE',\n\t    'IN',\n\t    'ID',\n\t    'IR',\n\t    'IS',\n", "    'IT',\n\t    'JM',\n\t    'JP',\n\t    'KR',\n\t    'KZ',\n\t    'LI',\n\t    'LT',\n\t    'LU',\n\t    'LV',\n\t    'LY',\n", "    'MT',\n\t    'MZ',\n\t    'MY',\n\t    'MX',\n\t    'NL',\n\t    'NZ',\n\t    'PH',\n\t    'PK',\n\t    'PL',\n\t    'PT',\n", "    'RO',\n\t    'RU',\n\t    'SE',\n\t    'SL',\n\t    'SK',\n\t    'TH',\n\t    'TR',\n\t    'UA',\n\t    'US',\n\t  ] as const,\n", "  /**\n\t   * Check if the value is a valid color hexcode\n\t   */\n\t  isHexColor: (value: string) => {\n\t    if (!value.startsWith('#')) {\n\t      return false\n\t    }\n\t    return isHexColor.default(value)\n\t  },\n\t  /**\n", "   * Check if a URL has valid `A` or `AAAA` DNS records\n\t   */\n\t  isActiveURL: async (url: string): Promise<boolean> => {\n\t    try {\n\t      const { hostname } = new URL(url)\n\t      const v6Addresses = await resolve6(hostname)\n\t      if (v6Addresses.length) {\n\t        return true\n\t        /* c8 ignore next 4 */\n\t      } else {\n", "        const v4Addresses = await resolve4(hostname)\n\t        return v4Addresses.length > 0\n\t      }\n\t    } catch {\n\t      return false\n\t    }\n\t  },\n\t  /**\n\t   * Check if all the elements inside the dataset are unique.\n\t   *\n", "   * In case of an array of objects, you must provide one or more keys\n\t   * for the fields that must be unique across the objects.\n\t   *\n\t   * ```ts\n\t   * helpers.isDistinct([1, 2, 4, 5]) // true\n\t   *\n\t   * // Null and undefined values are ignored\n\t   * helpers.isDistinct([1, null, 2, null, 4, 5]) // true\n\t   *\n\t   * helpers.isDistinct([\n", "   *   {\n\t   *     email: 'foo@bar.com',\n\t   *     name: 'foo'\n\t   *   },\n\t   *   {\n\t   *     email: 'baz@bar.com',\n\t   *     name: 'baz'\n\t   *   }\n\t   * ], 'email') // true\n\t   *\n", "   * helpers.isDistinct([\n\t   *   {\n\t   *     email: 'foo@bar.com',\n\t   *     tenant_id: 1,\n\t   *     name: 'foo'\n\t   *   },\n\t   *   {\n\t   *     email: 'foo@bar.com',\n\t   *     tenant_id: 2,\n\t   *     name: 'baz'\n", "   *   }\n\t   * ], ['email', 'tenant_id']) // true\n\t   * ```\n\t   */\n\t  isDistinct: (dataSet: any[], fields?: string | string[]): boolean => {\n\t    const uniqueItems: Set<any> = new Set()\n\t    /**\n\t     * Check for duplicates when no fields are provided\n\t     */\n\t    if (!fields) {\n", "      for (let item of dataSet) {\n\t        if (helpers.exists(item)) {\n\t          if (uniqueItems.has(item)) {\n\t            return false\n\t          } else {\n\t            uniqueItems.add(item)\n\t          }\n\t        }\n\t      }\n\t      return true\n", "    }\n\t    /**\n\t     * Checking for duplicates when one or more fields are mentioned\n\t     */\n\t    const fieldsList = Array.isArray(fields) ? fields : [fields]\n\t    for (let item of dataSet) {\n\t      /**\n\t       * Only process item, if it is an object and has all the fields\n\t       * required for uniqueness check\n\t       */\n", "      if (helpers.isObject(item) && helpers.hasKeys(item, fieldsList)) {\n\t        const element = fieldsList.map((field) => item[field]).join('_')\n\t        if (uniqueItems.has(element)) {\n\t          return false\n\t        } else {\n\t          uniqueItems.add(element)\n\t        }\n\t      }\n\t    }\n\t    return true\n", "  },\n\t}\n"]}
{"filename": "src/vine/validator.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { Compiler, refsBuilder } from '@vinejs/compiler'\n\timport type { MessagesProviderContact, Refs } from '@vinejs/compiler/types'\n", "import { messages } from '../defaults.js'\n\timport { OTYPE, PARSE } from '../symbols.js'\n\timport type {\n\t  Infer,\n\t  SchemaTypes,\n\t  MetaDataValidator,\n\t  ValidationOptions,\n\t  ErrorReporterContract,\n\t} from '../types.js'\n\t/**\n", " * Error messages to share with the compiler\n\t */\n\tconst COMPILER_ERROR_MESSAGES = {\n\t  required: messages.required,\n\t  array: messages.array,\n\t  object: messages.object,\n\t}\n\t/**\n\t * Vine Validator exposes the API to validate data using a pre-compiled\n\t * schema.\n", " */\n\texport class VineValidator<\n\t  Schema extends SchemaTypes,\n\t  MetaData extends undefined | Record<string, any>,\n\t> {\n\t  /**\n\t   * Reference to static types\n\t   */\n\t  declare [OTYPE]: Schema[typeof OTYPE]\n\t  /**\n", "   * Validator to use to validate metadata\n\t   */\n\t  #metaDataValidator?: MetaDataValidator\n\t  /**\n\t   * Messages provider to use on the validator\n\t   */\n\t  messagesProvider: MessagesProviderContact\n\t  /**\n\t   * Error reporter to use on the validator\n\t   */\n", "  errorReporter: () => ErrorReporterContract\n\t  /**\n\t   * Parses schema to compiler nodes.\n\t   */\n\t  #parse(schema: Schema) {\n\t    const refs = refsBuilder()\n\t    return {\n\t      compilerNode: {\n\t        type: 'root' as const,\n\t        schema: schema[PARSE]('', refs, { toCamelCase: false }),\n", "      },\n\t      refs: refs.toJSON(),\n\t    }\n\t  }\n\t  /**\n\t   * Refs computed from the compiled output\n\t   */\n\t  #refs: Refs\n\t  /**\n\t   * Compiled validator function\n", "   */\n\t  #validateFn: ReturnType<Compiler['compile']>\n\t  constructor(\n\t    schema: Schema,\n\t    options: {\n\t      convertEmptyStringsToNull: boolean\n\t      metaDataValidator?: MetaDataValidator\n\t      messagesProvider: MessagesProviderContact\n\t      errorReporter: () => ErrorReporterContract\n\t    }\n", "  ) {\n\t    const { compilerNode, refs } = this.#parse(schema)\n\t    this.#refs = refs\n\t    this.#validateFn = new Compiler(compilerNode, {\n\t      convertEmptyStringsToNull: options.convertEmptyStringsToNull,\n\t      messages: COMPILER_ERROR_MESSAGES,\n\t    }).compile()\n\t    this.errorReporter = options.errorReporter\n\t    this.messagesProvider = options.messagesProvider\n\t    this.#metaDataValidator = options.metaDataValidator\n", "  }\n\t  /**\n\t   * Validate data against a schema. Optionally, you can share metaData with\n\t   * the validator\n\t   *\n\t   * ```ts\n\t   * await validator.validate(data)\n\t   * await validator.validate(data, { meta: {} })\n\t   *\n\t   * await validator.validate(data, {\n", "   *   meta: { userId: auth.user.id },\n\t   *   errorReporter,\n\t   *   messagesProvider\n\t   * })\n\t   * ```\n\t   */\n\t  validate(\n\t    data: any,\n\t    ...[options]: [undefined] extends MetaData\n\t      ? [options?: ValidationOptions<MetaData> | undefined]\n", "      : [options: ValidationOptions<MetaData>]\n\t  ): Promise<Infer<Schema>> {\n\t    if (options?.meta && this.#metaDataValidator) {\n\t      this.#metaDataValidator(options.meta)\n\t    }\n\t    const errorReporter = options?.errorReporter || this.errorReporter\n\t    const messagesProvider = options?.messagesProvider || this.messagesProvider\n\t    return this.#validateFn(\n\t      data,\n\t      options?.meta || {},\n", "      this.#refs,\n\t      messagesProvider,\n\t      errorReporter()\n\t    )\n\t  }\n\t}\n"]}
{"filename": "src/reporters/simple_error_reporter.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { E_VALIDATION_ERROR } from '../errors/main.js'\n\timport { ValidationError } from '../errors/validation_error.js'\n", "import type { ErrorReporterContract, FieldContext } from '../types.js'\n\t/**\n\t * Shape of the error message collected by the SimpleErrorReporter\n\t */\n\ttype SimpleError = {\n\t  message: string\n\t  field: string\n\t  rule: string\n\t  index?: number\n\t  meta?: Record<string, any>\n", "}\n\t/**\n\t * Simple error reporter collects error messages as an array of object.\n\t * Each object has following properties.\n\t *\n\t * - message: string\n\t * - field: string\n\t * - rule: string\n\t * - index?: number (in case of an array member)\n\t * - args?: Record<string, any>\n", " */\n\texport class SimpleErrorReporter implements ErrorReporterContract {\n\t  /**\n\t   * Boolean to know one or more errors have been reported\n\t   */\n\t  hasErrors: boolean = false\n\t  /**\n\t   * Collection of errors\n\t   */\n\t  errors: SimpleError[] = []\n", "  /**\n\t   * Report an error.\n\t   */\n\t  report(\n\t    message: string,\n\t    rule: string,\n\t    field: FieldContext,\n\t    meta?: Record<string, any> | undefined\n\t  ) {\n\t    const error: SimpleError = {\n", "      message,\n\t      rule,\n\t      field: field.wildCardPath,\n\t    }\n\t    if (meta) {\n\t      error.meta = meta\n\t    }\n\t    if (field.isArrayMember) {\n\t      error.index = field.name as number\n\t    }\n", "    this.hasErrors = true\n\t    this.errors.push(error)\n\t  }\n\t  /**\n\t   * Returns an instance of the validation error\n\t   */\n\t  createError(): ValidationError {\n\t    return new E_VALIDATION_ERROR(this.errors)\n\t  }\n\t}\n"]}
{"filename": "src/schema/builder.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport Macroable from '@poppinss/macroable'\n\timport { VineAny } from './any/main.js'\n", "import { VineEnum } from './enum/main.js'\n\timport { union } from './union/builder.js'\n\timport { VineTuple } from './tuple/main.js'\n\timport { VineArray } from './array/main.js'\n\timport { VineObject } from './object/main.js'\n\timport { VineRecord } from './record/main.js'\n\timport { VineString } from './string/main.js'\n\timport { VineNumber } from './number/main.js'\n\timport { VineBoolean } from './boolean/main.js'\n\timport { VineLiteral } from './literal/main.js'\n", "import { CamelCase } from './camelcase_types.js'\n\timport { VineAccepted } from './accepted/main.js'\n\timport { group } from './object/group_builder.js'\n\timport { VineNativeEnum } from './enum/native_enum.js'\n\timport { VineUnionOfTypes } from './union_of_types/main.js'\n\timport { OTYPE, COTYPE, IS_OF_TYPE, UNIQUE_NAME } from '../symbols.js'\n\timport type { EnumLike, FieldContext, SchemaTypes } from '../types.js'\n\t/**\n\t * Schema builder exposes methods to construct a Vine schema. You may\n\t * add custom methods to it using macros.\n", " */\n\texport class SchemaBuilder extends Macroable {\n\t  /**\n\t   * Define a sub-object as a union\n\t   */\n\t  group = group\n\t  /**\n\t   * Define a union value\n\t   */\n\t  union = union\n", "  /**\n\t   * Define a string value\n\t   */\n\t  string() {\n\t    return new VineString()\n\t  }\n\t  /**\n\t   * Define a boolean value\n\t   */\n\t  boolean(options?: { strict: boolean }) {\n", "    return new VineBoolean(options)\n\t  }\n\t  /**\n\t   * Validate a checkbox to be checked\n\t   */\n\t  accepted() {\n\t    return new VineAccepted()\n\t  }\n\t  /**\n\t   * Define a number value\n", "   */\n\t  number(options?: { strict: boolean }) {\n\t    return new VineNumber(options)\n\t  }\n\t  /**\n\t   * Define a schema type in which the input value\n\t   * matches the pre-defined value\n\t   */\n\t  literal<const Value>(value: Value) {\n\t    return new VineLiteral<Value>(value)\n", "  }\n\t  /**\n\t   * Define an object with known properties. You may call \"allowUnknownProperties\"\n\t   * to merge unknown properties.\n\t   */\n\t  object<Properties extends Record<string, SchemaTypes>>(properties: Properties) {\n\t    return new VineObject<\n\t      Properties,\n\t      {\n\t        [K in keyof Properties]: Properties[K][typeof OTYPE]\n", "      },\n\t      {\n\t        [K in keyof Properties as CamelCase<K & string>]: Properties[K][typeof COTYPE]\n\t      }\n\t    >(properties)\n\t  }\n\t  /**\n\t   * Define an array field and validate its children elements.\n\t   */\n\t  array<Schema extends SchemaTypes>(schema: Schema) {\n", "    return new VineArray<Schema>(schema)\n\t  }\n\t  /**\n\t   * Define an array field with known length and each children\n\t   * element may have its own schema.\n\t   */\n\t  tuple<Schema extends SchemaTypes[]>(schemas: [...Schema]) {\n\t    return new VineTuple<\n\t      Schema,\n\t      { [K in keyof Schema]: Schema[K][typeof OTYPE] },\n", "      { [K in keyof Schema]: Schema[K][typeof COTYPE] }\n\t    >(schemas)\n\t  }\n\t  /**\n\t   * Define an object field with key-value pair. The keys in\n\t   * a record are unknown and values can be of a specific\n\t   * schema type.\n\t   */\n\t  record<Schema extends SchemaTypes>(schema: Schema) {\n\t    return new VineRecord<Schema>(schema)\n", "  }\n\t  /**\n\t   * Define a field whose value matches the enum choices.\n\t   */\n\t  enum<const Values extends readonly unknown[]>(\n\t    values: Values | ((field: FieldContext) => Values)\n\t  ): VineEnum<Values>\n\t  enum<Values extends EnumLike>(values: Values): VineNativeEnum<Values>\n\t  enum<Values extends readonly unknown[] | EnumLike>(values: Values): any {\n\t    if (Array.isArray(values) || typeof values === 'function') {\n", "      return new VineEnum(values)\n\t    }\n\t    return new VineNativeEnum(values as EnumLike)\n\t  }\n\t  /**\n\t   * Allow the field value to be anything\n\t   */\n\t  any() {\n\t    return new VineAny()\n\t  }\n", "  /**\n\t   * Define a union of unique schema types.\n\t   */\n\t  unionOfTypes<Schema extends SchemaTypes>(schemas: Schema[]) {\n\t    const schemasInUse: Set<string> = new Set()\n\t    schemas.forEach((schema) => {\n\t      if (!schema[IS_OF_TYPE] || !schema[UNIQUE_NAME]) {\n\t        throw new Error(\n\t          `Cannot use \"${schema.constructor.name}\". The schema type is not compatible for use with \"vine.unionOfTypes\"`\n\t        )\n", "      }\n\t      if (schemasInUse.has(schema[UNIQUE_NAME])) {\n\t        throw new Error(\n\t          `Cannot use duplicate schema \"${schema[UNIQUE_NAME]}\". \"vine.unionOfTypes\" needs distinct schema types only`\n\t        )\n\t      }\n\t      schemasInUse.add(schema[UNIQUE_NAME])\n\t    })\n\t    schemasInUse.clear()\n\t    return new VineUnionOfTypes(schemas)\n", "  }\n\t}\n"]}
{"filename": "src/schema/camelcase_types.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Copy-pasted from\n", " * https://github.com/ts-essentials/ts-essentials/blob/3f5d46a203cad06728fbf2a089a5b39bd473bf4e/lib/camel-case/index.ts\n\t *\n\t * Since, we need just one helper, I decided to not pull in the entire package and just copy-paste\n\t * the types\n\t */\n\ttype IsStringLiteral<Type> = Type extends string ? (string extends Type ? false : true) : false\n\ttype WordInPascalCase<Type> = Capitalize<WordInCamelCase<Uncapitalize<Type & string>>>\n\ttype WordInCamelCase<\n\t  Type,\n\t  Character extends string = '',\n", "> = Type extends `${Character}${infer NextCharacter}${infer _}`\n\t  ? NextCharacter extends Capitalize<NextCharacter>\n\t    ? Character\n\t    : WordInCamelCase<Type, `${Character}${NextCharacter}`>\n\t  : Character\n\ttype Separator = '_' | '-'\n\ttype IncludesSeparator<Type> = Type extends `${string}${Separator}${string}` ? true : false\n\ttype IsOneWord<Type> = Type extends Lowercase<Type & string>\n\t  ? true\n\t  : Type extends Uppercase<Type & string>\n", "  ? true\n\t  : false\n\ttype IsCamelCase<Type> = Type extends Uncapitalize<Type & string> ? true : false\n\ttype IsPascalCase<Type> = Type extends Capitalize<Type & string> ? true : false\n\t/** snake_case, CONSTANT_CASE, kebab-case or COBOL-CASE */\n\ttype SeparatorCaseParser<\n\t  Type,\n\t  Tuple extends readonly any[] = [],\n\t> = Type extends `${infer Word}${Separator}${infer Tail}`\n\t  ? SeparatorCaseParser<Tail, [...Tuple, Lowercase<Word>]>\n", "  : Type extends `${infer Word}`\n\t  ? [...Tuple, Lowercase<Word>]\n\t  : Tuple\n\ttype CamelCaseParser<Type, Tuple extends readonly any[] = []> = Type extends ''\n\t  ? Tuple\n\t  : Type extends `${WordInCamelCase<Type & string>}${infer Tail}`\n\t  ? Type extends `${infer Word}${Tail}`\n\t    ? CamelCaseParser<Uncapitalize<Tail>, [...Tuple, Lowercase<Word>]>\n\t    : never\n\t  : never\n", "type PascalCaseParser<Type, Tuple extends readonly any[] = []> = Type extends ''\n\t  ? Tuple\n\t  : Type extends `${WordInPascalCase<Type & string>}${infer Tail}`\n\t  ? Type extends `${infer Word}${Tail}`\n\t    ? PascalCaseParser<Tail, [...Tuple, Lowercase<Word>]>\n\t    : never\n\t  : never\n\ttype SplitAnyCase<Type> = IncludesSeparator<Type> extends true\n\t  ? SeparatorCaseParser<Type>\n\t  : IsOneWord<Type> extends true\n", "  ? [Lowercase<Type & string>]\n\t  : IsCamelCase<Type> extends true\n\t  ? CamelCaseParser<Type>\n\t  : IsPascalCase<Type> extends true\n\t  ? PascalCaseParser<Type>\n\t  : []\n\ttype PascalCapitalizer<Type, Tuple extends readonly any[] = []> = Type extends [\n\t  infer Head,\n\t  ...infer Tail,\n\t]\n", "  ? Head extends string\n\t    ? PascalCapitalizer<Tail, [...Tuple, Capitalize<Head>]>\n\t    : PascalCapitalizer<Tail, Tuple>\n\t  : Tuple\n\ttype CamelCapitalizer<Type> = Type extends [infer First, ...infer Tail]\n\t  ? PascalCapitalizer<Tail, [First]>\n\t  : []\n\ttype Join<Type, JoinedString extends string = ''> = Type extends [infer Head, ...infer Tail]\n\t  ? Head extends string\n\t    ? Join<Tail, `${JoinedString}${Head}`>\n", "    : Join<Tail>\n\t  : JoinedString\n\texport type CamelCase<Type> = IsStringLiteral<Type> extends true\n\t  ? Join<CamelCapitalizer<SplitAnyCase<Type>>>\n\t  : Type\n"]}
{"filename": "src/schema/union_of_types/main.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport camelcase from 'camelcase'\n\timport type { RefsStore, UnionNode } from '@vinejs/compiler/types'\n", "import { messages } from '../../defaults.js'\n\timport { OTYPE, COTYPE, PARSE, IS_OF_TYPE } from '../../symbols.js'\n\timport type {\n\t  SchemaTypes,\n\t  ParserOptions,\n\t  ConstructableSchema,\n\t  UnionNoMatchCallback,\n\t} from '../../types.js'\n\t/**\n\t * Vine union represents a union data type. A union is a collection\n", " * of conditionals and each condition has an associated schema\n\t */\n\texport class VineUnionOfTypes<Schema extends SchemaTypes>\n\t  implements ConstructableSchema<Schema[typeof OTYPE], Schema[typeof COTYPE]>\n\t{\n\t  declare [OTYPE]: Schema[typeof OTYPE];\n\t  declare [COTYPE]: Schema[typeof COTYPE]\n\t  #schemas: Schema[]\n\t  #otherwiseCallback: UnionNoMatchCallback<Record<string, unknown>> = (_, field) => {\n\t    field.report(messages.unionOfTypes, 'unionOfTypes', field)\n", "  }\n\t  constructor(schemas: Schema[]) {\n\t    this.#schemas = schemas\n\t  }\n\t  /**\n\t   * Define a fallback method to invoke when all of the union conditions\n\t   * fail. You may use this method to report an error.\n\t   */\n\t  otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this {\n\t    this.#otherwiseCallback = callback\n", "    return this\n\t  }\n\t  /**\n\t   * Clones the VineUnionOfTypes schema type.\n\t   */\n\t  clone(): this {\n\t    const cloned = new VineUnionOfTypes<Schema>(this.#schemas)\n\t    cloned.otherwise(this.#otherwiseCallback)\n\t    return cloned as this\n\t  }\n", "  /**\n\t   * Compiles to a union\n\t   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): UnionNode {\n\t    return {\n\t      type: 'union',\n\t      fieldName: propertyName,\n\t      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n\t      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),\n\t      conditions: this.#schemas.map((schema) => {\n", "        return {\n\t          conditionalFnRefId: refs.trackConditional((value, field) => {\n\t            return schema[IS_OF_TYPE]!(value, field)\n\t          }),\n\t          schema: schema[PARSE](propertyName, refs, options),\n\t        }\n\t      }),\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/schema/accepted/main.ts", "chunked_list": ["/*\n\t * vinejs\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { acceptedRule } from './rules.js'\n\timport { BaseLiteralType } from '../base/literal.js'\n", "import type { FieldOptions, Validation } from '../../types.js'\n\t/**\n\t * VineAccepted represents a checkbox input that must be checked\n\t */\n\texport class VineAccepted extends BaseLiteralType<true, true> {\n\t  /**\n\t   * Default collection of accepted rules\n\t   */\n\t  static rules = {\n\t    accepted: acceptedRule,\n", "  }\n\t  constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]) {\n\t    super(options, validations || [acceptedRule()])\n\t  }\n\t  /**\n\t   * Clones the VineAccepted schema type. The applied options\n\t   * and validations are copied to the new instance\n\t   */\n\t  clone(): this {\n\t    return new VineAccepted(this.cloneOptions(), this.cloneValidations()) as this\n", "  }\n\t}\n"]}
{"filename": "src/schema/accepted/rules.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { messages } from '../../defaults.js'\n\timport { createRule } from '../../vine/create_rule.js'\n", "const ACCEPTED_VALUES = ['on', '1', 'yes', 'true', true, 1]\n\t/**\n\t * Validates the value to be present and have one of\n\t * the following values.\n\t *\n\t * - \"on\"\n\t * - \"1\"\n\t * - \"yes\"\n\t * - \"true\"\n\t */\n", "export const acceptedRule = createRule((value, _, field) => {\n\t  if (!ACCEPTED_VALUES.includes(value as any)) {\n\t    field.report(messages.accepted, 'accepted', field)\n\t  }\n\t})\n"]}
{"filename": "src/schema/object/conditional.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type { ConditionalFn, ObjectGroupNode, RefsStore } from '@vinejs/compiler/types'\n\timport { OTYPE, COTYPE, PARSE } from '../../symbols.js'\n", "import type { ParserOptions, SchemaTypes } from '../../types.js'\n\t/**\n\t * Group conditional represents a sub-set of object wrapped\n\t * inside a conditional\n\t */\n\texport class GroupConditional<\n\t  Properties extends Record<string, SchemaTypes>,\n\t  Output,\n\t  CamelCaseOutput,\n\t> {\n", "  declare [OTYPE]: Output;\n\t  declare [COTYPE]: CamelCaseOutput\n\t  /**\n\t   * Properties to merge when conditonal is true\n\t   */\n\t  #properties: Properties\n\t  /**\n\t   * Conditional to evaluate\n\t   */\n\t  #conditional: ConditionalFn<Record<string, unknown>>\n", "  constructor(conditional: ConditionalFn<Record<string, unknown>>, properties: Properties) {\n\t    this.#properties = properties\n\t    this.#conditional = conditional\n\t  }\n\t  /**\n\t   * Compiles to a union conditional\n\t   */\n\t  [PARSE](refs: RefsStore, options: ParserOptions): ObjectGroupNode['conditions'][number] {\n\t    return {\n\t      schema: {\n", "        type: 'sub_object',\n\t        properties: Object.keys(this.#properties).map((property) => {\n\t          return this.#properties[property][PARSE](property, refs, options)\n\t        }),\n\t        groups: [], // Compiler allows nested groups, but we are not implementing it\n\t      },\n\t      conditionalFnRefId: refs.trackConditional(this.#conditional),\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/schema/object/main.ts", "chunked_list": ["/*\n\t * vinejs\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport camelcase from 'camelcase'\n\timport type { ObjectNode, RefsStore } from '@vinejs/compiler/types'\n", "import { ObjectGroup } from './group.js'\n\timport { GroupConditional } from './conditional.js'\n\timport { BaseModifiersType, BaseType } from '../base/main.js'\n\timport { OTYPE, COTYPE, PARSE, UNIQUE_NAME, IS_OF_TYPE } from '../../symbols.js'\n\timport type { Validation, SchemaTypes, FieldOptions, ParserOptions } from '../../types.js'\n\t/**\n\t * Converts schema properties to camelCase\n\t */\n\texport class VineCamelCaseObject<\n\t  Schema extends VineObject<any, any, any>,\n", "> extends BaseModifiersType<Schema[typeof COTYPE], Schema[typeof COTYPE]> {\n\t  #schema: Schema;\n\t  /**\n\t   * The property must be implemented for \"unionOfTypes\"\n\t   */\n\t  [UNIQUE_NAME] = 'types.object';\n\t  /**\n\t   * Checks if the value is of object type. The method must be\n\t   * implemented for \"unionOfTypes\"\n\t   */\n", "  [IS_OF_TYPE] = (value: unknown) => {\n\t    return value !== null && typeof value === 'object' && !Array.isArray(value)\n\t  }\n\t  constructor(schema: Schema) {\n\t    super()\n\t    this.#schema = schema\n\t  }\n\t  /**\n\t   * Clone object\n\t   */\n", "  clone(): this {\n\t    return new VineCamelCaseObject<Schema>(this.#schema.clone()) as this\n\t  }\n\t  /**\n\t   * Compiles the schema type to a compiler node\n\t   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ObjectNode {\n\t    options.toCamelCase = true\n\t    return this.#schema[PARSE](propertyName, refs, options)\n\t  }\n", "}\n\t/**\n\t * VineObject represents an object value in the validation\n\t * schema.\n\t */\n\texport class VineObject<\n\t  Properties extends Record<string, SchemaTypes>,\n\t  Output,\n\t  CamelCaseOutput,\n\t> extends BaseType<Output, CamelCaseOutput> {\n", "  /**\n\t   * Object properties\n\t   */\n\t  #properties: Properties\n\t  /**\n\t   * Object groups to merge based on conditionals\n\t   */\n\t  #groups: ObjectGroup<GroupConditional<any, any, any>>[] = []\n\t  /**\n\t   * Whether or not to allow unknown properties\n", "   */\n\t  #allowUnknownProperties: boolean = false;\n\t  /**\n\t   * The property must be implemented for \"unionOfTypes\"\n\t   */\n\t  [UNIQUE_NAME] = 'vine.object';\n\t  /**\n\t   * Checks if the value is of object type. The method must be\n\t   * implemented for \"unionOfTypes\"\n\t   */\n", "  [IS_OF_TYPE] = (value: unknown) => {\n\t    return value !== null && typeof value === 'object' && !Array.isArray(value)\n\t  }\n\t  constructor(properties: Properties, options?: FieldOptions, validations?: Validation<any>[]) {\n\t    super(options, validations)\n\t    this.#properties = properties\n\t  }\n\t  /**\n\t   * Returns a clone copy of the object properties. The object groups\n\t   * are not copied to keep the implementations simple and easy to\n", "   * reason about.\n\t   */\n\t  getProperties(): Properties {\n\t    return Object.keys(this.#properties).reduce((result, key) => {\n\t      result[key as keyof Properties] = this.#properties[\n\t        key\n\t      ].clone() as Properties[keyof Properties]\n\t      return result\n\t    }, {} as Properties)\n\t  }\n", "  /**\n\t   * Copy unknown properties to the final output.\n\t   */\n\t  allowUnknownProperties<Value>(): VineObject<\n\t    Properties,\n\t    Output & { [K: string]: Value },\n\t    CamelCaseOutput & { [K: string]: Value }\n\t  > {\n\t    this.#allowUnknownProperties = true\n\t    return this as VineObject<\n", "      Properties,\n\t      Output & { [K: string]: Value },\n\t      CamelCaseOutput & { [K: string]: Value }\n\t    >\n\t  }\n\t  /**\n\t   * Merge a union to the object groups. The union can be a \"vine.union\"\n\t   * with objects, or a \"vine.object.union\" with properties.\n\t   */\n\t  merge<Group extends ObjectGroup<GroupConditional<any, any, any>>>(\n", "    group: Group\n\t  ): VineObject<Properties, Output & Group[typeof OTYPE], CamelCaseOutput & Group[typeof COTYPE]> {\n\t    this.#groups.push(group)\n\t    return this as VineObject<\n\t      Properties,\n\t      Output & Group[typeof OTYPE],\n\t      CamelCaseOutput & Group[typeof COTYPE]\n\t    >\n\t  }\n\t  /**\n", "   * Clone object\n\t   */\n\t  clone(): this {\n\t    const cloned = new VineObject<Properties, Output, CamelCaseOutput>(\n\t      this.getProperties(),\n\t      this.cloneOptions(),\n\t      this.cloneValidations()\n\t    )\n\t    this.#groups.forEach((group) => cloned.merge(group))\n\t    if (this.#allowUnknownProperties) {\n", "      cloned.allowUnknownProperties()\n\t    }\n\t    return cloned as this\n\t  }\n\t  /**\n\t   * Applies camelcase transform\n\t   */\n\t  toCamelCase() {\n\t    return new VineCamelCaseObject(this)\n\t  }\n", "  /**\n\t   * Compiles the schema type to a compiler node\n\t   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ObjectNode {\n\t    return {\n\t      type: 'object',\n\t      fieldName: propertyName,\n\t      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n\t      bail: this.options.bail,\n\t      allowNull: this.options.allowNull,\n", "      isOptional: this.options.isOptional,\n\t      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,\n\t      allowUnknownProperties: this.#allowUnknownProperties,\n\t      validations: this.compileValidations(refs),\n\t      properties: Object.keys(this.#properties).map((property) => {\n\t        return this.#properties[property][PARSE](property, refs, options)\n\t      }),\n\t      groups: this.#groups.map((group) => {\n\t        return group[PARSE](refs, options)\n\t      }),\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src/schema/object/group_builder.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { ObjectGroup } from './group.js'\n\timport { OTYPE, COTYPE } from '../../symbols.js'\n", "import { CamelCase } from '../camelcase_types.js'\n\timport { GroupConditional } from './conditional.js'\n\timport type { FieldContext, SchemaTypes } from '../../types.js'\n\t/**\n\t * Create an object group. Groups are used to conditionally merge properties\n\t * to an existing object.\n\t */\n\texport function group<Conditional extends GroupConditional<any, any, any>>(\n\t  conditionals: Conditional[]\n\t) {\n", "  return new ObjectGroup<Conditional>(conditionals)\n\t}\n\t/**\n\t * Wrap object properties inside a conditonal\n\t */\n\tgroup.if = function groupIf<Properties extends Record<string, SchemaTypes>>(\n\t  conditon: (value: Record<string, unknown>, field: FieldContext) => any,\n\t  properties: Properties\n\t) {\n\t  return new GroupConditional<\n", "    Properties,\n\t    {\n\t      [K in keyof Properties]: Properties[K][typeof OTYPE]\n\t    },\n\t    {\n\t      [K in keyof Properties as CamelCase<K & string>]: Properties[K][typeof COTYPE]\n\t    }\n\t  >(conditon, properties)\n\t}\n\t/**\n", " * Wrap object properties inside an else conditon\n\t */\n\tgroup.else = function groupElse<Properties extends Record<string, SchemaTypes>>(\n\t  properties: Properties\n\t) {\n\t  return new GroupConditional<\n\t    Properties,\n\t    {\n\t      [K in keyof Properties]: Properties[K][typeof OTYPE]\n\t    },\n", "    {\n\t      [K in keyof Properties as CamelCase<K & string>]: Properties[K][typeof COTYPE]\n\t    }\n\t  >(() => true, properties)\n\t}\n"]}
{"filename": "src/schema/object/group.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { ObjectGroupNode, RefsStore } from '@vinejs/compiler/types'\n\timport { messages } from '../../defaults.js'\n", "import { GroupConditional } from './conditional.js'\n\timport { OTYPE, COTYPE, PARSE } from '../../symbols.js'\n\timport type { ParserOptions, UnionNoMatchCallback } from '../../types.js'\n\t/**\n\t * Object group represents a group with multiple conditionals, where each\n\t * condition returns a set of object properties to merge into the\n\t * existing object.\n\t */\n\texport class ObjectGroup<Conditional extends GroupConditional<any, any, any>> {\n\t  declare [OTYPE]: Conditional[typeof OTYPE];\n", "  declare [COTYPE]: Conditional[typeof COTYPE]\n\t  #conditionals: Conditional[]\n\t  #otherwiseCallback: UnionNoMatchCallback<Record<string, unknown>> = (_, field) => {\n\t    field.report(messages.unionGroup, 'unionGroup', field)\n\t  }\n\t  constructor(conditionals: Conditional[]) {\n\t    this.#conditionals = conditionals\n\t  }\n\t  /**\n\t   * Clones the ObjectGroup schema type.\n", "   */\n\t  clone(): this {\n\t    const cloned = new ObjectGroup<Conditional>(this.#conditionals)\n\t    cloned.otherwise(this.#otherwiseCallback)\n\t    return cloned as this\n\t  }\n\t  /**\n\t   * Define a fallback method to invoke when all of the group conditions\n\t   * fail. You may use this method to report an error.\n\t   */\n", "  otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this {\n\t    this.#otherwiseCallback = callback\n\t    return this\n\t  }\n\t  /**\n\t   * Compiles the group\n\t   */\n\t  [PARSE](refs: RefsStore, options: ParserOptions): ObjectGroupNode {\n\t    return {\n\t      type: 'group',\n", "      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),\n\t      conditions: this.#conditionals.map((conditional) => conditional[PARSE](refs, options)),\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/schema/boolean/main.ts", "chunked_list": ["/*\n\t * vinejs\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { booleanRule } from './rules.js'\n\timport { helpers } from '../../vine/helpers.js'\n", "import { BaseLiteralType } from '../base/literal.js'\n\timport { IS_OF_TYPE, UNIQUE_NAME } from '../../symbols.js'\n\timport type { FieldOptions, Validation } from '../../types.js'\n\t/**\n\t * VineBoolean represents a boolean value in the validation schema.\n\t */\n\texport class VineBoolean extends BaseLiteralType<boolean, boolean> {\n\t  /**\n\t   * Default collection of boolean rules\n\t   */\n", "  static rules = {\n\t    boolean: booleanRule,\n\t  }\n\t  protected declare options: FieldOptions & { strict?: boolean };\n\t  /**\n\t   * The property must be implemented for \"unionOfTypes\"\n\t   */\n\t  [UNIQUE_NAME] = 'vine.boolean';\n\t  /**\n\t   * Checks if the value is of boolean type. The method must be\n", "   * implemented for \"unionOfTypes\"\n\t   */\n\t  [IS_OF_TYPE] = (value: unknown) => {\n\t    const valueAsBoolean = this.options.strict === true ? value : helpers.asBoolean(value)\n\t    return typeof valueAsBoolean === 'boolean'\n\t  }\n\t  constructor(\n\t    options?: Partial<FieldOptions> & { strict?: boolean },\n\t    validations?: Validation<any>[]\n\t  ) {\n", "    super(options, validations || [booleanRule(options || {})])\n\t  }\n\t  /**\n\t   * Clones the VineBoolean schema type. The applied options\n\t   * and validations are copied to the new instance\n\t   */\n\t  clone(): this {\n\t    return new VineBoolean(this.cloneOptions(), this.cloneValidations()) as this\n\t  }\n\t}\n"]}
{"filename": "src/schema/boolean/rules.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { helpers } from '../../vine/helpers.js'\n\timport { messages } from '../../defaults.js'\n", "import { createRule } from '../../vine/create_rule.js'\n\t/**\n\t * Validates the value to be a boolean\n\t */\n\texport const booleanRule = createRule<{ strict?: boolean }>((value, options, field) => {\n\t  const valueAsBoolean = options.strict === true ? value : helpers.asBoolean(value)\n\t  if (typeof valueAsBoolean !== 'boolean') {\n\t    field.report(messages.boolean, 'boolean', field)\n\t    return\n\t  }\n", "  field.mutate(valueAsBoolean, field)\n\t})\n"]}
{"filename": "src/schema/string/main.ts", "chunked_list": ["/*\n\t * vinejs\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { BaseLiteralType } from '../base/literal.js'\n\timport { IS_OF_TYPE, UNIQUE_NAME } from '../../symbols.js'\n", "import type {\n\t  Validation,\n\t  AlphaOptions,\n\t  FieldContext,\n\t  FieldOptions,\n\t  AlphaNumericOptions,\n\t  NormalizeEmailOptions,\n\t} from '../../types.js'\n\timport {\n\t  inRule,\n", "  urlRule,\n\t  uuidRule,\n\t  trimRule,\n\t  alphaRule,\n\t  emailRule,\n\t  notInRule,\n\t  regexRule,\n\t  sameAsRule,\n\t  mobileRule,\n\t  escapeRule,\n", "  stringRule,\n\t  hexCodeRule,\n\t  passportRule,\n\t  endsWithRule,\n\t  ipAddressRule,\n\t  confirmedRule,\n\t  notSameAsRule,\n\t  activeUrlRule,\n\t  minLengthRule,\n\t  maxLengthRule,\n", "  startsWithRule,\n\t  creditCardRule,\n\t  postalCodeRule,\n\t  fixedLengthRule,\n\t  alphaNumericRule,\n\t  normalizeEmailRule,\n\t  asciiRule,\n\t  ibanRule,\n\t  jwtRule,\n\t  coordinatesRule,\n", "  toUpperCaseRule,\n\t  toLowerCaseRule,\n\t  toCamelCaseRule,\n\t  normalizeUrlRule,\n\t} from './rules.js'\n\t/**\n\t * VineString represents a string value in the validation schema.\n\t */\n\texport class VineString extends BaseLiteralType<string, string> {\n\t  static rules = {\n", "    in: inRule,\n\t    jwt: jwtRule,\n\t    url: urlRule,\n\t    iban: ibanRule,\n\t    uuid: uuidRule,\n\t    trim: trimRule,\n\t    email: emailRule,\n\t    alpha: alphaRule,\n\t    ascii: asciiRule,\n\t    notIn: notInRule,\n", "    regex: regexRule,\n\t    escape: escapeRule,\n\t    sameAs: sameAsRule,\n\t    mobile: mobileRule,\n\t    string: stringRule,\n\t    hexCode: hexCodeRule,\n\t    passport: passportRule,\n\t    endsWith: endsWithRule,\n\t    confirmed: confirmedRule,\n\t    activeUrl: activeUrlRule,\n", "    minLength: minLengthRule,\n\t    notSameAs: notSameAsRule,\n\t    maxLength: maxLengthRule,\n\t    ipAddress: ipAddressRule,\n\t    creditCard: creditCardRule,\n\t    postalCode: postalCodeRule,\n\t    startsWith: startsWithRule,\n\t    toUpperCase: toUpperCaseRule,\n\t    toLowerCase: toLowerCaseRule,\n\t    toCamelCase: toCamelCaseRule,\n", "    fixedLength: fixedLengthRule,\n\t    coordinates: coordinatesRule,\n\t    normalizeUrl: normalizeUrlRule,\n\t    alphaNumeric: alphaNumericRule,\n\t    normalizeEmail: normalizeEmailRule,\n\t  };\n\t  /**\n\t   * The property must be implemented for \"unionOfTypes\"\n\t   */\n\t  [UNIQUE_NAME] = 'vine.string';\n", "  /**\n\t   * Checks if the value is of string type. The method must be\n\t   * implemented for \"unionOfTypes\"\n\t   */\n\t  [IS_OF_TYPE] = (value: unknown) => {\n\t    return typeof value === 'string'\n\t  }\n\t  constructor(options?: FieldOptions, validations?: Validation<any>[]) {\n\t    super(options, validations || [stringRule()])\n\t  }\n", "  /**\n\t   * Validates the value to be a valid URL\n\t   */\n\t  url(...args: Parameters<typeof urlRule>) {\n\t    return this.use(urlRule(...args))\n\t  }\n\t  /**\n\t   * Validates the value to be an active URL\n\t   */\n\t  activeUrl() {\n", "    return this.use(activeUrlRule())\n\t  }\n\t  /**\n\t   * Validates the value to be a valid email address\n\t   */\n\t  email(...args: Parameters<typeof emailRule>) {\n\t    return this.use(emailRule(...args))\n\t  }\n\t  /**\n\t   * Validates the value to be a valid mobile number\n", "   */\n\t  mobile(...args: Parameters<typeof mobileRule>) {\n\t    return this.use(mobileRule(...args))\n\t  }\n\t  /**\n\t   * Validates the value to be a valid IP address.\n\t   */\n\t  ipAddress(version?: 4 | 6) {\n\t    return this.use(ipAddressRule(version ? { version } : undefined))\n\t  }\n", "  /**\n\t   * Validates the value to be a valid hex color code\n\t   */\n\t  hexCode() {\n\t    return this.use(hexCodeRule())\n\t  }\n\t  /**\n\t   * Validates the value to be an active URL\n\t   */\n\t  regex(expression: RegExp) {\n", "    return this.use(regexRule(expression))\n\t  }\n\t  /**\n\t   * Validates the value to contain only letters\n\t   */\n\t  alpha(options?: AlphaOptions) {\n\t    return this.use(alphaRule(options))\n\t  }\n\t  /**\n\t   * Validates the value to contain only letters and\n", "   * numbers\n\t   */\n\t  alphaNumeric(options?: AlphaNumericOptions) {\n\t    return this.use(alphaNumericRule(options))\n\t  }\n\t  /**\n\t   * Enforce a minimum length on a string field\n\t   */\n\t  minLength(expectedLength: number) {\n\t    return this.use(minLengthRule({ min: expectedLength }))\n", "  }\n\t  /**\n\t   * Enforce a maximum length on a string field\n\t   */\n\t  maxLength(expectedLength: number) {\n\t    return this.use(maxLengthRule({ max: expectedLength }))\n\t  }\n\t  /**\n\t   * Enforce a fixed length on a string field\n\t   */\n", "  fixedLength(expectedLength: number) {\n\t    return this.use(fixedLengthRule({ size: expectedLength }))\n\t  }\n\t  /**\n\t   * Ensure the field under validation is confirmed by\n\t   * having another field with the same name.\n\t   */\n\t  confirmed(options?: { confirmationField: string }) {\n\t    return this.use(confirmedRule(options))\n\t  }\n", "  /**\n\t   * Trims whitespaces around the string value\n\t   */\n\t  trim() {\n\t    return this.use(trimRule())\n\t  }\n\t  /**\n\t   * Normalizes the email address\n\t   */\n\t  normalizeEmail(options?: NormalizeEmailOptions) {\n", "    return this.use(normalizeEmailRule(options))\n\t  }\n\t  /**\n\t   * Converts the field value to UPPERCASE.\n\t   */\n\t  toUpperCase() {\n\t    return this.use(toUpperCaseRule())\n\t  }\n\t  /**\n\t   * Converts the field value to lowercase.\n", "   */\n\t  toLowerCase() {\n\t    return this.use(toLowerCaseRule())\n\t  }\n\t  /**\n\t   * Converts the field value to camelCase.\n\t   */\n\t  toCamelCase() {\n\t    return this.use(toCamelCaseRule())\n\t  }\n", "  /**\n\t   * Escape string for HTML entities\n\t   */\n\t  escape() {\n\t    return this.use(escapeRule())\n\t  }\n\t  /**\n\t   * Normalize a URL\n\t   */\n\t  normalizeUrl(...args: Parameters<typeof normalizeUrlRule>) {\n", "    return this.use(normalizeUrlRule(...args))\n\t  }\n\t  /**\n\t   * Ensure the value starts with the pre-defined substring\n\t   */\n\t  startsWith(substring: string) {\n\t    return this.use(startsWithRule({ substring }))\n\t  }\n\t  /**\n\t   * Ensure the value ends with the pre-defined substring\n", "   */\n\t  endsWith(substring: string) {\n\t    return this.use(endsWithRule({ substring }))\n\t  }\n\t  /**\n\t   * Ensure the value ends with the pre-defined substring\n\t   */\n\t  sameAs(otherField: string) {\n\t    return this.use(sameAsRule({ otherField }))\n\t  }\n", "  /**\n\t   * Ensure the value ends with the pre-defined substring\n\t   */\n\t  notSameAs(otherField: string) {\n\t    return this.use(notSameAsRule({ otherField }))\n\t  }\n\t  /**\n\t   * Ensure the field's value under validation is a subset of the pre-defined list.\n\t   */\n\t  in(choices: string[] | ((field: FieldContext) => string[])) {\n", "    return this.use(inRule({ choices }))\n\t  }\n\t  /**\n\t   * Ensure the field's value under validation is not inside the pre-defined list.\n\t   */\n\t  notIn(list: string[] | ((field: FieldContext) => string[])) {\n\t    return this.use(notInRule({ list }))\n\t  }\n\t  /**\n\t   * Validates the value to be a valid credit card number\n", "   */\n\t  creditCard(...args: Parameters<typeof creditCardRule>) {\n\t    return this.use(creditCardRule(...args))\n\t  }\n\t  /**\n\t   * Validates the value to be a valid passport number\n\t   */\n\t  passport(...args: Parameters<typeof passportRule>) {\n\t    return this.use(passportRule(...args))\n\t  }\n", "  /**\n\t   * Validates the value to be a valid postal code\n\t   */\n\t  postalCode(...args: Parameters<typeof postalCodeRule>) {\n\t    return this.use(postalCodeRule(...args))\n\t  }\n\t  /**\n\t   * Validates the value to be a valid UUID\n\t   */\n\t  uuid(...args: Parameters<typeof uuidRule>) {\n", "    return this.use(uuidRule(...args))\n\t  }\n\t  /**\n\t   * Validates the value contains ASCII characters only\n\t   */\n\t  ascii() {\n\t    return this.use(asciiRule())\n\t  }\n\t  /**\n\t   * Validates the value to be a valid IBAN number\n", "   */\n\t  iban() {\n\t    return this.use(ibanRule())\n\t  }\n\t  /**\n\t   * Validates the value to be a valid JWT token\n\t   */\n\t  jwt() {\n\t    return this.use(jwtRule())\n\t  }\n", "  /**\n\t   * Ensure the value is a string with latitude and longitude coordinates\n\t   */\n\t  coordinates() {\n\t    return this.use(coordinatesRule())\n\t  }\n\t  /**\n\t   * Clones the VineString schema type. The applied options\n\t   * and validations are copied to the new instance\n\t   */\n", "  clone(): this {\n\t    return new VineString(this.cloneOptions(), this.cloneValidations()) as this\n\t  }\n\t}\n"]}
{"filename": "src/schema/string/rules.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport normalizeEmail from 'validator/lib/normalizeEmail.js'\n\timport escape from 'validator/lib/escape.js'\n", "import type { FieldContext } from '@vinejs/compiler/types'\n\timport { helpers } from '../../vine/helpers.js'\n\timport { messages } from '../../defaults.js'\n\timport { createRule } from '../../vine/create_rule.js'\n\timport type {\n\t  URLOptions,\n\t  AlphaOptions,\n\t  EmailOptions,\n\t  MobileOptions,\n\t  PassportOptions,\n", "  CreditCardOptions,\n\t  PostalCodeOptions,\n\t  NormalizeUrlOptions,\n\t  AlphaNumericOptions,\n\t  NormalizeEmailOptions,\n\t} from '../../types.js'\n\timport camelcase from 'camelcase'\n\timport normalizeUrl from 'normalize-url'\n\t/**\n\t * Validates the value to be a string\n", " */\n\texport const stringRule = createRule((value, _, field) => {\n\t  if (typeof value !== 'string') {\n\t    field.report(messages.string, 'string', field)\n\t  }\n\t})\n\t/**\n\t * Validates the value to be a valid email address\n\t */\n\texport const emailRule = createRule<EmailOptions | undefined>((value, options, field) => {\n", "  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (!helpers.isEmail(value as string, options)) {\n\t    field.report(messages.email, 'email', field)\n\t  }\n\t})\n\t/**\n\t * Validates the value to be a valid mobile number\n\t */\n", "export const mobileRule = createRule<\n\t  MobileOptions | undefined | ((field: FieldContext) => MobileOptions | undefined)\n\t>((value, options, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  const normalizedOptions = options && typeof options === 'function' ? options(field) : options\n\t  const locales = normalizedOptions?.locale || 'any'\n\t  if (!helpers.isMobilePhone(value as string, locales, normalizedOptions)) {\n\t    field.report(messages.mobile, 'mobile', field)\n", "  }\n\t})\n\t/**\n\t * Validates the value to be a valid IP address.\n\t */\n\texport const ipAddressRule = createRule<{ version: 4 | 6 } | undefined>((value, options, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (!helpers.isIP(value as string, options?.version)) {\n", "    field.report(messages.ipAddress, 'ipAddress', field)\n\t  }\n\t})\n\t/**\n\t * Validates the value against a regular expression\n\t */\n\texport const regexRule = createRule<RegExp>((value, expression, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n", "  if (!expression.test(value as string)) {\n\t    field.report(messages.regex, 'regex', field)\n\t  }\n\t})\n\t/**\n\t * Validates the value to be a valid hex color code\n\t */\n\texport const hexCodeRule = createRule((value, _, field) => {\n\t  if (!field.isValid) {\n\t    return\n", "  }\n\t  if (!helpers.isHexColor(value as string)) {\n\t    field.report(messages.hexCode, 'hexCode', field)\n\t  }\n\t})\n\t/**\n\t * Validates the value to be a valid URL\n\t */\n\texport const urlRule = createRule<URLOptions | undefined>((value, options, field) => {\n\t  if (!field.isValid) {\n", "    return\n\t  }\n\t  if (!helpers.isURL(value as string, options)) {\n\t    field.report(messages.url, 'url', field)\n\t  }\n\t})\n\t/**\n\t * Validates the value to be an active URL\n\t */\n\texport const activeUrlRule = createRule(async (value, _, field) => {\n", "  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (!(await helpers.isActiveURL(value as string))) {\n\t    field.report(messages.activeUrl, 'activeUrl', field)\n\t  }\n\t})\n\t/**\n\t * Validates the value to contain only letters\n\t */\n", "export const alphaRule = createRule<AlphaOptions | undefined>((value, options, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  let characterSet = 'a-zA-Z'\n\t  if (options) {\n\t    if (options.allowSpaces) {\n\t      characterSet += '\\\\s'\n\t    }\n\t    if (options.allowDashes) {\n", "      characterSet += '-'\n\t    }\n\t    if (options.allowUnderscores) {\n\t      characterSet += '_'\n\t    }\n\t  }\n\t  const expression = new RegExp(`^[${characterSet}]+$`)\n\t  if (!expression.test(value as string)) {\n\t    field.report(messages.alpha, 'alpha', field)\n\t  }\n", "})\n\t/**\n\t * Validates the value to contain only letters and numbers\n\t */\n\texport const alphaNumericRule = createRule<AlphaNumericOptions | undefined>(\n\t  (value, options, field) => {\n\t    if (!field.isValid) {\n\t      return\n\t    }\n\t    let characterSet = 'a-zA-Z0-9'\n", "    if (options) {\n\t      if (options.allowSpaces) {\n\t        characterSet += '\\\\s'\n\t      }\n\t      if (options.allowDashes) {\n\t        characterSet += '-'\n\t      }\n\t      if (options.allowUnderscores) {\n\t        characterSet += '_'\n\t      }\n", "    }\n\t    const expression = new RegExp(`^[${characterSet}]+$`)\n\t    if (!expression.test(value as string)) {\n\t      field.report(messages.alphaNumeric, 'alphaNumeric', field)\n\t    }\n\t  }\n\t)\n\t/**\n\t * Enforce a minimum length on a string field\n\t */\n", "export const minLengthRule = createRule<{ min: number }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if ((value as string).length < options.min) {\n\t    field.report(messages.minLength, 'minLength', field, options)\n\t  }\n", "})\n\t/**\n\t * Enforce a maximum length on a string field\n\t */\n\texport const maxLengthRule = createRule<{ max: number }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n", "  }\n\t  if ((value as string).length > options.max) {\n\t    field.report(messages.maxLength, 'maxLength', field, options)\n\t  }\n\t})\n\t/**\n\t * Enforce a fixed length on a string field\n\t */\n\texport const fixedLengthRule = createRule<{ size: number }>((value, options, field) => {\n\t  /**\n", "   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if ((value as string).length !== options.size) {\n\t    field.report(messages.fixedLength, 'fixedLength', field, options)\n\t  }\n\t})\n\t/**\n", " * Ensure the value ends with the pre-defined substring\n\t */\n\texport const endsWithRule = createRule<{ substring: string }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (!(value as string).endsWith(options.substring)) {\n", "    field.report(messages.endsWith, 'endsWith', field, options)\n\t  }\n\t})\n\t/**\n\t * Ensure the value starts with the pre-defined substring\n\t */\n\texport const startsWithRule = createRule<{ substring: string }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n", "  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (!(value as string).startsWith(options.substring)) {\n\t    field.report(messages.startsWith, 'startsWith', field, options)\n\t  }\n\t})\n\t/**\n\t * Ensure the field's value under validation is the same as the other field's value\n\t */\n", "export const sameAsRule = createRule<{ otherField: string }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  const input = field.parent[options.otherField]\n\t  /**\n\t   * Performing validation and reporting error\n", "   */\n\t  if (input !== value) {\n\t    field.report(messages.sameAs, 'sameAs', field, options)\n\t    return\n\t  }\n\t})\n\t/**\n\t * Ensure the field's value under validation is different from another field's value\n\t */\n\texport const notSameAsRule = createRule<{ otherField: string }>((value, options, field) => {\n", "  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  const input = field.parent[options.otherField]\n\t  /**\n\t   * Performing validation and reporting error\n\t   */\n", "  if (input === value) {\n\t    field.report(messages.notSameAs, 'notSameAs', field, options)\n\t    return\n\t  }\n\t})\n\t/**\n\t * Ensure the field under validation is confirmed by\n\t * having another field with the same name\n\t */\n\texport const confirmedRule = createRule<{ confirmationField: string } | undefined>(\n", "  (value, options, field) => {\n\t    /**\n\t     * Skip if the field is not valid.\n\t     */\n\t    if (!field.isValid) {\n\t      return\n\t    }\n\t    const otherField = options?.confirmationField || `${field.name}_confirmation`\n\t    const input = field.parent[otherField]\n\t    /**\n", "     * Performing validation and reporting error\n\t     */\n\t    if (input !== value) {\n\t      field.report(messages.confirmed, 'confirmed', field, { otherField })\n\t      return\n\t    }\n\t  }\n\t)\n\t/**\n\t * Trims whitespaces around the string value\n", " */\n\texport const trimRule = createRule((value, _, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  field.mutate((value as string).trim(), field)\n\t})\n\t/**\n\t * Normalizes the email address\n\t */\n", "export const normalizeEmailRule = createRule<NormalizeEmailOptions | undefined>(\n\t  (value, options, field) => {\n\t    if (!field.isValid) {\n\t      return\n\t    }\n\t    field.mutate(normalizeEmail.default(value as string, options), field)\n\t  }\n\t)\n\t/**\n\t * Converts the field value to UPPERCASE.\n", " */\n\texport const toUpperCaseRule = createRule<string | string[] | undefined>(\n\t  (value, locales, field) => {\n\t    if (!field.isValid) {\n\t      return\n\t    }\n\t    field.mutate((value as string).toLocaleUpperCase(locales), field)\n\t  }\n\t)\n\t/**\n", " * Converts the field value to lowercase.\n\t */\n\texport const toLowerCaseRule = createRule<string | string[] | undefined>(\n\t  (value, locales, field) => {\n\t    if (!field.isValid) {\n\t      return\n\t    }\n\t    field.mutate((value as string).toLocaleLowerCase(locales), field)\n\t  }\n\t)\n", "/**\n\t * Converts the field value to camelCase.\n\t */\n\texport const toCamelCaseRule = createRule((value, _, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  field.mutate(camelcase(value as string), field)\n\t})\n\t/**\n", " * Escape string for HTML entities\n\t */\n\texport const escapeRule = createRule((value, _, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  field.mutate(escape.default(value as string), field)\n\t})\n\t/**\n\t * Normalize a URL\n", " */\n\texport const normalizeUrlRule = createRule<undefined | NormalizeUrlOptions>(\n\t  (value, options, field) => {\n\t    if (!field.isValid) {\n\t      return\n\t    }\n\t    field.mutate(normalizeUrl(value as string, options), field)\n\t  }\n\t)\n\t/**\n", " * Ensure the field's value under validation is a subset of the pre-defined list.\n\t */\n\texport const inRule = createRule<{ choices: string[] | ((field: FieldContext) => string[]) }>(\n\t  (value, options, field) => {\n\t    /**\n\t     * Skip if the field is not valid.\n\t     */\n\t    if (!field.isValid) {\n\t      return\n\t    }\n", "    const choices = typeof options.choices === 'function' ? options.choices(field) : options.choices\n\t    /**\n\t     * Performing validation and reporting error\n\t     */\n\t    if (!choices.includes(value as string)) {\n\t      field.report(messages.in, 'in', field, options)\n\t      return\n\t    }\n\t  }\n\t)\n", "/**\n\t * Ensure the field's value under validation is not inside the pre-defined list.\n\t */\n\texport const notInRule = createRule<{ list: string[] | ((field: FieldContext) => string[]) }>(\n\t  (value, options, field) => {\n\t    /**\n\t     * Skip if the field is not valid.\n\t     */\n\t    if (!field.isValid) {\n\t      return\n", "    }\n\t    const list = typeof options.list === 'function' ? options.list(field) : options.list\n\t    /**\n\t     * Performing validation and reporting error\n\t     */\n\t    if (list.includes(value as string)) {\n\t      field.report(messages.notIn, 'notIn', field, options)\n\t      return\n\t    }\n\t  }\n", ")\n\t/**\n\t * Validates the value to be a valid credit card number\n\t */\n\texport const creditCardRule = createRule<\n\t  CreditCardOptions | undefined | ((field: FieldContext) => CreditCardOptions | void | undefined)\n\t>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n", "  if (!field.isValid) {\n\t    return\n\t  }\n\t  const providers = options\n\t    ? typeof options === 'function'\n\t      ? options(field)?.provider || []\n\t      : options.provider\n\t    : []\n\t  if (!providers.length) {\n\t    if (!helpers.isCreditCard(value as string)) {\n", "      field.report(messages.creditCard, 'creditCard', field, {\n\t        providersList: 'credit',\n\t      })\n\t    }\n\t  } else {\n\t    const matchesAnyProvider = providers.find((provider) =>\n\t      helpers.isCreditCard(value as string, { provider })\n\t    )\n\t    if (!matchesAnyProvider) {\n\t      field.report(messages.creditCard, 'creditCard', field, {\n", "        providers: providers,\n\t        providersList: providers.join('/'),\n\t      })\n\t    }\n\t  }\n\t})\n\t/**\n\t * Validates the value to be a valid passport number\n\t */\n\texport const passportRule = createRule<\n", "  PassportOptions | ((field: FieldContext) => PassportOptions)\n\t>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  const countryCodes =\n\t    typeof options === 'function' ? options(field).countryCode : options.countryCode\n", "  const matchesAnyCountryCode = countryCodes.find((countryCode) =>\n\t    helpers.isPassportNumber(value as string, countryCode)\n\t  )\n\t  if (!matchesAnyCountryCode) {\n\t    field.report(messages.passport, 'passport', field, { countryCodes })\n\t  }\n\t})\n\t/**\n\t * Validates the value to be a valid postal code\n\t */\n", "export const postalCodeRule = createRule<\n\t  PostalCodeOptions | undefined | ((field: FieldContext) => PostalCodeOptions | void | undefined)\n\t>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  const countryCodes = options\n", "    ? typeof options === 'function'\n\t      ? options(field)?.countryCode || []\n\t      : options.countryCode\n\t    : []\n\t  if (!countryCodes.length) {\n\t    if (!helpers.isPostalCode(value as string, 'any')) {\n\t      field.report(messages.postalCode, 'postalCode', field)\n\t    }\n\t  } else {\n\t    const matchesAnyCountryCode = countryCodes.find((countryCode) =>\n", "      helpers.isPostalCode(value as string, countryCode)\n\t    )\n\t    if (!matchesAnyCountryCode) {\n\t      field.report(messages.postalCode, 'postalCode', field, { countryCodes })\n\t    }\n\t  }\n\t})\n\t/**\n\t * Validates the value to be a valid UUID\n\t */\n", "export const uuidRule = createRule<{ version?: (1 | 2 | 3 | 4 | 5)[] } | undefined>(\n\t  (value, options, field) => {\n\t    if (!field.isValid) {\n\t      return\n\t    }\n\t    if (!options || !options.version) {\n\t      if (!helpers.isUUID(value as string)) {\n\t        field.report(messages.uuid, 'uuid', field)\n\t      }\n\t    } else {\n", "      const matchesAnyVersion = options.version.find((version) =>\n\t        helpers.isUUID(value as string, version)\n\t      )\n\t      if (!matchesAnyVersion) {\n\t        field.report(messages.uuid, 'uuid', field, options)\n\t      }\n\t    }\n\t  }\n\t)\n\t/**\n", " * Validates the value contains ASCII characters only\n\t */\n\texport const asciiRule = createRule((value, _, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (!helpers.isAscii(value as string)) {\n\t    field.report(messages.ascii, 'ascii', field)\n\t  }\n\t})\n", "/**\n\t * Validates the value to be a valid IBAN number\n\t */\n\texport const ibanRule = createRule((value, _, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (!helpers.isIBAN(value as string)) {\n\t    field.report(messages.iban, 'iban', field)\n\t  }\n", "})\n\t/**\n\t * Validates the value to be a valid JWT token\n\t */\n\texport const jwtRule = createRule((value, _, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (!helpers.isJWT(value as string)) {\n\t    field.report(messages.jwt, 'jwt', field)\n", "  }\n\t})\n\t/**\n\t * Ensure the value is a string with latitude and longitude coordinates\n\t */\n\texport const coordinatesRule = createRule((value, _, field) => {\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (!helpers.isLatLong(value as string)) {\n", "    field.report(messages.coordinates, 'coordinates', field)\n\t  }\n\t})\n"]}
{"filename": "src/schema/union/conditional.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { ConditionalFn, RefsStore, UnionNode } from '@vinejs/compiler/types'\n\timport { OTYPE, COTYPE, PARSE } from '../../symbols.js'\n", "import type { ParserOptions, SchemaTypes } from '../../types.js'\n\t/**\n\t * Represents a union conditional type. A conditional is a predicate\n\t * with a schema\n\t */\n\texport class UnionConditional<Schema extends SchemaTypes> {\n\t  declare [OTYPE]: Schema[typeof OTYPE];\n\t  declare [COTYPE]: Schema[typeof COTYPE]\n\t  /**\n\t   * Properties to merge when conditonal is true\n", "   */\n\t  #schema: Schema\n\t  /**\n\t   * Conditional to evaluate\n\t   */\n\t  #conditional: ConditionalFn<Record<string, unknown>>\n\t  constructor(conditional: ConditionalFn<Record<string, unknown>>, schema: Schema) {\n\t    this.#schema = schema\n\t    this.#conditional = conditional\n\t  }\n", "  /**\n\t   * Compiles to a union conditional\n\t   */\n\t  [PARSE](\n\t    propertyName: string,\n\t    refs: RefsStore,\n\t    options: ParserOptions\n\t  ): UnionNode['conditions'][number] {\n\t    return {\n\t      conditionalFnRefId: refs.trackConditional(this.#conditional),\n", "      schema: this.#schema[PARSE](propertyName, refs, options),\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/schema/union/builder.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { VineUnion } from './main.js'\n\timport { UnionConditional } from './conditional.js'\n", "import type { FieldContext, SchemaTypes } from '../../types.js'\n\t/**\n\t * Create a new union schema type. A union is a collection of conditionals\n\t * and schema associated with it.\n\t */\n\texport function union<Conditional extends UnionConditional<any>>(conditionals: Conditional[]) {\n\t  return new VineUnion<Conditional>(conditionals)\n\t}\n\t/**\n\t * Wrap object properties inside a conditonal\n", " */\n\tunion.if = function unionIf<Schema extends SchemaTypes>(\n\t  conditon: (value: Record<string, unknown>, field: FieldContext) => any,\n\t  schema: Schema\n\t) {\n\t  return new UnionConditional<Schema>(conditon, schema)\n\t}\n\t/**\n\t * Wrap object properties inside an else conditon\n\t */\n", "union.else = function unionElse<Schema extends SchemaTypes>(schema: Schema) {\n\t  return new UnionConditional<Schema>(() => true, schema)\n\t}\n"]}
{"filename": "src/schema/union/main.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport camelcase from 'camelcase'\n\timport { RefsStore, UnionNode } from '@vinejs/compiler/types'\n", "import { messages } from '../../defaults.js'\n\timport { UnionConditional } from './conditional.js'\n\timport { OTYPE, COTYPE, PARSE } from '../../symbols.js'\n\timport type {\n\t  ConstructableSchema,\n\t  ParserOptions,\n\t  SchemaTypes,\n\t  UnionNoMatchCallback,\n\t} from '../../types.js'\n\t/**\n", " * Vine union represents a union data type. A union is a collection\n\t * of conditionals and each condition has an associated schema\n\t */\n\texport class VineUnion<Conditional extends UnionConditional<SchemaTypes>>\n\t  implements ConstructableSchema<Conditional[typeof OTYPE], Conditional[typeof COTYPE]>\n\t{\n\t  declare [OTYPE]: Conditional[typeof OTYPE];\n\t  declare [COTYPE]: Conditional[typeof COTYPE]\n\t  #conditionals: Conditional[]\n\t  #otherwiseCallback: UnionNoMatchCallback<Record<string, unknown>> = (_, field) => {\n", "    field.report(messages.union, 'union', field)\n\t  }\n\t  constructor(conditionals: Conditional[]) {\n\t    this.#conditionals = conditionals\n\t  }\n\t  /**\n\t   * Define a fallback method to invoke when all of the union conditions\n\t   * fail. You may use this method to report an error.\n\t   */\n\t  otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this {\n", "    this.#otherwiseCallback = callback\n\t    return this\n\t  }\n\t  /**\n\t   * Clones the VineUnion schema type.\n\t   */\n\t  clone(): this {\n\t    const cloned = new VineUnion<Conditional>(this.#conditionals)\n\t    cloned.otherwise(this.#otherwiseCallback)\n\t    return cloned as this\n", "  }\n\t  /**\n\t   * Compiles to a union\n\t   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): UnionNode {\n\t    return {\n\t      type: 'union',\n\t      fieldName: propertyName,\n\t      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n\t      elseConditionalFnRefId: refs.trackConditional(this.#otherwiseCallback),\n", "      conditions: this.#conditionals.map((conditional) =>\n\t        conditional[PARSE](propertyName, refs, options)\n\t      ),\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/schema/literal/main.ts", "chunked_list": ["/*\n\t * vinejs\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { equalsRule } from './rules.js'\n\timport { BaseLiteralType } from '../base/literal.js'\n", "import type { FieldOptions, Validation } from '../../types.js'\n\t/**\n\t * VineLiteral represents a type that matches an exact value\n\t */\n\texport class VineLiteral<Value> extends BaseLiteralType<Value, Value> {\n\t  /**\n\t   * Default collection of literal rules\n\t   */\n\t  static rules = {\n\t    equals: equalsRule,\n", "  }\n\t  #value: Value\n\t  constructor(value: Value, options?: FieldOptions, validations?: Validation<any>[]) {\n\t    super(options, validations || [equalsRule({ expectedValue: value })])\n\t    this.#value = value\n\t  }\n\t  /**\n\t   * Clones the VineLiteral schema type. The applied options\n\t   * and validations are copied to the new instance\n\t   */\n", "  clone(): this {\n\t    return new VineLiteral(this.#value, this.cloneOptions(), this.cloneValidations()) as this\n\t  }\n\t}\n"]}
{"filename": "src/schema/literal/rules.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { messages } from '../../defaults.js'\n\timport { helpers } from '../../vine/helpers.js'\n", "import { createRule } from '../../vine/create_rule.js'\n\t/**\n\t * Verifies two equals are equal considering the HTML forms\n\t * serialization behavior.\n\t */\n\texport const equalsRule = createRule<{ expectedValue: any }>((value, options, field) => {\n\t  let input = value\n\t  /**\n\t   * Normalizing the field value as per the expected\n\t   * value.\n", "   */\n\t  if (typeof options.expectedValue === 'boolean') {\n\t    input = helpers.asBoolean(value)\n\t  } else if (typeof options.expectedValue === 'number') {\n\t    input = helpers.asNumber(value)\n\t  }\n\t  /**\n\t   * Performing validation and reporting error\n\t   */\n\t  if (input !== options.expectedValue) {\n", "    field.report(messages.literal, 'literal', field, options)\n\t    return\n\t  }\n\t  /**\n\t   * Mutating input with normalized value\n\t   */\n\t  field.mutate(input, field)\n\t})\n"]}
{"filename": "src/schema/enum/main.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { enumRule } from './rules.js'\n\timport { BaseLiteralType } from '../base/literal.js'\n", "import type { FieldContext, FieldOptions, Validation } from '../../types.js'\n\t/**\n\t * VineEnum represents a enum data type that performs validation\n\t * against a pre-defined choices list.\n\t */\n\texport class VineEnum<const Values extends readonly unknown[]> extends BaseLiteralType<\n\t  Values[number],\n\t  Values[number]\n\t> {\n\t  /**\n", "   * Default collection of enum rules\n\t   */\n\t  static rules = {\n\t    enum: enumRule,\n\t  }\n\t  #values: Values | ((field: FieldContext) => Values)\n\t  /**\n\t   * Returns the enum choices\n\t   */\n\t  getChoices() {\n", "    return this.#values\n\t  }\n\t  constructor(\n\t    values: Values | ((field: FieldContext) => Values),\n\t    options?: FieldOptions,\n\t    validations?: Validation<any>[]\n\t  ) {\n\t    super(options, validations || [enumRule({ choices: values })])\n\t    this.#values = values\n\t  }\n", "  /**\n\t   * Clones the VineEnum schema type. The applied options\n\t   * and validations are copied to the new instance\n\t   */\n\t  clone(): this {\n\t    return new VineEnum(this.#values, this.cloneOptions(), this.cloneValidations()) as this\n\t  }\n\t}\n"]}
{"filename": "src/schema/enum/rules.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { createRule } from '../../vine/create_rule.js'\n\timport { messages } from '../../defaults.js'\n", "import { FieldContext } from '@vinejs/compiler/types'\n\t/**\n\t * Enum rule is used to validate the field's value to be one\n\t * from the pre-defined choices.\n\t */\n\texport const enumRule = createRule<{\n\t  choices: readonly any[] | ((field: FieldContext) => readonly any[])\n\t}>((value, options, field) => {\n\t  const choices = typeof options.choices === 'function' ? options.choices(field) : options.choices\n\t  /**\n", "   * Report error when value is not part of the pre-defined\n\t   * options\n\t   */\n\t  if (!choices.includes(value)) {\n\t    field.report(messages.enum, 'enum', field, { choices })\n\t  }\n\t})\n"]}
{"filename": "src/schema/enum/native_enum.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { enumRule } from './rules.js'\n\timport { BaseLiteralType } from '../base/literal.js'\n", "import type { EnumLike, FieldOptions, Validation } from '../../types.js'\n\t/**\n\t * VineNativeEnum represents a enum data type that performs validation\n\t * against a pre-defined choices list.\n\t *\n\t * The choices list is derived from TypeScript enum data type or an\n\t * object\n\t */\n\texport class VineNativeEnum<Values extends EnumLike> extends BaseLiteralType<\n\t  Values[keyof Values],\n", "  Values[keyof Values]\n\t> {\n\t  /**\n\t   * Default collection of enum rules\n\t   */\n\t  static rules = {\n\t    enum: enumRule,\n\t  }\n\t  #values: Values\n\t  constructor(values: Values, options?: FieldOptions, validations?: Validation<any>[]) {\n", "    super(options, validations || [enumRule({ choices: Object.values(values) })])\n\t    this.#values = values\n\t  }\n\t  /**\n\t   * Clones the VineNativeEnum schema type. The applied options\n\t   * and validations are copied to the new instance\n\t   */\n\t  clone(): this {\n\t    return new VineNativeEnum(this.#values, this.cloneOptions(), this.cloneValidations()) as this\n\t  }\n", "}\n"]}
{"filename": "src/schema/any/main.ts", "chunked_list": ["/*\n\t * vinejs\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { BaseLiteralType } from '../base/literal.js'\n\timport type { FieldOptions, Validation } from '../../types.js'\n", "/**\n\t * VineAny represents a value that can be anything\n\t */\n\texport class VineAny extends BaseLiteralType<any, any> {\n\t  constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]) {\n\t    super(options, validations)\n\t  }\n\t  /**\n\t   * Clones the VineAny schema type. The applied options\n\t   * and validations are copied to the new instance\n", "   */\n\t  clone(): this {\n\t    return new VineAny(this.cloneOptions(), this.cloneValidations()) as this\n\t  }\n\t}\n"]}
{"filename": "src/schema/number/main.ts", "chunked_list": ["/*\n\t * vinejs\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { helpers } from '../../vine/helpers.js'\n\timport { BaseLiteralType } from '../base/literal.js'\n", "import { FieldOptions, Validation } from '../../types.js'\n\timport { IS_OF_TYPE, UNIQUE_NAME } from '../../symbols.js'\n\timport {\n\t  maxRule,\n\t  minRule,\n\t  rangeRule,\n\t  numberRule,\n\t  decimalRule,\n\t  negativeRule,\n\t  positiveRule,\n", "  withoutDecimalsRule,\n\t} from './rules.js'\n\t/**\n\t * VineNumber represents a numeric value in the validation schema.\n\t */\n\texport class VineNumber extends BaseLiteralType<number, number> {\n\t  protected declare options: FieldOptions & { strict?: boolean }\n\t  /**\n\t   * Default collection of number rules\n\t   */\n", "  static rules = {\n\t    max: maxRule,\n\t    min: minRule,\n\t    range: rangeRule,\n\t    number: numberRule,\n\t    decimal: decimalRule,\n\t    negative: negativeRule,\n\t    positive: positiveRule,\n\t    withoutDecimals: withoutDecimalsRule,\n\t  };\n", "  /**\n\t   * The property must be implemented for \"unionOfTypes\"\n\t   */\n\t  [UNIQUE_NAME] = 'vine.number';\n\t  /**\n\t   * Checks if the value is of number type. The method must be\n\t   * implemented for \"unionOfTypes\"\n\t   */\n\t  [IS_OF_TYPE] = (value: unknown) => {\n\t    const valueAsNumber = helpers.asNumber(value)\n", "    return !Number.isNaN(valueAsNumber)\n\t  }\n\t  constructor(\n\t    options?: Partial<FieldOptions> & { strict?: boolean },\n\t    validations?: Validation<any>[]\n\t  ) {\n\t    super(options, validations || [numberRule(options || {})])\n\t  }\n\t  /**\n\t   * Enforce a minimum value for the number input\n", "   */\n\t  min(value: number) {\n\t    return this.use(minRule({ min: value }))\n\t  }\n\t  /**\n\t   * Enforce a maximum value for the number input\n\t   */\n\t  max(value: number) {\n\t    return this.use(maxRule({ max: value }))\n\t  }\n", "  /**\n\t   * Enforce value to be within the range of minimum and maximum output.\n\t   */\n\t  range(value: [min: number, max: number]) {\n\t    return this.use(rangeRule({ min: value[0], max: value[1] }))\n\t  }\n\t  /**\n\t   * Enforce the value be a positive number\n\t   */\n\t  positive() {\n", "    return this.use(positiveRule())\n\t  }\n\t  /**\n\t   * Enforce the value be a negative number\n\t   */\n\t  negative() {\n\t    return this.use(negativeRule())\n\t  }\n\t  /**\n\t   * Enforce the value to have fixed or range\n", "   * of decimal places\n\t   */\n\t  decimal(range: number | [number, number]) {\n\t    return this.use(decimalRule({ range: Array.isArray(range) ? range : [range] }))\n\t  }\n\t  /**\n\t   * Enforce the value to be an integer (aka without decimals)\n\t   */\n\t  withoutDecimals() {\n\t    return this.use(withoutDecimalsRule())\n", "  }\n\t  /**\n\t   * Clones the VineNumber schema type. The applied options\n\t   * and validations are copied to the new instance\n\t   */\n\t  clone(): this {\n\t    return new VineNumber(this.cloneOptions(), this.cloneValidations()) as this\n\t  }\n\t}\n"]}
{"filename": "src/schema/number/rules.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { helpers } from '../../vine/helpers.js'\n\timport { createRule } from '../../vine/create_rule.js'\n", "import { messages } from '../../defaults.js'\n\t/**\n\t * Enforce the value to be a number or a string representation\n\t * of a number\n\t */\n\texport const numberRule = createRule<{ strict?: boolean }>((value, options, field) => {\n\t  const valueAsNumber = options.strict ? value : helpers.asNumber(value)\n\t  if (\n\t    typeof valueAsNumber !== 'number' ||\n\t    Number.isNaN(valueAsNumber) ||\n", "    valueAsNumber === Number.POSITIVE_INFINITY ||\n\t    valueAsNumber === Number.NEGATIVE_INFINITY\n\t  ) {\n\t    field.report(messages.number, 'number', field)\n\t    return\n\t  }\n\t  field.mutate(valueAsNumber, field)\n\t})\n\t/**\n\t * Enforce a minimum value on a number field\n", " */\n\texport const minRule = createRule<{ min: number }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if ((value as number) < options.min) {\n\t    field.report(messages.min, 'min', field, options)\n", "  }\n\t})\n\t/**\n\t * Enforce a maximum value on a number field\n\t */\n\texport const maxRule = createRule<{ max: number }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n", "    return\n\t  }\n\t  if ((value as number) > options.max) {\n\t    field.report(messages.max, 'max', field, options)\n\t  }\n\t})\n\t/**\n\t * Enforce a range of values on a number field.\n\t */\n\texport const rangeRule = createRule<{ min: number; max: number }>((value, options, field) => {\n", "  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if ((value as number) < options.min || (value as number) > options.max) {\n\t    field.report(messages.range, 'range', field, options)\n\t  }\n\t})\n", "/**\n\t * Enforce the value is a positive number\n\t */\n\texport const positiveRule = createRule((value, _, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n", "  if ((value as number) < 0) {\n\t    field.report(messages.positive, 'positive', field)\n\t  }\n\t})\n\t/**\n\t * Enforce the value is a negative number\n\t */\n\texport const negativeRule = createRule<undefined>((value, _, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n", "   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if ((value as number) >= 0) {\n\t    field.report(messages.negative, 'negative', field)\n\t  }\n\t})\n\t/**\n\t * Enforce the value to have a fixed or range of decimals\n", " */\n\texport const decimalRule = createRule<{ range: [number, number?] }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (\n\t    !helpers.isDecimal(String(value), {\n", "      force_decimal: options.range[0] !== 0,\n\t      decimal_digits: options.range.join(','),\n\t    })\n\t  ) {\n\t    field.report(messages.decimal, 'decimal', field, { digits: options.range.join('-') })\n\t  }\n\t})\n\t/**\n\t * Enforce the value to not have decimal places\n\t */\n", "export const withoutDecimalsRule = createRule((value, _, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  if (!Number.isInteger(value)) {\n\t    field.report(messages.withoutDecimals, 'withoutDecimals', field)\n\t  }\n", "})\n"]}
{"filename": "src/schema/record/main.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport camelcase from 'camelcase'\n\timport { RefsStore, RecordNode } from '@vinejs/compiler/types'\n", "import { BaseType } from '../base/main.js'\n\timport { OTYPE, COTYPE, PARSE, UNIQUE_NAME, IS_OF_TYPE } from '../../symbols.js'\n\timport type { FieldOptions, ParserOptions, SchemaTypes, Validation } from '../../types.js'\n\timport { fixedLengthRule, maxLengthRule, minLengthRule, validateKeysRule } from './rules.js'\n\t/**\n\t * VineRecord represents an object of key-value pair in which\n\t * keys are unknown\n\t */\n\texport class VineRecord<Schema extends SchemaTypes> extends BaseType<\n\t  { [K: string]: Schema[typeof OTYPE] },\n", "  { [K: string]: Schema[typeof COTYPE] }\n\t> {\n\t  /**\n\t   * Default collection of record rules\n\t   */\n\t  static rules = {\n\t    maxLength: maxLengthRule,\n\t    minLength: minLengthRule,\n\t    fixedLength: fixedLengthRule,\n\t    validateKeys: validateKeysRule,\n", "  }\n\t  #schema: Schema;\n\t  /**\n\t   * The property must be implemented for \"unionOfTypes\"\n\t   */\n\t  [UNIQUE_NAME] = 'vine.object';\n\t  /**\n\t   * Checks if the value is of object type. The method must be\n\t   * implemented for \"unionOfTypes\"\n\t   */\n", "  [IS_OF_TYPE] = (value: unknown) => {\n\t    return value !== null && typeof value === 'object' && !Array.isArray(value)\n\t  }\n\t  constructor(schema: Schema, options?: FieldOptions, validations?: Validation<any>[]) {\n\t    super(options, validations)\n\t    this.#schema = schema\n\t  }\n\t  /**\n\t   * Enforce a minimum length on an object field\n\t   */\n", "  minLength(expectedLength: number) {\n\t    return this.use(minLengthRule({ min: expectedLength }))\n\t  }\n\t  /**\n\t   * Enforce a maximum length on an object field\n\t   */\n\t  maxLength(expectedLength: number) {\n\t    return this.use(maxLengthRule({ max: expectedLength }))\n\t  }\n\t  /**\n", "   * Enforce a fixed length on an object field\n\t   */\n\t  fixedLength(expectedLength: number) {\n\t    return this.use(fixedLengthRule({ size: expectedLength }))\n\t  }\n\t  /**\n\t   * Register a callback to validate the object keys\n\t   */\n\t  validateKeys(...args: Parameters<typeof validateKeysRule>) {\n\t    return this.use(validateKeysRule(...args))\n", "  }\n\t  /**\n\t   * Clones the VineRecord schema type. The applied options\n\t   * and validations are copied to the new instance\n\t   */\n\t  clone(): this {\n\t    return new VineRecord(\n\t      this.#schema.clone(),\n\t      this.cloneOptions(),\n\t      this.cloneValidations()\n", "    ) as this\n\t  }\n\t  /**\n\t   * Compiles to record data type\n\t   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): RecordNode {\n\t    return {\n\t      type: 'record',\n\t      fieldName: propertyName,\n\t      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n", "      bail: this.options.bail,\n\t      allowNull: this.options.allowNull,\n\t      isOptional: this.options.isOptional,\n\t      each: this.#schema[PARSE]('*', refs, options),\n\t      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,\n\t      validations: this.compileValidations(refs),\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/schema/record/rules.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { FieldContext } from '@vinejs/compiler/types'\n\timport { messages } from '../../defaults.js'\n", "import { createRule } from '../../vine/create_rule.js'\n\t/**\n\t * Enforce a minimum length on an object field\n\t */\n\texport const minLengthRule = createRule<{ min: number }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n", "  }\n\t  /**\n\t   * Value will always be an object if the field is valid.\n\t   */\n\t  if (Object.keys(value as Record<string, any>).length < options.min) {\n\t    field.report(messages['record.minLength'], 'record.minLength', field, options)\n\t  }\n\t})\n\t/**\n\t * Enforce a maximum length on an object field\n", " */\n\texport const maxLengthRule = createRule<{ max: number }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  /**\n\t   * Value will always be an object if the field is valid.\n", "   */\n\t  if (Object.keys(value as Record<string, any>).length > options.max) {\n\t    field.report(messages['record.maxLength'], 'record.maxLength', field, options)\n\t  }\n\t})\n\t/**\n\t * Enforce a fixed length on an object field\n\t */\n\texport const fixedLengthRule = createRule<{ size: number }>((value, options, field) => {\n\t  /**\n", "   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  /**\n\t   * Value will always be an object if the field is valid.\n\t   */\n\t  if (Object.keys(value as Record<string, any>).length !== options.size) {\n\t    field.report(messages['record.fixedLength'], 'record.fixedLength', field, options)\n", "  }\n\t})\n\t/**\n\t * Register a callback to validate the object keys\n\t */\n\texport const validateKeysRule = createRule<(keys: string[], field: FieldContext) => void>(\n\t  (value, callback, field) => {\n\t    /**\n\t     * Skip if the field is not valid.\n\t     */\n", "    if (!field.isValid) {\n\t      return\n\t    }\n\t    callback(Object.keys(value as Record<string, any>), field)\n\t  }\n\t)\n"]}
{"filename": "src/schema/array/main.ts", "chunked_list": ["/*\n\t * vinejs\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport camelcase from 'camelcase'\n\timport { RefsStore, ArrayNode } from '@vinejs/compiler/types'\n", "import { BaseType } from '../base/main.js'\n\timport { OTYPE, COTYPE, PARSE, UNIQUE_NAME, IS_OF_TYPE } from '../../symbols.js'\n\timport type { FieldOptions, ParserOptions, SchemaTypes, Validation } from '../../types.js'\n\timport {\n\t  compactRule,\n\t  notEmptyRule,\n\t  distinctRule,\n\t  minLengthRule,\n\t  maxLengthRule,\n\t  fixedLengthRule,\n", "} from './rules.js'\n\t/**\n\t * VineArray represents an array schema type in the validation\n\t * pipeline\n\t */\n\texport class VineArray<Schema extends SchemaTypes> extends BaseType<\n\t  Schema[typeof OTYPE][],\n\t  Schema[typeof COTYPE][]\n\t> {\n\t  /**\n", "   * Default collection of array rules\n\t   */\n\t  static rules = {\n\t    compact: compactRule,\n\t    notEmpty: notEmptyRule,\n\t    distinct: distinctRule,\n\t    minLength: minLengthRule,\n\t    maxLength: maxLengthRule,\n\t    fixedLength: fixedLengthRule,\n\t  }\n", "  #schema: Schema;\n\t  /**\n\t   * The property must be implemented for \"unionOfTypes\"\n\t   */\n\t  [UNIQUE_NAME] = 'vine.array';\n\t  /**\n\t   * Checks if the value is of array type. The method must be\n\t   * implemented for \"unionOfTypes\"\n\t   */\n\t  [IS_OF_TYPE] = (value: unknown) => {\n", "    return Array.isArray(value)\n\t  }\n\t  constructor(schema: Schema, options?: FieldOptions, validations?: Validation<any>[]) {\n\t    super(options, validations)\n\t    this.#schema = schema\n\t  }\n\t  /**\n\t   * Enforce a minimum length on an array field\n\t   */\n\t  minLength(expectedLength: number) {\n", "    return this.use(minLengthRule({ min: expectedLength }))\n\t  }\n\t  /**\n\t   * Enforce a maximum length on an array field\n\t   */\n\t  maxLength(expectedLength: number) {\n\t    return this.use(maxLengthRule({ max: expectedLength }))\n\t  }\n\t  /**\n\t   * Enforce a fixed length on an array field\n", "   */\n\t  fixedLength(expectedLength: number) {\n\t    return this.use(fixedLengthRule({ size: expectedLength }))\n\t  }\n\t  /**\n\t   * Ensure the array is not empty\n\t   */\n\t  notEmpty() {\n\t    return this.use(notEmptyRule())\n\t  }\n", "  /**\n\t   * Ensure array elements are distinct/unique\n\t   */\n\t  distinct(fields?: string | string[]) {\n\t    return this.use(distinctRule({ fields }))\n\t  }\n\t  /**\n\t   * Removes empty strings, null and undefined values from the array\n\t   */\n\t  compact() {\n", "    return this.use(compactRule())\n\t  }\n\t  /**\n\t   * Clones the VineArray schema type. The applied options\n\t   * and validations are copied to the new instance\n\t   */\n\t  clone(): this {\n\t    return new VineArray(this.#schema.clone(), this.cloneOptions(), this.cloneValidations()) as this\n\t  }\n\t  /**\n", "   * Compiles to array data type\n\t   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ArrayNode {\n\t    return {\n\t      type: 'array',\n\t      fieldName: propertyName,\n\t      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n\t      bail: this.options.bail,\n\t      allowNull: this.options.allowNull,\n\t      isOptional: this.options.isOptional,\n", "      each: this.#schema[PARSE]('*', refs, options),\n\t      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,\n\t      validations: this.compileValidations(refs),\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/schema/array/rules.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { helpers } from '../../vine/helpers.js'\n\timport { messages } from '../../defaults.js'\n", "import { createRule } from '../../vine/create_rule.js'\n\t/**\n\t * Enforce a minimum length on an array field\n\t */\n\texport const minLengthRule = createRule<{ min: number }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n", "  }\n\t  /**\n\t   * Value will always be an array if the field is valid.\n\t   */\n\t  if ((value as unknown[]).length < options.min) {\n\t    field.report(messages['array.minLength'], 'array.minLength', field, options)\n\t  }\n\t})\n\t/**\n\t * Enforce a maximum length on an array field\n", " */\n\texport const maxLengthRule = createRule<{ max: number }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  /**\n\t   * Value will always be an array if the field is valid.\n", "   */\n\t  if ((value as unknown[]).length > options.max) {\n\t    field.report(messages['array.maxLength'], 'array.maxLength', field, options)\n\t  }\n\t})\n\t/**\n\t * Enforce a fixed length on an array field\n\t */\n\texport const fixedLengthRule = createRule<{ size: number }>((value, options, field) => {\n\t  /**\n", "   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  /**\n\t   * Value will always be an array if the field is valid.\n\t   */\n\t  if ((value as unknown[]).length !== options.size) {\n\t    field.report(messages['array.fixedLength'], 'array.fixedLength', field, options)\n", "  }\n\t})\n\t/**\n\t * Ensure the array is not empty\n\t */\n\texport const notEmptyRule = createRule<undefined>((value, _, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n", "    return\n\t  }\n\t  /**\n\t   * Value will always be an array if the field is valid.\n\t   */\n\t  if ((value as unknown[]).length <= 0) {\n\t    field.report(messages.notEmpty, 'notEmpty', field)\n\t  }\n\t})\n\t/**\n", " * Ensure array elements are distinct/unique\n\t */\n\texport const distinctRule = createRule<{ fields?: string | string[] }>((value, options, field) => {\n\t  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  /**\n", "   * Value will always be an array if the field is valid.\n\t   */\n\t  if (!helpers.isDistinct(value as any[], options.fields)) {\n\t    field.report(messages.distinct, 'distinct', field, options)\n\t  }\n\t})\n\t/**\n\t * Removes empty strings, null and undefined values from the array\n\t */\n\texport const compactRule = createRule<undefined>((value, _, field) => {\n", "  /**\n\t   * Skip if the field is not valid.\n\t   */\n\t  if (!field.isValid) {\n\t    return\n\t  }\n\t  field.mutate(\n\t    (value as unknown[]).filter((item) => helpers.exists(item) && item !== ''),\n\t    field\n\t  )\n", "})\n"]}
{"filename": "src/schema/base/literal.ts", "chunked_list": ["/*\n\t * vinejs\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport camelcase from 'camelcase'\n\timport Macroable from '@poppinss/macroable'\n", "import type { LiteralNode, RefsStore } from '@vinejs/compiler/types'\n\timport { OTYPE, COTYPE, PARSE, VALIDATION } from '../../symbols.js'\n\timport type {\n\t  Parser,\n\t  Validation,\n\t  RuleBuilder,\n\t  Transformer,\n\t  FieldOptions,\n\t  ParserOptions,\n\t  ConstructableSchema,\n", "} from '../../types.js'\n\t/**\n\t * Base schema type with only modifiers applicable on all the schema types.\n\t */\n\tabstract class BaseModifiersType<Output, CamelCaseOutput>\n\t  extends Macroable\n\t  implements ConstructableSchema<Output, CamelCaseOutput>\n\t{\n\t  /**\n\t   * Each subtype should implement the compile method that returns\n", "   * one of the known compiler nodes\n\t   */\n\t  abstract [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode\n\t  /**\n\t   * The child class must implement the clone method\n\t   */\n\t  abstract clone(): this\n\t  /**\n\t   * The output value of the field. The property points to a type only\n\t   * and not the real value.\n", "   */\n\t  declare [OTYPE]: Output;\n\t  declare [COTYPE]: CamelCaseOutput\n\t  /**\n\t   * Mark the field under validation as optional. An optional\n\t   * field allows both null and undefined values.\n\t   */\n\t  optional(): OptionalModifier<this> {\n\t    return new OptionalModifier(this)\n\t  }\n", "  /**\n\t   * Mark the field under validation to be null. The null value will\n\t   * be written to the output as well.\n\t   *\n\t   * If `optional` and `nullable` are used together, then both undefined\n\t   * and null values will be allowed.\n\t   */\n\t  nullable(): NullableModifier<this> {\n\t    return new NullableModifier(this)\n\t  }\n", "  /**\n\t   * Apply transform on the final validated value. The transform method may\n\t   * convert the value to any new datatype.\n\t   */\n\t  transform<TransformedOutput>(\n\t    transformer: Transformer<this, TransformedOutput>\n\t  ): TransformModifier<this, TransformedOutput> {\n\t    return new TransformModifier(transformer, this)\n\t  }\n\t}\n", "/**\n\t * Modifies the schema type to allow null values\n\t */\n\tclass NullableModifier<Schema extends BaseModifiersType<any, any>> extends BaseModifiersType<\n\t  Schema[typeof OTYPE] | null,\n\t  Schema[typeof COTYPE] | null\n\t> {\n\t  #parent: Schema\n\t  constructor(parent: Schema) {\n\t    super()\n", "    this.#parent = parent\n\t  }\n\t  /**\n\t   * Creates a fresh instance of the underlying schema type\n\t   * and wraps it inside the nullable modifier\n\t   */\n\t  clone(): this {\n\t    return new NullableModifier(this.#parent.clone()) as this\n\t  }\n\t  /**\n", "   * Compiles to compiler node\n\t   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode {\n\t    const output = this.#parent[PARSE](propertyName, refs, options)\n\t    output.allowNull = true\n\t    return output\n\t  }\n\t}\n\t/**\n\t * Modifies the schema type to allow undefined values\n", " */\n\tclass OptionalModifier<Schema extends BaseModifiersType<any, any>> extends BaseModifiersType<\n\t  Schema[typeof OTYPE] | undefined,\n\t  Schema[typeof COTYPE] | undefined\n\t> {\n\t  #parent: Schema\n\t  constructor(parent: Schema) {\n\t    super()\n\t    this.#parent = parent\n\t  }\n", "  /**\n\t   * Creates a fresh instance of the underlying schema type\n\t   * and wraps it inside the optional modifier\n\t   */\n\t  clone(): this {\n\t    return new OptionalModifier(this.#parent.clone()) as this\n\t  }\n\t  /**\n\t   * Compiles to compiler node\n\t   */\n", "  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode {\n\t    const output = this.#parent[PARSE](propertyName, refs, options)\n\t    output.isOptional = true\n\t    return output\n\t  }\n\t}\n\t/**\n\t * Modifies the schema type to allow custom transformed values\n\t */\n\tclass TransformModifier<\n", "  Schema extends BaseModifiersType<any, any>,\n\t  Output,\n\t> extends BaseModifiersType<Output, Output> {\n\t  /**\n\t   * The output value of the field. The property points to a type only\n\t   * and not the real value.\n\t   */\n\t  declare [OTYPE]: Output;\n\t  declare [COTYPE]: Output\n\t  #parent: Schema\n", "  #transform: Transformer<Schema, Output>\n\t  constructor(transform: Transformer<Schema, Output>, parent: Schema) {\n\t    super()\n\t    this.#transform = transform\n\t    this.#parent = parent\n\t  }\n\t  /**\n\t   * Creates a fresh instance of the underlying schema type\n\t   * and wraps it inside the transform modifier.\n\t   */\n", "  clone(): this {\n\t    return new TransformModifier(this.#transform, this.#parent.clone()) as this\n\t  }\n\t  /**\n\t   * Compiles to compiler node\n\t   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode {\n\t    const output = this.#parent[PARSE](propertyName, refs, options)\n\t    output.transformFnId = refs.trackTransformer(this.#transform)\n\t    return output\n", "  }\n\t}\n\t/**\n\t * The base type for creating a custom literal type. Literal type\n\t * is a schema type that has no children elements.\n\t */\n\texport abstract class BaseLiteralType<Output, CamelCaseOutput> extends BaseModifiersType<\n\t  Output,\n\t  CamelCaseOutput\n\t> {\n", "  /**\n\t   * The child class must implement the clone method\n\t   */\n\t  abstract clone(): this\n\t  /**\n\t   * Field options\n\t   */\n\t  protected options: FieldOptions\n\t  /**\n\t   * Set of validations to run\n", "   */\n\t  protected validations: Validation<any>[]\n\t  constructor(options?: Partial<FieldOptions>, validations?: Validation<any>[]) {\n\t    super()\n\t    this.options = {\n\t      bail: true,\n\t      allowNull: false,\n\t      isOptional: false,\n\t      ...options,\n\t    }\n", "    this.validations = validations || []\n\t  }\n\t  /**\n\t   * Shallow clones the validations. Since, there are no API's to mutate\n\t   * the validation options, we can safely copy them by reference.\n\t   */\n\t  protected cloneValidations(): Validation<any>[] {\n\t    return this.validations.map((validation) => {\n\t      return {\n\t        options: validation.options,\n", "        rule: validation.rule,\n\t      }\n\t    })\n\t  }\n\t  /**\n\t   * Shallow clones the options\n\t   */\n\t  protected cloneOptions(): FieldOptions {\n\t    return { ...this.options }\n\t  }\n", "  /**\n\t   * Compiles validations\n\t   */\n\t  protected compileValidations(refs: RefsStore) {\n\t    return this.validations.map((validation) => {\n\t      return {\n\t        ruleFnId: refs.track({\n\t          validator: validation.rule.validator,\n\t          options: validation.options,\n\t        }),\n", "        implicit: validation.rule.implicit,\n\t        isAsync: validation.rule.isAsync,\n\t      }\n\t    })\n\t  }\n\t  /**\n\t   * Define a method to parse the input value. The method\n\t   * is invoked before any validation and hence you must\n\t   * perform type-checking to know the value you are\n\t   * working it.\n", "   */\n\t  parse(callback: Parser): this {\n\t    this.options.parse = callback\n\t    return this\n\t  }\n\t  /**\n\t   * Push a validation to the validations chain.\n\t   */\n\t  use(validation: Validation<any> | RuleBuilder): this {\n\t    this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation)\n", "    return this\n\t  }\n\t  /**\n\t   * Enable/disable the bail mode. In bail mode, the field validations\n\t   * are stopped after the first error.\n\t   */\n\t  bail(state: boolean) {\n\t    this.options.bail = state\n\t    return this\n\t  }\n", "  /**\n\t   * Compiles the schema type to a compiler node\n\t   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): LiteralNode {\n\t    return {\n\t      type: 'literal',\n\t      fieldName: propertyName,\n\t      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n\t      bail: this.options.bail,\n\t      allowNull: this.options.allowNull,\n", "      isOptional: this.options.isOptional,\n\t      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,\n\t      validations: this.compileValidations(refs),\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/schema/base/main.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type { CompilerNodes, RefsStore } from '@vinejs/compiler/types'\n\timport { OTYPE, COTYPE, PARSE, VALIDATION } from '../../symbols.js'\n", "import type {\n\t  Parser,\n\t  Validation,\n\t  RuleBuilder,\n\t  FieldOptions,\n\t  ParserOptions,\n\t  ConstructableSchema,\n\t} from '../../types.js'\n\timport Macroable from '@poppinss/macroable'\n\t/**\n", " * Base schema type with only modifiers applicable on all the schema types.\n\t */\n\texport abstract class BaseModifiersType<Output, CamelCaseOutput>\n\t  extends Macroable\n\t  implements ConstructableSchema<Output, CamelCaseOutput>\n\t{\n\t  /**\n\t   * Each subtype should implement the compile method that returns\n\t   * one of the known compiler nodes\n\t   */\n", "  abstract [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes\n\t  /**\n\t   * The child class must implement the clone method\n\t   */\n\t  abstract clone(): this\n\t  /**\n\t   * The output value of the field. The property points to a type only\n\t   * and not the real value.\n\t   */\n\t  declare [OTYPE]: Output;\n", "  declare [COTYPE]: CamelCaseOutput\n\t  /**\n\t   * Mark the field under validation as optional. An optional\n\t   * field allows both null and undefined values.\n\t   */\n\t  optional(): OptionalModifier<this> {\n\t    return new OptionalModifier(this)\n\t  }\n\t  /**\n\t   * Mark the field under validation to be null. The null value will\n", "   * be written to the output as well.\n\t   *\n\t   * If `optional` and `nullable` are used together, then both undefined\n\t   * and null values will be allowed.\n\t   */\n\t  nullable(): NullableModifier<this> {\n\t    return new NullableModifier(this)\n\t  }\n\t}\n\t/**\n", " * Modifies the schema type to allow null values\n\t */\n\tclass NullableModifier<Schema extends BaseModifiersType<any, any>> extends BaseModifiersType<\n\t  Schema[typeof OTYPE] | null,\n\t  Schema[typeof COTYPE] | null\n\t> {\n\t  #parent: Schema\n\t  constructor(parent: Schema) {\n\t    super()\n\t    this.#parent = parent\n", "  }\n\t  /**\n\t   * Creates a fresh instance of the underlying schema type\n\t   * and wraps it inside the nullable modifier\n\t   */\n\t  clone(): this {\n\t    return new NullableModifier(this.#parent.clone()) as this\n\t  }\n\t  /**\n\t   * Compiles to compiler node\n", "   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes {\n\t    const output = this.#parent[PARSE](propertyName, refs, options)\n\t    if (output.type !== 'union') {\n\t      output.allowNull = true\n\t    }\n\t    return output\n\t  }\n\t}\n\t/**\n", " * Modifies the schema type to allow undefined values\n\t */\n\tclass OptionalModifier<Schema extends BaseModifiersType<any, any>> extends BaseModifiersType<\n\t  Schema[typeof OTYPE] | undefined,\n\t  Schema[typeof COTYPE] | undefined\n\t> {\n\t  #parent: Schema\n\t  constructor(parent: Schema) {\n\t    super()\n\t    this.#parent = parent\n", "  }\n\t  /**\n\t   * Creates a fresh instance of the underlying schema type\n\t   * and wraps it inside the optional modifier\n\t   */\n\t  clone(): this {\n\t    return new OptionalModifier(this.#parent.clone()) as this\n\t  }\n\t  /**\n\t   * Compiles to compiler node\n", "   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes {\n\t    const output = this.#parent[PARSE](propertyName, refs, options)\n\t    if (output.type !== 'union') {\n\t      output.isOptional = true\n\t    }\n\t    return output\n\t  }\n\t}\n\t/**\n", " * The BaseSchema class abstracts the repetitive parts of creating\n\t * a custom schema type.\n\t */\n\texport abstract class BaseType<Output, CamelCaseOutput> extends BaseModifiersType<\n\t  Output,\n\t  CamelCaseOutput\n\t> {\n\t  /**\n\t   * Field options\n\t   */\n", "  protected options: FieldOptions\n\t  /**\n\t   * Set of validations to run\n\t   */\n\t  protected validations: Validation<any>[]\n\t  constructor(options?: FieldOptions, validations?: Validation<any>[]) {\n\t    super()\n\t    this.options = options || {\n\t      bail: true,\n\t      allowNull: false,\n", "      isOptional: false,\n\t    }\n\t    this.validations = validations || []\n\t  }\n\t  /**\n\t   * Shallow clones the validations. Since, there are no API's to mutate\n\t   * the validation options, we can safely copy them by reference.\n\t   */\n\t  protected cloneValidations(): Validation<any>[] {\n\t    return this.validations.map((validation) => {\n", "      return {\n\t        options: validation.options,\n\t        rule: validation.rule,\n\t      }\n\t    })\n\t  }\n\t  /**\n\t   * Shallow clones the options\n\t   */\n\t  protected cloneOptions(): FieldOptions {\n", "    return { ...this.options }\n\t  }\n\t  /**\n\t   * Compiles validations\n\t   */\n\t  protected compileValidations(refs: RefsStore) {\n\t    return this.validations.map((validation) => {\n\t      return {\n\t        ruleFnId: refs.track({\n\t          validator: validation.rule.validator,\n", "          options: validation.options,\n\t        }),\n\t        implicit: validation.rule.implicit,\n\t        isAsync: validation.rule.isAsync,\n\t      }\n\t    })\n\t  }\n\t  /**\n\t   * Define a method to parse the input value. The method\n\t   * is invoked before any validation and hence you must\n", "   * perform type-checking to know the value you are\n\t   * working it.\n\t   */\n\t  parse(callback: Parser): this {\n\t    this.options.parse = callback\n\t    return this\n\t  }\n\t  /**\n\t   * Push a validation to the validations chain.\n\t   */\n", "  use(validation: Validation<any> | RuleBuilder): this {\n\t    this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation)\n\t    return this\n\t  }\n\t  /**\n\t   * Enable/disable the bail mode. In bail mode, the field validations\n\t   * are stopped after the first error.\n\t   */\n\t  bail(state: boolean) {\n\t    this.options.bail = state\n", "    return this\n\t  }\n\t}\n"]}
{"filename": "src/schema/tuple/main.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport camelcase from 'camelcase'\n\timport { RefsStore, TupleNode } from '@vinejs/compiler/types'\n", "import { BaseType } from '../base/main.js'\n\timport { IS_OF_TYPE, PARSE, UNIQUE_NAME } from '../../symbols.js'\n\timport type { FieldOptions, ParserOptions, SchemaTypes, Validation } from '../../types.js'\n\t/**\n\t * VineTuple is an array with known length and may have different\n\t * schema type for each array element.\n\t */\n\texport class VineTuple<\n\t  Schema extends SchemaTypes[],\n\t  Output extends any[],\n", "  CamelCaseOutput extends any[],\n\t> extends BaseType<Output, CamelCaseOutput> {\n\t  #schemas: [...Schema]\n\t  /**\n\t   * Whether or not to allow unknown properties\n\t   */\n\t  #allowUnknownProperties: boolean = false;\n\t  /**\n\t   * The property must be implemented for \"unionOfTypes\"\n\t   */\n", "  [UNIQUE_NAME] = 'vine.array';\n\t  /**\n\t   * Checks if the value is of array type. The method must be\n\t   * implemented for \"unionOfTypes\"\n\t   */\n\t  [IS_OF_TYPE] = (value: unknown) => {\n\t    return Array.isArray(value)\n\t  }\n\t  constructor(schemas: [...Schema], options?: FieldOptions, validations?: Validation<any>[]) {\n\t    super(options, validations)\n", "    this.#schemas = schemas\n\t  }\n\t  /**\n\t   * Copy unknown properties to the final output.\n\t   */\n\t  allowUnknownProperties<Value>(): VineTuple<\n\t    Schema,\n\t    [...Output, ...Value[]],\n\t    [...CamelCaseOutput, ...Value[]]\n\t  > {\n", "    this.#allowUnknownProperties = true\n\t    return this as unknown as VineTuple<\n\t      Schema,\n\t      [...Output, ...Value[]],\n\t      [...CamelCaseOutput, ...Value[]]\n\t    >\n\t  }\n\t  /**\n\t   * Clone object\n\t   */\n", "  clone(): this {\n\t    const cloned = new VineTuple<Schema, Output, CamelCaseOutput>(\n\t      this.#schemas.map((schema) => schema.clone()) as Schema,\n\t      this.cloneOptions(),\n\t      this.cloneValidations()\n\t    )\n\t    if (this.#allowUnknownProperties) {\n\t      cloned.allowUnknownProperties()\n\t    }\n\t    return cloned as this\n", "  }\n\t  /**\n\t   * Compiles to array data type\n\t   */\n\t  [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): TupleNode {\n\t    return {\n\t      type: 'tuple',\n\t      fieldName: propertyName,\n\t      propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,\n\t      bail: this.options.bail,\n", "      allowNull: this.options.allowNull,\n\t      isOptional: this.options.isOptional,\n\t      allowUnknownProperties: this.#allowUnknownProperties,\n\t      parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,\n\t      validations: this.compileValidations(refs),\n\t      properties: this.#schemas.map((schema, index) => schema[PARSE](String(index), refs, options)),\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/errors/validation_error.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Validation error is a superset of Error class with validation\n", " * error messages\n\t */\n\texport class ValidationError extends Error {\n\t  /**\n\t   * Http status code for the validation error\n\t   */\n\t  status: number = 422\n\t  /**\n\t   * Internal code for handling the validation error\n\t   * exception\n", "   */\n\t  code: string = 'E_VALIDATION_ERROR'\n\t  constructor(\n\t    public messages: any,\n\t    options?: ErrorOptions\n\t  ) {\n\t    super('Validation failure', options)\n\t    const ErrorConstructor = this.constructor as typeof ValidationError\n\t    Error.captureStackTrace(this, ErrorConstructor)\n\t  }\n", "  get [Symbol.toStringTag]() {\n\t    return this.constructor.name\n\t  }\n\t  toString() {\n\t    return `${this.name} [${this.code}]: ${this.message}`\n\t  }\n\t}\n"]}
{"filename": "src/errors/main.ts", "chunked_list": ["/*\n\t * @vinejs/vine\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { ValidationError } from './validation_error.js'\n\t/**\n", " * Create an instance of validation error\n\t */\n\texport const E_VALIDATION_ERROR = ValidationError\n"]}
