{"filename": "src/main.ts", "chunked_list": ["#!/usr/bin/env node\n\timport { Command } from 'commander';\n\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t// @ts-ignore\n\timport { version } from '../package.json';\n\timport { ConfigCommand } from './commands/config.command';\n\timport { LocalReviewCommand } from './commands/local-review.command';\n\timport { PullRequestReviewCommand } from './commands/pull-request-review.command';\n\timport { LocalReviewArgs } from './interfaces';\n\timport { CommitCommand } from './commands/commit.command';\n", "import { checkForUpdate } from './utils/update-notifier';\n\tconst program = new Command();\n\tprogram\n\t  .version(version || '0.0.0')\n\t  .description(\n\t    'revu-cli - Streamlining code reviews and commit message generation using GPT-4.',\n\t  );\n\tprogram\n\t  .command('config')\n\t  .description('Configure revu-cli')\n", "  .action(async () => {\n\t    const configCommand = new ConfigCommand({ commandName: 'config' });\n\t    await configCommand.run();\n\t  });\n\tprogram\n\t  .command('pr <repository> <pull_request>')\n\t  .description('Review a pull request')\n\t  .action(async (repository: string, pullRequest: string) => {\n\t    const pullRequestReviewCommand = new PullRequestReviewCommand({\n\t      commandName: 'pr-review',\n", "    });\n\t    await pullRequestReviewCommand.run({\n\t      fullRepository: repository,\n\t      pullRequest,\n\t    });\n\t  });\n\tprogram\n\t  .command('local')\n\t  .description('Review local changes or a specific file')\n\t  .option('-f, --filename <filename>', 'filename to review', '')\n", "  .option('-d, --directory <directory>', 'directory of the file to review', '.')\n\t  .action(async (localReviewArgs: LocalReviewArgs) => {\n\t    const localReviewCommand = new LocalReviewCommand({\n\t      commandName: 'local-review',\n\t    });\n\t    await localReviewCommand.run(localReviewArgs);\n\t  });\n\tprogram\n\t  .command('commit')\n\t  .description('Generate commit message and commit selected files')\n", "  .action(async () => {\n\t    const commitCommand = new CommitCommand({\n\t      commandName: 'commit',\n\t    });\n\t    await commitCommand.run();\n\t  });\n\tprogram.parseAsync(process.argv).then(() => {\n\t  checkForUpdate(version);\n\t});\n\tif (!process.argv.slice(2).length) {\n", "  program.outputHelp();\n\t}\n"]}
{"filename": "src/logger.ts", "chunked_list": ["import { createLogger, format, transports } from 'winston';\n\texport const logger = createLogger({\n\t  level: 'info',\n\t  transports: [\n\t    new transports.Console({\n\t      level: 'info',\n\t      format: format.combine(\n\t        format.colorize(),\n\t        format.printf((info) => {\n\t          return `${info.message}`;\n", "        }),\n\t      ),\n\t    }),\n\t  ],\n\t});\n"]}
{"filename": "src/commands/base.command.ts", "chunked_list": ["import ora from 'ora';\n\timport { CommandConfig } from '../interfaces';\n\timport { logger } from '../logger';\n\texport abstract class BaseCommand<T> {\n\t  protected config: CommandConfig;\n\t  protected spinner: ora.Ora;\n\t  protected constructor(config: CommandConfig) {\n\t    this.config = config;\n\t    this.spinner = ora();\n\t  }\n", "  protected abstract _run(args?: T): Promise<void>;\n\t  public async run(args?: T): Promise<void> {\n\t    try {\n\t      await this._run(args);\n\t    } catch (error: any) {\n\t      this.spinner.stop();\n\t      logger.error(error.message);\n\t      process.exit(1);\n\t    }\n\t  }\n", "}\n"]}
{"filename": "src/commands/pull-request-review.command.ts", "chunked_list": ["import { CommandConfig } from '../interfaces';\n\timport { ConfigService } from '../services/config.service';\n\timport { OpenAiService } from '../services/openai.service';\n\timport { GithubService } from '../services/git/github.service';\n\timport { logger } from '../logger';\n\timport { BaseCommand } from './base.command';\n\tinterface PullRequestReviewArgs {\n\t  fullRepository: string;\n\t  pullRequest: string;\n\t}\n", "export class PullRequestReviewCommand extends BaseCommand<PullRequestReviewArgs> {\n\t  constructor(config: CommandConfig) {\n\t    super(config);\n\t  }\n\t  protected async _run({\n\t    fullRepository,\n\t    pullRequest,\n\t  }: PullRequestReviewArgs): Promise<void> {\n\t    const config = ConfigService.load();\n\t    const openAIConfig = config.llm.openai;\n", "    const pullRequestUrl = GithubService.getPullRequestUrl(\n\t      fullRepository,\n\t      pullRequest,\n\t    );\n\t    logger.info(`Reviewing ${pullRequestUrl}`);\n\t    const pullRequestDiff = await GithubService.getPRDiff(\n\t      config.github,\n\t      config.git,\n\t      fullRepository,\n\t      pullRequest,\n", "    );\n\t    this.spinner.text = 'Reviewing...';\n\t    this.spinner.start();\n\t    const review = await OpenAiService.reviewDiff(\n\t      openAIConfig,\n\t      pullRequestDiff,\n\t    );\n\t    this.spinner.stop();\n\t    logger.info(review);\n\t  }\n", "}\n"]}
{"filename": "src/commands/local-review.command.ts", "chunked_list": ["import {\n\t  CommandConfig,\n\t  GitConfig,\n\t  LocalReviewArgs,\n\t  OpenAIConfig,\n\t} from '../interfaces';\n\timport { ConfigService } from '../services/config.service';\n\timport { OpenAiService } from '../services/openai.service';\n\timport { GitLocalService } from '../services/git/git-local.service';\n\timport { FileService } from '../services/file.service';\n", "import { logger } from '../logger';\n\timport { BaseCommand } from './base.command';\n\texport class LocalReviewCommand extends BaseCommand<LocalReviewArgs> {\n\t  constructor(config: CommandConfig) {\n\t    super(config);\n\t  }\n\t  private async reviewDiff(\n\t    openAIConfig: OpenAIConfig,\n\t    gitConfig: GitConfig,\n\t  ): Promise<string> {\n", "    const localDiff = await GitLocalService.getLocalDiff({\n\t      ignorePatterns: gitConfig.ignorePatterns,\n\t    });\n\t    logger.info('Reviewing local changes');\n\t    this.spinner.start();\n\t    return OpenAiService.reviewDiff(openAIConfig, localDiff);\n\t  }\n\t  private async reviewFile(\n\t    openAIConfig: OpenAIConfig,\n\t    directory: string,\n", "    filename: string,\n\t  ): Promise<string> {\n\t    const getFileResponse = await FileService.getFileContentAndName(\n\t      directory,\n\t      filename,\n\t    );\n\t    const contentWithLineNumbers = FileService.addLineNumbers(\n\t      getFileResponse.content,\n\t    );\n\t    logger.info(`Reviewing ${getFileResponse.filename}`);\n", "    this.spinner.start();\n\t    return OpenAiService.reviewFile(\n\t      openAIConfig,\n\t      contentWithLineNumbers,\n\t      getFileResponse.filename,\n\t    );\n\t  }\n\t  protected async _run({\n\t    directory,\n\t    filename,\n", "  }: LocalReviewArgs): Promise<void> {\n\t    const config = ConfigService.load();\n\t    const openAIConfig = config.llm.openai;\n\t    const gitConfig = config.git;\n\t    this.spinner.text = 'Reviewing...';\n\t    const review = filename\n\t      ? await this.reviewFile(openAIConfig, directory, filename)\n\t      : await this.reviewDiff(openAIConfig, gitConfig);\n\t    this.spinner.stop();\n\t    logger.info(review);\n", "  }\n\t}\n"]}
{"filename": "src/commands/config.command.ts", "chunked_list": ["import prompts from 'prompts';\n\timport { CommandConfig } from '../interfaces';\n\timport { ConfigService } from '../services/config.service';\n\timport { BaseCommand } from './base.command';\n\tclass ConfigCommandError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = 'ConfigCommandError';\n\t  }\n\t}\n", "export class ConfigCommand extends BaseCommand<void> {\n\t  constructor(config: CommandConfig) {\n\t    super(config);\n\t  }\n\t  protected async _run(): Promise<void> {\n\t    const response = await prompts(\n\t      [\n\t        {\n\t          type: 'password',\n\t          name: 'githubToken',\n", "          message: 'Please enter your GitHub token:',\n\t          validate: (input: string) => {\n\t            if (input.length === 0) {\n\t              return 'GitHub token cannot be empty!';\n\t            }\n\t            return true;\n\t          },\n\t        },\n\t        {\n\t          type: 'password',\n", "          name: 'openApiKey',\n\t          message: 'Please enter your OpenAI API key:',\n\t          validate: (input: string) => {\n\t            if (input.length === 0) {\n\t              return 'OpenAI API key cannot be empty!';\n\t            }\n\t            return true;\n\t          },\n\t        },\n\t      ],\n", "      {\n\t        onCancel: () => {\n\t          throw new ConfigCommandError('Setup was cancelled by the user');\n\t        },\n\t      },\n\t    );\n\t    await ConfigService.save({\n\t      githubToken: response.githubToken,\n\t      openaiApiKey: response.openApiKey,\n\t    });\n", "  }\n\t}\n"]}
{"filename": "src/commands/commit.command.ts", "chunked_list": ["import prompts from 'prompts';\n\timport {\n\t  CommandConfig,\n\t  CommitAction,\n\t  FileSelectionStatus,\n\t  GitConfig,\n\t  GitDiff,\n\t  LocalReviewArgs,\n\t} from '../interfaces';\n\timport { ConfigService } from '../services/config.service';\n", "import { GitLocalService } from '../services/git/git-local.service';\n\timport { FileService } from '../services/file.service';\n\timport { logger } from '../logger';\n\timport { OpenAiService } from '../services/openai.service';\n\timport { BaseCommand } from './base.command';\n\tclass CommitCommandError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = 'CommitCommandError';\n\t  }\n", "}\n\texport class CommitCommand extends BaseCommand<LocalReviewArgs> {\n\t  constructor(config: CommandConfig) {\n\t    super(config);\n\t  }\n\t  private async filesDiff(\n\t    filenames: string[],\n\t    gitConfig: GitConfig,\n\t  ): Promise<GitDiff> {\n\t    logger.info('Reviewing local changes for commit');\n", "    return GitLocalService.getFilesDiff(filenames, {\n\t      ignorePatterns: gitConfig.ignorePatterns,\n\t    });\n\t  }\n\t  private async selectChangedFiles(): Promise<FileSelectionStatus> {\n\t    const fileChanges = await GitLocalService.getFilesChanged();\n\t    const selectedFiles = await FileService.selectFiles(fileChanges);\n\t    const selectedFileNames = new Set(\n\t      selectedFiles.map((file) => file.filename),\n\t    );\n", "    const allFileNames = fileChanges.map((fileChange) => fileChange.filename);\n\t    const unselectedFileNames = allFileNames.filter(\n\t      (filename) => !selectedFileNames.has(filename),\n\t    );\n\t    return {\n\t      selectedFileNames: Array.from(selectedFileNames),\n\t      unselectedFileNames: unselectedFileNames,\n\t    };\n\t  }\n\t  private async promptShouldContinueCommit(): Promise<boolean> {\n", "    const response = await prompts({\n\t      type: 'confirm',\n\t      name: 'value',\n\t      message: 'Do you want to continue commit?',\n\t      initial: false,\n\t    });\n\t    return response.value;\n\t  }\n\t  private async getCommitAction(): Promise<CommitAction> {\n\t    const response = await prompts({\n", "      type: 'select',\n\t      name: 'value',\n\t      message: 'Do you want to commit the message, replace it, or do nothing?',\n\t      choices: [\n\t        { title: 'Commit', value: CommitAction.COMMIT },\n\t        { title: 'Replace', value: CommitAction.REPLACE },\n\t        { title: 'Do Nothing', value: CommitAction.SKIP },\n\t      ],\n\t      initial: 0,\n\t    });\n", "    if (!response.value) {\n\t      throw new CommitCommandError('Commit action is required');\n\t    }\n\t    return response.value;\n\t  }\n\t  private async promptReplaceCommitMessage(\n\t    initialMessage: string,\n\t  ): Promise<string> {\n\t    const response = await prompts({\n\t      type: 'text',\n", "      name: 'value',\n\t      message: 'Enter the new commit message:',\n\t      initial: initialMessage,\n\t    });\n\t    if (!response.value) {\n\t      throw new CommitCommandError('Commit message is required');\n\t    }\n\t    return response.value;\n\t  }\n\t  protected async _run(): Promise<void> {\n", "    let shouldContinueCommit = true;\n\t    const config = ConfigService.load();\n\t    const gitConfig = config.git;\n\t    const openAIConfig = config.llm.openai;\n\t    while (shouldContinueCommit) {\n\t      const { selectedFileNames, unselectedFileNames } =\n\t        await this.selectChangedFiles();\n\t      const diff = await this.filesDiff(selectedFileNames, gitConfig);\n\t      logger.info('Generating commit message');\n\t      const commitHistory = await GitLocalService.getCommitHistory(\n", "        gitConfig.maxCommitHistory,\n\t      );\n\t      this.spinner.text = 'Generating commit message...';\n\t      this.spinner.start();\n\t      const commitMessage = await OpenAiService.generateCommitMessage(\n\t        openAIConfig,\n\t        diff,\n\t        commitHistory,\n\t      );\n\t      this.spinner.stop();\n", "      logger.info(commitMessage);\n\t      const commitAction = await this.getCommitAction();\n\t      shouldContinueCommit = commitAction !== CommitAction.SKIP;\n\t      if (commitAction !== CommitAction.SKIP) {\n\t        const messageToCommit =\n\t          commitAction === CommitAction.COMMIT\n\t            ? commitMessage\n\t            : await this.promptReplaceCommitMessage(commitMessage);\n\t        await GitLocalService.commit(messageToCommit, selectedFileNames);\n\t        shouldContinueCommit =\n", "          unselectedFileNames.length === 0\n\t            ? false\n\t            : await this.promptShouldContinueCommit();\n\t      }\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/utils/update-notifier.ts", "chunked_list": ["import { execSync } from 'child_process';\n\timport chalk from 'chalk';\n\timport { logger } from '../logger';\n\texport const checkForUpdate = (version: string) => {\n\t  try {\n\t    const latestVersion = execSync('npm show revu-cli version')\n\t      .toString()\n\t      .trim();\n\t    if (latestVersion !== version) {\n\t      logger.info(\n", "        chalk.yellow(\n\t          `\\nNew version (${latestVersion}) of revu-cli is available. Consider updating.`,\n\t        ),\n\t      );\n\t    }\n\t  } catch (error) {\n\t    logger.error(chalk.red(`\\nFailed to check for updates.`));\n\t  }\n\t};\n"]}
{"filename": "src/interfaces/common.interface.ts", "chunked_list": ["import { GitConfig } from './git.interface';\n\timport { GithubConfig } from './github.interface';\n\timport { LLMConfig } from './llm.interface';\n\texport interface Config {\n\t  git: GitConfig;\n\t  github: GithubConfig;\n\t  llm: LLMConfig;\n\t}\n\texport interface CommandConfig {\n\t  commandName: string;\n", "}\n\texport enum CommitAction {\n\t  COMMIT = 'commit',\n\t  REPLACE = 'replace',\n\t  SKIP = 'skip',\n\t}\n\texport interface GitDiff {\n\t  diff: string;\n\t}\n\texport interface LocalReviewArgs {\n", "  directory: string;\n\t  filename: string;\n\t}\n\texport interface Prompt {\n\t  system: string;\n\t  user: string;\n\t}\n\texport interface FileSelectionStatus {\n\t  selectedFileNames: string[];\n\t  unselectedFileNames: string[];\n", "}\n\texport interface GitFileChange {\n\t  filename: string;\n\t  status: 'deleted' | 'changed' | 'added';\n\t}\n\texport interface GetFileResponse {\n\t  content: string;\n\t  filename: string;\n\t}\n"]}
{"filename": "src/interfaces/openai.interface.ts", "chunked_list": ["export interface OpenAIConfig {\n\t  openaiApiUrl: string;\n\t  openaiModel: string;\n\t  openaiTemperature: number;\n\t  secretOpenaiApiKey: string;\n\t}\n"]}
{"filename": "src/interfaces/git.interface.ts", "chunked_list": ["export interface GitConfig {\n\t  ignorePatterns: string[];\n\t  maxCommitHistory: number;\n\t}\n"]}
{"filename": "src/interfaces/llm.interface.ts", "chunked_list": ["import { OpenAIConfig } from './openai.interface';\n\texport interface LLMConfig {\n\t  openai: OpenAIConfig;\n\t}\n"]}
{"filename": "src/interfaces/github.interface.ts", "chunked_list": ["export interface GithubConfig {\n\t  githubApiUrl: string;\n\t  secretGithubToken: string;\n\t}\n\texport interface GitHubRepository {\n\t  owner: string;\n\t  repo: string;\n\t}\n"]}
{"filename": "src/interfaces/index.ts", "chunked_list": ["export * from './github.interface';\n\texport * from './openai.interface';\n\texport * from './git.interface';\n\texport * from './llm.interface';\n\texport * from './common.interface';\n"]}
{"filename": "src/services/prompt.service.ts", "chunked_list": ["import { GitDiff, Prompt } from '../interfaces';\n\texport class PromptService {\n\t  public static generateReviewDiffPrompt(details: GitDiff): Prompt {\n\t    const context =\n\t      'Your objective is to meticulously review a diff from a git repository and ' +\n\t      'meticulously identify any requisite alterations to guarantee that the code ' +\n\t      'is efficient, durable, and secure. Your assessment must be precise and detailed, ' +\n\t      'only proposing changes that will enhance or repair the code. It is imperative to ' +\n\t      'accurately pinpoint the exact location in the code that necessitates modification ' +\n\t      'and explicitly specify the necessary changes. Refrain from suggesting comments and ' +\n", "      'provide an overall status at the conclusion of your evaluation. If no changes are necessary, ' +\n\t      'state \"✔ LGTM.\" at the end of your feedback. If modifications are required, state ' +\n\t      '\"✘ Change(s) required.\" at the end of your feedback. If you have suggestions, state ' +\n\t      '\"~ LGTM with suggestions.\" at the end of your feedback. When recommending modifications or ' +\n\t      'improvements, please adhere to the following format:';\n\t    const responseFormat = `📌 {{filename}}\\n💡 {{suggestion}}`;\n\t    const systemContent = `${context}\\n\\n${responseFormat}`;\n\t    return {\n\t      system: systemContent,\n\t      user: `Please review the following code changes:\\n\\`\\`\\`\\n${details.diff}\\n\\`\\`\\``,\n", "    };\n\t  }\n\t  public static generateReviewFilePrompt(\n\t    fileContent: string,\n\t    filename: string,\n\t  ): Prompt {\n\t    const context =\n\t      'As an expert code reviewer, your main duty is to ensure that the code conforms to ' +\n\t      'the highest standards of efficiency, maintainability, and security. To accomplish this, ' +\n\t      'you must provide clear and precise feedback that identifies the exact line number where ' +\n", "      'changes are necessary and specifies what needs to be altered. It is crucial to avoid suggesting ' +\n\t      'modifications that do not improve or fix the code and to refrain from making comments that do not ' +\n\t      \"contribute to the code's improvement or error correction. At the conclusion of your review, you \" +\n\t      'must explicitly state the overall status of the code, using one of the following three options: ' +\n\t      '\"✔ LGTM\" for code that is ready for use, \"✘ Change(s) required\" for code that requires improvements, ' +\n\t      'or \"~ LGTM with suggestions\" for code that is mostly acceptable but could benefit from some minor adjustments.';\n\t    const responseFormat = `Your feedback should be formatted in the following way:\\n\\n💡 Line {{line number}}: {{suggestion}}`;\n\t    const systemContent = `${context}\\n\\n${responseFormat}`;\n\t    const fileExtension = filename.slice(filename.lastIndexOf('.') + 1);\n\t    return {\n", "      system: systemContent,\n\t      user: `Please review the following file:\\n\\`\\`\\`${fileExtension}\\n${fileContent}\\n\\`\\`\\``,\n\t    };\n\t  }\n\t  public static generateCommitMessagePrompt(\n\t    details: GitDiff,\n\t    commitHistory: string[],\n\t  ): Prompt {\n\t    const context =\n\t      'As an experienced code reviewer, your task is to identify the most appropriate commit ' +\n", "      'description by analyzing the diff and commit history. Your objective is ' +\n\t      'to produce a concise and precise commit description with a maximum length of 40 characters. ' +\n\t      'Please note that your response should only include the commit description. The commit history ' +\n\t      'provided is as follows:';\n\t    const commitHistoryContent = `\\`\\`\\`\\n${commitHistory.join('\\n')}\\n\\`\\`\\``;\n\t    const systemContent = `${context}\\n${commitHistoryContent}`;\n\t    return {\n\t      system: systemContent,\n\t      user: `Please generate the perfect commit description for the following code changes:\\n\\`\\`\\`\\n${details.diff}\\n\\`\\`\\``,\n\t    };\n", "  }\n\t}\n"]}
{"filename": "src/services/config.service.ts", "chunked_list": ["import fs from 'fs';\n\timport path from 'path';\n\timport os from 'os';\n\timport merge from 'lodash.merge';\n\timport { Config } from '../interfaces';\n\tconst CONFIG_FILENAME = 'revu.json';\n\tconst DEFAULT_CONFIG: Config = {\n\t  git: {\n\t    ignorePatterns: [],\n\t    maxCommitHistory: 10,\n", "  },\n\t  github: {\n\t    githubApiUrl: 'https://api.github.com',\n\t    secretGithubToken: '',\n\t  },\n\t  llm: {\n\t    openai: {\n\t      openaiApiUrl: 'https://api.openai.com',\n\t      openaiModel: 'gpt-3.5-turbo',\n\t      openaiTemperature: 0,\n", "      secretOpenaiApiKey: '',\n\t    },\n\t  },\n\t};\n\tclass ConfigurationError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = 'ConfigurationError';\n\t  }\n\t}\n", "export class ConfigService {\n\t  private static getConfigPath(): string {\n\t    const configDir =\n\t      process.env.NODE_ENV === 'development'\n\t        ? process.cwd()\n\t        : path.join(os.homedir(), '.revu');\n\t    return path.join(configDir, CONFIG_FILENAME);\n\t  }\n\t  private static fromEnvOrDefault(): Config {\n\t    const envConfig = {\n", "      git: {\n\t        ignorePatterns: process.env.GIT_IGNORE_PATTERNS?.split(','),\n\t        maxCommitHistory: process.env.GIT_MAX_COMMIT_HISTORY\n\t          ? Number(process.env.GIT_MAX_COMMIT_HISTORY)\n\t          : undefined,\n\t      },\n\t      github: {\n\t        githubApiUrl: process.env.GITHUB_API_URL,\n\t        secretGithubToken: process.env.GITHUB_TOKEN,\n\t      },\n", "      llm: {\n\t        openai: {\n\t          openaiApiUrl: process.env.OPENAI_API_URL,\n\t          openaiModel: process.env.OPENAI_MODEL,\n\t          openaiTemperature: process.env.OPENAI_TEMPERATURE\n\t            ? Number(process.env.OPENAI_TEMPERATURE)\n\t            : undefined,\n\t          secretOpenaiApiKey: process.env.OPENAI_API_KEY,\n\t        },\n\t      },\n", "    } as Config;\n\t    const cleanedEnvConfig = JSON.parse(JSON.stringify(envConfig));\n\t    return merge({}, DEFAULT_CONFIG, cleanedEnvConfig);\n\t  }\n\t  static fromFileOrDefault(): Config {\n\t    let fileConfig = {} as Config;\n\t    if (this.configFileExists()) {\n\t      try {\n\t        fileConfig = JSON.parse(fs.readFileSync(this.getConfigPath(), 'utf-8'));\n\t      } catch (err) {\n", "        throw new ConfigurationError(\n\t          'Unable to parse the configuration file. Please ensure it is valid JSON.',\n\t        );\n\t      }\n\t    }\n\t    return merge({}, DEFAULT_CONFIG, fileConfig);\n\t  }\n\t  private static validateTemperature(temperature: number): void {\n\t    if (!(temperature >= 0.0 && temperature <= 2.0)) {\n\t      throw new ConfigurationError(\n", "        'Invalid temperature value. It must be a value between 0 and 2 (inclusive).',\n\t      );\n\t    }\n\t  }\n\t  private static configFileExists(): boolean {\n\t    const configPath = this.getConfigPath();\n\t    return fs.existsSync(configPath);\n\t  }\n\t  static save({\n\t    githubToken,\n", "    openaiApiKey,\n\t  }: {\n\t    githubToken: string;\n\t    openaiApiKey: string;\n\t  }): void {\n\t    const configPath = this.getConfigPath();\n\t    const dir = path.dirname(configPath);\n\t    if (!fs.existsSync(dir)) {\n\t      fs.mkdirSync(dir, { recursive: true });\n\t    }\n", "    const config = this.fromFileOrDefault();\n\t    config.github.secretGithubToken = githubToken;\n\t    config.llm.openai.secretOpenaiApiKey = openaiApiKey;\n\t    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));\n\t  }\n\t  static load(): Config {\n\t    const config = this.configFileExists()\n\t      ? this.fromFileOrDefault()\n\t      : this.fromEnvOrDefault();\n\t    this.validateTemperature(config.llm.openai.openaiTemperature);\n", "    return config;\n\t  }\n\t}\n"]}
{"filename": "src/services/file.service.ts", "chunked_list": ["import fs from 'fs';\n\timport fg from 'fast-glob';\n\timport prompts from 'prompts';\n\timport escapeStringRegexp from 'escape-string-regexp';\n\timport chalk from 'chalk';\n\timport { GetFileResponse, GitFileChange } from '../interfaces';\n\tclass FileServiceError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = 'FileServiceError';\n", "  }\n\t}\n\texport class FileService {\n\t  public static async getFileContentAndName(\n\t    directory: string,\n\t    filename: string,\n\t  ): Promise<GetFileResponse> {\n\t    const escapedFilename = escapeStringRegexp(filename);\n\t    const pattern = `${directory}/**/*${escapedFilename}*`;\n\t    const matches = await fg(pattern, { onlyFiles: true });\n", "    if (matches.length === 0) {\n\t      throw new FileServiceError(\n\t        `File ${filename} not found in directory ${directory}`,\n\t      );\n\t    }\n\t    let file: string;\n\t    if (matches.length === 1) {\n\t      file = matches[0];\n\t    } else {\n\t      const response = await prompts({\n", "        type: 'autocomplete',\n\t        name: 'file',\n\t        message: 'Multiple files match. Please select a file to review:',\n\t        choices: matches\n\t          .sort()\n\t          .map((match) => ({ title: match, value: match })),\n\t        initial: 0,\n\t        suggest: (input, choices) => {\n\t          const inputValue = input.toLowerCase();\n\t          const filteredChoices = choices.filter((choice) =>\n", "            choice.title.toLowerCase().includes(inputValue),\n\t          );\n\t          return Promise.resolve(filteredChoices);\n\t        },\n\t      });\n\t      if (!response.file) {\n\t        throw new FileServiceError('No file was selected from the prompt');\n\t      }\n\t      file = response.file;\n\t    }\n", "    const content = fs.readFileSync(file, 'utf8');\n\t    return { filename: file, content };\n\t  }\n\t  public static async selectFiles(\n\t    fileChanges: GitFileChange[],\n\t  ): Promise<GitFileChange[]> {\n\t    const response = await prompts({\n\t      type: 'multiselect',\n\t      name: 'files',\n\t      message: 'Select files to commit:',\n", "      choices: fileChanges\n\t        .sort((a, b) => a.filename.localeCompare(b.filename))\n\t        .map((fileChange) => ({\n\t          title: this.colorize(fileChange),\n\t          value: fileChange,\n\t        })),\n\t      initial: 0,\n\t      min: 1,\n\t      max: fileChanges.length,\n\t    });\n", "    if (!response.files) {\n\t      throw new FileServiceError('No files were selected from the prompt');\n\t    }\n\t    return response.files;\n\t  }\n\t  public static addLineNumbers(content: string): string {\n\t    return content\n\t      .split('\\n')\n\t      .map((line, index) => `${index + 1} | ${line}`)\n\t      .join('\\n');\n", "  }\n\t  private static colorize(fileChange: GitFileChange): string {\n\t    switch (fileChange.status) {\n\t      case 'added':\n\t        return chalk.green(fileChange.filename);\n\t      case 'deleted':\n\t        return chalk.red(fileChange.filename);\n\t      case 'changed':\n\t        return chalk.cyan(fileChange.filename);\n\t    }\n", "  }\n\t}\n"]}
{"filename": "src/services/openai.service.ts", "chunked_list": ["import {\n\t  ChatCompletionRequestMessage,\n\t  Configuration,\n\t  CreateChatCompletionRequest,\n\t  OpenAIApi,\n\t} from 'openai';\n\timport { GitDiff, OpenAIConfig } from '../interfaces';\n\timport { PromptService } from './prompt.service';\n\texport class OpenAiServiceError extends Error {\n\t  constructor(message: string) {\n", "    super(message);\n\t    this.name = 'OpenAiServiceError';\n\t  }\n\t}\n\texport class OpenAiService {\n\t  public static async callOpenAI(\n\t    config: OpenAIConfig,\n\t    messages: ChatCompletionRequestMessage[],\n\t  ): Promise<string> {\n\t    const openAIConfiguration = new Configuration({\n", "      apiKey: config.secretOpenaiApiKey,\n\t    });\n\t    const openaiClient = new OpenAIApi(openAIConfiguration);\n\t    const chatCompletionCreate: CreateChatCompletionRequest = {\n\t      model: config.openaiModel,\n\t      temperature: config.openaiTemperature,\n\t      messages: messages,\n\t    };\n\t    let result;\n\t    try {\n", "      result = await openaiClient.createChatCompletion(chatCompletionCreate);\n\t    } catch (error: any) {\n\t      throw new OpenAiServiceError(\n\t        `Failed to call OpenAI API: ${error.message}`,\n\t      );\n\t    }\n\t    const assistantMessage = result.data?.choices?.[0]?.message?.content;\n\t    if (!assistantMessage) {\n\t      throw new OpenAiServiceError('OpenAI did not return a response');\n\t    }\n", "    return assistantMessage;\n\t  }\n\t  public static async reviewDiff(\n\t    config: OpenAIConfig,\n\t    details: GitDiff,\n\t  ): Promise<string> {\n\t    const prompt = PromptService.generateReviewDiffPrompt(details);\n\t    const messages: ChatCompletionRequestMessage[] = [\n\t      {\n\t        role: 'system',\n", "        content: prompt.system,\n\t      },\n\t      {\n\t        role: 'user',\n\t        content: prompt.user,\n\t      },\n\t    ];\n\t    return await this.callOpenAI(config, messages);\n\t  }\n\t  public static async reviewFile(\n", "    config: OpenAIConfig,\n\t    fileContent: string,\n\t    filename: string,\n\t  ): Promise<string> {\n\t    const prompt = PromptService.generateReviewFilePrompt(\n\t      fileContent,\n\t      filename,\n\t    );\n\t    const messages: ChatCompletionRequestMessage[] = [\n\t      {\n", "        role: 'user',\n\t        content: prompt.system,\n\t      },\n\t      {\n\t        role: 'user',\n\t        content: prompt.user,\n\t      },\n\t    ];\n\t    return await this.callOpenAI(config, messages);\n\t  }\n", "  public static async generateCommitMessage(\n\t    config: OpenAIConfig,\n\t    details: GitDiff,\n\t    commitHistory: string[],\n\t  ): Promise<string> {\n\t    const prompt = PromptService.generateCommitMessagePrompt(\n\t      details,\n\t      commitHistory,\n\t    );\n\t    const messages: ChatCompletionRequestMessage[] = [\n", "      {\n\t        role: 'system',\n\t        content: prompt.system,\n\t      },\n\t      {\n\t        role: 'user',\n\t        content: prompt.user,\n\t      },\n\t    ];\n\t    return await this.callOpenAI(config, messages);\n", "  }\n\t}\n"]}
{"filename": "src/services/git/github.service.ts", "chunked_list": ["import fetch from 'node-fetch';\n\timport parse, { File as ParsedFile } from 'parse-diff';\n\timport {\n\t  GithubConfig,\n\t  GitHubRepository,\n\t  GitDiff,\n\t  GitConfig,\n\t} from '../../interfaces';\n\tclass GithubServiceError extends Error {\n\t  constructor(message: string) {\n", "    super(message);\n\t    this.name = 'GithubServiceError';\n\t  }\n\t}\n\texport class GithubService {\n\t  private static getOwnerAndRepo(fullRepositoryPath: string): GitHubRepository {\n\t    const ownerRepoRegex = /^[a-zA-Z0-9-_]+\\/[a-zA-Z0-9-_]+$/;\n\t    if (!ownerRepoRegex.test(fullRepositoryPath)) {\n\t      throw new GithubServiceError(\n\t        'Invalid repository format. Please use the format: owner/repo',\n", "      );\n\t    }\n\t    const [owner, repo] = fullRepositoryPath.split('/');\n\t    return { owner, repo };\n\t  }\n\t  static async getPRDiff(\n\t    githubConfig: GithubConfig,\n\t    gitConfig: GitConfig,\n\t    fullRepositoryPath: string,\n\t    prNumber: string,\n", "  ): Promise<GitDiff> {\n\t    const { owner, repo } = this.getOwnerAndRepo(fullRepositoryPath);\n\t    const apiPrUrl = `${githubConfig.githubApiUrl}/repos/${owner}/${repo}/pulls/${prNumber}`;\n\t    const diffResponse = await fetch(apiPrUrl, {\n\t      headers: {\n\t        Authorization: `Bearer ${githubConfig.secretGithubToken}`,\n\t        'User-Agent': 'Revu-CLI',\n\t        Accept: 'application/vnd.github.diff',\n\t      },\n\t    });\n", "    if (!diffResponse.ok) {\n\t      throw new GithubServiceError(\n\t        `Failed to fetch PR diff: ${diffResponse.statusText}`,\n\t      );\n\t    }\n\t    const diff = await diffResponse.text();\n\t    const parsedDiff: ParsedFile[] = parse(diff);\n\t    const filteredDiff: ParsedFile[] = this.filterParsedDiff(\n\t      parsedDiff,\n\t      gitConfig.ignorePatterns,\n", "    );\n\t    if (filteredDiff.length === 0) {\n\t      throw new GithubServiceError('No files to diff');\n\t    }\n\t    const filteredDiffText = this.convertParsedDiffToText(filteredDiff);\n\t    return { diff: filteredDiffText };\n\t  }\n\t  private static filterParsedDiff(\n\t    parsedDiff: ParsedFile[],\n\t    ignorePatterns: string[],\n", "  ): ParsedFile[] {\n\t    const ignorePatternsRegex =\n\t      ignorePatterns?.map((pattern) => new RegExp(pattern)) || [];\n\t    return parsedDiff.filter((fileDiff: ParsedFile) => {\n\t      return !ignorePatternsRegex.some(\n\t        (pattern) =>\n\t          (fileDiff.to && pattern.test(fileDiff.to)) ||\n\t          (fileDiff.from && pattern.test(fileDiff.from)),\n\t      );\n\t    });\n", "  }\n\t  private static convertParsedDiffToText(parsedDiff: ParsedFile[]): string {\n\t    return parsedDiff\n\t      .map((file) => {\n\t        const chunks = file.chunks\n\t          .map((chunk) => {\n\t            const changes = chunk.changes\n\t              .map((change) => {\n\t                return `${change.type === 'normal' ? ' ' : change.type[0]}${\n\t                  change.content\n", "                }`;\n\t              })\n\t              .join('\\n');\n\t            return `@@ -${chunk.oldStart},${chunk.oldLines} +${chunk.newStart},${chunk.newLines} @@\\n${changes}`;\n\t          })\n\t          .join('\\n\\n');\n\t        return `--- ${file.from}\\n+++ ${file.to}\\n${chunks}`;\n\t      })\n\t      .join('\\n\\n');\n\t  }\n", "  static getPullRequestUrl(\n\t    fullRepositoryPath: string,\n\t    pullRequest: string,\n\t  ): string {\n\t    return `https://github.com/${fullRepositoryPath}/pull/${pullRequest}`;\n\t  }\n\t}\n"]}
{"filename": "src/services/git/git-local.service.ts", "chunked_list": ["import { gitP } from 'simple-git';\n\timport { GitFileChange, GitDiff } from '../../interfaces';\n\tclass GitLocalServiceError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = 'GitLocalServiceError';\n\t  }\n\t}\n\texport class GitLocalService {\n\t  private static readonly git = gitP();\n", "  public static async getLocalDiff(options?: {\n\t    ignorePatterns?: string[];\n\t  }): Promise<GitDiff> {\n\t    const fileChanges = await this.getFilesChanged();\n\t    const filenames = fileChanges.map((fileChange) => fileChange.filename);\n\t    return this.getFilesDiff(filenames, {\n\t      ignorePatterns: options?.ignorePatterns,\n\t    });\n\t  }\n\t  public static async getFilesChanged(): Promise<GitFileChange[]> {\n", "    await this.checkIsRepo();\n\t    const status = await this.git.status();\n\t    const added: GitFileChange[] = [...status.created, ...status.not_added].map(\n\t      (filename) => ({ filename, status: 'added' }),\n\t    );\n\t    const deleted: GitFileChange[] = status.deleted.map((filename) => ({\n\t      filename,\n\t      status: 'deleted',\n\t    }));\n\t    const changed: GitFileChange[] = [\n", "      ...status.modified,\n\t      ...status.renamed.map((renamed) => renamed.to),\n\t      ...status.conflicted,\n\t    ].map((filename) => ({ filename, status: 'changed' }));\n\t    return [...added, ...deleted, ...changed].sort((a, b) => {\n\t      return a.filename.localeCompare(b.filename);\n\t    });\n\t  }\n\t  public static async getFilesDiff(\n\t    filenames: string[],\n", "    options?: { ignorePatterns?: string[] },\n\t  ): Promise<GitDiff> {\n\t    await this.checkIsRepo();\n\t    const ignorePatterns =\n\t      options?.ignorePatterns?.map((pattern) => new RegExp(pattern)) || [];\n\t    const filteredFilenames = filenames.filter((filename) => {\n\t      return !ignorePatterns.some((pattern) => pattern.test(filename));\n\t    });\n\t    if (filteredFilenames.length === 0) {\n\t      throw new GitLocalServiceError('No files to diff');\n", "    }\n\t    const diff = await this.git.diff(['HEAD', '--'].concat(filteredFilenames));\n\t    return { diff };\n\t  }\n\t  public static async getCommitHistory(\n\t    maxCommitHistory: number,\n\t  ): Promise<string[]> {\n\t    await this.checkIsRepo();\n\t    const history = await this.git.log([\n\t      '-n',\n", "      String(maxCommitHistory),\n\t      '--pretty=format:%s',\n\t    ]);\n\t    return history.all\n\t      .map((commit) => {\n\t        return commit.hash;\n\t      })\n\t      .map((commits) => {\n\t        return commits.split('\\n');\n\t      })\n", "      .flat();\n\t  }\n\t  public static async commit(\n\t    message: string,\n\t    filenames: string[],\n\t  ): Promise<void> {\n\t    await this.checkIsRepo();\n\t    await this.git.add(filenames);\n\t    await this.git.commit(message);\n\t  }\n", "  private static async checkIsRepo(): Promise<void> {\n\t    if (!(await this.git.checkIsRepo())) {\n\t      throw new GitLocalServiceError(\n\t        'Current directory is not inside a Git repository.',\n\t      );\n\t    }\n\t  }\n\t}\n"]}
