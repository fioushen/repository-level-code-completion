{"filename": "vite.config.ts", "chunked_list": ["import { resolve, dirname } from \"path\";\n\timport { defineConfig } from \"vite\";\n\timport { fileURLToPath } from \"url\";\n\tconst __filename = fileURLToPath(import.meta.url);\n\tconst __dirname = dirname(__filename);\n\texport default defineConfig({\n\t  define: {\n\t    \"process.env\": { NODE_ENV: \"production\" },\n\t  },\n\t  build: {\n", "    lib: {\n\t      entry: resolve(__dirname, \"src/ui/index.tsx\"),\n\t      name: \"Index\",\n\t      fileName: \"index\",\n\t    },\n\t  },\n\t  server: {\n\t    proxy: {\n\t      \"/api\": {\n\t        rewrite: (path) => path.replace(/^\\/api/, \"\"),\n", "        target: \"http://localhost:3000\",\n\t        changeOrigin: true,\n\t      },\n\t    },\n\t  },\n\t});\n"]}
{"filename": "dev/vite-env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n"]}
{"filename": "src/api/app-conf.ts", "chunked_list": ["export const AppConf = {\n\t  meetupApiBaseUrl: process.env.MEETUP_API_BASE_URL,\n\t  githubApiBaseUrl: process.env.GH_API_BASE_URL,\n\t  githubAuthKey: process.env.GH_AUTH_KEY,\n\t  logsVerbose: (process.env.LOGS_VERBOSE || \"\").toUpperCase() === \"TRUE\",\n\t  settingsBaseUrl: process.env.SETTINGS_BASE_URL,\n\t  apiKey: process.env.API_KEY,\n\t  emailAppUrl: process.env.EMAIL_APP_URL as string,\n\t};\n"]}
{"filename": "src/api/routes.ts", "chunked_list": ["import { APIGatewayProxyEventV2 } from \"aws-lambda\";\n\timport { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\n\timport { chaptersController } from \"./controllers/chapters.controller\";\n\timport { chapterIconController } from \"./controllers/chapter-icon.controller\";\n\timport { healthController } from \"./controllers/health.controller\";\n\timport { notifyController } from \"./controllers/notify.controller\";\n\ttype Route = {\n\t  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n\t  path: string;\n\t  controller: Controller;\n", "};\n\texport type Controller = (\n\t  event: APIGatewayProxyEventV2\n\t) =>\n\t  | APIGatewayProxyStructuredResultV2\n\t  | Promise<APIGatewayProxyStructuredResultV2>;\n\texport const routes: Array<Route> = [\n\t  {\n\t    method: \"GET\",\n\t    path: \"/info/events\",\n", "    controller: chaptersController,\n\t  },\n\t  {\n\t    method: \"GET\",\n\t    path: \"/info/chapter-icons/[A-Za-z-]+\",\n\t    controller: chapterIconController,\n\t  },\n\t  {\n\t    method: \"GET\",\n\t    path: \"/info/health\",\n", "    controller: healthController,\n\t  },\n\t  {\n\t    method: \"GET\",\n\t    path: \"/api/health\",\n\t    controller: healthController,\n\t  },\n\t  {\n\t    method: \"POST\",\n\t    path: \"/api/notify\",\n", "    controller: notifyController,\n\t  },\n\t];\n"]}
{"filename": "src/api/index.ts", "chunked_list": ["import { APIGatewayProxyEventV2 } from \"aws-lambda\";\n\timport { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\n\timport { MeetupEvent } from \"./dao/meetup.dao\";\n\timport { AppConf } from \"./app-conf\";\n\timport { Controller, routes } from \"./routes\";\n\timport colors from \"colors\";\n\texport type EventsResponse = Array<MeetupEvent>;\n\texport async function handler(\n\t  event: APIGatewayProxyEventV2\n\t): Promise<APIGatewayProxyStructuredResultV2> {\n", "  try {\n\t    return await handleRequest(event);\n\t  } catch (e) {\n\t    console.error(`Internal server error: ${e}`);\n\t    return {\n\t      statusCode: 500,\n\t      body: JSON.stringify({\n\t        message: \"Internal server error\",\n\t        requestId: event.requestContext.requestId,\n\t      }),\n", "      headers: {\n\t        \"Content-Type\": \"application/json\",\n\t        \"Access-Control-Allow-Origin\": \"*\",\n\t      },\n\t    };\n\t  }\n\t}\n\tasync function handleRequest(\n\t  event: APIGatewayProxyEventV2\n\t): Promise<APIGatewayProxyStructuredResultV2> {\n", "  console.log(\"request received\");\n\t  if (!isApiKeyValid(event)) {\n\t    return {\n\t      statusCode: 401,\n\t      body: JSON.stringify({\n\t        message: \"Unauthorized\",\n\t      }),\n\t      headers: {\n\t        \"Content-Type\": \"application/json\",\n\t      },\n", "    };\n\t  }\n\t  const path = event.requestContext.http.path;\n\t  const method = event.requestContext.http.method.toUpperCase();\n\t  let controller = undefined as undefined | Controller;\n\t  for (const route of routes) {\n\t    if (method === route.method && new RegExp(`^${route.path}$`).test(path)) {\n\t      controller = route.controller;\n\t      break;\n\t    }\n", "  }\n\t  if (controller) {\n\t    const response = await controller(event);\n\t    if (!response.headers) {\n\t      response.headers = {};\n\t    }\n\t    response.headers[\"Access-Control-Allow-Origin\"] = \"*\";\n\t    return response;\n\t  }\n\t  console.log(\n", "    colors.blue(\"No controller found for path \") + colors.yellow(`\"${path}\"`)\n\t  );\n\t  return {\n\t    statusCode: 404,\n\t    body: JSON.stringify({\n\t      message: \"Not found\",\n\t      requestId: event.requestContext.requestId,\n\t    }),\n\t    headers: {\n\t      \"Content-Type\": \"application/json\",\n", "    },\n\t  };\n\t}\n\tconst API_KEY_PATH = /^\\/api\\/.*/;\n\t/**\n\t * Checks if an API key is needed, and if so, if it is valid. API Keys are required for all non cached requests.\n\t * @param request The request to validate.\n\t */\n\tfunction isApiKeyValid(request: APIGatewayProxyEventV2): boolean {\n\t  if (API_KEY_PATH.test(request.requestContext.http.path)) {\n", "    return request.headers?.[\"x-api-key\"] === AppConf.apiKey;\n\t  }\n\t  return true;\n\t}\n"]}
{"filename": "src/api/dao/meetup.dao.ts", "chunked_list": ["import { request } from \"../util/request.util\";\n\timport { AppConf } from \"../app-conf\";\n\timport { Chapter } from \"./settings.dao\";\n\t//See https://www.meetup.com/api/schema/#p03-objects-section for Meetup API details.\n\t/**\n\t * Represents all the data that is returned from the Meetup API for an event.\n\t */\n\texport type MeetupEvent = {\n\t  id: string;\n\t  eventUrl: string;\n", "  title: string;\n\t  going: number;\n\t  imageUrl: string;\n\t  venue: {\n\t    name: string;\n\t    address: string;\n\t    city: string;\n\t    state: string;\n\t  } | null;\n\t  dateTime: string;\n", "  group: {\n\t    id: string;\n\t    name: string;\n\t    city: string;\n\t    state: string;\n\t    urlname: string;\n\t  };\n\t  description: string;\n\t};\n\t/**\n", " * The raw response from the Meetup API events query.\n\t */\n\ttype QueryResponse = {\n\t  data: Record<\n\t    string,\n\t    {\n\t      upcomingEvents: {\n\t        edges: Array<{\n\t          node: MeetupEvent;\n\t        }>;\n", "      };\n\t    } | null\n\t  >;\n\t};\n\t/**\n\t * Get the events from the Meetup API.\n\t */\n\texport async function getMeetupEvents(\n\t  chapters: Chapter[]\n\t): Promise<Array<MeetupEvent>> {\n", "  const finalQuery = formQuery(chapters);\n\t  const response = await request({\n\t    name: \"Meetup Event\",\n\t    url: `${AppConf.meetupApiBaseUrl}/gql`,\n\t    method: \"POST\",\n\t    headers: { \"Content-Type\": \"application/json\" },\n\t    body: { query: finalQuery },\n\t  });\n\t  return processResponse((await response.json()) as QueryResponse);\n\t}\n", "const eventFragment =\n\t  \"fragment eventFragment on Event { id eventUrl title description going imageUrl venue { name address city state } dateTime group { id name city state urlname}}\";\n\tconst groupFragment =\n\t  \"fragment groupFragment on Group { upcomingEvents(input:{first:10}) { edges { node { ...eventFragment } } } }\";\n\t/**\n\t * Form the query to get the events from the Meetup API.\n\t *\n\t * @param chapters The chapters to get events for.\n\t */\n\tfunction formQuery(chapters: Array<Chapter>): string {\n", "  let newQuery = \"query {\";\n\t  for (const i in chapters) {\n\t    newQuery += `result${i}:groupByUrlname(urlname:\"${chapters[i].meetupGroupUrlName}\") { ...groupFragment }`;\n\t  }\n\t  newQuery += \"}\" + eventFragment + groupFragment;\n\t  return newQuery;\n\t}\n\t/**\n\t * Process the response from the query and return a list of events.\n\t *\n", " * @param response The response from the query.\n\t */\n\tfunction processResponse(response: QueryResponse): Array<MeetupEvent> {\n\t  const result = [] as Array<MeetupEvent>;\n\t  for (const group of Object.values(response.data)) {\n\t    if (group) {\n\t      for (const event of group.upcomingEvents.edges) {\n\t        result.push(event.node);\n\t      }\n\t    }\n", "  }\n\t  return result;\n\t}\n"]}
{"filename": "src/api/dao/email.dao.ts", "chunked_list": ["import { request } from \"../util/request.util\";\n\timport { AppConf } from \"../app-conf\";\n\texport type EmailContent = {\n\t  recipient: string | Array<string>;\n\t  subject: string;\n\t  body: string;\n\t};\n\texport async function sendEmail(email: EmailContent) {\n\t  await request({\n\t    name: \"Send Email\",\n", "    method: \"POST\",\n\t    url: AppConf.emailAppUrl,\n\t    headers: {\n\t      \"Content-Type\": \"application/json\",\n\t    },\n\t    body: email,\n\t  });\n\t}\n"]}
{"filename": "src/api/dao/settings.dao.ts", "chunked_list": ["import { request } from \"../util/request.util\";\n\timport { AppConf } from \"../app-conf\";\n\t/**\n\t * The info for a Code and Coffee Chapter.\n\t */\n\texport type Chapter = {\n\t  name: string;\n\t  meetupGroupUrlName: string;\n\t};\n\texport type NotificationSetting = {\n", "  name: string;\n\t  github: string;\n\t  email: Array<string>;\n\t  emailTitlePrepend: string;\n\t};\n\t/**\n\t * Get a list of all the Code and Coffee Chapters.\n\t */\n\texport async function getChapters(): Promise<Chapter[]> {\n\t  return (await (\n", "    await request({\n\t      name: \"Chapters Setting\",\n\t      url: `${AppConf.settingsBaseUrl}/chapters.json`,\n\t      method: \"GET\",\n\t    })\n\t  ).json()) as Chapter[];\n\t}\n\t/**\n\t * Get the icon for the given chapter.\n\t *\n", " * @param chapter The chapter to get the icon for.\n\t */\n\texport async function getChapterIcon(chapter: string): Promise<ArrayBuffer> {\n\t  return await (\n\t    await request({\n\t      name: \"Chapter Icon\",\n\t      url: `${AppConf.settingsBaseUrl}/chapter-icons/${chapter}.png`,\n\t      method: \"GET\",\n\t    })\n\t  ).arrayBuffer();\n", "}\n\t/**\n\t * Get all the notification settings.\n\t */\n\texport async function getNotificationSettings(): Promise<\n\t  Array<NotificationSetting>\n\t> {\n\t  return await (\n\t    await request({\n\t      name: \"Notification Settings\",\n", "      url: `${AppConf.settingsBaseUrl}/notifications.json`,\n\t      method: \"GET\",\n\t    })\n\t  ).json();\n\t}\n"]}
{"filename": "src/api/dao/github.dao.ts", "chunked_list": ["import { request } from \"../util/request.util\";\n\timport { AppConf } from \"../app-conf\";\n\texport type GithubIssue = {\n\t  title: string;\n\t  body: string;\n\t};\n\texport interface GithubIssueResponse {\n\t  url: string;\n\t  repository_url: string;\n\t  labels_url: string;\n", "  comments_url: string;\n\t  events_url: string;\n\t  html_url: string;\n\t  id: number;\n\t  node_id: string;\n\t  number: number;\n\t  title: string;\n\t  user: User;\n\t  labels: any[];\n\t  state: string;\n", "  locked: boolean;\n\t  assignee: null;\n\t  assignees: any[];\n\t  milestone: null;\n\t  comments: number;\n\t  created_at: Date;\n\t  updated_at: Date;\n\t  closed_at: null;\n\t  author_association: string;\n\t  active_lock_reason: null;\n", "  body: string;\n\t  closed_by: null;\n\t  reactions: Reactions;\n\t  timeline_url: string;\n\t  performed_via_github_app: null;\n\t  state_reason: null;\n\t}\n\texport interface Reactions {\n\t  url: string;\n\t  total_count: number;\n", "  \"+1\": number;\n\t  \"-1\": number;\n\t  laugh: number;\n\t  hooray: number;\n\t  confused: number;\n\t  heart: number;\n\t  rocket: number;\n\t  eyes: number;\n\t}\n\texport interface User {\n", "  login: string;\n\t  id: number;\n\t  node_id: string;\n\t  avatar_url: string;\n\t  gravatar_id: string;\n\t  url: string;\n\t  html_url: string;\n\t  followers_url: string;\n\t  following_url: string;\n\t  gists_url: string;\n", "  starred_url: string;\n\t  subscriptions_url: string;\n\t  organizations_url: string;\n\t  repos_url: string;\n\t  events_url: string;\n\t  received_events_url: string;\n\t  type: string;\n\t  site_admin: boolean;\n\t}\n\texport async function createIssue(\n", "  repo: string,\n\t  issue: GithubIssue\n\t): Promise<GithubIssueResponse> {\n\t  return (\n\t    await request({\n\t      name: \"Create Github Issue\",\n\t      url: `${AppConf.githubApiBaseUrl}/repos/${repo}/issues`,\n\t      method: \"POST\",\n\t      headers: {\n\t        \"Content-Type\": \"application/json\",\n", "        \"X-GitHub-Api-Version\": \"2022-11-28\",\n\t        Authorization: `Bearer ${AppConf.githubAuthKey}`,\n\t        Accept: \"application/vnd.github+json\",\n\t      },\n\t      body: issue,\n\t    })\n\t  ).json();\n\t}\n"]}
{"filename": "src/api/util/request.util.ts", "chunked_list": ["import colors from \"colors\";\n\texport type RequestOptions = {\n\t  name: string;\n\t  url: string;\n\t  body?: any;\n\t  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n\t  headers?: Record<string, string>;\n\t};\n\texport async function request(options: RequestOptions): Promise<Response> {\n\t  console.info(\n", "    colors.blue.bold(\"REST Request \") +\n\t      colors.yellow(options.name) +\n\t      \"\\n\" +\n\t      colors.yellow(\n\t        JSON.stringify({\n\t          name: options.name,\n\t          url: options.url,\n\t          method: options.method,\n\t          headers: options.headers,\n\t          body: !!options.body,\n", "        })\n\t      ) +\n\t      \"\\n\"\n\t  );\n\t  let response;\n\t  try {\n\t    response = await fetch(options.url, {\n\t      method: options.method,\n\t      headers: options.headers,\n\t      body: JSON.stringify(options.body),\n", "    });\n\t  } catch (e) {\n\t    console.error(\n\t      colors.blue.bold(\"REST Response \") +\n\t        colors.yellow(options.name) +\n\t        colors.red.bold(\" FAILURE\") +\n\t        \"\\n\" +\n\t        colors.yellow(`ERROR: ${e}`) +\n\t        \"\\n\"\n\t    );\n", "    throw \"Failed to fetch\";\n\t  }\n\t  if (response.ok) {\n\t    console.info(\n\t      colors.blue.bold(\"REST Response \") +\n\t        colors.yellow(options.name) +\n\t        colors.green.bold(\" SUCCESS\") +\n\t        \"\\n\" +\n\t        colors.yellow(\n\t          JSON.stringify({\n", "            status: response.status,\n\t            statusText: response.statusText,\n\t            headers: response.headers,\n\t            data: !!response.body,\n\t          })\n\t        ) +\n\t        \"\\n\"\n\t    );\n\t  } else {\n\t    console.error(\n", "      colors.blue.bold(\"REST Response \") +\n\t        colors.yellow(options.name) +\n\t        colors.red.bold(\" FAILURE\") +\n\t        \"\\n\" +\n\t        colors.yellow(\n\t          JSON.stringify({\n\t            status: response.status,\n\t            statusText: response.statusText,\n\t            headers: response.headers,\n\t          })\n", "        ) +\n\t        \"\\n\"\n\t    );\n\t    throw response;\n\t  }\n\t  return response;\n\t}\n"]}
{"filename": "src/api/service/events.service.ts", "chunked_list": ["import { getMeetupEvents, MeetupEvent } from \"../dao/meetup.dao\";\n\timport { getChapters } from \"../dao/settings.dao\";\n\t/**\n\t * Get a list of all upcoming events for Code and Coffee.\n\t */\n\texport async function getEvents(): Promise<Array<MeetupEvent>> {\n\t  const chapters = await getChapters();\n\t  const events = await getMeetupEvents(chapters);\n\t  return events.sort((a, b) => {\n\t    return new Date(a.dateTime).getTime() - new Date(b.dateTime).getTime();\n", "  });\n\t}\n"]}
{"filename": "src/api/service/notify.service.ts", "chunked_list": ["import { getNotificationSettings } from \"../dao/settings.dao\";\n\timport { sendEmail } from \"../dao/email.dao\";\n\timport { createIssue } from \"../dao/github.dao\";\n\ttype Notification = {\n\t  channel: string;\n\t  title: string;\n\t  message: string;\n\t};\n\texport async function notify(notification: Notification): Promise<void> {\n\t  if (!isNotificationValid(notification)) {\n", "    throw new Error(\"INVALID_NOTIFICATION\");\n\t  }\n\t  const channelSetting = (await getNotificationSettings()).find(\n\t    (setting) => setting.name === notification.channel\n\t  );\n\t  if (!channelSetting) {\n\t    throw new Error(\"INVALID_NOTIFICATION\");\n\t  }\n\t  if (channelSetting.email) {\n\t    await sendEmail({\n", "      body: notification.message,\n\t      recipient: channelSetting.email,\n\t      subject: channelSetting.emailTitlePrepend\n\t        ? `${channelSetting.emailTitlePrepend}${notification.title}`\n\t        : notification.title,\n\t    });\n\t  }\n\t  if (channelSetting.github) {\n\t    await createIssue(channelSetting.github, {\n\t      title: notification.title,\n", "      body: notification.message,\n\t    });\n\t  }\n\t}\n\tfunction isNotificationValid(notification: any): boolean {\n\t  return !(\n\t    !notification ||\n\t    !notification.channel ||\n\t    !notification.title ||\n\t    !notification.message\n", "  );\n\t}\n"]}
{"filename": "src/api/controllers/notify.controller.ts", "chunked_list": ["import { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\n\timport { APIGatewayProxyEventV2 } from \"aws-lambda\";\n\timport { notify } from \"../service/notify.service\";\n\texport async function notifyController(\n\t  event: APIGatewayProxyEventV2\n\t): Promise<APIGatewayProxyStructuredResultV2> {\n\t  try {\n\t    await notify(JSON.parse(event.body || \"\"));\n\t  } catch (e: any) {\n\t    if (e.message === \"INVALID_NOTIFICATION\") {\n", "      return {\n\t        statusCode: 400,\n\t        body: JSON.stringify({\n\t          result: \"INVALID_NOTIFICATION\",\n\t        }),\n\t        headers: {\n\t          \"Content-Type\": \"application/json\",\n\t        },\n\t      };\n\t    } else {\n", "      return {\n\t        statusCode: 500,\n\t        body: JSON.stringify({\n\t          result: \"FAILURE\",\n\t        }),\n\t        headers: {\n\t          \"Content-Type\": \"application/json\",\n\t        },\n\t      };\n\t    }\n", "  }\n\t  return {\n\t    statusCode: 200,\n\t    body: JSON.stringify({\n\t      result: \"SUCCESS\",\n\t    }),\n\t    headers: {\n\t      \"Content-Type\": \"application/json\",\n\t    },\n\t  };\n", "}\n"]}
{"filename": "src/api/controllers/chapters.controller.ts", "chunked_list": ["import { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\n\timport { getEvents } from \"../service/events.service\";\n\texport async function chaptersController(): Promise<APIGatewayProxyStructuredResultV2> {\n\t  return {\n\t    statusCode: 200,\n\t    body: JSON.stringify(await getEvents()),\n\t    headers: {\n\t      \"Content-Type\": \"application/json\",\n\t    },\n\t  };\n", "}\n"]}
{"filename": "src/api/controllers/health.controller.ts", "chunked_list": ["import { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\n\texport function healthController(): APIGatewayProxyStructuredResultV2 {\n\t  return {\n\t    statusCode: 200,\n\t    body: JSON.stringify({\n\t      status: \"OK\",\n\t      timestamp: new Date().toUTCString(),\n\t    }),\n\t    headers: {\n\t      \"Content-Type\": \"application/json\",\n", "    },\n\t  };\n\t}\n"]}
{"filename": "src/api/controllers/chapter-icon.controller.ts", "chunked_list": ["import { APIGatewayProxyEventV2 } from \"aws-lambda\";\n\timport { APIGatewayProxyStructuredResultV2 } from \"aws-lambda/trigger/api-gateway-proxy\";\n\timport { getChapterIcon } from \"../dao/settings.dao\";\n\texport async function chapterIconController(\n\t  event: APIGatewayProxyEventV2\n\t): Promise<APIGatewayProxyStructuredResultV2> {\n\t  try {\n\t    return {\n\t      statusCode: 200,\n\t      body: new Buffer(\n", "        await getChapterIcon(extractChapter(event.rawPath))\n\t      ).toString(\"base64\"),\n\t      headers: {\n\t        \"Content-Type\": \"image/png\",\n\t      },\n\t      isBase64Encoded: true,\n\t    };\n\t  } catch (e: any | Response) {\n\t    if (e.status === 404) {\n\t      return {\n", "        statusCode: 404,\n\t        body: \"Not Found\",\n\t        headers: {\n\t          \"Content-Type\": \"text/plain\",\n\t        },\n\t      };\n\t    } else {\n\t      throw e;\n\t    }\n\t  }\n", "}\n\tconst chapterRegex = /(?<=\\/info\\/chapter-icons\\/).*$/;\n\tfunction extractChapter(path: string): string {\n\t  const results = path.match(chapterRegex);\n\t  if (results === null) {\n\t    throw new Error(`Could not extract chapter from path ${path}`);\n\t  }\n\t  return results[0];\n\t}\n"]}
{"filename": "src/ui/web-conf.ts", "chunked_list": ["export const WebConf = {\n\t  smBreakpoint: 600,\n\t  rootHost: import.meta.env.VITE_ROOT_URL,\n\t};\n"]}
{"filename": "src/ui/calendar/events.util.ts", "chunked_list": ["import { EventsResponse } from \"../../api\";\n\texport type EventStats = {\n\t  totalEvents: number;\n\t  totalActiveChapters: number;\n\t  totalRSVPs: number;\n\t};\n\t/**\n\t * Gets the stats for all the current events.\n\t *\n\t * @param events The events to get stats from\n", " */\n\texport function getEventStats(events: EventsResponse): EventStats {\n\t  const result: EventStats = {\n\t    totalEvents: 0,\n\t    totalActiveChapters: 0,\n\t    totalRSVPs: 0,\n\t  };\n\t  const chapters = new Set<string>();\n\t  events.forEach((event) => {\n\t    result.totalEvents++;\n", "    result.totalRSVPs += event.going;\n\t    if (!chapters.has(event.group.urlname)) {\n\t      result.totalActiveChapters++;\n\t      chapters.add(event.group.urlname);\n\t    }\n\t  });\n\t  return result;\n\t}\n"]}
{"filename": "src/ui/calendar/coffee.dao.ts", "chunked_list": ["import { EventsResponse } from \"../../api\";\n\timport { WebConf } from \"../web-conf\";\n\t/**\n\t * Get the details of all events from the Code and Coffee service.\n\t */\n\texport async function getEvents(): Promise<EventsResponse> {\n\t  const response = await fetch(`${WebConf.rootHost}/info/events`, {\n\t    method: \"GET\",\n\t  });\n\t  return response.json();\n", "}\n"]}
