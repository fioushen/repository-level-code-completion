{"filename": "vite.config.ts", "chunked_list": ["// vite.config.ts\n\timport react from '@vitejs/plugin-react';\n\timport { defineConfig } from 'vite';\n\texport default defineConfig({\n\t  plugins: [react()],\n\t  server: {\n\t    port: 8082,\n\t    host: '0.0.0.0',\n\t  },\n\t  build: {\n", "    minify: true,\n\t  },\n\t  base: '',\n\t});\n"]}
{"filename": "src/webgpu/webgpubindgroup.ts", "chunked_list": ["import { WebGPUResourceOptions } from './types';\n\timport { WebGPUBindGroupLayout } from './webgpubindgrouplayout';\n\ttype WebGPUBindGroupOptions = WebGPUResourceOptions & {\n\t  bindGroupLayout: WebGPUBindGroupLayout;\n\t  entries: GPUBindGroupEntry[];\n\t};\n\texport class WebGPUBindGroup {\n\t  private group: GPUBindGroup;\n\t  public get bindGroup() {\n\t    return this.group;\n", "  }\n\t  public create(options: WebGPUBindGroupOptions) {\n\t    this.group = options.device.createBindGroup({\n\t      label: options.label,\n\t      layout: options.bindGroupLayout.layout,\n\t      entries: options.entries,\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/webgpu/types.ts", "chunked_list": ["export type WebGPUResourceOptions = {\n\t  label?: string;\n\t  device: GPUDevice;\n\t};\n"]}
{"filename": "src/webgpu/webgpucontext.ts", "chunked_list": ["export class WebGPURenderContext {\n\t  private _canvas: HTMLCanvasElement;\n\t  private _device: GPUDevice;\n\t  private _queue: GPUQueue;\n\t  private _gpuCanvasContext: GPUCanvasContext;\n\t  private _presentationFormat: GPUTextureFormat;\n\t  private _adapterLimits: GPUSupportedLimits;\n\t  private _adapterInfo: GPUAdapterInfo;\n\t  public async initialize(canvas: HTMLCanvasElement) {\n\t    this._canvas = canvas;\n", "    const gpu: GPU = navigator.gpu;\n\t    const adapter = await gpu.requestAdapter();\n\t    this._adapterLimits = adapter.limits;\n\t    this._adapterInfo = await adapter.requestAdapterInfo();\n\t    this._device = await adapter.requestDevice();\n\t    this._queue = this._device.queue;\n\t    this._gpuCanvasContext = this._canvas.getContext('webgpu');\n\t    this._presentationFormat = gpu.getPreferredCanvasFormat();\n\t  }\n\t  public get device() {\n", "    return this._device;\n\t  }\n\t  public get queue() {\n\t    return this._queue;\n\t  }\n\t  public get presentationContext() {\n\t    return this._gpuCanvasContext;\n\t  }\n\t  public get presentationFormat() {\n\t    return this._presentationFormat;\n", "  }\n\t}\n"]}
{"filename": "src/webgpu/webgpurenderpipeline.ts", "chunked_list": ["import { WebGPUResourceOptions } from './types';\n\timport { WebGPUPipelineLayout } from './webgpupipelinelayout';\n\timport { createShaderModuleFromPath } from './webgpushader';\n\ttype WebGPURenderPipelineOptions = WebGPUResourceOptions & {\n\t  sampleCount: number;\n\t  vertexShaderFile: string;\n\t  fragmentShaderFile: string;\n\t  fragmentTargets: GPUColorTargetState[];\n\t  pipelineLayout?: WebGPUPipelineLayout;\n\t};\n", "export class WebGPURenderPipeline {\n\t  private renderPipeline: GPURenderPipeline;\n\t  public get pipeline() {\n\t    return this.renderPipeline;\n\t  }\n\t  public async create(options: WebGPURenderPipelineOptions) {\n\t    this.renderPipeline = options.device.createRenderPipeline({\n\t      label: options.label,\n\t      layout: options.pipelineLayout?.layout ?? 'auto',\n\t      vertex: {\n", "        module: await createShaderModuleFromPath(options.vertexShaderFile, options.device),\n\t        entryPoint: 'main',\n\t      },\n\t      fragment: {\n\t        module: await createShaderModuleFromPath(options.fragmentShaderFile, options.device),\n\t        entryPoint: 'main',\n\t        targets: options.fragmentTargets,\n\t      },\n\t      primitive: {\n\t        topology: 'triangle-list',\n", "      },\n\t      multisample: {\n\t        count: options.sampleCount,\n\t      },\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/webgpu/helpers.ts", "chunked_list": ["export function supportsWebGPU(): boolean {\n\t  if (navigator.gpu) {\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\texport function createBuffer(array: ArrayBuffer, usage: GPUBufferUsageFlags, device: GPUDevice): GPUBuffer {\n\t  try {\n\t    const buffer = device.createBuffer({\n\t      size: array.byteLength,\n", "      usage,\n\t    });\n\t    device.queue.writeBuffer(buffer, 0, array);\n\t    return buffer;\n\t  } catch (e) {\n\t    console.error(e);\n\t  }\n\t}\n"]}
{"filename": "src/webgpu/index.ts", "chunked_list": ["export * from './helpers';\n\texport * from './webgpucontext';\n\texport * from './webgpurenderer';\n"]}
{"filename": "src/webgpu/webgpubindgrouplayout.ts", "chunked_list": ["import { WebGPUResourceOptions } from './types';\n\ttype WebGPUBindGroupLayoutOptions = WebGPUResourceOptions & {\n\t  entries: GPUBindGroupLayoutEntry[];\n\t};\n\texport class WebGPUBindGroupLayout {\n\t  private bindGroupLayout: GPUBindGroupLayout;\n\t  public get layout() {\n\t    return this.bindGroupLayout;\n\t  }\n\t  public create(options: WebGPUBindGroupLayoutOptions) {\n", "    this.bindGroupLayout = options.device.createBindGroupLayout({\n\t      label: options.label,\n\t      entries: options.entries,\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/webgpu/webgpurenderer.ts", "chunked_list": ["import { Vec2, Vec3, vec2 } from 'wgpu-matrix';\n\timport { Camera } from './camera';\n\timport { createBuffer } from './helpers';\n\timport { WebGPUBindGroup } from './webgpubindgroup';\n\timport { WebGPUBindGroupLayout } from './webgpubindgrouplayout';\n\timport { WebGPURenderContext } from './webgpucontext';\n\timport { WebGPUPipelineLayout } from './webgpupipelinelayout';\n\timport { WebGPURenderPipeline } from './webgpurenderpipeline';\n\ttype UniformParams = {\n\t  resolution: Vec2;\n", "  cameraPosition: Vec3;\n\t};\n\texport class WebGPURenderer {\n\t  private readonly canvas: HTMLCanvasElement;\n\t  private readonly context = new WebGPURenderContext();\n\t  private presentationSize: GPUExtent3DDict;\n\t  private readonly depthOrArrayLayers = 1;\n\t  private readonly sampleCount = 4;\n\t  private renderTarget: GPUTexture;\n\t  private renderTargetView: GPUTextureView;\n", "  private depthTarget: GPUTexture;\n\t  private depthTargetView: GPUTextureView;\n\t  private currentTime = 0;\n\t  private renderPipeline: WebGPURenderPipeline;\n\t  // private computePipeline: GPUComputePipeline;\n\t  private uniformParams: UniformParams;\n\t  private uniformParamsBuffer: GPUBuffer;\n\t  private uniformParamsGroup: WebGPUBindGroup;\n\t  private camera: Camera;\n\t  constructor(canvas: HTMLCanvasElement) {\n", "    this.canvas = canvas;\n\t    this.camera = new Camera(canvas, [0, 0, 5], [0, 0, 0]);\n\t    this.uniformParams = {\n\t      resolution: [0, 0],\n\t      cameraPosition: this.camera.position,\n\t    };\n\t  }\n\t  private async initialize() {\n\t    await this.context.initialize(this.canvas);\n\t    this.uniformParams.resolution = [this.canvas.clientWidth, this.canvas.clientHeight];\n", "    const width = this.uniformParams.resolution[0] * window.devicePixelRatio;\n\t    const height = this.uniformParams.resolution[1] * window.devicePixelRatio;\n\t    this.presentationSize = {\n\t      width,\n\t      height,\n\t      depthOrArrayLayers: this.depthOrArrayLayers,\n\t    };\n\t    this.canvas.width = width;\n\t    this.canvas.height = height;\n\t    this.context.presentationContext.configure({\n", "      device: this.context.device,\n\t      format: this.context.presentationFormat,\n\t      alphaMode: 'opaque',\n\t    });\n\t    const resizeObserver = new ResizeObserver(entries => {\n\t      if (!Array.isArray(entries)) {\n\t        return;\n\t      }\n\t      this.resize([entries[0].contentRect.width, entries[0].contentRect.height]);\n\t    });\n", "    resizeObserver.observe(this.canvas);\n\t  }\n\t  private resize(newResolution: Vec2) {\n\t    if (!vec2.equals(this.uniformParams.resolution, newResolution)) {\n\t      this.uniformParams.resolution = newResolution;\n\t      const width = this.uniformParams.resolution[0] * window.devicePixelRatio;\n\t      const height = this.uniformParams.resolution[1] * window.devicePixelRatio;\n\t      this.canvas.width = width;\n\t      this.canvas.height = height;\n\t      this.presentationSize = {\n", "        width,\n\t        height,\n\t        depthOrArrayLayers: this.depthOrArrayLayers,\n\t      };\n\t      this.reCreateRenderTargets();\n\t    }\n\t  }\n\t  private reCreateRenderTargets() {\n\t    if (this.renderTarget) {\n\t      this.renderTarget.destroy();\n", "    }\n\t    if (this.depthTarget) {\n\t      this.depthTarget.destroy();\n\t    }\n\t    /* render target */\n\t    this.renderTarget = this.context.device.createTexture({\n\t      size: this.presentationSize,\n\t      sampleCount: this.sampleCount,\n\t      format: this.context.presentationFormat,\n\t      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n", "    });\n\t    this.renderTargetView = this.renderTarget.createView();\n\t    /* depth target */\n\t    this.depthTarget = this.context.device.createTexture({\n\t      size: this.presentationSize,\n\t      sampleCount: this.sampleCount,\n\t      format: 'depth24plus-stencil8',\n\t      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n\t    });\n\t    this.depthTargetView = this.depthTarget.createView();\n", "  }\n\t  private getUniformParamsArray(): ArrayBuffer {\n\t    const uniformParamsArray = new ArrayBuffer(32);\n\t    new Uint32Array(uniformParamsArray, 0, 2).set(this.uniformParams.resolution);\n\t    new Float32Array(uniformParamsArray, 16, 3).set(this.uniformParams.cameraPosition);\n\t    return uniformParamsArray;\n\t  }\n\t  private async initializeResources() {\n\t    this.uniformParamsBuffer = createBuffer(\n\t      this.getUniformParamsArray(),\n", "      GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t      this.context.device,\n\t    );\n\t    const bindGroupLayout = new WebGPUBindGroupLayout();\n\t    bindGroupLayout.create({\n\t      device: this.context.device,\n\t      entries: [\n\t        {\n\t          binding: 0,\n\t          visibility: GPUShaderStage.FRAGMENT,\n", "          buffer: {\n\t            type: 'uniform',\n\t          },\n\t        },\n\t      ],\n\t    });\n\t    this.uniformParamsGroup = new WebGPUBindGroup();\n\t    this.uniformParamsGroup.create({\n\t      device: this.context.device,\n\t      bindGroupLayout,\n", "      entries: [\n\t        {\n\t          binding: 0,\n\t          resource: {\n\t            buffer: this.uniformParamsBuffer,\n\t          },\n\t        },\n\t      ],\n\t    });\n\t    const pipelineLayout = new WebGPUPipelineLayout();\n", "    pipelineLayout.create({\n\t      device: this.context.device,\n\t      bindGroupLayouts: [bindGroupLayout],\n\t    });\n\t    this.renderPipeline = new WebGPURenderPipeline();\n\t    await this.renderPipeline.create({\n\t      device: this.context.device,\n\t      vertexShaderFile: './shaders/basic.vert.wgsl',\n\t      fragmentShaderFile: './shaders/basic.frag.wgsl',\n\t      fragmentTargets: [{ format: this.context.presentationFormat }],\n", "      sampleCount: this.sampleCount,\n\t      pipelineLayout,\n\t    });\n\t  }\n\t  private updateUniformBuffer() {\n\t    this.context.queue.writeBuffer(this.uniformParamsBuffer, 0, this.getUniformParamsArray());\n\t  }\n\t  public async start() {\n\t    await this.initialize();\n\t    this.reCreateRenderTargets();\n", "    await this.initializeResources();\n\t    this.currentTime = performance.now();\n\t    this.update();\n\t  }\n\t  private update = () => {\n\t    const beginFrameTime = performance.now();\n\t    const duration = beginFrameTime - this.currentTime;\n\t    this.currentTime = beginFrameTime;\n\t    this.uniformParams.cameraPosition = this.camera.position;\n\t    this.render(duration);\n", "    window.requestAnimationFrame(this.update);\n\t    const endFrameTime = performance.now();\n\t    const frameDuration = endFrameTime - beginFrameTime;\n\t  };\n\t  private render(deltaTime: number) {\n\t    // this.computePass(deltaTime);\n\t    this.renderPass();\n\t  }\n\t  private renderPass() {\n\t    this.updateUniformBuffer();\n", "    const renderPassDesc: GPURenderPassDescriptor = {\n\t      colorAttachments: [\n\t        {\n\t          view: this.sampleCount > 1 ? this.renderTargetView : this.context.presentationContext.getCurrentTexture().createView(),\n\t          resolveTarget: this.sampleCount > 1 ? this.context.presentationContext.getCurrentTexture().createView() : undefined,\n\t          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n\t          loadOp: 'clear',\n\t          storeOp: 'discard',\n\t        },\n\t      ],\n", "      // depthStencilAttachment: {\n\t      //   view: this.depthTargetView,\n\t      //   depthLoadOp: 'clear',\n\t      //   depthClearValue: 1.0,\n\t      //   depthStoreOp: 'store',\n\t      //   stencilLoadOp: 'clear',\n\t      //   stencilClearValue: 0,\n\t      //   stencilStoreOp: 'store',\n\t      // },\n\t    };\n", "    const commandEncoder = this.context.device.createCommandEncoder();\n\t    const passEncoder = commandEncoder.beginRenderPass(renderPassDesc);\n\t    passEncoder.setPipeline(this.renderPipeline.pipeline);\n\t    passEncoder.setBindGroup(0, this.uniformParamsGroup.bindGroup);\n\t    passEncoder.draw(3, 1, 0, 0); // only 1 triangle\n\t    passEncoder.end();\n\t    this.context.queue.submit([commandEncoder.finish()]);\n\t  }\n\t  // private computePass(deltaTime: number) {\n\t  //   const commandEncoder = this.context.device.createCommandEncoder();\n", "  //   const passEncoder = commandEncoder.beginComputePass();\n\t  //   passEncoder.setPipeline(this.computePipeline);\n\t  //   passEncoder.end();\n\t  //   this.context.queue.submit([commandEncoder.finish()]);\n\t  // }\n\t}\n"]}
{"filename": "src/webgpu/webgpushader.ts", "chunked_list": ["export function createShaderModuleFromString(code: string, device: GPUDevice) {\n\t  return device.createShaderModule({ code });\n\t}\n\texport async function createShaderModuleFromPath(path: string, device: GPUDevice) {\n\t  const res = await fetch(path);\n\t  const code = await res.text();\n\t  return createShaderModuleFromString(code, device);\n\t}\n"]}
{"filename": "src/webgpu/webgpupipelinelayout.ts", "chunked_list": ["import { WebGPUResourceOptions } from './types';\n\timport { WebGPUBindGroupLayout } from './webgpubindgrouplayout';\n\texport type WebGPUPipelineLayoutOptions = WebGPUResourceOptions & {\n\t  bindGroupLayouts: WebGPUBindGroupLayout[];\n\t};\n\texport class WebGPUPipelineLayout {\n\t  private pipelineLayout: GPUPipelineLayout;\n\t  public get layout() {\n\t    return this.pipelineLayout;\n\t  }\n", "  public create(options: WebGPUPipelineLayoutOptions) {\n\t    this.pipelineLayout = options.device.createPipelineLayout({\n\t      label: options.label,\n\t      bindGroupLayouts: options.bindGroupLayouts.map(bgl => bgl.layout),\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/webgpu/camera.ts", "chunked_list": ["import { Vec2, Vec3, vec2 } from 'wgpu-matrix';\n\texport class Camera {\n\t  private currentMousePosition: Vec2 = vec2.create();\n\t  constructor(canvas: HTMLCanvasElement, private cameraPosition: Vec3, private cameraTarget: Vec3) {\n\t    canvas.addEventListener('wheel', this.onMouseWheel);\n\t    canvas.addEventListener('mousemove', this.onMouseMove);\n\t    document.addEventListener('keydown', this.onKeyDown);\n\t    document.addEventListener('keyup', this.onKeyup);\n\t  }\n\t  private onMouseWheel = (event: WheelEvent) => {\n", "    this.cameraPosition[2] = this.cameraPosition[2] + event.deltaY * 0.01;\n\t  };\n\t  private onMouseMove = (event: MouseEvent) => {\n\t    // const currentPos: Vec2 = [event.clientX, event.clientY];\n\t    // if (event.buttons === 1) {\n\t    //   const offset = vec2.subtract(currentPos, this.currentMousePosition);\n\t    //   vec2.scale(offset, 0.0025, offset);\n\t    //   vec2.add(this.cameraPosition, [offset[0], offset[1], 0], this.cameraPosition);\n\t    //   //console.log(cameraPosition);\n\t    // }\n", "    // this.currentMousePosition = currentPos;\n\t  };\n\t  private onKeyDown = (event: KeyboardEvent) => {\n\t    const movementSpeed = 0.25;\n\t    let x = this.cameraPosition[0];\n\t    let y = this.cameraPosition[1];\n\t    switch (event.key) {\n\t      case 'w':\n\t        y += movementSpeed;\n\t        break;\n", "      case 's':\n\t        y -= movementSpeed;\n\t        break;\n\t      case 'a':\n\t        x -= movementSpeed;\n\t        break;\n\t      case 'd':\n\t        x += movementSpeed;\n\t        break;\n\t    }\n", "    this.cameraPosition[0] = x;\n\t    this.cameraPosition[1] = y;\n\t  };\n\t  private onKeyup = (event: KeyboardEvent) => {\n\t    //\n\t  };\n\t  public get position(): Vec3 {\n\t    return this.cameraPosition;\n\t  }\n\t  public get target(): Vec3 {\n", "    return this.cameraTarget;\n\t  }\n\t}\n"]}
