{"filename": "src/index.ts", "chunked_list": ["export * from './lib/datasource';\n\texport * from './lib/executor';\n\texport * from './lib/logging';\n\texport * from './lib/stored-procedure';\n\texport * from './lib/types';\n\texport * from './lib/utils';\n"]}
{"filename": "src/lib/datasource/mssql-datasource.ts", "chunked_list": ["import type { Request } from 'mssql';\n\timport { type GraphQLResolveInfo } from 'graphql';\n\timport { DevConsoleLogger, logExecutionBegin, logExecutionEnd, logSafely } from '../logging';\n\timport { DatabaseExecutor } from '../executor';\n\timport { ConnectionManager } from '../utils';\n\timport {\n\t  StoredProcedureManager,\n\t  StoredProcedureCacheManager,\n\t  StoredProcedureMetadataManager,\n\t} from '../stored-procedure';\n", "import type { MSSQLOptions, ILogger, IResolverProcedureResult, InputParameters } from '../types';\n\t/**\n\t * A GraphQL DataSource backed by a Microsoft SQL Server database.\n\t * Maintains separate caching for Query and Mutation operations.\n\t * Maintains a global connection pool cache to reuse connections.\n\t */\n\texport class MSSQLDataSource {\n\t  private readonly _queryOptions: MSSQLOptions;\n\t  private readonly _mutationOptions: MSSQLOptions;\n\t  private readonly _queryLogger: ILogger;\n", "  private readonly _mutationLogger: ILogger;\n\t  private readonly _connectionManager: ConnectionManager;\n\t  private readonly _databaseExecutor: DatabaseExecutor;\n\t  private readonly _storedProcedureMetadataManager: StoredProcedureMetadataManager;\n\t  private readonly _storedProcedureCacheManager: StoredProcedureCacheManager;\n\t  private readonly _storedProcedureManager: StoredProcedureManager;\n\t  /**\n\t   * Creates a new MSSQLDataSource with the given options.\n\t   * @param queryOptions The options for Query operations\n\t   * @param mutationOptions The options for Mutation operations\n", "   */\n\t  constructor(\n\t    queryOptions: MSSQLOptions = MSSQLDataSource.defaultOptions,\n\t    mutationOptions: MSSQLOptions = MSSQLDataSource.defaultOptions,\n\t  ) {\n\t    this._queryOptions = queryOptions;\n\t    this._mutationOptions = mutationOptions;\n\t    const defaultOptions = MSSQLDataSource.defaultOptions;\n\t    this._queryLogger =\n\t      queryOptions.logger !== undefined ? queryOptions.logger : (defaultOptions.logger as ILogger);\n", "    this._mutationLogger =\n\t      mutationOptions.logger !== undefined\n\t        ? mutationOptions.logger\n\t        : (defaultOptions.logger as ILogger);\n\t    this._connectionManager = new ConnectionManager(\n\t      this._queryOptions.config,\n\t      this._mutationOptions.config,\n\t    );\n\t    this._databaseExecutor = new DatabaseExecutor(this._connectionManager);\n\t    this._storedProcedureMetadataManager = new StoredProcedureMetadataManager(\n", "      this._databaseExecutor,\n\t    );\n\t    this._storedProcedureCacheManager = new StoredProcedureCacheManager();\n\t    this._storedProcedureManager = new StoredProcedureManager(\n\t      this._storedProcedureCacheManager,\n\t      this._storedProcedureMetadataManager,\n\t    );\n\t  }\n\t  /**\n\t   * Executes a stored procedure for a Query operation with the provided input parameters, and returns the result.\n", "   * @template T - This type parameter represents the type of the value returned by the resolver procedure.\n\t   * @param {string} storedProcedureName - The name of the stored procedure to execute.\n\t   * @param {StoredProcedureInput} input - The input parameters for the stored procedure.\n\t   * @param {GraphQLResolveInfo | undefined} info - If provided, will be used to case-insensitively map the stored\n\t   * procedure results to the correct schema field names.\n\t   * @returns A Promise that resolves to the result of the stored procedure execution.\n\t   */\n\t  public async executeStoredProcedureQuery<T>(\n\t    storedProcedureName: string,\n\t    input: InputParameters,\n", "    info?: GraphQLResolveInfo,\n\t  ): Promise<IResolverProcedureResult<T>> {\n\t    const startTime = performance.now();\n\t    const logger = this._queryLogger;\n\t    logExecutionBegin(logger, `Stored Procedure Query ${storedProcedureName} with inputs`, input);\n\t    const result = await this._databaseExecutor.executeQueryRequest(\n\t      async (request: Request): Promise<IResolverProcedureResult<T>> =>\n\t        await this._storedProcedureManager.executeStoredProcedure<T>(\n\t          storedProcedureName,\n\t          input,\n", "          request,\n\t          logger,\n\t          info,\n\t        ),\n\t      logger,\n\t    );\n\t    logExecutionEnd(logger, `Stored Procedure Query ${storedProcedureName}`, startTime);\n\t    logSafely(logger, 'info', `------------------`);\n\t    return result;\n\t  }\n", "  /**\n\t   * Executes a stored procedure for a Mutation operation with the provided input parameters, and returns the result.\n\t   * @template T - This type parameter represents the type of the value returned by the resolver procedure.\n\t   * @param {string} storedProcedureName - The name of the stored procedure to execute.\n\t   * @param {StoredProcedureInput} input - The input parameters for the stored procedure.\n\t   * @param {GraphQLResolveInfo | undefined} info - If provided, will be used to case-insensitively map the stored\n\t   * procedure results to the correct schema field names.\n\t   * @returns A Promise that resolves to the result of the stored procedure execution.\n\t   */\n\t  public async executeStoredProcedureMutation<T>(\n", "    storedProcedureName: string,\n\t    input: InputParameters,\n\t    info?: GraphQLResolveInfo,\n\t  ): Promise<IResolverProcedureResult<T>> {\n\t    const startTime = performance.now();\n\t    const logger = this._mutationLogger;\n\t    logExecutionBegin(logger, `Stored Procedure Mutation ${storedProcedureName}`, input);\n\t    const result = await this._databaseExecutor.executeMutationRequest(\n\t      async (request: Request): Promise<IResolverProcedureResult<T>> =>\n\t        await this._storedProcedureManager.executeStoredProcedure(\n", "          storedProcedureName,\n\t          input,\n\t          request,\n\t          logger,\n\t          info,\n\t        ),\n\t      logger,\n\t    );\n\t    logExecutionEnd(logger, `Stored Procedure Mutation ${storedProcedureName}`, startTime);\n\t    return result;\n", "  }\n\t  /**\n\t   * Default options for the Query and Mutation global connection pool cache.\n\t   */\n\t  private static get defaultOptions(): MSSQLOptions {\n\t    return {\n\t      config: {\n\t        user: '',\n\t        password: '',\n\t        server: '',\n", "        database: '',\n\t      },\n\t      logger: new DevConsoleLogger(),\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/lib/datasource/index.ts", "chunked_list": ["export * from './mssql-datasource';\n"]}
{"filename": "src/lib/utils/type-map.ts", "chunked_list": ["import {\n\t  type ISqlTypeFactory,\n\t  type ISqlTypeFactoryWithLength,\n\t  type ISqlTypeFactoryWithNoParams,\n\t  type ISqlTypeFactoryWithPrecisionScale,\n\t  type ISqlTypeFactoryWithScale,\n\t  type ISqlTypeFactoryWithTvpType,\n\t  type ISqlTypeWithLength,\n\t  type ISqlTypeWithNoParams,\n\t  type ISqlTypeWithPrecisionScale,\n", "  type ISqlTypeWithScale,\n\t  type ISqlTypeWithTvpType,\n\t  TYPES,\n\t  MAX,\n\t} from 'mssql';\n\timport type { StoredProcedureParameter } from '../types';\n\ttype TypeFactory<T> = T extends ISqlTypeFactoryWithNoParams\n\t  ? () => ISqlTypeWithNoParams\n\t  : T extends ISqlTypeFactoryWithLength\n\t  ? (length?: number) => ISqlTypeWithLength\n", "  : T extends ISqlTypeFactoryWithScale\n\t  ? (scale?: number) => ISqlTypeWithScale\n\t  : T extends ISqlTypeFactoryWithPrecisionScale\n\t  ? (precision?: number, scale?: number) => ISqlTypeWithPrecisionScale\n\t  : T extends ISqlTypeFactoryWithTvpType\n\t  ? (tvpType?: unknown) => ISqlTypeWithTvpType\n\t  : never;\n\ttype TypesType = typeof TYPES;\n\ttype TypesKey = keyof TypesType;\n\ttype IndexableTypes = {\n", "  [K in TypesKey]: TypeFactory<TypesType[K]>;\n\t};\n\tfunction isSqlTypeFactoryWithNoParams(\n\t  factoryObject: ISqlTypeFactory,\n\t): factoryObject is ISqlTypeFactoryWithNoParams {\n\t  return (\n\t    factoryObject !== undefined &&\n\t    !('length' in factoryObject) &&\n\t    !('scale' in factoryObject) &&\n\t    !('precision' in factoryObject) &&\n", "    !('tvpType' in factoryObject)\n\t  );\n\t}\n\tfunction isSqlTypeFactoryWithLength(\n\t  factoryObject: ISqlTypeFactory,\n\t): factoryObject is ISqlTypeFactoryWithLength {\n\t  return factoryObject !== undefined && 'length' in factoryObject;\n\t}\n\tfunction isSqlTypeFactoryWithScale(\n\t  factoryObject: ISqlTypeFactory,\n", "): factoryObject is ISqlTypeFactoryWithScale {\n\t  return factoryObject !== undefined && 'scale' in factoryObject;\n\t}\n\tfunction isSqlTypeFactoryWithPrecisionScale(\n\t  factoryObject: ISqlTypeFactory,\n\t): factoryObject is ISqlTypeFactoryWithPrecisionScale {\n\t  return factoryObject !== undefined && 'precision' in factoryObject && 'scale' in factoryObject;\n\t}\n\tfunction isSqlTypeFactoryWithTvpType(\n\t  factoryObject: ISqlTypeFactory,\n", "): factoryObject is ISqlTypeFactoryWithTvpType {\n\t  return factoryObject !== undefined && 'tvpType' in factoryObject;\n\t}\n\tconst findPropertyCaseInsensitive = (obj: object, propertyName: string): string | null => {\n\t  const lowercasePropertyName = propertyName.toLowerCase();\n\t  for (const key in obj) {\n\t    if (\n\t      Object.prototype.hasOwnProperty.call(obj, key) &&\n\t      key.toLowerCase() === lowercasePropertyName\n\t    ) {\n", "      return key;\n\t    }\n\t  }\n\t  return null;\n\t};\n\texport const mapDbTypeToDriverType = ({\n\t  type,\n\t  length,\n\t  precision,\n\t  scale,\n", "}: Pick<StoredProcedureParameter, 'type' | 'length' | 'precision' | 'scale'>): ISqlTypeFactory => {\n\t  const types: IndexableTypes = TYPES;\n\t  const property = findPropertyCaseInsensitive(types, type);\n\t  if (property !== null) {\n\t    const typeFactory = types[property as TypesKey];\n\t    if (isSqlTypeFactoryWithNoParams(typeFactory)) {\n\t      return typeFactory();\n\t    } else if (isSqlTypeFactoryWithLength(typeFactory)) {\n\t      return (typeFactory as ISqlTypeFactoryWithLength)(length === -1 ? MAX : length);\n\t    } else if (isSqlTypeFactoryWithScale(typeFactory)) {\n", "      return (typeFactory as ISqlTypeFactoryWithScale)(scale);\n\t    } else if (isSqlTypeFactoryWithPrecisionScale(typeFactory)) {\n\t      return (typeFactory as ISqlTypeFactoryWithPrecisionScale)(precision, scale);\n\t    } else if (isSqlTypeFactoryWithTvpType(typeFactory)) {\n\t      return TYPES.NVarChar();\n\t    } else {\n\t      throw new Error(`Unknown SQL Type ${type}.`);\n\t    }\n\t  }\n\t  return TYPES.NVarChar();\n", "};\n\ttype SqlValue = string | number | boolean | Date | Buffer;\n\tconst isStringOrNumber = (value: SqlValue): value is string | number => {\n\t  return typeof value === 'string' || typeof value === 'number';\n\t};\n\tconst isDate = (value: SqlValue): value is Date => {\n\t  return value instanceof Date;\n\t};\n\tconst isType = (sqlType: string, typePrefixes: string[]): boolean => {\n\t  return typePrefixes.some((prefix) => sqlType.startsWith(prefix));\n", "};\n\texport const convertSqlValueToJsValue = (value: SqlValue, sqlType: string): unknown => {\n\t  if (value === 'NULL') {\n\t    return null;\n\t  }\n\t  const lowerCaseSqlType = sqlType.toLowerCase();\n\t  if (\n\t    isType(lowerCaseSqlType, [\n\t      'varchar',\n\t      'nvarchar',\n", "      'char',\n\t      'nchar',\n\t      'text',\n\t      'ntext',\n\t      'xml',\n\t      'uniqueidentifier',\n\t    ])\n\t  ) {\n\t    return String(value);\n\t  }\n", "  if (\n\t    isType(lowerCaseSqlType, [\n\t      'int',\n\t      'smallint',\n\t      'tinyint',\n\t      'bigint',\n\t      'decimal',\n\t      'numeric',\n\t      'float',\n\t      'real',\n", "      'money',\n\t      'smallmoney',\n\t    ])\n\t  ) {\n\t    return Number(value);\n\t  }\n\t  if (isType(lowerCaseSqlType, ['bit'])) {\n\t    return Boolean(value);\n\t  }\n\t  if (isType(lowerCaseSqlType, ['date', 'datetime', 'datetime2', 'smalldatetime', 'time'])) {\n", "    if (isStringOrNumber(value) || isDate(value)) {\n\t      return new Date(value);\n\t    }\n\t    throw new Error('Cannot create a Date from a boolean value.');\n\t  }\n\t  if (isType(lowerCaseSqlType, ['binary', 'varbinary', 'image'])) {\n\t    return Buffer.from(value as Buffer);\n\t  }\n\t  if (isType(lowerCaseSqlType, ['rowversion', 'timestamp'])) {\n\t    return Buffer.from(value as Buffer);\n", "  }\n\t  if (isType(lowerCaseSqlType, ['hierarchyid', 'geometry', 'geography'])) {\n\t    return value;\n\t  }\n\t  if (isType(lowerCaseSqlType, ['tvp'])) {\n\t    throw new Error('TVPs are not supported.');\n\t  }\n\t  if (isType(lowerCaseSqlType, ['udt'])) {\n\t    throw new Error('UDTs are not supported.');\n\t  }\n", "  throw new Error(`Unsupported SQL type: ${sqlType}`);\n\t};\n"]}
{"filename": "src/lib/utils/connection-manager.ts", "chunked_list": ["import { ConnectionPool } from 'mssql';\n\timport type { MSSQLConfig } from '../types';\n\t/**\n\t * Whether the given config is a string or not.\n\t * @param config - The config to check\n\t * @returns Whether the config is a string or not\n\t */\n\texport const isConfigString = (config: MSSQLConfig): config is string => {\n\t  return typeof config === 'string';\n\t};\n", "/**\n\t * A class for managing the global connection pools for the Query and Mutation data sources.\n\t */\n\texport class ConnectionManager {\n\t  private static _queryConfig: MSSQLConfig;\n\t  private static _mutationConfig: MSSQLConfig;\n\t  private static _globalQueryPool: ConnectionPool | undefined;\n\t  private static _globalMutationPool: ConnectionPool | undefined;\n\t  /**\n\t   * Constructs a new ConnectionManager instance.\n", "   * @param {MSSQLConfig} queryConfig The config to be used for the Query data source\n\t   * @param {MSSQLConfig} mutationConfig The config to be used for the Mutation data source\n\t   */\n\t  constructor(queryConfig: MSSQLConfig, mutationConfig: MSSQLConfig) {\n\t    if (ConnectionManager._queryConfig === undefined) {\n\t      ConnectionManager._queryConfig = queryConfig;\n\t    }\n\t    if (ConnectionManager._mutationConfig === undefined) {\n\t      ConnectionManager._mutationConfig = mutationConfig;\n\t    }\n", "  }\n\t  /**\n\t   * Returns the global query connection pool.\n\t   */\n\t  public get queryConnectionPool(): ConnectionPool {\n\t    if (ConnectionManager._globalQueryPool === undefined) {\n\t      ConnectionManager._globalQueryPool = this.createConnectionPool(\n\t        ConnectionManager._queryConfig,\n\t      );\n\t    }\n", "    return ConnectionManager._globalQueryPool;\n\t  }\n\t  /**\n\t   * Returns the global mutation connection pool.\n\t   */\n\t  public get mutationConnectionPool(): ConnectionPool {\n\t    if (ConnectionManager._globalMutationPool === undefined) {\n\t      ConnectionManager._globalMutationPool = this.createConnectionPool(\n\t        ConnectionManager._mutationConfig,\n\t      );\n", "    }\n\t    return ConnectionManager._globalMutationPool;\n\t  }\n\t  private createConnectionPool(config: MSSQLConfig): ConnectionPool {\n\t    return isConfigString(config) ? new ConnectionPool(config) : new ConnectionPool(config);\n\t  }\n\t}\n"]}
{"filename": "src/lib/utils/index.ts", "chunked_list": ["export * from './cache-helper';\n\texport * from './connection-manager';\n\texport * from './type-map';\n\texport * from './type-replacer';\n"]}
{"filename": "src/lib/utils/type-replacer.ts", "chunked_list": ["export const replacer = (key: string, value: any): unknown => {\n\t  if (typeof value === 'bigint') {\n\t    return { __type: 'BigInt', value: value.toString() };\n\t  } else if (value instanceof Date) {\n\t    return { __type: 'Date', value: value.toISOString() };\n\t  } else if (value instanceof Map) {\n\t    return { __type: 'Map', value: Array.from(value.entries()) };\n\t  } else if (value instanceof Set) {\n\t    return { __type: 'Set', value: Array.from(value.values()) };\n\t  } else if (value instanceof RegExp) {\n", "    return { __type: 'RegExp', value: value.toString() };\n\t  } else if (value instanceof Buffer) {\n\t    return { __type: 'Buffer', value: value.toString('base64') };\n\t  } else {\n\t    return value;\n\t  }\n\t};\n"]}
{"filename": "src/lib/utils/graphql-helper.ts", "chunked_list": ["import { type GraphQLResolveInfo, type FieldNode, visit } from 'graphql';\n\t/**\n\t * Find the first node in the GraphQLResolveInfo with the given case insensitive name.\n\t * @param {GraphQLResolveInfo} info - The GraphQL resolve information object.\n\t * @param {string} nodeName - The case insensitive name of the node to find.\n\t * @returns {FieldNode | undefined} - The found node, or undefined if not found.\n\t */\n\texport function findNodeByName(info: GraphQLResolveInfo, nodeName: string): FieldNode | undefined {\n\t  let targetNode: FieldNode | undefined;\n\t  // Iterate through the fieldNodes, stopping when the target node is found\n", "  info.fieldNodes.some((fieldNode) =>\n\t    visit(fieldNode, {\n\t      Field(node) {\n\t        // Compare the node's name (case insensitive) to the target nodeName\n\t        if (node.name.value.toLowerCase() === nodeName.toLowerCase()) {\n\t          targetNode = node;\n\t          return false; // Stop traversal once the target node is found\n\t        }\n\t      },\n\t    }),\n", "  );\n\t  return targetNode;\n\t}\n\t/**\n\t * Get a dictionary of all subfields of the given target node, where the keys are\n\t * the lowercase subfield names and the values are the correctly cased names.\n\t * @param {FieldNode} targetNode - The target node whose subfield names to retrieve.\n\t * @returns {Record<string, string>} - A dictionary mapping lowercase subfield names to their correctly cased names.\n\t */\n\texport function getSelectionSetNames(targetNode: FieldNode): Record<string, string> {\n", "  const subfieldNames: Record<string, string> = {};\n\t  // If the target node has a selection set, visit its subfields and collect their names\n\t  if (targetNode.selectionSet !== undefined) {\n\t    visit(targetNode.selectionSet, {\n\t      Field(node) {\n\t        subfieldNames[node.name.value.toLowerCase()] = node.name.value;\n\t      },\n\t    });\n\t  }\n\t  return subfieldNames;\n", "}\n\t/**\n\t * Find the first node with the given case insensitive name in the GraphQLResolveInfo\n\t * and return a dictionary of its subfield names, where the keys are the lowercase\n\t * subfield names and the values are the correctly cased names.\n\t * @param {GraphQLResolveInfo} info - The GraphQL resolve information object.\n\t * @param {string} nodeName - The case insensitive name of the node to find.\n\t * @returns {Record<string, string>} - A dictionary of subfield names, or an empty dictionary if the node is not found.\n\t */\n\texport function getNodeSelectionSetNames(\n", "  info: GraphQLResolveInfo,\n\t  nodeName: string,\n\t): Record<string, string> {\n\t  const targetNode = findNodeByName(info, nodeName);\n\t  // If the target node is not found, return an empty dictionary\n\t  if (targetNode === undefined) {\n\t    return {};\n\t  }\n\t  // If the target node is found, return its subfield names\n\t  return getSelectionSetNames(targetNode);\n", "}\n\t/**\n\t * Get a dictionary of all field names excluding those of the given nodeName,\n\t * where the keys are the lowercase sibling field names and the values are the\n\t * correctly cased names.\n\t * @param {GraphQLResolveInfo} info - The GraphQL resolve information object.\n\t * @param {string} nodeName - The case insensitive name of the node to exclude.\n\t * @returns {Record<string, string>} - A dictionary mapping lowercase sibling field names to their correctly cased names, or an empty dictionary if the node is not found.\n\t */\n\texport function getFieldNamesExcludingNode(\n", "  info: GraphQLResolveInfo,\n\t  nodeName: string,\n\t): Record<string, string> {\n\t  const siblingFields: Record<string, string> = {};\n\t  info.fieldNodes.forEach((fieldNode) => {\n\t    visit(fieldNode, {\n\t      Field(node) {\n\t        const isTargetNode = node.name.value.toLowerCase() === nodeName.toLowerCase();\n\t        if (isTargetNode) {\n\t          return false;\n", "        } else {\n\t          siblingFields[node.name.value.toLowerCase()] = node.name.value;\n\t        }\n\t      },\n\t    });\n\t  });\n\t  return siblingFields;\n\t}\n"]}
{"filename": "src/lib/utils/cache-helper.ts", "chunked_list": ["import crypto from 'crypto';\n\timport type { KeyValueCache } from '@apollo/utils.keyvaluecache';\n\texport class CacheHelper<T> {\n\t  /**\n\t   * Constructs a new CacheHelper instance.\n\t   * @param _cache The cache to be used for storing and retrieving T\n\t   */\n\t  constructor(private readonly _cache: KeyValueCache<T>) {}\n\t  /**\n\t   * Returns the hash of the given key using the SHA1 algorithm.\n", "   * This is used to generate unique cache keys for storing T.\n\t   *\n\t   * @param key The string to be hashed\n\t   * @returns The hashed key as a base64 string\n\t   */\n\t  private hashKey(key: string): string {\n\t    return crypto.createHash('sha1').update(key).digest('base64');\n\t  }\n\t  /**\n\t   * Attempts to retrieve the cached T for the given key.\n", "   * @param keyToHash The key to be hashed and used to lookup the cached T\n\t   * @returns The cached T if it exists, otherwise undefined\n\t   */\n\t  public async tryGetFromCache(keyToHash: string): Promise<T | undefined> {\n\t    const key = this.hashKey(keyToHash);\n\t    return await this._cache.get(key);\n\t  }\n\t  /**\n\t   * Caches the given T using the given key.\n\t   * @param keyToHash The key to be hashed and used to store the T\n", "   * @param result The result to be cached\n\t   */\n\t  public async addToCache(keyToHash: string, obj: T): Promise<void> {\n\t    const key = this.hashKey(keyToHash);\n\t    await this._cache.set(key, obj);\n\t  }\n\t}\n"]}
{"filename": "src/lib/logging/dev-console-logger.ts", "chunked_list": ["import type { ILogger } from '../types';\n\t/**\n\t * A logger that logs messages to the console.\n\t */\n\texport class DevConsoleLogger implements ILogger {\n\t  private readonly _isDev: boolean;\n\t  /**\n\t   * Creates a new instance of the ConsoleLogger class.\n\t   */\n\t  constructor() {\n", "    this._isDev = process.env.NODE_ENV !== 'production';\n\t  }\n\t  /**\n\t   * Logs an informational message to the console.\n\t   * @param {unknown} message The message to log\n\t   * @param {unknown[]} optionalParams Optional parameters to log\n\t   */\n\t  info(message?: unknown, ...optionalParams: unknown[]): void {\n\t    if (this._isDev) {\n\t      console.info(message, ...optionalParams);\n", "    }\n\t  }\n\t  /**\n\t   * Logs an error message to the console.\n\t   * @param {unknown} message The message to log\n\t   * @param {unknown[]} optionalParams Optional parameters to log\n\t   */\n\t  error(message?: unknown, ...optionalParams: unknown[]): void {\n\t    console.error(message, ...optionalParams);\n\t  }\n", "}\n"]}
{"filename": "src/lib/logging/index.ts", "chunked_list": ["export * from './logging-utils';\n\texport * from './dev-console-logger';\n"]}
{"filename": "src/lib/logging/logging-utils.ts", "chunked_list": ["import { performance } from 'perf_hooks';\n\timport type { ILogger } from '../types';\n\timport { replacer } from '../utils';\n\t/**\n\t * Logs a message using the logger for the given resolver type and method.\n\t *\n\t * @param logger The logger to be used\n\t * @param method The logger method to be used (info, log, warn, error, trace)\n\t * @param args The arguments to be passed to the logger method\n\t */\n", "export const logSafely = (logger: ILogger, method: keyof ILogger, ...args: unknown[]): void => {\n\t  if (method !== undefined) {\n\t    const loggingMethod = logger[method];\n\t    if (loggingMethod !== undefined) {\n\t      loggingMethod.bind(logger)(...args);\n\t    }\n\t  }\n\t};\n\t/**\n\t * Calculates and logs the elapsed time using the given startTime for the specified method name.\n", " *\n\t * @param logger The logger to be used\n\t * @param methodName The method that was executed to be logged\n\t * @param startTime The start time of the method execution\n\t */\n\texport const logPerformance = (logger: ILogger, methodName: string, startTime: number): void => {\n\t  const elapsedTime = (performance.now() - startTime).toFixed(2);\n\t  logSafely(\n\t    logger,\n\t    'info',\n", "    // Blue\n\t    `\\x1b[34mExecution time for ${methodName}: ${elapsedTime} milliseconds.\\x1b[0m`,\n\t  );\n\t};\n\t/**\n\t * Logs the beginning of a function execution including arguments.\n\t *\n\t * @param {ILogger} logger The logger to be used\n\t * @param {string} fnName The object that was executed to be logged\n\t * @param {object} fnInput The input to be logged\n", " */\n\texport const logExecutionBegin = (\n\t  logger: ILogger,\n\t  fnName: string,\n\t  fnInput: { toString: () => string },\n\t  ansiCode: string = '36m', // Cyan\n\t): void => {\n\t  logSafely(\n\t    logger,\n\t    'info',\n", "    // Cyan\n\t    `\\u001b[${ansiCode}Starting execution of ${fnName}: ${JSON.stringify(\n\t      fnInput,\n\t      replacer,\n\t      0,\n\t    )}\\u001b[0m`,\n\t  );\n\t};\n\t/**\n\t * Logs the end of a function execution including elapsed time.\n", " *\n\t * @param {ILogger} logger The logger to be used\n\t * @param {string} fnName The object that was executed to be logged\n\t * @param {number} fnStartTime The start time of the method execution\n\t */\n\texport const logExecutionEnd = (\n\t  logger: ILogger,\n\t  fnName: string,\n\t  fnStartTime: number,\n\t  ansiCode: string = '36m', // Cyan\n", "): void => {\n\t  const elapsedTime = (performance.now() - fnStartTime).toFixed(2);\n\t  logSafely(\n\t    logger,\n\t    'info',\n\t    `\\u001b[${ansiCode}Finished executing ${fnName} completed in ${elapsedTime}ms\\u001b[0m`,\n\t  );\n\t};\n"]}
{"filename": "src/lib/executor/database-executor.ts", "chunked_list": ["import { performance } from 'perf_hooks';\n\timport { type ConnectionPool, Request } from 'mssql';\n\timport type { ILogger, IDatabaseExecutor } from '../types';\n\timport { logPerformance } from '../logging';\n\timport { type ConnectionManager } from '../utils';\n\t/**\n\t * @class\n\t * @implements {IDatabaseExecutor}\n\t */\n\texport class DatabaseExecutor implements IDatabaseExecutor {\n", "  constructor(private readonly _connectionManager: ConnectionManager) {}\n\t  /**\n\t   * @inheritdoc\n\t   */\n\t  public async executeQueryRequest<T>(\n\t    requestFn: (request: Request) => Promise<T>,\n\t    logger: ILogger,\n\t  ): Promise<T> {\n\t    return await this.executeRequest(\n\t      this._connectionManager.queryConnectionPool,\n", "      requestFn,\n\t      logger,\n\t    );\n\t  }\n\t  /**\n\t   * @inheritdoc\n\t   */\n\t  public async executeMutationRequest<T>(\n\t    requestFn: (request: Request) => Promise<T>,\n\t    logger: ILogger,\n", "  ): Promise<T> {\n\t    return await this.executeRequest(\n\t      this._connectionManager.mutationConnectionPool,\n\t      requestFn,\n\t      logger,\n\t    );\n\t  }\n\t  /**\n\t   * Executes the given request function with a new Request instance\n\t   * using the appropriate ConnectionPool for the resolver type.\n", "   * This method ensures the ConnectionPool is connected before\n\t   * invoking the request function.\n\t   *\n\t   * @param {Promise<ConnectionPool>} connectionPool The function to be executed to get the ConnectionPool\n\t   * @param {(request: Request): Promise<T>} requestFn The function to be executed with the new Request instance\n\t   * @returns The result of the request function\n\t   */\n\t  private async executeRequest<T>(\n\t    connectionPool: ConnectionPool,\n\t    requestFn: (request: Request) => Promise<T>,\n", "    logger: ILogger,\n\t  ): Promise<T> {\n\t    const startTime = performance.now();\n\t    if (!connectionPool.connected) {\n\t      await connectionPool.connect();\n\t    }\n\t    logPerformance(logger, 'connect', startTime);\n\t    return await requestFn(new Request(connectionPool));\n\t  }\n\t}\n"]}
{"filename": "src/lib/executor/index.ts", "chunked_list": ["export * from './database-executor';\n"]}
{"filename": "src/lib/stored-procedure/stored-procedure-cache-manager.ts", "chunked_list": ["import { InMemoryLRUCache } from '@apollo/utils.keyvaluecache';\n\timport { CacheHelper } from '../utils';\n\t/**\n\t * A class that manages the global cache for stored procedures.\n\t */\n\texport class StoredProcedureCacheManager {\n\t  private static _globalCache: CacheHelper<object>;\n\t  private static get defaultCache(): InMemoryLRUCache<object> {\n\t    return new InMemoryLRUCache<object>({\n\t      // Default TTL is 3600000 ms or 1 hour.\n", "      ttl: 60 * 60 * 1000,\n\t      ttlAutopurge: false,\n\t    });\n\t  }\n\t  private static get globalCache(): CacheHelper<object> {\n\t    if (this._globalCache === undefined) {\n\t      this._globalCache = new CacheHelper(StoredProcedureCacheManager.defaultCache);\n\t    }\n\t    return this._globalCache;\n\t  }\n", "  /**\n\t   * Attempts to retrieve the cached object from the global cache for the given key.\n\t   * @param keyToHash The key to be hashed and used to lookup the cached object\n\t   * @returns The cached object if it exists, otherwise undefined\n\t   */\n\t  public async tryGetFromCache(keyToHash: string): Promise<object | undefined> {\n\t    return await StoredProcedureCacheManager.globalCache.tryGetFromCache(keyToHash);\n\t  }\n\t  /**\n\t   * Caches the given result in the global cache using the given key.\n", "   * @param keyToHash The key to be hashed and used to store the result\n\t   * @param result The result to be cached\n\t   */\n\t  public async addToCache(keyToHash: string, result: object): Promise<void> {\n\t    await StoredProcedureCacheManager.globalCache.addToCache(keyToHash, result);\n\t  }\n\t}\n"]}
{"filename": "src/lib/stored-procedure/stored-procedure-metadata-manager.ts", "chunked_list": ["import { type IResult, type Request } from 'mssql';\n\timport type { StoredProcedureParameter, StoredProcedureSchema, ILogger } from '../types';\n\timport { type DatabaseExecutor } from '../executor';\n\timport { convertSqlValueToJsValue } from '../utils';\n\t/**\n\t * A manager for stored procedure metadata.\n\t * Handles the retrieval and caching of stored procedure metadata.\n\t */\n\texport class StoredProcedureMetadataManager {\n\t  /**\n", "   * Regular expression to extract MSSQL stored procedure names.\n\t   * See https://regex101.com/r/cMsTyT/1 for this regex.\n\t   */\n\t  private static readonly storedProcedureNameRegex =\n\t    /((?:(?:\\[([\\w\\s]+)\\]|(\\w+))\\.)?(?:\\[([\\w\\s]+)\\]|(\\w+))\\.(?:\\[([\\w\\s]+)\\]|(\\w+)))/i;\n\t  /**\n\t   * Matches any comments from the Stored Procedure definition.\n\t   * See https://regex101.com/r/dxA7n0/1 for this regex.\n\t   */\n\t  private static readonly commentRegex = /(?:\\s*-{2}.+\\s*$)|(?:\\/\\*([\\s\\S]*?)\\*\\/)/gm;\n", "  /**\n\t   * Matches the parameters from the Stored Procedure definition.\n\t   * See https://regex101.com/r/4TaTky/1 for this regex.\n\t   */\n\t  private static readonly parameterSectionRegex =\n\t    /(?<=(?:CREATE|ALTER)\\s+PROCEDURE)\\s+((?:(?:\\[([\\w\\s]+)\\]|(\\w+))\\.)?(?:\\[([\\w\\s]+)\\]|(\\w+))\\.(?:\\[([\\w\\s]+)\\]|(\\w+)))(.*?)(?=(?:AS|FOR\\s+REPLICATION)[^\\w])/is;\n\t  /**\n\t   * See https://regex101.com/r/iMEaLb/1 for this regex.\n\t   * Match the individual parameters in the Parameter Definition.\n\t   */\n", "  private static readonly parameterDefinitionRegex = /(@[\\w]+)\\s+([^\\s]+)\\s*=\\s*([^, ]*),?/gi;\n\t  constructor(private readonly _databaseExecutor: DatabaseExecutor) {}\n\t  /**\n\t   * Parses the stored procedure parameter schema into a StoredProcedureParameter array.\n\t   * @param {string} storedProcedureName - The name of the stored procedure to retrieve the parameter schema for.\n\t   * @returns A Promise that resolves to the result of the stored procedure execution.\n\t   */\n\t  public async getStoredProcedureParameterSchema(\n\t    storedProcedureName: string,\n\t    logger: ILogger,\n", "  ): Promise<IResult<StoredProcedureSchema>> {\n\t    return await this._databaseExecutor.executeQueryRequest(async (request: Request) => {\n\t      // Remove square bracket notation if any, and split into schema and name.\n\t      const schemaAndName = storedProcedureName.replace(/\\[|\\]/g, '').split('.');\n\t      const result = await request.query<StoredProcedureSchema>(\n\t        'SELECT ' +\n\t          'PARAMETER_NAME as name, ' +\n\t          'DATA_TYPE as type, ' +\n\t          'PARAMETER_MODE as mode, ' +\n\t          'CHARACTER_MAXIMUM_LENGTH length, ' +\n", "          'NUMERIC_PRECISION as precision, ' +\n\t          'NUMERIC_SCALE as scale ' +\n\t          'FROM INFORMATION_SCHEMA.PARAMETERS ' +\n\t          `WHERE SPECIFIC_SCHEMA = '${schemaAndName[0]}' AND SPECIFIC_NAME = '${schemaAndName[1]}';\n\t            SELECT OBJECT_DEFINITION(OBJECT_ID('${storedProcedureName}')) AS storedProcedureDefinition;`,\n\t      );\n\t      const recordSetLength = result.recordsets.length as number;\n\t      if (recordSetLength < 1 || recordSetLength > 2) {\n\t        throw new Error(\n\t          `Could not retrieve stored procedure parameter schema from Database for stored procedure ${storedProcedureName}.`,\n", "        );\n\t      }\n\t      if (recordSetLength !== 2 || result.recordsets[1].length !== 1) {\n\t        throw new Error(\n\t          `Could not retrieve stored procedure definition from Database for stored procedure ${storedProcedureName}.`,\n\t        );\n\t      }\n\t      return result;\n\t    }, logger);\n\t  }\n", "  /**\n\t   * Parses the stored procedure parameter schema into a StoredProcedureParameter array.\n\t   * @param {string} storedProcedureName - The name of the stored procedure to parse the parameter schema for.\n\t   * @param {IResult<StoredProcedureSchema>} schemaResult - The result of the stored procedure parameter schema query.\n\t   * @returns A StoredProcedureParameter array.\n\t   */\n\t  public parseStoredProcedureParameters(\n\t    storedProcedureName: string,\n\t    schemaResult: IResult<StoredProcedureSchema>,\n\t  ): IterableIterator<StoredProcedureParameter> {\n", "    const parameterSchemaMap: Map<string, StoredProcedureParameter> =\n\t      schemaResult.recordsets[0].reduce(\n\t        (parameterMap: Map<string, StoredProcedureParameter>, item: StoredProcedureParameter) => {\n\t          parameterMap.set(item.name, item);\n\t          return parameterMap;\n\t        },\n\t        new Map<string, StoredProcedureParameter>(),\n\t      );\n\t    const storedProcedureDefinition = schemaResult.recordsets[1][0].storedProcedureDefinition;\n\t    if (storedProcedureDefinition == null) {\n", "      throw new Error(\n\t        `Could not parse stored procedure definition for stored procedure ${storedProcedureName}.`,\n\t      );\n\t    }\n\t    const commentStrippedStoredProcedureDefinition = storedProcedureDefinition.replace(\n\t      StoredProcedureMetadataManager.commentRegex,\n\t      '',\n\t    );\n\t    if (commentStrippedStoredProcedureDefinition === '') {\n\t      throw new Error(\n", "        `Could not parse stored procedure comments from definition for stored procedure ${storedProcedureName}.`,\n\t      );\n\t    }\n\t    const parameterSection = commentStrippedStoredProcedureDefinition.match(\n\t      StoredProcedureMetadataManager.parameterSectionRegex,\n\t    );\n\t    if (parameterSection === null || parameterSection.length !== 9) {\n\t      throw new Error(\n\t        `Could not parse stored procedure parameters from definition for stored procedure ${storedProcedureName}.`,\n\t      );\n", "    }\n\t    const parameterDefinition = parameterSection[8];\n\t    let parameterDefinitionMatch;\n\t    while (\n\t      (parameterDefinitionMatch =\n\t        StoredProcedureMetadataManager.parameterDefinitionRegex.exec(parameterDefinition)) !== null\n\t    ) {\n\t      const name = parameterDefinitionMatch[1];\n\t      const type = parameterDefinitionMatch[2];\n\t      const defaultValue = parameterDefinitionMatch[3];\n", "      const parameter = parameterSchemaMap.get(name);\n\t      if (parameter !== undefined) {\n\t        parameter.defaultValue = convertSqlValueToJsValue(defaultValue, type);\n\t      }\n\t    }\n\t    return parameterSchemaMap.values();\n\t  }\n\t}\n"]}
{"filename": "src/lib/stored-procedure/stored-procedure-manager.ts", "chunked_list": ["import { camelCase } from 'lodash';\n\timport { type Request, type IProcedureResult, type IResult, type IRecordSet } from 'mssql';\n\timport { type GraphQLResolveInfo } from 'graphql';\n\timport {\n\t  type DriverType,\n\t  type PreparedStoredProcedureParameter,\n\t  ParameterMode,\n\t  type StoredProcedureSchema,\n\t  type StoredProcedureParameter,\n\t  type ILogger,\n", "  type InputParameters,\n\t} from '../types';\n\timport { mapDbTypeToDriverType, replacer } from '../utils';\n\timport { logExecutionBegin, logPerformance, logSafely } from '../logging';\n\timport {\n\t  type StoredProcedureCacheManager,\n\t  type StoredProcedureMetadataManager,\n\t} from '../stored-procedure';\n\timport { type IResolverProcedureResult } from '../types/i-resolver-procedure-result';\n\timport { getNodeSelectionSetNames, getFieldNamesExcludingNode } from '../utils/graphql-helper';\n", "/**\n\t * StoredProcedureManager provides methods to interact\n\t * with a Microsoft SQL Server database for managing stored procedures.\n\t */\n\texport class StoredProcedureManager {\n\t  /**\n\t   * Creates a new instance of StoredProcedureManager.\n\t   */\n\t  constructor(\n\t    private readonly _storedProcedureCacheManager: StoredProcedureCacheManager,\n", "    private readonly _storedProcedureMetadataManager: StoredProcedureMetadataManager,\n\t  ) {}\n\t  /**\n\t   * Executes a stored procedure with the provided input parameters, and returns the result.\n\t   * @template TVal - The type of records in the result set.\n\t   * @template TRet - The type of the result object to be returned.\n\t   * @param {string} storedProcedureName - The name of the stored procedure to execute.\n\t   * @param {StoredProcedureInput} input - The input parameters for the stored procedure.\n\t   * @param {Request} request - The request to execute the stored procedure.\n\t   * @param {GraphQLResolveInfo | undefined} info - If provided, will be used to case-insensitively map the stored\n", "   * procedure results to the correct schema field names.\n\t   * @param {ILogger} logger - The logger to use for logging.\n\t   * @returns A Promise that resolves to the result of the stored procedure execution.\n\t   */\n\t  public async executeStoredProcedure<T>(\n\t    storedProcedureName: string,\n\t    input: InputParameters,\n\t    request: Request,\n\t    logger: ILogger,\n\t    info?: GraphQLResolveInfo,\n", "  ): Promise<IResolverProcedureResult<T>> {\n\t    let startTime = performance.now();\n\t    let schema = (await this._storedProcedureCacheManager.tryGetFromCache(storedProcedureName)) as\n\t      | IResult<StoredProcedureSchema>\n\t      | undefined;\n\t    if (schema === undefined) {\n\t      logSafely(\n\t        logger,\n\t        'info',\n\t        // Yellow\n", "        `\\x1b[33mCache miss occurred while retrieving the cached schema for ${storedProcedureName}\\x1b[0m`,\n\t      );\n\t      schema = await this._storedProcedureMetadataManager.getStoredProcedureParameterSchema(\n\t        storedProcedureName,\n\t        logger,\n\t      );\n\t      await this._storedProcedureCacheManager.addToCache(storedProcedureName, schema);\n\t    } else {\n\t      logSafely(\n\t        logger,\n", "        'info',\n\t        // Green\n\t        `\\x1b[32mCache hit occurred while retrieving the cached schema for ${storedProcedureName}\\x1b[0m`,\n\t      );\n\t    }\n\t    logPerformance(logger, 'getStoredProcedureParameterSchema', startTime);\n\t    startTime = performance.now();\n\t    const storedProcedureParameters =\n\t      this._storedProcedureMetadataManager.parseStoredProcedureParameters(\n\t        storedProcedureName,\n", "        schema,\n\t      );\n\t    logPerformance(logger, 'parseStoredProcedureParameters', startTime);\n\t    startTime = performance.now();\n\t    const preparedRequest = this.prepareStoredProcedureRequest(\n\t      storedProcedureParameters,\n\t      input,\n\t      request,\n\t    );\n\t    logPerformance(logger, 'prepareStoredProcedureRequest', startTime);\n", "    startTime = performance.now();\n\t    logExecutionBegin(\n\t      logger,\n\t      `Stored Procedure ${storedProcedureName} with parameters`,\n\t      preparedRequest.parameters,\n\t      // Green\n\t      '32m',\n\t    );\n\t    const result = await preparedRequest.execute(storedProcedureName);\n\t    startTime = performance.now();\n", "    const preparedResult = this.prepareStoredProcedureResult(result, info);\n\t    logPerformance(logger, 'prepareStoredProcedureResult', startTime);\n\t    return preparedResult;\n\t  }\n\t  private prepareParameters(\n\t    storedProcedureParameters: IterableIterator<StoredProcedureParameter>,\n\t    input: InputParameters,\n\t  ): Map<string, PreparedStoredProcedureParameter> {\n\t    // We want to use the inferred DB Stored Procedure schema as the source of truth.\n\t    const preparedParameters = new Map<string, PreparedStoredProcedureParameter>();\n", "    for (const spParameter of storedProcedureParameters) {\n\t      const { name, type, length, precision, scale, ...rest } = spParameter;\n\t      const parameterName = name.slice(1);\n\t      // Let's use the parameter name in lowercase as the lookup key.\n\t      preparedParameters.set(parameterName.toLowerCase(), {\n\t        name: parameterName,\n\t        type: mapDbTypeToDriverType({\n\t          type,\n\t          length,\n\t          precision,\n", "          scale,\n\t        }) as DriverType,\n\t        value: undefined,\n\t        ...rest,\n\t      });\n\t    }\n\t    // Populate our input values into the request parameters.\n\t    const inputParameters = input as Record<string, unknown>;\n\t    for (const inputParameterKey in inputParameters) {\n\t      const preparedParameter = preparedParameters.get(inputParameterKey.toLowerCase());\n", "      if (preparedParameter != null) {\n\t        preparedParameter.value = inputParameters[inputParameterKey];\n\t      }\n\t      // We don't care about provided input parameters that are missing in the Stored Procedure definition.\n\t    }\n\t    return preparedParameters;\n\t  }\n\t  private getMissingRequiredParameters(\n\t    parameters: Map<string, PreparedStoredProcedureParameter>,\n\t  ): PreparedStoredProcedureParameter[] {\n", "    // Check what required parameters are missing.\n\t    const missingRequiredParameters = [];\n\t    for (const parameter of parameters.values()) {\n\t      // If they have a default value they can be ommitted from the request.\n\t      if (parameter.defaultValue === undefined && parameter.value === undefined) {\n\t        missingRequiredParameters.push(parameter);\n\t      }\n\t    }\n\t    return missingRequiredParameters;\n\t  }\n", "  private addParametersToRequest(\n\t    parameters: Map<string, PreparedStoredProcedureParameter>,\n\t    request: Request,\n\t  ): Request {\n\t    const preparedRequest = request;\n\t    for (const parameter of parameters.values()) {\n\t      const { name, type, mode, value, defaultValue } = parameter;\n\t      if (defaultValue !== undefined && value === undefined) {\n\t        continue;\n\t      }\n", "      const modeEnum = mode;\n\t      if (modeEnum === ParameterMode.IN) {\n\t        preparedRequest.input(name, type, value);\n\t      } else if (modeEnum === ParameterMode.INOUT) {\n\t        preparedRequest.output(name, type, value);\n\t      } else {\n\t        throw new Error(`Unknown parameter mode: ${mode}`);\n\t      }\n\t    }\n\t    return preparedRequest;\n", "  }\n\t  /**\n\t   * Prepares the stored procedure request.\n\t   * @param {IterableIterator<StoredProcedureParameter>} storedProcedureParameters - The stored procedure parameters.\n\t   * @param {StoredProcedureInput} input - The input object.\n\t   * @param {Request} request - The request object.\n\t   * @returns A prepared request object.\n\t   */\n\t  private prepareStoredProcedureRequest(\n\t    storedProcedureParameters: IterableIterator<StoredProcedureParameter>,\n", "    input: InputParameters,\n\t    request: Request,\n\t  ): Request {\n\t    const parameters = this.prepareParameters(storedProcedureParameters, input);\n\t    const missingRequiredParameters = this.getMissingRequiredParameters(parameters);\n\t    const missingLength = missingRequiredParameters.length;\n\t    if (missingLength > 0) {\n\t      throw new Error(\n\t        `Missing ${missingLength} required parameters: ${missingRequiredParameters\n\t          .map((param) => JSON.stringify(param, replacer, 0))\n", "          .join(', ')}.`,\n\t      );\n\t    }\n\t    const preparedRequest = this.addParametersToRequest(parameters, request);\n\t    return preparedRequest;\n\t  }\n\t  /**\n\t   * Maps the keys of an object based on the provided mapping.\n\t   * @template T - The type of the original object.\n\t   * @param {T} obj - The object whose keys need to be mapped.\n", "   * @param {Record<string, string>} mapping - A dictionary containing the mapping of the original keys to the new keys.\n\t   * @returns {T} A new object with the keys mapped according to the provided mapping.\n\t   */\n\t  private mapKeysWithMapping<T extends Record<string, unknown>>(\n\t    obj: T,\n\t    mapping: Record<string, string>,\n\t  ): T {\n\t    const result: Record<string, unknown> = {};\n\t    for (const key in obj) {\n\t      const mappedKey = mapping[key.toLowerCase()] ?? camelCase(key);\n", "      result[mappedKey] = obj[key];\n\t    }\n\t    return result as T;\n\t  }\n\t  /**\n\t   * Prepares the stored procedure result into a GraphQL result object.\n\t   * @param {IProcedureResult} result - The stored procedure result.\n\t   * @param {GraphQLResolveInfo | undefined} info - If provided, will be used to case-insensitively map the stored\n\t   * procedure results to the correct schema field names.\n\t   * @returns {IResolverProcedureResult} A prepared GraphQL result object.\n", "   */\n\t  private prepareStoredProcedureResult<T extends Record<string, unknown>>(\n\t    result: IProcedureResult<T>,\n\t    info?: GraphQLResolveInfo,\n\t  ): IResolverProcedureResult<T> {\n\t    const { resultSetFields, outputFields } =\n\t      info !== undefined\n\t        ? {\n\t            resultSetFields: getNodeSelectionSetNames(info, 'resultSets'),\n\t            outputFields: getFieldNamesExcludingNode(info, 'resultSets'),\n", "          }\n\t        : { resultSetFields: {}, outputFields: {} };\n\t    const resultSets = result.recordsets.map((recordset: IRecordSet<Record<string, unknown>>) => {\n\t      return recordset.map((record: Record<string, unknown>) =>\n\t        this.mapKeysWithMapping(record, resultSetFields),\n\t      );\n\t    });\n\t    const output = this.mapKeysWithMapping(result.output, outputFields);\n\t    const preparedResult = {\n\t      returnValue: result.returnValue,\n", "      resultSets: resultSets as T[][],\n\t      rowsAffected: result.rowsAffected,\n\t      ...output,\n\t    };\n\t    return preparedResult;\n\t  }\n\t}\n"]}
{"filename": "src/lib/stored-procedure/index.ts", "chunked_list": ["export * from './stored-procedure-cache-manager';\n\texport * from './stored-procedure-manager';\n\texport * from './stored-procedure-metadata-manager';\n"]}
{"filename": "src/lib/types/i-stored-procedure-parameter.ts", "chunked_list": ["import type { ParameterMode } from '.';\n\t/**\n\t * Represents a subset of used metadata for an MSSQL stored procedure parameter.\n\t * @property {string} name - The name of the parameter. Begins with @.\n\t * @property {string} type - The MSSQL data type of the parameter.\n\t * @property {ParameterMode} mode - The MSSQL mode of the parameter. Either 'IN', 'INOUT' or 'UNKNOWN'.\n\t * @property {unknown} defaultValue - The default value of the parameter, if any, or undefined.\n\t * @property {number} length - The length of character-based parameters, or undefined.\n\t * @property {number} precision - The precision of floating point parameters, or undefined.\n\t * @property {number} scale - The scale of floating point parameters, or undefined.\n", " */\n\texport interface StoredProcedureParameter {\n\t  name: string;\n\t  type: string;\n\t  mode: ParameterMode;\n\t  defaultValue?: unknown;\n\t  length?: number;\n\t  precision?: number;\n\t  scale?: number;\n\t}\n"]}
{"filename": "src/lib/types/i-resolver-procedure-result.ts", "chunked_list": ["/**\n\t * Represents a GraphQL resolver stored procedure result.\n\t * The format of the result is: a single resultSet property, followed by\n\t * any additional output properties that were returned by the stored procedure.\n\t */\n\texport interface IResolverProcedureResult<T> extends Record<string, unknown> {\n\t  returnValue?: number;\n\t  resultSets?: T[][];\n\t  rowsAffected?: number[];\n\t}\n"]}
{"filename": "src/lib/types/prepared-stored-procedure-parameter.ts", "chunked_list": ["import type { StoredProcedureParameter, DriverType } from '.';\n\t/**\n\t * Final parameters that will be passed to the stored procedure request.\n\t */\n\texport type PreparedStoredProcedureParameter = Omit<StoredProcedureParameter, 'type'> & {\n\t  type: DriverType;\n\t  value?: unknown;\n\t};\n"]}
{"filename": "src/lib/types/input-parameters.ts", "chunked_list": ["/**\n\t * Input parameters that will be prepared and passed to the stored procedure request.\n\t */\n\t// export interface InputParameter extends Record<string, unknown> {}\n\texport type InputParameters = Record<string, unknown>;\n"]}
{"filename": "src/lib/types/mssql-config.ts", "chunked_list": ["import type { config } from 'mssql';\n\t/**\n\t * Represents a configuration object for a MSSQL database.\n\t * Can be an mssql config or Connection String.\n\t */\n\texport type MSSQLConfig = config | string;\n"]}
{"filename": "src/lib/types/driver-type.ts", "chunked_list": ["import type { ISqlType } from 'mssql';\n\t/**\n\t * Driver types that can be used to specify the type of a stored procedure parameter.\n\t */\n\texport type DriverType = (() => ISqlType) | ISqlType;\n"]}
{"filename": "src/lib/types/i-logger.ts", "chunked_list": ["import type { info } from 'console';\n\t/**\n\t * A logger that can be used to log messages with different\n\t * levels of severity for the MSSQLDataSource.\n\t * @property {Function} [info] - Logs an informational message\n\t * @property {Function} [log] - Logs a debug message\n\t * @property {Function} [warn] - Logs a warning message\n\t * @property {Function} [error] - Logs an error message\n\t * @property {Function} [trace] - Logs a stack trace\n\t * @property {Function} [performance] - Logs performance information\n", " */\n\texport interface ILogger {\n\t  info?: typeof console.info;\n\t  log?: typeof console.log;\n\t  warn?: typeof console.warn;\n\t  error?: typeof console.error;\n\t  trace?: typeof console.trace;\n\t  performance?: typeof info;\n\t}\n"]}
{"filename": "src/lib/types/stored-procedure-schema.ts", "chunked_list": ["import type { StoredProcedureParameter } from '.';\n\t/**\n\t * Represents the result of a stored procedure execution.\n\t */\n\texport type StoredProcedureSchema = [\n\t  StoredProcedureParameter,\n\t  {\n\t    storedProcedureDefinition: string;\n\t  },\n\t];\n"]}
{"filename": "src/lib/types/i-mssql-options.ts", "chunked_list": ["import type { MSSQLConfig, ILogger } from '.';\n\t/**\n\t * The options for configuring the MSSQLDataSource.\n\t * @property {MSSQLConfig} config - The configuration for the MSSQL connection\n\t * @property {Logger} [logger] - Optional custom logger\n\t */\n\texport interface MSSQLOptions {\n\t  config: MSSQLConfig;\n\t  logger?: ILogger;\n\t}\n"]}
{"filename": "src/lib/types/index.ts", "chunked_list": ["export * from './driver-type';\n\texport * from './i-database-executor';\n\texport * from './i-logger';\n\texport * from './i-mssql-options';\n\texport * from './i-resolver-procedure-result';\n\texport * from './i-stored-procedure-parameter';\n\texport * from './input-parameters';\n\texport * from './mssql-config';\n\texport * from './parameter-mode';\n\texport * from './prepared-stored-procedure-parameter';\n", "export * from './stored-procedure-schema';\n"]}
{"filename": "src/lib/types/i-database-executor.ts", "chunked_list": ["import type { Request } from 'mssql';\n\timport type { ILogger } from '.';\n\texport interface IDatabaseExecutor {\n\t  /**\n\t   * Executes the given request function for a query operation\n\t   * with a new Request instance using the appropriate ConnectionPool.\n\t   *\n\t   * @param {(request: Request) => Promise<T>} requestFn The function to be executed with the new Request instance\n\t   * @param {ILogger} logger The logger to use for logging\n\t   * @returns The result of the Query request function\n", "   */\n\t  executeQueryRequest: <T>(\n\t    requestFn: (request: Request) => Promise<T>,\n\t    logger: ILogger,\n\t  ) => Promise<T>;\n\t  /**\n\t   * Executes the given request function for a mutation operation\n\t   * with a new Request instance using the appropriate ConnectionPool.\n\t   *\n\t   * @param {(request: Request) => Promise<T>} requestFn The function to be executed with the new Request instance\n", "   * @param {ILogger} logger The logger to use for logging\n\t   * @returns The result of the Mutation request function\n\t   */\n\t  executeMutationRequest: <T>(\n\t    requestFn: (request: Request) => Promise<T>,\n\t    logger: ILogger,\n\t  ) => Promise<T>;\n\t}\n"]}
{"filename": "src/lib/types/parameter-mode.ts", "chunked_list": ["/**\n\t * In Microsoft SQL Server, parameters are either input/IN parameters\n\t * (by default, when no keyword is specified) or input-output/INOUT (using the OUTPUT keyword).\n\t * Unknown parameter modes are not supported.\n\t * @enum IN - Represents an input parameter\n\t * @enum INOUT - Represents an input-output parameter\n\t * @enum UNKNOWN - Represents an unknown parameter\n\t */\n\texport enum ParameterMode {\n\t  IN = 'IN',\n", "  OUT = 'OUT',\n\t  INOUT = 'INOUT',\n\t}\n"]}
