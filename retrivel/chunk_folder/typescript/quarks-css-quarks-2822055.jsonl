{"filename": "src/createStylesFromProps.ts", "chunked_list": ["import PROP_PREFIX from './constants/prefix';\n\timport { validateProp } from './setup';\n\timport media from './theme/breakpoints';\n\timport { customOverwrites } from './theme/customOverwrites';\n\timport { camelToKebabCase } from './utils/functions';\n\timport { isCustomOverwrite, isMediaQuery, isPseudo, isPseudoElement } from './utils/propChecks';\n\timport { objectEntries } from './utils/typeUtils';\n\timport type { CSSAttribute } from 'goober';\n\tconst createStylesFromProps = (props: Record<string, unknown>): CSSAttribute =>\n\t  objectEntries(props).reduce((prevValue, prop) => {\n", "    const [propName, value] = prop;\n\t    // checks if prop is for styling\n\t    if (typeof propName !== 'string' || !validateProp(propName)) {\n\t      return prevValue;\n\t    }\n\t    const key = camelToKebabCase(propName.replace(PROP_PREFIX, ''));\n\t    // checks if prop is something from customOverwrites\n\t    if (isCustomOverwrite(prop)) {\n\t      const [overwriteKey, overwriteValue] = prop;\n\t      const themeValue = customOverwrites[overwriteKey](overwriteValue);\n", "      return {\n\t        ...prevValue,\n\t        [key]: themeValue,\n\t      };\n\t    }\n\t    // checks if prop is a media query\n\t    if (isMediaQuery(prop)) {\n\t      const [mediaKey, mediaValue] = prop;\n\t      return {\n\t        ...prevValue,\n", "        [media[mediaKey]]: createStylesFromProps(mediaValue),\n\t      };\n\t    }\n\t    // checks if prop is pseudo-class or pseudo-element\n\t    if (isPseudo(value)) {\n\t      const extraColon = isPseudoElement(propName) ? ':' : '';\n\t      return {\n\t        ...prevValue,\n\t        [`&:${extraColon}${key}`]: createStylesFromProps(value),\n\t      };\n", "    }\n\t    return {\n\t      ...prevValue,\n\t      [key]: value,\n\t    };\n\t  }, {});\n\texport default createStylesFromProps;\n"]}
{"filename": "src/quark.ts", "chunked_list": ["import { styled } from 'goober';\n\timport createStylesFromProps from './createStylesFromProps';\n\timport type { QuarkProps } from './types/quarkProps';\n\t// TODO: Remove type assertion on `props` by solving \"Index signature for type 'string' is missing in type\" from SVGProps\n\tconst quark = <T extends keyof JSX.IntrinsicElements>(tag: T) =>\n\t  styled<QuarkProps<T>>(tag)(props => createStylesFromProps(props as Record<string, unknown>));\n\texport default quark;\n"]}
{"filename": "src/setup.ts", "chunked_list": ["import { setup } from 'goober';\n\timport { prefix } from 'goober/prefixer';\n\timport { shouldForwardProp } from 'goober/should-forward-prop';\n\timport { createElement } from 'react';\n\timport PROP_PREFIX from './constants/prefix';\n\timport useTheme from './theme';\n\timport type { StyleProps } from './types/quarkProps';\n\texport const validateProp = (string: string): string is keyof StyleProps =>\n\t  typeof string === 'string' && string.startsWith(PROP_PREFIX);\n\tconst setupQuarks = () =>\n", "  setup(\n\t    createElement,\n\t    prefix,\n\t    useTheme,\n\t    shouldForwardProp(prop => !validateProp(prop)),\n\t  );\n\texport default setupQuarks;\n"]}
{"filename": "src/index.ts", "chunked_list": ["import quark from './quark';\n\timport setupQuarks from './setup';\n\texport { setupQuarks as setup };\n\texport default quark;\n"]}
{"filename": "src/utils/propChecks.ts", "chunked_list": ["import { prefixedPseudoElements } from '../constants/pseudoElements';\n\timport media from '../theme/breakpoints';\n\timport { customOverwrites } from '../theme/customOverwrites';\n\timport type { valueof } from './typeUtils';\n\ttype customOverWriteValues = Parameters<valueof<typeof customOverwrites>>[number];\n\texport const isCustomOverwrite = (\n\t  prop: [string, unknown],\n\t): prop is [keyof typeof customOverwrites, customOverWriteValues] => prop[0] in customOverwrites;\n\texport const isMediaQuery = (prop: [string, unknown]): prop is [keyof typeof media, Record<string, unknown>] =>\n\t  prop[0] in media;\n", "export const isPseudo = (value: unknown): value is Record<string, unknown> => typeof value === 'object';\n\texport const isPseudoElement = (propName: string) => prefixedPseudoElements.includes(propName);\n"]}
{"filename": "src/utils/typeUtils.ts", "chunked_list": ["export type valueof<T> = T[keyof T];\n\texport type OverwriteProperties<T, R> = Omit<T, keyof R> & R;\n\texport type Prefix<T, Pre extends string> = {\n\t  [P in keyof T & string as `${Pre}${P}`]?: T[P];\n\t};\n\texport type Replace<\n\t  T extends string,\n\t  SearchVal extends string,\n\t  ReplaceVal extends string,\n\t  A extends string = '',\n", "> = T extends `${infer L}${SearchVal}${infer R}`\n\t  ? Replace<R, SearchVal, ReplaceVal, `${A}${L}${ReplaceVal}`>\n\t  : `${A}${T}`;\n\ttype ObjectEntriesReturn<T> = [keyof T, valueof<T>][];\n\ttype ObjectEntries = <T extends object>(object: T) => ObjectEntriesReturn<T>;\n\ttype ObjectKeys = <T extends object>(object: T) => (keyof T)[];\n\texport const objectEntries: ObjectEntries = object => Object.entries(object) as ObjectEntriesReturn<typeof object>;\n\texport const objectKeys: ObjectKeys = object => Object.keys(object) as (keyof typeof object)[];\n\texport const hasOwnProperty = <P extends string>(object: Readonly<Record<P, unknown>>, key: string): key is P =>\n\t  key in object;\n"]}
{"filename": "src/utils/functions.ts", "chunked_list": ["export const stringToKebabCase = (id: string) =>\n\t  id\n\t    .toLowerCase()\n\t    .replace(/[^A-Za-z0-9 ]/g, '')\n\t    .trim()\n\t    .replace(/\\s+/g, '-');\n\texport const toCamelCase = (string?: string | null) =>\n\t  string\n\t    ? string\n\t        .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => (index === 0 ? word.toLowerCase() : word.toUpperCase()))\n", "        .replace(/\\s+/g, '')\n\t    : '';\n\ttype CamelToKebabCase<T extends string, A extends string> = T extends `${infer F}${infer R}`\n\t  ? CamelToKebabCase<R, `${A}${F extends Lowercase<F> ? '' : '-'}${Lowercase<F>}`>\n\t  : A;\n\texport const camelToKebabCase = <T extends string>(string: T) =>\n\t  string.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase()) as CamelToKebabCase<\n\t    T,\n\t    string\n\t  >;\n"]}
{"filename": "src/utils/flattenObject.ts", "chunked_list": ["// see @https://stackoverflow.com/questions/69843406/flattening-a-nested-object-in-typescript-whilst-preserving-types#comment123459995_69843406\n\ttype FlattenObjectReturn<T extends object> = object extends T\n\t  ? object\n\t  : {\n\t      [K in keyof T]-?: (\n\t        x: NonNullable<T[K]> extends infer V\n\t          ? V extends object\n\t            ? V extends readonly any[]\n\t              ? Pick<T, K>\n\t              : FlattenObjectReturn<V> extends infer FV\n", "              ? {\n\t                  [P in keyof FV as `${Extract<K, string | number>}-${Extract<P, string | number>}`]: FV[P];\n\t                }\n\t              : never\n\t            : Pick<T, K>\n\t          : never,\n\t      ) => void;\n\t    } extends Record<keyof T, (y: infer O) => void>\n\t  ? O extends infer _U\n\t    ? { [K in keyof O]: O[K] }\n", "    : never\n\t  : never;\n\tconst flattenObject = <T extends object>(obj: T, parentKey?: string): FlattenObjectReturn<T> => {\n\t  const result = Object.entries(obj).reduce<FlattenObjectReturn<T>>((prevValue, [key, value]) => {\n\t    const newKey = parentKey ? (`${parentKey}-${String(key)}` as const) : key;\n\t    if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n\t      return { ...prevValue, ...flattenObject(value, String(newKey)) };\n\t    }\n\t    return { ...prevValue, [newKey]: value };\n\t  }, {} as FlattenObjectReturn<T>);\n", "  return result;\n\t};\n\texport default flattenObject;\n"]}
{"filename": "src/constants/pseudoElements.ts", "chunked_list": ["import PROP_PREFIX from './prefix';\n\t// part and slotted not currently supported by quarks\n\tconst PSEUDO_ELEMENTS = [\n\t  // '::part()',\n\t  // '::slotted()',\n\t  '::after',\n\t  '::backdrop',\n\t  '::before',\n\t  '::cue',\n\t  '::cue-region',\n", "  '::first-letter',\n\t  '::first-line',\n\t  '::file-selector-button',\n\t  '::grammar-error',\n\t  '::marker',\n\t  '::placeholder',\n\t  '::selection',\n\t  '::spelling-error',\n\t  '::target-text',\n\t  '::-moz-placeholder',\n", "  '::-moz-progress-bar',\n\t  '::-moz-range-progress',\n\t  '::-moz-range-thumb',\n\t  '::-moz-range-track',\n\t  '::-moz-selection',\n\t  '::-ms-backdrop',\n\t  '::-ms-browse',\n\t  '::-ms-check',\n\t  '::-ms-clear',\n\t  '::-ms-expand',\n", "  '::-ms-fill',\n\t  '::-ms-fill-lower',\n\t  '::-ms-fill-upper',\n\t  '::-ms-input-placeholder',\n\t  '::-ms-reveal',\n\t  '::-ms-thumb',\n\t  '::-ms-ticks-after',\n\t  '::-ms-ticks-before',\n\t  '::-ms-tooltip',\n\t  '::-ms-track',\n", "  '::-ms-value',\n\t  '::-webkit-backdrop',\n\t  '::-webkit-input-placeholder',\n\t  '::-webkit-progress-bar',\n\t  '::-webkit-progress-inner-value',\n\t  '::-webkit-progress-value',\n\t  '::-webkit-slider-runnable-track',\n\t  '::-webkit-slider-thumb',\n\t];\n\texport const prefixedPseudoElements = PSEUDO_ELEMENTS.map(pseudoEle => pseudoEle.replace('::', PROP_PREFIX));\n", "export default PSEUDO_ELEMENTS;\n"]}
{"filename": "src/constants/prefix.ts", "chunked_list": ["const PROP_PREFIX = '$';\n\texport type PropPrefix = typeof PROP_PREFIX;\n\texport default PROP_PREFIX;\n"]}
{"filename": "src/theme/customOverwrites.ts", "chunked_list": ["import flattenObject from '../utils/flattenObject';\n\timport COLORS from './color';\n\tconst flattenedColors = flattenObject(COLORS);\n\texport const customOverwrites = {\n\t  $backgroundColor: (value: keyof typeof flattenedColors) => flattenedColors[value],\n\t  $color: (value: keyof typeof flattenedColors) => flattenedColors[value],\n\t};\n\ttype GetOverwriteValues<T> = {\n\t  [P in keyof T]?: T[P] extends (...args: any) => string ? Parameters<T[P]>[0] : never;\n\t};\n", "export type OverwriteValues = GetOverwriteValues<typeof customOverwrites>;\n"]}
{"filename": "src/theme/color.ts", "chunked_list": ["const COLORS = {\n\t  common: { white: '#ffffff', black: '#000000', transparent: 'transparent' },\n\t  primary: {\n\t    25: '#F2F9FF',\n\t    50: '#E3F2FF',\n\t    100: '#BCDDFF',\n\t    200: '#90C9FF',\n\t    300: '#62B4FF',\n\t    400: '#40A3FF',\n\t    500: '#2493FF',\n", "    600: '#2885F6',\n\t    700: '#2972E2',\n\t    800: '#2961CF',\n\t    900: '#2740B0',\n\t  },\n\t} as const;\n\texport default COLORS;\n"]}
{"filename": "src/theme/index.ts", "chunked_list": ["import { createContext, useContext } from 'react';\n\tconst theme = {};\n\tconst ThemeContext = createContext(theme);\n\tconst useTheme = () => useContext(ThemeContext);\n\texport default useTheme;\n"]}
{"filename": "src/theme/breakpoints.ts", "chunked_list": ["import { objectEntries } from '../utils/typeUtils';\n\tconst DEFAULT_BREAKPOINTS = {\n\t  xs: '375px',\n\t  sm: '576px',\n\t  md: '768px',\n\t  lg: '992px',\n\t  xl: '1280px',\n\t} as const;\n\ttype CreateMedia<T extends typeof DEFAULT_BREAKPOINTS> = {\n\t  [P in keyof T & string as `$${P}`]: T[P] extends string ? `@media screen and (min-width: ${T[P]})` : never;\n", "};\n\ttype Media = CreateMedia<typeof DEFAULT_BREAKPOINTS>;\n\tconst media = objectEntries(DEFAULT_BREAKPOINTS).reduce(\n\t  (prevValue, [breakpointKey, breakpointValue]) => ({\n\t    ...prevValue,\n\t    [`$${breakpointKey}`]: `@media screen and (min-width: ${breakpointValue})`,\n\t  }),\n\t  {} as Media,\n\t);\n\texport default media;\n"]}
{"filename": "src/types/quarkProps.ts", "chunked_list": ["import type { PseudoClassProps, PseudoElementProps } from './pseudos';\n\timport type media from '../theme/breakpoints';\n\timport type { OverwriteValues } from '../theme/customOverwrites';\n\timport type { OverwriteProperties, Prefix } from '../utils/typeUtils';\n\timport type { Properties } from 'csstype';\n\timport type { DefaultTheme, Theme } from 'goober';\n\ttype PrefixedProperties = Prefix<Properties, '$'>;\n\ttype DirectStyleProps = OverwriteProperties<PrefixedProperties, OverwriteValues>;\n\texport type StyleProps = DirectStyleProps & {\n\t  [P in keyof typeof media]?: StyleProps;\n", "} & {\n\t  [P in PseudoClassProps]?: StyleProps;\n\t} & {\n\t  [P in PseudoElementProps]?: StyleProps;\n\t};\n\texport type QuarkProps<T extends keyof JSX.IntrinsicElements> = StyleProps &\n\t  JSX.LibraryManagedAttributes<T, JSX.IntrinsicElements[T]> &\n\t  Theme<DefaultTheme>;\n"]}
{"filename": "src/types/pseudos.ts", "chunked_list": ["import type { PropPrefix } from '../constants/prefix';\n\timport type { Replace } from '../utils/typeUtils';\n\timport type { Pseudos } from 'csstype';\n\ttype FilterPseudoTypes<T extends string, U extends string> = T extends `${U}${string}` ? T : never;\n\ttype PseudoElements = FilterPseudoTypes<Pseudos, '::'>;\n\ttype PseudoClasses = Exclude<Pseudos, PseudoElements>;\n\texport type PseudoClassProps = Replace<PseudoClasses, ':', PropPrefix>;\n\texport type PseudoElementProps = Exclude<Replace<PseudoElements, '::', PropPrefix>, '$slotted' | '$part'>;\n"]}
