{"filename": "@types/@github/markdownlint-github/index.d.ts", "chunked_list": ["import {Configuration, Rule} from \"markdownlint\";\n\tdeclare const main: Rule[] & {\n\t  init(overrides: Configuration): Configuration;\n\t};\n\texport default main;\n"]}
{"filename": "src/content-script.ts", "chunked_list": ["import {\n\t  LintedMarkdownCodeMirrorEditor,\n\t  LintedMarkdownTextareaEditor,\n\t} from \"./components/linted-markdown-editor\";\n\timport {observeSelector} from \"./utilities/dom/observe-selector\";\n\tconst rootPortal = document.createElement(\"div\");\n\trootPortal.style.zIndex = \"999\";\n\trootPortal.style.position = \"absolute\";\n\trootPortal.style.top = \"0\";\n\trootPortal.style.left = \"0\";\n", "document.body.appendChild(rootPortal);\n\tobserveSelector(\n\t  \"textarea.js-paste-markdown, textarea.CommentBox-input, textarea[aria-label='Markdown value']\",\n\t  (editor) => {\n\t    if (!(editor instanceof HTMLTextAreaElement)) return () => {};\n\t    const lintedEditor = new LintedMarkdownTextareaEditor(editor, rootPortal);\n\t    return () => lintedEditor.disconnect();\n\t  }\n\t);\n\tobserveSelector(\n", "  \"file-attachment.js-upload-markdown-image .CodeMirror-code[contenteditable]\",\n\t  (editor) => {\n\t    const lintedEditor = new LintedMarkdownCodeMirrorEditor(editor, rootPortal);\n\t    return () => lintedEditor.disconnect();\n\t  }\n\t);\n"]}
{"filename": "src/components/lint-error-annotation.ts", "chunked_list": ["import {LintedMarkdownEditor} from \"./linted-markdown-editor\";\n\timport {Rect} from \"../utilities/geometry/rect\";\n\timport {Vector} from \"../utilities/geometry/vector\";\n\timport {getWindowScrollVector, isHighContrastMode} from \"../utilities/dom\";\n\timport {NumberRange} from \"../utilities/geometry/number-range\";\n\timport {Component} from \"./component\";\n\timport {LintError} from \"../utilities/lint-markdown\";\n\texport class LintErrorAnnotation extends Component {\n\t  readonly lineNumber: number;\n\t  readonly #container: HTMLElement = document.createElement(\"div\");\n", "  readonly #editor: LintedMarkdownEditor;\n\t  #elements: readonly HTMLElement[] = [];\n\t  readonly #indexRange: NumberRange;\n\t  constructor(\n\t    readonly error: LintError,\n\t    editor: LintedMarkdownEditor,\n\t    portal: HTMLElement\n\t  ) {\n\t    super();\n\t    this.#editor = editor;\n", "    this.lineNumber = error.lineNumber;\n\t    portal.appendChild(this.#container);\n\t    const markdown = editor.value;\n\t    const [line = \"\", ...prevLines] = markdown\n\t      .split(\"\\n\")\n\t      .slice(0, this.lineNumber)\n\t      .reverse();\n\t    const startCol = (error.errorRange?.[0] ?? 1) - 1;\n\t    const length = error.errorRange?.[1] ?? line.length - startCol;\n\t    const startIndex = prevLines.reduce(\n", "      (t, l) => t + l.length + 1 /* +1 for newline char */,\n\t      startCol\n\t    );\n\t    const endIndex = startIndex + length;\n\t    this.#indexRange = new NumberRange(startIndex, endIndex);\n\t    this.recalculatePosition();\n\t  }\n\t  disconnect() {\n\t    super.disconnect();\n\t    this.#container.remove();\n", "  }\n\t  getTooltipPosition() {\n\t    const domRect = this.#elements.at(-1)?.getBoundingClientRect();\n\t    if (domRect)\n\t      return new Rect(domRect)\n\t        .asVector(\"bottom-left\")\n\t        .plus(new Vector(0, 2)) // add some breathing room\n\t        .plus(getWindowScrollVector());\n\t  }\n\t  containsPoint(point: Vector) {\n", "    return this.#elements.some((el) =>\n\t      // scale slightly so we don't show two tooltips at touching horizontal edges\n\t      new Rect(el.getBoundingClientRect()).scaleY(0.99).contains(point)\n\t    );\n\t  }\n\t  containsIndex(index: number) {\n\t    return this.#indexRange.contains(index, \"inclusive\");\n\t  }\n\t  recalculatePosition() {\n\t    const editorRect = new Rect(this.#editor.getBoundingClientRect());\n", "    const scrollVector = getWindowScrollVector();\n\t    // The range rectangles are tight around the characters; we'd rather fill the line height if possible\n\t    const cssLineHeight = this.#editor.getLineHeight();\n\t    const elements: HTMLElement[] = [];\n\t    // render an annotation element for each line separately\n\t    for (const rect of this.#editor.getRangeRects(this.#indexRange)) {\n\t      // suppress when out of bounds\n\t      if (!rect.isContainedBy(editorRect)) continue;\n\t      // The rects are viewport-relative, but the annotations are absolute positioned\n\t      // (document-relative) so we have to add the window scroll position\n", "      const absoluteRect = rect.translate(scrollVector);\n\t      // We want ranges spanning multiple lines to look like one annotation, so we need to\n\t      // expand them to fill the gap around the lines\n\t      const lineHeight = cssLineHeight ?? rect.height * 1.2;\n\t      const scaledRect = absoluteRect.scaleY(lineHeight / absoluteRect.height);\n\t      elements.push(LintErrorAnnotation.#createAnnotationElement(scaledRect));\n\t    }\n\t    this.#container.replaceChildren(...elements);\n\t    this.#elements = elements;\n\t  }\n", "  static #createAnnotationElement(rect: Rect) {\n\t    const annotation = document.createElement(\"span\");\n\t    annotation.style.position = \"absolute\";\n\t    annotation.style.boxSizing = \"border-box\";\n\t    // use underline instead of highlight for high contrast\n\t    if (isHighContrastMode()) {\n\t      annotation.style.borderBottom = \"3px dashed var(--color-danger-fg)\";\n\t    } else {\n\t      annotation.style.backgroundColor = \"var(--color-danger-emphasis)\";\n\t      annotation.style.opacity = \"0.2\";\n", "    }\n\t    annotation.style.pointerEvents = \"none\";\n\t    annotation.style.top = `${rect.top}px`;\n\t    annotation.style.left = `${rect.left}px`;\n\t    annotation.style.width = `${rect.width}px`;\n\t    annotation.style.height = `${rect.height}px`;\n\t    return annotation;\n\t  }\n\t}\n"]}
{"filename": "src/components/lint-error-tooltip.ts", "chunked_list": ["//@ts-check\n\t\"use strict\";\n\timport {Vector} from \"../utilities/geometry/vector\";\n\timport {LintError} from \"../utilities/lint-markdown\";\n\timport {Component} from \"./component\";\n\tconst WIDTH = 350;\n\tconst MARGIN = 8;\n\texport class LintErrorTooltip extends Component {\n\t  #tooltip = LintErrorTooltip.#createTooltipElement();\n\t  constructor(portal: HTMLElement) {\n", "    super();\n\t    this.addEventListener(document, \"keydown\", (e) => this.#onGlobalKeydown(e));\n\t    this.addEventListener(this.#tooltip, \"mouseout\", () => this.hide());\n\t    portal.appendChild(this.#tooltip);\n\t  }\n\t  disconnect() {\n\t    super.disconnect();\n\t    this.#tooltip.remove();\n\t  }\n\t  show(errors: LintError[], {x, y}: Vector) {\n", "    const prefix = LintErrorTooltip.#createPrefixElement(errors.length);\n\t    // even though typed as required string, sometimes these properties are missing\n\t    const errorNodes = errors.map((error, i) => [\n\t      i !== 0 ? LintErrorTooltip.#createSeparatorElement() : \"\",\n\t      LintErrorTooltip.#createDescriptionElement(error.ruleDescription),\n\t      error.errorDetail\n\t        ? LintErrorTooltip.#createDetailsElement(error.errorDetail)\n\t        : \"\",\n\t      error.justification\n\t        ? LintErrorTooltip.#createJustificationElement(error.justification)\n", "        : \"\",\n\t      error.ruleNames?.length\n\t        ? LintErrorTooltip.#createNameElement(\n\t            error.ruleNames?.slice(0, 2).join(\": \")\n\t          )\n\t        : \"\",\n\t    ]);\n\t    this.#tooltip.replaceChildren(prefix, ...errorNodes.flat());\n\t    this.#tooltip.style.top = `${y}px`;\n\t    {\n", "      const availableWidth = document.body.clientWidth - 2 * MARGIN;\n\t      const rightOverflow = Math.max(x + WIDTH - (availableWidth + MARGIN), 0);\n\t      this.#tooltip.style.left = `${Math.max(x - rightOverflow, MARGIN)}px`;\n\t      this.#tooltip.style.maxWidth = `${availableWidth}px`;\n\t    }\n\t    this.#tooltip.removeAttribute(\"hidden\");\n\t  }\n\t  hide(force = false) {\n\t    // Don't hide if the mouse enters the tooltip (allowing users to copy text)\n\t    setTimeout(() => {\n", "      if (force || !this.#tooltip.matches(\":hover\"))\n\t        this.#tooltip.setAttribute(\"hidden\", \"true\");\n\t    }, 10);\n\t  }\n\t  #onGlobalKeydown(event: KeyboardEvent) {\n\t    if (event.key === \"Escape\" && !event.defaultPrevented) this.hide(true);\n\t  }\n\t  static #createTooltipElement() {\n\t    const element = document.createElement(\"div\");\n\t    element.setAttribute(\"aria-live\", \"polite\");\n", "    element.setAttribute(\"hidden\", \"true\");\n\t    element.style.backgroundColor = \"var(--color-canvas-default)\";\n\t    element.style.padding = \"8px\";\n\t    element.style.border = \"1px solid var(--color-border-default)\";\n\t    element.style.borderRadius = \"6px\";\n\t    element.style.boxShadow = \"var(--color-shadow-medium)\";\n\t    element.style.boxSizing = \"border-box\";\n\t    element.style.position = \"absolute\";\n\t    element.style.width = `${WIDTH}px`;\n\t    element.style.display = \"flex\";\n", "    element.style.flexDirection = \"column\";\n\t    element.style.gap = \"8px\";\n\t    return element;\n\t  }\n\t  static #createPrefixElement(errorCount: number) {\n\t    const element = document.createElement(\"span\");\n\t    element.textContent =\n\t      errorCount === 1\n\t        ? \"Markdown problem: \"\n\t        : `${errorCount} Markdown problems: `;\n", "    element.style.clipPath = \"circle(0)\";\n\t    element.style.position = \"absolute\";\n\t    return element;\n\t  }\n\t  static #createDescriptionElement(description: string) {\n\t    const element = document.createElement(\"div\");\n\t    element.style.fontWeight = \"bold\";\n\t    element.style.color = \"var(--color-danger-fg)\";\n\t    element.append(description);\n\t    return element;\n", "  }\n\t  static #createDetailsElement(details: string) {\n\t    const element = document.createElement(\"p\");\n\t    element.style.fontWeight = \"bold\";\n\t    element.style.margin = \"0\";\n\t    element.append(details);\n\t    return element;\n\t  }\n\t  static #createJustificationElement(justification: string) {\n\t    const element = document.createElement(\"p\");\n", "    element.style.margin = \"0\";\n\t    element.append(justification);\n\t    return element;\n\t  }\n\t  static #createNameElement(name: string) {\n\t    const element = document.createElement(\"code\");\n\t    element.style.fontSize = \"12px\";\n\t    element.style.color = \"var(--color-fg-muted)\";\n\t    element.style.backgroundColor = \"transparent\";\n\t    element.append(name);\n", "    return element;\n\t  }\n\t  static #createSeparatorElement() {\n\t    const element = document.createElement(\"hr\");\n\t    element.style.borderTop = \"1px dashed var(--color-border-default)\";\n\t    element.style.borderBottom = \"none\";\n\t    element.style.margin = \"0\";\n\t    return element;\n\t  }\n\t}\n"]}
{"filename": "src/components/linted-markdown-editor.ts", "chunked_list": ["import {\n\t  CodeMirrorRangeRectCalculator,\n\t  RangeRectCalculator,\n\t  TextareaRangeRectCalculator,\n\t} from \"../utilities/dom/range-rect-calculator\";\n\timport {formatList} from \"../utilities/format\";\n\timport {lintMarkdown} from \"../utilities/lint-markdown\";\n\timport {LintErrorTooltip} from \"./lint-error-tooltip\";\n\timport {LintErrorAnnotation} from \"./lint-error-annotation\";\n\timport {Vector} from \"../utilities/geometry/vector\";\n", "import {NumberRange} from \"../utilities/geometry/number-range\";\n\timport {Component} from \"./component\";\n\texport abstract class LintedMarkdownEditor extends Component {\n\t  #editor: HTMLElement;\n\t  #tooltip: LintErrorTooltip;\n\t  #resizeObserver: ResizeObserver;\n\t  #rangeRectCalculator: RangeRectCalculator;\n\t  #annotationsPortal = document.createElement(\"div\");\n\t  #statusContainer = LintedMarkdownEditor.#createStatusContainerElement();\n\t  constructor(\n", "    element: HTMLElement,\n\t    portal: HTMLElement,\n\t    rangeRectCalculator: RangeRectCalculator\n\t  ) {\n\t    super();\n\t    this.#editor = element;\n\t    this.#rangeRectCalculator = rangeRectCalculator;\n\t    portal.append(this.#annotationsPortal, this.#statusContainer);\n\t    this.addEventListener(element, \"focus\", this.onUpdate);\n\t    this.addEventListener(element, \"blur\", this.#onBlur);\n", "    this.addEventListener(element, \"mousemove\", this.#onMouseMove);\n\t    this.addEventListener(element, \"mouseleave\", this.#onMouseLeave);\n\t    // capture ancestor scroll events for nested scroll containers\n\t    this.addEventListener(document, \"scroll\", this.#onReposition, true);\n\t    // selectionchange can't be bound to the textarea so we have to use the document\n\t    this.addEventListener(document, \"selectionchange\", this.#onSelectionChange);\n\t    // annotations are document-relative so we need to observe document resize as well\n\t    this.addEventListener(window, \"resize\", this.#onReposition);\n\t    // this does mean it will run twice when the resize causes a resize of the textarea,\n\t    // but we also need the resize observer for the textarea because it's user resizable\n", "    this.#resizeObserver = new ResizeObserver(this.#onReposition);\n\t    this.#resizeObserver.observe(element);\n\t    this.#tooltip = new LintErrorTooltip(portal);\n\t  }\n\t  disconnect() {\n\t    super.disconnect();\n\t    this.#resizeObserver.disconnect();\n\t    this.#rangeRectCalculator.disconnect();\n\t    this.#tooltip.disconnect();\n\t    this.#annotationsPortal.remove();\n", "    this.#statusContainer.remove();\n\t  }\n\t  /**\n\t   * Return a list of rects for the given range. If the range extends over multiple lines,\n\t   * multiple rects will be returned.\n\t   */\n\t  getRangeRects(characterIndexes: NumberRange) {\n\t    return this.#rangeRectCalculator.getClientRects(characterIndexes);\n\t  }\n\t  getBoundingClientRect() {\n", "    return this.#editor.getBoundingClientRect();\n\t  }\n\t  getLineHeight() {\n\t    const parsed = parseInt(getComputedStyle(this.#editor).lineHeight, 10);\n\t    return Number.isNaN(parsed) ? undefined : parsed;\n\t  }\n\t  abstract get value(): string;\n\t  abstract get caretPosition(): number;\n\t  #_annotations: readonly LintErrorAnnotation[] = [];\n\t  set #annotations(annotations: ReadonlyArray<LintErrorAnnotation>) {\n", "    if (annotations === this.#_annotations) return;\n\t    this.#_annotations = annotations;\n\t    this.#statusContainer.textContent =\n\t      annotations.length > 0\n\t        ? `${annotations.length} Markdown problem${\n\t            annotations.length > 1 ? \"s\" : \"\"\n\t          } identified: see line${\n\t            annotations.length > 1 ? \"s\" : \"\"\n\t          } ${formatList(\n\t            annotations.map((a) => a.lineNumber.toString()),\n", "            \"and\"\n\t          )}`\n\t        : \"\";\n\t  }\n\t  get #annotations() {\n\t    return this.#_annotations;\n\t  }\n\t  #_tooltipAnnotations: readonly LintErrorAnnotation[] = [];\n\t  set #tooltipAnnotations(annotations: LintErrorAnnotation[]) {\n\t    if (annotations === this.#_tooltipAnnotations) return;\n", "    this.#_tooltipAnnotations = annotations;\n\t    const position = annotations[0]?.getTooltipPosition();\n\t    const errors = annotations.map(({error}) => error);\n\t    if (position) this.#tooltip.show(errors, position);\n\t    else this.#tooltip.hide();\n\t  }\n\t  protected onUpdate = () => this.#lint();\n\t  #isOnRepositionTick = false;\n\t  #onReposition = () => {\n\t    if (this.#isOnRepositionTick) return;\n", "    this.#isOnRepositionTick = true;\n\t    requestAnimationFrame(() => {\n\t      this.#recalculateAnnotationPositions();\n\t      this.#isOnRepositionTick = false;\n\t    });\n\t  };\n\t  #onBlur = () => this.#clear();\n\t  #onMouseMove = (event: MouseEvent) =>\n\t    this.#updatePointerTooltip(new Vector(event.clientX, event.clientY));\n\t  #onMouseLeave = () => (this.#tooltipAnnotations = []);\n", "  #onSelectionChange = () => {\n\t    // this event only works when applied to the document but we can filter it by detecting focus\n\t    if (document.activeElement === this.#editor) this.#updateCaretTooltip();\n\t  };\n\t  #clear() {\n\t    // the annotations will clean themselves up too but this is slightly faster\n\t    this.#annotationsPortal.replaceChildren();\n\t    for (const annotation of this.#annotations) annotation.disconnect();\n\t    this.#annotations = [];\n\t    this.#tooltipAnnotations = [];\n", "  }\n\t  #lint() {\n\t    this.#clear();\n\t    // clear() will not hide the tooltip if the mouse is over it, but if the user is typing then they are not trying to copy content\n\t    this.#tooltip.hide(true);\n\t    if (document.activeElement !== this.#editor) return;\n\t    const errors = lintMarkdown(this.value);\n\t    this.#annotations = errors.map(\n\t      (error) => new LintErrorAnnotation(error, this, this.#annotationsPortal)\n\t    );\n", "  }\n\t  #recalculateAnnotationPositions() {\n\t    for (const annotation of this.#annotations)\n\t      annotation.recalculatePosition();\n\t  }\n\t  #updatePointerTooltip(pointerLocation: Vector) {\n\t    // can't use mouse events on annotations (the easy way) because they have pointer-events: none\n\t    this.#tooltipAnnotations = this.#annotations.filter((a) =>\n\t      a.containsPoint(pointerLocation)\n\t    );\n", "  }\n\t  #updateCaretTooltip() {\n\t    this.#tooltipAnnotations = this.#annotations.filter((a) =>\n\t      a.containsIndex(this.caretPosition)\n\t    );\n\t  }\n\t  static #createStatusContainerElement() {\n\t    const container = document.createElement(\"p\");\n\t    container.setAttribute(\"aria-live\", \"polite\");\n\t    container.style.position = \"absolute\";\n", "    container.style.clipPath = \"circle(0)\";\n\t    return container;\n\t  }\n\t}\n\texport class LintedMarkdownTextareaEditor extends LintedMarkdownEditor {\n\t  readonly #textarea: HTMLTextAreaElement;\n\t  constructor(textarea: HTMLTextAreaElement, portal: HTMLElement) {\n\t    super(textarea, portal, new TextareaRangeRectCalculator(textarea));\n\t    this.#textarea = textarea;\n\t    this.addEventListener(textarea, \"input\", this.onUpdate);\n", "  }\n\t  get value() {\n\t    return this.#textarea.value;\n\t  }\n\t  get caretPosition() {\n\t    return this.#textarea.selectionEnd !== this.#textarea.selectionStart\n\t      ? -1\n\t      : this.#textarea.selectionStart;\n\t  }\n\t}\n", "export class LintedMarkdownCodeMirrorEditor extends LintedMarkdownEditor {\n\t  readonly #element: HTMLElement;\n\t  readonly #mutationObserver: MutationObserver;\n\t  constructor(element: HTMLElement, portal: HTMLElement) {\n\t    super(element, portal, new CodeMirrorRangeRectCalculator(element));\n\t    this.#element = element;\n\t    this.#mutationObserver = new MutationObserver(this.onUpdate);\n\t    this.#mutationObserver.observe(element, {\n\t      childList: true,\n\t      subtree: true,\n", "    });\n\t  }\n\t  override disconnect(): void {\n\t    super.disconnect();\n\t    this.#mutationObserver.disconnect();\n\t  }\n\t  get value() {\n\t    return Array.from(this.#element.querySelectorAll(\".CodeMirror-line\"))\n\t      .map((line) => line.textContent)\n\t      .join(\"\\n\");\n", "  }\n\t  get caretPosition() {\n\t    const selection = document.getSelection();\n\t    const range = selection?.getRangeAt(0);\n\t    if (!range?.collapsed || selection?.rangeCount !== 1) return -1;\n\t    const referenceRange = document.createRange();\n\t    referenceRange.selectNodeContents(this.#element);\n\t    referenceRange.setEnd(range.startContainer, range.startOffset);\n\t    return referenceRange.toString().length;\n\t  }\n", "}\n"]}
{"filename": "src/components/component.ts", "chunked_list": ["type EventName = keyof GlobalEventHandlersEventMap;\n\ttype EventHandler<Name extends EventName> = (\n\t  event: GlobalEventHandlersEventMap[Name]\n\t) => void;\n\tinterface EventDispatcher {\n\t  addEventListener<Name extends EventName>(\n\t    name: Name,\n\t    handler: EventHandler<Name>,\n\t    capture?: boolean\n\t  ): void;\n", "  removeEventListener<Name extends EventName>(\n\t    name: Name,\n\t    handler: EventHandler<Name>,\n\t    capture?: boolean\n\t  ): void;\n\t}\n\ttype EventListener<in out Name extends EventName> = {\n\t  target: EventDispatcher;\n\t  name: Name;\n\t  capture?: boolean;\n", "  handler: EventHandler<Name>;\n\t};\n\texport type ChildNode = string | Node;\n\texport abstract class Component {\n\t  #eventListeners: Array<EventListener<EventName>> = [];\n\t  protected addEventListener<Name extends EventName>(\n\t    target: EventDispatcher,\n\t    name: Name,\n\t    handler: EventHandler<Name>,\n\t    capture?: boolean\n", "  ) {\n\t    target.addEventListener(name, handler, capture);\n\t    this.#eventListeners.push({\n\t      target,\n\t      name,\n\t      capture,\n\t      handler,\n\t    } as EventListener<EventName>);\n\t  }\n\t  disconnect() {\n", "    for (const {target, name, capture, handler} of this.#eventListeners)\n\t      target.removeEventListener(name, handler, capture);\n\t    this.#eventListeners = [];\n\t  }\n\t}\n"]}
{"filename": "src/utilities/lint-markdown.ts", "chunked_list": ["import markdownlint from \"markdownlint\";\n\timport markdownlintGitHub from \"@github/markdownlint-github\";\n\texport interface LintError extends markdownlint.LintError {\n\t  justification?: string;\n\t}\n\texport const lintMarkdown = (markdown: string): LintError[] =>\n\t  markdownlint\n\t    .sync({\n\t      strings: {\n\t        content: markdown,\n", "      },\n\t      config: markdownlintGitHub.init({\n\t        default: false,\n\t        \"no-reversed-links\": true,\n\t        \"no-empty-links\": true,\n\t        // While enforcing a certain unordered list style can be somewhat helpful for making the Markdown source\n\t        // easier to read with a screen reader, this rule is ultimately too opinionated and noisy to be worth it,\n\t        // especially because it conflicts with the editor's bulleted list toolbar button.\n\t        \"ul-style\": false,\n\t      }),\n", "      handleRuleFailures: true,\n\t      customRules: markdownlintGitHub,\n\t    })\n\t    .content?.map((error) => ({\n\t      ...error,\n\t      justification: error.ruleNames\n\t        .map((name) => ruleJustifications[name])\n\t        .join(\" \"),\n\t    })) ?? [];\n\texport const ruleJustifications: Partial<Record<string, string>> = {\n", "  \"heading-increment\":\n\t    \"A well-formed heading structure is key for navigating documents using accessibility tools.\",\n\t  \"fenced-code-language\":\n\t    \"Syntax highlighting in code blocks makes it easier for sighted readers to understand code.\",\n\t  \"no-alt-text\":\n\t    \"Images without alt text are invisible to non-sighted readers.\",\n\t  \"no-default-alt-text\":\n\t    \"Default alt text does not help non-sighted readers understand the image.\",\n\t  \"no-emphasis-as-header\":\n\t    \"Using headers to separate sections helps readers use accessibility tools to navigate documents.\",\n", "  \"ol-prefix\":\n\t    \"When reading Markdown source code, out-of-order lists make it more difficult for non-sighted users to understand how long a list is.\",\n\t};\n"]}
{"filename": "src/utilities/format.ts", "chunked_list": ["export function formatList(items: string[], conjunction: string) {\n\t  if (items.length > 2) {\n\t    items.push(`${conjunction} ${items.pop()}`);\n\t    return items.join(\", \");\n\t  } else if (items.length === 2) {\n\t    const last = items.pop();\n\t    const secondLast = items.pop();\n\t    return [secondLast, conjunction, last].join(\" \");\n\t  } else {\n\t    return items[0];\n", "  }\n\t}\n"]}
{"filename": "src/utilities/dom/observe-selector.ts", "chunked_list": ["/**\n\t * Watch the document DOM for the selector.\n\t */\n\texport function observeSelector(\n\t  selector: string,\n\t  onAdd: (element: HTMLElement) => () => void\n\t) {\n\t  const removeHandlers = new Map<HTMLElement, () => void>();\n\t  for (const element of document.querySelectorAll(selector))\n\t    if (element instanceof HTMLElement)\n", "      removeHandlers.set(element, onAdd(element));\n\t  const observer = new MutationObserver(() => {\n\t    const found = new Set<HTMLElement>();\n\t    // handle new elements\n\t    for (const element of document.querySelectorAll(selector))\n\t      if (element instanceof HTMLElement) {\n\t        found.add(element);\n\t        if (!removeHandlers.has(element))\n\t          removeHandlers.set(element, onAdd(element));\n\t      }\n", "    // handle removed elements\n\t    for (const [element, onRemove] of removeHandlers.entries())\n\t      if (!found.has(element)) {\n\t        onRemove();\n\t        removeHandlers.delete(element);\n\t      }\n\t  });\n\t  observer.observe(document, {\n\t    childList: true,\n\t    subtree: true,\n", "  });\n\t}\n"]}
{"filename": "src/utilities/dom/index.ts", "chunked_list": ["import {Vector} from \"../geometry/vector\";\n\texport const getWindowScrollVector = () =>\n\t  new Vector(window.scrollX, window.scrollY);\n\texport const isHighContrastMode = () => {\n\t  const documentColorMode = document.documentElement.dataset.colorMode;\n\t  const resolvedColorMode =\n\t    documentColorMode === \"auto\"\n\t      ? window.matchMedia(\"prefers-color-scheme: dark\").matches\n\t        ? \"dark\"\n\t        : \"light\"\n", "      : documentColorMode;\n\t  const resolvedColorScheme =\n\t    resolvedColorMode === \"dark\"\n\t      ? document.documentElement.dataset.darkTheme\n\t      : document.documentElement.dataset.lightTheme;\n\t  return (\n\t    (window.matchMedia(\"(forced-colors: active)\").matches ||\n\t      resolvedColorScheme?.includes(\"high_contrast\")) ??\n\t    false\n\t  );\n", "};\n"]}
{"filename": "src/utilities/dom/range-rect-calculator.ts", "chunked_list": ["import {NumberRange} from \"../geometry/number-range\";\n\timport {Rect} from \"../geometry/rect\";\n\timport {Vector} from \"../geometry/vector\";\n\t// Note that some browsers, such as Firefox, do not concatenate properties\n\t// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n\t// so we have to list every single property explicitly.\n\tconst propertiesToCopy = [\n\t  \"direction\", // RTL support\n\t  \"boxSizing\",\n\t  \"width\", // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n", "  \"height\",\n\t  \"overflowX\",\n\t  \"overflowY\", // copy the scrollbar for IE\n\t  \"borderTopWidth\",\n\t  \"borderRightWidth\",\n\t  \"borderBottomWidth\",\n\t  \"borderLeftWidth\",\n\t  \"borderStyle\",\n\t  \"paddingTop\",\n\t  \"paddingRight\",\n", "  \"paddingBottom\",\n\t  \"paddingLeft\",\n\t  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n\t  \"fontStyle\",\n\t  \"fontVariant\",\n\t  \"fontWeight\",\n\t  \"fontStretch\",\n\t  \"fontSize\",\n\t  \"fontSizeAdjust\",\n\t  \"lineHeight\",\n", "  \"fontFamily\",\n\t  \"textAlign\",\n\t  \"textTransform\",\n\t  \"textIndent\",\n\t  \"textDecoration\", // might not make a difference, but better be safe\n\t  \"letterSpacing\",\n\t  \"wordSpacing\",\n\t  \"tabSize\",\n\t  \"MozTabSize\" as \"tabSize\", // prefixed version for Firefox <= 52\n\t] as const satisfies ReadonlyArray<keyof CSSStyleDeclaration>;\n", "export interface RangeRectCalculator {\n\t  /**\n\t   * Return the viewport-relative client rects of the range of characters. If the range\n\t   * has any line breaks, this will return multiple rects. Will include the start char and\n\t   * exclude the end char.\n\t   */\n\t  getClientRects({start, end}: NumberRange): Rect[];\n\t  disconnect(): void;\n\t}\n\t/**\n", " * The `Range` API doesn't work well with `textarea` elements, so this creates a duplicate\n\t * element and uses that instead. Provides a limited API wrapping around adjusted `Range`\n\t * APIs.\n\t */\n\texport class TextareaRangeRectCalculator implements RangeRectCalculator {\n\t  readonly #element: HTMLTextAreaElement;\n\t  readonly #div: HTMLDivElement;\n\t  readonly #mutationObserver: MutationObserver;\n\t  readonly #resizeObserver: ResizeObserver;\n\t  readonly #range: Range;\n", "  constructor(target: HTMLTextAreaElement) {\n\t    this.#element = target;\n\t    // The mirror div will replicate the textarea's style\n\t    const div = document.createElement(\"div\");\n\t    this.#div = div;\n\t    document.body.appendChild(div);\n\t    this.#refreshStyles();\n\t    this.#mutationObserver = new MutationObserver(() => this.#refreshStyles());\n\t    this.#mutationObserver.observe(this.#element, {\n\t      attributeFilter: [\"style\"],\n", "    });\n\t    this.#resizeObserver = new ResizeObserver(() => this.#refreshStyles());\n\t    this.#resizeObserver.observe(this.#element);\n\t    this.#range = document.createRange();\n\t  }\n\t  /**\n\t   * Return the viewport-relative client rects of the range. If the range has any line\n\t   * breaks, this will return multiple rects. Will include the start char and exclude the\n\t   * end char.\n\t   */\n", "  getClientRects({start, end}: NumberRange) {\n\t    this.#refreshText();\n\t    const textNode = this.#div.childNodes[0];\n\t    if (!textNode) return [];\n\t    this.#range.setStart(textNode, start);\n\t    this.#range.setEnd(textNode, end);\n\t    // The div is not in the same place as the textarea so we need to subtract the div\n\t    // position and add the textarea position\n\t    const divPosition = new Rect(this.#div.getBoundingClientRect()).asVector();\n\t    const textareaPosition = new Rect(\n", "      this.#element.getBoundingClientRect()\n\t    ).asVector();\n\t    // The div is not scrollable so it does not have scroll adjustment built in\n\t    const scrollOffset = new Vector(\n\t      this.#element.scrollLeft,\n\t      this.#element.scrollTop\n\t    );\n\t    const netTranslate = divPosition\n\t      .negate()\n\t      .plus(textareaPosition)\n", "      .minus(scrollOffset);\n\t    return Array.from(this.#range.getClientRects()).map((domRect) =>\n\t      new Rect(domRect).translate(netTranslate)\n\t    );\n\t  }\n\t  disconnect() {\n\t    this.#div.remove();\n\t  }\n\t  #refreshStyles() {\n\t    const style = this.#div.style;\n", "    const textareaStyle = window.getComputedStyle(this.#element);\n\t    // Default wrapping styles\n\t    style.whiteSpace = \"pre-wrap\";\n\t    style.wordWrap = \"break-word\";\n\t    // Position off-screen\n\t    style.position = \"fixed\";\n\t    style.top = \"0\";\n\t    style.transform = \"translateY(-100%)\";\n\t    const isFirefox = \"mozInnerScreenX\" in window;\n\t    // Transfer the element's properties to the div\n", "    for (const prop of propertiesToCopy)\n\t      if (prop === \"width\" && textareaStyle.boxSizing === \"border-box\") {\n\t        // With box-sizing: border-box we need to offset the size slightly inwards.  This small difference can compound\n\t        // greatly in long textareas with lots of wrapping, leading to very innacurate results if not accounted for.\n\t        // Firefox will return computed styles in floats, like `0.9px`, while chromium might return `1px` for the same element.\n\t        // Either way we use `parseFloat` to turn `0.9px` into `0.9` and `1px` into `1`\n\t        const totalBorderWidth =\n\t          parseFloat(textareaStyle.borderLeftWidth) +\n\t          parseFloat(textareaStyle.borderRightWidth);\n\t        // When a vertical scrollbar is present it shrinks the content. We need to account for this by using clientWidth\n", "        // instead of width in everything but Firefox. When we do that we also have to account for the border width.\n\t        const width = isFirefox\n\t          ? parseFloat(textareaStyle.width) - totalBorderWidth\n\t          : this.#element.clientWidth + totalBorderWidth;\n\t        style.width = `${width}px`;\n\t      } else {\n\t        style[prop] = textareaStyle[prop];\n\t      }\n\t    if (isFirefox) {\n\t      // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n", "      if (this.#element.scrollHeight > parseInt(textareaStyle.height))\n\t        style.overflowY = \"scroll\";\n\t    } else {\n\t      style.overflow = \"hidden\"; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n\t    }\n\t  }\n\t  #refreshText() {\n\t    this.#div.textContent =\n\t      this.#element instanceof HTMLInputElement\n\t        ? this.#element.value.replace(/\\s/g, \"\\u00a0\")\n", "        : this.#element.value;\n\t  }\n\t}\n\texport class CodeMirrorRangeRectCalculator implements RangeRectCalculator {\n\t  readonly #element: HTMLElement;\n\t  readonly #range: Range;\n\t  constructor(target: HTMLElement) {\n\t    if (!target.classList.contains(\"CodeMirror-code\"))\n\t      throw new Error(\n\t        \"CodeMirrorRangeRectCalculator only works with CodeMirror code editors.\"\n", "      );\n\t    this.#element = target;\n\t    this.#range = document.createRange();\n\t  }\n\t  getClientRects(range: NumberRange): Rect[] {\n\t    const lineNodes = Array.from(\n\t      this.#element.querySelectorAll(\".CodeMirror-line\")\n\t    );\n\t    const lines = lineNodes.map((line) =>\n\t      CodeMirrorRangeRectCalculator.#getAllTextNodes(line)\n", "    );\n\t    const start = CodeMirrorRangeRectCalculator.#getNodeAtOffset(\n\t      lines,\n\t      range.start\n\t    );\n\t    const end = CodeMirrorRangeRectCalculator.#getNodeAtOffset(\n\t      lines,\n\t      range.end\n\t    );\n\t    if (!start || !end) return [];\n", "    this.#range.setStart(...start);\n\t    this.#range.setEnd(...end);\n\t    return Array.from(this.#range.getClientRects()).map(\n\t      (domRect) => new Rect(domRect)\n\t    );\n\t  }\n\t  disconnect(): void {}\n\t  static #getAllTextNodes(node: Node): Node[] {\n\t    const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT);\n\t    const nodes = [];\n", "    while (walker.nextNode()) nodes.push(walker.currentNode);\n\t    return nodes;\n\t  }\n\t  /**\n\t   * Get the text node containing the offset, and the relative offset into that node.\n\t   * @param lines Array of nodes for each line\n\t   * @param offset Offset into the entire text\n\t   */\n\t  static #getNodeAtOffset(\n\t    lines: Node[][],\n", "    offset: number\n\t  ): [node: Node, offsetIntoNode: number] | undefined {\n\t    let prevChars = 0;\n\t    for (const line of lines) {\n\t      for (const node of line) {\n\t        const length = node.textContent?.length ?? 0;\n\t        if (offset <= prevChars + length) return [node, offset - prevChars];\n\t        prevChars += length;\n\t      }\n\t      prevChars++; // For the newline\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src/utilities/geometry/rect.ts", "chunked_list": ["import {NumberRange} from \"./number-range\";\n\timport {Vector} from \"./vector\";\n\ttype RectParams = Pick<DOMRect, \"x\" | \"y\" | \"height\" | \"width\">;\n\t/** Represents a rectangle, typically the bounding box for an HTML element. */\n\texport class Rect implements DOMRect {\n\t  readonly height: number;\n\t  readonly width: number;\n\t  readonly x: number;\n\t  readonly y: number;\n\t  constructor({x, y, height, width}: RectParams) {\n", "    this.x = x;\n\t    this.y = y;\n\t    this.height = height;\n\t    this.width = width;\n\t  }\n\t  copy({\n\t    x = this.x,\n\t    y = this.y,\n\t    height = this.height,\n\t    width = this.width,\n", "  }: Partial<RectParams>) {\n\t    return new Rect({x, y, height, width});\n\t  }\n\t  toJSON() {\n\t    JSON.stringify({\n\t      top: this.top,\n\t      bottom: this.bottom,\n\t      left: this.left,\n\t      right: this.right,\n\t      x: this.x,\n", "      y: this.y,\n\t      height: this.height,\n\t      width: this.width,\n\t    });\n\t  }\n\t  /**\n\t   * Return `true` if `rect` is entirely contained by `otherRect`.\n\t   */\n\t  isContainedBy(other: Rect) {\n\t    return (\n", "      other.contains(this.asVector(\"top-left\")) &&\n\t      other.contains(this.asVector(\"bottom-right\"))\n\t    );\n\t  }\n\t  contains(point: Vector) {\n\t    return (\n\t      this.xRange.contains(point.x, \"inclusive\") &&\n\t      this.yRange.contains(point.y, \"inclusive\")\n\t    );\n\t  }\n", "  get left() {\n\t    return this.x;\n\t  }\n\t  get right() {\n\t    return this.left + this.width;\n\t  }\n\t  get top() {\n\t    return this.y;\n\t  }\n\t  get bottom() {\n", "    return this.top + this.height;\n\t  }\n\t  get xRange() {\n\t    return new NumberRange(this.left, this.right);\n\t  }\n\t  get yRange() {\n\t    return new NumberRange(this.top, this.bottom);\n\t  }\n\t  asVector(\n\t    corner:\n", "      | \"top-left\"\n\t      | \"top-right\"\n\t      | \"bottom-left\"\n\t      | \"bottom-right\" = \"top-left\"\n\t  ) {\n\t    switch (corner) {\n\t      case \"top-left\":\n\t        return new Vector(this.left, this.top);\n\t      case \"top-right\":\n\t        return new Vector(this.right, this.top);\n", "      case \"bottom-left\":\n\t        return new Vector(this.left, this.bottom);\n\t      case \"bottom-right\":\n\t        return new Vector(this.right, this.bottom);\n\t    }\n\t  }\n\t  translate(vector: Vector) {\n\t    return this.copy(this.asVector().plus(vector));\n\t  }\n\t  scaleY(factor: number) {\n", "    const scaledHeight = this.height * factor;\n\t    const deltaY = (this.height - scaledHeight) / 2;\n\t    return this.translate(new Vector(0, deltaY)).copy({height: scaledHeight});\n\t  }\n\t}\n"]}
{"filename": "src/utilities/geometry/vector.ts", "chunked_list": ["/** Represents a 2D vector or point. */\n\texport class Vector {\n\t  constructor(readonly x: number, readonly y: number) {}\n\t  plus(other: Vector) {\n\t    return new Vector(this.x + other.x, this.y + other.y);\n\t  }\n\t  minus(other: Vector) {\n\t    return this.plus(other.negate());\n\t  }\n\t  negate() {\n", "    return new Vector(-this.x, -this.y);\n\t  }\n\t}\n"]}
{"filename": "src/utilities/geometry/number-range.ts", "chunked_list": ["export class NumberRange {\n\t  readonly start: number;\n\t  readonly end: number;\n\t  constructor(start: number, end: number) {\n\t    this.start = Math.min(start, end);\n\t    this.end = Math.max(start, end);\n\t  }\n\t  contains(\n\t    value: number,\n\t    mode:\n", "      | \"inclusive\"\n\t      | \"exclusive\"\n\t      | \"start-inclusive-end-exclusive\"\n\t      | \"start-exclusive-end-inclusive\"\n\t  ) {\n\t    switch (mode) {\n\t      case \"inclusive\":\n\t        return value >= this.start && value <= this.end;\n\t      case \"exclusive\":\n\t        return value > this.start && value < this.end;\n", "      case \"start-inclusive-end-exclusive\":\n\t        return value >= this.start && value < this.end;\n\t      case \"start-exclusive-end-inclusive\":\n\t        return value > this.start && value <= this.end;\n\t    }\n\t  }\n\t}\n"]}
