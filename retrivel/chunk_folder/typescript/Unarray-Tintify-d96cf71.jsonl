{"filename": "vitest.config.ts", "chunked_list": ["import { defineConfig } from \"vitest/config\";\n\texport default defineConfig({\n\t  resolve: {\n\t    alias: {\n\t      \"#/\": \"./src/\"\n\t    }\n\t  },\n\t  test: {\n\t    restoreMocks: true\n\t  }\n", "});"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"#/colors\";\n\texport * from \"#/utils/color\";\n\texport * from \"#/formatters\";"]}
{"filename": "src/formatters/formatter.util.ts", "chunked_list": ["import { RGB, isRGBValues } from \"#/utils/color\";\n\texport const linearGradientIndex = (start: RGB, end: RGB, index: number): RGB => {\n\t  if (!isRGBValues(start)) {\n\t    throw new Error(`Invalid RGB values (start). Values must be in [0, 255]: red=\\`${start.red}\\`, green=\\`${start.green}\\`, blue=\\`${start.blue}\\``);\n\t  }\n\t  if (!isRGBValues(end)) {\n\t    throw new Error(`Invalid RGB values (end). Values must be in [0, 255]: red=\\`${end.red}\\`, green=\\`${end.green}\\`, blue=\\`${end.blue}\\``);\n\t  }\n\t  if (index < 0 || index > 1) throw new Error(`Index must be in range [0,1]: index=\\`${index}\\``);\n\t  return {\n", "    red: Math.floor(start.red + (end.red - start.red) * index),\n\t    green: Math.floor(start.green + (end.green - start.green) * index),\n\t    blue: Math.floor(start.blue + (end.blue - start.blue) * index)\n\t  };\n\t};\n\texport const nextRGBValue = (color: RGB, step: number): RGB => {\n\t  if (!isRGBValues(color)) {\n\t    throw new Error(`Invalid RGB values. Values must be in [0, 255]: red=\\`${color.red}\\`, green=\\`${color.green}\\`, blue=\\`${color.blue}\\``);\n\t  }\n\t  const maxStep = (255 - Math.min(color.red, color.green, color.blue)) * 6; // Max different RGB values\n", "  step = step % maxStep; // Do this to remove the unnecessary loop back to the beginning.\n\t  const colorsArray = Object.entries(color).map(value => ({ id: value[0], color: value[1] }));\n\t  // Init the loop values\n\t  const max = Math.max(...colorsArray.map(v => v.color));\n\t  const min = Math.min(...colorsArray.map(v => v.color));\n\t  let nextMaxIndex = colorsArray.findIndex(v => v.color === max);\n\t  let remainingSteps = step;\n\t  while (remainingSteps > 0) {\n\t    const previousIndex = (nextMaxIndex + 2) % colorsArray.length;\n\t    const previousColorValue = colorsArray[previousIndex].color;\n", "    if (previousColorValue === min) {\n\t      const nextIndex = (nextMaxIndex + 1) % colorsArray.length;\n\t      const nextColor = colorsArray[nextIndex].color;\n\t      const valueToAdd = remainingSteps >= max - nextColor ? max - nextColor : remainingSteps;\n\t      colorsArray[nextIndex].color = nextColor + valueToAdd;\n\t      remainingSteps -= valueToAdd;\n\t      nextMaxIndex = nextIndex;\n\t    } else {\n\t      const valueToRemove = remainingSteps >= previousColorValue - min ? previousColorValue - min : remainingSteps;\n\t      colorsArray[previousIndex].color = previousColorValue - valueToRemove;\n", "      remainingSteps -= valueToRemove;\n\t    }\n\t  }\n\t  return {\n\t    red: colorsArray[0].color,\n\t    green: colorsArray[1].color,\n\t    blue: colorsArray[2].color\n\t  };\n\t};\n\texport const charIndexes = (message: string, char: string): number[] => {\n", "  const spaceIndex: number[] = [];\n\t  for (let i = 0; i < message.length; i++) {\n\t    if (message[i] !== char) continue;\n\t    spaceIndex.push(i);\n\t  }\n\t  return spaceIndex;\n\t};\n\texport const concatCharIndexes = (message: string[], charIndexes : number[], char: string): string[] => {\n\t  charIndexes.sort((a, b) => a - b);\n\t  for (const index of charIndexes) {\n", "    message = message.slice(0, index).concat([char], message.slice(index));\n\t  }\n\t  return message;\n\t};"]}
{"filename": "src/formatters/formatter.type.ts", "chunked_list": ["export type FormatConfig = Record<string, string>;"]}
{"filename": "src/formatters/formatter.const.ts", "chunked_list": ["import { FormatConfig } from \"./formatter.type\";\n\timport { RGB } from \"#/utils/color\";\n\timport { effect, effectReset, forground } from \"#/colors\";\n\texport const defaultRainbowStartColor: RGB = {\n\t  red: 255,\n\t  green: 0,\n\t  blue: 0\n\t} as const;\n\texport const defaultFormatConfig: FormatConfig = {\n\t  \"§0\": forground.black,\n", "  \"§1\": forground.red,\n\t  \"§2\": forground.green,\n\t  \"§3\": forground.yellow,\n\t  \"§4\": forground.blue,\n\t  \"§5\": forground.magenta,\n\t  \"§6\": forground.cyan,\n\t  \"§7\": forground.white,\n\t  \"§8\": forground.default,\n\t  \"§r\": effectReset.all,\n\t  \"§b\": effect.bold,\n", "  \"§i\": effect.italic,\n\t  \"§u\": effect.underline,\n\t  \"§s\": effect.strikethrough\n\t} as const;"]}
{"filename": "src/formatters/index.ts", "chunked_list": ["export * from \"./formatter\";\n\texport * from \"./formatter.const\";"]}
{"filename": "src/formatters/formatter.ts", "chunked_list": ["import { effectReset, forgroundRGBColor } from \"#/colors\";\n\timport { FormatConfig } from \"./formatter.type\";\n\timport { RGB, isInRGBRange, isRGBValues, removeEscapeSequence } from \"#/utils/color\";\n\timport { defaultFormatConfig, defaultRainbowStartColor } from \"./formatter.const\";\n\timport { charIndexes, concatCharIndexes, linearGradientIndex, nextRGBValue } from \"./formatter.util\";\n\texport const linearGradient = (message: string, start: RGB, end: RGB, ignoreSpaces = true): string => {\n\t  if (!isRGBValues(start)) {\n\t    throw new Error(`Invalid RGB values (start). Values must be in [0, 255]: red=\\`${start.red}\\`, green=\\`${start.green}\\`, blue=\\`${start.blue}\\``);\n\t  }\n\t  if (!isRGBValues(end)) {\n", "    throw new Error(`Invalid RGB values (end). Values must be in [0, 255]: red=\\`${end.red}\\`, green=\\`${end.green}\\`, blue=\\`${end.blue}\\``);\n\t  }\n\t  message = removeEscapeSequence(message);\n\t  const tempMessage = ignoreSpaces ? message.replaceAll(\" \", \"\") : message;\n\t  let newMessage: string[] = [];\n\t  if (tempMessage.length <= 1) {\n\t    newMessage.push(`${forgroundRGBColor(start)}${tempMessage}`);\n\t  } else {\n\t    for (let i = 0; i < tempMessage.length; i++) {\n\t      if (tempMessage[i] === \" \") {\n", "        newMessage.push(tempMessage[i]);\n\t        continue;\n\t      }\n\t      const color = linearGradientIndex(start, end, (i / (tempMessage.length - 1)));\n\t      newMessage.push(`${forgroundRGBColor(color)}${tempMessage[i]}`);\n\t    }\n\t  }\n\t  if (ignoreSpaces) {\n\t    newMessage = concatCharIndexes(\n\t      newMessage,\n", "      charIndexes(message, \" \"),\n\t      \" \"\n\t    );\n\t  }\n\t  return `${newMessage.join(\"\")}${effectReset.all}`;\n\t};\n\texport const matrix = (message: string, color: RGB, force = 100): string => {\n\t  if (!isRGBValues(color)) {\n\t    throw new Error(`Invalid RGB values. Values must be in [0, 255]: red=\\`${color.red}\\`, green=\\`${color.green}\\`, blue=\\`${color.blue}\\``);\n\t  }\n", "  if (!isInRGBRange(force)) throw new Error(`Invalid force. Value must be in [0, 255]: force=\\`${force}\\``);\n\t  message = removeEscapeSequence(message);\n\t  let newMessage = \"\";\n\t  for (let i = 0; i < message.length; i++) {\n\t    if (message[i] === \" \") {\n\t      newMessage += message[i];\n\t      continue;\n\t    }\n\t    const num = Math.round(Math.random() * force); // Random number between 0 and force\n\t    // For each value cross-product\n", "    const colorNuance: RGB = {\n\t      red: Math.floor(color.red * ((255 - num) / 255)),\n\t      green: Math.floor(color.green * ((255 - num) / 255)),\n\t      blue: Math.floor(color.blue * ((255 - num) / 255))\n\t    };\n\t    newMessage += `${forgroundRGBColor(colorNuance)}${message[i]}`;\n\t  }\n\t  return `${newMessage}${effectReset.all}`;\n\t};\n\texport const rainbow = (message: string, start: RGB = defaultRainbowStartColor, step = 15, ignoreSpaces = true): string => {\n", "  if (!isRGBValues(start)) {\n\t    throw new Error(`Invalid RGB values. Values must be in [0, 255]: red=\\`${start.red}\\`, green=\\`${start.green}\\`, blue=\\`${start.blue}\\``);\n\t  }\n\t  message = removeEscapeSequence(message);\n\t  const tempMessage = ignoreSpaces ? message.replaceAll(\" \", \"\") : message;\n\t  let newMessage: string[] = [];\n\t  let nextColor = start;\n\t  for (let i = 0; i < tempMessage.length; i++) {\n\t    if (tempMessage[i] === \" \") {\n\t      newMessage.push(tempMessage[i]);\n", "    } else {\n\t      newMessage.push(`${forgroundRGBColor(nextColor)}${tempMessage[i]}`);\n\t    }\n\t    nextColor = nextRGBValue(nextColor, step);\n\t  }\n\t  if (ignoreSpaces) {\n\t    newMessage = concatCharIndexes(\n\t      newMessage,\n\t      charIndexes(message, \" \"),\n\t      \" \"\n", "    );\n\t  }\n\t  return `${newMessage.join(\"\")}${effectReset.all}`;\n\t};\n\texport const format = (message: string, formatConfig: FormatConfig = defaultFormatConfig): string => {\n\t  const regex = new RegExp(Object.keys(formatConfig).join(\"|\"), \"g\");\n\t  return message.replace(regex, match => formatConfig[match]);\n\t};"]}
{"filename": "src/formatters/_test/formatter.util.test.ts", "chunked_list": ["import { charIndexes, concatCharIndexes, linearGradientIndex, nextRGBValue } from \"../formatter.util\";\n\timport { RGB } from \"#/utils/color\";\n\timport { describe, expect, it } from \"vitest\";\n\tdescribe(\"`linearGradientIndex` function\", () => {\n\t  it(\"should return a RGB value\", () => {\n\t    expect(linearGradientIndex({ red: 255, green: 0, blue: 112 }, { red: 25, green: 240, blue: 22 }, 0))\n\t      .toStrictEqual<RGB>({ red: 255, green: 0, blue: 112 });\n\t    expect(linearGradientIndex({ red: 255, green: 0, blue: 112 }, { red: 25, green: 240, blue: 22 }, 0.2))\n\t      .toStrictEqual<RGB>({ red: 209, green: 48, blue: 94 });\n\t    expect(linearGradientIndex({ red: 255, green: 0, blue: 112 }, { red: 25, green: 240, blue: 22 }, 0.4))\n", "      .toStrictEqual<RGB>({ red: 163, green: 96, blue: 76 });\n\t    expect(linearGradientIndex({ red: 255, green: 0, blue: 112 }, { red: 25, green: 240, blue: 22 }, 0.6))\n\t      .toStrictEqual<RGB>({ red: 117, green: 144, blue: 58 });\n\t    expect(linearGradientIndex({ red: 255, green: 0, blue: 112 }, { red: 25, green: 240, blue: 22 }, 0.8))\n\t      .toStrictEqual<RGB>({ red: 71, green: 192, blue: 40 });\n\t    expect(linearGradientIndex({ red: 255, green: 0, blue: 112 }, { red: 25, green: 240, blue: 22 }, 1))\n\t      .toStrictEqual<RGB>({ red: 25, green: 240, blue: 22 });\n\t  });\n\t  it(\"should throw an error\", () => {\n\t    expect(() => linearGradientIndex({ red: -1, green: 0, blue: 0 }, { red: 0, green: 0, blue: 0 }, 0))\n", "      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`-1`, green=`0`, blue=`0`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: -1, blue: 0 }, { red: 0, green: 0, blue: 0 }, 0))\n\t      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`0`, green=`-1`, blue=`0`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 0, blue: -1 }, { red: 0, green: 0, blue: 0 }, 0))\n\t      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`0`, green=`0`, blue=`-1`\");\n\t    expect(() => linearGradientIndex({ red: 256, green: 0, blue: 0 }, { red: 0, green: 0, blue: 0 }, 0))\n\t      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`256`, green=`0`, blue=`0`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 256, blue: 0 }, { red: 0, green: 0, blue: 0 }, 0))\n\t      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`0`, green=`256`, blue=`0`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 0, blue: 256 }, { red: 0, green: 0, blue: 0 }, 0))\n", "      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`0`, green=`0`, blue=`256`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 0, blue: 0 }, { red: -1, green: 0, blue: 0 }, 0))\n\t      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`-1`, green=`0`, blue=`0`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 0, blue: 0 }, { red: 0, green: -1, blue: 0 }, 0))\n\t      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`0`, green=`-1`, blue=`0`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 0, blue: 0 }, { red: 0, green: 0, blue: -1 }, 0))\n\t      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`0`, green=`0`, blue=`-1`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 0, blue: 0 }, { red: 256, green: 0, blue: 0 }, 0))\n\t      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`256`, green=`0`, blue=`0`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 0, blue: 0 }, { red: 0, green: 256, blue: 0 }, 0))\n", "      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`0`, green=`256`, blue=`0`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 0, blue: 0 }, { red: 0, green: 0, blue: 256 }, 0))\n\t      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`0`, green=`0`, blue=`256`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 0, blue: 0 }, { red: 0, green: 0, blue: 0 }, -1))\n\t      .toThrow(\"Index must be in range [0,1]: index=`-1`\");\n\t    expect(() => linearGradientIndex({ red: 0, green: 0, blue: 0 }, { red: 0, green: 0, blue: 0 }, 2))\n\t      .toThrow(\"Index must be in range [0,1]: index=`2`\");\n\t  });\n\t});\n\tdescribe(\"`nextRGBValue` function\", () => {\n", "  it(\"should return a RGB value\", () => {\n\t    expect(nextRGBValue({ red: 255, green: 0, blue: 0 }, 0))\n\t      .toStrictEqual<RGB>({ red: 255, green: 0, blue: 0 });\n\t    expect(nextRGBValue({ red: 255, green: 0, blue: 0 }, 1530))\n\t      .toStrictEqual<RGB>({ red: 255, green: 0, blue: 0 });\n\t    expect(nextRGBValue({ red: 255, green: 0, blue: 0 }, 10))\n\t      .toStrictEqual<RGB>({ red: 255, green: 10, blue: 0 });\n\t    expect(nextRGBValue({ red: 255, green: 0, blue: 0 }, 50))\n\t      .toStrictEqual<RGB>({ red: 255, green: 50, blue: 0 });\n\t    expect(nextRGBValue({ red: 255, green: 0, blue: 0 }, 100))\n", "      .toStrictEqual<RGB>({ red: 255, green: 100, blue: 0 });\n\t    expect(nextRGBValue({ red: 255, green: 0, blue: 0 }, 500))\n\t      .toStrictEqual<RGB>({ red: 10, green: 255, blue: 0 });\n\t    expect(nextRGBValue({ red: 255, green: 0, blue: 0 }, 1000))\n\t      .toStrictEqual<RGB>({ red: 0, green: 20, blue: 255 });\n\t    expect(nextRGBValue({ red: 47, green: 61, blue: 74 }, 0))\n\t      .toStrictEqual<RGB>({ red: 47, green: 61, blue: 74 });\n\t    expect(nextRGBValue({ red: 47, green: 61, blue: 74 }, 1248))\n\t      .toStrictEqual<RGB>({ red: 47, green: 61, blue: 74 });\n\t    expect(nextRGBValue({ red: 47, green: 61, blue: 74 }, 1530))\n", "      .toStrictEqual<RGB>({ red: 49, green: 74, blue: 47 });\n\t    expect(nextRGBValue({ red: 47, green: 61, blue: 74 }, 10))\n\t      .toStrictEqual<RGB>({ red: 47, green: 51, blue: 74 });\n\t    expect(nextRGBValue({ red: 47, green: 61, blue: 74 }, 50))\n\t      .toStrictEqual<RGB>({ red: 74, green: 47, blue: 65 });\n\t    expect(nextRGBValue({ red: 47, green: 61, blue: 74 }, 100))\n\t      .toStrictEqual<RGB>({ red: 69, green: 74, blue: 47 });\n\t    expect(nextRGBValue({ red: 47, green: 61, blue: 74 }, 500))\n\t      .toStrictEqual<RGB>({ red: 47, green: 47, blue: 74 });\n\t    expect(nextRGBValue({ red: 47, green: 61, blue: 74 }, 1000))\n", "      .toStrictEqual<RGB>({ red: 61, green: 47, blue: 74 });\n\t  });\n\t  it(\"should throw an error\", () => {\n\t    expect(() => nextRGBValue({ red: -1, green: 0, blue: 0 }, 0))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`-1`, green=`0`, blue=`0`\");\n\t    expect(() => nextRGBValue({ red: 0, green: -1, blue: 0 }, 0))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`-1`, blue=`0`\");\n\t    expect(() => nextRGBValue({ red: 0, green: 0, blue: -1 }, 0))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`0`, blue=`-1`\");\n\t    expect(() => nextRGBValue({ red: 256, green: 0, blue: 0 }, 0))\n", "      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`256`, green=`0`, blue=`0`\");\n\t    expect(() => nextRGBValue({ red: 0, green: 256, blue: 0 }, 0))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`256`, blue=`0`\");\n\t    expect(() => nextRGBValue({ red: 0, green: 0, blue: 256 }, 0))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`0`, blue=`256`\");\n\t  });\n\t});\n\tdescribe(\"`charIndexes` function\", () => {\n\t  it(\"should return an array of indexes\", () => {\n\t    expect(charIndexes(\"\", \" \")).toStrictEqual([]);\n", "    expect(charIndexes(\"foo\", \" \")).toStrictEqual([]);\n\t    expect(charIndexes(\"foo bar\", \" \")).toStrictEqual([3]);\n\t    expect(charIndexes(\"foo bar\", \" \")).toStrictEqual([3]);\n\t    expect(charIndexes(\"foo bar\", \" \")).toStrictEqual([3]);\n\t    expect(charIndexes(\"foo bar toto titi tata tutu tete\", \" \")).toStrictEqual([3, 7, 12, 17, 22, 27]);\n\t    expect(charIndexes(\"foo bar toto titi tata tutu tete\", \"a\")).toStrictEqual([5, 19, 21]);\n\t  });\n\t});\n\tdescribe(\"`concatCharIndexes` function\", () => {\n\t  it(\"should return an array of string\", () => {\n", "    expect(concatCharIndexes([], [], \"foo\")).toStrictEqual([]);\n\t    expect(concatCharIndexes([], [1], \"foo\")).toStrictEqual([\"foo\"]);\n\t    expect(concatCharIndexes([\"bar\"], [], \"foo\")).toStrictEqual([\"bar\"]);\n\t    expect(concatCharIndexes([\"bar\"], [0], \"foo\")).toStrictEqual([\"foo\", \"bar\"]);\n\t    expect(concatCharIndexes([\"bar\"], [1], \"foo\")).toStrictEqual([\"bar\", \"foo\"]);\n\t    expect(concatCharIndexes([\"bar\"], [0, 3], \"foo\")).toStrictEqual([\"foo\", \"bar\", \"foo\"]);\n\t    expect(concatCharIndexes([\"bar\"], [1, 3], \"foo\")).toStrictEqual([\"bar\", \"foo\", \"foo\"]);\n\t    expect(concatCharIndexes([\"bar\", \"toto\", \"titi\", \"tata\", \"tutu\", \"tete\"], [1, 19, 3, 8], \"foo\"))\n\t      .toStrictEqual([\"bar\", \"foo\", \"toto\", \"foo\", \"titi\", \"tata\", \"tutu\", \"tete\", \"foo\", \"foo\"]);\n\t  });\n", "});"]}
{"filename": "src/formatters/_test/formatter.test.ts", "chunked_list": ["import { forground } from \"#/colors\";\n\timport { defaultFormatConfig } from \"../formatter.const\";\n\timport { FormatConfig } from \"../formatter.type\";\n\timport { format, linearGradient, matrix, rainbow } from \"../formatter\";\n\timport { describe, expect, it, vi } from \"vitest\";\n\tdescribe(\"`linearGradient` function\", () => {\n\t  it(\"should return a formatted string with ignoring spaces\", () => {\n\t    expect(linearGradient(\"\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }))\n\t      .toBe(\"\\u001B[38;2;255;0;0m\\u001B[0m\");\n\t    expect(linearGradient(\"a\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }))\n", "      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[0m\");\n\t    expect(linearGradient(\"aa\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;0;0;255ma\\u001B[0m\");\n\t    expect(linearGradient(\"aaa\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;127;0;127ma\\u001B[38;2;0;0;255ma\\u001B[0m\");\n\t    expect(linearGradient(\"aaaaa\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;191;0;63ma\\u001B[38;2;127;0;127ma\\u001B[38;2;63;0;191ma\\u001B[38;2;0;0;255ma\\u001B[0m\");\n\t    expect(linearGradient(\"aa     aa\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;170;0;85ma     \\u001B[38;2;85;0;170ma\\u001B[38;2;0;0;255ma\\u001B[0m\");\n\t    expect(linearGradient(\"     aa\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }))\n", "      .toBe(\"     \\u001B[38;2;255;0;0ma\\u001B[38;2;0;0;255ma\\u001B[0m\");\n\t  });\n\t  it(\"should return a formatted string without ignoring spaces\", () => {\n\t    expect(linearGradient(\"\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }, false))\n\t      .toBe(\"\\u001B[38;2;255;0;0m\\u001B[0m\");\n\t    expect(linearGradient(\"a\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }, false))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[0m\");\n\t    expect(linearGradient(\"aa\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }, false))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;0;0;255ma\\u001B[0m\");\n\t    expect(linearGradient(\"aaa\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }, false))\n", "      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;127;0;127ma\\u001B[38;2;0;0;255ma\\u001B[0m\");\n\t    expect(linearGradient(\"aaaaa\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }, false))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;191;0;63ma\\u001B[38;2;127;0;127ma\\u001B[38;2;63;0;191ma\\u001B[38;2;0;0;255ma\\u001B[0m\");\n\t    expect(linearGradient(\"aa     aa\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }, false))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;223;0;31ma     \\u001B[38;2;31;0;223ma\\u001B[38;2;0;0;255ma\\u001B[0m\");\n\t    expect(linearGradient(\"     aa\", { red: 255, green: 0, blue: 0 }, { red: 0, green: 0, blue: 255 }, false))\n\t      .toBe(\"     \\u001B[38;2;42;0;212ma\\u001B[38;2;0;0;255ma\\u001B[0m\");\n\t  });\n\t  it(\"should throw an error\", () => {\n\t    expect(() => linearGradient(\"\", { red: -1, green: 0, blue: 0 }, { red: 0, green: 0, blue: 0 }))\n", "      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`-1`, green=`0`, blue=`0`\");\n\t    expect(() => linearGradient(\"\", { red: 0, green: -1, blue: 0 }, { red: 0, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`0`, green=`-1`, blue=`0`\");\n\t    expect(() => linearGradient(\"\", { red: 0, green: 0, blue: -1 }, { red: 0, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`0`, green=`0`, blue=`-1`\");\n\t    expect(() => linearGradient(\"\", { red: 256, green: 0, blue: 0 }, { red: 0, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`256`, green=`0`, blue=`0`\");\n\t    expect(() => linearGradient(\"\", { red: 0, green: 256, blue: 0 }, { red: 0, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`0`, green=`256`, blue=`0`\");\n\t    expect(() => linearGradient(\"\", { red: 0, green: 0, blue: 256 }, { red: 0, green: 0, blue: 0 }))\n", "      .toThrow(\"Invalid RGB values (start). Values must be in [0, 255]: red=`0`, green=`0`, blue=`256`\");\n\t    expect(() => linearGradient(\"\", { red: 0, green: 0, blue: 0 }, { red: -1, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`-1`, green=`0`, blue=`0`\");\n\t    expect(() => linearGradient(\"\", { red: 0, green: 0, blue: 0 }, { red: 0, green: -1, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`0`, green=`-1`, blue=`0`\");\n\t    expect(() => linearGradient(\"\", { red: 0, green: 0, blue: 0 }, { red: 0, green: 0, blue: -1 }))\n\t      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`0`, green=`0`, blue=`-1`\");\n\t    expect(() => linearGradient(\"\", { red: 0, green: 0, blue: 0 }, { red: 256, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`256`, green=`0`, blue=`0`\");\n\t    expect(() => linearGradient(\"\", { red: 0, green: 0, blue: 0 }, { red: 0, green: 256, blue: 0 }))\n", "      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`0`, green=`256`, blue=`0`\");\n\t    expect(() => linearGradient(\"\", { red: 0, green: 0, blue: 0 }, { red: 0, green: 0, blue: 256 }))\n\t      .toThrow(\"Invalid RGB values (end). Values must be in [0, 255]: red=`0`, green=`0`, blue=`256`\");\n\t  });\n\t});\n\tdescribe(\"`matrix` function\", () => {\n\t  it(\"should return a formatted string with a random value set to 0\", () => {\n\t    vi.spyOn(global.Math, \"random\").mockReturnValue(0);\n\t    expect(matrix(\"\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[0m\");\n\t    expect(matrix(\"a\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[38;2;255;128;0ma\\u001B[0m\");\n", "    expect(matrix(\"aa\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[38;2;255;128;0ma\\u001B[38;2;255;128;0ma\\u001B[0m\");\n\t    expect(matrix(\"aaa\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[38;2;255;128;0ma\\u001B[38;2;255;128;0ma\\u001B[38;2;255;128;0ma\\u001B[0m\");\n\t  });\n\t  it(\"should return a formatted string with a random value set to 0.5\", () => {\n\t    vi.spyOn(global.Math, \"random\").mockReturnValue(0.5);\n\t    expect(matrix(\"\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[0m\");\n\t    expect(matrix(\"a\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[38;2;205;102;0ma\\u001B[0m\");\n\t    expect(matrix(\"aa\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[38;2;205;102;0ma\\u001B[38;2;205;102;0ma\\u001B[0m\");\n\t    expect(matrix(\"aaa\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[38;2;205;102;0ma\\u001B[38;2;205;102;0ma\\u001B[38;2;205;102;0ma\\u001B[0m\");\n\t  });\n", "  it(\"should return a formatted string with a random value set to 1\", () => {\n\t    vi.spyOn(global.Math, \"random\").mockReturnValue(1);\n\t    expect(matrix(\"\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[0m\");\n\t    expect(matrix(\"a\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[38;2;155;77;0ma\\u001B[0m\");\n\t    expect(matrix(\"aa\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[38;2;155;77;0ma\\u001B[38;2;155;77;0ma\\u001B[0m\");\n\t    expect(matrix(\"aaa\", { red: 255, green: 128, blue: 0 })).toBe(\"\\u001B[38;2;155;77;0ma\\u001B[38;2;155;77;0ma\\u001B[38;2;155;77;0ma\\u001B[0m\");\n\t  });\n\t  it(\"should return a formatted string with a random value set to 1 and froce to 0\", () => {\n\t    vi.spyOn(global.Math, \"random\").mockReturnValue(1);\n\t    expect(matrix(\"\", { red: 255, green: 128, blue: 0 }, 0)).toBe(\"\\u001B[0m\");\n", "    expect(matrix(\"a\", { red: 255, green: 128, blue: 0 }, 0)).toBe(\"\\u001B[38;2;255;128;0ma\\u001B[0m\");\n\t    expect(matrix(\"aa\", { red: 255, green: 128, blue: 0 }, 0)).toBe(\"\\u001B[38;2;255;128;0ma\\u001B[38;2;255;128;0ma\\u001B[0m\");\n\t    expect(matrix(\"aaa\", { red: 255, green: 128, blue: 0 }, 0))\n\t      .toBe(\"\\u001B[38;2;255;128;0ma\\u001B[38;2;255;128;0ma\\u001B[38;2;255;128;0ma\\u001B[0m\");\n\t  });\n\t  it(\"should return a formatted string with a random value set to 1 and froce to 255\", () => {\n\t    vi.spyOn(global.Math, \"random\").mockReturnValue(1);\n\t    expect(matrix(\"\", { red: 255, green: 128, blue: 0 }, 255)).toBe(\"\\u001B[0m\");\n\t    expect(matrix(\"a\", { red: 255, green: 128, blue: 0 }, 255)).toBe(\"\\u001B[38;2;0;0;0ma\\u001B[0m\");\n\t    expect(matrix(\"aa\", { red: 255, green: 128, blue: 0 }, 255)).toBe(\"\\u001B[38;2;0;0;0ma\\u001B[38;2;0;0;0ma\\u001B[0m\");\n", "    expect(matrix(\"aaa\", { red: 255, green: 128, blue: 0 }, 255)).toBe(\"\\u001B[38;2;0;0;0ma\\u001B[38;2;0;0;0ma\\u001B[38;2;0;0;0ma\\u001B[0m\");\n\t  });\n\t  it(\"should throw an error\", () => {\n\t    expect(() => matrix(\"\", { red: -1, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`-1`, green=`0`, blue=`0`\");\n\t    expect(() => matrix(\"\", { red: 0, green: -1, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`-1`, blue=`0`\");\n\t    expect(() => matrix(\"\", { red: 0, green: 0, blue: -1 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`0`, blue=`-1`\");\n\t    expect(() => matrix(\"\", { red: 256, green: 0, blue: 0 }))\n", "      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`256`, green=`0`, blue=`0`\");\n\t    expect(() => matrix(\"\", { red: 0, green: 256, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`256`, blue=`0`\");\n\t    expect(() => matrix(\"\", { red: 0, green: 0, blue: 256 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`0`, blue=`256`\");\n\t    expect(() => matrix(\"\", { red: 0, green: 0, blue: 0 }, -1)).toThrow(\"Invalid force. Value must be in [0, 255]: force=`-1`\");\n\t    expect(() => matrix(\"\", { red: 0, green: 0, blue: 0 }, 256)).toThrow(\"Invalid force. Value must be in [0, 255]: force=`256`\");\n\t  });\n\t});\n\tdescribe(\"`rainbow` function\", () => {\n", "  it(\"should return a formatted string with ignoring spaces\", () => {\n\t    expect(rainbow(\"\"))\n\t      .toBe(\"\\u001B[0m\");\n\t    expect(rainbow(\"a\"))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[0m\");\n\t    expect(rainbow(\"aa\"))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;255;15;0ma\\u001B[0m\");\n\t    expect(rainbow(\"aaa\"))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;255;15;0ma\\u001B[38;2;255;30;0ma\\u001B[0m\");\n\t    expect(rainbow(\"aaaaa\"))\n", "      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;255;15;0ma\\u001B[38;2;255;30;0ma\\u001B[38;2;255;45;0ma\\u001B[38;2;255;60;0ma\\u001B[0m\");\n\t    expect(rainbow(\"aa     aa\"))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;255;15;0ma     \\u001B[38;2;255;30;0ma\\u001B[38;2;255;45;0ma\\u001B[0m\");\n\t    expect(rainbow(\"     aa\"))\n\t      .toBe(\"     \\u001B[38;2;255;0;0ma\\u001B[38;2;255;15;0ma\\u001B[0m\");\n\t  });\n\t  it(\"should return a formatted string without ignoring spaces\", () => {\n\t    expect(rainbow(\"\", undefined, undefined, false))\n\t      .toBe(\"\\u001B[0m\");\n\t    expect(rainbow(\"a\", undefined, undefined, false))\n", "      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[0m\");\n\t    expect(rainbow(\"aa\", undefined, undefined, false))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;255;15;0ma\\u001B[0m\");\n\t    expect(rainbow(\"aaa\", undefined, undefined, false))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;255;15;0ma\\u001B[38;2;255;30;0ma\\u001B[0m\");\n\t    expect(rainbow(\"aaaaa\", undefined, undefined, false))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;255;15;0ma\\u001B[38;2;255;30;0ma\\u001B[38;2;255;45;0ma\\u001B[38;2;255;60;0ma\\u001B[0m\");\n\t    expect(rainbow(\"aa     aa\", undefined, undefined, false))\n\t      .toBe(\"\\u001B[38;2;255;0;0ma\\u001B[38;2;255;15;0ma     \\u001B[38;2;255;105;0ma\\u001B[38;2;255;120;0ma\\u001B[0m\");\n\t    expect(rainbow(\"     aa\", undefined, undefined, false))\n", "      .toBe(\"     \\u001B[38;2;255;75;0ma\\u001B[38;2;255;90;0ma\\u001B[0m\");\n\t  });\n\t  it(\"should return a formatted string with ignoring spaces and start at different color\", () => {\n\t    expect(rainbow(\"\", { red: 115, green: 230, blue: 214 }))\n\t      .toBe(\"\\u001B[0m\");\n\t    expect(rainbow(\"a\", { red: 115, green: 230, blue: 214 }))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[0m\");\n\t    expect(rainbow(\"aa\", { red: 115, green: 230, blue: 214 }))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;115;230;229ma\\u001B[0m\");\n\t    expect(rainbow(\"aaa\", { red: 115, green: 230, blue: 214 }))\n", "      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;115;230;229ma\\u001B[38;2;115;216;230ma\\u001B[0m\");\n\t    expect(rainbow(\"aaaaa\", { red: 115, green: 230, blue: 214 }))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;115;230;229ma\\u001B[38;2;115;216;230ma\\u001B[38;2;115;201;230ma\\u001B[38;2;115;186;230ma\\u001B[0m\");\n\t    expect(rainbow(\"aa     aa\", { red: 115, green: 230, blue: 214 }))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;115;230;229ma     \\u001B[38;2;115;216;230ma\\u001B[38;2;115;201;230ma\\u001B[0m\");\n\t    expect(rainbow(\"     aa\", { red: 115, green: 230, blue: 214 }))\n\t      .toBe(\"     \\u001B[38;2;115;230;214ma\\u001B[38;2;115;230;229ma\\u001B[0m\");\n\t  });\n\t  it(\"should return a formatted string without ignoring spaces and start at different color\", () => {\n\t    expect(rainbow(\"\", { red: 115, green: 230, blue: 214 }, undefined, false))\n", "      .toBe(\"\\u001B[0m\");\n\t    expect(rainbow(\"a\", { red: 115, green: 230, blue: 214 }, undefined, false))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[0m\");\n\t    expect(rainbow(\"aa\", { red: 115, green: 230, blue: 214 }, undefined, false))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;115;230;229ma\\u001B[0m\");\n\t    expect(rainbow(\"aaa\", { red: 115, green: 230, blue: 214 }, undefined, false))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;115;230;229ma\\u001B[38;2;115;216;230ma\\u001B[0m\");\n\t    expect(rainbow(\"aaaaa\", { red: 115, green: 230, blue: 214 }, undefined, false))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;115;230;229ma\\u001B[38;2;115;216;230ma\\u001B[38;2;115;201;230ma\\u001B[38;2;115;186;230ma\\u001B[0m\");\n\t    expect(rainbow(\"aa     aa\", { red: 115, green: 230, blue: 214 }, undefined, false))\n", "      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;115;230;229ma     \\u001B[38;2;115;141;230ma\\u001B[38;2;115;126;230ma\\u001B[0m\");\n\t    expect(rainbow(\"     aa\", { red: 115, green: 230, blue: 214 }, undefined, false))\n\t      .toBe(\"     \\u001B[38;2;115;171;230ma\\u001B[38;2;115;156;230ma\\u001B[0m\");\n\t  });\n\t  it(\"should return a formatted string with ignoring spaces and have different step\", () => {\n\t    expect(rainbow(\"\", { red: 115, green: 230, blue: 214 }, 150))\n\t      .toBe(\"\\u001B[0m\");\n\t    expect(rainbow(\"a\", { red: 115, green: 230, blue: 214 }, 150))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[0m\");\n\t    expect(rainbow(\"aa\", { red: 115, green: 230, blue: 214 }, 150))\n", "      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;134;115;230ma\\u001B[0m\");\n\t    expect(rainbow(\"aaa\", { red: 115, green: 230, blue: 214 }, 150))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;134;115;230ma\\u001B[38;2;230;115;176ma\\u001B[0m\");\n\t    expect(rainbow(\"aaaaa\", { red: 115, green: 230, blue: 214 }, 150))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;134;115;230ma\\u001B[38;2;230;115;176ma\\u001B[38;2;230;204;115ma\\u001B[38;2;115;230;124ma\\u001B[0m\");\n\t    expect(rainbow(\"aa     aa\", { red: 115, green: 230, blue: 214 }, 150))\n\t      .toBe(\"\\u001B[38;2;115;230;214ma\\u001B[38;2;134;115;230ma     \\u001B[38;2;230;115;176ma\\u001B[38;2;230;204;115ma\\u001B[0m\");\n\t    expect(rainbow(\"     aa\", { red: 115, green: 230, blue: 214 }, 150))\n\t      .toBe(\"     \\u001B[38;2;115;230;214ma\\u001B[38;2;134;115;230ma\\u001B[0m\");\n\t  });\n", "  it(\"should throw an error\", () => {\n\t    expect(() => rainbow(\"\", { red: -1, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`-1`, green=`0`, blue=`0`\");\n\t    expect(() => rainbow(\"\", { red: 0, green: -1, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`-1`, blue=`0`\");\n\t    expect(() => rainbow(\"\", { red: 0, green: 0, blue: -1 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`0`, blue=`-1`\");\n\t    expect(() => rainbow(\"\", { red: 256, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`256`, green=`0`, blue=`0`\");\n\t    expect(() => rainbow(\"\", { red: 0, green: 256, blue: 0 }))\n", "      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`256`, blue=`0`\");\n\t    expect(() => rainbow(\"\", { red: 0, green: 0, blue: 256 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`0`, blue=`256`\");\n\t  });\n\t});\n\tdescribe(\"`format` function\", () => {\n\t  it(\"should return a formatted string with default values passed in parameters replace by their replacement\", () => {\n\t    expect(format(\"\")).toBe(\"\");\n\t    expect(format(\"a\")).toBe(\"a\");\n\t    expect(format(\"aa\")).toBe(\"aa\");\n", "    expect(format(\"§2aa\")).toBe(\"\\u001B[32maa\");\n\t    expect(format(\"§a2a\")).toBe(\"§a2a\");\n\t    expect(format(\"§2§baa\")).toBe(\"\\u001B[32m\\u001B[1maa\");\n\t  });\n\t  it(\"should return a formatted string with custom values passed in parameters replace by their replacement\", () => {\n\t    const formatConfig: FormatConfig = {\n\t      \"§1\": forground.black,\n\t      \"§2\": `§${forground.red}`,\n\t      \"§3\": `§${forground.green}`,\n\t      \"§4\": `§${forground.yellow}`\n", "    };\n\t    expect(format(\"\", formatConfig)).toBe(\"\");\n\t    expect(format(\"a\", formatConfig)).toBe(\"a\");\n\t    expect(format(\"aa\", formatConfig)).toBe(\"aa\");\n\t    expect(format(\"§2aa\", formatConfig)).toBe(\"§\\u001B[31maa\");\n\t    expect(format(\"§a2a\", formatConfig)).toBe(\"§a2a\");\n\t    expect(format(\"§2§baa\", formatConfig)).toBe(\"§\\u001B[31m§baa\");\n\t  });\n\t  it(\"should return a formatted string with custom & default values passed in parameters replace by their replacement\", () => {\n\t    const formatConfig: FormatConfig = {\n", "      ...defaultFormatConfig,\n\t      \"§1\": forground.black,\n\t      \"§2\": `§${forground.red}`,\n\t      \"§3\": `§${forground.green}`,\n\t      \"§4\": `§${forground.yellow}`\n\t    };\n\t    expect(format(\"\", formatConfig)).toBe(\"\");\n\t    expect(format(\"a\", formatConfig)).toBe(\"a\");\n\t    expect(format(\"aa\", formatConfig)).toBe(\"aa\");\n\t    expect(format(\"§2aa\", formatConfig)).toBe(\"§\\u001B[31maa\");\n", "    expect(format(\"§a2a\", formatConfig)).toBe(\"§a2a\");\n\t    expect(format(\"§2§baa\", formatConfig)).toBe(\"§\\u001B[31m\\u001B[1maa\");\n\t  });\n\t});"]}
{"filename": "src/utils/color/color.validator.ts", "chunked_list": ["import { HexColor, RGB } from \"./color.type\";\n\texport const isRGBValues = (color: RGB): boolean => {\n\t  return isInRGBRange(color.red) && isInRGBRange(color.green) && isInRGBRange(color.blue);\n\t};\n\texport const isInRGBRange = (value: number): boolean => Number.isInteger(value) && value >= 0 && value <= 255;\n\texport const isHexColor = (value: string): value is HexColor => (/^#?([0-9a-f]{6}|[0-9a-f]{3})$/i).test(value);"]}
{"filename": "src/utils/color/color.util.ts", "chunked_list": ["import { isHexColor } from \"./color.validator\";\n\timport { HexColor, RGB } from \"./color.type\";\n\texport const hexToRgb = (hex: HexColor): RGB => {\n\t  if (!isHexColor(hex)) throw new Error(`\\`${hex}\\` isn't a hexadecimal color code`);\n\t  let code = hex.replace(\"#\", \"\");\n\t  if (code.length === 3) code = code.split(\"\").map(value => `${value}${value}`).join(\"\");\n\t  const red = code.slice(0, 2);\n\t  const green = code.slice(2, 4);\n\t  const blue = code.slice(4, 6);\n\t  return {\n", "    red: parseInt(red, 16),\n\t    green: parseInt(green, 16),\n\t    blue: parseInt(blue, 16)\n\t  };\n\t};\n\texport const removeEscapeSequence = (string: string): string => {\n\t  return string.replace(/\\u001B\\[([0-9;]*)m/g, \"\");\n\t};"]}
{"filename": "src/utils/color/index.ts", "chunked_list": ["export * from \"./color.type\";\n\texport * from \"./color.util\";\n\texport * from \"./color.validator\";"]}
{"filename": "src/utils/color/color.type.ts", "chunked_list": ["export type HexColor = `#${string}`;\n\texport type RGB = {\n\t  red: number;\n\t  green: number;\n\t  blue: number;\n\t}"]}
{"filename": "src/utils/color/_test/color.validator.test.ts", "chunked_list": ["import { isHexColor, isInRGBRange, isRGBValues } from \"../color.validator\";\n\timport { describe, expect, it } from \"vitest\";\n\tdescribe(\"`isRGBValues` function\", () => {\n\t  it(\"should be true\", () => {\n\t    expect(isRGBValues({ red: 0, green: 0, blue: 0 })).toBeTruthy();\n\t    expect(isRGBValues({ red: 255, green: 255, blue: 255 })).toBeTruthy();\n\t    expect(isRGBValues({ red: 0, green: 1, blue: 2 })).toBeTruthy();\n\t    expect(isRGBValues({ red: 1, green: 0, blue: 2 })).toBeTruthy();\n\t    expect(isRGBValues({ red: 1, green: 2, blue: 0 })).toBeTruthy();\n\t  });\n", "  it(\"should be false\", () => {\n\t    expect(isRGBValues({ red: -1, green: -1, blue: -1 })).toBeFalsy();\n\t    expect(isRGBValues({ red: 256, green: 256, blue: 256 })).toBeFalsy();\n\t    expect(isRGBValues({ red: -1, green: 0, blue: 0 })).toBeFalsy();\n\t    expect(isRGBValues({ red: 0, green: -1, blue: 0 })).toBeFalsy();\n\t    expect(isRGBValues({ red: 0, green: 0, blue: -1 })).toBeFalsy();\n\t  });\n\t});\n\tdescribe(\"`isInRGBRange` function\", () => {\n\t  it(\"should be true\", () => {\n", "    expect(isInRGBRange(0)).toBeTruthy();\n\t    expect(isInRGBRange(128)).toBeTruthy();\n\t    expect(isInRGBRange(255)).toBeTruthy();\n\t  });\n\t  it(\"should be false\", () => {\n\t    expect(isInRGBRange(-1)).toBeFalsy();\n\t    expect(isInRGBRange(256)).toBeFalsy();\n\t  });\n\t});\n\tdescribe(\"`isHexColor` function\", () => {\n", "  it(\"should be true\", () => {\n\t    expect(isHexColor(\"#009\")).toBeTruthy();\n\t    expect(isHexColor(\"#AAF\")).toBeTruthy();\n\t    expect(isHexColor(\"#aaf\")).toBeTruthy();\n\t    expect(isHexColor(\"#aAf\")).toBeTruthy();\n\t    expect(isHexColor(\"#000999\")).toBeTruthy();\n\t    expect(isHexColor(\"#AAAFFF\")).toBeTruthy();\n\t    expect(isHexColor(\"#aaafff\")).toBeTruthy();\n\t    expect(isHexColor(\"#aaAFff\")).toBeTruthy();\n\t  });\n", "  it(\"should be false\", () => {\n\t    expect(isHexColor(\"\")).toBeFalsy();\n\t    expect(isHexColor(\"#\")).toBeFalsy();\n\t    expect(isHexColor(\"#0\")).toBeFalsy();\n\t    expect(isHexColor(\"#00\")).toBeFalsy();\n\t    expect(isHexColor(\"#0000\")).toBeFalsy();\n\t    expect(isHexColor(\"#00000\")).toBeFalsy();\n\t    expect(isHexColor(\"#0000000\")).toBeFalsy();\n\t    expect(isHexColor(\"#0AG\")).toBeFalsy();\n\t    expect(isHexColor(\"#0000AG\")).toBeFalsy();\n", "    expect(isHexColor(\"#0-_\")).toBeFalsy();\n\t    expect(isHexColor(\"00000G\")).toBeFalsy();\n\t    expect(isHexColor(\"00G\")).toBeFalsy();\n\t  });\n\t});"]}
{"filename": "src/utils/color/_test/color.util.test.ts", "chunked_list": ["import { RGB } from \"../color.type\";\n\timport { hexToRgb, removeEscapeSequence } from \"../color.util\";\n\timport { describe, expect, it } from \"vitest\";\n\tdescribe(\"`hexToRgb` function\", () => {\n\t  it(\"should return RGB\", () => {\n\t    expect(hexToRgb(\"#000\")).toStrictEqual<RGB>({ red: 0, green: 0, blue: 0 });\n\t    expect(hexToRgb(\"#000000\")).toStrictEqual<RGB>({ red: 0, green: 0, blue: 0 });\n\t    expect(hexToRgb(\"#FFF\")).toStrictEqual<RGB>({ red: 255, green: 255, blue: 255 });\n\t    expect(hexToRgb(\"#FFFFFF\")).toStrictEqual<RGB>({ red: 255, green: 255, blue: 255 });\n\t    expect(hexToRgb(\"#497\")).toStrictEqual<RGB>({ red: 68, green: 153, blue: 119 });\n", "    expect(hexToRgb(\"#4b9976\")).toStrictEqual<RGB>({ red: 75, green: 153, blue: 118 });\n\t  });\n\t  it(\"should throw an error\", () => {\n\t    expect(() => hexToRgb(\"#\")).toThrow(\"`#` isn't a hexadecimal color code\");\n\t    expect(() => hexToRgb(\"#0\")).toThrow(\"`#0` isn't a hexadecimal color code\");\n\t    expect(() => hexToRgb(\"#00\")).toThrow(\"`#00` isn't a hexadecimal color code\");\n\t    expect(() => hexToRgb(\"#0000\")).toThrow(\"`#0000` isn't a hexadecimal color code\");\n\t    expect(() => hexToRgb(\"#00000\")).toThrow(\"`#00000` isn't a hexadecimal color code\");\n\t    expect(() => hexToRgb(\"#0000000\")).toThrow(\"`#0000000` isn't a hexadecimal color code\");\n\t    expect(() => hexToRgb(\"#0AG\")).toThrow(\"`#0AG` isn't a hexadecimal color code\");\n", "    expect(() => hexToRgb(\"#0000AG\")).toThrow(\"`#0000AG` isn't a hexadecimal color code\");\n\t    expect(() => hexToRgb(\"#0-_\")).toThrow(\"`#0-_` isn't a hexadecimal color code\");\n\t  });\n\t});\n\tdescribe(\"`removeEscapeSequence` function\", () => {\n\t  it(\"should return a string without ANSI escape sequences\", () => {\n\t    expect(removeEscapeSequence(\"\\u001B[0ma\")).toBe(\"a\");\n\t    expect(removeEscapeSequence(\"a\\u001B[0ma\")).toBe(\"aa\");\n\t    expect(removeEscapeSequence(\"\\u001B[0ma\\u001B[0ma\")).toBe(\"aa\");\n\t    expect(removeEscapeSequence(\"a\\u001B[0ma\\u001B[0ma\")).toBe(\"aaa\");\n", "    expect(removeEscapeSequence(\"a\\u001B[0;1ma\")).toBe(\"aa\");\n\t    expect(removeEscapeSequence(\"a\\u001B[0;1;12ma\")).toBe(\"aa\");\n\t    expect(removeEscapeSequence(\"a\\u001B[0;1;12;123ma\")).toBe(\"aa\");\n\t    expect(removeEscapeSequence(\"a\\u001B[0;1;12;123;1234ma\")).toBe(\"aa\");\n\t    expect(removeEscapeSequence(\"a\\u001B[0;1;12;123;1234;1345ma\")).toBe(\"aa\");\n\t  });\n\t});"]}
{"filename": "src/colors/colors.ts", "chunked_list": ["import { Background256, BackgroundRGB, Forground256, ForgroundRGB } from \"./colors.type\";\n\timport { closeANSI, openANSI } from \"./colors.const\";\n\timport { RGB, isInRGBRange, isRGBValues } from \"#/utils/color\";\n\texport const forgroundRGBColor = (color: RGB): ForgroundRGB => {\n\t  if (!isRGBValues(color)) {\n\t    throw new Error(`Invalid RGB values. Values must be in [0, 255]: red=\\`${color.red}\\`, green=\\`${color.green}\\`, blue=\\`${color.blue}\\``);\n\t  }\n\t  return `${openANSI}38;2;${color.red};${color.green};${color.blue}${closeANSI}`;\n\t};\n\texport const backgroundRGBColor = (color: RGB): BackgroundRGB => {\n", "  if (!isRGBValues(color)) {\n\t    throw new Error(`Invalid RGB values. Values must be in [0, 255]: red=\\`${color.red}\\`, green=\\`${color.green}\\`, blue=\\`${color.blue}\\``);\n\t  }\n\t  return `${openANSI}48;2;${color.red};${color.green};${color.blue}${closeANSI}`;\n\t};\n\texport const forground256Color = (colorId: number): Forground256 => {\n\t  if (!isInRGBRange(colorId)) {\n\t    throw new Error(`Invalid colorId. Value must be in [0, 255]: colorId=\\`${colorId}\\``);\n\t  }\n\t  return `${openANSI}38;5;${colorId}${closeANSI}`;\n", "};\n\texport const background256Color = (colorId: number): Background256 => {\n\t  if (!isInRGBRange(colorId)) {\n\t    throw new Error(`Invalid colorId. Value must be in [0, 255]: colorId=\\`${colorId}\\``);\n\t  }\n\t  return `${openANSI}48;5;${colorId}${closeANSI}`;\n\t};"]}
{"filename": "src/colors/colors.const.ts", "chunked_list": ["export const openANSI = \"\\u001B[\";\n\texport const closeANSI = \"m\";\n\texport const effect = {\n\t  bold: `${openANSI}1${closeANSI}`,\n\t  thin: `${openANSI}2${closeANSI}`,\n\t  italic: `${openANSI}3${closeANSI}`,\n\t  underline: `${openANSI}4${closeANSI}`,\n\t  blink: `${openANSI}5${closeANSI}`,\n\t  reverse: `${openANSI}7${closeANSI}`,\n\t  hidden: `${openANSI}8${closeANSI}`,\n", "  strikethrough: `${openANSI}9${closeANSI}`\n\t} as const;\n\texport const effectReset = {\n\t  all: `${openANSI}0${closeANSI}`,\n\t  bold: `${openANSI}22${closeANSI}`,\n\t  thin: `${openANSI}22${closeANSI}`,\n\t  italic: `${openANSI}23${closeANSI}`,\n\t  underline: `${openANSI}24${closeANSI}`,\n\t  blink: `${openANSI}25${closeANSI}`,\n\t  reverse: `${openANSI}27${closeANSI}`,\n", "  hidden: `${openANSI}28${closeANSI}`,\n\t  strikethrough: `${openANSI}29${closeANSI}`\n\t} as const;\n\texport const forground = {\n\t  black: `${openANSI}30${closeANSI}`,\n\t  red: `${openANSI}31${closeANSI}`,\n\t  green: `${openANSI}32${closeANSI}`,\n\t  yellow: `${openANSI}33${closeANSI}`,\n\t  blue: `${openANSI}34${closeANSI}`,\n\t  magenta: `${openANSI}35${closeANSI}`,\n", "  cyan: `${openANSI}36${closeANSI}`,\n\t  white: `${openANSI}37${closeANSI}`,\n\t  default: `${openANSI}39${closeANSI}`\n\t} as const;\n\texport const brightForground = {\n\t  black: `${openANSI}90${closeANSI}`,\n\t  red: `${openANSI}91${closeANSI}`,\n\t  green: `${openANSI}92${closeANSI}`,\n\t  yellow: `${openANSI}93${closeANSI}`,\n\t  blue: `${openANSI}94${closeANSI}`,\n", "  magenta: `${openANSI}95${closeANSI}`,\n\t  cyan: `${openANSI}96${closeANSI}`,\n\t  white: `${openANSI}97${closeANSI}`\n\t} as const;\n\texport const background = {\n\t  black: `${openANSI}40${closeANSI}`,\n\t  red: `${openANSI}41${closeANSI}`,\n\t  green: `${openANSI}42${closeANSI}`,\n\t  yellow: `${openANSI}43${closeANSI}`,\n\t  blue: `${openANSI}44${closeANSI}`,\n", "  magenta: `${openANSI}45${closeANSI}`,\n\t  cyan: `${openANSI}46${closeANSI}`,\n\t  white: `${openANSI}47${closeANSI}`,\n\t  default: `${openANSI}49${closeANSI}`\n\t} as const;\n\texport const brightBackground = {\n\t  black: `${openANSI}100${closeANSI}`,\n\t  red: `${openANSI}101${closeANSI}`,\n\t  green: `${openANSI}102${closeANSI}`,\n\t  yellow: `${openANSI}103${closeANSI}`,\n", "  blue: `${openANSI}104${closeANSI}`,\n\t  magenta: `${openANSI}105${closeANSI}`,\n\t  cyan: `${openANSI}106${closeANSI}`,\n\t  white: `${openANSI}107${closeANSI}`\n\t} as const;"]}
{"filename": "src/colors/colors.type.ts", "chunked_list": ["import { background, brightBackground, brightForground, closeANSI, effect, effectReset, forground, openANSI } from \"./colors.const\";\n\texport type ForgroundRGB = `${typeof openANSI}38;2;${number};${number};${number}${typeof closeANSI}`;\n\texport type BackgroundRGB = `${typeof openANSI}48;2;${number};${number};${number}${typeof closeANSI}`;\n\texport type Forground256 = `${typeof openANSI}38;5;${number}${typeof closeANSI}`;\n\texport type Background256 = `${typeof openANSI}48;5;${number}${typeof closeANSI}`;\n\ttype Keys<T> = keyof T\n\ttype Values<T> = T[Keys<T>]\n\texport type EffectKeys = Keys<typeof effect>\n\texport type EffectValues = Values<typeof effect>\n\texport type EffectResetKeys = Keys<typeof effectReset>\n", "export type EffectResetValues = Values<typeof effectReset>\n\texport type ForgroundKeys = Keys<typeof forground>\n\texport type ForgroundValues = Values<typeof forground>\n\texport type BrightForgroundKeys = Keys<typeof brightForground>\n\texport type BrightForgroundValues = Values<typeof brightForground>\n\texport type BackgroundKeys = Keys<typeof background>\n\texport type BackgroundValues = Values<typeof background>\n\texport type BrightBackgroundKeys = Keys<typeof brightBackground>\n\texport type BrightBackgroundValues = Values<typeof brightBackground>"]}
{"filename": "src/colors/index.ts", "chunked_list": ["export * from \"./colors.const\";\n\texport * from \"./colors\";\n\texport * from \"./colors.type\";"]}
{"filename": "src/colors/_test/color.test.ts", "chunked_list": ["import { background256Color, backgroundRGBColor, forground256Color, forgroundRGBColor } from \"../colors\";\n\timport { describe, expect, it } from \"vitest\";\n\tdescribe(\"`forgroundRGBColor` function\", () => {\n\t  it(\"should return an escape sequence\", () => {\n\t    expect(forgroundRGBColor({ red: 0, green: 0, blue: 0 })).toBe(\"\\x1b[38;2;0;0;0m\");\n\t    expect(forgroundRGBColor({ red: 255, green: 255, blue: 255 })).toBe(\"\\x1b[38;2;255;255;255m\");\n\t    expect(forgroundRGBColor({ red: 0, green: 1, blue: 1 })).toBe(\"\\x1b[38;2;0;1;1m\");\n\t    expect(forgroundRGBColor({ red: 1, green: 0, blue: 1 })).toBe(\"\\x1b[38;2;1;0;1m\");\n\t    expect(forgroundRGBColor({ red: 1, green: 1, blue: 0 })).toBe(\"\\x1b[38;2;1;1;0m\");\n\t  });\n", "  it(\"should throw an error\", () => {\n\t    expect(() => forgroundRGBColor({ red: -1, green: -1, blue: -1 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`-1`, green=`-1`, blue=`-1`\");\n\t    expect(() => forgroundRGBColor({ red: 256, green: 256, blue: 256 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`256`, green=`256`, blue=`256`\");\n\t    expect(() => forgroundRGBColor({ red: -1, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`-1`, green=`0`, blue=`0`\");\n\t    expect(() => forgroundRGBColor({ red: 0, green: -1, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`-1`, blue=`0`\");\n\t    expect(() => forgroundRGBColor({ red: 0, green: 0, blue: -1 }))\n", "      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`0`, blue=`-1`\");\n\t  });\n\t});\n\tdescribe(\"`backgroundRGBColor` function\", () => {\n\t  it(\"should return an escape sequence\", () => {\n\t    expect(backgroundRGBColor({ red: 0, green: 0, blue: 0 })).toBe(\"\\x1b[48;2;0;0;0m\");\n\t    expect(backgroundRGBColor({ red: 255, green: 255, blue: 255 })).toBe(\"\\x1b[48;2;255;255;255m\");\n\t    expect(backgroundRGBColor({ red: 0, green: 1, blue: 1 })).toBe(\"\\x1b[48;2;0;1;1m\");\n\t    expect(backgroundRGBColor({ red: 1, green: 0, blue: 1 })).toBe(\"\\x1b[48;2;1;0;1m\");\n\t    expect(backgroundRGBColor({ red: 1, green: 1, blue: 0 })).toBe(\"\\x1b[48;2;1;1;0m\");\n", "  });\n\t  it(\"should throw an error\", () => {\n\t    expect(() => backgroundRGBColor({ red: -1, green: -1, blue: -1 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`-1`, green=`-1`, blue=`-1`\");\n\t    expect(() => backgroundRGBColor({ red: 256, green: 256, blue: 256 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`256`, green=`256`, blue=`256`\");\n\t    expect(() => backgroundRGBColor({ red: -1, green: 0, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`-1`, green=`0`, blue=`0`\");\n\t    expect(() => backgroundRGBColor({ red: 0, green: -1, blue: 0 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`-1`, blue=`0`\");\n", "    expect(() => backgroundRGBColor({ red: 0, green: 0, blue: -1 }))\n\t      .toThrow(\"Invalid RGB values. Values must be in [0, 255]: red=`0`, green=`0`, blue=`-1`\");\n\t  });\n\t});\n\tdescribe(\"`forground256Color` function\", () => {\n\t  it(\"should return an escape sequence\", () => {\n\t    expect(forground256Color(0)).toBe(\"\\x1b[38;5;0m\");\n\t    expect(forground256Color(128)).toBe(\"\\x1b[38;5;128m\");\n\t    expect(forground256Color(255)).toBe(\"\\x1b[38;5;255m\");\n\t  });\n", "  it(\"should throw an error\", () => {\n\t    expect(() => forground256Color(-1)).toThrow(\"Invalid colorId. Value must be in [0, 255]: colorId=`-1`\");\n\t    expect(() => forground256Color(256)).toThrow(\"Invalid colorId. Value must be in [0, 255]: colorId=`256`\");\n\t  });\n\t});\n\tdescribe(\"`backround256Color` function\", () => {\n\t  it(\"should return an escape sequence\", () => {\n\t    expect(background256Color(0)).toBe(\"\\x1b[48;5;0m\");\n\t    expect(background256Color(128)).toBe(\"\\x1b[48;5;128m\");\n\t    expect(background256Color(255)).toBe(\"\\x1b[48;5;255m\");\n", "  });\n\t  it(\"should throw an error\", () => {\n\t    expect(() => background256Color(-1)).toThrow(\"Invalid colorId. Value must be in [0, 255]: colorId=`-1`\");\n\t    expect(() => background256Color(256)).toThrow(\"Invalid colorId. Value must be in [0, 255]: colorId=`256`\");\n\t  });\n\t});"]}
