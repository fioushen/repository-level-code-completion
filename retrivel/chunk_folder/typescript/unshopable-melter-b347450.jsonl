{"filename": "tsup.config.ts", "chunked_list": ["import type { Options } from 'tsup';\n\tconst tsupConfig: Options = {\n\t  entryPoints: ['src/index.ts'],\n\t  clean: true,\n\t  format: ['cjs', 'esm'],\n\t  dts: true,\n\t};\n\texport default tsupConfig;\n"]}
{"filename": "src/Watcher.ts", "chunked_list": ["import * as chokidar from 'chokidar';\n\timport * as fs from 'fs';\n\timport { Compiler } from './Compiler';\n\tinterface WatchOptions extends chokidar.WatchOptions {}\n\texport class Watcher {\n\t  compiler: Compiler;\n\t  watcher: chokidar.FSWatcher | null;\n\t  watcherPath: string;\n\t  watchOptions: WatchOptions;\n\t  initial: boolean;\n", "  initialAssetPaths: Set<string>;\n\t  constructor(compiler: Compiler, watcherPath: string, watchOptions: WatchOptions) {\n\t    this.compiler = compiler;\n\t    this.watcher = null;\n\t    this.watcherPath = watcherPath;\n\t    this.watchOptions = watchOptions;\n\t    this.initial = true;\n\t    this.initialAssetPaths = new Set<string>();\n\t  }\n\t  start() {\n", "    if (this.watchOptions.persistent) {\n\t      // Chokidar is not really watching without `persistent` being `true` so we do not want\n\t      // to call the `watcherStart` hook in this case.\n\t      this.compiler.hooks.watcherStart.call();\n\t    }\n\t    this.watcher = chokidar.watch(this.watcherPath, this.watchOptions);\n\t    this.watcher.on('add', (path: string, stats: fs.Stats) => {\n\t      if (this.initial) {\n\t        this.initialAssetPaths.add(path);\n\t        return;\n", "      }\n\t      this.compiler.compile('add', new Set([path]));\n\t    });\n\t    this.watcher.on('change', (path: string, stats: fs.Stats) => {\n\t      this.compiler.compile('update', new Set([path]));\n\t    });\n\t    this.watcher.on('unlink', (path: string, stats: fs.Stats) => {\n\t      this.compiler.compile('remove', new Set([path]));\n\t    });\n\t    this.watcher.on('ready', () => {\n", "      this.initial = false;\n\t      this.compiler.compile('add', this.initialAssetPaths);\n\t    });\n\t  }\n\t  async close() {\n\t    if (this.watcher) {\n\t      await this.watcher.close();\n\t      this.compiler.hooks.watcherClose.call();\n\t    }\n\t  }\n", "}\n"]}
{"filename": "src/Asset.ts", "chunked_list": ["import * as fs from 'fs-extra';\n\timport { CompilerEvent } from './Compiler';\n\texport type AssetType =\n\t  | 'assets'\n\t  | 'config'\n\t  | 'layout'\n\t  | 'locales'\n\t  | 'sections'\n\t  | 'snippets'\n\t  | 'templates';\n", "export type AssetPath = {\n\t  absolute: string;\n\t  relative: string;\n\t};\n\texport class Asset {\n\t  /**\n\t   * The type of the asset.\n\t   */\n\t  type: AssetType;\n\t  /**\n", "   * The absolute and relative path to the asset's file.\n\t   */\n\t  source: AssetPath;\n\t  /**\n\t   * The absolute and relative path to the asset's file.\n\t   */\n\t  target?: AssetPath;\n\t  /**\n\t   * A set of assets the asset is linked with.\n\t   */\n", "  links: Set<Asset>;\n\t  /**\n\t   * The asset's content.\n\t   */\n\t  content: Buffer;\n\t  /**\n\t   * The action that created this asset.\n\t   */\n\t  action: CompilerEvent;\n\t  constructor(type: AssetType, source: AssetPath, links: Set<Asset>, action: CompilerEvent) {\n", "    this.type = type;\n\t    this.source = source;\n\t    this.links = new Set<Asset>(links);\n\t    this.content = this.getContent();\n\t    this.action = action;\n\t  }\n\t  private getContent() {\n\t    try {\n\t      return fs.readFileSync(this.source.absolute);\n\t    } catch {\n", "      return Buffer.from('');\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/Logger.ts", "chunked_list": ["export type LoggerDataType = 'warning' | 'error';\n\texport class Logger {\n\t  success(message: string) {\n\t    console.log(this.formatSuccess(message));\n\t    console.log('');\n\t  }\n\t  warning(message: string, data: string[]) {\n\t    console.log(this.formatWarning(message));\n\t    if (data.length > 0) {\n\t      console.log('');\n", "      console.log(this.formatLogData('warning', data));\n\t      console.log('');\n\t    }\n\t  }\n\t  error(message: string, data: string[]) {\n\t    console.log(this.formatError(message));\n\t    if (data.length > 0) {\n\t      console.log('');\n\t      console.log(this.formatLogData('error', data));\n\t      console.log('');\n", "    }\n\t  }\n\t  private formatSuccess(message: string): string {\n\t    return `\\x1b[32m${message}\\x1b[0m`;\n\t  }\n\t  private formatWarning(message: string): string {\n\t    return `\\x1b[33m${message}\\x1b[0m`;\n\t  }\n\t  private formatError(message: string): string {\n\t    return `\\x1b[31m${message}\\x1b[0m`;\n", "  }\n\t  private formatLogData(type: LoggerDataType, data: string[]) {\n\t    const prefix = this.getPrefix(type);\n\t    return data.map((item) => `  ${prefix} ${item}`).join('\\n');\n\t  }\n\t  private getPrefix(type: LoggerDataType) {\n\t    const prefix = {\n\t      warning: this.formatWarning('⚠'),\n\t      error: this.formatError('✖'),\n\t    };\n", "    return prefix[type];\n\t  }\n\t}\n"]}
{"filename": "src/melter.ts", "chunked_list": ["import { Compiler } from './Compiler';\n\timport { MelterConfig } from './config';\n\timport { applyConfigDefaults } from './config/defaults';\n\texport function melter(config: MelterConfig) {\n\t  const compilerConfig = applyConfigDefaults(config);\n\t  const compiler = new Compiler(compilerConfig);\n\t  if (Array.isArray(compilerConfig.plugins)) {\n\t    for (const plugin of compilerConfig.plugins) {\n\t      plugin.apply(compiler);\n\t    }\n", "  }\n\t  return compiler;\n\t}\n"]}
{"filename": "src/Compilation.ts", "chunked_list": ["import * as path from 'path';\n\timport { SyncHook } from 'tapable';\n\timport { Asset } from './Asset';\n\timport { Compiler, CompilerEvent } from './Compiler';\n\texport type CompilationStats = {\n\t  /**\n\t   * The compilation time in milliseconds.\n\t   */\n\t  time: number;\n\t  /**\n", "   * A list of asset objects.\n\t   */\n\t  assets: Asset[];\n\t  /**\n\t   * A list of warnings.\n\t   */\n\t  warnings: string[];\n\t  /**\n\t   * A list of errors.\n\t   */\n", "  errors: string[];\n\t};\n\texport type CompilationHooks = {\n\t  beforeAddAsset: SyncHook<[Asset]>;\n\t  afterAddAsset: SyncHook<[Asset]>;\n\t};\n\texport class Compilation {\n\t  compiler: Compiler;\n\t  event: CompilerEvent;\n\t  assetPaths: Set<string>;\n", "  assets: Set<Asset>;\n\t  stats: CompilationStats;\n\t  hooks: Readonly<CompilationHooks>;\n\t  /**\n\t   * Creates an instance of `Compilation`.\n\t   *\n\t   * @param compiler The compiler which created the compilation.\n\t   * @param assetPaths A set of paths to assets that should be compiled.\n\t   */\n\t  constructor(compiler: Compiler, event: CompilerEvent, assetPaths: Set<string>) {\n", "    this.compiler = compiler;\n\t    this.event = event;\n\t    this.assetPaths = assetPaths;\n\t    this.assets = new Set<Asset>();\n\t    this.stats = {\n\t      time: 0,\n\t      assets: [],\n\t      warnings: [],\n\t      errors: [],\n\t    };\n", "    this.hooks = Object.freeze<CompilationHooks>({\n\t      beforeAddAsset: new SyncHook(['asset']),\n\t      afterAddAsset: new SyncHook(['asset']),\n\t    });\n\t  }\n\t  create() {\n\t    const startTime = performance.now();\n\t    this.assetPaths.forEach((assetPath) => {\n\t      const assetType = 'sections';\n\t      const sourcePath = {\n", "        absolute: path.resolve(this.compiler.cwd, assetPath),\n\t        relative: assetPath,\n\t      };\n\t      const asset = new Asset(assetType, sourcePath, new Set(), this.event);\n\t      this.hooks.beforeAddAsset.call(asset);\n\t      this.assets.add(asset);\n\t      this.stats.assets.push(asset);\n\t      this.hooks.afterAddAsset.call(asset);\n\t    });\n\t    const endTime = performance.now();\n", "    this.stats.time = Number((endTime - startTime).toFixed(2));\n\t  }\n\t  addWarning(warning: string) {\n\t    this.stats.warnings.push(warning);\n\t  }\n\t  addError(error: string) {\n\t    this.stats.errors.push(error);\n\t  }\n\t}\n"]}
{"filename": "src/Plugin.ts", "chunked_list": ["import { Compiler } from './Compiler';\n\texport class Plugin {\n\t  apply(compiler: Compiler): void {}\n\t}\n"]}
{"filename": "src/Compiler.ts", "chunked_list": ["import { SyncHook } from 'tapable';\n\timport { Compilation, CompilationStats } from './Compilation';\n\timport { Emitter } from './Emitter';\n\timport { Logger } from './Logger';\n\timport { Watcher } from './Watcher';\n\timport { CompilerConfig } from './config';\n\texport type CompilerHooks = {\n\t  beforeCompile: SyncHook<[]>;\n\t  compilation: SyncHook<[Compilation]>;\n\t  afterCompile: SyncHook<[Compilation]>;\n", "  beforeEmit: SyncHook<[Compilation]>;\n\t  emitter: SyncHook<[Emitter]>;\n\t  afterEmit: SyncHook<[Compilation]>;\n\t  done: SyncHook<[CompilationStats]>;\n\t  watcherStart: SyncHook<[]>;\n\t  watcherClose: SyncHook<[]>;\n\t};\n\texport type CompilerEvent = 'add' | 'update' | 'remove';\n\texport class Compiler {\n\t  cwd: Readonly<string>;\n", "  config: Readonly<CompilerConfig>;\n\t  hooks: Readonly<CompilerHooks>;\n\t  watcher: Readonly<Watcher | null>;\n\t  logger: Readonly<Logger>;\n\t  constructor(config: CompilerConfig) {\n\t    this.cwd = process.cwd();\n\t    this.config = config;\n\t    this.hooks = Object.freeze<CompilerHooks>({\n\t      beforeCompile: new SyncHook(),\n\t      compilation: new SyncHook(['compilation']),\n", "      afterCompile: new SyncHook(['compilation']),\n\t      beforeEmit: new SyncHook(['compilation']),\n\t      emitter: new SyncHook(['emitter']),\n\t      afterEmit: new SyncHook(['compilation']),\n\t      done: new SyncHook(['stats']),\n\t      watcherStart: new SyncHook(),\n\t      watcherClose: new SyncHook(),\n\t    });\n\t    this.watcher = null;\n\t    this.logger = new Logger();\n", "  }\n\t  build() {\n\t    const watcher = new Watcher(this, this.config.input, {\n\t      cwd: this.cwd,\n\t      // Trigger build.\n\t      ignoreInitial: false,\n\t      // Do not listen for changes.\n\t      persistent: false,\n\t    });\n\t    watcher.start();\n", "  }\n\t  watch() {\n\t    this.watcher = new Watcher(this, this.config.input, {\n\t      cwd: this.cwd,\n\t      // Trigger an initial build.\n\t      ignoreInitial: false,\n\t      // Continously watch for changes.\n\t      persistent: true,\n\t    });\n\t    this.watcher.start();\n", "  }\n\t  compile(event: CompilerEvent, assetPaths: Set<string>) {\n\t    this.hooks.beforeCompile.call();\n\t    const compilation = new Compilation(this, event, assetPaths);\n\t    this.hooks.compilation.call(compilation);\n\t    compilation.create();\n\t    this.hooks.afterCompile.call(compilation);\n\t    // If no output directory is specified we do not want to emit assets.\n\t    if (this.config.output) {\n\t      this.hooks.beforeEmit.call(compilation);\n", "      const emitter = new Emitter(this, compilation);\n\t      this.hooks.emitter.call(emitter);\n\t      emitter.emit();\n\t      this.hooks.afterEmit.call(compilation);\n\t    }\n\t    this.hooks.done.call(compilation.stats);\n\t  }\n\t  close() {\n\t    if (this.watcher) {\n\t      // Close active watcher if compiler has one.\n", "      this.watcher.close();\n\t    }\n\t    process.exit();\n\t  }\n\t}\n"]}
{"filename": "src/Emitter.ts", "chunked_list": ["import * as fs from 'fs-extra';\n\timport { SyncHook } from 'tapable';\n\timport { Asset, AssetPath } from './Asset';\n\timport { Compilation } from './Compilation';\n\timport { Compiler } from './Compiler';\n\texport type EmitterHooks = Readonly<{\n\t  beforeAssetAction: SyncHook<[Asset]>;\n\t  afterAssetAction: SyncHook<[Asset]>;\n\t}>;\n\texport class Emitter {\n", "  compiler: Compiler;\n\t  compilation: Compilation;\n\t  hooks: EmitterHooks;\n\t  constructor(compiler: Compiler, compilation: Compilation) {\n\t    this.compiler = compiler;\n\t    this.compilation = compilation;\n\t    this.hooks = {\n\t      beforeAssetAction: new SyncHook(['asset']),\n\t      afterAssetAction: new SyncHook(['asset']),\n\t    };\n", "  }\n\t  emit() {\n\t    this.compilation.assets.forEach((asset) => {\n\t      this.hooks.beforeAssetAction.call(asset);\n\t      if (typeof asset.target === 'undefined') {\n\t        this.compilation.addWarning(`Missing target path: '${asset.source.relative}'`);\n\t        return;\n\t      }\n\t      switch (asset.action) {\n\t        case 'add':\n", "        case 'update': {\n\t          this.writeFile(asset.target.absolute, asset.content);\n\t          break;\n\t        }\n\t        case 'remove': {\n\t          this.removeFile(asset.target.absolute);\n\t          break;\n\t        }\n\t        // No default.\n\t      }\n", "      this.hooks.afterAssetAction.call(asset);\n\t    });\n\t  }\n\t  private writeFile(targetPath: AssetPath['absolute'], content: Asset['content']) {\n\t    try {\n\t      fs.ensureFileSync(targetPath);\n\t      fs.writeFileSync(targetPath, content);\n\t    } catch (error: any) {\n\t      this.compilation.addError(error.message);\n\t    }\n", "  }\n\t  private removeFile(targetPath: AssetPath['absolute']) {\n\t    try {\n\t      fs.removeSync(targetPath);\n\t    } catch (error: any) {\n\t      this.compilation.addError(error.message);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './Asset';\n\texport * from './Compilation';\n\texport * from './Compiler';\n\texport * from './Emitter';\n\texport * from './Logger';\n\texport * from './Plugin';\n\texport * from './Watcher';\n\texport * from './config';\n\texport * from './melter';\n"]}
{"filename": "src/plugins/StatsPlugin.ts", "chunked_list": ["import { CompilationStats } from '../Compilation';\n\timport { Compiler } from '../Compiler';\n\timport { Plugin } from '../Plugin';\n\texport type StatsPluginConfig = {\n\t  stats?: boolean;\n\t};\n\texport class StatsPlugin extends Plugin {\n\t  config: StatsPluginConfig;\n\t  constructor(config: StatsPluginConfig = {}) {\n\t    super();\n", "    this.config = config;\n\t  }\n\t  apply(compiler: Compiler): void {\n\t    if (this.config.stats === false) return;\n\t    compiler.hooks.done.tap('StatsPlugin', (compilationStats: CompilationStats) => {\n\t      if (compilationStats.errors.length > 0) {\n\t        compiler.logger.error('Compilation failed', compilationStats.errors);\n\t      } else if (compilationStats.warnings.length > 0) {\n\t        compiler.logger.warning(\n\t          `Compiled with ${compilationStats.warnings.length} warnings`,\n", "          compilationStats.warnings,\n\t        );\n\t      } else {\n\t        compiler.logger.success(`Successfully compiled in ${compilationStats.time} ms`);\n\t      }\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/plugins/PathsPlugin.ts", "chunked_list": ["import * as path from 'path';\n\timport { Asset, AssetPath, AssetType } from '../Asset';\n\timport { Compiler } from '../Compiler';\n\timport { Emitter } from '../Emitter';\n\timport { Plugin } from '../Plugin';\n\ttype Paths = {\n\t  /**\n\t   * An array of paths pointing to files that should be processed as `assets`.\n\t   */\n\t  assets?: RegExp[];\n", "  /**\n\t   * An array of paths pointing to files that should be processed as `config`.\n\t   */\n\t  config?: RegExp[];\n\t  /**\n\t   * An array of paths pointing to files that should be processed as `layout`.\n\t   */\n\t  layout?: RegExp[];\n\t  /**\n\t   * An array of paths pointing to files that should be processed as `locales`.\n", "   */\n\t  locales?: RegExp[];\n\t  /**\n\t   * An array of paths pointing to files that should be processed as `sections`.\n\t   */\n\t  sections?: RegExp[];\n\t  /**\n\t   * An array of paths pointing to files that should be processed as `snippets`.\n\t   */\n\t  snippets?: RegExp[];\n", "  /**\n\t   * An array of paths pointing to files that should be processed as `templates`.\n\t   */\n\t  templates?: RegExp[];\n\t};\n\t/**\n\t * Path plugin configuration object.\n\t */\n\texport type PathsPluginConfig = {\n\t  /**\n", "   * A map of Shopify's directory structure and component types.\n\t   *\n\t   * @see [Shopify Docs Reference](https://shopify.dev/docs/themes/architecture#directory-structure-and-component-types)\n\t   */\n\t  paths?: Paths | false;\n\t};\n\tconst defaultPathsPluginConfig: PathsPluginConfig = {\n\t  paths: {\n\t    assets: [/assets\\/[^\\/]*\\.*$/],\n\t    config: [/config\\/[^\\/]*\\.json$/],\n", "    layout: [/layout\\/[^\\/]*\\.liquid$/],\n\t    locales: [/locales\\/[^\\/]*\\.json$/],\n\t    sections: [/sections\\/[^\\/]*\\.liquid$/],\n\t    snippets: [/snippets\\/[^\\/]*\\.liquid$/],\n\t    templates: [\n\t      /templates\\/[^\\/]*\\.liquid$/,\n\t      /templates\\/[^\\/]*\\.json$/,\n\t      /templates\\/customers\\/[^\\/]*\\.liquid$/,\n\t      /templates\\/customers\\/[^\\/]*\\.json$/,\n\t    ],\n", "  },\n\t};\n\texport class PathsPlugin extends Plugin {\n\t  config: PathsPluginConfig;\n\t  constructor(config: PathsPluginConfig) {\n\t    super();\n\t    this.config =\n\t      config.paths !== false\n\t        ? {\n\t            paths: {\n", "              ...defaultPathsPluginConfig.paths,\n\t              ...config.paths,\n\t            },\n\t          }\n\t        : {};\n\t  }\n\t  apply(compiler: Compiler): void {\n\t    const output = compiler.config.output;\n\t    if (!output) return;\n\t    const paths = this.config.paths;\n", "    if (!paths) return;\n\t    compiler.hooks.emitter.tap('PathsPlugin', (emitter: Emitter) => {\n\t      emitter.hooks.beforeAssetAction.tap('PathsPlugin', (asset: Asset) => {\n\t        const assetType = this.determineAssetType(paths, asset.source.relative);\n\t        if (!assetType) return;\n\t        asset.type = assetType;\n\t        const assetSourcePathParts = asset.source.relative.split('/');\n\t        let assetFilename: string = '';\n\t        if (assetSourcePathParts.at(-2) === 'customers') {\n\t          assetFilename = assetSourcePathParts.slice(-2).join('/');\n", "        } else {\n\t          assetFilename = assetSourcePathParts.at(-1)!;\n\t        }\n\t        const assetTargetPath = this.resolveAssetTargetPath(\n\t          compiler.cwd,\n\t          output,\n\t          assetType,\n\t          assetFilename,\n\t        );\n\t        asset.target = assetTargetPath;\n", "      });\n\t    });\n\t  }\n\t  private determineAssetType(paths: Paths, assetPath: string): AssetType | null {\n\t    const pathEntries = Object.entries(paths);\n\t    for (let i = 0; i < pathEntries.length; i += 1) {\n\t      const [name, patterns] = pathEntries[i];\n\t      for (let j = 0; j < patterns.length; j++) {\n\t        if (assetPath.match(patterns[j])) {\n\t          return name as AssetType;\n", "        }\n\t      }\n\t    }\n\t    return null;\n\t  }\n\t  private resolveAssetTargetPath(\n\t    cwd: string,\n\t    output: string,\n\t    assetType: AssetType,\n\t    filename: string,\n", "  ): AssetPath {\n\t    const relativeAssetTargetPath = path.resolve(output, assetType, filename);\n\t    const absoluteAssetTargetPath = path.resolve(cwd, relativeAssetTargetPath);\n\t    return {\n\t      absolute: absoluteAssetTargetPath,\n\t      relative: relativeAssetTargetPath,\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/utils/index.ts", "chunked_list": ["export function getFilenameFromPath(path: string): string {\n\t  return path.split('/').at(-1)!;\n\t}\n\t/**\n\t * Parses provided value and returns data if succeeded. Otherwise the corresponding error\n\t * will be returned.\n\t */\n\texport function parseJSON<T>(value: string): { data: T | null; error?: string } {\n\t  try {\n\t    return {\n", "      data: JSON.parse(value),\n\t    };\n\t  } catch (error: any) {\n\t    return {\n\t      data: null,\n\t      error: error.message,\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/config/defaults.ts", "chunked_list": ["import { CompilerConfig, MelterConfig, defaultBaseCompilerConfig } from '.';\n\timport { Plugin } from '../Plugin';\n\timport { PathsPlugin } from '../plugins/PathsPlugin';\n\timport { StatsPlugin } from '../plugins/StatsPlugin';\n\tfunction applyDefaultPlugins(config: CompilerConfig): Plugin[] {\n\t  const plugins = [];\n\t  plugins.push(\n\t    ...[\n\t      new StatsPlugin({\n\t        stats: config.stats,\n", "      }),\n\t      new PathsPlugin({\n\t        paths: config.paths,\n\t      }),\n\t    ],\n\t  );\n\t  return plugins;\n\t}\n\texport function applyConfigDefaults(config: MelterConfig): CompilerConfig {\n\t  const compilerConfig = {\n", "    ...defaultBaseCompilerConfig,\n\t    ...config,\n\t  };\n\t  compilerConfig.plugins = [...applyDefaultPlugins(compilerConfig), ...compilerConfig.plugins];\n\t  return compilerConfig;\n\t}\n"]}
{"filename": "src/config/index.ts", "chunked_list": ["import { Plugin } from '../Plugin';\n\timport { PathsPluginConfig } from '../plugins/PathsPlugin';\n\timport { StatsPluginConfig } from '../plugins/StatsPlugin';\n\texport * from './load';\n\texport type BaseCompilerConfig = {\n\t  /**\n\t   * Where to look for files to compile.\n\t   */\n\t  input: string;\n\t  /**\n", "   * Where to write the compiled files to. The emitter won't emit any assets if undefined.\n\t   */\n\t  output: string;\n\t  /**\n\t   * A list of additional plugins to add to the compiler.\n\t   */\n\t  plugins: Plugin[];\n\t};\n\texport const defaultBaseCompilerConfig: BaseCompilerConfig = {\n\t  input: 'src',\n", "  output: 'dist',\n\t  plugins: [],\n\t};\n\t/**\n\t * Compiler configuration object.\n\t */\n\texport type CompilerConfig = {} & BaseCompilerConfig & StatsPluginConfig & PathsPluginConfig;\n\t/**\n\t * Melter configuration object.\n\t *\n", " * @see [Configuration documentation](https://github.com/unshopable/melter#configuration)\n\t */\n\texport type MelterConfig = Partial<CompilerConfig>;\n"]}
{"filename": "src/config/load.ts", "chunked_list": ["import fg from 'fast-glob';\n\timport * as fs from 'fs-extra';\n\timport * as path from 'path';\n\timport { BaseCompilerConfig, MelterConfig, defaultBaseCompilerConfig } from '.';\n\timport { getFilenameFromPath, parseJSON } from '../utils';\n\tfunction getConfigFiles(cwd: string): string[] {\n\t  const configFilePattern = 'melter.config.*';\n\t  // flat-glob only supports POSIX path syntax, so we use convertPathToPattern() for windows\n\t  return fg.sync(fg.convertPathToPattern(cwd) + '/' + configFilePattern);\n\t}\n", "function parseConfigFile(file: string): { config: MelterConfig | null; errors: string[] } {\n\t  if (file.endsWith('json')) {\n\t    const content = fs.readFileSync(file, 'utf8');\n\t    const { data, error } = parseJSON<MelterConfig>(content);\n\t    if (error) {\n\t      return {\n\t        config: null,\n\t        errors: [error],\n\t      };\n\t    }\n", "    return {\n\t      config: data,\n\t      errors: [],\n\t    };\n\t  }\n\t  return {\n\t    config: require(file).default || require(file),\n\t    errors: [],\n\t  };\n\t}\n", "export function loadConfig(): {\n\t  config: MelterConfig | BaseCompilerConfig | null;\n\t  warnings: string[];\n\t  errors: string[];\n\t} {\n\t  const configFiles = getConfigFiles(process.cwd());\n\t  if (configFiles.length === 0) {\n\t    return {\n\t      config: defaultBaseCompilerConfig,\n\t      warnings: [\n", "        'No config found. Loaded default config. To disable this warning create a custom config.',\n\t      ],\n\t      errors: [],\n\t    };\n\t  }\n\t  const firstConfigFile = configFiles[0];\n\t  const warnings: string[] = [];\n\t  if (configFiles.length > 1) {\n\t    warnings.push(\n\t      `Multiple configs found. Loaded '${getFilenameFromPath(\n", "        firstConfigFile,\n\t      )}'. To disable this warning remove unused configs.`,\n\t    );\n\t  }\n\t  const { config, errors } = parseConfigFile(firstConfigFile);\n\t  return {\n\t    config,\n\t    warnings,\n\t    errors,\n\t  };\n", "}\n"]}
