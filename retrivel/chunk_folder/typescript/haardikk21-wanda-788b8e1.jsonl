{"filename": "vite.config.ts", "chunked_list": ["import { defineConfig } from \"vite\";\n\timport react from \"@vitejs/plugin-react\";\n\t// https://vitejs.dev/config/\n\texport default defineConfig({\n\t  define: {\n\t    global: \"globalThis\",\n\t  },\n\t  plugins: [react()],\n\t});\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './connectors'\n\texport * from './hooks'\n\texport * from './types'\n\texport { Provider } from './context'\n"]}
{"filename": "src/context.ts", "chunked_list": ["import React from 'react'\n\timport { Connector, Data, InjectedConnector } from './connectors'\n\ttype State = {\n\t  connector?: Connector\n\t  data?: Data\n\t  error?: Error\n\t}\n\ttype ContextValue = [\n\t  {\n\t    connectors: Connector[]\n", "    connector?: State['connector']\n\t    data?: State['data']\n\t  },\n\t  React.Dispatch<React.SetStateAction<State>>,\n\t]\n\texport const Context = React.createContext<ContextValue | null>(null)\n\ttype Props = {\n\t  connectors: Connector[]\n\t}\n\texport const Provider: React.FC<React.PropsWithChildren<Props>> = ({\n", "  children,\n\t  connectors = [new InjectedConnector()],\n\t}) => {\n\t  const [state, setState] = React.useState<State>({})\n\t  React.useEffect(() => {\n\t    if (!state.connector) return\n\t    const handleChange = (data: Data) => {\n\t      setState((state) => ({ ...state, data }))\n\t    }\n\t    state.connector.on('change', handleChange)\n", "    return () => {\n\t      if (!state.connector) return\n\t      state.connector.off('change', handleChange)\n\t    }\n\t  }, [state.connector])\n\t  // Close connectors when unmounting\n\t  React.useEffect(() => {\n\t    return () => {\n\t      if (!state.connector) return\n\t      state.connector.deactivate()\n", "    }\n\t  }, [state.connector])\n\t  const value = [\n\t    {\n\t      connectors,\n\t      connector: state.connector,\n\t      data: state.data,\n\t    },\n\t    setState,\n\t  ] as ContextValue\n", "  return React.createElement(Context.Provider, { value }, children)\n\t}\n"]}
{"filename": "src/connectors/types.ts", "chunked_list": ["import EventEmitter from 'events'\n\timport { ModelID } from '../types'\n\timport { WindowAiProvider } from '../types/declarations'\n\texport type Data = {\n\t  model?: ModelID\n\t  provider?: WindowAiProvider\n\t}\n\ttype EventMap = {\n\t  change: Data\n\t  disconnect: undefined\n", "  error: Error\n\t}\n\ttype EventKey<T extends EventMap> = string & keyof T\n\ttype EventReceiver<T> = (params: T) => void\n\tinterface IEmitter<T extends EventMap> {\n\t  on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void\n\t  off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void\n\t  emit<K extends EventKey<T>>(\n\t    eventName: K,\n\t    ...params: T[K] extends undefined ? [undefined?] : [T[K]]\n", "  ): void\n\t}\n\texport abstract class Emitter implements IEmitter<EventMap> {\n\t  private emitter = new EventEmitter()\n\t  on<K extends EventKey<EventMap>>(\n\t    eventName: K,\n\t    fn: EventReceiver<EventMap[K]>,\n\t  ): void {\n\t    this.emitter.on(eventName, fn)\n\t  }\n", "  off<K extends EventKey<EventMap>>(\n\t    eventName: K,\n\t    fn: EventReceiver<EventMap[K]>,\n\t  ): void {\n\t    this.emitter.off(eventName, fn)\n\t  }\n\t  emit<K extends EventKey<EventMap>>(\n\t    eventName: K,\n\t    ...params: EventMap[K] extends undefined ? [undefined?] : [EventMap[K]]\n\t  ): void {\n", "    this.emitter.emit(eventName, ...params)\n\t  }\n\t}\n\texport abstract class Connector extends Emitter {\n\t  abstract name: string\n\t  abstract activate(): Promise<Data>\n\t  abstract deactivate(): void\n\t  abstract getModel(): Promise<ModelID>\n\t  abstract getProvider(): Promise<WindowAiProvider>\n\t}\n"]}
{"filename": "src/connectors/injected.ts", "chunked_list": ["import { ErrorCode, EventType, ModelID } from '../types'\n\timport { WindowAiProvider } from '../types/declarations'\n\timport { Connector, Data } from './types'\n\texport class InjectedConnector extends Connector {\n\t  name = 'injected'\n\t  constructor() {\n\t    super()\n\t    this.handleEvent = this.handleEvent.bind(this)\n\t  }\n\t  async activate(): Promise<Data> {\n", "    if (!window.ai) throw Error(`window.ai not found`)\n\t    if (window.ai.addEventListener) {\n\t      window.ai.addEventListener(this.handleEvent)\n\t    }\n\t    try {\n\t      const model = await window.ai.getCurrentModel()\n\t      return { model, provider: window.ai }\n\t    } catch (error) {\n\t      throw Error(`activate failed`)\n\t    }\n", "  }\n\t  deactivate(): void {\n\t    // no-op\n\t    // Disconnect event listeners here once window.ai upstream has removeEventListener\n\t  }\n\t  async getModel(): Promise<ModelID> {\n\t    if (!window.ai) throw Error(`window.ai not found`)\n\t    try {\n\t      return await window.ai.getCurrentModel()\n\t    } catch {\n", "      throw Error('model not found')\n\t    }\n\t  }\n\t  async getProvider(): Promise<WindowAiProvider> {\n\t    if (!window.ai) throw Error(`window.ai not found`)\n\t    return window.ai\n\t  }\n\t  private handleEvent(event: EventType, data: unknown) {\n\t    if (event === EventType.ModelChanged) {\n\t      this.emit('change', { model: (<{ model: ModelID }>data).model })\n", "    } else if (event === EventType.Error) {\n\t      this.emit('error', Error(data as ErrorCode))\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/connectors/index.ts", "chunked_list": ["export { InjectedConnector } from './injected'\n\texport type { Connector, Data } from './types'\n"]}
{"filename": "src/hooks/useModel.ts", "chunked_list": ["import { useContext } from './useContext'\n\texport const useModel = () => {\n\t  const [state] = useContext()\n\t  return state.data?.model\n\t}\n"]}
{"filename": "src/hooks/useCompletion.ts", "chunked_list": ["import { useContext } from './useContext'\n\timport { CompletionOptions, Input } from '../types'\n\texport const useCompletion = () => {\n\t  const [state] = useContext()\n\t  const getCompletion = async <T extends Input>(\n\t    input: T,\n\t    options?: CompletionOptions<T>,\n\t  ) => {\n\t    const provider = await state.connector?.getProvider()\n\t    if (!provider) {\n", "      throw Error('No provider found')\n\t    }\n\t    return provider.getCompletion(input, options)\n\t  }\n\t  return { getCompletion }\n\t}\n"]}
{"filename": "src/hooks/useContext.ts", "chunked_list": ["import React from 'react'\n\timport { Context } from '../context'\n\texport const useContext = () => {\n\t  const context = React.useContext(Context)\n\t  if (!context) throw Error(`useContext must be used within a Provider`)\n\t  return context\n\t}\n"]}
{"filename": "src/hooks/index.ts", "chunked_list": ["export { useCompletion } from './useCompletion'\n\texport { useConnect } from './useConnect'\n\texport { useModel } from './useModel'\n"]}
{"filename": "src/hooks/useConnect.ts", "chunked_list": ["import { useCallback, useState } from 'react'\n\timport { useContext } from './useContext'\n\timport { Connector } from '../connectors'\n\ttype UseConnectState = {\n\t  connecting: boolean\n\t  error?: Error\n\t}\n\texport const useConnect = () => {\n\t  const [globalState, setGlobalState] = useContext()\n\t  const [state, setState] = useState<UseConnectState>({ connecting: false })\n", "  const connect = useCallback(\n\t    async (connector: Connector) => {\n\t      try {\n\t        if (connector === globalState.connector) return\n\t        setGlobalState((state) => ({ ...state, connector }))\n\t        setState((state) => ({ ...state, connecting: true, error: undefined }))\n\t        const data = await connector.activate()\n\t        setGlobalState((state) => ({ ...state, data }))\n\t      } catch (error) {\n\t        console.error(error)\n", "        setState((state) => ({ ...state, error: error as Error }))\n\t      } finally {\n\t        setState((state) => ({ ...state, connecting: false }))\n\t      }\n\t    },\n\t    [globalState.connector, setGlobalState],\n\t  )\n\t  return [\n\t    {\n\t      connecting: state.connecting,\n", "      connector: globalState.connector,\n\t      connectors: globalState.connectors,\n\t      error: state.error,\n\t    },\n\t    connect,\n\t  ] as const\n\t}\n"]}
{"filename": "src/types/index.ts", "chunked_list": ["export type Message = {\n\t  role: 'system' | 'user' | 'assistant'\n\t  content: string\n\t}\n\texport type PromptInput = {\n\t  prompt: string\n\t}\n\texport type MessagesInput = {\n\t  messages: Message[]\n\t}\n", "export type Input = PromptInput | MessagesInput\n\texport type TextOutput = {\n\t  text: string\n\t}\n\texport type MessageOutput = {\n\t  message: Message\n\t}\n\texport enum EventType {\n\t  ModelChanged = 'model_changed',\n\t  Error = 'error',\n", "}\n\texport enum ErrorCode {\n\t  NotAuthenticated = 'NOT_AUTHENTICATED',\n\t  PermissionDenied = 'PERMISSION_DENIED',\n\t  RequestNotFound = 'REQUEST_NOT_FOUND',\n\t  InvalidRequest = 'INVALID_REQUEST',\n\t  ModelRejectedRequest = 'MODEL_REJECTED_REQUEST',\n\t}\n\texport enum ModelID {\n\t  GPT3 = 'openai/gpt3.5',\n", "  GPT4 = 'openai/gpt4',\n\t  GPTNeo = 'together/gpt-neoxt-20B',\n\t  Cohere = 'cohere/xlarge',\n\t  Local = 'local',\n\t}\n\texport interface CompletionOptions<T extends Input> {\n\t  temperature?: number\n\t  numOutputs?: number\n\t  maxTokens?: number\n\t  stopSequences?: string[]\n", "  model?: ModelID\n\t  onStreamResult?: (\n\t    result: T extends PromptInput ? TextOutput : MessageOutput,\n\t    error: string | null,\n\t  ) => unknown\n\t}\n"]}
{"filename": "src/types/declarations.d.ts", "chunked_list": ["import {\n\t  CompletionOptions,\n\t  ErrorCode,\n\t  EventType,\n\t  Input,\n\t  MessageOutput,\n\t  ModelID,\n\t  PromptInput,\n\t  TextOutput,\n\t} from '.'\n", "interface WindowAiProvider {\n\t  getCurrentModel: () => Promise<ModelID>\n\t  getCompletion<T extends Input>(\n\t    input: T,\n\t    options?: CompletionOptions<T>,\n\t  ): Promise<T extends PromptInput ? TextOutput : MessageOutput>\n\t  addEventListener?<T>(\n\t    handler: (event: EventType, data: T | ErrorCode) => void,\n\t  ): string\n\t}\n", "declare global {\n\t  interface Window {\n\t    ai?: WindowAiProvider\n\t  }\n\t}\n"]}
