{"filename": "vitest.config.ts", "chunked_list": ["import { defineConfig } from 'vitest/config'\n\texport default defineConfig({\n\t  test: {\n\t    globals: true,\n\t    setupFiles: ['./test/setup'],\n\t    alias: {\n\t      'requete/shared': './src/shared.ts',\n\t      'requete/adapter': './src/adapter.ts',\n\t      'requete/middleware': './src/middleware.ts',\n\t      requete: './src/index.ts',\n", "    },\n\t  },\n\t})\n"]}
{"filename": "test/setup.ts", "chunked_list": ["import { vi } from 'vitest'\n\t// @ts-ignore\n\tglobal.XMLHttpRequest = vi.fn()\n"]}
{"filename": "test/utils.ts", "chunked_list": ["export function toAny(v: any) {\n\t  return v as any\n\t}\n\texport function sleep(ms: number) {\n\t  return new Promise((r) => setTimeout(r, ms))\n\t}\n"]}
{"filename": "src/shared.ts", "chunked_list": ["export * from './shared/headers'\n\texport * from './shared/logger'\n\texport * from './shared/pick'\n\texport * from './shared/progress'\n\texport * from './shared/RequestError'\n\texport * from './shared/transform'\n\texport * from './shared/url'\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { create } from './core/create'\n\texport default create()\n\texport * from './core/AbortController'\n\texport * from './core/create'\n\texport * from './core/Requete'\n\texport { FetchAdapter, XhrAdapter } from 'requete/adapter'\n\texport { RequestError } from 'requete/shared'\n"]}
{"filename": "src/middleware.ts", "chunked_list": ["export * from './middleware/timestamp'\n"]}
{"filename": "src/adapter.ts", "chunked_list": ["export * from './adapter/Adapter'\n\texport * from './adapter/create'\n\texport * from './adapter/FetchAdapter'\n\texport * from './adapter/XhrAdapter'\n"]}
{"filename": "src/shared/url.ts", "chunked_list": ["import type { IRequest, RequestQuery } from 'requete'\n\texport function stringifyUrl(url: string, query: RequestQuery, append = true) {\n\t  let searchParams: URLSearchParams\n\t  if (query instanceof URLSearchParams) {\n\t    searchParams = query\n\t  } else if (typeof query === 'string' || Array.isArray(query)) {\n\t    searchParams = new URLSearchParams(query)\n\t  } else {\n\t    searchParams = new URLSearchParams()\n\t    Object.entries(query).forEach(([key, value]) => {\n", "      if (Array.isArray(value)) {\n\t        value.forEach((val) => searchParams.append(key, val.toString()))\n\t      } else if (value != null) {\n\t        searchParams.set(key, value.toString())\n\t      }\n\t    })\n\t  }\n\t  const qIndex = url.indexOf('?')\n\t  if (qIndex === -1) return url + '?' + searchParams.toString()\n\t  if (append) return url + '&' + searchParams.toString()\n", "  else {\n\t    const params = new URLSearchParams(url.slice(qIndex))\n\t    searchParams.forEach((value, key) => params.set(key, value.toString()))\n\t    return url.slice(0, qIndex) + '?' + params.toString()\n\t  }\n\t}\n\tfunction isAbsolute(url: string) {\n\t  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url)\n\t}\n\texport function getUri(config: IRequest) {\n", "  let url = config.url\n\t  const hashIndex = url.indexOf('#')\n\t  if (hashIndex > -1) url = url.slice(0, hashIndex)\n\t  if (!isAbsolute(url) && config.baseURL) {\n\t    url = config.baseURL.replace(/\\/+$/, '') + '/' + url.replace(/^\\/+/, '')\n\t  }\n\t  if (config.params) {\n\t    url = stringifyUrl(url, config.params)\n\t  }\n\t  return url\n", "}\n"]}
{"filename": "src/shared/transform.ts", "chunked_list": ["import type { RequestBody } from 'requete'\n\texport function transformRequestBody(data?: RequestBody) {\n\t  const toString = Object.prototype.toString.call(data)\n\t  let requestBody: any = data\n\t  let contentType = ''\n\t  switch (toString) {\n\t    case '[object Undefined]':\n\t    case '[object Null]':\n\t      break\n\t    case '[object String]':\n", "    case '[object URLSearchParams]':\n\t      contentType = 'application/x-www-form-urlencoded;charset=utf-8'\n\t      break\n\t    case '[object FormData]':\n\t    case '[object Blob]':\n\t    case '[object ReadableStream]':\n\t    case '[object ArrayBuffer]':\n\t    case '[object DataView]':\n\t    case '[object BigInt64Array]':\n\t    case '[object BigUint64Array]':\n", "    case '[object Float32Array]':\n\t    case '[object Float64Array]':\n\t    case '[object Int8Array]':\n\t    case '[object Int16Array]':\n\t    case '[object Int32Array]':\n\t    case '[object Uint8Array]':\n\t    case '[object Uint8ClampedArray]':\n\t    case '[object Uint16Array]':\n\t    case '[object Uint32Array]':\n\t      contentType = 'multipart/form-data;charset=utf-8'\n", "      break\n\t    case '[object Object]':\n\t    case '[object Array]':\n\t      requestBody = JSON.stringify(data)\n\t      contentType = 'application/json;charset=utf-8'\n\t      break\n\t    default:\n\t      throw new TypeError('Invalid request body type: ' + toString)\n\t  }\n\t  return { requestBody, contentType }\n", "}\n"]}
{"filename": "src/shared/progress.ts", "chunked_list": ["import type { IProgressEvent } from 'requete/adapter'\n\t/**\n\t * Calculate data maxRate\n\t *\n\t * Forked: https://github.com/axios/axios/blob/6f360a2531d8d70363fd9becef6a45a323f170e2/lib/helpers/speedometer.js\n\t */\n\tfunction speedometer(samplesCount = 10, min = 1000) {\n\t  const bytes = new Array(samplesCount)\n\t  const timestamps = new Array(samplesCount)\n\t  let head = 0\n", "  let tail = 0\n\t  let firstSampleTS: number\n\t  return function push(chunkLength: number) {\n\t    const now = Date.now()\n\t    const startedAt = timestamps[tail]\n\t    if (!firstSampleTS) {\n\t      firstSampleTS = now\n\t    }\n\t    bytes[head] = chunkLength\n\t    timestamps[head] = now\n", "    let i = tail\n\t    let bytesCount = 0\n\t    while (i !== head) {\n\t      bytesCount += bytes[i++]\n\t      i = i % samplesCount\n\t    }\n\t    head = (head + 1) % samplesCount\n\t    if (head === tail) {\n\t      tail = (tail + 1) % samplesCount\n\t    }\n", "    if (now - firstSampleTS < min) {\n\t      return\n\t    }\n\t    const passed = startedAt && now - startedAt\n\t    return passed ? Math.round((bytesCount * 1000) / passed) : undefined\n\t  }\n\t}\n\t/**\n\t * Forked: https://github.com/axios/axios/blob/6f360a2531d8d70363fd9becef6a45a323f170e2/lib/adapters/xhr.js#L17\n\t */\n", "export function progressEventReducer(\n\t  listener: (e: IProgressEvent) => void,\n\t  isDownload?: boolean\n\t) {\n\t  let bytesNotified = 0\n\t  const _speedometer = speedometer(50, 250)\n\t  return (e: any) => {\n\t    const loaded = e.loaded\n\t    const total = e.lengthComputable ? e.total : undefined\n\t    const progressBytes = loaded - bytesNotified\n", "    const rate = _speedometer(progressBytes)\n\t    const inRange = loaded <= total\n\t    bytesNotified = loaded\n\t    listener({\n\t      download: !!isDownload,\n\t      upload: !isDownload,\n\t      loaded,\n\t      total,\n\t      progress: total ? loaded / total : undefined,\n\t      bytes: progressBytes,\n", "      rate: rate ? rate : undefined,\n\t      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n\t      event: e,\n\t    })\n\t  }\n\t}\n"]}
{"filename": "src/shared/logger.ts", "chunked_list": ["import type { IContext } from 'requete'\n\timport { RequestError } from './RequestError'\n\texport class Logger {\n\t  constructor(private name: string, private level: number) {\n\t    this.name = name && `[${name}]`\n\t  }\n\t  res(ctx: IContext) {\n\t    const headers = (headers?: Headers) => {\n\t      if (headers) {\n\t        const obj: any = {}\n", "        headers.forEach((value, key) => {\n\t          obj[key] = value\n\t        })\n\t        return obj\n\t      }\n\t    }\n\t    return {\n\t      request: {\n\t        data: ctx.request.data,\n\t        params: ctx.request.params,\n", "        headers: headers(ctx.request.headers),\n\t      },\n\t      response: {\n\t        data: ctx.data,\n\t        headers: headers(ctx.headers),\n\t        responseText: ctx.responseText,\n\t      },\n\t    }\n\t  }\n\t  info(...message: any[]) {\n", "    if (this.level < 2) return\n\t    console.log(this.name, ...message)\n\t  }\n\t  error(e: Error | string) {\n\t    if (this.level < 1) return\n\t    if (!(e instanceof RequestError)) return console.error(e)\n\t    const { ctx } = e as RequestError\n\t    const { request, url, status, statusText } = ctx\n\t    console.error(\n\t      `${this.name} ${request.method} ${url} ${status} (${\n", "        status === -1 ? 'Before Request' : statusText\n\t      })\\n%o\\n${e.stack}`,\n\t      this.res(ctx)\n\t    )\n\t  }\n\t  request(ctx: IContext) {\n\t    this.info(`${ctx.request.method} ${ctx.url}`, this.res(ctx).request)\n\t  }\n\t  response(ctx: IContext) {\n\t    this.info(\n", "      `${ctx.request.method} ${ctx.url} ${ctx.status} (${ctx.statusText})`,\n\t      this.res(ctx).response\n\t    )\n\t  }\n\t}\n"]}
{"filename": "src/shared/pick.ts", "chunked_list": ["export function pick<T extends object, K extends keyof T>(\n\t  object: T,\n\t  keys: K[]\n\t): Pick<T, K> {\n\t  const partial: any = {}\n\t  keys.forEach((key) => {\n\t    partial[key] = object[key]\n\t  })\n\t  return partial\n\t}\n"]}
{"filename": "src/shared/headers.ts", "chunked_list": ["export function mergeHeaders(...headers: (HeadersInit | undefined)[]) {\n\t  return headers.filter(Boolean).reduce((res: Headers, header) => {\n\t    new Headers(header).forEach((value, key) => res.set(key, value))\n\t    return res\n\t  }, new Headers())\n\t}\n\texport function parseHeaders(rawText?: string) {\n\t  const headers = new Headers()\n\t  if (!rawText) return headers\n\t  rawText\n", "    .trim()\n\t    .split(/[\\r\\n]+/)\n\t    .forEach((header) => {\n\t      const [key, value] = header.split(': ').map((s) => s.trim())\n\t      headers.append(key, value)\n\t    })\n\t  return headers\n\t}\n"]}
{"filename": "src/shared/RequestError.ts", "chunked_list": ["import type { IContext } from 'requete'\n\texport class RequestError extends Error {\n\t  name = 'RequestError'\n\t  ctx: IContext\n\t  constructor(errMsg: string | Error, ctx: IContext) {\n\t    const isError = typeof errMsg !== 'string'\n\t    super(isError ? errMsg.message : errMsg)\n\t    if (isError) {\n\t      this.stack = errMsg.stack\n\t      this.cause = errMsg.cause\n", "    }\n\t    this.ctx = ctx\n\t  }\n\t  get [Symbol.toStringTag]() {\n\t    return 'Error'\n\t  }\n\t}\n"]}
{"filename": "src/shared/__tests__/headers.test.ts", "chunked_list": ["import { mergeHeaders, parseHeaders } from '../headers'\n\tdescribe('headers specs', () => {\n\t  it('mergeHeaders', () => {\n\t    expect(\n\t      mergeHeaders(\n\t        {\n\t          'content-type': 'text/html; charset=utf-8',\n\t          'content-length': '1024',\n\t        },\n\t        undefined,\n", "        {\n\t          'x-xss-protection': '1; mode=block',\n\t          'content-type': 'application/json',\n\t        }\n\t      )\n\t    ).toEqual(\n\t      new Headers({\n\t        'x-xss-protection': '1; mode=block',\n\t        'content-type': 'application/json',\n\t        'content-length': '1024',\n", "      })\n\t    )\n\t  })\n\t  it('parseHeaders', () => {\n\t    const rawHeader = `x-frame-options: DENY\\r\\n\n\t      content-type: text/html; charset=utf-8\\r\\n\n\t      content-length: 1024\\r\\n\n\t      x-xss-protection: 1; mode=block\\r\\n`\n\t    expect(parseHeaders(rawHeader)).toEqual(\n\t      new Headers({\n", "        'x-frame-options': 'DENY',\n\t        'content-type': 'text/html; charset=utf-8',\n\t        'content-length': '1024',\n\t        'x-xss-protection': '1; mode=block',\n\t      })\n\t    )\n\t  })\n\t})\n"]}
{"filename": "src/shared/__tests__/logger.test.ts", "chunked_list": ["import { toAny } from 'test/utils'\n\timport { Logger } from '../logger'\n\timport { RequestError } from '../RequestError'\n\tdescribe('Logger specs', () => {\n\t  const logSpy = vi.spyOn(console, 'log').mockImplementation(toAny(vi.fn()))\n\t  const errorSpy = vi.spyOn(console, 'error').mockImplementation(toAny(vi.fn()))\n\t  beforeEach(() => {\n\t    logSpy.mockClear()\n\t    errorSpy.mockClear()\n\t  })\n", "  it('should output both info & error log when given level == 2', () => {\n\t    const logger = new Logger('logger', 2)\n\t    logger.info('info')\n\t    logger.error('error')\n\t    expect(logSpy).toBeCalled()\n\t    expect(errorSpy).toBeCalled()\n\t  })\n\t  it('should output only error log when given level == 1', () => {\n\t    const logger = new Logger('logger', 1)\n\t    logger.info('info')\n", "    logger.error('error')\n\t    expect(logSpy).not.toBeCalled()\n\t    expect(errorSpy).toBeCalled()\n\t  })\n\t  it('should not output when given level == 0', () => {\n\t    const logger = new Logger('logger', 0)\n\t    logger.info('info')\n\t    logger.error('error')\n\t    expect(logSpy).not.toBeCalled()\n\t    expect(errorSpy).not.toBeCalled()\n", "  })\n\t  it('should output info log with formatted message', () => {\n\t    const logger = new Logger('logger', 2)\n\t    logger.info('info')\n\t    expect(logSpy).toBeCalledWith('[logger]', 'info')\n\t  })\n\t  it('should output request log with formatted message', () => {\n\t    const logger = new Logger('logger', 2)\n\t    logger.request(\n\t      toAny({\n", "        request: {\n\t          method: 'GET',\n\t          data: null,\n\t          params: undefined,\n\t          headers: new Headers({ 'x-header-a': 'a' }),\n\t        },\n\t        url: '/do-mock',\n\t        data: null,\n\t        headers: new Headers({ 'Content-Type': 'application/json' }),\n\t        responseText: 'null',\n", "      })\n\t    )\n\t    expect(logSpy).toBeCalledWith('[logger]', 'GET /do-mock', {\n\t      data: null,\n\t      params: undefined,\n\t      headers: { 'x-header-a': 'a' },\n\t    })\n\t  })\n\t  it('should output response log with formatted message', () => {\n\t    const logger = new Logger('logger', 2)\n", "    logger.response(\n\t      toAny({\n\t        request: {\n\t          method: 'GET',\n\t          data: null,\n\t          params: undefined,\n\t          headers: new Headers({ 'x-header-a': 'a' }),\n\t        },\n\t        url: '/do-mock',\n\t        status: 200,\n", "        statusText: 'OK',\n\t        data: null,\n\t        headers: new Headers({ 'Content-Type': 'application/json' }),\n\t        responseText: 'null',\n\t      })\n\t    )\n\t    expect(logSpy).toBeCalledWith('[logger]', 'GET /do-mock 200 (OK)', {\n\t      data: null,\n\t      responseText: 'null',\n\t      headers: { 'content-type': 'application/json' },\n", "    })\n\t  })\n\t  it('should output error log with formatted message when given a RequestError', () => {\n\t    const logger = new Logger('logger', 2)\n\t    const ctx = toAny({\n\t      request: {\n\t        method: 'GET',\n\t        data: null,\n\t        params: undefined,\n\t        headers: new Headers({ 'x-header-a': 'a' }),\n", "      },\n\t      url: '/do-mock',\n\t      status: 500,\n\t      statusText: 'Internal Server Error',\n\t      data: null,\n\t      headers: new Headers({ 'Content-Type': 'application/json' }),\n\t      responseText: 'null',\n\t    })\n\t    const error = new RequestError('error', ctx)\n\t    logger.error(error)\n", "    expect(errorSpy).toBeCalledWith(\n\t      '[logger] GET /do-mock 500 (Internal Server Error)\\n%o\\n' + error.stack,\n\t      {\n\t        request: {\n\t          data: null,\n\t          headers: {\n\t            'x-header-a': 'a',\n\t          },\n\t          params: undefined,\n\t        },\n", "        response: {\n\t          data: null,\n\t          headers: {\n\t            'content-type': 'application/json',\n\t          },\n\t          responseText: 'null',\n\t        },\n\t      }\n\t    )\n\t  })\n", "  it('should output error log with formatted message when before request', () => {\n\t    const logger = new Logger('logger', 2)\n\t    const ctx = toAny({\n\t      request: {\n\t        method: 'GET',\n\t        data: null,\n\t        params: undefined,\n\t        headers: new Headers({ 'x-header-a': 'a' }),\n\t      },\n\t      url: '/do-mock',\n", "      status: -1,\n\t    })\n\t    const error = new RequestError('error', ctx)\n\t    logger.error(error)\n\t    expect(errorSpy).toBeCalledWith(\n\t      '[logger] GET /do-mock -1 (Before Request)\\n%o\\n' + error.stack,\n\t      {\n\t        request: {\n\t          data: null,\n\t          headers: {\n", "            'x-header-a': 'a',\n\t          },\n\t          params: undefined,\n\t        },\n\t        response: {\n\t          data: undefined,\n\t          headers: undefined,\n\t          responseText: undefined,\n\t        },\n\t      }\n", "    )\n\t  })\n\t  it('should output error log with formatted message when given an other error', () => {\n\t    const logger = new Logger('logger', 2)\n\t    logger.error('error')\n\t    expect(errorSpy).toBeCalledWith('error')\n\t    const error = new Error('error')\n\t    logger.error(error)\n\t    expect(errorSpy).toBeCalledWith(error)\n\t  })\n", "})\n"]}
{"filename": "src/shared/__tests__/progress.test.ts", "chunked_list": ["import { progressEventReducer } from '../progress'\n\tdescribe('progress specs', () => {\n\t  it('should calc progress rate correctly', () => {\n\t    // mock progress interval\n\t    let times = 0\n\t    vi.spyOn(Date, 'now').mockImplementation(() => ++times * 250)\n\t    let progress: any = {}\n\t    const reducedListener = progressEventReducer((v) => {\n\t      progress = v\n\t    })\n", "    // 1st load\n\t    const event: any = { loaded: 50, total: 10240, lengthComputable: true }\n\t    reducedListener(event)\n\t    expect(progress).toMatchInlineSnapshot(`\n\t      {\n\t        \"bytes\": 50,\n\t        \"download\": false,\n\t        \"estimated\": undefined,\n\t        \"event\": {\n\t          \"lengthComputable\": true,\n", "          \"loaded\": 50,\n\t          \"total\": 10240,\n\t        },\n\t        \"loaded\": 50,\n\t        \"progress\": 0.0048828125,\n\t        \"rate\": undefined,\n\t        \"total\": 10240,\n\t        \"upload\": true,\n\t      }\n\t    `)\n", "    // 2nd load\n\t    event.loaded = 1500\n\t    reducedListener(event)\n\t    expect(progress).toMatchInlineSnapshot(`\n\t      {\n\t        \"bytes\": 1450,\n\t        \"download\": false,\n\t        \"estimated\": 43.7,\n\t        \"event\": {\n\t          \"lengthComputable\": true,\n", "          \"loaded\": 1500,\n\t          \"total\": 10240,\n\t        },\n\t        \"loaded\": 1500,\n\t        \"progress\": 0.146484375,\n\t        \"rate\": 200,\n\t        \"total\": 10240,\n\t        \"upload\": true,\n\t      }\n\t    `)\n", "    // disable lengthComputable\n\t    event.lengthComputable = false\n\t    event.total = undefined\n\t    reducedListener(event)\n\t    expect(progress).toMatchInlineSnapshot(`\n\t      {\n\t        \"bytes\": 0,\n\t        \"download\": false,\n\t        \"estimated\": undefined,\n\t        \"event\": {\n", "          \"lengthComputable\": false,\n\t          \"loaded\": 1500,\n\t          \"total\": undefined,\n\t        },\n\t        \"loaded\": 1500,\n\t        \"progress\": undefined,\n\t        \"rate\": 3000,\n\t        \"total\": undefined,\n\t        \"upload\": true,\n\t      }\n", "    `)\n\t  })\n\t})\n"]}
{"filename": "src/shared/__tests__/url.test.ts", "chunked_list": ["import { getUri, stringifyUrl } from '../url'\n\tdescribe('getUri specs', () => {\n\t  it('should not join when given a absolute url', () => {\n\t    expect(\n\t      getUri({\n\t        baseURL: 'https://example.com',\n\t        url: 'https://api.com/api/v1/posts',\n\t      })\n\t    ).toBe('https://api.com/api/v1/posts')\n\t    expect(\n", "      getUri({\n\t        baseURL: 'https://example.com',\n\t        url: '//api.com/api/v1/posts',\n\t      })\n\t    ).toBe('//api.com/api/v1/posts')\n\t  })\n\t  it('should not join when baseURL is falsy', () => {\n\t    expect(\n\t      getUri({\n\t        baseURL: undefined,\n", "        url: '/api/v1/posts',\n\t      })\n\t    ).toBe('/api/v1/posts')\n\t    expect(\n\t      getUri({\n\t        baseURL: '',\n\t        url: '/api/v1/posts',\n\t      })\n\t    ).toBe('/api/v1/posts')\n\t  })\n", "  it('should join with baseURL with separator', () => {\n\t    expect(\n\t      getUri({\n\t        baseURL: 'https://example.com/',\n\t        url: '/api/v1/posts#t=1',\n\t      })\n\t    ).toBe('https://example.com/api/v1/posts')\n\t    expect(\n\t      getUri({\n\t        baseURL: 'https://example.com//',\n", "        url: '/api/v1/posts/',\n\t      })\n\t    ).toBe('https://example.com/api/v1/posts/')\n\t  })\n\t  it('should join url with query-string when given string params', () => {\n\t    expect(\n\t      getUri({\n\t        url: 'https://example.com/api/v1/posts',\n\t        params: 'a=1',\n\t      })\n", "    ).toBe('https://example.com/api/v1/posts?a=1')\n\t    expect(\n\t      getUri({\n\t        url: 'https://example.com/api/v1/posts?t=123',\n\t        params: '?a=1',\n\t      })\n\t    ).toBe('https://example.com/api/v1/posts?t=123&a=1')\n\t  })\n\t  it('should join url with query-string when given object params', () => {\n\t    expect(\n", "      getUri({\n\t        url: 'https://example.com/api/v1/posts',\n\t        params: {\n\t          a: '1+1',\n\t          b: '2 1',\n\t          c: null,\n\t          d: undefined,\n\t          arr: [1, 2, 3],\n\t        },\n\t      })\n", "    ).toBe('https://example.com/api/v1/posts?a=1%2B1&b=2+1&arr=1&arr=2&arr=3')\n\t  })\n\t  it('should join url with query-string when given the URLSearchParams', () => {\n\t    expect(\n\t      getUri({\n\t        url: 'https://example.com/api/v1/posts',\n\t        params: new URLSearchParams({ a: '1', b: '2' }),\n\t      })\n\t    ).toBe('https://example.com/api/v1/posts?a=1&b=2')\n\t  })\n", "})\n\tdescribe('stringifyUrl specs', () => {\n\t  it('should overwrite the duplicated key-values when given a url having search-params if not append', () => {\n\t    expect(\n\t      stringifyUrl(\n\t        'https://example.com?a=a&b=b&t=1',\n\t        { a: 1, b: 2, c: 3 },\n\t        false\n\t      )\n\t    ).toBe('https://example.com?a=1&b=2&t=1&c=3')\n", "  })\n\t})\n"]}
{"filename": "src/shared/__tests__/RequestError.test.ts", "chunked_list": ["import { toAny } from 'test/utils'\n\timport { RequestError } from '../RequestError'\n\tdescribe('RequestError specs', () => {\n\t  it('should return [object RequestError] when called with Object.prototype.toString', () => {\n\t    expect(\n\t      Object.prototype.toString.call(new RequestError('test', toAny({})))\n\t    ).toBe('[object Error]')\n\t  })\n\t})\n"]}
{"filename": "src/shared/__tests__/transform.test.ts", "chunked_list": ["import { transformRequestBody } from '../transform'\n\tdescribe('transform specs', () => {\n\t  it.each([\n\t    undefined,\n\t    null,\n\t    '1',\n\t    new FormData(),\n\t    new Blob(['1']),\n\t    new ArrayBuffer(1),\n\t    { a: 1 },\n", "    [{ a: 1 }],\n\t  ])('should transform requestBody correctly when given `%o`', (data) => {\n\t    expect(transformRequestBody(data)).toMatchSnapshot()\n\t  })\n\t  it('should thrown TypeError when given a number', () => {\n\t    expect(() => transformRequestBody(1 as any)).toThrow(TypeError)\n\t    expect(() => transformRequestBody(1 as any)).toThrow(\n\t      /Invalid request body type/\n\t    )\n\t  })\n", "})\n"]}
{"filename": "src/core/AbortController.ts", "chunked_list": ["export class TimeoutAbortController {\n\t  static readonly supported = typeof AbortController !== 'undefined'\n\t  private controller: AbortController\n\t  private timeoutId: ReturnType<typeof setTimeout> | null = null\n\t  constructor(timeout: number) {\n\t    if (!TimeoutAbortController.supported)\n\t      throw new ReferenceError(\n\t        'Not support AbortController in current environment.'\n\t      )\n\t    this.controller = new AbortController()\n", "    if (timeout > 0) {\n\t      this.timeoutId = setTimeout(\n\t        () => this.controller.abort('timeout'),\n\t        timeout\n\t      )\n\t    }\n\t  }\n\t  get signal() {\n\t    return this.controller.signal\n\t  }\n", "  abort(reason?: any) {\n\t    this.controller.abort(reason)\n\t    this.clear()\n\t  }\n\t  clear() {\n\t    if (this.timeoutId) {\n\t      clearTimeout(this.timeoutId)\n\t      this.timeoutId = null\n\t    }\n\t  }\n", "  get [Symbol.toStringTag]() {\n\t    return 'TimeoutAbortController'\n\t  }\n\t}\n"]}
{"filename": "src/core/Requete.ts", "chunked_list": ["import { Adapter, createAdapter } from 'requete/adapter'\n\timport {\n\t  getUri,\n\t  Logger,\n\t  mergeHeaders,\n\t  pick,\n\t  RequestError,\n\t  stringifyUrl,\n\t} from 'requete/shared'\n\timport { TimeoutAbortController } from './AbortController'\n", "import { compose } from './compose'\n\texport type Method =\n\t  | 'GET'\n\t  | 'DELETE'\n\t  | 'HEAD'\n\t  | 'OPTIONS'\n\t  | 'POST'\n\t  | 'PUT'\n\t  | 'PATCH'\n\texport type RequestBody =\n", "  | BodyInit\n\t  | null\n\t  | Record<string, any>\n\t  | Record<string, any>[]\n\texport type RequestQueryRecord = Record<\n\t  string,\n\t  | string\n\t  | number\n\t  | boolean\n\t  | null\n", "  | undefined\n\t  | Array<string | number | boolean>\n\t>\n\texport type RequestQuery = string | URLSearchParams | RequestQueryRecord\n\texport interface RequestConfig {\n\t  baseURL?: string\n\t  /** request timeout (ms) */\n\t  timeout?: number\n\t  /** response body type */\n\t  responseType?: 'json' | 'formData' | 'text' | 'blob' | 'arrayBuffer'\n", "  /** A string indicating how the request will interact with the browser's cache to set request's cache. */\n\t  cache?: RequestCache\n\t  /** A string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL. Sets request's credentials. */\n\t  credentials?: RequestCredentials\n\t  /** A Headers object, an object literal, or an array of two-item arrays to set request's headers. */\n\t  headers?: HeadersInit\n\t  /** A cryptographic hash of the resource to be fetched by request. Sets request's integrity. */\n\t  integrity?: string\n\t  /** A boolean to set request's keepalive. */\n\t  keepalive?: boolean\n", "  /** A string to indicate whether the request will use CORS, or will be restricted to same-origin URLs. Sets request's mode. */\n\t  mode?: RequestMode\n\t  /** A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. */\n\t  redirect?: RequestRedirect\n\t  /** A string whose value is a same-origin URL, \"about:client\", or the empty string, to set request's referrer. */\n\t  referrer?: string\n\t  /** A referrer policy to set request's referrerPolicy. */\n\t  referrerPolicy?: ReferrerPolicy\n\t  /** enable logger or set logger level # */\n\t  verbose?: boolean | number\n", "  /**\n\t   * parse json function\n\t   * (for transform response)\n\t   * @default JSON.parse\n\t   */\n\t  toJSON?(body: string): any\n\t}\n\texport interface IRequest extends Omit<RequestConfig, 'verbose'> {\n\t  url: string\n\t  /**\n", "   * A string to set request's method.\n\t   * @default GET\n\t   */\n\t  method?: Method\n\t  /** A string or object to set querystring of url */\n\t  params?: RequestQuery\n\t  /** request`s body */\n\t  data?: RequestBody\n\t  /**\n\t   * A TimeoutAbortController to set request's signal.\n", "   * @default TimeoutAbortController\n\t   */\n\t  abort?: TimeoutAbortController | null\n\t  /** specify request adapter */\n\t  adapter?: Adapter\n\t  /** flexible custom field */\n\t  custom?: Record<string, any>\n\t}\n\t/** {@link https://developer.mozilla.org/en-US/docs/Web/API/Response} */\n\texport interface IResponse<Data = any> {\n", "  headers: Headers\n\t  ok: boolean\n\t  redirected: boolean\n\t  status: number\n\t  statusText: string\n\t  type: ResponseType\n\t  url: string\n\t  data: Data\n\t  responseText?: string\n\t}\n", "export interface IContext<Data = any> extends IResponse<Data> {\n\t  /**\n\t   * request config.\n\t   * and empty `Headers` object as default\n\t   */\n\t  request: IRequest & { method: Method; headers: Headers }\n\t  /**\n\t   * set `ctx.request.headers`\n\t   *\n\t   * *And header names are matched by case-insensitive byte sequence.*\n", "   *\n\t   * @example\n\t   * ```ts\n\t   * // set a header\n\t   * ctx.set('name', '<value>')\n\t   *\n\t   * // remove a header\n\t   * ctx.set('name', null)\n\t   * ctx.set('name')\n\t   *\n", "   * // set headers\n\t   * ctx.set({ name1: '<value>', name2: '<value>' })\n\t   * ```\n\t   */\n\t  set(headerOrName: HeadersInit | string, value?: string | null): this\n\t  /**\n\t   * Add extra params to `request.url`.\n\t   * If there are duplicate keys, then the original key-values will be removed.\n\t   */\n\t  params(params: RequestQuery): this\n", "  /**\n\t   * get `ctx.request.abort`,\n\t   * and **create one if not exist**\n\t   * @throws {RequestError}\n\t   */\n\t  abort(): TimeoutAbortController\n\t  /** throw {@link RequestError} */\n\t  throw(e: string | Error): void\n\t  /**\n\t   * Assign to current context\n", "   */\n\t  assign(context: Partial<IContext>): void\n\t  /**\n\t   * Replay current request\n\t   * And assign new context to current, with replay`s response\n\t   */\n\t  replay(): Promise<void>\n\t}\n\texport type Middleware = (\n\t  ctx: IContext,\n", "  next: () => Promise<void>\n\t) => Promise<void>\n\ttype AliasConfig = Omit<IRequest, 'url' | 'data'>\n\texport class Requete {\n\t  static defaults: RequestConfig = {\n\t    timeout: 0,\n\t    responseType: 'json',\n\t    headers: {\n\t      Accept: 'application/json, text/plain, */*',\n\t    },\n", "    verbose: 1,\n\t    toJSON: (text: string | null | undefined) => {\n\t      if (text) return JSON.parse(text)\n\t    },\n\t  }\n\t  private configs?: RequestConfig\n\t  private adapter: Adapter\n\t  private middlewares: Middleware[] = []\n\t  logger: Logger\n\t  constructor(config?: RequestConfig) {\n", "    this.configs = Object.assign({ method: 'GET' }, Requete.defaults, config)\n\t    this.adapter = createAdapter()\n\t    this.logger = new Logger(\n\t      'Requete',\n\t      this.configs.verbose === true ? 2 : Number(this.configs.verbose ?? 0)\n\t    )\n\t  }\n\t  /**\n\t   * add middleware function\n\t   *\n", "   * @attention\n\t   * - The calling order of middleware should follow the **Onion Model**.\n\t   *   like {@link https://github.com/koajs/koa/blob/master/docs/guide.md#writing-middleware Koajs}.\n\t   * - `next()` must be called asynchronously in middleware\n\t   *\n\t   * @example\n\t   * ```ts\n\t   * http.use(async (ctx, next) => {\n\t   *   // set request header\n\t   *   ctx.set('Authorization', '<token>')\n", "   *\n\t   *   // wait for request responding\n\t   *   await next()\n\t   *\n\t   *   // transformed response body\n\t   *   console.log(ctx.data)\n\t   *\n\t   *   // throw a request error\n\t   *   if (!ctx.data) ctx.throw('no response data')\n\t   * })\n", "   * ```\n\t   */\n\t  use(middleware: Middleware) {\n\t    this.middlewares.push(middleware)\n\t    this.logger.info(\n\t      `Use middleware #${this.middlewares.length}:`,\n\t      middleware.name || middleware\n\t    )\n\t    return this\n\t  }\n", "  private createRequest(config: IRequest) {\n\t    const request: IRequest = Object.assign({}, this.configs, config)\n\t    request.url = getUri(request)\n\t    request.headers = mergeHeaders(\n\t      Requete.defaults.headers,\n\t      this.configs?.headers,\n\t      config.headers\n\t    )\n\t    // add default AbortController for timeout\n\t    if (!request.abort && request.timeout && TimeoutAbortController.supported) {\n", "      request.abort = new TimeoutAbortController(request.timeout)\n\t    }\n\t    return request as IContext['request']\n\t  }\n\t  private createContext<D>(config: IRequest) {\n\t    const request = this.createRequest(config)\n\t    const doRequest = this.request.bind(this)\n\t    const ctx: IContext<D> = {\n\t      request,\n\t      status: -1,\n", "      data: undefined as D,\n\t      ok: false,\n\t      redirected: false,\n\t      headers: undefined as unknown as Headers,\n\t      statusText: undefined as unknown as string,\n\t      type: undefined as unknown as ResponseType,\n\t      url: request.url,\n\t      set(headerOrName, value) {\n\t        if (this.status !== -1)\n\t          this.throw('Cannot set request headers after next().')\n", "        let headers = this.request.headers\n\t        if (typeof headerOrName === 'string') {\n\t          value == null\n\t            ? headers.delete(headerOrName)\n\t            : headers.set(headerOrName, value)\n\t        } else {\n\t          headers = mergeHeaders(headers, headerOrName)\n\t        }\n\t        this.request.headers = headers\n\t        return this\n", "      },\n\t      params(params) {\n\t        this.request.url = stringifyUrl(this.request.url, params, false)\n\t        return this\n\t      },\n\t      abort() {\n\t        if (!this.request.abort) {\n\t          if (this.status !== -1)\n\t            this.throw('Cannot set abortSignal after next().')\n\t          this.request.abort = new TimeoutAbortController(\n", "            this.request.timeout ?? 0\n\t          )\n\t        }\n\t        return this.request.abort\n\t      },\n\t      throw(e) {\n\t        if (e instanceof RequestError) throw e\n\t        throw new RequestError(e, this)\n\t      },\n\t      assign(context) {\n", "        Object.assign(this, context)\n\t      },\n\t      async replay() {\n\t        // count replay #\n\t        this.request.custom = Object.assign({}, this.request.custom, {\n\t          replay: (this.request.custom?.replay ?? 0) + 1,\n\t        })\n\t        const context = await doRequest(this.request)\n\t        this.assign(context)\n\t      },\n", "    }\n\t    return ctx\n\t  }\n\t  private async invoke(ctx: IContext) {\n\t    this.logger.request(ctx)\n\t    const adapter = ctx.request.adapter ?? this.adapter\n\t    const response = await adapter.request(ctx)\n\t    // assign to ctx\n\t    Object.assign(\n\t      ctx,\n", "      pick(response, [\n\t        'ok',\n\t        'status',\n\t        'statusText',\n\t        'headers',\n\t        'data',\n\t        'responseText',\n\t        'redirected',\n\t        'type',\n\t        'url',\n", "      ])\n\t    )\n\t    if (ctx.request.responseType === 'json') {\n\t      ctx.data = ctx.request.toJSON!(response.data)\n\t    }\n\t  }\n\t  async request<D = any>(config: IRequest) {\n\t    // create context\n\t    const context = this.createContext<D>(config)\n\t    // exec middleware\n", "    try {\n\t      await compose(this.middlewares)(context, this.invoke.bind(this))\n\t      if (!context.ok) {\n\t        context.throw(\n\t          `${context.request.method} ${context.url} ${context.status} (${context.statusText})`\n\t        )\n\t      }\n\t      this.logger.response(context)\n\t      return context\n\t    } catch (e: any) {\n", "      this.logger.error(e)\n\t      throw e\n\t    } finally {\n\t      context.request.abort?.clear()\n\t    }\n\t  }\n\t  get<D = any>(url: string, config?: AliasConfig) {\n\t    return this.request<D>({ ...config, url, method: 'GET' })\n\t  }\n\t  delete<D = any>(url: string, config?: AliasConfig) {\n", "    return this.request<D>({ ...config, url, method: 'DELETE' })\n\t  }\n\t  head<D = any>(url: string, config?: AliasConfig) {\n\t    return this.request<D>({ ...config, url, method: 'HEAD' })\n\t  }\n\t  options<D = any>(url: string, config?: AliasConfig) {\n\t    return this.request<D>({ ...config, url, method: 'OPTIONS' })\n\t  }\n\t  post<D = any>(url: string, data?: RequestBody, config?: AliasConfig) {\n\t    return this.request<D>({ ...config, url, data, method: 'POST' })\n", "  }\n\t  put<D = any>(url: string, data?: RequestBody, config?: AliasConfig) {\n\t    return this.request<D>({ ...config, url, data, method: 'PUT' })\n\t  }\n\t  patch<D = any>(url: string, data?: RequestBody, config?: AliasConfig) {\n\t    return this.request<D>({ ...config, url, data, method: 'PATCH' })\n\t  }\n\t}\n"]}
{"filename": "src/core/create.ts", "chunked_list": ["import { RequestConfig, Requete } from './Requete'\n\texport function create(config?: RequestConfig) {\n\t  return new Requete(config)\n\t}\n"]}
{"filename": "src/core/compose.ts", "chunked_list": ["import type { IContext, Middleware } from './Requete'\n\texport function compose(middlewares: Middleware[]) {\n\t  return (context: IContext, next: Middleware) => {\n\t    // last called middleware #\n\t    let index = -1\n\t    return dispatch(0).catch((e) => context.throw(e))\n\t    async function dispatch(i: number): Promise<void> {\n\t      if (i <= index) throw new Error('next() called multiple times')\n\t      index = i\n\t      const middleware = i === middlewares.length ? next : middlewares[i]\n", "      if (middleware) return await middleware(context, () => dispatch(i + 1))\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/core/__tests__/AbortController.test.ts", "chunked_list": ["import { TimeoutAbortController } from '../AbortController'\n\tdescribe('TimeoutAbortController specs', () => {\n\t  it('should thrown a ReferenceError when AbortController not supported', () => {\n\t    // @ts-ignore\n\t    TimeoutAbortController.supported = false\n\t    expect(() => new TimeoutAbortController(0)).toThrow(ReferenceError)\n\t    expect(() => new TimeoutAbortController(0)).toThrow(\n\t      'Not support AbortController in current environment.'\n\t    )\n\t    // @ts-ignore\n", "    TimeoutAbortController.supported = true\n\t  })\n\t  it('should return [object TimeoutAbortController] when called with Object.prototype.toString', () => {\n\t    expect(Object.prototype.toString.call(new TimeoutAbortController(0))).toBe(\n\t      '[object TimeoutAbortController]'\n\t    )\n\t  })\n\t})\n"]}
{"filename": "src/core/__tests__/requete-request.test.ts", "chunked_list": ["import { FetchAdapter } from 'requete/adapter'\n\timport { Method, Requete } from '../Requete'\n\tdescribe('Requete request configs', () => {\n\t  beforeEach(() => {\n\t    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n\t      vi.fn().mockResolvedValue({\n\t        ok: true,\n\t        status: 200,\n\t        statusText: 'OK',\n\t        url: '/do-mock',\n", "        data: 'null',\n\t      })\n\t    )\n\t  })\n\t  it.each([\n\t    'get',\n\t    'head',\n\t    'delete',\n\t    'options',\n\t    'post',\n", "    'patch',\n\t    'put',\n\t  ] as Lowercase<Method>[])(\n\t    'should make request by %s alias func',\n\t    async (method) => {\n\t      const requete = new Requete()\n\t      const ctx = await requete[method]('/do-mock')\n\t      expect(ctx.request.url).toBe('/do-mock')\n\t      expect(ctx.request.method).toBe(method.toUpperCase())\n\t    }\n", "  )\n\t  it('should make a request with correct url', async () => {\n\t    const requete = new Requete({ baseURL: 'https://api.mock.com/api/v1/' })\n\t    let ctx = await requete.post('https://api.mock.com/api/v2/do-mock?id=1')\n\t    expect(ctx.request.url).toBe('https://api.mock.com/api/v2/do-mock?id=1')\n\t    ctx = await requete.get('do-mock?id=1', { params: { id: '2' } })\n\t    expect(ctx.request.url).toBe(\n\t      'https://api.mock.com/api/v1/do-mock?id=1&id=2'\n\t    )\n\t    ctx = await requete.get('do-mock', { params: 'id=2' })\n", "    expect(ctx.request.url).toBe('https://api.mock.com/api/v1/do-mock?id=2')\n\t  })\n\t})\n"]}
{"filename": "src/core/__tests__/requete-exceptions.test.ts", "chunked_list": ["import { FetchAdapter } from 'requete/adapter'\n\timport { RequestError } from 'requete/shared'\n\timport { toAny } from 'test/utils'\n\timport { Requete } from '../Requete'\n\tdescribe('Requete exceptions specs', () => {\n\t  beforeEach(() => {\n\t    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n\t      vi.fn().mockResolvedValue({\n\t        ok: true,\n\t        status: 200,\n", "        statusText: 'OK',\n\t        url: '/do-mock',\n\t        data: 'null',\n\t      })\n\t    )\n\t    // disable console.error\n\t    vi.spyOn(global.console, 'error').mockImplementation(toAny(vi.fn()))\n\t  })\n\t  it('should caught RequestError when response`s status != 200', async () => {\n\t    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n", "      vi.fn().mockResolvedValue({\n\t        ok: false,\n\t        status: 500,\n\t        statusText: 'Internal Server Error',\n\t        url: '/do-mock',\n\t        data: 'null',\n\t      })\n\t    )\n\t    const requete = new Requete()\n\t    await expect(requete.get('https:api.com/do-mock')).rejects.toThrow(\n", "      RequestError\n\t    )\n\t    await expect(requete.get('/do-mock')).rejects.toThrow(\n\t      'GET /do-mock 500 (Internal Server Error)'\n\t    )\n\t  })\n\t  it('should caught RequestError when middleware throws', async () => {\n\t    const requete = new Requete().use(async (ctx, next) => {\n\t      if (ctx.request.method === 'GET') throw new Error('not allowed')\n\t      await next()\n", "      if (ctx.request.method === 'POST') throw new Error('post error')\n\t    })\n\t    await expect(requete.get('/do-mock')).rejects.toThrow(RequestError)\n\t    await expect(requete.get('/do-mock')).rejects.toThrow('not allowed')\n\t    await expect(requete.post('/do-mock')).rejects.toThrow(RequestError)\n\t    await expect(requete.post('/do-mock')).rejects.toThrow('post error')\n\t  })\n\t  it('should caught when call ctx funcs in wrong way', async () => {\n\t    // ctx.abort()\n\t    await expect(\n", "      new Requete()\n\t        .use(async (ctx, next) => {\n\t          await next()\n\t          ctx.abort()\n\t        })\n\t        .get('/do-mock')\n\t    ).rejects.toThrow('Cannot set abortSignal after next().')\n\t    // ctx.set()\n\t    await expect(\n\t      new Requete()\n", "        .use(async (ctx, next) => {\n\t          await next()\n\t          ctx.set('a', 'b')\n\t        })\n\t        .get('/do-mock')\n\t    ).rejects.toThrow('Cannot set request headers after next().')\n\t  })\n\t  it('should caught when request aborted', async () => {\n\t    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n\t      async (ctx) => {\n", "        const abort = ctx.abort()\n\t        if (abort.signal.aborted) {\n\t          throw new Error(abort.signal.reason)\n\t        }\n\t        return toAny({\n\t          ok: false,\n\t          status: 500,\n\t          statusText: 'Internal Server Error',\n\t          url: '/do-mock',\n\t          data: 'null',\n", "        })\n\t      }\n\t    )\n\t    const requete = new Requete().use(async (ctx, next) => {\n\t      ctx.abort().abort('abort request')\n\t      await next()\n\t    })\n\t    await expect(requete.get('/do-mock', { timeout: 1000 })).rejects.toThrow(\n\t      'abort request'\n\t    )\n", "  })\n\t  it('should caught RequestError when parse body with throws', async () => {\n\t    vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n\t      vi.fn().mockResolvedValue({\n\t        ok: true,\n\t        status: 200,\n\t        statusText: 'OK',\n\t        url: '/do-mock',\n\t        data: 'bad',\n\t      })\n", "    )\n\t    const requete = new Requete()\n\t    await expect(requete.get('/do-mock')).rejects.toThrow(RequestError)\n\t    await expect(requete.get('/do-mock')).rejects.toThrow(/Unexpected token/)\n\t  })\n\t})\n"]}
{"filename": "src/core/__tests__/requete-response.test.ts", "chunked_list": ["import { toAny } from 'test/utils'\n\timport { Requete } from '../Requete'\n\tdescribe('Requete response specs', () => {\n\t  beforeEach(() => {\n\t    vi.clearAllMocks()\n\t  })\n\t  it.each([\n\t    { data: { data: 'mockData' }, dataType: 'json' },\n\t    { data: new FormData(), dataType: 'formData' },\n\t    { data: new Blob(), dataType: 'blob' },\n", "    { data: new ArrayBuffer(0), dataType: 'arrayBuffer' },\n\t    { data: 'text', dataType: 'text' },\n\t  ])(\n\t    'should respond $dataType type when request successfully',\n\t    async ({ data, dataType }) => {\n\t      const response: any = {\n\t        ok: true,\n\t        status: 200,\n\t        statusText: 'ok',\n\t        [dataType]: vi.fn().mockResolvedValue(data),\n", "        url: '/do-mock',\n\t      }\n\t      // add text func for json type\n\t      if (dataType === 'json') {\n\t        response.text = vi.fn().mockResolvedValue(JSON.stringify(data))\n\t      }\n\t      // mock fetch api\n\t      vi.spyOn(global, 'fetch').mockImplementation(\n\t        toAny(vi.fn().mockResolvedValue(response))\n\t      )\n", "      const res = await new Requete().get('/do-mock', {\n\t        responseType: dataType as any,\n\t      })\n\t      expect(res.data).toEqual(data)\n\t    }\n\t  )\n\t})\n"]}
{"filename": "src/core/__tests__/requete-middleware.test.ts", "chunked_list": ["import { FetchAdapter } from 'requete/adapter'\n\timport { toAny } from 'test/utils'\n\timport { Requete } from '../Requete'\n\tdescribe('Requete middleware specs', () => {\n\t  const spy = vi.spyOn(FetchAdapter.prototype, 'request').mockImplementation(\n\t    vi.fn().mockResolvedValue({\n\t      ok: true,\n\t      status: 200,\n\t      statusText: 'OK',\n\t      url: '/do-mock',\n", "      data: 'null',\n\t    })\n\t  )\n\t  beforeEach(() => {\n\t    spy.mockClear()\n\t  })\n\t  it('should execute middleware in order according to the onion model with request context', async () => {\n\t    const before = vi.fn()\n\t    const after = vi.fn()\n\t    const requete = new Requete()\n", "      .use(async (ctx, next) => {\n\t        before(ctx.request)\n\t        await next()\n\t        after(ctx.data)\n\t      })\n\t      .use(async (ctx, next) => {\n\t        before(2)\n\t        await next()\n\t        after(2)\n\t      })\n", "      .use(async (ctx, next) => {\n\t        before(3)\n\t        await next()\n\t        after(3)\n\t      })\n\t    const res = await requete.post('/do-mock')\n\t    expect(res.request).toBeDefined()\n\t    expect(res.data).toBeDefined()\n\t    expect(before).nthCalledWith(1, res.request)\n\t    expect(before).nthCalledWith(2, 2)\n", "    expect(before).nthCalledWith(3, 3)\n\t    expect(after).nthCalledWith(1, 3)\n\t    expect(after).nthCalledWith(2, 2)\n\t    expect(after).nthCalledWith(3, res.data)\n\t  })\n\t  it('should throws when call next() duplicated', async () => {\n\t    vi.spyOn(console, 'error').mockImplementation(toAny(vi.fn()))\n\t    const requete = new Requete()\n\t    requete.use(async (ctx, next) => {\n\t      await next()\n", "      await next()\n\t    })\n\t    await expect(requete.post('/do-mock')).rejects.toThrow(\n\t      'next() called multiple times'\n\t    )\n\t  })\n\t  it('should set request header correctly in middleware', async () => {\n\t    const requete = new Requete()\n\t    requete.use(async (ctx, next) => {\n\t      ctx.set('Authorization', 'mock')\n", "      ctx.set({ 'x-client-by': 'mock' })\n\t      ctx.set('x')\n\t      await next()\n\t    })\n\t    const res = await requete.post('/do-mock')\n\t    expect(res.request.headers).toEqual(\n\t      new Headers({\n\t        Accept: 'application/json, text/plain, */*',\n\t        Authorization: 'mock',\n\t        'x-client-by': 'mock',\n", "      })\n\t    )\n\t  })\n\t  it('should set params correctly in middleware', async () => {\n\t    const requete = new Requete()\n\t    requete.use(async (ctx, next) => {\n\t      ctx.params({ a: 1, b: 2 })\n\t      await next()\n\t    })\n\t    const res = await requete.post('/do-mock', { params: { b: 1 } })\n", "    expect(res.request.url).toBe('/do-mock?a=1&b=2')\n\t  })\n\t  it('should set abortSignal correctly in middleware', async () => {\n\t    const requete = new Requete()\n\t    let controller: any\n\t    requete.use(async (ctx, next) => {\n\t      controller = ctx.abort()\n\t      await next()\n\t    })\n\t    const res = await requete.post('/do-mock', undefined)\n", "    expect(res.request.abort).toEqual(controller)\n\t  })\n\t  it('should replay the request in middleware', async () => {\n\t    const requete = new Requete()\n\t    requete.use(async (ctx, next) => {\n\t      await next()\n\t      if (!ctx.request.custom?.replay) {\n\t        await ctx.replay()\n\t      }\n\t    })\n", "    const { request } = await requete.post('/do-mock')\n\t    expect(spy).toBeCalledTimes(2)\n\t    expect(request.custom?.replay).toBe(1)\n\t  })\n\t})\n"]}
{"filename": "src/adapter/create.ts", "chunked_list": ["import { FetchAdapter } from './FetchAdapter'\n\timport { XhrAdapter } from './XhrAdapter'\n\texport function createAdapter() {\n\t  const SupportedAdapter = [FetchAdapter, XhrAdapter].find((i) => i.supported)\n\t  if (!SupportedAdapter)\n\t    throw new ReferenceError('No adapter supported in current environment.')\n\t  return new SupportedAdapter()\n\t}\n"]}
{"filename": "src/adapter/FetchAdapter.ts", "chunked_list": ["import type { IContext, IResponse } from 'requete'\n\timport { pick, transformRequestBody } from 'requete/shared'\n\timport { Adapter } from './Adapter'\n\texport class FetchAdapter extends Adapter {\n\t  static readonly supported = typeof fetch !== 'undefined'\n\t  private transformRequest(request: IContext['request']) {\n\t    const supports = [\n\t      'method',\n\t      'cache',\n\t      'credentials',\n", "      'headers',\n\t      'integrity',\n\t      'keepalive',\n\t      'mode',\n\t      'redirect',\n\t      'referrer',\n\t      'referrerPolicy',\n\t    ] as const\n\t    const init: RequestInit = supports.reduce((req, key) => {\n\t      const value: any = request[key]\n", "      if (value !== undefined) {\n\t        req[key] = value\n\t      }\n\t      return req\n\t    }, {} as RequestInit)\n\t    // Content-Type header\n\t    const headers = init.headers as Headers\n\t    if (/^(POST|PUT|PATCH)$/i.test(request.method!)) {\n\t      const { requestBody, contentType } = transformRequestBody(request.data)\n\t      init.body = requestBody\n", "      if (contentType && !headers.has('Content-Type')) {\n\t        headers.set('Content-Type', contentType)\n\t      }\n\t    }\n\t    if (init.body == null) {\n\t      headers.delete('Content-Type')\n\t    }\n\t    init.headers = headers\n\t    if (request.abort) init.signal = request.abort.signal\n\t    return init\n", "  }\n\t  async request(ctx: IContext) {\n\t    if (!FetchAdapter.supported) {\n\t      throw new ReferenceError('Not support fetch api in current environment.')\n\t    }\n\t    const response = await fetch(\n\t      ctx.request.url,\n\t      this.transformRequest(ctx.request)\n\t    )\n\t    const res = pick(response, [\n", "      'ok',\n\t      'status',\n\t      'statusText',\n\t      'headers',\n\t      'redirected',\n\t      'type',\n\t      'url',\n\t    ]) as IResponse\n\t    switch (ctx.request.responseType) {\n\t      case 'formData':\n", "        res.data = await response.formData()\n\t        break\n\t      case 'blob':\n\t        res.data = await response.blob()\n\t        break\n\t      case 'arrayBuffer':\n\t        res.data = await response.arrayBuffer()\n\t        break\n\t      default:\n\t        res.data = res.responseText = await response.text()\n", "    }\n\t    return res\n\t  }\n\t}\n"]}
{"filename": "src/adapter/XhrAdapter.ts", "chunked_list": ["import { IContext, IResponse } from 'requete'\n\timport {\n\t  parseHeaders,\n\t  progressEventReducer,\n\t  RequestError,\n\t  transformRequestBody,\n\t} from 'requete/shared'\n\timport { Adapter } from './Adapter'\n\texport interface IProgressEvent {\n\t  loaded: number\n", "  total?: number\n\t  progress?: number\n\t  bytes: number\n\t  rate?: number\n\t  estimated?: number\n\t  upload?: boolean\n\t  download?: boolean\n\t  event?: any\n\t}\n\texport type XhrAdapterOptions = {\n", "  onDownloadProgress?(e: IProgressEvent): void\n\t  onUploadProgress?(e: IProgressEvent): void\n\t}\n\texport class XhrAdapter extends Adapter {\n\t  static readonly supported = typeof XMLHttpRequest !== 'undefined'\n\t  constructor(private options?: XhrAdapterOptions) {\n\t    super()\n\t  }\n\t  private transformRequest(xhr: XMLHttpRequest, ctx: IContext) {\n\t    const { request } = ctx\n", "    const { headers } = request\n\t    if (request.timeout) {\n\t      xhr.timeout = request.timeout\n\t    }\n\t    // Add withCredentials to xhr\n\t    if (request.credentials === 'include') {\n\t      xhr.withCredentials = true\n\t    }\n\t    // Content-Type header to xhr\n\t    let requestBody: any\n", "    if (/^(POST|PUT|PATCH)$/i.test(request.method!)) {\n\t      const body = transformRequestBody(request.data)\n\t      requestBody = body.requestBody\n\t      if (body.contentType && !request.headers.has('Content-Type')) {\n\t        headers.set('Content-Type', body.contentType)\n\t      }\n\t    }\n\t    if (requestBody == null) {\n\t      headers.delete('Content-Type')\n\t    }\n", "    // Add headers to xhr\n\t    headers.forEach((value, key) => {\n\t      xhr.setRequestHeader(key, value)\n\t    })\n\t    return requestBody\n\t  }\n\t  private transformResponse(xhr: XMLHttpRequest, ctx: IContext) {\n\t    const response: IResponse = {\n\t      ok: !!xhr.status && xhr.status >= 200 && xhr.status < 300,\n\t      status: xhr.status,\n", "      statusText: xhr.statusText,\n\t      headers: parseHeaders(xhr.getAllResponseHeaders()),\n\t      redirected: false,\n\t      type: 'default',\n\t      url: xhr.responseURL,\n\t      data: ['json', 'text', undefined].includes(ctx.request.responseType)\n\t        ? xhr.responseText\n\t        : xhr.response,\n\t      responseText: xhr.responseText,\n\t    }\n", "    return response\n\t  }\n\t  request(ctx: IContext) {\n\t    return new Promise<IResponse>((resolve, reject) => {\n\t      if (!XhrAdapter.supported) {\n\t        throw new ReferenceError(\n\t          'Not support XMLHttpRequest api in current environment.'\n\t        )\n\t      }\n\t      let xhr: null | XMLHttpRequest = new XMLHttpRequest()\n", "      xhr.open(ctx.request.method!, ctx.request.url, true)\n\t      const abort = (abortReq?: boolean) => {\n\t        reject(\n\t          new RequestError(ctx.request.abort!.signal.reason ?? 'aborted', ctx)\n\t        )\n\t        abortReq && xhr!.abort()\n\t        xhr = null\n\t      }\n\t      const onabort = () => {\n\t        if (!xhr) return\n", "        abort(true)\n\t      }\n\t      // add abortSignal\n\t      if (ctx.request.abort) {\n\t        const { signal } = ctx.request.abort\n\t        if (signal.aborted) {\n\t          // no need to send request\n\t          return abort()\n\t        }\n\t        signal.addEventListener('abort', onabort)\n", "      }\n\t      xhr.onloadend = () => {\n\t        if (!xhr) return\n\t        resolve(this.transformResponse(xhr, ctx))\n\t        ctx.request.abort?.signal.removeEventListener('abort', onabort)\n\t        xhr = null\n\t      }\n\t      xhr.onerror = () => {\n\t        if (!xhr) return\n\t        reject(new RequestError('Network Error', ctx))\n", "        xhr = null\n\t      }\n\t      xhr.ontimeout = () => {\n\t        if (!xhr) return\n\t        reject(new RequestError('timeout', ctx))\n\t        xhr = null\n\t      }\n\t      if (this.options?.onDownloadProgress) {\n\t        xhr.addEventListener(\n\t          'progress',\n", "          progressEventReducer(this.options.onDownloadProgress, true)\n\t        )\n\t      }\n\t      // Not all browsers support upload events\n\t      if (this.options?.onUploadProgress && xhr.upload) {\n\t        xhr.addEventListener(\n\t          'progress',\n\t          progressEventReducer(this.options.onUploadProgress)\n\t        )\n\t      }\n", "      xhr.send(this.transformRequest(xhr, ctx) ?? null)\n\t    })\n\t  }\n\t}\n"]}
{"filename": "src/adapter/Adapter.ts", "chunked_list": ["import type { IContext, IResponse } from 'requete'\n\texport abstract class Adapter {\n\t  static readonly supported: boolean\n\t  abstract request(ctx: IContext): Promise<IResponse>\n\t}\n"]}
{"filename": "src/adapter/__tests__/FetchAdapter.test.ts", "chunked_list": ["import { Method, TimeoutAbortController } from 'requete'\n\timport { toAny } from 'test/utils'\n\timport { FetchAdapter } from '../FetchAdapter'\n\tdescribe('FetchAdapter specs', () => {\n\t  const supported = FetchAdapter.supported\n\t  beforeEach(() => {\n\t    vi.clearAllMocks()\n\t  })\n\t  it.each([\n\t    'GET',\n", "    'HEAD',\n\t    'DELETE',\n\t    'OPTIONS',\n\t    'POST',\n\t    'PUT',\n\t    'PATCH',\n\t  ] as Method[])('should make a %s by fetch', (method) => {\n\t    const spy = vi.spyOn(global, 'fetch').mockImplementation(toAny(vi.fn()))\n\t    const headers = new Headers()\n\t    new FetchAdapter()\n", "      .request(\n\t        toAny({\n\t          request: { url: '/do-mock', method, headers },\n\t        })\n\t      )\n\t      .catch(vi.fn())\n\t    expect(spy).toBeCalledWith('/do-mock', {\n\t      method,\n\t      headers, // headers is required in ctx\n\t    })\n", "  })\n\t  it('should set Content-Type header when given a POST request with payload', () => {\n\t    const spy = vi.spyOn(global, 'fetch').mockImplementation(toAny(vi.fn()))\n\t    const data = { a: 1 }\n\t    new FetchAdapter()\n\t      .request(\n\t        toAny({\n\t          request: {\n\t            url: '/do-mock',\n\t            method: 'POST',\n", "            headers: new Headers(),\n\t            data,\n\t          },\n\t        })\n\t      )\n\t      .catch(vi.fn())\n\t    expect(spy).toBeCalledWith('/do-mock', {\n\t      method: 'POST',\n\t      headers: new Headers({\n\t        'Content-Type': 'application/json;charset=utf-8',\n", "      }),\n\t      body: JSON.stringify(data),\n\t    })\n\t  })\n\t  it('should remove Content-Type header when given a POST request without payload', () => {\n\t    const spy = vi.spyOn(global, 'fetch').mockImplementation(toAny(vi.fn()))\n\t    new FetchAdapter()\n\t      .request(\n\t        toAny({\n\t          request: {\n", "            url: '/do-mock',\n\t            method: 'POST',\n\t            headers: new Headers({\n\t              'Content-Type': 'application/json',\n\t            }),\n\t          },\n\t        })\n\t      )\n\t      .catch(vi.fn())\n\t    expect(spy).toBeCalledWith('/do-mock', {\n", "      method: 'POST',\n\t      headers: new Headers(),\n\t    })\n\t  })\n\t  it('should add abortSignal when given ctx with `abort` field', () => {\n\t    const spy = vi.spyOn(global, 'fetch').mockImplementation(toAny(vi.fn()))\n\t    const abort = new TimeoutAbortController(0)\n\t    new FetchAdapter()\n\t      .request(\n\t        toAny({\n", "          request: {\n\t            url: '/do-mock',\n\t            method: 'POST',\n\t            headers: new Headers(),\n\t            abort,\n\t          },\n\t        })\n\t      )\n\t      .catch(vi.fn())\n\t    expect(spy).toBeCalledWith('/do-mock', {\n", "      method: 'POST',\n\t      headers: new Headers(),\n\t      signal: abort.signal,\n\t    })\n\t  })\n\t  it('should thrown ReferenceError when fetch api not supported', async () => {\n\t    // @ts-ignore\n\t    FetchAdapter.supported = false\n\t    await expect(new FetchAdapter().request(toAny({}))).rejects.toThrow(\n\t      ReferenceError\n", "    )\n\t    await expect(new FetchAdapter().request(toAny({}))).rejects.toThrow(\n\t      'Not support fetch api in current environment.'\n\t    )\n\t    // @ts-ignore\n\t    FetchAdapter.supported = supported\n\t  })\n\t})\n"]}
{"filename": "src/adapter/__tests__/create.test.ts", "chunked_list": ["import { createAdapter } from '../create'\n\timport { FetchAdapter } from '../FetchAdapter'\n\timport { XhrAdapter } from '../XhrAdapter'\n\tdescribe('createAdapter specs', () => {\n\t  it('should thrown a ReferenceError when all adapters are not supported', () => {\n\t    // @ts-ignore\n\t    FetchAdapter.supported = false\n\t    // @ts-ignore\n\t    XhrAdapter.supported = false\n\t    expect(createAdapter).toThrow(ReferenceError)\n", "    expect(createAdapter).toThrow(\n\t      'No adapter supported in current environment.'\n\t    )\n\t  })\n\t  it('should return FetchAdapter instance when it supported', () => {\n\t    // @ts-ignore\n\t    FetchAdapter.supported = true\n\t    expect(createAdapter()).toBeInstanceOf(FetchAdapter)\n\t  })\n\t  it('should return XhrAdapter instance when it supported & FetchAdapter not supported', () => {\n", "    // @ts-ignore\n\t    FetchAdapter.supported = false\n\t    // @ts-ignore\n\t    XhrAdapter.supported = true\n\t    expect(createAdapter()).toBeInstanceOf(XhrAdapter)\n\t  })\n\t})\n"]}
{"filename": "src/adapter/__tests__/XhrAdapter.test.ts", "chunked_list": ["import { Method, TimeoutAbortController } from 'requete'\n\timport { sleep, toAny } from 'test/utils'\n\timport * as progress from '../../shared/progress'\n\timport { XhrAdapter } from '../XhrAdapter'\n\tdescribe('XhrAdapter specs', () => {\n\t  const supported = XhrAdapter.supported\n\t  beforeEach(() => {\n\t    vi.clearAllMocks()\n\t  })\n\t  it('should thrown ReferenceError when fetch api not supported', async () => {\n", "    // @ts-ignore\n\t    XhrAdapter.supported = false\n\t    await expect(new XhrAdapter().request(toAny({}))).rejects.toThrow(\n\t      ReferenceError\n\t    )\n\t    await expect(new XhrAdapter().request(toAny({}))).rejects.toThrow(\n\t      'Not support XMLHttpRequest api in current environment.'\n\t    )\n\t    // @ts-ignore\n\t    XhrAdapter.supported = supported\n", "  })\n\t  describe('XhrAdapter: request config specs', () => {\n\t    it.each([\n\t      'GET',\n\t      'HEAD',\n\t      'DELETE',\n\t      'OPTIONS',\n\t      'POST',\n\t      'PUT',\n\t      'PATCH',\n", "    ] as Method[])('should make a %s by XMLHttpRequest', (method) => {\n\t      const openStub = vi.fn()\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n\t        toAny(\n\t          vi.fn().mockReturnValue({\n\t            open: openStub,\n\t          })\n\t        )\n\t      )\n\t      expect(XhrAdapter.supported).toBe(true)\n", "      new XhrAdapter()\n\t        .request(\n\t          toAny({\n\t            request: { url: '/do-mock', method },\n\t          })\n\t        )\n\t        .catch(vi.fn())\n\t      expect(openStub).toBeCalledWith(method, '/do-mock', true)\n\t    })\n\t    it('should set Content-Type header when given a POST request with payload', () => {\n", "      const setRequestHeaderStub = vi.fn()\n\t      const sendStub = vi.fn()\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n\t        toAny(\n\t          vi.fn().mockReturnValue({\n\t            open: vi.fn(),\n\t            setRequestHeader: setRequestHeaderStub,\n\t            send: sendStub,\n\t          })\n\t        )\n", "      )\n\t      const data = { a: 1 }\n\t      new XhrAdapter().request(\n\t        toAny({\n\t          request: {\n\t            url: '/do-mock',\n\t            method: 'POST',\n\t            headers: new Headers(),\n\t            data,\n\t          },\n", "        })\n\t      )\n\t      expect(setRequestHeaderStub).toBeCalledWith(\n\t        'content-type', // lower-case by `Headers`\n\t        'application/json;charset=utf-8'\n\t      )\n\t      expect(sendStub).toBeCalledWith(JSON.stringify(data))\n\t    })\n\t    it('should remove Content-Type header when given a POST request without payload', () => {\n\t      const setRequestHeaderStub = vi.fn()\n", "      const sendStub = vi.fn()\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n\t        toAny(\n\t          vi.fn().mockReturnValue({\n\t            open: vi.fn(),\n\t            setRequestHeader: setRequestHeaderStub,\n\t            send: sendStub,\n\t          })\n\t        )\n\t      )\n", "      new XhrAdapter().request(\n\t        toAny({\n\t          request: {\n\t            url: '/do-mock',\n\t            method: 'POST',\n\t            headers: new Headers({\n\t              'Content-Type': 'application/json',\n\t            }),\n\t          },\n\t        })\n", "      )\n\t      expect(setRequestHeaderStub).not.toBeCalled()\n\t      expect(sendStub).toBeCalledWith(null)\n\t    })\n\t    it('should set timeout to xhr when given timeout in ctx', () => {\n\t      const setterStub = vi.fn()\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n\t        toAny(\n\t          vi.fn().mockReturnValue({\n\t            open: vi.fn(),\n", "            send: vi.fn(),\n\t            set timeout(v: any) {\n\t              setterStub(v)\n\t            },\n\t          })\n\t        )\n\t      )\n\t      new XhrAdapter().request(\n\t        toAny({\n\t          request: {\n", "            url: '/do-mock',\n\t            method: 'POST',\n\t            headers: new Headers(),\n\t            timeout: 1,\n\t          },\n\t        })\n\t      )\n\t      expect(setterStub).toBeCalledWith(1)\n\t    })\n\t    it('should set withCredentials to xhr when given credentials == `include` in ctx', () => {\n", "      const setterStub = vi.fn()\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(\n\t        toAny(\n\t          vi.fn().mockReturnValue({\n\t            open: vi.fn(),\n\t            send: vi.fn(),\n\t            set withCredentials(v: any) {\n\t              setterStub(v)\n\t            },\n\t          })\n", "        )\n\t      )\n\t      new XhrAdapter().request(\n\t        toAny({\n\t          request: {\n\t            url: '/do-mock',\n\t            method: 'POST',\n\t            headers: new Headers(),\n\t            credentials: 'include',\n\t          },\n", "        })\n\t      )\n\t      expect(setterStub).toBeCalledWith(true)\n\t    })\n\t  })\n\t  describe('XhrAdapter: response specs', () => {\n\t    it('should transform response for ctx when the request is onloadend', async () => {\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {\n\t        class FakeXhr {\n\t          onloadend = vi.fn()\n", "          open = vi.fn()\n\t          send() {\n\t            this.onloadend()\n\t          }\n\t          getAllResponseHeaders = () => undefined\n\t        }\n\t        return new FakeXhr() as any\n\t      })\n\t      const response = await new XhrAdapter().request(\n\t        toAny({\n", "          request: {\n\t            url: '/do-mock',\n\t            method: 'POST',\n\t            headers: new Headers(),\n\t            abort: new TimeoutAbortController(0),\n\t          },\n\t        })\n\t      )\n\t      expect(response).toEqual({\n\t        ok: false,\n", "        status: undefined,\n\t        statusText: undefined,\n\t        headers: new Headers(),\n\t        redirected: false,\n\t        type: 'default',\n\t        url: undefined,\n\t        data: undefined,\n\t      })\n\t    })\n\t    it.each([\n", "      { status: 200, expected: true },\n\t      { status: 201, expected: true },\n\t      { status: 301, expected: false },\n\t      { status: 404, expected: false },\n\t      { status: 500, expected: false },\n\t    ])(\n\t      'should set response.ok is $expected when response status is $status',\n\t      async ({ status, expected }) => {\n\t        vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {\n\t          class FakeXhr {\n", "            status = status\n\t            onloadend = vi.fn()\n\t            open = vi.fn()\n\t            send() {\n\t              this.onloadend()\n\t            }\n\t            getAllResponseHeaders = () => undefined\n\t          }\n\t          return new FakeXhr() as any\n\t        })\n", "        const { ok } = await new XhrAdapter().request(\n\t          toAny({\n\t            request: {\n\t              url: '/do-mock',\n\t              method: 'POST',\n\t              headers: new Headers(),\n\t            },\n\t          })\n\t        )\n\t        expect(ok).toBe(expected)\n", "      }\n\t    )\n\t    it.each([\n\t      { responseType: 'blob', resIndex: 1 },\n\t      { responseType: 'arrayBuffer', resIndex: 1 },\n\t      { responseType: 'formData', resIndex: 1 },\n\t      { responseType: 'json', resIndex: 0 },\n\t      { responseType: 'text', resIndex: 0 },\n\t    ])(\n\t      'should get response data after loadend when given then responseType is $responseType',\n", "      async ({ responseType, resIndex }) => {\n\t        const mockRes = ['mock responseText', 'mock response']\n\t        vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {\n\t          class FakeXhr {\n\t            responseText = mockRes[0]\n\t            response = mockRes[1]\n\t            onloadend = vi.fn()\n\t            open = vi.fn()\n\t            send() {\n\t              this.onloadend()\n", "            }\n\t            getAllResponseHeaders = () => undefined\n\t          }\n\t          return new FakeXhr() as any\n\t        })\n\t        const { data } = await new XhrAdapter().request(\n\t          toAny({\n\t            request: {\n\t              url: '/do-mock',\n\t              method: 'POST',\n", "              headers: new Headers(),\n\t              responseType,\n\t            },\n\t          })\n\t        )\n\t        expect(data).toBe(mockRes[resIndex])\n\t      }\n\t    )\n\t  })\n\t  describe('XhrAdapter: exception specs', () => {\n", "    it('should thrown a error when request onerror', async () => {\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {\n\t        class FakeXhr {\n\t          onerror = vi.fn()\n\t          open = vi.fn()\n\t          send() {\n\t            this.onerror()\n\t          }\n\t          getAllResponseHeaders = () => undefined\n\t        }\n", "        return new FakeXhr() as any\n\t      })\n\t      await expect(\n\t        new XhrAdapter().request(toAny({ request: { headers: new Headers() } }))\n\t      ).rejects.toThrow('Network Error')\n\t    })\n\t    it('should thrown a error when request ontimeout', async () => {\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {\n\t        class FakeXhr {\n\t          ontimeout = vi.fn()\n", "          open = vi.fn()\n\t          send() {\n\t            this.ontimeout()\n\t          }\n\t          getAllResponseHeaders = () => undefined\n\t        }\n\t        return new FakeXhr() as any\n\t      })\n\t      await expect(\n\t        new XhrAdapter().request(toAny({ request: { headers: new Headers() } }))\n", "      ).rejects.toThrow('timeout')\n\t    })\n\t  })\n\t  describe('XhrAdapter: abort specs', () => {\n\t    it('should thrown error & don`t send request when given a aborted AbortController in ctx', async () => {\n\t      const sendStub = vi.fn()\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {\n\t        class FakeXhr {\n\t          open = vi.fn()\n\t          send = sendStub\n", "          getAllResponseHeaders = () => undefined\n\t        }\n\t        return new FakeXhr() as any\n\t      })\n\t      const adapter = new XhrAdapter()\n\t      let controller = new TimeoutAbortController(0)\n\t      controller.abort()\n\t      await expect(\n\t        adapter.request(\n\t          toAny({ request: { headers: new Headers(), abort: controller } })\n", "        )\n\t      ).rejects.toThrow('aborted')\n\t      expect(sendStub).not.toBeCalled()\n\t      controller = new TimeoutAbortController(0)\n\t      controller.abort('canceled')\n\t      await expect(\n\t        adapter.request(\n\t          toAny({ request: { headers: new Headers(), abort: controller } })\n\t        )\n\t      ).rejects.toThrow('canceled')\n", "    })\n\t    it('should abort the pending request by AbortController', async () => {\n\t      const abortStub = vi.fn()\n\t      const onloadendStub = vi.fn()\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {\n\t        class FakeXhr {\n\t          open = vi.fn()\n\t          getAllResponseHeaders = () => undefined\n\t          onloadend = vi.fn()\n\t          send = () => sleep(1000).then(() => this.onloadend)\n", "          abort = abortStub\n\t        }\n\t        return new FakeXhr() as any\n\t      })\n\t      const adapter = new XhrAdapter()\n\t      const controller = new TimeoutAbortController(0)\n\t      const request = adapter.request(\n\t        toAny({ request: { headers: new Headers(), abort: controller } })\n\t      )\n\t      controller.abort('why abort?')\n", "      await expect(request).rejects.toThrow('why abort?')\n\t      expect(abortStub).toBeCalled()\n\t      expect(onloadendStub).not.toBeCalled()\n\t    })\n\t  })\n\t  describe('XhrAdapter: with progress options', () => {\n\t    it('should not set `onDownloadProgress` to xhr when given the option', () => {\n\t      const handleStub = vi.fn()\n\t      const spy = vi\n\t        .spyOn(progress, 'progressEventReducer')\n", "        .mockImplementation(toAny(vi.fn().mockReturnValue(handleStub)))\n\t      const addEventListenerStub = vi.fn()\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {\n\t        class FakeXhr {\n\t          open = vi.fn()\n\t          send = vi.fn()\n\t          addEventListener = addEventListenerStub\n\t        }\n\t        return new FakeXhr() as any\n\t      })\n", "      const onDownloadProgress = vi.fn()\n\t      new XhrAdapter({ onDownloadProgress }).request(\n\t        toAny({ request: { headers: new Headers() } })\n\t      )\n\t      expect(spy).toBeCalledWith(onDownloadProgress, true)\n\t      expect(addEventListenerStub).toBeCalledWith('progress', handleStub)\n\t    })\n\t    it('should set `onUploadProgress` to xhr when given the option & it support upload', () => {\n\t      const handleStub = vi.fn()\n\t      const spy = vi\n", "        .spyOn(progress, 'progressEventReducer')\n\t        .mockImplementation(toAny(vi.fn().mockReturnValue(handleStub)))\n\t      const addEventListenerStub = vi.fn()\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {\n\t        class FakeXhr {\n\t          open = vi.fn()\n\t          send = vi.fn()\n\t          addEventListener = addEventListenerStub\n\t          upload = true\n\t        }\n", "        return new FakeXhr() as any\n\t      })\n\t      const onUploadProgress = vi.fn()\n\t      new XhrAdapter({ onUploadProgress }).request(\n\t        toAny({ request: { headers: new Headers() } })\n\t      )\n\t      expect(spy).toBeCalledWith(onUploadProgress)\n\t      expect(addEventListenerStub).toBeCalledWith('progress', handleStub)\n\t    })\n\t    it('should not set `onUploadProgress` to xhr when it not support upload', () => {\n", "      const spy = vi\n\t        .spyOn(progress, 'progressEventReducer')\n\t        .mockImplementation(toAny(vi.fn()))\n\t      const addEventListenerStub = vi.fn()\n\t      vi.spyOn(global, 'XMLHttpRequest').mockImplementation(() => {\n\t        class FakeXhr {\n\t          open = vi.fn()\n\t          send = vi.fn()\n\t          addEventListener = addEventListenerStub\n\t        }\n", "        return new FakeXhr() as any\n\t      })\n\t      new XhrAdapter({ onUploadProgress: vi.fn() }).request(\n\t        toAny({ request: { headers: new Headers() } })\n\t      )\n\t      expect(spy).not.toBeCalled()\n\t      expect(addEventListenerStub).not.toBeCalled()\n\t    })\n\t  })\n\t})\n"]}
{"filename": "src/middleware/timestamp.ts", "chunked_list": ["import type { Method, Middleware } from 'requete'\n\texport function timestamp(key = '_', methods: Method[] = ['GET']): Middleware {\n\t  return async function addTimestamp(ctx, next) {\n\t    if (methods.includes(ctx.request.method)) {\n\t      ctx.params({ [key]: Date.now() })\n\t    }\n\t    await next()\n\t  }\n\t}\n"]}
