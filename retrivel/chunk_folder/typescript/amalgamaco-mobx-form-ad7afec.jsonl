{"filename": "tests/ManualField.test.ts", "chunked_list": ["import Field, { type FieldParams } from '../src/Field';\n\timport ManualField from '../src/ManualField';\n\timport { invalid, valid } from '../src/validators';\n\timport { itCallsTheOnChangeCallback } from './support/callbacks';\n\tdescribe( 'ManualField', () => {\n\t\tconst after2021 = ( value: Date ) => (\n\t\t\tvalue.getFullYear() > 2021 ? valid() : invalid( 'Date is invalid' )\n\t\t);\n\t\tconst createField = ( params?: Partial<FieldParams<Date>> ) => new ManualField<Date>( {\n\t\t\tdefaultValue: new Date(),\n", "\t\tvalue: new Date( 2022, 10, 10 ),\n\t\t\tvalidators: [ after2021 ],\n\t\t\t...params\n\t\t} );\n\t\tconst itChangesTheFieldValue = (\n\t\t\tchangingAction: ( field: ManualField<Date>, value: Date ) => void\n\t\t) => {\n\t\t\tit( 'updates the value of the field with the given one', () => {\n\t\t\t\tconst field = createField();\n\t\t\t\tconst newValue = new Date( 2022, 12, 3 );\n", "\t\t\tchangingAction( field, newValue );\n\t\t\t\texpect( field.value ).toEqual( newValue );\n\t\t\t} );\n\t\t\tit( 'shows the error if the new value is not valid', () => {\n\t\t\t\tconst field = createField();\n\t\t\t\tchangingAction( field, new Date( 2021, 11, 31 ) );\n\t\t\t\texpect( field.error ).toEqual( 'Date is invalid' );\n\t\t\t} );\n\t\t\tit( 'hides the error if the old value was invalid and the new one is not', () => {\n\t\t\t\tconst field = createField();\n", "\t\t\tchangingAction( field, new Date( 2021, 11, 31 ) );\n\t\t\t\tchangingAction( field, new Date( 2022, 0, 1 ) );\n\t\t\t\texpect( field.error ).toEqual( '' );\n\t\t\t} );\n\t\t\titCallsTheOnChangeCallback<ManualField<Date>>( {\n\t\t\t\tfieldBuilder: onChange => createField( { onChange } ),\n\t\t\t\tchangingAction,\n\t\t\t\tsampleValue: new Date()\n\t\t\t} );\n\t\t};\n", "\tit( 'is a Field', () => {\n\t\t\tconst field = createField();\n\t\t\texpect( field ).toBeInstanceOf( Field );\n\t\t} );\n\t\tdescribe( '@change', () => {\n\t\t\titChangesTheFieldValue( ( field, value ) => field.change( value ) );\n\t\t} );\n\t\tdescribe( '@set', () => {\n\t\t\titChangesTheFieldValue( ( field, value ) => field.set( value ) );\n\t\t} );\n", "\tdescribe( '@select', () => {\n\t\t\titChangesTheFieldValue( ( field, value ) => field.select( value ) );\n\t\t} );\n\t} );\n"]}
{"filename": "tests/Field.test.ts", "chunked_list": ["import TestField from './support/TestField';\n\timport type { FieldParams } from '../src/Field';\n\timport Form from '../src/Form';\n\timport { invalid, valid } from '../src/validators';\n\tdescribe( 'Field', () => {\n\t\tconst label = 'A field';\n\t\tconst hint = 'Some hint';\n\t\tconst initialValue = 'Content';\n\t\tconst defaultValue = 'Defval';\n\t\tconst presenceValidator = ( value: string ) => (\n", "\t\tvalue ? valid() : invalid( 'This is required.' )\n\t\t);\n\t\tconst lengthValidator = ( value: string ) => (\n\t\t\tvalue.length <= 7 ? valid() : invalid( 'Too long!' )\n\t\t);\n\t\tconst createField = ( params?: Partial<FieldParams<string>> ) => new TestField( {\n\t\t\tlabel,\n\t\t\thint,\n\t\t\tdefaultValue,\n\t\t\tvalue: initialValue,\n", "\t\tvalidators: [ presenceValidator, lengthValidator ],\n\t\t\tdisabled: false,\n\t\t\t...params\n\t\t} );\n\t\tdescribe( 'constructor', () => {\n\t\t\tit( 'assigns the given attributes to the field', () => {\n\t\t\t\tconst field = createField();\n\t\t\t\texpect( field.label ).toEqual( label );\n\t\t\t\texpect( field.hint ).toEqual( hint );\n\t\t\t\texpect( field.value ).toEqual( initialValue );\n", "\t\t\texpect( field.isDisabled ).toEqual( false );\n\t\t\t\tconst disabledField = createField( { disabled: true } );\n\t\t\t\texpect( disabledField.isDisabled ).toEqual( true );\n\t\t\t} );\n\t\t\tdescribe( 'without label, hint and disabled attributes', () => {\n\t\t\t\tit( 'assigns default values for them', () => {\n\t\t\t\t\tconst field = createField( { label: undefined, hint: undefined, disabled: undefined } );\n\t\t\t\t\texpect( field.label ).toEqual( '' );\n\t\t\t\t\texpect( field.hint ).toEqual( '' );\n\t\t\t\t\texpect( field.isDisabled ).toBe( false );\n", "\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'without value', () => {\n\t\t\t\tit( 'assigns the given defaultValue as the initial value', () => {\n\t\t\t\t\tconst field = createField( { value: undefined, hint: undefined, disabled: undefined } );\n\t\t\t\t\texpect( field.value ).toBe( defaultValue );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@isValid', () => {\n", "\t\tdescribe( 'when the field is constructed with a value not accepted by a validator', () => {\n\t\t\t\tit( 'returns false', () => {\n\t\t\t\t\tconst field = createField( { value: 'Too long' } );\n\t\t\t\t\texpect( field.isValid ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the field is constructed with a value accepted by all validators', () => {\n\t\t\t\tit( 'returns true', () => {\n\t\t\t\t\tconst field = createField( { value: 'Ok' } );\n\t\t\t\t\texpect( field.isValid ).toBe( true );\n", "\t\t\t} );\n\t\t\t\tdescribe( 'but is then updated with a value not accepted by a validator', () => {\n\t\t\t\t\tit( 'returns false', () => {\n\t\t\t\t\t\tconst field = createField( { value: 'Ok' } );\n\t\t\t\t\t\tfield.change( '' );\n\t\t\t\t\t\texpect( field.isValid ).toBe( false );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n", "\tdescribe( '@isDirty', () => {\n\t\t\tdescribe( 'when the field\\'s value has not changed', () => {\n\t\t\t\tit( 'returns false', () => {\n\t\t\t\t\tconst field = createField();\n\t\t\t\t\texpect( field.isDirty ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the field\\'s value has changed', () => {\n\t\t\t\tit( 'returns true', () => {\n\t\t\t\t\tconst field = createField();\n", "\t\t\t\tfield.change( 'Other content' );\n\t\t\t\t\texpect( field.isDirty ).toBe( true );\n\t\t\t\t} );\n\t\t\t\tdescribe( 'but is then changed to the initial value given in constructor', () => {\n\t\t\t\t\tit( 'returns false', () => {\n\t\t\t\t\t\tconst field = createField();\n\t\t\t\t\t\tfield.change( 'Other content' );\n\t\t\t\t\t\tfield.change( initialValue );\n\t\t\t\t\t\texpect( field.isDirty ).toBe( false );\n\t\t\t\t\t} );\n", "\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@setIsDisabled', () => {\n\t\t\tdescribe( 'when called with false', () => {\n\t\t\t\tit( 'sets the field as enabled', () => {\n\t\t\t\t\tconst field = createField( { disabled: true } );\n\t\t\t\t\tfield.setIsDisabled( false );\n\t\t\t\t\texpect( field.isDisabled ).toBe( false );\n\t\t\t\t} );\n", "\t\t} );\n\t\t\tdescribe( 'when called with true', () => {\n\t\t\t\tit( 'sets the field as disabled', () => {\n\t\t\t\t\tconst field = createField( { disabled: false } );\n\t\t\t\t\tfield.setIsDisabled( true );\n\t\t\t\t\texpect( field.isDisabled ).toBe( true );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@clear', () => {\n", "\t\tit( 'sets the defaultValue given in constructor as the new value', () => {\n\t\t\t\tconst field = createField();\n\t\t\t\tfield.clear();\n\t\t\t\texpect( field.value ).toEqual( defaultValue );\n\t\t\t} );\n\t\t\tit( 'stops showing the error message', () => {\n\t\t\t\tconst field = createField();\n\t\t\t\tfield.change( '' );\n\t\t\t\tfield.syncError();\n\t\t\t\tfield.clear();\n", "\t\t\texpect( field.error ).toEqual( '' );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@reset', () => {\n\t\t\tit( 'resets the value of the field with the value given in constructor', () => {\n\t\t\t\tconst field = createField();\n\t\t\t\tfield.change( 'New content' );\n\t\t\t\tfield.reset();\n\t\t\t\texpect( field.value ).toEqual( initialValue );\n\t\t\t} );\n", "\t\tit( 'stops showing the error message', () => {\n\t\t\t\tconst field = createField();\n\t\t\t\tfield.change( '' );\n\t\t\t\tfield.syncError();\n\t\t\t\tfield.reset();\n\t\t\t\texpect( field.error ).toEqual( '' );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@syncError', () => {\n\t\t\tdescribe( 'when the field is valid', () => {\n", "\t\t\tdescribe( 'and no error is being shown', () => {\n\t\t\t\t\tit( 'does not show any error message on the field', () => {\n\t\t\t\t\t\tconst field = createField();\n\t\t\t\t\t\tfield.syncError();\n\t\t\t\t\t\texpect( field.error ).toEqual( '' );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t\tdescribe( 'and an error is being shown', () => {\n\t\t\t\t\tit( 'hides the shown error message', () => {\n\t\t\t\t\t\tconst field = createField();\n", "\t\t\t\t\tfield.change( '' );\n\t\t\t\t\t\tfield.syncError();\n\t\t\t\t\t\tfield.change( 'good' );\n\t\t\t\t\t\tfield.syncError();\n\t\t\t\t\t\texpect( field.error ).toEqual( '' );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the field is invalid', () => {\n\t\t\t\tdescribe( 'and no error is being shown', () => {\n", "\t\t\t\tit( 'shows the error message of the first failing validator', () => {\n\t\t\t\t\t\tconst field = createField();\n\t\t\t\t\t\tfield.change( 'quite long' );\n\t\t\t\t\t\tfield.syncError();\n\t\t\t\t\t\texpect( field.error ).toEqual( 'Too long!' );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t\tdescribe( 'and an error is being shown', () => {\n\t\t\t\t\tit( 'shows the error message of the first failing validator', () => {\n\t\t\t\t\t\tconst field = createField();\n", "\t\t\t\t\tfield.change( 'quite long' );\n\t\t\t\t\t\tfield.syncError();\n\t\t\t\t\t\tfield.change( '' );\n\t\t\t\t\t\tfield.syncError();\n\t\t\t\t\t\texpect( field.error ).toEqual( 'This is required.' );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@showError', () => {\n", "\t\tit( 'displays the given error on the field', () => {\n\t\t\t\tconst field = createField();\n\t\t\t\tconst error = 'That value is already being used';\n\t\t\t\tfield.showError( error );\n\t\t\t\texpect( field.error ).toEqual( error );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@attachToForm', () => {\n\t\t\tconst createAndAttachField = () => {\n\t\t\t\tconst validator = jest.fn(\n", "\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\t( _value: string, _form?: Form, _label?: string ) => valid()\n\t\t\t\t);\n\t\t\t\tconst form = new Form( {\n\t\t\t\t\tfields: {},\n\t\t\t\t\tonSubmit: () => Promise.resolve()\n\t\t\t\t} );\n\t\t\t\tconst field = createField( { validators: [ validator ] } );\n\t\t\t\tfield.attachToForm( form );\n\t\t\t\treturn { field, form, validator };\n", "\t\t};\n\t\t\tdescribe( 'when the field is not attached to any form', () => {\n\t\t\t\tit( 'starts passing the given form and field key to the validators', () => {\n\t\t\t\t\tconst { field, form, validator } = createAndAttachField();\n\t\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\t\tfield.isValid;\n\t\t\t\t\texpect( validator ).toHaveBeenCalledWith( field.value, form, field.label );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the field is already attached to a form', () => {\n", "\t\t\tit( 'throws a runtime error', () => {\n\t\t\t\t\tconst { field, form } = createAndAttachField();\n\t\t\t\t\texpect( () => field.attachToForm( form ) ).toThrow( Error );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t} );\n"]}
{"filename": "tests/Form.test.ts", "chunked_list": ["import ManualField from '../src/ManualField';\n\timport TestField from './support/TestField';\n\timport Form, { FormParams } from '../src/Form';\n\timport { invalid, valid } from '../src/validators';\n\tdescribe( 'Form', () => {\n\t\tconst required = ( value: string ) => (\n\t\t\tvalue ? valid() : invalid( 'This field is required.' )\n\t\t);\n\t\tconst atLeastEightChars = ( value: string ) => (\n\t\t\tvalue.length >= 8 ? valid() : invalid( 'At least eight chars.' )\n", "\t);\n\t\tconst matchPassword = ( value: string, form?: Form ) => (\n\t\t\tvalue === form?.field( 'password' ).value ? valid() : invalid( 'Password does not match' )\n\t\t);\n\t\tconst fields = {\n\t\t\temail: {\n\t\t\t\tlabel: 'Email',\n\t\t\t\thint: 'Write it with a known domain',\n\t\t\t\tdefaultValue: 'no email',\n\t\t\t\tvalue: 'autofilled@test.com',\n", "\t\t\tvalidators: [ required ],\n\t\t\t\tdisabled: false\n\t\t\t},\n\t\t\tpassword: {\n\t\t\t\tlabel: 'Password',\n\t\t\t\thint: 'At least 8 characters',\n\t\t\t\tdefaultValue: 'no password',\n\t\t\t\tvalue: '',\n\t\t\t\tvalidators: [ required, atLeastEightChars ],\n\t\t\t\tdisabled: false\n", "\t\t},\n\t\t\tpasswordConfirmation: {\n\t\t\t\tlabel: 'Password confirmation',\n\t\t\t\tdefaultValue: 'no password confirmation',\n\t\t\t\tvalue: '',\n\t\t\t\tvalidators: [ required, matchPassword ]\n\t\t\t},\n\t\t\tdocument: {\n\t\t\t\tlabel: 'Document',\n\t\t\t\tdefaultValue: 'no document',\n", "\t\t\tvalue: 'unused',\n\t\t\t\tvalidators: [ atLeastEightChars ],\n\t\t\t\tdisabled: true\n\t\t\t},\n\t\t\tadmin: {\n\t\t\t\tlabel: 'Admin?',\n\t\t\t\tdefaultValue: true,\n\t\t\t\tvalue: true\n\t\t\t}\n\t\t};\n", "\tconst onSubmit = jest.fn( () => Promise.resolve() );\n\t\tconst createForm = ( params?: Partial<FormParams> ) => new Form( {\n\t\t\tfields: {\n\t\t\t\temail: new TestField( fields.email ),\n\t\t\t\tpassword: new TestField( fields.password ),\n\t\t\t\tpasswordConfirmation: new TestField( fields.passwordConfirmation ),\n\t\t\t\tdocument: new TestField( fields.document ),\n\t\t\t\tadmin: new ManualField( fields.admin )\n\t\t\t},\n\t\t\tonSubmit,\n", "\t\t...params\n\t\t} );\n\t\tconst createFormAndMakeItValid = ( params?: Partial<FormParams> ) => {\n\t\t\tconst form = createForm( params );\n\t\t\tform.field<TestField>( 'password' ).change( 'validpass' );\n\t\t\tform.field<TestField>( 'passwordConfirmation' ).change( 'validpass' );\n\t\t\treturn form;\n\t\t};\n\t\tconst itClearsTheErrorMessageOfEachField = ( action: ( form: Form ) => void ) => {\n\t\t\tit( 'clears the error message of each field', () => {\n", "\t\t\tconst form = createForm();\n\t\t\t\tform.field<TestField>( 'email' ).change( '' );\n\t\t\t\tform.field<TestField>( 'password' ).change( '' );\n\t\t\t\tform.submit();\n\t\t\t\taction( form );\n\t\t\t\t[ 'email', 'password', 'passwordConfirmation', 'document', 'admin' ].forEach( ( key ) => {\n\t\t\t\t\texpect( form.field( key ).error ).toEqual( '' );\n\t\t\t\t} );\n\t\t\t} );\n\t\t};\n", "\tafterEach( () => jest.clearAllMocks() );\n\t\tdescribe( '@fields', () => {\n\t\t\tit( 'returns an object with all the fields indexed by their keys', () => {\n\t\t\t\tconst form = createForm();\n\t\t\t\texpect( form.fields ).toEqual( {\n\t\t\t\t\temail: form.field( 'email' ),\n\t\t\t\t\tpassword: form.field( 'password' ),\n\t\t\t\t\tpasswordConfirmation: form.field( 'passwordConfirmation' ),\n\t\t\t\t\tdocument: form.field( 'document' ),\n\t\t\t\t\tadmin: form.field( 'admin' )\n", "\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@values', () => {\n\t\t\tit( 'returns an object with values per field key', () => {\n\t\t\t\tconst form = createForm();\n\t\t\t\texpect( form.values ).toEqual( {\n\t\t\t\t\temail: fields.email.value,\n\t\t\t\t\tpassword: fields.password.value,\n\t\t\t\t\tpasswordConfirmation: fields.passwordConfirmation.value,\n", "\t\t\t\tdocument: fields.document.value,\n\t\t\t\t\tadmin: fields.admin.value\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@dirtyValues', () => {\n\t\t\tdescribe( 'when no field is dirty', () => {\n\t\t\t\tit( 'returns an empty object', () => {\n\t\t\t\t\tconst form = createForm();\n\t\t\t\t\texpect( form.dirtyValues ).toEqual( {} );\n", "\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when one or more fields are dirty', () => {\n\t\t\t\tit( 'returns the values of the dirty fields', () => {\n\t\t\t\t\tconst form = createForm();\n\t\t\t\t\tform.field<TestField>( 'email' ).change( 'new@test.com' );\n\t\t\t\t\tform.field<ManualField<boolean>>( 'admin' ).change( false );\n\t\t\t\t\texpect( form.dirtyValues ).toEqual( {\n\t\t\t\t\t\temail: 'new@test.com',\n\t\t\t\t\t\tadmin: false\n", "\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@isValid', () => {\n\t\t\tdescribe( 'when all fields are valid', () => {\n\t\t\t\tit( 'returns true', () => {\n\t\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\tform.field<TestField>( 'document' ).change( 'validdoc' );\n\t\t\t\t\texpect( form.isValid ).toBe( true );\n", "\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when only disabled fields are invalid', () => {\n\t\t\t\tit( 'returns true', () => {\n\t\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\texpect( form.isValid ).toBe( true );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when at least one enabled field is invalid', () => {\n\t\t\t\tit( 'returns false', () => {\n", "\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\tform.field<TestField>( 'passwordConfirmation' ).change( 'is not the password' );\n\t\t\t\t\texpect( form.isValid ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@isDirty', () => {\n\t\t\tdescribe( 'when no field is dirty', () => {\n\t\t\t\tit( 'returns false', () => {\n\t\t\t\t\tconst form = createForm();\n", "\t\t\t\texpect( form.isDirty ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when one or more fields are dirty', () => {\n\t\t\t\tit( 'returns true', () => {\n\t\t\t\t\tconst form = createForm();\n\t\t\t\t\tform.field<TestField>( 'password' ).change( 'sekret' );\n\t\t\t\t\texpect( form.isDirty ).toBe( true );\n\t\t\t\t} );\n\t\t\t} );\n", "\t} );\n\t\tdescribe( '@isReadyToSubmit', () => {\n\t\t\tdescribe( 'when one or more fields are invalid', () => {\n\t\t\t\tit( 'returns false', () => {\n\t\t\t\t\tconst form = createForm();\n\t\t\t\t\texpect( form.isReadyToSubmit ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the form is not dirty', () => {\n\t\t\t\tit( 'returns false', () => {\n", "\t\t\t\tconst form = createForm( {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\temail: new TestField( fields.email )\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t\texpect( form.isReadyToSubmit ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the form is being submitted', () => {\n\t\t\t\tit( 'returns false', () => {\n", "\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\tform.submit();\n\t\t\t\t\texpect( form.isReadyToSubmit ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the form is valid, dirty and is not being submitted', () => {\n\t\t\t\tit( 'returns true', () => {\n\t\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\texpect( form.isReadyToSubmit ).toBe( true );\n\t\t\t\t} );\n", "\t\t} );\n\t\t} );\n\t\tdescribe( '@field', () => {\n\t\t\tit( 'returns the field that has the given key', () => {\n\t\t\t\tconst form = createForm();\n\t\t\t\tconst documentField = form.field<TestField>( 'document' );\n\t\t\t\texpect( documentField.label ).toEqual( 'Document' );\n\t\t\t\texpect( documentField.value ).toEqual( 'unused' );\n\t\t\t\texpect( documentField.isDisabled ).toBe( true );\n\t\t\t} );\n", "\t} );\n\t\tdescribe( '@select', () => {\n\t\t\tit( 'returns the field that has the given key', () => {\n\t\t\t\tconst form = createForm();\n\t\t\t\tconst documentField = form.select<TestField>( 'document' );\n\t\t\t\texpect( documentField.label ).toEqual( 'Document' );\n\t\t\t\texpect( documentField.value ).toEqual( 'unused' );\n\t\t\t\texpect( documentField.isDisabled ).toBe( true );\n\t\t\t} );\n\t\t} );\n", "\tdescribe( '@eachField', () => {\n\t\t\tit( 'executes the given callback for each field', () => {\n\t\t\t\tconst form = createForm();\n\t\t\t\tconst fieldLabels: string[] = [];\n\t\t\t\tform.eachField( ( field ) => {\n\t\t\t\t\tfieldLabels.push( field.label );\n\t\t\t\t} );\n\t\t\t\texpect( fieldLabels ).toEqual(\n\t\t\t\t\tObject.values( fields ).map( ( { label } ) => label )\n\t\t\t\t);\n", "\t\t} );\n\t\t} );\n\t\tdescribe( '@submit', () => {\n\t\t\tit( 'syncronizes the errors of all fields', () => {\n\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\tconst email = form.field<TestField>( 'email' );\n\t\t\t\tconst password = form.field<TestField>( 'password' );\n\t\t\t\temail.change( '' );\n\t\t\t\temail.syncError();\n\t\t\t\temail.change( 'valid@again.com' );\n", "\t\t\tpassword.change( 'short' );\n\t\t\t\tform.submit();\n\t\t\t\texpect( email.error ).toEqual( '' );\n\t\t\t\texpect( password.error ).toEqual( 'At least eight chars.' );\n\t\t\t} );\n\t\t\tdescribe( 'when the form is valid and is not being submitted', () => {\n\t\t\t\tit( 'calls the onSubmit callback with itself as parameter', () => {\n\t\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\tform.submit();\n\t\t\t\t\texpect( onSubmit ).toHaveBeenCalledWith( form );\n", "\t\t\t} );\n\t\t\t\tit( 'sets isSubmitting to true', () => {\n\t\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\tform.submit();\n\t\t\t\t\texpect( form.isSubmitting ).toBe( true );\n\t\t\t\t} );\n\t\t\t\tdescribe( 'when the onSubmit promise is resolved', () => {\n\t\t\t\t\tit( 'sets isSubmitting to false again', async () => {\n\t\t\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\t\tawait form.submit();\n", "\t\t\t\t\texpect( form.isSubmitting ).toBe( false );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t\tdescribe( 'when the onSubmit promise is rejected', () => {\n\t\t\t\t\tbeforeEach( () => onSubmit.mockRejectedValueOnce( 'error' ) );\n\t\t\t\t\tit( 'sets isSubmitting to false again and the returned promise is rejected', async () => {\n\t\t\t\t\t\texpect.assertions( 1 );\n\t\t\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait form.submit();\n", "\t\t\t\t\t} catch {\n\t\t\t\t\t\t\texpect( form.isSubmitting ).toBe( false );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t\tdescribe( 'when the onSubmit callback does not return anything', () => {\n\t\t\t\t\tit( 'returns a resolved promise', async () => {\n\t\t\t\t\t\tconst form = createForm( { onSubmit: () => undefined } );\n\t\t\t\t\t\tawait expect( form.submit() ).resolves.not.toThrow();\n\t\t\t\t\t} );\n", "\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the form is invalid', () => {\n\t\t\t\tit( 'does not call the onSubmit callback', () => {\n\t\t\t\t\tconst form = createForm();\n\t\t\t\t\tform.submit();\n\t\t\t\t\texpect( onSubmit ).not.toHaveBeenCalled();\n\t\t\t\t} );\n\t\t\t\tit( 'returns a resolved promise', async () => {\n\t\t\t\t\tconst form = createForm();\n", "\t\t\t\tform.submit();\n\t\t\t\t\tawait expect( form.submit() ).resolves.not.toThrow();\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the form is being submitted', () => {\n\t\t\t\tit( 'does not call the onSubmit callback', () => {\n\t\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\tform.submit();\n\t\t\t\t\tform.submit();\n\t\t\t\t\texpect( onSubmit ).toHaveBeenCalledTimes( 1 );\n", "\t\t\t} );\n\t\t\t\tit( 'returns a resolved promise', async () => {\n\t\t\t\t\tconst form = createFormAndMakeItValid();\n\t\t\t\t\tform.submit();\n\t\t\t\t\tawait expect( form.submit() ).resolves.not.toThrow();\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@clear', () => {\n\t\t\tit( 'sets the value of each field to its default value', () => {\n", "\t\t\tconst form = createForm();\n\t\t\t\tform.clear();\n\t\t\t\texpect( form.values ).toEqual( {\n\t\t\t\t\temail: 'no email',\n\t\t\t\t\tpassword: 'no password',\n\t\t\t\t\tpasswordConfirmation: 'no password confirmation',\n\t\t\t\t\tdocument: 'no document',\n\t\t\t\t\tadmin: true\n\t\t\t\t} );\n\t\t\t} );\n", "\t\titClearsTheErrorMessageOfEachField( form => form.clear() );\n\t\t} );\n\t\tdescribe( '@reset', () => {\n\t\t\tit( 'resets the value of each field', () => {\n\t\t\t\tconst form = createForm();\n\t\t\t\tform.field<TestField>( 'email' ).change( 'dirty@test.com' );\n\t\t\t\tform.field<TestField>( 'password' ).change( 'dirty' );\n\t\t\t\tform.reset();\n\t\t\t\texpect( form.values ).toEqual( {\n\t\t\t\t\temail: fields.email.value,\n", "\t\t\t\tpassword: fields.password.value,\n\t\t\t\t\tpasswordConfirmation: fields.passwordConfirmation.value,\n\t\t\t\t\tdocument: fields.document.value,\n\t\t\t\t\tadmin: fields.admin.value\n\t\t\t\t} );\n\t\t\t} );\n\t\t\titClearsTheErrorMessageOfEachField( form => form.reset() );\n\t\t} );\n\t\tdescribe( '@showErrors', () => {\n\t\t\tit( 'shows the given errors on the fields', () => {\n", "\t\t\tconst form = createForm();\n\t\t\t\tconst errors = {\n\t\t\t\t\temail: 'This email is being used',\n\t\t\t\t\tdocument: 'This document failed the external validation'\n\t\t\t\t};\n\t\t\t\tform.showErrors( errors );\n\t\t\t\texpect( form.field( 'email' ).error ).toEqual( errors.email );\n\t\t\t\texpect( form.field( 'document' ).error ).toEqual( errors.document );\n\t\t\t} );\n\t\t\tit( 'ignores errors for fields that do not exist', () => {\n", "\t\t\tconst form = createForm();\n\t\t\t\texpect( () => form.showErrors( { age: 'Invalid' } ) ).not.toThrow();\n\t\t\t} );\n\t\t} );\n\t} );\n"]}
{"filename": "tests/multiSelect.test.ts", "chunked_list": ["import ManualField from '../src/ManualField';\n\timport multiSelect, { type MultiSelectParams } from '../src/multiSelect';\n\tdescribe( 'multiSelect', () => {\n\t\tconst createMultiSelect = (\n\t\t\tparams?: Partial<MultiSelectParams<number>>\n\t\t) => multiSelect<number>( {\n\t\t\tlabel: 'Numbers of interest',\n\t\t\t...params\n\t\t} );\n\t\tit( 'returns a ManualField', () => {\n", "\t\tconst field = createMultiSelect();\n\t\t\texpect( field ).toBeInstanceOf( ManualField );\n\t\t} );\n\t\tdescribe( 'when no default value is given', () => {\n\t\t\tit( 'uses an empty array as the field\\'s default value', () => {\n\t\t\t\tconst field = createMultiSelect();\n\t\t\t\texpect( field.value ).toEqual( [] );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( 'when a default value is given', () => {\n", "\t\tit( 'uses that value as the field\\'s default value', () => {\n\t\t\t\tconst field = createMultiSelect( { defaultValue: [ 5, 6 ] } );\n\t\t\t\texpect( field.value ).toEqual( [ 5, 6 ] );\n\t\t\t} );\n\t\t} );\n\t} );\n"]}
{"filename": "tests/config.test.ts", "chunked_list": ["import { cloneDeep } from 'lodash';\n\timport config, { configure } from '../src/config';\n\tdescribe( 'configure', () => {\n\t\tit( 'replaces the given entries in the config object with the values provided', () => {\n\t\t\tconst oldConfig = cloneDeep( config );\n\t\t\tconst newConfigOptions = {\n\t\t\t\tvalidators: {\n\t\t\t\t\trequired: { message: 'Cannot be blank' },\n\t\t\t\t\tminLength: { message: 'Too short' }\n\t\t\t\t}\n", "\t\t};\n\t\t\tconfigure( newConfigOptions );\n\t\t\texpect( config ).toEqual( {\n\t\t\t\t...oldConfig,\n\t\t\t\tvalidators: {\n\t\t\t\t\t...oldConfig.validators,\n\t\t\t\t\t...newConfigOptions.validators\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n", "} );\n"]}
{"filename": "tests/select.test.ts", "chunked_list": ["import ManualField from '../src/ManualField';\n\timport select, { type SelectParams } from '../src/select';\n\tdescribe( 'select', () => {\n\t\tconst createSelect = (\n\t\t\tparams?: Partial<SelectParams<string>>\n\t\t) => select<string>( {\n\t\t\tlabel: 'Favorite language',\n\t\t\t...params\n\t\t} );\n\t\tit( 'returns a ManualField', () => {\n", "\t\tconst field = createSelect();\n\t\t\texpect( field ).toBeInstanceOf( ManualField );\n\t\t} );\n\t\tdescribe( 'when no default value is given', () => {\n\t\t\tit( 'uses null as the field\\'s default value', () => {\n\t\t\t\tconst field = createSelect();\n\t\t\t\texpect( field.value ).toBeNull();\n\t\t\t} );\n\t\t} );\n\t\tdescribe( 'when a default value is given', () => {\n", "\t\tit( 'uses that value as the field\\'s default value', () => {\n\t\t\t\tconst field = createSelect( { defaultValue: 'Ruby' } );\n\t\t\t\texpect( field.value ).toEqual( 'Ruby' );\n\t\t\t} );\n\t\t} );\n\t} );\n"]}
{"filename": "tests/Input.test.ts", "chunked_list": ["import Field from '../src/Field';\n\timport Form from '../src/Form';\n\timport Input, { type InputParams } from '../src/Input';\n\timport { invalid, valid } from '../src/validators';\n\timport { itCallsTheOnChangeCallback } from './support/callbacks';\n\tdescribe( 'Input', () => {\n\t\tconst lengthValidator = ( value: string ) => (\n\t\t\tvalue.length >= 8 ? valid() : invalid( 'Too short' )\n\t\t);\n\t\tconst createInput = ( params?: Partial<InputParams<string>> ) => new Input<string>( {\n", "\t\tlabel: 'Username',\n\t\t\tplaceholder: 'AwesomeUser',\n\t\t\thint: 'Type 5 or more characters',\n\t\t\tdefaultValue: 'default value',\n\t\t\tvalue: 'initial value',\n\t\t\tvalidators: [ lengthValidator ],\n\t\t\tdisabled: false,\n\t\t\tshowErrors: 'onWrite',\n\t\t\t...params\n\t\t} );\n", "\tconst createInputWithForm = ( params?: Partial<InputParams<string>> ) => {\n\t\t\tconst input = createInput( params );\n\t\t\tconst form = new Form( { fields: { input } } );\n\t\t\treturn { input, form };\n\t\t};\n\t\tit( 'is a Field', () => {\n\t\t\tconst input = createInput();\n\t\t\texpect( input ).toBeInstanceOf( Field );\n\t\t} );\n\t\tdescribe( 'constructor', () => {\n", "\t\tit( 'creates the input with the given parameters', () => {\n\t\t\t\tconst input = createInput();\n\t\t\t\texpect( input.label ).toEqual( 'Username' );\n\t\t\t\texpect( input.placeholder ).toEqual( 'AwesomeUser' );\n\t\t\t\texpect( input.hint ).toEqual( 'Type 5 or more characters' );\n\t\t\t\texpect( input.value ).toEqual( 'initial value' );\n\t\t\t\texpect( input.isDisabled ).toBe( false );\n\t\t\t} );\n\t\t\tdescribe( 'without the optional attributes', () => {\n\t\t\t\tit( 'assigns default values for them', () => {\n", "\t\t\t\tconst input = new Input<string>( { defaultValue: 'default value' } );\n\t\t\t\t\texpect( input.label ).toEqual( '' );\n\t\t\t\t\texpect( input.placeholder ).toEqual( '' );\n\t\t\t\t\texpect( input.hint ).toEqual( '' );\n\t\t\t\t\texpect( input.value ).toBe( 'default value' );\n\t\t\t\t\texpect( input.isDisabled ).toBe( false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@focus', () => {\n", "\t\tdescribe( 'when the input is not focused', () => {\n\t\t\t\tit( 'sets the isFocused prop to true', () => {\n\t\t\t\t\tconst input = createInput();\n\t\t\t\t\tinput.focus();\n\t\t\t\t\texpect( input.isFocused ).toBe( true );\n\t\t\t\t} );\n\t\t\t\tdescribe( 'when the input has an onFocus callback', () => {\n\t\t\t\t\tconst onFocus = jest.fn();\n\t\t\t\t\tit( 'calls it passing the parent form as parameter', () => {\n\t\t\t\t\t\tconst { input, form } = createInputWithForm( { onFocus } );\n", "\t\t\t\t\tinput.focus();\n\t\t\t\t\t\texpect( onFocus ).toHaveBeenCalledWith( form );\n\t\t\t\t\t\texpect( onFocus ).toHaveBeenCalledTimes( 1 );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the input is focused', () => {\n\t\t\t\tit( 'does not change the isFocused prop', () => {\n\t\t\t\t\tconst input = createInput();\n\t\t\t\t\tinput.focus();\n", "\t\t\t\tinput.focus();\n\t\t\t\t\texpect( input.isFocused ).toBe( true );\n\t\t\t\t} );\n\t\t\t\tdescribe( 'when the input has an onFocus callback', () => {\n\t\t\t\t\tconst onFocus = jest.fn();\n\t\t\t\t\tit( 'doesn\\'t execute it', () => {\n\t\t\t\t\t\tconst { input } = createInputWithForm( { onFocus } );\n\t\t\t\t\t\tinput.focus();\n\t\t\t\t\t\tinput.focus();\n\t\t\t\t\t\texpect( onFocus ).toHaveBeenCalledTimes( 1 );\n", "\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( '@write', () => {\n\t\t\tit( 'changes the value of the input with the given one', () => {\n\t\t\t\tconst input = createInput();\n\t\t\t\tinput.write( 'new value' );\n\t\t\t\texpect( input.value ).toEqual( 'new value' );\n\t\t\t} );\n", "\t\tit( 'focuses the input', () => {\n\t\t\t\tconst input = createInput();\n\t\t\t\tinput.write( 'new value' );\n\t\t\t\texpect( input.isFocused ).toBe( true );\n\t\t\t} );\n\t\t\titCallsTheOnChangeCallback<Input<string>>( {\n\t\t\t\tfieldBuilder: onChange => createInput( { onChange } ),\n\t\t\t\tchangingAction: ( field, value ) => field.write( value ),\n\t\t\t\tsampleValue: 'sample'\n\t\t\t} );\n", "\t} );\n\t\tdescribe( '@blur', () => {\n\t\t\tdescribe( 'when the input is not focused', () => {\n\t\t\t\tit( 'does not change the isFocused prop', () => {\n\t\t\t\t\tconst input = createInput();\n\t\t\t\t\tinput.blur();\n\t\t\t\t\texpect( input.isFocused ).toBe( false );\n\t\t\t\t} );\n\t\t\t\tdescribe( 'when the input has an onBlur callback', () => {\n\t\t\t\t\tconst onBlur = jest.fn();\n", "\t\t\t\tit( 'doesn\\'t execute it', () => {\n\t\t\t\t\t\tconst { input } = createInputWithForm( { onBlur } );\n\t\t\t\t\t\tinput.blur();\n\t\t\t\t\t\texpect( onBlur ).not.toHaveBeenCalled();\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'when the input is focused', () => {\n\t\t\t\tit( 'sets the isFocused prop to false', () => {\n\t\t\t\t\tconst input = createInput();\n", "\t\t\t\tinput.focus();\n\t\t\t\t\tinput.blur();\n\t\t\t\t\texpect( input.isFocused ).toBe( false );\n\t\t\t\t} );\n\t\t\t\tdescribe( 'when the input has an onBlur callback', () => {\n\t\t\t\t\tconst onBlur = jest.fn();\n\t\t\t\t\tit( 'calls it passing the parent form as parameter', () => {\n\t\t\t\t\t\tconst { input, form } = createInputWithForm( { onBlur } );\n\t\t\t\t\t\tinput.focus();\n\t\t\t\t\t\tinput.blur();\n", "\t\t\t\t\texpect( onBlur ).toHaveBeenCalledWith( form );\n\t\t\t\t\t\texpect( onBlur ).toHaveBeenCalledTimes( 1 );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( 'error display configs', () => {\n\t\t\tdescribe( 'onWrite config', () => {\n\t\t\t\tdescribe( 'when a value is written', () => {\n\t\t\t\t\tdescribe( 'and it is invalid', () => {\n", "\t\t\t\t\ttest( 'the input shows the error', () => {\n\t\t\t\t\t\t\tconst input = createInput( { showErrors: 'onWrite' } );\n\t\t\t\t\t\t\tinput.write( 'short' );\n\t\t\t\t\t\t\texpect( input.error ).toEqual( 'Too short' );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} );\n\t\t\t\t\tdescribe( 'and it is valid', () => {\n\t\t\t\t\t\ttest( 'the input hides any error being shown', () => {\n\t\t\t\t\t\t\tconst input = createInput( { showErrors: 'onWrite' } );\n\t\t\t\t\t\t\tinput.write( 'short' );\n", "\t\t\t\t\t\tinput.write( 'valid again' );\n\t\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'onBlur config', () => {\n\t\t\t\tdescribe( 'when a value is written', () => {\n\t\t\t\t\tdescribe( 'and it is invalid', () => {\n\t\t\t\t\t\ttest( 'the input shows the error only when blurred', () => {\n", "\t\t\t\t\t\tconst input = createInput( { showErrors: 'onBlur' } );\n\t\t\t\t\t\t\tinput.write( 'short' );\n\t\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\t\t\t\t\t\t\tinput.blur();\n\t\t\t\t\t\t\texpect( input.error ).toEqual( 'Too short' );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} );\n\t\t\t\t\tdescribe( 'and it is valid', () => {\n\t\t\t\t\t\ttest( 'the input hides any error being shown', () => {\n\t\t\t\t\t\t\tconst input = createInput( { showErrors: 'onBlur' } );\n", "\t\t\t\t\t\tinput.write( 'short' );\n\t\t\t\t\t\t\tinput.blur();\n\t\t\t\t\t\t\tinput.write( 'valid again' );\n\t\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'onSubmit config', () => {\n\t\t\t\tdescribe( 'when a value is written', () => {\n", "\t\t\t\tdescribe( 'and it is invalid', () => {\n\t\t\t\t\t\ttest( 'the input does not show the error', () => {\n\t\t\t\t\t\t\tconst input = createInput( { showErrors: 'onSubmit' } );\n\t\t\t\t\t\t\tinput.write( 'short' );\n\t\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\t\t\t\t\t\t\tinput.blur();\n\t\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} );\n\t\t\t\t\tdescribe( 'and it is valid', () => {\n", "\t\t\t\t\ttest( 'the input hides any error being shown', () => {\n\t\t\t\t\t\t\tconst input = createInput( { showErrors: 'onSubmit' } );\n\t\t\t\t\t\t\tinput.write( 'short' );\n\t\t\t\t\t\t\tinput.syncError();\n\t\t\t\t\t\t\tinput.write( 'valid again' );\n\t\t\t\t\t\t\texpect( input.error ).toEqual( '' );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n", "\t} );\n\t} );\n"]}
{"filename": "tests/validators/maxLength.test.ts", "chunked_list": ["import { maxLength } from '../../src/validators';\n\timport {\n\t\texpectFailedValidation, expectSuccessfulValidation, itIncludesTheLabelInTheErrorMessage\n\t} from '../support/validators';\n\tdescribe( 'maxLength validator', () => {\n\t\tconst config = { message: 'At most :length chars' };\n\t\tconst expectedError = 'At most 5 chars';\n\t\tconst validator = maxLength( 5, config );\n\t\tdescribe( 'when the string\\'s length equals the given length for the validator', () => {\n\t\t\tit( 'succeeds the validation', () => {\n", "\t\t\texpectSuccessfulValidation( validator( '12345' ) );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( 'when the string\\'s length is less than the given length for the validator', () => {\n\t\t\tit( 'succeeds the validation', () => {\n\t\t\t\texpectSuccessfulValidation( validator( 'A' ) );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( 'when the string\\'s length is greater than the given length for the validator', () => {\n\t\t\tit( 'fails the validation with a message containing the expected min length', () => {\n", "\t\t\texpectFailedValidation( validator( 'xyz123' ), expectedError );\n\t\t\t} );\n\t\t} );\n\t\titIncludesTheLabelInTheErrorMessage( {\n\t\t\tvalidatorBuilder: message => maxLength( 4, { message } ),\n\t\t\tsampleInvalidValue: '5char'\n\t\t} );\n\t} );\n"]}
{"filename": "tests/validators/email.test.ts", "chunked_list": ["import { email } from '../../src/validators';\n\timport {\n\t\texpectFailedValidation, expectSuccessfulValidation, itIncludesTheLabelInTheErrorMessage\n\t} from '../support/validators';\n\tdescribe( 'email validator', () => {\n\t\tconst config = { message: 'The email is not valid!' };\n\t\tconst validator = email( config );\n\t\tdescribe( 'when the string has a valid email format', () => {\n\t\t\tit( 'succeeds the validation', () => {\n\t\t\t\texpectSuccessfulValidation( validator( 'valid@test.co' ) );\n", "\t\t} );\n\t\t} );\n\t\tdescribe( 'when the string has an invalid email format', () => {\n\t\t\tit( 'fails the validation', () => {\n\t\t\t\texpectFailedValidation( validator( 'invalid@test,co' ), config.message );\n\t\t\t\texpectFailedValidation( validator( 'invalidtest.co' ), config.message );\n\t\t\t} );\n\t\t} );\n\t\titIncludesTheLabelInTheErrorMessage( {\n\t\t\tvalidatorBuilder: message => email( { message } ),\n", "\t\tsampleInvalidValue: 'not.valid.com'\n\t\t} );\n\t} );\n"]}
{"filename": "tests/validators/length.test.ts", "chunked_list": ["import { length } from '../../src/validators';\n\timport {\n\t\texpectFailedValidation, expectSuccessfulValidation, itIncludesTheLabelInTheErrorMessage\n\t} from '../support/validators';\n\tdescribe( 'length validator', () => {\n\t\tconst config = { message: 'Must have :length chars' };\n\t\tconst expectedError = 'Must have 9 chars';\n\t\tconst validator = length( 9, config );\n\t\tdescribe( 'when the string\\'s length equals the given length for the validator', () => {\n\t\t\tit( 'succeeds the validation', () => {\n", "\t\t\texpectSuccessfulValidation( validator( 'ninechars' ) );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( 'when the string\\'s length is less than the given length for the validator', () => {\n\t\t\tit( 'fails the validation with a message containing the expected length', () => {\n\t\t\t\texpectFailedValidation( validator( 'tooshort' ), expectedError );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( 'when the string\\'s length is greater than the given length for the validator', () => {\n\t\t\tit( 'fails the validation with a message containing the expected length', () => {\n", "\t\t\texpectFailedValidation( validator( 'toolongggg' ), expectedError );\n\t\t\t} );\n\t\t} );\n\t\titIncludesTheLabelInTheErrorMessage( {\n\t\t\tvalidatorBuilder: message => length( 3, { message } ),\n\t\t\tsampleInvalidValue: 'four'\n\t\t} );\n\t} );\n"]}
{"filename": "tests/validators/required.test.ts", "chunked_list": ["import { required } from '../../src/validators';\n\timport {\n\t\texpectFailedValidation, expectSuccessfulValidation, itIncludesTheLabelInTheErrorMessage\n\t} from '../support/validators';\n\tdescribe( 'required validator', () => {\n\t\tconst config = { message: 'Cannot be blank' };\n\t\tconst validator = required( config );\n\t\tdescribe( 'when the value is not falsy', () => {\n\t\t\tit( 'succeeds the validation', () => {\n\t\t\t\texpectSuccessfulValidation( validator( 'something' ) );\n", "\t\t} );\n\t\t} );\n\t\tdescribe( 'when the value is falsy', () => {\n\t\t\tit( 'fails the validation', () => {\n\t\t\t\texpectFailedValidation( validator( '' ), config.message );\n\t\t\t} );\n\t\t} );\n\t\titIncludesTheLabelInTheErrorMessage( {\n\t\t\tvalidatorBuilder: message => required( { message } ),\n\t\t\tsampleInvalidValue: ''\n", "\t} );\n\t} );\n"]}
{"filename": "tests/validators/minLength.test.ts", "chunked_list": ["import { minLength } from '../../src/validators';\n\timport {\n\t\texpectFailedValidation, expectSuccessfulValidation, itIncludesTheLabelInTheErrorMessage\n\t} from '../support/validators';\n\tdescribe( 'minLength validator', () => {\n\t\tconst config = { message: 'At least :length chars' };\n\t\tconst expectedError = 'At least 8 chars';\n\t\tconst validator = minLength( 8, config );\n\t\tdescribe( 'when the string\\'s length equals the given length for the validator', () => {\n\t\t\tit( 'succeeds the validation', () => {\n", "\t\t\texpectSuccessfulValidation( validator( '8--chars' ) );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( 'when the string\\'s length is greater than the given length for the validator', () => {\n\t\t\tit( 'succeeds the validation', () => {\n\t\t\t\texpectSuccessfulValidation( validator( 'very long string' ) );\n\t\t\t} );\n\t\t} );\n\t\tdescribe( 'when the string\\'s length is less than the given length for the validator', () => {\n\t\t\tit( 'fails the validation with a message containing the expected min length', () => {\n", "\t\t\texpectFailedValidation( validator( '=short=' ), expectedError );\n\t\t\t} );\n\t\t} );\n\t\titIncludesTheLabelInTheErrorMessage( {\n\t\t\tvalidatorBuilder: message => minLength( 3, { message } ),\n\t\t\tsampleInvalidValue: 'XY'\n\t\t} );\n\t} );\n"]}
{"filename": "tests/support/TestField.ts", "chunked_list": ["import { action, makeObservable } from 'mobx';\n\timport Field, { type FieldParams } from '../../src/Field';\n\texport default class TestField extends Field<string> {\n\t\tconstructor( params: FieldParams<string> ) {\n\t\t\tsuper( params );\n\t\t\tmakeObservable( this, {\n\t\t\t\tchange: action\n\t\t\t} );\n\t\t}\n\t\tchange( newValue: string ) {\n", "\t\tthis.setValue( newValue );\n\t\t}\n\t}\n"]}
{"filename": "tests/support/validators.ts", "chunked_list": ["import { FieldValidator, ValidationResult } from '../../src/validators';\n\texport function expectSuccessfulValidation( result: ValidationResult ) {\n\t\texpect( result.isValid ).toBe( true );\n\t}\n\texport function expectFailedValidation( result: ValidationResult, expectedError: string ) {\n\t\texpect( result.isValid ).toBe( false );\n\t\texpect( result.error ).toBe( expectedError );\n\t}\n\texport function itIncludesTheLabelInTheErrorMessage<T>( {\n\t\tvalidatorBuilder,\n", "\tsampleInvalidValue\n\t}: {\n\t\tvalidatorBuilder: ( message: string ) => FieldValidator<T>,\n\t\tsampleInvalidValue: T\n\t} ) {\n\t\tdescribe( 'when the validator is configured with a message containing the :label keyword', () => {\n\t\t\tdescribe( 'and it is invoked with a label', () => {\n\t\t\t\tit( 'replaces the :label keyword with the label when returning an error', () => {\n\t\t\t\t\tconst validator = validatorBuilder( 'The field :label is invalid' );\n\t\t\t\t\tconst result = validator( sampleInvalidValue, undefined, 'Role' );\n", "\t\t\t\texpect( result.error ).toEqual( 'The field Role is invalid' );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'and it is invoked without a label', () => {\n\t\t\t\tit( 'replaces the :label keyword with the word \"Field\" when returning an error', () => {\n\t\t\t\t\tconst validator = validatorBuilder( ':label is invalid' );\n\t\t\t\t\tconst result = validator( sampleInvalidValue, undefined );\n\t\t\t\t\texpect( result.error ).toEqual( 'Field is invalid' );\n\t\t\t\t} );\n\t\t\t} );\n", "\t} );\n\t}\n"]}
{"filename": "tests/support/callbacks.ts", "chunked_list": ["import Field from '../../src/Field';\n\timport Form from '../../src/Form';\n\timport { type ValueType } from '../../src/utils/types';\n\timport { FieldOnChangeCallback } from '../../src/utils/FieldState/types';\n\tinterface OnChangeTestParams<F> {\n\t\tfieldBuilder: ( onChange: FieldOnChangeCallback<ValueType<F>> ) => F,\n\t\tchangingAction: ( field: F, value: ValueType<F> ) => void,\n\t\tsampleValue: ValueType<F>\n\t}\n\texport function itCallsTheOnChangeCallback<F extends Field<ValueType<F>>>( {\n", "\tfieldBuilder,\n\t\tchangingAction,\n\t\tsampleValue\n\t}: OnChangeTestParams<F> ) {\n\t\tdescribe( 'when the field has an onChange callback', () => {\n\t\t\tconst setUp = () => {\n\t\t\t\tconst onChange = jest.fn();\n\t\t\t\tconst field = fieldBuilder( onChange );\n\t\t\t\tconst form = new Form( { fields: { field } } );\n\t\t\t\treturn { onChange, field, form };\n", "\t\t};\n\t\t\tdescribe( 'and a new value is given', () => {\n\t\t\t\tit( 'calls the callback with the new value and the parent form', () => {\n\t\t\t\t\tconst { onChange, field, form } = setUp();\n\t\t\t\t\tchangingAction( field, sampleValue );\n\t\t\t\t\texpect( onChange ).toHaveBeenCalledWith( sampleValue, form );\n\t\t\t\t\texpect( onChange ).toHaveBeenCalledTimes( 1 );\n\t\t\t\t} );\n\t\t\t} );\n\t\t\tdescribe( 'and the same value is given', () => {\n", "\t\t\tit( 'does not call the callback', () => {\n\t\t\t\t\tconst { onChange, field } = setUp();\n\t\t\t\t\tchangingAction( field, field.value );\n\t\t\t\t\texpect( onChange ).not.toHaveBeenCalled();\n\t\t\t\t} );\n\t\t\t} );\n\t\t} );\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export {\n\t\tdefault as config, configure, type Config, type ConfigOptions\n\t} from './config';\n\texport { default as Field, type FieldParams, type FieldOnChangeCallback } from './Field';\n\texport {\n\t\tdefault as Input,\n\t\ttype InputParams,\n\t\ttype InputErrorDisplayConfig,\n\t\ttype InputCallback\n\t} from './Input';\n", "export { default as TextInput, textInput, type TextInputParams } from './TextInput';\n\texport { default as ManualField, manualField } from './ManualField';\n\texport { default as select, type Select, type SelectParams } from './select';\n\texport { default as multiSelect, type MultiSelect, type MultiSelectParams } from './multiSelect';\n\texport { default as Form, type FormParams, type FormValues } from './Form';\n\texport {\n\t\temail,\n\t\tlength,\n\t\tmaxLength,\n\t\tminLength,\n", "\trequired,\n\t\tinvalid,\n\t\tvalid,\n\t\ttype FieldValidator,\n\t\ttype ValidationResult\n\t} from './validators';\n"]}
{"filename": "src/multiSelect/index.ts", "chunked_list": ["import ManualField from '../ManualField';\n\timport type { FieldParams } from '../Field';\n\timport type { WithOptionalDefaultValue } from '../utils/types';\n\texport type MultiSelect<ValueType> = ManualField<ValueType[]>;\n\texport type MultiSelectParams<ValueType> = WithOptionalDefaultValue<FieldParams<ValueType[]>>;\n\texport default function multiSelect<ValueType = string>( params: MultiSelectParams<ValueType> ) {\n\t\treturn new ManualField<ValueType[]>( { defaultValue: [], ...params } );\n\t}\n"]}
{"filename": "src/Form/types.ts", "chunked_list": ["import Field from '../Field';\n\timport type Form from '.';\n\texport type FormSubmitCallback = ( form: Form ) => void | Promise<void>;\n\texport type FormSubmitAction = ( form: Form ) => Promise<void>;\n\texport interface FormParams {\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tfields: Record<string, Field<any>>,\n\t\tonSubmit?: FormSubmitCallback\n\t}\n\texport type FormFields = Record<string, Field<unknown>>;\n", "export type FormValues = Record<string, unknown>;\n"]}
{"filename": "src/Form/utils.ts", "chunked_list": ["import { mapValues } from 'lodash';\n\timport type Form from '.';\n\timport { FormFields, FormSubmitAction, FormSubmitCallback } from './types';\n\texport function wrapInAsyncAction( onSubmit: FormSubmitCallback ) {\n\t\treturn (\n\t\t\t( form: Form ) => Promise.resolve( onSubmit( form ) )\n\t\t) as FormSubmitAction;\n\t}\n\texport function valuesOf( fields: FormFields ) {\n\t\treturn mapValues( fields, field => field.value );\n", "}\n"]}
{"filename": "src/Form/index.ts", "chunked_list": ["import {\n\t\taction, computed, makeObservable, observable\n\t} from 'mobx';\n\timport {\n\t\tclone, every, forEach, pickBy, some\n\t} from 'lodash';\n\timport Field from '../Field';\n\timport type {\n\t\tFormFields, FormParams, FormSubmitAction, FormValues\n\t} from './types';\n", "import { valuesOf, wrapInAsyncAction } from './utils';\n\timport type { ValueType } from '../utils/types';\n\timport deprecatedMethod from '../utils/deprecatedMethod';\n\texport default class Form {\n\t\tprivate _fields: FormFields;\n\t\tprivate submitAction: FormSubmitAction;\n\t\tprivate _isSubmitting: boolean;\n\t\tconstructor( { fields, onSubmit = () => undefined }: FormParams ) {\n\t\t\tthis._fields = fields;\n\t\t\tthis.submitAction = wrapInAsyncAction( onSubmit );\n", "\t\tthis._isSubmitting = false;\n\t\t\tthis.attachFields();\n\t\t\tmakeObservable<Form, '_fields' | 'submitAction' | '_isSubmitting' >( this, {\n\t\t\t\t_fields: observable,\n\t\t\t\tsubmitAction: observable,\n\t\t\t\t_isSubmitting: observable,\n\t\t\t\tfields: computed,\n\t\t\t\tvalues: computed,\n\t\t\t\tdirtyValues: computed,\n\t\t\t\tisValid: computed,\n", "\t\t\tisDirty: computed,\n\t\t\t\tisReadyToSubmit: computed,\n\t\t\t\tisSubmitting: computed,\n\t\t\t\tsubmit: action,\n\t\t\t\tclear: action,\n\t\t\t\treset: action,\n\t\t\t\tshowErrors: action\n\t\t\t} );\n\t\t}\n\t\tget fields(): FormFields {\n", "\t\treturn clone( this._fields );\n\t\t}\n\t\tget values(): FormValues {\n\t\t\treturn valuesOf( this._fields );\n\t\t}\n\t\tget dirtyValues(): FormValues {\n\t\t\treturn valuesOf( this.dirtyFields );\n\t\t}\n\t\tget isValid() {\n\t\t\treturn every( this.enabledFields, field => field.isValid );\n", "\t}\n\t\tget isDirty() {\n\t\t\treturn some( this._fields, field => field.isDirty );\n\t\t}\n\t\tget isReadyToSubmit() {\n\t\t\treturn this.isValid && this.isDirty && !this.isSubmitting;\n\t\t}\n\t\tget isSubmitting() {\n\t\t\treturn this._isSubmitting;\n\t\t}\n", "\tfield<FieldType extends Field<ValueType<FieldType>> = Field<unknown>>( fieldKey: string ) {\n\t\t\treturn this._fields[ fieldKey ] as FieldType;\n\t\t}\n\t\tselect<FieldType extends Field<ValueType<FieldType>> = Field<unknown>>( fieldKey: string ) {\n\t\t\tdeprecatedMethod(\n\t\t\t\t'Form', 'select', { alternative: 'field', docsPath: '/reference/Form.md#field' }\n\t\t\t);\n\t\t\treturn this.field<FieldType>( fieldKey );\n\t\t}\n\t\teachField( actionOnField: ( field: Field<unknown> ) => void ) {\n", "\t\tforEach( this._fields, actionOnField );\n\t\t}\n\t\tsubmit(): Promise<void> {\n\t\t\tthis.syncFieldErrors();\n\t\t\tif ( !this.isValid || this.isSubmitting ) return Promise.resolve();\n\t\t\treturn this.executeSubmitAction();\n\t\t}\n\t\tclear() {\n\t\t\tthis.eachField( field => field.clear() );\n\t\t}\n", "\treset() {\n\t\t\tthis.eachField( field => field.reset() );\n\t\t}\n\t\tshowErrors( errors: Record<string, string> ) {\n\t\t\tforEach( errors, ( error, fieldKey ) => this.showErrorOnField( fieldKey, error ) );\n\t\t}\n\t\tprivate attachFields() {\n\t\t\tforEach( this._fields, field => field.attachToForm( this ) );\n\t\t}\n\t\tprivate get dirtyFields() {\n", "\t\treturn this.pickFieldsBy( field => field.isDirty );\n\t\t}\n\t\tprivate get enabledFields() {\n\t\t\treturn this.pickFieldsBy( field => !field.isDisabled );\n\t\t}\n\t\tprivate pickFieldsBy( predicate: ( field: Field<unknown> ) => boolean ): FormFields {\n\t\t\treturn pickBy( this._fields, predicate );\n\t\t}\n\t\tprivate syncFieldErrors() {\n\t\t\tforEach( this._fields, field => field.syncError() );\n", "\t}\n\t\tprivate executeSubmitAction() {\n\t\t\tthis._isSubmitting = true;\n\t\t\treturn this.submitAction( this )\n\t\t\t\t.finally( action( () => { this._isSubmitting = false; } ) );\n\t\t}\n\t\tprivate showErrorOnField( fieldKey: string, error: string ) {\n\t\t\tthis._fields[ fieldKey ]?.showError( error );\n\t\t}\n\t}\n", "export type { FormParams, FormValues };\n"]}
{"filename": "src/Field/types.ts", "chunked_list": ["import type { FieldStateParams } from '../utils/FieldState';\n\texport type FieldParams<ValueType> = FieldStateParams<ValueType> & { hint?: string };\n\texport type AnnotatedPrivateFieldProps = '_state' | '_presentedError';\n"]}
{"filename": "src/Field/index.ts", "chunked_list": ["import {\n\t\taction, computed, makeObservable, observable\n\t} from 'mobx';\n\timport FieldState from '../utils/FieldState';\n\timport type { AnnotatedPrivateFieldProps, FieldParams } from './types';\n\timport type Form from '../Form';\n\texport default abstract class Field<ValueType> {\n\t\treadonly hint: string;\n\t\tprotected _state: FieldState<ValueType>;\n\t\tprotected _presentedError: string;\n", "\tconstructor( {\n\t\t\thint = '',\n\t\t\t...fieldStateParams\n\t\t}: FieldParams<ValueType> ) {\n\t\t\tthis.hint = hint;\n\t\t\tthis._state = new FieldState( fieldStateParams );\n\t\t\tthis._presentedError = '';\n\t\t\tmakeObservable<Field<ValueType>, AnnotatedPrivateFieldProps>( this, {\n\t\t\t\t_state: observable,\n\t\t\t\t_presentedError: observable,\n", "\t\t\tlabel: computed,\n\t\t\t\tvalue: computed,\n\t\t\t\tisValid: computed,\n\t\t\t\tisDirty: computed,\n\t\t\t\terror: computed,\n\t\t\t\tisDisabled: computed,\n\t\t\t\tsetIsDisabled: action,\n\t\t\t\tclear: action,\n\t\t\t\treset: action,\n\t\t\t\tsyncError: action,\n", "\t\t\tshowError: action,\n\t\t\t\tattachToForm: action\n\t\t\t} );\n\t\t}\n\t\tget label() {\n\t\t\treturn this._state.label;\n\t\t}\n\t\tget value() {\n\t\t\treturn this._state.value;\n\t\t}\n", "\tget isValid() {\n\t\t\treturn this._state.isValid;\n\t\t}\n\t\tget isDirty() {\n\t\t\treturn this._state.isDirty;\n\t\t}\n\t\tget error() {\n\t\t\treturn this._presentedError;\n\t\t}\n\t\tget isDisabled() {\n", "\t\treturn this._state.isDisabled;\n\t\t}\n\t\tsetIsDisabled( isDisabled: boolean ) {\n\t\t\tthis._state.setIsDisabled( isDisabled );\n\t\t}\n\t\tclear() {\n\t\t\tthis._state.clear();\n\t\t\tthis.hideError();\n\t\t}\n\t\treset() {\n", "\t\tthis._state.reset();\n\t\t\tthis.hideError();\n\t\t}\n\t\tsyncError() {\n\t\t\tthis._presentedError = this._state.error || '';\n\t\t}\n\t\tshowError( errorMessage: string ) {\n\t\t\tthis._presentedError = errorMessage;\n\t\t}\n\t\tattachToForm( form: Form ) {\n", "\t\tthis._state.attachToForm( form );\n\t\t}\n\t\tprotected hideError() {\n\t\t\tthis._presentedError = '';\n\t\t}\n\t\tprotected setValue( newValue: ValueType ) {\n\t\t\tthis._state.setValue( newValue );\n\t\t}\n\t}\n\texport type { FieldParams };\n", "export type { FieldOnChangeCallback } from '../utils/FieldState';\n"]}
{"filename": "src/Input/types.ts", "chunked_list": ["import type { FieldParams } from '../Field';\n\timport type Form from '../Form';\n\texport type InputErrorDisplayConfig = 'onWrite' | 'onBlur' | 'onSubmit';\n\texport type InputCallback = ( form?: Form ) => void;\n\texport interface InputParams<ValueType> extends FieldParams<ValueType> {\n\t\tplaceholder?: string,\n\t\tshowErrors?: InputErrorDisplayConfig,\n\t\tonFocus?: InputCallback,\n\t\tonBlur?: InputCallback\n\t}\n"]}
{"filename": "src/Input/index.ts", "chunked_list": ["import {\n\t\taction, computed, makeObservable, observable, reaction\n\t} from 'mobx';\n\timport config from '../config';\n\timport Field from '../Field';\n\timport type { InputCallback, InputErrorDisplayConfig, InputParams } from './types';\n\texport default class Input<ValueType> extends Field<ValueType> {\n\t\treadonly placeholder: string;\n\t\tprotected readonly showErrors: InputErrorDisplayConfig;\n\t\tprotected readonly onFocus?: InputCallback;\n", "\tprotected readonly onBlur?: InputCallback;\n\t\tprotected _isFocused: boolean;\n\t\tconstructor( {\n\t\t\tplaceholder = '',\n\t\t\tshowErrors = config.inputs.showErrors,\n\t\t\tonFocus = undefined,\n\t\t\tonBlur = undefined,\n\t\t\t...fieldParams\n\t\t}: InputParams<ValueType> ) {\n\t\t\tsuper( fieldParams );\n", "\t\tthis.placeholder = placeholder;\n\t\t\tthis.showErrors = showErrors;\n\t\t\tthis.onFocus = onFocus;\n\t\t\tthis.onBlur = onBlur;\n\t\t\tthis._isFocused = false;\n\t\t\tmakeObservable<Input<ValueType>, '_isFocused'>( this, {\n\t\t\t\t_isFocused: observable,\n\t\t\t\tisFocused: computed,\n\t\t\t\tfocus: action,\n\t\t\t\twrite: action,\n", "\t\t\tblur: action\n\t\t\t} );\n\t\t\tthis.setUpFocusReaction();\n\t\t}\n\t\tget isFocused() {\n\t\t\treturn this._isFocused;\n\t\t}\n\t\tfocus() {\n\t\t\tthis._isFocused = true;\n\t\t}\n", "\twrite( newValue: ValueType ) {\n\t\t\tthis.focus();\n\t\t\tthis.setValue( newValue );\n\t\t\tif ( this.isValid || this.showErrors === 'onWrite' ) this.syncError();\n\t\t}\n\t\tblur() {\n\t\t\tthis._isFocused = false;\n\t\t\tif ( this.showErrors === 'onBlur' ) this.syncError();\n\t\t}\n\t\tprotected setUpFocusReaction() {\n", "\t\treaction(\n\t\t\t\t() => this.isFocused,\n\t\t\t\t( isFocused ) => {\n\t\t\t\t\tconst callback = isFocused ? this.onFocus : this.onBlur;\n\t\t\t\t\tcallback?.( this.parentForm );\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tprotected get parentForm() {\n\t\t\treturn this._state.parentForm;\n", "\t}\n\t}\n\texport type { InputCallback, InputErrorDisplayConfig, InputParams };\n"]}
{"filename": "src/utils/types.ts", "chunked_list": ["import type Field from '../Field';\n\timport type { FieldParams } from '../Field';\n\texport type ValueType<F> =\n\t\tF extends Field<infer V> ? V :\n\t\tF extends FieldParams<infer V> ? V :\n\t\tnever;\n\texport type WithOptionalDefaultValue<FieldParamsType> = Omit<FieldParamsType, 'defaultValue'> & {\n\t\tdefaultValue?: ValueType<FieldParamsType>\n\t};\n\texport type DeepPartial<T> = {\n", "\t[ K in keyof T ]?:\n\t\t\tT[ K ] extends object ? DeepPartial<T[ K ]> :\n\t\t\tT[ K ] extends ( infer U )[] ? DeepPartial<U>[] :\n\t\t\tT[ K ];\n\t};\n"]}
{"filename": "src/utils/deprecatedMethod.ts", "chunked_list": ["/* eslint-disable no-console */\n\tconst DOCS_BASE_URL = 'https://github.com/amalgamaco/mobx-form/blob/main/docs';\n\tfunction docsUrl( path: string ) {\n\t\treturn DOCS_BASE_URL + path;\n\t}\n\tfunction joinSentences( ...sentences: Array<string | undefined> ) {\n\t\treturn sentences.filter( Boolean ).join( '. ' );\n\t}\n\tinterface DeprecatedMethodOptions {\n\t\talternative?: string,\n", "\tdocsPath?: string\n\t}\n\texport default function deprecatedMethod(\n\t\tklass: string,\n\t\tmethod: string,\n\t\t{ alternative, docsPath }: DeprecatedMethodOptions = {}\n\t) {\n\t\tconst deprecationMessage = joinSentences(\n\t\t\t`DEPRECATED method '${method}' from class '${klass}'`,\n\t\t\talternative && `Use '${alternative}' instead`,\n", "\t\tdocsPath && `For more information about usage see ${docsUrl( docsPath )}`\n\t\t);\n\t\tconsole.warn( `mobx-form: ${deprecationMessage}` );\n\t}\n"]}
{"filename": "src/utils/FieldState/types.ts", "chunked_list": ["import type { FieldValidator } from '../../validators';\n\timport type Form from '../../Form';\n\texport type FieldOnChangeCallback<ValueType> = (\n\t\tnewValue: ValueType, parentForm?: Form\n\t) => void;\n\texport interface FieldStateParams<ValueType> {\n\t\tlabel?: string,\n\t\tdefaultValue: ValueType,\n\t\tvalue?: ValueType,\n\t\tvalidators?: FieldValidator<ValueType>[],\n", "\tdisabled?: boolean,\n\t\tonChange?: FieldOnChangeCallback<ValueType>\n\t}\n"]}
{"filename": "src/utils/FieldState/index.ts", "chunked_list": ["import { makeAutoObservable, reaction } from 'mobx';\n\timport type { FieldStateParams, FieldOnChangeCallback } from './types';\n\timport type Form from '../../Form';\n\timport type { FieldValidator } from '../../validators';\n\tconst fieldAlreadyAttachedError = ( label: string ) => new Error(\n\t\t`Tried to re-attach a field with label \"${label}\". Fields can only be attached to a Form instance once.`\n\t);\n\texport default class FieldState<ValueType> {\n\t\treadonly label: string;\n\t\tprivate readonly _defaultValue: ValueType;\n", "\tprivate readonly _initialValue: ValueType;\n\t\tprivate readonly _validators: FieldValidator<ValueType>[];\n\t\tprivate readonly _onChange?: FieldOnChangeCallback<ValueType>;\n\t\tprivate _value: ValueType;\n\t\tprivate _isDisabled: boolean;\n\t\tprivate _parentForm?: Form;\n\t\tconstructor( {\n\t\t\tlabel = '',\n\t\t\tdefaultValue,\n\t\t\tvalue = defaultValue,\n", "\t\tvalidators = [],\n\t\t\tdisabled = false,\n\t\t\tonChange = undefined\n\t\t}: FieldStateParams<ValueType> ) {\n\t\t\tthis.label = label;\n\t\t\tthis._defaultValue = defaultValue;\n\t\t\tthis._initialValue = value;\n\t\t\tthis._validators = validators;\n\t\t\tthis._onChange = onChange;\n\t\t\tthis._value = value;\n", "\t\tthis._isDisabled = disabled;\n\t\t\tmakeAutoObservable( this );\n\t\t\tthis.setUpOnChangeReaction();\n\t\t}\n\t\tget value() {\n\t\t\treturn this._value;\n\t\t}\n\t\tget isValid() {\n\t\t\treturn !this.failedValidationResult;\n\t\t}\n", "\tget isDirty() {\n\t\t\treturn this._value !== this._initialValue;\n\t\t}\n\t\tget isDisabled() {\n\t\t\treturn this._isDisabled;\n\t\t}\n\t\tget error() {\n\t\t\treturn this.failedValidationResult?.error;\n\t\t}\n\t\tget parentForm() {\n", "\t\treturn this._parentForm;\n\t\t}\n\t\tsetValue( newValue: ValueType ) {\n\t\t\tthis._value = newValue;\n\t\t}\n\t\tsetIsDisabled( isDisabled: boolean ) {\n\t\t\tthis._isDisabled = isDisabled;\n\t\t}\n\t\tclear() {\n\t\t\tthis._value = this._defaultValue;\n", "\t}\n\t\treset() {\n\t\t\tthis._value = this._initialValue;\n\t\t}\n\t\tattachToForm( form: Form ) {\n\t\t\tif ( this._parentForm ) throw fieldAlreadyAttachedError( this.label );\n\t\t\tthis._parentForm = form;\n\t\t}\n\t\tprivate setUpOnChangeReaction() {\n\t\t\treaction(\n", "\t\t\t() => this._value,\n\t\t\t\t( newValue: ValueType ) => this._onChange?.( newValue, this._parentForm )\n\t\t\t);\n\t\t}\n\t\tprivate get failedValidationResult() {\n\t\t\treturn this.validationResults.find( result => !result.isValid );\n\t\t}\n\t\tprivate get validationResults() {\n\t\t\treturn this._validators.map(\n\t\t\t\tvalidator => validator( this._value, this._parentForm, this.label )\n", "\t\t);\n\t\t}\n\t}\n\texport type { FieldStateParams, FieldOnChangeCallback };\n"]}
{"filename": "src/config/types.ts", "chunked_list": ["import type { InputErrorDisplayConfig } from '../Input';\n\timport type { DeepPartial } from '../utils/types';\n\timport type { EmailValidatorConfig } from '../validators/email';\n\timport type { LengthValidatorConfig } from '../validators/length';\n\timport type { MaxLengthValidatorConfig } from '../validators/maxLength';\n\timport type { MinLengthValidatorConfig } from '../validators/minLength';\n\timport type { RequiredValidatorConfig } from '../validators/required';\n\texport interface Config {\n\t\tinputs: {\n\t\t\tshowErrors: InputErrorDisplayConfig\n", "\t},\n\t\tvalidators: {\n\t\t\temail: EmailValidatorConfig,\n\t\t\tlength: LengthValidatorConfig,\n\t\t\tmaxLength: MaxLengthValidatorConfig,\n\t\t\tminLength: MinLengthValidatorConfig,\n\t\t\trequired: RequiredValidatorConfig\n\t\t}\n\t}\n\texport type ConfigOptions = DeepPartial<Config>;\n"]}
{"filename": "src/config/index.ts", "chunked_list": ["import { merge } from 'lodash';\n\timport type { Config, ConfigOptions } from './types';\n\tconst config: Config = {\n\t\tinputs: {\n\t\t\tshowErrors: 'onBlur'\n\t\t},\n\t\tvalidators: {\n\t\t\temail: { message: 'This email does not have a valid format' },\n\t\t\tlength: { message: 'Must have exactly :length characters' },\n\t\t\tmaxLength: { message: 'Must have at most :length characters' },\n", "\t\tminLength: { message: 'Must have at least :length characters' },\n\t\t\trequired: { message: 'This field is mandatory' }\n\t\t}\n\t};\n\tfunction configure( options: ConfigOptions ) {\n\t\tmerge( config, options );\n\t}\n\texport default config;\n\texport { configure, type Config, type ConfigOptions };\n"]}
{"filename": "src/validators/results.ts", "chunked_list": ["import type { ValidationResult } from './types';\n\texport const valid = (): ValidationResult => ( {\n\t\tisValid: true, error: ''\n\t} );\n\texport const invalid = ( error: string ): ValidationResult => ( {\n\t\tisValid: false, error\n\t} );\n"]}
{"filename": "src/validators/required.ts", "chunked_list": ["import config from '../config';\n\timport type { FieldValidator, ValidatorConfigWithMessage } from './types';\n\timport { makeValidator } from './utils';\n\texport type RequiredValidatorConfig = ValidatorConfigWithMessage;\n\texport function required<ValueType>(\n\t\t{ message }: RequiredValidatorConfig = config.validators.required\n\t): FieldValidator<ValueType> {\n\t\treturn makeValidator( {\n\t\t\tpredicate: value => !!value,\n\t\t\tmessage\n", "\t} );\n\t}\n"]}
{"filename": "src/validators/email.ts", "chunked_list": ["import isEmail from 'validator/lib/isEmail';\n\timport config from '../config';\n\timport type { FieldValidator, ValidatorConfigWithMessage } from './types';\n\timport { makeValidator } from './utils';\n\texport type EmailValidatorConfig = ValidatorConfigWithMessage;\n\texport function email(\n\t\t{ message }: EmailValidatorConfig = config.validators.email\n\t): FieldValidator<string> {\n\t\treturn makeValidator( {\n\t\t\tpredicate: value => isEmail( value ),\n", "\t\tmessage\n\t\t} );\n\t}\n"]}
{"filename": "src/validators/types.ts", "chunked_list": ["import type Form from '../Form';\n\texport interface ValidationResult {\n\t\tisValid: boolean,\n\t\terror: string\n\t}\n\texport type FieldValidator<ValueType> = (\n\t\tvalue: ValueType, form?: Form, label?: string\n\t) => ValidationResult;\n\texport interface MakeValidatorParams<ValueType> {\n\t\tpredicate: ( value: ValueType, form?: Form ) => boolean,\n", "\tmessage: string\n\t}\n\texport interface ValidatorConfigWithMessage {\n\t\tmessage: string\n\t}\n"]}
{"filename": "src/validators/minLength.ts", "chunked_list": ["import config from '../config';\n\timport type { FieldValidator, ValidatorConfigWithMessage } from './types';\n\timport { makeValidator } from './utils';\n\texport type MinLengthValidatorConfig = ValidatorConfigWithMessage;\n\texport function minLength(\n\t\tminLengthValue: number,\n\t\t{ message }: MinLengthValidatorConfig = config.validators.minLength\n\t): FieldValidator<string> {\n\t\treturn makeValidator( {\n\t\t\tpredicate: value => value.length >= minLengthValue,\n", "\t\tmessage: message.replace( ':length', minLengthValue.toString() )\n\t\t} );\n\t}\n"]}
{"filename": "src/validators/utils.ts", "chunked_list": ["import { invalid, valid } from './results';\n\timport type { FieldValidator, MakeValidatorParams } from './types';\n\texport function makeValidator<ValueType>( {\n\t\tpredicate, message\n\t}: MakeValidatorParams<ValueType> ): FieldValidator<ValueType> {\n\t\treturn ( value, form, label ) => (\n\t\t\tpredicate( value, form )\n\t\t\t\t? valid()\n\t\t\t\t: invalid( message.replace( ':label', label || 'Field' ) )\n\t\t);\n", "}\n"]}
{"filename": "src/validators/index.ts", "chunked_list": ["export { email } from './email';\n\texport { length } from './length';\n\texport { maxLength } from './maxLength';\n\texport { minLength } from './minLength';\n\texport { required } from './required';\n\texport { invalid, valid } from './results';\n\texport type { FieldValidator, ValidationResult } from './types';\n"]}
{"filename": "src/validators/length.ts", "chunked_list": ["import config from '../config';\n\timport type { FieldValidator, ValidatorConfigWithMessage } from './types';\n\timport { makeValidator } from './utils';\n\texport type LengthValidatorConfig = ValidatorConfigWithMessage;\n\texport function length(\n\t\tlengthValue: number,\n\t\t{ message }: LengthValidatorConfig = config.validators.length\n\t): FieldValidator<string> {\n\t\treturn makeValidator( {\n\t\t\tpredicate: value => value.length === lengthValue,\n", "\t\tmessage: message.replace( ':length', lengthValue.toString() )\n\t\t} );\n\t}\n"]}
{"filename": "src/validators/maxLength.ts", "chunked_list": ["import config from '../config';\n\timport type { FieldValidator, ValidatorConfigWithMessage } from './types';\n\timport { makeValidator } from './utils';\n\texport type MaxLengthValidatorConfig = ValidatorConfigWithMessage;\n\texport function maxLength(\n\t\tmaxLengthValue: number,\n\t\t{ message }: MaxLengthValidatorConfig = config.validators.maxLength\n\t): FieldValidator<string> {\n\t\treturn makeValidator( {\n\t\t\tpredicate: value => value.length <= maxLengthValue,\n", "\t\tmessage: message.replace( ':length', maxLengthValue.toString() )\n\t\t} );\n\t}\n"]}
{"filename": "src/TextInput/types.ts", "chunked_list": ["import type { InputParams } from '../Input';\n\texport interface TextInputParams extends Omit<InputParams<string>, 'defaultValue'> {\n\t\tdefaultValue?: string\n\t}\n"]}
{"filename": "src/TextInput/index.ts", "chunked_list": ["import Input from '../Input';\n\timport type { TextInputParams } from './types';\n\texport default class TextInput extends Input<string> {\n\t\tconstructor( {\n\t\t\tdefaultValue = '',\n\t\t\t...inputParams\n\t\t}: TextInputParams ) {\n\t\t\tsuper( { defaultValue, ...inputParams } );\n\t\t}\n\t}\n", "export function textInput( params: TextInputParams ) {\n\t\treturn new TextInput( params );\n\t}\n\texport type { TextInputParams };\n"]}
{"filename": "src/ManualField/index.ts", "chunked_list": ["import { action, makeObservable } from 'mobx';\n\timport Field, { FieldParams } from '../Field';\n\texport default class ManualField<ValueType> extends Field<ValueType> {\n\t\tconstructor( params: FieldParams<ValueType> ) {\n\t\t\tsuper( params );\n\t\t\tmakeObservable( this, {\n\t\t\t\tchange: action\n\t\t\t} );\n\t\t}\n\t\tchange( newValue: ValueType ) {\n", "\t\tthis.setValue( newValue );\n\t\t\tthis.syncError();\n\t\t}\n\t\tset( newValue: ValueType ) {\n\t\t\tthis.change( newValue );\n\t\t}\n\t\tselect( newValue: ValueType ) {\n\t\t\tthis.change( newValue );\n\t\t}\n\t}\n", "export function manualField<ValueType>( params: FieldParams<ValueType> ) {\n\t\treturn new ManualField<ValueType>( params );\n\t}\n"]}
{"filename": "src/select/index.ts", "chunked_list": ["import ManualField from '../ManualField';\n\timport type { FieldParams } from '../Field';\n\timport type { WithOptionalDefaultValue } from '../utils/types';\n\texport type Select<ValueType> = ManualField<ValueType | null>;\n\texport type SelectParams<ValueType> = WithOptionalDefaultValue<FieldParams<ValueType | null>>;\n\texport default function select<ValueType = string>( params: SelectParams<ValueType> ) {\n\t\treturn new ManualField<ValueType | null>( { defaultValue: null, ...params } );\n\t}\n"]}
