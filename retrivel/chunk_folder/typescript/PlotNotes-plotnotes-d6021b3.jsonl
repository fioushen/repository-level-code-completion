{"filename": "playwright.config.ts", "chunked_list": ["import { defineConfig, devices } from '@playwright/test';\n\t/**\n\t * Read environment variables from file.\n\t * https://github.com/motdotla/dotenv\n\t */\n\t// require('dotenv').config();\n\t/**\n\t * See https://playwright.dev/docs/test-configuration.\n\t */\n\texport default defineConfig({\n", "  timeout: 100000,\n\t  testDir: './tests',\n\t  /* Run tests in files in parallel */\n\t  fullyParallel: true,\n\t  /* Fail the build on CI if you accidentally left test.only in the source code. */\n\t  forbidOnly: !!process.env.CI,\n\t  /* Retry on CI only */\n\t  retries: process.env.CI ? 2 : 0,\n\t  /* Opt out of parallel tests on CI. */\n\t  workers: process.env.CI ? 1 : undefined,\n", "  /* Reporter to use. See https://playwright.dev/docs/test-reporters */\n\t  reporter: 'html',\n\t  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */\n\t  use: {\n\t    /* Base URL to use in actions like `await page.goto('/')`. */\n\t    // baseURL: 'http://127.0.0.1:3000',\n\t    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */\n\t    trace: 'on-first-retry',\n\t  },\n\t  /* Configure projects for major browsers */\n", "  projects: [\n\t    {\n\t      name: 'chromium',\n\t      use: { \n\t        ...devices['Desktop Chrome'],\n\t        permissions: ['clipboard-read', 'clipboard-write'],\n\t       },\n\t    },\n\t    {\n\t      name: 'firefox',\n", "      use: { ...devices['Desktop Firefox'] },\n\t    },\n\t    {\n\t      name: 'webkit',\n\t      use: { ...devices['Desktop Safari'] },\n\t    },\n\t    /* Test against mobile viewports. */\n\t    // {\n\t    //   name: 'Mobile Chrome',\n\t    //   use: { ...devices['Pixel 5'] },\n", "    // },\n\t    // {\n\t    //   name: 'Mobile Safari',\n\t    //   use: { ...devices['iPhone 12'] },\n\t    // },\n\t    /* Test against branded browsers. */\n\t    // {\n\t    //   name: 'Microsoft Edge',\n\t    //   use: { ...devices['Desktop Edge'], channel: 'msedge' },\n\t    // },\n", "    // {\n\t    //   name: 'Google Chrome',\n\t    //   use: { ..devices['Desktop Chrome'], channel: 'chrome' },\n\t    // },\n\t  ],\n\t  /* Run your local dev server before starting the tests */\n\t  // webServer: {\n\t  //   command: 'npm run start',\n\t  //   url: 'http://127.0.0.1:3000',\n\t  //   reuseExistingServer: !process.env.CI,\n", "  // },\n\t});\n"]}
{"filename": "tests-examples/demo-todo-app.spec.ts", "chunked_list": ["import { test, expect, type Page } from '@playwright/test';\n\ttest.beforeEach(async ({ page }) => {\n\t  await page.goto('https://demo.playwright.dev/todomvc');\n\t});\n\tconst TODO_ITEMS = [\n\t  'buy some cheese',\n\t  'feed the cat',\n\t  'book a doctors appointment'\n\t];\n\ttest.describe('New Todo', () => {\n", "  test('should allow me to add todo items', async ({ page }) => {\n\t    // create a new todo locator\n\t    const newTodo = page.getByPlaceholder('What needs to be done?');\n\t    // Create 1st todo.\n\t    await newTodo.fill(TODO_ITEMS[0]);\n\t    await newTodo.press('Enter');\n\t    // Make sure the list only has one todo item.\n\t    await expect(page.getByTestId('todo-title')).toHaveText([\n\t      TODO_ITEMS[0]\n\t    ]);\n", "    // Create 2nd todo.\n\t    await newTodo.fill(TODO_ITEMS[1]);\n\t    await newTodo.press('Enter');\n\t    // Make sure the list now has two todo items.\n\t    await expect(page.getByTestId('todo-title')).toHaveText([\n\t      TODO_ITEMS[0],\n\t      TODO_ITEMS[1]\n\t    ]);\n\t    await checkNumberOfTodosInLocalStorage(page, 2);\n\t  });\n", "  test('should clear text input field when an item is added', async ({ page }) => {\n\t    // create a new todo locator\n\t    const newTodo = page.getByPlaceholder('What needs to be done?');\n\t    // Create one todo item.\n\t    await newTodo.fill(TODO_ITEMS[0]);\n\t    await newTodo.press('Enter');\n\t    // Check that input is empty.\n\t    await expect(newTodo).toBeEmpty();\n\t    await checkNumberOfTodosInLocalStorage(page, 1);\n\t  });\n", "  test('should append new items to the bottom of the list', async ({ page }) => {\n\t    // Create 3 items.\n\t    await createDefaultTodos(page);\n\t    // create a todo count locator\n\t    const todoCount = page.getByTestId('todo-count')\n\t    // Check test using different methods.\n\t    await expect(page.getByText('3 items left')).toBeVisible();\n\t    await expect(todoCount).toHaveText('3 items left');\n\t    await expect(todoCount).toContainText('3');\n\t    await expect(todoCount).toHaveText(/3/);\n", "    // Check all items in one call.\n\t    await expect(page.getByTestId('todo-title')).toHaveText(TODO_ITEMS);\n\t    await checkNumberOfTodosInLocalStorage(page, 3);\n\t  });\n\t});\n\ttest.describe('Mark all as completed', () => {\n\t  test.beforeEach(async ({ page }) => {\n\t    await createDefaultTodos(page);\n\t    await checkNumberOfTodosInLocalStorage(page, 3);\n\t  });\n", "  test.afterEach(async ({ page }) => {\n\t    await checkNumberOfTodosInLocalStorage(page, 3);\n\t  });\n\t  test('should allow me to mark all items as completed', async ({ page }) => {\n\t    // Complete all todos.\n\t    await page.getByLabel('Mark all as complete').check();\n\t    // Ensure all todos have 'completed' class.\n\t    await expect(page.getByTestId('todo-item')).toHaveClass(['completed', 'completed', 'completed']);\n\t    await checkNumberOfCompletedTodosInLocalStorage(page, 3);\n\t  });\n", "  test('should allow me to clear the complete state of all items', async ({ page }) => {\n\t    const toggleAll = page.getByLabel('Mark all as complete');\n\t    // Check and then immediately uncheck.\n\t    await toggleAll.check();\n\t    await toggleAll.uncheck();\n\t    // Should be no completed classes.\n\t    await expect(page.getByTestId('todo-item')).toHaveClass(['', '', '']);\n\t  });\n\t  test('complete all checkbox should update state when items are completed / cleared', async ({ page }) => {\n\t    const toggleAll = page.getByLabel('Mark all as complete');\n", "    await toggleAll.check();\n\t    await expect(toggleAll).toBeChecked();\n\t    await checkNumberOfCompletedTodosInLocalStorage(page, 3);\n\t    // Uncheck first todo.\n\t    const firstTodo = page.getByTestId('todo-item').nth(0);\n\t    await firstTodo.getByRole('checkbox').uncheck();\n\t    // Reuse toggleAll locator and make sure its not checked.\n\t    await expect(toggleAll).not.toBeChecked();\n\t    await firstTodo.getByRole('checkbox').check();\n\t    await checkNumberOfCompletedTodosInLocalStorage(page, 3);\n", "    // Assert the toggle all is checked again.\n\t    await expect(toggleAll).toBeChecked();\n\t  });\n\t});\n\ttest.describe('Item', () => {\n\t  test('should allow me to mark items as complete', async ({ page }) => {\n\t    // create a new todo locator\n\t    const newTodo = page.getByPlaceholder('What needs to be done?');\n\t    // Create two items.\n\t    for (const item of TODO_ITEMS.slice(0, 2)) {\n", "      await newTodo.fill(item);\n\t      await newTodo.press('Enter');\n\t    }\n\t    // Check first item.\n\t    const firstTodo = page.getByTestId('todo-item').nth(0);\n\t    await firstTodo.getByRole('checkbox').check();\n\t    await expect(firstTodo).toHaveClass('completed');\n\t    // Check second item.\n\t    const secondTodo = page.getByTestId('todo-item').nth(1);\n\t    await expect(secondTodo).not.toHaveClass('completed');\n", "    await secondTodo.getByRole('checkbox').check();\n\t    // Assert completed class.\n\t    await expect(firstTodo).toHaveClass('completed');\n\t    await expect(secondTodo).toHaveClass('completed');\n\t  });\n\t  test('should allow me to un-mark items as complete', async ({ page }) => {\n\t    // create a new todo locator\n\t    const newTodo = page.getByPlaceholder('What needs to be done?');\n\t    // Create two items.\n\t    for (const item of TODO_ITEMS.slice(0, 2)) {\n", "      await newTodo.fill(item);\n\t      await newTodo.press('Enter');\n\t    }\n\t    const firstTodo = page.getByTestId('todo-item').nth(0);\n\t    const secondTodo = page.getByTestId('todo-item').nth(1);\n\t    const firstTodoCheckbox = firstTodo.getByRole('checkbox');\n\t    await firstTodoCheckbox.check();\n\t    await expect(firstTodo).toHaveClass('completed');\n\t    await expect(secondTodo).not.toHaveClass('completed');\n\t    await checkNumberOfCompletedTodosInLocalStorage(page, 1);\n", "    await firstTodoCheckbox.uncheck();\n\t    await expect(firstTodo).not.toHaveClass('completed');\n\t    await expect(secondTodo).not.toHaveClass('completed');\n\t    await checkNumberOfCompletedTodosInLocalStorage(page, 0);\n\t  });\n\t  test('should allow me to edit an item', async ({ page }) => {\n\t    await createDefaultTodos(page);\n\t    const todoItems = page.getByTestId('todo-item');\n\t    const secondTodo = todoItems.nth(1);\n\t    await secondTodo.dblclick();\n", "    await expect(secondTodo.getByRole('textbox', { name: 'Edit' })).toHaveValue(TODO_ITEMS[1]);\n\t    await secondTodo.getByRole('textbox', { name: 'Edit' }).fill('buy some sausages');\n\t    await secondTodo.getByRole('textbox', { name: 'Edit' }).press('Enter');\n\t    // Explicitly assert the new text value.\n\t    await expect(todoItems).toHaveText([\n\t      TODO_ITEMS[0],\n\t      'buy some sausages',\n\t      TODO_ITEMS[2]\n\t    ]);\n\t    await checkTodosInLocalStorage(page, 'buy some sausages');\n", "  });\n\t});\n\ttest.describe('Editing', () => {\n\t  test.beforeEach(async ({ page }) => {\n\t    await createDefaultTodos(page);\n\t    await checkNumberOfTodosInLocalStorage(page, 3);\n\t  });\n\t  test('should hide other controls when editing', async ({ page }) => {\n\t    const todoItem = page.getByTestId('todo-item').nth(1);\n\t    await todoItem.dblclick();\n", "    await expect(todoItem.getByRole('checkbox')).not.toBeVisible();\n\t    await expect(todoItem.locator('label', {\n\t      hasText: TODO_ITEMS[1],\n\t    })).not.toBeVisible();\n\t    await checkNumberOfTodosInLocalStorage(page, 3);\n\t  });\n\t  test('should save edits on blur', async ({ page }) => {\n\t    const todoItems = page.getByTestId('todo-item');\n\t    await todoItems.nth(1).dblclick();\n\t    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).fill('buy some sausages');\n", "    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).dispatchEvent('blur');\n\t    await expect(todoItems).toHaveText([\n\t      TODO_ITEMS[0],\n\t      'buy some sausages',\n\t      TODO_ITEMS[2],\n\t    ]);\n\t    await checkTodosInLocalStorage(page, 'buy some sausages');\n\t  });\n\t  test('should trim entered text', async ({ page }) => {\n\t    const todoItems = page.getByTestId('todo-item');\n", "    await todoItems.nth(1).dblclick();\n\t    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).fill('    buy some sausages    ');\n\t    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).press('Enter');\n\t    await expect(todoItems).toHaveText([\n\t      TODO_ITEMS[0],\n\t      'buy some sausages',\n\t      TODO_ITEMS[2],\n\t    ]);\n\t    await checkTodosInLocalStorage(page, 'buy some sausages');\n\t  });\n", "  test('should remove the item if an empty text string was entered', async ({ page }) => {\n\t    const todoItems = page.getByTestId('todo-item');\n\t    await todoItems.nth(1).dblclick();\n\t    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).fill('');\n\t    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).press('Enter');\n\t    await expect(todoItems).toHaveText([\n\t      TODO_ITEMS[0],\n\t      TODO_ITEMS[2],\n\t    ]);\n\t  });\n", "  test('should cancel edits on escape', async ({ page }) => {\n\t    const todoItems = page.getByTestId('todo-item');\n\t    await todoItems.nth(1).dblclick();\n\t    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).fill('buy some sausages');\n\t    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).press('Escape');\n\t    await expect(todoItems).toHaveText(TODO_ITEMS);\n\t  });\n\t});\n\ttest.describe('Counter', () => {\n\t  test('should display the current number of todo items', async ({ page }) => {\n", "    // create a new todo locator\n\t    const newTodo = page.getByPlaceholder('What needs to be done?');\n\t    // create a todo count locator\n\t    const todoCount = page.getByTestId('todo-count')\n\t    await newTodo.fill(TODO_ITEMS[0]);\n\t    await newTodo.press('Enter');\n\t    await expect(todoCount).toContainText('1');\n\t    await newTodo.fill(TODO_ITEMS[1]);\n\t    await newTodo.press('Enter');\n\t    await expect(todoCount).toContainText('2');\n", "    await checkNumberOfTodosInLocalStorage(page, 2);\n\t  });\n\t});\n\ttest.describe('Clear completed button', () => {\n\t  test.beforeEach(async ({ page }) => {\n\t    await createDefaultTodos(page);\n\t  });\n\t  test('should display the correct text', async ({ page }) => {\n\t    await page.locator('.todo-list li .toggle').first().check();\n\t    await expect(page.getByRole('button', { name: 'Clear completed' })).toBeVisible();\n", "  });\n\t  test('should remove completed items when clicked', async ({ page }) => {\n\t    const todoItems = page.getByTestId('todo-item');\n\t    await todoItems.nth(1).getByRole('checkbox').check();\n\t    await page.getByRole('button', { name: 'Clear completed' }).click();\n\t    await expect(todoItems).toHaveCount(2);\n\t    await expect(todoItems).toHaveText([TODO_ITEMS[0], TODO_ITEMS[2]]);\n\t  });\n\t  test('should be hidden when there are no items that are completed', async ({ page }) => {\n\t    await page.locator('.todo-list li .toggle').first().check();\n", "    await page.getByRole('button', { name: 'Clear completed' }).click();\n\t    await expect(page.getByRole('button', { name: 'Clear completed' })).toBeHidden();\n\t  });\n\t});\n\ttest.describe('Persistence', () => {\n\t  test('should persist its data', async ({ page }) => {\n\t    // create a new todo locator\n\t    const newTodo = page.getByPlaceholder('What needs to be done?');\n\t    for (const item of TODO_ITEMS.slice(0, 2)) {\n\t      await newTodo.fill(item);\n", "      await newTodo.press('Enter');\n\t    }\n\t    const todoItems = page.getByTestId('todo-item');\n\t    const firstTodoCheck = todoItems.nth(0).getByRole('checkbox');\n\t    await firstTodoCheck.check();\n\t    await expect(todoItems).toHaveText([TODO_ITEMS[0], TODO_ITEMS[1]]);\n\t    await expect(firstTodoCheck).toBeChecked();\n\t    await expect(todoItems).toHaveClass(['completed', '']);\n\t    // Ensure there is 1 completed item.\n\t    await checkNumberOfCompletedTodosInLocalStorage(page, 1);\n", "    // Now reload.\n\t    await page.reload();\n\t    await expect(todoItems).toHaveText([TODO_ITEMS[0], TODO_ITEMS[1]]);\n\t    await expect(firstTodoCheck).toBeChecked();\n\t    await expect(todoItems).toHaveClass(['completed', '']);\n\t  });\n\t});\n\ttest.describe('Routing', () => {\n\t  test.beforeEach(async ({ page }) => {\n\t    await createDefaultTodos(page);\n", "    // make sure the app had a chance to save updated todos in storage\n\t    // before navigating to a new view, otherwise the items can get lost :(\n\t    // in some frameworks like Durandal\n\t    await checkTodosInLocalStorage(page, TODO_ITEMS[0]);\n\t  });\n\t  test('should allow me to display active items', async ({ page }) => {\n\t    const todoItem = page.getByTestId('todo-item');\n\t    await page.getByTestId('todo-item').nth(1).getByRole('checkbox').check();\n\t    await checkNumberOfCompletedTodosInLocalStorage(page, 1);\n\t    await page.getByRole('link', { name: 'Active' }).click();\n", "    await expect(todoItem).toHaveCount(2);\n\t    await expect(todoItem).toHaveText([TODO_ITEMS[0], TODO_ITEMS[2]]);\n\t  });\n\t  test('should respect the back button', async ({ page }) => {\n\t    const todoItem = page.getByTestId('todo-item'); \n\t    await page.getByTestId('todo-item').nth(1).getByRole('checkbox').check();\n\t    await checkNumberOfCompletedTodosInLocalStorage(page, 1);\n\t    await test.step('Showing all items', async () => {\n\t      await page.getByRole('link', { name: 'All' }).click();\n\t      await expect(todoItem).toHaveCount(3);\n", "    });\n\t    await test.step('Showing active items', async () => {\n\t      await page.getByRole('link', { name: 'Active' }).click();\n\t    });\n\t    await test.step('Showing completed items', async () => {\n\t      await page.getByRole('link', { name: 'Completed' }).click();\n\t    });\n\t    await expect(todoItem).toHaveCount(1);\n\t    await page.goBack();\n\t    await expect(todoItem).toHaveCount(2);\n", "    await page.goBack();\n\t    await expect(todoItem).toHaveCount(3);\n\t  });\n\t  test('should allow me to display completed items', async ({ page }) => {\n\t    await page.getByTestId('todo-item').nth(1).getByRole('checkbox').check();\n\t    await checkNumberOfCompletedTodosInLocalStorage(page, 1);\n\t    await page.getByRole('link', { name: 'Completed' }).click();\n\t    await expect(page.getByTestId('todo-item')).toHaveCount(1);\n\t  });\n\t  test('should allow me to display all items', async ({ page }) => {\n", "    await page.getByTestId('todo-item').nth(1).getByRole('checkbox').check();\n\t    await checkNumberOfCompletedTodosInLocalStorage(page, 1);\n\t    await page.getByRole('link', { name: 'Active' }).click();\n\t    await page.getByRole('link', { name: 'Completed' }).click();\n\t    await page.getByRole('link', { name: 'All' }).click();\n\t    await expect(page.getByTestId('todo-item')).toHaveCount(3);\n\t  });\n\t  test('should highlight the currently applied filter', async ({ page }) => {\n\t    await expect(page.getByRole('link', { name: 'All' })).toHaveClass('selected');\n\t    //create locators for active and completed links\n", "    const activeLink = page.getByRole('link', { name: 'Active' });\n\t    const completedLink = page.getByRole('link', { name: 'Completed' });\n\t    await activeLink.click();\n\t    // Page change - active items.\n\t    await expect(activeLink).toHaveClass('selected');\n\t    await completedLink.click();\n\t    // Page change - completed items.\n\t    await expect(completedLink).toHaveClass('selected');\n\t  });\n\t});\n", "async function createDefaultTodos(page: Page) {\n\t  // create a new todo locator\n\t  const newTodo = page.getByPlaceholder('What needs to be done?');\n\t  for (const item of TODO_ITEMS) {\n\t    await newTodo.fill(item);\n\t    await newTodo.press('Enter');\n\t  }\n\t}\n\tasync function checkNumberOfTodosInLocalStorage(page: Page, expected: number) {\n\t  return await page.waitForFunction(e => {\n", "    return JSON.parse(localStorage['react-todos']).length === e;\n\t  }, expected);\n\t}\n\tasync function checkNumberOfCompletedTodosInLocalStorage(page: Page, expected: number) {\n\t  return await page.waitForFunction(e => {\n\t    return JSON.parse(localStorage['react-todos']).filter((todo: any) => todo.completed).length === e;\n\t  }, expected);\n\t}\n\tasync function checkTodosInLocalStorage(page: Page, title: string) {\n\t  return await page.waitForFunction(t => {\n", "    return JSON.parse(localStorage['react-todos']).map((todo: any) => todo.title).includes(t);\n\t  }, title);\n\t}\n"]}
{"filename": "tests/example.spec.ts", "chunked_list": ["import { test, expect } from '@playwright/test';\n\ttest('has title', async ({ page }) => {\n\t  await page.goto('https://playwright.dev/');\n\t  // Expect a title \"to contain\" a substring.\n\t  await expect(page).toHaveTitle(/Playwright/);\n\t});\n\ttest('get started link', async ({ page }) => {\n\t  await page.goto('https://playwright.dev/');\n\t  // Click the get started link.\n\t  await page.getByRole('link', { name: 'Get started' }).click();\n", "  // Expects the URL to contain intro.\n\t  await expect(page).toHaveURL(/.*intro/);\n\t});\n\t// Tests for the login page\n\ttest('login page', async ({ page }) => {\n\t  await page.goto('http://localhost:3000/signin');\n\t  // Expect a title \"to contain\" a substring.\n\t  await expect(page).toHaveTitle(/PlotNotes/);\n\t});\n\ttest('Login scenario', async ({ page }) => {\n", "  await page.goto('http://localhost:3000/signin');\n\t  await page.fill('input[name=\"loginUsername\"]', 'testuser');\n\t  await page.fill('input[name=\"loginPassword\"]', 'testpassword');\n\t  const navigationPromise = page.waitForNavigation();\n\t  await page.click('button:has-text(\"Login\")');\n\t  await navigationPromise;\n\t  // Add additional assertions based on the expected behavior after login.\n\t  expect(page.url()).toBe('http://localhost:3000/');\n\t});\n\t// Helper function to generate random string\n", "function generateRandomString(length: number) {\n\t  let result = '';\n\t  let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\t  let charactersLength = characters.length;\n\t  for (let i = 0; i < length; i++ ) {\n\t      result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\t  }\n\t  return result;\n\t}"]}
{"filename": "src/pages/api/prompt.ts", "chunked_list": ["import { getOpenAIClient, constructPrompt, createEmbedding, tokenize, getCustomTermName } from \"./openai\";\n\timport { userLoggedIn } from \"./authchecks\";\n\timport { query } from \"./db\";\n\timport { NextApiRequest, NextApiResponse } from \"next\";\n\tconst generateChapterPrompt = (prompt: string, context: string, additionalText: string) => {\n\t  return `Write ${additionalText} about '${prompt}', ${\n\t    context ? `here is some relevant context '${context}', ` : \"\"\n\t  }do not end the story just yet and make this response at least 20,000 words. \n\t  Include only the story and do not use the prompt in the response. Do not name the story.\n\t  Chapter 1: The Start`;\n", "};\n\tconst generateShortStoryPrompt = (prompt: string, context: string, additionalText: string) => {\n\t  return `Write ${additionalText} about '${prompt}', ${\n\t    context ? `here is some relevant context '${context}', ` : \"\"\n\t  }do not end the story just yet and make this response at least 20,000 words. \n\t  Include only the story and do not use the prompt in the response. Do not name the story.`;\n\t}\n\tconst generateContinuePrompt = (prompt: string, context: string, summary: string) => {\n\t  return `Continue the story: '${summary}' using the following prompt ${prompt}, ${\n\t    context ? `here is some relevant context '${context}', ` : \"\"\n", "  }. Include only the story and do not use the prompt in the response.`;\n\t}\n\tconst getOpenAICompletion = async (content: string) => {\n\t  const openai = getOpenAIClient();\n\t  const prompt = constructPrompt(content);\n\t  const completion = await openai.createChatCompletion(prompt);\n\t  return completion.data.choices[0].message!.content.trim();\n\t};\n\tconst getStory = async (req: NextApiRequest, userid: string) => {\n\t  const prompt = req.body.prompt;\n", "  const context = await getContext(prompt, userid);\n\t  const content = generateShortStoryPrompt(prompt, context, 'a short story');\n\t  let completion = await getOpenAICompletion(content);\n\t  // If the story is too short, continue the completion where it left off\n\t  let tokens = tokenize(completion);\n\t  while (tokens < 1000) {\n\t    const summary = await summarize(completion);\n\t    const newContent = generateContinuePrompt(prompt, context, summary);\n\t    const newCompletion = await getOpenAICompletion(newContent);\n\t    completion += ` ${newCompletion}`;\n", "    tokens = tokenize(completion);\n\t  }\n\t  return completion;\n\t};\n\texport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n\t  const userid = await userLoggedIn(req, res);\n\t  if (!userid) {\n\t    res.status(401).send({ response: \"Not logged in\" });\n\t    return;\n\t  }\n", "  const createShortStory = req.body.shortStory;\n\t  const prompt = req.body.prompt;\n\t  const context = await getContext(prompt, userid);\n\t  if (createShortStory) {\n\t    const story = await getStory(req, userid);\n\t    const storyName = await createStoryName(story);\n\t    res.status(200).send({story, storyName});\n\t  } else {\n\t    const chapter = await writeChapter(prompt, context);\n\t    const storyName = await createStoryName(prompt);\n", "    res.status(200).send({chapter, storyName});\n\t  }\n\t}\n\tconst getContext = async (prompt: string, userid: string) => {\n\t  const termsQuery = await query(`SELECT term FROM userterms WHERE userid = $1`, [userid]);\n\t  const terms = termsQuery.rows.map(row => (row as any).term);\n\t  const termsInPrompt = terms.filter(term => prompt.toLowerCase().includes(term.toLowerCase()));\n\t  if (!termsInPrompt.length) return \"\";\n\t  const promptEmbedding = await createEmbedding(prompt);\n\t  const context = [];\n", "  for (const term of termsInPrompt) {\n\t    const termIDQuery = await query(`SELECT termid FROM userterms WHERE userid = $1 AND term = $2`, [userid, term]);\n\t    const termId = (termIDQuery.rows[0] as any).termid;\n\t    const contextQuery = await query(`SELECT context FROM usercontext WHERE termid = $1 AND embedding <-> $2 < 0.7`, [termId, promptEmbedding]);\n\t    if (contextQuery.rows.length) {\n\t      context.push(...contextQuery.rows.map(row => (row as any).context));\n\t    }\n\t  }\n\t  return context.join(\"\\n\\n\");\n\t};\n", "const writeChapter = async (prompt: string, context: string) => {\n\t  const content = generateChapterPrompt(prompt, context, 'the first chapter of a story');\n\t  let completion = await getOpenAICompletion(content);\n\t  // If the story is too short, continue the completion where it left off\n\t  let tokens = tokenize(completion);\n\t  while (tokens < 1000) {\n\t    const summary = await summarize(completion);\n\t    const newContent = generateContinuePrompt(prompt, context, summary);\n\t    const newCompletion = await getOpenAICompletion(newContent);\n\t    completion += ` ${newCompletion}`;\n", "    tokens = tokenize(completion);\n\t  }\n\t  return completion;\n\t};\n\tconst createStoryName = async (story: string) => {\n\t  const content = `Create a name for the story, include nothing except the name of the story: '${story}'. Do not use quotes.`;\n\t  return await getOpenAICompletion(content);\n\t};\n\texport async function continueStory(prompt: string, oldStories: string[], userid: string) {\n\t  const summary = await summarizeMultiple(oldStories);\n", "  let context = await getContext(prompt, userid);\n\t  let content = generateContinuationPrompt(prompt, summary, context);\n\t  let completion = await getOpenAICompletion(content);\n\t  // If the story is too short, continue the completion where it left off\n\t  let tokens = tokenize(completion);\n\t  while (tokens < 1000) {\n\t    const summary = await summarize(completion);\n\t    const newContent = generateContinuePrompt(prompt, context, summary);\n\t    const newCompletion = await getOpenAICompletion(newContent);\n\t    completion += ` ${newCompletion}`;\n", "    tokens = tokenize(completion);\n\t  }\n\t  return completion;\n\t}\n\texport async function continueChapters(prompt: string, previousChapters: string[], userid: string) {\n\t  let summaries = await summarizeMultiple(previousChapters);\n\t  let context = await getContext(prompt, userid);\n\t  let content = generateContinuationPrompt(prompt, summaries, context);\n\t  let completion = await getOpenAICompletion(content);\n\t  // If the story is too short, continue the completion where it left off\n", "  let tokens = tokenize(completion);\n\t  while (tokens < 1000) {\n\t    const summary = await summarize(completion);\n\t    const newContent = generateContinuePrompt(prompt, context, summary);\n\t    const newCompletion = await getOpenAICompletion(newContent);\n\t    completion += ` ${newCompletion}`;\n\t    tokens = tokenize(completion);\n\t  }\n\t  return completion;\n\t}\n", "async function summarizeMultiple(texts: string[]) {\n\t  let summaries = \"\";\n\t  for (let i = 0; i < texts.length; i++) {\n\t    let text = texts[i]\n\t    summaries += await summarize(text) + \" \";\n\t  }\n\t  return summaries;\n\t}\n\tasync function summarize(story: string): Promise<string> {\n\t  const openai = getOpenAIClient();\n", "  let content = `Summarize the following as much as possible: '${story}'. If there is nothing to summarize, say nothing.`;\n\t  const summaryPrompt = constructPrompt(content);\n\t  const completion = await openai.createChatCompletion(summaryPrompt);\n\t  return completion.data.choices[0].message!.content.trim();\n\t}\n\tfunction generateContinuationPrompt(prompt: string, summaries: string, context: string) {\n\t  let content = ``;\n\t  if (context != \"\") {\n\t    content = `Continue the following story: \"${summaries}\" using the prompt: '${prompt}', here is some relevant context '${context}', make it as long as possible and include only the story. Do not include the prompt in the story.`\n\t  } else {\n", "    content = `Continue the following story: \"${summaries}\" using the prompt: '${prompt}', make it as long as possible and include only the story. Do not include the prompt in the story.`\n\t  }\n\t  return content;\n\t}\n\texport async function editExcerpt(chapter: string, prompt: string) {\n\t  const tokens = tokenize(chapter + \" \" + prompt);\n\t  if (tokens > 1000) {\n\t    chapter = await summarize(chapter);\n\t  }\n\t  const content = `Edit the following: '${chapter}' using the prompt: '${prompt}', make it as long as possible.`;\n", "  let editedChapter = await getOpenAICompletion(content);\n\t  if (editedChapter.startsWith(`\"`) && editedChapter.endsWith(`\"`)) {\n\t    editedChapter = editedChapter.slice(1, -1);\n\t  }\n\t  return editedChapter;\n\t}\n\texport async function createCustomTerm(termNames: any[], termName: string): Promise<{ termName: string, termDescription: string }> {\n\t  if (!termName) {\n\t    const termNameContent = `Create a brand new random term that doesn't exist yet for a fictional story event or character that isnt one of the following terms: \n\t    '${termNames.toString()}', include nothing except the name of the term. Do not use quotes or periods at the end.`;\n", "    termName = await getCustomTermName(termNameContent);\n\t  }\n\t  const termContent = `Create a description for the following fictional story term '${termName}', include nothing except the description of the term. \n\t  Do not use quotes or attach it to an existing franchise. Make it several paragraphs.`;\n\t  const termDescription = await getOpenAICompletion(termContent);\n\t  if (termName.endsWith(`.`)) {\n\t    termName = termName.slice(0, -1);\n\t  }\n\t  return { termName, termDescription };\n\t}"]}
{"filename": "src/pages/api/sessionCmds.ts", "chunked_list": ["import { NextApiRequest, NextApiResponse } from 'next';\n\timport { query } from './db';\n\timport Cookies from 'cookies';\n\texport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n\t    if (req.method == \"POST\") {\n\t        await addUser(req, res);\n\t    }\n\t    else if (req.method == \"PUT\") {\n\t        await logInUser(req, res);\n\t    } else if (req.method == \"DELETE\") {\n", "        await logOutUser(req, res);\n\t    }\n\t}\n\tasync function logOutUser(req: NextApiRequest, res: NextApiResponse) {\n\t    // Assumes the user has a cookie\n\t    const cookie = new Cookies(req, res);\n\t    const sessionId = cookie.get('token');\n\t    try {\n\t        await query(\n\t            `DELETE FROM sessions WHERE id = $1`,\n", "            [sessionId]\n\t        );\n\t        res.status(200).send({ response: \"success\" });\n\t    } catch (err) {\n\t        console.error(err);\n\t        res.status(500).send({ error: \"error\" });\n\t    }\n\t}\n\tasync function logInUser(req: NextApiRequest, res: NextApiResponse) {\n\t    const { username, password } = req.body;\n", "    try {\n\t        if (!await userExists(username, password, false)) {\n\t            res.status(200).send({ error: 'user does not exist' });\n\t            return;\n\t        }\n\t        const userId = await getUserId(username);\n\t        if (!await passwordMatches(userId, password)) {\n\t            res.status(200).send({ error: 'password does not match' });\n\t            return;\n\t        }\n", "        const sessionId = await createSession(`${userId}`);\n\t        const cookie = new Cookies(req, res);\n\t        // Sets the user's cookie to expire the same day\n\t        cookie.set('token', sessionId, {\n\t            httpOnly: true,\n\t            maxAge: 1000 * 60 * 60 * 24,\n\t        });\n\t        res.status(200).send({ sessionId: sessionId});\n\t        return;\n\t    } catch (err) {\n", "        console.log(err);\n\t        res.status(500).send({ error: \"error\" });\n\t    }\n\t}\n\tasync function getUserId(username: string): Promise<number> {\n\t    const userQuery = await query(\n\t        `SELECT (id) FROM users WHERE name = $1`,\n\t        [username]\n\t    );\n\t    return (userQuery.rows[0] as any).id;\n", "}\n\tasync function addUser(req: NextApiRequest, res: NextApiResponse) {\n\t    const { username, password, usedGoogle } = req.body;\n\t    try {\n\t        if (usedGoogle) {\n\t            const sessionId = await signInWithGoogle(username);\n\t            const cookie = new Cookies(req, res);\n\t            // Sets the user's cookie to expire the same day\n\t            cookie.set('token', sessionId, {\n\t                httpOnly: true,\n", "                maxAge: 1000 * 60 * 60 * 24,\n\t            });\n\t            res.status(200).send({ sessionId: sessionId});\n\t        }\n\t        else {\n\t            if (await userExists(username, password, usedGoogle)) {\n\t                res.status(200).send({ error: 'A user with the same username already exists' });\n\t                return;\n\t            }\n\t            const sessionId = await signUp(username, password);\n", "            const cookie = new Cookies(req, res);\n\t            cookie.set('token', sessionId, {\n\t                httpOnly: true,\n\t                maxAge: 1000 * 60 * 60 * 24,\n\t            });\n\t            res.status(200).send(sessionId);\n\t        }\n\t    } catch (err) {\n\t        console.error(err);\n\t        res.status(500).send({ error: err + ' error in queries' });\n", "    }\n\t}\n\tasync function userExists(username: string, password: string, usedGoogle: boolean): Promise<boolean> {\n\t    const userQuery = await query(\n\t        `SELECT (name) FROM users WHERE name = $1`,\n\t        [username]\n\t    );\n\t    if (userQuery.rows.length == 0) {\n\t        return false;\n\t    }\n", "    return true;\n\t}\n\tasync function passwordMatches(userId: number, password: string): Promise<boolean> {\n\t    const passwordQuery = await query(\n\t        `SELECT (password) FROM userpasswords WHERE id = $1`,\n\t        [userId]\n\t    );\n\t    if ((passwordQuery.rows[0] as any).password == password) {\n\t        return true;\n\t    }\n", "    return false;\n\t}\n\tasync function signUp(username: string, password: string): Promise<string> {\n\t    await query(\n\t        `INSERT INTO users (name, usedGoogle) VALUES ($1, $2);`,\n\t        [username, false]\n\t    );\n\t    const idQuery = await query(\n\t        `SELECT (id) FROM users WHERE name = $1`,\n\t        [username]\n", "    );\n\t    const id = (idQuery.rows[0] as any).id;\n\t    await query(\n\t        `INSERT INTO userpasswords (id, password) VALUES ($1, $2);`,\n\t        [id, password]\n\t    );\n\t    await fetch(`${process.env.ZAPIER_WEBHOOK_URL}`, {\n\t        method: 'POST',\n\t        body: JSON.stringify({\n\t            username,\n", "        }),\n\t        headers: {\n\t            'Content-Type': 'application/json'\n\t        }\n\t    });\n\t    return createSession(id);\n\t}\n\tasync function signInWithGoogle(username: string): Promise<string> {\n\t    // Checks to see if the user already exists, if so, just log them in\n\t    const userQuery = await query(\n", "        `SELECT (name) FROM users WHERE name = $1`,\n\t        [username]\n\t    );\n\t    if (userQuery.rows.length != 0) {\n\t        const userIDQuery = await query(\n\t            `SELECT (id) FROM users WHERE name = $1`,\n\t            [username]\n\t        );\n\t        const userID = (userIDQuery.rows[0] as any).id;\n\t        const sessionId = await createSession(userID);\n", "        return sessionId;\n\t    }\n\t    await query(\n\t        `INSERT INTO users (name, usedGoogle) VALUES ($1, $2);`,\n\t        [username, true]\n\t    );\n\t    const userIDQuery = await query(\n\t        `SELECT (id) FROM users WHERE name = $1`,\n\t        [username]\n\t    );\n", "    const userID = (userIDQuery.rows[0] as any).id;\n\t    await fetch(`${process.env.ZAPIER_WEBHOOK_URL}`, {\n\t        method: 'POST',\n\t        body: JSON.stringify({\n\t            username,\n\t        }),\n\t        headers: {\n\t            'Content-Type': 'application/json'\n\t        }\n\t    });\n", "    const sessionId = await createSession(userID);\n\t    return sessionId;\n\t}\n\texport async function createSession(id: string): Promise<string> {\n\t    try {\n\t        const sessionId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n\t        const expireDate = new Date();\n\t        // sets the expiration date to be an hour from now\n\t        expireDate.setHours(expireDate.getHours() + 1);\n\t        await query(\n", "            `INSERT INTO sessions (id, userid, expiredate) VALUES ($1, $2, $3);`,\n\t            [sessionId, id, expireDate]);\n\t        return sessionId;\n\t    } catch (err) {\n\t        console.error(err);\n\t        throw err;\n\t    }\n\t}\n\texport async function getSession(sessionId: string) {\n\t    try {\n", "        const result = await query(\n\t            `SELECT * FROM sessions WHERE id = $1`,\n\t            [sessionId]\n\t        );\n\t        return result;\n\t    } catch (err) {\n\t        console.error(err);\n\t        throw err;\n\t    }\n\t}\n", "export async function deleteExpiredSessions() {\n\t    const currentDate = new Date();\n\t    try {\n\t        await query(\n\t            `DELETE FROM sessions WHERE expireDate < $1`,\n\t            [currentDate]\n\t        );\n\t    } catch (err) {\n\t        console.error(err);\n\t        throw err;\n", "    }\n\t}"]}
{"filename": "src/pages/api/shortStoryCmds.ts", "chunked_list": ["import { NextApiRequest, NextApiResponse } from 'next';\n\timport { query } from './db';\n\timport { userLoggedIn } from './authchecks';\n\texport default async function insertStory(req: NextApiRequest, res: NextApiResponse) {\n\t    const userid = await userLoggedIn(req, res);\n\t    if (userid == \"\") {\n\t        res.status(401).send({ response: \"Not logged in\" });\n\t        return;\n\t    }\n\t    if (req.method == \"POST\") {\n", "        await postRequest(req, res, userid);\n\t    } else if (req.method == \"GET\") {\n\t        await getRequest(req, res, userid);\n\t    } else if (req.method == \"PUT\") {\n\t        await putRequest(req, res, userid);\n\t    } else if (req.method == \"DELETE\") {\n\t        await deleteRequest(req, res, userid);\n\t    }\n\t}\n\tasync function deleteRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n", "    const messageid = req.headers.messageid as string;\n\t    // Deletes all stories related to the given messageid, starting by getting the parentid\n\t    const parentIDQuery = await query(\n\t        `SELECT (parentid) FROM shortstories WHERE messageid = $1`,\n\t        [messageid]\n\t    );\n\t    let parentID = (parentIDQuery.rows[0] as any).parentid;\n\t    if (parentID == 0) {\n\t        parentID = messageid;\n\t    }\n", "    await query(\n\t        `DELETE FROM shortstories WHERE parentid = $1`,\n\t        [parentID]\n\t    );\n\t    await query(\n\t        `DELETE FROM shortstories WHERE messageid = $1`,\n\t        [parentID]\n\t    );\n\t    res.status(200).send({ response: \"success\" });\n\t}\n", "async function putRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    const story = req.body.story as string;\n\t    const messageid = req.body.messageid as string;\n\t    await query(\n\t        `UPDATE shortstories SET message = $1 WHERE messageid = $2 AND userid = $3`,\n\t        [story, messageid, userid]\n\t    );\n\t    res.status(200).send({ response: \"story updated\" });\n\t}\n\tasync function getRequest(req: NextApiRequest, res: NextApiResponse, userId: string) {\n", "    // Returns the stories, checking the iterationID and parentID to keep only the most recent version of each story\n\t    const stories = await updateStories(userId);\n\t    const prompts = await updatePrompts(stories);\n\t    const titles = await updateTitles(stories);\n\t    const messageIDs = await updateMessageIDs(stories);\n\t    res.status(200).send({ stories: stories, prompts: prompts, titles: titles, messageIDs: messageIDs });\n\t}\n\tasync function updateStories(userID: string): Promise<string[]> {\n\t    const storyQuery = await query(`SELECT (messageid) FROM shortstories WHERE parentid = 0 AND userid = $1`, [userID]);\n\t    // Loops through the stories and makes a query for a message whose parentID is the story's messageID, and replaces the story with the most recent version\n", "    let stories: string[] = [];\n\t    for (let i = 0; i < storyQuery.rows.length; i++) {\n\t        const storyID = (storyQuery.rows[i] as any).messageid;\n\t        const childrenStoryQuery = await query(\n\t            `SELECT (message) FROM shortstories WHERE parentid = $1 ORDER BY iterationid DESC LIMIT 1`,\n\t            [storyID]\n\t        );\n\t        if (childrenStoryQuery.rows.length != 0) {\n\t            stories.push((childrenStoryQuery.rows[0] as any).message);\n\t            continue;\n", "        }\n\t        const parentStoryQuery = await query(\n\t            `SELECT (message) FROM shortstories WHERE messageid = $1`,\n\t            [storyID]\n\t        );\n\t        stories.push((parentStoryQuery.rows[0] as any).message);\n\t    }\n\t    return stories;\n\t}\n\tasync function updatePrompts(stories: string[]): Promise<string[]> {\n", "    // For each story in stories, get the prompt from the database and add it to the prompts array\n\t    let prompts: string[] = [];\n\t    for (let i = 0; i < stories.length; i++) {\n\t        const story = stories[i];\n\t        const promptQuery = await query(\n\t            `SELECT (prompt) FROM shortstories WHERE message = $1`,\n\t            [story]\n\t        );\n\t        prompts.push((promptQuery.rows[0] as any).prompt);\n\t    }\n", "    return prompts;\n\t}\n\tasync function updateTitles(stories: string[]): Promise<string[]> {\n\t    // For each story in stories, get the title from the database and add it to the titles array\n\t    let titles: string[] = [];\n\t    for (let i = 0; i < stories.length; i++) {\n\t        const story = stories[i];\n\t        const titleQuery = await query(\n\t            `SELECT (title) FROM shortstories WHERE message = $1`,\n\t            [story]\n", "        );\n\t        titles.push((titleQuery.rows[0] as any).title);\n\t    }\n\t    return titles;\n\t}\n\tasync function updateMessageIDs(stories: string[]): Promise<string[]> {\n\t    // For each story in stories, get the messageID from the database and add it to the messageIDs array\n\t    let messageIDs: string[] = [];\n\t    for (let i = 0; i < stories.length; i++) {\n\t        const story = stories[i];\n", "        const messageIDQuery = await query(\n\t            `SELECT (messageid) FROM shortstories WHERE message = $1`,\n\t            [story]\n\t        );\n\t        messageIDs.push((messageIDQuery.rows[0] as any).messageid);\n\t    }\n\t    return messageIDs;\n\t}\n\tasync function postRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    const { story, storyName, prompt, iterationId } = req.body;\n", "    try {\n\t        const storyIdQuery = await query(\n\t            `INSERT INTO shortstories (iterationid, userid, message, prompt, title, parentid) VALUES ($1, $2, $3, $4, $5, $6)`,\n\t            [iterationId, userid, story, prompt, storyName, 0]\n\t        );\n\t        res.status(200).send({ response: \"success\" });\n\t    } catch (err) {\n\t        console.error(err);\n\t        throw err;\n\t    }        \n", "}\n\texport async function getStory(storyID: string): Promise<string> {\n\t    try {\n\t        const storyQuery = await query(\n\t            `SELECT (story) FROM stories WHERE id = $1`,\n\t            [storyID]\n\t        );\n\t        const story = (storyQuery.rows[0] as any).story;\n\t        return story;\n\t    } catch (err) {\n", "        console.error(err);\n\t        throw err;\n\t    }\n\t}"]}
{"filename": "src/pages/api/authchecks.ts", "chunked_list": ["import { query } from \"./db\";\n\timport { NextApiRequest, NextApiResponse } from \"next\";\n\t// If the user is logged in, return an object that contains the userid and sessionid, otherwise have them null\n\texport async function userLoggedIn(req: NextApiRequest, res: NextApiResponse): Promise<string> {\n\t    let sessionid = \"\";\n\t    let userid = \"\";\n\t    try {\n\t        sessionid = req.cookies.token as string;\n\t        if (!sessionid) {            \n\t            return \"\";\n", "        }\n\t        userid = await getUserID(sessionid);\n\t    } catch (e) {\n\t        // If the userid cannot be found from the sessionid, route the user back to the login page\n\t        if (e instanceof TypeError && e.message == \"Cannot read properties of undefined (reading 'userid')\") {\n\t            return \"\";\n\t        }\n\t    }\n\t    return userid;\n\t}\n", "export async function getUserID(sessionId: string): Promise<string>\n\t{\n\t    const userIdQuery = await query(\n\t        `SELECT (userid) FROM sessions WHERE id = $1`,\n\t        [sessionId]\n\t    );\n\t    const userId = (userIdQuery.rows[0] as any).userid;\n\t    return userId;\n\t}"]}
{"filename": "src/pages/api/chapterCmds.ts", "chunked_list": ["import { NextApiRequest, NextApiResponse } from \"next\";\n\timport { query } from \"./db\";\n\timport { userLoggedIn } from \"./authchecks\";\n\texport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n\t    const userid = await userLoggedIn(req, res);\n\t    if (userid == \"\") {\n\t        res.status(401).send({ response: \"Not logged in\" });\n\t        return;\n\t    }\n\t    if (req.method == \"POST\") {\n", "        await addChapter(req, res, userid);\n\t    } else if (req.method == \"GET\") {\n\t        await getChapter(req, res, userid);\n\t    } else if (req.method == \"PUT\") {\n\t        await putChapter(req, res, userid);\n\t    } else if (req.method == \"DELETE\") {\n\t        await deleteChapter(req, res, userid);\n\t    }\n\t}\n\tasync function deleteChapter(req: NextApiRequest, res: NextApiResponse, userid: string) {\n", "    // Deletes all chapters related to the given messageid\n\t    const messageid = req.headers.messageid as string;\n\t    const seriesIDQuery = await query(\n\t        `SELECT (seriesid) FROM chapters WHERE messageid = $1 AND userid = $2`,\n\t        [messageid, userid]\n\t    );\n\t    const seriesID = (seriesIDQuery.rows[0] as any).seriesid;\n\t    await query(\n\t        `DELETE FROM chapters WHERE seriesid = $1`,\n\t        [seriesID]\n", "    );\n\t    res.status(200).send({ response: \"success\" });\n\t}\n\tasync function putChapter(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    // Gets the new story from the request body and inserts it where the messageid is the given messageid\n\t    const story = req.body.story as string;\n\t    const messageid = req.body.messageid as string;\n\t    await query(\n\t        `UPDATE chapters SET message = $1 WHERE messageid = $2 AND userid = $3`,\n\t        [story, messageid, userid]\n", "    );\n\t    res.status(200).send({ response: \"chapter updated\" });\n\t}\n\tasync function getChapter(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    // Gets all chapters associated with the userID and is the first chapter in the series\n\t    const chapterQuery = await query(\n\t        `SELECT seriesid FROM chapters WHERE userid = $1 AND chapterid = $2`,\n\t        [userid, 1]\n\t    );\n\t    if (chapterQuery.rows.length == 0) {\n", "        res.status(200).send({ response: \"no chapters\" });\n\t        return;\n\t    }\n\t    // Now it gets the most recent chapter for each story that was received from the previous query\n\t    // This is done by getting the seriesid of each story and getting the most recent chapter with that seriesid\n\t    const seriesIDs: string[] = [];\n\t    for (let i = 0; i < chapterQuery.rows.length; i++) {\n\t        seriesIDs.push((chapterQuery.rows[i] as any).seriesid);\n\t    }\n\t    const chapters: string[] = [];\n", "    const storyNames: string[] = [];\n\t    const messageIDs: string[] = [];\n\t    for (let i = 0; i < seriesIDs.length; i++) {\n\t        const chapterQuery = await query(\n\t            `SELECT message, name, messageid FROM chapters WHERE seriesid = $1 ORDER BY chapterid DESC LIMIT 1`,\n\t            [seriesIDs[i]]\n\t        );\n\t        chapters.push((chapterQuery.rows[0] as any).message);\n\t        storyNames.push((chapterQuery.rows[0] as any).name);\n\t        messageIDs.push((chapterQuery.rows[0] as any).messageid);\n", "    }    \n\t    res.status(200).send({ chapters: chapters, storyNames: storyNames, messageIDs: messageIDs });\n\t}\n\tasync function addChapter(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    try {\n\t        const { prompt, story, storyName } = req.body;\n\t        // Since this is called only for the first chapters of a series, find the largest seriesid in the db and add 1 to it\n\t        const seriesIDQuery = await query(\n\t            `SELECT (seriesid) FROM chapters ORDER BY seriesid DESC LIMIT 1`\n\t        );\n", "        let seriesID = 1;\n\t        if (seriesIDQuery.rows.length != 0) {\n\t            seriesID = (seriesIDQuery.rows[0] as any).seriesid;\n\t            seriesID = Number(seriesID) + 1;\n\t        }\n\t        const insertChapterQuery = await query(\n\t            `INSERT INTO chapters (seriesid, chapterid, prompt, message, userid, name) VALUES ($1, $2, $3, $4, $5, $6)`,\n\t            [seriesID, 1, prompt, story, userid, storyName]\n\t        );\n\t        res.status(200).send({ response: \"chapter added\" });\n", "    } catch (err) {\n\t        console.log(err);\n\t        res.status(500).send({ error: err });\n\t    }\n\t}\n"]}
{"filename": "src/pages/api/openai.ts", "chunked_list": ["import { OpenAIApi, Configuration, ChatCompletionRequestMessageRoleEnum } from \"openai\";\n\timport { Tiktoken } from \"@dqbd/tiktoken\";\n\timport p50k_base from \"@dqbd/tiktoken/encoders/p50k_base.json\";\n\texport function getOpenAIConfiguration() {\n\t  return new Configuration({\n\t    apiKey: process.env.OPENAI_KEY,\n\t  }); \n\t}\n\texport async function createEmbedding(content: string) {\n\t  const openai = getOpenAIClient();\n", "  try {\n\t    // Normalizes the content\n\t    content = normalizeText(content);\n\t    const embedding = await openai.createEmbedding({\n\t      model: \"text-embedding-ada-002\",\n\t      input: [content],\n\t    });\n\t    const embeddingArray = embedding.data.data[0].embedding;\n\t    const embeddingString = \"[\" + embeddingArray.join(\", \") + \"]\";\n\t    return embeddingString;\n", "  } catch (err) {\n\t    console.log(err);\n\t  }\n\t}\n\texport function getOpenAIClient() {\n\t  return new OpenAIApi(getOpenAIConfiguration());\n\t}\n\texport function constructPrompt(content: string, temperature?: number) {\n\t  let messages = [];\n\t  messages.push({\n", "      \"role\": ChatCompletionRequestMessageRoleEnum.User,\n\t      \"content\": content\n\t  })\n\t  const max_tokens = getMaxTokens(content);\n\t  if (temperature) {\n\t    return {\n\t      model: \"gpt-3.5-turbo\",\n\t      messages, \n\t      max_tokens: max_tokens,\n\t      temperature: temperature,\n", "      top_p: 0,\n\t    };\n\t  }\n\t  return {\n\t    model: \"gpt-3.5-turbo\",\n\t    messages, \n\t    max_tokens: max_tokens,\n\t    temperature: 1.5,\n\t    top_p: 0,\n\t  }; \n", "}\n\texport function tokenize(content: string) {\n\t  const encoding = new Tiktoken(\n\t    p50k_base.bpe_ranks,\n\t    p50k_base.special_tokens,\n\t    p50k_base.pat_str\n\t  );\n\t  const tokens = encoding.encode(content);\n\t  encoding.free();\n\t  return tokens.length;\n", "}\n\tfunction getMaxTokens(content: string) {\n\t    const encoding = new Tiktoken(\n\t      p50k_base.bpe_ranks,\n\t      p50k_base.special_tokens,\n\t      p50k_base.pat_str\n\t    );\n\t    const tokens = encoding.encode(content);\n\t    encoding.free();\n\t    const max_tokens = (4096 - tokens.length) - 10;\n", "    return max_tokens;\n\t  }\n\t  export async function getCustomTermName(content: string): Promise<string> {\n\t    const openai = getOpenAIClient();\n\t    const prompt = constructPrompt(content, 2);\n\t    const completion = await openai.createChatCompletion(prompt);\n\t    const termName = completion.data.choices[0].message!.content.trim();\n\t    return termName;\n\t  }\n\t  // Helper method that normalizes given text by making it all lowercase and removing punctuation\n", "function normalizeText(text: string): string {\n\t  return text.toLowerCase().replace(/[.,\\/#!$%\\^&\\*;:{}=\\-_`~()]/g,\"\");\n\t}"]}
{"filename": "src/pages/api/auth/{...nextauth}.ts", "chunked_list": ["import NextAuth from 'next-auth';\n\timport GoogleProvider from 'next-auth/providers/google';\n\texport default NextAuth({\n\t    providers: [\n\t        GoogleProvider({\n\t            clientId: process.env.GOOGLE_CLIENT_ID!,\n\t            clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n\t        }) \n\t    ]\n\t})"]}
{"filename": "src/pages/api/[messageid]/edit.ts", "chunked_list": ["import { query } from \"../db\";\n\timport { userLoggedIn } from \"../authchecks\";\n\timport { NextApiRequest, NextApiResponse } from \"next\";\n\texport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n\t        const userid  = await userLoggedIn(req, res);\n\t        if (userid == \"\") {\n\t            res.status(401).send({ response: \"Not logged in\" });\n\t            return;\n\t        }\n\t        if (req.method == \"GET\") {\n", "            await getRequest(req, res, userid);\n\t        } else if (req.method == \"POST\") {\n\t            await postRequest(req, res, userid);\n\t        }\n\t}\n\tasync function postRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    // Determines if the user accepted or rejected the edit along with the table they are editing\n\t    const { accept, table } = req.body;\n\t    const messageid = req.query.messageid as string;\n\t    // If the user accepted the edit, retrieve the new message from the edits table and then add it to the table\n", "    if (accept) {\n\t        const newMessageQuery = await query(\n\t            `SELECT newmessage FROM edits WHERE userid = $1 AND messageid = $2 AND storytype = $3`,\n\t            [userid, messageid, table]\n\t        );\n\t        const newMessage = (newMessageQuery.rows[0] as any).newmessage;\n\t        if (table == \"shortstory\") {\n\t            await query(\n\t                `UPDATE shortstories SET message = $1 WHERE messageid = $2`,\n\t                [newMessage, messageid]\n", "            );\n\t        } else if (table == \"chapter\") {\n\t            await query(\n\t                `UPDATE chapters SET message = $1 WHERE messageid = $2`,\n\t                [newMessage, messageid]\n\t            );\n\t        }\n\t    } \n\t    // Deletes the edit from the edits table\n\t    await query(\n", "        `DELETE FROM edits WHERE userid = $1 AND messageid = $2`,\n\t        [userid, messageid]\n\t    );\n\t    res.status(200).send({ response: \"success\" });\n\t}\n\tasync function getRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    // Gets the two stories associated with the user from the edits table\n\t    const editsQuery = await query(\n\t        `SELECT oldmessage, newmessage FROM edits WHERE userid = $1 AND messageid = $2`,\n\t        [userid, req.query.messageid]\n", "    );\n\t    if (editsQuery.rows.length == 0) {\n\t        res.status(404).send({ response: \"no edits\" });\n\t        return;\n\t    }\n\t    const oldMessage = (editsQuery.rows[0] as any).oldmessage;\n\t    const newMessage = (editsQuery.rows[0] as any).newmessage;\n\t    res.status(200).send({ oldMessage: oldMessage, newMessage: newMessage });\n\t}"]}
{"filename": "src/pages/api/[messageid]/shortStory.ts", "chunked_list": ["import { NextApiRequest, NextApiResponse } from 'next';\n\timport { query } from '../db';\n\timport { userLoggedIn } from '../authchecks';\n\timport { continueStory, editExcerpt } from '../prompt';\n\texport default async function storyHistory(req: NextApiRequest, res: NextApiResponse) {\n\t    const userid = await userLoggedIn(req, res);\n\t    if (userid == \"\") {\n\t        res.status(401).send({ response: \"Not logged in\" });\n\t        return;\n\t    }\n", "    if (req.method == \"GET\") {\n\t        await getRequest(req, res, userid);\n\t    } else if (req.method == \"POST\") {\n\t        await postRequest(req, res, userid);\n\t    } else if (req.method == \"PUT\") {\n\t        await putRequest(req, res, userid);\n\t    } else if (req.method == \"DELETE\") {\n\t        await deleteRequest(req, res, userid);\n\t    }\n\t}\n", "async function deleteRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    const messageid = req.query.messageid as string;\n\t    // Deletes the story from the database\n\t    await query(\n\t        `DELETE FROM shortstories WHERE messageid = $1 AND userid = $2`,\n\t        [messageid, userid]\n\t    );\n\t    // Gets the most recent story in the series\n\t    const storyQuery = await query(\n\t        `SELECT messageid FROM shortstories WHERE parentid = $1 ORDER BY iterationid DESC LIMIT 1`,\n", "        [messageid]\n\t    );\n\t    if (storyQuery.rows.length == 0) {\n\t        res.status(200).send({ response: \"no stories\" });\n\t        return;\n\t    }\n\t    const newMessageID = (storyQuery.rows[0] as any).messageid;\n\t    res.status(200).send({ messageid: newMessageID });\n\t}\n\tasync function putRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n", "    const messageid = req.query.messageid as string;\n\t    const prompt = req.body.prompt as string;\n\t    // Given the prompt, get the message associated with the messageid and edit the story according to the prompt\n\t    const messageQuery = await query(\n\t        `SELECT message FROM shortstories WHERE messageid = $1 AND userid = $2`,\n\t        [messageid, userid]\n\t    );\n\t    if (messageQuery.rows.length == 0) {\n\t        res.status(200).send({ response: \"no chapters\" });\n\t        return;\n", "    }\n\t    const message = (messageQuery.rows[0] as any).message;\n\t    const newMessage = await editExcerpt(message, prompt);\n\t    // Inserts the old and new stories into the edits table\n\t    await query(\n\t        `INSERT INTO edits (userid, oldmessage, newmessage, messageid, storytype) VALUES ($1, $2, $3, $4, 'shortstory')`,\n\t        [userid, message, newMessage, messageid]\n\t    );\n\t    // Sends the new message information back to the user so they can view it before they submit it\n\t    res.status(200).send({ response: \"success\" });\n", "}\n\tasync function postRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    const messageid = req.query.messageid as string;\n\t    const prompt = req.body.prompt as string;\n\t    // Gets the iterationID of the story associated with the given messageID\n\t    const iterationIDQuery = await query(\n\t        `SELECT (iterationid) FROM shortstories WHERE messageid = $1`,\n\t        [messageid]\n\t    );\n\t    const iterationID = (iterationIDQuery.rows[0] as any).iterationid;\n", "    let parentID = \"0\";\n\t    if (iterationID == 0) {\n\t        parentID = messageid;\n\t    } else {\n\t        // Gets the parentID of the story associated with the given messageID\n\t        const parentIDQuery = await query(\n\t            `SELECT (parentid) FROM shortstories WHERE messageid = $1`,\n\t            [messageid]\n\t        );\n\t        parentID = (parentIDQuery.rows[0] as any).parentid;\n", "    }\n\t    // Gets the title of the parent story\n\t    const parentTitle = await getTitle(messageid);\n\t    // Gets every previous story in this iteration and puts it in a string array\n\t    const storiesQuery = await query(\n\t        `SELECT (message) FROM shortstories WHERE messageid = $1 OR parentid = $1`,\n\t        [parentID]\n\t    );\n\t    let stories: string[] = [];\n\t    for (let i = 0; i < storiesQuery.rows.length; i++) {\n", "        stories.push((storiesQuery.rows[i] as any).message);        \n\t    }\n\t    const story = await continueStory(prompt, stories, userid);\n\t    // Inserts the new story into the database, adding 1 to the iterationID\n\t    await query(\n\t        `INSERT INTO shortstories (iterationid, userid, message, prompt, title, parentid) VALUES ($1, $2, $3, $4, $5, $6)`,\n\t        [iterationID + 1, userid, story, prompt, parentTitle, parentID]\n\t    );\n\t    const messageIDQuery = await query(\n\t        `SELECT (messageid) FROM shortstories WHERE message = $1`,\n", "        [story]\n\t    );\n\t    const messageID = (messageIDQuery.rows[0] as any).messageid;\n\t    res.status(200).send({ messageID: messageID });\n\t}\n\tasync function getRequest(req: NextApiRequest, res: NextApiResponse, userId: string) {\n\t    const messageid = req.query.messageid as string;\n\t    // Checks to see if the messageID belongs to the user requesting it\n\t    const messageIDQuery = await query(\n\t        `SELECT (message) FROM shortstories WHERE userid = $1 AND messageid = $2`,\n", "        [userId, messageid]\n\t    );\n\t    if (messageIDQuery.rows.length == 0) {\n\t        res.status(401).send({ error: \"messageID does not belong to user\" });\n\t        return;\n\t    }\n\t    // Gets the parent story from the database\n\t    const parentIdQuery = await query(\n\t        `SELECT (parentid) FROM shortstories WHERE messageid = $1`,\n\t        [messageid]\n", "    );\n\t    const parentStoryID = (parentIdQuery.rows[0] as any ).parentid;\n\t    // If there is no parentID, meaning it is 0, then it is the first story and should be returned along with the title\n\t    if (parentStoryID == 0) {\n\t        const parentTitle = await getTitle(messageid);\n\t        res.status(200).send({ stories: [(messageIDQuery.rows[0] as any).message], parentTitle: parentTitle, messageIDs: [messageid] });\n\t        return;\n\t    }\n\t    const parentStoryQuery = await query(\n\t        `SELECT (message) FROM shortstories WHERE messageid = $1`,\n", "        [parentStoryID]\n\t    );\n\t    // Returns the parent and every story that has the parentID as the parent as an array of strings, so long as the messageID is\n\t    // less than the given one\n\t    const parentStory = (parentStoryQuery.rows[0] as any).message;\n\t    const childStoriesQuery = await query(\n\t        `SELECT message, messageid FROM shortstories WHERE parentid = $1 AND messageid <= $2`,\n\t        [parentStoryID, messageid]\n\t    );\n\t    const childStories = childStoriesQuery.rows;\n", "    let childStoriesArray: string[] = [];\n\t    let messageIDArray: string[] = [];\n\t    messageIDArray.push(parentStoryID);\n\t    for (let i = 0; i < childStories.length; i++) {\n\t        childStoriesArray.push((childStories[i] as any).message);\n\t        messageIDArray.push((childStories[i] as any).messageid);\n\t    }\n\t    const parentTitle = await getTitle(parentStoryID);\n\t    let stories = [];\n\t    stories.push(parentStory);\n", "    for (let i = 0; i < childStoriesArray.length; i++) {\n\t        stories.push(childStoriesArray[i]);\n\t    }\n\t    res.status(200).send({ stories: stories, parentTitle: parentTitle, messageIDs: messageIDArray });\n\t}\n\tasync function getTitle(messageid: string): Promise<string> {\n\t    // Gets the title of the parent story\n\t    const parentTitleQuery = await query(\n\t        `SELECT (title) FROM shortstories WHERE messageid = $1`,\n\t        [messageid]\n", "    );\n\t    const parentTitle = parentTitleQuery.rows[0];\n\t    return (parentTitle as any).title;\n\t}"]}
{"filename": "src/pages/api/[messageid]/chapters.ts", "chunked_list": ["import { NextApiRequest, NextApiResponse } from 'next';\n\timport { query } from '../db';\n\timport { userLoggedIn } from '../authchecks';\n\timport { continueChapters, editExcerpt } from '../prompt';\n\texport default async function chapterHistory(req: NextApiRequest, res: NextApiResponse) {\n\t    const userid = await userLoggedIn(req, res);\n\t    if (userid == \"\") {\n\t        res.status(401).send({ response: \"Not logged in\" });\n\t        return;\n\t    }\n", "    if (req.method == \"GET\") {\n\t        await getRequest(req, res, userid);\n\t    } else if (req.method == \"POST\") {\n\t        await postRequest(req, res, userid);\n\t    } else if (req.method == \"PUT\") {\n\t        await putRequest(req, res, userid);\n\t    } else if (req.method == \"DELETE\") {\n\t        await deleteRequest(req, res, userid);\n\t    }\n\t}\n", "async function deleteRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    const messageid = req.query.messageid as string;\n\t    // Gets the seriesid of the story with the given messageid\n\t    const seriesIDQuery = await query(\n\t        `SELECT seriesid FROM chapters WHERE messageid = $1`,\n\t        [messageid]\n\t    );\n\t    const seriesID = (seriesIDQuery.rows[0] as any).seriesid;\n\t    // Deletes the story from the database\n\t    await query(\n", "        `DELETE FROM chapters WHERE messageid = $1 AND userid = $2`,\n\t        [messageid, userid]\n\t    );\n\t    // Gets the most recent chapter in the series\n\t    const chapterQuery = await query(\n\t        `SELECT messageid FROM chapters WHERE seriesid = $1 ORDER BY chapterid DESC LIMIT 1`,\n\t        [seriesID]\n\t    );\n\t    if (chapterQuery.rows.length == 0) {\n\t        res.status(200).send({ response: \"no chapters\" });\n", "        return;\n\t    }\n\t    const newMessageID = (chapterQuery.rows[0] as any).messageid;\n\t    res.status(200).send({ messageid: newMessageID });\n\t}\n\tasync function putRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    const messageid = req.query.messageid as string;\n\t    const prompt = req.body.prompt as string;\n\t    // Given the prompt, get the message associated with the messageid and edit the story according to the prompt\n\t    const messageQuery = await query(\n", "        `SELECT message FROM chapters WHERE messageid = $1 AND userid = $2`,\n\t        [messageid, userid]\n\t    );\n\t    if (messageQuery.rows.length == 0) {\n\t        res.status(200).send({ response: \"no chapters\" });\n\t        return;\n\t    }\n\t    const message = (messageQuery.rows[0] as any).message;\n\t    const newMessage = await editExcerpt(message, prompt);\n\t    // Inserts the old and new stories into the edits table\n", "    await query(\n\t        `INSERT INTO edits (userid, oldmessage, newmessage, messageid, storytype) VALUES ($1, $2, $3, $4, 'chapter')`,\n\t        [userid, message, newMessage, messageid]\n\t    );\n\t    // Sends the new message information back to the user so they can view it before they submit it\n\t    res.status(200).send({ response: \"success\" });\n\t}\n\tasync function getRequest(req: NextApiRequest, res: NextApiResponse, userId: string) {\n\t    const messageid = req.query.messageid as string;\n\t    // Gets every chapter where the userid is the same as the userid of the chapter with the given messageid, and the messageid is less than or equal to the given messageid\n", "    const seriesIDQuery = await query(\n\t        `SELECT message, name, messageid FROM chapters WHERE seriesid = (SELECT seriesid FROM chapters WHERE messageid = $1) AND chapterid <= (SELECT chapterid FROM chapters WHERE messageid = $1) AND userid = $2 ORDER BY chapterid ASC`,\n\t        [messageid, userId]\n\t    );\n\t    if (seriesIDQuery.rows.length == 0) {\n\t        res.status(200).send({ response: \"no chapters\" });\n\t        return;\n\t    }\n\t    // Returns the chapters, story names, and messageIDs as arrays\n\t    const chapters: string[] = [];\n", "    const storyNames: string[] = [];\n\t    const messageIDs: string[] = [];\n\t    for (let i = 0; i < seriesIDQuery.rows.length; i++) {\n\t        chapters.push((seriesIDQuery.rows[i] as any).message);\n\t        storyNames.push((seriesIDQuery.rows[i] as any).name);\n\t        messageIDs.push((seriesIDQuery.rows[i] as any).messageid);\n\t    }\n\t    res.status(200).send({ chapters: chapters, storyNames: storyNames, messageIDs: messageIDs });\n\t}\n\tasync function postRequest(req: NextApiRequest, res: NextApiResponse, userId: string) {\n", "    const { prompt, messageid } = req.body;\n\t    // Since the messageid given is the id of the previous message, the messageid will have the needed seriesid and chapterid\n\t    const seriesIDQuery = await query(\n\t        `SELECT seriesid, chapterid FROM chapters WHERE messageid = $1`,\n\t        [messageid]\n\t    );\n\t    const seriesID = (seriesIDQuery.rows[0] as any).seriesid;\n\t    let chapterid = (seriesIDQuery.rows[0] as any).chapterid;\n\t    chapterid = Number(chapterid) + 1;\n\t    // Gets all previous chapters of the story, ordering with the lowest chapterid first\n", "    const chaptersQuery = await query(\n\t        `SELECT message FROM chapters WHERE seriesid = $1 ORDER BY chapterid ASC`,\n\t        [seriesID]\n\t    );\n\t    let chapters: string[] = [];\n\t    for (let i = 0; i < chaptersQuery.rows.length; i++) {\n\t        chapters.push((chaptersQuery.rows[i] as any).message);\n\t    }\n\t    // Generates the next chapter\n\t    const story = await continueChapters(prompt, chapters, userId);\n", "    const storyNameQuery = await query(\n\t        `SELECT name FROM chapters WHERE seriesid = $1 ORDER BY chapterid DESC LIMIT 1`,\n\t        [seriesID]\n\t    );\n\t    let storyName = (storyNameQuery.rows[0] as any).name;\n\t    await query(\n\t        `INSERT INTO chapters (seriesid, chapterid, prompt, message, userid, name) VALUES ($1, $2, $3, $4, $5, $6)`,\n\t        [seriesID, chapterid, prompt, story, userId, storyName]\n\t    );\n\t    const newMessageIDQuery = await query(\n", "        `SELECT messageid FROM chapters WHERE seriesid = $1 AND chapterid = $2`,\n\t        [seriesID, chapterid]\n\t    );\n\t    const newMessageID = (newMessageIDQuery.rows[0] as any).messageid;\n\t    res.status(200).send({ messageid: newMessageID });\n\t}"]}
{"filename": "src/pages/api/customTerms/index.ts", "chunked_list": ["import { query } from \"../db\";\n\timport { userLoggedIn } from \"../authchecks\";\n\timport { NextApiResponse, NextApiRequest } from \"next\";\n\timport { createEmbedding } from \"../openai\";\n\texport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n\t    const userid = await userLoggedIn(req, res);\n\t    if (userid == \"\") {\n\t        res.status(401).send({ response: \"Not logged in\" });\n\t        return;\n\t    }\n", "    if (req.method == \"POST\") {\n\t        await postRequest(req, res, userid);\n\t    } else if (req.method == \"GET\") {\n\t        await getRequest(req, res, userid);\n\t    }\n\t}\n\tasync function getRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    // Gets all custom terms associated with the userID\n\t    const customTermsQuery = await query(\n\t        `SELECT term, context, termid FROM userterms WHERE userid = $1`,\n", "        [userid]\n\t    );\n\t    const contexts = customTermsQuery.rows.map((row) => (row as any).context);\n\t    const termids = customTermsQuery.rows.map(row => (row as any).termid);\n\t    const terms = customTermsQuery.rows.map(row => (row as any).term);\n\t    res.status(200).send({ terms: terms, contexts: contexts, termids: termids });\n\t}\n\tasync function postRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    const term = req.body.term as string;\n\t    const context = req.body.context as string;\n", "    // Inserts the term and context into the userterms table\n\t    await query(\n\t        `INSERT INTO userterms (userid, term, context) VALUES ($1, $2, $3)`,\n\t        [userid, term, context]\n\t    );\n\t    // Gets the termid of the term just inserted\n\t    const termidQuery = await query(\n\t        `SELECT termid FROM userterms WHERE userid = $1 AND term = $2`,\n\t        [userid, term]\n\t    );\n", "    const termid = (termidQuery.rows[0] as any).termid;\n\t    // Breaks the context into paragraphs and inserts them into the usercontext table\n\t    const paragraphs = context.split(\"\\n\\n\");\n\t    for (let i = 1; i <= paragraphs.length; i++) {\n\t        const embedding = await createEmbedding(paragraphs[i-1]);\n\t        await query(\n\t            `INSERT INTO usercontext (termid, context, sentenceid, embedding) VALUES ($1, $2, $3, $4)`,\n\t            [termid, paragraphs[i-1], i, embedding]\n\t        );\n\t    }\n", "}"]}
{"filename": "src/pages/api/customTerms/generate.ts", "chunked_list": ["import { query } from \"../db\";\n\timport { userLoggedIn } from \"../authchecks\";\n\timport { NextApiResponse, NextApiRequest } from \"next\";\n\timport { createEmbedding } from \"../openai\";\n\timport { createCustomTerm } from \"../prompt\";\n\texport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n\t    const userid = await userLoggedIn(req, res);\n\t    if (userid == \"\") {\n\t        res.status(401).send({ response: \"Not logged in\" });\n\t        return;\n", "    }\n\t    if (req.method == \"GET\") {\n\t        await getRequest(req, res, userid);\n\t    }\n\t}\n\tasync function getRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    // Gets the term names of all terms the user already has\n\t    const termNamesQuery = await query(\n\t        `SELECT term FROM userterms WHERE userid = $1`,\n\t        [userid]\n", "    );\n\t    const providedTermName = req.headers.term as string;\n\t    const termNames = termNamesQuery.rows.map(row => (row as any).term);\n\t    // Generates a new custom term and context and then adds it to the user's custom terms list\n\t    const { termName, termDescription } = await createCustomTerm(termNames, providedTermName);\n\t    // Inserts the term into the userterms table\n\t    await query(\n\t        `INSERT INTO userterms (userid, term, context) VALUES ($1, $2, $3)`,\n\t        [userid, termName, termDescription]\n\t    );\n", "    // Breaks the context into paragraphs and inserts them into the usercontext table\n\t    const paragraphs = termDescription.split(\"\\n\");\n\t    const termIDQuery = await query(\n\t        `SELECT termid FROM userterms WHERE userid = $1 AND term = $2 AND context = $3`,\n\t        [userid, termName, termDescription]\n\t    );\n\t    const termID = (termIDQuery.rows[0] as any).termid;\n\t    for (let i = 1; i <= paragraphs.length; i++) {\n\t        await query(\n\t            `INSERT INTO usercontext (termid, context, sentenceid) VALUES ($1, $2, $3)`,\n", "            [termID, paragraphs[i - 1], i]\n\t        );\n\t    }\n\t    res.status(200).send({ termid: termID })\n\t}"]}
{"filename": "src/pages/api/customTerms/[termid]/index.ts", "chunked_list": ["import { query } from \"../../db\";\n\timport { userLoggedIn } from \"../../authchecks\";\n\timport { NextApiResponse, NextApiRequest } from \"next\";\n\timport { createEmbedding } from \"../../openai\";\n\texport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n\t    const userid = await userLoggedIn(req, res);\n\t    if (userid == \"\") {\n\t        res.status(401).send({ response: \"Not logged in\" });\n\t        return;\n\t    }\n", "    if (req.method == \"PUT\") {\n\t        await putRequest(req, res, userid);\n\t    } else if (req.method == \"GET\") {\n\t        await getRequest(req, res, userid);\n\t    } else if (req.method == \"DELETE\") {\n\t        await deleteRequest(req, res, userid);\n\t    }\n\t}\n\tasync function deleteRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    // Deletes the term from the userterms table\n", "    const termid = req.query.termid as string;\n\t    await query(\n\t        `DELETE FROM userterms WHERE userid = $1 AND termid = $2`,\n\t        [userid, termid]\n\t    );\n\t    // Deletes all paragraphs associated with the termid\n\t    await query(\n\t        `DELETE FROM usercontext WHERE termid = $1`,\n\t        [termid]\n\t    );\n", "    res.status(200).send({ response: \"success\" });\n\t}\n\tasync function getRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t   // Gets the context for the specified term\n\t   const termid = req.query.termid as string;\n\t    const contextQuery = await query(\n\t        `SELECT context, term FROM userterms WHERE userid = $1 AND termid = $2`,\n\t        [userid, termid]\n\t    );\n\t    const term = (contextQuery.rows[0] as any).term;\n", "    const context = (contextQuery.rows[0] as any).context;\n\t    res.status(200).send({ context: context, term: term });\n\t}\n\tasync function putRequest(req: NextApiRequest, res: NextApiResponse, userid: string) {\n\t    const termid = req.query.termid as string;\n\t    const context = req.body.context as string;\n\t    await query(\n\t        `UPDATE userterms SET context = $1 WHERE userid = $2 AND termid = $3`,\n\t        [context, userid, termid]\n\t    );\n", "    // Deletes all sentences associated with the termid\n\t    await query(\n\t        `DELETE FROM usercontext WHERE termid = $1`,\n\t        [termid]\n\t    );\n\t    // Breaks the context into individual paragraphs, and for each sentence, add it to the usercontext table in the database\n\t    const paragraphs = context.split(\"\\n\\n\");\n\t    try {\n\t        for (let i = 1; i <= paragraphs.length; i++) {\n\t            const sentence = paragraphs[i - 1];\n", "            const embedding = await createEmbedding(sentence);\n\t            await query(\n\t                `INSERT INTO usercontext (context, termid, sentenceid, embedding) VALUES ($1, $2, $3, $4)`,\n\t                [sentence, termid, i, embedding]\n\t            );\n\t        }\n\t    } catch (e) {\n\t        console.log(e);\n\t        res.status(500).send({ error: e });\n\t    }\n", "    res.status(200).send({ response: \"success\" });\n\t}"]}
