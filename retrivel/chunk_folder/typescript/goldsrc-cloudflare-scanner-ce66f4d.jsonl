{"filename": "src/consts/index.ts", "chunked_list": ["import cloudflareIpRanges from \"./ip-ranges.json\";\n\timport { rangeToIpArray } from \"~/helpers/rangeToIpArray\";\n\texport const allIps: string[] = cloudflareIpRanges.flatMap((range) =>\n\t  rangeToIpArray(range)\n\t);\n"]}
{"filename": "src/helpers/randomizeElements.ts", "chunked_list": ["export function randomizeElements<T>(arr: T[]) {\n\t  return [...arr].sort(() => Math.random() - 0.5);\n\t}\n"]}
{"filename": "src/helpers/copyIPToClipboard.ts", "chunked_list": ["import { toast } from \"react-hot-toast\";\n\texport async function copyIPToClipboard(ip: string) {\n\t  try {\n\t    await navigator.clipboard.writeText(ip);\n\t    toast.success(`IP ${ip} copied to clipboard!`);\n\t  } catch (error) {\n\t    toast.error(`Failed to copy IP ${ip} to clipboard!`);\n\t    console.error(error);\n\t  }\n\t}\n"]}
{"filename": "src/helpers/rangeToIpArray.ts", "chunked_list": ["export function rangeToIpArray(range: string) {\n\t  const parts = range.split(\"/\");\n\t  if (parts.length !== 2) {\n\t    throw new Error(`Invalid IP Range format ${range} `);\n\t  }\n\t  const [ip, maskString] = parts as [string, string];\n\t  const mask = parseInt(maskString, 10);\n\t  const ipParts = ip.split(\".\");\n\t  if (ipParts.length !== 4) {\n\t    throw new Error(\"Invalid IP\");\n", "  }\n\t  const [first, second, third, forth] = ipParts as [\n\t    string,\n\t    string,\n\t    string,\n\t    string\n\t  ];\n\t  const start =\n\t    (parseInt(first, 10) << 24) |\n\t    (parseInt(second, 10) << 16) |\n", "    (parseInt(third, 10) << 8) |\n\t    parseInt(forth, 10) |\n\t    0; // convert to unsigned int\n\t  const end = start | (0xffffffff >>> mask) | 0; // convert to unsigned int\n\t  const ips: string[] = [];\n\t  for (let i = start; i <= end; i++) {\n\t    const ip = [\n\t      (i >> 24) & 0xff,\n\t      (i >> 16) & 0xff,\n\t      (i >> 8) & 0xff,\n", "      i & 0xff,\n\t    ].join(\".\");\n\t    ips.push(ip);\n\t  }\n\t  return ips;\n\t}\n"]}
{"filename": "src/helpers/download.ts", "chunked_list": ["type AcceptableObject = Record<string, unknown>;\n\ttype CreateFn = (arr: AcceptableObject[]) => Blob;\n\tconst createJSON: CreateFn = (arr) => {\n\t  const jsonString = JSON.stringify(arr, null, 2);\n\t  const blob = new Blob([jsonString], {\n\t    type: \"application/json;charset=utf-8;\",\n\t  });\n\t  return blob;\n\t};\n\tconst createCSV: CreateFn = (arr) => {\n", "  const keys = Object.keys(arr[0] as AcceptableObject);\n\t  const csvHeader = keys.join(\",\");\n\t  const csvContent = arr\n\t    .map((el) => keys.map((key) => String(el[key] || \"\")).join(\",\"))\n\t    .join(\"\\n\");\n\t  const csvString = `${csvHeader}\\n${csvContent}`;\n\t  const blob = new Blob([csvString], { type: \"text/csv\" });\n\t  return blob;\n\t};\n\texport function download(arr: AcceptableObject[], format: \"json\" | \"csv\") {\n", "  if (!arr.length) return;\n\t  const blob = format === \"json\" ? createJSON(arr) : createCSV(arr);\n\t  const url = URL.createObjectURL(blob);\n\t  const link = document.createElement(\"a\");\n\t  link.setAttribute(\"href\", url);\n\t  link.setAttribute(\"download\", `ip-list.${format}`);\n\t  link.style.display = \"none\";\n\t  document.body.appendChild(link);\n\t  link.click();\n\t  document.body.removeChild(link);\n", "}\n"]}
{"filename": "src/swr/cacheProviders/localstorage.ts", "chunked_list": ["import { type State } from \"swr\";\n\tconst CACHE_KEY = \"swr-cache\";\n\texport const localStorageProvider = () => {\n\t  const isServer = typeof window === \"undefined\";\n\t  const localStorageData: unknown = JSON.parse(\n\t    (!isServer && localStorage.getItem(CACHE_KEY)) || \"[]\"\n\t  );\n\t  const map = new Map<string, State<unknown, unknown> | undefined>(\n\t    Array.isArray(localStorageData) ? localStorageData : []\n\t  );\n", "  if (!isServer) {\n\t    // Before unloading the app, we write back all the data into `localStorage`.\n\t    window.addEventListener(\"beforeunload\", () => {\n\t      const appCache = JSON.stringify(Array.from(map.entries()));\n\t      localStorage.setItem(CACHE_KEY, appCache);\n\t    });\n\t  }\n\t  // We still use the map for write & read for performance.\n\t  return map;\n\t};\n"]}
{"filename": "src/swr/fetchers/userIP.ts", "chunked_list": ["import { type IPInfo } from \"~/types\";\n\texport const fetchUserIPInfo = async (detectedIP = \"\") => {\n\t  const res = await fetch(`https://freeipapi.com/api/json/${detectedIP}`);\n\t  const ipInfo = (await res.json()) as IPInfo;\n\t  return ipInfo;\n\t};\n"]}
{"filename": "src/hooks/useUserIPInfo.ts", "chunked_list": ["import useSWR from \"swr\";\n\timport { fetchUserIPInfo } from \"~/swr/fetchers/userIP\";\n\texport const useUserIPInfo = () => {\n\t  const swr = useSWR(\"ipInfo\", () => fetchUserIPInfo(), {\n\t    fallbackData: {\n\t      ipVersion: 0,\n\t      ipAddress: \"0.0.0.0\",\n\t      latitude: 0,\n\t      longitude: 0,\n\t      countryName: \"-\",\n", "      countryCode: \"-\",\n\t      timeZone: \"+00:00\",\n\t      zipCode: \"00000\",\n\t      cityName: \"-\",\n\t      regionName: \"-\",\n\t    },\n\t  });\n\t  return {\n\t    loading: (!swr.data && !swr.error) || swr.isValidating,\n\t    error: swr.error as unknown,\n", "    ipInfo: swr.data,\n\t  };\n\t};\n"]}
{"filename": "src/hooks/useIPScanner.ts", "chunked_list": ["import { create } from \"zustand\";\n\timport { persist } from \"zustand/middleware\";\n\timport { randomizeElements } from \"~/helpers/randomizeElements\";\n\timport pick from \"lodash/pick\";\n\ttype ValidIP = {\n\t  ip: string;\n\t  latency: number;\n\t};\n\tconst TRY_CHARS = [\"\", \"|\", \"/\", \"-\", \"\\\\\"] as const;\n\tconst MAX_TRIES = TRY_CHARS.length;\n", "export type TryChar = (typeof TRY_CHARS)[number];\n\texport type Settings = {\n\t  maxIPCount: number;\n\t  maxLatency: number;\n\t  ipRegex: string;\n\t};\n\ttype SettingKeys = keyof Settings;\n\ttype ScanState = \"idle\" | \"stopping\" | \"scanning\";\n\ttype ScannerStore = Settings & {\n\t  testNo: number;\n", "  validIPs: ValidIP[];\n\t  currentIP: string;\n\t  tryChar: TryChar;\n\t  currentLatency: number;\n\t  color: \"red\" | \"green\";\n\t  scanState: ScanState;\n\t  dispatch: (newState: Partial<ScannerStore>) => void;\n\t  reset: () => void;\n\t  increaseTestNo: () => void;\n\t  addValidIP: (validIP: ValidIP) => void;\n", "  setSettings: (newSettings: Partial<Settings>) => void;\n\t  getScanState: () => ScanState;\n\t  getValidIPCount: () => number;\n\t};\n\ttype FunctionalKeys = {\n\t  [K in keyof ScannerStore]: ScannerStore[K] extends (\n\t    ...args: never[]\n\t  ) => unknown\n\t    ? K\n\t    : never;\n", "}[keyof ScannerStore];\n\texport const settingsInitialValues: Pick<ScannerStore, SettingKeys> = {\n\t  maxIPCount: 5,\n\t  maxLatency: 1000,\n\t  ipRegex: \"\",\n\t};\n\tconst initialState: Omit<ScannerStore, FunctionalKeys> = {\n\t  ...settingsInitialValues,\n\t  testNo: 0,\n\t  validIPs: [],\n", "  currentIP: \"\",\n\t  tryChar: \"\",\n\t  currentLatency: 0,\n\t  color: \"red\",\n\t  scanState: \"idle\",\n\t};\n\texport const useScannerStore = create<ScannerStore>()(\n\t  persist(\n\t    (set, get) => ({\n\t      ...initialState,\n", "      getScanState: () => get().scanState,\n\t      getValidIPCount: () => get().validIPs.length,\n\t      setSettings: (newSettings) => {\n\t        set(newSettings);\n\t      },\n\t      dispatch: (newState) => {\n\t        set(newState);\n\t      },\n\t      addValidIP(validIP) {\n\t        set((state) => {\n", "          const newArr = [...state.validIPs, validIP];\n\t          const validIPs = newArr.sort((a, b) => a.latency - b.latency);\n\t          return {\n\t            validIPs,\n\t          };\n\t        });\n\t      },\n\t      reset: () => {\n\t        set({\n\t          testNo: 0,\n", "          validIPs: [],\n\t          currentIP: \"\",\n\t          tryChar: \"\",\n\t          currentLatency: 0,\n\t          color: \"red\",\n\t          scanState: \"idle\",\n\t        });\n\t      },\n\t      increaseTestNo: () => {\n\t        set((state) => ({ testNo: state.testNo + 1 }));\n", "      },\n\t    }),\n\t    {\n\t      name: \"scanner-store\",\n\t      partialize: (state) => pick(state, Object.keys(settingsInitialValues)),\n\t      version: 1,\n\t    }\n\t  )\n\t);\n\ttype IPScannerProps = {\n", "  allIps: string[];\n\t};\n\texport const useIPScanner = ({ allIps }: IPScannerProps) => {\n\t  const {\n\t    dispatch,\n\t    reset,\n\t    increaseTestNo,\n\t    addValidIP,\n\t    getScanState,\n\t    getValidIPCount,\n", "    ...state\n\t  } = useScannerStore();\n\t  function setToIdle() {\n\t    dispatch({ scanState: \"idle\", tryChar: \"\" });\n\t  }\n\t  async function startScan() {\n\t    reset();\n\t    try {\n\t      const ips = state.ipRegex\n\t        ? allIps.filter((el) => new RegExp(state.ipRegex).test(el))\n", "        : allIps;\n\t      dispatch({ scanState: \"scanning\" });\n\t      await testIPs(randomizeElements(ips));\n\t      setToIdle();\n\t    } catch (e) {\n\t      console.error(e);\n\t    }\n\t  }\n\t  function stopScan() {\n\t    if (getScanState() === \"scanning\") {\n", "      dispatch({ scanState: \"stopping\" });\n\t    } else {\n\t      setToIdle();\n\t    }\n\t  }\n\t  async function testIPs(ipList: string[]) {\n\t    for (const ip of ipList) {\n\t      increaseTestNo();\n\t      const url = `https://${ip}/__down`;\n\t      let testCount = 0;\n", "      const startTime = performance.now();\n\t      const multiply =\n\t        state.maxLatency <= 500 ? 1.5 : state.maxLatency <= 1000 ? 1.2 : 1;\n\t      let timeout = 1.5 * multiply * state.maxLatency;\n\t      for (let i = 0; i < MAX_TRIES; i++) {\n\t        const controller = new AbortController();\n\t        const timeoutId = setTimeout(() => {\n\t          controller.abort();\n\t        }, Math.trunc(timeout));\n\t        const newState: Partial<ScannerStore> = {\n", "          currentIP: ip,\n\t          tryChar: TRY_CHARS[i] || \"\",\n\t        };\n\t        if (i === 0) {\n\t          timeout = multiply * state.maxLatency;\n\t          newState.color = \"red\";\n\t          newState.currentLatency = 0;\n\t        } else {\n\t          timeout = 1.2 * multiply * state.maxLatency;\n\t          newState.color = \"green\";\n", "          newState.currentLatency = Math.floor(\n\t            (performance.now() - startTime) / (i + 1)\n\t          );\n\t        }\n\t        dispatch(newState);\n\t        try {\n\t          await fetch(url, {\n\t            signal: controller.signal,\n\t          });\n\t          testCount++;\n", "        } catch (error) {\n\t          // don't increase testResult if it's not an abort error\n\t          if (!(error instanceof Error && error.name === \"AbortError\")) {\n\t            testCount++;\n\t          }\n\t        }\n\t        clearTimeout(timeoutId);\n\t      }\n\t      const latency = Math.floor((performance.now() - startTime) / MAX_TRIES);\n\t      if (testCount === MAX_TRIES && latency <= state.maxLatency) {\n", "        addValidIP({\n\t          ip,\n\t          latency,\n\t        });\n\t      }\n\t      if (\n\t        getScanState() !== \"scanning\" ||\n\t        getValidIPCount() >= state.maxIPCount\n\t      ) {\n\t        break;\n", "      }\n\t    }\n\t  }\n\t  return {\n\t    ...state,\n\t    startScan,\n\t    stopScan,\n\t  };\n\t};\n"]}
{"filename": "src/types/index.ts", "chunked_list": ["export type IPInfo = {\n\t  ipVersion: number;\n\t  ipAddress: string;\n\t  latitude: number;\n\t  longitude: number;\n\t  countryName: string;\n\t  countryCode: string;\n\t  timeZone: string;\n\t  zipCode: string;\n\t  cityName: string;\n", "  regionName: string;\n\t};\n"]}
