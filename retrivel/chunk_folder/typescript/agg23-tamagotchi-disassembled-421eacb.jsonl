{"filename": "src/assembler.ts", "chunked_list": ["import fs, { readFileSync, writeFileSync } from \"fs\";\n\timport { argv } from \"process\";\n\timport readline from \"readline\";\n\timport events from \"events\";\n\timport { InstructionSet, parseArchLine } from \"./lib/bass\";\n\timport { parseNumber } from \"./lib/util\";\n\timport * as path from \"path\";\n\timport { AssembledProgram } from \"./lib/types\";\n\timport { commentRegex, labelRegex } from \"./lib/regex\";\n\timport { outputInstructions } from \"./lib/opcodeOutput\";\n", "import { log } from \"./lib/log\";\n\timport { readArch, readByLines } from \"./lib/fs\";\n\tinterface ComamndEntry {\n\t  regex: RegExp;\n\t  action: (\n\t    line: { line: string; lineNumber: number },\n\t    matches: RegExpExecArray,\n\t    program: AssembledProgram\n\t  ) => void;\n\t}\n", "// The commands supported by the assembler (separate from opcodes)\n\tconst commands: ComamndEntry[] = [\n\t  {\n\t    regex: /origin\\s+((?:0x)?[a-f0-9]+)/,\n\t    action: ({ lineNumber }, [_2, address], program) => {\n\t      if (address === undefined) {\n\t        log(\"Could not parse origin\", lineNumber);\n\t        return;\n\t      }\n\t      program.currentAddress = parseNumber(address);\n", "    },\n\t  },\n\t  {\n\t    regex: /constant\\s+(?:(0x[a-f0-9]+|[0-9]+)|([a-z0-9_]+))/,\n\t    action: ({ line, lineNumber }, [_, constant, label], program) => {\n\t      const address = program.currentAddress;\n\t      if (constant !== undefined) {\n\t        const value = parseNumber(constant);\n\t        if (value > 4095) {\n\t          log(\n", "            `Constant ${constant} is too large to fit into 12 bits`,\n\t            lineNumber\n\t          );\n\t          return;\n\t        }\n\t        program.matchedInstructions.push({\n\t          type: \"constant\",\n\t          subtype: \"literal\",\n\t          value,\n\t          line,\n", "          lineNumber,\n\t          address,\n\t        });\n\t      } else if (label !== undefined) {\n\t        program.matchedInstructions.push({\n\t          type: \"constant\",\n\t          subtype: \"label\",\n\t          label,\n\t          line,\n\t          lineNumber,\n", "          address,\n\t        });\n\t      } else {\n\t        log(\"Unknown constant error\", lineNumber);\n\t        return;\n\t      }\n\t      program.currentAddress += 1;\n\t    },\n\t  },\n\t];\n", "const parseAsmLine = (\n\t  line: string,\n\t  lineNumber: number,\n\t  instructionSet: InstructionSet,\n\t  program: AssembledProgram\n\t) => {\n\t  if (line.length == 0 || line.startsWith(\"//\") || line.startsWith(\";\")) {\n\t    // Comment. Skip\n\t    return;\n\t  }\n", "  for (const command of commands) {\n\t    const matches = command.regex.exec(line);\n\t    if (!!matches && matches.length > 0) {\n\t      command.action({ lineNumber, line }, matches, program);\n\t      return;\n\t    }\n\t  }\n\t  let hasInstruction = false;\n\t  // Match line against all known instructions from the BASS arch\n\t  for (const instruction of instructionSet.instructions) {\n", "    const matches = instruction.regex.exec(line);\n\t    const address = program.currentAddress;\n\t    if (!!matches && matches.length > 0) {\n\t      if (matches[1] !== undefined) {\n\t        // immediate\n\t        if (instruction.type !== \"immediate\") {\n\t          log(\n\t            \"Attempted to match content with non-immediate instruction\",\n\t            lineNumber\n\t          );\n", "          return;\n\t        }\n\t        program.matchedInstructions.push({\n\t          type: \"immediate\",\n\t          line,\n\t          immediate: parseNumber(matches[1]),\n\t          opcodeString: instruction.opcodeString,\n\t          bitCount: instruction.immediate.bitCount,\n\t          lineNumber,\n\t          address,\n", "        });\n\t      } else if (matches[2] !== undefined) {\n\t        // potential label\n\t        if (instruction.type !== \"immediate\") {\n\t          log(\n\t            \"Attempted to match content with non-immediate instruction\",\n\t            lineNumber\n\t          );\n\t          return;\n\t        }\n", "        program.matchedInstructions.push({\n\t          type: \"label\",\n\t          line,\n\t          label: matches[2],\n\t          opcodeString: instruction.opcodeString,\n\t          bitCount: instruction.immediate.bitCount,\n\t          lineNumber,\n\t          address,\n\t        });\n\t      } else {\n", "        // literal only\n\t        program.matchedInstructions.push({\n\t          type: \"literal\",\n\t          line,\n\t          opcodeString: instruction.opcodeString,\n\t          lineNumber,\n\t          address,\n\t        });\n\t      }\n\t      hasInstruction = true;\n", "      program.currentAddress += 1;\n\t      break;\n\t    }\n\t  }\n\t  if (hasInstruction && program.unmatchedLabels.length > 0) {\n\t    // Add queued labels\n\t    for (const label of program.unmatchedLabels) {\n\t      const existingLabel = program.matchedLabels[label.label];\n\t      if (existingLabel) {\n\t        log(\n", "          `Label \"${label.label}\" already exists. Was created on line ${existingLabel.lineNumber}`,\n\t          lineNumber\n\t        );\n\t        return;\n\t      }\n\t      program.matchedLabels[label.label] = {\n\t        lineNumber,\n\t        instructionIndex: program.matchedInstructions.length - 1,\n\t        address: program.currentAddress - 1,\n\t      };\n", "    }\n\t    // We've processed all labels\n\t    program.unmatchedLabels = [];\n\t  }\n\t  let lineWithoutLabel = line;\n\t  const matches = labelRegex.exec(line);\n\t  if (!!matches && matches.length > 0 && matches[1]) {\n\t    lineWithoutLabel =\n\t      lineWithoutLabel.substring(0, matches.index) +\n\t      lineWithoutLabel.substring(matches.index + matches[0].length);\n", "    const label = matches[1];\n\t    const existingLabel = program.matchedLabels[label];\n\t    if (existingLabel) {\n\t      log(\n\t        `Label \"${label}\" already exists. Was created on line ${existingLabel.lineNumber}`,\n\t        lineNumber\n\t      );\n\t      return;\n\t    }\n\t    if (hasInstruction) {\n", "      // Instruction on this line, pair them up\n\t      program.matchedLabels[label] = {\n\t        lineNumber,\n\t        instructionIndex: program.matchedInstructions.length - 1,\n\t        address: program.currentAddress - 1,\n\t      };\n\t    } else {\n\t      // Will pair with some future instruction. Queue it\n\t      program.unmatchedLabels.push({\n\t        label,\n", "        lineNumber,\n\t      });\n\t    }\n\t  }\n\t  lineWithoutLabel = lineWithoutLabel.replace(commentRegex, \"\").trim();\n\t  if (!hasInstruction && lineWithoutLabel.length > 0) {\n\t    log(`Unknown instruction \"${lineWithoutLabel}\"`, lineNumber);\n\t  }\n\t};\n\tif (argv.length != 4 && argv.length != 5) {\n", "  console.log(`Received ${argv.length - 2} arguments. Expected 2-3\\n`);\n\t  console.log(\n\t    \"Usage: node assembler.js [input.asm] [output.bin] {true|false: 12 bit output}\"\n\t  );\n\t  process.exit(1);\n\t}\n\tconst archPath = path.join(__dirname, \"../bass/6200.arch\");\n\tconst inputFile = argv[2] as string;\n\tconst outputFile = argv[3] as string;\n\tconst word16Align = argv[4] !== \"true\";\n", "const build = async () => {\n\t  const program: AssembledProgram = {\n\t    currentAddress: 0,\n\t    matchedInstructions: [],\n\t    matchedLabels: {},\n\t    unmatchedLabels: [],\n\t  };\n\t  const instructionSet = await readArch(archPath);\n\t  await readByLines(inputFile, (line, lineNumber) =>\n\t    parseAsmLine(line, lineNumber, instructionSet, program)\n", "  );\n\t  const outputBuffer = outputInstructions(program, word16Align);\n\t  if (outputBuffer.type === \"some\") {\n\t    writeFileSync(outputFile, outputBuffer.value);\n\t  } else {\n\t    console.log(\"Could not generate output binary\");\n\t  }\n\t};\n\tbuild();\n"]}
{"filename": "src/extractIcons.ts", "chunked_list": ["import { readFileSync, writeFileSync } from \"fs\";\n\timport { argv } from \"process\";\n\timport encode from \"image-encode\";\n\tinterface PossibleImage {\n\t  address: number;\n\t  width: number;\n\t}\n\tconst findImages = (buffer: Buffer): PossibleImage[] => {\n\t  const images: PossibleImage[] = [];\n\t  let lbpxCount = 0;\n", "  for (let i = 0; i < buffer.length; i += 2) {\n\t    // Skip the low byte of every word\n\t    const highNibble = buffer[i]! & 0xf;\n\t    if (highNibble === 0x9) {\n\t      // LBPX\n\t      // This is probably a set of pixels for an image\n\t      lbpxCount += 1;\n\t    } else if (highNibble === 0x1 && lbpxCount > 0) {\n\t      // RETD\n\t      // We have some number of possible pixels, so consider this a complete image write\n", "      images.push({\n\t        address: i - lbpxCount * 2,\n\t        width: lbpxCount + 1,\n\t      });\n\t      lbpxCount = 0;\n\t    } else {\n\t      // If there's a gap in instructions, reset lbpxCount\n\t      lbpxCount = 0;\n\t    }\n\t  }\n", "  return images;\n\t};\n\tconst IMAGE_HEIGHT = 8;\n\tconst IMAGE_WIDTH = 16;\n\tconst generateImages = (romBuffer: Buffer) => {\n\t  const images = findImages(romBuffer);\n\t  for (const image of images) {\n\t    const imageBuffer = Buffer.alloc(16 * 8 * 4);\n\t    for (let y = 0; y < IMAGE_HEIGHT; y++) {\n\t      for (let x = 0; x < image.width; x++) {\n", "        // Load the second byte of the word, which is where the immediate is\n\t        const byte = romBuffer[image.address + x * 2 + 1]!;\n\t        const imageCoord = (y * IMAGE_WIDTH + x) * 4;\n\t        if (((byte >> y) & 0x1) !== 0) {\n\t          // Pixel at x, y is on\n\t          // Array is initialized to 0, so we can just toggle the alpha value to display black\n\t          imageBuffer[imageCoord + 3] = 0xff;\n\t        } else {\n\t          imageBuffer[imageCoord + 3] = 0;\n\t        }\n", "      }\n\t    }\n\t    const wordAddress = image.address / 2;\n\t    writeFileSync(\n\t      `images/0x${wordAddress.toString(16)}.png`,\n\t      Buffer.from(encode(imageBuffer, [16, 8], \"png\"))\n\t    );\n\t  }\n\t};\n\tif (argv.length != 3) {\n", "  console.log(`Received ${argv.length - 2} arguments. Expected 1\\n`);\n\t  console.log(\"Usage: node extractIcons.js [input.bin]\");\n\t  process.exit(1);\n\t}\n\tconst inputFile = argv[2] as string;\n\tconst build = async () => {\n\t  const buffer = readFileSync(inputFile);\n\t  generateImages(buffer);\n\t};\n\tbuild();\n"]}
{"filename": "src/disassembler.ts", "chunked_list": ["import { readFileSync, writeFileSync } from \"fs\";\n\timport path from \"path\";\n\timport { argv } from \"process\";\n\timport { parseBinaryBuffer } from \"./lib/disassembly\";\n\timport { readArch } from \"./lib/fs\";\n\tif (argv.length != 4) {\n\t  console.log(`Received ${argv.length - 2} arguments. Expected 2\\n`);\n\t  console.log(\"Usage: node disassembler.js [input.bin] [output.asm]\");\n\t  process.exit(1);\n\t}\n", "const archPath = path.join(__dirname, \"../bass/6200.arch\");\n\tconst inputFile = argv[2] as string;\n\tconst outputFile = argv[3] as string;\n\tconst build = async () => {\n\t  const instructionSet = await readArch(archPath);\n\t  const sortedInstructions = instructionSet.instructions.sort(\n\t    (a, b) => a.sortableOpcode - b.sortableOpcode\n\t  );\n\t  const buffer = readFileSync(inputFile);\n\t  const outputString = parseBinaryBuffer(buffer, sortedInstructions);\n", "  writeFileSync(outputFile, outputString);\n\t};\n\tbuild();\n"]}
{"filename": "src/lib/disassembly.ts", "chunked_list": ["import { ImmediateInstruction, Instruction } from \"./bass\";\n\timport { buildDisassembledInstructionString } from \"./display\";\n\timport { DisassembledInstruction } from \"./types\";\n\timport { maskOfSize } from \"./util\";\n\texport const parseBinaryBuffer = (\n\t  buffer: Buffer,\n\t  instructions: Instruction[]\n\t): string => {\n\t  const disassembledInstructions: DisassembledInstruction[] = [];\n\t  const unsetLabels: Array<DisassembledInstruction[] | undefined> = new Array(\n", "    8192\n\t  );\n\t  for (let i = 0; i < buffer.length; i += 2) {\n\t    const highByte = buffer[i]!;\n\t    const lowByte = buffer[i + 1]!;\n\t    const address = i / 2;\n\t    const correctedWord = (highByte << 8) | lowByte;\n\t    const instruction = findWordInstruction(correctedWord, instructions);\n\t    const disassembledInstruction: DisassembledInstruction = {\n\t      instruction,\n", "      actualWord: correctedWord,\n\t      address,\n\t    };\n\t    if (isFlowControlWithImmediate(instruction)) {\n\t      // Convert local address into global one\n\t      const pcLowerByte =\n\t        correctedWord & maskOfSize(instruction.immediate.bitCount);\n\t      let pcUpperFive = (address >> 8) & 0x1f;\n\t      if (isCalz(instruction)) {\n\t        // calz is only zero page and prevents pset\n", "        pcUpperFive = 0;\n\t      } else {\n\t        const lastInstruction =\n\t          disassembledInstructions[disassembledInstructions.length - 1]!;\n\t        if (isPset(lastInstruction.instruction)) {\n\t          // PSET immediate determines our upper 5 bits\n\t          pcUpperFive = lastInstruction.actualWord & 0x1f;\n\t        }\n\t      }\n\t      const pc = (pcUpperFive << 8) | pcLowerByte;\n", "      const existingLabel = unsetLabels[pc];\n\t      if (existingLabel) {\n\t        existingLabel.push(disassembledInstruction);\n\t      } else {\n\t        unsetLabels[pc] = [disassembledInstruction];\n\t      }\n\t    }\n\t    disassembledInstructions.push(disassembledInstruction);\n\t  }\n\t  // Build label names\n", "  let labelCount = 0;\n\t  const namedLabels: Array<\n\t    | {\n\t        name: string;\n\t        instructions: DisassembledInstruction[];\n\t      }\n\t    | undefined\n\t  > = unsetLabels.map((instructions) => {\n\t    if (!!instructions) {\n\t      return {\n", "        name: `label_${labelCount++}`,\n\t        instructions,\n\t      };\n\t    }\n\t    return undefined;\n\t  });\n\t  // Build list of instructions that will replace the immedates with these labels, and build labels\n\t  const labelUsageMap: Array<string | undefined> = new Array(8192);\n\t  for (const namedLabel of namedLabels) {\n\t    if (namedLabel) {\n", "      for (const instruction of namedLabel.instructions) {\n\t        labelUsageMap[instruction.address] = namedLabel.name;\n\t      }\n\t    }\n\t  }\n\t  let output = \"\";\n\t  let address = 0;\n\t  for (const instruction of disassembledInstructions) {\n\t    const immediateLabel = labelUsageMap[instruction.address];\n\t    const lineLabel = namedLabels[instruction.address];\n", "    if (lineLabel) {\n\t      output += `\\n${lineLabel.name}:\\n`;\n\t    }\n\t    output += `  ${buildDisassembledInstructionString(\n\t      instruction,\n\t      immediateLabel\n\t    )}\\n`;\n\t    address += 1;\n\t  }\n\t  return output;\n", "};\n\tconst findWordInstruction = (word: number, instructions: Instruction[]) => {\n\t  // Naive because it doesn't really matter\n\t  let bestMatch = instructions[0]!;\n\t  for (let i = 0; i < instructions.length; i++) {\n\t    const instruction = instructions[i]!;\n\t    if (instruction.sortableOpcode <= word) {\n\t      bestMatch = instruction;\n\t    } else {\n\t      // We've passed the best solution, end\n", "      break;\n\t    }\n\t  }\n\t  return bestMatch;\n\t};\n\tconst flowControlImmediateMnemonics = ((): Set<string> =>\n\t  new Set<string>([\"call\", \"calz\", \"jp\"]))();\n\tconst extractMnemonic = (instruction: Instruction): string =>\n\t  instruction.originalInstruction.split(/\\s/)[0]!.trim();\n\tconst isFlowControlWithImmediate = (\n", "  instruction: Instruction\n\t): instruction is ImmediateInstruction => {\n\t  const mnemonic = extractMnemonic(instruction);\n\t  return flowControlImmediateMnemonics.has(mnemonic);\n\t};\n\tconst isPset = (instruction: Instruction): boolean => {\n\t  const mnemonic = extractMnemonic(instruction);\n\t  return mnemonic === \"pset\";\n\t};\n\tconst isCalz = (instruction: Instruction) => {\n", "  const mnemonic = extractMnemonic(instruction);\n\t  return mnemonic === \"calz\";\n\t};\n"]}
{"filename": "src/lib/display.ts", "chunked_list": ["import { DisassembledInstruction } from \"./types\";\n\timport { isLetterChar, maskOfSize } from \"./util\";\n\texport const buildDisassembledInstructionString = (\n\t  { instruction, actualWord, address }: DisassembledInstruction,\n\t  immediateLabel: string | undefined\n\t) => {\n\t  let instructionString = instruction.originalInstruction;\n\t  if (instruction.type === \"immediate\") {\n\t    const { bitCount, stringIndex, stringLength } = instruction.immediate;\n\t    const immediatePrefix = instructionString.substring(0, stringIndex);\n", "    const immediateSuffix = instructionString.substring(\n\t      stringIndex + stringLength\n\t    );\n\t    let immediate = \"\";\n\t    if (immediateLabel) {\n\t      immediate = immediateLabel;\n\t    } else {\n\t      const argument = maskOfSize(bitCount) & actualWord;\n\t      if (isLetterChar(immediatePrefix.charAt(immediatePrefix.length - 1))) {\n\t        // If letter, treat as decimal\n", "        immediate = argument.toString();\n\t      } else {\n\t        // Otherwise, treat as hex\n\t        immediate = `0x${argument.toString(16).toUpperCase()}`;\n\t      }\n\t    }\n\t    instructionString = `${immediatePrefix}${immediate}${immediateSuffix}`;\n\t  }\n\t  // Separate out instruction so that it formats nicely\n\t  // Four total columns\n", "  // Opcode - Source - Dest - Comments\n\t  const splitInstruction = instructionString.split(/\\s+/);\n\t  let lastPadWidth = 0;\n\t  for (let i = 2; i >= splitInstruction.length - 1; i--) {\n\t    lastPadWidth += columnPadWidth(i);\n\t  }\n\t  const formattedInstructionString = splitInstruction\n\t    .map((s, i) => {\n\t      const pad =\n\t        i === splitInstruction.length - 1 ? lastPadWidth : columnPadWidth(i);\n", "      return s.padEnd(pad);\n\t    })\n\t    .join(\"\");\n\t  const comment = `// 0x${address\n\t    .toString(16)\n\t    .toUpperCase()\n\t    .padEnd(4)} (0x${actualWord.toString(16).toUpperCase()})`;\n\t  return `${formattedInstructionString.padEnd(81)}${comment}`;\n\t};\n\tconst columnPadWidth = (column: number) => {\n", "  switch (column) {\n\t    case 0:\n\t      return 6;\n\t    case 1:\n\t      return 5;\n\t    case 2:\n\t      return 10;\n\t  }\n\t  return 0;\n\t};\n"]}
{"filename": "src/lib/bass.ts", "chunked_list": ["import {\n\t  bassNumberRegex,\n\t  instructionPrefixRegex,\n\t  instructionSuffixRegex,\n\t  whitespaceRegex,\n\t} from \"./regex\";\n\timport { log } from \"./log\";\n\timport { parseNumber } from \"./util\";\n\timport { buildOpcode } from \"./opcodeOutput\";\n\texport interface InstructionSet {\n", "  instructions: Array<Instruction>;\n\t}\n\texport type Instruction = ImmediateInstruction | LiteralInstruction;\n\texport interface InstructionBase {\n\t  regex: RegExp;\n\t  opcodeString: string;\n\t  sortableOpcode: number;\n\t  originalInstruction: string;\n\t}\n\texport type ImmediateInstruction = InstructionBase & {\n", "  type: \"immediate\";\n\t  immediate: {\n\t    bitCount: number;\n\t    /**\n\t     * The index in the originalInstruction the immediate occurs\n\t     */\n\t    stringIndex: number;\n\t    /**\n\t     * The length of the immediate in the originalInstruction string\n\t     */\n", "    stringLength: number;\n\t  };\n\t};\n\texport type LiteralInstruction = InstructionBase & {\n\t  type: \"literal\";\n\t};\n\t/**\n\t * Parses a single line of a BASS architecture file\n\t * @param line The line being parsed\n\t * @param lineNumber The one-based index of the line being processed\n", " * @param config The global instruction set config\n\t * @returns\n\t */\n\texport const parseArchLine = (\n\t  line: string,\n\t  lineNumber: number,\n\t  config: InstructionSet\n\t) => {\n\t  if (line.length == 0 || line.startsWith(\"//\") || line.startsWith(\"#\")) {\n\t    // Comment. Skip\n", "    return;\n\t  }\n\t  const sections = line.split(\";\");\n\t  if (sections.length != 2) {\n\t    log(\n\t      \"Unexpected semicolon. Does this instruction have an output?\",\n\t      lineNumber\n\t    );\n\t    return;\n\t  }\n", "  const [originalInstruction, opcode] = sections;\n\t  if (!originalInstruction || !opcode) {\n\t    log(\"Unknown input\", lineNumber);\n\t    return;\n\t  }\n\t  const opcodeString = opcode.trim();\n\t  let numberMatch = originalInstruction.match(bassNumberRegex);\n\t  if (!!numberMatch && numberMatch.index) {\n\t    // This instruction contains a star followed by a number\n\t    // This is an immediate\n", "    const matchString = numberMatch[0];\n\t    // This is guaranteed to exist due to the regex\n\t    const bitCount = parseNumber(numberMatch[1]!);\n\t    const index = numberMatch.index;\n\t    const instructionLine =\n\t      originalInstruction.substring(0, index) +\n\t      \"(?:(0x[a-f0-9]+|[0-9]+)|([a-z0-9_]+))\" +\n\t      originalInstruction.substring(index + matchString.length);\n\t    const sortableOpcode = buildSortableOpcode(opcodeString, bitCount);\n\t    config.instructions.push({\n", "      type: \"immediate\",\n\t      regex: cleanAndFinishInstructionRegex(instructionLine),\n\t      immediate: {\n\t        bitCount,\n\t        stringIndex: index,\n\t        stringLength: matchString.length,\n\t      },\n\t      opcodeString,\n\t      sortableOpcode,\n\t      originalInstruction: originalInstruction.trim(),\n", "    });\n\t  } else {\n\t    // This is a literal\n\t    const sortableOpcode = buildSortableOpcode(opcodeString, 0);\n\t    config.instructions.push({\n\t      type: \"literal\",\n\t      regex: cleanAndFinishInstructionRegex(originalInstruction),\n\t      opcodeString,\n\t      sortableOpcode,\n\t      originalInstruction: originalInstruction.trim(),\n", "    });\n\t  }\n\t};\n\tconst buildSortableOpcode = (template: string, bitCount: number) =>\n\t  buildOpcode(template, bitCount, 0);\n\tconst cleanAndFinishInstructionRegex = (instruction: string): RegExp => {\n\t  const cleaned = instruction\n\t    .trim()\n\t    .replace(whitespaceRegex, whitespaceRegex.source);\n\t  // Force nothing but whitespace from beginning of string to instruction\n", "  // Force nothing but whitespace and a comment from instruction to end of string\n\t  return new RegExp(\n\t    instructionPrefixRegex.source + cleaned + instructionSuffixRegex.source\n\t  );\n\t};\n"]}
{"filename": "src/lib/types.ts", "chunked_list": ["import { Instruction } from \"./bass\";\n\texport interface MatchedInstructionBase {\n\t  line: string;\n\t  lineNumber: number;\n\t  address: number;\n\t}\n\texport type ConstantLiteralMatchedInstruction = MatchedInstructionBase & {\n\t  type: \"constant\";\n\t  subtype: \"literal\";\n\t  value: number;\n", "};\n\texport type ConstantLabelMatchedInstruction = MatchedInstructionBase & {\n\t  type: \"constant\";\n\t  subtype: \"label\";\n\t  label: string;\n\t};\n\texport type ImmediateMatchedInstruction = MatchedInstructionBase & {\n\t  type: \"immediate\";\n\t  immediate: number;\n\t  bitCount: number;\n", "  opcodeString: string;\n\t};\n\texport type LabelMatchedInstruction = MatchedInstructionBase & {\n\t  type: \"label\";\n\t  label: string;\n\t  bitCount: number;\n\t  opcodeString: string;\n\t};\n\texport type LiteralMatchedInstruction = MatchedInstructionBase & {\n\t  type: \"literal\";\n", "  opcodeString: string;\n\t};\n\texport interface AssembledProgram {\n\t  currentAddress: number;\n\t  matchedInstructions: Array<\n\t    | ConstantLiteralMatchedInstruction\n\t    | ConstantLabelMatchedInstruction\n\t    | ImmediateMatchedInstruction\n\t    | LabelMatchedInstruction\n\t    | LiteralMatchedInstruction\n", "  >;\n\t  matchedLabels: {\n\t    [name: string]: {\n\t      lineNumber: number;\n\t      instructionIndex: number;\n\t      address: number;\n\t    };\n\t  };\n\t  unmatchedLabels: Array<{\n\t    label: string;\n", "    lineNumber: number;\n\t  }>;\n\t}\n\t/// Disassembly ///\n\texport interface DisassembledInstruction {\n\t  instruction: Instruction;\n\t  actualWord: number;\n\t  address: number;\n\t}\n\texport interface Some<T> {\n", "  type: \"some\";\n\t  value: T;\n\t}\n\texport interface None {\n\t  type: \"none\";\n\t}\n\texport type Option<T> = Some<T> | None;\n"]}
{"filename": "src/lib/log.ts", "chunked_list": ["/**\n\t * Logs an error message with a line number and message\n\t * @param message The error message to display\n\t * @param lineNumber The one-based index of the line that generated the error\n\t */\n\texport const log = (message: String, lineNumber: Number) =>\n\t  console.log(`ERROR (line ${lineNumber}): ${message}`);\n"]}
{"filename": "src/lib/fs.ts", "chunked_list": ["import fs from \"fs\";\n\timport readline from \"readline\";\n\timport events from \"events\";\n\timport { InstructionSet, parseArchLine } from \"./bass\";\n\t/**\n\t * Opens a file and streams it out, line by line\n\t * @param path The path of the file to read\n\t * @param onLine A callback used to respond to each line content and its line number\n\t */\n\texport const readByLines = async (\n", "  path: string,\n\t  onLine: (line: string, lineNumber: number) => void\n\t) => {\n\t  const rl = readline.createInterface({\n\t    input: fs.createReadStream(path),\n\t    crlfDelay: Infinity,\n\t  });\n\t  let lineNumber = 0;\n\t  rl.on(\"line\", (line) => onLine(line.toLowerCase().trim(), ++lineNumber));\n\t  await events.once(rl, \"close\");\n", "};\n\t/**\n\t * Reads and parses the BASS arch file\n\t * @param path The path of the arch file\n\t * @returns The InstructionSet resulting from parsing the arch file\n\t */\n\texport const readArch = async (path: string): Promise<InstructionSet> => {\n\t  const instructionSet: InstructionSet = {\n\t    instructions: [],\n\t  };\n", "  await readByLines(path, (line, lineNumber) =>\n\t    parseArchLine(line, lineNumber, instructionSet)\n\t  );\n\t  return instructionSet;\n\t};\n"]}
{"filename": "src/lib/opcodeOutput.ts", "chunked_list": ["import { log } from \"./log\";\n\timport { AssembledProgram, Option } from \"./types\";\n\timport { maskOfSize } from \"./util\";\n\t/**\n\t * Builds the output buffer from the matched instructions\n\t * @param program The configured program we have built\n\t * @param word16Align If true, align the 12 bit opcodes to 16 bit words. The lowest nibble will be 0\n\t * @returns The output buffer that should be written to the assembled binary\n\t */\n\texport const outputInstructions = (\n", "  program: AssembledProgram,\n\t  word16Align: boolean\n\t): Option<Buffer> => {\n\t  // This buffer stores each nibble of the program separately, and we will combine this later into the output buffer\n\t  const threeNibbleBuffer: number[] = new Array(8192 * 3);\n\t  // Fill array with 0xF\n\t  for (let i = 0; i < threeNibbleBuffer.length; i++) {\n\t    threeNibbleBuffer[i] = 0xf;\n\t  }\n\t  for (const instruction of program.matchedInstructions) {\n", "    let opcode = 0;\n\t    switch (instruction.type) {\n\t      case \"literal\": {\n\t        opcode = buildOpcode(instruction.opcodeString, 0, 0);\n\t        break;\n\t      }\n\t      case \"immediate\": {\n\t        opcode = buildOpcode(\n\t          instruction.opcodeString,\n\t          instruction.bitCount,\n", "          instruction.immediate\n\t        );\n\t        break;\n\t      }\n\t      case \"label\": {\n\t        const label = program.matchedLabels[instruction.label];\n\t        if (!label) {\n\t          log(`Unknown label ${instruction.label}`, instruction.lineNumber);\n\t          return { type: \"none\" };\n\t        }\n", "        opcode = buildOpcode(\n\t          instruction.opcodeString,\n\t          instruction.bitCount,\n\t          label.address\n\t        );\n\t        break;\n\t      }\n\t      case \"constant\": {\n\t        if (instruction.subtype === \"literal\") {\n\t          opcode = instruction.value;\n", "        } else {\n\t          // Label\n\t          const label = program.matchedLabels[instruction.label];\n\t          if (!label) {\n\t            log(`Unknown label ${instruction.label}`, instruction.lineNumber);\n\t            return { type: \"none\" };\n\t          }\n\t          console.log(`${label.address.toString(16)}`);\n\t          opcode = label.address;\n\t        }\n", "        break;\n\t      }\n\t    }\n\t    const low = opcode & 0xf;\n\t    const mid = (opcode & 0xf0) >> 4;\n\t    const high = (opcode & 0xf00) >> 8;\n\t    const baseAddress = instruction.address * 3;\n\t    // We use reverse order because that's how the nibbles are in the ROM\n\t    threeNibbleBuffer[baseAddress] = high;\n\t    threeNibbleBuffer[baseAddress + 1] = mid;\n", "    threeNibbleBuffer[baseAddress + 2] = low;\n\t  }\n\t  return {\n\t    type: \"some\",\n\t    value: copyToOutputBuffer(threeNibbleBuffer, word16Align),\n\t  };\n\t};\n\tconst copyToOutputBuffer = (\n\t  threeNibbleBuffer: number[],\n\t  word16Align: boolean\n", "): Buffer => {\n\t  const bufferSize = word16Align ? 8192 * 2 : (8192 * 3) / 2;\n\t  const buffer = Buffer.alloc(bufferSize);\n\t  let byteBuffer = 0;\n\t  let bufferAddress = 0;\n\t  let lowNibble = false;\n\t  let evenByte = true;\n\t  for (let i = 0; i < threeNibbleBuffer.length; i++) {\n\t    const nibble = threeNibbleBuffer[i]!;\n\t    const writeSpacerValue = word16Align && !lowNibble && evenByte;\n", "    if (lowNibble || writeSpacerValue) {\n\t      // \"Second\", lower value of byte, or we're writing the spacer now\n\t      byteBuffer |= nibble;\n\t      buffer[bufferAddress] = byteBuffer;\n\t      bufferAddress += 1;\n\t      byteBuffer = 0;\n\t      evenByte = !evenByte;\n\t    } else {\n\t      // \"First\", upper value of byte\n\t      byteBuffer |= nibble << 4;\n", "    }\n\t    if (!writeSpacerValue) {\n\t      // We've moved to the next byte if we wrote a spacer, so stay at !lowNibble\n\t      lowNibble = !lowNibble;\n\t    }\n\t  }\n\t  return buffer;\n\t};\n\t/**\n\t * Comsumes the opcode template from the BASS arch file and produces the actual output word\n", " * @param template The opcode template from the BASS arch file\n\t * @param argSize The number of bits in an argument to the opcode, if any\n\t * @param argument The actual data to pass as an argument to the opcode, if any\n\t * @returns The output opcode as a 12 bit word\n\t */\n\texport const buildOpcode = (\n\t  template: string,\n\t  argSize: number,\n\t  argument: number\n\t) => {\n", "  let index = 0;\n\t  let outputWord = 0;\n\t  while (index < template.length) {\n\t    const char = template[index];\n\t    if (char === \"%\") {\n\t      // Consume chars until whitespace\n\t      let data = 0;\n\t      let count = 0;\n\t      for (let i = 1; i < Math.min(13, template.length - index); i++) {\n\t        const nextChar = template[index + i]!;\n", "        if (nextChar !== \"1\" && nextChar !== \"0\") {\n\t          // Stop consuming\n\t          break;\n\t        }\n\t        data <<= 1;\n\t        data |= nextChar === \"1\" ? 1 : 0;\n\t        count += 1;\n\t      }\n\t      // Consume the next four chars as bits\n\t      outputWord <<= count;\n", "      outputWord |= data;\n\t      index += count + 1;\n\t    } else if (char === \"=\") {\n\t      if (template[index + 1] !== \"a\") {\n\t        console.log(\n\t          `ERROR: Unexpected char after = in instruction definition \"${template}\"`\n\t        );\n\t        return 0;\n\t      }\n\t      outputWord <<= argSize;\n", "      outputWord |= maskOfSize(argSize) & argument;\n\t      index += 2;\n\t    } else {\n\t      index += 1;\n\t    }\n\t  }\n\t  return outputWord;\n\t};\n"]}
{"filename": "src/lib/regex.ts", "chunked_list": ["export const whitespaceRegex = /\\s+/g;\n\texport const bassNumberRegex = /\\*([0-9]+)/;\n\texport const labelRegex = /^([a-z0-9_]+):/i;\n\texport const commentRegex = /(\\/\\/.*)/;\n\texport const instructionPrefixRegex = /^\\s*/;\n\texport const instructionSuffixRegex = /\\s*(?:\\/\\/.*)?$/;\n"]}
{"filename": "src/lib/util.ts", "chunked_list": ["/**\n\t * Converts a string into a number. If it is prefixed with 0x, it will be interpreted as base 16, otherwise base 10\n\t * @param string\n\t * @returns The parsed number\n\t */\n\texport const parseNumber = (string: string) => {\n\t  if (string.startsWith(\"0x\")) {\n\t    return parseInt(string.substring(2), 16);\n\t  } else {\n\t    return parseInt(string, 10);\n", "  }\n\t};\n\t/**\n\t * Creates a bitmask used to truncate a number to fit within `size` bits\n\t * @param size The number of bits in the mask\n\t * @returns A bitmask of `size` bits, each bit set as 1\n\t */\n\texport const maskOfSize = (size: number) => {\n\t  let mask = 0;\n\t  for (let i = 0; i < size; i++) {\n", "    mask <<= 1;\n\t    mask |= 1;\n\t  }\n\t  return mask;\n\t};\n\t/**\n\t * Checks whether a string is a single letter\n\t * @param string The string to check\n\t * @returns True if a letter, false otherwise\n\t */\n", "export const isLetterChar = (string: string) =>\n\t  string.length === 1 && string.match(/[a-z]/i);\n"]}
{"filename": "src/customTypes/image-encode.d.ts", "chunked_list": ["declare module \"image-encode\" {\n\t  export default function encode(\n\t    data: Buffer,\n\t    shape: number[],\n\t    options: {}\n\t  ): ArrayBuffer;\n\t}\n"]}
