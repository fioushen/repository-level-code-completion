{"filename": "tsup.config.ts", "chunked_list": ["import { defineConfig } from 'tsup'\n\texport default defineConfig({\n\t  entry: ['src/index.ts', 'src/middleware/zod-validation.ts'],\n\t  format: ['esm', 'cjs'],\n\t  clean: true,\n\t  dts: true,\n\t})\n"]}
{"filename": "test/helpers.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-empty-function */\n\timport { BasicRequest } from '../src/request'\n\texport function buildRequest(url: string, options: RequestInit) {\n\t  return new BasicRequest(new Request(url, options))\n\t}\n\texport function execRoute<Env>(\n\t  route: (arg0: {\n\t    request: BasicRequest\n\t    env: Env\n\t    ctx: ExecutionContext\n", "  }) => Promise<Response>,\n\t  request: BasicRequest\n\t) {\n\t  return route({\n\t    request,\n\t    env: {} as Env,\n\t    ctx: {\n\t      waitUntil: () => {},\n\t      passThroughOnException: () => {},\n\t    },\n", "  })\n\t}\n"]}
{"filename": "example/src/worker.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-unused-vars */\n\timport { RouteHandler, Router, json } from 'cloudflare-basics'\n\t/**\n\t * Welcome to Cloudflare Workers! This is your first worker.\n\t *\n\t * - Run `npm run dev` in your terminal to start a development server\n\t * - Open a browser tab at http://localhost:8787/ to see your worker in action\n\t * - Run `npm run deploy` to publish your worker\n\t *\n\t * Learn more at https://developers.cloudflare.com/workers/\n", " */\n\texport interface Env {\n\t  // Example binding to KV. Learn more at https://developers.cloudflare.com/workers/runtime-apis/kv/\n\t  // MY_KV_NAMESPACE: KVNamespace;\n\t  //\n\t  // Example binding to Durable Object. Learn more at https://developers.cloudflare.com/workers/runtime-apis/durable-objects/\n\t  // MY_DURABLE_OBJECT: DurableObjectNamespace;\n\t  //\n\t  // Example binding to R2. Learn more at https://developers.cloudflare.com/workers/runtime-apis/r2/\n\t  // MY_BUCKET: R2Bucket;\n", "  //\n\t  // Example binding to a Service. Learn more at https://developers.cloudflare.com/workers/runtime-apis/service-bindings/\n\t  // MY_SERVICE: Fetcher;\n\t  //\n\t  // Example binding to a Queue. Learn more at https://developers.cloudflare.com/queues/javascript-apis/\n\t  // MY_QUEUE: Queue;\n\t  FOO: string\n\t}\n\texport default {\n\t  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n", "    const router = new Router<Env>()\n\t    router.get('/', async ({ request }) => {\n\t      return new Response('Hello World!')\n\t    })\n\t    router.post('/books', async ({ request }) => {\n\t      const data = await request.body()\n\t      return json({ data })\n\t    })\n\t    const MyHandler: RouteHandler<Env> = async ({ params }) => {\n\t      const bookId = params?.id\n", "      return json({ bookId })\n\t    }\n\t    router.get('/books/:id', MyHandler)\n\t    return router.handle(request, env, ctx) ?? new Response('Not Found', { status: 404 })\n\t  },\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { BasicRequest } from './request'\n\texport type RouteMatcher = (\n\t  request: BasicRequest\n\t) => { params: Record<string, string> } | undefined\n\texport type RouteOptions<Env> = {\n\t  request: BasicRequest\n\t  env: Env\n\t  ctx: ExecutionContext\n\t  params?: Record<string, string>\n\t}\n", "export type RouteHandler<Env> = (\n\t  options: RouteOptions<Env>\n\t) => Promise<Response>\n\texport type ZodRouteHandler<Env, Schema> = (\n\t  options: RouteOptions<Env> & { data: Schema }\n\t) => Promise<Response>\n\texport type Route<Env> = [RouteMatcher, RouteHandler<Env>]\n\texport enum RequestMethodEnum {\n\t  options = 'options',\n\t  head = 'head',\n", "  get = 'get',\n\t  post = 'post',\n\t  put = 'put',\n\t  delete = 'delete',\n\t  patch = 'patch',\n\t}\n\texport type RequestMethod = keyof typeof RequestMethodEnum\n"]}
{"filename": "src/response.ts", "chunked_list": ["/**\n\t * Shorthand for creating a JSON response with an error message.\n\t *\n\t * @param message error message\n\t * @param options {\n\t *  type: error type, defaults to 'invalid_request'\n\t *  status: status code, defaults to 400\n\t * }\n\t * @returns Response\n\t */\n", "export function error(\n\t  message: string,\n\t  { type = 'invalid_request', status = 400 } = {}\n\t) {\n\t  return json({ error: { message, type } }, status)\n\t}\n\t/**\n\t * A shortcut for creating a JSON response.\n\t *\n\t * @param data An object to be JSON stringified.\n", " * @param status optional status code, defaults to 200\n\t * @returns Response\n\t */\n\texport function json(data: any, status = 200) {\n\t  return new Response(JSON.stringify(data, null, 2), {\n\t    status,\n\t    headers: {\n\t      'content-type': 'application/json;charset=UTF-8',\n\t    },\n\t  })\n", "}\n"]}
{"filename": "src/cookie.ts", "chunked_list": ["/**\n\t *\n\t *  Parses a cookie string and returns an object containing the key-value pairs.\n\t *  @param {string} cookieString - A string containing the cookies in the \"key=value; key2=value2\" format.\n\t *  @returns {Record<string, string>} - An object containing the key-value pairs of the cookies.\n\t *  @example\n\t *  const cookieString = \"name=John; age=25; city=New York\";\n\t *  parseCookie(cookieString) //=> { name: \"John\", age: \"25\", city: \"New York\" }\n\t **/\n\texport function parseCookie(cookieString: string): Record<string, string> {\n", "  const cookies = cookieString.split(';')\n\t  const result: Record<string, string> = {}\n\t  for (const cookie of cookies) {\n\t    const [name, value] = cookie.split('=')\n\t    result[name.trim()] = decodeURIComponent(value)\n\t  }\n\t  return result\n\t}\n\tinterface StringifyOptions {\n\t  value: string\n", "  maxage: number\n\t  expires: Date\n\t  samesite: 'Lax' | 'Strict' | 'None'\n\t  secure: boolean\n\t  httponly: boolean\n\t  domain: string\n\t  path: string\n\t}\n\t/**\n\t *\n", " *  Stringifies a cookie, including its name, value, and options.\n\t *  @param {string} name - The name of the cookie.\n\t *  @param {string} value - The value of the cookie.\n\t *  @param {Partial} [options={}] - An object containing optional cookie attributes:\n\t *  @param {string} options.value - The value of the cookie.\n\t *  @param {number} options.maxage - The maximum age of the cookie (in seconds).\n\t *  @param {Date} options.expires - The expiration date of the cookie.\n\t *  @param {'Lax' | 'Strict' | 'None'} options.samesite - The SameSite attribute of the cookie.\n\t *  @param {boolean} options.secure - Whether the cookie should be sent only over HTTPS.\n\t *  @param {boolean} options.httponly - Whether the cookie should be HTTP-only.\n", " *  @param {string} options.domain - The domain of the cookie.\n\t *  @param {string} options.path - The path of the cookie.\n\t *  @returns {string} The stringified cookie.\n\t *\n\t *  @example\n\t *\n\t *  stringifyCookie('name', 'John', {\n\t *    maxage: 60 * 60 * 24 * 365, // 1 year\n\t *  }) //=> \"name=John; Max-Age=31536000\"\n\t *\n", " **/\n\texport function stringifyCookie(\n\t  name: string,\n\t  value: string,\n\t  options: Partial<StringifyOptions> = {}\n\t): string {\n\t  let str = name + '=' + encodeURIComponent(value)\n\t  if (options.expires) {\n\t    str += '; Expires=' + new Date(options.expires).toUTCString()\n\t  }\n", "  if (options.maxage != null && options.maxage >= 0) {\n\t    str += '; Max-Age=' + (options.maxage | 0)\n\t  }\n\t  if (options.domain) {\n\t    str += '; Domain=' + options.domain\n\t  }\n\t  if (options.path) {\n\t    str += '; Path=' + options.path\n\t  }\n\t  if (options.samesite) {\n", "    str += '; SameSite=' + options.samesite\n\t  }\n\t  if (options.secure || options.samesite === 'None') {\n\t    str += '; Secure'\n\t  }\n\t  if (options.httponly) {\n\t    str += '; HttpOnly'\n\t  }\n\t  return str\n\t}\n"]}
{"filename": "src/router.ts", "chunked_list": ["import { BasicRequest } from './request'\n\timport { RequestMethod, Route, RouteHandler } from './types'\n\texport class Router<Env> {\n\t  routes: Route<Env>[] = []\n\t  /**\n\t   * Handles a request by matching it against the registered routes.\n\t   * @param request Request\n\t   * @param env Environment\n\t   * @param ctx Context (for Workers)\n\t   * @returns Response\n", "   **/\n\t  handle(rawRequest: Request, env: Env, ctx: ExecutionContext) {\n\t    const request = new BasicRequest(rawRequest)\n\t    for (const route of this.routes) {\n\t      const match = route[0](request)\n\t      if (match) {\n\t        return route[1]({ request, env, ctx, params: match.params })\n\t      }\n\t    }\n\t    const match = this.routes.find(([matcher]) => matcher(request))\n", "    if (match) {\n\t      return match[1]({ request, env, ctx })\n\t    }\n\t  }\n\t  /**\n\t   * Registers a new route.\n\t   * @param handler RouteHandler\n\t   * @param path Path to match\n\t   * @param method HTTP method to match\n\t   *\n", "   * @example\n\t   * const router = new Router<Env>()\n\t   *\n\t   * router.register(async ({ request }) => {\n\t   *  return new Response('ok')\n\t   * }, '/test')\n\t   */\n\t  register(handler: RouteHandler<Env>, path: string, method?: RequestMethod) {\n\t    const urlPattern = new URLPattern({ pathname: path })\n\t    this.routes.push([\n", "      (request) => {\n\t        if (!method || request.method === method) {\n\t          const match = urlPattern.exec({\n\t            pathname: request.url.pathname,\n\t          })\n\t          if (match) {\n\t            return { params: match.pathname.groups }\n\t          }\n\t        }\n\t      },\n", "      handler,\n\t    ])\n\t  }\n\t  options(path: string, handler: RouteHandler<Env>) {\n\t    this.register(handler, path, 'options')\n\t  }\n\t  head(path: string, handler: RouteHandler<Env>) {\n\t    this.register(handler, path, 'head')\n\t  }\n\t  /**\n", "   * Register a new GET route.\n\t   * @param path\n\t   * @param handler\n\t   *\n\t   * @example\n\t   * const router = new Router<Env>()\n\t   *\n\t   * router.get('/test', async ({ request }) => {\n\t   *  return new Response('ok')\n\t   * })\n", "   */\n\t  get(path: string, handler: RouteHandler<Env>) {\n\t    this.register(handler, path, 'get')\n\t  }\n\t  post(path: string, handler: RouteHandler<Env>) {\n\t    this.register(handler, path, 'post')\n\t  }\n\t  put(path: string, handler: RouteHandler<Env>) {\n\t    this.register(handler, path, 'put')\n\t  }\n", "  patch(path: string, handler: RouteHandler<Env>) {\n\t    this.register(handler, path, 'patch')\n\t  }\n\t  delete(path: string, handler: RouteHandler<Env>) {\n\t    this.register(handler, path, 'delete')\n\t  }\n\t  /**\n\t   * Registers a new route for all HTTP methods.\n\t   * @param path\n\t   * @param handler\n", "   */\n\t  all(path: string, handler: RouteHandler<Env>) {\n\t    this.register(handler, path)\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './cookie'\n\texport * from './request'\n\texport * from './response'\n\texport * from './router'\n\texport * from './types'\n\texport * from './middleware/zod-validation'\n"]}
{"filename": "src/request.ts", "chunked_list": ["import { parseCookie } from './cookie'\n\timport { RequestMethod, RequestMethodEnum } from './types'\n\timport { enumFromString } from './utils/enum'\n\timport { toObject } from './utils/to-object'\n\texport class BasicRequest {\n\t  url: URL\n\t  constructor(public request: Request) {\n\t    this.url = new URL(request.url)\n\t  }\n\t  /**\n", "   * Returns the request method as a lowercase string.\n\t   */\n\t  get method(): RequestMethod {\n\t    return enumFromString<RequestMethodEnum>(\n\t      RequestMethodEnum,\n\t      this.request.method.toLowerCase()\n\t    )\n\t  }\n\t  /**\n\t   * Returns the cookies sent by the client.\n", "   */\n\t  get cookies(): Record<string, string> {\n\t    const cookieString = this.headers.get('cookie')\n\t    if (!cookieString) {\n\t      return {}\n\t    }\n\t    return parseCookie(cookieString)\n\t  }\n\t  /**\n\t   * Returns the query parameters sent by the client.\n", "   */\n\t  get query() {\n\t    return toObject(this.url.searchParams)\n\t  }\n\t  get headers() {\n\t    return this.request.headers\n\t  }\n\t  get origin() {\n\t    return this.url.origin\n\t  }\n", "  /**\n\t   * A helper to parse the request body.\n\t   * @returns {Promise<T>} The parsed request body as an object.\n\t   */\n\t  async body<T>(): Promise<T | undefined> {\n\t    const ct = this.contentType\n\t    const rq = this.request\n\t    if (!rq.body || !ct) {\n\t      return\n\t    }\n", "    if (~ct.indexOf('application/json')) {\n\t      return rq.json() as Promise<T>\n\t    }\n\t    if (~ct.indexOf('multipart/form-data')) {\n\t      return rq.formData().then(toObject) as Promise<T>\n\t    }\n\t    if (~ct.indexOf('application/x-www-form-urlencoded')) {\n\t      return rq.formData().then(toObject) as Promise<T>\n\t    }\n\t    return\n", "  }\n\t  /**\n\t   * Returns the content type of the request.\n\t   */\n\t  get contentType() {\n\t    return this.request.headers.get('content-type')\n\t  }\n\t}\n"]}
{"filename": "src/router.test.ts", "chunked_list": ["import { describe, it, expect } from 'vitest'\n\timport { Router } from './router'\n\timport 'urlpattern-polyfill'\n\tdescribe('router', () => {\n\t  type Env = {\n\t    foo: string\n\t  }\n\t  it('handles routes', async () => {\n\t    const router = new Router<Env>()\n\t    router.register(async ({ request }) => {\n", "      expect(request.url.href).toBe('https://example.com/test')\n\t      return new Response('ok')\n\t    }, '/test')\n\t    const response = await router.handle(\n\t      new Request('https://example.com/test'),\n\t      { foo: 'bar' },\n\t      {} as any\n\t    )\n\t    expect(response?.status).toBe(200)\n\t  })\n", "  it('handles post routes', async () => {\n\t    const router = new Router<Env>()\n\t    router.post('/test', async ({ request }) => {\n\t      expect(request.url.href).toBe('https://example.com/test')\n\t      return new Response('ok')\n\t    })\n\t    const response = await router.handle(\n\t      new Request('https://example.com/test', { method: 'POST' }),\n\t      { foo: 'bar' },\n\t      {} as any\n", "    )\n\t    expect(response?.status).toBe(200)\n\t  })\n\t})\n"]}
{"filename": "src/request.test.ts", "chunked_list": ["import { describe, it, expect } from 'vitest'\n\timport { BasicRequest } from './request'\n\tdescribe('request', () => {\n\t  it('parses query params', () => {\n\t    const request = new BasicRequest(\n\t      new Request('https://example.com/test?foo=bar')\n\t    )\n\t    expect(request.query).toEqual({ foo: 'bar' })\n\t  })\n\t  it('parses cookies', () => {\n", "    const request = new BasicRequest(\n\t      new Request('https://example.com/test', {\n\t        headers: {\n\t          cookie: 'foo=bar',\n\t        },\n\t      })\n\t    )\n\t    expect(request.cookies).toEqual({ foo: 'bar' })\n\t  })\n\t  it('parses headers', () => {\n", "    const request = new BasicRequest(\n\t      new Request('https://example.com/test', {\n\t        headers: {\n\t          'content-type': 'application/json',\n\t        },\n\t      })\n\t    )\n\t    expect(request.headers.get('content-type')).toBe('application/json')\n\t  })\n\t  it('parses origin', () => {\n", "    const request = new BasicRequest(\n\t      new Request('https://example.com/test', {\n\t        headers: {\n\t          'content-type': 'application/json',\n\t        },\n\t      })\n\t    )\n\t    expect(request.origin).toBe('https://example.com')\n\t  })\n\t  it('parses json', async () => {\n", "    const request = new BasicRequest(\n\t      new Request('https://example.com/test', {\n\t        method: 'POST',\n\t        headers: {\n\t          'content-type': 'application/json',\n\t        },\n\t        body: JSON.stringify({ foo: 'bar' }),\n\t      })\n\t    )\n\t    expect(await request.body()).toEqual({ foo: 'bar' })\n", "  })\n\t  it('parses forms', async () => {\n\t    const request = new BasicRequest(\n\t      new Request('https://example.com/test', {\n\t        method: 'POST',\n\t        headers: {\n\t          'content-type': 'application/x-www-form-urlencoded',\n\t        },\n\t        body: 'foo=bar',\n\t      })\n", "    )\n\t    expect(await request.body()).toEqual({ foo: 'bar' })\n\t  })\n\t})\n"]}
{"filename": "src/utils/enum.ts", "chunked_list": ["/**\n\t * Converts string to enum. Returns undefined if enum doesn't contain the value.\n\t *\n\t */\n\texport function enumFromString<T>(\n\t  enm: { [s: string]: T },\n\t  value: string | undefined | null\n\t): T {\n\t  if (!value) {\n\t    throw new Error('Value is undefined or null')\n", "  }\n\t  const validValues = Object.values(enm) as unknown as string[]\n\t  const isValid = validValues.includes(value)\n\t  if (isValid) {\n\t    return value as unknown as T\n\t  } else {\n\t    throw new Error(`Invalid value: ${value}`)\n\t  }\n\t}\n"]}
{"filename": "src/utils/to-object.ts", "chunked_list": ["// Taken from https://github.com/lukeed/worktop/tree/master\n\t// MIT License Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)\n\ttype Arrayable<T> = T | Array<T>\n\ttype DataObject = Record<string, Arrayable<FormDataEntryValue>>\n\texport function toObject(\n\t  iter: Headers | FormData | URLSearchParams\n\t): DataObject {\n\t  let key, val, tmp: Arrayable<FormDataEntryValue>\n\t  const out: DataObject = {}\n\t  for ([key, val] of iter) {\n", "    out[key] =\n\t      (tmp = out[key]) !== void 0\n\t        ? ([] as FormDataEntryValue[]).concat(tmp, val)\n\t        : val\n\t  }\n\t  return out\n\t}\n"]}
{"filename": "src/middleware/zod-validation.ts", "chunked_list": ["import z from 'zod'\n\timport { RouteOptions, ZodRouteHandler } from '../types'\n\timport { error } from '../response'\n\t/**\n\t * Creates a route handler that validates the request data and parameters using the Zod schema.\n\t * If validation fails, it returns a 400 json error with a detailed message.\n\t *\n\t * @param {z.Schema} schema - A Zod schema used to validate the incoming request data and parameters.\n\t * @param {ZodRouteHandler<Env, Schema>} callback - The main callback that will be executed after validation is successful.\n\t *\n", " * @return {ZodRouteHandler}\n\t *\n\t * @example\n\t * const schema = z.object({\n\t *   name: z.string(),\n\t * })\n\t *\n\t * type schemaType = z.infer<typeof schema>\n\t *\n\t * withZod<Env, schemaType>(schema, async (options) => {\n", " *  console.log(options.data) //=> { name: 'test' }\n\t *  return new Response('ok')\n\t * })\n\t *\n\t */\n\texport function withZod<Env, Schema>(\n\t  schema: z.Schema,\n\t  callback: ZodRouteHandler<Env, Schema>\n\t) {\n\t  return async (options: RouteOptions<Env>) => {\n", "    const { request } = options\n\t    const queryParams = request.query\n\t    const bodyParams = (await request.body()) ?? {}\n\t    const existingParams = options.params ?? {}\n\t    const params = {\n\t      ...queryParams,\n\t      ...bodyParams,\n\t      ...existingParams,\n\t    }\n\t    const result = schema.safeParse(params)\n", "    if (!result.success) {\n\t      const firstError = result.error?.errors?.[0]\n\t      if (firstError) {\n\t        return error(`${firstError.path} ${firstError.message}`.toLowerCase(), {\n\t          type: firstError.code,\n\t          status: 400,\n\t        })\n\t      } else {\n\t        return error('invalid_request')\n\t      }\n", "    }\n\t    return callback({\n\t      ...options,\n\t      data: result.data,\n\t    })\n\t  }\n\t}\n"]}
{"filename": "src/middleware/zod-validation.test.ts", "chunked_list": ["import { describe, expect, it } from 'vitest'\n\timport { withZod } from './zod-validation'\n\timport { z } from 'zod'\n\timport { execRoute, buildRequest } from '../../test/helpers'\n\tdescribe('zod-validation', () => {\n\t  type Env = {\n\t    foo: string\n\t  }\n\t  const schema = z.object({\n\t    name: z.string(),\n", "  })\n\t  type schemaType = z.infer<typeof schema>\n\t  it('should pass through json', async () => {\n\t    const route = withZod<Env, schemaType>(schema, async (options) => {\n\t      expect(options.data).toEqual({ name: 'test' })\n\t      return new Response('ok')\n\t    })\n\t    const response = await execRoute(\n\t      route,\n\t      buildRequest('https://example.com', {\n", "        method: 'POST',\n\t        headers: { 'content-type': 'application/json' },\n\t        body: JSON.stringify({ name: 'test' }),\n\t      })\n\t    )\n\t    expect(response.status).toBe(200)\n\t  })\n\t  it('should pass through query', async () => {\n\t    const route = withZod<Env, schemaType>(schema, async (options) => {\n\t      expect(options.data).toEqual({ name: 'test' })\n", "      return new Response('ok')\n\t    })\n\t    const response = await execRoute(\n\t      route,\n\t      buildRequest('https://example.com?name=test', {\n\t        method: 'GET',\n\t      })\n\t    )\n\t    expect(response.status).toBe(200)\n\t  })\n", "  it('should pass through form parms', async () => {\n\t    const route = withZod<Env, schemaType>(schema, async (options) => {\n\t      expect(options.data).toEqual({ name: 'test' })\n\t      return new Response('ok')\n\t    })\n\t    const response = await execRoute(\n\t      route,\n\t      buildRequest('https://example.com?name=test', {\n\t        method: 'POST',\n\t        headers: { 'content-type': 'application/x-www-form-urlencoded' },\n", "        body: 'name=test',\n\t      })\n\t    )\n\t    expect(response.status).toBe(200)\n\t  })\n\t  it('should should a validation error', async () => {\n\t    const route = withZod<Env, schemaType>(schema, async (options) => {\n\t      expect(options.data).toEqual({ bar: 'test' })\n\t      return new Response('ok')\n\t    })\n", "    const response = await execRoute(\n\t      route,\n\t      buildRequest('https://example.com', {\n\t        method: 'POST',\n\t        headers: { 'content-type': 'application/json' },\n\t        body: JSON.stringify({ bar: 'test' }),\n\t      })\n\t    )\n\t    expect(response.status).toBe(400)\n\t    expect(await response.json()).toMatchInlineSnapshot(`\n", "      {\n\t        \"error\": {\n\t          \"message\": \"name required\",\n\t          \"type\": \"invalid_type\",\n\t        },\n\t      }\n\t    `)\n\t  })\n\t})\n"]}
