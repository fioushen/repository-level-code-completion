{"filename": "src/output.ts", "chunked_list": ["import yaml from 'js-yaml';\n\timport* as fs from 'fs';\n\timport { Runner, Output } from './modules/types.js';\n\timport error from './modules/log.js';\n\tfunction constructReturn(runner: Runner): Output {\n\t    const output: Output = {\n\t        success: (runner.numberSuccess === runner.tests.length) ? true : false,\n\t        numberSuccess: runner.numberSuccess,\n\t        numberFail: runner.numberFail,\n\t        numberSkipped: runner.tests.length - runner.numberFail - runner.numberSuccess,\n", "        testResults: []\n\t    };\n\t    for (const test of runner.tests) {\n\t        output.testResults.push(test);\n\t    }\n\t    return output;\n\t}\n\texport function returnJson(runner: Runner): string {\n\t    return JSON.stringify(constructReturn(runner));\n\t}\n", "export function returnYaml(runner: Runner): string {\n\t    return yaml.dump(constructReturn(runner));\n\t}\n\tfunction print_end(runner: Runner): void {\n\t    if (runner.settings.verbose)\n\t        console.log(\"Finished Tests!\");\n\t    if (runner.settings.outputFormat == 'text')\n\t        console.log(`\\nTests Results\n\t->\\tSuccess: ${runner.numberSuccess}\\tFail: ${runner.numberFail} \\tSkipped: ${runner.tests.length - runner.numberFail - runner.numberSuccess}\\t<-`);\n\t}\n", "export default function createOutput(runner: Runner): void {\n\t    let output: string;\n\t    switch (runner.settings.outputFormat) {\n\t        case 'json':\n\t            output = returnJson(runner);\n\t            break;\n\t        case 'yaml':\n\t            output = returnYaml(runner);\n\t            break;\n\t        default:\n", "            print_end(runner);\n\t            break;\n\t    }\n\t    try {\n\t        if (output !== undefined)\n\t            fs.writeFileSync(runner.settings.output, output);\n\t    } catch (err) {\n\t        error(`Error writing to file: ${err}`);\n\t    }\n\t    if (runner.settings.status && runner.numberFail > 0)\n", "        process.exit(1);\n\t}\n"]}
{"filename": "src/runTests.ts", "chunked_list": ["import { Runner, Test, Out } from './modules/types.js';\n\timport runRefer from './runner/refer.js';\n\timport runExpect from './runner/expect.js';\n\timport yaml from 'js-yaml';\n\timport createOutput from './output.js';\n\tfunction print_expected(out: Out): void {\n\t    if (out.stdout !== undefined)\n\t        if (out.stdout.string !== undefined)\n\t            console.log(`Expected stdout: \"${out.stdout.string}\"`);\n\t        else if (out.stdout.regex !== undefined)\n", "            console.log(`stdout must match: /${out.stdout.regex}/`);\n\t    if (out.stderr !== undefined)\n\t        if (out.stderr.string !== undefined)\n\t            console.log(`Expected stderr: \"${out.stderr.string}\"`);\n\t        else if (out.stderr.regex !== undefined)\n\t            console.log(`stderr must match: /${out.stderr.regex}/`);\n\t    if (out.exitCode !== undefined)\n\t        console.log(`Expected exit code: ${out.exitCode}`);\n\t}\n\tfunction print_test_description(test: Test): void {\n", "    console.log(`Test ${test.id}: ${test.name}`);\n\t    console.log(`Test Command: $${test.command}`);\n\t    console.log(`Test type: [${test.testType}]`);\n\t    if (test.testType === 'refer')\n\t        console.log(`Refer Command: $${test.referCommand}`);\n\t    else {\n\t        print_expected(test.expected);\n\t    }\n\t}\n\tasync function runTest(runner: Runner, test: Test): Promise<void> {\n", "    if (runner.settings.verbose) {\n\t        print_test_description(test);\n\t    } else if (runner.settings.outputFormat == 'text') \n\t        process.stdout.write(`Test ${test.id}: ${test.name}... \\t`);\n\t    if (test.testType === 'refer')\n\t        await runRefer(runner, test);\n\t    else if (test.testType === 'expect')\n\t        await runExpect(runner, test);\n\t    if (runner.settings.verbose)\n\t        console.log('\\n');\n", "}\n\texport default async function runTests(runner: Runner): Promise<void> {\n\t    if (runner.settings.verbose) {\n\t        console.log(`Starting Tests for ${runner.testFilePath}...`);\n\t        console.log(`Settings: \\n${yaml.dump(runner.settings)}`);\n\t        console.log(\"Test Queue:\");\n\t        for (const test of runner.tests) {\n\t            if (runner.settings.runList.includes(test.id) || runner.settings.runList.length === 0)\n\t                console.log(`Test ${test.id}: ${test.name}`);\n\t        }\n", "    }\n\t    if (runner.settings.outputFormat == 'text')\n\t        console.log(\"Starting Tests...\\n\");\n\t    for (const test of runner.tests) {\n\t        if (runner.settings.runList.includes(test.id) || runner.settings.runList.length === 0) {\n\t            test.result = {\n\t                status: 'pending',\n\t                msg: 'In the queue',\n\t                result: {\n\t                    stdout: undefined,\n", "                    stderr: undefined,\n\t                    exitCode: undefined\n\t                },\n\t                timeTaken: undefined\n\t            };\n\t        } else {\n\t            test.result = {\n\t                status: 'skipped',\n\t                msg: 'Skipped by user',\n\t                result: {\n", "                    stdout: undefined,\n\t                    stderr: undefined,\n\t                    exitCode: undefined\n\t                },\n\t                timeTaken: undefined\n\t            };\n\t        }\n\t    }\n\t    for (const test of runner.tests) {\n\t        if (runner.settings.runList.includes(test.id) || runner.settings.runList.length === 0) {\n", "            test.result = {\n\t                status: 'pending',\n\t                msg: 'In the queue',\n\t                result: {\n\t                    stdout: undefined,\n\t                    stderr: undefined,\n\t                    exitCode: undefined\n\t                },\n\t                timeTaken: undefined\n\t            };\n", "            await runTest(runner, test);\n\t        }\n\t    }\n\t    createOutput(runner);\n\t}\n"]}
{"filename": "src/binaryTester.ts", "chunked_list": ["import argsHandler from './argsHandler.js';\n\timport runTests from './runTests.js';\n\texport async function cli(): Promise<void> {\n\t    runTests((await argsHandler(process.argv.slice(2))));\n\t}\n"]}
{"filename": "src/argsHandler.ts", "chunked_list": ["import help from './modules/help.js';\n\timport error from './modules/log.js';\n\timport { Runner } from './modules/types.js';\n\timport parseYaml from './fileParsing/yaml.js';\n\timport parseJson from './fileParsing/json.js';\n\tasync function parseArguments(args: string[]): Promise<Runner> {\n\t    let runner: Runner = {\n\t        testFilePath: '',\n\t        tests: [],\n\t        settings: {\n", "            output: 'stdout',\n\t            outputFormat: 'text',\n\t            timeout: 0,\n\t            verbose: false,\n\t            status: false,\n\t            runList: [],\n\t            stopWhenFail: false,\n\t        },\n\t        numberSuccess: 0,\n\t        numberFail: 0,\n", "    };\n\t    for (let i = 0; i < args.length; i++) {\n\t        switch (args[i]) {\n\t            case '-o': case '--output':\n\t                if (args[i + 1] === undefined)\n\t                    error(\"Invalid output (must be 'file [json or yaml]')\");\n\t                runner.settings.output = args[i + 1];\n\t                runner.settings.outputFormat = 'yaml';\n\t                if (args[i + 1].endsWith('.json'))\n\t                    runner.settings.outputFormat = 'json';\n", "                i++;\n\t                break;\n\t            case '-t': case '--timeout':\n\t                if (args[i + 1] === undefined || isNaN(parseInt(args[i + 1])) || parseInt(args[i + 1]) < 0)\n\t                    error('Invalid timeout');\n\t                runner.settings.timeout = parseInt(args[i + 1]);\n\t                i++;\n\t                break;\n\t            case '-v': case '--verbose':\n\t                runner.settings.verbose = true;\n", "                break;\n\t            case '-s': case '--status':\n\t                runner.settings.status = true;\n\t                break;\n\t            case '-swf': case '--stop-when-fail':\n\t                runner.settings.stopWhenFail = true;\n\t                break;\n\t            case '-r': case '--runList':\n\t                if (args[i + 1] === undefined || args[i + 1].split(',').some((x) => isNaN(parseInt(x))))\n\t                    error('Invalid run list');\n", "                runner.settings.runList = args[i + 1].split(',').map((x) => parseInt(x));\n\t                i++;\n\t                break;\n\t            case '-h': case '--help':\n\t                help();\n\t                process.exit(0);\n\t            default:\n\t                if (args[i].startsWith('-') || args[i].startsWith('--'))\n\t                    error(`Invalid argument: ${args[i]}`);\n\t                runner.testFilePath = args[i];\n", "                break;\n\t        }\n\t    }\n\t    if (runner.testFilePath === '') {\n\t        help();\n\t        process.exit(1);\n\t    }\n\t    if (runner.testFilePath.endsWith('.yaml') || runner.testFilePath.endsWith('.yml'))\n\t        runner = await parseYaml(runner);\n\t    else if (runner.testFilePath.endsWith('.json'))\n", "        runner = await parseJson(runner);\n\t    return runner;\n\t}\n\texport default parseArguments;\n\texport { parseArguments };"]}
{"filename": "src/fileParsing/yaml.ts", "chunked_list": ["import* as fs from 'fs';\n\timport* as yaml from 'js-yaml';\n\timport error from '../modules/log.js';\n\timport { Runner, Test, Out } from '../modules/types.js';\n\timport parse from './parse.js';\n\texport default async function parseYaml(runner: Runner): Promise<Runner> {\n\t    let data = fs.readFileSync(runner.testFilePath, 'utf8');\n\t    if (!data) error(`Error reading file from disk: ${runner.testFilePath}`);\n\t    try {\n\t        return await parse(runner, yaml.load(data));\n", "    } catch(e) {\n\t        error(`Error parsing YAML: ${e}`);\n\t    }\n\t}\n"]}
{"filename": "src/fileParsing/json.ts", "chunked_list": ["import* as fs from 'fs';\n\timport error from '../modules/log.js';\n\timport { Runner, Test, Out } from '../modules/types.js';\n\timport parse from './parse.js';\n\texport default async function parseYaml(runner: Runner): Promise<Runner> {\n\t    let data = fs.readFileSync(runner.testFilePath, 'utf8');\n\t    if (!data) error(`Error reading file from disk: ${runner.testFilePath}`);\n\t    try {\n\t        return await parse(runner, JSON.parse(data));\n\t    } catch(e) {\n", "        error(`Error parsing JSON: ${e}`);\n\t    }\n\t}\n"]}
{"filename": "src/fileParsing/parse.ts", "chunked_list": ["import* as fs from 'fs';\n\timport error from '../modules/log.js';\n\timport { Runner, Test, Out } from '../modules/types.js';\n\tfunction parseOut(test: any): Out {\n\t    let expected: Out = {\n\t        stdout: undefined,\n\t        stderr: undefined,\n\t        exitCode: undefined\n\t    }\n\t    if (test.stdout)\n", "        expected.stdout = test.stdout;\n\t    if (test.stderr)\n\t        expected.stderr = test.stderr;\n\t    if (test.exitCode !== undefined)\n\t        expected.exitCode = test.exitCode;\n\t    return expected;\n\t}\n\texport default async function parse(runner: Runner, doc: any): Promise<Runner> {\n\t    const tests: Test[] = [];\n\t    try {\n", "        let testId = 0;\n\t        for (const test of doc.Tests) {\n\t            testId++;\n\t            const testObj: Test = {\n\t                id: testId,\n\t                name: test.name,\n\t                description: test.description,\n\t                command: test.command,\n\t                testType: test.testType,\n\t                referCommand: undefined,\n", "                expected: undefined,\n\t                result: undefined\n\t            };\n\t            if (test.testType === 'refer')\n\t                testObj.referCommand = test.referCommand;\n\t            else if (test.testType === \"expect\")\n\t                testObj.expected = parseOut(test.expected);\n\t            else\n\t                throw new Error(`Invalid testType or comparsionType in test ${testObj.id}`);\n\t            tests.push(testObj);\n", "        }\n\t    } catch(e) {\n\t        error(`Error parsing: ${e}`);\n\t    }\n\t    runner.tests = tests;\n\t    return runner;\n\t}\n"]}
{"filename": "src/runner/expect.ts", "chunked_list": ["import {Runner, Test, Out} from '../modules/types.js';\n\timport { spawnSync, SpawnSyncReturns } from 'child_process';\n\timport jobError from './jobError.js';\n\tfunction compareStatus(run: Number, test: Test): Boolean {\n\t    if (test.expected.exitCode === undefined) {\n\t        return true;\n\t    }\n\t    return run === test.expected.exitCode;\n\t}\n\tfunction compareStdout(run: string, test: Test): Boolean {\n", "    if (test.expected.stdout === undefined || (test.expected.stdout.string === undefined && test.expected.stdout.regex === undefined)) {\n\t        return true;\n\t    }\n\t    if (test.expected.stdout.string !== undefined && test.expected.stdout.string === run)\n\t        return true;\n\t    if (test.expected.stdout.regex !== undefined) {\n\t        let reg = new RegExp(test.expected.stdout.regex);\n\t        return reg.test(run);\n\t    }\n\t}\n", "function compareStderr(run: string, test: Test): Boolean {\n\t    if (test.expected.stderr === undefined || (test.expected.stderr.string === undefined && test.expected.stderr.regex === undefined)) {\n\t        return true;\n\t    }\n\t    if (test.expected.stderr.string !== undefined && test.expected.stderr.string === run)\n\t        return true;\n\t    if (test.expected.stderr.regex !== undefined) {\n\t        let reg = new RegExp(test.expected.stderr.regex);\n\t        return reg.test(run);\n\t    }\n", "}\n\tasync function runExpect(runner: Runner, test: Test): Promise<void> {\n\t    let startTime = Date.now();\n\t    let run: SpawnSyncReturns<Buffer> = spawnSync(test.command, {\n\t        timeout: runner.settings.timeout,\n\t        shell: true\n\t    });\n\t    let endTime = Date.now();\n\t    if (runner.settings.verbose) {\n\t        console.log(`Run stdout: \"${run.stdout}\"`);\n", "        console.log(`Run stderr: \"${run.stderr}\"`);\n\t        console.log(`Run exit code: ${run.status}`);\n\t    }\n\t    test.result = {\n\t        status: 'success',\n\t        msg: 'OK',\n\t        result: {\n\t            stdout: run.stdout.toString(),\n\t            stderr: run.stderr.toString(),\n\t            exitCode: run.status\n", "        },\n\t        timeTaken: endTime - startTime\n\t    };\n\t    if (test.result.timeTaken > runner.settings.timeout && runner.settings.timeout !== 0) {\n\t        return jobError(runner, test, `Test timed out after ${test.result.timeTaken}ms`);\n\t    }\n\t    if (!compareStatus(run.status, test)) {\n\t        return jobError(runner, test, `Expected exit code ${test.expected.exitCode} but got ${run.status}`);\n\t    }\n\t    if (!compareStdout(run.stdout.toString(), test)) {\n", "        return jobError(runner, test, `Expected stdout not match with run stdout`);\n\t    }\n\t    if (!compareStderr(run.stderr.toString(), test)) {\n\t        return jobError(runner, test, `Expected stderr not match with run stderr`);\n\t    }\n\t    runner.numberSuccess++;\n\t    if (runner.settings.outputFormat === 'text')\n\t        console.log(`OK`);\n\t}\n\texport default runExpect;\n"]}
{"filename": "src/runner/jobError.ts", "chunked_list": ["import {Runner, Test, Out} from '../modules/types.js';\n\timport createOutput from '../output.js';\n\texport default function jobError(runner: Runner, test: Test, msg: string): void {\n\t    test.result.status = 'fail';\n\t    test.result.msg = msg;\n\t    if (runner.settings.outputFormat === 'text') {\n\t        console.log(`Failed: ${msg}`);\n\t    }\n\t    runner.numberFail++;\n\t    if (runner.settings.stopWhenFail) {\n", "        if (runner.settings.outputFormat === 'text') {\n\t            console.log(\"You have chosen to stop when a test fails.\");\n\t            console.log(\"Stopping Tests...\");\n\t        }\n\t        for (const test of runner.tests) {\n\t            if (test.result.status === 'pending') {\n\t                test.result.status = 'skipped';\n\t                test.result.msg = 'Skipped: Test stopped due to previous failure';\n\t            }\n\t        }\n", "        createOutput(runner);\n\t        if (runner.settings.status)\n\t            process.exit(1);\n\t        else\n\t            process.exit(0);\n\t    }\n\t}\n"]}
{"filename": "src/runner/refer.ts", "chunked_list": ["import {Runner, Test, Out} from '../modules/types.js';\n\timport { spawnSync, SpawnSyncReturns } from 'child_process';\n\timport jobError from './jobError.js';\n\tasync function runRefer(runner: Runner, test: Test): Promise<void> {\n\t    let startTime = Date.now();\n\t    let run: SpawnSyncReturns<Buffer> = spawnSync(test.command, {\n\t        timeout: runner.settings.timeout,\n\t        shell: true\n\t    });\n\t    let endTime = Date.now();\n", "    let ref: SpawnSyncReturns<Buffer> = spawnSync(test.referCommand, {\n\t        timeout: runner.settings.timeout,\n\t        shell: true\n\t    });\n\t    if (runner.settings.verbose) {\n\t        console.log(`Run stdout: \"${run.stdout}\"`);\n\t        console.log(`Run stderr: \"${run.stderr}\"`);\n\t        console.log(`Refer stdout: \"${ref.stdout}\"`);\n\t        console.log(`Refer stderr: \"${ref.stderr}\"`);\n\t        console.log(`Run exit code: ${run.status}`);\n", "        console.log(`Refer exit code: ${ref.status}`);\n\t    }\n\t    test.result = {\n\t        status: 'success',\n\t        msg: 'OK',\n\t        result: {\n\t            stdout: run.stdout.toString(),\n\t            stderr: run.stderr.toString(),\n\t            exitCode: run.status\n\t        },\n", "        timeTaken: endTime - startTime\n\t    };\n\t    if (test.result.timeTaken > runner.settings.timeout && runner.settings.timeout !== 0) {\n\t        return jobError(runner, test, `Test timed out after ${test.result.timeTaken}ms`);\n\t    }\n\t    if (run.status !== ref.status) {\n\t        return jobError(runner, test, `Expected exit code ${test.expected.exitCode} but got ${run.status}`);\n\t    }\n\t    if (run.stdout.toString() !== ref.stdout.toString()) {\n\t        return jobError(runner, test, `Expected stdout not match with run stdout`);\n", "    }\n\t    if (run.stderr.toString() !== ref.stderr.toString()) {\n\t        return jobError(runner, test, `Expected stderr not match with run stderr`);\n\t    }\n\t    runner.numberSuccess++;\n\t    if (runner.settings.outputFormat === 'text')\n\t        console.log(`OK`);\n\t}\n\texport default runRefer;"]}
{"filename": "src/modules/types.ts", "chunked_list": ["export type Match = {\n\t    string: string;\n\t    regex: string;\n\t}\n\texport type Out = {\n\t    stdout: Match;\n\t    stderr: Match;\n\t    exitCode: number;\n\t}\n\texport type Result = {\n", "    status: 'success' | 'fail' | 'skipped' | 'pending';\n\t    msg: string;\n\t    result: {\n\t        stdout: string;\n\t        stderr: string;\n\t        exitCode: number;\n\t    };\n\t    timeTaken: number;\n\t}\n\texport type Test = {\n", "    id: number;\n\t    name: string;\n\t    description: string;\n\t    command: string;\n\t    testType: 'refer' | 'expect';\n\t    referCommand: string;\n\t    expected: Out;\n\t    result: Result;\n\t}\n\texport type Settings = {\n", "    output: string;\n\t    outputFormat: string;\n\t    timeout: number;\n\t    verbose: boolean;\n\t    status: boolean;\n\t    runList: Array<number>;\n\t    stopWhenFail: boolean;\n\t}\n\texport type Runner = {\n\t    testFilePath: string;\n", "    tests: Array<Test>;\n\t    settings: Settings;\n\t    numberSuccess: number;\n\t    numberFail: number;\n\t}\n\texport type Output = {\n\t    success: boolean;\n\t    numberSuccess: number;\n\t    numberFail: number;\n\t    numberSkipped: number;\n", "    testResults: Array<Test>;\n\t}\n"]}
{"filename": "src/modules/log.ts", "chunked_list": ["function error(message: string): void {\n\t    process.stderr.write(message);\n\t    process.stderr.write('\\n');\n\t    process.exit(1);\n\t}\n\texport default error;"]}
{"filename": "src/modules/help.ts", "chunked_list": ["function help(): void {\n\t    process.stdout.write(`Usage ${process.argv[1].split(\"/\").slice(-1)} [options] [file]`);\n\t    process.stdout.write(`\\n\\n`);\n\t    process.stdout.write(`Options:\\n`);\n\t    process.stdout.write(`\\t-o, --output [file (json or yaml)]\\t`);\n\t    process.stdout.write(`Output format (default: text)\\n`);\n\t    process.stdout.write(`\\t-swf, --stop-when-fail\\t`);\n\t    process.stdout.write(`Stop when a test fails (default: false)\\n`);\n\t    process.stdout.write(`\\t-t, --timeout [number]\\t`);\n\t    process.stdout.write(`Timeout in milliseconds (default: -1)\\n`);\n", "    process.stdout.write(`\\t-v, --verbose\\t`);\n\t    process.stdout.write(`Verbose output (default: false)\\n`);\n\t    process.stdout.write(`\\t-s, --status\\t`);\n\t    process.stdout.write(`Show status (default: false)\\n`);\n\t    process.stdout.write(`\\t-r, --runList [number,number,...]\\t`);\n\t    process.stdout.write(`Run only specified tests (default: [])\\n`);\n\t    process.stdout.write(`\\t-h, --help\\t`);\n\t    process.stdout.write(`Show this help message\\n`);\n\t    process.stdout.write(`\\n`);\n\t}\n", "export default help;\n"]}
