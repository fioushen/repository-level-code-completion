{"filename": "jest.config.ts", "chunked_list": ["import { JestConfigWithTsJest } from 'ts-jest';\n\texport default {\n\t  preset: 'ts-jest',\n\t  testEnvironment: 'node',\n\t} as JestConfigWithTsJest;\n"]}
{"filename": "src/utils/Nominal.ts", "chunked_list": ["const nominalField = '_nominal_';\n\tconst baseTypeField = '_baseType_';\n\t/**\n\t * An alias for creating a nominal type\n\t */\n\texport type Nominal<Type, Identifier> = Type &\n\t  { readonly [nominalField]: Identifier } &\n\t  { readonly [baseTypeField]: Type };\n\t/**\n\t * Alias returns base type of Nominal\n", " */\n\ttype Base<N extends Nominal<unknown, unknown>> = N[typeof baseTypeField];\n\t/**\n\t * Asserts type to a value\n\t *\n\t * @param value - value to assert a type\n\t */\n\tconst assertType = <N extends Nominal<unknown, unknown>>(value: Base<N>): N => value as N;\n\t/**\n\t * Generic function returns assertType function with Nominal type\n", " */\n\texport const create = <N extends Nominal<unknown, unknown>>(): typeof assertType<N> => assertType<N>;\n"]}
{"filename": "src/utils/mocks/createValueNodeMock.ts", "chunked_list": ["import { ValueNode } from '../../entities/ValueNode';\n\timport type { ValueNodeConstructorParameters } from '../../entities/ValueNode';\n\t/**\n\t * Creates a mock ValueNode instance.\n\t *\n\t * @param args - ValueNode constructor arguments.\n\t * @param args.value - The value of this value node.\n\t */\n\texport function createValueNodeMock({ value }: ValueNodeConstructorParameters): ValueNode {\n\t  return new ValueNode({\n", "    value,\n\t  });\n\t}\n"]}
{"filename": "src/utils/mocks/createBlockTuneMock.ts", "chunked_list": ["import { BlockTune, BlockTuneName, createBlockTuneName } from '../../entities/BlockTune';\n\t/**\n\t * Creates a BlockTune instance with the given name and data.\n\t *\n\t * @param args - BlockTune constructor arguments.\n\t * @param args.name - The name of the tune.\n\t * @param args.data - Any additional data associated with the tune.\n\t */\n\texport function createBlockTuneMock({ name, data }: {\n\t  name?: BlockTuneName,\n", "  data?: Record<string, unknown>,\n\t}): BlockTune {\n\t  return new BlockTune(\n\t    {\n\t      name: name || createBlockTuneName('aligning'),\n\t      data: data || {},\n\t    }\n\t  );\n\t}\n"]}
{"filename": "src/utils/mocks/createEditorDocumentMock.ts", "chunked_list": ["import { EditorDocument } from '../../entities/EditorDocument';\n\t/**\n\t * Creates an EditorDocument object for tests.\n\t */\n\texport function createEditorDocumentMock(): EditorDocument {\n\t  return new EditorDocument({\n\t    children: [],\n\t    properties: {\n\t      readOnly: false,\n\t    },\n", "  });\n\t}\n"]}
{"filename": "src/utils/mocks/createBlockNodeMock.ts", "chunked_list": ["import { BlockNode, BlockNodeName, createBlockNodeName } from '../../entities/BlockNode';\n\timport { EditorDocument } from '../../entities/EditorDocument';\n\timport { BlockNodeData } from '../../entities/BlockNode/types';\n\timport { BlockTune, BlockTuneName } from '../../entities/BlockTune';\n\t/**\n\t * Creates a BlockNode with the specified name and adds it to the specified parent.\n\t *\n\t * @param args - The arguments to pass to the BlockNode constructor.\n\t * @param args.name - The name of the BlockNode.\n\t * @param args.parent - The parent of the BlockNode.\n", " */\n\texport function createBlockNodeMock({ name, parent, tunes, data }: { name?: BlockNodeName, parent: EditorDocument, data?: BlockNodeData, tunes?: Record<BlockTuneName, BlockTune> }): BlockNode {\n\t  return new BlockNode({\n\t    name: name || createBlockNodeName('header'),\n\t    parent,\n\t    data: data || {},\n\t    tunes: tunes || {},\n\t  });\n\t}\n"]}
{"filename": "src/entities/EditorDocument/index.ts", "chunked_list": ["import { BlockNode } from '../BlockNode';\n\timport { EditorDocumentConstructorParameters, PropName } from './types';\n\t/**\n\t * EditorDocument class represents the top-level container for a tree-like structure of BlockNodes in an editor document.\n\t * It contains an array of BlockNodes representing the root-level nodes of the document.\n\t */\n\texport class EditorDocument {\n\t  /**\n\t   * Private field representing the child BlockNodes of the EditorDocument\n\t   */\n", "  #children: BlockNode[];\n\t  /**\n\t   * Private field representing the properties of the document\n\t   */\n\t  #properties: Record<PropName, unknown>;\n\t  /**\n\t   * Constructor for EditorDocument class.\n\t   *\n\t   * @param args - EditorDocument constructor arguments.\n\t   * @param args.children - The child BlockNodes of the EditorDocument.\n", "   * @param args.properties - The properties of the document.\n\t   */\n\t  constructor({ children, properties }: EditorDocumentConstructorParameters) {\n\t    this.#children = children;\n\t    this.#properties = properties;\n\t  }\n\t  /**\n\t   * Returns count of child BlockNodes of the EditorDocument.\n\t   */\n\t  public get length(): number {\n", "    return this.#children.length;\n\t  }\n\t  /**\n\t   * Adds a BlockNode to the EditorDocument at the specified index.\n\t   * If no index is provided, the BlockNode will be added to the end of the array.\n\t   *\n\t   * @param blockNode - The BlockNode to add to the EditorDocument\n\t   * @param index - The index at which to add the BlockNode\n\t   * @throws Error if the index is out of bounds\n\t   */\n", "  public addBlock(blockNode: BlockNode, index?: number): void {\n\t    if (index === undefined) {\n\t      this.#children.push(blockNode);\n\t      return;\n\t    }\n\t    this.#checkIndexOutOfBounds(index);\n\t    this.#children.splice(index, 0, blockNode);\n\t  }\n\t  /**\n\t   * Removes a BlockNode from the EditorDocument at the specified index.\n", "   *\n\t   * @param index - The index of the BlockNode to remove\n\t   * @throws Error if the index is out of bounds\n\t   */\n\t  public removeBlock(index: number): void {\n\t    this.#checkIndexOutOfBounds(index, this.length - 1);\n\t    this.#children.splice(index, 1);\n\t  }\n\t  /**\n\t   * Returns the BlockNode at the specified index.\n", "   * Throws an error if the index is out of bounds.\n\t   *\n\t   * @param index - The index of the BlockNode to return\n\t   * @throws Error if the index is out of bounds\n\t   */\n\t  public getBlock(index: number): BlockNode {\n\t    this.#checkIndexOutOfBounds(index, this.length - 1);\n\t    return this.#children[index];\n\t  }\n\t  /**\n", "   * Checks if the index is out of bounds.\n\t   *\n\t   * @param index - The index to check\n\t   * @param max - The maximum index value. Defaults to the length of the children array.\n\t   * @throws Error if the index is out of bounds\n\t   */\n\t  #checkIndexOutOfBounds(index: number, max: number = this.length): void {\n\t    if (index < 0 || index > max) {\n\t      throw new Error('Index out of bounds');\n\t    }\n", "  }\n\t}\n"]}
{"filename": "src/entities/EditorDocument/EditorDocument.spec.ts", "chunked_list": ["import { EditorDocument } from './index';\n\timport { BlockNode } from '../BlockNode';\n\timport { createBlockNodeMock } from '../../utils/mocks/createBlockNodeMock';\n\timport { createEditorDocumentMock } from '../../utils/mocks/createEditorDocumentMock';\n\t/**\n\t * Creates an EditorDocument object with some blocks for tests.\n\t */\n\tfunction createEditorDocumentMockWithSomeBlocks(): EditorDocument {\n\t  const document = createEditorDocumentMock();\n\t  const countOfBlocks = 3;\n", "  for (let i = 0; i < countOfBlocks; i++) {\n\t    const block = createBlockNodeMock({\n\t      parent: document,\n\t    });\n\t    document.addBlock(block);\n\t  }\n\t  return document;\n\t}\n\tdescribe('EditorDocument', () => {\n\t  describe('.length', () => {\n", "    it('should return the number of blocks in the document', () => {\n\t      // Arrange\n\t      const blocksCount = 3;\n\t      const document = new EditorDocument({\n\t        children: [],\n\t        properties: {\n\t          readOnly: false,\n\t        },\n\t      });\n\t      for (let i = 0; i < blocksCount; i++) {\n", "        const block = createBlockNodeMock({\n\t          parent: document,\n\t        });\n\t        document.addBlock(block);\n\t      }\n\t      // Act\n\t      const actual = document.length;\n\t      // Assert\n\t      expect(actual).toBe(blocksCount);\n\t    });\n", "  });\n\t  describe('.addBlock()', () => {\n\t    it('should add the block to the end of the document if index is not provided', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      const block = createBlockNodeMock({\n\t        parent: document,\n\t      });\n\t      // Act\n\t      document.addBlock(block);\n", "      // Assert\n\t      const lastBlock = document.getBlock(document.length - 1);\n\t      expect(lastBlock).toBe(block);\n\t    });\n\t    it('should add the block to the beginning of the document if index is 0', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      const block = createBlockNodeMock({\n\t        parent: document,\n\t      });\n", "      // Act\n\t      document.addBlock(block, 0);\n\t      // Assert\n\t      expect(document.getBlock(0)).toBe(block);\n\t    });\n\t    it('should add the block to the specified index in the middle of the document', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      const block = createBlockNodeMock({\n\t        parent: document,\n", "      });\n\t      // Act\n\t      document.addBlock(block, 1);\n\t      // Assert\n\t      expect(document.getBlock(1)).toBe(block);\n\t    });\n\t    it('should add the block to the end of the document if the index after the last element is passed', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      const block = createBlockNodeMock({\n", "        parent: document,\n\t      });\n\t      // Act\n\t      document.addBlock(block, document.length);\n\t      // Assert\n\t      const lastBlock = document.getBlock(document.length - 1);\n\t      expect(lastBlock).toBe(block);\n\t    });\n\t    it('should throw an error if index is less then 0', () => {\n\t      // Arrange\n", "      const document = createEditorDocumentMockWithSomeBlocks();\n\t      const block = createBlockNodeMock({\n\t        parent: document,\n\t      });\n\t      // Act\n\t      const action = (): void => document.addBlock(block, -1);\n\t      // Assert\n\t      expect(action).toThrowError('Index out of bounds');\n\t    });\n\t    it('should throw an error if index is greater then document length', () => {\n", "      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      const block = createBlockNodeMock({\n\t        parent: document,\n\t      });\n\t      // Act\n\t      const action = (): void => document.addBlock(block, document.length + 1);\n\t      // Assert\n\t      expect(action).toThrowError('Index out of bounds');\n\t    });\n", "  });\n\t  describe('.removeBlock()', () => {\n\t    it('should remove the block from the beginning of the document if index 0 is passed', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      const block = document.getBlock(0);\n\t      // Act\n\t      document.removeBlock(0);\n\t      // Assert\n\t      expect(document.getBlock(0)).not.toBe(block);\n", "    });\n\t    it('should remove the block from the specified index in the middle of the document', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      const block = document.getBlock(1);\n\t      // Act\n\t      document.removeBlock(1);\n\t      // Assert\n\t      expect(document.getBlock(1)).not.toBe(block);\n\t    });\n", "    it('should remove the block from the end of the document if the last index is passed', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      const documentLengthBeforeRemove = document.length;\n\t      // Act\n\t      document.removeBlock(document.length - 1);\n\t      // Assert\n\t      expect(document.length).toBe(documentLengthBeforeRemove - 1);\n\t    });\n\t    it('should throw an error if index is less then 0', () => {\n", "      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      // Act\n\t      const action = (): void => document.removeBlock(-1);\n\t      // Assert\n\t      expect(action).toThrowError('Index out of bounds');\n\t    });\n\t    it('should throw an error if index is greater then document length', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n", "      // Act\n\t      const action = (): void => document.removeBlock(document.length);\n\t      // Assert\n\t      expect(action).toThrowError('Index out of bounds');\n\t    });\n\t  });\n\t  describe('.getBlock()', () => {\n\t    it('should return the block from the specific index', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMock();\n", "      const countOfBlocks = 3;\n\t      const blocks: BlockNode[] = [];\n\t      for (let i = 0; i < countOfBlocks; i++) {\n\t        const block = createBlockNodeMock({\n\t          parent: document,\n\t        });\n\t        document.addBlock(block);\n\t        blocks.push(block);\n\t      }\n\t      const index = 1;\n", "      // Act\n\t      const block = document.getBlock(index);\n\t      // Assert\n\t      expect(block).toBe(blocks[index]);\n\t    });\n\t    it('should throw an error if index is less then 0', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      // Act\n\t      const action = (): BlockNode => document.getBlock(-1);\n", "      // Assert\n\t      expect(action).toThrowError('Index out of bounds');\n\t    });\n\t    it('should throw an error if index is greater then document length', () => {\n\t      // Arrange\n\t      const document = createEditorDocumentMockWithSomeBlocks();\n\t      // Act\n\t      const action = (): BlockNode => document.getBlock(document.length);\n\t      // Assert\n\t      expect(action).toThrowError('Index out of bounds');\n", "    });\n\t  });\n\t});\n"]}
{"filename": "src/entities/EditorDocument/types/EditorDocumentConstructorParameters.ts", "chunked_list": ["import { BlockNode } from '../../BlockNode';\n\timport { PropName } from './PropName';\n\texport interface EditorDocumentConstructorParameters {\n\t  /**\n\t   * The child BlockNodes of the EditorDocument\n\t   */\n\t  children: BlockNode[];\n\t  /**\n\t   * The properties of the document\n\t   */\n", "  properties: Record<PropName, unknown>;\n\t}\n"]}
{"filename": "src/entities/EditorDocument/types/PropName.ts", "chunked_list": ["/**\n\t * Enum with available props to customise document state and behaviour\n\t */\n\texport enum PropName {\n\t  /**\n\t   * Read-only mode for the Editor\n\t   */\n\t  ReadOnly = 'readOnly',\n\t}\n"]}
{"filename": "src/entities/EditorDocument/types/index.ts", "chunked_list": ["export { EditorDocumentConstructorParameters } from './EditorDocumentConstructorParameters';\n\texport { PropName } from './PropName';\n"]}
{"filename": "src/entities/BlockNode/BlockNode.spec.ts", "chunked_list": ["import { BlockNode } from './index';\n\timport { createBlockNodeName, createDataKey } from './types';\n\timport { BlockTune, createBlockTuneName } from '../BlockTune';\n\timport { TextNode } from '../TextNode';\n\timport { ValueNode } from '../ValueNode';\n\timport type { EditorDocument } from '../EditorDocument';\n\timport type { BlockTuneConstructorParameters } from '../BlockTune/types';\n\timport type { TextNodeConstructorParameters } from '../TextNode';\n\timport type { ValueNodeConstructorParameters } from '../ValueNode';\n\tdescribe('BlockNode', () => {\n", "  describe('.serialized', () => {\n\t    beforeEach(() => {\n\t      jest.mock('../BlockTune', () => ({\n\t        BlockTune: jest.fn().mockImplementation(() => ({}) as BlockTune),\n\t        serialized: jest.fn(),\n\t      }));\n\t      jest.mock('../TextNode', () => ({\n\t        TextNode: jest.fn().mockImplementation(() => ({}) as TextNode),\n\t        serialized: jest.fn(),\n\t      }));\n", "      jest.mock('../ValueNode', () => ({\n\t        ValueNode: jest.fn().mockImplementation(() => ({}) as ValueNode),\n\t        serialized: jest.fn(),\n\t      }));\n\t    });\n\t    afterEach(() => {\n\t      jest.clearAllMocks();\n\t    });\n\t    it('should return a name of a tool that created a BlockNode', () => {\n\t      const blockNodeName = createBlockNodeName('paragraph');\n", "      const blockNode = new BlockNode({\n\t        name: blockNodeName,\n\t        data: {},\n\t        parent: {} as EditorDocument,\n\t      });\n\t      const serialized = blockNode.serialized;\n\t      expect(serialized.name).toEqual(blockNodeName);\n\t    });\n\t    it('should call .serialized getter of all tunes associated with the BlockNode', () => {\n\t      const blockTunesNames = [\n", "        createBlockTuneName('align'),\n\t        createBlockTuneName('font-size'),\n\t        createBlockTuneName('font-weight'),\n\t      ];\n\t      const blockTunes = blockTunesNames.reduce((acc, name) => ({\n\t        ...acc,\n\t        [name]: new BlockTune({} as BlockTuneConstructorParameters),\n\t      }), {});\n\t      const spyArray = Object\n\t        .values(blockTunes)\n", "        .map((blockTune) => {\n\t          return jest.spyOn(blockTune as BlockTune, 'serialized', 'get');\n\t        });\n\t      const blockNode = new BlockNode({\n\t        name: createBlockNodeName('paragraph'),\n\t        data: {},\n\t        parent: {} as EditorDocument,\n\t        tunes: blockTunes,\n\t      });\n\t      blockNode.serialized;\n", "      spyArray.forEach((spy) => {\n\t        expect(spy).toHaveBeenCalled();\n\t      });\n\t    });\n\t    it('should call .serialized getter of all child ValueNodes associated with the BlockNode', () => {\n\t      const countOfValueNodes = 2;\n\t      const valueNodes = [ ...Array(countOfValueNodes).keys() ]\n\t        .reduce((acc, index) => ({\n\t          ...acc,\n\t          [createDataKey(`data-key-${index}c${index}d`)]: new ValueNode({} as ValueNodeConstructorParameters),\n", "        }), {});\n\t      const spyArray = Object\n\t        .values(valueNodes)\n\t        .map((valueNode) => {\n\t          return jest.spyOn(valueNode as ValueNode, 'serialized', 'get');\n\t        });\n\t      const blockNode = new BlockNode({\n\t        name: createBlockNodeName('paragraph'),\n\t        data: {\n\t          ...valueNodes,\n", "        },\n\t        parent: {} as EditorDocument,\n\t      });\n\t      blockNode.serialized;\n\t      spyArray.forEach((spy) => {\n\t        expect(spy).toHaveBeenCalled();\n\t      });\n\t    });\n\t    it('should call .serialized getter of all child TextNodes associated with the BlockNode', () => {\n\t      const countOfTextNodes = 3;\n", "      const textNodes = [ ...Array(countOfTextNodes).keys() ]\n\t        .map(() => new TextNode({} as TextNodeConstructorParameters));\n\t      const spyArray = textNodes\n\t        .map((textNode) => {\n\t          return jest.spyOn(textNode, 'serialized', 'get');\n\t        });\n\t      const blockNode = new BlockNode({\n\t        name: createBlockNodeName('paragraph'),\n\t        data: {\n\t          [createDataKey('data-key-1a2b')]: textNodes,\n", "        },\n\t        parent: {} as EditorDocument,\n\t      });\n\t      blockNode.serialized;\n\t      spyArray.forEach((spy) => {\n\t        expect(spy).toHaveBeenCalled();\n\t      });\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/entities/BlockNode/index.ts", "chunked_list": ["import { EditorDocument } from '../EditorDocument';\n\timport { BlockTune, BlockTuneName, BlockTuneSerialized } from '../BlockTune';\n\timport {\n\t  BlockNodeConstructorParameters,\n\t  BlockNodeName,\n\t  createBlockNodeName,\n\t  DataKey,\n\t  createDataKey, BlockNodeData,\n\t  BlockNodeSerialized\n\t} from './types';\n", "/**\n\t * BlockNode class represents a node in a tree-like structure used to store and manipulate Blocks in an editor document.\n\t * A BlockNode can contain one or more child nodes of type TextNode, ValueNode or FormattingNode.\n\t * It can also be associated with one or more BlockTunes, which can modify the behavior of the BlockNode.\n\t */\n\texport class BlockNode {\n\t  /**\n\t   * Field representing a name of the Tool created this Block\n\t   */\n\t  #name: BlockNodeName;\n", "  /**\n\t   * Field representing the content of the Block\n\t   */\n\t  #data: BlockNodeData;\n\t  /**\n\t   * Field representing the parent EditorDocument of the BlockNode\n\t   */\n\t  #parent: EditorDocument;\n\t  /**\n\t   * Private field representing the BlockTunes associated with the BlockNode\n", "   */\n\t  #tunes: Record<BlockTuneName, BlockTune>;\n\t  /**\n\t   * Constructor for BlockNode class.\n\t   *\n\t   * @param args - TextNode constructor arguments.\n\t   * @param args.name - The name of the BlockNode.\n\t   * @param args.data - The content of the BlockNode.\n\t   * @param args.parent - The parent EditorDocument of the BlockNode.\n\t   * @param args.tunes - The BlockTunes associated with the BlockNode.\n", "   */\n\t  constructor({ name, data, parent, tunes = {} }: BlockNodeConstructorParameters) {\n\t    this.#name = name;\n\t    this.#data = data;\n\t    this.#parent = parent;\n\t    this.#tunes = tunes;\n\t  }\n\t  /**\n\t   * Returns serialized object representing the BlockNode\n\t   */\n", "  public get serialized(): BlockNodeSerialized {\n\t    const serializedData = Object\n\t      .entries(this.#data)\n\t      .reduce(\n\t        (acc, [dataKey, value]) => {\n\t          /**\n\t           * If the value is an array, we need to serialize each node in the array\n\t           * Value is an array if the BlockNode contains TextNodes and FormattingNodes\n\t           * After serializing there will be InlineNodeSerialized object\n\t           */\n", "          if (value instanceof Array) {\n\t            acc[dataKey] = value.map((node) => node.serialized);\n\t            return acc;\n\t          }\n\t          acc[dataKey] = value.serialized;\n\t          return acc;\n\t        },\n\t        {} as Record<string, unknown>\n\t      );\n\t    const serializedTunes = Object\n", "      .entries(this.#tunes)\n\t      .reduce(\n\t        (acc, [name, tune]) => {\n\t          acc[name] = tune.serialized;\n\t          return acc;\n\t        },\n\t        {} as Record<string, BlockTuneSerialized>\n\t      );\n\t    return {\n\t      name: this.#name,\n", "      data: serializedData,\n\t      tunes: serializedTunes,\n\t    };\n\t  }\n\t}\n\texport {\n\t  BlockNodeName,\n\t  createBlockNodeName,\n\t  DataKey,\n\t  createDataKey\n", "};\n"]}
{"filename": "src/entities/BlockNode/types/BlockNodeSerialized.ts", "chunked_list": ["import { BlockTuneSerialized } from '../../BlockTune';\n\t/**\n\t * Serialized version of the BlockNode\n\t */\n\texport interface BlockNodeSerialized {\n\t  /**\n\t   * The name of the tool created a Block\n\t   */\n\t  name: string;\n\t  /**\n", "   * The content of the Block\n\t   */\n\t  data: Record<string, unknown>; // @todo replace unknown type with serialized root node and value node\n\t  /**\n\t   * Serialized BlockTunes associated with the BlockNode\n\t   */\n\t  tunes: Record<string, BlockTuneSerialized>;\n\t}\n"]}
{"filename": "src/entities/BlockNode/types/DataKey.ts", "chunked_list": ["import { create, Nominal } from '../../../utils/Nominal';\n\t/**\n\t * Base type of the data key field\n\t */\n\ttype DataKeyBase = string;\n\t/**\n\t * Nominal type for the data key field\n\t */\n\texport type DataKey = Nominal<DataKeyBase, 'DataKey'>;\n\t/**\n", " * Function returns a value with the nominal DataKey type\n\t */\n\texport const createDataKey = create<DataKey>();\n"]}
{"filename": "src/entities/BlockNode/types/BlockNodeData.ts", "chunked_list": ["import { DataKey } from './DataKey';\n\timport { TextNode } from '../../TextNode';\n\timport { ValueNode } from '../../ValueNode';\n\timport { FormattingNode } from '../../FormattingNode';\n\t/**\n\t * Represents a record object containing the data of a block node.\n\t * Each root node is associated with a specific data key.\n\t */\n\texport type BlockNodeData = Record<DataKey, ValueNode | (FormattingNode | TextNode)[]>;\n"]}
{"filename": "src/entities/BlockNode/types/BlockNodeName.ts", "chunked_list": ["import { create, Nominal } from '../../../utils/Nominal';\n\t/**\n\t * Base type of the block node name field\n\t */\n\ttype BlockNodeNameBase = string;\n\t/**\n\t * Nominal type for the block node name field\n\t */\n\texport type BlockNodeName = Nominal<BlockNodeNameBase, 'BlockNodeName'>;\n\t/**\n", " * Function returns a value with the nominal BlockNodeName type\n\t */\n\texport const createBlockNodeName = create<BlockNodeName>();\n"]}
{"filename": "src/entities/BlockNode/types/index.ts", "chunked_list": ["export { BlockNodeConstructorParameters } from './BlockNodeConstructorParameters';\n\texport { BlockNodeName, createBlockNodeName } from './BlockNodeName';\n\texport { DataKey, createDataKey } from './DataKey';\n\texport { BlockNodeData } from './BlockNodeData';\n\texport { BlockNodeSerialized } from './BlockNodeSerialized';\n"]}
{"filename": "src/entities/BlockNode/types/BlockNodeConstructorParameters.ts", "chunked_list": ["import { EditorDocument } from '../../EditorDocument';\n\timport { BlockTune, BlockTuneName } from '../../BlockTune';\n\timport { BlockNodeName } from './BlockNodeName';\n\timport { BlockNodeData } from './BlockNodeData';\n\texport interface BlockNodeConstructorParameters {\n\t  /**\n\t   * The name of the tool created a Block\n\t   */\n\t  name: BlockNodeName;\n\t  /**\n", "   * The content of the Block\n\t   */\n\t  data: BlockNodeData;\n\t  /**\n\t   * The parent EditorDocument of the BlockNode\n\t   */\n\t  parent: EditorDocument;\n\t  /**\n\t   * The BlockTunes associated with the BlockNode\n\t   */\n", "  tunes?: Record<BlockTuneName, BlockTune>;\n\t}\n"]}
{"filename": "src/entities/interfaces/ChildNode.spec.ts", "chunked_list": ["import { describe, it, expect, beforeEach, jest } from '@jest/globals';\n\timport { ChildNode } from './ChildNode';\n\timport type { ParentNode } from './ParentNode';\n\tconst parentMock = {\n\t  append: jest.fn(),\n\t  removeChild: jest.fn(),\n\t  insertAfter: jest.fn(),\n\t  children: [],\n\t} as unknown as ParentNode;\n\tinterface Dummy extends ChildNode {\n", "}\n\t/**\n\t * Dummy Node's class\n\t */\n\t@ChildNode\n\tclass Dummy {\n\t  /**\n\t   *\n\t   * @param _options - dummy options\n\t   */\n", "  // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars,no-unused-vars\n\t  constructor(_options?: unknown) {}\n\t}\n\tdescribe('ChildNode decorator', () => {\n\t  let dummy: Dummy;\n\t  beforeEach(() => {\n\t    jest.resetAllMocks();\n\t  });\n\t  it('should decorated class to a parent', () => {\n\t    dummy = new Dummy({ parent: parentMock });\n", "    expect(parentMock.append).toBeCalledWith(dummy);\n\t  });\n\t  it('should add remove method to the decorated class', () => {\n\t    expect(dummy.remove).toBeInstanceOf(Function);\n\t  });\n\t  it('should add appendTo method to the decorated class', () => {\n\t    expect(dummy.appendTo).toBeInstanceOf(Function);\n\t  });\n\t  describe('.parent', () => {\n\t    it('should return null by default', () => {\n", "      dummy = new Dummy();\n\t      expect(dummy.parent).toBeNull();\n\t    });\n\t    it('should return parent passed via constructor', () => {\n\t      dummy = new Dummy({ parent: parentMock });\n\t      expect(dummy.parent).toEqual(parentMock);\n\t    });\n\t  });\n\t  describe('.remove()', () => {\n\t    beforeEach(() => {\n", "      dummy = new Dummy({\n\t        parent: parentMock,\n\t      });\n\t    });\n\t    it('should call parent\\'s removeChild method', () => {\n\t      dummy.remove();\n\t      expect(parentMock.removeChild).toBeCalledWith(dummy);\n\t    });\n\t    it('should set node\\'s parent to null', () => {\n\t      dummy.remove();\n", "      expect(dummy.parent).toBeNull();\n\t    });\n\t  });\n\t  describe('.appendTo()', () => {\n\t    beforeEach(() => {\n\t      dummy = new Dummy();\n\t    });\n\t    it('should call parent\\'s append method on appendTo call', () => {\n\t      dummy.appendTo(parentMock);\n\t      expect(parentMock.append).toBeCalledWith(dummy);\n", "    });\n\t    it('should set node\\'s parent on appendTo call', () => {\n\t      dummy.appendTo(parentMock);\n\t      expect(dummy.parent).toBe(parentMock);\n\t    });\n\t    it('should do nothing if parents are the same', () => {\n\t      const dummyWithParent = new Dummy({\n\t        parent: parentMock,\n\t      });\n\t      jest.resetAllMocks();\n", "      dummyWithParent.appendTo(parentMock);\n\t      expect(parentMock.append).not.toBeCalled();\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/entities/interfaces/ParentNode.spec.ts", "chunked_list": ["import { describe, it, expect, beforeEach, jest } from '@jest/globals';\n\timport { ParentNode } from './ParentNode';\n\timport type { ChildNode } from './ChildNode';\n\tconst createChildMock = (): ChildNode => {\n\t  return {\n\t    appendTo: jest.fn(),\n\t    remove: jest.fn(),\n\t    parent: null,\n\t  } as unknown as ChildNode;\n\t};\n", "interface Dummy extends ParentNode {\n\t}\n\t/**\n\t *\n\t */\n\t@ParentNode\n\tclass Dummy {\n\t  /**\n\t   *\n\t   * @param _options - dummy options\n", "   */\n\t  // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars,no-unused-vars\n\t  constructor(_options?: unknown) {}\n\t}\n\tdescribe('ParentNode decorator', () => {\n\t  let dummy: Dummy;\n\t  beforeEach(() => {\n\t    dummy = new Dummy();\n\t    jest.resetAllMocks();\n\t  });\n", "  it('should add removeChild method to the decorated class', () => {\n\t    expect(dummy.removeChild).toBeInstanceOf(Function);\n\t  });\n\t  it('should add append method to the decorated class', () => {\n\t    expect(dummy.append).toBeInstanceOf(Function);\n\t  });\n\t  it('should add insertAfter method to the decorated class', () => {\n\t    expect(dummy.insertAfter).toBeInstanceOf(Function);\n\t  });\n\t  describe('constructor', () => {\n", "    it('should append passed children to new parent', () => {\n\t      const childMock = createChildMock();\n\t      dummy = new Dummy({\n\t        children: [ childMock ],\n\t      });\n\t      expect(childMock.appendTo).toBeCalledWith(dummy);\n\t    });\n\t  });\n\t  describe('.children', () => {\n\t    it('should return empty array by default', () => {\n", "      expect(dummy.children).toEqual([]);\n\t    });\n\t    it('should return children passed via constructor', () => {\n\t      const childMock = createChildMock();\n\t      dummy = new Dummy({\n\t        children: [ childMock ],\n\t      });\n\t      expect(dummy.children).toEqual([ childMock ]);\n\t    });\n\t  });\n", "  describe('.append()', () => {\n\t    it('should add child to the children array', () => {\n\t      const childMock = createChildMock();\n\t      dummy.append(childMock);\n\t      expect(dummy.children).toContain(childMock);\n\t    });\n\t    it('should add several children to the children array', () => {\n\t      const childMock = createChildMock();\n\t      const anotherChildMock = createChildMock();\n\t      dummy.append(childMock, anotherChildMock);\n", "      expect(dummy.children).toEqual([childMock, anotherChildMock]);\n\t    });\n\t    it('should move a child to the end of children array if it is already there', () => {\n\t      const childMock = createChildMock();\n\t      const anotherChildMock = createChildMock();\n\t      const oneMoreChildMock = createChildMock();\n\t      dummy = new Dummy({\n\t        children: [childMock, anotherChildMock, oneMoreChildMock],\n\t      });\n\t      dummy.append(anotherChildMock);\n", "      expect(dummy.children).toEqual([childMock, oneMoreChildMock, anotherChildMock]);\n\t    });\n\t    it('should preserve already existing children', () => {\n\t      const childMock = createChildMock();\n\t      const anotherChildMock = createChildMock();\n\t      const oneMoreChildMock = createChildMock();\n\t      dummy = new Dummy({\n\t        children: [childMock, anotherChildMock],\n\t      });\n\t      dummy.append(oneMoreChildMock);\n", "      expect(dummy.children).toEqual([childMock, anotherChildMock, oneMoreChildMock]);\n\t    });\n\t  });\n\t  describe('.insertAfter()', () => {\n\t    it('should insert a child after passed target', () => {\n\t      const childMock = createChildMock();\n\t      const anotherChildMock = createChildMock();\n\t      const childMockToInsert = createChildMock();\n\t      dummy = new Dummy({\n\t        children: [childMock, anotherChildMock],\n", "      });\n\t      dummy.insertAfter(childMock, childMockToInsert);\n\t      expect(dummy.children).toEqual([childMock, childMockToInsert, anotherChildMock]);\n\t    });\n\t    it('should insert several children after passed target', () => {\n\t      const childMock = createChildMock();\n\t      const anotherChildMock = createChildMock();\n\t      const childMockToInsert = createChildMock();\n\t      const anotherChildMockToInsert = createChildMock();\n\t      dummy = new Dummy({\n", "        children: [childMock, anotherChildMock],\n\t      });\n\t      dummy.insertAfter(childMock, childMockToInsert, anotherChildMockToInsert);\n\t      expect(dummy.children).toEqual([childMock, childMockToInsert, anotherChildMockToInsert, anotherChildMock]);\n\t    });\n\t    it('should remove existing child and insert it to the new place', () => {\n\t      const childMock = createChildMock();\n\t      const anotherChildMock = createChildMock();\n\t      const oneMoreChildMock = createChildMock();\n\t      const childMockToInsert = createChildMock();\n", "      dummy = new Dummy({\n\t        children: [childMock, anotherChildMock, oneMoreChildMock, childMockToInsert],\n\t      });\n\t      dummy.insertAfter(anotherChildMock, childMockToInsert);\n\t      expect(dummy.children).toEqual([childMock, anotherChildMock, childMockToInsert, oneMoreChildMock]);\n\t    });\n\t  });\n\t  describe('.removeChild()', () => {\n\t    it('should remove child from the children array', () => {\n\t      const childMock = createChildMock();\n", "      dummy = new Dummy({\n\t        children: [ childMock ],\n\t      });\n\t      dummy.removeChild(childMock);\n\t      expect(dummy.children).toHaveLength(0);\n\t    });\n\t    it('should call remove method of child', () => {\n\t      const childMock = createChildMock();\n\t      dummy = new Dummy({\n\t        children: [ childMock ],\n", "      });\n\t      dummy.removeChild(childMock);\n\t      expect(childMock.remove).toBeCalled();\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/entities/interfaces/integration.spec.ts", "chunked_list": ["import { beforeEach, describe } from '@jest/globals';\n\timport { ParentNode } from './ParentNode';\n\timport { ChildNode } from './ChildNode';\n\tinterface DummyParent extends ParentNode {}\n\t/**\n\t *\n\t */\n\t@ParentNode\n\tclass DummyParent {\n\t  /**\n", "   *\n\t   * @param _options - dummy options\n\t   */\n\t  // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars,no-unused-vars\n\t  constructor(_options?: unknown) {}\n\t}\n\tinterface DummyChild extends ChildNode {}\n\t/**\n\t *\n\t */\n", "@ChildNode\n\tclass DummyChild {\n\t  /**\n\t   *\n\t   * @param _options - dummy options\n\t   */\n\t  // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars,no-unused-vars\n\t  constructor(_options?: unknown) {}\n\t}\n\tdescribe('ParentNode and ChildNode integration', () => {\n", "  describe('child removal', () => {\n\t    let parent: DummyParent;\n\t    let child: DummyChild;\n\t    beforeEach(() => {\n\t      parent = new DummyParent();\n\t      child = new DummyChild({ parent });\n\t    });\n\t    it('should remove child from parent on child.remove() call', () => {\n\t      child.remove();\n\t      expect(parent.children).not.toContain(child);\n", "    });\n\t    it('should set child\\'s parent to null on parent.removeChild() call', () => {\n\t      parent.removeChild(child);\n\t      expect(child.parent).toBeNull();\n\t    });\n\t  });\n\t  describe('child addition', () => {\n\t    let parent: DummyParent;\n\t    let child: DummyChild;\n\t    beforeEach(() => {\n", "      parent = new DummyParent();\n\t      child = new DummyChild();\n\t    });\n\t    it('should add child to parent on child.appendTo call', () => {\n\t      child.appendTo(parent);\n\t      expect(parent.children).toContain(child);\n\t    });\n\t    it('should set child\\'s parent on parent.append() call', () => {\n\t      parent.append(child);\n\t      expect(child.parent).toEqual(parent);\n", "    });\n\t    it('should set child\\'s parent on parent.insertAfter() call', () => {\n\t      const anotherChild = new DummyChild();\n\t      parent.append(child);\n\t      parent.insertAfter(child, anotherChild);\n\t      expect(anotherChild.parent).toEqual(parent);\n\t    });\n\t  });\n\t  describe('child transfer from parent to parent', () => {\n\t    let parent: DummyParent;\n", "    let anotherParent: DummyParent;\n\t    let child: DummyChild;\n\t    beforeEach(() => {\n\t      parent = new DummyParent();\n\t      child = new DummyChild({ parent });\n\t      anotherParent = new DummyParent();\n\t    });\n\t    it('should remove child from the old parent on new parent.append() call', () => {\n\t      anotherParent.append(child);\n\t      expect(parent.children).not.toContain(child);\n", "    });\n\t    it('should remove child from the old parent on new parent.insertAfter() call', () => {\n\t      const anotherChild = new DummyChild({ parent: anotherParent });\n\t      anotherParent.insertAfter(anotherChild, child);\n\t      expect(parent.children).not.toContain(child);\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/entities/interfaces/InlineNode.ts", "chunked_list": ["import { InlineToolData, InlineToolName } from '../FormattingNode';\n\t/**\n\t * Interface describing abstract InlineNode\n\t */\n\texport interface InlineNode {\n\t  /**\n\t   * Text length of node and it's subtree\n\t   */\n\t  length: number;\n\t  /**\n", "   * Returns text value in passed range\n\t   *\n\t   * @param start - start char index of the range\n\t   * @param end - end char index of the range\n\t   */\n\t  getText(start?: number, end?: number): string;\n\t  /**\n\t   * Applies inline formatting on the passed range\n\t   *\n\t   * @param name - name of Inline Tool to apply\n", "   * @param [start] - start char index of the range\n\t   * @param [end] - end char index of the range\n\t   * @param [data] - Inline Tool data if applicable\n\t   * @returns {InlineNode[]} - array of nodes after applied formatting\n\t   */\n\t  format(name: InlineToolName, start?: number, end?: number, data?: InlineToolData): InlineNode[];\n\t  /**\n\t   * Inserts text at passed char index\n\t   *\n\t   * @param text - text to insert\n", "   * @param [index] - char index where to insert text\n\t   */\n\t  insertText(text: string, index?: number): void;\n\t  /**\n\t   * Removes text from the passed range\n\t   *\n\t   * @param [start] - start char index of the range\n\t   * @param [end] - утв char index of the range\n\t   * @returns {string} removed text\n\t   */\n", "  removeText(start?: number, end?: number): string;\n\t  /**\n\t   * Splits current node at the passed index\n\t   *\n\t   * @param index - char index where to split the node\n\t   * @returns {InlineNode | null} new node if split successful, null if nothing to split\n\t   */\n\t  split(index?: number): InlineNode | null;\n\t  /**\n\t   * Serialized value of the node\n", "   */\n\t  serialized: InlineNodeSerialized;\n\t}\n\t/**\n\t * Serialized inline fragment\n\t */\n\texport interface InlineFragment {\n\t  /**\n\t   * Name of the applied Inline Tool\n\t   */\n", "  tool: InlineToolName;\n\t  /**\n\t   * Inline Tool Data if applicable\n\t   */\n\t  data?: InlineToolData;\n\t  /**\n\t   * Range of the fragment\n\t   */\n\t  range: [start: number, end: number];\n\t}\n", "/**\n\t * Serialized Inline Node value\n\t */\n\texport interface InlineNodeSerialized {\n\t  /**\n\t   * Text value of the node and its subtree\n\t   */\n\t  text: string;\n\t  /**\n\t   * Fragments which node and its subtree contains\n", "   */\n\t  fragments: InlineFragment[];\n\t}\n"]}
{"filename": "src/entities/interfaces/index.ts", "chunked_list": ["export * from './ChildNode';\n\texport * from './ParentNode';\n\texport * from './InlineNode';\n"]}
{"filename": "src/entities/interfaces/ParentNode.ts", "chunked_list": ["import type { ChildNode } from './ChildNode';\n\timport { InlineNode } from './InlineNode';\n\t/**\n\t * Abstract parent node interface\n\t */\n\texport interface ParentNode extends InlineNode {\n\t  /**\n\t   * Appends passed children to this node\n\t   *\n\t   * @param children - array of children to append\n", "   */\n\t  append(...children: ChildNode[]): void;\n\t  /**\n\t   * Removes a child from the parent\n\t   *\n\t   * @param child - child to remove\n\t   */\n\t  removeChild(child: ChildNode): void;\n\t  /**\n\t   * Inserts new children after specified target\n", "   *\n\t   * @param target - target after which to insert new children\n\t   * @param children - children nodes to insert\n\t   */\n\t  insertAfter(target: ChildNode, ...children: ChildNode[]): void\n\t  /**\n\t   * Node's children\n\t   */\n\t  children: ChildNode[];\n\t}\n", "export interface ParentNodeConstructorOptions {\n\t  children?: ChildNode[];\n\t}\n\t/**\n\t * ParentNode decorator to mixin ParentNode's methods\n\t *\n\t * @param constructor - class to decorate\n\t * @example\n\t *\n\t * ```ts\n", " * // interface is required to let TS know about ParentNode's methods\n\t * interface MyNode extends ParentNode {}\n\t *\n\t * @ParentNode\n\t * class MyNode {}\n\t * ```\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any -- any type here is a TS requirement for mixin classes\n\texport function ParentNode<C extends { new(...args: any[]): InlineNode }>(constructor: C): C {\n\t  return class extends constructor {\n", "    #children: ChildNode[];\n\t    /**\n\t     * @param args — constructor arguments\n\t     * @param {ChildNode[]} [args.children] - optional node's children\n\t     */\n\t    // Stryker disable next-line BlockStatement -- Styker's bug, see https://github.com/stryker-mutator/stryker-js/issues/2474\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- any type here is a TS requirement for mixin classes\n\t    constructor(...args: any[]) {\n\t      const { children = [], ...rest } = args[0] ?? {};\n\t      super(rest);\n", "      this.#children = children;\n\t      this.children.forEach(child => child.appendTo(this));\n\t    }\n\t    /**\n\t     * Returns node's children\n\t     */\n\t    public get children(): ChildNode[] {\n\t      return this.#children;\n\t    }\n\t    /**\n", "     * Appends passed children to this node\n\t     *\n\t     * @param children - array of children to append\n\t     */\n\t    public append(...children: ChildNode[]): void {\n\t      /**\n\t       * If node is already a child of current node, remove it to append at the end\n\t       */\n\t      children.forEach(child => {\n\t        const index = this.children.indexOf(child);\n", "        if (index === -1) {\n\t          return;\n\t        }\n\t        this.children.splice(index, 1);\n\t      });\n\t      this.children.push(...children);\n\t      children.forEach(child => child.appendTo(this));\n\t    }\n\t    /**\n\t     * Removes a child from the parent\n", "     *\n\t     * @param child - child to remove\n\t     */\n\t    public removeChild(child: ChildNode): void {\n\t      const index = this.children.indexOf(child);\n\t      this.children.splice(index, 1);\n\t      child.remove();\n\t    }\n\t    /**\n\t     * Inserts new children after specified target\n", "     *\n\t     * @param target - target after which to insert new children\n\t     * @param children - children nodes to insert\n\t     */\n\t    public insertAfter(target: ChildNode, ...children: ChildNode[]): void {\n\t      /**\n\t       * If node is already a child of current node, remove it to append at the end\n\t       */\n\t      children.forEach(child => {\n\t        const index = this.children.indexOf(child);\n", "        if (index === -1) {\n\t          return;\n\t        }\n\t        this.children.splice(index, 1);\n\t      });\n\t      const index = this.children.indexOf(target);\n\t      this.children.splice(index + 1, 0, ...children);\n\t      children.forEach(child => child.appendTo(this));\n\t    }\n\t  };\n", "}\n"]}
{"filename": "src/entities/interfaces/ChildNode.ts", "chunked_list": ["import type { ParentNode } from './ParentNode';\n\timport { InlineNode } from './InlineNode';\n\t/**\n\t * Abstract child node interface\n\t */\n\texport interface ChildNode extends InlineNode {\n\t  /**\n\t   * Appends this node to passed parent node\n\t   *\n\t   * @param parent - new parent\n", "   */\n\t  appendTo(parent: ParentNode): void;\n\t  /**\n\t   * Removes this node from parent\n\t   */\n\t  remove(): void;\n\t  /**\n\t   * Node's parent\n\t   */\n\t  parent: ParentNode | null;\n", "}\n\texport interface ChildNodeConstructorOptions {\n\t  parent?: ParentNode;\n\t}\n\t/**\n\t * ChildNode decorator to mixin ChildNode's methods\n\t *\n\t * @param constructor - class to decorate\n\t * @example\n\t *\n", " * ```ts\n\t * // interface is required to let TS know about ChildNode's methods\n\t * interface MyNode extends ChildNode {}\n\t *\n\t * @ChildNode\n\t * class MyNode {}\n\t * ```\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any -- any type here is a TS requirement for mixin classes\n\texport function ChildNode<C extends { new(...args: any[]): InlineNode }>(constructor: C): C {\n", "  // eslint-disable-next-line @typescript-eslint/no-shadow\n\t  return class ChildNode extends constructor {\n\t    /**\n\t     * Node's parent\n\t     *\n\t     * @private\n\t     */\n\t    #parent: ParentNode | null;\n\t    /**\n\t     * @param args — constructor arguments\n", "     * @param {ParentNode} [args.parent] - optional node's parent\n\t     */\n\t    // Stryker disable next-line BlockStatement -- Styker's bug, see https://github.com/stryker-mutator/stryker-js/issues/2474\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- any type here is a TS requirement for mixin classes\n\t    constructor(...args: any[]) {\n\t      const { parent, ...rest } = args[0] ?? {};\n\t      super(rest);\n\t      this.#parent = parent ?? null;\n\t      this.parent?.append(this);\n\t    }\n", "    /**\n\t     * Returns node's parent\n\t     */\n\t    public get parent(): ParentNode | null {\n\t      return this.#parent;\n\t    }\n\t    /**\n\t     * Appends this node to passed parent node\n\t     *\n\t     * @param parent - new parent\n", "     */\n\t    public appendTo(parent: ParentNode): void {\n\t      if (this.parent === parent) {\n\t        return;\n\t      }\n\t      this.parent?.removeChild(this);\n\t      this.#parent = parent;\n\t      parent.append(this);\n\t    }\n\t    /**\n", "     * Removes this node from parent\n\t     */\n\t    public remove(): void {\n\t      const parent = this.parent;\n\t      this.#parent = null;\n\t      parent?.removeChild(this);\n\t    }\n\t  };\n\t}\n"]}
{"filename": "src/entities/ValueNode/ValueNode.spec.ts", "chunked_list": ["import { createValueNodeMock } from '../../utils/mocks/createValueNodeMock';\n\tdescribe('ValueNode', () => {\n\t  describe('.update()', () => {\n\t    it('should update existing data associated with this value node', () => {\n\t      // Arrange\n\t      const longitudeValueNode = createValueNodeMock({\n\t        value: 23.123,\n\t      });\n\t      const updatedLongitude = 23.456;\n\t      // Act\n", "      longitudeValueNode.update(updatedLongitude);\n\t      // Assert\n\t      expect(longitudeValueNode.serialized).toBe(updatedLongitude);\n\t    });\n\t  });\n\t  describe('.serialized', () => {\n\t    it('should return the serialized data associated with this value node', () => {\n\t      // Arrange\n\t      const longitude = 23.123;\n\t      const longitudeValueNode = createValueNodeMock({\n", "        value: longitude,\n\t      });\n\t      // Act\n\t      const serializedLongitude = longitudeValueNode.serialized;\n\t      // Assert\n\t      expect(serializedLongitude).toStrictEqual(longitude);\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/entities/ValueNode/index.ts", "chunked_list": ["import type { ValueNodeConstructorParameters } from './types';\n\t/**\n\t * ValueNode class represents a node in a tree-like structure, used to store and manipulate data associated with a BlockNode.\n\t * Unlike TextNode, changing the data of a ValueNode will replace the entire data in this node.\n\t * This can be useful for storing data that needs to be updated in its entirety, such as a link or other metadata associated with a BlockNode.\n\t */\n\texport class ValueNode<ValueType = unknown> {\n\t  /**\n\t   * Private field representing the data associated with this node\n\t   */\n", "  #value: ValueType;\n\t  /**\n\t   * Constructor for ValueNode class.\n\t   *\n\t   * @param args - ValueNode constructor arguments.\n\t   * @param args.value - The value of this value node.\n\t   */\n\t  constructor({ value }: ValueNodeConstructorParameters<ValueType>) {\n\t    this.#value = value;\n\t  }\n", "  /**\n\t   * Updates the data associated with this value node.\n\t   *\n\t   * @param value - The new value of this value node.\n\t   */\n\t  public update(value: ValueType): void {\n\t    this.#value = value;\n\t  }\n\t  /**\n\t   * Returns serialized data associated with this value node.\n", "   */\n\t  public get serialized(): ValueType {\n\t    return this.#value;\n\t  }\n\t}\n\texport type {\n\t  ValueNodeConstructorParameters\n\t};\n"]}
{"filename": "src/entities/ValueNode/types/ValueNodeConstructorParameters.ts", "chunked_list": ["/**\n\t * Type of the constructor parameters for a ValueNode.\n\t */\n\texport interface ValueNodeConstructorParameters<ValueType = unknown> {\n\t  /**\n\t   * The value of this value node.\n\t   */\n\t  value: ValueType;\n\t}\n"]}
{"filename": "src/entities/ValueNode/types/index.ts", "chunked_list": ["export { ValueNodeConstructorParameters } from './ValueNodeConstructorParameters';\n"]}
{"filename": "src/entities/FormattingNode/index.ts", "chunked_list": ["import {\n\t  FormattingNodeConstructorParameters,\n\t  InlineToolName,\n\t  InlineToolData\n\t} from './types';\n\timport { ChildNode, InlineFragment, InlineNode, InlineNodeSerialized, ParentNode } from '../interfaces';\n\texport * from './types';\n\t/**\n\t * We need to extend FormattingNode interface with ChildNode and ParentNode ones to use the methods from mixins\n\t */\n", "export interface FormattingNode extends ChildNode, ParentNode {}\n\t/**\n\t * FormattingNode class represents a node in a tree-like structure, used to store and manipulate formatted text content\n\t */\n\t@ParentNode\n\t@ChildNode\n\texport class FormattingNode implements InlineNode {\n\t  /**\n\t   * Private field representing the name of the formatting tool applied to the content\n\t   */\n", "  #tool: InlineToolName;\n\t  /**\n\t   * Any additional data associated with the formatting tool\n\t   */\n\t  #data?: InlineToolData;\n\t  /**\n\t   * Constructor for FormattingNode class.\n\t   *\n\t   * @param args - FormattingNode constructor arguments.\n\t   * @param args.tool - The name of the formatting tool applied to the content.\n", "   * @param args.data - Any additional data associated with the formatting.\n\t   */\n\t  constructor({ tool, data }: FormattingNodeConstructorParameters) {\n\t    this.#tool = tool;\n\t    this.#data = data;\n\t  }\n\t  /**\n\t   * Returns text value length of current node (including subtree)\n\t   */\n\t  public get length(): number {\n", "    return this.children.reduce((sum, child) => sum + child.length, 0);\n\t  }\n\t  /**\n\t   * Returns serialized value of the node: text and formatting fragments\n\t   */\n\t  public get serialized(): InlineNodeSerialized {\n\t    return {\n\t      text: this.getText(),\n\t      fragments: this.getFragments(),\n\t    };\n", "  }\n\t  /**\n\t   * Inserts text to the specified index, by default appends text to the end of the current value\n\t   *\n\t   * @param text - text to insert\n\t   * @param [index] - char index where to insert text\n\t   */\n\t  public insertText(text: string, index = this.length): void {\n\t    const [child, offset] = this.#findChildByIndex(index);\n\t    child?.insertText(text, index - offset);\n", "  }\n\t  /**\n\t   * Removes text form the specified range\n\t   *\n\t   * @param [start] - start char index of the range, by default 0\n\t   * @param [end] - end char index of the range, by default length of the text value\n\t   * @returns {string} removed text\n\t   */\n\t  public removeText(start = 0, end = this.length): string {\n\t    const result = this.#reduceChildrenInRange(\n", "      start,\n\t      end,\n\t      (acc, child, childStart, childEnd) => {\n\t        return acc + child.removeText(childStart, childEnd);\n\t      },\n\t      ''\n\t    );\n\t    if (this.length === 0) {\n\t      this.remove();\n\t    }\n", "    return result;\n\t  }\n\t  /**\n\t   * Returns text from the specified range\n\t   *\n\t   * @param [start] - start char index of the range, by default 0\n\t   * @param [end] - end char index of the range, by default length of the text value\n\t   */\n\t  public getText(start = 0, end = this.length): string {\n\t    return this.#reduceChildrenInRange(\n", "      start,\n\t      end,\n\t      (acc, child, childStart, childEnd) => {\n\t        return acc + child.getText(childStart, childEnd);\n\t      },\n\t      ''\n\t    );\n\t  }\n\t  /**\n\t   * Returns inline fragments for subtree including current node from the specified range\n", "   *\n\t   * @param [start] - start char index of the range, by default 0\n\t   * @param [end] - end char index of the range, by default length of the text value\n\t   */\n\t  public getFragments(start = 0, end = this.length): InlineFragment[] {\n\t    return this.#reduceChildrenInRange<InlineFragment[]>(\n\t      start,\n\t      end,\n\t      (acc, child, childStart, childEnd) => {\n\t        /**\n", "         * If child is not a FormattingNode, it doesn't include any fragments. So we skip it.\n\t         */\n\t        if (!(child instanceof FormattingNode)) {\n\t          return acc;\n\t        }\n\t        acc.push(...child.getFragments(childStart, childEnd));\n\t        return acc;\n\t      },\n\t      [ {\n\t        tool: this.#tool,\n", "        data: this.#data,\n\t        range: [start, end],\n\t      } ]\n\t    );\n\t  }\n\t  /**\n\t   * Splits current node by the specified index\n\t   *\n\t   * @param index - char index where to split the node\n\t   * @returns {FormattingNode | null} new node\n", "   */\n\t  public split(index: number): FormattingNode | null {\n\t    if (index === 0 || index === this.length) {\n\t      return null;\n\t    }\n\t    const newNode = new FormattingNode({\n\t      tool: this.#tool,\n\t      data: this.#data,\n\t    });\n\t    const [child, offset] = this.#findChildByIndex(index);\n", "    if (!child) {\n\t      return null;\n\t    }\n\t    // Have to save length as it is changed after split\n\t    const childLength = child.length;\n\t    const splitNode = child.split(index - offset);\n\t    let midNodeIndex = this.children.indexOf(child);\n\t    /**\n\t     * If node is split or if node is not split but index equals to child length, we should split children from the next node\n\t     */\n", "    if (splitNode || (index - offset === childLength)) {\n\t      midNodeIndex += 1;\n\t    }\n\t    newNode.append(...this.children.slice(midNodeIndex));\n\t    this.parent?.insertAfter(this, newNode);\n\t    return newNode;\n\t  }\n\t  /**\n\t   * Applies formatting to the text with specified inline tool in the specified range\n\t   *\n", "   * @param tool - name of inline tool to apply\n\t   * @param start - char start index of the range\n\t   * @param end - char end index of the range\n\t   * @param [data] - inline tool data if applicable\n\t   */\n\t  public format(tool: InlineToolName, start: number, end: number, data?: InlineToolData): InlineNode[] {\n\t    /**\n\t     * In case current tool is the same as new one, do nothing\n\t     */\n\t    if (tool === this.#tool) {\n", "      return [];\n\t    }\n\t    return this.#reduceChildrenInRange<InlineNode[]>(\n\t      start,\n\t      end,\n\t      (acc, child, childStart, childEnd) => {\n\t        acc.push(...child.format(tool, childStart, childEnd, data));\n\t        return acc;\n\t      },\n\t      []\n", "    );\n\t  }\n\t  /**\n\t   * Iterates through children in range and calls callback for each\n\t   *\n\t   * @param start - range start char index\n\t   * @param end - range end char index\n\t   * @param callback - callback to apply on children\n\t   * @param initialValue - initial accumulator value\n\t   * @private\n", "   */\n\t  #reduceChildrenInRange<Acc>(\n\t    start: number,\n\t    end: number,\n\t    callback: (acc: Acc, child: InlineNode, start: number, end: number) => Acc,\n\t    initialValue: Acc\n\t  ): Acc {\n\t    let result = initialValue;\n\t    for (const child of this.children) {\n\t      if (start < child.length && end > 0 && start < end) {\n", "        result = callback(result, child, Math.max(start, 0), Math.min(child.length, end));\n\t      }\n\t      start -= child.length;\n\t      end -= child.length;\n\t    }\n\t    return result;\n\t  }\n\t  /**\n\t   * Returns child by passed text index\n\t   *\n", "   * @param index - char index\n\t   * @private\n\t   */\n\t  #findChildByIndex(index: number): [child: InlineNode & ChildNode | null, offset: number] {\n\t    let totalLength = 0;\n\t    for (const child of this.children) {\n\t      if (index <= child.length + totalLength) {\n\t        return [child, totalLength];\n\t      }\n\t      totalLength += child.length;\n", "    }\n\t    return [null, totalLength];\n\t  }\n\t}\n"]}
{"filename": "src/entities/FormattingNode/FormattingNode.spec.ts", "chunked_list": ["import { beforeEach, describe, expect, it } from '@jest/globals';\n\timport { ParentNode } from '../interfaces';\n\timport { createInlineToolData, createInlineToolName, FormattingNode } from './index';\n\timport { TextNode } from '../TextNode';\n\tconst parentMock = {\n\t  insertAfter: jest.fn(),\n\t  removeChild: jest.fn(),\n\t  append: jest.fn(),\n\t  children: [],\n\t} as unknown as ParentNode;\n", "const createChildMock = (value: string): TextNode => ({\n\t  getText: jest.fn(() => value),\n\t  appendTo: jest.fn(),\n\t  insertText: jest.fn(),\n\t  removeText: jest.fn(),\n\t  split: jest.fn(() => null),\n\t  format: jest.fn(() => [ new FormattingNode({ tool: createInlineToolName('tool') }) ]),\n\t  length: value.length,\n\t} as unknown as TextNode);\n\tdescribe('FormattingNode', () => {\n", "  const childMock = createChildMock('Some text here. ');\n\t  const anotherChildMock = createChildMock('Another text here.');\n\t  const tool = createInlineToolName('bold');\n\t  const anotherTool = createInlineToolName('italic');\n\t  const data = createInlineToolData({});\n\t  let node: FormattingNode;\n\t  beforeEach(() => {\n\t    node = new FormattingNode({\n\t      tool,\n\t      data,\n", "      parent: parentMock as FormattingNode,\n\t      children: [childMock, anotherChildMock],\n\t    });\n\t    jest.clearAllMocks();\n\t  });\n\t  describe('.length', () => {\n\t    it('should return sum of lengths of children', () => {\n\t      expect(node.length).toEqual(childMock.length + anotherChildMock.length);\n\t    });\n\t  });\n", "  describe('.serialized', () => {\n\t    it('should return concatenated text of all fragments with fragments list describing formatting', () => {\n\t      const result = node.serialized;\n\t      expect(result).toEqual({\n\t        text: childMock.getText() + anotherChildMock.getText(),\n\t        fragments: [\n\t          {\n\t            tool,\n\t            data,\n\t            range: [0, node.length],\n", "          },\n\t        ],\n\t      });\n\t    });\n\t  });\n\t  describe('.insertText()', () => {\n\t    const newText = 'new text';\n\t    const index = 3;\n\t    it('should lead calling insertText() of the child with the passed index', () => {\n\t      node.insertText(newText, index);\n", "      expect(childMock.insertText).toBeCalledWith(newText, index);\n\t    });\n\t    it('should adjust index by child offset', () => {\n\t      const offset = childMock.length;\n\t      node.insertText(newText, index + offset);\n\t      expect(anotherChildMock.insertText).toBeCalledWith(newText, index);\n\t    });\n\t    it('should append text to the last child by default', () => {\n\t      node.insertText(newText);\n\t      expect(anotherChildMock.insertText).toBeCalledWith(newText, anotherChildMock.length);\n", "    });\n\t  });\n\t  describe('.removeText()', () => {\n\t    const start = 3;\n\t    const end = 5;\n\t    it('should remove text from appropriate child', () => {\n\t      node.removeText(start, end);\n\t      expect(childMock.removeText).toBeCalledWith(start, end);\n\t    });\n\t    it('should adjust indices by child offset', () => {\n", "      const offset = childMock.length;\n\t      node.removeText(offset + start, offset + end);\n\t      expect(anotherChildMock.removeText).toBeCalledWith(start, end);\n\t    });\n\t    it('should call removeText for each affected child', () => {\n\t      const offset = childMock.length;\n\t      node.removeText(start, offset + end);\n\t      expect(childMock.removeText).toBeCalledWith(start, offset);\n\t      expect(anotherChildMock.removeText).toBeCalledWith(0, end);\n\t    });\n", "    it('should remove all text by default', () => {\n\t      node.removeText();\n\t      expect(childMock.removeText).toBeCalledWith(0, childMock.length);\n\t      expect(anotherChildMock.removeText).toBeCalledWith(0, anotherChildMock.length);\n\t    });\n\t    it('should call remove() if length is 0 after removeText() call', () => {\n\t      const removeSpy = jest.spyOn(node, 'remove');\n\t      const lengthSpy = jest.spyOn(node, 'length', 'get').mockImplementation(() => 0);\n\t      node.removeText();\n\t      expect(removeSpy).toBeCalled();\n", "      removeSpy.mockRestore();\n\t      lengthSpy.mockRestore();\n\t    });\n\t  });\n\t  describe('.getText()', () => {\n\t    const start = 3;\n\t    const end = 5;\n\t    it('should call getText() for the relevant child', () => {\n\t      node.getText(start, end);\n\t      expect(childMock.getText).toBeCalledWith(start, end);\n", "    });\n\t    it('should adjust index by child offset', () => {\n\t      const offset = childMock.length;\n\t      node.getText(offset + start, offset + end);\n\t      expect(anotherChildMock.getText).toBeCalledWith(start, end);\n\t    });\n\t    it('should call getText for all relevant children', () => {\n\t      const offset = childMock.length;\n\t      node.getText(start, offset + end);\n\t      expect(childMock.getText).toBeCalledWith(start, offset);\n", "      expect(anotherChildMock.getText).toBeCalledWith(0, end);\n\t    });\n\t    it('should return all text by default', () => {\n\t      node.getText();\n\t      expect(childMock.getText).toBeCalledWith(0, childMock.length);\n\t      expect(anotherChildMock.getText).toBeCalledWith(0, anotherChildMock.length);\n\t    });\n\t  });\n\t  describe('.getFragments()', () => {\n\t    /**\n", "     * @todo\n\t     */\n\t    it.todo('should return fragments for sub-tree');\n\t    it('should return node\\'s fragment', () => {\n\t      const fragments = node.getFragments();\n\t      expect(fragments).toEqual([\n\t        {\n\t          tool,\n\t          data,\n\t          range: [0, node.length],\n", "        },\n\t      ]);\n\t    });\n\t  });\n\t  describe('.split()', () => {\n\t    const index = 5;\n\t    it('should not split (return null) if index is 0', () => {\n\t      const newNode = node.split(0);\n\t      expect(newNode).toBeNull();\n\t    });\n", "    it('should not split (return null) if index equals text length', () => {\n\t      const newNode = node.split(node.length);\n\t      expect(newNode).toBeNull();\n\t    });\n\t    it('should create new FormattingNode on split', () => {\n\t      const newNode = node.split(index);\n\t      expect(newNode).toBeInstanceOf(FormattingNode);\n\t    });\n\t    /**\n\t     * @todo check this and related cases with integration tests\n", "     */\n\t    it('should create new FormattingNode with children split from the original one', () => {\n\t      const newNode = node.split(childMock.length);\n\t      expect(newNode?.children).toEqual([ anotherChildMock ]);\n\t    });\n\t    it('should call split method of child containing the specified index', () => {\n\t      node.split(index);\n\t      expect(childMock.split).toBeCalledWith(index);\n\t    });\n\t    it('should insert new node to the parent', () => {\n", "      const newNode = node.split(index);\n\t      expect(parentMock.insertAfter).toBeCalledWith(node, newNode);\n\t    });\n\t  });\n\t  describe('.format()', () => {\n\t    const start = 3;\n\t    const end = 5;\n\t    it('should apply formatting to the relevant child', () => {\n\t      node.format(anotherTool, start, end);\n\t      expect(childMock.format).toBeCalledWith(anotherTool, start, end, undefined);\n", "    });\n\t    it('should adjust index by child offset', () => {\n\t      const offset = childMock.length;\n\t      node.format(anotherTool, offset + start, offset + end);\n\t      expect(anotherChildMock.format).toBeCalledWith(anotherTool, start, end, undefined);\n\t    });\n\t    it('should format all relevant children', () => {\n\t      const offset = childMock.length;\n\t      node.format(anotherTool, start, offset + end);\n\t      expect(childMock.format).toBeCalledWith(anotherTool, start, offset, undefined);\n", "      expect(anotherChildMock.format).toBeCalledWith(anotherTool, 0, end, undefined);\n\t    });\n\t    it('should do nothing if same tool is being applied', () => {\n\t      node.format(tool, start, end);\n\t      expect(childMock.format).not.toBeCalled();\n\t      expect(anotherChildMock.format).not.toBeCalled();\n\t    });\n\t    it('should return empty array if same tool is being applied', () => {\n\t      const result = node.format(tool, start, end);\n\t      expect(result).toHaveLength(0);\n", "    });\n\t    it('should return array of new formatting nodes', () => {\n\t      const result = node.format(anotherTool, start, end);\n\t      expect(result).toEqual(childMock.format(anotherTool, start, end));\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/entities/FormattingNode/types/InlineToolName.ts", "chunked_list": ["import { create, Nominal } from '../../../utils/Nominal';\n\t/**\n\t * Base type of the formatting node tool field\n\t */\n\ttype InlineToolNameBase = string;\n\t/**\n\t * Nominal type for the formatting node tool field\n\t */\n\texport type InlineToolName = Nominal<InlineToolNameBase, 'InlineToolName'>;\n\t/**\n", " * Function returns a value with the nominal FormattingNodeName type\n\t */\n\texport const createInlineToolName = create<InlineToolName>();\n"]}
{"filename": "src/entities/FormattingNode/types/index.ts", "chunked_list": ["export { FormattingNodeConstructorParameters } from './FormattingNodeConstructorParameters';\n\texport { InlineToolName, createInlineToolName } from './InlineToolName';\n\texport { InlineToolData, createInlineToolData } from './InlineToolData';\n"]}
{"filename": "src/entities/FormattingNode/types/FormattingNodeConstructorParameters.ts", "chunked_list": ["import { InlineToolName } from './InlineToolName';\n\timport { InlineToolData } from './InlineToolData';\n\timport type { ChildNodeConstructorOptions, ParentNodeConstructorOptions } from '../../interfaces';\n\texport interface FormattingNodeConstructorParameters extends ChildNodeConstructorOptions, ParentNodeConstructorOptions {\n\t  /**\n\t   * The name of the formatting tool applied to the content\n\t   */\n\t  tool: InlineToolName;\n\t  /**\n\t   * Any additional data associated with the formatting\n", "   */\n\t  data?: InlineToolData;\n\t}\n"]}
{"filename": "src/entities/FormattingNode/types/InlineToolData.ts", "chunked_list": ["import { create, Nominal } from '../../../utils/Nominal';\n\t/**\n\t * Base type for Inline Tool data\n\t */\n\ttype InlineToolDataBase = Record<string, unknown>;\n\t/**\n\t * Nominal type for Inline Tool data\n\t */\n\texport type InlineToolData = Nominal<InlineToolDataBase, 'InlineToolData'>;\n\t/**\n", " * Function to cast values to InlineToolData type\n\t */\n\texport const createInlineToolData = create<InlineToolData>();\n"]}
{"filename": "src/entities/BlockTune/BlockTune.spec.ts", "chunked_list": ["import { createBlockTuneName } from './index';\n\timport { createBlockTuneMock } from '../../utils/mocks/createBlockTuneMock';\n\tdescribe('BlockTune', () => {\n\t  describe('.update()', () => {\n\t    it('should add field to data object by key if it doesn\\'t exist', () => {\n\t      // Arrange\n\t      const blockTune = createBlockTuneMock({\n\t        data: {},\n\t      });\n\t      // Act\n", "      blockTune.update('align', 'left');\n\t      // Assert\n\t      expect(blockTune.serialized.data).toEqual({\n\t        align: 'left',\n\t      });\n\t    });\n\t    it('should update field in data object by key', () => {\n\t      // Arrange\n\t      const blockTune = createBlockTuneMock({\n\t        data: {\n", "          align: 'center',\n\t        },\n\t      });\n\t      // Act\n\t      blockTune.update('align', 'right');\n\t      // Assert\n\t      expect(blockTune.serialized.data).toEqual({\n\t        align: 'right',\n\t      });\n\t    });\n", "  });\n\t  describe('.serialized', () => {\n\t    it('should return serialized version of the BlockTune', () => {\n\t      // Arrange\n\t      const tune = createBlockTuneMock({\n\t        name: createBlockTuneName('styling'),\n\t        data: {\n\t          background: 'transparent',\n\t        },\n\t      });\n", "      // Act\n\t      const tuneSerialized = tune.serialized;\n\t      // Assert\n\t      expect(tuneSerialized).toEqual(\n\t        {\n\t          name: 'styling',\n\t          data: {\n\t            background: 'transparent',\n\t          },\n\t        }\n", "      );\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/entities/BlockTune/index.ts", "chunked_list": ["import { BlockTuneConstructorParameters, BlockTuneName, BlockTuneSerialized, createBlockTuneName } from './types';\n\t/**\n\t * BlockTune class represents a set of additional information associated with a BlockNode.\n\t * This information can be used by a BlockTool to modify the behavior of the BlockNode.\n\t */\n\texport class BlockTune {\n\t  /**\n\t   * Private field representing the name of the tune\n\t   */\n\t  #name: BlockTuneName;\n", "  /**\n\t   * Private field representing any additional data associated with the tune\n\t   */\n\t  #data: Record<string, unknown>;\n\t  /**\n\t   * Constructor for BlockTune class.\n\t   *\n\t   * @param args - BlockTune constructor arguments.\n\t   * @param args.name - The name of the tune.\n\t   * @param args.data - Any additional data associated with the tune.\n", "   */\n\t  constructor({ name, data }: BlockTuneConstructorParameters) {\n\t    this.#name = name;\n\t    this.#data = data;\n\t  }\n\t  /**\n\t   * Updates data associated with the tune.\n\t   *\n\t   * @param key - The key of the data to update\n\t   * @param value - The value to update the data with\n", "   */\n\t  public update(key: string, value: unknown): void {\n\t    this.#data[key] = value;\n\t  }\n\t  /**\n\t   * Returns serialized version of the BlockTune.\n\t   */\n\t  public get serialized(): BlockTuneSerialized {\n\t    return {\n\t      name: this.#name,\n", "      data: this.#data,\n\t    };\n\t  }\n\t}\n\texport {\n\t  BlockTuneName,\n\t  createBlockTuneName\n\t};\n\texport type {\n\t  BlockTuneSerialized\n", "};\n"]}
{"filename": "src/entities/BlockTune/types/BlockTuneName.ts", "chunked_list": ["import { Nominal, create } from '../../../utils/Nominal';\n\t/**\n\t * Base type of the block tune name field\n\t */\n\ttype BlockTuneNameBase = string;\n\t/**\n\t * Nominal type for the block tune name field\n\t */\n\texport type BlockTuneName = Nominal<BlockTuneNameBase, 'BlockTuneName'>;\n\t/**\n", " * Function returns a value with the nominal BlockTuneName type\n\t */\n\texport const createBlockTuneName = create<BlockTuneName>();\n"]}
{"filename": "src/entities/BlockTune/types/BlockTuneConstructorParameters.ts", "chunked_list": ["import { BlockTuneName } from './BlockTuneName';\n\texport interface BlockTuneConstructorParameters {\n\t  /**\n\t   * The name of the tune\n\t   */\n\t  name: BlockTuneName;\n\t  /**\n\t   * Any additional data associated with the tune\n\t   */\n\t  data: Record<string, unknown>;\n", "}\n"]}
{"filename": "src/entities/BlockTune/types/BlockTuneSerialized.ts", "chunked_list": ["/**\n\t * BlockTuneSerialized represents a serialized version of a BlockTune.\n\t */\n\texport interface BlockTuneSerialized {\n\t  /**\n\t   * The name of the tune.\n\t   * Serialized as a string.\n\t   */\n\t  name: string;\n\t  /**\n", "   * Any additional data associated with the tune.\n\t   */\n\t  data: Record<string, unknown>;\n\t}\n"]}
{"filename": "src/entities/BlockTune/types/index.ts", "chunked_list": ["export { BlockTuneConstructorParameters } from './BlockTuneConstructorParameters';\n\texport { BlockTuneName, createBlockTuneName } from './BlockTuneName';\n\texport { BlockTuneSerialized } from './BlockTuneSerialized';\n"]}
{"filename": "src/entities/TextNode/TextNode.spec.ts", "chunked_list": ["import { describe, it, expect, beforeEach } from '@jest/globals';\n\timport { TextNode } from './index';\n\timport { createInlineToolName, FormattingNode } from '../FormattingNode';\n\timport type { ParentNode } from '../interfaces';\n\tdescribe('TextNode', () => {\n\t  const initialText = 'initial text';\n\t  const text = 'some text';\n\t  const parentMock = {\n\t    insertAfter: jest.fn(),\n\t    removeChild: jest.fn(),\n", "    append: jest.fn(),\n\t    children: [],\n\t  } as unknown as ParentNode;\n\t  let node: TextNode;\n\t  beforeEach(() => {\n\t    node = new TextNode({\n\t      value: initialText,\n\t      parent: parentMock as FormattingNode,\n\t    });\n\t  });\n", "  it('should have empty value by default', () => {\n\t    node = new TextNode();\n\t    expect(node.getText()).toEqual('');\n\t  });\n\t  describe('.insertText()', () => {\n\t    it('should set text to value if node is empty', () => {\n\t      node = new TextNode();\n\t      node.insertText(text);\n\t      expect(node.getText()).toEqual(text);\n\t    });\n", "    it('should append text if not empty', () => {\n\t      node.insertText(text);\n\t      expect(node.getText()).toEqual(initialText + text);\n\t    });\n\t    it('should prepend text if index is 0 and node is not empty', () => {\n\t      node.insertText(text, 0);\n\t      expect(node.getText()).toEqual(text + initialText);\n\t    });\n\t    it('should insert text at index if not empty', () => {\n\t      const index = 5;\n", "      node.insertText(text, index);\n\t      expect(node.getText()).toEqual(initialText.slice(0, index) + text + initialText.slice(index));\n\t    });\n\t    it('should throw an error if index is less than 0', () => {\n\t      const f = (): void => node.insertText(text, -1);\n\t      expect(f).toThrowError();\n\t    });\n\t    it('should throw an error if index is greater than node length', () => {\n\t      const f = (): void => node.insertText(text, initialText.length + 1);\n\t      expect(f).toThrowError();\n", "    });\n\t  });\n\t  describe('.getText()', () => {\n\t    it('should return sliced value if start provided', () => {\n\t      const start = 5;\n\t      expect(node.getText(start)).toEqual(initialText.slice(start));\n\t    });\n\t    it('should return sliced value if end provided', () => {\n\t      const end = 6;\n\t      expect(node.getText(0, end)).toEqual(initialText.slice(0, end));\n", "    });\n\t    it('should return sliced value if full range provided', () => {\n\t      const start = 3;\n\t      const end = 9;\n\t      expect(node.getText(start, end)).toEqual(initialText.slice(start, end));\n\t    });\n\t    it('should throw an error if start is invalid index', () => {\n\t      expect(() => node.getText(-1)).toThrowError();\n\t      expect(() => node.getText(initialText.length + 1)).toThrowError();\n\t    });\n", "    it('should throw an error if end is invalid index', () => {\n\t      expect(() => node.getText(0, initialText.length + 1)).toThrowError();\n\t    });\n\t    it('should throw an error if end index is greater than start index', () => {\n\t      const start = 5;\n\t      const end = 3;\n\t      expect(() => node.getText(start, end)).toThrowError();\n\t    });\n\t    it('should not throw an error if end index is equal to start index', () => {\n\t      const start = 5;\n", "      const end = 5;\n\t      expect(() => node.getText(start, end)).not.toThrowError();\n\t    });\n\t  });\n\t  describe('.removeText()', () => {\n\t    it('should remove all text by default', () => {\n\t      node.removeText();\n\t      expect(node.getText()).toEqual('');\n\t    });\n\t    it('should remove text from specified index', () => {\n", "      const start = 3;\n\t      node.removeText(start);\n\t      expect(node.getText()).toEqual(initialText.slice(0, start));\n\t    });\n\t    it('should remove text from 0 to specified end index', () => {\n\t      const end = 8;\n\t      node.removeText(0, end);\n\t      expect(node.getText()).toEqual(initialText.slice(end));\n\t    });\n\t    it('should remove text from specified start and end indecies', () => {\n", "      const start = 3;\n\t      const end = 8;\n\t      node.removeText(start, end);\n\t      expect(node.getText()).toEqual(initialText.slice(0, start) + initialText.slice(end));\n\t    });\n\t    it('should call remove() method if node is empty after removeText() call', () => {\n\t      jest.spyOn(node, 'remove');\n\t      node.removeText();\n\t      expect(node.remove).toBeCalled();\n\t    });\n", "  });\n\t  describe('.format()', () => {\n\t    it('should return just one FormattingNode, if formatting full TextNode', () => {\n\t      const name = createInlineToolName('bold');\n\t      const fragments = node.format(name, 0, initialText.length);\n\t      expect(fragments).toHaveLength(1);\n\t      expect(fragments[0]).toBeInstanceOf(FormattingNode);\n\t    });\n\t    it('should return two fragments if formatting from the start, but not to the end', () => {\n\t      const name = createInlineToolName('bold');\n", "      const end = 5;\n\t      const fragments = node.format(name, 0, end);\n\t      expect(fragments).toHaveLength(2);\n\t      expect(fragments[0]).toBeInstanceOf(FormattingNode);\n\t      expect(fragments[1]).toBeInstanceOf(TextNode);\n\t    });\n\t    it('should return two fragments if formatting to the end, but not from the start', () => {\n\t      const name = createInlineToolName('bold');\n\t      const start = 5;\n\t      const fragments = node.format(name, start, initialText.length);\n", "      expect(fragments).toHaveLength(2);\n\t      expect(fragments[0]).toBeInstanceOf(TextNode);\n\t      expect(fragments[1]).toBeInstanceOf(FormattingNode);\n\t    });\n\t    it('should return three fragments if formatting in the middle', () => {\n\t      const name = createInlineToolName('bold');\n\t      const start = 5;\n\t      const end = 8;\n\t      const fragments = node.format(name, start, end);\n\t      // eslint-disable-next-line @typescript-eslint/no-magic-numbers\n", "      expect(fragments).toHaveLength(3);\n\t      expect(fragments[0]).toBeInstanceOf(TextNode);\n\t      expect(fragments[1]).toBeInstanceOf(FormattingNode);\n\t      expect(fragments[2]).toBeInstanceOf(TextNode);\n\t    });\n\t    it('should return FormattingNode with a TextNode as a child with correct text value', () => {\n\t      const name = createInlineToolName('bold');\n\t      const start = 5;\n\t      const end = 8;\n\t      const fragments = node.format(name, start, end);\n", "      const formattingNode = fragments[1] as FormattingNode;\n\t      expect(formattingNode.children[0].getText()).toEqual(initialText.slice(start, end));\n\t    });\n\t    it('should call parent\\'s insertAfter with new nodes', () => {\n\t      const name = createInlineToolName('bold');\n\t      const start = 5;\n\t      const end = 8;\n\t      const fragments = node.format(name, start, end);\n\t      expect(parentMock.insertAfter).toBeCalledWith(node, ...fragments);\n\t    });\n", "  });\n\t  describe('.split()', () => {\n\t    const index = 5;\n\t    it('should not split (return null) if index is 0', () => {\n\t      const newNode = node.split(0);\n\t      expect(newNode).toBeNull();\n\t    });\n\t    it('should not split (return null) if index equals text length', () => {\n\t      const newNode = node.split(initialText.length);\n\t      expect(newNode).toBeNull();\n", "    });\n\t    it('should create new TextNode on split', () => {\n\t      const newNode = node.split(index);\n\t      expect(newNode).toBeInstanceOf(TextNode);\n\t    });\n\t    it('should create new TextNode with text value splitted from the original one', () => {\n\t      const newNode = node.split(index);\n\t      expect(newNode?.getText()).toEqual(initialText.slice(index));\n\t    });\n\t    it('should remove split text value from the original node', () => {\n", "      node.split(index);\n\t      expect(node.getText()).toEqual(initialText.slice(0, index));\n\t    });\n\t    it('should insert new node to the parent', () => {\n\t      const newNode = node.split(index);\n\t      expect(parentMock.insertAfter).toBeCalledWith(node, newNode);\n\t    });\n\t  });\n\t  describe('.serialized', () => {\n\t    it('should return text value and empty array of fragments', () => {\n", "      const result = node.serialized;\n\t      expect(result).toEqual({\n\t        text: initialText,\n\t        fragments: [],\n\t      });\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/entities/TextNode/index.ts", "chunked_list": ["import { FormattingNode, InlineToolName, InlineToolData } from '../FormattingNode';\n\timport { TextNodeConstructorParameters } from './types';\n\timport { ChildNode, InlineNode, InlineNodeSerialized } from '../interfaces';\n\texport * from './types';\n\texport interface TextNode extends ChildNode {}\n\t/**\n\t * TextNode class represents a node in a tree-like structure, used to store and manipulate text content.\n\t */\n\t@ChildNode\n\texport class TextNode implements InlineNode {\n", "  /**\n\t   * Private field representing the text content of the node\n\t   */\n\t  #value: string;\n\t  /**\n\t   * Constructor for TextNode class\n\t   *\n\t   * @param args - TextNode constructor arguments.\n\t   * @param args.value - Text content of the node.\n\t   */\n", "  constructor({ value = '' }: TextNodeConstructorParameters = {}) {\n\t    this.#value = value;\n\t  }\n\t  /**\n\t   * Returns length of the text\n\t   */\n\t  public get length(): number {\n\t    return this.#value.length;\n\t  }\n\t  /**\n", "   * Returns serialized value of the node\n\t   */\n\t  public get serialized(): InlineNodeSerialized {\n\t    return {\n\t      text: this.getText(),\n\t      // No fragments for text node\n\t      fragments: [],\n\t    };\n\t  }\n\t  /**\n", "   * Inserts text to specified position. By default, appends new text to the current value\n\t   *\n\t   * @param text - text to insert\n\t   * @param [index] - char start index\n\t   */\n\t  public insertText(text: string, index = this.length): void {\n\t    this.#validateIndex(index);\n\t    this.#value = this.#value.slice(0, index) + text + this.#value.slice(index);\n\t  }\n\t  /**\n", "   * Remove text from specified range\n\t   *\n\t   * @param [start] - start char index of the range, 0 by default\n\t   * @param [end] - end char index of the range, text length by default\n\t   * @returns {string} removed text\n\t   */\n\t  public removeText(start = 0, end = this.length): string {\n\t    this.#validateIndex(start);\n\t    this.#validateIndex(end);\n\t    const removedValue = this.#value.slice(start, end);\n", "    this.#value = this.#value.slice(0, start) + this.#value.slice(end);\n\t    if (this.length === 0) {\n\t      this.remove();\n\t    }\n\t    return removedValue;\n\t  }\n\t  /**\n\t   * Returns text value from the specified range\n\t   *\n\t   * @param [start] - start char index of the range, 0 by default\n", "   * @param [end] - end char index of the range, text length by default\n\t   */\n\t  public getText(start = 0, end = this.length): string {\n\t    if (start > end) {\n\t      // Stryker disable next-line StringLiteral\n\t      throw new Error(`Start index ${start} should be less or equal than end index ${end}`);\n\t    }\n\t    this.#validateIndex(start);\n\t    this.#validateIndex(end);\n\t    return this.#value.slice(start, end);\n", "  }\n\t  /**\n\t   * Applies inline tool for specified range\n\t   *\n\t   * @param tool - name of the tool to apply\n\t   * @param start - start char index of the range\n\t   * @param end - end char index of the range\n\t   * @param [data] - inline tool data if applicable\n\t   * @returns {InlineNode[]} - array of nodes after applied formatting\n\t   */\n", "  public format(tool: InlineToolName, start: number, end: number, data?: InlineToolData): InlineNode[] {\n\t    this.#validateIndex(start);\n\t    this.#validateIndex(end);\n\t    const formattingNode = new FormattingNode({\n\t      tool,\n\t      data,\n\t    });\n\t    const fragments: ChildNode[] = [];\n\t    /**\n\t     * If start index is greater than 0, we need extract part of the text before the start index\n", "     */\n\t    if (start > 0) {\n\t      fragments.push(this.#cloneContents(0, start));\n\t    }\n\t    /**\n\t     * Formatting is applied to the specified range\n\t     */\n\t    const formattedFragment = this.#cloneContents(start, end);\n\t    formattedFragment.appendTo(formattingNode);\n\t    fragments.push(formattingNode);\n", "    /**\n\t     * If end index is less than the text length, we need to extract part of the text after the end index\n\t     */\n\t    if (end < this.length) {\n\t      fragments.push(this.#cloneContents(end, this.length));\n\t    }\n\t    this.parent?.insertAfter(this, ...fragments);\n\t    this.remove();\n\t    return fragments;\n\t  }\n", "  /**\n\t   * Splits current node into two nodes by the specified index\n\t   *\n\t   * @param index - char index where to split\n\t   * @returns {TextNode|null} - new node or null if split is not applicable\n\t   */\n\t  public split(index: number): TextNode | null {\n\t    if (index === 0 || index === this.length) {\n\t      return null;\n\t    }\n", "    const newNode = new TextNode();\n\t    const text = this.removeText(index);\n\t    newNode.insertText(text);\n\t    this.parent?.insertAfter(this, newNode);\n\t    return newNode;\n\t  }\n\t  /**\n\t   * Validates index\n\t   *\n\t   * @param index - char index to validate\n", "   * @throws Error if index is out of the text length\n\t   */\n\t  #validateIndex(index: number): void {\n\t    if (index < 0 || index > this.length) {\n\t      // Stryker disable next-line StringLiteral\n\t      throw new Error(`Index ${index} is not in valid range [0, ${this.length}]`);\n\t    }\n\t  }\n\t  /**\n\t   * Clones specified range to a new TextNode\n", "   *\n\t   * @param start - start char index of the range\n\t   * @param end - end char index of the range\n\t   */\n\t  #cloneContents(start: number, end: number): TextNode {\n\t    return new TextNode({\n\t      value: this.getText(start, end),\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/entities/TextNode/types/TextNodeConstructorParameters.ts", "chunked_list": ["import type { ChildNodeConstructorOptions } from '../../interfaces';\n\texport interface TextNodeConstructorParameters extends ChildNodeConstructorOptions {\n\t  /**\n\t   * Text content of the node\n\t   */\n\t  value?: string;\n\t}\n"]}
{"filename": "src/entities/TextNode/types/index.ts", "chunked_list": ["export { TextNodeConstructorParameters } from './TextNodeConstructorParameters';\n"]}
