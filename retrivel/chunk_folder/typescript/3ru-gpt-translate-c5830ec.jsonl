{"filename": "website/src/middleware.ts", "chunked_list": ["import type { NextRequest } from 'next/server'\n\timport { NextResponse } from 'next/server'\n\texport function middleware(request: NextRequest) {\n\t  if (request.nextUrl.pathname === '/') {\n\t    return NextResponse.redirect(\n\t      new URL('/docs/overview/getting-started', request.url),\n\t    )\n\t  }\n\t}\n\texport const config = {\n", "  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],\n\t}\n"]}
{"filename": "src/gpt.ts", "chunked_list": ["import { error, getInput, info, notice, setFailed } from '@actions/core'\n\timport {\n\t  ChatCompletionRequestMessageRoleEnum,\n\t  Configuration,\n\t  OpenAIApi,\n\t} from 'openai'\n\timport { encode } from 'gpt-3-encoder'\n\tconst API_KEY = getInput('apikey')\n\tconst BASE_PATH = getInput('basePath') || 'https://api.openai.com/v1'\n\tconst PROMPT =\n", "  getInput('prompt') ||\n\t  'Please translate the given text into naturalistic {targetLanguage}.'\n\tif (!API_KEY) {\n\t  setFailed('Error: API_KEY could not be retrieved.')\n\t}\n\tconst configuration = new Configuration({\n\t  apiKey: API_KEY,\n\t  basePath: BASE_PATH,\n\t})\n\tconst openAIApi = new OpenAIApi(configuration)\n", "export const askGPT = async (text: string, prompt: string): Promise<string> => {\n\t  const {\n\t    data: {\n\t      choices: [{ message: { content: content } = { content: '' } }],\n\t    },\n\t  } = await openAIApi\n\t    .createChatCompletion({\n\t      model: 'gpt-3.5-turbo-16k',\n\t      messages: [\n\t        {\n", "          role: ChatCompletionRequestMessageRoleEnum.System,\n\t          content: prompt,\n\t        },\n\t        { role: ChatCompletionRequestMessageRoleEnum.User, content: text },\n\t      ],\n\t      top_p: 0.5,\n\t    })\n\t    .catch((err) => {\n\t      error(err)\n\t      notice(\n", "        'If the status code is 400, the file exceeds 16,000 tokens without line breaks. \\nPlease open one line as appropriate.',\n\t      )\n\t      process.exit(1)\n\t    })\n\t  if (content === '') {\n\t    info('Possible Error: Translation result is empty')\n\t  }\n\t  return content\n\t}\n\texport const gptTranslate = async (\n", "  text: string,\n\t  targetLanguage: string,\n\t  targetFileExt: string, // filename extension. Must be within availableFileExtensions.\n\t  maxToken = 16000,\n\t  splitter = `\\n\\n`,\n\t): Promise<string> => {\n\t  const prompt = PROMPT.replaceAll(\n\t    '{targetLanguage}',\n\t    targetLanguage,\n\t  ).replaceAll('{targetFileExt}', targetFileExt)\n", "  let translated = ''\n\t  let chunk = ''\n\t  info('Start translating...')\n\t  const contentChunks = text.split(splitter)\n\t  for (let i = 0; i < contentChunks.length; i++) {\n\t    if (encode(chunk + contentChunks[i]).length > maxToken) {\n\t      const translatedContent = await askGPT(chunk, prompt)\n\t      translated += translatedContent + splitter\n\t      chunk = ''\n\t    }\n", "    chunk += contentChunks[i] + (i < contentChunks.length - 1 ? splitter : '')\n\t  }\n\t  translated += await askGPT(chunk, prompt)\n\t  info('Translation completed!')\n\t  return translated\n\t}\n"]}
{"filename": "src/translate.ts", "chunked_list": ["import fs from 'fs/promises'\n\timport path from 'path'\n\timport { gptTranslate } from './gpt'\n\timport { generatePRBody, isPR } from './utils'\n\timport {\n\t  gitCheckout,\n\t  gitCommitPush,\n\t  gitCreateBranch,\n\t  gitCreatePullRequest,\n\t  gitPostComment,\n", "  gitSetConfig,\n\t} from './git'\n\timport { context } from '@actions/github'\n\timport {\n\t  createFile,\n\t  generateOutputFilePaths,\n\t  getFilePathsWithExtension,\n\t  isFileExists,\n\t} from './file'\n\timport { info } from '@actions/core'\n", "export const translateByCommand = async (\n\t  inputFilePath: string,\n\t  outputFilePath: string,\n\t  targetLang: string,\n\t) => {\n\t  await gitSetConfig()\n\t  const branch = isPR() ? await gitCheckout() : await gitCreateBranch()\n\t  const isMultipleFileSelected = path.basename(inputFilePath).includes('*')\n\t  const inputFilePaths = isMultipleFileSelected\n\t    ? await getFilePathsWithExtension(\n", "        path.dirname(inputFilePath),\n\t        path.extname(inputFilePath),\n\t      )\n\t    : [inputFilePath]\n\t  const outputFilePaths = isMultipleFileSelected\n\t    ? generateOutputFilePaths(inputFilePaths, outputFilePath)\n\t    : [outputFilePath]\n\t  await createTranslatedFiles(inputFilePaths, outputFilePaths, targetLang)\n\t  await gitCommitPush(branch, outputFilePaths)\n\t  if (isPR()) {\n", "    await gitPostComment('🎉Translation completed!')\n\t    return\n\t  }\n\t  const issueNumber = context.issue.number\n\t  const title = '🌐 Add LLM Translations'\n\t  const body = generatePRBody(\n\t    inputFilePaths,\n\t    outputFilePaths,\n\t    targetLang,\n\t    issueNumber,\n", "  )\n\t  await gitCreatePullRequest(branch, title, body)\n\t  await gitPostComment('🎉Translation PR created!')\n\t}\n\texport const translateByManual = async (\n\t  inputFiles: string[],\n\t  outputFiles: string[],\n\t  languages: string[],\n\t) => {\n\t  if (!inputFiles.length) {\n", "    info('No input files specified. Skip translation.')\n\t    return\n\t  }\n\t  if (!inputFiles.length || !outputFiles.length || !languages.length) {\n\t    throw new Error(\n\t      'Error: For push execution, all three parameters (inputFiles, outputFiles and language ) are required',\n\t    )\n\t  }\n\t  if (outputFiles.length !== languages.length) {\n\t    throw new Error('Error: outputFiles and language must be same length.')\n", "  }\n\t  const outputFilePaths: string[][] = outputFiles.map((outputFile) => {\n\t    return generateOutputFilePaths(inputFiles, outputFile)\n\t  })\n\t  // TODO: Dealing with request limits (503 error)\n\t  await Promise.all(\n\t    languages.map((language, index) =>\n\t      createTranslatedFiles(inputFiles, outputFilePaths[index], language),\n\t    ),\n\t  )\n", "  await gitSetConfig()\n\t  const branch = await gitCreateBranch()\n\t  const title = '🌐 Add LLM Translations'\n\t  await gitCommitPush(branch, outputFilePaths.flat())\n\t  const body = generatePRBody(inputFiles, outputFilePaths, languages)\n\t  await gitCreatePullRequest(branch, title, body)\n\t}\n\t/*\n\t * Parallel creation of translation files\n\t * inputFilePaths and outputFilePaths must be same length and same order\n", " */\n\texport const createTranslatedFiles = async (\n\t  inputFilePaths: string[],\n\t  outputFilePaths: string[],\n\t  targetLang: string,\n\t) => {\n\t  const processFiles = inputFilePaths.map(async (inputFile, i) => {\n\t    const content = await fs.readFile(inputFile, 'utf-8')\n\t    const ext = path.extname(inputFile)\n\t    const translated = await gptTranslate(content, targetLang, ext)\n", "    // Check if the translation is same as the original\n\t    if (await isFileExists(outputFilePaths[i])) {\n\t      const fileContent = await fs.readFile(outputFilePaths[i], 'utf-8')\n\t      if (fileContent === translated) {\n\t        info(\n\t          '⛔ The result of translation was same as the existed output file.',\n\t        )\n\t        return\n\t      }\n\t    }\n", "    info(`Create Translated File ${outputFilePaths[i]}`)\n\t    await createFile(translated, outputFilePaths[i])\n\t  })\n\t  await Promise.all(processFiles)\n\t}\n"]}
{"filename": "src/const.ts", "chunked_list": ["// File extensions for translation\n\texport const availableFileExtensions = ['.md', '.mdx']\n"]}
{"filename": "src/git.ts", "chunked_list": ["import { exec } from '@actions/exec'\n\timport { context, getOctokit } from '@actions/github'\n\timport { setFailed, info, getInput } from '@actions/core'\n\timport { randomUUID } from 'crypto'\n\tconst GITHUB_TOKEN = getInput('token')\n\tif (!GITHUB_TOKEN) {\n\t  setFailed('Error: GITHUB_TOKEN could not be retrieved.')\n\t}\n\texport const gitSetConfig = async () => {\n\t  info('Setting git config...')\n", "  // TODO: Get command user info from\n\t  // const { rest } = getOctokit(GITHUB_TOKEN)\n\t  // const { data: user } = await rest.users.getAuthenticated()\n\t  const user = {\n\t    name: 'github-actions[bot]',\n\t    email: '41898282+github-actions[bot]@users.noreply.github.com',\n\t  }\n\t  await exec('git', ['config', 'user.name', user.name])\n\t  await exec('git', ['config', 'user.email', user.email])\n\t}\n", "export const gitCheckout = async () => {\n\t  info('Checking out...')\n\t  const {\n\t    rest: { pulls },\n\t  } = getOctokit(GITHUB_TOKEN)\n\t  const {\n\t    data: {\n\t      head: { ref: branch },\n\t    },\n\t  } = await pulls.get({\n", "    ...context.repo,\n\t    pull_number: context.issue.number,\n\t  })\n\t  await exec('git', ['fetch', 'origin', branch])\n\t  await exec('git', ['checkout', branch])\n\t  return branch as string\n\t}\n\texport const gitCreateBranch = async () => {\n\t  info('Creating branch...')\n\t  const branch = `gt-${randomUUID()}`\n", "  await exec('git', ['checkout', '-b', branch])\n\t  return branch\n\t}\n\texport const gitCommitPush = async (\n\t  branch: string,\n\t  filePath: string | string[],\n\t) => {\n\t  info('Committing and pushing...')\n\t  if (Array.isArray(filePath)) {\n\t    await exec('git', ['add', ...filePath])\n", "  } else {\n\t    await exec('git', ['add', filePath])\n\t  }\n\t  await exec('git', ['commit', '-m', `💬Generate LLM translations`])\n\t  await exec('git', ['push', 'origin', branch])\n\t}\n\texport const gitCreatePullRequest = async (\n\t  head: string,\n\t  title: string,\n\t  body: string,\n", ") => {\n\t  const {\n\t    rest: { pulls, repos },\n\t  } = getOctokit(GITHUB_TOKEN)\n\t  const {\n\t    data: { default_branch: base },\n\t  } = await repos.get(context.repo)\n\t  info(`Creating pull request from ${base} to ${head}...`)\n\t  await pulls.create({\n\t    ...context.repo,\n", "    head,\n\t    base,\n\t    title,\n\t    body,\n\t  })\n\t}\n\texport const gitPostComment = async (message: string) => {\n\t  const {\n\t    rest: { issues },\n\t  } = getOctokit(GITHUB_TOKEN)\n", "  await issues.createComment({\n\t    ...context.repo,\n\t    issue_number: context.issue.number,\n\t    body: message,\n\t  })\n\t}\n\texport const authorizeUser = async () => {\n\t  const {\n\t    rest: { repos },\n\t  } = getOctokit(GITHUB_TOKEN)\n", "  const { data: user } = await repos.getCollaboratorPermissionLevel({\n\t    ...context.repo,\n\t    username: context.actor,\n\t  })\n\t  info(`User permission: ${user.permission}`)\n\t  return user.permission === 'admin' || user.permission === 'write'\n\t}\n"]}
{"filename": "src/validate.ts", "chunked_list": ["import { availableFileExtensions } from './const'\n\timport path from 'path'\n\timport { postError, removeSymbols } from './utils'\n\timport { COMMAND_USAGE, INVALID_FILE_EXTENSION } from './error'\n\texport const isValidFileExt = (filename: string): boolean => {\n\t  // Allow input file extension inheritance by asterisk in addition to normal file formats\n\t  const fileExts = [...availableFileExtensions, '*']\n\t  return fileExts.some((type) => filename.endsWith(type))\n\t}\n\texport const commandValidator = async (\n", "  userCommand: string | undefined,\n\t  match: RegExpExecArray | null,\n\t): Promise<{\n\t  inputFilePath: string\n\t  outputFilePath: string\n\t  targetLang: string\n\t}> => {\n\t  if (!match || match.length < 4) {\n\t    await postError(`Invalid command: \\`${userCommand}\\`\\n${COMMAND_USAGE}`)\n\t  }\n", "  const [, inputFilePath, outputFilePath, targetLang] = match!\n\t  if (!isValidFileExt(inputFilePath) || !isValidFileExt(outputFilePath)) {\n\t    await postError(INVALID_FILE_EXTENSION)\n\t  }\n\t  const inputFileName = path.basename(inputFilePath)\n\t  const outputFileName = path.basename(outputFilePath)\n\t  // If multiple files are specified, input and output must be specified in the same way.\n\t  if (\n\t    (inputFileName.includes('*') && !outputFileName.includes('*')) ||\n\t    (!inputFileName.includes('*') && outputFileName.includes('*'))\n", "  ) {\n\t    await postError(\n\t      `Error: Multiple file specification mismatch.\\n${inputFileName} and ${outputFileName}`,\n\t    )\n\t  }\n\t  return {\n\t    inputFilePath,\n\t    outputFilePath,\n\t    targetLang: removeSymbols(targetLang),\n\t  }\n", "}\n"]}
{"filename": "src/error.ts", "chunked_list": ["import { availableFileExtensions } from './const'\n\texport const COMMAND_USAGE = `usage:\n\t\\`\\`\\`\n\t/gpt-translate [input file path] [output file path] [target language]\n\t\\`\\`\\`\n\t`\n\tconst availableFileExtsString = availableFileExtensions.join(', ')\n\texport const INVALID_FILE_EXTENSION = `Error: File must be a valid file type.\\n${availableFileExtsString}`\n"]}
{"filename": "src/file.ts", "chunked_list": ["import fs from 'fs/promises'\n\timport path from 'path'\n\t/**\n\t * Create files recursively if no directory.\n\t */\n\texport const createFile = async (\n\t  data: string,\n\t  filePath: string,\n\t): Promise<void> => {\n\t  try {\n", "    await fs.writeFile(filePath, data)\n\t  } catch (err) {\n\t    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {\n\t      await fs.mkdir(path.dirname(filePath), { recursive: true })\n\t      await createFile(data, filePath)\n\t    } else {\n\t      throw err\n\t    }\n\t  }\n\t}\n", "export const isFileExists = async (inputPath: string) => {\n\t  try {\n\t    await fs.stat(inputPath)\n\t    return true\n\t  } catch (error) {\n\t    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n\t      return false\n\t    }\n\t    throw error\n\t  }\n", "}\n\t/**\n\t * Replace the part with '**' with the rest\n\t */\n\tfunction replaceWildcard(inputArray: string[], outputArray: string[]) {\n\t  const output = [...outputArray]\n\t  const indexOfAsteriskAsterisk = outputArray.indexOf('**')\n\t  if (indexOfAsteriskAsterisk !== -1) {\n\t    output.splice(\n\t      indexOfAsteriskAsterisk,\n", "      1,\n\t      ...inputArray.slice(indexOfAsteriskAsterisk),\n\t    )\n\t  }\n\t  return output\n\t}\n\t/**\n\t * Extracts the extension from a filename string\n\t */\n\tfunction extractFileExtension(filename: string): string | null {\n", "  const match = filename.match(/\\.\\w+(\\.\\w+)?$/)\n\t  return match ? match[0] : null\n\t}\n\t/*\n\t * Get all file paths in a directory with a specific extension.\n\t * @param directoryPath The path to the directory to search.\n\t * @param extension The extension to filter by.\n\t */\n\texport const getFilePathsWithExtension = async (\n\t  directoryPath: string,\n", "  extension: string,\n\t): Promise<string[]> => {\n\t  const files = await fs.readdir(directoryPath)\n\t  const filteredFiles: string[] = []\n\t  for (const file of files) {\n\t    const filePath = path.join(directoryPath, file)\n\t    const stat = await fs.stat(filePath)\n\t    if (stat.isFile() && path.extname(file) === extension) {\n\t      filteredFiles.push(filePath)\n\t    }\n", "  }\n\t  return filteredFiles\n\t}\n\t/**\n\t * Generates an array of output file paths based on the provided array of input file paths\n\t *\n\t * @param {string[]} inputFilePaths - The array of input file paths\n\t * @param {string} outputFilePath - The format of the output file path. The '*' character in the output file path is replaced by the filename of each input file path\n\t * @returns {string[]} An array of output file paths.\n\t * @throws {Error} Throws an error if the outputFilePath does not contain extensions(.md) or wildcards(*)\n", " *\n\t */\n\texport const generateOutputFilePaths = (\n\t  inputFilePaths: string[],\n\t  outputFilePath: string,\n\t): string[] => {\n\t  const outputSegments = outputFilePath.replace('./', '').split('/')\n\t  const outputFilePattern = outputSegments.pop()!\n\t  const outputFileExt = extractFileExtension(outputFilePattern) || ''\n\t  const outputFilenameWithoutExt = outputFilePattern.replace(outputFileExt, '')\n", "  return inputFilePaths.map((inputFilePath) => {\n\t    const inputSegments = inputFilePath.split('/')\n\t    const inputFile = inputSegments.pop()!\n\t    const inputFileExt = extractFileExtension(inputFile) || ''\n\t    const inputFilenameWithoutExt = inputFile.replace(inputFileExt, '')\n\t    const resolvedPathSegments = replaceWildcard(inputSegments, outputSegments) // Resolve path segments\n\t    // If output file pattern contains '*', replace it with the input filename\n\t    if (outputFilenameWithoutExt.includes('*')) {\n\t      const finalExt = outputFileExt || inputFileExt // If output extension isn't specified, use input file extension\n\t      const finalFilename = `${inputFilenameWithoutExt}${finalExt}` // Concatenate filename and extension\n", "      resolvedPathSegments.push(finalFilename)\n\t    } else {\n\t      // Otherwise, use the specified output filename\n\t      resolvedPathSegments.push(outputFilePattern)\n\t    }\n\t    return resolvedPathSegments.join('/')\n\t  })\n\t}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import { setFailed } from '@actions/core'\n\timport { gitPostComment } from './git'\n\timport { context } from '@actions/github'\n\texport const postError = async (message: string) => {\n\t  await gitPostComment(`❌${message}`)\n\t  setFailed(message)\n\t  process.exit(1)\n\t}\n\texport const isPR = () => {\n\t  const { payload } = context\n", "  return !!payload.issue?.pull_request\n\t}\n\texport const removeSymbols = (input: string): string => {\n\t  return input.replace(/[^\\w\\s]/gi, '')\n\t}\n\texport const generatePRBody = (\n\t  inputFilePaths: string[],\n\t  outputFilePaths: string[] | string[][],\n\t  targetLang: string | string[],\n\t  issueNumber?: number,\n", ") => {\n\t  const generateRow = (label: string, filePaths: string[] | string[][]) => {\n\t    let result: string[] = []\n\t    if (Array.isArray(filePaths[0])) {\n\t      // filePaths: string[][]\n\t      let cnt = -1\n\t      filePaths.forEach((subArr) => {\n\t        // subArr: string[]\n\t        subArr.forEach((filePath: string) => {\n\t          cnt++\n", "          return result.push(\n\t            `${cnt > 0 ? '|' : `|**${label}**`}|\\`${filePath}\\`|`,\n\t          )\n\t        })\n\t      })\n\t    } else {\n\t      // filePaths: string[]\n\t      filePaths.forEach((filePath, i) => {\n\t        return result.push(`${i > 0 ? '|' : `|**${label}**`}|\\`${filePath}\\`|`)\n\t      })\n", "    }\n\t    return result.join('\\n')\n\t  }\n\t  return `## ✅ LLM Translation completed\n\t  |**Name**|**Value**|\n\t  |---|---|\n\t  ${generateRow('Source', inputFilePaths)}\n\t  ${generateRow('Output', outputFilePaths)}\n\t  |**Language**|${\n\t    Array.isArray(targetLang) ? targetLang.join(', ') : targetLang\n", "  }|\n\t  ${issueNumber ? `|**Issue**|#${issueNumber}|` : ''}\n\t  `\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { postError } from './utils'\n\timport { translateByCommand, translateByManual } from './translate'\n\timport { authorizeUser } from './git'\n\timport { extractInput, getCommandParams } from './extract'\n\timport { context } from '@actions/github'\n\timport { setFailed } from '@actions/core'\n\tasync function main() {\n\t  switch (context.eventName) {\n\t    case 'issue_comment':\n\t      const isAuthorized = await authorizeUser()\n", "      if (!isAuthorized) {\n\t        await postError('You have no permission to use this bot.')\n\t      }\n\t      const { inputFilePath, outputFilePath, targetLang } =\n\t        await getCommandParams()\n\t      await translateByCommand(inputFilePath, outputFilePath, targetLang)\n\t      break\n\t    case 'push':\n\t      // ⚠ Experimental Feature\n\t      // Translate any file from the parameter specification.\n", "      // Multiple output and target languages can be selected.\n\t      // [IMPORTANT]\n\t      // outputFiles must be specified using wildcards.\n\t      const { inputFiles, outputFiles, languages } = extractInput()\n\t      await translateByManual(inputFiles, outputFiles, languages)\n\t      break\n\t    default:\n\t      await postError('This event is not supported.')\n\t  }\n\t}\n", "main().catch((e) => setFailed(e))\n"]}
{"filename": "src/extract.ts", "chunked_list": ["import { getInput, setFailed } from '@actions/core'\n\timport { context } from '@actions/github'\n\timport { commandValidator, isValidFileExt } from './validate'\n\ttype CommandParams = {\n\t  inputFilePath: string\n\t  outputFilePath: string\n\t  targetLang: string\n\t}\n\ttype ManualParams = {\n\t  inputFiles: string[]\n", "  outputFiles: string[]\n\t  languages: string[]\n\t}\n\texport const getCommandParams = async (): Promise<CommandParams> => {\n\t  const comment = context.payload.comment?.body\n\t  if (!comment) setFailed('Error: Comment could not be retrieved correctly.')\n\t  const regex = /\\/(?:gpt-translate|gt)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/\n\t  const match = regex.exec(comment)\n\t  return commandValidator(comment, match)\n\t}\n", "export const extractInput = (): ManualParams => {\n\t  const inputFilesRaw = getInput('inputFiles')\n\t  const outputFilesRaw = getInput('outputFiles')\n\t  const languagesRaw = getInput('languages')\n\t  const inputFiles = inputFilesRaw\n\t    ? inputFilesRaw.split(' ').filter((v) => v)\n\t    : []\n\t  const outputFiles = outputFilesRaw\n\t    ? outputFilesRaw.split(' ').filter((v) => v)\n\t    : []\n", "  const languages = languagesRaw ? languagesRaw.split(' ').filter((v) => v) : []\n\t  // validate input\n\t  const isValidInput =\n\t    inputFiles.every((v) => isValidFileExt(v)) &&\n\t    outputFiles.every((v) => isValidFileExt(v))\n\t  if (!isValidInput) {\n\t    throw new Error(\n\t      'Invalid input. Please check the inputFiles and outputFiles parameters',\n\t    )\n\t  }\n", "  return {\n\t    inputFiles,\n\t    outputFiles,\n\t    languages,\n\t  }\n\t}\n"]}
