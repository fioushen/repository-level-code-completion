{"filename": "tests/esml.spec.ts", "chunked_list": ["describe(\"esml\", () => {\n\t  it.todo(\"should compile\");\n\t  it.todo(\"shoudl fail\");\n\t});\n"]}
{"filename": "src/canvas.ts", "chunked_list": ["import { esml } from \"./esml\";\n\timport type { ContextNode, Node, Schema } from \"./types\";\n\timport { EventEmitter, debounce } from \"./utils\";\n\tconst MIN_X = 0,\n\t  MIN_Y = 0;\n\ttype Options = {\n\t  SCALE: number;\n\t  WIDTH: number;\n\t  HEIGHT: number;\n\t  coordsSpan?: HTMLSpanElement;\n", "  zoomBtn?: HTMLButtonElement;\n\t  zoomInBtn?: HTMLButtonElement;\n\t  zoomOutBtn?: HTMLButtonElement;\n\t};\n\ttype State = {\n\t  code: string;\n\t  font: string;\n\t  x?: number;\n\t  y?: number;\n\t  zoom?: number;\n", "};\n\tconst renderSchema = (ctx: ContextNode, schema?: Schema): string => {\n\t  return schema\n\t    ? renderSchema(ctx, schema.base).concat(`<div class=\"schema\">\n\t  ${[...schema.values()]\n\t    .map((field) => {\n\t      const name =\n\t        field.name.length > 20\n\t          ? field.name.substring(0, 20) + \"...\"\n\t          : field.name;\n", "      const nel = field.required ? \"b\" : \"span\";\n\t      const tel = typeof field.type === \"object\" ? \"i\" : \"span\";\n\t      return `<div class=\"field\"><${nel}>${name}</${nel}><${tel}>${\n\t        field.type\n\t      }</${tel}>\n\t      </div>\n\t      ${tel === \"i\" ? renderSchema(ctx, field.type as Schema) : \"\"}`;\n\t    })\n\t    .join(\"\")}\n\t</div>`)\n", "    : \"\";\n\t};\n\texport declare interface Canvas {\n\t  on(event: \"transformed\", listener: (args: State) => void): this;\n\t}\n\texport class Canvas extends EventEmitter {\n\t  readonly SCALE: number = 80;\n\t  readonly WIDTH = this.SCALE * 100;\n\t  readonly HEIGHT = this.SCALE * 100;\n\t  readonly svg: Element;\n", "  readonly coordsSpan: HTMLSpanElement | undefined;\n\t  readonly zoomBtn: HTMLButtonElement | undefined;\n\t  readonly zoomInBtn: HTMLButtonElement | undefined;\n\t  readonly zoomOutBtn: HTMLButtonElement | undefined;\n\t  readonly details: HTMLElement | null;\n\t  private nodes?: HTMLDivElement;\n\t  private dragging = false;\n\t  private dx = 0;\n\t  private dy = 0;\n\t  private zoom = 1;\n", "  private x = 0;\n\t  private y = 0;\n\t  private w = 0;\n\t  private h = 0;\n\t  constructor(\n\t    private document: Document,\n\t    private container: HTMLDivElement,\n\t    options?: Options\n\t  ) {\n\t    super();\n", "    this.details = this.document.getElementById(\"details\");\n\t    if (options) {\n\t      this.SCALE = options.SCALE;\n\t      this.WIDTH = options.WIDTH;\n\t      this.HEIGHT = options.HEIGHT;\n\t      this.coordsSpan = options.coordsSpan;\n\t      this.zoomBtn = options.zoomBtn;\n\t      this.zoomInBtn = options.zoomInBtn;\n\t      this.zoomOutBtn = options.zoomOutBtn;\n\t    }\n", "    this.svg = this.document.createElementNS(\n\t      \"http://www.w3.org/2000/svg\",\n\t      \"svg\"\n\t    );\n\t    this.svg.setAttributeNS(\n\t      \"http://www.w3.org/2000/xmlns/\",\n\t      \"xmlns:xlink\",\n\t      \"http://www.w3.org/1999/xlink\"\n\t    );\n\t    this.svg.setAttribute(\n", "      \"viewBox\",\n\t      `${MIN_X} ${MIN_Y} ${this.WIDTH} ${this.HEIGHT}`\n\t    );\n\t    this.svg.setAttribute(\"width\", `${this.WIDTH}`);\n\t    this.svg.setAttribute(\"height\", `${this.HEIGHT}`);\n\t    this.container.appendChild(this.svg);\n\t    this.container.addEventListener(\"wheel\", (e: WheelEvent) => {\n\t      e.preventDefault();\n\t      if (e.metaKey || e.ctrlKey) {\n\t        this.fitZoom(this.zoom + e.deltaY * -0.01);\n", "        this.transform();\n\t      } else {\n\t        this.transform(e.deltaX, e.deltaY);\n\t      }\n\t    });\n\t    type Pos = { clientX: number; clientY: number };\n\t    const dragStart = ({ clientX, clientY }: Pos) => {\n\t      this.dragging = true;\n\t      this.dx = clientX;\n\t      this.dy = clientY;\n", "      this.container.style.cursor = \"grabbing\";\n\t    };\n\t    const dragEnd = () => {\n\t      this.dragging = false;\n\t      this.container.style.cursor = \"default\";\n\t    };\n\t    const drag = ({ clientX, clientY }: Pos) => {\n\t      if (this.dragging) {\n\t        this.transform(this.dx - clientX, this.dy - clientY);\n\t        this.dx = clientX;\n", "        this.dy = clientY;\n\t      }\n\t    };\n\t    this.container.addEventListener(\"mousedown\", dragStart);\n\t    this.container.addEventListener(\"mouseup\", dragEnd);\n\t    this.container.addEventListener(\"mousemove\", drag);\n\t    this.container.addEventListener(\"touchstart\", (e) =>\n\t      dragStart(e.touches[0])\n\t    );\n\t    this.container.addEventListener(\"touchend\", dragEnd);\n", "    this.container.addEventListener(\"touchmove\", (e) => drag(e.touches[0]));\n\t    this.zoomBtn &&\n\t      (this.zoomBtn.onclick = () => this.fitToContainer.apply(this));\n\t    this.zoomInBtn &&\n\t      (this.zoomInBtn.onclick = () => this.zoomTo.apply(this, [0.1]));\n\t    this.zoomOutBtn &&\n\t      (this.zoomOutBtn.onclick = () => this.zoomTo.apply(this, [-0.1]));\n\t  }\n\t  public fitToContainer() {\n\t    const vw = Math.min(this.container.clientWidth, window.innerWidth);\n", "    const vh = Math.min(this.container.clientHeight, window.innerHeight);\n\t    if (this.w && this.h && vw && vh) {\n\t      // avoid NaN\n\t      this.fitZoom(Math.min(vw / this.w, vh / this.h));\n\t      this.x = Math.floor((vw - this.w * this.zoom) / 2);\n\t      this.y = Math.floor((vh - this.h * this.zoom) / 2);\n\t      this.transform();\n\t    }\n\t  }\n\t  private zoomTo(z: number) {\n", "    this.fitZoom(this.zoom + z);\n\t    this.transform();\n\t  }\n\t  private fitZoom(z: number) {\n\t    this.zoom = Math.round(Math.min(Math.max(0.1, z), 3) * 100) / 100;\n\t  }\n\t  private transform(dx = 0, dy = 0) {\n\t    const g = this.svg.children[0];\n\t    if (g) {\n\t      this.x = Math.floor(\n", "        Math.min(Math.max(this.x - dx, MIN_X - this.w * this.zoom), this.WIDTH)\n\t      );\n\t      this.y = Math.floor(\n\t        Math.min(Math.max(this.y - dy, MIN_Y - this.h * this.zoom), this.HEIGHT)\n\t      );\n\t      this.coordsSpan &&\n\t        (this.coordsSpan.innerText = `x:${this.x} y:${this.y} w:${this.w} h:${this.h}`);\n\t      this.zoomBtn &&\n\t        (this.zoomBtn.innerText = `${Math.floor(this.zoom * 100)}%`);\n\t      g.setAttribute(\n", "        \"transform\",\n\t        `translate(${this.x}, ${this.y}) scale(${this.zoom})`\n\t      );\n\t      this.emit(\"transformed\", { x: this.x, y: this.y, zoom: this.zoom });\n\t    }\n\t  }\n\t  private renderNodeDetails(node: Node, schema?: Schema) {\n\t    return `<div class=\"name\">${node.name}</div>\n\t    <div class=\"description\">${node.description || \"\"}</div>\n\t    ${renderSchema(node.ctx, schema)}\n", "    `;\n\t  }\n\t  private addNodes(nodes: Node[]) {\n\t    const fadable = Object.fromEntries(\n\t      nodes\n\t        .filter((n) =>\n\t          [\"aggregate\", \"system\", \"policy\", \"process\", \"projector\"].includes(\n\t            n.visual\n\t          )\n\t        )\n", "        .map(({ index, visual }) => [`n${index}`, visual])\n\t    );\n\t    const fade = debounce((id: string) => {\n\t      if (id) {\n\t        const fade = document.querySelectorAll(`g:not(.${id}):not(.context)`);\n\t        for (let e of fade) {\n\t          e.id !== id && e.classList.add(\"faded\");\n\t        }\n\t      }\n\t    }, 500);\n", "    const handleMouseEnter = (event: MouseEvent) => {\n\t      const g = event.target as SVGGElement;\n\t      if (fadable[g.id]) fade(g.id);\n\t      const node = this.document.getElementById(\"node-\" + g.id);\n\t      if (this.details && node) {\n\t        this.details.innerHTML = node.innerHTML;\n\t        this.details.style.visibility = \"visible\";\n\t      }\n\t    };\n\t    const handleMouseLeave = () => {\n", "      fade(\"\");\n\t      const faded = document.querySelectorAll(\".faded\");\n\t      for (let e of faded) {\n\t        e.classList.remove(\"faded\");\n\t      }\n\t      this.details && (this.details.style.visibility = \"hidden\");\n\t    };\n\t    this.nodes && this.container.removeChild(this.nodes);\n\t    this.nodes = this.document.createElement(\"div\");\n\t    this.container.appendChild(this.nodes);\n", "    this.nodes.style.visibility = \"hidden\";\n\t    nodes.map((node) => {\n\t      const g = this.document.getElementById(\"n\" + node.index);\n\t      if (g) {\n\t        if (!g.classList.contains(\"context\")) {\n\t          g.addEventListener(\"mouseenter\", handleMouseEnter);\n\t          g.addEventListener(\"mouseleave\", handleMouseLeave);\n\t        }\n\t        // details\n\t        const schema = node.ctx.schemas.get(node.name);\n", "        if (node.description || schema) {\n\t          const el = this.document.createElement(\"div\");\n\t          el.id = `node-${g.id}`;\n\t          el.innerHTML = this.renderNodeDetails(node, schema);\n\t          this.nodes?.appendChild(el);\n\t        }\n\t      }\n\t    });\n\t  }\n\t  public render(state: State): Error | undefined {\n", "    const { error, svg, width, height, nodes } = esml(\n\t      state.code,\n\t      this.SCALE,\n\t      state.font\n\t    );\n\t    if (error) return error;\n\t    this.svg.innerHTML = svg!;\n\t    nodes && this.addNodes(nodes);\n\t    this.w = Math.floor(width!);\n\t    this.h = Math.floor(height!);\n", "    if (state.zoom) {\n\t      this.x = state.x || 0;\n\t      this.y = state.y || 0;\n\t      this.zoom = state.zoom;\n\t    }\n\t    this.transform();\n\t  }\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { Vector } from \"./utils\";\n\texport type Style = {\n\t  scale: number;\n\t  margin: number;\n\t  padding: number;\n\t  stroke: string;\n\t  fill: string;\n\t  font: string;\n\t  fontSize: number;\n\t};\n", "export const Visuals = [\n\t  \"context\",\n\t  \"aggregate\",\n\t  \"system\",\n\t  \"projector\",\n\t  \"policy\",\n\t  \"process\",\n\t  \"command\",\n\t  \"event\",\n\t  \"actor\",\n", "] as const;\n\texport const Actions = [\n\t  \"invokes\",\n\t  \"handles\",\n\t  \"emits\",\n\t  \"includes\",\n\t  \"requires\",\n\t  \"optional\",\n\t] as const;\n\texport type Visual = (typeof Visuals)[number];\n", "export type Action = (typeof Actions)[number];\n\texport const COLORS: { [key in Visual]: string } = {\n\t  context: \"white\",\n\t  actor: \"#ffc107\",\n\t  aggregate: \"#fffabb\",\n\t  system: \"#eca0c3\",\n\t  projector: \"#d5f694\",\n\t  policy: \"#c595cd\",\n\t  process: \"#c595cd\",\n\t  command: \"#7adcfb\",\n", "  event: \"#ffaa61\",\n\t};\n\texport const ScalarFieldTypes = [\n\t  \"string\",\n\t  \"number\",\n\t  \"boolean\",\n\t  \"uuid\",\n\t  \"date\",\n\t] as const;\n\texport type FieldType = (typeof ScalarFieldTypes)[number] | Schema;\n", "export class Field {\n\t  constructor(\n\t    readonly name: string,\n\t    readonly required: boolean,\n\t    readonly type: FieldType,\n\t    readonly size?: number\n\t  ) {}\n\t}\n\texport class Schema extends Map<string, Field> {\n\t  constructor(readonly name: string, description?: string) {\n", "    super();\n\t    this._base = undefined;\n\t    this._description = description;\n\t  }\n\t  private _base: Schema | undefined;\n\t  public set base(v: Schema) {\n\t    this._base = v;\n\t  }\n\t  public get base(): Schema | undefined {\n\t    return this._base;\n", "  }\n\t  private _description: string | undefined;\n\t  public set description(v: string) {\n\t    this._description = v;\n\t  }\n\t  public get description(): string | undefined {\n\t    return this._description;\n\t  }\n\t  toString() {\n\t    return this.name;\n", "  }\n\t}\n\texport type Edge = {\n\t  source: Node;\n\t  target: Node;\n\t  color?: string;\n\t  arrow?: boolean;\n\t  path?: Vector[];\n\t};\n\texport type Node = {\n", "  index: number;\n\t  name: string;\n\t  visual: Visual;\n\t  ctx: ContextNode;\n\t  description?: string;\n\t  color?: string;\n\t  x?: number;\n\t  y?: number;\n\t  width?: number;\n\t  height?: number;\n", "  refs?: Set<Node>;\n\t  useRefs?: boolean;\n\t  rels?: Set<number>;\n\t};\n\texport type ContextNode = Node & {\n\t  visual: \"context\";\n\t  nodes: Map<string, Node>;\n\t  edges: Map<string, Edge>;\n\t  schemas: Map<string, Schema>;\n\t};\n", "export const isContextNode = (node: Node): node is ContextNode =>\n\t  \"nodes\" in node;\n\texport type Edger = (\n\t  source: Node,\n\t  target: Node,\n\t  root: ContextNode\n\t) => Edge | undefined;\n"]}
{"filename": "src/schema.ts", "chunked_list": ["import { z } from \"zod\";\n\timport { ScalarFieldTypes } from \"./types\";\n\tconst Pascal = /^[A-Z][A-Za-z0-9]+$/;\n\tconst Camel = /^[a-z][A-Za-z0-9]+$/;\n\tconst Reference = /^([A-Z][A-Za-z0-9]+)(\\.[A-Z][A-Za-z0-9]*){0,1}$/;\n\tconst CommandList = z\n\t  .array(\n\t    z.string().regex(Pascal, {\n\t      message: \"Invalid command name. Use Pascal case!\",\n\t    })\n", "  )\n\t  .optional()\n\t  .describe(\"A list of references to internal commands\");\n\tconst EventList = z\n\t  .array(\n\t    z.string().regex(Reference, {\n\t      message: \"Invalid event name. Use [Context.]Name in Pascal case!\",\n\t    })\n\t  )\n\t  .optional()\n", "  .describe(\"A list of references to internal or external events\");\n\tconst Fields = z\n\t  .record(\n\t    z.string().regex(Camel, {\n\t      message: \"Invalid field name. Use camel case!\",\n\t    }),\n\t    z.enum(ScalarFieldTypes).or(\n\t      z.string().regex(Pascal, {\n\t        message: \"Invalid schema name. Use Pascal case!\",\n\t      })\n", "    )\n\t  )\n\t  .describe(\n\t    \"A map of field names and types (scalars or references to internal schemas)\"\n\t  );\n\tconst Schema = z\n\t  .object({\n\t    description: z.string().optional(),\n\t    base: z\n\t      .string()\n", "      .regex(Pascal, { message: \"Invalid schema name. Use Pascal case!\" })\n\t      .optional(),\n\t    requires: Fields.optional(),\n\t    optional: Fields.optional(),\n\t  })\n\t  .strict()\n\t  .describe(\"The data schema of internal messages or artifact states\");\n\tconst Event = z\n\t  .object({\n\t    type: z.literal(\"event\"),\n", "    description: z.string().optional(),\n\t    schema: Schema.optional(),\n\t  })\n\t  .strict()\n\t  .describe(\"An event\");\n\tconst Command = z\n\t  .object({\n\t    type: z.literal(\"command\"),\n\t    description: z.string().optional(),\n\t    schema: Schema.optional(),\n", "    actors: z\n\t      .record(\n\t        z.string().regex(Pascal, {\n\t          message: \"Invalid actor name. Use Pascal case!\",\n\t        }),\n\t        z.array(\n\t          z.string().regex(Reference, {\n\t            message:\n\t              \"Invalid projector name. Use [Context.]Projector in Pascal case!\",\n\t          })\n", "        )\n\t      )\n\t      .optional(),\n\t  })\n\t  .strict()\n\t  .describe(\"A command, with actors that can read projections\");\n\tconst System = z\n\t  .object({\n\t    type: z.literal(\"system\"),\n\t    description: z.string().optional(),\n", "    handles: CommandList,\n\t    emits: EventList,\n\t  })\n\t  .strict()\n\t  .describe(\"System artifact, can handle commands and emit events\");\n\tconst Aggregate = z\n\t  .object({\n\t    type: z.literal(\"aggregate\"),\n\t    description: z.string().optional(),\n\t    handles: CommandList,\n", "    emits: EventList,\n\t    schema: Schema.optional(),\n\t  })\n\t  .strict()\n\t  .describe(\n\t    \"Aggregate artifact, can handle commands and emit events, with a state\"\n\t  );\n\tconst Policy = z\n\t  .object({\n\t    type: z.literal(\"policy\"),\n", "    description: z.string().optional(),\n\t    handles: EventList,\n\t    invokes: CommandList,\n\t    useRefs: z\n\t      .boolean()\n\t      .optional()\n\t      .describe(\"Render near commands, with no edges\"),\n\t  })\n\t  .strict()\n\t  .describe(\n", "    \"Policy artifact, can handle (react to) events, and invoke commands\"\n\t  );\n\tconst Process = z\n\t  .object({\n\t    type: z.literal(\"process\"),\n\t    description: z.string().optional(),\n\t    handles: EventList,\n\t    invokes: CommandList,\n\t    schema: Schema.optional(),\n\t    useRefs: z\n", "      .boolean()\n\t      .optional()\n\t      .describe(\"Render near commands, with no edges\"),\n\t  })\n\t  .strict()\n\t  .describe(\n\t    \"Process manager artifact, can handle (react to) events, and invoke commands, with a state\"\n\t  );\n\tconst Projector = z\n\t  .object({\n", "    type: z.literal(\"projector\"),\n\t    description: z.string().optional(),\n\t    handles: EventList,\n\t    schema: Schema.optional(),\n\t  })\n\t  .strict()\n\t  .describe(\n\t    \"Projector artifact, can handle (project) events into a state (projection)\"\n\t  );\n\tconst ObjectSchema = z\n", "  .object({\n\t    type: z.literal(\"schema\"),\n\t    description: z.string().optional(),\n\t    base: z\n\t      .string()\n\t      .regex(Pascal, { message: \"Invalid schema name. Use Pascal case!\" })\n\t      .optional(),\n\t    requires: Fields.optional(),\n\t    optional: Fields.optional(),\n\t  })\n", "  .strict()\n\t  .describe(\"Object schemas can be used as base types or value objects\");\n\tconst Statement = z.union([\n\t  Command,\n\t  Event,\n\t  System,\n\t  Aggregate,\n\t  Policy,\n\t  Process,\n\t  Projector,\n", "  ObjectSchema,\n\t]);\n\texport const Grammar = z\n\t  .record(\n\t    z.string().regex(Pascal, {\n\t      message: \"Invalid context name. Use Pascal case!\",\n\t    }),\n\t    z.record(\n\t      z.string().regex(Pascal, {\n\t        message: \"Invalid artifact name. Use Pascal case!\",\n", "      }),\n\t      Statement\n\t    )\n\t  )\n\t  .describe(\"The model is a map of bounded contexts with internal artifacts\");\n\texport type Grammar = z.infer<typeof Grammar>;\n\texport type Statement = z.infer<typeof Statement>;\n\texport type Schema = z.infer<typeof Schema>;\n"]}
{"filename": "src/utils.ts", "chunked_list": ["export interface Vector {\n\t  x: number;\n\t  y: number;\n\t}\n\texport const magnitude = (v: Vector) => Math.sqrt(v.x * v.x + v.y * v.y);\n\texport const difference = (a: Vector, b: Vector) => ({\n\t  x: a.x - b.x,\n\t  y: a.y - b.y,\n\t});\n\texport const distance = (a: Vector, b: Vector) => magnitude(difference(a, b));\n", "export const add = (a: Vector, b: Vector) => ({ x: a.x + b.x, y: a.y + b.y });\n\texport const multiply = (v: Vector, factor: number) => ({\n\t  x: factor * v.x,\n\t  y: factor * v.y,\n\t});\n\texport const normalize = (v: Vector) => multiply(v, 1 / magnitude(v));\n\texport const rotate = (a: Vector) => ({ x: a.y, y: -a.x });\n\texport const pad = (n: number, l: number) => n.toString().padStart(l);\n\texport const splitName = (name: string) => name.trim().split(/(?=[A-Z])/);\n\ttype F = (this: ThisParameterType<void>, ...args: any[]) => void;\n", "export const debounce = (func: F, delay: number): F => {\n\t  let timeout: NodeJS.Timeout;\n\t  return function (this: ThisParameterType<void>, ...args: any[]): void {\n\t    clearTimeout(timeout);\n\t    timeout = setTimeout(() => {\n\t      func.apply(this, args);\n\t    }, delay);\n\t  };\n\t};\n\ttype ListenerFn = (...args: any[]) => void;\n", "export class EventEmitter {\n\t  private listeners = new Map<string, Set<ListenerFn>>();\n\t  public on(eventName: string, listener: ListenerFn): void {\n\t    !this.listeners.has(eventName) && this.listeners.set(eventName, new Set());\n\t    this.listeners.get(eventName)!.add(listener);\n\t  }\n\t  public emit(eventName: string, ...args: any[]): void {\n\t    this.listeners.has(eventName) &&\n\t      this.listeners.get(eventName)!.forEach((listener) => listener(...args));\n\t  }\n", "}\n"]}
{"filename": "src/compiler.ts", "chunked_list": ["import {\n\t  COLORS,\n\t  Field,\n\t  ScalarFieldTypes,\n\t  Schema,\n\t  type Action,\n\t  type ContextNode,\n\t  type Edge,\n\t  type Node,\n\t  type Visual,\n", "  Edger,\n\t} from \"./types\";\n\timport * as schema from \"./schema\";\n\tconst rules: Partial<Record<Visual, Partial<Record<Action, Visual>>>> = {\n\t  system: {\n\t    handles: \"command\",\n\t    emits: \"event\",\n\t  },\n\t  aggregate: {\n\t    handles: \"command\",\n", "    emits: \"event\",\n\t  },\n\t  policy: {\n\t    handles: \"event\",\n\t    invokes: \"command\",\n\t  },\n\t  process: {\n\t    handles: \"event\",\n\t    invokes: \"command\",\n\t  },\n", "  projector: { handles: \"event\" },\n\t};\n\tconst system: Edger = (source, target) =>\n\t  target.visual === \"command\"\n\t    ? { source: target, target: source }\n\t    : { source, target };\n\tconst policy: Edger = (source, target) =>\n\t  target.visual === \"event\"\n\t    ? {\n\t        source: source.ctx === target.ctx ? target : { ...target },\n", "        target: source,\n\t        color: COLORS.event,\n\t        arrow: false,\n\t      }\n\t    : source.ctx === target.ctx && !source.useRefs\n\t    ? {\n\t        source,\n\t        target,\n\t        color: COLORS.command,\n\t        arrow: false,\n", "      }\n\t    : undefined; // commands with policy refs\n\tconst edgers: { [key in Visual]: Edger } = {\n\t  context: (source, target, root) => {\n\t    if (target.visual === \"event\")\n\t      return {\n\t        source: root.nodes.get(target.ctx.name)!,\n\t        target: root.nodes.get(source.ctx.name)!,\n\t        color: COLORS.event,\n\t        arrow: true,\n", "      };\n\t    if (target.visual === \"command\")\n\t      return {\n\t        source: root.nodes.get(source.ctx.name)!,\n\t        target: root.nodes.get(target.ctx.name)!,\n\t        color: COLORS.command,\n\t        arrow: true,\n\t      };\n\t    if (target.visual === \"projector\")\n\t      return {\n", "        source: root.nodes.get(source.ctx.name)!,\n\t        target: root.nodes.get(target.ctx.name)!,\n\t        color: COLORS.projector,\n\t        arrow: true,\n\t      };\n\t  },\n\t  aggregate: system,\n\t  system: system,\n\t  policy: policy,\n\t  process: policy,\n", "  projector: (source, target) => ({\n\t    source: source.ctx === target.ctx ? target : { ...target },\n\t    target: source,\n\t    color: COLORS.event,\n\t    arrow: false,\n\t  }),\n\t  command: () => undefined,\n\t  event: () => undefined,\n\t  actor: () => undefined,\n\t};\n", "const addRef = (source: Node, target: Node) => {\n\t  !source.refs && (source.refs = new Set());\n\t  source.refs.add(target);\n\t};\n\tconst addRel = (stm: Node, msg: Node) => {\n\t  msg.rels = msg.rels ?? new Set<number>();\n\t  msg.rels.add(stm.index);\n\t};\n\tconst addSchema = (\n\t  ctx: ContextNode,\n", "  name: string,\n\t  { requires, optional, description }: schema.Schema\n\t) => {\n\t  const schema = ctx.schemas.get(name) ?? new Schema(name, description);\n\t  if (description && !schema.description) schema.description = description;\n\t  ctx.schemas.set(name, schema);\n\t  const append = (name: string, type: string, required: boolean) => {\n\t    const scalar = ScalarFieldTypes.includes(type as any);\n\t    if (!scalar) {\n\t      if (!ctx.schemas.has(type)) ctx.schemas.set(type, new Schema(type));\n", "      schema.set(name, new Field(name, required, ctx.schemas.get(type)!));\n\t    } else schema.set(name, new Field(name, required, type as any));\n\t  };\n\t  requires &&\n\t    Object.entries(requires).forEach(([name, type]) =>\n\t      append(name, type, true)\n\t    );\n\t  optional &&\n\t    Object.entries(optional).forEach(([name, type]) =>\n\t      append(name, type, false)\n", "    );\n\t};\n\tconst addBaseSchema = (ctx: ContextNode, name: string, base: string) => {\n\t  const schema = ctx.schemas.get(name);\n\t  const baseSchema = ctx.schemas.get(base);\n\t  schema && baseSchema && (schema.base = baseSchema);\n\t};\n\texport const compile = (model: schema.Grammar): ContextNode => {\n\t  let count = 0;\n\t  const newContext = (\n", "    parent?: ContextNode,\n\t    name = \"\",\n\t    hidden = false\n\t  ): ContextNode => ({\n\t    index: ++count,\n\t    name,\n\t    visual: \"context\",\n\t    ctx: parent ?? ({} as ContextNode),\n\t    color: hidden ? undefined : COLORS.context,\n\t    nodes: new Map(),\n", "    edges: new Map(),\n\t    schemas: new Map(),\n\t    x: 0,\n\t    y: 0,\n\t  });\n\t  const root = newContext();\n\t  const getNode = (ctx: ContextNode, name: string, visual: Visual): Node => {\n\t    // resolve [Context.]Target\n\t    const [a, b] = name.split(\".\");\n\t    if (b) {\n", "      ctx = root.nodes.get(a) as ContextNode;\n\t      if (!ctx) {\n\t        ctx = newContext(root, a);\n\t        root.nodes.set(a, ctx);\n\t      }\n\t      name = b;\n\t    }\n\t    !ctx.nodes.has(name) &&\n\t      ctx.nodes.set(name, {\n\t        index: ++count,\n", "        name,\n\t        visual,\n\t        color: COLORS[visual],\n\t        ctx,\n\t      });\n\t    const node = ctx.nodes.get(name)!;\n\t    return node;\n\t  };\n\t  const addStmt = (\n\t    ctx: ContextNode,\n", "    name: string,\n\t    statement: schema.Statement\n\t  ): void => {\n\t    if (statement.type === \"schema\") {\n\t      addSchema(ctx, name, statement);\n\t    } else {\n\t      const node = getNode(ctx, name, statement.type);\n\t      node.description = statement.description;\n\t      if (\"useRefs\" in statement) node.useRefs = statement.useRefs;\n\t      if (\"schema\" in statement) addSchema(ctx, name, statement.schema!);\n", "      if (statement.type === \"command\") {\n\t        statement.actors &&\n\t          Object.keys(statement.actors).forEach((actor) =>\n\t            getNode(ctx, actor, \"actor\")\n\t          );\n\t      } else if (statement.type !== \"event\") {\n\t        Object.entries(statement).forEach(([action, list]) => {\n\t          if (Array.isArray(list)) {\n\t            const visual = rules[statement.type]![action as Action];\n\t            visual &&\n", "              list.forEach((rel) => {\n\t                const msg = getNode(ctx, rel, visual);\n\t                addRel(node, msg);\n\t              });\n\t          }\n\t        });\n\t      }\n\t    }\n\t  };\n\t  // compile statements\n", "  Object.entries(model).forEach(([name, context]) => {\n\t    const ctx = (root.nodes.get(name) as ContextNode) ?? newContext(root, name);\n\t    root.nodes.set(name, ctx);\n\t    Object.entries(context).forEach(([name, statement]) =>\n\t      addStmt(ctx, name, statement)\n\t    );\n\t  });\n\t  // connect the model!\n\t  Object.entries(model).forEach(([name, context]) => {\n\t    const ctx = root.nodes.get(name) as ContextNode;\n", "    Object.entries(context).forEach(([name, statement]) => {\n\t      if (statement.type === \"schema\") {\n\t        statement.base && addBaseSchema(ctx, name, statement.base);\n\t      } else {\n\t        const edger = edgers[statement.type];\n\t        const source = ctx.nodes.get(name)!;\n\t        // connect base and value objects in schema\n\t        if (\"schema\" in statement && statement.schema?.base)\n\t          addBaseSchema(ctx, name, statement.schema.base);\n\t        // connect actors and read models\n", "        if (statement.type === \"command\" && statement.actors) {\n\t          Object.entries(statement.actors).forEach(([name, projectors]) => {\n\t            const actor = { ...ctx.nodes.get(name)! }; // clone it!\n\t            addRef(source, actor);\n\t            projectors.forEach((name) => {\n\t              const projector = getNode(ctx, name, \"projector\");\n\t              if (projector && projector.visual === \"projector\") {\n\t                addRef(actor, projector);\n\t                addRel(projector, source);\n\t              }\n", "            });\n\t          });\n\t        }\n\t        Object.entries(statement).forEach(([action, list]) => {\n\t          Array.isArray(list) &&\n\t            list.forEach((name: string) => {\n\t              const target = getNode(\n\t                ctx,\n\t                name,\n\t                rules[statement.type]![action as Action]!\n", "              );\n\t              // connect policies invoking commands\n\t              if (\n\t                (source.visual === \"policy\" || source.visual === \"process\") &&\n\t                target.visual === \"command\" &&\n\t                (source.ctx !== target.ctx || source.useRefs)\n\t              ) {\n\t                addRef(target, source);\n\t                addRel(source, target);\n\t              }\n", "              // connect contexts\n\t              if (ctx.color && source.ctx !== target.ctx) {\n\t                const edge = edgers.context(source, target, root) as Edge;\n\t                if (edge) {\n\t                  const key = `${edge.source.name}->${edge.target.name}-${\n\t                    edge.color || \"\"\n\t                  }`;\n\t                  !root.edges.has(key) && root.edges.set(key, edge);\n\t                }\n\t              }\n", "              // connect edges inside context\n\t              const edge = edger(source, target, root);\n\t              if (edge) {\n\t                ctx.edges.set(`${edge.source.name}->${edge.target.name}`, edge);\n\t                ctx.nodes.set(edge.source.name, edge.source);\n\t                ctx.nodes.set(edge.target.name, edge.target);\n\t              }\n\t            });\n\t        });\n\t      }\n", "    });\n\t  });\n\t  return root;\n\t};\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { Canvas } from \"./canvas\";\n\timport { esml } from \"./esml\";\n\timport { EventEmitter, debounce } from \"./utils\";\n\texport { Canvas, EventEmitter, debounce, esml };\n"]}
{"filename": "src/esml.ts", "chunked_list": ["import json5 from \"json5\";\n\timport { ZodError } from \"zod\";\n\timport { compile } from \"./compiler\";\n\timport { layout, render } from \"./graphics\";\n\timport { Grammar } from \"./schema\";\n\timport type { ContextNode, Node, Style } from \"./types\";\n\texport class Json5Error extends Error {\n\t  constructor(\n\t    readonly message: string,\n\t    readonly source: {\n", "      from: { line: number; col: number };\n\t      to: { line: number; col: number };\n\t    }\n\t  ) {\n\t    super(message);\n\t  }\n\t}\n\ttype Font = \"monospace\" | \"inconsolata\" | \"caveat\" | \"handlee\";\n\tconst FONTS: { [key in Font]: string } = {\n\t  monospace: \"Monospace\",\n", "  inconsolata: \"Inconsolata\",\n\t  caveat: \"Caveat\",\n\t  handlee: \"Handlee\",\n\t};\n\tconst DEFAULT_FONT = \"inconsolata\";\n\texport const esml = (\n\t  code: string,\n\t  scale: number,\n\t  font = DEFAULT_FONT\n\t): {\n", "  error?: Error;\n\t  svg?: string;\n\t  width?: number;\n\t  height?: number;\n\t  nodes?: Node[];\n\t} => {\n\t  const style: Style = {\n\t    scale,\n\t    stroke: \"#dedede\",\n\t    fill: \"white\",\n", "    font: FONTS[font.toLowerCase() as Font] || FONTS[DEFAULT_FONT],\n\t    fontSize: 12,\n\t    padding: 30,\n\t    margin: 40,\n\t  };\n\t  try {\n\t    const model = Grammar.parse(json5.parse(code));\n\t    const root = compile(model);\n\t    layout(root, style);\n\t    const svg = render(root, style);\n", "    const nodes = [...root.nodes.values()].flatMap((n) => [\n\t      ...(n as ContextNode).nodes.values(),\n\t    ]);\n\t    return {\n\t      svg,\n\t      width: root.width,\n\t      height: root.height,\n\t      nodes,\n\t    };\n\t  } catch (error: any) {\n", "    if (\"lineNumber\" in error && \"columnNumber\" in error)\n\t      return {\n\t        error: new Json5Error(error.message, {\n\t          from: { line: error.lineNumber - 1, col: 0 },\n\t          to: { line: error.lineNumber - 1, col: error.columnNumber },\n\t        }),\n\t      };\n\t    if (error instanceof ZodError)\n\t      return {\n\t        error: Error(\n", "          error.issues\n\t            .map((i) => `${i.path.join(\".\")}: ${i.message}`)\n\t            .join(\"\\n\")\n\t        ),\n\t      };\n\t    if (error instanceof Error) {\n\t      const message = error.stack!.split(\"\\n\").slice(0, 2).join(\" \");\n\t      return { error: Error(message) };\n\t    }\n\t    return { error: Error(error) };\n", "  }\n\t};\n"]}
{"filename": "src/graphics/render.ts", "chunked_list": ["import {\n\t  isContextNode,\n\t  type ContextNode,\n\t  type Edge,\n\t  type Node,\n\t  type Style,\n\t} from \"../types\";\n\timport {\n\t  add,\n\t  difference,\n", "  multiply,\n\t  normalize,\n\t  rotate,\n\t  splitName,\n\t} from \"../utils\";\n\timport { SvgGraphics } from \"./SvgGraphics\";\n\timport { Graphics, Path, Renderable, SvgAttrs } from \"./types\";\n\tconst CTX_STROKE = \"#aaaaaa\";\n\tconst NOTE_STROKE = \"#555555\";\n\tconst ARROW_SIZE = 1.5;\n", "const pickFontSize = (words: string[], w: number) => {\n\t  const max = words\n\t    .map((word) => word.length)\n\t    .sort((a, b) => b - a)\n\t    .at(0)!;\n\t  return Math.floor(Math.min(Math.max(Math.ceil(w / max), 8), 24));\n\t};\n\tconst sizeText = (\n\t  text: string[],\n\t  w: number,\n", "  h: number\n\t): { lines: string[]; fontSize: number } => {\n\t  let fontSize = pickFontSize(text, w);\n\t  while (fontSize > 5) {\n\t    const maxWidth = Math.ceil(w / fontSize) - 1;\n\t    const maxHeight = Math.floor(h / fontSize) - 1;\n\t    const lines: string[] = [];\n\t    let line = text[0];\n\t    let n = 1;\n\t    while (n < text.length) {\n", "      const word = text[n++];\n\t      if (line.length + word.length >= maxWidth) {\n\t        lines.push(line);\n\t        line = word;\n\t      } else line = line.concat(line.length ? \" \" : \"\", word);\n\t    }\n\t    lines.push(line);\n\t    if (n === text.length && lines.length <= maxHeight)\n\t      return {\n\t        lines,\n", "        fontSize,\n\t      };\n\t    fontSize--;\n\t  }\n\t  return {\n\t    lines: [text.join(\" \")],\n\t    fontSize,\n\t  };\n\t};\n\tconst renderText = (\n", "  text: string[],\n\t  w: number,\n\t  h: number,\n\t  g: Graphics,\n\t  options: {\n\t    fit: boolean;\n\t    x?: number;\n\t    y?: number;\n\t    w?: number;\n\t    h?: number;\n", "    fontSize?: number;\n\t  } = { fit: true }\n\t) => {\n\t  const width = options.w || w || 0;\n\t  const height = options.h || h || 0;\n\t  const { lines, fontSize } = options.fit\n\t    ? sizeText(text, width, height)\n\t    : {\n\t        lines: text,\n\t        fontSize: options.fontSize || 12,\n", "      };\n\t  g.attr(\"font-size\", fontSize + \"pt\");\n\t  const x = options.x || Math.floor(width / 2);\n\t  const y = options.y || Math.floor(height / 2);\n\t  const m = Math.floor(lines.length / 2);\n\t  const o = lines.length % 2 ? 0.3 : 0.9;\n\t  lines.forEach((line, i) => {\n\t    g.text(line, x, y, {\n\t      fill: NOTE_STROKE,\n\t      dy: `${((i - m) * 1.2 + o).toFixed(2)}em`,\n", "    });\n\t  });\n\t};\n\tconst getPath = (edge: Edge): Path[] => {\n\t  if (edge.path) {\n\t    const path = edge.path!.slice(1, -1);\n\t    const endDir = normalize(difference(path[path.length - 2], path.at(-1)!));\n\t    const end = path.length - 1;\n\t    const copy = path.map((p) => ({ x: p.x, y: p.y }));\n\t    copy[end] = add(\n", "      copy[end],\n\t      multiply(endDir, ARROW_SIZE * (edge.arrow ? 5 : 0))\n\t    );\n\t    return copy;\n\t  }\n\t  const x1 = edge.source.x! + edge.source.width! / 2;\n\t  const x2 = edge.target.x! - edge.target.width! / 2;\n\t  const y1 = edge.source.y!;\n\t  const y2 = edge.target.y!;\n\t  if (y1 === y2) return [{ x: x1, y: y1 }, { dx: x2 - x1 }];\n", "  const dx = Math.floor((x2 - x1) / 2);\n\t  const dy = Math.floor(y2 - y1);\n\t  return [{ x: x1, y: y1 }, { dx }, { dy }, { dx }];\n\t};\n\tconst renderEdge = (edge: Edge, g: Graphics) => {\n\t  const attrs: SvgAttrs = {\n\t    fill: \"none\",\n\t    stroke: edge.arrow ? edge.color : edge.target.color,\n\t  };\n\t  edge.arrow && (attrs[\"stroke-width\"] = 3);\n", "  g.path(getPath(edge), false, { ...attrs });\n\t  if (edge.arrow) {\n\t    const end = edge.path![edge.path!.length - 2];\n\t    const path = edge.path!.slice(1, -1);\n\t    const dir = normalize(difference(path[path.length - 2], path.at(-1)!));\n\t    const x = (s: number) => add(end, multiply(dir, s * ARROW_SIZE));\n\t    const y = (s: number) => multiply(rotate(dir), s * ARROW_SIZE);\n\t    g.path([add(x(10), y(4)), x(5), add(x(10), y(-4)), end], true, {\n\t      ...attrs,\n\t      fill: edge.color,\n", "    });\n\t  }\n\t};\n\tconst renderSimpleRef = (\n\t  node: Node,\n\t  x: number,\n\t  y: number,\n\t  w: number,\n\t  h: number,\n\t  g: Graphics\n", ") => {\n\t  g.group(\"\", \"\").attr(\"fill\", node.color);\n\t  g.rect(x, y, w, h);\n\t  renderText(splitName(node.name), w, h, g, {\n\t    fit: true,\n\t    x: x + w / 2,\n\t    y: y + h / 2,\n\t    w,\n\t    h,\n\t  });\n", "  g.ungroup();\n\t};\n\tconst renderRef = (\n\t  node: Node,\n\t  x: number,\n\t  y: number,\n\t  w: number,\n\t  h: number,\n\t  g: Graphics\n\t) => {\n", "  renderSimpleRef(node, x, y, w, h, g);\n\t  const hw = Math.ceil(w / 2);\n\t  const hh = Math.ceil(h / 2);\n\t  node.refs &&\n\t    [...node.refs].forEach((target, i) =>\n\t      renderSimpleRef(target, x - hw + 4, y + i * (hh + 2) - 4, hw, hh, g)\n\t    );\n\t};\n\tconst renderMultilineRef = (\n\t  targets: Node[],\n", "  x: number,\n\t  y: number,\n\t  w: number,\n\t  h: number,\n\t  g: Graphics\n\t) => {\n\t  const text = targets.map((target) => `- ${splitName(target.name).join(\" \")}`);\n\t  g.group(\"\", \"\")\n\t    .attr(\"fill\", targets[0].color)\n\t    .attr(\"text-align\", \"left\")\n", "    .attr(\"text-anchor\", \"start\");\n\t  g.rect(x, y, w, h);\n\t  renderText(text, w, h, g, {\n\t    fit: true,\n\t    x: x + 4,\n\t    y: y + h / 2,\n\t    w,\n\t    h,\n\t  });\n\t  g.ungroup();\n", "};\n\tconst renderCommandRefs = (\n\t  node: Node,\n\t  x: number,\n\t  y: number,\n\t  w: number,\n\t  h: number,\n\t  g: Graphics\n\t) => {\n\t  const targets = [...node.refs!];\n", "  const th = Math.floor(h / targets.length);\n\t  targets.forEach((target, i) =>\n\t    renderRef(target, x, y + i * (th + 2), w, th, g)\n\t  );\n\t};\n\tconst renderRefs = (node: Node, g: Graphics, style: Style) => {\n\t  if (node.refs && node.visual !== \"actor\") {\n\t    const x = Math.floor(node.x! - node.width! / 2 - style.scale * 0.2);\n\t    const y = Math.floor(node.y! + node.height! * 0.4);\n\t    const w = Math.floor(style.scale);\n", "    const h = Math.floor(style.scale / 2);\n\t    node.refs?.size > 1\n\t      ? node.visual === \"command\"\n\t        ? renderCommandRefs(node, x, y, w, h, g)\n\t        : renderMultilineRef([...node.refs], x, y, w, h, g)\n\t      : renderRef([...node.refs][0], x, y, w, h, g);\n\t  }\n\t};\n\tconst context: Renderable = (ctx: Node, g: Graphics, style: Style) => {\n\t  if (isContextNode(ctx)) {\n", "    if (ctx.name) {\n\t      const words = splitName(ctx.name);\n\t      g.text(words.join(\" \"), 0, 0, {\n\t        fill: CTX_STROKE,\n\t        stroke: CTX_STROKE,\n\t        dy: -style.fontSize,\n\t      });\n\t      g.rect(0, 0, ctx.width!, ctx.height!, { rx: 25, ry: 25 });\n\t    }\n\t    g.group(`n${ctx.index}`, \"\", { dx: style.padding, dy: style.padding });\n", "    if (ctx.name)\n\t      g.attr(\"text-align\", \"center\")\n\t        .attr(\"text-anchor\", \"middle\")\n\t        .attr(\"stroke\", NOTE_STROKE);\n\t    ctx.edges.forEach(\n\t      (e) =>\n\t        e.color &&\n\t        renderEdge({ ...e, source: ctx.nodes.get(e.source.name)! }, g)\n\t    );\n\t    ctx.nodes.forEach((n) => n.color && renderNode(n, g, style));\n", "    ctx.nodes.forEach((n) => n.refs && renderRefs(n, g, style));\n\t    g.ungroup();\n\t  }\n\t};\n\tconst note: Renderable = (node: Node, g: Graphics) => {\n\t  g.attr(\"fill\", node.color!);\n\t  g.rect(0, 0, node.width!, node.height!);\n\t  if (node.rels)\n\t    g.attr(\n\t      \"class\",\n", "      node.visual.concat(\" \", [...node.rels].map((i) => `n${i}`).join(\" \"))\n\t    );\n\t  renderText(splitName(node.name), node.width!, node.height!, g);\n\t  const schema = node.ctx.schemas.get(node.name);\n\t  schema &&\n\t    g.text(`{${schema.size}}`, node.width! - 6, 6, {\n\t      \"font-size\": \"6pt\",\n\t      fill: NOTE_STROKE,\n\t    });\n\t};\n", "const renderNode = (node: Node, g: Graphics, style: Style) => {\n\t  const dx = Math.floor(node.x! - node.width! / 2);\n\t  const dy = Math.floor(node.y! - node.height! / 2);\n\t  const render =\n\t    node.visual === \"context\"\n\t      ? context\n\t      : node.visual !== \"actor\"\n\t      ? note\n\t      : undefined; // don't render actors as nodes\n\t  if (render) {\n", "    g.group(`n${node.index}`, node.name, { class: node.visual, dx, dy });\n\t    render(node, g, style);\n\t    g.ungroup();\n\t  }\n\t};\n\texport const render = (root: ContextNode, style: Style): string => {\n\t  const g = new SvgGraphics({\n\t    fill: style.fill,\n\t    \"font-family\": style.font,\n\t    \"font-size\": style.fontSize + \"pt\",\n", "    \"text-align\": \"left\",\n\t    stroke: style.stroke,\n\t    \"stroke-width\": 1,\n\t  });\n\t  context(root, g, style);\n\t  return g.serialize();\n\t};\n"]}
{"filename": "src/graphics/types.ts", "chunked_list": ["import type { Style, Node } from \"../types\";\n\texport type SvgElementType = \"g\" | \"path\" | \"rect\" | \"text\" | \"tspan\";\n\texport type SvgAttr = {\n\t  id?: string;\n\t  \"data-name\"?: string;\n\t  class?: string;\n\t  transform?: string;\n\t  fill?: string;\n\t  stroke?: string;\n\t  \"stroke-width\"?: number;\n", "  \"stroke-dasharray\"?: string;\n\t  \"font-family\"?: string;\n\t  \"font-size\"?: number | string;\n\t  \"font-weight\"?: \"bold\" | \"normal\";\n\t  \"font-style\"?: \"italic\" | \"normal\";\n\t  \"text-align\"?: \"left\" | \"center\" | \"right\";\n\t  \"text-anchor\"?: \"start\" | \"middle\" | \"end\";\n\t  d?: string;\n\t  x?: number;\n\t  y?: number;\n", "  dx?: number | string;\n\t  dy?: number | string;\n\t  rx?: number;\n\t  ry?: number;\n\t  height?: number;\n\t  width?: number;\n\t  style?: string;\n\t};\n\texport type Path = { x?: number; y?: number; dx?: number; dy?: number };\n\texport type SvgAttrs = { [K in keyof SvgAttr]?: SvgAttr[K] };\n", "export interface Graphics {\n\t  group(\n\t    id: string,\n\t    name: string,\n\t    attrs?: { class?: string; dx?: number; dy?: number }\n\t  ): this;\n\t  ungroup(): void;\n\t  attr<K extends keyof SvgAttr>(key: K, val: SvgAttrs[K]): this;\n\t  text(\n\t    text: string,\n", "    x: number,\n\t    y: number,\n\t    attrs?: {\n\t      fill?: string;\n\t      stroke?: string;\n\t      dy?: number | string;\n\t      \"font-family\"?: string;\n\t      \"font-size\"?: number | string;\n\t    }\n\t  ): void;\n", "  rect(\n\t    x: number,\n\t    y: number,\n\t    width: number,\n\t    height: number,\n\t    attrs?: {\n\t      fill?: string;\n\t      stroke?: string;\n\t      style?: string;\n\t      rx?: number;\n", "      ry?: number;\n\t    }\n\t  ): void;\n\t  path(path: Path[], close?: boolean, attrs?: SvgAttrs): void;\n\t  serialize(): string;\n\t}\n\texport type Renderable = (node: Node, g: Graphics, style: Style) => void;\n"]}
{"filename": "src/graphics/layout.ts", "chunked_list": ["import * as dagre from \"dagre\";\n\timport type { ContextNode, Node, Style, Visual } from \"../types\";\n\timport { splitName } from \"../utils\";\n\ttype Layouter = (node: Node, style: Style) => void;\n\tconst square: Layouter = (node: Node, style: Style) => {\n\t  node.x = 0;\n\t  node.y = 0;\n\t  node.width = style.scale;\n\t  node.height = style.scale;\n\t};\n", "const rectangle: Layouter = (node: Node, style: Style) => {\n\t  node.x = 0;\n\t  node.y = 0;\n\t  node.width = style.scale * 2;\n\t  node.height = style.scale;\n\t};\n\t// don't render actors as nodes\n\tconst actor: Layouter = (node: Node) => {\n\t  node.x = 0;\n\t  node.y = 0;\n", "  node.width = 0;\n\t  node.height = 0;\n\t};\n\texport const layout = (root: ContextNode, style: Style) => {\n\t  function layouter(visual: Visual): Layouter {\n\t    switch (visual) {\n\t      case \"context\":\n\t        return layoutContext as Layouter;\n\t      case \"actor\":\n\t        return actor;\n", "      case \"command\":\n\t      case \"event\":\n\t        return square;\n\t      default:\n\t        return rectangle;\n\t    }\n\t  }\n\t  const PAD = 2 * style.padding;\n\t  const layoutContext = (ctx: ContextNode, style: Style) => {\n\t    if (ctx.nodes.size) {\n", "      const graph = new dagre.graphlib.Graph({\n\t        multigraph: true,\n\t      });\n\t      graph.setGraph({\n\t        nodesep: style.margin,\n\t        edgesep: style.margin,\n\t        ranksep: style.margin,\n\t        acyclicer: ctx.name && \"greedy\",\n\t        rankdir: \"LR\",\n\t        ranker: \"network-simplex\",\n", "      });\n\t      ctx.nodes.forEach((n) => n.color && layouter(n.visual)(n, style));\n\t      ctx.nodes.forEach(\n\t        ({ name, width, height }) =>\n\t          width && height && graph.setNode(name, { width, height })\n\t      );\n\t      ctx.edges.forEach(({ source, target }, name) =>\n\t        graph.setEdge(source.name, target.name, {}, name)\n\t      );\n\t      dagre.layout(graph);\n", "      ctx.nodes.forEach((n) => {\n\t        const gn = graph.node(n.name);\n\t        if (gn) {\n\t          n.x = gn.x;\n\t          n.y = gn.y;\n\t        }\n\t      });\n\t      !ctx.name &&\n\t        graph.edges().forEach((e) => {\n\t          const ge = graph.edge(e);\n", "          const ne = ctx.edges.get(e.name!)!;\n\t          ne.path = [ne.source, ...ge.points!, ne.target].map((n) => ({\n\t            x: Math.floor(n.x!),\n\t            y: Math.floor(n.y!),\n\t          }));\n\t        });\n\t      const { width = 0, height = 0 } = graph.graph();\n\t      ctx.width = width + PAD;\n\t      ctx.height = height + PAD;\n\t    } else {\n", "      ctx.width = splitName(ctx.name).join(\" \").length * style.fontSize + PAD;\n\t      ctx.height = style.fontSize + PAD;\n\t    }\n\t  };\n\t  return layoutContext(root, style);\n\t};\n"]}
{"filename": "src/graphics/SvgGraphics.ts", "chunked_list": ["import { Graphics, Path, SvgAttr, SvgAttrs, SvgElementType } from \"./types\";\n\tfunction encode(val?: string | number) {\n\t  if (\"number\" === typeof val) return val.toFixed(0);\n\t  return (val ?? \"\")\n\t    .toString()\n\t    .replace(/&/g, \"&amp;\")\n\t    .replace(/</g, \"&lt;\")\n\t    .replace(/>/g, \"&gt;\")\n\t    .replace(/\"/g, \"&quot;\")\n\t    .replace(/'/g, \"&apos;\");\n", "}\n\tfunction attrs(attrs: SvgAttrs): string {\n\t  return Object.entries(attrs)\n\t    .filter(([_, val]) => val)\n\t    .map(([key, val]) => `${key}=\"${encode(val)}\"`)\n\t    .join(\" \");\n\t}\n\tclass SvgElement {\n\t  private readonly children: SvgElement[] = [];\n\t  constructor(\n", "    private readonly type: SvgElementType,\n\t    private readonly attrs: SvgAttrs,\n\t    private parent?: SvgElement,\n\t    private text?: string\n\t  ) {}\n\t  get group() {\n\t    return this.parent;\n\t  }\n\t  attr<K extends keyof SvgAttr>(key: K, val: SvgAttrs[K]) {\n\t    this.attrs[key] = val;\n", "    return this;\n\t  }\n\t  append(el: SvgElement) {\n\t    el.parent = this;\n\t    this.children.push(el);\n\t    return el;\n\t  }\n\t  serialize(): string {\n\t    const attr = attrs({ ...this.attrs });\n\t    const body =\n", "      this.children.map((o) => o.serialize()).join(\"\") || encode(this.text);\n\t    return `<${this.type} ${attr}>${body}</${this.type}>`;\n\t  }\n\t}\n\texport class SvgGraphics implements Graphics {\n\t  private readonly root: SvgElement;\n\t  private current: SvgElement;\n\t  private _new(type: SvgElementType, attr: SvgAttrs, text?: string) {\n\t    this.current.append(new SvgElement(type, attr, this.current, text));\n\t  }\n", "  constructor(attrs: SvgAttrs) {\n\t    this.root = this.current = new SvgElement(\"g\", {\n\t      ...attrs,\n\t      \"data-name\": \"root\",\n\t    });\n\t  }\n\t  group(\n\t    id: string,\n\t    name: string,\n\t    attrs?: { class?: string; dx?: number; dy?: number }\n", "  ) {\n\t    const element = new SvgElement(\"g\", {}, this.current);\n\t    this.current.append(element);\n\t    this.current = element;\n\t    if (name) {\n\t      this.attr(\"id\", id);\n\t      this.attr(\"data-name\", name);\n\t    }\n\t    if (attrs) {\n\t      attrs.class && this.attr(\"class\", attrs.class);\n", "      (attrs.dx || attrs.dy) &&\n\t        this.attr(\"transform\", `translate(${attrs.dx}, ${attrs.dy})`);\n\t    }\n\t    return this;\n\t  }\n\t  ungroup() {\n\t    this.current.group && (this.current = this.current.group);\n\t  }\n\t  attr<K extends keyof SvgAttr>(key: K, val: SvgAttrs[K]) {\n\t    this.current.attr(key, val);\n", "    return this;\n\t  }\n\t  rect(\n\t    x: number,\n\t    y: number,\n\t    width: number,\n\t    height: number,\n\t    attrs?: {\n\t      fill?: string;\n\t      stroke?: string;\n", "      style?: string;\n\t      rx?: number;\n\t      ry?: number;\n\t    }\n\t  ) {\n\t    this._new(\"rect\", { x, y, height, width, ...attrs });\n\t  }\n\t  path(path: Path[], close?: boolean, attrs?: SvgAttrs) {\n\t    const d = path\n\t      .map((p, i) =>\n", "        p.x && p.y\n\t          ? (i ? \"L\" : \"M\") + p.x.toFixed(0) + \" \" + p.y.toFixed(0)\n\t          : p.dx\n\t          ? \"h\" + p.dx.toFixed(0)\n\t          : p.dy\n\t          ? \"v\" + p.dy.toFixed(0)\n\t          : \"\"\n\t      )\n\t      .join(\" \")\n\t      .concat(close ? \" Z\" : \"\");\n", "    this._new(\"path\", { ...attrs, d });\n\t  }\n\t  text(\n\t    text: string,\n\t    x: number,\n\t    y: number,\n\t    attrs?: {\n\t      fill?: string;\n\t      stroke?: string;\n\t      dy?: number | string;\n", "      \"font-family\"?: string;\n\t      \"font-size\"?: number | string;\n\t    }\n\t  ) {\n\t    this._new(\"text\", { x, y, ...attrs }, text);\n\t  }\n\t  serialize() {\n\t    return this.root.serialize();\n\t  }\n\t}\n"]}
{"filename": "src/graphics/index.ts", "chunked_list": ["export { layout } from \"./layout\";\n\texport { render } from \"./render\";\n"]}
{"filename": "src/cli/configs.ts", "chunked_list": ["import path from \"node:path\";\n\timport os from \"node:os\";\n\timport { createFile } from \"./utils\";\n\ttype Package = {\n\t  name: string;\n\t  version: string;\n\t  description: string;\n\t  author: {\n\t    name: string;\n\t    email: string;\n", "  };\n\t  license: \"MIT\";\n\t  main?: string;\n\t  workspaces?: string[];\n\t  scripts?: Record<string, string>;\n\t  dependencies?: Record<string, string>;\n\t  devDependencies?: Record<string, string>;\n\t};\n\texport function createPackageJson(\n\t  dir: string,\n", "  name: string,\n\t  workspaces?: string[]\n\t): void {\n\t  const username = os.userInfo().username || \"username\";\n\t  const pkg: Package = {\n\t    name,\n\t    version: \"0.1.0\",\n\t    description: `Describe your ${name} project here`,\n\t    author: {\n\t      name: username,\n", "      email: `${username}@email.com`,\n\t    },\n\t    license: \"MIT\",\n\t  };\n\t  if (workspaces) {\n\t    pkg.workspaces = workspaces;\n\t    pkg.scripts = {\n\t      build: \"npm run build --workspaces\",\n\t      test: \"npm run test --workspaces\",\n\t      dev: \"sh ./scripts/dev.sh\",\n", "      up: \"npm run build && docker-compose up\",\n\t      down: \"docker-compose down\",\n\t    };\n\t    pkg.devDependencies = {\n\t      \"@types/express\": \"^4\",\n\t      \"@types/jest\": \"^29\",\n\t      \"@types/node\": \"^18\",\n\t      jest: \"^29\",\n\t      \"ts-jest\": \"^29\",\n\t      \"ts-node\": \"^10\",\n", "      \"ts-node-dev\": \"^2\",\n\t      typescript: \"^5\",\n\t    };\n\t  } else {\n\t    pkg.main = \"dist/index.js\";\n\t    pkg.scripts = {\n\t      start: \"node dist/index.js\",\n\t      test: \"jest --coverage\",\n\t      build: \"tsc\",\n\t    };\n", "    pkg.dependencies = {\n\t      \"@rotorsoft/eventually\": \"^5\",\n\t      \"@rotorsoft/eventually-express\": \"^5\",\n\t      \"@rotorsoft/eventually-openapi\": \"^0\",\n\t      \"@rotorsoft/eventually-pg\": \"^5\",\n\t      express: \"^4\",\n\t      zod: \"^3\",\n\t    };\n\t  }\n\t  createFile(path.join(dir, \"package.json\"), JSON.stringify(pkg, null, 2));\n", "}\n\texport function createTsConfig(dir: string, base?: string): void {\n\t  const tsConfig = base\n\t    ? {\n\t        extends: base,\n\t        compilerOptions: {\n\t          rootDir: \"src\",\n\t          outDir: \"dist\",\n\t        },\n\t        include: [\"src\"],\n", "        exclude: [\"src/__tests__\"],\n\t      }\n\t    : {\n\t        compilerOptions: {\n\t          target: \"ES2021\",\n\t          module: \"commonjs\",\n\t          strict: true,\n\t          sourceMap: true,\n\t          declaration: true,\n\t          declarationMap: true,\n", "          noImplicitAny: true,\n\t          esModuleInterop: true,\n\t          skipLibCheck: true,\n\t        },\n\t        exclude: [\"node_modules\"],\n\t      };\n\t  createFile(\n\t    path.join(dir, \"tsconfig.json\"),\n\t    JSON.stringify(tsConfig, null, 2)\n\t  );\n", "}\n\texport function createJestConfig(dir: string): void {\n\t  const jestConfig = {\n\t    preset: \"ts-jest\",\n\t    testEnvironment: \"node\",\n\t    testMatch: [\"**/*spec.ts\"],\n\t    coveragePathIgnorePatterns: [\n\t      \"node_modules\",\n\t      \"dist\",\n\t      \"__tests__\",\n", "      \"__mocks__\",\n\t    ],\n\t  };\n\t  createFile(\n\t    path.join(dir, \"jest.config.js\"),\n\t    `/* eslint-disable no-undef */\n\t/** @type {import('ts-jest/dist/types').JestConfigWithTsJest} */\n\tmodule.exports = ${JSON.stringify(jestConfig, null, 2)};\n\t`\n\t  );\n", "}\n\texport function createEnv(dir: string): void {\n\t  createFile(\n\t    path.join(dir, \".env\"),\n\t    `LOG_LEVEL=trace\n\tOAS_UI=Rapidoc\n\t# local PG docker container\n\tPG_HOST=localhost\n\tPG_USER=postgres\n\tPG_PASSWORD=postgres\n", "PG_DATABASE=postgres\n\t`\n\t  );\n\t}\n\texport function createGitIgnore(dir: string): void {\n\t  createFile(\n\t    path.join(dir, \".gitignore\"),\n\t    `node_modules\n\tdist\n\tcoverage\n", "`\n\t  );\n\t}\n"]}
{"filename": "src/cli/create-eventually-app.ts", "chunked_list": ["#!/usr/bin/env node\n\timport path from \"node:path\";\n\timport {\n\t  createDirectory,\n\t  executeCommand,\n\t  loadFile,\n\t  parseArguments,\n\t  resolvePath,\n\t} from \"./utils\";\n\timport { generateContexts } from \"./generators\";\n", "import { createEnv, createGitIgnore, createTsConfig } from \"./configs\";\n\tconst use =\n\t  \"Use: npx create-eventually-app --src=path-to-model --dir=path-to-target --project=project-name\";\n\tconst { dir, src, project } = parseArguments(process.argv);\n\tif (!(dir && src && project)) {\n\t  console.log(use);\n\t  process.exit(1);\n\t}\n\tconst srcPath = resolvePath(src);\n\tconsole.log(\"Source path:\", srcPath);\n", "const dirPath = resolvePath(dir);\n\tconst projectPath = path.join(dirPath, project);\n\tconsole.log(\"Project path:\", projectPath);\n\tconst code = loadFile(srcPath);\n\tif (!code) {\n\t  console.error(\"Model not found at:\", srcPath);\n\t  process.exit(1);\n\t}\n\tcreateDirectory(projectPath);\n\tcreateTsConfig(projectPath);\n", "createEnv(projectPath);\n\tcreateGitIgnore(projectPath);\n\tgenerateContexts(projectPath, project, code);\n\texecuteCommand(`cd ${projectPath} && npm install`);\n\tconsole.log(`Successfully created eventually project '${project}' 🚀`);\n"]}
{"filename": "src/cli/types.ts", "chunked_list": ["import type { Node } from \"../types\";\n\texport interface Arguments {\n\t  [key: string]: string;\n\t}\n\texport type Art = Node & {\n\t  in: Array<Node>;\n\t  out: Array<Node>;\n\t};\n"]}
{"filename": "src/cli/create-eventually-arts.ts", "chunked_list": ["#!/usr/bin/env node\n\timport json5 from \"json5\";\n\timport path from \"node:path\";\n\timport { compile } from \"../compiler\";\n\timport { Grammar } from \"../schema\";\n\timport { createArtifacts } from \"./generators\";\n\timport {\n\t  createDirectory,\n\t  createFile,\n\t  decamelize,\n", "  loadFile,\n\t  parseArguments,\n\t  resolvePath,\n\t} from \"./utils\";\n\timport { ContextNode } from \"../types\";\n\tconst use =\n\t  \"Use: npx create-eventually-arts --src=path-to-model --dir=path-to-target\";\n\tconst { dir, src } = parseArguments(process.argv);\n\tif (!(dir && src)) {\n\t  console.log(use);\n", "  process.exit(1);\n\t}\n\tconst srcPath = resolvePath(src);\n\tconsole.log(\"Source path:\", srcPath);\n\tconst dirPath = resolvePath(dir);\n\tconsole.log(\"Target path:\", dirPath);\n\tconst code = loadFile(srcPath);\n\tif (!code) {\n\t  console.error(\"Model not found at:\", srcPath);\n\t  process.exit(1);\n", "}\n\tcreateDirectory(dirPath);\n\tconst model = Grammar.parse(json5.parse(code));\n\tconst root = compile(model);\n\troot.nodes.forEach((ctx, name) => {\n\t  const pkg = decamelize(name);\n\t  const cdir = path.join(dirPath, pkg);\n\t  createDirectory(path.join(cdir));\n\t  createDirectory(path.join(cdir, \"/schemas\"));\n\t  console.log(`Creating artifacts in context ${ctx.name}:`, cdir, \"...\");\n", "  createArtifacts(ctx as ContextNode, (art, result, schemas) => {\n\t    console.log(`... ${art.visual} ${art.name}`);\n\t    createFile(path.join(cdir, `${art.name}.${art.visual}.ts`), result.content);\n\t    createFile(path.join(cdir, `${art.name}.spec.ts`), result.unitTest);\n\t    Object.entries(schemas.schemas).forEach(([name, content]) =>\n\t      createFile(path.join(cdir, `/schemas/${name}.schema.ts`), content)\n\t    );\n\t    createFile(path.join(cdir, `/schemas/${art.name}.ts`), schemas.map);\n\t  });\n\t});\n", "console.log(\"Successfully created eventually artifacts 🚀\");\n"]}
{"filename": "src/cli/utils.ts", "chunked_list": ["import { execSync } from \"node:child_process\";\n\timport * as fs from \"node:fs\";\n\timport os from \"node:os\";\n\timport path from \"node:path\";\n\timport { Arguments } from \"./types\";\n\texport function parseArguments(args: string[]): Arguments {\n\t  const parsedArgs: Arguments = {};\n\t  args.forEach((arg) => {\n\t    const matches = arg.match(/^--([^=]+)=(.*)$/);\n\t    if (matches) {\n", "      const key = matches[1];\n\t      const value = matches[2];\n\t      parsedArgs[key] = value;\n\t    }\n\t  });\n\t  return parsedArgs;\n\t}\n\texport function resolvePath(p: string): string {\n\t  return p\n\t    ? p.startsWith(\"~/\")\n", "      ? path.resolve(os.homedir(), p.slice(2))\n\t      : path.resolve(p)\n\t    : process.cwd();\n\t}\n\texport function createDirectory(directory: string): void {\n\t  if (!fs.existsSync(directory)) {\n\t    fs.mkdirSync(directory);\n\t  }\n\t}\n\texport function createFile(filePath: string, content: string): void {\n", "  fs.writeFileSync(filePath, content);\n\t}\n\texport function loadFile(filePath: string): string | undefined {\n\t  return fs.existsSync(filePath)\n\t    ? fs.readFileSync(filePath).toString()\n\t    : undefined;\n\t}\n\texport function executeCommand(command: string): void {\n\t  execSync(command, { stdio: \"inherit\" });\n\t}\n", "export function decamelize(value: string): string {\n\t  return value\n\t    .replace(/([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})/gu, \"$1-$2\")\n\t    .replace(\n\t      /(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)/gu,\n\t      \"$1-$2\"\n\t    )\n\t    .toLowerCase();\n\t}\n"]}
{"filename": "src/cli/schemas.ts", "chunked_list": ["import { randomUUID } from \"node:crypto\";\n\timport {\n\t  ScalarFieldTypes,\n\t  type FieldType,\n\t  type Node,\n\t  Schema,\n\t  Visual,\n\t} from \"../types\";\n\timport type { Art } from \"./types\";\n\tfunction toZodType(type: FieldType, required = true): string {\n", "  let t: string;\n\t  if (ScalarFieldTypes.includes(type as any)) {\n\t    switch (type) {\n\t      case \"uuid\":\n\t        t = \"z.string().uuid()\";\n\t        break;\n\t      default:\n\t        t = `z.${type}()`;\n\t        break;\n\t    }\n", "  } else t = type.toString();\n\t  return required ? t : t.concat(\".optional()\");\n\t}\n\tfunction toZod(schema?: Schema, indent = 3): string {\n\t  return `z.object({${\n\t    schema && schema.size > 0\n\t      ? \"\\n\".concat(\n\t          [...schema.values()]\n\t            .map(\n\t              (f) =>\n", "                `${\" \".repeat(indent * 2)}${f.name}: ${toZodType(\n\t                  f.type,\n\t                  f.required\n\t                )}`\n\t            )\n\t            .join(\",\\n\"),\n\t          \"\\n\",\n\t          \" \".repeat((indent - 1) * 2),\n\t          \"})\"\n\t        )\n", "      : \"})\"\n\t  }${schema?.description ? `.describe(\"${schema.description}\")` : \"\"}`;\n\t}\n\tfunction toDefaultValue(type: FieldType): string {\n\t  switch (type) {\n\t    case \"boolean\":\n\t      return \"true\";\n\t    case \"number\":\n\t      return \"0\";\n\t    case \"uuid\":\n", "      return `\"${randomUUID()}\"`;\n\t    case \"date\":\n\t      return \"new Date()\";\n\t    case \"string\":\n\t      return '\"\"';\n\t    default:\n\t      return toDefault(type);\n\t  }\n\t}\n\texport function toDefault(schema?: Schema): string {\n", "  return `{${\n\t    schema\n\t      ? [...(schema.base?.values() ?? []), ...schema.values()]\n\t          .map((f) => `${f.name}: ${toDefaultValue(f.type)}`)\n\t          .join(\", \")\n\t      : \"\"\n\t  }}`;\n\t}\n\texport function toDefaultEvent(event: Node): string {\n\t  return `{ name: \"${\n", "    event.name\n\t  }\", id: 0, stream: \"\", version: 0, created: new Date(), metadata: { correlation: \"\", causation: {} }, data: ${toDefault(\n\t    event.ctx.schemas.get(event.name)\n\t  )} }`;\n\t}\n\tfunction toSchema(art: Art): string | undefined {\n\t  const inputs = art.in.map((v) => `    ${v.name}`).join(\",\\n\");\n\t  const outputs = art.out.map((v) => `    ${v.name}`).join(\",\\n\");\n\t  switch (art.visual) {\n\t    case \"system\":\n", "      return `\n\t  commands: {\n\t${inputs} \n\t  },\n\t  events: {\n\t${outputs} \n\t  },`;\n\t    case \"aggregate\":\n\t      return `\n\t  state: ${art.name},\n", "  commands: {\n\t${inputs} \n\t  },\n\t  events: {\n\t${outputs} \n\t  },`;\n\t    case \"policy\":\n\t      return `\n\t  commands: {\n\t${outputs} \n", "  },\n\t  events: {\n\t${inputs} \n\t  },`;\n\t    case \"process\":\n\t      return `\n\t  state: ${art.name},\n\t  commands: {\n\t${outputs} \n\t  },\n", "  events: {\n\t${inputs} \n\t  },`;\n\t    case \"projector\":\n\t      return `\n\t  state: ${art.name},\n\t  events: {\n\t${inputs} \n\t  },`;\n\t  }\n", "}\n\tconst withState: Visual[] = [\"aggregate\", \"process\", \"projector\"];\n\texport function createSchemas(art: Art): {\n\t  map: string;\n\t  schemas: Record<string, string>;\n\t} {\n\t  const schemas: Record<string, string> = {};\n\t  const addSchema = (schema: Schema) => {\n\t    const name = schema.toString();\n\t    console.log(\"... schema\", name);\n", "    let content = toZod(schema, 1);\n\t    const refs: string[] = [];\n\t    if (schema.base) {\n\t      refs.push(schema.base.toString());\n\t      addSchema(schema.base);\n\t      content = `${schema.base.toString()}.and(${content})`;\n\t    }\n\t    schema.forEach((field) => {\n\t      if (!ScalarFieldTypes.includes(field.type as any)) {\n\t        const ref = field.type as Schema;\n", "        refs.push(ref.toString());\n\t        addSchema(ref);\n\t      }\n\t    });\n\t    const imports = refs\n\t      .sort()\n\t      .map((schema) => `import { ${schema} } from \"./${schema}.schema\";`)\n\t      .join(\"\\n\");\n\t    schemas[name] = `import { z } from \"zod\";\n\t${imports.length ? `${imports}\\n` : \"\"}\n", "export const ${name} = ${content}\n\t  `;\n\t  };\n\t  // collect schemas\n\t  let state = art.ctx.schemas.get(art.name);\n\t  if (withState.includes(art.visual) && !state) {\n\t    state = new Schema(art.name);\n\t    if (art.visual === \"projector\")\n\t      state.set(\"id\", { name: \"id\", type: \"string\", required: true });\n\t  }\n", "  const artSchemas = [\n\t    state,\n\t    ...art.in.map((v) => v.ctx.schemas.get(v.name) ?? new Schema(v.name)),\n\t    ...art.out.map((v) => v.ctx.schemas.get(v.name) ?? new Schema(v.name)),\n\t  ].filter(Boolean);\n\t  artSchemas.forEach((schema) => addSchema(schema!));\n\t  // fake ouput schema for processes\n\t  const outputSchema =\n\t    art.visual === \"process\" &&\n\t    `export const ${art.name}OutputSchema = {\n", "  TodoOutputEvents: z.object({}),\n\t};`;\n\t  // collect art schemas in a file with imports to message and state schemas\n\t  const map = `${artSchemas\n\t    .map((schema) => schema!.name)\n\t    .sort()\n\t    .map((name) => `import { ${name} } from \"./${name}.schema\";`)\n\t    .join(\"\\n\")}  \n\texport const ${art.name}Schemas = {${toSchema(art)}\n\t};\n", "${outputSchema || \"\"}\n\t`;\n\t  return { map, schemas };\n\t}\n"]}
{"filename": "src/cli/gen-schema.ts", "chunked_list": ["#!/usr/bin/env node\n\timport { zodToJsonSchema } from \"zod-to-json-schema\";\n\timport { Grammar } from \"../schema\";\n\tconst schema = zodToJsonSchema(Grammar, \"esml\");\n\tconsole.log(JSON.stringify(schema, null, 2));\n"]}
{"filename": "src/cli/generators.ts", "chunked_list": ["import json5 from \"json5\";\n\timport path from \"node:path\";\n\timport { compile } from \"../compiler\";\n\timport { Grammar } from \"../schema\";\n\timport type { ContextNode, Visual } from \"../types\";\n\timport { createJestConfig, createPackageJson, createTsConfig } from \"./configs\";\n\timport { createSchemas, toDefault, toDefaultEvent } from \"./schemas\";\n\timport {\n\t  generateDockerCompose,\n\t  generateScripts,\n", "  generateVsCodeTasks,\n\t} from \"./scripts\";\n\timport { Art } from \"./types\";\n\timport { createDirectory, createFile, decamelize } from \"./utils\";\n\tfunction createIndexFile(filePath: string, arts: Art[]): void {\n\t  const indexContent = `import { app, bootstrap } from \"@rotorsoft/eventually\";\n\timport { ExpressApp } from \"@rotorsoft/eventually-express\";\n\t${arts\n\t  .map(({ name, visual }) => `import { ${name} } from \"./${name}.${visual}\";`)\n\t  .join(\"\\n\")}\n", "bootstrap(async () => {\n\t  app(new ExpressApp())\\n${arts\n\t    .map(({ name }) => `    .with(${name})`)\n\t    .join(\"\\n\")};\n\t  app().build();\n\t  await app().listen();\n\t});`;\n\t  createFile(filePath, indexContent);\n\t}\n\ttype ArtResult = { content: string; unitTest: string };\n", "const artMap: { [key in Visual]?: (art: Art) => ArtResult } = {\n\t  aggregate: createAggregate,\n\t  system: createSystem,\n\t  policy: createPolicy,\n\t  process: createProcess,\n\t  projector: createProjector,\n\t};\n\tconst Arts: Array<Visual> = [\n\t  \"aggregate\",\n\t  \"system\",\n", "  \"policy\",\n\t  \"process\",\n\t  \"projector\",\n\t];\n\tfunction createAggregate(art: Art): ArtResult {\n\t  const content = `import { InferAggregate } from \"@rotorsoft/eventually\";\n\timport { ${art.name}Schemas } from \"./schemas/${art.name}\";\n\texport const ${art.name} = (stream: string): InferAggregate<typeof ${\n\t    art.name\n\t  }Schemas> => ({\n", "  description: \"${art.description ?? \"TODO: describe this artifact!\"}\",\n\t  stream,\n\t  schemas: ${art.name}Schemas,\n\t  init: () => (${toDefault(art.ctx.schemas.get(art.name))}),\n\t  reduce: {\n\t${art.out\n\t  .map(\n\t    (event) => `    ${event.name}: (state, { data }) => ({ ...state, ...data })`\n\t  )\n\t  .join(\",\\n\")} \n", "  },\n\t  given: {\n\t${art.in.map((command) => `    ${command.name}: []`).join(\",\\n\")} \n\t  },\n\t  on: {\n\t${art.in\n\t  .map(\n\t    (command) =>\n\t      `    ${command.name}: (data, state, actor) => { return Promise.resolve([]); }`\n\t  )\n", "  .join(\",\\n\")} \n\t  },\n\t});  \n\t`;\n\t  const unitTest = `import { app, client, dispose } from \"@rotorsoft/eventually\";\n\timport { ${art.name} } from \"../${art.name}.${art.visual}\";\n\timport { randomUUID } from \"node:crypto\";\n\tdescribe(\"${art.name} ${art.visual}\", () => {\n\t  beforeAll(() => {\n\t    app().with(${art.name}).build();\n", "  });\n\t  afterAll(async () => {\n\t    await dispose()();\n\t  });\n\t  it(\"should handle commands\", async() => {\n\t    const target = { stream: randomUUID(), actor: { id: randomUUID(), name: \"actor\", roles: [] } };\n\t${art.in\n\t  .map(\n\t    (command) =>\n\t      `    await client().command(${art.name}, \"${command.name}\", ${toDefault(\n", "        command.ctx.schemas.get(command.name)\n\t      )}, target);`\n\t  )\n\t  .join(\"\\n\")}\n\t    const snap = await client().load(${art.name}, target.stream);\n\t    expect(snap.state).toBeDefined;\n\t  })\n\t})  \n\t`;\n\t  return { content, unitTest };\n", "}\n\tfunction createSystem(art: Art): ArtResult {\n\t  const content = `import { InferSystem } from \"@rotorsoft/eventually\";\n\timport { ${art.name}Schemas } from \"./schemas/${art.name}\";\n\texport const ${art.name} = (): InferSystem<typeof ${art.name}Schemas> => ({\n\t  description: \"${art.description ?? \"TODO: describe this artifact!\"}\",\n\t  stream: \"${art.name}\",\n\t  schemas: ${art.name}Schemas,\n\t  on: {\n\t${art.in\n", "  .map(\n\t    (command) =>\n\t      `    ${command.name}: (data, state, actor) => { return Promise.resolve([]); }`\n\t  )\n\t  .join(\",\\n\")} \n\t  },\n\t});  \n\t`;\n\t  const unitTest = `import { app, client, dispose } from \"@rotorsoft/eventually\";\n\timport { ${art.name} } from \"../${art.name}.${art.visual}\";\n", "import { randomUUID } from \"node:crypto\";\n\tdescribe(\"${art.name} ${art.visual}\", () => {\n\t  beforeAll(() => {\n\t    app().with(${art.name}).build();\n\t  });\n\t  afterAll(async () => {\n\t    await dispose()();\n\t  });\n\t  it(\"should handle commands\", async() => {\n\t    const target = { stream: randomUUID(), actor: { id: randomUUID(), name: \"actor\", roles: [] } };\n", "${art.in\n\t  .map(\n\t    (command) =>\n\t      `    await client().command(${art.name}, \"${command.name}\", ${toDefault(\n\t        command.ctx.schemas.get(command.name)\n\t      )}, target);`\n\t  )\n\t  .join(\"\\n\")}\n\t    const result = await client().query({ stream: \"${art.name}\" });\n\t    expect(result).toBeDefined();\n", "  })\n\t})  \n\t`;\n\t  return { content, unitTest };\n\t}\n\tfunction createPolicy(art: Art): ArtResult {\n\t  const content = `import { InferPolicy } from \"@rotorsoft/eventually\";\n\timport { ${art.name}Schemas } from \"./schemas/${art.name}\";\n\texport const ${art.name} = (): InferPolicy<typeof ${art.name}Schemas> => ({\n\t  description: \"${art.description ?? \"TODO: describe this artifact!\"}\",\n", "  schemas: ${art.name}Schemas,\n\t  on: {\n\t${art.in\n\t  .map(\n\t    (event) => `    ${event.name}: () => { return Promise.resolve(undefined); }`\n\t  )\n\t  .join(\",\\n\")} \n\t  },\n\t});\n\t`;\n", "  const unitTest = `import { app, broker, client, dispose } from \"@rotorsoft/eventually\";\n\timport { ${art.name} } from \"../${art.name}.${art.visual}\";\n\tdescribe(\"${art.name} ${art.visual}\", () => {\n\t  beforeAll(() => {\n\t    app().with(${art.name}).build();\n\t  });\n\t  afterAll(async () => {\n\t    await dispose()();\n\t  });\n\t  it(\"should handle events\", async() => {\n", "${art.in\n\t  .map(\n\t    (event) =>\n\t      `    await client().event(${art.name}, ${toDefaultEvent(event)});`\n\t  )\n\t  .join(\"\\n\")}\n\t    await broker().drain();\n\t    expect(1).toBeDefined; // TODO: expect side effects\n\t  })\n\t})  \n", "`;\n\t  return { content, unitTest };\n\t}\n\tfunction createProcess(art: Art): ArtResult {\n\t  const content = `import { InferProcessManager } from \"@rotorsoft/eventually\";\n\timport { ${art.name}Schemas, ${art.name}OutputSchema } from \"./schemas/${\n\t    art.name\n\t  }\";\n\texport const ${art.name} = (): InferProcessManager<typeof ${\n\t    art.name\n", "  }Schemas, typeof ${art.name}OutputSchema> => ({\n\t  description: \"${art.description ?? \"TODO: describe this artifact!\"}\",\n\t  schemas: ${art.name}Schemas,\n\t  init: () => (${toDefault(art.ctx.schemas.get(art.name))}),\n\t  reduce: {\n\t    TodoOutputEvents: (state, { data }) => ({ ...state, ...data }), // TODO: reduce all output events\n\t  },\n\t  actor: {\n\t${art.in\n\t  .map((event) => `    ${event.name}: ({ stream }) => stream`)\n", "  .join(\",\\n\")} \n\t  },\n\t  on: {\n\t${art.in\n\t  .map(\n\t    (event) => `    ${event.name}: () => { return Promise.resolve(undefined); }`\n\t  )\n\t  .join(\",\\n\")} \n\t  },\n\t});\n", "`;\n\t  const unitTest = `import { app, broker, client, dispose } from \"@rotorsoft/eventually\";\n\timport { ${art.name} } from \"../${art.name}.${art.visual}\";\n\tdescribe(\"${art.name} ${art.visual}\", () => {\n\t  beforeAll(() => {\n\t    app().with(${art.name}).build();\n\t  });\n\t  afterAll(async () => {\n\t    await dispose()();\n\t  });\n", "  it(\"should handle events\", async() => {\n\t${art.in\n\t  .map(\n\t    (event) =>\n\t      `    await client().event(${art.name}, ${toDefaultEvent(event)});`\n\t  )\n\t  .join(\"\\n\")}\n\t    await broker().drain();\n\t    expect(1).toBeDefined; // TODO: expect side effects\n\t  })\n", "})  \n\t`;\n\t  return { content, unitTest };\n\t}\n\tfunction createProjector(art: Art): ArtResult {\n\t  const content = `import { client, InferProjector } from \"@rotorsoft/eventually\";\n\timport { ${art.name}Schemas } from \"./schemas/${art.name}\";\n\texport const ${art.name} = (): InferProjector<typeof ${art.name}Schemas> => ({\n\t  description: \"${art.description ?? \"TODO: describe this artifact!\"}\",\n\t  schemas: ${art.name}Schemas,\n", "  on: {\n\t${art.in\n\t  .map(\n\t    (event) =>\n\t      `    ${event.name}: async ({ stream, data }, map) => {\n\t        const id = stream; // TBD\n\t        // load current state?\n\t        const state = map.records.get(id) ?? (await client().read(${art.name}, id)).at(0)?.state ?? { id };\n\t        const patches = [{}]; // TBD\n\t        return patches; // TBD\n", "      }`\n\t  )\n\t  .join(\",\\n\")} \n\t  },\n\t});\n\t`;\n\t  const unitTest = `import { app, broker, client, dispose } from \"@rotorsoft/eventually\";\n\timport { ${art.name} } from \"../${art.name}.${art.visual}\";\n\tdescribe(\"${art.name} ${art.visual}\", () => {\n\t  beforeAll(() => {\n", "    app().with(${art.name}).build();\n\t  });\n\t  afterAll(async () => {\n\t    await dispose()();\n\t  });\n\t  it(\"should handle events\", async() => {\n\t    await client().project(${art.name}, [\n\t${art.in.map((event) => `      ${toDefaultEvent(event)}`).join(\",\\n\")}\n\t    ]);\n\t    await broker().drain();\n", "    const records = await client().read(${art.name}, \"projectionId\", ()=>{});\n\t  })\n\t})  \n\t`;\n\t  return { content, unitTest };\n\t}\n\texport function createArtifacts(\n\t  ctx: ContextNode,\n\t  callback: (\n\t    art: Art,\n", "    result: ArtResult,\n\t    schemas: { map: string; schemas: Record<string, string> }\n\t  ) => void\n\t): Art[] {\n\t  const refs = ctx\n\t    ? [...ctx.nodes.values()]\n\t        .filter((node) => node.visual === \"command\" && node.refs) // commands with refs\n\t        .flatMap((cmd) =>\n\t          [...cmd.refs!.values()]\n\t            .filter((ref) => ref.visual !== \"actor\") // skip actor refs\n", "            .flatMap(({ name }) => ({ name, cmd }))\n\t        )\n\t    : [];\n\t  const arts: Art[] = ctx\n\t    ? [...ctx.nodes.entries()]\n\t        .filter(([, value]) => Arts.includes(value.visual))\n\t        .map(([name, value]) => ({\n\t          ...value,\n\t          in: [...ctx.edges.values()]\n\t            .filter(({ target }) => target.name === name)\n", "            .map(({ source }) => source),\n\t          out: [...ctx.edges.values()]\n\t            .filter(({ source }) => source.name === name)\n\t            .map(({ target }) => target)\n\t            .concat(\n\t              refs.filter((ref) => ref.name === name).map(({ cmd }) => cmd) // commands with refs to this art\n\t            ),\n\t        }))\n\t        .sort((a, b) => a.name.localeCompare(b.name))\n\t    : [];\n", "  arts.forEach((art) => {\n\t    const result = artMap[art.visual]!(art);\n\t    const schemas = createSchemas(art);\n\t    callback(art, result, schemas);\n\t  });\n\t  return arts;\n\t}\n\tfunction generateContext(\n\t  cdir: string,\n\t  name: string,\n", "  ctx: ContextNode,\n\t  workspace = false\n\t): void {\n\t  createDirectory(cdir);\n\t  createPackageJson(cdir, name);\n\t  createJestConfig(cdir);\n\t  workspace && createTsConfig(cdir, \"../../tsconfig.json\");\n\t  createDirectory(path.join(cdir, \"src\"));\n\t  createDirectory(path.join(cdir, \"src\", \"schemas\"));\n\t  createDirectory(path.join(cdir, \"src\", \"__tests__\"));\n", "  createDirectory(path.join(cdir, \"dist\"));\n\t  const arts = createArtifacts(ctx, (art, result, schemas) => {\n\t    createFile(\n\t      path.join(cdir, `src/${art.name}.${art.visual}.ts`),\n\t      result.content\n\t    );\n\t    createFile(\n\t      path.join(cdir, `src/__tests__/${art.name}.spec.ts`),\n\t      result.unitTest\n\t    );\n", "    Object.entries(schemas.schemas).forEach(([name, content]) =>\n\t      createFile(path.join(cdir, `src/schemas/${name}.schema.ts`), content)\n\t    );\n\t    createFile(path.join(cdir, `src/schemas/${art.name}.ts`), schemas.map);\n\t  });\n\t  createIndexFile(path.join(cdir, \"src/index.ts\"), arts);\n\t}\n\texport function generateContexts(\n\t  pdir: string,\n\t  project: string,\n", "  code: string\n\t): void {\n\t  const model = Grammar.parse(json5.parse(code));\n\t  const root = compile(model);\n\t  const ids = [...root.nodes.keys()].map((id) => decamelize(id)).sort();\n\t  createPackageJson(\n\t    pdir,\n\t    project,\n\t    ids.map((id) => `packages/${id}`)\n\t  );\n", "  createDirectory(path.join(pdir, \"packages\"));\n\t  root.nodes.forEach((node, name) => {\n\t    const pkg = decamelize(name);\n\t    generateContext(\n\t      path.join(pdir, \"packages\", pkg),\n\t      pkg,\n\t      node as ContextNode,\n\t      true\n\t    );\n\t  });\n", "  generateVsCodeTasks(path.join(pdir, \".vscode\"), ids);\n\t  generateScripts(path.join(pdir, \"scripts\"));\n\t  generateDockerCompose(pdir, ids);\n\t}\n"]}
{"filename": "src/cli/scripts.ts", "chunked_list": ["import path from \"node:path\";\n\timport { createDirectory, createFile } from \"./utils\";\n\tconst devScript = `#!/bin/bash\n\tset -e\n\tif [ $# -eq 0 ]; then\n\t    echo \"Missing service name!\"\n\t    echo \"Usage: npm run dev service-name [port]\"\n\t    exit 1\n\tfi;\n\treadonly service=\"$1\"\n", "readonly target=\"./packages/$\\{service\\}\"\n\tif [ ! -d $target ]; then\n\t    echo \"Invalid service name: $\\{service\\}\"\n\t    exit 1\n\tfi;\n\treadonly port=\"$2\"\n\techo \">>> Loading [.env] variables...\"\n\tset -o allexport\n\t# shellcheck source=/dev/null # Disable shellcheck source following\n\t. ./.env set\n", "set +o allexport\n\techo \">>> Running [$service] in development mode...\"\n\tcd $target\n\tPORT=$port ts-node-dev --transpile-only --respawn ./src/index.ts\n\tcd ../..\n\t`;\n\texport function generateScripts(dir: string): void {\n\t  createDirectory(dir);\n\t  createFile(path.join(dir, \"dev.sh\"), devScript);\n\t}\n", "export function generateVsCodeTasks(dir: string, ids: string[]): void {\n\t  createDirectory(dir);\n\t  const group = \"all-eventually-apps\";\n\t  const tasks = {\n\t    version: \"2.0.0\",\n\t    tasks: [{ label: group, dependsOn: ids }].concat(\n\t      ids.map(\n\t        (id, index) =>\n\t          ({\n\t            label: id,\n", "            type: \"shell\",\n\t            command: `npm run dev ${id} ${3000 + index}`,\n\t            presentation: {\n\t              reveal: \"always\",\n\t              panel: \"new\",\n\t              group,\n\t            },\n\t          } as any)\n\t      )\n\t    ),\n", "  };\n\t  createFile(path.join(dir, \"tasks.json\"), JSON.stringify(tasks, null, 2));\n\t}\n\texport function generateDockerCompose(dir: string, ids: string[]): void {\n\t  ids.forEach((id) =>\n\t    createFile(\n\t      path.join(dir, \"packages\", id, \"Dockerfile\"),\n\t      `FROM node:18-alpine\n\tWORKDIR /app\n\tCOPY dist ./dist\n", "COPY package.json ./\n\tRUN npm install\n\tEXPOSE 3000\n\tCMD [ \"npm\", \"start\" ]\n\t`\n\t    )\n\t  );\n\t  createFile(\n\t    path.join(dir, \"docker-compose.yml\"),\n\t    `version: '3'\n", "services:\n\t${ids\n\t  .map(\n\t    (id, index) => `  ${id}:\n\t    build:\n\t      context: ./packages/${id}\n\t      dockerfile: Dockerfile\n\t    ports:\n\t      - ${3000 + index}:3000\n\t    environment:\n", "      - LOG_LEVEL=trace\n\t      - OAS_UI=Rapidoc\n\t    command: npm start\n\t`\n\t  )\n\t  .join(\"\\n\")}\n\t`\n\t  );\n\t}\n"]}
