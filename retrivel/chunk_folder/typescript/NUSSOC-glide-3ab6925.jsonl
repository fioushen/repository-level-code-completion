{"filename": "src/declaration.d.ts", "chunked_list": ["declare module '*.svg' {\n\t  import { SVGProps, VFC } from 'react';\n\t  const SVG: VFC<SVGProps<SVGSVGElement>>;\n\t  export default SVG;\n\t}\n\tdeclare module '*.svg?url' {\n\t  const svg: string;\n\t  export default svg;\n\t}\n\tdeclare module '*.py' {\n", "  const script: string;\n\t  export default script;\n\t}\n\tdeclare const __VERSION__: string;\n"]}
{"filename": "src/store/hooks.ts", "chunked_list": ["import type { TypedUseSelectorHook } from 'react-redux';\n\timport { useDispatch, useSelector } from 'react-redux';\n\timport type { AppDispatch, RootState } from '../store';\n\texport const useAppDispatch: () => AppDispatch = useDispatch;\n\texport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n"]}
{"filename": "src/store/vaultSlice.ts", "chunked_list": ["import { createSelector, PayloadAction } from '@reduxjs/toolkit';\n\timport { createSlice } from '@reduxjs/toolkit';\n\timport { RootState } from '.';\n\tinterface File {\n\t  name: string;\n\t  content: string;\n\t}\n\tinterface VaultState {\n\t  files: Record<string, string>;\n\t  list: string[];\n", "}\n\tconst initialState: VaultState = {\n\t  files: {},\n\t  list: [],\n\t};\n\texport const vaultSlice = createSlice({\n\t  name: 'vault',\n\t  initialState,\n\t  reducers: {\n\t    save: (state, action: PayloadAction<File>) => {\n", "      const { name, content } = action.payload;\n\t      if (state.files[name] === undefined) state.list.push(name);\n\t      state.files[name] = content;\n\t    },\n\t    destroy: (state, action: PayloadAction<string>) => {\n\t      const name = action.payload;\n\t      delete state.files[name];\n\t      state.list = state.list.filter((file) => file !== name);\n\t    },\n\t    rename: (state, action: PayloadAction<{ from: string; to: string }>) => {\n", "      const { from: oldName, to: newName } = action.payload;\n\t      const isOldNameExist = state.files[oldName] !== undefined;\n\t      const isNewNameExist = state.files[newName] !== undefined;\n\t      if (!isOldNameExist || isNewNameExist) return;\n\t      state.files[newName] = state.files[oldName];\n\t      delete state.files[oldName];\n\t      state.list = state.list.map((name) =>\n\t        name === oldName ? newName : name,\n\t      );\n\t    },\n", "  },\n\t});\n\tconst selectVault = (state: RootState) => state.vault;\n\texport const getFileNames = createSelector(selectVault, (vault) => vault.list);\n\texport const getFileContent = (name: string) =>\n\t  createSelector(selectVault, (vault) => vault.files[name]);\n\texport const vaultActions = vaultSlice.actions;\n\texport default vaultSlice.reducer;\n"]}
{"filename": "src/store/filesSlice.ts", "chunked_list": ["import { createSelector, PayloadAction } from '@reduxjs/toolkit';\n\timport { createSlice } from '@reduxjs/toolkit';\n\timport { RootState } from '.';\n\tinterface FilesState {\n\t  files: Record<string, string>;\n\t  list: string[];\n\t  selected?: string;\n\t}\n\tconst initialState: FilesState = {\n\t  files: {},\n", "  list: [],\n\t};\n\tconst findSuitableName = (\n\t  name: string,\n\t  list: string[],\n\t  transformer: (counter: number) => string,\n\t) => {\n\t  const names = new Set(list);\n\t  let counter = 0;\n\t  let newName = name;\n", "  while (names.has(newName)) {\n\t    newName = transformer(counter);\n\t    counter += 1;\n\t  }\n\t  return newName;\n\t};\n\texport const filesSlice = createSlice({\n\t  name: 'files',\n\t  initialState,\n\t  reducers: {\n", "    rehydrate: (\n\t      state,\n\t      action: PayloadAction<Pick<FilesState, 'files' | 'list'>>,\n\t    ) => {\n\t      state.files = action.payload.files;\n\t      state.list = action.payload.list;\n\t    },\n\t    draft: (state, action: PayloadAction<boolean | undefined>) => {\n\t      const name = findSuitableName(\n\t        'untitled.py',\n", "        state.list,\n\t        (counter) => `untitled-${counter + 1}.py`,\n\t      );\n\t      state.files[name] = '';\n\t      state.list.push(name);\n\t      const select = action.payload;\n\t      if (select) state.selected = name;\n\t    },\n\t    create: (\n\t      state,\n", "      action: PayloadAction<{ name: string; content: string }>,\n\t    ) => {\n\t      const { name, content } = action.payload;\n\t      const newName = findSuitableName(\n\t        name,\n\t        state.list,\n\t        (counter) => `Copy${counter ? ` ${counter}` : ''} of ${name}`,\n\t      );\n\t      state.files[newName] = content;\n\t      state.list.push(newName);\n", "      state.selected = newName;\n\t    },\n\t    updateSelected: (state, action: PayloadAction<string>) => {\n\t      if (state.selected === undefined) return;\n\t      state.files[state.selected] = action.payload;\n\t    },\n\t    destroy: (state, action: PayloadAction<string>) => {\n\t      const name = action.payload;\n\t      delete state.files[name];\n\t      state.list = state.list.filter((file) => file !== name);\n", "      if (state.selected === name) state.selected = undefined;\n\t    },\n\t    select: (state, action: PayloadAction<string>) => {\n\t      const name = action.payload;\n\t      if (state.files[name] === undefined) return;\n\t      state.selected = name;\n\t    },\n\t    rename: (state, action: PayloadAction<{ from: string; to: string }>) => {\n\t      const { from: oldName, to: newName } = action.payload;\n\t      const isOldNameExist = state.files[oldName] !== undefined;\n", "      const isNewNameExist = state.files[newName] !== undefined;\n\t      if (!isOldNameExist || isNewNameExist) return;\n\t      state.files[newName] = state.files[oldName];\n\t      delete state.files[oldName];\n\t      state.list = state.list.map((name) =>\n\t        name === oldName ? newName : name,\n\t      );\n\t      if (state.selected === oldName) state.selected = newName;\n\t    },\n\t  },\n", "});\n\tconst selectFiles = (state: RootState) => state.files;\n\texport const getSelectedFileName = createSelector(\n\t  selectFiles,\n\t  (files) => files.selected,\n\t);\n\texport const getSelectedFile = createSelector(selectFiles, (files) =>\n\t  files.selected\n\t    ? { name: files.selected, content: files.files[files.selected] }\n\t    : { name: undefined, content: undefined },\n", ");\n\texport const filesActions = filesSlice.actions;\n\texport default filesSlice.reducer;\n"]}
{"filename": "src/store/index.ts", "chunked_list": ["import { configureStore } from '@reduxjs/toolkit';\n\timport localforage from 'localforage';\n\timport {\n\t  FLUSH,\n\t  PAUSE,\n\t  PERSIST,\n\t  persistCombineReducers,\n\t  persistStore,\n\t  PURGE,\n\t  REGISTER,\n", "  REHYDRATE,\n\t} from 'redux-persist';\n\timport filesReducer, { filesActions } from './filesSlice';\n\timport vaultReducer from './vaultSlice';\n\tconst persistConfig = {\n\t  key: 'root',\n\t  storage: localforage,\n\t  whitelist: ['vault'],\n\t};\n\tconst rootReducer = persistCombineReducers(persistConfig, {\n", "  files: filesReducer,\n\t  vault: vaultReducer,\n\t});\n\texport const store = configureStore({\n\t  reducer: rootReducer,\n\t  middleware: (getDefaultMiddleware) =>\n\t    getDefaultMiddleware({\n\t      serializableCheck: {\n\t        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n\t      },\n", "    }),\n\t});\n\texport const persistor = persistStore(store, null, () => {\n\t  const vault = store.getState().vault;\n\t  store.dispatch(filesActions.rehydrate(vault));\n\t});\n\texport const getState = store.getState;\n\texport type RootState = ReturnType<typeof store.getState>;\n\texport type AppDispatch = typeof store.dispatch;\n"]}
{"filename": "src/hooks/useFilesMutations.ts", "chunked_list": ["import { persistor } from '../store';\n\timport { filesActions } from '../store/filesSlice';\n\timport { useAppDispatch } from '../store/hooks';\n\timport { vaultActions } from '../store/vaultSlice';\n\tinterface UseFilesMutationsHook {\n\t  /**\n\t   * For performance reasons, the caller should ensure that the new\n\t   * name is not already in use in *both* the files and vault stores.\n\t   */\n\t  rename: (from: string, to: string) => void;\n", "  save: (name: string, content: string) => void;\n\t  destroy: (name: string) => void;\n\t  draft: (autoSelect?: boolean) => void;\n\t  select: (name: string) => void;\n\t  update: (content: string) => void;\n\t  create: (name: string, content: string) => void;\n\t}\n\tconst useFilesMutations = (): UseFilesMutationsHook => {\n\t  const dispatch = useAppDispatch();\n\t  return {\n", "    save: (name: string, content: string) => {\n\t      dispatch(filesActions.updateSelected(content));\n\t      dispatch(vaultActions.save({ name, content }));\n\t      persistor.flush();\n\t    },\n\t    rename: (from: string, to: string) => {\n\t      if (from === to) return;\n\t      dispatch(filesActions.rename({ from, to }));\n\t      dispatch(vaultActions.rename({ from, to }));\n\t      persistor.flush();\n", "    },\n\t    destroy: (name: string) => {\n\t      dispatch(filesActions.destroy(name));\n\t      dispatch(vaultActions.destroy(name));\n\t      persistor.flush();\n\t    },\n\t    draft: (autoSelect?: boolean) => {\n\t      dispatch(filesActions.draft(autoSelect));\n\t    },\n\t    select: (name: string) => {\n", "      dispatch(filesActions.select(name));\n\t    },\n\t    update: (content: string) => {\n\t      dispatch(filesActions.updateSelected(content));\n\t    },\n\t    create: (name: string, content: string) => {\n\t      dispatch(filesActions.create({ name, content }));\n\t      dispatch(vaultActions.save({ name, content }));\n\t      persistor.flush();\n\t    },\n", "  };\n\t};\n\texport default useFilesMutations;\n"]}
{"filename": "src/hooks/useFile.ts", "chunked_list": ["import { getState } from '../store';\n\timport { getSelectedFile, getSelectedFileName } from '../store/filesSlice';\n\timport { useAppSelector } from '../store/hooks';\n\tconst Selected = () => useAppSelector(getSelectedFile);\n\tconst SelectedName = () => useAppSelector(getSelectedFileName);\n\tconst NamesSet = () =>\n\t  useAppSelector(({ files, vault }) => new Set(files.list.concat(vault.list)));\n\tconst NamesWithUnsaved = () =>\n\t  useAppSelector(({ files, vault }) =>\n\t    files.list.map((name) => {\n", "      const fileInFiles = files.files[name];\n\t      const fileInVault = vault.files[name];\n\t      return { name, unsaved: fileInFiles !== fileInVault };\n\t    }),\n\t  );\n\tconst IsUnsavedOf = (name?: string) =>\n\t  useAppSelector(({ files, vault }) => {\n\t    if (!name) return true;\n\t    const fileInFiles = files.files[name];\n\t    const fileInVault = vault.files[name];\n", "    return fileInFiles !== fileInVault;\n\t  });\n\tconst Exports = () => {\n\t  const { files, list } = getState().vault;\n\t  return list.map((name) => ({ name, content: files[name] }));\n\t};\n\tconst useFile = {\n\t  SelectedName,\n\t  Selected,\n\t  NamesSet,\n", "  NamesWithUnsaved,\n\t  IsUnsavedOf,\n\t  Exports,\n\t};\n\texport default useFile;\n"]}
{"filename": "src/hooks/useInterpreter.ts", "chunked_list": ["import { useEffect, useRef } from 'react';\n\tinterface Interpreter {\n\t  run: (code: string) => void;\n\t  stop: () => void;\n\t  execute: (command: string) => void;\n\t  restart: () => void;\n\t}\n\tinterface Callbacks {\n\t  write: (text: string) => void;\n\t  writeln: (text: string) => void;\n", "  error: (text: string) => void;\n\t  system: (text: string) => void;\n\t  exports?: () => { name: string; content: string }[];\n\t  lock: () => void;\n\t  unlock: () => void;\n\t}\n\tinterface Message<L extends Record<string, any>> {\n\t  type: keyof L;\n\t  payload: any;\n\t}\n", "const useInterpreter = (callbacks: Callbacks): Interpreter => {\n\t  const workerRef = useRef<Worker>();\n\t  const interruptBufferRef = useRef<Uint8Array>();\n\t  const setUpInterpreterWorker = () => {\n\t    const worker = new Worker(\n\t      new URL('../workers/interpreter.worker.ts', import.meta.url),\n\t    );\n\t    worker.onmessage = (event: MessageEvent<Message<Callbacks>>) => {\n\t      callbacks[event.data.type]?.(event.data.payload);\n\t    };\n", "    let interruptBuffer: Uint8Array | null = null;\n\t    if (typeof SharedArrayBuffer !== 'undefined') {\n\t      interruptBuffer = new Uint8Array(new SharedArrayBuffer(1));\n\t      interruptBufferRef.current = interruptBuffer;\n\t    }\n\t    worker.postMessage({ type: 'initialize', payload: interruptBuffer });\n\t    workerRef.current = worker;\n\t  };\n\t  useEffect(() => {\n\t    if (workerRef.current) return;\n", "    setUpInterpreterWorker();\n\t  }, []);\n\t  const resetInterruptBuffer = () => {\n\t    if (!interruptBufferRef.current) return;\n\t    interruptBufferRef.current[0] = 0;\n\t  };\n\t  const restartInterpreter = () => {\n\t    workerRef.current?.terminate();\n\t    setUpInterpreterWorker();\n\t  };\n", "  return {\n\t    run: (code) => {\n\t      resetInterruptBuffer();\n\t      workerRef.current?.postMessage({\n\t        type: 'run',\n\t        payload: { code, exports: callbacks.exports?.() },\n\t      });\n\t    },\n\t    stop: () => {\n\t      if (interruptBufferRef.current) {\n", "        interruptBufferRef.current[0] = 2;\n\t        workerRef.current?.postMessage({ type: 'replClear' });\n\t      } else {\n\t        callbacks.system(\n\t          \"\\nDue to browser incompatibility, we can't stop your code execution gracefully. Instead, we'll restart the interpreter for you. Hold on yah...\\n\",\n\t        );\n\t        restartInterpreter();\n\t      }\n\t    },\n\t    execute: (code) => {\n", "      resetInterruptBuffer();\n\t      workerRef.current?.postMessage({\n\t        type: 'replInput',\n\t        payload: { code, exports: callbacks.exports?.() },\n\t      });\n\t    },\n\t    restart: () => {\n\t      callbacks.system('\\nOkies! Restarting interpreter...\\n');\n\t      restartInterpreter();\n\t    },\n", "  };\n\t};\n\texport default useInterpreter;\n"]}
{"filename": "src/hooks/useCommandHistory.ts", "chunked_list": ["import { useRef, useState } from 'react';\n\timport produce from 'immer';\n\tinterface CommandHistory {\n\t  push: (command: string) => void;\n\t  previous: () => string | undefined;\n\t  next: () => string | undefined;\n\t}\n\tconst MAX_HISTORY_LENGTH = 100 as const;\n\tconst useCommandHistory = (): CommandHistory => {\n\t  const [history, setHistory] = useState<string[]>([]);\n", "  const position = useRef(0);\n\t  return {\n\t    push: (command: string) => {\n\t      position.current = 0;\n\t      setHistory(\n\t        produce((draft) => {\n\t          if (draft.length >= MAX_HISTORY_LENGTH) draft.splice(0, 1);\n\t          draft.push(command);\n\t        }),\n\t      );\n", "    },\n\t    previous: () => {\n\t      if (!history.length) return undefined;\n\t      position.current = Math.max(position.current - 1, -history.length);\n\t      return history.at(position.current);\n\t    },\n\t    next: () => {\n\t      if (!history.length) return undefined;\n\t      position.current = Math.min(position.current + 1, 0);\n\t      return position.current ? history.at(position.current) : undefined;\n", "    },\n\t  };\n\t};\n\texport default useCommandHistory;\n"]}
{"filename": "src/workers/interpreter.worker.ts", "chunked_list": ["import {\n\t  loadPyodide,\n\t  PyodideInterface,\n\t  PyProxy,\n\t  PyProxyAwaitable,\n\t  PyProxyCallable,\n\t  PyProxyDict,\n\t} from 'pyodide';\n\timport consoleScript from '../assets/console.py';\n\t/**\n", " * @see https://pyodide.org/en/stable/usage/api/python-api/console.html#pyodide.console.ConsoleFuture.syntax_check\n\t */\n\ttype SyntaxCheck = 'syntax-error' | 'incomplete' | 'complete';\n\tinterface Message<T extends Record<string, unknown>> {\n\t  type: keyof T;\n\t  payload: any;\n\t}\n\tinterface RunExportableData {\n\t  code: string;\n\t  exports?: { name: string; content: string }[];\n", "}\n\tlet pyodide: PyodideInterface;\n\tlet interruptBuffer: Uint8Array | null;\n\tlet await_fut: PyProxyCallable;\n\tlet repr_shorten: PyProxyCallable;\n\tlet pyconsole: PyProxy;\n\tlet clear_console: PyProxyCallable;\n\tlet create_console: PyProxyCallable;\n\tconst PS1 = '\\u001b[32;1m>>> \\u001b[0m' as const;\n\tconst PS2 = '\\u001b[32m... \\u001b[0m' as const;\n", "const RUN_CODE = '\\u001b[3m\\u001b[32m<run code>\\u001b[0m' as const;\n\tconst post = {\n\t  write: (text: string) => postMessage({ type: 'write', payload: text }),\n\t  writeln: (line: string) => postMessage({ type: 'writeln', payload: line }),\n\t  error: (message: string) => postMessage({ type: 'error', payload: message }),\n\t  system: (message: string) =>\n\t    postMessage({ type: 'system', payload: message }),\n\t  lock: () => postMessage({ type: 'lock' }),\n\t  unlock: () => postMessage({ type: 'unlock' }),\n\t  prompt: (newLine = true) => post.write(`${newLine ? '\\n' : ''}${PS1}`),\n", "  promptPending: () => post.write(PS2),\n\t};\n\tconst setUpConsole = (globals?: PyProxyDict) => {\n\t  pyconsole?.destroy();\n\t  pyconsole = create_console(globals);\n\t};\n\tconst setUpREPLEnvironment = () => {\n\t  const globals = pyodide.globals.get('dict')();\n\t  pyodide.runPython(consoleScript, { globals });\n\t  repr_shorten = globals.get('repr_shorten');\n", "  await_fut = globals.get('await_fut');\n\t  create_console = globals.get('create_console');\n\t  clear_console = globals.get('clear_console');\n\t  setUpConsole();\n\t  return globals.get('BANNER') as string;\n\t};\n\tconst preparePyodide = async () => {\n\t  const newPyodide = await loadPyodide();\n\t  newPyodide.setStdout({ batched: post.writeln });\n\t  newPyodide.setStderr({ batched: post.error });\n", "  pyodide = newPyodide;\n\t  if (interruptBuffer) pyodide.setInterruptBuffer(interruptBuffer);\n\t  /**\n\t   * Replaces Pyodide's `js` import with a stub `object`. This must also be\n\t   * paired with some `del sys.modules['js']` in Pyodide's initialisation.\n\t   */\n\t  pyodide.registerJsModule('js', {});\n\t  const banner = setUpREPLEnvironment();\n\t  post.writeln(banner);\n\t  post.prompt(false);\n", "  post.unlock();\n\t  return newPyodide;\n\t};\n\tconst prepareExports = (exports?: { name: string; content: string }[]) => {\n\t  let newExports = new Set<string>();\n\t  exports?.forEach(({ name, content }) => {\n\t    pyodide.FS.writeFile(name, content, { encoding: 'utf-8' });\n\t    newExports.add(name);\n\t  });\n\t  const oldExports = pyodide.FS.readdir('.') as string[];\n", "  oldExports.forEach((name) => {\n\t    if (name === '.' || name === '..' || newExports.has(name)) return;\n\t    pyodide.FS.unlink(name);\n\t  });\n\t};\n\t/**\n\t * Pyodide may sometimes not catch `RecursionError`s and excessively\n\t * recursive code spills as JavaScript `RangeError`, causing Pyodide to\n\t * fatally crash. We need to restart Pyodide in this case.\n\t * @see https://github.com/pyodide/pyodide/issues/951\n", " */\n\tconst handleRangeErrorAndRestartPyodide = async (error: unknown) => {\n\t  if (!(error instanceof RangeError)) return;\n\t  post.system(\n\t    '\\nOops, something happened and we have to restart the interpreter. ' +\n\t      \"Don't worry, it's not your fault. \" +\n\t      'You may continue once you see the prompt again.\\n',\n\t  );\n\t  await preparePyodide();\n\t};\n", "const listeners = {\n\t  initialize: async (newInterruptBuffer?: Uint8Array) => {\n\t    pyodide ??= await preparePyodide();\n\t    if (!newInterruptBuffer) return;\n\t    pyodide.setInterruptBuffer(newInterruptBuffer);\n\t    interruptBuffer = newInterruptBuffer;\n\t  },\n\t  run: async ({ code, exports }: RunExportableData) => {\n\t    pyodide ??= await preparePyodide();\n\t    post.writeln(RUN_CODE);\n", "    try {\n\t      post.lock();\n\t      prepareExports(exports);\n\t      await pyodide.loadPackagesFromImports(code);\n\t      const globals = pyodide.globals.get('dict')();\n\t      /**\n\t       * `await pyodide.runPythonAsync(code)` is not used because it raises\n\t       * an uncatchable `PythonError` when Pyodide emits a `KeyboardInterrupt`.\n\t       * @see https://github.com/pyodide/pyodide/issues/2141\n\t       */\n", "      const result = pyodide.runPython(code, { globals });\n\t      setUpConsole(globals);\n\t      post.writeln(result?.toString());\n\t    } catch (error) {\n\t      if (!(error instanceof Error)) throw error;\n\t      post.error(error.message);\n\t      handleRangeErrorAndRestartPyodide(error);\n\t    } finally {\n\t      post.prompt();\n\t      post.unlock();\n", "    }\n\t  },\n\t  replClear: async () => {\n\t    try {\n\t      clear_console(pyconsole);\n\t      await await_fut(pyconsole.push(''));\n\t    } finally {\n\t      post.error('\\nKeyboardInterrupt');\n\t      post.prompt();\n\t    }\n", "  },\n\t  replInput: async ({ code, exports }: RunExportableData) => {\n\t    post.writeln(code);\n\t    const future = pyconsole.push(code) as PyProxy;\n\t    const status = future.syntax_check as SyntaxCheck;\n\t    switch (status) {\n\t      case 'syntax-error':\n\t        post.error(future.formatted_error.trimEnd());\n\t        post.prompt();\n\t        return;\n", "      case 'incomplete':\n\t        post.promptPending();\n\t        return;\n\t      case 'complete':\n\t        break;\n\t      default:\n\t        throw new Error(`Unexpected type: ${status}`);\n\t    }\n\t    prepareExports(exports);\n\t    const wrapped = await_fut(future) as PyProxyAwaitable;\n", "    try {\n\t      const [value] = await wrapped;\n\t      if (value !== undefined) {\n\t        const repr = repr_shorten.callKwargs(value, {\n\t          separator: '\\n<long output truncated>\\n',\n\t        }) as string;\n\t        post.writeln(repr);\n\t      }\n\t      if (pyodide.isPyProxy(value)) value.destroy();\n\t    } catch (error) {\n", "      if (!(error instanceof Error)) throw error;\n\t      const message = future.formatted_error || error.message;\n\t      post.error(message.trimEnd());\n\t      handleRangeErrorAndRestartPyodide(error);\n\t    } finally {\n\t      post.prompt();\n\t      future.destroy();\n\t      wrapped.destroy();\n\t    }\n\t  },\n", "};\n\tonmessage = async (event: MessageEvent<Message<typeof listeners>>) => {\n\t  listeners[event.data.type]?.(event.data.payload);\n\t};\n"]}
