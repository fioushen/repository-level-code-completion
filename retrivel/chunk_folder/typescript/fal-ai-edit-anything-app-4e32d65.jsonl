{"filename": "src/util.ts", "chunked_list": ["import * as fs from \"fs\";\n\timport fetch from \"node-fetch\";\n\texport function base64ToFile(dataurl: string, filename: string) {\n\t  // Extract the base64 data portion\n\t  let base64Data = dataurl.split(\",\")[1];\n\t  // Write the base64 string to a file\n\t  fs.writeFileSync(filename, base64Data, { encoding: \"base64\" });\n\t}\n\tasync function convertImageUrlToBuffer(\n\t  imageUrl: string\n", "): Promise<Buffer | null> {\n\t  try {\n\t    const response = await fetch(imageUrl);\n\t    if (!response.ok) {\n\t      throw new Error(\"Failed to download the image\");\n\t    }\n\t    return await response.buffer();\n\t  } catch (error) {\n\t    console.error(\"Failed to convert image URL to file:\", error);\n\t    return null;\n", "  }\n\t}\n"]}
{"filename": "src/pages/api/images.ts", "chunked_list": ["import { getImageCount } from \"@/data/storage\";\n\timport type { NextApiHandler } from \"next\";\n\tconst handler: NextApiHandler = async (request, response) => {\n\t  const numberOfImages = await getImageCount();\n\t  return response.json({ numberOfImages });\n\t};\n\texport default handler;\n"]}
{"filename": "src/pages/api/edit.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\n\timport FormData from \"form-data\";\n\timport type { NextApiHandler } from \"next\";\n\timport fetch from \"node-fetch\";\n\timport { v4 as uuidv4 } from \"uuid\";\n\tconst EDIT_FUNCTION_URL = process.env.NEXT_PUBLIC_EDIT_FUNCTION_URL;\n\tconst falToken = process.env.FAL_TOKEN;\n\tconst handler: NextApiHandler = async (request, response) => {\n\t  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n\t    response.status(405).json({ message: \"Method not allowed\" });\n", "    return;\n\t  }\n\t  if (!EDIT_FUNCTION_URL) {\n\t    response.status(500).json({ message: \"EDIT_FUNCTION_URL not set\" });\n\t    return;\n\t  }\n\t  const uuid = uuidv4();\n\t  const maskFileBuffer = await convertImageUrlToBuffer(request.body.mask_url);\n\t  let base64ImageWithoutPrefix = request.body.image_url.data\n\t    .split(\";base64,\")\n", "    .pop();\n\t  const formData = new FormData();\n\t  formData.append(\n\t    \"image_file\",\n\t    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n\t    \"image_file.png\"\n\t  );\n\t  formData.append(\"mask_file\", maskFileBuffer, \"mask_file.png\");\n\t  formData.append(\"fal_token\", falToken);\n\t  formData.append(\"prompt\", request.body.prompt);\n", "  const res = await fetch(EDIT_FUNCTION_URL, {\n\t    method: \"POST\",\n\t    body: formData,\n\t  });\n\t  if (!res.ok) {\n\t    response.status(res.status).send(res.statusText);\n\t    return;\n\t  }\n\t  await incrementImageCount();\n\t  response.json(await res.json());\n", "};\n\tasync function convertImageUrlToBuffer(\n\t  imageUrl: string\n\t): Promise<Buffer | null> {\n\t  try {\n\t    const response = await fetch(imageUrl);\n\t    if (!response.ok) {\n\t      throw new Error(\"Failed to download the image\");\n\t    }\n\t    return await response.buffer();\n", "  } catch (error) {\n\t    console.error(\"Failed to convert image URL to file:\", error);\n\t    return null;\n\t  }\n\t}\n\texport default handler;\n"]}
{"filename": "src/pages/api/controlnet.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\n\timport fetch from \"node-fetch\";\n\timport FormData from \"form-data\";\n\timport type { NextApiHandler } from \"next\";\n\timport { v4 as uuidv4 } from \"uuid\";\n\tconst CONTROLNET_URL = process.env.NEXT_PUBLIC_CONTROLNET_URL;\n\tconst falToken = process.env.FAL_TOKEN;\n\tconst handler: NextApiHandler = async (request, response) => {\n\t  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n\t    response.status(405).json({ message: \"Method not allowed\" });\n", "    return;\n\t  }\n\t  if (!CONTROLNET_URL) {\n\t    response.status(500).json({ message: \"CONTROLNET_URL not set\" });\n\t    return;\n\t  }\n\t  // save file\n\t  const uuid = uuidv4();\n\t  let base64ImageWithoutPrefix = request.body.base64Image\n\t    .split(\";base64,\")\n", "    .pop();\n\t  let formData = new FormData();\n\t  formData.append(\n\t    \"file\",\n\t    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n\t    `base_${uuid}.png`\n\t  );\n\t  // TODO: these need to change\n\t  formData.append(\"fal_token\", falToken);\n\t  formData.append(\"num_samples\", \"1\");\n", "  formData.append(\"prompt\", request.body.prompt);\n\t  const res = await fetch(CONTROLNET_URL, {\n\t    method: \"POST\",\n\t    body: formData,\n\t  });\n\t  if (!res.ok) {\n\t    console.log(res.status);\n\t    response.status(res.status).send(res.statusText);\n\t    return;\n\t  }\n", "  await incrementImageCount();\n\t  const data: any = await res.json();\n\t  response.json({ imageUrl: data[0] });\n\t};\n\texport default handler;\n"]}
{"filename": "src/pages/api/remove.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\n\timport FormData from \"form-data\";\n\timport type { NextApiHandler } from \"next\";\n\timport fetch from \"node-fetch\";\n\tconst REMOVE_FUNCTION_URL = process.env.NEXT_PUBLIC_REMOVE_FUNCTION_URL;\n\tconst falToken = process.env.FAL_TOKEN;\n\tconst handler: NextApiHandler = async (request, response) => {\n\t  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n\t    response.status(405).json({ message: \"Method not allowed\" });\n\t    return;\n", "  }\n\t  if (!REMOVE_FUNCTION_URL) {\n\t    response.status(500).json({ message: \"REMOVE_FUNCTION_URL not set\" });\n\t    return;\n\t  }\n\t  const maskFileBuffer = convertImageUrlToBuffer(request.body.mask_url);\n\t  let base64ImageWithoutPrefix = request.body.image_url.data\n\t    .split(\";base64,\")\n\t    .pop();\n\t  const formData = new FormData();\n", "  formData.append(\n\t    \"image_file\",\n\t    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n\t    \"image_file.png\"\n\t  );\n\t  formData.append(\"mask_file\", maskFileBuffer, \"mask_file.png\");\n\t  formData.append(\"fal_token\", falToken);\n\t  formData.append(\"prompt\", request.body.prompt);\n\t  const res = await fetch(REMOVE_FUNCTION_URL, {\n\t    method: \"POST\",\n", "    body: formData,\n\t  });\n\t  if (!res.ok) {\n\t    response.status(res.status).send(res.statusText);\n\t    return;\n\t  }\n\t  await incrementImageCount();\n\t  response.json(await res.json());\n\t};\n\texport default handler;\n", "function convertImageUrlToBuffer(mask_url: any) {\n\t  throw new Error(\"Function not implemented.\");\n\t}\n"]}
{"filename": "src/pages/api/masks.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\n\timport FormData from \"form-data\";\n\timport type { NextApiHandler, PageConfig } from \"next\";\n\timport fetch from \"node-fetch\";\n\tconst falToken = process.env.FAL_TOKEN;\n\tconst MASK_FUNCTION_URL = process.env.NEXT_PUBLIC_MASK_FUNCTION_URL;\n\tconst handler: NextApiHandler = async (request, response) => {\n\t  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n\t    response.status(405).json({ message: \"Method not allowed\" });\n\t    return;\n", "  }\n\t  if (!MASK_FUNCTION_URL) {\n\t    response.status(500).json({ message: \"MASK_FUNCTION_URL not set\" });\n\t    return;\n\t  }\n\t  let base64ImageWithoutPrefix = request.body.image.split(\";base64,\").pop();\n\t  const formData = new FormData();\n\t  formData.append(\n\t    \"file\",\n\t    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n", "    \"base.png\"\n\t  );\n\t  formData.append(\"fal_token\", falToken);\n\t  formData.append(\"x\", request.body.x);\n\t  formData.append(\"y\", request.body.y);\n\t  formData.append(\"extension\", request.body.extension);\n\t  formData.append(\"dilation\", request.body.dilation);\n\t  const res = await fetch(MASK_FUNCTION_URL, {\n\t    method: \"POST\",\n\t    body: formData,\n", "  });\n\t  if (!res.ok) {\n\t    response.status(res.status).send(res.statusText);\n\t    return;\n\t  }\n\t  await incrementImageCount({ by: 3 });\n\t  const imagesList: string[] = (await res.json()) as string[];\n\t  // masks are returned as the 3rd, 6th, and 9th images\n\t  const images = {\n\t    displayMasks: [imagesList[2], imagesList[5], imagesList[8]],\n", "    masks: [imagesList[0], imagesList[3], imagesList[6]],\n\t  };\n\t  response.json(images);\n\t};\n\texport const config: PageConfig = {\n\t  api: {\n\t    bodyParser: {\n\t      sizeLimit: \"10mb\",\n\t    },\n\t  },\n", "};\n\texport default handler;\n"]}
{"filename": "src/pages/api/fill.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\n\timport FormData from \"form-data\";\n\timport type { NextApiHandler } from \"next\";\n\timport fetch from \"node-fetch\";\n\tconst FILL_FUNCTION_URL = process.env.NEXT_PUBLIC_FILL_FUNCTION_URL;\n\tconst falToken = process.env.FAL_TOKEN;\n\tconst handler: NextApiHandler = async (request, response) => {\n\t  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n\t    response.status(405).json({ message: \"Method not allowed\" });\n\t    return;\n", "  }\n\t  if (!FILL_FUNCTION_URL) {\n\t    response.status(500).json({ message: \"FILL_FUNCTION_URL not set\" });\n\t    return;\n\t  }\n\t  const maskFileBuffer = convertImageUrlToBuffer(request.body.mask_url);\n\t  let base64ImageWithoutPrefix = request.body.image_url.data\n\t    .split(\";base64,\")\n\t    .pop();\n\t  const formData = new FormData();\n", "  formData.append(\n\t    \"image_file\",\n\t    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n\t    \"image_file.png\"\n\t  );\n\t  formData.append(\"mask_file\", maskFileBuffer, \"mask_file.png\");\n\t  formData.append(\"fal_token\", falToken);\n\t  formData.append(\"prompt\", request.body.prompt);\n\t  const res = await fetch(FILL_FUNCTION_URL, {\n\t    method: \"POST\",\n", "    body: formData,\n\t  });\n\t  if (!res.ok) {\n\t    response.status(res.status).send(res.statusText);\n\t    return;\n\t  }\n\t  await incrementImageCount();\n\t  response.json(await res.json());\n\t};\n\texport default handler;\n", "function convertImageUrlToBuffer(mask_url: any) {\n\t  throw new Error(\"Function not implemented.\");\n\t}\n"]}
{"filename": "src/pages/api/rembg.ts", "chunked_list": ["import { incrementImageCount } from \"@/data/storage\";\n\timport axios from \"axios\";\n\timport FormData from \"form-data\";\n\timport type { NextApiHandler } from \"next\";\n\tconst REMBG_URL = process.env.NEXT_PUBLIC_REMBG_URL;\n\tconst falToken = process.env.FAL_TOKEN;\n\tconst handler: NextApiHandler = async (request, response) => {\n\t  if (request.method !== \"POST\" && request.method !== \"OPTIONS\") {\n\t    response.status(405).json({ message: \"Method not allowed\" });\n\t    return;\n", "  }\n\t  if (!REMBG_URL) {\n\t    response.status(500).json({ message: \"REMBG_URL not set\" });\n\t    return;\n\t  }\n\t  // save file\n\t  let base64ImageWithoutPrefix = request.body.base64Image\n\t    .split(\";base64,\")\n\t    .pop();\n\t  let formData = new FormData();\n", "  formData.append(\n\t    \"file\",\n\t    Buffer.from(base64ImageWithoutPrefix, \"base64\"),\n\t    \"anything.png\"\n\t  );\n\t  formData.append(\"fal_token\", falToken);\n\t  axios\n\t    .post(`${REMBG_URL}/remove`, formData)\n\t    .then(async (res) => {\n\t      if (res.status == 200) {\n", "        await incrementImageCount({ by: 1 });\n\t        const result = await res.data;\n\t        response.status(res.status).send({ imageUrl: res.data });\n\t      }\n\t    })\n\t    .catch((error) => console.error(error));\n\t};\n\texport default handler;\n"]}
{"filename": "src/data/image.ts", "chunked_list": ["export interface ImageFile {\n\t  filename: string;\n\t  data: string;\n\t  size: {\n\t    width: number;\n\t    height: number;\n\t  };\n\t}\n"]}
{"filename": "src/data/storage.ts", "chunked_list": ["import kv from \"@vercel/kv\";\n\tconst NUMBER_OF_IMAGES_KEY = \"numberOfImages\";\n\texport function isAvailable(): boolean {\n\t  return process.env.KV_REST_API_URL !== undefined;\n\t}\n\ttype IncrementArgs = {\n\t  by: number;\n\t};\n\texport function incrementImageCount(\n\t  { by }: IncrementArgs = { by: 1 }\n", "): Promise<number> {\n\t  if (!isAvailable()) {\n\t    console.warn(\"KV storage is disabled.\");\n\t    return Promise.resolve(0);\n\t  }\n\t  if (by < 1) {\n\t    throw new Error(\"Increment cannot be less than 1\");\n\t  }\n\t  return kv.incrby(NUMBER_OF_IMAGES_KEY, by);\n\t}\n", "export function getImageCount(): Promise<number | null> {\n\t  if (!isAvailable()) {\n\t    console.warn(\"KV storage is disabled.\");\n\t    return Promise.resolve(null);\n\t  }\n\t  return kv.get(NUMBER_OF_IMAGES_KEY);\n\t}\n"]}
{"filename": "src/data/modelMetadata.ts", "chunked_list": ["export type Model = {\n\t  id: string;\n\t  name: string;\n\t  apiEndpoint: string;\n\t  pythonCode: string;\n\t  jsCode: string;\n\t  curlCode: string;\n\t};\n\tconst regmbModel: Model = {\n\t  id: \"rembg\",\n", "  name: \"Rembg\",\n\t  apiEndpoint: process.env.NEXT_PUBLIC_REMBG_URL || \"\",\n\t  pythonCode: `\n\timport requests\n\trembg_base_url = \"${process.env.NEXT_PUBLIC_REMBG_URL}\"\n\tfal_token = \"<YOUR_TOKEN_HERE>\"\n\trembg_response = requests.post(\n\t    f\"{rembg_base_url}/remove\",\n\t    files={\"file\": open(\"image.png\", \"rb\")},\n\t    data={\"fal_token\": fal_token},\n", ")\n\t    `,\n\t  jsCode: \"\",\n\t  curlCode: \"\",\n\t};\n\tconst segmentAnything: Model = {\n\t  id: \"sam\",\n\t  name: \"Segment Anything\",\n\t  apiEndpoint: process.env.NEXT_PUBLIC_MASK_FUNCTION_URL || \"\",\n\t  pythonCode: `\n", "import requests\n\tsam_base_url = \"${process.env.NEXT_PUBLIC_MASK_FUNCTION_URL}\"\n\tfal_token = \"<YOUR_TOKEN_HERE>\"\n\tsam_response = requests.post(\n\t    f\"{sam_base_url}/masks\",\n\t    files={\"file\": open(\"image.png\", \"rb\")},\n\t    data={\"fal_token\": fal_token},\n\t)\n\t`,\n\t  jsCode: \"\",\n", "  curlCode: \"\",\n\t};\n\tconst controlnet: Model = {\n\t  id: \"controlnet\",\n\t  name: \"lllyasviel/sd-controlnet-scribble\",\n\t  apiEndpoint: process.env.NEXT_PUBLIC_CONTROLNET_SCRIBBLE_URL || \"\",\n\t  pythonCode: `\n\timport requests\n\turl = \"${process.env.NEXT_PUBLIC_CONTROLNET_SCRIBBLE_URL}\"\n\tresponse = requests.post(\n", "    f\"{url}/generate\",\n\t    files={\"file\": open(\"turtle.png\", \"rb\")},\n\t    data={\n\t        \"prompt\": \"turle on the sky\",\n\t        \"num_samples\": 1,\n\t        \"fal_token\": \"fal_token\",\n\t    },\n\t)\n\t`,\n\t  jsCode: \"\",\n", "  curlCode: \"\",\n\t};\n\ttype ModelRegistry = {\n\t  [key: string]: Model;\n\t};\n\texport const models: ModelRegistry = {\n\t  rembg: regmbModel,\n\t  sam: segmentAnything,\n\t  controlnet: controlnet,\n\t};\n"]}
