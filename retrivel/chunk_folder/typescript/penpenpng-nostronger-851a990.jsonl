{"filename": "vite.config.ts", "chunked_list": ["import { defineConfig } from 'vite';\n\timport { crx } from '@crxjs/vite-plugin';\n\timport { svelte } from '@sveltejs/vite-plugin-svelte';\n\timport path from 'path';\n\timport sveltePreprocess from 'svelte-preprocess';\n\timport manifest from './src/manifest';\n\texport default defineConfig(({ mode }) => {\n\t  const production = mode === 'production';\n\t  return {\n\t    build: {\n", "      emptyOutDir: true,\n\t      outDir: 'build',\n\t      rollupOptions: {\n\t        input: {\n\t          charge: 'charge.html',\n\t        },\n\t        output: {\n\t          chunkFileNames: 'assets/chunk-[hash].js',\n\t        },\n\t      },\n", "    },\n\t    plugins: [\n\t      crx({ manifest }),\n\t      svelte({\n\t        compilerOptions: {\n\t          dev: !production,\n\t        },\n\t        preprocess: sveltePreprocess(),\n\t      }),\n\t    ],\n", "    resolve: {\n\t      alias: {\n\t        '@': path.resolve(__dirname, 'src'),\n\t      },\n\t    },\n\t  };\n\t});\n"]}
{"filename": "src/global.d.ts", "chunked_list": ["/// <reference types=\"svelte\" />\n\t/// <reference types=\"vite/client\" />\n\tdeclare const __APP_VERSION__: string;\n"]}
{"filename": "src/manifest.ts", "chunked_list": ["import { defineManifest } from '@crxjs/vite-plugin';\n\texport default defineManifest({\n\t  name: 'create-chrome-ext',\n\t  description: '',\n\t  version: '0.0.0',\n\t  manifest_version: 3,\n\t  icons: {\n\t    '16': 'img/logo-16.png',\n\t    '32': 'img/logo-34.png',\n\t    '48': 'img/logo-48.png',\n", "    '128': 'img/logo-128.png',\n\t  },\n\t  action: {\n\t    default_popup: 'popup.html',\n\t    default_icon: 'img/logo-48.png',\n\t  },\n\t  options_page: 'options.html',\n\t  background: {\n\t    service_worker: 'src/background/index.ts',\n\t    type: 'module',\n", "  },\n\t  content_scripts: [\n\t    {\n\t      matches: ['http://*/*', 'https://*/*'],\n\t      js: ['src/content/index.ts'],\n\t    },\n\t  ],\n\t  web_accessible_resources: [\n\t    {\n\t      resources: ['img/logo-16.png', 'img/logo-34.png', 'img/logo-48.png', 'img/logo-128.png'],\n", "      matches: [],\n\t    },\n\t    {\n\t      resources: ['js/nip07-provider.js'],\n\t      matches: ['https://*/*', 'http://localhost:*/*'],\n\t    },\n\t  ],\n\t  permissions: ['storage', 'tabs', 'activeTab'],\n\t});\n"]}
{"filename": "src/pages/options/index.ts", "chunked_list": ["import App from './Options.svelte';\n\timport '../../lib/svelte-material-ui';\n\tconst app = new (App as any)({\n\t  target: document.getElementById('app')!,\n\t});\n\texport default app;\n"]}
{"filename": "src/pages/popup/index.ts", "chunked_list": ["import App from './Popup.svelte';\n\timport '../../lib/svelte-material-ui';\n\tconst app = new (App as any)({\n\t  target: document.getElementById('app')!,\n\t});\n\texport default app;\n"]}
{"filename": "src/pages/charge/index.ts", "chunked_list": ["import App from './Charge.svelte';\n\timport '../../lib/svelte-material-ui';\n\tconst app = new (App as any)({\n\t  target: document.getElementById('app')!,\n\t});\n\texport default app;\n"]}
{"filename": "src/lib/nostr.ts", "chunked_list": ["import * as secp256k1 from '@noble/secp256k1';\n\timport { sha256 } from '@noble/hashes/sha256';\n\timport { bech32 } from 'bech32';\n\tconst utf8Encoder = new TextEncoder();\n\tsecp256k1.utils.sha256Sync = (...msgs) => sha256(secp256k1.utils.concatBytes(...msgs));\n\texport async function calcPubkey(seckey: string): Promise<string> {\n\t  return secp256k1.utils.bytesToHex(secp256k1.schnorr.getPublicKey(seckey));\n\t}\n\texport async function signEvent(\n\t  { seckey, pubkey }: KeyPair,\n", "  unsignedEvent: UnsignedEvent,\n\t): Promise<SignedEvent> {\n\t  const { created_at, kind, tags, content } = unsignedEvent;\n\t  const id = secp256k1.utils.bytesToHex(\n\t    sha256(utf8Encoder.encode(JSON.stringify([0, pubkey, created_at, kind, tags, content]))),\n\t  );\n\t  const sig = secp256k1.utils.bytesToHex(secp256k1.schnorr.signSync(id, seckey));\n\t  return {\n\t    id,\n\t    pubkey,\n", "    sig,\n\t    ...unsignedEvent,\n\t  };\n\t}\n\texport function bech32encode(str: string) {\n\t  return hexEncode(fromWords(bech32.decode(str).words));\n\t}\n\tfunction hexEncode(buf: number[]) {\n\t  let str = '';\n\t  for (let i = 0; i < buf.length; i++) {\n", "    const c = buf[i];\n\t    str += hexChar(c >> 4);\n\t    str += hexChar(c & 0xf);\n\t  }\n\t  return str;\n\t}\n\tfunction hexChar(val: number) {\n\t  if (val < 10) return String.fromCharCode(48 + val);\n\t  else return String.fromCharCode(97 + val - 10);\n\t}\n", "function fromWords(words: number[]) {\n\t  const res = convertbits(words, 5, 8, false);\n\t  if (Array.isArray(res)) return res;\n\t  throw new Error(res);\n\t}\n\tfunction convertbits(data: number[], inBits: number, outBits: number, pad: boolean) {\n\t  let value = 0;\n\t  let bits = 0;\n\t  const maxV = (1 << outBits) - 1;\n\t  const result = [];\n", "  for (let i = 0; i < data.length; ++i) {\n\t    value = (value << inBits) | data[i];\n\t    bits += inBits;\n\t    while (bits >= outBits) {\n\t      bits -= outBits;\n\t      result.push((value >> bits) & maxV);\n\t    }\n\t  }\n\t  if (pad) {\n\t    if (bits > 0) {\n", "      result.push((value << (outBits - bits)) & maxV);\n\t    }\n\t  } else {\n\t    if (bits >= inBits) return 'Excess padding';\n\t    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding';\n\t  }\n\t  return result;\n\t}\n\texport function isValidHex(hex: string): boolean {\n\t  return /^[a-f0-9]{64}$/.test(hex);\n", "}\n"]}
{"filename": "src/lib/messaging.ts", "chunked_list": ["export const ext: ExtName = 'nostronger';\n\texport function generateMessageId() {\n\t  return Math.floor(Math.random() * 1000000);\n\t}\n\texport function wait<E, T>(\n\t  createListener: (resolve: (val: T) => void) => (event: E) => void,\n\t  params: {\n\t    addEventListener: (listener: (event: E) => void) => void;\n\t    removeEventListener: (listener: (event: E) => void) => void;\n\t    prepare?: () => void;\n", "    timeout?: number;\n\t  },\n\t) {\n\t  return new Promise<T>((resolve, reject) => {\n\t    const timeoutId = params.timeout\n\t      ? setTimeout(() => {\n\t          params.removeEventListener(listener);\n\t          reject('timed out');\n\t        })\n\t      : -1;\n", "    const listener = createListener((val) => {\n\t      clearTimeout(timeoutId);\n\t      params.removeEventListener(listener);\n\t      resolve(val);\n\t    });\n\t    params.addEventListener(listener);\n\t    params.prepare?.();\n\t  });\n\t}\n\texport function handleCrxRpcRequest(\n", "  msg: CrxRpcRequestMessage,\n\t  origin: CrxMessageOrigin,\n\t): { next?: CrxMessageOrigin; shouldBeHandled: boolean } {\n\t  if (msg.ext !== 'nostronger' || !('request' in msg.payload) || msg.path[0] !== origin) {\n\t    return {\n\t      shouldBeHandled: false,\n\t    };\n\t  }\n\t  msg.path.shift();\n\t  const next = msg.path[0];\n", "  return {\n\t    next,\n\t    shouldBeHandled: true,\n\t  };\n\t}\n"]}
{"filename": "src/lib/svelte-material-ui.ts", "chunked_list": ["import 'svelte-material-ui/bare.css';\n\timport 'svelte-material-ui/themes/svelte.css';\n\timport 'material-icons/iconfont/material-icons.css';\n"]}
{"filename": "src/lib/store.ts", "chunked_list": ["import { calcPubkey } from '../lib/nostr';\n\tconst LOCAL_STORAGE_KEY = {\n\t  KEY_PAIR: 'KEY_PAIR',\n\t  SIGN_POWER: 'SIGN_POWER',\n\t} as const;\n\tasync function get(key: string): Promise<any> {\n\t  const { [key]: val } = await chrome.storage.local.get(key);\n\t  return val;\n\t}\n\tasync function set(key: string, val: any): Promise<void> {\n", "  await chrome.storage.local.set({ [key]: val });\n\t}\n\texport async function getKeyPair(): Promise<KeyPair> {\n\t  const { seckey, pubkey } = await get(LOCAL_STORAGE_KEY.KEY_PAIR);\n\t  return { seckey, pubkey };\n\t}\n\texport async function setKeyPair(seckey: string) {\n\t  const pubkey = await calcPubkey(seckey);\n\t  await set(LOCAL_STORAGE_KEY.KEY_PAIR, { seckey, pubkey });\n\t}\n", "export async function getSignPower(): Promise<number> {\n\t  const signPower = (await get(LOCAL_STORAGE_KEY.SIGN_POWER)) ?? 0;\n\t  return Number(signPower) || 0;\n\t}\n\texport async function setSignPower(signPower: number) {\n\t  await set(LOCAL_STORAGE_KEY.SIGN_POWER, signPower);\n\t}\n"]}
{"filename": "src/lib/ring-con.ts", "chunked_list": ["import { wait } from './messaging';\n\texport async function getJoyconDevice() {\n\t  const [device] = await navigator.hid.requestDevice({\n\t    filters: [\n\t      {\n\t        vendorId: 0x057e, // Nintendo vendor ID\n\t        productId: 0x2007, // joy-con R\n\t      },\n\t    ],\n\t  });\n", "  if (!device) {\n\t    throw new Error('device not found.');\n\t  }\n\t  if (!device.opened) {\n\t    await device.open();\n\t  }\n\t  await setupJoycon(device);\n\t  return device;\n\t}\n\texport async function setupJoycon(joycon: HIDDevice) {\n", "  // set_input_report_mode_to_0x30\n\t  await communicate(joycon, [0x03, 0x30], [[14, 0x03]]);\n\t  // enabling_MCU_data_22_1\n\t  await communicate(\n\t    joycon,\n\t    [0x22, 0x01],\n\t    [\n\t      [13, 0x80],\n\t      [14, 0x22],\n\t    ],\n", "  );\n\t  // enabling_MCU_data_21_21_1_1\n\t  await communicate(\n\t    joycon,\n\t    [\n\t      0x21, 0x21, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3,\n\t    ],\n\t    [[14, 0x21]],\n", "  );\n\t  // get_ext_data_59\n\t  await communicate(\n\t    joycon,\n\t    [0x59],\n\t    [\n\t      [14, 0x59],\n\t      [16, 0x20],\n\t    ],\n\t  );\n", "  // get_ext_dev_in_format_config_5C\n\t  await communicate(\n\t    joycon,\n\t    [\n\t      0x5c, 0x06, 0x03, 0x25, 0x06, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x16, 0xed, 0x34, 0x36, 0x00,\n\t      0x00, 0x00, 0x0a, 0x64, 0x0b, 0xe6, 0xa9, 0x22, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,\n\t      0x00, 0x00, 0x00, 0x90, 0xa8, 0xe1, 0x34, 0x36,\n\t    ],\n\t    [[14, 0x5c]],\n\t  );\n", "  // start_external_polling_5A\n\t  await communicate(joycon, [0x5a, 0x04, 0x01, 0x01, 0x02], [[14, 0x5a]]);\n\t  // blink LED\n\t  await communicate(joycon, [0x30, 0x90], [[14, 0x30]]);\n\t}\n\tasync function communicate(device: HIDDevice, subcommand: number[], expected: [number, number][]) {\n\t  await wait<HIDInputReportEvent, void>(\n\t    (resolve) => (event) => {\n\t      if (event.reportId !== 0x21) {\n\t        return;\n", "      }\n\t      const data = new Uint8Array(event.data.buffer);\n\t      if (expected.every(([pos, val]) => data[pos - 1] === val)) {\n\t        resolve();\n\t      }\n\t    },\n\t    {\n\t      addEventListener: (listener) => device.addEventListener('inputreport', listener),\n\t      removeEventListener: (listener) => device.removeEventListener('inputreport', listener),\n\t      prepare: () => {\n", "        device.sendReport(\n\t          0x01,\n\t          new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ...subcommand]),\n\t        );\n\t      },\n\t      // timeout: 5000,\n\t    },\n\t  );\n\t}\n\texport async function getNextStrain(joycon: HIDDevice) {\n", "  return wait<HIDInputReportEvent, number>(\n\t    (resolve) => (event) => {\n\t      const strain = getStrain(event);\n\t      if (strain) {\n\t        resolve(strain);\n\t      }\n\t    },\n\t    {\n\t      addEventListener: (listener) => joycon.addEventListener('inputreport', listener),\n\t      removeEventListener: (listener) => joycon.removeEventListener('inputreport', listener),\n", "      // timeout: 5000,\n\t    },\n\t  );\n\t}\n\texport function getStrain(event: HIDInputReportEvent) {\n\t  if (event.reportId === 0x30) {\n\t    return new DataView(event.data.buffer, 38, 2).getInt16(0, true);\n\t  } else {\n\t    return null;\n\t  }\n", "}\n"]}
{"filename": "src/background/index.ts", "chunked_list": ["import { handleCrxRpcRequest } from '../lib/messaging';\n\timport { signEvent } from '../lib/nostr';\n\timport { getKeyPair, getSignPower, setSignPower } from '../lib/store';\n\t// * -> ...\n\tchrome.runtime.onMessage.addListener((msg: CrxRpcRequestMessage, sender, _sendResponse) => {\n\t  const { next, shouldBeHandled } = handleCrxRpcRequest(msg, 'background');\n\t  if (!shouldBeHandled) {\n\t    return;\n\t  }\n\t  const payload = msg.payload;\n", "  if (next === 'content' && payload.kind === 'leaveChargeMode') {\n\t    chrome.tabs.sendMessage(payload.request.senderTabId, msg);\n\t    return;\n\t  } else if (!!next) {\n\t    console.warn('Unexpected message', msg);\n\t    return;\n\t  }\n\t  const sendResponse = (val: any) => {\n\t    const res: CrxRpcResponseMessage = {\n\t      ...msg,\n", "      payload: {\n\t        kind: payload.kind,\n\t        response: val,\n\t      },\n\t    };\n\t    _sendResponse(res);\n\t  };\n\t  // ... -> HERE\n\t  switch (payload.kind) {\n\t    case 'getPubkey':\n", "      getKeyPair().then(({ pubkey }) => {\n\t        sendResponse(pubkey);\n\t      });\n\t      return true; // For async response\n\t    case 'signEvent':\n\t      getKeyPair().then(async (keypair) => {\n\t        const signed = await signEvent(keypair, payload.request);\n\t        sendResponse(signed);\n\t      });\n\t      return true;\n", "    case 'getSignPower':\n\t      getSignPower().then((power) => {\n\t        sendResponse(power);\n\t      });\n\t      return true;\n\t    case 'setSignPower':\n\t      setSignPower(payload.request.value).then(() => {\n\t        sendResponse(void 0);\n\t      });\n\t      return true;\n", "    case 'openChargeWindow':\n\t      chrome.windows\n\t        .create({\n\t          url: chrome.runtime.getURL('charge.html'),\n\t          type: 'popup',\n\t        })\n\t        .then((res) => {\n\t          const tabId = res.tabs?.[0].id;\n\t          sendResponse(tabId);\n\t        });\n", "      return true;\n\t    default:\n\t      break;\n\t  }\n\t});\n"]}
{"filename": "src/@types/common/index.d.ts", "chunked_list": ["// crx-rpc ------------------------------------------------\n\ttype ExtName = 'nostronger';\n\ttype CrxRpcMessage = CrxRpcRequestMessage | CrxRpcResponseMessage;\n\tinterface CrxRpcRequestMessage extends _CrxRpcMessageBase {\n\t  src: CrxMessageOrigin;\n\t  path: CrxMessageOrigin[];\n\t  payload: CrxRpcRequestPayload;\n\t}\n\tinterface CrxRpcResponseMessage extends _CrxRpcMessageBase {\n\t  payload: CrxRpcResponsePayload;\n", "}\n\tinterface _CrxRpcMessageBase {\n\t  ext: ExtName;\n\t  messageId: number;\n\t}\n\ttype CrxMessageOrigin = 'nip07-provider' | 'content' | 'background' | 'charge';\n\ttype CrxRpc =\n\t  | {\n\t      // possible paths:\n\t      // - 'nip07-provider' -> 'content' -> 'background'\n", "      kind: 'getPubkey';\n\t      request: {};\n\t      response: string;\n\t    }\n\t  | {\n\t      // possible paths:\n\t      // - 'nip07-provider' -> 'content' -> 'background'\n\t      kind: 'signEvent';\n\t      request: UnsignedEvent;\n\t      response: SignedEvent;\n", "    }\n\t  | {\n\t      // possible paths:\n\t      // - 'nip07-provider' -> 'content' -> 'background'\n\t      // - 'charge' -> 'background'\n\t      kind: 'getSignPower';\n\t      request: {};\n\t      response: number;\n\t    }\n\t  | {\n", "      // possible paths:\n\t      // - 'nip07-provider' -> 'content' -> 'background'\n\t      // - 'charge' -> 'background'\n\t      kind: 'setSignPower';\n\t      request: { value: number };\n\t      response: void;\n\t    }\n\t  | {\n\t      // possible paths:\n\t      // - 'nip07-provider' -> 'content'\n", "      kind: 'enterChargeMode';\n\t      request: {};\n\t      response: boolean;\n\t    }\n\t  | {\n\t      // possible paths:\n\t      // - 'content' -> 'background'\n\t      kind: 'openChargeWindow';\n\t      request: {};\n\t      response: number; // tabId\n", "    }\n\t  | {\n\t      // possible paths:\n\t      // - 'content' -> 'charge'\n\t      kind: 'sendStrain';\n\t      request: {\n\t        value: number;\n\t        neutral: number;\n\t      };\n\t      response: void;\n", "    }\n\t  | {\n\t      // possible paths:\n\t      // - 'charge' -> 'background' -> 'content'\n\t      kind: 'leaveChargeMode';\n\t      request: {\n\t        senderTabId: number;\n\t      };\n\t      response: void;\n\t    };\n", "type CrxRpcRequestPayload = _CrxRpcRequestPayload<CrxRpc>;\n\ttype CrxRpcResponsePayload = _CrxRpcResponsePayload<CrxRpc>;\n\ttype CrxRpcResponse<Req extends CrxRpcRequestPayload> = _CrxRpc<CrxRpc, Req['kind']>['response'];\n\ttype _CrxRpcRequestPayload<T extends CrxRpc> = T extends T ? Omit<T, 'response'> : never;\n\ttype _CrxRpcResponsePayload<T extends CrxRpc> = T extends T ? Omit<T, 'request'> : never;\n\ttype _CrxRpc<T extends CrxRpc, K extends CrxRpc['kind']> = T extends { kind: K } ? T : never;\n\t// nostr --------------------------------------------------\n\tinterface KeyPair {\n\t  seckey: string;\n\t  pubkey: string;\n", "}\n\tinterface UnsignedEvent {\n\t  kind: number;\n\t  tags: string[][];\n\t  content: string;\n\t  created_at: number;\n\t}\n\tinterface SignedEvent extends UnsignedEvent {\n\t  id: string;\n\t  sig: string;\n", "  pubkey: string;\n\t}\n"]}
{"filename": "src/resource/nip07-provider.ts", "chunked_list": ["// Note that web accessible scripts cannot import or export because they must be compiled into a single file by tsc.\n\t(window as any).nostr = {\n\t  async getPublicKey(): Promise<string> {\n\t    return rpc(\n\t      {\n\t        kind: 'getPubkey',\n\t        request: {},\n\t      },\n\t      ['content', 'background'],\n\t    );\n", "  },\n\t  async signEvent(event: UnsignedEvent): Promise<SignedEvent | undefined> {\n\t    let signPower = await rpc(\n\t      {\n\t        kind: 'getSignPower',\n\t        request: {},\n\t      },\n\t      ['content', 'background'],\n\t    );\n\t    if (signPower <= 0) {\n", "      await rpc(\n\t        {\n\t          kind: 'enterChargeMode',\n\t          request: {},\n\t        },\n\t        ['content'],\n\t      );\n\t      signPower = await rpc(\n\t        {\n\t          kind: 'getSignPower',\n", "          request: {},\n\t        },\n\t        ['content', 'background'],\n\t      );\n\t    }\n\t    if (signPower > 0) {\n\t      rpc(\n\t        {\n\t          kind: 'setSignPower',\n\t          request: { value: signPower - 1 },\n", "        },\n\t        ['content', 'background'],\n\t      );\n\t      return rpc(\n\t        {\n\t          kind: 'signEvent',\n\t          request: event,\n\t        },\n\t        ['content', 'background'],\n\t      );\n", "    }\n\t  },\n\t};\n\tconst ext: ExtName = 'nostronger';\n\tfunction rpc<T extends CrxRpcRequestPayload>(\n\t  req: T,\n\t  path: CrxMessageOrigin[],\n\t  timeout?: number,\n\t): Promise<CrxRpcResponse<T>> {\n\t  return new Promise((resolve, reject) => {\n", "    const messageId = Math.floor(Math.random() * 1000000);\n\t    const message: CrxRpcRequestMessage = {\n\t      ext,\n\t      messageId,\n\t      src: 'nip07-provider',\n\t      path,\n\t      payload: req,\n\t    };\n\t    window.addEventListener('message', listener);\n\t    window.postMessage(message, '*');\n", "    const timeoutId = timeout\n\t      ? setTimeout(() => {\n\t          window.removeEventListener('message', listener);\n\t          reject(`Request \\`${req.kind}\\` timed out`);\n\t        }, timeout)\n\t      : -1;\n\t    function listener(ev: MessageEvent<CrxRpcResponseMessage>) {\n\t      const data = ev.data;\n\t      if (\n\t        data.ext !== 'nostronger' ||\n", "        data.messageId !== messageId ||\n\t        data.payload.kind !== req.kind ||\n\t        !('response' in data.payload)\n\t      ) {\n\t        return;\n\t      }\n\t      // Assumed by `data.payload.kind !== req.kind`\n\t      const response = data.payload.response as CrxRpcResponse<T> | PromiseLike<CrxRpcResponse<T>>;\n\t      window.removeEventListener('message', listener);\n\t      clearInterval(timeoutId);\n", "      resolve(response);\n\t    }\n\t  });\n\t}\n"]}
{"filename": "src/content/index.ts", "chunked_list": ["import { ext, generateMessageId, handleCrxRpcRequest, wait } from '../lib/messaging';\n\timport { getJoyconDevice, getNextStrain, getStrain, setupJoycon } from '../lib/ring-con';\n\tinjectResourceScript('js/nip07-provider.js');\n\t// 'nip07-provider' -> ...\n\twindow.addEventListener('message', async ({ data }: MessageEvent<CrxRpcRequestMessage>) => {\n\t  const { next, shouldBeHandled } = handleCrxRpcRequest(data, 'content');\n\t  if (!shouldBeHandled) {\n\t    return;\n\t  }\n\t  if (next === 'background') {\n", "    // ... -> HERE -> 'background'\n\t    const response: CrxRpcResponseMessage = await chrome.runtime.sendMessage(data);\n\t    window.postMessage(response);\n\t    return;\n\t  } else if (!!next) {\n\t    console.warn('Unexpected message', data);\n\t    return;\n\t  }\n\t  //...  -> HERE\n\t  switch (data.payload.kind) {\n", "    case 'enterChargeMode':\n\t      {\n\t        try {\n\t          const response = await enterChargeMode(data);\n\t          window.postMessage(response);\n\t        } catch (err) {\n\t          console.error(err);\n\t          window.postMessage({\n\t            ext,\n\t            messageId: data.messageId,\n", "            payload: {\n\t              kind: 'enterChargeMode',\n\t              response: false,\n\t            },\n\t          });\n\t          throw err;\n\t        }\n\t      }\n\t      break;\n\t    default:\n", "      break;\n\t  }\n\t});\n\tasync function enterChargeMode({\n\t  messageId,\n\t  payload,\n\t}: CrxRpcRequestMessage): Promise<CrxRpcResponseMessage> {\n\t  if (payload.kind !== 'enterChargeMode') {\n\t    throw 'Unexpected message';\n\t  }\n", "  const openChargeWindowReq: CrxRpcMessage = {\n\t    ext,\n\t    messageId: generateMessageId(),\n\t    src: 'content',\n\t    path: ['background'],\n\t    payload: {\n\t      kind: 'openChargeWindow',\n\t      request: {},\n\t    },\n\t  };\n", "  const { payload: result }: CrxRpcResponseMessage = await chrome.runtime.sendMessage(\n\t    openChargeWindowReq,\n\t  );\n\t  if (result.kind !== 'openChargeWindow') {\n\t    throw 'Unexpected message';\n\t  }\n\t  // Keep sending strain signals.\n\t  const joycon = await getJoyconDevice();\n\t  await setupJoycon(joycon);\n\t  const neutral = await getNextStrain(joycon);\n", "  const sendStrain = (value: number) => {\n\t    const req: CrxRpcMessage = {\n\t      ext,\n\t      messageId: generateMessageId(),\n\t      src: 'content',\n\t      path: ['charge'],\n\t      payload: {\n\t        kind: 'sendStrain',\n\t        request: {\n\t          value,\n", "          neutral,\n\t        },\n\t      },\n\t    };\n\t    chrome.runtime.sendMessage(req);\n\t  };\n\t  const reportListener = (ev: HIDInputReportEvent) => {\n\t    const value = getStrain(ev);\n\t    if (value) {\n\t      sendStrain(value);\n", "    }\n\t  };\n\t  joycon.addEventListener('inputreport', reportListener);\n\t  // Wait for `leaveChargeMode` signal.\n\t  await wait<CrxRpcRequestMessage, void>(\n\t    (resolve) => (msg) => {\n\t      const { next, shouldBeHandled } = handleCrxRpcRequest(msg, 'content');\n\t      if (!shouldBeHandled) {\n\t        return;\n\t      }\n", "      if (!!next) {\n\t        console.warn('Unexpected message', msg);\n\t        return;\n\t      }\n\t      if (msg.payload.kind === 'leaveChargeMode') {\n\t        resolve();\n\t      }\n\t    },\n\t    {\n\t      addEventListener: (listener) => {\n", "        chrome.runtime.onMessage.addListener(listener);\n\t      },\n\t      removeEventListener: (listener) => {\n\t        chrome.runtime.onMessage.removeListener(listener);\n\t      },\n\t    },\n\t  );\n\t  // Stop sending strain signals.\n\t  joycon.removeEventListener('inputreport', reportListener);\n\t  return {\n", "    ext,\n\t    messageId,\n\t    payload: {\n\t      kind: 'enterChargeMode',\n\t      response: true,\n\t    },\n\t  };\n\t}\n\tfunction injectResourceScript(path: string) {\n\t  const script = document.createElement('script');\n", "  script.setAttribute('async', 'false');\n\t  script.setAttribute('type', 'text/javascript');\n\t  script.setAttribute('src', chrome.runtime.getURL(path));\n\t  document.head.appendChild(script);\n\t}\n"]}
