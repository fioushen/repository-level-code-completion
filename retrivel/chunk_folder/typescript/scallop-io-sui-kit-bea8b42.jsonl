{"filename": "test/index.spec.ts", "chunked_list": ["import * as dotenv from 'dotenv';\n\timport { describe, it, expect } from 'vitest';\n\timport { SuiKit, SuiTxBlock } from '../src/index';\n\timport { SuiOwnedObject } from '../src/libs/suiModel';\n\tdotenv.config();\n\t/**\n\t *  Remove `.skip` to proceed with testing according to requirements.\n\t */\n\tdescribe('Test Scallop Kit', async () => {\n\t  const fullnodeUrls = [\n", "    'https://api.shinami.com/node/v1/sui_mainnet_af69715eb5088e2eb2000069999a65d8',\n\t    'https://sui-mainnet.blockvision.org/v1/2Sf0z3YB6WWNOcn8HuUWHjdp4Sb',\n\t    'https://fullnode.mainnet.sui.io:443',\n\t  ];\n\t  const suiKit = new SuiKit({\n\t    // secretKey: process.env.SECRET_KEY,\n\t    mnemonics: process.env.MNEMONICS,\n\t    fullnodeUrls,\n\t  });\n\t  it('Manage account', async () => {\n", "    const coinType = '0x2::sui::SUI';\n\t    const addr = suiKit.getAddress({ accountIndex: 0 });\n\t    const balance = (await suiKit.getBalance(coinType, { accountIndex: 0 }))\n\t      .totalBalance;\n\t    console.log(`Account ${0}: ${addr} has ${balance} SUI`);\n\t    expect(!!addr).toBe(true);\n\t  });\n\t  it('use multiple fullnodeUrls', async () => {\n\t    const tx = new SuiTxBlock();\n\t    const gas = new SuiOwnedObject({\n", "      objectId:\n\t        '0x6d8528380c0e91611f674af8ae12a509cd63288607bc07c981a1f15fb7d3a19b',\n\t    });\n\t    await suiKit.updateObjects([gas]);\n\t    tx.moveCall('0x2::sui::getSUI');\n\t    tx.setSender(suiKit.currentAddress());\n\t    tx.setGasPrice(1000);\n\t    tx.setGasPayment([\n\t      { objectId: gas.objectId, version: gas.version!, digest: gas.digest! },\n\t    ]);\n", "    tx.setGasBudget(10 ** 7);\n\t    const res = await suiKit.signAndSendTxn(tx);\n\t    console.log(res);\n\t  });\n\t  it('getObjects', async () => {\n\t    const res = await suiKit.getObjects([\n\t      '0x6d8528380c0e91611f674af8ae12a509cd63288607bc07c981a1f15fb7d3a19c',\n\t    ]);\n\t    console.log(res);\n\t  });\n", "});\n"]}
{"filename": "src/suiKit.ts", "chunked_list": ["/**\n\t * @description This file is used to aggregate the tools that used to interact with SUI network.\n\t */\n\timport {\n\t  RawSigner,\n\t  TransactionBlock,\n\t  DevInspectResults,\n\t  SuiTransactionBlockResponse,\n\t} from '@mysten/sui.js';\n\timport { SuiAccountManager } from './libs/suiAccountManager';\n", "import { SuiTxBlock } from './libs/suiTxBuilder';\n\timport { SuiInteractor, getDefaultConnection } from './libs/suiInteractor';\n\timport { SuiSharedObject, SuiOwnedObject } from './libs/suiModel';\n\timport { SuiKitParams, DerivePathParams, SuiTxArg, SuiVecTxArg } from './types';\n\t/**\n\t * @class SuiKit\n\t * @description This class is used to aggregate the tools that used to interact with SUI network.\n\t */\n\texport class SuiKit {\n\t  public accountManager: SuiAccountManager;\n", "  public suiInteractor: SuiInteractor;\n\t  /**\n\t   * Support the following ways to init the SuiToolkit:\n\t   * 1. mnemonics\n\t   * 2. secretKey (base64 or hex)\n\t   * If none of them is provided, will generate a random mnemonics with 24 words.\n\t   *\n\t   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n\t   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored\n\t   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'devnet'\n", "   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type\n\t   */\n\t  constructor({\n\t    mnemonics,\n\t    secretKey,\n\t    networkType,\n\t    fullnodeUrls,\n\t  }: SuiKitParams = {}) {\n\t    // Init the account manager\n\t    this.accountManager = new SuiAccountManager({ mnemonics, secretKey });\n", "    // Init the rpc provider\n\t    fullnodeUrls = fullnodeUrls || [getDefaultConnection(networkType).fullnode];\n\t    this.suiInteractor = new SuiInteractor(fullnodeUrls);\n\t  }\n\t  /**\n\t   * if derivePathParams is not provided or mnemonics is empty, it will return the currentSigner.\n\t   * else:\n\t   * it will generate signer from the mnemonic with the given derivePathParams.\n\t   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n\t   */\n", "  getSigner(derivePathParams?: DerivePathParams) {\n\t    const keyPair = this.accountManager.getKeyPair(derivePathParams);\n\t    return new RawSigner(keyPair, this.suiInteractor.currentProvider);\n\t  }\n\t  /**\n\t   * @description Switch the current account with the given derivePathParams\n\t   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n\t   */\n\t  switchAccount(derivePathParams: DerivePathParams) {\n\t    this.accountManager.switchAccount(derivePathParams);\n", "  }\n\t  /**\n\t   * @description Get the address of the account for the given derivePathParams\n\t   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n\t   */\n\t  getAddress(derivePathParams?: DerivePathParams) {\n\t    return this.accountManager.getAddress(derivePathParams);\n\t  }\n\t  currentAddress() {\n\t    return this.accountManager.currentAddress;\n", "  }\n\t  provider() {\n\t    return this.suiInteractor.currentProvider;\n\t  }\n\t  async getBalance(coinType?: string, derivePathParams?: DerivePathParams) {\n\t    const owner = this.accountManager.getAddress(derivePathParams);\n\t    return this.suiInteractor.currentProvider.getBalance({ owner, coinType });\n\t  }\n\t  async getObjects(objectIds: string[]) {\n\t    return this.suiInteractor.getObjects(objectIds);\n", "  }\n\t  /**\n\t   * @description Update objects in a batch\n\t   * @param suiObjects\n\t   */\n\t  async updateObjects(suiObjects: (SuiSharedObject | SuiOwnedObject)[]) {\n\t    return this.suiInteractor.updateObjects(suiObjects);\n\t  }\n\t  async signTxn(\n\t    tx: Uint8Array | TransactionBlock | SuiTxBlock,\n", "    derivePathParams?: DerivePathParams\n\t  ) {\n\t    tx = tx instanceof SuiTxBlock ? tx.txBlock : tx;\n\t    const signer = this.getSigner(derivePathParams);\n\t    return signer.signTransactionBlock({ transactionBlock: tx });\n\t  }\n\t  async signAndSendTxn(\n\t    tx: Uint8Array | TransactionBlock | SuiTxBlock,\n\t    derivePathParams?: DerivePathParams\n\t  ): Promise<SuiTransactionBlockResponse> {\n", "    const { transactionBlockBytes, signature } = await this.signTxn(\n\t      tx,\n\t      derivePathParams\n\t    );\n\t    return this.suiInteractor.sendTx(transactionBlockBytes, signature);\n\t  }\n\t  /**\n\t   * Transfer the given amount of SUI to the recipient\n\t   * @param recipient\n\t   * @param amount\n", "   * @param derivePathParams\n\t   */\n\t  async transferSui(\n\t    recipient: string,\n\t    amount: number,\n\t    derivePathParams?: DerivePathParams\n\t  ) {\n\t    const tx = new SuiTxBlock();\n\t    tx.transferSui(recipient, amount);\n\t    return this.signAndSendTxn(tx, derivePathParams);\n", "  }\n\t  /**\n\t   * Transfer to mutliple recipients\n\t   * @param recipients the recipients addresses\n\t   * @param amounts the amounts of SUI to transfer to each recipient, the length of amounts should be the same as the length of recipients\n\t   * @param derivePathParams\n\t   */\n\t  async transferSuiToMany(\n\t    recipients: string[],\n\t    amounts: number[],\n", "    derivePathParams?: DerivePathParams\n\t  ) {\n\t    const tx = new SuiTxBlock();\n\t    tx.transferSuiToMany(recipients, amounts);\n\t    return this.signAndSendTxn(tx, derivePathParams);\n\t  }\n\t  /**\n\t   * Transfer the given amounts of coin to multiple recipients\n\t   * @param recipients the list of recipient address\n\t   * @param amounts the amounts to transfer for each recipient\n", "   * @param coinType any custom coin type but not SUI\n\t   * @param derivePathParams the derive path params for the current signer\n\t   */\n\t  async transferCoinToMany(\n\t    recipients: string[],\n\t    amounts: number[],\n\t    coinType: string,\n\t    derivePathParams?: DerivePathParams\n\t  ) {\n\t    const tx = new SuiTxBlock();\n", "    const owner = this.accountManager.getAddress(derivePathParams);\n\t    const totalAmount = amounts.reduce((a, b) => a + b, 0);\n\t    const coins = await this.suiInteractor.selectCoins(\n\t      owner,\n\t      totalAmount,\n\t      coinType\n\t    );\n\t    tx.transferCoinToMany(\n\t      coins.map((c) => c.objectId),\n\t      owner,\n", "      recipients,\n\t      amounts\n\t    );\n\t    return this.signAndSendTxn(tx, derivePathParams);\n\t  }\n\t  async transferCoin(\n\t    recipient: string,\n\t    amount: number,\n\t    coinType: string,\n\t    derivePathParams?: DerivePathParams\n", "  ) {\n\t    return this.transferCoinToMany(\n\t      [recipient],\n\t      [amount],\n\t      coinType,\n\t      derivePathParams\n\t    );\n\t  }\n\t  async transferObjects(\n\t    objects: string[],\n", "    recipient: string,\n\t    derivePathParams?: DerivePathParams\n\t  ) {\n\t    const tx = new SuiTxBlock();\n\t    tx.transferObjects(objects, recipient);\n\t    return this.signAndSendTxn(tx, derivePathParams);\n\t  }\n\t  async moveCall(callParams: {\n\t    target: string;\n\t    arguments?: (SuiTxArg | SuiVecTxArg)[];\n", "    typeArguments?: string[];\n\t    derivePathParams?: DerivePathParams;\n\t  }) {\n\t    const {\n\t      target,\n\t      arguments: args = [],\n\t      typeArguments = [],\n\t      derivePathParams,\n\t    } = callParams;\n\t    const tx = new SuiTxBlock();\n", "    tx.moveCall(target, args, typeArguments);\n\t    return this.signAndSendTxn(tx, derivePathParams);\n\t  }\n\t  /**\n\t   * Select coins with the given amount and coin type, the total amount is greater than or equal to the given amount\n\t   * @param amount\n\t   * @param coinType\n\t   * @param owner\n\t   */\n\t  async selectCoinsWithAmount(\n", "    amount: number,\n\t    coinType: string,\n\t    owner?: string\n\t  ) {\n\t    owner = owner || this.accountManager.currentAddress;\n\t    const coins = await this.suiInteractor.selectCoins(owner, amount, coinType);\n\t    return coins.map((c) => c.objectId);\n\t  }\n\t  /**\n\t   * stake the given amount of SUI to the validator\n", "   * @param amount the amount of SUI to stake\n\t   * @param validatorAddr the validator address\n\t   * @param derivePathParams the derive path params for the current signer\n\t   */\n\t  async stakeSui(\n\t    amount: number,\n\t    validatorAddr: string,\n\t    derivePathParams?: DerivePathParams\n\t  ) {\n\t    const tx = new SuiTxBlock();\n", "    tx.stakeSui(amount, validatorAddr);\n\t    return this.signAndSendTxn(tx, derivePathParams);\n\t  }\n\t  /**\n\t   * Execute the transaction with on-chain data but without really submitting. Useful for querying the effects of a transaction.\n\t   * Since the transaction is not submitted, its gas cost is not charged.\n\t   * @param tx the transaction to execute\n\t   * @param derivePathParams the derive path params\n\t   * @returns the effects and events of the transaction, such as object changes, gas cost, event emitted.\n\t   */\n", "  async inspectTxn(\n\t    tx: Uint8Array | TransactionBlock | SuiTxBlock,\n\t    derivePathParams?: DerivePathParams\n\t  ): Promise<DevInspectResults> {\n\t    tx = tx instanceof SuiTxBlock ? tx.txBlock : tx;\n\t    return this.suiInteractor.currentProvider.devInspectTransactionBlock({\n\t      transactionBlock: tx,\n\t      sender: this.getAddress(derivePathParams),\n\t    });\n\t  }\n", "}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export {\n\t  TransactionBlock,\n\t  SUI_CLOCK_OBJECT_ID,\n\t  SUI_SYSTEM_STATE_OBJECT_ID,\n\t} from '@mysten/sui.js';\n\texport { SuiKit } from './suiKit';\n\texport { SuiAccountManager } from './libs/suiAccountManager';\n\texport { SuiTxBlock } from './libs/suiTxBuilder';\n\texport type * from './types';\n"]}
{"filename": "src/libs/suiInteractor/suiInteractor.ts", "chunked_list": ["import {\n\t  SuiTransactionBlockResponse,\n\t  SuiTransactionBlockResponseOptions,\n\t  JsonRpcProvider,\n\t  Connection,\n\t  getObjectDisplay,\n\t  getObjectFields,\n\t  getObjectId,\n\t  getObjectType,\n\t  getObjectVersion,\n", "  getSharedObjectInitialVersion,\n\t} from '@mysten/sui.js';\n\timport { ObjectData } from 'src/types';\n\timport { SuiOwnedObject, SuiSharedObject } from '../suiModel';\n\timport { delay } from './util';\n\t/**\n\t * `SuiTransactionSender` is used to send transaction with a given gas coin.\n\t * It always uses the gas coin to pay for the gas,\n\t * and update the gas coin after the transaction.\n\t */\n", "export class SuiInteractor {\n\t  public readonly providers: JsonRpcProvider[];\n\t  public currentProvider: JsonRpcProvider;\n\t  constructor(fullNodeUrls: string[]) {\n\t    if (fullNodeUrls.length === 0)\n\t      throw new Error('fullNodeUrls must not be empty');\n\t    this.providers = fullNodeUrls.map(\n\t      (url) => new JsonRpcProvider(new Connection({ fullnode: url }))\n\t    );\n\t    this.currentProvider = this.providers[0];\n", "  }\n\t  switchToNextProvider() {\n\t    const currentProviderIdx = this.providers.indexOf(this.currentProvider);\n\t    this.currentProvider =\n\t      this.providers[(currentProviderIdx + 1) % this.providers.length];\n\t  }\n\t  async sendTx(\n\t    transactionBlock: Uint8Array | string,\n\t    signature: string | string[]\n\t  ): Promise<SuiTransactionBlockResponse> {\n", "    const txResOptions: SuiTransactionBlockResponseOptions = {\n\t      showEvents: true,\n\t      showEffects: true,\n\t      showObjectChanges: true,\n\t      showBalanceChanges: true,\n\t    };\n\t    // const currentProviderIdx = this.providers.indexOf(this.currentProvider);\n\t    // const providers = [\n\t    //   ...this.providers.slice(currentProviderIdx, this.providers.length),\n\t    //   ...this.providers.slice(0, currentProviderIdx),\n", "    // ]\n\t    for (const provider of this.providers) {\n\t      try {\n\t        const res = await provider.executeTransactionBlock({\n\t          transactionBlock,\n\t          signature,\n\t          options: txResOptions,\n\t        });\n\t        return res;\n\t      } catch (err) {\n", "        console.warn(\n\t          `Failed to send transaction with fullnode ${provider.connection.fullnode}: ${err}`\n\t        );\n\t        await delay(2000);\n\t      }\n\t    }\n\t    throw new Error('Failed to send transaction with all fullnodes');\n\t  }\n\t  async getObjects(ids: string[]) {\n\t    const options = {\n", "      showContent: true,\n\t      showDisplay: true,\n\t      showType: true,\n\t      showOwner: true,\n\t    };\n\t    // const currentProviderIdx = this.providers.indexOf(this.currentProvider);\n\t    // const providers = [\n\t    //   ...this.providers.slice(currentProviderIdx, this.providers.length),\n\t    //   ...this.providers.slice(0, currentProviderIdx),\n\t    // ]\n", "    for (const provider of this.providers) {\n\t      try {\n\t        const objects = await provider.multiGetObjects({ ids, options });\n\t        const parsedObjects = objects.map((object) => {\n\t          const objectId = getObjectId(object);\n\t          const objectType = getObjectType(object);\n\t          const objectVersion = getObjectVersion(object);\n\t          const objectDigest = object.data ? object.data.digest : undefined;\n\t          const initialSharedVersion = getSharedObjectInitialVersion(object);\n\t          const objectFields = getObjectFields(object);\n", "          const objectDisplay = getObjectDisplay(object);\n\t          return {\n\t            objectId,\n\t            objectType,\n\t            objectVersion,\n\t            objectDigest,\n\t            objectFields,\n\t            objectDisplay,\n\t            initialSharedVersion,\n\t          };\n", "        });\n\t        return parsedObjects as ObjectData[];\n\t      } catch (err) {\n\t        await delay(2000);\n\t        console.warn(\n\t          `Failed to get objects with fullnode ${provider.connection.fullnode}: ${err}`\n\t        );\n\t      }\n\t    }\n\t    throw new Error('Failed to get objects with all fullnodes');\n", "  }\n\t  async getObject(id: string) {\n\t    const objects = await this.getObjects([id]);\n\t    return objects[0];\n\t  }\n\t  /**\n\t   * @description Update objects in a batch\n\t   * @param suiObjects\n\t   */\n\t  async updateObjects(suiObjects: (SuiOwnedObject | SuiSharedObject)[]) {\n", "    const objectIds = suiObjects.map((obj) => obj.objectId);\n\t    const objects = await this.getObjects(objectIds);\n\t    for (const object of objects) {\n\t      const suiObject = suiObjects.find(\n\t        (obj) => obj.objectId === object.objectId\n\t      );\n\t      if (suiObject instanceof SuiSharedObject) {\n\t        suiObject.initialSharedVersion = object.initialSharedVersion;\n\t      } else if (suiObject instanceof SuiOwnedObject) {\n\t        suiObject.version = object.objectVersion;\n", "        suiObject.digest = object.objectDigest;\n\t      }\n\t    }\n\t  }\n\t  /**\n\t   * @description Select coins that add up to the given amount.\n\t   * @param addr the address of the owner\n\t   * @param amount the amount that is needed for the coin\n\t   * @param coinType the coin type, default is '0x2::SUI::SUI'\n\t   */\n", "  async selectCoins(\n\t    addr: string,\n\t    amount: number,\n\t    coinType: string = '0x2::SUI::SUI'\n\t  ) {\n\t    const selectedCoins: {\n\t      objectId: string;\n\t      digest: string;\n\t      version: string;\n\t    }[] = [];\n", "    let totalAmount = 0;\n\t    let hasNext = true,\n\t      nextCursor: string | null = null;\n\t    while (hasNext && totalAmount < amount) {\n\t      const coins = await this.currentProvider.getCoins({\n\t        owner: addr,\n\t        coinType: coinType,\n\t        cursor: nextCursor,\n\t      });\n\t      // Sort the coins by balance in descending order\n", "      coins.data.sort((a, b) => parseInt(b.balance) - parseInt(a.balance));\n\t      for (const coinData of coins.data) {\n\t        selectedCoins.push({\n\t          objectId: coinData.coinObjectId,\n\t          digest: coinData.digest,\n\t          version: coinData.version,\n\t        });\n\t        totalAmount = totalAmount + parseInt(coinData.balance);\n\t        if (totalAmount >= amount) {\n\t          break;\n", "        }\n\t      }\n\t      nextCursor = coins.nextCursor;\n\t      hasNext = coins.hasNextPage;\n\t    }\n\t    if (!selectedCoins.length) {\n\t      throw new Error('No valid coins found for the transaction.');\n\t    }\n\t    return selectedCoins;\n\t  }\n", "}\n"]}
{"filename": "src/libs/suiInteractor/defaultConfig.ts", "chunked_list": ["import {\n\t  localnetConnection,\n\t  devnetConnection,\n\t  testnetConnection,\n\t  mainnetConnection,\n\t} from '@mysten/sui.js';\n\timport type { Connection } from '@mysten/sui.js';\n\timport type { NetworkType } from 'src/types';\n\texport const defaultGasBudget = 10 ** 8; // 0.1 SUI, should be enough for most of the transactions\n\texport const defaultGasPrice = 1000; // 1000 MIST\n", "/**\n\t * @description Get the default fullnode url and faucet url for the given network type\n\t * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localnet', default is 'devnet'\n\t * @returns { fullNode: string, websocket: string, faucet?: string }\n\t */\n\texport const getDefaultConnection = (\n\t  networkType: NetworkType = 'devnet'\n\t): Connection => {\n\t  switch (networkType) {\n\t    case 'localnet':\n", "      return localnetConnection;\n\t    case 'devnet':\n\t      return devnetConnection;\n\t    case 'testnet':\n\t      return testnetConnection;\n\t    case 'mainnet':\n\t      return mainnetConnection;\n\t    default:\n\t      return devnetConnection;\n\t  }\n", "};\n"]}
{"filename": "src/libs/suiInteractor/index.ts", "chunked_list": ["export { SuiInteractor } from './suiInteractor';\n\texport { getDefaultConnection } from './defaultConfig';\n"]}
{"filename": "src/libs/suiInteractor/util.ts", "chunked_list": ["export const delay = (ms: number) =>\n\t  new Promise((resolve) => setTimeout(resolve, ms));\n"]}
{"filename": "src/libs/suiTxBuilder/index.ts", "chunked_list": ["import {\n\t  TransactionBlock,\n\t  SUI_SYSTEM_STATE_OBJECT_ID,\n\t  TransactionExpiration,\n\t  SuiObjectRef,\n\t  SharedObjectRef,\n\t  JsonRpcProvider,\n\t  TransactionType,\n\t  Transactions,\n\t  ObjectCallArg,\n", "} from '@mysten/sui.js';\n\timport { convertArgs } from './util';\n\timport type { SuiTxArg, SuiObjectArg, SuiVecTxArg } from 'src/types';\n\texport class SuiTxBlock {\n\t  public txBlock: TransactionBlock;\n\t  constructor(transaction?: TransactionBlock) {\n\t    this.txBlock = new TransactionBlock(transaction);\n\t  }\n\t  //======== override methods of TransactionBlock ============\n\t  address(value: string) {\n", "    return this.txBlock.pure(value, 'address');\n\t  }\n\t  pure(value: unknown, type?: string) {\n\t    return this.txBlock.pure(value, type);\n\t  }\n\t  object(value: string | ObjectCallArg) {\n\t    return this.txBlock.object(value);\n\t  }\n\t  objectRef(ref: SuiObjectRef) {\n\t    return this.txBlock.objectRef(ref);\n", "  }\n\t  sharedObjectRef(ref: SharedObjectRef) {\n\t    return this.txBlock.sharedObjectRef(ref);\n\t  }\n\t  setSender(sender: string) {\n\t    return this.txBlock.setSender(sender);\n\t  }\n\t  setSenderIfNotSet(sender: string) {\n\t    return this.txBlock.setSenderIfNotSet(sender);\n\t  }\n", "  setExpiration(expiration?: TransactionExpiration) {\n\t    return this.txBlock.setExpiration(expiration);\n\t  }\n\t  setGasPrice(price: number | bigint) {\n\t    return this.txBlock.setGasPrice(price);\n\t  }\n\t  setGasBudget(budget: number | bigint) {\n\t    return this.txBlock.setGasBudget(budget);\n\t  }\n\t  setGasOwner(owner: string) {\n", "    return this.txBlock.setGasOwner(owner);\n\t  }\n\t  setGasPayment(payments: SuiObjectRef[]) {\n\t    return this.txBlock.setGasPayment(payments);\n\t  }\n\t  add(transaction: TransactionType) {\n\t    return this.txBlock.add(transaction);\n\t  }\n\t  serialize() {\n\t    return this.txBlock.serialize();\n", "  }\n\t  build(\n\t    params: {\n\t      provider?: JsonRpcProvider;\n\t      onlyTransactionKind?: boolean;\n\t    } = {}\n\t  ) {\n\t    return this.txBlock.build(params);\n\t  }\n\t  getDigest({ provider }: { provider?: JsonRpcProvider } = {}) {\n", "    return this.txBlock.getDigest({ provider });\n\t  }\n\t  get gas() {\n\t    return this.txBlock.gas;\n\t  }\n\t  get blockData() {\n\t    return this.txBlock.blockData;\n\t  }\n\t  transferObjects(objects: SuiObjectArg[], recipient: string) {\n\t    const tx = this.txBlock;\n", "    tx.transferObjects(convertArgs(this.txBlock, objects), tx.pure(recipient));\n\t    return this;\n\t  }\n\t  splitCoins(coin: SuiObjectArg, amounts: number[]) {\n\t    const tx = this.txBlock;\n\t    const coinObject = convertArgs(this.txBlock, [coin])[0];\n\t    const res = tx.splitCoins(\n\t      coinObject,\n\t      amounts.map((m) => tx.pure(m))\n\t    );\n", "    return amounts.map((_, i) => res[i]);\n\t  }\n\t  mergeCoins(destination: SuiObjectArg, sources: SuiObjectArg[]) {\n\t    const destinationObject = convertArgs(this.txBlock, [destination])[0];\n\t    const sourceObjects = convertArgs(this.txBlock, sources);\n\t    return this.txBlock.mergeCoins(destinationObject, sourceObjects);\n\t  }\n\t  publish(...args: Parameters<(typeof Transactions)['Publish']>) {\n\t    return this.txBlock.publish(...args);\n\t  }\n", "  upgrade(...args: Parameters<(typeof Transactions)['Upgrade']>) {\n\t    return this.txBlock.upgrade(...args);\n\t  }\n\t  makeMoveVec(...args: Parameters<(typeof Transactions)['MakeMoveVec']>) {\n\t    return this.txBlock.makeMoveVec(...args);\n\t  }\n\t  /**\n\t   * @description Move call\n\t   * @param target `${string}::${string}::${string}`, e.g. `0x3::sui_system::request_add_stake`\n\t   * @param args the arguments of the move call, such as `['0x1', '0x2']`\n", "   * @param typeArgs the type arguments of the move call, such as `['0x2::sui::SUI']`\n\t   */\n\t  moveCall(\n\t    target: string,\n\t    args: (SuiTxArg | SuiVecTxArg)[] = [],\n\t    typeArgs: string[] = []\n\t  ) {\n\t    // a regex for pattern `${string}::${string}::${string}`\n\t    const regex =\n\t      /(?<package>[a-zA-Z0-9]+)::(?<module>[a-zA-Z0-9_]+)::(?<function>[a-zA-Z0-9_]+)/;\n", "    const match = target.match(regex);\n\t    if (match === null)\n\t      throw new Error(\n\t        'Invalid target format. Expected `${string}::${string}::${string}`'\n\t      );\n\t    const convertedArgs = convertArgs(this.txBlock, args);\n\t    const tx = this.txBlock;\n\t    return tx.moveCall({\n\t      target: target as `${string}::${string}::${string}`,\n\t      arguments: convertedArgs,\n", "      typeArguments: typeArgs,\n\t    });\n\t  }\n\t  //======== enhance methods ============\n\t  transferSuiToMany(recipients: string[], amounts: number[]) {\n\t    // require recipients.length === amounts.length\n\t    if (recipients.length !== amounts.length) {\n\t      throw new Error(\n\t        'transferSuiToMany: recipients.length !== amounts.length'\n\t      );\n", "    }\n\t    const tx = this.txBlock;\n\t    const coins = tx.splitCoins(\n\t      tx.gas,\n\t      amounts.map((amount) => tx.pure(amount))\n\t    );\n\t    recipients.forEach((recipient, index) => {\n\t      tx.transferObjects([coins[index]], tx.pure(recipient));\n\t    });\n\t    return this;\n", "  }\n\t  transferSui(recipient: string, amount: number) {\n\t    return this.transferSuiToMany([recipient], [amount]);\n\t  }\n\t  takeAmountFromCoins(coins: SuiObjectArg[], amount: number) {\n\t    const tx = this.txBlock;\n\t    const coinObjects = convertArgs(this.txBlock, coins);\n\t    const mergedCoin = coinObjects[0];\n\t    if (coins.length > 1) {\n\t      tx.mergeCoins(mergedCoin, coinObjects.slice(1));\n", "    }\n\t    const [sendCoin] = tx.splitCoins(mergedCoin, [tx.pure(amount)]);\n\t    return [sendCoin, mergedCoin];\n\t  }\n\t  splitSUIFromGas(amounts: number[]) {\n\t    const tx = this.txBlock;\n\t    return tx.splitCoins(\n\t      tx.gas,\n\t      amounts.map((m) => tx.pure(m))\n\t    );\n", "  }\n\t  splitMultiCoins(coins: SuiObjectArg[], amounts: number[]) {\n\t    const tx = this.txBlock;\n\t    const coinObjects = convertArgs(this.txBlock, coins);\n\t    const mergedCoin = coinObjects[0];\n\t    if (coins.length > 1) {\n\t      tx.mergeCoins(mergedCoin, coinObjects.slice(1));\n\t    }\n\t    const splitedCoins = tx.splitCoins(\n\t      mergedCoin,\n", "      amounts.map((m) => tx.pure(m))\n\t    );\n\t    return { splitedCoins, mergedCoin };\n\t  }\n\t  transferCoinToMany(\n\t    inputCoins: SuiObjectArg[],\n\t    sender: string,\n\t    recipients: string[],\n\t    amounts: number[]\n\t  ) {\n", "    // require recipients.length === amounts.length\n\t    if (recipients.length !== amounts.length) {\n\t      throw new Error(\n\t        'transferSuiToMany: recipients.length !== amounts.length'\n\t      );\n\t    }\n\t    const tx = this.txBlock;\n\t    const { splitedCoins, mergedCoin } = this.splitMultiCoins(\n\t      inputCoins,\n\t      amounts\n", "    );\n\t    recipients.forEach((recipient, index) => {\n\t      tx.transferObjects([splitedCoins[index]], tx.pure(recipient));\n\t    });\n\t    tx.transferObjects([mergedCoin], tx.pure(sender));\n\t    return this;\n\t  }\n\t  transferCoin(\n\t    inputCoins: SuiObjectArg[],\n\t    sender: string,\n", "    recipient: string,\n\t    amount: number\n\t  ) {\n\t    return this.transferCoinToMany(inputCoins, sender, [recipient], [amount]);\n\t  }\n\t  stakeSui(amount: number, validatorAddr: string) {\n\t    const tx = this.txBlock;\n\t    const [stakeCoin] = tx.splitCoins(tx.gas, [tx.pure(amount)]);\n\t    tx.moveCall({\n\t      target: '0x3::sui_system::request_add_stake',\n", "      arguments: [\n\t        tx.object(SUI_SYSTEM_STATE_OBJECT_ID),\n\t        stakeCoin,\n\t        tx.pure(validatorAddr),\n\t      ],\n\t    });\n\t    return tx;\n\t  }\n\t}\n"]}
{"filename": "src/libs/suiTxBuilder/util.ts", "chunked_list": ["import {\n\t  normalizeSuiObjectId,\n\t  TransactionArgument,\n\t  TransactionBlock,\n\t} from '@mysten/sui.js';\n\timport { SuiTxArg, SuiInputTypes } from 'src/types';\n\texport const getDefaultSuiInputType = (value: any): SuiInputTypes => {\n\t  if (typeof value === 'string' && value.startsWith('0x')) {\n\t    return 'object';\n\t  } else if (typeof value === 'number' || typeof value === 'bigint') {\n", "    return 'u64';\n\t  } else if (typeof value === 'boolean') {\n\t    return 'bool';\n\t  } else {\n\t    return 'object';\n\t  }\n\t};\n\t/**\n\t * Since we know the elements in the array are the same type\n\t * If type is not provided, we will try to infer the type from the first element\n", " * By default,\n\t *\n\t * string starting with `0x` =====> object id\n\t * number, bigint ====> u64\n\t * boolean =====> bool\n\t *\n\t *\n\t * If type is provided, we will use the type to convert the array\n\t * @param args\n\t * @param type 'address' | 'bool' | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'u256' | 'object'\n", " */\n\texport function makeVecParam(\n\t  txBlock: TransactionBlock,\n\t  args: SuiTxArg[],\n\t  type?: SuiInputTypes\n\t) {\n\t  if (args.length === 0)\n\t    throw new Error('Transaction builder error: Empty array is not allowed');\n\t  const defaultSuiType = getDefaultSuiInputType(args[0]);\n\t  if (type === 'object' || (!type && defaultSuiType === 'object')) {\n", "    const objects = args.map((arg) =>\n\t      typeof arg === 'string'\n\t        ? txBlock.object(normalizeSuiObjectId(arg))\n\t        : (arg as any)\n\t    );\n\t    return txBlock.makeMoveVec({ objects });\n\t  } else {\n\t    const vecType = type || defaultSuiType;\n\t    return txBlock.pure(args, `vector<${vecType}>`);\n\t  }\n", "}\n\texport function isMoveVecArg(arg: any) {\n\t  const isFullMoveVecArg =\n\t    arg && arg.value && Array.isArray(arg.value) && arg.vecType;\n\t  const isSimpleMoveVecArg = Array.isArray(arg);\n\t  return isFullMoveVecArg || isSimpleMoveVecArg;\n\t}\n\texport function convertArgs(\n\t  txBlock: TransactionBlock,\n\t  args: any[]\n", "): TransactionArgument[] {\n\t  return args.map((arg) => {\n\t    if (typeof arg === 'string' && arg.startsWith('0x')) {\n\t      // We always treat string starting with `0x` as object id\n\t      return txBlock.object(normalizeSuiObjectId(arg));\n\t    } else if (isMoveVecArg(arg)) {\n\t      // if it's an array arg, we will convert it to move vec\n\t      const vecType = arg.vecType || undefined;\n\t      return vecType\n\t        ? makeVecParam(txBlock, arg.value, vecType)\n", "        : makeVecParam(txBlock, arg);\n\t    } else if (typeof arg !== 'object') {\n\t      // Other basic types such as string, number, boolean are converted to pure value\n\t      return txBlock.pure(arg);\n\t    } else {\n\t      // We do nothing, because it's most likely already a move value\n\t      return arg;\n\t    }\n\t  });\n\t}\n"]}
{"filename": "src/libs/suiModel/suiOwnedObject.ts", "chunked_list": ["import { Infer } from 'superstruct';\n\timport {\n\t  getObjectChanges,\n\t  SuiTransactionBlockResponse,\n\t  ObjectCallArg,\n\t  ObjectId,\n\t} from '@mysten/sui.js';\n\texport class SuiOwnedObject {\n\t  public readonly objectId: string;\n\t  public version?: number | string;\n", "  public digest?: string;\n\t  constructor(param: { objectId: string; version?: string; digest?: string }) {\n\t    this.objectId = param.objectId;\n\t    this.version = param.version;\n\t    this.digest = param.digest;\n\t  }\n\t  /**\n\t   * Check if the object is fully initialized.\n\t   * So that when it's used as an input, it won't be necessary to fetch from fullnode again.\n\t   * Which can save time when sending transactions.\n", "   */\n\t  isFullObject(): boolean {\n\t    return !!this.version && !!this.digest;\n\t  }\n\t  asCallArg(): Infer<typeof ObjectCallArg> | Infer<typeof ObjectId> {\n\t    if (!this.version || !this.digest) {\n\t      return this.objectId;\n\t    }\n\t    return {\n\t      Object: {\n", "        ImmOrOwned: {\n\t          objectId: this.objectId,\n\t          version: this.version,\n\t          digest: this.digest,\n\t        },\n\t      },\n\t    };\n\t  }\n\t  /**\n\t   * Update object version & digest based on the transaction response.\n", "   * @param txResponse\n\t   */\n\t  updateFromTxResponse(txResponse: SuiTransactionBlockResponse) {\n\t    const changes = getObjectChanges(txResponse);\n\t    if (!changes) {\n\t      throw new Error('Bad transaction response!');\n\t    }\n\t    for (const change of changes) {\n\t      if (change.type === 'mutated' && change.objectId === this.objectId) {\n\t        this.digest = change.digest;\n", "        this.version = change.version;\n\t        return;\n\t      }\n\t    }\n\t    throw new Error('Could not find object in transaction response!');\n\t  }\n\t}\n"]}
{"filename": "src/libs/suiModel/index.ts", "chunked_list": ["export { SuiOwnedObject } from './suiOwnedObject';\n\texport { SuiSharedObject } from './suiSharedObject';\n"]}
{"filename": "src/libs/suiModel/suiSharedObject.ts", "chunked_list": ["import { Infer } from 'superstruct';\n\timport { ObjectCallArg, ObjectId } from '@mysten/sui.js';\n\texport class SuiSharedObject {\n\t  public readonly objectId: string;\n\t  public initialSharedVersion?: number | string;\n\t  constructor(param: {\n\t    objectId: string;\n\t    initialSharedVersion?: number;\n\t    mutable?: boolean;\n\t  }) {\n", "    this.objectId = param.objectId;\n\t    this.initialSharedVersion = param.initialSharedVersion;\n\t  }\n\t  asCallArg(\n\t    mutable: boolean = false\n\t  ): Infer<typeof ObjectCallArg> | Infer<typeof ObjectId> {\n\t    if (!this.initialSharedVersion) {\n\t      return this.objectId;\n\t    }\n\t    return {\n", "      Object: {\n\t        Shared: {\n\t          objectId: this.objectId,\n\t          initialSharedVersion: this.initialSharedVersion,\n\t          mutable,\n\t        },\n\t      },\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/libs/suiAccountManager/keypair.ts", "chunked_list": ["import { Ed25519Keypair } from '@mysten/sui.js';\n\timport type { DerivePathParams } from 'src/types';\n\t/**\n\t * @description Get ed25519 derive path for SUI\n\t * @param derivePathParams\n\t */\n\texport const getDerivePathForSUI = (\n\t  derivePathParams: DerivePathParams = {}\n\t) => {\n\t  const {\n", "    accountIndex = 0,\n\t    isExternal = false,\n\t    addressIndex = 0,\n\t  } = derivePathParams;\n\t  return `m/44'/784'/${accountIndex}'/${isExternal ? 1 : 0}'/${addressIndex}'`;\n\t};\n\t/**\n\t * the format is m/44'/784'/accountIndex'/${isExternal ? 1 : 0}'/addressIndex'\n\t *\n\t * accountIndex is the index of the account, default is 0.\n", " *\n\t * isExternal is the type of the address, default is false. Usually, the external address is used to receive coins. The internal address is used to change coins.\n\t *\n\t * addressIndex is the index of the address, default is 0. It's used to generate multiple addresses for one account.\n\t *\n\t * @description Get keypair from mnemonics and derive path\n\t * @param mnemonics\n\t * @param derivePathParams\n\t */\n\texport const getKeyPair = (\n", "  mnemonics: string,\n\t  derivePathParams: DerivePathParams = {}\n\t) => {\n\t  const derivePath = getDerivePathForSUI(derivePathParams);\n\t  return Ed25519Keypair.deriveKeypair(mnemonics, derivePath);\n\t};\n"]}
{"filename": "src/libs/suiAccountManager/crypto.ts", "chunked_list": ["import { generateMnemonic as genMnemonic } from '@scure/bip39';\n\timport { wordlist } from '@scure/bip39/wordlists/english';\n\texport const generateMnemonic = (numberOfWords: 12 | 24 = 24) => {\n\t  const strength = numberOfWords === 12 ? 128 : 256;\n\t  return genMnemonic(wordlist, strength);\n\t};\n"]}
{"filename": "src/libs/suiAccountManager/index.ts", "chunked_list": ["import { Ed25519Keypair } from '@mysten/sui.js';\n\timport { getKeyPair } from './keypair';\n\timport { hexOrBase64ToUint8Array, normalizePrivateKey } from './util';\n\timport { generateMnemonic } from './crypto';\n\timport type { AccountMangerParams, DerivePathParams } from 'src/types';\n\texport class SuiAccountManager {\n\t  private mnemonics: string;\n\t  private secretKey: string;\n\t  public currentKeyPair: Ed25519Keypair;\n\t  public currentAddress: string;\n", "  /**\n\t   * Support the following ways to init the SuiToolkit:\n\t   * 1. mnemonics\n\t   * 2. secretKey (base64 or hex)\n\t   * If none of them is provided, will generate a random mnemonics with 24 words.\n\t   *\n\t   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n\t   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored\n\t   */\n\t  constructor({ mnemonics, secretKey }: AccountMangerParams = {}) {\n", "    // If the mnemonics or secretKey is provided, use it\n\t    // Otherwise, generate a random mnemonics with 24 words\n\t    this.mnemonics = mnemonics || '';\n\t    this.secretKey = secretKey || '';\n\t    if (!this.mnemonics && !this.secretKey) {\n\t      this.mnemonics = generateMnemonic(24);\n\t    }\n\t    // Init the current account\n\t    this.currentKeyPair = this.secretKey\n\t      ? Ed25519Keypair.fromSecretKey(\n", "          normalizePrivateKey(hexOrBase64ToUint8Array(this.secretKey))\n\t        )\n\t      : getKeyPair(this.mnemonics);\n\t    this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();\n\t  }\n\t  /**\n\t   * if derivePathParams is not provided or mnemonics is empty, it will return the currentKeyPair.\n\t   * else:\n\t   * it will generate keyPair from the mnemonic with the given derivePathParams.\n\t   */\n", "  getKeyPair(derivePathParams?: DerivePathParams) {\n\t    if (!derivePathParams || !this.mnemonics) return this.currentKeyPair;\n\t    return getKeyPair(this.mnemonics, derivePathParams);\n\t  }\n\t  /**\n\t   * if derivePathParams is not provided or mnemonics is empty, it will return the currentAddress.\n\t   * else:\n\t   * it will generate address from the mnemonic with the given derivePathParams.\n\t   */\n\t  getAddress(derivePathParams?: DerivePathParams) {\n", "    if (!derivePathParams || !this.mnemonics) return this.currentAddress;\n\t    return getKeyPair(this.mnemonics, derivePathParams)\n\t      .getPublicKey()\n\t      .toSuiAddress();\n\t  }\n\t  /**\n\t   * Switch the current account with the given derivePathParams.\n\t   * This is only useful when the mnemonics is provided. For secretKey mode, it will always use the same account.\n\t   */\n\t  switchAccount(derivePathParams: DerivePathParams) {\n", "    if (this.mnemonics) {\n\t      this.currentKeyPair = getKeyPair(this.mnemonics, derivePathParams);\n\t      this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/libs/suiAccountManager/util.ts", "chunked_list": ["import { fromB64 } from '@mysten/sui.js';\n\t/**\n\t * @description This regular expression matches any string that contains only hexadecimal digits (0-9, A-F, a-f).\n\t * @param str\n\t */\n\texport const isHex = (str: string) =>\n\t  /^0x[0-9a-fA-F]+$|^[0-9a-fA-F]+$/.test(str);\n\t/**\n\t * @description This regular expression matches any string that contains only base64 digits (0-9, A-Z, a-z, +, /, =).\n\t * Note that the \"=\" signs at the end are optional padding characters that may be present in some base64 encoded strings.\n", " * @param str\n\t */\n\texport const isBase64 = (str: string) => /^[a-zA-Z0-9+/]+={0,2}$/g.test(str);\n\t/**\n\t * Convert a hex string to Uint8Array\n\t * @param hexStr\n\t */\n\texport const fromHEX = (hexStr: string): Uint8Array => {\n\t  if (!hexStr) {\n\t    throw new Error('cannot parse empty string to Uint8Array');\n", "  }\n\t  const intArr = hexStr\n\t    .replace('0x', '')\n\t    .match(/.{1,2}/g)\n\t    ?.map((byte) => parseInt(byte, 16));\n\t  if (!intArr || intArr.length === 0) {\n\t    throw new Error(`Unable to parse HEX: ${hexStr}`);\n\t  }\n\t  return Uint8Array.from(intArr);\n\t};\n", "/**\n\t * @description Convert a hex or base64 string to Uint8Array\n\t */\n\texport const hexOrBase64ToUint8Array = (str: string): Uint8Array => {\n\t  if (isHex(str)) {\n\t    return fromHEX(str);\n\t  } else if (isBase64(str)) {\n\t    return fromB64(str);\n\t  } else {\n\t    throw new Error('The string is not a valid hex or base64 string.');\n", "  }\n\t};\n\tconst PRIVATE_KEY_SIZE = 32;\n\tconst LEGACY_PRIVATE_KEY_SIZE = 64;\n\t/**\n\t * normalize a private key\n\t * A private key is a 32-byte array.\n\t * But there are two different formats for private keys:\n\t * 1. A 32-byte array\n\t * 2. A 64-byte array with the first 32 bytes being the private key and the last 32 bytes being the public key\n", " * 3. A 33-byte array with the first byte being 0x00 (sui.keystore key is a Base64 string with scheme flag 0x00 at the beginning)\n\t */\n\texport const normalizePrivateKey = (key: Uint8Array): Uint8Array => {\n\t  if (key.length === LEGACY_PRIVATE_KEY_SIZE) {\n\t    // This is a legacy secret key, we need to strip the public key bytes and only read the first 32 bytes\n\t    key = key.slice(0, PRIVATE_KEY_SIZE);\n\t  } else if (key.length === PRIVATE_KEY_SIZE + 1 && key[0] === 0) {\n\t    // sui.keystore key is a Base64 string with scheme flag 0x00 at the beginning\n\t    return key.slice(1);\n\t  } else if (key.length === PRIVATE_KEY_SIZE) {\n", "    return key;\n\t  }\n\t  throw new Error('invalid secret key');\n\t};\n"]}
{"filename": "src/types/index.ts", "chunked_list": ["import { Infer } from 'superstruct';\n\timport {\n\t  DisplayFieldsResponse,\n\t  ObjectCallArg,\n\t  ObjectContentFields,\n\t  SharedObjectRef,\n\t  SuiObjectRef,\n\t  TransactionArgument,\n\t} from '@mysten/sui.js';\n\texport type AccountMangerParams = {\n", "  mnemonics?: string;\n\t  secretKey?: string;\n\t};\n\texport type DerivePathParams = {\n\t  accountIndex?: number;\n\t  isExternal?: boolean;\n\t  addressIndex?: number;\n\t};\n\texport type NetworkType = 'testnet' | 'mainnet' | 'devnet' | 'localnet';\n\texport type SuiKitParams = {\n", "  mnemonics?: string;\n\t  secretKey?: string;\n\t  fullnodeUrls?: string[];\n\t  faucetUrl?: string;\n\t  networkType?: NetworkType;\n\t};\n\texport type ObjectData = {\n\t  objectId: string;\n\t  objectType: string;\n\t  objectVersion: number;\n", "  objectDigest: string;\n\t  initialSharedVersion?: number;\n\t  objectDisplay: DisplayFieldsResponse;\n\t  objectFields: ObjectContentFields;\n\t};\n\texport type SuiTxArg =\n\t  | Infer<typeof TransactionArgument>\n\t  | Infer<typeof ObjectCallArg>\n\t  | string\n\t  | number\n", "  | bigint\n\t  | boolean;\n\texport type SuiObjectArg =\n\t  | SharedObjectRef\n\t  | Infer<typeof SuiObjectRef>\n\t  | string\n\t  | Infer<typeof ObjectCallArg>\n\t  | Infer<typeof TransactionArgument>;\n\texport type SuiVecTxArg =\n\t  | { value: SuiTxArg[]; vecType: SuiInputTypes }\n", "  | SuiTxArg[];\n\t/**\n\t * These are the basics types that can be used in the SUI\n\t */\n\texport type SuiBasicTypes =\n\t  | 'address'\n\t  | 'bool'\n\t  | 'u8'\n\t  | 'u16'\n\t  | 'u32'\n", "  | 'u64'\n\t  | 'u128'\n\t  | 'u256';\n\texport type SuiInputTypes = 'object' | SuiBasicTypes;\n"]}
