{"filename": "src/Watchman.service.ts", "chunked_list": ["import { HttpStatus, Injectable } from '@nestjs/common';\n\timport { Request, Response } from 'express';\n\timport { BaseStrategy } from './strategies';\n\timport {\n\t  IException,\n\t  WatchData,\n\t  WatchmanModuleOptions,\n\t  WatchMetaData,\n\t} from './interfaces';\n\t@Injectable()\n", "export class WatchmanService {\n\t  constructor(\n\t    private options: Partial<WatchmanModuleOptions>,\n\t    private strategy: BaseStrategy,\n\t  ) {}\n\t  public setStrategy(strategy: BaseStrategy) {\n\t    this.strategy = strategy;\n\t  }\n\t  public watch(exception: IException, data: WatchData): void {\n\t    const { host, trackUUID, metaData } = data;\n", "    let _host: WatchMetaData = null;\n\t    if (host) {\n\t      const ctx = host.switchToHttp();\n\t      _host = {\n\t        request: ctx.getRequest<Request>(),\n\t        response: ctx.getResponse<Response>(),\n\t      };\n\t    }\n\t    const status =\n\t      'getStatus' in exception\n", "        ? exception.getStatus()\n\t        : HttpStatus.INTERNAL_SERVER_ERROR;\n\t    if (trackUUID) exception.uuid = trackUUID;\n\t    if (status === HttpStatus.INTERNAL_SERVER_ERROR)\n\t      return this.strategy.execute(exception, status, _host, metaData);\n\t    if (this.options && this.options.catchOnlyInternalExceptions) return;\n\t    return this.strategy.execute(exception, status, _host, metaData);\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './Watchman.module';\n\texport * from './Watchman.service';\n\texport * from './strategies/export.strategy';\n\texport * from './interfaces';\n\texport * from './constants';\n"]}
{"filename": "src/Watchman.module.ts", "chunked_list": ["import { HttpModule } from '@nestjs/axios';\n\timport { DynamicModule, Module, Provider, Type } from '@nestjs/common';\n\timport { WatchmanService } from './Watchman.service';\n\timport {\n\t  WatchmanModuleAsyncOptions,\n\t  WatchmanModuleFactory,\n\t  WatchmanModuleOptions,\n\t} from './interfaces';\n\timport { STRATEGY_TOKEN, Watchman_OPTIONS } from './constants';\n\timport {\n", "  BaseStrategy,\n\t  injectStrategies,\n\t  strategyDependenciesProviders,\n\t  strategyProviders,\n\t} from './strategies';\n\t@Module({})\n\texport class WatchmanModule {\n\t  static forRoot(option: WatchmanModuleOptions): DynamicModule {\n\t    const provider: Provider<any> = {\n\t      provide: WatchmanService,\n", "      useFactory: (config: WatchmanModuleOptions, ...args: BaseStrategy[]) => {\n\t        if (!option.strategy) throw new Error('Please Provide Strategy class');\n\t        const loadedStrategy = args.find(\n\t          (injectedStrategy) =>\n\t            injectedStrategy && injectedStrategy instanceof option.strategy,\n\t        );\n\t        if (!config.strategyConfig)\n\t          throw new Error('Please set your config in strategyConfig object');\n\t        return new WatchmanService(config, loadedStrategy);\n\t      },\n", "      inject: [Watchman_OPTIONS, ...injectStrategies],\n\t    };\n\t    return {\n\t      providers: [\n\t        provider,\n\t        { provide: Watchman_OPTIONS, useValue: option },\n\t        ...strategyDependenciesProviders,\n\t        ...strategyProviders,\n\t      ],\n\t      exports: [provider],\n", "      module: WatchmanModule,\n\t      imports: [HttpModule],\n\t    };\n\t  }\n\t  static forRootAsync(options: WatchmanModuleAsyncOptions): DynamicModule {\n\t    const provider: Provider = {\n\t      provide: WatchmanService,\n\t      useFactory: async (\n\t        config: WatchmanModuleOptions,\n\t        ...args: BaseStrategy[]\n", "      ) => {\n\t        const strategy = options.strategy || config.strategy;\n\t        if (!strategy) throw new Error('Please Provide Strategy class');\n\t        const loadedStrategy = args.find(\n\t          (injectedStrategy) =>\n\t            injectedStrategy && injectedStrategy instanceof strategy,\n\t        );\n\t        if (!options.strategy) {\n\t          if (!config.strategyConfig)\n\t            throw new Error('Please set your config in strategyConfig object');\n", "        }\n\t        return new WatchmanService(config, loadedStrategy);\n\t      },\n\t      inject: [\n\t        { token: Watchman_OPTIONS, optional: true },\n\t        { token: STRATEGY_TOKEN, optional: true },\n\t        ...injectStrategies,\n\t      ],\n\t    };\n\t    return {\n", "      module: WatchmanModule,\n\t      imports: [...(options.imports || []), HttpModule],\n\t      providers: [\n\t        ...this.createAsyncProviders(options),\n\t        provider,\n\t        ...strategyProviders,\n\t        ...strategyDependenciesProviders,\n\t        {\n\t          provide: STRATEGY_TOKEN,\n\t          useClass: options.strategy,\n", "        },\n\t      ],\n\t      exports: [provider],\n\t    };\n\t  }\n\t  private static createAsyncProviders(\n\t    options: WatchmanModuleAsyncOptions,\n\t  ): Provider[] {\n\t    if (options.useExisting || options.useFactory) {\n\t      return [this.createAsyncOptionsProvider(options)];\n", "    }\n\t    const useClass = options.useClass as Type<WatchmanModuleFactory>;\n\t    if (useClass)\n\t      return [\n\t        this.createAsyncOptionsProvider(options),\n\t        {\n\t          provide: useClass,\n\t          useClass,\n\t        },\n\t      ];\n", "    return [\n\t      {\n\t        provide: Watchman_OPTIONS,\n\t        useValue: null,\n\t      },\n\t    ];\n\t  }\n\t  private static createAsyncOptionsProvider(\n\t    options: WatchmanModuleAsyncOptions,\n\t  ): Provider {\n", "    if (options.useFactory) {\n\t      return {\n\t        provide: Watchman_OPTIONS,\n\t        useFactory: options.useFactory,\n\t        inject: options.inject || [],\n\t      };\n\t    }\n\t    const inject = [\n\t      (options.useClass || options.useExisting) as Type<WatchmanModuleFactory>,\n\t    ];\n", "    return {\n\t      provide: Watchman_OPTIONS,\n\t      useFactory: async (optionsFactory: WatchmanModuleFactory) =>\n\t        await optionsFactory.createWatchmanModuleOptions(),\n\t      inject,\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/strategies/export.strategy.ts", "chunked_list": ["export * from './discord.strategy';\n"]}
{"filename": "src/strategies/base.strategy.ts", "chunked_list": ["import { Request, Response } from 'express';\n\timport { Inject } from '@nestjs/common';\n\timport { Watchman_OPTIONS } from '../constants';\n\timport {\n\t  DiscordConfig,\n\t  IException,\n\t  WatchmanModuleOptions,\n\t  WatchMetaData,\n\t} from '../interfaces';\n\ttype StrategyConfig = WatchmanModuleOptions['strategyConfig'];\n", "export abstract class BaseStrategy {\n\t  private _statusCode: number;\n\t  private _exception: IException;\n\t  private _request: Request;\n\t  private _response: Response;\n\t  private _filePath: string;\n\t  private _fileName: string;\n\t  private _metaData: any;\n\t  private strategyConfig: StrategyConfig;\n\t  @Inject(Watchman_OPTIONS)\n", "  private _options: WatchmanModuleOptions = {\n\t    strategyConfig: null,\n\t    catchOnlyInternalExceptions: false,\n\t  };\n\t  execute(\n\t    exception: IException,\n\t    statusCode: number,\n\t    host: WatchMetaData,\n\t    metaDta: any,\n\t  ): void {\n", "    {\n\t      this._statusCode = statusCode || null;\n\t      this._exception = exception || null;\n\t      this._request = host?.request || null;\n\t      this._response = host?.response || null;\n\t      this._metaData = metaDta || null;\n\t      this._filePath = this.extractErrorPath(this._exception.stack);\n\t      this._fileName =\n\t        this._filePath && this.extractErrorFileNameFromPath(this._filePath);\n\t      let message;\n", "      if (!!host) message = this.withHostMessageFormat();\n\t      else message = this.simpleMessageFormat();\n\t      this.send(message);\n\t    }\n\t  }\n\t  get statusCode(): number {\n\t    return this._statusCode;\n\t  }\n\t  get exception(): IException {\n\t    return this._exception;\n", "  }\n\t  get metaData(): any {\n\t    return this._metaData;\n\t  }\n\t  get request(): Request {\n\t    return this._request;\n\t  }\n\t  get response(): Response {\n\t    return this._response;\n\t  }\n", "  get filePath(): string {\n\t    return this._filePath;\n\t  }\n\t  get fileName(): string {\n\t    return this._fileName;\n\t  }\n\t  get config(): StrategyConfig {\n\t    if (!this.strategyConfig) return this._options.strategyConfig;\n\t    return this.strategyConfig;\n\t  }\n", "  set config(config: StrategyConfig) {\n\t    this.strategyConfig = config;\n\t  }\n\t  private extractErrorFileNameFromPath(path: string): string | null {\n\t    return (\n\t      path\n\t        .slice(path.lastIndexOf('/'))\n\t        .replace('/', '')\n\t        .replace(/\\(|\\)/gi, '') || null\n\t    );\n", "  }\n\t  private extractErrorPath(errorStack: string): string | null {\n\t    errorStack = errorStack.slice(errorStack.indexOf('\\n'));\n\t    const firstIndex = errorStack.indexOf('/');\n\t    const nextIndex = errorStack.indexOf('\\n', errorStack.indexOf('/'));\n\t    const path = errorStack.slice(firstIndex, nextIndex);\n\t    const uselessPaths = path.match(\n\t      /node_modules|internal|streams|stream_base_commons|task_queues/gi,\n\t    );\n\t    if (uselessPaths && uselessPaths.length) {\n", "      return this.extractErrorPath(errorStack.slice(nextIndex));\n\t    }\n\t    return path || null;\n\t  }\n\t  abstract send(messageBody): unknown;\n\t  abstract withHostMessageFormat(): unknown;\n\t  abstract simpleMessageFormat(): unknown;\n\t}\n"]}
{"filename": "src/strategies/discord.strategy.ts", "chunked_list": ["import { HttpService } from '@nestjs/axios';\n\timport { Inject, Injectable, Optional } from '@nestjs/common';\n\timport { Subscription } from 'rxjs';\n\timport { EmbedBuilder } from 'discord.js';\n\timport { BaseStrategy } from './base.strategy';\n\timport { DiscordConfig, IDiscordBody } from '../interfaces';\n\t@Injectable()\n\texport class DiscordBaseStrategy extends BaseStrategy {\n\t  @Inject()\n\t  private httpService: HttpService;\n", "  @Inject(EmbedBuilder.name)\n\t  embedBuilder: EmbedBuilder;\n\t  constructor(@Optional() discordConfig?: DiscordConfig) {\n\t    super();\n\t    if (discordConfig) this.config = discordConfig;\n\t  }\n\t  send(discordBody: IDiscordBody): Subscription {\n\t    return this.httpService\n\t      .post(this.config.webHookUrl, discordBody)\n\t      .subscribe();\n", "  }\n\t  private mention(mentionList: Array<'here' | 'everyone' | string>): string {\n\t    return mentionList\n\t      .map((person) =>\n\t        person === 'here' || person === 'everyone'\n\t          ? `@${person}`\n\t          : `<@${person}>`,\n\t      )\n\t      .join(', ');\n\t  }\n", "  withHostMessageFormat(): IDiscordBody {\n\t    const embed = this.embedBuilder\n\t      .setColor(0xff0000)\n\t      .setTitle(this.exception.name)\n\t      .setFields(\n\t        {\n\t          name: 'Occurred In',\n\t          value: this.fileName || 'ExceptionHandler',\n\t        },\n\t        {\n", "          name: 'Route',\n\t          value: this.request.path,\n\t          inline: true,\n\t        },\n\t        {\n\t          name: 'Http Method',\n\t          value: this.request.method,\n\t          inline: true,\n\t        },\n\t        {\n", "          name: 'Trace',\n\t          value: this.exception?.stack.slice(0, 1020) + '...',\n\t        },\n\t      )\n\t      .setTimestamp()\n\t      .setFooter({\n\t        text: 'Happened At ',\n\t        iconURL: 'https://i.imgur.com/AfFp7pu.png',\n\t      });\n\t    if (this.exception.uuid)\n", "      embed.addFields({ name: 'Tracking Id', value: this.exception.uuid });\n\t    const discordBody: IDiscordBody = {\n\t      embeds: [embed],\n\t    };\n\t    if (this.config.mentionList && this.config.mentionList.length)\n\t      discordBody.content = this.mention(this.config.mentionList);\n\t    return discordBody;\n\t  }\n\t  simpleMessageFormat(): IDiscordBody {\n\t    /**\n", "     * @see {@link https://discordjs.guide/popular-topics/embeds.html#embed-preview}\n\t     * **/\n\t    const embed = this.embedBuilder\n\t      .setColor(0xff0000)\n\t      .setTitle(this.exception.name)\n\t      .setFields(\n\t        {\n\t          name: 'Occurred In',\n\t          value: this.fileName || 'ExceptionHandler',\n\t        },\n", "        {\n\t          name: 'Trace',\n\t          value: this.exception?.stack.slice(0, 1020) + '...',\n\t        },\n\t      )\n\t      .setTimestamp()\n\t      .setFooter({\n\t        text: 'Happened At ',\n\t        iconURL: 'https://i.imgur.com/AfFp7pu.png',\n\t      });\n", "    if (this.exception.uuid)\n\t      embed.addFields({ name: 'Tracking Id', value: this.exception.uuid });\n\t    const discordBody: IDiscordBody = {\n\t      embeds: [embed],\n\t    };\n\t    if (this.config.mentionList && this.config.mentionList.length)\n\t      discordBody.content = this.mention(this.config.mentionList);\n\t    return discordBody;\n\t  }\n\t}\n"]}
{"filename": "src/strategies/index.ts", "chunked_list": ["import {\n\t  InjectionToken,\n\t  OptionalFactoryDependency,\n\t  Provider,\n\t} from '@nestjs/common';\n\timport { DiscordBaseStrategy } from './discord.strategy';\n\timport { BaseStrategy } from './base.strategy';\n\timport { EmbedBuilder } from 'discord.js';\n\t// export from here to access locally\n\texport { DiscordBaseStrategy, BaseStrategy };\n", "export const injectStrategies: Array<\n\t  InjectionToken | OptionalFactoryDependency\n\t> = [DiscordBaseStrategy];\n\texport const strategyProviders: Array<Provider<any>> = [DiscordBaseStrategy];\n\texport const strategyDependenciesProviders: Array<Provider<any>> = [\n\t  {\n\t    provide: EmbedBuilder.name,\n\t    useClass: EmbedBuilder,\n\t  },\n\t];\n"]}
{"filename": "src/constants/provider-names.ts", "chunked_list": ["export const Watchman_OPTIONS = 'WatchmanOptions';\n\texport const STRATEGY_TOKEN = 'STRATEGY';\n"]}
{"filename": "src/constants/index.ts", "chunked_list": ["export * from './provider-names';\n"]}
{"filename": "src/interfaces/module.interface.ts", "chunked_list": ["import { ArgumentsHost, ModuleMetadata, Type } from '@nestjs/common';\n\timport { DiscordConfig } from './discord.interface';\n\timport { Request, Response } from 'express';\n\texport interface WatchmanModuleAsyncOptions\n\t  extends Pick<ModuleMetadata, 'imports'> {\n\t  strategy?: any;\n\t  inject?: any[];\n\t  useClass?: Type<WatchmanModuleFactory>;\n\t  useExisting?: Type<WatchmanModuleFactory>;\n\t  useFactory?: (\n", "    ...args: any[]\n\t  ) => Promise<WatchmanModuleOptions> | WatchmanModuleOptions;\n\t}\n\texport interface WatchmanModuleOptions {\n\t  /**\n\t   * @default false\n\t   * */\n\t  catchOnlyInternalExceptions?: boolean;\n\t  strategy?: any;\n\t  strategyConfig?: DiscordConfig;\n", "}\n\texport interface WatchmanModuleFactory {\n\t  createWatchmanModuleOptions: () =>\n\t    | Promise<WatchmanModuleOptions>\n\t    | WatchmanModuleOptions;\n\t}\n\texport interface WatchMetaData {\n\t  request: Request;\n\t  response: Response;\n\t}\n", "export interface WatchData {\n\t  host?: ArgumentsHost | null;\n\t  trackUUID?: string | null;\n\t  metaData?: any;\n\t}\n"]}
{"filename": "src/interfaces/discord.interface.ts", "chunked_list": ["import { EmbedBuilder } from '@discordjs/builders';\n\texport interface DiscordConfig {\n\t  webHookUrl: string;\n\t  /**\n\t   * @description you can use \"here\" and \"everyone\" to mention or set a userId or roleId to mention persons. note that don't pass @ in mention text\n\t   * @see  {@link https://support.discord.com/hc/en-us/articles/206346498-Where-can-I-find-my-User-Server-Message-ID- Where can I find my User OR Role ID}\n\t   * */\n\t  mentionList?: Array<'here' | 'everyone' | string>;\n\t}\n\texport interface IDiscordBody {\n", "  /**\n\t   * @description the message contents (up to 2000 characters)\n\t   */\n\t  content?: string;\n\t  /**\n\t   * @description override the default username of the webhook\n\t   */\n\t  username?: string;\n\t  /**\n\t   * @description override the default avatar of the webhook\n", "   */\n\t  avatar_url?: string;\n\t  /**\n\t   * @description true if this is a TTS message\n\t   */\n\t  tts?: boolean;\n\t  /**\n\t   * @description message can be generated in embeds\n\t   * @overview Array of up to 10 embed objects\n\t   * @see {@link https://discord.com/developers/docs/resources/channel#embed-object Embed Object Structure}\n", "   * @see {@link https://discordjs.guide/popular-topics/embeds.html#embed-preview How To Generate Embeds With EmbedBuilder Class}\n\t   */\n\t  embeds?: Array<EmbedBuilder | Embedded>;\n\t  /**\n\t   * @description allowed mentions for the message\n\t   * @type  allowed mention object\n\t   * @see {@link https://discord.com/developers/docs/resources/channel#allowed-mentions-objectallowed }\n\t   */\n\t  allowed_mentions?: AllowedMentions;\n\t  /**\n", "   * @description the components to include with the message\n\t   * @type  array of message component\n\t   * @see {@link https://discord.com/developers/docs/interactions/message-components#component-objectmessage }\n\t   */\n\t  components?: Array<string>;\n\t  /**\n\t   * @description the contents of the file being sent\n\t   * @type  file contents\n\t   */\n\t  files?: any;\n", "  /**\n\t   * @description JSON encoded body of non-file params\n\t   */\n\t  payload_json?: string;\n\t  /**\n\t   * @description attachment objects with filename and description\n\t   * @type  array of partial attachment objects\n\t   * @see {@link https://discord.com/developers/docs/resources/channel#attachment-objectattachment}\n\t   */\n\t  attachments?: any;\n", "}\n\tinterface AllowedMentions {\n\t  parse?: Array<Allowed_Mention_Types>; //\tarray of allowed mention types\tAn array of allowed mention types to parse from the content.\n\t  roles?: Array<string>; //\tlist of snowflakes\tArray of role_ids to mention (Max size of 100)\n\t  users?: Array<string>; //\tlist of snowflakes\tArray of user_ids to mention (Max size of 100)\n\t  replied_user?: boolean; //\tFor replies, whether to mention the author of the message being replied to (default false)\n\t}\n\tinterface Embedded {\n\t  title?: string; //\ttitle of embed\n\t  type?: 'rich'; //string\ttype of embed (always \"rich\" for webhook embeds)\n", "  description?: string; //\tdescription of embed\n\t  url?: string; //\turl of embed\n\t  timestamp?: string; //\tISO8601 timestamp of embed content\n\t  color?: number; //\tinteger\tcolor code of the embed\n\t  footer?: EmbeddedFooter; //\tembed footer object\tfooter information\n\t  image?: EmbeddedImage; //\tembed image object\timage information\n\t  thumbnail?: EmbeddedThumbnail; //\tembed thumbnail object\tthumbnail information\n\t  video?: any; //\tembed video object\tvideo information\n\t  provider?: EmbeddedProvider; //embed provider object\tprovider information\n\t  author?: any; //embed author object\tauthor information\n", "  fields?: Array<EmbeddedField>; //\tarray of embed field objects\tfields information\n\t}\n\tinterface EmbeddedField {\n\t  name: string; //\tname of the field\n\t  value: string; //\tvalue of the field\n\t  inline?: boolean; //whether or not this field should display inline\n\t}\n\tinterface EmbeddedProvider {\n\t  name?: string; //\tname of provider\n\t  url?: string; //\turl of provider\n", "}\n\tinterface EmbeddedThumbnail {\n\t  url: string; //source url of thumbnail (only supports http(s) and attachments)\n\t  proxy_url?: string; //a proxied url of the thumbnail\n\t  height?: number; //\theight of thumbnail\n\t  width?: number; //width of thumbnail\n\t}\n\tinterface EmbeddedImage {\n\t  url: string; //\tsource url of image (only supports http(s) and attachments)\n\t  proxy_url?: string; //\ta proxied url of the image\n", "  height?: number; //\theight of image\n\t  width?: number; //\twidth of image\n\t}\n\tinterface EmbeddedFooter {\n\t  text: string; //\tfooter text\n\t  icon_url?: string; //\turl of footer icon (only supports http(s) and attachments)\n\t  proxy_icon_url?: string; //a proxied url of footer icon\n\t}\n\texport enum Allowed_Mention_Types {\n\t  RoleMentions = 'roles', //\tControls role mentions\n", "  UserMentions = 'users', //\tControls user mentions\n\t  EveryoneMentions = 'everyone', //\tControls @everyone and @here mentions\n\t}\n"]}
{"filename": "src/interfaces/index.ts", "chunked_list": ["export * from './discord.interface';\n\texport * from './module.interface';\n\texport * from './watchman-service.inteface';\n"]}
{"filename": "src/interfaces/watchman-service.inteface.ts", "chunked_list": ["import { HttpException } from '@nestjs/common';\n\ttype UUID = { uuid?: string };\n\texport type IException = HttpException & UUID;\n"]}
