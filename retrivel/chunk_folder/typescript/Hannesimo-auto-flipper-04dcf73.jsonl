{"filename": "types/config.d.ts", "chunked_list": ["interface SESSIONS {\n\t    [key: string]: ColfSession\n\t}\n\tinterface Config {\n\t    INGAME_NAME: string\n\t    WEBHOOK_URL: string\n\t    FLIP_ACTION_DELAY: number\n\t    USE_COFL_CHAT: boolean\n\t    ENABLE_CONSOLE_INPUT: boolean\n\t    SESSIONS: SESSIONS\n", "    USE_WINDOW_SKIPS: boolean\n\t}\n\tinterface ColfSession {\n\t    id: string\n\t    expires: Date\n\t}\n"]}
{"filename": "types/fastWindowClick.d.ts", "chunked_list": ["interface FastWindowClicker {\n\t    clickPurchase(price: number, windowId: number): void\n\t    clickBedPurchase(price: number, windowId: number): void\n\t    clickConfirm(price: number, itemName: string, windowId: number): void\n\t    onAuctionWasAlreadyBought(): void\n\t    getLastWindowId(): number\n\t}\n"]}
{"filename": "types/webhook.d.ts", "chunked_list": ["interface Webhook {\n\t    content: string\n\t    username?: string\n\t    avatar_url: string\n\t    tts: boolean\n\t    embeds?: Array<Embed>\n\t}\n\tinterface Embed {\n\t    title: string\n\t    description?: string\n", "    url?: string\n\t    timestamp?: number\n\t    color?: number\n\t    footer?: EmbedFooter\n\t    image?: string\n\t    thumbnail?: EmbedThumbnail\n\t    author?: EmbedAuthor\n\t    fields?: Array<EmbedField>\n\t}\n\tinterface EmbedFooter {\n", "    text: string\n\t    icon_url?: string\n\t}\n\tinterface EmbedAuthor {\n\t    name: string\n\t    url?: string\n\t    icon_url?: string\n\t}\n\tinterface EmbedField {\n\t    name: string\n", "    value: string\n\t    inline: boolean\n\t}\n\tinterface EmbedThumbnail {\n\t    url: string\n\t    proxy_url?: string\n\t    height?: number\n\t    width?: number\n\t}\n"]}
{"filename": "types/autobuy.d.ts", "chunked_list": ["import { Bot } from 'mineflayer'\n\tinterface SellData {\n\t    price: number\n\t    slot: number\n\t    duration: number\n\t    itemName: string\n\t    id: string\n\t}\n\tinterface TradeData {\n\t    target: string\n", "    slots: number[]\n\t    coins: number\n\t}\n\tinterface SwapData {\n\t    profile: string\n\t}\n\tinterface Flip {\n\t    id: string\n\t    startingBid: number\n\t    purchaseAt: Date\n", "    itemName: string\n\t    target: number\n\t}\n\tinterface TextMessageData {\n\t    text: string\n\t}\n\tinterface MyBot extends Bot {\n\t    state?: 'purchasing' | 'selling' | 'claiming' | 'gracePeriod'\n\t    lastViewAuctionCommandForPurchase?: string\n\t    privacySettings?: any\n", "}\n"]}
{"filename": "src/swapProfileHandler.ts", "chunked_list": ["import { MyBot, SwapData } from '../types/autobuy'\n\timport { log } from './logger'\n\timport { clickWindow, getWindowTitle } from './utils'\n\texport async function swapProfile(bot: MyBot, data: SwapData) {\n\t    bot.setQuickBarSlot(8)\n\t    bot.activateItem()\n\t    bot.on('windowOpen', window => {\n\t        let title = getWindowTitle(window)\n\t        if (title == 'SkyBlock Menu') {\n\t            clickWindow(bot, 48)\n", "        }\n\t        if (title == 'Profile Management') {\n\t            let clickSlot\n\t            window.slots.forEach(item => {\n\t                if (item && (item.nbt.value as any).display.value.Name.value.includes((data as SwapData).profile)) clickSlot = item.slot\n\t            })\n\t            log('Clickslot is ' + clickSlot)\n\t            clickWindow(bot, clickSlot)\n\t        }\n\t        if (title.includes('Profile:')) {\n", "            clickWindow(bot, 11)\n\t            log('Successfully swapped profiles')\n\t        }\n\t    })\n\t}\n"]}
{"filename": "src/AFKHandler.ts", "chunked_list": ["import { ScoreBoard } from 'mineflayer'\n\timport { MyBot } from '../types/autobuy'\n\timport { printMcChatToConsole, log } from './logger'\n\timport { sleep } from './utils'\n\texport function initAFKHandler(bot: MyBot) {\n\t    let consecutiveTeleportAttempts = 0\n\t    registerCheckInverval()\n\t    function registerCheckInverval() {\n\t        setTimeout(async () => {\n\t            let teleportWasTried = await tryToTeleportToIsland(bot)\n", "            if (teleportWasTried) {\n\t                consecutiveTeleportAttempts++\n\t                log(`ConsecutiveTeleportAttemps: ${consecutiveTeleportAttempts}`)\n\t                registerCheckInverval()\n\t            } else {\n\t                consecutiveTeleportAttempts = 0\n\t                registerCheckInverval()\n\t            }\n\t        }, 10000 * (consecutiveTeleportAttempts + 1))\n\t    }\n", "}\n\texport async function tryToTeleportToIsland(bot: MyBot, delayBeforeTeleport = 5000) {\n\t    if (isLimbo(bot.scoreboard.sidebar)) {\n\t        await sleep(delayBeforeTeleport)\n\t        log('Bot seems to be in limbo. Sending \"/lobby\"')\n\t        printMcChatToConsole('§f[§4BAF§f]: §fYou seem to be in limbo.')\n\t        printMcChatToConsole('§f[§4BAF§f]: §fWarping back to lobby...')\n\t        bot.chat('/lobby')\n\t        return true\n\t    }\n", "    if (\n\t        !bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, '')).find(e => e.includes('Purse:') || e.includes('Piggy:'))\n\t    ) {\n\t        await sleep(delayBeforeTeleport)\n\t        log(`Bot seems to be in lobby (Sidebar title = ${bot.scoreboard.sidebar.title}). Sending \"/play sb\"`)\n\t        printMcChatToConsole('§f[§4BAF§f]: §fYou seem to be in the lobby.')\n\t        printMcChatToConsole('§f[§4BAF§f]: §fWarping back into skyblock...')\n\t        bot.chat('/play sb')\n\t        return true\n\t    }\n", "    let scoreboard = bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, ''))\n\t    if (!scoreboard.find(e => e.includes('Your Island'))) {\n\t        await sleep(delayBeforeTeleport)\n\t        log('Bot is not on island. Warping back')\n\t        log(bot.scoreboard)\n\t        printMcChatToConsole('§f[§4BAF§f]: §fYou seem to not be on your island.')\n\t        printMcChatToConsole('§f[§4BAF§f]: §fWarping back to island...')\n\t        bot.chat('/is')\n\t        return true\n\t    }\n", "    return false\n\t}\n\tfunction isLimbo(sidebar: ScoreBoard) {\n\t    let isLimbo = true\n\t    sidebar.items.forEach(item => {\n\t        if (item.displayName.getText(null).replace(item.name, '') !== '') {\n\t            isLimbo = false\n\t        }\n\t    })\n\t    return isLimbo\n", "}\n"]}
{"filename": "src/coflSessionManager.ts", "chunked_list": ["import { getConfigProperty, updatePersistentConfigProperty } from './configHelper'\n\timport crypto from 'crypto'\n\tconst SESSIONS_KEY = 'SESSIONS'\n\texport function getSessionId(username: string): string {\n\t    let sessions = getConfigProperty(SESSIONS_KEY) as SESSIONS\n\t    if (!sessions) {\n\t        sessions = {}\n\t        updatePersistentConfigProperty(SESSIONS_KEY, {})\n\t    }\n\t    if (!sessions[username]) {\n", "        sessions[username] = {\n\t            id: crypto.randomUUID(),\n\t            expires: new Date(new Date().getTime() + 1000 * 60 * 60 * 24 * 180)\n\t        }\n\t        updatePersistentConfigProperty(SESSIONS_KEY, sessions)\n\t    }\n\t    if (isExpired(sessions[username].expires)) {\n\t        delete sessions[username]\n\t        updatePersistentConfigProperty(SESSIONS_KEY, sessions)\n\t        return null\n", "    } else {\n\t        return sessions[username].id\n\t    }\n\t}\n\texport function isExpired(date: Date) {\n\t    return date.getTime() < new Date().getTime()\n\t}\n"]}
{"filename": "src/consoleHandler.ts", "chunked_list": ["import readline from 'readline'\n\timport { getConfigProperty } from './configHelper'\n\texport function setupConsoleInterface(ws: WebSocket) {\n\t    if (!getConfigProperty('ENABLE_CONSOLE_INPUT')) {\n\t        return\n\t    }\n\t    const rl = readline.createInterface({\n\t        input: process.stdin,\n\t        output: process.stdout\n\t    })\n", "    rl.on('line', input => {\n\t        if (input?.startsWith('/cofl') && input?.split(' ').length >= 2) {\n\t            let splits = input.split(' ')\n\t            splits.shift() // remove /cofl\n\t            let command = splits.shift()\n\t            ws.send(\n\t                JSON.stringify({\n\t                    type: command,\n\t                    data: `\"${splits.join(' ')}\"`\n\t                })\n", "            )\n\t        } else {\n\t            ws.send(\n\t                JSON.stringify({\n\t                    type: 'chat',\n\t                    data: `\"${input}\"`\n\t                })\n\t            )\n\t        }\n\t    })\n", "}\n"]}
{"filename": "src/ingameMessageHandler.ts", "chunked_list": ["import { MyBot } from '../types/autobuy'\n\timport { log, printMcChatToConsole } from './logger'\n\timport { clickWindow, getWindowTitle } from './utils'\n\timport { ChatMessage } from 'prismarine-chat'\n\timport { sendWebhookItemPurchased, sendWebhookItemSold } from './webhookHandler'\n\texport function registerIngameMessageHandler(bot: MyBot, wss: WebSocket) {\n\t    bot.on('message', (message: ChatMessage, type) => {\n\t        let text = message.getText(null)\n\t        if (type == 'chat') {\n\t            printMcChatToConsole(message.toAnsi())\n", "            if (text.startsWith('You purchased')) {\n\t                wss.send(\n\t                    JSON.stringify({\n\t                        type: 'uploadTab',\n\t                        data: JSON.stringify(Object.keys(bot.players).map(playername => bot.players[playername].displayName.getText(null)))\n\t                    })\n\t                )\n\t                wss.send(\n\t                    JSON.stringify({\n\t                        type: 'uploadScoreboard',\n", "                        data: JSON.stringify(bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, '')))\n\t                    })\n\t                )\n\t                claimPurchased(bot)\n\t                sendWebhookItemPurchased(text.split(' purchased ')[1].split(' for ')[0], text.split(' for ')[1].split(' coins!')[0])\n\t            }\n\t            if (text.startsWith('[Auction]') && text.includes('bought') && text.includes('for')) {\n\t                log('New item sold')\n\t                claimSoldItem(bot, text.split(' bought ')[1].split(' for ')[0])\n\t                sendWebhookItemSold(\n", "                    text.split(' bought ')[1].split(' for ')[0],\n\t                    text.split(' for ')[1].split(' coins')[0],\n\t                    text.split('[Auction] ')[1].split(' bought ')[0]\n\t                )\n\t            }\n\t            if (bot.privacySettings && bot.privacySettings.chatRegex.test(text)) {\n\t                wss.send(\n\t                    JSON.stringify({\n\t                        type: 'chatBatch',\n\t                        data: JSON.stringify([text])\n", "                    })\n\t                )\n\t            }\n\t        }\n\t    })\n\t}\n\tfunction claimPurchased(bot: MyBot) {\n\t    if (bot.state) {\n\t        log('Currently busy with something else (' + bot.state + ') -> not claiming purchased item')\n\t        setTimeout(() => {\n", "            claimPurchased(bot)\n\t        }, 1000)\n\t        return\n\t    }\n\t    bot.state = 'claiming'\n\t    bot.chat('/ah')\n\t    setTimeout(() => {\n\t        log('Claiming of purchased auction failed. Removing lock')\n\t        bot.state = null\n\t    }, 5000)\n", "    bot.on('windowOpen', window => {\n\t        let title = getWindowTitle(window)\n\t        log('Claiming auction window: ' + title)\n\t        if (title.toString().includes('Auction House')) {\n\t            clickWindow(bot, 13)\n\t        }\n\t        if (title.toString().includes('Your Bids')) {\n\t            let slotToClick = -1\n\t            for (let i = 0; i < window.slots.length; i++) {\n\t                const slot = window.slots[i]\n", "                let name = (slot?.nbt as any)?.value?.display?.value?.Name?.value?.toString()\n\t                if (slot?.type === 380 && name?.includes('Claim') && name?.includes('All')) {\n\t                    log('Found cauldron to claim all purchased auctions -> clicking index ' + i)\n\t                    clickWindow(bot, i)\n\t                    bot.removeAllListeners('windowOpen')\n\t                    bot.state = null\n\t                    return\n\t                }\n\t                let lore = (slot?.nbt as any)?.value?.display?.value?.Lore?.value?.value?.toString()\n\t                if (lore?.includes('Status:') && lore?.includes('Sold!')) {\n", "                    log('Found claimable purchased auction. Gonna click index ' + i)\n\t                    log(JSON.stringify(slot))\n\t                    slotToClick = i\n\t                }\n\t            }\n\t            clickWindow(bot, slotToClick)\n\t        }\n\t        if (title.toString().includes('BIN Auction View')) {\n\t            if (!window.slots[31]) {\n\t                log('Weird error trying to claim purchased auction', 'warn')\n", "                log(window.title)\n\t                log(JSON.stringify(window.slots))\n\t                bot.removeAllListeners('windowOpen')\n\t                bot.state = null\n\t                return\n\t            }\n\t            if (window.slots[31].name.includes('gold_block')) {\n\t                log('Claiming purchased auction...')\n\t                clickWindow(bot, 31)\n\t            }\n", "            bot.removeAllListeners('windowOpen')\n\t            bot.state = null\n\t        }\n\t    })\n\t}\n\tasync function claimSoldItem(bot: MyBot, itemName: string) {\n\t    if (bot.state) {\n\t        log('Currently busy with something else (' + bot.state + ') -> not claiming sold item')\n\t        setTimeout(() => {\n\t            claimSoldItem(bot, itemName)\n", "        }, 1000)\n\t        return\n\t    }\n\t    let timeout = setTimeout(() => {\n\t        log('Seems something went wrong while claiming sold item. Removing lock')\n\t        bot.state = null\n\t        bot.removeAllListeners('windowOpen')\n\t    }, 10000)\n\t    bot.state = 'claiming'\n\t    bot.chat('/ah')\n", "    bot.on('windowOpen', window => {\n\t        let title = getWindowTitle(window)\n\t        if (title.toString().includes('Auction House')) {\n\t            clickWindow(bot, 15)\n\t        }\n\t        if (title.toString().includes('Manage Auctions')) {\n\t            log('Claiming sold auction...')\n\t            let clickSlot\n\t            for (let i = 0; i < window.slots.length; i++) {\n\t                const item = window.slots[i] as any\n", "                if (item?.nbt?.value?.display?.value?.Lore && JSON.stringify(item.nbt.value.display.value.Lore).includes('Sold for')) {\n\t                    clickSlot = item.slot\n\t                }\n\t                if (item && item.type === 380 && (item.nbt as any).value?.display?.value?.Name?.value?.toString().includes('Claim All')) {\n\t                    log(item)\n\t                    log('Found cauldron to claim all sold auctions -> clicking index ' + item.slot)\n\t                    clickWindow(bot, item.slot)\n\t                    clearTimeout(timeout)\n\t                    bot.removeAllListeners('windowOpen')\n\t                    bot.state = null\n", "                    return\n\t                }\n\t            }\n\t            log('Clicking auction to claim, index: ' + clickSlot)\n\t            log(JSON.stringify(window.slots[clickSlot]))\n\t            clickWindow(bot, clickSlot)\n\t        }\n\t        if (title == 'BIN Auction View') {\n\t            if (window.slots[31].name.includes('gold_block')) {\n\t                log('Clicking slot 31, claiming purchased auction')\n", "                clickWindow(bot, 31)\n\t            }\n\t            clearTimeout(timeout)\n\t            bot.removeAllListeners('windowOpen')\n\t            bot.state = null\n\t        }\n\t    })\n\t}\n"]}
{"filename": "src/flipHandler.ts", "chunked_list": ["import { Flip, MyBot } from '../types/autobuy'\n\timport { getConfigProperty } from './configHelper'\n\timport { getFastWindowClicker } from './fastWindowClick'\n\timport { log, printMcChatToConsole } from './logger'\n\timport { clickWindow, getWindowTitle, numberWithThousandsSeparators, sleep } from './utils'\n\texport async function flipHandler(bot: MyBot, flip: Flip) {\n\t    flip.purchaseAt = new Date(flip.purchaseAt)\n\t    if (bot.state) {\n\t        setTimeout(() => {\n\t            flipHandler(bot, flip)\n", "        }, 1100)\n\t        return\n\t    }\n\t    bot.state = 'purchasing'\n\t    let timeout = setTimeout(() => {\n\t        if (bot.state === 'purchasing') {\n\t            log(\"Resetting 'bot.state === purchasing' lock\")\n\t            bot.state = null\n\t            bot.removeAllListeners('windowOpen')\n\t        }\n", "    }, 10000)\n\t    let isBed = flip.purchaseAt.getTime() > new Date().getTime()\n\t    let delayUntilBuyStart = isBed ? flip.purchaseAt.getTime() - new Date().getTime() : getConfigProperty('FLIP_ACTION_DELAY')\n\t    bot.lastViewAuctionCommandForPurchase = `/viewauction ${flip.id}`\n\t    await sleep(delayUntilBuyStart)\n\t    bot.chat(bot.lastViewAuctionCommandForPurchase)\n\t    printMcChatToConsole(\n\t        `§f[§4BAF§f]: §fTrying to purchase flip${isBed ? ' (Bed)' : ''}: ${flip.itemName} §for ${numberWithThousandsSeparators(\n\t            flip.startingBid\n\t        )} coins (Target: ${numberWithThousandsSeparators(flip.target)})`\n", "    )\n\t    if (getConfigProperty('USE_WINDOW_SKIPS')) {\n\t        useWindowSkipPurchase(flip, isBed)\n\t        // clear timeout after 1sec, so there are no weird overlaps that mess up the windowIds\n\t        setTimeout(() => {\n\t            bot.state = null\n\t            clearTimeout(timeout)\n\t        }, 2500)\n\t    } else {\n\t        useRegularPurchase(bot)\n", "    }\n\t}\n\tasync function useRegularPurchase(bot: MyBot) {\n\t    bot.addListener('windowOpen', async window => {\n\t        let title = getWindowTitle(window)\n\t        if (title.toString().includes('BIN Auction View')) {\n\t            await sleep(getConfigProperty('FLIP_ACTION_DELAY'))\n\t            clickWindow(bot, 31)\n\t        }\n\t        if (title.toString().includes('Confirm Purchase')) {\n", "            await sleep(getConfigProperty('FLIP_ACTION_DELAY'))\n\t            clickWindow(bot, 11)\n\t            bot.removeAllListeners('windowOpen')\n\t            bot.state = null\n\t            return\n\t        }\n\t    })\n\t}\n\tasync function useWindowSkipPurchase(flip: Flip, isBed: boolean) {\n\t    let lastWindowId = getFastWindowClicker().getLastWindowId()\n", "    if (isBed) {\n\t        getFastWindowClicker().clickBedPurchase(flip.startingBid, lastWindowId + 1)\n\t    } else {\n\t        getFastWindowClicker().clickPurchase(flip.startingBid, lastWindowId + 1)\n\t    }\n\t    await sleep(getConfigProperty('FLIP_ACTION_DELAY'))\n\t    getFastWindowClicker().clickConfirm(flip.startingBid, flip.itemName, lastWindowId + 2)\n\t}\n"]}
{"filename": "src/BAF.ts", "chunked_list": ["import { ScoreBoard } from 'mineflayer'\n\timport { createBot } from 'mineflayer'\n\timport { createFastWindowClicker } from './fastWindowClick'\n\timport { addLoggerToClientWriteFunction, initLogger, log, printMcChatToConsole } from './logger'\n\timport { clickWindow, isCoflChatMessage, removeMinecraftColorCodes, sleep } from './utils'\n\timport { onWebsocketCreateAuction } from './sellHandler'\n\timport { tradePerson } from './tradeHandler'\n\timport { swapProfile } from './swapProfileHandler'\n\timport { flipHandler } from './flipHandler'\n\timport { registerIngameMessageHandler } from './ingameMessageHandler'\n", "import { MyBot, TextMessageData } from '../types/autobuy'\n\timport { getConfigProperty, initConfigHelper, updatePersistentConfigProperty } from './configHelper'\n\timport { getSessionId } from './coflSessionManager'\n\timport { sendWebhookInitialized } from './webhookHandler'\n\timport { setupConsoleInterface } from './consoleHandler'\n\timport { initAFKHandler, tryToTeleportToIsland } from './AFKHandler'\n\tconst WebSocket = require('ws')\n\tvar prompt = require('prompt-sync')()\n\tinitConfigHelper()\n\tinitLogger()\n", "const version = '1.5.0-af'\n\tlet wss: WebSocket\n\tlet ingameName = getConfigProperty('INGAME_NAME')\n\tif (!ingameName) {\n\t    ingameName = prompt('Enter your ingame name: ')\n\t    updatePersistentConfigProperty('INGAME_NAME', ingameName)\n\t}\n\tconst bot: MyBot = createBot({\n\t    username: ingameName,\n\t    auth: 'microsoft',\n", "    logErrors: true,\n\t    version: '1.17',\n\t    host: 'mc.hypixel.net'\n\t})\n\tbot.setMaxListeners(0)\n\tbot.state = 'gracePeriod'\n\tcreateFastWindowClicker(bot._client)\n\tif (getConfigProperty('LOG_PACKAGES')) {\n\t    addLoggerToClientWriteFunction(bot._client)\n\t}\n", "bot.once('login', connectWebsocket)\n\tbot.once('spawn', async () => {\n\t    await bot.waitForChunksToLoad()\n\t    await sleep(2000)\n\t    bot.chat('/play sb')\n\t    bot.on('scoreboardTitleChanged', onScoreboardChanged)\n\t    registerIngameMessageHandler(bot, wss)\n\t})\n\tfunction connectWebsocket() {\n\t    wss = new WebSocket(`wss://sky.coflnet.com/modsocket?player=${ingameName}&version=${version}&SId=${getSessionId(ingameName)}`)\n", "    wss.onopen = function () {\n\t        setupConsoleInterface(wss)\n\t        sendWebhookInitialized()\n\t    }\n\t    wss.onmessage = onWebsocketMessage\n\t    wss.onclose = function (e) {\n\t        log('Connection closed. Reconnecting... ', 'warn')\n\t        setTimeout(function () {\n\t            connectWebsocket()\n\t        }, 1000)\n", "    }\n\t    wss.onerror = function (err) {\n\t        log('Connection error: ' + JSON.stringify(err), 'error')\n\t        wss.close()\n\t    }\n\t}\n\tasync function onWebsocketMessage(msg) {\n\t    let message = JSON.parse(msg.data)\n\t    let data = JSON.parse(message.data)\n\t    switch (message.type) {\n", "        case 'flip':\n\t            log(message, 'debug')\n\t            flipHandler(bot, data)\n\t            break\n\t        case 'chatMessage':\n\t            for (let da of [...(data as TextMessageData[])]) {\n\t                let isCoflChat = isCoflChatMessage(da.text)\n\t                if (!isCoflChat) {\n\t                    log(message, 'debug')\n\t                }\n", "                if (getConfigProperty('USE_COFL_CHAT') || !isCoflChat) {\n\t                    printMcChatToConsole(da.text)\n\t                }\n\t            }\n\t            break\n\t        case 'writeToChat':\n\t            let isCoflChat = isCoflChatMessage(data.text)\n\t            if (!isCoflChat) {\n\t                log(message, 'debug')\n\t            }\n", "            if (getConfigProperty('USE_COFL_CHAT') || !isCoflChat) {\n\t                printMcChatToConsole((data as TextMessageData).text)\n\t            }\n\t            break\n\t        case 'swapProfile':\n\t            log(message, 'debug')\n\t            swapProfile(bot, data)\n\t            break\n\t        case 'createAuction':\n\t            log(message, 'debug')\n", "            onWebsocketCreateAuction(bot, data)\n\t            break\n\t        case 'trade':\n\t            log(message, 'debug')\n\t            tradePerson(bot, wss, data)\n\t            break\n\t        case 'tradeResponse':\n\t            let tradeDisplay = (bot.currentWindow.slots[39].nbt.value as any).display.value.Name.value\n\t            if (tradeDisplay.includes('Deal!') || tradeDisplay.includes('Warning!')) {\n\t                await sleep(3400)\n", "            }\n\t            clickWindow(bot, 39)\n\t            break\n\t        case 'getInventory':\n\t            log('Uploading inventory...')\n\t            wss.send(\n\t                JSON.stringify({\n\t                    type: 'uploadInventory',\n\t                    data: JSON.stringify(bot.inventory)\n\t                })\n", "            )\n\t            break\n\t        case 'execute':\n\t            log(message, 'debug')\n\t            bot.chat(data)\n\t            break\n\t        case 'privacySettings':\n\t            log(message, 'debug')\n\t            data.chatRegex = new RegExp(data.chatRegex)\n\t            bot.privacySettings = data\n", "            break\n\t    }\n\t}\n\tasync function onScoreboardChanged() {\n\t    if (\n\t        bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, '')).find(e => e.includes('Purse:') || e.includes('Piggy:'))\n\t    ) {\n\t        bot.removeListener('scoreboardTitleChanged', onScoreboardChanged)\n\t        log('Joined SkyBlock')\n\t        initAFKHandler(bot)\n", "        setTimeout(() => {\n\t            log('Waited for grace period to end. Flips can now be bought.')\n\t            bot.state = null\n\t            bot.removeAllListeners('scoreboardTitleChanged')\n\t            wss.send(\n\t                JSON.stringify({\n\t                    type: 'uploadScoreboard',\n\t                    data: JSON.stringify(bot.scoreboard.sidebar.items.map(item => item.displayName.getText(null).replace(item.name, '')))\n\t                })\n\t            )\n", "        }, 5500)\n\t        await sleep(2500)\n\t        tryToTeleportToIsland(bot, 0)\n\t    }\n\t}\n"]}
{"filename": "src/tradeHandler.ts", "chunked_list": ["import { MyBot, TradeData } from '../types/autobuy'\n\timport { log } from './logger'\n\timport { clickWindow, sleep } from './utils'\n\texport async function tradePerson(bot: MyBot, websocket: WebSocket, data: TradeData) {\n\t    let addedCoins = false\n\t    let addedItems = false\n\t    let trading = true\n\t    while (trading) {\n\t        bot.chat('/trade ' + data.target)\n\t        bot.on('message', async msgE => {\n", "            let msg = msgE.getText(null)\n\t            if (msg == 'You cannot trade while the server is lagging!') {\n\t                bot.chat('The server is lagging, give it a second')\n\t                await sleep(5000)\n\t            } else if (msg.startsWith('Cannot find player named')) {\n\t                log('Player is not avaliable to trade with, please rerequest when they are capable of trading')\n\t                trading = false\n\t                return\n\t            } else if (msg == 'You are too far away to trade with that player!') {\n\t                bot.chat('Hey ' + data.target + ' come here so we can trade!')\n", "            } else if (msg.startsWith('You have sent a trade request to ')) {\n\t                log('successfully sent trade, waiting for them to accept')\n\t                bot.on('windowOpen', async window => {\n\t                    trading = false\n\t                    log('Trade window opened')\n\t                    if (!addedItems) {\n\t                        for (let slot of data.slots) {\n\t                            slot += 44\n\t                            clickWindow(bot, slot)\n\t                            log('Clicked slot ' + slot)\n", "                        }\n\t                        log('Added all items')\n\t                    }\n\t                    if (data.coins > 0 && !addedCoins) {\n\t                        bot._client.once('open_sign_entity', ({ location }) => {\n\t                            let price = data.coins\n\t                            log('New sign entity')\n\t                            log('price to set ' + Math.floor(price).toString())\n\t                            bot._client.write('update_sign', {\n\t                                location: {\n", "                                    x: location.z,\n\t                                    y: location.y,\n\t                                    z: location.z\n\t                                },\n\t                                text1: `\\\"${Math.floor(price).toString()}\\\"`,\n\t                                text2: '{\"italic\":false,\"extra\":[\"^^^^^^^^^^^^^^^\"],\"text\":\"\"}',\n\t                                text3: '{\"italic\":false,\"extra\":[\"Your auction\"],\"text\":\"\"}',\n\t                                text4: '{\"italic\":false,\"extra\":[\"starting bid\"],\"text\":\"\"}'\n\t                            })\n\t                            addedCoins = true\n", "                        })\n\t                        clickWindow(bot, 36)\n\t                    }\n\t                    if (!(data.coins > 0) || addedCoins) {\n\t                        websocket.send(JSON.stringify({ type: 'affirmFlip', data: [JSON.stringify(window.slots)] }))\n\t                    }\n\t                })\n\t            }\n\t        })\n\t        await sleep(5000)\n", "    }\n\t}\n"]}
{"filename": "src/logger.ts", "chunked_list": ["import { Client, PacketMeta } from 'minecraft-protocol'\n\timport winston from 'winston'\n\timport { getConfigProperty } from './configHelper'\n\tlet fs = require('fs')\n\tlet path = require('path')\n\tlet logFilePath = path.join((process as any).pkg ? process.argv[0] : process.argv[1], '..')\n\tlet logger: winston.Logger\n\texport function initLogger() {\n\t    const loggerConfig = {\n\t        format: winston.format.combine(winston.format.timestamp(), winston.format.prettyPrint()),\n", "        transports: [],\n\t        exceptionHandlers: [new winston.transports.File({ filename: 'log.txt', dirname: logFilePath })],\n\t        rejectionHandlers: [new winston.transports.File({ filename: 'log.txt', dirname: logFilePath })]\n\t    }\n\t    loggerConfig.transports.push(\n\t        new winston.transports.File({\n\t            dirname: logFilePath,\n\t            filename: 'log.txt',\n\t            level: 'debug',\n\t            format: winston.format.combine(winston.format.timestamp(), winston.format.prettyPrint()),\n", "            options: {\n\t                flags: 'w'\n\t            }\n\t        })\n\t    )\n\t    loggerConfig.transports.push(\n\t        new winston.transports.Console({\n\t            format: winston.format.combine(winston.format.timestamp(), winston.format.prettyPrint()),\n\t            level: 'none'\n\t        })\n", "    )\n\t    logger = winston.createLogger(loggerConfig)\n\t}\n\texport function log(string: any, level?: string) {\n\t    logger.log(level || 'info', string)\n\t}\n\texport function logPacket(packet: any, packetMeta: PacketMeta, toServer: boolean) {\n\t    if (!getConfigProperty('LOG_PACKAGES')) {\n\t        return\n\t    }\n", "    if (packetMeta.name !== 'window_click' && packetMeta.name !== 'open_window' && packetMeta.name !== 'window_items') {\n\t        return\n\t    }\n\t    fs.writeFileSync(\n\t        'packets.log',\n\t        `${toServer ? 'toServer' : 'toClient'}: ${JSON.stringify(packet)}\\n${JSON.stringify(packetMeta)}\\n----------------------------------------------\\n`,\n\t        { flag: 'a+' }\n\t    )\n\t}\n\texport function printMcChatToConsole(string: string) {\n", "    let msg = ''\n\t    let split = string.split('§')\n\t    msg += split[0]\n\t    for (let a of string.split('§').slice(1, split.length)) {\n\t        let color = a.charAt(0)\n\t        let message\n\t        if (Object.keys(colors).includes(color)) {\n\t            msg += colors[color]\n\t        }\n\t        message = a.substring(1, a.length)\n", "        msg += message\n\t    }\n\t    console.log('\\x1b[0m\\x1b[1m\\x1b[90m' + msg + '\\x1b[0m')\n\t}\n\t// this function adds a logging function to the wrtie function of the client\n\t// resulting in all sent packets being logged by the logPacket function\n\texport function addLoggerToClientWriteFunction(client: Client) {\n\t    ;(function () {\n\t        var old_prototype = client.write.prototype\n\t        var old_init = client.write\n", "        client.write = function (name, packet) {\n\t            old_init.apply(this, arguments)\n\t            logPacket(packet, { name: name, state: null }, true)\n\t        }\n\t        client.write.prototype = old_prototype\n\t    })()\n\t}\n\tconst colors = {\n\t    0: '\\x1b[0m\\x1b[30m',\n\t    1: '\\x1b[0m\\x1b[34m',\n", "    2: '\\x1b[0m\\x1b[32m',\n\t    3: '\\x1b[0m\\x1b[36m',\n\t    4: '\\x1b[0m\\x1b[31m',\n\t    5: '\\x1b[0m\\x1b[35m',\n\t    6: '\\x1b[0m\\x1b[33m',\n\t    7: '\\x1b[0m\\x1b[1m\\x1b[90m',\n\t    8: '\\x1b[0m\\x1b[90m',\n\t    9: '\\x1b[0m\\x1b[34m',\n\t    a: '\\x1b[0m\\x1b[32m',\n\t    b: '\\x1b[0m\\x1b[36m',\n", "    c: '\\x1b[0m\\x1b[31m',\n\t    d: '\\x1b[0m\\x1b[35m',\n\t    e: '\\x1b[0m\\x1b[33m',\n\t    f: '\\x1b[0m\\x1b[37m'\n\t}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["export async function clickWindow(bot, slot: number) {\n\t    return bot.clickWindow(slot, 0, 0)\n\t}\n\texport async function sleep(ms: number): Promise<void> {\n\t    return await new Promise(resolve => setTimeout(resolve, ms))\n\t}\n\texport function getWindowTitle(window) {\n\t    if (window.title) {\n\t        let parsed = JSON.parse(window.title)\n\t        return parsed.extra ? parsed['extra'][0]['text'] : parsed.translate\n", "    }\n\t    if (window.windowTitle) {\n\t        return JSON.parse(window.windowTitle)['extra'][0]['text']\n\t    }\n\t    return ''\n\t}\n\texport function numberWithThousandsSeparators(number?: number): string {\n\t    if (!number) {\n\t        return '0'\n\t    }\n", "    var parts = number.toString().split('.')\n\t    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n\t    return parts.join('.')\n\t}\n\texport function isCoflChatMessage(message: string) {\n\t    return removeMinecraftColorCodes(message).startsWith('[Chat]')\n\t}\n\texport function removeMinecraftColorCodes(text: string) {\n\t    return text?.replace(/§[0-9a-fk-or]/gi, '')\n\t}\n"]}
{"filename": "src/fastWindowClick.ts", "chunked_list": ["import { Client } from 'minecraft-protocol'\n\timport { log, logPacket, printMcChatToConsole } from './logger'\n\timport { numberWithThousandsSeparators } from './utils'\n\tlet windowClicker\n\texport function getFastWindowClicker(): FastWindowClicker {\n\t    if (windowClicker) {\n\t        return windowClicker\n\t    }\n\t    throw 'Window Clicker not created!'\n\t}\n", "export function createFastWindowClicker(client: Client) {\n\t    let actionCounter = 1\n\t    let lastWindowId = 0\n\t    let _windowClicker = {\n\t        // click purchase in window \"BIN Auction View\"\n\t        clickPurchase: function (price: number, windowId: number) {\n\t            client.write('window_click', {\n\t                windowId: windowId,\n\t                slot: 31,\n\t                mouseButton: 0,\n", "                action: actionCounter,\n\t                mode: 0,\n\t                item: {\n\t                    blockId: 371,\n\t                    itemCount: 1,\n\t                    itemDamage: 0,\n\t                    nbtData: {\n\t                        type: 'compound',\n\t                        name: '',\n\t                        value: {\n", "                            overrideMeta: { type: 'byte', value: 1 },\n\t                            display: {\n\t                                type: 'compound',\n\t                                value: {\n\t                                    Lore: {\n\t                                        type: 'list',\n\t                                        value: {\n\t                                            type: 'string',\n\t                                            value: ['', `┬º7Price: ┬º6${numberWithThousandsSeparators(price)} coins`, '', '┬ºeClick to purchase!']\n\t                                        }\n", "                                    },\n\t                                    Name: { type: 'string', value: '┬º6Buy Item Right Now' }\n\t                                }\n\t                            },\n\t                            AttributeModifiers: { type: 'list', value: { type: 'end', value: [] } }\n\t                        }\n\t                    }\n\t                }\n\t            })\n\t            actionCounter += 1\n", "        },\n\t        clickBedPurchase: function (price: number, windowId: number) {\n\t            client.write('window_click', {\n\t                windowId: windowId,\n\t                slot: 31,\n\t                mouseButton: 0,\n\t                action: actionCounter,\n\t                mode: 0,\n\t                item: {\n\t                    blockId: 355,\n", "                    itemCount: 1,\n\t                    itemDamage: 0,\n\t                    nbtData: {\n\t                        type: 'compound',\n\t                        name: '',\n\t                        value: {\n\t                            overrideMeta: { type: 'byte', value: 1 },\n\t                            display: {\n\t                                type: 'compound',\n\t                                value: {\n", "                                    Lore: {\n\t                                        type: 'list',\n\t                                        value: {\n\t                                            type: 'string',\n\t                                            value: ['', `┬º7Price: ┬º6${numberWithThousandsSeparators(price)} coins`, '', '┬ºcCan be bought soon!']\n\t                                        }\n\t                                    },\n\t                                    Name: { type: 'string', value: '┬º6Buy Item Right Now' }\n\t                                }\n\t                            },\n", "                            AttributeModifiers: { type: 'list', value: { type: 'end', value: [] } }\n\t                        }\n\t                    }\n\t                }\n\t            })\n\t            actionCounter += 1\n\t        },\n\t        // click confirm in window \"Confirm Purchase\"\n\t        clickConfirm: function (price: number, itemName: string, windowId: number) {\n\t            client.write('window_click', {\n", "                windowId: windowId,\n\t                slot: 11,\n\t                mouseButton: 0,\n\t                action: actionCounter,\n\t                mode: 0,\n\t                item: {\n\t                    blockId: 159,\n\t                    itemCount: 1,\n\t                    itemDamage: 13,\n\t                    nbtData: {\n", "                        type: 'compound',\n\t                        name: '',\n\t                        value: {\n\t                            overrideMeta: { type: 'byte', value: 1 },\n\t                            display: {\n\t                                type: 'compound',\n\t                                value: {\n\t                                    Lore: {\n\t                                        type: 'list',\n\t                                        value: {\n", "                                            type: 'string',\n\t                                            value: [\n\t                                                `┬º7Purchasing: ┬ºa┬ºf┬º9${itemName.replace(/§/g, '┬º')}`,\n\t                                                `┬º7Cost: ┬º6${numberWithThousandsSeparators(Math.floor(price))} coins`\n\t                                            ]\n\t                                        }\n\t                                    },\n\t                                    Name: { type: 'string', value: '┬ºaConfirm' }\n\t                                }\n\t                            },\n", "                            AttributeModifiers: { type: 'list', value: { type: 'end', value: [] } }\n\t                        }\n\t                    }\n\t                }\n\t            })\n\t            actionCounter += 1\n\t        },\n\t        getLastWindowId: function () {\n\t            return lastWindowId\n\t        }\n", "    }\n\t    client.on('packet', function (packet, packetMeta) {\n\t        if (packetMeta.name === 'open_window') {\n\t            lastWindowId = packet.windowId\n\t        }\n\t        logPacket(packet, packetMeta, false)\n\t    })\n\t    windowClicker = _windowClicker\n\t}\n"]}
{"filename": "src/sellHandler.ts", "chunked_list": ["import { MyBot, SellData } from '../types/autobuy'\n\timport { log, printMcChatToConsole } from './logger'\n\timport { clickWindow, getWindowTitle, numberWithThousandsSeparators, removeMinecraftColorCodes } from './utils'\n\timport { sendWebhookItemListed } from './webhookHandler'\n\tlet setPrice = false\n\tlet durationSet = false\n\tlet retryCount = 0\n\texport async function onWebsocketCreateAuction(bot: MyBot, data: SellData) {\n\t    if (bot.state) {\n\t        log('Currently busy with something else (' + bot.state + ') -> not selling')\n", "        if (retryCount > 3) {\n\t            retryCount = 0\n\t            return\n\t        }\n\t        setTimeout(() => {\n\t            retryCount++\n\t            onWebsocketCreateAuction(bot, data)\n\t        }, 1000)\n\t        return\n\t    }\n", "    bot.state = 'selling'\n\t    log('Selling item...')\n\t    log(data)\n\t    sellItem(data, bot)\n\t}\n\tasync function sellItem(data: SellData, bot: MyBot) {\n\t    let timeout = setTimeout(() => {\n\t        log('Seems something went wrong while selling. Removing lock', 'warn')\n\t        bot.state = null\n\t        bot.removeAllListeners('windowOpen')\n", "    }, 10000)\n\t    let handler = function (window: any) {\n\t        sellHandler(data, bot, window, () => {\n\t            clearTimeout(timeout)\n\t            bot.removeAllListeners('windowOpen')\n\t        })\n\t    }\n\t    bot.on('windowOpen', handler)\n\t    bot.chat('/ah')\n\t}\n", "async function sellHandler(data: SellData, bot: MyBot, sellWindow, removeEventListenerCallback: Function) {\n\t    let title = getWindowTitle(sellWindow)\n\t    log(title)\n\t    if (title.toString().includes('Auction House')) {\n\t        clickWindow(bot, 15)\n\t    }\n\t    if (title == 'Manage Auctions') {\n\t        let clickSlot\n\t        for (let i = 0; i < sellWindow.slots.length; i++) {\n\t            const item = sellWindow.slots[i]\n", "            if (item && item.nbt.value.display.value.Name.value.includes('Create Auction')) {\n\t                if (item && (item.nbt as any).value?.display?.value?.Lore?.value?.value?.toString().includes('You reached the maximum number')) {\n\t                    log('Maximum number of auctons reached -> cant sell')\n\t                    removeEventListenerCallback()\n\t                    bot.state = null\n\t                    return\n\t                }\n\t                clickSlot = item.slot\n\t            }\n\t        }\n", "        clickWindow(bot, clickSlot)\n\t    }\n\t    if (title == 'Create Auction') {\n\t        clickWindow(bot, 48)\n\t    }\n\t    if (title == 'Create BIN Auction') {\n\t        if (!setPrice && !durationSet) {\n\t            if (!sellWindow.slots[13].nbt.value.display.value.Name.value.includes('Click an item in your inventory!')) {\n\t                clickWindow(bot, 13)\n\t            }\n", "            // calculate item slot, by calculating the slot index without the chest\n\t            let itemSlot = data.slot - bot.inventory.inventoryStart + sellWindow.inventoryStart\n\t            if (!sellWindow.slots[itemSlot]) {\n\t                bot.state = null\n\t                removeEventListenerCallback()\n\t                log('No item at index ' + itemSlot + ' found -> probably already sold', 'warn')\n\t                return\n\t            }\n\t            let id = sellWindow.slots[itemSlot]?.nbt?.value?.ExtraAttributes?.value?.id?.value\n\t            let uuid = sellWindow.slots[itemSlot]?.nbt?.value?.ExtraAttributes?.value?.uuid?.value\n", "            if (data.id !== id && data.id !== uuid) {\n\t                bot.state = null\n\t                removeEventListenerCallback()\n\t                log('Item at index ' + itemSlot + '\" does not match item that is supposed to be sold: \"' + data.id + '\" -> dont sell', 'warn')\n\t                log(JSON.stringify(sellWindow.slots[itemSlot]))\n\t                return\n\t            }\n\t            clickWindow(bot, itemSlot)\n\t            bot._client.once('open_sign_entity', ({ location }) => {\n\t                let price = (data as SellData).price\n", "                log('Price to set ' + Math.floor(price).toString())\n\t                bot._client.write('update_sign', {\n\t                    location: {\n\t                        x: location.z,\n\t                        y: location.y,\n\t                        z: location.z\n\t                    },\n\t                    text1: `\\\"${Math.floor(price).toString()}\\\"`,\n\t                    text2: '{\"italic\":false,\"extra\":[\"^^^^^^^^^^^^^^^\"],\"text\":\"\"}',\n\t                    text3: '{\"italic\":false,\"extra\":[\"Your auction\"],\"text\":\"\"}',\n", "                    text4: '{\"italic\":false,\"extra\":[\"starting bid\"],\"text\":\"\"}'\n\t                })\n\t            })\n\t            log('opening pricer')\n\t            clickWindow(bot, 31)\n\t            setPrice = true\n\t        } else if (setPrice && !durationSet) {\n\t            clickWindow(bot, 33)\n\t        } else if (setPrice && durationSet) {\n\t            const resetAndTakeOutItem = () => {\n", "                clickWindow(bot, 13) // Take the item out of the window\n\t                removeEventListenerCallback()\n\t                setPrice = false\n\t                durationSet = false\n\t                bot.state = null\n\t            }\n\t            try {\n\t                const lore = <string[]>sellWindow.slots[29]?.nbt?.value?.display?.value?.Lore?.value?.value\n\t                let priceLine = lore.find(el => removeMinecraftColorCodes(el).includes('Item price'))\n\t                if (!priceLine) {\n", "                    log('Price not present', 'error')\n\t                    log(sellWindow.slots[29])\n\t                    resetAndTakeOutItem()\n\t                    return\n\t                }\n\t                if (priceLine.startsWith('{')) {\n\t                    let obj = JSON.parse(priceLine)\n\t                    priceLine = obj.extra[1].text.replace(/[,.]/g, '').split(' coins')[0]\n\t                } else {\n\t                    priceLine = removeMinecraftColorCodes(priceLine)\n", "                    priceLine = priceLine.split(': ')[1].split(' coins')[0]\n\t                    priceLine = priceLine.replace(/[,.]/g, '')\n\t                }\n\t                if (Number(priceLine) !== Math.floor(data.price)) {\n\t                    log('Price is not the one that should be there', 'error')\n\t                    log(data)\n\t                    log(sellWindow.slots[29])\n\t                    resetAndTakeOutItem()\n\t                    return\n\t                }\n", "            } catch (e) {\n\t                log('Checking if correct price was set in sellHandler through an error: ' + JSON.stringify(e), 'error')\n\t            }\n\t            clickWindow(bot, 29)\n\t        }\n\t    }\n\t    if (title == 'Auction Duration') {\n\t        setAuctionDuration(bot, data.duration).then(() => {\n\t            durationSet = true\n\t        })\n", "        clickWindow(bot, 16)\n\t    }\n\t    if (title == 'Confirm BIN Auction') {\n\t        clickWindow(bot, 11)\n\t    }\n\t    if (title == 'BIN Auction View') {\n\t        log('Successfully listed an item')\n\t        removeEventListenerCallback()\n\t        setPrice = false\n\t        durationSet = false\n", "        bot.state = null\n\t        printMcChatToConsole(`§f[§4BAF§f]: §fItem listed: ${data.itemName} §ffor ${numberWithThousandsSeparators(data.price)} coins`)\n\t        sendWebhookItemListed(data.itemName, numberWithThousandsSeparators(data.price), data.duration)\n\t        bot.closeWindow(sellWindow)\n\t    }\n\t}\n\tasync function setAuctionDuration(bot: MyBot, time: number) {\n\t    log('setAuctionDuration function')\n\t    return new Promise<void>(resolve => {\n\t        bot._client.once('open_sign_entity', ({ location }) => {\n", "            bot._client.write('update_sign', {\n\t                location: {\n\t                    x: location.z,\n\t                    y: location.y,\n\t                    z: location.z\n\t                },\n\t                text1: `\\\"${Math.floor(time).toString()}\\\"`,\n\t                text2: '{\"italic\":false,\"extra\":[\"^^^^^^^^^^^^^^^\"],\"text\":\"\"}',\n\t                text3: '{\"italic\":false,\"extra\":[\"Auction\"],\"text\":\"\"}',\n\t                text4: '{\"italic\":false,\"extra\":[\"hours\"],\"text\":\"\"}'\n", "            })\n\t            resolve()\n\t        })\n\t    })\n\t}\n"]}
{"filename": "src/configHelper.ts", "chunked_list": ["let fs = require('fs')\n\tlet path = require('path')\n\tlet filePath = path.join((process as any).pkg ? process.argv[0] : process.argv[1], '..', 'config.toml')\n\tvar json2toml = require('json2toml')\n\tvar toml = require('toml')\n\tlet config: Config = {\n\t    INGAME_NAME: '',\n\t    WEBHOOK_URL: '',\n\t    FLIP_ACTION_DELAY: 100,\n\t    ENABLE_CONSOLE_INPUT: true,\n", "    USE_COFL_CHAT: true,\n\t    SESSIONS: {},\n\t    USE_WINDOW_SKIPS: false\n\t}\n\tjson2toml({ simple: true })\n\texport function initConfigHelper() {\n\t    if (fs.existsSync(filePath)) {\n\t        let existingConfig = toml.parse(fs.readFileSync(filePath, { encoding: 'utf8', flag: 'r' }))\n\t        // add new default values to existing config if new property was added in newer version\n\t        let hadChange = false\n", "        Object.keys(config).forEach(key => {\n\t            if (existingConfig[key] === undefined) {\n\t                existingConfig[key] = config[key]\n\t                hadChange = true\n\t            }\n\t        })\n\t        if (hadChange) {\n\t            fs.writeFileSync(filePath, json2toml(existingConfig))\n\t        }\n\t        config = existingConfig\n", "    }\n\t}\n\texport function updatePersistentConfigProperty(property: string, value: any) {\n\t    config[property] = value\n\t    fs.writeFileSync(filePath, json2toml(config))\n\t}\n\texport function getConfigProperty(property: string): any {\n\t    return config[property]\n\t}\n"]}
{"filename": "src/webhookHandler.ts", "chunked_list": ["import axios from 'axios'\n\timport { getConfigProperty } from './configHelper'\n\tfunction sendWebhookData(options: Partial<Webhook>): void {\n\t    let data = {\n\t        content: options.content || '',\n\t        avatar_url: options.avatar_url,\n\t        tts: options.tts,\n\t        embeds: options.embeds || [],\n\t        username: options.username || 'BAF'\n\t    }\n", "    axios.post(getConfigProperty('WEBHOOK_URL'), data)\n\t}\n\tfunction isWebhookConfigured() {\n\t    return !!getConfigProperty('WEBHOOK_URL')\n\t}\n\texport function sendWebhookInitialized() {\n\t    if (!isWebhookConfigured()) {\n\t        return\n\t    }\n\t    let ingameName = getConfigProperty('INGAME_NAME')\n", "    sendWebhookData({\n\t        content: 'Initialized Connection',\n\t        embeds: [\n\t            {\n\t                title: 'Initialized Connection',\n\t                fields: [\n\t                    { name: 'Connected as:', value: `\\`\\`\\`${ingameName}\\`\\`\\``, inline: false },\n\t                    {\n\t                        name: 'Started at:',\n\t                        value: `<t:${(Date.now() / 1000).toFixed(0)}:t>`,\n", "                        inline: false\n\t                    }\n\t                ],\n\t                thumbnail: { url: `https://minotar.net/helm/${ingameName}/600.png` }\n\t            }\n\t        ]\n\t    })\n\t}\n\texport function sendWebhookItemPurchased(itemName: string, price: string) {\n\t    if (!isWebhookConfigured()) {\n", "        return\n\t    }\n\t    let ingameName = getConfigProperty('INGAME_NAME')\n\t    sendWebhookData({\n\t        embeds: [\n\t            {\n\t                title: 'Item Purchased',\n\t                fields: [\n\t                    {\n\t                        name: 'Item:',\n", "                        value: `\\`\\`\\`${itemName}\\`\\`\\``,\n\t                        inline: true\n\t                    },\n\t                    {\n\t                        name: 'Bought for:',\n\t                        value: `\\`\\`\\`${price}\\`\\`\\``,\n\t                        inline: true\n\t                    }\n\t                ],\n\t                thumbnail: { url: `https://minotar.net/helm/${ingameName}/600.png` }\n", "            }\n\t        ]\n\t    })\n\t}\n\texport function sendWebhookItemSold(itemName: string, price: string, purchasedBy: string) {\n\t    if (!isWebhookConfigured()) {\n\t        return\n\t    }\n\t    let ingameName = getConfigProperty('INGAME_NAME')\n\t    sendWebhookData({\n", "        embeds: [\n\t            {\n\t                title: 'Item Sold',\n\t                fields: [\n\t                    {\n\t                        name: 'Purchased by:',\n\t                        value: `\\`\\`\\`${purchasedBy}\\`\\`\\``,\n\t                        inline: true\n\t                    },\n\t                    {\n", "                        name: 'Item Sold:',\n\t                        value: `\\`\\`\\`${itemName}\\`\\`\\``,\n\t                        inline: true\n\t                    },\n\t                    {\n\t                        name: 'Sold for:',\n\t                        value: `\\`\\`\\`${price}\\`\\`\\``,\n\t                        inline: true\n\t                    }\n\t                ],\n", "                thumbnail: { url: `https://minotar.net/helm/${ingameName}/600.png` }\n\t            }\n\t        ]\n\t    })\n\t}\n\texport function sendWebhookItemListed(itemName: string, price: string, duration: number) {\n\t    if (!isWebhookConfigured()) {\n\t        return\n\t    }\n\t    let ingameName = getConfigProperty('INGAME_NAME')\n", "    sendWebhookData({\n\t        embeds: [\n\t            {\n\t                title: 'Item Listed',\n\t                fields: [\n\t                    {\n\t                        name: 'Listed Item:',\n\t                        value: `\\`\\`\\`${itemName}\\`\\`\\``,\n\t                        inline: false\n\t                    },\n", "                    {\n\t                        name: 'Item Price:',\n\t                        value: `\\`\\`\\`${price}\\`\\`\\``,\n\t                        inline: false\n\t                    },\n\t                    {\n\t                        name: 'AH Duration:',\n\t                        value: `\\`\\`\\`${duration}h\\`\\`\\``,\n\t                        inline: false\n\t                    }\n", "                ],\n\t                thumbnail: { url: `https://minotar.net/helm/${ingameName}/600.png` }\n\t            }\n\t        ]\n\t    })\n\t}\n"]}
