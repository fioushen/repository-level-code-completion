{"filename": "src/main/config.ts", "chunked_list": ["const Config = {\n\t  defaultPrefix: \"!\",\n\t  version: \"1.1.0-stable\",\n\t  disableWatchdog: false, // If your world crashes, change this to true\n\t};\n\texport { Config };\n"]}
{"filename": "src/main/index.ts", "chunked_list": ["import { SystemEvents } from \"./@modules/modules\";\n\timport { Config } from \"./config\";\n\tSystemEvents.on(\n\t  \"watchdogTerminate\",\n\t  (watchdog) => (watchdog.cancel = Config.disableWatchdog)\n\t);\n\timport \"./plugins/plugin.loader\";\n"]}
{"filename": "src/main/plugins/plugin.loader.ts", "chunked_list": ["/**\n\t * This is an AutoLoad system\n\t * Import plugin using pluginFolder, like if you have plugin called \"Example\" then add \"Example\" to the pluginFolder, it should looks like this\n\t * [\"Example\", \"Plugin 1\", \"Plugin 2\"]\n\t * Don't forget to rename the main plugin with \"system\", example: \"Plugin 1/system\"\n\t */\n\tconst pluginFolder: string[] = [\n\t  // Import Plugin (Folder Name)\n\t  \"Chat Ranks\",\n\t  \"Custom Commands\",\n", "];\n\t//.\n\t//.\n\t//.\n\t//.\n\t//.\n\t//.\n\t//.\n\t//.\n\t//.\n", "//.\n\t//.\n\t//.\n\t//.\n\t//.\n\t// Don't Touch\n\timport \"./_ignore/index\";\n\tconst start: number = Date.now();\n\tfor (const plugin of pluginFolder) {\n\t  const end: number = Date.now();\n", "  import(`./${plugin}/system`)\n\t    .then(() =>\n\t      console.warn(\n\t        `Loaded plugin: ${plugin} successfully, in ${end - start} ms`\n\t      )\n\t    )\n\t    .catch((err) =>\n\t      console.warn(\n\t        `Error on loading plugin: ${plugin}\\nError: ${err}\\nStack: ${err.stack}`\n\t      )\n", "    );\n\t}\n"]}
{"filename": "src/main/plugins/@modules.ts", "chunked_list": ["// Modules chaining\n\texport {\n\t  Command,\n\t  CommandRegistration,\n\t  Collection,\n\t  PlayerClass,\n\t  ChatClass,\n\t  ErrorClass,\n\t  FailedClass,\n\t  FormClass,\n", "  Form,\n\t  World,\n\t  Database,\n\t  AfterEvents,\n\t  BeforeEvents,\n\t  SystemEvents,\n\t  CooldownClass,\n\t  Formatter,\n\t  Timer,\n\t  Validation,\n", "  MS,\n\t} from \"../@modules/modules\";\n"]}
{"filename": "src/main/plugins/Chat Ranks/config.ts", "chunked_list": ["const RankConfig = {\n\t  /**\n\t   * @NAME = Player Name\n\t   * @CHAT = Player Message\n\t   */\n\t  defaultRank: \"§7[Member] §r@NAME §7>> §r@CHAT\",\n\t};\n\texport { RankConfig };\n"]}
{"filename": "src/main/plugins/Chat Ranks/system.ts", "chunked_list": ["import { world } from \"@minecraft/server\";\n\timport { BeforeEvents, Command, PlayerClass } from \"../@modules\";\n\timport { RankConfig } from \"./config\";\n\tBeforeEvents.on(\"chat\", (rawdata) => {\n\t  const { sender, message } = rawdata;\n\t  if (message.startsWith(Command.getPrefix())) return;\n\t  rawdata.cancel = true;\n\t  const player = new PlayerClass(sender);\n\t  const getRank =\n\t    player.getTagStartsWith(\"rank:\")?.slice(5) ?? RankConfig.defaultRank;\n", "  world.sendMessage(\n\t    getRank?.replaceAll(\"@NAME\", sender.name)?.replaceAll(\"@CHAT\", message)\n\t  );\n\t});\n"]}
{"filename": "src/main/plugins/_ignore/index.ts", "chunked_list": ["// Runner\n\timport \"./EventEmitter/index\";\n"]}
{"filename": "src/main/plugins/_ignore/EventEmitter/index.ts", "chunked_list": ["import { world, system, ChatSendBeforeEvent  } from \"@minecraft/server\";\n\timport {\n\t  BeforeEvents,\n\t  AfterEvents,\n\t  SystemEvents,\n\t} from \"../../@modules\";\n\t// Before events\n\tworld.beforeEvents.chatSend.subscribe((cb) => BeforeEvents.emit(\"chat\", cb));\n\tworld.beforeEvents.dataDrivenEntityTriggerEvent.subscribe((cb) =>\n\t  BeforeEvents.emit(\"dataDrivenEntity\", cb)\n", ");\n\tworld.beforeEvents.explosion.subscribe((cb) =>\n\t  BeforeEvents.emit(\"explosion\", cb)\n\t);\n\tworld.beforeEvents.itemDefinitionEvent.subscribe((cb) =>\n\t  BeforeEvents.emit(\"itemDefinition\", cb)\n\t);\n\tworld.beforeEvents.itemUse.subscribe((cb) => BeforeEvents.emit(\"itemUse\", cb));\n\tworld.beforeEvents.itemUseOn.subscribe((cb) =>\n\t  BeforeEvents.emit(\"itemUseOn\", cb)\n", ");\n\tworld.beforeEvents.pistonActivate.subscribe((cb) =>\n\t  BeforeEvents.emit(\"pistonActivate\", cb)\n\t);\n\t// After events\n\tworld.afterEvents.blockBreak.subscribe((cb) =>\n\t  AfterEvents.emit(\"blockBreak\", cb)\n\t);\n\tworld.afterEvents.blockExplode.subscribe((cb) =>\n\t  AfterEvents.emit(\"blockExplode\", cb)\n", ");\n\tworld.afterEvents.blockPlace.subscribe((cb) =>\n\t  AfterEvents.emit(\"blockPlace\", cb)\n\t);\n\tworld.afterEvents.buttonPush.subscribe((cb) =>\n\t  AfterEvents.emit(\"buttonPush\", cb)\n\t);\n\tworld.afterEvents.chatSend.subscribe((cb) => AfterEvents.emit(\"chat\", cb));\n\tworld.afterEvents.dataDrivenEntityTriggerEvent.subscribe((cb) =>\n\t  AfterEvents.emit(\"dataDrivenEntity\", cb)\n", ");\n\tworld.afterEvents.effectAdd.subscribe((cb) =>\n\t  AfterEvents.emit(\"effectAdd\", cb)\n\t);\n\tworld.afterEvents.entityDie.subscribe((cb) =>\n\t  AfterEvents.emit(\"entityDie\", cb)\n\t);\n\tworld.afterEvents.entityHealthChanged.subscribe((cb) =>\n\t  AfterEvents.emit(\"entityHealthChanged\", cb)\n\t);\n", "world.afterEvents.entityHitBlock.subscribe((cb) =>\n\t  AfterEvents.emit(\"entityHitBlock\", cb)\n\t);\n\tworld.afterEvents.entityHitEntity.unsubscribe((cb) =>\n\t  AfterEvents.emit(\"entityHitEntity\", cb)\n\t);\n\tworld.afterEvents.entityHurt.subscribe((cb) =>\n\t  AfterEvents.emit(\"entityHurt\", cb)\n\t);\n\tworld.afterEvents.entityRemoved.subscribe((cb) =>\n", "  AfterEvents.emit(\"entityRemoved\", cb)\n\t);\n\tworld.afterEvents.entitySpawn.subscribe((cb) =>\n\t  AfterEvents.emit(\"entitySpawn\", cb)\n\t);\n\tworld.afterEvents.explosion.subscribe((cb) =>\n\t  AfterEvents.emit(\"explosion\", cb)\n\t);\n\tworld.afterEvents.itemCompleteUse.subscribe((cb) =>\n\t  AfterEvents.emit(\"itemCompleteUse\", cb)\n", ");\n\tworld.afterEvents.itemDefinitionEvent.subscribe((cb) =>\n\t  AfterEvents.emit(\"itemDefinition\", cb)\n\t);\n\tworld.afterEvents.itemReleaseUse.subscribe((cb) =>\n\t  AfterEvents.emit(\"itemReleaseUse\", cb)\n\t);\n\tworld.afterEvents.itemStartUse.subscribe((cb) =>\n\t  AfterEvents.emit(\"itemStartUse\", cb)\n\t);\n", "world.afterEvents.itemStartUseOn.subscribe((cb) =>\n\t  AfterEvents.emit(\"itemStartUseOn\", cb)\n\t);\n\tworld.afterEvents.itemStopUse.subscribe((cb) =>\n\t  AfterEvents.emit(\"itemStopUse\", cb)\n\t);\n\tworld.afterEvents.itemStopUseOn.subscribe((cb) =>\n\t  AfterEvents.emit(\"itemStopUseOn\", cb)\n\t);\n\tworld.afterEvents.itemUse.subscribe((cb) => AfterEvents.emit(\"itemUse\", cb));\n", "world.afterEvents.itemUseOn.subscribe((cb) =>\n\t  AfterEvents.emit(\"itemUseOn\", cb)\n\t);\n\tworld.afterEvents.leverAction.subscribe((cb) =>\n\t  AfterEvents.emit(\"leverAction\", cb)\n\t);\n\tworld.afterEvents.messageReceive.subscribe((cb) =>\n\t  AfterEvents.emit(\"messageReceive\", cb)\n\t);\n\tworld.afterEvents.pistonActivate.subscribe((cb) =>\n", "  AfterEvents.emit(\"pistonActivate\", cb)\n\t);\n\tworld.afterEvents.playerJoin.subscribe((cb) =>\n\t  AfterEvents.emit(\"playerJoin\", cb)\n\t);\n\tworld.afterEvents.playerLeave.subscribe((cb) =>\n\t  AfterEvents.emit(\"playerLeave\", cb)\n\t);\n\tworld.afterEvents.playerSpawn.subscribe((cb) =>\n\t  AfterEvents.emit(\"playerSpawn\", cb)\n", ");\n\tworld.afterEvents.pressurePlatePop.subscribe((cb) =>\n\t  AfterEvents.emit(\"pressurePlatePop\", cb)\n\t);\n\tworld.afterEvents.pressurePlatePush.subscribe((cb) =>\n\t  AfterEvents.emit(\"pressurePlatePush\", cb)\n\t);\n\tworld.afterEvents.projectileHit.subscribe((cb) =>\n\t  AfterEvents.emit(\"projectileHit\", cb)\n\t);\n", "world.afterEvents.targetBlockHit.subscribe((cb) =>\n\t  AfterEvents.emit(\"targetBlockHit\", cb)\n\t);\n\tworld.afterEvents.tripWireTrip.subscribe((cb) =>\n\t  AfterEvents.emit(\"tripWireTrip\", cb)\n\t);\n\tworld.afterEvents.weatherChange.subscribe((cb) =>\n\t  AfterEvents.emit(\"weatherChange\", cb)\n\t);\n\tworld.afterEvents.worldInitialize.subscribe((cb) =>\n", "  AfterEvents.emit(\"worldInitialize\", cb)\n\t);\n\t// System events\n\tsystem.beforeEvents.watchdogTerminate.subscribe((cb) =>\n\t  SystemEvents.emit(\"watchdogTerminate\", cb)\n\t);\n\tsystem.afterEvents.scriptEventReceive.subscribe((cb) =>\n\t  SystemEvents.emit(\"scriptEventReceive\", cb)\n\t);\n"]}
{"filename": "src/main/plugins/Custom Commands/system.ts", "chunked_list": ["// Information\n\timport \"./information/help\";\n\timport \"./information/version\";\n\t// Global\n\timport \"./global/home/home\";\n\timport \"./global/home/sethome\";\n\timport \"./global/home/delhome\";\n\timport \"./global/home/listhome\";\n"]}
{"filename": "src/main/plugins/Custom Commands/global/home/listhome.ts", "chunked_list": ["import { world } from \"@minecraft/server\";\n\timport { Command, CommandRegistration, Validation } from \"../../../@modules\";\n\timport { HomeDB } from \"./sethome\";\n\tconst registration: CommandRegistration = new CommandRegistration()\n\t  .setName(\"listhome\")\n\t  .setDescription(\"Get all home\")\n\t  .setUsage([\"<homeName>\"])\n\t  .setExample([\"listhome myHome\"]);\n\tCommand.BuildCommand(registration, (interaction) => {\n\t  const { sender } = interaction;\n", "  const homes = [];\n\t  for (const [, home] of HomeDB) {\n\t    if (home.creator === sender.name) homes.push(home);\n\t  }\n\t  return sender.sendMessage(\n\t    `§b---- Home List ----\\n\\n${\n\t      homes.length === 0\n\t        ? \"§f# §7You don't have any home\"\n\t        : homes\n\t            .sort()\n", "            .map(\n\t              (home: { name: string; dimension: string }) =>\n\t                `§f# §a${home.name} §7- ${home.dimension}`\n\t            )\n\t            .join(\"\\n\\n\")\n\t    }`\n\t  );\n\t});\n"]}
{"filename": "src/main/plugins/Custom Commands/global/home/delhome.ts", "chunked_list": ["import { Command, CommandRegistration, Validation } from \"../../../@modules\";\n\timport { HomeDB } from \"./sethome\";\n\tconst registration: CommandRegistration = new CommandRegistration()\n\t  .setName(\"delhome\")\n\t  .setDescription(\"Delete home\")\n\t  .setAliases([\"deletehome\", \"dhome\"])\n\t  .setInputs({ 0: [\"string\"] })\n\t  .setUsage([\"<homeName>\"])\n\t  .setExample([\"home myHome\", \"deletehome myHome\", \"dhome myHome\"]);\n\tCommand.BuildCommand(registration, (interaction) => {\n", "  const { sender, inputs } = interaction;\n\t  const homeName = inputs.getInput(0) as any;\n\t  if (Validation.isUndefined(homeName))\n\t    return sender.sendMessage(\"§cHome name cannot be empty\");\n\t  const homeDBFrmt = `${sender.name}_${homeName}`;\n\t  if (!HomeDB.hasKey(homeDBFrmt))\n\t    return sender.sendMessage(`§cHome with name §e${homeName} §cdoesn't exist`);\n\t  HomeDB.delete(homeDBFrmt);\n\t  return sender.sendMessage(\n\t    `§aSuccessfully deleted home with name §e${homeName}`\n", "  );\n\t});\n"]}
{"filename": "src/main/plugins/Custom Commands/global/home/home.ts", "chunked_list": ["import { world } from \"@minecraft/server\";\n\timport { Command, CommandRegistration, Validation } from \"../../../@modules\";\n\timport { HomeDB } from \"./sethome\";\n\tconst registration: CommandRegistration = new CommandRegistration()\n\t  .setName(\"home\")\n\t  .setDescription(\"Teleport to home\")\n\t  .setInputs({ 0: [\"string\"] })\n\t  .setUsage([\"<homeName>\"])\n\t  .setExample([\"home myHome\"]);\n\tCommand.BuildCommand(registration, async (interaction) => {\n", "  const { sender, inputs } = interaction;\n\t  const homeName = inputs.getInput(0) as any;\n\t  if (Validation.isUndefined(homeName))\n\t    return sender.sendMessage(\"§cHome name cannot be empty\");\n\t  const homeDBFrmt = `${sender.name}_${homeName}`;\n\t  if (!HomeDB.hasKey(homeDBFrmt))\n\t    return sender.sendMessage(`§cHome with name §e${homeName} §cdoesn't exist`);\n\t  const parsedHome = HomeDB.get(homeDBFrmt);\n\t  await null;\n\t  sender.teleport(\n", "    {\n\t      x: parsedHome.coordinate[0],\n\t      y: parsedHome.coordinate[1],\n\t      z: parsedHome.coordinate[2],\n\t    },\n\t    { dimension: world.getDimension(parsedHome.dimension) }\n\t  );\n\t  return sender.sendMessage(\n\t    `§aSuccessfully teleported to home with name §e${homeName}`\n\t  );\n", "});\n"]}
{"filename": "src/main/plugins/Custom Commands/global/home/sethome.ts", "chunked_list": ["import {\n\t  Command,\n\t  CommandRegistration,\n\t  Database,\n\t  Validation,\n\t} from \"../../../@modules\";\n\tconst registration: CommandRegistration = new CommandRegistration()\n\t  .setName(\"sethome\")\n\t  .setDescription(\"Sethome home\")\n\t  .setAliases([\"shome\"])\n", "  .setInputs({ 0: [\"string\"] })\n\t  .setUsage([\"<homeName>\"])\n\t  .setExample([\"sethome myHome\", \"shome myHome\"]);\n\tconst HomeDB = new Database(\"HomeDB\");\n\tCommand.BuildCommand(registration, (interaction) => {\n\t  const { sender, inputs } = interaction;\n\t  const homeName = inputs.getInput(0) as any;\n\t  if (Validation.isUndefined(homeName))\n\t    return sender.sendMessage(\"§cHome name cannot be empty\");\n\t  const homeDBFrmt = `${sender.name}_${homeName}`;\n", "  if (HomeDB.hasKey(homeDBFrmt))\n\t    return sender.sendMessage(`§eHome with name §e${homeName} §calready exist`);\n\t  HomeDB.set(homeDBFrmt, {\n\t    name: homeName,\n\t    creator: sender.name,\n\t    coordinate: [\n\t      Math.floor(sender.location.x),\n\t      Math.floor(sender.location.y),\n\t      Math.floor(sender.location.z),\n\t    ],\n", "    dimension: sender.dimension.id,\n\t  });\n\t  return sender.sendMessage(\n\t    `§aSuccessfully set home with name §e${homeName} §aat coordinates §eX: ${Math.floor(\n\t      sender.location.x\n\t    )} Y: ${Math.floor(sender.location.x)} Z: ${Math.floor(sender.location.z)}`\n\t  );\n\t});\n\texport { HomeDB };\n"]}
{"filename": "src/main/plugins/Custom Commands/information/version.ts", "chunked_list": ["import { Config } from \"../../../config\";\n\timport { Command, CommandRegistration } from \"../../@modules\";\n\tconst registration: CommandRegistration = new CommandRegistration()\n\t  .setName(\"version\")\n\t  .setDescription(\"Get API version\")\n\t  .setCategory(\"Information\")\n\t  .setAliases([\"ver\", \"versi\"]);\n\tCommand.BuildCommand(registration, (interaction) =>\n\t  interaction.sender.sendMessage(`§aAPI Version: §e${Config.version}`)\n\t);\n"]}
{"filename": "src/main/plugins/Custom Commands/information/help.ts", "chunked_list": ["import { Player } from \"@minecraft/server\";\n\timport { Command, CommandRegistration, Validation } from \"../../@modules\";\n\tconst registration: CommandRegistration = new CommandRegistration()\n\t  .setName(\"help\")\n\t  .setDescription(\"Help command\")\n\t  .setCategory(\"Information\")\n\t  .setAliases([\"?\", \"h\"])\n\t  .setInputs({ 0: [\"number\", \"string\"] })\n\t  .setUsage([\"<pageNumber | CommandName>\"])\n\t  .setExample([\"help ping\", \"help 1\", \"help\"]);\n", "const PAGE_LIMIT: number = 12;\n\tCommand.BuildCommand(registration, (interaction) => {\n\t  const { sender, inputs } = interaction;\n\t  if (\n\t    isNaN(inputs.getInput(0) as any) &&\n\t    !Validation.isUndefined(inputs.getInput(0) as any)\n\t  ) {\n\t    const item = Command.getCommand(inputs.getInput(0) as any);\n\t    if (!item)\n\t      return sender.sendMessage(\n", "        `§cCommands with name or alias §f${\n\t          inputs.getInput(0) as any\n\t        } §cnot found.`\n\t      );\n\t    return sender.sendMessage(\n\t      `§a--- Command information ---\\n§7Name: §f${\n\t        item.name\n\t      }\\n§7Description: §f${\n\t        item.description.length === 0\n\t          ? \"No description found\"\n", "          : item.description\n\t      }\\n§7Category: §f${item.category}\\n§7Aliases: §f${\n\t        item.aliases.length === 0 ? \"No aliases found\" : item.aliases.join(\", \")\n\t      }\\n§7Usage: §f\\n - ${\n\t        item.usage.length === 0 ? \"No usage found\" : item.usage.join(\"\\n - \")\n\t      }\\n§7Example Usage: §f\\n - ${\n\t        item.example.length === 0\n\t          ? \"No example found\"\n\t          : item.example.join(\"\\n - \")\n\t      }\\n§a--------------------------`\n", "    );\n\t  } else {\n\t    const startIndex: number = (((inputs.getInput(0) as any) ?? 1) - 1) * PAGE_LIMIT;\n\t    const endIndex: number = ((inputs.getInput(0) as any) ?? 1) * PAGE_LIMIT;\n\t    const items = Array.from(Command.getAllCommands().values())\n\t      .slice(startIndex, endIndex)\n\t      .filter((command) => !command.private);\n\t    const maxPages: number = Math.ceil(items.length / PAGE_LIMIT);\n\t    let messages: string = \"\";\n\t    let currentCategory: string = \"\";\n", "    messages += `§a--- Showing help page ${\n\t      inputs.getInput(0) ?? 1\n\t    } of ${maxPages} [§e${Command.getPrefix()}help <page>§a] ---\\n\\n`;\n\t    messages += items\n\t      .map((item) => {\n\t        let categoryLine = \"\";\n\t        if (item.category !== currentCategory) {\n\t          categoryLine = `§e${item.category}:\\n`;\n\t          currentCategory = item.category;\n\t        }\n", "        return `${categoryLine} §7${Command.getPrefix()}${item.name} §f${\n\t          item.usage[0]\n\t        }`;\n\t      })\n\t      .join(\"\\n\");\n\t    if (inputs.getInput(0) === 1) {\n\t      const remainingItems = Array.from(\n\t        Command.getAllCommands().values()\n\t      ).slice(PAGE_LIMIT);\n\t      if (remainingItems.length > 0) {\n", "        messages += `\\n§eTo view the next page, use §f${Command.getPrefix()}help 2 §eor §f${Command.getPrefix()}help 3§e, and so on`;\n\t      }\n\t    } else {\n\t      const remainingItems = Array.from(\n\t        Command.getAllCommands().values()\n\t      ).slice(endIndex);\n\t      if (remainingItems.length > 0) {\n\t        messages += `\\n§eTo view the next page, use §f${Command.getPrefix()}help ${\n\t          ((inputs.getInput(0) as any) ?? 1) + 1\n\t        }`;\n", "      }\n\t    }\n\t    return sender.sendMessage(messages);\n\t  }\n\t});\n"]}
{"filename": "src/main/@modules/modules.ts", "chunked_list": ["export { Command } from \"./handlers/command/Command.Class\";\n\texport { CommandRegistration } from \"./handlers/command/CommandRegistration.Class\";\n\texport { Collection } from \"./handlers/data/Collection.Class\";\n\texport { PlayerClass } from \"./handlers/entity/Player.Class\";\n\texport { EntityClass } from \"./handlers/entity/Entity.Class\";\n\texport { ChatClass } from \"./handlers/message/Chat.Class\";\n\texport { ErrorClass } from \"./handlers/message/Error.Class\";\n\texport { FailedClass } from \"./handlers/message/Failed.Class\";\n\texport { FormClass } from \"./handlers/interface/Form.Class\";\n\texport * as Form from \"./handlers/interface/Form.Function\";\n", "export * as World from \"./handlers/world/World.Function\";\n\texport { Database } from \"./storages/Database.Class\";\n\texport { AfterEvents } from \"./events/AfterEventsEmitter.Class\";\n\texport { BeforeEvents } from \"./events/BeforeEventsEmitter.Class\";\n\texport { SystemEvents } from \"./events/SystemEventsEmitter.Class\";\n\texport { CooldownClass } from \"./utils/Cooldown.Class\";\n\texport * as Formatter from \"./utils/Formatter.Function\";\n\texport * as Timer from \"./utils/Timer.Function\";\n\texport * as Validation from \"./utils/Validation.Function\";\n\texport * as MS from \"./utils/MS.Function\";\n"]}
{"filename": "src/main/@modules/storages/Database.Class.ts", "chunked_list": ["import {\n\t  world,\n\t  ScoreboardIdentityType,\n\t  Scoreboard,\n\t  ScoreboardObjective,\n\t} from \"@minecraft/server\";\n\timport { Collection } from \"../handlers/data/Collection.Class\";\n\timport { ChatClass } from \"../handlers/message/Chat.Class\";\n\timport { ErrorClass } from \"../handlers/message/Error.Class\";\n\timport * as Formatter from \"../utils/Formatter.Function\";\n", "import * as Validation from \"../utils/Validation.Function\";\n\timport * as Timer from \"../utils/Timer.Function\";\n\tclass Database {\n\t  private DB_NAME: string;\n\t  private DB_SAVED_NAMES: string[];\n\t  private RESTORED_DATA: Collection;\n\t  private error: ErrorClass;\n\t  private objective: Scoreboard | ScoreboardObjective;\n\t  /**\n\t   * Database class\n", "   * @param name - Database name\n\t   */\n\t  constructor(name: string) {\n\t    this.DB_NAME = name;\n\t    this.DB_SAVED_NAMES = [];\n\t    this.RESTORED_DATA = new Collection();\n\t    this.error = new ErrorClass();\n\t    this.objective =\n\t      world.scoreboard.getObjective(`DB_${name}`) ??\n\t      world.scoreboard.addObjective(`DB_${name}`, `DB_${name}`);\n", "    if (name.length > 15 || !name)\n\t      this.error.CustomError(\n\t        \"Database\",\n\t        \"constructor\",\n\t        \"Database names can't be more than 15 characters nor empty\"\n\t      );\n\t    if (this.DB_SAVED_NAMES.includes(name))\n\t      this.error.CustomError(\n\t        \"Database\",\n\t        \"constructor\",\n", "        `Database with name ${name} already exist`\n\t      );\n\t    this.DB_SAVED_NAMES.push(name);\n\t    Timer.runNextTick(() => {\n\t      for (const participant of this.objective.getParticipants()) {\n\t        if (participant.type !== ScoreboardIdentityType.FakePlayer) continue;\n\t        const [cleanData, parsedData] = participant.displayName\n\t          .slice(1, -1)\n\t          .split(\",\")\n\t          .map(Formatter.DecryptText);\n", "        this.RESTORED_DATA.set(JSON.parse(cleanData), JSON.parse(parsedData));\n\t      }\n\t    });\n\t  }\n\t  private _dataMerge(...arrays: any): any {\n\t    const destination: any = {};\n\t    arrays.forEach((source: any) => {\n\t      for (let prop in source) {\n\t        if (destination[prop] === null || Validation.isArray(destination[prop]))\n\t          destination[prop] =\n", "            destination[prop]?.concat(source[prop]) || source[prop];\n\t        else if (typeof destination[prop] === \"object\")\n\t          destination[prop] = this._dataMerge(destination[prop], source[prop]);\n\t        else destination[prop] = source[prop];\n\t      }\n\t    });\n\t    return destination;\n\t  }\n\t  /**\n\t   * Push new data to database\n", "   * @param key - Key\n\t   * @param value - Value or data\n\t   */\n\t  push(key: string, value: any): undefined | void {\n\t    if (!this.hasKey(key)) return undefined;\n\t    this.set(key, this._dataMerge(this.get(key), value));\n\t  }\n\t  /**\n\t   * Set data to database\n\t   * @param key - Key\n", "   * @param value - Value or data\n\t   */\n\t  async set(key: string, value: any) {\n\t    if (value.length >= 32000)\n\t      this.error.CustomError(\n\t        \"Database\",\n\t        \"set\",\n\t        \"Value length is too much, limit character is 32000 or 32k\"\n\t      );\n\t    const [encryptKey, encryptValue] = [key, value].map((item) =>\n", "      Formatter.EncryptText(JSON.stringify(item))\n\t    );\n\t    this.delete(key);\n\t    await null;\n\t    new ChatClass().runCommand(\n\t      `scoreboard players set \"[${encryptKey},${encryptValue}]\" \"DB_${this.DB_NAME}\" 0`\n\t    );\n\t    this.RESTORED_DATA.set(key, value);\n\t  }\n\t  /**\n", "   * Get data from database\n\t   * @param key - Key\n\t   */\n\t  get(key: string): any | undefined {\n\t    return this.hasKey(key) ? this.RESTORED_DATA.get(key) : undefined;\n\t  }\n\t  /**\n\t   * Delete database data based with key\n\t   * @param key - Key\n\t   */\n", "  async delete(key: string): Promise<void | undefined> {\n\t    if (!this.hasKey(key)) return undefined;\n\t    const [encryptKey, encryptValue] = [key, this.RESTORED_DATA.get(key)].map(\n\t      (item) => Formatter.EncryptText(JSON.stringify(item))\n\t    );\n\t    await null;\n\t    new ChatClass().runCommand(\n\t      `scoreboard players reset \"[${encryptKey},${encryptValue}]\" \"DB_${this.DB_NAME}\"`\n\t    );\n\t    this.RESTORED_DATA.delete(key);\n", "  }\n\t  /**\n\t   * Find data without key\n\t   * @param fn - Function\n\t   */\n\t  find(fn: (value: any, key?: any, map?: Map<any, any>) => any): any {\n\t    return this.RESTORED_DATA.find(fn);\n\t  }\n\t  /**\n\t   * Looping the data\n", "   * @param fn - Function\n\t   */\n\t  forEach(fn: (value: any, key?: any, map?: Map<any, any>) => void): any {\n\t    return this.RESTORED_DATA.forEach(fn);\n\t  }\n\t  /**\n\t   * Reset database\n\t   */\n\t  reset() {\n\t    world.scoreboard.removeObjective(`DB_${this.DB_NAME}`);\n", "    world.scoreboard.addObjective(`DB_${this.DB_NAME}`, `DB_${this.DB_NAME}`);\n\t    this.RESTORED_DATA.clear();\n\t  }\n\t  /** Iterator */\n\t  *values() {\n\t    yield* this.RESTORED_DATA.values();\n\t  }\n\t  /** Iterator */\n\t  *keys() {\n\t    yield* this.RESTORED_DATA.keys();\n", "  }\n\t  /**\n\t   * Has key\n\t   * @param key - Key\n\t   */\n\t  hasKey(key: string): boolean {\n\t    return this.RESTORED_DATA.has(key);\n\t  }\n\t  /** Iterator */\n\t  *entries() {\n", "    yield* this.RESTORED_DATA.entries();\n\t  }\n\t  /** Iterator */\n\t  [Symbol.iterator]() {\n\t    return this.entries();\n\t  }\n\t}\n\texport { Database };\n"]}
{"filename": "src/main/@modules/utils/Validation.Function.ts", "chunked_list": ["/**\n\t * Check if string\n\t * @param string\n\t */\n\tfunction isString(string: string): boolean {\n\t  return typeof string === \"string\";\n\t}\n\t/**\n\t * Check if number\n\t * @param number\n", " */\n\tfunction isNumber(number: number): boolean {\n\t  return typeof number === \"number\";\n\t}\n\t/**\n\t * Check if integer\n\t * @param integer\n\t */\n\tfunction isInteger(integer: bigint): boolean {\n\t  return Number.isInteger(integer);\n", "}\n\t/**\n\t * Check if boolean\n\t * @param boolean\n\t */\n\tfunction isBoolean(boolean: boolean): boolean {\n\t  return typeof boolean === \"boolean\";\n\t}\n\t/**\n\t * Check if object\n", " * @param object\n\t */\n\tfunction isObject(object: object): boolean {\n\t  return (\n\t    typeof object === \"object\" && !Array.isArray(object) && object !== null\n\t  );\n\t}\n\t/**\n\t * Check if array\n\t * @param array\n", " */\n\tfunction isArray(array: Array<any>): boolean {\n\t  return Array.isArray(array);\n\t}\n\t/**\n\t * Check if null\n\t * @param object\n\t */\n\tfunction isNull(object: null): boolean {\n\t  return object === null;\n", "}\n\t/**\n\t * Check if undefined\n\t * @param object\n\t */\n\tfunction isUndefined(object: undefined): boolean {\n\t  return object === undefined;\n\t}\n\t/**\n\t * Check if error\n", " * @param error\n\t */\n\tfunction isError(error: Error): boolean {\n\t  return error instanceof Error && \"message\" in error;\n\t}\n\texport {\n\t  isString,\n\t  isNumber,\n\t  isInteger,\n\t  isBoolean,\n", "  isObject,\n\t  isArray,\n\t  isNull,\n\t  isUndefined,\n\t  isError,\n\t};"]}
{"filename": "src/main/@modules/utils/MS.Function.ts", "chunked_list": ["/**\n\t * Converting durations or milliseconds\n\t */\n\tfunction Format(\n\t  value: number | string,\n\t  {\n\t    compactDuration = false,\n\t    fullDuration = false,\n\t    avoidDuration = [],\n\t  }: {\n", "    compactDuration?: boolean;\n\t    fullDuration?: boolean;\n\t    avoidDuration?: string[];\n\t  } = {}\n\t): boolean | number | string {\n\t  if (typeof value === \"string\") {\n\t    if (/^\\d+$/.test(value)) return Number(value);\n\t    const durations = value.match(\n\t      /-?\\d*\\.?\\d+\\s*?(years?|yrs?|weeks?|days?|hours?|hrs?|minutes?|mins?|seconds?|secs?|milliseconds?|msecs?|ms|[smhdwy])/gi\n\t    );\n", "    return durations\n\t      ? durations.reduce((a, b) => a + toMiliseconds(b), 0)\n\t      : null;\n\t  }\n\t  if (typeof value === \"number\")\n\t    return toDuration(value, {\n\t      compactDuration,\n\t      fullDuration,\n\t      avoidDuration,\n\t    });\n", "  return false;\n\t}\n\t/**\n\t * Convert durations to milliseconds\n\t */\n\tfunction toMiliseconds(value: string): number {\n\t  const number = Number(value.replace(/[^-.0-9]+/g, \"\"));\n\t  value = value.replace(/\\s+/g, \"\");\n\t  if (/\\d+(?=y)/i.test(value)) return number * 3.154e10;\n\t  else if (/\\d+(?=w)/i.test(value)) return number * 6.048e8;\n", "  else if (/\\d+(?=d)/i.test(value)) return number * 8.64e7;\n\t  else if (/\\d+(?=h)/i.test(value)) return number * 3.6e6;\n\t  else if (/\\d+(?=m)/i.test(value)) return number * 60000;\n\t  else if (/\\d+(?=s)/i.test(value)) return number * 1000;\n\t  else if (/\\d+(?=ms|milliseconds?)/i.test(value)) return number;\n\t}\n\t/**\n\t * Convert milliseconds to duration\n\t */\n\tfunction toDuration(\n", "  value: number,\n\t  {\n\t    compactDuration = false,\n\t    fullDuration = false,\n\t    avoidDuration = [],\n\t  }: {\n\t    compactDuration?: boolean;\n\t    fullDuration?: boolean;\n\t    avoidDuration?: string[];\n\t  } = {}\n", "): string {\n\t  const absMs = Math.abs(value);\n\t  const duration = [\n\t    { short: \"w\", long: \"week\", duration: Math.floor(absMs / 6.048e8) },\n\t    { short: \"d\", long: \"day\", duration: Math.floor(absMs / 8.64e7) % 7 },\n\t    { short: \"h\", long: \"hour\", duration: Math.floor(absMs / 3.6e6) % 24 },\n\t    { short: \"m\", long: \"minute\", duration: Math.floor(absMs / 60000) % 60 },\n\t    { short: \"s\", long: \"second\", duration: Math.floor(absMs / 1000) % 60 },\n\t    { short: \"ms\", long: \"millisecond\", duration: absMs % 1000 },\n\t  ];\n", "  const mappedDuration = duration\n\t    .filter((obj) =>\n\t      obj.duration !== 0 && avoidDuration\n\t        ? fullDuration &&\n\t          !avoidDuration.map((v: string) => v.toLowerCase()).includes(obj.short)\n\t        : obj.duration\n\t    )\n\t    .map(\n\t      (obj) =>\n\t        `${Math.sign(value) === -1 ? \"-\" : \"\"}${\n", "          compactDuration\n\t            ? `${Math.floor(obj.duration)}${obj.short}`\n\t            : `${Math.floor(obj.duration)} ${obj.long}${\n\t                obj.duration === 1 ? \"\" : \"s\"\n\t              }`\n\t        }`\n\t    );\n\t  const result = fullDuration\n\t    ? mappedDuration.join(compactDuration ? \" \" : \", \")\n\t    : mappedDuration[0];\n", "  return result || `${absMs}`;\n\t}\n\texport { Format, toMiliseconds, toDuration };\n"]}
{"filename": "src/main/@modules/utils/Timer.Function.ts", "chunked_list": ["import { system } from \"@minecraft/server\";\n\t/**\n\t * Run next tick\n\t * @param callback\n\t */\n\tfunction runNextTick(callback: () => void): number {\n\t  const timerId = system.run(callback);\n\t  return timerId;\n\t}\n\t/**\n", " * Repeatedly executing a function\n\t * @param callback\n\t * @param tick\n\t */\n\tfunction setTickInterval(callback: () => void, tick: number): number {\n\t  const timerId = system.runInterval(callback, tick);\n\t  return timerId;\n\t}\n\t/**\n\t * Executing a function with delay\n", " * @param callback\n\t * @param tick\n\t */\n\tfunction setTickTimeout(callback: () => void, tick: number): number {\n\t  const timerId = system.runTimeout(callback, tick);\n\t  return timerId;\n\t}\n\t/**\n\t * Same with setTickInterval but without tick\n\t * @param callback\n", " */\n\tfunction runInfinityLoop(callback: () => void): number {\n\t  const timerId = system.runInterval(callback);\n\t  return timerId;\n\t}\n\t/**\n\t * Clear tick\n\t * @param timerId\n\t * @example\n\t * const run = setTickInterval(YourFunction, 20);\n", " * clearTick(run);\n\t */\n\tfunction clearTick(timerId: number) {\n\t  system.clearRun(timerId);\n\t}\n\t/**\n\t * Like setTickTimeout but without function\n\t * @param tick\n\t * @example\n\t * console.warn(\"One\");\n", " * sleep(20);\n\t * console.warn(\"Two\");\n\t */\n\tasync function sleep(tick: number): Promise<any> {\n\t  try {\n\t    return new Promise(\n\t      (resolve: (value?: unknown) => void, reject: (reason?: any) => void) => {\n\t        system.runTimeout(resolve, tick);\n\t      }\n\t    );\n", "  } catch (err) {\n\t    console.warn(err, err.stack);\n\t  }\n\t}\n\texport {\n\t  runNextTick,\n\t  setTickInterval,\n\t  setTickTimeout,\n\t  runInfinityLoop,\n\t  clearTick,\n", "  sleep,\n\t};\n"]}
{"filename": "src/main/@modules/utils/Cooldown.Class.ts", "chunked_list": ["import { setTickTimeout } from \"./Timer.Function\";\n\tclass CooldownClass {\n\t  private endTime: number;\n\t  /**\n\t   * Cooldown system\n\t   */\n\t  constructor() {\n\t    this.endTime = null;\n\t  }\n\t  /**\n", "   * Start cooldown\n\t   * @param duration - Duration in seconds\n\t   */\n\t  start(duration: number) {\n\t    if (this.isActive()) return;\n\t    this.endTime = Date.now() + duration * 1000;\n\t    setTickTimeout(() => {\n\t      this.endTime = null;\n\t    }, duration * 20);\n\t  }\n", "  /**\n\t   * Check cooldown\n\t   * @returns {number}\n\t   */\n\t  isActive(): boolean {\n\t    return this.endTime !== null && this.endTime > Date.now();\n\t  }\n\t  /**\n\t   * Get cooldown time remaining\n\t   * @returns {number}\n", "   */\n\t  getCooldown(): number {\n\t    if (this.isActive()) {\n\t      const remainingTime = Math.max(0, this.endTime - Date.now());\n\t      return Math.round(remainingTime / 1000);\n\t    }\n\t    return 0;\n\t  }\n\t}\n\texport { CooldownClass };\n"]}
{"filename": "src/main/@modules/utils/Formatter.Function.ts", "chunked_list": ["/**\n\t * Turn text into colored text\n\t * @param text - The text you want to format to rainbow colors.\n\t * @example rainbowText('This is rainbow text!');\n\t */\n\tfunction rainbowText(text: string): string {\n\t  const rainbowCode: string[] = [\n\t    \"§4\",\n\t    \"§c\",\n\t    \"§6\",\n", "    \"§e\",\n\t    \"§g\",\n\t    \"§2\",\n\t    \"§a\",\n\t    \"§b\",\n\t    \"§3\",\n\t    \"§9\",\n\t    \"§5\",\n\t    \"§d\",\n\t  ];\n", "  const letter: string[] = text.replace(/§./g, \"\").split(\"\");\n\t  let newMessage: string = \"\";\n\t  let rainbowIndex: number = 0;\n\t  letter.forEach((letter) => {\n\t    if (letter !== \" \") {\n\t      newMessage += `${rainbowCode[rainbowIndex]}${letter}`;\n\t      rainbowIndex + 1 >= rainbowCode.length\n\t        ? (rainbowIndex = 0)\n\t        : rainbowIndex++;\n\t    } else newMessage += \" \";\n", "  });\n\t  return newMessage;\n\t}\n\t/**\n\t * This will display in text in thousands, millions and etc... For ex: \"1400 -> \"1.4k\", \"1000000\" -> \"1M\", etc...\n\t * @param number - The number you want to convert\n\t * @example metricNumbers(15000);\n\t */\n\tfunction metricNumbers(value: number): string | number {\n\t  const types: string[] = [\"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"];\n", "  const selectType: number = (Math.log10(value) / 3) | 0;\n\t  if (selectType == 0) return value;\n\t  let scaled: number = value / Math.pow(10, selectType * 3);\n\t  return scaled.toFixed(1) + types[selectType];\n\t}\n\t/**\n\t * Will format your number. For ex: \"1400\" -> \"1,400\", \"1000000\" -> \"1,000,000\", etc...\n\t * @param number - The number you want to convert\n\t * @example thousandsSeparator(15000);\n\t */\n", "function thousandsSeparator(value: number): string {\n\t  if (typeof value !== \"number\") return;\n\t  return value.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n\t}\n\t/**\n\t * Encrypt text\n\t * @param text\n\t */\n\tfunction EncryptText(text: string): string {\n\t  return text\n", "    .split(\"\")\n\t    .map((char) => {\n\t      return char.charCodeAt(0).toString(10);\n\t    })\n\t    .join(\"|\");\n\t}\n\t/**\n\t * Decrypt text\n\t * @param encrypt\n\t */\n", "function DecryptText(encrypt: string): string {\n\t  return encrypt\n\t    .split(\"|\")\n\t    .map((char) => {\n\t      return String.fromCharCode(parseInt(char, 10));\n\t    })\n\t    .join(\"\");\n\t}\n\texport {\n\t  rainbowText,\n", "  metricNumbers,\n\t  thousandsSeparator,\n\t  EncryptText,\n\t  DecryptText,\n\t};\n"]}
{"filename": "src/main/@modules/events/AfterEventsEmitter.Class.ts", "chunked_list": ["import {\n\t  AfterEventCallback,\n\t  AfterEventsList,\n\t} from \"../@types/events/AfterEventsType\";\n\tclass AfterEventsEmitter {\n\t  private _eventsListener: {\n\t    [key: string]: {\n\t      callback: Function;\n\t      once: boolean;\n\t    }[];\n", "  };\n\t  /**\n\t   * Event emitter\n\t   */\n\t  constructor() {\n\t    this._eventsListener = {};\n\t  }\n\t  private _addListener(\n\t    name: string,\n\t    callback: Function,\n", "    once: boolean = false\n\t  ) {\n\t    if (!this._eventsListener[name]) {\n\t      this._eventsListener[name] = [];\n\t    }\n\t    this._eventsListener[name].push({ callback, once });\n\t  }\n\t  /**\n\t   * Event trigger\n\t   * @param name - Trigger name\n", "   * @param args - Event insert callback\n\t   */\n\t  emit(name: string, ...args: any) {\n\t    const listener = this._eventsListener[name];\n\t    if (listener) {\n\t      listener.forEach((value, index) => {\n\t        value.callback(...args);\n\t        if (value.once) listener.splice(index, 1);\n\t      });\n\t    }\n", "  }\n\t  /**\n\t   * On event call\n\t   * @param name - Event name\n\t   * @param callback - Callback\n\t   */\n\t  on<T extends AfterEventsList>(\n\t    name: T,\n\t    callback: (arg: AfterEventCallback<T>) => void\n\t  ) {\n", "    this._addListener(name, callback);\n\t  }\n\t  /**\n\t   * Once event call\n\t   * @param name - Event name\n\t   * @param callback - Callback\n\t   */\n\t  once<T extends AfterEventsList>(\n\t    name: T,\n\t    callback: (arg: AfterEventCallback<T>) => void\n", "  ) {\n\t    this._addListener(name, callback, true);\n\t  }\n\t}\n\tconst AfterEvents = new AfterEventsEmitter();\n\texport { AfterEvents };\n"]}
{"filename": "src/main/@modules/events/SystemEventsEmitter.Class.ts", "chunked_list": ["import {\n\t  SystemEventCallback,\n\t  SystemEventsList,\n\t} from \"../@types/events/SystemEventsType\";\n\tclass SystemEventsEmitter {\n\t  private _eventsListener: {\n\t    [key: string]: {\n\t      callback: Function;\n\t      once: boolean;\n\t    }[];\n", "  };\n\t  /**\n\t   * Event emitter\n\t   */\n\t  constructor() {\n\t    this._eventsListener = {};\n\t  }\n\t  private _addListener(\n\t    name: string,\n\t    callback: Function,\n", "    once: boolean = false\n\t  ) {\n\t    if (!this._eventsListener[name]) {\n\t      this._eventsListener[name] = [];\n\t    }\n\t    this._eventsListener[name].push({ callback, once });\n\t  }\n\t  /**\n\t   * Event trigger\n\t   * @param name - Event trigger\n", "   * @param args - Event insert callback\n\t   */\n\t  emit(name: string, ...args: any) {\n\t    const listener = this._eventsListener[name];\n\t    if (listener) {\n\t      listener.forEach((value, index) => {\n\t        value.callback(...args);\n\t        if (value.once) listener.splice(index, 1);\n\t      });\n\t    }\n", "  }\n\t  /**\n\t   * On event call\n\t   * @param name - Event name\n\t   * @param callback - Callback\n\t   */\n\t  on<T extends SystemEventsList>(\n\t    name: T,\n\t    callback: (arg: SystemEventCallback<T>) => void\n\t  ) {\n", "    this._addListener(name, callback);\n\t  }\n\t  /**\n\t   * Once event call\n\t   * @param name - Event name\n\t   * @param callback - Callback\n\t   */\n\t  once<T extends SystemEventsList>(\n\t    name: T,\n\t    callback: (arg: SystemEventCallback<T>) => void\n", "  ) {\n\t    this._addListener(name, callback, true);\n\t  }\n\t}\n\tconst SystemEvents = new SystemEventsEmitter();\n\texport { SystemEvents };\n"]}
{"filename": "src/main/@modules/events/BeforeEventsEmitter.Class.ts", "chunked_list": ["import {\n\t  BeforeEventsList,\n\t  BeforeEventCallback,\n\t} from \"../@types/events/BeforeEventsType\";\n\tclass BeforeEventsEmitter {\n\t  private _eventsListener: {\n\t    [key: string]: {\n\t      callback: Function;\n\t      once: boolean;\n\t    }[];\n", "  };\n\t  /**\n\t   * Event emitter\n\t   */\n\t  constructor() {\n\t    this._eventsListener = {};\n\t  }\n\t  private _addListener(\n\t    name: string,\n\t    callback: Function,\n", "    once: boolean = false\n\t  ) {\n\t    if (!this._eventsListener[name]) {\n\t      this._eventsListener[name] = [];\n\t    }\n\t    this._eventsListener[name].push({ callback, once });\n\t  }\n\t  /**\n\t   * Event trigger\n\t   * @param name - Event trigger\n", "   * @param args - Event insert callback\n\t   */\n\t  emit(name: string, ...args: any) {\n\t    const listener = this._eventsListener[name];\n\t    if (listener) {\n\t      listener.forEach((value, index) => {\n\t        value.callback(...args);\n\t        if (value.once) listener.splice(index, 1);\n\t      });\n\t    }\n", "  }\n\t  /**\n\t   * On event call\n\t   * @param name - Event name\n\t   * @param callback - Callback\n\t   */\n\t  on<T extends BeforeEventsList>(\n\t    name: T,\n\t    callback: (arg: BeforeEventCallback<T>) => void\n\t  ) {\n", "    this._addListener(name, callback);\n\t  }\n\t  /**\n\t   * Once event call\n\t   * @param name - Event name\n\t   * @param callback - Callback\n\t   */\n\t  once<T extends BeforeEventsList>(\n\t    name: T,\n\t    callback: (arg: BeforeEventCallback<T>) => void\n", "  ) {\n\t    this._addListener(name, callback, true);\n\t  }\n\t}\n\tconst BeforeEvents = new BeforeEventsEmitter();\n\texport { BeforeEvents };\n"]}
{"filename": "src/main/@modules/handlers/entity/Player.Class.ts", "chunked_list": ["import {\n\t  world,\n\t  Player,\n\t  EntityInventoryComponent,\n\t  ItemStack,\n\t} from \"@minecraft/server\";\n\timport { EntityClass } from \"./Entity.Class\";\n\timport { ErrorClass } from \"../message/Error.Class\";\n\timport * as Validation from \"../../utils/Validation.Function\";\n\timport * as World from \"../world/World.Function\";\n", "class PlayerClass extends EntityClass {\n\t  private playerObject: Player;\n\t  private inventory;\n\t  private errors: ErrorClass;\n\t  /**\n\t   * Player class\n\t   * @param playerObject - Player object\n\t   */\n\t  constructor(playerObject: Player) {\n\t    super(playerObject);\n", "    this.playerObject = playerObject;\n\t    this.inventory = this.playerObject.getComponent(\n\t      \"inventory\"\n\t    ) as EntityInventoryComponent;\n\t    this.errors = new ErrorClass();\n\t    if (!playerObject)\n\t      this.errors.CustomError(\n\t        \"PlayerClass\",\n\t        \"constructor\",\n\t        \"PlayerObject cannot be empty\"\n", "      );\n\t  }\n\t  /**\n\t   * Get player scoreboard score\n\t   * @param objective - Scoreboard objective name\n\t   * @example\n\t   * getScore(\"money\");\n\t   */\n\t  getScore(objective: string): number {\n\t    try {\n", "      const sb = world.scoreboard.getObjective(objective);\n\t      if (!sb) world.scoreboard.addObjective(objective, objective);\n\t      return sb.getScore(this.playerObject.scoreboardIdentity);\n\t    } catch {\n\t      return 0;\n\t    }\n\t  }\n\t  /**\n\t   * Set player scoreboard value\n\t   * @param {String} objective - Scoreboard objective name\n", "   * @param {Number} value - Value\n\t   * @param {Boolean} isAdd - If true, it will add score not set score\n\t   */\n\t  setScore(\n\t    objective: string,\n\t    value: number,\n\t    isAdd: boolean = false\n\t  ): unknown | undefined {\n\t    try {\n\t      const sb = world.scoreboard.getObjective(objective);\n", "      if (!sb) world.scoreboard.addObjective(objective, objective);\n\t      return isAdd\n\t        ? this.setScore(objective, this.getScore(objective) + value)\n\t        : sb.setScore(this.playerObject.scoreboardIdentity, value);\n\t    } catch {\n\t      return undefined;\n\t    }\n\t  }\n\t  /**\n\t   * Get player xp level\n", "   * @example getXpLevel();\n\t   */\n\t  getXpLevel(): number {\n\t    return this.playerObject.level ?? 0;\n\t  }\n\t  /**\n\t   * Check player if online\n\t   * @param target - Player name\n\t   * @example isOnline(\"JustSky001\");\n\t   */\n", "  isOnline(target: string): boolean {\n\t    return (\n\t      World.getOnlinePlayers().find(\n\t        (player: Player) => player.name === target\n\t      ) !== undefined\n\t    );\n\t  }\n\t  /**\n\t   * Get player inventory empty slots\n\t   */\n", "  getEmptySlots() {\n\t    return this.inventory.container.emptySlotsCount;\n\t  }\n\t  /**\n\t   * Get player item in right hands slot\n\t   */\n\t  getRightItem(): ItemStack | undefined {\n\t    return this.inventory.container.getItem(this.playerObject.selectedSlot);\n\t  }\n\t  /**\n", "   * Get all items in inventory\n\t   */\n\t  getItems(): { [key: number]: ItemStack } {\n\t    let inventory = {};\n\t    for (let i = 0; i < this.inventory.container.size; i++) {\n\t      Object.assign(inventory, {\n\t        [i]: this.inventory.container.getItem(i),\n\t      });\n\t    }\n\t    return inventory;\n", "  }\n\t  /**\n\t   * Set item lore (player selected slot)\n\t   * @param lore - Lore list\n\t   */\n\t  setItemLore(lore: string[]): undefined {\n\t    if (!Validation.isArray(lore)) return;\n\t    this.getRightItem()?.setLore(lore);\n\t    this.inventory.container.setItem(\n\t      this.playerObject.selectedSlot,\n", "      this.getRightItem()\n\t    );\n\t  }\n\t  /**\n\t   * Get player object from name\n\t   * @param target - Player name\n\t   */\n\t  getPlayerObjectFromName(target: string): Player | undefined {\n\t    return World.getOnlinePlayers().find((player) => player.name === target);\n\t  }\n", "  /**\n\t   * Get needed xp to next level\n\t   */\n\t  needXpToLevelUp(): number {\n\t    return this.playerObject.totalXpNeededForNextLevel;\n\t  }\n\t  /**\n\t   * Get earned xp at current level\n\t   */\n\t  xpEarned(): number {\n", "    return this.playerObject.xpEarnedAtCurrentLevel;\n\t  }\n\t  /**\n\t   * Get inventory component\n\t   */\n\t  getInventoryComponent(): EntityInventoryComponent {\n\t    return this.inventory;\n\t  }\n\t  /**\n\t   * Get raw component\n", "   */\n\t  getRawPlayerComponent(): Player {\n\t    return this.playerObject;\n\t  }\n\t  /**\n\t   * Query\n\t   */\n\t  Query(query: QueryName): boolean {\n\t    return this.playerObject[query];\n\t  }\n", "}\n\texport { PlayerClass };\n"]}
{"filename": "src/main/@modules/handlers/entity/Entity.Class.ts", "chunked_list": ["import { Entity } from \"@minecraft/server\";\n\timport { ErrorClass } from \"../message/Error.Class\";\n\tclass EntityClass {\n\t  private entityObject: Entity;\n\t  private error: ErrorClass;\n\t  /**\n\t   * Entity class\n\t   * @param entityObject - Entity object\n\t   */\n\t  constructor(entityObject: Entity) {\n", "    this.entityObject = entityObject;\n\t    this.error = new ErrorClass();\n\t    if (!entityObject)\n\t      this.error.CustomError(\n\t        \"EntityClass\",\n\t        \"constructor\",\n\t        \"EntityObject cannot be empty\"\n\t      );\n\t  }\n\t  /**\n", "   * Get player all tag\n\t   * @example getTags();\n\t   */\n\t  getTags(): string[] {\n\t    return this.entityObject.getTags();\n\t  }\n\t  /**\n\t   * Check player if had tag\n\t   * @param tag - Tag\n\t   * @example hasTag(\"tag\");\n", "   */\n\t  hasTag(tag: string): boolean {\n\t    if (!tag)\n\t      this.error.CustomError(\"EntityClass\", \"hasTag\", \"tag cannot be empty\");\n\t    return this.entityObject.hasTag(tag);\n\t  }\n\t  /**\n\t   * Get player specific tag\n\t   * @example getSpecificTag(\"tag:\");\n\t   */\n", "  getTagStartsWith(startswith: string): string {\n\t    if (!startswith)\n\t      this.error.CustomError(\n\t        \"EntityClass\",\n\t        \"getTagStartsWith\",\n\t        \"startswith cannot be empty\"\n\t      );\n\t    const check: string = this.getTags()?.find((tag) =>\n\t      tag.startsWith(startswith)\n\t    );\n", "    return check;\n\t  }\n\t}\n\texport { EntityClass };\n"]}
{"filename": "src/main/@modules/handlers/message/Chat.Class.ts", "chunked_list": ["import { world } from \"@minecraft/server\";\n\timport { ErrorClass } from \"./Error.Class\";\n\tclass ChatClass {\n\t  /**\n\t   * Broadcast message in chat\n\t   * @param rawtext - The text must be Object\n\t   * @param player - Player name (Optional)\n\t   * @example broadcast({ text: \"Hello world!\" });\n\t   */\n\t  broadcast(rawtext: object, player: string): unknown {\n", "    const JSONstring = JSON.stringify(rawtext);\n\t    return this.runCommand(\n\t      `tellraw ${player ? `\"${player}\"` : \"@a\"} {\"rawtext\":[${JSON.stringify(\n\t        rawtext\n\t      )}]}`\n\t    );\n\t  }\n\t  /**\n\t   * Runs a command\n\t   * @param command - Basic command but without \"/\"\n", "   * @param dimension - \"overworld\" | \"nether\" | \"the end\"\n\t   * @param debugMode - If true, it will logs the command results, but if false, it will run the command\n\t   * @example runCommand(\"say Hello world!\");\n\t   */\n\t  runCommand(\n\t    command: string,\n\t    dimension: string = \"overworld\",\n\t    debugMode: boolean = false\n\t  ): unknown | string {\n\t    if (command.startsWith(\"/\"))\n", "      new ErrorClass().CustomError(\n\t        \"ChatClass\",\n\t        \"runCommand\",\n\t        'command cannot starts with \"/\" at <anonymous>'\n\t      );\n\t    return debugMode\n\t      ? console.warn(JSON.stringify(this.runCommand(command)))\n\t      : world.getDimension(dimension).runCommand(command);\n\t  }\n\t  /**\n", "   * Runs multiple command at once\n\t   * @param commands - Basic command but without \"/\"\n\t   * @example runCommands([ \"say Hello\", \"say World!\" ]);\n\t   */\n\t  runCommands(commands: string[]) {\n\t    if (commands.some((slash) => slash.startsWith(\"/\")))\n\t      new ErrorClass().CustomError(\n\t        \"ChatClass\",\n\t        \"runCommands\",\n\t        'commands cannot starts with \"/\" at <anonymous>'\n", "      );\n\t    commands.forEach((cmd) => {\n\t      this.runCommand(cmd);\n\t    });\n\t  }\n\t}\n\texport { ChatClass };\n"]}
{"filename": "src/main/@modules/handlers/message/Failed.Class.ts", "chunked_list": ["import { Player } from \"@minecraft/server\";\n\tclass FailedClass {\n\t  /**\n\t   * Invalid command builder\n\t   * @param player - Player object\n\t   * @param commandName - Command name\n\t   */\n\t  InvalidCommand(player: Player, commandName: string): unknown {\n\t    return player.sendMessage({\n\t      rawtext: [\n", "        {\n\t          text: \"§c\",\n\t        },\n\t        {\n\t          translate: \"commands.generic.unknown\",\n\t          with: [`${commandName}`],\n\t        },\n\t      ],\n\t    });\n\t  }\n", "}\n\texport { FailedClass };\n"]}
{"filename": "src/main/@modules/handlers/message/Error.Class.ts", "chunked_list": ["class ErrorClass {\n\t  /**\n\t   * Custom error\n\t   * @param className - Class target\n\t   * @param functionName - Function target\n\t   * @param errorMessage - Error message\n\t   */\n\t  CustomError(\n\t    className: string,\n\t    functionName: string,\n", "    errorMessage: string\n\t  ): Error {\n\t    throw new Error(`[${className}::${functionName}] ${errorMessage}`);\n\t  }\n\t}\n\texport { ErrorClass };\n"]}
{"filename": "src/main/@modules/handlers/data/Collection.Class.ts", "chunked_list": ["class Collection extends Map {\n\t  /**\n\t   * Collection\n\t   */\n\t  constructor() {\n\t    super();\n\t  }\n\t  /**\n\t   * Collection find\n\t   * @param fn - Function\n", "   */\n\t  find(fn: (value: any, key?: any, idk?: unknown) => any) {\n\t    for (const [key, value] of this) {\n\t      if (fn(value, key, this)) return value;\n\t    }\n\t  }\n\t}\n\texport { Collection };\n"]}
{"filename": "src/main/@modules/handlers/command/CommandRegistration.Class.ts", "chunked_list": ["class CommandRegistration {\n\t  private name: string;\n\t  private description: string;\n\t  private private: boolean;\n\t  private category: string;\n\t  private requireTags: string[];\n\t  private aliases: string[];\n\t  private usage: string[];\n\t  private example: string[];\n\t  private inputs: {\n", "    [key: number]: string[];\n\t  };\n\t  /**\n\t   * Command registration\n\t   */\n\t  constructor() {\n\t    this.name = \"\";\n\t    this.description = \"No Description\";\n\t    this.private = false;\n\t    this.category = \"Global\";\n", "    this.requireTags = [];\n\t    this.aliases = [];\n\t    this.usage = [];\n\t    this.example = [];\n\t    this.inputs = {};\n\t  }\n\t  /**\n\t   * Set command name\n\t   */\n\t  setName(name: string) {\n", "    this.name = name;\n\t    return this;\n\t  }\n\t  /**\n\t   * Set command description\n\t   */\n\t  setDescription(desc: string) {\n\t    this.description = desc;\n\t    return this;\n\t  }\n", "  /**\n\t   * Set command private\n\t   */\n\t  setPrivate(value: boolean) {\n\t    this.private = value;\n\t    return this;\n\t  }\n\t  /**\n\t   * Set command category\n\t   */\n", "  setCategory(cname: string) {\n\t    this.category = cname;\n\t    return this;\n\t  }\n\t  /**\n\t   * Set command require tags\n\t   */\n\t  setRequireTags(tags: string[]) {\n\t    this.requireTags = tags;\n\t    return this;\n", "  }\n\t  /**\n\t   * Ser t command aliases\n\t   */\n\t  setAliases(als: string[]) {\n\t    this.aliases = als;\n\t    return this;\n\t  }\n\t  /**\n\t   * Set command usage\n", "   */\n\t  setUsage(usage: string[]) {\n\t    this.usage = usage;\n\t    return this;\n\t  }\n\t  /**\n\t   * Set command example\n\t   */\n\t  setExample(eg: string[]) {\n\t    this.example = eg;\n", "    return this;\n\t  }\n\t  /**\n\t   * Set command input\n\t   */\n\t  setInputs(inputs: { [key: number]: SupportedInputs }) {\n\t    Object.assign(this.inputs, inputs);\n\t    return this;\n\t  }\n\t  /**\n", "   * Extract to JSON - You don't need this for creating custom command\n\t   */\n\t  _ToJSON() {\n\t    return {\n\t      name: this.name,\n\t      description: this.description,\n\t      private: this.private,\n\t      category: this.category,\n\t      requireTags: this.requireTags,\n\t      aliases: this.aliases,\n", "      usage: this.usage,\n\t      example: this.example,\n\t      inputs: this.inputs,\n\t    };\n\t  }\n\t}\n\texport { CommandRegistration };\n"]}
{"filename": "src/main/@modules/handlers/command/Command.Class.ts", "chunked_list": ["import { ChatSendBeforeEvent, world } from \"@minecraft/server\";\n\timport { Collection } from \"../data/Collection.Class\";\n\timport { FailedClass } from \"../message/Failed.Class\";\n\timport { Database } from \"../../storages/Database.Class\";\n\timport { ErrorClass } from \"../message/Error.Class\";\n\timport * as Validation from \"../../utils/Validation.Function\";\n\timport { Config } from \"../../../config\";\n\timport { CommandBuild } from \"../../@types/handlers/command/CommandBuilder\";\n\timport { CommandRegistration } from \"./CommandRegistration.Class\";\n\tclass CommandClass {\n", "  private registration: Collection;\n\t  private failed: FailedClass;\n\t  private error: ErrorClass;\n\t  private db: Database;\n\t  private commandPrefix: string;\n\t  /**\n\t   * Custom Command\n\t   */\n\t  constructor() {\n\t    this.registration = new Collection();\n", "    this.failed = new FailedClass();\n\t    this.error = new ErrorClass();\n\t    this.db = new Database(\"GlobalDB\");\n\t    this.commandPrefix = this.db.get(\"commandPrefix\") ?? Config.defaultPrefix;\n\t    world.beforeEvents.chatSend.subscribe(this.execute.bind(this));\n\t  }\n\t  /**\n\t   * Register new command\n\t   * @param registration\n\t   * @param callback\n", "   */\n\t  BuildCommand(\n\t    registration: CommandRegistration,\n\t    callback: (arg: CommandBuild) => void\n\t  ) {\n\t    const information = registration._ToJSON();\n\t    this.registration.set(information.name, {\n\t      ...information,\n\t      callback,\n\t    });\n", "  }\n\t  /**\n\t   * Get command\n\t   * @param commandName\n\t   */\n\t  getCommand(commandName: string) {\n\t    return (\n\t      this.registration.get(commandName) ||\n\t      this.registration.find((als) => als?.aliases.includes(commandName))\n\t    );\n", "  }\n\t  /**\n\t   * Get all command registratios\n\t   */\n\t  getAllCommands(): Collection {\n\t    return this.registration;\n\t  }\n\t  /**\n\t   * Get command prefix\n\t   */\n", "  getPrefix(): string {\n\t    return this.commandPrefix;\n\t  }\n\t  /**\n\t   * Set command prefix\n\t   * @param prefix\n\t   */\n\t  setPrefix(prefix: string) {\n\t    if (!prefix)\n\t      this.error.CustomError(\n", "        \"CommandClass\",\n\t        \"setPrefix\",\n\t        \"prefix cannot be empty\"\n\t      );\n\t    if (!Validation.isString(prefix))\n\t      this.error.CustomError(\n\t        \"CommandClass\",\n\t        \"setPrefix\",\n\t        \"prefix must be string\"\n\t      );\n", "    this.db.set(\"currentPrefix\", prefix);\n\t  }\n\t  /**\n\t   * Get input\n\t   */\n\t  private getCommandInput(\n\t    args: string[],\n\t    commandInput: { [key: number]: string[] },\n\t    inputNumber: number\n\t  ): undefined | boolean | string | number {\n", "    if (!commandInput) return undefined;\n\t    const inputTypes = [\"string\", \"boolean\", \"number\", \"playername\"];\n\t    const getTypes = commandInput[inputNumber];\n\t    const inputValue = args[inputNumber];\n\t    if (!getTypes || inputValue === undefined) return undefined;\n\t    for (const type of getTypes) {\n\t      if (type === \"playername\" && inputValue.startsWith(\"@\"))\n\t        return inputValue.substring(1);\n\t      if (inputTypes.includes(type)) {\n\t        if (type === \"boolean\") {\n", "          if (inputValue === \"true\") return true;\n\t          if (inputValue === \"false\") return false;\n\t        }\n\t        if (type === \"number\") {\n\t          const parsedValue = Number(inputValue);\n\t          if (!isNaN(parsedValue)) return parsedValue;\n\t        }\n\t        if (typeof inputValue === type) return inputValue;\n\t      }\n\t    }\n", "    return undefined;\n\t  }\n\t  /**\n\t   * Execute\n\t   * @private\n\t   * @param packet\n\t   */\n\t  private execute(packet: ChatSendBeforeEvent) {\n\t    const { message, sender } = packet;\n\t    if (!message.startsWith(this.commandPrefix)) return;\n", "    packet.cancel = true;\n\t    const args: string[] = message\n\t      .slice(this.commandPrefix.length)\n\t      .trim()\n\t      .match(/\"[^\"]+\"|\\S+/g)\n\t      .map((e) => e.replace(/\"/g, \"\"));\n\t    const commandArgs: string = args.shift().toLowerCase();\n\t    const commandName = this.getCommand(commandArgs);\n\t    if (\n\t      !commandName ||\n", "      (!!commandName?.private && !sender.isOp()) ||\n\t      (commandName?.requireTags.length > 0 &&\n\t        !commandName?.requireTags.every((i: any) =>\n\t          sender.getTags().includes(i)\n\t        ))\n\t    )\n\t      return this.failed.InvalidCommand(sender, commandArgs);\n\t    else\n\t      commandName?.callback({\n\t        DB: {\n", "          used: this.db,\n\t        },\n\t        inputs: {\n\t          getInput: (inputNumber: number) =>\n\t            this.getCommandInput(args, commandName.inputs, inputNumber),\n\t        },\n\t        raw: packet,\n\t        sender,\n\t        config: Config,\n\t      });\n", "  }\n\t}\n\tconst Command = new CommandClass();\n\texport { Command };\n"]}
{"filename": "src/main/@modules/handlers/interface/Form.Function.ts", "chunked_list": ["import { Player } from \"@minecraft/server\";\n\timport { FormCancelationReason } from \"@minecraft/server-ui\";\n\timport { ErrorClass } from \"../message/Error.Class\";\n\timport {\n\t  ActiveForm,\n\t  ActiveFormResponse,\n\t} from \"../../@types/handlers/interface/ActiveForm\";\n\t/**\n\t * Forced send form to player\n\t * @param formId - Form id\n", " * @param player - Player object\n\t */\n\tasync function SendActiveForm<T extends ActiveForm>(\n\t  formId: T,\n\t  player: Player\n\t): Promise<ActiveFormResponse<T>> {\n\t  try {\n\t    while (true) {\n\t      const response = await (formId as T).show(player);\n\t      if (response.cancelationReason !== FormCancelationReason.UserBusy)\n", "        return response as ActiveFormResponse<T>;\n\t    }\n\t  } catch (error) {\n\t    new ErrorClass().CustomError(\"SendActiveForm\", \"typeFunction\", error);\n\t  }\n\t}\n\texport { SendActiveForm };\n"]}
{"filename": "src/main/@modules/handlers/interface/Form.Class.ts", "chunked_list": ["import { Player, RawMessage } from \"@minecraft/server\";\n\timport {\n\t  ActionFormData,\n\t  MessageFormData,\n\t  ModalFormData,\n\t} from \"@minecraft/server-ui\";\n\timport { ErrorClass } from \"../message/Error.Class\";\n\timport * as Validation from \"../../utils/Validation.Function\";\n\timport {\n\t  FormTypeList,\n", "  FormTypes,\n\t  FormResponse,\n\t} from \"../../@types/handlers/interface/FormType\";\n\tclass FormClass<T extends FormTypeList> {\n\t  private type: string;\n\t  private typeMap: { [key: string]: any };\n\t  private error: ErrorClass;\n\t  private formType: FormTypes<T>;\n\t  /**\n\t   * Form class\n", "   * @param type - Form type (action, message, modal)\n\t   */\n\t  constructor(type: T) {\n\t    this.type = type;\n\t    this.typeMap = {\n\t      action: ActionFormData,\n\t      message: MessageFormData,\n\t      modal: ModalFormData,\n\t    };\n\t    this.error = new ErrorClass();\n", "    if (type.length === 0)\n\t      this.error.CustomError(\n\t        \"FormClass\",\n\t        \"constructor\",\n\t        \"type cannot be empty\"\n\t      );\n\t    if (Validation.isUndefined(this.typeMap[type]))\n\t      this.error.CustomError(\n\t        \"FormClass\",\n\t        \"constructor\",\n", "        \"unsupported type, available type (action, message, modal)\"\n\t      );\n\t    this.formType = new this.typeMap[type]();\n\t  }\n\t  /**\n\t   * AllForm: form title\n\t   * @param text - Title text\n\t   */\n\t  setTitle(text: string | RawMessage) {\n\t    this.formType.title(text);\n", "    return this;\n\t  }\n\t  /**\n\t   * Action and Message: form body\n\t   * @param text - Body text\n\t   */\n\t  setBody(text: string | RawMessage) {\n\t    if (\n\t      !(this.formType instanceof ActionFormData) ||\n\t      !(this.formType instanceof MessageFormData)\n", "    )\n\t      this.error.CustomError(\n\t        \"FormClass\",\n\t        \"setBody\",\n\t        \"Modal form don't have setBody method\"\n\t      );\n\t    (this.formType as ActionFormData | MessageFormData).body(text);\n\t    return this;\n\t  }\n\t  /**\n", "   * Action: form button\n\t   * @param text - Button text\n\t   * @param iconPath - Button icon (optional)\n\t   */\n\t  addButton(text: string | RawMessage, iconPath?: string) {\n\t    if (!(this.formType instanceof ActionFormData))\n\t      this.error.CustomError(\n\t        \"FormClass\",\n\t        \"addButton\",\n\t        \"Message and Modal form don't have addButton method\"\n", "      );\n\t    (this.formType as ActionFormData).button(text, iconPath);\n\t    return this;\n\t  }\n\t  /**\n\t   * Message: form button 1\n\t   * @param text - Button text\n\t   */\n\t  setButton1(text: string | RawMessage) {\n\t    if (!(this.formType instanceof MessageFormData))\n", "      this.error.CustomError(\n\t        \"FormClass\",\n\t        \"setButton1\",\n\t        \"Action and Modal form don't have setButton1 method\"\n\t      );\n\t    (this.formType as MessageFormData).button1(text);\n\t    return this;\n\t  }\n\t  /**\n\t   * Message: form button 2\n", "   * @param text - Button text\n\t   */\n\t  setButton2(text: string | RawMessage) {\n\t    if (!(this.formType instanceof MessageFormData))\n\t      this.error.CustomError(\n\t        \"FormClass\",\n\t        \"setButton2\",\n\t        \"Action and Modal form don't have setButton2 method\"\n\t      );\n\t    (this.formType as MessageFormData).button2(text);\n", "    return this;\n\t  }\n\t  /**\n\t   * Modal: form dropdown\n\t   * @param label - Label text\n\t   * @param options - Array options\n\t   * @param defaultValue - Default value array number (optional)\n\t   */\n\t  addDropdown(\n\t    label: string | RawMessage,\n", "    options: string[] | RawMessage[],\n\t    defaultValue?: number\n\t  ) {\n\t    if (!(this.formType instanceof ModalFormData))\n\t      this.error.CustomError(\n\t        \"FormClass\",\n\t        \"addDropdown\",\n\t        \"Action and Message form don't have addDropdown method\"\n\t      );\n\t    (this.formType as ModalFormData).dropdown(label, options, defaultValue);\n", "    return this;\n\t  }\n\t  /**\n\t   * Modal: form slider\n\t   * @param label - Label text\n\t   * @param minValue - Minimal slider value\n\t   * @param maxValue - Maximal slider value\n\t   * @param valueStep - Value step\n\t   * @param defaultValue - Default slider value (optional)\n\t   */\n", "  addSlider(\n\t    label: string | RawMessage,\n\t    minValue: number,\n\t    maxValue: number,\n\t    valueStep: number,\n\t    defaultValue?: number\n\t  ) {\n\t    if (!(this.formType instanceof ModalFormData))\n\t      this.error.CustomError(\n\t        \"FormClass\",\n", "        \"addSlider\",\n\t        \"Action and Message form don't have addSlider method\"\n\t      );\n\t    (this.formType as ModalFormData).slider(\n\t      label,\n\t      minValue,\n\t      maxValue,\n\t      valueStep,\n\t      defaultValue\n\t    );\n", "    return this;\n\t  }\n\t  /**\n\t   * Modal: form text field\n\t   * @param label - Label text\n\t   * @param placeholder - Placeholder text\n\t   * @param defaultValue - Default text value (optional)\n\t   */\n\t  addTextField(\n\t    label: string | RawMessage,\n", "    placeholder: string | RawMessage,\n\t    defaultValue?: string\n\t  ) {\n\t    if (!(this.formType instanceof ModalFormData))\n\t      this.error.CustomError(\n\t        \"FormClass\",\n\t        \"addTextField\",\n\t        \"Action and Message form don't have addTextField method\"\n\t      );\n\t    (this.formType as ModalFormData).textField(\n", "      label,\n\t      placeholder,\n\t      defaultValue\n\t    );\n\t    return this;\n\t  }\n\t  /**\n\t   * Modal: form toggle\n\t   * @param label - Label text\n\t   * @param defaultValue - Default toggle value (optional)\n", "   */\n\t  addToggle(label: string | RawMessage, defaultValue?: boolean) {\n\t    if (!(this.formType instanceof ModalFormData))\n\t      this.error.CustomError(\n\t        \"FormClass\",\n\t        \"addToggle\",\n\t        \"Action and Message form don't have addToggle method\"\n\t      );\n\t    (this.formType as ModalFormData).toggle(label, defaultValue);\n\t    return this;\n", "  }\n\t  /**\n\t   * Show message to player\n\t   * @param player - Player object\n\t   */\n\t  async sendForm(player: Player): Promise<FormResponse<T>> {\n\t    try {\n\t      const response = await this.formType.show(player);\n\t      return response as FormResponse<T>;\n\t    } catch (error) {\n", "      this.error.CustomError(\"FormClass\", \"sendForm\", error);\n\t    }\n\t  }\n\t}\n\texport { FormClass };\n"]}
{"filename": "src/main/@modules/handlers/world/World.Function.ts", "chunked_list": ["import { world, Player } from \"@minecraft/server\";\n\t/**\n\t * Get all online players\n\t */\n\tfunction getOnlinePlayers(): Player[] {\n\t  return world.getAllPlayers();\n\t}\n\texport { getOnlinePlayers };\n"]}
{"filename": "src/main/@modules/@types/events/SystemEventsType.d.ts", "chunked_list": ["import {\n\t  ScriptEventCommandMessageAfterEvent,\n\t  WatchdogTerminateBeforeEvent,\n\t} from \"@minecraft/server\";\n\ttype SystemEventsList = \"watchdogTerminate\" | \"scriptEventReceive\";\n\ttype SystemEventCallback<T extends SystemEventsList> =\n\t  T extends \"watchdogTerminate\"\n\t    ? WatchdogTerminateBeforeEvent\n\t    : T extends \"scriptEventReceive\"\n\t    ? ScriptEventCommandMessageAfterEvent\n", "    : undefined;\n"]}
{"filename": "src/main/@modules/@types/events/BeforeEventsType.d.ts", "chunked_list": ["import {\n\t  ChatSendBeforeEvent,\n\t  DataDrivenEntityTriggerBeforeEvent,\n\t  ExplosionBeforeEvent,\n\t  ItemDefinitionBeforeEventSignal,\n\t  ItemUseBeforeEvent,\n\t  ItemUseOnBeforeEvent,\n\t  PistonActivateBeforeEvent,\n\t} from \"@minecraft/server\";\n\ttype BeforeEventsList =\n", "  | \"chat\"\n\t  | \"dataDrivenEntity\"\n\t  | \"explosion\"\n\t  | \"itemDefinition\"\n\t  | \"itemUse\"\n\t  | \"itemUseOn\"\n\t  | \"pistonActivate\";\n\ttype BeforeEventCallback<T extends BeforeEventsList> = T extends \"chat\"\n\t  ? ChatSendBeforeEvent\n\t  : T extends \"dataDrivenEntity\"\n", "  ? DataDrivenEntityTriggerBeforeEvent\n\t  : T extends \"explosion\"\n\t  ? ExplosionBeforeEvent\n\t  : T extends \"itemDefinition\"\n\t  ? ItemDefinitionBeforeEventSignal\n\t  : T extends \"itemUse\"\n\t  ? ItemUseBeforeEvent\n\t  : T extends \"itemUseOn\"\n\t  ? ItemUseOnBeforeEvent\n\t  : T extends \"pistonActivate\"\n", "  ? PistonActivateBeforeEvent\n\t  : undefined;\n"]}
{"filename": "src/main/@modules/@types/events/AfterEventsType.d.ts", "chunked_list": ["import {\n\t  BlockBreakAfterEvent,\n\t  BlockExplodeAfterEvent,\n\t  BlockPlaceAfterEvent,\n\t  ButtonPushAfterEvent,\n\t  ChatSendAfterEvent,\n\t  DataDrivenEntityTriggerAfterEvent,\n\t  EffectAddAfterEvent,\n\t  EntityDieAfterEvent,\n\t  EntityHealthChangedAfterEvent,\n", "  EntityHitBlockAfterEvent,\n\t  EntityHitEntityAfterEvent,\n\t  EntityHurtAfterEvent,\n\t  EntityRemovedAfterEvent,\n\t  EntitySpawnAfterEvent,\n\t  ExplosionAfterEvent,\n\t  ItemCompleteUseAfterEvent,\n\t  ItemDefinitionAfterEventSignal,\n\t  ItemReleaseUseAfterEvent,\n\t  ItemStartUseAfterEvent,\n", "  ItemStartUseOnAfterEvent,\n\t  ItemStopUseAfterEvent,\n\t  ItemStopUseOnAfterEvent,\n\t  ItemUseAfterEvent,\n\t  ItemUseOnAfterEvent,\n\t  LeverActionAfterEvent,\n\t  MessageReceiveAfterEvent,\n\t  PistonActivateAfterEvent,\n\t  PlayerJoinAfterEvent,\n\t  PlayerLeaveAfterEvent,\n", "  PlayerSpawnAfterEvent,\n\t  PressurePlatePopAfterEvent,\n\t  PressurePlatePushAfterEvent,\n\t  ProjectileHitAfterEvent,\n\t  TargetBlockHitAfterEvent,\n\t  TripWireTripAfterEvent,\n\t  WeatherChangeAfterEvent,\n\t  WorldInitializeAfterEvent,\n\t} from \"@minecraft/server\";\n\ttype AfterEventsList =\n", "  | \"blockBreak\"\n\t  | \"blockExplode\"\n\t  | \"blockPlace\"\n\t  | \"buttonPush\"\n\t  | \"chat\"\n\t  | \"dataDrivenEntity\"\n\t  | \"effectAdd\"\n\t  | \"entityDie\"\n\t  | \"entityHealthChanged\"\n\t  | \"entityHitBlock\"\n", "  | \"entityHitEntity\"\n\t  | \"entityHurt\"\n\t  | \"entityRemoved\"\n\t  | \"entitySpawn\"\n\t  | \"explosion\"\n\t  | \"itemCompleteUse\"\n\t  | \"itemDefinition\"\n\t  | \"itemReleaseUse\"\n\t  | \"itemStartUse\"\n\t  | \"itemStartUseOn\"\n", "  | \"itemStopUse\"\n\t  | \"itemStopUseOn\"\n\t  | \"itemUse\"\n\t  | \"itemUseOn\"\n\t  | \"leverAction\"\n\t  | \"messageReceive\"\n\t  | \"pistonActivate\"\n\t  | \"playerJoin\"\n\t  | \"playerLeave\"\n\t  | \"playerSpawn\"\n", "  | \"pressurePlatePop\"\n\t  | \"pressurePlatePush\"\n\t  | \"projectileHit\"\n\t  | \"targetBlockHit\"\n\t  | \"tripWireTrip\"\n\t  | \"weatherChange\"\n\t  | \"worldInitialize\";\n\ttype AfterEventCallback<T extends AfterEventsList> = T extends \"blockBreak\"\n\t  ? BlockBreakAfterEvent\n\t  : T extends \"blockExplode\"\n", "  ? BlockExplodeAfterEvent\n\t  : T extends \"blockPlace\"\n\t  ? BlockPlaceAfterEvent\n\t  : T extends \"buttonPush\"\n\t  ? ButtonPushAfterEvent\n\t  : T extends \"chat\"\n\t  ? ChatSendAfterEvent\n\t  : T extends \"dataDrivenEntity\"\n\t  ? DataDrivenEntityTriggerAfterEvent\n\t  : T extends \"effectAdd\"\n", "  ? EffectAddAfterEvent\n\t  : T extends \"entityDie\"\n\t  ? EntityDieAfterEvent\n\t  : T extends \"entityHealthChanged\"\n\t  ? EntityHealthChangedAfterEvent\n\t  : T extends \"entityHitBlock\"\n\t  ? EntityHitBlockAfterEvent\n\t  : T extends \"entityHitEntity\"\n\t  ? EntityHitEntityAfterEvent\n\t  : T extends \"entityHurt\"\n", "  ? EntityHurtAfterEvent\n\t  : T extends \"entityRemoved\"\n\t  ? EntityRemovedAfterEvent\n\t  : T extends \"entitySpawn\"\n\t  ? EntitySpawnAfterEvent\n\t  : T extends \"explosion\"\n\t  ? ExplosionAfterEvent\n\t  : T extends \"itemCompleteUse\"\n\t  ? ItemCompleteUseAfterEvent\n\t  : T extends \"itemDefinition\"\n", "  ? ItemDefinitionAfterEventSignal\n\t  : T extends \"itemReleaseUse\"\n\t  ? ItemReleaseUseAfterEvent\n\t  : T extends \"itemStartUse\"\n\t  ? ItemStartUseAfterEvent\n\t  : T extends \"itemStartUseOn\"\n\t  ? ItemStartUseOnAfterEvent\n\t  : T extends \"itemStopUse\"\n\t  ? ItemStopUseAfterEvent\n\t  : T extends \"itemStopUseOn\"\n", "  ? ItemStopUseOnAfterEvent\n\t  : T extends \"itemUse\"\n\t  ? ItemUseAfterEvent\n\t  : T extends \"itemUseOn\"\n\t  ? ItemUseOnAfterEvent\n\t  : T extends \"leverAction\"\n\t  ? LeverActionAfterEvent\n\t  : T extends \"messageReceive\"\n\t  ? MessageReceiveAfterEvent\n\t  : T extends \"pistonActivate\"\n", "  ? PistonActivateAfterEvent\n\t  : T extends \"playerJoin\"\n\t  ? PlayerJoinAfterEvent\n\t  : T extends \"playerLeave\"\n\t  ? PlayerLeaveAfterEvent\n\t  : T extends \"playerSpawn\"\n\t  ? PlayerSpawnAfterEvent\n\t  : T extends \"pressurePlatePop\"\n\t  ? PressurePlatePopAfterEvent\n\t  : T extends \"pressurePlatePush\"\n", "  ? PressurePlatePushAfterEvent\n\t  : T extends \"projectileHit\"\n\t  ? ProjectileHitAfterEvent\n\t  : T extends \"targetBlockHit\"\n\t  ? TargetBlockHitAfterEvent\n\t  : T extends \"tripWireTrip\"\n\t  ? TripWireTripAfterEvent\n\t  : T extends \"weatherChange\"\n\t  ? WeatherChangeAfterEvent\n\t  : T extends \"worldInitialize\"\n", "  ? WorldInitializeAfterEvent\n\t  : undefined;\n"]}
{"filename": "src/main/@modules/@types/handlers/entity/PlayerType.d.ts", "chunked_list": ["type QueryName =\n\t  | \"isClimbing\"\n\t  | \"isFalling\"\n\t  | \"isFlying\"\n\t  | \"isGliding\"\n\t  | \"isInWater\"\n\t  | \"isJumping\"\n\t  | \"isOnGround\"\n\t  | \"isSneaking\"\n\t  | \"isSprinting\"\n", "  | \"isSwimming\";\n"]}
{"filename": "src/main/@modules/@types/handlers/command/RegistrationType.d.ts", "chunked_list": ["type inputs = [\"string\", \"boolean\", \"number\", \"playername\"]\n\ttype SupportedInputs = inputs[number][]"]}
{"filename": "src/main/@modules/@types/handlers/command/CommandBuilder.d.ts", "chunked_list": ["import { ChatSendBeforeEvent, Player } from \"@minecraft/server\";\n\timport { Config } from \"../../../../config\";\n\tinterface CommandBuild {\n\t  DB?: {\n\t    used: number;\n\t  };\n\t  sender?: Player;\n\t  inputs?: {\n\t    getInput: (inputNumber: number) => number | string | boolean | undefined;\n\t  };\n", "  config?: typeof Config;\n\t  raw: ChatSendBeforeEvent;\n\t}\n"]}
{"filename": "src/main/@modules/@types/handlers/interface/FormType.d.ts", "chunked_list": ["import {\n\t  ActionFormData,\n\t  ActionFormResponse,\n\t  MessageFormData,\n\t  MessageFormResponse,\n\t  ModalFormData,\n\t  ModalFormResponse,\n\t} from \"@minecraft/server-ui\";\n\ttype FormTypeList = \"action\" | \"message\" | \"modal\";\n\ttype FormTypes<T extends FormTypeList> = T extends \"action\"\n", "  ? ActionFormData\n\t  : T extends \"message\"\n\t  ? MessageFormData\n\t  : T extends \"modal\"\n\t  ? ModalFormData\n\t  : undefined;\n\ttype FormResponse<T> = T extends \"action\"\n\t  ? ActionFormResponse\n\t  : T extends \"message\"\n\t  ? MessageFormResponse\n", "  : T extends \"modal\"\n\t  ? ModalFormResponse\n\t  : undefined;\n"]}
{"filename": "src/main/@modules/@types/handlers/interface/ActiveForm.d.ts", "chunked_list": ["import {\n\t  ActionFormData,\n\t  ActionFormResponse,\n\t  MessageFormData,\n\t  MessageFormResponse,\n\t  ModalFormData,\n\t  ModalFormResponse,\n\t} from \"@minecraft/server-ui\";\n\ttype ActiveForm = ActionFormData | MessageFormData | ModalFormData;\n\ttype ActiveFormResponse<T extends ActiveForm> = T extends ActionFormData\n", "  ? ActionFormResponse\n\t  : T extends MessageFormData\n\t  ? MessageFormResponse\n\t  : T extends ModalFormData\n\t  ? ModalFormResponse\n\t  : undefined;\n"]}
{"filename": "src/main/@modules/@types/handlers/world/WorldType.d.ts", "chunked_list": ["import { Player } from \"@minecraft/server\";\n\ttype GetAllPlayers<T extends boolean> = T extends true ? number : Player[]"]}
