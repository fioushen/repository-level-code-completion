{"filename": "vite.config.ts", "chunked_list": ["import { externalizeDeps } from 'vite-plugin-externalize-deps';\n\timport dts from 'vite-plugin-dts';\n\timport { defineConfig } from 'vitest/config';\n\timport pkg from './package.json';\n\t/**\n\t * vite config\n\t * @ref https://vitejs.dev/\n\t * vitest config\n\t * @ref https://vitest.dev/\n\t */\n", "export default defineConfig({\n\t  plugins: [\n\t    externalizeDeps(),\n\t    dts({\n\t      outputDir: 'dist-types',\n\t    }),\n\t  ],\n\t  define: {\n\t    'process.env.PKG_NAME': JSON.stringify(pkg.name),\n\t    'process.env.PKG_VERSION': JSON.stringify(pkg.version),\n", "  },\n\t  build: {\n\t    minify: false,\n\t    sourcemap: true,\n\t    copyPublicDir: false,\n\t    reportCompressedSize: false,\n\t    lib: {\n\t      entry: ['src/index.ts', 'src/helpers.ts'],\n\t    },\n\t    rollupOptions: {\n", "      output: [\n\t        {\n\t          format: 'esm',\n\t          dir: 'dist-esm',\n\t          entryFileNames: '[name].mjs',\n\t          chunkFileNames: '[name].mjs',\n\t        },\n\t        {\n\t          format: 'cjs',\n\t          dir: 'dist-cjs',\n", "          entryFileNames: '[name].cjs',\n\t          chunkFileNames: '[name].cjs',\n\t        },\n\t      ],\n\t    },\n\t  },\n\t  test: {\n\t    globals: true,\n\t    env: {\n\t      PKG_NAME: 'pkg-name-for-test',\n", "      PKG_VERSION: 'pkg-version-for-test',\n\t    },\n\t    coverage: {\n\t      all: true,\n\t      include: ['src/**/*.ts'],\n\t      reporter: ['lcov', 'text'],\n\t    },\n\t  },\n\t});\n"]}
{"filename": "test/helpers.test.ts", "chunked_list": ["import { resolveURL } from '../src/helpers';\n\ttest('resolveBaseURL', () => {\n\t  expect(resolveURL('/', '/a/b')).toEqual('/a/b');\n\t  expect(resolveURL('/api/v1', '/a/b')).toEqual('/api/v1/a/b');\n\t  expect(resolveURL('https//example.com/api/v1', '/a/b')).toEqual('https//example.com/api/v1/a/b');\n\t  expect(resolveURL('https//example.com/api/v1/', '/a/b')).toEqual('https//example.com/api/v1/a/b');\n\t  expect(resolveURL('https//example.com/api/v1////', '/////a/b')).toEqual('https//example.com/api/v1/a/b');\n\t});\n"]}
{"filename": "test/helpers.ts", "chunked_list": ["import * as crypto from 'crypto';\n\timport fs from 'fs';\n\timport * as os from 'os';\n\timport { pkgName, pkgVersion } from '../src';\n\timport { isString } from '../src/utils/type-is';\n\timport path from 'path';\n\texport function writeFile(name: string, data: string | Record<string, any>) {\n\t  fs.writeFileSync(path.join(__dirname, 'files', name), isString(data) ? data : JSON.stringify(data), 'utf8');\n\t}\n\t/**\n", " * 创建临时目录【必存在】\n\t * @returns {string}\n\t */\n\texport function createTempDirname() {\n\t  const d = path.join(os.tmpdir(), pkgName, pkgVersion, crypto.randomUUID() + '.d');\n\t  fs.mkdirSync(d, { recursive: true });\n\t  return [\n\t    d,\n\t    () => {\n\t      try {\n", "        fs.rmSync(d, { force: true });\n\t      } catch (cause) {\n\t        // ignore\n\t      }\n\t    },\n\t  ] as const;\n\t}\n"]}
{"filename": "test/printers/DocumentPrinter.test.ts", "chunked_list": ["import type { TypeDocument } from '../../src/parsers/types';\n\timport { DocumentPrinter } from '../../src';\n\timport petStore3 from '../files/petStore3.types.json';\n\timport { writeFile } from '../helpers';\n\ttest('DocumentPrinter', () => {\n\t  const printer = new DocumentPrinter(petStore3 as TypeDocument);\n\t  const text = printer.print();\n\t  writeFile('petStore3.types.txt', text);\n\t  expect(text).toMatchInlineSnapshot(`\n\t    \"import type { OneOf } from 'openapi-axios/helpers';\n", "    import type { AxiosPromise, AxiosRequestConfig } from 'axios';\n\t    import {\n\t      DELETE,\n\t      GET,\n\t      HEAD,\n\t      OPTIONS,\n\t      PATCH,\n\t      POST,\n\t      PUT,\n\t      resolveURL,\n", "    } from 'openapi-axios/helpers';\n\t    import axios from 'axios';\n\t    const request = axios.request;\n\t    const BASE_URL = '/api/v3';\n\t    export type Address = {\n\t      /**\n\t       * @example Palo Alto\n\t       */\n\t      city?: string;\n\t      /**\n", "       * @example CA\n\t       */\n\t      state?: string;\n\t      /**\n\t       * @example 437 Lytton\n\t       */\n\t      street?: string;\n\t      /**\n\t       * @example 94301\n\t       */\n", "      zip?: string;\n\t    };\n\t    export type ApiResponse = {\n\t      /**\n\t       * @format int32\n\t       */\n\t      code?: number;\n\t      message?: string;\n\t      type?: string;\n\t    };\n", "    export type Category = {\n\t      /**\n\t       * @format int64\n\t       * @example 1\n\t       */\n\t      id?: number;\n\t      /**\n\t       * @example Dogs\n\t       */\n\t      name?: string;\n", "    };\n\t    export type Customer = {\n\t      address?: Array<Address>;\n\t      /**\n\t       * @format int64\n\t       * @example 100000\n\t       */\n\t      id?: number;\n\t      /**\n\t       * @example fehguy\n", "       */\n\t      username?: string;\n\t    };\n\t    export type Order = {\n\t      complete?: boolean;\n\t      /**\n\t       * @format int64\n\t       * @example 10\n\t       */\n\t      id?: number;\n", "      /**\n\t       * @format int64\n\t       * @example 198772\n\t       */\n\t      petId?: number;\n\t      /**\n\t       * @format int32\n\t       * @example 7\n\t       */\n\t      quantity?: number;\n", "      /**\n\t       * @format date-time\n\t       */\n\t      shipDate?: string;\n\t      /**\n\t       * @description Order Status\n\t       * @example approved\n\t       */\n\t      status?: 'placed' | 'approved' | 'delivered';\n\t    };\n", "    export type Pet = {\n\t      category?: Category;\n\t      /**\n\t       * @format int64\n\t       * @example 10\n\t       */\n\t      id?: number;\n\t      /**\n\t       * @example doggie\n\t       */\n", "      name: string;\n\t      photoUrls: Array<string>;\n\t      /**\n\t       * @description pet status in the store\n\t       */\n\t      status?: 'available' | 'pending' | 'sold';\n\t      tags?: Array<Tag>;\n\t    };\n\t    export type Tag = {\n\t      /**\n", "       * @format int64\n\t       */\n\t      id?: number;\n\t      name?: string;\n\t    };\n\t    export type User = {\n\t      /**\n\t       * @example john@email.com\n\t       */\n\t      email?: string;\n", "      /**\n\t       * @example John\n\t       */\n\t      firstName?: string;\n\t      /**\n\t       * @format int64\n\t       * @example 10\n\t       */\n\t      id?: number;\n\t      /**\n", "       * @example James\n\t       */\n\t      lastName?: string;\n\t      /**\n\t       * @example 12345\n\t       */\n\t      password?: string;\n\t      /**\n\t       * @example 12345\n\t       */\n", "      phone?: string;\n\t      /**\n\t       * @example theUser\n\t       */\n\t      username?: string;\n\t      /**\n\t       * @description User Status\n\t       * @format int32\n\t       * @example 1\n\t       */\n", "      userStatus?: number;\n\t    };\n\t    export type AddPetReqData = Pet;\n\t    export type AddPetResData = Pet;\n\t    /**\n\t     * @title Add a new pet to the store\n\t     * @description Add a new pet to the store\n\t     */\n\t    export async function addPet(\n\t      data: AddPetReqData,\n", "      config?: AxiosRequestConfig\n\t    ): AxiosPromise<AddPetResData> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/pet\\`),\n\t        method: POST,\n\t        data,\n\t        ...config,\n\t      });\n\t    }\n\t    export type UpdatePetReqData = Pet;\n", "    export type UpdatePetResData = Pet;\n\t    /**\n\t     * @title Update an existing pet\n\t     * @description Update an existing pet by Id\n\t     */\n\t    export async function updatePet(\n\t      data: UpdatePetReqData,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<UpdatePetResData> {\n\t      return request({\n", "        url: resolveURL(BASE_URL, \\`/pet\\`),\n\t        method: PUT,\n\t        data,\n\t        ...config,\n\t      });\n\t    }\n\t    export type DeletePetReqPath = {\n\t      /**\n\t       * @description Pet id to delete\n\t       * @format int64\n", "       */\n\t      petId: number;\n\t    };\n\t    /**\n\t     * @title Deletes a pet\n\t     * @description\n\t     */\n\t    export async function deletePet(\n\t      path: DeletePetReqPath,\n\t      config?: AxiosRequestConfig\n", "    ): AxiosPromise<never> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/pet/\\${path.petId}\\`),\n\t        method: DELETE,\n\t        ...config,\n\t      });\n\t    }\n\t    export type GetPetByIdReqPath = {\n\t      /**\n\t       * @description ID of pet to return\n", "       * @format int64\n\t       */\n\t      petId: number;\n\t    };\n\t    export type GetPetByIdResData = Pet;\n\t    /**\n\t     * @title Find pet by ID\n\t     * @description Returns a single pet\n\t     */\n\t    export async function getPetById(\n", "      path: GetPetByIdReqPath,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<GetPetByIdResData> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/pet/\\${path.petId}\\`),\n\t        method: GET,\n\t        ...config,\n\t      });\n\t    }\n\t    export type UpdatePetWithFormReqPath = {\n", "      /**\n\t       * @description ID of pet that needs to be updated\n\t       * @format int64\n\t       */\n\t      petId: number;\n\t    };\n\t    export type UpdatePetWithFormReqParams = {\n\t      /**\n\t       * @description Name of pet that needs to be updated\n\t       */\n", "      name?: string;\n\t      /**\n\t       * @description Status of pet that needs to be updated\n\t       */\n\t      status?: string;\n\t    };\n\t    /**\n\t     * @title Updates a pet in the store with form data\n\t     * @description\n\t     */\n", "    export async function updatePetWithForm(\n\t      path: UpdatePetWithFormReqPath,\n\t      params?: UpdatePetWithFormReqParams,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<never> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/pet/\\${path.petId}\\`),\n\t        method: POST,\n\t        params,\n\t        ...config,\n", "      });\n\t    }\n\t    export type UploadFileReqPath = {\n\t      /**\n\t       * @description ID of pet to update\n\t       * @format int64\n\t       */\n\t      petId: number;\n\t    };\n\t    export type UploadFileReqParams = {\n", "      /**\n\t       * @description Additional Metadata\n\t       */\n\t      additionalMetadata?: string;\n\t    };\n\t    export type UploadFileReqData = Blob;\n\t    export type UploadFileResData = ApiResponse;\n\t    /**\n\t     * @title uploads an image\n\t     * @description\n", "     */\n\t    export async function uploadFile(\n\t      path: UploadFileReqPath,\n\t      data: UploadFileReqData,\n\t      params?: UploadFileReqParams,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<UploadFileResData> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/pet/\\${path.petId}/uploadImage\\`),\n\t        method: POST,\n", "        params,\n\t        data,\n\t        ...config,\n\t      });\n\t    }\n\t    export type FindPetsByStatusReqParams = {\n\t      /**\n\t       * @description Status values that need to be considered for filter\n\t       * @default available\n\t       */\n", "      status?: 'available' | 'pending' | 'sold';\n\t    };\n\t    export type FindPetsByStatusResData = Array<Pet>;\n\t    /**\n\t     * @title Finds Pets by status\n\t     * @description Multiple status values can be provided with comma separated strings\n\t     */\n\t    export async function findPetsByStatus(\n\t      params?: FindPetsByStatusReqParams,\n\t      config?: AxiosRequestConfig\n", "    ): AxiosPromise<FindPetsByStatusResData> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/pet/findByStatus\\`),\n\t        method: GET,\n\t        params,\n\t        ...config,\n\t      });\n\t    }\n\t    export type FindPetsByTagsReqParams = {\n\t      /**\n", "       * @description Tags to filter by\n\t       */\n\t      tags?: Array<string>;\n\t    };\n\t    export type FindPetsByTagsResData = Array<Pet>;\n\t    /**\n\t     * @title Finds Pets by tags\n\t     * @description Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\n\t     */\n\t    export async function findPetsByTags(\n", "      params?: FindPetsByTagsReqParams,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<FindPetsByTagsResData> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/pet/findByTags\\`),\n\t        method: GET,\n\t        params,\n\t        ...config,\n\t      });\n\t    }\n", "    export type GetInventoryResData = {\n\t      /**\n\t       * @format int32\n\t       */\n\t      [key: string]: number;\n\t    };\n\t    /**\n\t     * @title Returns pet inventories by status\n\t     * @description Returns a map of status codes to quantities\n\t     */\n", "    export async function getInventory(\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<GetInventoryResData> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/store/inventory\\`),\n\t        method: GET,\n\t        ...config,\n\t      });\n\t    }\n\t    export type PlaceOrderReqData = Order;\n", "    export type PlaceOrderResData = Order;\n\t    /**\n\t     * @title Place an order for a pet\n\t     * @description Place a new order in the store\n\t     */\n\t    export async function placeOrder(\n\t      data: PlaceOrderReqData,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<PlaceOrderResData> {\n\t      return request({\n", "        url: resolveURL(BASE_URL, \\`/store/order\\`),\n\t        method: POST,\n\t        data,\n\t        ...config,\n\t      });\n\t    }\n\t    export type DeleteOrderReqPath = {\n\t      /**\n\t       * @description ID of the order that needs to be deleted\n\t       * @format int64\n", "       */\n\t      orderId: number;\n\t    };\n\t    /**\n\t     * @title Delete purchase order by ID\n\t     * @description For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors\n\t     */\n\t    export async function deleteOrder(\n\t      path: DeleteOrderReqPath,\n\t      config?: AxiosRequestConfig\n", "    ): AxiosPromise<never> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/store/order/\\${path.orderId}\\`),\n\t        method: DELETE,\n\t        ...config,\n\t      });\n\t    }\n\t    export type GetOrderByIdReqPath = {\n\t      /**\n\t       * @description ID of order that needs to be fetched\n", "       * @format int64\n\t       */\n\t      orderId: number;\n\t    };\n\t    export type GetOrderByIdResData = Order;\n\t    /**\n\t     * @title Find purchase order by ID\n\t     * @description For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.\n\t     */\n\t    export async function getOrderById(\n", "      path: GetOrderByIdReqPath,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<GetOrderByIdResData> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/store/order/\\${path.orderId}\\`),\n\t        method: GET,\n\t        ...config,\n\t      });\n\t    }\n\t    export type CreateUserReqData = User;\n", "    /**\n\t     * @title Create user\n\t     * @description This can only be done by the logged in user.\n\t     */\n\t    export async function createUser(\n\t      data: CreateUserReqData,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<never> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/user\\`),\n", "        method: POST,\n\t        data,\n\t        ...config,\n\t      });\n\t    }\n\t    export type DeleteUserReqPath = {\n\t      /**\n\t       * @description The name that needs to be deleted\n\t       */\n\t      username: string;\n", "    };\n\t    /**\n\t     * @title Delete user\n\t     * @description This can only be done by the logged in user.\n\t     */\n\t    export async function deleteUser(\n\t      path: DeleteUserReqPath,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<never> {\n\t      return request({\n", "        url: resolveURL(BASE_URL, \\`/user/\\${path.username}\\`),\n\t        method: DELETE,\n\t        ...config,\n\t      });\n\t    }\n\t    export type GetUserByNameReqPath = {\n\t      /**\n\t       * @description The name that needs to be fetched. Use user1 for testing.\n\t       */\n\t      username: string;\n", "    };\n\t    export type GetUserByNameResData = User;\n\t    /**\n\t     * @title Get user by user name\n\t     * @description\n\t     */\n\t    export async function getUserByName(\n\t      path: GetUserByNameReqPath,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<GetUserByNameResData> {\n", "      return request({\n\t        url: resolveURL(BASE_URL, \\`/user/\\${path.username}\\`),\n\t        method: GET,\n\t        ...config,\n\t      });\n\t    }\n\t    export type UpdateUserReqPath = {\n\t      /**\n\t       * @description name that need to be deleted\n\t       */\n", "      username: string;\n\t    };\n\t    export type UpdateUserReqData = User;\n\t    /**\n\t     * @title Update user\n\t     * @description This can only be done by the logged in user.\n\t     */\n\t    export async function updateUser(\n\t      path: UpdateUserReqPath,\n\t      data: UpdateUserReqData,\n", "      config?: AxiosRequestConfig\n\t    ): AxiosPromise<never> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/user/\\${path.username}\\`),\n\t        method: PUT,\n\t        data,\n\t        ...config,\n\t      });\n\t    }\n\t    export type CreateUsersWithListInputReqData = Array<User>;\n", "    export type CreateUsersWithListInputResData = User;\n\t    /**\n\t     * @title Creates list of users with given input array\n\t     * @description Creates list of users with given input array\n\t     */\n\t    export async function createUsersWithListInput(\n\t      data?: CreateUsersWithListInputReqData,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<CreateUsersWithListInputResData> {\n\t      return request({\n", "        url: resolveURL(BASE_URL, \\`/user/createWithList\\`),\n\t        method: POST,\n\t        data,\n\t        ...config,\n\t      });\n\t    }\n\t    export type LoginUserReqParams = {\n\t      /**\n\t       * @description The user name for login\n\t       */\n", "      username?: string;\n\t      /**\n\t       * @description The password for login in clear text\n\t       */\n\t      password?: string;\n\t    };\n\t    export type LoginUserResData = string;\n\t    /**\n\t     * @title Logs user into the system\n\t     * @description\n", "     */\n\t    export async function loginUser(\n\t      params?: LoginUserReqParams,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<LoginUserResData> {\n\t      return request({\n\t        url: resolveURL(BASE_URL, \\`/user/login\\`),\n\t        method: GET,\n\t        params,\n\t        ...config,\n", "      });\n\t    }\n\t    /**\n\t     * @title Logs out current logged in user session\n\t     * @description\n\t     */\n\t    export async function logoutUser(\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<never> {\n\t      return request({\n", "        url: resolveURL(BASE_URL, \\`/user/logout\\`),\n\t        method: GET,\n\t        ...config,\n\t      });\n\t    }\n\t    \"\n\t  `);\n\t});\n"]}
{"filename": "test/printers/CommentsPrinter.test.ts", "chunked_list": ["import { CommentsPrinter } from '../../src/printers/CommentsPrinter';\n\ttest('CommentsPrinter', () => {\n\t  const printer = new CommentsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t      baseURL: '/',\n\t    },\n\t    components: [],\n\t    paths: [],\n", "  });\n\t  expect(printer.printComments({})).toMatchInlineSnapshot('\"\"');\n\t  expect(\n\t    printer.printComments({\n\t      deprecated: true,\n\t    })\n\t  ).toMatchInlineSnapshot(`\n\t    \"/**\n\t     * @deprecated\n\t     */\"\n", "  `);\n\t  expect(\n\t    printer.printComments({\n\t      deprecated: true,\n\t      title: '一个注释标题',\n\t      description: '一个注释描述\\n第 2 行描述\\n第 3 行描述',\n\t      format: 'username',\n\t      example: 'const a = 1;\\nconst b = 2;',\n\t      default: '\"张三\"',\n\t    })\n", "  ).toMatchInlineSnapshot(`\n\t    \"/**\n\t     * @deprecated\n\t     * @title 一个注释标题\n\t     * @description 一个注释描述\n\t     * 第 2 行描述\n\t     * 第 3 行描述\n\t     * @format username\n\t     * @default \\\\\"张三\\\\\"\n\t     * @example const a = 1;\n", "     * const b = 2;\n\t     */\"\n\t  `);\n\t});\n"]}
{"filename": "test/printers/PathsPrinter.test.ts", "chunked_list": ["import { PathsPrinter } from '../../src/printers/PathsPrinter';\n\ttest('empty paths', () => {\n\t  const printer = new PathsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    components: [],\n\t    paths: [],\n\t  });\n", "  expect(printer.printPaths()).toMatchInlineSnapshot('\"\"');\n\t});\n\ttest('empty req && empty res', () => {\n\t  const printer = new PathsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    components: [],\n\t    paths: [\n", "      {\n\t        url: '/',\n\t        method: 'get',\n\t        name: 'getName',\n\t        description: 'ddd',\n\t        request: {},\n\t        response: {},\n\t      },\n\t    ],\n\t  });\n", "  expect(printer.printPaths()).toMatchInlineSnapshot(`\n\t    \"/**\n\t     * @description ddd\n\t     */\n\t    export async function getName(\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<never> {\n\t      return request({\n\t        url: \\`/\\`,\n\t        method: GET,\n", "        ...config,\n\t      });\n\t    }\n\t    \"\n\t  `);\n\t});\n\ttest('req.path', () => {\n\t  const printer = new PathsPrinter({\n\t    info: {\n\t      title: 'test',\n", "      version: '1.0.0',\n\t    },\n\t    components: [],\n\t    paths: [\n\t      {\n\t        url: '/api/name/{name}/age/{age}',\n\t        method: 'get',\n\t        name: 'getName',\n\t        description: 'ddd',\n\t        request: {\n", "          path: {\n\t            kind: 'origin',\n\t            name: 'T',\n\t            type: 'object',\n\t            required: true,\n\t            children: [\n\t              {\n\t                kind: 'origin',\n\t                type: 'string',\n\t                name: 'name',\n", "                required: true,\n\t              },\n\t              {\n\t                kind: 'origin',\n\t                type: 'number',\n\t                name: 'age',\n\t                required: true,\n\t              },\n\t            ],\n\t          },\n", "        },\n\t        response: {},\n\t      },\n\t    ],\n\t  });\n\t  expect(printer.printPaths()).toMatchInlineSnapshot(`\n\t    \"export type T = { name: string; age: number };\n\t    /**\n\t     * @description ddd\n\t     */\n", "    export async function getName(\n\t      path: T,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<never> {\n\t      return request({\n\t        url: \\`/api/name/\\${path.name}/age/\\${path.age}\\`,\n\t        method: GET,\n\t        ...config,\n\t      });\n\t    }\n", "    \"\n\t  `);\n\t});\n\ttest('req.query', () => {\n\t  const printer = new PathsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    components: [],\n", "    paths: [\n\t      {\n\t        url: '/',\n\t        method: 'get',\n\t        name: 'getName',\n\t        description: 'ddd',\n\t        request: {\n\t          query: {\n\t            kind: 'origin',\n\t            name: 'T',\n", "            type: 'object',\n\t            required: true,\n\t            children: [\n\t              {\n\t                kind: 'origin',\n\t                type: 'string',\n\t                name: 'name',\n\t                required: true,\n\t              },\n\t              {\n", "                kind: 'origin',\n\t                type: 'number',\n\t                name: 'age',\n\t                required: true,\n\t              },\n\t            ],\n\t          },\n\t        },\n\t        response: {},\n\t      },\n", "    ],\n\t  });\n\t  expect(printer.printPaths()).toMatchInlineSnapshot(`\n\t    \"export type T = { name: string; age: number };\n\t    /**\n\t     * @description ddd\n\t     */\n\t    export async function getName(\n\t      params: T,\n\t      config?: AxiosRequestConfig\n", "    ): AxiosPromise<never> {\n\t      return request({\n\t        url: \\`/\\`,\n\t        method: GET,\n\t        params,\n\t        ...config,\n\t      });\n\t    }\n\t    \"\n\t  `);\n", "});\n\ttest('req.body', () => {\n\t  const printer = new PathsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    components: [],\n\t    paths: [\n\t      {\n", "        url: '/',\n\t        method: 'get',\n\t        name: 'getName',\n\t        description: 'ddd',\n\t        request: {\n\t          body: {\n\t            kind: 'origin',\n\t            name: 'T',\n\t            type: 'object',\n\t            required: true,\n", "            children: [\n\t              {\n\t                kind: 'origin',\n\t                type: 'string',\n\t                name: 'name',\n\t                required: true,\n\t              },\n\t              {\n\t                kind: 'origin',\n\t                type: 'number',\n", "                name: 'age',\n\t                required: true,\n\t              },\n\t            ],\n\t          },\n\t        },\n\t        response: {},\n\t      },\n\t    ],\n\t  });\n", "  expect(printer.printPaths()).toMatchInlineSnapshot(`\n\t    \"export type T = { name: string; age: number };\n\t    /**\n\t     * @description ddd\n\t     */\n\t    export async function getName(\n\t      data: T,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<never> {\n\t      return request({\n", "        url: \\`/\\`,\n\t        method: GET,\n\t        data,\n\t        ...config,\n\t      });\n\t    }\n\t    \"\n\t  `);\n\t});\n\ttest('res.body', () => {\n", "  const printer = new PathsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    components: [],\n\t    paths: [\n\t      {\n\t        url: '/',\n\t        method: 'get',\n", "        name: 'getName',\n\t        description: 'ddd',\n\t        response: {\n\t          body: {\n\t            kind: 'origin',\n\t            name: 'T',\n\t            type: 'object',\n\t            required: true,\n\t            children: [\n\t              {\n", "                kind: 'origin',\n\t                type: 'string',\n\t                name: 'name',\n\t                required: true,\n\t              },\n\t              {\n\t                kind: 'origin',\n\t                type: 'number',\n\t                name: 'age',\n\t                required: true,\n", "              },\n\t            ],\n\t          },\n\t        },\n\t        request: {},\n\t      },\n\t    ],\n\t  });\n\t  expect(printer.printPaths()).toMatchInlineSnapshot(`\n\t    \"export type T = { name: string; age: number };\n", "    /**\n\t     * @description ddd\n\t     */\n\t    export async function getName(config?: AxiosRequestConfig): AxiosPromise<T> {\n\t      return request({\n\t        url: \\`/\\`,\n\t        method: GET,\n\t        ...config,\n\t      });\n\t    }\n", "    \"\n\t  `);\n\t});\n\ttest('req.path + res.body', () => {\n\t  const printer = new PathsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    components: [],\n", "    paths: [\n\t      {\n\t        name: 'getPetById',\n\t        method: 'get',\n\t        url: '/pet/{petId}',\n\t        title: 'Find pet by ID',\n\t        description: 'Returns a single pet',\n\t        request: {\n\t          path: {\n\t            kind: 'origin',\n", "            name: 'GetPetByIdRequestPath',\n\t            type: 'object',\n\t            required: true,\n\t            children: [\n\t              {\n\t                format: 'int64',\n\t                name: 'petId',\n\t                type: 'number',\n\t                required: true,\n\t                kind: 'origin',\n", "              },\n\t            ],\n\t          },\n\t        },\n\t        response: {\n\t          body: {\n\t            kind: 'alias',\n\t            refAble: false,\n\t            required: false,\n\t            name: 'GetPetByIdResponseBody',\n", "            ref: '#/components/schemas/Pet',\n\t            target: 'Pet',\n\t            origin: 'Pet',\n\t            props: [],\n\t          },\n\t        },\n\t      },\n\t    ],\n\t  });\n\t  expect(printer.printPaths()).toMatchInlineSnapshot(`\n", "    \"export type GetPetByIdRequestPath = {\n\t      /**\n\t       * @format int64\n\t       */\n\t      petId: number;\n\t    };\n\t    export type GetPetByIdResponseBody = Pet;\n\t    /**\n\t     * @title Find pet by ID\n\t     * @description Returns a single pet\n", "     */\n\t    export async function getPetById(\n\t      path: GetPetByIdRequestPath,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<GetPetByIdResponseBody> {\n\t      return request({\n\t        url: \\`/pet/\\${path.petId}\\`,\n\t        method: GET,\n\t        ...config,\n\t      });\n", "    }\n\t    \"\n\t  `);\n\t});\n\ttest('req.path + req.query + res.body', () => {\n\t  const printer = new PathsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n", "    components: [],\n\t    paths: [\n\t      {\n\t        name: 'uploadFile',\n\t        method: 'post',\n\t        url: '/pet/{petId}/uploadImage',\n\t        title: 'uploads an image',\n\t        description: '',\n\t        request: {\n\t          path: {\n", "            kind: 'origin',\n\t            name: 'UploadFileRequestPath',\n\t            type: 'object',\n\t            required: true,\n\t            children: [\n\t              {\n\t                format: 'int64',\n\t                name: 'petId',\n\t                type: 'number',\n\t                required: true,\n", "                kind: 'origin',\n\t              },\n\t            ],\n\t          },\n\t          query: {\n\t            kind: 'origin',\n\t            name: 'UploadFileRequestQuery',\n\t            type: 'object',\n\t            required: false,\n\t            children: [\n", "              {\n\t                name: 'additionalMetadata',\n\t                type: 'string',\n\t                required: false,\n\t                kind: 'origin',\n\t              },\n\t            ],\n\t          },\n\t        },\n\t        response: {\n", "          body: {\n\t            kind: 'alias',\n\t            refAble: false,\n\t            required: false,\n\t            name: 'UploadFileResponseBody',\n\t            ref: '#/components/schemas/ApiResponse',\n\t            target: 'ApiResponse',\n\t            origin: 'ApiResponse',\n\t            props: [],\n\t          },\n", "        },\n\t      },\n\t    ],\n\t  });\n\t  expect(printer.printPaths()).toMatchInlineSnapshot(`\n\t    \"export type UploadFileRequestPath = {\n\t      /**\n\t       * @format int64\n\t       */\n\t      petId: number;\n", "    };\n\t    export type UploadFileRequestQuery = { additionalMetadata?: string };\n\t    export type UploadFileResponseBody = ApiResponse;\n\t    /**\n\t     * @title uploads an image\n\t     * @description\n\t     */\n\t    export async function uploadFile(\n\t      path: UploadFileRequestPath,\n\t      params?: UploadFileRequestQuery,\n", "      config?: AxiosRequestConfig\n\t    ): AxiosPromise<UploadFileResponseBody> {\n\t      return request({\n\t        url: \\`/pet/\\${path.petId}/uploadImage\\`,\n\t        method: POST,\n\t        params,\n\t        ...config,\n\t      });\n\t    }\n\t    \"\n", "  `);\n\t});\n\ttest('req.path + req.query + req.body + res.body', () => {\n\t  const printer = new PathsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    components: [],\n\t    paths: [\n", "      {\n\t        name: 'uploadFile',\n\t        method: 'post',\n\t        url: '/pet/{petId}/uploadImage',\n\t        title: 'uploads an image',\n\t        description: '',\n\t        request: {\n\t          path: {\n\t            kind: 'origin',\n\t            name: 'UploadFileRequestPath',\n", "            type: 'object',\n\t            required: true,\n\t            children: [\n\t              {\n\t                format: 'int64',\n\t                name: 'petId',\n\t                type: 'number',\n\t                required: true,\n\t                kind: 'origin',\n\t              },\n", "            ],\n\t          },\n\t          query: {\n\t            kind: 'origin',\n\t            name: 'UploadFileRequestQuery',\n\t            type: 'object',\n\t            required: false,\n\t            children: [\n\t              {\n\t                name: 'additionalMetadata',\n", "                type: 'string',\n\t                required: false,\n\t                kind: 'origin',\n\t              },\n\t            ],\n\t          },\n\t          body: {\n\t            kind: 'origin',\n\t            name: 'UploadFileRequestBody',\n\t            type: 'array',\n", "            required: true,\n\t            children: [\n\t              {\n\t                name: 'additionalMetadata',\n\t                type: 'string',\n\t                required: false,\n\t                kind: 'origin',\n\t              },\n\t              {\n\t                format: 'int32',\n", "                name: '[key: string]',\n\t                type: 'number',\n\t                required: true,\n\t                kind: 'origin',\n\t              },\n\t            ],\n\t          },\n\t        },\n\t        response: {\n\t          body: {\n", "            kind: 'alias',\n\t            refAble: false,\n\t            required: false,\n\t            name: 'UploadFileResponseBody',\n\t            ref: '#/components/schemas/ApiResponse',\n\t            target: 'ApiResponse',\n\t            origin: 'ApiResponse',\n\t            props: [],\n\t          },\n\t        },\n", "      },\n\t    ],\n\t  });\n\t  expect(printer.printPaths()).toMatchInlineSnapshot(`\n\t    \"export type UploadFileRequestPath = {\n\t      /**\n\t       * @format int64\n\t       */\n\t      petId: number;\n\t    };\n", "    export type UploadFileRequestQuery = { additionalMetadata?: string };\n\t    export type UploadFileRequestBody = Array<\n\t      | string\n\t      /**\n\t       * @format int32\n\t       */\n\t      | number\n\t    >;\n\t    export type UploadFileResponseBody = ApiResponse;\n\t    /**\n", "     * @title uploads an image\n\t     * @description\n\t     */\n\t    export async function uploadFile(\n\t      path: UploadFileRequestPath,\n\t      data: UploadFileRequestBody,\n\t      params?: UploadFileRequestQuery,\n\t      config?: AxiosRequestConfig\n\t    ): AxiosPromise<UploadFileResponseBody> {\n\t      return request({\n", "        url: \\`/pet/\\${path.petId}/uploadImage\\`,\n\t        method: POST,\n\t        params,\n\t        data,\n\t        ...config,\n\t      });\n\t    }\n\t    \"\n\t  `);\n\t});\n"]}
{"filename": "test/printers/ComponentsPrinter.test.ts", "chunked_list": ["import { ComponentsPrinter } from '../../src/printers/ComponentsPrinter';\n\ttest('empty components', () => {\n\t  const printer = new ComponentsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t      baseURL: '/',\n\t    },\n\t    components: [],\n\t    paths: [],\n", "  });\n\t  const text = printer.printComponents();\n\t  expect(text).toEqual('');\n\t});\n\ttest('alias', () => {\n\t  const printer = new ComponentsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t      baseURL: '/',\n", "    },\n\t    components: [\n\t      {\n\t        kind: 'alias',\n\t        name: 'O',\n\t        target: 'P',\n\t        origin: 'Q',\n\t        props: [],\n\t        refAble: true,\n\t        required: true,\n", "        description: 'd1',\n\t      },\n\t      {\n\t        kind: 'alias',\n\t        name: 'O',\n\t        target: 'P',\n\t        origin: 'Q',\n\t        props: ['q1', 'q2'],\n\t        refAble: true,\n\t        required: true,\n", "        description: 'd2',\n\t      },\n\t    ],\n\t    paths: [],\n\t  });\n\t  const text = printer.printComponents();\n\t  expect(text).toMatchInlineSnapshot(`\n\t    \"/**\n\t     * @description d1\n\t     */\n", "    export type O = Q;\n\t    /**\n\t     * @description d2\n\t     */\n\t    export type O = Q['q1']['q2'];\n\t    \"\n\t  `);\n\t});\n\ttest('origin primitive', () => {\n\t  const printer = new ComponentsPrinter({\n", "    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t      baseURL: '/',\n\t    },\n\t    components: [\n\t      {\n\t        kind: 'origin',\n\t        type: 'number',\n\t        name: 'N1',\n", "        required: true,\n\t        description: 'ddd1',\n\t      },\n\t      {\n\t        kind: 'origin',\n\t        type: 'string',\n\t        name: 'S1',\n\t        required: true,\n\t        description: 'ddd2',\n\t      },\n", "      {\n\t        kind: 'origin',\n\t        type: 'boolean',\n\t        name: 'B1',\n\t        required: true,\n\t      },\n\t      {\n\t        kind: 'origin',\n\t        type: 'never',\n\t        name: 'N2',\n", "        required: true,\n\t      },\n\t    ],\n\t    paths: [],\n\t  });\n\t  const text = printer.printComponents();\n\t  expect(text).toMatchInlineSnapshot(`\n\t    \"/**\n\t     * @description ddd1\n\t     */\n", "    export type N1 = number;\n\t    /**\n\t     * @description ddd2\n\t     */\n\t    export type S1 = string;\n\t    export type B1 = boolean;\n\t    export type N2 = never;\n\t    \"\n\t  `);\n\t});\n", "test('origin enum', () => {\n\t  const printer = new ComponentsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t      baseURL: '/',\n\t    },\n\t    components: [\n\t      {\n\t        kind: 'origin',\n", "        type: 'string',\n\t        name: 'N1',\n\t        required: true,\n\t        description: 'ddd1',\n\t        enum: ['aaa', 'bbb', 'ccc'],\n\t      },\n\t    ],\n\t    paths: [],\n\t  });\n\t  const text = printer.printComponents();\n", "  expect(text).toMatchInlineSnapshot(`\n\t    \"/**\n\t     * @description ddd1\n\t     */\n\t    export type N1 = 'aaa' | 'bbb' | 'ccc';\n\t    \"\n\t  `);\n\t});\n\ttest('origin object', () => {\n\t  const printer = new ComponentsPrinter({\n", "    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t      baseURL: '/',\n\t    },\n\t    components: [\n\t      {\n\t        kind: 'origin',\n\t        type: 'object',\n\t        name: 'O1',\n", "        required: true,\n\t        description: 'ddd1',\n\t        children: [\n\t          {\n\t            kind: 'origin',\n\t            type: 'string',\n\t            name: 'sss',\n\t            required: true,\n\t            description: 'ddd2',\n\t          },\n", "          {\n\t            kind: 'alias',\n\t            name: 'ooo',\n\t            target: 'P',\n\t            origin: 'Q',\n\t            props: ['q1', 'q2'],\n\t            refAble: false,\n\t            required: false,\n\t            description: 'ddd3',\n\t          },\n", "          {\n\t            kind: 'origin',\n\t            type: 'object',\n\t            name: 'ppp',\n\t            required: true,\n\t            children: [\n\t              {\n\t                kind: 'origin',\n\t                type: 'number',\n\t                name: 'nnn',\n", "                required: true,\n\t              },\n\t              {\n\t                kind: 'alias',\n\t                name: 'qqq',\n\t                target: 'X',\n\t                origin: 'X',\n\t                props: [],\n\t                refAble: false,\n\t                required: false,\n", "              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t    paths: [],\n\t  });\n\t  const text = printer.printComponents();\n\t  expect(text).toMatchInlineSnapshot(`\n", "    \"/**\n\t     * @description ddd1\n\t     */\n\t    export type O1 = {\n\t      /**\n\t       * @description ddd2\n\t       */\n\t      sss: string;\n\t      /**\n\t       * @description ddd3\n", "       */\n\t      ooo?: Q['q1']['q2'];\n\t      ppp: { nnn: number; qqq?: X };\n\t    };\n\t    \"\n\t  `);\n\t});\n\ttest('origin object additional', () => {\n\t  const printer = new ComponentsPrinter({\n\t    info: {\n", "      title: 'test',\n\t      version: '1.0.0',\n\t      baseURL: '/',\n\t    },\n\t    components: [\n\t      {\n\t        kind: 'origin',\n\t        type: 'object',\n\t        name: 'O1',\n\t        required: true,\n", "        description: 'ddd1',\n\t        children: [\n\t          {\n\t            kind: 'origin',\n\t            type: 'string',\n\t            name: 'sss',\n\t            required: true,\n\t            description: 'ddd2',\n\t          },\n\t          {\n", "            kind: 'alias',\n\t            name: 'ooo',\n\t            target: 'P',\n\t            origin: 'Q',\n\t            props: ['q1', 'q2'],\n\t            refAble: false,\n\t            required: false,\n\t            description: 'ddd3',\n\t          },\n\t          {\n", "            kind: 'origin',\n\t            type: 'object',\n\t            name: 'ppp',\n\t            required: true,\n\t            children: [\n\t              {\n\t                kind: 'origin',\n\t                type: 'number',\n\t                name: 'nnn',\n\t                required: true,\n", "              },\n\t              {\n\t                kind: 'alias',\n\t                name: 'qqq',\n\t                target: 'X',\n\t                origin: 'X',\n\t                props: [],\n\t                refAble: false,\n\t                required: false,\n\t              },\n", "              {\n\t                format: 'int32',\n\t                name: '[key: string]',\n\t                type: 'number',\n\t                required: true,\n\t                kind: 'origin',\n\t              },\n\t            ],\n\t          },\n\t        ],\n", "      },\n\t    ],\n\t    paths: [],\n\t  });\n\t  const text = printer.printComponents();\n\t  expect(text).toMatchInlineSnapshot(`\n\t    \"/**\n\t     * @description ddd1\n\t     */\n\t    export type O1 = {\n", "      /**\n\t       * @description ddd2\n\t       */\n\t      sss: string;\n\t      /**\n\t       * @description ddd3\n\t       */\n\t      ooo?: Q['q1']['q2'];\n\t      ppp: {\n\t        nnn: number;\n", "        qqq?: X;\n\t        /**\n\t         * @format int32\n\t         */\n\t        [key: string]: number;\n\t      };\n\t    };\n\t    \"\n\t  `);\n\t});\n", "test('origin array', () => {\n\t  const printer = new ComponentsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t      baseURL: '/',\n\t    },\n\t    components: [\n\t      {\n\t        kind: 'origin',\n", "        type: 'array',\n\t        name: 'A',\n\t        required: true,\n\t        description: 'ddd1',\n\t        children: [\n\t          {\n\t            kind: 'origin',\n\t            name: 'A[]',\n\t            type: 'string',\n\t            required: false,\n", "            description: 'ddd2',\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t    paths: [],\n\t  });\n\t  const text = printer.printComponents();\n\t  expect(text).toMatchInlineSnapshot(`\n\t    \"/**\n", "     * @description ddd1\n\t     */\n\t    export type A = Array</**\n\t     * @description ddd2\n\t     */\n\t    string>;\n\t    \"\n\t  `);\n\t});\n\ttest('origin array additional', () => {\n", "  const printer = new ComponentsPrinter({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t      baseURL: '/',\n\t    },\n\t    components: [\n\t      {\n\t        kind: 'origin',\n\t        type: 'array',\n", "        name: 'A',\n\t        required: true,\n\t        description: 'ddd1',\n\t        children: [\n\t          {\n\t            kind: 'origin',\n\t            name: 'A[]',\n\t            type: 'string',\n\t            required: false,\n\t            description: 'ddd2',\n", "          },\n\t          {\n\t            kind: 'alias',\n\t            name: '[key: string]',\n\t            target: 'T',\n\t            origin: 'T',\n\t            props: [],\n\t            refAble: false,\n\t            required: false,\n\t            ref: '#/components/schema/T',\n", "            description: 'ddd3',\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t    paths: [],\n\t  });\n\t  const text = printer.printComponents();\n\t  expect(text).toMatchInlineSnapshot(`\n\t    \"/**\n", "     * @description ddd1\n\t     */\n\t    export type A = Array<\n\t      /**\n\t       * @description ddd2\n\t       */\n\t      | string\n\t      /**\n\t       * @description ddd3\n\t       */\n", "      | T\n\t    >;\n\t    \"\n\t  `);\n\t});\n"]}
{"filename": "test/utils/string.test.ts", "chunked_list": ["import {\n\t  buildName,\n\t  findOrigin,\n\t  joinSlices,\n\t  nextUniqueName,\n\t  type RefInfo,\n\t  refToType,\n\t  toTypePath,\n\t  varString,\n\t} from '../../src/utils/string';\n", "test('buildName', () => {\n\t  expect(buildName('!')).toEqual('unnamed');\n\t  expect(buildName('??')).toEqual('unnamed');\n\t  expect(buildName('hello-world')).toEqual('helloWorld');\n\t  expect(buildName('hello-world123')).toEqual('helloWorld123');\n\t  expect(buildName('123hello-world123')).toEqual('helloWorld123');\n\t  expect(buildName('123hello-world123')).toEqual('helloWorld123');\n\t  expect(buildName('[[[123hello-world123]]]')).toEqual('helloWorld123');\n\t  expect(buildName('[[[123hello-world123]]]', true)).toEqual('HelloWorld123');\n\t});\n", "test('refToType', () => {\n\t  expect(refToType('#/components/schemas/T')).toEqual<RefInfo>({\n\t    type: 'T',\n\t    base: '#/components/schemas/T',\n\t    props: [],\n\t  });\n\t  expect(refToType('#/components/schemas/T/oo')).toEqual<RefInfo>({\n\t    type: 'T',\n\t    base: '#/components/schemas/T',\n\t    props: ['oo'],\n", "  });\n\t  expect(refToType('#/components/schemas/T/oo/pp/qq')).toEqual<RefInfo>({\n\t    type: 'T',\n\t    base: '#/components/schemas/T',\n\t    props: ['oo', 'pp', 'qq'],\n\t  });\n\t});\n\ttest('findOrigin', () => {\n\t  // a -> b -> c -> d\n\t  // x -> y\n", "  const relation = new Map([\n\t    ['a', 'b'],\n\t    ['b', 'c'],\n\t    ['c', 'd'],\n\t    ['x', 'y'],\n\t  ]);\n\t  expect(findOrigin('a', relation)).toBe('d');\n\t  expect(findOrigin('x', relation)).toBe('y');\n\t  expect(findOrigin('y', relation)).toBe('y');\n\t});\n", "test('varString', () => {\n\t  expect(varString('/a/b')).toEqual('/a/b');\n\t  expect(varString('/a/b/{cc}')).toEqual('/a/b/${cc}');\n\t  expect(varString('/a/b/{cc}/dd/{ee}')).toEqual('/a/b/${cc}/dd/${ee}');\n\t  expect(varString('/a/b/{cc}/dd/{ee}', 'path')).toEqual('/a/b/${path.cc}/dd/${path.ee}');\n\t  expect(varString('/a/b/{cc}/dd/{ee}/ff/{-ff-}', 'path')).toEqual('/a/b/${path.cc}/dd/${path.ee}/ff/${path[\"-ff-\"]}');\n\t});\n\ttest('toTypePath', () => {\n\t  expect(toTypePath([])).toEqual('');\n\t  expect(toTypePath(['a'])).toEqual('[\"a\"]');\n", "  expect(toTypePath(['a', 'b'])).toEqual('[\"a\"][\"b\"]');\n\t});\n\ttest('joinSlices', () => {\n\t  expect(joinSlices(['', undefined, ''])).toEqual('');\n\t  expect(joinSlices(['1', undefined, '2', ''])).toEqual('1\\n2');\n\t});\n\ttest('nextUniqueName', () => {\n\t  const map = new Map<string, number>();\n\t  expect(nextUniqueName('abc', map)).toBe('abc');\n\t  expect(nextUniqueName('abc', map)).toBe('abc2');\n", "  expect(nextUniqueName('abc', map)).toBe('abc3');\n\t  expect(nextUniqueName('abc2', map)).toBe('abc4');\n\t});\n"]}
{"filename": "test/utils/type-is.test.ts", "chunked_list": ["import { isVarName } from '../../src/utils/type-is';\n\ttest('isVarName', () => {\n\t  expect(isVarName('')).toBe(false);\n\t  expect(isVarName('a')).toBe(true);\n\t  expect(isVarName('$a')).toBe(true);\n\t  expect(isVarName('_a')).toBe(true);\n\t  expect(isVarName('1a')).toBe(false);\n\t});\n"]}
{"filename": "test/generators/generator.test.ts", "chunked_list": ["import fs from 'fs';\n\timport path from 'path';\n\timport { Generator } from '../../src/generators/Generator';\n\timport { createTempDirname } from '../helpers';\n\ttest('Generator', async () => {\n\t  const [tempDir, clean] = createTempDirname();\n\t  const generator = new Generator({\n\t    cwd: tempDir,\n\t    openAPIs: [\n\t      {\n", "        name: 'petStore3',\n\t        document: path.join(__dirname, '../files/petStore3.openapi.json'),\n\t      },\n\t    ],\n\t  });\n\t  const fn1 = vi.fn();\n\t  generator.on('start', fn1);\n\t  const fn2 = vi.fn();\n\t  generator.on('end', fn2);\n\t  const fn3 = vi.fn();\n", "  generator.on('process', fn3);\n\t  const fn4 = vi.fn();\n\t  generator.on('error', fn4);\n\t  await generator.generate();\n\t  console.log(tempDir);\n\t  expect(fs.existsSync(path.join(tempDir, 'src/apis/petStore3.ts'))).toBe(true);\n\t  expect(fn1).toBeCalledTimes(1);\n\t  expect(fn2).toBeCalledTimes(1);\n\t  expect(fn3).toBeCalledTimes(1 /*reading*/ + 1 /*parsing*/ + 1 /*printing*/ + 1 /*writing*/ + 1 /*generated*/);\n\t  expect(fn4).toBeCalledTimes(0);\n", "  clean();\n\t});\n"]}
{"filename": "test/generators/commands.test.ts", "chunked_list": ["import fs from 'fs';\n\timport path from 'path';\n\timport { configFileNameOrder, resolveConfig, resolveConfigFile, run } from '../../src/generators/command';\n\timport type { OpenAPIV3Document } from '../../src/types/openapi';\n\timport { createTempDirname } from '../helpers';\n\ttest('resolveConfigFile', async () => {\n\t  const [cwd, clean] = createTempDirname();\n\t  expect(resolveConfigFile(cwd)).toBeUndefined();\n\t  [...configFileNameOrder].reverse().forEach((name, index) => {\n\t    const file1 = path.join(cwd, name);\n", "    const file2 = path.join(cwd, configFileNameOrder[configFileNameOrder.length - 1 - index]);\n\t    fs.writeFileSync(file1, '', 'utf8');\n\t    expect(resolveConfigFile(cwd)).toBe(file2);\n\t  });\n\t  clean();\n\t});\n\ttest('resolveConfig', async () => {\n\t  const [cwd, clean] = createTempDirname();\n\t  expect(() => resolveConfig(cwd)).toThrow('配置文件未找到');\n\t  const file = path.join(cwd, configFileNameOrder[0]);\n", "  fs.writeFileSync(file, '', 'utf8');\n\t  expect(() => resolveConfig(cwd)).toThrow('#/openAPIs - Required');\n\t  fs.writeFileSync(\n\t    file,\n\t    `module.exports = {\n\t    openAPIs: []\n\t  };`,\n\t    'utf8'\n\t  );\n\t  expect(() => resolveConfig(cwd)).toThrow('#/openAPIs - Array must contain at least 1 element(s)');\n", "  fs.writeFileSync(\n\t    file,\n\t    `module.exports = {\n\t    openAPIs: [{name: \"test\"}]\n\t  };`,\n\t    'utf8'\n\t  );\n\t  expect(() => resolveConfig(cwd)).toThrow('#/openAPIs/0/document - Invalid input');\n\t  fs.writeFileSync(\n\t    file,\n", "    `module.exports = {\n\t    openAPIs: [{name: \"test\", \"document\": \"test.openapi.json\"}]\n\t  };`,\n\t    'utf8'\n\t  );\n\t  expect(() => resolveConfig(cwd)).not.toThrow();\n\t  clean();\n\t});\n\ttest('run', async () => {\n\t  const [cwd, clean] = createTempDirname();\n", "  const file = path.join(cwd, configFileNameOrder[0]);\n\t  fs.writeFileSync(\n\t    path.join(cwd, 'test.openapi.json'),\n\t    JSON.stringify({\n\t      info: {\n\t        title: 'test',\n\t        version: '1.0.0',\n\t      },\n\t      openapi: '3.0.0',\n\t      paths: {},\n", "    } as OpenAPIV3Document)\n\t  );\n\t  fs.writeFileSync(\n\t    file,\n\t    `module.exports = {\n\t    openAPIs: [{name: \"test\", \"document\": \"test.openapi.json\"}]\n\t  };`,\n\t    'utf8'\n\t  );\n\t  await run(cwd);\n", "  expect(fs.existsSync(path.join(cwd, 'src/apis/test.ts'))).toBe(true);\n\t  clean();\n\t});\n"]}
{"filename": "test/generators/Logger.test.ts", "chunked_list": ["import { Logger } from '../../src/generators/Logger';\n\ttest('Logger', async () => {\n\t  const logger = new Logger();\n\t  logger.pipeConfigError(new Error('test error'));\n\t  logger.pipeStartEvent({\n\t    count: 99,\n\t  });\n\t  logger.pipeProcessEvent({\n\t    index: 5,\n\t    count: 99,\n", "    stage: 'generated',\n\t    filePath: '/a/b/c/d/e/f',\n\t    options: {\n\t      cwd: '/a/b/c',\n\t      dest: '',\n\t      name: 'test',\n\t      document: {\n\t        info: {\n\t          title: 'test',\n\t          version: '1.0.0',\n", "        },\n\t        openapi: '3.0.0',\n\t        paths: {},\n\t      },\n\t    },\n\t  });\n\t  logger.pipeEndEvent({\n\t    count: 99,\n\t  });\n\t  logger.pipeErrorEvent(new Error('test error'), {\n", "    count: 99,\n\t  });\n\t  expect(logger).toBeInstanceOf(Logger);\n\t});\n"]}
{"filename": "test/generators/Reader.test.ts", "chunked_list": ["import path from 'path';\n\timport { Reader } from '../../src/generators/Reader';\n\ttest('read local', async () => {\n\t  const reader = new Reader();\n\t  reader.cwd = path.resolve(__dirname, '../files');\n\t  const document = await reader.read('petStore3.openapi.json');\n\t  expect(document.openapi).toBeTypeOf('string');\n\t});\n\ttest('read remote', async () => {\n\t  const reader = new Reader();\n", "  const document = await reader.read('https://gw.alipayobjects.com/os/antfincdn/LyDMjDyIhK/1611471979478-opa.json');\n\t  expect(document.openapi).toBeTypeOf('string');\n\t});\n\ttest('read object', async () => {\n\t  const reader = new Reader();\n\t  const document = await reader.read({\n\t    info: {\n\t      title: 'test',\n\t      version: '1',\n\t    },\n", "    openapi: '3.0.0',\n\t    paths: {},\n\t  });\n\t  expect(document.openapi).toBeTypeOf('string');\n\t});\n"]}
{"filename": "test/parsers/PathsParser.test.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\n\timport { PathsParser } from '../../src/parsers/PathsParser';\n\timport type { TypeOperations } from '../../src/parsers/types';\n\timport HttpMethods = OpenAPIV3.HttpMethods;\n\ttest('empty paths keys', async () => {\n\t  const parser = new PathsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n", "    openapi: '3.0.0',\n\t    paths: {},\n\t  });\n\t  const t = parser.parsePaths();\n\t  expect(t).toEqual<TypeOperations>([]);\n\t});\n\ttest('empty path item keys', async () => {\n\t  const parser = new PathsParser({\n\t    info: {\n\t      title: 'test',\n", "      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {\n\t      '/pet': {},\n\t    },\n\t  });\n\t  const t = parser.parsePaths();\n\t  expect(t).toEqual<TypeOperations>([]);\n\t});\n", "test('empty path item method responses keys', async () => {\n\t  const parser = new PathsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {\n\t      '/pet': {\n\t        get: {\n", "          responses: {},\n\t        },\n\t      },\n\t    },\n\t  });\n\t  const t = parser.parsePaths();\n\t  expect(t).toEqual<TypeOperations>([\n\t    {\n\t      name: 'getPet',\n\t      method: OpenAPIV3.HttpMethods.GET,\n", "      url: '/pet',\n\t      request: {},\n\t      response: {},\n\t    },\n\t  ]);\n\t});\n\ttest('empty path item method responses keys + specify operationId', async () => {\n\t  const parser = new PathsParser({\n\t    info: {\n\t      title: 'test',\n", "      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {\n\t      '/pet': {\n\t        get: {\n\t          operationId: 'findPet',\n\t          responses: {},\n\t        },\n\t      },\n", "    },\n\t  });\n\t  const t = parser.parsePaths();\n\t  expect(t).toEqual<TypeOperations>([\n\t    {\n\t      name: 'findPet',\n\t      method: OpenAPIV3.HttpMethods.GET,\n\t      url: '/pet',\n\t      request: {},\n\t      response: {},\n", "    },\n\t  ]);\n\t});\n\ttest('custom name formatter', async () => {\n\t  const parser = new PathsParser(\n\t    {\n\t      info: {\n\t        title: 'test',\n\t        version: '1.0.0',\n\t      },\n", "      openapi: '3.0.0',\n\t      paths: {\n\t        '/pet': {\n\t          get: {\n\t            operationId: 'findPet',\n\t            responses: {},\n\t          },\n\t        },\n\t        '/cat': {\n\t          get: {\n", "            responses: {},\n\t          },\n\t        },\n\t      },\n\t    },\n\t    {\n\t      nameFormatter: ({ name /*, method, url, operationId*/ }) => {\n\t        return `custom_${name}`;\n\t      },\n\t    }\n", "  );\n\t  const t = parser.parsePaths();\n\t  expect(t).toEqual<TypeOperations>([\n\t    {\n\t      name: `custom_getCat`,\n\t      method: OpenAPIV3.HttpMethods.GET,\n\t      url: '/cat',\n\t      request: {},\n\t      response: {},\n\t    },\n", "    {\n\t      name: `custom_findPet`,\n\t      method: OpenAPIV3.HttpMethods.GET,\n\t      url: '/pet',\n\t      request: {},\n\t      response: {},\n\t    },\n\t  ]);\n\t});\n\ttest('operationId is reserved', async () => {\n", "  const parser = new PathsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {\n\t      '/pet': {\n\t        get: {\n\t          operationId: 'export',\n", "          responses: {},\n\t        },\n\t      },\n\t    },\n\t  });\n\t  const t = parser.parsePaths();\n\t  expect(t).toEqual<TypeOperations>([\n\t    {\n\t      name: 'export2',\n\t      method: OpenAPIV3.HttpMethods.GET,\n", "      url: '/pet',\n\t      request: {},\n\t      response: {},\n\t    },\n\t  ]);\n\t});\n\ttest('resp ref', async () => {\n\t  const parser = new PathsParser({\n\t    info: {\n\t      title: 'test',\n", "      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {\n\t      '/pet': {\n\t        get: {\n\t          operationId: 'findPet',\n\t          responses: {\n\t            200: {\n\t              description: '',\n", "              content: {\n\t                'application/json': {\n\t                  schema: {\n\t                    $ref: '#/components/schemas/T',\n\t                  },\n\t                },\n\t              },\n\t            },\n\t          },\n\t        },\n", "      },\n\t    },\n\t    components: {\n\t      schemas: {\n\t        T: {\n\t          type: 'string',\n\t        },\n\t      },\n\t    },\n\t  });\n", "  parser.parseComponents();\n\t  const t = parser.parsePaths();\n\t  expect(t).toEqual<TypeOperations>([\n\t    {\n\t      name: 'findPet',\n\t      url: '/pet',\n\t      method: HttpMethods.GET,\n\t      request: {},\n\t      response: {\n\t        body: {\n", "          kind: 'alias',\n\t          refAble: false,\n\t          required: true,\n\t          name: 'FindPetResData',\n\t          target: 'T',\n\t          origin: 'T',\n\t          props: [],\n\t          ref: '#/components/schemas/T',\n\t        },\n\t      },\n", "    },\n\t  ]);\n\t});\n\ttest('resp type', async () => {\n\t  const parser = new PathsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n", "    paths: {\n\t      '/pet': {\n\t        get: {\n\t          operationId: 'findPet',\n\t          responses: {\n\t            200: {\n\t              description: '',\n\t              content: {\n\t                'application/json': {\n\t                  schema: {\n", "                    type: 'string',\n\t                  },\n\t                },\n\t              },\n\t            },\n\t          },\n\t        },\n\t      },\n\t    },\n\t  });\n", "  const t = parser.parsePaths();\n\t  expect(t).toEqual<TypeOperations>([\n\t    {\n\t      name: 'findPet',\n\t      method: OpenAPIV3.HttpMethods.GET,\n\t      url: '/pet',\n\t      request: {},\n\t      response: {\n\t        body: {\n\t          kind: 'origin',\n", "          name: 'FindPetResData',\n\t          required: false,\n\t          type: 'string',\n\t        },\n\t      },\n\t    },\n\t  ]);\n\t});\n\ttest('req body', async () => {\n\t  const parser = new PathsParser({\n", "    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {\n\t      '/pet': {\n\t        get: {\n\t          operationId: 'findPet',\n\t          requestBody: {\n", "            content: {\n\t              'application/json': {\n\t                schema: {\n\t                  type: 'object',\n\t                  properties: {\n\t                    p: {\n\t                      type: 'string',\n\t                    },\n\t                  },\n\t                },\n", "              },\n\t            },\n\t          },\n\t          responses: {},\n\t        },\n\t      },\n\t    },\n\t  });\n\t  const t = parser.parsePaths();\n\t  expect(t).toEqual<TypeOperations>([\n", "    {\n\t      name: 'findPet',\n\t      method: HttpMethods.GET,\n\t      url: '/pet',\n\t      request: {\n\t        body: {\n\t          kind: 'origin',\n\t          name: 'FindPetReqData',\n\t          type: 'object',\n\t          required: false,\n", "          children: [\n\t            {\n\t              kind: 'origin',\n\t              name: 'p',\n\t              type: 'string',\n\t              required: false,\n\t            },\n\t          ],\n\t        },\n\t      },\n", "      response: {},\n\t    },\n\t  ]);\n\t});\n\ttest('req file', async () => {\n\t  const parser = new PathsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n", "    openapi: '3.0.0',\n\t    paths: {\n\t      '/pet': {\n\t        get: {\n\t          operationId: 'findPet',\n\t          requestBody: {\n\t            content: {\n\t              'application/octet-stream': {\n\t                schema: {\n\t                  type: 'string',\n", "                  format: 'binary',\n\t                },\n\t              },\n\t            },\n\t          },\n\t          responses: {},\n\t        },\n\t      },\n\t    },\n\t  });\n", "  const t = parser.parsePaths();\n\t  expect(t).toEqual<TypeOperations>([\n\t    {\n\t      name: 'findPet',\n\t      method: HttpMethods.GET,\n\t      url: '/pet',\n\t      request: {\n\t        body: {\n\t          kind: 'alias',\n\t          name: 'FindPetReqData',\n", "          origin: 'Blob',\n\t          props: [],\n\t          refAble: false,\n\t          required: true,\n\t          target: 'Blob',\n\t        },\n\t      },\n\t      response: {},\n\t    },\n\t  ]);\n", "});\n\ttest('req query + path', async () => {\n\t  const parser = new PathsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {\n\t      '/pet/{name}': {\n", "        get: {\n\t          operationId: 'findPet',\n\t          parameters: [\n\t            {\n\t              name: 'name',\n\t              in: 'path',\n\t              required: true,\n\t              schema: {\n\t                $ref: '#/components/schemas/O/p',\n\t              },\n", "            },\n\t            {\n\t              name: 'status',\n\t              in: 'query',\n\t              description: 'Status values that need to be considered for filter',\n\t              required: false,\n\t              explode: true,\n\t              schema: {\n\t                type: 'string',\n\t                default: 'available',\n", "                enum: ['available', 'pending', 'sold'],\n\t              },\n\t            },\n\t          ],\n\t          responses: {},\n\t        },\n\t      },\n\t    },\n\t    components: {\n\t      schemas: {\n", "        O: {\n\t          type: 'object',\n\t          properties: {\n\t            P: {\n\t              type: 'string',\n\t            },\n\t          },\n\t        },\n\t      },\n\t    },\n", "  });\n\t  parser.parseComponents();\n\t  const t = parser.parsePaths();\n\t  // console.log(JSON.stringify(t));\n\t  expect(t).toEqual<TypeOperations>([\n\t    {\n\t      name: 'findPet',\n\t      method: 'get',\n\t      url: '/pet/{name}',\n\t      request: {\n", "        path: {\n\t          kind: 'origin',\n\t          name: 'FindPetReqPath',\n\t          type: 'object',\n\t          required: true,\n\t          children: [\n\t            {\n\t              kind: 'alias',\n\t              refAble: false,\n\t              required: true,\n", "              name: 'name',\n\t              ref: '#/components/schemas/O/p',\n\t              target: 'O',\n\t              origin: 'O',\n\t              props: ['p'],\n\t            },\n\t          ],\n\t        },\n\t        query: {\n\t          kind: 'origin',\n", "          name: 'FindPetReqParams',\n\t          type: 'object',\n\t          required: false,\n\t          children: [\n\t            {\n\t              default: 'available',\n\t              description: 'Status values that need to be considered for filter',\n\t              enum: ['available', 'pending', 'sold'],\n\t              name: 'status',\n\t              type: 'string',\n", "              required: false,\n\t              kind: 'origin',\n\t            },\n\t          ],\n\t        },\n\t      },\n\t      response: {},\n\t    },\n\t  ]);\n\t});\n"]}
{"filename": "test/parsers/DocumentParser.test.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\n\timport { doc } from 'prettier';\n\timport { DocumentParser } from '../../src/parsers/DocumentParser';\n\timport type { TypeDocument } from '../../src/parsers/types';\n\timport document from '../files/petStore3.openapi.json';\n\timport { writeFile } from '../helpers';\n\ttest('DocumentParser', () => {\n\t  const parser = new DocumentParser(document as unknown as OpenAPIV3.Document);\n\t  const types = parser.parse();\n\t  writeFile('petStore3.types.json', types);\n", "  expect(types).toMatchInlineSnapshot(`\n\t    {\n\t      \"components\": [\n\t        {\n\t          \"children\": [\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n", "              \"example\": \"Palo Alto\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"city\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n", "              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": \"CA\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"state\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n", "            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": \"437 Lytton\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"street\",\n", "              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": \"94301\",\n", "              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"zip\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t          ],\n\t          \"default\": undefined,\n\t          \"deprecated\": undefined,\n", "          \"description\": undefined,\n\t          \"enum\": undefined,\n\t          \"example\": undefined,\n\t          \"format\": undefined,\n\t          \"kind\": \"origin\",\n\t          \"name\": \"Address\",\n\t          \"required\": false,\n\t          \"title\": undefined,\n\t          \"type\": \"object\",\n\t        },\n", "        {\n\t          \"children\": [\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": \"int32\",\n\t              \"kind\": \"origin\",\n", "              \"name\": \"code\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"number\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n", "              \"example\": undefined,\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"message\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n", "              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"type\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n", "            },\n\t          ],\n\t          \"default\": undefined,\n\t          \"deprecated\": undefined,\n\t          \"description\": undefined,\n\t          \"enum\": undefined,\n\t          \"example\": undefined,\n\t          \"format\": undefined,\n\t          \"kind\": \"origin\",\n\t          \"name\": \"ApiResponse\",\n", "          \"required\": false,\n\t          \"title\": undefined,\n\t          \"type\": \"object\",\n\t        },\n\t        {\n\t          \"children\": [\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n", "              \"enum\": undefined,\n\t              \"example\": 1,\n\t              \"format\": \"int64\",\n\t              \"kind\": \"origin\",\n\t              \"name\": \"id\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"number\",\n\t            },\n\t            {\n", "              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": \"Dogs\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"name\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n", "              \"type\": \"string\",\n\t            },\n\t          ],\n\t          \"default\": undefined,\n\t          \"deprecated\": undefined,\n\t          \"description\": undefined,\n\t          \"enum\": undefined,\n\t          \"example\": undefined,\n\t          \"format\": undefined,\n\t          \"kind\": \"origin\",\n", "          \"name\": \"Category\",\n\t          \"required\": false,\n\t          \"title\": undefined,\n\t          \"type\": \"object\",\n\t        },\n\t        {\n\t          \"children\": [\n\t            {\n\t              \"children\": [\n\t                {\n", "                  \"kind\": \"alias\",\n\t                  \"name\": \"address[]\",\n\t                  \"origin\": \"Address\",\n\t                  \"props\": [],\n\t                  \"ref\": \"#/components/schemas/Address\",\n\t                  \"refAble\": false,\n\t                  \"required\": true,\n\t                  \"target\": \"Address\",\n\t                },\n\t              ],\n", "              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"address\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n", "              \"type\": \"array\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": 100000,\n\t              \"format\": \"int64\",\n\t              \"kind\": \"origin\",\n", "              \"name\": \"id\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"number\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n", "              \"example\": \"fehguy\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"username\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t          ],\n\t          \"default\": undefined,\n", "          \"deprecated\": undefined,\n\t          \"description\": undefined,\n\t          \"enum\": undefined,\n\t          \"example\": undefined,\n\t          \"format\": undefined,\n\t          \"kind\": \"origin\",\n\t          \"name\": \"Customer\",\n\t          \"required\": false,\n\t          \"title\": undefined,\n\t          \"type\": \"object\",\n", "        },\n\t        {\n\t          \"children\": [\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": undefined,\n", "              \"kind\": \"origin\",\n\t              \"name\": \"complete\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"boolean\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n", "              \"enum\": undefined,\n\t              \"example\": 10,\n\t              \"format\": \"int64\",\n\t              \"kind\": \"origin\",\n\t              \"name\": \"id\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"number\",\n\t            },\n\t            {\n", "              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": 198772,\n\t              \"format\": \"int64\",\n\t              \"kind\": \"origin\",\n\t              \"name\": \"petId\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n", "              \"type\": \"number\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": 7,\n\t              \"format\": \"int32\",\n\t              \"kind\": \"origin\",\n", "              \"name\": \"quantity\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"number\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n", "              \"example\": undefined,\n\t              \"format\": \"date-time\",\n\t              \"kind\": \"origin\",\n\t              \"name\": \"shipDate\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n", "              \"deprecated\": undefined,\n\t              \"description\": \"Order Status\",\n\t              \"enum\": [\n\t                \"placed\",\n\t                \"approved\",\n\t                \"delivered\",\n\t              ],\n\t              \"example\": \"approved\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n", "              \"name\": \"status\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t          ],\n\t          \"default\": undefined,\n\t          \"deprecated\": undefined,\n\t          \"description\": undefined,\n\t          \"enum\": undefined,\n", "          \"example\": undefined,\n\t          \"format\": undefined,\n\t          \"kind\": \"origin\",\n\t          \"name\": \"Order\",\n\t          \"required\": false,\n\t          \"title\": undefined,\n\t          \"type\": \"object\",\n\t        },\n\t        {\n\t          \"children\": [\n", "            {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"category\",\n\t              \"origin\": \"Category\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/Category\",\n\t              \"refAble\": false,\n\t              \"required\": false,\n\t              \"target\": \"Category\",\n\t            },\n", "            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": 10,\n\t              \"format\": \"int64\",\n\t              \"kind\": \"origin\",\n\t              \"name\": \"id\",\n\t              \"required\": false,\n", "              \"title\": undefined,\n\t              \"type\": \"number\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": \"doggie\",\n\t              \"format\": undefined,\n", "              \"kind\": \"origin\",\n\t              \"name\": \"name\",\n\t              \"required\": true,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t            {\n\t              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n", "                  \"deprecated\": undefined,\n\t                  \"description\": undefined,\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": undefined,\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"photoUrls[]\",\n\t                  \"required\": false,\n\t                  \"title\": undefined,\n\t                  \"type\": \"string\",\n", "                },\n\t              ],\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"photoUrls\",\n", "              \"required\": true,\n\t              \"title\": undefined,\n\t              \"type\": \"array\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": \"pet status in the store\",\n\t              \"enum\": [\n\t                \"available\",\n", "                \"pending\",\n\t                \"sold\",\n\t              ],\n\t              \"example\": undefined,\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"status\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n", "            },\n\t            {\n\t              \"children\": [\n\t                {\n\t                  \"kind\": \"alias\",\n\t                  \"name\": \"tags[]\",\n\t                  \"origin\": \"Tag\",\n\t                  \"props\": [],\n\t                  \"ref\": \"#/components/schemas/Tag\",\n\t                  \"refAble\": false,\n", "                  \"required\": true,\n\t                  \"target\": \"Tag\",\n\t                },\n\t              ],\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": undefined,\n", "              \"kind\": \"origin\",\n\t              \"name\": \"tags\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"array\",\n\t            },\n\t          ],\n\t          \"default\": undefined,\n\t          \"deprecated\": undefined,\n\t          \"description\": undefined,\n", "          \"enum\": undefined,\n\t          \"example\": undefined,\n\t          \"format\": undefined,\n\t          \"kind\": \"origin\",\n\t          \"name\": \"Pet\",\n\t          \"required\": false,\n\t          \"title\": undefined,\n\t          \"type\": \"object\",\n\t        },\n\t        {\n", "          \"children\": [\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": \"int64\",\n\t              \"kind\": \"origin\",\n\t              \"name\": \"id\",\n", "              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"number\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n", "              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"name\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t          ],\n\t          \"default\": undefined,\n\t          \"deprecated\": undefined,\n", "          \"description\": undefined,\n\t          \"enum\": undefined,\n\t          \"example\": undefined,\n\t          \"format\": undefined,\n\t          \"kind\": \"origin\",\n\t          \"name\": \"Tag\",\n\t          \"required\": false,\n\t          \"title\": undefined,\n\t          \"type\": \"object\",\n\t        },\n", "        {\n\t          \"children\": [\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": \"john@email.com\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n", "              \"name\": \"email\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n", "              \"example\": \"John\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"firstName\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n", "              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": 10,\n\t              \"format\": \"int64\",\n\t              \"kind\": \"origin\",\n\t              \"name\": \"id\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"number\",\n", "            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": \"James\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"lastName\",\n", "              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": \"12345\",\n", "              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"password\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n", "              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": \"12345\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"phone\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n", "            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": \"theUser\",\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"username\",\n\t              \"required\": false,\n", "              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t            {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": \"User Status\",\n\t              \"enum\": undefined,\n\t              \"example\": 1,\n\t              \"format\": \"int32\",\n", "              \"kind\": \"origin\",\n\t              \"name\": \"userStatus\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"number\",\n\t            },\n\t          ],\n\t          \"default\": undefined,\n\t          \"deprecated\": undefined,\n\t          \"description\": undefined,\n", "          \"enum\": undefined,\n\t          \"example\": undefined,\n\t          \"format\": undefined,\n\t          \"kind\": \"origin\",\n\t          \"name\": \"User\",\n\t          \"required\": false,\n\t          \"title\": undefined,\n\t          \"type\": \"object\",\n\t        },\n\t      ],\n", "      \"info\": {\n\t        \"baseURL\": \"/api/v3\",\n\t        \"description\": \"This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\n\t    Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\n\t    You can now help us improve the API whether it's by making changes to the definition itself or to the code.\n\t    That way, with time, we can improve the API in general, and expose some of the new features in OAS3.\n\t    Some useful links:\n\t    - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\n\t    - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)\",\n\t        \"title\": \"Swagger Petstore - OpenAPI 3.0\",\n", "        \"version\": \"1.0.17\",\n\t      },\n\t      \"paths\": [\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"Add a new pet to the store\",\n\t          \"method\": \"post\",\n\t          \"name\": \"addPet\",\n\t          \"request\": {\n\t            \"body\": {\n", "              \"kind\": \"alias\",\n\t              \"name\": \"AddPetReqData\",\n\t              \"origin\": \"Pet\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/Pet\",\n\t              \"refAble\": false,\n\t              \"required\": true,\n\t              \"target\": \"Pet\",\n\t            },\n\t            \"path\": undefined,\n", "            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"AddPetResData\",\n\t              \"origin\": \"Pet\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/Pet\",\n\t              \"refAble\": false,\n", "              \"required\": true,\n\t              \"target\": \"Pet\",\n\t            },\n\t          },\n\t          \"title\": \"Add a new pet to the store\",\n\t          \"url\": \"/pet\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"Update an existing pet by Id\",\n", "          \"method\": \"put\",\n\t          \"name\": \"updatePet\",\n\t          \"request\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"UpdatePetReqData\",\n\t              \"origin\": \"Pet\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/Pet\",\n\t              \"refAble\": false,\n", "              \"required\": true,\n\t              \"target\": \"Pet\",\n\t            },\n\t            \"path\": undefined,\n\t            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"UpdatePetResData\",\n", "              \"origin\": \"Pet\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/Pet\",\n\t              \"refAble\": false,\n\t              \"required\": true,\n\t              \"target\": \"Pet\",\n\t            },\n\t          },\n\t          \"title\": \"Update an existing pet\",\n\t          \"url\": \"/pet\",\n", "        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"\",\n\t          \"method\": \"delete\",\n\t          \"name\": \"deletePet\",\n\t          \"request\": {\n\t            \"body\": undefined,\n\t            \"path\": {\n\t              \"children\": [\n", "                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"Pet id to delete\",\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": \"int64\",\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"petId\",\n\t                  \"required\": true,\n", "                  \"title\": undefined,\n\t                  \"type\": \"number\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n\t              \"name\": \"DeletePetReqPath\",\n\t              \"required\": true,\n\t              \"type\": \"object\",\n\t            },\n\t            \"query\": undefined,\n", "          },\n\t          \"response\": {\n\t            \"body\": undefined,\n\t          },\n\t          \"title\": \"Deletes a pet\",\n\t          \"url\": \"/pet/{petId}\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"Returns a single pet\",\n", "          \"method\": \"get\",\n\t          \"name\": \"getPetById\",\n\t          \"request\": {\n\t            \"body\": undefined,\n\t            \"path\": {\n\t              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"ID of pet to return\",\n", "                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": \"int64\",\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"petId\",\n\t                  \"required\": true,\n\t                  \"title\": undefined,\n\t                  \"type\": \"number\",\n\t                },\n\t              ],\n", "              \"kind\": \"origin\",\n\t              \"name\": \"GetPetByIdReqPath\",\n\t              \"required\": true,\n\t              \"type\": \"object\",\n\t            },\n\t            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n", "              \"name\": \"GetPetByIdResData\",\n\t              \"origin\": \"Pet\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/Pet\",\n\t              \"refAble\": false,\n\t              \"required\": true,\n\t              \"target\": \"Pet\",\n\t            },\n\t          },\n\t          \"title\": \"Find pet by ID\",\n", "          \"url\": \"/pet/{petId}\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"\",\n\t          \"method\": \"post\",\n\t          \"name\": \"updatePetWithForm\",\n\t          \"request\": {\n\t            \"body\": undefined,\n\t            \"path\": {\n", "              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"ID of pet that needs to be updated\",\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": \"int64\",\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"petId\",\n", "                  \"required\": true,\n\t                  \"title\": undefined,\n\t                  \"type\": \"number\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n\t              \"name\": \"UpdatePetWithFormReqPath\",\n\t              \"required\": true,\n\t              \"type\": \"object\",\n\t            },\n", "            \"query\": {\n\t              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"Name of pet that needs to be updated\",\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": undefined,\n\t                  \"kind\": \"origin\",\n", "                  \"name\": \"name\",\n\t                  \"required\": false,\n\t                  \"title\": undefined,\n\t                  \"type\": \"string\",\n\t                },\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"Status of pet that needs to be updated\",\n\t                  \"enum\": undefined,\n", "                  \"example\": undefined,\n\t                  \"format\": undefined,\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"status\",\n\t                  \"required\": false,\n\t                  \"title\": undefined,\n\t                  \"type\": \"string\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n", "              \"name\": \"UpdatePetWithFormReqParams\",\n\t              \"required\": false,\n\t              \"type\": \"object\",\n\t            },\n\t          },\n\t          \"response\": {\n\t            \"body\": undefined,\n\t          },\n\t          \"title\": \"Updates a pet in the store with form data\",\n\t          \"url\": \"/pet/{petId}\",\n", "        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"\",\n\t          \"method\": \"post\",\n\t          \"name\": \"uploadFile\",\n\t          \"request\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"UploadFileReqData\",\n", "              \"origin\": \"Blob\",\n\t              \"props\": [],\n\t              \"refAble\": false,\n\t              \"required\": true,\n\t              \"target\": \"Blob\",\n\t            },\n\t            \"path\": {\n\t              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n", "                  \"deprecated\": undefined,\n\t                  \"description\": \"ID of pet to update\",\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": \"int64\",\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"petId\",\n\t                  \"required\": true,\n\t                  \"title\": undefined,\n\t                  \"type\": \"number\",\n", "                },\n\t              ],\n\t              \"kind\": \"origin\",\n\t              \"name\": \"UploadFileReqPath\",\n\t              \"required\": true,\n\t              \"type\": \"object\",\n\t            },\n\t            \"query\": {\n\t              \"children\": [\n\t                {\n", "                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"Additional Metadata\",\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": undefined,\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"additionalMetadata\",\n\t                  \"required\": false,\n\t                  \"title\": undefined,\n", "                  \"type\": \"string\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n\t              \"name\": \"UploadFileReqParams\",\n\t              \"required\": false,\n\t              \"type\": \"object\",\n\t            },\n\t          },\n\t          \"response\": {\n", "            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"UploadFileResData\",\n\t              \"origin\": \"ApiResponse\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/ApiResponse\",\n\t              \"refAble\": false,\n\t              \"required\": true,\n\t              \"target\": \"ApiResponse\",\n\t            },\n", "          },\n\t          \"title\": \"uploads an image\",\n\t          \"url\": \"/pet/{petId}/uploadImage\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"Multiple status values can be provided with comma separated strings\",\n\t          \"method\": \"get\",\n\t          \"name\": \"findPetsByStatus\",\n\t          \"request\": {\n", "            \"body\": undefined,\n\t            \"path\": undefined,\n\t            \"query\": {\n\t              \"children\": [\n\t                {\n\t                  \"default\": \"available\",\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"Status values that need to be considered for filter\",\n\t                  \"enum\": [\n\t                    \"available\",\n", "                    \"pending\",\n\t                    \"sold\",\n\t                  ],\n\t                  \"example\": undefined,\n\t                  \"format\": undefined,\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"status\",\n\t                  \"required\": false,\n\t                  \"title\": undefined,\n\t                  \"type\": \"string\",\n", "                },\n\t              ],\n\t              \"kind\": \"origin\",\n\t              \"name\": \"FindPetsByStatusReqParams\",\n\t              \"required\": false,\n\t              \"type\": \"object\",\n\t            },\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n", "              \"children\": [\n\t                {\n\t                  \"kind\": \"alias\",\n\t                  \"name\": \"FindPetsByStatusResData[]\",\n\t                  \"origin\": \"Pet\",\n\t                  \"props\": [],\n\t                  \"ref\": \"#/components/schemas/Pet\",\n\t                  \"refAble\": false,\n\t                  \"required\": true,\n\t                  \"target\": \"Pet\",\n", "                },\n\t              ],\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"FindPetsByStatusResData\",\n", "              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"array\",\n\t            },\n\t          },\n\t          \"title\": \"Finds Pets by status\",\n\t          \"url\": \"/pet/findByStatus\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n", "          \"description\": \"Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\",\n\t          \"method\": \"get\",\n\t          \"name\": \"findPetsByTags\",\n\t          \"request\": {\n\t            \"body\": undefined,\n\t            \"path\": undefined,\n\t            \"query\": {\n\t              \"children\": [\n\t                {\n\t                  \"children\": [\n", "                    {\n\t                      \"default\": undefined,\n\t                      \"deprecated\": undefined,\n\t                      \"description\": undefined,\n\t                      \"enum\": undefined,\n\t                      \"example\": undefined,\n\t                      \"format\": undefined,\n\t                      \"kind\": \"origin\",\n\t                      \"name\": \"tags[]\",\n\t                      \"required\": false,\n", "                      \"title\": undefined,\n\t                      \"type\": \"string\",\n\t                    },\n\t                  ],\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"Tags to filter by\",\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": undefined,\n", "                  \"kind\": \"origin\",\n\t                  \"name\": \"tags\",\n\t                  \"required\": false,\n\t                  \"title\": undefined,\n\t                  \"type\": \"array\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n\t              \"name\": \"FindPetsByTagsReqParams\",\n\t              \"required\": false,\n", "              \"type\": \"object\",\n\t            },\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n\t              \"children\": [\n\t                {\n\t                  \"kind\": \"alias\",\n\t                  \"name\": \"FindPetsByTagsResData[]\",\n\t                  \"origin\": \"Pet\",\n", "                  \"props\": [],\n\t                  \"ref\": \"#/components/schemas/Pet\",\n\t                  \"refAble\": false,\n\t                  \"required\": true,\n\t                  \"target\": \"Pet\",\n\t                },\n\t              ],\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n", "              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"FindPetsByTagsResData\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"array\",\n\t            },\n\t          },\n", "          \"title\": \"Finds Pets by tags\",\n\t          \"url\": \"/pet/findByTags\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"Returns a map of status codes to quantities\",\n\t          \"method\": \"get\",\n\t          \"name\": \"getInventory\",\n\t          \"request\": {\n\t            \"body\": undefined,\n", "            \"path\": undefined,\n\t            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n\t              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": undefined,\n", "                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": \"int32\",\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"[key: string]\",\n\t                  \"required\": true,\n\t                  \"title\": undefined,\n\t                  \"type\": \"number\",\n\t                },\n\t              ],\n", "              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"GetInventoryResData\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n", "              \"type\": \"object\",\n\t            },\n\t          },\n\t          \"title\": \"Returns pet inventories by status\",\n\t          \"url\": \"/store/inventory\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"Place a new order in the store\",\n\t          \"method\": \"post\",\n", "          \"name\": \"placeOrder\",\n\t          \"request\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"PlaceOrderReqData\",\n\t              \"origin\": \"Order\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/Order\",\n\t              \"refAble\": false,\n\t              \"required\": true,\n", "              \"target\": \"Order\",\n\t            },\n\t            \"path\": undefined,\n\t            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"PlaceOrderResData\",\n\t              \"origin\": \"Order\",\n", "              \"props\": [],\n\t              \"ref\": \"#/components/schemas/Order\",\n\t              \"refAble\": false,\n\t              \"required\": true,\n\t              \"target\": \"Order\",\n\t            },\n\t          },\n\t          \"title\": \"Place an order for a pet\",\n\t          \"url\": \"/store/order\",\n\t        },\n", "        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors\",\n\t          \"method\": \"delete\",\n\t          \"name\": \"deleteOrder\",\n\t          \"request\": {\n\t            \"body\": undefined,\n\t            \"path\": {\n\t              \"children\": [\n\t                {\n", "                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"ID of the order that needs to be deleted\",\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": \"int64\",\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"orderId\",\n\t                  \"required\": true,\n\t                  \"title\": undefined,\n", "                  \"type\": \"number\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n\t              \"name\": \"DeleteOrderReqPath\",\n\t              \"required\": true,\n\t              \"type\": \"object\",\n\t            },\n\t            \"query\": undefined,\n\t          },\n", "          \"response\": {\n\t            \"body\": undefined,\n\t          },\n\t          \"title\": \"Delete purchase order by ID\",\n\t          \"url\": \"/store/order/{orderId}\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.\",\n\t          \"method\": \"get\",\n", "          \"name\": \"getOrderById\",\n\t          \"request\": {\n\t            \"body\": undefined,\n\t            \"path\": {\n\t              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"ID of order that needs to be fetched\",\n\t                  \"enum\": undefined,\n", "                  \"example\": undefined,\n\t                  \"format\": \"int64\",\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"orderId\",\n\t                  \"required\": true,\n\t                  \"title\": undefined,\n\t                  \"type\": \"number\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n", "              \"name\": \"GetOrderByIdReqPath\",\n\t              \"required\": true,\n\t              \"type\": \"object\",\n\t            },\n\t            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"GetOrderByIdResData\",\n", "              \"origin\": \"Order\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/Order\",\n\t              \"refAble\": false,\n\t              \"required\": true,\n\t              \"target\": \"Order\",\n\t            },\n\t          },\n\t          \"title\": \"Find purchase order by ID\",\n\t          \"url\": \"/store/order/{orderId}\",\n", "        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"This can only be done by the logged in user.\",\n\t          \"method\": \"post\",\n\t          \"name\": \"createUser\",\n\t          \"request\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"CreateUserReqData\",\n", "              \"origin\": \"User\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/User\",\n\t              \"refAble\": false,\n\t              \"required\": true,\n\t              \"target\": \"User\",\n\t            },\n\t            \"path\": undefined,\n\t            \"query\": undefined,\n\t          },\n", "          \"response\": {\n\t            \"body\": undefined,\n\t          },\n\t          \"title\": \"Create user\",\n\t          \"url\": \"/user\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"This can only be done by the logged in user.\",\n\t          \"method\": \"delete\",\n", "          \"name\": \"deleteUser\",\n\t          \"request\": {\n\t            \"body\": undefined,\n\t            \"path\": {\n\t              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"The name that needs to be deleted\",\n\t                  \"enum\": undefined,\n", "                  \"example\": undefined,\n\t                  \"format\": undefined,\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"username\",\n\t                  \"required\": true,\n\t                  \"title\": undefined,\n\t                  \"type\": \"string\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n", "              \"name\": \"DeleteUserReqPath\",\n\t              \"required\": true,\n\t              \"type\": \"object\",\n\t            },\n\t            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": undefined,\n\t          },\n\t          \"title\": \"Delete user\",\n", "          \"url\": \"/user/{username}\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"\",\n\t          \"method\": \"get\",\n\t          \"name\": \"getUserByName\",\n\t          \"request\": {\n\t            \"body\": undefined,\n\t            \"path\": {\n", "              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"The name that needs to be fetched. Use user1 for testing. \",\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": undefined,\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"username\",\n", "                  \"required\": true,\n\t                  \"title\": undefined,\n\t                  \"type\": \"string\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n\t              \"name\": \"GetUserByNameReqPath\",\n\t              \"required\": true,\n\t              \"type\": \"object\",\n\t            },\n", "            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"GetUserByNameResData\",\n\t              \"origin\": \"User\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/User\",\n\t              \"refAble\": false,\n", "              \"required\": true,\n\t              \"target\": \"User\",\n\t            },\n\t          },\n\t          \"title\": \"Get user by user name\",\n\t          \"url\": \"/user/{username}\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"This can only be done by the logged in user.\",\n", "          \"method\": \"put\",\n\t          \"name\": \"updateUser\",\n\t          \"request\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"UpdateUserReqData\",\n\t              \"origin\": \"User\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/User\",\n\t              \"refAble\": false,\n", "              \"required\": true,\n\t              \"target\": \"User\",\n\t            },\n\t            \"path\": {\n\t              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"name that need to be deleted\",\n\t                  \"enum\": undefined,\n", "                  \"example\": undefined,\n\t                  \"format\": undefined,\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"username\",\n\t                  \"required\": true,\n\t                  \"title\": undefined,\n\t                  \"type\": \"string\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n", "              \"name\": \"UpdateUserReqPath\",\n\t              \"required\": true,\n\t              \"type\": \"object\",\n\t            },\n\t            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": undefined,\n\t          },\n\t          \"title\": \"Update user\",\n", "          \"url\": \"/user/{username}\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"Creates list of users with given input array\",\n\t          \"method\": \"post\",\n\t          \"name\": \"createUsersWithListInput\",\n\t          \"request\": {\n\t            \"body\": {\n\t              \"children\": [\n", "                {\n\t                  \"kind\": \"alias\",\n\t                  \"name\": \"CreateUsersWithListInputReqData[]\",\n\t                  \"origin\": \"User\",\n\t                  \"props\": [],\n\t                  \"ref\": \"#/components/schemas/User\",\n\t                  \"refAble\": false,\n\t                  \"required\": true,\n\t                  \"target\": \"User\",\n\t                },\n", "              ],\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n\t              \"example\": undefined,\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"CreateUsersWithListInputReqData\",\n\t              \"required\": false,\n", "              \"title\": undefined,\n\t              \"type\": \"array\",\n\t            },\n\t            \"path\": undefined,\n\t            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n\t              \"kind\": \"alias\",\n\t              \"name\": \"CreateUsersWithListInputResData\",\n", "              \"origin\": \"User\",\n\t              \"props\": [],\n\t              \"ref\": \"#/components/schemas/User\",\n\t              \"refAble\": false,\n\t              \"required\": true,\n\t              \"target\": \"User\",\n\t            },\n\t          },\n\t          \"title\": \"Creates list of users with given input array\",\n\t          \"url\": \"/user/createWithList\",\n", "        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"\",\n\t          \"method\": \"get\",\n\t          \"name\": \"loginUser\",\n\t          \"request\": {\n\t            \"body\": undefined,\n\t            \"path\": undefined,\n\t            \"query\": {\n", "              \"children\": [\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"The user name for login\",\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n\t                  \"format\": undefined,\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"username\",\n", "                  \"required\": false,\n\t                  \"title\": undefined,\n\t                  \"type\": \"string\",\n\t                },\n\t                {\n\t                  \"default\": undefined,\n\t                  \"deprecated\": undefined,\n\t                  \"description\": \"The password for login in clear text\",\n\t                  \"enum\": undefined,\n\t                  \"example\": undefined,\n", "                  \"format\": undefined,\n\t                  \"kind\": \"origin\",\n\t                  \"name\": \"password\",\n\t                  \"required\": false,\n\t                  \"title\": undefined,\n\t                  \"type\": \"string\",\n\t                },\n\t              ],\n\t              \"kind\": \"origin\",\n\t              \"name\": \"LoginUserReqParams\",\n", "              \"required\": false,\n\t              \"type\": \"object\",\n\t            },\n\t          },\n\t          \"response\": {\n\t            \"body\": {\n\t              \"default\": undefined,\n\t              \"deprecated\": undefined,\n\t              \"description\": undefined,\n\t              \"enum\": undefined,\n", "              \"example\": undefined,\n\t              \"format\": undefined,\n\t              \"kind\": \"origin\",\n\t              \"name\": \"LoginUserResData\",\n\t              \"required\": false,\n\t              \"title\": undefined,\n\t              \"type\": \"string\",\n\t            },\n\t          },\n\t          \"title\": \"Logs user into the system\",\n", "          \"url\": \"/user/login\",\n\t        },\n\t        {\n\t          \"deprecated\": undefined,\n\t          \"description\": \"\",\n\t          \"method\": \"get\",\n\t          \"name\": \"logoutUser\",\n\t          \"request\": {\n\t            \"body\": undefined,\n\t            \"path\": undefined,\n", "            \"query\": undefined,\n\t          },\n\t          \"response\": {\n\t            \"body\": undefined,\n\t          },\n\t          \"title\": \"Logs out current logged in user session\",\n\t          \"url\": \"/user/logout\",\n\t        },\n\t      ],\n\t    }\n", "  `);\n\t});\n"]}
{"filename": "test/parsers/ComponentsPaser.test.ts", "chunked_list": ["import { expect } from 'vitest';\n\timport { ComponentsParser } from '../../src/parsers/ComponentsParser';\n\timport type { TypeAlias, TypeList } from '../../src/parsers/types';\n\ttest('empty components', async () => {\n\t  const parser = new ComponentsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n", "    paths: {},\n\t  });\n\t  const t = parser.parseComponents();\n\t  expect(t).toEqual<TypeList>([]);\n\t});\n\ttest('empty components keys', async () => {\n\t  const parser = new ComponentsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n", "    },\n\t    openapi: '3.0.0',\n\t    paths: {},\n\t    components: {},\n\t  });\n\t  const t = parser.parseComponents();\n\t  expect(t).toEqual<TypeList>([]);\n\t});\n\ttest('empty ref', async () => {\n\t  const parser = new ComponentsParser({\n", "    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {},\n\t    components: {\n\t      schemas: {\n\t        T: {\n\t          $ref: '#/components/schemas/P',\n", "        },\n\t      },\n\t    },\n\t  });\n\t  const t = parser.parseComponents();\n\t  expect((t[0] as TypeAlias).target).toEqual('');\n\t});\n\ttest('ref once', async () => {\n\t  const parser = new ComponentsParser({\n\t    info: {\n", "      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {},\n\t    components: {\n\t      schemas: {\n\t        T: {\n\t          $ref: '#/components/schemas/P',\n\t        },\n", "        P: {\n\t          type: 'string',\n\t        },\n\t      },\n\t    },\n\t  });\n\t  const t = parser.parseComponents();\n\t  expect(t).toEqual<TypeList>([\n\t    {\n\t      kind: 'origin',\n", "      name: 'P',\n\t      type: 'string',\n\t      required: false,\n\t    },\n\t    {\n\t      kind: 'alias',\n\t      refAble: true,\n\t      required: true,\n\t      name: 'T',\n\t      target: 'P',\n", "      origin: 'P',\n\t      props: [],\n\t      ref: '#/components/schemas/P',\n\t    },\n\t  ]);\n\t});\n\ttest('ref twice', async () => {\n\t  const parser = new ComponentsParser({\n\t    info: {\n\t      title: 'test',\n", "      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {},\n\t    components: {\n\t      schemas: {\n\t        T: {\n\t          $ref: '#/components/schemas/P',\n\t        },\n\t        P: {\n", "          $ref: '#/components/schemas/K',\n\t        },\n\t        K: {\n\t          type: 'string',\n\t        },\n\t      },\n\t    },\n\t  });\n\t  const t = parser.parseComponents();\n\t  expect(t).toEqual<TypeList>([\n", "    { kind: 'origin', name: 'K', type: 'string', required: false },\n\t    {\n\t      kind: 'alias',\n\t      refAble: true,\n\t      required: true,\n\t      name: 'P',\n\t      target: 'K',\n\t      origin: 'K',\n\t      props: [],\n\t      ref: '#/components/schemas/K',\n", "    },\n\t    {\n\t      kind: 'alias',\n\t      refAble: true,\n\t      required: true,\n\t      name: 'T',\n\t      target: 'P',\n\t      origin: 'K',\n\t      props: [],\n\t      ref: '#/components/schemas/P',\n", "    },\n\t  ]);\n\t});\n\ttest('primitive', async () => {\n\t  const parser = new ComponentsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n", "    paths: {},\n\t    components: {\n\t      schemas: {\n\t        B: {\n\t          type: 'boolean',\n\t        },\n\t        S: {\n\t          type: 'string',\n\t        },\n\t        N: {\n", "          type: 'number',\n\t        },\n\t        I: {\n\t          type: 'integer',\n\t        },\n\t      },\n\t    },\n\t  });\n\t  const t = parser.parseComponents();\n\t  expect(t).toEqual<TypeList>([\n", "    { name: 'B', type: 'boolean', required: false, kind: 'origin' },\n\t    { name: 'I', type: 'number', required: false, kind: 'origin' },\n\t    { name: 'N', type: 'number', required: false, kind: 'origin' },\n\t    { name: 'S', type: 'string', required: false, kind: 'origin' },\n\t  ]);\n\t});\n\ttest('object', async () => {\n\t  const parser = new ComponentsParser({\n\t    info: {\n\t      title: 'test',\n", "      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {},\n\t    components: {\n\t      schemas: {\n\t        O: {\n\t          type: 'object',\n\t          nullable: false,\n\t          properties: {\n", "            B: {\n\t              type: 'boolean',\n\t            },\n\t            S: {\n\t              type: 'string',\n\t            },\n\t            N: {\n\t              type: 'number',\n\t            },\n\t            I: {\n", "              type: 'integer',\n\t            },\n\t            R: {\n\t              $ref: '#/components/schemas/R',\n\t            },\n\t          },\n\t          required: ['B', 'S', 'N', 'I'],\n\t          additionalProperties: true,\n\t        },\n\t        R: {\n", "          type: 'string',\n\t        },\n\t      },\n\t    },\n\t  });\n\t  const t = parser.parseComponents();\n\t  expect(t).toEqual<TypeList>([\n\t    {\n\t      kind: 'origin',\n\t      name: 'O',\n", "      type: 'object',\n\t      required: true,\n\t      children: [\n\t        // 已重新排序\n\t        { name: 'B', type: 'boolean', required: true, kind: 'origin' },\n\t        { name: 'I', type: 'number', required: true, kind: 'origin' },\n\t        { name: 'N', type: 'number', required: true, kind: 'origin' },\n\t        {\n\t          kind: 'alias',\n\t          refAble: false,\n", "          required: false,\n\t          name: 'R',\n\t          target: 'R',\n\t          origin: 'R',\n\t          props: [],\n\t          ref: '#/components/schemas/R',\n\t        },\n\t        { name: 'S', type: 'string', required: true, kind: 'origin' },\n\t        { name: '[key: string]', type: 'any', required: true, kind: 'origin' },\n\t      ],\n", "    },\n\t    {\n\t      kind: 'origin',\n\t      name: 'R',\n\t      type: 'string',\n\t      required: false,\n\t    },\n\t  ]);\n\t});\n\ttest('array', async () => {\n", "  const parser = new ComponentsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n\t    openapi: '3.0.0',\n\t    paths: {},\n\t    components: {\n\t      schemas: {\n\t        A: {\n", "          type: 'array',\n\t          nullable: false,\n\t          items: {\n\t            type: 'string',\n\t          },\n\t          additionalProperties: {\n\t            $ref: '#/components/schema/T',\n\t          },\n\t        },\n\t        T: {\n", "          type: 'string',\n\t        },\n\t      },\n\t    },\n\t  });\n\t  const t = parser.parseComponents();\n\t  expect(t).toEqual<TypeList>([\n\t    {\n\t      kind: 'origin',\n\t      name: 'A',\n", "      type: 'array',\n\t      required: true,\n\t      children: [\n\t        { kind: 'origin', name: 'A[]', type: 'string', required: false },\n\t        {\n\t          kind: 'alias',\n\t          name: '[key: string]',\n\t          target: 'T',\n\t          origin: 'T',\n\t          props: [],\n", "          refAble: false,\n\t          required: true,\n\t          ref: '#/components/schema/T',\n\t        },\n\t      ],\n\t    },\n\t    {\n\t      kind: 'origin',\n\t      name: 'T',\n\t      type: 'string',\n", "      required: false,\n\t    },\n\t  ]);\n\t});\n\ttest('never', async () => {\n\t  const parser = new ComponentsParser({\n\t    info: {\n\t      title: 'test',\n\t      version: '1.0.0',\n\t    },\n", "    openapi: '3.0.0',\n\t    paths: {},\n\t    components: {\n\t      schemas: {\n\t        R: {},\n\t      },\n\t    },\n\t  });\n\t  const t = parser.parseComponents();\n\t  expect(t).toEqual<TypeList>([\n", "    {\n\t      kind: 'origin',\n\t      name: 'R',\n\t      type: 'never',\n\t      required: true,\n\t    },\n\t  ]);\n\t});\n"]}
{"filename": "test/parsers/Named.test.ts", "chunked_list": ["import { Named } from '../../src/parsers/Named';\n\ttest('named', () => {\n\t  const named = new Named();\n\t  named.internalName('Internal');\n\t  expect(named.nextTypeName('Internal', true)).toEqual('Internal2');\n\t  expect(named.nextTypeName('-', true)).toEqual('Unnamed');\n\t  expect(named.nextTypeName('!', true)).toEqual('Unnamed2');\n\t  expect(named.nextTypeName('A', true)).toEqual('A');\n\t  expect(named.nextTypeName('A!', true)).toEqual('A2');\n\t  expect(named.nextTypeName('aa', true)).toEqual('Aa');\n", "  expect(named.nextTypeName('aa!', true)).toEqual('Aa2');\n\t  expect(named.nextTypeName('aa!!', true)).toEqual('Aa3');\n\t  expect(named.nextOperationId('get', '/path/to/foo')).toEqual('getFoo');\n\t  expect(named.nextOperationId('get', '/path/to/foo')).toEqual('getFoo2');\n\t  expect(named.nextOperationId('get', '/path/to/foo', 'foo')).toEqual('foo');\n\t  expect(named.nextOperationId('get', '/path/to/foo', 'foo')).toEqual('foo2');\n\t  expect(named.nextOperationId('get', '/path/to/foo')).toEqual('getFoo3');\n\t  expect(named.nextOperationId('', '', 'xx')).toEqual('xx');\n\t  expect(named.nextOperationId('', '', 'xx')).toEqual('xx2');\n\t  named.internalName('export');\n", "  expect(named.nextOperationId('', '', 'export')).toEqual('export2');\n\t  expect(named.nextOperationId('', '', 'export')).toEqual('export3');\n\t  // A -> A!(A2) -> aa!!/1/2 == A -> aa!!/1/2(Aa3)\n\t  const a1 = named.addAlias({\n\t    kind: 'alias',\n\t    refAble: true,\n\t    required: true,\n\t    name: 'A',\n\t    ref: '#/components/schemas/A!',\n\t    target: '',\n", "    origin: '',\n\t    props: [],\n\t  });\n\t  // A!(A2) -> aa!!/1/2(Aa3)\n\t  const a2 = named.addAlias({\n\t    kind: 'alias',\n\t    refAble: true,\n\t    required: true,\n\t    name: 'A2',\n\t    ref: '#/components/schemas/aa!!/1/2',\n", "    target: '',\n\t    origin: '',\n\t    props: [],\n\t  });\n\t  named.resolveAlias();\n\t  expect(a1.target).toEqual('A2');\n\t  expect(a2.target).toEqual('Aa3');\n\t  expect(a1.origin).toEqual('Aa3');\n\t  expect(a2.origin).toEqual('Aa3');\n\t  expect(a1.props).toEqual([]);\n", "  expect(a2.props).toEqual(['1', '2']);\n\t});\n"]}
{"filename": "src/const.ts", "chunked_list": ["export const pkgName = process.env.PKG_NAME;\n\texport const pkgVersion = process.env.PKG_VERSION;\n"]}
{"filename": "src/helpers.ts", "chunked_list": ["export * from './const';\n\t// @ref https://github.com/drwpow/openapi-typescript/blob/bc52343c44f9dab4006e04c27411e405fb67a739/src/index.ts#L215\n\texport type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\texport type XOR<T, U> = T | U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;\n\texport type OneOf<T extends any[]> = T extends [infer Only]\n\t  ? Only\n\t  : T extends [infer A, infer B, ...infer Rest]\n\t  ? OneOf<[XOR<A, B>, ...Rest]>\n\t  : never;\n\texport const DELETE = 'DELETE';\n", "export const GET = 'GET';\n\texport const HEAD = 'HEAD';\n\texport const OPTIONS = 'OPTIONS';\n\texport const PATCH = 'PATCH';\n\texport const POST = 'POST';\n\texport const PUT = 'PUT';\n\texport const TRACE = 'TRACE';\n\texport function resolveURL(baseURL: string, url: string) {\n\t  // @ref https://github.com/FrontEndDev-org/openapi-axios/security/code-scanning/1\n\t  return baseURL.replace(/(?<!\\/)\\/+$/, '') + '/' + url.replace(/^\\/+/, '');\n", "}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './const';\n\texport { defineConfig, run } from './generators/command';\n\texport { DocumentPrinter } from './printers/DocumentPrinter';\n\texport { DocumentParser } from './parsers/DocumentParser';\n\texport { Generator } from './generators/Generator';\n"]}
{"filename": "src/printers/PathsPrinter.ts", "chunked_list": ["import type { AxiosRequestConfig } from 'axios';\n\timport { groupBy } from 'lodash';\n\timport type { TypeItem, TypeList, TypeOperation, TypeOperations, TypeOrigin } from '../parsers/types';\n\timport { joinSlices, nextUniqueName, varString } from '../utils/string';\n\timport { isBoolean, isString } from '../utils/type-is';\n\timport { ComponentsPrinter } from './ComponentsPrinter';\n\tconst { stringify } = JSON;\n\texport class PathsPrinter extends ComponentsPrinter {\n\t  protected init() {\n\t    super.init();\n", "    this.imports.push('import type { AxiosPromise, AxiosRequestConfig } from \"axios\";');\n\t    this.imports.push(\n\t      'import { DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT, resolveURL } from \"openapi-axios/helpers\";'\n\t    );\n\t    this.imports.push(this.options.axiosImport);\n\t    this.helpers.push(`const request = axios.request;`);\n\t    if (this.document.info.baseURL) this.helpers.push(`const BASE_URL = ${stringify(this.document.info.baseURL)};`);\n\t  }\n\t  printPaths() {\n\t    return this.format(joinSlices(this.document.paths.map(this.printOperation.bind(this)), '\\n\\n'));\n", "  }\n\t  protected printOperation(type: TypeOperation) {\n\t    return joinSlices([this.printOperationTypes(type), this.printOperationAxios(type)]);\n\t  }\n\t  protected printOperationTypes(type: TypeOperation) {\n\t    const {\n\t      request: { path, query, body: reqBody },\n\t      response: { body: resBody },\n\t    } = type;\n\t    return joinSlices(([path, query, reqBody, resBody].filter(Boolean) as TypeList).map(this.printRootType.bind(this)));\n", "  }\n\t  protected printOperationAxios(type: TypeOperation) {\n\t    const {\n\t      name,\n\t      request: { path, query, body: reqBody },\n\t      response: { body: resBody },\n\t    } = type;\n\t    const { responseTypeName } = this.options;\n\t    const argNameCountMap = new Map<string, number>();\n\t    const requestPathArgName = nextUniqueName(this.options.requestPathArgName, argNameCountMap);\n", "    const requestQueryArgName = nextUniqueName(this.options.requestQueryArgName, argNameCountMap);\n\t    const requestBodyArgName = nextUniqueName(this.options.requestBodyArgName, argNameCountMap);\n\t    const configArgName = nextUniqueName('config', argNameCountMap);\n\t    const comments = this.printComments(type, true);\n\t    const argsGroup = groupBy(\n\t      [\n\t        this.printArg(requestPathArgName, path),\n\t        this.printArg(requestQueryArgName, query),\n\t        this.printArg(requestBodyArgName, reqBody),\n\t        this.printArg(configArgName, 'AxiosRequestConfig', false),\n", "      ],\n\t      (item) => item?.required\n\t    );\n\t    const args_ = joinSlices(\n\t      [\n\t        // 可能没有任何必填参数\n\t        ...(argsGroup['true'] || []),\n\t        // 至少有一个 config 可选参数\n\t        ...argsGroup['false'],\n\t      ].map((desc) => desc?.text),\n", "      ', '\n\t    );\n\t    const return_ = `${responseTypeName}<${resBody?.name || 'never'}>`;\n\t    const url_ = this.printAxiosProp('url', this.toURL(type, requestPathArgName));\n\t    const method_ = this.printAxiosProp('method', type.method.toUpperCase());\n\t    const params_ = this.printAxiosProp('params', query ? requestQueryArgName : '');\n\t    const data_ = this.printAxiosProp('data', reqBody ? requestBodyArgName : '');\n\t    const props = joinSlices([\n\t      //\n\t      url_,\n", "      method_,\n\t      params_,\n\t      data_,\n\t      `...${configArgName}`,\n\t    ]);\n\t    return `${comments}export async function ${name}(${args_}): ${return_}  {\n\t              return request({\n\t                ${props}\n\t              });\n\t            }`;\n", "  }\n\t  protected printAxiosProp(prop: keyof AxiosRequestConfig, value?: string) {\n\t    if (!value) return '';\n\t    return prop === value ? `${prop},` : `${prop}: ${value},`;\n\t  }\n\t  protected printArg(name: string, type?: TypeItem | string, required?: boolean) {\n\t    if (!type) return;\n\t    const typeName = isString(type) ? type : type.name;\n\t    required = isString(type) ? required : (type as TypeOrigin).required;\n\t    const equal = required ? ':' : '?:';\n", "    return {\n\t      required,\n\t      text: `${name}${equal}${typeName}`,\n\t    };\n\t  }\n\t  protected toURL(type: TypeOperation, requestPathArgName: string) {\n\t    const url = stringify(varString(type.url, requestPathArgName)).replace(/\"/g, '`');\n\t    if (!this.document.info.baseURL) return url;\n\t    return `resolveURL(BASE_URL, ${url})`;\n\t  }\n", "}\n"]}
{"filename": "src/printers/CommentsPrinter.ts", "chunked_list": ["import type { TypeComments, TypeItem } from '../parsers/types';\n\timport { joinSlices } from '../utils/string';\n\timport { isUndefined } from '../utils/type-is';\n\timport { BasePrinter } from './BasePrinter';\n\texport class CommentsPrinter extends BasePrinter {\n\t  printComments(type: TypeComments, trailingEndOfLine = false) {\n\t    const orders: (keyof TypeComments)[] = ['title', 'description', 'format', 'default', 'example'];\n\t    const mainLines = joinSlices([\n\t      type.deprecated ? ' * @deprecated' : '',\n\t      ...orders.map((key) => {\n", "        const val = type[key];\n\t        if (isUndefined(val)) return '';\n\t        const [firstLine, ...restLines] = String(val).split('\\n');\n\t        return joinSlices([`@${key} ${firstLine}`, ...restLines].map((line) => ` * ${line}`));\n\t      }),\n\t    ]);\n\t    if (mainLines.length === 0) return '';\n\t    return (\n\t      '/**\\n' + //////////////////////////////////////\n\t      mainLines +\n", "      '\\n */' +\n\t      (trailingEndOfLine ? '\\n' : '')\n\t    );\n\t  }\n\t}\n"]}
{"filename": "src/printers/ComponentsPrinter.ts", "chunked_list": ["import type { TypeItem, TypeOrigin } from '../parsers/types';\n\timport { joinSlices, toTypePath } from '../utils/string';\n\timport { BasePrinter } from './BasePrinter';\n\timport { CommentsPrinter } from './CommentsPrinter';\n\texport class ComponentsPrinter extends CommentsPrinter {\n\t  protected init() {\n\t    super.init();\n\t    this.imports.push('import type { OneOf } from \"openapi-axios/helpers\"');\n\t  }\n\t  printComponents() {\n", "    return this.format(joinSlices(this.document.components.map(this.printRootType.bind(this)), '\\n\\n'));\n\t  }\n\t  protected printRootType(type: TypeItem) {\n\t    const comments = this.printComments(type, true);\n\t    return `${comments}export type ${type.name} = ${this.printType(type)};`;\n\t  }\n\t  private printType(type: TypeItem): string {\n\t    if (this.isTypeAlias(type)) return `${type.origin}${toTypePath(type.props)}`;\n\t    switch (type.type) {\n\t      case 'object':\n", "        return this.printObject(type);\n\t      case 'array':\n\t        return this.printArray(type);\n\t      default:\n\t        return this.printPrimitive(type);\n\t    }\n\t  }\n\t  private printPrimitive(type: TypeOrigin) {\n\t    return type.enum ? type.enum.map((el) => JSON.stringify(el)).join('|') : `${type.type}`;\n\t  }\n", "  private printObject(type: TypeOrigin) {\n\t    const { children } = type;\n\t    if (!children || !children.length) return '{[key: string]: never}';\n\t    const kvList = children.map((type) => {\n\t      const comments = this.printComments(type, true);\n\t      const key = type.name;\n\t      const equal = type.required ? ':' : '?:';\n\t      const value = this.printType(type);\n\t      return comments + key + equal + value + ';';\n\t    });\n", "    return '{' + joinSlices(kvList) + '}';\n\t  }\n\t  private printArray(type: TypeOrigin) {\n\t    const { children } = type;\n\t    if (!children || !children.length) return 'never';\n\t    const vList = children.map((type) => {\n\t      const comments = this.printComments(type, true);\n\t      const value = this.printType(type);\n\t      return comments + value;\n\t    });\n", "    return `Array<${joinSlices(vList, '|')}>`;\n\t  }\n\t}\n"]}
{"filename": "src/printers/types.ts", "chunked_list": ["import type { Config } from 'prettier';\n\texport interface PrinterOptions {\n\t  axiosImport?: string;\n\t  /**\n\t   * 格式化配置\n\t   */\n\t  prettier?: Config;\n\t  requestPathArgName?: string;\n\t  requestQueryArgName?: string;\n\t  requestBodyArgName?: string;\n", "  responseTypeName?: 'Promise' | 'AxiosPromise' | string;\n\t}\n\texport type StrictPrinterOptions = Required<PrinterOptions>;\n"]}
{"filename": "src/printers/BasePrinter.ts", "chunked_list": ["import type { TypeAlias, TypeDocument, TypeItem } from '../parsers/types';\n\timport { joinSlices } from '../utils/string';\n\timport type { StrictPrinterOptions, PrinterOptions } from './types';\n\timport prettier from 'prettier';\n\texport class BasePrinter {\n\t  static defaults: StrictPrinterOptions = {\n\t    axiosImport: `import axios from 'axios';`,\n\t    prettier: {\n\t      singleQuote: true,\n\t    },\n", "    requestPathArgName: 'path',\n\t    requestQueryArgName: 'params',\n\t    requestBodyArgName: 'data',\n\t    responseTypeName: 'AxiosPromise',\n\t  };\n\t  options: StrictPrinterOptions;\n\t  constructor(readonly document: TypeDocument, options?: PrinterOptions) {\n\t    this.options = Object.assign({}, BasePrinter.defaults, options) as StrictPrinterOptions;\n\t    this.init();\n\t  }\n", "  protected init() {\n\t    //\n\t  }\n\t  protected isTypeAlias(type: TypeItem): type is TypeAlias {\n\t    return type.kind === 'alias';\n\t  }\n\t  protected format(text: string) {\n\t    return prettier.format(text, {\n\t      ...this.options.prettier,\n\t      parser: 'typescript',\n", "    });\n\t  }\n\t  // 头部声明\n\t  statements: string[] = [];\n\t  // 头部导入\n\t  imports: string[] = [];\n\t  // 帮助类型\n\t  helpers: string[] = [];\n\t  protected printStatements() {\n\t    return joinSlices(this.statements);\n", "  }\n\t  protected printImports() {\n\t    return this.format(joinSlices(this.imports));\n\t  }\n\t  protected printHelpers() {\n\t    return this.format(joinSlices(this.helpers));\n\t  }\n\t}\n"]}
{"filename": "src/printers/DocumentPrinter.ts", "chunked_list": ["import { joinSlices } from '../utils/string';\n\timport { PathsPrinter } from './PathsPrinter';\n\texport class DocumentPrinter extends PathsPrinter {\n\t  print() {\n\t    return joinSlices([\n\t      //\n\t      this.printStatements(),\n\t      this.printImports(),\n\t      this.printHelpers(),\n\t      this.printComponents(),\n", "      this.printPaths(),\n\t    ]);\n\t  }\n\t}\n"]}
{"filename": "src/utils/fs2.ts", "chunked_list": ["import fs from 'fs/promises';\n\texport async function isFile(p: string) {\n\t  try {\n\t    const state = await fs.stat(p);\n\t    return state.isFile();\n\t  } catch (err) {\n\t    return false;\n\t  }\n\t}\n\texport async function cleanDir(p: string) {\n", "  await fs.rm(p, { recursive: true, force: true });\n\t}\n"]}
{"filename": "src/utils/type-is.ts", "chunked_list": ["export function isUndefined(any: unknown): any is undefined {\n\t  return any === undefined;\n\t}\n\texport function isString(any: unknown): any is string {\n\t  return typeof any === 'string';\n\t}\n\texport function isBoolean(any: unknown): any is boolean {\n\t  return typeof any === 'boolean';\n\t}\n\texport function isNumber(any: unknown): any is number {\n", "  return typeof any === 'number';\n\t}\n\texport function isObject(any: unknown): any is object {\n\t  return typeof any === 'object' && any !== null;\n\t}\n\texport function isDate(any: unknown): any is Date {\n\t  return Boolean(any && any instanceof Date);\n\t}\n\texport function isUrl(any: string): boolean {\n\t  return /^https:\\/\\//i.test(any);\n", "}\n\texport function isVarName(varName: string) {\n\t  return /^[a-z_$]\\w*$/i.test(varName);\n\t}\n"]}
{"filename": "src/utils/string.ts", "chunked_list": ["import { isVarName } from './type-is';\n\texport function buildName(origin: string, bigger = false) {\n\t  const name =\n\t    origin\n\t      .replace(/\\W/g, '_')\n\t      .replace(/(^_+|_+$)/g, '')\n\t      .replace(/_(.)/g, ($0, $1: string) => $1.toUpperCase())\n\t      .replace(/^\\d+/, '') || 'unnamed';\n\t  return (bigger ? name[0].toUpperCase() : name[0].toLowerCase()) + name.slice(1);\n\t}\n", "export interface RefInfo {\n\t  type: string;\n\t  base: string;\n\t  props: string[];\n\t}\n\texport function refToType(ref: string): RefInfo {\n\t  const segs = ref.split('/').slice(3);\n\t  const type = segs[0]!;\n\t  return {\n\t    type,\n", "    base: `#/components/schemas/${type}`,\n\t    props: segs.slice(1),\n\t  };\n\t}\n\texport function findOrigin(source: string, relation: Map<string, string>) {\n\t  let origin = source;\n\t  let target: string | undefined;\n\t  while ((target = relation.get(origin))) {\n\t    origin = target;\n\t  }\n", "  return origin;\n\t}\n\texport function varString(string: string, leading = ''): string {\n\t  return string.replace(/\\{([^}]+)\\}/g, ($0, $1: string) => {\n\t    const key = leading ? (isVarName($1) ? `${leading}.${$1}` : `${leading}[${JSON.stringify($1)}]`) : $1;\n\t    return `$\\{${key}}`;\n\t  });\n\t}\n\texport function toTypePath(props: string[]): string {\n\t  const path = props.map((p) => JSON.stringify(p)).join('][');\n", "  return path ? '[' + path + ']' : '';\n\t}\n\texport function joinSlices(slices: Array<string | undefined>, separator = '\\n') {\n\t  return slices.filter(Boolean).join(separator);\n\t}\n\texport function nextUniqueName(refName: string, nameCountMap: Map<string, number>) {\n\t  // abc123 -> abc\n\t  const baseName = refName.replace(/\\d+$/, '');\n\t  const count = nameCountMap.get(baseName) || 0;\n\t  const nextCount = count + 1;\n", "  nameCountMap.set(baseName, nextCount);\n\t  return nextCount === 1 ? baseName : baseName + nextCount;\n\t}\n"]}
{"filename": "src/generators/Generator.ts", "chunked_list": ["import fs from 'fs';\n\timport path from 'path';\n\timport process from 'process';\n\timport { Emitter } from 'strict-event-emitter';\n\timport { normalizeError } from 'try-flatten';\n\timport { DocumentParser } from '../parsers/DocumentParser';\n\timport { DocumentPrinter } from '../printers/DocumentPrinter';\n\timport { Reader } from './Reader';\n\timport type {\n\t  GeneratingOptions,\n", "  GeneratingStage,\n\t  GeneratorEmits,\n\t  GeneratorOptions,\n\t  GeneratingPayload,\n\t  OpenAPIOptions,\n\t  StrictGeneratorOptions,\n\t  GeneratorPayload,\n\t} from './types';\n\texport class Generator extends Emitter<GeneratorEmits> {\n\t  static defaults: StrictGeneratorOptions = {\n", "    cwd: process.cwd(),\n\t    dest: '/src/apis',\n\t    openAPIs: [],\n\t  };\n\t  options: StrictGeneratorOptions;\n\t  constructor(options: GeneratorOptions) {\n\t    super();\n\t    this.options = Object.assign({}, Generator.defaults, options) as StrictGeneratorOptions;\n\t  }\n\t  async generate() {\n", "    const count = this.options.openAPIs.length;\n\t    const payload: GeneratorPayload = { count };\n\t    this.emit('start', payload);\n\t    try {\n\t      let index = 0;\n\t      for (const openAPI of this.options.openAPIs) {\n\t        await this.generateOpenAPI(index, count, openAPI, this.options);\n\t        index++;\n\t      }\n\t    } catch (cause) {\n", "      const err = normalizeError(cause);\n\t      this.emit('error', err, payload);\n\t      throw err;\n\t    }\n\t    this.emit('end', payload);\n\t  }\n\t  protected async generateOpenAPI(\n\t    index: number,\n\t    count: number,\n\t    openAPIOptions: OpenAPIOptions,\n", "    generatorOptions: StrictGeneratorOptions\n\t  ) {\n\t    const { cwd, dest, parser: globalParser, printer: globalPrinter } = generatorOptions;\n\t    const { name, document, parser: scopeParser, printer: scopePrinter } = openAPIOptions;\n\t    const fileName = `${name}.ts`;\n\t    const filePath = path.join(cwd, dest, fileName);\n\t    // 1. 参数合并\n\t    const parserOptions = Object.assign({}, globalParser, scopeParser);\n\t    const printerOptions = Object.assign({}, globalPrinter, scopePrinter);\n\t    const options: GeneratingOptions = {\n", "      ...openAPIOptions,\n\t      cwd,\n\t      dest,\n\t      parser: parserOptions,\n\t      printer: printerOptions,\n\t    };\n\t    const makePayload = (step: GeneratingStage): GeneratingPayload => ({\n\t      index,\n\t      count,\n\t      stage: step,\n", "      options,\n\t      filePath,\n\t    });\n\t    // 2. 读取\n\t    this.emit('process', makePayload('reading'));\n\t    const reader = new Reader();\n\t    reader.cwd = cwd;\n\t    const openAPIV3Document = await reader.read(document);\n\t    // 3. 解析\n\t    this.emit('process', makePayload('parsing'));\n", "    const parser = new DocumentParser(openAPIV3Document, parserOptions);\n\t    const types = parser.parse();\n\t    // 4. 输出\n\t    this.emit('process', makePayload('printing'));\n\t    const printer = new DocumentPrinter(types, printerOptions);\n\t    const text = printer.print();\n\t    // 5. 写入\n\t    this.emit('process', makePayload('writing'));\n\t    fs.mkdirSync(path.dirname(filePath), { recursive: true });\n\t    fs.writeFileSync(filePath, text, 'utf8');\n", "    this.emit('process', makePayload('generated'));\n\t  }\n\t}\n"]}
{"filename": "src/generators/Reader.ts", "chunked_list": ["import axios from 'axios';\n\timport fs from 'fs';\n\timport path from 'path';\n\timport process from 'process';\n\timport type { AcceptDocument } from '../parsers/types';\n\timport type { OpenAPIV3Document } from '../types/openapi';\n\timport { isString } from '../utils/type-is';\n\texport class Reader {\n\t  cwd = process.cwd();\n\t  async read(document: AcceptDocument): Promise<OpenAPIV3Document> {\n", "    if (isString(document)) {\n\t      if (/^https?:/i.test(document)) {\n\t        return await this.readRemote(document);\n\t      } else {\n\t        return this.readLocal(document);\n\t      }\n\t    } else {\n\t      return this.readObject(document);\n\t    }\n\t  }\n", "  static validate(document: AcceptDocument) {\n\t    // TODO\n\t  }\n\t  protected readLocal(file: string) {\n\t    const data = fs.readFileSync(path.resolve(this.cwd, file), 'utf8');\n\t    return JSON.parse(data) as OpenAPIV3Document;\n\t  }\n\t  protected async readRemote(url: string) {\n\t    const { data } = await axios.request<OpenAPIV3Document>({\n\t      url,\n", "      method: 'get',\n\t    });\n\t    return data;\n\t  }\n\t  protected readObject(document: OpenAPIV3Document) {\n\t    return document;\n\t  }\n\t}\n"]}
{"filename": "src/generators/Logger.ts", "chunked_list": ["import chalk from 'chalk';\n\timport path from 'path';\n\timport type { GeneratorEmits } from './types';\n\texport class Logger {\n\t  pipeStartEvent(...[payload]: GeneratorEmits['start']) {\n\t    console.log(chalk.greenBright('▶'), `即将处理 ${payload.count} 个 openAPI 文档`);\n\t  }\n\t  pipeProcessEvent(...[payload]: GeneratorEmits['process']) {\n\t    const width = payload.count.toString().length;\n\t    const step = (payload.index + 1).toString().padStart(width, '0');\n", "    console.log(\n\t      chalk.cyanBright('▷'),\n\t      chalk.yellowBright(`${step}/${payload.count}`),\n\t      payload.options.name,\n\t      payload.stage,\n\t      payload.stage === 'generated' ? path.relative(payload.options.cwd, payload.filePath) : ''\n\t    );\n\t  }\n\t  pipeEndEvent(...[payload]: GeneratorEmits['end']) {\n\t    console.log(chalk.greenBright('■'), '处理完成');\n", "  }\n\t  pipeErrorEvent(...[err]: GeneratorEmits['error']) {\n\t    console.log(chalk.redBright('●'), '处理失败');\n\t    console.log(chalk.redBright(err.message));\n\t  }\n\t  pipeConfigError(err: Error) {\n\t    console.log(chalk.redBright('○'), '配置错误');\n\t    console.log(chalk.redBright(err.message));\n\t  }\n\t}\n"]}
{"filename": "src/generators/types.ts", "chunked_list": ["import type { AcceptDocument, ParserOptions } from '../parsers/types';\n\timport type { PrinterOptions } from '../printers/types';\n\timport type { OpenAPIV3Document } from '../types/openapi';\n\ttype RequiredWith<T, K extends keyof T> = T & { [P in K]-?: T[P] };\n\texport interface OpenAPIOptions {\n\t  /**\n\t   * openapi 的名称，将会生成 ${name}.ts 文件\n\t   */\n\t  name: string;\n\t  /**\n", "   * openapi 的 document，可以是一个链接地址，也可以是本地路径，也可以是一个对象\n\t   */\n\t  document: AcceptDocument;\n\t  /**\n\t   * 解析配置，优先级高于全局配置\n\t   */\n\t  parser?: ParserOptions;\n\t  /**\n\t   * 输出配置，优先级高于全局配置\n\t   */\n", "  printer?: PrinterOptions;\n\t}\n\texport interface GeneratorOptions {\n\t  /**\n\t   * 工作目录，默认为 process.cwd()\n\t   */\n\t  cwd?: string;\n\t  /**\n\t   * 生成文件目的地，默认为 src/apis\n\t   */\n", "  dest?: string;\n\t  /**\n\t   * 解析配置\n\t   */\n\t  parser?: ParserOptions;\n\t  /**\n\t   * 输出配置\n\t   */\n\t  printer?: PrinterOptions;\n\t  /**\n", "   * openapi 配置列表\n\t   */\n\t  openAPIs: OpenAPIOptions[];\n\t}\n\texport type StrictGeneratorOptions = RequiredWith<GeneratorOptions, 'cwd' | 'dest'>;\n\texport type GeneratingStage = 'reading' | 'parsing' | 'printing' | 'writing' | 'generated';\n\texport type GeneratingOptions = OpenAPIOptions & Pick<StrictGeneratorOptions, 'cwd' | 'dest'>;\n\texport interface GeneratorPayload {\n\t  count: number;\n\t}\n", "export interface GeneratingPayload {\n\t  index: number;\n\t  count: number;\n\t  stage: GeneratingStage;\n\t  options: GeneratingOptions;\n\t  filePath: string;\n\t}\n\texport type GeneratorEmits = {\n\t  // 所有开始\n\t  start: [GeneratorPayload];\n", "  // 所有结束\n\t  end: [GeneratorPayload];\n\t  // 处理中\n\t  process: [GeneratingPayload];\n\t  error: [Error, GeneratorPayload];\n\t};\n"]}
{"filename": "src/generators/command.ts", "chunked_list": ["import fs from 'fs';\n\timport path from 'path';\n\timport process from 'process';\n\timport { tryFlatten } from 'try-flatten';\n\timport { z } from 'zod';\n\timport { Generator } from './Generator';\n\timport { Logger } from './Logger';\n\timport type { GeneratorOptions } from './types';\n\texport function defineConfig(options: GeneratorOptions): GeneratorOptions {\n\t  return options;\n", "}\n\texport const configFileNameOrder = [\n\t  //\n\t  'openapi.config.cjs',\n\t  'openapi.config.js',\n\t];\n\texport function resolveConfigFile(cwd: string) {\n\t  for (const fileName of configFileNameOrder.values()) {\n\t    const filePath = path.join(cwd, fileName);\n\t    if (fs.existsSync(filePath)) {\n", "      return filePath;\n\t    }\n\t  }\n\t}\n\texport function resolveConfig(cwd: string): GeneratorOptions {\n\t  const configFile = resolveConfigFile(cwd);\n\t  if (!configFile) {\n\t    throw new Error(`配置文件未找到，配置文件可以是 ${configFileNameOrder.join('、')} 之一`);\n\t  }\n\t  const configFileName = path.relative(cwd, configFile);\n", "  const [err, config] = tryFlatten(() => {\n\t    delete require.cache[require.resolve(configFile)];\n\t    // eslint-disable-next-line @typescript-eslint/no-var-requires\n\t    return require(configFile) as GeneratorOptions;\n\t  });\n\t  if (err) {\n\t    throw err;\n\t  }\n\t  const schema = z\n\t    .object({\n", "      cwd: z.string(),\n\t      dest: z.string(),\n\t      openAPIs: z\n\t        .array(\n\t          z.object({\n\t            name: z.string(),\n\t            document: z.union([z.object({}), z.string()]),\n\t          })\n\t        )\n\t        .min(1),\n", "    })\n\t    .partial({\n\t      cwd: true,\n\t      dest: true,\n\t    });\n\t  const result = schema.safeParse(config);\n\t  if (result.success) return config;\n\t  if (result.error.isEmpty) return config;\n\t  const firstIssue = result.error.issues[0];\n\t  if (!firstIssue) return config;\n", "  throw new Error(`${configFileName}: #/${firstIssue.path.join('/')} - ${firstIssue.message}`);\n\t}\n\texport async function run(cwd = process.cwd()) {\n\t  const logger = new Logger();\n\t  const [err, config] = tryFlatten(() => resolveConfig(cwd));\n\t  if (err) return logger.pipeConfigError(err);\n\t  config.cwd = config.cwd || cwd;\n\t  const generator = new Generator(config);\n\t  generator.on('start', logger.pipeStartEvent);\n\t  generator.on('end', logger.pipeEndEvent);\n", "  generator.on('error', logger.pipeErrorEvent);\n\t  generator.on('process', logger.pipeProcessEvent);\n\t  await tryFlatten(generator.generate());\n\t}\n"]}
{"filename": "src/parsers/PathsParser.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\n\timport { ComponentsParser } from './ComponentsParser';\n\timport { BLOB_MIME, JSON_MIME, HTTP_METHODS } from './const';\n\timport type { TypeItem, TypeList, TypeOperation, TypeOperations, TypeOrigin } from './types';\n\texport class PathsParser extends ComponentsParser {\n\t  parsingUrl = '';\n\t  parsingMethod: OpenAPIV3.HttpMethods = OpenAPIV3.HttpMethods.GET;\n\t  parsePaths(): TypeOperations {\n\t    const { paths } = this.document;\n\t    const types: TypeOperations = [];\n", "    Object.entries(paths)\n\t      .sort((a, b) => a[0].localeCompare(b[0]))\n\t      .forEach(([url, pathItem]) => {\n\t        if (!pathItem) return;\n\t        this.parsingUrl = url;\n\t        types.push(...this.parsePathItem(pathItem));\n\t      });\n\t    this.named.resolveAlias();\n\t    return types;\n\t  }\n", "  protected parsePathItem(pathItem: OpenAPIV3.PathItemObject) {\n\t    const types: TypeOperations = [];\n\t    HTTP_METHODS.forEach((method) => {\n\t      const operation = pathItem[method];\n\t      if (!operation) return;\n\t      this.parsingMethod = method;\n\t      types.push(this.parseOperation(operation));\n\t    });\n\t    return types;\n\t  }\n", "  parseOperation(operation: OpenAPIV3.OperationObject): TypeOperation {\n\t    const { parameters, requestBody: requestBodySchema } = operation;\n\t    const { pathTypes, queryTypes } = this.parseOperationParameters(parameters);\n\t    const initialName = this.named.nextOperationId(this.parsingMethod, this.parsingUrl, operation.operationId);\n\t    const name = this.options.nameFormatter({\n\t      name: initialName,\n\t      method: this.parsingMethod,\n\t      url: this.parsingUrl,\n\t      operationId: operation.operationId,\n\t    });\n", "    const requestPathTypeName = this.named.nextTypeName(name + this.options.requestPathTypeName);\n\t    const requestQueryTypeName = this.named.nextTypeName(name + this.options.requestQueryTypeName);\n\t    const requestBodyTypeName = this.named.nextTypeName(name + this.options.requestBodyTypeName);\n\t    const responseBodyTypeName = this.named.nextTypeName(name + this.options.responseBodyTypeName);\n\t    const requestBody = this.parseOperationRequest(requestBodyTypeName, requestBodySchema);\n\t    return {\n\t      name,\n\t      method: this.parsingMethod,\n\t      url: this.parsingUrl,\n\t      title: operation.summary,\n", "      description: operation.description,\n\t      deprecated: operation.deprecated,\n\t      request: {\n\t        path: this.wrapParameters(requestPathTypeName, pathTypes),\n\t        query: this.wrapParameters(requestQueryTypeName, queryTypes),\n\t        body: requestBody,\n\t      },\n\t      response: {\n\t        body: this.parseOperationResponse(responseBodyTypeName, operation.responses),\n\t      },\n", "    };\n\t  }\n\t  protected wrapParameters(name: string, types?: TypeList): TypeOrigin | undefined {\n\t    if (!types) return;\n\t    if (types.length === 0) return;\n\t    return {\n\t      kind: 'origin',\n\t      name,\n\t      type: 'object',\n\t      // 有一个必填属性时，则该对象必填\n", "      required: types.some((type) => (this.isTypeAlias(type) ? true : type.required)),\n\t      children: types,\n\t    };\n\t  }\n\t  protected parseOperationParameters(parameters: OpenAPIV3.OperationObject['parameters'] = []) {\n\t    const pathTypes: TypeList = [];\n\t    const queryTypes: TypeList = [];\n\t    parameters.forEach((parameter) => {\n\t      const t = this.parseOperationParameter(parameter);\n\t      if (!t) return;\n", "      if (!('in' in parameter)) return;\n\t      if (parameter.in === 'path') {\n\t        pathTypes.push(t);\n\t      } else if (parameter.in === 'query') {\n\t        queryTypes.push(t);\n\t      }\n\t    });\n\t    return { pathTypes, queryTypes };\n\t  }\n\t  protected parseOperationParameter(parameter: OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject) {\n", "    if (this.isReference(parameter)) return;\n\t    const { schema, name, required = false, deprecated, description, example } = parameter;\n\t    if (!schema) return;\n\t    return this.isReference(schema)\n\t      ? this.parseReference(name, required, schema)\n\t      : this.parseSchema(name, required, {\n\t          deprecated,\n\t          description,\n\t          example,\n\t          ...schema,\n", "        });\n\t  }\n\t  parseOperationRequest(name: string, body: OpenAPIV3.OperationObject['requestBody']): TypeItem | undefined {\n\t    if (!body) return;\n\t    if (this.isReference(body)) return;\n\t    const { content } = body;\n\t    const jsonReq = content[JSON_MIME];\n\t    const blobReq = content[BLOB_MIME];\n\t    if (jsonReq) return this.parseOperationMedia(name, jsonReq);\n\t    if (blobReq)\n", "      return {\n\t        kind: 'alias',\n\t        name,\n\t        refAble: false,\n\t        required: true,\n\t        target: 'Blob',\n\t        origin: 'Blob',\n\t        props: [],\n\t      };\n\t  }\n", "  protected parseOperationResponse(name: string, responses: NonNullable<OpenAPIV3.ResponsesObject>) {\n\t    const okResponse = responses[this.options.okCode];\n\t    if (!okResponse) return;\n\t    if (this.isReference(okResponse)) return;\n\t    const { content } = okResponse;\n\t    if (!content) return;\n\t    const okMedia = content[this.options.okMediaType];\n\t    if (!okMedia) return;\n\t    return this.parseOperationMedia(name, okMedia);\n\t  }\n", "  protected parseOperationMedia(name: string, media: OpenAPIV3.MediaTypeObject) {\n\t    const { schema } = media;\n\t    if (!schema) return this.parseSchemaNever(name, true, {});\n\t    return this.isReference(schema)\n\t      ? this.parseReference(name, true, schema)\n\t      : this.parseSchema(name, schema.nullable === false, schema);\n\t  }\n\t}\n"]}
{"filename": "src/parsers/ComponentsParser.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\n\timport { isBoolean } from '../utils/type-is';\n\timport { BaseParser } from './BaseParser';\n\timport type { TypeAlias, TypeItem, TypeList, TypeOrigin, TypeUnit } from './types';\n\texport class ComponentsParser extends BaseParser {\n\t  parseComponents(): TypeList {\n\t    const { components } = this.document;\n\t    if (!components) return [];\n\t    const { schemas } = components;\n\t    if (!schemas) return [];\n", "    const t = Object.entries(schemas)\n\t      .sort((a, b) => a[0].localeCompare(b[0]))\n\t      .map(([name, schema]) => {\n\t        const typeName = this.named.nextTypeName(name, true);\n\t        return this.isReference(schema)\n\t          ? this.parseReference(typeName, true, schema, true)\n\t          : this.parseSchema(typeName, schema.nullable === false, schema);\n\t      });\n\t    this.named.resolveAlias();\n\t    return t;\n", "  }\n\t  protected parseReference(\n\t    name: string,\n\t    required: boolean,\n\t    reference: OpenAPIV3.ReferenceObject,\n\t    refAble = false\n\t  ): TypeAlias {\n\t    return this.named.addAlias({\n\t      kind: 'alias',\n\t      refAble,\n", "      name,\n\t      required,\n\t      ref: reference.$ref,\n\t      target: '',\n\t      origin: '',\n\t      props: [],\n\t    });\n\t  }\n\t  protected parseSchema(name: string, required: boolean, schema: OpenAPIV3.SchemaObject) {\n\t    const { type } = schema;\n", "    switch (type) {\n\t      case 'boolean':\n\t      case 'string':\n\t      case 'number':\n\t      case 'integer': {\n\t        const tsType = type === 'integer' ? 'number' : type;\n\t        return this.parseSchemaPrimitive(name, required, tsType, schema);\n\t      }\n\t      case 'object':\n\t        return this.parseSchemaObject(name, required, schema);\n", "      case 'array':\n\t        return this.parseSchemaArray(name, required, schema);\n\t      default:\n\t        return this.parseSchemaNever(name, true, schema);\n\t    }\n\t  }\n\t  protected parseSchemaPrimitive(\n\t    name: string,\n\t    required: boolean,\n\t    type: TypeUnit,\n", "    schema: OpenAPIV3.SchemaObject\n\t  ): TypeOrigin {\n\t    return {\n\t      ...this.inheritProps(schema),\n\t      name,\n\t      type,\n\t      required,\n\t      kind: 'origin',\n\t    };\n\t  }\n", "  protected parseSchemaObject(name: string, required: boolean, schema: OpenAPIV3.SchemaObject): TypeOrigin {\n\t    const properties = Object.entries(schema.properties || {}).sort((a, b) => a[0].localeCompare(b[0]));\n\t    const children = properties.map(([propName, propSchema]) => {\n\t      const required = schema.required?.includes(propName) || false;\n\t      return this.isReference(propSchema)\n\t        ? this.parseReference(propName, required, propSchema)\n\t        : this.parseSchema(propName, required, propSchema);\n\t    });\n\t    const additional = this.parseObjectAdditionalProperties(schema.additionalProperties);\n\t    if (additional) children.push(additional);\n", "    return {\n\t      ...this.inheritProps(schema),\n\t      name,\n\t      required,\n\t      kind: 'origin',\n\t      type: 'object',\n\t      children,\n\t    };\n\t  }\n\t  protected parseSchemaArray(name: string, required: boolean, schema: OpenAPIV3.ArraySchemaObject): TypeOrigin {\n", "    const children = [schema.items].map((schema) => {\n\t      return this.isReference(schema)\n\t        ? this.parseReference(`${name}[]`, true, schema)\n\t        : this.parseSchema(`${name}[]`, schema.nullable === false, schema);\n\t    });\n\t    const additional = this.parseObjectAdditionalProperties(schema.additionalProperties);\n\t    if (additional) children.push(additional);\n\t    return {\n\t      ...this.inheritProps(schema),\n\t      name,\n", "      required,\n\t      kind: 'origin',\n\t      type: 'array',\n\t      children: children,\n\t    };\n\t  }\n\t  protected parseObjectAdditionalProperties(\n\t    additionalProperties: OpenAPIV3.SchemaObject['additionalProperties']\n\t  ): TypeItem | undefined {\n\t    if (!additionalProperties) return;\n", "    const name = '[key: string]';\n\t    if (isBoolean(additionalProperties)) {\n\t      if (additionalProperties) {\n\t        return {\n\t          kind: 'origin',\n\t          type: 'any',\n\t          name,\n\t          required: true,\n\t        };\n\t      }\n", "      return;\n\t    }\n\t    return this.isReference(additionalProperties)\n\t      ? this.parseReference(name, true, additionalProperties)\n\t      : this.parseSchema(name, true, additionalProperties);\n\t  }\n\t  protected parseSchemaNever(name: string, required: boolean, schema: OpenAPIV3.SchemaObject): TypeOrigin {\n\t    return {\n\t      ...this.inheritProps(schema),\n\t      name,\n", "      required,\n\t      kind: 'origin',\n\t      type: 'never',\n\t    };\n\t  }\n\t  private inheritProps(schema: OpenAPIV3.BaseSchemaObject) {\n\t    return {\n\t      default: schema.default,\n\t      description: schema.description,\n\t      example: schema.example,\n", "      deprecated: schema.deprecated,\n\t      title: schema.title,\n\t      format: schema.format,\n\t      enum: schema.enum,\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/parsers/Named.ts", "chunked_list": ["import { buildName, findOrigin, nextUniqueName, refToType } from '../utils/string';\n\timport type { TypeAlias } from './types';\n\texport class Named {\n\t  private aliasRelationMap = new Map<string /*source*/, string /*target*/>();\n\t  private unresolvedAliasList: TypeAlias[] = [];\n\t  addAlias(a: TypeAlias): TypeAlias {\n\t    this.unresolvedAliasList.push(a);\n\t    return a;\n\t  }\n\t  resolveAlias() {\n", "    this.unresolvedAliasList.forEach((a) => {\n\t      if (!a.ref) return;\n\t      const info = refToType(a.ref);\n\t      a.target = this.getName(info.base);\n\t      a.props = info.props;\n\t      // 指向另外一个地址\n\t      const { refAble, name, target } = a;\n\t      if (refAble) {\n\t        this.aliasRelationMap.set(name, target);\n\t      }\n", "    });\n\t    this.unresolvedAliasList.forEach((a) => {\n\t      a.origin = findOrigin(a.refAble ? a.name : a.target, this.aliasRelationMap);\n\t    });\n\t    this.unresolvedAliasList.length = 0;\n\t  }\n\t  nameCountMap = new Map<string /*name*/, number /*count*/>();\n\t  nameRefMap = new Map<string /*name*/, string /*ref*/>();\n\t  refNameMap = new Map<string /*ref*/, string /*name*/>();\n\t  /**\n", "   * 注册内部名称\n\t   * @param {string} name\n\t   */\n\t  internalName(name: string) {\n\t    this.nameCountMap.set(name, 1);\n\t  }\n\t  nextTypeName(name: string, refAble = false) {\n\t    const ref = refAble ? `#/components/schemas/${name}` : '';\n\t    const refTypeName = buildName(name, true);\n\t    const uniqueTypeName = nextUniqueName(refTypeName, this.nameCountMap);\n", "    if (ref) {\n\t      this.nameRefMap.set(uniqueTypeName, ref);\n\t      this.refNameMap.set(ref, uniqueTypeName);\n\t    }\n\t    return uniqueTypeName;\n\t  }\n\t  getName(ref: string) {\n\t    return this.refNameMap.get(ref) || '';\n\t  }\n\t  nextOperationId(method: string, url: string, operationId?: string) {\n", "    operationId = operationId || buildName([method, url.split('/').pop()!].join('_'));\n\t    return nextUniqueName(operationId, this.nameCountMap);\n\t  }\n\t}\n"]}
{"filename": "src/parsers/types.ts", "chunked_list": ["import type { OpenAPIV3Document } from '../types/openapi';\n\texport type TypeUnit = 'number' | 'string' | 'boolean' | 'never' | 'object' | 'array' | 'any';\n\texport interface TypeComments {\n\t  title?: string;\n\t  description?: string;\n\t  default?: any;\n\t  example?: any;\n\t  deprecated?: boolean;\n\t  format?: string;\n\t}\n", "export interface TypeOrigin extends TypeComments {\n\t  kind: 'origin';\n\t  name: string;\n\t  type: TypeUnit;\n\t  required: boolean;\n\t  enum?: string[];\n\t  children?: TypeList;\n\t}\n\texport interface TypeAlias extends TypeComments {\n\t  kind: 'alias';\n", "  refAble: boolean;\n\t  required: boolean;\n\t  name: string;\n\t  target: string;\n\t  origin: string;\n\t  props: string[];\n\t  ref?: string;\n\t}\n\texport type TypeItem = TypeOrigin | TypeAlias;\n\texport type TypeList = TypeItem[];\n", "export interface NameFormatterProps {\n\t  name: string;\n\t  method: string;\n\t  url: string;\n\t  operationId?: string;\n\t}\n\texport interface ParserOptions {\n\t  cwd?: string;\n\t  /**\n\t   * ok 的响应码\n", "   * @default 200\n\t   */\n\t  okCode?: number;\n\t  /**\n\t   * ok 的响应类型\n\t   * @default [\"application/json\"]\n\t   */\n\t  okMediaType?: string;\n\t  nameFormatter?: (props: NameFormatterProps) => string;\n\t  requestPathTypeName?: string;\n", "  requestQueryTypeName?: string;\n\t  requestBodyTypeName?: string;\n\t  responseBodyTypeName?: string;\n\t}\n\texport type StrictParserOptions = Required<ParserOptions>;\n\texport interface TypeOperation extends TypeComments {\n\t  method: string;\n\t  url: string;\n\t  name: string;\n\t  request: {\n", "    path?: TypeItem;\n\t    query?: TypeItem;\n\t    body?: TypeItem;\n\t  };\n\t  response: {\n\t    body?: TypeItem;\n\t  };\n\t}\n\texport type TypeOperations = TypeOperation[];\n\texport interface TypeDocument {\n", "  info: {\n\t    title: string;\n\t    description?: string;\n\t    version: string;\n\t    baseURL?: string;\n\t  };\n\t  components: TypeList;\n\t  paths: TypeOperations;\n\t}\n\texport type AcceptDocument = OpenAPIV3Document | string;\n"]}
{"filename": "src/parsers/const.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\n\texport const HTTP_METHODS: OpenAPIV3.HttpMethods[] = [\n\t  OpenAPIV3.HttpMethods.DELETE,\n\t  OpenAPIV3.HttpMethods.GET,\n\t  OpenAPIV3.HttpMethods.HEAD,\n\t  OpenAPIV3.HttpMethods.OPTIONS,\n\t  OpenAPIV3.HttpMethods.PATCH,\n\t  OpenAPIV3.HttpMethods.POST,\n\t  OpenAPIV3.HttpMethods.PUT,\n\t  OpenAPIV3.HttpMethods.TRACE,\n", "];\n\texport const JSON_MIME = 'application/json';\n\texport const BLOB_MIME = 'application/octet-stream';\n\t// 内部名称，文档里如果重复了会生成新的唯一值\n\texport const INTERNAL_NAMES = [\n\t  // native\n\t  'Blob',\n\t  // @ref ComponentsWriter\n\t  'OneOf',\n\t  // @ref PathsWriter\n", "  'axios',\n\t  'request',\n\t  'DELETE',\n\t  'GET',\n\t  'HEAD',\n\t  'OPTIONS',\n\t  'PATCH',\n\t  'POST',\n\t  'PUT',\n\t  'TRACE',\n", "  'resolveURL',\n\t  'BASE_URL',\n\t  'AxiosPromise',\n\t  'AxiosRequestConfig',\n\t];\n\t// @ref https://www.w3schools.com/js/js_reserved.asp\n\texport const JS_RESERVED_NAMES = [\n\t  'abstract',\n\t  'arguments',\n\t  'await',\n", "  'boolean',\n\t  'break',\n\t  'byte',\n\t  'case',\n\t  'catch',\n\t  'char',\n\t  'class',\n\t  'const',\n\t  'continue',\n\t  'debugger',\n", "  'default',\n\t  'delete',\n\t  'do',\n\t  'double',\n\t  'else',\n\t  'enum',\n\t  'eval',\n\t  'export',\n\t  'extends',\n\t  'false',\n", "  'final',\n\t  'finally',\n\t  'float',\n\t  'for',\n\t  'function',\n\t  'goto',\n\t  'if',\n\t  'implements',\n\t  'import',\n\t  'in',\n", "  'instanceof',\n\t  'int',\n\t  'interface',\n\t  'let',\n\t  'long',\n\t  'native',\n\t  'new',\n\t  'null',\n\t  'package',\n\t  'private',\n", "  'protected',\n\t  'public',\n\t  'return',\n\t  'short',\n\t  'static',\n\t  'super',\n\t  'switch',\n\t  'synchronized',\n\t  'this',\n\t  'throw',\n", "  'throws',\n\t  'transient',\n\t  'true',\n\t  'try',\n\t  'typeof',\n\t  'var',\n\t  'void',\n\t  'volatile',\n\t  'while',\n\t  'with',\n", "  'yield',\n\t  'abstract',\n\t  'boolean',\n\t  'byte',\n\t  'char',\n\t  'double',\n\t  'final',\n\t  'float',\n\t  'goto',\n\t  'int',\n", "  'long',\n\t  'native',\n\t  'short',\n\t  'synchronized',\n\t  'throws',\n\t  'transient',\n\t  'volatile',\n\t];\n"]}
{"filename": "src/parsers/BaseParser.ts", "chunked_list": ["import process from 'process';\n\timport type { OpenAPIV3, OpenAPIV3Document } from '../types/openapi';\n\timport { INTERNAL_NAMES, JS_RESERVED_NAMES, JSON_MIME } from './const';\n\timport { Named } from './Named';\n\timport type { ParserOptions, StrictParserOptions, TypeAlias, TypeItem } from './types';\n\texport class BaseParser {\n\t  named = new Named();\n\t  static defaults: StrictParserOptions = {\n\t    cwd: process.cwd(),\n\t    okCode: 200,\n", "    okMediaType: JSON_MIME,\n\t    nameFormatter: ({ name }) => name,\n\t    requestPathTypeName: 'ReqPath',\n\t    requestQueryTypeName: 'ReqParams',\n\t    requestBodyTypeName: 'ReqData',\n\t    responseBodyTypeName: 'ResData',\n\t  };\n\t  options: StrictParserOptions;\n\t  constructor(protected document: OpenAPIV3Document, options?: ParserOptions) {\n\t    this.options = Object.assign({}, BaseParser.defaults, options) as StrictParserOptions;\n", "    INTERNAL_NAMES.forEach(this.named.internalName.bind(this.named));\n\t    JS_RESERVED_NAMES.forEach(this.named.internalName.bind(this.named));\n\t    this.init();\n\t  }\n\t  protected init() {\n\t    //\n\t  }\n\t  protected isReference(\n\t    object: OpenAPIV3.ReferenceObject | OpenAPIV3.SchemaObject | OpenAPIV3.ParameterObject | OpenAPIV3.RequestBodyObject\n\t  ): object is OpenAPIV3.ReferenceObject {\n", "    return '$ref' in object;\n\t  }\n\t  protected isTypeAlias(type: TypeItem): type is TypeAlias {\n\t    return type.kind === 'alias';\n\t  }\n\t}\n"]}
{"filename": "src/parsers/DocumentParser.ts", "chunked_list": ["import { PathsParser } from './PathsParser';\n\timport type { TypeDocument } from './types';\n\texport class DocumentParser extends PathsParser {\n\t  parse(): TypeDocument {\n\t    const components = this.parseComponents();\n\t    const paths = this.parsePaths();\n\t    const { info, servers } = this.document;\n\t    const firstServer = servers?.[0];\n\t    const baseURL = firstServer && firstServer.url;\n\t    const { title, description, version } = info;\n", "    return {\n\t      info: {\n\t        title: title,\n\t        description: description,\n\t        version: version,\n\t        baseURL,\n\t      },\n\t      components,\n\t      paths,\n\t    };\n", "  }\n\t}\n"]}
{"filename": "src/types/process.env.d.ts", "chunked_list": ["// @ref https://bobbyhadz.com/blog/typescript-process-env-type\n\tdeclare global {\n\t  namespace NodeJS {\n\t    interface ProcessEnv {\n\t      // package name\n\t      PKG_NAME: string;\n\t      // package version\n\t      PKG_VERSION: string;\n\t    }\n\t  }\n", "}\n\texport {};\n"]}
{"filename": "src/types/openapi.ts", "chunked_list": ["import { OpenAPIV3 } from 'openapi-types';\n\texport { OpenAPIV3 };\n\texport type OpenAPIV3Document = OpenAPIV3.Document;\n"]}
