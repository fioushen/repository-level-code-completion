{"filename": "vitest.config.ts", "chunked_list": ["/// <reference types=\"vitest\" />\n\timport { defineConfig } from \"vite\"\n\texport default defineConfig({\n\t  test: {\n\t    include: [\"./test/**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}\"],\n\t    exclude: [],\n\t    globals: true,\n\t    coverage: {\n\t      provider: \"v8\"\n\t    }\n", "  }\n\t})\n"]}
{"filename": "tsup.config.ts", "chunked_list": ["import { defineConfig } from \"tsup\"\n\texport default defineConfig({\n\t  entry: [\"src/bin.ts\"],\n\t  clean: true,\n\t  publicDir: true,\n\t  noExternal: [/(effect|@effect|chalk)/]\n\t})\n"]}
{"filename": "test/Markdown.ts", "chunked_list": ["import * as assert from \"assert\"\n\timport { Option } from \"effect\"\n\timport { flow } from \"effect/Function\"\n\timport {\n\t  createClass,\n\t  createConstant,\n\t  createDocumentable,\n\t  createExport,\n\t  createFunction,\n\t  createInterface,\n", "  createMethod,\n\t  createModule,\n\t  createProperty,\n\t  createTypeAlias\n\t} from \"../src/Domain\"\n\timport * as _ from \"../src/Markdown\"\n\tconst testCases = {\n\t  class: createClass(\n\t    createDocumentable(\n\t      \"A\",\n", "      Option.some(\"a class\"),\n\t      Option.some(\"1.0.0\"),\n\t      false,\n\t      [\"example 1\"],\n\t      Option.some(\"category\")\n\t    ),\n\t    \"declare class A { constructor() }\",\n\t    [\n\t      createMethod(\n\t        createDocumentable(\n", "          \"hasOwnProperty\",\n\t          Option.none(),\n\t          Option.some(\"1.0.0\"),\n\t          false,\n\t          [],\n\t          Option.none()\n\t        ),\n\t        [\"hasOwnProperty(): boolean\"]\n\t      )\n\t    ],\n", "    [\n\t      createMethod(\n\t        createDocumentable(\n\t          \"staticTest\",\n\t          Option.none(),\n\t          Option.some(\"1.0.0\"),\n\t          false,\n\t          [],\n\t          Option.none()\n\t        ),\n", "        [\"static testStatic(): string;\"]\n\t      )\n\t    ],\n\t    [\n\t      createProperty(\n\t        createDocumentable(\n\t          \"foo\",\n\t          Option.none(),\n\t          Option.some(\"1.0.0\"),\n\t          false,\n", "          [],\n\t          Option.none()\n\t        ),\n\t        \"foo: string\"\n\t      )\n\t    ]\n\t  ),\n\t  constant: createConstant(\n\t    createDocumentable(\n\t      \"test\",\n", "      Option.some(\"the test\"),\n\t      Option.some(\"1.0.0\"),\n\t      false,\n\t      [],\n\t      Option.some(\"constants\")\n\t    ),\n\t    \"declare const test: string\"\n\t  ),\n\t  export: createExport(\n\t    createDocumentable(\n", "      \"test\",\n\t      Option.none(),\n\t      Option.some(\"1.0.0\"),\n\t      false,\n\t      [],\n\t      Option.none()\n\t    ),\n\t    \"export declare const test: typeof test\"\n\t  ),\n\t  function: createFunction(\n", "    createDocumentable(\n\t      \"func\",\n\t      Option.some(\"a function\"),\n\t      Option.some(\"1.0.0\"),\n\t      true,\n\t      [\"example 1\"],\n\t      Option.none()\n\t    ),\n\t    [\"declare const func: (test: string) => string\"]\n\t  ),\n", "  interface: createInterface(\n\t    createDocumentable(\n\t      \"A\",\n\t      Option.none(),\n\t      Option.some(\"1.0.0\"),\n\t      false,\n\t      [],\n\t      Option.none()\n\t    ),\n\t    \"export interface A extends Record<string, unknown> {}\"\n", "  ),\n\t  typeAlias: createTypeAlias(\n\t    createDocumentable(\n\t      \"A\",\n\t      Option.none(),\n\t      Option.some(\"1.0.0\"),\n\t      false,\n\t      [],\n\t      Option.none()\n\t    ),\n", "    \"export type A = number\"\n\t  )\n\t}\n\tdescribe.concurrent(\"Markdown\", () => {\n\t  const print = flow(_.fromPrintable, _.prettify)\n\t  it(\"fromClass\", () => {\n\t    assert.strictEqual(\n\t      print(testCases.class),\n\t      `## A (class)\n\ta class\n", "**Signature**\n\t\\`\\`\\`ts\n\tdeclare class A {\n\t  constructor()\n\t}\n\t\\`\\`\\`\n\t**Example**\n\t\\`\\`\\`ts\n\texample 1\n\t\\`\\`\\`\n", "Added in v1.0.0\n\t### staticTest (static method)\n\t**Signature**\n\t\\`\\`\\`ts\n\tstatic testStatic(): string;\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t### hasOwnProperty (function) (method)\n\t**Signature**\n\t\\`\\`\\`ts\n", "hasOwnProperty(): boolean\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t### foo (property)\n\t**Signature**\n\t\\`\\`\\`ts\n\tfoo: string\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t`\n", "    )\n\t  })\n\t  it(\"printConstant\", () => {\n\t    assert.strictEqual(\n\t      print(testCases.constant),\n\t      `## test\n\tthe test\n\t**Signature**\n\t\\`\\`\\`ts\n\tdeclare const test: string\n", "\\`\\`\\`\n\tAdded in v1.0.0\n\t`\n\t    )\n\t  })\n\t  it(\"printExport\", () => {\n\t    assert.strictEqual(\n\t      print(testCases.export),\n\t      `## test\n\t**Signature**\n", "\\`\\`\\`ts\n\texport declare const test: typeof test\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t`\n\t    )\n\t  })\n\t  it(\"printFunction\", () => {\n\t    assert.strictEqual(\n\t      print(testCases.function),\n", "      `## ~~func~~\n\ta function\n\t**Signature**\n\t\\`\\`\\`ts\n\tdeclare const func: (test: string) => string\n\t\\`\\`\\`\n\t**Example**\n\t\\`\\`\\`ts\n\texample 1\n\t\\`\\`\\`\n", "Added in v1.0.0\n\t`\n\t    )\n\t  })\n\t  it(\"printInterface\", () => {\n\t    assert.strictEqual(\n\t      print(testCases.interface),\n\t      `## A (interface)\n\t**Signature**\n\t\\`\\`\\`ts\n", "export interface A extends Record<string, unknown> {}\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t`\n\t    )\n\t  })\n\t  it(\"printTypeAlias\", () => {\n\t    assert.strictEqual(\n\t      print(testCases.typeAlias),\n\t      `## A (type alias)\n", "**Signature**\n\t\\`\\`\\`ts\n\texport type A = number\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t`\n\t    )\n\t    assert.strictEqual(\n\t      print({ ...testCases.typeAlias, since: Option.none() }),\n\t      `## A (type alias)\n", "**Signature**\n\t\\`\\`\\`ts\n\texport type A = number\n\t\\`\\`\\`\n\t`\n\t    )\n\t  })\n\t  it(\"printModule\", () => {\n\t    const documentation = createDocumentable(\n\t      \"tests\",\n", "      Option.none(),\n\t      Option.some(\"1.0.0\"),\n\t      false,\n\t      [],\n\t      Option.none()\n\t    )\n\t    assert.strictEqual(\n\t      _.printModule(\n\t        createModule(\n\t          documentation,\n", "          [\"src\", \"tests.ts\"],\n\t          [testCases.class],\n\t          [testCases.interface],\n\t          [testCases.function],\n\t          [testCases.typeAlias],\n\t          [testCases.constant],\n\t          [testCases.export]\n\t        ),\n\t        1\n\t      ),\n", "      `---\n\ttitle: tests.ts\n\tnav_order: 1\n\tparent: Modules\n\t---\n\t## tests overview\n\tAdded in v1.0.0\n\t---\n\t<h2 class=\"text-delta\">Table of contents</h2>\n\t- [category](#category)\n", "  - [A (class)](#a-class)\n\t    - [staticTest (static method)](#statictest-static-method)\n\t    - [hasOwnProperty (function) (method)](#hasownproperty-function-method)\n\t    - [foo (property)](#foo-property)\n\t- [constants](#constants)\n\t  - [test](#test)\n\t- [utils](#utils)\n\t  - [A (interface)](#a-interface)\n\t  - [A (type alias)](#a-type-alias)\n\t  - [~~func~~](#func)\n", "  - [test](#test-1)\n\t---\n\t# category\n\t## A (class)\n\ta class\n\t**Signature**\n\t\\`\\`\\`ts\n\tdeclare class A {\n\t  constructor()\n\t}\n", "\\`\\`\\`\n\t**Example**\n\t\\`\\`\\`ts\n\texample 1\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t### staticTest (static method)\n\t**Signature**\n\t\\`\\`\\`ts\n\tstatic testStatic(): string;\n", "\\`\\`\\`\n\tAdded in v1.0.0\n\t### hasOwnProperty (function) (method)\n\t**Signature**\n\t\\`\\`\\`ts\n\thasOwnProperty(): boolean\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t### foo (property)\n\t**Signature**\n", "\\`\\`\\`ts\n\tfoo: string\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t# constants\n\t## test\n\tthe test\n\t**Signature**\n\t\\`\\`\\`ts\n\tdeclare const test: string\n", "\\`\\`\\`\n\tAdded in v1.0.0\n\t# utils\n\t## A (interface)\n\t**Signature**\n\t\\`\\`\\`ts\n\texport interface A extends Record<string, unknown> {}\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t## A (type alias)\n", "**Signature**\n\t\\`\\`\\`ts\n\texport type A = number\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t## ~~func~~\n\ta function\n\t**Signature**\n\t\\`\\`\\`ts\n\tdeclare const func: (test: string) => string\n", "\\`\\`\\`\n\t**Example**\n\t\\`\\`\\`ts\n\texample 1\n\t\\`\\`\\`\n\tAdded in v1.0.0\n\t## test\n\t**Signature**\n\t\\`\\`\\`ts\n\texport declare const test: typeof test\n", "\\`\\`\\`\n\tAdded in v1.0.0\n\t`\n\t    )\n\t    const empty = createModule(\n\t      documentation,\n\t      [\"src\", \"tests.ts\"],\n\t      [],\n\t      [],\n\t      [],\n", "      [],\n\t      [],\n\t      []\n\t    )\n\t    assert.strictEqual(\n\t      _.printModule(empty, 1),\n\t      `---\n\ttitle: tests.ts\n\tnav_order: 1\n\tparent: Modules\n", "---\n\t## tests overview\n\tAdded in v1.0.0\n\t---\n\t<h2 class=\"text-delta\">Table of contents</h2>\n\t---\n\t`\n\t    )\n\t  })\n\t})\n"]}
{"filename": "test/Domain.ts", "chunked_list": ["import * as assert from \"assert\"\n\timport { Option, ReadonlyArray } from \"effect\"\n\timport * as Domain from \"../src/Domain\"\n\tconst documentable = (name: string) =>\n\t  Domain.createDocumentable(\n\t    name,\n\t    Option.none(),\n\t    Option.some(\"1.0.0\"),\n\t    false,\n\t    [],\n", "    Option.none()\n\t  )\n\tdescribe.concurrent(\"Domain\", () => {\n\t  describe.concurrent(\"constructors\", () => {\n\t    it(\"Documentable\", () => {\n\t      assert.deepStrictEqual(documentable(\"A\"), {\n\t        name: \"A\",\n\t        description: Option.none(),\n\t        since: Option.some(\"1.0.0\"),\n\t        deprecated: false,\n", "        examples: [],\n\t        category: Option.none()\n\t      })\n\t    })\n\t    it(\"Module\", () => {\n\t      const m = Domain.createModule(\n\t        documentable(\"test\"),\n\t        [\"src\", \"index.ts\"],\n\t        [],\n\t        [],\n", "        [],\n\t        [],\n\t        [],\n\t        []\n\t      )\n\t      assert.deepStrictEqual(m, {\n\t        ...documentable(\"test\"),\n\t        path: [\"src\", \"index.ts\"],\n\t        classes: [],\n\t        interfaces: [],\n", "        functions: [],\n\t        typeAliases: [],\n\t        constants: [],\n\t        exports: []\n\t      })\n\t    })\n\t    it(\"Class\", () => {\n\t      const c = Domain.createClass(\n\t        documentable(\"A\"),\n\t        \"declare class A { constructor() }\",\n", "        [],\n\t        [],\n\t        []\n\t      )\n\t      assert.deepStrictEqual(c, {\n\t        _tag: \"Class\",\n\t        ...documentable(\"A\"),\n\t        signature: \"declare class A { constructor() }\",\n\t        methods: [],\n\t        staticMethods: [],\n", "        properties: []\n\t      })\n\t    })\n\t    it(\"Constant\", () => {\n\t      const c = Domain.createConstant(\n\t        documentable(\"foo\"),\n\t        \"declare const foo: string\"\n\t      )\n\t      assert.deepStrictEqual(c, {\n\t        _tag: \"Constant\",\n", "        ...documentable(\"foo\"),\n\t        signature: \"declare const foo: string\"\n\t      })\n\t    })\n\t    it(\"Method\", () => {\n\t      const m = Domain.createMethod(documentable(\"foo\"), [\"foo(): string\"])\n\t      assert.deepStrictEqual(m, {\n\t        ...documentable(\"foo\"),\n\t        signatures: [\"foo(): string\"]\n\t      })\n", "    })\n\t    it(\"Property\", () => {\n\t      const p = Domain.createProperty(documentable(\"foo\"), \"foo: string\")\n\t      assert.deepStrictEqual(p, {\n\t        ...documentable(\"foo\"),\n\t        signature: \"foo: string\"\n\t      })\n\t    })\n\t    it(\"Interface\", () => {\n\t      const i = Domain.createInterface(documentable(\"A\"), \"interface A {}\")\n", "      assert.deepStrictEqual(i, {\n\t        _tag: \"Interface\",\n\t        ...documentable(\"A\"),\n\t        signature: \"interface A {}\"\n\t      })\n\t    })\n\t    it(\"Function\", () => {\n\t      const f = Domain.createFunction(documentable(\"func\"), [\n\t        \"declare function func(): string\"\n\t      ])\n", "      assert.deepStrictEqual(f, {\n\t        _tag: \"Function\",\n\t        ...documentable(\"func\"),\n\t        signatures: [\"declare function func(): string\"]\n\t      })\n\t    })\n\t    it(\"TypeAlias\", () => {\n\t      const ta = Domain.createTypeAlias(documentable(\"A\"), \"type A = string\")\n\t      assert.deepStrictEqual(ta, {\n\t        _tag: \"TypeAlias\",\n", "        ...documentable(\"A\"),\n\t        signature: \"type A = string\"\n\t      })\n\t    })\n\t    it(\"Export\", () => {\n\t      const e = Domain.createExport(\n\t        documentable(\"foo\"),\n\t        \"export declare const foo: string\"\n\t      )\n\t      assert.deepStrictEqual(e, {\n", "        _tag: \"Export\",\n\t        ...documentable(\"foo\"),\n\t        signature: \"export declare const foo: string\"\n\t      })\n\t    })\n\t  })\n\t  describe.concurrent(\"instances\", () => {\n\t    it(\"ordModule\", () => {\n\t      const m1 = Domain.createModule(\n\t        documentable(\"test1\"),\n", "        [\"src\", \"test1.ts\"],\n\t        [],\n\t        [],\n\t        [],\n\t        [],\n\t        [],\n\t        []\n\t      )\n\t      const m2 = Domain.createModule(\n\t        documentable(\"test1\"),\n", "        [\"src\", \"test1.ts\"],\n\t        [],\n\t        [],\n\t        [],\n\t        [],\n\t        [],\n\t        []\n\t      )\n\t      const sorted = ReadonlyArray.sort([m2, m1], Domain.Order)\n\t      assert.deepStrictEqual(sorted, [m1, m2])\n", "    })\n\t  })\n\t})\n"]}
{"filename": "test/FileSystem.ts", "chunked_list": ["import * as assert from \"assert\"\n\timport { Effect, Exit } from \"effect\"\n\timport * as FileSystem from \"../src/FileSystem\"\n\tdescribe.concurrent(\"FileSystem\", () => {\n\t  describe.concurrent(\"readFile\", () => {\n\t    it(\"should error out on non existing files\", async () => {\n\t      const program = Effect.flatMap(\n\t        FileSystem.FileSystem,\n\t        (fileSystem) => fileSystem.readFile(\"non-existent.txt\")\n\t      ).pipe(\n", "        Effect.mapError(({ error }) => error.message),\n\t        Effect.provideLayer(FileSystem.FileSystemLive)\n\t      )\n\t      assert.deepStrictEqual(\n\t        Exit.unannotate(await Effect.runPromiseExit(program)),\n\t        Exit.fail(\"ENOENT: no such file or directory, open 'non-existent.txt'\")\n\t      )\n\t    })\n\t  })\n\t})\n"]}
{"filename": "test/Parser.ts", "chunked_list": ["import * as assert from \"assert\"\n\timport chalk from \"chalk\"\n\timport { Effect, Exit, Option, String } from \"effect\"\n\timport * as ast from \"ts-morph\"\n\timport * as Config from \"../src/Config\"\n\timport * as FileSystem from \"../src/FileSystem\"\n\timport * as Parser from \"../src/Parser\"\n\tlet testCounter = 0\n\tconst project = new ast.Project({\n\t  compilerOptions: { strict: true },\n", "  useInMemoryFileSystem: true\n\t})\n\tconst defaultConfig: Config.Config = {\n\t  projectName: \"docgen\",\n\t  projectHomepage: \"https://github.com/effect-ts/docgen\",\n\t  srcDir: \"src\",\n\t  outDir: \"docs\",\n\t  theme: \"pmarsceill/just-the-docs\",\n\t  enableSearch: true,\n\t  enforceDescriptions: false,\n", "  enforceExamples: false,\n\t  enforceVersion: true,\n\t  exclude: [],\n\t  parseCompilerOptions: {},\n\t  examplesCompilerOptions: {}\n\t}\n\tconst getParser = (sourceText: string): Parser.Source => ({\n\t  path: [\"test\"],\n\t  sourceFile: project.createSourceFile(`test-${testCounter++}.ts`, sourceText)\n\t})\n", "const expectFailure = <E, A>(\n\t  sourceText: string,\n\t  eff: Effect.Effect<Parser.Source | Config.Config, E, A>,\n\t  failure: E,\n\t  config?: Partial<Config.Config>\n\t) => {\n\t  expect(\n\t    eff.pipe(\n\t      Effect.provideService(Parser.Source, getParser(sourceText)),\n\t      Effect.provideService(Config.Config, { ...defaultConfig, ...config }),\n", "      Effect.runSyncExit,\n\t      Exit.unannotate\n\t    )\n\t  ).toEqual(Exit.fail(failure))\n\t}\n\tconst expectSuccess = <E, A>(\n\t  sourceText: string,\n\t  eff: Effect.Effect<Parser.Source | Config.Config, E, A>,\n\t  a: A,\n\t  config?: Partial<Config.Config>\n", ") => {\n\t  expect(\n\t    eff\n\t      .pipe(\n\t        Effect.provideService(Parser.Source, getParser(sourceText)),\n\t        Effect.provideService(Config.Config, { ...defaultConfig, ...config }),\n\t        Effect.runSyncExit\n\t      )\n\t  ).toEqual(Exit.succeed(a))\n\t}\n", "describe.concurrent(\"Parser\", () => {\n\t  describe.concurrent(\"parsers\", () => {\n\t    describe.concurrent(\"parseInterfaces\", () => {\n\t      it(\"should return no `Interface`s if the file is empty\", () => {\n\t        expectSuccess(\"\", Parser.parseInterfaces, [])\n\t      })\n\t      it(\"should return no `Interface`s if there are no exported interfaces\", () => {\n\t        expectSuccess(\"interface A {}\", Parser.parseInterfaces, [])\n\t      })\n\t      it(\"should return an `Interface`\", () => {\n", "        expectSuccess(\n\t          `/**\n\t        * a description...\n\t        * @since 1.0.0\n\t        * @deprecated\n\t        */\n\t        export interface A {}`,\n\t          Parser.parseInterfaces,\n\t          [\n\t            {\n", "              _tag: \"Interface\",\n\t              deprecated: true,\n\t              description: Option.some(\"a description...\"),\n\t              name: \"A\",\n\t              signature: \"export interface A {}\",\n\t              since: Option.some(\"1.0.0\"),\n\t              examples: [],\n\t              category: Option.none()\n\t            }\n\t          ]\n", "        )\n\t      })\n\t      it(\"should return interfaces sorted by name\", () => {\n\t        expectSuccess(\n\t          `\n\t        /**\n\t         * @since 1.0.0\n\t         */\n\t        export interface B {}\n\t        /**\n", "         * @since 1.0.0\n\t         */\n\t        export interface A {}\n\t        `,\n\t          Parser.parseInterfaces,\n\t          [\n\t            {\n\t              _tag: \"Interface\",\n\t              name: \"A\",\n\t              description: Option.none(),\n", "              since: Option.some(\"1.0.0\"),\n\t              deprecated: false,\n\t              category: Option.none(),\n\t              examples: [],\n\t              signature: \"export interface A {}\"\n\t            },\n\t            {\n\t              _tag: \"Interface\",\n\t              name: \"B\",\n\t              description: Option.none(),\n", "              since: Option.some(\"1.0.0\"),\n\t              deprecated: false,\n\t              category: Option.none(),\n\t              examples: [],\n\t              signature: \"export interface B {}\"\n\t            }\n\t          ]\n\t        )\n\t      })\n\t    })\n", "    describe.concurrent(\"parseFunctions\", () => {\n\t      it(\"should raise an error if the function is anonymous\", () => {\n\t        expectFailure(\n\t          `export function(a: number, b: number): number { return a + b }`,\n\t          Parser.parseFunctions,\n\t          [\"Missing function name in module test\"]\n\t        )\n\t      })\n\t      it(\"should not return private function declarations\", () => {\n\t        expectSuccess(\n", "          `function sum(a: number, b: number): number { return a + b }`,\n\t          Parser.parseFunctions,\n\t          []\n\t        )\n\t      })\n\t      it(\"should not return ignored function declarations\", () => {\n\t        expectSuccess(\n\t          `/**\n\t        * @ignore\n\t        */\n", "        export function sum(a: number, b: number): number { return a + b }`,\n\t          Parser.parseFunctions,\n\t          []\n\t        )\n\t      })\n\t      it(\"should not return ignored function declarations with overloads\", () => {\n\t        expectSuccess(\n\t          `/**\n\t            * @ignore\n\t            */\n", "            export function sum(a: number, b: number)\n\t            export function sum(a: number, b: number): number { return a + b }`,\n\t          Parser.parseFunctions,\n\t          []\n\t        )\n\t      })\n\t      it(\"should not return internal function declarations\", () => {\n\t        expectSuccess(\n\t          `/**\n\t            * @internal\n", "            */\n\t            export function sum(a: number, b: number): number { return a + b }`,\n\t          Parser.parseFunctions,\n\t          []\n\t        )\n\t      })\n\t      it(\"should not return internal function declarations even with overloads\", () => {\n\t        expectSuccess(\n\t          `/**\n\t            * @internal\n", "            */\n\t            export function sum(a: number, b: number)\n\t            export function sum(a: number, b: number): number { return a + b }`,\n\t          Parser.parseFunctions,\n\t          []\n\t        )\n\t      })\n\t      it(\"should not return private const function declarations\", () => {\n\t        expectSuccess(\n\t          `const sum = (a: number, b: number): number => a + b `,\n", "          Parser.parseFunctions,\n\t          []\n\t        )\n\t      })\n\t      it(\"should not return internal const function declarations\", () => {\n\t        expectSuccess(\n\t          `/**\n\t            * @internal\n\t            */\n\t            export const sum = (a: number, b: number): number => a + b `,\n", "          Parser.parseFunctions,\n\t          []\n\t        )\n\t      })\n\t      it(\"should account for nullable polymorphic return types\", () => {\n\t        expectSuccess(\n\t          `/**\n\t            * @since 1.0.0\n\t            */\n\t           export const toNullable = <A>(ma: A | null): A | null => ma`,\n", "          Parser.parseFunctions,\n\t          [\n\t            {\n\t              _tag: \"Function\",\n\t              deprecated: false,\n\t              description: Option.none(),\n\t              name: \"toNullable\",\n\t              signatures: [\n\t                \"export declare const toNullable: <A>(ma: A | null) => A | null\"\n\t              ],\n", "              since: Option.some(\"1.0.0\"),\n\t              examples: [],\n\t              category: Option.none()\n\t            }\n\t          ]\n\t        )\n\t      })\n\t      it(\"should return a const function declaration\", () => {\n\t        expectSuccess(\n\t          `/**\n", "            * a description...\n\t            * @since 1.0.0\n\t            * @example\n\t            * assert.deepStrictEqual(f(1, 2), { a: 1, b: 2 })\n\t            * @example\n\t            * assert.deepStrictEqual(f(3, 4), { a: 3, b: 4 })\n\t            * @deprecated\n\t            */\n\t            export const f = (a: number, b: number): { [key: string]: number } => ({ a, b })`,\n\t          Parser.parseFunctions,\n", "          [\n\t            {\n\t              _tag: \"Function\",\n\t              deprecated: true,\n\t              description: Option.some(\"a description...\"),\n\t              name: \"f\",\n\t              signatures: [\n\t                \"export declare const f: (a: number, b: number) => { [key: string]: number; }\"\n\t              ],\n\t              since: Option.some(\"1.0.0\"),\n", "              examples: [\n\t                \"assert.deepStrictEqual(f(1, 2), { a: 1, b: 2 })\",\n\t                \"assert.deepStrictEqual(f(3, 4), { a: 3, b: 4 })\"\n\t              ],\n\t              category: Option.none()\n\t            }\n\t          ]\n\t        )\n\t      })\n\t      it(\"should return a function declaration\", () => {\n", "        expectSuccess(\n\t          `/**\n\t            * @since 1.0.0\n\t            */\n\t            export function f(a: number, b: number): { [key: string]: number } { return { a, b } }`,\n\t          Parser.parseFunctions,\n\t          [\n\t            {\n\t              _tag: \"Function\",\n\t              deprecated: false,\n", "              description: Option.none(),\n\t              name: \"f\",\n\t              signatures: [\n\t                \"export declare function f(a: number, b: number): { [key: string]: number }\"\n\t              ],\n\t              since: Option.some(\"1.0.0\"),\n\t              examples: [],\n\t              category: Option.none()\n\t            }\n\t          ]\n", "        )\n\t      })\n\t      it(\"should return a function with comments\", () => {\n\t        expectSuccess(\n\t          `/**\n\t            * a description...\n\t            * @since 1.0.0\n\t            * @deprecated\n\t            */\n\t            export function f(a: number, b: number): { [key: string]: number } { return { a, b } }`,\n", "          Parser.parseFunctions,\n\t          [\n\t            {\n\t              _tag: \"Function\",\n\t              deprecated: true,\n\t              description: Option.some(\"a description...\"),\n\t              name: \"f\",\n\t              signatures: [\n\t                \"export declare function f(a: number, b: number): { [key: string]: number }\"\n\t              ],\n", "              since: Option.some(\"1.0.0\"),\n\t              examples: [],\n\t              category: Option.none()\n\t            }\n\t          ]\n\t        )\n\t      })\n\t      it(\"should handle overloadings\", () => {\n\t        expectSuccess(\n\t          `/**\n", "            * a description...\n\t            * @since 1.0.0\n\t            * @deprecated\n\t            */\n\t            export function f(a: Int, b: Int): { [key: string]: number }\n\t            export function f(a: number, b: number): { [key: string]: number }\n\t            export function f(a: any, b: any): { [key: string]: number } { return { a, b } }`,\n\t          Parser.parseFunctions,\n\t          [\n\t            {\n", "              _tag: \"Function\",\n\t              name: \"f\",\n\t              description: Option.some(\"a description...\"),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: true,\n\t              category: Option.none(),\n\t              examples: [],\n\t              signatures: [\n\t                \"export declare function f(a: Int, b: Int): { [key: string]: number }\",\n\t                \"export declare function f(a: number, b: number): { [key: string]: number }\"\n", "              ]\n\t            }\n\t          ]\n\t        )\n\t      })\n\t    })\n\t    describe.concurrent(\"parseTypeAlias\", () => {\n\t      it(\"should return a `TypeAlias`\", () => {\n\t        expectSuccess(\n\t          `/**\n", "            * a description...\n\t            * @since 1.0.0\n\t            * @deprecated\n\t            */\n\t            export type Option<A> = None<A> | Some<A>`,\n\t          Parser.parseTypeAliases,\n\t          [\n\t            {\n\t              _tag: \"TypeAlias\",\n\t              name: \"Option\",\n", "              description: Option.some(\"a description...\"),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: true,\n\t              category: Option.none(),\n\t              signature: \"export type Option<A> = None<A> | Some<A>\",\n\t              examples: []\n\t            }\n\t          ]\n\t        )\n\t      })\n", "    })\n\t    describe.concurrent(\"parseConstants\", () => {\n\t      it(\"should handle a constant value\", () => {\n\t        expectSuccess(\n\t          `/**\n\t            * a description...\n\t            * @since 1.0.0\n\t            * @deprecated\n\t            */\n\t            export const s: string = ''`,\n", "          Parser.parseConstants,\n\t          [\n\t            {\n\t              _tag: \"Constant\",\n\t              name: \"s\",\n\t              description: Option.some(\"a description...\"),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: true,\n\t              category: Option.none(),\n\t              signature: \"export declare const s: string\",\n", "              examples: []\n\t            }\n\t          ]\n\t        )\n\t      })\n\t      it(\"should support constants with default type parameters\", () => {\n\t        expectSuccess(\n\t          `/**\n\t            * @since 1.0.0\n\t            */\n", "            export const left: <E = never, A = never>(l: E) => string = T.left`,\n\t          Parser.parseConstants,\n\t          [\n\t            {\n\t              _tag: \"Constant\",\n\t              name: \"left\",\n\t              description: Option.none(),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: false,\n\t              category: Option.none(),\n", "              signature: \"export declare const left: <E = never, A = never>(l: E) => string\",\n\t              examples: []\n\t            }\n\t          ]\n\t        )\n\t      })\n\t      it(\"should support untyped constants\", () => {\n\t        expectSuccess(\n\t          `\n\t        class A {}\n", "      /**\n\t        * @since 1.0.0\n\t        */\n\t        export const empty = new A()`,\n\t          Parser.parseConstants,\n\t          [\n\t            {\n\t              _tag: \"Constant\",\n\t              name: \"empty\",\n\t              description: Option.none(),\n", "              since: Option.some(\"1.0.0\"),\n\t              deprecated: false,\n\t              category: Option.none(),\n\t              signature: \"export declare const empty: A\",\n\t              examples: []\n\t            }\n\t          ]\n\t        )\n\t      })\n\t      it(\"should handle constants with typeof annotations\", () => {\n", "        expectSuccess(\n\t          ` const task: { a: number } = {\n\t          a: 1\n\t        }\n\t        /**\n\t        * @since 1.0.0\n\t        */\n\t        export const taskSeq: typeof task = {\n\t          ...task,\n\t          ap: (mab, ma) => () => mab().then(f => ma().then(a => f(a)))\n", "        }`,\n\t          Parser.parseConstants,\n\t          [\n\t            {\n\t              _tag: \"Constant\",\n\t              deprecated: false,\n\t              description: Option.none(),\n\t              name: \"taskSeq\",\n\t              signature: \"export declare const taskSeq: { a: number; }\",\n\t              since: Option.some(\"1.0.0\"),\n", "              examples: [],\n\t              category: Option.none()\n\t            }\n\t          ]\n\t        )\n\t      })\n\t      it(\"should not include variables declared in for loops\", () => {\n\t        expectSuccess(\n\t          ` const object = { a: 1, b: 2, c: 3 };\n\t        for (const property in object) {\n", "          console.log(property);\n\t        }`,\n\t          Parser.parseConstants,\n\t          []\n\t        )\n\t      })\n\t    })\n\t    describe.concurrent(\"parseClasses\", () => {\n\t      it(\"should raise an error if the class is anonymous\", () => {\n\t        expectFailure(`export class {}`, Parser.parseClasses, [\n", "          \"Missing class name in module test\"\n\t        ])\n\t      })\n\t      it(\"should raise an error if an `@since` tag is missing in a module\", () => {\n\t        expectFailure(`export class MyClass {}`, Parser.parseClasses, [\n\t          `Missing ${chalk.bold(\"@since\")} tag in ${chalk.bold(\"test#MyClass\")} documentation`\n\t        ])\n\t      })\n\t      it(\"should ignore internal classes\", () => {\n\t        expectSuccess(`/** @internal */export class MyClass {}`, Parser.parseClasses, [])\n", "      })\n\t      it(\"should ignore `@ignore`d classes\", () => {\n\t        expectSuccess(`/** @ignore */export class MyClass {}`, Parser.parseClasses, [])\n\t      })\n\t      it(\"should raise an error if `@since` is missing in a property\", () => {\n\t        expectFailure(\n\t          `/**\n\t            * @since 1.0.0\n\t            */\n\t            export class MyClass<A> {\n", "              readonly _A!: A\n\t            }`,\n\t          Parser.parseClasses,\n\t          [`Missing ${chalk.bold(\"@since\")} tag in ${chalk.bold(\"test#MyClass#_A\")} documentation`]\n\t        )\n\t      })\n\t      it(\"should skip ignored properties\", () => {\n\t        expectSuccess(\n\t          `/**\n\t        * @since 1.0.0\n", "        */\n\t        export class MyClass<A> {\n\t          /**\n\t           * @ignore\n\t           */\n\t          readonly _A!: A\n\t        }`,\n\t          Parser.parseClasses,\n\t          [\n\t            {\n", "              _tag: \"Class\",\n\t              name: \"MyClass\",\n\t              description: Option.none(),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: false,\n\t              category: Option.none(),\n\t              examples: [],\n\t              signature: \"export declare class MyClass<A>\",\n\t              methods: [],\n\t              staticMethods: [],\n", "              properties: []\n\t            }\n\t          ]\n\t        )\n\t      })\n\t      it(\"should skip the constructor body\", () => {\n\t        expectSuccess(\n\t          `/**\n\t        * description\n\t        * @since 1.0.0\n", "        */\n\t        export class C { constructor() {} }`,\n\t          Parser.parseClasses,\n\t          [\n\t            {\n\t              _tag: \"Class\",\n\t              name: \"C\",\n\t              description: Option.some(\"description\"),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: false,\n", "              category: Option.none(),\n\t              examples: [],\n\t              signature: \"export declare class C { constructor() }\",\n\t              methods: [],\n\t              staticMethods: [],\n\t              properties: []\n\t            }\n\t          ]\n\t        )\n\t      })\n", "      it(\"should get a constructor declaration signature\", () => {\n\t        const sourceFile = project.createSourceFile(\n\t          `test-${testCounter++}.ts`,\n\t          `\n\t        /**\n\t         * @since 1.0.0\n\t         */\n\t        declare class A {\n\t          constructor()\n\t        }\n", "      `\n\t        )\n\t        const constructorDeclaration = sourceFile\n\t          .getClass(\"A\")!\n\t          .getConstructors()[0]\n\t        assert.deepStrictEqual(\n\t          Parser.getConstructorDeclarationSignature(constructorDeclaration),\n\t          \"constructor()\"\n\t        )\n\t      })\n", "      it(\"should handle non-readonly properties\", () => {\n\t        expectSuccess(\n\t          `/**\n\t        * description\n\t        * @since 1.0.0\n\t        */\n\t        export class C {\n\t          /**\n\t           * @since 1.0.0\n\t           */\n", "          a: string\n\t        }`,\n\t          Parser.parseClasses,\n\t          [\n\t            {\n\t              _tag: \"Class\",\n\t              name: \"C\",\n\t              description: Option.some(\"description\"),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: false,\n", "              category: Option.none(),\n\t              examples: [],\n\t              signature: \"export declare class C\",\n\t              methods: [],\n\t              staticMethods: [],\n\t              properties: [\n\t                {\n\t                  name: \"a\",\n\t                  description: Option.none(),\n\t                  since: Option.some(\"1.0.0\"),\n", "                  deprecated: false,\n\t                  category: Option.none(),\n\t                  examples: [],\n\t                  signature: \"a: string\"\n\t                }\n\t              ]\n\t            }\n\t          ]\n\t        )\n\t      })\n", "      it(\"should return a `Class`\", () => {\n\t        expectSuccess(\n\t          `/**\n\t        * a class description...\n\t        * @since 1.0.0\n\t        * @deprecated\n\t        */\n\t        export class Test {\n\t          /**\n\t           * a property...\n", "           * @since 1.1.0\n\t           * @deprecated\n\t           */\n\t          readonly a: string\n\t          private readonly b: number\n\t          /**\n\t           * a static method description...\n\t           * @since 1.1.0\n\t           * @deprecated\n\t           */\n", "          static f(): void {}\n\t          constructor(readonly value: string) { }\n\t          /**\n\t           * a method description...\n\t           * @since 1.1.0\n\t           * @deprecated\n\t           */\n\t          g(a: number, b: number): { [key: string]: number } {\n\t            return { a, b }\n\t          }\n", "        }`,\n\t          Parser.parseClasses,\n\t          [\n\t            {\n\t              _tag: \"Class\",\n\t              name: \"Test\",\n\t              description: Option.some(\"a class description...\"),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: true,\n\t              category: Option.none(),\n", "              examples: [],\n\t              signature: \"export declare class Test { constructor(readonly value: string) }\",\n\t              methods: [\n\t                {\n\t                  name: \"g\",\n\t                  description: Option.some(\"a method description...\"),\n\t                  since: Option.some(\"1.1.0\"),\n\t                  deprecated: true,\n\t                  category: Option.none(),\n\t                  examples: [],\n", "                  signatures: [\n\t                    \"g(a: number, b: number): { [key: string]: number }\"\n\t                  ]\n\t                }\n\t              ],\n\t              staticMethods: [\n\t                {\n\t                  name: \"f\",\n\t                  description: Option.some(\"a static method description...\"),\n\t                  since: Option.some(\"1.1.0\"),\n", "                  deprecated: true,\n\t                  category: Option.none(),\n\t                  examples: [],\n\t                  signatures: [\"static f(): void\"]\n\t                }\n\t              ],\n\t              properties: [\n\t                {\n\t                  name: \"a\",\n\t                  description: Option.some(\"a property...\"),\n", "                  since: Option.some(\"1.1.0\"),\n\t                  deprecated: true,\n\t                  category: Option.none(),\n\t                  signature: \"readonly a: string\",\n\t                  examples: []\n\t                }\n\t              ]\n\t            }\n\t          ]\n\t        )\n", "      })\n\t      it(\"should handle method overloadings\", () => {\n\t        expectSuccess(\n\t          `/**\n\t        * a class description...\n\t        * @since 1.0.0\n\t        * @deprecated\n\t        */\n\t        export class Test<A> {\n\t          /**\n", "           * a static method description...\n\t           * @since 1.1.0\n\t           * @deprecated\n\t           */\n\t          static f(x: number): number\n\t          static f(x: string): string\n\t          static f(x: any): any {}\n\t          constructor(readonly value: A) { }\n\t          /**\n\t           * a method description...\n", "           * @since 1.1.0\n\t           * @deprecated\n\t           */\n\t          map(f: (a: number) => number): Test\n\t          map(f: (a: string) => string): Test\n\t          map(f: (a: any) => any): any {\n\t            return new Test(f(this.value))\n\t          }\n\t        }`,\n\t          Parser.parseClasses,\n", "          [\n\t            {\n\t              _tag: \"Class\",\n\t              name: \"Test\",\n\t              description: Option.some(\"a class description...\"),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: true,\n\t              category: Option.none(),\n\t              examples: [],\n\t              signature: \"export declare class Test<A> { constructor(readonly value: A) }\",\n", "              methods: [\n\t                {\n\t                  name: \"map\",\n\t                  description: Option.some(\"a method description...\"),\n\t                  since: Option.some(\"1.1.0\"),\n\t                  deprecated: true,\n\t                  category: Option.none(),\n\t                  examples: [],\n\t                  signatures: [\n\t                    \"map(f: (a: number) => number): Test\",\n", "                    \"map(f: (a: string) => string): Test\"\n\t                  ]\n\t                }\n\t              ],\n\t              staticMethods: [\n\t                {\n\t                  name: \"f\",\n\t                  description: Option.some(\"a static method description...\"),\n\t                  since: Option.some(\"1.1.0\"),\n\t                  deprecated: true,\n", "                  category: Option.none(),\n\t                  examples: [],\n\t                  signatures: [\n\t                    \"static f(x: number): number\",\n\t                    \"static f(x: string): string\"\n\t                  ]\n\t                }\n\t              ],\n\t              properties: []\n\t            }\n", "          ]\n\t        )\n\t      })\n\t      it(\"should ignore internal/ignored methods (#42)\", () => {\n\t        expectSuccess(\n\t          `/**\n\t        * a class description...\n\t        * @since 1.0.0\n\t        */\n\t        export class Test<A> {\n", "          /**\n\t           * @since 0.0.1\n\t           * @internal\n\t           **/\n\t          private foo(): void {}\n\t          /**\n\t           * @since 0.0.1\n\t           * @ignore\n\t           **/\n\t          private bar(): void {}\n", "        }`,\n\t          Parser.parseClasses,\n\t          [\n\t            {\n\t              _tag: \"Class\",\n\t              name: \"Test\",\n\t              description: Option.some(\"a class description...\"),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: false,\n\t              category: Option.none(),\n", "              examples: [],\n\t              signature: \"export declare class Test<A>\",\n\t              methods: [],\n\t              staticMethods: [],\n\t              properties: []\n\t            }\n\t          ]\n\t        )\n\t      })\n\t    })\n", "    describe.concurrent(\"parseModuleDocumentation\", () => {\n\t      it(\"should return a description field and a deprecated field\", () => {\n\t        expectSuccess(\n\t          `/**\n\t            * Manages the configuration settings for the widget\n\t            * @deprecated\n\t            * @since 1.0.0\n\t            */\n\t            /**\n\t             * @since 1.2.0\n", "             */\n\t            export const a: number = 1`,\n\t          Parser.parseModuleDocumentation,\n\t          {\n\t            name: \"test\",\n\t            description: Option.some(\n\t              \"Manages the configuration settings for the widget\"\n\t            ),\n\t            since: Option.some(\"1.0.0\"),\n\t            deprecated: true,\n", "            category: Option.none(),\n\t            examples: []\n\t          }\n\t        )\n\t      })\n\t      it(\"should return an error when documentation is enforced but no documentation is provided\", () => {\n\t        expectFailure(\n\t          \"export const a: number = 1\",\n\t          Parser.parseModuleDocumentation,\n\t          \"Missing documentation in test module\"\n", "        )\n\t      })\n\t      it(\"should support absence of module documentation when no documentation is enforced\", () => {\n\t        expectSuccess(\n\t          \"export const a: number = 1\",\n\t          Parser.parseModuleDocumentation,\n\t          {\n\t            name: \"test\",\n\t            description: Option.none(),\n\t            since: Option.none(),\n", "            deprecated: false,\n\t            category: Option.none(),\n\t            examples: []\n\t          },\n\t          { enforceVersion: false }\n\t        )\n\t      })\n\t    })\n\t    describe.concurrent(\"parseExports\", () => {\n\t      it(\"should return no `Export`s if the file is empty\", () => {\n", "        expectSuccess(\"\", Parser.parseExports, [])\n\t      })\n\t      it(\"should handle renamimg\", () => {\n\t        expectSuccess(\n\t          `const a = 1;\n\t          export {\n\t            /**\n\t             * @since 1.0.0\n\t             */\n\t            a as b\n", "          }`,\n\t          Parser.parseExports,\n\t          [\n\t            {\n\t              _tag: \"Export\",\n\t              name: \"b\",\n\t              description: Option.none(),\n\t              deprecated: false,\n\t              since: Option.some(\"1.0.0\"),\n\t              category: Option.none(),\n", "              examples: [],\n\t              signature: \"export declare const b: 1\"\n\t            }\n\t          ]\n\t        )\n\t      })\n\t      it(\"should return an `Export`\", () => {\n\t        expectSuccess(\n\t          `export {\n\t            /**\n", "             * description_of_a\n\t             * @since 1.0.0\n\t             */\n\t            a,\n\t            /**\n\t             * description_of_b\n\t             * @since 2.0.0\n\t             */\n\t            b\n\t          }`,\n", "          Parser.parseExports,\n\t          [\n\t            {\n\t              _tag: \"Export\",\n\t              name: \"a\",\n\t              description: Option.some(\"description_of_a\"),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: false,\n\t              category: Option.none(),\n\t              signature: \"export declare const a: any\",\n", "              examples: []\n\t            },\n\t            {\n\t              _tag: \"Export\",\n\t              name: \"b\",\n\t              description: Option.some(\"description_of_b\"),\n\t              since: Option.some(\"2.0.0\"),\n\t              deprecated: false,\n\t              category: Option.none(),\n\t              signature: \"export declare const b: any\",\n", "              examples: []\n\t            }\n\t          ]\n\t        )\n\t      })\n\t      it(\"should raise an error if `@since` tag is missing in export\", () => {\n\t        expectFailure(\"export { a }\", Parser.parseExports, [\n\t          \"Missing a documentation in test\"\n\t        ])\n\t      })\n", "      it(\"should retrieve an export signature\", () => {\n\t        project.createSourceFile(\"a.ts\", `export const a = 1`)\n\t        const sourceFile = project.createSourceFile(\n\t          \"b.ts\",\n\t          `import { a } from './a'\n\t          const b = a\n\t          export {\n\t            /**\n\t              * @since 1.0.0\n\t              */\n", "            b\n\t          }`\n\t        )\n\t        const actual = Parser.parseExports.pipe(\n\t          Effect.provideService(Parser.Source, {\n\t            path: [\"test\"],\n\t            sourceFile\n\t          }),\n\t          Effect.provideService(Config.Config, defaultConfig),\n\t          Effect.runSyncExit\n", "        )\n\t        expect(actual).toEqual(\n\t          Exit.succeed([\n\t            {\n\t              _tag: \"Export\",\n\t              name: \"b\",\n\t              description: Option.none(),\n\t              since: Option.some(\"1.0.0\"),\n\t              deprecated: false,\n\t              signature: \"export declare const b: 1\",\n", "              category: Option.none(),\n\t              examples: []\n\t            }\n\t          ])\n\t        )\n\t      })\n\t    })\n\t    describe.concurrent(\"parseModule\", () => {\n\t      it(\"should raise an error if `@since` tag is missing\", async () => {\n\t        expectFailure(`import * as assert from 'assert'`, Parser.parseModule, [\n", "          \"Missing documentation in test module\"\n\t        ])\n\t      })\n\t      it(\"should not require an example for modules when `enforceExamples` is set to true (#38)\", () => {\n\t        expectSuccess(\n\t          `/**\n\t* This is the assert module.\n\t*\n\t* @since 1.0.0\n\t*/\n", "import * as assert from 'assert'\n\t/**\n\t * This is the foo export.\n\t *\n\t * @example\n\t * import { foo } from 'test'\n\t *\n\t * console.log(foo)\n\t *\n\t * @category foo\n", " * @since 1.0.0\n\t */\n\texport const foo = 'foo'`,\n\t          Parser.parseModule,\n\t          {\n\t            name: \"test\",\n\t            description: Option.some(\"This is the assert module.\"),\n\t            since: Option.some(\"1.0.0\"),\n\t            deprecated: false,\n\t            examples: [],\n", "            category: Option.none(),\n\t            path: [\"test\"],\n\t            classes: [],\n\t            interfaces: [],\n\t            functions: [],\n\t            typeAliases: [],\n\t            constants: [\n\t              {\n\t                _tag: \"Constant\",\n\t                name: \"foo\",\n", "                description: Option.some(\"This is the foo export.\"),\n\t                since: Option.some(\"1.0.0\"),\n\t                deprecated: false,\n\t                examples: [`import { foo } from 'test'\\n\\nconsole.log(foo)`],\n\t                category: Option.some(\"foo\"),\n\t                signature: \"export declare const foo: \\\"foo\\\"\"\n\t              }\n\t            ],\n\t            exports: []\n\t          },\n", "          { enforceExamples: true }\n\t        )\n\t      })\n\t    })\n\t    describe.concurrent(\"parseFile\", () => {\n\t      it(\"should not parse a non-existent file\", async () => {\n\t        const file = FileSystem.makeFile(\"non-existent.ts\", \"\")\n\t        const project = new ast.Project({ useInMemoryFileSystem: true })\n\t        assert.deepStrictEqual(\n\t          Parser.parseFile(project)(file).pipe(\n", "            Effect.provideService(Config.Config, defaultConfig),\n\t            Effect.runSyncExit,\n\t            Exit.unannotate\n\t          ),\n\t          Exit.fail([\"Unable to locate file: non-existent.ts\"])\n\t        )\n\t      })\n\t    })\n\t  })\n\t  describe.concurrent(\"utils\", () => {\n", "    describe.concurrent(\"getCommentInfo\", () => {\n\t      it(\"should parse comment information\", () => {\n\t        const text = String.stripMargin(\n\t          `|/**\n\t           | * description\n\t           | * @category instances\n\t           | * @since 1.0.0\n\t           | */`\n\t        )\n\t        expectSuccess(\"\", Parser.getCommentInfo(\"name\")(text), {\n", "          description: Option.some(\"description\"),\n\t          since: Option.some(\"1.0.0\"),\n\t          category: Option.some(\"instances\"),\n\t          deprecated: false,\n\t          examples: []\n\t        })\n\t      })\n\t      it(\"should fail if an empty comment tag is provided\", () => {\n\t        const text = String.stripMargin(\n\t          `|/**\n", "           | * @category\n\t           | * @since 1.0.0\n\t           | */`\n\t        )\n\t        expectFailure(\n\t          \"\",\n\t          Parser.getCommentInfo(\"name\")(text),\n\t          `Missing ${chalk.bold(\"@category\")} tag in ${chalk.bold(\"test#name\")} documentation`\n\t        )\n\t      })\n", "      it(\"should require a description if `enforceDescriptions` is set to true\", () => {\n\t        const text = String.stripMargin(\n\t          `|/**\n\t           | * @category instances\n\t           | * @since 1.0.0\n\t           | */`\n\t        )\n\t        expectFailure(\n\t          \"\",\n\t          Parser.getCommentInfo(\"name\")(text),\n", "          `Missing ${chalk.bold(\"description\")} in ${chalk.bold(\"test#name\")} documentation`,\n\t          {\n\t            enforceDescriptions: true\n\t          }\n\t        )\n\t      })\n\t      it(\"should require at least one example if `enforceExamples` is set to true\", () => {\n\t        const text = String.stripMargin(\n\t          `|/**\n\t           | * description\n", "           | * @category instances\n\t           | * @since 1.0.0\n\t           | */`\n\t        )\n\t        expectFailure(\n\t          \"\",\n\t          Parser.getCommentInfo(\"name\")(text),\n\t          `Missing ${chalk.bold(\"@example\")} tag in ${chalk.bold(\"test#name\")} documentation`,\n\t          {\n\t            enforceExamples: true\n", "          }\n\t        )\n\t      })\n\t      it(\"should require at least one non-empty example if `enforceExamples` is set to true\", () => {\n\t        const text = String.stripMargin(\n\t          `|/**\n\t           | * description\n\t           | * @example\n\t           | * @category instances\n\t           | * @since 1.0.0\n", "           | */`\n\t        )\n\t        expectFailure(\n\t          \"\",\n\t          Parser.getCommentInfo(\"name\")(text),\n\t          `Missing ${chalk.bold(\"@example\")} tag in ${chalk.bold(\"test#name\")} documentation`,\n\t          {\n\t            enforceExamples: true\n\t          }\n\t        )\n", "      })\n\t      it(\"should allow no since tag if `enforceVersion` is set to false\", () => {\n\t        const text = `/**\n\t* description\n\t* @category instances\n\t*/`\n\t        expectSuccess(\n\t          \"\",\n\t          Parser.getCommentInfo(\"name\")(text),\n\t          {\n", "            description: Option.some(\"description\"),\n\t            since: Option.none(),\n\t            category: Option.some(\"instances\"),\n\t            deprecated: false,\n\t            examples: []\n\t          },\n\t          { enforceVersion: false }\n\t        )\n\t      })\n\t    })\n", "    it(\"parseComment\", () => {\n\t      assert.deepStrictEqual(Parser.parseComment(\"\"), {\n\t        description: Option.none(),\n\t        tags: {}\n\t      })\n\t      assert.deepStrictEqual(Parser.parseComment(\"/** description */\"), {\n\t        description: Option.some(\"description\"),\n\t        tags: {}\n\t      })\n\t      assert.deepStrictEqual(\n", "        Parser.parseComment(\"/** description\\n * @since 1.0.0\\n */\"),\n\t        {\n\t          description: Option.some(\"description\"),\n\t          tags: {\n\t            since: [Option.some(\"1.0.0\")]\n\t          }\n\t        }\n\t      )\n\t      assert.deepStrictEqual(\n\t        Parser.parseComment(\"/** description\\n * @deprecated\\n */\"),\n", "        {\n\t          description: Option.some(\"description\"),\n\t          tags: {\n\t            deprecated: [Option.none()]\n\t          }\n\t        }\n\t      )\n\t      assert.deepStrictEqual(\n\t        Parser.parseComment(\"/** description\\n * @category instance\\n */\"),\n\t        {\n", "          description: Option.some(\"description\"),\n\t          tags: {\n\t            category: [Option.some(\"instance\")]\n\t          }\n\t        }\n\t      )\n\t    })\n\t    it(\"stripImportTypes\", () => {\n\t      assert.deepStrictEqual(\n\t        Parser.stripImportTypes(\n", "          \"{ <E, A, B>(refinement: import(\\\"/Users/giulio/Documents/Projects/github/fp-ts/src/function\\\").Refinement<A, B>, onFalse: (a: A) => E): (ma: Either<E, A>) => Either<E, B>; <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Either<E, A>) => Either<E, A>; }\"\n\t        ),\n\t        \"{ <E, A, B>(refinement: Refinement<A, B>, onFalse: (a: A) => E): (ma: Either<E, A>) => Either<E, B>; <E, A>(predicate: Predicate<A>, onFalse: (a: A) => E): (ma: Either<E, A>) => Either<E, A>; }\"\n\t      )\n\t      assert.deepStrictEqual(\n\t        Parser.stripImportTypes(\n\t          \"{ <A, B>(refinementWithIndex: import(\\\"/Users/giulio/Documents/Projects/github/fp-ts/src/FilterableWithIndex\\\").RefinementWithIndex<number, A, B>): (fa: A[]) => B[]; <A>(predicateWithIndex: import(\\\"/Users/giulio/Documents/Projects/github/fp-ts/src/FilterableWithIndex\\\").PredicateWithIndex<number, A>): (fa: A[]) => A[]; }\"\n\t        ),\n\t        \"{ <A, B>(refinementWithIndex: RefinementWithIndex<number, A, B>): (fa: A[]) => B[]; <A>(predicateWithIndex: PredicateWithIndex<number, A>): (fa: A[]) => A[]; }\"\n\t      )\n", "    })\n\t  })\n\t})\n"]}
{"filename": "scripts/copy-package-json.ts", "chunked_list": ["import { Effect, ReadonlyRecord } from \"effect\"\n\timport * as path from \"node:path\"\n\timport * as FileSystem from \"../src/FileSystem\"\n\tconst excludedPrefixes = [\"@effect\", \"effect\", \"chalk\"]\n\tconst excludeEffectPackages = (\n\t  deps: Record<string, string>\n\t): Record<string, string> => {\n\t  return ReadonlyRecord.filter(\n\t    deps,\n\t    (_, k) => !excludedPrefixes.some((_) => k.startsWith(_))\n", "  )\n\t}\n\tconst read = FileSystem.FileSystem.pipe(\n\t  Effect.flatMap((fileSystem) => fileSystem.readJsonFile(\"package.json\")),\n\t  Effect.map((json: any) => ({\n\t    name: json.name,\n\t    version: json.version,\n\t    description: json.description,\n\t    main: \"bin.js\",\n\t    bin: \"bin.js\",\n", "    engines: json.engines,\n\t    dependencies: excludeEffectPackages(json.dependencies),\n\t    peerDependencies: excludeEffectPackages(json.peerDependencies),\n\t    repository: json.repository,\n\t    author: json.author,\n\t    license: json.license,\n\t    bugs: json.bugs,\n\t    homepage: json.homepage,\n\t    tags: json.tags,\n\t    keywords: json.keywords\n", "  }))\n\t)\n\tconst pathTo = path.join(\"dist\", \"package.json\")\n\tconst write = (pkg: object) =>\n\t  Effect.flatMap(\n\t    FileSystem.FileSystem,\n\t    (fileSystem) => fileSystem.writeFile(pathTo, JSON.stringify(pkg, null, 2))\n\t  )\n\tconst program = Effect.sync(() => console.log(`copying package.json to ${pathTo}...`)).pipe(\n\t  Effect.zipRight(read),\n", "  Effect.flatMap(write),\n\t  Effect.provideLayer(FileSystem.FileSystemLive)\n\t)\n\tEffect.runPromise(program)\n"]}
{"filename": "src/ChildProcess.ts", "chunked_list": ["/**\n\t * @since 1.0.0\n\t */\n\timport { Context, Data, Effect, Layer } from \"effect\"\n\timport * as NodeChildProcess from \"node:child_process\"\n\t/**\n\t * Represents an entity that is capable of spawning child processes.\n\t *\n\t * @category model\n\t * @since 1.0.0\n", " */\n\texport interface ChildProcess {\n\t  /**\n\t   * Executes a command like:\n\t   *\n\t   * ```sh\n\t   * ts-node docs/examples/index.ts\n\t   * ```\n\t   *\n\t   * where `command = ts-node` and `executable = docs/examples/index.ts`\n", "   */\n\t  spawn(\n\t    command: string,\n\t    executable: string\n\t  ): Effect.Effect<never, ExecutionError | SpawnError, void>\n\t}\n\t/**\n\t * Represents an error that occurs when trying to spawn a child process.\n\t *\n\t * @category model\n", " * @since 1.0.0\n\t */\n\texport interface SpawnError extends Data.Case {\n\t  readonly _tag: \"SpawnError\"\n\t  readonly command: string\n\t  readonly args: ReadonlyArray<string>\n\t  readonly error: Error\n\t}\n\t/**\n\t * @category constructors\n", " * @since 1.0.0\n\t */\n\texport const SpawnError = Data.tagged<SpawnError>(\"SpawnError\")\n\t/**\n\t * Represents an error that occurs within a child process during execution.\n\t *\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface ExecutionError extends Data.Case {\n", "  readonly _tag: \"ExecutionError\"\n\t  readonly command: string\n\t  readonly stderr: string\n\t}\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const ExecutionError = Data.tagged<ExecutionError>(\"ExecutionError\")\n\t/**\n", " * @category service\n\t * @since 1.0.0\n\t */\n\texport const ChildProcess = Context.Tag<ChildProcess>()\n\t/**\n\t * @category service\n\t * @since 1.0.0\n\t */\n\texport const ChildProcessLive = Layer.succeed(\n\t  ChildProcess,\n", "  ChildProcess.of({\n\t    spawn: (command, executable) =>\n\t      Effect.try({\n\t        try: () =>\n\t          NodeChildProcess.spawnSync(command, [executable], {\n\t            stdio: \"pipe\",\n\t            encoding: \"utf8\"\n\t          }),\n\t        catch: (error) =>\n\t          SpawnError({\n", "            command,\n\t            args: [executable],\n\t            error: error instanceof Error ? error : new Error(String(error))\n\t          })\n\t      }).pipe(\n\t        Effect.flatMap(({ status, stderr }) =>\n\t          status === 0\n\t            ? Effect.unit\n\t            : Effect.fail(ExecutionError({ command, stderr }))\n\t        )\n", "      )\n\t  })\n\t)\n"]}
{"filename": "src/Markdown.ts", "chunked_list": ["/**\n\t * @since 1.0.0\n\t */\n\timport { Option, Order, pipe, ReadonlyArray, ReadonlyRecord, String } from \"effect\"\n\timport * as Prettier from \"prettier\"\n\timport type * as Domain from \"./Domain\"\n\t// eslint-disable-next-line @typescript-eslint/no-var-requires\n\tconst toc = require(\"markdown-toc\")\n\ttype Printable =\n\t  | Domain.Class\n", "  | Domain.Constant\n\t  | Domain.Export\n\t  | Domain.Function\n\t  | Domain.Interface\n\t  | Domain.TypeAlias\n\tconst bold = (s: string) => `**${s}**`\n\tconst fence = (language: string, content: string) =>\n\t  \"```\" + language + \"\\n\" + content + \"\\n\" + \"```\\n\\n\"\n\tconst paragraph = (...content: ReadonlyArray<string>) => \"\\n\" + content.join(\"\") + \"\\n\\n\"\n\tconst strikethrough = (content: string) => `~~${content}~~`\n", "const createHeader = (level: number) => (content: string): string =>\n\t  \"#\".repeat(level) + \" \" + content + \"\\n\\n\"\n\tconst h1 = createHeader(1)\n\tconst h2 = createHeader(2)\n\tconst h3 = createHeader(3)\n\tconst getSince: (v: Option.Option<string>) => string = Option.match({\n\t  onNone: () => \"\",\n\t  onSome: (v) => paragraph(`Added in v${v}`)\n\t})\n\tconst getTitle = (s: string, deprecated: boolean, type?: string): string => {\n", "  const name = s.trim() === \"hasOwnProperty\" ? `${s} (function)` : s\n\t  const title = deprecated ? strikethrough(name) : name\n\t  return Option.fromNullable(type).pipe(\n\t    Option.match({\n\t      onNone: () => title,\n\t      onSome: (t) => title + ` ${t}`\n\t    })\n\t  )\n\t}\n\tconst getDescription = (d: Option.Option<string>): string =>\n", "  paragraph(Option.getOrElse(d, () => \"\"))\n\tconst getSignature = (s: string): string => paragraph(bold(\"Signature\")) + paragraph(fence(\"ts\", s))\n\tconst getSignatures = (ss: ReadonlyArray<string>): string =>\n\t  paragraph(bold(\"Signature\")) + paragraph(fence(\"ts\", ss.join(\"\\n\")))\n\tconst getExamples = (es: ReadonlyArray<string>): string =>\n\t  es\n\t    .map((code) => paragraph(bold(\"Example\")) + paragraph(fence(\"ts\", code)))\n\t    .join(\"\\n\\n\")\n\tconst getStaticMethod = (m: Domain.Method): string =>\n\t  paragraph(\n", "    h3(getTitle(m.name, m.deprecated, \"(static method)\")),\n\t    getDescription(m.description),\n\t    getSignatures(m.signatures),\n\t    getExamples(m.examples),\n\t    getSince(m.since)\n\t  )\n\tconst getMethod = (m: Domain.Method): string =>\n\t  paragraph(\n\t    h3(getTitle(m.name, m.deprecated, \"(method)\")),\n\t    getDescription(m.description),\n", "    getSignatures(m.signatures),\n\t    getExamples(m.examples),\n\t    getSince(m.since)\n\t  )\n\tconst getProperty = (p: Domain.Property): string =>\n\t  paragraph(\n\t    h3(getTitle(p.name, p.deprecated, \"(property)\")),\n\t    getDescription(p.description),\n\t    getSignature(p.signature),\n\t    getExamples(p.examples),\n", "    getSince(p.since)\n\t  )\n\tconst getStaticMethods = (methods: ReadonlyArray<Domain.Method>): string =>\n\t  ReadonlyArray.map(methods, (method) => getStaticMethod(method) + \"\\n\\n\").join(\n\t    \"\"\n\t  )\n\tconst getMethods = (methods: ReadonlyArray<Domain.Method>): string =>\n\t  ReadonlyArray.map(methods, (method) => getMethod(method) + \"\\n\\n\").join(\"\")\n\tconst getProperties = (properties: ReadonlyArray<Domain.Property>): string =>\n\t  ReadonlyArray.map(\n", "    properties,\n\t    (property) => getProperty(property) + \"\\n\\n\"\n\t  ).join(\"\")\n\tconst getModuleDescription = (module: Domain.Module): string =>\n\t  paragraph(\n\t    h2(getTitle(module.name, module.deprecated, \"overview\")),\n\t    getDescription(module.description),\n\t    getExamples(module.examples),\n\t    getSince(module.since)\n\t  )\n", "const getMeta = (title: string, order: number): string =>\n\t  paragraph(\n\t    \"---\",\n\t    `\\n`,\n\t    `title: ${title}`,\n\t    `\\n`,\n\t    `nav_order: ${order}`,\n\t    `\\n`,\n\t    `parent: Modules`,\n\t    `\\n`,\n", "    \"---\"\n\t  )\n\tconst fromClass = (c: Domain.Class): string =>\n\t  paragraph(\n\t    paragraph(\n\t      h2(getTitle(c.name, c.deprecated, \"(class)\")),\n\t      getDescription(c.description),\n\t      getSignature(c.signature),\n\t      getExamples(c.examples),\n\t      getSince(c.since)\n", "    ),\n\t    getStaticMethods(c.staticMethods),\n\t    getMethods(c.methods),\n\t    getProperties(c.properties)\n\t  )\n\tconst fromConstant = (c: Domain.Constant): string =>\n\t  paragraph(\n\t    h2(getTitle(c.name, c.deprecated)),\n\t    getDescription(c.description),\n\t    getSignature(c.signature),\n", "    getExamples(c.examples),\n\t    getSince(c.since)\n\t  )\n\tconst fromExport = (e: Domain.Export): string =>\n\t  paragraph(\n\t    h2(getTitle(e.name, e.deprecated)),\n\t    getDescription(e.description),\n\t    getSignature(e.signature),\n\t    getExamples(e.examples),\n\t    getSince(e.since)\n", "  )\n\tconst fromFunction = (f: Domain.Function): string =>\n\t  paragraph(\n\t    h2(getTitle(f.name, f.deprecated)),\n\t    getDescription(f.description),\n\t    getSignatures(f.signatures),\n\t    getExamples(f.examples),\n\t    getSince(f.since)\n\t  )\n\tconst fromInterface = (i: Domain.Interface): string =>\n", "  paragraph(\n\t    h2(getTitle(i.name, i.deprecated, \"(interface)\")),\n\t    getDescription(i.description),\n\t    getSignature(i.signature),\n\t    getExamples(i.examples),\n\t    getSince(i.since)\n\t  )\n\tconst fromTypeAlias = (ta: Domain.TypeAlias): string =>\n\t  paragraph(\n\t    h2(getTitle(ta.name, ta.deprecated, \"(type alias)\")),\n", "    getDescription(ta.description),\n\t    getSignature(ta.signature),\n\t    getExamples(ta.examples),\n\t    getSince(ta.since)\n\t  )\n\t/** @internal */\n\texport const fromPrintable = (p: Printable): string => {\n\t  switch (p._tag) {\n\t    case \"Class\":\n\t      return fromClass(p)\n", "    case \"Constant\":\n\t      return fromConstant(p)\n\t    case \"Export\":\n\t      return fromExport(p)\n\t    case \"Function\":\n\t      return fromFunction(p)\n\t    case \"Interface\":\n\t      return fromInterface(p)\n\t    case \"TypeAlias\":\n\t      return fromTypeAlias(p)\n", "  }\n\t}\n\tconst getPrintables = (module: Domain.Module): ReadonlyArray<Printable> =>\n\t  ReadonlyArray.flatten<Printable>([\n\t    module.classes,\n\t    module.constants,\n\t    module.exports,\n\t    module.functions,\n\t    module.interfaces,\n\t    module.typeAliases\n", "  ])\n\t/**\n\t * @category printers\n\t * @since 1.0.0\n\t */\n\texport const printModule = (module: Domain.Module, order: number): string => {\n\t  const DEFAULT_CATEGORY = \"utils\"\n\t  const header = getMeta(module.path.slice(1).join(\"/\"), order)\n\t  const description = paragraph(getModuleDescription(module))\n\t  const content = pipe(\n", "    getPrintables(module),\n\t    ReadonlyArray.groupBy(({ category }) => Option.getOrElse(category, () => DEFAULT_CATEGORY)),\n\t    ReadonlyRecord.toEntries,\n\t    ReadonlyArray.sort(\n\t      Order.mapInput(String.Order, ([category]: [string, unknown]) => category)\n\t    ),\n\t    ReadonlyArray.map(([category, printables]) =>\n\t      [\n\t        h1(category),\n\t        ...pipe(\n", "          printables,\n\t          ReadonlyArray.sort(\n\t            Order.mapInput(\n\t              String.Order,\n\t              (printable: Printable) => printable.name\n\t            )\n\t          ),\n\t          ReadonlyArray.map(fromPrintable)\n\t        )\n\t      ].join(\"\\n\")\n", "    )\n\t  ).join(\"\\n\")\n\t  const tableOfContents = (content: string) =>\n\t    \"<h2 class=\\\"text-delta\\\">Table of contents</h2>\\n\\n\"\n\t    + toc(content).content\n\t    + \"\\n\\n\"\n\t  return prettify(\n\t    [\n\t      header,\n\t      description,\n", "      \"---\\n\",\n\t      tableOfContents(content),\n\t      \"---\\n\",\n\t      content\n\t    ].join(\"\\n\")\n\t  )\n\t}\n\tconst defaultPrettierOptions: Prettier.Options = {\n\t  parser: \"markdown\",\n\t  semi: false,\n", "  singleQuote: true,\n\t  printWidth: 120\n\t}\n\t/** @internal */\n\texport const prettify = (s: string): string => Prettier.format(s, defaultPrettierOptions)\n"]}
{"filename": "src/Logger.ts", "chunked_list": ["/**\n\t * @since 1.0.0\n\t */\n\timport chalk from \"chalk\"\n\timport { Logger } from \"effect\"\n\t/**\n\t * @category logging\n\t * @since 1.0.0\n\t */\n\texport const SimpleLogger = Logger.make(({ logLevel, message }) => {\n", "  if (logLevel._tag === \"Debug\") {\n\t    globalThis.console.log(chalk.gray(`[${logLevel.label}] ${message}`))\n\t  } else {\n\t    globalThis.console.log(`[${logLevel.label}] ${message}`)\n\t  }\n\t})\n"]}
{"filename": "src/Domain.ts", "chunked_list": ["/**\n\t * @since 1.0.0\n\t */\n\timport { Order as order, String } from \"effect\"\n\timport type { Option } from \"effect\"\n\t/**\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface Module extends Documentable {\n", "  readonly path: ReadonlyArray<string>\n\t  readonly classes: ReadonlyArray<Class>\n\t  readonly interfaces: ReadonlyArray<Interface>\n\t  readonly functions: ReadonlyArray<Function>\n\t  readonly typeAliases: ReadonlyArray<TypeAlias>\n\t  readonly constants: ReadonlyArray<Constant>\n\t  readonly exports: ReadonlyArray<Export>\n\t}\n\t/**\n\t * @category model\n", " * @since 1.0.0\n\t */\n\texport interface Documentable {\n\t  readonly name: string\n\t  readonly description: Option.Option<string>\n\t  readonly since: Option.Option<string>\n\t  readonly deprecated: boolean\n\t  readonly examples: ReadonlyArray<Example>\n\t  readonly category: Option.Option<string>\n\t}\n", "/**\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface Class extends Documentable {\n\t  readonly _tag: \"Class\"\n\t  readonly signature: string\n\t  readonly methods: ReadonlyArray<Method>\n\t  readonly staticMethods: ReadonlyArray<Method>\n\t  readonly properties: ReadonlyArray<Property>\n", "}\n\t/**\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface Method extends Documentable {\n\t  readonly signatures: ReadonlyArray<string>\n\t}\n\t/**\n\t * @category model\n", " * @since 1.0.0\n\t */\n\texport interface Property extends Documentable {\n\t  readonly signature: string\n\t}\n\t/**\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface Interface extends Documentable {\n", "  readonly _tag: \"Interface\"\n\t  readonly signature: string\n\t}\n\t/**\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface Function extends Documentable {\n\t  readonly _tag: \"Function\"\n\t  readonly signatures: ReadonlyArray<string>\n", "}\n\t/**\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface TypeAlias extends Documentable {\n\t  readonly _tag: \"TypeAlias\"\n\t  readonly signature: string\n\t}\n\t/**\n", " * @category model\n\t * @since 1.0.0\n\t */\n\texport interface Constant extends Documentable {\n\t  readonly _tag: \"Constant\"\n\t  readonly signature: string\n\t}\n\t/**\n\t * @category model\n\t * @since 1.0.0\n", " */\n\texport interface Export extends Documentable {\n\t  readonly _tag: \"Export\"\n\t  readonly signature: string\n\t}\n\t/**\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport type Example = string\n", "// -------------------------------------------------------------------------------------\n\t// constructors\n\t// -------------------------------------------------------------------------------------\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const createDocumentable = (\n\t  name: string,\n\t  description: Option.Option<string>,\n", "  since: Option.Option<string>,\n\t  deprecated: boolean,\n\t  examples: ReadonlyArray<Example>,\n\t  category: Option.Option<string>\n\t): Documentable => ({\n\t  name,\n\t  description,\n\t  since,\n\t  deprecated,\n\t  examples,\n", "  category\n\t})\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const createModule = (\n\t  documentable: Documentable,\n\t  path: ReadonlyArray<string>,\n\t  classes: ReadonlyArray<Class>,\n", "  interfaces: ReadonlyArray<Interface>,\n\t  functions: ReadonlyArray<Function>,\n\t  typeAliases: ReadonlyArray<TypeAlias>,\n\t  constants: ReadonlyArray<Constant>,\n\t  exports: ReadonlyArray<Export>\n\t): Module => ({\n\t  ...documentable,\n\t  path,\n\t  classes,\n\t  interfaces,\n", "  functions,\n\t  typeAliases,\n\t  constants,\n\t  exports\n\t})\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const createClass = (\n", "  documentable: Documentable,\n\t  signature: string,\n\t  methods: ReadonlyArray<Method>,\n\t  staticMethods: ReadonlyArray<Method>,\n\t  properties: ReadonlyArray<Property>\n\t): Class => ({\n\t  _tag: \"Class\",\n\t  ...documentable,\n\t  signature,\n\t  methods,\n", "  staticMethods,\n\t  properties\n\t})\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const createConstant = (\n\t  documentable: Documentable,\n\t  signature: string\n", "): Constant => ({\n\t  _tag: \"Constant\",\n\t  ...documentable,\n\t  signature\n\t})\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const createMethod = (\n", "  documentable: Documentable,\n\t  signatures: ReadonlyArray<string>\n\t): Method => ({\n\t  ...documentable,\n\t  signatures\n\t})\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n", "export const createProperty = (\n\t  documentable: Documentable,\n\t  signature: string\n\t): Property => ({\n\t  ...documentable,\n\t  signature\n\t})\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n", " */\n\texport const createInterface = (\n\t  documentable: Documentable,\n\t  signature: string\n\t): Interface => ({\n\t  _tag: \"Interface\",\n\t  ...documentable,\n\t  signature\n\t})\n\t/**\n", " * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const createFunction = (\n\t  documentable: Documentable,\n\t  signatures: ReadonlyArray<string>\n\t): Function => ({\n\t  _tag: \"Function\",\n\t  ...documentable,\n\t  signatures\n", "})\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const createTypeAlias = (\n\t  documentable: Documentable,\n\t  signature: string\n\t): TypeAlias => ({\n\t  _tag: \"TypeAlias\",\n", "  ...documentable,\n\t  signature\n\t})\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const createExport = (\n\t  documentable: Documentable,\n\t  signature: string\n", "): Export => ({\n\t  _tag: \"Export\",\n\t  ...documentable,\n\t  signature\n\t})\n\t/**\n\t * @category instances\n\t * @since 1.0.0\n\t */\n\texport const Order: order.Order<Module> = order.mapInput(\n", "  String.Order,\n\t  (module: Module) => module.path.join(\"/\").toLowerCase()\n\t)\n"]}
{"filename": "src/FileSystem.ts", "chunked_list": ["/**\n\t * @since 1.0.0\n\t */\n\timport { Context, Data, Effect, Layer } from \"effect\"\n\timport * as NodeFS from \"fs-extra\"\n\timport * as Glob from \"glob\"\n\timport * as Rimraf from \"rimraf\"\n\t/**\n\t * Represents a file system which can be read from and written to.\n\t *\n", " * @category model\n\t * @since 1.0.0\n\t */\n\texport interface FileSystem {\n\t  /**\n\t   * Read a file from the file system at the specified `path`.\n\t   */\n\t  readFile(path: string): Effect.Effect<never, ReadFileError, string>\n\t  /**\n\t   * Read a `.json` file from the file system at the specified `path` and parse\n", "   * the contents.\n\t   */\n\t  readJsonFile(path: string): Effect.Effect<never, ReadFileError | ParseJsonError, unknown>\n\t  /**\n\t   * Write a file to the specified `path` containing the specified `content`.\n\t   */\n\t  writeFile(path: string, content: string): Effect.Effect<never, WriteFileError, void>\n\t  /**\n\t   * Removes a file from the file system at the specified `path`.\n\t   */\n", "  removeFile(path: string): Effect.Effect<never, RemoveFileError, void>\n\t  /**\n\t   * Checks if the specified `path` exists on the file system.\n\t   */\n\t  pathExists(path: string): Effect.Effect<never, ReadFileError, boolean>\n\t  /**\n\t   * Find all files matching the specified `glob` pattern, optionally excluding\n\t   * files matching the provided `exclude` patterns.\n\t   */\n\t  glob(\n", "    pattern: string,\n\t    exclude?: ReadonlyArray<string>\n\t  ): Effect.Effect<never, GlobError, ReadonlyArray<string>>\n\t}\n\t/**\n\t * Represents an error that occurs when attempting to read a file from the\n\t * file system.\n\t *\n\t * @category model\n\t * @since 1.0.0\n", " */\n\texport interface ReadFileError extends Data.Case {\n\t  readonly _tag: \"ReadFileError\"\n\t  readonly path: string\n\t  readonly error: Error\n\t}\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n", "export const ReadFileError = Data.tagged<ReadFileError>(\"ReadFileError\")\n\t/**\n\t * Represents an error that occurs when attempting to write a file to the\n\t * file system.\n\t *\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface WriteFileError extends Data.Case {\n\t  readonly _tag: \"WriteFileError\"\n", "  readonly path: string\n\t  readonly error: Error\n\t}\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const WriteFileError = Data.tagged<WriteFileError>(\"WriteFileError\")\n\t/**\n\t * Represents an error that occurs when attempting to remove a file from the\n", " * file system.\n\t *\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface RemoveFileError extends Data.Case {\n\t  readonly _tag: \"RemoveFileError\"\n\t  readonly path: string\n\t  readonly error: Error\n\t}\n", "/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const RemoveFileError = Data.tagged<RemoveFileError>(\"RemoveFileError\")\n\t/**\n\t * Represents an error that occurs when attempting to parse JSON content.\n\t *\n\t * @category model\n\t * @since 1.0.0\n", " */\n\texport interface ParseJsonError extends Data.Case {\n\t  readonly _tag: \"ParseJsonError\"\n\t  readonly content: string\n\t  readonly error: Error\n\t}\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n", "export const ParseJsonError = Data.tagged<ParseJsonError>(\"ParseJsonError\")\n\t/**\n\t * Represents an error that occurs when attempting to execute a glob pattern to\n\t * find multiple files on the file system.\n\t *\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface GlobError extends Data.Case {\n\t  readonly _tag: \"GlobError\"\n", "  readonly pattern: string\n\t  readonly exclude: ReadonlyArray<string>\n\t  readonly error: Error\n\t}\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const GlobError = Data.tagged<GlobError>(\"GlobError\")\n\t/**\n", " * @category service\n\t * @since 1.0.0\n\t */\n\texport const FileSystem = Context.Tag<FileSystem>()\n\t/**\n\t * @category service\n\t * @since 1.0.0\n\t */\n\texport const FileSystemLive = Layer.effect(\n\t  FileSystem,\n", "  Effect.sync(() => {\n\t    const readFile = (path: string): Effect.Effect<never, ReadFileError, string> =>\n\t      Effect.async((resume) =>\n\t        NodeFS.readFile(path, \"utf8\", (error, data) => {\n\t          if (error) {\n\t            resume(Effect.fail(ReadFileError({ path, error })))\n\t          } else {\n\t            resume(Effect.succeed(data))\n\t          }\n\t        })\n", "      )\n\t    const readJsonFile = (\n\t      path: string\n\t    ): Effect.Effect<never, ReadFileError | ParseJsonError, unknown> =>\n\t      Effect.flatMap(readFile(path), (content) =>\n\t        Effect.try({\n\t          try: () => JSON.parse(content),\n\t          catch: (error) =>\n\t            ParseJsonError({\n\t              content,\n", "              error: error instanceof Error ? error : new Error(String(error))\n\t            })\n\t        }))\n\t    const writeFile = (path: string, content: string): Effect.Effect<never, WriteFileError, void> =>\n\t      Effect.async((resume) =>\n\t        NodeFS.outputFile(path, content, \"utf8\", (error) => {\n\t          if (error) {\n\t            resume(Effect.fail(WriteFileError({ path, error })))\n\t          } else {\n\t            resume(Effect.unit)\n", "          }\n\t        })\n\t      )\n\t    const removeFile = (path: string): Effect.Effect<never, RemoveFileError, void> =>\n\t      Effect.tryPromise({\n\t        try: () => Rimraf.rimraf(path),\n\t        catch: (error) =>\n\t          RemoveFileError({\n\t            error: error instanceof Error ? error : new Error(String(error)),\n\t            path\n", "          })\n\t      })\n\t    const pathExists = (path: string): Effect.Effect<never, ReadFileError, boolean> =>\n\t      Effect.async((resume) =>\n\t        NodeFS.pathExists(path, (error, data) => {\n\t          if (error) {\n\t            resume(Effect.fail(ReadFileError({ error, path })))\n\t          } else {\n\t            resume(Effect.succeed(data))\n\t          }\n", "        })\n\t      )\n\t    const glob = (\n\t      pattern: string,\n\t      exclude: Array<string> = []\n\t    ): Effect.Effect<never, GlobError, Array<string>> =>\n\t      Effect.tryPromise({\n\t        try: () => Glob.glob(pattern, { ignore: exclude, withFileTypes: false }),\n\t        catch: (error) =>\n\t          GlobError({\n", "            error: error instanceof Error ? error : new Error(String(error)),\n\t            exclude,\n\t            pattern\n\t          })\n\t      })\n\t    return FileSystem.of({\n\t      readFile,\n\t      readJsonFile,\n\t      writeFile,\n\t      removeFile,\n", "      pathExists,\n\t      glob\n\t    })\n\t  })\n\t)\n\t/**\n\t * Represents a file which can be optionally overwriteable.\n\t *\n\t * @category model\n\t * @since 1.0.0\n", " */\n\texport interface File extends\n\t  Data.Data<{\n\t    readonly path: string\n\t    readonly content: string\n\t    readonly overwrite: boolean\n\t  }>\n\t{}\n\t/**\n\t * By default files are readonly (`overwrite = false`).\n", " *\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const makeFile = (\n\t  path: string,\n\t  content: string,\n\t  overwrite = false\n\t): File =>\n\t  Data.struct({\n", "    path,\n\t    content,\n\t    overwrite\n\t  })\n"]}
{"filename": "src/Config.ts", "chunked_list": ["/**\n\t * @since 1.0.0\n\t */\n\timport * as Schema from \"@effect/schema/Schema\"\n\timport * as TreeFormatter from \"@effect/schema/TreeFormatter\"\n\timport chalk from \"chalk\"\n\timport { Context, Data, Effect, Layer, Option } from \"effect\"\n\timport * as NodePath from \"node:path\"\n\timport * as FileSystem from \"./FileSystem\"\n\timport * as Process from \"./Process\"\n", "const PACKAGE_JSON_FILE_NAME = \"package.json\"\n\tconst CONFIG_FILE_NAME = \"docgen.json\"\n\t/**\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface Config {\n\t  readonly projectName: string\n\t  readonly projectHomepage: string\n\t  readonly srcDir: string\n", "  readonly outDir: string\n\t  readonly theme: string\n\t  readonly enableSearch: boolean\n\t  readonly enforceDescriptions: boolean\n\t  readonly enforceExamples: boolean\n\t  readonly enforceVersion: boolean\n\t  readonly exclude: ReadonlyArray<string>\n\t  readonly parseCompilerOptions: Record<string, unknown>\n\t  readonly examplesCompilerOptions: Record<string, unknown>\n\t}\n", "/**\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface ConfigError extends Data.Case {\n\t  readonly _tag: \"ConfigError\"\n\t  readonly message: string\n\t}\n\t/**\n\t * @category constructors\n", " * @since 1.0.0\n\t */\n\texport const ConfigError = Data.tagged<ConfigError>(\"ConfigError\")\n\t/**\n\t * @category service\n\t * @since 1.0.0\n\t */\n\texport const Config = Context.Tag<Config>()\n\tconst ConfigSchema = Schema.struct({\n\t  projectHomepage: Schema.string,\n", "  srcDir: Schema.string,\n\t  outDir: Schema.string,\n\t  theme: Schema.string,\n\t  enableSearch: Schema.boolean,\n\t  enforceDescriptions: Schema.boolean,\n\t  enforceExamples: Schema.boolean,\n\t  enforceVersion: Schema.boolean,\n\t  exclude: Schema.array(Schema.string),\n\t  parseCompilerOptions: Schema.record(Schema.string, Schema.unknown),\n\t  examplesCompilerOptions: Schema.record(Schema.string, Schema.unknown)\n", "})\n\tconst PartialConfigSchema = Schema.partial(ConfigSchema)\n\tconst PackageJsonSchema = Schema.struct({\n\t  name: Schema.string,\n\t  homepage: Schema.string\n\t})\n\tconst parseJsonFile = <I, A>(\n\t  schema: Schema.Schema<I, A>,\n\t  path: string,\n\t  fileSystem: FileSystem.FileSystem\n", "): Effect.Effect<never, ConfigError | FileSystem.ReadFileError | FileSystem.ParseJsonError, A> =>\n\t  fileSystem.readJsonFile(path).pipe(\n\t    Effect.flatMap((content) =>\n\t      Schema.parse(schema)(content).pipe(\n\t        Effect.mapError((e) => ConfigError({ message: TreeFormatter.formatErrors(e.errors) }))\n\t      )\n\t    )\n\t  )\n\tconst getDefaultConfig = (projectName: string, projectHomepage: string): Config => ({\n\t  projectName,\n", "  projectHomepage,\n\t  srcDir: \"src\",\n\t  outDir: \"docs\",\n\t  theme: \"pmarsceill/just-the-docs\",\n\t  enableSearch: true,\n\t  enforceDescriptions: false,\n\t  enforceExamples: false,\n\t  enforceVersion: true,\n\t  exclude: [],\n\t  parseCompilerOptions: {},\n", "  examplesCompilerOptions: {}\n\t})\n\tconst loadConfig = (\n\t  path: string,\n\t  fileSystem: FileSystem.FileSystem\n\t): Effect.Effect<\n\t  never,\n\t  ConfigError | FileSystem.ReadFileError | FileSystem.ParseJsonError,\n\t  Option.Option<Schema.To<typeof PartialConfigSchema>>\n\t> =>\n", "  Effect.if(fileSystem.pathExists(path), {\n\t    onTrue: Effect.logInfo(chalk.bold(\"Configuration file found\")).pipe(\n\t      Effect.zipRight(parseJsonFile(PartialConfigSchema, path, fileSystem)),\n\t      Effect.asSome\n\t    ),\n\t    onFalse: Effect.as(\n\t      Effect.logInfo(\n\t        chalk.bold(\"No configuration file detected, using default configuration\")\n\t      ),\n\t      Option.none()\n", "    )\n\t  })\n\t/**\n\t * @category service\n\t * @since 1.0.0\n\t */\n\texport const ConfigLive = Layer.effect(\n\t  Config,\n\t  Effect.gen(function*($) {\n\t    // Extract the requisite services\n", "    const process = yield* $(Process.Process)\n\t    const fileSystem = yield* $(FileSystem.FileSystem)\n\t    const cwd = yield* $(process.cwd)\n\t    // Read and parse the package.json\n\t    const packageJsonPath = NodePath.join(cwd, PACKAGE_JSON_FILE_NAME)\n\t    const packageJson = yield* $(parseJsonFile(PackageJsonSchema, packageJsonPath, fileSystem))\n\t    // Read and resolve the configuration\n\t    const defaultConfig = getDefaultConfig(packageJson.name, packageJson.homepage)\n\t    const configPath = NodePath.join(cwd, CONFIG_FILE_NAME)\n\t    const maybeConfig = yield* $(loadConfig(configPath, fileSystem))\n", "    return Config.of(\n\t      Option.match(maybeConfig, {\n\t        onNone: () => defaultConfig,\n\t        onSome: (loadedConfig) => ({ ...defaultConfig, ...loadedConfig })\n\t      })\n\t    )\n\t  })\n\t)\n"]}
{"filename": "src/index.ts", "chunked_list": ["/**\n\t * @since 1.0.0\n\t */\n\timport { Effect } from \"effect\"\n\timport * as Core from \"./Core\"\n\t/**\n\t * @category main\n\t * @since 1.0.0\n\t */\n\texport const main = Effect.tapErrorCause(Core.main, Effect.logError)\n"]}
{"filename": "src/Parser.ts", "chunked_list": ["/**\n\t * @since 1.0.0\n\t */\n\timport chalk from \"chalk\"\n\timport * as doctrine from \"doctrine\"\n\timport {\n\t  Context,\n\t  Effect,\n\t  Option,\n\t  Order,\n", "  pipe,\n\t  Predicate,\n\t  ReadonlyArray,\n\t  ReadonlyRecord,\n\t  String\n\t} from \"effect\"\n\timport { flow } from \"effect/Function\"\n\timport * as NodePath from \"node:path\"\n\timport * as ast from \"ts-morph\"\n\timport * as Config from \"./Config\"\n", "import * as Domain from \"./Domain\"\n\timport type * as FileSystem from \"./FileSystem\"\n\t/** @internal */\n\texport interface Source {\n\t  readonly path: ReadonlyArray.NonEmptyReadonlyArray<string>\n\t  readonly sourceFile: ast.SourceFile\n\t}\n\t/** @internal */\n\texport const Source = Context.Tag<Source>()\n\tinterface Comment {\n", "  readonly description: Option.Option<string>\n\t  readonly tags: ReadonlyRecord.ReadonlyRecord<\n\t    ReadonlyArray.NonEmptyReadonlyArray<Option.Option<string>>\n\t  >\n\t}\n\tinterface CommentInfo {\n\t  readonly description: Option.Option<string>\n\t  readonly since: Option.Option<string>\n\t  readonly deprecated: boolean\n\t  readonly examples: ReadonlyArray<Domain.Example>\n", "  readonly category: Option.Option<string>\n\t}\n\tconst createCommentInfo = (\n\t  description: Option.Option<string>,\n\t  since: Option.Option<string>,\n\t  deprecated: boolean,\n\t  examples: ReadonlyArray<Domain.Example>,\n\t  category: Option.Option<string>\n\t): CommentInfo => ({\n\t  description,\n", "  since,\n\t  deprecated,\n\t  examples,\n\t  category\n\t})\n\tconst every = <A>(predicates: ReadonlyArray<Predicate.Predicate<A>>) => (a: A): boolean =>\n\t  predicates.every((p) => p(a))\n\tconst some = <A>(predicates: ReadonlyArray<Predicate.Predicate<A>>) => (a: A): boolean =>\n\t  predicates.some((p) => p(a))\n\tconst byName = pipe(\n", "  String.Order,\n\t  Order.mapInput(({ name }: { name: string }) => name)\n\t)\n\tconst sortModules = ReadonlyArray.sort(Domain.Order)\n\tconst isNonEmptyString = (s: string) => s.length > 0\n\t/**\n\t * @internal\n\t */\n\texport const stripImportTypes = (s: string): string => s.replace(/import\\(\"((?!\").)*\"\\)./g, \"\")\n\tconst getJSDocText: (jsdocs: ReadonlyArray<ast.JSDoc>) => string = ReadonlyArray.matchRight({\n", "  onEmpty: () => \"\",\n\t  onNonEmpty: (_, last) => last.getText()\n\t})\n\tconst hasTag = (tag: string) => (comment: Comment) =>\n\t  pipe(comment.tags, ReadonlyRecord.get(tag), Option.isSome)\n\tconst hasInternalTag = hasTag(\"internal\")\n\tconst hasIgnoreTag = hasTag(\"ignore\")\n\tconst shouldIgnore: Predicate.Predicate<Comment> = some([hasInternalTag, hasIgnoreTag])\n\tconst isVariableDeclarationList = (\n\t  u: ast.VariableDeclarationList | ast.CatchClause\n", "): u is ast.VariableDeclarationList => u.getKind() === ast.ts.SyntaxKind.VariableDeclarationList\n\tconst isVariableStatement = (\n\t  u:\n\t    | ast.VariableStatement\n\t    | ast.ForStatement\n\t    | ast.ForOfStatement\n\t    | ast.ForInStatement\n\t): u is ast.VariableStatement => u.getKind() === ast.ts.SyntaxKind.VariableStatement\n\tconst getMissingError = (\n\t  what: string,\n", "  path: ReadonlyArray<string>,\n\t  name: string\n\t): string =>\n\t  `Missing ${chalk.bold(what)} in ${\n\t    chalk.bold(\n\t      path.join(\"/\") + \"#\" + name\n\t    )\n\t  } documentation`\n\tconst getMissingTagError = (\n\t  tag: string,\n", "  path: ReadonlyArray<string>,\n\t  name: string\n\t): string =>\n\t  `Missing ${chalk.bold(tag)} tag in ${\n\t    chalk.bold(\n\t      path.join(\"/\") + \"#\" + name\n\t    )\n\t  } documentation`\n\tconst getSinceTag = (name: string, comment: Comment) =>\n\t  pipe(\n", "    Effect.all([Config.Config, Source]),\n\t    Effect.flatMap(([config, source]) =>\n\t      pipe(\n\t        comment.tags,\n\t        ReadonlyRecord.get(\"since\"),\n\t        Option.flatMap(ReadonlyArray.headNonEmpty),\n\t        Effect.asSome,\n\t        Effect.catchAll(() =>\n\t          config.enforceVersion\n\t            ? Effect.fail(getMissingTagError(\"@since\", source.path, name))\n", "            : Effect.succeed(Option.none<string>())\n\t        )\n\t      )\n\t    )\n\t  )\n\tconst getCategoryTag = (name: string, comment: Comment) =>\n\t  Effect.flatMap(Source, (source) =>\n\t    pipe(\n\t      comment.tags,\n\t      ReadonlyRecord.get(\"category\"),\n", "      Option.flatMap(ReadonlyArray.headNonEmpty),\n\t      Effect.asSome,\n\t      Effect.catchAll(() =>\n\t        ReadonlyRecord.has(comment.tags, \"category\")\n\t          ? Effect.fail(getMissingTagError(\"@category\", source.path, name))\n\t          : Effect.succeed(Option.none<string>())\n\t      )\n\t    ))\n\tconst getDescription = (name: string, comment: Comment) =>\n\t  pipe(\n", "    Effect.all([Config.Config, Source]),\n\t    Effect.flatMap(([config, source]) =>\n\t      pipe(\n\t        comment.description,\n\t        Option.match({\n\t          onNone: () =>\n\t            config.enforceDescriptions\n\t              ? Effect.fail(getMissingError(\"description\", source.path, name))\n\t              : Effect.succeed(Option.none()),\n\t          onSome: (description) => Effect.succeed(Option.some(description))\n", "        })\n\t      )\n\t    )\n\t  )\n\tconst getExamples = (name: string, comment: Comment, isModule: boolean) =>\n\t  pipe(\n\t    Effect.all([Config.Config, Source]),\n\t    Effect.flatMap(([config, source]) =>\n\t      pipe(\n\t        comment.tags,\n", "        ReadonlyRecord.get(\"example\"),\n\t        Option.map(ReadonlyArray.compact),\n\t        Option.match({\n\t          onNone: () =>\n\t            config.enforceExamples && !isModule\n\t              ? Effect.fail(getMissingTagError(\"@example\", source.path, name))\n\t              : Effect.succeed([]),\n\t          onSome: (examples) =>\n\t            config.enforceExamples &&\n\t              ReadonlyArray.isEmptyArray(examples) &&\n", "              !isModule\n\t              ? Effect.fail(getMissingTagError(\"@example\", source.path, name))\n\t              : Effect.succeed(examples)\n\t        })\n\t      )\n\t    )\n\t  )\n\t/**\n\t * @internal\n\t */\n", "export const getCommentInfo = (name: string, isModule = false) => (text: string) =>\n\t  pipe(\n\t    Effect.Do,\n\t    Effect.let(\"comment\", () => parseComment(text)),\n\t    Effect.bind(\"since\", ({ comment }) => getSinceTag(name, comment)),\n\t    Effect.bind(\"category\", ({ comment }) => getCategoryTag(name, comment)),\n\t    Effect.bind(\"description\", ({ comment }) => getDescription(name, comment)),\n\t    Effect.bind(\"examples\", ({ comment }) => getExamples(name, comment, isModule)),\n\t    Effect.bind(\"deprecated\", ({ comment }) =>\n\t      Effect.succeed(\n", "        pipe(comment.tags, ReadonlyRecord.get(\"deprecated\"), Option.isSome)\n\t      )),\n\t    Effect.map(({ category, deprecated, description, examples, since }) => {\n\t      return createCommentInfo(\n\t        description,\n\t        since,\n\t        deprecated,\n\t        examples,\n\t        category\n\t      )\n", "    })\n\t  )\n\t/**\n\t * @internal\n\t */\n\texport const parseComment = (text: string): Comment => {\n\t  const annotation: doctrine.Annotation = doctrine.parse(text, {\n\t    unwrap: true\n\t  })\n\t  const tags = pipe(\n", "    annotation.tags,\n\t    ReadonlyArray.groupBy((tag) => tag.title),\n\t    ReadonlyRecord.map(\n\t      ReadonlyArray.mapNonEmpty((tag) =>\n\t        pipe(\n\t          Option.fromNullable(tag.description),\n\t          Option.filter(isNonEmptyString)\n\t        )\n\t      )\n\t    )\n", "  )\n\t  const description = pipe(\n\t    Option.fromNullable(annotation.description),\n\t    Option.filter(isNonEmptyString)\n\t  )\n\t  return { description, tags }\n\t}\n\t// -------------------------------------------------------------------------------------\n\t// interfaces\n\t// -------------------------------------------------------------------------------------\n", "const parseInterfaceDeclaration = (id: ast.InterfaceDeclaration) =>\n\t  pipe(\n\t    getJSDocText(id.getJsDocs()),\n\t    getCommentInfo(id.getName()),\n\t    Effect.map((info) =>\n\t      Domain.createInterface(\n\t        Domain.createDocumentable(\n\t          id.getName(),\n\t          info.description,\n\t          info.since,\n", "          info.deprecated,\n\t          info.examples,\n\t          info.category\n\t        ),\n\t        id.getText()\n\t      )\n\t    )\n\t  )\n\t/**\n\t * @category parsers\n", " * @since 1.0.0\n\t */\n\texport const parseInterfaces = pipe(\n\t  Effect.map(Source, (source) =>\n\t    pipe(\n\t      source.sourceFile.getInterfaces(),\n\t      ReadonlyArray.filter(\n\t        every<ast.InterfaceDeclaration>([\n\t          (id) => id.isExported(),\n\t          (id) =>\n", "            pipe(\n\t              id.getJsDocs(),\n\t              Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n\t            )\n\t        ])\n\t      )\n\t    )),\n\t  Effect.flatMap((interfaceDeclarations) =>\n\t    pipe(\n\t      interfaceDeclarations,\n", "      Effect.validateAll(parseInterfaceDeclaration),\n\t      Effect.map(ReadonlyArray.sort(byName))\n\t    )\n\t  )\n\t)\n\t// -------------------------------------------------------------------------------------\n\t// functions\n\t// -------------------------------------------------------------------------------------\n\tconst getFunctionDeclarationSignature = (\n\t  f: ast.FunctionDeclaration\n", "): string => {\n\t  const text = f.getText()\n\t  return pipe(\n\t    Option.fromNullable(f.compilerNode.body),\n\t    Option.match({\n\t      onNone: () => text.replace(\"export function \", \"export declare function \"),\n\t      onSome: (body) => {\n\t        const end = body.getStart() - f.getStart() - 1\n\t        return text\n\t          .substring(0, end)\n", "          .replace(\"export function \", \"export declare function \")\n\t      }\n\t    })\n\t  )\n\t}\n\tconst getFunctionDeclarationJSDocs = (\n\t  fd: ast.FunctionDeclaration\n\t): Array<ast.JSDoc> =>\n\t  pipe(\n\t    fd.getOverloads(),\n", "    ReadonlyArray.matchLeft({\n\t      onEmpty: () => fd.getJsDocs(),\n\t      onNonEmpty: (firstOverload) => firstOverload.getJsDocs()\n\t    })\n\t  )\n\tconst parseFunctionDeclaration = (fd: ast.FunctionDeclaration) =>\n\t  pipe(\n\t    Effect.flatMap(Source, (source) =>\n\t      pipe(\n\t        Option.fromNullable(fd.getName()),\n", "        Option.flatMap(Option.liftPredicate((name) => name.length > 0)),\n\t        Effect.mapError(\n\t          () => `Missing function name in module ${source.path.join(\"/\")}`\n\t        )\n\t      )),\n\t    Effect.flatMap((name) =>\n\t      pipe(\n\t        getJSDocText(getFunctionDeclarationJSDocs(fd)),\n\t        getCommentInfo(name),\n\t        Effect.map((info) => {\n", "          const signatures = pipe(\n\t            fd.getOverloads(),\n\t            ReadonlyArray.matchRight({\n\t              onEmpty: () => [getFunctionDeclarationSignature(fd)],\n\t              onNonEmpty: (init, last) =>\n\t                pipe(\n\t                  init.map(getFunctionDeclarationSignature),\n\t                  ReadonlyArray.append(getFunctionDeclarationSignature(last))\n\t                )\n\t            })\n", "          )\n\t          return Domain.createFunction(\n\t            Domain.createDocumentable(\n\t              name,\n\t              info.description,\n\t              info.since,\n\t              info.deprecated,\n\t              info.examples,\n\t              info.category\n\t            ),\n", "            signatures\n\t          )\n\t        })\n\t      )\n\t    )\n\t  )\n\tconst parseFunctionVariableDeclaration = (vd: ast.VariableDeclaration) => {\n\t  const vs: any = vd.getParent().getParent()\n\t  const name = vd.getName()\n\t  return pipe(\n", "    getJSDocText(vs.getJsDocs()),\n\t    getCommentInfo(name),\n\t    Effect.map((info) => {\n\t      const signature = `export declare const ${name}: ${\n\t        stripImportTypes(\n\t          vd.getType().getText(vd)\n\t        )\n\t      }`\n\t      return Domain.createFunction(\n\t        Domain.createDocumentable(\n", "          name,\n\t          info.description,\n\t          info.since,\n\t          info.deprecated,\n\t          info.examples,\n\t          info.category\n\t        ),\n\t        [signature]\n\t      )\n\t    })\n", "  )\n\t}\n\tconst getFunctionDeclarations = pipe(\n\t  Effect.map(Source, (source) => ({\n\t    functions: pipe(\n\t      source.sourceFile.getFunctions(),\n\t      ReadonlyArray.filter(\n\t        every<ast.FunctionDeclaration>([\n\t          (fd) => fd.isExported(),\n\t          Predicate.not(\n", "            flow(\n\t              getFunctionDeclarationJSDocs,\n\t              getJSDocText,\n\t              parseComment,\n\t              shouldIgnore\n\t            )\n\t          )\n\t        ])\n\t      )\n\t    ),\n", "    arrows: pipe(\n\t      source.sourceFile.getVariableDeclarations(),\n\t      ReadonlyArray.filter(\n\t        every<ast.VariableDeclaration>([\n\t          (vd) => isVariableDeclarationList(vd.getParent()),\n\t          (vd) => isVariableStatement(vd.getParent().getParent() as any),\n\t          (vd) =>\n\t            pipe(\n\t              vd.getInitializer(),\n\t              every([\n", "                flow(\n\t                  Option.fromNullable,\n\t                  Option.flatMap(\n\t                    Option.liftPredicate(ast.Node.isFunctionLikeDeclaration)\n\t                  ),\n\t                  Option.isSome\n\t                ),\n\t                () =>\n\t                  pipe(\n\t                    (\n", "                      vd.getParent().getParent() as ast.VariableStatement\n\t                    ).getJsDocs(),\n\t                    Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n\t                  ),\n\t                () =>\n\t                  (\n\t                    vd.getParent().getParent() as ast.VariableStatement\n\t                  ).isExported()\n\t              ])\n\t            )\n", "        ])\n\t      )\n\t    )\n\t  }))\n\t)\n\t/**\n\t * @category parsers\n\t * @since 1.0.0\n\t */\n\texport const parseFunctions = pipe(\n", "  Effect.Do,\n\t  Effect.bind(\"getFunctionDeclarations\", () => getFunctionDeclarations),\n\t  Effect.bind(\"functionDeclarations\", ({ getFunctionDeclarations }) =>\n\t    pipe(\n\t      getFunctionDeclarations.functions,\n\t      Effect.validateAll(parseFunctionDeclaration)\n\t    )),\n\t  Effect.bind(\"variableDeclarations\", ({ getFunctionDeclarations }) =>\n\t    pipe(\n\t      getFunctionDeclarations.arrows,\n", "      Effect.validateAll(parseFunctionVariableDeclaration)\n\t    )),\n\t  Effect.map(({ functionDeclarations, variableDeclarations }) =>\n\t    functionDeclarations.concat(variableDeclarations)\n\t  )\n\t)\n\t// -------------------------------------------------------------------------------------\n\t// type aliases\n\t// -------------------------------------------------------------------------------------\n\tconst parseTypeAliasDeclaration = (ta: ast.TypeAliasDeclaration) =>\n", "  pipe(\n\t    Effect.succeed(ta.getName()),\n\t    Effect.flatMap((name) =>\n\t      pipe(\n\t        getJSDocText(ta.getJsDocs()),\n\t        getCommentInfo(name),\n\t        Effect.map((info) =>\n\t          Domain.createTypeAlias(\n\t            Domain.createDocumentable(\n\t              name,\n", "              info.description,\n\t              info.since,\n\t              info.deprecated,\n\t              info.examples,\n\t              info.category\n\t            ),\n\t            ta.getText()\n\t          )\n\t        )\n\t      )\n", "    )\n\t  )\n\t/**\n\t * @category parsers\n\t * @since 1.0.0\n\t */\n\texport const parseTypeAliases = pipe(\n\t  Effect.map(Source, (source) =>\n\t    pipe(\n\t      source.sourceFile.getTypeAliases(),\n", "      ReadonlyArray.filter(\n\t        every<ast.TypeAliasDeclaration>([\n\t          (alias) => alias.isExported(),\n\t          (alias) =>\n\t            pipe(\n\t              alias.getJsDocs(),\n\t              Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n\t            )\n\t        ])\n\t      )\n", "    )),\n\t  Effect.flatMap((typeAliasDeclarations) =>\n\t    pipe(typeAliasDeclarations, Effect.validateAll(parseTypeAliasDeclaration))\n\t  ),\n\t  Effect.map(ReadonlyArray.sort(byName))\n\t)\n\t// -------------------------------------------------------------------------------------\n\t// constants\n\t// -------------------------------------------------------------------------------------\n\tconst parseConstantVariableDeclaration = (vd: ast.VariableDeclaration) => {\n", "  const vs: any = vd.getParent().getParent()\n\t  const name = vd.getName()\n\t  return pipe(\n\t    getJSDocText(vs.getJsDocs()),\n\t    getCommentInfo(name),\n\t    Effect.map((info) => {\n\t      const type = stripImportTypes(vd.getType().getText(vd))\n\t      const signature = `export declare const ${name}: ${type}`\n\t      return Domain.createConstant(\n\t        Domain.createDocumentable(\n", "          name,\n\t          info.description,\n\t          info.since,\n\t          info.deprecated,\n\t          info.examples,\n\t          info.category\n\t        ),\n\t        signature\n\t      )\n\t    })\n", "  )\n\t}\n\t/**\n\t * @category parsers\n\t * @since 1.0.0\n\t */\n\texport const parseConstants = pipe(\n\t  Effect.map(Source, (source) =>\n\t    pipe(\n\t      source.sourceFile.getVariableDeclarations(),\n", "      ReadonlyArray.filter(\n\t        every<ast.VariableDeclaration>([\n\t          (vd) => isVariableDeclarationList(vd.getParent()),\n\t          (vd) => isVariableStatement(vd.getParent().getParent() as any),\n\t          (vd) =>\n\t            pipe(\n\t              vd.getInitializer(),\n\t              every([\n\t                flow(\n\t                  Option.fromNullable,\n", "                  Option.flatMap(\n\t                    Option.liftPredicate(\n\t                      Predicate.not(ast.Node.isFunctionLikeDeclaration)\n\t                    )\n\t                  ),\n\t                  Option.isSome\n\t                ),\n\t                () =>\n\t                  pipe(\n\t                    (\n", "                      vd.getParent().getParent() as ast.VariableStatement\n\t                    ).getJsDocs(),\n\t                    Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n\t                  ),\n\t                () =>\n\t                  (\n\t                    vd.getParent().getParent() as ast.VariableStatement\n\t                  ).isExported()\n\t              ])\n\t            )\n", "        ])\n\t      )\n\t    )),\n\t  Effect.flatMap((variableDeclarations) =>\n\t    pipe(\n\t      variableDeclarations,\n\t      Effect.validateAll(parseConstantVariableDeclaration)\n\t    )\n\t  )\n\t)\n", "// -------------------------------------------------------------------------------------\n\t// exports\n\t// -------------------------------------------------------------------------------------\n\tconst parseExportSpecifier = (es: ast.ExportSpecifier) =>\n\t  Effect.flatMap(Source, (source) =>\n\t    pipe(\n\t      Effect.Do,\n\t      Effect.bind(\"name\", () => Effect.succeed(es.compilerNode.name.text)),\n\t      Effect.bind(\"type\", () => Effect.succeed(stripImportTypes(es.getType().getText(es)))),\n\t      Effect.bind(\n", "        \"signature\",\n\t        ({ name, type }) => Effect.succeed(`export declare const ${name}: ${type}`)\n\t      ),\n\t      Effect.flatMap(({ name, signature }) =>\n\t        pipe(\n\t          es.getLeadingCommentRanges(),\n\t          ReadonlyArray.head,\n\t          Effect.mapError(\n\t            () => `Missing ${name} documentation in ${source.path.join(\"/\")}`\n\t          ),\n", "          Effect.flatMap((commentRange) => pipe(commentRange.getText(), getCommentInfo(name))),\n\t          Effect.map((info) =>\n\t            Domain.createExport(\n\t              Domain.createDocumentable(\n\t                name,\n\t                info.description,\n\t                info.since,\n\t                info.deprecated,\n\t                info.examples,\n\t                info.category\n", "              ),\n\t              signature\n\t            )\n\t          )\n\t        )\n\t      )\n\t    ))\n\tconst parseExportDeclaration = (ed: ast.ExportDeclaration) =>\n\t  pipe(ed.getNamedExports(), Effect.validateAll(parseExportSpecifier))\n\t/**\n", " * @category parsers\n\t * @since 1.0.0\n\t */\n\texport const parseExports = pipe(\n\t  Effect.map(Source, (source) => source.sourceFile.getExportDeclarations()),\n\t  Effect.flatMap((exportDeclarations) =>\n\t    pipe(exportDeclarations, Effect.validateAll(parseExportDeclaration))\n\t  ),\n\t  Effect.mapBoth({\n\t    onFailure: ReadonlyArray.flatten,\n", "    onSuccess: ReadonlyArray.flatten\n\t  })\n\t)\n\t// -------------------------------------------------------------------------------------\n\t// classes\n\t// -------------------------------------------------------------------------------------\n\tconst getTypeParameters = (\n\t  tps: ReadonlyArray<ast.TypeParameterDeclaration>\n\t): string => tps.length === 0 ? \"\" : `<${tps.map((p) => p.getName()).join(\", \")}>`\n\tconst getMethodSignature = (md: ast.MethodDeclaration): string =>\n", "  pipe(\n\t    Option.fromNullable(md.compilerNode.body),\n\t    Option.match({\n\t      onNone: () => md.getText(),\n\t      onSome: (body) => {\n\t        const end = body.getStart() - md.getStart() - 1\n\t        return md.getText().substring(0, end)\n\t      }\n\t    })\n\t  )\n", "const parseMethod = (md: ast.MethodDeclaration) =>\n\t  pipe(\n\t    Effect.Do,\n\t    Effect.bind(\"name\", () => Effect.succeed(md.getName())),\n\t    Effect.bind(\"overloads\", () => Effect.succeed(md.getOverloads())),\n\t    Effect.bind(\"jsdocs\", ({ overloads }) =>\n\t      Effect.succeed(\n\t        pipe(\n\t          overloads,\n\t          ReadonlyArray.matchLeft({\n", "            onEmpty: () => md.getJsDocs(),\n\t            onNonEmpty: (x) => x.getJsDocs()\n\t          })\n\t        )\n\t      )),\n\t    Effect.flatMap(({ jsdocs, name, overloads }) =>\n\t      shouldIgnore(parseComment(getJSDocText(jsdocs)))\n\t        ? Effect.succeed(Option.none())\n\t        : pipe(\n\t          getJSDocText(jsdocs),\n", "          getCommentInfo(name),\n\t          Effect.map((info) => {\n\t            const signatures = pipe(\n\t              overloads,\n\t              ReadonlyArray.matchRight({\n\t                onEmpty: () => [getMethodSignature(md)],\n\t                onNonEmpty: (init, last) =>\n\t                  pipe(\n\t                    init.map((md) => md.getText()),\n\t                    ReadonlyArray.append(getMethodSignature(last))\n", "                  )\n\t              })\n\t            )\n\t            return Option.some(\n\t              Domain.createMethod(\n\t                Domain.createDocumentable(\n\t                  name,\n\t                  info.description,\n\t                  info.since,\n\t                  info.deprecated,\n", "                  info.examples,\n\t                  info.category\n\t                ),\n\t                signatures\n\t              )\n\t            )\n\t          })\n\t        )\n\t    )\n\t  )\n", "const parseProperty = (classname: string) => (pd: ast.PropertyDeclaration) => {\n\t  const name = pd.getName()\n\t  return pipe(\n\t    getJSDocText(pd.getJsDocs()),\n\t    getCommentInfo(`${classname}#${name}`),\n\t    Effect.map((info) => {\n\t      const type = stripImportTypes(pd.getType().getText(pd))\n\t      const readonly = pipe(\n\t        Option.fromNullable(\n\t          pd.getFirstModifierByKind(ast.ts.SyntaxKind.ReadonlyKeyword)\n", "        ),\n\t        Option.match({\n\t          onNone: () => \"\",\n\t          onSome: () => \"readonly \"\n\t        })\n\t      )\n\t      const signature = `${readonly}${name}: ${type}`\n\t      return Domain.createProperty(\n\t        Domain.createDocumentable(\n\t          name,\n", "          info.description,\n\t          info.since,\n\t          info.deprecated,\n\t          info.examples,\n\t          info.category\n\t        ),\n\t        signature\n\t      )\n\t    })\n\t  )\n", "}\n\tconst parseProperties = (name: string, c: ast.ClassDeclaration) =>\n\t  pipe(\n\t    c.getProperties(),\n\t    ReadonlyArray.filter(\n\t      every<ast.PropertyDeclaration>([\n\t        (prop) => !prop.isStatic(),\n\t        (prop) =>\n\t          pipe(\n\t            prop.getFirstModifierByKind(ast.ts.SyntaxKind.PrivateKeyword),\n", "            Option.fromNullable,\n\t            Option.isNone\n\t          ),\n\t        (prop) =>\n\t          pipe(\n\t            prop.getJsDocs(),\n\t            Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n\t          )\n\t      ])\n\t    ),\n", "    (propertyDeclarations) => pipe(propertyDeclarations, Effect.validateAll(parseProperty(name)))\n\t  )\n\t/**\n\t * @internal\n\t */\n\texport const getConstructorDeclarationSignature = (\n\t  c: ast.ConstructorDeclaration\n\t): string =>\n\t  pipe(\n\t    Option.fromNullable(c.compilerNode.body),\n", "    Option.match({\n\t      onNone: () => c.getText(),\n\t      onSome: (body) => {\n\t        const end = body.getStart() - c.getStart() - 1\n\t        return c.getText().substring(0, end)\n\t      }\n\t    })\n\t  )\n\tconst getClassName = (c: ast.ClassDeclaration) =>\n\t  Effect.flatMap(Source, (source) =>\n", "    Effect.mapError(\n\t      Option.fromNullable(c.getName()),\n\t      () => `Missing class name in module ${source.path.join(\"/\")}`\n\t    ))\n\tconst getClassCommentInfo = (name: string, c: ast.ClassDeclaration) =>\n\t  pipe(c.getJsDocs(), getJSDocText, getCommentInfo(name))\n\tconst getClassDeclarationSignature = (name: string, c: ast.ClassDeclaration) =>\n\t  pipe(\n\t    Effect.succeed(getTypeParameters(c.getTypeParameters())),\n\t    Effect.map((typeParameters) =>\n", "      pipe(\n\t        c.getConstructors(),\n\t        ReadonlyArray.matchLeft({\n\t          onEmpty: () => `export declare class ${name}${typeParameters}`,\n\t          onNonEmpty: (head) =>\n\t            `export declare class ${name}${typeParameters} { ${\n\t              getConstructorDeclarationSignature(\n\t                head\n\t              )\n\t            } }`\n", "        })\n\t      )\n\t    )\n\t  )\n\tconst parseClass = (c: ast.ClassDeclaration) =>\n\t  pipe(\n\t    Effect.Do,\n\t    Effect.bind(\"name\", () => Effect.mapError(getClassName(c), (e) => [e])),\n\t    Effect.bind(\"info\", ({ name }) => Effect.mapError(getClassCommentInfo(name, c), (e) => [e])),\n\t    Effect.bind(\"signature\", ({ name }) => getClassDeclarationSignature(name, c)),\n", "    Effect.bind(\"methods\", () =>\n\t      pipe(\n\t        c.getInstanceMethods(),\n\t        Effect.validateAll(parseMethod),\n\t        Effect.map(ReadonlyArray.compact)\n\t      )),\n\t    Effect.bind(\"staticMethods\", () =>\n\t      pipe(\n\t        c.getStaticMethods(),\n\t        Effect.validateAll(parseMethod),\n", "        Effect.map(ReadonlyArray.compact)\n\t      )),\n\t    Effect.bind(\"properties\", ({ name }) => parseProperties(name, c)),\n\t    Effect.map(\n\t      ({ info, methods, name, properties, signature, staticMethods }) =>\n\t        Domain.createClass(\n\t          Domain.createDocumentable(\n\t            name,\n\t            info.description,\n\t            info.since,\n", "            info.deprecated,\n\t            info.examples,\n\t            info.category\n\t          ),\n\t          signature,\n\t          methods,\n\t          staticMethods,\n\t          properties\n\t        )\n\t    )\n", "  )\n\t/**\n\t * @category parsers\n\t * @since 1.0.0\n\t */\n\texport const parseClasses = pipe(\n\t  Effect.map(Source, (source) =>\n\t    pipe(\n\t      source.sourceFile.getClasses(),\n\t      ReadonlyArray.filter(every<ast.ClassDeclaration>([\n", "        (id) => id.isExported(),\n\t        (id) =>\n\t          pipe(\n\t            id.getJsDocs(),\n\t            Predicate.not(flow(getJSDocText, parseComment, shouldIgnore))\n\t          )\n\t      ]))\n\t    )),\n\t  Effect.flatMap((classDeclarations) =>\n\t    pipe(\n", "      classDeclarations,\n\t      Effect.validateAll(parseClass),\n\t      Effect.mapBoth({\n\t        onFailure: ReadonlyArray.flatten,\n\t        onSuccess: ReadonlyArray.sort(byName)\n\t      })\n\t    )\n\t  )\n\t)\n\t// -------------------------------------------------------------------------------------\n", "// modules\n\t// -------------------------------------------------------------------------------------\n\tconst getModuleName = (\n\t  path: ReadonlyArray.NonEmptyReadonlyArray<string>\n\t): string => NodePath.parse(ReadonlyArray.lastNonEmpty(path)).name\n\t/**\n\t * @internal\n\t */\n\texport const parseModuleDocumentation = pipe(\n\t  Effect.all([Config.Config, Source]),\n", "  Effect.flatMap(([config, source]) => {\n\t    const name = getModuleName(source.path)\n\t    // if any of the settings enforcing documentation are set to `true`, then\n\t    // a module should have associated documentation\n\t    const isDocumentationRequired = config.enforceDescriptions || config.enforceVersion\n\t    const onMissingDocumentation = () =>\n\t      isDocumentationRequired\n\t        ? Effect.fail(\n\t          `Missing documentation in ${source.path.join(\"/\")} module`\n\t        )\n", "        : Effect.succeed(\n\t          Domain.createDocumentable(\n\t            name,\n\t            Option.none(),\n\t            Option.none(),\n\t            false,\n\t            [],\n\t            Option.none()\n\t          )\n\t        )\n", "    return ReadonlyArray.matchLeft(source.sourceFile.getStatements(), {\n\t      onEmpty: onMissingDocumentation,\n\t      onNonEmpty: (statement) =>\n\t        ReadonlyArray.matchLeft(statement.getLeadingCommentRanges(), {\n\t          onEmpty: onMissingDocumentation,\n\t          onNonEmpty: (commentRange) =>\n\t            pipe(\n\t              getCommentInfo(name, true)(commentRange.getText()),\n\t              Effect.map((info) =>\n\t                Domain.createDocumentable(\n", "                  name,\n\t                  info.description,\n\t                  info.since,\n\t                  info.deprecated,\n\t                  info.examples,\n\t                  info.category\n\t                )\n\t              )\n\t            )\n\t        })\n", "    })\n\t  })\n\t)\n\t/**\n\t * @category parsers\n\t * @since 1.0.0\n\t */\n\texport const parseModule = pipe(\n\t  Effect.flatMap(Source, (source) =>\n\t    pipe(\n", "      Effect.Do,\n\t      Effect.bind(\"documentation\", () => Effect.mapError(parseModuleDocumentation, (e) => [e])),\n\t      Effect.bind(\"interfaces\", () => parseInterfaces),\n\t      Effect.bind(\"functions\", () => parseFunctions),\n\t      Effect.bind(\"typeAliases\", () => parseTypeAliases),\n\t      Effect.bind(\"classes\", () => parseClasses),\n\t      Effect.bind(\"constants\", () => parseConstants),\n\t      Effect.bind(\"exports\", () => parseExports),\n\t      Effect.map(\n\t        ({\n", "          classes,\n\t          constants,\n\t          documentation,\n\t          exports,\n\t          functions,\n\t          interfaces,\n\t          typeAliases\n\t        }) =>\n\t          Domain.createModule(\n\t            documentation,\n", "            source.path,\n\t            classes,\n\t            interfaces,\n\t            functions,\n\t            typeAliases,\n\t            constants,\n\t            exports\n\t          )\n\t      )\n\t    ))\n", ")\n\t/**\n\t * @internal\n\t */\n\texport const parseFile = (project: ast.Project) =>\n\t(\n\t  file: FileSystem.File\n\t): Effect.Effect<Config.Config, Array<string>, Domain.Module> => {\n\t  const path = file.path.split(\n\t    NodePath.sep\n", "  ) as any as ReadonlyArray.NonEmptyReadonlyArray<string>\n\t  const sourceFile = project.getSourceFile(file.path)\n\t  if (sourceFile !== undefined) {\n\t    return pipe(\n\t      parseModule,\n\t      Effect.provideService(Source, { path, sourceFile })\n\t    )\n\t  }\n\t  return Effect.fail([`Unable to locate file: ${file.path}`])\n\t}\n", "const createProject = (files: ReadonlyArray<FileSystem.File>) =>\n\t  pipe(\n\t    Config.Config,\n\t    Effect.map((config) => {\n\t      const options: ast.ProjectOptions = {\n\t        compilerOptions: {\n\t          strict: true,\n\t          ...config.parseCompilerOptions\n\t        }\n\t      }\n", "      const project = new ast.Project(options)\n\t      for (const file of files) {\n\t        project.addSourceFileAtPath(file.path)\n\t      }\n\t      return project\n\t    })\n\t  )\n\t/**\n\t * @category parsers\n\t * @since 1.0.0\n", " */\n\texport const parseFiles = (files: ReadonlyArray<FileSystem.File>) =>\n\t  pipe(\n\t    createProject(files),\n\t    Effect.flatMap((project) =>\n\t      pipe(\n\t        files,\n\t        Effect.validateAll(parseFile(project)),\n\t        Effect.map(\n\t          flow(\n", "            ReadonlyArray.filter((module) => !module.deprecated),\n\t            sortModules\n\t          )\n\t        )\n\t      )\n\t    )\n\t  )\n"]}
{"filename": "src/bin.ts", "chunked_list": ["#!/usr/bin/env node\n\t/**\n\t * CLI\n\t *\n\t * @since 1.0.0\n\t */\n\timport chalk from \"chalk\"\n\timport { Effect } from \"effect\"\n\timport { main } from \"./index\"\n\tEffect.runPromise(main).catch((defect) => {\n", "  console.error(chalk.bold.red(\"Unexpected Error\"))\n\t  console.error(defect)\n\t  process.exit(1)\n\t})\n"]}
{"filename": "src/Core.ts", "chunked_list": ["/**\n\t * @since 1.0.0\n\t */\n\timport chalk from \"chalk\"\n\timport { Data, Effect, Layer, Logger, LoggerLevel, pipe, ReadonlyArray, String } from \"effect\"\n\timport * as NodePath from \"path\"\n\timport * as ChildProcess from \"./ChildProcess\"\n\timport * as Config from \"./Config\"\n\timport type * as Domain from \"./Domain\"\n\timport * as FileSystem from \"./FileSystem\"\n", "import { SimpleLogger } from \"./Logger\"\n\timport { printModule } from \"./Markdown\"\n\timport * as Parser from \"./Parser\"\n\timport * as Process from \"./Process\"\n\t// -------------------------------------------------------------------------------------\n\t// readFiles\n\t// -------------------------------------------------------------------------------------\n\tconst join = (...paths: Array<string>): string => NodePath.normalize(NodePath.join(...paths))\n\tconst readFiles = Effect.all([Config.Config, FileSystem.FileSystem]).pipe(\n\t  Effect.flatMap(([config, fileSystem]) =>\n", "    fileSystem.glob(join(config.srcDir, \"**\", \"*.ts\"), config.exclude).pipe(\n\t      Effect.tap((paths) => Effect.logInfo(chalk.bold(`${paths.length} module(s) found`))),\n\t      Effect.flatMap(\n\t        Effect.forEach((path) =>\n\t          Effect.map(\n\t            fileSystem.readFile(path),\n\t            (content) => FileSystem.makeFile(path, content, false)\n\t          ), { concurrency: \"inherit\" })\n\t      )\n\t    )\n", "  )\n\t)\n\tconst writeFile = (\n\t  file: FileSystem.File\n\t): Effect.Effect<\n\t  Config.Config | FileSystem.FileSystem | Process.Process,\n\t  FileSystem.ReadFileError | FileSystem.WriteFileError,\n\t  void\n\t> =>\n\t  Effect.all([Config.Config, FileSystem.FileSystem, Process.Process]).pipe(\n", "    Effect.flatMap(([config, fileSystem, process]) =>\n\t      process.cwd.pipe(\n\t        Effect.map((cwd) => NodePath.relative(NodePath.join(cwd, config.outDir), file.path)),\n\t        Effect.flatMap((fileName) => {\n\t          const overwrite = Effect.flatMap(\n\t            Effect.logDebug(`overwriting file ${chalk.black(fileName)}`),\n\t            () => fileSystem.writeFile(file.path, file.content)\n\t          )\n\t          const skip = Effect.logDebug(\n\t            `file ${chalk.black(fileName)} already exists, skipping creation`\n", "          )\n\t          const write = fileSystem.writeFile(file.path, file.content)\n\t          return Effect.if(fileSystem.pathExists(file.path), {\n\t            onTrue: file.overwrite ? overwrite : skip,\n\t            onFalse: write\n\t          })\n\t        })\n\t      )\n\t    )\n\t  )\n", "// -------------------------------------------------------------------------------------\n\t// parse\n\t// -------------------------------------------------------------------------------------\n\t/**\n\t * Represents errors that occurred during parsing of TypeScript source files.\n\t *\n\t * @category model\n\t * @since 1.0.0\n\t */\n\texport interface ParseError extends Data.Case {\n", "  readonly _tag: \"ParseError\"\n\t  readonly message: string\n\t}\n\t/**\n\t * @category constructors\n\t * @since 1.0.0\n\t */\n\texport const ParseError = Data.tagged<ParseError>(\"ParseError\")\n\tconst getModules = (files: ReadonlyArray<FileSystem.File>) =>\n\t  Parser.parseFiles(files).pipe(\n", "    Effect.mapError((errors) =>\n\t      ParseError({\n\t        message: errors\n\t          .map((errors) => errors.join(\"\\n\"))\n\t          .join(\"\\n\")\n\t      })\n\t    )\n\t  )\n\t// -------------------------------------------------------------------------------------\n\t// typeCheckExamples\n", "// -------------------------------------------------------------------------------------\n\tconst typeCheckExamples = (modules: ReadonlyArray<Domain.Module>) =>\n\t  getExampleFiles(modules)\n\t    .pipe(\n\t      Effect.flatMap(handleImports),\n\t      Effect.flatMap((examples) =>\n\t        examples.length === 0\n\t          ? cleanExamples\n\t          : writeExamples(examples).pipe(\n\t            Effect.zipRight(writeTsConfigJson),\n", "            Effect.zipRight(spawnTsNode),\n\t            Effect.zipRight(cleanExamples)\n\t          )\n\t      )\n\t    )\n\tconst getExampleFiles = (modules: ReadonlyArray<Domain.Module>) =>\n\t  Effect.map(Config.Config, (config) =>\n\t    ReadonlyArray.flatMap(modules, (module) => {\n\t      const prefix = module.path.join(\"-\")\n\t      const getDocumentableExamples = (id: string) =>\n", "      (\n\t        documentable: Domain.Documentable\n\t      ): ReadonlyArray<FileSystem.File> =>\n\t        ReadonlyArray.map(\n\t          documentable.examples,\n\t          (content, i) =>\n\t            FileSystem.makeFile(\n\t              join(\n\t                config.outDir,\n\t                \"examples\",\n", "                `${prefix}-${id}-${documentable.name}-${i}.ts`\n\t              ),\n\t              `${content}\\n`,\n\t              true\n\t            )\n\t        )\n\t      const moduleExamples = getDocumentableExamples(\"module\")(module)\n\t      const methods = ReadonlyArray.flatMap(module.classes, (c) =>\n\t        ReadonlyArray.flatten([\n\t          ReadonlyArray.flatMap(\n", "            c.methods,\n\t            getDocumentableExamples(`${c.name}-method`)\n\t          ),\n\t          ReadonlyArray.flatMap(\n\t            c.staticMethods,\n\t            getDocumentableExamples(`${c.name}-staticmethod`)\n\t          )\n\t        ]))\n\t      const interfaces = ReadonlyArray.flatMap(\n\t        module.interfaces,\n", "        getDocumentableExamples(\"interface\")\n\t      )\n\t      const typeAliases = ReadonlyArray.flatMap(\n\t        module.typeAliases,\n\t        getDocumentableExamples(\"typealias\")\n\t      )\n\t      const constants = ReadonlyArray.flatMap(\n\t        module.constants,\n\t        getDocumentableExamples(\"constant\")\n\t      )\n", "      const functions = ReadonlyArray.flatMap(\n\t        module.functions,\n\t        getDocumentableExamples(\"function\")\n\t      )\n\t      return ReadonlyArray.flatten([\n\t        moduleExamples,\n\t        methods,\n\t        interfaces,\n\t        typeAliases,\n\t        constants,\n", "        functions\n\t      ])\n\t    }))\n\tconst addAssertImport = (code: string): string =>\n\t  code.indexOf(\"assert.\") !== -1\n\t    ? `import * as assert from 'assert'\\n${code}`\n\t    : code\n\tconst replaceProjectName = (source: string) =>\n\t  Effect.map(Config.Config, (config) => {\n\t    const importRegex = (projectName: string) =>\n", "      new RegExp(\n\t        `from (?<quote>['\"])${projectName}(?:/lib)?(?:/(?<path>.*))?\\\\k<quote>`,\n\t        \"g\"\n\t      )\n\t    const out = source.replace(importRegex(config.projectName), (...args) => {\n\t      const groups: { path?: string } = args[args.length - 1]\n\t      return `from '../../src${groups.path ? `/${groups.path}` : \"\"}'`\n\t    })\n\t    return out\n\t  })\n", "const handleImports = (files: ReadonlyArray<FileSystem.File>) =>\n\t  Effect.forEach(files, (file) =>\n\t    replaceProjectName(file.content).pipe(\n\t      Effect.map(addAssertImport),\n\t      Effect.map((content) => FileSystem.makeFile(file.path, content, file.overwrite))\n\t    ))\n\tconst getExampleIndex = (examples: ReadonlyArray<FileSystem.File>) => {\n\t  const content = pipe(\n\t    examples,\n\t    ReadonlyArray.map(\n", "      (example) => `import './${NodePath.basename(example.path, \".ts\")}'`\n\t    ),\n\t    ReadonlyArray.join(\"\\n\")\n\t  )\n\t  return Effect.map(Config.Config, (config) =>\n\t    FileSystem.makeFile(\n\t      join(config.outDir, \"examples\", \"index.ts\"),\n\t      `${content}\\n`,\n\t      true\n\t    ))\n", "}\n\tconst cleanExamples = Effect.flatMap(\n\t  Effect.all([Config.Config, FileSystem.FileSystem]),\n\t  ([config, fileSystem]) => fileSystem.removeFile(join(config.outDir, \"examples\"))\n\t)\n\tconst spawnTsNode = Effect.logDebug(\"Type checking examples...\").pipe(\n\t  Effect.flatMap(() => Effect.all([ChildProcess.ChildProcess, Config.Config, Process.Process])),\n\t  Effect.flatMap(([childProcess, config, process]) =>\n\t    Effect.all([process.cwd, process.platform]).pipe(\n\t      Effect.flatMap(([cwd, platform]) => {\n", "        const command = platform === \"win32\" ? \"ts-node.cmd\" : \"ts-node\"\n\t        const executable = join(cwd, config.outDir, \"examples\", \"index.ts\")\n\t        return childProcess.spawn(command, executable)\n\t      })\n\t    )\n\t  )\n\t)\n\tconst writeFiles = (\n\t  files: ReadonlyArray<FileSystem.File>\n\t) => Effect.forEach(files, writeFile, { discard: true })\n", "const writeExamples = (examples: ReadonlyArray<FileSystem.File>) =>\n\t  Effect.logDebug(\"Writing examples...\").pipe(\n\t    Effect.flatMap(() => getExampleIndex(examples)),\n\t    Effect.map((index) => pipe(examples, ReadonlyArray.prepend(index))),\n\t    Effect.flatMap(writeFiles)\n\t  )\n\tconst writeTsConfigJson = Effect.logDebug(\"Writing examples tsconfig...\").pipe(\n\t  Effect.flatMap(() => Effect.all([Config.Config, Process.Process])),\n\t  Effect.flatMap(([config, process]) =>\n\t    process.cwd.pipe(\n", "      Effect.flatMap((cwd) =>\n\t        writeFile(\n\t          FileSystem.makeFile(\n\t            join(cwd, config.outDir, \"examples\", \"tsconfig.json\"),\n\t            JSON.stringify({ compilerOptions: config.examplesCompilerOptions }, null, 2),\n\t            true\n\t          )\n\t        )\n\t      )\n\t    )\n", "  )\n\t)\n\t// -------------------------------------------------------------------------------------\n\t// getMarkdown\n\t// -------------------------------------------------------------------------------------\n\tconst getMarkdown = (modules: ReadonlyArray<Domain.Module>) =>\n\t  Effect.Do.pipe(\n\t    Effect.bind(\"home\", () => getHome),\n\t    Effect.bind(\"index\", () => getModulesIndex),\n\t    Effect.bind(\"yml\", () => getConfigYML),\n", "    Effect.flatMap(({ home, index, yml }) =>\n\t      pipe(\n\t        getModuleMarkdownFiles(modules),\n\t        Effect.map((files) => [home, index, yml].concat(files))\n\t      )\n\t    )\n\t  )\n\tconst getHome = Effect.all([Config.Config, Process.Process]).pipe(\n\t  Effect.flatMap(([config, process]) =>\n\t    process.cwd.pipe(\n", "      Effect.map((cwd) =>\n\t        FileSystem.makeFile(\n\t          join(cwd, config.outDir, \"index.md\"),\n\t          String.stripMargin(\n\t            `|---\n\t             |title: Home\n\t             |nav_order: 1\n\t             |---\n\t             |`\n\t          ),\n", "          false\n\t        )\n\t      )\n\t    )\n\t  )\n\t)\n\tconst getModulesIndex = Effect.all([Config.Config, Process.Process]).pipe(\n\t  Effect.flatMap(([config, process]) =>\n\t    process.cwd\n\t      .pipe(\n", "        Effect.map((cwd) =>\n\t          FileSystem.makeFile(\n\t            join(cwd, config.outDir, \"modules\", \"index.md\"),\n\t            String.stripMargin(\n\t              `|---\n\t             |title: Modules\n\t             |has_children: true\n\t             |permalink: /docs/modules\n\t             |nav_order: 2\n\t             |---\n", "             |`\n\t            ),\n\t            false\n\t          )\n\t        )\n\t      )\n\t  )\n\t)\n\tconst replace = (\n\t  searchValue: string | RegExp,\n", "  replaceValue: string\n\t): (s: string) => string =>\n\t(s) => s.replace(searchValue, replaceValue)\n\tconst resolveConfigYML = (\n\t  previousContent: string,\n\t  config: Config.Config\n\t): string =>\n\t  pipe(\n\t    previousContent,\n\t    replace(/^remote_theme:.*$/m, `remote_theme: ${config.theme}`),\n", "    replace(/^search_enabled:.*$/m, `search_enabled: ${config.enableSearch}`),\n\t    replace(\n\t      /^ {2}'\\S* on GitHub':\\n {4}- '.*'/m,\n\t      `  '${config.projectName} on GitHub':\\n    - '${config.projectHomepage}'`\n\t    )\n\t  )\n\tconst getHomepageNavigationHeader = (config: Config.Config): string => {\n\t  const isGitHub = config.projectHomepage.toLowerCase().includes(\"github\")\n\t  return isGitHub ? config.projectName + \" on GitHub\" : \"Homepage\"\n\t}\n", "const getConfigYML = Effect.all([Config.Config, FileSystem.FileSystem, Process.Process]).pipe(\n\t  Effect.flatMap(([config, fileSystem, process]) =>\n\t    Effect.flatMap(process.cwd, (cwd) => {\n\t      const filePath = join(cwd, config.outDir, \"_config.yml\")\n\t      return fileSystem.pathExists(filePath).pipe(\n\t        Effect.flatMap((exists) =>\n\t          exists\n\t            ? Effect.map(\n\t              fileSystem.readFile(filePath),\n\t              (content) =>\n", "                FileSystem.makeFile(\n\t                  filePath,\n\t                  resolveConfigYML(content, config),\n\t                  true\n\t                )\n\t            )\n\t            : Effect.succeed(\n\t              FileSystem.makeFile(\n\t                filePath,\n\t                String.stripMargin(\n", "                  `|remote_theme: ${config.theme}\n\t                   |\n\t                   |# Enable or disable the site search\n\t                   |search_enabled: ${config.enableSearch}\n\t                   |\n\t                   |# Aux links for the upper right navigation\n\t                   |aux_links:\n\t                   |'${getHomepageNavigationHeader(config)}':\n\t                   |  - '${config.projectHomepage}'`\n\t                ),\n", "                false\n\t              )\n\t            )\n\t        )\n\t      )\n\t    })\n\t  )\n\t)\n\tconst getMarkdownOutputPath = (module: Domain.Module) =>\n\t  Effect.map(Config.Config, (config) =>\n", "    join(\n\t      config.outDir,\n\t      \"modules\",\n\t      `${module.path.slice(1).join(NodePath.sep)}.md`\n\t    ))\n\tconst getModuleMarkdownFiles = (modules: ReadonlyArray<Domain.Module>) =>\n\t  Effect.forEach(modules, (module, order) =>\n\t    Effect.Do\n\t      .pipe(\n\t        Effect.bind(\"outputPath\", () => getMarkdownOutputPath(module)),\n", "        Effect.bind(\"content\", () => Effect.succeed(printModule(module, order + 1))),\n\t        Effect.map(({ content, outputPath }) => FileSystem.makeFile(outputPath, content, true))\n\t      ))\n\t// -------------------------------------------------------------------------------------\n\t// writeMarkdown\n\t// -------------------------------------------------------------------------------------\n\tconst writeMarkdown = (files: ReadonlyArray<FileSystem.File>) =>\n\t  Effect.map(Config.Config, (config) => join(config.outDir, \"**/*.ts.md\")).pipe(\n\t    Effect.tap((pattern) => Effect.logDebug(`deleting ${chalk.black(pattern)}`)),\n\t    Effect.flatMap((pattern) =>\n", "      Effect.flatMap(FileSystem.FileSystem, (fileSystem) => fileSystem.removeFile(pattern))\n\t    ),\n\t    Effect.flatMap(() => writeFiles(files))\n\t  )\n\tconst MainLayer = Logger.replace(Logger.defaultLogger, SimpleLogger).pipe(\n\t  Layer.merge(ChildProcess.ChildProcessLive),\n\t  Layer.merge(FileSystem.FileSystemLive),\n\t  Layer.merge(Process.ProcessLive),\n\t  Layer.provideMerge(Config.ConfigLive)\n\t)\n", "/**\n\t * @category main\n\t * @since 1.0.0\n\t */\n\texport const main: Effect.Effect<never, never, void> = Effect.logInfo(\"reading modules...\").pipe(\n\t  Effect.zipRight(readFiles),\n\t  Effect.zipLeft(Effect.logInfo(\"parsing modules...\")),\n\t  Effect.flatMap(getModules),\n\t  Effect.zipLeft(Effect.logInfo(\"typechecking examples...\")),\n\t  Effect.tap(typeCheckExamples),\n", "  Effect.zipLeft(Effect.logInfo(\"creating markdown files...\")),\n\t  Effect.flatMap(getMarkdown),\n\t  Effect.zipLeft(Effect.logInfo(\"writing markdown files...\")),\n\t  Effect.flatMap(writeMarkdown),\n\t  Effect.zipLeft(Effect.logInfo(chalk.bold.green(\"Docs generation succeeded!\"))),\n\t  Logger.withMinimumLogLevel(LoggerLevel.Debug),\n\t  Effect.provideLayer(MainLayer),\n\t  Effect.catchTags({\n\t    // Configuration errors\n\t    ConfigError: ({ message }) => Effect.dieMessage(message),\n", "    // File system errors\n\t    ReadFileError: ({ path }) => Effect.dieMessage(`Unable to read file from: '${path}'`),\n\t    WriteFileError: ({ path }) => Effect.dieMessage(`Unable to write file to: '${path}'`),\n\t    RemoveFileError: ({ path }) => Effect.dieMessage(`Unable to remove file from: '${path}'`),\n\t    GlobError: ({ exclude, pattern }) =>\n\t      Effect.dieMessage(\n\t        `Unable to execute glob pattern '${pattern}' excluding files matching '${exclude}'`\n\t      ),\n\t    // Child process errors\n\t    ExecutionError: ({ command, stderr }) =>\n", "      Effect.dieMessage(\n\t        `During execution of '${command}', the following error occurred:\\n${stderr}`\n\t      ),\n\t    SpawnError: ({ args, command, error }) =>\n\t      Effect.dieMessage(\n\t        `Unable to spawn child process for command: '${command} ${args.join(\" \")}'\\n${error}`\n\t      ),\n\t    // Parsing errors\n\t    ParseJsonError: ({ content }) => Effect.dieMessage(`Unable to parse JSON: ${content}`),\n\t    ParseError: ({ message }) =>\n", "      Effect.dieMessage(\n\t        `The following error(s) occurred while parsing the TypeScript source files:\\n${message}`\n\t      )\n\t  })\n\t)\n"]}
{"filename": "src/Process.ts", "chunked_list": ["/**\n\t * @since 1.0.0\n\t */\n\timport { Context, Effect, Layer } from \"effect\"\n\t/**\n\t * Represents a handle to the currently executing process.\n\t *\n\t * @category model\n\t * @since 1.0.0\n\t */\n", "export interface Process {\n\t  readonly cwd: Effect.Effect<never, never, string>\n\t  readonly platform: Effect.Effect<never, never, string>\n\t}\n\t/**\n\t * @category service\n\t * @since 1.0.0\n\t */\n\texport const Process = Context.Tag<Process>()\n\t/**\n", " * @category service\n\t * @since 1.0.0\n\t */\n\texport const ProcessLive = Layer.succeed(\n\t  Process,\n\t  Process.of({\n\t    cwd: Effect.sync(() => process.cwd()),\n\t    platform: Effect.sync(() => process.platform)\n\t  })\n\t)\n"]}
