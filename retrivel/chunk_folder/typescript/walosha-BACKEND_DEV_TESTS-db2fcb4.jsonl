{"filename": "@types/helmet.d.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/ban-types */\n\tdeclare module 'xss-clean' {\n\t  const value: Function;\n\t  export default value;\n\t}\n"]}
{"filename": "@types/xss-clean.d.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/ban-types */\n\tdeclare module 'helmet' {\n\t  const value: Function;\n\t  export default value;\n\t}\n"]}
{"filename": "@types/express.d.ts", "chunked_list": ["export interface UserPayload {\n\t  id?: string;\n\t  name: string;\n\t  email: string;\n\t  role: string;\n\t  token?: string;\n\t}\n\tdeclare module 'express-serve-static-core' {\n\t  interface Request {\n\t    user?: UserPayload;\n", "  }\n\t}\n"]}
{"filename": "src/app.ts", "chunked_list": ["import express from 'express';\n\timport morgan from 'morgan';\n\timport mongoSanitize from 'express-mongo-sanitize';\n\timport cookieParser from 'cookie-parser';\n\timport cors from 'cors';\n\timport authRouter from './modules/auth/controller';\n\timport userRouter from './modules/auth/controller/users';\n\timport accountRouter from './modules/account/controller/index';\n\timport errorHandler from './middleware/error';\n\timport swaggerJsdoc from 'swagger-jsdoc';\n", "import swaggerUi from 'swagger-ui-express';\n\timport * as dotenv from 'dotenv';\n\timport { options } from './constant/swaggerOptions';\n\timport { customRedisRateLimiter } from './middleware/ratelimiter';\n\tdotenv.config();\n\t// Start express app\n\tconst app = express();\n\tconst specs = swaggerJsdoc(options);\n\tapp.use('/api/v1/api-docs', swaggerUi.serve, swaggerUi.setup(specs));\n\tapp.enable('trust proxy');\n", "// Implement CORS\n\tapp.use(cors());\n\t// Set security HTTP headers\n\t// Implemened 10 requests in 24 hrs limit!\n\tapp.use(customRedisRateLimiter);\n\t// Development logging\n\tif (process.env.NODE_ENV === 'development') {\n\t  app.use(morgan('dev'));\n\t}\n\t// Body parser, reading data from body into req.body\n", "app.use(express.json({ limit: '10kb' }));\n\tapp.use(express.urlencoded({ extended: true, limit: '10kb' }));\n\tapp.use(cookieParser());\n\tapp.use(mongoSanitize());\n\t// 3) ROUTES\n\tapp.use('/api/v1/auth', authRouter);\n\tapp.use('/api/v1/users', userRouter);\n\tapp.use('/api/v1/account', accountRouter);\n\tapp.use(errorHandler);\n\texport default app;\n"]}
{"filename": "src/index.ts", "chunked_list": ["import dotenv from 'dotenv';\n\timport { initializeDB } from './database';\n\tprocess.on('uncaughtException', (err) => {\n\t  console.log('UNCAUGHT EXCEPTION! ðŸ’¥ Shutting down...');\n\t  console.log(err.name, err.message);\n\t  process.exit(1);\n\t});\n\tdotenv.config({ path: './config.env' });\n\timport app from './app';\n\tinitializeDB();\n", "const port = process.env.PORT || 3000;\n\tconst server = app.listen(port, () => {\n\t  console.log(`App running on port ${port}...`);\n\t});\n\tprocess.on('unhandledRejection', (err: any) => {\n\t  console.log('UNHANDLED REJECTION! ðŸ’¥ Shutting down...');\n\t  console.log(err.name, err.message);\n\t  server.close(() => {\n\t    process.exit(1);\n\t  });\n", "});\n\tprocess.on('SIGTERM', () => {\n\t  console.log('ðŸ‘‹ SIGTERM RECEIVED. Shutting down gracefully');\n\t  server.close(() => {\n\t    console.log('ðŸ’¥ Process terminated!');\n\t  });\n\t});\n"]}
{"filename": "src/utils/appError.ts", "chunked_list": ["export class AppError extends Error {\n\t  status;\n\t  statusCode;\n\t  isOperational;\n\t  constructor(message: string, statusCode: number) {\n\t    super(message);\n\t    this.statusCode = statusCode;\n\t    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';\n\t    this.isOperational = true;\n\t    Error.captureStackTrace(this, this.constructor);\n", "  }\n\t}\n"]}
{"filename": "src/utils/catchAsync.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\n\ttype AsyncFunction = (req: Request, res: Response, next: NextFunction) => Promise<any>;\n\texport const catchAsync = (fn: AsyncFunction) => {\n\t  return (req: Request, res: Response, next: NextFunction) => {\n\t    fn(req, res, next).catch(next);\n\t  };\n\t};\n"]}
{"filename": "src/utils/redis.ts", "chunked_list": ["import { createClient } from 'redis';\n\tclass RedisService {\n\t  client;\n\t  constructor() {\n\t    this.client = createClient({ url: process.env.REDIS_URL });\n\t  }\n\t  async set({ key, value, timeType, time }: any) {\n\t    await this.client.connect();\n\t    await this.client.set(key, value, timeType, time);\n\t    await this.client.disconnect();\n", "  }\n\t  async get(key: string) {\n\t    await this.client.connect();\n\t    const result = await this.client.get(key);\n\t    await this.client.disconnect();\n\t    return result;\n\t  }\n\t  async exists(key: string) {\n\t    await this.client.connect();\n\t    const result = await this.client.exists(key);\n", "    await this.client.disconnect();\n\t    return result;\n\t  }\n\t}\n\texport default new RedisService();\n"]}
{"filename": "src/constant/swaggerOptions.ts", "chunked_list": ["// https://blog.logrocket.com/documenting-express-js-api-swagger/\n\texport const options = {\n\t  swaggerDefinition: {\n\t    openapi: '3.0.0',\n\t    info: {\n\t      title: 'BACKEND_DEV_TEST',\n\t      version: '1.0.0',\n\t      description: 'API documentation',\n\t      contact: {\n\t        name: 'bacnk-api',\n", "        url: 'localhost:3000',\n\t        email: 'walosha@yahoo.com',\n\t      },\n\t    },\n\t    components: {\n\t      securitySchemes: {\n\t        bearerAuth: {\n\t          type: 'http',\n\t          scheme: 'bearer',\n\t          bearerFormat: 'JWT',\n", "        },\n\t      },\n\t    },\n\t    security: [{ bearerAuth: [] }],\n\t    servers: [\n\t      {\n\t        url: 'http://localhost:3000',\n\t        description: 'Development server',\n\t      },\n\t    ],\n", "  },\n\t  apis: ['./src/modules/**/*.ts'],\n\t};\n"]}
{"filename": "src/database/index.ts", "chunked_list": ["import mongoose from 'mongoose';\n\texport const initializeDB = () => {\n\t  console.log(process.env.DATABASE_URL);\n\t  mongoose\n\t    .connect(process.env.DATABASE_URL as string, {})\n\t    .then(() => console.log('DB connection successful!'))\n\t    .catch(console.log);\n\t};\n"]}
{"filename": "src/modules/auth/model/index.ts", "chunked_list": ["import { Document, Model, Schema, model } from 'mongoose';\n\timport * as EmailValidator from 'email-validator';\n\timport { hash, compare } from 'bcryptjs';\n\t// import { IUser } from '../types';\n\tinterface UserAttrs {\n\t  id: string;\n\t  name: string;\n\t  email: string;\n\t  role: 'user' | 'admin';\n\t  password: string;\n", "}\n\texport interface UserModel extends Model<IUser> {\n\t  build(attrs: UserAttrs): IUser;\n\t  correctPassword(candidatePassword: string, userPassword: string): Promise<boolean>;\n\t}\n\tinterface IUser extends Document {\n\t  id: string;\n\t  name: string;\n\t  email: string;\n\t  role: 'user' | 'admin';\n", "  password: string;\n\t}\n\tconst userSchema = new Schema<IUser>({\n\t  name: {\n\t    type: String,\n\t    required: [true, 'Please tell us your name!'],\n\t  },\n\t  email: {\n\t    type: String,\n\t    required: [true, 'Please provide your email'],\n", "    unique: true,\n\t    lowercase: true,\n\t    validate: {\n\t      validator: function (value: string) {\n\t        // Custom email validation logic\n\t        return /^([\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4})?$/.test(value);\n\t      },\n\t      message: 'Invalid email format',\n\t    },\n\t  },\n", "  role: {\n\t    type: String,\n\t    enum: ['user', 'admin'],\n\t    default: 'user',\n\t  },\n\t  password: {\n\t    type: String,\n\t    required: [true, 'Please provide a password'],\n\t    minlength: 8,\n\t    select: false,\n", "  },\n\t});\n\tuserSchema.pre('save', async function (next) {\n\t  // Only run this function if password was actually modified\n\t  if (!this.isModified('password')) return next();\n\t  // Hash the password with cost of 12\n\t  this.password = await hash(this.password, 12);\n\t  // Delete passwordConfirm field\n\t  next();\n\t});\n", "userSchema.methods.correctPassword = async function (\n\t  candidatePassword: string,\n\t  userPassword: string,\n\t): Promise<boolean> {\n\t  return await compare(candidatePassword, userPassword);\n\t};\n\t// const User = model<IUser>('User', userSchema);\n\tuserSchema.statics.build = (attrs: UserAttrs) => {\n\t  return new User(attrs);\n\t};\n", "const User = model<IUser, UserModel>('User', userSchema);\n\texport default User;\n"]}
{"filename": "src/modules/auth/controller/users.ts", "chunked_list": ["/**\n\t * @swagger\n\t * components:\n\t *   schemas:\n\t *     User:\n\t *       type: object\n\t *       required:\n\t *         - name\n\t *         - email\n\t *       properties:\n", " *         name:\n\t *           type: string\n\t *           description: The user name\n\t *         email:\n\t *           type: string\n\t *           format: email\n\t *           description: The user email address\n\t *         password:\n\t *           type: string\n\t *           description: The user password (hashed)\n", " *         role:\n\t *           type: string\n\t *           enum: [user, admin]\n\t *           description: The user role\n\t *           default: user\n\t *       example:\n\t *         name: John Doe\n\t *         email: johndoe@example.com\n\t *         password: $2a$10$gR06R4K1NM4p4b4ELq.LlOTzq3Dcxj2iPwE5U/O2MDE70o9noemhO\n\t *         role: user\n", " */\n\timport express from 'express';\n\timport { deleteUser, fetchUsers } from '../service';\n\timport { protect, restrictTo } from '../../../middleware';\n\tconst router = express.Router();\n\t/**\n\t * @swagger\n\t * /api/v1/users:\n\t *   get:\n\t *     summary: Retrieve all users\n", " *     tags: [User]\n\t *     security:\n\t *       - bearerAuth: []\n\t *     responses:\n\t *       \"200\":\n\t *         description: A list of users\n\t *         content:\n\t *           application/json:\n\t *             schema:\n\t *               type: array\n", " *               items:\n\t *                 $ref: '#/components/schemas/User'\n\t *       \"401\":\n\t *         description: Unauthorized\n\t */\n\trouter.get('/', protect, restrictTo('admin'), fetchUsers);\n\t/**\n\t * @swagger\n\t * /api/v1/users/{id}:\n\t *   delete:\n", " *     summary: Delete a user by ID\n\t *     tags: [User]\n\t *     security:\n\t *       - bearerAuth: []\n\t *     parameters:\n\t *       - in: path\n\t *         name: id\n\t *         schema:\n\t *           type: string\n\t *         required: true\n", " *         description: The ID of the user to delete\n\t *     responses:\n\t *       \"204\":\n\t *         description: User deleted successfully\n\t *       \"401\":\n\t *         description: Unauthorized\n\t *       \"404\":\n\t *         description: User not found\n\t */\n\t// A simple case where users can only delete themselves not the admin\n", "router.delete('/:id', restrictTo('user'), deleteUser);\n\texport default router;\n"]}
{"filename": "src/modules/auth/controller/index.ts", "chunked_list": ["/**\n\t * @swagger\n\t * components:\n\t *   schemas:\n\t *     SignupRequest:\n\t *       type: object\n\t *       required:\n\t *         - email\n\t *         - password\n\t *         - name\n", " *       properties:\n\t *         name:\n\t *           type: string\n\t *           description: The user name\n\t *         email:\n\t *           type: string\n\t *           description: The user email address\n\t *         password:\n\t *           type: string\n\t *           description: The user password\n", " *       example:\n\t *         name: John Doe\n\t *         email: johndoe@example.com\n\t *         password: password123\n\t *     LoginRequest:\n\t *       type: object\n\t *       required:\n\t *         - email\n\t *         - password\n\t *       properties:\n", " *         email:\n\t *           type: string\n\t *           description: The user email address\n\t *         password:\n\t *           type: string\n\t *           description: The user password\n\t *       example:\n\t *         email: johndoe@example.com\n\t *         password: password123\n\t */\n", "import express from 'express';\n\timport { getMe, login, refresh, signup } from '../service';\n\timport { refreshMiddleware } from '../../../middleware/refresh';\n\timport { protect } from '../../../middleware';\n\tconst router = express.Router();\n\t/**\n\t * @swagger\n\t * /api/v1/auth/signup:\n\t *   post:\n\t *     summary: Creates an account\n", " *     tags: [Auth]\n\t *     requestBody:\n\t *       required: true\n\t *       content:\n\t *         application/json:\n\t *           schema:\n\t *             $ref: '#/components/schemas/SignupRequest'\n\t *     responses:\n\t *       \"200\":\n\t *         description: The created user.\n", " *         content:\n\t *           application/json:\n\t *             schema:\n\t *               $ref: '#/components/schemas/User'\n\t */\n\trouter.post('/signup', signup);\n\t/**\n\t * @swagger\n\t * /api/v1/auth/login:\n\t *   post:\n", " *     summary: Login User\n\t *     tags: [Auth]\n\t *     requestBody:\n\t *       required: true\n\t *       content:\n\t *         application/json:\n\t *           schema:\n\t *             $ref: '#/components/schemas/LoginRequest'\n\t *     responses:\n\t *       \"200\":\n", " *         description: The authenticated user.\n\t *         content:\n\t *           application/json:\n\t *             schema:\n\t *               $ref: '#/components/schemas/User'\n\t */\n\trouter.post('/login', login);\n\t/**\n\t * @swagger\n\t * /api/v1/auth/refresh:\n", " *   post:\n\t *     summary: Refreshes the access token\n\t *     tags: [Auth]\n\t *     requestBody:\n\t *       required: true\n\t *       content:\n\t *         application/json:\n\t *           schema:\n\t *             type: object\n\t *             required:\n", " *               - refresh\n\t *             properties:\n\t *               refresh:\n\t *                 type: string\n\t *                 description: Refresh token\n\t *                 example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0NGYwMjg0MWRmNGJlYzliOWI3ZjlhYSIsImlhdCI6MTY4Mjg5OTU4OCwiZXhwIjoxNjgzMDcyMzg4fQ.Bt2kzyxyUEtUy9pLvr0zSzpI8_xTaM6KulO2mwYztbQ\n\t *     responses:\n\t *       \"200\":\n\t *         description: The new access token\n\t *         content:\n", " *           application/json:\n\t *             schema:\n\t *               type: object\n\t *               properties:\n\t *                 accessToken:\n\t *                   type: string\n\t *                   description: Access token\n\t *                   example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJKb2huIERvZSIsImlhdCI6MTUxNjIzOTAyMn0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\t *       \"400\":\n\t *         description: Invalid request or refresh token is not present\n", " *       \"401\":\n\t *         description: Invalid or expired token or refresh token was already used\n\t */\n\trouter.post('/refresh', refreshMiddleware, refresh);\n\t/**\n\t * @swagger\n\t * /api/v1/auth/me:\n\t *   post:\n\t *     summary: Get user profile\n\t *     tags: [Auth]\n", " *     security:\n\t *       - bearerAuth: []\n\t *     responses:\n\t *       \"200\":\n\t *         description: The user profile\n\t *       \"401\":\n\t *         description: Unauthorized\n\t */\n\trouter.post('/me', protect, getMe);\n\texport default router;\n"]}
{"filename": "src/modules/auth/types/index.ts", "chunked_list": ["export interface IUser {\n\t  _id: string;\n\t  name: string;\n\t  email: string;\n\t  role: 'user' | 'admin';\n\t  password: string;\n\t}\n"]}
{"filename": "src/modules/auth/service/index.ts", "chunked_list": ["import { sign } from 'jsonwebtoken';\n\timport { IUser } from '../types';\n\timport { Request, Response } from 'express';\n\timport User from '../model';\n\timport { AppError } from '../../../utils/appError';\n\timport { catchAsync } from '../../../utils/catchAsync';\n\timport redisService from '../../../utils/redis';\n\tconst accessToken = (user: { _id: string; name: string; email: string; role: string }) => {\n\t  return sign(\n\t    { id: user._id, name: user.name, email: user.email, type: process.env.JWT_ACCESS, role: user.role },\n", "    process.env.JWT_KEY_SECRET as string,\n\t    {\n\t      subject: user.email,\n\t      expiresIn: process.env.JWT_EXPIRES_IN,\n\t      audience: process.env.JWT_AUDIENCE,\n\t      issuer: process.env.JWT_ISSUER,\n\t    },\n\t  );\n\t};\n\tconst refreshToken = (user: { _id: string; name: string; email: string; role: string }) => {\n", "  return sign(\n\t    { id: user._id, name: user.name, email: user.email, type: process.env.JWT_REFRESH, role: user.role },\n\t    process.env.JWT_KEY_REFRESH as string,\n\t    {\n\t      subject: user.email,\n\t      expiresIn: process.env.JWT_EXPIRES_IN,\n\t      audience: process.env.JWT_AUDIENCE,\n\t      issuer: process.env.JWT_ISSUER,\n\t    },\n\t  );\n", "};\n\tconst createSendToken = (user: IUser, statusCode: number, req: Request, res: Response) => {\n\t  const acess = accessToken(user);\n\t  const refresh = refreshToken(user);\n\t  // Remove password from output\n\t  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t  const { name, email, role, ...otherUserData } = user;\n\t  res.status(statusCode).json({\n\t    status: 'success',\n\t    acess,\n", "    refresh,\n\t    data: {\n\t      name,\n\t      email,\n\t      role,\n\t    },\n\t  });\n\t};\n\texport const signup = catchAsync(async (req, res) => {\n\t  const newUser = await User.create({\n", "    name: req.body.name,\n\t    email: req.body.email,\n\t    password: req.body.password,\n\t  });\n\t  createSendToken(newUser, 201, req, res);\n\t});\n\texport const login = catchAsync(async (req, res, next) => {\n\t  const { email, password } = req.body;\n\t  // 1) Check if email and password exist\n\t  if (!email || !password) {\n", "    return next(new AppError('Please provide email and password!', 400));\n\t  }\n\t  // 2) Check if user exists && password is correct\n\t  const user: any = await User.findOne({ email }).select('+password');\n\t  if (!user || !(await user.correctPassword(password, user.password))) {\n\t    return next(new AppError('Incorrect email or password', 401));\n\t  }\n\t  // 3) If everything ok, send token to client\n\t  createSendToken(user, 200, req, res);\n\t});\n", "export const getMe = catchAsync(async (req, res) => {\n\t  const user = req.user;\n\t  // 3) If everything ok, send token to client\n\t  res.status(200).json({ message: 'user sucessfully fetched!', user });\n\t});\n\texport function logout(req: Request, res: Response) {\n\t  res.cookie('jwt', 'loggedout', {\n\t    expires: new Date(Date.now() + 10 * 1000),\n\t    httpOnly: true,\n\t  });\n", "  res.status(200).json({ status: 'success' });\n\t}\n\texport async function refresh(req: Request, res: Response) {\n\t  const user: any = req.user;\n\t  await redisService.set({\n\t    key: user?.token,\n\t    value: '1',\n\t    timeType: 'EX',\n\t    time: parseInt(process.env.JWT_REFRESH_TIME || '', 10),\n\t  });\n", "  const refresh = refreshToken(user);\n\t  return res.status(200).json({ status: 'sucess', refresh });\n\t}\n\texport async function fetchUsers(req: Request, res: Response) {\n\t  const body = req.body;\n\t  console.log({ body });\n\t  try {\n\t    const users = await User.find();\n\t    return res.status(200).json({ message: 'sucessfully fetch users', data: users });\n\t  } catch (error: any) {\n", "    new AppError(error.message, 201);\n\t  }\n\t}\n\texport async function deleteUser(req: Request, res: Response) {\n\t  const id = req.params.id;\n\t  try {\n\t    await User.deleteOne({ _id: id });\n\t    return res.status(200).json({ message: 'sucessfully deleted users' });\n\t  } catch (error: any) {\n\t    new AppError(error.message, 201);\n", "  }\n\t}\n"]}
{"filename": "src/modules/account/model/index.ts", "chunked_list": ["import mongoose, { Document, Model, Schema, model } from 'mongoose';\n\tinterface AccountAttrs {\n\t  id: string;\n\t  user: string;\n\t  accountType: any;\n\t  balance: number;\n\t}\n\tinterface IAccount extends Document {\n\t  id: string;\n\t  user: string;\n", "  accountType: any;\n\t  balance: number;\n\t}\n\texport interface AccountModel extends Model<IAccount> {\n\t  build(attrs: AccountAttrs): IAccount;\n\t}\n\tconst AccountSchema = new Schema({\n\t  accountType: {\n\t    type: String,\n\t    enum: ['Savings', 'Current', 'BasicSavings'],\n", "  },\n\t  user: {\n\t    type: mongoose.Types.ObjectId,\n\t    ref: 'User',\n\t  },\n\t  balance: {\n\t    type: Number,\n\t    default: 0,\n\t  },\n\t});\n", "AccountSchema.methods.verifyBalance = function (amountToAdd: any) {\n\t  if (this.accountType === 'BasicSavings' && this.balance + amountToAdd > 50000) {\n\t    return false;\n\t  }\n\t  return true;\n\t};\n\tAccountSchema.statics.build = (attrs: AccountAttrs) => {\n\t  return new Account(attrs);\n\t};\n\tconst Account = model<IAccount, AccountModel>('Account', AccountSchema);\n", "export default Account;\n"]}
{"filename": "src/modules/account/controller/index.ts", "chunked_list": ["/**\n\t * @swagger\n\t * components:\n\t *   schemas:\n\t *     SignupRequest:\n\t *       type: object\n\t *       required:\n\t *         - email\n\t *         - password\n\t *         - name\n", " *       properties:\n\t *         name:\n\t *           type: string\n\t *           description: The user name\n\t *         email:\n\t *           type: string\n\t *           description: The user email address\n\t *         password:\n\t *           type: string\n\t *           description: The user password\n", " *       example:\n\t *         name: John Doe\n\t *         email: johndoe@example.com\n\t *         password: password123\n\t *     LoginRequest:\n\t *       type: object\n\t *       required:\n\t *         - email\n\t *         - password\n\t *       properties:\n", " *         email:\n\t *           type: string\n\t *           description: The user email address\n\t *         password:\n\t *           type: string\n\t *           description: The user password\n\t *       example:\n\t *         email: johndoe@example.com\n\t *         password: password123\n\t */\n", "import express from 'express';\n\timport { transferFund } from '../service';\n\timport { protect } from '../../../middleware';\n\tconst router = express.Router();\n\t/**\n\t * @swagger\n\t * /api/v1/account/transfer:\n\t *   post:\n\t *     tags:\n\t *       - Transfer\n", " *     summary: Transfer funds between accounts\n\t *     security:\n\t *       - BearerAuth: []\n\t *     requestBody:\n\t *       required: true\n\t *       content:\n\t *         application/json:\n\t *           schema:\n\t *             type: object\n\t *             properties:\n", " *               fromAccountId:\n\t *                 type: string\n\t *                 description: The ID of the account to transfer funds from.\n\t *                 example: \"123456\"\n\t *               toAccountId:\n\t *                 type: string\n\t *                 description: The ID of the account to transfer funds to.\n\t *                 example: \"789012\"\n\t *               amount:\n\t *                 type: number\n", " *                 description: The amount of funds to transfer.\n\t *                 example: 1000.00\n\t *               tag:\n\t *                 type: string\n\t *                 description: The tag associated with the transfer.\n\t *                 example: \"Rent payment\"\n\t *     responses:\n\t *       '200':\n\t *         description: Successful transfer of funds\n\t *       '400':\n", " *         description: Invalid request parameters\n\t *       '401':\n\t *         description: Unauthorized request\n\t */\n\trouter.post('/transfer', protect, transferFund);\n\texport default router;\n"]}
{"filename": "src/modules/account/types/index.ts", "chunked_list": ["export interface IUser {\n\t  _id: string;\n\t  name: string;\n\t  email: string;\n\t  role: 'user' | 'admin';\n\t  password: string;\n\t}\n"]}
{"filename": "src/modules/account/service/index.ts", "chunked_list": ["import { Request, Response } from 'express';\n\timport Account from '../model';\n\texport const transferFund = async (req: Request, res: Response) => {\n\t  const { fromAccountId, toAccountId, amount } = req.body;\n\t  try {\n\t    let srcAccount: any = await Account.findById(fromAccountId);\n\t    let destAccount: any = await Account.findById(toAccountId);\n\t    if (String(srcAccount.user) == String(destAccount.user)) {\n\t      return res.status(400).json({\n\t        error: 'Cannot transfer to own acccount',\n", "        errorCode: 400,\n\t      });\n\t    }\n\t    if (srcAccount.balance >= amount) {\n\t      srcAccount = await Account.findByIdAndUpdate(\n\t        srcAccount,\n\t        {\n\t          $inc: {\n\t            balance: -amount,\n\t          },\n", "        },\n\t        { returnOriginal: false },\n\t      );\n\t      destAccount = await Account.findByIdAndUpdate(destAccount, {\n\t        $inc: {\n\t          balance: amount,\n\t        },\n\t      });\n\t      console.log('srcAcc', srcAccount);\n\t      const destUserId = destAccount.user;\n", "      const destUserData = await Account.aggregate([\n\t        {\n\t          $match: {\n\t            user: destUserId,\n\t          },\n\t        },\n\t        {\n\t          $group: {\n\t            _id: null,\n\t            total: {\n", "              $sum: '$balance',\n\t            },\n\t          },\n\t        },\n\t      ]);\n\t      console.log(destUserData[0].total);\n\t      return res.json({\n\t        newSrcBalance: srcAccount.balance,\n\t        totalDestBalance: destUserData[0].total,\n\t        transferedAt: new Date(),\n", "      });\n\t    } else {\n\t      return res.status(400).json({\n\t        error: 'Not enough balance',\n\t        errorCode: 400,\n\t      });\n\t    }\n\t  } catch (err) {\n\t    console.log(err);\n\t    return res.status(400).json({\n", "      error: 'Transcation failed',\n\t    });\n\t  }\n\t};\n"]}
{"filename": "src/middleware/isLoggedIn.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\n\timport { NextFunction, Request, Response } from 'express';\n\timport jwt from 'jsonwebtoken';\n\timport User from '../modules/auth/model';\n\t// Only for rendered pages, no errors!\n\texport async function isLoggedIn(req: Request, res: Response, next: NextFunction) {\n\t  if (req.cookies.jwt) {\n\t    try {\n\t      // 1) verify token\n\t      const decoded: any = await jwt.verify(req.cookies.jwt, process.env.JWT_KEY_SECRET as string);\n", "      // 2) Check if user still exists\n\t      const currentUser = await User.findById(decoded?.id);\n\t      if (!currentUser) {\n\t        return next();\n\t      }\n\t      return next();\n\t    } catch (err) {\n\t      return next();\n\t    }\n\t  }\n", "  next();\n\t}\n"]}
{"filename": "src/middleware/protect.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\n\timport { JwtPayload, verify } from 'jsonwebtoken';\n\timport { AppError } from '../utils/appError';\n\timport { catchAsync } from '../utils/catchAsync';\n\timport User from '../modules/auth/model';\n\texport const protect = catchAsync(async (req: Request, res: Response, next: NextFunction) => {\n\t  // 1) Getting token and check of it's there\n\t  let token;\n\t  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n\t    token = req.headers.authorization.split(' ')[1];\n", "  } else if (req.cookies.jwt) {\n\t    token = req.cookies.jwt;\n\t  }\n\t  console.log({ token });\n\t  if (!token) {\n\t    return next(new AppError('You are not logged in! Please log in to get access.', 401));\n\t  }\n\t  // 2) Verification token\n\t  const decoded = (await verify(token, process.env.JWT_KEY_SECRET as string)) as JwtPayload;\n\t  console.log({ decoded });\n", "  // 3) Check if user still exists\n\t  const currentUser = await User.findById(decoded.id);\n\t  if (!currentUser) {\n\t    return next(new AppError('The user belonging to this token does no longer exist.', 401));\n\t  }\n\t  // GRANT ACCESS TO PROTECTED ROUTE\n\t  req.user = currentUser;\n\t  next();\n\t});\n"]}
{"filename": "src/middleware/roles.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\n\timport { AppError } from '../utils/appError';\n\timport { UserPayload } from '../../@types/express';\n\texport function restrictTo(...roles: string[]) {\n\t  return (req: Request & { user?: UserPayload }, res: Response, next: NextFunction) => {\n\t    // roles ['admin', 'user']. role='user'\n\t    if (req?.user) {\n\t      if (!roles.includes(req.user.role)) {\n\t        return next(new AppError('You do not have permission to perform this action', 403));\n\t      }\n", "    }\n\t    next();\n\t  };\n\t}\n"]}
{"filename": "src/middleware/ratelimiter.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\n\timport moment from 'moment';\n\timport { AppError } from '../utils/appError';\n\timport redisService from '../utils/redis';\n\tconst WINDOW_SIZE_IN_HOURS = 24;\n\tconst MAX_WINDOW_REQUEST_COUNT = 20;\n\tconst WINDOW_LOG_INTERVAL_IN_HOURS = 1;\n\texport const customRedisRateLimiter = async (req: Request, res: Response, next: NextFunction) => {\n\t  try {\n\t    if (!redisService) {\n", "      throw new AppError('Redis client does not exist!', 500);\n\t    }\n\t    console.log({ IPAddress: req.ip });\n\t    const record = await redisService.get(req.ip);\n\t    const currentRequestTime = moment();\n\t    if (!record) {\n\t      const newRecord = [{ requestTimeStamp: currentRequestTime.unix(), requestCount: 1 }];\n\t      await redisService.set({ key: req.ip, value: JSON.stringify(newRecord) });\n\t      return next();\n\t    }\n", "    const data = JSON.parse(record);\n\t    const windowStartTimestamp = moment().subtract(WINDOW_SIZE_IN_HOURS, 'hours').unix();\n\t    const requestsWithinWindow = data.filter(\n\t      (entry: { requestTimeStamp: number }) => entry.requestTimeStamp > windowStartTimestamp,\n\t    );\n\t    const totalWindowRequestsCount = requestsWithinWindow.reduce(\n\t      (accumulator: any, entry: { requestCount: any }) => accumulator + entry.requestCount,\n\t      0,\n\t    );\n\t    if (totalWindowRequestsCount >= MAX_WINDOW_REQUEST_COUNT) {\n", "      return res.status(429).send({\n\t        message: `You have exceeded the ${MAX_WINDOW_REQUEST_COUNT} requests in ${WINDOW_SIZE_IN_HOURS} hrs limit!`,\n\t      });\n\t    }\n\t    const lastRequestLog = data[data.length - 1];\n\t    const potentialCurrentWindowIntervalStartTimeStamp = currentRequestTime\n\t      .subtract(WINDOW_LOG_INTERVAL_IN_HOURS, 'hours')\n\t      .unix();\n\t    if (lastRequestLog.requestTimeStamp > potentialCurrentWindowIntervalStartTimeStamp) {\n\t      lastRequestLog.requestCount++;\n", "      data[data.length - 1] = lastRequestLog;\n\t    } else {\n\t      data.push({ requestTimeStamp: currentRequestTime.unix(), requestCount: 1 });\n\t    }\n\t    await redisService.set({ key: req.ip, value: JSON.stringify(data) });\n\t    next();\n\t  } catch (error) {\n\t    next(error);\n\t  }\n\t};\n"]}
{"filename": "src/middleware/refresh.ts", "chunked_list": ["import jwt, { JwtPayload } from 'jsonwebtoken';\n\timport redisService from '../utils/redis';\n\timport { AppError } from '../utils/appError';\n\timport { NextFunction, Request, Response } from 'express';\n\texport const refreshMiddleware: any = async (req: Request, res: Response, next: NextFunction) => {\n\t  if (req.body?.refresh) {\n\t    const token = req.body.refresh;\n\t    try {\n\t      const decoded: any = jwt.verify(token, process.env.JWT_KEY_REFRESH as string) as JwtPayload;\n\t      if (\n", "        decoded.type !== process.env.JWT_REFRESH ||\n\t        decoded.aud !== process.env.JWT_AUDIENCE ||\n\t        decoded.iss !== process.env.JWT_ISSUER\n\t      ) {\n\t        next(new AppError('Invalid token type', 401));\n\t      }\n\t      const value = await redisService.get(token);\n\t      if (value) {\n\t        next(new AppError('Refresh token was already used', 401));\n\t      }\n", "      req.user = {\n\t        email: decoded.email,\n\t        name: decoded.name,\n\t        role: decoded.role,\n\t        token,\n\t      };\n\t      next();\n\t      return;\n\t    } catch (err) {\n\t      console.log({ err });\n", "      next(new AppError('Invalid token', 401));\n\t    }\n\t  }\n\t  next(new AppError('Refresh token is not present', 400));\n\t};\n"]}
{"filename": "src/middleware/error.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\n\timport { AppError } from '../utils/appError';\n\tconst handleCastErrorDB = (err: any) => {\n\t  const message = `Invalid ${err.path}: ${err.value}.`;\n\t  return new AppError(message, 400);\n\t};\n\tconst handleDuplicateFieldsDB = (err: any) => {\n\t  const value = err.errmsg.match(/([\"'])(\\\\?.)*?\\1/)[0];\n\t  const message = `Duplicate field value: ${value}. Please use another value!`;\n\t  return new AppError(message, 400);\n", "};\n\tconst handleValidationErrorDB = (err: any) => {\n\t  const errors = Object.values(err.errors).map((el: any) => el.message);\n\t  const message = `Invalid input data. ${errors.join('. ')}`;\n\t  return new AppError(message, 400);\n\t};\n\tconst handleJWTError = () => new AppError('Invalid token. Please log in again!', 401);\n\tconst handleJWTExpiredError = () => new AppError('Your token has expired! Please log in again.', 401);\n\tconst sendErrorDev = (err: any, req: Request, res: Response) => {\n\t  // A) API\n", "  return res.status(err.statusCode).json({\n\t    status: err.status,\n\t    error: err,\n\t    message: err.message,\n\t    stack: err.stack,\n\t  });\n\t};\n\tconst sendErrorProd = (err: any, req: Request, res: Response) => {\n\t  // A) API\n\t  if (req.originalUrl.startsWith('/api')) {\n", "    // A) Operational, trusted error: send message to client\n\t    if (err.isOperational) {\n\t      return res.status(err.statusCode).json({\n\t        status: err.status,\n\t        message: err.message,\n\t      });\n\t    }\n\t    // B) Programming or other unknown error: don't leak error details\n\t    // 1) Log error\n\t    console.error('ERROR ðŸ’¥', err);\n", "    // 2) Send generic message\n\t    return res.status(500).json({\n\t      status: 'error',\n\t      message: 'Something went very wrong!',\n\t    });\n\t  }\n\t  // B) Programming or other unknown error: don't leak error details\n\t  // 1) Log error\n\t  console.error('ERROR ðŸ’¥', err);\n\t  // 2) Send generic message\n", "  return res.status(err.statusCode).render('error', {\n\t    title: 'Something went wrong!',\n\t    msg: 'Please try again later.',\n\t  });\n\t};\n\tfunction globalErrorHandler(err: any, req: Request, res: Response, next: NextFunction) {\n\t  // console.log(err.stack);\n\t  err.statusCode = err.statusCode || 500;\n\t  err.status = err.status || 'error';\n\t  if (process.env.NODE_ENV === undefined) {\n", "    sendErrorDev(err, req, res);\n\t  } else if (process.env.NODE_ENV === 'production') {\n\t    let error = { ...err };\n\t    error.message = err.message;\n\t    if (error.name === 'CastError') error = handleCastErrorDB(error);\n\t    if (error.code === 11000) error = handleDuplicateFieldsDB(error);\n\t    if (error.name === 'ValidationError') error = handleValidationErrorDB(error);\n\t    if (error.name === 'JsonWebTokenError') error = handleJWTError();\n\t    if (error.name === 'TokenExpiredError') error = handleJWTExpiredError();\n\t    sendErrorProd(error, req, res);\n", "  }\n\t}\n\texport default globalErrorHandler;\n"]}
{"filename": "src/middleware/index.ts", "chunked_list": ["export { restrictTo } from './roles';\n\texport { isLoggedIn } from './isLoggedIn';\n\texport { protect } from './protect';\n"]}
