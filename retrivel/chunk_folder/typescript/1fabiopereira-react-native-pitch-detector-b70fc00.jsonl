{"filename": "jest.config.ts", "chunked_list": ["import type { Config } from 'jest';\n\tconst config: Config = {\n\t  preset: 'react-native',\n\t  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],\n\t  transformIgnorePatterns: ['./node_modules/(?!@react-native|react-native)'],\n\t  setupFiles: ['<rootDir>/.jest/jest.setup.ts'],\n\t  modulePathIgnorePatterns: [\n\t    '<rootDir>/example/node_modules',\n\t    '<rootDir>/lib/',\n\t  ],\n", "};\n\texport default config;\n"]}
{"filename": ".jest/jest.setup.ts", "chunked_list": ["import PitchDetectorModule from './__mocks__/PitchDetectorModule'\n\tjest.mock('react-native-permissions', () => require('react-native-permissions/mock'));\n\tconst mocks = { PitchDetectorModule }\n\tObject.keys(mocks).forEach((module => jest.doMock(module, () => mocks[module], { virtual: true })))\n\tjest.mock('react-native', () => ({\n\t    Platform: {\n\t        OS: 'android',\n\t        select: jest.fn((data: { android: any, ios: any }) => data.android)\n\t    },\n\t    NativeEventEmitter: jest.fn().mockImplementation(() => ({\n", "        addListener: jest.fn(),\n\t        emit: jest.fn(),\n\t        listenerCount: jest.fn(),\n\t        removeAllListeners: jest.fn(),\n\t        removeEventListener: jest.fn(),\n\t        removeSubscription: jest.fn(),\n\t    })),\n\t    NativeModules: mocks,\n\t}))\n"]}
{"filename": ".jest/__mocks__/PitchDetectorModule.ts", "chunked_list": ["export default {\n\t    start: jest.fn(),\n\t    stop: jest.fn(),\n\t    isRecording: jest.fn(),\n\t}"]}
{"filename": "example/src/types/index.ts", "chunked_list": ["import { PermissionStatus, Rationale } from 'react-native-permissions';\n\texport type TComparableCallback = (status: PermissionStatus) => boolean;\n\texport type TPermissionsHandlers = {\n\t  RequestPermission: (\n\t    rationale?: Rationale,\n\t    compare?: TComparableCallback\n\t  ) => Promise<PermissionStatus | boolean | null>;\n\t  CheckPermission: (\n\t    compare?: TComparableCallback\n\t  ) => Promise<PermissionStatus | boolean | null>;\n", "};\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './internal/pitch-detector';\n"]}
{"filename": "src/types/index.ts", "chunked_list": ["import type { NativeModule, EmitterSubscription } from 'react-native';\n\timport type { Float, Int32 } from 'react-native/Libraries/Types/CodegenTypes';\n\timport { PermissionStatus, Rationale } from 'react-native-permissions';\n\t/**\n\t * Permission handler comparable callback\n\t */\n\texport type Comparable = (status: PermissionStatus) => boolean;\n\t/**\n\t * Permission handler response\n\t */\n", "export type Response = Promise<PermissionStatus | boolean | null>;\n\t/**\n\t * Permission handler\n\t */\n\texport type PermissionsHandlers = {\n\t  /**\n\t   * Request permission\n\t   * @returns Promise<PermissionStatus | boolean | null>\n\t   */\n\t  RequestPermission: (rationale?: Rationale, compare?: Comparable) => Response;\n", "  /**\n\t   * Check permission\n\t   * @returns Promise<PermissionStatus | boolean | null>\n\t   */\n\t  CheckPermission: (compare?: Comparable) => Response;\n\t};\n\texport enum PitchDetectorErrors {\n\t  BASE,\n\t  LINKING_ERROR,\n\t  PERMISSIONS_ERROR,\n", "}\n\t/**\n\t * Event emitter subscription\n\t */\n\texport type Subscription = EmitterSubscription | undefined;\n\t/**\n\t * Available musical tones.\n\t * @see `https://en.wikipedia.org/wiki/Musical_tone`\n\t */\n\texport type Tone =\n", "  | 'C'\n\t  | 'C#'\n\t  | 'D'\n\t  | 'D#'\n\t  | 'E'\n\t  | 'F'\n\t  | 'F#'\n\t  | 'G'\n\t  | 'G#'\n\t  | 'A'\n", "  | 'A#'\n\t  | 'B';\n\t/**\n\t * Result generated by pitch estimation process.\n\t */\n\texport type Data = {\n\t  /**\n\t   * Pitch frequency in hertz.\n\t   */\n\t  frequency: Float;\n", "  tone: Tone;\n\t};\n\t/**\n\t * A callback function called by event emitted from native side.\n\t */\n\texport type Callback = (data: Data) => void;\n\t/**\n\t * Available pitch estimation algorithm for Android.\n\t * @see `https://0110.be/releases/TarsosDSP/TarsosDSP-latest/TarsosDSP-latest-Documentation/`\n\t */\n", "export type PitchEstimationAndroidAlgorithm =\n\t  | 'AMDF'\n\t  | 'DYNAMIC_WAVELET'\n\t  | 'FFT_PITCH'\n\t  | 'FFT_YIN'\n\t  | 'MPM'\n\t  | 'YIN';\n\t/**\n\t * Available pitch estimation algorithm for IOS.\n\t * @see `https://github.com/vadymmarkov/Beethoven#configuration`\n", " */\n\texport type PitchEstimationIOSAlgorithm =\n\t  | 'BARYCENTRIC'\n\t  | 'HPS'\n\t  | 'JAINS'\n\t  | 'MAX_VALUE'\n\t  | 'QUADRACTIC'\n\t  | 'QUINNS_FIRST'\n\t  | 'QUINNS_SECOND'\n\t  | 'YIN';\n", "export type PitchDetectorAndroidConfig = {\n\t  algorithm?: PitchEstimationAndroidAlgorithm;\n\t  bufferOverLap?: Int32;\n\t  bufferSize?: Int32;\n\t  sampleRate?: Float;\n\t};\n\texport type PitchDetectorIOSConfig = {\n\t  algorithm?: PitchEstimationIOSAlgorithm;\n\t  bufferSize?: Int32;\n\t};\n", "/**\n\t * Pitch detector configuration.\n\t */\n\texport type PitchDetectorConfig = {\n\t  android?: PitchDetectorAndroidConfig;\n\t  ios?: PitchDetectorIOSConfig;\n\t};\n\t/**\n\t * PitchDetector native module interface\n\t */\n", "export interface NativeModuleImplementation extends NativeModule {\n\t  /**\n\t   * Start audio recording and pitch detection with provided configs\n\t   * @param config\n\t   * @returns Promise<void>\n\t   */\n\t  start: (\n\t    config: PitchDetectorAndroidConfig | PitchDetectorIOSConfig\n\t  ) => Promise<void>;\n\t  /**\n", "   * Stop audio recording and pitch detection\n\t   * @returns Promise<void>\n\t   */\n\t  stop: () => Promise<void>;\n\t  /**\n\t   * Get current status\n\t   * @returns Promise<boolean>\n\t   */\n\t  isRecording: () => Promise<void>;\n\t}\n"]}
{"filename": "src/internal/pitch-detector/index.ts", "chunked_list": ["import { NativeModules, NativeEventEmitter, Platform } from 'react-native';\n\timport { Permissions } from '../permissions';\n\timport { PitchDetectorError } from '../erros';\n\timport { merge } from '../utils';\n\timport {\n\t  type Callback,\n\t  type NativeModuleImplementation,\n\t  type PitchDetectorConfig,\n\t  type Subscription,\n\t  type PitchDetectorAndroidConfig,\n", "  type PitchDetectorIOSConfig,\n\t  PitchDetectorErrors,\n\t} from '../../types';\n\texport class InternalPitchDetector {\n\t  private module?: NativeModuleImplementation;\n\t  private event?: NativeEventEmitter;\n\t  constructor() {\n\t    this.module = NativeModules?.PitchDetectorModule;\n\t    if (this.module) {\n\t      this.event = new NativeEventEmitter(this.module);\n", "    } else {\n\t      /* istanbul ignore next */\n\t      throw new PitchDetectorError(PitchDetectorErrors.LINKING_ERROR);\n\t    }\n\t  }\n\t  /**\n\t   * Returns a default PitchDetector configs\n\t   * @returns PitchDetectorConfig\n\t   * @example\n\t   * ```ts\n", "   * {\n\t   *  android: {\n\t   *    algorithm: 'YIN',\n\t   *    bufferOverLap: 0,\n\t   *    bufferSize: 1024,\n\t   *    sampleRate: 22050,\n\t   *  },\n\t   *  ios: {\n\t   *    algorithm: 'YIN',\n\t   *    bufferSize: 1024,\n", "   *  }\n\t   * }\n\t   */\n\t  private getDefaultConfig(): PitchDetectorConfig {\n\t    return {\n\t      android: {\n\t        algorithm: 'YIN',\n\t        bufferOverLap: 0,\n\t        bufferSize: 1024,\n\t        sampleRate: 22050,\n", "      },\n\t      ios: {\n\t        algorithm: 'YIN',\n\t        bufferSize: 1024,\n\t      },\n\t    };\n\t  }\n\t  /**\n\t   * Get current audio permission\n\t   * @returns Promise<boolean>\n", "   */\n\t  private async hasPermissions(): Promise<boolean> {\n\t    return !!(await Permissions.audio());\n\t  }\n\t  /**\n\t   * Get current status\n\t   * @returns Promise<boolean>\n\t   */\n\t  async isRecording(): Promise<boolean> {\n\t    try {\n", "      const status = await this.module?.isRecording();\n\t      return !!status;\n\t    } catch (err) {\n\t      console.warn(err);\n\t      return false;\n\t    }\n\t  }\n\t  /**\n\t   * Trigger audio recording and pitch detection with provided configs\n\t   * @param config\n", "   * @returns Promise<void>\n\t   */\n\t  async start(config?: PitchDetectorConfig): Promise<void> {\n\t    try {\n\t      const permission = await this.hasPermissions();\n\t      if (!permission) {\n\t        throw new PitchDetectorError(PitchDetectorErrors.PERMISSIONS_ERROR);\n\t      }\n\t      const configuration = merge<PitchDetectorConfig>(\n\t        this.getDefaultConfig(),\n", "        config ?? {}\n\t      );\n\t      const params = Platform.select({\n\t        android: configuration.android as unknown,\n\t        ios: configuration.ios as unknown,\n\t      }) as PitchDetectorIOSConfig | PitchDetectorAndroidConfig;\n\t      await this.module?.start(params);\n\t    } catch (err: unknown) {\n\t      console.warn(err);\n\t    }\n", "  }\n\t  /**\n\t   * Stop audio recording and pitch detection\n\t   * @returns Promise<void>\n\t   */\n\t  async stop(): Promise<void> {\n\t    try {\n\t      await this.module?.stop();\n\t    } catch (err: unknown) {\n\t      console.warn(err);\n", "    }\n\t  }\n\t  /**\n\t   * Register a event listener\n\t   */\n\t  addListener(callback: Callback): Subscription {\n\t    return this.event?.addListener('data', callback);\n\t  }\n\t  /**\n\t   * Method event listeners\n", "   * @alias removeAllListeners\n\t   */\n\t  removeListener(): void {\n\t    this.event?.removeAllListeners('data');\n\t  }\n\t  /**\n\t   * Method remove all event listeners\n\t   */\n\t  removeAllListeners(): void {\n\t    this.event?.removeAllListeners('data');\n", "  }\n\t}\n\t/**\n\t * Export an instance of InternalPitchDetector\n\t */\n\texport const PitchDetector = new InternalPitchDetector();\n"]}
{"filename": "src/internal/pitch-detector/__tests__/pitch-detector.spec.ts", "chunked_list": ["import { NativeModules } from 'react-native';\n\timport { PitchDetectorErrors } from '../../../types';\n\timport { PitchDetectorError } from '../../erros';\n\timport { Permissions } from '../../permissions';\n\timport { PitchDetector } from '..';\n\tconst Module = NativeModules.PitchDetectorModule;\n\tconst asyncMock = <T>(value: T) => jest.fn().mockResolvedValue(value);\n\tconst asyncMockThrow = <T>(error: T) =>\n\t  jest.fn().mockImplementation(() => {\n\t    throw error;\n", "  });\n\tdescribe('PitchDetector', () => {\n\t  beforeEach(() => jest.clearAllMocks());\n\t  it.each([\n\t    ['start', 1],\n\t    ['isRecording', 1],\n\t    ['stop', 1],\n\t  ])(\n\t    'should call %s method %s time(s) from native module',\n\t    async (method: string, times: number) => {\n", "      const spy = jest.spyOn(Module, method as any);\n\t      await Object(PitchDetector)[method]();\n\t      expect(spy).toBeCalledTimes(times);\n\t    }\n\t  );\n\t  it.each([\n\t    ['hasPermissions', 'start'],\n\t    ['getDefaultConfig', 'start'],\n\t  ])(\n\t    'should call %s method when %s method will be called',\n", "    async (target: string, method: string) => {\n\t      const spy = jest.spyOn(PitchDetector, target as any);\n\t      await Object(PitchDetector)[method]();\n\t      expect(spy).toBeCalledTimes(1);\n\t    }\n\t  );\n\t  it('should call audio permission method when start method will be called', async () => {\n\t    const spy = jest.spyOn(Permissions, 'audio');\n\t    await PitchDetector.start();\n\t    expect(spy).toBeCalledTimes(1);\n", "  });\n\t  it('should throw error when start method will be called and not have audio record permission', async () => {\n\t    const error = new PitchDetectorError(PitchDetectorErrors.PERMISSIONS_ERROR);\n\t    const spy = jest.spyOn(console, 'warn');\n\t    Permissions.audio = asyncMock(false);\n\t    await PitchDetector.start();\n\t    expect(spy).toBeCalledTimes(1);\n\t    expect(spy).toHaveBeenCalledWith(error);\n\t  });\n\t  it.each([\n", "    ['addListener', 'addListener'],\n\t    ['removeAllListeners', 'removeAllListeners'],\n\t    ['removeAllListeners', 'removeListener'],\n\t  ])(\n\t    'should call %s method from event emitter when %s method will be called',\n\t    async (target: string, method: string) => {\n\t      const spy = jest.spyOn(Object(PitchDetector).event, target as any);\n\t      await Object(PitchDetector)[method](1);\n\t      expect(spy).toBeCalledTimes(1);\n\t    }\n", "  );\n\t  it.each([['start'], ['stop'], ['isRecording']])(\n\t    'should throw error when native %s method fail',\n\t    async (method: string) => {\n\t      const error = new Error('Some error message');\n\t      const spy = jest.spyOn(console, 'warn');\n\t      Permissions.audio = asyncMock(true);\n\t      Object(PitchDetector).module[method] = asyncMockThrow(error);\n\t      await Object(PitchDetector)[method]();\n\t      expect(spy).toBeCalledTimes(1);\n", "      expect(spy).toBeCalledWith(error);\n\t    }\n\t  );\n\t});\n"]}
{"filename": "src/internal/utils/index.ts", "chunked_list": ["/**\n\t * Simple object check.\n\t * @param item\n\t * @returns {boolean}\n\t */\n\texport function isObject(item: any) {\n\t  return Boolean(\n\t    item &&\n\t      typeof item === 'object' &&\n\t      !Array.isArray(item) &&\n", "      !(item instanceof Date)\n\t  );\n\t}\n\t/**\n\t * Deep merge two objects.\n\t * @param target\n\t * @param ...sources\n\t */\n\texport function merge<T>(target: any, ...sources: any): T {\n\t  if (!sources.length) return target;\n", "  const source = sources.shift();\n\t  if (isObject(target) && isObject(source)) {\n\t    for (const key in source) {\n\t      if (isObject(source[key])) {\n\t        if (!target[key]) Object.assign(target, { [key]: {} });\n\t        merge(target[key], source[key]);\n\t      } else {\n\t        Object.assign(target, { [key]: source[key] });\n\t      }\n\t    }\n", "  }\n\t  return merge(target, ...sources);\n\t}\n"]}
{"filename": "src/internal/utils/__tests__/utils.spec.ts", "chunked_list": ["import { isObject, merge } from '..';\n\tdescribe('Utils', () => {\n\t  it.each([\n\t    [false, 'array', []],\n\t    [false, 'NaN', NaN],\n\t    [false, 'number', 10],\n\t    [false, 'symbol', Symbol()],\n\t    [false, 'date', new Date()],\n\t    [true, 'object', {}],\n\t  ])(\n", "    'should return %s when isObject function will be called with %s',\n\t    (expected: boolean, _: string, params: any) => {\n\t      const result = isObject(params);\n\t      expect(result).toBe(expected);\n\t    }\n\t  );\n\t  it('should not merge when one params is not object', () => {\n\t    const result = merge({ name: 'Fábio' }, NaN);\n\t    expect(result).toHaveProperty('name');\n\t  });\n", "  it('should merge two complex object', () => {\n\t    const obj1 = {\n\t      person: {\n\t        name: 'Fábio',\n\t        address: {\n\t          street: { name: 'Street name', number: 'Street number' },\n\t          city: { name: 'City name' },\n\t        },\n\t      },\n\t    };\n", "    const obj2 = {\n\t      person: {\n\t        age: 29,\n\t        address: {\n\t          city: { postalCode: 1212000, name: 'City name 2' },\n\t          coords: {\n\t            lat: 0,\n\t            lgn: 0,\n\t          },\n\t        },\n", "      },\n\t    };\n\t    const result: any = merge(obj1, obj2);\n\t    expect(result.person).toHaveProperty('name');\n\t    expect(result.person).toHaveProperty('age');\n\t    expect(result.person.address.street).toHaveProperty('name');\n\t    expect(result.person.address.street).toHaveProperty('number');\n\t    expect(result.person.address.city).toHaveProperty('name');\n\t    expect(result.person.address.city).toHaveProperty('postalCode');\n\t    expect(result.person.address.coords).toHaveProperty('lat');\n", "    expect(result.person.address.coords).toHaveProperty('lgn');\n\t    expect(result.person.address.city.name).toBe(obj2.person.address.city.name);\n\t  });\n\t});\n"]}
{"filename": "src/internal/permissions/index.ts", "chunked_list": ["import { Platform } from 'react-native';\n\timport {\n\t  PERMISSIONS,\n\t  Permission,\n\t  PermissionStatus,\n\t  RESULTS,\n\t} from 'react-native-permissions';\n\timport Factory from './factory';\n\texport const isDenied = (status: PermissionStatus) => status === RESULTS.DENIED;\n\texport const isGranted = (status: PermissionStatus) =>\n", "  status === RESULTS.GRANTED;\n\texport const isBlocked = (status: PermissionStatus) =>\n\t  status === RESULTS.BLOCKED;\n\texport const isLimited = (status: PermissionStatus) =>\n\t  status === RESULTS.LIMITED;\n\texport const isUnavailable = (status: PermissionStatus) =>\n\t  status === RESULTS.UNAVAILABLE;\n\texport class Permissions {\n\t  static async audio() {\n\t    const MICROPHONE_PERMISSION = Platform.select({\n", "      android: PERMISSIONS.ANDROID.RECORD_AUDIO,\n\t      ios: PERMISSIONS.IOS.MICROPHONE,\n\t    }) as Permission;\n\t    const rationale = {\n\t      title: 'Acesso ao microfone',\n\t      message: 'Para que possamos executar',\n\t      buttonPositive: 'Permitir',\n\t      buttonNegative: 'Negar',\n\t    };\n\t    const audio = Factory(MICROPHONE_PERMISSION, 'AUDIO PERMISSION:');\n", "    const denied = await audio.CheckPermission(isDenied);\n\t    const blocked = await audio.CheckPermission(isBlocked);\n\t    if (denied || blocked) {\n\t      return await audio.RequestPermission(rationale, isGranted);\n\t    }\n\t    return await audio.CheckPermission(isGranted);\n\t  }\n\t}\n"]}
{"filename": "src/internal/permissions/factory/index.ts", "chunked_list": ["import {\n\t  check,\n\t  Permission,\n\t  Rationale,\n\t  request,\n\t  RESULTS,\n\t} from 'react-native-permissions';\n\timport type { Comparable, PermissionsHandlers, Response } from '../../../types';\n\tconst BLOCKED = 'Permission is denied and not requestable anymore';\n\tconst DENIED = \"Permission hasn't been requested / is denied but requestable\";\n", "const GRANTED = 'Permission is granted';\n\tconst LIMITED = 'Permission is limited: some actions are possible';\n\tconst UNAVAILABLE = 'This feature is not available.';\n\tconst MESSAGES = new Map<string, string>([\n\t  [RESULTS.BLOCKED, BLOCKED],\n\t  [RESULTS.DENIED, DENIED],\n\t  [RESULTS.GRANTED, GRANTED],\n\t  [RESULTS.LIMITED, LIMITED],\n\t  [RESULTS.UNAVAILABLE, UNAVAILABLE],\n\t]);\n", "export default (\n\t  targetPermission: Permission,\n\t  TAG: string\n\t): PermissionsHandlers => {\n\t  const CheckPermission = async (compare?: Comparable): Response => {\n\t    try {\n\t      const result = await check(targetPermission);\n\t      console.log(TAG, MESSAGES.get(result));\n\t      return compare ? compare(result) : result;\n\t    } catch (error: any) {\n", "      console.log(TAG, error.message);\n\t      return null;\n\t    }\n\t  };\n\t  const RequestPermission = async (\n\t    rationale?: Rationale,\n\t    compare?: Comparable\n\t  ): Response => {\n\t    try {\n\t      const result = await request(targetPermission, rationale);\n", "      console.log(TAG, MESSAGES.get(result));\n\t      return compare ? compare(result) : result;\n\t    } catch (error: any) {\n\t      console.log(TAG, error.message);\n\t      return null;\n\t    }\n\t  };\n\t  return { CheckPermission, RequestPermission };\n\t};\n"]}
{"filename": "src/internal/permissions/__tests__/permissions.spec.ts", "chunked_list": ["import { PermissionStatus } from 'react-native-permissions';\n\timport {\n\t  isBlocked,\n\t  isDenied,\n\t  isGranted,\n\t  isLimited,\n\t  isUnavailable,\n\t} from '../../permissions';\n\tdescribe('Permissions', () => {\n\t  it.each([\n", "    ['isBlocked', 'blocked', true, isBlocked],\n\t    ['isDenied', 'denied', true, isDenied],\n\t    ['isGranted', 'granted', true, isGranted],\n\t    ['isLimited', 'limited', true, isLimited],\n\t    ['isUnavailable', 'unavailable', true, isUnavailable],\n\t  ])(\n\t    'should call %s function and return %s',\n\t    (\n\t      _: string,\n\t      params: any,\n", "      expected: boolean,\n\t      fn: (status: PermissionStatus) => boolean\n\t    ) => {\n\t      const result = fn(params);\n\t      expect(result).toBe(expected);\n\t    }\n\t  );\n\t});\n"]}
{"filename": "src/internal/erros/index.ts", "chunked_list": ["import { Platform } from 'react-native';\n\timport { PitchDetectorErrors } from '../../types';\n\tconst base =\n\t  `The package 'react-native-pitch-detector' find a error. Make sure: \\n\\n` +\n\t  '- You rebuilt the app after installing the package\\n' +\n\t  '- You are not using Expo Go\\n';\n\tconst linking =\n\t  `The package 'react-native-pitch-detector' doesn't seem to be linked. Make sure: \\n\\n` +\n\t  Platform.select({\n\t    ios: \"- You have run 'pod install'\\n\",\n", "    android: '',\n\t  }) +\n\t  '- You rebuilt the app after installing the package\\n' +\n\t  '- You are not using Expo Go\\n';\n\tconst permission =\n\t  `The package 'react-native-pitch-detector' need audio record permission. Make sure: \\n\\n` +\n\t  Platform.select({\n\t    ios: '- You have added Microphone access permission before start record.',\n\t    android: `- You have added '<uses-permission android:name=\"android.permission.RECORD_AUDIO\" />' on AndroidManifest.xml and request permission before start record.\\n`,\n\t  });\n", "export class PitchDetectorError {\n\t  constructor(type: PitchDetectorErrors) {\n\t    if (type === PitchDetectorErrors.LINKING_ERROR) {\n\t      return new Error(linking);\n\t    }\n\t    if (type === PitchDetectorErrors.PERMISSIONS_ERROR) {\n\t      return new Error(permission);\n\t    }\n\t    return new Error(base);\n\t  }\n", "}\n"]}
{"filename": "src/internal/erros/__tests__/errors.spec.ts", "chunked_list": ["import { PitchDetectorErrors } from '../../../types';\n\timport { PitchDetectorError } from '..';\n\tdescribe('Errors', () => {\n\t  it('should create base error', () => {\n\t    const error: any = new PitchDetectorError(PitchDetectorErrors.BASE);\n\t    expect(error?.message).toMatch(/You are not using Expo Go/);\n\t    expect(error?.message).toMatch(\n\t      /You rebuilt the app after installing the package/\n\t    );\n\t  });\n", "  it('should create link error', () => {\n\t    const error: any = new PitchDetectorError(\n\t      PitchDetectorErrors.LINKING_ERROR\n\t    );\n\t    expect(error?.message).toMatch(/doesn't seem to be linked/);\n\t  });\n\t  it('should create permission error', () => {\n\t    const error: any = new PitchDetectorError(\n\t      PitchDetectorErrors.PERMISSIONS_ERROR\n\t    );\n", "    expect(error?.message).toMatch(/need audio record permission/);\n\t  });\n\t});\n"]}
