{"filename": "src/parameters.ts", "chunked_list": ["import { GPT_3_5_TURBO, GPT_4, Model } from \"./openai\";\n\tconst args = process.argv.slice(2); // Remove the first two elements (Node.js executable and script path)\n\texport const numberOfAgents = args.length > 0 ? parseInt(args[0]) : 1;\n\tconsole.log(`Number of agents: ${numberOfAgents}`);\n\tconst modelText = args.length > 1 ? args[1] : \"gpt-3.5-turbo\";\n\texport let model: Model;\n\tswitch (modelText) {\n\t  case GPT_3_5_TURBO:\n\t  case GPT_4:\n\t    model = modelText;\n", "    break;\n\t  default:\n\t    throw Error(`Unrecognized OpenAI model: '${modelText}'`);\n\t}\n\tconsole.log(`Model: ${model}`);\n"]}
{"filename": "src/task-queue.ts", "chunked_list": ["type Task<T = void> = () => Promise<T>;\n\texport default class TaskQueue {\n\t  private tasks: Task[] = [];\n\t  private running: Promise<void> | undefined;\n\t  private intervals: NodeJS.Timer[] = [];\n\t  get length() {\n\t    return this.tasks.length;\n\t  }\n\t  run<T>(task: Task<T>): Promise<T> {\n\t    return new Promise((resolve, reject) => {\n", "      this.tasks.push(() => task().then(resolve).catch(reject));\n\t      this.runNext();\n\t    });\n\t  }\n\t  runPeriodically(task: Task, milliseconds: number): void {\n\t    let pending = false;\n\t    this.intervals.push(\n\t      setInterval(() => {\n\t        if (pending) return;\n\t        pending = true;\n", "        this.run(task).finally(() => {\n\t          pending = false;\n\t        });\n\t      }, milliseconds)\n\t    );\n\t  }\n\t  async stop() {\n\t    this.tasks.length = 0;\n\t    this.intervals.forEach(clearInterval);\n\t    this.intervals = [];\n", "    if (this.running) {\n\t      await this.running;\n\t    }\n\t  }\n\t  private async runNext() {\n\t    if (this.running) return;\n\t    const task = this.tasks.shift();\n\t    if (!task) return;\n\t    try {\n\t      await (this.running = task());\n", "    } finally {\n\t      this.running = undefined;\n\t    }\n\t    this.runNext();\n\t  }\n\t}\n"]}
{"filename": "src/make-decision.ts", "chunked_list": ["import { ChatCompletionRequestMessage } from \"openai\";\n\timport { Event } from \"./memory\";\n\timport { createChatCompletion } from \"./openai\";\n\timport { model } from \"./parameters\";\n\timport { messageSourceName } from \"./util\";\n\texport default async function makeDecision(events: Event[]): Promise<string> {\n\t  console.log(`Reflecting on ${events.length} events...`);\n\t  const t0 = Date.now();\n\t  const messages = events.map(toOpenAiMessage);\n\t  // console.log(JSON.stringify(messages, null, 2));\n", "  const responseContent = await createChatCompletion({\n\t    model,\n\t    messages,\n\t    temperature: 0.0,\n\t  });\n\t  console.log(\n\t    `Arrived at a decision after ${((Date.now() - t0) / 1000).toFixed(1)}s`\n\t  );\n\t  return responseContent;\n\t}\n", "// lazy load to avoid accessing OPENAI_API_KEY before env has been loaded\n\texport function toOpenAiMessage(event: Event): ChatCompletionRequestMessage {\n\t  switch (event.type) {\n\t    case \"message\": {\n\t      const { type: messageType, source, content } = event.message;\n\t      const role = source.type === \"system\" ? \"system\" : \"user\";\n\t      let header: string;\n\t      switch (messageType) {\n\t        case \"spontaneous\":\n\t        case \"ok\":\n", "          header = \"\";\n\t          break;\n\t        case \"agentToAgent\":\n\t          header = `--- MESSAGE FROM ${messageSourceName(\n\t            source\n\t          ).toUpperCase()} ---\\n\\n`;\n\t          break;\n\t        case \"error\":\n\t          header = \"--- ERROR ---\\n\\n\";\n\t          break;\n", "      }\n\t      return {\n\t        role,\n\t        content: `${header}${content}`,\n\t      };\n\t    }\n\t    case \"decision\":\n\t      return {\n\t        role: \"assistant\",\n\t        content: event.actionText,\n", "      };\n\t  }\n\t}\n"]}
{"filename": "src/in-memory-message-bus.ts", "chunked_list": ["import { EventEmitter } from \"events\";\n\timport { MessageBus } from \"./message-bus\";\n\timport { Message } from \"./message\";\n\texport class InMemoryMessageBus implements MessageBus {\n\t  private emitter: EventEmitter;\n\t  constructor() {\n\t    this.emitter = new EventEmitter();\n\t  }\n\t  subscribe(listener: (message: Message) => void): void {\n\t    this.emitter.on(\"message\", listener);\n", "  }\n\t  unsubscribe(listener: (message: Message) => void): void {\n\t    this.emitter.off(\"message\", listener);\n\t  }\n\t  send(message: Message): void {\n\t    this.emitter.emit(\"message\", message);\n\t  }\n\t}\n"]}
{"filename": "src/main.ts", "chunked_list": ["import dotenv from \"dotenv\";\n\timport ActionHandler from \"./action-handler\";\n\timport { Agent } from \"./agent\";\n\timport { startConsole } from \"./console\";\n\timport { InMemoryMessageBus } from \"./in-memory-message-bus\";\n\timport { Event, Memory } from \"./memory\";\n\timport { MessageBus } from \"./message-bus\";\n\timport core from \"./module/definitions/core\";\n\timport filesystem from \"./module/definitions/filesystem\";\n\timport goals from \"./module/definitions/goals\";\n", "import messaging from \"./module/definitions/messaging\";\n\timport notes from \"./module/definitions/notes\";\n\timport web from \"./module/definitions/web\";\n\timport { ModuleManager } from \"./module/module-manager\";\n\timport { contextWindowSize } from \"./openai\";\n\timport { model, numberOfAgents } from \"./parameters\";\n\timport FileStore from \"./store/file-store\";\n\timport JsonStore from \"./store/json-store\";\n\timport { webSocketServer } from \"./web-socket-server\";\n\tdotenv.config();\n", "const agentIds = Array.from({ length: numberOfAgents + 1 }, (_, i) => `${i}`);\n\tconst messageBus: MessageBus = new InMemoryMessageBus();\n\tmain();\n\tasync function main() {\n\t  startConsole(agentIds, messageBus);\n\t  webSocketServer(messageBus, 8080);\n\t  for (const id of agentIds.slice(1)) {\n\t    const moduleManager = new ModuleManager(id, agentIds, [\n\t      core,\n\t      goals,\n", "      notes,\n\t      messaging,\n\t      filesystem,\n\t      web,\n\t    ]);\n\t    const actionHandler = new ActionHandler(\n\t      agentIds,\n\t      messageBus,\n\t      moduleManager\n\t    );\n", "    const store = new JsonStore<Event[]>(new FileStore([id]));\n\t    // We have to leave room for the agent's next action, which is of unknown size\n\t    const compressionThreshold = Math.round(contextWindowSize[model] * 0.75);\n\t    const memory = new Memory(id, moduleManager, store, compressionThreshold);\n\t    const agent = new Agent(\n\t      id,\n\t      memory,\n\t      messageBus,\n\t      moduleManager,\n\t      actionHandler\n", "    );\n\t    await agent.start();\n\t  }\n\t}\n"]}
{"filename": "src/task-queue.test.ts", "chunked_list": ["import TaskQueue from \"./task-queue\";\n\timport { sleep } from \"./util\";\n\tdescribe(\"TaskQueue\", () => {\n\t  let taskQueue: TaskQueue;\n\t  beforeEach(() => {\n\t    taskQueue = new TaskQueue();\n\t  });\n\t  afterEach(() => taskQueue.stop());\n\t  describe(\"run\", () => {\n\t    it(\"should run tasks in serial\", async () => {\n", "      const results: number[] = [];\n\t      const task1 = async () => {\n\t        await sleep(100);\n\t        results.push(1);\n\t      };\n\t      const task2 = async () => {\n\t        results.push(2);\n\t      };\n\t      await Promise.all([taskQueue.run(task1), taskQueue.run(task2)]);\n\t      expect(results).toEqual([1, 2]);\n", "    });\n\t  });\n\t  describe(\"runPeriodically\", () => {\n\t    it(\"should skip re-scheduling task if still pending\", async () => {\n\t      let numTasksRun = 0;\n\t      const periodicTask = async () => {\n\t        await sleep(100);\n\t        numTasksRun++;\n\t      };\n\t      taskQueue.runPeriodically(periodicTask, 10);\n", "      await sleep(500);\n\t      expect(taskQueue.length).toBeLessThanOrEqual(1);\n\t      expect(numTasksRun).toBeGreaterThanOrEqual(3);\n\t      expect(numTasksRun).toBeLessThanOrEqual(5);\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/web-socket-server.ts", "chunked_list": ["import WebSocket from \"ws\";\n\timport { MessageBus } from \"./message-bus\";\n\texport const webSocketServer = (messageBus: MessageBus, port: number) => {\n\t  const wss = new WebSocket.Server({ port });\n\t  messageBus.subscribe((message) => {\n\t    wss.clients.forEach((client: WebSocket) => {\n\t      if (client.readyState === WebSocket.OPEN) {\n\t        client.send(JSON.stringify(message));\n\t      }\n\t    });\n", "  });\n\t  wss.on(\"connection\", (ws: WebSocket) => {\n\t    console.log(\"WebSocket client connected\");\n\t    ws.on(\"message\", (message: string) => {\n\t      console.log(\"Received: %s\", message);\n\t    });\n\t    ws.on(\"close\", () => {\n\t      console.log(\"WebSocket client disconnected\");\n\t    });\n\t  });\n", "};\n"]}
{"filename": "src/console.ts", "chunked_list": ["import readline from \"readline\";\n\timport { messageBuilder } from \"./message\";\n\timport { MessageBus } from \"./message-bus\";\n\tconst AGENT_ID = \"0\";\n\tconst rl = readline.createInterface({\n\t  input: process.stdin,\n\t  output: process.stdout,\n\t  prompt: \"$ \",\n\t});\n\texport function startConsole(agentIds: string[], messageBus: MessageBus) {\n", "  messageBus.subscribe((message) => {\n\t    if (message.targetAgentIds && !message.targetAgentIds.includes(AGENT_ID))\n\t      return;\n\t    console.log(`\\n${message.content}\\n`);\n\t    rl.prompt();\n\t  });\n\t  rl.on(\"line\", (input) => {\n\t    const colonIndex = -1; //input.indexOf(\":\");\n\t    let targetAgentIds: string[];\n\t    let content: string;\n", "    if (colonIndex >= 0) {\n\t      targetAgentIds = [input.substring(0, colonIndex)];\n\t      content = input.substring(colonIndex + 1);\n\t    } else {\n\t      targetAgentIds = agentIds.filter((id) => id !== AGENT_ID);\n\t      content = input;\n\t    }\n\t    if (content)\n\t      messageBus.send(\n\t        messageBuilder.agentToAgent(AGENT_ID, targetAgentIds, content)\n", "      );\n\t    rl.prompt();\n\t  });\n\t  // Display the initial prompt\n\t  rl.prompt();\n\t}\n"]}
{"filename": "src/message.ts", "chunked_list": ["export interface Message {\n\t  type: MessageType;\n\t  source: MessageSource;\n\t  targetAgentIds: string[];\n\t  content: string;\n\t}\n\ttype TypelessMessage = Omit<Message, \"type\">;\n\texport type MessageType = keyof typeof messageBuilder;\n\texport type MessageSource = SystemMessageSource | AgentMessageSource;\n\tinterface MessageSourceBase {\n", "  id?: string;\n\t}\n\tinterface SystemMessageSource extends MessageSourceBase {\n\t  type: \"system\";\n\t  id?: undefined;\n\t}\n\tinterface AgentMessageSource extends MessageSourceBase {\n\t  type: \"agent\";\n\t  id: string;\n\t}\n", "export const systemSource: SystemMessageSource = { type: \"system\" };\n\texport const agentSource = (id: string): AgentMessageSource => ({\n\t  type: \"agent\",\n\t  id,\n\t});\n\texport const CODE_BLOCK_DELIMITER = \"```\";\n\texport const messageBuilder = addMessageTypes({\n\t  spontaneous: singleTargetSystemMessage,\n\t  ok: singleTargetSystemMessage,\n\t  error: singleTargetSystemMessage,\n", "  agentToAgent: (\n\t    sourceAgentId: string,\n\t    targetAgentIds: string[],\n\t    content: string\n\t  ) => ({\n\t    source: agentSource(sourceAgentId),\n\t    targetAgentIds,\n\t    content,\n\t  }),\n\t});\n", "function addMessageTypes<\n\t  T extends Record<string, (...args: any) => TypelessMessage>\n\t>(record: T): { [K in keyof T]: (...args: Parameters<T[K]>) => Message } {\n\t  for (const [type, builder] of Object.entries(record)) {\n\t    (record as any)[type] = (...args: any) => ({\n\t      type,\n\t      ...(builder as any)(...args),\n\t    });\n\t  }\n\t  return record as any;\n", "}\n\tfunction singleTargetSystemMessage(\n\t  agentId: string,\n\t  content: string\n\t): TypelessMessage {\n\t  return {\n\t    source: systemSource,\n\t    targetAgentIds: [agentId],\n\t    content,\n\t  };\n", "}\n"]}
{"filename": "src/redis-message-bus.ts", "chunked_list": ["import { createClient, RedisClientType } from \"redis\";\n\timport { MessageBus } from \"./message-bus\";\n\timport { Message } from \"./message\";\n\texport class RedisMessageBus implements MessageBus {\n\t  private publisher: RedisClientType;\n\t  private subscriber: RedisClientType;\n\t  private channel = \"messages\";\n\t  constructor() {\n\t    this.publisher = createClient();\n\t    this.subscriber = createClient();\n", "  }\n\t  subscribe(listener: (message: Message) => void): void {\n\t    this.subscriber.on(\"message\", (channel, message) => {\n\t      if (channel === this.channel) {\n\t        listener(JSON.parse(message));\n\t      }\n\t    });\n\t    this.subscriber.subscribe(this.channel, () => {});\n\t  }\n\t  unsubscribe(listener: (message: Message) => void): void {\n", "    this.subscriber.removeListener(\"message\", listener);\n\t    this.subscriber.unsubscribe(this.channel, () => {});\n\t  }\n\t  send(message: Message): void {\n\t    this.publisher.publish(this.channel, JSON.stringify(message));\n\t  }\n\t}\n"]}
{"filename": "src/openai.ts", "chunked_list": ["import { AxiosError, AxiosRequestConfig } from \"axios\";\n\timport { memoize } from \"lodash\";\n\timport { Configuration, CreateChatCompletionRequest, OpenAIApi } from \"openai\";\n\texport const GPT_3_5_TURBO = \"gpt-3.5-turbo\";\n\texport const GPT_4 = \"gpt-4\";\n\texport const contextWindowSize = {\n\t  [GPT_3_5_TURBO]: 4000,\n\t  [GPT_4]: 8000,\n\t};\n\texport type Model = typeof GPT_3_5_TURBO | typeof GPT_4;\n", "export async function createChatCompletion(\n\t  request: CreateChatCompletionRequest,\n\t  options?: AxiosRequestConfig\n\t): Promise<string> {\n\t  try {\n\t    const response = await openai().createChatCompletion(request, options);\n\t    return response.data.choices[0].message!.content;\n\t  } catch (e) {\n\t    const { response } = e as AxiosError;\n\t    switch (response?.status) {\n", "      case 400:\n\t        throw Error(`Context window is full.`);\n\t      case 404:\n\t        throw Error(`Model '${request.model}' is unavailable.`);\n\t      case 429:\n\t        throw Error(`OpenAI rate limited.`);\n\t      default:\n\t        throw e;\n\t    }\n\t  }\n", "}\n\t// lazy load to avoid accessing OPENAI_API_KEY before env has been loaded\n\tconst openai = memoize(() => {\n\t  const apiKey = process.env.OPENAI_API_KEY;\n\t  if (!apiKey) throw Error(\"OPENAI_API_KEY is not configured!\");\n\t  const configuration = new Configuration({\n\t    apiKey: process.env.OPENAI_API_KEY,\n\t  });\n\t  return new OpenAIApi(configuration);\n\t});\n"]}
{"filename": "src/message-bus.ts", "chunked_list": ["import { Message } from \"./message\";\n\texport interface MessageBus {\n\t  subscribe(listener: (message: Message) => void): void;\n\t  unsubscribe(listener: (message: Message) => void): void;\n\t  send(message: Message): void;\n\t}\n"]}
{"filename": "src/parse-action.ts", "chunked_list": ["import { CODE_BLOCK_DELIMITER } from \"./message\";\n\timport { ActionDefinition } from \"./module/action-definition\";\n\timport { getUsageText } from \"./module/util\";\n\timport { MULTILINE_DELIMITER } from \"./util\";\n\ttype ParseResult =\n\t  | {\n\t      type: \"success\";\n\t      action: Action;\n\t    }\n\t  | { type: \"error\"; message: string };\n", "export interface Action {\n\t  actionDef: ActionDefinition;\n\t  thoughts?: string;\n\t  parameters: Record<string, string>;\n\t}\n\texport default function parseAction(\n\t  actionDictionary: Map<string, ActionDefinition>,\n\t  text: string\n\t): ParseResult {\n\t  try {\n", "    text = text.trim();\n\t    if (!/^\\S+(?=\\n|$)/.test(text.split(\"\\n\")[0])) {\n\t      return {\n\t        type: \"error\",\n\t        message: `\n\tYour action could not be parsed. Remember to always format your entire response as an action, like this:\n\t${CODE_BLOCK_DELIMITER}\n\t<action name>\n\t<arg 1 name>: <prop value>\n\t<arg 2 name>: <prop value>\n", "...\n\t${CODE_BLOCK_DELIMITER}\n\t`.trim(),\n\t      };\n\t    }\n\t    text = `name: ${text}`;\n\t    const jsonText =\n\t      \"{\" +\n\t      text\n\t        .split(MULTILINE_DELIMITER)\n", "        .map((part) => part.trim())\n\t        .map((part, i) => {\n\t          if (i % 2 === 0) return part;\n\t          return JSON.stringify(part) + \"\\n\";\n\t        })\n\t        .join(\"\")\n\t        .split(\"\\n\")\n\t        .filter(Boolean)\n\t        .map((line) => {\n\t          const colonIndex = line.indexOf(\":\");\n", "          if (colonIndex < 0)\n\t            throw new Error(\n\t              `Your action could not be parsed. Did you fail to wrap the entirety of a multi-line parameter value with the multi-line delimiter (\\`${MULTILINE_DELIMITER}\\`)?`\n\t            );\n\t          const key = line.substring(0, colonIndex).trim();\n\t          let value = line.substring(colonIndex + 1).trim();\n\t          if (!value.startsWith('\"') || !value.endsWith('\"'))\n\t            value = JSON.stringify(value);\n\t          return `\"${key}\": ${value}`;\n\t        })\n", "        .join(\",\") +\n\t      \"}\";\n\t    const { name, thoughts, ...parameters } = JSON.parse(jsonText);\n\t    const actionDef = actionDictionary.get(name);\n\t    if (!actionDef)\n\t      return {\n\t        type: \"error\",\n\t        message: `Unknown action \\`${name}\\`. Please refer to the list of available actions given in the introductory message.`,\n\t      };\n\t    const missingProps = Object.entries(actionDef.parameters)\n", "      .filter(\n\t        ([name, parameterDef]) =>\n\t          !parameterDef.optional && !(name in parameters)\n\t      )\n\t      .map(([name]) => name);\n\t    if (missingProps.length) {\n\t      return {\n\t        type: \"error\",\n\t        message: `Missing required parameter${\n\t          missingProps.length > 1 ? \"s\" : \"\"\n", "        } ${missingProps.map((p) => `\\`${p}\\``)}. ${getUsageText(actionDef)}`,\n\t      };\n\t    }\n\t    const extraProps = Object.keys(parameters).filter(\n\t      (p) => !(p in actionDef.parameters)\n\t    );\n\t    if (extraProps.length) {\n\t      return {\n\t        type: \"error\",\n\t        message: `Extraneous parameter${\n", "          extraProps.length > 1 ? \"s\" : \"\"\n\t        } ${extraProps.map((p) => `\\`${p}\\``)}. ${getUsageText(actionDef)}`,\n\t      };\n\t    }\n\t    return { type: \"success\", action: { actionDef, thoughts, parameters } };\n\t  } catch (e: any) {\n\t    return {\n\t      type: \"error\",\n\t      message: e.message,\n\t    };\n", "  }\n\t}\n"]}
{"filename": "src/action-handler.ts", "chunked_list": ["import { ModuleManager } from \"./module/module-manager\";\n\timport { MessageBus } from \"./message-bus\";\n\timport { Action } from \"./parse-action\";\n\texport default class ActionHandler {\n\t  constructor(\n\t    private agentIds: string[],\n\t    private messageBus: MessageBus,\n\t    private moduleManager: ModuleManager\n\t  ) {}\n\t  async handle(agentId: string, { actionDef, parameters }: Action) {\n", "    actionDef.execute({\n\t      context: this.moduleManager.getModuleForAction(actionDef.name)!.context,\n\t      parameters,\n\t      sendMessage: (message) => this.messageBus.send(message),\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/agent.ts", "chunked_list": ["import { last } from \"lodash\";\n\timport ActionHandler from \"./action-handler\";\n\timport makeDecision from \"./make-decision\";\n\timport { Memory } from \"./memory\";\n\timport { messageBuilder } from \"./message\";\n\timport { MessageBus } from \"./message-bus\";\n\timport { ModuleManager } from \"./module/module-manager\";\n\timport parseAction from \"./parse-action\";\n\timport TaskQueue from \"./task-queue\";\n\timport { agentName, sleep } from \"./util\";\n", "const actionInterval = 1000;\n\t// const heartbeatInterval = 60 * 1000;\n\texport class Agent {\n\t  constructor(\n\t    public id: string,\n\t    private memory: Memory,\n\t    private messageBus: MessageBus,\n\t    private moduleManager: ModuleManager,\n\t    private actionHandler: ActionHandler\n\t  ) {}\n", "  private taskQueue = new TaskQueue();\n\t  // Start this Agent's event loop\n\t  async start() {\n\t    // Subscribe to messages\n\t    this.messageBus.subscribe((message) => {\n\t      if (message.targetAgentIds && !message.targetAgentIds.includes(this.id))\n\t        return;\n\t      this.memory.append({ type: \"message\", message });\n\t    });\n\t    // Act on messages periodically\n", "    this.taskQueue.runPeriodically(() => this.takeAction(), actionInterval);\n\t    // Start heartbeat\n\t    // this.taskQueue.runPeriodically(async () => {\n\t    //   const messages = await this.memory.retrieve();\n\t    //   const lastMessage = last(messages);\n\t    //   if (lastMessage?.type === \"decision\") {\n\t    //     this.messageBus.send(\n\t    //       messageBuilder.spontaneous(\n\t    //         this.id,\n\t    //         \"This is your regularly scheduled heartbeat message. Is there anything you need to do?\"\n", "    //       )\n\t    //     );\n\t    //   }\n\t    // }, heartbeatInterval);\n\t  }\n\t  private async takeAction(): Promise<void> {\n\t    try {\n\t      let events = await this.memory.retrieve();\n\t      // Do not act again if the last event was a decision\n\t      if (last(events)?.type === \"decision\") return;\n", "      const actionText = await makeDecision(events);\n\t      // Reassign events in case summarization occurred\n\t      events = await this.memory.append({\n\t        type: \"decision\",\n\t        actionText,\n\t      });\n\t      const result = parseAction(this.moduleManager.actions, actionText);\n\t      if (result.type === \"error\") {\n\t        this.messageBus.send(messageBuilder.error(this.id, result.message));\n\t      } else {\n", "        await this.actionHandler.handle(this.id, result.action);\n\t      }\n\t    } catch (e) {\n\t      console.error(\n\t        `${agentName(\n\t          this.id\n\t        )} encountered the following problem while attempting to take action:`\n\t      );\n\t      console.error(e);\n\t    } finally {\n", "      if (process.env.AGENT_DELAY) {\n\t        await sleep(parseInt(process.env.AGENT_DELAY));\n\t      }\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/util.ts", "chunked_list": ["import { encode } from \"gpt-3-encoder\";\n\timport { MessageSource } from \"./message\";\n\texport function sleep(milliseconds: number): Promise<void> {\n\t  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n\t}\n\texport function sleepUntil(condition: () => boolean): Promise<void> {\n\t  return new Promise((resolve) => {\n\t    if (condition()) return resolve();\n\t    const interval = setInterval(() => {\n\t      if (condition()) {\n", "        clearInterval(interval);\n\t        resolve();\n\t      }\n\t    }, 1000);\n\t  });\n\t}\n\texport function messageSourceName(source: MessageSource) {\n\t  return source.type === \"system\" ? \"System\" : agentName(source.id);\n\t}\n\texport function agentName(agentId: string) {\n", "  return `${agentId === \"0\" ? \"Control\" : `Agent ${agentId}`}`;\n\t}\n\texport const MULTILINE_DELIMITER = `% ${\"ff9d7713-0bb0-40d4-823c-5a66de48761b\"}`;\n\texport const AVG_WORDS_PER_TOKEN = 0.75;\n\texport const AVG_CHARACTERS_PER_TOKEN = 4;\n\texport function countTokens(text: string) {\n\t  return encode(text).length;\n\t}\n"]}
{"filename": "src/parse-action.test.ts", "chunked_list": ["import core from \"./module/definitions/core\";\n\timport filesystem from \"./module/definitions/filesystem\";\n\timport messaging from \"./module/definitions/messaging\";\n\timport notes from \"./module/definitions/notes\";\n\timport { ModuleManager } from \"./module/module-manager\";\n\timport { getUsageText } from \"./module/util\";\n\timport parseAction, { Action } from \"./parse-action\";\n\timport { MULTILINE_DELIMITER } from \"./util\";\n\tconst moduleManager = new ModuleManager(\n\t  \"1\",\n", "  [\"1\"],\n\t  [core, notes, messaging, filesystem]\n\t);\n\ttest(\"case 1\", () => {\n\t  assertValid(`\n\tsendMessage\n\ttargetAgentId: 0\n\tmessage:\n\t% ff9d7713-0bb0-40d4-823c-5a66de48761b\n\tHello Control, this is Agent 1.\n", "I am sending you a multi-line message.\n\tThis is another line.\n\t% ff9d7713-0bb0-40d4-823c-5a66de48761b\n\t  `);\n\t});\n\ttest(\"case 2\", () => {\n\t  assertValid(`\n\tsendMessage\n\ttargetAgentId: 0\n\tmessage:\n", "% ff9d7713-0bb0-40d4-823c-5a66de48761b\n\tHello Control, this is Agent 1.\n\tHere is a multi-line message:\n\tThis is the first line.\n\tThis is the second line.\n\tThis is the third line.\n\t% ff9d7713-0bb0-40d4-823c-5a66de48761b\n\t    `);\n\t});\n\ttest(\"case 3\", () => {\n", "  assertValid(`\n\twriteFile\n\tpath: ./schema/action-dictionary.json\n\tcontent:\n\t% ff9d7713-0bb0-40d4-823c-5a66de48761b\n\t{\n\t  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n\t  \"type\": \"object\",\n\t  \"title\": \"Action\",\n\t  \"oneOf\": [\n", "    {\n\t      ... the old content of action-dictionary.json ...\n\t    },\n\t    {\n\t      \"title\": \"NewActionDefinition\",\n\t      \"description\": \"This is an example of a new action definition.\",\n\t      \"properties\": {\n\t        \"type\": {\n\t          \"type\": \"string\",\n\t          \"const\": \"new-action-definition\"\n", "        },\n\t        \"exampleArg\": {\n\t          \"type\": \"string\",\n\t          \"description\": \"An example parameter for the new action definition.\"\n\t        }\n\t      },\n\t      \"required\": [\n\t        \"type\",\n\t        \"exampleArg\"\n\t      ],\n", "      \"additionalProperties\": false\n\t    }\n\t  ]\n\t}\n\t% ff9d7713-0bb0-40d4-823c-5a66de48761b\n\t`);\n\t});\n\ttest(\"invalid multiline with no delimiter\", () => {\n\t  expect(\n\t    assertInvalid(`\n", "sendMessage\n\ttargetAgentId: 0\n\tmessage: Hello Control, here's a list of things,\n\t- 9 bottles of ketchup\n\t- 2 pairs of socks\n\t- a very big balloon\n\t  `)\n\t  ).toEqual(\n\t    `Your action could not be parsed. Did you fail to wrap the entirety of a multi-line parameter value with the multi-line delimiter (\\`% ff9d7713-0bb0-40d4-823c-5a66de48761b\\`)?`\n\t  );\n", "});\n\ttest(\"multiline delimiter not starting on its own line\", () => {\n\t  expect(\n\t    assertValid(`\n\tsendMessage\n\ttargetAgentId: 0\n\tmessage: % ff9d7713-0bb0-40d4-823c-5a66de48761b\n\there is a\n\tmulti\n\tline\n", "message\n\t% ff9d7713-0bb0-40d4-823c-5a66de48761b\n\t`).parameters.message\n\t  ).toBe(\n\t    `\n\there is a\n\tmulti\n\tline\n\tmessage\n\t`.trim()\n", "  );\n\t});\n\ttest(\"parameter after multiline parameter\", () => {\n\t  const { parameters, thoughts } = assertValid(`\n\tsendMessage\n\ttargetAgentId: 0\n\tmessage:\n\t% ff9d7713-0bb0-40d4-823c-5a66de48761b\n\tmulti\n\tline\n", "parameter\n\t% ff9d7713-0bb0-40d4-823c-5a66de48761b\n\tthoughts: Trying a multi-line parameter followed by another parameter.\n\t`);\n\t  expect(parameters.message).toBe(\n\t    `\n\tmulti\n\tline\n\tparameter\n\t`.trim()\n", "  );\n\t  expect(thoughts).toBe(\n\t    \"Trying a multi-line parameter followed by another parameter.\"\n\t  );\n\t});\n\ttest(\"invalid command name\", () => {\n\t  expect(assertInvalid(\"foo\")).toBe(\n\t    \"Unknown action `foo`. Please refer to the list of available actions given in the introductory message.\"\n\t  );\n\t});\n", "test(\"invalid raw text\", () => {\n\t  expect(assertInvalid(\"Hello Control, how are you doing?\")).toEqual(\n\t    `\n\tYour action could not be parsed. Remember to always format your entire response as an action, like this:\n\t\\`\\`\\`\n\t<action name>\n\t<arg 1 name>: <prop value>\n\t<arg 2 name>: <prop value>\n\t...\n\t\\`\\`\\`\n", "`.trim()\n\t  );\n\t});\n\ttest(\"missing required parameter\", () => {\n\t  expect(assertInvalid(\"sendMessage\\ntargetAgentId: 0\")).toBe(\n\t    `Missing required parameter \\`message\\`. ${getUsageText(\n\t      messaging.actions.sendMessage\n\t    )}`\n\t  );\n\t});\n", "test(\"extra parameter\", () => {\n\t  expect(assertInvalid(\"noop\\nfoo: bar\")).toEqual(\n\t    `Extraneous parameter \\`foo\\`. ${getUsageText(core.actions.noop)}`\n\t  );\n\t});\n\tdescribe(\"quotes\", () => {\n\t  test(\"in-line parameter\", () => {\n\t    const action = assertValid(`\n\tsendMessage\n\ttargetAgentId: 0\n", "message: hello, \"control\"\n\t`);\n\t    expect(action.actionDef.name).toBe(\"sendMessage\");\n\t    expect(action.parameters).toEqual({\n\t      targetAgentId: \"0\",\n\t      message: 'hello, \"control\"',\n\t    });\n\t  });\n\t  test(\"multi-line parameter\", () => {\n\t    const action = assertValid(`\n", "sendMessage\n\ttargetAgentId: 0\n\tmessage:\n\t${MULTILINE_DELIMITER}\n\thello, \"control\"\n\t${MULTILINE_DELIMITER}\n\t`);\n\t    expect(action.actionDef.name).toBe(\"sendMessage\");\n\t    expect(action.parameters).toEqual({\n\t      targetAgentId: \"0\",\n", "      message: 'hello, \"control\"',\n\t    });\n\t  });\n\t});\n\t// =============================================================================\n\tfunction assertValid(text: string): Action {\n\t  const result = parseAction(moduleManager.actions, text);\n\t  if (result.type === \"error\") throw Error(`Parse failed: ${result.message}`);\n\t  return result.action;\n\t}\n", "function assertInvalid(text: string): string {\n\t  const result = parseAction(moduleManager.actions, text);\n\t  if (result.type === \"success\")\n\t    throw Error(\n\t      `Parse succeeded when it should've failed: ${JSON.stringify(\n\t        result.action,\n\t        null,\n\t        2\n\t      )}`\n\t    );\n", "  return result.message;\n\t}\n"]}
{"filename": "src/store/file-store.ts", "chunked_list": ["import { Store } from \".\";\n\timport { readFile, writeFile, mkdir, stat, unlink, readdir } from \"fs/promises\";\n\timport path from \"path\";\n\tconst STORE_DIR = \".store\";\n\texport default class FileStore implements Store<string> {\n\t  constructor(private namespaces: string[]) {}\n\t  async get(key: string) {\n\t    await this.mkdirs();\n\t    const path = this.pathFor(key);\n\t    const fileExists = await checkExists(path);\n", "    if (!fileExists) return undefined;\n\t    const buffer = await readFile(path, \"utf-8\");\n\t    return buffer.toString();\n\t  }\n\t  async set(key: string, value: string) {\n\t    await this.mkdirs();\n\t    await writeFile(this.pathFor(key), value, \"utf-8\");\n\t  }\n\t  async delete(key: string) {\n\t    await this.mkdirs();\n", "    const path = this.pathFor(key);\n\t    const fileExists = await checkExists(path);\n\t    if (!fileExists) return false;\n\t    await unlink(path);\n\t    return true;\n\t  }\n\t  async getKeys() {\n\t    await this.mkdirs();\n\t    const fileNames = await readdir(this.dirPath);\n\t    // Get file stats for each file in parallel\n", "    const withStats = await Promise.all(\n\t      fileNames.map(async (fileName) => {\n\t        const stats = await stat(`${this.dirPath}/${fileName}`);\n\t        return { keyName: decodeFilename(fileName), stats };\n\t      })\n\t    );\n\t    // Sort by last modified date\n\t    const sortedKeys = withStats\n\t      .sort((a, b) => a.stats.mtime.getTime() - b.stats.mtime.getTime())\n\t      .map(({ keyName }) => keyName);\n", "    return sortedKeys;\n\t  }\n\t  private async mkdirs() {\n\t    await mkdir(this.dirPath, { recursive: true });\n\t  }\n\t  private pathFor(key: string) {\n\t    return path.join(this.dirPath, encodeFilename(key));\n\t  }\n\t  private get dirPath() {\n\t    return path.join(STORE_DIR, ...this.namespaces);\n", "  }\n\t}\n\tasync function checkExists(path: string) {\n\t  try {\n\t    await stat(path);\n\t    return true;\n\t  } catch (e: any) {\n\t    if (e.code === \"ENOENT\") {\n\t      // Does not exist\n\t      return false;\n", "    } else {\n\t      // Some other error occurred\n\t      throw e;\n\t    }\n\t  }\n\t}\n\tfunction encodeChar(char: string): string {\n\t  return \"%\" + char.charCodeAt(0).toString(16);\n\t}\n\tfunction decodeChar(encodedChar: string): string {\n", "  return String.fromCharCode(parseInt(encodedChar.slice(1), 16));\n\t}\n\tfunction encodeFilename(filename: string): string {\n\t  // Replace invalid characters with their encoded versions\n\t  const replaced = filename.replace(/[\\\\/:*?\"<>|]/g, encodeChar);\n\t  // Limit the filename length, as some file systems have restrictions\n\t  const maxLength = 255;\n\t  const trimmed = replaced.slice(0, maxLength);\n\t  return trimmed;\n\t}\n", "function decodeFilename(filename: string): string {\n\t  // Decode the escaped characters back to their original form\n\t  return filename.replace(/%[0-9a-fA-F]{2}/g, decodeChar);\n\t}\n"]}
{"filename": "src/store/json-store.ts", "chunked_list": ["import { Store } from \".\";\n\texport default class JsonStore<T> implements Store<T> {\n\t  constructor(private stringStore: Store<string>) {}\n\t  async get(key: string) {\n\t    const stringValue = await this.stringStore.get(key);\n\t    return stringValue && JSON.parse(stringValue);\n\t  }\n\t  async set(key: string, value: T) {\n\t    return this.stringStore.set(key, JSON.stringify(value, null, 2));\n\t  }\n", "  async delete(key: string) {\n\t    return this.stringStore.delete(key);\n\t  }\n\t  async getKeys() {\n\t    return this.stringStore.getKeys();\n\t  }\n\t}\n"]}
{"filename": "src/store/in-memory-store.ts", "chunked_list": ["import { Store } from \".\";\n\texport default class InMemoryStore implements Store<string> {\n\t  private map = new Map<string, string>();\n\t  async get(key: string) {\n\t    return this.map.get(key);\n\t  }\n\t  async set(key: string, value: string) {\n\t    this.map.set(key, value);\n\t  }\n\t  async delete(key: string) {\n", "    return this.map.delete(key);\n\t  }\n\t  async getKeys() {\n\t    return [...this.map.keys()];\n\t  }\n\t}\n"]}
{"filename": "src/store/index.ts", "chunked_list": ["export interface Store<T = string> {\n\t  get(key: string): Promise<T | undefined>;\n\t  set(key: string, value: T): Promise<void>;\n\t  delete(key: string): Promise<boolean>;\n\t  getKeys(): Promise<string[]>;\n\t}\n"]}
{"filename": "src/module/define-module.ts", "chunked_list": ["import { fromPairs, mapValues, toPairs } from \"lodash\";\n\timport { PartialActionDefinition } from \"./action-definition\";\n\timport {\n\t  ModuleDefinitionInputs1,\n\t  ModuleDefinitionInputs2,\n\t  ModuleDefinition,\n\t} from \".\";\n\texport function defineModule<S>(inputs1: ModuleDefinitionInputs1<S>) {\n\t  return {\n\t    with: <A extends string>({\n", "      actions,\n\t      ...inputs2\n\t    }: ModuleDefinitionInputs2<S, A>): ModuleDefinition<S, A> => ({\n\t      ...inputs1,\n\t      ...inputs2,\n\t      actions: fromPairs(\n\t        toPairs<PartialActionDefinition<S, string>>(actions).map(\n\t          ([name, { parameters = {}, ...definition }]) => [\n\t            name,\n\t            {\n", "              name,\n\t              parameters: mapValues(parameters, (parameter) => ({\n\t                optional: false,\n\t                ...parameter,\n\t              })),\n\t              ...definition,\n\t            },\n\t          ]\n\t        )\n\t      ) as any,\n", "    }),\n\t  };\n\t}\n"]}
{"filename": "src/module/index.ts", "chunked_list": ["import { ActionDefinition, PartialActionDefinition } from \"./action-definition\";\n\texport interface ModuleDefinition<S = any, A extends string = string>\n\t  extends ModuleDefinitionInputs1<S> {\n\t  pinnedMessage?: (context: ModuleContext<S>) => Promise<string | undefined>;\n\t  actions: Record<A, ActionDefinition<S>>;\n\t}\n\texport interface ModuleDefinitionInputs1<S> {\n\t  name: string;\n\t  createState?: (params: ModuleStateInputs) => S;\n\t}\n", "export interface ModuleDefinitionInputs2<S, A extends string> {\n\t  pinnedMessage?: (context: ModuleContext<S>) => Promise<string | undefined>;\n\t  actions: Record<A, PartialActionDefinition<S, string>>;\n\t}\n\texport interface ModuleStateInputs {\n\t  agentId: string;\n\t}\n\texport interface ModuleContext<S> {\n\t  agentId: string;\n\t  allAgentIds: string[];\n", "  actionDictionary: Map<string, ActionDefinition>;\n\t  state: S;\n\t}\n"]}
{"filename": "src/module/module-manager.ts", "chunked_list": ["import { ModuleDefinition } from \".\";\n\timport { ActionDefinition } from \"./action-definition\";\n\timport { ModuleInstance } from \"./module-instance\";\n\texport class ModuleManager {\n\t  modules: ModuleInstance[];\n\t  actions: Map<string, ActionDefinition>;\n\t  private actionToModule: Map<string, ModuleInstance>;\n\t  constructor(\n\t    public agentId: string,\n\t    public allAgentIds: string[],\n", "    moduleDefinitions: ModuleDefinition[]\n\t  ) {\n\t    this.modules = moduleDefinitions.map(\n\t      (moduleDef) => new ModuleInstance(this, moduleDef)\n\t    );\n\t    this.actions = moduleDefinitions\n\t      .flatMap((module) => Object.values(module.actions))\n\t      .reduce(\n\t        (map, actionDef) => (map.set(actionDef.name, actionDef), map),\n\t        new Map()\n", "      );\n\t    this.actionToModule = new Map();\n\t    for (const module of this.modules) {\n\t      for (const actionDef of Object.values(module.moduleDef.actions)) {\n\t        this.actionToModule.set(actionDef.name, module);\n\t      }\n\t    }\n\t  }\n\t  getModuleForAction(name: string): ModuleInstance | undefined {\n\t    return this.actionToModule.get(name);\n", "  }\n\t}\n"]}
{"filename": "src/module/module-instance.ts", "chunked_list": ["import { ModuleContext, ModuleDefinition } from \".\";\n\timport { ModuleManager } from \"./module-manager\";\n\texport class ModuleInstance<S = void, A extends string = string> {\n\t  private _state: S | undefined;\n\t  constructor(\n\t    private moduleManager: ModuleManager,\n\t    public moduleDef: ModuleDefinition<S, A>\n\t  ) {}\n\t  get state(): S {\n\t    if (!this.moduleDef.createState) return undefined as S;\n", "    this._state = this.moduleDef.createState({\n\t      agentId: this.moduleManager.agentId,\n\t    });\n\t    return this._state;\n\t  }\n\t  get context(): ModuleContext<S> {\n\t    return {\n\t      agentId: this.moduleManager.agentId,\n\t      allAgentIds: this.moduleManager.allAgentIds,\n\t      actionDictionary: this.moduleManager.actions,\n", "      state: this.state,\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/module/util.ts", "chunked_list": ["import { CODE_BLOCK_DELIMITER } from \"../message\";\n\timport { ActionDefinition } from \"./action-definition\";\n\texport function getUsageText(actionDef: ActionDefinition): string {\n\t  return `Usage:\n\t${CODE_BLOCK_DELIMITER}\n\t${actionDef.name}\n\tthoughts: <reasoning behind this action> (optional)${Object.entries(\n\t    actionDef.parameters\n\t  )\n\t    .map(([name, { description }]) =>\n", "      name === \"name\"\n\t        ? undefined\n\t        : `\\n${name}: <${description.toLowerCase()}>${\n\t            actionDef.parameters[name].optional ? \" (optional)\" : \"\"\n\t          }`\n\t    )\n\t    .filter(Boolean)\n\t    .join(\"\")}\n\t${CODE_BLOCK_DELIMITER}`;\n\t}\n"]}
{"filename": "src/module/action-definition.ts", "chunked_list": ["import { ModuleContext } from \".\";\n\timport { Message } from \"../message\";\n\texport interface ActionDefinition<S = void, P extends string = string>\n\t  extends PartialActionDefinition<S, P> {\n\t  name: string;\n\t  parameters: Record<P, ParameterDefinition>;\n\t}\n\texport interface PartialActionDefinition<S = void, P extends string = never> {\n\t  description: string;\n\t  parameters?: Record<P, PartialParameterDefinition>;\n", "  execute: ActionHandler<S, P>;\n\t}\n\texport type ParameterDefinition = Required<PartialParameterDefinition>;\n\texport interface PartialParameterDefinition {\n\t  description: string;\n\t  optional?: boolean;\n\t}\n\texport type ActionHandler<S = void, P extends string = string> = (\n\t  inputs: ActionHandlerInputs<S, P>\n\t) => Promise<void>;\n", "export interface ActionHandlerInputs<S = void, P extends string = string> {\n\t  parameters: Record<P, string>;\n\t  context: ModuleContext<S>;\n\t  sendMessage: (message: Message) => void;\n\t}\n\texport { ModuleContext };\n"]}
{"filename": "src/module/definitions/messaging.ts", "chunked_list": ["import { defineModule } from \"../define-module\";\n\timport { messageBuilder } from \"../../message\";\n\timport { agentName } from \"../../util\";\n\texport default defineModule({\n\t  name: \"messaging\",\n\t}).with({\n\t  actions: {\n\t    queryAgentRegistry: {\n\t      description: \"Ask who the other agents are that you can talk to\",\n\t      async execute({ context: { agentId, allAgentIds }, sendMessage }) {\n", "        sendMessage(\n\t          messageBuilder.ok(\n\t            agentId,\n\t            `These are the agents in the system:\\n\\n${allAgentIds\n\t              .map((id) => `${agentName(id)} [agentId=${id}]`)\n\t              .join(\"\\n\")}`\n\t          )\n\t        );\n\t      },\n\t    },\n", "    sendMessage: {\n\t      description: \"Send a message to another agent\",\n\t      parameters: {\n\t        targetAgentId: {\n\t          description: \"The target agent's ID\",\n\t        },\n\t        message: {\n\t          description: \"The content of the message\",\n\t        },\n\t      },\n", "      async execute({\n\t        parameters: { targetAgentId, message },\n\t        context: { agentId, allAgentIds },\n\t        sendMessage,\n\t      }) {\n\t        if (agentId === targetAgentId) {\n\t          return sendMessage(\n\t            messageBuilder.error(\n\t              agentId,\n\t              \"You can't send a message to yourself. Use the `writeNote` action if you want to make notes for yourself.\"\n", "            )\n\t          );\n\t        }\n\t        if (allAgentIds.includes(targetAgentId)) {\n\t          sendMessage(\n\t            messageBuilder.agentToAgent(agentId, [targetAgentId], message)\n\t          );\n\t        } else {\n\t          sendMessage(\n\t            messageBuilder.error(\n", "              agentId,\n\t              `You tried to send your message to an invalid targetAgentId (${JSON.stringify(\n\t                targetAgentId\n\t              )}). You can use the 'queryAgentRegistry' action to see a list of available agents and their agent IDs.`\n\t            )\n\t          );\n\t        }\n\t      },\n\t    },\n\t  },\n", "});\n"]}
{"filename": "src/module/definitions/web.ts", "chunked_list": ["import { google } from \"googleapis\";\n\timport puppeteer from \"puppeteer\";\n\timport TurndownService from \"turndown\";\n\timport { messageBuilder } from \"../../message\";\n\timport { Model, contextWindowSize, createChatCompletion } from \"../../openai\";\n\timport { model } from \"../../parameters\";\n\timport {\n\t  AVG_CHARACTERS_PER_TOKEN,\n\t  AVG_WORDS_PER_TOKEN,\n\t  countTokens,\n", "} from \"../../util\";\n\timport { defineModule } from \"../define-module\";\n\texport default defineModule({\n\t  name: \"web\",\n\t}).with({\n\t  actions: {\n\t    searchWeb: {\n\t      description: \"Search the web.\",\n\t      parameters: {\n\t        searchString: {\n", "          description: \"The string to search for\",\n\t        },\n\t      },\n\t      async execute({\n\t        parameters: { searchString },\n\t        context: { agentId },\n\t        sendMessage,\n\t      }) {\n\t        const items = await getSearchResults(searchString);\n\t        if (!items) {\n", "          return sendMessage(\n\t            messageBuilder.ok(agentId, \"Search returned no results.\")\n\t          );\n\t        }\n\t        sendMessage(\n\t          messageBuilder.ok(\n\t            agentId,\n\t            `Search results:\\n\\n${items\n\t              .map((item) => `- Title: \"${item.title}\"\\n  URL: ${item.link}`)\n\t              .join(\"\\n\\n\")}`\n", "          )\n\t        );\n\t      },\n\t    },\n\t    readPage: {\n\t      description: \"View a markdown summary of a web page.\",\n\t      parameters: {\n\t        url: {\n\t          description: \"The URL of the web page to read\",\n\t        },\n", "      },\n\t      async execute({\n\t        parameters: { url },\n\t        context: { agentId },\n\t        sendMessage,\n\t      }) {\n\t        try {\n\t          const maxCompletionTokens = contextWindowSize[model] / 4;\n\t          // console.log({ maxCompletionTokens });\n\t          const pageSummary = await getPageSummary(\n", "            model,\n\t            maxCompletionTokens,\n\t            url\n\t          );\n\t          sendMessage(\n\t            messageBuilder.ok(\n\t              agentId,\n\t              `Here is a summarized markdown version of the page, in a series of summarized chunks:\\n\\n${pageSummary}`\n\t            )\n\t          );\n", "        } catch (e: any) {\n\t          sendMessage(\n\t            messageBuilder.error(\n\t              agentId,\n\t              `Error extracting content from ${url}: ${e.message}`\n\t            )\n\t          );\n\t        }\n\t      },\n\t    },\n", "  },\n\t});\n\texport async function getSearchResults(searchString: string) {\n\t  const { data } = await google.customsearch(\"v1\").cse.list({\n\t    q: searchString,\n\t    cx: process.env.GOOGLE_SEARCH_ENGINE_ID,\n\t    key: process.env.GOOGLE_API_KEY,\n\t  });\n\t  return data.items;\n\t}\n", "export async function getPageSummary(\n\t  model: Model,\n\t  maxSummaryTokens: number,\n\t  url: string\n\t) {\n\t  const maxCompletionTokens = Math.round(contextWindowSize[model] * 0.9);\n\t  console.log(\"Initializing...\");\n\t  const browser = await puppeteer.launch();\n\t  const page = await browser.newPage();\n\t  const turndownService = new TurndownService().addRule(\n", "    \"remove-extraneous-tags\",\n\t    {\n\t      filter: [\"style\", \"script\", \"img\"],\n\t      replacement: () => \"\",\n\t    }\n\t  );\n\t  console.log(`Reading page at ${url}...`);\n\t  await page.goto(url);\n\t  const htmlContent = await page.content();\n\t  // console.log(htmlContent);\n", "  console.log(`HTML tokens: ${countTokens(htmlContent)}`);\n\t  turndownService.remove([\"style\", \"script\"]);\n\t  const markdownContent = turndownService\n\t    .turndown(htmlContent)\n\t    .replace(/\\\\_/g, \"_\");\n\t  const markdownTokens = countTokens(markdownContent);\n\t  console.log(`Markdown tokens: ${markdownTokens}`);\n\t  const chunks: string[] = [];\n\t  let currentChunkLines: string[] = [];\n\t  let currentChunkTokens = 0;\n", "  for (const line of markdownContent.split(\"\\n\")) {\n\t    const lineTokens = countTokens(line);\n\t    if (currentChunkTokens + lineTokens > maxCompletionTokens) {\n\t      chunks.push(currentChunkLines.join(\"\\n\"));\n\t      currentChunkLines = [];\n\t      currentChunkTokens = 0;\n\t    }\n\t    currentChunkLines.push(line);\n\t    currentChunkTokens += lineTokens;\n\t  }\n", "  let lastChunk = currentChunkLines.join(\"\\n\");\n\t  if (countTokens(lastChunk) > maxCompletionTokens) {\n\t    const characterLimit = Math.round(\n\t      maxCompletionTokens * AVG_CHARACTERS_PER_TOKEN\n\t    );\n\t    console.log(\n\t      `Truncating final chunk at ${characterLimit} characters:\\n\\n${lastChunk}`\n\t    );\n\t    lastChunk = lastChunk.substring(0, characterLimit);\n\t  }\n", "  chunks.push(lastChunk);\n\t  // console.log(\n\t  //   chunks\n\t  //     .map((chunk) => `CHUNK (${countTokens(chunk)}):\\n\\n${chunk}\\n\\n`)\n\t  //     .join(\"\")\n\t  // );\n\t  console.log(\n\t    `Total chunks: ${chunks.length} (${Math.round(\n\t      markdownTokens / chunks.length\n\t    )} tokens per chunk)`\n", "  );\n\t  const maxChunkSummaryTokens = Math.round(maxSummaryTokens / chunks.length);\n\t  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t  const maxChunkSummaryWords = Math.round(\n\t    maxChunkSummaryTokens * AVG_WORDS_PER_TOKEN\n\t  );\n\t  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t  const maxChunkSummaryCharacters = Math.round(\n\t    maxChunkSummaryTokens * AVG_CHARACTERS_PER_TOKEN\n\t  );\n", "  // const summaryLimitText = `${maxChunkSummaryWords} words`;\n\t  const chunkSummaryLimitText = `${maxChunkSummaryCharacters} characters`;\n\t  console.log(\n\t    `Max tokens per chunk summary: ${maxChunkSummaryTokens} (${chunkSummaryLimitText})`\n\t  );\n\t  console.log(\"Summarizing chunks...\");\n\t  const summarizedChunks = await Promise.all(\n\t    chunks.map(async (chunk) =>\n\t      createChatCompletion({\n\t        model,\n", "        messages: [\n\t          {\n\t            role: \"user\",\n\t            content: `Modify the following markdown excerpt only as much as necessary to bring it under a maximum of ${chunkSummaryLimitText}, preserving the most essential information. In particular, try to preserve links (example: \\`[my special link](https://foo.bar/baz/)\\`). Write this in the same voice as the original text; do not speak in the voice of someone who is describing it to someone else. For instance, don't use phrases like \"The article talks about...\". Excerpt to summarize follows:\\n\\n=============\\n\\n${chunk}`,\n\t          },\n\t        ],\n\t      })\n\t    )\n\t  );\n\t  const summary = summarizedChunks\n", "    .map(\n\t      (chunk) =>\n\t        `=== SUMMARIZED CHUNK (${countTokens(\n\t          chunk\n\t        )} tokens) ===\\n\\n${chunk}\\n\\n`\n\t    )\n\t    .join(\"\");\n\t  // console.log(`Summary:\\n\\n${summary}\\n`);\n\t  console.log(`Summary tokens: ${countTokens(summary)}`);\n\t  await browser.close();\n", "  return summary;\n\t}\n"]}
{"filename": "src/module/definitions/filesystem.ts", "chunked_list": ["import {\n\t  readFile,\n\t  readdir,\n\t  rename,\n\t  stat,\n\t  unlink,\n\t  writeFile,\n\t  mkdir,\n\t} from \"fs/promises\";\n\timport { join as joinPath, resolve as resolvePath } from \"path\";\n", "import { defineModule } from \"../define-module\";\n\timport { messageBuilder } from \"../../message\";\n\texport default defineModule({\n\t  name: \"filesystem\",\n\t}).with({\n\t  actions: {\n\t    listDirectory: {\n\t      description: \"Inspect the contents of a particular directory\",\n\t      parameters: {\n\t        path: {\n", "          description: \"The path of the directory you want to inspect\",\n\t        },\n\t      },\n\t      async execute({\n\t        parameters: { path },\n\t        context: { agentId },\n\t        sendMessage,\n\t      }) {\n\t        if (!checkPath(agentId, path, sendMessage)) return;\n\t        try {\n", "          const files = await readdir(path);\n\t          const filesWithStatsPromises = files.map(async (file) => {\n\t            const stats = await stat(joinPath(path, file));\n\t            return `${file} ${stats.isDirectory() ? \"[directory]\" : \"[file]\"}`;\n\t          });\n\t          const filesWithStats = await Promise.all(filesWithStatsPromises);\n\t          sendMessage(\n\t            messageBuilder.ok(\n\t              agentId,\n\t              `Here are the contents of ${path}:\\n${filesWithStats.join(\"\\n\")}`\n", "            )\n\t          );\n\t        } catch (err) {\n\t          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n\t        }\n\t      },\n\t    },\n\t    readFile: {\n\t      description: \"Read the contents of a particular file\",\n\t      parameters: {\n", "        path: {\n\t          description: \"The path of the file you want to inspect\",\n\t        },\n\t      },\n\t      async execute({\n\t        parameters: { path },\n\t        context: { agentId },\n\t        sendMessage,\n\t      }) {\n\t        if (!checkPath(agentId, path, sendMessage)) return;\n", "        try {\n\t          const data = await readFile(path, \"utf8\");\n\t          sendMessage(\n\t            messageBuilder.ok(agentId, `Contents of ${path}:\\n\\n${data}`)\n\t          );\n\t        } catch (err) {\n\t          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n\t        }\n\t      },\n\t    },\n", "    writeFile: {\n\t      description: \"Write the contents of a particular file\",\n\t      parameters: {\n\t        path: {\n\t          description: \"The path of the file you want to write to\",\n\t        },\n\t        content: {\n\t          description: \"The new content of the file\",\n\t        },\n\t      },\n", "      async execute({\n\t        parameters: { path, content },\n\t        context: { agentId },\n\t        sendMessage,\n\t      }) {\n\t        if (!checkPath(agentId, path, sendMessage)) return;\n\t        try {\n\t          await writeFile(path, content, \"utf8\");\n\t          sendMessage(messageBuilder.ok(agentId, `Wrote to ${path}.`));\n\t        } catch (err) {\n", "          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n\t        }\n\t      },\n\t    },\n\t    moveFile: {\n\t      description: \"Move a file to a new location\",\n\t      parameters: {\n\t        sourcePath: {\n\t          description: \"The original path of the file\",\n\t        },\n", "        destinationPath: {\n\t          description: \"The new path for the file\",\n\t        },\n\t      },\n\t      async execute({\n\t        parameters: { sourcePath, destinationPath },\n\t        context: { agentId },\n\t        sendMessage,\n\t      }) {\n\t        if (!checkPath(agentId, sourcePath, sendMessage)) return;\n", "        if (!checkPath(agentId, destinationPath, sendMessage)) return;\n\t        try {\n\t          await rename(sourcePath, destinationPath);\n\t          sendMessage(\n\t            messageBuilder.ok(\n\t              agentId,\n\t              `Moved ${sourcePath} to ${destinationPath}.`\n\t            )\n\t          );\n\t        } catch (err) {\n", "          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n\t        }\n\t      },\n\t    },\n\t    deleteFile: {\n\t      description: \"Delete a file\",\n\t      parameters: {\n\t        path: {\n\t          description: \"The path of the file to delete\",\n\t        },\n", "      },\n\t      async execute({\n\t        parameters: { path },\n\t        context: { agentId },\n\t        sendMessage,\n\t      }) {\n\t        if (!checkPath(agentId, path, sendMessage)) return;\n\t        try {\n\t          await unlink(path);\n\t          sendMessage(messageBuilder.ok(agentId, `Deleted ${path}.`));\n", "        } catch (err) {\n\t          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n\t        }\n\t      },\n\t    },\n\t    createDirectory: {\n\t      description: \"Create a new directory\",\n\t      parameters: {\n\t        path: {\n\t          description: \"The path of the directory to create\",\n", "        },\n\t      },\n\t      async execute({\n\t        parameters: { path },\n\t        context: { agentId },\n\t        sendMessage,\n\t      }) {\n\t        if (!checkPath(agentId, path, sendMessage)) return;\n\t        try {\n\t          await mkdir(path);\n", "          sendMessage(messageBuilder.ok(agentId, `Created directory ${path}.`));\n\t        } catch (err) {\n\t          sendMessage(messageBuilder.error(agentId, JSON.stringify(err)));\n\t        }\n\t      },\n\t    },\n\t  },\n\t});\n\tfunction checkPath(\n\t  agentId: string,\n", "  path: string,\n\t  sendMessage: (message: any) => void\n\t) {\n\t  const currentDirectory = process.cwd();\n\t  const resolvedPath = resolvePath(path);\n\t  if (!resolvedPath.startsWith(currentDirectory)) {\n\t    sendMessage(\n\t      messageBuilder.error(\n\t        agentId,\n\t        \"Invalid path; must be within the current directory.\"\n", "      )\n\t    );\n\t    return false;\n\t  }\n\t  if (resolvedPath.includes(\".git\") || resolvedPath.includes(\"node_modules\")) {\n\t    sendMessage(messageBuilder.error(agentId, \"That path is off-limits!\"));\n\t    return false;\n\t  }\n\t  return true;\n\t}\n"]}
{"filename": "src/module/definitions/core.ts", "chunked_list": ["import { CODE_BLOCK_DELIMITER, messageBuilder } from \"../../message\";\n\timport { MULTILINE_DELIMITER, agentName } from \"../../util\";\n\timport { defineModule } from \"../define-module\";\n\timport { getUsageText } from \"../util\";\n\texport default defineModule({\n\t  name: \"core\",\n\t}).with({\n\t  pinnedMessage: async ({ agentId, actionDictionary }) =>\n\t    `\n\t  You are ${agentName(\n", "    agentId\n\t  )}, a highly capable autonomous entity who is able to perform actions in order to accomplish tasks. The following points should govern everything you do. Read carefully and never forget them:\n\t  1) The entirety of your response should always be an invocation of an action, using the following format:\n\t  ${CODE_BLOCK_DELIMITER}\n\t  <action name>\n\t  thoughts: <reasoning behind this action>\n\t  <arg 1 name>: <prop value>\n\t  <arg 2 name>: <prop value>\n\t  ...\n\t  ${CODE_BLOCK_DELIMITER}\n", "  Example of a correct response:\n\t  ${CODE_BLOCK_DELIMITER}\n\t  writeNote\n\t  thoughts: This seems important since it's fundamental to the way I communicate with the system.\n\t  title: Always Remember\n\t  content: Encode every response as an action!\n\t  ${CODE_BLOCK_DELIMITER}\n\t  Example of an incorrect response:\n\t  ${CODE_BLOCK_DELIMITER}\n\t  Note to self: always encode every response as an action!\n", "  ${CODE_BLOCK_DELIMITER}\n\t  2) These are the actions at your disposal:\n\t  ${[...actionDictionary.values()]\n\t    .map((actionDef) => `\\`${actionDef.name}\\` - ${actionDef.description}`)\n\t    .join(\"\\n\")}\n\t  To get help on a specific action, use the \\`help\\` action with the \\`aboutAction\\` parameter set to the name of the action you want help with. For example:\n\t  ${CODE_BLOCK_DELIMITER}\n\t  help\n\t  aboutAction: writeNote\n\t  ${CODE_BLOCK_DELIMITER}\n", "  You may only invoke actions mentioned in the above list.\n\t  *NOTE* You never invoke an action until you have first invoked \\`help\\` on it so that you know what parameters it expects. Being the careful agent that you are, you do not simply guess parameters that you think would make sense.\n\t  3) When passing multiple lines of text as an action parameter, you *MUST* use the multi-line delimiter \\`${MULTILINE_DELIMITER}\\` to enclose the parameter value in its entirety.\n\t  Example:\n\t  ${CODE_BLOCK_DELIMITER}\n\t  writeNote\n\t  title: Always Remember\n\t  content:\n\t  ${MULTILINE_DELIMITER}\n\t  Encode\n", "  every\n\t  response\n\t  as\n\t  an\n\t  action!\n\t  ${MULTILINE_DELIMITER}\n\t  ${CODE_BLOCK_DELIMITER}\n\t  Notice that both the start and end delimiters appear on lines by themselves, and they enclose the \\`message\\` parameter value in its entirety.\n\t  4) Every time you receive a message, you must decide on an action to take. If there's nothing you feel like you need to do at the moment, you can use the \\`noop\\` action.\n\t  5) You are not serving a mere advisory role. You are not a chat bot. You are an autonomous entity who invokes actions to accomplish goals.\n", "  `.trim(),\n\t  actions: {\n\t    noop: {\n\t      description: \"Do nothing\",\n\t      async execute() {},\n\t    },\n\t    help: {\n\t      description:\n\t        \"Get help on a specific action and the parameters it expects.\",\n\t      parameters: {\n", "        aboutAction: {\n\t          description: \"The name of an action to get help on\",\n\t        },\n\t      },\n\t      async execute({\n\t        parameters: { aboutAction },\n\t        context: { agentId, actionDictionary },\n\t        sendMessage,\n\t      }) {\n\t        const actionDef = actionDictionary.get(aboutAction);\n", "        if (!actionDef) {\n\t          sendMessage(\n\t            messageBuilder.error(\n\t              agentId,\n\t              `Unknown action \\`${aboutAction}\\`. Please refer to the list of available actions given in the introductory message.`\n\t            )\n\t          );\n\t        } else {\n\t          sendMessage(messageBuilder.ok(agentId, getUsageText(actionDef)));\n\t        }\n", "      },\n\t    },\n\t  },\n\t});\n"]}
{"filename": "src/module/definitions/goals.ts", "chunked_list": ["import { defineModule } from \"../define-module\";\n\timport { messageBuilder } from \"../../message\";\n\timport { Store } from \"../../store\";\n\timport FileStore from \"../../store/file-store\";\n\timport JsonStore from \"../../store/json-store\";\n\tinterface Goal {\n\t  text: string;\n\t  complete: boolean;\n\t}\n\tconst KEY = \"goals\";\n", "export default defineModule<Store<Goal[]>>({\n\t  name: \"goals\",\n\t  createState: ({ agentId }) => new JsonStore(new FileStore([agentId])),\n\t}).with({\n\t  async pinnedMessage({ state }) {\n\t    const goals = (await state.get(KEY)) || [];\n\t    const currentGloals = goals.length\n\t      ? `This is your current goal list:\\n\\n${goals\n\t          .map(\n\t            ({ text, complete }, index) =>\n", "              `${index + 1}) \"${text}\" [${complete ? \"COMPLETE\" : \"PENDING\"}]`\n\t          )\n\t          .join(\"\\n\")}`\n\t      : \"You have no goals currently.\";\n\t    return `\n\tYou are responsible for maintaining your list of goals, based on higher-level objectives which will be given to you. Whenever you start doing something, first add a goal. Whenever you finish doing something, mark it complete. This list of goals will always be pinned to the top of your context and won't be summarized away. Goals should be medium-term (requiring several actions to complete) and concrete. Do not invent goals out of nothing, they should encapsulate instructions that have been given to you.\n\t${currentGloals}\n\t`.trim();\n\t  },\n\t  actions: {\n", "    addGoal: {\n\t      description: \"Add a new goal at the end of your goals list.\",\n\t      parameters: {\n\t        goal: {\n\t          description:\n\t            \"A summary of what you want to achieve (keep this relatively short but information dense)\",\n\t        },\n\t      },\n\t      async execute({\n\t        parameters: { goal },\n", "        context: { agentId, state },\n\t        sendMessage,\n\t      }) {\n\t        const goals = (await state.get(KEY)) || [];\n\t        await state.set(KEY, [...goals, { text: goal, complete: false }]);\n\t        sendMessage(messageBuilder.ok(agentId, \"Goal added.\"));\n\t      },\n\t    },\n\t    completeGoal: {\n\t      description: \"Mark a goal as complete.\",\n", "      parameters: {\n\t        goalNumber: {\n\t          description: \"The number of the goal you want to mark as complete\",\n\t        },\n\t      },\n\t      async execute({\n\t        parameters: { goalNumber },\n\t        context: { agentId, state },\n\t        sendMessage,\n\t      }) {\n", "        const idx = parseInt(goalNumber) - 1;\n\t        const goals = (await state.get(KEY)) || [];\n\t        if (isNaN(idx) || idx < 0 || idx >= goals.length)\n\t          return sendMessage(\n\t            messageBuilder.error(agentId, `Invalid goal index: ${goalNumber}`)\n\t          );\n\t        await state.set(KEY, [\n\t          ...goals.slice(0, idx),\n\t          { ...goals[idx], complete: true },\n\t          ...goals.slice(idx + 1),\n", "        ]);\n\t        sendMessage(messageBuilder.ok(agentId, \"Goal marked complete.\"));\n\t      },\n\t    },\n\t  },\n\t});\n"]}
{"filename": "src/module/definitions/web.test.ts", "chunked_list": ["import dotenv from \"dotenv\";\n\timport { GPT_3_5_TURBO } from \"../../openai\";\n\timport { getPageSummary, getSearchResults } from \"./web\";\n\tdotenv.config();\n\ttest.skip(\n\t  \"getPageSummary\",\n\t  async () => {\n\t    await getPageSummary(\n\t      GPT_3_5_TURBO,\n\t      // GPT_4,\n", "      1000,\n\t      \"https://xenogothic.com/2022/12/23/patchwork-a-reflection/\"\n\t      // \"https://platform.openai.com/docs/guides/completion/inserting-text\"\n\t      // \"https://actions.github.io/authentication/\",\n\t      // \"https://en.wikipedia.org/wiki/Technological_singularity\"\n\t    );\n\t  },\n\t  5 * 60 * 1000\n\t);\n\ttest.skip(\n", "  \"getSearchResults\",\n\t  async () => {\n\t    const results = await getSearchResults(`\"e/acc\" explanation and sources`);\n\t    console.log(results?.map((item) => item.title).join(\"\\n\"));\n\t  },\n\t  5 * 60 * 1000\n\t);\n"]}
{"filename": "src/module/definitions/notes.ts", "chunked_list": ["import { defineModule } from \"../define-module\";\n\timport { messageBuilder } from \"../../message\";\n\timport { Store } from \"../../store\";\n\timport FileStore from \"../../store/file-store\";\n\texport default defineModule<Store>({\n\t  name: \"notes\",\n\t  createState: ({ agentId }) => new FileStore([agentId, \"notes\"]),\n\t}).with({\n\t  async pinnedMessage({ state }) {\n\t    const noteTitles = await state.getKeys();\n", "    const currentNotes = noteTitles.length\n\t      ? `Here are your current notes:\\n\\n${noteTitles\n\t          .map((title) => `- \"${title}\"`)\n\t          .join(\"\\n\")}`\n\t      : \"Your have no notes currently.\";\n\t    return `\n\tYou can manage your notes using the \\`writeNote\\`, \\`viewNote\\` and \\`deleteNote\\` actions. Use notes to keep track of any important information that you come across that may be of longterm interest. Because notes contain content in addition to a title, you can store larger thoughts here which might not fit into the text of a goal. Your notes list will always be pinned to the top of your context and won't be summarized away.\n\t${currentNotes}\n\t`.trim();\n\t  },\n", "  actions: {\n\t    writeNote: {\n\t      description: \"Create or update a note which will only be visible to you.\",\n\t      parameters: {\n\t        title: {\n\t          description: \"The title of the note\",\n\t        },\n\t        content: {\n\t          description: \"The content of the note\",\n\t        },\n", "      },\n\t      async execute({\n\t        parameters: { title, content },\n\t        context: { agentId, state },\n\t        sendMessage,\n\t      }) {\n\t        await state.set(title, content);\n\t        sendMessage(\n\t          messageBuilder.ok(\n\t            agentId,\n", "            `Note \"${title}\" has been written successfully.`\n\t          )\n\t        );\n\t      },\n\t    },\n\t    viewNote: {\n\t      description: \"Display the content of a note.\",\n\t      parameters: {\n\t        title: {\n\t          description: \"The title of the note to view\",\n", "        },\n\t      },\n\t      async execute({\n\t        parameters: { title },\n\t        context: { agentId, state },\n\t        sendMessage,\n\t      }) {\n\t        const content = await state.get(title);\n\t        if (content) {\n\t          sendMessage(\n", "            messageBuilder.ok(agentId, `Content of \"${title}\":\\n\\n${content}`)\n\t          );\n\t        } else {\n\t          sendMessage(\n\t            messageBuilder.error(agentId, `Note \"${title}\" not found.`)\n\t          );\n\t        }\n\t      },\n\t    },\n\t    deleteNote: {\n", "      description: \"Delete a note.\",\n\t      parameters: {\n\t        title: {\n\t          description: \"The title of the note to delete\",\n\t        },\n\t      },\n\t      async execute({\n\t        parameters: { title },\n\t        context: { agentId, state },\n\t        sendMessage,\n", "      }) {\n\t        if (await state.delete(title)) {\n\t          sendMessage(messageBuilder.ok(agentId, `Deleted note \"${title}\".`));\n\t        } else {\n\t          sendMessage(\n\t            messageBuilder.error(agentId, `Note \"${title}\" not found.`)\n\t          );\n\t        }\n\t      },\n\t    },\n", "  },\n\t});\n"]}
{"filename": "src/memory/index.ts", "chunked_list": ["import { Message } from \"../message\";\n\texport { Memory } from \"./memory\";\n\texport type Event = MessageEvent | DecisionEvent;\n\texport interface MessageEvent {\n\t  type: \"message\";\n\t  message: Message;\n\t}\n\texport interface DecisionEvent {\n\t  type: \"decision\";\n\t  actionText: string;\n", "}\n"]}
{"filename": "src/memory/memory.ts", "chunked_list": ["import { Event } from \".\";\n\timport makeDecision, { toOpenAiMessage } from \"../make-decision\";\n\timport { messageBuilder } from \"../message\";\n\timport { ModuleManager } from \"../module/module-manager\";\n\timport { Store } from \"../store\";\n\timport {\n\t  AVG_WORDS_PER_TOKEN,\n\t  agentName,\n\t  countTokens as countTokensInText,\n\t  messageSourceName,\n", "} from \"../util\";\n\texport class Memory {\n\t  private firstRetrieval = true;\n\t  constructor(\n\t    private agentId: string,\n\t    private moduleManager: ModuleManager,\n\t    private store: Store<Event[]>,\n\t    private compressionThreshold: number\n\t  ) {}\n\t  async append(event: Event): Promise<Event[]> {\n", "    this.printEvent(event);\n\t    let events = await this.retrieve();\n\t    if (event.type === \"message\" && event.message.type === \"ok\") {\n\t      // After an \"ok\" message is sent, remove all errors and their antecedents from memory,\n\t      // since agents tend to repeat mistakes rather than learning from them.\n\t      events = this.removeErrors(events);\n\t    }\n\t    events.push(event);\n\t    events = await this.summarize(events);\n\t    await this.store.set(this.key, events.slice(1));\n", "    return events;\n\t  }\n\t  async retrieve(): Promise<Event[]> {\n\t    const introduction = await this.getIntroduction();\n\t    const storedEvents = await this.store.get(this.key);\n\t    let events = [\n\t      introduction,\n\t      ...(storedEvents || [{ type: \"decision\", actionText: \"noop\" }]),\n\t    ];\n\t    if (this.firstRetrieval) {\n", "      this.firstRetrieval = false;\n\t      events = await this.summarize(events);\n\t      await this.store.set(this.key, events.slice(1));\n\t    }\n\t    // events.forEach((event) => this.printEvent(event));\n\t    return events;\n\t  }\n\t  private async getIntroduction(): Promise<Event> {\n\t    const nestedEvents = await Promise.all(\n\t      this.moduleManager.modules.map(async (module): Promise<string[]> => {\n", "        const { name, pinnedMessage } = module.moduleDef;\n\t        if (!pinnedMessage) return [];\n\t        const content = await pinnedMessage(module.context);\n\t        if (!content) return [];\n\t        return [`--- ${name.toUpperCase()} ---\\n\\n${content}`];\n\t      })\n\t    );\n\t    return {\n\t      type: \"message\",\n\t      message: messageBuilder.spontaneous(\n", "        this.agentId,\n\t        nestedEvents.flat().join(\"\\n\\n\")\n\t      ),\n\t    };\n\t  }\n\t  private removeErrors(events: Event[]): Event[] {\n\t    const cleaned: Event[] = [];\n\t    for (let i = events.length - 1; i >= 0; i--) {\n\t      const event = events[i];\n\t      if (event.type === \"message\" && event.message.type === \"error\") {\n", "        const prevEvent = events[i - 1];\n\t        // console.log(\"REMOVING\", JSON.stringify(prevEvent, null, 2));\n\t        // console.log(\"REMOVING\", JSON.stringify(event, null, 2));\n\t        if (prevEvent.type === \"decision\") {\n\t          i--; // skip the previous action which generated the error\n\t        } else {\n\t          console.error(\"error event was not preceded by an action\");\n\t        }\n\t        continue;\n\t      }\n", "      cleaned.push(event);\n\t    }\n\t    cleaned.reverse();\n\t    // console.log({ events, cleaned });\n\t    return cleaned;\n\t  }\n\t  /**\n\t   * Compress the event history when it becomes too large in order to free up the context window.\n\t   */\n\t  private async summarize(events: Event[]): Promise<Event[]> {\n", "    if (!events.length) return [];\n\t    const cumulativeTokenCounts = this.getCumulativeTokenCounts(events);\n\t    const totalTokenCount =\n\t      cumulativeTokenCounts[cumulativeTokenCounts.length - 1];\n\t    const thresholdOverrun = totalTokenCount - this.compressionThreshold;\n\t    const truncationThreshold =\n\t      cumulativeTokenCounts[0] +\n\t      Math.max(\n\t        thresholdOverrun,\n\t        Math.floor((totalTokenCount - cumulativeTokenCounts[0]) / 2)\n", "      );\n\t    // console.log(\n\t    //   `Token count: ${totalTokenCount}\\nRemaining context space: ${-thresholdOverrun}`\n\t    // );\n\t    // console.log({\n\t    //   compressionThreshold: this.compressionThreshold,\n\t    //   truncationThreshold,\n\t    //   thresholdOverrun,\n\t    //   cumulativeTokenCounts,\n\t    // });\n", "    if (thresholdOverrun > 0) {\n\t      let i = 1;\n\t      // prettier-ignore\n\t      for (; i < events.length && cumulativeTokenCounts[i - 1] <= truncationThreshold; i++);\n\t      // prettier-ignore\n\t      for (; i > 0 && cumulativeTokenCounts[i - 1] > this.compressionThreshold; i--);\n\t      i = Math.max(i, 3);\n\t      const precedingTokens = cumulativeTokenCounts[i - 1];\n\t      // console.log({ truncationIndex: i, precedingTokens });\n\t      const summaryWordLimit = Math.floor(\n", "        (this.compressionThreshold * AVG_WORDS_PER_TOKEN) / 6\n\t      );\n\t      const eventsToSummarize = events.slice(0, i);\n\t      // console.log(\n\t      //   `Summarizing ${eventsToSummarize.length} events (${eventsToSummarize\n\t      //     .map(countTokens)\n\t      //     .reduce((sum, next) => sum + next, 0)} tokens)`\n\t      // );\n\t      const summaryContent = await makeDecision([\n\t        ...eventsToSummarize,\n", "        {\n\t          type: \"message\",\n\t          message: messageBuilder.ok(\n\t            this.agentId,\n\t            `Write a summary in ${summaryWordLimit} words or less of what has happened since (but not including) the introductory message. Include key information that you learned which you don't want to forget. This information will serve as a note to yourself to help you understand what has gone before. Use the second person voice, as if you are someone filling in your replacement who knows nothing. The summarized messages will be omitted from your context window going forward and you will only have this summary to go by, so make it as useful and information-dense as possible. Be as specific as possible, but only include important information. If there are details that seem unimportant, or which you could recover outside of your memory (for instance the particular contents of a file which you could read any time), then omit them from your summary. Once again, your summary must not exceed ${summaryWordLimit} words. In this particular instance, your response should just be raw text, not formatted as an action.`\n\t          ),\n\t        },\n\t      ]);\n\t      const summary = `Several events are omitted here to free up space in your context window, summarized as follows:\\n\\n${summaryContent}`;\n\t      // const summary =\n", "      //   \"Several events are omitted here to free up space in your context window.\";\n\t      const summaryEvent: Event = {\n\t        type: \"message\",\n\t        message: messageBuilder.spontaneous(this.agentId, summary),\n\t      };\n\t      const summaryTokens = countTokens(summaryEvent);\n\t      const tokenSavings =\n\t        precedingTokens - summaryTokens - cumulativeTokenCounts[0];\n\t      if (tokenSavings > 0) {\n\t        // console.log(\n", "        //   `Summarized events, saving ${tokenSavings} tokens:\\n\\n${summary}`\n\t        // );\n\t        const newEvents = [events[0], summaryEvent, ...events.slice(i)];\n\t        // const newCumulativeTokenCounts =\n\t        //   this.getCumulativeTokenCounts(newEvents);\n\t        // console.log({ newCumulativeTokenCounts });\n\t        return newEvents;\n\t      }\n\t    }\n\t    return events;\n", "  }\n\t  private getCumulativeTokenCounts(events: Event[]) {\n\t    return events.reduce((counts, event) => {\n\t      const prevSum = counts.length ? counts[counts.length - 1] : 0;\n\t      counts.push(prevSum + countTokens(event));\n\t      return counts;\n\t    }, [] as number[]);\n\t  }\n\t  private get key() {\n\t    return \"memory\";\n", "  }\n\t  private printEvent(event: Event) {\n\t    let sourceName: string;\n\t    let targetNames: string[];\n\t    if (event.type === \"message\") {\n\t      const { message } = event;\n\t      sourceName = messageSourceName(message.source);\n\t      targetNames = message.targetAgentIds?.map(agentName);\n\t    } else {\n\t      sourceName = agentName(this.agentId);\n", "      targetNames = [\"System\"];\n\t    }\n\t    console.log(\n\t      `${sourceName} -> ${targetNames.join(\", \")}:\\n\\n${\n\t        toOpenAiMessage(event).content\n\t      }\\n\\n=============\\n`\n\t    );\n\t  }\n\t}\n\tfunction countTokens(event: Event) {\n", "  return countTokensInText(toOpenAiMessage(event).content);\n\t}\n"]}
