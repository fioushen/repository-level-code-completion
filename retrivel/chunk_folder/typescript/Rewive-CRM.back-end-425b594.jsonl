{"filename": "test/app.e2e-spec.ts", "chunked_list": ["import { Test, TestingModule } from '@nestjs/testing';\n\timport { INestApplication } from '@nestjs/common';\n\timport * as request from 'supertest';\n\timport { AppModule } from './../src/app.module';\n\tdescribe('AppController (e2e)', () => {\n\t  let app: INestApplication;\n\t  beforeEach(async () => {\n\t    const moduleFixture: TestingModule = await Test.createTestingModule({\n\t      imports: [AppModule],\n\t    }).compile();\n", "    app = moduleFixture.createNestApplication();\n\t    await app.init();\n\t  });\n\t  it('/ (GET)', () => {\n\t    return request(app.getHttpServer())\n\t      .get('/')\n\t      .expect(200)\n\t      .expect('Hello World!');\n\t  });\n\t});\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { ValidationPipe } from '@nestjs/common';\n\timport { NestFactory } from '@nestjs/core';\n\timport { FastifyAdapter, NestFastifyApplication } from '@nestjs/platform-fastify';\n\timport { AppModule } from './app.module';\n\timport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\n\timport { ConfigService } from '@nestjs/config';\n\timport helmet from '@fastify/helmet'\n\tasync function bootstrap() {\n\t  const configService = new ConfigService();\n\t  const app = await NestFactory.create<NestFastifyApplication>(\n", "    AppModule,\n\t    new FastifyAdapter({\n\t      maxParamLength: configService.get('MAX_PARAMS_LENGTH'),\n\t    }),\n\t  );\n\t  app.useGlobalPipes(\n\t    new ValidationPipe({\n\t      whitelist: true,\n\t      transform: true,\n\t    }),\n", "  );\n\t  app.getHttpAdapter().getInstance().register(helmet);\n\t  const config = new DocumentBuilder()\n\t    .setTitle('CRM')\n\t    .setDescription('API CRM')\n\t    .setVersion('1.0')\n\t    .addTag('crm')\n\t    .addBearerAuth()\n\t    .build();\n\t  const document = SwaggerModule.createDocument(app, config);\n", "  SwaggerModule.setup('api/docs', app, document);\n\t  await app.listen(configService.get('PORT'));\n\t}\n\tbootstrap();"]}
{"filename": "src/app.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\tinterface AuthResponse {\n\t  status: string;\n\t}\n\t@Injectable()\n\texport class AppService {\n\t  CheckAuth(): AuthResponse {\n\t    return {status: \"OK\"};\n\t  }\n\t}\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { ConfigModule, ConfigService } from '@nestjs/config';\n\timport { AppController } from './app.controller';\n\timport { AppService } from './app.service';\n\timport { JwtStrategy } from './strategy/jwt.strategy';\n\timport { AuthModule } from './auth/auth.module';\n\timport { UsersModule } from './users/users.module';\n\timport { MongooseModule } from '@nestjs/mongoose';\n\timport { ThrottlerModule } from '@nestjs/throttler';\n\t@Module({\n", "  imports: [\n\t    MongooseModule.forRootAsync({\n\t      imports: [ConfigModule],\n\t      useFactory: (configService: ConfigService) => ({\n\t        uri: configService.get('MONGODB_URI'),\n\t      }),\n\t      inject: [ConfigService],\n\t    }),\n\t    ThrottlerModule.forRootAsync({\n\t      imports: [ConfigModule],\n", "      useFactory: (configService: ConfigService) => ({\n\t        ttl: configService.get('TTL'),\n\t        limit: configService.get('LIMIT'),\n\t      }),\n\t      inject: [ConfigService],\n\t    }),\n\t    ConfigModule.forRoot({\n\t      envFilePath: '.env',\n\t    }),\n\t    AuthModule,\n", "    UsersModule,\n\t  ],\n\t  controllers: [AppController],\n\t  providers: [AppService, JwtStrategy],\n\t})\n\texport class AppModule {}"]}
{"filename": "src/app.controller.ts", "chunked_list": ["import { Controller, Get , UseGuards } from '@nestjs/common';\n\timport { AppService } from './app.service';\n\timport { JwtAuthGuard } from './guards/jwt-auth.guards';\n\t@Controller()\n\texport class AppController {\n\t  constructor(private readonly appService: AppService) {}\n\t  @UseGuards(JwtAuthGuard)\n\t  @Get('/')\n\t  CheckAuth(): object {\n\t    return this.appService.CheckAuth();\n", "  }\n\t}\n"]}
{"filename": "src/strategy/jwt.strategy.ts", "chunked_list": ["import { ExtractJwt, Strategy } from 'passport-jwt';\n\timport { PassportStrategy } from '@nestjs/passport';\n\timport { Injectable } from '@nestjs/common';\n\t@Injectable()\n\texport class JwtStrategy extends PassportStrategy(Strategy) {\n\t    constructor() {\n\t        super({\n\t            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n\t            ignoreExpiration: false,\n\t            secretOrKey: process.env.JWT_SECRET,\n", "        });\n\t    }\n\t    async validate(payload: any) {\n\t        return { userId: payload.sub, username: payload.username };\n\t    }\n\t}"]}
{"filename": "src/users/users.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { MongooseModule } from '@nestjs/mongoose';\n\timport { ConfigModule, ConfigService } from '@nestjs/config';\n\timport { PassportModule } from '@nestjs/passport';\n\timport { JwtModule } from '@nestjs/jwt';\n\timport { JwtStrategy } from '../strategy/jwt.strategy';\n\timport { UsersController } from '../users/users.controller';\n\timport { UsersService } from '../users/users.service';\n\timport { Users, UsersSchema } from './models';\n\t@Module({\n", "  imports: [\n\t    MongooseModule.forFeature([{ name: Users.name, schema: UsersSchema }]),\n\t    PassportModule,\n\t    JwtModule.registerAsync({\n\t      imports: [ConfigModule],\n\t      useFactory: (configService: ConfigService) => ({\n\t        secret: configService.get('JWT_SECRET'),\n\t        signOptions: { expiresIn: configService.get('JWT_EXPIRES_IN') },\n\t      }),\n\t      inject: [ConfigService],\n", "    }),\n\t  ],\n\t  controllers: [UsersController],\n\t  providers: [UsersService, JwtStrategy],\n\t})\n\texport class UsersModule {}"]}
{"filename": "src/users/users.service.ts", "chunked_list": ["import { Injectable, ConflictException, NotFoundException, BadRequestException } from '@nestjs/common';\n\timport { InjectModel } from '@nestjs/mongoose';\n\timport { Model } from 'mongoose';\n\timport { Users, UsersDocument } from './models';\n\timport { CreateUsersDto, UpdateUsersDto, DeleteUsersDto, IdUsersDto } from './dto';\n\t@Injectable()\n\texport class UsersService {\n\t    constructor(@InjectModel(Users.name) private usersModel: Model<UsersDocument>) {}\n\t    async findAll(): Promise<Users[]> {\n\t        return this.usersModel.find().exec();\n", "    }\n\t    async findOne(idUsersDto: IdUsersDto): Promise<Users> {\n\t        try {\n\t            const user = await this.usersModel.findById(idUsersDto.id).orFail();\n\t            return user;\n\t        } catch (error) {\n\t            if (error.name === 'DocumentNotFoundError') {\n\t                throw new NotFoundException('User not found');\n\t            }\n\t            throw new BadRequestException('Invalid id');\n", "        }\n\t    }\n\t    async create(createUsersDto: CreateUsersDto): Promise<Users> {\n\t        const existingUser = await this.usersModel.findOne({ email: createUsersDto.email });\n\t        if (existingUser) {\n\t            throw new ConflictException('User with this email already exists');\n\t        }\n\t        const createdUser = new this.usersModel(createUsersDto);\n\t        return createdUser.save();\n\t    }\n", "    async update(ctachidUsersDto: IdUsersDto, updateUsersDto: UpdateUsersDto): Promise<Users> {\n\t        try {\n\t            const updatedUser = await this.usersModel.findByIdAndUpdate(ctachidUsersDto.id, updateUsersDto, { new: true }).orFail();\n\t            return updatedUser;\n\t        } catch (error) {\n\t            if (error.name === 'DocumentNotFoundError') {\n\t                throw new NotFoundException('User not found');\n\t            }\n\t            throw new BadRequestException('Invalid id');\n\t        }\n", "    }\n\t    async remove(deleteUsersDto: DeleteUsersDto): Promise<{ status: string }> {\n\t        try {\n\t            await this.usersModel.findByIdAndDelete(deleteUsersDto.id).orFail();\n\t            return { status: 'Deleted' };\n\t        } catch (error) {\n\t            if (error.name === 'DocumentNotFoundError') {\n\t                throw new NotFoundException('User not found');\n\t            }\n\t            throw new BadRequestException('Invalid id');\n", "        }\n\t    }\n\t}"]}
{"filename": "src/users/users.controller.ts", "chunked_list": ["import { Controller, Post, Get, Body, UseGuards, Param, Patch, Delete } from '@nestjs/common';\n\timport { UsersService } from './users.service';\n\timport { CreateUsersDto, DeleteUsersDto, UpdateUsersDto, IdUsersDto } from './dto'\n\timport { JwtAuthGuard } from '../guards/jwt-auth.guards';\n\timport { ThrottlerGuard } from '@nestjs/throttler';\n\t@UseGuards(ThrottlerGuard) \n\t@Controller('api/users')\n\texport class UsersController {\n\t  constructor(private readonly usersService: UsersService) { }\n\t  @UseGuards(JwtAuthGuard)\n", "  @Get('/')\n\t  async findAll() {\n\t    return this.usersService.findAll();\n\t  }\n\t  @UseGuards(JwtAuthGuard)\n\t  @Get(':id')\n\t  async findOne(@Param() idUsersDto: IdUsersDto) {\n\t    return this.usersService.findOne(idUsersDto);\n\t  }\n\t  @UseGuards(JwtAuthGuard)\n", "  @Post('/create')\n\t  async create(@Body() createUsersDto: CreateUsersDto) {\n\t    return this.usersService.create(createUsersDto);\n\t  }\n\t  @UseGuards(JwtAuthGuard)\n\t  @Patch(':id')\n\t  async update(@Param() catchidUsersDto: IdUsersDto, @Body() updateUsersDto: UpdateUsersDto) {\n\t    console.log('update route called with:', catchidUsersDto, updateUsersDto);\n\t    return this.usersService.update(catchidUsersDto, updateUsersDto);\n\t  }\n", "  @UseGuards(JwtAuthGuard)\n\t  @Delete(':id')\n\t  async remove(@Param() deleteUsersDto: DeleteUsersDto) {\n\t    return this.usersService.remove(deleteUsersDto);\n\t  }\n\t}"]}
{"filename": "src/users/models/index.ts", "chunked_list": ["export * from './users.model';"]}
{"filename": "src/users/models/users.model.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\n\timport { Document } from 'mongoose';\n\texport type UsersDocument = Users & Document;\n\t@Schema()\n\texport class Users {\n\t  @Prop()\n\t  name: string;\n\t  @Prop()\n\t  lastname: string;\n\t  @Prop()\n", "  patronymic: string;\n\t  @Prop()\n\t  email: string;\n\t  @Prop()\n\t  password: string;\n\t  @Prop({ type: Number })\n\t  age: number;\n\t}\n\texport const UsersSchema = SchemaFactory.createForClass(Users);"]}
{"filename": "src/users/dto/users-create.dto.ts", "chunked_list": ["import { IsNotEmpty, IsString, IsEmail, IsInt } from 'class-validator';\n\texport class CreateUsersDto {\n\t  @IsString()\n\t  @IsNotEmpty()\n\t  public name: string;\n\t  @IsString()\n\t  @IsNotEmpty()\n\t  public lastname: string;\n\t  @IsString()\n\t  @IsNotEmpty()\n", "  public patronymic: string;\n\t  @IsEmail()\n\t  @IsNotEmpty()\n\t  public email: string;\n\t  @IsInt()\n\t  @IsNotEmpty()\n\t  public age: number;\n\t}"]}
{"filename": "src/users/dto/users-update.dto.ts", "chunked_list": ["import { IsNotEmpty, IsOptional, IsString, IsEmail, IsInt, IsMongoId } from 'class-validator';\n\texport class UpdateUsersDto {\n\t  @IsString()\n\t  @IsOptional()\n\t  @IsNotEmpty()\n\t  public name: string;\n\t  @IsString()\n\t  @IsOptional()\n\t  @IsNotEmpty()\n\t  public lastname: string;\n", "  @IsString()\n\t  @IsOptional()\n\t  @IsNotEmpty()\n\t  public patronymic: string;\n\t  @IsEmail()\n\t  @IsOptional()\n\t  @IsNotEmpty()\n\t  public email: string;\n\t  @IsInt()\n\t  @IsOptional()\n", "  @IsNotEmpty()\n\t  public age: number;\n\t}"]}
{"filename": "src/users/dto/users-delete.dto.ts", "chunked_list": ["import { IsString, IsMongoId } from 'class-validator';\n\texport class DeleteUsersDto {\n\t  @IsString()\n\t  @IsMongoId()\n\t  public id: string;\n\t}"]}
{"filename": "src/users/dto/index.ts", "chunked_list": ["export * from './users-create.dto';\n\texport * from './users-delete.dto';\n\texport * from './users-update.dto';\n\texport * from './users-id.dto';"]}
{"filename": "src/users/dto/users-id.dto.ts", "chunked_list": ["import { IsString, IsMongoId } from 'class-validator';\n\texport class IdUsersDto {\n\t  @IsString()\n\t  @IsMongoId()\n\t  public id: string;\n\t}"]}
{"filename": "src/auth/auth.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { AuthController } from './auth.controller';\n\timport { AuthService } from './auth.service';\n\timport { MongooseModule } from '@nestjs/mongoose';\n\timport { Auth, AuthSchema } from './models';\n\timport { PassportModule } from '@nestjs/passport';\n\timport { JwtModule } from '@nestjs/jwt';\n\timport { JwtStrategy } from '../strategy/jwt.strategy';\n\timport { ConfigModule, ConfigService } from '@nestjs/config';\n\t@Module({\n", "  imports: [\n\t    MongooseModule.forFeature([{ name: Auth.name, schema: AuthSchema }]),\n\t    PassportModule,\n\t    JwtModule.registerAsync({\n\t      imports: [ConfigModule],\n\t      useFactory: (configService: ConfigService) => ({\n\t        secret: configService.get('JWT_SECRET'),\n\t        signOptions: { expiresIn: configService.get('JWT_EXPIRES_IN') },\n\t      }),\n\t      inject: [ConfigService],\n", "    }),\n\t  ],\n\t  controllers: [AuthController],\n\t  providers: [AuthService, JwtStrategy],\n\t})\n\texport class AuthModule { }"]}
{"filename": "src/auth/auth.controller.ts", "chunked_list": ["import { Controller, Post, Get, Body, Request, Param, UseGuards } from '@nestjs/common';\n\timport { AuthService } from './auth.service';\n\timport { SignAuthDto, LoginAuthDto, ConfirmAuthDto } from './dto';\n\timport { ThrottlerGuard } from '@nestjs/throttler';\n\t@UseGuards(ThrottlerGuard) \n\t@Controller('api/auth')\n\texport class AuthController {\n\t    constructor(private readonly authService: AuthService) { }\n\t    @Post('/sign')\n\t    async sign(@Body() signAuthDto: SignAuthDto) {\n", "        return this.authService.sign(signAuthDto);\n\t    }\n\t    @Post('/login')\n\t    async login(@Body() loginAuthDto: LoginAuthDto, @Request() req) {\n\t        return this.authService.login(loginAuthDto);\n\t    }\n\t    @Get('confirm/:token')\n\t    async confirm(@Param() confirmAuthDto: ConfirmAuthDto) {\n\t        return this.authService.confirm(confirmAuthDto);\n\t    }\n", "}"]}
{"filename": "src/auth/auth.service.ts", "chunked_list": ["import { Injectable, ConflictException, UnauthorizedException, NotFoundException, } from '@nestjs/common';\n\timport { TokenExpiredError } from 'jsonwebtoken';\n\timport { Model } from 'mongoose';\n\timport { InjectModel } from '@nestjs/mongoose';\n\timport { Auth } from './models/auth.model';\n\timport { LoginAuthDto, SignAuthDto, ConfirmAuthDto } from './dto'\n\timport { JwtService } from '@nestjs/jwt';\n\timport { ConfigService } from '@nestjs/config';\n\timport * as argon2 from 'argon2';\n\tinterface AuthResponse {\n", "    status: string;\n\t}\n\t@Injectable()\n\texport class AuthService {\n\t    constructor(\n\t        @InjectModel(Auth.name) private AuthModel: Model<Auth>,\n\t        private jwtService: JwtService,\n\t    ) {}\n\t    async sign(SignAuthDto: SignAuthDto): Promise<object> {\n\t        // Проверка на наличие пользователя с таким же адресом электронной почты\n", "        const existingUser = await this.AuthModel.findOne({ email: SignAuthDto.email });\n\t        if (existingUser) {\n\t            throw new ConflictException('Email already exists');\n\t        }\n\t        // Хеширование пароля с помощью argon2i\n\t        const hashedPassword = await argon2.hash(SignAuthDto.password, { type: argon2.argon2i });\n\t        // Сохранение пользователя в базе данных с хешированным паролем\n\t        const createdAuth = new this.AuthModel({ ...SignAuthDto, password: hashedPassword });\n\t        const result = await createdAuth.save();\n\t        // Создание токена JWT\n", "        const token = this.jwtService.sign({ id: result._id }, { expiresIn: '30d' });\n\t        // Сохранение токена в базе данных\n\t        result.token = token;\n\t        await result.save();\n\t        // Создание токена для подтверждения регистрации с дополнительной информацией и сроком действия\n\t        const confirmtoken = this.jwtService.sign(\n\t            { id: result._id, type: 'confirmation', email: SignAuthDto.email },\n\t            { expiresIn: '7d' },\n\t        );\n\t        // Создание ссылки для подтверждения регистрации\n", "        const confirmationLink = `http://localhost:${new ConfigService().get('PORT')}/api/auth/confirm/${confirmtoken}`;\n\t        return { access_token: token, link: confirmationLink };\n\t    }\n\t    async login(LoginAuthDto: LoginAuthDto): Promise<object> {\n\t        // Поиск пользователя по адресу электронной почты\n\t        const user = await this.AuthModel.findOne({ email: LoginAuthDto.email });\n\t        if (!user) {\n\t            throw new UnauthorizedException('Invalid email or password');\n\t        }\n\t        // Проверка совпадения паролей с помощью argon2.verify()\n", "        const passwordMatch = await argon2.verify(user.password, LoginAuthDto.password);\n\t        if (!passwordMatch) {\n\t            throw new UnauthorizedException('Invalid email or password');\n\t        }\n\t        // Создание токена JWT\n\t        const token = this.jwtService.sign({ id: user._id });\n\t        return { access_token: token };\n\t    }\n\t    async confirm(confirmAuthDto: ConfirmAuthDto): Promise<object> {\n\t        let payload: { id: any; };\n", "        try {\n\t            // Проверка токена JWT\n\t            payload = this.jwtService.verify(confirmAuthDto.token);\n\t        } catch (error) {\n\t            if (error instanceof TokenExpiredError) {\n\t                throw new UnauthorizedException('Token expired');\n\t            } else {\n\t                throw new UnauthorizedException('Invalid token');\n\t            }\n\t        }\n", "        // Поиск пользователя по идентификатору из токена\n\t        const user = await this.AuthModel.findById(payload.id);\n\t        if (!user) {\n\t            throw new NotFoundException('User not found');\n\t        }\n\t        // Обновление статуса пользователя на \"подтвержденный\"\n\t        user.confirmed = true;\n\t        await user.save();\n\t        return { status: 'Confirmed' };\n\t    }\n", "    CheckAuth(): AuthResponse {\n\t        return { status: \"OK\" };\n\t    }\n\t}"]}
{"filename": "src/auth/models/auth.model.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\n\timport { HydratedDocument } from 'mongoose';\n\texport type AuthDocument = HydratedDocument<Auth>;\n\t@Schema()\n\texport class Auth {\n\t  @Prop()\n\t  name: string;\n\t  @Prop()\n\t  lastname: string;\n\t  @Prop()\n", "  email: string;\n\t  @Prop()\n\t  password: string;\n\t  @Prop()\n\t  token: string;\n\t  @Prop({ default: false })\n\t  confirmed: boolean;\n\t}\n\texport const AuthSchema = SchemaFactory.createForClass(Auth);"]}
{"filename": "src/auth/models/index.ts", "chunked_list": ["export * from './auth.model';"]}
{"filename": "src/auth/dto/auth-sign.dto.ts", "chunked_list": ["import { IsNotEmpty, IsString, IsEmail } from 'class-validator';\n\texport class SignAuthDto {\n\t    @IsString()\n\t    @IsNotEmpty()\n\t    public name: string;\n\t    @IsString()\n\t    @IsNotEmpty()\n\t    public lastname: string;\n\t    @IsString()\n\t    @IsNotEmpty()\n", "    @IsEmail()\n\t    public email: string;\n\t    @IsString()\n\t    @IsNotEmpty()\n\t    public password: string;\n\t  }"]}
{"filename": "src/auth/dto/index.ts", "chunked_list": ["export * from './auth-sign.dto';\n\texport * from './auth-login.dto';\n\texport * from './auth-confirm.dto';"]}
{"filename": "src/auth/dto/auth-login.dto.ts", "chunked_list": ["import { IsNotEmpty, IsString, IsEmail } from 'class-validator';\n\texport class LoginAuthDto {\n\t    @IsString()\n\t    @IsNotEmpty()\n\t    @IsEmail()\n\t    public email: string;\n\t    @IsString()\n\t    @IsNotEmpty()\n\t    public password: string;\n\t  }"]}
{"filename": "src/auth/dto/auth-confirm.dto.ts", "chunked_list": ["import { IsString, IsNotEmpty, MaxLength } from 'class-validator';\n\texport class ConfirmAuthDto {\n\t    @IsString()\n\t    @IsNotEmpty()\n\t    @MaxLength(300)\n\t    public token: string;\n\t}"]}
{"filename": "src/guards/jwt-auth.guards.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\timport { AuthGuard } from '@nestjs/passport';\n\t@Injectable()\n\texport class JwtAuthGuard extends AuthGuard('jwt') {}"]}
