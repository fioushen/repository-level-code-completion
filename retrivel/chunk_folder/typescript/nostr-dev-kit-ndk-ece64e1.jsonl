{"filename": "src/index.ts", "chunked_list": ["import debug from \"debug\";\n\timport EventEmitter from \"eventemitter3\";\n\timport { NDKCacheAdapter } from \"./cache/index.js\";\n\timport dedupEvent from \"./events/dedup.js\";\n\timport NDKEvent from \"./events/index.js\";\n\timport type { NDKRelay } from \"./relay/index.js\";\n\timport { NDKPool } from \"./relay/pool/index.js\";\n\timport { calculateRelaySetFromEvent } from \"./relay/sets/calculate.js\";\n\timport { NDKRelaySet } from \"./relay/sets/index.js\";\n\timport { correctRelaySet } from \"./relay/sets/utils.js\";\n", "import type { NDKSigner } from \"./signers/index.js\";\n\timport {\n\t    NDKFilter,\n\t    NDKSubscription,\n\t    NDKSubscriptionOptions,\n\t    filterFromId,\n\t    relaysFromBech32,\n\t} from \"./subscription/index.js\";\n\timport NDKUser, { NDKUserParams } from \"./user/index.js\";\n\timport { NDKUserProfile } from \"./user/profile.js\";\n", "export { NDKEvent, NDKUser, NDKFilter, NDKUserProfile, NDKCacheAdapter };\n\texport * from \"./events/index.js\";\n\texport * from \"./events/kinds/index.js\";\n\texport * from \"./events/kinds/article.js\";\n\texport * from \"./events/kinds/dvm/index.js\";\n\texport * from \"./events/kinds/lists/index.js\";\n\texport * from \"./events/kinds/repost.js\";\n\texport * from \"./relay/index.js\";\n\texport * from \"./relay/sets/index.js\";\n\texport * from \"./signers/index.js\";\n", "export * from \"./signers/nip07/index.js\";\n\texport * from \"./signers/nip46/backend/index.js\";\n\texport * from \"./signers/nip46/rpc.js\";\n\texport * from \"./signers/nip46/index.js\";\n\texport * from \"./signers/private-key/index.js\";\n\texport * from \"./subscription/index.js\";\n\texport * from \"./user/profile.js\";\n\texport { NDKZapInvoice, zapInvoiceFromEvent } from \"./zap/invoice.js\";\n\texport interface NDKConstructorParams {\n\t    explicitRelayUrls?: string[];\n", "    devWriteRelayUrls?: string[];\n\t    signer?: NDKSigner;\n\t    cacheAdapter?: NDKCacheAdapter;\n\t    debug?: debug.Debugger;\n\t}\n\texport interface GetUserParams extends NDKUserParams {\n\t    npub?: string;\n\t    hexpubkey?: string;\n\t}\n\texport default class NDK extends EventEmitter {\n", "    public pool: NDKPool;\n\t    public signer?: NDKSigner;\n\t    public cacheAdapter?: NDKCacheAdapter;\n\t    public debug: debug.Debugger;\n\t    public devWriteRelaySet?: NDKRelaySet;\n\t    public delayedSubscriptions: Map<string, NDKSubscription[]>;\n\t    public constructor(opts: NDKConstructorParams = {}) {\n\t        super();\n\t        this.debug = opts.debug || debug(\"ndk\");\n\t        this.pool = new NDKPool(opts.explicitRelayUrls || [], this);\n", "        this.signer = opts.signer;\n\t        this.cacheAdapter = opts.cacheAdapter;\n\t        this.delayedSubscriptions = new Map();\n\t        if (opts.devWriteRelayUrls) {\n\t            this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(\n\t                opts.devWriteRelayUrls,\n\t                this\n\t            );\n\t        }\n\t    }\n", "    public toJSON(): string {\n\t        return { relayCount: this.pool.relays.size }.toString();\n\t    }\n\t    /**\n\t     * Connect to relays with optional timeout.\n\t     * If the timeout is reached, the connection will be continued to be established in the background.\n\t     */\n\t    public async connect(timeoutMs?: number): Promise<void> {\n\t        this.debug(\"Connecting to relays\", { timeoutMs });\n\t        return this.pool.connect(timeoutMs);\n", "    }\n\t    /**\n\t     * Get a NDKUser object\n\t     *\n\t     * @param opts\n\t     * @returns\n\t     */\n\t    public getUser(opts: GetUserParams): NDKUser {\n\t        const user = new NDKUser(opts);\n\t        user.ndk = this;\n", "        return user;\n\t    }\n\t    /**\n\t     * Create a new subscription. Subscriptions automatically start and finish when all relays\n\t     * on the set send back an EOSE. (set `opts.closeOnEose` to `false` in order avoid this)\n\t     *\n\t     * @param filters\n\t     * @param opts\n\t     * @param relaySet explicit relay set to use\n\t     * @param autoStart automatically start the subscription\n", "     * @returns NDKSubscription\n\t     */\n\t    public subscribe(\n\t        filters: NDKFilter | NDKFilter[],\n\t        opts?: NDKSubscriptionOptions,\n\t        relaySet?: NDKRelaySet,\n\t        autoStart = true\n\t    ): NDKSubscription {\n\t        const subscription = new NDKSubscription(this, filters, opts, relaySet);\n\t        // Signal to the relays that they are explicitly being used\n", "        if (relaySet) {\n\t            for (const relay of relaySet.relays) {\n\t                this.pool.useTemporaryRelay(relay);\n\t            }\n\t        }\n\t        if (autoStart) subscription.start();\n\t        return subscription;\n\t    }\n\t    /**\n\t     * Publish an event to a relay\n", "     * @param event event to publish\n\t     * @param relaySet explicit relay set to use\n\t     * @param timeoutMs timeout in milliseconds to wait for the event to be published\n\t     * @returns The relays the event was published to\n\t     *\n\t     * @deprecated Use `event.publish()` instead\n\t     */\n\t    public async publish(\n\t        event: NDKEvent,\n\t        relaySet?: NDKRelaySet,\n", "        timeoutMs?: number\n\t    ): Promise<Set<NDKRelay>> {\n\t        this.debug(\"Deprecated: Use `event.publish()` instead\");\n\t        if (!relaySet) {\n\t            // If we have a devWriteRelaySet, use it to publish all events\n\t            relaySet =\n\t                this.devWriteRelaySet ||\n\t                calculateRelaySetFromEvent(this, event);\n\t        }\n\t        return relaySet.publish(event, timeoutMs);\n", "    }\n\t    /**\n\t     * Fetch a single event.\n\t     *\n\t     * @param idOrFilter event id in bech32 format or filter\n\t     * @param opts subscription options\n\t     * @param relaySet explicit relay set to use\n\t     */\n\t    public async fetchEvent(\n\t        idOrFilter: string | NDKFilter,\n", "        opts?: NDKSubscriptionOptions,\n\t        relaySet?: NDKRelaySet\n\t    ): Promise<NDKEvent | null> {\n\t        let filter: NDKFilter;\n\t        // if no relayset has been provided, try to get one from the event id\n\t        if (!relaySet && typeof idOrFilter === \"string\") {\n\t            const relays = relaysFromBech32(idOrFilter);\n\t            if (relays.length > 0) {\n\t                relaySet = new NDKRelaySet(new Set<NDKRelay>(relays), this);\n\t                // Make sure we have connected relays in this set\n", "                relaySet = correctRelaySet(relaySet, this.pool);\n\t            }\n\t        }\n\t        if (typeof idOrFilter === \"string\") {\n\t            filter = filterFromId(idOrFilter);\n\t        } else {\n\t            filter = idOrFilter;\n\t        }\n\t        if (!filter) {\n\t            throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);\n", "        }\n\t        return new Promise((resolve) => {\n\t            const s = this.subscribe(\n\t                filter,\n\t                { ...(opts || {}), closeOnEose: true },\n\t                relaySet,\n\t                false\n\t            );\n\t            s.on(\"event\", (event) => {\n\t                event.ndk = this;\n", "                resolve(event);\n\t            });\n\t            s.on(\"eose\", () => {\n\t                resolve(null);\n\t            });\n\t            s.start();\n\t        });\n\t    }\n\t    /**\n\t     * Fetch events\n", "     */\n\t    public async fetchEvents(\n\t        filters: NDKFilter | NDKFilter[],\n\t        opts?: NDKSubscriptionOptions,\n\t        relaySet?: NDKRelaySet\n\t    ): Promise<Set<NDKEvent>> {\n\t        return new Promise((resolve) => {\n\t            const events: Map<string, NDKEvent> = new Map();\n\t            const relaySetSubscription = this.subscribe(\n\t                filters,\n", "                { ...(opts || {}), closeOnEose: true },\n\t                relaySet,\n\t                false\n\t            );\n\t            const onEvent = (event: NDKEvent) => {\n\t                const dedupKey = event.deduplicationKey();\n\t                const existingEvent = events.get(dedupKey);\n\t                if (existingEvent) {\n\t                    event = dedupEvent(existingEvent, event);\n\t                }\n", "                event.ndk = this;\n\t                events.set(dedupKey, event);\n\t            };\n\t            // We want to inspect duplicated events\n\t            // so we can dedup them\n\t            relaySetSubscription.on(\"event\", onEvent);\n\t            relaySetSubscription.on(\"event:dup\", onEvent);\n\t            relaySetSubscription.on(\"eose\", () => {\n\t                resolve(new Set(events.values()));\n\t            });\n", "            relaySetSubscription.start();\n\t        });\n\t    }\n\t    /**\n\t     * Ensures that a signer is available to sign an event.\n\t     */\n\t    public async assertSigner() {\n\t        if (!this.signer) {\n\t            this.emit(\"signerRequired\");\n\t            throw new Error(\"Signer required\");\n", "        }\n\t    }\n\t}\n"]}
{"filename": "src/light-bolt11-decoder.d.ts", "chunked_list": ["declare module \"light-bolt11-decoder\" {\n\t    export function decode(bolt11: string): any;\n\t}\n"]}
{"filename": "src/zap/invoice.ts", "chunked_list": ["import { decode } from \"light-bolt11-decoder\";\n\timport NDKEvent, { type NDKEventId, type NostrEvent } from \"../events/index.js\";\n\texport interface NDKZapInvoice {\n\t    id?: NDKEventId;\n\t    zapper: string; // pubkey of zapper app\n\t    zappee: string; // pubkey of user sending zap\n\t    zapped: string; // pubkey of user receiving zap\n\t    zappedEvent?: string; // event zapped\n\t    amount: number; // amount zapped in millisatoshis\n\t    comment?: string;\n", "}\n\t/**\n\t * Parses a zap invoice from a kind 9735 event\n\t *\n\t * @param event The event to parse\n\t *\n\t * @returns NDKZapInvoice | null\n\t */\n\texport function zapInvoiceFromEvent(event: NDKEvent): NDKZapInvoice | null {\n\t    const description = event.getMatchingTags(\"description\")[0];\n", "    const bolt11 = event.getMatchingTags(\"bolt11\")[0];\n\t    let decodedInvoice;\n\t    let zapRequest: NostrEvent;\n\t    if (!description || !bolt11 || !bolt11[1]) {\n\t        return null;\n\t    }\n\t    try {\n\t        let zapRequestPayload = description[1];\n\t        if (zapRequestPayload.startsWith(\"%\")) {\n\t            zapRequestPayload = decodeURIComponent(zapRequestPayload);\n", "        }\n\t        if (zapRequestPayload === \"\") {\n\t            return null;\n\t        }\n\t        zapRequest = JSON.parse(zapRequestPayload);\n\t        decodedInvoice = decode(bolt11[1]);\n\t    } catch (e) {\n\t        return null;\n\t    }\n\t    const amountSection = decodedInvoice.sections.find(\n", "        (s: any) => s.name === \"amount\"\n\t    );\n\t    if (!amountSection) {\n\t        return null;\n\t    }\n\t    const amount = parseInt(amountSection.value);\n\t    if (!amount) {\n\t        return null;\n\t    }\n\t    const content = zapRequest.content;\n", "    const sender = zapRequest.pubkey;\n\t    const recipientTag = event.getMatchingTags(\"p\")[0];\n\t    const recipient = recipientTag[1];\n\t    let zappedEvent = event.getMatchingTags(\"e\")[0];\n\t    if (!zappedEvent) {\n\t        zappedEvent = event.getMatchingTags(\"a\")[0];\n\t    }\n\t    const zappedEventId = zappedEvent ? zappedEvent[1] : undefined;\n\t    // ignore self-zaps (TODO: configurable?)\n\t    // if (sender === recipient) { return null; } XXX\n", "    const zapInvoice: NDKZapInvoice = {\n\t        id: event.id,\n\t        zapper: event.pubkey,\n\t        zappee: sender,\n\t        zapped: recipient,\n\t        zappedEvent: zappedEventId,\n\t        amount,\n\t        comment: content,\n\t    };\n\t    return zapInvoice;\n", "}\n"]}
{"filename": "src/zap/index.ts", "chunked_list": ["import { bech32 } from \"@scure/base\";\n\timport EventEmitter from \"eventemitter3\";\n\timport { nip57 } from \"nostr-tools\";\n\timport type { NostrEvent } from \"../events/index.js\";\n\timport NDKEvent, { NDKTag } from \"../events/index.js\";\n\timport NDK from \"../index.js\";\n\timport User from \"../user/index.js\";\n\tconst DEFAULT_RELAYS = [\n\t    \"wss://nos.lol\",\n\t    \"wss://relay.nostr.band\",\n", "    \"wss://relay.f7z.io\",\n\t    \"wss://relay.damus.io\",\n\t    \"wss://nostr.mom\",\n\t    \"wss://no.str.cr\",\n\t];\n\tinterface ZapConstructorParams {\n\t    ndk: NDK;\n\t    zappedEvent?: NDKEvent;\n\t    zappedUser?: User;\n\t}\n", "type ZapConstructorParamsRequired = Required<\n\t    Pick<ZapConstructorParams, \"zappedEvent\">\n\t> &\n\t    Pick<ZapConstructorParams, \"zappedUser\"> &\n\t    ZapConstructorParams;\n\texport default class Zap extends EventEmitter {\n\t    public ndk?: NDK;\n\t    public zappedEvent?: NDKEvent;\n\t    public zappedUser: User;\n\t    public constructor(args: ZapConstructorParamsRequired) {\n", "        super();\n\t        this.ndk = args.ndk;\n\t        this.zappedEvent = args.zappedEvent;\n\t        this.zappedUser =\n\t            args.zappedUser ||\n\t            this.ndk.getUser({ hexpubkey: this.zappedEvent.pubkey });\n\t    }\n\t    public async getZapEndpoint(): Promise<string | undefined> {\n\t        let lud06: string | undefined;\n\t        let lud16: string | undefined;\n", "        let zapEndpoint: string | undefined;\n\t        let zapEndpointCallback: string | undefined;\n\t        if (this.zappedEvent) {\n\t            const zapTag = (await this.zappedEvent.getMatchingTags(\"zap\"))[0];\n\t            if (zapTag) {\n\t                switch (zapTag[2]) {\n\t                    case \"lud06\":\n\t                        lud06 = zapTag[1];\n\t                        break;\n\t                    case \"lud16\":\n", "                        lud16 = zapTag[1];\n\t                        break;\n\t                    default:\n\t                        throw new Error(`Unknown zap tag ${zapTag}`);\n\t                }\n\t            }\n\t        }\n\t        if (this.zappedUser && !lud06 && !lud16) {\n\t            // check if user has a profile, otherwise request it\n\t            if (!this.zappedUser.profile) {\n", "                await this.zappedUser.fetchProfile();\n\t            }\n\t            lud06 = (this.zappedUser.profile || {}).lud06;\n\t            lud16 = (this.zappedUser.profile || {}).lud16;\n\t        }\n\t        if (lud16) {\n\t            const [name, domain] = lud16.split(\"@\");\n\t            zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;\n\t        } else if (lud06) {\n\t            const { words } = bech32.decode(lud06, 1000);\n", "            const data = bech32.fromWords(words);\n\t            const utf8Decoder = new TextDecoder(\"utf-8\");\n\t            zapEndpoint = utf8Decoder.decode(data);\n\t        }\n\t        if (!zapEndpoint) {\n\t            throw new Error(\"No zap endpoint found\");\n\t        }\n\t        const response = await fetch(zapEndpoint);\n\t        const body = await response.json();\n\t        if (body?.allowsNostr && (body?.nostrPubkey || body?.nostrPubKey)) {\n", "            zapEndpointCallback = body.callback;\n\t        }\n\t        return zapEndpointCallback;\n\t    }\n\t    /**\n\t     * Generates a kind:9734 zap request and returns the payment request\n\t     * @param amount amount to zap in millisatoshis\n\t     * @param comment optional comment to include in the zap request\n\t     * @param extraTags optional extra tags to include in the zap request\n\t     * @param relays optional relays to ask zapper to publish the zap to\n", "     * @returns the payment request\n\t     */\n\t    public async createZapRequest(\n\t        amount: number, // amount to zap in millisatoshis\n\t        comment?: string,\n\t        extraTags?: NDKTag[],\n\t        relays?: string[]\n\t    ): Promise<string | null> {\n\t        const zapEndpoint = await this.getZapEndpoint();\n\t        if (!zapEndpoint) {\n", "            throw new Error(\"No zap endpoint found\");\n\t        }\n\t        if (!this.zappedEvent) throw new Error(\"No zapped event found\");\n\t        const zapRequest = nip57.makeZapRequest({\n\t            profile: this.zappedUser.hexpubkey(),\n\t            // set the event to null since nostr-tools doesn't support nip-33 zaps\n\t            event: null,\n\t            amount,\n\t            comment: comment || \"\",\n\t            relays: relays ?? this.relays(),\n", "        });\n\t        // add the event tag if it exists; this supports both 'e' and 'a' tags\n\t        if (this.zappedEvent) {\n\t            const tag = this.zappedEvent.tagReference();\n\t            if (tag) {\n\t                zapRequest.tags.push(tag);\n\t            }\n\t        }\n\t        zapRequest.tags.push([\"lnurl\", zapEndpoint]);\n\t        const zapRequestEvent = new NDKEvent(\n", "            this.ndk,\n\t            zapRequest as NostrEvent\n\t        );\n\t        if (extraTags) {\n\t            zapRequestEvent.tags = zapRequestEvent.tags.concat(extraTags);\n\t        }\n\t        await zapRequestEvent.sign();\n\t        const zapRequestNostrEvent = await zapRequestEvent.toNostrEvent();\n\t        const response = await fetch(\n\t            `${zapEndpoint}?` +\n", "                new URLSearchParams({\n\t                    amount: amount.toString(),\n\t                    nostr: JSON.stringify(zapRequestNostrEvent),\n\t                })\n\t        );\n\t        const body = await response.json();\n\t        return body.pr;\n\t    }\n\t    /**\n\t     * @returns the relays to use for the zap request\n", "     */\n\t    private relays(): string[] {\n\t        let r: string[] = [];\n\t        if (this.ndk?.pool?.relays) {\n\t            r = this.ndk.pool.urls();\n\t        }\n\t        if (!r.length) {\n\t            r = DEFAULT_RELAYS;\n\t        }\n\t        return r;\n", "    }\n\t}\n"]}
{"filename": "src/signers/index.ts", "chunked_list": ["import type { NostrEvent } from \"../events/index.js\";\n\timport NDKUser from \"../user\";\n\t/**\n\t * Interface for NDK signers.\n\t */\n\texport interface NDKSigner {\n\t    /**\n\t     * Blocks until the signer is ready and returns the associated NDKUser.\n\t     * @returns A promise that resolves to the NDKUser instance.\n\t     */\n", "    blockUntilReady(): Promise<NDKUser>;\n\t    /**\n\t     * Getter for the user property.\n\t     * @returns A promise that resolves to the NDKUser instance.\n\t     */\n\t    user(): Promise<NDKUser>;\n\t    /**\n\t     * Signs the given Nostr event.\n\t     * @param event - The Nostr event to be signed.\n\t     * @returns A promise that resolves to the signature of the signed event.\n", "     */\n\t    sign(event: NostrEvent): Promise<string>;\n\t    /**\n\t     * Encrypts the given Nostr event for the given recipient.\n\t     * @param value - The value to be encrypted.\n\t     * @param recipient - The recipient of the encrypted value.\n\t     */\n\t    encrypt(recipient: NDKUser, value: string): Promise<string>;\n\t    /**\n\t     * Decrypts the given value.\n", "     * @param value\n\t     */\n\t    decrypt(sender: NDKUser, value: string): Promise<string>;\n\t}\n"]}
{"filename": "src/signers/nip46/rpc.ts", "chunked_list": ["import EventEmitter from \"eventemitter3\";\n\timport NDK, {\n\t    NDKEvent,\n\t    NDKFilter,\n\t    NDKSigner,\n\t    NDKSubscription,\n\t    NostrEvent,\n\t} from \"../../index.js\";\n\texport interface NDKRpcRequest {\n\t    id: string;\n", "    pubkey: string;\n\t    method: string;\n\t    params: string[];\n\t    event: NDKEvent;\n\t}\n\texport interface NDKRpcResponse {\n\t    id: string;\n\t    result: string;\n\t    error?: string;\n\t    event: NDKEvent;\n", "}\n\texport class NDKNostrRpc extends EventEmitter {\n\t    private ndk: NDK;\n\t    private signer: NDKSigner;\n\t    private debug: debug.Debugger;\n\t    public constructor(ndk: NDK, signer: NDKSigner, debug: debug.Debugger) {\n\t        super();\n\t        this.ndk = ndk;\n\t        this.signer = signer;\n\t        this.debug = debug.extend(\"rpc\");\n", "    }\n\t    /**\n\t     * Subscribe to a filter. This function will resolve once the subscription is ready.\n\t     */\n\t    public async subscribe(filter: NDKFilter): Promise<NDKSubscription> {\n\t        const sub = this.ndk.subscribe(filter, { closeOnEose: false });\n\t        sub.on(\"event\", async (event: NDKEvent) => {\n\t            try {\n\t                const parsedEvent = await this.parseEvent(event);\n\t                if ((parsedEvent as NDKRpcRequest).method) {\n", "                    this.emit(\"request\", parsedEvent);\n\t                } else {\n\t                    this.emit(`response-${parsedEvent.id}`, parsedEvent);\n\t                }\n\t            } catch (e) {\n\t                this.debug(\"error parsing event\", e, event);\n\t            }\n\t        });\n\t        return new Promise((resolve, reject) => {\n\t            sub.on(\"eose\", () => resolve(sub));\n", "        });\n\t    }\n\t    public async parseEvent(\n\t        event: NDKEvent\n\t    ): Promise<NDKRpcRequest | NDKRpcResponse> {\n\t        const remoteUser = this.ndk.getUser({ hexpubkey: event.pubkey });\n\t        remoteUser.ndk = this.ndk;\n\t        const decryptedContent = await this.signer.decrypt(\n\t            remoteUser,\n\t            event.content\n", "        );\n\t        const parsedContent = JSON.parse(decryptedContent);\n\t        const { id, method, params, result, error } = parsedContent;\n\t        if (method) {\n\t            return { id, pubkey: event.pubkey, method, params, event };\n\t        } else {\n\t            return { id, result, error, event };\n\t        }\n\t    }\n\t    public async sendResponse(\n", "        id: string,\n\t        remotePubkey: string,\n\t        result: string,\n\t        kind = 24133,\n\t        error?: string\n\t    ) {\n\t        const res = { id, result } as NDKRpcResponse;\n\t        if (error) {\n\t            res.error = error;\n\t        }\n", "        const localUser = await this.signer.user();\n\t        const remoteUser = this.ndk.getUser({ hexpubkey: remotePubkey });\n\t        const event = new NDKEvent(this.ndk, {\n\t            kind,\n\t            content: JSON.stringify(res),\n\t            tags: [[\"p\", remotePubkey]],\n\t            pubkey: localUser.hexpubkey(),\n\t        } as NostrEvent);\n\t        event.content = await this.signer.encrypt(remoteUser, event.content);\n\t        await event.sign(this.signer);\n", "        await this.ndk.publish(event);\n\t    }\n\t    /**\n\t     * Sends a request.\n\t     * @param remotePubkey\n\t     * @param method\n\t     * @param params\n\t     * @param kind\n\t     * @param id\n\t     */\n", "    public async sendRequest(\n\t        remotePubkey: string,\n\t        method: string,\n\t        params: string[] = [],\n\t        kind = 24133,\n\t        cb?: (res: NDKRpcResponse) => void\n\t    ) {\n\t        const id = Math.random().toString(36).substring(7);\n\t        const localUser = await this.signer.user();\n\t        const remoteUser = this.ndk.getUser({ hexpubkey: remotePubkey });\n", "        const request = { id, method, params };\n\t        const promise = new Promise<NDKRpcResponse>((resolve) => {\n\t            if (cb) this.once(`response-${id}`, cb);\n\t        });\n\t        const event = new NDKEvent(this.ndk, {\n\t            kind,\n\t            content: JSON.stringify(request),\n\t            tags: [[\"p\", remotePubkey]],\n\t            pubkey: localUser.hexpubkey(),\n\t        } as NostrEvent);\n", "        event.content = await this.signer.encrypt(remoteUser, event.content);\n\t        await event.sign(this.signer);\n\t        this.debug(\"sending request to\", remotePubkey);\n\t        await this.ndk.publish(event);\n\t        return promise;\n\t    }\n\t}\n"]}
{"filename": "src/signers/nip46/index.ts", "chunked_list": ["import NDK, {\n\t    NDKPrivateKeySigner,\n\t    NDKSigner,\n\t    NDKUser,\n\t    NostrEvent,\n\t} from \"../../index.js\";\n\timport { NDKNostrRpc, NDKRpcResponse } from \"./rpc.js\";\n\t/**\n\t * This NDKSigner implements NIP-46, which allows remote signing of events.\n\t * This class is meant to be used client-side, paired with the NDKNip46Backend or a NIP-46 backend (like Nostr-Connect)\n", " */\n\texport class NDKNip46Signer implements NDKSigner {\n\t    private ndk: NDK;\n\t    public remoteUser: NDKUser;\n\t    public remotePubkey: string;\n\t    public token: string | undefined;\n\t    public localSigner: NDKSigner;\n\t    private rpc: NDKNostrRpc;\n\t    private debug: debug.Debugger;\n\t    /**\n", "     * @param ndk - The NDK instance to use\n\t     * @param token - connection token, in the form \"npub#otp\"\n\t     * @param localSigner - The signer that will be used to request events to be signed\n\t     */\n\t    public constructor(ndk: NDK, token: string, localSigner?: NDKSigner);\n\t    /**\n\t     * @param ndk - The NDK instance to use\n\t     * @param remoteNpub - The npub that wants to be published as\n\t     * @param localSigner - The signer that will be used to request events to be signed\n\t     */\n", "    public constructor(ndk: NDK, remoteNpub: string, localSigner?: NDKSigner);\n\t    /**\n\t     * @param ndk - The NDK instance to use\n\t     * @param remotePubkey - The public key of the npub that wants to be published as\n\t     * @param localSigner - The signer that will be used to request events to be signed\n\t     */\n\t    public constructor(ndk: NDK, remotePubkey: string, localSigner?: NDKSigner);\n\t    /**\n\t     * @param ndk - The NDK instance to use\n\t     * @param tokenOrRemotePubkey - The public key, or a connection token, of the npub that wants to be published as\n", "     * @param localSigner - The signer that will be used to request events to be signed\n\t     */\n\t    public constructor(\n\t        ndk: NDK,\n\t        tokenOrRemotePubkey: string,\n\t        localSigner?: NDKSigner\n\t    ) {\n\t        let remotePubkey: string;\n\t        let token: string | undefined;\n\t        if (tokenOrRemotePubkey.includes(\"#\")) {\n", "            const parts = tokenOrRemotePubkey.split(\"#\");\n\t            remotePubkey = new NDKUser({ npub: parts[0] }).hexpubkey();\n\t            token = parts[1];\n\t        } else if (tokenOrRemotePubkey.startsWith(\"npub\")) {\n\t            remotePubkey = new NDKUser({\n\t                npub: tokenOrRemotePubkey,\n\t            }).hexpubkey();\n\t        } else {\n\t            remotePubkey = tokenOrRemotePubkey;\n\t        }\n", "        this.ndk = ndk;\n\t        this.remotePubkey = remotePubkey;\n\t        this.token = token;\n\t        this.debug = ndk.debug.extend(\"nip46:signer\");\n\t        this.remoteUser = new NDKUser({ hexpubkey: remotePubkey });\n\t        if (!localSigner) {\n\t            this.localSigner = NDKPrivateKeySigner.generate();\n\t        } else {\n\t            this.localSigner = localSigner;\n\t        }\n", "        this.rpc = new NDKNostrRpc(ndk, this.localSigner, this.debug);\n\t    }\n\t    /**\n\t     * Get the user that is being published as\n\t     */\n\t    public async user(): Promise<NDKUser> {\n\t        return this.remoteUser;\n\t    }\n\t    public async blockUntilReady(): Promise<NDKUser> {\n\t        const localUser = await this.localSigner.user();\n", "        const user = this.ndk.getUser({ npub: localUser.npub });\n\t        // Generates subscription, single subscription for the lifetime of our connection\n\t        await this.rpc.subscribe({\n\t            kinds: [24133 as number],\n\t            \"#p\": [localUser.hexpubkey()],\n\t        });\n\t        return new Promise((resolve, reject) => {\n\t            // There is a race condition between the subscription and sending the request;\n\t            // introducing a small delay here to give a clear priority to the subscription\n\t            // to happen first\n", "            setTimeout(() => {\n\t                const connectParams = [localUser.hexpubkey()];\n\t                if (this.token) {\n\t                    connectParams.push(this.token);\n\t                }\n\t                this.rpc.sendRequest(\n\t                    this.remotePubkey,\n\t                    \"connect\",\n\t                    connectParams,\n\t                    24133,\n", "                    (response: NDKRpcResponse) => {\n\t                        if (response.result === \"ack\") {\n\t                            resolve(user);\n\t                        } else {\n\t                            reject(response.error);\n\t                        }\n\t                    }\n\t                );\n\t            }, 100);\n\t        });\n", "    }\n\t    public async encrypt(recipient: NDKUser, value: string): Promise<string> {\n\t        this.debug(\"asking for encryption\");\n\t        const promise = new Promise<string>((resolve, reject) => {\n\t            this.rpc.sendRequest(\n\t                this.remotePubkey,\n\t                \"nip04_encrypt\",\n\t                [recipient.hexpubkey(), value],\n\t                24133,\n\t                (response: NDKRpcResponse) => {\n", "                    if (!response.error) {\n\t                        resolve(response.result);\n\t                    } else {\n\t                        reject(response.error);\n\t                    }\n\t                }\n\t            );\n\t        });\n\t        return promise;\n\t    }\n", "    public async decrypt(sender: NDKUser, value: string): Promise<string> {\n\t        this.debug(\"asking for decryption\");\n\t        const promise = new Promise<string>((resolve, reject) => {\n\t            this.rpc.sendRequest(\n\t                this.remotePubkey,\n\t                \"nip04_decrypt\",\n\t                [sender.hexpubkey(), value],\n\t                24133,\n\t                (response: NDKRpcResponse) => {\n\t                    if (!response.error) {\n", "                        const value = JSON.parse(response.result);\n\t                        resolve(value[0]);\n\t                    } else {\n\t                        reject(response.error);\n\t                    }\n\t                }\n\t            );\n\t        });\n\t        return promise;\n\t    }\n", "    public async sign(event: NostrEvent): Promise<string> {\n\t        this.debug(\"asking for a signature\");\n\t        const promise = new Promise<string>((resolve, reject) => {\n\t            this.rpc.sendRequest(\n\t                this.remotePubkey,\n\t                \"sign_event\",\n\t                [JSON.stringify(event)],\n\t                24133,\n\t                (response: NDKRpcResponse) => {\n\t                    this.debug(\"got a response\", response);\n", "                    if (!response.error) {\n\t                        const json = JSON.parse(response.result);\n\t                        resolve(json.sig);\n\t                    } else {\n\t                        reject(response.error);\n\t                    }\n\t                }\n\t            );\n\t        });\n\t        return promise;\n", "    }\n\t}\n"]}
{"filename": "src/signers/nip46/backend/describe.ts", "chunked_list": ["import { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\texport default class DescribeHandlingStrategy\n\t    implements IEventHandlingStrategy\n\t{\n\t    async handle(\n\t        backend: NDKNip46Backend,\n\t        remotePubkey: string,\n\t        params: string[]\n\t    ): Promise<string | undefined> {\n\t        const keys = Object.keys(backend.handlers);\n", "        return JSON.stringify(keys);\n\t    }\n\t}\n"]}
{"filename": "src/signers/nip46/backend/nip04-encrypt.ts", "chunked_list": ["import NDKUser from \"../../../user/index.js\";\n\timport { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\texport default class Nip04EncryptHandlingStrategy\n\t    implements IEventHandlingStrategy\n\t{\n\t    async handle(\n\t        backend: NDKNip46Backend,\n\t        remotePubkey: string,\n\t        params: string[]\n\t    ): Promise<string | undefined> {\n", "        const [recipientPubkey, payload] = params;\n\t        const recipientUser = new NDKUser({ hexpubkey: recipientPubkey });\n\t        const decryptedPayload = await backend.encrypt(\n\t            remotePubkey,\n\t            recipientUser,\n\t            payload\n\t        );\n\t        return decryptedPayload;\n\t    }\n\t}\n"]}
{"filename": "src/signers/nip46/backend/connect.ts", "chunked_list": ["import { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\texport default class ConnectEventHandlingStrategy\n\t    implements IEventHandlingStrategy\n\t{\n\t    async handle(\n\t        backend: NDKNip46Backend,\n\t        remotePubkey: string,\n\t        params: string[]\n\t    ): Promise<string | undefined> {\n\t        const [pubkey, token] = params;\n", "        const debug = backend.debug.extend(\"connect\");\n\t        debug(`connection request from ${pubkey}`);\n\t        if (token && backend.applyToken) {\n\t            debug(`applying token`);\n\t            await backend.applyToken(pubkey, token);\n\t        }\n\t        if (await backend.pubkeyAllowed(pubkey, \"connect\", token)) {\n\t            debug(`connection request from ${pubkey} allowed`);\n\t            return \"ack\";\n\t        } else {\n", "            debug(`connection request from ${pubkey} rejected`);\n\t        }\n\t        return undefined;\n\t    }\n\t}\n"]}
{"filename": "src/signers/nip46/backend/nip04-decrypt.ts", "chunked_list": ["import NDKUser from \"../../../user/index.js\";\n\timport { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\texport default class Nip04DecryptHandlingStrategy\n\t    implements IEventHandlingStrategy\n\t{\n\t    async handle(\n\t        backend: NDKNip46Backend,\n\t        remotePubkey: string,\n\t        params: string[]\n\t    ): Promise<string | undefined> {\n", "        const [senderPubkey, payload] = params;\n\t        const senderUser = new NDKUser({ hexpubkey: senderPubkey });\n\t        const decryptedPayload = await backend.decrypt(\n\t            remotePubkey,\n\t            senderUser,\n\t            payload\n\t        );\n\t        return JSON.stringify([decryptedPayload]);\n\t    }\n\t}\n"]}
{"filename": "src/signers/nip46/backend/sign-event.ts", "chunked_list": ["import { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\texport default class SignEventHandlingStrategy\n\t    implements IEventHandlingStrategy\n\t{\n\t    async handle(\n\t        backend: NDKNip46Backend,\n\t        remotePubkey: string,\n\t        params: string[]\n\t    ): Promise<string | undefined> {\n\t        const event = await backend.signEvent(remotePubkey, params);\n", "        if (!event) return undefined;\n\t        return JSON.stringify(await event.toNostrEvent());\n\t    }\n\t}\n"]}
{"filename": "src/signers/nip46/backend/index.ts", "chunked_list": ["import { verifySignature, Event } from \"nostr-tools\";\n\timport NDK, { NDKEvent, NDKPrivateKeySigner, NDKUser } from \"../../../index.js\";\n\timport { NDKNostrRpc } from \"../rpc.js\";\n\timport ConnectEventHandlingStrategy from \"./connect.js\";\n\timport DescribeEventHandlingStrategy from \"./describe.js\";\n\timport GetPublicKeyHandlingStrategy from \"./get-public-key.js\";\n\timport Nip04DecryptHandlingStrategy from \"./nip04-decrypt.js\";\n\timport Nip04EncryptHandlingStrategy from \"./nip04-encrypt.js\";\n\timport SignEventHandlingStrategy from \"./sign-event.js\";\n\texport type Nip46PermitCallback = (\n", "    pubkey: string,\n\t    method: string,\n\t    params?: any\n\t) => Promise<boolean>;\n\texport type Nip46ApplyTokenCallback = (\n\t    pubkey: string,\n\t    token: string\n\t) => Promise<void>;\n\texport interface IEventHandlingStrategy {\n\t    handle(\n", "        backend: NDKNip46Backend,\n\t        remotePubkey: string,\n\t        params: string[]\n\t    ): Promise<string | undefined>;\n\t}\n\t/**\n\t * This class implements a NIP-46 backend, meaning that it will hold a private key\n\t * of the npub that wants to be published as.\n\t *\n\t * This backend is meant to be used by an NDKNip46Signer, which is the class that\n", " * should run client-side, where the user wants to sign events from.\n\t */\n\texport class NDKNip46Backend {\n\t    readonly ndk: NDK;\n\t    readonly signer: NDKPrivateKeySigner;\n\t    public localUser?: NDKUser;\n\t    readonly debug: debug.Debugger;\n\t    private rpc: NDKNostrRpc;\n\t    private permitCallback: Nip46PermitCallback;\n\t    /**\n", "     * @param ndk The NDK instance to use\n\t     * @param privateKey The private key of the npub that wants to be published as\n\t     */\n\t    public constructor(\n\t        ndk: NDK,\n\t        privateKey: string,\n\t        permitCallback: Nip46PermitCallback\n\t    ) {\n\t        this.ndk = ndk;\n\t        this.signer = new NDKPrivateKeySigner(privateKey);\n", "        this.debug = ndk.debug.extend(\"nip46:backend\");\n\t        this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug);\n\t        this.permitCallback = permitCallback;\n\t    }\n\t    /**\n\t     * This method starts the backend, which will start listening for incoming\n\t     * requests.\n\t     */\n\t    public async start() {\n\t        this.localUser = await this.signer.user();\n", "        const sub = this.ndk.subscribe(\n\t            {\n\t                kinds: [24133 as number],\n\t                \"#p\": [this.localUser.hexpubkey()],\n\t            },\n\t            { closeOnEose: false }\n\t        );\n\t        sub.on(\"event\", (e) => this.handleIncomingEvent(e));\n\t    }\n\t    public handlers: { [method: string]: IEventHandlingStrategy } = {\n", "        connect: new ConnectEventHandlingStrategy(),\n\t        sign_event: new SignEventHandlingStrategy(),\n\t        nip04_encrypt: new Nip04EncryptHandlingStrategy(),\n\t        nip04_decrypt: new Nip04DecryptHandlingStrategy(),\n\t        get_public_key: new GetPublicKeyHandlingStrategy(),\n\t        describe: new DescribeEventHandlingStrategy(),\n\t    };\n\t    /**\n\t     * Enables the user to set a custom strategy for handling incoming events.\n\t     * @param method - The method to set the strategy for\n", "     * @param strategy - The strategy to set\n\t     */\n\t    public setStrategy(method: string, strategy: IEventHandlingStrategy) {\n\t        this.handlers[method] = strategy;\n\t    }\n\t    /**\n\t     * Overload this method to apply tokens, which can\n\t     * wrap permission sets to be applied to a pubkey.\n\t     * @param pubkey public key to apply token to\n\t     * @param token token to apply\n", "     */\n\t    async applyToken(pubkey: string, token: string): Promise<void> {\n\t        throw new Error(\"connection token not supported\");\n\t    }\n\t    protected async handleIncomingEvent(event: NDKEvent) {\n\t        const { id, method, params } = (await this.rpc.parseEvent(\n\t            event\n\t        )) as any;\n\t        const remotePubkey = event.pubkey;\n\t        let response: string | undefined;\n", "        this.debug(\"incoming event\", { id, method, params });\n\t        // validate signature explicitly\n\t        if (!verifySignature(event.rawEvent() as Event<any>)) {\n\t            this.debug(\"invalid signature\", event.rawEvent());\n\t            return;\n\t        }\n\t        const strategy = this.handlers[method];\n\t        if (strategy) {\n\t            try {\n\t                response = await strategy.handle(this, remotePubkey, params);\n", "            } catch (e: any) {\n\t                this.debug(\"error handling event\", e, { id, method, params });\n\t                this.rpc.sendResponse(\n\t                    id,\n\t                    remotePubkey,\n\t                    \"error\",\n\t                    undefined,\n\t                    e.message\n\t                );\n\t            }\n", "        } else {\n\t            this.debug(\"unsupported method\", { method, params });\n\t        }\n\t        if (response) {\n\t            this.debug(`sending response to ${remotePubkey}`, response);\n\t            this.rpc.sendResponse(id, remotePubkey, response);\n\t        } else {\n\t            this.rpc.sendResponse(\n\t                id,\n\t                remotePubkey,\n", "                \"error\",\n\t                undefined,\n\t                \"Not authorized\"\n\t            );\n\t        }\n\t    }\n\t    public async decrypt(\n\t        remotePubkey: string,\n\t        senderUser: NDKUser,\n\t        payload: string\n", "    ) {\n\t        if (!(await this.pubkeyAllowed(remotePubkey, \"decrypt\", payload))) {\n\t            this.debug(`decrypt request from ${remotePubkey} rejected`);\n\t            return undefined;\n\t        }\n\t        return await this.signer.decrypt(senderUser, payload);\n\t    }\n\t    public async encrypt(\n\t        remotePubkey: string,\n\t        recipientUser: NDKUser,\n", "        payload: string\n\t    ) {\n\t        if (!(await this.pubkeyAllowed(remotePubkey, \"encrypt\", payload))) {\n\t            this.debug(`encrypt request from ${remotePubkey} rejected`);\n\t            return undefined;\n\t        }\n\t        return await this.signer.encrypt(recipientUser, payload);\n\t    }\n\t    public async signEvent(\n\t        remotePubkey: string,\n", "        params: string[]\n\t    ): Promise<NDKEvent | undefined> {\n\t        const [eventString] = params;\n\t        this.debug(`sign event request from ${remotePubkey}`);\n\t        const event = new NDKEvent(this.ndk, JSON.parse(eventString));\n\t        this.debug(\"event to sign\", event.rawEvent());\n\t        if (!(await this.pubkeyAllowed(remotePubkey, \"sign_event\", event))) {\n\t            this.debug(`sign event request from ${remotePubkey} rejected`);\n\t            return undefined;\n\t        }\n", "        this.debug(`sign event request from ${remotePubkey} allowed`);\n\t        await event.sign(this.signer);\n\t        return event;\n\t    }\n\t    /**\n\t     * This method should be overriden by the user to allow or reject incoming\n\t     * connections.\n\t     */\n\t    public async pubkeyAllowed(\n\t        pubkey: string,\n", "        method: string,\n\t        params?: any\n\t    ): Promise<boolean> {\n\t        return this.permitCallback(pubkey, method, params);\n\t    }\n\t}\n"]}
{"filename": "src/signers/nip46/backend/get-public-key.ts", "chunked_list": ["import { IEventHandlingStrategy, NDKNip46Backend } from \"./index.js\";\n\texport default class GetPublicKeyHandlingStrategy\n\t    implements IEventHandlingStrategy\n\t{\n\t    async handle(\n\t        backend: NDKNip46Backend,\n\t        remotePubkey: string,\n\t        params: string[]\n\t    ): Promise<string | undefined> {\n\t        return backend.localUser?.hexpubkey();\n", "    }\n\t}\n"]}
{"filename": "src/signers/nip07/index.ts", "chunked_list": ["import debug from \"debug\";\n\timport type { NostrEvent } from \"../../events/index.js\";\n\timport NDKUser from \"../../user/index.js\";\n\timport { NDKSigner } from \"../index.js\";\n\ttype Nip04QueueItem = {\n\t    type: \"encrypt\" | \"decrypt\";\n\t    counterpartyHexpubkey: string;\n\t    value: string;\n\t    resolve: (value: string) => void;\n\t    reject: (reason?: Error) => void;\n", "};\n\t/**\n\t * NDKNip07Signer implements the NDKSigner interface for signing Nostr events\n\t * with a NIP-07 browser extension (e.g., getalby, nos2x).\n\t */\n\texport class NDKNip07Signer implements NDKSigner {\n\t    private _userPromise: Promise<NDKUser> | undefined;\n\t    public nip04Queue: Nip04QueueItem[] = [];\n\t    private nip04Processing = false;\n\t    private debug: debug.Debugger;\n", "    public constructor() {\n\t        if (!window.nostr) {\n\t            throw new Error(\"NIP-07 extension not available\");\n\t        }\n\t        this.debug = debug(\"ndk:nip07\");\n\t    }\n\t    public async blockUntilReady(): Promise<NDKUser> {\n\t        const pubkey = await window.nostr?.getPublicKey();\n\t        // If the user rejects granting access, error out\n\t        if (!pubkey) {\n", "            throw new Error(\"User rejected access\");\n\t        }\n\t        return new NDKUser({ hexpubkey: pubkey });\n\t    }\n\t    /**\n\t     * Getter for the user property.\n\t     * @returns The NDKUser instance.\n\t     */\n\t    public async user(): Promise<NDKUser> {\n\t        if (!this._userPromise) {\n", "            this._userPromise = this.blockUntilReady();\n\t        }\n\t        return this._userPromise;\n\t    }\n\t    /**\n\t     * Signs the given Nostr event.\n\t     * @param event - The Nostr event to be signed.\n\t     * @returns The signature of the signed event.\n\t     * @throws Error if the NIP-07 is not available on the window object.\n\t     */\n", "    public async sign(event: NostrEvent): Promise<string> {\n\t        if (!window.nostr) {\n\t            throw new Error(\"NIP-07 extension not available\");\n\t        }\n\t        const signedEvent = await window.nostr.signEvent(event);\n\t        return signedEvent.sig;\n\t    }\n\t    public async encrypt(recipient: NDKUser, value: string): Promise<string> {\n\t        if (!window.nostr) {\n\t            throw new Error(\"NIP-07 extension not available\");\n", "        }\n\t        const recipientHexPubKey = recipient.hexpubkey();\n\t        return this.queueNip04(\"encrypt\", recipientHexPubKey, value);\n\t    }\n\t    public async decrypt(sender: NDKUser, value: string): Promise<string> {\n\t        if (!window.nostr) {\n\t            throw new Error(\"NIP-07 extension not available\");\n\t        }\n\t        const senderHexPubKey = sender.hexpubkey();\n\t        return this.queueNip04(\"decrypt\", senderHexPubKey, value);\n", "    }\n\t    private async queueNip04(\n\t        type: \"encrypt\" | \"decrypt\",\n\t        counterpartyHexpubkey: string,\n\t        value: string\n\t    ): Promise<string> {\n\t        return new Promise((resolve, reject) => {\n\t            this.nip04Queue.push({\n\t                type,\n\t                counterpartyHexpubkey,\n", "                value,\n\t                resolve,\n\t                reject,\n\t            });\n\t            if (!this.nip04Processing) {\n\t                this.processNip04Queue();\n\t            }\n\t        });\n\t    }\n\t    private async processNip04Queue(\n", "        item?: Nip04QueueItem,\n\t        retries = 0\n\t    ): Promise<void> {\n\t        if (!item && this.nip04Queue.length === 0) {\n\t            this.nip04Processing = false;\n\t            return;\n\t        }\n\t        this.nip04Processing = true;\n\t        const { type, counterpartyHexpubkey, value, resolve, reject } =\n\t            item || this.nip04Queue.shift()!;\n", "        this.debug(\"Processing encryption queue item\", {\n\t            type,\n\t            counterpartyHexpubkey,\n\t            value,\n\t        });\n\t        try {\n\t            let result;\n\t            if (type === \"encrypt\") {\n\t                result = await window.nostr!.nip04.encrypt(\n\t                    counterpartyHexpubkey,\n", "                    value\n\t                );\n\t            } else {\n\t                result = await window.nostr!.nip04.decrypt(\n\t                    counterpartyHexpubkey,\n\t                    value\n\t                );\n\t            }\n\t            resolve(result);\n\t        } catch (error: any) {\n", "            // retry a few times if the call is already executing\n\t            if (\n\t                error.message &&\n\t                error.message.includes(\"call already executing\")\n\t            ) {\n\t                if (retries < 5) {\n\t                    this.debug(\"Retrying encryption queue item\", {\n\t                        type,\n\t                        counterpartyHexpubkey,\n\t                        value,\n", "                        retries,\n\t                    });\n\t                    setTimeout(() => {\n\t                        this.processNip04Queue(item, retries + 1);\n\t                    }, 50 * retries);\n\t                    return;\n\t                }\n\t            }\n\t            reject(error);\n\t        }\n", "        this.processNip04Queue();\n\t    }\n\t}\n\tdeclare global {\n\t    interface Window {\n\t        nostr?: {\n\t            getPublicKey(): Promise<string>;\n\t            signEvent(event: NostrEvent): Promise<{ sig: string }>;\n\t            nip04: {\n\t                encrypt(\n", "                    recipientHexPubKey: string,\n\t                    value: string\n\t                ): Promise<string>;\n\t                decrypt(\n\t                    senderHexPubKey: string,\n\t                    value: string\n\t                ): Promise<string>;\n\t            };\n\t        };\n\t    }\n", "}\n"]}
{"filename": "src/signers/private-key/index.test.ts", "chunked_list": ["import { NDKUser, NostrEvent } from \"../../index.js\";\n\timport { NDKPrivateKeySigner } from \"./index\";\n\tdescribe(\"NDKPrivateKeySigner\", () => {\n\t    it(\"generates a new NDKPrivateKeySigner instance with a private key\", () => {\n\t        const signer = NDKPrivateKeySigner.generate();\n\t        expect(signer).toBeInstanceOf(NDKPrivateKeySigner);\n\t        expect(signer.privateKey).toBeDefined();\n\t    });\n\t    it(\"creates a new NDKPrivateKeySigner instance with a provided private key\", () => {\n\t        const privateKey =\n", "            \"00112233445566778899aabbccddeeff00112233445566778899aabbccddeeff\";\n\t        const signer = new NDKPrivateKeySigner(privateKey);\n\t        expect(signer).toBeInstanceOf(NDKPrivateKeySigner);\n\t        expect(signer.privateKey).toBe(privateKey);\n\t    });\n\t    it(\"returns a user instance with a public key corresponding to the private key\", async () => {\n\t        const privateKey =\n\t            \"e8eb7464168139c6ccb9111f768777f332fa1289dff11244ccfe89970ff776d4\";\n\t        const signer = new NDKPrivateKeySigner(privateKey);\n\t        const user = await signer.user();\n", "        expect(user).toBeInstanceOf(NDKUser);\n\t        expect(user.hexpubkey()).toBe(\n\t            \"07f61c41b44a923952db82e6e7bcd184b059fe087f58f9d9a918da391f38d503\"\n\t        );\n\t    });\n\t    it(\"signs a NostrEvent with the private key\", async () => {\n\t        const privateKey =\n\t            \"00112233445566778899aabbccddeeff00112233445566778899aabbccddeeff\";\n\t        const signer = new NDKPrivateKeySigner(privateKey);\n\t        const event: NostrEvent = {\n", "            pubkey: \"07f61c41b44a923952db82e6e7bcd184b059fe087f58f9d9a918da391f38d503\",\n\t            created_at: Math.floor(Date.now() / 1000),\n\t            tags: [],\n\t            content: \"Test content\",\n\t            kind: 1,\n\t        };\n\t        const signature = await signer.sign(event);\n\t        expect(signature).toBeDefined();\n\t        expect(signature.length).toBe(128);\n\t    });\n", "});\n"]}
{"filename": "src/signers/private-key/index.ts", "chunked_list": ["import type { UnsignedEvent } from \"nostr-tools\";\n\timport {\n\t    generatePrivateKey,\n\t    getPublicKey,\n\t    nip04,\n\t    getSignature,\n\t} from \"nostr-tools\";\n\timport type { NostrEvent } from \"../../events/index.js\";\n\timport NDKUser from \"../../user\";\n\timport { NDKSigner } from \"../index.js\";\n", "export class NDKPrivateKeySigner implements NDKSigner {\n\t    private _user: NDKUser | undefined;\n\t    privateKey?: string;\n\t    public constructor(privateKey?: string) {\n\t        if (privateKey) {\n\t            this.privateKey = privateKey;\n\t            this._user = new NDKUser({\n\t                hexpubkey: getPublicKey(this.privateKey),\n\t            });\n\t        }\n", "    }\n\t    public static generate() {\n\t        const privateKey = generatePrivateKey();\n\t        return new NDKPrivateKeySigner(privateKey);\n\t    }\n\t    public async blockUntilReady(): Promise<NDKUser> {\n\t        if (!this._user) {\n\t            throw new Error(\"NDKUser not initialized\");\n\t        }\n\t        return this._user;\n", "    }\n\t    public async user(): Promise<NDKUser> {\n\t        await this.blockUntilReady();\n\t        return this._user as NDKUser;\n\t    }\n\t    public async sign(event: NostrEvent): Promise<string> {\n\t        if (!this.privateKey) {\n\t            throw Error(\"Attempted to sign without a private key\");\n\t        }\n\t        return getSignature(event as UnsignedEvent, this.privateKey);\n", "    }\n\t    public async encrypt(recipient: NDKUser, value: string): Promise<string> {\n\t        if (!this.privateKey) {\n\t            throw Error(\"Attempted to encrypt without a private key\");\n\t        }\n\t        const recipientHexPubKey = recipient.hexpubkey();\n\t        return await nip04.encrypt(this.privateKey, recipientHexPubKey, value);\n\t    }\n\t    public async decrypt(sender: NDKUser, value: string): Promise<string> {\n\t        if (!this.privateKey) {\n", "            throw Error(\"Attempted to decrypt without a private key\");\n\t        }\n\t        const senderHexPubKey = sender.hexpubkey();\n\t        return await nip04.decrypt(this.privateKey, senderHexPubKey, value);\n\t    }\n\t}\n"]}
{"filename": "src/events/nip19.ts", "chunked_list": ["import { nip19 } from \"nostr-tools\";\n\timport NDKEvent from \".\";\n\texport function encode(this: NDKEvent) {\n\t    if (this.isParamReplaceable()) {\n\t        return nip19.naddrEncode({\n\t            kind: this.kind as number,\n\t            pubkey: this.pubkey,\n\t            identifier: this.replaceableDTag(),\n\t            relays: this.relay ? [this.relay.url] : [],\n\t        });\n", "    } else if (this.relay) {\n\t        return nip19.neventEncode({\n\t            id: this.tagId(),\n\t            relays: [this.relay.url],\n\t            author: this.pubkey,\n\t        });\n\t    } else {\n\t        return nip19.noteEncode(this.tagId());\n\t    }\n\t}\n"]}
{"filename": "src/events/kind.ts", "chunked_list": ["import NDKEvent from \"./index.js\";\n\texport function isReplaceable(this: NDKEvent): boolean {\n\t    if (this.kind === undefined) throw new Error(\"Kind not set\");\n\t    return this.kind >= 10000 && this.kind < 20000;\n\t}\n\texport function isEphemeral(this: NDKEvent): boolean {\n\t    if (this.kind === undefined) throw new Error(\"Kind not set\");\n\t    return this.kind >= 20000 && this.kind < 30000;\n\t}\n\texport function isParamReplaceable(this: NDKEvent): boolean {\n", "    if (this.kind === undefined) throw new Error(\"Kind not set\");\n\t    return this.kind >= 30000 && this.kind < 40000;\n\t}\n"]}
{"filename": "src/events/nip04.ts", "chunked_list": ["import NDKEvent from \".\";\n\timport { NDKSigner } from \"../signers\";\n\timport NDKUser from \"../user\";\n\texport async function encrypt(\n\t    this: NDKEvent,\n\t    recipient?: NDKUser,\n\t    signer?: NDKSigner\n\t) {\n\t    if (!signer) {\n\t        if (!this.ndk) {\n", "            throw new Error(\"No signer available\");\n\t        }\n\t        await this.ndk.assertSigner();\n\t        signer = this.ndk.signer!;\n\t    }\n\t    if (!recipient) {\n\t        const pTags = this.getMatchingTags(\"p\");\n\t        if (pTags.length !== 1) {\n\t            throw new Error(\n\t                \"No recipient could be determined and no explicit recipient was provided\"\n", "            );\n\t        }\n\t        recipient = new NDKUser({ hexpubkey: pTags[0][1] });\n\t        recipient.ndk = this.ndk;\n\t    }\n\t    this.content = await signer.encrypt(recipient, this.content);\n\t}\n\texport async function decrypt(\n\t    this: NDKEvent,\n\t    sender?: NDKUser,\n", "    signer?: NDKSigner\n\t) {\n\t    if (!signer) {\n\t        if (!this.ndk) {\n\t            throw new Error(\"No signer available\");\n\t        }\n\t        await this.ndk.assertSigner();\n\t        signer = this.ndk.signer!;\n\t    }\n\t    if (!sender) {\n", "        sender = this.author;\n\t    }\n\t    this.content = await signer.decrypt(sender, this.content);\n\t}\n"]}
{"filename": "src/events/content-tagger.ts", "chunked_list": ["import { nip19 } from \"nostr-tools\";\n\timport { EventPointer, ProfilePointer } from \"nostr-tools/lib/nip19\";\n\timport { NDKTag } from \"./index.js\";\n\texport function generateContentTags(\n\t    content: string,\n\t    tags: NDKTag[] = []\n\t): { content: string; tags: NDKTag[] } {\n\t    const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent)[a-zA-Z0-9]+/g;\n\t    content = content.replace(tagRegex, (tag) => {\n\t        try {\n", "            const entity = tag.split(/(@|nostr:)/)[2];\n\t            const { type, data } = nip19.decode(entity);\n\t            let t: NDKTag;\n\t            switch (type) {\n\t                case \"npub\":\n\t                    t = [\"p\", data as string];\n\t                    break;\n\t                case \"nprofile\":\n\t                    t = [\"p\", (data as ProfilePointer).pubkey as string];\n\t                    break;\n", "                case \"nevent\":\n\t                    t = [\"e\", (data as EventPointer).id as string];\n\t                    break;\n\t                case \"note\":\n\t                    t = [\"e\", data as string];\n\t                    break;\n\t                default:\n\t                    return tag;\n\t            }\n\t            if (!tags.find((t2) => t2[0] === t[0] && t2[1] === t[1])) {\n", "                tags.push(t);\n\t            }\n\t            return `nostr:${entity}`;\n\t        } catch (error) {\n\t            return tag;\n\t        }\n\t    });\n\t    return { content, tags };\n\t}\n"]}
{"filename": "src/events/index.test.ts", "chunked_list": ["import NDK, { NDKEvent, NDKSubscription, NDKUser, NostrEvent } from \"../index\";\n\tdescribe(\"NDKEvent\", () => {\n\t    let ndk: NDK;\n\t    let event: NDKEvent;\n\t    let user1: NDKUser;\n\t    let user2: NDKUser;\n\t    beforeEach(() => {\n\t        ndk = new NDK();\n\t        user1 = new NDKUser({\n\t            npub: \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\",\n", "        });\n\t        user2 = new NDKUser({\n\t            npub: \"npub12262qa4uhw7u8gdwlgmntqtv7aye8vdcmvszkqwgs0zchel6mz7s6cgrkj\",\n\t        });\n\t        event = new NDKEvent(ndk);\n\t        event.author = user1;\n\t    });\n\t    describe(\"deduplicationKey\", () => {\n\t        it(\"returns <kind>:<pubkey> for kinds 0\", () => {\n\t            event.kind = 0;\n", "            const result = event.deduplicationKey();\n\t            expect(result).toEqual(`0:${user1.hexpubkey()}`);\n\t        });\n\t        it(\"returns <kind>:<pubkey> for kinds 3\", () => {\n\t            event.kind = 3;\n\t            const result = event.deduplicationKey();\n\t            expect(result).toEqual(`3:${user1.hexpubkey()}`);\n\t        });\n\t        it(\"returns tagId for other kinds\", () => {\n\t            event.kind = 2;\n", "            const spy = jest.spyOn(event, \"tagId\").mockReturnValue(\"mockTagId\");\n\t            const result = event.deduplicationKey();\n\t            expect(result).toEqual(\"mockTagId\");\n\t            expect(spy).toHaveBeenCalled();\n\t            spy.mockRestore();\n\t        });\n\t        it(\"returns parameterized tagId for kinds between 30k and 40k\", () => {\n\t            event.kind = 35000;\n\t            const spy = jest\n\t                .spyOn(event, \"tagId\")\n", "                .mockReturnValue(\"parameterizedTagId\");\n\t            const result = event.deduplicationKey();\n\t            expect(result).toEqual(\"parameterizedTagId\");\n\t            expect(spy).toHaveBeenCalled();\n\t            spy.mockRestore();\n\t        });\n\t    });\n\t    describe(\"tag\", () => {\n\t        it(\"tags a user without a marker\", () => {\n\t            event.tag(user2);\n", "            expect(event.tags).toEqual([[\"p\", user2.hexpubkey()]]);\n\t        });\n\t        it(\"tags a user with a marker\", () => {\n\t            event.tag(user2, \"author\");\n\t            expect(event.tags).toEqual([[\"p\", user2.hexpubkey(), \"author\"]]);\n\t        });\n\t        it(\"tags an event without a marker\", () => {\n\t            const otherEvent = new NDKEvent(ndk, {\n\t                id: \"123\",\n\t                kind: 1,\n", "            } as NostrEvent);\n\t            otherEvent.author = user1;\n\t            event.tag(otherEvent);\n\t            expect(event.tags).toEqual([[\"e\", otherEvent.id]]);\n\t        });\n\t        it(\"tags an event with a marker\", () => {\n\t            const otherEvent = new NDKEvent(ndk, {\n\t                id: \"123\",\n\t                kind: 1,\n\t            } as NostrEvent);\n", "            otherEvent.author = user1;\n\t            event.tag(otherEvent, \"marker\");\n\t            expect(event.tags).toEqual([[\"e\", otherEvent.id, \"marker\"]]);\n\t        });\n\t        it(\"tags an event author when it's different from the signing user\", () => {\n\t            const otherEvent = new NDKEvent(ndk, { kind: 1 } as NostrEvent);\n\t            otherEvent.author = user2;\n\t            event.tag(otherEvent);\n\t            expect(event.tags).toEqual([\n\t                [\"e\", otherEvent.id],\n", "                [\"p\", user2.hexpubkey()],\n\t            ]);\n\t        });\n\t        it(\"does not tag an event author when it's the same as the signing user\", () => {\n\t            const otherEvent = new NDKEvent(ndk, { kind: 1 } as NostrEvent);\n\t            otherEvent.author = user1;\n\t            event.tag(otherEvent);\n\t            expect(event.tags).toEqual([[\"e\", otherEvent.id]]);\n\t        });\n\t    });\n", "    describe(\"fetchEvents\", () => {\n\t        it(\"correctly handles a relay sending old replaced events\", async () => {\n\t            const eventData = {\n\t                kind: 300001,\n\t                tags: [[\"d\", \"\"]],\n\t                content: \"\",\n\t                pubkey: \"\",\n\t            };\n\t            const event1 = new NDKEvent(ndk, {\n\t                ...eventData,\n", "                created_at: Date.now() / 1000 - 3600,\n\t            });\n\t            const event2 = new NDKEvent(ndk, {\n\t                ...eventData,\n\t                created_at: Date.now() / 1000,\n\t            });\n\t            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n\t                const sub = new NDKSubscription(ndk, filter, opts);\n\t                setTimeout(() => {\n\t                    sub.emit(\"event\", event1);\n", "                    sub.emit(\"event\", event2);\n\t                    sub.emit(\"eose\");\n\t                }, 100);\n\t                return sub;\n\t            });\n\t            const events = await ndk.fetchEvents({ kinds: [30001 as number] });\n\t            expect(events.size).toBe(1);\n\t            const dedupedEvent = events.values().next().value;\n\t            expect(dedupedEvent).toEqual(event2);\n\t        });\n", "    });\n\t    describe(\"toNostrEvent\", () => {\n\t        it(\"returns a NostrEvent object\", async () => {\n\t            const nostrEvent = await event.toNostrEvent();\n\t            expect(nostrEvent).toHaveProperty(\"created_at\");\n\t            expect(nostrEvent).toHaveProperty(\"content\");\n\t            expect(nostrEvent).toHaveProperty(\"tags\");\n\t            expect(nostrEvent).toHaveProperty(\"kind\");\n\t            expect(nostrEvent).toHaveProperty(\"pubkey\");\n\t            expect(nostrEvent).toHaveProperty(\"id\");\n", "        });\n\t        describe(\"mentions\", () => {\n\t            it(\"handles NIP-27 mentions\", async () => {\n\t                event.content =\n\t                    \"hello nostr:npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft!\";\n\t                const nostrEvent = await event.toNostrEvent();\n\t                const mentionTag = nostrEvent.tags.find(\n\t                    (t) =>\n\t                        t[0] === \"p\" &&\n\t                        t[1] ===\n", "                            \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\"\n\t                );\n\t                expect(mentionTag).toBeTruthy();\n\t            });\n\t        });\n\t    });\n\t    describe(\"tagReference\", () => {\n\t        it(\"returns the correct tag for referencing the event\", () => {\n\t            const event1 = new NDKEvent(ndk, {\n\t                created_at: Date.now() / 1000,\n", "                content: \"\",\n\t                kind: 30000,\n\t                pubkey: \"pubkey\",\n\t                tags: [[\"d\", \"d-code\"]],\n\t            });\n\t            const event2 = new NDKEvent(ndk, {\n\t                created_at: Date.now() / 1000,\n\t                content: \"\",\n\t                tags: [],\n\t                kind: 1,\n", "                pubkey: \"pubkey\",\n\t                id: \"eventid\",\n\t            });\n\t            expect(event1.tagReference()).toEqual([\"a\", \"30000:pubkey:d-code\"]);\n\t            expect(event2.tagReference()).toEqual([\"e\", \"eventid\"]);\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/events/repost.ts", "chunked_list": ["import { NDKSigner } from \"../signers/index.js\";\n\timport NDKEvent, { NostrEvent } from \"./index.js\";\n\timport { NDKKind } from \"./kinds/index.js\";\n\t/**\n\t * NIP-18 reposting event.\n\t *\n\t * @param publish Whether to publish the reposted event automatically\n\t * @param signer The signer to use for signing the reposted event\n\t * @returns The reposted event\n\t */\n", "export async function repost(\n\t    this: NDKEvent,\n\t    publish = true,\n\t    signer?: NDKSigner\n\t) {\n\t    if (!signer) {\n\t        if (!this.ndk) throw new Error(\"No NDK instance found\");\n\t        this.ndk.assertSigner();\n\t        signer = this.ndk.signer;\n\t    }\n", "    if (!signer) {\n\t        throw new Error(\"No signer available\");\n\t    }\n\t    const user = await signer.user();\n\t    const e = new NDKEvent(this.ndk, {\n\t        kind: getKind(this),\n\t        content: \"\",\n\t        pubkey: user.hexpubkey(),\n\t    } as NostrEvent);\n\t    e.tag(this);\n", "    if (e.kind === NDKKind.GenericRepost) {\n\t        e.tags.push([\"k\", `${this.kind}`]);\n\t    }\n\t    await e.sign(signer);\n\t    if (publish) await e.publish();\n\t    return e;\n\t}\n\tfunction getKind(event: NDKEvent): NDKKind {\n\t    if (event.kind === 1) {\n\t        return NDKKind.Repost;\n", "    }\n\t    return NDKKind.GenericRepost;\n\t}\n"]}
{"filename": "src/events/nip19.test.ts", "chunked_list": ["import NDK, { NDKEvent, NDKRelay, NostrEvent } from \"../index\";\n\tlet ndk: NDK;\n\tbeforeAll(() => {\n\t    ndk = new NDK();\n\t});\n\tdescribe(\"NDKEvent\", () => {\n\t    describe(\"encode\", () => {\n\t        it(\"encodes NIP-33 events\", () => {\n\t            const event = new NDKEvent(ndk, {\n\t                kind: 30000,\n", "                pubkey: \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n\t                tags: [[\"d\", \"1234\"]],\n\t            } as NostrEvent);\n\t            const a = event.encode();\n\t            expect(a).toBe(\n\t                \"naddr1qqzrzv3nxspzp75cf0tahv5z7plpdeaws7ex52nmnwgtwfr2g3m37r844evqrr6jqvzqqqr4xq098d2k\"\n\t            );\n\t        });\n\t        it(\"encodes NIP-33 events with relay when it's known\", () => {\n\t            const event = new NDKEvent(ndk, {\n", "                kind: 30000,\n\t                pubkey: \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n\t                tags: [[\"d\", \"1234\"]],\n\t            } as NostrEvent);\n\t            event.relay = new NDKRelay(\"wss://relay.f7z.io\");\n\t            const a = event.encode();\n\t            expect(a).toBe(\n\t                \"naddr1qqzrzv3nxsq3yamnwvaz7tmjv4kxz7fwvcmh5tnfdupzp75cf0tahv5z7plpdeaws7ex52nmnwgtwfr2g3m37r844evqrr6jqvzqqqr4xq45f5n4\"\n\t            );\n\t        });\n", "        it(\"encodes events as notes when the relay is known\", () => {\n\t            const event = new NDKEvent(ndk, {\n\t                kind: 1,\n\t                pubkey: \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n\t                tags: [[\"d\", \"1234\"]],\n\t            } as NostrEvent);\n\t            event.relay = new NDKRelay(\"wss://relay.f7z.io\");\n\t            const a = event.encode();\n\t            expect(a).toBe(\n\t                \"nevent1qqqqzynhwden5te0wfjkccte9enrw73wd9hsyg86np9a0kajstc8u9h846rmy6320wdepdeydfz8w8cv7kh9sqv02gyxar4d\"\n", "            );\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/events/index.ts", "chunked_list": ["import EventEmitter from \"eventemitter3\";\n\timport { getEventHash, UnsignedEvent } from \"nostr-tools\";\n\timport NDK, { NDKFilter, NDKRelay, NDKRelaySet, NDKUser } from \"../index.js\";\n\timport { NDKSigner } from \"../signers/index.js\";\n\timport Zap from \"../zap/index.js\";\n\timport { generateContentTags } from \"./content-tagger.js\";\n\timport { isParamReplaceable, isReplaceable } from \"./kind.js\";\n\timport { NDKKind } from \"./kinds/index.js\";\n\timport { decrypt, encrypt } from \"./nip04.js\";\n\timport { encode } from \"./nip19.js\";\n", "import { repost } from \"./repost.js\";\n\texport type NDKEventId = string;\n\texport type NDKTag = string[];\n\texport type NostrEvent = {\n\t    created_at: number;\n\t    content: string;\n\t    tags: NDKTag[];\n\t    kind?: NDKKind | number;\n\t    pubkey: string;\n\t    id?: string;\n", "    sig?: string;\n\t};\n\texport type ContentTag = {\n\t    tags: NDKTag[];\n\t    content: string;\n\t};\n\t/**\n\t * NDKEvent is the basic building block of NDK; most things\n\t * you do with NDK will revolve around writing or consuming NDKEvents.\n\t */\n", "export default class NDKEvent extends EventEmitter {\n\t    public ndk?: NDK;\n\t    public created_at?: number;\n\t    public content = \"\";\n\t    public tags: NDKTag[] = [];\n\t    public kind?: NDKKind | number;\n\t    public id = \"\";\n\t    public sig?: string;\n\t    public pubkey = \"\";\n\t    /**\n", "     * The relay that this event was first received from.\n\t     */\n\t    public relay: NDKRelay | undefined;\n\t    constructor(ndk?: NDK, event?: NostrEvent) {\n\t        super();\n\t        this.ndk = ndk;\n\t        this.created_at = event?.created_at;\n\t        this.content = event?.content || \"\";\n\t        this.tags = event?.tags || [];\n\t        this.id = event?.id || \"\";\n", "        this.sig = event?.sig;\n\t        this.pubkey = event?.pubkey || \"\";\n\t        this.kind = event?.kind;\n\t    }\n\t    /**\n\t     * Returns the event as is.\n\t     */\n\t    public rawEvent(): NostrEvent {\n\t        return {\n\t            created_at: this.created_at,\n", "            content: this.content,\n\t            tags: this.tags,\n\t            kind: this.kind,\n\t            pubkey: this.pubkey,\n\t            id: this.id,\n\t            sig: this.sig,\n\t        } as NostrEvent;\n\t    }\n\t    set author(user: NDKUser) {\n\t        this.pubkey = user.hexpubkey();\n", "    }\n\t    /**\n\t     * Returns an NDKUser for the author of the event.\n\t     */\n\t    get author(): NDKUser {\n\t        const user = new NDKUser({ hexpubkey: this.pubkey });\n\t        user.ndk = this.ndk;\n\t        return user;\n\t    }\n\t    /**\n", "     * Tag a user with an optional marker.\n\t     * @param user The user to tag.\n\t     * @param marker The marker to use in the tag.\n\t     */\n\t    public tag(user: NDKUser, marker?: string): void;\n\t    /**\n\t     * Tag a user with an optional marker.\n\t     * @param event The event to tag.\n\t     * @param marker The marker to use in the tag.\n\t     * @example\n", "     * ```typescript\n\t     * reply.tag(opEvent, \"reply\");\n\t     * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n\t     * ```\n\t     */\n\t    public tag(event: NDKEvent, marker?: string): void;\n\t    public tag(userOrEvent: NDKUser | NDKEvent, marker?: string): void {\n\t        const tag = userOrEvent.tagReference();\n\t        if (marker) tag.push(marker);\n\t        this.tags.push(tag);\n", "        if (userOrEvent instanceof NDKEvent) {\n\t            const tagEventAuthor = userOrEvent.author;\n\t            // If event author is not the same as the user signing this event, tag the author\n\t            if (tagEventAuthor && this.pubkey !== tagEventAuthor.hexpubkey()) {\n\t                this.tag(tagEventAuthor);\n\t            }\n\t            // tag p-tags in the event if they are not the same as the user signing this event\n\t            for (const pTag of userOrEvent.getMatchingTags(\"p\")) {\n\t                if (pTag[1] === this.pubkey) continue;\n\t                if (this.tags.find((t) => t[0] === \"p\" && t[1] === pTag[1]))\n", "                    continue;\n\t                this.tags.push([\"p\", pTag[1]]);\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Return a NostrEvent object, trying to fill in missing fields\n\t     * when possible, adding tags when necessary.\n\t     * @param pubkey {string} The pubkey of the user who the event belongs to.\n\t     * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.\n", "     */\n\t    async toNostrEvent(pubkey?: string): Promise<NostrEvent> {\n\t        if (!pubkey && this.pubkey === \"\") {\n\t            const user = await this.ndk?.signer?.user();\n\t            this.pubkey = user?.hexpubkey() || \"\";\n\t        }\n\t        if (!this.created_at) this.created_at = Math.floor(Date.now() / 1000);\n\t        const nostrEvent = this.rawEvent();\n\t        const { content, tags } = this.generateTags();\n\t        nostrEvent.content = content || \"\";\n", "        nostrEvent.tags = tags;\n\t        try {\n\t            this.id = getEventHash(nostrEvent as UnsignedEvent);\n\t            // eslint-disable-next-line no-empty\n\t        } catch (e) {}\n\t        if (this.id) nostrEvent.id = this.id;\n\t        if (this.sig) nostrEvent.sig = this.sig;\n\t        return nostrEvent;\n\t    }\n\t    public isReplaceable = isReplaceable.bind(this);\n", "    public isParamReplaceable = isParamReplaceable.bind(this);\n\t    /**\n\t     * Encodes a bech32 id.\n\t     *\n\t     * @returns {string} - Encoded naddr, note or nevent.\n\t     */\n\t    public encode = encode.bind(this);\n\t    public encrypt = encrypt.bind(this);\n\t    public decrypt = decrypt.bind(this);\n\t    /**\n", "     * Get all tags with the given name\n\t     * @param tagName {string} The name of the tag to search for\n\t     * @returns {NDKTag[]} An array of the matching tags\n\t     */\n\t    public getMatchingTags(tagName: string): NDKTag[] {\n\t        return this.tags.filter((tag) => tag[0] === tagName);\n\t    }\n\t    /**\n\t     * Get the first tag with the given name\n\t     * @param tagName Tag name to search for\n", "     * @returns The value of the first tag with the given name, or undefined if no such tag exists\n\t     */\n\t    public tagValue(tagName: string): string | undefined {\n\t        const tags = this.getMatchingTags(tagName);\n\t        if (tags.length === 0) return undefined;\n\t        return tags[0][1];\n\t    }\n\t    /**\n\t     * Remove all tags with the given name (e.g. \"d\", \"a\", \"p\")\n\t     * @param tagName Tag name to search for and remove\n", "     * @returns {void}\n\t     */\n\t    public removeTag(tagName: string): void {\n\t        this.tags = this.tags.filter((tag) => tag[0] !== tagName);\n\t    }\n\t    /**\n\t     * Sign the event if a signer is present.\n\t     *\n\t     * It will generate tags.\n\t     * Repleacable events will have their created_at field set to the current time.\n", "     * @param signer {NDKSigner} The NDKSigner to use to sign the event\n\t     * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.\n\t     */\n\t    public async sign(signer?: NDKSigner): Promise<string> {\n\t        if (!signer) {\n\t            this.ndk?.assertSigner();\n\t            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t            signer = this.ndk!.signer!;\n\t        }\n\t        await this.generateTags();\n", "        if (this.isReplaceable()) {\n\t            this.created_at = Math.floor(Date.now() / 1000);\n\t        }\n\t        const nostrEvent = await this.toNostrEvent();\n\t        this.sig = await signer.sign(nostrEvent);\n\t        return this.sig;\n\t    }\n\t    /**\n\t     * Attempt to sign and then publish an NDKEvent to a given relaySet.\n\t     * If no relaySet is provided, the relaySet will be calculated by NDK.\n", "     * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n\t     * @returns A promise that resolves to the relays the event was published to.\n\t     */\n\t    public async publish(\n\t        relaySet?: NDKRelaySet,\n\t        timeoutMs?: number\n\t    ): Promise<Set<NDKRelay>> {\n\t        if (!this.sig) await this.sign();\n\t        if (!this.ndk)\n\t            throw new Error(\n", "                \"NDKEvent must be associated with an NDK instance to publish\"\n\t            );\n\t        return this.ndk.publish(this, relaySet, timeoutMs);\n\t    }\n\t    /**\n\t     * Generates tags for users, notes, and other events tagged in content.\n\t     * Will also generate random \"d\" tag for parameterized replaceable events where needed.\n\t     * @returns {ContentTag} The tags and content of the event.\n\t     */\n\t    protected generateTags(): ContentTag {\n", "        let tags: NDKTag[] = [];\n\t        // don't autogenerate if there currently are tags\n\t        const g = generateContentTags(this.content, this.tags);\n\t        const content = g.content;\n\t        tags = g.tags;\n\t        // if this is a parameterized replaceable event, check if there's a d tag, if not, generate it\n\t        if (this.kind && this.kind >= 30000 && this.kind <= 40000) {\n\t            const dTag = this.getMatchingTags(\"d\")[0];\n\t            // generate a string of 32 random bytes\n\t            if (!dTag) {\n", "                const str = [...Array(16)]\n\t                    .map(() => Math.random().toString(36)[2])\n\t                    .join(\"\");\n\t                tags.push([\"d\", str]);\n\t            }\n\t        }\n\t        return { content: content || \"\", tags };\n\t    }\n\t    /**\n\t     * Returns the \"d\" tag of a parameterized replaceable event or throws an error if the event isn't\n", "     * a parameterized replaceable event.\n\t     * @returns {string} the \"d\" tag of the event.\n\t     */\n\t    replaceableDTag() {\n\t        if (this.kind && this.kind >= 30000 && this.kind <= 40000) {\n\t            const dTag = this.getMatchingTags(\"d\")[0];\n\t            const dTagId = dTag ? dTag[1] : \"\";\n\t            return dTagId;\n\t        }\n\t        throw new Error(\"Event is not a parameterized replaceable event\");\n", "    }\n\t    /**\n\t     * Provides a deduplication key for the event.\n\t     *\n\t     * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>\n\t     * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>\n\t     * For all other kinds this will be the event id\n\t     */\n\t    deduplicationKey(): string {\n\t        if (this.kind === 0 || this.kind === 3) {\n", "            return `${this.kind}:${this.pubkey}`;\n\t        } else {\n\t            return this.tagId();\n\t        }\n\t    }\n\t    /**\n\t     * Returns the id of the event or, if it's a parameterized event, the generated id of the event using \"d\" tag, pubkey, and kind.\n\t     * @returns {string} The id\n\t     */\n\t    tagId(): string {\n", "        // NIP-33\n\t        if (this.kind && this.kind >= 30000 && this.kind <= 40000) {\n\t            const dTagId = this.replaceableDTag();\n\t            return `${this.kind}:${this.pubkey}:${dTagId}`;\n\t        }\n\t        return this.id;\n\t    }\n\t    /**\n\t     * Get the tag that can be used to reference this event from another event\n\t     * @example\n", "     *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n\t     *     event.tagReference(); // [\"a\", \"30000:pubkey:d-code\"]\n\t     *\n\t     *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n\t     *     event.tagReference(); // [\"e\", \"eventid\"]\n\t     * @returns {NDKTag} The NDKTag object referencing this event\n\t     */\n\t    tagReference(): NDKTag {\n\t        // NIP-33\n\t        if (this.isParamReplaceable()) {\n", "            return [\"a\", this.tagId()];\n\t        }\n\t        return [\"e\", this.tagId()];\n\t    }\n\t    /**\n\t     * Provides the filter that will return matching events for this event.\n\t     *\n\t     * @example\n\t     *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n\t     *    event.filter(); // { \"#a\": [\"30000:pubkey:d-code\"] }\n", "     * @example\n\t     *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n\t     *    event.filter(); // { \"#e\": [\"eventid\"] }\n\t     *\n\t     * @returns The filter that will return matching events for this event\n\t     */\n\t    filter(): NDKFilter {\n\t        if (this.isParamReplaceable()) {\n\t            return { \"#a\": [this.tagId()] };\n\t        } else {\n", "            return { \"#e\": [this.tagId()] };\n\t        }\n\t    }\n\t    /**\n\t     * Create a zap request for an existing event\n\t     *\n\t     * @param amount The amount to zap in millisatoshis\n\t     * @param comment A comment to add to the zap request\n\t     * @param extraTags Extra tags to add to the zap request\n\t     */\n", "    async zap(\n\t        amount: number,\n\t        comment?: string,\n\t        extraTags?: NDKTag[]\n\t    ): Promise<string | null> {\n\t        if (!this.ndk) throw new Error(\"No NDK instance found\");\n\t        this.ndk.assertSigner();\n\t        const zap = new Zap({\n\t            ndk: this.ndk,\n\t            zappedEvent: this,\n", "        });\n\t        const paymentRequest = await zap.createZapRequest(\n\t            amount,\n\t            comment,\n\t            extraTags\n\t        );\n\t        // await zap.publish(amount);\n\t        return paymentRequest;\n\t    }\n\t    /**\n", "     * Generates a deletion event of the current event\n\t     *\n\t     * @param reason The reason for the deletion\n\t     * @returns The deletion event\n\t     */\n\t    async delete(reason?: string): Promise<NDKEvent> {\n\t        if (!this.ndk) throw new Error(\"No NDK instance found\");\n\t        this.ndk.assertSigner();\n\t        const e = new NDKEvent(this.ndk, {\n\t            kind: NDKKind.EventDeletion,\n", "            content: reason || \"\",\n\t        } as NostrEvent);\n\t        e.tag(this);\n\t        await e.publish();\n\t        return e;\n\t    }\n\t    /**\n\t     * NIP-18 reposting event.\n\t     *\n\t     * @param publish Whether to publish the reposted event automatically\n", "     * @param signer The signer to use for signing the reposted event\n\t     * @returns The reposted event\n\t     *\n\t     * @function\n\t     */\n\t    public repost = repost.bind(this);\n\t}\n"]}
{"filename": "src/events/dedup.ts", "chunked_list": ["import { NDKEvent } from \"../index.js\";\n\t/**\n\t * Receives two events and returns the \"correct\" event to use.\n\t * #nip-33\n\t */\n\texport default function dedup(event1: NDKEvent, event2: NDKEvent) {\n\t    // return the newest of the two\n\t    if (event1.created_at! > event2.created_at!) {\n\t        return event1;\n\t    }\n", "    return event2;\n\t}\n"]}
{"filename": "src/events/content-tagger.test.ts", "chunked_list": ["import { generateContentTags } from \"./content-tagger\";\n\timport { NDKTag } from \"./index.js\";\n\tdescribe(\"generateContentTags\", () => {\n\t    it(\"should replace valid tags and store decoded data in the tags array\", () => {\n\t        const content =\n\t            \"This is a sample content with @npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft and @note1d2mheza0d5z5yycucu94nw37e6gyl4vwl6gavyku86rshkhexq6q30s0g7 tags.\";\n\t        const tags: NDKTag[] = [];\n\t        const { content: processedContent, tags: processedTags } =\n\t            generateContentTags(content, tags);\n\t        expect(processedContent).toEqual(\n", "            \"This is a sample content with nostr:npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft and nostr:note1d2mheza0d5z5yycucu94nw37e6gyl4vwl6gavyku86rshkhexq6q30s0g7 tags.\"\n\t        );\n\t        expect(processedTags.length).toEqual(2);\n\t        expect(processedTags).toEqual([\n\t            [\n\t                \"p\",\n\t                \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n\t            ],\n\t            [\n\t                \"e\",\n", "                \"6ab77c8baf6d0542131cc70b59ba3ece904fd58efe91d612dc3e870bdaf93034\",\n\t            ],\n\t        ]);\n\t    });\n\t    it(\"should not replace invalid tags and leave the tags array unchanged\", () => {\n\t        const content = \"This is a sample content with an @invalidTag.\";\n\t        const tags: NDKTag[] = [];\n\t        const { content: processedContent, tags: processedTags } =\n\t            generateContentTags(content, tags);\n\t        expect(processedContent).toEqual(content);\n", "        expect(processedTags.length).toEqual(0);\n\t    });\n\t    it(\"should handle existing tags and update indexes accordingly\", () => {\n\t        const content =\n\t            \"This is a sample content with @npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft and @note1d2mheza0d5z5yycucu94nw37e6gyl4vwl6gavyku86rshkhexq6q30s0g7 tags.\";\n\t        const tags: NDKTag[] = [[\"p\", \"existing_p\"]];\n\t        const { content: processedContent, tags: processedTags } =\n\t            generateContentTags(content, tags);\n\t        expect(processedContent).toEqual(\n\t            \"This is a sample content with nostr:npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft and nostr:note1d2mheza0d5z5yycucu94nw37e6gyl4vwl6gavyku86rshkhexq6q30s0g7 tags.\"\n", "        );\n\t        expect(processedTags.length).toEqual(3);\n\t        expect(processedTags).toEqual([\n\t            [\"p\", \"existing_p\"],\n\t            [\n\t                \"p\",\n\t                \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n\t            ],\n\t            [\n\t                \"e\",\n", "                \"6ab77c8baf6d0542131cc70b59ba3ece904fd58efe91d612dc3e870bdaf93034\",\n\t            ],\n\t        ]);\n\t    });\n\t    it(\"does not replace an event without a nostr: or @ prefix\", async () => {\n\t        const content =\n\t            \"note13jgf85r2yxjmww8f6gweque5g388agfztrppmgenur7zvh8e929s4cptur \" +\n\t            \"@note13jgf85r2yxjmww8f6gweque5g388agfztrppmgenur7zvh8e929s4cptur\";\n\t        const { content: processedContent, tags: processedTags } =\n\t            generateContentTags(content, []);\n", "        expect(processedContent).toEqual(\n\t            \"note13jgf85r2yxjmww8f6gweque5g388agfztrppmgenur7zvh8e929s4cptur \" +\n\t                \"nostr:note13jgf85r2yxjmww8f6gweque5g388agfztrppmgenur7zvh8e929s4cptur\"\n\t        );\n\t        expect(processedTags).toEqual([\n\t            [\n\t                \"e\",\n\t                \"8c9093d06a21a5b738e9d21d907334444e7ea12258c21da333e0fc265cf92a8b\",\n\t            ],\n\t        ]);\n", "    });\n\t});\n"]}
{"filename": "src/events/kinds/article.ts", "chunked_list": ["import NDK from \"../../index.js\";\n\timport { ContentTag, type NostrEvent } from \"../index.js\";\n\timport NDKEvent from \"../index.js\";\n\timport { NDKKind } from \"./index.js\";\n\t/**\n\t * Represents a NIP-23 article.\n\t */\n\texport class NDKArticle extends NDKEvent {\n\t    constructor(ndk: NDK | undefined, rawEvent?: NostrEvent) {\n\t        super(ndk, rawEvent);\n", "        this.kind = NDKKind.Article;\n\t    }\n\t    /**\n\t     * Creates a NDKArticle from an existing NDKEvent.\n\t     *\n\t     * @param event NDKEVent to create the NDKArticle from.\n\t     * @returns NDKArticle\n\t     */\n\t    static from(event: NDKEvent) {\n\t        return new NDKArticle(event.ndk, event.rawEvent());\n", "    }\n\t    /**\n\t     * Getter for the article title.\n\t     *\n\t     * @returns {string | undefined} - The article title if available, otherwise undefined.\n\t     */\n\t    get title(): string | undefined {\n\t        return this.tagValue(\"title\");\n\t    }\n\t    /**\n", "     * Setter for the article title.\n\t     *\n\t     * @param {string | undefined} title - The title to set for the article.\n\t     */\n\t    set title(title: string | undefined) {\n\t        this.removeTag(\"title\");\n\t        if (title) this.tags.push([\"title\", title]);\n\t    }\n\t    /**\n\t     * Getter for the article image.\n", "     *\n\t     * @returns {string | undefined} - The article image if available, otherwise undefined.\n\t     */\n\t    get image(): string | undefined {\n\t        return this.tagValue(\"image\");\n\t    }\n\t    /**\n\t     * Setter for the article image.\n\t     *\n\t     * @param {string | undefined} image - The image to set for the article.\n", "     */\n\t    set image(image: string | undefined) {\n\t        this.removeTag(\"image\");\n\t        if (image) this.tags.push([\"image\", image]);\n\t    }\n\t    /**\n\t     * Getter for the article's publication timestamp.\n\t     *\n\t     * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n\t     */\n", "    get published_at(): number | undefined {\n\t        const tag = this.tagValue(\"published_at\");\n\t        if (tag) {\n\t            return parseInt(tag);\n\t        }\n\t        return undefined;\n\t    }\n\t    /**\n\t     * Setter for the article's publication timestamp.\n\t     *\n", "     * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n\t     */\n\t    set published_at(timestamp: number | undefined) {\n\t        this.removeTag(\"published_at\"); // Removes any existing \"published_at\" tag.\n\t        if (timestamp !== undefined) {\n\t            this.tags.push([\"published_at\", timestamp.toString()]);\n\t        }\n\t    }\n\t    /**\n\t     * Generates content tags for the article.\n", "     *\n\t     * This method first checks and sets the publication date if not available,\n\t     * and then generates content tags based on the base NDKEvent class.\n\t     *\n\t     * @returns {ContentTag} - The generated content tags.\n\t     */\n\t    protected generateTags(): ContentTag {\n\t        super.generateTags();\n\t        if (!this.published_at) {\n\t            this.published_at = this.created_at;\n", "        }\n\t        return super.generateTags();\n\t    }\n\t    /**\n\t     * Getter for the article's URL.\n\t     *\n\t     * @returns {string | undefined} - The article's URL if available, otherwise undefined.\n\t     */\n\t    get url(): string | undefined {\n\t        return this.tagValue(\"url\");\n", "    }\n\t    /**\n\t     * Setter for the article's URL.\n\t     *\n\t     * @param {string | undefined} url - The URL to set for the article.\n\t     */\n\t    set url(url: string | undefined) {\n\t        if (url) {\n\t            this.tags.push([\"url\", url]);\n\t        } else {\n", "            this.removeTag(\"url\");\n\t        }\n\t    }\n\t}\n"]}
{"filename": "src/events/kinds/repost.ts", "chunked_list": ["import NDK, { NDKFilter } from \"../../index.js\";\n\timport { NDKSubscriptionOptions } from \"../../subscription/index.js\";\n\timport NDKEvent, { NDKTag, NostrEvent } from \"../index.js\";\n\ttype classWithConvertFunction<T> = {\n\t    from: (event: NDKEvent) => T;\n\t};\n\t/**\n\t * Handles NIP-18 reposts.\n\t */\n\texport class NDKRepost<T> extends NDKEvent {\n", "    private _repostedEvents: T[] | undefined;\n\t    constructor(ndk?: NDK, rawEvent?: NostrEvent) {\n\t        super(ndk, rawEvent);\n\t    }\n\t    static from(event: NDKEvent) {\n\t        return new NDKRepost(event.ndk, event.rawEvent());\n\t    }\n\t    /**\n\t     * Returns all reposted events by the current event.\n\t     *\n", "     * @param klass Optional class to convert the events to.\n\t     * @returns\n\t     */\n\t    async repostedEvents(\n\t        klass?: classWithConvertFunction<T>,\n\t        opts?: NDKSubscriptionOptions\n\t    ): Promise<T[]> {\n\t        const items: T[] = [];\n\t        if (!this.ndk) throw new Error(\"NDK instance not set\");\n\t        if (this._repostedEvents !== undefined) return this._repostedEvents;\n", "        for (const eventId of this.repostedEventIds()) {\n\t            const filter = filterForId(eventId);\n\t            const event = await this.ndk.fetchEvent(filter, opts);\n\t            if (event) {\n\t                items.push(klass ? klass.from(event) : (event as T));\n\t            }\n\t        }\n\t        return items;\n\t    }\n\t    /**\n", "     * Returns the reposted event IDs.\n\t     */\n\t    repostedEventIds(): string[] {\n\t        return this.tags\n\t            .filter((t: NDKTag) => t[0] === \"e\" || t[0] === \"a\")\n\t            .map((t: NDKTag) => t[1]);\n\t    }\n\t}\n\tfunction filterForId(id: string): NDKFilter {\n\t    if (id.match(/:/)) {\n", "        const [kind, pubkey, identifier] = id.split(\":\");\n\t        return {\n\t            kinds: [parseInt(kind)],\n\t            authors: [pubkey],\n\t            \"#d\": [identifier],\n\t        };\n\t    } else {\n\t        return { ids: [id] };\n\t    }\n\t}\n"]}
{"filename": "src/events/kinds/index.ts", "chunked_list": ["export enum NDKKind {\n\t    Metadata = 0,\n\t    Text = 1,\n\t    RecommendRelay = 2,\n\t    Contacts = 3,\n\t    EncryptedDirectMessage = 4,\n\t    EventDeletion = 5,\n\t    Repost = 6,\n\t    Reaction = 7,\n\t    BadgeAward = 8,\n", "    GenericRepost = 16,\n\t    ChannelCreation = 40,\n\t    ChannelMetadata = 41,\n\t    ChannelMessage = 42,\n\t    ChannelHideMessage = 43,\n\t    ChannelMuteUser = 44,\n\t    Report = 1984,\n\t    ZapRequest = 9734,\n\t    Zap = 9735,\n\t    Highlight = 9802,\n", "    MuteList = 10000,\n\t    PinList = 10001,\n\t    RelayList = 10002,\n\t    ClientAuth = 22242,\n\t    NostrConnect = 24133,\n\t    CategorizedPeopleList = 30000,\n\t    CategorizedBookmarkList = 30001,\n\t    CategorizedRelayList = 30022,\n\t    ProfileBadge = 30008,\n\t    BadgeDefinition = 30009,\n", "    MarketStall = 30017,\n\t    MarketProduct = 30018,\n\t    Article = 30023,\n\t    AppSpecificData = 30078,\n\t    CategorizedHighlightList = 39802,\n\t    // NIP-90: Data Vending Machines\n\t    DVMJobFeedback = 65000,\n\t    DVMJobResult = 65001,\n\t    DVMJobRequestTranscription = 65002,\n\t}\n"]}
{"filename": "src/events/kinds/lists/index.ts", "chunked_list": ["import NDK, { NDKKind, NDKRelay, NDKUser } from \"../../../index.js\";\n\timport NDKEvent from \"../../index.js\";\n\timport { NDKTag, NostrEvent } from \"../../index.js\";\n\texport type NDKListItem = NDKRelay | NDKUser | NDKEvent;\n\t/**\n\t * Represents any NIP-33 list kind.\n\t *\n\t * This class provides some helper methods to manage the list, particularly\n\t * a CRUD interface to list items.\n\t *\n", " * List items can be encrypted or not. Encrypted items are JSON-encoded and\n\t * self-signed by the user's key.\n\t *\n\t * @example Adding an event to the list.\n\t * const event1 = new NDKEvent(...);\n\t * const list = new NDKList();\n\t * list.addItem(event1);\n\t *\n\t * @example Adding an encrypted `p` tag to the list with a \"person\" mark.\n\t * const secretFollow = new NDKUser(...);\n", " * list.addItem(secretFollow, 'person', true);\n\t *\n\t * @emits NDKList#change\n\t */\n\texport class NDKList extends NDKEvent {\n\t    public _encryptedTags: NDKTag[] | undefined;\n\t    /**\n\t     * Stores the number of bytes the content was before decryption\n\t     * to expire the cache when the content changes.\n\t     */\n", "    private encryptedTagsLength: number | undefined;\n\t    constructor(ndk?: NDK, rawEvent?: NostrEvent) {\n\t        super(ndk, rawEvent);\n\t        if (!this.kind) this.kind = NDKKind.CategorizedBookmarkList;\n\t    }\n\t    /**\n\t     * Wrap a NDKEvent into a NDKList\n\t     */\n\t    static from(ndkEvent: NDKEvent): NDKList {\n\t        return new NDKList(ndkEvent.ndk, ndkEvent.rawEvent());\n", "    }\n\t    /**\n\t     * Returns the name of the list.\n\t     */\n\t    get name(): string | undefined {\n\t        return this.tagValue(\"name\") ?? this.tagValue(\"d\");\n\t    }\n\t    /**\n\t     * Sets the name of the list.\n\t     */\n", "    set name(name: string | undefined) {\n\t        this.removeTag(\"name\");\n\t        if (name) {\n\t            this.tags.push([\"name\", name]);\n\t        } else {\n\t            throw new Error(\"Name cannot be empty\");\n\t        }\n\t    }\n\t    /**\n\t     * Returns the description of the list.\n", "     */\n\t    get description(): string | undefined {\n\t        return this.tagValue(\"description\");\n\t    }\n\t    /**\n\t     * Sets the description of the list.\n\t     */\n\t    set description(name: string | undefined) {\n\t        if (name) {\n\t            this.tags.push([\"description\", name]);\n", "        } else {\n\t            this.removeTag(\"description\");\n\t        }\n\t    }\n\t    private isEncryptedTagsCacheValid(): boolean {\n\t        return !!(\n\t            this._encryptedTags &&\n\t            this.encryptedTagsLength === this.content.length\n\t        );\n\t    }\n", "    /**\n\t     * Returns the decrypted content of the list.\n\t     */\n\t    async encryptedTags(useCache = true): Promise<NDKTag[]> {\n\t        if (useCache && this.isEncryptedTagsCacheValid())\n\t            return this._encryptedTags!;\n\t        if (!this.ndk) throw new Error(\"NDK instance not set\");\n\t        if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n\t        const user = await this.ndk.signer.user();\n\t        try {\n", "            if (this.content.length > 0) {\n\t                try {\n\t                    const decryptedContent = await this.ndk.signer.decrypt(\n\t                        user,\n\t                        this.content\n\t                    );\n\t                    const a = JSON.parse(decryptedContent);\n\t                    if (a && a[0]) {\n\t                        this.encryptedTagsLength = this.content.length;\n\t                        return (this._encryptedTags = a);\n", "                    }\n\t                    this.encryptedTagsLength = this.content.length;\n\t                    return (this._encryptedTags = []);\n\t                } catch (e) {\n\t                    console.log(`error decrypting ${this.content}`);\n\t                }\n\t            }\n\t        } catch (e) {\n\t            // console.trace(e);\n\t            // throw e;\n", "        }\n\t        return [];\n\t    }\n\t    /**\n\t     * This method can be overriden to validate that a tag is valid for this list.\n\t     *\n\t     * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n\t     */\n\t    public validateTag(tagValue: string): boolean | string {\n\t        return true;\n", "    }\n\t    /**\n\t     * Returns the unecrypted items in this list.\n\t     */\n\t    get items(): NDKTag[] {\n\t        return this.tags.filter((t) => {\n\t            return ![\"d\", \"name\", \"description\"].includes(t[0]);\n\t        });\n\t    }\n\t    /**\n", "     * Adds a new item to the list.\n\t     * @param relay Relay to add\n\t     * @param mark Optional mark to add to the item\n\t     * @param encrypted Whether to encrypt the item\n\t     */\n\t    async addItem(\n\t        item: NDKListItem | NDKTag,\n\t        mark: string | undefined = undefined,\n\t        encrypted = false\n\t    ): Promise<void> {\n", "        if (!this.ndk) throw new Error(\"NDK instance not set\");\n\t        if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n\t        let tag;\n\t        if (item instanceof NDKEvent) {\n\t            tag = item.tagReference();\n\t        } else if (item instanceof NDKUser) {\n\t            tag = item.tagReference();\n\t        } else if (item instanceof NDKRelay) {\n\t            tag = item.tagReference();\n\t        } else if (Array.isArray(item)) {\n", "            // NDKTag\n\t            tag = item;\n\t        } else {\n\t            throw new Error(\"Invalid object type\");\n\t        }\n\t        if (mark) tag.push(mark);\n\t        if (encrypted) {\n\t            const user = await this.ndk.signer.user();\n\t            const currentList = await this.encryptedTags();\n\t            currentList.push(tag);\n", "            this._encryptedTags = currentList;\n\t            this.encryptedTagsLength = this.content.length;\n\t            this.content = JSON.stringify(currentList);\n\t            await this.encrypt(user);\n\t        } else {\n\t            this.tags.push(tag);\n\t        }\n\t        this.created_at = Math.floor(Date.now() / 1000);\n\t        this.emit(\"change\");\n\t    }\n", "    /**\n\t     * Removes an item from the list.\n\t     *\n\t     * @param index The index of the item to remove.\n\t     * @param encrypted Whether to remove from the encrypted list or not.\n\t     */\n\t    async removeItem(index: number, encrypted: boolean): Promise<NDKList> {\n\t        if (!this.ndk) throw new Error(\"NDK instance not set\");\n\t        if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n\t        if (encrypted) {\n", "            const user = await this.ndk.signer.user();\n\t            const currentList = await this.encryptedTags();\n\t            currentList.splice(index, 1);\n\t            this._encryptedTags = currentList;\n\t            this.encryptedTagsLength = this.content.length;\n\t            this.content = JSON.stringify(currentList);\n\t            await this.encrypt(user);\n\t        } else {\n\t            this.tags.splice(index, 1);\n\t        }\n", "        this.created_at = Math.floor(Date.now() / 1000);\n\t        this.emit(\"change\");\n\t        return this;\n\t    }\n\t}\n\texport default NDKList;\n"]}
{"filename": "src/events/kinds/dvm/NDKDVMRequest.ts", "chunked_list": ["import NDK, { NDKDVMJobResult, NDKEvent, NostrEvent } from \"../../../index.js\";\n\t/**\n\t * NIP-90: Data vending machine\n\t *\n\t * A generic Job request class for Data Vending Machines\n\t */\n\texport class NDKDVMRequest extends NDKEvent {\n\t    constructor(ndk: NDK | undefined, event?: NostrEvent) {\n\t        super(ndk, event);\n\t        if (ndk) {\n", "            this.tags.push([\"relays\", ...ndk.pool.urls()]);\n\t        }\n\t    }\n\t    static from(event: NDKEvent) {\n\t        return new NDKDVMRequest(event.ndk, event.rawEvent());\n\t    }\n\t    /**\n\t     * Create a new result event for this request\n\t     */\n\t    public createResult(data?: NostrEvent) {\n", "        const event = new NDKDVMJobResult(this.ndk, data);\n\t        event.jobRequest = this;\n\t        return event;\n\t    }\n\t    set bid(msatAmount: number | undefined) {\n\t        if (msatAmount === undefined) {\n\t            this.removeTag(\"bid\");\n\t        } else {\n\t            this.tags.push([\"bid\", msatAmount.toString()]);\n\t        }\n", "    }\n\t    get bid(): number | undefined {\n\t        const v = this.tagValue(\"bid\");\n\t        if (v === undefined) return undefined;\n\t        return parseInt(v);\n\t    }\n\t    /**\n\t     * Adds a new input to the job\n\t     * @param args The arguments to the input\n\t     */\n", "    addInput(...args: string[]): void {\n\t        this.tags.push([\"i\", ...args]);\n\t    }\n\t    /**\n\t     * Adds a new parameter to the job\n\t     */\n\t    addParam(...args: string[]): void {\n\t        this.tags.push([\"param\", ...args]);\n\t    }\n\t    set output(output: string | string[] | undefined) {\n", "        if (output === undefined) {\n\t            this.removeTag(\"output\");\n\t        } else {\n\t            if (typeof output === \"string\") output = [output];\n\t            this.tags.push([\"output\", ...output]);\n\t        }\n\t    }\n\t    get output(): string[] | undefined {\n\t        const outputTag = this.getMatchingTags(\"output\")[0];\n\t        return outputTag ? outputTag.slice(1) : undefined;\n", "    }\n\t}\n"]}
{"filename": "src/events/kinds/dvm/NDKDVMJobResult.ts", "chunked_list": ["import NDK from \"../../../index.js\";\n\timport NDKEvent, { NostrEvent } from \"../../index.js\";\n\timport { NDKKind } from \"../index.js\";\n\t/**\n\t * This event is published by Data Vending Machines when\n\t * they have finished processing a job.\n\t */\n\texport class NDKDVMJobResult extends NDKEvent {\n\t    constructor(ndk?: NDK, event?: NostrEvent) {\n\t        super(ndk, event);\n", "        this.kind = NDKKind.DVMJobResult;\n\t    }\n\t    static from(event: NDKEvent) {\n\t        return new NDKDVMJobResult(event.ndk, event.rawEvent());\n\t    }\n\t    set result(result: string | undefined) {\n\t        if (result === undefined) {\n\t            this.content = \"\";\n\t        } else {\n\t            this.content = result;\n", "        }\n\t    }\n\t    get result(): string | undefined {\n\t        if (this.content === \"\") {\n\t            return undefined;\n\t        }\n\t        return this.content;\n\t    }\n\t    set status(status: string | undefined) {\n\t        this.removeTag(\"status\");\n", "        if (status !== undefined) {\n\t            this.tags.push([\"status\", status]);\n\t        }\n\t    }\n\t    get status(): string | undefined {\n\t        return this.tagValue(\"status\");\n\t    }\n\t    set jobRequest(event: NDKEvent | undefined) {\n\t        this.removeTag(\"request\");\n\t        if (event) {\n", "            this.tags.push([\"request\", JSON.stringify(event.rawEvent())]);\n\t            this.tag(event);\n\t        }\n\t    }\n\t    get jobRequest(): NDKEvent | undefined {\n\t        const tag = this.tagValue(\"request\");\n\t        if (tag === undefined) {\n\t            return undefined;\n\t        }\n\t        return new NDKEvent(this.ndk, JSON.parse(tag));\n", "    }\n\t}\n"]}
{"filename": "src/events/kinds/dvm/index.ts", "chunked_list": ["export * from \"./NDKDVMRequest\";\n\texport * from \"./NDKTranscriptionDVM\";\n\texport * from \"./NDKDVMJobResult\";\n"]}
{"filename": "src/events/kinds/dvm/NDKTranscriptionDVM.ts", "chunked_list": ["import { NDKKind } from \"..\";\n\timport NDKEvent, { NostrEvent } from \"../..\";\n\timport NDK from \"../../..\";\n\timport { NDKDVMRequest } from \"./NDKDVMRequest\";\n\t/**\n\t * NIP-90\n\t *\n\t * This class creates DVM transcription job types\n\t */\n\texport class NDKTranscriptionDVM extends NDKDVMRequest {\n", "    constructor(ndk: NDK | undefined, event?: NostrEvent) {\n\t        super(ndk, event);\n\t        this.kind = NDKKind.DVMJobRequestTranscription;\n\t    }\n\t    static from(event: NDKEvent) {\n\t        return new NDKTranscriptionDVM(event.ndk, event.rawEvent());\n\t    }\n\t    /**\n\t     * Returns the original source of the transcription\n\t     */\n", "    get url(): string | undefined {\n\t        const inputTags = this.getMatchingTags(\"i\");\n\t        if (inputTags.length !== 1) {\n\t            return undefined;\n\t        }\n\t        return inputTags[0][1];\n\t    }\n\t    /**\n\t     * Getter for the title tag\n\t     */\n", "    get title(): string | undefined {\n\t        return this.tagValue(\"title\");\n\t    }\n\t    /**\n\t     * Setter for the title tag\n\t     */\n\t    set title(value: string | undefined) {\n\t        this.removeTag(\"title\");\n\t        if (value) {\n\t            this.tags.push([\"title\", value]);\n", "        }\n\t    }\n\t    /**\n\t     * Getter for the image tag\n\t     */\n\t    get image(): string | undefined {\n\t        return this.tagValue(\"image\");\n\t    }\n\t    /**\n\t     * Setter for the image tag\n", "     */\n\t    set image(value: string | undefined) {\n\t        this.removeTag(\"image\");\n\t        if (value) {\n\t            this.tags.push([\"image\", value]);\n\t        }\n\t    }\n\t}\n"]}
{"filename": "src/relay/score.ts", "chunked_list": ["// TODO this will probably get more sophisticated\n\texport type NDKRelayScore = number;\n"]}
{"filename": "src/relay/index.ts", "chunked_list": ["import debug from \"debug\";\n\timport EventEmitter from \"eventemitter3\";\n\timport { Relay, relayInit, Sub } from \"nostr-tools\";\n\timport \"websocket-polyfill\";\n\timport NDKEvent, { NDKTag, NostrEvent } from \"../events/index.js\";\n\timport { NDKSubscription } from \"../subscription/index.js\";\n\timport User from \"../user/index.js\";\n\timport { NDKRelayScore } from \"./score.js\";\n\texport enum NDKRelayStatus {\n\t    CONNECTING,\n", "    CONNECTED,\n\t    DISCONNECTING,\n\t    DISCONNECTED,\n\t    RECONNECTING,\n\t    FLAPPING,\n\t}\n\texport interface NDKRelayConnectionStats {\n\t    /**\n\t     * The number of times a connection has been attempted.\n\t     */\n", "    attempts: number;\n\t    /**\n\t     * The number of times a connection has been successfully established.\n\t     */\n\t    success: number;\n\t    /**\n\t     * The durations of the last 100 connections in milliseconds.\n\t     */\n\t    durations: number[];\n\t    /**\n", "     * The time the current connection was established in milliseconds.\n\t     */\n\t    connectedAt?: number;\n\t}\n\t/**\n\t * The NDKRelay class represents a connection to a relay.\n\t *\n\t * @emits NDKRelay#connect\n\t * @emits NDKRelay#disconnect\n\t * @emits NDKRelay#notice\n", " * @emits NDKRelay#event\n\t * @emits NDKRelay#published when an event is published to the relay\n\t * @emits NDKRelay#publish:failed when an event fails to publish to the relay\n\t * @emits NDKRelay#eose\n\t */\n\texport class NDKRelay extends EventEmitter {\n\t    readonly url: string;\n\t    readonly scores: Map<User, NDKRelayScore>;\n\t    private relay: Relay;\n\t    private _status: NDKRelayStatus;\n", "    private connectedAt?: number;\n\t    private _connectionStats: NDKRelayConnectionStats = {\n\t        attempts: 0,\n\t        success: 0,\n\t        durations: [],\n\t    };\n\t    public complaining = false;\n\t    private debug: debug.Debugger;\n\t    /**\n\t     * Active subscriptions this relay is connected to\n", "     */\n\t    public activeSubscriptions = new Set<NDKSubscription>();\n\t    public constructor(url: string) {\n\t        super();\n\t        this.url = url;\n\t        this.relay = relayInit(url);\n\t        this.scores = new Map<User, NDKRelayScore>();\n\t        this._status = NDKRelayStatus.DISCONNECTED;\n\t        this.debug = debug(`ndk:relay:${url}`);\n\t        this.relay.on(\"connect\", () => {\n", "            this.updateConnectionStats.connected();\n\t            this._status = NDKRelayStatus.CONNECTED;\n\t            this.emit(\"connect\");\n\t        });\n\t        this.relay.on(\"disconnect\", () => {\n\t            this.updateConnectionStats.disconnected();\n\t            if (this._status === NDKRelayStatus.CONNECTED) {\n\t                this._status = NDKRelayStatus.DISCONNECTED;\n\t                this.handleReconnection();\n\t            }\n", "            this.emit(\"disconnect\");\n\t        });\n\t        this.relay.on(\"notice\", (notice: string) => this.handleNotice(notice));\n\t    }\n\t    /**\n\t     * Evaluates the connection stats to determine if the relay is flapping.\n\t     */\n\t    private isFlapping(): boolean {\n\t        const durations = this._connectionStats.durations;\n\t        if (durations.length < 10) return false;\n", "        const sum = durations.reduce((a, b) => a + b, 0);\n\t        const avg = sum / durations.length;\n\t        const variance =\n\t            durations\n\t                .map((x) => Math.pow(x - avg, 2))\n\t                .reduce((a, b) => a + b, 0) / durations.length;\n\t        const stdDev = Math.sqrt(variance);\n\t        const isFlapping = stdDev < 1000;\n\t        return isFlapping;\n\t    }\n", "    /**\n\t     * Called when the relay is unexpectedly disconnected.\n\t     */\n\t    private handleReconnection() {\n\t        if (this.isFlapping()) {\n\t            this.emit(\"flapping\", this, this._connectionStats);\n\t            this._status = NDKRelayStatus.FLAPPING;\n\t        }\n\t        if (this.connectedAt && Date.now() - this.connectedAt < 5000) {\n\t            setTimeout(() => this.connect(), 60000);\n", "        } else {\n\t            this.connect();\n\t        }\n\t    }\n\t    get status(): NDKRelayStatus {\n\t        return this._status;\n\t    }\n\t    /**\n\t     * Connects to the relay.\n\t     */\n", "    public async connect(): Promise<void> {\n\t        try {\n\t            this.updateConnectionStats.attempt();\n\t            this._status = NDKRelayStatus.CONNECTING;\n\t            await this.relay.connect();\n\t        } catch (e) {\n\t            this.debug(\"Failed to connect\", e);\n\t            this._status = NDKRelayStatus.DISCONNECTED;\n\t            throw e;\n\t        }\n", "    }\n\t    /**\n\t     * Disconnects from the relay.\n\t     */\n\t    public disconnect(): void {\n\t        this._status = NDKRelayStatus.DISCONNECTING;\n\t        this.relay.close();\n\t    }\n\t    async handleNotice(notice: string) {\n\t        // This is a prototype; if the relay seems to be complaining\n", "        // remove it from relay set selection for a minute.\n\t        if (notice.includes(\"oo many\") || notice.includes(\"aximum\")) {\n\t            this.disconnect();\n\t            // fixme\n\t            setTimeout(() => this.connect(), 2000);\n\t            this.debug(this.relay.url, \"Relay complaining?\", notice);\n\t            // this.complaining = true;\n\t            // setTimeout(() => {\n\t            //     this.complaining = false;\n\t            //     console.log(this.relay.url, 'Reactivate relay');\n", "            // }, 60000);\n\t        }\n\t        this.emit(\"notice\", this, notice);\n\t    }\n\t    /**\n\t     * Subscribes to a subscription.\n\t     */\n\t    public subscribe(subscription: NDKSubscription): Sub {\n\t        const { filters } = subscription;\n\t        const sub = this.relay.sub(filters, {\n", "            id: subscription.subId,\n\t        });\n\t        this.debug(`Subscribed to ${JSON.stringify(filters)}`);\n\t        sub.on(\"event\", (event: NostrEvent) => {\n\t            const e = new NDKEvent(undefined, event);\n\t            e.relay = this;\n\t            subscription.eventReceived(e, this);\n\t        });\n\t        sub.on(\"eose\", () => {\n\t            subscription.eoseReceived(this);\n", "        });\n\t        const unsub = sub.unsub;\n\t        sub.unsub = () => {\n\t            this.debug(`Unsubscribing from ${JSON.stringify(filters)}`);\n\t            this.activeSubscriptions.delete(subscription);\n\t            unsub();\n\t        };\n\t        this.activeSubscriptions.add(subscription);\n\t        subscription.on(\"close\", () => {\n\t            this.activeSubscriptions.delete(subscription);\n", "        });\n\t        return sub;\n\t    }\n\t    /**\n\t     * Publishes an event to the relay with an optional timeout.\n\t     *\n\t     * If the relay is not connected, the event will be published when the relay connects,\n\t     * unless the timeout is reached before the relay connects.\n\t     *\n\t     * @param event The event to publish\n", "     * @param timeoutMs The timeout for the publish operation in milliseconds\n\t     * @returns A promise that resolves when the event has been published or rejects if the operation times out\n\t     */\n\t    public async publish(event: NDKEvent, timeoutMs = 2500): Promise<boolean> {\n\t        if (this.status === NDKRelayStatus.CONNECTED) {\n\t            return this.publishEvent(event, timeoutMs);\n\t        } else {\n\t            this.once(\"connect\", () => {\n\t                this.publishEvent(event, timeoutMs);\n\t            });\n", "            return true;\n\t        }\n\t    }\n\t    private async publishEvent(\n\t        event: NDKEvent,\n\t        timeoutMs?: number\n\t    ): Promise<boolean> {\n\t        const nostrEvent = await event.toNostrEvent();\n\t        const publish = this.relay.publish(nostrEvent as any);\n\t        let publishTimeout: NodeJS.Timeout | number;\n", "        const publishPromise = new Promise<boolean>((resolve, reject) => {\n\t            publish\n\t                .then(() => {\n\t                    clearTimeout(publishTimeout as unknown as NodeJS.Timeout);\n\t                    this.emit(\"published\", event);\n\t                    resolve(true);\n\t                })\n\t                .catch((err) => {\n\t                    clearTimeout(publishTimeout as NodeJS.Timeout);\n\t                    this.debug(\"Publish failed\", err, event.id);\n", "                    this.emit(\"publish:failed\", event, err);\n\t                    reject(err);\n\t                });\n\t        });\n\t        // If no timeout is specified, just return the publish promise\n\t        if (!timeoutMs) {\n\t            return publishPromise;\n\t        }\n\t        // Create a promise that rejects after timeoutMs milliseconds\n\t        const timeoutPromise = new Promise<boolean>((_, reject) => {\n", "            publishTimeout = setTimeout(() => {\n\t                this.debug(\"Publish timed out\", event.rawEvent());\n\t                this.emit(\"publish:failed\", event, \"Timeout\");\n\t                reject(new Error(\"Publish operation timed out\"));\n\t            }, timeoutMs);\n\t        });\n\t        // wait for either the publish operation to complete or the timeout to occur\n\t        return Promise.race([publishPromise, timeoutPromise]);\n\t    }\n\t    /**\n", "     * Called when this relay has responded with an event but\n\t     * wasn't the fastest one.\n\t     * @param timeDiffInMs The time difference in ms between the fastest and this relay in milliseconds\n\t     */\n\t    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t    public scoreSlowerEvent(timeDiffInMs: number): void {\n\t        // TODO\n\t    }\n\t    /**\n\t     * Utility functions to update the connection stats.\n", "     */\n\t    private updateConnectionStats = {\n\t        connected: () => {\n\t            this._connectionStats.success++;\n\t            this._connectionStats.connectedAt = Date.now();\n\t        },\n\t        disconnected: () => {\n\t            if (this._connectionStats.connectedAt) {\n\t                this._connectionStats.durations.push(\n\t                    Date.now() - this._connectionStats.connectedAt\n", "                );\n\t                if (this._connectionStats.durations.length > 100) {\n\t                    this._connectionStats.durations.shift();\n\t                }\n\t            }\n\t            this._connectionStats.connectedAt = undefined;\n\t        },\n\t        attempt: () => {\n\t            this._connectionStats.attempts++;\n\t        },\n", "    };\n\t    /**\n\t     * Returns the connection stats.\n\t     */\n\t    get connectionStats(): NDKRelayConnectionStats {\n\t        return this._connectionStats;\n\t    }\n\t    public tagReference(marker?: string): NDKTag {\n\t        const tag = [\"r\", this.relay.url];\n\t        if (marker) {\n", "            tag.push(marker);\n\t        }\n\t        return tag;\n\t    }\n\t}\n"]}
{"filename": "src/relay/pool/index.ts", "chunked_list": ["import debug from \"debug\";\n\timport EventEmitter from \"eventemitter3\";\n\timport NDK from \"../../index.js\";\n\timport { NDKRelay, NDKRelayStatus } from \"../index.js\";\n\texport type NDKPoolStats = {\n\t    total: number;\n\t    connected: number;\n\t    disconnected: number;\n\t    connecting: number;\n\t};\n", "/**\n\t * Handles connections to all relays. A single pool should be used per NDK instance.\n\t *\n\t * @emit connect - Emitted when all relays in the pool are connected, or when the specified timeout has elapsed, and some relays are connected.\n\t * @emit notice - Emitted when a relay in the pool sends a notice.\n\t * @emit flapping - Emitted when a relay in the pool is flapping.\n\t * @emit relay:connect - Emitted when a relay in the pool connects.\n\t * @emit relay:disconnect - Emitted when a relay in the pool disconnects.\n\t */\n\texport class NDKPool extends EventEmitter {\n", "    public relays = new Map<string, NDKRelay>();\n\t    private debug: debug.Debugger;\n\t    private temporaryRelayTimers = new Map<string, NodeJS.Timeout>();\n\t    public constructor(relayUrls: string[] = [], ndk: NDK) {\n\t        super();\n\t        this.debug = ndk.debug.extend(\"pool\");\n\t        for (const relayUrl of relayUrls) {\n\t            const relay = new NDKRelay(relayUrl);\n\t            this.addRelay(relay, false);\n\t        }\n", "    }\n\t    /**\n\t     * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n\t     * @param relay - The relay to add to the pool.\n\t     * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n\t     */\n\t    public useTemporaryRelay(relay: NDKRelay, removeIfUnusedAfter = 600000) {\n\t        const relayAlreadyInPool = this.relays.has(relay.url);\n\t        // check if the relay is already in the pool\n\t        if (!relayAlreadyInPool) {\n", "            this.addRelay(relay);\n\t        }\n\t        // check if the relay already has a disconnecting timer\n\t        const existingTimer = this.temporaryRelayTimers.get(relay.url);\n\t        if (existingTimer) {\n\t            clearTimeout(existingTimer);\n\t        }\n\t        // add a disconnecting timer only if the relay was not already in the pool\n\t        // or if it had an existing timer\n\t        // this prevents explicit relays from being removed from the pool\n", "        if (!relayAlreadyInPool || existingTimer) {\n\t            // set a timer to remove the relay from the pool if it is not used within the specified time\n\t            const timer = setTimeout(() => {\n\t                this.removeRelay(relay.url);\n\t            }, removeIfUnusedAfter) as unknown as NodeJS.Timeout;\n\t            this.temporaryRelayTimers.set(relay.url, timer);\n\t        }\n\t    }\n\t    /**\n\t     * Adds a relay to the pool.\n", "     *\n\t     * @param relay - The relay to add to the pool.\n\t     * @param connect - Whether or not to connect to the relay.\n\t     */\n\t    public addRelay(relay: NDKRelay, connect = true) {\n\t        const relayUrl = relay.url;\n\t        relay.on(\"notice\", (relay, notice) =>\n\t            this.emit(\"notice\", relay, notice)\n\t        );\n\t        relay.on(\"connect\", () => this.handleRelayConnect(relayUrl));\n", "        relay.on(\"disconnect\", () => this.emit(\"relay:disconnect\", relay));\n\t        relay.on(\"flapping\", () => this.handleFlapping(relay));\n\t        this.relays.set(relayUrl, relay);\n\t        if (connect) {\n\t            relay.connect();\n\t        }\n\t    }\n\t    /**\n\t     * Removes a relay from the pool.\n\t     * @param relayUrl - The URL of the relay to remove.\n", "     * @returns {boolean} True if the relay was removed, false if it was not found.\n\t     */\n\t    public removeRelay(relayUrl: string): boolean {\n\t        const relay = this.relays.get(relayUrl);\n\t        if (relay) {\n\t            relay.disconnect();\n\t            this.relays.delete(relayUrl);\n\t            this.emit(\"relay:disconnect\", relay);\n\t            return true;\n\t        }\n", "        // remove the relay from the temporary relay timers\n\t        const existingTimer = this.temporaryRelayTimers.get(relayUrl);\n\t        if (existingTimer) {\n\t            clearTimeout(existingTimer);\n\t            this.temporaryRelayTimers.delete(relayUrl);\n\t        }\n\t        return false;\n\t    }\n\t    private handleRelayConnect(relayUrl: string) {\n\t        this.debug(`Relay ${relayUrl} connected`);\n", "        this.emit(\"relay:connect\", this.relays.get(relayUrl));\n\t        if (this.stats().connected === this.relays.size) {\n\t            this.emit(\"connect\");\n\t        }\n\t    }\n\t    /**\n\t     * Attempts to establish a connection to each relay in the pool.\n\t     *\n\t     * @async\n\t     * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.\n", "     * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.\n\t     * @throws {Error} If any of the connection attempts result in an error or timeout.\n\t     */\n\t    public async connect(timeoutMs?: number): Promise<void> {\n\t        const promises: Promise<void>[] = [];\n\t        this.debug(\n\t            `Connecting to ${this.relays.size} relays${\n\t                timeoutMs ? `, timeout ${timeoutMs}...` : \"\"\n\t            }`\n\t        );\n", "        for (const relay of this.relays.values()) {\n\t            if (timeoutMs) {\n\t                const timeoutPromise = new Promise<void>((_, reject) => {\n\t                    setTimeout(\n\t                        () => reject(`Timed out after ${timeoutMs}ms`),\n\t                        timeoutMs\n\t                    );\n\t                });\n\t                promises.push(\n\t                    Promise.race([relay.connect(), timeoutPromise]).catch(\n", "                        (e) => {\n\t                            this.debug(\n\t                                `Failed to connect to relay ${relay.url}: ${e}`\n\t                            );\n\t                        }\n\t                    )\n\t                );\n\t            } else {\n\t                promises.push(relay.connect());\n\t            }\n", "        }\n\t        // If we are running with a timeout, check if we need to emit a `connect` event\n\t        // in case some, but not all, relays were connected\n\t        if (timeoutMs) {\n\t            setTimeout(() => {\n\t                const allConnected =\n\t                    this.stats().connected === this.relays.size;\n\t                const someConnected = this.stats().connected > 0;\n\t                if (!allConnected && someConnected) {\n\t                    this.emit(\"connect\");\n", "                }\n\t            }, timeoutMs);\n\t        }\n\t        await Promise.all(promises);\n\t    }\n\t    private handleFlapping(relay: NDKRelay) {\n\t        this.debug(`Relay ${relay.url} is flapping`);\n\t        // TODO: Be smarter about this.\n\t        this.relays.delete(relay.url);\n\t        this.emit(\"flapping\", relay);\n", "    }\n\t    public size(): number {\n\t        return this.relays.size;\n\t    }\n\t    /**\n\t     * Returns the status of each relay in the pool.\n\t     * @returns {NDKPoolStats} An object containing the number of relays in each status.\n\t     */\n\t    public stats(): NDKPoolStats {\n\t        const stats: NDKPoolStats = {\n", "            total: 0,\n\t            connected: 0,\n\t            disconnected: 0,\n\t            connecting: 0,\n\t        };\n\t        for (const relay of this.relays.values()) {\n\t            stats.total++;\n\t            if (relay.status === NDKRelayStatus.CONNECTED) {\n\t                stats.connected++;\n\t            } else if (relay.status === NDKRelayStatus.DISCONNECTED) {\n", "                stats.disconnected++;\n\t            } else if (relay.status === NDKRelayStatus.CONNECTING) {\n\t                stats.connecting++;\n\t            }\n\t        }\n\t        return stats;\n\t    }\n\t    public connectedRelays(): NDKRelay[] {\n\t        return Array.from(this.relays.values()).filter(\n\t            (relay) => relay.status === NDKRelayStatus.CONNECTED\n", "        );\n\t    }\n\t    /**\n\t     * Get a list of all relay urls in the pool.\n\t     */\n\t    public urls(): string[] {\n\t        return Array.from(this.relays.keys());\n\t    }\n\t}\n"]}
{"filename": "src/relay/sets/utils.ts", "chunked_list": ["import { NDKPool } from \"../../relay/pool/index.js\";\n\timport { NDKRelaySet } from \"../../relay/sets/index.js\";\n\t/**\n\t * If the provided relay set does not include connected relays in the pool\n\t * the relaySet will have the connected relays added to it.\n\t */\n\texport function correctRelaySet(\n\t    relaySet: NDKRelaySet,\n\t    pool: NDKPool\n\t): NDKRelaySet {\n", "    const connectedRelays = pool.connectedRelays();\n\t    const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {\n\t        return connectedRelays.map((r) => r.url).includes(relay.url);\n\t    });\n\t    if (!includesConnectedRelay) {\n\t        // Add connected relays to the relay set\n\t        for (const relay of connectedRelays) {\n\t            relaySet.addRelay(relay);\n\t        }\n\t    }\n", "    // if connected relays is empty (such us when we're first starting, add all relays)\n\t    if (connectedRelays.length === 0) {\n\t        for (const relay of pool.relays.values()) {\n\t            relaySet.addRelay(relay);\n\t        }\n\t    }\n\t    return relaySet;\n\t}\n"]}
{"filename": "src/relay/sets/index.ts", "chunked_list": ["import { sha256 } from \"@noble/hashes/sha256\";\n\timport { bytesToHex } from \"@noble/hashes/utils\";\n\timport NDKEvent from \"../../events/index.js\";\n\timport type NDK from \"../../index.js\";\n\timport {\n\t    NDKSubscription,\n\t    NDKSubscriptionGroup,\n\t} from \"../../subscription/index.js\";\n\timport { NDKRelay, NDKRelayStatus } from \"../index.js\";\n\t/**\n", " * A relay set is a group of relays. This grouping can be short-living, for a single\n\t * REQ or can be long-lasting, for example for the explicit relay list the user\n\t * has specified.\n\t *\n\t * Requests to relays should be sent through this interface.\n\t */\n\texport class NDKRelaySet {\n\t    readonly relays: Set<NDKRelay>;\n\t    private debug: debug.Debugger;\n\t    private ndk: NDK;\n", "    public constructor(relays: Set<NDKRelay>, ndk: NDK) {\n\t        this.relays = relays;\n\t        this.ndk = ndk;\n\t        this.debug = ndk.debug.extend(\"relayset\");\n\t    }\n\t    /**\n\t     * Adds a relay to this set.\n\t     */\n\t    public addRelay(relay: NDKRelay) {\n\t        this.relays.add(relay);\n", "    }\n\t    /**\n\t     * Creates a relay set from a list of relay URLs.\n\t     *\n\t     * This is useful for testing in development to pass a local relay\n\t     * to publish methods.\n\t     *\n\t     * @param relayUrls - list of relay URLs to include in this set\n\t     * @param ndk\n\t     * @returns NDKRelaySet\n", "     */\n\t    static fromRelayUrls(relayUrls: string[], ndk: NDK): NDKRelaySet {\n\t        const relays = new Set<NDKRelay>();\n\t        for (const url of relayUrls) {\n\t            const relay = ndk.pool.relays.get(url);\n\t            if (relay) {\n\t                relays.add(relay);\n\t            }\n\t        }\n\t        return new NDKRelaySet(new Set(relays), ndk);\n", "    }\n\t    private subscribeOnRelay(relay: NDKRelay, subscription: NDKSubscription) {\n\t        const sub = relay.subscribe(subscription);\n\t        subscription.relaySubscriptions.set(relay, sub);\n\t    }\n\t    /**\n\t     * Calculates an ID of this specific combination of relays.\n\t     */\n\t    public getId() {\n\t        const urls = Array.from(this.relays).map((r) => r.url);\n", "        const urlString = urls.sort().join(\",\");\n\t        return bytesToHex(sha256(urlString));\n\t    }\n\t    /**\n\t     * Add a subscription to this relay set\n\t     */\n\t    public subscribe(subscription: NDKSubscription): NDKSubscription {\n\t        const subGroupableId = subscription.groupableId();\n\t        const groupableId = `${this.getId()}:${subGroupableId}`;\n\t        if (!subGroupableId) {\n", "            this.executeSubscription(subscription);\n\t            return subscription;\n\t        }\n\t        const delayedSubscription =\n\t            this.ndk.delayedSubscriptions.get(groupableId);\n\t        if (delayedSubscription) {\n\t            delayedSubscription.push(subscription);\n\t        } else {\n\t            setTimeout(() => {\n\t                this.executeDelayedSubscription(groupableId);\n", "            }, subscription.opts.groupableDelay);\n\t            this.ndk.delayedSubscriptions.set(groupableId, [subscription]);\n\t        }\n\t        return subscription;\n\t    }\n\t    private executeDelayedSubscription(groupableId: string) {\n\t        const subscriptions = this.ndk.delayedSubscriptions.get(groupableId);\n\t        this.ndk.delayedSubscriptions.delete(groupableId);\n\t        if (subscriptions) {\n\t            if (subscriptions.length > 1) {\n", "                this.executeSubscriptions(subscriptions);\n\t            } else {\n\t                this.executeSubscription(subscriptions[0]);\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * This function takes a similar group of subscriptions, merges the filters\n\t     * and sends a single subscription to the relay.\n\t     */\n", "    private executeSubscriptions(subscriptions: NDKSubscription[]) {\n\t        const ndk = subscriptions[0].ndk;\n\t        const subGroup = new NDKSubscriptionGroup(ndk, subscriptions);\n\t        this.executeSubscription(subGroup);\n\t    }\n\t    private executeSubscription(\n\t        subscription: NDKSubscription\n\t    ): NDKSubscription {\n\t        this.debug(\"subscribing\", { filters: subscription.filters });\n\t        for (const relay of this.relays) {\n", "            if (relay.status === NDKRelayStatus.CONNECTED) {\n\t                // If the relay is already connected, subscribe immediately\n\t                this.subscribeOnRelay(relay, subscription);\n\t            } else {\n\t                // If the relay is not connected, add a one-time listener to wait for the 'connected' event\n\t                const connectedListener = () => {\n\t                    this.debug(\n\t                        \"new relay coming online for active subscription\",\n\t                        {\n\t                            relay: relay.url,\n", "                            filters: subscription.filters,\n\t                        }\n\t                    );\n\t                    this.subscribeOnRelay(relay, subscription);\n\t                };\n\t                relay.once(\"connect\", connectedListener);\n\t                // Add a one-time listener to remove the connectedListener when the subscription stops\n\t                subscription.once(\"close\", () => {\n\t                    relay.removeListener(\"connect\", connectedListener);\n\t                });\n", "            }\n\t        }\n\t        return subscription;\n\t    }\n\t    /**\n\t     * Publish an event to all relays in this set. Returns the number of relays that have received the event.\n\t     * @param event\n\t     * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation\n\t     * @returns A set where the event was successfully published to\n\t     */\n", "    public async publish(\n\t        event: NDKEvent,\n\t        timeoutMs?: number\n\t    ): Promise<Set<NDKRelay>> {\n\t        const publishedToRelays: Set<NDKRelay> = new Set();\n\t        // go through each relay and publish the event\n\t        const promises: Promise<void>[] = Array.from(this.relays).map(\n\t            (relay: NDKRelay) => {\n\t                return new Promise<void>((resolve) => {\n\t                    relay\n", "                        .publish(event, timeoutMs)\n\t                        .then(() => {\n\t                            publishedToRelays.add(relay);\n\t                            resolve();\n\t                        })\n\t                        .catch((err) => {\n\t                            this.debug(\"error publishing to relay\", {\n\t                                relay: relay.url,\n\t                                err,\n\t                            });\n", "                            resolve();\n\t                        });\n\t                });\n\t            }\n\t        );\n\t        await Promise.all(promises);\n\t        if (publishedToRelays.size === 0) {\n\t            throw new Error(\"No relay was able to receive the event\");\n\t        }\n\t        return publishedToRelays;\n", "    }\n\t    public size(): number {\n\t        return this.relays.size;\n\t    }\n\t}\n"]}
{"filename": "src/relay/sets/calculate.ts", "chunked_list": ["import Event from \"../../events/index.js\";\n\timport NDK from \"../../index.js\";\n\timport { NDKFilter } from \"../../subscription/index.js\";\n\timport { NDKRelay } from \"../index.js\";\n\timport { NDKRelaySet } from \"./index.js\";\n\t/**\n\t * Creates a NDKRelaySet for the specified event.\n\t * TODO: account for relays where tagged pubkeys or hashtags\n\t * tend to write to.\n\t * @param ndk {NDK}\n", " * @param event {Event}\n\t * @returns Promise<NDKRelaySet>\n\t */\n\texport function calculateRelaySetFromEvent(\n\t    ndk: NDK,\n\t    event: Event\n\t): NDKRelaySet {\n\t    const relays: Set<NDKRelay> = new Set();\n\t    ndk.pool?.relays.forEach((relay) => relays.add(relay));\n\t    return new NDKRelaySet(relays, ndk);\n", "}\n\t/**\n\t * Creates a NDKRelaySet for the specified filter\n\t * @param ndk\n\t * @param filter\n\t * @returns Promise<NDKRelaySet>\n\t */\n\texport function calculateRelaySetFromFilter(\n\t    ndk: NDK,\n\t    filter: NDKFilter\n", "): NDKRelaySet {\n\t    const relays: Set<NDKRelay> = new Set();\n\t    ndk.pool?.relays.forEach((relay) => {\n\t        if (!relay.complaining) {\n\t            relays.add(relay);\n\t        } else {\n\t            ndk.debug(`Relay ${relay.url} is complaining, not adding to set`);\n\t        }\n\t    });\n\t    return new NDKRelaySet(relays, ndk);\n", "}\n\t/**\n\t * Calculates a number of RelaySets for each filter.\n\t * @param ndk\n\t * @param filters\n\t */\n\texport function calculateRelaySetsFromFilters(\n\t    ndk: NDK,\n\t    filters: NDKFilter[]\n\t): Map<NDKFilter, NDKRelaySet> {\n", "    const sets: Map<NDKFilter, NDKRelaySet> = new Map();\n\t    filters.forEach((filter) => {\n\t        const set = calculateRelaySetFromFilter(ndk, filter);\n\t        sets.set(filter, set);\n\t    });\n\t    return sets;\n\t}\n"]}
{"filename": "src/user/follows.ts", "chunked_list": ["import { nip19 } from \"nostr-tools\";\n\timport NDKUser from \"./index.js\";\n\texport async function follows(this: NDKUser): Promise<Set<NDKUser>> {\n\t    if (!this.ndk) throw new Error(\"NDK not set\");\n\t    const contactListEvents = await this.ndk.fetchEvents({\n\t        kinds: [3],\n\t        authors: [this.hexpubkey()],\n\t    });\n\t    if (contactListEvents) {\n\t        const npubs = new Set<string>();\n", "        contactListEvents.forEach((event) => {\n\t            event.tags.forEach((tag: string[]) => {\n\t                if (tag[0] === \"p\") {\n\t                    try {\n\t                        const npub = nip19.npubEncode(tag[1]);\n\t                        npubs.add(npub);\n\t                    } catch (e) {\n\t                        /* empty */\n\t                    }\n\t                }\n", "            });\n\t        });\n\t        return [...npubs].reduce((acc: Set<NDKUser>, npub: string) => {\n\t            const user = new NDKUser({ npub });\n\t            user.ndk = this.ndk;\n\t            acc.add(user);\n\t            return acc;\n\t        }, new Set<NDKUser>());\n\t    }\n\t    return new Set<NDKUser>();\n", "}\n"]}
{"filename": "src/user/index.test.ts", "chunked_list": ["import { nip19 } from \"nostr-tools\";\n\timport NDK, { NDKEvent, NDKSubscription } from \"../index.js\";\n\timport NDKUser, { NDKUserParams } from \"./index.js\";\n\tjest.mock(\"nostr-tools\", () => ({\n\t    nip05: {\n\t        queryProfile: jest.fn(),\n\t    },\n\t    nip19: {\n\t        npubEncode: jest.fn(),\n\t        decode: jest.fn(),\n", "    },\n\t}));\n\tdescribe(\"NDKUser\", () => {\n\t    beforeEach(() => {\n\t        jest.clearAllMocks();\n\t    });\n\t    describe(\"constructor\", () => {\n\t        it(\"sets npub from provided npub\", () => {\n\t            const opts: NDKUserParams = {\n\t                npub: \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\",\n", "            };\n\t            const user = new NDKUser(opts);\n\t            expect(user.npub).toEqual(\n\t                \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\"\n\t            );\n\t        });\n\t        it(\"sets npub from provided hexpubkey\", () => {\n\t            const opts: NDKUserParams = {\n\t                hexpubkey:\n\t                    \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n", "            };\n\t            (nip19.npubEncode as jest.Mock).mockReturnValue(\"encoded_npub\");\n\t            const user = new NDKUser(opts);\n\t            expect(nip19.npubEncode).toHaveBeenCalledWith(\n\t                \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\"\n\t            );\n\t            expect(user.npub).toEqual(\"encoded_npub\");\n\t        });\n\t        it(\"sets relayUrls from provided relayUrls\", () => {\n\t            const opts: NDKUserParams = {\n", "                relayUrls: [\"url1\", \"url2\"],\n\t            };\n\t            const user = new NDKUser(opts);\n\t            expect(user.relayUrls).toEqual([\"url1\", \"url2\"]);\n\t        });\n\t    });\n\t    describe(\"hexpubkey\", () => {\n\t        it(\"returns the decoded hexpubkey\", () => {\n\t            const user = new NDKUser({\n\t                npub: \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\",\n", "            });\n\t            (nip19.decode as jest.Mock).mockReturnValue({\n\t                data: \"decoded_hexpubkey\",\n\t            });\n\t            const hexpubkey = user.hexpubkey();\n\t            expect(nip19.decode).toHaveBeenCalledWith(\n\t                \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\"\n\t            );\n\t            expect(hexpubkey).toEqual(\"decoded_hexpubkey\");\n\t        });\n", "    });\n\t    describe(\"fetchProfile\", () => {\n\t        const ndk = new NDK();\n\t        let newEvent: NDKEvent;\n\t        let oldEvent: NDKEvent;\n\t        const user = new NDKUser({\n\t            npub: \"npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft\",\n\t        });\n\t        user.ndk = ndk;\n\t        (nip19.decode as jest.Mock).mockReturnValue({\n", "            data: \"decoded_hexpubkey\",\n\t        });\n\t        const pubkey = user.hexpubkey();\n\t        it(\"Returns updated fields\", async () => {\n\t            newEvent = new NDKEvent(ndk, {\n\t                kind: 0,\n\t                pubkey: pubkey,\n\t                tags: [],\n\t                created_at: Date.now() / 1000 - 3600,\n\t                content: JSON.stringify({\n", "                    displayName: \"JeffG\",\n\t                    name: \"Jeff\",\n\t                    image: \"https://image.url\",\n\t                    banner: \"https://banner.url\",\n\t                    bio: \"Some bio info\",\n\t                    nip05: \"_@jeffg.fyi\",\n\t                    lud06: \"lud06value\",\n\t                    lud16: \"lud16value\",\n\t                    about: \"About jeff\",\n\t                    zapService: \"Zapservice details\",\n", "                }),\n\t            });\n\t            oldEvent = new NDKEvent(ndk, {\n\t                kind: 0,\n\t                pubkey: pubkey,\n\t                tags: [],\n\t                created_at: Date.now() / 1000 - 7200,\n\t                content: JSON.stringify({\n\t                    displayName: \"JeffG_OLD\",\n\t                    name: \"Jeff_OLD\",\n", "                    image: \"https://image.url.old\",\n\t                    banner: \"https://banner.url.old\",\n\t                    bio: \"Some OLD bio info\",\n\t                    nip05: \"OLD@jeffg.fyi\",\n\t                    lud06: \"lud06value OLD\",\n\t                    lud16: \"lud16value OLD\",\n\t                    about: \"About jeff OLD\",\n\t                    zapService: \"Zapservice details OLD\",\n\t                }),\n\t            });\n", "            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n\t                const sub = new NDKSubscription(ndk, filter, opts);\n\t                setTimeout(() => {\n\t                    sub.emit(\"event\", newEvent);\n\t                    sub.emit(\"event\", oldEvent);\n\t                    sub.emit(\"eose\");\n\t                }, 100);\n\t                return sub;\n\t            });\n\t            await user.fetchProfile();\n", "            expect(user.profile?.displayName).toEqual(\"JeffG\");\n\t            expect(user.profile?.name).toEqual(\"Jeff\");\n\t            expect(user.profile?.image).toEqual(\"https://image.url\");\n\t            expect(user.profile?.banner).toEqual(\"https://banner.url\");\n\t            expect(user.profile?.bio).toEqual(\"Some bio info\");\n\t            expect(user.profile?.nip05).toEqual(\"_@jeffg.fyi\");\n\t            expect(user.profile?.lud06).toEqual(\"lud06value\");\n\t            expect(user.profile?.lud16).toEqual(\"lud16value\");\n\t            expect(user.profile?.about).toEqual(\"About jeff\");\n\t            expect(user.profile?.zapService).toEqual(\"Zapservice details\");\n", "        });\n\t        // Both \"display_name\" and \"displayName\" are set to \"displayName\" field in the user profile\n\t        it(\"Display name is set properly\", async () => {\n\t            newEvent = new NDKEvent(ndk, {\n\t                kind: 0,\n\t                pubkey: pubkey,\n\t                tags: [],\n\t                created_at: Date.now() / 1000 - 3600,\n\t                content: JSON.stringify({\n\t                    displayName: \"JeffG\",\n", "                    display_name: \"James\",\n\t                }),\n\t            });\n\t            oldEvent = new NDKEvent(ndk, {\n\t                kind: 0,\n\t                pubkey: pubkey,\n\t                tags: [],\n\t                created_at: Date.now() / 1000 - 7200,\n\t                content: JSON.stringify({\n\t                    displayName: \"Bob\",\n", "                }),\n\t            });\n\t            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n\t                const sub = new NDKSubscription(ndk, filter, opts);\n\t                setTimeout(() => {\n\t                    sub.emit(\"event\", newEvent);\n\t                    sub.emit(\"event\", oldEvent);\n\t                    sub.emit(\"eose\");\n\t                }, 100);\n\t                return sub;\n", "            });\n\t            await user.fetchProfile();\n\t            expect(user.profile?.displayName).toEqual(\"JeffG\");\n\t        });\n\t        // Both \"image\" and \"picture\" are set to the \"image\" field in the user profile\n\t        it(\"Image is set properly\", async () => {\n\t            newEvent = new NDKEvent(ndk, {\n\t                kind: 0,\n\t                pubkey: pubkey,\n\t                tags: [],\n", "                created_at: Date.now() / 1000 - 3600,\n\t                content: JSON.stringify({\n\t                    picture: \"https://set-from-picture-field.url\",\n\t                }),\n\t            });\n\t            oldEvent = new NDKEvent(ndk, {\n\t                kind: 0,\n\t                pubkey: pubkey,\n\t                tags: [],\n\t                created_at: Date.now() / 1000 - 7200,\n", "                content: JSON.stringify({\n\t                    image: \"https://set-from-image-field.url\",\n\t                }),\n\t            });\n\t            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n\t                const sub = new NDKSubscription(ndk, filter, opts);\n\t                setTimeout(() => {\n\t                    sub.emit(\"event\", newEvent);\n\t                    sub.emit(\"event\", oldEvent);\n\t                    sub.emit(\"eose\");\n", "                }, 100);\n\t                return sub;\n\t            });\n\t            await user.fetchProfile();\n\t            expect(user.profile?.image).toEqual(\n\t                \"https://set-from-picture-field.url\"\n\t            );\n\t        });\n\t        it(\"Allows for arbitrary values to be set on user profiles\", async () => {\n\t            newEvent = new NDKEvent(ndk, {\n", "                kind: 0,\n\t                pubkey: pubkey,\n\t                tags: [],\n\t                created_at: Date.now() / 1000 - 3600,\n\t                content: JSON.stringify({\n\t                    customField: \"custom NEW\",\n\t                }),\n\t            });\n\t            oldEvent = new NDKEvent(ndk, {\n\t                kind: 0,\n", "                pubkey: pubkey,\n\t                tags: [],\n\t                created_at: Date.now() / 1000 - 7200,\n\t                content: JSON.stringify({\n\t                    customField: \"custom OLD\",\n\t                }),\n\t            });\n\t            ndk.subscribe = jest.fn((filter, opts?): NDKSubscription => {\n\t                const sub = new NDKSubscription(ndk, filter, opts);\n\t                setTimeout(() => {\n", "                    sub.emit(\"event\", newEvent);\n\t                    sub.emit(\"event\", oldEvent);\n\t                    sub.emit(\"eose\");\n\t                }, 100);\n\t                return sub;\n\t            });\n\t            await user.fetchProfile();\n\t            expect(user.profile?.customField).toEqual(\"custom NEW\");\n\t        });\n\t    });\n", "});\n"]}
{"filename": "src/user/follows.test.ts", "chunked_list": ["import NDKEvent from \"../events/index\";\n\timport NDK from \"../index\";\n\timport NDKUser from \"./index\";\n\tjest.mock(\"../index.js\", () => {\n\t    return {\n\t        __esModule: true,\n\t        default: jest.fn().mockImplementation(() => {\n\t            return {\n\t                fetchEvents: jest.fn(),\n\t            };\n", "        }),\n\t    };\n\t});\n\tdescribe(\"follows\", () => {\n\t    it(\"skips tags on the contact list with invalid pubkeys\", async () => {\n\t        const ndk = new NDK();\n\t        const user = new NDKUser({\n\t            hexpubkey:\n\t                \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n\t        });\n", "        user.ndk = ndk;\n\t        const followedHexpubkey =\n\t            \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\";\n\t        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t        (user.ndk!.fetchEvents as jest.Mock).mockImplementation(() => {\n\t            const e = new NDKEvent(ndk);\n\t            e.tags = [[\"p\", \"invalid-pubkey\"]];\n\t            e.tags = [[\"p\", followedHexpubkey]];\n\t            return new Set([e]);\n\t        });\n", "        const followedUsers = await user.follows();\n\t        expect(followedUsers.size).toBe(1);\n\t        for (const followedUser of followedUsers) {\n\t            expect(followedUser).toBeInstanceOf(NDKUser);\n\t            expect(followedUser.hexpubkey()).toBe(followedHexpubkey);\n\t            expect(followedUser.ndk).toBe(user.ndk);\n\t        }\n\t    });\n\t    it(\"dedupes followed users\", async () => {\n\t        const ndk = new NDK();\n", "        const user = new NDKUser({\n\t            hexpubkey:\n\t                \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\",\n\t        });\n\t        user.ndk = ndk;\n\t        const followedHexpubkey =\n\t            \"fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52\";\n\t        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t        (user.ndk!.fetchEvents as jest.Mock).mockImplementation(() => {\n\t            const e = new NDKEvent(ndk);\n", "            e.tags = [[\"p\", \"invalid-pubkey\"]];\n\t            e.tags = [[\"p\", followedHexpubkey]];\n\t            e.tags = [[\"p\", followedHexpubkey]];\n\t            return new Set([e]);\n\t        });\n\t        const followedUsers = await user.follows();\n\t        expect(followedUsers.size).toBe(1);\n\t        for (const followedUser of followedUsers) {\n\t            expect(followedUser).toBeInstanceOf(NDKUser);\n\t            expect(followedUser.hexpubkey()).toBe(followedHexpubkey);\n", "            expect(followedUser.ndk).toBe(user.ndk);\n\t        }\n\t    });\n\t});\n"]}
{"filename": "src/user/index.ts", "chunked_list": ["import { nip05, nip19 } from \"nostr-tools\";\n\timport { default as NDKEvent, NDKTag, NostrEvent } from \"../events/index.js\";\n\timport NDK, { NDKKind } from \"../index.js\";\n\timport {\n\t    NDKSubscriptionCacheUsage,\n\t    NDKSubscriptionOptions,\n\t} from \"../subscription/index.js\";\n\timport { follows } from \"./follows.js\";\n\timport { NDKUserProfile, mergeEvent } from \"./profile\";\n\texport interface NDKUserParams {\n", "    npub?: string;\n\t    hexpubkey?: string;\n\t    nip05?: string;\n\t    relayUrls?: string[];\n\t}\n\t/**\n\t * Represents a pubkey.\n\t */\n\texport default class NDKUser {\n\t    public ndk: NDK | undefined;\n", "    public profile?: NDKUserProfile;\n\t    readonly npub: string = \"\";\n\t    readonly relayUrls: string[] = [];\n\t    public constructor(opts: NDKUserParams) {\n\t        if (opts.npub) this.npub = opts.npub;\n\t        if (opts.hexpubkey) {\n\t            this.npub = nip19.npubEncode(opts.hexpubkey);\n\t        }\n\t        if (opts.relayUrls) {\n\t            this.relayUrls = opts.relayUrls;\n", "        }\n\t    }\n\t    /**\n\t     * Instantiate an NDKUser from a NIP-05 string\n\t     * @param nip05Id {string} The user's NIP-05\n\t     * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.\n\t     */\n\t    static async fromNip05(nip05Id: string): Promise<NDKUser | undefined> {\n\t        const profile = await nip05.queryProfile(nip05Id);\n\t        if (profile) {\n", "            return new NDKUser({\n\t                hexpubkey: profile.pubkey,\n\t                relayUrls: profile.relays,\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * Get the hexpubkey for a user\n\t     * @returns {string} The user's hexpubkey\n\t     */\n", "    public hexpubkey(): string {\n\t        return nip19.decode(this.npub).data as string;\n\t    }\n\t    /**\n\t     * Fetch a user's kind 0 metadata events and merge the events in a single up-to-date profile\n\t     * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions\n\t     * @returns {Promise<Set<NDKEvent>>} A set of all NDKEvents events returned for the given user\n\t     */\n\t    public async fetchProfile(\n\t        opts?: NDKSubscriptionOptions\n", "    ): Promise<Set<NDKEvent> | null> {\n\t        if (!this.ndk) throw new Error(\"NDK not set\");\n\t        if (!this.profile) this.profile = {};\n\t        let setMetadataEvents: Set<NDKEvent> | null = null;\n\t        // if no options have been set and we have a cache, try to load from cache with no grouping\n\t        // This is done in favour of simply using NDKSubscriptionCacheUsage.CACHE_FIRST since\n\t        // we want to avoid depending on the grouping, arguably, all queries should go through this\n\t        // type of behavior when we have a locking cache\n\t        if (\n\t            !opts && // if no options have been set\n", "            this.ndk.cacheAdapter && // and we have a cache\n\t            this.ndk.cacheAdapter.locking // and the cache identifies itself as fast 😂\n\t        ) {\n\t            setMetadataEvents = await this.ndk.fetchEvents(\n\t                {\n\t                    kinds: [0],\n\t                    authors: [this.hexpubkey()],\n\t                },\n\t                {\n\t                    cacheUsage: NDKSubscriptionCacheUsage.ONLY_CACHE,\n", "                    closeOnEose: true,\n\t                    groupable: false,\n\t                }\n\t            );\n\t            opts = {\n\t                cacheUsage: NDKSubscriptionCacheUsage.ONLY_RELAY,\n\t                closeOnEose: true,\n\t            };\n\t        }\n\t        if (!setMetadataEvents || setMetadataEvents.size === 0) {\n", "            setMetadataEvents = await this.ndk.fetchEvents(\n\t                {\n\t                    kinds: [0],\n\t                    authors: [this.hexpubkey()],\n\t                },\n\t                opts\n\t            );\n\t        }\n\t        if (setMetadataEvents) {\n\t            // sort setMetadataEvents by created_at in ascending order\n", "            const sortedSetMetadataEvents = Array.from(setMetadataEvents).sort(\n\t                (a, b) => (a.created_at as number) - (b.created_at as number)\n\t            );\n\t            sortedSetMetadataEvents.forEach((event) => {\n\t                try {\n\t                    this.profile = mergeEvent(event, this.profile!);\n\t                } catch (e) {}\n\t            });\n\t        }\n\t        return setMetadataEvents;\n", "    }\n\t    /**\n\t     * Returns a set of users that this user follows.\n\t     */\n\t    public follows = follows.bind(this);\n\t    /**\n\t     * Returns a set of relay list events for a user.\n\t     * @returns {Promise<Set<NDKEvent>>} A set of NDKEvents returned for the given user.\n\t     */\n\t    public async relayList(): Promise<Set<NDKEvent>> {\n", "        if (!this.ndk) throw new Error(\"NDK not set\");\n\t        const relayListEvents = await this.ndk.fetchEvents({\n\t            kinds: [10002],\n\t            authors: [this.hexpubkey()],\n\t        });\n\t        if (relayListEvents) {\n\t            return relayListEvents;\n\t        }\n\t        return new Set<NDKEvent>();\n\t    }\n", "    /**\n\t     * Get the tag that can be used to reference this user in an event\n\t     * @returns {NDKTag} an NDKTag\n\t     */\n\t    public tagReference(): NDKTag {\n\t        return [\"p\", this.hexpubkey()];\n\t    }\n\t    /**\n\t     * Publishes the current profile.\n\t     */\n", "    public async publish() {\n\t        if (!this.ndk) throw new Error(\"No NDK instance found\");\n\t        this.ndk.assertSigner();\n\t        const event = new NDKEvent(this.ndk, {\n\t            kind: 0,\n\t            content: JSON.stringify(this.profile),\n\t        } as NostrEvent);\n\t        await event.publish();\n\t    }\n\t    /**\n", "     * Add a follow to this user's contact list\n\t     *\n\t     * @param newFollow {NDKUser} The user to follow\n\t     * @param currentFollowList {Set<NDKUser>} The current follow list\n\t     * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists\n\t     */\n\t    public async follow(\n\t        newFollow: NDKUser,\n\t        currentFollowList?: Set<NDKUser>\n\t    ): Promise<boolean> {\n", "        if (!this.ndk) throw new Error(\"No NDK instance found\");\n\t        this.ndk.assertSigner();\n\t        if (!currentFollowList) {\n\t            currentFollowList = await this.follows();\n\t        }\n\t        if (currentFollowList.has(newFollow)) {\n\t            return false;\n\t        }\n\t        currentFollowList.add(newFollow);\n\t        const event = new NDKEvent(this.ndk, {\n", "            kind: NDKKind.Contacts,\n\t        } as NostrEvent);\n\t        // This is a horrible hack and I need to fix it\n\t        for (const follow of currentFollowList) {\n\t            event.tag(follow);\n\t        }\n\t        await event.publish();\n\t        return true;\n\t    }\n\t}\n"]}
{"filename": "src/user/profile.ts", "chunked_list": ["import NDKEvent from \"../events/index.js\";\n\t/**\n\t * NDKUserProfile represents a user's kind 0 profile metadata\n\t */\n\texport type NDKUserProfile = {\n\t    [key: string]: string | undefined; // allows custom fields\n\t    name?: string;\n\t    displayName?: string;\n\t    image?: string;\n\t    banner?: string;\n", "    bio?: string;\n\t    nip05?: string;\n\t    lud06?: string;\n\t    lud16?: string;\n\t    about?: string;\n\t    zapService?: string;\n\t    website?: string;\n\t};\n\texport function mergeEvent(\n\t    event: NDKEvent,\n", "    profile: NDKUserProfile\n\t): NDKUserProfile {\n\t    const payload = JSON.parse(event.content);\n\t    Object.keys(payload).forEach((key) => {\n\t        switch (key) {\n\t            case \"name\":\n\t                profile.name = payload.name;\n\t                break;\n\t            case \"display_name\":\n\t            case \"displayName\":\n", "                profile.displayName =\n\t                    payload.displayName || payload.display_name;\n\t                break;\n\t            case \"image\":\n\t            case \"picture\":\n\t                profile.image = payload.image || payload.picture;\n\t                break;\n\t            case \"banner\":\n\t                profile.banner = payload.banner;\n\t                break;\n", "            case \"bio\":\n\t                profile.bio = payload.bio;\n\t                break;\n\t            case \"nip05\":\n\t                profile.nip05 = payload.nip05;\n\t                break;\n\t            case \"lud06\":\n\t                profile.lud06 = payload.lud06;\n\t                break;\n\t            case \"lud16\":\n", "                profile.lud16 = payload.lud16;\n\t                break;\n\t            case \"about\":\n\t                profile.about = payload.about;\n\t                break;\n\t            case \"zapService\":\n\t                profile.zapService = payload.zapService;\n\t                break;\n\t            case \"website\":\n\t                profile.website = payload.website;\n", "                break;\n\t            default:\n\t                profile[key] = payload[key];\n\t                break;\n\t        }\n\t    });\n\t    return profile;\n\t}\n"]}
{"filename": "src/subscription/utils.ts", "chunked_list": ["import { NDKFilter, NDKSubscription } from \"./index.js\";\n\t/**\n\t * Checks if a subscription is fully guaranteed to have been filled.\n\t *\n\t * This is useful to determine if a cache hit fully satisfies a subscription.\n\t *\n\t * @param subscription\n\t * @returns\n\t */\n\texport function queryFullyFilled(subscription: NDKSubscription): boolean {\n", "    if (filterIncludesIds(subscription.filter)) {\n\t        if (resultHasAllRequestedIds(subscription)) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\tfunction filterIncludesIds(filter: NDKFilter): boolean {\n\t    return !!filter[\"ids\"];\n\t}\n", "function resultHasAllRequestedIds(subscription: NDKSubscription): boolean {\n\t    const ids = subscription.filter[\"ids\"];\n\t    return !!ids && ids.length === subscription.eventFirstSeen.size;\n\t}\n"]}
{"filename": "src/subscription/index.ts", "chunked_list": ["import EventEmitter from \"eventemitter3\";\n\timport { Filter as NostrFilter, matchFilter, Sub, nip19 } from \"nostr-tools\";\n\timport { EventPointer } from \"nostr-tools/lib/nip19\";\n\timport NDKEvent, { NDKEventId } from \"../events/index.js\";\n\timport NDK from \"../index.js\";\n\timport { NDKRelay } from \"../relay\";\n\timport { calculateRelaySetFromFilter } from \"../relay/sets/calculate\";\n\timport { NDKRelaySet } from \"../relay/sets/index.js\";\n\timport { queryFullyFilled } from \"./utils.js\";\n\texport type NDKFilter = NostrFilter;\n", "export enum NDKSubscriptionCacheUsage {\n\t    // Only use cache, don't subscribe to relays\n\t    ONLY_CACHE = \"ONLY_CACHE\",\n\t    // Use cache, if no matches, use relays\n\t    CACHE_FIRST = \"CACHE_FIRST\",\n\t    // Use cache in addition to relays\n\t    PARALLEL = \"PARALLEL\",\n\t    // Skip cache, don't query it\n\t    ONLY_RELAY = \"ONLY_RELAY\",\n\t}\n", "export interface NDKSubscriptionOptions {\n\t    closeOnEose: boolean;\n\t    cacheUsage?: NDKSubscriptionCacheUsage;\n\t    /**\n\t     * Groupable subscriptions are created with a slight time\n\t     * delayed to allow similar filters to be grouped together.\n\t     */\n\t    groupable?: boolean;\n\t    /**\n\t     * The delay to use when grouping subscriptions, specified in milliseconds.\n", "     * @default 100\n\t     */\n\t    groupableDelay?: number;\n\t    /**\n\t     * The subscription ID to use for the subscription.\n\t     */\n\t    subId?: string;\n\t}\n\t/**\n\t * Default subscription options.\n", " */\n\texport const defaultOpts: NDKSubscriptionOptions = {\n\t    closeOnEose: true,\n\t    cacheUsage: NDKSubscriptionCacheUsage.CACHE_FIRST,\n\t    groupable: true,\n\t    groupableDelay: 100,\n\t};\n\t/**\n\t * Represents a subscription to an NDK event stream.\n\t *\n", " * @event NDKSubscription#event\n\t * Emitted when an event is received by the subscription.\n\t * @param {NDKEvent} event - The event received by the subscription.\n\t * @param {NDKRelay} relay - The relay that received the event.\n\t * @param {NDKSubscription} subscription - The subscription that received the event.\n\t *\n\t * @event NDKSubscription#event:dup\n\t * Emitted when a duplicate event is received by the subscription.\n\t * @param {NDKEvent} event - The duplicate event received by the subscription.\n\t * @param {NDKRelay} relay - The relay that received the event.\n", " * @param {number} timeSinceFirstSeen - The time elapsed since the first time the event was seen.\n\t * @param {NDKSubscription} subscription - The subscription that received the event.\n\t *\n\t * @event NDKSubscription#eose - Emitted when all relays have reached the end of the event stream.\n\t * @param {NDKSubscription} subscription - The subscription that received EOSE.\n\t *\n\t * @event NDKSubscription#close - Emitted when the subscription is closed.\n\t * @param {NDKSubscription} subscription - The subscription that was closed.\n\t */\n\texport class NDKSubscription extends EventEmitter {\n", "    readonly subId: string;\n\t    readonly filters: NDKFilter[];\n\t    readonly opts: NDKSubscriptionOptions;\n\t    public relaySet?: NDKRelaySet;\n\t    public ndk: NDK;\n\t    public relaySubscriptions: Map<NDKRelay, Sub>;\n\t    private debug: debug.Debugger;\n\t    /**\n\t     * Events that have been seen by the subscription, with the time they were first seen.\n\t     */\n", "    public eventFirstSeen = new Map<NDKEventId, number>();\n\t    /**\n\t     * Relays that have sent an EOSE.\n\t     */\n\t    public eosesSeen = new Set<NDKRelay>();\n\t    /**\n\t     * Events that have been seen by the subscription per relay.\n\t     */\n\t    public eventsPerRelay: Map<NDKRelay, Set<NDKEventId>> = new Map();\n\t    public constructor(\n", "        ndk: NDK,\n\t        filters: NDKFilter | NDKFilter[],\n\t        opts?: NDKSubscriptionOptions,\n\t        relaySet?: NDKRelaySet,\n\t        subId?: string\n\t    ) {\n\t        super();\n\t        this.ndk = ndk;\n\t        this.opts = { ...defaultOpts, ...(opts || {}) };\n\t        this.filters = filters instanceof Array ? filters : [filters];\n", "        this.subId = subId || opts?.subId || generateFilterId(this.filters[0]);\n\t        this.relaySet = relaySet;\n\t        this.relaySubscriptions = new Map<NDKRelay, Sub>();\n\t        this.debug = ndk.debug.extend(`subscription:${this.subId}`);\n\t        // validate that the caller is not expecting a persistent\n\t        // subscription while using an option that will only hit the cache\n\t        if (\n\t            this.opts.cacheUsage === NDKSubscriptionCacheUsage.ONLY_CACHE &&\n\t            !this.opts.closeOnEose\n\t        ) {\n", "            throw new Error(\n\t                \"Cannot use cache-only options with a persistent subscription\"\n\t            );\n\t        }\n\t    }\n\t    /**\n\t     * Provides access to the first filter of the subscription for\n\t     * backwards compatibility.\n\t     */\n\t    get filter(): NDKFilter {\n", "        return this.filters[0];\n\t    }\n\t    /**\n\t     * Calculates the groupable ID for this subscription.\n\t     *\n\t     * @returns The groupable ID, or null if the subscription is not groupable.\n\t     */\n\t    public groupableId(): string | null {\n\t        if (!this.opts?.groupable || this.filters.length > 1) {\n\t            return null;\n", "        }\n\t        const filter = this.filters[0];\n\t        // Check if there is a kind and no time-based filters\n\t        const noTimeConstraints = !filter.since && !filter.until;\n\t        const noLimit = !filter.limit;\n\t        if (noTimeConstraints && noLimit) {\n\t            let id = filter.kinds ? filter.kinds.join(\",\") : \"\";\n\t            const keys = Object.keys(filter || {})\n\t                .sort()\n\t                .join(\"-\");\n", "            id += `-${keys}`;\n\t            return id;\n\t        }\n\t        return null;\n\t    }\n\t    private shouldQueryCache(): boolean {\n\t        return this.opts?.cacheUsage !== NDKSubscriptionCacheUsage.ONLY_RELAY;\n\t    }\n\t    private shouldQueryRelays(): boolean {\n\t        return this.opts?.cacheUsage !== NDKSubscriptionCacheUsage.ONLY_CACHE;\n", "    }\n\t    private shouldWaitForCache(): boolean {\n\t        return (\n\t            // Must want to close on EOSE; subscriptions\n\t            // that want to receive further updates must\n\t            // always hit the relay\n\t            this.opts.closeOnEose &&\n\t            // Cache adapter must claim to be fast\n\t            !!this.ndk.cacheAdapter?.locking &&\n\t            // If explicitly told to run in parallel, then\n", "            // we should not wait for the cache\n\t            this.opts.cacheUsage !== NDKSubscriptionCacheUsage.PARALLEL\n\t        );\n\t    }\n\t    /**\n\t     * Start the subscription. This is the main method that should be called\n\t     * after creating a subscription.\n\t     */\n\t    public async start(): Promise<void> {\n\t        let cachePromise;\n", "        if (this.shouldQueryCache()) {\n\t            cachePromise = this.startWithCache();\n\t            if (this.shouldWaitForCache()) {\n\t                await cachePromise;\n\t                // if the cache has a hit, return early\n\t                if (queryFullyFilled(this)) {\n\t                    this.emit(\"eose\", this);\n\t                    return;\n\t                }\n\t            }\n", "        }\n\t        if (this.shouldQueryRelays()) {\n\t            this.startWithRelaySet();\n\t        } else {\n\t            this.emit(\"eose\", this);\n\t        }\n\t        return;\n\t    }\n\t    public stop(): void {\n\t        this.relaySubscriptions.forEach((sub) => sub.unsub());\n", "        this.relaySubscriptions.clear();\n\t        this.emit(\"close\", this);\n\t    }\n\t    private async startWithCache(): Promise<void> {\n\t        if (this.ndk.cacheAdapter?.query) {\n\t            const promise = this.ndk.cacheAdapter.query(this);\n\t            if (this.ndk.cacheAdapter.locking) {\n\t                await promise;\n\t            }\n\t        }\n", "    }\n\t    private startWithRelaySet(): void {\n\t        if (!this.relaySet) {\n\t            this.relaySet = calculateRelaySetFromFilter(\n\t                this.ndk,\n\t                this.filters[0]\n\t            );\n\t        }\n\t        if (this.relaySet) {\n\t            this.relaySet.subscribe(this);\n", "        }\n\t    }\n\t    // EVENT handling\n\t    /**\n\t     * Called when an event is received from a relay or the cache\n\t     * @param event\n\t     * @param relay\n\t     * @param fromCache Whether the event was received from the cache\n\t     */\n\t    public eventReceived(\n", "        event: NDKEvent,\n\t        relay: NDKRelay | undefined,\n\t        fromCache = false\n\t    ) {\n\t        if (relay) event.relay = relay;\n\t        if (!relay) relay = event.relay;\n\t        if (!fromCache && relay) {\n\t            // track the event per relay\n\t            let events = this.eventsPerRelay.get(relay);\n\t            if (!events) {\n", "                events = new Set();\n\t                this.eventsPerRelay.set(relay, events);\n\t            }\n\t            events.add(event.id);\n\t            // mark the event as seen\n\t            const eventAlreadySeen = this.eventFirstSeen.has(event.id);\n\t            if (eventAlreadySeen) {\n\t                const timeSinceFirstSeen =\n\t                    Date.now() - (this.eventFirstSeen.get(event.id) || 0);\n\t                relay.scoreSlowerEvent(timeSinceFirstSeen);\n", "                this.emit(\"event:dup\", event, relay, timeSinceFirstSeen, this);\n\t                return;\n\t            }\n\t            if (this.ndk.cacheAdapter) {\n\t                this.ndk.cacheAdapter.setEvent(event, this.filters[0], relay);\n\t            }\n\t            this.eventFirstSeen.set(`${event.id}`, Date.now());\n\t        } else {\n\t            this.eventFirstSeen.set(`${event.id}`, 0);\n\t        }\n", "        this.emit(\"event\", event, relay, this);\n\t    }\n\t    // EOSE handling\n\t    private eoseTimeout: ReturnType<typeof setTimeout> | undefined;\n\t    public eoseReceived(relay: NDKRelay): void {\n\t        if (this.opts?.closeOnEose) {\n\t            this.relaySubscriptions.get(relay)?.unsub();\n\t            this.relaySubscriptions.delete(relay);\n\t            // if this was the last relay that needed to EOSE, emit that this subscription is closed\n\t            if (this.relaySubscriptions.size === 0) {\n", "                this.emit(\"close\", this);\n\t            }\n\t        }\n\t        this.eosesSeen.add(relay);\n\t        const hasSeenAllEoses = this.eosesSeen.size === this.relaySet?.size();\n\t        if (hasSeenAllEoses) {\n\t            this.emit(\"eose\");\n\t        } else {\n\t            if (this.eoseTimeout) {\n\t                clearTimeout(this.eoseTimeout);\n", "            }\n\t            this.eoseTimeout = setTimeout(() => {\n\t                this.emit(\"eose\");\n\t            }, 500);\n\t        }\n\t    }\n\t}\n\t/**\n\t * Represents a group of subscriptions.\n\t *\n", " * Events emitted from the group will be emitted from each subscription.\n\t */\n\texport class NDKSubscriptionGroup extends NDKSubscription {\n\t    private subscriptions: NDKSubscription[];\n\t    constructor(ndk: NDK, subscriptions: NDKSubscription[]) {\n\t        const debug = ndk.debug.extend(\"subscription-group\");\n\t        const filters = mergeFilters(subscriptions.map((s) => s.filters[0]));\n\t        super(\n\t            ndk,\n\t            filters,\n", "            subscriptions[0].opts, // TODO: This should be merged\n\t            subscriptions[0].relaySet // TODO: This should be merged\n\t        );\n\t        this.subscriptions = subscriptions;\n\t        debug(\"merged filters\", {\n\t            count: subscriptions.length,\n\t            mergedFilters: this.filters[0],\n\t        });\n\t        // forward events to the matching subscriptions\n\t        this.on(\"event\", this.forwardEvent);\n", "        this.on(\"event:dup\", this.forwardEventDup);\n\t        this.on(\"eose\", this.forwardEose);\n\t        this.on(\"close\", this.forwardClose);\n\t    }\n\t    private isEventForSubscription(\n\t        event: NDKEvent,\n\t        subscription: NDKSubscription\n\t    ): boolean {\n\t        const { filters } = subscription;\n\t        if (!filters) return false;\n", "        return matchFilter(filters[0], event.rawEvent() as any);\n\t        // check if there is a filter whose key begins with '#'; if there is, check if the event has a tag with the same key on the first position\n\t        // of the tags array of arrays and the same value in the second position\n\t        // for (const key in filter) {\n\t        //     if (key === 'kinds' && filter.kinds!.includes(event.kind!)) return false;\n\t        //     else if (key === 'authors' && filter.authors!.includes(event.pubkey)) return false;\n\t        //     else if (key.startsWith('#')) {\n\t        //         const tagKey = key.slice(1);\n\t        //         const tagValue = filter[key];\n\t        //         if (event.tags) {\n", "        //             for (const tag of event.tags) {\n\t        //                 if (tag[0] === tagKey && tag[1] === tagValue) {\n\t        //                     return false;\n\t        //                 }\n\t        //             }\n\t        //         }\n\t        //     }\n\t        // return true;\n\t    }\n\t    private forwardEvent(event: NDKEvent, relay: NDKRelay) {\n", "        for (const subscription of this.subscriptions) {\n\t            if (!this.isEventForSubscription(event, subscription)) {\n\t                continue;\n\t            }\n\t            subscription.emit(\"event\", event, relay, subscription);\n\t        }\n\t    }\n\t    private forwardEventDup(\n\t        event: NDKEvent,\n\t        relay: NDKRelay,\n", "        timeSinceFirstSeen: number\n\t    ) {\n\t        for (const subscription of this.subscriptions) {\n\t            if (!this.isEventForSubscription(event, subscription)) {\n\t                continue;\n\t            }\n\t            subscription.emit(\n\t                \"event:dup\",\n\t                event,\n\t                relay,\n", "                timeSinceFirstSeen,\n\t                subscription\n\t            );\n\t        }\n\t    }\n\t    private forwardEose() {\n\t        for (const subscription of this.subscriptions) {\n\t            subscription.emit(\"eose\", subscription);\n\t        }\n\t    }\n", "    private forwardClose() {\n\t        for (const subscription of this.subscriptions) {\n\t            subscription.emit(\"close\", subscription);\n\t        }\n\t    }\n\t}\n\t/**\n\t * Go through all the passed filters, which should be\n\t * relatively similar, and merge them.\n\t */\n", "export function mergeFilters(filters: NDKFilter[]): NDKFilter {\n\t    const result: any = {};\n\t    filters.forEach((filter) => {\n\t        Object.entries(filter).forEach(([key, value]) => {\n\t            if (Array.isArray(value)) {\n\t                if (result[key] === undefined) {\n\t                    result[key] = [...value];\n\t                } else {\n\t                    result[key] = Array.from(\n\t                        new Set([...result[key], ...value])\n", "                    );\n\t                }\n\t            } else {\n\t                result[key] = value;\n\t            }\n\t        });\n\t    });\n\t    return result as NDKFilter;\n\t}\n\t/**\n", " * Creates a valid nostr filter from an event id or a NIP-19 bech32.\n\t */\n\texport function filterFromId(id: string): NDKFilter {\n\t    let decoded;\n\t    try {\n\t        decoded = nip19.decode(id);\n\t        switch (decoded.type) {\n\t            case \"nevent\":\n\t                return { ids: [decoded.data.id] };\n\t            case \"note\":\n", "                return { ids: [decoded.data] };\n\t            case \"naddr\":\n\t                return {\n\t                    authors: [decoded.data.pubkey],\n\t                    \"#d\": [decoded.data.identifier],\n\t                    kinds: [decoded.data.kind],\n\t                };\n\t        }\n\t    } catch (e) {}\n\t    return { ids: [id] };\n", "}\n\t/**\n\t * Returns the specified relays from a NIP-19 bech32.\n\t *\n\t * @param bech32 The NIP-19 bech32.\n\t */\n\texport function relaysFromBech32(bech32: string): NDKRelay[] {\n\t    try {\n\t        const decoded = nip19.decode(bech32);\n\t        if ([\"naddr\", \"nevent\"].includes(decoded?.type)) {\n", "            const data = decoded.data as unknown as EventPointer;\n\t            if (data?.relays) {\n\t                return data.relays.map((r: string) => new NDKRelay(r));\n\t            }\n\t        }\n\t    } catch (e) {\n\t        /* empty */\n\t    }\n\t    return [];\n\t}\n", "/**\n\t * Generates a random filter id, based on the filter keys.\n\t */\n\tfunction generateFilterId(filter: NDKFilter) {\n\t    const keys = Object.keys(filter) || [];\n\t    const subId = [];\n\t    for (const key of keys) {\n\t        if (key === \"kinds\") {\n\t            const v = [key, filter.kinds!.join(\",\")];\n\t            subId.push(v.join(\":\"));\n", "        } else {\n\t            subId.push(key);\n\t        }\n\t    }\n\t    subId.push(Math.floor(Math.random() * 999999999).toString());\n\t    return subId.join(\"-\");\n\t}\n"]}
{"filename": "src/cache/index.ts", "chunked_list": ["import NDKEvent from \"../events/index.js\";\n\timport { NDKRelay } from \"../relay/index.js\";\n\timport { NDKFilter, NDKSubscription } from \"../subscription/index.js\";\n\texport interface NDKCacheAdapter {\n\t    /**\n\t     * Whether this cache adapter is expected to be fast.\n\t     * If this is true, the cache will be queried before the relays.\n\t     * When this is false, the cache will be queried in addition to the relays.\n\t     */\n\t    locking: boolean;\n", "    query(subscription: NDKSubscription): Promise<void>;\n\t    setEvent(\n\t        event: NDKEvent,\n\t        filter: NDKFilter,\n\t        relay?: NDKRelay\n\t    ): Promise<void>;\n\t}\n"]}
