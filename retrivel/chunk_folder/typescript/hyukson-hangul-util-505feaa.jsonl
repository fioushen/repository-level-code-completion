{"filename": "test/getLocal.spec.ts", "chunked_list": ["import { getLocal, getLocalByGroups } from \"../src/getLocal\";\n\tdescribe(\"getLocal\", () => {\n\t  test(\"안녕하세요 - ko\", () => {\n\t    expect(getLocal(\"안녕하세요\")).toEqual(\"ko\");\n\t  });\n\t  test(\"Hello world - en\", () => {\n\t    expect(getLocal(\"Hello world\")).toEqual(\"en\");\n\t  });\n\t  test(\"1234 - number\", () => {\n\t    expect(getLocal(\"1234\")).toEqual(\"number\");\n", "  });\n\t  test(\"!@#$%^&*()_+ - special\", () => {\n\t    expect(getLocal(\"!@#$%^&*()_+\")).toEqual(\"special\");\n\t  });\n\t  test(\"こんにちは！!123 - etc\", () => {\n\t    expect(getLocal(\"こんにちは！!123\")).toEqual(\"etc\");\n\t  });\n\t});\n\tdescribe(\"getLocalByGroups\", () => {\n\t  test(\"안녕하세요 - 그룹\", () => {\n", "    expect(getLocalByGroups(\"안녕하세요\")).toEqual([\n\t      \"ko\",\n\t      \"ko\",\n\t      \"ko\",\n\t      \"ko\",\n\t      \"ko\",\n\t    ]);\n\t  });\n\t  test(\"Hello, world! - 그룹\", () => {\n\t    expect(getLocalByGroups(\"Hello, world!\")).toEqual([\n", "      \"en\",\n\t      \"en\",\n\t      \"en\",\n\t      \"en\",\n\t      \"en\",\n\t      \"special\",\n\t      \"special\",\n\t      \"en\",\n\t      \"en\",\n\t      \"en\",\n", "      \"en\",\n\t      \"en\",\n\t      \"special\",\n\t    ]);\n\t  });\n\t  test(\"1234 - 그룹\", () => {\n\t    expect(getLocalByGroups(\"1234\")).toEqual([\n\t      \"number\",\n\t      \"number\",\n\t      \"number\",\n", "      \"number\",\n\t    ]);\n\t  });\n\t  test(\"!@#$%^&*()_+ - 그룹\", () => {\n\t    expect(getLocalByGroups(\"!@#$%^&*()_+\")).toEqual([\n\t      \"special\",\n\t      \"special\",\n\t      \"special\",\n\t      \"special\",\n\t      \"special\",\n", "      \"special\",\n\t      \"special\",\n\t      \"special\",\n\t      \"special\",\n\t      \"special\",\n\t      \"special\",\n\t      \"special\",\n\t    ]);\n\t  });\n\t  test(\"こんにちは!123 - 그룹\", () => {\n", "    const word = \"こんにちは!123\";\n\t    const result = getLocalByGroups(word);\n\t    expect(result).toEqual([\n\t      \"etc\",\n\t      \"etc\",\n\t      \"etc\",\n\t      \"etc\",\n\t      \"etc\",\n\t      \"special\",\n\t      \"number\",\n", "      \"number\",\n\t      \"number\",\n\t    ]);\n\t  });\n\t  test(\"안녕하세요! Hello, world! 1234 # - 퍼센트\", () => {\n\t    const word = \"안녕하세요! Hello, world! 1234 #\";\n\t    const result = getLocalByGroups(word, true);\n\t    expect(result).toEqual({\n\t      ko: 18.52,\n\t      en: 37.04,\n", "      number: 14.81,\n\t      special: 29.63,\n\t      etc: 0,\n\t    });\n\t  });\n\t  test(\"!@#$%^&*()_+ - 퍼센트\", () => {\n\t    expect(getLocalByGroups(\"!@#$%^&*()_+\", true)).toEqual({\n\t      ko: 0,\n\t      en: 0,\n\t      number: 0,\n", "      special: 100,\n\t      etc: 0,\n\t    });\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const word = new Array(1000000).fill(\"안녕하세요! Hello, world! 1234 #\").join('');\n\t    const result = getLocalByGroups(word, true);\n\t    expect(result).toEqual({\n\t      ko: 18.52,\n\t      en: 37.04,\n", "      number: 14.81,\n\t      special: 29.63,\n\t      etc: 0,\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/formatDate.spec.ts", "chunked_list": ["import { formatDate } from \"../src/formatDate\";\n\tconst date = \"2022-02-22 22:22:22\";\n\tdescribe(\"formatDate\", () => {\n\t  test(\"formatStyle 기본값 - new Date()\", () => {\n\t    expect(formatDate(date)).toEqual(\"2022년02월22일 22시22분22초\");\n\t  });\n\t  test(\"formatStyle 기본값 - String\", () => {\n\t    expect(formatDate(date)).toEqual(\"2022년02월22일 22시22분22초\");\n\t  });\n\t  test(\"HH:mm:ss YYYY년 MM월\", () => {\n", "    expect(formatDate(date, \"HH:mm:ss YYYY년 MM월\")).toEqual(\n\t      \"22:22:22 2022년 02월\"\n\t    );\n\t  });\n\t  test(\"YYYY년 MM월 DD일 dd요일 HH:mm:ss\", () => {\n\t    expect(formatDate(date, \"YYYY년 MM월 DD일 dd요일 HH:mm:ss\")).toEqual(\n\t      \"2022년 02월 22일 화요일 22:22:22\"\n\t    );\n\t  });\n\t  test(\"YYYY-MM-DD HH:mm:ss\", () => {\n", "    expect(formatDate(date, \"YYYY-MM-DD HH:mm:ss\")).toEqual(\"2022-02-22 22:22:22\");\n\t  });\n\t});\n"]}
{"filename": "test/distance.spec.ts", "chunked_list": ["import { getDistance, correctByDistance } from \"../src/distance\";\n\tdescribe(\"getDistance\", () => {\n\t  test(\"빈값\", () => {\n\t    expect(getDistance(\"파인애플\", \"\")).toEqual(4);\n\t    expect(getDistance(\"\", \"파인애플\")).toEqual(4);\n\t    expect(getDistance(\"\", \"\")).toEqual(0);\n\t  });\n\t  test(\"파인애플\", () => {\n\t    expect(getDistance(\"파인애플\", \"파일해플\")).toEqual(2);\n\t  });\n", "  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(10000).fill(\"팝\").join(\"\");\n\t    const input2 = new Array(10000).fill(\"핍\").join(\"\");\n\t    expect(getDistance(input, input2)).toEqual(10000);\n\t  });\n\t});\n\tdescribe(\"correctByDistance\", () => {\n\t  const wordList = [\n\t    \"사자\",\n\t    \"무과\",\n", "    \"사과파이\",\n\t    \"파인애플\",\n\t    \"망고\",\n\t    \"변호사\",\n\t    \"사고\",\n\t    \"사과\",\n\t    \"귤\",\n\t    \"토끼\",\n\t    \"코끼리\",\n\t  ];\n", "  test(\"사과\", () => {\n\t    expect(correctByDistance(\"사과\", wordList)).toEqual([\n\t      \"사과\",\n\t      \"사고\",\n\t      \"사자\",\n\t      \"무과\",\n\t    ]);\n\t    expect(correctByDistance(\"사과\", wordList, { isSplit: false })).toEqual([\n\t      \"사과\",\n\t      \"사자\",\n", "      \"무과\",\n\t      \"사고\",\n\t      \"사과파이\",\n\t      \"망고\",\n\t      \"귤\",\n\t      \"토끼\",\n\t    ]);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(1000).fill(\"팝\").join(\"\");\n", "    const input2 = new Array(1000)\n\t      .fill([\n\t        new Array(1000).fill(\"핍\").join(\"\"),\n\t        new Array(1000).fill(\"쉽\").join(\"\"),\n\t      ])\n\t      .flat();\n\t    expect(correctByDistance(input, input2)).toEqual([]);\n\t  });\n\t});\n"]}
{"filename": "test/banmal.spec.ts", "chunked_list": ["import { toBanmal, toHonorific } from \"../src/banmal\";\n\tdescribe(\"toHonorific\", () => {\n\t  test(\"반말 -> 높임말\", () => {\n\t    expect(toHonorific(\"오늘은 사과이다.\")).toEqual(\"오늘은 사과입니다.\");\n\t    expect(toHonorific(\"내일은 자두이다.\")).toEqual(\"내일은 자두입니다.\");\n\t    expect(toHonorific(\"내가 먹을 사과이다.\")).toEqual(\"내가 먹을 사과입니다.\");\n\t    expect(toHonorific(\"나는 친구와 함께 간다.\")).toEqual(\n\t      \"저는 친구와 함께 갑니다.\"\n\t    );\n\t    expect(toHonorific(\"어제는 비가 왔다.\")).toEqual(\"어제는 비가 왔습니다.\");\n", "    expect(toHonorific(\"나는, 사람이다.\")).toEqual(\"저는, 사람입니다.\");\n\t  });\n\t});\n\tdescribe(\"toBanmal\", () => {\n\t  test(\"높임말 -> 반말\", () => {\n\t    expect(toBanmal(\"사람이 없습니다.\")).toEqual(\"사람이 없다.\");\n\t    expect(toBanmal(\"하겠습니다.\")).toEqual(\"하겠다.\");\n\t    expect(toBanmal(\"다가옵니다.\")).toEqual(\"다가온다.\");\n\t    expect(toBanmal(\"필수입니다.\")).toEqual(\"필수이다.\");\n\t    expect(toBanmal(\"생깁니다.\")).toEqual(\"생긴다.\");\n", "    expect(toBanmal(\"않습니다.\")).toEqual(\"않다.\");\n\t    expect(toBanmal(\"보겠습니다.\")).toEqual(\"보겠다.\");\n\t    expect(toBanmal(\"하였습니다.\")).toEqual(\"하였다.\");\n\t    expect(toBanmal(\"가능합니다.\")).toEqual(\"가능하다.\");\n\t    expect(toBanmal(\"중요합니다.\")).toEqual(\"중요하다.\");\n\t    expect(toBanmal(\"하십니다.\")).toEqual(\"하신다.\");\n\t    expect(toBanmal(\"바랍니다.\")).toEqual(\"바란다.\");\n\t    expect(toBanmal(\"나옵니다.\")).toEqual(\"나온다.\");\n\t    expect(toBanmal(\"했습니다.\")).toEqual(\"했다.\");\n\t    expect(toBanmal(\"봤습니다.\")).toEqual(\"봤다.\");\n", "    expect(toBanmal(\"쳤습니다.\")).toEqual(\"쳤다.\");\n\t    expect(toBanmal(\"쌌습니다.\")).toEqual(\"쌌다.\");\n\t    expect(toBanmal(\"해주세요.\")).toEqual(\"해라.\");\n\t    expect(toBanmal(\"샀습니다.\")).toEqual(\"샀다.\");\n\t    expect(toBanmal(\"었습니다.\")).toEqual(\"었다.\");\n\t    expect(toBanmal(\"먹습니다.\")).toEqual(\"먹다.\");\n\t    expect(toBanmal(\"있습니다.\")).toEqual(\"있다.\");\n\t    expect(toBanmal(\"좋습니다.\")).toEqual(\"좋다.\");\n\t    expect(toBanmal(\"많습니다.\")).toEqual(\"많다.\");\n\t    expect(toBanmal(\"놓았습니다.\")).toEqual(\"놓았다.\");\n", "    expect(toBanmal(\"어렵습니다.\")).toEqual(\"어렵다.\");\n\t    expect(toBanmal(\"주워주세요.\")).toEqual(\"주워라.\");\n\t  });\n\t});\n"]}
{"filename": "test/isJong.spec.ts", "chunked_list": ["import { isJongByCode, isJong, isJongByGroups } from \"../src/isJong\";\n\tdescribe(\"isJongByCode\", () => {\n\t  test(\"ㄱ\", () => {\n\t    expect(isJongByCode(12593)).toEqual(true); // \"ㄱ\"\n\t  });\n\t  test(\"ㅊ\", () => {\n\t    expect(isJongByCode(12622)).toEqual(true); // \"ㅊ\"\n\t  });\n\t  test(\"ㅊ\", () => {\n\t    expect(isJongByCode(12595)).toEqual(true); // \"ㅊ\"\n", "  });\n\t  test(\"가\", () => {\n\t    expect(isJongByCode(44032)).toEqual(false); // '가'\n\t  });\n\t  test(\"a\", () => {\n\t    expect(isJongByCode(97)).toEqual(false); // \"a\"\n\t  });\n\t});\n\tdescribe(\"isJong\", () => {\n\t  test(\"빈값\", () => {\n", "    expect(isJong(\"\")).toEqual(false);\n\t  });\n\t  test(\"ㄳㅂㄷㅈ\", () => {\n\t    expect(isJong(\"ㄳㅂㄷㅈ\")).toEqual(true);\n\t  });\n\t  test(\"ㄳㅂ2ㄷㅈ\", () => {\n\t    expect(isJong(\"ㄳㅂ2ㄷㅈ\")).toEqual(false);\n\t  });\n\t  test(\"가나다라\", () => {\n\t    expect(isJong(\"가나다라\")).toEqual(false);\n", "  });\n\t  test(\"ㄱㅏㄷㅏ\", () => {\n\t    expect(isJong(\"ㄱㅏㄷㅏ\")).toEqual(false);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(1000000).fill('ㅂ').join('')\n\t    expect(isJong(input)).toEqual(true);\n\t  });\n\t});\n\tdescribe(\"isJongByGroups\", () => {\n", "  test(\"ㄱㅂㄷㅈ\", () => {\n\t    expect(isJongByGroups(\"ㄱㅂㄷㅈ\")).toEqual([true, true, true, true]);\n\t  });\n\t  test(\"가나다라\", () => {\n\t    expect(isJongByGroups(\"가나다라\")).toEqual([false, false, false, false]);\n\t  });\n\t  test(\"ㄳㅏㄷㅏ\", () => {\n\t    expect(isJongByGroups(\"ㄳㅏㄷㅏ\")).toEqual([true, false, true, false]);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n", "    const input = new Array(1000000).fill('ㄳ').join('')\n\t    const result = new Array(1000000).fill(true);\n\t    expect(isJongByGroups(input)).toEqual(result);\n\t  });\n\t});\n"]}
{"filename": "test/encode.spec.ts", "chunked_list": ["import { encode, decode } from \"../src/encode\";\n\tdescribe(\"formatNumber\", () => {\n\t  test(\"문자\", () => {\n\t    expect(decode(encode(\"구오\"))).toEqual(\"구오\");\n\t  });\n\t  test(\"혼합 문자\", () => {\n\t    expect(decode(encode(\"감!사3합$니다.\"))).toEqual(\"감!사3합$니다.\");\n\t  });\n\t  test(\"배열\", () => {\n\t    expect(decode(encode([1, 2, 3]))).toEqual([1, 2, 3]);\n", "  });\n\t  test(\"객체\", () => {\n\t    expect(decode(encode({ a: 1, b: 2 }))).toEqual({ a: 1, b: 2 });\n\t  });\n\t  test(\"혼합 객체\", () => {\n\t    expect(\n\t      decode(\n\t        encode([\n\t          { a: 1, b: 2 },\n\t          { a: 1, b: 2 },\n", "        ])\n\t      )\n\t    ).toEqual([\n\t      { a: 1, b: 2 },\n\t      { a: 1, b: 2 },\n\t    ]);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(40000).fill(\"감!사3합$니다.\").join('');\n\t    expect(decode(encode(input))).toEqual(input);\n", "  });\n\t});\n"]}
{"filename": "test/divide.spec.ts", "chunked_list": ["import { divide, divideHangul, divideHangulByGroups } from \"../src/divide\";\n\tdescribe(\"divide\", () => {\n\t  test(\"한글이 아닌 값\", () => {\n\t    expect(divide(\"a\")).toEqual([\"a\"]);\n\t  });\n\t  test(\"한\", () => {\n\t    expect(divide(\"한\")).toEqual([\"ㅎ\", \"ㅏ\", \"ㄴ\"]);\n\t  });\n\t  test(\"한 - object\", () => {\n\t    expect(divide(\"한\", { resultType: \"object\" })).toEqual({\n", "      cho: \"ㅎ\",\n\t      jung: \"ㅏ\",\n\t      jong: \"ㄴ\",\n\t    });\n\t  });\n\t  test(\"한 - string\", () => {\n\t    expect(divide(\"한\", { resultType: \"string\" })).toEqual(\"ㅎㅏㄴ\");\n\t  });\n\t  test(\"빵\", () => {\n\t    expect(divide(\"빵\")).toEqual([\"ㅃ\", \"ㅏ\", \"ㅇ\"]);\n", "  });\n\t  test(\"뷁\", () => {\n\t    expect(divide(\"뷁\", { isSplit: true })).toEqual([\n\t      \"ㅂ\",\n\t      \"ㅜ\",\n\t      \"ㅔ\",\n\t      \"ㄹ\",\n\t      \"ㄱ\",\n\t    ]);\n\t    expect(divide(\"뷁\", { isSplit: false })).toEqual([\"ㅂ\", \"ㅞ\", \"ㄺ\"]);\n", "  });\n\t});\n\tdescribe(\"divideHangulByGroups\", () => {\n\t  test(\"빈값\", () => {\n\t    expect(divideHangulByGroups(\"\")).toEqual([]);\n\t  });\n\t  test(\"안녕하세요\", () => {\n\t    expect(divideHangulByGroups(\"안녕하세요\")).toEqual([\n\t      [\"ㅇ\", \"ㅏ\", \"ㄴ\"],\n\t      [\"ㄴ\", \"ㅕ\", \"ㅇ\"],\n", "      [\"ㅎ\", \"ㅏ\"],\n\t      [\"ㅅ\", \"ㅔ\"],\n\t      [\"ㅇ\", \"ㅛ\"],\n\t    ]);\n\t  });\n\t  test(\"Hello, 안녕하세요\", () => {\n\t    expect(divideHangulByGroups(\"Hello, 안녕하세요\")).toEqual([\n\t      [\"H\"],\n\t      [\"e\"],\n\t      [\"l\"],\n", "      [\"l\"],\n\t      [\"o\"],\n\t      [\",\"],\n\t      [\" \"],\n\t      [\"ㅇ\", \"ㅏ\", \"ㄴ\"],\n\t      [\"ㄴ\", \"ㅕ\", \"ㅇ\"],\n\t      [\"ㅎ\", \"ㅏ\"],\n\t      [\"ㅅ\", \"ㅔ\"],\n\t      [\"ㅇ\", \"ㅛ\"],\n\t    ]);\n", "  });\n\t  test(\"값뷁쇏\", () => {\n\t    expect(divideHangulByGroups(\"값뷁ㅅ쇏\")).toEqual([\n\t      [\"ㄱ\", \"ㅏ\", \"ㅂ\", \"ㅅ\"],\n\t      [\"ㅂ\", \"ㅜ\", \"ㅔ\", \"ㄹ\", \"ㄱ\"],\n\t      [\"ㅅ\"],\n\t      [\"ㅅ\", \"ㅗ\", \"ㅐ\", \"ㄹ\", \"ㅂ\"],\n\t    ]);\n\t    expect(divideHangulByGroups(\"값뷁ㅅ쇏\", { isSplit: false })).toEqual([\n\t      [\"ㄱ\", \"ㅏ\", \"ㅄ\"],\n", "      [\"ㅂ\", \"ㅞ\", \"ㄺ\"],\n\t      [\"ㅅ\"],\n\t      [\"ㅅ\", \"ㅙ\", \"ㄼ\"],\n\t    ]);\n\t  });\n\t});\n\tdescribe(\"divideHangul\", () => {\n\t  test(\"빈값\", () => {\n\t    expect(divideHangul(\"\")).toEqual([]);\n\t  });\n", "  test(\"안녕하세요\", () => {\n\t    expect(divideHangul(\"안녕하세요\")).toEqual([\n\t      \"ㅇ\",\n\t      \"ㅏ\",\n\t      \"ㄴ\",\n\t      \"ㄴ\",\n\t      \"ㅕ\",\n\t      \"ㅇ\",\n\t      \"ㅎ\",\n\t      \"ㅏ\",\n", "      \"ㅅ\",\n\t      \"ㅔ\",\n\t      \"ㅇ\",\n\t      \"ㅛ\",\n\t    ]);\n\t  });\n\t  test(\"Hello, 안녕하세요\", () => {\n\t    expect(divideHangul(\"Hello, 안녕하세요\")).toEqual([\n\t      \"H\",\n\t      \"e\",\n", "      \"l\",\n\t      \"l\",\n\t      \"o\",\n\t      \",\",\n\t      \" \",\n\t      \"ㅇ\",\n\t      \"ㅏ\",\n\t      \"ㄴ\",\n\t      \"ㄴ\",\n\t      \"ㅕ\",\n", "      \"ㅇ\",\n\t      \"ㅎ\",\n\t      \"ㅏ\",\n\t      \"ㅅ\",\n\t      \"ㅔ\",\n\t      \"ㅇ\",\n\t      \"ㅛ\",\n\t    ]);\n\t  });\n\t  test(\"값뷁쇏\", () => {\n", "    expect(divideHangul(\"값뷁쇏\")).toEqual([\n\t      \"ㄱ\",\n\t      \"ㅏ\",\n\t      \"ㅂ\",\n\t      \"ㅅ\",\n\t      \"ㅂ\",\n\t      \"ㅜ\",\n\t      \"ㅔ\",\n\t      \"ㄹ\",\n\t      \"ㄱ\",\n", "      \"ㅅ\",\n\t      \"ㅗ\",\n\t      \"ㅐ\",\n\t      \"ㄹ\",\n\t      \"ㅂ\",\n\t    ]);\n\t    expect(divideHangul(\"값뷁쇏\", false)).toEqual([\n\t      \"ㄱ\",\n\t      \"ㅏ\",\n\t      \"ㅄ\",\n", "      \"ㅂ\",\n\t      \"ㅞ\",\n\t      \"ㄺ\",\n\t      \"ㅅ\",\n\t      \"ㅙ\",\n\t      \"ㄼ\",\n\t    ]);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = divideHangul(new Array(100000).fill(\"값쉛\").join(\"\"));\n", "    const result = new Array(100000).fill(\"ㄱㅏㅂㅅㅅㅜㅔㄹㅂ\").join('').split('');\n\t    expect(input).toEqual(result);\n\t  });\n\t});\n"]}
{"filename": "test/sortHangul.spec.ts", "chunked_list": ["import { sortByASC, sortByDESC, sortByGroups } from \"../src/sortHangul\";\n\tdescribe(\"sortByASC\", () => {\n\t  test(\"영어 배열\", () => {\n\t    expect(sortByASC([\"apple\", \"kiwi\", \"banana\"])).toEqual([\n\t      \"apple\",\n\t      \"banana\",\n\t      \"kiwi\",\n\t    ]);\n\t  });\n\t  test(\"한글 배열\", () => {\n", "    expect(sortByASC([\"사과\", \"키위\", \"바나나\"])).toEqual([\n\t      \"바나나\",\n\t      \"사과\",\n\t      \"키위\",\n\t    ]);\n\t  });\n\t  test(\"숫자 배열\", () => {\n\t    expect(sortByASC([1, 5, 1, 4])).toEqual([1, 1, 4, 5]);\n\t  });\n\t  test(\"아무런 배열\", () => {\n", "    expect(sortByASC([4, \"a\", \"가\", \"ㄴ\"])).toEqual([4, \"가\", \"ㄴ\", \"a\"]);\n\t  });\n\t  test(\"객체 배열\", () => {\n\t    const array = [\n\t      { name: \"kiwi\", age: 12 },\n\t      { name: \"apple\", age: 42 },\n\t      { name: \"kiwi\", age: 42 },\n\t    ];\n\t    expect(sortByASC(array)).toEqual([\n\t      { name: \"kiwi\", age: 12 },\n", "      { name: \"apple\", age: 42 },\n\t      { name: \"kiwi\", age: 42 },\n\t    ]);\n\t    expect(sortByASC(array, \"age\")).toEqual([\n\t      { name: \"kiwi\", age: 12 },\n\t      { name: \"apple\", age: 42 },\n\t      { name: \"kiwi\", age: 42 },\n\t    ]);\n\t    expect(sortByASC(array, [\"name\", \"age\"])).toEqual([\n\t      { name: \"apple\", age: 42 },\n", "      { name: \"kiwi\", age: 12 },\n\t      { name: \"kiwi\", age: 42 },\n\t    ]);\n\t  });\n\t  test(\"compare object 적용\", () => {\n\t    const array = [\n\t      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t    ];\n", "    expect(sortByASC(array, \"user.name\")).toEqual([\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t    ]);\n\t    expect(sortByASC(array, [\"user.age\", \"user.name\"])).toEqual([\n\t      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t    ]);\n", "    expect(sortByASC(array, \"user.name[0]\")).toEqual([\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t    ]);\n\t  });\n\t});\n\tdescribe(\"sortByDESC\", () => {\n\t  test(\"영어 배열\", () => {\n\t    expect(sortByDESC([\"apple\", \"kiwi\", \"banana\"])).toEqual([\n", "      \"kiwi\",\n\t      \"banana\",\n\t      \"apple\",\n\t    ]);\n\t  });\n\t  test(\"한글 배열\", () => {\n\t    expect(sortByDESC([\"사과\", \"키위\", \"바나나\"])).toEqual([\n\t      \"키위\",\n\t      \"사과\",\n\t      \"바나나\",\n", "    ]);\n\t  });\n\t  test(\"숫자 배열\", () => {\n\t    expect(sortByDESC([1, 5, 1, 4])).toEqual([5, 4, 1, 1]);\n\t  });\n\t  test(\"아무런 배열\", () => {\n\t    expect(sortByDESC([4, \"a\", \"가\", \"ㄴ\"])).toEqual([\"a\", \"ㄴ\", \"가\", 4]);\n\t  });\n\t  test(\"객체 배열\", () => {\n\t    const array = [\n", "      { name: \"kiwi\", age: 12 },\n\t      { name: \"apple\", age: 42 },\n\t      { name: \"kiwi\", age: 42 },\n\t    ];\n\t    expect(sortByDESC(array)).toEqual([\n\t      { name: \"kiwi\", age: 12 },\n\t      { name: \"apple\", age: 42 },\n\t      { name: \"kiwi\", age: 42 },\n\t    ]);\n\t    expect(sortByDESC(array, \"age\")).toEqual([\n", "      { name: \"apple\", age: 42 },\n\t      { name: \"kiwi\", age: 42 },\n\t      { name: \"kiwi\", age: 12 },\n\t    ]);\n\t    expect(sortByDESC(array, [\"name\", \"age\"])).toEqual([\n\t      { name: \"kiwi\", age: 42 },\n\t      { name: \"kiwi\", age: 12 },\n\t      { name: \"apple\", age: 42 },\n\t    ]);\n\t  });\n", "  test(\"compare object 적용\", () => {\n\t    const array = [\n\t      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t    ];\n\t    expect(sortByDESC(array, \"user.name\")).toEqual([\n\t      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n", "      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t    ]);\n\t    expect(sortByDESC(array, [\"user.age\", \"user.name\"])).toEqual([\n\t      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t    ]);\n\t    expect(sortByDESC(array, \"user.name[0]\")).toEqual([\n", "      { user: { name: \"kiwi\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"kiwi\", age: 12 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t      { user: { name: \"apple\", age: 42 }, lastConnect: \"2022-02-22 22:22:22\" },\n\t    ]);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const array = new Array(9000000).fill({ name: \"apple\", age: 242 });\n\t    expect(sortByDESC(array, \"name\")).toEqual(array);\n\t  });\n", "});\n\tdescribe(\"sortByGroups\", () => {\n\t  test(\"회사 오름차순\", () => {\n\t    const groups = [\"회장\", \"사장\", \"부장\", \"대리\", \"사원\"];\n\t    expect(\n\t      sortByGroups([\"대리\", \"사원\", \"사장\", \"회장\", \"부장\"], groups)\n\t    ).toEqual([\"회장\", \"사장\", \"부장\", \"대리\", \"사원\"]);\n\t  });\n\t  test(\"오름차순 내림차순\", () => {\n\t    const array = [5, \"banana\", 4, \"apple\", \"kiwi\", 1];\n", "    const groups = [4, \"apple\", \"kiwi\", \"banana\"];\n\t    expect(sortByGroups(array, groups, false)).toEqual([\n\t      5,\n\t      1,\n\t      \"banana\",\n\t      \"kiwi\",\n\t      \"apple\",\n\t      4,\n\t    ]);\n\t    expect(sortByGroups(array, groups)).toEqual([\n", "      4,\n\t      \"apple\",\n\t      \"kiwi\",\n\t      \"banana\",\n\t      1,\n\t      5,\n\t    ]);\n\t  });\n\t  test(\"배열, 그룹 아무 것도 없는 경우\", () => {\n\t    expect(sortByGroups([], [])).toEqual([]);\n", "  });\n\t  test(\"그룹에는 없는데, 배열에는 존재하는 경우\", () => {\n\t    const array = [\"banana\", \"cherry\", \"kiwi\", \"apple\", \"grape\"];\n\t    const groups = [\"apple\", \"kiwi\", \"banana\"];\n\t    expect(sortByGroups(array, groups)).toEqual([\n\t      \"apple\",\n\t      \"kiwi\",\n\t      \"banana\",\n\t      \"cherry\",\n\t      \"grape\",\n", "    ]);\n\t  });\n\t  test(\"그룹에는 존재하지만, 배열에는 없는 경우\", () => {\n\t    const array = [\"banana\", \"kiwi\", \"apple\", \"cherr1\"];\n\t    const groups = [\"apple\", \"kiwi\", \"banana\", \"cherry\"];\n\t    expect(sortByGroups(array, groups)).toEqual([\n\t      \"apple\",\n\t      \"kiwi\",\n\t      \"banana\",\n\t      \"cherr1\",\n", "    ]);\n\t  });\n\t});\n"]}
{"filename": "test/includesByCho.spec.ts", "chunked_list": ["import { includesByCho, makeRegexByCho } from \"../src/includesByCho\";\n\tdescribe(\"includesByCho\", () => {\n\t  test(\"가나다라마바사\", () => {\n\t    const search = \"ㄱ나다라마바ㅅ\";\n\t    expect(makeRegexByCho(search)).toEqual(/([가-깋]나다라마바[사-싷])/g);\n\t  });\n\t  test(\"가나다라마바사\", () => {\n\t    const search = \"ㄱㄱ\";\n\t    expect(makeRegexByCho(search)).toEqual(/([가-깋][가-깋])/g);\n\t  });\n", "});\n\tdescribe(\"includesByCho\", () => {\n\t  test(\"가나다라마바사\", () => {\n\t    const search = \"ㄱ\";\n\t    const word = \"가나다라마바사\";\n\t    expect(includesByCho(search, word)).toEqual(true);\n\t  });\n\t  test(\"가나다라마바사\", () => {\n\t    const search = \"ㅇ\";\n\t    const word = \"가나다라마바사\";\n", "    expect(includesByCho(search, word)).toEqual(false);\n\t  });\n\t  test(\"가나다라마바사\", () => {\n\t    const search = \"ㄷㄹ\";\n\t    const word = \"가나다라마바사\";\n\t    expect(includesByCho(search, word)).toEqual(true);\n\t  });\n\t  test(\"가나다라마바사\", () => {\n\t    const search = \"ㄱㄹ\";\n\t    const word = \"가나다라마바사\";\n", "    expect(includesByCho(search, word)).toEqual(false);\n\t  });\n\t  test(\"가나다라마바사 to 가ㄴㄷ라\", () => {\n\t    const search = \"가ㄴㄷ라\";\n\t    const word = \"가나다라마바사\";\n\t    expect(includesByCho(search, word)).toEqual(true);\n\t  });\n\t});\n"]}
{"filename": "test/utils.spec.ts", "chunked_list": ["import {\n\t  isNumber,\n\t  chunkAtEnd,\n\t  makePercentByObject,\n\t  zeroPad,\n\t  reverseByObject,\n\t  reverseByArray,\n\t  getNestedProperty,\n\t  splitByKey,\n\t} from \"../src/utils\";\n", "describe(\"isNumber\", () => {\n\t  test(\"숫자가 아닌 값\", () => {\n\t    expect(isNumber(\"\")).toEqual(false);\n\t    expect(isNumber(null)).toEqual(false);\n\t    expect(isNumber(undefined)).toEqual(false);\n\t    expect(isNumber(NaN)).toEqual(false);\n\t    expect(isNumber(\"abc\")).toEqual(false);\n\t    expect(isNumber(\"test\")).toEqual(false);\n\t    expect(isNumber(\"100,000.123\")).toEqual(false);\n\t    expect(isNumber(true)).toEqual(false);\n", "    expect(isNumber(false)).toEqual(false);\n\t    expect(isNumber([])).toEqual(false);\n\t    expect(isNumber({})).toEqual(false);\n\t  });\n\t  test(\"숫자\", () => {\n\t    expect(isNumber(0)).toEqual(true);\n\t    expect(isNumber(123)).toEqual(true);\n\t    expect(isNumber(-123)).toEqual(true);\n\t    expect(isNumber(0.123)).toEqual(true);\n\t    expect(isNumber(123.213)).toEqual(true);\n", "  });\n\t});\n\tdescribe(\"splitByKey\", () => {\n\t  test(\"빈값\", () => {\n\t    expect(splitByKey(\"\")).toEqual([]);\n\t  });\n\t  test(\"[0].a\", () => {\n\t    expect(splitByKey(\"[0].a\")).toEqual([\"0\", \"a\"]);\n\t  });\n\t  test(\"name.detail\", () => {\n", "    expect(splitByKey(\"name.detail\")).toEqual([\"name\", \"detail\"]);\n\t  });\n\t});\n\tdescribe(\"getNestedProperty\", () => {\n\t  test(\"빈값\", () => {\n\t    expect(getNestedProperty(\"\", \"\")).toEqual(undefined);\n\t    expect(getNestedProperty(\"\", {})).toEqual(undefined);\n\t  });\n\t  test(\"[0].a\", () => {\n\t    expect(getNestedProperty(\"[2].a\", \"test\")).toEqual(undefined);\n", "    expect(getNestedProperty(splitByKey(\"[2].a\"), \"test\")).toEqual(undefined);\n\t    expect(getNestedProperty(\"[0].a\", [{ a: 2 }, { b: 1 }])).toEqual(2);\n\t    expect(getNestedProperty(\"[0].a\", [{ b: 1 }, { a: 2 }])).toEqual(undefined);\n\t  });\n\t  test(\"name.detail\", () => {\n\t    expect(\n\t      getNestedProperty(\"name.detail\", { name: { detail: \"테스트\" } })\n\t    ).toEqual(\"테스트\");\n\t    expect(getNestedProperty(\"name.detail\", { name: \"테스트\" })).toEqual(\n\t      undefined\n", "    );\n\t  });\n\t});\n\tdescribe(\"zeroPad\", () => {\n\t  test(\"5\", () => {\n\t    expect(zeroPad(5, 2)).toEqual(\"05\");\n\t  });\n\t  test(\"test\", () => {\n\t    expect(zeroPad(\"test\", 10)).toEqual(\"000000test\");\n\t    expect(zeroPad(\"test\", 10, \"-\")).toEqual(\"------test\");\n", "  });\n\t  test(\"123\", () => {\n\t    expect(zeroPad(123, 2)).toEqual(\"123\");\n\t    expect(zeroPad(123, 5)).toEqual(\"00123\");\n\t    expect(zeroPad(123, 3, \"-\")).toEqual(\"123\");\n\t    expect(zeroPad(123, 0)).toEqual(\"123\");\n\t    expect(zeroPad(12345, 3)).toEqual(\"12345\");\n\t  });\n\t  test(\"빈값\", () => {\n\t    expect(zeroPad(\"\", 3)).toEqual(\"000\");\n", "  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const result = new Array(10000000).fill(\"0\").join(\"\");\n\t    expect(zeroPad(\"\", 10000000)).toEqual(result);\n\t  });\n\t});\n\tdescribe(\"chunkAtEnd\", () => {\n\t  test(\"abcdefg\", () => {\n\t    expect(chunkAtEnd(\"abcdefg\", 2)).toEqual([\"fg\", \"de\", \"bc\", \"a\"]);\n\t    expect(chunkAtEnd(\"abcdefg\", 4)).toEqual([\"defg\", \"abc\"]);\n", "  });\n\t  test(\"abc\", () => {\n\t    expect(chunkAtEnd(\"abc\")).toEqual([\"c\", \"b\", \"a\"]);\n\t    expect(chunkAtEnd(\"abc\", 3)).toEqual([\"abc\"]);\n\t  });\n\t  test(\"00000001\", () => {\n\t    expect(chunkAtEnd(\"00000001\", 4)).toEqual([\"0001\", \"0000\"]);\n\t    expect(chunkAtEnd(\"00000001\", 2)).toEqual([\"01\", \"00\", \"00\", \"00\"]);\n\t  });\n\t  test(\"빈값\", () => {\n", "    expect(chunkAtEnd(\"\")).toEqual([]);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(400000).fill(\"0101\").join(\"\");\n\t    const result = new Array(400000).fill(['1', '0', '1', '0']).flat();\n\t    expect(chunkAtEnd(input, 1)).toEqual(result);\n\t  });\n\t});\n\tdescribe(\"makePercentByObject\", () => {\n\t  test(\"빈값\", () => {\n", "    expect(makePercentByObject({})).toEqual({});\n\t  });\n\t  test(\"3개 값\", () => {\n\t    expect(makePercentByObject({ a: 10, b: 20, c: 30 })).toEqual({\n\t      a: 16.67,\n\t      b: 33.33,\n\t      c: 50,\n\t    });\n\t  });\n\t  test(\"2개 값\", () => {\n", "    expect(makePercentByObject({ a: 0, b: 10 })).toEqual({ a: 0, b: 100 });\n\t  });\n\t});\n\tdescribe(\"reverseByObject\", () => {\n\t  test(\"Object\", () => {\n\t    expect(reverseByObject({ a: 1, b: 2, c: 3 })).toEqual({\n\t      1: \"a\",\n\t      2: \"b\",\n\t      3: \"c\",\n\t    });\n", "    expect(reverseByObject({ 1: \"a\", 2: \"b\", 3: \"c\" })).toEqual({\n\t      a: \"1\",\n\t      b: \"2\",\n\t      c: \"3\",\n\t    });\n\t    expect(reverseByObject([\"a\", \"b\", \"c\"])).toEqual({\n\t      a: \"0\",\n\t      b: \"1\",\n\t      c: \"2\",\n\t    });\n", "  });\n\t});\n\tdescribe(\"reverseByArray\", () => {\n\t  test(\"Array\", () => {\n\t    expect(\n\t      reverseByArray([\n\t        [[\"습니다\"], [\"다\", \"어\", \"음\"]],\n\t        [[\"입니다\"], [\"이다\"]],\n\t      ])\n\t    ).toEqual([\n", "      [[\"이다\"], [\"입니다\"]],\n\t      [[\"음\", \"어\", \"다\"], [\"습니다\"]],\n\t    ]);\n\t  });\n\t  test(\"Array\", () => {\n\t    expect(reverseByArray([1, 2, 3, [4, [5, 6, 7]]])).toEqual([\n\t      [[7, 6, 5], 4],\n\t      3,\n\t      2,\n\t      1,\n", "    ]);\n\t  });\n\t});\n"]}
{"filename": "test/convertKey.spec.ts", "chunked_list": ["import { convertKey } from \"../src/convertKey\";\n\tdescribe(\"convertKey\", () => {\n\t  test(\"영어로 변환\", () => {\n\t    expect(convertKey(\"안뇽 안뇽 그렇구만!\", \"en\")).toEqual(\"dkssyd dkssyd rmfjgrnaks!\");\n\t  });\n\t  test(\"한글로 변환\", () => {\n\t    expect(convertKey(\"dkssyd dkssyd rmfjgrnaks!\", \"ko\")).toEqual(\"안뇽 안뇽 그렇구만!\");\n\t  });\n\t  test(\"한글로 변환 - 합치기 X\", () => {\n\t    expect(convertKey(\"dkssyd dkssyd rmfjgrnaks!\", \"ko\", false)).toEqual(\"ㅇㅏㄴㄴㅛㅇ ㅇㅏㄴㄴㅛㅇ ㄱㅡㄹㅓㅎㄱㅜㅁㅏㄴ!\");\n", "  });\n\t  test(\"hello world!\", () => {\n\t    expect(convertKey(\"ㅗ디ㅣㅐ 재깅!\", \"en\")).toEqual(\"hello world!\");\n\t  });\n\t  test(\"ㅗ디ㅣㅐ 재깅!\", () => {\n\t    expect(convertKey(\"hello world!\", \"ko\")).toEqual(\"ㅗ디ㅣㅐ 재깅!\");\n\t  });\n\t  test(\"이상한 언어\", () => {\n\t    expect(convertKey(\"안뇽 안뇽 그렇구만!\", \"special\")).toEqual(\"안뇽 안뇽 그렇구만!\");\n\t  });\n", "  test(\"시간초과 테스트(영어)\", () => {\n\t    const input = new Array(1000000).fill(\"ㅗㄷㅣㅣㅐ ㅈㅐㄱㅣㅇ!\").join('')\n\t    const result = new Array(1000000).fill(\"hello world!\").join('');\n\t    expect(convertKey(input, \"en\")).toEqual(result);\n\t  });\n\t  test(\"시간초과 테스트(한국어)\", () => {\n\t    const input = new Array(1000000).fill(\"hello world!\").join('');\n\t    const result = new Array(1000000).fill(\"ㅗㄷㅣㅣㅐ ㅈㅐㄱㅣㅇ!\").join('')\n\t    expect(convertKey(input, \"ko\", false)).toEqual(result);\n\t  });\n", "});\n"]}
{"filename": "test/combine.spec.ts", "chunked_list": ["import { combine, combineByCode, combineHangul } from \"../src/combine\";\n\tdescribe(\"combineByCode\", () => {\n\t  test(\"빈값\", () => {\n\t    expect(combineByCode()).toEqual(\"가\");\n\t  });\n\t  test(\"이상한 값\", () => {\n\t    expect(combineByCode(-1, -1, -1)).toEqual(\"\");\n\t  });\n\t  test(\"깋\", () => {\n\t    expect(combineByCode(1, 0, -1)).toEqual(\"깋\");\n", "  });\n\t});\n\tdescribe(\"combine\", () => {\n\t  test(\"빈값\", () => {\n\t    expect(combine()).toEqual(\"\");\n\t  });\n\t  test(\"한글이 아닌 값\", () => {\n\t    expect(combine(\"a\")).toEqual(\"a\");\n\t  });\n\t  test(\"아\", () => {\n", "    expect(combine(\"ㅇ\", \"ㅏ\")).toEqual(\"아\");\n\t  });\n\t  test(\"안\", () => {\n\t    expect(combine(\"ㅇ\", \"ㅏ\", \"ㄴ\")).toEqual(\"안\");\n\t  });\n\t  test(\"뷁\", () => {\n\t    expect(combine(\"ㅂ\", \"ㅞ\", \"ㄺ\")).toEqual(\"뷁\");\n\t    expect(combine(\"ㅂ\", \"ㅜㅔ\", \"ㄹㄱ\")).toEqual(\"뷁\");\n\t  });\n\t});\n", "describe(\"combineHangul\", () => {\n\t  test(\"가나다\", () => {\n\t    expect(combineHangul(\"ㄱㅏㄴㅏㄷㅏ\")).toEqual(\"가나다\");\n\t  });\n\t  test(\"간나다\", () => {\n\t    expect(combineHangul(\"ㄱㅏㄴㄴㅏㄷㅏ\")).toEqual(\"간나다\");\n\t  });\n\t  test(\"값나다\", () => {\n\t    expect(combineHangul(\"ㄱㅏㅂㅅㄴㅏㄷㅏ\")).toEqual(\"값나다\");\n\t  });\n", "  test(\"값ㄴ나다\", () => {\n\t    expect(combineHangul(\"ㄱㅏㅂㅅㄴㄴㅏㄷㅏ\")).toEqual(\"값ㄴ나다\");\n\t  });\n\t  test(\"값ㅅㄴ나다\", () => {\n\t    expect(combineHangul(\"ㄱㅏㅂㅅㅅㄴㄴㅏㄷㅏ\")).toEqual(\"값ㅅㄴ나다\");\n\t  });\n\t  test(\"갑사ㅏㅅㄴ나다\", () => {\n\t    expect(combineHangul(\"ㄱㅏㅂㅅㅏㅏㅅㄴㄴㅏㄷㅏ\")).toEqual(\"갑사ㅏㅅㄴ나다\");\n\t  });\n\t  test(\"갑사산나다\", () => {\n", "    expect(combineHangul(\"ㄱㅏㅂㅅㅏㅅㅏㄴㄴㅏㄷㅏ\")).toEqual(\"갑사산나다\");\n\t  });\n\t  test(\"갑삿ㄴ나다\", () => {\n\t    expect(combineHangul(\"ㄱㅏㅂㅅㅏㅅㄴㄴㅏㄷㅏ\")).toEqual(\"갑삿ㄴ나다\");\n\t  });\n\t  test(\"갑삿ㄴ눼다\", () => {\n\t    expect(combineHangul(\"ㄱㅏㅂㅅㅏㅅㄴㄴㅜㅔㄷㅏ\")).toEqual(\"갑삿ㄴ눼다\");\n\t  });\n\t  test(\"수박\", () => {\n\t    expect(combineHangul(\"ㅅㅜㅂㅏㄱ\")).toEqual(\"수박\");\n", "  });\n\t  test(\"ㅗ디ㅣㅐ 재깅!\", () => {\n\t    expect(combineHangul(\"ㅗㄷㅣㅣㅐ ㅂㅏㅂㅗㅇ!\")).toEqual(\"ㅗ디ㅣㅐ 바봉!\");\n\t  });\n\t  test(\"ㅗ디ㅓㅕㅜㅠㅣㅐ 바봉!\", () => {\n\t    expect(combineHangul(\"ㅗㄷㅣㅓㅕㅜㅠㅣㅐ ㅂㅏㅂㅗㅇ!\")).toEqual(\n\t      \"ㅗ디ㅓㅕㅜㅠㅣㅐ 바봉!\"\n\t    );\n\t  });\n\t  test(\"ㅗ디ㅓㅇㅅㅎㅇㅇㅇ여ㅜㅠㅣㅐ 바봉\", () => {\n", "    expect(\n\t      combineHangul(\"ㅗㄷㅣㅓㅇㅅㅎㅇㅇㅇㅇㅕㅜㅠㅣㅐ ㅂㅏㅂㅗㅇ!\")\n\t    ).toEqual(\"ㅗ디ㅓㅇㅅㅎㅇㅇㅇ여ㅜㅠㅣㅐ 바봉!\");\n\t  });\n\t  test(\"빈값\", () => {\n\t    expect(combineHangul()).toEqual(\"\");\n\t  });\n\t  test(\"한글이 아닌 값\", () => {\n\t    expect(combineHangul(\"Ab!6k+@_ @\")).toEqual(\"Ab!6k+@_ @\");\n\t  });\n", "  test(\"안녕하세요\", () => {\n\t    expect(combineHangul([\"ㅇㅏㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ\"])).toEqual(\"안녕하세요\");\n\t    expect(combineHangul(\"ㅇㅏㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ\")).toEqual(\"안녕하세요\");\n\t    expect(combineHangul([[\"ㅇㅏㄴㅈ\"], [\"ㄴㅕㅇㅎㅏㅅㅔㅇㅛ\"]])).toEqual(\n\t      \"앉녕하세요\"\n\t    );\n\t    expect(combineHangul([[\"ㅇㅏㄴ\"], [\"ㅈㄴㅕㅇㅎㅏㅅㅔㅇㅛ\"]])).toEqual(\n\t      \"안ㅈ녕하세요\"\n\t    );\n\t    expect(combineHangul([\"ㅇㅏㄴㄴㅕㅇㅎㅏㅅㅔㅇㅛ\"])).toEqual(\"안녕하세요\");\n", "  });\n\t  test(\"모든 경우의 수\", () => {\n\t    expect(\n\t      combineHangul([\n\t        [\"ㅂㅜ\", \"ㅔ\", \"ㄹㄱ\"],\n\t        \"ㅅ\",\n\t        \"ㅗ\",\n\t        \"ㅐ\",\n\t        \"ㄹ\",\n\t        \"ㅁ\",\n", "        [\"ㅎㅜㅔㅂㅅ\"],\n\t        \"ㄱ\",\n\t        [\"ㅏ\", \"ㅅ\", \"ㅏ\"],\n\t      ])\n\t    ).toEqual(\"뷁쇎휎ㄱㅏ사\");\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(1000000).fill(\"ㄱㅏㅂㅅ\").join(\"\");\n\t    const result = new Array(1000000).fill(\"값\").join(\"\");\n\t    expect(combineHangul(input)).toEqual(result);\n", "  });\n\t});\n"]}
{"filename": "test/formatNumber.spec.ts", "chunked_list": ["import { formatNumber, formatNumberAll } from \"../src/formatNumber\";\n\tdescribe(\"formatNumber\", () => {\n\t  test(\"1234\", () => {\n\t    expect(formatNumber(1234)).toEqual(\"1234\");\n\t  });\n\t  test(\"12345678\", () => {\n\t    expect(formatNumber(\"12345678\")).toEqual(\"1234만 5678\");\n\t  });\n\t  test(\"0001\", () => {\n\t    expect(formatNumber(\"0001\")).toEqual(\"1\");\n", "  });\n\t  test(\"0001\", () => {\n\t    expect(formatNumber(123456789)).toEqual(\"1억 2345만 6789\");\n\t  });\n\t  test(\"0001\", () => {\n\t    expect(formatNumber(\"1234567890123456\")).toEqual(\n\t      \"1234조 5678억 9012만 3456\"\n\t    );\n\t  });\n\t  test(\"0001\", () => {\n", "    expect(formatNumber(\"0000000000000001\")).toEqual(\"1\");\n\t  });\n\t  test(\"숫자가 아닌 값\", () => {\n\t    expect(formatNumber(\"abc\")).toEqual(\"\");\n\t    expect(formatNumber(null)).toEqual(\"\");\n\t    expect(formatNumber(undefined)).toEqual(\"\");\n\t  });\n\t});\n\tdescribe(\"formatNumberAll\", () => {\n\t  test(\"1234\", () => {\n", "    expect(formatNumberAll(1234)).toEqual(\"천이백삼십사\");\n\t  });\n\t  test(\"12345678\", () => {\n\t    expect(formatNumberAll(\"12345678\")).toEqual(\n\t      \"천이백삼십사만 오천육백칠십팔\"\n\t    );\n\t  });\n\t  test(\"0001\", () => {\n\t    expect(formatNumberAll(\"0001\")).toEqual(\"일\");\n\t  });\n", "  test(\"123456789\", () => {\n\t    expect(formatNumberAll(123456789)).toEqual(\n\t      \"일억 이천삼백사십오만 육천칠백팔십구\"\n\t    );\n\t  });\n\t  test(\"1234567890123456\", () => {\n\t    expect(formatNumberAll(\"1234567890123456\")).toEqual(\n\t      \"천이백삼십사조 오천육백칠십팔억 구천십이만 삼천사백오십육\"\n\t    );\n\t  });\n", "  test(\"0000000000000001\", () => {\n\t    expect(formatNumberAll(\"0000000000000001\")).toEqual(\"일\");\n\t  });\n\t  test(\"숫자가 아닌 값\", () => {\n\t    expect(formatNumberAll(\"abc\")).toEqual(\"\");\n\t    expect(formatNumberAll(null)).toEqual(\"\");\n\t    expect(formatNumberAll(undefined)).toEqual(\"\");\n\t  });\n\t});\n"]}
{"filename": "test/isCho.spec.ts", "chunked_list": ["import { isChoByChar, isCho, isChoByGroups } from \"../src/isCho\";\n\tdescribe(\"isChoByChar\", () => {\n\t  test(\"ㄱ\", () => {\n\t    expect(isChoByChar(\"ㄱ\")).toEqual(true);\n\t  });\n\t  test(\"ㄴ\", () => {\n\t    expect(isChoByChar(\"ㄴ\")).toEqual(true);\n\t  });\n\t  test(\"ㅎ\", () => {\n\t    expect(isChoByChar(\"ㅎ\")).toEqual(true);\n", "  });\n\t  test(\"ㅏ\", () => {\n\t    expect(isChoByChar(\"ㅏ\")).toEqual(false);\n\t  });\n\t  test(\"ㅓ\", () => {\n\t    expect(isChoByChar(\"ㅓ\")).toEqual(false);\n\t  });\n\t  test(\"야\", () => {\n\t    expect(isChoByChar(\"야\")).toEqual(false);\n\t  });\n", "});\n\tdescribe(\"isCho\", () => {\n\t  test(\"빈값\", () => {\n\t    expect(isCho(\"\")).toEqual(false);\n\t  });\n\t  test(\"ㄱㅎㄴ\", () => {\n\t    expect(isCho(\"ㄱㅎㄴ\")).toEqual(true);\n\t  });\n\t  test(\"ㅎㅎㅎ\", () => {\n\t    expect(isCho(\"ㅎㅎㅎ\")).toEqual(true);\n", "  });\n\t  test(\"ㅎㄴa\", () => {\n\t    expect(isCho(\"ㅎㄴa\")).toEqual(false);\n\t  });\n\t  test(\"hello\", () => {\n\t    expect(isCho(\"hello\")).toEqual(false);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(1000000).fill('ㄱ').join('')\n\t    expect(isCho(input)).toEqual(true);\n", "  });\n\t});\n\tdescribe(\"isChoByGroups\", () => {\n\t  test(\"빈값\", () => {\n\t    expect(isChoByGroups(\"\")).toEqual([]);\n\t  });\n\t  test(\"ㄱㅎㄴ\", () => {\n\t    expect(isChoByGroups(\"ㄱㅎㄴ\")).toEqual([true, true, true]);\n\t  });\n\t  test(\"ㅎㄴa\", () => {\n", "    expect(isChoByGroups(\"ㅎㄴa\")).toEqual([true, true, false]);\n\t  });\n\t  test(\"ㅎㅏㄾㅆ\", () => {\n\t    expect(isChoByGroups(\"ㅎㅏㄾㅆ\")).toEqual([true, false, false, true]);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(1000000).fill('ㄱ').join('')\n\t    const result = new Array(1000000).fill(true);\n\t    expect(isChoByGroups(input)).toEqual(result);\n\t  });\n", "});\n"]}
{"filename": "test/isHangul.spec.ts", "chunked_list": ["import { isHangul, isHangulByCode, isHangulByGroups } from \"../src/isHangul\";\n\tdescribe(\"isHangulByCode\", () => {\n\t  test(\"조합된 한글 값\", () => {\n\t    expect(isHangulByCode(\"아\".charCodeAt(0))).toEqual(true);\n\t    expect(isHangulByCode(\"뷁\".charCodeAt(0))).toEqual(true);\n\t  });\n\t  test(\"조합된 한글 아닌 값\", () => {\n\t    expect(isHangulByCode(\"1\".charCodeAt(0))).toEqual(false);\n\t    expect(isHangulByCode(\"s\".charCodeAt(0))).toEqual(false);\n\t    expect(isHangulByCode(\"@\".charCodeAt(0))).toEqual(false);\n", "    expect(isHangulByCode(\"ㄱ\".charCodeAt(0))).toEqual(false);\n\t    expect(isHangulByCode(\"ㅏ\".charCodeAt(0))).toEqual(false);\n\t  });\n\t});\n\tdescribe(\"isHangul\", () => {\n\t  test(\"한글 값\", () => {\n\t    expect(isHangul(\"자\")).toEqual(true);\n\t    expect(isHangul(\"안녕하세요\")).toEqual(true);\n\t    expect(isHangul(\"자바스크립트\")).toEqual(true);\n\t  });\n", "  test(\"한글 아닌 값 포함\", () => {\n\t    expect(isHangul(\"Hello, world!\")).toEqual(false);\n\t    expect(isHangul(\"12345\")).toEqual(false);\n\t    expect(isHangul(\"안녕하세요, Hello, world!\")).toEqual(false);\n\t    expect(isHangul(\"Hello! 안녕!\")).toEqual(false);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(1000000).fill('값').join('')\n\t    expect(isHangul(input)).toEqual(true);\n\t  });\n", "});\n\tdescribe(\"isHangulByGroups\", () => {\n\t  test(\"안녕하세요\", () => {\n\t    expect(isHangulByGroups(\"안녕하세요\")).toEqual([\n\t      true,\n\t      true,\n\t      true,\n\t      true,\n\t      true,\n\t    ]);\n", "  });\n\t  test(\"자바스크립트.\", () => {\n\t    expect(isHangulByGroups(\"자바스크립트.\")).toEqual([\n\t      true,\n\t      true,\n\t      true,\n\t      true,\n\t      true,\n\t      true,\n\t      false,\n", "    ]);\n\t  });\n\t  test(\"Hello, 안녕!\", () => {\n\t    expect(isHangulByGroups(\"Hello, 안녕!\")).toEqual([\n\t      false,\n\t      false,\n\t      false,\n\t      false,\n\t      false,\n\t      false,\n", "      false,\n\t      true,\n\t      true,\n\t      false,\n\t    ]);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(1000000).fill('값').join('')\n\t    const result = new Array(1000000).fill(true);\n\t    expect(isHangulByGroups(input)).toEqual(result);\n", "  });\n\t});\n"]}
{"filename": "test/normalize.spec.ts", "chunked_list": ["import { normalize } from \"../src/normalize\";\n\tdescribe(\"normalize\", () => {\n\t  test(\"사과\", () => {\n\t    expect(normalize('사과')).toEqual('sa gwa');\n\t  });\n\t  test(\"이탈리아\", () => {\n\t    expect(normalize('이탈리아')).toEqual('i tar ri a');\n\t    expect(normalize('이탈리아', false)).toEqual('itarria');\n\t  });\n\t  test(\"그 외\", () => {\n", "    expect(normalize('그 외')).toEqual('geu oe');\n\t  });\n\t  test(\"사과! 그리고 sagwa!\", () => {\n\t    expect(normalize('사과! 그리고 sagwa!')).toEqual('sa gwa ! geu ri go sagwa!');\n\t    expect(normalize('사과! 그리고 sagwa!', false)).toEqual('sagwa! geurigo sagwa!');\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(100000).fill('사과! 그리고 sagwa!').join('');\n\t    const result = new Array(100000).fill('sa gwa ! geu ri go sagwa!').join('');  \n\t    expect(normalize(input)).toEqual(result);\n", "  });\n\t});\n"]}
{"filename": "test/josa.spec.ts", "chunked_list": ["import { formatJosa, josa } from \"../src/josa\";\n\tdescribe(\"formatJosa\", () => {\n\t  test(\"조사\", () => {\n\t    expect(josa(\"영희\", '는')).toEqual('는');\n\t  });\n\t});\n\tdescribe(\"formatJosa\", () => {\n\t  test(\"조사\", () => {\n\t    expect(formatJosa(\"I have an apple[은/는]\")).toEqual(\"I have an apple[은/는]\");\n\t    expect(formatJosa(\"[은/는]\")).toEqual(\"[은/는]\");\n", "    expect(formatJosa(\"영희[은/는]\")).toEqual(\"영희는\");\n\t    expect(formatJosa(\"인생[이란/란]\")).toEqual(\"인생이란\");\n\t    expect(formatJosa(\"인생[란/테스트]\")).toEqual(\"인생이란\");\n\t  });\n\t  test(\"빈값\", () => {\n\t    expect(formatJosa()).toEqual(\"\");\n\t  });\n\t});\n"]}
{"filename": "test/isJung.spec.ts", "chunked_list": ["import { isJungByCode, isJung, isJungByGroups } from \"../src/isJung\";\n\tdescribe(\"isJungByCode\", () => {\n\t  test(\"ㅏ\", () => {\n\t    expect(isJungByCode(\"ㅏ\".charCodeAt(0))).toEqual(true);\n\t  });\n\t  test(\"ㄱ\", () => {\n\t    expect(isJungByCode(\"ㄱ\".charCodeAt(0))).toEqual(false);\n\t  });\n\t  test(\"a\", () => {\n\t    expect(isJungByCode(\"a\".charCodeAt(0))).toEqual(false);\n", "  });\n\t});\n\tdescribe(\"isJung\", () => {\n\t  test(\"ㅏㅣㅜ\", () => {\n\t    expect(isJung(\"ㅏㅣㅜ\")).toEqual(true);\n\t  });\n\t  test(\"ㅏㄱㅣ \", () => {\n\t    expect(isJung(\"ㅏㄱㅣ\")).toEqual(false);\n\t  });\n\t  test(\"빈값\", () => {\n", "    expect(isJung(\"\")).toEqual(false);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(1000000).fill('ㅜ').join('')\n\t    expect(isJung(input)).toEqual(true);\n\t  });\n\t});\n\tdescribe(\"isJungByGroups\", () => {\n\t  test(\"ㅏㅣㅜ\", () => {\n\t    expect(isJungByGroups(\"ㅏㅣㅜ\")).toEqual([true, true, true]);\n", "  });\n\t  test(\"ㅏㄱㅣ\", () => {\n\t    expect(isJungByGroups(\"ㅏㄱㅣ\")).toEqual([true, false, true]);\n\t  });\n\t  test(\"빈값\", () => {\n\t    expect(isJungByGroups(\"\")).toEqual([]);\n\t  });\n\t  test(\"시간초과 테스트\", () => {\n\t    const input = new Array(1000000).fill('ㅏ').join('')\n\t    const result = new Array(1000000).fill(true);\n", "    expect(isJungByGroups(input)).toEqual(result);\n\t  });\n\t});\n"]}
{"filename": "src/encode.ts", "chunked_list": ["import { chunkAtEnd } from \"./utils\";\n\tconst a = [\n\t  escape,\n\t  (t: string) => chunkAtEnd(chunkAtEnd(t).join(\"\"), 3).join(\"\"),\n\t  (t: string) => chunkAtEnd(chunkAtEnd(t).join(\"\"), 4).join(\"\"),\n\t  (t: string) => chunkAtEnd(t).join(\"\"),\n\t  (t: string) =>\n\t    t\n\t      .split(\"\")\n\t      .map((v, i) => (i % 3 === 0 ? v + w() : v))\n", "      .join(\"\"),\n\t  (t: string) =>\n\t    t.slice(Math.floor(t.length / 2), t.length) +\n\t    t.slice(0, Math.floor(t.length / 2)),\n\t];\n\tconst s = JSON.stringify;\n\tconst b = btoa;\n\tconst e = encodeURI;\n\tconst w = (): any => Math.floor(Math.random() * (a.length));\n\texport function encode(t: any = \"\", l: number = 0): any {\n", "  const _t = w();\n\t  const c = l % 3 === 0 ? b(e(s(t))) : a[_t](t);\n\t  return l === 5\n\t    ? _t + b(e(c))\n\t    : encode((l % 2 === 1 ? _t : \"\") + c + (l % 2 === 0 ? _t : \"\"), l + 1);\n\t}\n\tconst n = [\n\t  unescape,\n\t  (t: string) => chunkAtEnd(chunkAtEnd(t).join(\"\"), 3).join(\"\"),\n\t  (t: string) => chunkAtEnd(chunkAtEnd(t).join(\"\"), 4).join(\"\"),\n", "  (t: string) => chunkAtEnd(t).join(\"\"),\n\t  (t: string) =>\n\t    t\n\t      .split(\"\")\n\t      .map((v, i) => ((i - 1) % 4 === 0 ? \"\" : v))\n\t      .join(\"\"),\n\t  (t: string) =>\n\t    t.slice(Math.ceil(t.length / 2), t.length) +\n\t    t.slice(0, Math.ceil(t.length / 2)),\n\t];\n", "const x = atob;\n\tconst d = decodeURI;\n\tconst p = JSON.parse;\n\texport function decode(t: any = \"\", l: number = 5): any {\n\t  const _t =\n\t    l % 2 === 1\n\t      ? [t.slice(1, t.length), t[0]]\n\t      : [t.slice(0, t.length - 1), t[t.length - 1]];\n\t  const h = l === 5 ? d(x(_t[0])) : _t[0];\n\t  const c = l % 3 === 0 ? p(d(x(h))) : n[_t[1]](h);\n", "  return l === 0 ? c : decode(c, l - 1);\n\t}\n"]}
{"filename": "src/normalize.ts", "chunked_list": ["import { NORMALIZE_CHO, NORMALIZE_JUNG, NORMALIZE_JONG } from \"./constant\";\n\timport { divideHangulByGroups } from \"./divide\";\n\ttype recordTypes = { cho: number; jung: number; jong: number };\n\texport function normalize(text: string, isSpace: boolean = true) {\n\t  const divided = divideHangulByGroups(text, {\n\t    isSplit: false,\n\t    resultType: \"index\",\n\t  }) as recordTypes[];\n\t  const space = isSpace ? \" \" : \"\";\n\t  return divided\n", "    .map((hangul: recordTypes) => {\n\t      const char =\n\t        NORMALIZE_CHO[hangul.cho] +\n\t        NORMALIZE_JUNG[hangul.jung] +\n\t        NORMALIZE_JONG[hangul.jong];\n\t      return char ? char + space : hangul;\n\t    })\n\t    .join(\"\")\n\t    .replace(/\\s{2,}/g, ' ')\n\t    .trim();\n", "}\n"]}
{"filename": "src/isCho.ts", "chunked_list": ["import { JONG_COMPLETE_HANGUL } from \"./constant\";\n\timport { isJongByCode } from \"./isJong\";\n\texport function isChoByChar(cho: string = \"\") {\n\t  return isJongByCode(cho.charCodeAt(0)) && !JONG_COMPLETE_HANGUL[cho];\n\t}\n\texport function isCho(word: string = \"\") {\n\t  for (let index = 0; index < word.length; index++) {\n\t    if (!isChoByChar(word[index])) return false;\n\t  }\n\t  return !!word;\n", "}\n\texport function isChoByGroups(word: string = \"\") {\n\t  return word.toString().split(\"\").map(isChoByChar);\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["export type LocalTypes = \"ko\" | \"en\" | \"number\" | \"special\" | \"etc\";\n\texport type DivideOptionTypes = {\n\t  isSplit?: boolean;\n\t  resultType?: \"object\" | \"string\" | \"array\" | \"index\";\n\t};\n\texport type TypingOptionTypes = {\n\t  content?: string;\n\t  speed?: number;\n\t};\n"]}
{"filename": "src/constant.ts", "chunked_list": ["export const CHO_HANGUL = [\n\t  'ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ',\n\t  'ㄹ', 'ㅁ', 'ㅂ','ㅃ', 'ㅅ',\n\t  'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ',\n\t  'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ',\n\t];\n\texport const JUNG_HANGUL = [\n\t  'ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', \n\t  'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', \n\t  'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', \n", "  'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ',\n\t];\n\texport const JONG_HANGUL = [\n\t  '', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', \n\t  'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', \n\t  'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', \n\t  'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ','ㅎ',\n\t];\n\texport const JUNG_COMPLETE_HANGUL: Record<string, string> = {\n\t  ㅘ: 'ㅗㅏ',\n", "  ㅙ: 'ㅗㅐ',\n\t  ㅚ: 'ㅗㅣ',\n\t  ㅝ: 'ㅜㅓ',\n\t  ㅞ: 'ㅜㅔ',\n\t  ㅟ: 'ㅜㅣ',\n\t  ㅢ: 'ㅡㅣ',\n\t};\n\texport const JONG_COMPLETE_HANGUL: Record<string, string> = {\n\t  ㄳ: 'ㄱㅅ',\n\t  ㄵ: 'ㄴㅈ',\n", "  ㄶ: 'ㄴㅎ',\n\t  ㄺ: 'ㄹㄱ',\n\t  ㄻ: 'ㄹㅁ',\n\t  ㄼ: 'ㄹㅂ',\n\t  ㄽ: 'ㄹㅅ',\n\t  ㄾ: 'ㄹㅌ',\n\t  ㄿ: 'ㄹㅍ',\n\t  ㅀ: 'ㄹㅎ',\n\t  ㅄ: 'ㅂㅅ',\n\t};\n", "export const JUNG_START_CHARCODE = JUNG_HANGUL[0].charCodeAt(0);\n\texport const JUNG_END_CHARCODE = JUNG_HANGUL[JUNG_HANGUL.length-1].charCodeAt(0);\n\texport const JONG_START_CHARCODE = JONG_HANGUL[1].charCodeAt(0);\n\texport const JONG_END_CHARCODE = JONG_HANGUL[JONG_HANGUL.length-1].charCodeAt(0);\n\texport const HANGUL_START_CHARCODE = '가'.charCodeAt(0);\n\texport const HANGUL_END_CHARCODE = '힣'.charCodeAt(0);\n\texport const CHO_PERIOD = '까'.charCodeAt(0) - '가'.charCodeAt(0);\n\texport const JONG_PERIOD = '개'.charCodeAt(0) - '가'.charCodeAt(0);\n\t// use covertKey function\n\texport const KEY_MAPS: Record<string, string> = {\n", "  ㅂ: \"q\", ㅃ: \"Q\", ㅈ: \"w\", ㅉ: \"W\",\n\t  ㄷ: \"e\", ㄸ: \"E\", ㄱ: \"r\", ㄲ: \"R\",\n\t  ㅅ: \"t\", ㅆ: \"T\", ㅛ: \"y\", ㅕ: \"u\",\n\t  ㅑ: \"i\", ㅐ: \"o\", ㅒ: \"O\", ㅔ: \"p\", \n\t  ㅖ: \"P\", ㅁ: \"a\", ㄴ: \"s\",ㅇ: \"d\",\n\t  ㄹ: \"f\", ㅎ: \"g\", ㅗ: \"h\",ㅓ: \"j\",\n\t  ㅏ: \"k\", ㅣ: \"l\", ㅋ: \"z\", ㅌ: \"x\",\n\t  ㅊ: \"c\", ㅍ: \"v\", ㅠ: \"b\", ㅜ: \"n\",\n\t  ㅡ: \"m\",\n\t};\n", "// use formatNumber function\n\texport const numberUnits = [\"\", \"일\", \"이\", \"삼\", \"사\", \"오\", \"육\", \"칠\", \"팔\", \"구\"];\n\texport const tenUnits = [\"\", \"십\", \"백\", \"천\"];\n\texport const thousandUnits = [\"\", \"만\", \"억\", \"조\", \"경\", \"해\"];\n\t// use formatDate function\n\texport const WEEK_DAY = [\"일\", \"월\", \"화\", \"수\", \"목\", \"금\", \"토\"];\n\t// use josa function\n\texport const JOSA_LIST: Record<string, string> = {\n\t  이: \"이/가\",\n\t  가: \"이/가\",\n", "  을: \"을/를\",\n\t  를: \"을/를\",\n\t  은: \"은/는\",\n\t  는: \"은/는\",\n\t  으로: \"으로/로\",\n\t  로: \"으로/로\",\n\t  와: \"와/과\",\n\t  과: \"와/과\",\n\t  이나: \"이나/나\",\n\t  나: \"이나/나\",\n", "  이에: \"이에/에\",\n\t  에: \"이에/에\",\n\t  이란: \"이란/란\",\n\t  란: \"이란/란\",\n\t}\n\t// use normalize function\n\texport const NORMALIZE_CHO = [\n\t  \"g\", \"gg\", \"n\", \"d\", \"dd\",\n\t  \"r\", \"m\", \"b\", \"bb\", \"s\",\n\t  \"ss\", \"\", \"j\", \"jj\", \"c\",\n", "  \"k\", \"t\", \"p\", \"h\"\n\t];\n\texport const NORMALIZE_JUNG = [\n\t \"a\", \"ae\", \"ya\", \"yae\", \"eo\",\n\t \"e\", \"yeo\", \"ye\", \"o\", \"wa\",\n\t \"wae\", \"oe\", \"yo\", \"u\", \"weo\",\n\t \"we\", \"wi\", \"yu\", \"eu\", \"eui\",\n\t \"i\"\n\t]\n\texport const NORMALIZE_JONG = [\n", "  \"\", \"g\", \"gg\", \"gs\", \"n\", \"nj\",\n\t  \"nh\", \"d\", \"r\", \"rk\", \"rm\", \n\t  \"rb\", \"rs\", \"rt\", \"rp\", \"rh\", \n\t  \"m\", \"b\", \"bs\", \"s\", \"ss\", \n\t  \"ng\", \"j\", \"c\", \"k\", \"t\", \n\t  \"p\", \"h\"\n\t]"]}
{"filename": "src/convertKey.ts", "chunked_list": ["import { combineHangul } from \"./combine\";\n\timport { KEY_MAPS } from \"./constant\";\n\timport { divideHangul } from \"./divide\";\n\timport { LocalTypes } from \"./types\";\n\timport { reverseByObject } from \"./utils\";\n\tconst REVERSE_MAPS: Record<string, string> = reverseByObject(KEY_MAPS);\n\tfunction toKo(english: string = \"\") {\n\t  return english\n\t    .toString()\n\t    .split(\"\")\n", "    .map((char) => REVERSE_MAPS[char] || char)\n\t    .join(\"\");\n\t}\n\tfunction toEn(korean: string = \"\") {\n\t  return korean\n\t    .toString()\n\t    .split(\"\")\n\t    .map((char) => KEY_MAPS[char] || char)\n\t    .join(\"\");\n\t}\n", "export function convertKey(\n\t  word: string = \"\",\n\t  toLanguage: LocalTypes = \"ko\",\n\t  isCombine: boolean = true\n\t) {\n\t  const hangul = (\n\t    isCombine ? divideHangul(word) : word.toString().split(\"\")\n\t  ).join(\"\");\n\t  // 한타로 변환\n\t  if (toLanguage === \"ko\") {\n", "    return isCombine ? combineHangul(toKo(hangul)) : toKo(hangul);\n\t  }\n\t  // 영타로 변환\n\t  if (toLanguage === \"en\") {\n\t    return toEn(hangul);\n\t  }\n\t  return word;\n\t}\n"]}
{"filename": "src/banmal.ts", "chunked_list": ["import { reverseByArray } from \"./utils\";\n\tconst FIRST_REGEX = /(\\s)?(^[가-힣]{0,3}|[가-힣]{1,3})(\\s*)/;\n\tconst LAST_REGEX = /([\\.|\\,|\\s])/;\n\tconst formater = [\n\t  [[\"습니다\"], [\"다\"]],\n\t  [[\"주세요\"], [\"라\"]],\n\t  [[\"입니다\"], [\"이다\"]],\n\t  [[\"합니다\"], [\"하다\"]],\n\t  [[\"옵니다\"], [\"온다\"]],\n\t  [[\"됩니다\"], [\"된다\"]],\n", "  [[\"갑니다\"], [\"간다\"]],\n\t  [[\"깁니다\"], [\"긴다\"]],\n\t  [[\"십니다\"], [\"신다\"]],\n\t  [[\"랍니다\"], [\"란다\"]],\n\t  [[\"저는\"], [\"나는\"]],\n\t];\n\tconst makeRegByFormater = (array: any) => {\n\t  const result: string[] = [];\n\t  array.forEach((caseList: any) => {\n\t    const case1List = caseList[0].map(\n", "      (case1: string) =>\n\t        new RegExp(FIRST_REGEX.source + case1 + LAST_REGEX.source, \"g\")\n\t    );\n\t    const list = case1List.reduce(\n\t      (acc2: RegExp[], regex: RegExp) =>\n\t        acc2.concat(\n\t          caseList[1].map((case2: string) => [\n\t            regex,\n\t            `$1;$2;$3;${case2.split(\"\").join(\";\")};$4`,\n\t          ])\n", "        ),\n\t      []\n\t    );\n\t    result.push(...list);\n\t  });\n\t  return result;\n\t};\n\tconst BANMAL_REGEX_LIST = makeRegByFormater(formater);\n\tconst HONORIFIC_REGEX_LIST = makeRegByFormater(reverseByArray(formater));\n\texport function toBanmal(string: string) {\n", "  return BANMAL_REGEX_LIST.reduce(\n\t    (acc: string, [$1, $2]: any) => acc.replace($1, $2),\n\t    string\n\t  ).replace(/;/g, \"\");\n\t}\n\texport function toHonorific(string: string) {\n\t  return HONORIFIC_REGEX_LIST.reduce(\n\t    (acc: string, [$1, $2]: any) => acc.replace($1, $2),\n\t    string\n\t  ).replace(/;/g, \"\");\n", "}\n"]}
{"filename": "src/isJong.ts", "chunked_list": ["import { JONG_START_CHARCODE, JONG_END_CHARCODE } from \"./constant\";\n\texport function isJongByCode(jong: number = 0) {\n\t  return JONG_START_CHARCODE <= jong && jong <= JONG_END_CHARCODE;\n\t}\n\texport function isJong(word: string = \"\") {\n\t  for (let index = 0; index < word.length; index++) {\n\t    if (!isJongByCode(word.charCodeAt(index))) return false;\n\t  }\n\t  return !!word;\n\t}\n", "export function isJongByGroups(word: string = \"\") {\n\t  const result: boolean[] = [];\n\t  for (let index = 0; index < word.length; index++) {\n\t    result.push(isJongByCode(word.charCodeAt(index)));\n\t  }\n\t  return result;\n\t}\n"]}
{"filename": "src/isHangul.ts", "chunked_list": ["import { HANGUL_END_CHARCODE, HANGUL_START_CHARCODE } from \"./constant\";\n\texport function isHangulByCode(hangul: number = 0) {\n\t  return HANGUL_START_CHARCODE <= hangul && hangul <= HANGUL_END_CHARCODE;\n\t}\n\texport function isHangul(word: string = \"\") {\n\t  for (let index = 0; index < word.length; index++) {\n\t    if (!isHangulByCode(word.charCodeAt(index))) return false;\n\t  }\n\t  return !!word;\n\t}\n", "export function isHangulByGroups(word: string = \"\") {\n\t  const result: boolean[] = [];\n\t  for (let index = 0; index < word.length; index++) {\n\t    result.push(isHangulByCode(word.charCodeAt(index)));\n\t  }\n\t  return result;\n\t}\n"]}
{"filename": "src/josa.ts", "chunked_list": ["import { HANGUL_START_CHARCODE, JONG_PERIOD, JOSA_LIST } from \"./constant\";\n\texport function josa(letter: string = \"\", _josa: string = \"이\") {\n\t  const hasJong =\n\t    (letter.charCodeAt(letter.length - 1) - HANGUL_START_CHARCODE) %\n\t      JONG_PERIOD >\n\t    0;\n\t  const josaIndex = hasJong ? 0 : 1;\n\t  const josa = _josa.replace(/\\[|\\]/g, \"\");\n\t  const josaCase = getJosaCasc(josa.split(\"/\")[0]) || josa;\n\t  return josaCase.split(\"/\")[josaIndex] ?? josa;\n", "}\n\t// 오늘[은/는] 사과[이/가]\n\texport function formatJosa(letter: string = \"\") {\n\t  return letter.replace(\n\t    /[가-힣]\\[[가-힣]+\\/[가-힣]+\\]/g,\n\t    (match) => match[0] + josa(match[0], match.slice(1))\n\t  );\n\t}\n\tfunction getJosaCasc(josa: string = \"\") {\n\t  return JOSA_LIST[josa] ?? josa;\n", "}\n"]}
{"filename": "src/isJung.ts", "chunked_list": ["import { JUNG_START_CHARCODE, JUNG_END_CHARCODE } from \"./constant\";\n\texport function isJungByCode(jung: number = 0) {\n\t  return JUNG_START_CHARCODE <= jung && jung <= JUNG_END_CHARCODE;\n\t}\n\texport function isJung(word: string = \"\") {\n\t  for (let index = 0; index < word.length; index++) {\n\t    if (!isJungByCode(word.charCodeAt(index))) return false;\n\t  }\n\t  return !!word;\n\t}\n", "export function isJungByGroups(word: string = \"\") {\n\t  const result: boolean[] = [];\n\t  for (let index = 0; index < word.length; index++) {\n\t    result.push(isJungByCode(word.charCodeAt(index)));\n\t  }\n\t  return result;\n\t}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["export function isNumber(input: any) {\n\t  return typeof input === \"number\" && !isNaN(input);\n\t}\n\texport function splitByKey(key: string = \"\"): string[] {\n\t  return key.match(/[ㄱ-힣a-zA-Z0-9]+/g) ?? ([] as any);\n\t}\n\texport function getNestedProperty(\n\t  key: string[] | string = [],\n\t  object: any = {}\n\t) {\n", "  const _key = typeof key === \"string\" ? splitByKey(key) : key;\n\t  if (!_key.length) return undefined;\n\t  return _key?.reduce((acc, v) => acc?.[v], object);\n\t}\n\texport function zeroPad(\n\t  string: number | string = \"\",\n\t  pow: number = 0,\n\t  pad: string = \"0\"\n\t) {\n\t  let result = String(string);\n", "  const padString = String(pad);\n\t  for (let i = pow - result.length; i > 0; i--) {\n\t    result = padString + result;\n\t  }\n\t  return result;\n\t}\n\texport function chunkAtEnd(value: string = \"\", n: number = 1) {\n\t  const result: string[] = [];\n\t  let start = value.length;\n\t  while ((start -= n) > 0) {\n", "    result.push(value.substring(start, start + n));\n\t  }\n\t  if (start > -n) {\n\t    result.push(value.substring(0, start + n));\n\t  }\n\t  return result;\n\t}\n\texport function makePercentByObject(object: any) {\n\t  const result: Record<string, number> = {};\n\t  let sum = 0;\n", "  for (const key in object) {\n\t    sum += object[key];\n\t  }\n\t  for (const key in object) {\n\t    if (isNumber(object[key])) {\n\t      result[key] = Number(((object[key] / sum) * 100).toFixed(2));\n\t    }\n\t  }\n\t  return result;\n\t}\n", "export function reverseByObject(object: any) {\n\t  const result: Record<string | number, string> = {};\n\t  for (const key in object) {\n\t    result[object[key]] = key;\n\t  }\n\t  return result;\n\t}\n\texport function reverseByArray(array: any) {\n\t  const result: any = [];\n\t  for (let index = 0; index < array.length; index++) {\n", "    if (Array.isArray(array[index])) {\n\t      array[index] = reverseByArray(array[index]);\n\t    }\n\t    result.unshift(array[index]);\n\t  }\n\t  return result;\n\t}"]}
{"filename": "src/index.ts", "chunked_list": ["export { isCho, isChoByGroups } from \"./isCho\";\n\texport { isJung, isJungByGroups } from \"./isJung\";\n\texport { isJong, isJongByGroups } from \"./isJong\";\n\texport { isHangul, isHangulByGroups } from \"./isHangul\";\n\texport {\n\t  divideByJong,\n\t  divideByJung,\n\t  divideHangul,\n\t  divideHangulByGroups\n\t} from \"./divide\";\n", "export {\n\t  combineHangul,\n\t  combineByJung,\n\t  combineByJong,\n\t} from \"./combine\";\n\texport * from \"./formatDate\";\n\texport * from \"./formatNumber\";\n\texport * from \"./josa\";\n\texport * from \"./banmal\";\n\texport * from \"./encode\";\n", "export * from './distance';\n\texport * from \"./includesByCho\";\n\texport * from \"./sortHangul\";\n\texport * from \"./getLocal\";\n\texport * from \"./convertKey\";\n\texport * from './normalize';\n\texport * from './utils';"]}
{"filename": "src/includesByCho.ts", "chunked_list": ["import { combineByCode } from \"./combine\";\n\timport { CHO_HANGUL } from \"./constant\";\n\texport function makeRegexByCho(search: string = \"\") {\n\t  const regex = CHO_HANGUL.reduce(\n\t    (acc: string, cho: string, index: number) =>\n\t      acc.replace(\n\t        new RegExp(cho, \"g\"),\n\t        `[${combineByCode(index, 0, 0)}-${combineByCode(index + 1, 0, -1)}]`\n\t      ),\n\t    search\n", "  );\n\t  return new RegExp(`(${regex})`, \"g\");\n\t}\n\texport function includesByCho(search: string = \"\", word: string = \"\") {\n\t  return makeRegexByCho(search).test(word);\n\t}\n"]}
{"filename": "src/sortHangul.ts", "chunked_list": ["import { splitByKey, getNestedProperty, reverseByObject } from \"./utils\";\n\tconst intlCollator = Intl.Collator();\n\tfunction baseCompare(str1: any, str2: any, orderASC: boolean) {\n\t  if (orderASC) {\n\t    return intlCollator.compare(str1, str2);\n\t  }\n\t  return intlCollator.compare(str2, str1);\n\t}\n\tfunction baseSortBy(\n\t  array: any[] = [],\n", "  compare?: string[] | string,\n\t  orderASC: boolean = true\n\t) {\n\t  if (Array.isArray(compare)) {\n\t    const keys = compare.map((x) => splitByKey(x));\n\t    return array.sort((a, b) => {\n\t      for (let i = 0; i < compare.length; i++) {\n\t        const result = baseCompare(\n\t          getNestedProperty(keys[i], a),\n\t          getNestedProperty(keys[i], b),\n", "          orderASC\n\t        );\n\t        if (result !== 0) return result;\n\t      }\n\t      return 0;\n\t    });\n\t  }\n\t  if (!compare) {\n\t    return array.sort((a, b) => baseCompare(a, b, orderASC));\n\t  }\n", "  const keys = splitByKey(compare);\n\t  return array.sort((a, b) =>\n\t    baseCompare(\n\t      getNestedProperty(keys, a),\n\t      getNestedProperty(keys, b),\n\t      orderASC\n\t    )\n\t  );\n\t}\n\texport function sortByASC(array: any[] = [], compare?: string[] | string) {\n", "  return baseSortBy(array, compare, true);\n\t}\n\texport function sortByDESC(array: any[] = [], compare?: string[] | string) {\n\t  return baseSortBy(array, compare, false);\n\t}\n\t/**\n\t * orderASC: true -> 오름차순\n\t * orderASC: false -> 내림차순\n\t */\n\texport function sortByGroups(\n", "  array: any[] = [],\n\t  groups: (number | string)[] = [],\n\t  orderASC: boolean = true,\n\t  compare?: string\n\t) {\n\t  const objectBygroup: any = reverseByObject(groups);\n\t  const keys = splitByKey(compare);\n\t  const mapped = array.map((item, index) => {\n\t    return { index, value: compare ? getNestedProperty(keys, item) : item };\n\t  });\n", "  const baseSortByGroups = (a: any, b: any) => {\n\t    const status1 = objectBygroup[a.value] ?? -1;\n\t    const status2 = objectBygroup[b.value] ?? -1;\n\t    const condition1 = orderASC ? status1 - status2 : status2 - status1;\n\t    const condition2 = baseCompare(a.value, b.value, orderASC);\n\t    if (status1 === status2) {\n\t      return condition2 || 0;\n\t    }\n\t    if (status1 === -1) {\n\t      return orderASC ? 1 : -1;\n", "    }\n\t    if (status2 === -1) {\n\t      return orderASC ? -1 : 1;\n\t    }\n\t    return condition1 || condition2 || 0;\n\t  };\n\t  return mapped.sort(baseSortByGroups).map((item) => array[item.index]);\n\t}\n"]}
{"filename": "src/distance.ts", "chunked_list": ["import { divideHangul } from \"./divide\";\n\timport { sortByASC } from \"./sortHangul\";\n\tfunction minBy(x1: number, x2: number, x3: number) {\n\t  return x1 > x2 ? (x2 > x3 ? x3 : x2) : x3 > x1 ? x1 : x3;\n\t}\n\tconst memo: any = {};\n\t// levenshtein distance\n\texport function getDistance(first: string, second: string): number {\n\t  if (first === second) return 0;\n\t  if (!first) return second.length;\n", "  if (!second) return first.length;\n\t  if (memo[first + '||' + second]) {\n\t    return memo[first + '||' + second];\n\t  }\n\t  const getDistance: number[][] = [[]];\n\t  // 초기값 설정\n\t  for (let j = 0; j <= second.length; j++) {\n\t    getDistance[0][j] = j;\n\t  }\n\t  for (let i = 1; i <= first.length; i++) {\n", "    getDistance[i] = [i];\n\t    for (let j = 1; j <= second.length; j++) {\n\t      getDistance[i][j] = minBy(\n\t        getDistance[i - 1][j] + 1,\n\t        getDistance[i][j - 1] + 1,\n\t        getDistance[i - 1][j - 1] + (first[i - 1] === second[j - 1] ? 0 : 1)\n\t      );\n\t    }\n\t  }\n\t  memo[first + '||' + second] = getDistance[first.length][second.length];\n", "  return getDistance[first.length][second.length];\n\t}\n\texport function correctByDistance(\n\t  word: string,\n\t  list: string[],\n\t  option?: { distance?: number; maxSlice?: number; isSplit?: boolean }\n\t) {\n\t  const distance = option?.distance ?? Math.max(word.length / 2, 2);\n\t  const maxSlice = option?.maxSlice ?? 10;\n\t  const isSplit = option?.isSplit ?? true;\n", "  const minDist = [];\n\t  const dividedWord = divideHangul(word, true).join(\"\");\n\t  for (let index = 0; index < list.length; index++) {\n\t    const dist = isSplit\n\t      ? getDistance(dividedWord, divideHangul(list[index], true).join(\"\"))\n\t      : getDistance(word, list[index]);\n\t    if (dist <= distance) {\n\t      minDist.push({ dist, word: list[index] });\n\t    }\n\t  }\n", "  return sortByASC(minDist, \"dist\")\n\t    .slice(0, maxSlice)\n\t    .map((item) => item.word);\n\t}\n"]}
{"filename": "src/divide.ts", "chunked_list": ["import {\n\t  CHO_HANGUL,\n\t  JUNG_HANGUL,\n\t  JONG_HANGUL,\n\t  JUNG_COMPLETE_HANGUL,\n\t  JONG_COMPLETE_HANGUL,\n\t  CHO_PERIOD,\n\t  JONG_PERIOD,\n\t  HANGUL_START_CHARCODE,\n\t} from \"./constant\";\n", "import { isHangulByCode } from \"./isHangul\";\n\timport { DivideOptionTypes } from \"./types\";\n\texport function divide(word: string = \"\", option: DivideOptionTypes = {}) {\n\t  const { isSplit, resultType } = option;\n\t  const wordCode = word.charCodeAt(0);\n\t  const charCode = wordCode - HANGUL_START_CHARCODE;\n\t  if (!isHangulByCode(wordCode)) {\n\t    return [word[0]];\n\t  }\n\t  const choIndex = Math.floor(charCode / CHO_PERIOD);\n", "  const jungIndex = Math.floor((charCode % CHO_PERIOD) / JONG_PERIOD);\n\t  const jongIndex = charCode % JONG_PERIOD;\n\t  const cho = CHO_HANGUL[choIndex] || \"\";\n\t  const jung = JUNG_HANGUL[jungIndex] || \"\";\n\t  const jong = JONG_HANGUL[jongIndex] || \"\";\n\t  // 더 세분하게 분리하기 ㅙ -> ㅗㅐ\n\t  const dividedJung = isSplit ? divideByJung(jung) : jung;\n\t  const dividedJong = isSplit ? divideByJong(jong) : jong;\n\t  if (resultType === \"index\") {\n\t    return { cho: choIndex, jung: jungIndex, jong: jongIndex };\n", "  }\n\t  if (resultType === \"object\") {\n\t    return { cho, jung: dividedJung, jong: dividedJong };\n\t  }\n\t  if (resultType === \"string\") {\n\t    return cho + dividedJung + dividedJong;\n\t  }\n\t  return (cho + dividedJung + dividedJong).split(\"\");\n\t}\n\texport function divideHangulByGroups(\n", "  word: string = \"\",\n\t  option: DivideOptionTypes = {}\n\t) {\n\t  const isSplit = option?.isSplit ?? true;\n\t  const resultType = option?.resultType ?? \"array\";\n\t  return word\n\t    .toString()\n\t    .split(\"\")\n\t    .map((char) => divide(char, { isSplit, resultType }));\n\t}\n", "export function divideHangul(word: string = \"\", isSplit: boolean = true) {\n\t  const divided = word\n\t    .toString()\n\t    .split(\"\")\n\t    .map((char) => divide(char, { isSplit, resultType: \"string\" }))\n\t    .join(\"\");\n\t  return divided.split(\"\");\n\t}\n\texport function divideByJung(jung: string) {\n\t  return JUNG_COMPLETE_HANGUL[jung] || jung;\n", "}\n\texport function divideByJong(jong: string) {\n\t  return JONG_COMPLETE_HANGUL[jong] || jong;\n\t}\n"]}
{"filename": "src/combine.ts", "chunked_list": ["import {\n\t  CHO_HANGUL,\n\t  CHO_PERIOD,\n\t  HANGUL_START_CHARCODE,\n\t  JONG_COMPLETE_HANGUL,\n\t  JONG_HANGUL,\n\t  JUNG_COMPLETE_HANGUL,\n\t  JUNG_HANGUL,\n\t  JONG_PERIOD,\n\t} from \"./constant\";\n", "import { reverseByObject } from \"./utils\";\n\timport { isCho } from \"./isCho\";\n\timport { isJung } from \"./isJung\";\n\timport { isJong } from \"./isJong\";\n\timport { isHangulByCode } from \"./isHangul\";\n\tconst fromCharCodeMemo: Record<number, string> = {};\n\texport function combineByCode(\n\t  cho: number = 0,\n\t  jung: number = 0,\n\t  jong: number = 0\n", ") {\n\t  const hangulCode =\n\t    HANGUL_START_CHARCODE + cho * CHO_PERIOD + jung * JONG_PERIOD + jong;\n\t  if (!isHangulByCode(hangulCode)) {\n\t    return \"\";\n\t  }\n\t  if (!fromCharCodeMemo[hangulCode]) {\n\t    fromCharCodeMemo[hangulCode] = String.fromCharCode(hangulCode);\n\t  }\n\t  return fromCharCodeMemo[hangulCode];\n", "}\n\texport function combine(\n\t  cho: string = \"\",\n\t  jung: string = \"\",\n\t  jong: string = \"\"\n\t) {\n\t  const combineJung = combineByJung(jung);\n\t  const combineJong = combineByJong(jong);\n\t  const choIndex = CHO_HANGUL.indexOf(cho);\n\t  const jungIndex = JUNG_HANGUL.indexOf(combineJung);\n", "  const jongIndex = JONG_HANGUL.indexOf(combineJong);\n\t  if (choIndex === -1 || jungIndex === -1 || jongIndex === -1) {\n\t    return cho || combineJung || combineJong;\n\t  }\n\t  return combineByCode(choIndex, jungIndex, jongIndex);\n\t}\n\tfunction combineLoop(wordList: string[]) {\n\t  let index = 0;\n\t  const result: string[] = [];\n\t  while (index < wordList.length) {\n", "    const first = wordList[index++];\n\t    const cho = isCho(first) ? first : \"\";\n\t    const jung = cho && isJung(wordList[index]) ? wordList[index++] : \"\";\n\t    // 초성 또는 중성 합쳐지지 않고, 종성 의미 X,\n\t    if (!cho || !jung) {\n\t      result.push(first);\n\t      continue;\n\t    }\n\t    // 중성이 없으면 소용 X\n\t    const subJung = JUNG_COMPLETE_HANGUL[combineByJung(jung + wordList[index])]\n", "      ? wordList[index++]\n\t      : \"\";\n\t    // 다음 문자에 모음이 안오는 경우 (합쳐질 가능성 존재)\n\t    const jong =\n\t      isJong(wordList[index]) && !isJung(wordList[index + 1])\n\t        ? wordList[index++]\n\t        : \"\";\n\t    // 두 문자 모두 초성이면서 (이미 합쳐진 문자 X - ㅄ, ㄺ X)\n\t    // 다음 문자에 모음이 안오는 경우 (합쳐질 가능성 존재)\n\t    const subJong =\n", "      JONG_COMPLETE_HANGUL[combineByJong(jong + wordList[index])] &&\n\t      !isJung(wordList[index + 1])\n\t        ? wordList[index++]\n\t        : \"\";\n\t    result.push(combine(cho, jung + subJung, jong + subJong));\n\t  }\n\t  return result.join(\"\");\n\t}\n\texport function combineHangul(str: string | (string | string[])[] = \"\") {\n\t  const word = typeof str === \"string\" ? str.toString().split(\"\") : str;\n", "  // Group 형식일 때, [ ['ㄱㅏ'], 'ㄴㅏ', ['ㄷ', 'ㅏ'] ]\n\t  const result: string[] = [];\n\t  const _temp: string[] = [];\n\t  for (let index = 0; index < word.length; index++) {\n\t    const item = word[index];\n\t    if (typeof item === \"string\") {\n\t      _temp.push(...item.toString().split(\"\"));\n\t    } else {\n\t      result.push(\n\t        combineLoop(_temp.splice(0)).concat(\n", "          combineLoop(item.join(\"\").split(\"\"))\n\t        )\n\t      );\n\t    }\n\t  }\n\t  result.push(combineLoop(_temp));\n\t  return result.join(\"\");\n\t}\n\tconst REVERSE_JUNG_COMPLETE = reverseByObject(JUNG_COMPLETE_HANGUL);\n\tconst REVERSE_JONG_COMPLETE = reverseByObject(JONG_COMPLETE_HANGUL);\n", "export function combineByJung(jung: string) {\n\t  return REVERSE_JUNG_COMPLETE[jung] || jung;\n\t}\n\texport function combineByJong(jong: string) {\n\t  return REVERSE_JONG_COMPLETE[jong] || jong;\n\t}\n"]}
{"filename": "src/formatNumber.ts", "chunked_list": ["import { chunkAtEnd, isNumber, zeroPad } from \"./utils\";\n\timport { numberUnits, tenUnits, thousandUnits } from \"./constant\";\n\texport function formatNumber(format: number | string | null = \"\") {\n\t  if (!isNumber(Number(format))) {\n\t    return \"\";\n\t  }\n\t  return chunkAtEnd(String(format), 4)\n\t    .reduce((acc, item, index) => {\n\t      const unit = thousandUnits[index] ?? \"\";\n\t      if (!Number(item)) {\n", "        return acc;\n\t      }\n\t      return `${Number(item)}${unit} ${acc}`;\n\t    }, \"\")\n\t    .trim();\n\t}\n\texport function formatNumberAll(format: number | string | null = \"\") {\n\t  if (!isNumber(Number(format))) {\n\t    return \"\";\n\t  }\n", "  return chunkAtEnd(String(format), 4)\n\t    .reduce((acc, item, index) => {\n\t      if (!Number(item)) {\n\t        return acc;\n\t      }\n\t      let numberUnit = \"\";\n\t      const zeroItem = zeroPad(item, 4);\n\t      for (let i = 0; i < 4; i++) {\n\t        const number = Number(zeroItem[i]);\n\t        if (number) {\n", "          const unit = tenUnits[3 - i];\n\t          numberUnit += `${\n\t            unit && number === 1 ? \"\" : numberUnits[number]\n\t          }${unit}`;\n\t        }\n\t      }\n\t      const thousandUnit = thousandUnits[index] ?? \"\";\n\t      return `${numberUnit}${numberUnit ? thousandUnit : \"\"} ${acc}`;\n\t    }, \"\")\n\t    .trim();\n", "}\n"]}
{"filename": "src/getLocal.ts", "chunked_list": ["import { LocalTypes } from \"./types\";\n\timport { makePercentByObject } from \"./utils\";\n\tconst LANGUAGE_REGEXP: Record<LocalTypes, RegExp> = {\n\t  ko: /^[가-힣|ㄱ-ㅎ|ㅏ-ㅣ|\\s]+$/,\n\t  en: /^[a-zA-Z|\\s]+$/,\n\t  number: /^[0-9]+$/,\n\t  special: /^[\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\_\\+\\-\\=\\\\\\|\\{\\}\\[\\]\\;\\:\\'\\\"\\<\\,\\.\\>\\/\\?\\s]+$/,\n\t  etc: /.*/,\n\t};\n\texport function getLocal(word: string = \"\") {\n", "  if (LANGUAGE_REGEXP[\"special\"].test(word)) {\n\t    return \"special\";\n\t  }\n\t  if (LANGUAGE_REGEXP[\"ko\"].test(word)) {\n\t    return \"ko\";\n\t  }\n\t  if (LANGUAGE_REGEXP[\"en\"].test(word)) {\n\t    return \"en\";\n\t  }\n\t  if (LANGUAGE_REGEXP[\"number\"].test(word)) {\n", "    return \"number\";\n\t  }\n\t  return \"etc\";\n\t}\n\texport function getLocalByGroups(\n\t  word: string = \"\",\n\t  isPercent: boolean = false,\n\t) {\n\t  const countObject = {\n\t    ko: 0,\n", "    en: 0,\n\t    number: 0,\n\t    special: 0,\n\t    etc: 0,\n\t  };\n\t  const result: string[] = [];\n\t  for (let index = 0; index < word.length; index++) {\n\t    const language = getLocal(word[index]);\n\t    if (isPercent) {\n\t      countObject[language]++;\n", "    } else {\n\t      result.push(language);\n\t    }\n\t  }\n\t  if (isPercent) {\n\t    return makePercentByObject(countObject);\n\t  }\n\t  return result;\n\t}\n"]}
{"filename": "src/formatDate.ts", "chunked_list": ["import { zeroPad } from \"./utils\";\n\timport { WEEK_DAY } from \"./constant\";\n\tconst DATE_REGEXER = /Y{2,4}|M{1,2}|D{1,2}|d{1,2}|H{1,2}|m{1,2}|s{1,2}/g;\n\t/**\n\t * @example\n\t * YY - 22, YYYY - 2022\n\t * M: 2, MM: 02,\n\t * D: 2, DD: 02,\n\t * d: 3, dd: '화',\n\t * H: 2, HH: 02,\n", " * m: 2, mm: 02,\n\t * s: 2, ss: 02,\n\t */\n\texport function formatDate(\n\t  _date: string | Date = new Date(),\n\t  formatStyle: string = \"YYYY년MM월DD일 HH시mm분ss초\"\n\t) {\n\t  const date = new Date(_date);\n\t  const year = zeroPad(date.getFullYear(), 4, \"0\");\n\t  const month = date.getMonth() + 1;\n", "  const day = date.getDate();\n\t  const hour = date.getHours();\n\t  const minute = date.getMinutes();\n\t  const second = date.getSeconds();\n\t  const week = date.getDay();\n\t  function matcher(match: string): any {\n\t    return (\n\t      {\n\t        YY: year.slice(-2),\n\t        YYYY: year,\n", "        M: month,\n\t        MM: zeroPad(month, 2, \"0\"),\n\t        D: day,\n\t        DD: zeroPad(day, 2, \"0\"),\n\t        d: week,\n\t        dd: WEEK_DAY[week],\n\t        H: hour,\n\t        HH: zeroPad(hour, 2, \"0\"),\n\t        m: minute,\n\t        mm: zeroPad(minute, 2, \"0\"),\n", "        s: second,\n\t        ss: zeroPad(second, 2, \"0\"),\n\t      }[match] || match\n\t    );\n\t  }\n\t  return (\n\t    formatStyle\n\t      .replace(DATE_REGEXER, matcher)\n\t      // \"년년\" 방지 -> \"년\"\n\t      .replace(/(년|월|일|시|분|초{1})(년|월|일|시|분|초{1})+/g, \"$1\")\n", "      .replace(/\\s+/g, \" \")\n\t  );\n\t}\n"]}
