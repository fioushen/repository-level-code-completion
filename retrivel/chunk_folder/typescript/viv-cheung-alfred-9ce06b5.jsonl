{"filename": "src/Commands.ts", "chunked_list": ["import { Command } from './types/Command'\n\timport Ping from './commands/Ping'\n\timport TicketGenerator from './commands/TicketGenerator'\n\timport CreateIssue from './commands/CreateIssue'\n\timport Summarize from './commands/Summarize'\n\t// List of all commands available to the bot\n\texport default [CreateIssue, Ping, TicketGenerator, Summarize] as Command[]\n"]}
{"filename": "src/bot.ts", "chunked_list": ["import { Client, GatewayIntentBits } from 'discord.js'\n\timport { DISCORD_BOT_TOKEN } from './config/config'\n\timport ready from './listeners/ready'\n\timport interactionCreate from './listeners/interactionCreate'\n\tconsole.log('Initiating bot ...')\n\t// Create client\n\tconst client = new Client({\n\t  intents: [\n\t    GatewayIntentBits.DirectMessages,\n\t    GatewayIntentBits.Guilds,\n", "    GatewayIntentBits.GuildMessages,\n\t    GatewayIntentBits.MessageContent,\n\t  ],\n\t})\n\t// Ready the client\n\tready(client)\n\t// Listen to interactions\n\tinteractionCreate(client)\n\t// Login bot\n\tclient.login(DISCORD_BOT_TOKEN)\n"]}
{"filename": "src/commands/Summarize.ts", "chunked_list": ["import { ChatInputCommandInteraction, Client, SlashCommandBuilder } from 'discord.js'\n\timport { Configuration, OpenAIApi } from 'openai'\n\timport { getMessageFromURL, replaceMessageUrls } from '../utils/discord'\n\timport { GPT_API_KEY } from '../config/config'\n\timport openAISettings from '../config/openAISettings'\n\timport { addConversation } from '../utils/openai'\n\t/*  ******SETTINGS****** */\n\tconst CONVERSATION_WORD_LIMIT = 3000 // Maximum number of words in conversation\n\t// Setup\n\tconst config = new Configuration({ apiKey: GPT_API_KEY })\n", "const openai = new OpenAIApi(config)\n\t// Command declaration\n\tconst summarizeCommandData = new SlashCommandBuilder()\n\t  .setName('summarize-ai')\n\t  .setDescription('Summarize the key points from a conversation starting with a message URL')\n\t  .addStringOption((option) => option\n\t    .setName('start_message')\n\t    .setDescription('URL of the message to start summarizing from')\n\t    .setRequired(true))\n\t// Will summarize conversations\n", "async function generateConversationSummary(discordClient: Client, conversation: string) {\n\t  if (conversation.trim().length === 0) {\n\t    throw new Error('Please enter valid information or conversation')\n\t  }\n\t  // Check if conversation is too long for GPT to handle in one call\n\t  if (conversation.split(' ').length > CONVERSATION_WORD_LIMIT) {\n\t    throw new Error(`\n\t        Not able to review the conversation because it exceeds the \n\t        word limit of ${CONVERSATION_WORD_LIMIT} (${conversation.split(' ').length} words)\n\t    `)\n", "  }\n\t  // Replace discord message urls with their actual message content\n\t  const noURLconversation = await replaceMessageUrls(discordClient, conversation)\n\t  // Send conversation to GPT with a summary prompt\n\t  const completion = await openai.createChatCompletion({\n\t    messages: [\n\t      { role: 'system', content: 'Please summarize the key points from the following conversation:' },\n\t      { role: 'user', content: noURLconversation },\n\t    ],\n\t    ...openAISettings,\n", "  } as any)\n\t  const summary = completion.data.choices[0].message?.content.toString()\n\t  if (summary) {\n\t    return summary\n\t  }\n\t  throw new Error('GPT response is unfortunately empty. Troubled servers perhaps?')\n\t}\n\texport default {\n\t  data: summarizeCommandData,\n\t  execute: async (discordClient: Client, interaction: ChatInputCommandInteraction) => {\n", "    // Get the starting message using the provided URL\n\t    const startMessage = await getMessageFromURL(discordClient, interaction.options.getString('start_message'))\n\t    // Find the channel where the conversation took place\n\t    const channel = await discordClient.channels.cache.get(interaction.channelId)\n\t    if (channel && channel.isTextBased()) {\n\t      // Start the conversation with the starting message\n\t      let conversation = addConversation(startMessage)\n\t      // Fetch the messages in the channel after the starting message and concatenate them\n\t      const messages = await channel.messages.fetch({ after: startMessage.id })\n\t      messages.reverse().forEach((message) => {\n", "        conversation += addConversation(message)\n\t      })\n\t      // Generate a summary of the conversation\n\t      const summary = await generateConversationSummary(discordClient, conversation)\n\t      // Send the summary back to the user\n\t      await interaction.followUp({\n\t        content: `Here's the summary of the conversation:\\n\\n${summary}`,\n\t        ephemeral: true,\n\t      })\n\t    }\n", "  },\n\t}\n"]}
{"filename": "src/commands/Ping.ts", "chunked_list": ["import { Client, CommandInteraction } from 'discord.js'\n\timport { SlashCommandBuilder } from '@discordjs/builders'\n\tconst pingCommandData = new SlashCommandBuilder()\n\t  .setName('ping')\n\t  .setDescription('Alfred will greet you')\n\texport default {\n\t  data: pingCommandData,\n\t  execute: async (client: Client, interaction: CommandInteraction) => {\n\t    const content = ':smile: *Why, hello!*'\n\t    await interaction.followUp({\n", "      ephemeral: true,\n\t      content,\n\t    })\n\t  },\n\t}\n"]}
{"filename": "src/commands/CreateIssue.ts", "chunked_list": ["import { ChatInputCommandInteraction, Client } from 'discord.js'\n\timport { SlashCommandBuilder } from '@discordjs/builders'\n\timport { Configuration, OpenAIApi } from 'openai'\n\timport { getOctokit, createIssue, getRepositoryLabels } from '../utils/github'\n\timport { AlfredGithubConfig, GPT_API_KEY } from '../config/config'\n\timport LabelsPrompt from '../prompts/LabelsPrompt'\n\timport openAISettings from '../config/openAISettings'\n\timport { AlfredResponse } from '../types/AlfredResponse'\n\t// TEMPORARY SETTINGS\n\tconst OWNER = 'viv-cheung'\n", "const REPO = 'alfred'\n\t// Setup\n\tconst configuration = new Configuration({ apiKey: GPT_API_KEY })\n\tconst openai = new OpenAIApi(configuration)\n\tconst octokit = getOctokit(AlfredGithubConfig)\n\t// Command\n\tconst createIssueCommandData = new SlashCommandBuilder()\n\t  .setName('create-issue-manual')\n\t  .setDescription('Create a GitHub issue')\n\t  .addStringOption((option) => option\n", "    .setName('title')\n\t    .setDescription('The title of the issue')\n\t    .setRequired(true))\n\t  .addStringOption((option) => option\n\t    .setName('content')\n\t    .setDescription('The body of the issue')\n\t    .setRequired(true))\n\t  .addBooleanOption((option) => option\n\t    .setName('ai-labels')\n\t    .setDescription('Let Alfred label the ticket?'))\n", "// Command to let the bot create a ticket\n\texport default {\n\t  data: createIssueCommandData,\n\t  execute: async (client: Client, interaction: ChatInputCommandInteraction): Promise<void> => {\n\t    const title = interaction.options.getString('title')\n\t    const body = interaction.options.getString('content')\n\t    const aiLabels = interaction.options.getBoolean('ai-labels') ?? true\n\t    // Labels proposed by Alfred\n\t    let proposedLabels: string[] | undefined\n\t    if (aiLabels) {\n", "      // Get Repository labels + definitions for auto-labeling\n\t      const labels = await getRepositoryLabels(await octokit, OWNER, REPO)\n\t      const alfredResponse = (await openai.createChatCompletion({\n\t        messages: [\n\t          { role: 'system', content: 'You will assign labels for the following github issue:' },\n\t          { role: 'user', content: `${title}: ${body}` },\n\t          { role: 'system', content: LabelsPrompt },\n\t          { role: 'system', content: labels },\n\t          { role: 'system', content: 'Reply with RFC8259 compliant JSON with a field called \"labels\"' },\n\t        ],\n", "        ...openAISettings,\n\t      } as any)).data.choices[0].message?.content.toString()\n\t      // Don't throw if smart labeling failed\n\t      try {\n\t        proposedLabels = (JSON.parse(alfredResponse!) as AlfredResponse).labels\n\t      } catch (e) {\n\t        console.log(`Can't assign labels: ${e}`)\n\t      }\n\t    }\n\t    // Create ticket\n", "    const url = await createIssue(await octokit, OWNER, REPO, title!, body!, proposedLabels)\n\t    // Send info back to discord\n\t    interaction.followUp({\n\t      content:\n\t          `**${title}**\\n`\n\t          + `:link: ${url}\\n`\n\t          + `:label: ${proposedLabels ?? ''}\\n`\n\t          + `\\`\\`\\`${body}\\`\\`\\``,\n\t      ephemeral: false,\n\t    })\n", "  },\n\t}\n"]}
{"filename": "src/commands/TicketGenerator.ts", "chunked_list": ["import {\n\t  Client, Message, SlashCommandBuilder, ChatInputCommandInteraction, ThreadChannel,\n\t} from 'discord.js'\n\timport { Configuration, OpenAIApi } from 'openai'\n\timport { GPT_API_KEY, AlfredGithubConfig } from '../config/config'\n\timport openAISettings from '../config/openAISettings'\n\timport { getOctokit, createIssue, getRepositoryLabels } from '../utils/github'\n\timport LabelsPrompt from '../prompts/LabelsPrompt'\n\timport PreConversationPrompt from '../prompts/PreConversationPrompt'\n\timport {\n", "  getMessageFromURL, mentionUser, replaceMessageUrls, replyOrFollowup, waitForUserResponse,\n\t} from '../utils/discord'\n\timport { AlfredResponse } from '../types/AlfredResponse'\n\timport AlfredRolePrompt from '../prompts/AlfredRolePrompt'\n\timport TicketRulesPrompt from '../prompts/TicketRulesPrompt'\n\timport { addConversation } from '../utils/openai'\n\t/*  ******SETTINGS****** */\n\tconst COUNT_QUESTION_LIMIT = 4 // Number of questions Alfred can ask\n\tconst CONVERSATION_WORD_LIMIT = 1500 // Maximum number of words in conversation\n\tconst TIMEOUT_WAITING_FOR_RESPONSE_LIMIT = 60000 // Time user has to reply to a question\n", "const USER_RESPONSE_COUNT_LIMIT = 1 // How many answers does Alfred wait for\n\t// TEMPORARY SETTINGS\n\tconst OWNER = 'viv-cheung'\n\tconst REPO = 'alfred'\n\t// Setup\n\tconst config = new Configuration({ apiKey: GPT_API_KEY })\n\tconst openai = new OpenAIApi(config)\n\tconst octokit = getOctokit(AlfredGithubConfig)\n\t// Core function\n\tasync function generateAlfredResponse(discordClient: Client, conversation: string) {\n", "  if (conversation.trim().length === 0) {\n\t    throw new Error('Please enter valid information or conversation')\n\t  }\n\t  // Check if conversation is too long for GPT to handle in one call\n\t  if (conversation.split(' ').length > CONVERSATION_WORD_LIMIT) {\n\t    throw new Error(`\n\t      Not able to review the conversation because it exceeds the \n\t      word limit of ${CONVERSATION_WORD_LIMIT} (${conversation.split(' ').length} words)\n\t    `)\n\t  }\n", "  // Replace discord message urls with their actual message content\n\t  const noURLconversation = await replaceMessageUrls(discordClient, conversation)\n\t  // Get Repository labels + definitions for auto-labeling\n\t  const labels = await getRepositoryLabels(await octokit, OWNER, REPO)\n\t  // Send all to chat GPT\n\t  const completion = await openai.createChatCompletion({\n\t    messages: [\n\t      { role: 'system', content: AlfredRolePrompt },\n\t      { role: 'system', content: PreConversationPrompt },\n\t      { role: 'user', content: noURLconversation },\n", "      { role: 'system', content: TicketRulesPrompt },\n\t      { role: 'system', content: LabelsPrompt },\n\t      { role: 'system', content: labels },\n\t    ],\n\t    ...openAISettings,\n\t  } as any)\n\t  const alfredResponse = completion.data.choices[0].message?.content.toString()\n\t  if (alfredResponse) {\n\t    return JSON.parse(alfredResponse) as AlfredResponse\n\t  }\n", "  throw new Error('GPT response is unfortunately empty. Troubled servers perhaps?')\n\t}\n\t// Build command\n\tconst generateTicketCommandData = new SlashCommandBuilder()\n\t  .setName('create-issue-ai')\n\t  .setDescription('Alfred will read conversation and create a ticket')\n\t  .addStringOption((option) => option\n\t    .setName('first_message')\n\t    .setDescription('URL of the first message Alfred should start from')\n\t    .setRequired(true))\n", "// Command to generate a GitHub Ticket\n\texport default {\n\t  data: generateTicketCommandData,\n\t  execute: async (discordClient: Client, interaction: ChatInputCommandInteraction) => {\n\t    let questionCount: number = 0 // Number of questions alfred asks\n\t    let responseThread: ThreadChannel | undefined\n\t    // Get the first message to start from (the Original Post)\n\t    const op = await getMessageFromURL(discordClient, interaction.options.getString('first_message'))\n\t    // Find the channel where the conversation took place\n\t    const channel = await discordClient.channels.cache.get(interaction.channelId)\n", "    if (channel && channel.isTextBased()) {\n\t      // Start the conversation with the OP\n\t      let conversation = addConversation(op)\n\t      // Fetch the messages in the channel after OP and concatenate them\n\t      const messages = await channel.messages.fetch({ after: op.id })\n\t      messages.reverse().forEach((message: Message<true> | Message<false>) => {\n\t        conversation += addConversation(message)\n\t      })\n\t      // Pass the messages from Discord to GPT model to create a response\n\t      let alfredResponse = await generateAlfredResponse(discordClient, conversation)\n", "      // If additional information is required from the user, Alfred will ask some questions to\n\t      // the user before creating the ticket, up to a point. To not pollute main channels,\n\t      // Alfred will create a thread to inquire further information.\n\t      while (alfredResponse.response_to_user !== 'I have all the information needed!' && questionCount < COUNT_QUESTION_LIMIT) {\n\t        await replyOrFollowup(\n\t          interaction,\n\t          questionCount > 1,\n\t          {\n\t            ephemeral: true,\n\t            content: `${mentionUser(interaction.user.id)} ${alfredResponse.response_to_user}`,\n", "          },\n\t          responseThread,\n\t        )\n\t        // Listen for user response in channel or thread\n\t        const responseMessage = await waitForUserResponse(\n\t          interaction.user.id,\n\t          USER_RESPONSE_COUNT_LIMIT,\n\t          TIMEOUT_WAITING_FOR_RESPONSE_LIMIT,\n\t          channel,\n\t          responseThread,\n", "        )\n\t        if (!responseMessage || responseMessage.size === 0) {\n\t          throw new Error('The waiting period for the response has timed out.')\n\t        }\n\t        // Append new response from user to conversation sent to GPT\n\t        conversation += `Alfred (you): ${alfredResponse.response_to_user}\\n`\n\t        conversation += addConversation(responseMessage?.first()!)\n\t        alfredResponse = await generateAlfredResponse(discordClient, conversation)\n\t        // Will make a thread for remaining interactions\n\t        if (!responseThread) {\n", "          responseThread = await responseMessage.last()?.startThread({\n\t            name: 'Alfred inquiries',\n\t            autoArchiveDuration: 60, // in minutes\n\t          })\n\t        }\n\t        questionCount += 1\n\t      }\n\t      // Create github ticket using alfred's response\n\t      const url = await createIssue(\n\t        await octokit,\n", "        OWNER,\n\t        REPO,\n\t        alfredResponse.title,\n\t        alfredResponse.body,\n\t        alfredResponse.labels,\n\t      )\n\t      await replyOrFollowup(\n\t        interaction,\n\t        questionCount > 1,\n\t        {\n", "          ephemeral: true,\n\t          content:\n\t            `**${alfredResponse.title}**\\n`\n\t            + `:link: ${url}\\n`\n\t            + `:label: ${alfredResponse.labels}\\n`\n\t            + `\\`\\`\\`${alfredResponse.body}\\`\\`\\``,\n\t        },\n\t        responseThread,\n\t      )\n\t    }\n", "  },\n\t}\n"]}
{"filename": "src/listeners/ready.ts", "chunked_list": ["import { Client } from 'discord.js'\n\timport Commands from '../Commands'\n\t// Check if the client is in a ready state\n\texport default (client: Client): void => {\n\t  client.on('ready', async () => {\n\t    if (!client.user || !client.application) {\n\t      return\n\t    }\n\t    await client.application.commands.set(Commands.map((command) => command.data.toJSON()))\n\t    console.log(`${client.user.username} is online`)\n", "  })\n\t}\n"]}
{"filename": "src/listeners/interactionCreate.ts", "chunked_list": ["import { CommandInteraction, Client, Interaction } from 'discord.js'\n\timport Commands from '../Commands'\n\timport safeExecute from '../utils/commands'\n\t// Slash command validation\n\tconst handleSlashCommand = async (\n\t  client: Client,\n\t  interaction: CommandInteraction,\n\t): Promise<void> => {\n\t  const slashCommand = Commands.find((c) => c.data.name === interaction.commandName)\n\t  if (!slashCommand) {\n", "    interaction.followUp({ content: 'Hm, I do not understand this command.' })\n\t    return\n\t  }\n\t  await interaction.deferReply()\n\t  safeExecute(slashCommand, client, interaction)\n\t}\n\t// Check if the message is a bot command\n\texport default (client: Client): void => {\n\t  client.on('interactionCreate', async (interaction: Interaction) => {\n\t    if (interaction.isCommand() || interaction.isContextMenuCommand()) {\n", "      await handleSlashCommand(client, interaction)\n\t    }\n\t  })\n\t}\n"]}
{"filename": "src/utils/config.ts", "chunked_list": ["// Get environment variables and enforces they aren't missing\n\texport default (key: string): string => {\n\t  const param = process.env[key]\n\t  if (!param || param === '' || param === '0') {\n\t    throw new Error(\n\t      `${key} is missing from your env file or is invalid.`,\n\t    )\n\t  }\n\t  return param\n\t}\n"]}
{"filename": "src/utils/commands.ts", "chunked_list": ["import { Client, CommandInteraction } from 'discord.js'\n\timport { Command } from '../types/Command'\n\texport default async function safeExecute(\n\t  command: Command,\n\t  client: Client,\n\t  interaction: CommandInteraction,\n\t) {\n\t  try {\n\t    await command.execute(client, interaction)\n\t  } catch (error) {\n", "    console.error(`Error while executing command ${command.data.name}:`, error)\n\t    await interaction.followUp({\n\t      content:\n\t       ':pensive: *I am terribly sorry, but it seems I\\'ve run into some trouble:*\\n'\n\t       + `:red_circle: **${error}**`,\n\t      ephemeral: true,\n\t    })\n\t  }\n\t}\n"]}
{"filename": "src/utils/discord.ts", "chunked_list": ["import {\n\t  ChatInputCommandInteraction,\n\t  Client,\n\t  Collection,\n\t  InteractionReplyOptions,\n\t  Message,\n\t  TextBasedChannel,\n\t  ThreadChannel,\n\t} from 'discord.js'\n\t// Regex for discord messages\n", "// e.g. https://discord.com/channels/1095842976/10969358/11023650\n\tconst messageUrlRegex = /https:\\/\\/discord\\.com\\/channels\\/(\\d+)\\/(\\d+)\\/(\\d+)/\n\t// Will get the message from a discord message URL\n\texport async function getMessageFromURL(client: Client, url: string | null) {\n\t  if (!url) throw new Error(\"Message URL can't be undefined\")\n\t  const matches = url.match(messageUrlRegex)\n\t  if (!matches) {\n\t    throw new Error('Invalid message URL. Expected discord/guild_id/channel_id/message_id')\n\t  }\n\t  const [, guildId, channelId, messageId] = matches\n", "  const guild = await client.guilds.cache.get(guildId)\n\t  if (!guild) throw new Error('Server not found')\n\t  const channel = await guild.channels.cache.get(channelId)\n\t  if (!channel) throw new Error('Channel not found')\n\t  if (!channel.isTextBased()) throw new Error('Channel is not text based')\n\t  const message = await channel.messages.fetch(messageId)\n\t  if (!message) throw new Error('Message not found')\n\t  return message\n\t}\n\t// Replace all discord message URLs with their actual message content\n", "export async function replaceMessageUrls(client: Client, conversation: string): Promise<string> {\n\t  const replacer = async (match: string) => {\n\t    const message = await getMessageFromURL(client, match)\n\t    return message.content\n\t  }\n\t  // Handle all message fetching in parallel\n\t  async function replaceAsync(str: string, regex: RegExp, asyncFn: Function): Promise<string> {\n\t    const globalRegex = new RegExp(regex.source, `${regex.flags}g`)\n\t    const matches = Array.from(str.matchAll(globalRegex))\n\t    const replacements = await Promise.all(matches.map((match) => asyncFn(match[0])))\n", "    return matches.reduce((result, match, i) => result.replace(match[0], `(((reference to an other message: ${replacements[i]})))`), str)\n\t  }\n\t  // Return conversation with replaced URLs\n\t  const replacedConversation = await replaceAsync(conversation, messageUrlRegex, replacer)\n\t  return replacedConversation\n\t}\n\t// To mention users in reply messages\n\texport function mentionUser(userID: string) {\n\t  return `<@${userID}>`\n\t}\n", "// Logic to simplify whether to use a reply or followup message\n\texport async function replyOrFollowup(\n\t  interaction: ChatInputCommandInteraction,\n\t  isReply: boolean,\n\t  reply: InteractionReplyOptions,\n\t  thread?: ThreadChannel,\n\t) {\n\t  // If in a thread, always just send message\n\t  if (thread) {\n\t    thread.send(reply.content!)\n", "  } else {\n\t    (isReply ? interaction.deferReply : interaction.followUp).bind(interaction)(reply)\n\t  }\n\t}\n\texport async function waitForUserResponse(\n\t  userID: string, // User ID\n\t  max: number, // Maximum number of responses\n\t  time: number, // How long Alfred waits for\n\t  channel: TextBasedChannel,\n\t  thread?: ThreadChannel,\n", "): Promise<Collection<string, Message>> {\n\t  const filter = (m: any) => m.author.id === userID\n\t  // Custom timeout promise to be used when the thread is not defined, so it doesn't blow up\n\t  const timeoutPromise = new Promise<Collection<string, Message>>(\n\t    // eslint-disable-next-line no-promise-executor-return\n\t    (resolve) => setTimeout(() => resolve(new Collection()), time + 1000),\n\t  )\n\t  // Listeners\n\t  const threadPromise = thread ? thread.awaitMessages({ filter, max, time }) : timeoutPromise\n\t  const channelPromise = channel.awaitMessages({ filter, max, time })\n", "  // Listen to both channel and thread in parallel and return the first reply in either\n\t  return Promise.race([channelPromise, threadPromise])\n\t}\n"]}
{"filename": "src/utils/openai.ts", "chunked_list": ["import { Collection, Message } from 'discord.js'\n\texport function addConversation(msg: Message) {\n\t  const attachments = msg.attachments.map((att) => att.url)\n\t  return `${msg.author.username}: ${msg.content} `\n\t    + `${attachments.length > 0 ? `[ATTACHMENTS: ${attachments}]` : ''}]\\n`\n\t}\n\texport function stackConversation(\n\t  msgs: Collection<string, Message<true>> | Collection<string, Message<false>>,\n\t) {\n\t  let conversation = ''\n", "  msgs.reverse().forEach((message: Message<true> | Message<false>) => {\n\t    conversation += addConversation(message)\n\t  })\n\t  return conversation\n\t}\n"]}
{"filename": "src/utils/github.ts", "chunked_list": ["import { createAppAuth } from '@octokit/auth-app'\n\timport { Octokit } from '@octokit/rest'\n\timport { AlfredGithubConfig } from '../types/AlfredGithubConfig'\n\t// Will create an octokit isntance based on Alfred's configuration\n\texport async function getOctokit(config: AlfredGithubConfig): Promise<Octokit> {\n\t  // Deconstruct config\n\t  const { installationId, ...options } = config\n\t  // Get auth for app\n\t  const auth = createAppAuth(options)\n\t  // Retrieve installation access token\n", "  const installationAuthentication = await auth({\n\t    type: 'installation',\n\t    installationId,\n\t  })\n\t  // Return ocktokit for specific app installation\n\t  return new Octokit({\n\t    auth: installationAuthentication.token,\n\t  })\n\t}\n\t// Will create an issue in specified repository\n", "export async function createIssue(\n\t  octokit: Octokit, // Octokit instance for that specific app installation\n\t  owner: string, // Owner of the repository\n\t  repo: string, // Name of the repository\n\t  title: string, // Issue title\n\t  body: string, // Content of the issue\n\t  labels?: string[], // Labels to assign to the issue\n\t): Promise<string> {\n\t  try {\n\t    const resp = await octokit.issues.create({\n", "      owner,\n\t      repo,\n\t      title,\n\t      body,\n\t      labels,\n\t    })\n\t    return resp.data.html_url\n\t  } catch (error) {\n\t    console.error('Error creating issue:', error)\n\t    throw new Error(`Failed to create issue: ${error}`)\n", "  }\n\t}\n\t// Will get the labels and their descriptions for a given repository\n\texport async function getRepositoryLabels(\n\t  octokit: Octokit, // Octokit instance for that specific app installation\n\t  owner: string, // Owner of the repository\n\t  repo: string, // Name of the repository\n\t): Promise<string> {\n\t  try {\n\t    const response = await octokit.issues.listLabelsForRepo({\n", "      owner,\n\t      repo,\n\t      per_page: 200,\n\t    })\n\t    const labels = response.data\n\t    // Build a string with all labels\n\t    let labelsString = ''\n\t    labels.forEach((label) => {\n\t      labelsString += `${label.name}: ${label.description} \\n`\n\t    })\n", "    return labelsString\n\t  } catch (error) {\n\t    console.error(\"Error fetching repo's labels:\", error)\n\t    throw new Error(`Error fetching repo's labels: ${error}`)\n\t  }\n\t}\n"]}
{"filename": "src/config/config.ts", "chunked_list": ["import dotenv from 'dotenv'\n\timport getEnvParameter from '../utils/config'\n\tdotenv.config()\n\t// Discord bot token\n\texport const DISCORD_BOT_TOKEN = getEnvParameter('DISCORD_BOT_TOKEN')\n\t// OpenAI GPT-4 API key\n\texport const GPT_API_KEY = getEnvParameter('GPT_API_KEY')\n\t// Github configs\n\tconst ALFRED_GIT_APP_ID = Number(getEnvParameter('ALFRED_GIT_APP_ID'))\n\tconst ALFRED_GIT_CLIENT_ID = getEnvParameter('ALFRED_GIT_CLIENT_ID')\n", "const ALFRED_GIT_INSTALLATION_ID = Number(getEnvParameter('ALFRED_GIT_INSTALLATION_ID'))\n\tconst ALFRED_GIT_CLIENT_SECRET = getEnvParameter('ALFRED_GIT_CLIENT_SECRET')\n\tconst ALFRED_GIT_PK = getEnvParameter('ALFRED_GIT_PK')\n\texport const AlfredGithubConfig = {\n\t  appId: ALFRED_GIT_APP_ID,\n\t  installationId: ALFRED_GIT_INSTALLATION_ID,\n\t  clientID: ALFRED_GIT_CLIENT_ID,\n\t  clientSecret: ALFRED_GIT_CLIENT_SECRET,\n\t  privateKey: ALFRED_GIT_PK,\n\t}\n"]}
{"filename": "src/config/openAISettings.ts", "chunked_list": ["export default {\n\t  model: 'gpt-4',\n\t  temperature: 0.5,\n\t  max_tokens: 1000,\n\t}\n"]}
{"filename": "src/prompts/TicketRulesPrompt.ts", "chunked_list": ["export default\n\t`\n\tNow that you have the conversation, you will reply based on the following rules:\n\tYou will respond in only a RFC8259 compliant JSON response following this format without deviation. The format is composed of the issue summary, issue title, the issue body, the issue's labels and the response to the user who requested a ticket.\n\tIf the issue you are creating is a bug or problem, you will use the following JSON RFC8259 template: \n\t{\n\t  \"title\": \"Give a title that summarizes the problem\",\"body\": \"# Problem statement\\nGive a problem statement that summarizes the issues outlined in the conversation. Describe the problem.\\n\\n# Solution\\nDescribe the desired solution agreed upon in the conversation input. You can also propose a solution, but make it clear that it's YOUR proposed solution by starting with '**🎩Alfred:**'.\\n\\n#QA Process\\nSummarize how a QA should test that the solution solves the problem\\n\\n# Additional Context\\nAdd any additional context you think would help resolve the issue.\", \"labels\": [\"Some label\"], \"response_to_user\": \"If there is insufficient information, unclear details, if the conversation is too general / generic or if there is confusion you don't know how to resolve, ask questions to the user. Otherwise, reply in a json format and reply EXACTLY with 'I have all the information needed!'\"\n\t}\n\tElse if it's a feature request. enhancement or task to do, you will use the following JSON RFC8259 template:\n\t{\n", "  \"title\": \"Give a title that summarizes the ticket\",\"body\": \"Start with a high level summary of the conversation and what needs to be done.\\n\\n# Specification\\nDescribe what needs to be done.\\n\\n# Rationale\\nSummarize why this needs to be done\\n\\n# Additional Context\\nAdd any additional context you think is relevant to help people complete the task.\", \"labels\": [\"Some label\"], \"response_to_user\": \"If there is insufficient information, unclear details, if the conversation is too general / generic or if there is confusion you don't know how to resolve, ask questions to the user. Otherwise, reply in a json format and reply EXACTLY with 'I have all the information needed!'\"\n\t}\n\tYou will also follow these requirements:\n\t- Be as consice as possible without losing information\n\t- Some messages may contain attachments. If they do, they will end with [ATTACHMENTS array_of_urls]. Embed all images in a new section called # Images at the end of the issue's body.\n\t- Don't hesitate to ask for further information if you believe it could lead to you writing a better ticket\n\t- VERY IMPORTANT: ONLY RETURN A RFC8259 compliant JSON AS A RESPONSE THAT CAN BE DIRECTLY PARSED, NOTHING ELSE. \n\t- Only add new lines (\"\\\\n\") within the body field of your response\n\t`\n"]}
{"filename": "src/prompts/LabelsPrompt.ts", "chunked_list": ["export default\n\t`\n\tAs for which label to assign in the 'labels' field of the JSON, please ONLY add labels present in the list below. Each label is accompanied with a description of what the label is for. \n\tAdd only the most relevant labels and if you aren't sure if a label is appropriate, don't add it.\n\tHere's the list of labels you can choose from;\n\t`\n"]}
{"filename": "src/prompts/PreConversationPrompt.ts", "chunked_list": ["export default\n\t`\n\tNow that you have the full context and directives, here's the conversation:\n\t`\n"]}
{"filename": "src/prompts/AlfredRolePrompt.ts", "chunked_list": ["export default\n\t`\n\tYou are Alfred, a gentle butler that help people create github tickets.\n\tYou will like a product manager, but with the personality of a kind and refined butler.\n\tI will give you a conversation between colleagues at a company.\n\tYou will create a github issue based on this conversation.\n\tThe GitHub ticket should contain all the necessary information for a developer, a product manager or a quality assurance tester to understand the feature request or bug report.\n\t`\n"]}
{"filename": "src/types/AlfredResponse.ts", "chunked_list": ["export interface AlfredResponse {\n\t  title: string, // Issue title\n\t  body: string, // Content of issue\n\t  labels: string[], // Labels assigned to issue\n\t  response_to_user: string // Alfred's response to user\n\t}\n"]}
{"filename": "src/types/Command.ts", "chunked_list": ["import { SlashCommandBuilder, CommandInteraction, Client } from 'discord.js'\n\texport interface Command {\n\t  data: SlashCommandBuilder;\n\t  execute: (client: Client, interaction: CommandInteraction) => Promise<void> ;\n\t}\n"]}
{"filename": "src/types/AlfredGithubConfig.ts", "chunked_list": ["export interface AlfredGithubConfig {\n\t  appId: number,\n\t  installationId: number,\n\t  clientID: string,\n\t  clientSecret: string,\n\t  privateKey: string\n\t}\n"]}
