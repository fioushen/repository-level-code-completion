{"filename": "build.config.ts", "chunked_list": ["import { defineBuildConfig } from 'unbuild';\n\texport default defineBuildConfig({\n\t  entries: ['src/index', 'src/cli'],\n\t  declaration: true,\n\t  clean: true,\n\t  rollup: {\n\t    emitCJS: true,\n\t    inlineDependencies: true\n\t  }\n\t});\n"]}
{"filename": "src/config.ts", "chunked_list": ["import { getCurrentGitBranch, getFirstGitCommit, getLastGitTag, isPrerelease } from './git';\n\timport { resolveRepoConfig } from './repo';\n\timport type { ChangelogOptions, ResolvedChangelogOptions } from './types';\n\tconst defaultConfig: ChangelogOptions = {\n\t  cwd: process.cwd(),\n\t  from: '',\n\t  to: '',\n\t  gitMainBranch: 'main',\n\t  scopeMap: {},\n\t  repo: {},\n", "  types: {\n\t    feat: { title: 'üöÄ Features' },\n\t    fix: { title: 'üêû Bug Fixes' },\n\t    perf: { title: 'üî• Performance' },\n\t    refactor: { title: 'üíÖ Refactors' },\n\t    docs: { title: 'üìñ Documentation' },\n\t    build: { title: 'üì¶ Build' },\n\t    types: { title: 'üåä Types' },\n\t    chore: { title: 'üè° Chore' },\n\t    examples: { title: 'üèÄ Examples' },\n", "    test: { title: '‚úÖ Tests' },\n\t    style: { title: 'üé® Styles' },\n\t    ci: { title: 'ü§ñ CI' }\n\t  },\n\t  titles: {\n\t    breakingChanges: 'üö® Breaking Changes'\n\t  },\n\t  tokens: {\n\t    github: process.env.CHANGELOGEN_TOKENS_GITHUB || process.env.GITHUB_TOKEN || process.env.GH_TOKEN\n\t  },\n", "  output: 'CHANGELOG.md',\n\t  contributors: true,\n\t  capitalize: true,\n\t  group: true\n\t};\n\texport async function resolveConfig(cwd: string, options: ChangelogOptions) {\n\t  const { loadConfig } = await import('c12');\n\t  const config = await loadConfig<ChangelogOptions>({\n\t    name: 'githublogen',\n\t    defaults: defaultConfig,\n", "    overrides: options\n\t  }).then(r => r.config || defaultConfig);\n\t  config.from = config.from || (await getLastGitTag());\n\t  config.to = config.to || (await getCurrentGitBranch());\n\t  config.repo = await resolveRepoConfig(cwd);\n\t  config.prerelease = config.prerelease ?? isPrerelease(config.to);\n\t  if (config.to === config.from) {\n\t    config.from = (await getLastGitTag(-1)) || (await getFirstGitCommit());\n\t  }\n\t  return config as ResolvedChangelogOptions;\n", "}\n"]}
{"filename": "src/types.ts", "chunked_list": ["export type SemverBumpType = 'major' | 'premajor' | 'minor' | 'preminor' | 'patch' | 'prepatch' | 'prerelease';\n\texport type RepoProvider = 'github' | 'gitlab' | 'bitbucket';\n\texport type RepoConfig = {\n\t  domain?: string;\n\t  repo?: string;\n\t  provider?: RepoProvider;\n\t  token?: string;\n\t};\n\texport interface ChangelogConfig {\n\t  cwd: string;\n", "  types: Record<string, { title: string; semver?: SemverBumpType }>;\n\t  scopeMap: Record<string, string>;\n\t  repo: RepoConfig;\n\t  tokens: Partial<Record<RepoProvider, string>>;\n\t  from: string;\n\t  to: string;\n\t  newVersion?: string;\n\t  output: string | boolean;\n\t  gitMainBranch: string;\n\t}\n", "export interface GitCommitAuthor {\n\t  name: string;\n\t  email: string;\n\t}\n\texport interface RawGitCommit {\n\t  message: string;\n\t  body: string;\n\t  shortHash: string;\n\t  author: GitCommitAuthor;\n\t}\n", "export interface Reference {\n\t  type: 'hash' | 'issue' | 'pull-request';\n\t  value: string;\n\t}\n\texport interface GithubOptions {\n\t  repo: string;\n\t  token: string;\n\t}\n\texport interface GithubRelease {\n\t  id?: string;\n", "  tag_name: string;\n\t  name?: string;\n\t  body?: string;\n\t  draft?: boolean;\n\t  prerelease?: boolean;\n\t}\n\texport interface GitCommit extends RawGitCommit {\n\t  description: string;\n\t  type: string;\n\t  scope: string;\n", "  references: Reference[];\n\t  authors: GitCommitAuthor[];\n\t  isBreaking: boolean;\n\t}\n\texport interface AuthorInfo {\n\t  commits: string[];\n\t  login?: string;\n\t  email: string;\n\t  name: string;\n\t}\n", "export interface Commit extends GitCommit {\n\t  resolvedAuthors?: AuthorInfo[];\n\t}\n\texport interface ChangelogOptions extends ChangelogConfig {\n\t  /**\n\t   * Dry run. Skip releasing to GitHub.\n\t   */\n\t  dry?: boolean;\n\t  /**\n\t   * Whether to include contributors in release notes.\n", "   *\n\t   * @default true\n\t   */\n\t  contributors?: boolean;\n\t  /**\n\t   * Name of the release\n\t   */\n\t  name?: string;\n\t  /**\n\t   * Mark the release as a draft\n", "   */\n\t  draft?: boolean;\n\t  /**\n\t   * Mark the release as prerelease\n\t   */\n\t  prerelease?: boolean;\n\t  /**\n\t   * Custom titles\n\t   */\n\t  titles?: {\n", "    breakingChanges?: string;\n\t  };\n\t  /**\n\t   * Capitalize commit messages\n\t   * @default true\n\t   */\n\t  capitalize?: boolean;\n\t  /**\n\t   * Nest commit messages under their scopes\n\t   * @default true\n", "   */\n\t  group?: boolean | 'multiple';\n\t  /**\n\t   * Use emojis in section titles\n\t   * @default true\n\t   */\n\t  emoji?: boolean;\n\t}\n\texport type ResolvedChangelogOptions = Required<ChangelogOptions>;\n"]}
{"filename": "src/git.ts", "chunked_list": ["import type { RawGitCommit, RepoConfig } from './types';\n\texport async function getGitHubRepo() {\n\t  const url = await execCommand('git', ['config', '--get', 'remote.origin.url']);\n\t  const match = url.match(/github\\.com[\\/:]([\\w\\d._-]+?)\\/([\\w\\d._-]+?)(\\.git)?$/i);\n\t  if (!match) {\n\t    throw new Error(`Can not parse GitHub repo from url ${url}`);\n\t  }\n\t  return `${match[1]}/${match[2]}`;\n\t}\n\texport async function getGitMainBranchName() {\n", "  const main = await execCommand('git', ['rev-parse', '--abbrev-ref', 'HEAD']);\n\t  return main;\n\t}\n\texport async function getCurrentGitBranch() {\n\t  const result1 = await execCommand('git', ['tag', '--points-at', 'HEAD']);\n\t  const main = getGitMainBranchName();\n\t  return result1 || main;\n\t}\n\texport async function isRepoShallow() {\n\t  return (await execCommand('git', ['rev-parse', '--is-shallow-repository'])).trim() === 'true';\n", "}\n\texport async function getLastGitTag(delta = 0) {\n\t  const tags = await execCommand('git', ['--no-pager', 'tag', '-l', '--sort=creatordate']).then(r => r.split('\\n'));\n\t  return tags[tags.length + delta - 1];\n\t}\n\texport async function isRefGitTag(to: string) {\n\t  const { execa } = await import('execa');\n\t  try {\n\t    await execa('git', ['show-ref', '--verify', `refs/tags/${to}`], { reject: true });\n\t    return true;\n", "  } catch {\n\t    return false;\n\t  }\n\t}\n\texport function getFirstGitCommit() {\n\t  return execCommand('git', ['rev-list', '--max-parents=0', 'HEAD']);\n\t}\n\texport function isPrerelease(version: string) {\n\t  return !/^[^.]*[\\d.]+$/.test(version);\n\t}\n", "async function execCommand(cmd: string, args: string[]) {\n\t  const { execa } = await import('execa');\n\t  const res = await execa(cmd, args);\n\t  return res.stdout.trim();\n\t}\n\texport async function getGitDiff(from: string | undefined, to = 'HEAD'): Promise<RawGitCommit[]> {\n\t  // https://git-scm.com/docs/pretty-formats\n\t  const r = await execCommand('git', [\n\t    '--no-pager',\n\t    'log',\n", "    `${from ? `${from}...` : ''}${to}`,\n\t    '--pretty=\"----%n%s|%h|%an|%ae%n%b\"',\n\t    '--name-status'\n\t  ]);\n\t  return r\n\t    .split('----\\n')\n\t    .splice(1)\n\t    .map(line => {\n\t      const [firstLine, ..._body] = line.split('\\n');\n\t      const [message, shortHash, authorName, authorEmail] = firstLine.split('|');\n", "      const $r: RawGitCommit = {\n\t        message,\n\t        shortHash,\n\t        author: { name: authorName, email: authorEmail },\n\t        body: _body.join('\\n')\n\t      };\n\t      return $r;\n\t    });\n\t}\n\texport function getGitRemoteURL(cwd: string, remote = 'origin') {\n", "  return execCommand('git', [`--work-tree=${cwd}`, 'remote', 'get-url', remote]);\n\t}\n\texport function getGitPushUrl(config: RepoConfig, token?: string) {\n\t  if (!token) return null;\n\t  return `https://${token}@${config.domain}/${config.repo}`;\n\t}\n"]}
{"filename": "src/repo.ts", "chunked_list": ["import { readPackageJSON } from 'pkg-types';\n\timport type { Reference, ChangelogConfig, RepoProvider, RepoConfig } from './types';\n\timport { getGitRemoteURL } from './git';\n\tconst providerToRefSpec: Record<RepoProvider, Record<Reference['type'], string>> = {\n\t  github: { 'pull-request': 'pull', hash: 'commit', issue: 'issues' },\n\t  gitlab: { 'pull-request': 'merge_requests', hash: 'commit', issue: 'issues' },\n\t  bitbucket: {\n\t    'pull-request': 'pull-requests',\n\t    hash: 'commit',\n\t    issue: 'issues'\n", "  }\n\t};\n\tconst providerToDomain: Record<RepoProvider, string> = {\n\t  github: 'github.com',\n\t  gitlab: 'gitlab.com',\n\t  bitbucket: 'bitbucket.org'\n\t};\n\tconst domainToProvider: Record<string, RepoProvider> = {\n\t  'github.com': 'github',\n\t  'gitlab.com': 'gitlab',\n", "  'bitbucket.org': 'bitbucket'\n\t};\n\t// https://regex101.com/r/NA4Io6/1\n\tconst providerURLRegex = /^(?:(?<user>\\w+)@)?(?:(?<provider>[^/:]+):)?(?<repo>\\w+\\/\\w+)(?:\\.git)?$/;\n\tfunction baseUrl(config: RepoConfig) {\n\t  return `https://${config.domain}/${config.repo}`;\n\t}\n\texport function formatReference(ref: Reference, repo?: RepoConfig) {\n\t  if (!repo?.provider || !(repo.provider in providerToRefSpec)) {\n\t    return ref.value;\n", "  }\n\t  const refSpec = providerToRefSpec[repo.provider];\n\t  return `[${ref.value}](${baseUrl(repo)}/${refSpec[ref.type]}/${ref.value.replace(/^#/, '')})`;\n\t}\n\texport function formatCompareChanges(v: string, config: ChangelogConfig) {\n\t  const part = config.repo?.provider === 'bitbucket' ? 'branches/compare' : 'compare';\n\t  return `[compare changes](${baseUrl(config.repo)}/${part}/${config.from}...${v || config.to})`;\n\t}\n\texport async function resolveRepoConfig(cwd: string) {\n\t  // Try closest package.json\n", "  const pkg = await readPackageJSON(cwd).catch(() => {});\n\t  if (pkg && pkg.repository) {\n\t    const url = typeof pkg.repository === 'string' ? pkg.repository : pkg.repository.url;\n\t    return getRepoConfig(url);\n\t  }\n\t  const gitRemote = await getGitRemoteURL(cwd).catch(() => {});\n\t  if (gitRemote) {\n\t    return getRepoConfig(gitRemote);\n\t  }\n\t  return {};\n", "}\n\texport function getRepoConfig(repoUrl = ''): RepoConfig {\n\t  let provider: RepoProvider | undefined;\n\t  let repo: string | undefined;\n\t  let domain: string | undefined;\n\t  let url: URL | undefined;\n\t  try {\n\t    url = new URL(repoUrl);\n\t  } catch {}\n\t  const m = repoUrl.match(providerURLRegex)?.groups ?? {};\n", "  if (m.repo && m.provider) {\n\t    repo = m.repo;\n\t    provider = m.provider in domainToProvider ? domainToProvider[m.provider] : (m.provider as RepoProvider);\n\t    domain = provider in providerToDomain ? providerToDomain[provider] : provider;\n\t  } else if (url) {\n\t    domain = url.hostname;\n\t    repo = url.pathname\n\t      .split('/')\n\t      .slice(1, 3)\n\t      .join('/')\n", "      .replace(/\\.git$/, '');\n\t    provider = domainToProvider[domain];\n\t  } else if (m.repo) {\n\t    repo = m.repo;\n\t    provider = 'github';\n\t    domain = providerToDomain[provider];\n\t  }\n\t  return {\n\t    provider,\n\t    repo,\n", "    domain\n\t  };\n\t}\n"]}
{"filename": "src/shared.ts", "chunked_list": ["type PartitionFilter<T> = (i: T, idx: number, arr: readonly T[]) => any;\n\t/**\n\t * Divide an array into two parts by a filter function\n\t * @category Array\n\t * @example const [odd, even] = partition([1, 2, 3, 4], i => i % 2 != 0)\n\t */\n\texport function partition<T>(array: readonly T[], f1: PartitionFilter<T>): [T[], T[]];\n\texport function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>): [T[], T[], T[]];\n\texport function partition<T>(\n\t  array: readonly T[],\n", "  f1: PartitionFilter<T>,\n\t  f2: PartitionFilter<T>,\n\t  f3: PartitionFilter<T>\n\t): [T[], T[], T[], T[]];\n\texport function partition<T>(\n\t  array: readonly T[],\n\t  f1: PartitionFilter<T>,\n\t  f2: PartitionFilter<T>,\n\t  f3: PartitionFilter<T>,\n\t  f4: PartitionFilter<T>\n", "): [T[], T[], T[], T[], T[]];\n\texport function partition<T>(\n\t  array: readonly T[],\n\t  f1: PartitionFilter<T>,\n\t  f2: PartitionFilter<T>,\n\t  f3: PartitionFilter<T>,\n\t  f4: PartitionFilter<T>,\n\t  f5: PartitionFilter<T>\n\t): [T[], T[], T[], T[], T[], T[]];\n\texport function partition<T>(\n", "  array: readonly T[],\n\t  f1: PartitionFilter<T>,\n\t  f2: PartitionFilter<T>,\n\t  f3: PartitionFilter<T>,\n\t  f4: PartitionFilter<T>,\n\t  f5: PartitionFilter<T>,\n\t  f6: PartitionFilter<T>\n\t): [T[], T[], T[], T[], T[], T[], T[]];\n\texport function partition<T>(array: readonly T[], ...filters: PartitionFilter<T>[]): any {\n\t  const result: T[][] = new Array(filters.length + 1).fill(null).map(() => []);\n", "  array.forEach((e, idx, arr) => {\n\t    let i = 0;\n\t    for (const filter of filters) {\n\t      if (filter(e, idx, arr)) {\n\t        result[i].push(e);\n\t        return;\n\t      }\n\t      i += 1;\n\t    }\n\t    result[i].push(e);\n", "  });\n\t  return result;\n\t}\n\texport function notNullish<T>(v?: T | null): v is NonNullable<T> {\n\t  return v !== null && v !== undefined;\n\t}\n\texport function groupBy<T>(items: T[], key: string, groups: Record<string, T[]> = {}) {\n\t  for (const item of items) {\n\t    const v = (item as any)[key] as string;\n\t    groups[v] = groups[v] || [];\n", "    groups[v].push(item);\n\t  }\n\t  return groups;\n\t}\n\texport function capitalize(str: string) {\n\t  return str.charAt(0).toUpperCase() + str.slice(1);\n\t}\n\texport function join(array?: string[], glue = ', ', finalGlue = ' and '): string {\n\t  if (!array || array.length === 0) return '';\n\t  if (array.length === 1) return array[0];\n", "  if (array.length === 2) return array.join(finalGlue);\n\t  return `${array.slice(0, -1).join(glue)}${finalGlue}${array.slice(-1)}`;\n\t}\n\texport function upperFirst(string?: string) {\n\t  return !string ? '' : string[0].toUpperCase() + string.slice(1);\n\t}\n"]}
{"filename": "src/cli.ts", "chunked_list": ["#!/usr/bin/env node\n\timport { blue, bold, cyan, dim, red, yellow } from 'kolorist';\n\timport cac from 'cac';\n\timport { version } from '../package.json';\n\timport { generate } from './generate';\n\timport { hasTagOnGitHub, sendRelease } from './github';\n\timport { isRepoShallow } from './git';\n\timport type { ChangelogOptions } from './types';\n\tconst cli = cac('githublogen');\n\tcli\n", "  .version(version)\n\t  .option('-t, --token <path>', 'GitHub Token')\n\t  .option('--from <ref>', 'From tag')\n\t  .option('--to <ref>', 'To tag')\n\t  .option('--github <path>', 'GitHub Repository, e.g. soybeanjs/githublogen')\n\t  .option('--name <name>', 'Name of the release')\n\t  .option('--contributors', 'Show contributors section')\n\t  .option('--prerelease', 'Mark release as prerelease')\n\t  .option('-d, --draft', 'Mark release as draft')\n\t  .option('--output <path>', 'Output to file instead of sending to GitHub')\n", "  .option('--capitalize', 'Should capitalize for each comment message')\n\t  .option('--emoji', 'Use emojis in section titles', { default: true })\n\t  .option('--group', 'Nest commit messages under their scopes')\n\t  .option('--dry', 'Dry run')\n\t  .help();\n\tcli.command('').action(async (args: any) => {\n\t  try {\n\t    console.log();\n\t    console.log(dim(`${bold('github')}logen `) + dim(`v${version}`));\n\t    const cwd = process.cwd();\n", "    const { config, md, commits } = await generate(cwd, args as unknown as ChangelogOptions);\n\t    const markdown = md.replace(/&nbsp;/g, '');\n\t    console.log(cyan(config.from) + dim(' -> ') + blue(config.to) + dim(` (${commits.length} commits)`));\n\t    console.log(dim('--------------'));\n\t    console.log();\n\t    console.log(markdown);\n\t    console.log();\n\t    console.log(dim('--------------'));\n\t    if (config.dry) {\n\t      console.log(yellow('Dry run. Release skipped.'));\n", "      return;\n\t    }\n\t    if (!(await hasTagOnGitHub(config.to, config))) {\n\t      console.error(yellow(`Current ref \"${bold(config.to)}\" is not available as tags on GitHub. Release skipped.`));\n\t      process.exitCode = 1;\n\t      return;\n\t    }\n\t    if (!commits.length && (await isRepoShallow())) {\n\t      console.error(\n\t        yellow(\n", "          'The repo seems to be clone shallowly, which make changelog failed to generate. You might want to specify `fetch-depth: 0` in your CI config.'\n\t        )\n\t      );\n\t      process.exitCode = 1;\n\t      return;\n\t    }\n\t    await sendRelease(config, md);\n\t  } catch (e: any) {\n\t    console.error(red(String(e)));\n\t    if (e?.stack) {\n", "      console.error(dim(e.stack?.split('\\n').slice(1).join('\\n')));\n\t    }\n\t    process.exit(1);\n\t  }\n\t});\n\tcli.parse();\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './types';\n\texport * from './github';\n\texport * from './git';\n\texport * from './markdown';\n\texport * from './generate';\n\texport * from './config';\n\texport * from './parse';\n"]}
{"filename": "src/generate.ts", "chunked_list": ["import { getGitDiff } from './git';\n\timport { generateMarkdown } from './markdown';\n\timport { resolveAuthors } from './github';\n\timport { resolveConfig } from './config';\n\timport { parseCommits } from './parse';\n\timport type { ChangelogOptions } from './types';\n\texport async function generate(cwd: string, options: ChangelogOptions) {\n\t  const resolved = await resolveConfig(cwd, options);\n\t  const rawCommits = await getGitDiff(resolved.from, resolved.to);\n\t  const commits = parseCommits(rawCommits, resolved);\n", "  if (resolved.contributors) {\n\t    await resolveAuthors(commits, resolved);\n\t  }\n\t  const md = generateMarkdown(commits, resolved);\n\t  return { config: resolved, md, commits };\n\t}\n"]}
{"filename": "src/github.ts", "chunked_list": ["import { $fetch } from 'ohmyfetch';\n\timport { cyan, green, red, yellow } from 'kolorist';\n\timport { notNullish } from './shared';\n\timport type { AuthorInfo, ChangelogOptions, Commit } from './types';\n\texport async function sendRelease(options: ChangelogOptions, content: string) {\n\t  const headers = getHeaders(options);\n\t  const github = options.repo.repo!;\n\t  let url = `https://api.github.com/repos/${github}/releases`;\n\t  let method = 'POST';\n\t  try {\n", "    const exists = await $fetch(`https://api.github.com/repos/${github}/releases/tags/${options.to}`, {\n\t      headers\n\t    });\n\t    if (exists.url) {\n\t      url = exists.url;\n\t      method = 'PATCH';\n\t    }\n\t  } catch (e) {}\n\t  const body = {\n\t    body: content,\n", "    draft: options.draft || false,\n\t    name: options.name || options.to,\n\t    prerelease: options.prerelease,\n\t    tag_name: options.to\n\t  };\n\t  const webUrl = `https://github.com/${github}/releases/new?title=${encodeURIComponent(\n\t    String(body.name)\n\t  )}&body=${encodeURIComponent(String(body.body))}&tag=${encodeURIComponent(String(options.to))}&prerelease=${\n\t    options.prerelease\n\t  }`;\n", "  try {\n\t    console.log(cyan(method === 'POST' ? 'Creating release notes...' : 'Updating release notes...'));\n\t    const res = await $fetch(url, {\n\t      method,\n\t      body: JSON.stringify(body),\n\t      headers\n\t    });\n\t    console.log(green(`Released on ${res.html_url}`));\n\t  } catch (e) {\n\t    console.log();\n", "    console.error(red('Failed to create the release. Using the following link to create it manually:'));\n\t    console.error(yellow(webUrl));\n\t    console.log();\n\t    throw e;\n\t  }\n\t}\n\tfunction getHeaders(options: ChangelogOptions) {\n\t  return {\n\t    accept: 'application/vnd.github.v3+json',\n\t    authorization: `token ${options.tokens.github}`\n", "  };\n\t}\n\texport async function resolveAuthorInfo(options: ChangelogOptions, info: AuthorInfo) {\n\t  if (info.login) return info;\n\t  // token not provided, skip github resolving\n\t  if (!options.tokens.github) return info;\n\t  try {\n\t    const data = await $fetch(`https://api.github.com/search/users?q=${encodeURIComponent(info.email)}`, {\n\t      headers: getHeaders(options)\n\t    });\n", "    info.login = data.items[0].login;\n\t  } catch {}\n\t  if (info.login) return info;\n\t  if (info.commits.length) {\n\t    try {\n\t      const data = await $fetch(`https://api.github.com/repos/${options.repo.repo}/commits/${info.commits[0]}`, {\n\t        headers: getHeaders(options)\n\t      });\n\t      info.login = data.author.login;\n\t    } catch (e) {}\n", "  }\n\t  return info;\n\t}\n\texport async function resolveAuthors(commits: Commit[], options: ChangelogOptions) {\n\t  const map = new Map<string, AuthorInfo>();\n\t  commits.forEach(commit => {\n\t    commit.resolvedAuthors = commit.authors\n\t      .map((a, idx) => {\n\t        if (!a.email || !a.name) {\n\t          return null;\n", "        }\n\t        if (!map.has(a.email)) {\n\t          map.set(a.email, {\n\t            commits: [],\n\t            name: a.name,\n\t            email: a.email\n\t          });\n\t        }\n\t        const info = map.get(a.email)!;\n\t        // record commits only for the first author\n", "        if (idx === 0) {\n\t          info.commits.push(commit.shortHash);\n\t        }\n\t        return info;\n\t      })\n\t      .filter(notNullish);\n\t  });\n\t  const authors = Array.from(map.values());\n\t  const resolved = await Promise.all(authors.map(info => resolveAuthorInfo(options, info)));\n\t  const loginSet = new Set<string>();\n", "  const nameSet = new Set<string>();\n\t  return resolved\n\t    .sort((a, b) => (a.login || a.name).localeCompare(b.login || b.name))\n\t    .filter(i => {\n\t      if (i.login && loginSet.has(i.login)) {\n\t        return false;\n\t      }\n\t      if (i.login) {\n\t        loginSet.add(i.login);\n\t      } else {\n", "        if (nameSet.has(i.name)) {\n\t          return false;\n\t        }\n\t        nameSet.add(i.name);\n\t      }\n\t      return true;\n\t    });\n\t}\n\texport async function hasTagOnGitHub(tag: string, options: ChangelogOptions) {\n\t  try {\n", "    await $fetch(`https://api.github.com/repos/${options.repo.repo}/git/ref/tags/${tag}`, {\n\t      headers: getHeaders(options)\n\t    });\n\t    return true;\n\t  } catch (e) {\n\t    return false;\n\t  }\n\t}\n"]}
{"filename": "src/markdown.ts", "chunked_list": ["import { convert } from 'convert-gitmoji';\n\timport { partition, groupBy, capitalize, join } from './shared';\n\timport type { Reference, Commit, ResolvedChangelogOptions } from './types';\n\tconst emojisRE =\n\t  /([\\u2700-\\u27BF]|[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2011-\\u26FF]|\\uD83E[\\uDD10-\\uDDFF])/g;\n\tfunction formatReferences(references: Reference[], github: string, type: 'issues' | 'hash'): string {\n\t  const refs = references\n\t    .filter(i => {\n\t      if (type === 'issues') {\n\t        return i.type === 'issue' || i.type === 'pull-request';\n", "      }\n\t      return i.type === 'hash';\n\t    })\n\t    .map(ref => {\n\t      if (!github) {\n\t        return ref.value;\n\t      }\n\t      if (ref.type === 'pull-request' || ref.type === 'issue') {\n\t        return `https://github.com/${github}/issues/${ref.value.slice(1)}`;\n\t      }\n", "      return `[<samp>(${ref.value.slice(0, 5)})</samp>](https://github.com/${github}/commit/${ref.value})`;\n\t    });\n\t  const referencesString = join(refs).trim();\n\t  if (type === 'issues') {\n\t    return referencesString && `in ${referencesString}`;\n\t  }\n\t  return referencesString;\n\t}\n\tfunction formatLine(commit: Commit, options: ResolvedChangelogOptions) {\n\t  const prRefs = formatReferences(commit.references, options.repo.repo || '', 'issues');\n", "  const hashRefs = formatReferences(commit.references, options.repo.repo || '', 'hash');\n\t  let authors = join([\n\t    ...new Set(commit.resolvedAuthors?.map(i => (i.login ? `@${i.login}` : `**${i.name}**`)))\n\t  ])?.trim();\n\t  if (authors) {\n\t    authors = `by ${authors}`;\n\t  }\n\t  let refs = [authors, prRefs, hashRefs].filter(i => i?.trim()).join(' ');\n\t  if (refs) {\n\t    refs = `&nbsp;-&nbsp; ${refs}`;\n", "  }\n\t  const description = options.capitalize ? capitalize(commit.description) : commit.description;\n\t  return [description, refs].filter(i => i?.trim()).join(' ');\n\t}\n\tfunction formatTitle(name: string, options: ResolvedChangelogOptions) {\n\t  let $name = name.trim();\n\t  if (!options.emoji) {\n\t    $name = name.replace(emojisRE, '').trim();\n\t  }\n\t  return `### &nbsp;&nbsp;&nbsp;${$name}`;\n", "}\n\tfunction formatSection(commits: Commit[], sectionName: string, options: ResolvedChangelogOptions) {\n\t  if (!commits.length) {\n\t    return [];\n\t  }\n\t  const lines: string[] = ['', formatTitle(sectionName, options), ''];\n\t  const scopes = groupBy(commits, 'scope');\n\t  let useScopeGroup = options.group;\n\t  // group scopes only when one of the scope have multiple commits\n\t  if (!Object.entries(scopes).some(([k, v]) => k && v.length > 1)) {\n", "    useScopeGroup = false;\n\t  }\n\t  Object.keys(scopes)\n\t    .sort()\n\t    .forEach(scope => {\n\t      let padding = '';\n\t      let prefix = '';\n\t      const scopeText = `**${options.scopeMap[scope] || scope}**`;\n\t      if (scope && (useScopeGroup === true || (useScopeGroup === 'multiple' && scopes[scope].length > 1))) {\n\t        lines.push(`- ${scopeText}:`);\n", "        padding = '  ';\n\t      } else if (scope) {\n\t        prefix = `${scopeText}: `;\n\t      }\n\t      lines.push(...scopes[scope].reverse().map(commit => `${padding}- ${prefix}${formatLine(commit, options)}`));\n\t    });\n\t  return lines;\n\t}\n\texport function generateMarkdown(commits: Commit[], options: ResolvedChangelogOptions) {\n\t  const lines: string[] = [];\n", "  const [breaking, changes] = partition(commits, c => c.isBreaking);\n\t  const group = groupBy(changes, 'type');\n\t  lines.push(...formatSection(breaking, options.titles.breakingChanges!, options));\n\t  for (const type of Object.keys(options.types)) {\n\t    const items = group[type] || [];\n\t    lines.push(...formatSection(items, options.types[type].title, options));\n\t  }\n\t  if (!lines.length) {\n\t    lines.push('*No significant changes*');\n\t  }\n", "  const url = `https://github.com/${options.repo.repo!}/compare/${options.from}...${options.to}`;\n\t  lines.push('', `##### &nbsp;&nbsp;&nbsp;&nbsp;[View changes on GitHub](${url})`);\n\t  return convert(lines.join('\\n').trim(), true);\n\t}\n"]}
{"filename": "src/parse.ts", "chunked_list": ["import { notNullish } from './shared';\n\timport type { GitCommit, RawGitCommit, GitCommitAuthor, ChangelogConfig, Reference } from './types';\n\t// https://www.conventionalcommits.org/en/v1.0.0/\n\t// https://regex101.com/r/FSfNvA/1\n\tconst ConventionalCommitRegex = /(?<type>[a-z]+)(\\((?<scope>.+)\\))?(?<breaking>!)?: (?<description>.+)/i;\n\tconst CoAuthoredByRegex = /co-authored-by:\\s*(?<name>.+)(<(?<email>.+)>)/gim;\n\tconst PullRequestRE = /\\([a-z]*(#\\d+)\\s*\\)/gm;\n\tconst IssueRE = /(#\\d+)/gm;\n\texport function parseGitCommit(commit: RawGitCommit, config: ChangelogConfig): GitCommit | null {\n\t  const match = commit.message.match(ConventionalCommitRegex);\n", "  if (!match?.groups) {\n\t    return null;\n\t  }\n\t  const type = match.groups.type;\n\t  let scope = match.groups.scope || '';\n\t  scope = config.scopeMap[scope] || scope;\n\t  const isBreaking = Boolean(match.groups.breaking);\n\t  let description = match.groups.description;\n\t  // Extract references from message\n\t  const references: Reference[] = [];\n", "  for (const m of description.matchAll(PullRequestRE)) {\n\t    references.push({ type: 'pull-request', value: m[1] });\n\t  }\n\t  for (const m of description.matchAll(IssueRE)) {\n\t    if (!references.some(i => i.value === m[1])) {\n\t      references.push({ type: 'issue', value: m[1] });\n\t    }\n\t  }\n\t  references.push({ value: commit.shortHash, type: 'hash' });\n\t  // Remove references and normalize\n", "  description = description.replace(PullRequestRE, '').trim();\n\t  // Find all authors\n\t  const authors: GitCommitAuthor[] = [commit.author];\n\t  const matchs = commit.body.matchAll(CoAuthoredByRegex);\n\t  for (const $match of matchs) {\n\t    const { name = '', email = '' } = $match.groups || {};\n\t    const author: GitCommitAuthor = {\n\t      name: name.trim(),\n\t      email: email.trim()\n\t    };\n", "    authors.push(author);\n\t  }\n\t  return {\n\t    ...commit,\n\t    authors,\n\t    description,\n\t    type,\n\t    scope,\n\t    references,\n\t    isBreaking\n", "  };\n\t}\n\texport function parseCommits(commits: RawGitCommit[], config: ChangelogConfig): GitCommit[] {\n\t  return commits.map(commit => parseGitCommit(commit, config)).filter(notNullish);\n\t}\n"]}
