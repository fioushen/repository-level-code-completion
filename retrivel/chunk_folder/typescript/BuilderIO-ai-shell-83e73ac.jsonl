{"filename": "src/prompt.ts", "chunked_list": ["import * as p from '@clack/prompts';\n\timport { execaCommand } from 'execa';\n\timport { cyan, dim } from 'kolorist';\n\timport {\n\t  getExplanation,\n\t  getRevision,\n\t  getScriptAndInfo,\n\t} from './helpers/completion';\n\timport { getConfig } from './helpers/config';\n\timport { projectName } from './helpers/constants';\n", "import { KnownError } from './helpers/error';\n\timport clipboardy from 'clipboardy';\n\timport i18n from './helpers/i18n';\n\tconst init = async () => {\n\t  try {\n\t    const { LANGUAGE: language } = await getConfig();\n\t    i18n.setLanguage(language);\n\t  } catch {\n\t    i18n.setLanguage('en');\n\t  }\n", "};\n\tconst examples: string[] = [];\n\tinit().then(() => {\n\t  examples.push(i18n.t('delete all log files'));\n\t  examples.push(i18n.t('list js files'));\n\t  examples.push(i18n.t('fetch me a random joke'));\n\t  examples.push(i18n.t('list all commits'));\n\t});\n\tconst sample = <T>(arr: T[]): T | undefined => {\n\t  const len = arr == null ? 0 : arr.length;\n", "  return len ? arr[Math.floor(Math.random() * len)] : undefined;\n\t};\n\tasync function runScript(script: string) {\n\t  p.outro(`${i18n.t('Running')}: ${script}`);\n\t  console.log('');\n\t  await execaCommand(script, {\n\t    stdio: 'inherit',\n\t    shell: process.env.SHELL || true,\n\t  }).catch(() => {\n\t    // Nothing needed, it'll output to stderr\n", "  });\n\t}\n\tasync function getPrompt(prompt?: string) {\n\t  const group = p.group(\n\t    {\n\t      prompt: () =>\n\t        p.text({\n\t          message: i18n.t('What would you like me to do?'),\n\t          placeholder: `${i18n.t('e.g.')} ${sample(examples)}`,\n\t          initialValue: prompt,\n", "          defaultValue: i18n.t('Say hello'),\n\t          validate: (value) => {\n\t            if (!value) return i18n.t('Please enter a prompt.');\n\t          },\n\t        }),\n\t    },\n\t    {\n\t      onCancel: () => {\n\t        p.cancel(i18n.t('Goodbye!'));\n\t        process.exit(0);\n", "      },\n\t    }\n\t  );\n\t  return (await group).prompt;\n\t}\n\tasync function promptForRevision() {\n\t  const group = p.group(\n\t    {\n\t      prompt: () =>\n\t        p.text({\n", "          message: i18n.t('What would you like me to change in this script?'),\n\t          placeholder: i18n.t('e.g. change the folder name'),\n\t          validate: (value) => {\n\t            if (!value) return i18n.t('Please enter a prompt.');\n\t          },\n\t        }),\n\t    },\n\t    {\n\t      onCancel: () => {\n\t        p.cancel(i18n.t('Goodbye!'));\n", "        process.exit(0);\n\t      },\n\t    }\n\t  );\n\t  return (await group).prompt;\n\t}\n\texport async function prompt({\n\t  usePrompt,\n\t  silentMode,\n\t}: { usePrompt?: string; silentMode?: boolean } = {}) {\n", "  const {\n\t    OPENAI_KEY: key,\n\t    SILENT_MODE,\n\t    OPENAI_API_ENDPOINT: apiEndpoint,\n\t    MODEL: model,\n\t  } = await getConfig();\n\t  const skipCommandExplanation = silentMode || SILENT_MODE;\n\t  console.log('');\n\t  p.intro(`${cyan(`${projectName}`)}`);\n\t  const thePrompt = usePrompt || (await getPrompt());\n", "  const spin = p.spinner();\n\t  spin.start(i18n.t(`Loading...`));\n\t  const { readInfo, readScript } = await getScriptAndInfo({\n\t    prompt: thePrompt,\n\t    key,\n\t    model,\n\t    apiEndpoint,\n\t  });\n\t  spin.stop(`${i18n.t('Your script')}:`);\n\t  console.log('');\n", "  const script = await readScript(process.stdout.write.bind(process.stdout));\n\t  console.log('');\n\t  console.log('');\n\t  console.log(dim('•'));\n\t  if (!skipCommandExplanation) {\n\t    spin.start(i18n.t(`Getting explanation...`));\n\t    const info = await readInfo(process.stdout.write.bind(process.stdout));\n\t    if (!info) {\n\t      const { readExplanation } = await getExplanation({\n\t        script,\n", "        key,\n\t        apiEndpoint,\n\t      });\n\t      spin.stop(`${i18n.t('Explanation')}:`);\n\t      console.log('');\n\t      await readExplanation(process.stdout.write.bind(process.stdout));\n\t      console.log('');\n\t      console.log('');\n\t      console.log(dim('•'));\n\t    }\n", "  }\n\t  await runOrReviseFlow(script, key, model, apiEndpoint, silentMode);\n\t}\n\tasync function runOrReviseFlow(\n\t  script: string,\n\t  key: string,\n\t  model: string,\n\t  apiEndpoint: string,\n\t  silentMode?: boolean\n\t) {\n", "  const emptyScript = script.trim() === '';\n\t  const answer: symbol | (() => any) = await p.select({\n\t    message: emptyScript\n\t      ? i18n.t('Revise this script?')\n\t      : i18n.t('Run this script?'),\n\t    options: [\n\t      ...(emptyScript\n\t        ? []\n\t        : [\n\t            {\n", "              label: '✅ ' + i18n.t('Yes'),\n\t              hint: i18n.t('Lets go!'),\n\t              value: async () => {\n\t                await runScript(script);\n\t              },\n\t            },\n\t            {\n\t              label: '📝 ' + i18n.t('Edit'),\n\t              hint: i18n.t('Make some adjustments before running'),\n\t              value: async () => {\n", "                const newScript = await p.text({\n\t                  message: i18n.t('you can edit script here:'),\n\t                  initialValue: script,\n\t                });\n\t                if (!p.isCancel(newScript)) {\n\t                  await runScript(newScript);\n\t                }\n\t              },\n\t            },\n\t          ]),\n", "      {\n\t        label: '🔁 ' + i18n.t('Revise'),\n\t        hint: i18n.t('Give feedback via prompt and get a new result'),\n\t        value: async () => {\n\t          await revisionFlow(script, key, model, apiEndpoint, silentMode);\n\t        },\n\t      },\n\t      {\n\t        label: '📋 ' + i18n.t('Copy'),\n\t        hint: i18n.t('Copy the generated script to your clipboard'),\n", "        value: async () => {\n\t          await clipboardy.write(script);\n\t          p.outro(i18n.t('Copied to clipboard!'));\n\t        },\n\t      },\n\t      {\n\t        label: '❌ ' + i18n.t('Cancel'),\n\t        hint: i18n.t('Exit the program'),\n\t        value: () => {\n\t          p.cancel(i18n.t('Goodbye!'));\n", "          process.exit(0);\n\t        },\n\t      },\n\t    ],\n\t  });\n\t  if (typeof answer === 'function') {\n\t    await answer();\n\t  }\n\t}\n\tasync function revisionFlow(\n", "  currentScript: string,\n\t  key: string,\n\t  model: string,\n\t  apiEndpoint: string,\n\t  silentMode?: boolean\n\t) {\n\t  const revision = await promptForRevision();\n\t  const spin = p.spinner();\n\t  spin.start(i18n.t(`Loading...`));\n\t  const { readScript } = await getRevision({\n", "    prompt: revision,\n\t    code: currentScript,\n\t    key,\n\t    model,\n\t    apiEndpoint,\n\t  });\n\t  spin.stop(`${i18n.t(`Your new script`)}:`);\n\t  console.log('');\n\t  const script = await readScript(process.stdout.write.bind(process.stdout));\n\t  console.log('');\n", "  console.log('');\n\t  console.log(dim('•'));\n\t  if (!silentMode) {\n\t    const infoSpin = p.spinner();\n\t    infoSpin.start(i18n.t(`Getting explanation...`));\n\t    const { readExplanation } = await getExplanation({\n\t      script,\n\t      key,\n\t      model,\n\t      apiEndpoint,\n", "    });\n\t    infoSpin.stop(`${i18n.t('Explanation')}:`);\n\t    console.log('');\n\t    await readExplanation(process.stdout.write.bind(process.stdout));\n\t    console.log('');\n\t    console.log('');\n\t    console.log(dim('•'));\n\t  }\n\t  await runOrReviseFlow(script, key, model, apiEndpoint, silentMode);\n\t}\n", "export const parseAssert = (name: string, condition: any, message: string) => {\n\t  if (!condition) {\n\t    throw new KnownError(\n\t      `${i18n.t('Invalid config property')} ${name}: ${message}`\n\t    );\n\t  }\n\t};\n"]}
{"filename": "src/cli.ts", "chunked_list": ["import { cli } from 'cleye';\n\timport { red } from 'kolorist';\n\timport { version } from '../package.json';\n\timport config from './commands/config';\n\timport update from './commands/update';\n\timport chat from './commands/chat';\n\timport { commandName } from './helpers/constants';\n\timport { handleCliError } from './helpers/error';\n\timport { prompt } from './prompt';\n\tcli(\n", "  {\n\t    name: commandName,\n\t    version: version,\n\t    flags: {\n\t      prompt: {\n\t        type: String,\n\t        description: 'Prompt to run',\n\t        alias: 'p',\n\t      },\n\t      silent: {\n", "        type: Boolean,\n\t        description: 'Less verbose, skip printing the command explanation ',\n\t        alias: 's',\n\t      },\n\t    },\n\t    commands: [config, chat, update],\n\t  },\n\t  (argv) => {\n\t    const silentMode = argv.flags.silent;\n\t    const promptText = argv._.join(' ');\n", "    if (promptText.trim() === 'update') {\n\t      update.callback?.(argv);\n\t    } else {\n\t      prompt({ usePrompt: promptText, silentMode }).catch((error) => {\n\t        console.error(`\\n${red('✖')} ${error.message}`);\n\t        handleCliError(error);\n\t        process.exit(1);\n\t      });\n\t    }\n\t  }\n", ");\n"]}
{"filename": "src/commands/config.ts", "chunked_list": ["import { command } from 'cleye';\n\timport { red } from 'kolorist';\n\timport {\n\t  hasOwn,\n\t  getConfig,\n\t  setConfigs,\n\t  showConfigUI,\n\t} from '../helpers/config.js';\n\timport { KnownError, handleCliError } from '../helpers/error.js';\n\timport i18n from '../helpers/i18n.js';\n", "export default command(\n\t  {\n\t    name: 'config',\n\t    parameters: ['[mode]', '[key=value...]'],\n\t    help: {\n\t      description: 'Configure the CLI',\n\t    },\n\t  },\n\t  (argv) => {\n\t    (async () => {\n", "      const { mode, keyValue: keyValues } = argv._;\n\t      if (mode === 'ui' || !mode) {\n\t        await showConfigUI();\n\t        return;\n\t      }\n\t      if (!keyValues.length) {\n\t        console.error(\n\t          `${i18n.t('Error')}: ${i18n.t(\n\t            'Missing required parameter'\n\t          )} \"key=value\"\\n`\n", "        );\n\t        argv.showHelp();\n\t        return process.exit(1);\n\t      }\n\t      if (mode === 'get') {\n\t        const config = await getConfig();\n\t        for (const key of keyValues) {\n\t          if (hasOwn(config, key)) {\n\t            console.log(`${key}=${config[key as keyof typeof config]}`);\n\t          } else {\n", "            throw new KnownError(\n\t              `${i18n.t('Invalid config property')}: ${key}`\n\t            );\n\t          }\n\t        }\n\t        return;\n\t      }\n\t      if (mode === 'set') {\n\t        await setConfigs(\n\t          keyValues.map((keyValue) => keyValue.split('=') as [string, string])\n", "        );\n\t        return;\n\t      }\n\t      throw new KnownError(`${i18n.t('Invalid mode')}: ${mode}`);\n\t    })().catch((error) => {\n\t      console.error(`\\n${red('✖')} ${error.message}`);\n\t      handleCliError(error);\n\t      process.exit(1);\n\t    });\n\t  }\n", ");\n"]}
{"filename": "src/commands/chat.ts", "chunked_list": ["import { command } from 'cleye';\n\timport { spinner, intro, outro, text, isCancel } from '@clack/prompts';\n\timport { cyan, green } from 'kolorist';\n\timport { generateCompletion, readData } from '../helpers/completion';\n\timport { getConfig } from '../helpers/config';\n\timport { streamToIterable } from '../helpers/stream-to-iterable';\n\timport { ChatCompletionRequestMessage } from 'openai';\n\timport i18n from '../helpers/i18n';\n\texport default command(\n\t  {\n", "    name: 'chat',\n\t    help: {\n\t      description:\n\t        'Start a new chat session to send and receive messages, continue replying until the user chooses to exit.',\n\t    },\n\t  },\n\t  async () => {\n\t    const {\n\t      OPENAI_KEY: key,\n\t      OPENAI_API_ENDPOINT: apiEndpoint,\n", "      MODEL: model,\n\t    } = await getConfig();\n\t    const chatHistory: ChatCompletionRequestMessage[] = [];\n\t    console.log('');\n\t    intro(i18n.t('Starting new conversation'));\n\t    const prompt = async () => {\n\t      const msgYou = `${i18n.t('You')}:`;\n\t      const userPrompt = (await text({\n\t        message: `${cyan(msgYou)}`,\n\t        placeholder: i18n.t(`send a message ('exit' to quit)`),\n", "        validate: (value) => {\n\t          if (!value) return i18n.t('Please enter a prompt.');\n\t        },\n\t      })) as string;\n\t      if (isCancel(userPrompt) || userPrompt === 'exit') {\n\t        outro(i18n.t('Goodbye!'));\n\t        process.exit(0);\n\t      }\n\t      const infoSpin = spinner();\n\t      infoSpin.start(i18n.t(`THINKING...`));\n", "      chatHistory.push({\n\t        role: 'user',\n\t        content: userPrompt,\n\t      });\n\t      const { readResponse } = await getResponse({\n\t        prompt: chatHistory,\n\t        key,\n\t        model,\n\t        apiEndpoint,\n\t      });\n", "      infoSpin.stop(`${green('AI Shell:')}`);\n\t      console.log('');\n\t      const fullResponse = await readResponse(\n\t        process.stdout.write.bind(process.stdout)\n\t      );\n\t      chatHistory.push({\n\t        role: 'assistant',\n\t        content: fullResponse,\n\t      });\n\t      console.log('');\n", "      console.log('');\n\t      prompt();\n\t    };\n\t    prompt();\n\t  }\n\t);\n\tasync function getResponse({\n\t  prompt,\n\t  number = 1,\n\t  key,\n", "  model,\n\t  apiEndpoint,\n\t}: {\n\t  prompt: string | ChatCompletionRequestMessage[];\n\t  number?: number;\n\t  model?: string;\n\t  key: string;\n\t  apiEndpoint: string;\n\t}) {\n\t  const stream = await generateCompletion({\n", "    prompt,\n\t    key,\n\t    model,\n\t    number,\n\t    apiEndpoint,\n\t  });\n\t  const iterableStream = streamToIterable(stream);\n\t  return { readResponse: readData(iterableStream, () => true) };\n\t}\n"]}
{"filename": "src/commands/update.ts", "chunked_list": ["import { command } from 'cleye';\n\timport { execaCommand } from 'execa';\n\timport { dim } from 'kolorist';\n\timport i18n from '../helpers/i18n';\n\texport default command(\n\t  {\n\t    name: 'update',\n\t    help: {\n\t      description: 'Update AI Shell to the latest version',\n\t    },\n", "  },\n\t  async () => {\n\t    console.log('');\n\t    const command = `npm update -g @builder.io/ai-shell`;\n\t    console.log(dim(`${i18n.t('Running')}: ${command}`));\n\t    console.log('');\n\t    await execaCommand(command, {\n\t      stdio: 'inherit',\n\t      shell: process.env.SHELL || true,\n\t    }).catch(() => {\n", "      // No need to handle, will go to stderr\n\t    });\n\t    console.log('');\n\t  }\n\t);\n"]}
{"filename": "src/helpers/os-detect.ts", "chunked_list": ["import os from 'os';\n\timport path from 'path';\n\timport i18n from './i18n';\n\texport function detectShell() {\n\t  try {\n\t    // Detect if we're running on win32 and assume powershell\n\t    if (os.platform() === 'win32') {\n\t      return 'powershell';\n\t    }\n\t    // otherwise return current shell; default to bash\n", "    return path.basename(os.userInfo().shell ?? 'bash');\n\t  } catch (err: unknown) {\n\t    if (err instanceof Error) {\n\t      throw new Error(\n\t        `${i18n.t('Shell detection failed unexpectedly')}: ${err.message}`\n\t      );\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/helpers/completion.ts", "chunked_list": ["import { OpenAIApi, Configuration, ChatCompletionRequestMessage } from 'openai';\n\timport dedent from 'dedent';\n\timport { IncomingMessage } from 'http';\n\timport { KnownError } from './error';\n\timport { streamToIterable } from './stream-to-iterable';\n\timport { detectShell } from './os-detect';\n\timport type { AxiosError } from 'axios';\n\timport { streamToString } from './stream-to-string';\n\timport './replace-all-polyfill';\n\timport i18n from './i18n';\n", "const explainInSecondRequest = true;\n\tfunction getOpenAi(key: string, apiEndpoint: string) {\n\t  const openAi = new OpenAIApi(\n\t    new Configuration({ apiKey: key, basePath: apiEndpoint })\n\t  );\n\t  return openAi;\n\t}\n\t// Openai outputs markdown format for code blocks. It oftne uses\n\t// a github style like: \"```bash\"\n\tconst shellCodeStartRegex = /```[^\\n]*/gi;\n", "export async function getScriptAndInfo({\n\t  prompt,\n\t  key,\n\t  model,\n\t  apiEndpoint,\n\t}: {\n\t  prompt: string;\n\t  key: string;\n\t  model?: string;\n\t  apiEndpoint: string;\n", "}) {\n\t  const fullPrompt = getFullPrompt(prompt);\n\t  const stream = await generateCompletion({\n\t    prompt: fullPrompt,\n\t    number: 1,\n\t    key,\n\t    model,\n\t    apiEndpoint,\n\t  });\n\t  const iterableStream = streamToIterable(stream);\n", "  const codeBlock = '```';\n\t  return {\n\t    readScript: readData(iterableStream, () => true, shellCodeStartRegex),\n\t    readInfo: readData(\n\t      iterableStream,\n\t      (content) => content.endsWith(codeBlock),\n\t      shellCodeStartRegex\n\t    ),\n\t  };\n\t}\n", "export async function generateCompletion({\n\t  prompt,\n\t  number = 1,\n\t  key,\n\t  model,\n\t  apiEndpoint,\n\t}: {\n\t  prompt: string | ChatCompletionRequestMessage[];\n\t  number?: number;\n\t  model?: string;\n", "  key: string;\n\t  apiEndpoint: string;\n\t}) {\n\t  const openAi = getOpenAi(key, apiEndpoint);\n\t  try {\n\t    const completion = await openAi.createChatCompletion(\n\t      {\n\t        model: model || 'gpt-3.5-turbo',\n\t        messages: Array.isArray(prompt)\n\t          ? prompt\n", "          : [{ role: 'user', content: prompt }],\n\t        n: Math.min(number, 10),\n\t        stream: true,\n\t      },\n\t      { responseType: 'stream' }\n\t    );\n\t    return completion.data as unknown as IncomingMessage;\n\t  } catch (err) {\n\t    const error = err as AxiosError;\n\t    if (error.code === 'ENOTFOUND') {\n", "      throw new KnownError(\n\t        `Error connecting to ${error.request.hostname} (${error.request.syscall}). Are you connected to the internet?`\n\t      );\n\t    }\n\t    const response = error.response;\n\t    let message = response?.data as string | object | IncomingMessage;\n\t    if (response && message instanceof IncomingMessage) {\n\t      message = await streamToString(\n\t        response.data as unknown as IncomingMessage\n\t      );\n", "      try {\n\t        // Handle if the message is JSON. It should be but occasionally will\n\t        // be HTML, so lets handle both\n\t        message = JSON.parse(message);\n\t      } catch (e) {\n\t        // Ignore\n\t      }\n\t    }\n\t    const messageString = message && JSON.stringify(message, null, 2);\n\t    if (response?.status === 429) {\n", "      throw new KnownError(\n\t        dedent`\n\t        Request to OpenAI failed with status 429. This is due to incorrect billing setup or excessive quota usage. Please follow this guide to fix it: https://help.openai.com/en/articles/6891831-error-code-429-you-exceeded-your-current-quota-please-check-your-plan-and-billing-details\n\t        You can activate billing here: https://platform.openai.com/account/billing/overview . Make sure to add a payment method if not under an active grant from OpenAI.\n\t        Full message from OpenAI:\n\t      ` +\n\t          '\\n\\n' +\n\t          messageString +\n\t          '\\n'\n\t      );\n", "    } else if (response && message) {\n\t      throw new KnownError(\n\t        dedent`\n\t        Request to OpenAI failed with status ${response?.status}:\n\t      ` +\n\t          '\\n\\n' +\n\t          messageString +\n\t          '\\n'\n\t      );\n\t    }\n", "    throw error;\n\t  }\n\t}\n\texport async function getExplanation({\n\t  script,\n\t  key,\n\t  model,\n\t  apiEndpoint,\n\t}: {\n\t  script: string;\n", "  key: string;\n\t  model?: string;\n\t  apiEndpoint: string;\n\t}) {\n\t  const prompt = getExplanationPrompt(script);\n\t  const stream = await generateCompletion({\n\t    prompt,\n\t    key,\n\t    number: 1,\n\t    model,\n", "    apiEndpoint,\n\t  });\n\t  const iterableStream = streamToIterable(stream);\n\t  return { readExplanation: readData(iterableStream, () => true) };\n\t}\n\texport async function getRevision({\n\t  prompt,\n\t  code,\n\t  key,\n\t  model,\n", "  apiEndpoint,\n\t}: {\n\t  prompt: string;\n\t  code: string;\n\t  key: string;\n\t  model?: string;\n\t  apiEndpoint: string;\n\t}) {\n\t  const fullPrompt = getRevisionPrompt(prompt, code);\n\t  const stream = await generateCompletion({\n", "    prompt: fullPrompt,\n\t    key,\n\t    number: 1,\n\t    model,\n\t    apiEndpoint,\n\t  });\n\t  const iterableStream = streamToIterable(stream);\n\t  return {\n\t    readScript: readData(iterableStream, () => true),\n\t  };\n", "}\n\texport const readData =\n\t  (\n\t    iterableStream: AsyncGenerator<string, void>,\n\t    startSignal: (content: string) => boolean,\n\t    excluded?: RegExp\n\t  ) =>\n\t  (writer: (data: string) => void): Promise<string> =>\n\t    new Promise(async (resolve) => {\n\t      let data = '';\n", "      let content = '';\n\t      let dataStart = false;\n\t      let waitUntilNewline = false;\n\t      for await (const chunk of iterableStream) {\n\t        const payloads = chunk.toString().split('\\n\\n');\n\t        for (const payload of payloads) {\n\t          if (payload.includes('[DONE]')) {\n\t            dataStart = false;\n\t            resolve(data);\n\t            return;\n", "          }\n\t          if (payload.startsWith('data:')) {\n\t            content = parseContent(payload);\n\t            if (!dataStart && content.match(excluded ?? '')) {\n\t              dataStart = startSignal(content);\n\t              if (!content.includes('\\n')) {\n\t                waitUntilNewline = true;\n\t              }\n\t              if (excluded) break;\n\t            }\n", "            if (content && waitUntilNewline) {\n\t              if (!content.includes('\\n')) {\n\t                continue;\n\t              }\n\t              waitUntilNewline = false;\n\t            }\n\t            if (dataStart && content) {\n\t              const contentWithoutExcluded = excluded\n\t                ? content.replaceAll(excluded, '')\n\t                : content;\n", "              data += contentWithoutExcluded;\n\t              writer(contentWithoutExcluded);\n\t            }\n\t          }\n\t        }\n\t      }\n\t      function parseContent(payload: string): string {\n\t        const data = payload.replaceAll(/(\\n)?^data:\\s*/g, '');\n\t        try {\n\t          const delta = JSON.parse(data.trim());\n", "          return delta.choices?.[0].delta?.content ?? '';\n\t        } catch (error) {\n\t          return `Error with JSON.parse and ${payload}.\\n${error}`;\n\t        }\n\t      }\n\t      resolve(data);\n\t    });\n\tfunction getExplanationPrompt(script: string) {\n\t  return dedent`\n\t    ${explainScript} Please reply in ${i18n.getCurrentLanguagenName()}\n", "    The script: ${script}\n\t  `;\n\t}\n\tfunction getShellDetails() {\n\t  const shellDetails = detectShell();\n\t  return dedent`\n\t      The target shell is ${shellDetails}\n\t  `;\n\t}\n\tconst shellDetails = getShellDetails();\n", "const explainScript = dedent`\n\t  Please provide a clear, concise description of the script, using minimal words. Outline the steps in a list format.\n\t`;\n\tfunction getOperationSystemDetails() {\n\t  const os = require('@nexssp/os/legacy');\n\t  return os.name();\n\t}\n\tconst generationDetails = dedent`\n\t    Only reply with the single line command surrounded by three backticks. It must be able to be directly run in the target shell. Do not include any other text.\n\t    Make sure the command runs on ${getOperationSystemDetails()} operating system.\n", "  `;\n\tfunction getFullPrompt(prompt: string) {\n\t  return dedent`\n\t    Create a single line command that one can enter in a terminal and run, based on what is specified in the prompt.\n\t    ${shellDetails}\n\t    ${generationDetails}\n\t    ${explainInSecondRequest ? '' : explainScript}\n\t    The prompt is: ${prompt}\n\t  `;\n\t}\n", "function getRevisionPrompt(prompt: string, code: string) {\n\t  return dedent`\n\t    Update the following script based on what is asked in the following prompt.\n\t    The script: ${code}\n\t    The prompt: ${prompt}\n\t    ${generationDetails}\n\t  `;\n\t}\n"]}
{"filename": "src/helpers/config.ts", "chunked_list": ["import fs from 'fs/promises';\n\timport path from 'path';\n\timport os from 'os';\n\timport ini from 'ini';\n\timport type { TiktokenModel } from '@dqbd/tiktoken';\n\timport { commandName } from './constants';\n\timport { KnownError, handleCliError } from './error';\n\timport * as p from '@clack/prompts';\n\timport { red } from 'kolorist';\n\timport i18n from './i18n';\n", "const { hasOwnProperty } = Object.prototype;\n\texport const hasOwn = (object: unknown, key: PropertyKey) =>\n\t  hasOwnProperty.call(object, key);\n\tconst languagesOptions = Object.entries(i18n.languages).map(([key, value]) => ({\n\t  value: key,\n\t  label: value,\n\t}));\n\tconst parseAssert = (name: string, condition: any, message: string) => {\n\t  if (!condition) {\n\t    throw new KnownError(\n", "      `${i18n.t('Invalid config property')} ${name}: ${message}`\n\t    );\n\t  }\n\t};\n\tconst configParsers = {\n\t  OPENAI_KEY(key?: string) {\n\t    if (!key) {\n\t      throw new KnownError(\n\t        `Please set your OpenAI API key via \\`${commandName} config set OPENAI_KEY=<your token>\\`` // TODO: i18n\n\t      );\n", "    }\n\t    return key;\n\t  },\n\t  MODEL(model?: string) {\n\t    if (!model || model.length === 0) {\n\t      return 'gpt-3.5-turbo';\n\t    }\n\t    return model as TiktokenModel;\n\t  },\n\t  SILENT_MODE(mode?: string) {\n", "    return String(mode).toLowerCase() === 'true';\n\t  },\n\t  OPENAI_API_ENDPOINT(apiEndpoint?: string) {\n\t    return apiEndpoint || 'https://api.openai.com/v1';\n\t  },\n\t  LANGUAGE(language?: string) {\n\t    return language || 'en';\n\t  },\n\t} as const;\n\ttype ConfigKeys = keyof typeof configParsers;\n", "type RawConfig = {\n\t  [key in ConfigKeys]?: string;\n\t};\n\ttype ValidConfig = {\n\t  [Key in ConfigKeys]: ReturnType<(typeof configParsers)[Key]>;\n\t};\n\tconst configPath = path.join(os.homedir(), '.ai-shell');\n\tconst fileExists = (filePath: string) =>\n\t  fs.lstat(filePath).then(\n\t    () => true,\n", "    () => false\n\t  );\n\tconst readConfigFile = async (): Promise<RawConfig> => {\n\t  const configExists = await fileExists(configPath);\n\t  if (!configExists) {\n\t    return Object.create(null);\n\t  }\n\t  const configString = await fs.readFile(configPath, 'utf8');\n\t  return ini.parse(configString);\n\t};\n", "export const getConfig = async (\n\t  cliConfig?: RawConfig\n\t): Promise<ValidConfig> => {\n\t  const config = await readConfigFile();\n\t  const parsedConfig: Record<string, unknown> = {};\n\t  for (const key of Object.keys(configParsers) as ConfigKeys[]) {\n\t    const parser = configParsers[key];\n\t    const value = cliConfig?.[key] ?? config[key];\n\t    parsedConfig[key] = parser(value);\n\t  }\n", "  return parsedConfig as ValidConfig;\n\t};\n\texport const setConfigs = async (keyValues: [key: string, value: string][]) => {\n\t  const config = await readConfigFile();\n\t  for (const [key, value] of keyValues) {\n\t    if (!hasOwn(configParsers, key)) {\n\t      throw new KnownError(`${i18n.t('Invalid config property')}: ${key}`);\n\t    }\n\t    const parsed = configParsers[key as ConfigKeys](value);\n\t    config[key as ConfigKeys] = parsed as any;\n", "  }\n\t  await fs.writeFile(configPath, ini.stringify(config), 'utf8');\n\t};\n\texport const showConfigUI = async () => {\n\t  try {\n\t    const config = await getConfig();\n\t    const choice = (await p.select({\n\t      message: i18n.t('Set config') + ':',\n\t      options: [\n\t        {\n", "          label: i18n.t('OpenAI Key'),\n\t          value: 'OPENAI_KEY',\n\t          hint: hasOwn(config, 'OPENAI_KEY')\n\t            ? // Obfuscate the key\n\t              'sk-...' + config.OPENAI_KEY.slice(-3)\n\t            : i18n.t('(not set)'),\n\t        },\n\t        {\n\t          label: i18n.t('OpenAI API Endpoint'),\n\t          value: 'OPENAI_API_ENDPOINT',\n", "          hint: hasOwn(config, 'OPENAI_API_ENDPOINT')\n\t            ? config.OPENAI_API_ENDPOINT\n\t            : i18n.t('(not set)'),\n\t        },\n\t        {\n\t          label: i18n.t('Silent Mode'),\n\t          value: 'SILENT_MODE',\n\t          hint: hasOwn(config, 'SILENT_MODE')\n\t            ? config.SILENT_MODE.toString()\n\t            : i18n.t('(not set)'),\n", "        },\n\t        {\n\t          label: i18n.t('Model'),\n\t          value: 'MODEL',\n\t          hint: hasOwn(config, 'MODEL') ? config.MODEL : i18n.t('(not set)'),\n\t        },\n\t        {\n\t          label: i18n.t('Language'),\n\t          value: 'LANGUAGE',\n\t          hint: hasOwn(config, 'LANGUAGE')\n", "            ? config.LANGUAGE\n\t            : i18n.t('(not set)'),\n\t        },\n\t        {\n\t          label: i18n.t('Cancel'),\n\t          value: 'cancel',\n\t          hint: i18n.t('Exit the program'),\n\t        },\n\t      ],\n\t    })) as ConfigKeys | 'cancel' | symbol;\n", "    if (p.isCancel(choice)) return;\n\t    if (choice === 'OPENAI_KEY') {\n\t      const key = await p.text({\n\t        message: i18n.t('Enter your OpenAI API key'),\n\t        validate: (value) => {\n\t          if (!value.length) {\n\t            return i18n.t('Please enter a key');\n\t          }\n\t        },\n\t      });\n", "      if (p.isCancel(key)) return;\n\t      await setConfigs([['OPENAI_KEY', key]]);\n\t    } else if (choice === 'OPENAI_API_ENDPOINT') {\n\t      const apiEndpoint = await p.text({\n\t        message: i18n.t('Enter your OpenAI API Endpoint'),\n\t      });\n\t      if (p.isCancel(apiEndpoint)) return;\n\t      await setConfigs([['OPENAI_API_ENDPOINT', apiEndpoint]]);\n\t    } else if (choice === 'SILENT_MODE') {\n\t      const silentMode = await p.confirm({\n", "        message: i18n.t('Enable silent mode?'),\n\t      });\n\t      if (p.isCancel(silentMode)) return;\n\t      await setConfigs([['SILENT_MODE', silentMode ? 'true' : 'false']]);\n\t    } else if (choice === 'MODEL') {\n\t      const model = await p.text({\n\t        message: i18n.t('Enter the model you want to use'),\n\t      });\n\t      if (p.isCancel(model)) return;\n\t      await setConfigs([['MODEL', model]]);\n", "    } else if (choice === 'LANGUAGE') {\n\t      const language = (await p.select({\n\t        message: i18n.t('Enter the language you want to use'),\n\t        options: languagesOptions,\n\t      })) as string;\n\t      if (p.isCancel(language)) return;\n\t      await setConfigs([['LANGUAGE', language]]);\n\t      i18n.setLanguage(language);\n\t    }\n\t    if (choice === 'cancel') return;\n", "    showConfigUI();\n\t  } catch (error: any) {\n\t    console.error(`\\n${red('✖')} ${error.message}`);\n\t    handleCliError(error);\n\t    process.exit(1);\n\t  }\n\t};\n"]}
{"filename": "src/helpers/stream-to-string.ts", "chunked_list": ["import { IncomingMessage } from 'http';\n\texport async function streamToString(stream: IncomingMessage): Promise<string> {\n\t  let str = '';\n\t  for await (const chunk of stream) {\n\t    str += chunk;\n\t  }\n\t  return str;\n\t}\n"]}
{"filename": "src/helpers/stream-to-iterable.ts", "chunked_list": ["import { IncomingMessage } from 'http';\n\texport async function* streamToIterable(stream: IncomingMessage) {\n\t  let previous = '';\n\t  for await (const chunk of stream) {\n\t    const bufferChunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);\n\t    previous += bufferChunk;\n\t    let eolIndex;\n\t    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n\t      // line includes the EOL\n\t      const line = previous.slice(0, eolIndex + 1).trimEnd();\n", "      if (line.startsWith('data: ')) yield line;\n\t      previous = previous.slice(eolIndex + 1);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/helpers/replace-all-polyfill.ts", "chunked_list": ["/**\n\t * String.prototype.replaceAll() polyfill\n\t * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/\n\t * @author Chris Ferdinandi\n\t * @license MIT\n\t */\n\tif (!String.prototype.replaceAll) {\n\t  String.prototype.replaceAll = function (str, newStr) {\n\t    if (\n\t      Object.prototype.toString.call(str).toLowerCase() === '[object regexp]'\n", "    ) {\n\t      return this.replace(str, newStr as string);\n\t    }\n\t    return this.replace(new RegExp(str, 'g'), newStr as string);\n\t  };\n\t}\n"]}
{"filename": "src/helpers/i18n.ts", "chunked_list": ["import i18next from 'i18next';\n\timport zhHansTranslation from '../locales/zh-Hans.json';\n\timport zhHantTranslation from '../locales/zh-Hant.json';\n\timport esTranslation from '../locales/es.json';\n\timport jpTranslation from '../locales/jp.json';\n\timport koTranslation from '../locales/ko.json';\n\timport frTranslation from '../locales/fr.json';\n\timport deTranslation from '../locales/de.json';\n\timport ruTranslation from '../locales/ru.json';\n\timport ukTranslation from '../locales/uk.json';\n", "import viTranslation from '../locales/vi.json';\n\timport arTranslation from '../locales/ar.json';\n\timport ptTranslation from '../locales/pt.json';\n\timport idTranslation from '../locales/id.json';\n\tlet currentlang: string = 'en';\n\tconst languages: Record<string, string> = {\n\t  en: 'English',\n\t  'zh-Hans': '简体中文', // simplified Chinese\n\t  'zh-Hant': '繁體中文', // traditional Chinese\n\t  es: 'Español', // Spanish\n", "  jp: '日本語', // Japanese\n\t  ko: '한국어', // Korean\n\t  fr: 'Français', // French\n\t  de: 'Deutsch', // German\n\t  ru: 'Русский', // Russian\n\t  uk: 'Українська', // Ukrainian\n\t  vi: 'Tiếng Việt', // Vietnamese\n\t  ar: 'العربية', // Arabic\n\t  pt: 'Português', // Portuguese\n\t  id: 'Indonesia', // Indonesia\n", "};\n\ti18next.init({\n\t  lng: currentlang,\n\t  fallbackLng: 'en',\n\t  resources: {\n\t    'zh-Hans': {\n\t      translation: zhHansTranslation,\n\t    },\n\t    'zh-Hant': {\n\t      translation: zhHantTranslation,\n", "    },\n\t    es: {\n\t      translation: esTranslation,\n\t    },\n\t    jp: {\n\t      translation: jpTranslation,\n\t    },\n\t    ko: {\n\t      translation: koTranslation,\n\t    },\n", "    fr: {\n\t      translation: frTranslation,\n\t    },\n\t    de: {\n\t      translation: deTranslation,\n\t    },\n\t    ru: {\n\t      translation: ruTranslation,\n\t    },\n\t    uk: {\n", "      translation: ukTranslation,\n\t    },\n\t    vi: {\n\t      translation: viTranslation,\n\t    },\n\t    ar: {\n\t      translation: arTranslation,\n\t    },\n\t    pt: {\n\t      translation: ptTranslation,\n", "    },\n\t    id: {\n\t      translation: idTranslation,\n\t    },\n\t  },\n\t});\n\t/**\n\t * Adds a public method called \"t\" that takes a string parameter and returns a string.\n\t * @param key - The translation key to look up.\n\t * @returns The translated string.\n", " */\n\tconst t = (key: string): string => {\n\t  if (!currentlang || currentlang === 'en') return key;\n\t  return i18next.t(key) as string;\n\t};\n\tconst setLanguage = (lang: string) => {\n\t  currentlang = lang || 'en';\n\t  i18next.changeLanguage(currentlang);\n\t};\n\tconst getCurrentLanguagenName = () => {\n", "  return languages[currentlang];\n\t};\n\texport default { setLanguage, t, getCurrentLanguagenName, languages };\n"]}
{"filename": "src/helpers/constants.ts", "chunked_list": ["import pkg from '../../package.json';\n\texport const commandName = 'ai';\n\texport const projectName = 'AI Shell';\n\texport const repoUrl = pkg.repository.url;\n"]}
{"filename": "src/helpers/error.ts", "chunked_list": ["import { dim } from 'kolorist';\n\timport { version } from '../../package.json';\n\timport i18n from './i18n';\n\texport class KnownError extends Error {}\n\tconst indent = ' '.repeat(4);\n\texport const handleCliError = (error: any) => {\n\t  if (error instanceof Error && !(error instanceof KnownError)) {\n\t    if (error.stack) {\n\t      console.error(dim(error.stack.split('\\n').slice(1).join('\\n')));\n\t    }\n", "    console.error(`\\n${indent}${dim(`ai-shell v${version}`)}`);\n\t    console.error(\n\t      `\\n${indent}${i18n.t(\n\t        'Please open a Bug report with the information above'\n\t      )}:`\n\t    );\n\t    console.error(`${indent}https://github.com/BuilderIO/ai-shell/issues/new`);\n\t  }\n\t};\n"]}
