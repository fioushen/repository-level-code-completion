{"filename": "__mocks__/obsidian.ts", "chunked_list": ["// This file is required to exclude obsidian package dependency from jest unit tests\n\timport moment from \"moment\";\n\texport { moment as moment };\n"]}
{"filename": "__mocks__/nanoid.ts", "chunked_list": ["export function customAlphabet(alphabet: string, defaultSize?: number): (size?: number) => string {\n\t    return () => \"\"\n\t}\n"]}
{"filename": "src/path.ts", "chunked_list": ["export interface ParsedPath {\n\t  /**\n\t   * parent directory name (if exist)\n\t   */\n\t  dir: string;\n\t  /**\n\t   * name with extension\n\t   */\n\t  name: string;\n\t  /**\n", "   *  name without extension\n\t   */\n\t  basename: string;\n\t  /**\n\t   * extension\n\t   */\n\t  extension: string;\n\t}\n\tconst lastSeparatorRegex = /[/\\\\](?!.*[/\\\\])/g;\n\tconst lastPeriodRegex = /\\.(?!.*\\.)/g;\n", "export function parsePath(path: string): ParsedPath {\n\t  const pathComponent = path.split(lastSeparatorRegex);\n\t  let dir = \"\";\n\t  let name;\n\t  if (pathComponent.length == 2) [dir, name] = pathComponent;\n\t  else [name] = pathComponent;\n\t  const nameComponent = name.split(lastPeriodRegex);\n\t  const basename = nameComponent[0];\n\t  let extension = \"\";\n\t  if (nameComponent.length > 1) extension = nameComponent[1];\n", "  return {\n\t    dir,\n\t    name,\n\t    basename,\n\t    extension,\n\t  };\n\t}\n"]}
{"filename": "src/obsidian-ex.d.ts", "chunked_list": ["import { EditorState } from \"@codemirror/state\";\n\timport \"obsidian\";\n\tdeclare module \"obsidian\" {\n\t  enum PopoverState {\n\t    Showing,\n\t    Shown,\n\t    Hiding,\n\t    Hidden,\n\t  }\n\t  interface HoverParent {\n", "    type?: string;\n\t  }\n\t  interface HoverPopover {\n\t    parent: HoverParent | null;\n\t    targetEl: HTMLElement;\n\t    hoverEl: HTMLElement;\n\t    position(pos?: MousePos): void;\n\t    hide(): void;\n\t    show(): void;\n\t    shouldShowSelf(): boolean;\n", "    timer: number;\n\t    waitTime: number;\n\t    shouldShow(): boolean;\n\t    transition(): void;\n\t  }\n\t  interface MousePos {\n\t    x: number;\n\t    y: number;\n\t  }\n\t  interface PagePreviewPlugin {\n", "    onLinkHover(\n\t      parent: HoverParent,\n\t      tergetEl: HTMLElement,\n\t      link: string,\n\t      sourcePath: string,\n\t      state: EditorState\n\t    );\n\t  }\n\t  interface InternalPlugins {\n\t    \"page-preview\": PagePreviewPlugin;\n", "  }\n\t  interface App {\n\t    internalPlugins: {\n\t      getEnabledPluginById<T extends keyof InternalPlugins>(id: T): InternalPlugins[T] | undefined;\n\t    };\n\t  }\n\t  interface MarkdownRenderer {\n\t    renderer: {\n\t      set(markdown: string): void;\n\t    };\n", "  }\n\t  interface MarkdownRendererConstructorType {\n\t    new (app: App, container: HTMLElement, queed: boolean): MarkdownRenderer;\n\t  }\n\t  interface Workspace {\n\t    registerEditorExtension(extension: Extension): void;\n\t    unregisterEditorExtension(extension: Extension): void;\n\t  }\n\t  interface PopoverSuggest<T> {\n\t    suggestEl: HTMLDivElement;\n", "    suggestions: {\n\t      setSuggestions(list: T[]);\n\t    };\n\t    setAutoDestroy(el: HTMLElement);\n\t    reposition({ left: number, right: number, top: number, bottom: number });\n\t  }\n\t  interface ClickableToken {\n\t    type: string;\n\t    text: string;\n\t    start: EditorPosition;\n", "    end: EditorPosition;\n\t  }\n\t  interface Editor {\n\t    getClickableTokenAt?: (pos: EditorPosition) => ClickableToken | undefined;\n\t  }\n\t}\n"]}
{"filename": "src/view.ts", "chunked_list": ["import { ItemView, WorkspaceLeaf } from \"obsidian\";\n\timport Component from \"./components/MainComponent.svelte\";\n\timport DendronTreePlugin from \"./main\";\n\timport * as store from \"./store\";\n\timport { dendronActivityBarName } from \"./icons\";\n\texport const VIEW_TYPE_DENDRON = \"dendron-tree-view\";\n\texport class DendronView extends ItemView {\n\t  component: Component;\n\t  icon = dendronActivityBarName;\n\t  constructor(leaf: WorkspaceLeaf, private plugin: DendronTreePlugin) {\n", "    super(leaf);\n\t  }\n\t  getViewType() {\n\t    return VIEW_TYPE_DENDRON;\n\t  }\n\t  getDisplayText() {\n\t    return \"Dendron Tree\";\n\t  }\n\t  async onOpen() {\n\t    store.plugin.set(this.plugin);\n", "    this.component = new Component({\n\t      target: this.contentEl,\n\t    });\n\t  }\n\t  async onClose() {\n\t    this.component.$destroy();\n\t  }\n\t}\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { Menu, Plugin, TAbstractFile, TFile, addIcon } from \"obsidian\";\n\timport { DendronView, VIEW_TYPE_DENDRON } from \"./view\";\n\timport { activeFile, dendronVaultList } from \"./store\";\n\timport { LookupModal } from \"./modal/lookup\";\n\timport { dendronActivityBarIcon, dendronActivityBarName } from \"./icons\";\n\timport { DEFAULT_SETTINGS, DendronTreePluginSettings, DendronTreeSettingTab } from \"./settings\";\n\timport { parsePath } from \"./path\";\n\timport { DendronWorkspace } from \"./engine/workspace\";\n\timport { CustomResolver } from \"./custom-resolver\";\n\texport default class DendronTreePlugin extends Plugin {\n", "  settings: DendronTreePluginSettings;\n\t  workspace: DendronWorkspace = new DendronWorkspace(this.app);\n\t  customResolver?: CustomResolver;\n\t  async onload() {\n\t    await this.loadSettings();\n\t    await this.migrateSettings();\n\t    addIcon(dendronActivityBarName, dendronActivityBarIcon);\n\t    this.addCommand({\n\t      id: \"dendron-lookup\",\n\t      name: \"Lookup Note\",\n", "      callback: () => {\n\t        new LookupModal(this.app, this.workspace).open();\n\t      },\n\t    });\n\t    this.addSettingTab(new DendronTreeSettingTab(this.app, this));\n\t    this.registerView(VIEW_TYPE_DENDRON, (leaf) => new DendronView(leaf, this));\n\t    this.addRibbonIcon(dendronActivityBarName, \"Open Dendron Tree\", () => {\n\t      this.activateView();\n\t    });\n\t    this.app.workspace.onLayoutReady(() => {\n", "      this.onRootFolderChanged();\n\t      this.registerEvent(this.app.vault.on(\"create\", this.onCreateFile));\n\t      this.registerEvent(this.app.vault.on(\"delete\", this.onDeleteFile));\n\t      this.registerEvent(this.app.vault.on(\"rename\", this.onRenameFile));\n\t      this.registerEvent(this.app.metadataCache.on(\"resolve\", this.onResolveMetadata));\n\t      this.registerEvent(this.app.workspace.on(\"file-open\", this.onOpenFile, this));\n\t      this.registerEvent(this.app.workspace.on(\"file-menu\", this.onFileMenu));\n\t    });\n\t    this.configureCustomResolver();\n\t  }\n", "  async migrateSettings() {\n\t    function pathToVaultConfig(path: string) {\n\t      const { name } = parsePath(path);\n\t      if (name.length === 0)\n\t        return {\n\t          name: \"root\",\n\t          path: \"/\",\n\t        };\n\t      let processed = path;\n\t      if (processed.endsWith(\"/\")) processed = processed.slice(0, -1);\n", "      if (processed.startsWith(\"/\") && processed.length > 1) processed = processed.slice(1);\n\t      return {\n\t        name,\n\t        path: processed,\n\t      };\n\t    }\n\t    if (this.settings.vaultPath) {\n\t      this.settings.vaultList = [pathToVaultConfig(this.settings.vaultPath)];\n\t      this.settings.vaultPath = undefined;\n\t      await this.saveSettings();\n", "    }\n\t    if (this.settings.vaultList.length > 0 && typeof this.settings.vaultList[0] === \"string\") {\n\t      this.settings.vaultList = (this.settings.vaultList as unknown as string[]).map((path) =>\n\t        pathToVaultConfig(path)\n\t      );\n\t      await this.saveSettings();\n\t    }\n\t  }\n\t  onunload() {}\n\t  onRootFolderChanged() {\n", "    this.workspace.changeVault(this.settings.vaultList);\n\t    this.updateNoteStore();\n\t  }\n\t  configureCustomResolver() {\n\t    if (this.settings.customResolver && !this.customResolver) {\n\t      this.customResolver = new CustomResolver(this, this.workspace);\n\t      this.addChild(this.customResolver);\n\t    } else if (!this.settings.customResolver && this.customResolver) {\n\t      this.removeChild(this.customResolver);\n\t      this.customResolver = undefined;\n", "    }\n\t  }\n\t  updateNoteStore() {\n\t    dendronVaultList.set(this.workspace.vaultList);\n\t  }\n\t  onCreateFile = async (file: TAbstractFile) => {\n\t    const vault = this.workspace.findVaultByParent(file.parent);\n\t    if (vault && vault.onFileCreated(file)) {\n\t      if (this.settings.autoGenerateFrontmatter && file instanceof TFile && file.stat.size === 0)\n\t        await vault.generateFronmatter(file);\n", "      this.updateNoteStore();\n\t    }\n\t  };\n\t  onDeleteFile = (file: TAbstractFile) => {\n\t    // file.parent is null when file is deleted\n\t    const parsed = parsePath(file.path);\n\t    const vault = this.workspace.findVaultByParentPath(parsed.dir);\n\t    if (vault && vault.onFileDeleted(parsed)) {\n\t      this.updateNoteStore();\n\t    }\n", "  };\n\t  onRenameFile = (file: TAbstractFile, oldPath: string) => {\n\t    const oldParsed = parsePath(oldPath);\n\t    const oldVault = this.workspace.findVaultByParentPath(oldParsed.dir);\n\t    let update = false;\n\t    if (oldVault) {\n\t      update = oldVault.onFileDeleted(oldParsed);\n\t    }\n\t    const newVault = this.workspace.findVaultByParent(file.parent);\n\t    if (newVault) {\n", "      update = newVault.onFileCreated(file) || update;\n\t    }\n\t    if (update) this.updateNoteStore();\n\t  };\n\t  onOpenFile(file: TFile | null) {\n\t    activeFile.set(file);\n\t    if (file && this.settings.autoReveal) this.revealFile(file);\n\t  }\n\t  onFileMenu = (menu: Menu, file: TAbstractFile) => {\n\t    if (!(file instanceof TFile)) return;\n", "    menu.addItem((item) => {\n\t      item\n\t        .setIcon(dendronActivityBarName)\n\t        .setTitle(\"Reveal in Dendron Tree\")\n\t        .onClick(() => this.revealFile(file));\n\t    });\n\t  };\n\t  onResolveMetadata = (file: TFile) => {\n\t    const vault = this.workspace.findVaultByParent(file.parent);\n\t    if (vault && vault.onMetadataChanged(file)) {\n", "      this.updateNoteStore();\n\t    }\n\t  };\n\t  revealFile(file: TFile) {\n\t    const vault = this.workspace.findVaultByParent(file.parent);\n\t    if (!vault) return;\n\t    const note = vault.tree.getFromFileName(file.basename);\n\t    if (!note) return;\n\t    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_DENDRON)) {\n\t      if (!(leaf.view instanceof DendronView)) continue;\n", "      leaf.view.component.focusTo(vault, note);\n\t    }\n\t  }\n\t  async activateView() {\n\t    const leafs = this.app.workspace.getLeavesOfType(VIEW_TYPE_DENDRON);\n\t    if (leafs.length == 0) {\n\t      const leaf = this.app.workspace.getLeftLeaf(false);\n\t      await leaf.setViewState({\n\t        type: VIEW_TYPE_DENDRON,\n\t        active: true,\n", "      });\n\t      this.app.workspace.revealLeaf(leaf);\n\t    } else {\n\t      leafs.forEach((leaf) => this.app.workspace.revealLeaf(leaf));\n\t    }\n\t  }\n\t  async loadSettings() {\n\t    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\n\t  }\n\t  async saveSettings() {\n", "    await this.saveData(this.settings);\n\t  }\n\t}\n"]}
{"filename": "src/store.ts", "chunked_list": ["import { derived, get, writable } from \"svelte/store\";\n\timport type DendronTreePlugin from \"./main\";\n\timport { TFile } from \"obsidian\";\n\timport { DendronVault } from \"./engine/vault\";\n\texport const plugin = writable<DendronTreePlugin>();\n\texport const getPlugin = () => get(plugin);\n\texport const activeFile = writable<TFile | null>();\n\texport const dendronVaultList = writable<DendronVault[]>([]);\n\texport const getDendronVaultList = () => get(dendronVaultList);\n\texport const showVaultPath = derived(dendronVaultList, ($list) => $list.length > 1);\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import { App, OpenViewState, TAbstractFile, TFile, Vault } from \"obsidian\";\n\timport { customAlphabet as nanoid } from \"nanoid\";\n\texport function getFolderFile(vault: Vault, path: string) {\n\t  return path.length === 0 ? vault.getRoot() : vault.getAbstractFileByPath(path);\n\t}\n\texport function openFile(\n\t  app: App,\n\t  file: TAbstractFile | undefined | null,\n\t  openState?: OpenViewState\n\t) {\n", "  if (!file || !(file instanceof TFile)) return;\n\t  const leaf = app.workspace.getLeaf();\n\t  return leaf.openFile(file, openState);\n\t}\n\tconst alphanumericLowercase = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\texport const generateUUID = nanoid(alphanumericLowercase, 23);\n"]}
{"filename": "src/settings.ts", "chunked_list": ["import { App, Notice, PluginSettingTab, Setting } from \"obsidian\";\n\timport DendronTreePlugin from \"./main\";\n\timport { VaultConfig } from \"./engine/vault\";\n\timport { AddVaultModal } from \"./modal/add-vault\";\n\texport interface DendronTreePluginSettings {\n\t  /**\n\t   * @deprecated use vaultList\n\t   */\n\t  vaultPath?: string;\n\t  vaultList: VaultConfig[];\n", "  autoGenerateFrontmatter: boolean;\n\t  autoReveal: boolean;\n\t  customResolver: boolean;\n\t}\n\texport const DEFAULT_SETTINGS: DendronTreePluginSettings = {\n\t  vaultList: [\n\t    {\n\t      name: \"root\",\n\t      path: \"/\",\n\t    },\n", "  ],\n\t  autoGenerateFrontmatter: true,\n\t  autoReveal: true,\n\t  customResolver: false,\n\t};\n\texport class DendronTreeSettingTab extends PluginSettingTab {\n\t  plugin: DendronTreePlugin;\n\t  constructor(app: App, plugin: DendronTreePlugin) {\n\t    super(app, plugin);\n\t    this.plugin = plugin;\n", "  }\n\t  display(): void {\n\t    const { containerEl } = this;\n\t    containerEl.empty();\n\t    containerEl.createEl(\"h2\", { text: \"Dendron Tree Settting\" });\n\t    new Setting(containerEl)\n\t      .setName(\"Auto Generate Front Matter\")\n\t      .setDesc(\"Generate front matter for new file even if file is created outside of Dendron tree\")\n\t      .addToggle((toggle) => {\n\t        toggle.setValue(this.plugin.settings.autoGenerateFrontmatter).onChange(async (value) => {\n", "          this.plugin.settings.autoGenerateFrontmatter = value;\n\t          await this.plugin.saveSettings();\n\t        });\n\t      });\n\t    new Setting(containerEl)\n\t      .setName(\"Auto Reveal\")\n\t      .setDesc(\"Automatically reveal active file in Dendron Tree\")\n\t      .addToggle((toggle) => {\n\t        toggle.setValue(this.plugin.settings.autoReveal).onChange(async (value) => {\n\t          this.plugin.settings.autoReveal = value;\n", "          await this.plugin.saveSettings();\n\t        });\n\t      });\n\t    new Setting(containerEl)\n\t      .setName(\"Custom Resolver\")\n\t      .setDesc(\n\t        \"Use custom resolver to resolve ref/embed and link. (Please reopen editor after change this setting)\"\n\t      )\n\t      .addToggle((toggle) => {\n\t        toggle.setValue(this.plugin.settings.customResolver).onChange(async (value) => {\n", "          this.plugin.settings.customResolver = value;\n\t          await this.plugin.saveSettings();\n\t        });\n\t      });\n\t    new Setting(containerEl).setName(\"Vault List\").setHeading();\n\t    for (const vault of this.plugin.settings.vaultList) {\n\t      new Setting(containerEl)\n\t        .setName(vault.name)\n\t        .setDesc(`Folder: ${vault.path}`)\n\t        .addButton((btn) => {\n", "          btn.setButtonText(\"Remove\").onClick(async () => {\n\t            this.plugin.settings.vaultList.remove(vault);\n\t            await this.plugin.saveSettings();\n\t            this.display();\n\t          });\n\t        });\n\t    }\n\t    new Setting(containerEl).addButton((btn) => {\n\t      btn.setButtonText(\"Add Vault\").onClick(() => {\n\t        new AddVaultModal(this.app, (config) => {\n", "          const list = this.plugin.settings.vaultList;\n\t          const nameLowecase = config.name.toLowerCase();\n\t          if (list.find(({ name }) => name.toLowerCase() === nameLowecase)) {\n\t            new Notice(\"Vault with same name already exist\");\n\t            return false;\n\t          }\n\t          if (list.find(({ path }) => path === config.path)) {\n\t            new Notice(\"Vault with same path already exist\");\n\t            return false;\n\t          }\n", "          list.push(config);\n\t          this.plugin.saveSettings().then(() => this.display());\n\t          return true;\n\t        }).open();\n\t      });\n\t    });\n\t  }\n\t  hide() {\n\t    super.hide();\n\t    this.plugin.onRootFolderChanged();\n", "    this.plugin.configureCustomResolver();\n\t  }\n\t}\n"]}
{"filename": "src/path.test.ts", "chunked_list": ["import { parsePath } from \"./path\";\n\tdescribe(\"parse path\", () => {\n\t  it(\"parse path with 2 component\", () => {\n\t    expect(parsePath(\"abc/ll.md\")).toStrictEqual({\n\t      dir: \"abc\",\n\t      name: \"ll.md\",\n\t      basename: \"ll\",\n\t      extension: \"md\",\n\t    });\n\t  });\n", "  it(\"parse path with 1 component\", () => {\n\t    expect(parsePath(\"hugo.md\")).toStrictEqual({\n\t      dir: \"\",\n\t      name: \"hugo.md\",\n\t      basename: \"hugo\",\n\t      extension: \"md\",\n\t    });\n\t  });\n\t  it(\"parse path with name contain multiple dot\", () => {\n\t    expect(parsePath(\"baca.buku.md\")).toStrictEqual({\n", "      dir: \"\",\n\t      name: \"baca.buku.md\",\n\t      basename: \"baca.buku\",\n\t      extension: \"md\",\n\t    });\n\t  });\n\t  it(\"parse path with multiple component\", () => {\n\t    expect(parsePath(\"baca/buku/dirumah/pacar.md\")).toStrictEqual({\n\t      dir: \"baca/buku/dirumah\",\n\t      name: \"pacar.md\",\n", "      basename: \"pacar\",\n\t      extension: \"md\",\n\t    });\n\t  });\n\t  it(\"parse windows path\", () => {\n\t    expect(parsePath(\"abc\\\\ll.md\")).toStrictEqual({\n\t      dir: \"abc\",\n\t      name: \"ll.md\",\n\t      basename: \"ll\",\n\t      extension: \"md\",\n", "    });\n\t  });\n\t});\n"]}
{"filename": "src/icons.ts", "chunked_list": ["export const dendronActivityBarName = \"dendron-activity-bar\";\n\texport const dendronActivityBarIcon = `<path d=\"M51.263 53.512a5.349 5.349 0 0 0-5.349 5.348 5.349 5.349 0 0 0 2.399 4.456c.014-.185.031-.356.031-.595h5.814c0 .221-.014.436-.027.652a5.349 5.349 0 0 0 2.48-4.513 5.349 5.349 0 0 0-5.348-5.348zm-2.95 9.804a5.349 5.349 0 0 0 .201.122 5.349 5.349 0 0 1-.201-.122zm.201.122a5.349 5.349 0 0 0 .4.219 5.349 5.349 0 0 1-.4-.219zm.4.219a5.349 5.349 0 0 0 .177.088 5.349 5.349 0 0 1-.177-.088zm.177.088a5.349 5.349 0 0 0 .562.21 5.349 5.349 0 0 1-.562-.21zm.562.21a5.349 5.349 0 0 0 .187.056 5.349 5.349 0 0 1-.187-.057zm.187.056a5.349 5.349 0 0 0 .603.131 5.349 5.349 0 0 1-.603-.131Zm.603.131a5.349 5.349 0 0 0 .152.02 5.349 5.349 0 0 1-.152-.02Zm.152.02a5.349 5.349 0 0 0 .668.047 5.349 5.349 0 0 1-.668-.047Zm.668.047a5.349 5.349 0 0 0 .669-.048 5.349 5.349 0 0 1-.67.048zm.669-.048a5.349 5.349 0 0 0 .18-.025 5.349 5.349 0 0 1-.18.026zm.18-.025a5.349 5.349 0 0 0 .645-.14 5.349 5.349 0 0 1-.644.14zm2.017-.762a5.349 5.349 0 0 1-.559.305 5.349 5.349 0 0 0 .56-.305zm-.559.305a5.349 5.349 0 0 1-.185.084 5.349 5.349 0 0 0 .185-.084zm-.185.084a5.349 5.349 0 0 1-.561.21 5.349 5.349 0 0 0 .56-.21zm-.561.21a5.349 5.349 0 0 1-.067.022 5.349 5.349 0 0 0 .067-.022zm20.218-8.717c-2.223 0-4.058 1.835-4.058 4.058s1.835 4.058 4.058 4.058c2.222 0 4.058-1.835 4.058-4.058s-1.836-4.058-4.058-4.058zm0 3.14c.526 0 .918.392.918.918a.896.896 0 0 1-.918.919.896.896 0 0 1-.919-.919c0-.526.393-.919.919-.919zM53.154 43.51c-.798 4.917 2.592 9.621 7.51 10.42 4.916.797 9.62-2.593 10.419-7.51.797-4.917-2.593-9.621-7.51-10.419s-9.621 2.593-10.419 7.51zm5.739.932c.294-1.816 1.933-2.997 3.749-2.702 1.815.295 2.996 1.933 2.702 3.749-.295 1.815-1.934 2.996-3.75 2.701-1.815-.294-2.996-1.933-2.701-3.748zM42.46 18.465c-6.727 0-12.244 5.516-12.244 12.244s5.517 12.244 12.244 12.244c6.728 0 12.245-5.516 12.245-12.244S49.188 18.465 42.46 18.465zm0 5.814a6.387 6.387 0 0 1 6.43 6.43 6.387 6.387 0 0 1-6.43 6.43 6.387 6.387 0 0 1-6.43-6.43 6.387 6.387 0 0 1 6.43-6.43zm28.547 38.186v5.116c0 1.432-.194 1.47-.662 1.777a2.75 2.75 0 0 1-.439.22l-.022.01-.064.024c-.276.11-.628.234-1.02.371-.385.136-.817.29-1.283.477l-.01.003-.001.001-14.22 5-.032.013c-1.121.439-3.369 1.019-5.427 2.193-2.058 1.174-4.164 3.413-4.003 6.528l-.003-.105v14.956a50 50 0 0 0 3.71.265 50 50 0 0 0 .36-.026V84.04l-.003-.052c-.072-1.385.555-1.984 1.956-2.783 1.401-.8 3.34-1.33 4.893-1.938l-.067.025 14.231-5.004.045-.018c.905-.367 2.238-.593 3.633-1.51 1.395-.916 2.498-2.82 2.498-5.179v-5.116Zm-3.49 7.995zM39.6 41.453V73.67c-.03.306-.047.617-.047.935h.047v24.023a50 50 0 0 0 7.93.686 50 50 0 0 0 3.047-.218v-5.02l-.002-.053c-.05-1.37.239-1.562.97-2.113.73-.55 1.932-.957 3.326-1.722l-.04.021 4.38-2.317c.76-.38 2.244-.973 3.572-2.394 1.335-1.427 2.236-3.671 2.236-6.417V52.395h-5.814v26.686c0 1.662-.332 2.086-.669 2.447-.337.36-.952.674-1.952 1.178l-.027.013-4.464 2.361-.02.011c-.513.282-2.293.869-4.028 2.176-1.022.77-2.009 1.974-2.631 3.467v-16.94c.078-.574.253-.763.496-1.011.332-.339 1.085-.756 2.205-1.295 1.121-.54 2.617-1.218 3.916-2.65 1.3-1.433 2.127-3.597 2.127-6.117h-5.814c0 .72-.067 1.176-.178 1.5a1.737 1.737 0 0 1-.198.407 2.522 2.522 0 0 1-.244.304c-.349.385-1.051.798-2.128 1.316l-.182.087V41.453Zm11-35.639c5.965 0 11.756 1.163 17.198 3.465a43.866 43.866 0 0 1 14.046 9.477 44.246 44.246 0 0 1 9.477 14.046c2.302 5.442 3.465 11.233 3.465 17.198s-1.163 11.756-3.465 17.198a43.866 43.866 0 0 1-9.477 14.046 44.246 44.246 0 0 1-14.046 9.477c-5.454 2.302-11.233 3.465-17.198 3.465s-11.756-1.163-17.198-3.465a43.866 43.866 0 0 1-14.046-9.477 44.246 44.246 0 0 1-9.477-14.046C7.577 61.756 6.414 55.965 6.414 50s1.163-11.756 3.465-17.198a43.866 43.866 0 0 1 9.477-14.046 44.246 44.246 0 0 1 14.046-9.477A44.073 44.073 0 0 1 50.6 5.814M50.6 0C22.984 0 .6 22.384.6 50s22.384 50 50 50 50-22.384 50-50-22.384-50-50-50z\" fill=\"currentcolor\"/>`;\n"]}
{"filename": "src/modal/lookup.ts", "chunked_list": ["import { App, SuggestModal, getIcon } from \"obsidian\";\n\timport { Note } from \"../engine/note\";\n\timport { openFile } from \"../utils\";\n\timport { DendronVault } from \"../engine/vault\";\n\timport { SelectVaultModal } from \"./select-vault\";\n\timport { DendronWorkspace } from \"../engine/workspace\";\n\tinterface LookupItem {\n\t  note: Note;\n\t  vault: DendronVault;\n\t}\n", "export class LookupModal extends SuggestModal<LookupItem | null> {\n\t  constructor(app: App, private workspace: DendronWorkspace, private initialQuery: string = \"\") {\n\t    super(app);\n\t  }\n\t  onOpen(): void {\n\t    super.onOpen();\n\t    if (this.initialQuery.length > 0) {\n\t      this.inputEl.value = this.initialQuery;\n\t      this.inputEl.dispatchEvent(new Event(\"input\"));\n\t    }\n", "  }\n\t  getSuggestions(query: string): (LookupItem | null)[] {\n\t    const queryLowercase = query.toLowerCase();\n\t    const result: (LookupItem | null)[] = [];\n\t    let foundExact = true;\n\t    for (const vault of this.workspace.vaultList) {\n\t      let currentFoundExact = false;\n\t      for (const note of vault.tree.flatten()) {\n\t        const path = note.getPath();\n\t        const item: LookupItem = {\n", "          note,\n\t          vault,\n\t        };\n\t        if (path === queryLowercase) {\n\t          currentFoundExact = true;\n\t          result.unshift(item);\n\t          continue;\n\t        }\n\t        if (\n\t          note.title.toLowerCase().includes(queryLowercase) ||\n", "          note.name.includes(queryLowercase) ||\n\t          path.includes(queryLowercase)\n\t        )\n\t          result.push(item);\n\t      }\n\t      foundExact = foundExact && currentFoundExact;\n\t    }\n\t    if (!foundExact && queryLowercase.trim().length > 0) result.unshift(null);\n\t    return result;\n\t  }\n", "  renderSuggestion(item: LookupItem | null, el: HTMLElement) {\n\t    el.classList.add(\"mod-complex\");\n\t    el.createEl(\"div\", { cls: \"suggestion-content\" }, (el) => {\n\t      el.createEl(\"div\", { text: item?.note.title ?? \"Create New\", cls: \"suggestion-title\" });\n\t      el.createEl(\"small\", {\n\t        text: item\n\t          ? item.note.getPath() +\n\t            (this.workspace.vaultList.length > 1 ? ` (${item.vault.config.name})` : \"\")\n\t          : \"Note does not exist\",\n\t        cls: \"suggestion-content\",\n", "      });\n\t    });\n\t    if (!item || !item.note.file)\n\t      el.createEl(\"div\", { cls: \"suggestion-aux\" }, (el) => {\n\t        el.append(getIcon(\"plus\")!);\n\t      });\n\t  }\n\t  async onChooseSuggestion(item: LookupItem | null, evt: MouseEvent | KeyboardEvent) {\n\t    if (item && item.note.file) {\n\t      openFile(this.app, item.note.file);\n", "      return;\n\t    }\n\t    const path = item ? item.note.getPath() : this.inputEl.value;\n\t    const doCreate = async (vault: DendronVault) => {\n\t      const file = await vault.createNote(path);\n\t      return openFile(vault.app, file);\n\t    };\n\t    if (item?.vault) {\n\t      await doCreate(item.vault);\n\t    } else if (this.workspace.vaultList.length == 1) {\n", "      await doCreate(this.workspace.vaultList[0]);\n\t    } else {\n\t      new SelectVaultModal(this.app, this.workspace, doCreate).open();\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/modal/add-vault.ts", "chunked_list": ["import { App, Modal, Notice, PopoverSuggest, Setting, TFolder, TextComponent } from \"obsidian\";\n\timport { VaultConfig } from \"src/engine/vault\";\n\tclass FolderSuggester extends PopoverSuggest<TFolder> {\n\t  constructor(\n\t    public app: App,\n\t    public inputEl: HTMLInputElement,\n\t    public onSelected: (folder: TFolder) => void\n\t  ) {\n\t    super(app);\n\t    inputEl.addEventListener(\"input\", this.onInputChange);\n", "    inputEl.addEventListener(\"focus\", this.onInputChange);\n\t    inputEl.addEventListener(\"blur\", () => this.close());\n\t    this.suggestEl.on(\"mousedown\", \".suggestion-item\", (e) => e.preventDefault());\n\t    this.suggestEl.classList.add(\"dendron-folder-suggest\");\n\t  }\n\t  onInputChange = () => {\n\t    const suggestionList = this.getSuggestions(this.inputEl.value);\n\t    if (suggestionList.length === 0) {\n\t      this.close();\n\t      return;\n", "    }\n\t    this.suggestions.setSuggestions(suggestionList);\n\t    this.open();\n\t    this.setAutoDestroy(this.inputEl);\n\t    this.suggestEl.style.width = `${this.inputEl.offsetWidth}px`;\n\t    const loc = this.inputEl.getBoundingClientRect();\n\t    this.reposition({\n\t      left: loc.left,\n\t      right: loc.right,\n\t      top: loc.top,\n", "      bottom: loc.top + this.inputEl.offsetHeight,\n\t    });\n\t  };\n\t  getSuggestions(query: string) {\n\t    const queryLowercase = query.toLowerCase();\n\t    return this.app.vault\n\t      .getAllLoadedFiles()\n\t      .filter(\n\t        (file) => file instanceof TFolder && file.path.toLowerCase().contains(queryLowercase)\n\t      ) as TFolder[];\n", "  }\n\t  renderSuggestion(value: TFolder, el: HTMLElement): void {\n\t    el.createDiv({\n\t      text: value.path,\n\t    });\n\t  }\n\t  selectSuggestion(value: TFolder, evt: MouseEvent | KeyboardEvent): void {\n\t    this.inputEl.value = value.path;\n\t    this.close();\n\t    this.onSelected(value);\n", "  }\n\t}\n\texport class AddVaultModal extends Modal {\n\t  folder?: TFolder;\n\t  nameText: TextComponent;\n\t  constructor(app: App, public onSubmit: (config: VaultConfig) => boolean) {\n\t    super(app);\n\t  }\n\t  generateName({ path, name }: TFolder) {\n\t    if (path === \"/\") return \"root\";\n", "    return name;\n\t  }\n\t  onOpen(): void {\n\t    new Setting(this.contentEl).setHeading().setName(\"Add Vault\");\n\t    new Setting(this.contentEl).setName(\"Vault Path\").addText((text) => {\n\t      new FolderSuggester(this.app, text.inputEl, (newFolder) => {\n\t        const currentName = this.nameText.getValue();\n\t        if (\n\t          currentName.length === 0 ||\n\t          (this.folder && currentName === this.generateName(this.folder))\n", "        )\n\t          this.nameText.setValue(this.generateName(newFolder));\n\t        this.folder = newFolder;\n\t      });\n\t    });\n\t    new Setting(this.contentEl).setName(\"Vault Name\").addText((text) => {\n\t      this.nameText = text;\n\t    });\n\t    new Setting(this.contentEl).addButton((btn) => {\n\t      btn\n", "        .setCta()\n\t        .setButtonText(\"Add Text\")\n\t        .onClick(() => {\n\t          const name = this.nameText.getValue();\n\t          if (!this.folder || name.trim().length === 0) {\n\t            new Notice(\"Please specify Vault Path and Vault Name\");\n\t            return;\n\t          }\n\t          if (\n\t            this.onSubmit({\n", "              path: this.folder.path,\n\t              name,\n\t            })\n\t          )\n\t            this.close();\n\t        });\n\t    });\n\t  }\n\t  onClose() {\n\t    this.contentEl.empty();\n", "  }\n\t}\n"]}
{"filename": "src/modal/select-vault.ts", "chunked_list": ["import { App, SuggestModal } from \"obsidian\";\n\timport { DendronVault } from \"../engine/vault\";\n\timport { DendronWorkspace } from \"../engine/workspace\";\n\texport class SelectVaultModal extends SuggestModal<DendronVault> {\n\t  constructor(\n\t    app: App,\n\t    private workspace: DendronWorkspace,\n\t    private onSelected: (item: DendronVault) => void\n\t  ) {\n\t    super(app);\n", "  }\n\t  getSuggestions(query: string): DendronVault[] | Promise<DendronVault[]> {\n\t    const queryLowercase = query.toLowerCase();\n\t    return this.workspace.vaultList.filter(\n\t      (value) =>\n\t        value.config.path.toLowerCase().contains(queryLowercase) ||\n\t        value.config.name.toLowerCase().contains(queryLowercase)\n\t    );\n\t  }\n\t  renderSuggestion(value: DendronVault, el: HTMLElement) {\n", "    el.createEl(\"div\", { text: value.config.name });\n\t    el.createEl(\"small\", {\n\t      text: value.config.path,\n\t    });\n\t  }\n\t  onChooseSuggestion(item: DendronVault, evt: MouseEvent | KeyboardEvent) {\n\t    this.onSelected(item);\n\t  }\n\t}\n"]}
{"filename": "src/modal/invalid-root.ts", "chunked_list": ["import { Modal, Setting } from \"obsidian\";\n\timport { DendronVault } from \"../engine/vault\";\n\texport class InvalidRootModal extends Modal {\n\t  constructor(private dendronVault: DendronVault) {\n\t    super(dendronVault.app);\n\t  }\n\t  onOpen(): void {\n\t    this.contentEl.createEl(\"h1\", { text: \"Invalid Root\" });\n\t    this.contentEl.createEl(\"p\", {\n\t      text: `\"${this.dendronVault.config.path}\" is not folder. Do you want to create this folder?`,\n", "    });\n\t    new Setting(this.contentEl).addButton((button) => {\n\t      button\n\t        .setButtonText(\"Create\")\n\t        .setCta()\n\t        .onClick(async () => {\n\t          await this.dendronVault.createRootFolder();\n\t          this.dendronVault.init();\n\t          this.close();\n\t        });\n", "    });\n\t  }\n\t  onClose() {\n\t    this.contentEl.empty();\n\t  }\n\t}\n"]}
{"filename": "src/engine/note.ts", "chunked_list": ["import { TFile } from \"obsidian\";\n\texport interface NoteMetadata {\n\t  title?: string;\n\t}\n\texport class Note {\n\t  name: string;\n\t  children: Note[] = [];\n\t  file?: TFile;\n\t  parent?: Note;\n\t  title = \"\";\n", "  constructor(private originalName: string, private titlecase: boolean) {\n\t    this.name = originalName.toLowerCase();\n\t    this.syncMetadata(undefined);\n\t  }\n\t  appendChild(note: Note) {\n\t    if (note.parent) throw Error(\"Note has parent\");\n\t    note.parent = this;\n\t    this.children.push(note);\n\t  }\n\t  removeChildren(note: Note) {\n", "    note.parent = undefined;\n\t    const index = this.children.indexOf(note);\n\t    this.children.splice(index, 1);\n\t  }\n\t  findChildren(name: string) {\n\t    const lower = name.toLowerCase();\n\t    return this.children.find((note) => note.name == lower);\n\t  }\n\t  sortChildren(rescursive: boolean) {\n\t    this.children.sort((a, b) => a.name.localeCompare(b.name));\n", "    if (rescursive) this.children.forEach((child) => child.sortChildren(rescursive));\n\t  }\n\t  getPath(original = false) {\n\t    const component: string[] = [];\n\t    const notes = this.getPathNotes();\n\t    if (notes.length === 1) return original ? notes[0].originalName : notes[0].name;\n\t    for (const note of notes) {\n\t      if (!note.parent && note.name === \"root\") continue;\n\t      component.push(original ? note.originalName : note.name);\n\t    }\n", "    return component.join(\".\");\n\t  }\n\t  getPathNotes() {\n\t    const notes: Note[] = [];\n\t    // eslint-disable-next-line @typescript-eslint/no-this-alias\n\t    let current: Note | undefined = this;\n\t    while (current) {\n\t      notes.unshift(current);\n\t      current = current.parent;\n\t    }\n", "    return notes;\n\t  }\n\t  syncMetadata(metadata: NoteMetadata | undefined) {\n\t    this.title = metadata?.title ?? generateNoteTitle(this.originalName, this.titlecase);\n\t  }\n\t}\n\t/**\n\t * Check whetever generated note title must be title case or not\n\t * @param baseName file base name\n\t */\n", "export function isUseTitleCase(baseName: string) {\n\t  return baseName.toLowerCase() === baseName;\n\t}\n\t/**\n\t * Generate title for note\n\t * @param originalName name of note before lowercased (not filename)\n\t * @param titlecase use title case or use original name\n\t * @returns title for note\n\t */\n\texport function generateNoteTitle(originalName: string, titlecase: boolean) {\n", "  if (!titlecase) return originalName;\n\t  return originalName\n\t    .split(\"-\")\n\t    .map((item) => item.trim())\n\t    .filter((item) => item.length > 0)\n\t    .map((word) => {\n\t      return word[0].toUpperCase() + word.substring(1).toLowerCase();\n\t    })\n\t    .join(\" \");\n\t}\n", "export class NoteTree {\n\t  root: Note = new Note(\"root\", true);\n\t  sort() {\n\t    this.root.sortChildren(true);\n\t  }\n\t  public static getPathFromFileName(name: string) {\n\t    return name.split(\".\");\n\t  }\n\t  private static isRootPath(path: string[]) {\n\t    return path.length === 1 && path[0] === \"root\";\n", "  }\n\t  addFile(file: TFile, sort = false) {\n\t    const titlecase = isUseTitleCase(file.basename);\n\t    const path = NoteTree.getPathFromFileName(file.basename);\n\t    let currentNote: Note = this.root;\n\t    if (!NoteTree.isRootPath(path))\n\t      for (const name of path) {\n\t        let note: Note | undefined = currentNote.findChildren(name);\n\t        if (!note) {\n\t          note = new Note(name, titlecase);\n", "          currentNote.appendChild(note);\n\t          if (sort) currentNote.sortChildren(false);\n\t        }\n\t        currentNote = note;\n\t      }\n\t    currentNote.file = file;\n\t    return currentNote;\n\t  }\n\t  getFromFileName(name: string) {\n\t    const path = NoteTree.getPathFromFileName(name);\n", "    if (NoteTree.isRootPath(path)) return this.root;\n\t    let currentNote: Note = this.root;\n\t    for (const name of path) {\n\t      const found = currentNote.findChildren(name);\n\t      if (!found) return undefined;\n\t      currentNote = found;\n\t    }\n\t    return currentNote;\n\t  }\n\t  deleteByFileName(name: string) {\n", "    const note = this.getFromFileName(name);\n\t    if (!note) return;\n\t    note.file = undefined;\n\t    if (note.children.length == 0) {\n\t      let currentNote: Note | undefined = note;\n\t      while (\n\t        currentNote &&\n\t        currentNote.parent &&\n\t        !currentNote.file &&\n\t        currentNote.children.length == 0\n", "      ) {\n\t        const parent: Note | undefined = currentNote.parent;\n\t        parent.removeChildren(currentNote);\n\t        currentNote = parent;\n\t      }\n\t    }\n\t    return note;\n\t  }\n\t  private static *flattenInternal(root: Note): Generator<Note> {\n\t    yield root;\n", "    for (const child of root.children) yield* this.flattenInternal(child);\n\t  }\n\t  flatten() {\n\t    return Array.from(NoteTree.flattenInternal(this.root));\n\t  }\n\t}\n"]}
{"filename": "src/engine/note.test.ts", "chunked_list": ["import type { Stat, TFile, Vault } from \"obsidian\";\n\timport { Note, NoteTree, generateNoteTitle, isUseTitleCase } from \"./note\";\n\timport { parsePath } from \"../path\";\n\tdescribe(\"note title\", () => {\n\t  it(\"use title case when file name is lowercase\", () => {\n\t    expect(generateNoteTitle(\"kamu-milikku\", isUseTitleCase(\"aku.cinta.kamu-milikku.md\"))).toBe(\n\t      \"Kamu Milikku\"\n\t    );\n\t  });\n\t  it(\"use file name when note name contain uppercase\", () => {\n", "    expect(generateNoteTitle(\"Kamu-Milikku\", isUseTitleCase(\"aku.cinta.Kamu-Milikku.md\"))).toBe(\n\t      \"Kamu-Milikku\"\n\t    );\n\t  });\n\t  it(\"use file name when file name contain uppercase\", () => {\n\t    expect(generateNoteTitle(\"kamu-milikku\", isUseTitleCase(\"Aku.cinta.kamu-milikku.md\"))).toBe(\n\t      \"kamu-milikku\"\n\t    );\n\t  });\n\t});\n", "describe(\"note class\", () => {\n\t  it(\"append and remove child work\", () => {\n\t    const child = new Note(\"lala\", true);\n\t    expect(child.parent).toBeUndefined();\n\t    const parent = new Note(\"apa\", true);\n\t    expect(parent.children).toEqual([]);\n\t    parent.appendChild(child);\n\t    expect(child.parent).toBe(parent);\n\t    expect(parent.children).toEqual([child]);\n\t    parent.removeChildren(child);\n", "    expect(child.parent).toBeUndefined();\n\t    expect(parent.children).toEqual([]);\n\t  });\n\t  it(\"append child must throw if child already has parent\", () => {\n\t    const origParent = new Note(\"root\", true);\n\t    const parent = new Note(\"root2\", true);\n\t    const child = new Note(\"child\", true);\n\t    origParent.appendChild(child);\n\t    expect(() => parent.appendChild(child)).toThrowError(\"has parent\");\n\t  });\n", "  it(\"find children work\", () => {\n\t    const parent = new Note(\"parent\", true);\n\t    const child1 = new Note(\"child1\", true);\n\t    const child2 = new Note(\"child2\", true);\n\t    const child3 = new Note(\"child3\", true);\n\t    parent.appendChild(child1);\n\t    parent.appendChild(child2);\n\t    parent.appendChild(child3);\n\t    expect(parent.findChildren(\"child1\")).toBe(child1);\n\t    expect(parent.findChildren(\"child2\")).toBe(child2);\n", "    expect(parent.findChildren(\"child3\")).toBe(child3);\n\t    expect(parent.findChildren(\"child4\")).toBeUndefined();\n\t  });\n\t  it(\"non-recursive sort children work\", () => {\n\t    const parent = new Note(\"parent\", true);\n\t    const child1 = new Note(\"gajak\", true);\n\t    const child2 = new Note(\"lumba\", true);\n\t    const child3 = new Note(\"biawak\", true);\n\t    parent.appendChild(child1);\n\t    parent.appendChild(child2);\n", "    parent.appendChild(child3);\n\t    expect(parent.children).toEqual([child1, child2, child3]);\n\t    parent.sortChildren(false);\n\t    expect(parent.children).toEqual([child3, child1, child2]);\n\t  });\n\t  it(\"recursive sort children work\", () => {\n\t    const parent = new Note(\"parent\", true);\n\t    const child1 = new Note(\"lumba\", true);\n\t    const child2 = new Note(\"galak\", true);\n\t    const grandchild1 = new Note(\"lupa\", true);\n", "    const grandchild2 = new Note(\"apa\", true);\n\t    const grandchild3 = new Note(\"abu\", true);\n\t    const grandchild4 = new Note(\"lagi\", true);\n\t    parent.appendChild(child1);\n\t    child1.appendChild(grandchild1);\n\t    child1.appendChild(grandchild2);\n\t    parent.appendChild(child2);\n\t    child2.appendChild(grandchild3);\n\t    child2.appendChild(grandchild4);\n\t    expect(parent.children).toEqual([child1, child2]);\n", "    expect(child1.children).toEqual([grandchild1, grandchild2]);\n\t    expect(child2.children).toEqual([grandchild3, grandchild4]);\n\t    parent.sortChildren(true);\n\t    expect(parent.children).toEqual([child2, child1]);\n\t    expect(child1.children).toEqual([grandchild2, grandchild1]);\n\t    expect(child2.children).toEqual([grandchild3, grandchild4]);\n\t  });\n\t  it(\"get path on non-root\", () => {\n\t    const root = new Note(\"root\", true);\n\t    const ch1 = new Note(\"parent\", true);\n", "    const ch2 = new Note(\"parent2\", true);\n\t    const ch3 = new Note(\"child\", true);\n\t    root.appendChild(ch1);\n\t    ch1.appendChild(ch2);\n\t    ch2.appendChild(ch3);\n\t    expect(ch3.getPath()).toBe(\"parent.parent2.child\");\n\t    expect(ch3.getPathNotes()).toEqual([root, ch1, ch2, ch3]);\n\t  });\n\t  it(\"get path on root\", () => {\n\t    const root = new Note(\"root\", true);\n", "    expect(root.getPath()).toBe(\"root\");\n\t    expect(root.getPathNotes()).toEqual([root]);\n\t  });\n\t  it(\"use generated title when titlecase true\", () => {\n\t    const note = new Note(\"aku-cinta\", true);\n\t    expect(note.title).toBe(\"Aku Cinta\");\n\t  });\n\t  it(\"use filename as title when titlecase false\", () => {\n\t    const note = new Note(\"aKu-ciNta\", false);\n\t    expect(note.title).toBe(\"aKu-ciNta\");\n", "  });\n\t  it(\"use metadata title when has metadata\", () => {\n\t    const note = new Note(\"aKu-ciNta\", false);\n\t    note.syncMetadata({\n\t      title: \"Butuh Kamu\",\n\t    });\n\t    expect(note.title).toBe(\"Butuh Kamu\");\n\t  });\n\t});\n\tfunction createTFile(path: string): TFile {\n", "  const { basename, name, extension } = parsePath(path);\n\t  return {\n\t    basename,\n\t    extension,\n\t    name,\n\t    parent: null,\n\t    path: path,\n\t    stat: null as unknown as Stat,\n\t    vault: null as unknown as Vault,\n\t  };\n", "}\n\tdescribe(\"tree class\", () => {\n\t  it(\"add file without sort\", () => {\n\t    const tree = new NoteTree();\n\t    tree.addFile(createTFile(\"abc.def.jkl.md\"));\n\t    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n\t    expect(tree.root.children.length).toBe(1);\n\t    expect(tree.root.children[0].name).toBe(\"abc\");\n\t    expect(tree.root.children[0].children.length).toBe(1);\n\t    expect(tree.root.children[0].children[0].name).toBe(\"def\");\n", "    expect(tree.root.children[0].children[0].children.length).toBe(2);\n\t    expect(tree.root.children[0].children[0].children[0].name).toBe(\"jkl\");\n\t    expect(tree.root.children[0].children[0].children[1].name).toBe(\"ghi\");\n\t  });\n\t  it(\"add file with sort\", () => {\n\t    const tree = new NoteTree();\n\t    tree.addFile(createTFile(\"abc.def.jkl.md\"), true);\n\t    tree.addFile(createTFile(\"abc.def.ghi.md\"), true);\n\t    tree.addFile(createTFile(\"abc.def.mno.md\"), true);\n\t    expect(tree.root.children[0].children[0].children.length).toBe(3);\n", "    expect(tree.root.children[0].children[0].children[0].name).toBe(\"ghi\");\n\t    expect(tree.root.children[0].children[0].children[1].name).toBe(\"jkl\");\n\t    expect(tree.root.children[0].children[0].children[2].name).toBe(\"mno\");\n\t  });\n\t  it(\"get note by file base name\", () => {\n\t    const tree = new NoteTree();\n\t    tree.addFile(createTFile(\"abc.def.jkl.md\"));\n\t    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n\t    expect(tree.getFromFileName(\"abc.def.jkl\")?.name).toBe(\"jkl\");\n\t    expect(tree.getFromFileName(\"abc.def.ghi\")?.name).toBe(\"ghi\");\n", "    expect(tree.getFromFileName(\"abc.def.mno\")).toBeUndefined();\n\t  });\n\t  it(\"get note using blank path\", () => {\n\t    const tree = new NoteTree();\n\t    tree.addFile(createTFile(\"abc.def.jkl.md\"));\n\t    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n\t    expect(tree.getFromFileName(\"\")).toBeUndefined()\n\t  })\n\t  it(\"delete note if do not have children\", () => {\n\t    const tree = new NoteTree();\n", "    tree.addFile(createTFile(\"abc.md\"));\n\t    tree.deleteByFileName(\"abc\");\n\t    expect(tree.getFromFileName(\"abc\")).toBeUndefined();\n\t  });\n\t  it(\"do not delete note if have children\", () => {\n\t    const tree = new NoteTree();\n\t    tree.addFile(createTFile(\"abc.md\"));\n\t    tree.addFile(createTFile(\"abc.def.md\"));\n\t    tree.deleteByFileName(\"abc\");\n\t    expect(tree.getFromFileName(\"abc\")?.name).toBe(\"abc\");\n", "    expect(tree.getFromFileName(\"abc.def\")?.name).toBe(\"def\");\n\t  });\n\t  it(\"delete note and parent if do not have children and parent file is null\", () => {\n\t    const tree = new NoteTree();\n\t    tree.addFile(createTFile(\"abc\"));\n\t    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n\t    tree.deleteByFileName(\"abc.def.ghi\");\n\t    expect(tree.getFromFileName(\"abc.def.ghi\")).toBeUndefined();\n\t    expect(tree.getFromFileName(\"abc.def\")).toBeUndefined();\n\t    expect(tree.getFromFileName(\"abc\")?.name).toBe(\"abc\");\n", "  });\n\t  it(\"sort note\", () => {\n\t    const tree = new NoteTree();\n\t    tree.addFile(createTFile(\"abc.def.jkl.md\"));\n\t    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n\t    tree.addFile(createTFile(\"abc.def.mno.md\"));\n\t    expect(tree.root.children[0].children[0].children.length).toBe(3);\n\t    expect(tree.root.children[0].children[0].children[0].name).toBe(\"jkl\");\n\t    expect(tree.root.children[0].children[0].children[1].name).toBe(\"ghi\");\n\t    expect(tree.root.children[0].children[0].children[2].name).toBe(\"mno\");\n", "    tree.sort();\n\t    expect(tree.root.children[0].children[0].children[0].name).toBe(\"ghi\");\n\t    expect(tree.root.children[0].children[0].children[1].name).toBe(\"jkl\");\n\t    expect(tree.root.children[0].children[0].children[2].name).toBe(\"mno\");\n\t  });\n\t  it(\"flatten note\", () => {\n\t    const tree = new NoteTree();\n\t    tree.addFile(createTFile(\"abc.def.md\"));\n\t    tree.addFile(createTFile(\"abc.def.ghi.md\"));\n\t    tree.addFile(createTFile(\"abc.jkl.mno.md\"));\n", "    expect(tree.flatten().map((note) => note.getPath())).toEqual([\n\t      \"root\",\n\t      \"abc\",\n\t      \"abc.def\",\n\t      \"abc.def.ghi\",\n\t      \"abc.jkl\",\n\t      \"abc.jkl.mno\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "src/engine/vault.ts", "chunked_list": ["import { App, TAbstractFile, TFile, TFolder } from \"obsidian\";\n\timport { NoteMetadata, NoteTree } from \"./note\";\n\timport { InvalidRootModal } from \"../modal/invalid-root\";\n\timport { generateUUID, getFolderFile } from \"../utils\";\n\timport { ParsedPath } from \"../path\";\n\texport interface VaultConfig {\n\t  path: string;\n\t  name: string;\n\t}\n\texport class DendronVault {\n", "  folder: TFolder;\n\t  tree: NoteTree;\n\t  isIniatialized = false;\n\t  constructor(public app: App, public config: VaultConfig) {}\n\t  private resolveMetadata(file: TFile): NoteMetadata | undefined {\n\t    const frontmatter = this.app.metadataCache.getFileCache(file)?.frontmatter;\n\t    if (!frontmatter) return undefined;\n\t    return {\n\t      title: frontmatter[\"title\"],\n\t    };\n", "  }\n\t  init() {\n\t    if (this.isIniatialized) return;\n\t    this.tree = new NoteTree();\n\t    const root = getFolderFile(this.app.vault, this.config.path);\n\t    if (!(root instanceof TFolder)) {\n\t      new InvalidRootModal(this).open();\n\t      return;\n\t    }\n\t    this.folder = root;\n", "    for (const child of root.children)\n\t      if (child instanceof TFile && this.isNote(child.extension))\n\t        this.tree.addFile(child).syncMetadata(this.resolveMetadata(child));\n\t    this.tree.sort();\n\t    this.isIniatialized = true;\n\t  }\n\t  async createRootFolder() {\n\t    return await this.app.vault.createFolder(this.config.path);\n\t  }\n\t  async createNote(baseName: string) {\n", "    const filePath = `${this.config.path}/${baseName}.md`;\n\t    return await this.app.vault.create(filePath, \"\");\n\t  }\n\t  async generateFronmatter(file: TFile) {\n\t    if (!this.isNote(file.extension)) return;\n\t    const note = this.tree.getFromFileName(file.basename);\n\t    if (!note) return false;\n\t    return await this.app.fileManager.processFrontMatter(file, (fronmatter) => {\n\t      if (!fronmatter.id) fronmatter.id = generateUUID();\n\t      if (!fronmatter.title) fronmatter.title = note.title;\n", "      if (fronmatter.desc === undefined) fronmatter.desc = \"\";\n\t      if (!fronmatter.created) fronmatter.created = file.stat.ctime;\n\t      if (!fronmatter.updated) fronmatter.updated = file.stat.mtime;\n\t    });\n\t  }\n\t  isNote(extension: string) {\n\t    return extension === \"md\";\n\t  }\n\t  onFileCreated(file: TAbstractFile): boolean {\n\t    if (!(file instanceof TFile) || !this.isNote(file.extension)) return false;\n", "    this.tree.addFile(file, true).syncMetadata(this.resolveMetadata(file));\n\t    return true;\n\t  }\n\t  onMetadataChanged(file: TFile): boolean {\n\t    if (!this.isNote(file.extension)) return false;\n\t    const note = this.tree.getFromFileName(file.basename);\n\t    if (!note) return false;\n\t    note.syncMetadata(this.resolveMetadata(file));\n\t    return true;\n\t  }\n", "  onFileDeleted(parsed: ParsedPath): boolean {\n\t    if (!this.isNote(parsed.extension)) return false;\n\t    const note = this.tree.deleteByFileName(parsed.basename);\n\t    if (note?.parent) {\n\t      note.syncMetadata(undefined);\n\t    }\n\t    return true;\n\t  }\n\t}\n"]}
{"filename": "src/engine/workspace.ts", "chunked_list": ["import { App, TFolder, parseLinktext } from \"obsidian\";\n\timport { DendronVault, VaultConfig } from \"./vault\";\n\timport { getFolderFile } from \"../utils\";\n\timport { RefTarget, parseRefSubpath } from \"./ref\";\n\timport { parsePath } from \"../path\";\n\tconst DENDRON_URI_START = \"dendron://\";\n\texport class DendronWorkspace {\n\t  vaultList: DendronVault[] = [];\n\t  constructor(public app: App) {}\n\t  changeVault(vaultList: VaultConfig[]) {\n", "    this.vaultList = vaultList.map((config) => {\n\t      return (\n\t        this.vaultList.find(\n\t          (vault) => vault.config.name === config.name && vault.config.path === config.path\n\t        ) ?? new DendronVault(this.app, config)\n\t      );\n\t    });\n\t    for (const vault of this.vaultList) {\n\t      vault.init();\n\t    }\n", "  }\n\t  findVaultByParent(parent: TFolder | null): DendronVault | undefined {\n\t    return this.vaultList.find((vault) => vault.folder === parent);\n\t  }\n\t  findVaultByParentPath(path: string): DendronVault | undefined {\n\t    const file = getFolderFile(this.app.vault, path);\n\t    return file instanceof TFolder ? this.findVaultByParent(file) : undefined;\n\t  }\n\t  resolveRef(sourcePath: string, link: string): RefTarget | null {\n\t    if (link.startsWith(DENDRON_URI_START)) {\n", "      const [vaultName, rest] = link.slice(DENDRON_URI_START.length).split(\"/\", 2) as (\n\t        | string\n\t        | undefined\n\t      )[];\n\t      const { path, subpath } = rest\n\t        ? parseLinktext(rest)\n\t        : {\n\t            path: undefined,\n\t            subpath: undefined,\n\t          };\n", "      const vault = this.vaultList.find(({ config }) => config.name === vaultName);\n\t      return {\n\t        type: \"maybe-note\",\n\t        vaultName: vaultName ?? \"\",\n\t        vault,\n\t        note: path ? vault?.tree?.getFromFileName(path) : undefined,\n\t        path: path ?? \"\",\n\t        subpath: subpath ? parseRefSubpath(subpath) : undefined,\n\t      };\n\t    }\n", "    const { dir: vaultDir } = parsePath(sourcePath);\n\t    const vault = this.findVaultByParentPath(vaultDir);\n\t    if (!vault) return null;\n\t    const { path, subpath } = parseLinktext(link);\n\t    const target = this.app.metadataCache.getFirstLinkpathDest(path, sourcePath);\n\t    if (target && target.extension !== \"md\")\n\t      return {\n\t        type: \"file\",\n\t        file: target,\n\t      };\n", "    const note = vault.tree.getFromFileName(path);\n\t    return {\n\t      type: \"maybe-note\",\n\t      vaultName: vault.config.name,\n\t      vault: vault,\n\t      note,\n\t      path,\n\t      subpath: parseRefSubpath(subpath.slice(1) ?? \"\"),\n\t    };\n\t  }\n", "}\n"]}
{"filename": "src/engine/ref.ts", "chunked_list": ["import { CachedMetadata, HeadingCache, TFile } from \"obsidian\";\n\timport { Note } from \"./note\";\n\timport { DendronVault } from \"./vault\";\n\timport GithubSlugger from \"github-slugger\";\n\texport interface MaybeNoteRef {\n\t  type: \"maybe-note\";\n\t  vaultName: string;\n\t  vault?: DendronVault;\n\t  note?: Note;\n\t  path: string;\n", "  subpath?: RefSubpath;\n\t}\n\texport interface FileRef {\n\t  type: \"file\";\n\t  file: TFile;\n\t}\n\texport type RefTarget = MaybeNoteRef | FileRef;\n\texport type RefAnchor =\n\t  | {\n\t      type: \"begin\";\n", "    }\n\t  | {\n\t      type: \"end\";\n\t    }\n\t  | {\n\t      type: \"wildcard\";\n\t    }\n\t  | {\n\t      type: \"block\";\n\t      name: string;\n", "    }\n\t  | {\n\t      type: \"header\";\n\t      name: string;\n\t      lineOffset: number;\n\t    };\n\texport interface RefRange {\n\t  start: number;\n\t  startLineOffset: number;\n\t  /* undefined = end of file */\n", "  end: number | undefined;\n\t}\n\texport interface RefSubpath {\n\t  text: string;\n\t  start: RefAnchor;\n\t  end?: RefAnchor;\n\t}\n\texport function parseRefAnchor(pos: string): RefAnchor {\n\t  if (pos === \"*\") {\n\t    return {\n", "      type: \"wildcard\",\n\t    };\n\t  } else if (pos === \"^begin\") {\n\t    return {\n\t      type: \"begin\",\n\t    };\n\t  } else if (pos === \"^end\") {\n\t    return {\n\t      type: \"end\",\n\t    };\n", "  } else if (pos.startsWith(\"^\")) {\n\t    return {\n\t      type: \"block\",\n\t      name: pos.slice(1),\n\t    };\n\t  } else {\n\t    const [name, lineOffsetStr] = pos.split(\",\", 2);\n\t    return {\n\t      type: \"header\",\n\t      name,\n", "      lineOffset: parseInt(lineOffsetStr ?? \"0\"),\n\t    };\n\t  }\n\t}\n\tfunction findHeadingByGithubSlug(headings: HeadingCache[], name: string) {\n\t  const slugger = new GithubSlugger();\n\t  const index = headings.findIndex(({ heading }) => slugger.slug(heading) === name);\n\t  return {\n\t    index,\n\t    heading: headings[index],\n", "  };\n\t}\n\texport function getRefContentRange(subpath: RefSubpath, metadata: CachedMetadata): RefRange | null {\n\t  const range: RefRange = {\n\t    start: 0,\n\t    startLineOffset: 0,\n\t    end: undefined,\n\t  };\n\t  const { start, end } = subpath;\n\t  if (start.type === \"begin\") {\n", "    range.start = 0;\n\t    range.end = metadata.headings?.[0].position.start.offset;\n\t  } else if (start.type === \"end\" || start.type === \"wildcard\") {\n\t    return null;\n\t  } else if (start.type === \"block\") {\n\t    if (!metadata.blocks) return null;\n\t    const block = metadata.blocks[start.name];\n\t    if (!block) return null;\n\t    const { position } = block;\n\t    range.start = position.start.offset;\n", "    range.end = position.end.offset;\n\t  } else if (start.type === \"header\") {\n\t    if (!metadata.headings) return null;\n\t    const { index: startHeadingIndex, heading: startHeading } = findHeadingByGithubSlug(\n\t      metadata.headings,\n\t      start.name\n\t    );\n\t    if (!startHeading) return null;\n\t    range.start = startHeading.position.start.offset;\n\t    range.startLineOffset = start.lineOffset;\n", "    let endHeading: HeadingCache | undefined;\n\t    if (end && end.type === \"wildcard\") {\n\t      endHeading = metadata.headings?.[startHeadingIndex + 1];\n\t    } else {\n\t      endHeading = metadata.headings?.find(\n\t        ({ level }, index) => index > startHeadingIndex && level <= startHeading.level\n\t      );\n\t    }\n\t    range.end = endHeading?.position.start.offset;\n\t  }\n", "  if (!end) return range;\n\t  if (end.type === \"begin\") {\n\t    return null;\n\t  } else if (end.type === \"end\") {\n\t    range.end = undefined;\n\t  } else if (end.type === \"header\") {\n\t    if (!metadata.headings) return null;\n\t    const { heading } = findHeadingByGithubSlug(metadata.headings, end.name);\n\t    if (!heading) return null;\n\t    range.end = heading?.position.end.offset;\n", "  } else if (end.type === \"block\") {\n\t    const block = metadata.blocks?.[end.name];\n\t    if (!block) return null;\n\t    range.end = block?.position.end.offset;\n\t  }\n\t  return range;\n\t}\n\texport function anchorToLinkSubpath(\n\t  anchor: RefAnchor,\n\t  headings: HeadingCache[] | undefined\n", "): string | null {\n\t  if (anchor.type === \"header\") {\n\t    let name = anchor.name;\n\t    if (headings) {\n\t      const { heading } = findHeadingByGithubSlug(headings, name);\n\t      if (heading) {\n\t        name = heading.heading;\n\t      }\n\t    }\n\t    return `#${name}`;\n", "  } else if (anchor.type === \"block\") return `#^${anchor.name}`;\n\t  return \"\";\n\t}\n\texport function parseRefSubpath(str: string): RefSubpath | undefined {\n\t  if (str.length > 0) {\n\t    const [startStr, endStr] = str.split(\":#\", 2);\n\t    const start = parseRefAnchor(startStr);\n\t    let end: RefAnchor | undefined;\n\t    if (endStr) end = parseRefAnchor(endStr);\n\t    return {\n", "      text: str,\n\t      start,\n\t      end,\n\t    };\n\t  }\n\t  return undefined;\n\t}\n"]}
{"filename": "src/custom-resolver/ref-render.ts", "chunked_list": ["import {\n\t  App,\n\t  ButtonComponent,\n\t  MarkdownRenderChild,\n\t  MarkdownRenderer,\n\t  MarkdownRendererConstructorType,\n\t  OpenViewState,\n\t  TFile,\n\t  setIcon,\n\t} from \"obsidian\";\n", "import { openFile } from \"../utils\";\n\timport { MaybeNoteRef, RefRange, getRefContentRange, anchorToLinkSubpath } from \"../engine/ref\";\n\timport { dendronActivityBarName } from \"../icons\";\n\tconst MarkdownRendererConstructor = MarkdownRenderer as unknown as MarkdownRendererConstructorType;\n\tclass RefMarkdownRenderer extends MarkdownRendererConstructor {\n\t  constructor(public parent: NoteRefRenderChild, queed: boolean) {\n\t    super(parent.app, parent.previewEl, queed);\n\t  }\n\t  get file(): TFile {\n\t    return this.parent.file;\n", "  }\n\t  edit(markdown: string) {\n\t    this.parent.editContent(markdown);\n\t  }\n\t}\n\texport class NoteRefRenderChild extends MarkdownRenderChild {\n\t  previewEl: HTMLElement;\n\t  renderer: RefMarkdownRenderer;\n\t  file: TFile;\n\t  range: RefRange | null;\n", "  markdown?: string;\n\t  found = false;\n\t  constructor(\n\t    public readonly app: App,\n\t    public readonly containerEl: HTMLElement,\n\t    public readonly ref: MaybeNoteRef\n\t  ) {\n\t    super(containerEl);\n\t    if (!ref.note || !ref.note.file)\n\t      throw Error(\"NoteRefChild only accept ref with non-blank note and file\");\n", "    this.file = ref.note.file;\n\t    this.containerEl.classList.add(\"dendron-embed\", \"markdown-embed\", \"inline-embed\", \"is-loaded\");\n\t    this.containerEl.setText(\"\");\n\t    const icon = this.containerEl.createDiv(\"dendron-icon\");\n\t    setIcon(icon, dendronActivityBarName);\n\t    this.previewEl = this.containerEl.createDiv(\"markdown-embed-content\");\n\t    const buttonComponent = new ButtonComponent(this.containerEl);\n\t    buttonComponent.buttonEl.remove();\n\t    buttonComponent.buttonEl = this.containerEl.createDiv(\n\t      \"markdown-embed-link\"\n", "    ) as unknown as HTMLButtonElement;\n\t    buttonComponent.setIcon(\"lucide-link\").setTooltip(\"Open link\");\n\t    buttonComponent.buttonEl.onclick = () => {\n\t      const openState: OpenViewState = {};\n\t      if (this.ref.subpath) {\n\t        openState.eState = {\n\t          subpath: anchorToLinkSubpath(\n\t            this.ref.subpath.start,\n\t            this.app.metadataCache.getFileCache(this.file)?.headings\n\t          ),\n", "        };\n\t      }\n\t      openFile(this.app, this.ref.note?.file, openState);\n\t    };\n\t    this.renderer = new RefMarkdownRenderer(this, true);\n\t    this.addChild(this.renderer);\n\t  }\n\t  async getContent(): Promise<string> {\n\t    this.markdown = await this.app.vault.cachedRead(this.file);\n\t    if (!this.ref.subpath) {\n", "      this.found = true;\n\t      return this.markdown;\n\t    }\n\t    const metadata = this.app.metadataCache.getFileCache(this.file);\n\t    if (metadata) {\n\t      this.range = getRefContentRange(this.ref.subpath, metadata);\n\t      if (this.range) {\n\t        let currentLineIndex = 0;\n\t        while (currentLineIndex < this.range.startLineOffset) {\n\t          if (this.markdown[this.range.start] === \"\\n\") currentLineIndex++;\n", "          this.range.start++;\n\t        }\n\t        this.found = true;\n\t        return this.markdown.substring(this.range.start, this.range.end);\n\t      }\n\t    }\n\t    this.found = false;\n\t    return \"### Unable to find section \"\n\t      .concat(this.ref.subpath.text, \" in \")\n\t      .concat(this.file.basename);\n", "  }\n\t  editContent(target: string) {\n\t    if (!this.found || !this.markdown) return;\n\t    let md;\n\t    if (!this.range) {\n\t      md = target;\n\t    } else {\n\t      const before = this.markdown.substring(0, this.range.start);\n\t      md = before + target;\n\t      if (this.range.end) {\n", "        const after = this.markdown.substring(this.range.end);\n\t        md += after;\n\t      }\n\t    }\n\t    this.app.vault.modify(this.file, md);\n\t  }\n\t  async loadFile() {\n\t    const content = await this.getContent();\n\t    this.renderer.renderer.set(content);\n\t  }\n", "  onload(): void {\n\t    super.onload();\n\t    this.registerEvent(\n\t      this.app.metadataCache.on(\"changed\", async (file, data) => {\n\t        if (file === this.file) {\n\t          this.loadFile();\n\t        }\n\t      })\n\t    );\n\t  }\n", "}\n\texport class UnresolvedRefRenderChild extends MarkdownRenderChild {\n\t  constructor(app: App, containerEl: HTMLElement, target: MaybeNoteRef) {\n\t    super(containerEl);\n\t    this.containerEl.classList.add(\"dendron-embed\", \"file-embed\", \"mod-empty\", \"is-loaded\");\n\t    this.containerEl.setText(\"\");\n\t    const icon = this.containerEl.createDiv(\"dendron-icon\");\n\t    setIcon(icon, dendronActivityBarName);\n\t    const content = this.containerEl.createDiv();\n\t    const { vaultName, vault, path } = target;\n", "    if (vaultName === \"\") {\n\t      content.setText(\"Vault name are unspecified in link.\");\n\t      return;\n\t    } else if (!vault) {\n\t      content.setText(`Vault ${vaultName} are not found.`);\n\t      return;\n\t    } else if (path === \"\") {\n\t      content.setText(\"Note path are unspecified in link.\");\n\t      return;\n\t    }\n", "    content.setText(`\"${target.path}\" is not created yet. Click to create.`);\n\t    this.containerEl.onclick = () => {\n\t      vault.createNote(path).then((file) => openFile(app, file));\n\t    };\n\t  }\n\t}\n\texport function createRefRenderer(target: MaybeNoteRef, app: App, container: HTMLElement) {\n\t  if (!target.note || !target.note.file) {\n\t    return new UnresolvedRefRenderChild(app, container, target);\n\t  } else {\n", "    return new NoteRefRenderChild(app, container, target);\n\t  }\n\t}\n"]}
{"filename": "src/custom-resolver/link-render.ts", "chunked_list": ["import { App } from \"obsidian\";\n\timport { DendronWorkspace } from \"../engine/workspace\";\n\texport function renderLinkTitle(\n\t  app: App,\n\t  workspace: DendronWorkspace,\n\t  href: string,\n\t  title: string | undefined,\n\t  sourcePath: string\n\t) {\n\t  if (title) {\n", "    return title;\n\t  }\n\t  const ref = workspace.resolveRef(sourcePath, href);\n\t  if (!ref || ref.type !== \"maybe-note\" || !ref.note?.file) {\n\t    return href;\n\t  }\n\t  const fileTitle = app.metadataCache.getFileCache(ref.note.file)?.frontmatter?.[\"title\"];\n\t  return fileTitle ?? href;\n\t}\n"]}
{"filename": "src/custom-resolver/link-live.ts", "chunked_list": ["import { syntaxTree, tokenClassNodeProp } from \"@codemirror/language\";\n\timport { RangeSetBuilder } from \"@codemirror/state\";\n\timport {\n\t  Decoration,\n\t  DecorationSet,\n\t  EditorView,\n\t  PluginValue,\n\t  ViewUpdate,\n\t  WidgetType,\n\t} from \"@codemirror/view\";\n", "import { editorInfoField, App } from \"obsidian\";\n\timport { editorLivePreviewField } from \"obsidian\";\n\timport { RefTarget } from \"../engine/ref\";\n\timport { DendronWorkspace } from \"../engine/workspace\";\n\timport { renderLinkTitle } from \"./link-render\";\n\tclass LinkWidget extends WidgetType {\n\t  containerEl: HTMLSpanElement;\n\t  ref: RefTarget | null;\n\t  constructor(\n\t    public app: App,\n", "    public workspace: DendronWorkspace,\n\t    public sourcePath: string,\n\t    public href: string,\n\t    public title: string | undefined\n\t  ) {\n\t    super();\n\t  }\n\t  initDOM() {\n\t    this.containerEl = createSpan(\n\t      {\n", "        cls: \"cm-hmd-internal-link\",\n\t      },\n\t      (el) => {\n\t        el.createSpan({\n\t          cls: \"cm-underline\",\n\t        });\n\t      }\n\t    );\n\t    this.updateTitle();\n\t    this.containerEl.addEventListener(\"click\", () => {\n", "      this.app.workspace.openLinkText(this.href, this.sourcePath);\n\t    });\n\t  }\n\t  updateTitle() {\n\t    this.containerEl.children[0].setText(\n\t      renderLinkTitle(this.app, this.workspace, this.href, this.title, this.sourcePath)\n\t    );\n\t  }\n\t  toDOM(view: EditorView): HTMLElement {\n\t    if (!this.containerEl) this.initDOM();\n", "    return this.containerEl;\n\t  }\n\t}\n\tinterface LinkData {\n\t  start: number;\n\t  end: number;\n\t  href: string;\n\t  title: string | undefined;\n\t  hasAlias: boolean;\n\t  showSource: boolean;\n", "}\n\texport class LinkLivePlugin implements PluginValue {\n\t  decorations: DecorationSet = Decoration.none;\n\t  widgets: LinkWidget[] = [];\n\t  constructor(public app: App, public workspace: DendronWorkspace, public editorView: EditorView) {\n\t    this.decorations = this.buildDecorations(editorView);\n\t  }\n\t  update(update: ViewUpdate): void {\n\t    this.decorations = this.buildDecorations(update.view);\n\t  }\n", "  getLinks(view: EditorView) {\n\t    const links: LinkData[] = [];\n\t    for (const { from, to } of view.visibleRanges) {\n\t      let linkStart = -1;\n\t      let linkTitle: string | undefined = undefined;\n\t      let linkHref = \"\";\n\t      syntaxTree(view.state).iterate({\n\t        from,\n\t        to,\n\t        enter(node) {\n", "          const tokenClass = node.type.prop(tokenClassNodeProp);\n\t          if (!tokenClass) return;\n\t          const tokenClassList = tokenClass.split(\" \");\n\t          if (\n\t            tokenClassList.contains(\"formatting-link-start\") &&\n\t            !tokenClassList.contains(\"formatting-embed\")\n\t          ) {\n\t            linkStart = node.from;\n\t          } else if (linkStart >= 0) {\n\t            if (tokenClassList.contains(\"hmd-internal-link\")) {\n", "              const text = view.state.doc.sliceString(node.from, node.to);\n\t              if (tokenClassList.contains(\"link-has-alias\")) {\n\t                linkTitle = text;\n\t              } else {\n\t                linkHref = text;\n\t              }\n\t            } else if (tokenClassList.contains(\"formatting-link-end\")) {\n\t              links.push({\n\t                start: linkStart,\n\t                end: node.to,\n", "                href: linkHref,\n\t                title: linkTitle,\n\t                hasAlias: !!linkTitle,\n\t                showSource: true,\n\t              });\n\t              linkStart = -1;\n\t              linkTitle = undefined;\n\t              linkHref = \"\";\n\t            }\n\t          }\n", "        },\n\t      });\n\t    }\n\t    return links;\n\t  }\n\t  configureLinkVisibility(links: LinkData[], view: EditorView) {\n\t    const prevDecorations = view.state.facet(EditorView.decorations);\n\t    for (const decorFn of prevDecorations) {\n\t      if (typeof decorFn !== \"function\") continue;\n\t      const decor = decorFn(view);\n", "      const iter = decor.iter();\n\t      let found = false;\n\t      while (iter.value) {\n\t        if ((iter.value as any).isReplace) {\n\t          const link = links.find(({ start }) => start === iter.from);\n\t          if (link) {\n\t            found = true;\n\t            link.showSource = false;\n\t            if (link.hasAlias) {\n\t              iter.next(); // skip before pipe\n", "              iter.next(); // skip pipe\n\t              iter.next(); // skip after pipe\n\t            } else {\n\t              iter.next(); // skip text\n\t            }\n\t            iter.next();\n\t          }\n\t        }\n\t        iter.next();\n\t      }\n", "      if (found) break;\n\t    }\n\t  }\n\t  getWidget(link: LinkData, sourcePath: string) {\n\t    const lastWidgetIndex = this.widgets.findIndex(\n\t      (widget) => widget.href === link.href && widget.sourcePath === sourcePath\n\t    );\n\t    if (lastWidgetIndex >= 0) {\n\t      const widget = this.widgets[lastWidgetIndex];\n\t      widget.title = link.title;\n", "      widget.updateTitle();\n\t      this.widgets.splice(lastWidgetIndex, 1);\n\t      return widget;\n\t    }\n\t    return new LinkWidget(this.app, this.workspace, sourcePath, link.href, link.title);\n\t  }\n\t  buildDecorations(view: EditorView): DecorationSet {\n\t    if (!view.state.field(editorLivePreviewField)) {\n\t      return Decoration.none;\n\t    }\n", "    const links = this.getLinks(view);\n\t    if (links.length === 0) return Decoration.none;\n\t    this.configureLinkVisibility(links, view);\n\t    const builder = new RangeSetBuilder<Decoration>();\n\t    const currentWidgets: LinkWidget[] = [];\n\t    const sourcePath = view.state.field(editorInfoField).file?.path ?? \"\";\n\t    for (const link of links) {\n\t      if (link.showSource) continue;\n\t      const widget = this.getWidget(link, sourcePath);\n\t      currentWidgets.push(widget);\n", "      builder.add(\n\t        link.start,\n\t        link.end,\n\t        Decoration.widget({\n\t          widget,\n\t        })\n\t      );\n\t    }\n\t    this.widgets = currentWidgets;\n\t    return builder.finish();\n", "  }\n\t}\n"]}
{"filename": "src/custom-resolver/link-markdown-processor.ts", "chunked_list": ["import { App, MarkdownPostProcessor } from \"obsidian\";\n\timport { DendronWorkspace } from \"../engine/workspace\";\n\timport { renderLinkTitle } from \"./link-render\";\n\texport function createLinkMarkdownProcessor(\n\t  app: App,\n\t  workspace: DendronWorkspace\n\t): MarkdownPostProcessor {\n\t  return (el, ctx) => {\n\t    console.log();\n\t    const linksEl = el.querySelectorAll(\".internal-link\");\n", "    if (linksEl.length == 0) return;\n\t    const section = ctx.getSectionInfo(el);\n\t    const cache = app.metadataCache.getCache(ctx.sourcePath);\n\t    if (!section || !cache?.links) return;\n\t    const links = cache.links.filter(\n\t      (link) =>\n\t        link.position.start.line >= section.lineStart && link.position.end.line <= section.lineEnd\n\t    );\n\t    if (links.length !== linksEl.length) {\n\t      console.warn(\"Cannot post process link\");\n", "      return;\n\t    }\n\t    linksEl.forEach((el, index) => {\n\t      const link = links[index];\n\t      // used to check is wikilink or not\n\t      // aria-label and data-tooltip-position only appear when link is wikilink with alias\n\t      if (!link.original.startsWith(\"[[\") || !link.original.endsWith(\"]]\")) return;\n\t      let title: string | undefined, href: string;\n\t      const split = link.original.substring(2, link.original.length - 2).split(\"|\", 2);\n\t      if (split.length == 1) href = split[0];\n", "      else {\n\t        title = split[0];\n\t        href = split[1];\n\t      }\n\t      const titleText = renderLinkTitle(app, workspace, href, title, ctx.sourcePath);\n\t      el.setText(titleText);\n\t      el.setAttribute(\"href\", href);\n\t      el.setAttribute(\"data-href\", href);\n\t      el.setAttribute(\"aria-label\", href);\n\t      el.setAttribute(\"data-tooltip-position\", \"top\");\n", "    });\n\t  };\n\t}\n"]}
{"filename": "src/custom-resolver/link-hover.ts", "chunked_list": ["import { App, HoverPopover, PagePreviewPlugin, PopoverState } from \"obsidian\";\n\timport { DendronWorkspace } from \"src/engine/workspace\";\n\timport { NoteRefRenderChild, createRefRenderer } from \"./ref-render\";\n\texport function createLinkHoverHandler(\n\t  app: App,\n\t  workspace: DendronWorkspace,\n\t  originalBoundedFunction: PagePreviewPlugin[\"onLinkHover\"]\n\t): PagePreviewPlugin[\"onLinkHover\"] {\n\t  return (parent, targetEl, link, sourcePath, state) => {\n\t    const ref = workspace.resolveRef(sourcePath, link);\n", "    if (!ref || ref.type !== \"maybe-note\")\n\t      return originalBoundedFunction(parent, targetEl, link, sourcePath, state);\n\t    if (\n\t      !(\n\t        parent.hoverPopover &&\n\t        parent.hoverPopover.state !== PopoverState.Hidden &&\n\t        parent.hoverPopover.targetEl === targetEl\n\t      )\n\t    ) {\n\t      const popOver = new HoverPopover(parent, targetEl);\n", "      setTimeout(async () => {\n\t        if (popOver.state === PopoverState.Hidden) return;\n\t        const container = popOver.hoverEl.createDiv();\n\t        const component = createRefRenderer(ref, app, container);\n\t        popOver.addChild(component);\n\t        if (component instanceof NoteRefRenderChild) await component.loadFile();\n\t        if (popOver.state === PopoverState.Shown) popOver.position();\n\t      }, 100);\n\t    }\n\t  };\n", "}\n"]}
{"filename": "src/custom-resolver/link-ref-clickbale.ts", "chunked_list": ["import { EditorView, PluginValue } from \"@codemirror/view\";\n\timport { Editor, editorInfoField } from \"obsidian\";\n\ttype GetClickableTokenType = Required<Editor>[\"getClickableTokenAt\"];\n\texport class LinkRefClickbale implements PluginValue {\n\t  static createClickableTokenAtWrapper(original: GetClickableTokenType): GetClickableTokenType {\n\t    return function (this: Editor, ...args) {\n\t      const result: ReturnType<GetClickableTokenType> = original.call(this, ...args);\n\t      if (result && result.type === \"internal-link\") {\n\t        const raw = this.getRange(result.start, result.end);\n\t        const split = raw.split(\"|\", 2);\n", "        if (split.length === 2) {\n\t          result.text = split[1];\n\t        }\n\t      }\n\t      return result;\n\t    };\n\t  }\n\t  getClickableTokenAtOrig: Editor[\"getClickableTokenAt\"];\n\t  constructor(private view: EditorView) {\n\t    const editor = view.state.field(editorInfoField).editor;\n", "    if (editor && editor.getClickableTokenAt) {\n\t      this.getClickableTokenAtOrig = editor.getClickableTokenAt;\n\t      editor.getClickableTokenAt = LinkRefClickbale.createClickableTokenAtWrapper(\n\t        this.getClickableTokenAtOrig\n\t      );\n\t    }\n\t  }\n\t  destroy(): void {\n\t    if (this.getClickableTokenAtOrig) {\n\t      const editor = this.view.state.field(editorInfoField).editor;\n", "      if (editor) {\n\t        editor.getClickableTokenAt = this.getClickableTokenAtOrig;\n\t      }\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/custom-resolver/index.ts", "chunked_list": ["import { Component, MarkdownPreviewRenderer, PagePreviewPlugin, Plugin, Workspace } from \"obsidian\";\n\timport { DendronWorkspace } from \"../engine/workspace\";\n\timport { createLinkHoverHandler } from \"./link-hover\";\n\timport { ViewPlugin } from \"@codemirror/view\";\n\timport { RefLivePlugin } from \"./ref-live\";\n\timport { createRefMarkdownProcessor } from \"./ref-markdown-processor\";\n\timport { createLinkOpenHandler } from \"./link-open\";\n\timport { LinkLivePlugin } from \"./link-live\";\n\timport { createLinkMarkdownProcessor } from \"./link-markdown-processor\";\n\timport { LinkRefClickbale } from \"./link-ref-clickbale\";\n", "export class CustomResolver extends Component {\n\t  pagePreviewPlugin?: PagePreviewPlugin;\n\t  originalLinkHover: PagePreviewPlugin[\"onLinkHover\"];\n\t  originalOpenLinkText: Workspace[\"openLinkText\"];\n\t  refPostProcessor = createRefMarkdownProcessor(this.plugin.app, this.workspace);\n\t  linkPostProcessor = createLinkMarkdownProcessor(this.plugin.app, this.workspace);\n\t  refEditorExtenstion = ViewPlugin.define((v) => {\n\t    return new RefLivePlugin(this.plugin.app, this.workspace);\n\t  });\n\t  linkEditorExtenstion = ViewPlugin.define(\n", "    (view) => {\n\t      return new LinkLivePlugin(this.plugin.app, this.workspace, view);\n\t    },\n\t    {\n\t      decorations: (value) => value.decorations,\n\t    }\n\t  );\n\t  linkRefClickbaleExtension = ViewPlugin.define((v) => {\n\t    return new LinkRefClickbale(v);\n\t  });\n", "  constructor(public plugin: Plugin, public workspace: DendronWorkspace) {\n\t    super();\n\t  }\n\t  onload(): void {\n\t    this.plugin.app.workspace.onLayoutReady(() => {\n\t      this.plugin.app.workspace.registerEditorExtension(this.refEditorExtenstion);\n\t      this.plugin.app.workspace.registerEditorExtension(this.linkEditorExtenstion);\n\t      this.plugin.app.workspace.registerEditorExtension(this.linkRefClickbaleExtension);\n\t      this.pagePreviewPlugin = this.plugin.app.internalPlugins.getEnabledPluginById(\"page-preview\");\n\t      if (!this.pagePreviewPlugin) return;\n", "      this.originalLinkHover = this.pagePreviewPlugin.onLinkHover;\n\t      this.pagePreviewPlugin.onLinkHover = createLinkHoverHandler(\n\t        this.plugin.app,\n\t        this.workspace,\n\t        this.originalLinkHover.bind(this.pagePreviewPlugin)\n\t      );\n\t    });\n\t    MarkdownPreviewRenderer.registerPostProcessor(this.refPostProcessor);\n\t    MarkdownPreviewRenderer.registerPostProcessor(this.linkPostProcessor);\n\t    this.originalOpenLinkText = this.plugin.app.workspace.openLinkText;\n", "    this.plugin.app.workspace.openLinkText = createLinkOpenHandler(\n\t      this.workspace,\n\t      this.originalOpenLinkText.bind(this.plugin.app.workspace)\n\t    );\n\t  }\n\t  onunload(): void {\n\t    this.plugin.app.workspace.openLinkText = this.originalOpenLinkText;\n\t    MarkdownPreviewRenderer.unregisterPostProcessor(this.linkPostProcessor);\n\t    MarkdownPreviewRenderer.unregisterPostProcessor(this.refPostProcessor);\n\t    this.plugin.app.workspace.unregisterEditorExtension(this.linkRefClickbaleExtension);\n", "    this.plugin.app.workspace.unregisterEditorExtension(this.linkEditorExtenstion);\n\t    this.plugin.app.workspace.unregisterEditorExtension(this.refEditorExtenstion);\n\t    if (!this.pagePreviewPlugin) return;\n\t    this.pagePreviewPlugin.onLinkHover = this.originalLinkHover;\n\t  }\n\t}\n"]}
{"filename": "src/custom-resolver/link-open.ts", "chunked_list": ["import { Notice, Workspace } from \"obsidian\";\n\timport { anchorToLinkSubpath } from \"src/engine/ref\";\n\timport { DendronWorkspace } from \"src/engine/workspace\";\n\texport function createLinkOpenHandler(\n\t  workspace: DendronWorkspace,\n\t  originalBoundedFunction: Workspace[\"openLinkText\"]\n\t): Workspace[\"openLinkText\"] {\n\t  return async (linktext, sourcePath, newLeaf, openViewState) => {\n\t    const target = workspace.resolveRef(sourcePath, linktext);\n\t    if (!target || target.type !== \"maybe-note\")\n", "      return originalBoundedFunction(linktext, sourcePath, newLeaf, openViewState);\n\t    let file = target.note?.file;\n\t    if (!file) {\n\t      if (target.vaultName === \"\") {\n\t        new Notice(\"Vault name is unspecified in link.\");\n\t        return;\n\t      } else if (!target.vault) {\n\t        new Notice(`Vault ${target.vaultName} is not found.`);\n\t        return;\n\t      } else if (target.path === \"\") {\n", "        new Notice(\"Note path is unspecified in link.\");\n\t        return;\n\t      }\n\t      file = await target.vault.createNote(target.path);\n\t    }\n\t    let newLink = file.path;\n\t    if (target.subpath)\n\t      newLink += anchorToLinkSubpath(\n\t        target.subpath.start,\n\t        app.metadataCache.getFileCache(file)?.headings\n", "      );\n\t    return originalBoundedFunction(newLink, \"\", newLeaf, openViewState);\n\t  };\n\t}\n"]}
{"filename": "src/custom-resolver/ref-live.ts", "chunked_list": ["import { EditorView, PluginValue, ViewUpdate } from \"@codemirror/view\";\n\timport { App, Component, editorLivePreviewField } from \"obsidian\";\n\timport { NoteRefRenderChild, createRefRenderer } from \"./ref-render\";\n\timport { DendronWorkspace } from \"../engine/workspace\";\n\tinterface InternalEmbedWidget {\n\t  end: number;\n\t  href: string;\n\t  sourcePath: string;\n\t  start: string;\n\t  title: string;\n", "  children: Component[];\n\t  containerEl: HTMLElement;\n\t  hacked?: boolean;\n\t  initDOM(): HTMLElement;\n\t  addChild(c: Component): void;\n\t  applyTitle(container: HTMLElement, title: string): void;\n\t}\n\texport class RefLivePlugin implements PluginValue {\n\t  constructor(public app: App, public workspace: DendronWorkspace) {}\n\t  update(update: ViewUpdate) {\n", "    if (!update.state.field(editorLivePreviewField)) {\n\t      return;\n\t    }\n\t    update.view.state.facet(EditorView.decorations).forEach((d) => {\n\t      if (typeof d !== \"function\") {\n\t        const iter = d.iter();\n\t        while (iter.value) {\n\t          const widget = iter.value.spec.widget;\n\t          if (widget && widget.href && widget.sourcePath && widget.title) {\n\t            const internalWidget = widget as InternalEmbedWidget;\n", "            this.hack(internalWidget);\n\t          }\n\t          iter.next();\n\t        }\n\t      }\n\t    });\n\t  }\n\t  hack(widget: InternalEmbedWidget) {\n\t    if (widget.hacked) {\n\t      return;\n", "    }\n\t    widget.hacked = true;\n\t    const target = this.workspace.resolveRef(widget.sourcePath, widget.href);\n\t    if (!target || target.type !== \"maybe-note\") return;\n\t    const loadComponent = (widget: InternalEmbedWidget) => {\n\t      const renderer = createRefRenderer(target, this.app, widget.containerEl);\n\t      if (renderer instanceof NoteRefRenderChild) renderer.loadFile();\n\t      widget.addChild(renderer);\n\t    };\n\t    widget.initDOM = function (this: InternalEmbedWidget) {\n", "      this.containerEl = createDiv(\"internal-embed\");\n\t      loadComponent(this);\n\t      return this.containerEl;\n\t    };\n\t    widget.applyTitle = function (\n\t      this: InternalEmbedWidget,\n\t      container: HTMLElement,\n\t      title: string\n\t    ) {\n\t      this.title = title;\n", "    };\n\t    if (widget.containerEl) {\n\t      console.log(\"Workaround\");\n\t      widget.children[0].unload();\n\t      widget.children.pop();\n\t      loadComponent(widget);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/custom-resolver/ref-markdown-processor.ts", "chunked_list": ["import { DendronWorkspace } from \"../engine/workspace\";\n\timport { NoteRefRenderChild, createRefRenderer } from \"./ref-render\";\n\timport { App, MarkdownPostProcessor } from \"obsidian\";\n\texport function createRefMarkdownProcessor(\n\t  app: App,\n\t  workspace: DendronWorkspace\n\t): MarkdownPostProcessor {\n\t  return (element, context) => {\n\t    const embeddedItems = element.querySelectorAll(\".internal-embed\");\n\t    const promises: Promise<void>[] = [];\n", "    embeddedItems.forEach((el) => {\n\t      const link = el.getAttribute(\"src\");\n\t      if (!link) return;\n\t      const target = workspace.resolveRef(context.sourcePath, link);\n\t      if (!target || target.type !== \"maybe-note\") return;\n\t      const renderer = createRefRenderer(target, app, el as HTMLElement);\n\t      if (renderer instanceof NoteRefRenderChild) promises.push(renderer.loadFile());\n\t      context.addChild(renderer);\n\t    });\n\t    return Promise.all(promises);\n", "  };\n\t}\n"]}
