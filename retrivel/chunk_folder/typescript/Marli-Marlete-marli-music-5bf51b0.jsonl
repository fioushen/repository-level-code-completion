{"filename": "vitest.config.ts", "chunked_list": ["import path from 'path';\n\timport { defineConfig } from 'vitest/config';\n\texport default defineConfig({\n\t  test: {\n\t    coverage: {\n\t      provider: 'istanbul',\n\t      reporter: ['text', 'json', 'html'],\n\t    },\n\t  },\n\t  resolve: {\n", "    alias: {\n\t      '@': path.resolve(__dirname, './src'),\n\t    },\n\t  },\n\t});\n"]}
{"filename": "test/index.spec.ts", "chunked_list": ["import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';\n\timport { botStartup } from '../src/bot';\n\timport { initConfigs } from '../src/config';\n\timport { startServer } from '../src/http';\n\tdescribe('src/index.ts', () => {\n\t  beforeAll(() => {\n\t    vi.mock('../src/http/index');\n\t    vi.mock('../src/config/index');\n\t    vi.mock('../src/bot/index');\n\t  });\n", "  afterAll(() => {\n\t    vi.clearAllMocks();\n\t    it('should have called', () => {\n\t      expect(startServer()).toBeCalled();\n\t    });\n\t  });\n\t  it('should run correctly all functions', () => {\n\t    initConfigs();\n\t    startServer();\n\t    botStartup();\n", "    expect(initConfigs).toHaveBeenCalled();\n\t    expect(startServer).toHaveBeenCalled();\n\t    expect(startServer).toHaveBeenCalled();\n\t  });\n\t});\n"]}
{"filename": "test/config/winston.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\timport { fileLogger, logger } from '../../src/config/winston';\n\tdescribe('src/config/winston.ts', () => {\n\t  vi.useFakeTimers();\n\t  afterAll(() => {\n\t    vi.useRealTimers();\n\t    vi.clearAllMocks();\n\t  });\n\t  it('should run logger log correctly', () => {\n\t    const level = 'debug';\n", "    const message = 'testing logger';\n\t    vi.spyOn(logger, 'log');\n\t    logger.log(level, message);\n\t    expect(logger.log).toHaveBeenCalledOnce();\n\t    expect(logger.log).toBeCalledWith(level, message);\n\t  });\n\t  it('should run fileLogger log correctly', () => {\n\t    const level = 'error';\n\t    const message = 'Some Error has Happened';\n\t    const error = new Error(message);\n", "    vi.spyOn(fileLogger, 'log');\n\t    const systemDate = new Date(2023, 3, 23, 1);\n\t    vi.setSystemTime(systemDate);\n\t    fileLogger.log(level, message, error);\n\t    expect(fileLogger.log).toHaveBeenCalledOnce();\n\t    expect(fileLogger.log).toBeCalledWith(level, message, error);\n\t  });\n\t});\n"]}
{"filename": "test/config/index.spec.ts", "chunked_list": ["import * as dotenv from 'dotenv';\n\timport { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';\n\timport { initConfigs } from '../../src/config/index';\n\timport { initSentry } from '../../src/config/sentry';\n\tdescribe('src/config/index.ts', () => {\n\t  beforeAll(() => {\n\t    vi.mock('dotenv');\n\t    vi.mock('../../src/config/sentry');\n\t  });\n\t  afterAll(() => {\n", "    vi.clearAllMocks();\n\t  });\n\t  it('should run initConfigs correctly', () => {\n\t    initConfigs();\n\t    expect(dotenv.config).toHaveBeenCalledOnce();\n\t    expect(initSentry).toHaveBeenCalledOnce();\n\t  });\n\t});\n"]}
{"filename": "test/config/sentry.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\timport Sentry, { Transaction } from '@sentry/node';\n\timport { initSentry, sentryCapture } from '../../src/config/sentry';\n\tdescribe('src/config/sentry.ts', () => {\n\t  afterAll(() => {\n\t    vi.clearAllMocks();\n\t  });\n\t  it('should run initSentry', () => {\n\t    vi.spyOn(Sentry, 'init').mockResolvedValueOnce();\n\t    const sentryDns = 'http://sentry-test.com?id=9213812';\n", "    process.env.SENTRY_DNS = sentryDns;\n\t    initSentry();\n\t    expect(Sentry.init).toHaveBeenCalledOnce();\n\t    expect(Sentry.init).toHaveBeenCalledWith({\n\t      dsn: sentryDns,\n\t      environment: 'test',\n\t      tracesSampleRate: 1.0,\n\t    });\n\t  });\n\t  it('should run SentryCapture correctly', () => {\n", "    const name = 'TEST_ERROR';\n\t    const testError = new Error('Test Exception has happened');\n\t    const startTransactionSpy = vi\n\t      .spyOn(Sentry, 'startTransaction')\n\t      .mockImplementationOnce(() => {\n\t        return {\n\t          finish(endTimestamp) {\n\t            return endTimestamp;\n\t          },\n\t        } as Transaction;\n", "      });\n\t    vi.spyOn(Sentry, 'captureException').mockImplementation(() => '');\n\t    sentryCapture(name, testError);\n\t    expect(startTransactionSpy).toHaveBeenCalledOnce();\n\t    expect(Sentry.captureException).toHaveBeenCalledOnce();\n\t    expect(Sentry.captureException).toHaveBeenLastCalledWith(testError);\n\t  });\n\t});\n"]}
{"filename": "test/sources/source-stream.spec.ts", "chunked_list": ["import { Readable } from 'stream';\n\timport { afterAll, describe, expect, it, vi } from 'vitest';\n\timport {\n\t  ResultAudioSearch,\n\t  SourceStream,\n\t  StreamInfo,\n\t} from '../../src/sources/source-stream';\n\tdescribe('src/sources/source-stream.ts', () => {\n\t  const mockURLStream = 'https://some.stream.io?stream=03310';\n\t  const mockResultAudio: ResultAudioSearch = {\n", "    duration: '1:40',\n\t    id: '1',\n\t    title: 'some-stream-audio',\n\t    url: mockURLStream,\n\t  };\n\t  const mockStreamInfo: StreamInfo = {\n\t    title: 'some-stream',\n\t    url: mockURLStream,\n\t  };\n\t  class TestSourceStream implements SourceStream {\n", "    getStream(_url: string): Readable | Promise<Readable> {\n\t      console.log(_url);\n\t      const readable = new Readable({\n\t        encoding: 'utf-8',\n\t      });\n\t      return readable;\n\t    }\n\t    getStreamInfo(_input: string): Promise<StreamInfo> {\n\t      console.log(_input);\n\t      return Promise.resolve(mockStreamInfo);\n", "    }\n\t    search(_input: string): ResultAudioSearch[] | Promise<ResultAudioSearch[]> {\n\t      console.log(_input);\n\t      return [mockResultAudio];\n\t    }\n\t    getStreamFromUrl(_url: string): Promise<StreamInfo> {\n\t      console.log(_url);\n\t      return Promise.resolve(mockStreamInfo);\n\t    }\n\t    validate(_input: string): Promise<boolean> {\n", "      console.log(_input);\n\t      return Promise.resolve(true);\n\t    }\n\t  }\n\t  afterAll(() => {\n\t    vi.clearAllMocks();\n\t  });\n\t  it('should have correct instance of SourceStream', () => {\n\t    const testStream = new TestSourceStream();\n\t    expect(testStream.getStream).toBeDefined();\n", "    expect(testStream.search).toBeDefined();\n\t    expect(testStream.getStreamInfo).toBeDefined();\n\t  });\n\t  it('should run search correctly', () => {\n\t    vi.spyOn(TestSourceStream.prototype, 'search');\n\t    const testStream = new TestSourceStream();\n\t    const result = testStream.search('test');\n\t    expect(TestSourceStream.prototype.search).toHaveBeenCalledOnce();\n\t    expect(TestSourceStream.prototype.search).toBeCalledWith('test');\n\t    expect(result).toEqual([mockResultAudio]);\n", "  });\n\t  it('should run getStreamInfo correctly', async () => {\n\t    vi.spyOn(TestSourceStream.prototype, 'getStreamInfo');\n\t    const testStream = new TestSourceStream();\n\t    const result = await testStream.getStreamInfo('test');\n\t    expect(TestSourceStream.prototype.getStreamInfo).toHaveBeenCalledOnce();\n\t    expect(TestSourceStream.prototype.getStreamInfo).toBeCalledWith('test');\n\t    expect(result).toEqual(mockStreamInfo);\n\t  });\n\t  it('should run getStream correctly', async () => {\n", "    vi.spyOn(TestSourceStream.prototype, 'getStream');\n\t    const readableStream = new Readable({ encoding: 'utf-8' });\n\t    const testStream = new TestSourceStream();\n\t    const result = await testStream.getStream('test');\n\t    expect(TestSourceStream.prototype.getStream).toHaveBeenCalledOnce();\n\t    expect(TestSourceStream.prototype.getStream).toBeCalledWith('test');\n\t    expect(result).toEqual(readableStream);\n\t  });\n\t});\n"]}
{"filename": "test/sources/ytdl-source/ytdl-mocks.ts", "chunked_list": ["import { Readable } from 'stream';\n\timport { vi } from 'vitest';\n\timport yts from 'yt-search';\n\texport const mockVideoUrl = 'https://www.youtube.com/watch?v=qGl7b1EPwfA';\n\texport const mockVideoResult: yts.VideoSearchResult = {\n\t  duration: {\n\t    seconds: 40,\n\t    timestamp: '',\n\t    toString: () => '40',\n\t  },\n", "  seconds: 40,\n\t  title: 'video test 1',\n\t  url: 'www.youtube.com/watch?=023912',\n\t  videoId: 'qGl7b1EPwfA',\n\t} as yts.VideoSearchResult;\n\texport const mockYtVideoInfo = {\n\t  player_response: {\n\t    videoDetails: {\n\t      title: mockVideoResult.title,\n\t      videoId: 'qGl7b1EPwfA',\n", "    },\n\t  },\n\t  videoDetails: {\n\t    video_url: mockVideoUrl,\n\t  },\n\t};\n\texport const mockSearchResult: Partial<yts.SearchResult> = {\n\t  videos: [mockVideoResult],\n\t};\n\texport function setupYtdlStub() {\n", "  vi.mock('ytdl-core', async () => {\n\t    const original = await vi.importActual<typeof import('ytdl-core')>(\n\t      'ytdl-core'\n\t    );\n\t    const ytdlMock = {\n\t      ...original,\n\t      default: (url: string) => {\n\t        return url === mockVideoUrl ? new Readable() : null;\n\t      },\n\t      getInfo: () => mockYtVideoInfo,\n", "      getURLVideoID: () => mockVideoUrl,\n\t      validateURL: (url: string) => {\n\t        console.log('NO MOCK VALIDATE URL');\n\t        return url.includes('www.youtube.com/watch?v=');\n\t      },\n\t    };\n\t    return ytdlMock;\n\t  });\n\t  vi.mock('yt-search', async () => {\n\t    return {\n", "      default: (query: string) => {\n\t        if (query === 'test') return Promise.resolve(mockSearchResult);\n\t        return { videos: [] };\n\t      },\n\t    };\n\t  });\n\t}\n"]}
{"filename": "test/sources/ytdl-source/ytdl-source.spec.ts", "chunked_list": ["import { Readable } from 'stream';\n\timport { afterAll, describe, expect, it, vi } from 'vitest';\n\timport { ERRORS } from '../../../src/shared/errors';\n\timport { mockVideoUrl, setupYtdlStub } from './ytdl-mocks';\n\tsetupYtdlStub();\n\timport { YtdlSourceStream } from '../../../src/sources/ytdl-source/ytdl-source';\n\tdescribe('src/sources/ytdl-source/ytdl-source-stream.ts', () => {\n\t  afterAll(() => {\n\t    vi.resetAllMocks();\n\t    vi.clearAllMocks();\n", "    vi.restoreAllMocks();\n\t  });\n\t  describe('getStream()', () => {\n\t    it('should run getStream correctly', async () => {\n\t      const ytdlSource = new YtdlSourceStream();\n\t      const stream = await ytdlSource.getStream(mockVideoUrl);\n\t      expect(stream).toBeDefined();\n\t      expect(stream).toEqual(new Readable());\n\t    });\n\t    it('shoud return RESULT_NOT_FOUND on invalid yt url passed', async () => {\n", "      const ytdlSource = new YtdlSourceStream();\n\t      await ytdlSource.getStream('invalid_url').catch((e) => {\n\t        expect(e).toEqual(ERRORS.RESULT_NOT_FOUND);\n\t      });\n\t    });\n\t  });\n\t  describe('getStreamFromUrl()', () => {\n\t    it('should return youtube video results', async () => {\n\t      const ytdlSource = new YtdlSourceStream();\n\t      const results = await ytdlSource.search('test');\n", "      expect(results).toBeDefined();\n\t    });\n\t    it('should return RESLT_NOT_FOUND when no results were available', async () => {\n\t      const ytdlSource = new YtdlSourceStream();\n\t      ytdlSource.search('___').catch((reason) => {\n\t        expect(reason).toEqual(ERRORS.RESULT_NOT_FOUND);\n\t      });\n\t    });\n\t  });\n\t  describe('search()', () => {\n", "    it('should run getStreamFromUrl() ', async () => {\n\t      const source = new YtdlSourceStream();\n\t      const results = await source.getStreamFromUrl(mockVideoUrl);\n\t      expect(results).toBeDefined();\n\t    });\n\t    it('should return undefined due to invalid url', async () => {\n\t      const source = new YtdlSourceStream();\n\t      await source\n\t        .getStreamFromUrl('www.invalid-yt-url')\n\t        .catch((reason) => expect(reason).toEqual(ERRORS.RESULT_NOT_FOUND));\n", "    });\n\t  });\n\t});\n"]}
{"filename": "test/sources/play-dl-source/play-dl-source.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\timport { PlayDlSourceStream } from '../../../src/sources/play-dl-source/play-dl-source';\n\tdescribe('src/sources/play-dl-source/play-dl-source-stream.ts', () => {\n\t  afterAll(() => {\n\t    vi.clearAllMocks();\n\t  });\n\t  describe('getStream()', () => {\n\t    it('should run getStream correctly', async () => {\n\t      const playDLSource = new PlayDlSourceStream();\n\t      expect(playDLSource).toBeDefined();\n", "    });\n\t  });\n\t});\n"]}
{"filename": "test/helpers/helpers.spec.ts", "chunked_list": ["import { describe, expect, it } from 'vitest';\n\timport { shuffleArray } from '../../src/helpers/helpers';\n\tdescribe('shuffleArray', () => {\n\t  it('should return an array with different order', () => {\n\t    expect(shuffleArray<number>([1, 2, 3, 4])).not.toEqual([1, 2, 3, 4]);\n\t  });\n\t  it('should return an empty array if it was passed in param', () => {\n\t    expect(shuffleArray([])).toEqual([]);\n\t  });\n\t});\n"]}
{"filename": "test/bot/index.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\timport { botStartup } from '../../src/bot/index';\n\timport { MarliMusic } from '../../src/bot/marli-music';\n\tdescribe('src/bot/index.ts', () => {\n\t  afterAll(() => {\n\t    vi.clearAllMocks();\n\t  });\n\t  describe('botStartup', () => {\n\t    it('should return a MarliMusic instance', () => {\n\t      vi.spyOn(MarliMusic.prototype, 'login').mockReturnValueOnce(\n", "        Promise.resolve('')\n\t      );\n\t      const marliMusic = botStartup();\n\t      expect(marliMusic).toBeDefined();\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/bot/marli-music.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\timport { MarliMusic } from '../../src/bot/marli-music';\n\timport { LocalQueue } from '../../src/queue/queue';\n\timport { YtdlSourceStream } from '../../src/sources/ytdl-source/ytdl-source';\n\tdescribe('src/bot/marli-music.ts', () => {\n\t  afterAll(() => {\n\t    vi.clearAllMocks();\n\t  });\n\t  describe('healthCheck', () => {\n\t    it('should return healthCheck', () => {\n", "      vi.spyOn(MarliMusic.prototype, 'login').mockImplementation(() =>\n\t        Promise.resolve('')\n\t      );\n\t      const marli = new MarliMusic(\n\t        {\n\t          prefix: '!',\n\t          token: '123',\n\t        },\n\t        new YtdlSourceStream(),\n\t        new LocalQueue(),\n", "        { intents: [] }\n\t      );\n\t      const healthCheckSpy = vi.spyOn(marli, 'healthCheck');\n\t      expect(healthCheckSpy).toBeDefined();\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/bot/default-messages.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\timport { BOT_MESSAGES } from '../../src/bot/containts/default-messages';\n\tdescribe('src/bot/default-messages.ts', () => {\n\t  afterAll(() => {\n\t    vi.clearAllMocks();\n\t  });\n\t  describe('BOT_MESSAGES', () => {\n\t    it('should return BOT_MESSAGES', () => {\n\t      const msg = BOT_MESSAGES.INVALID_COMMAND;\n\t      expect(msg).toBeDefined();\n", "    });\n\t  });\n\t});\n"]}
{"filename": "test/shared/errors.spec.ts", "chunked_list": ["import { describe, expect, it } from 'vitest';\n\timport { ERRORS } from '../../src/shared/errors';\n\tdescribe('src/shared/errors.ts', () => {\n\t  it('should contain correct errors', () => {\n\t    const errors = Object.values(ERRORS).map((msg) => new Error(msg));\n\t    errors.forEach((error) => expect(ERRORS[error.message]).toBeDefined);\n\t  });\n\t});\n"]}
{"filename": "test/http/index.spec.ts", "chunked_list": ["import supertest from 'supertest';\n\timport {\n\t  afterAll,\n\t  afterEach,\n\t  describe,\n\t  expect,\n\t  it,\n\t  SpyInstance,\n\t  vi,\n\t} from 'vitest';\n", "import { logger } from '../../src/config/winston';\n\timport { appServer, httpServer, startServer } from '../../src/http/index';\n\tdescribe('src/http/index.ts', () => {\n\t  afterEach(() => {\n\t    httpServer.close();\n\t  });\n\t  afterAll(() => {\n\t    vi.resetAllMocks();\n\t  });\n\t  it('should start express server', async () => {\n", "    const spyUse = vi.spyOn(appServer, 'use');\n\t    const spyListen: SpyInstance = vi.spyOn(appServer, 'listen');\n\t    startServer();\n\t    expect(spyListen).toHaveBeenCalledOnce();\n\t    expect(spyUse).toHaveBeenCalledOnce();\n\t  });\n\t  it('should log `server listening`', () => {\n\t    const logSpy = vi.spyOn(logger, 'log');\n\t    startServer();\n\t    setTimeout(() => {\n", "      expect(logSpy).toHaveBeenCalledOnce();\n\t    }, 500);\n\t  });\n\t  it('should reach route [GET] / ', async () => {\n\t    startServer();\n\t    const response = await supertest(appServer).get('/');\n\t    expect(response.status).toBe(200);\n\t  });\n\t});\n"]}
{"filename": "test/http/routes/index.spec.ts", "chunked_list": ["import { afterAll, describe, expect, it, vi } from 'vitest';\n\timport { mainRouter } from '../../../src/http/routes/index';\n\tdescribe('src/http/routes/index.ts', () => {\n\t  afterAll(() => {\n\t    vi.clearAllMocks();\n\t  });\n\t  describe('mainRouter', () => {\n\t    it('should return mainRouter', () => {\n\t      const mainRouterSpy = vi.spyOn(mainRouter, 'get');\n\t      expect(mainRouterSpy).toBeDefined();\n", "    });\n\t  });\n\t});\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { botStartup } from './bot';\n\timport { initConfigs } from './config';\n\timport { startServer } from './http';\n\tinitConfigs();\n\tbotStartup();\n\tstartServer();\n"]}
{"filename": "src/config/winston.ts", "chunked_list": ["import dayjs from 'dayjs';\n\timport { join } from 'path';\n\timport { cwd } from 'process';\n\timport winston, { format, transports } from 'winston';\n\tclass Logger {\n\t  private logger: winston.Logger;\n\t  constructor(private options: { saveToFile: boolean }) {\n\t    this.logger = this.makeLogger();\n\t  }\n\t  public log(level: string, message: string, error?: Error) {\n", "    return this.logger.log(level, message, error);\n\t  }\n\t  public debug(level: string, ...args: unknown[]) {\n\t    return args.map((arg) => this.logger.log(level, arg));\n\t  }\n\t  public error(message: string, error?: Error) {\n\t    return this.logger.error(message, error);\n\t  }\n\t  private makeLogger() {\n\t    return winston.createLogger({\n", "      format: format.combine(\n\t        format.json(),\n\t        format.timestamp(),\n\t        format.printf(({ timestamp, level, message }) => {\n\t          return `[${timestamp}] ${level}: ${message}`;\n\t        })\n\t      ),\n\t      level: 'debug',\n\t      transports: this.options.saveToFile\n\t        ? [\n", "            new winston.transports.Console(),\n\t            new transports.File({\n\t              dirname: this.makeFolderName(),\n\t              filename: this.makeFileName(),\n\t            }),\n\t          ]\n\t        : [new winston.transports.Console()],\n\t    });\n\t  }\n\t  private makeFolderName() {\n", "    return join(cwd(), `logs/winston/${dayjs().format('MM-YYYY')}`);\n\t  }\n\t  private makeFileName() {\n\t    return `${dayjs().format('DD-MM-YYYY')}.log`;\n\t  }\n\t}\n\texport const logger = new Logger({ saveToFile: false });\n\texport const fileLogger = new Logger({ saveToFile: true });\n"]}
{"filename": "src/config/sentry.ts", "chunked_list": ["import * as Sentry from '@sentry/node';\n\texport function initSentry() {\n\t  Sentry.init({\n\t    dsn: process.env.SENTRY_DNS,\n\t    environment: process.env.NODE_ENV || 'development',\n\t    tracesSampleRate: 1.0,\n\t  });\n\t}\n\texport function sentryCapture(name: string, error: Error) {\n\t  const transaction = Sentry.startTransaction({\n", "    name,\n\t    op: 'transaction',\n\t  });\n\t  Sentry.captureException(error);\n\t  transaction.finish();\n\t}\n"]}
{"filename": "src/config/index.ts", "chunked_list": ["import * as dotenv from 'dotenv';\n\timport { initSentry } from './sentry';\n\texport function initConfigs() {\n\t  dotenv.config();\n\t  initSentry();\n\t}\n"]}
{"filename": "src/sources/source-stream.ts", "chunked_list": ["import { Readable } from 'node:stream';\n\texport interface ResultAudioSearch {\n\t  title: string;\n\t  duration: string;\n\t  id: string;\n\t  url: string;\n\t}\n\texport interface StreamInfo {\n\t  title: string;\n\t  url?: string;\n", "  artist?: string;\n\t}\n\texport interface SerachOptionsParams {\n\t  limit?: number;\n\t}\n\texport interface SourceStream {\n\t  getStream(url: string): Promise<Readable>;\n\t  search(\n\t    input: string,\n\t    options?: SerachOptionsParams\n", "  ): Promise<ResultAudioSearch[]>;\n\t  getStreamFromUrl(url: string): Promise<StreamInfo[]>;\n\t  validate(input: string): Promise<boolean>;\n\t}\n"]}
{"filename": "src/sources/ytdl-source/ytdl-source.ts", "chunked_list": ["import { Readable } from 'node:stream';\n\timport yts from 'yt-search';\n\timport ytdl, { getInfo, getURLVideoID, validateURL } from 'ytdl-core';\n\timport { ERRORS } from '@/shared/errors';\n\timport { ResultAudioSearch, SourceStream } from '../source-stream';\n\texport class YtdlSourceStream implements SourceStream {\n\t  async getStream(url: string): Promise<Readable> {\n\t    const stream = ytdl(url, {\n\t      dlChunkSize: 0,\n\t      filter: 'audioonly',\n", "      highWaterMark: 1 << 25,\n\t      quality: 'lowestaudio',\n\t    });\n\t    if (!stream) return Promise.reject(ERRORS.RESULT_NOT_FOUND);\n\t    return Promise.resolve(stream);\n\t  }\n\t  async search(input: string): Promise<ResultAudioSearch[]> {\n\t    const result = await yts(input);\n\t    if (result.videos.length < 1)\n\t      return Promise.reject(ERRORS.RESULT_NOT_FOUND);\n", "    const videos = result.videos.slice(0, 10);\n\t    return videos.map((video) => ({\n\t      duration: video.duration.toString(),\n\t      id: video.videoId,\n\t      title: video.title,\n\t      url: video.url,\n\t    }));\n\t  }\n\t  async getStreamFromUrl(input: string) {\n\t    if (input.startsWith('https') && validateURL(input)) {\n", "      const videoId = getURLVideoID(input);\n\t      const info = await getInfo(videoId);\n\t      return [\n\t        {\n\t          title: info.player_response.videoDetails.title,\n\t          url: info.videoDetails.video_url,\n\t        },\n\t      ];\n\t    }\n\t    return Promise.reject(ERRORS.RESULT_NOT_FOUND);\n", "  }\n\t  async validate(url: string): Promise<boolean> {\n\t    // implementation pending\n\t    return Boolean(url);\n\t  }\n\t}\n"]}
{"filename": "src/sources/play-dl-source/play-dl-source.ts", "chunked_list": ["import { Readable } from 'node:stream';\n\timport play, { validate as validateStreamUrl, YouTubeVideo } from 'play-dl';\n\timport { BotError, ERRORS } from '@/shared/errors';\n\timport {\n\t  ResultAudioSearch,\n\t  SerachOptionsParams,\n\t  SourceStream,\n\t} from '../source-stream';\n\timport { playDlStrategies } from './strategies/strategy';\n\tconst youtubeStreamTypes = ['yt_video'];\n", "const spotifyStreamTypes = ['sp_track', 'sp_playlist'];\n\tconst validStreamTypes = [...youtubeStreamTypes, ...spotifyStreamTypes];\n\texport class PlayDlSourceStream implements SourceStream {\n\t  streamType = 'sp_track';\n\t  async getStream(input: string): Promise<Readable> {\n\t    try {\n\t      const result = await play.stream(input, {\n\t        quality: 2,\n\t      });\n\t      return result.stream;\n", "    } catch (e) {\n\t      throw new BotError(e.stack || e.message, ERRORS.RESULT_NOT_FOUND);\n\t    }\n\t  }\n\t  async search(\n\t    input: string,\n\t    options?: SerachOptionsParams\n\t  ): Promise<ResultAudioSearch[]> {\n\t    try {\n\t      const result = await play.search(input, {\n", "        ...(options?.limit && { limit: options.limit }),\n\t        source: {\n\t          youtube: 'video',\n\t        },\n\t      });\n\t      if (!result.length) throw new Error(ERRORS.RESULT_NOT_FOUND);\n\t      const resultMap = result.map((video: YouTubeVideo) => ({\n\t        duration: video.durationRaw.toString(),\n\t        id: video.id,\n\t        title: video.title,\n", "        url: video.url,\n\t        artist: video.channel?.name || video?.music.shift()?.artist,\n\t      }));\n\t      if (options?.limit === 1) {\n\t        return [resultMap.shift()];\n\t      }\n\t      return resultMap;\n\t    } catch (e) {\n\t      throw new BotError(e.stack || e.message, ERRORS.RESULT_NOT_FOUND);\n\t    }\n", "  }\n\t  async getStreamFromUrl(url: string) {\n\t    try {\n\t      if (!url?.trim().startsWith('https')) return;\n\t      const validUrl = await this.validate(url);\n\t      if (!validUrl) throw new Error(ERRORS.INVALID_URL);\n\t      if (spotifyStreamTypes.includes(this.streamType) && play.is_expired()) {\n\t        await play.refreshToken();\n\t      }\n\t      const Strategy = playDlStrategies[this.streamType];\n", "      return new Strategy(this).getStreamInfo(url);\n\t    } catch (e) {\n\t      throw new BotError(e.stack || e.message, ERRORS.RESULT_NOT_FOUND);\n\t    }\n\t  }\n\t  async validate(input: string): Promise<boolean> {\n\t    this.streamType = String(await validateStreamUrl(input));\n\t    if (Boolean(this.streamType) === false) return false;\n\t    return validStreamTypes.includes(this.streamType);\n\t  }\n", "}\n"]}
{"filename": "src/sources/play-dl-source/strategies/youtube-strategy.ts", "chunked_list": ["import play from 'play-dl';\n\timport { StreamInfo } from '@/sources/source-stream';\n\timport { IStrategy } from './strategy';\n\texport class YoutubeStrategy implements IStrategy {\n\t  async getStreamInfo(url: string): Promise<StreamInfo[]> {\n\t    const videoInfo = await play.video_info(url);\n\t    return [\n\t      {\n\t        title: videoInfo.video_details.title,\n\t        url: videoInfo.video_details.url,\n", "        artist:\n\t          String(videoInfo.video_details.channel.name) ||\n\t          String(videoInfo.video_details.music.shift().artist),\n\t      },\n\t    ];\n\t  }\n\t}\n"]}
{"filename": "src/sources/play-dl-source/strategies/strategy.ts", "chunked_list": ["import { StreamInfo } from '@/sources/source-stream';\n\timport { PlayDlSourceStream } from '../play-dl-source';\n\timport {\n\t  SpotifyPlaylistStrategy,\n\t  SpotifyTrackStrategy,\n\t} from './spotify-strategy';\n\timport { YoutubeStrategy } from './youtube-strategy';\n\texport interface StrategyConstructor {\n\t  new (playDl: PlayDlSourceStream): IStrategy;\n\t}\n", "export interface IStrategy {\n\t  getStreamInfo(url: string): Promise<StreamInfo[]>;\n\t}\n\texport const playDlStrategies = {\n\t  sp_playlist: SpotifyPlaylistStrategy,\n\t  sp_track: SpotifyTrackStrategy,\n\t  yt_video: YoutubeStrategy,\n\t};\n"]}
{"filename": "src/sources/play-dl-source/strategies/spotify-strategy.ts", "chunked_list": ["import play, { SpotifyPlaylist, SpotifyTrack } from 'play-dl';\n\timport { StreamInfo } from '@/sources/source-stream';\n\timport { PlayDlSourceStream } from '../play-dl-source';\n\timport { IStrategy } from './strategy';\n\texport class SpotifyTrackStrategy implements IStrategy {\n\t  constructor(private playDlSourceStream: PlayDlSourceStream) {}\n\t  async getStreamInfo(url: string): Promise<StreamInfo[]> {\n\t    const spotifyInfo = (await play.spotify(url.trim())) as SpotifyTrack;\n\t    const searched = (\n\t      await this.playDlSourceStream.search(\n", "        `${spotifyInfo.name} - ${spotifyInfo?.artists.shift()?.name}`,\n\t        {\n\t          limit: 1,\n\t        }\n\t      )\n\t    ).shift();\n\t    return [\n\t      {\n\t        title: spotifyInfo.name,\n\t        url: searched.url,\n", "        artist: spotifyInfo?.artists.shift().name,\n\t      },\n\t    ];\n\t  }\n\t}\n\texport class SpotifyPlaylistStrategy implements IStrategy {\n\t  async getStreamInfo(url: string): Promise<StreamInfo[]> {\n\t    const playlist = (await play.spotify(url.trim())) as SpotifyPlaylist;\n\t    const tracks = await playlist.all_tracks();\n\t    const spotifyTracks = tracks.map((track) => ({\n", "      title: track.name,\n\t      url: undefined,\n\t      artist: track?.artists.shift().name,\n\t    }));\n\t    return spotifyTracks;\n\t  }\n\t}\n"]}
{"filename": "src/helpers/helpers.ts", "chunked_list": ["export function shuffleArray<T>(array: Array<T>): T[] {\n\t  let currentIndex = array.length;\n\t  let randomIndex: number;\n\t  // While there remain elements to shuffle.\n\t  while (currentIndex != 0) {\n\t    // Pick a remaining element.\n\t    randomIndex = Math.floor(Math.random() * currentIndex);\n\t    currentIndex--;\n\t    // And swap it with the current element.\n\t    [array[currentIndex], array[randomIndex]] = [\n", "      array[randomIndex],\n\t      array[currentIndex],\n\t    ];\n\t  }\n\t  return array;\n\t}\n\texport function fragmentContent(\n\t  itemsToShow: string,\n\t  limit = 1000,\n\t  delimiter = ''\n", "): string[] {\n\t  const contentLengh = itemsToShow.length;\n\t  const parts = Math.ceil(contentLengh / limit);\n\t  let count = 1;\n\t  let initRange = 0;\n\t  const result: string[] = [];\n\t  while (count <= parts) {\n\t    let finalRange = initRange + limit;\n\t    if (delimiter && finalRange[finalRange - 1] !== delimiter) {\n\t      const lastIndexOfDelimiter = itemsToShow.lastIndexOf(\n", "        delimiter,\n\t        finalRange\n\t      );\n\t      finalRange = lastIndexOfDelimiter + delimiter.length;\n\t    }\n\t    const fragment = itemsToShow.slice(initRange, finalRange);\n\t    result.push(fragment);\n\t    initRange = finalRange;\n\t    count++;\n\t  }\n", "  return result;\n\t}\n"]}
{"filename": "src/bot/marli-music.ts", "chunked_list": ["import { Client, ClientOptions, Message } from 'discord.js';\n\timport { sentryCapture } from '@/config/sentry';\n\timport { logger } from '@/config/winston';\n\timport { Queue } from '@/queue/queue';\n\timport { ERRORS } from '@/shared/errors';\n\timport { SourceStream } from '@/sources/source-stream';\n\timport { AudioPlayer } from '@discordjs/voice';\n\timport { ALL_COMMANDS, Command } from './commands';\n\timport { CommandHelp } from './commands/command-help';\n\timport { BOT_MESSAGES } from './containts/default-messages';\n", "export interface BotInfo {\n\t  prefix: string;\n\t  token: string;\n\t}\n\texport class MarliMusic extends Client {\n\t  prefix: string;\n\t  players: Map<string, AudioPlayer> = new Map();\n\t  static MAX_REPLY_CONTENT_LENGTH = 2000;\n\t  constructor(\n\t    private botInfo: BotInfo,\n", "    public sourceStream: SourceStream,\n\t    public queue: Queue,\n\t    options?: ClientOptions\n\t  ) {\n\t    super(options);\n\t    this.prefix = botInfo.prefix;\n\t    this.login(this.botInfo.token).catch((reason) => {\n\t      logger.log('error', ERRORS.BOT_STARTUP_ERROR, reason);\n\t      sentryCapture(ERRORS.BOT_STARTUP_ERROR, new Error(reason));\n\t    });\n", "    this.once('ready', () => {\n\t      this.healthCheck();\n\t    });\n\t    this.on('error', (error: Error) => {\n\t      logger.error(ERRORS.BOT_STARTUP_ERROR, error);\n\t      sentryCapture(ERRORS.BOT_STARTUP_ERROR, error);\n\t    });\n\t    this.on('messageCreate', async (message: Message) =>\n\t      this.onMessage(message)\n\t    );\n", "  }\n\t  public healthCheck() {\n\t    const healthString = `${this.user.username} online ${this.uptime}`;\n\t    logger.log('debug', healthString);\n\t    return healthString;\n\t  }\n\t  public addPlayer(connection: string) {\n\t    this.players.set(connection, new AudioPlayer());\n\t  }\n\t  public getPlayer(connection: string) {\n", "    if (!this.players.has(connection)) {\n\t      this.addPlayer(connection);\n\t    }\n\t    return this.players.get(connection);\n\t  }\n\t  public removePlayer(connection: string) {\n\t    this.players.delete(connection);\n\t  }\n\t  private async onMessage(message: Message) {\n\t    if (message.author.bot) return;\n", "    if (!message.content.startsWith(this.prefix)) return;\n\t    const args = message.content.split(' ');\n\t    const input = message.content.replace(args[0], '');\n\t    const commandString = args[0].replace(this.prefix, '');\n\t    if (!ALL_COMMANDS[commandString]) {\n\t      await message.reply(BOT_MESSAGES.INVALID_COMMAND);\n\t      await new CommandHelp(this).execute(message);\n\t      return;\n\t    }\n\t    const command: Command = new ALL_COMMANDS[commandString](this);\n", "    await command.execute(message, input);\n\t  }\n\t}\n"]}
{"filename": "src/bot/index.ts", "chunked_list": ["import * as dotenv from 'dotenv';\n\timport { LocalQueue } from '../queue/queue';\n\timport { PlayDlSourceStream } from '../sources/play-dl-source/play-dl-source';\n\timport { MarliMusic } from './marli-music';\n\tdotenv.config();\n\texport function botStartup() {\n\t  const botInfo = {\n\t    prefix: process.env.BOT_PREFIX,\n\t    token: process.env.BOT_TOKEN,\n\t  };\n", "  const queue = new LocalQueue();\n\t  const sourceStream = new PlayDlSourceStream();\n\t  const marliMusic = new MarliMusic(botInfo, sourceStream, queue, {\n\t    intents: [\n\t      'Guilds',\n\t      'GuildMessages',\n\t      'MessageContent',\n\t      'GuildVoiceStates',\n\t      'DirectMessageReactions',\n\t      'GuildEmojisAndStickers',\n", "      'GuildMembers',\n\t      'GuildMessageTyping',\n\t      'GuildMessageReactions',\n\t    ],\n\t  });\n\t  return marliMusic;\n\t}\n"]}
{"filename": "src/bot/commands/command-help.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { MarliMusic } from '../marli-music';\n\timport { Command } from './command';\n\timport { ALL_COMMANDS } from './command-map';\n\texport class CommandHelp extends Command {\n\t  name = 'help';\n\t  constructor(bot: MarliMusic) {\n\t    super(bot);\n\t  }\n\t  async execute(message: Message) {\n", "    try {\n\t      await this.validate(message, 'help');\n\t      const commands = Object.keys(ALL_COMMANDS);\n\t      message.reply(\n\t        `Type: ${this.bot.prefix}<command> \\n\\nAll Commands:\\n${commands.join(\n\t          '\\n'\n\t        )}`\n\t      );\n\t    } catch (err) {\n\t      await this.sendCommandError(err, message);\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src/bot/commands/command-search.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { MarliMusic } from '../marli-music';\n\timport { Command } from './command';\n\texport class Search extends Command {\n\t  name = 'search';\n\t  constructor(bot: MarliMusic) {\n\t    super(bot);\n\t  }\n\t  async execute(message: Message, input: string) {\n\t    try {\n", "      await this.validate(message, input);\n\t      const source = this.getSourceStream();\n\t      const searchResult = await source.search(message.content);\n\t      const limited = searchResult.slice(0, 10);\n\t      await message.reply(\n\t        limited\n\t          .map(\n\t            (item, index) =>\n\t              `\\n${index + 1} - ${item.title} - ${item.duration} - ${item.url}`\n\t          )\n", "          .join(' ')\n\t      );\n\t    } catch (err) {\n\t      await this.sendCommandError(err, message);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/bot/commands/command-stop.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { BOT_MESSAGES } from '../containts/default-messages';\n\timport { MarliMusic } from '../marli-music';\n\timport { Command } from './command';\n\texport class Stop extends Command {\n\t  constructor(bot: MarliMusic) {\n\t    super(bot);\n\t    this.name = 'stop';\n\t  }\n\t  async execute(message: Message): Promise<void> {\n", "    try {\n\t      await this.validate(message, 'stop');\n\t      const connectionID = message.member.voice.channelId;\n\t      const player = this.getPlayer(connectionID);\n\t      const queue = this.getQueue();\n\t      player.stop();\n\t      queue.clear(connectionID);\n\t      this.removePlayer(connectionID);\n\t      this.getConnection(message).destroy();\n\t      await message.reply(BOT_MESSAGES.PLAYLIST_ENDED);\n", "    } catch (err) {\n\t      await this.sendCommandError(err, message);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/bot/commands/command-play.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { StreamInfo } from '@/sources/source-stream';\n\timport { AudioPlayerStatus, joinVoiceChannel } from '@discordjs/voice';\n\timport { BOT_MESSAGES } from '../containts/default-messages';\n\timport { MarliMusic } from '../marli-music';\n\timport { Command } from './command';\n\timport { PlayHook } from './hooks/command-play-hook';\n\texport class Play extends Command {\n\t  constructor(bot: MarliMusic) {\n\t    super(bot);\n", "    this.name = 'play';\n\t  }\n\t  async execute(message: Message, input: string) {\n\t    try {\n\t      await this.validate(message, input);\n\t      const voiceMember = message.member.voice;\n\t      const connection = joinVoiceChannel({\n\t        adapterCreator: voiceMember.guild.voiceAdapterCreator,\n\t        channelId: voiceMember.channelId,\n\t        guildId: String(voiceMember.guild.id),\n", "      });\n\t      const source = this.getSourceStream();\n\t      const queue = this.getQueue();\n\t      const searchedStream = await source.getStreamFromUrl(input);\n\t      const streamInfoCollection =\n\t        searchedStream ??\n\t        ((await source.search(input, { limit: 1 })) as StreamInfo[]);\n\t      streamInfoCollection.forEach((streamInfo: StreamInfo) => {\n\t        queue.add(voiceMember.channelId, {\n\t          streamInfo,\n", "          userSearch: input,\n\t        });\n\t      });\n\t      const firstSong = streamInfoCollection.shift();\n\t      const player = this.getPlayer(voiceMember.channelId);\n\t      connection.subscribe(player);\n\t      let replyContent = `${message.author.username} ${BOT_MESSAGES.PUSHED_TO_QUEUE} ${firstSong.title} - ${firstSong.artist}`;\n\t      if (player.state.status === AudioPlayerStatus.Idle) {\n\t        const searchResultUrl =\n\t          firstSong?.url ??\n", "          (await this.getResourceUrl(firstSong.title, firstSong.artist));\n\t        player.play(await this.getAudioResource(searchResultUrl));\n\t        const playHook = new PlayHook(this.bot);\n\t        playHook.execute(message);\n\t        replyContent = `${message.author.username} ${BOT_MESSAGES.CURRENT_PLAYING} ${firstSong.title} - ${firstSong.artist}`;\n\t      }\n\t      await message.channel.send(replyContent);\n\t    } catch (err) {\n\t      await this.sendCommandError(err, message);\n\t    }\n", "  }\n\t}\n"]}
{"filename": "src/bot/commands/command-pause.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { BOT_MESSAGES } from '../containts/default-messages';\n\timport { MarliMusic } from '../marli-music';\n\timport { Command } from './command';\n\texport class Pause extends Command {\n\t  constructor(bot: MarliMusic) {\n\t    super(bot);\n\t    this.name = 'pause';\n\t  }\n\t  async execute(message: Message): Promise<void> {\n", "    try {\n\t      await this.validate(message, 'pause');\n\t      const connectionID = message.member.voice.channelId;\n\t      const player = this.getPlayer(connectionID);\n\t      player.pause();\n\t      await message.reply({\n\t        content: `${message.author.username} ${BOT_MESSAGES.MUSIC_PAUSED}`,\n\t      });\n\t    } catch (error) {\n\t      await this.sendCommandError(error, message);\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src/bot/commands/command-shuffle.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { MarliMusic } from '@/bot/marli-music';\n\timport { Command } from './command';\n\timport { ListQueue } from './command-list-queue';\n\texport class Shuffle extends Command {\n\t  constructor(bot: MarliMusic) {\n\t    super(bot);\n\t    this.name = 'shuffle';\n\t  }\n\t  async execute(message: Message<boolean>): Promise<void> {\n", "    try {\n\t      await this.validate(message, 'shuffle');\n\t      this.getQueue().shuffle(message.member.voice.channelId);\n\t      new ListQueue(this.bot).execute(message);\n\t    } catch (error) {\n\t      await this.sendCommandError(error, message);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/bot/commands/command-list-queue.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { BOT_MESSAGES } from '../containts/default-messages';\n\timport { Command } from './command';\n\timport { MarliMusic } from '../marli-music';\n\timport { fragmentContent } from '@/helpers/helpers';\n\texport class ListQueue extends Command {\n\t  async execute(message: Message<boolean>): Promise<void> {\n\t    try {\n\t      await this.validate(message, 'list');\n\t      const connectionID = message.member.voice.channelId;\n", "      const queue = this.getQueue();\n\t      const queueList = queue.getList(connectionID);\n\t      if (!queueList?.length) {\n\t        message.reply(BOT_MESSAGES.PLAYLIST_EMPTY);\n\t        return;\n\t      }\n\t      const itemsToShow = queueList\n\t        .map(\n\t          (item, index) =>\n\t            `\\n${index + 1} - ${item.streamInfo.title} - ${\n", "              item.streamInfo.artist\n\t            }\\t`\n\t        )\n\t        .join('');\n\t      fragmentContent(\n\t        itemsToShow,\n\t        MarliMusic.MAX_REPLY_CONTENT_LENGTH,\n\t        '\\t'\n\t      ).forEach(async (fragment) => {\n\t        await message.reply(fragment);\n", "      });\n\t    } catch (error) {\n\t      await this.sendCommandError(error, message);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/bot/commands/command-map.ts", "chunked_list": ["import { CommandHelp } from './command-help';\n\timport { ListQueue } from './command-list-queue';\n\timport { Pause } from './command-pause';\n\timport { Play } from './command-play';\n\timport { Resume } from './command-resume';\n\timport { Search } from './command-search';\n\timport { Skip } from './command-skip';\n\timport { Stop } from './command-stop';\n\timport { Shuffle } from './command-shuffle';\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n", "export const ALL_COMMANDS: Record<string, any> = {\n\t  search: Search,\n\t  play: Play,\n\t  pause: Pause,\n\t  resume: Resume,\n\t  skip: Skip,\n\t  stop: Stop,\n\t  queue: ListQueue,\n\t  help: CommandHelp,\n\t  shuffle: Shuffle,\n", "};\n"]}
{"filename": "src/bot/commands/index.ts", "chunked_list": ["export { ALL_COMMANDS } from './command-map';\n\texport { Play } from './command-play';\n\texport { Pause } from './command-pause';\n\texport { Resume } from './command-resume';\n\texport { Search } from './command-search';\n\texport { Stop } from './command-stop';\n\texport { Skip } from './command-skip';\n\texport { Command } from './command';\n\texport { ListQueue } from './command-list-queue';\n\texport { CommandHelp } from './command-help';\n", "export { Shuffle } from './command-shuffle';\n"]}
{"filename": "src/bot/commands/command-skip.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { BOT_MESSAGES } from '../containts/default-messages';\n\timport { MarliMusic } from '../marli-music';\n\timport { Command } from './command';\n\timport { Stop } from './command-stop';\n\texport class Skip extends Command {\n\t  constructor(bot: MarliMusic) {\n\t    super(bot);\n\t    this.name = 'skip';\n\t  }\n", "  async execute(message: Message) {\n\t    try {\n\t      await this.validate(message, 'skip');\n\t      const connectionID = message.member.voice.channelId;\n\t      const player = this.getPlayer(connectionID);\n\t      const queue = this.getQueue();\n\t      const playlist = queue.getList(connectionID);\n\t      if (playlist?.length > 1) {\n\t        const next = playlist[1];\n\t        if (!next.streamInfo?.url) {\n", "          next.streamInfo.url = await this.getResourceUrl(\n\t            next.streamInfo.title,\n\t            next.streamInfo.artist\n\t          );\n\t        }\n\t        const audioResource = await this.getAudioResource(next.streamInfo.url);\n\t        await message.reply(\n\t          `${BOT_MESSAGES.MUSIC_SKIPPED} ${next.streamInfo.title} - ${next.streamInfo.artist}`\n\t        );\n\t        player.play(audioResource);\n", "        queue.pop(connectionID);\n\t      } else {\n\t        player.removeAllListeners();\n\t        const stop = new Stop(this.bot);\n\t        await stop.execute(message);\n\t      }\n\t    } catch (error) {\n\t      await this.sendCommandError(error, message);\n\t    }\n\t  }\n", "}\n"]}
{"filename": "src/bot/commands/command-resume.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { BOT_MESSAGES } from '../containts/default-messages';\n\timport { MarliMusic } from '../marli-music';\n\timport { Command } from './command';\n\texport class Resume extends Command {\n\t  constructor(bot: MarliMusic) {\n\t    super(bot);\n\t    this.name = 'resume';\n\t  }\n\t  async execute(message: Message): Promise<void> {\n", "    try {\n\t      await this.validate(message, 'resume');\n\t      const connectionID = message.member.voice.channelId;\n\t      const player = this.getPlayer(connectionID);\n\t      player.unpause();\n\t      await message.reply({\n\t        content: `${message.author.username} ${BOT_MESSAGES.MUSIC_RESUMED}`,\n\t      });\n\t    } catch (error) {\n\t      await this.sendCommandError(error, message);\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src/bot/commands/command.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { sentryCapture } from '@/config/sentry';\n\timport { logger } from '@/config/winston';\n\timport { BotError, ERRORS } from '@/shared/errors';\n\timport {\n\t  AudioPlayer,\n\t  createAudioResource,\n\t  getVoiceConnection,\n\t  StreamType,\n\t} from '@discordjs/voice';\n", "import { BOT_MESSAGES } from '../containts/default-messages';\n\timport { MarliMusic } from '../marli-music';\n\texport abstract class Command {\n\t  name: string;\n\t  constructor(protected bot: MarliMusic) {}\n\t  abstract execute(message: Message, input?: string): Promise<void>;\n\t  async getAudioResource(url: string) {\n\t    const source = this.getSourceStream();\n\t    const stream = await source.getStream(url);\n\t    return createAudioResource(stream, {\n", "      inputType: StreamType.Opus,\n\t    });\n\t  }\n\t  async getResourceUrl(title: string, artist: string) {\n\t    const source = this.getSourceStream();\n\t    const search = (\n\t      await source.search(`${title} ${artist}`, {\n\t        limit: 1,\n\t      })\n\t    ).shift();\n", "    return search.url;\n\t  }\n\t  getPlayer(connectionID: string): AudioPlayer {\n\t    return this.bot.getPlayer(connectionID);\n\t  }\n\t  removePlayer(connectionID: string) {\n\t    this.bot.removePlayer(connectionID);\n\t  }\n\t  getQueue() {\n\t    return this.bot.queue;\n", "  }\n\t  getSourceStream() {\n\t    return this.bot.sourceStream;\n\t  }\n\t  public getConnection(message: Message) {\n\t    return getVoiceConnection(message.member.voice.guild.id);\n\t  }\n\t  async validate(message: Message, input: string): Promise<boolean> {\n\t    const voiceChannel = message.member.voice.channel;\n\t    if (!voiceChannel) {\n", "      throw new BotError(\n\t        ERRORS.INVALID_COMMAND_USAGE,\n\t        BOT_MESSAGES.NOT_IN_A_VOICE_CHANNEL\n\t      );\n\t    }\n\t    const permissions = voiceChannel.permissionsFor(message.client.user);\n\t    if (!permissions.has('Connect') || !permissions.has('Speak')) {\n\t      throw new BotError(\n\t        ERRORS.INVALID_COMMAND_USAGE,\n\t        BOT_MESSAGES.NO_PERMISSION_JOIN_SPEAK\n", "      );\n\t    }\n\t    if (!input.length) {\n\t      throw new BotError(\n\t        ERRORS.INVALID_COMMAND_USAGE,\n\t        BOT_MESSAGES.INVALID_INPUT_MESSAGE\n\t      );\n\t    }\n\t    return true;\n\t  }\n", "  async sendCommandError(error: BotError, message: Message) {\n\t    logger.debug('error', error.stack, error);\n\t    await message.reply({\n\t      content: error.userMessage || BOT_MESSAGES.BOT_ERROR,\n\t    });\n\t    sentryCapture(ERRORS.RESOURCE_ERROR, error);\n\t  }\n\t}\n"]}
{"filename": "src/bot/commands/hooks/command-play-hook.ts", "chunked_list": ["import { Message } from 'discord.js';\n\timport { BOT_MESSAGES } from '@/bot/containts/default-messages';\n\timport { MarliMusic } from '@/bot/marli-music';\n\timport { logger } from '@/config/winston';\n\timport { BotError } from '@/shared/errors';\n\timport { AudioPlayerStatus, VoiceConnectionStatus } from '@discordjs/voice';\n\timport { Command } from '../command';\n\timport { Skip } from '../command-skip';\n\texport class PlayHook extends Command {\n\t  constructor(bot: MarliMusic) {\n", "    super(bot);\n\t  }\n\t  async execute(message: Message) {\n\t    const connectionID = message.member.voice.channelId;\n\t    const player = this.getPlayer(connectionID);\n\t    const connection = this.getConnection(message);\n\t    player.on('error', async (error: Error) => {\n\t      await this.sendCommandError(\n\t        new BotError(error.stack, BOT_MESSAGES.BOT_ERROR),\n\t        message\n", "      );\n\t    });\n\t    player.on(AudioPlayerStatus.Idle, async () => {\n\t      const skip = new Skip(this.bot);\n\t      await skip.execute(message);\n\t    });\n\t    connection.on('error', async (error: Error) => {\n\t      await this.sendCommandError(\n\t        new BotError(error.stack, BOT_MESSAGES.BOT_ERROR),\n\t        message\n", "      );\n\t    });\n\t    connection.on(VoiceConnectionStatus.Disconnected, () => {\n\t      logger.log('info', 'disconnect');\n\t      connection.destroy();\n\t      const connectionID = message.member.voice.channelId;\n\t      this.removePlayer(connectionID);\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/bot/containts/default-messages.ts", "chunked_list": ["import * as dotenv from 'dotenv';\n\tdotenv.config();\n\tconst INVALID_COMMAND = process.env.INVALID_COMMAND || 'INVALID COMMAND';\n\tconst NOT_IN_A_VOICE_CHANNEL =\n\t  process.env.NOT_IN_A_VOICE_CHANNEL || `YOU'RE NOT IN A VOICE CHANNEL`;\n\tconst NO_PERMISSION_JOIN_SPEAK =\n\t  process.env.NO_PERMISSION_JOIN_SPEAK ||\n\t  'I HAVE NO PERMISSION TO JOIN OR SPEAK';\n\tconst INVALID_INPUT_MESSAGE =\n\t  process.env.INVALID_INPUT_MESSAGE || 'INVALID INPUT MESSAGE';\n", "const CURRENT_PLAYING = process.env.CURRENT_PLAYING || \"NOW WE'RE PLAYING\";\n\tconst MUSIC_PAUSED = process.env.MUSIC_STOPPED || 'PAUSED THE MUSIC';\n\tconst MUSIC_STOPPED = process.env.MUSIC_STOPPED || 'STOPPED THE MUSIC';\n\tconst MUSIC_RESUMED = process.env.MUSIC_RESUMED || 'RESUMED THE MUSIC';\n\tconst PUSHED_TO_QUEUE =\n\t  process.env.PUSHED_TO_QUEUE || 'ADDED A SONG TO THE QUEUE';\n\tconst MUSIC_SKIPPED = process.env.MUSIC_SKIPPED || 'SKIPPED THE MUSIC';\n\tconst PLAYLIST_ENDED = process.env.PLAYLIST_ENDED || 'PLAYLIST ENDED';\n\tconst PLAYLIST_ITEMS = process.env.PLAYLIST_ITEMS || 'PLAYLIST ITEMS';\n\tconst PLAYLIST_EMPTY = process.env.PLAYLIST_EMPTY || 'PLAYLIST EMPTY';\n", "const BOT_ERROR = process.env.BOT_ERROR || 'FAILED TO EXECUTE COMMAND';\n\texport const BOT_MESSAGES = {\n\t  CURRENT_PLAYING,\n\t  INVALID_COMMAND,\n\t  INVALID_INPUT_MESSAGE,\n\t  MUSIC_PAUSED,\n\t  MUSIC_RESUMED,\n\t  MUSIC_SKIPPED,\n\t  MUSIC_STOPPED,\n\t  NOT_IN_A_VOICE_CHANNEL,\n", "  NO_PERMISSION_JOIN_SPEAK,\n\t  PLAYLIST_ENDED,\n\t  PUSHED_TO_QUEUE,\n\t  PLAYLIST_ITEMS,\n\t  PLAYLIST_EMPTY,\n\t  BOT_ERROR,\n\t};\n"]}
{"filename": "src/shared/errors.ts", "chunked_list": ["export enum ERRORS {\n\t  NO_SEARCHER_ENGINE = 'NO SEARCH ENGINE SETUP',\n\t  RESULT_NOT_FOUND = 'Result NOT FOUND',\n\t  RESOURCE_ERROR = 'RESOURCE ERROR',\n\t  SUBSCRIPTION_ERROR = 'SUBSCRIPTION ERROR',\n\t  BOT_STARTUP_ERROR = 'ERROR ON BOT STARTUP',\n\t  INVALID_URL = 'INVALID URL ERROR',\n\t  INVALID_COMMAND = 'INVALID COMMAND ERROR',\n\t  INVALID_COMMAND_USAGE = 'INVALID COMMAND USAGE ERROR',\n\t}\n", "export enum STATUS_CODES {\n\t  OK = 200,\n\t  BAD_REQUEST = 400,\n\t  UNAUTHORIZED = 401,\n\t  FORBIDDEN = 403,\n\t  NOT_FOUND = 404,\n\t  INTERNAL_SERVER_ERROR = 500,\n\t}\n\texport class BotError extends Error {\n\t  public code: STATUS_CODES;\n", "  public constructor(public message: string, public userMessage: string) {\n\t    super(message);\n\t  }\n\t}\n"]}
{"filename": "src/http/index.ts", "chunked_list": ["import express, { Application } from 'express';\n\timport { Server } from 'http';\n\timport { logger } from '../config/winston';\n\timport { mainRouter } from './routes';\n\tconst appServer: Application = express();\n\tlet httpServer: Server;\n\tfunction startServer() {\n\t  const port = process.env.PORT || 3000;\n\t  appServer.use('/', mainRouter);\n\t  httpServer = appServer.listen(port, () => {\n", "    logger.log('info', `Server listening to: ${port}`);\n\t  });\n\t}\n\texport { appServer, httpServer, startServer };\n"]}
{"filename": "src/http/routes/index.ts", "chunked_list": ["import { NextFunction, Request, Response, Router } from 'express';\n\timport { join } from 'path';\n\timport { logger } from '@/config/winston';\n\tconst mainRouter: Router = Router();\n\tmainRouter.get(\n\t  '/',\n\t  (_request: Request, response: Response, next: NextFunction) => {\n\t    const options = {\n\t      root: join('public'),\n\t    };\n", "    return response.sendFile('index.html', options, (err) => {\n\t      if (err) {\n\t        next();\n\t        logger.log('error', err.message);\n\t      }\n\t    });\n\t  }\n\t);\n\tmainRouter.post('/health-check', (_request: Request, response: Response) => {\n\t  return response.json({\n", "    message: 'Ok',\n\t  });\n\t});\n\texport { mainRouter };\n"]}
{"filename": "src/queue/queue.ts", "chunked_list": ["import { StreamInfo } from '@/sources/source-stream';\n\timport { shuffleArray } from '../helpers/helpers';\n\texport interface QueueData {\n\t  streamInfo: StreamInfo;\n\t  userSearch: string;\n\t}\n\texport abstract class Queue {\n\t  items: Map<string, QueueData[]> = new Map();\n\t  abstract getList(connection: string): QueueData[];\n\t  abstract add(connection: string, value: QueueData): void;\n", "  abstract pop(connection: string): void;\n\t  abstract clear(connection: string): void;\n\t  abstract shuffle(connection: string): void;\n\t}\n\texport class LocalQueue extends Queue {\n\t  constructor() {\n\t    super();\n\t  }\n\t  getList(connectionID: string): QueueData[] {\n\t    return this.items.get(connectionID) || [];\n", "  }\n\t  add(connectionID: string, value: QueueData) {\n\t    const connectionItems = this.getList(connectionID);\n\t    connectionItems.push(value);\n\t    this.items.set(connectionID, connectionItems);\n\t  }\n\t  pop(connectionID: string) {\n\t    const connectionItems = this.getList(connectionID);\n\t    connectionItems.shift();\n\t    this.items.set(connectionID, connectionItems);\n", "  }\n\t  clear(connectionID: string): void {\n\t    this.items.delete(connectionID);\n\t  }\n\t  shuffle(connectionID: string): void {\n\t    const list = this.getList(connectionID);\n\t    const shuffledList = shuffleArray<QueueData>(list);\n\t    this.items.set(connectionID, shuffledList);\n\t  }\n\t}\n"]}
