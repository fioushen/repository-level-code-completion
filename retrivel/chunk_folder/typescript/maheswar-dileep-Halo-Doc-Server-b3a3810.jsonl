{"filename": "src/defenitions.ts", "chunked_list": ["import { Request } from 'express';\n\tinterface RequestDefenition extends Request {\n\t  user: {\n\t    id: string;\n\t  };\n\t}\n\texport default RequestDefenition;\n"]}
{"filename": "src/index.ts", "chunked_list": ["import express from 'express';\n\timport dotenv from 'dotenv';\n\timport cors from 'cors';\n\timport morgan from 'morgan';\n\timport http from 'http';\n\timport cookieParser from 'cookie-parser';\n\timport rateLimit from 'express-rate-limit';\n\timport socket from './utils/socket.io/socketio.js';\n\t//* Routers\n\timport userRouter from './router/user.js';\n", "import adminRouter from './router/admin.js';\n\timport doctorRouter from './router/doctor.js';\n\timport router from './router/router.js';\n\timport conversationRouter from './router/conversation.js';\n\timport messageRouter from './router/message.js';\n\timport connection from './config/mongodbConnection.js';\n\tconst limiter = rateLimit({\n\t  windowMs: 15 * 60 * 1000,\n\t  max: 100,\n\t  standardHeaders: true,\n", "  legacyHeaders: false,\n\t});\n\tconst app = express();\n\tapp.use(limiter);\n\tdotenv.config();\n\t/*\n\t *connect mongodb\n\t */\n\tconnection();\n\t/*\n", " *Use Middlewares\n\t */\n\tapp.use(express.json());\n\tapp.use(cookieParser());\n\tapp.use(morgan('dev'));\n\tapp.use(\n\t  cors({\n\t    origin: [\n\t      process.env.DOCTOR_URL,\n\t      process.env.USER_URL,\n", "      process.env.ADMIN_URL,\n\t    ],\n\t  }),\n\t);\n\t/*\n\t *API Routes]\n\t */\n\tapp.use('/api', router);\n\tapp.use('/api/user', userRouter);\n\tapp.use('/api/admin', adminRouter);\n", "app.use('/api/doctor', doctorRouter);\n\tapp.use('/api/conversation', conversationRouter);\n\tapp.use('/api/message', messageRouter);\n\t/*\n\t *Start Server\n\t */\n\tapp.use((req, res) => {\n\t  res.send('Hey thats a 404');\n\t});\n\t/*\n", " *socket io\n\t */\n\tconst server = http.createServer(app);\n\tsocket(server);\n\tconst port = process.env.PORT || 8080;\n\t// eslint-disable-next-line no-console\n\tserver.listen(port, () => console.log(`Server Started on http://localhost:${port}`));\n"]}
{"filename": "src/Types/interface.ts", "chunked_list": ["export interface IAdmin {\n\t  name: string;\n\t  email: string;\n\t  password: string;\n\t}\n\texport interface Ioptions {\n\t  page: number;\n\t  limit: number;\n\t}\n\texport interface IAppointment {\n", "  userId: string;\n\t  firstName: string;\n\t  lastName: string;\n\t  age: string;\n\t  gender: string;\n\t  email: string;\n\t  mobile: string;\n\t  department: string;\n\t  symptoms: Array<string>;\n\t  date: string;\n", "  time: string;\n\t  doctorName: string;\n\t  doctorId: string;\n\t  price: string;\n\t  cancelled: boolean;\n\t  payment: boolean;\n\t  payment_intent: string;\n\t  active: boolean;\n\t}\n\texport interface IBlog {\n", "  title: string;\n\t  content: string;\n\t  imageURL: string;\n\t}\n\texport interface IConversation {\n\t  members: Array<string>;\n\t}\n\texport interface IDept {\n\t  name: string;\n\t}\n", "export interface IDoctor {\n\t  firstName: string;\n\t  lastName: string;\n\t  email: string;\n\t  phone: number;\n\t  address: string;\n\t  profile: string;\n\t  photoURL: string;\n\t  dob: string;\n\t  department: string;\n", "  workTime: string;\n\t  fees: string;\n\t  leave: Array<string>;\n\t  password: string;\n\t}\n\texport interface IFeedback {\n\t  doctorId: string;\n\t  userId: string;\n\t  rating: number;\n\t  feedback: string;\n", "}\n\texport interface IMessage {\n\t  conversationId: string;\n\t  sender: string;\n\t  text: string;\n\t}\n\texport interface IReportDoctor {\n\t  doctorId: string;\n\t  userId: string;\n\t  reason: string;\n", "}\n\texport interface IUser {\n\t  name: string;\n\t  email: string;\n\t  profileURL: string;\n\t  blocked: boolean;\n\t  prescription: Array<object>;\n\t}\n"]}
{"filename": "src/utils/nodemailer.ts", "chunked_list": ["import nodemailer from 'nodemailer';\n\timport fs from 'fs/promises';\n\timport dotenv from 'dotenv';\n\tconst { readFile } = fs;\n\tdotenv.config();\n\tconst sendMail = async (mailType: string, email: string) => {\n\t  try {\n\t    let html: string | Buffer;\n\t    if (mailType === 'welcome') {\n\t      html = await readFile('./src/utils/mailHtml/welcome-mail.html', 'utf8');\n", "    } else if ('appointment') {\n\t      html = await readFile('./src/utils/mailHtml/appointment-mail.html', 'utf8');\n\t    }\n\t    const transporter = nodemailer.createTransport({\n\t      service: 'gmail',\n\t      host: 'smtp.gmail.email',\n\t      port: 465,\n\t      auth: {\n\t        type: 'login',\n\t        user: process.env.SMTP_USER,\n", "        pass: process.env.SMTP_PASS,\n\t      },\n\t    });\n\t    const info = await transporter.sendMail({\n\t      from: process.env.SMTP_USER, // sender address\n\t      to: email, // list of receivers\n\t      subject: 'Welcome To Halo-Doc', // Subject line\n\t      html,\n\t    });\n\t  } catch (error) {\n", "    console.log(error);\n\t    throw error;\n\t  }\n\t};\n\texport default sendMail;\n"]}
{"filename": "src/utils/socket.io/socketio.ts", "chunked_list": ["import { Server } from 'socket.io';\n\timport mongoose from 'mongoose';\n\timport dotenv from 'dotenv';\n\tdotenv.config();\n\texport default function socketIo(server: any) {\n\t  const io = new Server(server, {\n\t    cors: {\n\t      origin: [process.env.DOCTOR_URL, process.env.USER_URL, process.env.ADMIN_URL],\n\t      methods: ['GET', 'POST'],\n\t    },\n", "  });\n\t  let users = [];\n\t  const addUser = (userId: mongoose.Types.ObjectId, socketId: string) => {\n\t    const userExists = users.some((user) => user.userId === userId);\n\t    if (!userExists) {\n\t      users.push({ userId, socketId });\n\t    }\n\t  };\n\t  const removeUser = (socketId: string) => {\n\t    users = users.filter((user) => user.socketId !== socketId);\n", "  };\n\t  const getUser = (userId: string) => {\n\t    const user = users.find((data) => data.userId === userId);\n\t    return user;\n\t  };\n\t  io.on('connection', (socket) => {\n\t    socket.on('addUser', (userId) => {\n\t      addUser(userId, socket.id);\n\t    });\n\t    io.emit('allUsers', users);\n", "    socket.on('sendMessage', ({ senderId, recieverId, text }) => {\n\t      const user = getUser(recieverId);\n\t      io.to(user?.socketId).emit('getMessage', {\n\t        senderId,\n\t        text,\n\t      });\n\t    });\n\t    socket.on('disconnect', () => {\n\t      removeUser(socket.id);\n\t    });\n", "  });\n\t}\n"]}
{"filename": "src/config/firebase.ts", "chunked_list": ["import { initializeApp, applicationDefault } from 'firebase-admin/app';\n\timport { getAuth } from 'firebase-admin/auth';\n\timport dotenv from 'dotenv';\n\tdotenv.config();\n\tinitializeApp({\n\t  credential: applicationDefault(),\n\t});\n\tconst verifyFirebaseToken = async ({ idToken }: { idToken: string }) => {\n\t  // eslint-disable-next-line no-useless-catch\n\t  try {\n", "    // uid\n\t    const { uid } = await getAuth().verifyIdToken(idToken);\n\t    // user data\n\t    return await getAuth().getUser(uid);\n\t  } catch (error) {\n\t    throw error;\n\t  }\n\t};\n\texport default verifyFirebaseToken;\n"]}
{"filename": "src/config/mongodbConnection.ts", "chunked_list": ["import mongoose from 'mongoose';\n\tmongoose.connection.once('connected', () => {\n\t  console.log('db connected successfully');\n\t});\n\tconst connection = async () => {\n\t  try {\n\t    await mongoose.connect(process.env.MONGODB_URL);\n\t  } catch (error) {\n\t    console.log(error);\n\t  }\n", "};\n\texport default connection;\n"]}
{"filename": "src/model/messageSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\n\timport { IMessage } from '../Types/interface.js';\n\tinterface MessageDocument extends IMessage, Document {}\n\tconst messageSchema = new Schema<MessageDocument>(\n\t  {\n\t    conversationId: {\n\t      type: String,\n\t      required: true,\n\t    },\n\t    sender: {\n", "      type: String,\n\t      required: true,\n\t    },\n\t    text: {\n\t      type: String,\n\t      required: true,\n\t    },\n\t  },\n\t  {\n\t    timestamps: true,\n", "  },\n\t);\n\tconst messageModel = mongoose.model<IMessage>('message', messageSchema);\n\texport default messageModel;\n"]}
{"filename": "src/model/appointmentSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\n\timport paginate from 'mongoose-paginate-v2';\n\timport { IAppointment } from '../Types/interface.js';\n\tinterface AppointmentDocument extends IAppointment, Document {}\n\tconst appointmentSchema = new Schema<AppointmentDocument>({\n\t  userId: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  firstName: {\n", "    type: String,\n\t    required: true,\n\t  },\n\t  lastName: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  age: {\n\t    type: String,\n\t    required: true,\n", "  },\n\t  gender: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  email: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  mobile: {\n", "    type: String,\n\t    required: true,\n\t  },\n\t  department: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  symptoms: {\n\t    type: [String],\n\t    required: true,\n", "  },\n\t  date: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  time: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  doctorName: {\n", "    type: String,\n\t    required: true,\n\t  },\n\t  doctorId: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  price: {\n\t    type: String,\n\t    required: true,\n", "  },\n\t  cancelled: {\n\t    type: Boolean,\n\t    default: false,\n\t  },\n\t  payment: {\n\t    type: Boolean,\n\t    default: true,\n\t  },\n\t  active: {\n", "    type: Boolean,\n\t    default: true,\n\t  },\n\t  payment_intent: {\n\t    type: String,\n\t  },\n\t});\n\tappointmentSchema.plugin(paginate);\n\tconst appointmentModel = mongoose.model<AppointmentDocument, mongoose.PaginateModel<AppointmentDocument>>('appointment', appointmentSchema);\n\texport default appointmentModel;\n"]}
{"filename": "src/model/adminSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\n\timport paginate from 'mongoose-paginate-v2';\n\timport { IAdmin } from '../Types/interface.js';\n\tinterface AdminDocument extends IAdmin, Document {}\n\tconst adminSchema = new Schema<AdminDocument>({\n\t  name: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  email: {\n", "    type: String,\n\t    required: true,\n\t  },\n\t  password: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t});\n\tadminSchema.plugin(paginate);\n\tconst adminModel = mongoose.model<AdminDocument, mongoose.PaginateModel<AdminDocument>>('admin', adminSchema);\n", "export default adminModel;\n"]}
{"filename": "src/model/reportDoctorSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\n\timport paginate from 'mongoose-paginate-v2';\n\timport { IReportDoctor } from '../Types/interface.js';\n\tinterface ReportDocument extends IReportDoctor, Document {}\n\tconst reportDoctorSchema = new Schema<ReportDocument>({\n\t  doctorId: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  userId: {\n", "    type: String,\n\t    required: true,\n\t  },\n\t  reason: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t});\n\treportDoctorSchema.plugin(paginate);\n\tconst reportDoctorModel = mongoose.model<IReportDoctor>('ReportDoctor', reportDoctorSchema);\n", "export default reportDoctorModel;\n"]}
{"filename": "src/model/conversationSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\n\timport { IConversation } from '../Types/interface.js';\n\tinterface ConversationDocument extends IConversation, Document {}\n\tconst conversationSchema = new Schema<ConversationDocument>(\n\t  {\n\t    members: {\n\t      type: [String],\n\t      required: true,\n\t    },\n\t  },\n", "  {\n\t    timestamps: true,\n\t  },\n\t);\n\tconst conversationModel = mongoose.model<IConversation>('conversation', conversationSchema);\n\texport default conversationModel;\n"]}
{"filename": "src/model/feedback.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\n\timport paginate from 'mongoose-paginate-v2';\n\timport { IFeedback } from '../Types/interface.js';\n\tinterface FeedbackDocument extends IFeedback, Document {}\n\tconst feedbackSchema = new Schema<FeedbackDocument>({\n\t  doctorId: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  userId: {\n", "    type: String,\n\t    required: true,\n\t  },\n\t  rating: {\n\t    type: Number,\n\t    required: true,\n\t  },\n\t  feedback: {\n\t    type: String,\n\t  },\n", "});\n\tfeedbackSchema.plugin(paginate);\n\tconst feedbackModel = mongoose.model<FeedbackDocument, mongoose.PaginateModel<FeedbackDocument>>('Feedback', feedbackSchema);\n\texport default feedbackModel;\n"]}
{"filename": "src/model/blogSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\n\timport paginate from 'mongoose-paginate-v2';\n\timport { IBlog } from '../Types/interface.js';\n\tinterface BlogDocument extends IBlog, Document {}\n\tconst blogSchema = new Schema<BlogDocument>({\n\t  title: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  content: {\n", "    type: String,\n\t    required: true,\n\t  },\n\t  imageURL: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t});\n\tblogSchema.plugin(paginate);\n\tconst blogModel = mongoose.model<BlogDocument, mongoose.PaginateModel<BlogDocument>>('Blog', blogSchema);\n", "export default blogModel;\n"]}
{"filename": "src/model/index.ts", "chunked_list": ["import USER from './userSchema.js';\n\timport ADMIN from './adminSchema.js';\n\timport DOCTOR from './doctorSchema.js';\n\timport DEPARTMENT from './departmentSchema.js';\n\timport BLOG from './blogSchema.js';\n\timport APPOINTMENT from './appointmentSchema.js';\n\timport MESSAGE from './messageSchema.js';\n\timport CONVERSATION from './conversationSchema.js';\n\timport REPORT_DOCTOR from './reportDoctorSchema.js';\n\timport FEEDBACK from './feedback.js';\n", "export {\n\t  USER,\n\t  ADMIN,\n\t  DOCTOR,\n\t  DEPARTMENT,\n\t  BLOG,\n\t  APPOINTMENT,\n\t  MESSAGE,\n\t  CONVERSATION,\n\t  REPORT_DOCTOR,\n", "  FEEDBACK,\n\t};\n"]}
{"filename": "src/model/userSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\n\timport paginate from 'mongoose-paginate-v2';\n\timport { IUser } from '../Types/interface.js';\n\tinterface UserDocument extends IUser, Document {}\n\tconst userSchema = new Schema<UserDocument>({\n\t  name: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  email: {\n", "    type: String,\n\t    required: true,\n\t  },\n\t  profileURL: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  prescription: {\n\t    type: [Object],\n\t  },\n", "});\n\tuserSchema.plugin(paginate);\n\tconst userModel = mongoose.model<UserDocument, mongoose.PaginateModel<UserDocument>>('user', userSchema);\n\texport default userModel;\n"]}
{"filename": "src/model/doctorSchema.ts", "chunked_list": ["import mongoose, { Schema, Document } from 'mongoose';\n\timport paginate from 'mongoose-paginate-v2';\n\timport { IDoctor } from '../Types/interface.js';\n\tinterface DoctorDocument extends IDoctor, Document {}\n\tconst doctorSchema = new Schema<DoctorDocument>({\n\t  firstName: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  lastName: {\n", "    type: String,\n\t    required: true,\n\t  },\n\t  email: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  phone: {\n\t    type: Number,\n\t    required: true,\n", "  },\n\t  address: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  profile: {\n\t    type: String,\n\t    requied: true,\n\t  },\n\t  photoURL: {\n", "    type: String,\n\t    required: true,\n\t  },\n\t  dob: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  department: {\n\t    type: String,\n\t    required: true,\n", "  },\n\t  workTime: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  fees: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t  leave: {\n", "    type: [String],\n\t  },\n\t  password: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t});\n\tdoctorSchema.plugin(paginate);\n\tconst doctorModel = mongoose.model<DoctorDocument, mongoose.PaginateModel<DoctorDocument>>('Doctor', doctorSchema);\n\texport default doctorModel;\n"]}
{"filename": "src/model/departmentSchema.ts", "chunked_list": ["import mongoose, { Document, Schema } from 'mongoose';\n\timport paginate from 'mongoose-paginate-v2';\n\timport { IDept } from '../Types/interface.js';\n\tinterface DepartmentDocument extends IDept, Document {}\n\tconst departmentSchema = new Schema<DepartmentDocument>({\n\t  name: {\n\t    type: String,\n\t    required: true,\n\t  },\n\t});\n", "departmentSchema.plugin(paginate);\n\tconst departmentModel = mongoose.model<IDept>('department', departmentSchema);\n\texport default departmentModel;\n"]}
{"filename": "src/middlewares/auth.ts", "chunked_list": ["import jwt, { JwtPayload, VerifyErrors } from 'jsonwebtoken';\n\timport { Response, NextFunction } from 'express';\n\timport dotenv from 'dotenv';\n\timport RequestDefenition from '../defenitions.js';\n\tdotenv.config();\n\tconst auth = async (req: RequestDefenition, res: Response, next: NextFunction) => {\n\t  try {\n\t    const token = req.headers.authorization?.split(' ')?.[1];\n\t    if (!token) return res.status(401).send({ success: false, message: 'Missing Token' });\n\t    // eslint-disable-next-line max-len\n", "    jwt.verify(token, process.env.JWT_SECRET, (err: VerifyErrors | null, decoded: string | JwtPayload) => {\n\t      if (err) return res.status(401).send({ success: false, message: 'Invalid Token' });\n\t      req.user = { id: decoded?.['id'] };\n\t      next();\n\t    });\n\t  } catch (error) {\n\t    console.error('Error in auth midleware :- ', error);\n\t    res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n", "export default auth;\n"]}
{"filename": "src/controller/doctorController.ts", "chunked_list": ["import { Request, Response } from 'express';\n\timport bcrypt from 'bcrypt';\n\timport jwt from 'jsonwebtoken';\n\timport Stripe from 'stripe';\n\timport mongoose from 'mongoose';\n\timport {\n\t  APPOINTMENT, BLOG, DOCTOR, USER,\n\t} from '../model/index.js';\n\timport { IBlog } from '../Types/interface.js';\n\tconst stripe = new Stripe(process.env.STRIPE_SECRET, {\n", "  apiVersion: '2022-11-15',\n\t});\n\t//* Login\n\tinterface IDoctor {\n\t  _id: string;\n\t  firstName: string;\n\t  lastName: string;\n\t  email: string;\n\t  phone: number;\n\t  address: string;\n", "  profile: string;\n\t  photoURL: string;\n\t  dob: string;\n\t  department: string;\n\t  workTime: string;\n\t  fees: string;\n\t  leave: Array<string>;\n\t  password: string;\n\t}\n\texport const login = async (req: Request, res: Response) => {\n", "  try {\n\t    const { email, password } = req.body;\n\t    const doctor: IDoctor = await DOCTOR.findOne({ email });\n\t    if (!doctor) {\n\t      return res.status(200).send({ success: false, message: 'Doctor does not exist' });\n\t    }\n\t    const match = await bcrypt.compare(password, doctor.password);\n\t    if (match) {\n\t      const token: string = jwt.sign({ id: doctor._id }, process.env.JWT_SECRET, {\n\t        expiresIn: '15d',\n", "      });\n\t      doctor.password = null;\n\t      return res.status(200).send({\n\t        success: true,\n\t        message: 'Doctor login successfull',\n\t        doctor,\n\t        token,\n\t      });\n\t    }\n\t    return res.status(200).send({ success: false, message: 'Wrong Password' });\n", "  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n\t};\n\t//* add-blog\n\texport const addBlog = async (req: Request, res: Response) => {\n\t  try {\n\t    const blogData: IBlog = {\n\t      title: req.body.title,\n", "      content: req.body.content,\n\t      imageURL: req.body.imageURL,\n\t    };\n\t    const blog = new BLOG(blogData);\n\t    await blog.save();\n\t    return res.status(200).send({ success: true, message: 'Blog adding successfull' });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n", "};\n\t//* get-appointment\n\texport const getAppointments = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    const data = await APPOINTMENT.find({ doctorId: id });\n\t    return res.status(200).send({ success: true, message: 'Get Appointments Successful', data });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal server error' });\n", "  }\n\t};\n\t//* cancel-appointment\n\texport const cancelAppointment = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    const appointment = await APPOINTMENT.findOne({ _id: id });\n\t    if (!appointment) return res.status(404).send({ success: false, message: 'Appointment not found' });\n\t    await stripe.refunds.create({\n\t      payment_intent: appointment.payment_intent,\n", "    });\n\t    await APPOINTMENT.updateOne({ _id: id }, { cancelled: true, active: false });\n\t    return res.status(200).send({ success: true, message: 'Appointment cancelled successfully' });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* get Doctor\n\texport const getDoctor = async (req: Request, res: Response) => {\n", "  try {\n\t    const { id } = req.params;\n\t    const doctor = await DOCTOR.find({ _id: id });\n\t    return res.status(200).send({ success: true, message: 'get doctor Successful', doctor });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n\t};\n\t//* edit doctor\n", "export const editDoctor = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    //* Destructuring Data from request body\n\t    const {\n\t      firstName,\n\t      fees,\n\t      workTime,\n\t      lastName,\n\t      email,\n", "      phone,\n\t      address,\n\t      department,\n\t      dob,\n\t      profile,\n\t      photoURL,\n\t    }: IDoctor = req.body;\n\t    const doctor = {\n\t      firstName,\n\t      lastName,\n", "      email,\n\t      phone,\n\t      address,\n\t      profile,\n\t      department,\n\t      dob,\n\t      fees,\n\t      workTime,\n\t      photoURL,\n\t    };\n", "    //  Updating Doctor Profile\n\t    const result = await DOCTOR.updateOne({ email }, doctor);\n\t    console.log(result);\n\t    return res.status(200).json({ success: true, message: 'Doctor profile edited succesfully' });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).json({ success: false, message: 'internal server error' });\n\t  }\n\t};\n\t//* Get-All-Doctors\n", "export const getAllDoctors = async (req: Request, res: Response) => {\n\t  try {\n\t    const doctors = await DOCTOR.find({});\n\t    res.status(200).send({ success: true, message: 'get All doctors succesfull', data: doctors });\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n\t};\n\t//* get Patients Stat\n", "export const getPatients = async (req: Request, res: Response) => {\n\t  try {\n\t    const id = req.params?.id;\n\t    const patients = await APPOINTMENT.aggregate([\n\t      {\n\t        $group: {\n\t          _id: '$doctorId',\n\t          male: {\n\t            $sum: {\n\t              $cond: [{ $eq: ['$gender', 'male'] }, 1, 0],\n", "            },\n\t          },\n\t          female: {\n\t            $sum: {\n\t              $cond: [{ $eq: ['$gender', 'female'] }, 1, 0],\n\t            },\n\t          },\n\t          total: { $sum: 1 },\n\t        },\n\t      },\n", "      {\n\t        $project: {\n\t          _id: 0,\n\t          doctorId: '$_id',\n\t          male: 1,\n\t          female: 1,\n\t          total: 1,\n\t        },\n\t      },\n\t    ]);\n", "    res.status(200).send({ success: true, message: 'get patients successful', patients });\n\t  } catch (error) {\n\t    res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* get total revenue\n\texport const getTotalRevenue = async (req: Request, res: Response) => {\n\t  try {\n\t    const id = req.params?.id;\n\t    const revenue = await APPOINTMENT.aggregate([\n", "      {\n\t        $group: {\n\t          _id: null,\n\t          totalPrice: { $sum: { $toInt: '$price' } },\n\t        },\n\t      },\n\t    ]);\n\t    res.status(200).send({ success: true, message: 'get revenue successful', revenue: revenue[0].totalPrice });\n\t  } catch (error) {\n\t    console.log(error);\n", "    res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n\t};\n\t//* Apply Leave\n\texport const applyLeave = async (req: Request, res: Response) => {\n\t  try {\n\t    const { leaveDate, doctorId } = req.body;\n\t    const doctor = await DOCTOR.findOne({ _id: doctorId });\n\t    if (!doctor) return res.status(404).send({ success: false, message: 'user not found' });\n\t    if (doctor?.leave?.includes(leaveDate)) {\n", "      return res.status(200).json({ success: false, message: 'Leave Already Applied on the Same Date' });\n\t    }\n\t    await DOCTOR.updateOne({ _id: doctorId }, { $push: { leave: leaveDate } });\n\t    return res.status(200).send({ success: true, message: 'Leave Applied Successfully' });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* Apply Leave\n", "export const cancelLeave = async (req: Request, res: Response) => {\n\t  try {\n\t    const { leaveDate, doctorId } = req.body;\n\t    const doctor = await DOCTOR.findOne({ _id: doctorId });\n\t    if (!doctor) return res.status(404).send({ success: false, message: 'user not found' });\n\t    if (doctor?.leave?.includes(leaveDate) === false) {\n\t      return res.status(200).json({ success: false, message: 'No Leave on the Same Date' });\n\t    }\n\t    const date = doctor.leave.filter((data) => data !== leaveDate);\n\t    await DOCTOR.updateOne({ _id: doctorId }, { leave: date });\n", "    const result = await DOCTOR.findOne({ _id: doctorId });\n\t    return res.status(200).send({ success: true, message: 'Leave Cancelled Successfully', result: result.leave });\n\t  } catch (error) {\n\t    console.log('Error in doctor:: cancel leave :- ', error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* Add Prescription\n\texport const addPrescription = async (req: Request, res: Response) => {\n\t  try {\n", "    const {\n\t      id, medicine, dosage, notes, doctor, date,\n\t    } = req.body;\n\t    const user = await USER.findOne({ _id: new mongoose.Types.ObjectId(id) });\n\t    if (!user) return res.status(404).send({ success: false, message: 'Prescription not found with id' });\n\t    user.prescription.push({\n\t      id: user.prescription.length + 1,\n\t      medicine,\n\t      dosage,\n\t      notes,\n", "      doctor,\n\t      date,\n\t    });\n\t    await user.save();\n\t    return res.status(200).send({ success: true, message: 'Prescription added Successfully' });\n\t  } catch (error) {\n\t    console.error('Error in doctor: add prescription :-', error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n", "//* get monthly revenue\n\texport const getMontlyRevenue = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    const result = await APPOINTMENT.aggregate([\n\t      {\n\t        $group: {\n\t          _id: {\n\t            month: { $month: { $toDate: '$date' } },\n\t            year: { $year: { $toDate: '$date' } },\n", "          },\n\t          revenue: { $sum: { $toDouble: '$price' } },\n\t        },\n\t      },\n\t      {\n\t        $sort: {\n\t          '_id.year': 1,\n\t          '_id.month': 1,\n\t        },\n\t      },\n", "    ]);\n\t    const monthlyRevenueArray = Array(12).fill(0);\n\t    result.forEach((item) => {\n\t      const monthIndex = item._id.month - 1;\n\t      monthlyRevenueArray[monthIndex] = item.revenue;\n\t    });\n\t    res.status(200).send({ success: true, message: 'get Revenue Successfull', data: result });\n\t  } catch (error) {\n\t    console.log('error in get monthly revenue', error);\n\t    res.status(500).json({ error: 'Unable to retrieve the data' });\n", "  }\n\t};\n"]}
{"filename": "src/controller/message.ts", "chunked_list": ["import { Request, Response } from 'express';\n\timport { MESSAGE } from '../model/index.js';\n\texport const newMessage = async (req: Request, res: Response) => {\n\t  try {\n\t    const { conversationId, sender, text } = req.body;\n\t    const newMsg = new MESSAGE({ conversationId, sender, text });\n\t    const messages = await newMsg.save();\n\t    return res.status(200).send({ success: true, message: 'New Message Successful', messages });\n\t  } catch (error) {\n\t    console.log(error);\n", "    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\texport const getMessage = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    const messages: object = await MESSAGE.find({ conversationId: id });\n\t    return res.status(200).send({ success: true, message: 'Get Message Successful', messages });\n\t  } catch (error) {\n\t    console.log(error);\n", "    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n"]}
{"filename": "src/controller/conversation.ts", "chunked_list": ["import { Request, Response } from 'express';\n\timport { CONVERSATION } from '../model/index.js';\n\t//* conversation controller\n\texport const newConversation = async (req: Request, res: Response) => {\n\t  try {\n\t    const { senderId, recieverId } = req.body;\n\t    const newConvs = await new CONVERSATION({ members: [recieverId, senderId] });\n\t    const data = await newConvs.save();\n\t    return res.status(200).send({ success: true, message: 'Conversation Created Successfully', convId: data._id });\n\t  } catch (error) {\n", "    console.error(error);\n\t    return res.status(500).send({ success: true, message: 'Internal Server Error' });\n\t  }\n\t};\n\texport const getConversation = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    const conversation = await CONVERSATION.find({\n\t      members: { $in: [id] },\n\t    });\n", "    return res.status(200).send({ success: true, message: 'get conversation successfull', conversation });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n"]}
{"filename": "src/controller/controllers.ts", "chunked_list": ["import { Request, Response } from 'express';\n\timport { BLOG, DEPARTMENT, DOCTOR } from '../model/index.js';\n\timport { Ioptions } from '../Types/interface.js';\n\t//* Get-all-blogs\n\texport const getAllBlogs = async (req: Request, res: Response) => {\n\t  try {\n\t    const { page } = req.query;\n\t    const options: Ioptions = {\n\t      page: Number(page) || 1,\n\t      limit: 12,\n", "    };\n\t    const data = await BLOG.paginate({}, options);\n\t    res.status(200).send({ success: true, message: 'get all blog successfull', data });\n\t  } catch (error) {\n\t    console.log('Error in common controller: Get-All-blogs :-', error);\n\t    res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n\t};\n\texport const getBlogs = async (req: Request, res: Response) => {\n\t  try {\n", "    const id = req.params;\n\t    const blog = BLOG.find({ _id: id });\n\t    return res.status(200).send({ success: true, message: 'get blog successful', data: blog });\n\t  } catch (error) {\n\t    console.log('Error in common controller: Get-blog :-', error);\n\t    return res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n\t};\n\texport const getAllDoctors = async (req: Request, res: Response) => {\n\t  try {\n", "    const { page } = req.query;\n\t    const options: Ioptions = {\n\t      page: Number(page) || 1,\n\t      limit: 12,\n\t    };\n\t    const data = await DOCTOR.paginate({}, options);\n\t    return res.status(200).send({ success: true, message: 'get all Doctors Successful', data });\n\t  } catch (error) {\n\t    console.log('Error in common contoller - Get-all-doctors :-', error);\n\t    return res.status(500).send({ success: true, message: 'Internal Server Error' });\n", "  }\n\t};\n\texport const getDepartments = async (req: Request, res: Response) => {\n\t  try {\n\t    const department = await DEPARTMENT.find({});\n\t    return res.status(200).send({ success: true, message: 'get department successful', data: department });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: true, message: 'Internal Server Error' });\n\t  }\n", "};\n\texport const searchDoctors = async (req: Request, res: Response) => {\n\t  try {\n\t    const { keyword } = req.query;\n\t    const regex = new RegExp(keyword.toString(), 'i');\n\t    const result = await DOCTOR.find({ firstName: { $regex: regex } });\n\t    return res.status(200).send({ success: true, message: 'search doctor successful', result });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: true, message: 'Internal Server Error' });\n", "  }\n\t};\n"]}
{"filename": "src/controller/userController.ts", "chunked_list": ["import dotenv from 'dotenv';\n\timport { Request, Response } from 'express';\n\timport Stripe from 'stripe';\n\timport jwt from 'jsonwebtoken';\n\timport * as exportJs from '../model/index.js';\n\timport verifyFirebaseToken from '../config/firebase.js';\n\timport mailService from '../utils/nodemailer.js';\n\timport { IUser } from '../Types/interface.js';\n\tdotenv.config();\n\tconst stripe = new Stripe(process.env.STRIPE_SECRET, {\n", "  apiVersion: '2022-11-15',\n\t});\n\t//* User SignUp\n\texport const signup = async (req: Request, res: Response) => {\n\t  try {\n\t    /**\n\t     * * Getting user detiails from idToken\n\t     */\n\t    const { idToken } = req.body;\n\t    const user = await verifyFirebaseToken({ idToken });\n", "    const userData = {\n\t      name: user.displayName,\n\t      email: user.email,\n\t      profileURL: user?.photoURL ? user?.photoURL : false,\n\t    };\n\t    // * Saving userData to Database\n\t    const newUser = new exportJs.USER(userData);\n\t    const response = await newUser.save();\n\t    const id = response?._id;\n\t    const token = jwt.sign({ id }, process.env.JWT_SECRET, {\n", "      expiresIn: '15d',\n\t    });\n\t    mailService('welcome', user.email);\n\t    res.status(200).send({\n\t      success: true,\n\t      message: user?.photoURL ? 'google login succesful' : 'email login succesfull',\n\t      token,\n\t    });\n\t  } catch (error) {\n\t    console.log(error);\n", "    res.status(500).send({ success: false, message: 'internal server error' });\n\t  }\n\t};\n\t//* User Login\n\texport const login = async (req: Request, res: Response) => {\n\t  try {\n\t    /**\n\t     * * Getting user Details from idToken\n\t     */\n\t    const { idToken } = req.body;\n", "    const user = await verifyFirebaseToken({ idToken });\n\t    if (user) {\n\t      const userData = await exportJs.USER.findOne({ email: user?.email });\n\t      const id = userData?._id;\n\t      const token = jwt.sign({ id }, process.env.JWT_SECRET, {\n\t        expiresIn: '1d',\n\t      });\n\t      res.status(200).send({\n\t        success: true,\n\t        message: user?.photoURL ? 'google login succesful' : 'email login succesfull',\n", "        token,\n\t        user: userData,\n\t      });\n\t    }\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'internal server error' });\n\t  }\n\t};\n\t//* Get User Info\n", "export const getUserInfo = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    const user = await exportJs.USER.findById(id).exec();\n\t    return res.status(200).send({ success: true, message: 'get user successful', data: user });\n\t  } catch (error) {\n\t    console.log('Error in userController : get user info :-', error);\n\t    return res.status(500).send({ success: false, message: 'internal server error' });\n\t  }\n\t};\n", "//* Get Doctors\n\texport const getDoctorsbyDept = async (req: Request, res: Response) => {\n\t  try {\n\t    const { department } = req.query;\n\t    const doctors = await exportJs.DOCTOR.find({ department });\n\t    return res.status(200).send({ success: true, message: 'Get doctors by department successful', data: doctors });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'internal server error' });\n\t  }\n", "};\n\t//* WEB-HOOK (! For Stripe Payment )\n\texport const webHooks = async (req: Request, res: Response) => {\n\t  try {\n\t    const sig = req.headers['stripe-signature'];\n\t    const endpointSecret = null;\n\t    let event;\n\t    const jsonStringify = JSON.stringify(req.body);\n\t    const payloadBuffer = Buffer.from(jsonStringify);\n\t    let data;\n", "    let eventType;\n\t    if (endpointSecret) {\n\t      try {\n\t        event = stripe.webhooks.constructEvent(payloadBuffer, sig, endpointSecret);\n\t        // console.log('webhook verified');\n\t      } catch (err) {\n\t        console.log(`Webhook Error: ${err.message}`);\n\t        return res.status(400).send(`Webhook Error: ${err.message}`);\n\t      }\n\t      data = event.data.object;\n", "      eventType = event.type;\n\t    } else {\n\t      data = req.body.data.object;\n\t      eventType = req.body.type;\n\t    }\n\t    try {\n\t      if (eventType === 'checkout.session.completed') {\n\t        const customer = await stripe.customers.retrieve(data.customer);\n\t        // eslint-disable-next-line @typescript-eslint/dot-notation\n\t        const appointments = customer?.['metadata']?.appointments;\n", "        const newAppointment = new exportJs.APPOINTMENT(JSON.parse(appointments));\n\t        newAppointment.save();\n\t      }\n\t    } catch (error) {\n\t      console.log(`Webhook Error: ${error.message}`);\n\t    }\n\t    return res.send().end();\n\t  } catch (error) {\n\t    console.log(`Webhook Error: ${error.message}`);\n\t  }\n", "};\n\t//* Creating Stripe Payment\n\texport const payment = async (req: Request, res: Response) => {\n\t  try {\n\t    const bodyData = req.body;\n\t    try {\n\t      const newAppointment = new exportJs.APPOINTMENT(bodyData);\n\t      newAppointment.save();\n\t      const customer = await stripe.customers.create({\n\t        metadata: {\n", "          userId: bodyData.userId,\n\t          appointments: JSON.stringify(bodyData),\n\t        },\n\t      });\n\t      const session = await stripe.checkout.sessions.create({\n\t        line_items: [\n\t          {\n\t            price_data: {\n\t              currency: 'inr',\n\t              product_data: {\n", "                name: bodyData?.doctorName,\n\t                metadata: {\n\t                  id: bodyData.doctorId,\n\t                  appointments: JSON.stringify(bodyData),\n\t                },\n\t              },\n\t              unit_amount: bodyData.price * 100,\n\t            },\n\t            quantity: 1,\n\t          },\n", "        ],\n\t        customer: customer.id,\n\t        mode: 'payment',\n\t        success_url: `${process.env.CLIENT_URL}/success`,\n\t        cancel_url: `${process.env.CLIENT_URL}/failure`,\n\t      });\n\t      return res.status(200).send({ success: true, message: 'payment successful', url: session.url });\n\t    } catch (error) {\n\t      console.log(error);\n\t      return res.status(500).send({ success: false, message: 'Internal Server Error' });\n", "    }\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* Cancel Appointment\n\texport const cancelAppointment = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n", "    const appointment: any = await exportJs.APPOINTMENT.find({ _id: id });\n\t    if (!appointment) return res.status(200).send({ success: false, message: 'Appointment not found' });\n\t    await stripe.refunds.create({\n\t      payment_intent: appointment?.payment_intent,\n\t      amount: appointment?.price,\n\t    });\n\t    return res.status(200).send({ success: true, message: 'Appointment cancelled successfully' });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n", "  }\n\t};\n\t//* Check Available Timing\n\texport const checkAvailableTiming = async (req: Request, res: Response) => {\n\t  try {\n\t    const { date, doctorId } = req.body;\n\t    const response = await exportJs.APPOINTMENT.find({ date, doctorId }).select('time').exec();\n\t    return res.status(200).send({ success: true, message: 'Check Availability Successful', data: response });\n\t  } catch (error) {\n\t    console.log(error);\n", "    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* Report Doctor\n\texport const reportDoctor = async (req: Request, res: Response) => {\n\t  try {\n\t    const { userId, doctorId, reason } = req.body;\n\t    const newReport = await new exportJs.REPORT_DOCTOR({ userId, doctorId, reason });\n\t    await newReport.save();\n\t    return res.status(200).send({ success: true, message: 'doctor reported Successfully' });\n", "  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* feedback\n\texport const createFeedback = async (req: Request, res: Response) => {\n\t  try {\n\t    const { doctorId, userId, rating, feedback } = req.body;\n\t    const newFeedback = await new exportJs.FEEDBACK({\n", "      doctorId,\n\t      userId,\n\t      rating,\n\t      feedback,\n\t    });\n\t    await newFeedback.save();\n\t    return res.status(200).send({ success: true, message: 'Feedback added successfully' });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n", "  }\n\t};\n\texport const updateProfile = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    if (!id) return res.status(406).send({ success: false, message: 'Invalid token' });\n\t    const user: IUser | null = await exportJs.USER.findById(id);\n\t    if (!user) return res.status(404).send({ success: false, message: 'User not found' });\n\t    const { name, email } = req.body;\n\t    const data = {\n", "      name: name || user.name,\n\t      email: email || user.email,\n\t    };\n\t    await exportJs.USER.findByIdAndUpdate(id, data);\n\t    return res.status(200).send({ success: true, message: 'Update profile successful' });\n\t  } catch (error) {\n\t    console.error('Error in user controller: Update Profile :-', error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n", "export const getAppointment = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    const appointments = await exportJs.APPOINTMENT.find({ userId: id });\n\t    res.status(200).send({ success: true, message: 'get user appointments successful', data: appointments });\n\t  } catch (error) {\n\t    console.log('Error in get user Appointment', error);\n\t    res.status(500).send({ success: false, message: 'internal server error' });\n\t  }\n\t};\n"]}
{"filename": "src/controller/adminController.ts", "chunked_list": ["import { Request, Response } from 'express';\n\timport bcrypt from 'bcrypt';\n\timport jwt from 'jsonwebtoken';\n\timport dotenv from 'dotenv';\n\timport Stripe from 'stripe';\n\timport { v2 as cloudinary } from 'cloudinary';\n\timport { ADMIN, APPOINTMENT, BLOG, DEPARTMENT, DOCTOR, FEEDBACK, REPORT_DOCTOR, USER } from '../model/index.js';\n\timport { Ioptions } from '../Types/interface.js';\n\tdotenv.config();\n\t//* Initialize Cloudinary API\n", "cloudinary.config({\n\t  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n\t  api_key: process.env.CLOUDINARY_API_KEY,\n\t  api_secret: process.env.CLOUDINARY_API_SECRET,\n\t});\n\tconst stripe = new Stripe(process.env.STRIPE_SECRET, {\n\t  apiVersion: '2022-11-15',\n\t});\n\t/*\n\t *Admin Controllers\n", " */\n\t//* ADMIN-LOGIN\n\texport const login = async (req: Request, res: Response) => {\n\t  try {\n\t    //* validating email *\n\t    const user = await ADMIN.findOne({ email: req.body.email });\n\t    if (!user) {\n\t      // If no user returning error response with code 200\n\t      return res.status(200).send({ success: false, message: 'user does not exist', error: 'email' });\n\t    }\n", "    // comparing hashed password with bcrypt\n\t    const match = await bcrypt.compare(req.body.password, user.password);\n\t    if (!match) {\n\t      // If the password is incorrect returning error with code 200\n\t      return res.status(200).send({ success: false, message: \"password doesn't match\", error: 'password' });\n\t    }\n\t    // Credential verified\n\t    // Creating a JWT token\n\t    const token: string = jwt.sign({ id: user._id }, process.env.JWT_SECRET, {\n\t      expiresIn: '15d',\n", "    });\n\t    // Sending succes a succesful login response with token\n\t    return res.status(200).send({ success: true, message: 'login succesful', token });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).json({ success: false, message: 'internal server error' });\n\t  }\n\t};\n\t//* Add-Doctor\n\tinterface IUserReqBody {\n", "  firstName: string;\n\t  lastName: string;\n\t  email: string;\n\t  phone: string;\n\t  department: string;\n\t  dob: Date;\n\t  fees: string;\n\t  workTime: string;\n\t  photoURL: string;\n\t  password: string;\n", "  profile?: string;\n\t  address: string;\n\t}\n\texport const addDoctor = async (req: Request, res: Response) => {\n\t  try {\n\t    //* Destructuring Data from request body\n\t    const {\n\t      firstName,\n\t      fees,\n\t      workTime,\n", "      lastName,\n\t      email,\n\t      phone,\n\t      address,\n\t      department,\n\t      dob,\n\t      profile,\n\t      photoURL,\n\t    }: IUserReqBody = req.body;\n\t    const doctorExists = await DOCTOR.findOne({ email });\n", "    if (doctorExists) {\n\t      // if doctor already exists with same email returning error with response code 200\n\t      return res.status(200).send({ success: false, message: 'Doctor already exists' });\n\t    }\n\t    const doctor = {\n\t      firstName,\n\t      lastName,\n\t      email,\n\t      phone,\n\t      address,\n", "      profile,\n\t      department,\n\t      dob,\n\t      fees,\n\t      workTime,\n\t      password: await bcrypt.hash(req.body.password, 10),\n\t      photoURL,\n\t    };\n\t    // Adding New Doctor to Database\n\t    const newDoctor = new DOCTOR(doctor);\n", "    newDoctor.save();\n\t    return res.status(200).json({ success: true, message: 'Doctor added succesfully' });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).json({ success: false, message: 'internal server error' });\n\t  }\n\t};\n\t//* Get-All-Doctors\n\texport const getAllDoctors = async (req: Request, res: Response) => {\n\t  try {\n", "    const { page } = req.query;\n\t    const options: Ioptions = {\n\t      page: Number(page) || 1,\n\t      limit: 8,\n\t    };\n\t    const data = await DOCTOR.paginate({}, options);\n\t    res.status(200).send({ success: true, message: 'get All doctors succesfull', data });\n\t  } catch (error) {\n\t    console.error('Error in admin: Get-Doctors :-', error);\n\t    res.status(500).send({ success: false, message: 'Internal server error' });\n", "  }\n\t};\n\t//* Delete-doctors\n\texport const deleteDoctor = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    const doctor = await DOCTOR.findOne({ _id: id });\n\t    const result = await DOCTOR.deleteOne({ _id: id });\n\t    if (result.acknowledged) {\n\t      res.status(200).send({ success: true, message: `DR. ${doctor.firstName} deleted succesfully` });\n", "    }\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'internal server error' });\n\t  }\n\t};\n\t//* Add-Department\n\texport const addDepartment = async (req: Request, res: Response) => {\n\t  try {\n\t    //* Finding if the Department already exists or not\n", "    const { name } = req.body;\n\t    const deptExists = await DEPARTMENT.findOne({ name });\n\t    if (deptExists) {\n\t      //* if department exists returning error with code 200\n\t      return res.status(200).send({ success: false, message: 'Department already exists' });\n\t    }\n\t    //* Adding To Database\n\t    const newDept = new DEPARTMENT({ name });\n\t    const result = await newDept.save();\n\t    if (result) {\n", "      return res.status(200).send({ success: true, message: 'Department adding successful' });\n\t    }\n\t    return res.status(400).send({ success: false, message: 'Department adding failed' });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n\t};\n\t//* Add-Blog\n\texport const addBlog = async (req: Request, res: Response) => {\n", "  try {\n\t    console.log(req.body);\n\t    const blogData = {\n\t      title: req.body.title,\n\t      content: req.body.content,\n\t      imageURL: req.body.imageURL,\n\t    };\n\t    const blog = new BLOG(blogData);\n\t    await blog.save();\n\t    return res.status(200).send({ success: true, message: 'Blog adding successfull' });\n", "  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n\t};\n\t//* Get Single Blog\n\texport const getSingleBlog = async (req: Request, res: Response) => {\n\t  try {\n\t    const id = req.params?.id;\n\t    console.log(req.params?.id);\n", "    const blogData = await BLOG.findOne({ _id: id });\n\t    if (!blogData) return res.status(401).send({ success: false, message: 'no blog data found' });\n\t    return res.status(200).send({ success: true, message: 'Get Single Blog Successfull', data: blogData });\n\t  } catch (error) {\n\t    console.log(error);\n\t    return res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* edit blog\n\texport const editBlog = async (req: Request, res: Response) => {\n", "  try {\n\t    const { id }: { id?: string } = req.params;\n\t    const data = req.body;\n\t    const result = await BLOG.updateOne({ _id: id }, data);\n\t    if (result.acknowledged) res.status(200).send({ success: true, message: 'Edit Blog Successfull' });\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n\t};\n", "//* Delete Blog\n\texport const deleteBlog = async (req: Request, res: Response) => {\n\t  try {\n\t    const { id } = req.params;\n\t    const result = await BLOG.deleteOne({ _id: id });\n\t    if (result.acknowledged) {\n\t      res.status(200).send({ success: true, message: 'delete blog Successful' });\n\t    }\n\t  } catch (error) {\n\t    console.log(error);\n", "    res.status(500).send({ success: false, message: 'Internal server Error' });\n\t  }\n\t};\n\t//* Get-All-Users\n\texport const getAllUsers = async (req: Request, res: Response) => {\n\t  try {\n\t    const { page } = req.query;\n\t    const options: Ioptions = {\n\t      page: Number(page) || 1,\n\t      limit: 6,\n", "    };\n\t    const data = await USER.paginate({}, options);\n\t    res.status(200).send({ success: true, message: 'get all users succesfull', data });\n\t  } catch (error) {\n\t    console.log('Error in admin - Get All Users :-', error);\n\t    res.status(500).send({ success: false, message: 'Internal server error' });\n\t  }\n\t};\n\t//* Get Doctor reports\n\texport const getDoctorReports = async (req: Request, res: Response) => {\n", "  try {\n\t    const doctorReports = await REPORT_DOCTOR.find({});\n\t    res.status(200).send({ success: true, message: 'get doctor reports successfull', doctorReports });\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* Get User Feedbacks\n\texport const getUserFeedbacks = async (req: Request, res: Response) => {\n", "  try {\n\t    const feedbacks = await FEEDBACK.find({});\n\t    res.status(200).send({ success: true, message: 'Get Feedbacks Successfull', feedbacks });\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* Get Payments List\n\texport const getPaymentsList = async (req: Request, res: Response) => {\n", "  try {\n\t    const PAGE_SIZE = 8;\n\t    const options = {\n\t      limit: PAGE_SIZE,\n\t    };\n\t    let charges;\n\t    const { page } = req.query;\n\t    if (page === 'next' && req.query.lastPaymentId) {\n\t      //* To get the next page of charges\n\t      charges = await stripe.charges.list({\n", "        ...options,\n\t        starting_after: req.query.lastPaymentId as string,\n\t      });\n\t    } else if (page === 'prev' && req.query.firstPaymentId) {\n\t      //* To get the previous page of charges\n\t      charges = await stripe.charges.list({\n\t        ...options,\n\t        ending_before: req.query.firstPaymentId as string,\n\t      });\n\t    } else {\n", "      //* To get the first page of charges\n\t      charges = await stripe.charges.list(options);\n\t    }\n\t    res.status(200).send({ success: true, message: 'Get Payments Successful', payments: charges });\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* Get Payments refund List\n", "export const getPaymentsRefundList = async (req: Request, res: Response) => {\n\t  try {\n\t    const PAGE_SIZE = 3;\n\t    const options = {\n\t      limit: PAGE_SIZE,\n\t    };\n\t    let refunds;\n\t    const { page } = req.query;\n\t    if (page === 'next' && req.query.lastRefundId) {\n\t      //* To get the next page of refunds\n", "      refunds = await stripe.refunds.list({\n\t        ...options,\n\t        starting_after: req.query.lastRefundId as string,\n\t      });\n\t    } else if (page === 'prev' && req.query.firstRefundId) {\n\t      //* To get the previous page of refunds\n\t      refunds = await stripe.refunds.list({\n\t        ...options,\n\t        ending_before: req.query.firstRefundId as string,\n\t      });\n", "    } else {\n\t      //* To get the first page of refunds\n\t      refunds = await stripe.refunds.list(options);\n\t    }\n\t    res.status(200).send({ success: true, message: 'Get Refunds Successful', refunds });\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n", "//* get revenue\n\texport const getRevenue = async (req: Request, res: Response) => {\n\t  try {\n\t    const revenue = await APPOINTMENT.aggregate([\n\t      { $match: { cancelled: false } },\n\t      { $group: { _id: null, totalPrice: { $sum: { $toInt: '$price' } } } },\n\t    ]);\n\t    // get today's date\n\t    const today = new Date();\n\t    const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());\n", "    const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1);\n\t    // group appointments by date and sum up prices\n\t    const result = await APPOINTMENT.aggregate([\n\t      {\n\t        $match: {\n\t          date: { $gte: startOfDay, $lt: endOfDay },\n\t        },\n\t      },\n\t      {\n\t        $group: {\n", "          _id: '$date',\n\t          totalPrice: { $sum: { $toDouble: '$price' } },\n\t        },\n\t      },\n\t    ]);\n\t    res.status(200).send({ success: true, message: 'get revenue successfull', revenue: revenue[0].totalPrice });\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n", "};\n\t//* get number of appointment\n\texport const totalAppoinmtent = async (req: Request, res: Response) => {\n\t  try {\n\t    const maleCount: number = await APPOINTMENT.countDocuments({ gender: 'male' });\n\t    const femaleCount: number = await APPOINTMENT.countDocuments({ gender: 'female' });\n\t    const total: number = maleCount + femaleCount;\n\t    const data = {\n\t      maleCount,\n\t      femaleCount,\n", "      total,\n\t    };\n\t    res.status(200).send({ success: true, message: 'get revenue successfull', data });\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\t//* get number of doctors\n\texport const getTotalDoctors = async (req: Request, res: Response) => {\n", "  try {\n\t    const doctorsCount: number = await DOCTOR.countDocuments({}, {});\n\t    res.status(200).send({ success: true, message: 'get revenue successfull', doctorsCount });\n\t  } catch (error) {\n\t    console.log(error);\n\t    res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n\texport const getMonthlyRevenue = async (req: Request, res: Response) => {\n\t  try {\n", "    const result = await APPOINTMENT.aggregate([\n\t      {\n\t        $match: {\n\t          cancelled: false,\n\t        },\n\t      },\n\t      {\n\t        $group: {\n\t          _id: {\n\t            month: { $month: { $toDate: '$date' } },\n", "            year: { $year: { $toDate: '$date' } },\n\t          },\n\t          revenue: { $sum: { $toDouble: '$price' } },\n\t        },\n\t      },\n\t      {\n\t        $sort: {\n\t          '_id.year': 1,\n\t          '_id.month': 1,\n\t        },\n", "      },\n\t    ]);\n\t    const monthlyRevenueArray = Array(12).fill(0);\n\t    result.forEach((item) => {\n\t      const monthIndex = item._id.month - 1;\n\t      monthlyRevenueArray[monthIndex] = item.revenue;\n\t    });\n\t    return res.status(200).send({ success: true, message: 'get revenue successfull', data: monthlyRevenueArray });\n\t  } catch (error) {\n\t    console.error('Error:', error);\n", "    res.status(500).send({ success: false, message: 'Internal Server Error' });\n\t  }\n\t};\n"]}
{"filename": "src/router/message.ts", "chunked_list": ["import { Router } from 'express';\n\timport * as controller from '../controller/message.js';\n\tconst router = Router();\n\trouter.route('/').post(controller.newMessage);\n\trouter.route('/:id').get(controller.getMessage);\n\texport default router;\n"]}
{"filename": "src/router/conversation.ts", "chunked_list": ["import { Router } from 'express';\n\timport * as conversationController from '../controller/conversation.js';\n\tconst router = Router();\n\trouter.route('/').post(conversationController.newConversation);\n\trouter.route('/:id').get(conversationController.getConversation);\n\texport default router;\n"]}
{"filename": "src/router/doctor.ts", "chunked_list": ["import express from 'express';\n\timport * as controller from '../controller/doctorController.js';\n\timport auth from '../middlewares/auth.js';\n\tconst router = express.Router();\n\t//* login\n\trouter.route('/login').post(controller.login);\n\t//* appointments\n\trouter.route('/appointment/get-appointments/:id').get(auth, controller.getAppointments);\n\trouter.route('/appointment/cancel-appointment/:id').patch(controller.cancelAppointment);\n\t//* get data\n", "router.route('/get-doctor/:id').get(controller.getDoctor);\n\trouter.route('/edit-doctor/:id').patch(controller.editDoctor);\n\trouter.route('/patients/:id').get(controller.getPatients);\n\t//* Add Prescription\n\trouter.route('/add-prescription').post(controller.addPrescription);\n\t//* apply for Leave\n\trouter.route('/apply-leave').patch(controller.applyLeave);\n\trouter.route('/cancel-leave').patch(controller.cancelLeave);\n\t//* analytics\n\trouter.route('/get-total-revenue/:id').get(controller.getTotalRevenue);\n", "router.route('/get-monthly-revenue/:id').get(controller.getMontlyRevenue);\n\texport default router;\n"]}
{"filename": "src/router/admin.ts", "chunked_list": ["import express from 'express';\n\timport * as controller from '../controller/adminController.js';\n\t// import auth from '../middlewares/auth.js';\n\tconst router = express.Router();\n\t//* Login\n\trouter.route('/login').post(controller.login);\n\t//* User Management\n\trouter.route('/users/get-all-users').get(controller.getAllUsers);\n\t//* Doctors Management\n\trouter.route('/doctors/add-doctors').post(controller.addDoctor);\n", "router.route('/doctors/get-all-doctors').get(controller.getAllDoctors);\n\trouter.route('/doctors/add-new-department').post(controller.addDepartment);\n\trouter.route('/doctors/delete-doctor/:id').delete(controller.deleteDoctor);\n\t//* Blog Management\n\trouter.route('/blogs/add-blog').post(controller.addBlog);\n\trouter.route('/blogs/edit-blog/:id').get(controller.editBlog);\n\trouter.route('/blogs/get-single-blog/:id').get(controller.getSingleBlog);\n\trouter.route('/blogs/delete-blog/:id').delete(controller.deleteBlog);\n\t//* report / feedback\n\trouter.route('/get-doctor-reports').get(controller.getDoctorReports);\n", "router.route('/get-user-feedbacks').get(controller.getUserFeedbacks);\n\t//* Payments Data\n\trouter.route('/get-payments').get(controller.getPaymentsList);\n\trouter.route('/get-payment-refunds').get(controller.getPaymentsRefundList);\n\t//* analytics\n\trouter.route('/get-revenue').get(controller.getRevenue);\n\trouter.route('/get-total-appointments').get(controller.totalAppoinmtent);\n\trouter.route('/get-total-doctors').get(controller.getTotalDoctors);\n\trouter.route('/get-monthly-revenue').get(controller.getMonthlyRevenue);\n\texport default router;\n"]}
{"filename": "src/router/router.ts", "chunked_list": ["import express from 'express';\n\timport * as controller from '../controller/controllers.js';\n\tconst router = express.Router();\n\t//* blogs\n\trouter.route('/blogs/get-all-blogs').get(controller.getAllBlogs);\n\trouter.route('/blogs/get-blog/:id').get(controller.getBlogs)\n\trouter.route('/get-department').get(controller.getDepartments);\n\trouter.route('/get-doctors').get(controller.getAllDoctors);\n\trouter.route('/search-doctors').get(controller.searchDoctors);\n\texport default router;\n"]}
{"filename": "src/router/user.ts", "chunked_list": ["import express from 'express';\n\timport * as controller from '../controller/userController.js';\n\timport auth from '../middlewares/auth.js';\n\tconst router = express.Router();\n\t//* Signup Login\n\trouter.route('/signup').post(controller.signup);\n\trouter.route('/login').post(controller.login);\n\t//* get doctors\n\trouter.route('/get-user-info/:id').get(auth, controller.getUserInfo);\n\trouter.route('/doctors-by-department').get(auth, controller.getDoctorsbyDept);\n", "//* Payment\n\trouter.route('/payment').post(auth, controller.payment);\n\trouter.route('/webhook').post(auth, controller.webHooks);\n\t//* Appoinment\n\trouter.route('/appointment/cancel-appointment/:id').patch(auth, controller.cancelAppointment);\n\trouter.route('/check-available-timing').post(auth, controller.checkAvailableTiming);\n\trouter.route('/get-appointments/:id').get(auth, controller.getAppointment);\n\t//* report / feedback\n\trouter.route('/report-doctor').post(auth, controller.reportDoctor);\n\trouter.route('/feedback').post(auth, controller.createFeedback);\n", "//* update Profile\n\trouter.route('/update-profile').patch(auth, controller.updateProfile);\n\texport default router;\n"]}
