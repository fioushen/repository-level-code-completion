{"filename": "src/main.ts", "chunked_list": ["import './main.css';\n\timport Camera from './render/camera';\n\timport Input from './compute/input';\n\timport Lines from './render/lines';\n\timport Points from './render/points';\n\timport Renderer from './render/renderer';\n\timport Simulation from './compute/simulation';\n\timport { Cloth, Ropes } from './compute/generation';\n\tconst Main = (device: GPUDevice) => {\n\t  const dom = document.getElementById('app');\n", "  if (!dom) {\n\t    throw new Error(\"Couldn't get app DOM node\");\n\t  }\n\t  const camera = new Camera(device);\n\t  const renderer = new Renderer(camera, device);\n\t  const input = new Input(renderer.getCanvas());\n\t  const simulation = new Simulation(device);\n\t  dom.appendChild(renderer.getCanvas());\n\t  renderer.setAnimationLoop((command, delta) => (\n\t    simulation.compute(command, delta, input.getPointer(camera), camera.getZoom() * 0.02)\n", "  ));\n\t  renderer.setSize(window.innerWidth, window.innerHeight);\n\t  simulation.load(Cloth());\n\t  const lines = new Lines(camera, device, renderer.getFormat(), renderer.getSamples(), simulation);\n\t  renderer.add(lines);\n\t  const points = new Points(camera, device, renderer.getFormat(), renderer.getSamples(), simulation);\n\t  renderer.add(points);\n\t  input.setHotkeys({\n\t    1: () => simulation.load(Cloth()),\n\t    2: () => simulation.load(Cloth(false, true)),\n", "    3: () => simulation.load(Ropes()),\n\t    4: () => simulation.load(Cloth(true, false)),\n\t    5: () => simulation.load(Cloth(true, true)),\n\t    escape: () => simulation.reset(),\n\t    '?': () => document.getElementById('help')?.classList.toggle('hidden'), \n\t  });\n\t  window.addEventListener('drop', (e) => {\n\t    e.preventDefault();\n\t    const [file] = e.dataTransfer?.files || [];\n\t    if (file && file.type.indexOf('image/') === 0) {\n", "      points.setTexture(file);\n\t    }\n\t  });\n\t  window.addEventListener('resize', () => (\n\t    renderer.setSize(window.innerWidth, window.innerHeight)\n\t  ));\n\t  window.addEventListener('wheel', ({ deltaY }) => (\n\t    camera.setZoom(Math.min(Math.max(camera.getZoom() * (1 + deltaY * 0.001), 200), 400))\n\t  ));\n\t};\n", "const GPU = async () => {\n\t  if (!navigator.gpu) {\n\t    throw new Error(\"Couldn't load WebGPU\");\n\t  }\n\t  const adapter = await navigator.gpu.requestAdapter();\n\t  if (!adapter) {\n\t    throw new Error(\"Couldn't load WebGPU adapter\");\n\t  }\n\t  const device = await adapter.requestDevice();\n\t  if (!device) {\n", "    throw new Error(\"Couldn't load WebGPU device\");\n\t  }\n\t  return device;\n\t};\n\tconst prevent = (e: DragEvent | MouseEvent | TouchEvent) => e.preventDefault();\n\twindow.addEventListener('contextmenu', prevent);\n\twindow.addEventListener('dragenter', prevent);\n\twindow.addEventListener('dragover', prevent);\n\twindow.addEventListener('touchstart', prevent);\n\tGPU()\n", "  .then(Main)\n\t  .catch((e) => {\n\t    document.getElementById('error')!.innerText = e.message;\n\t    document.getElementById('support')!.classList.remove('hidden');\n\t  })\n\t  .finally(() => document.getElementById('loading')!.classList.add('hidden'));\n"]}
{"filename": "src/render/points.ts", "chunked_list": ["import Camera from './camera';\n\timport { Plane } from './geometry';\n\timport Simulation from '../compute/simulation';\n\tconst Vertex = /* wgsl */`\n\tstruct VertexInput {\n\t  @location(0) position: vec2<f32>,\n\t  @location(1) uv: vec2<f32>,\n\t  @location(2) iposition: vec2<f32>,\n\t  @location(3) isize: f32,\n\t  @location(4) iuv: vec2<f32>,\n", "}\n\tstruct VertexOutput {\n\t  @builtin(position) position: vec4<f32>,\n\t  @location(0) size: f32,\n\t  @location(1) uv: vec2<f32>,\n\t  @location(2) uv2: vec2<f32>,\n\t}\n\t@group(0) @binding(0) var<uniform> camera: mat4x4<f32>;\n\t@vertex\n\tfn main(vertex: VertexInput) -> VertexOutput {\n", "  var out: VertexOutput;\n\t  out.position = camera * vec4<f32>(vertex.position * vertex.isize + vertex.iposition, 0, 1);\n\t  out.size = vertex.isize;\n\t  out.uv = (vertex.uv - 0.5) * 2;\n\t  out.uv2 = vertex.iuv;\n\t  return out;\n\t}\n\t`;\n\tconst Fragment = /* wgsl */`\n\tstruct FragmentInput {\n", "  @location(0) size: f32,\n\t  @location(1) uv: vec2<f32>,\n\t  @location(2) uv2: vec2<f32>,\n\t}\n\t@group(0) @binding(1) var texture: texture_2d<f32>;\n\t@group(0) @binding(2) var textureSampler: sampler;\n\tfn linearTosRGB(linear: vec3<f32>) -> vec3<f32> {\n\t  if (all(linear <= vec3<f32>(0.0031308))) {\n\t    return linear * 12.92;\n\t  }\n", "  return (pow(abs(linear), vec3<f32>(1.0/2.4)) * 1.055) - vec3<f32>(0.055);\n\t}\n\t@fragment\n\tfn main(fragment: FragmentInput) -> @location(0) vec4<f32> {\n\t  let l = min(length(fragment.uv), 1);\n\t  var uv = fragment.uv2 + (fragment.uv / fragment.size / 33);\n\t  return vec4<f32>(linearTosRGB(\n\t    textureSample(texture, textureSampler, uv).xyz + smoothstep(0.5, 1, l) * 0.1\n\t  ), smoothstep(1, 0.8, l));\n\t}\n", "`;\n\tclass Points {\n\t  private readonly bindings: GPUBindGroup;\n\t  private readonly device: GPUDevice;\n\t  private readonly geometry: GPUBuffer;\n\t  private readonly pipeline: GPURenderPipeline;\n\t  private readonly simulation: Simulation;\n\t  private readonly texture: GPUTexture;\n\t  constructor(\n\t    camera: Camera,\n", "    device: GPUDevice,\n\t    format: GPUTextureFormat,\n\t    samples: number,\n\t    simulation: Simulation,\n\t  ) {\n\t    this.device = device;\n\t    this.geometry = Plane(device, 2, 2);\n\t    this.pipeline = device.createRenderPipeline({\n\t      layout: 'auto',\n\t      vertex: {\n", "        buffers: [\n\t          {\n\t            arrayStride: 4 * Float32Array.BYTES_PER_ELEMENT,\n\t            attributes: [\n\t              {\n\t                shaderLocation: 0,\n\t                offset: 0,\n\t                format: 'float32x2',\n\t              },\n\t              {\n", "                shaderLocation: 1,\n\t                offset: 2 * Float32Array.BYTES_PER_ELEMENT,\n\t                format: 'float32x2',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            arrayStride: 2 * Float32Array.BYTES_PER_ELEMENT,\n\t            stepMode: 'instance',\n\t            attributes: [\n", "              {\n\t                shaderLocation: 2,\n\t                offset: 0,\n\t                format: 'float32x2',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            arrayStride: 4 * Float32Array.BYTES_PER_ELEMENT,\n\t            stepMode: 'instance',\n", "            attributes: [\n\t              {\n\t                shaderLocation: 3,\n\t                offset: 1 * Float32Array.BYTES_PER_ELEMENT,\n\t                format: 'float32',\n\t              },\n\t              {\n\t                shaderLocation: 4,\n\t                offset: 2 * Float32Array.BYTES_PER_ELEMENT,\n\t                format: 'float32x2',\n", "              },\n\t            ],\n\t          },\n\t        ],\n\t        entryPoint: 'main',\n\t        module: device.createShaderModule({\n\t          code: Vertex,\n\t        }),\n\t      },\n\t      fragment: {\n", "        entryPoint: 'main',\n\t        module: device.createShaderModule({\n\t          code: Fragment,\n\t        }),\n\t        targets: [{\n\t          format,\n\t          blend: {\n\t            color: {\n\t              srcFactor: 'src-alpha',\n\t              dstFactor: 'one-minus-src-alpha',\n", "              operation: 'add',\n\t            },\n\t            alpha: {\n\t              srcFactor: 'src-alpha',\n\t              dstFactor: 'one-minus-src-alpha',\n\t              operation: 'add',\n\t            },\n\t          },\n\t        }],\n\t      },\n", "      primitive: {\n\t        topology: 'triangle-list',\n\t      },\n\t      multisample: {\n\t        count: samples,\n\t      },\n\t    });\n\t    this.texture = device.createTexture({\n\t      dimension: '2d',\n\t      format: 'rgba8unorm-srgb',\n", "      size: [512, 512],\n\t      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n\t    });\n\t    this.bindings = device.createBindGroup({\n\t      layout: this.pipeline.getBindGroupLayout(0),\n\t      entries: [\n\t        {\n\t          binding: 0,\n\t          resource: { buffer: camera.getBuffer() },\n\t        },\n", "        {\n\t          binding: 1,\n\t          resource: this.texture.createView(),\n\t        },\n\t        {\n\t          binding: 2,\n\t          resource: device.createSampler({ minFilter: 'linear', magFilter: 'linear' }),\n\t        },\n\t      ],\n\t    });\n", "    this.simulation = simulation;\n\t    this.generateDefaultTexture();\n\t  }\n\t  render(pass: GPURenderPassEncoder) {\n\t    const { bindings, geometry, pipeline, simulation } = this;\n\t    const { count, data, points } = simulation.getBuffers();\n\t    pass.setPipeline(pipeline);\n\t    pass.setBindGroup(0, bindings);\n\t    pass.setVertexBuffer(0, geometry);\n\t    pass.setVertexBuffer(1, points);\n", "    pass.setVertexBuffer(2, data);\n\t    pass.draw(6, count, 0, 0);\n\t  }\n\t  setTexture(file: Blob) {\n\t    const image = new Image();\n\t    image.addEventListener('load', () => {\n\t      const canvas = document.createElement('canvas');\n\t      const ctx = canvas.getContext('2d');\n\t      if (!ctx) {\n\t        throw new Error(\"Couldn't get 2d context\");\n", "      }\n\t      let x = 0;\n\t      let y = 0;\n\t      let w = canvas.width = 512;\n\t      let h = canvas.height = 512;\n\t      if (image.width / image.height > w / h) {\n\t        w = image.width * canvas.height / image.height;\n\t        x = (canvas.width - w) * 0.5;\n\t      } else {\n\t        h = image.height * canvas.width / image.width;\n", "        y = (canvas.height - h) * 0.5;\n\t      }\n\t      ctx.imageSmoothingEnabled = true;\n\t      ctx.imageSmoothingQuality = 'high';\n\t      ctx.drawImage(image, 0, 0, image.width, image.height, x, y, w, h);\n\t      this.updateTexture(canvas);\n\t    });\n\t    image.src = URL.createObjectURL(file);\n\t  }\n\t  private generateDefaultTexture() {\n", "    const canvas = document.createElement('canvas');\n\t    const ctx = canvas.getContext('2d');\n\t    if (!ctx) {\n\t      throw new Error(\"Couldn't get 2d context\");\n\t    }\n\t    canvas.width = canvas.height = 512;\n\t    for (let i = 0; i < 256; i++) {\n\t      ctx.fillStyle = `hsl(${360 * Math.random()},${20 + 40 * Math.random()}%,${20 + 40 * Math.random()}%)`;\n\t      ctx.beginPath();\n\t      ctx.arc(canvas.width * Math.random(), canvas.height * Math.random(), 16 + Math.random() * 64, 0, Math.PI * 2);\n", "      ctx.fill();\n\t    }\n\t    this.updateTexture(canvas);\n\t  }\n\t  private async updateTexture(canvas: HTMLCanvasElement) {\n\t    const { device, texture } = this;\n\t    const source = await createImageBitmap(canvas)\n\t    device.queue.copyExternalImageToTexture({ source, flipY: true }, { texture }, [512, 512]);\n\t  }\n\t}\n", "export default Points;\n"]}
{"filename": "src/render/renderer.ts", "chunked_list": ["import Camera from './camera';\n\tclass Renderer {\n\t  private readonly animation: {\n\t    clock: number;\n\t    loop: (command: GPUCommandEncoder, delta: number, time: number) => void;\n\t    request: number;\n\t  };\n\t  private readonly camera: Camera;\n\t  private readonly canvas: HTMLCanvasElement;\n\t  private readonly context: GPUCanvasContext;\n", "  private readonly descriptor: GPURenderPassDescriptor;\n\t  private readonly device: GPUDevice;\n\t  private readonly format: GPUTextureFormat;\n\t  private readonly objects: { render: (pass: GPURenderPassEncoder) => void }[];\n\t  private readonly samples: number = 4;\n\t  private target: GPUTexture = undefined as unknown as GPUTexture;\n\t  constructor(camera: Camera, device: GPUDevice) {\n\t    this.camera = camera;\n\t    this.canvas = document.createElement('canvas');\n\t    const context = this.canvas.getContext('webgpu');\n", "    if (!context) {\n\t      throw new Error(\"Couldn't get GPUCanvasContext\");\n\t    }\n\t    this.context = context;\n\t    this.format = navigator.gpu.getPreferredCanvasFormat();\n\t    this.context.configure({ alphaMode: 'opaque', device, format: this.format });\n\t    this.descriptor = {\n\t      colorAttachments: [\n\t        {\n\t          clearValue: { r: 0, g: 0, b: 0, a: 1 },\n", "          loadOp: 'clear',\n\t          storeOp: 'store',\n\t          view: undefined as unknown as GPUTextureView,\n\t        },\n\t      ],\n\t    };\n\t    this.device = device;\n\t    this.objects = [];\n\t    this.animate = this.animate.bind(this);\n\t    this.animation = {\n", "      clock: performance.now() / 1000,\n\t      loop: () => {},\n\t      request: requestAnimationFrame(this.animate),\n\t    };\n\t    this.visibilitychange = this.visibilitychange.bind(this);\n\t    document.addEventListener('visibilitychange', this.visibilitychange);\n\t  }\n\t  add(object: { render: (pass: GPURenderPassEncoder) => void }) {\n\t    this.objects.push(object);\n\t  }\n", "  getCanvas() {\n\t    return this.canvas;\n\t  }\n\t  getFormat() {\n\t    return this.format;\n\t  }\n\t  getSamples() {\n\t    return this.samples;\n\t  }\n\t  setAnimationLoop(loop: (command: GPUCommandEncoder, delta: number, time: number) => void) {\n", "    this.animation.loop = loop;\n\t  }\n\t  setSize(width: number, height: number) {\n\t    const {\n\t      camera,\n\t      canvas,\n\t      descriptor: { colorAttachments: [color] },\n\t      device,\n\t      format,\n\t      samples,\n", "      target,\n\t    } = this;\n\t    const pixelRatio = window.devicePixelRatio || 1;\n\t    const size = [Math.floor(width * pixelRatio), Math.floor(height * pixelRatio)];\n\t    canvas.width = size[0];\n\t    canvas.height = size[1];\n\t    canvas.style.width = `${width}px`;\n\t    canvas.style.height = `${height}px`;\n\t    camera.setAspect(width / height);\n\t    if (target) {\n", "      target.destroy();\n\t    }\n\t    this.target = device.createTexture({\n\t      format,\n\t      sampleCount: samples,\n\t      size,\n\t      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n\t    });\n\t    color!.view = this.target.createView();\n\t  }\n", "  private animate() {\n\t    const { animation, device } = this;\n\t    const time = performance.now() / 1000;\n\t    const delta = Math.min(time - animation.clock, 0.1);\n\t    animation.clock = time;\n\t    animation.request = requestAnimationFrame(this.animate);\n\t    const command = device.createCommandEncoder();\n\t    animation.loop(command, delta, time);\n\t    this.render(command);\n\t    device.queue.submit([command.finish()]);\n", "  }\n\t  private render(command: GPUCommandEncoder) {\n\t    const {\n\t      context,\n\t      descriptor,\n\t      objects,\n\t    } = this;\n\t    const { colorAttachments: [color] } = descriptor;\n\t    color!.resolveTarget = context.getCurrentTexture().createView();\n\t    const pass = command.beginRenderPass(descriptor);\n", "    objects.forEach((object) => object.render(pass));\n\t    pass.end();\n\t  }\n\t  private visibilitychange() {\n\t    const { animation } = this;\n\t    cancelAnimationFrame(animation.request);\n\t    if (document.visibilityState === 'visible') {\n\t      animation.clock = performance.now() / 1000;\n\t      animation.request = requestAnimationFrame(this.animate);\n\t    }\n", "  }\n\t}\n\texport default Renderer;\n"]}
{"filename": "src/render/geometry.ts", "chunked_list": ["export const Plane = (device: GPUDevice, width: number = 1, height: number = 1) => {\n\t  const buffer = device.createBuffer({\n\t    mappedAtCreation: true,\n\t    size: 24 * Float32Array.BYTES_PER_ELEMENT,\n\t    usage: GPUBufferUsage.VERTEX,\n\t  });\n\t  new Float32Array(buffer.getMappedRange()).set([\n\t    width * -0.5, height *  0.5,     0, 1,\n\t    width *  0.5, height *  0.5,     1, 1,\n\t    width *  0.5, height * -0.5,     1, 0,\n", "    width *  0.5, height * -0.5,     1, 0,\n\t    width * -0.5, height * -0.5,     0, 0,\n\t    width * -0.5, height *  0.5,     0, 1,\n\t  ]);\n\t  buffer.unmap();\n\t  return buffer;\n\t};\n"]}
{"filename": "src/render/lines.ts", "chunked_list": ["import Camera from './camera';\n\timport { Plane } from './geometry';\n\timport Simulation from '../compute/simulation';\n\tconst Vertex = /* wgsl */`\n\tstruct VertexInput {\n\t  @location(0) position: vec2<f32>,\n\t  @location(1) uv: vec2<f32>,\n\t  @location(2) iposition: vec2<f32>,\n\t  @location(3) irotation: f32,\n\t  @location(4) isize: f32,\n", "}\n\tstruct VertexOutput {\n\t  @builtin(position) position: vec4<f32>,\n\t}\n\t@group(0) @binding(0) var<uniform> camera: mat4x4<f32>;\n\tfn rotate(rad: f32) -> mat2x2<f32> {\n\t  var c: f32 = cos(rad);\n\t  var s: f32 = sin(rad);\n\t  return mat2x2<f32>(c, s, -s, c);\n\t}\n", "@vertex\n\tfn main(vertex: VertexInput) -> VertexOutput {\n\t  var out: VertexOutput;\n\t  out.position = camera * vec4<f32>(vertex.position * vec2<f32>(1, vertex.isize) * rotate(vertex.irotation) + vertex.iposition, 0, 1);\n\t  return out;\n\t}\n\t`;\n\tconst Fragment = /* wgsl */`\n\t@fragment\n\tfn main() -> @location(0) vec4<f32> {\n", "  return vec4<f32>(vec3(0.125), 1);\n\t}\n\t`;\n\tclass Lines {\n\t  private readonly bindings: GPUBindGroup;\n\t  private readonly geometry: GPUBuffer;\n\t  private readonly pipeline: GPURenderPipeline;\n\t  private readonly simulation: Simulation;\n\t  constructor(\n\t    camera: Camera,\n", "    device: GPUDevice,\n\t    format: GPUTextureFormat,\n\t    samples: number,\n\t    simulation: Simulation,\n\t  ) {\n\t    this.geometry = Plane(device);\n\t    this.pipeline = device.createRenderPipeline({\n\t      layout: 'auto',\n\t      vertex: {\n\t        buffers: [\n", "          {\n\t            arrayStride: 4 * Float32Array.BYTES_PER_ELEMENT,\n\t            attributes: [\n\t              {\n\t                shaderLocation: 0,\n\t                offset: 0,\n\t                format: 'float32x2',\n\t              },\n\t              {\n\t                shaderLocation: 1,\n", "                offset: 2 * Float32Array.BYTES_PER_ELEMENT,\n\t                format: 'float32x2',\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            arrayStride: 4 * Float32Array.BYTES_PER_ELEMENT,\n\t            stepMode: 'instance',\n\t            attributes: [\n\t              {\n", "                shaderLocation: 2,\n\t                offset: 0,\n\t                format: 'float32x2',\n\t              },\n\t              {\n\t                shaderLocation: 3,\n\t                offset: 2 * Float32Array.BYTES_PER_ELEMENT,\n\t                format: 'float32',\n\t              },\n\t              {\n", "                shaderLocation: 4,\n\t                offset: 3 * Float32Array.BYTES_PER_ELEMENT,\n\t                format: 'float32',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t        entryPoint: 'main',\n\t        module: device.createShaderModule({\n\t          code: Vertex,\n", "        }),\n\t      },\n\t      fragment: {\n\t        entryPoint: 'main',\n\t        module: device.createShaderModule({\n\t          code: Fragment,\n\t        }),\n\t        targets: [{ format }],\n\t      },\n\t      primitive: {\n", "        topology: 'triangle-list',\n\t      },\n\t      multisample: {\n\t        count: samples,\n\t      },\n\t    });\n\t    this.bindings = device.createBindGroup({\n\t      layout: this.pipeline.getBindGroupLayout(0),\n\t      entries: [\n\t        {\n", "          binding: 0,\n\t          resource: { buffer: camera.getBuffer() },\n\t        },\n\t      ],\n\t    });\n\t    this.simulation = simulation;\n\t  }\n\t  render(pass: GPURenderPassEncoder) {\n\t    const { bindings, geometry, pipeline, simulation } = this;\n\t    const { lines } = simulation.getBuffers();\n", "    pass.setPipeline(pipeline);\n\t    pass.setBindGroup(0, bindings);\n\t    pass.setVertexBuffer(0, geometry);\n\t    pass.setVertexBuffer(1, lines, 16);\n\t    pass.drawIndirect(lines, 0);\n\t  }\n\t}\n\texport default Lines;\n"]}
{"filename": "src/render/camera.ts", "chunked_list": ["import { mat4, vec2 } from 'gl-matrix';\n\tclass Camera {\n\t  private readonly device: GPUDevice;\n\t  private readonly buffer: GPUBuffer;\n\t  private aspect: number;\n\t  private near: number;\n\t  private far: number;\n\t  private zoom: number;\n\t  private readonly matrix: mat4;\n\t  private readonly matrixInverse: mat4;\n", "  private readonly position: vec2;\n\t  constructor(device: GPUDevice) {\n\t    this.aspect = 1;\n\t    this.near = -100;\n\t    this.far = 100;\n\t    this.zoom = 200;\n\t    this.position = vec2.create();\n\t    this.matrix = mat4.create();\n\t    this.matrixInverse = mat4.create();\n\t    this.device = device;\n", "    this.buffer = device.createBuffer({\n\t      size: (this.matrix as Float32Array).byteLength,\n\t      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n\t    });\n\t  }\n\t  getBuffer() {\n\t    return this.buffer;\n\t  }\n\t  getMatrixInverse() {\n\t    return this.matrixInverse;\n", "  }\n\t  getZoom() {\n\t    return this.zoom;\n\t  }\n\t  setAspect(aspect: number) {\n\t    this.aspect = aspect;\n\t    this.update();\n\t  }\n\t  setZoom(zoom: number) {\n\t    this.zoom = zoom;\n", "    this.update();\n\t  }\n\t  private update() {\n\t    const {\n\t      device, buffer,\n\t      matrix, matrixInverse,\n\t      aspect, near, far, zoom, position,\n\t    } = this;\n\t    const x = zoom * aspect * 0.5;\n\t    const y = zoom * 0.5;\n", "    mat4.ortho(\n\t      matrix,\n\t      position[0] - x, position[0] + x,\n\t      position[1] - y, position[1] + y,\n\t      near, far\n\t    );\n\t    mat4.invert(matrixInverse, matrix);\n\t    device.queue.writeBuffer(buffer, 0, matrix as Float32Array);\n\t  }\n\t}\n", "export default Camera;\n"]}
{"filename": "src/compute/input.ts", "chunked_list": ["import { vec2 } from 'gl-matrix';\n\timport Camera from '../render/camera';\n\tclass Input {\n\t  private hotkeys: Record<string, () => void> = {};\n\t  private readonly pointer: {\n\t    id: number;\n\t    button: number;\n\t    normalized: vec2;\n\t    position: vec2;\n\t  };\n", "  constructor(target: HTMLCanvasElement) {\n\t    this.pointer = {\n\t      id: -1,\n\t      button: 0,\n\t      normalized: vec2.fromValues(-1, -1),\n\t      position: vec2.create(),\n\t    };\n\t    window.addEventListener('keydown', this.onKeyDown.bind(this));\n\t    target.addEventListener('pointerdown', this.onPointerDown.bind(this));\n\t    window.addEventListener('pointermove', this.onPointerMove.bind(this));\n", "    target.addEventListener('pointerup', this.onPointerUp.bind(this));\n\t    {\n\t      const canvas = document.createElement('canvas');\n\t      const ctx = canvas.getContext('2d');\n\t      if (!ctx) {\n\t        throw new Error(\"Couldn't get 2d context\");\n\t      }\n\t      canvas.width = 20;\n\t      canvas.height = 20;\n\t      ctx.lineWidth = 5;\n", "      ctx.strokeStyle = '#111';\n\t      ctx.arc(canvas.width * 0.5, canvas.height * 0.5, 6, 0, Math.PI * 2);\n\t      ctx.stroke();\n\t      ctx.lineWidth = 3;\n\t      ctx.strokeStyle = '#eee';\n\t      ctx.stroke();\n\t      canvas.toBlob((blob) => {\n\t        if (blob) {\n\t          document.body.style.cursor = `url(${URL.createObjectURL(blob)}) 10 10, default`;\n\t        }\n", "      });\n\t    }\n\t  }\n\t  getPointer(camera: Camera) {\n\t    const { pointer } = this;\n\t    vec2.transformMat4(\n\t      pointer.position,\n\t      pointer.normalized,\n\t      camera.getMatrixInverse()\n\t    );\n", "    return pointer;\n\t  }\n\t  setHotkeys(hotkeys: Record<string, () => void>) {\n\t    this.hotkeys = hotkeys;\n\t  }\n\t  private onKeyDown({ key, repeat, target }: KeyboardEvent) {\n\t    const { hotkeys } = this;\n\t    const handler = hotkeys[key.toLowerCase()];\n\t    if (\n\t      handler\n", "      && !repeat\n\t      && !['input', 'textarea', 'select'].includes(\n\t        (target as HTMLElement).tagName.toLowerCase()\n\t      )\n\t    ) {\n\t      handler();\n\t    }\n\t  }\n\t  private onPointerDown({ buttons, pointerId, target }: PointerEvent) {\n\t    (target as HTMLCanvasElement).setPointerCapture(pointerId);\n", "    const { pointer } = this;\n\t    if (pointer.id !== -1) {\n\t      return;\n\t    }\n\t    pointer.id = pointerId;\n\t    pointer.button = buttons;\n\t  }\n\t  private onPointerMove({ pointerId, clientX, clientY }: PointerEvent) {\n\t    const { pointer } = this;\n\t    if (pointer.id !== -1 && pointer.id !== pointerId) {\n", "      return;\n\t    }\n\t    vec2.set(\n\t      pointer.normalized,\n\t      (clientX / window.innerWidth) * 2 - 1,\n\t      -(clientY / window.innerHeight) * 2 + 1\n\t    );\n\t  }\n\t  private onPointerUp({ pointerId, target }: PointerEvent) {\n\t    (target as HTMLCanvasElement).releasePointerCapture(pointerId);\n", "    const { pointer } = this;\n\t    if (pointer.id !== pointerId) {\n\t      return;\n\t    }\n\t    pointer.id = -1;\n\t    pointer.button = 0;\n\t  }\n\t}\n\texport default Input;\n"]}
{"filename": "src/compute/simulation/types.ts", "chunked_list": ["export const Data = /* wgsl */`\n\tstruct Data {\n\t  locked: u32,\n\t  size: f32,\n\t  uv: vec2<f32>,\n\t}\n\t`;\n\texport type Point = {\n\t  locked: boolean;\n\t  position: { x: number; y: number; };\n", "  size: number;\n\t  uv: { x: number, y: number };\n\t};\n\texport const PointBuffers = (values: Point[]) => {\n\t  const data = new ArrayBuffer(values.length * 16);\n\t  const points = new ArrayBuffer(values.length * 8);\n\t  values.forEach(({ locked, position, size, uv }, i) => {\n\t    const o = i * 16;\n\t    new Uint32Array(data, o, 1)[0] = locked ? 1 : 0;\n\t    new Float32Array(data, o + 4, 1)[0] = size;\n", "    new Float32Array(data, o + 8, 2).set([uv.x, uv.y]);\n\t    new Float32Array(points, i * 8, 2).set([position.x, position.y]);\n\t  });\n\t  return { data, points };\n\t};\n\texport const Joint = /* wgsl */`\n\tstruct Joint {\n\t  enabled: u32,\n\t  a: u32,\n\t  b: u32,\n", "  length: f32,\n\t}\n\t`;\n\texport type Joint = {\n\t  enabled: boolean;\n\t  a: number;\n\t  b: number;\n\t  length: number;\n\t};\n\texport const JointBuffer = (data: Joint[]) => {\n", "  const buffer = new ArrayBuffer(data.length * 16);\n\t  data.forEach(({ enabled, a, b, length }, i) => {\n\t    const o = i * 16;\n\t    new Uint32Array(buffer, o, 1)[0] = enabled ? 1 : 0;\n\t    new Uint32Array(buffer, o + 4, 1)[0] = a;\n\t    new Uint32Array(buffer, o + 8, 1)[0] = b;\n\t    new Float32Array(buffer, o + 12, 1)[0] = length;\n\t  });\n\t  return buffer;\n\t};\n", "export const Line = (atomicCount: boolean = false) => /* wgsl */`\n\tstruct Line {\n\t  position: vec2<f32>,\n\t  rotation: f32,\n\t  size: f32,\n\t}\n\tstruct Lines {\n\t  vertexCount: u32,\n\t  instanceCount: ${atomicCount ? 'atomic<u32>' : 'u32'},\n\t  firstVertex: u32,\n", "  firstInstance: u32,\n\t  data: array<Line>,\n\t}\n\t`;\n\texport const LineBuffer = (device: GPUDevice, numJoints: number) => {\n\t  const buffer = device.createBuffer({\n\t    mappedAtCreation: true,\n\t    size: 16 + numJoints * 16,\n\t    usage: (\n\t      GPUBufferUsage.COPY_DST\n", "      | GPUBufferUsage.INDIRECT\n\t      | GPUBufferUsage.STORAGE\n\t      | GPUBufferUsage.VERTEX\n\t    ),\n\t  });\n\t  new Uint32Array(buffer.getMappedRange(0, 4)).set(new Uint32Array([6]));\n\t  buffer.unmap();\n\t  return buffer;\n\t};\n\texport const Uniforms = /* wgsl */`\n", "struct Uniforms {\n\t  button: u32,\n\t  delta: f32,\n\t  pointer: vec2<f32>,\n\t  radius: f32,\n\t}\n\t`;\n\texport class UniformsBuffer {\n\t  private readonly buffers: {\n\t    cpu: ArrayBuffer,\n", "    gpu: GPUBuffer,\n\t  };\n\t  private readonly device: GPUDevice;\n\t  constructor(device: GPUDevice) {\n\t    const buffer = new ArrayBuffer(24);\n\t    this.buffers = {\n\t      cpu: buffer,\n\t      gpu: device.createBuffer({\n\t        size: buffer.byteLength,\n\t        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n", "      }),\n\t    };\n\t    this.device = device;\n\t  }\n\t  getBuffer() {\n\t    return this.buffers.gpu;\n\t  }\n\t  set button(value: number) {\n\t    new Uint32Array(this.buffers.cpu, 0, 1)[0] = value;\n\t  }\n", "  set delta(value: number) {\n\t    new Float32Array(this.buffers.cpu, 4, 1)[0] = value;\n\t  }\n\t  set pointer(value: [number, number] | Float32Array) {\n\t    new Float32Array(this.buffers.cpu, 8, 2).set(value);\n\t  }\n\t  set radius(value: number) {\n\t    new Float32Array(this.buffers.cpu, 16, 1)[0] = value;\n\t  }\n\t  update() {\n", "    this.device.queue.writeBuffer(this.buffers.gpu, 0, this.buffers.cpu);\n\t  }\n\t}\n"]}
{"filename": "src/compute/simulation/index.ts", "chunked_list": ["import ConstrainSimulation from './constrain';\n\timport ComputeLines from './lines';\n\timport StepSimulation from './step';\n\timport { LineBuffer, UniformsBuffer } from './types';\n\tclass Simulation {\n\t  private buffers?: {\n\t    data: GPUBuffer;\n\t    joints: GPUBuffer;\n\t    lines: GPUBuffer;\n\t    points: GPUBuffer[];\n", "  };\n\t  private count: number = 0;\n\t  private device: GPUDevice;\n\t  private initial?: {\n\t    joints: ArrayBuffer;\n\t    points: ArrayBuffer;\n\t  };\n\t  private pipelines?: {\n\t    constraint: ConstrainSimulation,\n\t    lines: ComputeLines,\n", "    step: StepSimulation,\n\t  };\n\t  private step: number = 0;\n\t  private readonly uniforms: UniformsBuffer;\n\t  constructor(device: GPUDevice) {\n\t    this.device = device;\n\t    this.uniforms = new UniformsBuffer(device);\n\t  }\n\t  compute(\n\t    command: GPUCommandEncoder,\n", "    delta: number,\n\t    pointer: { button: number; position: [number, number] | Float32Array; },\n\t    radius: number\n\t  ) {\n\t    const { buffers, pipelines, step, uniforms } = this;\n\t    if (!buffers || !pipelines) {\n\t      return;\n\t    }\n\t    uniforms.delta = delta;\n\t    uniforms.button = pointer.button;\n", "    uniforms.pointer = pointer.position;\n\t    uniforms.radius = radius;\n\t    uniforms.update();\n\t    const pass = command.beginComputePass();\n\t    pipelines.step.compute(pass, step);\n\t    this.step = (this.step + 1) % 2;\n\t    pipelines.constraint.compute(pass, this.step);\n\t    pipelines.lines.compute(pass, this.step);\n\t    pass.end();\n\t  }\n", "  getBuffers() {\n\t    const { buffers, count, step } = this;\n\t    if (!buffers) {\n\t      throw new Error(\"Simulation is not loaded\");\n\t    }\n\t    return {\n\t      count,\n\t      data: buffers.data,\n\t      lines: buffers.lines,\n\t      points: buffers.points[step],\n", "    };\n\t  }\n\t  load(\n\t    { data, joints, numJoints, points, numPoints }: {\n\t      data: ArrayBuffer;\n\t      joints: ArrayBuffer;\n\t      numJoints: number;\n\t      points: ArrayBuffer;\n\t      numPoints: number;\n\t    }\n", "  ) {\n\t    const { device } = this;\n\t    const createBuffer = (data: ArrayBuffer, usage: number) => {\n\t      const buffer = device.createBuffer({\n\t        mappedAtCreation: true,\n\t        size: data.byteLength,\n\t        usage,\n\t      });\n\t      new Uint32Array(buffer.getMappedRange()).set(new Uint32Array(data));\n\t      buffer.unmap();\n", "      return buffer;\n\t    };\n\t    if (this.buffers) {\n\t      this.buffers.data.destroy();\n\t      this.buffers.joints.destroy();\n\t      this.buffers.lines.destroy();\n\t      this.buffers.points.forEach((buffer) => buffer.destroy());\n\t    }\n\t    this.buffers = {\n\t      data: createBuffer(\n", "        data,\n\t        GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX\n\t      ),\n\t      joints: createBuffer(\n\t        joints,\n\t        GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE\n\t      ),\n\t      lines: LineBuffer(device, numJoints),\n\t      points: Array.from({ length: 2 }, () => createBuffer(\n\t        points,\n", "        GPUBufferUsage.COPY_DST\n\t        | GPUBufferUsage.STORAGE\n\t        | GPUBufferUsage.VERTEX\n\t      )),\n\t    };\n\t    this.count = numPoints;\n\t    this.initial = { joints, points };\n\t    this.pipelines = {\n\t      constraint: new ConstrainSimulation(\n\t        device,\n", "        this.buffers.data,\n\t        this.buffers.joints,\n\t        numJoints,\n\t        this.buffers.lines,\n\t        this.buffers.points,\n\t        numPoints\n\t      ),\n\t      lines: new ComputeLines(\n\t        device,\n\t        this.buffers.joints,\n", "        numJoints,\n\t        this.buffers.lines,\n\t        this.buffers.points,\n\t        numPoints,\n\t        this.uniforms.getBuffer()\n\t      ),\n\t      step: new StepSimulation(\n\t        device,\n\t        this.buffers.data,\n\t        this.buffers.points,\n", "        numPoints,\n\t        this.uniforms.getBuffer()\n\t      ),\n\t    };\n\t  }\n\t  reset() {\n\t    const { buffers, device, initial } = this;\n\t    if (!buffers || !initial) {\n\t      return;\n\t    }\n", "    device.queue.writeBuffer(buffers.joints, 0, initial.joints);\n\t    buffers.points.forEach((buffer) => (\n\t      device.queue.writeBuffer(buffer, 0, initial.points)\n\t    ));\n\t  }\n\t}\n\texport default Simulation;\n"]}
{"filename": "src/compute/simulation/step.ts", "chunked_list": ["import { Data, Uniforms } from './types';\n\tconst Compute = (numPoints: number) => /* wgsl */`\n\t${Data}\n\t${Uniforms}\n\t@group(0) @binding(0) var<storage, read> data: array<Data, ${numPoints}>;\n\t@group(0) @binding(1) var<uniform> uniforms: Uniforms;\n\t@group(1) @binding(0) var<storage, read> input: array<vec2<f32>, ${numPoints}>;\n\t@group(1) @binding(1) var<storage, read_write> output: array<vec2<f32>, ${numPoints}>;\n\t@compute @workgroup_size(256)\n\tfn main(@builtin(global_invocation_id) id: vec3<u32>) {\n", "  let index: u32 = id.x;\n\t  if (index >= ${numPoints}) {\n\t    return;\n\t  }\n\t  var point = input[index];\n\t  if (data[index].locked == 0) {\n\t    point += point - output[index];\n\t    point += vec2<f32>(0, -8) * uniforms.delta;\n\t    if (uniforms.button != 2) {\n\t      var d = point - uniforms.pointer;\n", "      if (length(d) < min(uniforms.radius * 4, 24)) {\n\t        point += d * uniforms.radius * uniforms.delta;\n\t      }\n\t    }\n\t  }\n\t  output[index] = point;\n\t}\n\t`;\n\tclass StepSimulation {\n\t  private readonly bindings: {\n", "    data: GPUBindGroup,\n\t    points: GPUBindGroup[],\n\t  };\n\t  private readonly pipeline: GPUComputePipeline;\n\t  private readonly workgroups: number;\n\t  constructor(\n\t    device: GPUDevice,\n\t    data: GPUBuffer,\n\t    points: GPUBuffer[],\n\t    numPoints: number,\n", "    uniforms: GPUBuffer\n\t  ) {\n\t    this.pipeline = device.createComputePipeline({\n\t      layout: 'auto',\n\t      compute: {\n\t        entryPoint: 'main',\n\t        module: device.createShaderModule({\n\t          code: Compute(numPoints),\n\t        }),\n\t      },\n", "    });\n\t    this.bindings = {\n\t      data: device.createBindGroup({\n\t        layout: this.pipeline.getBindGroupLayout(0),\n\t        entries: [\n\t          {\n\t            binding: 0,\n\t            resource: { buffer: data },\n\t          },\n\t          {\n", "            binding: 1,\n\t            resource: { buffer: uniforms },\n\t          },\n\t        ],\n\t      }),\n\t      points: points.map((buffer, i) => device.createBindGroup({\n\t        layout: this.pipeline.getBindGroupLayout(1),\n\t        entries: [\n\t          {\n\t            binding: 0,\n", "            resource: { buffer },\n\t          },\n\t          {\n\t            binding: 1,\n\t            resource: { buffer: points[(i + 1) % 2] },\n\t          },\n\t        ],\n\t      })),\n\t    };\n\t    this.workgroups = Math.ceil(numPoints / 256);\n", "  }\n\t  compute(pass: GPUComputePassEncoder, step: number) {\n\t    const { bindings, pipeline, workgroups } = this;\n\t    pass.setPipeline(pipeline);\n\t    pass.setBindGroup(0, bindings.data);\n\t    pass.setBindGroup(1, bindings.points[step]);\n\t    pass.dispatchWorkgroups(workgroups);\n\t  }\n\t}\n\texport default StepSimulation;\n"]}
{"filename": "src/compute/simulation/lines.ts", "chunked_list": ["import { Joint, Line, Uniforms } from './types';\n\tconst Compute = (numPoints: number, numJoints: number) => /* wgsl */`\n\t${Joint}\n\t${Line(true)}\n\t${Uniforms}\n\t@group(0) @binding(0) var<storage, read_write> joints: array<Joint, ${numJoints}>;\n\t@group(0) @binding(1) var<storage, read_write> lines: Lines;\n\t@group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\t@group(1) @binding(0) var<storage, read> points: array<vec2<f32>, ${numPoints}>;\n\tfn sdSegment(p: vec2<f32>, a: vec2<f32>, b: vec2<f32>) -> f32 {\n", "  var pa: vec2<f32> = p-a;\n\t  var ba: vec2<f32> = b-a;\n\t  var h: f32 = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\t  return length(pa - ba*h);\n\t}\n\t@compute @workgroup_size(256)\n\tfn main(@builtin(global_invocation_id) id: vec3<u32>) {\n\t  let index: u32 = id.x;\n\t  if (index >= ${numJoints}) {\n\t    return;\n", "  }\n\t  var joint = joints[index];\n\t  if (joint.enabled == 0) {\n\t    return;\n\t  }\n\t  if (uniforms.button == 2) {\n\t    if (\n\t      sdSegment(uniforms.pointer, points[joint.a], points[joint.b]) <= uniforms.radius * 0.25\n\t    ) {\n\t      joints[index].enabled = 0;\n", "      return;\n\t    }\n\t  }\n\t  var origin = (points[joint.a] + points[joint.b]) * 0.5;\n\t  var line = points[joint.a] - points[joint.b];\n\t  var direction = normalize(line);\n\t  var rotation = atan2(direction.x, direction.y);\n\t  var size = length(line);\n\t  var instance = atomicAdd(&lines.instanceCount, 1);\n\t  lines.data[instance].position = origin;\n", "  lines.data[instance].rotation = rotation;\n\t  lines.data[instance].size = size;\n\t}\n\t`;\n\tclass ComputeLines {\n\t  private readonly bindings: {\n\t    data: GPUBindGroup,\n\t    points: GPUBindGroup[],\n\t  };\n\t  private readonly pipeline: GPUComputePipeline;\n", "  private readonly workgroups: number;\n\t  constructor(\n\t    device: GPUDevice,\n\t    joints: GPUBuffer,\n\t    numJoints: number,\n\t    lines: GPUBuffer,\n\t    points: GPUBuffer[],\n\t    numPoints: number,\n\t    uniforms: GPUBuffer\n\t  ) {\n", "    this.pipeline = device.createComputePipeline({\n\t      layout: 'auto',\n\t      compute: {\n\t        entryPoint: 'main',\n\t        module: device.createShaderModule({\n\t          code: Compute(numPoints, numJoints),\n\t        }),\n\t      },\n\t    });\n\t    this.bindings = {\n", "      data: device.createBindGroup({\n\t        layout: this.pipeline.getBindGroupLayout(0),\n\t        entries: [\n\t          {\n\t            binding: 0,\n\t            resource: { buffer: joints },\n\t          },\n\t          {\n\t            binding: 1,\n\t            resource: { buffer: lines },\n", "          },\n\t          {\n\t            binding: 2,\n\t            resource: { buffer: uniforms },\n\t          },\n\t        ],\n\t      }),\n\t      points: points.map((buffer) => device.createBindGroup({\n\t        layout: this.pipeline.getBindGroupLayout(1),\n\t        entries: [\n", "          {\n\t            binding: 0,\n\t            resource: { buffer },\n\t          },\n\t        ],\n\t      })),\n\t    };\n\t    this.workgroups = Math.ceil(numJoints / 256);\n\t  }\n\t  compute(pass: GPUComputePassEncoder, step: number) {\n", "    const { bindings, pipeline, workgroups } = this;\n\t    pass.setPipeline(pipeline);\n\t    pass.setBindGroup(0, bindings.data);\n\t    pass.setBindGroup(1, bindings.points[step]);\n\t    pass.dispatchWorkgroups(workgroups);\n\t  }\n\t}\n\texport default ComputeLines;\n"]}
{"filename": "src/compute/simulation/constrain.ts", "chunked_list": ["import { Data, Joint, Line } from './types';\n\tconst Compute = (numIterations: number, numPoints: number, numJoints: number) => /* wgsl */`\n\t${Data}\n\t${Joint}\n\t${Line()}\n\t@group(0) @binding(0) var<storage, read> data: array<Data, ${numPoints}>;\n\t@group(0) @binding(1) var<storage, read> joints: array<Joint, ${numJoints}>;\n\t@group(0) @binding(2) var<storage, read_write> lines: Lines;\n\t@group(1) @binding(0) var<storage, read_write> points: array<vec2<f32>, ${numPoints}>;\n\t@compute @workgroup_size(1)\n", "fn main() {\n\t  lines.instanceCount = 0;\n\t  for (var j: u32 = 0; j < ${numIterations}; j++) {\n\t    for (var i: u32 = 0; i < ${numJoints}; i++) {\n\t      var joint = joints[i];\n\t      if (joint.enabled == 0) {\n\t        continue;\n\t      }\n\t      var origin = (points[joint.a] + points[joint.b]) * 0.5;\n\t      var edge = normalize(points[joint.a] - points[joint.b]) * joint.length * 0.5;\n", "      if (data[joint.a].locked == 0) {\n\t        points[joint.a] = origin + edge;\n\t      }\n\t      if (data[joint.b].locked == 0) {\n\t        points[joint.b] = origin - edge;\n\t      }\n\t    }\n\t  }\n\t}\n\t`;\n", "class ConstrainSimulation {\n\t  private readonly bindings: {\n\t    data: GPUBindGroup,\n\t    points: GPUBindGroup[],\n\t  };\n\t  private readonly pipeline: GPUComputePipeline;\n\t  constructor(\n\t    device: GPUDevice,\n\t    data: GPUBuffer,\n\t    joints: GPUBuffer,\n", "    numJoints: number,\n\t    lines: GPUBuffer,\n\t    points: GPUBuffer[],\n\t    numPoints: number\n\t  ) {\n\t    this.pipeline = device.createComputePipeline({\n\t      layout: 'auto',\n\t      compute: {\n\t        entryPoint: 'main',\n\t        module: device.createShaderModule({\n", "          code: Compute(4, numPoints, numJoints),\n\t        }),\n\t      },\n\t    });\n\t    this.bindings = {\n\t      data: device.createBindGroup({\n\t        layout: this.pipeline.getBindGroupLayout(0),\n\t        entries: [\n\t          {\n\t            binding: 0,\n", "            resource: { buffer: data },\n\t          },\n\t          {\n\t            binding: 1,\n\t            resource: { buffer: joints },\n\t          },\n\t          {\n\t            binding: 2,\n\t            resource: { buffer: lines },\n\t          },\n", "        ],\n\t      }),\n\t      points: points.map((buffer) => device.createBindGroup({\n\t        layout: this.pipeline.getBindGroupLayout(1),\n\t        entries: [\n\t          {\n\t            binding: 0,\n\t            resource: { buffer },\n\t          },\n\t        ],\n", "      })),\n\t    };\n\t  }\n\t  compute(pass: GPUComputePassEncoder, step: number) {\n\t    const { bindings, pipeline } = this;\n\t    pass.setPipeline(pipeline);\n\t    pass.setBindGroup(0, bindings.data);\n\t    pass.setBindGroup(1, bindings.points[step]);\n\t    pass.dispatchWorkgroups(1);\n\t  }\n", "}\n\texport default ConstrainSimulation;\n"]}
{"filename": "src/compute/generation/cloth.ts", "chunked_list": ["import { Joint, JointBuffer, Point, PointBuffers } from '../simulation/types';\n\texport default (large: boolean = false, tension: boolean = false) => {\n\t  const width = large ? 65 : 33;\n\t  const height = large ? 65 : 33;\n\t  const gap = 4;\n\t  const points: Point[] = [];\n\t  const joints: Joint[] = [];\n\t  for (let i = 0, y = 0; y < height; y++) {\n\t    for (let x = 0; x < width; x++, i++) {\n\t      points.push({\n", "        locked: tension ? (\n\t          ((y === 0 || y === height - 1) && (x % 8 === 0))\n\t          || ((x === 0 || x === width - 1) && (y % 8 === 0))\n\t        ) : (\n\t          y === height - 1 && (x % 8 === 0)\n\t        ),\n\t        position: {\n\t          x: (x - width * 0.5 + 0.5) * gap * 1.125 + gap * (Math.random() - 0.25) * 0.125,\n\t          y: (y - height * 0.5 + 0.5) * gap + gap * (Math.random() - 0.5) * 0.125 + height * gap * 0.2,\n\t        },\n", "        size: 1.5 + Math.random() * 0.5,\n\t        uv: {\n\t          x: (x + 0.5) / width,\n\t          y: (y + 0.5) / height,\n\t        },\n\t      });\n\t      if (x < width - 1) {\n\t        joints.push({\n\t          enabled: true,\n\t          a: i,\n", "          b: i + 1,\n\t          length: 0,\n\t        });\n\t      }\n\t      if (y > 0) {\n\t        joints.push({\n\t          enabled: true,\n\t          a: i,\n\t          b: i - width,\n\t          length: 0,\n", "        });\n\t      }\n\t    }\n\t  }\n\t  joints.forEach((joint) => {\n\t    const a = points[joint.a].position;\n\t    const b = points[joint.b].position;\n\t    joint.length = Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n\t  });\n\t  if (tension || large) {\n", "    points.forEach(({ position }) => {\n\t      if (tension) position.x *= 1.25;\n\t      position.y = (position.y - height * gap * 0.2) * 1.4;\n\t    });\n\t  }\n\t  return {\n\t    ...PointBuffers(points),\n\t    joints: JointBuffer(joints),\n\t    numJoints: joints.length,\n\t    numPoints: points.length,\n", "  };\n\t}\n"]}
{"filename": "src/compute/generation/index.ts", "chunked_list": ["export { default as Cloth } from './cloth';\n\texport { default as Ropes } from './ropes';\n"]}
{"filename": "src/compute/generation/ropes.ts", "chunked_list": ["import { Joint, JointBuffer, Point, PointBuffers } from '../simulation/types';\n\texport default () => {\n\t  const points: Point[] = [];\n\t  const joints: Joint[] = [];\n\t  const length = 33;\n\t  for (let j = 0, i = 0; j < 2; j++) {\n\t    let o = i;\n\t    let x = 64 * (j === 0 ? -1 : 1);\n\t    for (i = 0; i < length; i++) {\n\t      points.push({\n", "        locked: i === length - 1,\n\t        position: {\n\t          x,\n\t          y: i * 4 - 45,\n\t        },\n\t        size: 1.5 + Math.random() * 0.5,\n\t        uv: {\n\t          x: x / length,\n\t          y: (i + 0.5) / length,\n\t        },\n", "      });\n\t      if (i >= 3 && i < length - 1) {\n\t        joints.push({\n\t          enabled: true,\n\t          a: o + i,\n\t          b: o + i + 1,\n\t          length: 4,\n\t        });\n\t      }\n\t    }\n", "    points[o + 2].position.x -= 4;\n\t    points[o + 1].position.x += 4;\n\t    [\n\t      [3, 2],\n\t      [3, 1],\n\t      [2, 1],\n\t      [2, 0],\n\t      [1, 0],\n\t    ].forEach(([a, b]) => joints.push({\n\t      enabled: true,\n", "      a: o + a,\n\t      b: o + b,\n\t      length: 8,\n\t    }));\n\t  }\n\t  return {\n\t    ...PointBuffers(points),\n\t    joints: JointBuffer(joints),\n\t    numJoints: joints.length,\n\t    numPoints: points.length,\n", "  };\n\t}\n"]}
