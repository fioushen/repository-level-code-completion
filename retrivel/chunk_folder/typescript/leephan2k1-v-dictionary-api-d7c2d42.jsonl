{"filename": "src/index.ts", "chunked_list": ["import cors from \"cors\";\n\timport express from \"express\";\n\timport session from \"express-session\";\n\timport helmet from \"helmet\";\n\timport createError from \"http-errors\";\n\timport passport from \"passport\";\n\timport { PrismaSessionStore } from \"@quixo3/prisma-session-store\";\n\timport { prisma } from \"./utils/prismaClient\";\n\timport route from \"./router\";\n\timport connectDB from \"./utils/prismaClient\";\n", "import type { ErrorType } from \"./types\";\n\timport type { NextFunction, Request, Response } from \"express\";\n\timport(\"./middlewares/passport\");\n\timport(\"./middlewares/passportGoogleSSO\");\n\timport(\"./middlewares/passportFacebookSSO\");\n\tconst app = express();\n\tconst PORT = process.env.PORT || 5001;\n\tif (process.env.NODE_ENV === \"production\") {\n\t  app.set(\"trust proxy\", 1); // trust first proxy\n\t}\n", "app.use(\n\t  session({\n\t    secret: `${process.env.COOKIE_SECRET}`,\n\t    resave: true,\n\t    cookie: {\n\t      sameSite: process.env.NODE_ENV === \"production\" ? \"none\" : false,\n\t      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days (ms)\n\t      httpOnly: true,\n\t      secure: process.env.NODE_ENV === \"production\", //development can't serve https (SSL)\n\t    },\n", "    //@ts-ignore\n\t    //we need store session, because it will leak memory under most conditions if\n\t    //store on memory and the sever can down or break,...\n\t    store: new PrismaSessionStore(prisma, {\n\t      checkPeriod: 2 * 60 * 1000, // 2m (ms) => PrismaSessionStore will automatically remove expired sessions\n\t      dbRecordIdIsSessionId: true,\n\t      dbRecordIdFunction: undefined,\n\t    }),\n\t  })\n\t);\n", "app.use(cors({ credentials: true, origin: `${process.env.CLIENT_URL}` }));\n\tapp.use(helmet());\n\tapp.use(express.json());\n\t//passport middleware:\n\tapp.use(passport.initialize());\n\t// we don't need passport deserializeUser every route\n\t// just need for auth route\n\tapp.use((req, res, next) => {\n\t  if (req.url.match(\"/api/words\") || req.url.match(\"/api/service\")) {\n\t    console.log(\"run next\");\n", "    next();\n\t  } else {\n\t    console.log(\"handle cookie\");\n\t    passport.session()(req, res, next);\n\t  }\n\t});\n\t//db connection info\n\t(async function () {\n\t  await connectDB();\n\t})();\n", "//routers\n\troute(app);\n\tapp.get(\"/\", (req, res) => {\n\t  res.json({\n\t    message: \"🦄🌈✨👋🌎🌍🌏✨🌈🦄\",\n\t  });\n\t});\n\t//catch 404\n\tapp.use((req: Request, res: Response, next: NextFunction) => {\n\t  next(createError(404, \"404 Not Found!\"));\n", "});\n\t//error handler\n\tapp.use((err: ErrorType, req: Request, res: Response, next: NextFunction) => {\n\t  const error: ErrorType =\n\t    app.get(\"env\") === \"development\" ? err : ({} as ErrorType);\n\t  const status: number = err.status || 500;\n\t  console.log(\n\t    `${req.url} --- ${req.method} --- ${JSON.stringify({\n\t      message: error.message,\n\t    })}`\n", "  );\n\t  return res.status(status).json({\n\t    status,\n\t    message: error.message,\n\t  });\n\t});\n\tapp.listen(PORT, () =>\n\t  console.log(`🚀 Server ready at: http://localhost:${PORT}`)\n\t);\n"]}
{"filename": "src/libs/google.dictionary.ts", "chunked_list": ["import axios from \"axios\";\n\timport { translate } from \"@vitalets/google-translate-api\";\n\texport async function googleTranslate({\n\t  text,\n\t  target_language,\n\t  source_language,\n\t}: {\n\t  text: string;\n\t  target_language: string;\n\t  source_language: string;\n", "}) {\n\t  try {\n\t    const { text: textTranslated } = await translate(text, {\n\t      to: target_language,\n\t    });\n\t    return textTranslated;\n\t  } catch (error) {\n\t    try {\n\t      //fallback rate limit:\n\t      console.log(\"-- RATE LIMIT AND CALL RAPID API HOST FALLBACK --\");\n", "      const encodedParams = new URLSearchParams();\n\t      encodedParams.append(\"source_language\", source_language);\n\t      encodedParams.append(\"target_language\", target_language);\n\t      encodedParams.append(\"text\", text);\n\t      const options = {\n\t        method: \"POST\",\n\t        url: `${process.env.TRANSLATE_URL}`,\n\t        headers: {\n\t          \"content-type\": \"application/x-www-form-urlencoded\",\n\t          \"X-RapidAPI-Key\": `${process.env.RAPID_API_KEY}`,\n", "          \"X-RapidAPI-Host\": `${process.env.RAPID_API_HOST}`,\n\t        },\n\t        data: encodedParams,\n\t      };\n\t      const { data } = await axios.request(options);\n\t      return await data.data.translatedText;\n\t    } catch (error) {\n\t      console.error(\"GOOGLE TRANSLATE ERROR: \", error);\n\t    }\n\t  }\n", "}\n"]}
{"filename": "src/libs/oxford.dictionary.ts", "chunked_list": ["import { OXFORD_DICTIONARY_URL } from \"../configs\";\n\timport type { Language } from \"../types\";\n\timport axios from \"axios\";\n\timport { parse } from \"node-html-parser\";\n\texport async function getAudioOxford({ word }: { word: string }) {\n\t  let phonetics;\n\t  try {\n\t    const raw_phonetics = await (\n\t      await axios.get(`${OXFORD_DICTIONARY_URL}/definition/english/${word}`)\n\t    ).data;\n", "    const document = parse(raw_phonetics);\n\t    phonetics = document\n\t      .querySelectorAll(\".phonetics > div\")\n\t      ?.map((div, idx) => {\n\t        return {\n\t          phrase: div.querySelector(\".phon\")?.textContent,\n\t          author: `OxfordDictionary_${idx === 0 ? \"English\" : \"American\"}`,\n\t          url: div.querySelector(\".sound\")?.getAttribute(\"data-src-mp3\"),\n\t        };\n\t      });\n", "    return phonetics ? phonetics.slice(0, 2) : phonetics;\n\t  } catch (error) {\n\t    console.error(\"get audio oxford error: \", error);\n\t  }\n\t  return phonetics;\n\t}\n\texport async function translateOxford({ word }: { word: string }) {\n\t  try {\n\t    const rawData = await (\n\t      await axios.get(`${OXFORD_DICTIONARY_URL}/definition/english/${word}`)\n", "    ).data;\n\t    const document = parse(rawData);\n\t    const wordContent = document.querySelector(`#${word}_h_1`)?.textContent;\n\t    if (!wordContent) throw new Error();\n\t    const typesOfWord = document.querySelector(`span.pos`)?.textContent;\n\t    const senses = document.querySelectorAll(\"span.def\").map((span, index) => {\n\t      const examples = document\n\t        .querySelectorAll(`#${word}_sng_${index + 1} > ul > li`)\n\t        .map((li) => li?.textContent);\n\t      return { sense: span?.textContent, typeOfWord: typesOfWord, examples };\n", "    });\n\t    return {\n\t      wordContent,\n\t      typesOfWord: [typesOfWord],\n\t      senses,\n\t    };\n\t  } catch (error) {\n\t    console.log(\"translateOxford error: \", error);\n\t    return null;\n\t  }\n", "}\n"]}
{"filename": "src/libs/glosbe.dictionary.ts", "chunked_list": ["import axios from \"axios\";\n\timport { GLOSBE_URL, GLOSBE_TRANSLATOR_API } from \"../configs\";\n\timport type { Language } from \"../types\";\n\timport { parse } from \"node-html-parser\";\n\timport { normalizeString } from \"../utils/string\";\n\timport { translate } from \"@vitalets/google-translate-api\";\n\timport { googleTranslate } from \"./google.dictionary\";\n\texport async function getAudioGlosbe({\n\t  format,\n\t  word,\n", "}: {\n\t  format: Language;\n\t  word: string;\n\t}) {\n\t  let raw_phonetics;\n\t  let phonetics;\n\t  try {\n\t    raw_phonetics = await (\n\t      await axios.get(`${GLOSBE_URL}/api/audios/${format}/${word}`)\n\t    ).data;\n", "    phonetics = raw_phonetics?.phraseAudioCarrier?.audioEntries?.map(\n\t      (entry: any) => {\n\t        return {\n\t          phrase: entry.phrase,\n\t          author: entry.author.name,\n\t          url: `${GLOSBE_URL}/fb_aud/mp3/${entry.url.mp3}`,\n\t        };\n\t      }\n\t    );\n\t  } catch (error) {\n", "    console.error(\"get audio glosbe error: \", error);\n\t  }\n\t  return phonetics;\n\t}\n\texport async function translateWordGlosbe({\n\t  language_1,\n\t  language_2,\n\t  word,\n\t}: {\n\t  language_1: Language;\n", "  language_2: Language;\n\t  word: string;\n\t}) {\n\t  try {\n\t    const raw = await (\n\t      await axios.get(`${GLOSBE_URL}/${language_1}/${language_2}/${word}`)\n\t    ).data;\n\t    //@ts-ignore\n\t    const document = parse(raw);\n\t    const wordContent = document.querySelector(\"span.break-words\")?.textContent;\n", "    const typesOfWord = document\n\t      .querySelectorAll(\n\t        \"#phraseDetails_activator-0 > div.text-xl.text-gray-900.px-1.pb-1 > span.text-xxs.text-gray-500 > span\"\n\t      )\n\t      .map((e) => e?.textContent);\n\t    const senses = document\n\t      .querySelectorAll(\n\t        \"#dictionary-content > article > div > div > section.bg-white.px-1 > div.pl-1 > div > ul.pr-1 > li\"\n\t      )\n\t      .map((li) => {\n", "        const sense = li.querySelector(\"h3\")?.textContent;\n\t        const typeOfWord = li.querySelector(\n\t          \"span.text-xxs.text-gray-500 > span\"\n\t        )?.textContent;\n\t        const topic = li.querySelector(\"div.py-1 > p > span\");\n\t        // check if word has example or not:\n\t        const example = li.querySelector(\"div > p.dir-aware-pr-1\")\n\t          ? {\n\t              [language_1]: normalizeString(\n\t                String(li.querySelector(\"div > p.dir-aware-pr-1\")?.textContent)\n", "              ),\n\t              [language_2]: normalizeString(\n\t                String(li.querySelector(\"div > p.px-1.ml-2\")?.textContent)\n\t              ),\n\t            }\n\t          : undefined;\n\t        return {\n\t          sense,\n\t          typeOfWord,\n\t          category: topic ? normalizeString(String(topic).trim()) : undefined,\n", "          example,\n\t        };\n\t      });\n\t    const less_frequent_senses = document\n\t      .querySelectorAll(\n\t        \"#less-frequent-translations-container-0 > li > div:nth-child(2) > ul > li\"\n\t      )\n\t      .map((li) => li?.textContent);\n\t    const similar_phrases = document\n\t      .querySelectorAll(\"#simmilar-phrases > ul > li\")\n", "      .map((li) => {\n\t        return {\n\t          [language_1]: li.querySelector(\"a\")?.textContent,\n\t          [language_2]: normalizeString(\n\t            String(li.querySelector(\".dir-aware-pl-2\")?.textContent)\n\t          ),\n\t        };\n\t      });\n\t    const examples = document\n\t      .querySelectorAll(\n", "        \"#tmem_first_examples > div.px-1.text-sm.text-gray-900.break-words > div > div.py-2.flex\"\n\t      )\n\t      .map((div) => {\n\t        return {\n\t          [language_1]: normalizeString(\n\t            String(div.querySelector(\"div:nth-child(1)\")?.textContent)\n\t          ),\n\t          [`keyword_${language_1}`]: div.querySelector(\n\t            \"div:nth-child(1) .keyword\"\n\t          )\n", "            ? normalizeString(\n\t                String(\n\t                  div.querySelector(\"div:nth-child(1) .keyword\")?.textContent\n\t                )\n\t              )\n\t            : undefined,\n\t          [language_2]: normalizeString(\n\t            String(div.querySelector(\"div:nth-child(2)\")?.textContent)\n\t          ),\n\t          [`keyword_${language_2}`]: div.querySelector(\n", "            \"div:nth-child(2) .keyword\"\n\t          )\n\t            ? normalizeString(\n\t                String(\n\t                  div.querySelector(\"div:nth-child(2) .keyword\")?.textContent\n\t                )\n\t              )\n\t            : undefined,\n\t        };\n\t      });\n", "    if (typesOfWord && wordContent && senses) {\n\t      return {\n\t        wordContent,\n\t        typesOfWord,\n\t        senses,\n\t        less_frequent_senses,\n\t        similar_phrases,\n\t        examples,\n\t      };\n\t    } else {\n", "      return null;\n\t    }\n\t  } catch (error) {\n\t    console.log(\"glosbe translate error: \", error);\n\t    return null;\n\t  }\n\t}\n\texport async function machineTranslation({\n\t  language_1,\n\t  language_2,\n", "  word,\n\t}: {\n\t  language_1: Language;\n\t  language_2: Language;\n\t  word: string;\n\t}) {\n\t  try {\n\t    const [google] = await Promise.allSettled([\n\t      // (\n\t      //   await axios.post(\n", "      //     `${GLOSBE_TRANSLATOR_API}/translateByLangWithScore?sourceLang=${language_1}&targetLang=${language_2}`,\n\t      //     word,\n\t      //     {\n\t      //       headers: {\n\t      //         \"Content-Type\": \"text/plain;charset=UTF-8\",\n\t      //       },\n\t      //     }\n\t      //   )\n\t      // ).data,\n\t      await googleTranslate({\n", "        text: word,\n\t        source_language: language_1,\n\t        target_language: language_2,\n\t      }),\n\t    ]);\n\t    if (google.status === \"fulfilled\") {\n\t      return { google: google.value };\n\t    } else {\n\t      return null;\n\t    }\n", "  } catch (error) {\n\t    console.error(\"machineTranslation error: \", error);\n\t    return null;\n\t  }\n\t}\n\texport async function getGrammarGlosbe({ word }: { word: string }) {\n\t  // https://vi.glosbe.com/en/vi/straightforward/fragment/details?phraseIndex=0&translationIndex=-1\n\t  try {\n\t    const rawData = await (\n\t      await axios.get(\n", "        `${GLOSBE_URL}/en/vi/${word}/fragment/details?phraseIndex=0&translationIndex=-1`\n\t      )\n\t    ).data;\n\t    const document = parse(rawData);\n\t    const grammars = document\n\t      .querySelectorAll(\"#grammar_0_-1 > ul > li\")\n\t      .map((li) => {\n\t        return li?.textContent;\n\t      });\n\t    return grammars;\n", "  } catch (error) {\n\t    console.log(\"getGrammarGlosbe error: \", error);\n\t    return null;\n\t  }\n\t}\n"]}
{"filename": "src/libs/index.ts", "chunked_list": ["import {\n\t  getAudioGlosbe,\n\t  translateWordGlosbe,\n\t  machineTranslation,\n\t  getGrammarGlosbe,\n\t} from \"./glosbe.dictionary\";\n\timport { getAudioOxford, translateOxford } from \"./oxford.dictionary\";\n\timport { getAudioCambridge, translateCambridge } from \"./cambridge.dictionary\";\n\texport {\n\t  getAudioGlosbe,\n", "  getAudioOxford,\n\t  getAudioCambridge,\n\t  translateWordGlosbe,\n\t  machineTranslation,\n\t  translateOxford,\n\t  translateCambridge,\n\t  getGrammarGlosbe,\n\t};\n"]}
{"filename": "src/libs/cambridge.dictionary.ts", "chunked_list": ["import { CAMBRIDGE_DICTIONARY_URL } from \"../configs\";\n\timport { parse } from \"node-html-parser\";\n\timport axios from \"axios\";\n\timport { normalizeString } from \"../utils/string\";\n\texport async function getAudioCambridge({ word }: { word: string }) {\n\t  let raw_phonetics;\n\t  let phonetics;\n\t  try {\n\t    raw_phonetics = await (\n\t      await axios.get(\n", "        `${CAMBRIDGE_DICTIONARY_URL}/vi/dictionary/english/${word}`\n\t      )\n\t    ).data;\n\t    const document = parse(raw_phonetics);\n\t    const uk_audio =\n\t      String(CAMBRIDGE_DICTIONARY_URL) +\n\t      document.querySelector(\"#audio1 source\")?.getAttribute(\"src\");\n\t    const uk_phonetic = document.querySelector(\n\t      \"#page-content > div.page > div:nth-child(1) > div.link > div > div.di-body > div > div > div:nth-child(1) > div.pos-header.dpos-h > span.uk.dpron-i > span.pron.dpron\"\n\t    )?.textContent;\n", "    const raw_us_audio = document\n\t      .querySelector(\"#audio2 source\")\n\t      ?.getAttribute(\"src\");\n\t    if (!raw_us_audio) return null;\n\t    const us_audio = String(CAMBRIDGE_DICTIONARY_URL) + raw_us_audio;\n\t    const us_phonetic = document.querySelector(\n\t      \"#page-content > div.page > div:nth-child(1) > div.link > div > div.di-body > div > div > div:nth-child(1) > div.pos-header.dpos-h > span.us.dpron-i > span.pron.dpron\"\n\t    )?.textContent;\n\t    phonetics = [\n\t      { phrase: uk_phonetic, author: \"Cambridge_English\", url: uk_audio },\n", "      { phrase: us_phonetic, author: \"Cambridge_American\", url: us_audio },\n\t    ];\n\t  } catch (error) {\n\t    console.error(\"get audio cambridge error: \", error);\n\t  }\n\t  return phonetics;\n\t}\n\texport async function translateCambridge({ word }: { word: string }) {\n\t  try {\n\t    const rawData = await (\n", "      await axios.get(\n\t        `${CAMBRIDGE_DICTIONARY_URL}/vi/dictionary/english/${word}`\n\t      )\n\t    ).data;\n\t    const document = parse(rawData);\n\t    const wordContent = document.querySelector(\n\t      \"#page-content > div.page > div:nth-child(1) > div.link > div > div.di-body > div > div > div:nth-child(1) > div.pos-header.dpos-h > div.di-title > span > span\"\n\t    )?.textContent;\n\t    if (!wordContent) throw new Error();\n\t    const typesOfWord = document\n", "      .querySelectorAll(\".pr.entry-body__el .pos.dpos\")\n\t      .map((span) => span?.textContent);\n\t    const senses = document\n\t      .querySelectorAll(\".pr.entry-body__el\")\n\t      .map((container) => {\n\t        const typeOfWord = container.querySelector(\".pos.dpos\")?.textContent;\n\t        const sense = container.querySelector(\".def.ddef_d.db\")?.textContent;\n\t        const examples = container\n\t          .querySelectorAll(\".examp.dexamp\")\n\t          .map((div) => {\n", "            return normalizeString(String(div?.textContent));\n\t          });\n\t        return { typeOfWord, sense, examples };\n\t      });\n\t    return { wordContent, typesOfWord: [...new Set(typesOfWord)], senses };\n\t  } catch (error) {\n\t    console.log(\"translateCambridge error \", error);\n\t    return null;\n\t  }\n\t}\n"]}
{"filename": "src/configs/index.ts", "chunked_list": ["import dotenv from \"dotenv\";\n\tdotenv.config();\n\texport const GLOSBE_API = process.env.GLOSBE_API;\n\texport const GLOSBE_URL = process.env.GLOSBE_URL;\n\texport const GLOSBE_TRANSLATOR_API = process.env.GLOSBE_TRANSLATOR_API;\n\texport const OXFORD_DICTIONARY_URL = process.env.OXFORD_DICTIONARY_URL;\n\texport const CAMBRIDGE_DICTIONARY_URL = process.env.CAMBRIDGE_DICTIONARY_URL;\n"]}
{"filename": "src/schemas/index.ts", "chunked_list": ["import { z } from \"zod\";\n\texport const TranslationHistorySchema = z.object({\n\t  body: z.object({\n\t    translations_history: z\n\t      .array(\n\t        z.object({\n\t          word: z.string(),\n\t          sense: z.string(),\n\t          targetLanguage: z.string(),\n\t          currentLanguage: z.string(),\n", "        })\n\t      )\n\t      .optional(),\n\t    word: z.string({\n\t      required_error: \"word is required\",\n\t    }),\n\t    sense: z.string({\n\t      required_error: \"sense is required\",\n\t    }),\n\t    targetLanguage: z.string({\n", "      required_error: \"targetLanguage is required\",\n\t    }),\n\t    currentLanguage: z.string({\n\t      required_error: \"currentLanguage is required\",\n\t    }),\n\t  }),\n\t});\n\texport const DeleteTranslationHistorySchema = z.object({\n\t  body: z.object({\n\t    word: z.string({\n", "      required_error: \"word is required\",\n\t    }),\n\t    deleteOption: z.string().optional(),\n\t  }),\n\t});\n\texport const FavoriteBodySchema = z.object({\n\t  body: z.object({\n\t    word: z.string({ required_error: \"word is required\" }),\n\t    tag: z.string().optional(),\n\t    numberOfDaysToForget: z.number().optional(),\n", "  }),\n\t});\n\texport const FavoriteQuerySchema = z.object({\n\t  query: z.object({\n\t    word: z.string({ required_error: \"word is required\" }),\n\t  }),\n\t});\n\texport const DashboardQuerySchema = z.object({\n\t  query: z.object({\n\t    status: z.string({ required_error: \"status is required\" }),\n", "  }),\n\t});\n\texport const WordPreviewQuerySchema = z.object({\n\t  query: z.object({\n\t    status: z.string({ required_error: \"status is required\" }),\n\t  }),\n\t});\n\texport const PracticeQuerySchema = z.object({\n\t  query: z.object({\n\t    status: z.string({ required_error: \"status is required\" }),\n", "    tags: z.string({ required_error: \"tags is required\" }),\n\t  }),\n\t});\n\texport const PracticePatchSchema = z.object({\n\t  body: z.object({\n\t    wordContent: z.string({ required_error: \"wordContent is required\" }),\n\t    status: z.string({ required_error: \"status is required\" }),\n\t  }),\n\t});\n"]}
{"filename": "src/utils/prismaClient.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\n\texport const prisma = new PrismaClient();\n\tasync function connectDB() {\n\t  try {\n\t    await prisma.$connect();\n\t    console.log(\"🚀 Database connected successfully\");\n\t  } catch (error) {\n\t    console.log(error);\n\t    process.exit(1);\n\t  } finally {\n", "    await prisma.$disconnect();\n\t  }\n\t}\n\texport default connectDB;\n"]}
{"filename": "src/utils/string.ts", "chunked_list": ["export const normalizeString = (str: string) => {\n\t  const htmlTagsRegex = /(&nbsp;|<([^>]+)>)/g;\n\t  return str\n\t    .trim()\n\t    .replace(/(\\r\\n|\\n|\\r|\\\")/gm, \"\")\n\t    .replace(htmlTagsRegex, \"\");\n\t};\n"]}
{"filename": "src/utils/dbHelper.ts", "chunked_list": ["//@ts-nocheck\n\timport { prisma } from \"./prismaClient\";\n\t// prisma can not nested create in createMany, LMAO:\n\t// https://github.com/prisma/prisma/issues/5455\n\texport async function createManySense(senses, wordId) {\n\t  await prisma.$transaction(\n\t    senses.map((e) => {\n\t      return prisma.sense.create({\n\t        data: {\n\t          sense: e.sense,\n", "          category: e?.category ? e?.category : undefined,\n\t          example: e?.example\n\t            ? { create: { en: e.example.en, vi: e.example.vi } }\n\t            : undefined,\n\t          typeOfWord: e?.typeOfWord\n\t            ? {\n\t                connectOrCreate: {\n\t                  create: { type: e.typeOfWord },\n\t                  where: { type: e.typeOfWord },\n\t                },\n", "              }\n\t            : undefined,\n\t          Word: {\n\t            connect: { id: wordId },\n\t          },\n\t        },\n\t      });\n\t    })\n\t  );\n\t}\n", "export async function connectTypeOfWord(typesOfWord, word) {\n\t  await prisma.$transaction(\n\t    typesOfWord.map((type) => {\n\t      return prisma.word.update({\n\t        where: { wordContent: word },\n\t        data: {\n\t          typesOfWord: { connect: { type } },\n\t        },\n\t      });\n\t    })\n", "  );\n\t}\n"]}
{"filename": "src/utils/getAudio.ts", "chunked_list": ["import { getAudioGlosbe, getAudioOxford, getAudioCambridge } from \"../libs\";\n\timport type { Source } from \"../types\";\n\texport async function getAudioInfo({\n\t  word,\n\t  format,\n\t  source,\n\t}: {\n\t  word: string;\n\t  format: \"en\" | \"vi\";\n\t  source: Source;\n", "}) {\n\t  switch (source) {\n\t    case \"glosbe\":\n\t      return await getAudioGlosbe({ format, word });\n\t    case \"oxford\":\n\t      return await getAudioOxford({ word });\n\t    case \"cambridge\":\n\t      return await getAudioCambridge({ word });\n\t  }\n\t}\n"]}
{"filename": "src/constants/index.ts", "chunked_list": []}
{"filename": "src/middlewares/zodValidate.ts", "chunked_list": ["import { NextFunction, Request, Response } from \"express\";\n\timport { AnyZodObject } from \"zod\";\n\texport const validate =\n\t  (schema: AnyZodObject) =>\n\t  async (req: Request, res: Response, next: NextFunction) => {\n\t    try {\n\t      await schema.parseAsync({\n\t        body: req.body,\n\t        query: req.query,\n\t        params: req.params,\n", "      });\n\t      return next();\n\t    } catch (error) {\n\t      return res.status(400).json(error);\n\t    }\n\t  };\n"]}
{"filename": "src/middlewares/passportFacebookSSO.ts", "chunked_list": ["//@ts-nocheck\n\timport passport from \"passport\";\n\timport passportFacebook from \"passport-facebook\";\n\timport { prisma } from \"../utils/prismaClient\";\n\tconst FacebookStrategy = passportFacebook.Strategy;\n\tpassport.use(\n\t  new FacebookStrategy(\n\t    {\n\t      clientID: `${process.env.FACEBOOK_APP_ID}`,\n\t      clientSecret: `${process.env.FACEBOOK_APP_SECRET}`,\n", "      callbackURL: process.env.FACEBOOK_CALLBACK_URL,\n\t      profileFields: [\"id\", \"displayName\", \"photos\", \"email\"],\n\t    },\n\t    async (accessToken, refreshToken, profile, cb) => {\n\t      try {\n\t        const user = await prisma.user.upsert({\n\t          where: { accountId: profile.id },\n\t          create: {\n\t            name: `${profile.displayName}`,\n\t            email: profile.emails[0].value,\n", "            image: profile.photos[0].value,\n\t            accountId: profile.id,\n\t            provider: \"facebook\",\n\t          },\n\t          update: {},\n\t        });\n\t        if (user) return cb(null, user);\n\t      } catch (err) {\n\t        console.log(\"Error signing up\", err);\n\t        cb(err, null);\n", "      }\n\t    }\n\t  )\n\t);\n"]}
{"filename": "src/middlewares/auth.ts", "chunked_list": ["import type { NextFunction, Request, Response } from \"express\";\n\texport function isUserAuthenticated(\n\t  req: Request,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  if (req.user) {\n\t    next();\n\t  } else {\n\t    res.status(403).send(\"You must login first!\");\n", "  }\n\t}\n"]}
{"filename": "src/middlewares/passport.ts", "chunked_list": ["import passport from \"passport\";\n\timport passportJwt from \"passport-jwt\";\n\timport { prisma } from \"../utils/prismaClient\";\n\tconst ExtractJwt = passportJwt.ExtractJwt;\n\tconst StrategyJwt = passportJwt.Strategy;\n\tpassport.use(\n\t  new StrategyJwt(\n\t    {\n\t      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n\t      secretOrKey: process.env.JWT_SECRET,\n", "    },\n\t    async function (jwtPayload, done) {\n\t      return prisma.user\n\t        .findFirst({ where: { id: jwtPayload } })\n\t        .then((user) => {\n\t          return done(null, user || undefined);\n\t        })\n\t        .catch((err) => {\n\t          return done(err);\n\t        });\n", "    }\n\t  )\n\t);\n"]}
{"filename": "src/middlewares/passportGoogleSSO.ts", "chunked_list": ["//@ts-nocheck\n\timport passport from \"passport\";\n\timport passportGoogle from \"passport-google-oauth20\";\n\timport { prisma } from \"../utils/prismaClient\";\n\tconst GoogleStrategy = passportGoogle.Strategy;\n\tpassport.use(\n\t  new GoogleStrategy(\n\t    {\n\t      clientID: `${process.env.GOOGLE_CLIENT_ID}`,\n\t      clientSecret: `${process.env.GOOGLE_CLIENT_SECRET}`,\n", "      callbackURL: process.env.GOOGLE_CALLBACK_URL,\n\t      passReqToCallback: true,\n\t    },\n\t    async (req, accessToken, refreshToken, profile, cb) => {\n\t      try {\n\t        const user = await prisma.user.upsert({\n\t          where: { accountId: profile.id },\n\t          create: {\n\t            name: `${profile.name.givenName} ${profile.name.familyName}`,\n\t            email: profile.emails[0].value,\n", "            image: profile.photos[0].value,\n\t            accountId: profile.id,\n\t            provider: \"google\",\n\t          },\n\t          update: {},\n\t        });\n\t        if (user) return cb(null, user);\n\t      } catch (err) {\n\t        console.log(\"Error signing up\", err);\n\t        cb(err, null);\n", "      }\n\t    }\n\t  )\n\t);\n\tpassport.serializeUser((user, cb) => {\n\t  cb(null, user.id);\n\t});\n\tpassport.deserializeUser(async (id, cb) => {\n\t  try {\n\t    const user = await prisma.user.findUnique({\n", "      where: { id },\n\t      select: {\n\t        id: true,\n\t        email: true,\n\t        image: true,\n\t        name: true,\n\t        provider: true,\n\t        createdAt: true,\n\t      },\n\t    });\n", "    if (user) cb(null, user);\n\t  } catch (err) {\n\t    console.log(\"Error deserializing\", err);\n\t    cb(err, null);\n\t  }\n\t});\n"]}
{"filename": "src/types/index.d.ts", "chunked_list": ["export interface ErrorType {\n\t  status: number;\n\t  message: string;\n\t}\n\texport type Source = \"glosbe\" | \"oxford\" | \"cambridge\";\n\texport type LanguagePairs = \"vi-en\" | \"en-vi\" | \"en-en\";\n\texport type Language = \"en\" | \"vi\";\n"]}
{"filename": "src/router/auth.ts", "chunked_list": ["import Router from \"express-promise-router\";\n\timport passport from \"passport\";\n\timport type { NextFunction, Request, Response } from \"express\";\n\tconst router = Router();\n\trouter.get(\n\t  \"/login/google\",\n\t  passport.authenticate(\"google\", { scope: [\"profile\", \"email\"] })\n\t);\n\trouter.get(\n\t  \"/login/facebook\",\n", "  passport.authenticate(\"facebook\", {\n\t    scope: [\"public_profile\", \"email\"],\n\t  })\n\t);\n\trouter.get(\"/logout\", (req: Request, res: Response, next: NextFunction) => {\n\t  req.logOut((err) => {\n\t    if (err) {\n\t      console.log(\"err:: \", err);\n\t      return next(err);\n\t    }\n", "    req?.session?.destroy((err) => {\n\t      if (err) console.error(err);\n\t    });\n\t    res.clearCookie(\"connect.sid\");\n\t    return res.status(200).json({ status: \"success\" });\n\t  });\n\t});\n\trouter.get(\n\t  \"/auth/facebook/callback\",\n\t  passport.authenticate(\"facebook\", {\n", "    failureMessage: \"Cannot login to Facebook, please try again later!\",\n\t    successRedirect: `${process.env.CLIENT_URL}`,\n\t    failureRedirect: `${process.env.CLIENT_URL}`,\n\t  }),\n\t  (req, res) => {\n\t    console.log(\"User: \", req?.user);\n\t    return res.status(200).json({ message: '\"Logged\"' });\n\t  }\n\t);\n\trouter.get(\n", "  \"/auth/google/callback\",\n\t  passport.authenticate(\"google\", {\n\t    failureMessage: \"Cannot login to Google, please try again later!\",\n\t    successRedirect: `${process.env.CLIENT_URL}`,\n\t    failureRedirect: `${process.env.CLIENT_URL}`,\n\t  }),\n\t  (req, res) => {\n\t    console.log(\"User: \", req?.user);\n\t    return res.status(200).json({ message: '\"Logged\"' });\n\t  }\n", ");\n\texport default router;\n"]}
{"filename": "src/router/service.ts", "chunked_list": ["import type { NextFunction, Request, Response } from \"express\";\n\timport { updatePracticeStatus } from \"../controllers/wordController\";\n\timport Router from \"express-promise-router\";\n\tconst router = Router();\n\trouter.get(\n\t  \"/service/ping\",\n\t  (req: Request, res: Response, next: NextFunction) => {\n\t    const key = req.headers[\"x-api-key\"];\n\t    if (\n\t      !key ||\n", "      typeof key !== \"string\" ||\n\t      key !== `${process.env.CRON_API_KEY}`\n\t    ) {\n\t      return res.status(401).end();\n\t    }\n\t    return res.status(200).json({ message: \"pong\" });\n\t  }\n\t);\n\trouter.get(\"/service/update-practice-status\", updatePracticeStatus);\n\texport default router;\n"]}
{"filename": "src/router/word.ts", "chunked_list": ["import Router from \"express-promise-router\";\n\timport {\n\t  search,\n\t  getWordDetail,\n\t  getAudio,\n\t  getWordDetailByMachine,\n\t  getGrammar,\n\t} from \"../controllers/wordController\";\n\tconst router = Router();\n\trouter.get(\"/words/search\", search);\n", "router.get(\"/words/translate/:word\", getWordDetail);\n\trouter.post(\"/words/machine_translation\", getWordDetailByMachine);\n\trouter.get(\"/words/grammar/:word\", getGrammar);\n\trouter.get(\"/words/audio/:word\", getAudio);\n\texport default router;\n"]}
{"filename": "src/router/index.ts", "chunked_list": ["import { Express } from \"express\";\n\timport wordRouter from \"./word\";\n\timport authRouter from \"./auth\";\n\timport userRouter from \"./user\";\n\timport serviceRouter from \"./service\";\n\tfunction route(app: Express) {\n\t  app.use(`/api`, wordRouter);\n\t  app.use(`/api`, userRouter);\n\t  app.use(`/api`, authRouter);\n\t  app.use(`/api`, serviceRouter);\n", "}\n\texport default route;\n"]}
{"filename": "src/router/user.ts", "chunked_list": ["import Router from \"express-promise-router\";\n\timport { isUserAuthenticated } from \"../middlewares/auth\";\n\timport {\n\t  handleGetUserInfo,\n\t  handleCreateTranslationHistory,\n\t  handleGetTranslationHistory,\n\t  handleDeleteTranslationHistory,\n\t  handleGetInfoFavorite,\n\t  handleCreateFavorite,\n\t  handleDeleteFavorite,\n", "  handleGetDashboardInfo,\n\t  handleGetWordsPreview,\n\t  handleGetWordsPractice,\n\t  handleUpdatePracticeStatus,\n\t} from \"../controllers/userController\";\n\timport {\n\t  TranslationHistorySchema,\n\t  DeleteTranslationHistorySchema,\n\t  FavoriteQuerySchema,\n\t  FavoriteBodySchema,\n", "  DashboardQuerySchema,\n\t  WordPreviewQuerySchema,\n\t  PracticeQuerySchema,\n\t  PracticePatchSchema,\n\t} from \"../schemas\";\n\timport { validate } from \"../middlewares/zodValidate\";\n\tconst router = Router();\n\trouter.get(\"/auth/user\", isUserAuthenticated, handleGetUserInfo);\n\trouter.patch(\n\t  \"/users/practice\",\n", "  isUserAuthenticated,\n\t  validate(PracticePatchSchema),\n\t  handleUpdatePracticeStatus\n\t);\n\trouter.get(\n\t  \"/users/practice\",\n\t  isUserAuthenticated,\n\t  validate(PracticeQuerySchema),\n\t  //@ts-ignore\n\t  handleGetWordsPractice\n", ");\n\trouter.get(\n\t  \"/users/dashboard\",\n\t  isUserAuthenticated,\n\t  validate(DashboardQuerySchema),\n\t  handleGetDashboardInfo\n\t);\n\trouter.get(\n\t  \"/users/word-preview\",\n\t  isUserAuthenticated,\n", "  validate(WordPreviewQuerySchema),\n\t  //@ts-ignore\n\t  handleGetWordsPreview\n\t);\n\trouter.get(\n\t  \"/users/favorite\",\n\t  isUserAuthenticated,\n\t  validate(FavoriteQuerySchema),\n\t  handleGetInfoFavorite\n\t);\n", "router.post(\n\t  \"/users/favorite\",\n\t  isUserAuthenticated,\n\t  validate(FavoriteBodySchema),\n\t  handleCreateFavorite\n\t);\n\trouter.delete(\n\t  \"/users/favorite\",\n\t  isUserAuthenticated,\n\t  validate(FavoriteBodySchema),\n", "  handleDeleteFavorite\n\t);\n\trouter.post(\n\t  \"/users/translation-history\",\n\t  isUserAuthenticated,\n\t  validate(TranslationHistorySchema),\n\t  handleCreateTranslationHistory\n\t);\n\trouter.get(\n\t  \"/users/translation-history\",\n", "  isUserAuthenticated,\n\t  //@ts-ignore\n\t  handleGetTranslationHistory\n\t);\n\trouter.delete(\n\t  \"/users/translation-history\",\n\t  isUserAuthenticated,\n\t  validate(DeleteTranslationHistorySchema),\n\t  //@ts-ignore\n\t  handleDeleteTranslationHistory\n", ");\n\texport default router;\n"]}
{"filename": "src/controllers/wordController.ts", "chunked_list": ["import axios from \"axios\";\n\timport type { NextFunction, Request, Response } from \"express\";\n\timport { prisma } from \"../utils/prismaClient\";\n\timport { GLOSBE_API } from \"../configs\";\n\timport {\n\t  translateWordGlosbe,\n\t  machineTranslation,\n\t  getGrammarGlosbe,\n\t  translateOxford,\n\t  translateCambridge,\n", "} from \"../libs\";\n\timport { getAudioInfo } from \"../utils/getAudio\";\n\timport { createManySense, connectTypeOfWord } from \"../utils/dbHelper\";\n\timport type { Language, LanguagePairs, Source } from \"../types\";\n\tinterface SearchQuery {\n\t  word: string;\n\t  format: LanguagePairs;\n\t  sensesFormat: Language;\n\t}\n\tinterface AudioQuery {\n", "  source: Source;\n\t}\n\texport async function updatePracticeStatus(\n\t  req: Request,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  try {\n\t    const key = req.headers[\"x-api-key\"];\n\t    if (\n", "      !key ||\n\t      typeof key !== \"string\" ||\n\t      key !== `${process.env.CRON_API_KEY}`\n\t    ) {\n\t      return res.status(401).end();\n\t    }\n\t    const start = new Date(Date.now());\n\t    const practices = await prisma.practice.findMany({\n\t      where: {\n\t        status: \"REMEMBERED\",\n", "      },\n\t      select: {\n\t        id: true,\n\t        numberOfDaysToForget: true,\n\t        updatedAt: true,\n\t      },\n\t    });\n\t    await Promise.allSettled(\n\t      practices.map(async (e) => {\n\t        const diffDate = Math.ceil(\n", "          //@ts-ignore\n\t          (new Date(Date.now()) - new Date(String(e.updatedAt))) / 86400000\n\t        );\n\t        if (diffDate >= e.numberOfDaysToForget) {\n\t          return await prisma.practice.update({\n\t            where: { id: e.id },\n\t            data: { status: \"TEMPORARILY_FORGET\" },\n\t          });\n\t        } else {\n\t          // console.log(\"skip!\");\n", "        }\n\t      })\n\t    );\n\t    //@ts-ignore\n\t    const cost = Math.abs(new Date(Date.now()) - start) / 1000;\n\t    return res\n\t      .status(200)\n\t      .json({ updateCost: `${cost} s`, totalRecords: practices.length });\n\t  } catch (error) {\n\t    console.error(\"error:: \", error);\n", "    next(\"500 ERROR\");\n\t  }\n\t}\n\texport async function search(\n\t  req: Request<{}, {}, {}, SearchQuery>,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  const { format, word } = req.query;\n\t  const _format_ = format.split(\"-\");\n", "  try {\n\t    if (!format || !word) throw new Error(\"missing query [format, word]\");\n\t    const resData = await (\n\t      await axios.get(\n\t        `${GLOSBE_API}/iapi3/wordlist?l1=${_format_[0]}&l2=${_format_[1]}&q=${word}&after=20&before=0&env=vi`\n\t      )\n\t    ).data;\n\t    if (resData?.after && Array.isArray(resData?.after)) {\n\t      const words = resData?.after.map((e: any) => String(e?.phrase));\n\t      return res.status(200).json({ words });\n", "    }\n\t    return res.status(404).json({ message: \"word not found\" });\n\t  } catch (error) {\n\t    console.log(\"SEARCH ERROR: \", error);\n\t    next();\n\t  }\n\t}\n\texport async function getWordDetail(\n\t  req: Request<\n\t    Pick<SearchQuery, \"word\">,\n", "    {},\n\t    {},\n\t    Pick<SearchQuery, \"format\"> & AudioQuery\n\t  >,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  try {\n\t    const { word } = req.params;\n\t    const { format, source } = req.query;\n", "    const _format_ = format.split(\"-\");\n\t    if (!word) throw new Error(\"word missing\");\n\t    if (!format) throw new Error(\"format missing\");\n\t    //@ts-ignore\n\t    let resData;\n\t    if (format === \"en-en\") {\n\t      if (source === \"cambridge\") {\n\t        resData = await translateCambridge({ word });\n\t      } else {\n\t        resData = await translateOxford({ word });\n", "      }\n\t      if (resData) {\n\t        return res.status(200).json(resData);\n\t      } else {\n\t        throw new Error();\n\t      }\n\t    }\n\t    //get word from \"cache\":\n\t    const wordDb = await prisma.word.findUnique({\n\t      where: { wordContent: word },\n", "      include: {\n\t        examples: true,\n\t        senses: { include: { example: true, typeOfWord: true } },\n\t        less_frequent_senses: true,\n\t        similar_phrases: true,\n\t        typesOfWord: { select: { type: true } },\n\t      },\n\t    });\n\t    //\"cache hit\"\n\t    if (wordDb) {\n", "      return res.status(200).json({\n\t        ...wordDb,\n\t        typesOfWord: wordDb.typesOfWord.map((e) => e.type),\n\t        senses: wordDb.senses.map((s) => ({\n\t          ...s,\n\t          typeOfWord: s.typeOfWord?.type,\n\t        })),\n\t        less_frequent_senses: wordDb.less_frequent_senses.map((e) => e.sense),\n\t      });\n\t    }\n", "    console.time(`time scrape ${word}`);\n\t    resData = await translateWordGlosbe({\n\t      language_1: _format_[0] as Language,\n\t      language_2: _format_[1] as Language,\n\t      word,\n\t    });\n\t    console.timeEnd(`time scrape ${word}`);\n\t    if (resData) {\n\t      //cache data:\n\t      try {\n", "        setTimeout(async () => {\n\t          const [word] = await prisma.$transaction([\n\t            prisma.word.create({\n\t              data: {\n\t                format,\n\t                //@ts-ignore\n\t                wordContent: resData.wordContent,\n\t                less_frequent_senses:\n\t                  //@ts-ignore\n\t                  resData?.less_frequent_senses &&\n", "                  //@ts-ignore\n\t                  resData?.less_frequent_senses.length > 0\n\t                    ? {\n\t                        createMany: {\n\t                          //@ts-ignore\n\t                          data: resData?.less_frequent_senses.map((e) => ({\n\t                            sense: e,\n\t                          })),\n\t                        },\n\t                      }\n", "                    : undefined,\n\t                similar_phrases:\n\t                  //@ts-ignore\n\t                  resData?.similar_phrases &&\n\t                  resData?.similar_phrases.length > 0\n\t                    ? {\n\t                        createMany: {\n\t                          //@ts-ignore\n\t                          data: resData?.similar_phrases.map((e) => ({\n\t                            en: e.en,\n", "                            vi: e.vi,\n\t                          })),\n\t                        },\n\t                      }\n\t                    : undefined,\n\t                examples:\n\t                  //@ts-ignore\n\t                  resData?.examples && resData.examples.length > 0\n\t                    ? {\n\t                        createMany: {\n", "                          //@ts-ignore\n\t                          data: resData.examples.map((e) => ({\n\t                            en: e.en,\n\t                            vi: e.vi,\n\t                            keyword_en: e?.keyword_en,\n\t                            keyword_vi: e?.keyword_vi,\n\t                          })),\n\t                        },\n\t                      }\n\t                    : undefined,\n", "              },\n\t            }),\n\t            prisma.typeOfWord.createMany({\n\t              data:\n\t                //@ts-ignore\n\t                resData.typesOfWord && resData.typesOfWord.length > 0\n\t                  ? //@ts-ignore\n\t                    resData.typesOfWord.map((e) => ({ type: e }))\n\t                  : [],\n\t              skipDuplicates: true,\n", "            }),\n\t          ]);\n\t          //@ts-ignore\n\t          if (resData.typesOfWord && resData.typesOfWord.length > 0) {\n\t            await Promise.allSettled([\n\t              //@ts-ignore\n\t              await connectTypeOfWord(resData.typesOfWord, word.wordContent),\n\t              //@ts-ignore\n\t              await createManySense(resData.senses, word.id),\n\t            ]);\n", "          } else {\n\t            //@ts-ignore\n\t            await createManySense(resData.senses, word.id);\n\t          }\n\t        }, 500);\n\t      } catch (error) {\n\t        console.log(\"cache ERROR: \", error);\n\t      }\n\t      return res.status(200).json(resData);\n\t    } else {\n", "      return res.status(404).json({ message: \"word detail not found\" });\n\t    }\n\t  } catch (error) {\n\t    console.log(\"getWordDetail: \", error);\n\t    next();\n\t  }\n\t}\n\texport async function getGrammar(\n\t  req: Request<Pick<SearchQuery, \"word\">, {}, {}, {}>,\n\t  res: Response,\n", "  next: NextFunction\n\t) {\n\t  const { word } = req.params;\n\t  const resData = await getGrammarGlosbe({ word });\n\t  if (resData) {\n\t    return res.status(200).json({ grammars: resData });\n\t  } else {\n\t    return res.status(404).json({ message: \"grammars not found\" });\n\t  }\n\t}\n", "export async function getWordDetailByMachine(\n\t  req: Request<{}, {}, { sentence: string }, Pick<SearchQuery, \"format\">>,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  const { sentence } = req.body;\n\t  const { format } = req.query;\n\t  const _format_ = format.split(\"-\");\n\t  if (!sentence) throw new Error(\"word missing\");\n\t  if (!format) throw new Error(\"format missing\");\n", "  try {\n\t    const resData = await machineTranslation({\n\t      language_1: _format_[0] as Language,\n\t      language_2: _format_[1] as Language,\n\t      word: sentence,\n\t    });\n\t    if (resData) {\n\t      return res.status(200).json(resData);\n\t    }\n\t    return res\n", "      .status(404)\n\t      .json({ message: \"word detail by machine not found\" });\n\t  } catch (error) {\n\t    console.log(\"getWordDetailByMachine error: \", error);\n\t    next();\n\t  }\n\t}\n\texport async function getAudio(\n\t  req: Request<Pick<SearchQuery, \"word\">, {}, {}, AudioQuery>,\n\t  res: Response,\n", "  next: NextFunction\n\t) {\n\t  try {\n\t    const { word } = req.params;\n\t    const { source } = req.query;\n\t    const audios = await getAudioInfo({ word, format: \"en\", source });\n\t    return res.status(200).json({ audios });\n\t  } catch (error) {}\n\t}\n"]}
{"filename": "src/controllers/userController.ts", "chunked_list": ["import type { NextFunction, Request, Response } from \"express\";\n\timport { prisma } from \"../utils/prismaClient\";\n\timport type { PracticeStatus } from \"@prisma/client\";\n\texport async function handleGetUserInfo(\n\t  req: Request,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  try {\n\t    return res.status(200).json(req.user);\n", "  } catch (error) {\n\t    console.error(\"handleGetUserInfo ERROR: \", error);\n\t    return res.status(500).json(\"ERROR\");\n\t  }\n\t}\n\tinterface TranslationHistoryBody {\n\t  word: string;\n\t  sense: string;\n\t  currentLanguage: string;\n\t  targetLanguage: string;\n", "  translations_history: TranslationHistoryBody[];\n\t}\n\texport async function handleUpdatePracticeStatus(\n\t  req: Request<{}, {}, { status: PracticeStatus; wordContent: string }>,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  const { user } = req;\n\t  let { status, wordContent } = req.body;\n\t  try {\n", "    const practiceOwner = await prisma.practice.findUnique({\n\t      where: {\n\t        userId_wordContent: {\n\t          //@ts-ignore\n\t          userId: user.id,\n\t          wordContent,\n\t        },\n\t      },\n\t    });\n\t    const forgottenFrequencyOwner = practiceOwner?.forgottenFrequency\n", "      ? practiceOwner?.forgottenFrequency\n\t      : 0;\n\t    const practice = await prisma.practice.update({\n\t      where: {\n\t        userId_wordContent: {\n\t          //@ts-ignore\n\t          userId: user.id,\n\t          wordContent,\n\t        },\n\t      },\n", "      select: {\n\t        status: true,\n\t        updatedAt: true,\n\t      },\n\t      data: {\n\t        status,\n\t        forgottenFrequency:\n\t          status === \"REMEMBERED\" ? 0 : forgottenFrequencyOwner + 1,\n\t      },\n\t    });\n", "    return res.status(200).json(practice);\n\t  } catch (error) {\n\t    console.error(`handleGetWordsPreview: ${error}`);\n\t    next(\"handleGetWordsPreview ERROR\");\n\t  }\n\t}\n\texport async function handleGetWordsPractice(\n\t  req: Request<\n\t    {},\n\t    {},\n", "    {},\n\t    { status: string; tags: string; page?: number; limit?: number }\n\t  >,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  const { user } = req;\n\t  let { status, page, tags, limit } = req.query;\n\t  if (!page) page = 1;\n\t  if (!limit) limit = 20;\n", "  const _status_ = status.split(\"+\");\n\t  const _tags_ = tags.split(\"+\");\n\t  const orConditions = [\n\t    ..._status_.map((e) => ({ status: e })),\n\t    ..._tags_.map((e) => ({ tag: e })),\n\t  ];\n\t  try {\n\t    const [practices, totalRecords] = await prisma.$transaction([\n\t      prisma.practice.findMany({\n\t        where: {\n", "          //@ts-ignore\n\t          userId: user.id,\n\t          tag: tags ? { in: _tags_ } : undefined,\n\t          //@ts-ignore\n\t          status: status ? { in: _status_ } : undefined,\n\t        },\n\t        select: {\n\t          id: true,\n\t          status: true,\n\t          tag: true,\n", "          word: {\n\t            select: {\n\t              less_frequent_senses: { select: { sense: true } },\n\t              format: true,\n\t              wordContent: true,\n\t              senses: true,\n\t            },\n\t          },\n\t        },\n\t        take: Number(limit),\n", "        skip: (Number(page) - 1) * limit,\n\t        orderBy: {\n\t          createdAt: \"desc\",\n\t        },\n\t      }),\n\t      prisma.practice.count({\n\t        where: {\n\t          //@ts-ignore\n\t          userId: user.id,\n\t          tag: { in: _tags_ },\n", "          //@ts-ignore\n\t          status: { in: _status_ },\n\t        },\n\t      }),\n\t    ]);\n\t    return res\n\t      .status(200)\n\t      .json({ practices, totalPages: Math.ceil(totalRecords / limit) });\n\t  } catch (error) {\n\t    console.error(`handleGetWordsPreview: ${error}`);\n", "    next(\"handleGetWordsPreview ERROR\");\n\t  }\n\t}\n\texport async function handleGetWordsPreview(\n\t  req: Request<\n\t    {},\n\t    {},\n\t    {},\n\t    { status: string; tag?: string; page?: number; limit?: number }\n\t  >,\n", "  res: Response,\n\t  next: NextFunction\n\t) {\n\t  const { user } = req;\n\t  let { status, page, tag, limit } = req.query;\n\t  if (!page) page = 1;\n\t  if (!limit) limit = 18;\n\t  try {\n\t    const [words, totalRecords] = await prisma.$transaction([\n\t      prisma.practice.findMany({\n", "        where: {\n\t          //@ts-ignore\n\t          userId: user.id,\n\t          //@ts-ignore\n\t          status,\n\t          tag,\n\t        },\n\t        select: {\n\t          word: {\n\t            select: {\n", "              format: true,\n\t              wordContent: true,\n\t              senses: { select: { sense: true } },\n\t            },\n\t          },\n\t        },\n\t        take: Number(limit),\n\t        skip: (Number(page) - 1) * limit,\n\t        orderBy: {\n\t          createdAt: 'desc'\n", "        }\n\t      }),\n\t      prisma.practice.count({\n\t        where: {\n\t          //@ts-ignore\n\t          userId: user.id,\n\t          //@ts-ignore\n\t          status,\n\t          tag,\n\t        },\n", "      }),\n\t    ]);\n\t    return res\n\t      .status(200)\n\t      .json({ words, totalPages: Math.ceil(totalRecords / limit) });\n\t  } catch (error) {\n\t    console.error(`handleGetWordsPreview: ${error}`);\n\t    next(\"handleGetWordsPreview ERROR\");\n\t  }\n\t}\n", "export async function handleGetDashboardInfo(\n\t  req: Request<{}, {}, {}, { status: string }>,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  const { user } = req;\n\t  const { status } = req.query;\n\t  try {\n\t    const [statusCounting, historyCounting, favoriteCounting, tags] =\n\t      await prisma.$transaction([\n", "        prisma.practice.count({\n\t          //@ts-ignore\n\t          where: { userId: user.id, status },\n\t        }),\n\t        prisma.translationHistory.count({\n\t          //@ts-ignore\n\t          where: { userId: user.id },\n\t        }),\n\t        prisma.practice.count({\n\t          //@ts-ignore\n", "          where: { userId: user.id },\n\t        }),\n\t        prisma.practice.findMany({\n\t          //@ts-ignore\n\t          where: { userId: user.id },\n\t          distinct: [\"tag\"],\n\t          select: { tag: true },\n\t        }),\n\t      ]);\n\t    return res\n", "      .status(200)\n\t      .json({ statusCounting, historyCounting, favoriteCounting, tags });\n\t  } catch (error) {\n\t    console.error(`handleGetDashboardInfo: ${error}`);\n\t    next(\"handleGetDashboardInfo ERROR\");\n\t  }\n\t}\n\texport async function handleDeleteFavorite(\n\t  req: Request<{}, {}, { word: string }>,\n\t  res: Response,\n", "  next: NextFunction\n\t) {\n\t  const { word } = req.body;\n\t  const { user } = req;\n\t  try {\n\t    const deletedStatus = await prisma.practice.delete({\n\t      where: {\n\t        userId_wordContent: {\n\t          //@ts-ignore\n\t          userId: user.id,\n", "          wordContent: word,\n\t        },\n\t      },\n\t    });\n\t    return res.status(200).json(deletedStatus);\n\t  } catch (error) {\n\t    console.error(`handleCreateFavorite: ${error}`);\n\t    next(\"handleCreateFavorite ERROR\");\n\t  }\n\t}\n", "export async function handleCreateFavorite(\n\t  req: Request<\n\t    {},\n\t    {},\n\t    { word: string; tag?: string; numberOfDaysToForget?: number }\n\t  >,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  const { word, numberOfDaysToForget, tag } = req.body;\n", "  const { user } = req;\n\t  try {\n\t    const practiceWord = await prisma.practice.upsert({\n\t      where: {\n\t        userId_wordContent: {\n\t          //@ts-ignore\n\t          userId: user.id,\n\t          wordContent: word,\n\t        },\n\t      },\n", "      create: {\n\t        word: { connect: { wordContent: word } },\n\t        //@ts-ignore\n\t        user: { connect: { id: user.id } },\n\t        numberOfDaysToForget,\n\t        tag,\n\t      },\n\t      update: {},\n\t    });\n\t    return res.status(201).json(practiceWord);\n", "  } catch (error) {\n\t    console.error(`handleCreateFavorite: ${error}`);\n\t    next(\"handleCreateFavorite ERROR\");\n\t  }\n\t}\n\texport async function handleGetInfoFavorite(\n\t  req: Request<{}, {}, {}, { word: string }>,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n", "  const { word } = req.query;\n\t  const { user } = req;\n\t  try {\n\t    const practiceWord = await prisma.practice.findUnique({\n\t      where: {\n\t        userId_wordContent: {\n\t          //@ts-ignore\n\t          userId: user.id,\n\t          wordContent: word,\n\t        },\n", "      },\n\t      select: {\n\t        createdAt: true,\n\t      },\n\t    });\n\t    return res.status(200).json(practiceWord);\n\t  } catch (error) {\n\t    console.error(`handleGetInfoFavorite: ${error}`);\n\t    next(\"handleGetInfoFavorite ERROR\");\n\t  }\n", "}\n\texport async function handleCreateTranslationHistory(\n\t  req: Request<{}, {}, TranslationHistoryBody, {}>,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  const { word, sense, currentLanguage, targetLanguage, translations_history } =\n\t    req.body;\n\t  const { user } = req;\n\t  try {\n", "    //multiple create:\n\t    if (translations_history && translations_history.length > 0) {\n\t      const tHistory = await prisma.translationHistory.createMany({\n\t        data: translations_history.map((e) => ({\n\t          word: e.word,\n\t          sense: e.sense,\n\t          currentLanguage: e.currentLanguage,\n\t          targetLanguage: e.targetLanguage,\n\t          //@ts-ignore\n\t          userId: user.id,\n", "        })),\n\t        skipDuplicates: true,\n\t      });\n\t      return res.status(201).json(tHistory);\n\t    }\n\t    //single create:\n\t    const tHistory = await prisma.translationHistory.upsert({\n\t      where: {\n\t        userId_word: {\n\t          //@ts-ignore\n", "          userId: user.id,\n\t          word,\n\t        },\n\t      },\n\t      create: {\n\t        word,\n\t        sense,\n\t        currentLanguage,\n\t        targetLanguage,\n\t        //@ts-ignore\n", "        userId: user.id,\n\t      },\n\t      update: {},\n\t    });\n\t    return res.status(201).json(tHistory);\n\t  } catch (error) {\n\t    console.error(`handleCreateTranslationHistory: ${error}`);\n\t    next(\"handleCreateTranslationHistory ERROR\");\n\t  }\n\t}\n", "export async function handleGetTranslationHistory(\n\t  req: Request<{}, {}, {}, { page: number; limit: number }>,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  try {\n\t    const { user } = req;\n\t    let { page, limit } = req.query;\n\t    if (!page) page = 1;\n\t    if (!limit) limit = 18;\n", "    const [translations, totalRecords] = await prisma.$transaction([\n\t      prisma.translationHistory.findMany({\n\t        //@ts-ignore\n\t        where: { userId: user.id },\n\t        orderBy: {\n\t          createdAt: \"desc\",\n\t        },\n\t        take: Number(limit),\n\t        skip: (Number(page) - 1) * limit,\n\t      }),\n", "      prisma.translationHistory.count({\n\t        //@ts-ignore\n\t        where: { userId: user.id },\n\t      }),\n\t    ]);\n\t    return res\n\t      .status(200)\n\t      .json({ translations, totalPages: Math.ceil(totalRecords / limit) });\n\t  } catch (error) {\n\t    console.error(`handleGetTranslationHistory: ${error}`);\n", "    next(\"handleGetTranslationHistory ERROR\");\n\t  }\n\t}\n\texport async function handleDeleteTranslationHistory(\n\t  req: Request<{}, {}, { word: string; deleteOption: string }, {}>,\n\t  res: Response,\n\t  next: NextFunction\n\t) {\n\t  try {\n\t    const { word, deleteOption } = req.body;\n", "    const { user } = req;\n\t    if (deleteOption === \"deleteAll\") {\n\t      const deleteStatus = await prisma.translationHistory.deleteMany({\n\t        //@ts-ignore\n\t        where: { userId: user.id },\n\t      });\n\t      return res.status(200).json({ deleteStatus });\n\t    }\n\t    const deleteStatus = await prisma.translationHistory.delete({\n\t      where: {\n", "        userId_word: {\n\t          word,\n\t          //@ts-ignore\n\t          userId: user.id,\n\t        },\n\t      },\n\t    });\n\t    return res.status(200).json({ deleteStatus });\n\t  } catch (error) {\n\t    console.error(`handleDeleteTranslationHistory: ${error}`);\n", "    next(\"handleDeleteTranslationHistory ERROR\");\n\t  }\n\t}\n"]}
