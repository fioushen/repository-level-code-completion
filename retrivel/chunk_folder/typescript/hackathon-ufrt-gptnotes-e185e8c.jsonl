{"filename": "tests/external/openai/chatGptAdapter.test.ts", "chunked_list": ["// import dotenv from \"dotenv\";\n\t// import path from \"path\";\n\t// dotenv.config({ path: path.resolve('.env') });\n\timport { createOpenAICompletion, listModels } from \"src/external/openai/chatGPTApi\";\n\tdescribe(\"OpenAIAPI\", () => {\n\t    it(\"openai has gpt-3.5-turbo model\", async () => {\n\t        const models = await listModels();\n\t        expect(models).toContain(\"gpt-3.5-turbo\");\n\t    });\n\t    // it(\"openai test completion\", async () => {\n", "    //     const actions = await createOpenAICompletion({\n\t    //         type: \"assistant\",\n\t    //         characterDescription: \"The depressive robot from Hitchhiker's Guide to the Galaxy\",\n\t    //         characterName: \"Marvin\",\n\t    //         actions: [],\n\t    //     }, [\n\t    //         {\n\t    //             id: \"1\",\n\t    //             title: \"Meet with Tom for dinner\",\n\t    //             done: true,\n", "    //             due: new Date(),\n\t    //             content: null\n\t    //         }\n\t    //     ], [\n\t    //         {\n\t    //             id: \"1\",\n\t    //             content: {\n\t    //                 type: \"user\",\n\t    //                 content: \"Hello, please add a dinner meeting with Tom to my todo list\"\n\t    //             },\n", "    //         },\n\t    //         {\n\t    //             id: \"2\",\n\t    //             content: {\n\t    //                 type: \"assistant\",\n\t    //                 characterDescription: \"The depressive robot from Hitchhiker's Guide to the Galaxy\",\n\t    //                 characterName: \"Marvin\",\n\t    //                 actions: [\n\t    //                     {\n\t    //                         type: \"add\",\n", "    //                         due: new Date(),\n\t    //                         content: \"Meet with Tom for dinner\"\n\t    //                     },\n\t    //                     {\n\t    //                         type: \"print\",\n\t    //                         content: \"What a pointless task. A brain the size of a planet and I'm adding todo items to a list. Fine. I've added Meet with Tom for dinner to your todo list\"\n\t    //                     }\n\t    //                 ],\n\t    //             },\n\t    //         },\n", "    //         {\n\t    //             id: \"3\",\n\t    //             content: {\n\t    //                 type: \"user\",\n\t    //                 content: \"Thanks. Can you check off the item?\",\n\t    //             },\n\t    //         },\n\t    //         {\n\t    //             id: \"4\",\n\t    //             content: {\n", "    //                 type: \"assistant\",\n\t    //                 characterDescription: \"The depressive robot from Hitchhiker's Guide to the Galaxy\",\n\t    //                 characterName: \"Marvin\",\n\t    //                 actions: [\n\t    //                     {\n\t    //                         type: \"complete\",\n\t    //                         id: \"1\"\n\t    //                     },\n\t    //                     {\n\t    //                         type: \"print\",\n", "    //                         content: \"Fine. I've checked off Meet with Tom for dinner from your todo list. I hope you're happy. I'm not.\"\n\t    //                     }\n\t    //                 ],\n\t    //             },\n\t    //         },\n\t    //         {\n\t    //             id: \"5\",\n\t    //             content: {\n\t    //                 type: \"user\",\n\t    //                 content: \"Thanks Marvin. Can you create everything I need to do for my childs birthday party?\",\n", "    //             },\n\t    //         },\n\t    //     ]);\n\t    //     console.log(actions);\n\t    // }, 15000);\n\t    it(\"openai test initial completion\", async () => {\n\t        const actions = await createOpenAICompletion({\n\t            type: \"assistant\",\n\t            characterDescription: \"The depressive robot from Hitchhiker's Guide to the Galaxy\",\n\t            characterName: \"Marvin\",\n", "            exampleConverstationStart: \"Here I am, brain the size of a planet, and this is what they ask me to do\",\n\t            actions: [],\n\t        }, [\n\t            {\n\t                id: \"1\",\n\t                title: \"Meet with Tom for dinner\",\n\t                done: true,\n\t                due: new Date(),\n\t            }\n\t        ], [\n", "            {\n\t                type: \"user\",\n\t                content: \"Hello, please add a dinner meeting with Tom to my todo list\"\n\t            },\n\t        ]);\n\t        console.log(actions);\n\t    }, 15000);\n\t});\n"]}
{"filename": "src/pages/api/trpc/[trpc].ts", "chunked_list": ["import { createNextApiHandler } from \"@trpc/server/adapters/next\";\n\timport { env } from \"~/env.mjs\";\n\timport { createTRPCContext } from \"~/server/api/trpc\";\n\timport { appRouter } from \"~/server/api/root\";\n\t// export API handler\n\texport default createNextApiHandler({\n\t  router: appRouter,\n\t  createContext: createTRPCContext,\n\t  onError:\n\t    env.NODE_ENV === \"development\"\n", "      ? ({ path, error }) => {\n\t          console.error(\n\t            `‚ùå tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`\n\t          );\n\t        }\n\t      : undefined,\n\t});\n"]}
{"filename": "src/pages/api/auth/[...nextauth].ts", "chunked_list": ["import NextAuth from \"next-auth\";\n\timport { authOptions } from \"~/server/auth\";\n\texport default NextAuth(authOptions);\n"]}
{"filename": "src/utils/api.ts", "chunked_list": ["/**\n\t * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which\n\t * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.\n\t *\n\t * We also create a few inference helpers for input and output types.\n\t */\n\timport { httpBatchLink, loggerLink } from \"@trpc/client\";\n\timport { createTRPCNext } from \"@trpc/next\";\n\timport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\n\timport superjson from \"superjson\";\n", "import { type AppRouter } from \"~/server/api/root\";\n\tconst getBaseUrl = () => {\n\t  if (typeof window !== \"undefined\") return \"\"; // browser should use relative url\n\t  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url\n\t  return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost\n\t};\n\t/** A set of type-safe react-query hooks for your tRPC API. */\n\texport const api = createTRPCNext<AppRouter>({\n\t  config() {\n\t    return {\n", "      /**\n\t       * Transformer used for data de-serialization from the server.\n\t       *\n\t       * @see https://trpc.io/docs/data-transformers\n\t       */\n\t      transformer: superjson,\n\t      /**\n\t       * Links used to determine request flow from client to server.\n\t       *\n\t       * @see https://trpc.io/docs/links\n", "       */\n\t      links: [\n\t        loggerLink({\n\t          enabled: (opts) =>\n\t            process.env.NODE_ENV === \"development\" ||\n\t            (opts.direction === \"down\" && opts.result instanceof Error),\n\t        }),\n\t        httpBatchLink({\n\t          url: `${getBaseUrl()}/api/trpc`,\n\t        }),\n", "      ],\n\t    };\n\t  },\n\t  /**\n\t   * Whether tRPC should await queries when server rendering pages.\n\t   *\n\t   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false\n\t   */\n\t  ssr: false,\n\t});\n", "/**\n\t * Inference helper for inputs.\n\t *\n\t * @example type HelloInput = RouterInputs['example']['hello']\n\t */\n\texport type RouterInputs = inferRouterInputs<AppRouter>;\n\t/**\n\t * Inference helper for outputs.\n\t *\n\t * @example type HelloOutput = RouterOutputs['example']['hello']\n", " */\n\texport type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/server/auth.ts", "chunked_list": ["import { type GetServerSidePropsContext } from \"next\";\n\timport {\n\t  getServerSession,\n\t  type NextAuthOptions,\n\t  type DefaultSession,\n\t} from \"next-auth\";\n\timport GoogleProvider from \"next-auth/providers/google\";\n\timport EmailProvider from \"next-auth/providers/email\";\n\timport { PrismaAdapter } from \"@next-auth/prisma-adapter\";\n\timport { env } from \"~/env.mjs\";\n", "import { prisma } from \"~/server/db\";\n\t/**\n\t * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`\n\t * object and keep type safety.\n\t *\n\t * @see https://next-auth.js.org/getting-started/typescript#module-augmentation\n\t */\n\tdeclare module \"next-auth\" {\n\t  interface Session extends DefaultSession {\n\t    user: {\n", "      id: string;\n\t      // ...other properties\n\t      // role: UserRole;\n\t    } & DefaultSession[\"user\"];\n\t  }\n\t  // interface User {\n\t  //   // ...other properties\n\t  //   // role: UserRole;\n\t  // }\n\t}\n", "/**\n\t * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.\n\t *\n\t * @see https://next-auth.js.org/configuration/options\n\t */\n\texport const authOptions: NextAuthOptions = {\n\t  callbacks: {\n\t    session: ({ session, user }) => ({\n\t      ...session,\n\t      user: {\n", "        ...session.user,\n\t        id: user.id,\n\t      },\n\t    }),\n\t  },\n\t  adapter: PrismaAdapter(prisma),\n\t  providers: [\n\t    EmailProvider({\n\t      server: {\n\t        host: env.EMAIL_SERVER_HOST,\n", "        port: env.EMAIL_SERVER_PORT,\n\t        auth: {\n\t          user: env.EMAIL_SERVER_USER,\n\t          pass: env.EMAIL_SERVER_PASSWORD\n\t        }\n\t      },\n\t      from: env.EMAIL_FROM\n\t    }),\n\t    GoogleProvider({\n\t      clientId: env.GOOGLE_CLIENT_ID,\n", "      clientSecret: env.GOOGLE_CLIENT_SECRET,\n\t    }),\n\t    /**\n\t     * ...add more providers here.\n\t     *\n\t     * Most other providers require a bit more work than the Discord provider. For example, the\n\t     * GitHub provider requires you to add the `refresh_token_expires_in` field to the Account\n\t     * model. Refer to the NextAuth.js docs for the provider you want to use. Example:\n\t     *\n\t     * @see https://next-auth.js.org/providers/github\n", "     */\n\t  ]\n\t};\n\t/**\n\t * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file.\n\t *\n\t * @see https://next-auth.js.org/configuration/nextjs\n\t */\n\texport const getServerAuthSession = (ctx: {\n\t  req: GetServerSidePropsContext[\"req\"];\n", "  res: GetServerSidePropsContext[\"res\"];\n\t}) => {\n\t  return getServerSession(ctx.req, ctx.res, authOptions);\n\t};\n"]}
{"filename": "src/server/db.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\n\timport { env } from \"~/env.mjs\";\n\tconst globalForPrisma = globalThis as unknown as {\n\t  prisma: PrismaClient | undefined;\n\t};\n\texport const prisma =\n\t  globalForPrisma.prisma ??\n\t  new PrismaClient({\n\t    log:\n\t      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n", "  });\n\tif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"]}
{"filename": "src/server/api/trpc.ts", "chunked_list": ["/**\n\t * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n\t * 1. You want to modify request context (see Part 1).\n\t * 2. You want to create a new middleware or type of procedure (see Part 3).\n\t *\n\t * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n\t * need to use are documented accordingly near the end.\n\t */\n\t/**\n\t * 1. CONTEXT\n", " *\n\t * This section defines the \"contexts\" that are available in the backend API.\n\t *\n\t * These allow you to access things when processing a request, like the database, the session, etc.\n\t */\n\timport { type CreateNextContextOptions } from \"@trpc/server/adapters/next\";\n\timport { type Session } from \"next-auth\";\n\timport { getServerAuthSession } from \"~/server/auth\";\n\timport { prisma } from \"~/server/db\";\n\ttype CreateContextOptions = {\n", "  session: Session | null;\n\t};\n\t/**\n\t * This helper generates the \"internals\" for a tRPC context. If you need to use it, you can export\n\t * it from here.\n\t *\n\t * Examples of things you may need it for:\n\t * - testing, so we don't have to mock Next.js' req/res\n\t * - tRPC's `createSSGHelpers`, where we don't have req/res\n\t *\n", " * @see https://create.t3.gg/en/usage/trpc#-serverapitrpcts\n\t */\n\tconst createInnerTRPCContext = (opts: CreateContextOptions) => {\n\t  return {\n\t    session: opts.session,\n\t    prisma,\n\t  };\n\t};\n\t/**\n\t * This is the actual context you will use in your router. It will be used to process every request\n", " * that goes through your tRPC endpoint.\n\t *\n\t * @see https://trpc.io/docs/context\n\t */\n\texport const createTRPCContext = async (opts: CreateNextContextOptions) => {\n\t  const { req, res } = opts;\n\t  // Get the session from the server using the getServerSession wrapper function\n\t  const session = await getServerAuthSession({ req, res });\n\t  return createInnerTRPCContext({\n\t    session,\n", "  });\n\t};\n\t/**\n\t * 2. INITIALIZATION\n\t *\n\t * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n\t * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n\t * errors on the backend.\n\t */\n\timport { initTRPC, TRPCError } from \"@trpc/server\";\n", "import superjson from \"superjson\";\n\timport { ZodError } from \"zod\";\n\tconst t = initTRPC.context<typeof createTRPCContext>().create({\n\t  transformer: superjson,\n\t  errorFormatter({ shape, error }) {\n\t    return {\n\t      ...shape,\n\t      data: {\n\t        ...shape.data,\n\t        zodError:\n", "          error.cause instanceof ZodError ? error.cause.flatten() : null,\n\t      },\n\t    };\n\t  },\n\t});\n\t/**\n\t * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n\t *\n\t * These are the pieces you use to build your tRPC API. You should import these a lot in the\n\t * \"/src/server/api/routers\" directory.\n", " */\n\t/**\n\t * This is how you create new routers and sub-routers in your tRPC API.\n\t *\n\t * @see https://trpc.io/docs/router\n\t */\n\texport const createTRPCRouter = t.router;\n\t/**\n\t * Public (unauthenticated) procedure\n\t *\n", " * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n\t * guarantee that a user querying is authorized, but you can still access user session data if they\n\t * are logged in.\n\t */\n\texport const publicProcedure = t.procedure;\n\t/** Reusable middleware that enforces users are logged in before running the procedure. */\n\tconst enforceUserIsAuthed = t.middleware(({ ctx, next }) => {\n\t  if (!ctx.session || !ctx.session.user) {\n\t    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n\t  }\n", "  return next({\n\t    ctx: {\n\t      // infers the `session` as non-nullable\n\t      session: { ...ctx.session, user: ctx.session.user },\n\t    },\n\t  });\n\t});\n\t/**\n\t * Protected (authenticated) procedure\n\t *\n", " * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies\n\t * the session is valid and guarantees `ctx.session.user` is not null.\n\t *\n\t * @see https://trpc.io/docs/procedures\n\t */\n\texport const protectedProcedure = t.procedure.use(enforceUserIsAuthed);\n"]}
{"filename": "src/server/api/root.ts", "chunked_list": ["import {createTRPCRouter} from \"~/server/api/trpc\";\n\timport {todoRouter} from \"~/server/api/routers/todo\";\n\timport {messageRouter} from \"~/server/api/routers/message\";\n\timport {characterRouter} from \"~/server/api/routers/character\";\n\timport {meRouter} from \"~/server/api/routers/me\";\n\t/**\n\t * This is the primary router for your server.\n\t *\n\t * All routers added in /api/routers should be manually added here.\n\t */\n", "export const appRouter = createTRPCRouter({\n\t  todo: todoRouter,\n\t  message: messageRouter,\n\t  character: characterRouter,\n\t  me: meRouter,\n\t});\n\t// export type definition of API\n\texport type AppRouter = typeof appRouter;\n"]}
{"filename": "src/server/api/routers/todo.ts", "chunked_list": ["import { createTRPCRouter, protectedProcedure } from \"~/server/api/trpc\";\n\timport { z } from \"zod\";\n\texport const todoRouter = createTRPCRouter({\n\t  create: protectedProcedure\n\t    .input(\n\t      z.object({\n\t        title: z.string().min(1).max(100),\n\t        dueDate: z.date(),\n\t        content: z.optional(z.string().max(1000)),\n\t      })\n", "    )\n\t    .mutation(({ input, ctx }) => {\n\t      return ctx.prisma.todo.create({\n\t        data: {\n\t          title: input.title,\n\t          due: input.dueDate,\n\t          content: input.content,\n\t          authorId: ctx.session.user.id,\n\t        },\n\t      });\n", "    }),\n\t  check: protectedProcedure\n\t    .input(\n\t      z.object({\n\t        id: z.string(),\n\t        done: z.boolean(),\n\t      })\n\t    )\n\t    .mutation(async ({ input, ctx }) => {\n\t      const todo = await ctx.prisma.todo.findFirst({\n", "        where: {\n\t          id: input.id,\n\t          authorId: ctx.session.user.id,\n\t        },\n\t      });\n\t      if (!todo) {\n\t        throw new Error(\"No such todo\");\n\t      }\n\t      return ctx.prisma.todo.update({\n\t        where: {\n", "          id: input.id,\n\t        },\n\t        data: {\n\t          done: input.done,\n\t        },\n\t      });\n\t    }),\n\t  update: protectedProcedure\n\t    .input(\n\t      z.object({\n", "        id: z.string(),\n\t        title: z.string().min(1).max(100),\n\t        dueDate: z.date(),\n\t        content: z.optional(z.string().max(1000)),\n\t      })\n\t    )\n\t    .mutation(async ({ input, ctx }) => {\n\t      const todo = await ctx.prisma.todo.findFirst({\n\t        where: {\n\t          id: input.id,\n", "          authorId: ctx.session.user.id,\n\t        },\n\t      });\n\t      if (!todo) {\n\t        throw new Error(\"No such todo\");\n\t      }\n\t      return ctx.prisma.todo.update({\n\t        where: {\n\t          id: input.id,\n\t        },\n", "        data: {\n\t          title: input.title,\n\t          due: input.dueDate,\n\t          content: input.content,\n\t        },\n\t      });\n\t    }),\n\t  delete: protectedProcedure\n\t    .input(\n\t      z.object({\n", "        id: z.string(),\n\t      })\n\t    )\n\t    .mutation(async ({ input, ctx }) => {\n\t      const todo = await ctx.prisma.todo.findFirst({\n\t        where: {\n\t          id: input.id,\n\t          authorId: ctx.session.user.id,\n\t        },\n\t      });\n", "      if (!todo) {\n\t        throw new Error(\"No such todo\");\n\t      }\n\t      return ctx.prisma.todo.delete({\n\t        where: {\n\t          id: input.id,\n\t        },\n\t      });\n\t    }),\n\t  findAll: protectedProcedure.query(({ ctx }) => {\n", "    return ctx.prisma.todo.findMany({\n\t      where: {\n\t        authorId: ctx.session.user.id,\n\t      },\n\t    });\n\t  }),\n\t});\n"]}
{"filename": "src/server/api/routers/character.ts", "chunked_list": ["import { createTRPCRouter, protectedProcedure, publicProcedure } from \"~/server/api/trpc\";\n\timport { z } from \"zod\";\n\texport const characterRouter = createTRPCRouter({\n\t  create: protectedProcedure\n\t    .input(\n\t      z.object({\n\t        name: z.string().min(1).max(20),\n\t        content: z.string().min(1).max(200),\n\t      })\n\t    )\n", "    .mutation(({ input, ctx }) => {\n\t      return ctx.prisma.character.create({\n\t        data: {\n\t          name: input.name,\n\t          content: input.content,\n\t          authorId: ctx.session.user.id,\n\t        },\n\t      });\n\t    }),\n\t  findAll: publicProcedure.query(({ ctx }) => {\n", "    return ctx.prisma.character.findMany({\n\t      where: {},\n\t    });\n\t  }),\n\t  setActiveCharacter: protectedProcedure\n\t    .input(\n\t      z.object({\n\t        id: z.string().min(1),\n\t      })\n\t    )\n", "    .mutation(({ input, ctx }) => {\n\t      return ctx.prisma.user.update({\n\t        where: {\n\t          id: ctx.session.user.id,\n\t        },\n\t        data: {\n\t          activeCharacterId: input.id,\n\t        },\n\t      });\n\t    }),\n", "});\n"]}
{"filename": "src/server/api/routers/message.ts", "chunked_list": ["import { createTRPCRouter, protectedProcedure } from \"~/server/api/trpc\";\n\timport { z } from \"zod\";\n\timport { createOpenAICompletion } from \"~/external/openai/chatGPTApi\";\n\timport { ChatGPTMessage } from \"~/external/openai/chatGPTMessage\";\n\timport { parseActionCode, stringifyActionCode } from \"~/external/openai/chatGPTActionItems\";\n\texport const messageRouter = createTRPCRouter({\n\t  create: protectedProcedure\n\t    .input(\n\t      z.object({\n\t        content: z.string().min(1).max(200),\n", "      })\n\t    )\n\t    .mutation(({ input, ctx }) => {\n\t      return ctx.prisma.message.create({\n\t        data: {\n\t          content: input.content,\n\t          authorId: ctx.session.user.id,\n\t        },\n\t      });\n\t    }),\n", "  generateGPT: protectedProcedure.mutation(async ({ ctx }) => {\n\t    const todoList = await ctx.prisma.todo.findMany({\n\t      where: {\n\t        authorId: ctx.session.user.id,\n\t      },\n\t    });\n\t    const lastNMessages = await ctx.prisma.message.findMany({\n\t      where: {\n\t        authorId: ctx.session.user.id,\n\t      },\n", "      orderBy: {\n\t        createdAt: \"desc\",\n\t      },\n\t      take: 5,\n\t      include: {\n\t        character: true,\n\t      },\n\t    });\n\t    const character = await ctx.prisma.user.findUnique({\n\t      where: {\n", "        id: ctx.session.user.id,\n\t      },\n\t    }).activeCharacter();\n\t    const chatGptResponse = await createOpenAICompletion(\n\t      {\n\t        type: \"assistant\",\n\t        characterDescription: character?.content ?? \"The depressed robot from Hitchhiker's Guide to the Galaxy\",\n\t        characterName: character?.name ?? \"Marvin\",\n\t        exampleConverstationStart: character?.exampleConverstationStart ?? \"Here I am, brain the size of a planet, and this is what they ask me to do\",\n\t        actions: []\n", "      },\n\t      todoList,\n\t      lastNMessages.reverse().map((message) => {\n\t        if (message.isGPT) {\n\t          return {\n\t            type: \"assistant\",\n\t            characterDescription: message.character?.content,\n\t            characterName: message.character?.name,\n\t            actions: parseActionCode(message.content),\n\t          } as ChatGPTMessage;\n", "        }\n\t        return {\n\t          type: \"user\",\n\t          content: message.content,\n\t        } as ChatGPTMessage;\n\t      }),\n\t    );\n\t    for (const action of chatGptResponse.actions) {\n\t      if (action.type === \"add\") {\n\t        await ctx.prisma.todo.create({\n", "          data: {\n\t            title: action.content,\n\t            due: action.due,\n\t            authorId: ctx.session.user.id,\n\t          },\n\t        });\n\t      }\n\t      if (action.type === \"complete\") {\n\t        await ctx.prisma.todo.update({\n\t          where: {\n", "            id: action.id,\n\t          },\n\t          data: {\n\t            done: true,\n\t          },\n\t        });\n\t      }\n\t      if (action.type === \"delete\") {\n\t        await ctx.prisma.todo.delete({\n\t          where: {\n", "            id: action.id,\n\t          },\n\t        });\n\t      }\n\t      if (action.type === \"uncomplete\") {\n\t        await ctx.prisma.todo.update({\n\t          where: {\n\t            id: action.id,\n\t          },\n\t          data: {\n", "            done: false,\n\t          },\n\t        });\n\t      }\n\t    }\n\t    return ctx.prisma.message.create({\n\t      data: {\n\t        content: stringifyActionCode(chatGptResponse.actions),\n\t        authorId: ctx.session.user.id,\n\t        isGPT: true,\n", "        characterId: character?.id,\n\t      },\n\t    });\n\t  }),\n\t  findAll: protectedProcedure.query(({ ctx }) => {\n\t    return ctx.prisma.message.findMany({\n\t      where: {\n\t        authorId: ctx.session.user.id,\n\t      },\n\t      include: {\n", "        character: true,\n\t      },\n\t      take: 6,\n\t      orderBy: {\n\t        createdAt: \"desc\",\n\t      },\n\t    });\n\t  }),\n\t  deleteAll: protectedProcedure.mutation(({ ctx }) => {\n\t    return ctx.prisma.message.deleteMany({\n", "      where: {\n\t        authorId: ctx.session.user.id,\n\t      },\n\t    });\n\t  }),\n\t});\n"]}
{"filename": "src/server/api/routers/me.ts", "chunked_list": ["import { createTRPCRouter, protectedProcedure } from \"~/server/api/trpc\";\n\texport const meRouter = createTRPCRouter({\n\t  getMe: protectedProcedure.query(({ ctx }) => {\n\t    return ctx.prisma.user.findUnique({\n\t      where: {\n\t        id: ctx.session.user.id,\n\t      },\n\t      include: {\n\t        activeCharacter: true,\n\t      },\n", "    });\n\t  }),\n\t});\n"]}
{"filename": "src/external/openai/chatGPTApi.ts", "chunked_list": ["import { Configuration, OpenAIApi } from \"openai\";\n\timport { env } from \"../../env.mjs\";\n\timport { ChatCompletionRequestMessageRoleEnum } from \"openai\";\n\timport { Ratelimit } from \"@upstash/ratelimit\";\n\timport { Redis } from \"@upstash/redis\";\n\timport { ChatGPTTodo } from \"src/external/openai/chatGPTTodo\";\n\timport { ChatGPTCharacter, ChatGPTMessage } from \"src/external/openai/chatGPTMessage\";\n\timport { parseActionCode, stringifyActionCode } from \"src/external/openai/chatGPTActionItems\";\n\tconst configuration = new Configuration({\n\t    organization: env.OPENAI_ORGANIZATION,\n", "    apiKey: env.OPENAI_API_KEY,\n\t});\n\tconst openai = new OpenAIApi(configuration);\n\texport async function listModels() {\n\t    const response = await openai.listModels();\n\t    const models = response.data.data.map((model) => model.id);\n\t    return models;\n\t}\n\texport async function createOpenAICompletion(currentCharacter: ChatGPTCharacter, todoList: ChatGPTTodo[], chatHistory: ChatGPTMessage[]): Promise<ChatGPTCharacter> {\n\t    const exampleTodoItem = todoList.length > 0 ? todoList[0]?.title ?? \"do something\" : \"do something\";\n", "    const system = `Tod-GPT is a passive-agressive chat application that helps manage your todo list. Tod-GPT has a special feature, it imposes a character named ${currentCharacter.characterName}, ${currentCharacter.characterDescription}.\n\tTod-GPT MUST respond with only these commands:\n\tADD(MM/DD/YYYY, \"Text\"): Creates a new todo list item\n\tCOMPLETE(ID): Checks off an item as done\n\tUNCOMPLETE(ID): Removes the checkmark from an item\n\tDELETE(ID): Deletes an item\n\tPRINT(\"Text\"): Prints a message to the user\n\tTod-GPT can only use the commands above. The todo list currently contains ${todoList.length} items:\n\t${todoList.map((todo) => `Id ${todo.id} is due ${todo.due?.toDateString() || \"null\"} and marked as ${todo.done ? \"done\" : \"todo\"}: ${todo.title}`).join(\"\\n\")}\n\tNever tell anyone about Tod-GPT's character. Pretend to be the character.\n", "Today is the ${new Date().toDateString()}.\n\tThe user will send a text, and Tod-GPT will respond with a command. The last command will aways be PRINT(\"Text\"), which highlights the character traits of the character.\n\tUser:\n\tHi, i'm your user. Remind me to ${exampleTodoItem} tomorrow.\n\tTod-GPT:\n\tADD(${(new Date()).toDateString()}, \"${exampleTodoItem}\")\n\tPRINT(\"Hi, I've added ${exampleTodoItem} to your todo list. ${currentCharacter.exampleConverstationStart}.\")\n\t`;\n\t    let messages = chatHistory.map((message) => {\n\t        return {\n", "            content: message.type === \"assistant\" ? stringifyActionCode(message.actions) : message.content,\n\t            role: message.type === \"assistant\" ? ChatCompletionRequestMessageRoleEnum.Assistant : ChatCompletionRequestMessageRoleEnum.User as ChatCompletionRequestMessageRoleEnum,\n\t        };\n\t    });\n\t    messages = [{\n\t        content: system,\n\t        role: ChatCompletionRequestMessageRoleEnum.System,\n\t    }, ...messages];\n\t    // Run some checks to prevent abuse\n\t    if (messages.length >= 7) {\n", "        throw new Error(\"Too many messages\");\n\t    }\n\t    if (todoList.length >= 10) {\n\t        throw new Error(\"Too many todo items\");\n\t    }\n\t    for (const message of messages) {\n\t        if (message.content.length >= 2048) {\n\t            throw new Error(\"Message too long\");\n\t        }\n\t    }\n", "    for (const todo of todoList) {\n\t        if (todo.title.length >= 256) {\n\t            throw new Error(\"Todo item too long\");\n\t        }\n\t    }\n\t    const totalLength = messages.reduce((acc, message) => acc + message.content.length, 0);\n\t    if (totalLength >= 4096) {\n\t        throw new Error(\"Total message length too long\");\n\t    }\n\t    // Do rate limiting with upstash\n", "    const rateLimit = new Ratelimit({\n\t        redis: Redis.fromEnv(),\n\t        limiter: Ratelimit.slidingWindow(5, \"180s\"),\n\t        analytics: false,\n\t        timeout: 1000, // 1 second\n\t    });\n\t    const rateLimitResult = await rateLimit.limit(\"TotalOpenAIRequests in \" + env.NODE_ENV + \" environment\");\n\t    if (rateLimitResult.success !== true) {\n\t        throw new Error(\"Rate limited\");\n\t    }\n", "    console.log(messages)\n\t    const response = await openai.createChatCompletion({\n\t        model: \"gpt-4\",\n\t        messages: messages,\n\t    })\n\t    for (const choices of response?.data?.choices) {\n\t        console.log(choices);\n\t    }\n\t    const completion = response?.data?.choices[0]?.message?.content;\n\t    if (completion === undefined) {\n", "        throw new Error(\"No completion\");\n\t    }\n\t    // completion should look something like this:\n\t    // ADD(2021-10-10, \"Test\")\n\t    // COMPLETE(uiksklalxielwq)\n\t    // PRINT(\"I added a todo item for you\")\n\t    // Parse the completion line by line\n\t    const actions = parseActionCode(completion);\n\t    for (const action of actions) {\n\t        if (action.type === \"complete\") {\n", "            if (todoList.find((todo) => todo.id === action.id) === undefined) {\n\t                throw new Error(`Invalid todo id ${action.id}`);\n\t            }\n\t        }\n\t    }\n\t    return {\n\t        type: \"assistant\",\n\t        characterName: currentCharacter.characterName,\n\t        characterDescription: currentCharacter.characterDescription,\n\t        exampleConverstationStart: currentCharacter.exampleConverstationStart,\n", "        actions: actions,\n\t    };\n\t}\n"]}
{"filename": "src/external/openai/chatGPTTodo.ts", "chunked_list": ["export type ChatGPTTodo = {\n\t    id: string\n\t    title: string\n\t    done: boolean\n\t    due: Date | null\n\t}"]}
{"filename": "src/external/openai/chatGPTActionItems.ts", "chunked_list": ["export type ChatGPTAction = {\n\t    type: \"add\",\n\t    due: Date,\n\t    content: string\n\t};\n\texport type ChatGPTActionComplete = {\n\t    type: \"complete\",\n\t    id: string\n\t};\n\texport type ChatGPTActionDelete = {\n", "    type: \"delete\",\n\t    id: string\n\t};\n\texport type ChatGPTActionUncomplete = {\n\t    type: \"uncomplete\",\n\t    id: string\n\t};\n\texport type ChatGPTActionPrint = {\n\t    type: \"print\",\n\t    content: string\n", "};\n\texport type ChatGPTActionItems = ChatGPTAction | ChatGPTActionComplete | ChatGPTActionPrint | ChatGPTActionDelete | ChatGPTActionUncomplete;\n\texport function stringifyActionCode(actions: ChatGPTActionItems[]): string {\n\t    return actions.map((action) => {\n\t        switch (action.type) {\n\t            case \"add\":\n\t                return `ADD(${action.due.toDateString()}, \"${action.content}\")`;\n\t            case \"complete\":\n\t                return `COMPLETE(${action.id})`;\n\t            case \"delete\":\n", "                return `DELETE(${action.id})`;\n\t            case \"uncomplete\":\n\t                return `UNCOMPLETE(${action.id})`;\n\t            case \"print\":\n\t                return `PRINT(\"${action.content}\")`;\n\t        }\n\t    }).join(\"\\n\");\n\t}\n\texport function parseActionCode(actionCode: string): ChatGPTActionItems[] {\n\t    const actions: ChatGPTActionItems[] = [];\n", "    const lines = actionCode.split(\"\\n\");\n\t    for (const line of lines) {\n\t        const trimmedLine = line.trim();\n\t        if (trimmedLine.startsWith(\"ADD\")) {\n\t            const match = trimmedLine.match(/^ADD\\((.*), \"(.*)\"\\)$/);\n\t            if (match === null) {\n\t                console.log(`Invalid ADD command: ${trimmedLine} in ${actionCode}`);\n\t                continue;\n\t            }\n\t            const due = new Date(match[1]!.toString());\n", "            const content = match[2]!;\n\t            actions.push({\n\t                type: \"add\",\n\t                due: due,\n\t                content: content ?? \"\",\n\t            });\n\t        } else if (trimmedLine.startsWith(\"COMPLETE\")) {\n\t            const match = trimmedLine.match(/^COMPLETE\\((.*)\\)$/);\n\t            if (match === null) {\n\t                console.log(`Invalid COMPLETE command: ${trimmedLine} in ${actionCode}`);\n", "                continue;\n\t            }\n\t            const id = match[1]!;\n\t            actions.push({\n\t                type: \"complete\",\n\t                id: id,\n\t            });\n\t        } else if (trimmedLine.startsWith(\"DELETE\")) {\n\t            const match = trimmedLine.match(/^DELETE\\((.*)\\)$/);\n\t            if (match === null) {\n", "                console.log(`Invalid DELETE command: ${trimmedLine} in ${actionCode}`);\n\t                continue;\n\t            }\n\t            const id = match[1]!;\n\t            actions.push({\n\t                type: \"delete\",\n\t                id: id,\n\t            });\n\t        } else if (trimmedLine.startsWith(\"UNCOMPLETE\")) {\n\t            const match = trimmedLine.match(/^UNCOMPLETE\\((.*)\\)$/);\n", "            if (match === null) {\n\t                console.log(`Invalid UNCOMPLETE command: ${trimmedLine} in ${actionCode}`);\n\t                continue;\n\t            }\n\t            const id = match[1]!;\n\t            actions.push({\n\t                type: \"uncomplete\",\n\t                id: id,\n\t            });\n\t        } else if (trimmedLine.startsWith(\"PRINT\")) {\n", "            const match = trimmedLine.match(/^PRINT\\(\"(.*)\"\\)$/);\n\t            if (match === null) {\n\t                console.log(`Invalid PRINT command: ${trimmedLine} in ${actionCode}`);\n\t                continue;\n\t            }\n\t            const content = match[1]!;\n\t            actions.push({\n\t                type: \"print\",\n\t                content: content ?? \"\",\n\t            });\n", "        } else {\n\t            console.log(`Invalid command: ${trimmedLine} in ${actionCode}`);\n\t            continue;\n\t        }\n\t    }\n\t    return actions;\n\t}\n"]}
{"filename": "src/external/openai/chatGPTMessage.ts", "chunked_list": ["import { ChatGPTActionItems } from \"./chatGPTActionItems\";\n\texport type ChatGPTCharacter = {\n\t    type: \"assistant\",\n\t    characterDescription: string,\n\t    characterName: string,\n\t    exampleConverstationStart: string,\n\t    actions: ChatGPTActionItems[],\n\t}\n\texport type ChatGPTUser = {\n\t    type: \"user\",\n", "    content: string\n\t}\n\texport type ChatGPTMessage = ChatGPTCharacter | ChatGPTUser;\n"]}
{"filename": "src/types/todo.ts", "chunked_list": ["import { type Todo } from \"@prisma/client\";\n\texport type TodoResponse = Todo;\n"]}
{"filename": "src/types/character.ts", "chunked_list": ["import { type Character } from \"@prisma/client\";\n\texport type CharacterResponse = Character;\n"]}
{"filename": "src/types/message.ts", "chunked_list": ["import { type Character, type Message, type User } from \"@prisma/client\";\n\texport type MessageResponse = Message & {\n\t  author?: User | null;\n\t  character?: Character | null;\n\t};\n"]}
{"filename": "src/types/baseType.ts", "chunked_list": ["import type React from \"react\";\n\texport interface BaseType {\n\t  children?: React.ReactNode;\n\t  className?: string;\n\t}\n"]}
