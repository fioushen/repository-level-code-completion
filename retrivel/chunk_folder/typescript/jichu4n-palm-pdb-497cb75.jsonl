{"filename": "src/memo-database.ts", "chunked_list": ["import pick from 'lodash/pick';\n\timport {\n\t  field,\n\t  SerializeOptions,\n\t  SObject,\n\t  SStringNT,\n\t  SUInt16BE,\n\t  SUInt8,\n\t} from 'serio';\n\timport {AppInfoType, DatabaseHdrType, PdbDatabase, PdbRecord} from '.';\n", "/** MemoDB sort order. */\n\texport enum MemoSortOrder {\n\t  MANUAL = 0,\n\t  ALPHABETICAL = 1,\n\t}\n\t/** MemoDB AppInfo block. */\n\texport class MemoAppInfo extends AppInfoType {\n\t  @field(SUInt16BE)\n\t  private padding2 = 0;\n\t  /** Memo sort order.\n", "   *\n\t   * New for 2.0 memo application.\n\t   */\n\t  @field(SUInt8.enum(MemoSortOrder))\n\t  sortOrder = MemoSortOrder.MANUAL;\n\t  @field(SUInt8)\n\t  private padding3 = 0;\n\t  serialize(opts?: SerializeOptions) {\n\t    if (this.sortOrder < 0 || this.sortOrder > 1) {\n\t      throw new Error(`Invalid sort order: ${this.sortOrder}`);\n", "    }\n\t    return super.serialize(opts);\n\t  }\n\t}\n\t/** A MemoDB record. */\n\texport class MemoRecord extends PdbRecord {\n\t  /** Memo content. */\n\t  @field(SStringNT)\n\t  value = '';\n\t}\n", "/** MemoDB database.\n\t *\n\t * References:\n\t *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/memo.c\n\t *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Memo.pm\n\t */\n\texport class MemoDatabase extends PdbDatabase.of(MemoRecord, MemoAppInfo) {\n\t  header = DatabaseHdrType.with({\n\t    name: 'MemoDB',\n\t    type: 'DATA',\n", "    creator: 'memo',\n\t  });\n\t}\n"]}
{"filename": "src/date-time.ts", "chunked_list": ["import {\n\t  DeserializeOptions,\n\t  SUInt16BE,\n\t  SerializableWrapper,\n\t  SerializeOptions,\n\t} from 'serio';\n\t/** Standard epoch on Palm OS -- 1904/1/1. */\n\texport const PDB_EPOCH = new Date('1904-01-01T00:00:00.000Z');\n\t/** Standard UNIX epoch. */\n\texport const UNIX_EPOCH = new Date(0);\n", "/** Epoch that a DatabaseTimestamp value is based on. */\n\texport enum EpochType {\n\t  /** Standard epoch on Palm OS -- 1904/1/1. */\n\t  PDB = 'pdb',\n\t  /** UNIX epoch -- 1970/1/1. */\n\t  UNIX = 'unix',\n\t}\n\t/** A timestamp value.\n\t *\n\t * References:\n", " *   - https://wiki.mobileread.com/wiki/PDB#PDB_Times\n\t */\n\texport class DatabaseTimestamp extends SerializableWrapper<Date> {\n\t  /** JavaScript Date value corresponding to the time. */\n\t  value: Date = new Date();\n\t  /** The epoch to use when serializing this date. */\n\t  epochType = EpochType.PDB;\n\t  /** Parses a PDB timestamp.\n\t   *\n\t   * If the time has the top bit set, it's an unsigned 32-bit number counting\n", "   * from 1st Jan 1904.\n\t   *\n\t   * If the time has the top bit clear, it's a signed 32-bit number counting\n\t   * from 1st Jan 1970.\n\t   */\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    let ts = buffer.readUInt32BE();\n\t    if (ts === 0 || ts & (1 << 31)) {\n\t      this.epochType = EpochType.PDB;\n\t      this.value.setTime(PDB_EPOCH.getTime() + ts * 1000);\n", "    } else {\n\t      this.epochType = EpochType.UNIX;\n\t      ts = buffer.readInt32BE();\n\t      this.value.setTime(ts * 1000);\n\t    }\n\t    return 4;\n\t  }\n\t  serialize(opts?: SerializeOptions) {\n\t    const buffer = Buffer.alloc(4);\n\t    switch (this.epochType) {\n", "      case EpochType.PDB:\n\t        buffer.writeUInt32BE(\n\t          (this.value.getTime() - PDB_EPOCH.getTime()) / 1000\n\t        );\n\t        break;\n\t      case EpochType.UNIX:\n\t        buffer.writeInt32BE(this.value.getTime() / 1000);\n\t        break;\n\t      default:\n\t        throw new Error(`Unknown epoch type: ${this.epochType}`);\n", "    }\n\t    return buffer;\n\t  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n\t    return 4;\n\t  }\n\t}\n\t/** DatabaseTimestamp corresponding to epochDate. */\n\texport const EPOCH_TIMESTAMP = DatabaseTimestamp.of(PDB_EPOCH);\n\t/** A date (year, month, DOM) encoded as a 16-bit integer.\n", " *\n\t * There is no timezone information in the serialized form, so we assume UTC\n\t * when converting to / from JavaScript Date objects.\n\t */\n\texport class DatabaseDate extends SerializableWrapper<Date> {\n\t  /** Year. */\n\t  year = PDB_EPOCH.getUTCFullYear();\n\t  /** Month (Jan = 0, Dec = 11). */\n\t  month = 0;\n\t  /** Day of the month (1st = 1). */\n", "  dayOfMonth = 1;\n\t  get value() {\n\t    return new Date(Date.UTC(this.year, this.month, this.dayOfMonth));\n\t  }\n\t  set value(newValue: Date) {\n\t    this.year = newValue.getUTCFullYear();\n\t    this.month = newValue.getUTCMonth();\n\t    this.dayOfMonth = newValue.getUTCDate();\n\t  }\n\t  serialize(opts?: SerializeOptions) {\n", "    if (this.year < PDB_EPOCH.getUTCFullYear()) {\n\t      throw new Error(`Invalid year: ${this.year}`);\n\t    }\n\t    if (this.month < 0 || this.month > 11) {\n\t      throw new Error(`Invalid month: ${this.month}`);\n\t    }\n\t    if (this.dayOfMonth < 1 || this.dayOfMonth > 31) {\n\t      throw new Error(`Invalid day of month: ${this.dayOfMonth}`);\n\t    }\n\t    return SUInt16BE.of(\n", "      ((this.year - PDB_EPOCH.getUTCFullYear()) << 9) |\n\t        ((this.month + 1) << 5) |\n\t        this.dayOfMonth\n\t    ).serialize();\n\t  }\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    const {value: v} = SUInt16BE.from(buffer, opts);\n\t    // upper 7 bits => year since 1904\n\t    this.year = ((v >> 9) & 0x7f) + PDB_EPOCH.getUTCFullYear();\n\t    // 4 bits => month\n", "    this.month = ((v >> 5) & 0x0f) - 1;\n\t    // 5 bits => date\n\t    this.dayOfMonth = v & 0x1f;\n\t    return this.getSerializedLength(opts);\n\t  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n\t    return 2;\n\t  }\n\t  toJSON() {\n\t    return this.value.toISOString();\n", "  }\n\t}\n\t/** DatabaseDate wrapper where the value may be unspecified (indicated by 0xff). */\n\texport class OptionalDatabaseDate extends SerializableWrapper<DatabaseDate | null> {\n\t  /** DatabaseDate value, or null if unspecified.*/\n\t  value: DatabaseDate | null = null;\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    const dateValue = buffer.readUInt16BE();\n\t    this.value = dateValue === 0xffff ? null : DatabaseDate.from(buffer, opts);\n\t    return this.getSerializedLength(opts);\n", "  }\n\t  serialize(opts?: SerializeOptions) {\n\t    return this.value ? this.value.serialize(opts) : Buffer.of(0xff, 0xff);\n\t  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n\t    return 2;\n\t  }\n\t}\n"]}
{"filename": "src/record.ts", "chunked_list": ["import {field, SBuffer, Serializable, SObject} from 'serio';\n\timport {EntryType, RecordEntryType, RsrcEntryType} from './database-header';\n\t/** Base class of records in a PDB or PRC database. */\n\texport abstract class Record<EntryT extends EntryType> extends Serializable {\n\t  /** Record entry stored in the database header. */\n\t  abstract entry: EntryT;\n\t}\n\t/** Base class of records in a PDB database. */\n\texport abstract class PdbRecord\n\t  extends SObject\n", "  implements Record<RecordEntryType>\n\t{\n\t  entry = new RecordEntryType();\n\t  toJSON() {\n\t    return {\n\t      entry: this.entry,\n\t      ...super.toJSON(),\n\t    };\n\t  }\n\t}\n", "/** Base class of records in a PRC database. */\n\texport abstract class PrcRecord\n\t  extends SObject\n\t  implements Record<RsrcEntryType>\n\t{\n\t  entry = new RsrcEntryType();\n\t  toJSON() {\n\t    return {\n\t      entry: this.entry,\n\t      ...super.toJSON(),\n", "    };\n\t  }\n\t}\n\t/** PDB database record that simply stores record data in a Buffer. */\n\texport class RawPdbRecord extends PdbRecord {\n\t  @field(SBuffer)\n\t  data = Buffer.of();\n\t}\n\t/** PRC database record that simply stores record data in a Buffer. */\n\texport class RawPrcRecord extends PrcRecord {\n", "  @field(SBuffer)\n\t  data = Buffer.of();\n\t}\n"]}
{"filename": "src/palmdoc-database.ts", "chunked_list": ["import {\n\t  decodeString,\n\t  DeserializeOptions,\n\t  encodeString,\n\t  Serializable,\n\t  SerializeOptions,\n\t  SObject,\n\t} from 'serio';\n\timport {SmartBuffer} from 'smart-buffer';\n\timport {DatabaseHdrType, DEFAULT_ENCODING, PdbDatabase, RawPdbRecord} from '.';\n", "/** PalmDOC document. */\n\texport class PalmDoc extends SObject {\n\t  /** Document name (typically the file name). */\n\t  name = 'doc.txt';\n\t  /** Text content. */\n\t  text = '';\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    opts = {encoding: DEFAULT_ENCODING, ...opts};\n\t    const numBytes = this.db.deserialize(buffer, opts);\n\t    this.name = this.db.header.name;\n", "    if (this.db.records.length === 0) {\n\t      throw new Error(`PalmDOC metadata record missing`);\n\t    }\n\t    this.metadata.deserialize(this.db.records[0].data, opts);\n\t    this.textInDb = this.db.records\n\t      .slice(1, this.metadata.numRecords + 1)\n\t      .map(({data: data}) =>\n\t        decodeString(\n\t          this.metadata.isCompressed ? PalmDoc.decompress(data) : data,\n\t          opts\n", "        )\n\t      )\n\t      .join('');\n\t    this.text = this.textInDb;\n\t    return numBytes;\n\t  }\n\t  serialize(opts?: PalmDocSerializeOptions) {\n\t    opts = {encoding: DEFAULT_ENCODING, ...opts};\n\t    this.db.header.name = this.name;\n\t    if (this.text !== this.textInDb) {\n", "      this.db.records = [];\n\t      // Split text into 4096-byte chunks, compress, and add to DB.\n\t      const encodedText = encodeString(this.text, opts);\n\t      for (let i = 0; i < encodedText.length; i += PALM_DOC_RECORD_SIZE) {\n\t        const encodedTextChunk = encodedText.subarray(\n\t          i,\n\t          i + PALM_DOC_RECORD_SIZE\n\t        );\n\t        const record = RawPdbRecord.with({\n\t          data: opts?.enableCompression\n", "            ? PalmDoc.compress(encodedTextChunk)\n\t            : encodedTextChunk,\n\t        });\n\t        this.db.records.push(record);\n\t      }\n\t      // Add metadata record.\n\t      this.metadata.isCompressed = !!opts?.enableCompression;\n\t      this.metadata.textLength = this.text.length;\n\t      this.metadata.numRecords = this.db.records.length;\n\t      if (\n", "        this.metadata.position < 0 ||\n\t        this.metadata.position >= this.text.length\n\t      ) {\n\t        this.metadata.position = 0;\n\t      }\n\t      const metadataRecord = RawPdbRecord.with({\n\t        data: this.metadata.serialize(opts),\n\t      });\n\t      this.db.records.unshift(metadataRecord);\n\t      this.textInDb = this.text;\n", "    }\n\t    return this.db.serialize(opts);\n\t  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n\t    return this.serialize(opts).length;\n\t  }\n\t  /** Database corresponding to this document.\n\t   *\n\t   * Updated during serialize().\n\t   */\n", "  private readonly db = new PalmDocDatabase();\n\t  /** Text corresponding to db. */\n\t  private textInDb = '';\n\t  /** Metadata stored in the first record of a PalmDOC database. */\n\t  private metadata: PalmDocMetadata = new PalmDocMetadata();\n\t  /** PalmDOC LZ77 decompression algorithm.\n\t   *\n\t   * References:\n\t   *   - https://metacpan.org/release/EBook-Tools/source/lib/EBook/Tools/PalmDoc.pm\n\t   */\n", "  static decompress(buffer: Buffer): Buffer {\n\t    const reader = SmartBuffer.fromBuffer(buffer);\n\t    const writer = new SmartBuffer();\n\t    while (reader.remaining() > 0) {\n\t      const byte1 = reader.readUInt8();\n\t      if (byte1 === 0x00) {\n\t        // 0x00: \"1 literal\" copy that byte unmodified to the decompressed stream.\n\t        writer.writeUInt8(byte1);\n\t      } else if (byte1 <= 0x08) {\n\t        // 0x01 to 0x08: \"literals\": the byte is interpreted as a count from 1 to\n", "        // 8, and that many literals are copied unmodified from the compressed\n\t        // stream to the decompressed stream.\n\t        writer.writeBuffer(reader.readBuffer(byte1));\n\t      } else if (byte1 <= 0x7f) {\n\t        // 0x09 to 0x7f: \"1 literal\" copy that byte unmodified to the decompressed\n\t        // stream.\n\t        writer.writeUInt8(byte1);\n\t      } else if (byte1 <= 0xbf) {\n\t        // 0x80 to 0xbf: \"length, distance\" pair: the 2 leftmost bits of this byte\n\t        // ('10') are discarded, and the following 6 bits are combined with the 8\n", "        // bits of the next byte to make a 14 bit \"distance, length\" item. Those\n\t        // 14 bits are broken into 11 bits of distance backwards from the current\n\t        // location in the uncompressed text, and 3 bits of length to copy from\n\t        // that point (copying n+3 bytes, 3 to 10 bytes).\n\t        const byte2 = reader.readUInt8();\n\t        const distance =\n\t          ((byte1 & 0x3f) << 5) | // lower 6 bits\n\t          ((byte2 & 0xf8) >> 3); // upper 5 bits\n\t        const length =\n\t          (byte2 & 0x7) + // lower 3 bits\n", "          3;\n\t        if (writer.writeOffset - distance < 0) {\n\t          throw new Error(\n\t            'Invalid encoding: ' +\n\t              `distance = ${distance}, length = ${length}, decoded text length = ${writer.writeOffset}`\n\t          );\n\t        }\n\t        writer.readOffset = writer.writeOffset - distance;\n\t        if (writer.readOffset + length < writer.writeOffset) {\n\t          writer.writeBuffer(writer.readBuffer(length));\n", "        } else {\n\t          // It's possible that the \"length, distance\" pair references bytes that\n\t          // have not been decoded yet.\n\t          for (let i = 0; i < length; ++i) {\n\t            writer.writeUInt8(writer.readUInt8());\n\t          }\n\t        }\n\t      } else if (byte1 <= 0xff) {\n\t        // 0xc0 to 0xff: \"byte pair\": this byte is decoded into 2 characters: a\n\t        // space character, and a letter formed from this byte XORed with 0x80.\n", "        writer.writeUInt8(' '.charCodeAt(0));\n\t        writer.writeUInt8(byte1 ^ 0x80);\n\t      }\n\t    }\n\t    return writer.toBuffer();\n\t  }\n\t  /** PalmDOC LZ77 compression algorithm.\n\t   *\n\t   * References:\n\t   *   - https://metacpan.org/release/EBook-Tools/source/lib/EBook/Tools/PalmDoc.pm\n", "   */\n\t  static compress(buffer: Buffer): Buffer {\n\t    const reader = SmartBuffer.fromBuffer(buffer);\n\t    const writer = new SmartBuffer();\n\t    while (reader.remaining() > 0) {\n\t      const {readOffset} = reader;\n\t      // 1. Try 2-byte \"length, distance pair\" encoding.\n\t      if (readOffset >= 3 && reader.remaining() >= 3) {\n\t        let chunk = reader.readBuffer(Math.min(10, reader.remaining()));\n\t        // Prev occurrence must be within 2047 byte window.\n", "        const windowStartPos = Math.max(0, readOffset - 2047);\n\t        const window = buffer.subarray(windowStartPos, readOffset);\n\t        let prevOccurrencePos = -1;\n\t        do {\n\t          prevOccurrencePos = window.lastIndexOf(chunk);\n\t          if (prevOccurrencePos >= 0) {\n\t            prevOccurrencePos += windowStartPos;\n\t            break;\n\t          } else {\n\t            chunk = chunk.subarray(0, chunk.length - 1);\n", "          }\n\t        } while (chunk.length >= 3);\n\t        if (prevOccurrencePos >= 0) {\n\t          const distance = readOffset - prevOccurrencePos;\n\t          if (distance < 0 || distance > 2047) {\n\t            throw new Error(\n\t              `Distance out of range: ${distance}\\n` +\n\t                `readOffset = ${readOffset}, ` +\n\t                `prevOccurrencePos = ${prevOccurrencePos}, ` +\n\t                `chunk = \"${chunk.toString('latin1')}\"\\n` +\n", "                'This is a programming error. Please file an issue!'\n\t            );\n\t          }\n\t          const {length} = chunk;\n\t          if (length < 3 || length > 10) {\n\t            throw new Error(\n\t              `Length out of range: ${length}\\n` +\n\t                'This is a programming error. Please file an issue!'\n\t            );\n\t          }\n", "          const byte1 =\n\t            0x80 | // upper two bits = '10'\n\t            ((distance >> 5) & 0x3f); // upper 6 bits of distance as 11-bit integer\n\t          writer.writeUInt8(byte1);\n\t          const byte2 =\n\t            ((distance & 0x1f) << 3) | // lower 5 bits of distance\n\t            ((length - 3) & 0x7); // length as 3-bit integer\n\t          writer.writeUInt8(byte2);\n\t          reader.readOffset = readOffset + length;\n\t          continue;\n", "        } else {\n\t          reader.readOffset = readOffset;\n\t          // fall through\n\t        }\n\t      }\n\t      // Consume next byte.\n\t      let byte1 = reader.readUInt8();\n\t      // 2. Try 2-byte \"space, char XOR 0x80\" encoding.\n\t      if (byte1 === ' '.charCodeAt(0) && reader.remaining() >= 1) {\n\t        const byte2 = reader.readUInt8();\n", "        if (byte2 >= 0x40 && byte2 <= 0x7f) {\n\t          writer.writeUInt8(byte2 ^ 0x80);\n\t          continue;\n\t        } else {\n\t          --reader.readOffset;\n\t          // fall through\n\t        }\n\t      }\n\t      // 3. Try 1-byte literal encoding.\n\t      if (byte1 === 0 || (byte1 >= 0x9 && byte1 <= 0x7f)) {\n", "        writer.writeUInt8(byte1);\n\t        continue;\n\t      }\n\t      // 4. Fall through to multi-byte literal encoding.\n\t      {\n\t        const chunk = reader.readBuffer(Math.min(7, reader.remaining()));\n\t        writer.writeUInt8(chunk.length + 1); // length including byte1\n\t        writer.writeUInt8(byte1);\n\t        writer.writeBuffer(chunk);\n\t        continue;\n", "      }\n\t    }\n\t    return writer.toBuffer();\n\t  }\n\t}\n\t/** Serialization options for PalmDoc. */\n\texport interface PalmDocSerializeOptions extends SerializeOptions {\n\t  /** Whether to compress the text. */\n\t  enableCompression?: boolean;\n\t}\n", "/** Maximum size of each record containing text. */\n\tconst PALM_DOC_RECORD_SIZE = 4096;\n\t/** Metadata stored in the first record of a PalmDOC database. */\n\texport class PalmDocMetadata extends Serializable {\n\t  /** Whether the text is compressed. */\n\t  isCompressed = true;\n\t  /** Uncompressed length of the text. */\n\t  textLength = 0;\n\t  /** Number of records used for storing text. */\n\t  numRecords = 0;\n", "  /** Current reading position, as an offset into the uncompressed text. */\n\t  position = 0;\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    const reader = SmartBuffer.fromBuffer(buffer);\n\t    const compressionLevel = reader.readUInt16BE();\n\t    switch (compressionLevel) {\n\t      case 1:\n\t        this.isCompressed = false;\n\t        break;\n\t      case 2:\n", "        this.isCompressed = true;\n\t        break;\n\t      default:\n\t        throw new Error(`Unknown compression level: ${compressionLevel}`);\n\t    }\n\t    reader.readUInt16BE(); // Padding bytes\n\t    this.textLength = reader.readUInt32BE();\n\t    this.numRecords = reader.readUInt16BE();\n\t    const recordSize = reader.readUInt16BE();\n\t    if (recordSize !== PALM_DOC_RECORD_SIZE) {\n", "      throw new Error(`Unexpected record size: ${recordSize}`);\n\t    }\n\t    this.position = reader.readUInt32BE();\n\t    return reader.readOffset;\n\t  }\n\t  serialize(opts?: SerializeOptions) {\n\t    const writer = SmartBuffer.fromSize(this.getSerializedLength(opts));\n\t    writer.writeUInt16BE(this.isCompressed ? 2 : 1);\n\t    writer.writeUInt16BE(0); // Padding bytes\n\t    writer.writeUInt32BE(this.textLength);\n", "    writer.writeUInt16BE(this.numRecords);\n\t    writer.writeUInt16BE(PALM_DOC_RECORD_SIZE);\n\t    writer.writeUInt32BE(this.position);\n\t    return writer.toBuffer();\n\t  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n\t    return 16;\n\t  }\n\t}\n\t/** PalmDOC database.*/\n", "export class PalmDocDatabase extends PdbDatabase.of(RawPdbRecord) {\n\t  header = DatabaseHdrType.with({\n\t    name: 'Document',\n\t    type: 'TEXt',\n\t    creator: 'REAd',\n\t  });\n\t}\n"]}
{"filename": "src/database-header.ts", "chunked_list": ["import {\n\t  bitfield,\n\t  field,\n\t  SBitmask,\n\t  Serializable,\n\t  SObject,\n\t  SStringNT,\n\t  SUInt16BE,\n\t  SUInt32BE,\n\t  SUInt8,\n", "} from 'serio';\n\timport {DatabaseTimestamp, EPOCH_TIMESTAMP} from './date-time';\n\timport {LocalId, RecordId, SDynamicArray, TypeId} from './util';\n\timport pick from 'lodash/pick';\n\t/** Maximum length of database names - 31 chars + 1 NUL byte.\n\t *\n\t * References:\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataMgr.h#L72\n\t */\n\texport const DB_NAME_LENGTH = 32;\n", "/** Database header.\n\t *\n\t * References:\n\t *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataPrv.h#L67\n\t */\n\texport class DatabaseHdrType extends SObject {\n\t  /** Database name. */\n\t  @field(SStringNT.ofLength(DB_NAME_LENGTH))\n\t  name = '';\n", "  /** Database attribute flags. */\n\t  @field()\n\t  attributes: DatabaseAttrs = new DatabaseAttrs();\n\t  /** Database version (integer). */\n\t  @field(SUInt16BE)\n\t  version = 0;\n\t  /** Database creation timestamp. */\n\t  @field()\n\t  creationDate = new DatabaseTimestamp();\n\t  /** Database modification timestamp. */\n", "  @field()\n\t  modificationDate = new DatabaseTimestamp();\n\t  /** Last backup timestamp. */\n\t  @field()\n\t  lastBackupDate: DatabaseTimestamp = EPOCH_TIMESTAMP;\n\t  /** Modification number (integer). */\n\t  @field(SUInt32BE)\n\t  modificationNumber = 0;\n\t  /** Offset to AppInfo block. */\n\t  @field(LocalId)\n", "  appInfoId = 0;\n\t  /** Offset to SortInfo block. */\n\t  @field(LocalId)\n\t  sortInfoId = 0;\n\t  /** Database type identifier (max 4 bytes). */\n\t  @field(TypeId)\n\t  type = '';\n\t  /** Database creator identifier (max 4 bytes). */\n\t  @field(TypeId)\n\t  creator = '';\n", "  /** Seed for generating record IDs. */\n\t  @field(SUInt32BE)\n\t  uniqueIdSeed = 0;\n\t}\n\t/** Record entry in PDB files.\n\t *\n\t * References:\n\t *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataPrv.h#L23\n\t */\n", "export class RecordEntryType extends SObject {\n\t  /** Offset to raw record data. */\n\t  @field(LocalId)\n\t  localChunkId = 0;\n\t  /** Record attributes. */\n\t  @field()\n\t  attributes = new RecordAttrs();\n\t  /** Unique ID of the record.\n\t   *\n\t   * Valid records should have a non-zero unique ID.\n", "   */\n\t  @field(RecordId)\n\t  uniqueId = 0;\n\t}\n\t/** Resource entry in PRC files.\n\t *\n\t * References:\n\t *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataPrv.h#L36\n\t */\n", "export class RsrcEntryType extends SObject {\n\t  /** Resource type identifier (max 4 bytes). */\n\t  @field(TypeId)\n\t  type = '';\n\t  /** Resource ID. */\n\t  @field(SUInt16BE)\n\t  resourceId = 0;\n\t  /** Offset to raw record data. */\n\t  @field(LocalId)\n\t  localChunkId = 0;\n", "}\n\t/** Union type representing any record entry type. */\n\texport type EntryType = RecordEntryType | RsrcEntryType;\n\t/** Record or resource entry list. */\n\texport interface RecordListType<EntryT extends EntryType> extends Serializable {\n\t  /** Array of record or resource entries. */\n\t  values: Array<EntryT>;\n\t}\n\t/** Record entry list in PDB databases.\n\t *\n", " * References:\n\t *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataPrv.h#L51\n\t */\n\texport class PdbRecordListType\n\t  extends SObject\n\t  implements RecordListType<RecordEntryType>\n\t{\n\t  /** Offset of next PdbRecordListType structure.\n\t   *\n", "   * We don't support multiple RecordListTypes, so this must always be 0. See\n\t   * page 17 of the Palm File Format Specification for more details.\n\t   */\n\t  @field(SUInt32BE)\n\t  private readonly nextListId = 0;\n\t  /** Array of record entries. */\n\t  @field(SDynamicArray.of(SUInt16BE, RecordEntryType))\n\t  values: Array<RecordEntryType> = [];\n\t  @field(SUInt16BE)\n\t  private readonly padding1 = 0;\n", "}\n\t/** Resource entry list in PRC databases.\n\t *\n\t * References:\n\t *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataPrv.h#L51\n\t */\n\texport class PrcRecordListType\n\t  extends SObject\n\t  implements RecordListType<RsrcEntryType>\n", "{\n\t  /** Offset of next PrcRecordListType structure.\n\t   *\n\t   * We don't support multiple RecordListTypes, so this must always be 0. See\n\t   * page 17 of the Palm File Format Specification for more details.\n\t   */\n\t  @field(SUInt32BE)\n\t  private readonly nextListId = 0;\n\t  /** Array of resource entries. */\n\t  @field(SDynamicArray.of(SUInt16BE, RsrcEntryType))\n", "  values: Array<RsrcEntryType> = [];\n\t  @field(SUInt16BE)\n\t  private readonly padding1 = 0;\n\t}\n\t/** Database attribute flags.\n\t *\n\t * References:\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-5r4/include/Core/System/DataMgr.h\n\t *   - https://github.com/madsen/Palm-PDB/blob/master/lib/Palm/PDB.pm\n\t */\n", "export class DatabaseAttrs extends SBitmask.of(SUInt16BE) {\n\t  /** Database not closed properly. */\n\t  @bitfield(1)\n\t  open = false;\n\t  @bitfield(3)\n\t  private unused1 = 0;\n\t  /** This database (resource or record) is associated with the application\n\t   * with the same creator. It will be beamed and copied along with the\n\t   * application. */\n\t  @bitfield(1)\n", "  bundle = false;\n\t  /** This database (resource or record) is recyclable: it will be deleted Real\n\t   * Soon Now, generally the next time the database is closed. */\n\t  @bitfield(1)\n\t  recyclable = false;\n\t  /** This data database (not applicable for executables) can be \"launched\" by\n\t   * passing its name to it's owner app ('appl' database with same creator)\n\t   * using the sysAppLaunchCmdOpenNamedDB action code. */\n\t  @bitfield(1)\n\t  launchableData = false;\n", "  /** This database should generally be hidden from view.\n\t   *\n\t   * Used to hide some apps from the main view of the launcher for example. For\n\t   * data (non-resource) databases, this hides the record count within the\n\t   * launcher info screen. */\n\t  @bitfield(1)\n\t  hidden = false;\n\t  /** This database is used for file stream implementation. */\n\t  @bitfield(1)\n\t  stream = false;\n", "  /** This database should not be copied to */\n\t  @bitfield(1)\n\t  copyPrevention = false;\n\t  /** Device requires a reset after this database is installed. */\n\t  @bitfield(1)\n\t  resetAfterInstall = false;\n\t  /** This tells the backup conduit that it's OK for it to install a newer version\n\t   * of this database with a different name if the current database is open. This\n\t   * mechanism is used to update the Graffiti Shortcuts database, for example.\n\t   */\n", "  @bitfield(1)\n\t  okToInstallNewer = false;\n\t  /** Set if database should be backed up to PC if no app-specific synchronization\n\t   * conduit has been supplied. */\n\t  @bitfield(1)\n\t  backup = false;\n\t  /** Set if Application Info block is dirty.\n\t   *\n\t   * Optionally supported by an App's conduit. */\n\t  @bitfield(1)\n", "  appInfoDirty = false;\n\t  /** Read Only database. */\n\t  @bitfield(1)\n\t  readOnly = false;\n\t  /** Whether this is a resource database (i.e. PRC). */\n\t  @bitfield(1)\n\t  resDB = false;\n\t}\n\t/** Record attribute flags in PDB files.\n\t *\n", " * In the DLP protocol, we use one byte to store record attribute flags and\n\t * another byte to store the record category. However, in PDB files, we use a\n\t * single byte is used to store both attribute flags and the record category.\n\t *\n\t * This presents a problem: there are 5 record attributes (namely delete, dirty,\n\t * busy, secret, and archive), leaving 3 bits unused, but we need 4 bits to\n\t * store the record category. So the lowest 4 bits are overloaded, but the\n\t * exactly how differs among existing open source implementations:\n\t *\n\t * In pilot-link:\n", " *   - Upper 4 bits store the first 4 record attributes (delete, dirty, busy, secret)\n\t *   - Lower 4 bits store the record category; there's no archive bit\n\t *\n\t * In ColdSync:\n\t *   - If the record is busy, bit 5 stores the archive flag and the lowest 3\n\t *     bits are unused.\n\t *   - If the record is not busy, the lowest 4 bits store the category.\n\t *\n\t * In the Palm::PDB Perl module:\n\t *   - If the record is deleted or busy, bit 5 stores the archive flag and the\n", " *     lowest 3 bits are unused.\n\t *   - If the record is neither deleted or busy, the lowest 4 bits store the\n\t *     category.\n\t *\n\t * Here we've chosen to follow the Palm::PDB Perl module's implementation, as it\n\t * is the most flexible.\n\t *\n\t * References:\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-5r4/include/Core/System/DataMgr.h#L44\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-5r4/include/Core/System/DLCommon.h#L44\n", " *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/pi-file.c#L670\n\t *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/pi-file.c#L479\n\t *   - https://github.com/dwery/coldsync/blob/master/libpdb/pdb.c#L96\n\t *   - https://metacpan.org/dist/Palm-PDB/source/lib/Palm/PDB.pm#L428\n\t */\n\texport class RecordAttrs extends SBitmask.of(SUInt8) {\n\t  /** Record has been deleted. */\n\t  @bitfield(1)\n\t  delete = false;\n\t  /** Record has been modified. */\n", "  @bitfield(1)\n\t  dirty = false;\n\t  /** Record currently in use.\n\t   *\n\t   * This bit may also indicate the record has been deleted -- see comments in\n\t   * https://github.com/dwery/coldsync/blob/master/include/pdb.h .\n\t   */\n\t  @bitfield(1)\n\t  busy = false;\n\t  /** \"Secret\" record - password protected. */\n", "  @bitfield(1)\n\t  secret = false;\n\t  @bitfield(4)\n\t  private lowest4bits = 0;\n\t  /** Record is archived.\n\t   *\n\t   * Only available if deleted or busy.\n\t   */\n\t  get archive() {\n\t    if (this.delete || this.busy) {\n", "      return Boolean(this.lowest4bits & 0b1000);\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\t  set archive(newValue: boolean) {\n\t    if (!(this.delete || this.busy)) {\n\t      throw new Error(\n\t        `Attempting to set archive = ${newValue} ` +\n\t          `on record that is neither deleted nor busy`\n", "      );\n\t    }\n\t    this.lowest4bits = newValue\n\t      ? this.lowest4bits | 0b1000\n\t      : this.lowest4bits & 0b0111;\n\t  }\n\t  /** Record category.\n\t   *\n\t   * Only available if NOT deleted or busy.\n\t   */\n", "  get category() {\n\t    if (this.delete || this.busy) {\n\t      return 0;\n\t    } else {\n\t      return this.lowest4bits;\n\t    }\n\t  }\n\t  set category(newValue: number) {\n\t    if (this.delete || this.busy) {\n\t      const recordState =\n", "        this.delete && this.busy\n\t          ? 'deleted and busy'\n\t          : this.delete\n\t          ? 'deleted'\n\t          : 'busy';\n\t      throw new Error(\n\t        `Attempting to set category ${newValue} on record ` +\n\t          `that is currently ${recordState}`\n\t      );\n\t    }\n", "    this.lowest4bits = newValue & 0b1111;\n\t  }\n\t}\n"]}
{"filename": "src/todo-database.ts", "chunked_list": ["import pick from 'lodash/pick';\n\timport {\n\t  DeserializeOptions,\n\t  field,\n\t  SerializeOptions,\n\t  SStringNT,\n\t  SUInt16BE,\n\t  SUInt8,\n\t} from 'serio';\n\timport {\n", "  AppInfoType,\n\t  DatabaseDate,\n\t  DatabaseHdrType,\n\t  OptionalDatabaseDate,\n\t  PdbDatabase,\n\t  PdbRecord,\n\t} from '.';\n\t/** ToDoDB item sort order. */\n\texport enum ToDoSortOrder {\n\t  MANUAL = 0,\n", "  PRIORITY = 1,\n\t}\n\t/** ToDoDB AppInfo block. */\n\texport class ToDoAppInfo extends AppInfoType {\n\t  /** Not sure what this is ¯\\_(ツ)_/¯ */\n\t  @field(SUInt16BE)\n\t  private dirty = 0;\n\t  /** Item sort order. */\n\t  @field(SUInt8.enum(ToDoSortOrder))\n\t  sortOrder = ToDoSortOrder.MANUAL;\n", "  @field(SUInt8)\n\t  private padding2 = 0;\n\t  serialize(opts?: SerializeOptions) {\n\t    if (this.sortOrder < 0 || this.sortOrder > 1) {\n\t      throw new Error(`Invalid sort order: ${this.sortOrder}`);\n\t    }\n\t    return super.serialize(opts);\n\t  }\n\t}\n\t/** A ToDoDB record. */\n", "export class ToDoRecord extends PdbRecord {\n\t  /** Due date of the item (may be empty if there is no due date). */\n\t  @field(OptionalDatabaseDate)\n\t  dueDate: DatabaseDate | null = null;\n\t  /** Attributes byte. */\n\t  @field(SUInt8)\n\t  private attrs = 0;\n\t  /** Whether the item is completed. Stored inside attrs. */\n\t  isCompleted = false;\n\t  /** Priority of the item (max 127). Stored inside attrs. */\n", "  priority = 0;\n\t  /** Main description. */\n\t  @field(SStringNT)\n\t  description = '';\n\t  /** Additional note. */\n\t  @field(SStringNT)\n\t  note = '';\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    const readOffset = super.deserialize(buffer, opts);\n\t    this.isCompleted = !!(this.attrs & 0x80);\n", "    this.priority = this.attrs & 0x7f;\n\t    return readOffset;\n\t  }\n\t  serialize(opts?: SerializeOptions) {\n\t    if (this.priority < 0 || this.priority > 0x7f) {\n\t      throw new Error(`Invalid priority: ${this.priority}`);\n\t    }\n\t    this.attrs = this.priority;\n\t    if (this.isCompleted) {\n\t      this.attrs |= 0x80;\n", "    }\n\t    return super.serialize(opts);\n\t  }\n\t}\n\t/** ToDoDB database.\n\t *\n\t * References:\n\t *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/todo.c\n\t *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/ToDo.pm\n\t */\n", "export class ToDoDatabase extends PdbDatabase.of(ToDoRecord, ToDoAppInfo) {\n\t  header = DatabaseHdrType.with({\n\t    name: 'ToDoDB',\n\t    type: 'DATA',\n\t    creator: 'todo',\n\t  });\n\t}\n"]}
{"filename": "src/address-database.ts", "chunked_list": ["import groupBy from 'lodash/groupBy';\n\timport pick from 'lodash/pick';\n\timport {\n\t  bitfield,\n\t  DeserializeOptions,\n\t  field,\n\t  SArray,\n\t  SBitmask,\n\t  SerializeOptions,\n\t  SStringNT,\n", "  SUInt16BE,\n\t  SUInt32BE,\n\t  SUInt8,\n\t} from 'serio';\n\timport {AppInfoType, DatabaseHdrType, PdbDatabase, PdbRecord} from '.';\n\t/** Maximum length of address field labels - 15 + 1 NUL byte. */\n\texport const ADDRESS_FIELD_LABEL_LENGTH = 16;\n\t/** Countries and regions in AddressDB.\n\t *\n\t * References:\n", " *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Address.pm#L170\n\t */\n\texport enum AddressCountry {\n\t  AUSTRALIA = 0,\n\t  AUSTRIA = 1,\n\t  BELGIUM = 2,\n\t  BRAZIL = 3,\n\t  CANADA = 4,\n\t  DENMARK = 5,\n\t  FINLAND = 6,\n", "  FRANCE = 7,\n\t  GERMANY = 8,\n\t  HONG_KONG = 9,\n\t  ICELAND = 10,\n\t  IRELAND = 11,\n\t  ITALY = 12,\n\t  JAPAN = 13,\n\t  LUXEMBOURG = 14,\n\t  MEXICO = 15,\n\t  NETHERLANDS = 16,\n", "  NEW_ZEALAND = 17,\n\t  NORWAY = 18,\n\t  SPAIN = 19,\n\t  SWEDEN = 20,\n\t  SWITZERLAND = 21,\n\t  UNITED_KINGDOM = 22,\n\t  UNITED_STATES = 23,\n\t}\n\t/** Field types in AddressDB.\n\t *\n", " * References:\n\t *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Address.pm#L424\n\t */\n\texport enum AddressFieldType {\n\t  LAST_NAME = 0,\n\t  FIRST_NAME = 1,\n\t  COMPANY = 2,\n\t  PHONE_1 = 3,\n\t  PHONE_2 = 4,\n\t  PHONE_3 = 5,\n", "  PHONE_4 = 6,\n\t  PHONE_5 = 7,\n\t  ADDRESS = 8,\n\t  CITY = 9,\n\t  STATE = 10,\n\t  ZIP_CODE = 11,\n\t  COUNTRY = 12,\n\t  TITLE = 13,\n\t  CUSTOM_1 = 14,\n\t  CUSTOM_2 = 15,\n", "  CUSTOM_3 = 16,\n\t  CUSTOM_4 = 17,\n\t  NOTE = 18,\n\t  PHONE_6 = 19,\n\t  PHONE_7 = 20,\n\t  PHONE_8 = 21,\n\t}\n\t/** Number of address fields (and field types). */\n\texport const NUM_ADDRESS_FIELDS = 22;\n\t/** Standard phone number field types in AddressDB.\n", " *\n\t * References:\n\t *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Address.pm#L159\n\t */\n\texport enum PhoneNumberType {\n\t  WORK = 0,\n\t  HOME = 1,\n\t  FAX = 2,\n\t  OTHER = 3,\n\t  EMAIL = 4,\n", "  MAIN = 5,\n\t  PAGER = 6,\n\t  MOBILE = 7,\n\t}\n\t/** Standard phone number fields. */\n\texport const PHONE_NUMBER_FIELD_TYPES: Array<PhoneNumberFieldType> = [\n\t  AddressFieldType.PHONE_1,\n\t  AddressFieldType.PHONE_2,\n\t  AddressFieldType.PHONE_3,\n\t  AddressFieldType.PHONE_4,\n", "  AddressFieldType.PHONE_5,\n\t];\n\texport type PhoneNumberFieldType =\n\t  | AddressFieldType.PHONE_1\n\t  | AddressFieldType.PHONE_2\n\t  | AddressFieldType.PHONE_3\n\t  | AddressFieldType.PHONE_4\n\t  | AddressFieldType.PHONE_5;\n\texport function isPhoneNumberFieldType(\n\t  fieldType: AddressFieldType\n", "): fieldType is PhoneNumberFieldType {\n\t  return PHONE_NUMBER_FIELD_TYPES.includes(fieldType as any);\n\t}\n\t/** Information about a field in AddressDB. */\n\texport interface AddressField {\n\t  /** Field type. */\n\t  type: AddressFieldType;\n\t  /** Label displayed to the user.\n\t   *\n\t   * Max length is ADDRESS_FIELD_LABEL_LENGTH - 1.\n", "   */\n\t  label: string;\n\t  /** Dirty bit indicating whether this field has been renamed.  */\n\t  isRenamed: boolean;\n\t}\n\t/** AddressDB AppInfo block. */\n\texport class AddressAppInfo extends AppInfoType {\n\t  @field(SUInt16BE)\n\t  private padding2 = 0;\n\t  /** Field information.\n", "   *\n\t   * Always has exactly NUM_ADDRESS_FIELDS elements.\n\t   */\n\t  fields: Array<AddressField> = [];\n\t  @field(SUInt32BE)\n\t  private renamedFields = 0;\n\t  @field(\n\t    SArray.of(SStringNT.ofLength(ADDRESS_FIELD_LABEL_LENGTH)).ofLength(\n\t      NUM_ADDRESS_FIELDS\n\t    )\n", "  )\n\t  private addressLabels: Array<string> = [];\n\t  @field(SUInt8.enum(AddressCountry))\n\t  country = AddressCountry.UNITED_STATES;\n\t  @field(SUInt8)\n\t  private padding3 = 0;\n\t  /** Whether to sort the database by company - must be 0 or 1. */\n\t  @field(SUInt8)\n\t  sortByCompany = 0;\n\t  @field(SUInt8)\n", "  private padding4 = 0;\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    const offset = super.deserialize(buffer, opts);\n\t    this.fields = this.addressLabels.map((label, i) => ({\n\t      type: i,\n\t      label,\n\t      isRenamed: !!(this.renamedFields & (1 << i)),\n\t    }));\n\t    return offset;\n\t  }\n", "  serialize(opts?: SerializeOptions) {\n\t    if (this.fields.length !== NUM_ADDRESS_FIELDS) {\n\t      throw new Error(\n\t        `Fields array must have exactly ${NUM_ADDRESS_FIELDS} elements, ` +\n\t          `found ${this.fields.length}`\n\t      );\n\t    }\n\t    this.renamedFields = 0;\n\t    this.addressLabels = [];\n\t    for (let i = 0; i < this.fields.length; ++i) {\n", "      const {type, label, isRenamed} = this.fields[i];\n\t      if (type !== i) {\n\t        throw new Error(\n\t          `Expected field[${i}] to have type ${AddressFieldType[i]}, ` +\n\t            `found ${type}`\n\t        );\n\t      }\n\t      this.addressLabels.push(label);\n\t      if (isRenamed) {\n\t        this.renamedFields |= 1 << i;\n", "      }\n\t    }\n\t    return super.serialize(opts);\n\t  }\n\t}\n\t/** A cell in an AddressDB record. */\n\texport interface AddressRecordCell {\n\t  /** The corresponding field type. */\n\t  fieldType: AddressFieldType;\n\t  /** The phone number field, if this is a phone number field. */\n", "  phoneNumberType?: PhoneNumberType;\n\t  /** The actual data. */\n\t  value: string;\n\t}\n\t/** An AddressDB record. */\n\texport class AddressRecord extends PdbRecord {\n\t  /** The \"main\" phone number type for this record. */\n\t  get mainPhoneNumberType() {\n\t    return this.phoneNumberTypeMappingBitmask.mainPhoneNumberType;\n\t  }\n", "  set mainPhoneNumberType(newValue: PhoneNumberType) {\n\t    this.phoneNumberTypeMappingBitmask.mainPhoneNumberType = newValue;\n\t  }\n\t  /** Phone number type mapping for this record. */\n\t  get phoneNumberTypeMapping() {\n\t    return this.phoneNumberTypeMappingBitmask.phoneNumberTypeMapping;\n\t  }\n\t  set phoneNumberTypeMapping(newValue: PhoneNumberTypeMapping) {\n\t    this.phoneNumberTypeMappingBitmask.phoneNumberTypeMapping = newValue;\n\t  }\n", "  @field()\n\t  private phoneNumberTypeMappingBitmask = new PhoneNumberTypeMappingBitmask();\n\t  /** Cells in this record.\n\t   *\n\t   * A record can contain up to NUM_ADDRESS_FIELDS cells, one for each\n\t   * AddressFieldType.\n\t   *\n\t   * This array can be manipulated directly or via the get() and set() methods.\n\t   */\n\t  cells: Array<AddressRecordCell> = [];\n", "  @field(SUInt32BE)\n\t  private fieldsBitmask = 0;\n\t  @field(SUInt8)\n\t  private companyCellValueOffset = 0;\n\t  @field(SArray.of(SStringNT))\n\t  private values: Array<string> = [];\n\t  /** Returns the cell value for a field type in this record, or undefined if\n\t   * not present.\n\t   */\n\t  get(fieldType: AddressFieldType) {\n", "    return this.cells.find((cell) => cell.fieldType === fieldType)?.value;\n\t  }\n\t  /** Sets the cell value for a field type.\n\t   *\n\t   * If field type was already present on this record, the previous cell value\n\t   * is overwritten. Otherwise, a new cell is appended.\n\t   */\n\t  set(fieldType: AddressFieldType, value: string) {\n\t    const cell = this.makeCell(fieldType, value);\n\t    const existingCellIdx = this.cells.findIndex(\n", "      (cell) => cell.fieldType === fieldType\n\t    );\n\t    if (existingCellIdx >= 0) {\n\t      this.cells[existingCellIdx] = cell;\n\t    } else {\n\t      this.cells.push(cell);\n\t    }\n\t  }\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    this.cells = [];\n", "    this.values = [];\n\t    let offset = super.deserialize(buffer, opts);\n\t    const s = new SStringNT();\n\t    for (let i = 0; i < NUM_ADDRESS_FIELDS; ++i) {\n\t      if (this.fieldsBitmask & (1 << i)) {\n\t        offset += s.deserialize(buffer.subarray(offset), opts);\n\t        const fieldType = i;\n\t        this.cells.push(this.makeCell(fieldType, s.value));\n\t      }\n\t    }\n", "    return offset;\n\t  }\n\t  serialize(opts?: SerializeOptions) {\n\t    this.fieldsBitmask = 0;\n\t    this.values = [];\n\t    this.companyCellValueOffset = 0;\n\t    const cellsByFieldType = groupBy(this.cells, ({fieldType}) => fieldType);\n\t    for (let i = 0, companyCellValueOffset = 0; i < NUM_ADDRESS_FIELDS; ++i) {\n\t      const fieldType = i;\n\t      const cells = cellsByFieldType[fieldType];\n", "      if (!cells) {\n\t        continue;\n\t      }\n\t      if (cells.length !== 1) {\n\t        throw new Error(\n\t          `Found ${cells.length} cells with field type ${fieldType}: ` +\n\t            cells.map(({value}) => `\"${value}\"`).join(', ')\n\t        );\n\t      }\n\t      const {value, phoneNumberType} = cells[0];\n", "      if (isPhoneNumberFieldType(fieldType)) {\n\t        if (\n\t          phoneNumberType &&\n\t          phoneNumberType !== this.phoneNumberTypeMapping[fieldType]\n\t        ) {\n\t          throw new Error(\n\t            `Incorrect phone number type in cell ${fieldType}: ` +\n\t              `phoneNumberTypeMapping[${fieldType}] is ${this.phoneNumberTypeMapping[fieldType]}, ` +\n\t              `but cell has phone number type ${phoneNumberType}`\n\t          );\n", "        }\n\t      } else {\n\t        if (phoneNumberType) {\n\t          throw new Error(\n\t            `${fieldType} is not a phone number field and should not have phoneNumberType set ` +\n\t              `(found ${phoneNumberType})`\n\t          );\n\t        }\n\t      }\n\t      this.fieldsBitmask |= 1 << i;\n", "      this.values.push(value);\n\t      if (fieldType === AddressFieldType.COMPANY) {\n\t        this.companyCellValueOffset = companyCellValueOffset + 1;\n\t      } else if (this.companyCellValueOffset === 0) {\n\t        companyCellValueOffset += value.length + 1;\n\t      }\n\t    }\n\t    return super.serialize(opts);\n\t  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n", "    this.values = this.cells.map(({value}) => value);\n\t    return super.getSerializedLength(opts);\n\t  }\n\t  private makeCell(fieldType: AddressFieldType, value: string) {\n\t    return {\n\t      fieldType,\n\t      ...(isPhoneNumberFieldType(fieldType)\n\t        ? {\n\t            phoneNumberType: this.phoneNumberTypeMapping[fieldType],\n\t          }\n", "        : {}),\n\t      value,\n\t    };\n\t  }\n\t}\n\t/** Mapping from address field type to phone number type. */\n\texport type PhoneNumberTypeMapping = {\n\t  [key in PhoneNumberFieldType]: PhoneNumberType;\n\t};\n\tclass PhoneNumberTypeMappingBitmask extends SBitmask.of(SUInt32BE) {\n", "  @bitfield(8)\n\t  private padding1 = 0;\n\t  @bitfield(4)\n\t  mainPhoneNumberType = PhoneNumberType.WORK;\n\t  get phoneNumberTypeMapping(): PhoneNumberTypeMapping {\n\t    return {\n\t      [AddressFieldType.PHONE_1]: this.phone1,\n\t      [AddressFieldType.PHONE_2]: this.phone2,\n\t      [AddressFieldType.PHONE_3]: this.phone3,\n\t      [AddressFieldType.PHONE_4]: this.phone4,\n", "      [AddressFieldType.PHONE_5]: this.phone5,\n\t    };\n\t  }\n\t  set phoneNumberTypeMapping(newValue: PhoneNumberTypeMapping) {\n\t    this.phone1 = newValue[AddressFieldType.PHONE_1];\n\t    this.phone2 = newValue[AddressFieldType.PHONE_2];\n\t    this.phone3 = newValue[AddressFieldType.PHONE_3];\n\t    this.phone4 = newValue[AddressFieldType.PHONE_4];\n\t    this.phone5 = newValue[AddressFieldType.PHONE_5];\n\t  }\n", "  @bitfield(4)\n\t  private phone5 = 4;\n\t  @bitfield(4)\n\t  private phone4 = 3;\n\t  @bitfield(4)\n\t  private phone3 = 2;\n\t  @bitfield(4)\n\t  private phone2 = 1;\n\t  @bitfield(4)\n\t  private phone1 = 0;\n", "}\n\t/** AddressDB database.\n\t *\n\t * References:\n\t *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/address.c\n\t *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Address.pm\n\t */\n\texport class AddressDatabase extends PdbDatabase.of(\n\t  AddressRecord,\n\t  AddressAppInfo\n", ") {\n\t  header = DatabaseHdrType.with({\n\t    name: 'AddressDB',\n\t    type: 'DATA',\n\t    creator: 'addr',\n\t  });\n\t}\n"]}
{"filename": "src/app-info.ts", "chunked_list": ["import {pick} from 'lodash';\n\timport {\n\t  DeserializeOptions,\n\t  SArray,\n\t  SObject,\n\t  SStringNT,\n\t  SUInt16BE,\n\t  SUInt8,\n\t  SerializeOptions,\n\t  field,\n", "} from 'serio';\n\t/** Maximum number of categories.\n\t *\n\t * References:\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataMgr.h#L34\n\t */\n\texport const NUM_CATEGORIES = 16;\n\t/** Maximum length of category labels - 15 chars + 1 NUL byte.\n\t *\n\t * References:\n", " *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-3.1/include/Core/System/DataMgr.h#L35\n\t */\n\texport const CATEGORY_LABEL_LENGTH = 16;\n\t/** Information about a category.\n\t *\n\t * The member fields inside a Category object aren't actually stored together as\n\t * a single unit; instead, they are split across the `categoryLabels`,\n\t * `categoryUniqIds` and `renamedCategories` fields inside {@link AppInfoType}.\n\t * However, we still make Category extend `SObject` in order to present a\n\t * consistent API for interacting with database objects.\n", " */\n\texport class Category extends SObject {\n\t  /** Name of the category.\n\t   *\n\t   * Max length is CATEGORY_LABEL_LENGTH - 1.\n\t   */\n\t  label = '';\n\t  /** ID of the category.\n\t   *\n\t   * Unique IDs generated by the device are between 0 and 127. Unique IDs\n", "   * generated by the desktop computer are between 128 and 255.\n\t   */\n\t  uniqId = 0;\n\t  /** Dirty bit indicating whether this category has been renamed. */\n\t  isRenamed = false;\n\t  toJSON() {\n\t    return pick(this, ['label', 'uniqId', 'isRenamed']);\n\t  }\n\t}\n\t/** AppInfo block for standard category data.\n", " *\n\t * References:\n\t *   - https://jichu4n.github.io/palm-pdb/assets/Palm%20File%20Format%20Specification.pdf\n\t *   - https://github.com/jichu4n/palm-os-sdk/blob/master/sdk-5r3/include/Core/UI/Category.h\n\t */\n\texport class AppInfoType extends SObject {\n\t  /** Array of category information (dmRecNumCategories = 16 elements). */\n\t  categories: Array<Category> = [];\n\t  @field(SUInt16BE)\n\t  private renamedCategories = 0;\n", "  @field(\n\t    SArray.of(SStringNT.ofLength(CATEGORY_LABEL_LENGTH)).ofLength(\n\t      NUM_CATEGORIES\n\t    )\n\t  )\n\t  private categoryLabels: Array<string> = [];\n\t  @field(SArray.of(SUInt8).ofLength(NUM_CATEGORIES))\n\t  private categoryUniqIds: Array<number> = [];\n\t  /** The last unique category ID assigned. */\n\t  @field(SUInt8)\n", "  lastUniqId = 0;\n\t  @field(SUInt8)\n\t  private readonly padding1 = 0;\n\t  /** Finds the category with the given unique ID or label.\n\t   *\n\t   * If the argument is a number, this method will look for a category with a\n\t   * matching uniqId. If the argument is a string, this method will look for a\n\t   * category with a matching label.\n\t   */\n\t  getCategory(arg: number | string): Category | null {\n", "    let matchFn: (category: Category) => boolean;\n\t    switch (typeof arg) {\n\t      case 'number':\n\t        matchFn = (category) => category.uniqId === arg;\n\t        break;\n\t      case 'string':\n\t        matchFn = (category) => category.label === arg;\n\t        break;\n\t      default:\n\t        throw new Error(`Expected a number or string, found ${typeof arg}`);\n", "    }\n\t    return this.categories.find(matchFn) ?? null;\n\t  }\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    const offset = super.deserialize(buffer, opts);\n\t    this.categories = [];\n\t    for (let i = 0; i < NUM_CATEGORIES; ++i) {\n\t      if (!this.categoryLabels[i]) {\n\t        break;\n\t      }\n", "      this.categories.push(\n\t        Category.with({\n\t          label: this.categoryLabels[i],\n\t          uniqId: this.categoryUniqIds[i],\n\t          isRenamed: !!(this.renamedCategories & (1 << i)),\n\t        })\n\t      );\n\t    }\n\t    return offset;\n\t  }\n", "  serialize(opts?: SerializeOptions): Buffer {\n\t    this.categoryLabels = [];\n\t    this.categoryUniqIds = [];\n\t    this.renamedCategories = 0;\n\t    for (let i = 0; i < this.categories.length; ++i) {\n\t      const {label, uniqId, isRenamed} = this.categories[i];\n\t      this.categoryLabels.push(label);\n\t      this.categoryUniqIds.push(uniqId);\n\t      if (isRenamed) {\n\t        this.renamedCategories |= 1 << i;\n", "      }\n\t    }\n\t    return super.serialize(opts);\n\t  }\n\t}\n"]}
{"filename": "src/database.ts", "chunked_list": ["import sum from 'lodash/sum';\n\timport {\n\t  DeserializeOptions,\n\t  SBuffer,\n\t  SObject,\n\t  Serializable,\n\t  SerializeOptions,\n\t} from 'serio';\n\timport {SmartBuffer} from 'smart-buffer';\n\timport {\n", "  DatabaseHdrType,\n\t  EntryType,\n\t  PdbRecordListType,\n\t  PrcRecordListType,\n\t  RecordEntryType,\n\t  RecordListType,\n\t  RsrcEntryType,\n\t} from './database-header';\n\timport {RawPdbRecord, RawPrcRecord, Record} from './record';\n\timport {DEFAULT_ENCODING} from './util';\n", "/** Representation of a Palm OS database file. */\n\texport abstract class Database<\n\t  /** Record or resource entry type. */\n\t  EntryT extends EntryType,\n\t  /** Record type. */\n\t  RecordT extends Record<EntryT>,\n\t  /** AppInfo type. */\n\t  AppInfoT extends Serializable = SBuffer,\n\t  /** SortInfo type. */\n\t  SortInfoT extends Serializable = SBuffer\n", "> extends SObject {\n\t  /** Record list constructor, to be provided by child classes. */\n\t  protected abstract readonly recordListType: new () => RecordListType<EntryT>;\n\t  /** Record type constructor, to be provided by child classes. */\n\t  protected abstract readonly recordType: new () => RecordT;\n\t  /** AppInfo type constructor, to be provided by child classes. */\n\t  protected readonly appInfoType: (new () => AppInfoT) | null = null;\n\t  /** SortInfo type constructor, to be provided by child classes. */\n\t  protected readonly sortInfoType: (new () => SortInfoT) | null = null;\n\t  /** Database header.\n", "   *\n\t   * Note that `appInfoId` and `sortInfoId` fields in the header are overwritten\n\t   * during serialization.\n\t   */\n\t  header = new DatabaseHdrType();\n\t  /** AppInfo value. */\n\t  appInfo: AppInfoT | null = null;\n\t  /** SortInfo value. */\n\t  sortInfo: SortInfoT | null = null;\n\t  /** Record values.\n", "   *\n\t   * Note that `entry.localChunkId` is overwritten during serialization.\n\t   */\n\t  records: Array<RecordT> = [];\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    opts = {encoding: DEFAULT_ENCODING, ...opts};\n\t    this.header.deserialize(buffer, opts);\n\t    const recordList = new this.recordListType();\n\t    recordList.deserialize(\n\t      buffer.subarray(this.header.getSerializedLength(opts)),\n", "      opts\n\t    );\n\t    if (this.appInfoType && this.header.appInfoId) {\n\t      const appInfoEnd =\n\t        this.header.sortInfoId ||\n\t        (recordList.values.length > 0\n\t          ? recordList.values[0].localChunkId\n\t          : buffer.length);\n\t      if (!this.appInfo) {\n\t        this.appInfo = new this.appInfoType();\n", "      }\n\t      this.appInfo.deserialize(\n\t        buffer.subarray(this.header.appInfoId, appInfoEnd),\n\t        opts\n\t      );\n\t    } else {\n\t      this.appInfo = null;\n\t    }\n\t    if (this.sortInfoType && this.header.sortInfoId) {\n\t      const sortInfoEnd =\n", "        recordList.values.length > 0\n\t          ? recordList.values[0].localChunkId\n\t          : buffer.length;\n\t      if (!this.sortInfo) {\n\t        this.sortInfo = new this.sortInfoType();\n\t      }\n\t      this.sortInfo.deserialize(\n\t        buffer.subarray(this.header.sortInfoId, sortInfoEnd),\n\t        opts\n\t      );\n", "    } else {\n\t      this.sortInfo = null;\n\t    }\n\t    this.records = [];\n\t    let lastRecordEnd = 0;\n\t    for (let i = 0; i < recordList.values.length; ++i) {\n\t      const recordStart = recordList.values[i].localChunkId;\n\t      const recordEnd =\n\t        i < recordList.values.length - 1\n\t          ? recordList.values[i + 1].localChunkId\n", "          : buffer.length;\n\t      const record = new this.recordType();\n\t      record.entry = recordList.values[i];\n\t      record.deserialize(buffer.subarray(recordStart, recordEnd), opts);\n\t      this.records.push(record);\n\t      lastRecordEnd = recordEnd;\n\t    }\n\t    return lastRecordEnd;\n\t  }\n\t  serialize(opts?: SerializeOptions) {\n", "    opts = {encoding: DEFAULT_ENCODING, ...opts};\n\t    this.recomputeOffsets(opts);\n\t    const writer = new SmartBuffer();\n\t    writer.writeBuffer(this.header.serialize(opts));\n\t    const recordList = new this.recordListType();\n\t    recordList.values = this.records.map(({entry}) => entry);\n\t    writer.writeBuffer(recordList.serialize(opts));\n\t    if (this.appInfo) {\n\t      writer.writeBuffer(this.appInfo.serialize(opts));\n\t    }\n", "    if (this.sortInfo) {\n\t      writer.writeBuffer(this.sortInfo.serialize(opts));\n\t    }\n\t    for (const record of this.records) {\n\t      writer.writeBuffer(record.serialize(opts));\n\t    }\n\t    return writer.toBuffer();\n\t  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n\t    return (\n", "      this.header.getSerializedLength(opts) +\n\t      sum(this.records.map(({entry}) => entry.getSerializedLength(opts))) +\n\t      (this.appInfo ? this.appInfo.getSerializedLength(opts) : 0) +\n\t      (this.sortInfo ? this.sortInfo.getSerializedLength(opts) : 0) +\n\t      sum(this.records.map((record) => record.getSerializedLength(opts)))\n\t    );\n\t  }\n\t  /** Recompute offsets in the database and record headers.\n\t   *\n\t   * This will update the following based on the current field values:\n", "   *  - `header.appInfoId`\n\t   *  - `header.sortInfoId`\n\t   *  - `entry.localChunkId` for each record\n\t   */\n\t  recomputeOffsets(opts?: SerializeOptions) {\n\t    opts = {encoding: DEFAULT_ENCODING, ...opts};\n\t    const recordList = new this.recordListType();\n\t    recordList.values = this.records.map(({entry}) => entry);\n\t    let offset =\n\t      this.header.getSerializedLength(opts) +\n", "      recordList.getSerializedLength(opts);\n\t    if (this.appInfo) {\n\t      this.header.appInfoId = offset;\n\t      offset += this.appInfo.getSerializedLength(opts);\n\t    } else {\n\t      this.header.appInfoId = 0;\n\t    }\n\t    if (this.sortInfo) {\n\t      this.header.sortInfoId = offset;\n\t      offset += this.sortInfo.getSerializedLength(opts);\n", "    } else {\n\t      this.header.sortInfoId = 0;\n\t    }\n\t    for (let i = 0; i < this.records.length; ++i) {\n\t      recordList.values[i].localChunkId = offset;\n\t      offset += this.records[i].getSerializedLength(opts);\n\t    }\n\t  }\n\t}\n\t/** PDB databases. */\n", "export abstract class PdbDatabase<\n\t  /** Record type. */\n\t  RecordT extends Record<RecordEntryType>,\n\t  /** AppInfo type. */\n\t  AppInfoT extends Serializable = SBuffer,\n\t  /** SortInfo type. */\n\t  SortInfoT extends Serializable = SBuffer\n\t> extends Database<RecordEntryType, RecordT, AppInfoT, SortInfoT> {\n\t  constructor() {\n\t    super();\n", "    this.header.attributes.resDB = false;\n\t  }\n\t  recordListType = PdbRecordListType;\n\t  /** Constructs a PdbDatabase class with the given parameters. */\n\t  static of<\n\t    RecordT extends Record<RecordEntryType>,\n\t    AppInfoT extends Serializable = SBuffer,\n\t    SortInfoT extends Serializable = SBuffer\n\t  >(\n\t    recordType: new () => RecordT,\n", "    appInfoType?: new () => AppInfoT,\n\t    sortInfoType?: new () => SortInfoT\n\t  ) {\n\t    return class extends PdbDatabase<RecordT, AppInfoT, SortInfoT> {\n\t      recordType = recordType;\n\t      appInfoType = appInfoType ?? null;\n\t      sortInfoType = sortInfoType ?? null;\n\t      appInfo = appInfoType ? new appInfoType() : null;\n\t      sortInfo = sortInfoType ? new sortInfoType() : null;\n\t    };\n", "  }\n\t}\n\t/** PRC databases. */\n\texport abstract class PrcDatabase<\n\t  /** Record type. */\n\t  RecordT extends Record<RsrcEntryType>,\n\t  /** AppInfo type. */\n\t  AppInfoT extends Serializable = SBuffer,\n\t  /** SortInfo type. */\n\t  SortInfoT extends Serializable = SBuffer\n", "> extends Database<RsrcEntryType, RecordT, AppInfoT, SortInfoT> {\n\t  constructor() {\n\t    super();\n\t    this.header.attributes.resDB = true;\n\t  }\n\t  recordListType = PrcRecordListType;\n\t  /** Constructs a PrcDatabase class with the given parameters. */\n\t  static of<\n\t    RecordT extends Record<RsrcEntryType>,\n\t    AppInfoT extends Serializable = SBuffer,\n", "    SortInfoT extends Serializable = SBuffer\n\t  >(\n\t    recordType: new () => RecordT,\n\t    appInfoType?: new () => AppInfoT,\n\t    sortInfoType?: new () => SortInfoT\n\t  ) {\n\t    return class extends PrcDatabase<RecordT, AppInfoT, SortInfoT> {\n\t      recordType = recordType;\n\t      appInfoType = appInfoType ?? null;\n\t      sortInfoType = sortInfoType ?? null;\n", "      appInfo = appInfoType ? new appInfoType() : null;\n\t      sortInfo = sortInfoType ? new sortInfoType() : null;\n\t    };\n\t  }\n\t}\n\t/** PDB database providing records, AppInfo and SortInfo as raw buffers. */\n\texport class RawPdbDatabase extends PdbDatabase.of(\n\t  RawPdbRecord,\n\t  SBuffer,\n\t  SBuffer\n", ") {}\n\t/** PRC database providing records, AppInfo and SortInfo as raw buffers. */\n\texport class RawPrcDatabase extends PrcDatabase.of(\n\t  RawPrcRecord,\n\t  SBuffer,\n\t  SBuffer\n\t) {}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './util';\n\texport * from './date-time';\n\texport * from './database-header';\n\texport * from './app-info';\n\texport * from './database';\n\texport * from './record';\n\texport * from './datebook-database';\n\texport * from './memo-database';\n\texport * from './todo-database';\n\texport * from './address-database';\n", "export * from './palmdoc-database';\n"]}
{"filename": "src/util.ts", "chunked_list": ["import sum from 'lodash/sum';\n\timport {\n\t  DeserializeOptions,\n\t  SArray,\n\t  SString,\n\t  SUInt32BE,\n\t  Serializable,\n\t  SerializableWrapper,\n\t  SerializeOptions,\n\t} from 'serio';\n", "/** An array encoded as a number N followed by N elements. */\n\texport abstract class SDynamicArray<\n\t  LengthT extends SerializableWrapper<number>,\n\t  ValueT extends Serializable\n\t> extends SerializableWrapper<Array<ValueT>> {\n\t  /** Array of Serializables. */\n\t  value: Array<ValueT> = [];\n\t  /** Length type, to be provided by child classes. */\n\t  protected abstract readonly lengthType: new () => LengthT;\n\t  /** Element type, to be provided by child classes. */\n", "  protected abstract readonly valueType: new () => ValueT;\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    const length = new this.lengthType();\n\t    let readOffset = length.deserialize(buffer, opts);\n\t    const sArray = new (SArray.ofLength(length.value, this.valueType))();\n\t    readOffset += sArray.deserialize(buffer.subarray(readOffset), opts);\n\t    this.value.splice(0, this.value.length, ...sArray.value);\n\t    return readOffset;\n\t  }\n\t  serialize(opts?: SerializeOptions) {\n", "    const length = new this.lengthType();\n\t    length.value = this.value.length;\n\t    return Buffer.concat([\n\t      length.serialize(opts),\n\t      SArray.ofLength(this.value.length, this.valueType)\n\t        .of(this.value)\n\t        .serialize(opts),\n\t    ]);\n\t  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n", "    const length = new this.lengthType();\n\t    length.value = this.value.length;\n\t    return (\n\t      length.getSerializedLength(opts) +\n\t      sum(this.value.map((value) => value.getSerializedLength(opts)))\n\t    );\n\t  }\n\t  /** Create a new instance of this wrapper class from a raw value. */\n\t  static of<ValueT extends Serializable, SDynamicArrayT extends SArray<ValueT>>(\n\t    this: new () => SDynamicArrayT,\n", "    value: Array<ValueT>\n\t  ): SDynamicArrayT;\n\t  /** Returns an SDynamicArray class with the given length and value types. */\n\t  static of<\n\t    LengthT extends SerializableWrapper<number>,\n\t    ValueT extends Serializable\n\t  >(\n\t    lengthType: new () => LengthT,\n\t    valueType: new () => ValueT\n\t  ): ReturnType<typeof createSDynamicArray<LengthT, ValueT>>;\n", "  static of<\n\t    LengthT extends SerializableWrapper<number>,\n\t    ValueT extends Serializable\n\t  >(arg1: Array<ValueT> | (new () => LengthT), arg2?: new () => ValueT) {\n\t    if (Array.isArray(arg1)) {\n\t      return super.of(arg1);\n\t    }\n\t    if (\n\t      typeof arg1 === 'function' &&\n\t      arg1.prototype instanceof SerializableWrapper &&\n", "      typeof arg2 === 'function' &&\n\t      arg2.prototype instanceof Serializable\n\t    ) {\n\t      return createSDynamicArray(arg1, arg2);\n\t    }\n\t    throw new Error(\n\t      'SDynamicArray.of() should be invoked either with an array of Serializable ' +\n\t        'values, or a length type constructor and a value type constructor'\n\t    );\n\t  }\n", "}\n\tfunction createSDynamicArray<\n\t  LengthT extends SerializableWrapper<number>,\n\t  ValueT extends Serializable\n\t>(lengthType: new () => LengthT, valueType: new () => ValueT) {\n\t  return class extends SDynamicArray<LengthT, ValueT> {\n\t    lengthType = lengthType;\n\t    valueType = valueType;\n\t  };\n\t}\n", "/** Serializable wrapper for a 32-bit type ID mapped to a 4-character string. */\n\texport class TypeId extends SString.ofLength(4) {\n\t  value = 'AAAA';\n\t}\n\t/** Memory offset, i.e. \"local (card relative) chunk ID\" according to the SDK. */\n\texport const LocalId = SUInt32BE;\n\t/** Unique ID of records in PDB databases.\n\t *\n\t * Each unique ID is encoded as a 24-bit big endian unsigned integer. Valid\n\t * records should have a non-zero unique ID.\n", " */\n\texport class RecordId extends SerializableWrapper<number> {\n\t  value = 0;\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    // Reference: https://github.com/jichu4n/pilot-link/blob/master/libpisock/pi-file.c#L258\n\t    this.value =\n\t      (buffer.readUInt8(0) << 16) |\n\t      (buffer.readUInt8(1) << 8) |\n\t      buffer.readUInt8(2);\n\t    return 3;\n", "  }\n\t  serialize(opts?: SerializeOptions) {\n\t    // Reference: https://github.com/jichu4n/pilot-link/blob/master/libpisock/pi-file.c#L1246\n\t    return Buffer.of(\n\t      (this.value >> 16) & 0xff,\n\t      (this.value >> 8) & 0xff,\n\t      this.value & 0xff\n\t    );\n\t  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n", "    return 3;\n\t  }\n\t}\n\t/** Default text encoding for Palm OS PDB files. */\n\texport const DEFAULT_ENCODING = 'cp1252';\n"]}
{"filename": "src/datebook-database.ts", "chunked_list": ["import pick from 'lodash/pick';\n\timport times from 'lodash/times';\n\timport {\n\t  bitfield,\n\t  DeserializeOptions,\n\t  field,\n\t  SBitmask,\n\t  SerializableWrapper,\n\t  SerializeOptions,\n\t  SObject,\n", "  SStringNT,\n\t  SUInt16BE,\n\t  SUInt8,\n\t} from 'serio';\n\timport {\n\t  AppInfoType,\n\t  DatabaseDate,\n\t  DatabaseHdrType,\n\t  OptionalDatabaseDate,\n\t  PdbDatabase,\n", "  PdbRecord,\n\t  SDynamicArray,\n\t} from '.';\n\t/** Event start / end time. */\n\texport class EventTime extends SObject {\n\t  /** Hour of day (0 to 23). */\n\t  @field(SUInt8)\n\t  hour = 0;\n\t  /** Minute (0-59). */\n\t  @field(SUInt8)\n", "  minute = 0;\n\t  serialize(opts?: SerializeOptions) {\n\t    if (this.hour < 0 || this.hour > 23) {\n\t      throw new Error(`Invalid hour value: ${this.hour}`);\n\t    }\n\t    if (this.minute < 0 || this.minute > 59) {\n\t      throw new Error(`Invalid minute value: ${this.minute}`);\n\t    }\n\t    return super.serialize(opts);\n\t  }\n", "}\n\t/** Event start / end time. */\n\texport class OptionalEventTime extends SerializableWrapper<EventTime | null> {\n\t  /** Time value, or null if not specified. */\n\t  value: EventTime | null = null;\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    this.value =\n\t      buffer.readUInt16BE() === 0xffff ? null : EventTime.from(buffer, opts);\n\t    return this.getSerializedLength(opts);\n\t  }\n", "  serialize(opts?: SerializeOptions) {\n\t    return this.value ? this.value.serialize(opts) : Buffer.of(0xff, 0xff);\n\t  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n\t    return 2;\n\t  }\n\t}\n\t/** DatebookDB AppInfo block. */\n\texport class DatebookAppInfo extends AppInfoType {\n\t  /** Day of the week to start the week on. Not sure what the format is\n", "   * ¯\\_(ツ)_/¯ */\n\t  @field(SUInt8)\n\t  firstDayOfWeek = 0;\n\t  @field(SUInt8)\n\t  private padding2 = 0;\n\t}\n\t/** A DatebookDB record. */\n\texport class DatebookRecord extends PdbRecord {\n\t  /** Start time of event. */\n\t  @field(OptionalEventTime)\n", "  startTime: EventTime | null = null;\n\t  /** End time of event. */\n\t  @field(OptionalEventTime)\n\t  endTime: EventTime | null = null;\n\t  /** Date of the event. */\n\t  @field()\n\t  date = new DatabaseDate();\n\t  /** Attributes field. */\n\t  @field()\n\t  private attrs = new DatebookRecordAttrs();\n", "  @field(SUInt8)\n\t  private padding1 = 0;\n\t  /** Alarm settings, or null if no alarm configured. */\n\t  alarmSettings: AlarmSettings | null = null;\n\t  /** Recurrence settings, or null if the event is not recurring. */\n\t  recurrenceSettings: RecurrenceSettings | null = null;\n\t  /** Dates on which to skip repetitions. */\n\t  exceptionDates: Array<DatabaseDate> = [];\n\t  /** Main description. */\n\t  description = '';\n", "  /** Additional note. */\n\t  note = '';\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    let offset = super.deserialize(buffer, opts);\n\t    if (this.attrs.hasAlarmSettings) {\n\t      this.alarmSettings = new AlarmSettings();\n\t      offset += this.alarmSettings.deserialize(buffer.subarray(offset), opts);\n\t    } else {\n\t      this.alarmSettings = null;\n\t    }\n", "    if (this.attrs.hasRecurrenceSettings) {\n\t      this.recurrenceSettings = new RecurrenceSettings();\n\t      offset += this.recurrenceSettings.deserialize(\n\t        buffer.subarray(offset),\n\t        opts\n\t      );\n\t    } else {\n\t      this.recurrenceSettings = null;\n\t    }\n\t    if (this.attrs.hasExceptionDates) {\n", "      const wrapper = new (SDynamicArray.of(SUInt16BE, DatabaseDate))();\n\t      offset += wrapper.deserialize(buffer.subarray(offset), opts);\n\t      this.exceptionDates = wrapper.value;\n\t    } else {\n\t      this.exceptionDates = [];\n\t    }\n\t    if (this.attrs.hasDescription) {\n\t      const wrapper = new SStringNT();\n\t      offset += wrapper.deserialize(buffer.subarray(offset), opts);\n\t      this.description = wrapper.value;\n", "    } else {\n\t      this.description = '';\n\t    }\n\t    if (this.attrs.hasNote) {\n\t      const wrapper = new SStringNT();\n\t      offset += wrapper.deserialize(buffer.subarray(offset), opts);\n\t      this.note = wrapper.value;\n\t    } else {\n\t      this.note = '';\n\t    }\n", "    return buffer.length;\n\t  }\n\t  serialize(opts?: SerializeOptions) {\n\t    const pieces: Array<Buffer> = [];\n\t    this.attrs.hasAlarmSettings = !!this.alarmSettings;\n\t    this.attrs.hasRecurrenceSettings = !!this.recurrenceSettings;\n\t    this.attrs.hasExceptionDates = this.exceptionDates.length > 0;\n\t    this.attrs.hasDescription = !!this.description;\n\t    this.attrs.hasNote = !!this.note;\n\t    pieces.push(super.serialize(opts));\n", "    if (this.alarmSettings) {\n\t      pieces.push(this.alarmSettings.serialize(opts));\n\t    }\n\t    if (this.recurrenceSettings) {\n\t      pieces.push(this.recurrenceSettings.serialize(opts));\n\t    }\n\t    if (this.exceptionDates.length > 0) {\n\t      pieces.push(\n\t        SDynamicArray.of(SUInt16BE, DatabaseDate)\n\t          .of(this.exceptionDates)\n", "          .serialize(opts)\n\t      );\n\t    }\n\t    if (this.description) {\n\t      pieces.push(SStringNT.of(this.description).serialize(opts));\n\t    }\n\t    if (this.note) {\n\t      pieces.push(SStringNT.of(this.note).serialize(opts));\n\t    }\n\t    return Buffer.concat(pieces);\n", "  }\n\t  getSerializedLength(opts?: SerializeOptions) {\n\t    return (\n\t      8 +\n\t      (this.alarmSettings ? this.alarmSettings.getSerializedLength(opts) : 0) +\n\t      (this.recurrenceSettings\n\t        ? this.recurrenceSettings.getSerializedLength(opts)\n\t        : 0) +\n\t      (this.exceptionDates.length > 0\n\t        ? SDynamicArray.of(SUInt16BE, DatabaseDate)\n", "            .of(this.exceptionDates)\n\t            .getSerializedLength(opts)\n\t        : 0) +\n\t      (this.note ? this.note.length + 1 : 0) +\n\t      (this.description ? this.description.length + 1 : 0)\n\t    );\n\t  }\n\t}\n\t/** Datebook record attribute flags. */\n\texport class DatebookRecordAttrs extends SBitmask.of(SUInt8) {\n", "  @bitfield(1)\n\t  private unused1 = 0;\n\t  /** Whether this event should sound an alarm before the start time. */\n\t  @bitfield(1)\n\t  hasAlarmSettings = false;\n\t  /** Whether this event is recurring. */\n\t  @bitfield(1)\n\t  hasRecurrenceSettings = false;\n\t  /** Whether this event has an additional note. */\n\t  @bitfield(1)\n", "  hasNote = false;\n\t  /** Whether this event has repetition exceptions. */\n\t  @bitfield(1)\n\t  hasExceptionDates = false;\n\t  /** Whether this event has a description. */\n\t  @bitfield(1)\n\t  hasDescription = false;\n\t  @bitfield(2)\n\t  private unused2 = 0;\n\t}\n", "/** Time unit for describing when the alarm should fire. */\n\texport enum AlarmTimeUnit {\n\t  MINUTES = 0,\n\t  HOURS = 1,\n\t  DAYS = 2,\n\t}\n\t/** Event alarm settings.\n\t *\n\t * The time when the alarm will fire is specified by the combination of `unit`\n\t * and `value`. For example, `{unit: 'minutes', value: 10}` means the alarm will\n", " * fire 10 minutes before the event.\n\t */\n\texport class AlarmSettings extends SObject {\n\t  /** Number of time units before the event start time to fire the alarm. */\n\t  @field(SUInt8)\n\t  value = 0;\n\t  /** Time unit for expressing when the alarm should fire. */\n\t  @field(SUInt8.enum(AlarmTimeUnit))\n\t  unit = AlarmTimeUnit.MINUTES;\n\t}\n", "/** Frequency of a recurring event. */\n\texport enum RecurrenceFrequency {\n\t  /** Don't repeat. */\n\t  NONE = 0,\n\t  /** Repeat every N days */\n\t  DAILY = 1,\n\t  /** Repeat every N weeks on the same days of the week. */\n\t  WEEKLY = 2,\n\t  /** Repeat on same week of the month every N months. */\n\t  MONTHLY_BY_DAY = 3,\n", "  /** Repeat on same day of the month every N months. */\n\t  MONTHLY_BY_DATE = 4,\n\t  /** Repeat on same day of the year every N years. */\n\t  YEARLY = 5,\n\t}\n\t/** Additional settings for events with weekly recurrence. */\n\texport interface WeeklyRecurrenceSettings {\n\t  /** Array of 7 booleans specifying which days of the week the event recurs on.\n\t   *\n\t   * Index 0 = Sunday, 1 = Monday, etc. For example, the following indicates an\n", "   * event that recurs on Monday, Wednesday and Friday:\n\t   *\n\t   *   [false, true, false, true, false, true, false]\n\t   */\n\t  days: [boolean, boolean, boolean, boolean, boolean, boolean, boolean];\n\t  /** Day of the week that weeks start on - 0 for Sunday, 1 for Monday.\n\t   *\n\t   * This affects events that repeat every 2nd Sunday (or higher interval).\n\t   */\n\t  firstDayOfWeek: number;\n", "}\n\t/** Additional settings for events with monthly-by-day recurrence frequency. */\n\texport interface MonthlyByDayRecurrenceSettings {\n\t  /** Week number within the month.\n\t   *\n\t   * 0 = 1st week of the month\n\t   * 1 = 2nd week of the month\n\t   * ...\n\t   * 5 = last week of the month\n\t   */\n", "  weekOfMonth: number;\n\t  /** Day of week.\n\t   *\n\t   * 0 = Sunday, 1 = Monday, etc.\n\t   */\n\t  day: number;\n\t}\n\t/** Event recurrence settings. */\n\texport class RecurrenceSettings extends SObject {\n\t  /** Frequency of this recurring event. */\n", "  @field(SUInt8.enum(RecurrenceFrequency))\n\t  frequency = RecurrenceFrequency.DAILY;\n\t  @field(SUInt8)\n\t  private padding1 = 0;\n\t  /** Recurrence end date. If null, the event repeats forever. */\n\t  @field(OptionalDatabaseDate)\n\t  endDate: DatabaseDate | null = null;\n\t  /** The interval at which the event repeats (every N days / weeks / months /\n\t   * years). */\n\t  @field(SUInt8)\n", "  interval = 1;\n\t  /** Additional settings for WEEKLY frequency.\n\t   *\n\t   * Required if frequency is WEEKLY.\n\t   */\n\t  weekly: WeeklyRecurrenceSettings | null = null;\n\t  /** Additional settings for MONTHLY_BY_DAY frequency.\n\t   *\n\t   * Required if frequency is MONTHLY_BY_DAY.\n\t   */\n", "  monthlyByDay: MonthlyByDayRecurrenceSettings | null = null;\n\t  @field(SUInt8)\n\t  private arg1 = 0;\n\t  @field(SUInt8)\n\t  private arg2 = 0;\n\t  @field(SUInt8)\n\t  private padding2 = 0;\n\t  deserialize(buffer: Buffer, opts?: DeserializeOptions) {\n\t    const offset = super.deserialize(buffer, opts);\n\t    this.weekly = null;\n", "    this.monthlyByDay = null;\n\t    switch (this.frequency) {\n\t      case RecurrenceFrequency.DAILY:\n\t      case RecurrenceFrequency.MONTHLY_BY_DATE:\n\t      case RecurrenceFrequency.YEARLY:\n\t        break;\n\t      case RecurrenceFrequency.WEEKLY:\n\t        const days = times(\n\t          7,\n\t          (i) => !!(this.arg1 & (1 << i))\n", "        ) as WeeklyRecurrenceSettings['days'];\n\t        const firstDayOfWeek = this.arg2;\n\t        this.weekly = {days, firstDayOfWeek};\n\t        break;\n\t      case RecurrenceFrequency.MONTHLY_BY_DAY:\n\t        const weekOfMonth = Math.floor(this.arg1 / 7);\n\t        const day = this.arg1 % 7;\n\t        this.monthlyByDay = {weekOfMonth, day};\n\t        break;\n\t      default:\n", "        throw new Error(`Invalid frequency type: ${this.frequency}`);\n\t    }\n\t    return offset;\n\t  }\n\t  serialize(opts?: SerializeOptions) {\n\t    switch (this.frequency) {\n\t      case RecurrenceFrequency.DAILY:\n\t      case RecurrenceFrequency.MONTHLY_BY_DATE:\n\t      case RecurrenceFrequency.YEARLY:\n\t        this.arg1 = 0;\n", "        this.arg2 = 0;\n\t        break;\n\t      case RecurrenceFrequency.WEEKLY:\n\t        if (!this.weekly) {\n\t          throw new Error('`weekly` must be set when frequency is WEEKLY');\n\t        }\n\t        const {days, firstDayOfWeek} = this.weekly;\n\t        if (days.length !== 7) {\n\t          throw new Error(\n\t            `Days array must have exactly 7 elements, found ${days.length}`\n", "          );\n\t        }\n\t        this.arg1 = 0;\n\t        for (let i = 0; i < 7; ++i) {\n\t          if (days[i]) {\n\t            this.arg1 |= 1 << i;\n\t          }\n\t        }\n\t        if (firstDayOfWeek < 0 || firstDayOfWeek > 1) {\n\t          throw new Error(`Invalid first day of week: ${firstDayOfWeek}`);\n", "        }\n\t        this.arg2 = firstDayOfWeek;\n\t        break;\n\t      case RecurrenceFrequency.MONTHLY_BY_DAY:\n\t        if (!this.monthlyByDay) {\n\t          throw new Error(\n\t            '`monthlyByDay` must be set when frequency is MONTHLY_BY_DAY'\n\t          );\n\t        }\n\t        const {weekOfMonth, day} = this.monthlyByDay;\n", "        if (weekOfMonth < 0 || weekOfMonth > 5) {\n\t          throw new Error(`Invalid week of month: ${weekOfMonth}`);\n\t        }\n\t        if (day < 0 || day > 7) {\n\t          throw new Error(`Invalid day of week: ${day}`);\n\t        }\n\t        this.arg1 = weekOfMonth * 7 + day;\n\t        this.arg2 = 0;\n\t        break;\n\t      default:\n", "        throw new Error(`Invalid frequency type: ${this.frequency}`);\n\t    }\n\t    return super.serialize(opts);\n\t  }\n\t}\n\t/** DatebookDB database.\n\t *\n\t * References:\n\t *   - https://github.com/jichu4n/pilot-link/blob/master/libpisock/datebook.c\n\t *   - https://github.com/madsen/p5-Palm/blob/master/lib/Palm/Datebook.pm\n", " */\n\texport class DatebookDatabase extends PdbDatabase.of(\n\t  DatebookRecord,\n\t  DatebookAppInfo\n\t) {\n\t  header = DatabaseHdrType.with({\n\t    name: 'DatebookDB',\n\t    type: 'DATA',\n\t    creator: 'date',\n\t  });\n", "}\n"]}
{"filename": "src/bin/palmdoc.ts", "chunked_list": ["#!/usr/bin/env node\n\timport {program} from 'commander';\n\timport fs from 'fs-extra';\n\timport iconv from 'iconv-lite';\n\timport path from 'path';\n\timport {DEFAULT_ENCODING, PalmDoc} from '..';\n\t// Not using resolveJsonModule because it causes the output to be generated\n\t// relative to the root directory instead of src/.\n\tconst packageJson = require('../../package.json');\n\tif (require.main === module) {\n", "  (async () => {\n\t    program.name('palmdoc').version(packageJson.version);\n\t    program\n\t      .command('decode <document.pdb>')\n\t      .description('Decode a PalmDOC PDB file to text.')\n\t      .option(\n\t        '--input-encoding <encoding>',\n\t        'text encoding of input PalmDOC PDB file',\n\t        DEFAULT_ENCODING\n\t      )\n", "      .option(\n\t        '--output-encoding <encoding>',\n\t        'text encoding for output text file',\n\t        'utf-8'\n\t      )\n\t      .option('-o, --output <document.txt>', 'path to output text file')\n\t      .action(async (inputFilePath: string, opts: any) => {\n\t        const doc = new PalmDoc();\n\t        try {\n\t          const buffer = await fs.readFile(inputFilePath);\n", "          doc.deserialize(buffer, {encoding: opts.inputEncoding});\n\t        } catch (e: any) {\n\t          console.error(`Could not open '${inputFilePath}': ${e.message}`);\n\t          process.exit(1);\n\t        }\n\t        const outputFilePath =\n\t          opts.output || replaceOrAddFileExt(inputFilePath, 'pdb', 'txt');\n\t        await fs.writeFile(outputFilePath, doc.text, opts.outputEncoding);\n\t      });\n\t    program\n", "      .command('encode <document.txt>')\n\t      .description('Encode a text file to PalmDOC PDB format.')\n\t      .option(\n\t        '--input-encoding <encoding>',\n\t        'text encoding of input text file',\n\t        'utf-8'\n\t      )\n\t      .option(\n\t        '--output-encoding <encoding>',\n\t        'text encoding for output PalmDOC PDB file',\n", "        DEFAULT_ENCODING\n\t      )\n\t      .option(\n\t        '-n, --name <document name>',\n\t        'document name (default: file name)'\n\t      )\n\t      .option('--compress', 'enable compression', true)\n\t      .option('--no-compress', 'disable compression')\n\t      .option('-o, --output <document.pdb>', 'path to output PalmDOC PDB file')\n\t      .action(async (inputFilePath: string, opts: any) => {\n", "        const doc = new PalmDoc();\n\t        try {\n\t          doc.text = iconv.decode(\n\t            await fs.readFile(inputFilePath),\n\t            opts.inputEncoding\n\t          );\n\t        } catch (e: any) {\n\t          console.error(`Could not open '${inputFilePath}': ${e.message}`);\n\t          process.exit(1);\n\t        }\n", "        doc.name = opts.name || path.basename(inputFilePath);\n\t        const outputFilePath =\n\t          opts.output || replaceOrAddFileExt(inputFilePath, 'txt', 'pdb');\n\t        await fs.writeFile(\n\t          outputFilePath,\n\t          doc.serialize({\n\t            encoding: opts.outputEncoding,\n\t            enableCompression: !!opts.compress,\n\t          })\n\t        );\n", "      });\n\t    await program.parseAsync();\n\t  })();\n\t}\n\t/** Replace file extension in a path (case insenstive). */\n\tfunction replaceOrAddFileExt(filePath: string, oldExt: string, newExt: string) {\n\t  if (filePath.toLowerCase().endsWith(`.${oldExt.toLowerCase()}`)) {\n\t    return filePath.substr(0, filePath.length - oldExt.length) + newExt;\n\t  } else {\n\t    return `${filePath}.${newExt}`;\n", "  }\n\t}\n"]}
{"filename": "src/bin/pdb2json.ts", "chunked_list": ["#!/usr/bin/env node\n\timport {program} from 'commander';\n\timport fs from 'fs-extra';\n\timport {\n\t  AddressDatabase,\n\t  DatebookDatabase,\n\t  DEFAULT_ENCODING,\n\t  MemoDatabase,\n\t  PalmDocDatabase,\n\t  PdbDatabase,\n", "  RawPdbDatabase,\n\t  ToDoDatabase,\n\t} from '..';\n\t// Not using resolveJsonModule because it causes the output to be generated\n\t// relative to the root directory instead of src/.\n\tconst packageJson = require('../../package.json');\n\tinterface DatabaseRegistryEntry {\n\t  creator: string;\n\t  type: string;\n\t  databaseType: new () => PdbDatabase<any, any, any>;\n", "  label: string;\n\t}\n\tconst DATABASE_REGISTRY: Array<DatabaseRegistryEntry> = [\n\t  {creator: 'memo', type: 'DATA', databaseType: MemoDatabase, label: 'Memo'},\n\t  {creator: 'todo', type: 'DATA', databaseType: ToDoDatabase, label: 'ToDo'},\n\t  {\n\t    creator: 'date',\n\t    type: 'DATA',\n\t    databaseType: DatebookDatabase,\n\t    label: 'Datebook',\n", "  },\n\t  {\n\t    creator: 'addr',\n\t    type: 'DATA',\n\t    databaseType: AddressDatabase,\n\t    label: 'Address',\n\t  },\n\t  {\n\t    creator: 'REAd',\n\t    type: 'TEXt',\n", "    databaseType: PalmDocDatabase,\n\t    label: 'PalmDOC',\n\t  },\n\t];\n\tif (require.main === module) {\n\t  (async () => {\n\t    program.name('pdb2json').version(packageJson.version);\n\t    program\n\t      .description(\n\t        [\n", "          'Decode a PDB file and print it to JSON.',\n\t          'Supported formats: ' +\n\t            DATABASE_REGISTRY.map(({label}) => label).join(', '),\n\t        ].join('\\n')\n\t      )\n\t      .argument('<pdb-file>', 'Path to PDB file')\n\t      .option(\n\t        '--input-encoding <encoding>',\n\t        'text encoding of input PalmDOC PDB file',\n\t        DEFAULT_ENCODING\n", "      )\n\t      .action(async (inputFilePath, options) => {\n\t        // Read input file into buffer.\n\t        let pdbBuffer: Buffer;\n\t        let rawDb: RawPdbDatabase;\n\t        try {\n\t          pdbBuffer = await fs.readFile(inputFilePath);\n\t          rawDb = RawPdbDatabase.from(pdbBuffer);\n\t        } catch (e: any) {\n\t          console.error(`Could not open '${inputFilePath}': ${e.message}`);\n", "          process.exit(1);\n\t        }\n\t        // Find corresponding database type.\n\t        const {creator, type} = rawDb.header;\n\t        const dbRegistryEntry = DATABASE_REGISTRY.find(\n\t          (entry) => entry.creator === creator && entry.type === type\n\t        );\n\t        if (!dbRegistryEntry) {\n\t          console.error(\n\t            `Unknown database type: creator \"${creator}\", type \"${type}\"`\n", "          );\n\t          process.exit(1);\n\t        }\n\t        // Re-parse the file using the correct database.\n\t        const db = new dbRegistryEntry.databaseType();\n\t        try {\n\t          db.deserialize(pdbBuffer, {encoding: options.inputEncoding});\n\t        } catch (e: any) {\n\t          console.error(`Could not parse '${inputFilePath}': ${e.message}`);\n\t          process.exit(1);\n", "        }\n\t        // Print out result.\n\t        console.log(JSON.stringify(db, null, 4));\n\t      });\n\t    await program.parseAsync();\n\t  })();\n\t}\n"]}
{"filename": "src/tests/todo-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\n\timport pick from 'lodash/pick';\n\timport path from 'path';\n\timport {Category, DatabaseDate, ToDoDatabase, ToDoRecord} from '..';\n\tdescribe('ToDoDatabase', function () {\n\t  test('load test database', async function () {\n\t    const buffer = await fs.readFile(\n\t      path.join(__dirname, 'testdata', 'ToDoDB.pdb')\n\t    );\n\t    const db = ToDoDatabase.from(buffer);\n", "    expect(db.header).toMatchObject(\n\t      pick(new ToDoDatabase().header, ['name', 'type', 'creator'])\n\t    );\n\t    expect(db.appInfo?.categories.length).toStrictEqual(3);\n\t    expect(db.records.length).toStrictEqual(3);\n\t    for (const record of db.records) {\n\t      expect(record.description.length).toBeGreaterThan(1);\n\t      expect(record.priority).toStrictEqual(1);\n\t      expect(record.isCompleted).toStrictEqual(false);\n\t    }\n", "    let dueDate0 = db.records[0].dueDate;\n\t    expect(dueDate0?.year).toStrictEqual(2021);\n\t    expect(dueDate0?.month).toStrictEqual(1);\n\t    expect(dueDate0?.dayOfMonth).toStrictEqual(21);\n\t    expect(db.records[2].dueDate).toBeNull();\n\t  });\n\t  test('serialize', async function () {\n\t    // Create db1.\n\t    const db1 = new ToDoDatabase();\n\t    db1.appInfo!.categories = [\n", "      Category.with({label: 'Unfiled', uniqId: 0, isRenamed: false}),\n\t      Category.with({label: 'Personal', uniqId: 1, isRenamed: false}),\n\t    ];\n\t    for (let i = 0; i < 10; ++i) {\n\t      const record = new ToDoRecord();\n\t      record.description = `Task #${i}`;\n\t      record.note = `Note #${i}`;\n\t      record.priority = i + 1;\n\t      record.isCompleted = !!(i % 2);\n\t      if (i % 3) {\n", "        record.dueDate = DatabaseDate.of(new Date(2000 + i, 0, 1));\n\t      }\n\t      db1.records.push(record);\n\t    }\n\t    // Serialize to buffer and deserialize back into db2.\n\t    const buffer = db1.serialize();\n\t    const db2 = ToDoDatabase.from(buffer);\n\t    // Check db2 contents.\n\t    expect(db2.appInfo?.categories).toStrictEqual(db1.appInfo?.categories);\n\t    expect(db2.records.length).toStrictEqual(db1.records.length);\n", "    for (let i = 0; i < db1.records.length; ++i) {\n\t      expect(db2.records[i]).toStrictEqual(db1.records[i]);\n\t    }\n\t  });\n\t});\n"]}
{"filename": "src/tests/palmdoc-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\n\timport _ from 'lodash';\n\timport path from 'path';\n\timport {DeserializeOptions} from 'serio';\n\timport {PalmDoc, PalmDocSerializeOptions} from '..';\n\tdescribe('PalmDoc', function () {\n\t  test('load test database', async function () {\n\t    const buffer = await fs.readFile(\n\t      path.join(__dirname, 'testdata', 'OnBoardHeaderV40.pdb')\n\t    );\n", "    const doc = PalmDoc.from(buffer);\n\t    expect(doc.text).toContain('#define NULL 0');\n\t  });\n\t  for (const {label, text, serializeOpts, parseOpts} of [\n\t    {label: '\"Hello, world!\"', text: 'Hello, world!'},\n\t    {\n\t      label: '\"Hello, world!\" repeated 10K times',\n\t      text: 'Hello, world!'.repeat(10000),\n\t    },\n\t    {\n", "      label: '0x00 repeated 10K times',\n\t      text: '\\x00'.repeat(10000),\n\t    },\n\t    ..._.times(3, (n) => ({\n\t      label: `10K random base64 letters and spaces (pass #${n})`,\n\t      text: _.times(10000, () =>\n\t        generateRandomBuffer(Math.floor(1 + Math.random() * 10)).toString(\n\t          'base64'\n\t        )\n\t      ).join(' '),\n", "    })),\n\t    ..._.times(3, () => ({\n\t      label: 'base64 encoded random buffer of size 100K (pass #${n})',\n\t      text: generateRandomBuffer(100000).toString('base64'),\n\t    })),\n\t    {\n\t      label: '汉语',\n\t      text: '汉语，又称中文、唐话、华语，指整个汉语族或者其语族里的一种语言。',\n\t      serializeOpts: {\n\t        encoding: 'gb2312',\n", "        enableCompression: true,\n\t      },\n\t      parseOpts: {\n\t        encoding: 'gb2312',\n\t      },\n\t    },\n\t    {\n\t      label: '漢語',\n\t      text: '漢語，又稱中文、唐話、華語，指整個漢語族或者其語族里的一種語言。',\n\t      serializeOpts: {\n", "        encoding: 'big5',\n\t        enableCompression: true,\n\t      },\n\t      parseOpts: {\n\t        encoding: 'big5',\n\t      },\n\t    },\n\t    {\n\t      label: '日本語',\n\t      text: '日本語（にほんご、にっぽんご、英: Japanese）は、主に日本国内や日本人同士の間で使用されている言語。',\n", "      serializeOpts: {\n\t        encoding: 'shiftjis',\n\t        enableCompression: true,\n\t      },\n\t      parseOpts: {\n\t        encoding: 'shiftjis',\n\t      },\n\t    },\n\t  ] as Array<{\n\t    label: string;\n", "    text: string;\n\t    serializeOpts?: PalmDocSerializeOptions;\n\t    parseOpts?: DeserializeOptions;\n\t  }>) {\n\t    test(`serialize ${label}`, async function () {\n\t      // Create doc1.\n\t      const doc1 = new PalmDoc();\n\t      doc1.name = label.substring(0, 31);\n\t      doc1.text = text;\n\t      // Serialize to buffer and deserialize back into doc2.\n", "      const buffer = doc1.serialize(serializeOpts);\n\t      const doc2 = PalmDoc.from(buffer, parseOpts);\n\t      // Check doc2 contents.\n\t      expect(doc2.name).toStrictEqual(doc1.name);\n\t      expect(doc2.text).toStrictEqual(doc1.text);\n\t    });\n\t  }\n\t});\n\t/** Fill a Buffer of length n with random numbers. */\n\tfunction generateRandomBuffer(n: number) {\n", "  const buffer = Buffer.alloc(n);\n\t  let i = 0;\n\t  while (i + 4 <= n) {\n\t    buffer.writeUInt32BE(Math.floor(Math.random() * 0x100000000), i);\n\t    i += 4;\n\t  }\n\t  while (i < n) {\n\t    buffer.writeUInt8(Math.floor(Math.random() * 0x100), i);\n\t    ++i;\n\t  }\n", "  return buffer;\n\t}\n"]}
{"filename": "src/tests/prc-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\n\timport _ from 'lodash';\n\timport path from 'path';\n\timport {SmartBuffer} from 'smart-buffer';\n\timport {RawPrcRecord, RawPrcDatabase} from '..';\n\tdescribe('PrcDatabase', function () {\n\t  test('load test database', async function () {\n\t    const buffer = await fs.readFile(\n\t      path.join(__dirname, 'testdata', 'OnBoard.prc')\n\t    );\n", "    const db = RawPrcDatabase.from(buffer);\n\t    const recordsByType = _.groupBy(db.records, 'entry.type') as _.Dictionary<\n\t      Array<RawPrcRecord>\n\t    >;\n\t    for (const [type, resourceIds] of [\n\t      // Obtained from Simulator > View > Databases.\n\t      ['code', [0, 1, 2]],\n\t      ['data', [0]],\n\t      ['MBAR', [1000]],\n\t      ['pref', [0]],\n", "      ['tAIN', [1000]],\n\t      ['Tbmp', [1000, 1001, 1002, 1003, 1510, 1703, 2000, 2100, 2200, 2300]],\n\t      ['tFRM', [1100, 3400]],\n\t      ['tSTR', [1000]],\n\t      ['tver', [1000]],\n\t    ] as const) {\n\t      expect(recordsByType).toHaveProperty(type);\n\t      expect(\n\t        _.map(recordsByType[type], 'entry.resourceId').sort()\n\t      ).toStrictEqual(resourceIds);\n", "    }\n\t    expect(\n\t      SmartBuffer.fromBuffer(recordsByType['tAIN'][0].data).readStringNT()\n\t    ).toStrictEqual('OnBoard Asm');\n\t    expect(\n\t      SmartBuffer.fromBuffer(recordsByType['tver'][0].data).readStringNT()\n\t    ).toStrictEqual('2.5.1');\n\t  });\n\t  test('serialize', async function () {\n\t    // Create db1.\n", "    const db1 = new RawPrcDatabase();\n\t    db1.header.name = 'Foo';\n\t    expect(db1.header.attributes.resDB).toStrictEqual(true);\n\t    db1.header.type = 'appl';\n\t    db1.header.creator = 'TSt1';\n\t    for (let i = 0; i < 10; ++i) {\n\t      const record = new RawPrcRecord();\n\t      record.entry.type = 'code';\n\t      record.entry.resourceId = i;\n\t      record.data = new SmartBuffer().writeUInt32BE(i).toBuffer();\n", "      db1.records.push(record);\n\t    }\n\t    // Serialize to buffer and deserialize back into db2.\n\t    const buffer = db1.serialize();\n\t    const db2 = RawPrcDatabase.from(buffer);\n\t    // Check db2 contents.\n\t    expect(db2.records.length).toStrictEqual(db1.records.length);\n\t    for (let i = 0; i < db1.records.length; ++i) {\n\t      expect(db2.records[i]).toStrictEqual(db1.records[i]);\n\t    }\n", "  });\n\t});\n"]}
{"filename": "src/tests/memo-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\n\timport pick from 'lodash/pick';\n\timport path from 'path';\n\timport {Category, MemoDatabase, MemoRecord, MemoSortOrder} from '..';\n\tdescribe('MemoDatabase', function () {\n\t  test('load test database', async function () {\n\t    const buffer = await fs.readFile(\n\t      path.join(__dirname, 'testdata', 'MemoDB.pdb')\n\t    );\n\t    const db = MemoDatabase.from(buffer);\n", "    expect(db.header).toMatchObject(\n\t      pick(new MemoDatabase().header, ['name', 'type', 'creator'])\n\t    );\n\t    expect(db.appInfo?.categories.length).toStrictEqual(3);\n\t    expect(db.records.length).toStrictEqual(5);\n\t    for (const record of db.records) {\n\t      expect(record.value.length).toBeGreaterThan(1);\n\t    }\n\t  });\n\t  test('serialize', async function () {\n", "    // Create db1.\n\t    const db1 = new MemoDatabase();\n\t    db1.appInfo!.categories = [\n\t      Category.with({label: 'Unfiled', uniqId: 0, isRenamed: false}),\n\t      Category.with({label: 'Personal', uniqId: 1, isRenamed: false}),\n\t    ];\n\t    db1.appInfo!.sortOrder = MemoSortOrder.ALPHABETICAL;\n\t    for (let i = 0; i < 10; ++i) {\n\t      const record = new MemoRecord();\n\t      record.value = `Memo #${i}`;\n", "      db1.records.push(record);\n\t    }\n\t    // Serialize to buffer and deserialize back into db2.\n\t    const buffer = db1.serialize();\n\t    const db2 = MemoDatabase.from(buffer);\n\t    // Check db2 contents.\n\t    expect(db2.appInfo?.categories).toStrictEqual(db1.appInfo?.categories);\n\t    expect(db2.appInfo?.sortOrder).toStrictEqual(db1.appInfo?.sortOrder);\n\t    expect(db2.records.length).toStrictEqual(db1.records.length);\n\t    for (let i = 0; i < db1.records.length; ++i) {\n", "      expect(db2.records[i]).toStrictEqual(db1.records[i]);\n\t    }\n\t  });\n\t});\n"]}
{"filename": "src/tests/address-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\n\timport pick from 'lodash/pick';\n\timport path from 'path';\n\timport {SObject, SStringNT} from 'serio';\n\timport {\n\t  AddressCountry,\n\t  AddressDatabase,\n\t  AddressFieldType,\n\t  PHONE_NUMBER_FIELD_TYPES,\n\t  PhoneNumberType,\n", "} from '..';\n\tasync function loadTestDbAndDoBasicChecks(dbFile: string, encoding?: string) {\n\t  const buffer = await fs.readFile(path.join(__dirname, 'testdata', dbFile));\n\t  const db = AddressDatabase.from(buffer, {encoding});\n\t  expect(db.header).toMatchObject(\n\t    pick(new AddressDatabase().header, ['name', 'type', 'creator'])\n\t  );\n\t  expect((db.appInfo?.categories ?? []).length).toBeGreaterThan(0);\n\t  expect(db.records.length).toBeGreaterThan(0);\n\t  for (const record of db.records) {\n", "    expect(record.cells.length).toBeGreaterThan(0);\n\t    expect(Object.keys(record.phoneNumberTypeMapping)).toStrictEqual(\n\t      PHONE_NUMBER_FIELD_TYPES.map((t) => t.toString())\n\t    );\n\t  }\n\t  return db;\n\t}\n\tfunction mapToJson(array: Array<SObject>) {\n\t  return array.map((e) => e.toJSON());\n\t}\n", "describe('AddressDatabase', function () {\n\t  describe('load test databases', function () {\n\t    test(`load test database AddressDB-LifeDrive.pdb`, async function () {\n\t      const db = await loadTestDbAndDoBasicChecks('AddressDB-LifeDrive.pdb');\n\t      expect(mapToJson(db.appInfo!.categories)).toStrictEqual([\n\t        {\n\t          label: 'Unfiled',\n\t          uniqId: 0,\n\t          isRenamed: true,\n\t        },\n", "        {\n\t          label: 'Business',\n\t          uniqId: 1,\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          label: 'Personal',\n\t          uniqId: 2,\n\t          isRenamed: true,\n\t        },\n", "        {\n\t          label: 'QuickList',\n\t          uniqId: 3,\n\t          isRenamed: true,\n\t        },\n\t      ]);\n\t      expect(db.appInfo?.fields).toStrictEqual([\n\t        {\n\t          type: AddressFieldType.LAST_NAME,\n\t          label: 'Last name',\n", "          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.FIRST_NAME,\n\t          label: 'First name',\n\t          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.COMPANY,\n\t          label: 'Company',\n", "          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_1,\n\t          label: 'Work',\n\t          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_2,\n\t          label: 'Home',\n", "          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_3,\n\t          label: 'Fax',\n\t          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_4,\n\t          label: 'Other',\n", "          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_5,\n\t          label: 'E-mail',\n\t          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.ADDRESS,\n\t          label: 'Addr(W)',\n", "          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.CITY,\n\t          label: 'City',\n\t          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.STATE,\n\t          label: 'State',\n", "          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.ZIP_CODE,\n\t          label: 'Zip Code',\n\t          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.COUNTRY,\n\t          label: 'Country',\n", "          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.TITLE,\n\t          label: 'Title',\n\t          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.CUSTOM_1,\n\t          label: 'Custom 1',\n", "          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.CUSTOM_2,\n\t          label: 'Custom 2',\n\t          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.CUSTOM_3,\n\t          label: 'Custom 3',\n", "          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.CUSTOM_4,\n\t          label: 'Custom 4',\n\t          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.NOTE,\n\t          label: 'Note',\n", "          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_6,\n\t          label: 'Main',\n\t          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_7,\n\t          label: 'Pager',\n", "          isRenamed: false,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_8,\n\t          label: 'Mobile',\n\t          isRenamed: false,\n\t        },\n\t      ]);\n\t      expect(db.appInfo?.country).toStrictEqual(AddressCountry.UNITED_STATES);\n\t      expect(db.records).toHaveLength(2);\n", "      expect(db.records[1].phoneNumberTypeMapping).toStrictEqual({\n\t        [AddressFieldType.PHONE_1]: PhoneNumberType.MAIN,\n\t        [AddressFieldType.PHONE_2]: PhoneNumberType.OTHER,\n\t        [AddressFieldType.PHONE_3]: PhoneNumberType.MOBILE,\n\t        [AddressFieldType.PHONE_4]: PhoneNumberType.EMAIL,\n\t        [AddressFieldType.PHONE_5]: PhoneNumberType.MAIN,\n\t      });\n\t      expect(db.records[1].cells).toStrictEqual([\n\t        {\n\t          fieldType: AddressFieldType.LAST_NAME,\n", "          value: 'Technical Support',\n\t        },\n\t        {\n\t          fieldType: AddressFieldType.COMPANY,\n\t          value: 'palmOne, Inc.',\n\t        },\n\t        {\n\t          fieldType: AddressFieldType.PHONE_1,\n\t          phoneNumberType: PhoneNumberType.MAIN,\n\t          value: 'www.palmOne.com/support',\n", "        },\n\t        {\n\t          fieldType: AddressFieldType.PHONE_2,\n\t          phoneNumberType: PhoneNumberType.OTHER,\n\t          value: \"Int'l: www.palmOne.com/support/intl\",\n\t        },\n\t        {\n\t          fieldType: AddressFieldType.NOTE,\n\t          value:\n\t            'For the latest information on products and upgrades, check our web site regularly.',\n", "        },\n\t      ]);\n\t    });\n\t    test(`load test database AddressDB-Palm V-JP.pdb`, async function () {\n\t      const db = await loadTestDbAndDoBasicChecks(\n\t        'AddressDB-Palm V-JP.pdb',\n\t        'shiftjis'\n\t      );\n\t      expect(mapToJson(db.appInfo!.categories)).toStrictEqual([\n\t        {\n", "          label: '未分類',\n\t          uniqId: 0,\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          label: 'ビジネス',\n\t          uniqId: 1,\n\t          isRenamed: true,\n\t        },\n\t        {\n", "          label: 'パーソナル',\n\t          uniqId: 2,\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          label: 'クイックリスト',\n\t          uniqId: 3,\n\t          isRenamed: true,\n\t        },\n\t      ]);\n", "      expect(db.appInfo?.fields).toStrictEqual([\n\t        {\n\t          type: AddressFieldType.LAST_NAME,\n\t          label: '姓',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.FIRST_NAME,\n\t          label: '名',\n\t          isRenamed: true,\n", "        },\n\t        {\n\t          type: AddressFieldType.COMPANY,\n\t          label: '会社名',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_1,\n\t          label: '会社',\n\t          isRenamed: true,\n", "        },\n\t        {\n\t          type: AddressFieldType.PHONE_2,\n\t          label: '自宅',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_3,\n\t          label: 'Fax',\n\t          isRenamed: true,\n", "        },\n\t        {\n\t          type: AddressFieldType.PHONE_4,\n\t          label: 'その他',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_5,\n\t          label: 'E-mail',\n\t          isRenamed: true,\n", "        },\n\t        {\n\t          type: AddressFieldType.ADDRESS,\n\t          label: '住所',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.CITY,\n\t          label: '市町村',\n\t          isRenamed: true,\n", "        },\n\t        {\n\t          type: AddressFieldType.STATE,\n\t          label: '都道府県',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.ZIP_CODE,\n\t          label: '郵便番号',\n\t          isRenamed: true,\n", "        },\n\t        {\n\t          type: AddressFieldType.COUNTRY,\n\t          label: '国',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.TITLE,\n\t          label: '役職',\n\t          isRenamed: true,\n", "        },\n\t        {\n\t          type: AddressFieldType.CUSTOM_1,\n\t          label: 'カスタム 1',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.CUSTOM_2,\n\t          label: 'カスタム 2',\n\t          isRenamed: true,\n", "        },\n\t        {\n\t          type: AddressFieldType.CUSTOM_3,\n\t          label: 'カスタム 3',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.CUSTOM_4,\n\t          label: 'カスタム 4',\n\t          isRenamed: true,\n", "        },\n\t        {\n\t          type: AddressFieldType.NOTE,\n\t          label: 'ｺﾒﾝﾄ',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_6,\n\t          label: '代表',\n\t          isRenamed: true,\n", "        },\n\t        {\n\t          type: AddressFieldType.PHONE_7,\n\t          label: 'ポケベル',\n\t          isRenamed: true,\n\t        },\n\t        {\n\t          type: AddressFieldType.PHONE_8,\n\t          label: '携帯',\n\t          isRenamed: true,\n", "        },\n\t      ]);\n\t      expect(db.appInfo?.country).toStrictEqual(AddressCountry.JAPAN);\n\t      expect(db.records).toHaveLength(1);\n\t      expect(db.records[0].phoneNumberTypeMapping).toStrictEqual({\n\t        [AddressFieldType.PHONE_1]: PhoneNumberType.WORK,\n\t        [AddressFieldType.PHONE_2]: PhoneNumberType.HOME,\n\t        [AddressFieldType.PHONE_3]: PhoneNumberType.FAX,\n\t        [AddressFieldType.PHONE_4]: PhoneNumberType.OTHER,\n\t        [AddressFieldType.PHONE_5]: PhoneNumberType.EMAIL,\n", "      });\n\t      expect(db.records[0].cells).toStrictEqual([\n\t        {\n\t          fieldType: AddressFieldType.LAST_NAME,\n\t          value: '田中\\u0001たなか',\n\t        },\n\t        {\n\t          fieldType: AddressFieldType.FIRST_NAME,\n\t          value: '太郎\\u0001たろう',\n\t        },\n", "        {\n\t          fieldType: AddressFieldType.ADDRESS,\n\t          value: '港区六本木6丁目10ー1',\n\t        },\n\t        {\n\t          fieldType: AddressFieldType.STATE,\n\t          value: '東京都',\n\t        },\n\t        {\n\t          fieldType: AddressFieldType.ZIP_CODE,\n", "          value: '106-6126',\n\t        },\n\t        {\n\t          fieldType: AddressFieldType.COUNTRY,\n\t          value: '日本',\n\t        },\n\t      ]);\n\t    });\n\t    test(`load test database AddressDB-Palm V-FR.pdb`, async function () {\n\t      const db = await loadTestDbAndDoBasicChecks('AddressDB-Palm V-FR.pdb');\n", "      expect(db.appInfo?.country).toStrictEqual(AddressCountry.FRANCE);\n\t      expect(db.records).toHaveLength(2);\n\t    });\n\t  });\n\t  describe('serialize', function () {\n\t    test(`using test database AddressDB-LifeDrive.pdb`, async function () {\n\t      const db1 = await loadTestDbAndDoBasicChecks('AddressDB-LifeDrive.pdb');\n\t      const db2 = AddressDatabase.from(db1.serialize());\n\t      expect(db2.records).toHaveLength(db1.records.length);\n\t      for (let i = 0; i < db1.records.length; ++i) {\n", "        const rec1 = db1.records[i];\n\t        const rec2 = db2.records[i];\n\t        expect(rec2.mainPhoneNumberType).toStrictEqual(\n\t          rec1.mainPhoneNumberType\n\t        );\n\t        expect(rec2.phoneNumberTypeMapping).toStrictEqual(\n\t          rec1.phoneNumberTypeMapping\n\t        );\n\t        expect((rec2 as any)['companyCellValueOffset']).toBeGreaterThan(0);\n\t        expect((rec2 as any)['companyCellValueOffset']).toStrictEqual(\n", "          (rec1 as any)['companyCellValueOffset']\n\t        );\n\t        expect(\n\t          SStringNT.from(\n\t            rec2\n\t              .serialize()\n\t              .subarray(9 + (rec2 as any)['companyCellValueOffset'] - 1)\n\t          ).value\n\t        ).toStrictEqual(rec1.get(AddressFieldType.COMPANY));\n\t        expect(rec2.cells).toStrictEqual(rec1.cells);\n", "      }\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/tests/datebook-database.test.ts", "chunked_list": ["import fs from 'fs-extra';\n\timport pick from 'lodash/pick';\n\timport path from 'path';\n\timport {\n\t  AlarmSettings,\n\t  AlarmTimeUnit,\n\t  DatabaseDate,\n\t  DatebookDatabase,\n\t  DatebookRecord,\n\t  EventTime,\n", "  RecurrenceFrequency,\n\t  RecurrenceSettings,\n\t} from '..';\n\tdescribe('DatebookDatabase', function () {\n\t  test('load test database', async function () {\n\t    const buffer = await fs.readFile(\n\t      path.join(__dirname, 'testdata', 'DatebookDB.pdb')\n\t    );\n\t    const db = DatebookDatabase.from(buffer);\n\t    expect(db.header).toMatchObject(\n", "      pick(new DatebookDatabase().header, ['name', 'type', 'creator'])\n\t    );\n\t    expect(db.records.length).toStrictEqual(3);\n\t    for (const record of db.records) {\n\t      expect(record.date.year).toStrictEqual(2021);\n\t      expect(record.date.month).toStrictEqual(1);\n\t      expect(record.startTime?.hour).toBeGreaterThan(0);\n\t      expect(record.startTime?.minute).toStrictEqual(0);\n\t      expect(record.endTime?.hour).toBeGreaterThan(0);\n\t      expect(record.endTime?.minute).toStrictEqual(0);\n", "      expect(record.description.length).toBeGreaterThan(1);\n\t    }\n\t    expect(db.records[0].recurrenceSettings).toMatchObject({\n\t      frequency: RecurrenceFrequency.WEEKLY,\n\t      weekly: {\n\t        days: [false, false, false, false, false, false, true],\n\t        firstDayOfWeek: 0,\n\t      },\n\t      interval: 1,\n\t      endDate: null,\n", "    });\n\t  });\n\t  test('serialize', async function () {\n\t    // Create db1.\n\t    const db1 = new DatebookDatabase();\n\t    for (let i = 0; i < 30; ++i) {\n\t      const record = new DatebookRecord();\n\t      record.description = `Event #${i}`;\n\t      record.note = `Note #${i}`;\n\t      record.date.year = 2000 + i;\n", "      if (i % 2) {\n\t        record.startTime = EventTime.with({hour: i % 24, minute: 0});\n\t        record.endTime = EventTime.with({hour: i % 24, minute: 30});\n\t      }\n\t      if (i % 3) {\n\t        record.alarmSettings = AlarmSettings.with({\n\t          unit: AlarmTimeUnit.MINUTES,\n\t          value: i,\n\t        });\n\t      }\n", "      if (i % 10 === 0) {\n\t        record.recurrenceSettings = null;\n\t      } else {\n\t        if (i < 7) {\n\t          record.recurrenceSettings = RecurrenceSettings.with({\n\t            frequency: RecurrenceFrequency.WEEKLY,\n\t            weekly: {\n\t              days: [false, false, false, false, false, false, false],\n\t              firstDayOfWeek: 0,\n\t            },\n", "            interval: 1,\n\t            endDate: null,\n\t          });\n\t          for (let j = 0; j < i; j += 2) {\n\t            record.recurrenceSettings.weekly!.days[j] = true;\n\t          }\n\t        } else if (i < 15) {\n\t          record.recurrenceSettings = RecurrenceSettings.with({\n\t            frequency: RecurrenceFrequency.MONTHLY_BY_DAY,\n\t            monthlyByDay: {\n", "              weekOfMonth: i % 6,\n\t              day: i % 7,\n\t            },\n\t            interval: 1,\n\t            endDate: null,\n\t          });\n\t        } else {\n\t          const frequencies = [\n\t            RecurrenceFrequency.DAILY,\n\t            RecurrenceFrequency.MONTHLY_BY_DATE,\n", "            RecurrenceFrequency.YEARLY,\n\t          ] as const;\n\t          const frequency = frequencies[i % frequencies.length];\n\t          record.recurrenceSettings = RecurrenceSettings.with({\n\t            frequency,\n\t            interval: i,\n\t            endDate: null,\n\t          });\n\t        }\n\t        if (i % 4 && record.recurrenceSettings) {\n", "          record.recurrenceSettings.endDate = DatabaseDate.of(\n\t            new Date(2001 + i, 0, 1)\n\t          );\n\t        }\n\t      }\n\t      db1.records.push(record);\n\t    }\n\t    // Serialize to buffer and deserialize back into db2.\n\t    const buffer = db1.serialize();\n\t    const db2 = DatebookDatabase.from(buffer);\n", "    // Check db2 contents.\n\t    expect(db2.appInfo?.categories).toStrictEqual(db1.appInfo?.categories);\n\t    expect(db2.records.length).toStrictEqual(db1.records.length);\n\t    for (let i = 0; i < db1.records.length; ++i) {\n\t      expect(db2.records[i]).toStrictEqual(db1.records[i]);\n\t    }\n\t  });\n\t});\n"]}
