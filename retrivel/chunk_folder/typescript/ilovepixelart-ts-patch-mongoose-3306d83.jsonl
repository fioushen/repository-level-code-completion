{"filename": "jest.config.ts", "chunked_list": ["// For a detailed explanation regarding each configuration property, visit:\n\t// https://jestjs.io/docs/en/configuration.html\n\timport { recursive } from 'merge'\n\timport mongo from '@shelf/jest-mongodb/jest-preset'\n\tconst config = recursive(mongo, {\n\t  roots: [\n\t    '<rootDir>/src/',\n\t    '<rootDir>/tests/'\n\t  ],\n\t  clearMocks: true,\n", "  collectCoverage: true,\n\t  collectCoverageFrom: [\n\t    'src/**/*.ts',\n\t    '!src/**/*.d.ts',\n\t    '!src/interfaces/**/*.ts'\n\t  ],\n\t  coverageDirectory: 'coverage',\n\t  testMatch: [\n\t    '<rootDir>/tests/**/*.test.ts'\n\t  ],\n", "  transform: {\n\t    '^.+\\\\.(t|j)sx?$': '@swc/jest'\n\t  },\n\t  testPathIgnorePatterns: [\n\t    'node_modules'\n\t  ],\n\t  watchPathIgnorePatterns: [\n\t    'globalConfig'\n\t  ]\n\t})\n", "export default config\n"]}
{"filename": "jest-mongodb-config.ts", "chunked_list": ["export default {\n\t  mongodbMemoryServerOptions: {\n\t    binary: {\n\t      skipMD5: true\n\t    },\n\t    autoStart: false,\n\t    instance: {}\n\t  },\n\t  useSharedDBForAllJestWorkers: false\n\t}\n"]}
{"filename": "tests/plugin-patch-history-disabled.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\timport mongoose, { model } from 'mongoose'\n\timport UserSchema from './schemas/UserSchema'\n\timport { patchHistoryPlugin } from '../src/plugin'\n\timport History from '../src/models/History'\n\timport em from '../src/em'\n\tjest.mock('../src/em', () => {\n\t  return { emit: jest.fn() }\n\t})\n\tdescribe('plugin - patch history disabled', () => {\n", "  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\t  UserSchema.plugin(patchHistoryPlugin, {\n\t    patchHistoryDisabled: true\n\t  })\n\t  const User = model('User', UserSchema)\n\t  beforeAll(async () => {\n\t    await mongoose.connect(uri)\n\t  })\n\t  afterAll(async () => {\n\t    await mongoose.connection.close()\n", "  })\n\t  beforeEach(async () => {\n\t    await mongoose.connection.collection('users').deleteMany({})\n\t    await mongoose.connection.collection('history').deleteMany({})\n\t  })\n\t  it('should createHistory', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    user.name = 'Alice'\n\t    await user.save()\n", "    user.name = 'Bob'\n\t    await user.save()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    await User.deleteMany({ role: 'user' }).exec()\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should omit update of role', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n", "    user.role = 'manager'\n\t    await user.save()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should updateOne', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    await User.updateOne({ _id: user._id }, { name: 'Alice' }).exec()\n", "    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should findOneAndUpdate', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    await User.findOneAndUpdate({ _id: user._id }, { name: 'Alice' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n", "    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should update deprecated', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    if (isMongooseLessThan7) {\n\t      await User.update({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n\t    } else {\n\t      await User.findOneAndUpdate({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n\t    }\n", "    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t  })\n\t  it('should updated deprecated with multi flag', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n\t    expect(john.name).toBe('John')\n\t    const alice = await User.create({ name: 'Alice', role: 'user' })\n\t    expect(alice.name).toBe('Alice')\n\t    if (isMongooseLessThan7) {\n\t      await User.update({ role: 'user' }, { $set: { name: 'Bob' } }, { multi: true }).exec()\n", "    } else {\n\t      await User.updateMany({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n\t    }\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should create many', async () => {\n\t    await User.create([\n\t      { name: 'John', role: 'user' },\n", "      { name: 'Alice', role: 'user' }\n\t    ])\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should findOneAndUpdate upsert', async () => {\n\t    await User.findOneAndUpdate({ name: 'John', role: 'user' }, { name: 'Bob', role: 'user' }, { upsert: true, runValidators: true }).exec()\n\t    const documents = await User.find({})\n\t    expect(documents).toHaveLength(1)\n", "    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should update many', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n\t    expect(john.name).toBe('John')\n\t    const alice = await User.create({ name: 'Alice', role: 'user' })\n\t    expect(alice.name).toBe('Alice')\n\t    await User.updateMany({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n", "    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t})\n"]}
{"filename": "tests/em.test.ts", "chunked_list": ["import { emitEvent } from '../src/patch'\n\timport { patchEventEmitter } from '../src/plugin'\n\tdescribe('em', () => {\n\t  it('should subscribe and count', async () => {\n\t    let count = 0\n\t    const fn = () => {\n\t      count++\n\t    }\n\t    patchEventEmitter.on('test', fn)\n\t    patchEventEmitter.emit('test')\n", "    expect(count).toBe(1)\n\t    patchEventEmitter.off('test', fn)\n\t    patchEventEmitter.emit('test')\n\t    expect(count).toBe(1)\n\t  })\n\t  it('emitEvent', async () => {\n\t    const fn = jest.fn()\n\t    patchEventEmitter.on('test', fn)\n\t    const context = {\n\t      op: 'test',\n", "      modelName: 'Test',\n\t      collectionName: 'tests'\n\t    }\n\t    emitEvent(context, 'test', { doc: { name: 'test' } })\n\t    expect(fn).toHaveBeenCalledTimes(1)\n\t    patchEventEmitter.off('test', fn)\n\t  })\n\t  it('emitEvent ignore', async () => {\n\t    const fn = jest.fn()\n\t    patchEventEmitter.on('test', fn)\n", "    const context = {\n\t      ignoreEvent: true,\n\t      op: 'test',\n\t      modelName: 'Test',\n\t      collectionName: 'tests'\n\t    }\n\t    emitEvent(context, 'test', { doc: { name: 'test' } })\n\t    expect(fn).toHaveBeenCalledTimes(0)\n\t    patchEventEmitter.off('test', fn)\n\t  })\n", "})\n"]}
{"filename": "tests/plugin.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\timport mongoose from 'mongoose'\n\timport UserSchema from './schemas/UserSchema'\n\timport { patchHistoryPlugin } from '../src/plugin'\n\timport History from '../src/models/History'\n\timport em from '../src/em'\n\timport { USER_CREATED, USER_UPDATED, USER_DELETED } from './constants/events'\n\tjest.mock('../src/em', () => {\n\t  return { emit: jest.fn() }\n\t})\n", "describe('plugin', () => {\n\t  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\t  UserSchema.plugin(patchHistoryPlugin, {\n\t    eventCreated: USER_CREATED,\n\t    eventUpdated: USER_UPDATED,\n\t    eventDeleted: USER_DELETED,\n\t    omit: ['__v', 'role', 'createdAt', 'updatedAt']\n\t  })\n\t  const User = mongoose.model('User', UserSchema)\n\t  beforeAll(async () => {\n", "    await mongoose.connect(uri)\n\t  })\n\t  afterAll(async () => {\n\t    await mongoose.connection.close()\n\t  })\n\t  beforeEach(async () => {\n\t    await mongoose.connection.collection('users').deleteMany({})\n\t    await mongoose.connection.collection('history').deleteMany({})\n\t  })\n\t  it('should createHistory', async () => {\n", "    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    user.name = 'Alice'\n\t    await user.save()\n\t    user.name = 'Bob'\n\t    await user.save()\n\t    await User.deleteMany({ role: 'user' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(4)\n\t    const [first, second, third, fourth] = history\n", "    // 1 create\n\t    expect(first.version).toBe(0)\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(user._id)\n\t    expect(first.doc).toHaveProperty('_id', user._id)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n", "    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.patch).toHaveLength(0)\n\t    // 2 update\n\t    expect(second.version).toBe(1)\n\t    expect(second.op).toBe('update')\n\t    expect(second.modelName).toBe('User')\n\t    expect(second.collectionName).toBe('users')\n\t    expect(second.collectionId).toEqual(user._id)\n\t    expect(second.doc).toBeUndefined()\n\t    expect(second.patch).toHaveLength(2)\n", "    expect(second.patch).toMatchObject([\n\t      { op: 'test', path: '/name', value: 'John' },\n\t      { op: 'replace', path: '/name', value: 'Alice' }\n\t    ])\n\t    // 3 update\n\t    expect(third.version).toBe(2)\n\t    expect(third.op).toBe('update')\n\t    expect(third.modelName).toBe('User')\n\t    expect(third.collectionName).toBe('users')\n\t    expect(third.collectionId).toEqual(user._id)\n", "    expect(third.doc).toBeUndefined()\n\t    expect(third.patch).toHaveLength(2)\n\t    expect(third.patch).toMatchObject([\n\t      { op: 'test', path: '/name', value: 'Alice' },\n\t      { op: 'replace', path: '/name', value: 'Bob' }\n\t    ])\n\t    // 4 delete\n\t    expect(fourth.version).toBe(0)\n\t    expect(fourth.op).toBe('deleteMany')\n\t    expect(fourth.modelName).toBe('User')\n", "    expect(fourth.collectionName).toBe('users')\n\t    expect(fourth.collectionId).toEqual(user._id)\n\t    expect(fourth.doc).toHaveProperty('_id', user._id)\n\t    expect(fourth.doc).toHaveProperty('name', 'Bob')\n\t    expect(fourth.doc).toHaveProperty('role', 'user')\n\t    expect(fourth.doc).toHaveProperty('createdAt')\n\t    expect(fourth.doc).toHaveProperty('updatedAt')\n\t    expect(fourth.patch).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(4)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n", "    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({ _id: user._id, name: 'John', role: 'user' }),\n\t      doc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),\n\t      patch: second.patch\n\t    })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),\n\t      doc: expect.objectContaining({ _id: user._id, name: 'Bob', role: 'user' }),\n\t      patch: third.patch\n\t    })\n", "    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining({ _id: user._id, name: 'Bob', role: 'user' })\n\t    })\n\t  })\n\t  it('should omit update of role', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    user.role = 'manager'\n\t    await user.save()\n\t    const history = await History.find({})\n", "    expect(history).toHaveLength(1)\n\t    const [first] = history\n\t    // 1 create\n\t    expect(first.version).toBe(0)\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(user._id)\n\t    expect(first.doc).toHaveProperty('_id', user._id)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n", "    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n\t    // no update event emitted because role is omitted\n\t  })\n\t  it('should updateOne', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n", "    expect(user.name).toBe('John')\n\t    await User.updateOne({ _id: user._id }, { name: 'Alice' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(2)\n\t    const [first, second] = history\n\t    // 1 create\n\t    expect(first.version).toBe(0)\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n", "    expect(first.collectionId).toEqual(user._id)\n\t    expect(first.doc).toHaveProperty('_id', user._id)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.patch).toHaveLength(0)\n\t    // 2 update\n\t    expect(second.version).toBe(1)\n\t    expect(second.op).toBe('updateOne')\n", "    expect(second.modelName).toBe('User')\n\t    expect(second.collectionName).toBe('users')\n\t    expect(second.collectionId).toEqual(user._id)\n\t    expect(second.doc).toBeUndefined()\n\t    expect(second.patch).toHaveLength(2)\n\t    expect(second.patch).toMatchObject([\n\t      { op: 'test', path: '/name', value: 'John' },\n\t      { op: 'replace', path: '/name', value: 'Alice' }\n\t    ])\n\t    expect(em.emit).toHaveBeenCalledTimes(2)\n", "    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({ _id: user._id, name: 'John', role: 'user' }),\n\t      doc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),\n\t      patch: second.patch\n\t    })\n\t  })\n\t  it('should findOneAndUpdate', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n", "    await User.findOneAndUpdate({ _id: user._id }, { name: 'Alice' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(2)\n\t    const [first, second] = history\n\t    // 1 create\n\t    expect(first.version).toBe(0)\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(user._id)\n", "    expect(first.doc).toHaveProperty('_id', user._id)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.patch).toHaveLength(0)\n\t    // 2 update\n\t    expect(second.version).toBe(1)\n\t    expect(second.op).toBe('findOneAndUpdate')\n\t    expect(second.modelName).toBe('User')\n", "    expect(second.collectionName).toBe('users')\n\t    expect(second.collectionId).toEqual(user._id)\n\t    expect(second.doc).toBeUndefined()\n\t    expect(second.patch).toHaveLength(2)\n\t    expect(second.patch).toMatchObject([\n\t      { op: 'test', path: '/name', value: 'John' },\n\t      { op: 'replace', path: '/name', value: 'Alice' }\n\t    ])\n\t    expect(em.emit).toHaveBeenCalledTimes(2)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n", "    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({ _id: user._id, name: 'John', role: 'user' }),\n\t      doc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),\n\t      patch: second.patch\n\t    })\n\t  })\n\t  it('should update deprecated', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    if (isMongooseLessThan7) {\n", "      await User.update({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n\t    } else {\n\t      await User.findOneAndUpdate({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n\t    }\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(2)\n\t    const [first, second] = history\n\t    // 1 create\n\t    expect(first.version).toBe(0)\n\t    expect(first.op).toBe('create')\n", "    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(user._id)\n\t    expect(first.doc).toHaveProperty('_id', user._id)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.patch).toHaveLength(0)\n\t    // 2 update\n", "    expect(second.version).toBe(1)\n\t    expect(second.modelName).toBe('User')\n\t    expect(second.collectionName).toBe('users')\n\t    expect(second.collectionId).toEqual(user._id)\n\t    expect(second.doc).toBeUndefined()\n\t    expect(second.patch).toHaveLength(2)\n\t    expect(second.patch).toMatchObject([\n\t      { op: 'test', path: '/name', value: 'John' },\n\t      { op: 'replace', path: '/name', value: 'Alice' }\n\t    ])\n", "    expect(em.emit).toHaveBeenCalledTimes(2)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({ _id: user._id, name: 'John', role: 'user' }),\n\t      doc: expect.objectContaining({ _id: user._id, name: 'Alice', role: 'user' }),\n\t      patch: second.patch\n\t    })\n\t  })\n\t  it('should updated deprecated with multi flag', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n", "    expect(john.name).toBe('John')\n\t    const alice = await User.create({ name: 'Alice', role: 'user' })\n\t    expect(alice.name).toBe('Alice')\n\t    if (isMongooseLessThan7) {\n\t      await User.update({ role: 'user' }, { $set: { name: 'Bob' } }, { multi: true }).exec()\n\t    } else {\n\t      await User.findOneAndUpdate({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n\t    }\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(4)\n", "    const [first, second, third, fourth] = history\n\t    // 1 create\n\t    expect(first.version).toBe(0)\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(john._id)\n\t    expect(first.doc).toHaveProperty('_id', john._id)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n", "    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.patch).toHaveLength(0)\n\t    // 2 create\n\t    expect(second.version).toBe(0)\n\t    expect(second.op).toBe('create')\n\t    expect(second.modelName).toBe('User')\n\t    expect(second.collectionName).toBe('users')\n\t    expect(second.collectionId).toEqual(alice._id)\n\t    expect(second.doc).toHaveProperty('_id', alice._id)\n", "    expect(second.doc).toHaveProperty('name', 'Alice')\n\t    expect(second.doc).toHaveProperty('role', 'user')\n\t    expect(second.doc).toHaveProperty('createdAt')\n\t    expect(second.doc).toHaveProperty('updatedAt')\n\t    expect(second.patch).toHaveLength(0)\n\t    // 3 update\n\t    expect(third.version).toBe(1)\n\t    expect(third.modelName).toBe('User')\n\t    expect(third.collectionName).toBe('users')\n\t    expect(third.collectionId).toEqual(john._id)\n", "    expect(third.doc).toBeUndefined()\n\t    expect(third.patch).toHaveLength(2)\n\t    expect(third.patch).toMatchObject([\n\t      { op: 'test', path: '/name', value: 'John' },\n\t      { op: 'replace', path: '/name', value: 'Bob' }\n\t    ])\n\t    // 4 update\n\t    expect(fourth.version).toBe(1)\n\t    expect(fourth.modelName).toBe('User')\n\t    expect(fourth.collectionName).toBe('users')\n", "    expect(fourth.collectionId).toEqual(alice._id)\n\t    expect(fourth.doc).toBeUndefined()\n\t    expect(fourth.patch).toHaveLength(2)\n\t    expect(fourth.patch).toMatchObject([\n\t      { op: 'test', path: '/name', value: 'Alice' },\n\t      { op: 'replace', path: '/name', value: 'Bob' }\n\t    ])\n\t    expect(em.emit).toHaveBeenCalledTimes(4)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: second.doc })\n", "    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({ _id: john._id, name: 'John', role: 'user' }),\n\t      doc: expect.objectContaining({ _id: john._id, name: 'Bob', role: 'user' }),\n\t      patch: third.patch\n\t    })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({ _id: alice._id, name: 'Alice', role: 'user' }),\n\t      doc: expect.objectContaining({ _id: alice._id, name: 'Bob', role: 'user' }),\n\t      patch: fourth.patch\n\t    })\n", "  })\n\t  it('should create many', async () => {\n\t    await User.create([\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'John', role: 'user' }\n\t    ])\n\t    const history = await History.find({}).sort('doc.name')\n\t    expect(history).toHaveLength(2)\n\t    const [first, second] = history\n\t    // 1 create\n", "    expect(first.version).toBe(0)\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.doc).toHaveProperty('_id')\n\t    expect(first.doc).toHaveProperty('name', 'Alice')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.patch).toHaveLength(0)\n", "    // 2 create\n\t    expect(second.version).toBe(0)\n\t    expect(second.op).toBe('create')\n\t    expect(second.modelName).toBe('User')\n\t    expect(second.collectionName).toBe('users')\n\t    expect(second.doc).toHaveProperty('_id')\n\t    expect(second.doc).toHaveProperty('name', 'John')\n\t    expect(second.doc).toHaveProperty('role', 'user')\n\t    expect(second.doc).toHaveProperty('createdAt')\n\t    expect(second.doc).toHaveProperty('updatedAt')\n", "    expect(second.patch).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(2)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: second.doc })\n\t  })\n\t  it('should findOneAndUpdate upsert', async () => {\n\t    await User.findOneAndUpdate({ name: 'John', role: 'user' }, { name: 'Bob', role: 'user' }, { upsert: true, runValidators: true }).exec()\n\t    const documents = await User.find({})\n\t    expect(documents).toHaveLength(1)\n\t    const history = await History.find({})\n", "    expect(history).toHaveLength(1)\n\t    const [first] = history\n\t    // 1 create\n\t    expect(first.version).toBe(0)\n\t    expect(first.op).toBe('findOneAndUpdate')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.doc).toHaveProperty('_id')\n\t    expect(first.doc).toHaveProperty('name', 'Bob')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n", "    // Upsert don't have createdAt and updatedAt and validation errors\n\t    // Investigate this case later\n\t    // expect(first.doc).toHaveProperty('createdAt')\n\t    // expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n\t    // updated event is not emitted because it's an upsert\n\t  })\n\t  it('should update many', async () => {\n", "    const john = await User.create({ name: 'John', role: 'user' })\n\t    expect(john.name).toBe('John')\n\t    const alice = await User.create({ name: 'Alice', role: 'user' })\n\t    expect(alice.name).toBe('Alice')\n\t    await User.updateMany({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(4)\n\t    const [first, second, third, fourth] = history\n\t    // 1 create\n\t    expect(first.version).toBe(0)\n", "    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(john._id)\n\t    expect(first.doc).toHaveProperty('_id', john._id)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.patch).toHaveLength(0)\n", "    // 2 create\n\t    expect(second.version).toBe(0)\n\t    expect(second.op).toBe('create')\n\t    expect(second.modelName).toBe('User')\n\t    expect(second.collectionName).toBe('users')\n\t    expect(second.collectionId).toEqual(alice._id)\n\t    expect(second.doc).toHaveProperty('_id', alice._id)\n\t    expect(second.doc).toHaveProperty('name', 'Alice')\n\t    expect(second.doc).toHaveProperty('role', 'user')\n\t    expect(second.doc).toHaveProperty('createdAt')\n", "    expect(second.doc).toHaveProperty('updatedAt')\n\t    expect(second.patch).toHaveLength(0)\n\t    // 3 update\n\t    expect(third.version).toBe(1)\n\t    expect(third.op).toBe('updateMany')\n\t    expect(third.modelName).toBe('User')\n\t    expect(third.collectionName).toBe('users')\n\t    expect(third.collectionId).toEqual(john._id)\n\t    expect(third.doc).toBeUndefined()\n\t    expect(third.patch).toHaveLength(2)\n", "    expect(third.patch).toMatchObject([\n\t      { op: 'test', path: '/name', value: 'John' },\n\t      { op: 'replace', path: '/name', value: 'Bob' }\n\t    ])\n\t    // 4 update\n\t    expect(fourth.version).toBe(1)\n\t    expect(fourth.op).toBe('updateMany')\n\t    expect(fourth.modelName).toBe('User')\n\t    expect(fourth.collectionName).toBe('users')\n\t    expect(fourth.collectionId).toEqual(alice._id)\n", "    expect(fourth.doc).toBeUndefined()\n\t    expect(fourth.patch).toHaveLength(2)\n\t    expect(fourth.patch).toMatchObject([\n\t      { op: 'test', path: '/name', value: 'Alice' },\n\t      { op: 'replace', path: '/name', value: 'Bob' }\n\t    ])\n\t    expect(em.emit).toHaveBeenCalledTimes(4)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: first.doc })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_CREATED, { doc: second.doc })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n", "      oldDoc: expect.objectContaining({ _id: john._id, name: 'John', role: 'user' }),\n\t      doc: expect.objectContaining({ _id: john._id, name: 'Bob', role: 'user' }),\n\t      patch: third.patch\n\t    })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({ _id: alice._id, name: 'Alice', role: 'user' }),\n\t      doc: expect.objectContaining({ _id: alice._id, name: 'Bob', role: 'user' }),\n\t      patch: fourth.patch\n\t    })\n\t  })\n", "})\n"]}
{"filename": "tests/plugin-event-updated.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\timport mongoose, { Types, model } from 'mongoose'\n\timport UserSchema from './schemas/UserSchema'\n\timport { patchHistoryPlugin } from '../src/plugin'\n\timport History from '../src/models/History'\n\timport em from '../src/em'\n\timport { USER_UPDATED } from './constants/events'\n\tjest.mock('../src/em', () => {\n\t  return {\n\t    emit: jest.fn()\n", "  }\n\t})\n\tdescribe('plugin - event updated & patch history disabled', () => {\n\t  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\t  UserSchema.plugin(patchHistoryPlugin, {\n\t    eventUpdated: USER_UPDATED,\n\t    patchHistoryDisabled: true,\n\t    omit: ['createdAt', 'updatedAt']\n\t  })\n\t  const User = model('User', UserSchema)\n", "  beforeAll(async () => {\n\t    await mongoose.connect(uri)\n\t  })\n\t  afterAll(async () => {\n\t    await mongoose.connection.close()\n\t  })\n\t  beforeEach(async () => {\n\t    await mongoose.connection.collection('users').deleteMany({})\n\t    await mongoose.connection.collection('history').deleteMany({})\n\t  })\n", "  it('should save() and emit one update event', async () => {\n\t    await User.create({ name: 'Bob', role: 'user' })\n\t    const user = new User({ name: 'John', role: 'user' })\n\t    const created = await user.save()\n\t    user.name = 'John Doe'\n\t    const updated = await user.save()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n", "      oldDoc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: created._id,\n\t        name: 'John',\n\t        role: 'user',\n\t        createdAt: created.createdAt,\n\t        updatedAt: created.createdAt\n\t      }),\n\t      doc: expect.objectContaining({\n\t        __v: 0,\n", "        _id: updated._id,\n\t        name: 'John Doe',\n\t        role: 'user',\n\t        createdAt: created.createdAt,\n\t        updatedAt: updated.updatedAt\n\t      }),\n\t      patch: expect.arrayContaining([\n\t        { op: 'test', path: '/name', value: 'John' },\n\t        { op: 'replace', path: '/name', value: 'John Doe' }\n\t      ])\n", "    })\n\t    // Confirm that the document is updated\n\t    const users = await User.find({})\n\t    expect(users).toHaveLength(2)\n\t    const [bob, john] = users\n\t    expect(bob.name).toBe('Bob')\n\t    expect(john.name).toBe('John Doe')\n\t  })\n\t  it('should update() and emit three update event', async () => {\n\t    await User.create([\n", "      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'user' },\n\t      { name: 'John', role: 'user' }\n\t    ], { ordered: true })\n\t    if (isMongooseLessThan7) {\n\t      await User.update({ role: 'user' }, { role: 'manager' })\n\t    } else {\n\t      await User.updateMany({ role: 'user' }, { role: 'manager' })\n\t    }\n\t    const users = await User.find({ role: 'manager' })\n", "    expect(users).toHaveLength(3)\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(3)\n\t    // Confirm that the document is updated\n\t    const updated = await User.find({}).sort({ name: 1 })\n\t    expect(updated).toHaveLength(3)\n\t    const [alice, bob, john] = updated\n\t    expect(alice.role).toBe('manager')\n\t    expect(bob.role).toBe('manager')\n", "    expect(john.role).toBe('manager')\n\t  })\n\t  it('should updateOne() and emit one update event', async () => {\n\t    await User.create([\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'user' },\n\t      { name: 'John', role: 'user' }\n\t    ], { ordered: true })\n\t    await User.updateOne({ name: 'Bob' }, { role: 'manager' })\n\t    const users = await User.find({ role: 'manager' })\n", "    expect(users).toHaveLength(1)\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    // Confirm that the document is updated\n\t    const updated = await User.find({}).sort({ name: 1 })\n\t    expect(updated).toHaveLength(3)\n\t    const [alice, bob, john] = updated\n\t    expect(alice.role).toBe('user')\n\t    expect(bob.role).toBe('manager')\n", "    expect(john.role).toBe('user')\n\t  })\n\t  it('should replaceOne() and emit two update event', async () => {\n\t    await User.create([\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'user' },\n\t      { name: 'John', role: 'user' }\n\t    ], { ordered: true })\n\t    await User.replaceOne({ name: 'Bob' }, { name: 'Bob Doe', role: 'manager' })\n\t    const users = await User.find({ role: 'manager' })\n", "    expect(users).toHaveLength(1)\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: expect.any(Types.ObjectId),\n\t        name: 'Bob',\n\t        role: 'user',\n", "        createdAt: expect.any(Date),\n\t        updatedAt: expect.any(Date)\n\t      }),\n\t      doc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: expect.any(Types.ObjectId),\n\t        name: 'Bob Doe',\n\t        role: 'manager',\n\t        createdAt: expect.any(Date),\n\t        updatedAt: expect.any(Date)\n", "      }),\n\t      patch: expect.arrayContaining([\n\t        { op: 'test', path: '/name', value: 'Bob' },\n\t        { op: 'replace', path: '/name', value: 'Bob Doe' },\n\t        { op: 'test', path: '/role', value: 'user' },\n\t        { op: 'replace', path: '/role', value: 'manager' }\n\t      ])\n\t    })\n\t    // Confirm that the document is updated\n\t    const updated = await User.find({}).sort({ name: 1 })\n", "    expect(updated).toHaveLength(3)\n\t    const [alice, bob, john] = updated\n\t    expect(alice.role).toBe('user')\n\t    expect(bob.role).toBe('manager')\n\t    expect(john.role).toBe('user')\n\t  })\n\t  it('should updateMany() and emit two update event', async () => {\n\t    await User.create([\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'user' },\n", "      { name: 'John', role: 'user' }\n\t    ], { ordered: true })\n\t    await User.updateMany({ role: 'user' }, { role: 'manager' })\n\t    const users = await User.find({ role: 'manager' })\n\t    expect(users).toHaveLength(3)\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(3)\n\t    // Confirm that the document is updated\n\t    const updated = await User.find({}).sort({ name: 1 })\n", "    expect(updated).toHaveLength(3)\n\t    const [alice, bob, john] = updated\n\t    expect(alice.role).toBe('manager')\n\t    expect(bob.role).toBe('manager')\n\t    expect(john.role).toBe('manager')\n\t  })\n\t  it('should findOneAndUpdate() and emit one update event', async () => {\n\t    await User.create({ name: 'Bob', role: 'user' })\n\t    const created = await User.create({ name: 'John', role: 'user' })\n\t    await User.findOneAndUpdate({ _id: created._id }, { name: 'John Doe', role: 'manager' })\n", "    const updated = await User.findById(created._id).exec()\n\t    expect(updated).not.toBeNull()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: created._id,\n\t        name: created.name,\n", "        role: created.role,\n\t        createdAt: created.createdAt\n\t      }),\n\t      doc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: updated?._id,\n\t        name: updated?.name,\n\t        role: updated?.role,\n\t        createdAt: created.createdAt\n\t      }),\n", "      patch: expect.arrayContaining([\n\t        { op: 'test', path: '/role', value: 'user' },\n\t        { op: 'replace', path: '/role', value: 'manager' },\n\t        { op: 'test', path: '/name', value: 'John' },\n\t        { op: 'replace', path: '/name', value: 'John Doe' }\n\t      ])\n\t    })\n\t    // Confirm that the document is updated\n\t    expect(updated?.name).toBe('John Doe')\n\t    expect(updated?.role).toBe('manager')\n", "  })\n\t  it('should findOneAndReplace() and emit one update event', async () => {\n\t    await User.create({ name: 'Bob', role: 'user' })\n\t    const created = await User.create({ name: 'John', role: 'user' })\n\t    await User.findOneAndReplace({ _id: created._id }, { name: 'John Doe', role: 'manager' })\n\t    const updated = await User.findById(created._id).exec()\n\t    expect(updated).not.toBeNull()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n", "    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: created._id,\n\t        name: created.name,\n\t        role: created.role,\n\t        createdAt: created.createdAt,\n\t        updatedAt: created.createdAt\n\t      }),\n\t      doc: expect.objectContaining({\n", "        __v: 0,\n\t        _id: updated?._id,\n\t        name: updated?.name,\n\t        role: updated?.role,\n\t        createdAt: updated?.createdAt,\n\t        updatedAt: updated?.updatedAt\n\t      }),\n\t      patch: expect.arrayContaining([\n\t        { op: 'test', path: '/name', value: 'John' },\n\t        { op: 'replace', path: '/name', value: 'John Doe' },\n", "        { op: 'test', path: '/role', value: 'user' },\n\t        { op: 'replace', path: '/role', value: 'manager' }\n\t      ])\n\t    })\n\t    // Confirm that the document is updated\n\t    expect(updated?.name).toBe('John Doe')\n\t    expect(updated?.role).toBe('manager')\n\t  })\n\t  it('should findByIdAndUpdate() and emit one update event', async () => {\n\t    const created = await User.create({ name: 'Bob', role: 'user' })\n", "    await User.findByIdAndUpdate(created._id, { name: 'John Doe', role: 'manager' })\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: created._id,\n\t        name: created.name,\n\t        role: created.role,\n", "        createdAt: created.createdAt\n\t      }),\n\t      doc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: created._id,\n\t        name: 'John Doe',\n\t        role: 'manager',\n\t        createdAt: created.createdAt\n\t      }),\n\t      patch: expect.arrayContaining([\n", "        { op: 'test', path: '/name', value: 'Bob' },\n\t        { op: 'replace', path: '/name', value: 'John Doe' },\n\t        { op: 'test', path: '/role', value: 'user' },\n\t        { op: 'replace', path: '/role', value: 'manager' }\n\t      ])\n\t    })\n\t    // Confirm that the document is updated\n\t    const updated = await User.findById(created._id).exec()\n\t    expect(updated?.name).toBe('John Doe')\n\t    expect(updated?.role).toBe('manager')\n", "  })\n\t  it('should update and emit one update event', async () => {\n\t    await User.create({ name: 'Bob', role: 'user' })\n\t    const created = await User.create({ name: 'John', role: 'user' })\n\t    await User.updateOne({ _id: created._id }, { name: 'John Doe', role: 'manager' })\n\t    const updated = await User.findById(created._id).exec()\n\t    expect(updated).not.toBeNull()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n", "    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: created._id,\n\t        name: created.name,\n\t        role: created.role,\n\t        createdAt: created.createdAt\n\t      }),\n\t      doc: expect.objectContaining({\n\t        __v: 0,\n", "        _id: updated?._id,\n\t        name: updated?.name,\n\t        role: updated?.role,\n\t        createdAt: created.createdAt\n\t      }),\n\t      patch: expect.arrayContaining([\n\t        { op: 'test', path: '/role', value: 'user' },\n\t        { op: 'replace', path: '/role', value: 'manager' },\n\t        { op: 'test', path: '/name', value: 'John' },\n\t        { op: 'replace', path: '/name', value: 'John Doe' }\n", "      ])\n\t    })\n\t    // Confirm that the document is updated\n\t    expect(updated?.name).toBe('John Doe')\n\t    expect(updated?.role).toBe('manager')\n\t  })\n\t  it('should updateMany and emit two update events', async () => {\n\t    const created1 = await User.create({ name: 'John', role: 'user' })\n\t    const created2 = await User.create({ name: 'Bob', role: 'user' })\n\t    await User.updateMany({}, { name: 'John Doe', role: 'manager' })\n", "    const updated1 = await User.findById(created1._id).exec()\n\t    expect(updated1).not.toBeNull()\n\t    const updated2 = await User.findById(created2._id).exec()\n\t    expect(updated2).not.toBeNull()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(2)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({\n\t        __v: 0,\n", "        _id: created1._id,\n\t        name: created1.name,\n\t        role: created1.role,\n\t        createdAt: created1.createdAt\n\t      }),\n\t      doc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: updated1?._id,\n\t        name: updated1?.name,\n\t        role: updated1?.role,\n", "        createdAt: created1.createdAt\n\t      }),\n\t      patch: expect.arrayContaining([\n\t        { op: 'test', path: '/role', value: 'user' },\n\t        { op: 'replace', path: '/role', value: 'manager' },\n\t        { op: 'test', path: '/name', value: 'John' },\n\t        { op: 'replace', path: '/name', value: 'John Doe' }\n\t      ])\n\t    })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n", "      oldDoc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: created2._id,\n\t        name: created2.name,\n\t        role: created2.role,\n\t        createdAt: created2.createdAt\n\t      }),\n\t      doc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: updated2?._id,\n", "        name: updated2?.name,\n\t        role: updated2?.role,\n\t        createdAt: created2.createdAt\n\t      }),\n\t      patch: expect.arrayContaining([\n\t        { op: 'test', path: '/role', value: 'user' },\n\t        { op: 'replace', path: '/role', value: 'manager' },\n\t        { op: 'test', path: '/name', value: 'Bob' },\n\t        { op: 'replace', path: '/name', value: 'John Doe' }\n\t      ])\n", "    })\n\t    // Confirm that the documents are updated\n\t    expect(updated1?.name).toBe('John Doe')\n\t    expect(updated1?.role).toBe('manager')\n\t    expect(updated2?.name).toBe('John Doe')\n\t    expect(updated2?.role).toBe('manager')\n\t  })\n\t  it('should findOneAndUpdate $set and emit one update event', async () => {\n\t    const created = await User.create({ name: 'Bob', role: 'user' })\n\t    await User.findOneAndUpdate({ _id: created._id }, { $set: { name: 'John Doe', role: 'manager' } })\n", "    const updated = await User.findById(created._id).exec()\n\t    expect(updated).not.toBeNull()\n\t    expect(updated?.name).toBe('John Doe')\n\t    expect(updated?.role).toBe('manager')\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_UPDATED, {\n\t      oldDoc: expect.objectContaining({\n\t        __v: 0,\n", "        _id: created._id,\n\t        name: created.name,\n\t        role: created.role,\n\t        createdAt: created.createdAt\n\t      }),\n\t      doc: expect.objectContaining({\n\t        __v: 0,\n\t        _id: updated?._id,\n\t        name: updated?.name,\n\t        role: updated?.role,\n", "        createdAt: created.createdAt\n\t      }),\n\t      patch: expect.arrayContaining([\n\t        { op: 'test', path: '/name', value: 'Bob' },\n\t        { op: 'replace', path: '/name', value: 'John Doe' },\n\t        { op: 'test', path: '/role', value: 'user' },\n\t        { op: 'replace', path: '/role', value: 'manager' }\n\t      ])\n\t    })\n\t    // Confirm that the document is updated\n", "    expect(updated?.name).toBe('John Doe')\n\t    expect(updated?.role).toBe('manager')\n\t  })\n\t  it('should ignoreHook option on updateMany', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n\t    await User.updateMany({ role: 'user' }, { role: 'admin' }, { ignoreHook: true }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t    // Confirm that the document is updated\n", "    const updated = await User.findById(john._id).exec()\n\t    expect(updated?.role).toBe('admin')\n\t  })\n\t})\n"]}
{"filename": "tests/patch.test.ts", "chunked_list": ["import mongoose, { model } from 'mongoose'\n\timport { getUser, getReason, getMetadata, getData, getValue, getObjects, bulkPatch, updatePatch } from '../src/patch'\n\timport { patchHistoryPlugin } from '../src/plugin'\n\timport UserSchema from './schemas/UserSchema'\n\timport { USER_DELETED } from './constants/events'\n\timport type { HydratedDocument } from 'mongoose'\n\timport type { User } from '../src/interfaces/IPluginOptions'\n\timport type IPluginOptions from '../src/interfaces/IPluginOptions'\n\timport type IUser from './interfaces/IUser'\n\timport type IContext from '../src/interfaces/IContext'\n", "import em from '../src/em'\n\tjest.mock('../src/em', () => {\n\t  return {\n\t    emit: jest.fn()\n\t  }\n\t})\n\tdescribe('patch tests', () => {\n\t  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\t  UserSchema.plugin(patchHistoryPlugin, {\n\t    eventDeleted: USER_DELETED,\n", "    patchHistoryDisabled: true\n\t  })\n\t  const User = model('User', UserSchema)\n\t  beforeAll(async () => {\n\t    await mongoose.connect(uri)\n\t  })\n\t  afterAll(async () => {\n\t    await mongoose.connection.close()\n\t  })\n\t  beforeEach(async () => {\n", "    await mongoose.connection.collection('users').deleteMany({})\n\t    await mongoose.connection.collection('patches').deleteMany({})\n\t  })\n\t  describe('getObjects', () => {\n\t    it('should omit properties from currentObject and originalObject based on the opts', async () => {\n\t      const original = await User.create({ name: 'John', role: 'user' })\n\t      const current = await User.create({ name: 'John', role: 'admin' })\n\t      const pluginOptions = {\n\t        omit: ['createdAt']\n\t      }\n", "      const { currentObject, originalObject } = getObjects(pluginOptions, current, original)\n\t      expect(currentObject.name).toBe('John')\n\t      expect(currentObject.role).toBe('admin')\n\t      expect(currentObject.createdAt).toBeUndefined()\n\t      expect(originalObject.name).toBe('John')\n\t      expect(originalObject.role).toBe('user')\n\t      expect(originalObject.createdAt).toBeUndefined()\n\t    })\n\t    it('should not omit properties from currentObject and originalObject if opts is empty', async () => {\n\t      const original = await User.create({ name: 'John', role: 'user' })\n", "      const current = await User.create({ name: 'John', role: 'admin' })\n\t      const { currentObject, originalObject } = getObjects({}, current, original)\n\t      expect(currentObject.name).toBe('John')\n\t      expect(currentObject.role).toBe('admin')\n\t      expect(currentObject.createdAt).toBeDefined()\n\t      expect(originalObject.name).toBe('John')\n\t      expect(originalObject.role).toBe('user')\n\t      expect(originalObject.createdAt).toBeDefined()\n\t    })\n\t  })\n", "  describe('bulkPatch', () => {\n\t    it('should emit eventDeleted if opts.patchHistoryDisabled is false', async () => {\n\t      const doc = new User({ name: 'John', role: 'user' })\n\t      const pluginOptions: IPluginOptions<IUser> = {\n\t        eventDeleted: USER_DELETED,\n\t        patchHistoryDisabled: false\n\t      }\n\t      const context: IContext<IUser> = {\n\t        op: 'deleteOne',\n\t        modelName: 'User',\n", "        collectionName: 'users',\n\t        deletedDocs: [doc]\n\t      }\n\t      await bulkPatch(pluginOptions, context, 'eventDeleted', 'deletedDocs')\n\t      expect(em.emit).toHaveBeenCalled()\n\t    })\n\t    it('should emit eventDeleted if opts.patchHistoryDisabled is true', async () => {\n\t      const doc = new User({ name: 'John', role: 'user' })\n\t      const pluginOptions: IPluginOptions<IUser> = {\n\t        eventDeleted: USER_DELETED,\n", "        patchHistoryDisabled: true\n\t      }\n\t      const context: IContext<IUser> = {\n\t        op: 'deleteOne',\n\t        modelName: 'User',\n\t        collectionName: 'users',\n\t        deletedDocs: [doc]\n\t      }\n\t      await bulkPatch(pluginOptions, context, 'eventDeleted', 'deletedDocs')\n\t      expect(em.emit).toHaveBeenCalled()\n", "    })\n\t  })\n\t  describe('updatePatch', () => {\n\t    it('should return if one object is empty', async () => {\n\t      const current = await User.create({ name: 'John', role: 'user' })\n\t      const pluginOptions: IPluginOptions<IUser> = {\n\t        eventDeleted: USER_DELETED,\n\t        patchHistoryDisabled: true\n\t      }\n\t      const context: IContext<IUser> = {\n", "        op: 'updateOne',\n\t        modelName: 'User',\n\t        collectionName: 'users'\n\t      }\n\t      await updatePatch(pluginOptions, context, current, {} as HydratedDocument<IUser>)\n\t      expect(em.emit).not.toHaveBeenCalled()\n\t    })\n\t  })\n\t  describe('should getUser()', () => {\n\t    it('should return user, reason, metadata', async () => {\n", "      const opts: IPluginOptions<IUser> = {\n\t        getUser: () => ({ name: 'test' }),\n\t        getReason: () => 'test',\n\t        getMetadata: () => ({ test: 'test' })\n\t      }\n\t      await expect(getUser(opts)).resolves.toEqual({ name: 'test' })\n\t      await expect(getReason(opts)).resolves.toBe('test')\n\t      await expect(getMetadata(opts)).resolves.toEqual({ test: 'test' })\n\t    })\n\t  })\n", "  describe('should getData()', () => {\n\t    it('should return user, reason, metadata', async () => {\n\t      const opts: IPluginOptions<IUser> = {\n\t        getUser: () => ({ name: 'test' }),\n\t        getReason: () => 'test',\n\t        getMetadata: () => ({ test: 'test' })\n\t      }\n\t      await expect(getData(opts)).resolves.toEqual([{ name: 'test' }, 'test', { test: 'test' }])\n\t    })\n\t    it('should return user, reason, metadata undefined', async () => {\n", "      const opts: IPluginOptions<IUser> = {\n\t        getUser: () => ({ name: 'test' }),\n\t        getReason: () => 'test',\n\t        getMetadata: () => {\n\t          throw new Error('test')\n\t        }\n\t      }\n\t      await expect(getData(opts)).resolves.toEqual([{ name: 'test' }, 'test', undefined])\n\t    })\n\t    it('should getValue', () => {\n", "      const item1: PromiseSettledResult<User> = {\n\t        status: 'fulfilled',\n\t        value: {\n\t          name: 'test'\n\t        }\n\t      }\n\t      expect(getValue(item1)).toEqual({ name: 'test' })\n\t      const item2: PromiseSettledResult<User> = {\n\t        status: 'rejected',\n\t        reason: new Error('test')\n", "      }\n\t      expect(getValue(item2)).toBeUndefined()\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/plugin-event-deleted.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\timport mongoose, { model } from 'mongoose'\n\timport type { ToObjectOptions } from 'mongoose'\n\timport UserSchema from './schemas/UserSchema'\n\timport { patchHistoryPlugin } from '../src/plugin'\n\timport History from '../src/models/History'\n\timport em from '../src/em'\n\timport { USER_DELETED } from './constants/events'\n\tjest.mock('../src/em', () => {\n\t  return {\n", "    emit: jest.fn()\n\t  }\n\t})\n\tconst toObjectOptions: ToObjectOptions = {\n\t  depopulate: true,\n\t  virtuals: false\n\t}\n\tdescribe('plugin - event delete & patch history disabled', () => {\n\t  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\t  UserSchema.plugin(patchHistoryPlugin, {\n", "    eventDeleted: USER_DELETED,\n\t    patchHistoryDisabled: true\n\t  })\n\t  const User = model('User', UserSchema)\n\t  beforeAll(async () => {\n\t    await mongoose.connect(uri)\n\t  })\n\t  afterAll(async () => {\n\t    await mongoose.connection.close()\n\t  })\n", "  beforeEach(async () => {\n\t    await mongoose.connection.collection('users').deleteMany({})\n\t    await mongoose.connection.collection('history').deleteMany({})\n\t  })\n\t  it('should remove() and emit one delete event', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n\t    if (isMongooseLessThan7) {\n\t      await john.remove()\n\t    } else {\n\t      await john.deleteOne()\n", "    }\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    // Check if data is deleted\n\t    const user = await User.findById(john._id)\n\t    expect(user).toBeNull()\n", "  })\n\t  it('should remove() and emit two delete events', async () => {\n\t    const users = await User.create([\n\t      { name: 'John', role: 'user' },\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'admin' }\n\t    ])\n\t    const [john, alice] = users\n\t    if (isMongooseLessThan7) {\n\t      await User.remove({ role: 'user' }).exec()\n", "    } else {\n\t      await User.deleteMany({ role: 'user' }).exec()\n\t    }\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(2)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n", "      oldDoc: expect.objectContaining(alice.toObject(toObjectOptions))\n\t    })\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n\t    expect(deletedJohn).toBeNull()\n\t    const deletedAlice = await User.findById(alice._id)\n\t    expect(deletedAlice).toBeNull()\n\t    const remaining = await User.find({})\n\t    expect(remaining).toHaveLength(1)\n\t  })\n", "  it('should remove() and emit one delete event { single: true }', async () => {\n\t    const users = await User.create([\n\t      { name: 'John', role: 'user' },\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'admin' }\n\t    ])\n\t    const [john] = users\n\t    if (isMongooseLessThan7) {\n\t      await User.remove({ role: 'user' }, { single: true }).exec()\n\t    } else {\n", "      await User.deleteOne({ role: 'user' }).exec()\n\t    }\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n", "    expect(deletedJohn).toBeNull()\n\t    const remaining = await User.find({})\n\t    expect(remaining).toHaveLength(2)\n\t  })\n\t  it('should findOneAndDelete() and emit one delete event', async () => {\n\t    const users = await User.create([\n\t      { name: 'John', role: 'user' },\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'admin' }\n\t    ])\n", "    const [john] = users\n\t    await User.findOneAndDelete({ role: 'user' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n", "    expect(deletedJohn).toBeNull()\n\t    const remaining = await User.find({})\n\t    expect(remaining).toHaveLength(2)\n\t  })\n\t  it('should findOneAndRemove() and emit one delete event', async () => {\n\t    const users = await User.create([\n\t      { name: 'John', role: 'user' },\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'admin' }\n\t    ])\n", "    const [john] = users\n\t    await User.findOneAndRemove({ role: 'user' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n", "    expect(deletedJohn).toBeNull()\n\t    const remaining = await User.find({ name: { $in: ['Alice', 'Bob'] } })\n\t    expect(remaining).toHaveLength(2)\n\t  })\n\t  it('should findByIdAndDelete() and emit one delete event', async () => {\n\t    const users = await User.create([\n\t      { name: 'John', role: 'user' },\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'admin' }\n\t    ])\n", "    const [john] = users\n\t    await User.findByIdAndDelete(john._id).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n", "    expect(deletedJohn).toBeNull()\n\t    const remaining = await User.find({ name: { $in: ['Alice', 'Bob'] } })\n\t    expect(remaining).toHaveLength(2)\n\t  })\n\t  it('should findByIdAndRemove() and emit one delete event', async () => {\n\t    const users = await User.create([\n\t      { name: 'John', role: 'user' },\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'admin' }\n\t    ])\n", "    const [john] = users\n\t    await User.findByIdAndRemove(john._id).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n", "    expect(deletedJohn).toBeNull()\n\t    const remaining = await User.find({ name: { $in: ['Alice', 'Bob'] } })\n\t    expect(remaining).toHaveLength(2)\n\t  })\n\t  it('should deleteOne() and emit one delete event', async () => {\n\t    const users = await User.create([\n\t      { name: 'John', role: 'user' },\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'admin' }\n\t    ])\n", "    const [john] = users\n\t    await User.deleteOne({ role: 'user' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n", "    expect(deletedJohn).toBeNull()\n\t    const remaining = await User.find({ name: { $in: ['Alice', 'Bob'] } })\n\t    expect(remaining).toHaveLength(2)\n\t  })\n\t  it('should deleteMany() and emit two delete events', async () => {\n\t    const users = await User.create([\n\t      { name: 'John', role: 'user' },\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'admin' }\n\t    ])\n", "    const [john, alice] = users\n\t    await User.deleteMany({ role: 'user' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(2)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(alice.toObject(toObjectOptions))\n", "    })\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n\t    expect(deletedJohn).toBeNull()\n\t    const deletedAlice = await User.findById(alice._id)\n\t    expect(deletedAlice).toBeNull()\n\t    const remaining = await User.find({})\n\t    expect(remaining).toHaveLength(1)\n\t  })\n\t  it('should deleteMany() and emit one delete event { single: true }', async () => {\n", "    const users = await User.create([\n\t      { name: 'John', role: 'user' },\n\t      { name: 'Alice', role: 'user' },\n\t      { name: 'Bob', role: 'admin' }\n\t    ])\n\t    const [john] = users\n\t    if (isMongooseLessThan7) {\n\t      await User.deleteMany({ role: 'user' }, { single: true }).exec()\n\t    } else {\n\t      await User.deleteOne({ role: 'user' }).exec()\n", "    }\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n\t    expect(deletedJohn).toBeNull()\n", "    const remaining = await User.find({})\n\t    expect(remaining).toHaveLength(2)\n\t  })\n\t  it('should create then delete and emit one delete event', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n\t    if (isMongooseLessThan7) {\n\t      await john.delete()\n\t    } else {\n\t      await john.deleteOne()\n\t    }\n", "    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: expect.objectContaining(john.toObject(toObjectOptions))\n\t    })\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n\t    expect(deletedJohn).toBeNull()\n\t    const remaining = await User.find({})\n", "    expect(remaining).toHaveLength(0)\n\t  })\n\t  it('should ignoreHook option on deleteMany', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n\t    await User.deleteMany({ role: 'user' }, { ignoreHook: true }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n", "    expect(deletedJohn).toBeNull()\n\t  })\n\t  it('should ignoreHook option on deleteOne', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n\t    await User.deleteOne({ role: 'user' }, { ignoreHook: true }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(0)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t    // Check if data is deleted\n\t    const deletedJohn = await User.findById(john._id)\n", "    expect(deletedJohn).toBeNull()\n\t    const remaining = await User.find({})\n\t    expect(remaining).toHaveLength(0)\n\t  })\n\t})\n"]}
{"filename": "tests/plugin-pre-delete.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\timport mongoose, { model } from 'mongoose'\n\timport UserSchema from './schemas/UserSchema'\n\timport { patchHistoryPlugin } from '../src/plugin'\n\timport { USER_DELETED } from './constants/events'\n\timport em from '../src/em'\n\tconst preDeleteMock = jest.fn()\n\tjest.mock('../src/em', () => {\n\t  return { emit: jest.fn() }\n\t})\n", "describe('plugin - preDelete test', () => {\n\t  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\t  UserSchema.plugin(patchHistoryPlugin, {\n\t    eventDeleted: USER_DELETED,\n\t    patchHistoryDisabled: true,\n\t    preDelete: preDeleteMock\n\t  })\n\t  const User = model('User', UserSchema)\n\t  beforeAll(async () => {\n\t    await mongoose.connect(uri)\n", "  })\n\t  afterAll(async () => {\n\t    await mongoose.connection.close()\n\t  })\n\t  beforeEach(async () => {\n\t    await mongoose.connection.collection('users').deleteMany({})\n\t    await mongoose.connection.collection('history').deleteMany({})\n\t  })\n\t  it('should deleteMany and execute preDelete', async () => {\n\t    await User.create({ name: 'John', role: 'user' })\n", "    await User.create({ name: 'Jane', role: 'user' })\n\t    await User.create({ name: 'Jack', role: 'user' })\n\t    const users = await User.find({}).sort().lean().exec()\n\t    expect(users).toHaveLength(3)\n\t    const [john, jane, jack] = users\n\t    await User.deleteMany({ role: 'user' })\n\t    expect(preDeleteMock).toHaveBeenCalledTimes(1)\n\t    expect(preDeleteMock).toHaveBeenCalledWith([john, jane, jack])\n\t    expect(em.emit).toHaveBeenCalledTimes(3)\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n", "      oldDoc: {\n\t        __v: 0,\n\t        _id: jane?._id,\n\t        name: 'Jane',\n\t        role: 'user',\n\t        createdAt: jane?.createdAt,\n\t        updatedAt: jane?.updatedAt\n\t      }\n\t    })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n", "      oldDoc: {\n\t        __v: 0,\n\t        _id: john?._id,\n\t        name: 'John',\n\t        role: 'user',\n\t        createdAt: john?.createdAt,\n\t        updatedAt: john?.updatedAt\n\t      }\n\t    })\n\t    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n", "      oldDoc: {\n\t        __v: 0,\n\t        _id: jack?._id,\n\t        name: 'Jack',\n\t        role: 'user',\n\t        createdAt: jack?.createdAt,\n\t        updatedAt: jack?.updatedAt\n\t      }\n\t    })\n\t  })\n", "  it('should deleteOne and execute preDelete', async () => {\n\t    await User.create({ name: 'John', role: 'user' })\n\t    await User.create({ name: 'Jane', role: 'user' })\n\t    await User.create({ name: 'Jack', role: 'user' })\n\t    const users = await User.find({}).sort().lean().exec()\n\t    expect(users).toHaveLength(3)\n\t    const [john] = users\n\t    await User.deleteOne({ name: 'John' })\n\t    expect(preDeleteMock).toHaveBeenCalledTimes(1)\n\t    expect(preDeleteMock).toHaveBeenCalledWith([\n", "      {\n\t        __v: 0,\n\t        _id: john?._id,\n\t        name: 'John',\n\t        role: 'user',\n\t        createdAt: john?.createdAt,\n\t        updatedAt: john?.updatedAt\n\t      }\n\t    ])\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n", "    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: {\n\t        __v: 0,\n\t        _id: john?._id,\n\t        name: 'John',\n\t        role: 'user',\n\t        createdAt: john?.createdAt,\n\t        updatedAt: john?.updatedAt\n\t      }\n\t    })\n", "  })\n\t  it('should remove and execute preDelete', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n\t    if (isMongooseLessThan7) {\n\t      await john?.remove()\n\t    } else {\n\t      await john?.deleteOne()\n\t    }\n\t    expect(preDeleteMock).toHaveBeenCalledTimes(1)\n\t    expect(preDeleteMock).toHaveBeenCalledWith([\n", "      {\n\t        __v: 0,\n\t        _id: john?._id,\n\t        name: 'John',\n\t        role: 'user',\n\t        createdAt: john?.createdAt,\n\t        updatedAt: john?.updatedAt\n\t      }\n\t    ])\n\t    expect(em.emit).toHaveBeenCalledTimes(1)\n", "    expect(em.emit).toHaveBeenCalledWith(USER_DELETED, {\n\t      oldDoc: {\n\t        __v: 0,\n\t        _id: john?._id,\n\t        name: 'John',\n\t        role: 'user',\n\t        createdAt: john?.createdAt,\n\t        updatedAt: john?.updatedAt\n\t      }\n\t    })\n", "  })\n\t})\n"]}
{"filename": "tests/plugin-omit-all.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\timport mongoose, { Types, model } from 'mongoose'\n\timport UserSchema from './schemas/UserSchema'\n\timport { patchHistoryPlugin } from '../src/plugin'\n\timport History from '../src/models/History'\n\timport em from '../src/em'\n\tjest.mock('../src/em', () => {\n\t  return { emit: jest.fn() }\n\t})\n\tdescribe('plugin - omit all', () => {\n", "  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\t  UserSchema.plugin(patchHistoryPlugin, {\n\t    omit: ['__v', 'name', 'role', 'createdAt', 'updatedAt']\n\t  })\n\t  const User = model('User', UserSchema)\n\t  beforeAll(async () => {\n\t    await mongoose.connect(uri)\n\t  })\n\t  afterAll(async () => {\n\t    await mongoose.connection.close()\n", "  })\n\t  beforeEach(async () => {\n\t    await mongoose.connection.collection('users').deleteMany({})\n\t    await mongoose.connection.collection('history').deleteMany({})\n\t  })\n\t  it('should createHistory', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    user.name = 'Alice'\n\t    await user.save()\n", "    user.name = 'Bob'\n\t    await user.save()\n\t    await User.deleteMany({ role: 'user' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(2)\n\t    const [first, second] = history\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(user._id)\n", "    expect(first.version).toBe(0)\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.doc).toHaveProperty('_id', user._id)\n\t    expect(second.op).toBe('deleteMany')\n\t    expect(second.modelName).toBe('User')\n\t    expect(second.collectionName).toBe('users')\n", "    expect(second.collectionId).toEqual(user._id)\n\t    expect(second.version).toBe(0)\n\t    expect(second.patch).toHaveLength(0)\n\t    expect(second.doc).toHaveProperty('name', 'Bob')\n\t    expect(second.doc).toHaveProperty('role', 'user')\n\t    expect(second.doc).toHaveProperty('createdAt')\n\t    expect(second.doc).toHaveProperty('updatedAt')\n\t    expect(second.doc).toHaveProperty('_id', user._id)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n", "  it('should omit update of role', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    user.role = 'manager'\n\t    await user.save()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(1)\n\t    const [first] = history\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n", "    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(user._id)\n\t    expect(first.version).toBe(0)\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.doc).toHaveProperty('_id', user._id)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n", "  })\n\t  it('should updateOne', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    await User.updateOne({ _id: user._id }, { name: 'Alice' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(1)\n\t    const [first] = history\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n", "    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(user._id)\n\t    expect(first.version).toBe(0)\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.doc).toHaveProperty('_id', user._id)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n", "  })\n\t  it('should findOneAndUpdate', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    await User.findOneAndUpdate({ _id: user._id }, { name: 'Alice' }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(1)\n\t    const [first] = history\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n", "    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(user._id)\n\t    expect(first.version).toBe(0)\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.doc).toHaveProperty('_id', user._id)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n", "  })\n\t  it('should update deprecated', async () => {\n\t    const user = await User.create({ name: 'John', role: 'user' })\n\t    expect(user.name).toBe('John')\n\t    if (isMongooseLessThan7) {\n\t      await User.update({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n\t    } else {\n\t      await User.findOneAndUpdate({ _id: user._id }, { $set: { name: 'Alice' } }).exec()\n\t    }\n\t    const history = await History.find({})\n", "    expect(history).toHaveLength(1)\n\t    const [first] = history\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(user._id)\n\t    expect(first.version).toBe(0)\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n", "    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.doc).toHaveProperty('_id', user._id)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should updated deprecated with multi flag', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n\t    expect(john.name).toBe('John')\n\t    const alice = await User.create({ name: 'Alice', role: 'user' })\n\t    expect(alice.name).toBe('Alice')\n", "    if (isMongooseLessThan7) {\n\t      await User.update({ role: 'user' }, { $set: { name: 'Bob' } }, { multi: true }).exec()\n\t    } else {\n\t      await User.updateMany({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n\t    }\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(2)\n\t    const [first, second] = history\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n", "    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(john._id)\n\t    expect(first.version).toBe(0)\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.doc).toHaveProperty('_id', john._id)\n\t    expect(second.op).toBe('create')\n", "    expect(second.modelName).toBe('User')\n\t    expect(second.collectionName).toBe('users')\n\t    expect(second.collectionId).toEqual(alice._id)\n\t    expect(second.version).toBe(0)\n\t    expect(second.patch).toHaveLength(0)\n\t    expect(second.doc).toHaveProperty('name', 'Alice')\n\t    expect(second.doc).toHaveProperty('role', 'user')\n\t    expect(second.doc).toHaveProperty('createdAt')\n\t    expect(second.doc).toHaveProperty('updatedAt')\n\t    expect(second.doc).toHaveProperty('_id', alice._id)\n", "    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should create many', async () => {\n\t    await User.create([\n\t      { name: 'John', role: 'user' },\n\t      { name: 'Alice', role: 'user' }\n\t    ])\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(2)\n\t    const [first, second] = history\n", "    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toBeInstanceOf(Types.ObjectId)\n\t    expect(first.version).toBe(0)\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n\t    expect(first.doc).toHaveProperty('updatedAt')\n", "    expect(first.doc).toHaveProperty('_id')\n\t    expect(second.op).toBe('create')\n\t    expect(second.modelName).toBe('User')\n\t    expect(second.collectionName).toBe('users')\n\t    expect(second.collectionId).toBeInstanceOf(Types.ObjectId)\n\t    expect(second.version).toBe(0)\n\t    expect(second.patch).toHaveLength(0)\n\t    expect(second.doc).toHaveProperty('name', 'Alice')\n\t    expect(second.doc).toHaveProperty('role', 'user')\n\t    expect(second.doc).toHaveProperty('createdAt')\n", "    expect(second.doc).toHaveProperty('updatedAt')\n\t    expect(second.doc).toHaveProperty('_id')\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should findOneAndUpdate upsert', async () => {\n\t    await User.findOneAndUpdate({ name: 'John', role: 'user' }, { name: 'Bob', role: 'user' }, { upsert: true, runValidators: true }).exec()\n\t    const documents = await User.find({})\n\t    expect(documents).toHaveLength(1)\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(1)\n", "    const [first] = history\n\t    expect(first.op).toBe('findOneAndUpdate')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toBeInstanceOf(Types.ObjectId)\n\t    expect(first.version).toBe(0)\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(first.doc).toHaveProperty('name', 'Bob')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('_id')\n", "    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t  it('should update many', async () => {\n\t    const john = await User.create({ name: 'John', role: 'user' })\n\t    expect(john.name).toBe('John')\n\t    const alice = await User.create({ name: 'Alice', role: 'user' })\n\t    expect(alice.name).toBe('Alice')\n\t    await User.updateMany({ role: 'user' }, { $set: { name: 'Bob' } }).exec()\n\t    const history = await History.find({})\n\t    expect(history).toHaveLength(2)\n", "    const [first, second] = history\n\t    expect(first.op).toBe('create')\n\t    expect(first.modelName).toBe('User')\n\t    expect(first.collectionName).toBe('users')\n\t    expect(first.collectionId).toEqual(john._id)\n\t    expect(first.version).toBe(0)\n\t    expect(first.patch).toHaveLength(0)\n\t    expect(first.doc).toHaveProperty('name', 'John')\n\t    expect(first.doc).toHaveProperty('role', 'user')\n\t    expect(first.doc).toHaveProperty('createdAt')\n", "    expect(first.doc).toHaveProperty('updatedAt')\n\t    expect(first.doc).toHaveProperty('_id', john._id)\n\t    expect(second.op).toBe('create')\n\t    expect(second.modelName).toBe('User')\n\t    expect(second.collectionName).toBe('users')\n\t    expect(second.collectionId).toEqual(alice._id)\n\t    expect(second.version).toBe(0)\n\t    expect(second.patch).toHaveLength(0)\n\t    expect(second.doc).toHaveProperty('name', 'Alice')\n\t    expect(second.doc).toHaveProperty('role', 'user')\n", "    expect(second.doc).toHaveProperty('createdAt')\n\t    expect(second.doc).toHaveProperty('updatedAt')\n\t    expect(second.doc).toHaveProperty('_id', alice._id)\n\t    expect(em.emit).toHaveBeenCalledTimes(0)\n\t  })\n\t})\n"]}
{"filename": "tests/plugin-event-created.test.ts", "chunked_list": ["import { isMongooseLessThan7 } from '../src/version'\n\timport mongoose, { Types, model } from 'mongoose'\n\timport UserSchema from './schemas/UserSchema'\n\timport { patchHistoryPlugin } from '../src/plugin'\n\timport History from '../src/models/History'\n\timport em from '../src/em'\n\timport { USER_CREATED } from './constants/events'\n\tjest.mock('../src/em', () => {\n\t  return {\n\t    emit: jest.fn()\n", "  }\n\t})\n\tdescribe('plugin - event created & patch history disabled', () => {\n\t  const uri = `${globalThis.__MONGO_URI__}${globalThis.__MONGO_DB_NAME__}`\n\t  UserSchema.plugin(patchHistoryPlugin, {\n\t    eventCreated: USER_CREATED,\n\t    patchHistoryDisabled: true\n\t  })\n\t  const User = model('User', UserSchema)\n\t  beforeAll(async () => {\n", "    await mongoose.connect(uri)\n\t  })\n\t  afterAll(async () => {\n\t    await mongoose.connection.close()\n\t  })\n\t  beforeEach(async () => {\n\t    await mongoose.connection.collection('users').deleteMany({})\n\t    await mongoose.connection.collection('history').deleteMany({})\n\t  })\n\t  describe('normal cases', () => {\n", "    it('should save() and emit one create event', async () => {\n\t      const john = new User({ name: 'John', role: 'user' })\n\t      await john.save()\n\t      const history = await History.find({})\n\t      expect(history).toHaveLength(0)\n\t      expect(em.emit).toHaveBeenCalledTimes(1)\n\t      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n\t        doc: expect.objectContaining({\n\t          _id: john._id,\n\t          name: john.name,\n", "          role: john.role,\n\t          createdAt: john.createdAt,\n\t          updatedAt: john.updatedAt\n\t        })\n\t      })\n\t      // Check if the document is saved\n\t      const found = await User.findOne({})\n\t      expect(found).not.toBeNull()\n\t      expect(found?.name).toBe('John')\n\t      expect(found?.role).toBe('user')\n", "    })\n\t    it('should create() and emit one create event', async () => {\n\t      const user = await User.create({ name: 'John', role: 'user' })\n\t      const history = await History.find({})\n\t      expect(history).toHaveLength(0)\n\t      expect(em.emit).toHaveBeenCalledTimes(1)\n\t      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n\t        doc: expect.objectContaining({\n\t          _id: user._id,\n\t          name: user.name,\n", "          role: user.role,\n\t          createdAt: user.createdAt,\n\t          updatedAt: user.updatedAt\n\t        })\n\t      })\n\t      // Check if the document is saved\n\t      const found = await User.findOne({})\n\t      expect(found).not.toBeNull()\n\t      expect(found?.name).toBe('John')\n\t      expect(found?.role).toBe('user')\n", "    })\n\t    it('should insertMany() and emit three create events', async () => {\n\t      const users = await User.insertMany([\n\t        { name: 'John', role: 'user' },\n\t        { name: 'Alice', role: 'user' },\n\t        { name: 'Bob', role: 'user' }\n\t      ], { ordered: true })\n\t      const [john, alice, bob] = users\n\t      const history = await History.find({})\n\t      expect(history).toHaveLength(0)\n", "      expect(em.emit).toHaveBeenCalledTimes(3)\n\t      expect(em.emit).toHaveBeenNthCalledWith(1, USER_CREATED, {\n\t        doc: expect.objectContaining({\n\t          _id: john._id,\n\t          name: john.name,\n\t          role: john.role,\n\t          createdAt: john.createdAt,\n\t          updatedAt: john.updatedAt\n\t        })\n\t      })\n", "      expect(em.emit).toHaveBeenNthCalledWith(2, USER_CREATED, {\n\t        doc: expect.objectContaining({\n\t          _id: alice._id,\n\t          name: alice.name,\n\t          role: alice.role,\n\t          createdAt: alice.createdAt,\n\t          updatedAt: alice.updatedAt\n\t        })\n\t      })\n\t      expect(em.emit).toHaveBeenNthCalledWith(3, USER_CREATED, {\n", "        doc: expect.objectContaining({\n\t          _id: bob._id,\n\t          name: bob.name,\n\t          role: bob.role,\n\t          createdAt: bob.createdAt,\n\t          updatedAt: bob.updatedAt\n\t        })\n\t      })\n\t      // Check if the documents are saved\n\t      const found = await User.find({})\n", "      expect(found).toHaveLength(3)\n\t      const [foundJohn, foundAlice, foundBob] = found\n\t      expect(foundJohn.name).toBe('John')\n\t      expect(foundJohn.role).toBe('user')\n\t      expect(foundAlice.name).toBe('Alice')\n\t      expect(foundAlice.role).toBe('user')\n\t      expect(foundBob.name).toBe('Bob')\n\t      expect(foundBob.role).toBe('user')\n\t    })\n\t  })\n", "  describe('upsert cases', () => {\n\t    it('should update() + upsert and emit one create event', async () => {\n\t      if (isMongooseLessThan7) {\n\t        await User.update(\n\t          { name: 'John' },\n\t          { name: 'John', role: 'admin' },\n\t          { upsert: true }\n\t        )\n\t      } else {\n\t        await User.findOneAndUpdate(\n", "          { name: 'John' },\n\t          { name: 'John', role: 'admin' },\n\t          { upsert: true }\n\t        )\n\t      }\n\t      const user = await User.findOne({ name: 'John', role: 'admin' })\n\t      expect(user).not.toBeNull()\n\t      const history = await History.find({})\n\t      expect(history).toHaveLength(0)\n\t      expect(em.emit).toHaveBeenCalledTimes(1)\n", "      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n\t        doc: expect.objectContaining({\n\t          _id: user?._id,\n\t          name: user?.name,\n\t          role: user?.role\n\t        // Upsert does not set createdAt and updatedAt\n\t        })\n\t      })\n\t      // Check if the document is saved\n\t      const found = await User.findOne({})\n", "      expect(found).not.toBeNull()\n\t      expect(found?.name).toBe('John')\n\t      expect(found?.role).toBe('admin')\n\t    })\n\t    it('should updateOne() + upsert and emit one create event', async () => {\n\t      await User.updateOne(\n\t        { name: 'John' },\n\t        { name: 'John', role: 'admin' },\n\t        { upsert: true }\n\t      )\n", "      const user = await User.findOne({ name: 'John', role: 'admin' })\n\t      expect(user).not.toBeNull()\n\t      const history = await History.find({})\n\t      expect(history).toHaveLength(0)\n\t      expect(em.emit).toHaveBeenCalledTimes(1)\n\t      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n\t        doc: expect.objectContaining({\n\t          _id: user?._id,\n\t          name: user?.name,\n\t          role: user?.role\n", "        // Upsert does not set createdAt and updatedAt\n\t        })\n\t      })\n\t      // Check if the document is saved\n\t      const found = await User.findOne({})\n\t      expect(found).not.toBeNull()\n\t      expect(found?.name).toBe('John')\n\t      expect(found?.role).toBe('admin')\n\t    })\n\t    it('should replaceOne() + upsert and emit one create event', async () => {\n", "      await User.replaceOne(\n\t        { name: 'John' },\n\t        { name: 'John', role: 'admin' },\n\t        { upsert: true }\n\t      )\n\t      const user = await User.findOne({ name: 'John', role: 'admin' })\n\t      expect(user).not.toBeNull()\n\t      const history = await History.find({})\n\t      expect(history).toHaveLength(0)\n\t      expect(em.emit).toHaveBeenCalledTimes(1)\n", "      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n\t        doc: expect.objectContaining({\n\t          _id: user?._id,\n\t          name: user?.name,\n\t          role: user?.role\n\t          // Upsert does not set createdAt and updatedAt\n\t        })\n\t      })\n\t      // Check if the document is saved\n\t      const found = await User.findOne({})\n", "      expect(found).not.toBeNull()\n\t      expect(found?.name).toBe('John')\n\t      expect(found?.role).toBe('admin')\n\t    })\n\t    it('should updateMany() + upsert and emit one create event', async () => {\n\t      await User.updateMany(\n\t        { name: { $in: ['John', 'Alice', 'Bob'] } },\n\t        { name: 'Steve', role: 'admin' },\n\t        { upsert: true }\n\t      )\n", "      const users = await User.findOne({ name: 'Steve', role: 'admin' })\n\t      const history = await History.find({})\n\t      expect(history).toHaveLength(0)\n\t      expect(em.emit).toHaveBeenCalledTimes(1)\n\t      expect(em.emit).toHaveBeenNthCalledWith(1, USER_CREATED, {\n\t        doc: expect.objectContaining({\n\t          _id: users?._id,\n\t          name: users?.name,\n\t          role: users?.role\n\t        // Upsert does not set createdAt and updatedAt\n", "        })\n\t      })\n\t      // Check if the document is saved\n\t      const found = await User.findById(users?._id)\n\t      expect(found).not.toBeNull()\n\t      expect(found?.name).toBe('Steve')\n\t      expect(found?.role).toBe('admin')\n\t    })\n\t    it('should findOneAndUpdate() + upsert and emit one create event', async () => {\n\t      await User.findOneAndUpdate(\n", "        { name: 'John' },\n\t        { name: 'John', role: 'admin' },\n\t        { upsert: true }\n\t      )\n\t      const user = await User.findOne({ name: 'John', role: 'admin' })\n\t      expect(user).not.toBeNull()\n\t      const history = await History.find({})\n\t      expect(history).toHaveLength(0)\n\t      expect(em.emit).toHaveBeenCalledTimes(1)\n\t      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n", "        doc: expect.objectContaining({\n\t          _id: user?._id,\n\t          name: user?.name,\n\t          role: user?.role\n\t        // Upsert does not set createdAt and updatedAt\n\t        })\n\t      })\n\t      // Check if the document is saved\n\t      const found = await User.findOne({})\n\t      expect(found).not.toBeNull()\n", "      expect(found?.name).toBe('John')\n\t      expect(found?.role).toBe('admin')\n\t    })\n\t    it('should findOneAndReplace() + upsert and emit one create event', async () => {\n\t      await User.findOneAndReplace(\n\t        { name: 'John' },\n\t        { name: 'John', role: 'admin' },\n\t        { upsert: true }\n\t      )\n\t      const user = await User.findOne({ name: 'John', role: 'admin' })\n", "      expect(user).not.toBeNull()\n\t      const history = await History.find({})\n\t      expect(history).toHaveLength(0)\n\t      expect(em.emit).toHaveBeenCalledTimes(1)\n\t      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n\t        doc: expect.objectContaining({\n\t          _id: user?._id,\n\t          name: user?.name,\n\t          role: user?.role\n\t        // Upsert does not set createdAt and updatedAt\n", "        })\n\t      })\n\t      // Check if the document is saved\n\t      const found = await User.findOne({})\n\t      expect(found).not.toBeNull()\n\t      expect(found?.name).toBe('John')\n\t      expect(found?.role).toBe('admin')\n\t    })\n\t    it('should findByIdAndUpdate() + upsert and emit one create event', async () => {\n\t      const _id = new Types.ObjectId()\n", "      await User.findByIdAndUpdate(_id, { name: 'John', role: 'admin' }, { upsert: true })\n\t      const user = await User.findOne({ name: 'John', role: 'admin' })\n\t      expect(user).not.toBeNull()\n\t      const history = await History.find({})\n\t      expect(history).toHaveLength(0)\n\t      expect(em.emit).toHaveBeenCalledTimes(1)\n\t      expect(em.emit).toHaveBeenCalledWith(USER_CREATED, {\n\t        doc: expect.objectContaining({\n\t          _id: user?._id,\n\t          name: user?.name,\n", "          role: user?.role\n\t        })\n\t      })\n\t      // Check if the document is saved\n\t      const found = await User.findOne({})\n\t      expect(found).not.toBeNull()\n\t      expect(found?.name).toBe('John')\n\t      expect(found?.role).toBe('admin')\n\t    })\n\t  })\n", "})\n"]}
{"filename": "tests/schemas/UserSchema.ts", "chunked_list": ["import { Schema } from 'mongoose'\n\timport type IUser from '../interfaces/IUser'\n\tconst UserSchema = new Schema<IUser>({\n\t  name: {\n\t    type: String,\n\t    required: true\n\t  },\n\t  role: {\n\t    type: String,\n\t    required: true\n", "  }\n\t}, { timestamps: true })\n\texport default UserSchema\n"]}
{"filename": "tests/constants/events.ts", "chunked_list": ["export const USER_CREATED = 'user-created'\n\texport const USER_UPDATED = 'user-updated'\n\texport const USER_DELETED = 'user-deleted'\n"]}
{"filename": "tests/interfaces/IUser.ts", "chunked_list": ["interface IUser {\n\t  name: string\n\t  role: string\n\t  createdAt?: Date\n\t  updatedAt?: Date\n\t}\n\texport default IUser\n"]}
{"filename": "src/plugin.ts", "chunked_list": ["import _ from 'lodash'\n\timport { assign } from 'power-assign'\n\timport type { HydratedDocument, Model, MongooseQueryMiddleware, QueryOptions, Schema, ToObjectOptions, UpdateQuery, UpdateWithAggregationPipeline } from 'mongoose'\n\timport type IPluginOptions from './interfaces/IPluginOptions'\n\timport type IContext from './interfaces/IContext'\n\timport type IHookContext from './interfaces/IHookContext'\n\timport { createPatch, updatePatch, deletePatch } from './patch'\n\timport { isMongooseLessThan7 } from './version'\n\timport em from './em'\n\tconst remove = isMongooseLessThan7 ? 'remove' : 'deleteOne'\n", "const toObjectOptions: ToObjectOptions = {\n\t  depopulate: true,\n\t  virtuals: false\n\t}\n\tconst updateMethods = [\n\t  'update',\n\t  'updateOne',\n\t  'replaceOne',\n\t  'updateMany',\n\t  'findOneAndUpdate',\n", "  'findOneAndReplace',\n\t  'findByIdAndUpdate'\n\t]\n\tconst deleteMethods = [\n\t  'remove',\n\t  'findOneAndDelete',\n\t  'findOneAndRemove',\n\t  'findByIdAndDelete',\n\t  'findByIdAndRemove',\n\t  'deleteOne',\n", "  'deleteMany'\n\t]\n\tfunction isHookIgnored<T> (options: QueryOptions<T>): boolean {\n\t  return options.ignoreHook === true || (options.ignoreEvent === true && options.ignorePatchHistory === true)\n\t}\n\tfunction splitUpdateAndCommands<T> (updateQuery: UpdateWithAggregationPipeline | UpdateQuery<T> | null): { update: UpdateQuery<T>, commands: Record<string, unknown>[] } {\n\t  let update: UpdateQuery<T> = {}\n\t  const commands: Record<string, unknown>[] = []\n\t  if (!_.isEmpty(updateQuery) && !_.isArray(updateQuery) && _.isObjectLike(updateQuery)) {\n\t    update = _.cloneDeep(updateQuery)\n", "    const keys = _.keys(update).filter((key) => key.startsWith('$'))\n\t    if (!_.isEmpty(keys)) {\n\t      _.forEach(keys, (key) => {\n\t        commands.push({ [key]: update[key] as unknown })\n\t        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n\t        delete update[key]\n\t      })\n\t    }\n\t  }\n\t  return { update, commands }\n", "}\n\tfunction assignUpdate<T> (document: HydratedDocument<T>, update: UpdateQuery<T>, commands: Record<string, unknown>[]): HydratedDocument<T> {\n\t  let updated = assign(document, update)\n\t  _.forEach(commands, (command) => {\n\t    try {\n\t      updated = assign(updated, command)\n\t    } catch {\n\t      // we catch assign keys that are not implemented\n\t    }\n\t  })\n", "  return updated\n\t}\n\t/**\n\t * @description Patch patch event emitter\n\t */\n\texport const patchEventEmitter = em\n\t/**\n\t * @description Patch history plugin\n\t * @param {Schema} schema\n\t * @param {IPluginOptions} opts\n", " * @returns {void}\n\t */\n\texport const patchHistoryPlugin = function plugin<T> (schema: Schema<T>, opts: IPluginOptions<T>): void {\n\t  schema.pre('save', async function () {\n\t    const current = this.toObject(toObjectOptions) as HydratedDocument<T>\n\t    const model = this.constructor as Model<T>\n\t    const context: IContext<T> = {\n\t      op: this.isNew ? 'create' : 'update',\n\t      modelName: opts.modelName ?? model.modelName,\n\t      collectionName: opts.collectionName ?? model.collection.collectionName,\n", "      createdDocs: [current]\n\t    }\n\t    if (this.isNew) {\n\t      await createPatch(opts, context)\n\t    } else {\n\t      const original = await model.findById(current._id).lean().exec()\n\t      if (original) {\n\t        await updatePatch(opts, context, current, original as HydratedDocument<T>)\n\t      }\n\t    }\n", "  })\n\t  schema.post('insertMany', async function (docs) {\n\t    const context = {\n\t      op: 'create',\n\t      modelName: opts.modelName ?? this.modelName,\n\t      collectionName: opts.collectionName ?? this.collection.collectionName,\n\t      createdDocs: docs as unknown as HydratedDocument<T>[]\n\t    }\n\t    await createPatch(opts, context)\n\t  })\n", "  schema.pre(updateMethods as MongooseQueryMiddleware[], async function (this: IHookContext<T>) {\n\t    const options = this.getOptions()\n\t    if (isHookIgnored(options)) return\n\t    const model = this.model as Model<T>\n\t    const filter = this.getFilter()\n\t    const count = await this.model.count(filter).exec()\n\t    this._context = {\n\t      op: this.op,\n\t      modelName: opts.modelName ?? this.model.modelName,\n\t      collectionName: opts.collectionName ?? this.model.collection.collectionName,\n", "      isNew: options.upsert && count === 0,\n\t      ignoreEvent: options.ignoreEvent as boolean,\n\t      ignorePatchHistory: options.ignorePatchHistory as boolean\n\t    }\n\t    const updateQuery = this.getUpdate()\n\t    const { update, commands } = splitUpdateAndCommands(updateQuery)\n\t    const cursor = model.find(filter).lean().cursor()\n\t    await cursor.eachAsync(async (doc: HydratedDocument<T>) => {\n\t      await updatePatch(opts, this._context, assignUpdate(doc, update, commands), doc)\n\t    })\n", "  })\n\t  schema.post(updateMethods as MongooseQueryMiddleware[], async function (this: IHookContext<T>) {\n\t    const options = this.getOptions()\n\t    if (isHookIgnored(options)) return\n\t    if (!this._context.isNew) return\n\t    const model = this.model as Model<T>\n\t    const updateQuery = this.getUpdate()\n\t    const { update, commands } = splitUpdateAndCommands(updateQuery)\n\t    const filter = assignUpdate({} as HydratedDocument<T>, update, commands)\n\t    if (!_.isEmpty(filter)) {\n", "      const current = await model.findOne(update).lean().exec()\n\t      if (current) {\n\t        this._context.createdDocs = [current] as HydratedDocument<T>[]\n\t        await createPatch(opts, this._context)\n\t      }\n\t    }\n\t  })\n\t  schema.pre(remove, { document: true, query: false }, async function () {\n\t    const original = this.toObject(toObjectOptions) as HydratedDocument<T>\n\t    if (opts.preDelete && !_.isEmpty(original)) {\n", "      await opts.preDelete([original])\n\t    }\n\t  })\n\t  schema.post(remove, { document: true, query: false }, async function (this: HydratedDocument<T>) {\n\t    const original = this.toObject(toObjectOptions) as HydratedDocument<T>\n\t    const model = this.constructor as Model<T>\n\t    const context: IContext<T> = {\n\t      op: 'delete',\n\t      modelName: opts.modelName ?? model.modelName,\n\t      collectionName: opts.collectionName ?? model.collection.collectionName,\n", "      deletedDocs: [original]\n\t    }\n\t    await deletePatch(opts, context)\n\t  })\n\t  schema.pre(deleteMethods as MongooseQueryMiddleware[], { document: false, query: true }, async function (this: IHookContext<T>) {\n\t    const options = this.getOptions()\n\t    if (isHookIgnored(options)) return\n\t    const model = this.model as Model<T>\n\t    const filter = this.getFilter()\n\t    this._context = {\n", "      op: this.op,\n\t      modelName: opts.modelName ?? this.model.modelName,\n\t      collectionName: opts.collectionName ?? this.model.collection.collectionName,\n\t      ignoreEvent: options.ignoreEvent as boolean,\n\t      ignorePatchHistory: options.ignorePatchHistory as boolean\n\t    }\n\t    if (['remove', 'deleteMany'].includes(this._context.op) && !options.single) {\n\t      const docs = await model.find(filter).lean().exec()\n\t      if (!_.isEmpty(docs)) {\n\t        this._context.deletedDocs = docs as HydratedDocument<T>[]\n", "      }\n\t    } else {\n\t      const doc = await model.findOne(filter).lean().exec()\n\t      if (!_.isEmpty(doc)) {\n\t        this._context.deletedDocs = [doc] as HydratedDocument<T>[]\n\t      }\n\t    }\n\t    if (opts.preDelete && _.isArray(this._context.deletedDocs) && !_.isEmpty(this._context.deletedDocs)) {\n\t      await opts.preDelete(this._context.deletedDocs)\n\t    }\n", "  })\n\t  schema.post(deleteMethods as MongooseQueryMiddleware[], { document: false, query: true }, async function (this: IHookContext<T>) {\n\t    const options = this.getOptions()\n\t    if (isHookIgnored(options)) return\n\t    await deletePatch(opts, this._context)\n\t  })\n\t}\n"]}
{"filename": "src/patch.ts", "chunked_list": ["import _ from 'lodash'\n\timport omit from 'omit-deep'\n\timport jsonpatch from 'fast-json-patch'\n\timport type { HydratedDocument, Types } from 'mongoose'\n\timport type IEvent from './interfaces/IEvent'\n\timport type IContext from './interfaces/IContext'\n\timport type IPluginOptions from './interfaces/IPluginOptions'\n\timport type { User, Metadata } from './interfaces/IPluginOptions'\n\timport History from './models/History'\n\timport em from './em'\n", "function isPatchHistoryEnabled<T> (opts: IPluginOptions<T>, context: IContext<T>): boolean {\n\t  return !opts.patchHistoryDisabled && !context.ignorePatchHistory\n\t}\n\texport function getObjects<T> (opts: IPluginOptions<T>, current: HydratedDocument<T>, original: HydratedDocument<T>): { currentObject: Partial<T>, originalObject: Partial<T> } {\n\t  let currentObject = JSON.parse(JSON.stringify(current)) as Partial<T>\n\t  let originalObject = JSON.parse(JSON.stringify(original)) as Partial<T>\n\t  if (opts.omit) {\n\t    currentObject = omit(currentObject, opts.omit)\n\t    originalObject = omit(originalObject, opts.omit)\n\t  }\n", "  return { currentObject, originalObject }\n\t}\n\texport async function getUser<T> (opts: IPluginOptions<T>): Promise<User | undefined> {\n\t  if (_.isFunction(opts.getUser)) {\n\t    return await opts.getUser()\n\t  }\n\t  return undefined\n\t}\n\texport async function getReason<T> (opts: IPluginOptions<T>): Promise<string | undefined> {\n\t  if (_.isFunction(opts.getReason)) {\n", "    return await opts.getReason()\n\t  }\n\t  return undefined\n\t}\n\texport async function getMetadata<T> (opts: IPluginOptions<T>): Promise<Metadata | undefined> {\n\t  if (_.isFunction(opts.getMetadata)) {\n\t    return await opts.getMetadata()\n\t  }\n\t  return undefined\n\t}\n", "export function getValue <T> (item: PromiseSettledResult<T>): T | undefined {\n\t  return item.status === 'fulfilled' ? item.value : undefined\n\t}\n\texport async function getData<T> (opts: IPluginOptions<T>): Promise<[User | undefined, string | undefined, Metadata | undefined]> {\n\t  return Promise\n\t    .allSettled([getUser(opts), getReason(opts), getMetadata(opts)])\n\t    .then(([user, reason, metadata]) => {\n\t      return [\n\t        getValue(user),\n\t        getValue(reason),\n", "        getValue(metadata)\n\t      ]\n\t    })\n\t}\n\texport function emitEvent<T> (context: IContext<T>, event: string | undefined, data: IEvent<T>): void {\n\t  if (event && !context.ignoreEvent) {\n\t    em.emit(event, data)\n\t  }\n\t}\n\texport async function bulkPatch<T> (opts: IPluginOptions<T>, context: IContext<T>, eventKey: 'eventCreated' | 'eventDeleted', docsKey: 'createdDocs' | 'deletedDocs'): Promise<void> {\n", "  const history = isPatchHistoryEnabled(opts, context)\n\t  const event = opts[eventKey]\n\t  const docs = context[docsKey]\n\t  const key = eventKey === 'eventCreated' ? 'doc' : 'oldDoc'\n\t  if (_.isEmpty(docs) || (!event && !history)) return\n\t  const [user, reason, metadata] = await getData(opts)\n\t  const chunks = _.chunk(docs, 1000)\n\t  for await (const chunk of chunks) {\n\t    const bulk = []\n\t    for (const doc of chunk) {\n", "      emitEvent(context, event, { [key]: doc })\n\t      if (history) {\n\t        bulk.push({\n\t          insertOne: {\n\t            document: {\n\t              op: context.op,\n\t              modelName: context.modelName,\n\t              collectionName: context.collectionName,\n\t              collectionId: doc._id as Types.ObjectId,\n\t              doc,\n", "              user,\n\t              reason,\n\t              metadata,\n\t              version: 0\n\t            }\n\t          }\n\t        })\n\t      }\n\t    }\n\t    if (history) {\n", "      await History.bulkWrite(bulk, { ordered: false })\n\t    }\n\t  }\n\t}\n\texport async function createPatch<T> (opts: IPluginOptions<T>, context: IContext<T>): Promise<void> {\n\t  await bulkPatch(opts, context, 'eventCreated', 'createdDocs')\n\t}\n\texport async function updatePatch<T> (opts: IPluginOptions<T>, context: IContext<T>, current: HydratedDocument<T>, original: HydratedDocument<T>): Promise<void> {\n\t  const history = isPatchHistoryEnabled(opts, context)\n\t  const { currentObject, originalObject } = getObjects(opts, current, original)\n", "  if (_.isEmpty(originalObject) || _.isEmpty(currentObject)) return\n\t  const patch = jsonpatch.compare(originalObject, currentObject, true)\n\t  if (_.isEmpty(patch)) return\n\t  emitEvent(context, opts.eventUpdated, { oldDoc: original, doc: current, patch })\n\t  if (history) {\n\t    let version = 0\n\t    const lastHistory = await History.findOne({ collectionId: original._id as Types.ObjectId }).sort('-version').exec()\n\t    if (lastHistory && lastHistory.version >= 0) {\n\t      version = lastHistory.version + 1\n\t    }\n", "    const [user, reason, metadata] = await getData(opts)\n\t    await History.create({\n\t      op: context.op,\n\t      modelName: context.modelName,\n\t      collectionName: context.collectionName,\n\t      collectionId: original._id as Types.ObjectId,\n\t      patch,\n\t      user,\n\t      reason,\n\t      metadata,\n", "      version\n\t    })\n\t  }\n\t}\n\texport async function deletePatch<T> (opts: IPluginOptions<T>, context: IContext<T>): Promise<void> {\n\t  await bulkPatch(opts, context, 'eventDeleted', 'deletedDocs')\n\t}\n"]}
{"filename": "src/version.ts", "chunked_list": ["import { satisfies } from 'semver'\n\timport mongoose from 'mongoose'\n\texport const isMongooseLessThan7 = satisfies(mongoose.version, '<7')\n\texport const isMongoose6 = satisfies(mongoose.version, '6')\n\tif (isMongoose6) {\n\t  mongoose.set('strictQuery', false)\n\t}\n"]}
{"filename": "src/em.ts", "chunked_list": ["import EventEmitter from 'events'\n\tclass PatchEventEmitter extends EventEmitter {}\n\tconst em = new PatchEventEmitter()\n\texport default em\n"]}
{"filename": "src/interfaces/IHistory.ts", "chunked_list": ["import type { Types } from 'mongoose'\n\timport type { Operation } from 'fast-json-patch'\n\tinterface IHistory {\n\t  op: string\n\t  modelName: string,\n\t  collectionName: string\n\t  collectionId: Types.ObjectId\n\t  version: number\n\t  doc?: object\n\t  user?: object\n", "  reason?: string\n\t  metadata?: object\n\t  patch?: Operation[]\n\t}\n\texport default IHistory\n"]}
{"filename": "src/interfaces/IPluginOptions.ts", "chunked_list": ["import type { HydratedDocument } from 'mongoose'\n\texport type User = Record<string, unknown>\n\texport type Metadata = Record<string, unknown>\n\tinterface IPluginOptions<T> {\n\t  modelName?: string\n\t  collectionName?: string\n\t  eventUpdated?: string\n\t  eventCreated?: string\n\t  eventDeleted?: string\n\t  getUser?: () => Promise<User> | User\n", "  getReason?: () => Promise<string> | string\n\t  getMetadata?: () => Promise<Metadata> | Metadata\n\t  omit?: string[]\n\t  patchHistoryDisabled?: boolean\n\t  preDelete?: (docs: HydratedDocument<T>[]) => Promise<void>\n\t}\n\texport default IPluginOptions\n"]}
{"filename": "src/interfaces/IEvent.ts", "chunked_list": ["import type { Operation } from 'fast-json-patch'\n\timport type { HydratedDocument } from 'mongoose'\n\tinterface IEvent<T> {\n\t  oldDoc?: HydratedDocument<T>\n\t  doc?: HydratedDocument<T>\n\t  patch?: Operation[]\n\t}\n\texport default IEvent\n"]}
{"filename": "src/interfaces/IContext.ts", "chunked_list": ["import type { HydratedDocument } from 'mongoose'\n\tinterface IContext<T> {\n\t  op: string\n\t  modelName: string\n\t  collectionName: string\n\t  isNew?: boolean\n\t  createdDocs?: HydratedDocument<T>[]\n\t  deletedDocs?: HydratedDocument<T>[]\n\t  ignoreEvent?: boolean\n\t  ignorePatchHistory?: boolean\n", "}\n\texport default IContext\n"]}
{"filename": "src/interfaces/IHookContext.ts", "chunked_list": ["import type { Query } from 'mongoose'\n\timport type IContext from './IContext'\n\ttype IHookContext<T> = Query<T, T> & { op: string, _context: IContext<T> }\n\texport default IHookContext\n"]}
{"filename": "src/models/History.ts", "chunked_list": ["import { Schema, model } from 'mongoose'\n\timport type IHistory from '../interfaces/IHistory'\n\tconst HistorySchema = new Schema<IHistory>({\n\t  op: {\n\t    type: String,\n\t    required: true\n\t  },\n\t  modelName: {\n\t    type: String,\n\t    required: true\n", "  },\n\t  collectionName: {\n\t    type: String,\n\t    required: true\n\t  },\n\t  collectionId: {\n\t    type: Schema.Types.ObjectId,\n\t    required: true\n\t  },\n\t  doc: {\n", "    type: Object\n\t  },\n\t  patch: {\n\t    type: Array\n\t  },\n\t  user: {\n\t    type: Object\n\t  },\n\t  reason: {\n\t    type: String\n", "  },\n\t  metadata: {\n\t    type: Object\n\t  },\n\t  version: {\n\t    type: Number,\n\t    min: 0,\n\t    default: 0\n\t  }\n\t}, { timestamps: true })\n", "HistorySchema.index({ collectionId: 1, version: -1 })\n\tHistorySchema.index({ op: 1, modelName: 1, collectionName: 1, collectionId: 1, reason: 1, version: 1 })\n\tconst History = model('History', HistorySchema, 'history')\n\texport default History\n"]}
{"filename": "src/modules/power-assign.d.ts", "chunked_list": ["declare module 'power-assign' {\n\t  export function assign<T, U>(object1: T, object2: U): T & U\n\t}\n"]}
{"filename": "src/modules/omit-deep.d.ts", "chunked_list": ["declare module 'omit-deep' {\n\t  export default function omitDeep<T>(value: T, keys: string[]): Partial<T>\n\t}\n"]}
