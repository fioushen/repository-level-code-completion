{"filename": "src/utils/get-clients.ts", "chunked_list": ["import type { Chain, Hex, HttpTransport, PrivateKeyAccount, PublicClient, WalletClient } from 'viem'\n\timport { createPublicClient, createWalletClient, http } from 'viem'\n\timport { privateKeyToAccount } from 'viem/accounts'\n\timport { NETWORKS } from '../data/config.js'\n\timport type { Chains } from '../data/constants.js'\n\t// TODO: Singleton maybe?\n\tfunction getPublicClient({ network }: { network: Chains }): PublicClient {\n\t  const { rpc, viemChain } = NETWORKS[network]\n\t  return createPublicClient({ chain: viemChain, transport: http(rpc) })\n\t}\n", "function getWalletClient({ network, privateKey }: { network: Chains; privateKey: Hex }): WalletClient<HttpTransport, Chain, PrivateKeyAccount> {\n\t  const { rpc, viemChain } = NETWORKS[network]\n\t  return createWalletClient({ chain: viemChain, account: privateKeyToAccount(privateKey), transport: http(rpc) })\n\t}\n\texport { getPublicClient, getWalletClient }\n"]}
{"filename": "src/utils/split-array.ts", "chunked_list": ["function splitArray<T>(array: T[], x: number): T[][] {\n\t  const result: T[][] = []\n\t  for (let i = 0; i < x; i++) {\n\t    const subArray = array.filter((_, index) => index % x === i)\n\t    result.push(subArray)\n\t  }\n\t  return result\n\t}\n\texport { splitArray }\n"]}
{"filename": "src/utils/get-evm-wallet.ts", "chunked_list": ["import type { Address } from 'viem/accounts'\n\timport { privateKeyToAccount } from 'viem/accounts'\n\texport function getEvmWallet(privateKey: Address) {\n\t  const account = privateKeyToAccount(privateKey)\n\t  return account.address\n\t}\n"]}
{"filename": "src/data/config.ts", "chunked_list": ["import { arbitrum, avalanche, bsc, fantom, mainnet, optimism, polygon, polygonZkEvm, zkSync } from 'viem/chains'\n\timport type { CexKeys, CexKeysWithPassword } from '../models/cex.js'\n\timport type { NetworkConfiguration } from '../models/network.js'\n\t// Токен для работы бота. Получить можно у @BotFather в Telegram.\n\tconst TELEGRAM_BOT_TOKEN = ''\n\t// Куда будут отправляться логи. Можно указать группу, контакт, канал.\n\tconst TELEGRAM_USER_ID = ''\n\t// Здесь рекомендуется подставить свои значения RPC.\n\tconst NETWORKS: NetworkConfiguration = {\n\t  ethereum: {\n", "    rpc: 'https://eth.rpc.blxrbdn.com',\n\t    scan: 'https://etherscan.io/tx',\n\t    token: 'ETH',\n\t    chain_id: 1,\n\t    viemChain: mainnet,\n\t  },\n\t  optimism: {\n\t    rpc: 'https://mainnet.optimism.io',\n\t    scan: 'https://optimistic.etherscan.io/tx',\n\t    token: 'ETH',\n", "    chain_id: 10,\n\t    viemChain: optimism,\n\t  },\n\t  bsc: {\n\t    rpc: 'https://bsc-dataseed1.ninicoin.io',\n\t    scan: 'https://bscscan.com/tx',\n\t    token: 'BNB',\n\t    chain_id: 56,\n\t    viemChain: bsc,\n\t  },\n", "  polygon: {\n\t    rpc: 'https://rpc.ankr.com/polygon',\n\t    scan: 'https://polygonscan.com/tx',\n\t    token: 'MATIC',\n\t    chain_id: 137,\n\t    viemChain: polygon,\n\t  },\n\t  polygonZkEvm: {\n\t    rpc: 'https://zkevm-rpc.com',\n\t    scan: 'https://zkevm.polygonscan.com/tx',\n", "    token: 'ETH',\n\t    chain_id: 1101,\n\t    viemChain: polygonZkEvm,\n\t  },\n\t  arbitrum: {\n\t    rpc: 'https://arb1.croswap.com/rpc',\n\t    scan: 'https://arbiscan.io/tx',\n\t    token: 'ETH',\n\t    chain_id: 42161,\n\t    viemChain: arbitrum,\n", "  },\n\t  avalanche: {\n\t    rpc: 'https://rpc.ankr.com/avalanche',\n\t    scan: 'https://snowtrace.io/tx',\n\t    token: 'AVAX',\n\t    chain_id: 43114,\n\t    viemChain: avalanche,\n\t  },\n\t  fantom: {\n\t    rpc: 'https://rpc.ankr.com/fantom',\n", "    scan: 'https://ftmscan.com/tx',\n\t    token: 'FTM',\n\t    chain_id: 250,\n\t    viemChain: fantom,\n\t  },\n\t  nova: {\n\t    rpc: 'https://nova.arbitrum.io/rpc',\n\t    scan: 'https://nova.arbiscan.io/tx',\n\t    token: 'ETH',\n\t    chain_id: 42170,\n", "    viemChain: undefined, // TODO: Add nova chain\n\t  },\n\t  zksync: {\n\t    rpc: 'https://mainnet.era.zksync.io',\n\t    scan: 'https://explorer.zksync.io/tx',\n\t    token: 'ETH',\n\t    chain_id: 324,\n\t    viemChain: zkSync,\n\t  },\n\t}\n", "// Апи ключи от бирж. если биржей не пользуешься, можно не вставлять\n\tconst CEX_KEYS: {\n\t  [key: string]: CexKeys\n\t} = {\n\t  // binance: { api_key: 'your_api_key', api_secret: 'your_api_secret' },\n\t  // mexc: { api_key: 'your_api_key', api_secret: 'your_api_secret' },\n\t  // kucoin: { api_key: 'your_api_key', api_secret: 'your_api_secret', password: 'your_api_password' },\n\t  // huobi: { api_key: 'your_api_key', api_secret: 'your_api_secret' },\n\t  // bybit: { api_key: 'your_api_key', api_secret: 'your_api_secret' },\n\t}\n", "// можешь записать любое кол-во аккаунтов, сделал таким образом чтобы постоянно данные от новых акков не вводить, а просто вызывать по имени аккаунта\n\tconst OKX_KEYS: {\n\t  [account_name: string]: CexKeysWithPassword\n\t} = {\n\t  account_1: {\n\t    api_key: 'your_api_key',\n\t    api_secret: 'your_api_secret',\n\t    password: 'your_api_password',\n\t  },\n\t  account_2: {\n", "    api_key: 'your_api_key',\n\t    api_secret: 'your_api_secret',\n\t    password: 'your_api_password',\n\t  },\n\t}\n\texport { TELEGRAM_BOT_TOKEN, TELEGRAM_USER_ID, NETWORKS, CEX_KEYS, OKX_KEYS }\n"]}
{"filename": "src/data/wallets.ts", "chunked_list": ["import type { Hex } from 'viem'\n\t// Здесь список приватных ключей, которые будут использоваться в модуле.\n\tconst WALLETS: Hex[] = [\n\t]\n\texport { WALLETS }\n"]}
{"filename": "src/data/abi.ts", "chunked_list": ["const ERC20_ABI = [\n\t  {\n\t    constant: true,\n\t    inputs: [],\n\t    name: 'name',\n\t    outputs: [\n\t      {\n\t        name: '',\n\t        type: 'string',\n\t      },\n", "    ],\n\t    payable: false,\n\t    stateMutability: 'view',\n\t    type: 'function',\n\t  },\n\t  {\n\t    constant: false,\n\t    inputs: [\n\t      {\n\t        name: '_spender',\n", "        type: 'address',\n\t      },\n\t      {\n\t        name: '_value',\n\t        type: 'uint256',\n\t      },\n\t    ],\n\t    name: 'approve',\n\t    outputs: [\n\t      {\n", "        name: '',\n\t        type: 'bool',\n\t      },\n\t    ],\n\t    payable: false,\n\t    stateMutability: 'nonpayable',\n\t    type: 'function',\n\t  },\n\t  {\n\t    constant: true,\n", "    inputs: [],\n\t    name: 'totalSupply',\n\t    outputs: [\n\t      {\n\t        name: '',\n\t        type: 'uint256',\n\t      },\n\t    ],\n\t    payable: false,\n\t    stateMutability: 'view',\n", "    type: 'function',\n\t  },\n\t  {\n\t    constant: false,\n\t    inputs: [\n\t      {\n\t        name: '_from',\n\t        type: 'address',\n\t      },\n\t      {\n", "        name: '_to',\n\t        type: 'address',\n\t      },\n\t      {\n\t        name: '_value',\n\t        type: 'uint256',\n\t      },\n\t    ],\n\t    name: 'transferFrom',\n\t    outputs: [\n", "      {\n\t        name: '',\n\t        type: 'bool',\n\t      },\n\t    ],\n\t    payable: false,\n\t    stateMutability: 'nonpayable',\n\t    type: 'function',\n\t  },\n\t  {\n", "    constant: true,\n\t    inputs: [],\n\t    name: 'decimals',\n\t    outputs: [\n\t      {\n\t        name: '',\n\t        type: 'uint8',\n\t      },\n\t    ],\n\t    payable: false,\n", "    stateMutability: 'view',\n\t    type: 'function',\n\t  },\n\t  {\n\t    constant: true,\n\t    inputs: [\n\t      {\n\t        name: '_owner',\n\t        type: 'address',\n\t      },\n", "    ],\n\t    name: 'balanceOf',\n\t    outputs: [\n\t      {\n\t        name: 'balance',\n\t        type: 'uint256',\n\t      },\n\t    ],\n\t    payable: false,\n\t    stateMutability: 'view',\n", "    type: 'function',\n\t  },\n\t  {\n\t    constant: true,\n\t    inputs: [],\n\t    name: 'symbol',\n\t    outputs: [\n\t      {\n\t        name: '',\n\t        type: 'string',\n", "      },\n\t    ],\n\t    payable: false,\n\t    stateMutability: 'view',\n\t    type: 'function',\n\t  },\n\t  {\n\t    constant: false,\n\t    inputs: [\n\t      {\n", "        name: '_to',\n\t        type: 'address',\n\t      },\n\t      {\n\t        name: '_value',\n\t        type: 'uint256',\n\t      },\n\t    ],\n\t    name: 'transfer',\n\t    outputs: [\n", "      {\n\t        name: '',\n\t        type: 'bool',\n\t      },\n\t    ],\n\t    payable: false,\n\t    stateMutability: 'nonpayable',\n\t    type: 'function',\n\t  },\n\t  {\n", "    constant: true,\n\t    inputs: [\n\t      {\n\t        name: '_owner',\n\t        type: 'address',\n\t      },\n\t      {\n\t        name: '_spender',\n\t        type: 'address',\n\t      },\n", "    ],\n\t    name: 'allowance',\n\t    outputs: [\n\t      {\n\t        name: '',\n\t        type: 'uint256',\n\t      },\n\t    ],\n\t    payable: false,\n\t    stateMutability: 'view',\n", "    type: 'function',\n\t  },\n\t  {\n\t    payable: true,\n\t    stateMutability: 'payable',\n\t    type: 'fallback',\n\t  },\n\t  {\n\t    anonymous: false,\n\t    inputs: [\n", "      {\n\t        indexed: true,\n\t        name: 'owner',\n\t        type: 'address',\n\t      },\n\t      {\n\t        indexed: true,\n\t        name: 'spender',\n\t        type: 'address',\n\t      },\n", "      {\n\t        indexed: false,\n\t        name: 'value',\n\t        type: 'uint256',\n\t      },\n\t    ],\n\t    name: 'Approval',\n\t    type: 'event',\n\t  },\n\t  {\n", "    anonymous: false,\n\t    inputs: [\n\t      {\n\t        indexed: true,\n\t        name: 'from',\n\t        type: 'address',\n\t      },\n\t      {\n\t        indexed: true,\n\t        name: 'to',\n", "        type: 'address',\n\t      },\n\t      {\n\t        indexed: false,\n\t        name: 'value',\n\t        type: 'uint256',\n\t      },\n\t    ],\n\t    name: 'Transfer',\n\t    type: 'event',\n", "  },\n\t] as const\n\texport { ERC20_ABI }\n"]}
{"filename": "src/data/constants.ts", "chunked_list": ["enum Chains {\n\t  Ethereum = 'ethereum',\n\t  Optimism = 'optimism',\n\t  Bsc = 'bsc',\n\t  Polygon = 'polygon',\n\t  PolygonZkEvm = 'polygonZkEvm',\n\t  Arbitrum = 'arbitrum',\n\t  Avalanche = 'avalanche',\n\t  Fantom = 'fantom',\n\t  Nova = 'nova',\n", "  Zksync = 'zksync',\n\t}\n\texport { Chains }\n"]}
{"filename": "src/data/settings.ts", "chunked_list": ["import type { Web3CheckerAlert, Web3CheckerParameters, Web3CheckerTokens } from '../models/web3-checker.js'\n\timport { Chains } from './constants.js'\n\t// Модуль будет проверять только токены, указанные в этом объекте.\n\tconst ONCHAIN_BALANCES_TOKENS: Web3CheckerTokens = {\n\t  [Chains.Bsc]: [\n\t    '', // BNB\n\t    '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', // USDC\n\t    '0x55d398326f99059ff775485246999027b3197955', // USDT\n\t  ],\n\t  [Chains.Arbitrum]: [\n", "    '', // ETH\n\t    '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9', // USDT\n\t    '0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8', // USDC\n\t  ],\n\t  [Chains.Optimism]: [\n\t    '', // ETH\n\t    '0x7f5c764cbc14f9669b88837ca1490cca17c31607', // USDC\n\t    '0x4200000000000000000000000000000000000042', // OP\n\t    // '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58', // USDT\n\t  ],\n", "  // [Chains.Polygon]: [\n\t  //   '', // MATIC\n\t  // ],\n\t  // [Chains.Avalanche]: [\n\t  //   '', // AVAX\n\t  // ],\n\t  [Chains.Ethereum]: [\n\t    '', // ETH\n\t    // '0xdac17f958d2ee523a2206206994597c13d831ec7', // USDT\n\t  ],\n", "  // [Chains.zkSync]: [\n\t  //   '', // ETH\n\t  // ],\n\t  // [Chains.Nova]: [\n\t  //   '', // ETH\n\t  // ],\n\t  // [Chains.Fantom]: [\n\t  //   '', // FTM\n\t  // ],\n\t}\n", "// Здесь можно указать критерий минимального баланса.\n\t// Если баланс меньше этого значения, то будет отправлен алерт в телеграм.\n\t// Для проверки нативного токена используйте пустую строку.\n\t// Для выбора сети используйте константу Chains из файла constants.ts.\n\tconst ONCHAIN_BALANCES_ALERTS: Web3CheckerAlert[] = [\n\t  // {\n\t  //   chain: Chains.Ethereum,\n\t  //   coin: '',\n\t  //   amount: 0.1, // Amount без учета decimals.\n\t  // },\n", "]\n\t// Скрипты не будут запускаться, если газ будет стоить в долларах дороже этого значения.\n\t// const GAS_AMOUNT_LIMITS: Web3CheckerGasAmountLimit = {\n\t//   // [Chains.Ethereum]: 10,\n\t//   // [Chains.Zksync]: 2,\n\t// }\n\tconst ONCHAIN_BALANCES_PARAMETERS: Web3CheckerParameters = {\n\t  tokens: ONCHAIN_BALANCES_TOKENS,\n\t  alerts: ONCHAIN_BALANCES_ALERTS,\n\t  isNeedSaveToFile: true,\n", "  fileName: 'web3-balances',\n\t}\n\texport { ONCHAIN_BALANCES_PARAMETERS }\n"]}
{"filename": "src/models/web3-checker.ts", "chunked_list": ["import type { Address } from 'viem'\n\timport type { Chains } from '../data/constants.js'\n\ttype Web3CheckerTokens = {\n\t  [key in Chains]?: Array<Address | ''>\n\t}\n\tinterface Web3ChekerTokenInfo {\n\t  [key: string]: {\n\t    [key: string]: {\n\t      symbol: string\n\t      decimals: number\n", "      address: Address\n\t      price?: number\n\t    }\n\t  }\n\t}\n\tinterface Web3CheckerTokensResult {\n\t  [wallet: string]: {\n\t    [chain in Chains]?: {\n\t      [token: string]: bigint\n\t    }\n", "  }\n\t}\n\tinterface Web3CheckerAlert {\n\t  chain: Chains\n\t  coin: Address | ''\n\t  amount: number\n\t}\n\ttype Web3CheckerGasAmountLimit = {\n\t  [key in Chains]?: number\n\t}\n", "interface Web3CheckerParameters {\n\t  tokens: Web3CheckerTokens\n\t  alerts: Web3CheckerAlert[]\n\t  fileName: string\n\t  isNeedSaveToFile: boolean\n\t  // maxGwei?: number\n\t  // gasLimits: Web3CheckerGasAmountLimit\n\t  // isNeedTgAlerts: boolean\n\t  // isNeedTgBalances: boolean\n\t  // isCheckGweiEnabled: boolean\n", "}\n\texport type { Web3CheckerTokens, Web3ChekerTokenInfo, Web3CheckerTokensResult, Web3CheckerAlert, Web3CheckerGasAmountLimit, Web3CheckerParameters }\n"]}
{"filename": "src/models/network.ts", "chunked_list": ["import type { Chain } from 'viem'\n\timport type { Chains } from '../data/constants.js'\n\ttype NetworkConfiguration = {\n\t  [key in Chains]: {\n\t    rpc: string\n\t    scan: string\n\t    token: string\n\t    chain_id: number\n\t    viemChain?: Chain\n\t  }\n", "}\n\texport type { NetworkConfiguration }\n"]}
{"filename": "src/models/cex.ts", "chunked_list": ["interface CexKeys {\n\t  api_key: string\n\t  api_secret: string\n\t  password?: string\n\t}\n\tinterface CexKeysWithPassword extends CexKeys {\n\t  password: string\n\t}\n\texport { CexKeys, CexKeysWithPassword }\n"]}
{"filename": "src/modules/web3-checker.ts", "chunked_list": ["// Here is a brief technical description of each function in the Python script:\n\timport { createWriteStream } from 'node:fs'\n\timport { dirname, join } from 'node:path'\n\timport { fileURLToPath } from 'node:url'\n\timport Table from 'cli-table3'\n\timport type { Address, Hex } from 'viem'\n\timport { formatUnits } from 'viem'\n\timport { got } from 'got'\n\timport { splitArray } from '../utils/split-array.js'\n\timport { NETWORKS } from '../data/config.js'\n", "import { getEvmWallet } from '../utils/get-evm-wallet.js'\n\timport { ERC20_ABI } from '../data/abi.js'\n\timport type { Chains } from '../data/constants.js'\n\timport { WALLETS } from '../data/wallets.js'\n\timport type { Web3CheckerTokens, Web3CheckerTokensResult, Web3ChekerTokenInfo } from '../models/web3-checker.js'\n\timport { getPublicClient } from '../utils/get-clients.js'\n\timport { ONCHAIN_BALANCES_PARAMETERS } from '../data/settings.js'\n\tasync function getTokenInfo(tokens: Web3CheckerTokens): Promise<Web3ChekerTokenInfo> {\n\t  const chains = Object.keys(tokens) as Chains[]\n\t  const clients = chains.map(chain => getPublicClient({ network: chain }))\n", "  const symbolParams = {\n\t    abi: ERC20_ABI,\n\t    functionName: 'symbol',\n\t  }\n\t  const decimalsParams = {\n\t    abi: ERC20_ABI,\n\t    functionName: 'decimals',\n\t  }\n\t  const erc20Requests = clients.map(async (client, index) => {\n\t    const chain = chains[index]\n", "    const chainTokens = tokens[chain]?.filter(Boolean) as Address[]\n\t    const contracts = chainTokens.flatMap(token => [\n\t      {\n\t        address: token,\n\t        ...symbolParams,\n\t      },\n\t      {\n\t        address: token,\n\t        ...decimalsParams,\n\t      },\n", "    ])\n\t    return await client.multicall({\n\t      contracts,\n\t    })\n\t  })\n\t  const erc20Results = (await Promise.all(erc20Requests)).map((chainResults, chainIndex) => {\n\t    const chain = chains[chainIndex]\n\t    const chainTokens = tokens[chain]?.filter(Boolean) as Address[]\n\t    const chainInfo: any = {}\n\t    chainResults.flat().forEach((el, index) => {\n", "      const isSymbol = index % 2 === 0\n\t      const tokenIndex = Math.floor(index / 2)\n\t      const tokenAddress = chainTokens[tokenIndex]\n\t      if (!chainInfo[tokenAddress])\n\t        chainInfo[tokenAddress] = {}\n\t      if (isSymbol)\n\t        chainInfo[tokenAddress].symbol = el.result as string\n\t      else\n\t        chainInfo[tokenAddress].decimals = el.result as number\n\t    })\n", "    // check and process gas token\n\t    if (tokens[chain]?.includes('')) {\n\t      chainInfo[''] = {\n\t        symbol: NETWORKS[chain].token,\n\t        decimals: 18,\n\t      }\n\t    }\n\t    return { [chain]: chainInfo }\n\t  })\n\t  const tokenInfo: Web3ChekerTokenInfo = Object.assign({}, ...erc20Results)\n", "  // Fetching prices\n\t  const uniqueSymbols = new Set<string>()\n\t  for (const chain of Object.values(tokenInfo)) {\n\t    for (const token of Object.values(chain))\n\t      uniqueSymbols.add(token.symbol)\n\t  }\n\t  const priceRequests = Array.from(uniqueSymbols).map(async (symbol) => {\n\t    try {\n\t      const response = await got(`https://min-api.cryptocompare.com/data/price?fsym=${symbol}&tsyms=USDT`).json<{ USDT: number }>()\n\t      return { [symbol]: response.USDT }\n", "    }\n\t    catch (error: any) {\n\t      console.error(`Failed to fetch price for ${symbol}: ${error.message}`)\n\t      return { [symbol]: 0 }\n\t    }\n\t  })\n\t  const prices = Object.assign({}, ...(await Promise.all(priceRequests)))\n\t  // Adding prices to token info\n\t  for (const chain of Object.keys(tokenInfo) as Chains[]) {\n\t    for (const token of Object.keys(tokenInfo[chain]!))\n", "      tokenInfo[chain]![token].price = prices[tokenInfo![chain]![token].symbol] || 0\n\t  }\n\t  return tokenInfo\n\t}\n\tasync function getBalances(tokens: Web3CheckerTokens) {\n\t  const chains = Object.keys(tokens) as Chains[]\n\t  const clients = chains.map(chain => getPublicClient({ network: chain }))\n\t  const balanceParams = {\n\t    abi: ERC20_ABI,\n\t    functionName: 'balanceOf',\n", "  }\n\t  const erc20Requests = clients.map(async (client, index) => {\n\t    const chain = chains[index]\n\t    const chainTokens = tokens[chain]?.filter(Boolean) as Address[]\n\t    const contracts = WALLETS.map((wallet) => {\n\t      return chainTokens.map((token) => {\n\t        return {\n\t          address: token,\n\t          args: [getEvmWallet(wallet)],\n\t          ...balanceParams,\n", "        }\n\t      })\n\t    }).flat()\n\t    return await client.multicall({\n\t      contracts,\n\t    })\n\t  })\n\t  const erc20Results = (await Promise.all(erc20Requests)).flatMap((result) => {\n\t    return result.flat().map(el => el.result as bigint)\n\t  })\n", "  const gasRequests = Object.entries(tokens).map(async ([chain, tokens]) => {\n\t    if (tokens.includes('')) {\n\t      const client = getPublicClient({ network: chain as Chains })\n\t      const balances = await Promise.all(\n\t        WALLETS.map(async (wallet) => {\n\t          return await client.getBalance({ address: getEvmWallet(wallet) })\n\t        }),\n\t      )\n\t      return balances.flat()\n\t    }\n", "  }).filter(Boolean)\n\t  const gasResults = await (await Promise.all(gasRequests as Promise<bigint[]>[])).flat()\n\t  return [...erc20Results, ...gasResults]\n\t}\n\tfunction formatResults(walletBalances: bigint[][], wallets: Hex[], tokens: Web3CheckerTokens) {\n\t  const finalBalances: Web3CheckerTokensResult = {}\n\t  wallets.forEach((privateKey, walletIndex) => {\n\t    const wallet = getEvmWallet(privateKey)\n\t    const walletBalance = walletBalances[walletIndex]\n\t    let balanceIndex = 0\n", "    for (const chain of Object.keys(tokens) as Chains[]) {\n\t      if (!finalBalances[wallet])\n\t        finalBalances[wallet] = {}\n\t      const chainTokens = tokens[chain]\n\t      if (chainTokens) {\n\t        if (!finalBalances[wallet][chain])\n\t          finalBalances[wallet][chain] = {}\n\t        for (const token of chainTokens) {\n\t          if (token) { // if not gas token\n\t            finalBalances![wallet]![chain]![token] = walletBalance[balanceIndex++]\n", "          }\n\t        }\n\t      }\n\t    }\n\t    for (const chain of Object.keys(tokens) as Chains[]) {\n\t      if (!finalBalances[wallet])\n\t        finalBalances[wallet] = {}\n\t      const chainTokens = tokens[chain]\n\t      if (chainTokens) {\n\t        if (!finalBalances[wallet][chain])\n", "          finalBalances[wallet][chain] = {}\n\t        if (chainTokens.includes(''))\n\t          finalBalances![wallet]![chain]![''] = walletBalance[balanceIndex++]\n\t      }\n\t    }\n\t  })\n\t  return finalBalances\n\t}\n\tfunction printBalancesTable(formattedBalances: Web3CheckerTokensResult, tokens: Web3CheckerTokens, tokenInfo: Web3ChekerTokenInfo) {\n\t  let csvData = 'number,wallet,'\n", "  const chainsList: Chains[] = []\n\t  const totalBalances: { [chain: string]: { [token: string]: bigint } } = {}\n\t  for (const chain of Object.keys(tokens) as Chains[]) {\n\t    chainsList.push(chain)\n\t    for (const token of tokens[chain]!) {\n\t      csvData += `${tokenInfo[chain][token].symbol}-${chain},`\n\t      totalBalances[chain] = totalBalances[chain] || {}\n\t      totalBalances[chain][token] = BigInt(0) // Initialize total balance\n\t    }\n\t  }\n", "  csvData = csvData.slice(0, -1) // Remove trailing comma\n\t  csvData += '\\n'\n\t  // Add wallet balances\n\t  let walletNumber = 1\n\t  for (const wallet of Object.keys(formattedBalances)) {\n\t    // let shortAddress = wallet.substring(0, 6) + '...' + wallet.substring(address.length - 4);\n\t    const formattedWallet = `${wallet.substring(0, 6)}...${wallet.substring(wallet.length - 4)}`\n\t    csvData += `${walletNumber++},${formattedWallet},`\n\t    for (const chain of chainsList) {\n\t      for (const token of tokens[chain]!) {\n", "        const balance = formattedBalances[wallet]![chain]![token]\n\t        const decimals = tokenInfo[chain][token].decimals\n\t        const readableBalance = formatUnits(balance, decimals)\n\t        csvData += `${parseFloat(readableBalance).toFixed(4)},`\n\t        totalBalances[chain][token] += balance\n\t      }\n\t    }\n\t    csvData = csvData.slice(0, -1) // Remove trailing comma\n\t    csvData += '\\n'\n\t  }\n", "  // Add total balances\n\t  csvData += ',TOTAL,'\n\t  let totalValueUSD = 0\n\t  const totalValuesPerTokenUSD: { [token: string]: number } = {}\n\t  for (const chain of chainsList) {\n\t    for (const token of tokens[chain]!) {\n\t      const totalBalance = totalBalances[chain][token]\n\t      const decimals = tokenInfo[chain][token].decimals\n\t      const price = tokenInfo[chain][token].price\n\t      const readableBalance = formatUnits(totalBalance, decimals)\n", "      csvData += `${parseFloat(readableBalance).toFixed(4)},`\n\t      const valueUSD = Number(readableBalance) * price!\n\t      totalValueUSD += valueUSD\n\t      const tokenSymbolWithChain = `${tokenInfo[chain][token].symbol}-${chain}`\n\t      totalValuesPerTokenUSD[tokenSymbolWithChain] = (totalValuesPerTokenUSD[tokenSymbolWithChain] || 0) + valueUSD\n\t    }\n\t  }\n\t  csvData = csvData.slice(0, -1) // Remove trailing comma\n\t  csvData += '\\n'\n\t  // Add total value in USD\n", "  csvData += `TOTAL_VALUE:,${totalValueUSD.toFixed(2)} $,`\n\t  for (const chain of chainsList) {\n\t    for (const token of tokens[chain]!) {\n\t      const tokenValueUSD = totalValuesPerTokenUSD[`${tokenInfo[chain][token].symbol}-${chain}`]\n\t      csvData += `${tokenValueUSD.toFixed(2)} $,`\n\t    }\n\t  }\n\t  csvData = csvData.slice(0, -1) // Remove trailing comma\n\t  csvData += '\\n'\n\t  // Convert CSV data to table format\n", "  const lines = csvData.split('\\n')\n\t  const headers = lines[0].split(',')\n\t  const tableData = lines.slice(1, -1).map(line => line.split(',')) // exclude the last line since it could be empty\n\t  // Transpose the table data\n\t  const transposedData = headers.map((header, i) => [header, ...tableData.map(row => row[i])])\n\t  // Create a new table and push the transposed data into the table\n\t  const table = new Table()\n\t  transposedData.forEach(row => table.push(row))\n\t  // Print the table to the console\n\t  console.log(table.toString())\n", "  // Write data to CSV file\n\t  const directory = dirname(fileURLToPath(import.meta.url))\n\t  const path = join(directory, `../../results/${ONCHAIN_BALANCES_PARAMETERS.fileName}.csv`)\n\t  const csvStream = createWriteStream(path)\n\t  csvStream.write(csvData)\n\t  csvStream.end()\n\t}\n\tasync function main() {\n\t  const { tokens } = ONCHAIN_BALANCES_PARAMETERS\n\t  const allBalances = await getBalances(tokens)\n", "  const walletBalances = splitArray(allBalances, WALLETS.length)\n\t  const formattedBalances = formatResults(walletBalances, WALLETS, tokens)\n\t  const tokenInfo = await getTokenInfo(tokens)\n\t  printBalancesTable(formattedBalances, tokens, tokenInfo)\n\t}\n\tmain()\n"]}
