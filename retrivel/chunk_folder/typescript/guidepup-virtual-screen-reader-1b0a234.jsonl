{"filename": "test/setupTests.ts", "chunked_list": ["import \"@testing-library/jest-dom\";\n"]}
{"filename": "test/utils.ts", "chunked_list": ["export function setupBasicPage() {\n\t  document.body.innerHTML = `\n\t  <nav>Nav Text</nav>\n\t  <section>\n\t    <h1>Section Heading 1</h1>\n\t    <p>Section Text</p>\n\t    <article>\n\t      <header>\n\t        <h1>Article Header Heading 1</h1>\n\t        <p>Article Header Text</p>\n", "      </header>\n\t      <p>Article Text</p>\n\t    </article> \n\t  </section>\n\t  <footer>Footer</footer>\n\t  `;\n\t}\n"]}
{"filename": "test/int/ariaActiveDescendantCombobox.int.test.ts", "chunked_list": ["import { setupComboboxWithListAutocomplete } from \"./comboboxWithListAutocomplete\";\n\timport { virtual } from \"../../src\";\n\tdescribe(\"Aria Active Descendant\", () => {\n\t  let teardown;\n\t  beforeEach(() => {\n\t    teardown = setupComboboxWithListAutocomplete();\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n", "    teardown();\n\t  });\n\t  it(\"should handle an editable combobox with list autocomplete\", async () => {\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.type(\"nebr\");\n\t    await virtual.press(\"ArrowDown\");\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n", "      \"State\",\n\t      \"combobox, State, autocomplete in list, not expanded, has popup listbox, 1 control\",\n\t      \"combobox, State, nebr, autocomplete in list, expanded, has popup listbox, 1 control\",\n\t      \"combobox, State, nebr, active descendant Nebraska, autocomplete in list, expanded, has popup listbox, 1 control\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/moveToRole.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tconst quickNavigationRoles = [\n\t  \"banner\",\n\t  \"complementary\",\n\t  \"contentinfo\",\n\t  \"figure\",\n\t  \"form\",\n\t  \"main\",\n\t  \"navigation\",\n\t  \"region\",\n", "  \"search\",\n\t];\n\tconst quickNavigationRolesWithLandmark = [...quickNavigationRoles, \"landmark\"];\n\tdescribe(\"Move To Role\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  describe(\"moveToNextRole\", () => {\n\t    describe(\"when there are matching roles in the container\", () => {\n", "      beforeEach(async () => {\n\t        document.body.innerHTML = quickNavigationRoles\n\t          .map(\n\t            (role) =>\n\t              `<div role=\"${role}\" aria-label=\"Accessible name\">Node with role: ${role}</div>`\n\t          )\n\t          .join(\"\");\n\t        await virtual.start({ container: document.body });\n\t      });\n\t      it.each(quickNavigationRoles)(\n", "        \"should let you navigate to the next %s\",\n\t        async (role) => {\n\t          await virtual.perform(\n\t            virtual.commands[\n\t              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t              `moveToNext${role.at(0)!.toUpperCase()}${role.slice(1)}`\n\t            ]\n\t          );\n\t          await virtual.next();\n\t          await virtual.next();\n", "          expect(await virtual.spokenPhraseLog()).toEqual([\n\t            \"document\",\n\t            `${role}, Accessible name`,\n\t            `Node with role: ${role}`,\n\t            `end of ${role}, Accessible name`,\n\t          ]);\n\t        }\n\t      );\n\t    });\n\t    describe(\"when there are no matching roles in the container\", () => {\n", "      beforeEach(async () => {\n\t        document.body.innerHTML = \"\";\n\t        await virtual.start({ container: document.body });\n\t      });\n\t      it.each(quickNavigationRoles)(\n\t        \"should gracefully handle being asked to move to the next %s\",\n\t        async (role) => {\n\t          await virtual.perform(\n\t            virtual.commands[\n\t              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n", "              `moveToNext${role.at(0)!.toUpperCase()}${role.slice(1)}`\n\t            ]\n\t          );\n\t          expect(await virtual.spokenPhraseLog()).toEqual([\"document\"]);\n\t        }\n\t      );\n\t    });\n\t  });\n\t  describe(\"moveToPreviousRole\", () => {\n\t    describe(\"when there are matching roles in the container\", () => {\n", "      beforeEach(async () => {\n\t        document.body.innerHTML = quickNavigationRoles\n\t          .map(\n\t            (role) =>\n\t              `<div role=\"${role}\" aria-label=\"Accessible name\">Node with role: ${role}</div>`\n\t          )\n\t          .join(\"\");\n\t        await virtual.start({ container: document.body });\n\t      });\n\t      it.each(quickNavigationRoles)(\n", "        \"should let you navigate to the previous %s\",\n\t        async (role) => {\n\t          await virtual.perform(\n\t            virtual.commands[\n\t              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t              `moveToPrevious${role.at(0)!.toUpperCase()}${role.slice(1)}`\n\t            ]\n\t          );\n\t          await virtual.next();\n\t          await virtual.next();\n", "          expect(await virtual.spokenPhraseLog()).toEqual([\n\t            \"document\",\n\t            `${role}, Accessible name`,\n\t            `Node with role: ${role}`,\n\t            `end of ${role}, Accessible name`,\n\t          ]);\n\t        }\n\t      );\n\t    });\n\t    describe(\"when there are no matching roles in the container\", () => {\n", "      beforeEach(async () => {\n\t        document.body.innerHTML = \"\";\n\t        await virtual.start({ container: document.body });\n\t      });\n\t      it.each(quickNavigationRoles)(\n\t        \"should gracefully handle being asked to move to the previous %s\",\n\t        async (role) => {\n\t          await virtual.perform(\n\t            virtual.commands[\n\t              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n", "              `moveToPrevious${role.at(0)!.toUpperCase()}${role.slice(1)}`\n\t            ]\n\t          );\n\t          expect(await virtual.spokenPhraseLog()).toEqual([\"document\"]);\n\t        }\n\t      );\n\t    });\n\t  });\n\t  describe(\"landmark\", () => {\n\t    describe(\"when there are matching roles in the container\", () => {\n", "      beforeEach(async () => {\n\t        document.body.innerHTML = quickNavigationRolesWithLandmark\n\t          .map(\n\t            (role) =>\n\t              `<div role=\"${role}\" aria-label=\"Accessible name\">Node with role: ${role}</div>`\n\t          )\n\t          .join(\"\");\n\t        await virtual.start({ container: document.body });\n\t      });\n\t      it(\"should let you navigate to the next landmark\", async () => {\n", "        await Promise.all(\n\t          quickNavigationRoles.map(() =>\n\t            virtual.perform(virtual.commands.moveToNextLandmark)\n\t          )\n\t        );\n\t        expect(await virtual.spokenPhraseLog()).toEqual([\n\t          \"document\",\n\t          ...quickNavigationRoles.map((role) => `${role}, Accessible name`),\n\t        ]);\n\t      });\n", "      it(\"should let you navigate to the previous landmark\", async () => {\n\t        await Promise.all(\n\t          quickNavigationRoles.map(() =>\n\t            virtual.perform(virtual.commands.moveToPreviousLandmark)\n\t          )\n\t        );\n\t        expect(await virtual.spokenPhraseLog()).toEqual([\n\t          \"document\",\n\t          ...quickNavigationRoles\n\t            .slice()\n", "            .reverse()\n\t            .map((role) => `${role}, Accessible name`),\n\t        ]);\n\t      });\n\t    });\n\t    describe(\"when there are no matching roles in the container\", () => {\n\t      beforeEach(async () => {\n\t        document.body.innerHTML = \"\";\n\t        await virtual.start({ container: document.body });\n\t      });\n", "      it(\"should gracefully handle being asked to move to the next landmark\", async () => {\n\t        await virtual.perform(virtual.commands.moveToNextLandmark);\n\t        expect(await virtual.spokenPhraseLog()).toEqual([\"document\"]);\n\t      });\n\t      it(\"should gracefully handle being asked to move to the previous landmark\", async () => {\n\t        await virtual.perform(virtual.commands.moveToPreviousLandmark);\n\t        expect(await virtual.spokenPhraseLog()).toEqual([\"document\"]);\n\t      });\n\t    });\n\t  });\n", "});\n"]}
{"filename": "test/int/press.int.test.ts", "chunked_list": ["import { getByRole } from \"@testing-library/dom\";\n\timport { virtual } from \"../../src\";\n\tfunction setupInputPage() {\n\t  document.body.innerHTML = `\n\t  <label for=\"input\">Input Some Text</label>\n\t  <input type=\"text\" id=\"input\" value=\"\" />\n\t  <div id=\"hidden\" style=\"display: none;\">Hidden</div>\n\t  `;\n\t}\n\tdescribe(\"press\", () => {\n", "  beforeEach(() => {\n\t    setupInputPage();\n\t  });\n\t  it(\"should press keys on the active element\", async () => {\n\t    const container = document.body;\n\t    await virtual.start({ container });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.itemText()).toEqual(\"Input Some Text\");\n\t    await virtual.press(\"Shift+a+b+c\");\n", "    // TODO: FAIL: Testing Library user-event doesn't support modification yet, this should be \"ABC\"\n\t    expect(getByRole(container, \"textbox\")).toHaveValue(\"abc\");\n\t    expect(await virtual.itemText()).toEqual(\"Input Some Text, abc\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle requests to press on hidden container gracefully\", async () => {\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t    const container = document.querySelector(\"#hidden\")! as HTMLElement;\n\t    await virtual.start({ container });\n\t    await virtual.press(\"Shift+a+b+c\");\n", "    expect(await virtual.itemTextLog()).toEqual([]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle requests to press on a non-element gracefully\", async () => {\n\t    const container = document.createTextNode(\"text node\");\n\t    await virtual.start({ container });\n\t    await virtual.press(\"Shift+a+b+c\");\n\t    expect(await virtual.itemTextLog()).toEqual([\"text node\"]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\"text node\"]);\n", "    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/implicitAriaStates.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Implicit Aria States\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should announce implicit aria states as labels\", async () => {\n\t    document.body.innerHTML = `\n\t    <div role=\"tab\">A Tab</div>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"tab, A Tab, not selected\");\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/containerHidden.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Container Hidden\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"container\" style=\"display: none;\">This content is not announced</div>\n\t    `;\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t    await virtual.start({ container: document.querySelector(\"#container\")! });\n\t  });\n\t  afterEach(async () => {\n", "    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should not announce anything if the container is itself hidden from screen readers\", async () => {\n\t    expect(await virtual.itemTextLog()).toEqual([]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\t  });\n\t  it(\"should handle requests to move next and previous gracefully if the container is itself hidden from screen readers\", async () => {\n\t    await virtual.next();\n\t    await virtual.next();\n", "    await virtual.previous();\n\t    await virtual.previous();\n\t    expect(await virtual.itemTextLog()).toEqual([]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\t  });\n\t});\n"]}
{"filename": "test/int/jumpToControlledElement.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"jumpToControlledElement\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should jump to a controlled element\", async () => {\n\t    document.body.innerHTML = `\n\t    <button id=\"target\" aria-controls=\"controls-target\">Target</button>\n\t    <div>content 1</div>\n", "    <ul id=\"controls-target\">\n\t      <li>Item 1</li>\n\t      <li>Item 2</li>\n\t    </ul>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToControlledElement);\n\t    await virtual.next();\n\t    await virtual.next();\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"button, Target, 1 control\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"Item 1\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should jump to the second controlled element\", async () => {\n", "    document.body.innerHTML = `\n\t    <button id=\"target\" aria-controls=\"controls-target1 controls-target2\">Target</button>\n\t    <div>content 1</div>\n\t    <ul id=\"controls-target1\">\n\t      <li>Item 1</li>\n\t      <li>Item 2</li>\n\t    </ul>\n\t    <ul id=\"controls-target2\">\n\t      <li>Item 3</li>\n\t      <li>Item 4</li>\n", "    </ul>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToControlledElement, {\n\t      index: 1,\n\t    });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n", "      \"document\",\n\t      \"button, Target, 2 controls\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"Item 3\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should jump to a controlled presentation element\", async () => {\n\t    document.body.innerHTML = `\n", "    <button id=\"target\" aria-controls=\"controls-target\">Target</button>\n\t    <div>content 1</div>\n\t    <div id=\"controls-target\">content 2</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToControlledElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"button, Target, 1 control\",\n", "      \"content 2\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should jump to a second controlled presentation element\", async () => {\n\t    document.body.innerHTML = `\n\t    <button id=\"target\" aria-controls=\"controls-target1 controls-target2\">Target</button>\n\t    <div>content 1</div>\n\t    <div id=\"controls-target1\">content 2</div>\n\t    <div id=\"controls-target2\">content 3</div>\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToControlledElement, {\n\t      index: 1,\n\t    });\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"button, Target, 2 controls\",\n\t      \"content 3\",\n", "    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle a non-element container gracefully\", async () => {\n\t    const container = document.createTextNode(\"text node\");\n\t    await virtual.start({ container });\n\t    await virtual.perform(virtual.commands.jumpToControlledElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\"text node\"]);\n\t    await virtual.stop();\n\t  });\n", "  it(\"should handle a hidden container gracefully\", async () => {\n\t    const container = document.createElement(\"div\");\n\t    container.setAttribute(\"aria-hidden\", \"true\");\n\t    await virtual.start({ container });\n\t    await virtual.perform(virtual.commands.jumpToControlledElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should ignore the command on a non-element node\", async () => {\n\t    document.body.innerHTML = `Hello World`;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToControlledElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Hello World\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should ignore the command on an element with no aria-controls\", async () => {\n", "    document.body.innerHTML = `\n\t    <button id=\"target\">Target</button>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToControlledElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"button, Target\",\n\t    ]);\n", "    await virtual.stop();\n\t  });\n\t  it(\"should ignore the command on an element with an invalid aria-controls\", async () => {\n\t    document.body.innerHTML = `\n\t    <button id=\"target\" aria-controls=\"missing-element\">Target</button>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToControlledElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n", "      \"document\",\n\t      \"button, Target\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should ignore the command on an element with an aria-controls pointing to a hidden element\", async () => {\n\t    document.body.innerHTML = `\n\t    <button id=\"target\" aria-controls=\"hidden-element\">Target</button>\n\t    <div id=\"hidden-element\" aria-hidden=\"true\">Hidden</div>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToControlledElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"button, Target, 1 control\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/ariaReadonly.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Read only Attribute State\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should announce that a button with an aria-readonly attribute set to true is 'read only'\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Email Address *</div>\n\t    <div\n", "      role=\"textbox\"\n\t      aria-labelledby=\"label\"\n\t      aria-readonly=\"true\"\n\t      id=\"email1\"></div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Email Address *, read only\"\n", "    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce that a button with an aria-readonly attribute set to false is 'not read only'\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Email Address *</div>\n\t    <div\n\t      role=\"textbox\"\n\t      aria-labelledby=\"label\"\n\t      aria-readonly=\"false\"\n", "      id=\"email1\"></div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Email Address *, not read only\"\n\t    );\n\t    await virtual.stop();\n\t  });\n", "  it(\"should announce that a button with a readonly attribute is 'read only'\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Email Address *</div>\n\t    <textarea\n\t      aria-labelledby=\"label\"\n\t      readonly\n\t      id=\"email1\"></textarea>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n", "    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Email Address *, read only\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce that a button with a readonly attribute set to true is 'read only'\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Email Address *</div>\n\t    <textarea\n", "      aria-labelledby=\"label\"\n\t      readonly=\"true\"\n\t      id=\"email1\"></textarea>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Email Address *, read only\"\n\t    );\n", "    await virtual.stop();\n\t  });\n\t  it(\"should announce that a button with a readonly attribute set to false is 'not read only'\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Email Address *</div>\n\t    <textarea\n\t      aria-labelledby=\"label\"\n\t      readonly=\"false\"\n\t      id=\"email1\"></textarea>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Email Address *, not read only\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce that a button with a contenteditable attribute is 'not read only'\", async () => {\n\t    document.body.innerHTML = `\n", "    <div id=\"label\">Email Address *</div>\n\t    <textarea\n\t      aria-labelledby=\"label\"\n\t      contenteditable\n\t      id=\"email1\"></textarea>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n", "      \"textbox, Email Address *, not read only\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce that a button with a contenteditable attribute set to true is 'not read only'\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Email Address *</div>\n\t    <textarea\n\t      aria-labelledby=\"label\"\n\t      contenteditable=\"true\"\n", "      id=\"email1\"></textarea>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Email Address *, not read only\"\n\t    );\n\t    await virtual.stop();\n\t  });\n", "  it(\"should announce that a button with a contenteditable attribute set to false is 'read only'\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Email Address *</div>\n\t    <textarea\n\t      aria-labelledby=\"label\"\n\t      contenteditable=\"false\"\n\t      id=\"email1\"></textarea>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n", "    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Email Address *, read only\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should prefer contenteditable over aria-readonly\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Email Address *</div>\n\t    <textarea\n", "      aria-labelledby=\"label\"\n\t      contenteditable=\"true\"\n\t      aria-readonly=\"true\"\n\t      id=\"email1\"></textarea>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Email Address *, not read only\"\n", "    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should prefer readonly over aria-readonly\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Email Address *</div>\n\t    <textarea\n\t      aria-labelledby=\"label\"\n\t      readonly=\"true\"\n\t      aria-readonly=\"false\"\n", "      id=\"email1\"></textarea>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Email Address *, read only\"\n\t    );\n\t    await virtual.stop();\n\t  });\n", "  it(\"should prefer readonly over contenteditable\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Email Address *</div>\n\t    <textarea\n\t      aria-labelledby=\"label\"\n\t      readonly=\"true\"\n\t      contenteditable=\"true\"\n\t      id=\"email1\"></textarea>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Email Address *, read only\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/click.int.test.ts", "chunked_list": ["import { getByText, queryByText } from \"@testing-library/dom\";\n\timport { virtual } from \"../../src\";\n\tfunction setupButtonPage() {\n\t  document.body.innerHTML = `\n\t  <p id=\"status\">Not Clicked</p>\n\t  <div id=\"hidden\" style=\"display: none;\">Hidden</div>\n\t  `;\n\t  const button = document.createElement(\"button\");\n\t  button.addEventListener(\"click\", function (event) {\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n", "    document.getElementById(\n\t      \"status\"\n\t    )!.innerHTML = `Clicked ${event.detail} Time(s)`;\n\t  });\n\t  button.innerHTML = \"Click Me\";\n\t  document.body.appendChild(button);\n\t  document.body.addEventListener(\"contextmenu\", () => {\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t    document.getElementById(\"status\")!.innerHTML = `Right Clicked`;\n\t  });\n", "}\n\tdescribe(\"click\", () => {\n\t  beforeEach(() => {\n\t    setupButtonPage();\n\t  });\n\t  it(\"should click\", async () => {\n\t    const container = document.body;\n\t    await virtual.start({ container });\n\t    expect(getByText(container, \"Not Clicked\")).toBeInTheDocument();\n\t    while ((await virtual.itemText()) !== \"Click Me\") {\n", "      await virtual.next();\n\t    }\n\t    await virtual.click();\n\t    expect(queryByText(container, \"Not Clicked\")).not.toBeInTheDocument();\n\t    expect(getByText(container, \"Clicked 1 Time(s)\")).toBeInTheDocument();\n\t    await virtual.previous();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"Clicked 1 Time(s)\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should double click\", async () => {\n", "    const container = document.body;\n\t    await virtual.start({ container });\n\t    expect(getByText(container, \"Not Clicked\")).toBeInTheDocument();\n\t    while ((await virtual.itemText()) !== \"Click Me\") {\n\t      await virtual.next();\n\t    }\n\t    await virtual.click({ clickCount: 2 });\n\t    expect(queryByText(container, \"Not Clicked\")).not.toBeInTheDocument();\n\t    expect(getByText(container, \"Clicked 2 Time(s)\")).toBeInTheDocument();\n\t    await virtual.previous();\n", "    expect(await virtual.lastSpokenPhrase()).toEqual(\"Clicked 2 Time(s)\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should triple click\", async () => {\n\t    const container = document.body;\n\t    await virtual.start({ container });\n\t    expect(getByText(container, \"Not Clicked\")).toBeInTheDocument();\n\t    while ((await virtual.itemText()) !== \"Click Me\") {\n\t      await virtual.next();\n\t    }\n", "    await virtual.click({ clickCount: 3 });\n\t    expect(queryByText(container, \"Not Clicked\")).not.toBeInTheDocument();\n\t    expect(getByText(container, \"Clicked 3 Time(s)\")).toBeInTheDocument();\n\t    await virtual.previous();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"Clicked 3 Time(s)\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should right click\", async () => {\n\t    const container = document.body;\n\t    await virtual.start({ container });\n", "    expect(getByText(container, \"Not Clicked\")).toBeInTheDocument();\n\t    while ((await virtual.itemText()) !== \"Click Me\") {\n\t      await virtual.next();\n\t    }\n\t    await virtual.click({ button: \"right\" });\n\t    expect(queryByText(container, \"Not Clicked\")).not.toBeInTheDocument();\n\t    expect(getByText(container, \"Right Clicked\")).toBeInTheDocument();\n\t    await virtual.previous();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"Right Clicked\");\n\t    await virtual.stop();\n", "  });\n\t  it(\"should handle requests to click on hidden container gracefully\", async () => {\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t    const container = document.querySelector(\"#hidden\")! as HTMLElement;\n\t    await virtual.start({ container });\n\t    await virtual.click();\n\t    expect(await virtual.itemTextLog()).toEqual([]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\t    await virtual.stop();\n\t  });\n", "});\n"]}
{"filename": "test/int/invalidStart.test.ts", "chunked_list": ["import {\n\t  ERR_VIRTUAL_MISSING_CONTAINER,\n\t  ERR_VIRTUAL_NOT_STARTED,\n\t} from \"../../src/errors\";\n\timport { virtual } from \"../../src\";\n\tdescribe(\"Invalid Start\", () => {\n\t  beforeEach(() => {\n\t    document.body.innerHTML = `\n\t    <div>Some Text</div>\n\t    `;\n", "  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should throw if started without a configuration object\", async () => {\n\t    await expect(async () => await virtual.start()).rejects.toThrowError(\n\t      ERR_VIRTUAL_MISSING_CONTAINER\n\t    );\n\t  });\n", "  it(\"should throw if started without a container in the configuration object\", async () => {\n\t    await expect(\n\t      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t      async () => await virtual.start({} as any)\n\t    ).rejects.toThrowError(ERR_VIRTUAL_MISSING_CONTAINER);\n\t  });\n\t  it(\"should throw if use a method without starting first\", async () => {\n\t    await expect(async () => await virtual.next()).rejects.toThrowError(\n\t      ERR_VIRTUAL_NOT_STARTED\n\t    );\n", "  });\n\t});\n"]}
{"filename": "test/int/act.int.test.ts", "chunked_list": ["import { getByText, queryByText } from \"@testing-library/dom\";\n\timport { virtual } from \"../../src\";\n\tfunction setupButtonPage() {\n\t  document.body.innerHTML = `\n\t  <p id=\"status\">Not Clicked</p>\n\t  <div id=\"hidden\" style=\"display: none;\">Hidden</div>\n\t  `;\n\t  const button = document.createElement(\"button\");\n\t  button.addEventListener(\"click\", function (event) {\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n", "    document.getElementById(\n\t      \"status\"\n\t    )!.innerHTML = `Clicked ${event.detail} Time(s)`;\n\t  });\n\t  button.innerHTML = \"Click Me\";\n\t  document.body.appendChild(button);\n\t}\n\tdescribe(\"act\", () => {\n\t  beforeEach(() => {\n\t    setupButtonPage();\n", "  });\n\t  it(\"should perform the default action\", async () => {\n\t    const container = document.body;\n\t    await virtual.start({ container });\n\t    expect(getByText(container, \"Not Clicked\")).toBeInTheDocument();\n\t    while ((await virtual.itemText()) !== \"Click Me\") {\n\t      await virtual.next();\n\t    }\n\t    await virtual.act();\n\t    expect(queryByText(container, \"Not Clicked\")).not.toBeInTheDocument();\n", "    expect(getByText(container, \"Clicked 1 Time(s)\")).toBeInTheDocument();\n\t    await virtual.previous();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"Clicked 1 Time(s)\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle requests to perform the default action on hidden container gracefully\", async () => {\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t    const container = document.querySelector(\"#hidden\")! as HTMLElement;\n\t    await virtual.start({ container });\n\t    await virtual.act();\n", "    expect(await virtual.itemTextLog()).toEqual([]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/inheritedImplicitPresentational.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Inherited Implicit Presentational Role\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should treat children of presentation roles as presentation when there are no exceptions\", async () => {\n\t    document.body.innerHTML = `\n\t    <!-- 1. role=\"presentation\" negates the implicit 'heading' role semantics but does not affect the contents, including the nested hyperlink. -->\n\t    <h1 role=\"presentation\"> Sample Content <a href=\"...\">let's go!</a> </h1>\n", "    <!-- 2. A span has an implicit 'generic' role and no other attributes important to accessibility, so only its content is exposed, including the hyperlink. -->\n\t    <span> Sample Content <a href=\"...\">let's go!</a> </span>\n\t    <!-- 3. In the following code sample, the containing img and is appropriately labeled by the caption paragraph. In this example the img element can be marked as presentation because the role and the text alternatives are provided by the containing element. -->\n\t    <div role=\"img\" aria-labelledby=\"caption\">\n\t      <img src=\"example.png\" role=\"presentation\" alt=\"\">\n\t      <p id=\"caption\">A visible text caption labeling the image.</p>\n\t    </div>\n\t    <!-- 4. In the following code sample, because the anchor (HTML a element) is acting as the treeitem, the list item (HTML li element) is assigned an explicit WAI-ARIA role of presentation to override the user agent's implicit native semantics for list items. -->\n\t    <ul role=\"tree\">\n\t      <li role=\"presentation\">\n", "        <a role=\"treeitem\" aria-expanded=\"true\">An expanded tree node</a>\n\t      </li>\n\t    </ul>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.itemTextLog()).toEqual([\n\t      \"\",\n", "      \"Sample Content\",\n\t      \"let's go!\",\n\t      \"Sample Content\",\n\t      \"let's go!\",\n\t      \"A visible text caption labeling the image.\",\n\t      \"\",\n\t      \"An expanded tree node\",\n\t      \"\",\n\t      \"\",\n\t    ]);\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Sample Content\",\n\t      \"link, let's go!\",\n\t      \"Sample Content\",\n\t      \"link, let's go!\",\n\t      \"img, A visible text caption labeling the image.\",\n\t      \"tree, orientated vertically\",\n\t      \"treeitem, An expanded tree node, expanded, not selected\",\n\t      \"end of tree, orientated vertically\",\n", "      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle inherited implicit presentation role\", async () => {\n\t    document.body.innerHTML = `\n\t    <ul role=\"presentation\">\n\t      <li> Sample Content </li>\n\t      <li> More Sample Content </li>\n\t    </ul>\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Sample Content\",\n\t      \"More Sample Content\",\n\t      \"end of document\",\n", "    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle no implicit roles\", async () => {\n\t    document.body.innerHTML = `\n\t    <foo>\n\t      <foo> Sample Content </foo>\n\t      <foo> More Sample Content </foo>\n\t    </foo>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Sample Content\",\n\t      \"More Sample Content\",\n\t      \"end of document\",\n\t    ]);\n", "    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/edgeCaseContainer.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Edge Case Container\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should handle edge case containers such as comment nodes gracefully\", async () => {\n\t    document.body.innerHTML = `\n\t    <!-- HTML Comment -->\n\t    <div>Some Text</div>\n", "    `;\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    await virtual.start({ container: document.body.childNodes[0] as any });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.itemText()).toEqual(\"\");\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"\");\n\t    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\t    await virtual.stop();\n\t  });\n", "});\n"]}
{"filename": "test/int/noMutationObserver.int.test.ts", "chunked_list": ["(window.MutationObserver as unknown) = undefined;\n\t// eslint-disable-next-line @typescript-eslint/no-var-requires\n\tconst { virtual } = require(\"../../src\");\n\tdescribe(\"No Mutation Observer\", () => {\n\t  it(\"should handle DOM implementations that do not support Mutation Observer\", async () => {\n\t    document.body.innerHTML = `\n\t    <div>Some Text</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n", "    expect(await virtual.itemText()).toEqual(\"Some Text\");\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"Some Text\");\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t});\n"]}
{"filename": "test/int/jumpToDetailsElement.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"jumpToDetailsElement\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should jump to a details element\", async () => {\n\t    document.body.innerHTML = `\n\t    <button id=\"target\" aria-details=\"controls-target\">Target</button>\n\t    <div>content 1</div>\n", "    <ul id=\"controls-target\">\n\t      <li>Item 1</li>\n\t      <li>Item 2</li>\n\t    </ul>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\t    await virtual.next();\n\t    await virtual.next();\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"button, Target, linked details\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"Item 1\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should jump to a details presentation element\", async () => {\n", "    document.body.innerHTML = `\n\t    <button id=\"target\" aria-details=\"controls-target\">Target</button>\n\t    <div>content 1</div>\n\t    <div id=\"controls-target\">content 2</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n", "      \"button, Target, linked details\",\n\t      \"content 2\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle a non-element container gracefully\", async () => {\n\t    const container = document.createTextNode(\"text node\");\n\t    await virtual.start({ container });\n\t    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\"text node\"]);\n", "    await virtual.stop();\n\t  });\n\t  it(\"should handle a hidden container gracefully\", async () => {\n\t    const container = document.createElement(\"div\");\n\t    container.setAttribute(\"aria-hidden\", \"true\");\n\t    await virtual.start({ container });\n\t    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\t    await virtual.stop();\n\t  });\n", "  it(\"should ignore the command on a non-element node\", async () => {\n\t    document.body.innerHTML = `Hello World`;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Hello World\",\n\t    ]);\n\t    await virtual.stop();\n", "  });\n\t  it(\"should ignore the command on an element with no aria-details\", async () => {\n\t    document.body.innerHTML = `\n\t    <button id=\"target\">Target</button>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n", "      \"button, Target\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should ignore the command on an element with an invalid aria-details\", async () => {\n\t    document.body.innerHTML = `\n\t    <button id=\"target\" aria-details=\"missing-element\">Target</button>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n", "    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"button, Target\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should ignore the command on an element with an aria-details pointing to a hidden element\", async () => {\n\t    document.body.innerHTML = `\n\t    <button id=\"target\" aria-details=\"hidden-element\">Target</button>\n", "    <div id=\"hidden-element\" aria-hidden=\"true\">Hidden</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.perform(virtual.commands.jumpToDetailsElement);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"button, Target, linked details\",\n\t    ]);\n\t    await virtual.stop();\n", "  });\n\t});\n"]}
{"filename": "test/int/labelPriorityReplacement.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Label Priority Replacement\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should announce aria-valuetext in preference to aria-valuenow\", async () => {\n\t    document.body.innerHTML = `\n\t    <span id=\"element1\">Pandemic Size:</span>\n\t    <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuemin=\"1\" aria-valuemax=\"3\" aria-valuenow=\"1\" aria-valuetext=\"small\">\n", "      <svg width=\"300\" height=\"10\">\n\t        <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t        <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t      </svg>\n\t    </span>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n", "      \"progressbar, Pandemic Size:, current value small, max value 3, min value 1\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/allowedAccessibilityChildRoles.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Allowed Accessibility Child Roles\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should handle a direct DOM child\", async () => {\n\t    document.body.innerHTML = `\n\t    <div role=\"listbox\">\n\t      <div role=\"option\">option text</div>\n", "    </div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"listbox, orientated vertically\",\n\t      \"option, option text, not selected\",\n", "      \"end of listbox, orientated vertically\",\n\t      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle a DOM child with generics intervening\", async () => {\n\t    document.body.innerHTML = `\n\t    <div role=\"listbox\">\n\t      <div>\n\t        <div role=\"option\">option text</div>\n", "      </div>\n\t    </div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"listbox, orientated vertically\",\n", "      \"option, option text, not selected\",\n\t      \"end of listbox, orientated vertically\",\n\t      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle a direct aria-owns relationship\", async () => {\n\t    document.body.innerHTML = `\n\t    <div role=\"listbox\" aria-owns=\"id1\"></div>\n\t    <div role=\"option\" id=\"id1\">option text</div>\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"listbox, orientated vertically\",\n\t      \"option, option text, not selected\",\n\t      \"end of listbox, orientated vertically\",\n", "      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle an aria-owns relationship with generics intervening\", async () => {\n\t    document.body.innerHTML = `\n\t    <div role=\"listbox\" aria-owns=\"id1\"></div>\n\t    <div id=\"id1\">\n\t      <div>\n\t        <div role=\"option\">option text</div>\n", "      </div>\n\t    </div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"listbox, orientated vertically\",\n", "      \"option, option text, not selected\",\n\t      \"end of listbox, orientated vertically\",\n\t      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/disabled.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Disabled Attribute State\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should announce that a button with an aria-disabled attribute set to true is 'disabled'\", async () => {\n\t    document.body.innerHTML = `\n\t    <button aria-disabled=\"true\">Submit</button>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Submit, disabled\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce a button with an aria-disabled attribute set to false without any disabled state labelling\", async () => {\n\t    document.body.innerHTML = `\n\t    <button aria-disabled=\"false\">Submit</button>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"button, Submit, not disabled\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce that a button with a disabled attribute\", async () => {\n\t    document.body.innerHTML = `\n\t    <button disabled>Submit</button>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Submit, disabled\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce that a button with a disabled attribute set to true is 'disabled'\", async () => {\n\t    document.body.innerHTML = `\n\t    <button disabled=\"true\">Submit</button>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Submit, disabled\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce a button with a disabled attribute set to false without any disabled state labelling\", async () => {\n\t    document.body.innerHTML = `\n\t    <button disabled=\"false\">Submit</button>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n", "    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"button, Submit, not disabled\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce a button without an aria-disabled attribute without any disabled state labelling\", async () => {\n\t    document.body.innerHTML = `\n\t    <button>Submit</button>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Submit\");\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/checked.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Checked Attribute State\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should announce that a checkbox with a checked attribute is 'checked'\", async () => {\n\t    document.body.innerHTML = `\n\t    <fieldset>\n\t      <legend>Choose your monster's features:</legend>\n", "      <div>\n\t        <input type=\"checkbox\" id=\"scales\" name=\"scales\" checked>\n\t        <label for=\"scales\">Scales</label>\n\t      </div>\n\t      <div>\n\t        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n\t        <label for=\"horns\">Horns</label>\n\t      </div>\n\t    </fieldset>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Scales, checked\");\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Horns\");\n\t    await virtual.stop();\n\t  });\n", "  it(\"should announce that a checkbox with a checked attribute set to true is 'checked'\", async () => {\n\t    document.body.innerHTML = `\n\t    <fieldset>\n\t      <legend>Choose your monster's features:</legend>\n\t      <div>\n\t        <input type=\"checkbox\" id=\"scales\" name=\"scales\" checked=\"true\">\n\t        <label for=\"scales\">Scales</label>\n\t      </div>\n\t      <div>\n\t        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n", "        <label for=\"horns\">Horns</label>\n\t      </div>\n\t    </fieldset>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Scales, checked\");\n\t    await virtual.next();\n", "    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Horns\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce that a checkbox with a checked attribute set to false is 'not checked'\", async () => {\n\t    document.body.innerHTML = `\n\t    <fieldset>\n\t      <legend>Choose your monster's features:</legend>\n\t      <div>\n\t        <input type=\"checkbox\" id=\"scales\" name=\"scales\" checked=\"false\">\n", "        <label for=\"scales\">Scales</label>\n\t      </div>\n\t      <div>\n\t        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n\t        <label for=\"horns\">Horns</label>\n\t      </div>\n\t    </fieldset>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n", "    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"checkbox, Scales, not checked\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce that a checkbox with an aria-checked attribute set to true is 'checked'\", async () => {\n\t    document.body.innerHTML = `\n\t    <fieldset>\n", "      <legend>Choose your monster's features:</legend>\n\t      <div>\n\t        <input type=\"checkbox\" id=\"scales\" name=\"scales\" aria-checked=\"true\">\n\t        <label for=\"scales\">Scales</label>\n\t      </div>\n\t      <div>\n\t        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n\t        <label for=\"horns\">Horns</label>\n\t      </div>\n\t    </fieldset>\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Scales, checked\");\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Horns\");\n\t    await virtual.stop();\n", "  });\n\t  it(\"should announce that a checkbox with an aria-checked attribute set to false is 'not checked'\", async () => {\n\t    document.body.innerHTML = `\n\t    <fieldset>\n\t      <legend>Choose your monster's features:</legend>\n\t      <div>\n\t        <input type=\"checkbox\" id=\"scales\" name=\"scales\" aria-checked=\"false\">\n\t        <label for=\"scales\">Scales</label>\n\t      </div>\n\t      <div>\n", "        <input type=\"checkbox\" id=\"horns\" name=\"horns\">\n\t        <label for=\"horns\">Horns</label>\n\t      </div>\n\t    </fieldset>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n", "      \"checkbox, Scales, not checked\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle a checkbox with an aria-checked attribute set to mixed\", async () => {\n\t    // REF: https://www.w3.org/WAI/ARIA/apg/patterns/checkbox/examples/checkbox-mixed/\n\t    document.body.innerHTML = `\n\t    <fieldset class=\"checkbox-mixed\">\n\t      <legend>\n\t        Sandwich Condiments\n", "      </legend>\n\t      <div role=\"checkbox\"\n\t          class=\"group_checkbox\"\n\t          aria-checked=\"mixed\"\n\t          aria-controls=\"cond1 cond2 cond3 cond4\"\n\t          tabindex=\"0\">\n\t        All condiments\n\t      </div>\n\t      <ul class=\"checkboxes\">\n\t        <li>\n", "          <label>\n\t            <input type=\"checkbox\" id=\"cond1\">\n\t            Lettuce\n\t          </label>\n\t        </li>\n\t        <li>\n\t          <label>\n\t            <input type=\"checkbox\"\n\t                  id=\"cond2\"\n\t                  checked=\"\">\n", "            Tomato\n\t          </label>\n\t        </li>\n\t        <li>\n\t          <label>\n\t            <input type=\"checkbox\" id=\"cond3\">\n\t            Mustard\n\t          </label>\n\t        </li>\n\t        <li>\n", "          <label>\n\t            <input type=\"checkbox\" id=\"cond4\">\n\t            Sprouts\n\t          </label>\n\t        </li>\n\t      </ul>\n\t    </fieldset>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n", "    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"checkbox, All condiments, partially checked, 4 controls\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/detection.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Detection\", () => {\n\t  it(\"should return true for Virtual being a supported screen reader for the OS\", async () => {\n\t    expect(await virtual.detect()).toBeTruthy();\n\t  });\n\t  it(\"should return false for Virtual being the default screen reader for the OS\", async () => {\n\t    expect(await virtual.default()).toBeFalsy();\n\t  });\n\t});\n"]}
{"filename": "test/int/ariaDetails.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Aria Details\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should handle linked details\", async () => {\n\t    document.body.innerHTML = `\n\t    <img src=\"pythagorean.jpg\" alt=\"Pythagorean Theorem\" aria-details=\"det\">\n\t    <details id=\"det\">\n", "      <summary>Example</summary>\n\t      <p>\n\t        The Pythagorean Theorem is a relationship in Euclidean Geometry between the three sides of\n\t        a right triangle, where the square of the hypotenuse is the sum of the squares of the two\n\t        opposing sides.\n\t      </p>\n\t      <p>\n\t        The following drawing illustrates an application of the Pythagorean Theorem when used to\n\t        construct a skateboard ramp.\n\t      </p>\n", "      <object data=\"skatebd-ramp.svg\"  type=\"image/svg+xml\"></object>\n\t      <p>\n\t        In this example you will notice a skateboard with a base and vertical board whose width\n\t        is the width of the ramp. To compute how long the ramp must be, simply calculate the\n\t        base length, square it, sum it with the square of the height of the ramp, and take the\n\t        square root of the sum.\n\t      </p>\n\t    </details>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"img, Pythagorean Theorem, linked details\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should gracefully handle an invalid idRef\", async () => {\n\t    document.body.innerHTML = `\n\t    <img src=\"pythagorean.jpg\" alt=\"Pythagorean Theorem\" aria-details=\"det\">\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"img, Pythagorean Theorem\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/next.int.test.ts", "chunked_list": ["import { getByRole } from \"@testing-library/dom\";\n\timport { setupBasicPage } from \"../utils\";\n\timport { virtual } from \"../../src\";\n\tdescribe(\"next\", () => {\n\t  beforeEach(async () => {\n\t    setupBasicPage();\n\t    await virtual.start({ container: document.body });\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n", "    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should move through the next elements\", async () => {\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.itemTextLog()).toEqual([\n\t      \"\",\n\t      \"\",\n\t      \"Nav Text\",\n", "      \"\",\n\t      \"\",\n\t      \"Section Heading 1\",\n\t      \"Section Text\",\n\t      \"\",\n\t      \"\",\n\t      \"Article Header Heading 1\",\n\t      \"Article Header Text\",\n\t      \"\",\n\t      \"Article Text\",\n", "      \"\",\n\t      \"\",\n\t      \"\",\n\t      \"Footer\",\n\t      \"\",\n\t      \"\",\n\t    ]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"navigation\",\n", "      \"Nav Text\",\n\t      \"end of navigation\",\n\t      \"region\",\n\t      \"heading, Section Heading 1, level 1\",\n\t      \"Section Text\",\n\t      \"article\",\n\t      \"banner\",\n\t      \"heading, Article Header Heading 1, level 1\",\n\t      \"Article Header Text\",\n\t      \"end of banner\",\n", "      \"Article Text\",\n\t      \"end of article\",\n\t      \"end of region\",\n\t      \"contentinfo\",\n\t      \"Footer\",\n\t      \"end of contentinfo\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t  it(\"should handle the current node being removed from the DOM gracefully and set the active element back to the container\", async () => {\n", "    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"Nav Text\");\n\t    const currentElement = getByRole(document.body, \"navigation\");\n\t    document.body.removeChild(currentElement);\n\t    await virtual.next();\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"navigation\",\n\t      \"Nav Text\",\n", "      \"document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/int/ariaPlaceholder.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Placeholder Attribute Property\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should announce a non-empty aria-placeholder attribute on an input when there is no value\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n\t    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"\" aria-placeholder=\"Search...\"/>\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"textbox, Label, placeholder Search...\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should not announce an empty aria-placeholder attribute on an input when there is no value\", async () => {\n", "    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n\t    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"\" aria-placeholder=\"\"/>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label\");\n\t    await virtual.stop();\n\t  });\n", "  it(\"should announce an input value in preference to a non-empty aria-placeholder attribute\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n\t    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"a11y\" aria-placeholder=\"Search...\"/>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label, a11y\");\n\t    await virtual.stop();\n", "  });\n\t  it(\"should announce a non-empty placeholder attribute on an input when there is no value\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n\t    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"\" placeholder=\"Search...\"/>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n", "      \"textbox, Label, placeholder Search...\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should not announce an empty placeholder attribute on an input when there is no value\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n\t    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"\" placeholder=\"\"/>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce an input value in preference to a non-empty placeholder attribute\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n\t    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"a11y\" placeholder=\"Search...\"/>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label, a11y\");\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/previous.int.test.ts", "chunked_list": ["import { getByRole } from \"@testing-library/dom\";\n\timport { setupBasicPage } from \"../utils\";\n\timport { virtual } from \"../../src\";\n\tdescribe(\"previous\", () => {\n\t  beforeEach(async () => {\n\t    setupBasicPage();\n\t    await virtual.start({ container: document.body });\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n", "    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should move through previous elements\", async () => {\n\t    await virtual.previous();\n\t    while ((await virtual.lastSpokenPhrase()) !== \"document\") {\n\t      await virtual.previous();\n\t    }\n\t    expect(await virtual.itemTextLog()).toEqual([\n\t      \"\",\n\t      \"\",\n", "      \"\",\n\t      \"Footer\",\n\t      \"\",\n\t      \"\",\n\t      \"\",\n\t      \"Article Text\",\n\t      \"\",\n\t      \"Article Header Text\",\n\t      \"Article Header Heading 1\",\n\t      \"\",\n", "      \"\",\n\t      \"Section Text\",\n\t      \"Section Heading 1\",\n\t      \"\",\n\t      \"\",\n\t      \"Nav Text\",\n\t      \"\",\n\t      \"\",\n\t    ]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n", "      \"document\",\n\t      \"end of document\",\n\t      \"end of contentinfo\",\n\t      \"Footer\",\n\t      \"contentinfo\",\n\t      \"end of region\",\n\t      \"end of article\",\n\t      \"Article Text\",\n\t      \"end of banner\",\n\t      \"Article Header Text\",\n", "      \"heading, Article Header Heading 1, level 1\",\n\t      \"banner\",\n\t      \"article\",\n\t      \"Section Text\",\n\t      \"heading, Section Heading 1, level 1\",\n\t      \"region\",\n\t      \"end of navigation\",\n\t      \"Nav Text\",\n\t      \"navigation\",\n\t      \"document\",\n", "    ]);\n\t  });\n\t  it(\"should handle the current node being removed from the DOM gracefully and set the active element back to the container\", async () => {\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"Nav Text\");\n\t    const currentElement = getByRole(document.body, \"navigation\");\n\t    document.body.removeChild(currentElement);\n\t    await virtual.previous();\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n", "      \"document\",\n\t      \"navigation\",\n\t      \"Nav Text\",\n\t      \"document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/int/interact.int.test.ts", "chunked_list": ["import { setupBasicPage } from \"../utils\";\n\timport { virtual } from \"../../src\";\n\tdescribe(\"interact / stopInteracting\", () => {\n\t  beforeEach(() => {\n\t    setupBasicPage();\n\t  });\n\t  it(\"should not do anything\", async () => {\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.interact();\n", "    await virtual.next();\n\t    await virtual.stopInteracting();\n\t    await virtual.next();\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"navigation\",\n\t      \"Nav Text\",\n\t      \"end of navigation\",\n\t    ]);\n\t  });\n", "});\n"]}
{"filename": "test/int/accessibleValue.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Placeholder Attribute Property\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should announce a non-empty value on a text input\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n\t    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"a11y\"/>\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label, a11y\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should not announce an empty value on a text input\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n", "    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\" value=\"\"/>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should not announce a missing value on a text input\", async () => {\n\t    document.body.innerHTML = `\n", "    <div id=\"label\">Label</div>\n\t    <input type=\"text\" aria-labelledby=\"label\" id=\"search1\"/>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"textbox, Label\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should not announce a value on a checkbox input\", async () => {\n", "    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n\t    <input type=\"checkbox\" aria-labelledby=\"label\" id=\"check1\" value=\"forbidden\"/>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"checkbox, Label\");\n\t    await virtual.stop();\n\t  });\n", "  it(\"should not announce a value on a radio input\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n\t    <input type=\"radio\" aria-labelledby=\"label\" id=\"radio1\" value=\"forbidden\"/>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"radio, Label\");\n\t    await virtual.stop();\n", "  });\n\t  it(\"should not announce a value on a radio input\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"label\">Label</div>\n\t    <input type=\"radio\" aria-labelledby=\"label\" id=\"radio1\" value=\"forbidden\"/>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"radio, Label\");\n", "    await virtual.stop();\n\t  });\n\t  it(\"should announce the selected value in a select with options\", async () => {\n\t    document.body.innerHTML = `\n\t    <select>\n\t      <option value=\"first\">First Value</option>\n\t      <option value=\"second\" selected>Second Value</option>\n\t      <option value=\"third\">Third Value</option>\n\t    </select>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"combobox, second, not expanded, has popup listbox\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce the multiple selected values in a multi-select with options\", async () => {\n\t    document.body.innerHTML = `\n\t    <select multiple>\n", "      <option value=\"first\">First Value</option>\n\t      <option value=\"second\" selected>Second Value</option>\n\t      <option value=\"third\" selected>Third Value</option>\n\t    </select>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"listbox, second; third, orientated vertically\"\n\t    );\n", "    await virtual.stop();\n\t  });\n\t  it(\"should not announce empty selected values in a select with options\", async () => {\n\t    document.body.innerHTML = `\n\t    <select>\n\t      <option value=\"\" disabled selected>- Select some value - </option>\n\t      <option value=\"first\">First Value</option>\n\t      <option value=\"second\">Second Value</option>\n\t      <option value=\"third\">Third Value</option>\n\t    </select>\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"combobox, not expanded, has popup listbox\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce the value for a progress element\", async () => {\n\t    document.body.innerHTML = `\n", "    <label for=\"element1\">Loading:</label>\n\t    <progress id=\"element1\" max=\"100\" value=\"23\"></progress>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"progressbar, Loading:, 23, max value 100\"\n\t    );\n\t    await virtual.stop();\n", "  });\n\t  it(\"should not announce the value for a progress element which has an aria-valuenow\", async () => {\n\t    document.body.innerHTML = `\n\t    <label for=\"element1\">Loading:</label>\n\t    <progress id=\"element1\" max=\"100\" value=\"23\" aria-valuenow=\"24\"></progress>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n", "      \"progressbar, Loading:, max value 100, current value 24%\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t  it(\"should not announce the value for a progress element which has an aria-valuetext\", async () => {\n\t    document.body.innerHTML = `\n\t    <label for=\"element1\">Loading:</label>\n\t    <progress id=\"element1\" max=\"100\" value=\"23\" aria-valuetext=\"massive\"></progress>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"progressbar, Loading:, current value massive, max value 100\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/ariaActiveDescendantMenuButton1.int.test.ts", "chunked_list": ["import { setupActionsMenuButton } from \"./actionsMenuButton\";\n\timport { virtual } from \"../../src\";\n\tdescribe(\"Aria Active Descendant Menu Button\", () => {\n\t  let teardown;\n\t  beforeEach(() => {\n\t    teardown = setupActionsMenuButton();\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n", "    teardown();\n\t  });\n\t  it(\"should convey the referenced element as active - applied to the menu role\", async () => {\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.act();\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"button, Actions, has popup menu, 1 control\",\n\t      \"button, Actions, expanded, has popup menu, 1 control\",\n", "      \"menu, Actions, orientated vertically, active descendant Action 1\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/pressed.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Checked Attribute State\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should announce that a button with an aria-pressed attribute set to true is 'pressed'\", async () => {\n\t    document.body.innerHTML = `\n\t    <button aria-pressed=\"true\">Pause</button>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Pause, pressed\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce that a button with an aria-pressed attribute set to false is 'not pressed'\", async () => {\n\t    document.body.innerHTML = `\n\t    <button aria-pressed=\"false\">Pause</button>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Pause, not pressed\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce a button without an aria-pressed attribute without any pressed state labelling\", async () => {\n\t    document.body.innerHTML = `\n\t    <button>Pause</button>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n", "    expect(await virtual.lastSpokenPhrase()).toBe(\"button, Pause\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle a button with an aria-pressed attribute set to mixed\", async () => {\n\t    document.body.innerHTML = `\n\t    <fieldset class=\"button-mixed\">\n\t      <legend>\n\t        Power Plant Controls\n\t      </legend>\n\t      <div role=\"button\"\n", "          class=\"group_button\"\n\t          aria-pressed=\"mixed\"\n\t          aria-controls=\"cond1 cond2 cond3\"\n\t          tabindex=\"0\">\n\t        All systems\n\t      </div>\n\t      <ul class=\"buttons\">\n\t        <li>\n\t          <label>\n\t            <button id=\"cond1\">\n", "            Reactor\n\t          </label>\n\t        </li>\n\t        <li>\n\t          <label>\n\t            <button\n\t                  id=\"cond2\"\n\t                  aria-pressed=\"\">\n\t            Coolant\n\t          </label>\n", "        </li>\n\t        <li>\n\t          <label>\n\t            <button id=\"cond3\">\n\t            Generator\n\t          </label>\n\t        </li>\n\t      </ul>\n\t    </fieldset>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\n\t      \"button, All systems, partially pressed, 3 controls\"\n\t    );\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/ariaOwns.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Aria Owns\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should handle an aria-owns single reference\", async () => {\n\t    document.body.innerHTML = `\n\t    <ul id=\"target\">\n\t        <li aria-owns=\"child\">Fruit</li>\n", "        <li>Vegetables</li>\n\t    </ul>\n\t    <ul id=\"child\">\n\t        <li>Apples</li>\n\t        <li>Bananas</li>\n\t    </ul>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n", "    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"Fruit\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"Apples\",\n\t      \"end of listitem\",\n", "      \"listitem\",\n\t      \"Bananas\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      \"end of listitem\",\n\t      \"listitem\",\n\t      \"Vegetables\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      \"end of document\",\n", "    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle an aria-owns multiple reference\", async () => {\n\t    document.body.innerHTML = `\n\t    <ul id=\"target\">\n\t      <li aria-owns=\"child1 child2\">Fruit</li>\n\t      <li>Vegetables</li>\n\t    </ul>\n\t    <ul id=\"child1\">\n", "        <li>Apples</li>\n\t        <li>Bananas</li>\n\t    </ul>\n\t    <ul id=\"child2\">\n\t        <li>Blackberries</li>\n\t        <li>Blueberries</li>\n\t    </ul>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n", "      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"Fruit\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"Apples\",\n", "      \"end of listitem\",\n\t      \"listitem\",\n\t      \"Bananas\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"Blackberries\",\n\t      \"end of listitem\",\n\t      \"listitem\",\n", "      \"Blueberries\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      \"end of listitem\",\n\t      \"listitem\",\n\t      \"Vegetables\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      \"end of document\",\n\t    ]);\n", "    await virtual.stop();\n\t  });\n\t  it(\"should handle aria-owns where used to reorder already owned children\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"parent\" aria-owns=\"child1 child4 child2\">\n\t      <div id=\"child1\">Child 1</div>\n\t      <div id=\"child2\">Child 2</div>\n\t      <div id=\"child3\">Child 3</div>\n\t      <div id=\"child4\">Child 4</div>\n\t    </div>\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Child 3\",\n\t      \"Child 1\",\n\t      \"Child 4\",\n", "      \"Child 2\",\n\t      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle aria-owns simple circular references gracefully\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"element1\" aria-owns=\"element2\">Element 1</div>\n\t    <div id=\"element2\" aria-owns=\"element3\">Element 2</div>\n\t    <div id=\"element3\" aria-owns=\"element2\">Element 3</div>\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Element 1\",\n\t      \"Element 2\",\n\t      \"Element 3\",\n", "      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle aria-owns only circular references gracefully\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"element1\" aria-owns=\"element2\">Element 1</div>\n\t    <div id=\"element2\" aria-owns=\"element1\">Element 2</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    // All elements are \"owned\" by each other, so are ignored in the accessibility tree\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\"document\", \"document\"]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle aria-owns complex circular references gracefully\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"element1\" aria-owns=\"element2\">Element 1</div>\n\t    <div id=\"element2\" aria-owns=\"element4 element3\">Element 2</div>\n\t    <div id=\"element3\">Element 3</div>\n", "    <div id=\"element4\" aria-owns=\"element5\">Element 4</div>\n\t    <div id=\"element5\" aria-owns=\"element3\">Element 5</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Element 1\",\n", "      \"Element 2\",\n\t      \"Element 4\",\n\t      \"Element 5\",\n\t      \"Element 3\",\n\t      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle aria-owns invalid IDREF gracefully\", async () => {\n\t    document.body.innerHTML = `\n", "    <div id=\"element1\" aria-owns=\"element2\">Element 1</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Element 1\",\n\t      \"end of document\",\n", "    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle aria-owns invalid IDREFs gracefully\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"element1\" aria-owns=\"element2 element3\">Element 1</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n", "    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Element 1\",\n\t      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle aria-owns IDREF for a hidden element gracefully\", async () => {\n\t    document.body.innerHTML = `\n", "    <div id=\"element1\" aria-owns=\"element2\">Element 1</div>\n\t    <div id=\"element2\" aria-hidden=\"true\">Element 2</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Element 1\",\n", "      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle trying to find aria-owns on a non-element container\", async () => {\n\t    const textNode = document.createTextNode(\"text node\");\n\t    await virtual.start({ container: textNode as unknown as HTMLElement });\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\"text node\"]);\n\t    await virtual.stop();\n\t  });\n", "  it(\"should handle multiple aria-owns for the same IDREF gracefully\", async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"element1\" aria-owns=\"element3\">Element 1</div>\n\t    <div id=\"element2\" aria-owns=\"element3\">Element 2</div>\n\t    <div id=\"element3\">Element 3</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"Element 1\",\n\t      \"Element 3\",\n\t      \"Element 2\",\n\t      \"end of document\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/ariaActiveDescendant.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Aria Active Descendant\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should handle a simple combobox\", async () => {\n\t    document.body.innerHTML = `\n\t    <input type=\"text\" aria-activedescendant=\"cb1-opt6\" aria-readonly=\"true\" aria-owns=\"cb1-list\" aria-autocomplete=\"list\" role=\"combobox\" id=\"cb1-edit\">\n\t    <ul aria-expanded=\"true\" role=\"listbox\" id=\"cb1-list\">\n", "      <li role=\"option\" id=\"cb1-opt1\">Alabama</li>\n\t      <li role=\"option\" id=\"cb1-opt2\">Alaska</li>\n\t      <li role=\"option\" id=\"cb1-opt3\">American Samoa</li>\n\t      <li role=\"option\" id=\"cb1-opt4\">Arizona</li>\n\t      <li role=\"option\" id=\"cb1-opt5\">Arkansas</li>\n\t      <li role=\"option\" id=\"cb1-opt6\">California</li>\n\t      <li role=\"option\" id=\"cb1-opt7\">Colorado</li>\n\t    </ul>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"combobox, active descendant California, autocomplete in list, read only, not expanded, has popup listbox\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t  it(\"should gracefully handle an invalid idRef\", async () => {\n\t    document.body.innerHTML = `\n\t    <input type=\"text\" aria-activedescendant=\"cb1-opt8\" aria-readonly=\"true\" aria-owns=\"cb1-list\" aria-autocomplete=\"list\" role=\"combobox\" id=\"cb1-edit\">\n", "    <ul aria-expanded=\"true\" role=\"listbox\" id=\"cb1-list\">\n\t      <li role=\"option\" id=\"cb1-opt1\">Alabama</li>\n\t      <li role=\"option\" id=\"cb1-opt2\">Alaska</li>\n\t      <li role=\"option\" id=\"cb1-opt3\">American Samoa</li>\n\t      <li role=\"option\" id=\"cb1-opt4\">Arizona</li>\n\t      <li role=\"option\" id=\"cb1-opt5\">Arkansas</li>\n\t      <li role=\"option\" id=\"cb1-opt6\">California</li>\n\t      <li role=\"option\" id=\"cb1-opt7\">Colorado</li>\n\t    </ul>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"combobox, autocomplete in list, read only, not expanded, has popup listbox\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/ariaActiveDescendantMenuButton2.int.test.ts", "chunked_list": ["import { setupActionsMenuButton } from \"./actionsMenuButton\";\n\timport userEvent from \"@testing-library/user-event\";\n\timport { virtual } from \"../../src\";\n\tdescribe(\"Aria Active Descendant Menu Button\", () => {\n\t  let teardown;\n\t  beforeEach(() => {\n\t    teardown = setupActionsMenuButton();\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n", "    document.body.innerHTML = \"\";\n\t    teardown();\n\t  });\n\t  it(\"should convey when the referenced element changes - applied to the menu role\", async () => {\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.press(\"ArrowDown\");\n\t    await virtual.press(\"ArrowDown\");\n\t    await virtual.press(\"ArrowDown\");\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n", "      \"document\",\n\t      \"button, Actions, has popup menu, 1 control\",\n\t      \"button, Actions, expanded, has popup menu, 1 control\",\n\t      \"menu, Actions, orientated vertically, active descendant Action 1\",\n\t      \"menu, Actions, orientated vertically, active descendant Action 2\",\n\t      \"menu, Actions, orientated vertically, active descendant Action 3\",\n\t    ]);\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/ariaRoleDescription.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Aria Role Description\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should announce the aria-roledescription in place of the role\", async () => {\n\t    document.body.innerHTML = `\n\t    <div role=\"article\" aria-roledescription=\"slide\" id=\"slide\" aria-labelledby=\"slideheading\">\n\t      <h1 id=\"slideheading\">Quarterly Report</h1>\n", "      <!-- remaining slide contents -->\n\t    </div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"slide, Quarterly Report\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should announce the aria-roledescription in place of the role\", async () => {\n\t    document.body.innerHTML = `\n", "    <article aria-roledescription=\"slide\" id=\"slide\" aria-labelledby=\"slideheading\">\n\t      <h1 id=\"slideheading\">Quarterly Report</h1>\n\t      <!-- remaining slide contents -->\n\t    </article>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toBe(\"slide, Quarterly Report\");\n\t    await virtual.stop();\n\t  });\n", "});\n"]}
{"filename": "test/int/ariaFlowTo.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Aria Flow To\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  describe(\"next\", () => {\n\t    it(\"should let a user navigate to a referenced element\", async () => {\n\t      document.body.innerHTML = `\n\t      <div id=\"content_1\" aria-flowto=\"content_2 content_3 content_4\">apple</div>\n", "      <div id=\"content_2\">banana</div>\n\t      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>\n\t      <div id=\"content_4\">strawberry</div>\n\t      `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      await virtual.next();\n\t      await virtual.next();\n\t      await virtual.next();\n", "      await virtual.perform(\n\t        virtual.commands.moveToNextAlternateReadingOrderElement\n\t      );\n\t      expect(await virtual.spokenPhraseLog()).toEqual([\n\t        \"document\",\n\t        \"3 alternate reading orders, 1 previous alternate reading order\",\n\t        \"apple\",\n\t        \"1 previous alternate reading order\",\n\t        \"banana\",\n\t        \"1 alternate reading order, 1 previous alternate reading order\",\n", "        \"3 alternate reading orders, 1 previous alternate reading order\",\n\t      ]);\n\t      await virtual.stop();\n\t    });\n\t    it(\"should let a user navigate to any referenced elements\", async () => {\n\t      document.body.innerHTML = `\n\t      <div id=\"content_1\" aria-flowto=\"content_2 content_3 content_4\">apple</div>\n\t      <div id=\"content_2\">banana</div>\n\t      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>\n\t      <div id=\"content_4\">strawberry</div>\n", "      `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.perform(\n\t        virtual.commands.moveToNextAlternateReadingOrderElement\n\t      );\n\t      await virtual.previous();\n\t      await virtual.previous();\n\t      await virtual.perform(\n\t        virtual.commands.moveToNextAlternateReadingOrderElement,\n", "        { index: 1 }\n\t      );\n\t      await virtual.previous();\n\t      await virtual.previous();\n\t      await virtual.previous();\n\t      await virtual.previous();\n\t      await virtual.perform(\n\t        virtual.commands.moveToNextAlternateReadingOrderElement,\n\t        { index: 2 }\n\t      );\n", "      await virtual.next();\n\t      expect(await virtual.spokenPhraseLog()).toEqual([\n\t        \"document\",\n\t        \"3 alternate reading orders, 1 previous alternate reading order\",\n\t        \"1 previous alternate reading order\",\n\t        \"apple\",\n\t        \"3 alternate reading orders, 1 previous alternate reading order\",\n\t        \"1 alternate reading order, 1 previous alternate reading order\",\n\t        \"banana\",\n\t        \"1 previous alternate reading order\",\n", "        \"apple\",\n\t        \"3 alternate reading orders, 1 previous alternate reading order\",\n\t        \"1 previous alternate reading order\",\n\t        \"strawberry\",\n\t      ]);\n\t      await virtual.stop();\n\t    });\n\t    it(\"should let a user navigate to a referenced element from an owned element\", async () => {\n\t      document.body.innerHTML = `\n\t      <div id=\"content_1\" aria-owns=\"content_2\">apple</div>\n", "      <div id=\"content_2\" aria-flowto=\"content_3\">banana</div>\n\t      <div id=\"content_3\">orange</div>\n\t      `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      await virtual.next();\n\t      await virtual.perform(\n\t        virtual.commands.moveToNextAlternateReadingOrderElement\n\t      );\n", "      await virtual.next();\n\t      expect(await virtual.spokenPhraseLog()).toEqual([\n\t        \"document\",\n\t        \"apple\",\n\t        \"1 alternate reading order\",\n\t        \"banana\",\n\t        \"1 previous alternate reading order\",\n\t        \"orange\",\n\t      ]);\n\t      await virtual.stop();\n", "    });\n\t    it(\"should gracefully handle no idRefs\", async () => {\n\t      document.body.innerHTML = `\n\t      <div id=\"content_1\" aria-flowto=\"\">apple</div>\n\t      `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.perform(\n\t        virtual.commands.moveToNextAlternateReadingOrderElement\n\t      );\n", "      expect(await virtual.spokenPhraseLog()).toEqual([\"document\", \"apple\"]);\n\t      await virtual.stop();\n\t    });\n\t    it(\"should gracefully handle invalid idRefs\", async () => {\n\t      document.body.innerHTML = `\n\t      <div id=\"content_1\" aria-flowto=\"invalid\">apple</div>\n\t      `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.perform(\n", "        virtual.commands.moveToNextAlternateReadingOrderElement\n\t      );\n\t      expect(await virtual.spokenPhraseLog()).toEqual([\"document\", \"apple\"]);\n\t      await virtual.stop();\n\t    });\n\t    it(\"should gracefully handle trying to navigate to a next alternate reading order flow that doesn't exist\", async () => {\n\t      document.body.innerHTML = `\n\t      <div id=\"content_1\" aria-flowto=\"content_2\">apple</div>\n\t      <div id=\"content_2\">banana</div>\n\t      `;\n", "      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.perform(\n\t        virtual.commands.moveToNextAlternateReadingOrderElement,\n\t        { index: 2 }\n\t      );\n\t      await virtual.next();\n\t      expect(await virtual.spokenPhraseLog()).toEqual([\n\t        \"document\",\n\t        \"1 alternate reading order\",\n", "        \"apple\",\n\t      ]);\n\t      await virtual.stop();\n\t    });\n\t    it(\"should gracefully handle no attempting to follow next alternate reading order on a non-element node\", async () => {\n\t      const container = document.createTextNode(\"Hello World\");\n\t      await virtual.start({ container });\n\t      await virtual.perform(\n\t        virtual.commands.moveToNextAlternateReadingOrderElement\n\t      );\n", "      expect(await virtual.spokenPhraseLog()).toEqual([\"Hello World\"]);\n\t      await virtual.stop();\n\t    });\n\t  });\n\t  describe(\"previous\", () => {\n\t    it(\"should let a user navigate to an element that target the current element\", async () => {\n\t      document.body.innerHTML = `\n\t      <div id=\"content_1\" aria-flowto=\"content_2 content_3 content_4\">apple</div>\n\t      <div id=\"content_2\">banana</div>\n\t      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>\n", "      <div id=\"content_4\">strawberry</div>\n\t      `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.perform(\n\t        virtual.commands.moveToPreviousAlternateReadingOrderElement\n\t      );\n\t      await virtual.next();\n\t      expect(await virtual.spokenPhraseLog()).toEqual([\n\t        \"document\",\n", "        \"3 alternate reading orders, 1 previous alternate reading order\",\n\t        \"1 alternate reading order, 1 previous alternate reading order\",\n\t        \"orange\",\n\t      ]);\n\t      await virtual.stop();\n\t    });\n\t    it(\"should let a user navigate to any element that target the current element\", async () => {\n\t      document.body.innerHTML = `\n\t      <div id=\"content_1\">apple</div>\n\t      <div id=\"content_2\" aria-flowto=\"content_1\">banana</div>\n", "      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>\n\t      `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.perform(\n\t        virtual.commands.moveToPreviousAlternateReadingOrderElement,\n\t        { index: 1 }\n\t      );\n\t      await virtual.next();\n\t      expect(await virtual.spokenPhraseLog()).toEqual([\n", "        \"document\",\n\t        \"2 previous alternate reading orders\",\n\t        \"1 alternate reading order\",\n\t        \"orange\",\n\t      ]);\n\t      await virtual.stop();\n\t    });\n\t    it(\"should let a user navigate to a previous alternate reading order element from an owned element\", async () => {\n\t      document.body.innerHTML = `\n\t      <div id=\"content_1\" aria-owns=\"content_2\">apple</div>\n", "      <div id=\"content_2\">banana</div>\n\t      <div id=\"content_3\" aria-flowto=\"content_2\">orange</div>\n\t      `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      await virtual.perform(\n\t        virtual.commands.moveToPreviousAlternateReadingOrderElement\n\t      );\n\t      await virtual.next();\n", "      expect(await virtual.spokenPhraseLog()).toEqual([\n\t        \"document\",\n\t        \"apple\",\n\t        \"1 previous alternate reading order\",\n\t        \"1 alternate reading order\",\n\t        \"orange\",\n\t      ]);\n\t      await virtual.stop();\n\t    });\n\t    it(\"should gracefully handle trying to navigate to a previous alternate reading order flow that doesn't exist\", async () => {\n", "      document.body.innerHTML = `\n\t      <div id=\"content_1\">apple</div>\n\t      <div id=\"content_2\" aria-flowto=\"content_1\">banana</div>\n\t      <div id=\"content_3\" aria-flowto=\"content_1\">orange</div>\n\t      `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.perform(\n\t        virtual.commands.moveToPreviousAlternateReadingOrderElement,\n\t        { index: 2 }\n", "      );\n\t      await virtual.next();\n\t      expect(await virtual.spokenPhraseLog()).toEqual([\n\t        \"document\",\n\t        \"2 previous alternate reading orders\",\n\t        \"apple\",\n\t      ]);\n\t      await virtual.stop();\n\t    });\n\t    it(\"should gracefully handle no previous alternate reading order\", async () => {\n", "      document.body.innerHTML = `\n\t      <div id=\"content_1\">apple</div>\n\t      `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.perform(\n\t        virtual.commands.moveToPreviousAlternateReadingOrderElement\n\t      );\n\t      expect(await virtual.spokenPhraseLog()).toEqual([\"document\", \"apple\"]);\n\t      await virtual.stop();\n", "    });\n\t    it(\"should gracefully handle no attempting to follow previous alternate reading order on a non-element node\", async () => {\n\t      const container = document.createTextNode(\"Hello World\");\n\t      await virtual.start({ container });\n\t      await virtual.perform(\n\t        virtual.commands.moveToPreviousAlternateReadingOrderElement\n\t      );\n\t      expect(await virtual.spokenPhraseLog()).toEqual([\"Hello World\"]);\n\t      await virtual.stop();\n\t    });\n", "  });\n\t});\n"]}
{"filename": "test/int/focus.int.test.ts", "chunked_list": ["import { getByText } from \"@testing-library/dom\";\n\timport { virtual } from \"../../src\";\n\tfunction setupFocusChangePage() {\n\t  document.body.innerHTML = `\n\t  <div id=\"container\">\n\t    <button id=\"1\">1</button>\n\t    <button id=\"2\">2</button>\n\t    <label for=\"3\">3 label</label>\n\t    <input id=\"3\" type=\"text\" value=\"3\" />\n\t    <label for=\"4\">4 label</label>\n", "    <input id=\"4\" type=\"button\" value=\"4\" />\n\t    <textarea id=\"5\">5</textarea>\n\t    <a id=\"6\" href=\"#\">6</a>\n\t    <button id=\"hidden1\" aria-hidden=\"true\">hidden 1</button>\n\t  </div>\n\t  <button id=\"outside1\">outside 1</button>\n\t  `;\n\t}\n\tdescribe(\"click\", () => {\n\t  beforeEach(() => {\n", "    setupFocusChangePage();\n\t  });\n\t  it(\"should update the screen reader position when a node not currently active for the screen reader is focussed\", async () => {\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t    const container = document.querySelector(\"#container\")! as HTMLElement;\n\t    await virtual.start({ container });\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 1\");\n\t    getByText(container, \"4\").focus();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 4\");\n\t    await virtual.previous();\n", "    await virtual.previous();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"textbox, 3 label, 3\");\n\t    getByText(container, \"6\").focus();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"link, 6\");\n\t    await virtual.previous();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"end of textbox\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should not shift the screen reader active node if focus shifted outside the container\", async () => {\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n", "    const container = document.querySelector(\"#container\")! as HTMLElement;\n\t    await virtual.start({ container });\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 1\");\n\t    getByText(document.body, \"outside 1\").focus();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 1\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should not shift the screen reader active node if focus shifted to a node hidden from screen readers\", async () => {\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t    const container = document.querySelector(\"#container\")! as HTMLElement;\n", "    await virtual.start({ container });\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 1\");\n\t    getByText(document.body, \"hidden 1\").focus();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"button, 1\");\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/type.int.test.ts", "chunked_list": ["import { getByRole } from \"@testing-library/dom\";\n\timport { virtual } from \"../../src\";\n\tfunction setupInputPage() {\n\t  document.body.innerHTML = `\n\t  <label for=\"input\">Input Some Text</label>\n\t  <input type=\"text\" id=\"input\" value=\"\" />\n\t  <div id=\"hidden\" style=\"display: none;\">Hidden</div>\n\t  `;\n\t}\n\tdescribe(\"type\", () => {\n", "  beforeEach(() => {\n\t    setupInputPage();\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  it(\"should type on the active element\", async () => {\n\t    const container = document.body;\n\t    await virtual.start({ container });\n", "    await virtual.next();\n\t    await virtual.next();\n\t    expect(await virtual.itemText()).toEqual(\"Input Some Text\");\n\t    await virtual.type(\"Hello World!\");\n\t    expect(getByRole(container, \"textbox\")).toHaveValue(\"Hello World!\");\n\t    expect(await virtual.itemText()).toEqual(\"Input Some Text, Hello World!\");\n\t    await virtual.stop();\n\t  });\n\t  it(\"should handle requests to type on hidden container gracefully\", async () => {\n\t    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n", "    const container = document.querySelector(\"#hidden\")! as HTMLElement;\n\t    await virtual.start({ container });\n\t    await virtual.type(\"Hello World!\");\n\t    expect(await virtual.itemTextLog()).toEqual([]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([]);\n\t    await virtual.stop();\n\t  });\n\t});\n"]}
{"filename": "test/int/ariaValueNow.int.test.ts", "chunked_list": ["import { virtual } from \"../../src\";\n\tdescribe(\"Label Priority Replacement\", () => {\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  describe(\"progressbar\", () => {\n\t    it(\"should announce aria-valuenow on progressbar roles as a percentage when no range is provided\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n", "      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n", "      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"progressbar, Label, current value 1%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on progressbar roles as a percentage when only aria-valuemin is provided\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemin=\"1\">\n\t        <svg width=\"300\" height=\"10\">\n", "          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"progressbar, Label, min value 1, current value 1%\"\n", "      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on progressbar roles as a percentage when only aria-valuemax is provided\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemax=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n", "        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"progressbar, Label, max value 3, current value 1%\"\n\t      );\n\t      await virtual.stop();\n", "    });\n\t    it(\"should announce aria-valuenow on progressbar roles as a percentage when only min is provided\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" min=\"1\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n", "    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"progressbar, Label, min value 1, current value 1%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on progressbar roles as a percentage when only max is provided\", async () => {\n", "      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" max=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n", "      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"progressbar, Label, max value 3, current value 1%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on progressbar roles as a zero percentage of a positive aria-valuemin - aria-valuemax range\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n", "      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemin=\"1\" aria-valuemax=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n", "      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"progressbar, Label, max value 3, min value 1, current value 0%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on progressbar roles as a non-zero percentage of a positive aria-valuemin - aria-valuemax range\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"1\" aria-valuemax=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n", "          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"progressbar, Label, max value 3, min value 1, current value 50%\"\n", "      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on progressbar roles as a non-zero percentage rounded to at most 2 decimal places\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"0\" aria-valuemax=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n", "        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"progressbar, Label, max value 3, min value 0, current value 66.67%\"\n\t      );\n\t      await virtual.stop();\n", "    });\n\t    it(\"should announce aria-valuenow on progressbar roles as a percentage of a range spanning across 0\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"progressbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"-2\" aria-valuemax=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n", "    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"progressbar, Label, max value 3, min value -2, current value 80%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t  });\n", "  describe(\"scrollbar\", () => {\n\t    it(\"should announce aria-valuenow on scrollbar roles as a percentage when no range is provided\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n", "    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"scrollbar, Label, orientated vertically, max value 100, min value 0, current value 1%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on scrollbar roles as a percentage when only aria-valuemin is provided\", async () => {\n", "      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemin=\"1\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n", "      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"scrollbar, Label, orientated vertically, max value 100, min value 1, current value 0%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on scrollbar roles as a percentage when only aria-valuemax is provided\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n", "      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemax=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n", "      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"scrollbar, Label, orientated vertically, max value 3, min value 0, current value 33.33%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on scrollbar roles as a percentage when only min is provided\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" min=\"1\">\n\t        <svg width=\"300\" height=\"10\">\n", "          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"scrollbar, Label, orientated vertically, max value 100, min value 1, current value 0%\"\n", "      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on scrollbar roles as a percentage when only max is provided\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" max=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n", "        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"scrollbar, Label, orientated vertically, max value 3, min value 0, current value 33.33%\"\n\t      );\n\t      await virtual.stop();\n", "    });\n\t    it(\"should announce aria-valuenow on scrollbar roles as a zero percentage of a positive aria-valuemin - aria-valuemax range\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"1\" aria-valuemin=\"1\" aria-valuemax=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n", "    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"scrollbar, Label, orientated vertically, max value 3, min value 1, current value 0%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on scrollbar roles as a non-zero percentage of a positive aria-valuemin - aria-valuemax range\", async () => {\n", "      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"1\" aria-valuemax=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n", "      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"scrollbar, Label, orientated vertically, max value 3, min value 1, current value 50%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on scrollbar roles as a non-zero percentage rounded to at most 2 decimal places\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n", "      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"0\" aria-valuemax=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n\t          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n", "      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"scrollbar, Label, orientated vertically, max value 3, min value 0, current value 66.67%\"\n\t      );\n\t      await virtual.stop();\n\t    });\n\t    it(\"should announce aria-valuenow on scrollbar roles as a percentage of a range spanning across 0\", async () => {\n\t      document.body.innerHTML = `\n\t      <span id=\"element1\">Label</span>\n\t      <span role=\"scrollbar\" aria-labelledby=\"element1\" aria-valuenow=\"2\" aria-valuemin=\"-2\" aria-valuemax=\"3\">\n\t        <svg width=\"300\" height=\"10\">\n", "          <rect height=\"10\" width=\"100\" stroke=\"black\" fill=\"red\" />\n\t          <rect height=\"10\" width=\"200\" fill=\"white\" />\n\t        </svg>\n\t      </span>\n\t    `;\n\t      await virtual.start({ container: document.body });\n\t      await virtual.next();\n\t      await virtual.next();\n\t      expect(await virtual.lastSpokenPhrase()).toBe(\n\t        \"scrollbar, Label, orientated vertically, max value 3, min value -2, current value 80%\"\n", "      );\n\t      await virtual.stop();\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/wpt/html-aam/table-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/html-aam/table-roles.html\n\t */\n\tdescribe(\"HTML-AAM Table Role Verification Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <table data-testname=\"el-table\" data-expectedrole=\"table\" class=\"ex\">\n\t      <caption data-testname=\"el-caption\" data-expectedrole=\"caption\" class=\"ex\">caption</caption>\n\t      <thead data-testname=\"el-thead\" data-expectedrole=\"rowgroup\" class=\"ex\">\n", "        <tr data-testname=\"el-tr-thead\" data-expectedrole=\"row\" class=\"ex\">\n\t          <th data-testname=\"el-th\" data-expectedrole=\"columnheader\" class=\"ex\">a</th>\n\t          <th>b</th>\n\t          <th>c</th>\n\t        </tr>\n\t      </thead>\n\t      <tbody data-testname=\"el-tbody\" data-expectedrole=\"rowgroup\" class=\"ex\">\n\t        <tr data-testname=\"el-tr-tbody\" data-expectedrole=\"row\" class=\"ex\">\n\t          <th data-testname=\"el-th-in-row\" data-expectedrole=\"rowheader\" class=\"ex\">1</th>\n\t          <td data-testname=\"el-td\" data-expectedrole=\"cell\" class=\"ex\">2</td>\n", "          <td>3</td>\n\t        </tr>\n\t        <tr>\n\t          <th>4</th>\n\t          <td>5</td>\n\t          <td>6</td>\n\t        </tr>\n\t      </tbody>\n\t      <tfoot data-testname=\"el-tfoot\" data-expectedrole=\"rowgroup\" class=\"ex\">\n\t        <tr>\n", "          <th>x</th>\n\t          <th>y</th>\n\t          <th>z</th>\n\t        </tr>\n\t      </tfoot>\n\t    </table>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n", "    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"verifies roles\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"table, caption\",\n", "      \"caption\",\n\t      \"rowgroup\",\n\t      \"row, a b c\",\n\t      \"columnheader, a\",\n\t      \"columnheader, b\",\n\t      \"columnheader, c\",\n\t      \"end of row, a b c\",\n\t      \"end of rowgroup\",\n\t      \"rowgroup\",\n\t      \"row, 1 2 3\",\n", "      \"columnheader, 1\",\n\t      \"cell, 2\",\n\t      \"cell, 3\",\n\t      \"end of row, 1 2 3\",\n\t      \"row, 4 5 6\",\n\t      \"columnheader, 4\",\n\t      \"cell, 5\",\n\t      \"cell, 6\",\n\t      \"end of row, 4 5 6\",\n\t      \"end of rowgroup\",\n", "      \"rowgroup\",\n\t      \"row, x y z\",\n\t      \"columnheader, x\",\n\t      \"columnheader, y\",\n\t      \"columnheader, z\",\n\t      \"end of row, x y z\",\n\t      \"end of rowgroup\",\n\t      \"end of table, caption\",\n\t      \"end of document\",\n\t    ]);\n", "  });\n\t});\n"]}
{"filename": "test/wpt/html-aam/roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/html-aam/roles.html\n\t */\n\tdescribe(\"HTML-AAM Role Verification Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <!-- Most test names correspond to unique ID defined in the https://w3c.github.io/html-aam/ spec. -->\n\t    <a href=\"#\" data-testname=\"el-a\" data-expectedrole=\"link\" class=\"ex\">x</a>\n\t    <a data-testname=\"el-a-no-href\" data-expectedrole=\"generic\" class=\"ex\">x</a>\n", "    <!-- todo: abbr -->\n\t    <address data-testname=\"el-address\" data-expectedrole=\"group\" class=\"ex\">x</address>\n\t    <!-- area -> ./fragile/area-role.html -->\n\t    <article data-testname=\"el-article\" data-expectedrole=\"article\" class=\"ex\">x</article>\n\t    <!-- el-aside -->\n\t    <nav>\n\t      <aside data-testname=\"el-aside-in-section-with-name\" data-expectedrole=\"complementary\" aria-label=\"x\" class=\"ex\">x</aside>\n\t      <aside data-testname=\"el-aside-in-section-without-name\" data-expectedrole=\"generic\" class=\"ex\">x</aside>\n\t    </nav>\n\t    <aside data-testname=\"el-aside-ancestorbodymain\" data-expectedrole=\"complementary\" class=\"ex\">x</aside>\n", "    <!-- todo: audio -->\n\t    <!-- todo: autonomous custom element -->\n\t    <b data-testname=\"el-b\" data-expectedrole=\"generic\" class=\"ex\">x</b>\n\t    <!-- base (not mapped) -->\n\t    <bdi data-testname=\"el-bdi\" data-expectedrole=\"generic\" class=\"ex\">x</bdi>\n\t    <bdo data-testname=\"el-bdo\" data-expectedrole=\"generic\" class=\"ex\">x</bdo>\n\t    <blockquote data-testname=\"el-blockquote\" data-expectedrole=\"blockquote\" class=\"ex\">x</blockquote>\n\t    <!-- todo: body -->\n\t    <!-- br (not mapped) -->\n\t    <button data-testname=\"el-button\" data-expectedrole=\"button\" class=\"ex\">x</button>\n", "    <!-- todo: canvas -->\n\t    <!-- caption -> ./table-roles.html -->\n\t    <!-- todo: cite -->\n\t    <code data-testname=\"el-code\" data-expectedrole=\"code\" class=\"ex\">x</code>\n\t    <!-- todo: col -->\n\t    <!-- todo: colgroup -->\n\t    <data value=\"1\" data-testname=\"el-data\" data-expectedrole=\"generic\" class=\"ex\">x</data>\n\t    <!-- todo: datalist -->\n\t    <!-- el-dd -->\n\t    <dl>\n", "      <dt>x</dt>\n\t      <dd data-testname=\"el-dd\" data-expectedrole=\"definition\" class=\"ex\">x</dd>\n\t    </dl>\n\t    <del data-testname=\"el-del\" data-expectedrole=\"deletion\" class=\"ex\">x</del>\n\t    <details data-testname=\"el-details\" data-expectedrole=\"group\" class=\"ex\"><summary>x</summary>x</details>\n\t    <dfn data-testname=\"el-dfn\" data-expectedrole=\"term\" class=\"ex\">x</dfn>\n\t    <div open data-testname=\"el-div\" data-expectedrole=\"generic\" class=\"ex\">x</div>\n\t    <!-- todo: dl -->\n\t    <!-- el-dt -->\n\t    <dl>\n", "      <dt data-testname=\"el-dt\" data-expectedrole=\"term\" class=\"ex\">x</dt>\n\t      <dd>x</dd>\n\t    </dl>\n\t    <em data-testname=\"el-em\" data-expectedrole=\"emphasis\" class=\"ex\">x</em>\n\t    <!-- todo: embed -->\n\t    <fieldset data-testname=\"el-fieldset\" data-expectedrole=\"group\" class=\"ex\"><legend>x</legend><input></fieldset>\n\t    <!-- todo: figcaption -->\n\t    <figure data-testname=\"el-figure\" data-expectedrole=\"figure\" class=\"ex\"><img src=\"#\" alt=\"x\"><figcaption>x</figcaption></figure>\n\t    <!-- el-footer -->\n\t    <nav>\n", "      <footer data-testname=\"el-footer\" data-expectedrole=\"generic\" aria-label=\"x\" class=\"ex\">x</aside>\n\t    </nav>\n\t    <footer data-testname=\"el-footer-ancestorbody\" data-expectedrole=\"contentinfo\" class=\"ex\">x</footer>\n\t    <form data-testname=\"el-form\" data-expectedrole=\"form\" class=\"ex\"><input></form>\n\t    <!-- todo: form-associated custom element -->\n\t    <!-- el-h1-h6 -->\n\t    <h1 data-testname=\"el-h1\" data-expectedrole=\"heading\" class=\"ex\">x</h1>\n\t    <h2 data-testname=\"el-h2\" data-expectedrole=\"heading\" class=\"ex\">x</h2>\n\t    <h3 data-testname=\"el-h3\" data-expectedrole=\"heading\" class=\"ex\">x</h3>\n\t    <h4 data-testname=\"el-h4\" data-expectedrole=\"heading\" class=\"ex\">x</h4>\n", "    <h5 data-testname=\"el-h5\" data-expectedrole=\"heading\" class=\"ex\">x</h5>\n\t    <h6 data-testname=\"el-h6\" data-expectedrole=\"heading\" class=\"ex\">x</h6>\n\t    <!-- head (not mapped) -->\n\t    <!-- el-header -->\n\t    <nav>\n\t      <header data-testname=\"el-header\" data-expectedrole=\"generic\" aria-label=\"x\" class=\"ex\">x</header>\n\t    </nav>\n\t    <header data-testname=\"el-header-ancestorbody\" data-expectedrole=\"banner\" class=\"ex\">x</header>\n\t    <hgroup data-testname=\"el-hgroup\" data-expectedrole=\"group\" class=\"ex\"><h1>x</h1></hgroup>\n\t    <hr data-testname=\"el-hr\" data-expectedrole=\"separator\" class=\"ex\">\n", "    <!-- todo: html -->\n\t    <i data-testname=\"el-i\" data-expectedrole=\"generic\" class=\"ex\">x</i>\n\t    <!-- todo: iframe -->\n\t    <img src=\"#\" alt=\"x\" data-testname=\"el-img\" data-expectedrole=\"image\" class=\"ex\">\n\t    <!-- Implementations might also be valid if ignored rather than returning 'none' for the following images. -->\n\t    <img src=\"#\" alt data-testname=\"el-img-alt-no-value\" data-expectedrole=\"none\" class=\"ex\">\n\t    <img src=\"#\" alt=\"\" data-testname=\"el-img-empty-alt\" data-expectedrole=\"none\" class=\"ex\">\n\t    <input type=\"button\" value=\"x\" data-testname=\"el-input-button\" data-expectedrole=\"button\" class=\"ex\">\n\t    <input type=\"checkbox\" data-testname=\"el-input-checkbox\" data-expectedrole=\"checkbox\" class=\"ex\">\n\t    <!-- todo: input type=\"color\" -->\n", "    <!-- todo: input type=\"date\" -->\n\t    <!-- todo: input type=\"datetime\" -->\n\t    <!-- todo: input type=\"datetime-local\" -->\n\t    <input type=\"email\" data-testname=\"el-input-email\" data-expectedrole=\"textbox\" class=\"ex\">\n\t    <!-- todo: input type=\"file\" -->\n\t    <!-- input type=\"hidden\" (not mapped) -->\n\t    <!-- todo: input type=\"month\" -->\n\t    <!-- Blocked: HTML-AAM Issue #467 -->\n\t    <!-- <input type=\"number\" data-testname=\"el-input-number\" data-expectedrole=\"spinbutton\" class=\"ex\"> -->\n\t    <!-- todo: input type=\"password\" -->\n", "    <input type=\"radio\" data-testname=\"el-input-radio\" data-expectedrole=\"radio\" class=\"ex\">\n\t    <input type=\"range\" data-testname=\"el-input-range\" data-expectedrole=\"slider\" class=\"ex\">\n\t    <input type=\"reset\" value=\"x\" data-testname=\"el-input-reset\" data-expectedrole=\"button\" class=\"ex\">\n\t    <input type=\"search\" data-testname=\"el-input-search\" data-expectedrole=\"searchbox\" class=\"ex\">\n\t    <input type=\"submit\" value=\"x\" data-testname=\"el-input-submit\" data-expectedrole=\"button\" class=\"ex\">\n\t    <input type=\"tel\" data-testname=\"el-input-tel\" data-expectedrole=\"textbox\" class=\"ex\">\n\t    <input type=\"text\" data-testname=\"el-input-text\" data-expectedrole=\"textbox\" class=\"ex\">\n\t    <!-- todo: input (type attribute in the Text, Search, Telephone, URL, or E-mail states with a suggestions source element) -->\n\t    <!-- todo: input type=\"time\" -->\n\t    <input type=\"url\" data-testname=\"el-input-url\" data-expectedrole=\"textbox\" class=\"ex\">\n", "    <!-- todo: input type=\"week\" -->\n\t    <ins data-testname=\"el-ins\" data-expectedrole=\"insertion\" class=\"ex\">x</ins>\n\t    <!-- todo: kbd -->\n\t    <!-- todo: label -->\n\t    <!-- todo: legend -->\n\t    <!-- el-li -->\n\t    <li data-testname=\"el-li-orphaned\" data-expectedrole=\"generic\" class=\"ex\">x</li>\n\t    <ul><li data-testname=\"el-li-in-ul\" data-expectedrole=\"listitem\" class=\"ex\">x</li><li>x</li></ul>\n\t    <ol><li data-testname=\"el-li-in-ol\" data-expectedrole=\"listitem\" class=\"ex\">x</li><li>x</li></ol>\n\t    <!-- link (not mapped) -->\n", "    <main data-testname=\"el-main\" data-expectedrole=\"main\" class=\"ex\">x</main>\n\t    <!-- map (not mapped) -->\n\t    <mark data-testname=\"el-mark\" data-expectedrole=\"mark\" class=\"ex\">x</mark>\n\t    <!-- todo: math -->\n\t    <menu data-testname=\"el-menu\" data-expectedrole=\"list\" class=\"ex\"><li>x</li></menu>\n\t    <!-- meta (not mapped) -->\n\t    <meter data-testname=\"el-meter\" data-expectedrole=\"meter\" class=\"ex\" min=\"0\" max=\"100\" low=\"20\" high=\"80\" optimum=\"60\" value=\"50\">x</meter>\n\t    <nav data-testname=\"el-nav\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <!-- noscript (not mapped) -->\n\t    <!-- object (not mapped) -->\n", "    <ol data-testname=\"el-ol\" data-expectedrole=\"list\" class=\"ex\"><li>x</li><li>x</li></ol>\n\t    <!-- optgroup -> ./fragile/optgroup-role.html -->\n\t    <!-- option -->\n\t    <select>\n\t      <option data-testname=\"el-option\" data-expectedrole=\"option\" class=\"ex\">x</option>\n\t      <option>x</option>\n\t    </select>\n\t    <output data-testname=\"el-output\" data-expectedrole=\"status\" class=\"ex\">x</output>\n\t    <p data-testname=\"el-p\" data-expectedrole=\"paragraph\" class=\"ex\">x</p>\n\t    <!-- param (not mapped) -->\n", "    <!-- todo: picture -->\n\t    <pre data-testname=\"el-pre\" data-expectedrole=\"generic\" class=\"ex\">x</pre>\n\t    <progress data-testname=\"el-progress\" data-expectedrole=\"progressbar\" class=\"ex\">x</progress>\n\t    <q data-testname=\"el-q\" data-expectedrole=\"generic\" class=\"ex\">x</q>\n\t    <!-- todo: rp -> /ruby-aam? -->\n\t    <!-- todo: rt -> /ruby-aam? -->\n\t    <!-- todo: ruby -> /ruby-aam? -->\n\t    <s data-testname=\"el-s\" data-expectedrole=\"deletion\" class=\"ex\">x</s>\n\t    <samp data-testname=\"el-samp\" data-expectedrole=\"generic\" class=\"ex\">x</samp>\n\t    <!-- script (not mapped) -->\n", "    <search data-testname=\"el-search\" data-expectedrole=\"search\" class=\"ex\">x</search>\n\t    <!-- el-section -->\n\t    <section data-testname=\"el-section\" aria-label=\"x\" data-expectedrole=\"region\" class=\"ex\">x</section>\n\t    <section data-testname=\"el-section-no-name\" data-expectedrole=\"generic\" class=\"ex\">x</section>\n\t    <!-- Blocked: HTML-AAM Issue #467 -->\n\t    <!-- <select data-testname=\"el-select-combobox\" data-expectedrole=\"combobox\" class=\"ex\"><option>a1</option><option>a2</option></select>-->\n\t    <select data-testname=\"el-select-listbox\" size=\"2\" data-expectedrole=\"listbox\" class=\"ex\"><option>b1</option><option>b2</option></select>\n\t    <!-- slot (not mapped) -->\n\t    <small data-testname=\"el-small\" data-expectedrole=\"generic\" class=\"ex\">x</small>\n\t    <!-- source (not mapped) -->\n", "    <span data-testname=\"el-span\" data-expectedrole=\"generic\" class=\"ex\">x</span>\n\t    <strong data-testname=\"el-strong\" data-expectedrole=\"strong\" class=\"ex\">x</strong>\n\t    <!-- style (not mapped) -->\n\t    <sub data-testname=\"el-sub\" data-expectedrole=\"subscript\" class=\"ex\">x</sub>\n\t    <!-- todo: summary -->\n\t    <sup data-testname=\"el-sup\" data-expectedrole=\"superscript\" class=\"ex\">x</sup>\n\t    <!-- todo: svg (see /graphics-aam and /svg-aam tests) -->\n\t    <!-- table -> ./table-roles.html -->\n\t    <!-- tbody -> ./table-roles.html -->\n\t    <!-- td -> ./table-roles.html -->\n", "    <!-- template (not mapped) -->\n\t    <!-- tfoot -> ./table-roles.html -->\n\t    <!-- th -> ./table-roles.html -->\n\t    <!-- thead -> ./table-roles.html -->\n\t    <time data-testname=\"el-time\" data-expectedrole=\"time\" class=\"ex\">x</time>\n\t    <!-- title (not mapped) -->\n\t    <!-- tr -> ./table-roles.html -->\n\t    <textarea data-testname=\"el-textarea\" data-expectedrole=\"textbox\" class=\"ex\">x</textarea>\n\t    <!-- track (not mapped) -->\n\t    <u data-testname=\"el-u\" data-expectedrole=\"generic\" class=\"ex\">x</u>\n", "    <ul data-testname=\"el-ul\" data-expectedrole=\"list\" class=\"ex\"><li>x</li><li>x</li></ul>\n\t    <!-- var (not mapped) -->\n\t    <!-- todo: video -->\n\t    <!-- wbr (not mapped) -->\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n", "  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"verifies roles\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"link, x\",\n\t      \"x\", // WONTFIX generic ignored by screen readers\n\t      \"x\", // TODO: FAIL address should have role group\n", "      \"article\",\n\t      \"x\",\n\t      \"end of article\",\n\t      \"navigation\",\n\t      \"complementary, x\",\n\t      \"complementary\",\n\t      \"x\",\n\t      \"end of complementary\",\n\t      \"end of navigation\",\n\t      \"complementary\",\n", "      \"x\",\n\t      \"end of complementary\",\n\t      \"x\", // WONTFIX generic ignored by screen readers\n\t      \"x\", // WONTFIX generic ignored by screen readers\n\t      \"x\", // WONTFIX generic ignored by screen readers\n\t      \"x\", // TODO: FAIL blockquote should have role blockquote\n\t      \"button, x\",\n\t      \"x\", // TODO: FAIL code should have role code\n\t      \"x\", // WONTFIX generic ignored by screen readers\n\t      \"term\",\n", "      \"x\",\n\t      \"end of term\",\n\t      \"definition\",\n\t      \"x\",\n\t      \"end of definition\",\n\t      \"x\", // TODO: FAIL del should have role deletion\n\t      \"group\",\n\t      \"button, x\",\n\t      \"x\",\n\t      \"end of group\",\n", "      \"term\",\n\t      \"x\",\n\t      \"end of term\",\n\t      \"x\", // WONTFIX generic ignored by screen readers\n\t      \"term\",\n\t      \"x\",\n\t      \"end of term\",\n\t      \"definition\",\n\t      \"x\",\n\t      \"end of definition\",\n", "      \"x\", // TODO: FAIL em should have role emphasis\n\t      \"group, x\",\n\t      \"figure\",\n\t      \"img, x\",\n\t      \"x\",\n\t      \"end of figure\",\n\t      \"navigation\",\n\t      \"contentinfo, x\",\n\t      \"end of navigation\",\n\t      \"contentinfo\",\n", "      \"x\",\n\t      \"end of contentinfo\",\n\t      \"form\",\n\t      \"textbox\",\n\t      \"end of form\",\n\t      \"heading, x, level 1\",\n\t      \"heading, x, level 2\",\n\t      \"heading, x, level 3\",\n\t      \"heading, x, level 4\",\n\t      \"heading, x, level 5\",\n", "      \"heading, x, level 6\",\n\t      \"navigation\",\n\t      \"banner, x\", // TODO: FAIL header role should be generic\n\t      \"end of navigation\",\n\t      \"banner\",\n\t      \"x\",\n\t      \"end of banner\",\n\t      \"heading, x, level 1\", // TODO: FAIL hgroup missing role\n\t      \"separator, orientated horizontally, max value 100, min value 0\",\n\t      \"x\", // WONTFIX generic ignored by screen readers\n", "      \"img, x\", // TODO: FAIL img role should be image\n\t      // PASS on missing img entry\n\t      // PASS on missing img entry\n\t      \"button, x\",\n\t      \"checkbox\",\n\t      \"textbox\",\n\t      \"radio\",\n\t      \"slider, 50, orientated horizontally, max value 100, min value 0\",\n\t      \"button, x\",\n\t      \"searchbox\",\n", "      \"button, x\",\n\t      \"textbox\",\n\t      \"textbox\",\n\t      \"textbox\",\n\t      \"x\", // TODO: FAIL ins missing insertion role\n\t      \"listitem\", // TODO: FAIL orphaned li should not be announced\n\t      \"x\",\n\t      \"end of listitem\",\n\t      \"list\",\n\t      \"listitem\",\n", "      \"x\",\n\t      \"end of listitem\",\n\t      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n", "      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      \"main\",\n\t      \"x\",\n\t      \"end of main\",\n\t      \"x\", // TODO: FAIL mark should have mark role\n\t      \"list\",\n\t      \"listitem\",\n", "      \"x\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      \"x\", // TODO: FAIL meter should have meter role\n\t      \"navigation\",\n\t      \"x\",\n\t      \"end of navigation\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"x\",\n", "      \"end of listitem\",\n\t      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      \"combobox, x, not expanded, has popup listbox\",\n\t      \"option, x, not selected\",\n\t      \"option, x, not selected\",\n\t      \"end of combobox, x, not expanded, has popup listbox\",\n\t      \"status\",\n", "      \"x\",\n\t      \"end of status\",\n\t      \"x\", // TODO: FAIL p should have paragraph role\n\t      \"x\", // WONTFIX generic ignored by screen readers\n\t      \"progressbar, 0\",\n\t      \"x\",\n\t      \"end of progressbar, 0\",\n\t      \"x\",\n\t      \"x\", // TODO: FAIL s should have deletion role\n\t      \"x\", // WONTFIX generic ignored by screen readers\n", "      \"x\", // TODO: FAIL search should have search role\n\t      \"region, x\",\n\t      \"region\", // TODO: FAIL section with no name should be generic\n\t      \"x\",\n\t      \"end of region\",\n\t      \"listbox, orientated vertically\",\n\t      \"option, b1, not selected\",\n\t      \"option, b2, not selected\",\n\t      \"end of listbox, orientated vertically\",\n\t      \"x\", // WONTFIX generic ignored by screen readers\n", "      \"x\", // WONTFIX generic ignored by screen readers\n\t      \"x\", // TODO: FAIL strong should have strong role\n\t      \"x\", // TODO: FAIL sub should have subscript role\n\t      \"x\", // TODO: FAIL sup should have superscript role\n\t      \"x\", // TODO: FAIL time should have time role\n\t      \"textbox\",\n\t      \"x\",\n\t      \"end of textbox\",\n\t      \"x\", // WONTFIX generic ignored by screen readers\n\t      \"list\",\n", "      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n\t      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n", "});\n"]}
{"filename": "test/wpt/wai-aria/role/fallback-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/fallback-roles.html\n\t *\n\t * Verifies Fallback Roles from https://w3c.github.io/aria/#document-handling_author-errors_roles\n\t * 9.1 Roles - handling author errors\n\t */\n\tdescribe(\"Fallback Role Verification Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n", "    <navigation role=\"region group\" data-testname=\"fallback role w/ region with no label\" data-expectedrole=\"group\" class=\"ex\">x</navigation>\n\t    <navigation role=\"region group\" data-testname=\"fallback role w/ region with label\" aria-label=\"x\" data-expectedrole=\"region\" class=\"ex\">x</navigation>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    // Group\n\t    await virtual.next();\n\t    await virtual.next();\n\t    // Region\n\t    await virtual.next();\n", "  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"verifies roles\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"group\",\n\t      \"x\",\n", "      \"end of group\",\n\t      \"region, x\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/wai-aria/role/list-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/list-roles.html\n\t *\n\t * Verifies Invalid Roles from https://w3c.github.io/aria/#document-handling_author-errors_roles\n\t * 9.1 Roles - handling author errors\n\t */\n\tdescribe(\"List-related Role Verification Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n", "    <div role=\"list\" data-testname=\"first simple list\" data-expectedrole=\"list\" class=\"ex\">\n\t      <div role=\"listitem\" data-testname=\"first simple listitem\" data-expectedrole=\"listitem\" class=\"ex\">x</div>\n\t      <div role=\"listitem\" data-testname=\"last simple listitem\" data-expectedrole=\"listitem\" class=\"ex\">x</div>\n\t    </div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n", "    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"verifies roles\", async () => {\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n\t      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n", "    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/wai-aria/role/region-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/region-roles.html\n\t *\n\t * Verifies Invalid Roles from https://w3c.github.io/aria/#document-handling_author-errors_roles\n\t * 9.1 Roles - handling author errors\n\t */\n\tdescribe(\"Region Role Verification Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n", "    <!-- no label -->\n\t    <nav role=\"region\" data-testname=\"region without label\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <!-- w/ label -->\n\t    <nav role=\"region\" data-testname=\"region with label\" data-expectedrole=\"region\" aria-label=\"x\" class=\"ex\">x</nav>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    // Navigation\n\t    await virtual.next();\n\t    await virtual.next();\n", "    // Region\n\t    await virtual.next();\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"verifies roles\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n", "      \"navigation\",\n\t      \"x\",\n\t      \"end of navigation\",\n\t      \"region, x\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/wai-aria/role/role_non_conflict_resolution.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/role_none_conflict_resolution.html\n\t *\n\t * Verifies https://w3c.github.io/aria/#conflict_resolution_presentation_none\n\t * conflict resolution requirements for the ARIA none and presentation roles.\n\t */\n\tdescribe(\"Role None Conflict Resolution Verification Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n", "    <!-- none with label(global) on header -->\n\t    <h1 role=\"none\" data-testname=\"heading role none with global attr aria-label\" data-expectedrole=\"heading\" aria-label=\"x\" class=\"ex\">x</h1>\n\t    <!-- none with label(global) on paragraph -->\n\t    <p role=\"none\" data-testname=\"p role none with global attr aria-label (prohibited role)\" data-expectedrole=\"paragraph\" aria-label=\"x\" class=\"ex\">x</p>\n\t    <p role=\"none\" data-testname=\"p role none without global attr aria-label (prohibited role)\" data-expectedrole=\"none\" class=\"ex\">x</p>\n\t    <!-- none with focusable header -->\n\t    <h1 role=\"none\" data-testname=\"focusable heading role none with tabindex=0\" data-expectedrole=\"heading\" tabindex=\"0\" class=\"ex\">x</h1>\n\t    <h1 role=\"none\" data-testname=\"focusable heading role none with tabindex=-1\" data-expectedrole=\"heading\" tabindex=\"-1\" class=\"ex\">x</h1>\n\t    <h1 role=\"none\" data-testname=\"non-focusable heading role none\" data-expectedrole=\"none\" class=\"ex\">x</h1>\n\t    <!-- none with non-global-->\n", "    <h1 role=\"none\" data-testname=\"none with non-global\" data-expectedrole=\"none\" class=\"ex\" aria-level=\"2\"> Sample Content </h1>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n", "    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"verifies roles\", async () => {\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"heading, x, level 1\",\n\t      /**\n\t       * Invalid as of Aria 1.2, see https://www.w3.org/TR/wai-aria-1.2/#paragraph.\n\t       * Awaiting new release of dom-accessibility-api / aria-query dependencies\n\t       * \"paragraph, x\"\n\t       */\n\t      \"x\",\n\t      \"x\",\n", "      \"heading, level 1\",\n\t      \"x\",\n\t      \"end of heading, level 1\",\n\t      \"heading, level 1\",\n\t      \"x\",\n\t      \"end of heading, level 1\",\n\t      \"x\",\n\t      \"Sample Content\",\n\t    ]);\n\t  });\n", "});\n"]}
{"filename": "test/wpt/wai-aria/role/invalid-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/invalid-roles.html\n\t *\n\t * Verifies Invalid Roles from https://w3c.github.io/aria/#document-handling_author-errors_roles\n\t * 9.1 Roles - handling author errors\n\t */\n\tdescribe(\"Invalid Role Verification Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n", "    <nav role=\"foo\" data-testname=\"invalid role name foo\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"foo bar\" data-testname=\"multiple invalid role names\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    for (let i = 0; i < document.body.querySelectorAll(\"nav\").length * 3; i++) {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n", "    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"verifies roles\", async () => {\n\t    const expected = [\n\t      ...new Array(document.body.querySelectorAll(\"nav\").length),\n\t    ].flatMap(() => [\"navigation\", \"x\", \"end of navigation\"]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\"document\", ...expected]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/wai-aria/role/basic.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/basic.html\n\t */\n\tdescribe(\"Basic Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div id='d' style='height: 100px; width: 100px' role=\"group\" aria-label=\"test label\"></div>\n\t    <h1 id=\"h\">test heading</h1>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests explicit role\", async () => {\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\"group, test label\");\n\t  });\n", "  test(\"tests implicit role\", async () => {\n\t    await virtual.next();\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\n\t      \"heading, test heading, level 1\"\n\t    );\n\t  });\n\t});\n"]}
{"filename": "test/wpt/wai-aria/role/synonym-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/synonym-roles.html\n\t *\n\t * spec resolution https://github.com/w3c/core-aam/issues/166\n\t */\n\tdescribe(\"Synonym Role Verification Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div role=\"none\" id=\"none\" data-expectedrole=\"none\" data-testname=\"none role == computedrole none\" class=\"ex\">x</div><!-- preferred -->\n", "    <div role=\"presentation\" id=\"presentation\" data-expectedrole=\"none\" data-testname=\"synonym presentation role == computedrole none\" class=\"ex\">x</div><!-- synonym -->\n\t    <!-- image role due ARIA 1.3 -->\n\t    <!-- <div role=\"image\" id=\"image\" data-expectedrole=\"image\" data-testname=\"image role == computedrole image\" class=\"ex\">x</div> --> <!-- preferred -->\n\t    <div role=\"img\" id=\"img\" data-expectedrole=\"image\" data-testname=\"synonym img role == computedrole image\" class=\"ex\">x</div><!-- synonym -->\n\t    <!-- \\`directory\\` synonym deprecated in ARIA 1.2; these examples should all return computedrole \\`list\\` -->\n\t    <ul role=\"list\" id=\"list2\" data-expectedrole=\"list\" data-testname=\"list role == computedrole list\" class=\"ex\"><li>x</li></ul>\n\t    <ul role=\"directory\" id=\"directory\" data-expectedrole=\"list\" data-testname=\"directory role == computedrole list\" class=\"ex\"><li>x</li></ul>\n\t    <div role=\"directory\" id=\"div\" data-expectedrole=\"list\" data-testname=\"div w/directory role == computedrole list\" class=\"ex\"><div role=\"listitem\">x</div></div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n", "    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n", "  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"verifies roles\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"x\",\n\t      \"x\",\n", "      \"img\",\n\t      \"x\",\n\t      \"end of img\",\n\t      \"list\",\n\t      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n\t      \"end of list\",\n\t      /**\n\t       * `directory` alias deprecated in https://www.w3.org/TR/wai-aria-1.2/#directory\n", "       */\n\t      \"directory\",\n\t      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n\t      \"end of directory\",\n\t      \"directory\",\n\t      \"listitem\",\n\t      \"x\",\n\t      \"end of listitem\",\n", "      \"end of directory\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/wai-aria/role/abstract-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/abstract-roles.html\n\t *\n\t * Verifies https://w3c.github.io/aria/#document-handling_author-errors_roles\n\t * 9.1 Roles - handling author errors\n\t */\n\tdescribe(\"Abstract Role Verification Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n", "    <nav role=\"command\" data-testname=\"command role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"composite\" data-testname=\"composite role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"input\" data-testname=\"input role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"landmark\" data-testname=\"landmark role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"range\" data-testname=\"range role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"roletype\" data-testname=\"roletype role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"section\" data-testname=\"section role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"sectionhead\" data-testname=\"sectionhead role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"select\" data-testname=\"select role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"structure\" data-testname=\"structure role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n", "    <nav role=\"widget\" data-testname=\"widget role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <nav role=\"window\" data-testname=\"window role\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    for (let i = 0; i < document.body.querySelectorAll(\"nav\").length * 3; i++) {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n", "    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"verifies roles\", async () => {\n\t    const expected = [\n\t      ...new Array(document.body.querySelectorAll(\"nav\").length),\n\t    ].flatMap(() => [\"navigation\", \"x\", \"end of navigation\"]);\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\"document\", ...expected]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/wai-aria/role/form-roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/form-roles.html\n\t *\n\t * Verifies https://w3c.github.io/aria/#document-handling_author-errors_roles\n\t * 9.1 Roles - handling author errors and the form role.\n\t */\n\tdescribe(\"Form Role Verification Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n", "    <!-- no label -->\n\t    <nav role=\"form\" data-testname=\"form without label\" data-expectedrole=\"navigation\" class=\"ex\">x</nav>\n\t    <!-- w/ label -->\n\t    <nav role=\"form\" data-testname=\"form with label\" data-expectedrole=\"form\" aria-label=\"x\" class=\"ex\">x</nav>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n\t    await virtual.next();\n", "  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"verifies roles\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"navigation\",\n\t      \"x\",\n", "      \"end of navigation\",\n\t      \"form, x\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/wai-aria/role/roles.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/wai-aria/role/roles.html\n\t *\n\t * Tests simple role assignment: <div role=\"alert\">x</div>\n\t *\n\t * - Nested role structures (table>row>cell, etc) and Abstract roles (e.g.\n\t *   widget, composite) are commented with pointers to a separate test file.\n\t *\n\t * - ARIA extension specs (e.g. doc-*, graphics-*) are commented with pointers\n", " *   to a separate spec directory.\n\t */\n\t/**\n\t * https://w3c.github.io/aria/#namefromcontent\n\t */\n\tfunction allowsNameFromContent(node: Element): boolean {\n\t  return [\n\t    \"button\",\n\t    \"cell\",\n\t    \"checkbox\",\n", "    \"columnheader\",\n\t    \"gridcell\",\n\t    \"heading\",\n\t    \"label\",\n\t    \"legend\",\n\t    \"link\",\n\t    \"menuitem\",\n\t    \"menuitemcheckbox\",\n\t    \"menuitemradio\",\n\t    \"option\",\n", "    \"radio\",\n\t    \"row\",\n\t    \"rowheader\",\n\t    \"switch\",\n\t    \"tab\",\n\t    \"tooltip\",\n\t    \"treeitem\",\n\t  ].includes(node.getAttribute(\"role\") ?? \"\");\n\t}\n\tfunction defaultAriaAttributes(role) {\n", "  switch (role) {\n\t    case \"combobox\": {\n\t      return \", not expanded, has popup listbox\";\n\t    }\n\t    case \"heading\": {\n\t      return \", level 2\";\n\t    }\n\t    case \"meter\": {\n\t      return \", max value 100, min value 0\";\n\t    }\n", "    case \"scrollbar\": {\n\t      return \", orientated vertically, max value 100, min value 0\";\n\t    }\n\t    case \"separator\": {\n\t      return \", orientated horizontally, max value 100, min value 0\";\n\t    }\n\t    case \"slider\": {\n\t      return \", orientated horizontally, max value 100, min value 0\";\n\t    }\n\t    case \"spinbutton\": {\n", "      return \", 0\";\n\t    }\n\t    case \"toolbar\": {\n\t      return \", orientated horizontally\";\n\t    }\n\t  }\n\t  return \"\";\n\t}\n\tdescribe(\"Simple Core ARIA Role Verification Tests\", () => {\n\t  test.each([\n", "    \"alert\",\n\t    \"alertdialog\",\n\t    \"application\",\n\t    \"article\",\n\t    // \"associationlist\" [AT-RISK: ARIA #1662] or possibly -> ./list-roles.html\n\t    // \"associationlistitemkey\" [AT-RISK: ARIA #1662] or possibly -> ./list-roles.html\n\t    // \"associationlistitemvalue\" [AT-RISK: ARIA #1662] or possibly -> ./list-roles.html\n\t    \"banner\",\n\t    \"blockquote\",\n\t    \"button\",\n", "    \"caption\",\n\t    // \"cell\" -> ./grid-roles.html\n\t    \"checkbox\",\n\t    \"code\",\n\t    // \"columnheader\" -> ./grid-roles.html\n\t    \"combobox\",\n\t    // \"command\" -> ./abstract-roles.html\n\t    // \"comment\" -> [AT-RISK: ARIA #1885]\n\t    \"complementary\",\n\t    // \"composite\" -> ./abstract-roles.html\n", "    \"contentinfo\",\n\t    \"definition\",\n\t    \"deletion\",\n\t    \"dialog\",\n\t    // \"directory\" -> FAIL. WONTFIX. Deprecated in ARIA 1.2; re-mapped to list role.\n\t    \"document\",\n\t    // doc-* roles -> TBD /dpub-aria or /dpub-aam\n\t    \"emphasis\",\n\t    \"feed\",\n\t    \"figure\",\n", "    // form -> ./form-roles.html\n\t    // \"generic\", -> FAIL. WONTFIX. Screen Readers don't announce the generic role.\n\t    // graphics-* roles -> /graphics-aria\n\t    // \"grid\" -> ./grid-roles.html\n\t    // \"gridcell\" -> ./grid-roles.html\n\t    \"group\",\n\t    \"heading\",\n\t    // \"image\" -> ./synonym-roles.html\n\t    // \"img\" -> ./synonym-roles.html\n\t    // \"input\" -> ./abstract-roles.html\n", "    \"insertion\",\n\t    // \"landmark\" -> ./abstract-roles.html\n\t    \"link\",\n\t    // \"list\" -> ./list-roles.html\n\t    // \"listitem\" -> ./list-roles.html\n\t    // \"listitemkey\" [See: ARIA #1662] or possibly -> ./list-roles.html\n\t    // \"listitemvalue\" [See: ARIA #1662] or possibly -> ./list-roles.html\n\t    // \"listbox\" -> ./listbox-roles.html\n\t    \"log\",\n\t    \"main\",\n", "    \"marquee\",\n\t    \"math\",\n\t    // \"menu\" -> ./menu-roles.html\n\t    // \"menuitem\" -> ./menu-roles.html\n\t    // \"menuitemcheckbox\" -> ./menu-roles.html\n\t    // \"menuitemradio\" -> ./menu-roles.html\n\t    // \"menubar\" -> ./menu-roles.html\n\t    \"meter\",\n\t    \"navigation\",\n\t    // \"none\" -> ./synonym-roles.html\n", "    \"note\",\n\t    // \"option\" -> ./listbox-roles.html\n\t    \"paragraph\",\n\t    // \"presentation\" -> ./synonym-roles.html\n\t    \"progressbar\",\n\t    \"radio\",\n\t    \"radiogroup\",\n\t    // \"range\" -> ./abstract-roles.html\n\t    // \"region\" -> ./region-roles.html\n\t    // \"roletype\" -> ./abstract-roles.html\n", "    // \"row\" -> ./grid-roles.html\n\t    // \"rowgroup\" -> ./grid-roles.html\n\t    // \"rowheader\" -> ./grid-roles.html\n\t    \"scrollbar\",\n\t    \"search\",\n\t    \"searchbox\",\n\t    // \"section\" -> ./abstract-roles.html\n\t    // \"sectionhead\" -> ./abstract-roles.html\n\t    // \"select\" -> ./abstract-roles.html\n\t    \"separator\",\n", "    \"slider\",\n\t    \"spinbutton\",\n\t    \"status\",\n\t    \"strong\",\n\t    // \"structure\" -> ./abstract-roles.html\n\t    \"subscript\",\n\t    /**\n\t     * Will be part of WAI-ARIA 1.3, which is still being drafted.\n\t     * REF: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/suggestion_role\n\t     */\n", "    // \"suggestion\",\n\t    \"superscript\",\n\t    \"switch\",\n\t    // \"tab\" -> ./tab-roles.html\n\t    // \"table\" -> ./grid-roles.html\n\t    // \"tablist\" -> ./tab-roles.html\n\t    // \"tabpanel\" -> ./tab-roles.html\n\t    \"term\",\n\t    \"textbox\",\n\t    \"time\",\n", "    \"timer\",\n\t    \"toolbar\",\n\t    \"tooltip\",\n\t    // \"tree\" -> ./tree-roles.html\n\t    // \"treeitem\" -> ./tree-roles.html\n\t    // \"treegrid\" -> ./treegrid-roles.html\n\t    // \"widget\" -> ./abstract-roles.html\n\t    // \"window\" -> ./abstract-roles.html\n\t  ])(\"%s\", async (role) => {\n\t    const container = document.createElement(\"div\");\n", "    container.appendChild(document.createTextNode(\"x\"));\n\t    container.setAttribute(\"role\", role);\n\t    container.id = `role_${role}`;\n\t    await virtual.start({ container });\n\t    expect(await virtual.lastSpokenPhrase()).toEqual(\n\t      `${role}${\n\t        allowsNameFromContent(container) ? \", x\" : \"\"\n\t      }${defaultAriaAttributes(role)}`\n\t    );\n\t    await virtual.stop();\n", "  });\n\t});\n"]}
{"filename": "test/wpt/accname/basic.int.test.ts", "chunked_list": ["import { virtual } from \"../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/basic.html\n\t */\n\tdescribe(\"Basic Tests\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div id='d' style='height: 100px; width: 100px' role=\"group\" aria-label=\"test label\"></div>\n\t    <h1 id=\"h\">test heading</h1>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests label accessible name\", async () => {\n\t    expect(await virtual.itemText()).toEqual(\"test label\");\n\t  });\n", "  test(\"tests heading accessible name\", async () => {\n\t    await virtual.next();\n\t    expect(await virtual.itemText()).toEqual(\"test heading\");\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_664-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_664-manual.html\n\t */\n\tdescribe(\"Description test case 664\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div>\n\t      <img id=\"test\" aria-describedby=\"ID1\" src=\"test.png\">\n\t    </div>\n", "    <div id=\"ID1\">foo</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n", "  });\n\t  test(\"tests description\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"img, foo\",\n\t      \"foo\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_665-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_665-manual.html\n\t */\n\tdescribe(\"Description test case 665\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div>\n\t      <img id=\"test\" aria-describedby=\"ID1\" src=\"test.png\">\n\t    </div>\n", "    <div id=\"ID1\" style=\"display:none\">foo</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    await virtual.next();\n\t    await virtual.next();\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n", "  test(\"tests description\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"img, foo\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_title-same-element-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_title-same-element-manual.html\n\t */\n\tdescribe(\"Description title-same-element\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div><input aria-label=\"Name\" id=\"test\" title=\"Title\" aria-describedby=\"ID1\" type=\"text\"></div>\n\t    <div id=\"ID1\">Description</div>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests description\", async () => {\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"textbox, Name, Description\",\n\t      \"Description\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_666-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_666-manual.html\n\t */\n\tdescribe(\"Description test case 666\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div>\n\t      <img id=\"test\" aria-describedby=\"ID1\" src=\"test.png\">\n\t    </div>\n", "    <div id=\"ID1\" role=\"presentation\">foo</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n", "  });\n\t  test(\"tests description\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"img, foo\",\n\t      \"foo\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_broken_reference-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_broken_reference-manual.html\n\t */\n\tdescribe(\"Description test case broken reference\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests description\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n", "      \"document\",\n\t      \"img, test\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_one_valid_reference-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_one_valid_reference-manual.html\n\t */\n\tdescribe(\"Description test case one valid reference\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1 t2 t3\">\n\t    <div id=\"t2\">foo</div>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests description\", async () => {\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"img, test, foo\",\n\t      \"foo\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_838-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_838-manual.html\n\t */\n\tdescribe(\"Description test case 838\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">\n\t    <div id=\"t1\" style=\"visibility:hidden\">foo</div>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests description\", async () => {\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"img, test, foo\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_773-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_773-manual.html\n\t */\n\tdescribe(\"Description test case 773\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">\n\t    <div id=\"t1\" style=\"display:none\">foo</div>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests description\", async () => {\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"img, test, foo\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_557-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_557-manual.html\n\t */\n\tdescribe(\"Description test case 557\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <img id=\"test\" src=\"foo.jpg\" aria-label=\"1\" alt=\"a\" title=\"t\"/>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests description\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n", "      \"document\",\n\t      \"img, 1, t\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_link-with-label-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_link-with-label-manual.html\n\t */\n\tdescribe(\"Description link-with-label\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <a id=\"test\" href=\"#\" aria-label=\"California\" title=\"San Francisco\" >United States</a>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests description\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n", "      \"document\",\n\t      \"link, California, San Francisco\",\n\t      \"United States\",\n\t      \"end of link, California, San Francisco\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_772-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_772-manual.html\n\t */\n\tdescribe(\"Description test case 772\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">\n\t    <div id=\"t1\">foo</div>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests description\", async () => {\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"img, test, foo\",\n\t      \"foo\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_test_case_774-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_test_case_774-manual.html\n\t */\n\tdescribe(\"Description test case 774\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <img src=\"foo.jpg\" id=\"test\" alt=\"test\" aria-describedby=\"t1\">\n\t    <span id=\"t1\" role=\"presentation\">foo</span>\n\t    `;\n", "    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests description\", async () => {\n", "    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"img, test, foo\",\n\t      \"foo\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_from_content_of_describedby_element-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_from_content_of_describedby_element-manual.html\n\t */\n\tdescribe(\"Description from content of describedby element\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <style>\n\t      .hidden { display: none; }\n\t    </style>\n", "    <input id=\"test\" type=\"text\" aria-label=\"Important stuff\" aria-describedby=\"descId\" />\n\t    <div>\n\t      <div id=\"descId\">\n\t        <span aria-hidden=\"true\"><i> Hello, </i></span>\n\t        <span>My</span> name is\n\t        <div><img src=\"file.jpg\" title=\"Bryan\" alt=\"\" role=\"presentation\" /></div>\n\t        <span role=\"presentation\" aria-label=\"Eli\">\n\t          <span aria-label=\"Garaventa\">Zambino</span>\n\t        </span>\n\t        <span>the weird.</span>\n", "        (QED)\n\t        <span class=\"hidden\"><i><b>and don't you forget it.</b></i></span>\n\t        <table>\n\t          <tr>\n\t            <td>Where</td>\n\t            <td style=\"visibility:hidden;\"><div>in</div></td>\n\t            <td><div style=\"display:none;\">the world</div></td>\n\t            <td>are my marbles?</td>\n\t          </tr>\n\t        </table>\n", "      </div>\n\t    </div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n", "    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests description\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      // TODO: FAIL incorrectly using Zambino where it should be using Eli\n\t      // Needs fix in https://github.com/eps1lon/dom-accessibility-api\n\t      \"textbox, Important stuff, My name is Zambino the weird. (QED) Where are my marbles?\",\n\t      \"My\",\n\t      \"name is\",\n", "      \"Bryan\",\n\t      \"Eli\",\n\t      \"Garaventa\",\n\t      \"Zambino\",\n\t      \"the weird.\",\n\t      \"(QED)\",\n\t      \"table\",\n\t      \"rowgroup\",\n\t      \"row, Where are my marbles?\",\n\t      \"cell, Where\",\n", "      \"cell\",\n\t      \"cell, are my marbles?\",\n\t      \"end of row, Where are my marbles?\",\n\t      \"end of rowgroup\",\n\t      \"end of table\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/manual/description_1.0_combobox-focusable-manual.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/manual/description_1.0_combobox-focusable-manual.html\n\t */\n\tdescribe(\"Description 1.0 combobox-focusable\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div id=\"test\" role=\"combobox\" tabindex=\"0\" title=\"Choose your language.\">\n\t      <span> English </span>\n\t    </div>\n", "    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n", "  test(\"tests description\", async () => {\n\t    expect(await virtual.spokenPhraseLog()).toEqual([\n\t      \"document\",\n\t      \"combobox, Choose your language., not expanded, has popup listbox\",\n\t      \"English\",\n\t      \"end of combobox, Choose your language., not expanded, has popup listbox\",\n\t      \"end of document\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/name/comp_hidden_not_referenced.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_hidden_not_referenced.html\n\t */\n\tdescribe(\"Name Comp: Hidden Not Referenced\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <h2 class=\"ex\" data-expectedlabel=\"heading label\" data-testname=\"heading with interior hidden node\">\n\t      heading\n\t      <span hidden>bogus</span>\n", "      label\n\t    </h2>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n", "    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests accessible name\", async () => {\n\t    expect(await virtual.itemTextLog()).toEqual([\n\t      \"\",\n\t      \"heading label\",\n\t      \"heading\", // TODO: this isn't ideal, probably should just omit the contents as it matches the parent (but slight owing to the bogus element)\n\t      \"label\",\n\t      \"heading label\",\n\t      \"\",\n", "    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/name/comp_embedded_control.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_embedded_control.html\n\t */\n\tdescribe(\"Name Comp: Embedded Control\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <label>\n\t      <input type=\"checkbox\" data-expectedlabel=\"Flash the screen 3 times\" data-testname=\"checkbox label with embedded textfield\" class=\"ex\">\n\t      Flash the screen\n", "      <input value=\"3\" aria-label=\"number of times\" data-expectedlabel=\"number of times\" data-testname=\"label of embedded textfield inside checkbox label\" class=\"ex\"> times\n\t    </label>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n", "    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests accessible name\", async () => {\n\t    expect(await virtual.itemTextLog()).toEqual([\n\t      \"\",\n\t      \"Flash the screen 3 times\",\n\t      \"Flash the screen\",\n\t      \"number of times, 3\",\n\t      \"times\",\n\t      \"\",\n", "    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/name/comp_labelledby.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_labelledby.html\n\t */\n\tdescribe(\"Name Comp: Labelledby\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div role=\"group\" aria-labelledby=\"h\" class=\"ex\" data-expectedlabel=\"div group label\" data-testname=\"div group explicitly labelledby heading\">\n\t      <h2 id=\"h\">div group label</h2>\n\t      <p>text inside div group</p>\n", "    </div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n", "  });\n\t  test(\"tests accessible name\", async () => {\n\t    expect(await virtual.itemTextLog()).toEqual([\n\t      \"\",\n\t      \"div group label\",\n\t      \"div group label\",\n\t      \"text inside div group\",\n\t      \"div group label\",\n\t      \"\",\n\t    ]);\n", "  });\n\t});\n"]}
{"filename": "test/wpt/accname/name/comp_host_language_label.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_host_language_label.html\n\t */\n\tdescribe(\"Name Comp: Host Language Label\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <label for=\"t\">label</label>\n\t    <input id=\"t\" data-expectedlabel=\"label\" data-testname=\"host language: label[for] input[type=text]\" class=\"ex\">\n\t    <!-- Todo: test all remaining input types with label[for] -->\n", "    <label>\n\t      <input type=\"checkbox\" data-expectedlabel=\"label\" data-testname=\"host language: label input[type=checkbox] encapsulation\" class=\"ex\">\n\t      label\n\t    </label>\n\t    <!-- Todo: test all remaining input types with label encapsulation -->\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n", "  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests accessible name\", async () => {\n\t    expect(await virtual.itemTextLog()).toEqual([\n\t      \"\",\n\t      \"label\",\n\t      \"label\",\n", "      \"label\",\n\t      \"label\",\n\t      \"\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/name/comp_name_from_content.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_name_from_content.html\n\t */\n\tdescribe(\"Name Comp: Name From Content\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <h1 data-expectedlabel=\"label\" data-testname=\"heading name from content\" class=\"ex\">label</h1>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests accessible name\", async () => {\n\t    expect(await virtual.itemTextLog()).toEqual([\"\", \"label\", \"\"]);\n", "  });\n\t});\n"]}
{"filename": "test/wpt/accname/name/comp_label.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_label.html\n\t */\n\tdescribe(\"Name Comp: Label\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <div aria-label=\"label\" data-expectedlabel=\"label\" data-testname=\"label valid on group\" role=\"group\" class=\"ex\">x</div>\n\t    `;\n\t    await virtual.start({ container: document.body });\n", "    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n\t    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests accessible name\", async () => {\n\t    expect(await virtual.itemTextLog()).toEqual([\n", "      \"\",\n\t      \"label\",\n\t      \"x\",\n\t      \"label\",\n\t      \"\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "test/wpt/accname/name/comp_text_node.int.test.ts", "chunked_list": ["import { virtual } from \"../../../../src\";\n\t/**\n\t * https://github.com/web-platform-tests/wpt/blob/master/accname/name/comp_text_node.html\n\t */\n\tdescribe(\"Name Comp: Text Node\", () => {\n\t  beforeEach(async () => {\n\t    document.body.innerHTML = `\n\t    <!-- Skipped (class=\"ex\" removed) until https://github.com/w3c/accname/issues/193 is resolved -->\n\t    <h2 class=\"ex-skipped\" data-expectedlabel=\"heading label\" data-testname=\"heading with text/comment/text nodes, no space\">\n\t      heading<!-- with non-text node splitting concatenated text nodes -->label<!-- [sic] no extra spaces around first comment -->\n", "    </h2>\n\t    <h2 class=\"ex\" data-expectedlabel=\"heading label\" data-testname=\"heading with text/comment/text nodes, with space\">\n\t      heading\n\t      <!-- comment node between text nodes with leading/trailing whitespace -->\n\t      label\n\t    </h2>\n\t    `;\n\t    await virtual.start({ container: document.body });\n\t    while ((await virtual.lastSpokenPhrase()) !== \"end of document\") {\n\t      await virtual.next();\n", "    }\n\t  });\n\t  afterEach(async () => {\n\t    await virtual.stop();\n\t    document.body.innerHTML = \"\";\n\t  });\n\t  test(\"tests accessible name\", async () => {\n\t    expect(await virtual.itemTextLog()).toEqual([\n\t      \"\",\n\t      \"headinglabel\", // TODO: FAIL should have whitespace\n", "      \"heading label\",\n\t      \"heading\", // TODO: FAIL should be same node\n\t      \"label\",\n\t      \"heading label\",\n\t      \"\",\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "src/getItemText.ts", "chunked_list": ["import { AccessibilityNode } from \"./createAccessibilityTree\";\n\texport const getItemText = (\n\t  accessibilityNode: Pick<\n\t    AccessibilityNode,\n\t    \"accessibleName\" | \"accessibleValue\"\n\t  >\n\t) => {\n\t  const { accessibleName, accessibleValue } = accessibilityNode;\n\t  const announcedValue =\n\t    accessibleName === accessibleValue ? \"\" : accessibleValue;\n", "  return [accessibleName, announcedValue].filter(Boolean).join(\", \");\n\t};\n"]}
{"filename": "src/getSpokenPhrase.ts", "chunked_list": ["import { AccessibilityNode } from \"./createAccessibilityTree\";\n\texport const getSpokenPhrase = (accessibilityNode: AccessibilityNode) => {\n\t  const {\n\t    accessibleAttributeLabels,\n\t    accessibleDescription,\n\t    accessibleName,\n\t    accessibleValue,\n\t    spokenRole,\n\t  } = accessibilityNode;\n\t  const announcedValue =\n", "    accessibleName === accessibleValue ? \"\" : accessibleValue;\n\t  return [\n\t    spokenRole,\n\t    accessibleName,\n\t    announcedValue,\n\t    accessibleDescription,\n\t    ...accessibleAttributeLabels,\n\t  ]\n\t    .filter(Boolean)\n\t    .join(\", \");\n", "};\n"]}
{"filename": "src/Virtual.ts", "chunked_list": ["import {\n\t  AccessibilityNode,\n\t  createAccessibilityTree,\n\t} from \"./createAccessibilityTree\";\n\timport {\n\t  CommandOptions,\n\t  MacOSModifiers,\n\t  ScreenReader,\n\t  WindowsModifiers,\n\t} from \"@guidepup/guidepup\";\n", "import { commands, VirtualCommandKey, VirtualCommands } from \"./commands\";\n\timport {\n\t  ERR_VIRTUAL_MISSING_CONTAINER,\n\t  ERR_VIRTUAL_NOT_STARTED,\n\t} from \"./errors\";\n\timport { getItemText } from \"./getItemText\";\n\timport { getSpokenPhrase } from \"./getSpokenPhrase\";\n\timport { isElement } from \"./isElement\";\n\timport userEvent from \"@testing-library/user-event\";\n\timport { VirtualCommandArgs } from \"./commands/types\";\n", "export interface StartOptions extends CommandOptions {\n\t  /**\n\t   * The bounding HTML element to use the Virtual Screen Reader in.\n\t   *\n\t   * To use the entire page pass `document.body`.\n\t   */\n\t  container: Node;\n\t}\n\tconst defaultUserEventOptions = {\n\t  delay: null,\n", "  skipHover: true,\n\t};\n\t/**\n\t * TODO: handle live region roles:\n\t *\n\t * - alert\n\t * - log\n\t * - marquee\n\t * - status\n\t * - timer\n", " * - alertdialog\n\t *\n\t * And handle live region attributes:\n\t *\n\t * - aria-atomic\n\t * - aria-busy\n\t * - aria-live\n\t * - aria-relevant\n\t *\n\t * When live regions are marked as polite, assistive technologies SHOULD\n", " * announce updates at the next graceful opportunity, such as at the end of\n\t * speaking the current sentence or when the user pauses typing. When live\n\t * regions are marked as assertive, assistive technologies SHOULD notify the\n\t * user immediately.\n\t *\n\t * REF:\n\t *\n\t * - https://w3c.github.io/aria/#live_region_roles\n\t * - https://w3c.github.io/aria/#window_roles\n\t * - https://w3c.github.io/aria/#attrs_liveregions\n", " * - https://w3c.github.io/aria/#aria-live\n\t */\n\t/**\n\t * TODO: When a modal element is displayed, assistive technologies SHOULD\n\t * navigate to the element unless focus has explicitly been set elsewhere. Some\n\t * assistive technologies limit navigation to the modal element's contents. If\n\t * focus moves to an element outside the modal element, assistive technologies\n\t * SHOULD NOT limit navigation to the modal element.\n\t *\n\t * REF: https://w3c.github.io/aria/#aria-modal\n", " */\n\tconst observeDOM = (function () {\n\t  const MutationObserver = window.MutationObserver;\n\t  return function observeDOM(\n\t    node: Node,\n\t    onChange: MutationCallback\n\t  ): () => void {\n\t    if (!isElement(node)) {\n\t      return;\n\t    }\n", "    if (MutationObserver) {\n\t      const mutationObserver = new MutationObserver(onChange);\n\t      mutationObserver.observe(node, {\n\t        attributes: true,\n\t        childList: true,\n\t        subtree: true,\n\t      });\n\t      return () => {\n\t        mutationObserver.disconnect();\n\t      };\n", "    }\n\t    return () => {\n\t      // gracefully fallback to not supporting Accessibility Tree refreshes if\n\t      // the DOM changes.\n\t    };\n\t  };\n\t})();\n\tasync function tick() {\n\t  return await new Promise<void>((resolve) => setTimeout(() => resolve()));\n\t}\n", "/**\n\t * TODO: When an assistive technology reading cursor moves from one article to\n\t * another, assistive technologies SHOULD set user agent focus on the article\n\t * that contains the reading cursor. If the reading cursor lands on a focusable\n\t * element inside the article, the assistive technology MAY set focus on that\n\t * element in lieu of setting focus on the containing article.\n\t *\n\t * REF: https://w3c.github.io/aria/#feed\n\t */\n\texport class Virtual implements ScreenReader {\n", "  #activeNode: AccessibilityNode | null = null;\n\t  #container: Node | null = null;\n\t  #itemTextLog: string[] = [];\n\t  #spokenPhraseLog: string[] = [];\n\t  #treeCache: AccessibilityNode[] | null = null;\n\t  #disconnectDOMObserver: () => void | null = null;\n\t  #checkContainer() {\n\t    if (!this.#container) {\n\t      throw new Error(ERR_VIRTUAL_NOT_STARTED);\n\t    }\n", "  }\n\t  #getAccessibilityTree() {\n\t    if (!this.#treeCache) {\n\t      this.#treeCache = createAccessibilityTree(this.#container);\n\t      this.#attachFocusListeners();\n\t    }\n\t    return this.#treeCache;\n\t  }\n\t  #invalidateTreeCache() {\n\t    this.#detachFocusListeners();\n", "    this.#treeCache = null;\n\t  }\n\t  #attachFocusListeners() {\n\t    this.#getAccessibilityTree().forEach((treeNode) => {\n\t      treeNode.node.addEventListener(\n\t        \"focus\",\n\t        this.#handleFocusChange.bind(this)\n\t      );\n\t    });\n\t  }\n", "  #detachFocusListeners() {\n\t    this.#getAccessibilityTree().forEach((treeNode) => {\n\t      treeNode.node.removeEventListener(\n\t        \"focus\",\n\t        this.#handleFocusChange.bind(this)\n\t      );\n\t    });\n\t  }\n\t  async #handleFocusChange({ target }: FocusEvent) {\n\t    await tick();\n", "    this.#invalidateTreeCache();\n\t    const tree = this.#getAccessibilityTree();\n\t    const nextIndex = tree.findIndex(({ node }) => node === target);\n\t    const newActiveNode = tree.at(nextIndex);\n\t    this.#updateState(newActiveNode, true);\n\t  }\n\t  #focusActiveElement() {\n\t    if (!this.#activeNode || !isElement(this.#activeNode.node)) {\n\t      return;\n\t    }\n", "    this.#activeNode.node.focus();\n\t  }\n\t  #updateState(accessibilityNode: AccessibilityNode, ignoreIfNoChange = false) {\n\t    const spokenPhrase = getSpokenPhrase(accessibilityNode);\n\t    const itemText = getItemText(accessibilityNode);\n\t    this.#activeNode = accessibilityNode;\n\t    if (\n\t      ignoreIfNoChange &&\n\t      spokenPhrase === this.#spokenPhraseLog.at(-1) &&\n\t      itemText === this.#itemTextLog.at(-1)\n", "    ) {\n\t      return;\n\t    }\n\t    this.#itemTextLog.push(itemText);\n\t    this.#spokenPhraseLog.push(spokenPhrase);\n\t  }\n\t  async #refreshState(ignoreIfNoChange) {\n\t    await tick();\n\t    this.#invalidateTreeCache();\n\t    const tree = this.#getAccessibilityTree();\n", "    const currentIndex = this.#getCurrentIndexByNode(tree);\n\t    const newActiveNode = tree.at(currentIndex);\n\t    this.#updateState(newActiveNode, ignoreIfNoChange);\n\t  }\n\t  #getCurrentIndex(tree: AccessibilityNode[]) {\n\t    return tree.findIndex(\n\t      ({\n\t        accessibleDescription,\n\t        accessibleName,\n\t        accessibleValue,\n", "        node,\n\t        role,\n\t        spokenRole,\n\t      }) =>\n\t        accessibleDescription === this.#activeNode?.accessibleDescription &&\n\t        accessibleName === this.#activeNode?.accessibleName &&\n\t        accessibleValue === this.#activeNode?.accessibleValue &&\n\t        node === this.#activeNode?.node &&\n\t        role === this.#activeNode?.role &&\n\t        spokenRole === this.#activeNode?.spokenRole\n", "    );\n\t  }\n\t  #getCurrentIndexByNode(tree: AccessibilityNode[]) {\n\t    return tree.findIndex(({ node }) => node === this.#activeNode?.node);\n\t  }\n\t  /**\n\t   * Getter for screen reader commands.\n\t   *\n\t   * Use with `await virtual.perform(command)`.\n\t   */\n", "  get commands() {\n\t    return Object.fromEntries<VirtualCommandKey>(\n\t      Object.keys(commands).map((command: VirtualCommandKey) => [\n\t        command,\n\t        command,\n\t      ])\n\t    ) as { [K in VirtualCommandKey]: K };\n\t  }\n\t  /**\n\t   * Detect whether the screen reader is supported for the current OS.\n", "   *\n\t   * @returns {Promise<boolean>}\n\t   */\n\t  async detect() {\n\t    return true;\n\t  }\n\t  /**\n\t   * Detect whether the screen reader is the default screen reader for the current OS.\n\t   *\n\t   * @returns {Promise<boolean>}\n", "   */\n\t  async default() {\n\t    return false;\n\t  }\n\t  /**\n\t   * Turn the screen reader on.\n\t   *\n\t   * @param {object} [options] Additional options.\n\t   */\n\t  async start({ container }: StartOptions = { container: null }) {\n", "    if (!container) {\n\t      throw new Error(ERR_VIRTUAL_MISSING_CONTAINER);\n\t    }\n\t    this.#container = container;\n\t    this.#disconnectDOMObserver = observeDOM(\n\t      container,\n\t      this.#invalidateTreeCache.bind(this)\n\t    );\n\t    const tree = this.#getAccessibilityTree();\n\t    if (!tree.length) {\n", "      return;\n\t    }\n\t    this.#updateState(tree[0]);\n\t    return;\n\t  }\n\t  /**\n\t   * Turn the screen reader off.\n\t   */\n\t  async stop() {\n\t    this.#disconnectDOMObserver?.();\n", "    this.#invalidateTreeCache();\n\t    this.#activeNode = null;\n\t    this.#container = null;\n\t    this.#itemTextLog = [];\n\t    this.#spokenPhraseLog = [];\n\t    return;\n\t  }\n\t  /**\n\t   * Move the screen reader cursor to the previous location.\n\t   */\n", "  async previous() {\n\t    this.#checkContainer();\n\t    await tick();\n\t    const tree = this.#getAccessibilityTree();\n\t    if (!tree.length) {\n\t      return;\n\t    }\n\t    const currentIndex = this.#getCurrentIndex(tree);\n\t    const nextIndex = currentIndex === -1 ? 0 : currentIndex - 1;\n\t    const newActiveNode = tree.at(nextIndex);\n", "    this.#updateState(newActiveNode);\n\t    return;\n\t  }\n\t  /**\n\t   * Move the screen reader cursor to the next location.\n\t   */\n\t  async next() {\n\t    this.#checkContainer();\n\t    await tick();\n\t    const tree = this.#getAccessibilityTree();\n", "    if (!tree.length) {\n\t      return;\n\t    }\n\t    const currentIndex = this.#getCurrentIndex(tree);\n\t    const nextIndex =\n\t      currentIndex === -1 || currentIndex === tree.length - 1\n\t        ? 0\n\t        : currentIndex + 1;\n\t    const newActiveNode = tree.at(nextIndex);\n\t    this.#updateState(newActiveNode);\n", "    return;\n\t  }\n\t  /**\n\t   * Perform the default action for the item in the screen reader cursor.\n\t   */\n\t  async act() {\n\t    this.#checkContainer();\n\t    await tick();\n\t    if (!this.#activeNode) {\n\t      return;\n", "    }\n\t    const target = this.#activeNode.node as HTMLElement;\n\t    // TODO: verify that is appropriate for all default actions\n\t    await userEvent.click(target, defaultUserEventOptions);\n\t    return;\n\t  }\n\t  /**\n\t   * Interact with the item under the screen reader cursor.\n\t   */\n\t  async interact() {\n", "    this.#checkContainer();\n\t    return;\n\t  }\n\t  /**\n\t   * Stop interacting with the current item.\n\t   */\n\t  async stopInteracting() {\n\t    this.#checkContainer();\n\t    return;\n\t  }\n", "  /**\n\t   * Press a key on the active item.\n\t   *\n\t   * `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)\n\t   * value or a single character to generate the text for. A superset of the `key` values can be found\n\t   * [on the MDN key values page](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:\n\t   *\n\t   * `F1` - `F20`, `Digit0` - `Digit9`, `KeyA` - `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,\n\t   * `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.\n\t   *\n", "   * Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta` (OS permitting).\n\t   *\n\t   * Holding down `Shift` will type the text that corresponds to the `key` in the upper case.\n\t   *\n\t   * If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective\n\t   * texts.\n\t   *\n\t   * Shortcuts such as `key: \"Control+f\"` or `key: \"Control+Shift+f\"` are supported as well. When specified with the\n\t   * modifier, modifier is pressed and being held while the subsequent key is being pressed.\n\t   *\n", "   * ```ts\n\t   * await virtual.press(\"Control+f\");\n\t   * ```\n\t   *\n\t   * @param {string} key Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.\n\t   */\n\t  async press(key: string) {\n\t    this.#checkContainer();\n\t    await tick();\n\t    if (!this.#activeNode) {\n", "      return;\n\t    }\n\t    const rawKeys = key.replaceAll(\"{\", \"{{\").replaceAll(\"[\", \"[[\").split(\"+\");\n\t    const modifiers = [];\n\t    const keys = [];\n\t    rawKeys.forEach((rawKey) => {\n\t      if (\n\t        typeof MacOSModifiers[rawKey] !== \"undefined\" ||\n\t        typeof WindowsModifiers[rawKey] !== \"undefined\"\n\t      ) {\n", "        modifiers.push(rawKey);\n\t      } else {\n\t        keys.push(rawKey);\n\t      }\n\t    });\n\t    const keyboardCommand = [\n\t      ...modifiers.map((modifier) => `{${modifier}>}`),\n\t      ...keys.map((key) => `{${key}}`),\n\t      ...modifiers.reverse().map((modifier) => `{/${modifier}}`),\n\t    ].join(\"\");\n", "    this.#focusActiveElement();\n\t    await userEvent.keyboard(keyboardCommand, defaultUserEventOptions);\n\t    await this.#refreshState(true);\n\t    return;\n\t  }\n\t  /**\n\t   * Type text into the active item.\n\t   *\n\t   * To press a special key, like `Control` or `ArrowDown`, use `virtual.press(key)`.\n\t   *\n", "   * ```ts\n\t   * await virtual.type(\"my-username\");\n\t   * await virtual.press(\"Enter\");\n\t   * ```\n\t   *\n\t   * @param {string} text Text to type into the active item.\n\t   */\n\t  async type(text: string) {\n\t    this.#checkContainer();\n\t    await tick();\n", "    if (!this.#activeNode) {\n\t      return;\n\t    }\n\t    const target = this.#activeNode.node as HTMLElement;\n\t    await userEvent.type(target, text, defaultUserEventOptions);\n\t    await this.#refreshState(true);\n\t    return;\n\t  }\n\t  /**\n\t   * Perform a screen reader command.\n", "   *\n\t   * @param {string} command Screen reader command.\n\t   * @param {object} [options] Command options.\n\t   */\n\t  async perform<\n\t    T extends VirtualCommandKey,\n\t    K extends Omit<Parameters<VirtualCommands[T]>[0], keyof VirtualCommandArgs>\n\t  >(command: T, options?: { [L in keyof K]: K[L] } & CommandOptions) {\n\t    this.#checkContainer();\n\t    await tick();\n", "    const tree = this.#getAccessibilityTree();\n\t    if (!tree.length) {\n\t      return;\n\t    }\n\t    const currentIndex = this.#getCurrentIndex(tree);\n\t    const nextIndex = commands[command]?.({\n\t      ...options,\n\t      container: this.#container,\n\t      currentIndex,\n\t      tree,\n", "    });\n\t    if (typeof nextIndex !== \"number\") {\n\t      return;\n\t    }\n\t    const newActiveNode = tree.at(nextIndex);\n\t    this.#updateState(newActiveNode);\n\t    return;\n\t  }\n\t  /**\n\t   * Click the mouse.\n", "   *\n\t   * @param {object} [options] Click options.\n\t   */\n\t  async click({ button = \"left\", clickCount = 1 } = {}) {\n\t    this.#checkContainer();\n\t    await tick();\n\t    if (!this.#activeNode) {\n\t      return;\n\t    }\n\t    const key = `[Mouse${button[0].toUpperCase()}${button.slice(1)}]`;\n", "    const keys = key.repeat(clickCount);\n\t    const target = this.#activeNode.node as HTMLElement;\n\t    await userEvent.pointer(\n\t      [{ target }, { keys, target }],\n\t      defaultUserEventOptions\n\t    );\n\t    return;\n\t  }\n\t  /**\n\t   * Get the last spoken phrase.\n", "   *\n\t   * @returns {Promise<string>} The last spoken phrase.\n\t   */\n\t  async lastSpokenPhrase() {\n\t    this.#checkContainer();\n\t    await tick();\n\t    return this.#spokenPhraseLog.at(-1) ?? \"\";\n\t  }\n\t  /**\n\t   * Get the text of the item in the screen reader cursor.\n", "   *\n\t   * @returns {Promise<string>} The item's text.\n\t   */\n\t  async itemText() {\n\t    this.#checkContainer();\n\t    await tick();\n\t    return this.#itemTextLog.at(-1) ?? \"\";\n\t  }\n\t  /**\n\t   * Get the log of all spoken phrases for this screen reader instance.\n", "   *\n\t   * @returns {Promise<string[]>} The spoken phrase log.\n\t   */\n\t  async spokenPhraseLog() {\n\t    this.#checkContainer();\n\t    await tick();\n\t    return this.#spokenPhraseLog;\n\t  }\n\t  /**\n\t   * Get the log of all visited item text for this screen reader instance.\n", "   *\n\t   * @returns {Promise<string[]>} The item text log.\n\t   */\n\t  async itemTextLog() {\n\t    this.#checkContainer();\n\t    await tick();\n\t    return this.#itemTextLog;\n\t  }\n\t}\n"]}
{"filename": "src/getNodeByIdRef.ts", "chunked_list": ["import { isElement } from \"./isElement\";\n\texport function getNodeByIdRef({ container, idRef }) {\n\t  if (!isElement(container) || !idRef) {\n\t    return null;\n\t  }\n\t  return container.querySelector(`#${idRef}`);\n\t}\n"]}
{"filename": "src/errors.ts", "chunked_list": ["export const ERR_NOT_IMPLEMENTED = \"Not implemented\";\n\texport const ERR_VIRTUAL_MISSING_CONTAINER = \"A container was not provided\";\n\texport const ERR_VIRTUAL_NOT_STARTED = \"Virtual screen reader was not started\";\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { StartOptions, Virtual } from \"./Virtual\";\n\texport const virtual = new Virtual();\n\ttype _Virtual = typeof virtual;\n\texport { StartOptions, _Virtual as Virtual };\n"]}
{"filename": "src/createAccessibilityTree.ts", "chunked_list": ["import { getIdRefsByAttribute } from \"./getIdRefsByAttribute\";\n\timport { getNodeAccessibilityData } from \"./getNodeAccessibilityData\";\n\timport { getNodeByIdRef } from \"./getNodeByIdRef\";\n\timport { HTMLElementWithValue } from \"./getNodeAccessibilityData/getAccessibleValue\";\n\timport { isElement } from \"./isElement\";\n\timport { isInaccessible } from \"dom-accessibility-api\";\n\texport interface AccessibilityNode {\n\t  accessibleAttributeLabels: string[];\n\t  accessibleDescription: string;\n\t  accessibleName: string;\n", "  accessibleValue: string;\n\t  allowedAccessibilityChildRoles: string[][];\n\t  alternateReadingOrderParents: Node[];\n\t  childrenPresentational: boolean;\n\t  node: Node;\n\t  parent: Node | null;\n\t  role: string;\n\t  spokenRole: string;\n\t}\n\tinterface AccessibilityNodeTree extends AccessibilityNode {\n", "  children: AccessibilityNodeTree[];\n\t}\n\tinterface AccessibilityContext {\n\t  alternateReadingOrderMap: Map<Node, Set<Node>>;\n\t  container: Node;\n\t  ownedNodes: Set<Node>;\n\t  visitedNodes: Set<Node>;\n\t}\n\tfunction addAlternateReadingOrderNodes(\n\t  node: Element,\n", "  alternateReadingOrderMap: Map<Node, Set<Node>>,\n\t  container: Element\n\t) {\n\t  const idRefs = getIdRefsByAttribute({\n\t    attributeName: \"aria-flowto\",\n\t    node,\n\t  });\n\t  idRefs.forEach((idRef) => {\n\t    const childNode = getNodeByIdRef({ container, idRef });\n\t    if (!childNode) {\n", "      return;\n\t    }\n\t    const currentParentNodes =\n\t      alternateReadingOrderMap.get(childNode) ?? new Set<Node>();\n\t    currentParentNodes.add(node);\n\t    alternateReadingOrderMap.set(childNode, currentParentNodes);\n\t  });\n\t}\n\tfunction mapAlternateReadingOrder(node: Node) {\n\t  const alternateReadingOrderMap = new Map<Node, Set<Node>>();\n", "  if (!isElement(node)) {\n\t    return alternateReadingOrderMap;\n\t  }\n\t  node\n\t    .querySelectorAll(\"[aria-flowto]\")\n\t    .forEach((parentNode) =>\n\t      addAlternateReadingOrderNodes(parentNode, alternateReadingOrderMap, node)\n\t    );\n\t  return alternateReadingOrderMap;\n\t}\n", "function addOwnedNodes(\n\t  node: Element,\n\t  ownedNodes: Set<Node>,\n\t  container: Element\n\t) {\n\t  const idRefs = getIdRefsByAttribute({\n\t    attributeName: \"aria-owns\",\n\t    node,\n\t  });\n\t  idRefs.forEach((idRef) => {\n", "    const ownedNode = getNodeByIdRef({ container, idRef });\n\t    if (!!ownedNode && !ownedNodes.has(ownedNode)) {\n\t      ownedNodes.add(ownedNode);\n\t    }\n\t  });\n\t}\n\tfunction getAllOwnedNodes(node: Node) {\n\t  const ownedNodes = new Set<Node>();\n\t  if (!isElement(node)) {\n\t    return ownedNodes;\n", "  }\n\t  node\n\t    .querySelectorAll(\"[aria-owns]\")\n\t    .forEach((owningNode) => addOwnedNodes(owningNode, ownedNodes, node));\n\t  return ownedNodes;\n\t}\n\tfunction getOwnedNodes(node: Node, container: Node) {\n\t  const ownedNodes = new Set<Node>();\n\t  if (!isElement(node) || !isElement(container)) {\n\t    return ownedNodes;\n", "  }\n\t  addOwnedNodes(node, ownedNodes, container);\n\t  return ownedNodes;\n\t}\n\tfunction isHiddenFromAccessibilityTree(node: Node) {\n\t  if (!node) {\n\t    return true;\n\t  }\n\t  if (node.nodeType === Node.TEXT_NODE && !!node.textContent.trim()) {\n\t    return false;\n", "  }\n\t  return !isElement(node) || isInaccessible(node);\n\t}\n\tfunction shouldIgnoreChildren(tree: AccessibilityNodeTree) {\n\t  const { accessibleName, node } = tree;\n\t  if (!accessibleName) {\n\t    return false;\n\t  }\n\t  return (\n\t    // TODO: improve comparison on whether the children are superfluous\n", "    // to include.\n\t    accessibleName ===\n\t    (\n\t      node.textContent ||\n\t      `${(node as HTMLElementWithValue).value}` ||\n\t      \"\"\n\t    )?.trim()\n\t  );\n\t}\n\tfunction flattenTree(tree: AccessibilityNodeTree): AccessibilityNode[] {\n", "  const { children, ...treeNode } = tree;\n\t  const isAnnounced =\n\t    !!treeNode.accessibleName ||\n\t    !!treeNode.accessibleDescription ||\n\t    treeNode.accessibleAttributeLabels.length > 0 ||\n\t    !!treeNode.spokenRole;\n\t  const ignoreChildren = shouldIgnoreChildren(tree);\n\t  const flattenedTree = ignoreChildren\n\t    ? []\n\t    : [...children.flatMap((child) => flattenTree(child))];\n", "  const isRoleContainer =\n\t    !!flattenedTree.length && !ignoreChildren && !!treeNode.spokenRole;\n\t  if (isAnnounced) {\n\t    flattenedTree.unshift(treeNode);\n\t  }\n\t  if (isRoleContainer) {\n\t    flattenedTree.push({\n\t      accessibleAttributeLabels: treeNode.accessibleAttributeLabels,\n\t      accessibleDescription: treeNode.accessibleDescription,\n\t      accessibleName: treeNode.accessibleName,\n", "      accessibleValue: treeNode.accessibleValue,\n\t      allowedAccessibilityChildRoles: treeNode.allowedAccessibilityChildRoles,\n\t      alternateReadingOrderParents: treeNode.alternateReadingOrderParents,\n\t      childrenPresentational: treeNode.childrenPresentational,\n\t      node: treeNode.node,\n\t      parent: treeNode.parent,\n\t      role: treeNode.role,\n\t      spokenRole: `end of ${treeNode.spokenRole}`,\n\t    });\n\t  }\n", "  return flattenedTree;\n\t}\n\tfunction growTree(\n\t  node: Node,\n\t  tree: AccessibilityNodeTree,\n\t  {\n\t    alternateReadingOrderMap,\n\t    container,\n\t    ownedNodes,\n\t    visitedNodes,\n", "  }: AccessibilityContext\n\t): AccessibilityNodeTree {\n\t  /**\n\t   * Authors MUST NOT create circular references with aria-owns. In the case of\n\t   * authoring error with aria-owns, the user agent MAY ignore some aria-owns\n\t   * element references in order to build a consistent model of the content.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#aria-owns\n\t   */\n\t  if (visitedNodes.has(node)) {\n", "    return tree;\n\t  }\n\t  visitedNodes.add(node);\n\t  node.childNodes.forEach((childNode) => {\n\t    if (isHiddenFromAccessibilityTree(childNode)) {\n\t      return;\n\t    }\n\t    // REF: https://github.com/w3c/aria/issues/1817#issuecomment-1261602357\n\t    if (ownedNodes.has(childNode)) {\n\t      return;\n", "    }\n\t    const alternateReadingOrderParents = alternateReadingOrderMap.has(childNode)\n\t      ? Array.from(alternateReadingOrderMap.get(childNode))\n\t      : [];\n\t    const {\n\t      accessibleAttributeLabels,\n\t      accessibleDescription,\n\t      accessibleName,\n\t      accessibleValue,\n\t      allowedAccessibilityChildRoles,\n", "      childrenPresentational,\n\t      role,\n\t      spokenRole,\n\t    } = getNodeAccessibilityData({\n\t      allowedAccessibilityRoles: tree.allowedAccessibilityChildRoles,\n\t      alternateReadingOrderParents,\n\t      container,\n\t      node: childNode,\n\t      inheritedImplicitPresentational: tree.childrenPresentational,\n\t    });\n", "    tree.children.push(\n\t      growTree(\n\t        childNode,\n\t        {\n\t          accessibleAttributeLabels,\n\t          accessibleDescription,\n\t          accessibleName,\n\t          accessibleValue,\n\t          allowedAccessibilityChildRoles,\n\t          alternateReadingOrderParents,\n", "          children: [],\n\t          childrenPresentational,\n\t          node: childNode,\n\t          parent: node,\n\t          role,\n\t          spokenRole,\n\t        },\n\t        { alternateReadingOrderMap, container, ownedNodes, visitedNodes }\n\t      )\n\t    );\n", "  });\n\t  /**\n\t   * If an element has both aria-owns and DOM children then the order of the\n\t   * child elements with respect to the parent/child relationship is the DOM\n\t   * children first, then the elements referenced in aria-owns. If the author\n\t   * intends that the DOM children are not first, then list the DOM children in\n\t   * aria-owns in the desired order. Authors SHOULD NOT use aria-owns as a\n\t   * replacement for the DOM hierarchy. If the relationship is represented in\n\t   * the DOM, do not use aria-owns.\n\t   *\n", "   * REF: https://w3c.github.io/aria/#aria-owns\n\t   */\n\t  const ownedChildNodes = getOwnedNodes(node, container);\n\t  ownedChildNodes.forEach((childNode) => {\n\t    if (isHiddenFromAccessibilityTree(childNode)) {\n\t      return;\n\t    }\n\t    const alternateReadingOrderParents = alternateReadingOrderMap.has(childNode)\n\t      ? Array.from(alternateReadingOrderMap.get(childNode))\n\t      : [];\n", "    const {\n\t      accessibleAttributeLabels,\n\t      accessibleDescription,\n\t      accessibleName,\n\t      accessibleValue,\n\t      allowedAccessibilityChildRoles,\n\t      childrenPresentational,\n\t      role,\n\t      spokenRole,\n\t    } = getNodeAccessibilityData({\n", "      allowedAccessibilityRoles: tree.allowedAccessibilityChildRoles,\n\t      alternateReadingOrderParents,\n\t      container,\n\t      node: childNode,\n\t      inheritedImplicitPresentational: tree.childrenPresentational,\n\t    });\n\t    tree.children.push(\n\t      growTree(\n\t        childNode,\n\t        {\n", "          accessibleAttributeLabels,\n\t          accessibleDescription,\n\t          accessibleName,\n\t          accessibleValue,\n\t          allowedAccessibilityChildRoles,\n\t          alternateReadingOrderParents,\n\t          children: [],\n\t          childrenPresentational,\n\t          node: childNode,\n\t          parent: node,\n", "          role,\n\t          spokenRole,\n\t        },\n\t        { alternateReadingOrderMap, container, ownedNodes, visitedNodes }\n\t      )\n\t    );\n\t  });\n\t  return tree;\n\t}\n\texport function createAccessibilityTree(node: Node) {\n", "  if (isHiddenFromAccessibilityTree(node)) {\n\t    return [];\n\t  }\n\t  const alternateReadingOrderMap = mapAlternateReadingOrder(node);\n\t  const ownedNodes = getAllOwnedNodes(node);\n\t  const visitedNodes = new Set<Node>();\n\t  const {\n\t    accessibleAttributeLabels,\n\t    accessibleDescription,\n\t    accessibleName,\n", "    accessibleValue,\n\t    allowedAccessibilityChildRoles,\n\t    childrenPresentational,\n\t    role,\n\t    spokenRole,\n\t  } = getNodeAccessibilityData({\n\t    allowedAccessibilityRoles: [],\n\t    alternateReadingOrderParents: [],\n\t    container: node,\n\t    node,\n", "    inheritedImplicitPresentational: false,\n\t  });\n\t  const tree = growTree(\n\t    node,\n\t    {\n\t      accessibleAttributeLabels,\n\t      accessibleDescription,\n\t      accessibleName,\n\t      accessibleValue,\n\t      allowedAccessibilityChildRoles,\n", "      alternateReadingOrderParents: [],\n\t      children: [],\n\t      childrenPresentational,\n\t      node,\n\t      parent: null,\n\t      role,\n\t      spokenRole,\n\t    },\n\t    {\n\t      alternateReadingOrderMap,\n", "      container: node,\n\t      ownedNodes,\n\t      visitedNodes,\n\t    }\n\t  );\n\t  return flattenTree(tree);\n\t}\n"]}
{"filename": "src/getIdRefsByAttribute.ts", "chunked_list": ["export function getIdRefsByAttribute({ attributeName, node }) {\n\t  return (node.getAttribute(attributeName) ?? \"\")\n\t    .trim()\n\t    .split(\" \")\n\t    .filter(Boolean);\n\t}\n"]}
{"filename": "src/isElement.ts", "chunked_list": ["export function isElement(node: Node): node is HTMLElement {\n\t  return node.nodeType === Node.ELEMENT_NODE;\n\t}\n"]}
{"filename": "src/commands/jumpToControlledElement.ts", "chunked_list": ["import { getNextIndexByIdRefsAttribute } from \"./getNextIndexByIdRefsAttribute\";\n\timport { VirtualCommandArgs } from \"./types\";\n\texport interface JumpToControlledElementCommandArgs extends VirtualCommandArgs {\n\t  index?: number;\n\t}\n\t/**\n\t * aria-controls:\n\t *\n\t * Identifies the element (or elements) whose contents or presence\n\t * are controlled by the current element. See related aria-owns.\n", " *\n\t * REF: https://w3c.github.io/aria/#aria-controls\n\t *\n\t * MUST requirement:\n\t *\n\t * The controlled element might not be close to the element with\n\t * aria-controls and the user might find it convenient to jump directly to\n\t * the controlled element.\n\t *\n\t * REF: https://a11ysupport.io/tech/aria/aria-controls_attribute\n", " */\n\texport function jumpToControlledElement({\n\t  index = 0,\n\t  container,\n\t  currentIndex,\n\t  tree,\n\t}: JumpToControlledElementCommandArgs) {\n\t  return getNextIndexByIdRefsAttribute({\n\t    attributeName: \"aria-controls\",\n\t    index,\n", "    container,\n\t    currentIndex,\n\t    tree,\n\t  });\n\t}\n"]}
{"filename": "src/commands/getElementNode.ts", "chunked_list": ["import { AccessibilityNode } from \"../createAccessibilityTree\";\n\timport { isElement } from \"../isElement\";\n\texport function getElementNode(accessibilityNode: AccessibilityNode) {\n\t  const { node } = accessibilityNode;\n\t  if (node && isElement(node)) {\n\t    return node;\n\t  }\n\t  return accessibilityNode.parent;\n\t}\n"]}
{"filename": "src/commands/moveToPreviousAlternateReadingOrderElement.ts", "chunked_list": ["import { isElement } from \"../isElement\";\n\timport { VirtualCommandArgs } from \"./types\";\n\texport interface MoveToNextAlternateReadingOrderElement\n\t  extends VirtualCommandArgs {\n\t  index?: number;\n\t}\n\t/**\n\t * aria-flowto:\n\t *\n\t * However, when aria-flowto is provided with multiple ID\n", " * references, assistive technologies SHOULD present the referenced\n\t * elements as path choices.\n\t *\n\t * In the case of one or more ID references, user agents or assistive\n\t * technologies SHOULD give the user the option of navigating to any of the\n\t * targeted elements. The name of the path can be determined by the name of\n\t * the target element of the aria-flowto attribute. Accessibility APIs can\n\t * provide named path relationships.\n\t *\n\t * REF: https://w3c.github.io/aria/#aria-flowto\n", " *\n\t * MUST requirements:\n\t *\n\t * The reading order goes both directions, and a user needs to be aware of the\n\t * alternate reading order so that they can invoke the functionality.\n\t *\n\t * The reading order goes both directions, and a user needs to be able to\n\t * travel backwards through their chosen reading order.\n\t *\n\t * REF: https://a11ysupport.io/tech/aria/aria-flowto_attribute\n", " */\n\texport function moveToPreviousAlternateReadingOrderElement({\n\t  index = 0,\n\t  container,\n\t  currentIndex,\n\t  tree,\n\t}: MoveToNextAlternateReadingOrderElement) {\n\t  if (!isElement(container)) {\n\t    return;\n\t  }\n", "  const { alternateReadingOrderParents } = tree.at(currentIndex);\n\t  const targetNode = alternateReadingOrderParents[index];\n\t  if (!targetNode) {\n\t    return;\n\t  }\n\t  return tree.findIndex(({ node }) => node === targetNode);\n\t}\n"]}
{"filename": "src/commands/getNextIndexByRole.ts", "chunked_list": ["import { VirtualCommandArgs } from \"./types\";\n\texport type GetNextIndexByRoleArgs = Omit<VirtualCommandArgs, \"container\">;\n\texport function getNextIndexByRole(roles: Readonly<string[]>) {\n\t  return function getNextIndex({ currentIndex, tree }: GetNextIndexByRoleArgs) {\n\t    const reorderedTree = tree\n\t      .slice(currentIndex + 1)\n\t      .concat(tree.slice(0, currentIndex + 1));\n\t    const accessibilityNode = reorderedTree.find(\n\t      (node) =>\n\t        roles.includes(node.role) && !node.spokenRole.startsWith(\"end of\")\n", "    );\n\t    if (!accessibilityNode) {\n\t      return null;\n\t    }\n\t    return tree.findIndex((node) => node === accessibilityNode);\n\t  };\n\t}\n"]}
{"filename": "src/commands/types.ts", "chunked_list": ["import { AccessibilityNode } from \"../createAccessibilityTree\";\n\texport interface VirtualCommandArgs {\n\t  currentIndex: number;\n\t  container: Node;\n\t  tree: AccessibilityNode[];\n\t}\n"]}
{"filename": "src/commands/getPreviousIndexByRole.ts", "chunked_list": ["import { VirtualCommandArgs } from \"./types\";\n\texport type GetPreviousIndexByRoleArgs = Omit<VirtualCommandArgs, \"container\">;\n\texport function getPreviousIndexByRole(roles: Readonly<string[]>) {\n\t  return function getPreviousIndex({\n\t    currentIndex,\n\t    tree,\n\t  }: GetPreviousIndexByRoleArgs) {\n\t    const reorderedTree = tree\n\t      .slice(0, currentIndex)\n\t      .reverse()\n", "      .concat(tree.slice(currentIndex).reverse());\n\t    const accessibilityNode = reorderedTree.find(\n\t      (node) =>\n\t        roles.includes(node.role) && !node.spokenRole.startsWith(\"end of\")\n\t    );\n\t    if (!accessibilityNode) {\n\t      return null;\n\t    }\n\t    return tree.findIndex((node) => node === accessibilityNode);\n\t  };\n", "}\n"]}
{"filename": "src/commands/jumpToDetailsElement.ts", "chunked_list": ["import { getNextIndexByIdRefsAttribute } from \"./getNextIndexByIdRefsAttribute\";\n\timport { VirtualCommandArgs } from \"./types\";\n\t/**\n\t * aria-details:\n\t *\n\t * REF: https://w3c.github.io/aria/#aria-details\n\t *\n\t * SHOULD requirement:\n\t *\n\t * If the details are not adjacent to the element with aria-details, it might\n", " * be helpful to jump directly to the reference or have it conveyed.\n\t *\n\t * REF: https://a11ysupport.io/tech/aria/aria-details_attribute\n\t */\n\texport function jumpToDetailsElement({\n\t  container,\n\t  currentIndex,\n\t  tree,\n\t}: VirtualCommandArgs) {\n\t  return getNextIndexByIdRefsAttribute({\n", "    attributeName: \"aria-details\",\n\t    index: 0,\n\t    container,\n\t    currentIndex,\n\t    tree,\n\t  });\n\t}\n"]}
{"filename": "src/commands/index.ts", "chunked_list": ["import { getNextIndexByRole } from \"./getNextIndexByRole\";\n\timport { getPreviousIndexByRole } from \"./getPreviousIndexByRole\";\n\timport { jumpToControlledElement } from \"./jumpToControlledElement\";\n\timport { jumpToDetailsElement } from \"./jumpToDetailsElement\";\n\timport { moveToNextAlternateReadingOrderElement } from \"./moveToNextAlternateReadingOrderElement\";\n\timport { moveToPreviousAlternateReadingOrderElement } from \"./moveToPreviousAlternateReadingOrderElement\";\n\timport { VirtualCommandArgs } from \"./types\";\n\tconst quickLandmarkNavigationRoles = [\n\t  /**\n\t   * Assistive technologies SHOULD enable users to quickly navigate to\n", "   * elements with role banner.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#banner\n\t   */\n\t  \"banner\",\n\t  /**\n\t   * Assistive technologies SHOULD enable users to quickly navigate to\n\t   * elements with role complementary.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#complementary\n", "   */\n\t  \"complementary\",\n\t  /**\n\t   * Assistive technologies SHOULD enable users to quickly navigate to\n\t   * elements with role contentinfo.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#contentinfo\n\t   */\n\t  \"contentinfo\",\n\t  /**\n", "   * Assistive technologies SHOULD enable users to quickly navigate to\n\t   * figures.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#figure\n\t   */\n\t  \"figure\",\n\t  /**\n\t   * Assistive technologies SHOULD enable users to quickly navigate to\n\t   * elements with role form.\n\t   *\n", "   * REF: https://w3c.github.io/aria/#form\n\t   */\n\t  \"form\",\n\t  /**\n\t   * Assistive technologies SHOULD enable users to quickly navigate to\n\t   * elements with role main.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#main\n\t   */\n\t  \"main\",\n", "  /**\n\t   * Assistive technologies SHOULD enable users to quickly navigate to\n\t   * elements with role navigation.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#navigation\n\t   */\n\t  \"navigation\",\n\t  /**\n\t   * Assistive technologies SHOULD enable users to quickly navigate to\n\t   * elements with role region.\n", "   *\n\t   * REF: https://w3c.github.io/aria/#region\n\t   */\n\t  \"region\",\n\t  /**\n\t   * Assistive technologies SHOULD enable users to quickly navigate to\n\t   * elements with role search.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#search\n\t   */\n", "  \"search\",\n\t] as const;\n\tconst quickLandmarkNavigationCommands = quickLandmarkNavigationRoles.reduce<\n\t  Record<string, unknown>\n\t>((accumulatedCommands, role) => {\n\t  const moveToNextCommand = `moveToNext${role.at(0).toUpperCase()}${role.slice(\n\t    1\n\t  )}`;\n\t  const moveToPreviousCommand = `moveToPrevious${role\n\t    .at(0)\n", "    .toUpperCase()}${role.slice(1)}`;\n\t  return {\n\t    ...accumulatedCommands,\n\t    [moveToNextCommand]: getNextIndexByRole([role]),\n\t    [moveToPreviousCommand]: getPreviousIndexByRole([role]),\n\t  };\n\t}, {}) as {\n\t  [K in\n\t    | `moveToNext${Capitalize<(typeof quickLandmarkNavigationRoles)[number]>}`\n\t    | `moveToPrevious${Capitalize<\n", "        (typeof quickLandmarkNavigationRoles)[number]\n\t      >}`]: (args: VirtualCommandArgs) => number | null;\n\t};\n\texport const commands = {\n\t  jumpToControlledElement,\n\t  jumpToDetailsElement,\n\t  moveToNextAlternateReadingOrderElement,\n\t  moveToPreviousAlternateReadingOrderElement,\n\t  ...quickLandmarkNavigationCommands,\n\t  moveToNextLandmark: getNextIndexByRole(quickLandmarkNavigationRoles),\n", "  moveToPreviousLandmark: getPreviousIndexByRole(quickLandmarkNavigationRoles),\n\t};\n\texport type VirtualCommands = {\n\t  [K in keyof typeof commands]: (typeof commands)[K];\n\t};\n\texport type VirtualCommandKey = keyof VirtualCommands;\n"]}
{"filename": "src/commands/moveToNextAlternateReadingOrderElement.ts", "chunked_list": ["import { getNextIndexByIdRefsAttribute } from \"./getNextIndexByIdRefsAttribute\";\n\timport { VirtualCommandArgs } from \"./types\";\n\texport interface MoveToNextAlternateReadingOrderElement\n\t  extends VirtualCommandArgs {\n\t  index?: number;\n\t}\n\t/**\n\t * aria-flowto:\n\t *\n\t * However, when aria-flowto is provided with multiple ID\n", " * references, assistive technologies SHOULD present the referenced\n\t * elements as path choices.\n\t *\n\t * In the case of one or more ID references, user agents or assistive\n\t * technologies SHOULD give the user the option of navigating to any of the\n\t * targeted elements. The name of the path can be determined by the name of\n\t * the target element of the aria-flowto attribute. Accessibility APIs can\n\t * provide named path relationships.\n\t *\n\t * REF: https://w3c.github.io/aria/#aria-flowto\n", " *\n\t * MUST requirements:\n\t *\n\t * A user needs to understand that the current element flows to another element\n\t * so that they can invoke the functionality.\n\t *\n\t * A user needs to be able to follow the alternate reading order.\n\t *\n\t * REF: https://a11ysupport.io/tech/aria/aria-flowto_attribute\n\t */\n", "export function moveToNextAlternateReadingOrderElement({\n\t  index,\n\t  container,\n\t  currentIndex,\n\t  tree,\n\t}: MoveToNextAlternateReadingOrderElement) {\n\t  return getNextIndexByIdRefsAttribute({\n\t    attributeName: \"aria-flowto\",\n\t    index,\n\t    container,\n", "    currentIndex,\n\t    tree,\n\t  });\n\t}\n"]}
{"filename": "src/commands/getNextIndexByIdRefsAttribute.ts", "chunked_list": ["import { getElementNode } from \"./getElementNode\";\n\timport { getIdRefsByAttribute } from \"../getIdRefsByAttribute\";\n\timport { getNodeByIdRef } from \"../getNodeByIdRef\";\n\timport { isElement } from \"../isElement\";\n\timport { VirtualCommandArgs } from \"./types\";\n\texport interface GetNextIndexByIdRefsAttributeArgs extends VirtualCommandArgs {\n\t  attributeName: string;\n\t  index?: number;\n\t}\n\texport function getNextIndexByIdRefsAttribute({\n", "  attributeName,\n\t  index = 0,\n\t  container,\n\t  currentIndex,\n\t  tree,\n\t}: GetNextIndexByIdRefsAttributeArgs) {\n\t  if (!isElement(container)) {\n\t    return;\n\t  }\n\t  const currentAccessibilityNode = tree.at(currentIndex);\n", "  const currentNode = getElementNode(currentAccessibilityNode);\n\t  const idRefs = getIdRefsByAttribute({\n\t    attributeName,\n\t    node: currentNode,\n\t  });\n\t  const idRef = idRefs[index];\n\t  const targetNode = getNodeByIdRef({ container, idRef });\n\t  if (!targetNode) {\n\t    return;\n\t  }\n", "  const nodeIndex = tree.findIndex(({ node }) => node === targetNode);\n\t  if (nodeIndex !== -1) {\n\t    return nodeIndex;\n\t  }\n\t  const nodeIndexByParent = tree.findIndex(\n\t    ({ parent }) => parent === targetNode\n\t  );\n\t  if (nodeIndexByParent !== -1) {\n\t    return nodeIndexByParent;\n\t  }\n", "  return;\n\t}\n"]}
{"filename": "src/getNodeAccessibilityData/getRole.ts", "chunked_list": ["import { getRole as getImplicitRole } from \"dom-accessibility-api\";\n\timport { getRoles } from \"@testing-library/dom\";\n\timport { isElement } from \"../isElement\";\n\timport { roles } from \"aria-query\";\n\texport const presentationRoles = [\"presentation\", \"none\"];\n\tconst allowedNonAbstractRoles = roles\n\t  .entries()\n\t  .filter(([, { abstract }]) => !abstract)\n\t  .map(([key]) => key) as string[];\n\tconst rolesRequiringName = [\"form\", \"region\"];\n", "export const globalStatesAndProperties = [\n\t  \"aria-atomic\",\n\t  \"aria-braillelabel\",\n\t  \"aria-brailleroledescription\",\n\t  \"aria-busy\",\n\t  \"aria-controls\",\n\t  \"aria-describedby\",\n\t  \"aria-description\",\n\t  \"aria-details\",\n\t  \"aria-dropeffect\",\n", "  \"aria-flowto\",\n\t  \"aria-grabbed\",\n\t  \"aria-hidden\",\n\t  \"aria-keyshortcuts\",\n\t  \"aria-label\",\n\t  \"aria-labelledby\",\n\t  \"aria-live\",\n\t  \"aria-owns\",\n\t  \"aria-relevant\",\n\t  \"aria-roledescription\",\n", "];\n\tconst FOCUSABLE_SELECTOR = [\n\t  \"input:not([type=hidden]):not([disabled])\",\n\t  \"button:not([disabled])\",\n\t  \"select:not([disabled])\",\n\t  \"textarea:not([disabled])\",\n\t  '[contenteditable=\"\"]',\n\t  '[contenteditable=\"true\"]',\n\t  \"a[href]\",\n\t  \"[tabindex]:not([disabled])\",\n", "].join(\", \");\n\tfunction isFocusable(node: HTMLElement) {\n\t  return node.matches(FOCUSABLE_SELECTOR);\n\t}\n\tfunction hasGlobalStateOrProperty(node: HTMLElement) {\n\t  return globalStatesAndProperties.some((global) => node.hasAttribute(global));\n\t}\n\tfunction getExplicitRole({\n\t  accessibleName,\n\t  allowedAccessibilityRoles,\n", "  inheritedImplicitPresentational,\n\t  node,\n\t}: {\n\t  accessibleName: string;\n\t  allowedAccessibilityRoles: string[][];\n\t  inheritedImplicitPresentational: boolean;\n\t  node: HTMLElement;\n\t}) {\n\t  const rawRoles = node.getAttribute(\"role\")?.trim().split(\" \") ?? [];\n\t  const authorErrorFilteredRoles = rawRoles\n", "    /**\n\t     * As stated in the Definition of Roles section, it is considered an\n\t     * authoring error to use abstract roles in content.\n\t     * User agents MUST NOT map abstract roles via the standard role mechanism\n\t     * of the accessibility API.\n\t     *\n\t     * REF: https://w3c.github.io/aria/#document-handling_author-errors_roles\n\t     */\n\t    .filter((role) => allowedNonAbstractRoles.includes(role))\n\t    /**\n", "     * Certain landmark roles require names from authors. In situations where\n\t     * an author has not specified names for these landmarks, it is\n\t     * considered an authoring error. The user agent MUST treat such elements\n\t     * as if no role had been provided. If a valid fallback role had been\n\t     * specified, or if the element had an implicit ARIA role, then user\n\t     * agents would continue to expose that role, instead. Instances of such\n\t     * roles are as follows:\n\t     *\n\t     * - form\n\t     * - region\n", "     *\n\t     * REF: https://w3c.github.io/aria/#document-handling_author-errors_roles\n\t     */\n\t    .filter((role) => !!accessibleName || !rolesRequiringName.includes(role));\n\t  /**\n\t   * If an allowed child element has an explicit non-presentational role, user\n\t   * agents MUST ignore an inherited presentational role and expose the element\n\t   * with its explicit role. If the action of exposing the explicit role causes\n\t   * the accessibility tree to be malformed, the expected results are\n\t   * undefined.\n", "   *\n\t   * See also \"Children Presentational: True\".\n\t   *\n\t   * REF:\n\t   *\n\t   * - https://w3c.github.io/aria/#conflict_resolution_presentation_none\n\t   * - https://w3c.github.io/aria/#tree_exclusion\n\t   * - https://w3c.github.io/aria/#mustContain\n\t   */\n\t  const isExplicitAllowedChildElement = allowedAccessibilityRoles.some(\n", "    ([allowedExplicitRole]) =>\n\t      authorErrorFilteredRoles?.[0] === allowedExplicitRole\n\t  );\n\t  if (inheritedImplicitPresentational && !isExplicitAllowedChildElement) {\n\t    authorErrorFilteredRoles.unshift(\"none\");\n\t  }\n\t  if (!authorErrorFilteredRoles?.length) {\n\t    return \"\";\n\t  }\n\t  const filteredRoles = authorErrorFilteredRoles\n", "    /**\n\t     * If an element is focusable, user agents MUST ignore the\n\t     * presentation/none role and expose the element with its implicit role, in\n\t     * order to ensure that the element is operable.\n\t     *\n\t     * If an element has global WAI-ARIA states or properties, user agents MUST\n\t     * ignore the presentation role and instead expose the element's implicit\n\t     * role. However, if an element has only non-global, role-specific WAI-ARIA\n\t     * states or properties, the element MUST NOT be exposed unless the\n\t     * presentational role is inherited and an explicit non-presentational role\n", "     * is applied.\n\t     *\n\t     * REF: https://w3c.github.io/aria/#conflict_resolution_presentation_none\n\t     */\n\t    .filter((role) => {\n\t      if (!presentationRoles.includes(role)) {\n\t        return true;\n\t      }\n\t      if (hasGlobalStateOrProperty(node) || isFocusable(node)) {\n\t        return false;\n", "      }\n\t      return true;\n\t    });\n\t  return filteredRoles?.[0] ?? \"\";\n\t}\n\texport function getRole({\n\t  accessibleName,\n\t  allowedAccessibilityRoles,\n\t  inheritedImplicitPresentational,\n\t  node,\n", "}: {\n\t  accessibleName: string;\n\t  allowedAccessibilityRoles: string[][];\n\t  inheritedImplicitPresentational: boolean;\n\t  node: Node;\n\t}) {\n\t  if (!isElement(node)) {\n\t    return { explicitRole: \"\", implicitRole: \"\", role: \"\" };\n\t  }\n\t  const target = node.cloneNode() as HTMLElement;\n", "  const explicitRole = getExplicitRole({\n\t    accessibleName,\n\t    allowedAccessibilityRoles,\n\t    inheritedImplicitPresentational,\n\t    node: target,\n\t  });\n\t  target.removeAttribute(\"role\");\n\t  let implicitRole = getImplicitRole(target) ?? \"\";\n\t  if (!implicitRole) {\n\t    // TODO: remove this fallback post https://github.com/eps1lon/dom-accessibility-api/pull/937\n", "    implicitRole = Object.keys(getRoles(target))?.[0] ?? \"\";\n\t  }\n\t  if (explicitRole) {\n\t    return { explicitRole, implicitRole, role: explicitRole };\n\t  }\n\t  return {\n\t    explicitRole,\n\t    implicitRole,\n\t    role: implicitRole,\n\t  };\n", "}\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleName.ts", "chunked_list": ["import { computeAccessibleName } from \"dom-accessibility-api\";\n\timport { isElement } from \"../isElement\";\n\texport function getAccessibleName(node: Node) {\n\t  return isElement(node)\n\t    ? computeAccessibleName(node).trim()\n\t    : node.textContent.trim();\n\t}\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleDescription.ts", "chunked_list": ["import { computeAccessibleDescription } from \"dom-accessibility-api\";\n\timport { isElement } from \"../isElement\";\n\texport function getAccessibleDescription(node: Node) {\n\t  return isElement(node) ? computeAccessibleDescription(node).trim() : \"\";\n\t}\n"]}
{"filename": "src/getNodeAccessibilityData/index.ts", "chunked_list": ["import { ARIARoleDefinitionKey, roles } from \"aria-query\";\n\timport { getRole, presentationRoles } from \"./getRole\";\n\timport { getAccessibleAttributeLabels } from \"./getAccessibleAttributeLabels\";\n\timport { getAccessibleDescription } from \"./getAccessibleDescription\";\n\timport { getAccessibleName } from \"./getAccessibleName\";\n\timport { getAccessibleValue } from \"./getAccessibleValue\";\n\timport { isElement } from \"../isElement\";\n\tconst childrenPresentationalRoles = roles\n\t  .entries()\n\t  .filter(([, { childrenPresentational }]) => childrenPresentational)\n", "  .map(([key]) => key) as string[];\n\tconst getSpokenRole = ({ isGeneric, isPresentational, node, role }) => {\n\t  if (isPresentational || isGeneric) {\n\t    return \"\";\n\t  }\n\t  if (isElement(node)) {\n\t    /**\n\t     * Assistive technologies SHOULD use the value of aria-roledescription when\n\t     * presenting the role of an element, but SHOULD NOT change other\n\t     * functionality based on the role of an element that has a value for\n", "     * aria-roledescription. For example, an assistive technology that provides\n\t     * functions for navigating to the next region or button SHOULD allow those\n\t     * functions to navigate to regions and buttons that have an\n\t     * aria-roledescription.\n\t     *\n\t     * REF: https://w3c.github.io/aria/#aria-roledescription\n\t     */\n\t    const roledescription = node.getAttribute(\"aria-roledescription\");\n\t    if (roledescription) {\n\t      return roledescription;\n", "    }\n\t  }\n\t  return role;\n\t};\n\texport function getNodeAccessibilityData({\n\t  allowedAccessibilityRoles,\n\t  alternateReadingOrderParents,\n\t  container,\n\t  inheritedImplicitPresentational,\n\t  node,\n", "}: {\n\t  allowedAccessibilityRoles: string[][];\n\t  alternateReadingOrderParents: Node[];\n\t  container: Node;\n\t  inheritedImplicitPresentational: boolean;\n\t  node: Node;\n\t}) {\n\t  const accessibleDescription = getAccessibleDescription(node);\n\t  const accessibleName = getAccessibleName(node);\n\t  const accessibleValue = getAccessibleValue(node);\n", "  const { explicitRole, implicitRole, role } = getRole({\n\t    accessibleName,\n\t    allowedAccessibilityRoles,\n\t    inheritedImplicitPresentational,\n\t    node,\n\t  });\n\t  const accessibleAttributeLabels = getAccessibleAttributeLabels({\n\t    accessibleValue,\n\t    alternateReadingOrderParents,\n\t    container,\n", "    node,\n\t    role,\n\t  });\n\t  const amendedAccessibleDescription =\n\t    accessibleDescription === accessibleName ? \"\" : accessibleDescription;\n\t  const isExplicitPresentational = presentationRoles.includes(explicitRole);\n\t  const isPresentational = presentationRoles.includes(role);\n\t  const isGeneric = role === \"generic\";\n\t  const spokenRole = getSpokenRole({\n\t    isGeneric,\n", "    isPresentational,\n\t    node,\n\t    role,\n\t  });\n\t  const { requiredOwnedElements: allowedAccessibilityChildRoles } = (roles.get(\n\t    role as ARIARoleDefinitionKey\n\t  ) as unknown as {\n\t    requiredOwnedElements: string[][];\n\t  }) ?? { requiredOwnedElements: [] };\n\t  const { requiredOwnedElements: implicitAllowedAccessibilityChildRoles } =\n", "    (roles.get(implicitRole as ARIARoleDefinitionKey) as unknown as {\n\t      requiredOwnedElements: string[][];\n\t    }) ?? { requiredOwnedElements: [] };\n\t  /**\n\t   * Any descendants of elements that have the characteristic \"Children\n\t   * Presentational: True\" unless the descendant is not allowed to be\n\t   * presentational because it meets one of the conditions for exception\n\t   * described in Presentational Roles Conflict Resolution. However, the text\n\t   * content of any excluded descendants is included.\n\t   *\n", "   * REF: https://w3c.github.io/aria/#tree_exclusion\n\t   */\n\t  const isChildrenPresentationalRole =\n\t    childrenPresentationalRoles.includes(role);\n\t  /**\n\t   * When an explicit or inherited role of presentation is applied to an\n\t   * element with the implicit semantic of a WAI-ARIA role that has Allowed\n\t   * Accessibility Child Roles, in addition to the element with the explicit\n\t   * role of presentation, the user agent MUST apply an inherited role of\n\t   * presentation to any owned elements that do not have an explicit role\n", "   * defined. Also, when an explicit or inherited role of presentation is\n\t   * applied to a host language element which has specifically allowed children\n\t   * as defined by the host language specification, in addition to the element\n\t   * with the explicit role of presentation, the user agent MUST apply an\n\t   * inherited role of presentation to any specifically allowed children that\n\t   * do not have an explicit role defined.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#presentational-role-inheritance\n\t   */\n\t  const isExplicitOrInheritedPresentation =\n", "    isExplicitPresentational || inheritedImplicitPresentational;\n\t  const isElementWithImplicitAllowedAccessibilityChildRoles =\n\t    !!implicitAllowedAccessibilityChildRoles.length;\n\t  const childrenInheritPresentationExceptAllowedRoles =\n\t    isExplicitOrInheritedPresentation &&\n\t    isElementWithImplicitAllowedAccessibilityChildRoles;\n\t  const childrenPresentational =\n\t    isChildrenPresentationalRole ||\n\t    childrenInheritPresentationExceptAllowedRoles;\n\t  return {\n", "    accessibleAttributeLabels,\n\t    accessibleDescription: amendedAccessibleDescription,\n\t    accessibleName,\n\t    accessibleValue,\n\t    allowedAccessibilityChildRoles,\n\t    childrenPresentational,\n\t    role,\n\t    spokenRole,\n\t  };\n\t}\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleValue.ts", "chunked_list": ["import { isElement } from \"../isElement\";\n\texport type HTMLElementWithValue =\n\t  | HTMLButtonElement\n\t  | HTMLDataElement\n\t  | HTMLInputElement\n\t  | HTMLLIElement\n\t  | HTMLMeterElement\n\t  | HTMLOptionElement\n\t  | HTMLProgressElement\n\t  | HTMLParamElement;\n", "const ignoredInputTypes = [\"checkbox\", \"radio\"];\n\tconst allowedLocalNames = [\n\t  \"button\",\n\t  \"data\",\n\t  \"input\",\n\t  // \"li\",\n\t  \"meter\",\n\t  \"option\",\n\t  \"progress\",\n\t  \"param\",\n", "];\n\tfunction getSelectValue(node: HTMLSelectElement) {\n\t  const selectedOptions = [...node.options].filter(\n\t    (optionElement) => optionElement.selected\n\t  );\n\t  if (node.multiple) {\n\t    return [...selectedOptions]\n\t      .map((optionElement) => getValue(optionElement))\n\t      .join(\"; \");\n\t  }\n", "  if (selectedOptions.length === 0) {\n\t    return \"\";\n\t  }\n\t  return getValue(selectedOptions[0]);\n\t}\n\tfunction getInputValue(node: HTMLInputElement) {\n\t  if (ignoredInputTypes.includes(node.type)) {\n\t    return \"\";\n\t  }\n\t  return getValue(node);\n", "}\n\tfunction getValue(node: HTMLElementWithValue) {\n\t  if (!allowedLocalNames.includes(node.localName)) {\n\t    return \"\";\n\t  }\n\t  if (\n\t    node.getAttribute(\"aria-valuetext\") ||\n\t    node.getAttribute(\"aria-valuenow\")\n\t  ) {\n\t    return \"\";\n", "  }\n\t  return typeof node.value === \"number\" ? `${node.value}` : node.value;\n\t}\n\texport function getAccessibleValue(node: Node) {\n\t  if (!isElement(node)) {\n\t    return \"\";\n\t  }\n\t  switch (node.localName) {\n\t    case \"input\": {\n\t      return getInputValue(node as HTMLInputElement);\n", "    }\n\t    case \"select\": {\n\t      return getSelectValue(node as HTMLSelectElement);\n\t    }\n\t  }\n\t  return getValue(node as HTMLElementWithValue);\n\t}\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromAriaAttribute.ts", "chunked_list": ["import { mapAttributeNameAndValueToLabel } from \"./mapAttributeNameAndValueToLabel\";\n\texport const getLabelFromAriaAttribute = ({\n\t  attributeName,\n\t  container,\n\t  node,\n\t}: {\n\t  attributeName: string;\n\t  container: Node;\n\t  node: HTMLElement;\n\t}) => {\n", "  const attributeValue = node.getAttribute(attributeName);\n\t  return {\n\t    label: mapAttributeNameAndValueToLabel({\n\t      attributeName,\n\t      attributeValue,\n\t      container,\n\t    }),\n\t    value: attributeValue,\n\t  };\n\t};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/mapAttributeNameAndValueToLabel.ts", "chunked_list": ["import { getAccessibleName } from \"../getAccessibleName\";\n\timport { getAccessibleValue } from \"../getAccessibleValue\";\n\timport { getItemText } from \"../../getItemText\";\n\timport { getNodeByIdRef } from \"../../getNodeByIdRef\";\n\tenum State {\n\t  BUSY = \"busy\",\n\t  CHECKED = \"checked\",\n\t  CURRENT = \"current item\",\n\t  DISABLED = \"disabled\",\n\t  EXPANDED = \"expanded\",\n", "  INVALID = \"invalid\",\n\t  MODAL = \"modal\",\n\t  MULTI_SELECTABLE = \"multi-selectable\",\n\t  PARTIALLY_CHECKED = \"partially checked\",\n\t  PARTIALLY_PRESSED = \"partially pressed\",\n\t  PRESSED = \"pressed\",\n\t  READ_ONLY = \"read only\",\n\t  REQUIRED = \"required\",\n\t  SELECTED = \"selected\",\n\t}\n", "// https://w3c.github.io/aria/#state_prop_def\n\tconst ariaPropertyToVirtualLabelMap: Record<\n\t  string,\n\t  ((...args: unknown[]) => string) | null\n\t> = {\n\t  \"aria-activedescendant\": idRef(\"active descendant\"),\n\t  \"aria-atomic\": null, // Handled by live region logic\n\t  \"aria-autocomplete\": token({\n\t    inline: \"autocomplete inlined\",\n\t    list: \"autocomplete in list\",\n", "    both: \"autocomplete inlined and in list\",\n\t    none: \"no autocomplete\",\n\t  }),\n\t  \"aria-braillelabel\": null, // Currently won't do - not implementing a braille screen reader\n\t  \"aria-brailleroledescription\": null, // Currently won't do - not implementing a braille screen reader\n\t  \"aria-busy\": state(State.BUSY),\n\t  \"aria-checked\": tristate(State.CHECKED, State.PARTIALLY_CHECKED),\n\t  \"aria-colcount\": integer(\"column count\"),\n\t  \"aria-colindex\": integer(\"column index\"),\n\t  \"aria-colindextext\": string(\"column index\"),\n", "  \"aria-colspan\": integer(\"column span\"),\n\t  \"aria-controls\": idRefs(\"control\", \"controls\"), // Handled by virtual.perform()\n\t  \"aria-current\": token({\n\t    page: \"current page\",\n\t    step: \"current step\",\n\t    location: \"current location\",\n\t    date: \"current date\",\n\t    time: \"current time\",\n\t    true: State.CURRENT,\n\t    false: `not ${State.CURRENT}`,\n", "  }),\n\t  \"aria-describedby\": null, // Handled by accessible description\n\t  \"aria-description\": null, // Handled by accessible description\n\t  \"aria-details\": idRefs(\"linked details\", \"linked details\", false),\n\t  \"aria-disabled\": state(State.DISABLED),\n\t  \"aria-dropeffect\": null, // Deprecated in WAI-ARIA 1.1\n\t  \"aria-errormessage\": null, // TODO: decide what to announce here\n\t  \"aria-expanded\": state(State.EXPANDED),\n\t  \"aria-flowto\": idRefs(\"alternate reading order\", \"alternate reading orders\"), // Handled by virtual.perform()\n\t  \"aria-grabbed\": null, // Deprecated in WAI-ARIA 1.1\n", "  \"aria-haspopup\": token({\n\t    /**\n\t     * Assistive technologies SHOULD NOT expose the aria-haspopup property if\n\t     * it has a value of false.\n\t     *\n\t     * REF: // https://w3c.github.io/aria/#aria-haspopup\n\t     */\n\t    false: null,\n\t    true: \"has popup menu\",\n\t    menu: \"has popup menu\",\n", "    listbox: \"has popup listbox\",\n\t    tree: \"has popup tree\",\n\t    grid: \"has popup grid\",\n\t    dialog: \"has popup dialog\",\n\t  }),\n\t  \"aria-hidden\": null, // Excluded from accessibility tree\n\t  \"aria-invalid\": token({\n\t    grammar: \"grammatical error detected\",\n\t    false: `not ${State.INVALID}`,\n\t    spelling: \"spelling error detected\",\n", "    true: State.INVALID,\n\t  }),\n\t  \"aria-keyshortcuts\": string(\"key shortcuts\"),\n\t  \"aria-label\": null, // Handled by accessible name\n\t  \"aria-labelledby\": null, // Handled by accessible name\n\t  \"aria-level\": integer(\"level\"),\n\t  \"aria-live\": null, // Handled by live region logic\n\t  \"aria-modal\": state(State.MODAL),\n\t  \"aria-multiselectable\": state(State.MULTI_SELECTABLE),\n\t  \"aria-orientation\": token({\n", "    horizontal: \"orientated horizontally\",\n\t    vertical: \"orientated vertically\",\n\t  }),\n\t  \"aria-owns\": null, // Handled by accessibility tree construction\n\t  \"aria-placeholder\": string(\"placeholder\"),\n\t  \"aria-posinset\": integer(\"item set position\"),\n\t  \"aria-pressed\": tristate(State.PRESSED, State.PARTIALLY_PRESSED),\n\t  \"aria-readonly\": state(State.READ_ONLY),\n\t  \"aria-relevant\": null, // Handled by live region logic\n\t  \"aria-required\": state(State.REQUIRED),\n", "  \"aria-roledescription\": null, // Handled by accessible description\n\t  \"aria-rowcount\": integer(\"row count\"),\n\t  \"aria-rowindex\": integer(\"row index\"),\n\t  \"aria-rowindextext\": string(\"row index\"),\n\t  \"aria-rowspan\": integer(\"row span\"),\n\t  \"aria-selected\": state(State.SELECTED),\n\t  \"aria-setsize\": integer(\"item set size\"),\n\t  \"aria-sort\": token({\n\t    ascending: \"sorted in ascending order\",\n\t    descending: \"sorted in descending order\",\n", "    none: \"no defined sort order\",\n\t    other: \"non ascending / descending sort order applied\",\n\t  }),\n\t  \"aria-valuemax\": number(\"max value\"),\n\t  \"aria-valuemin\": number(\"min value\"),\n\t  \"aria-valuenow\": number(\"current value\"),\n\t  \"aria-valuetext\": string(\"current value\"),\n\t};\n\tinterface MapperArgs {\n\t  attributeValue: string;\n", "  container?: Node;\n\t  negative?: boolean;\n\t}\n\tfunction state(stateValue: State) {\n\t  return function stateMapper({ attributeValue, negative }: MapperArgs) {\n\t    if (negative) {\n\t      return attributeValue !== \"false\" ? `not ${stateValue}` : stateValue;\n\t    }\n\t    return attributeValue !== \"false\" ? stateValue : `not ${stateValue}`;\n\t  };\n", "}\n\tfunction idRefs(\n\t  propertyDescriptionSuffixSingular: string,\n\t  propertyDescriptionSuffixPlural: string,\n\t  printCount = true\n\t) {\n\t  return function mapper({ attributeValue, container }: MapperArgs) {\n\t    const idRefsCount = attributeValue\n\t      .trim()\n\t      .split(\" \")\n", "      .filter((idRef) => !!getNodeByIdRef({ container, idRef })).length;\n\t    if (idRefsCount === 0) {\n\t      return \"\";\n\t    }\n\t    return `${printCount ? `${idRefsCount} ` : \"\"}${\n\t      idRefsCount === 1\n\t        ? propertyDescriptionSuffixSingular\n\t        : propertyDescriptionSuffixPlural\n\t    }`;\n\t  };\n", "}\n\tfunction idRef(propertyName: string) {\n\t  return function mapper({ attributeValue: idRef, container }: MapperArgs) {\n\t    const node = getNodeByIdRef({ container, idRef });\n\t    if (!node) {\n\t      return \"\";\n\t    }\n\t    const accessibleName = getAccessibleName(node);\n\t    const accessibleValue = getAccessibleValue(node);\n\t    const itemText = getItemText({ accessibleName, accessibleValue });\n", "    return concat(propertyName)({ attributeValue: itemText });\n\t  };\n\t}\n\tfunction tristate(stateValue: State, mixedValue: State) {\n\t  return function stateMapper({ attributeValue }: MapperArgs) {\n\t    if (attributeValue === \"mixed\") {\n\t      return mixedValue;\n\t    }\n\t    return attributeValue !== \"false\" ? stateValue : `not ${stateValue}`;\n\t  };\n", "}\n\tfunction token(tokenMap: Record<string, string>) {\n\t  return function tokenMapper({ attributeValue }: MapperArgs) {\n\t    return tokenMap[attributeValue];\n\t  };\n\t}\n\tfunction concat(propertyName: string) {\n\t  return function mapper({ attributeValue }: MapperArgs) {\n\t    return attributeValue ? `${propertyName} ${attributeValue}` : \"\";\n\t  };\n", "}\n\tfunction integer(propertyName: string) {\n\t  return concat(propertyName);\n\t}\n\tfunction number(propertyName: string) {\n\t  return concat(propertyName);\n\t}\n\tfunction string(propertyName: string) {\n\t  return concat(propertyName);\n\t}\n", "export const mapAttributeNameAndValueToLabel = ({\n\t  attributeName,\n\t  attributeValue,\n\t  container,\n\t  negative = false,\n\t}: {\n\t  attributeName: string;\n\t  attributeValue: string | null;\n\t  container: Node;\n\t  negative?: boolean;\n", "}) => {\n\t  if (typeof attributeValue !== \"string\") {\n\t    return null;\n\t  }\n\t  const mapper = ariaPropertyToVirtualLabelMap[attributeName];\n\t  return mapper?.({ attributeValue, container, negative }) ?? null;\n\t};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/postProcessLabels.ts", "chunked_list": ["import { postProcessAriaValueNow } from \"./postProcessAriaValueNow\";\n\tconst priorityReplacementMap: [string, string][] = [\n\t  [\"aria-colindextext\", \"aria-colindex\"],\n\t  [\"aria-rowindextext\", \"aria-rowindex\"],\n\t  /**\n\t   * If aria-valuetext is specified, assistive technologies SHOULD render that\n\t   * value instead of the value of aria-valuenow.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#aria-valuetext\n\t   */\n", "  [\"aria-valuetext\", \"aria-valuenow\"],\n\t];\n\texport const postProcessLabels = ({\n\t  labels,\n\t  role,\n\t}: {\n\t  labels: Record<string, { label: string; value: string }>;\n\t  role: string;\n\t}) => {\n\t  for (const [preferred, dropped] of priorityReplacementMap) {\n", "    if (labels[preferred] && labels[dropped]) {\n\t      labels[dropped].value = \"\";\n\t    }\n\t  }\n\t  if (labels[\"aria-valuenow\"]) {\n\t    labels[\"aria-valuenow\"].label = postProcessAriaValueNow({\n\t      value: labels[\"aria-valuenow\"].value,\n\t      min: labels[\"aria-valuemin\"]?.value,\n\t      max: labels[\"aria-valuemax\"]?.value,\n\t      role,\n", "    });\n\t  }\n\t  return Object.values(labels).map(({ label }) => label);\n\t};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromHtmlEquivalentAttribute.ts", "chunked_list": ["import { mapAttributeNameAndValueToLabel } from \"./mapAttributeNameAndValueToLabel\";\n\t// REF: https://www.w3.org/TR/html-aria/#docconformance-attr\n\tconst ariaToHTMLAttributeMapping: Record<\n\t  string,\n\t  Array<{ name: string; negative?: boolean }>\n\t> = {\n\t  \"aria-checked\": [{ name: \"checked\" }],\n\t  \"aria-disabled\": [{ name: \"disabled\" }],\n\t  // \"aria-hidden\": [{ name: \"hidden\" }],\n\t  \"aria-placeholder\": [{ name: \"placeholder\" }],\n", "  \"aria-valuemax\": [{ name: \"max\" }],\n\t  \"aria-valuemin\": [{ name: \"min\" }],\n\t  \"aria-readonly\": [\n\t    { name: \"readonly\" },\n\t    { name: \"contenteditable\", negative: true },\n\t  ],\n\t  \"aria-required\": [{ name: \"required\" }],\n\t  \"aria-colspan\": [{ name: \"colspan\" }],\n\t  \"aria-rowspan\": [{ name: \"rowspan\" }],\n\t};\n", "export const getLabelFromHtmlEquivalentAttribute = ({\n\t  attributeName,\n\t  container,\n\t  node,\n\t}: {\n\t  attributeName: string;\n\t  container: Node;\n\t  node: HTMLElement;\n\t}) => {\n\t  const htmlAttribute = ariaToHTMLAttributeMapping[attributeName];\n", "  if (!htmlAttribute?.length) {\n\t    return { label: \"\", value: \"\" };\n\t  }\n\t  for (const { name, negative = false } of htmlAttribute) {\n\t    const attributeValue = node.getAttribute(name);\n\t    const label = mapAttributeNameAndValueToLabel({\n\t      attributeName,\n\t      attributeValue,\n\t      container,\n\t      negative,\n", "    });\n\t    if (label) {\n\t      return { label, value: attributeValue };\n\t    }\n\t  }\n\t  return { label: \"\", value: \"\" };\n\t};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/getAttributesByRole.ts", "chunked_list": ["import { ARIAPropertyMap, ARIARoleDefinitionKey, roles } from \"aria-query\";\n\timport { globalStatesAndProperties } from \"../getRole\";\n\tconst ignoreAttributesWithAccessibleValue = [\"aria-placeholder\"];\n\texport const getAttributesByRole = ({\n\t  accessibleValue,\n\t  role,\n\t}: {\n\t  accessibleValue: string;\n\t  role: string;\n\t}) => {\n", "  const {\n\t    props: implicitRoleAttributes = {},\n\t    prohibitedProps: prohibitedAttributes = [],\n\t  } = (roles.get(role as ARIARoleDefinitionKey) ?? {}) as {\n\t    props: ARIAPropertyMap;\n\t    prohibitedProps: string[];\n\t  };\n\t  const uniqueAttributes = Array.from(\n\t    new Set([\n\t      ...Object.keys(implicitRoleAttributes),\n", "      ...globalStatesAndProperties,\n\t    ])\n\t  )\n\t    .filter((attribute) => !prohibitedAttributes.includes(attribute))\n\t    .filter(\n\t      (attribute) =>\n\t        !accessibleValue ||\n\t        !ignoreAttributesWithAccessibleValue.includes(attribute)\n\t    );\n\t  return uniqueAttributes.map((attribute) => [\n", "    attribute,\n\t    implicitRoleAttributes[attribute] ?? null,\n\t  ]);\n\t};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromImplicitHtmlElementValue.ts", "chunked_list": ["import { mapAttributeNameAndValueToLabel } from \"./mapAttributeNameAndValueToLabel\";\n\tconst mapLocalNameToImplicitValue = {\n\t  \"aria-level\": {\n\t    h1: \"1\",\n\t    h2: \"2\",\n\t    h3: \"3\",\n\t    h4: \"4\",\n\t    h5: \"5\",\n\t    h6: \"6\",\n\t  },\n", "};\n\texport const getLabelFromImplicitHtmlElementValue = ({\n\t  attributeName,\n\t  container,\n\t  node,\n\t}: {\n\t  attributeName: string;\n\t  container: Node;\n\t  node: HTMLElement;\n\t}) => {\n", "  const { localName } = node;\n\t  const implicitValue = mapLocalNameToImplicitValue[attributeName]?.[localName];\n\t  return {\n\t    label: mapAttributeNameAndValueToLabel({\n\t      attributeName,\n\t      attributeValue: implicitValue,\n\t      container,\n\t    }),\n\t    value: implicitValue,\n\t  };\n", "};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/index.ts", "chunked_list": ["import { getAttributesByRole } from \"./getAttributesByRole\";\n\timport { getLabelFromAriaAttribute } from \"./getLabelFromAriaAttribute\";\n\timport { getLabelFromHtmlEquivalentAttribute } from \"./getLabelFromHtmlEquivalentAttribute\";\n\timport { getLabelFromImplicitHtmlElementValue } from \"./getLabelFromImplicitHtmlElementValue\";\n\timport { isElement } from \"../../isElement\";\n\timport { mapAttributeNameAndValueToLabel } from \"./mapAttributeNameAndValueToLabel\";\n\timport { postProcessLabels } from \"./postProcessLabels\";\n\texport const getAccessibleAttributeLabels = ({\n\t  accessibleValue,\n\t  alternateReadingOrderParents,\n", "  container,\n\t  node,\n\t  role,\n\t}: {\n\t  accessibleValue: string;\n\t  alternateReadingOrderParents: Node[];\n\t  container: Node;\n\t  node: Node;\n\t  role: string;\n\t}): string[] => {\n", "  if (!isElement(node)) {\n\t    return [];\n\t  }\n\t  const labels: Record<string, { label: string; value: string }> = {};\n\t  const attributes = getAttributesByRole({ accessibleValue, role });\n\t  attributes.forEach(([attributeName, implicitAttributeValue]) => {\n\t    const {\n\t      label: labelFromHtmlEquivalentAttribute,\n\t      value: valueFromHtmlEquivalentAttribute,\n\t    } = getLabelFromHtmlEquivalentAttribute({\n", "      attributeName,\n\t      container,\n\t      node,\n\t    });\n\t    if (labelFromHtmlEquivalentAttribute) {\n\t      labels[attributeName] = {\n\t        label: labelFromHtmlEquivalentAttribute,\n\t        value: valueFromHtmlEquivalentAttribute,\n\t      };\n\t      return;\n", "    }\n\t    const { label: labelFromAriaAttribute, value: valueFromAriaAttribute } =\n\t      getLabelFromAriaAttribute({\n\t        attributeName,\n\t        container,\n\t        node,\n\t      });\n\t    if (labelFromAriaAttribute) {\n\t      labels[attributeName] = {\n\t        label: labelFromAriaAttribute,\n", "        value: valueFromAriaAttribute,\n\t      };\n\t      return;\n\t    }\n\t    const {\n\t      label: labelFromImplicitHtmlElementValue,\n\t      value: valueFromImplicitHtmlElementValue,\n\t    } = getLabelFromImplicitHtmlElementValue({\n\t      attributeName,\n\t      container,\n", "      node,\n\t    });\n\t    if (labelFromImplicitHtmlElementValue) {\n\t      labels[attributeName] = {\n\t        label: labelFromImplicitHtmlElementValue,\n\t        value: valueFromImplicitHtmlElementValue,\n\t      };\n\t      return;\n\t    }\n\t    const labelFromImplicitAriaAttributeValue = mapAttributeNameAndValueToLabel(\n", "      {\n\t        attributeName,\n\t        attributeValue: implicitAttributeValue,\n\t        container,\n\t      }\n\t    );\n\t    if (labelFromImplicitAriaAttributeValue) {\n\t      labels[attributeName] = {\n\t        label: labelFromImplicitAriaAttributeValue,\n\t        value: implicitAttributeValue,\n", "      };\n\t      return;\n\t    }\n\t  });\n\t  const processedLabels = postProcessLabels({ labels, role }).filter(Boolean);\n\t  /**\n\t   * aria-flowto MUST requirements:\n\t   *\n\t   * The reading order goes both directions, and a user needs to be aware of the\n\t   * alternate reading order so that they can invoke the functionality.\n", "   *\n\t   * The reading order goes both directions, and a user needs to be able to\n\t   * travel backwards through their chosen reading order.\n\t   *\n\t   * REF: https://a11ysupport.io/tech/aria/aria-flowto_attribute\n\t   */\n\t  if (alternateReadingOrderParents.length > 0) {\n\t    processedLabels.push(\n\t      `${alternateReadingOrderParents.length} previous alternate reading ${\n\t        alternateReadingOrderParents.length === 1 ? \"order\" : \"orders\"\n", "      }`\n\t    );\n\t  }\n\t  return processedLabels;\n\t};\n"]}
{"filename": "src/getNodeAccessibilityData/getAccessibleAttributeLabels/postProcessAriaValueNow.ts", "chunked_list": ["const percentageBasedValueRoles = [\"progressbar\", \"scrollbar\"];\n\tconst isNumberLike = (value: string) => {\n\t  return !isNaN(parseFloat(value));\n\t};\n\tconst toNumber = (value: string) => parseFloat(value);\n\tconst toPercentageLabel = (value: number | string) => `current value ${value}%`;\n\t/**\n\t * If aria-valuetext is specified, assistive technologies render that instead\n\t * of the value of aria-valuenow.\n\t *\n", " * REF: https://w3c.github.io/aria/#aria-valuenow\n\t */\n\texport const postProcessAriaValueNow = ({\n\t  max,\n\t  min,\n\t  role,\n\t  value,\n\t}: {\n\t  max: string;\n\t  min: string;\n", "  role: string;\n\t  value: string;\n\t}) => {\n\t  if (!percentageBasedValueRoles.includes(role)) {\n\t    return value;\n\t  }\n\t  if (!isNumberLike(value)) {\n\t    return value;\n\t  }\n\t  /**\n", "   * For progressbar elements and scrollbar elements, assistive technologies\n\t   * SHOULD render the value to users as a percent, calculated as a position\n\t   * on the range from aria-valuemin to aria-valuemax if both are defined,\n\t   * otherwise the actual value with a percent indicator. For elements with\n\t   * role slider and spinbutton, assistive technologies SHOULD render the\n\t   * actual value to users.\n\t   *\n\t   * REF: https://w3c.github.io/aria/#aria-valuenow\n\t   */\n\t  if (isNumberLike(max) && isNumberLike(min)) {\n", "    const percentage = +(\n\t      ((toNumber(value) - toNumber(min)) / (toNumber(max) - toNumber(min))) *\n\t      100\n\t    ).toFixed(2);\n\t    return toPercentageLabel(percentage);\n\t  }\n\t  return toPercentageLabel(value);\n\t};\n"]}
