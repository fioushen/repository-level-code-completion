{"filename": "vitest.config.ts", "chunked_list": ["/// <reference types=\"vitest\" />\n\timport { configDefaults, defineConfig } from 'vitest/config'\n\texport default defineConfig(() => ({\n\t  test: {\n\t    environment: 'jsdom',\n\t    globals: true,\n\t    maxConcurrency: 1,\n\t    minThreads: 0,\n\t    maxThreads: 1,\n\t  },\n", "}))\n"]}
{"filename": "src/api.ts", "chunked_list": ["import { HTTP_METHODS } from './constants'\n\timport { getJson, getText } from './internals'\n\timport {\n\t  addQueryToURL,\n\t  ensureStringBody,\n\t  makeGetApiURL,\n\t  mergeHeaders,\n\t  replaceURLParams,\n\t} from './primitives'\n\timport {\n", "  EnhancedRequestInit,\n\t  HTTPMethod,\n\t  ServiceRequestInit,\n\t  TypedResponse,\n\t} from './types'\n\t/**\n\t * It hacks the Response object to add typed json and text methods\n\t * @param response the Response to be proxied\n\t * @returns a Response with typed json and text methods\n\t * @example const response = await fetch(\"https://example.com/api/users\");\n", " * const users = await response.json(userSchema);\n\t * //    ^? User[]\n\t * const untyped = await response.json();\n\t * //    ^? unknown\n\t * const text = await response.text();\n\t * //    ^? string\n\t * const typedJson = await response.json<User[]>();\n\t * //    ^? User[]\n\t */\n\tfunction typedResponse(response: Response): TypedResponse {\n", "  return new Proxy(response, {\n\t    get(target, prop) {\n\t      if (prop === 'json') return getJson(target)\n\t      if (prop === 'text') return getText(target)\n\t      return target[prop as keyof Response]\n\t    },\n\t  }) as Omit<Response, 'json' | 'text'> & {\n\t    json: ReturnType<typeof getJson>\n\t    text: ReturnType<typeof getText>\n\t  }\n", "}\n\t/**\n\t *\n\t * @param url a string or URL to be fetched\n\t * @param requestInit the requestInit to be passed to the fetch request. It is the same as the `RequestInit` type, but it also accepts a JSON-like `body` and an object-like `query` parameter.\n\t * @param requestInit.body the body of the request. It will be automatically stringified so you can send a JSON-like object\n\t * @param requestInit.query the query parameters to be added to the URL\n\t * @param requestInit.trace a function that receives the URL and the requestInit and can be used to log the request\n\t * @returns a Response with typed json and text methods\n\t * @example const response = await fetch(\"https://example.com/api/users\");\n", " * const users = await response.json(userSchema);\n\t * //    ^? User[]\n\t * const untyped = await response.json();\n\t * //    ^? unknown\n\t */\n\tasync function enhancedFetch<T extends string | URL>(\n\t  url: T,\n\t  requestInit?: EnhancedRequestInit<T>,\n\t) {\n\t  const { query, trace, ...reqInit } = requestInit ?? {}\n", "  const headers = mergeHeaders(\n\t    {\n\t      'content-type': 'application/json',\n\t    },\n\t    reqInit.headers ?? {},\n\t  )\n\t  const withParams = replaceURLParams<T>(url, reqInit.params ?? ({} as never))\n\t  const fullURL = addQueryToURL(withParams, query)\n\t  const body = ensureStringBody(reqInit.body)\n\t  const enhancedReqInit = { ...reqInit, headers, body }\n", "  trace?.(fullURL, enhancedReqInit)\n\t  const response = await fetch(fullURL, enhancedReqInit)\n\t  return typedResponse(response)\n\t}\n\t/**\n\t *\n\t * @param baseURL the base URL to be fetched in every request\n\t * @param baseHeaders any headers that should be sent with every request\n\t * @returns a function that receive a path and requestInit and return a serialized json response that can be typed or not.\n\t * @example const headers = { Authorization: \"Bearer 123\" }\n", " * const fetcher = makeFetcher(\"https://example.com/api\", headers);\n\t * const response = await fetcher(\"/users\", { method: \"GET\" })\n\t * const users = await response.json(userSchema);\n\t * //    ^? User[]\n\t */\n\tfunction makeFetcher(\n\t  baseURL: string | URL,\n\t  baseHeaders?: HeadersInit | (() => HeadersInit | Promise<HeadersInit>),\n\t) {\n\t  return async <T extends string>(\n", "    path: T,\n\t    requestInit: EnhancedRequestInit<T> = {},\n\t  ) => {\n\t    const url = makeGetApiURL(baseURL)(path)\n\t    const response = await enhancedFetch(url, {\n\t      ...requestInit,\n\t      headers: mergeHeaders(\n\t        typeof baseHeaders === 'function'\n\t          ? await baseHeaders()\n\t          : baseHeaders ?? {},\n", "        requestInit?.headers ?? {},\n\t      ),\n\t    })\n\t    return response\n\t  }\n\t}\n\t/**\n\t *\n\t * @param baseURL the base URL to the API\n\t * @param baseHeaders any headers that should be sent with every request\n", " * @returns a service object with HTTP methods that are functions that receive a path and requestInit and return a serialized json response that can be typed or not.\n\t * @example const headers = { Authorization: \"Bearer 123\" }\n\t * const api = makeService(\"https://example.com/api\", headers);\n\t * const response = await api.get(\"/users\")\n\t * const users = await response.json(userSchema);\n\t * //    ^? User[]\n\t */\n\tfunction makeService(\n\t  baseURL: string | URL,\n\t  baseHeaders?: HeadersInit | (() => HeadersInit | Promise<HeadersInit>),\n", ") {\n\t  const fetcher = makeFetcher(baseURL, baseHeaders)\n\t  function appliedService(method: HTTPMethod) {\n\t    return async <T extends string>(\n\t      path: T,\n\t      requestInit: ServiceRequestInit<T> = {},\n\t    ) => fetcher(path, { ...requestInit, method })\n\t  }\n\t  let service = {} as Record<\n\t    Lowercase<HTTPMethod>,\n", "    ReturnType<typeof appliedService>\n\t  >\n\t  for (const method of HTTP_METHODS) {\n\t    const lowerMethod = method.toLowerCase() as Lowercase<HTTPMethod>\n\t    service[lowerMethod] = appliedService(method)\n\t  }\n\t  return service\n\t}\n\texport { enhancedFetch, makeFetcher, makeService, typedResponse }\n"]}
{"filename": "src/internals.ts", "chunked_list": ["import { Schema } from './types'\n\t/**\n\t * It returns the JSON object or throws an error if the response is not ok.\n\t * @param response the Response to be parsed\n\t * @returns the response.json method that accepts a type or Zod schema for a typed json response\n\t */\n\tfunction getJson(response: Response) {\n\t  return async <T = unknown>(schema?: Schema<T>): Promise<T> => {\n\t    const json = await response.json()\n\t    return schema ? schema.parse(json) : (json as T)\n", "  }\n\t}\n\t/**\n\t * @param response the Response to be parsed\n\t * @returns the response.text method that accepts a type or Zod schema for a typed response\n\t */\n\tfunction getText(response: Response) {\n\t  return async <T extends string = string>(schema?: Schema<T>): Promise<T> => {\n\t    const text = await response.text()\n\t    return schema ? schema.parse(text) : (text as T)\n", "  }\n\t}\n\t/**\n\t * This is an enhanced version of the typeof operator to check the type of more complex values.\n\t * @param t the value to be checked\n\t * @returns the type of the value\n\t */\n\tfunction typeOf(t: unknown) {\n\t  return Object.prototype.toString\n\t    .call(t)\n", "    .replace(/^\\[object (.+)\\]$/, '$1')\n\t    .toLowerCase() as\n\t    | 'array'\n\t    | 'arraybuffer'\n\t    | 'bigint'\n\t    | 'blob'\n\t    | 'boolean'\n\t    | 'formdata'\n\t    | 'function'\n\t    | 'null'\n", "    | 'number'\n\t    | 'object'\n\t    | 'readablestream'\n\t    | 'string'\n\t    | 'symbol'\n\t    | 'undefined'\n\t    | 'url'\n\t    | 'urlsearchparams'\n\t}\n\texport { getJson, getText, typeOf }\n"]}
{"filename": "src/primitives.ts", "chunked_list": ["import { typeOf } from './internals'\n\timport { JSONValue, PathParams, SearchParams } from './types'\n\t/**\n\t * @param url a string or URL to which the query parameters will be added\n\t * @param searchParams the query parameters\n\t * @returns the url with the query parameters added with the same type as the url\n\t */\n\tfunction addQueryToURL(\n\t  url: string | URL,\n\t  searchParams?: SearchParams,\n", "): string | URL {\n\t  if (!searchParams) return url\n\t  if (typeof url === 'string') {\n\t    const separator = url.includes('?') ? '&' : '?'\n\t    return `${url}${separator}${new URLSearchParams(searchParams)}`\n\t  }\n\t  if (searchParams && url instanceof URL) {\n\t    for (const [key, value] of Object.entries(\n\t      new URLSearchParams(searchParams),\n\t    )) {\n", "      url.searchParams.set(key, value)\n\t    }\n\t  }\n\t  return url\n\t}\n\t/**\n\t * @param body the JSON-like body of the request\n\t * @returns the body is stringified if it is not a string and it is a JSON-like object. It also accepts other types of BodyInit such as Blob, ReadableStream, etc.\n\t */\n\tfunction ensureStringBody<B extends JSONValue | BodyInit | null>(\n", "  body?: B,\n\t): B extends JSONValue ? string : B {\n\t  if (typeof body === 'undefined') return body as never\n\t  if (typeof body === 'string') return body as never\n\t  return (\n\t    ['number', 'boolean', 'array', 'object'].includes(typeOf(body))\n\t      ? JSON.stringify(body)\n\t      : body\n\t  ) as never\n\t}\n", "/**\n\t * @param baseURL the base path to the API\n\t * @returns a function that receives a path and an object of query parameters and returns a URL\n\t */\n\tfunction makeGetApiURL<T extends string | URL>(baseURL: T) {\n\t  const base = baseURL instanceof URL ? baseURL.toString() : baseURL\n\t  return (path: string, searchParams?: SearchParams): T => {\n\t    const url = `${base}/${path}`.replace(/([^https?:]\\/)\\/+/g, '$1')\n\t    return addQueryToURL(url, searchParams) as T\n\t  }\n", "}\n\t/**\n\t * It merges multiple HeadersInit objects into a single Headers object\n\t * @param entries Any number of HeadersInit objects\n\t * @returns a new Headers object with the merged headers\n\t */\n\tfunction mergeHeaders(\n\t  ...entries: (\n\t    | HeadersInit\n\t    | [string, undefined][]\n", "    | Record<string, undefined>\n\t  )[]\n\t) {\n\t  const result = new Map<string, string>()\n\t  for (const entry of entries) {\n\t    const headers = new Headers(entry as HeadersInit)\n\t    for (const [key, value] of headers.entries()) {\n\t      if (value === undefined || value === 'undefined') {\n\t        result.delete(key)\n\t      } else {\n", "        result.set(key, value)\n\t      }\n\t    }\n\t  }\n\t  return new Headers(Array.from(result.entries()))\n\t}\n\t/**\n\t *\n\t * @param url the url string or URL object to replace the params\n\t * @param params the params map to be replaced in the url\n", " * @returns the url with the params replaced and with the same type as the given url\n\t */\n\tfunction replaceURLParams<T extends string | URL>(\n\t  url: T,\n\t  params: PathParams<T>,\n\t): T {\n\t  // TODO: use the URL Pattern API as soon as it has better browser support\n\t  if (!params) return url as T\n\t  let urlString = String(url)\n\t  Object.entries(params).forEach(([key, value]) => {\n", "    urlString = urlString.replace(new RegExp(`:${key}($|\\/)`), `${value}$1`)\n\t  })\n\t  return (url instanceof URL ? new URL(urlString) : urlString) as T\n\t}\n\texport {\n\t  addQueryToURL,\n\t  ensureStringBody,\n\t  makeGetApiURL,\n\t  mergeHeaders,\n\t  replaceURLParams,\n", "}\n"]}
{"filename": "src/test.d.ts", "chunked_list": ["type Expect<T extends true> = T\n\ttype Equal<A, B> =\n\t  // prettier-ignore\n\t  (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2)\n\t    ? true\n\t    : false\n"]}
{"filename": "src/transforms.ts", "chunked_list": ["import { typeOf } from './internals'\n\ttype KebabToCamel<Str> = Str extends `${infer First}-${infer Rest}`\n\t  ? `${First}${Capitalize<KebabToCamel<Rest>>}`\n\t  : Str\n\ttype SnakeToCamel<Str> = Str extends `${infer First}_${infer Rest}`\n\t  ? `${First}${Capitalize<SnakeToCamel<Rest>>}`\n\t  : Str\n\ttype KebabToSnake<Str> = Str extends `${infer First}-${infer Rest}`\n\t  ? `${First}_${KebabToSnake<Rest>}`\n\t  : Str\n", "type SnakeToKebab<Str> = Str extends `${infer First}_${infer Rest}`\n\t  ? `${First}-${SnakeToKebab<Rest>}`\n\t  : Str\n\ttype HandleFirstChar<Str> = Str extends `${infer First}${infer Rest}`\n\t  ? `${Lowercase<First>}${Rest}`\n\t  : Str\n\ttype CamelToSnakeFn<Str> = Str extends `${infer First}${infer Rest}`\n\t  ? `${First extends Capitalize<First>\n\t      ? '_'\n\t      : ''}${Lowercase<First>}${CamelToSnakeFn<Rest>}`\n", "  : Str\n\ttype CamelToSnake<Str> = CamelToSnakeFn<HandleFirstChar<Str>>\n\ttype CamelToKebabFn<Str> = Str extends `${infer First}${infer Rest}`\n\t  ? `${First extends Capitalize<First>\n\t      ? '-'\n\t      : ''}${Lowercase<First>}${CamelToKebabFn<Rest>}`\n\t  : Str\n\ttype CamelToKebab<Str> = CamelToKebabFn<HandleFirstChar<Str>>\n\tfunction words(str: string) {\n\t  const matches = str.match(\n", "    /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g,\n\t  )\n\t  return matches ? Array.from(matches) : [str]\n\t}\n\tfunction toCamelCase(str: string) {\n\t  const result = words(str)\n\t    .map((x) => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase())\n\t    .join('')\n\t  return result.slice(0, 1).toLowerCase() + result.slice(1)\n\t}\n", "function toKebabCase(str: string) {\n\t  return words(str)\n\t    .map((x) => x.toLowerCase())\n\t    .join('-')\n\t}\n\tfunction toSnakeCase(str: string) {\n\t  return words(str)\n\t    .map((x) => x.toLowerCase())\n\t    .join('_')\n\t}\n", "function deepTransformKeys<T>(obj: T, transform: (s: string) => string): T {\n\t  if (!['object', 'array'].includes(typeOf(obj))) return obj\n\t  if (Array.isArray(obj)) {\n\t    return obj.map((x) => deepTransformKeys(x, transform)) as T\n\t  }\n\t  const res = {} as T\n\t  for (const key in obj) {\n\t    res[transform(key) as keyof T] = deepTransformKeys(obj[key], transform)\n\t  }\n\t  return res\n", "}\n\ttype DeepKebabToCamel<T> = T extends [any, ...any]\n\t  ? { [I in keyof T]: DeepKebabToCamel<T[I]> }\n\t  : T extends (infer V)[]\n\t  ? DeepKebabToCamel<V>[]\n\t  : {\n\t      [K in keyof T as KebabToCamel<K>]: DeepKebabToCamel<T[K]>\n\t    }\n\tfunction kebabToCamel<T>(obj: T): DeepKebabToCamel<T> {\n\t  return deepTransformKeys(obj, toCamelCase) as never\n", "}\n\ttype DeepSnakeToCamel<T> = T extends [any, ...any]\n\t  ? { [I in keyof T]: DeepSnakeToCamel<T[I]> }\n\t  : T extends (infer V)[]\n\t  ? DeepSnakeToCamel<V>[]\n\t  : {\n\t      [K in keyof T as SnakeToCamel<K>]: DeepSnakeToCamel<T[K]>\n\t    }\n\tfunction snakeToCamel<T>(obj: T): DeepSnakeToCamel<T> {\n\t  return deepTransformKeys(obj, toCamelCase) as never\n", "}\n\ttype DeepCamelToSnake<T> = T extends [any, ...any]\n\t  ? { [I in keyof T]: DeepCamelToSnake<T[I]> }\n\t  : T extends (infer V)[]\n\t  ? DeepCamelToSnake<V>[]\n\t  : {\n\t      [K in keyof T as CamelToSnake<K>]: DeepCamelToSnake<T[K]>\n\t    }\n\tfunction camelToSnake<T>(obj: T): DeepCamelToSnake<T> {\n\t  return deepTransformKeys(obj, toSnakeCase) as never\n", "}\n\ttype DeepCamelToKebab<T> = T extends [any, ...any]\n\t  ? { [I in keyof T]: DeepCamelToKebab<T[I]> }\n\t  : T extends (infer V)[]\n\t  ? DeepCamelToKebab<V>[]\n\t  : {\n\t      [K in keyof T as CamelToKebab<K>]: DeepCamelToKebab<T[K]>\n\t    }\n\tfunction camelToKebab<T>(obj: T): DeepCamelToKebab<T> {\n\t  return deepTransformKeys(obj, toKebabCase) as never\n", "}\n\ttype DeepSnakeToKebab<T> = T extends [any, ...any]\n\t  ? { [I in keyof T]: DeepSnakeToKebab<T[I]> }\n\t  : T extends (infer V)[]\n\t  ? DeepSnakeToKebab<V>[]\n\t  : {\n\t      [K in keyof T as SnakeToKebab<K>]: DeepSnakeToKebab<T[K]>\n\t    }\n\tfunction snakeToKebab<T>(obj: T): DeepSnakeToKebab<T> {\n\t  return deepTransformKeys(obj, toKebabCase) as never\n", "}\n\ttype DeepKebabToSnake<T> = T extends [any, ...any]\n\t  ? { [I in keyof T]: DeepKebabToSnake<T[I]> }\n\t  : T extends (infer V)[]\n\t  ? DeepKebabToSnake<V>[]\n\t  : {\n\t      [K in keyof T as KebabToSnake<K>]: DeepKebabToSnake<T[K]>\n\t    }\n\tfunction kebabToSnake<T>(obj: T): DeepKebabToSnake<T> {\n\t  return deepTransformKeys(obj, toSnakeCase) as never\n", "}\n\texport type {\n\t  CamelToKebab,\n\t  CamelToSnake,\n\t  DeepCamelToKebab,\n\t  DeepCamelToSnake,\n\t  DeepKebabToCamel,\n\t  DeepKebabToSnake,\n\t  DeepSnakeToCamel,\n\t  DeepSnakeToKebab,\n", "  KebabToCamel,\n\t  KebabToSnake,\n\t  SnakeToCamel,\n\t  SnakeToKebab,\n\t}\n\texport {\n\t  camelToKebab,\n\t  camelToSnake,\n\t  kebabToCamel,\n\t  kebabToSnake,\n", "  snakeToCamel,\n\t  snakeToKebab,\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { HTTP_METHODS } from './constants'\n\timport { getJson, getText } from './internals'\n\ttype Schema<T> = { parse: (d: unknown) => T }\n\ttype JSONValue =\n\t  | string\n\t  | number\n\t  | boolean\n\t  | { [x: string]: JSONValue }\n\t  | Array<JSONValue>\n\ttype SearchParams = ConstructorParameters<typeof URLSearchParams>[0]\n", "type TypedResponse = Omit<Response, 'json' | 'text'> & {\n\t  json: TypedResponseJson\n\t  text: TypedResponseText\n\t}\n\ttype PathParams<T> = T extends string\n\t  ? ExtractPathParams<T> extends Record<string, unknown>\n\t    ? ExtractPathParams<T>\n\t    : Record<string, string>\n\t  : Record<string, string>\n\ttype EnhancedRequestInit<T = string> = Omit<RequestInit, 'body' | 'method'> & {\n", "  method?: HTTPMethod | Lowercase<HTTPMethod>\n\t  body?: JSONValue | BodyInit | null\n\t  query?: SearchParams\n\t  params?: PathParams<T>\n\t  trace?: (...args: Parameters<typeof fetch>) => void\n\t}\n\ttype ServiceRequestInit<T = string> = Omit<EnhancedRequestInit<T>, 'method'>\n\ttype HTTPMethod = (typeof HTTP_METHODS)[number]\n\ttype TypedResponseJson = ReturnType<typeof getJson>\n\ttype TypedResponseText = ReturnType<typeof getText>\n", "type Prettify<T> = {\n\t  [K in keyof T]: T[K]\n\t} & {}\n\ttype ExtractPathParams<T extends string> =\n\t  T extends `${infer _}:${infer Param}/${infer Rest}`\n\t    ? Prettify<Omit<{ [K in Param]: string } & ExtractPathParams<Rest>, ''>>\n\t    : T extends `${infer _}:${infer Param}`\n\t    ? { [K in Param]: string }\n\t    : {}\n\texport type {\n", "  EnhancedRequestInit,\n\t  HTTPMethod,\n\t  JSONValue,\n\t  PathParams,\n\t  Schema,\n\t  SearchParams,\n\t  ServiceRequestInit,\n\t  TypedResponse,\n\t  TypedResponseJson,\n\t  TypedResponseText,\n", "}\n"]}
{"filename": "src/primitives.test.ts", "chunked_list": ["import * as subject from './primitives'\n\tbeforeEach(() => {\n\t  vi.clearAllMocks()\n\t})\n\tdescribe('addQueryToURL', () => {\n\t  it('should add the query object to a string input', () => {\n\t    expect(subject.addQueryToURL('https://example.com/api', { id: '1' })).toBe(\n\t      'https://example.com/api?id=1',\n\t    )\n\t    expect(\n", "      subject.addQueryToURL('https://example.com/api', 'page=2&foo=bar'),\n\t    ).toBe('https://example.com/api?page=2&foo=bar')\n\t  })\n\t  it('should add the query object to a URL input', () => {\n\t    expect(\n\t      subject.addQueryToURL(new URL('https://example.com/api'), {\n\t        id: '1',\n\t      }),\n\t    ).toEqual(new URL('https://example.com/api?id=1'))\n\t    expect(\n", "      subject.addQueryToURL(new URL('https://example.com/api'), 'page=2'),\n\t    ).toEqual(new URL('https://example.com/api?page=2'))\n\t  })\n\t  it('should append the query to a URL string that already has QS', () => {\n\t    expect(\n\t      subject.addQueryToURL('https://example.com/api?id=1', { page: '2' }),\n\t    ).toBe('https://example.com/api?id=1&page=2')\n\t    expect(\n\t      subject.addQueryToURL('https://example.com/api?id=1', 'page=2'),\n\t    ).toBe('https://example.com/api?id=1&page=2')\n", "    expect(\n\t      subject.addQueryToURL(\n\t        'https://example.com/api?id=1',\n\t        new URLSearchParams({ page: '2' }),\n\t      ),\n\t    ).toBe('https://example.com/api?id=1&page=2')\n\t  })\n\t  it('should append the query to a URL instance that already has QS', () => {\n\t    expect(\n\t      subject.addQueryToURL(new URL('https://example.com/api?id=1'), {\n", "        page: '2',\n\t      }),\n\t    ).toEqual(new URL('https://example.com/api?id=1&page=2'))\n\t    expect(\n\t      subject.addQueryToURL(new URL('https://example.com/api?id=1'), 'page=2'),\n\t    ).toEqual(new URL('https://example.com/api?id=1&page=2'))\n\t    expect(\n\t      subject.addQueryToURL(\n\t        new URL('https://example.com/api?id=1'),\n\t        new URLSearchParams({ page: '2' }),\n", "      ),\n\t    ).toEqual(new URL('https://example.com/api?id=1&page=2'))\n\t  })\n\t  it(\"should return the input in case there's no query\", () => {\n\t    expect(subject.addQueryToURL('https://example.com/api')).toBe(\n\t      'https://example.com/api',\n\t    )\n\t    expect(subject.addQueryToURL(new URL('https://example.com/api'))).toEqual(\n\t      new URL('https://example.com/api'),\n\t    )\n", "  })\n\t})\n\tdescribe('ensureStringBody', () => {\n\t  it('should return the same if body was string', () => {\n\t    expect(subject.ensureStringBody('foo')).toBe('foo')\n\t  })\n\t  it('should return the same if body was not defined', () => {\n\t    expect(subject.ensureStringBody()).toBeUndefined()\n\t  })\n\t  it('should stringify the body if it is a JSON-like value', () => {\n", "    expect(subject.ensureStringBody({ page: 2 })).toBe(`{\"page\":2}`)\n\t    expect(subject.ensureStringBody([1, 2])).toBe(`[1,2]`)\n\t    expect(subject.ensureStringBody(3)).toBe(`3`)\n\t    expect(subject.ensureStringBody(true)).toBe(`true`)\n\t    expect(subject.ensureStringBody({})).toBe(`{}`)\n\t  })\n\t  it('should not stringify other valid kinds of BodyInit', () => {\n\t    const ab = new ArrayBuffer(0)\n\t    expect(subject.ensureStringBody(ab)).toBe(ab)\n\t    const rs = new ReadableStream()\n", "    expect(subject.ensureStringBody(rs)).toBe(rs)\n\t    const fd = new FormData()\n\t    expect(subject.ensureStringBody(fd)).toBe(fd)\n\t    const usp = new URLSearchParams()\n\t    expect(subject.ensureStringBody(usp)).toBe(usp)\n\t    const blob = new Blob()\n\t    expect(subject.ensureStringBody(blob)).toBe(blob)\n\t  })\n\t})\n\tdescribe('makeGetApiURL', () => {\n", "  it('should return a URL which is baseURL and path joined', () => {\n\t    expect(subject.makeGetApiURL('https://example.com/api')('/users')).toBe(\n\t      'https://example.com/api/users',\n\t    )\n\t  })\n\t  it('should accept an object-like queryString and return it joined to the URL', () => {\n\t    const getApiURL = subject.makeGetApiURL('https://example.com/api')\n\t    expect(getApiURL('/users', { id: '1' })).toBe(\n\t      'https://example.com/api/users?id=1',\n\t    )\n", "    expect(getApiURL('/users', { active: 'true', page: '2' })).toBe(\n\t      'https://example.com/api/users?active=true&page=2',\n\t    )\n\t  })\n\t  it('should accept a URL as baseURL and remove extra slashes', () => {\n\t    expect(\n\t      subject.makeGetApiURL(new URL('https://example.com/api'))('/users'),\n\t    ).toBe('https://example.com/api/users')\n\t    expect(\n\t      subject.makeGetApiURL(new URL('https://example.com/api/'))('/users'),\n", "    ).toBe('https://example.com/api/users')\n\t    expect(\n\t      subject.makeGetApiURL(new URL('https://example.com/api/'))('///users'),\n\t    ).toBe('https://example.com/api/users')\n\t  })\n\t  it('should add missing slashes', () => {\n\t    expect(\n\t      subject.makeGetApiURL(new URL('https://example.com/api'))('users'),\n\t    ).toBe('https://example.com/api/users')\n\t  })\n", "})\n\tdescribe('mergeHeaders', () => {\n\t  it('should merge diferent kinds of Headers', () => {\n\t    expect(\n\t      subject.mergeHeaders(new Headers({ a: '1' }), { b: '2' }, [['c', '3']]),\n\t    ).toEqual(new Headers({ a: '1', b: '2', c: '3' }))\n\t  })\n\t  it('should merge diferent kinds of Headers and override values', () => {\n\t    expect(\n\t      subject.mergeHeaders(new Headers({ a: '1' }), { a: '2' }, [['a', '3']]),\n", "    ).toEqual(new Headers({ a: '3' }))\n\t  })\n\t  it('should merge diferent kinds of Headers and delete undefined values', () => {\n\t    expect(\n\t      subject.mergeHeaders(new Headers({ a: '1' }), { a: undefined }),\n\t    ).toEqual(new Headers({}))\n\t    expect(\n\t      subject.mergeHeaders(new Headers({ a: '1' }), { a: 'undefined' }),\n\t    ).toEqual(new Headers({}))\n\t    expect(\n", "      subject.mergeHeaders(new Headers({ a: '1' }), [['a', undefined]]),\n\t    ).toEqual(new Headers({}))\n\t  })\n\t})\n\tdescribe('replaceURLParams', () => {\n\t  it('should replace the wildcards in an URL string with the given parameters', () => {\n\t    expect(subject.replaceURLParams('/users/:id', { id: '1' })).toBe('/users/1')\n\t    expect(\n\t      subject.replaceURLParams('http://example.com/users/:id/posts/:postId', {\n\t        id: '1',\n", "        postId: '3',\n\t      }),\n\t    ).toBe('http://example.com/users/1/posts/3')\n\t  })\n\t  it('should replace the wildcards in an instance of URL', () => {\n\t    expect(\n\t      subject.replaceURLParams(new URL('/users/:id', 'http://example.com'), {\n\t        id: '1',\n\t      }),\n\t    ).toEqual(new URL('http://example.com/users/1'))\n", "  })\n\t})\n"]}
{"filename": "src/transforms.test.ts", "chunked_list": ["import type * as Subject from './transforms'\n\timport * as subject from './transforms'\n\tnamespace TypeTransforms {\n\t  type test1 = Expect<\n\t    Equal<Subject.CamelToKebab<'camelToKebab'>, 'camel-to-kebab'>\n\t  >\n\t  type test2 = Expect<\n\t    Equal<Subject.CamelToSnake<'camelToSnake'>, 'camel_to_snake'>\n\t  >\n\t  type test3 = Expect<\n", "    Equal<Subject.KebabToCamel<'kebab-to-camel'>, 'kebabToCamel'>\n\t  >\n\t  type test4 = Expect<\n\t    Equal<Subject.KebabToSnake<'kebab-to-snake'>, 'kebab_to_snake'>\n\t  >\n\t  type test5 = Expect<\n\t    Equal<Subject.SnakeToCamel<'snake_to_camel'>, 'snakeToCamel'>\n\t  >\n\t  type test6 = Expect<\n\t    Equal<Subject.SnakeToKebab<'snake_to_kebab'>, 'snake-to-kebab'>\n", "  >\n\t}\n\tdescribe('deep transforms', () => {\n\t  test('camelToKebab', () => {\n\t    const result = subject.camelToKebab({\n\t      some: { deepNested: { value: true } },\n\t      otherValue: true,\n\t    })\n\t    expect(result).toEqual({\n\t      some: { 'deep-nested': { value: true } },\n", "      'other-value': true,\n\t    })\n\t    type test = Expect<\n\t      Equal<\n\t        typeof result,\n\t        { some: { 'deep-nested': { value: boolean } }; 'other-value': boolean }\n\t      >\n\t    >\n\t  })\n\t  test('camelToSnake', () => {\n", "    const result = subject.camelToSnake({\n\t      some: { deepNested: { value: true } },\n\t      otherValue: true,\n\t    })\n\t    expect(result).toEqual({\n\t      some: { deep_nested: { value: true } },\n\t      other_value: true,\n\t    })\n\t    type test = Expect<\n\t      Equal<\n", "        typeof result,\n\t        { some: { deep_nested: { value: boolean } }; other_value: boolean }\n\t      >\n\t    >\n\t  })\n\t  test('kebabToCamel', () => {\n\t    const result = subject.kebabToCamel({\n\t      some: { 'deep-nested': { value: true } },\n\t      'other-value': true,\n\t    })\n", "    expect(result).toEqual({\n\t      some: { deepNested: { value: true } },\n\t      otherValue: true,\n\t    })\n\t    type test = Expect<\n\t      Equal<\n\t        typeof result,\n\t        { some: { deepNested: { value: boolean } }; otherValue: boolean }\n\t      >\n\t    >\n", "  })\n\t  test('kebabToSnake', () => {\n\t    const result = subject.kebabToSnake({\n\t      some: { 'deep-nested': { value: true } },\n\t      'other-value': true,\n\t    })\n\t    expect(result).toEqual({\n\t      some: { deep_nested: { value: true } },\n\t      other_value: true,\n\t    })\n", "    type test = Expect<\n\t      Equal<\n\t        typeof result,\n\t        { some: { deep_nested: { value: boolean } }; other_value: boolean }\n\t      >\n\t    >\n\t  })\n\t  test('snakeToCamel', () => {\n\t    const result = subject.snakeToCamel({\n\t      some: { deep_nested: { value: true } },\n", "      other_value: true,\n\t    })\n\t    expect(result).toEqual({\n\t      some: { deepNested: { value: true } },\n\t      otherValue: true,\n\t    })\n\t    type test = Expect<\n\t      Equal<\n\t        typeof result,\n\t        { some: { deepNested: { value: boolean } }; otherValue: boolean }\n", "      >\n\t    >\n\t  })\n\t  test('snakeToKebab', () => {\n\t    const result = subject.snakeToKebab({\n\t      some: { deep_nested: { value: true } },\n\t      other_value: true,\n\t    })\n\t    expect(result).toEqual({\n\t      some: { 'deep-nested': { value: true } },\n", "      'other-value': true,\n\t    })\n\t    type test = Expect<\n\t      Equal<\n\t        typeof result,\n\t        { some: { 'deep-nested': { value: boolean } }; 'other-value': boolean }\n\t      >\n\t    >\n\t  })\n\t  test('should transform deep nested objects and array of objects', () => {\n", "    const result = subject.kebabToCamel([\n\t      { some: { 'deep-nested': [{ value: true }] } },\n\t    ])\n\t    expect(result).toEqual([{ some: { deepNested: [{ value: true }] } }])\n\t    type test = Expect<\n\t      Equal<typeof result, { some: { deepNested: { value: boolean }[] } }[]>\n\t    >\n\t  })\n\t})\n"]}
{"filename": "src/constants.ts", "chunked_list": ["const HTTP_METHODS = [\n\t  'GET',\n\t  'POST',\n\t  'PUT',\n\t  'DELETE',\n\t  'PATCH',\n\t  'OPTIONS',\n\t  'HEAD',\n\t  'CONNECT',\n\t  // 'TRACE', it has no support in most browsers yet\n", "] as const\n\texport { HTTP_METHODS }\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { enhancedFetch, makeFetcher, makeService, typedResponse } from './api'\n\texport {\n\t  addQueryToURL,\n\t  ensureStringBody,\n\t  makeGetApiURL,\n\t  mergeHeaders,\n\t  replaceURLParams,\n\t} from './primitives'\n\texport {\n\t  camelToKebab,\n", "  camelToSnake,\n\t  kebabToCamel,\n\t  kebabToSnake,\n\t  snakeToCamel,\n\t  snakeToKebab,\n\t} from './transforms'\n\texport type {\n\t  CamelToKebab,\n\t  CamelToSnake,\n\t  DeepCamelToKebab,\n", "  DeepCamelToSnake,\n\t  DeepKebabToCamel,\n\t  DeepKebabToSnake,\n\t  DeepSnakeToCamel,\n\t  DeepSnakeToKebab,\n\t  KebabToCamel,\n\t  KebabToSnake,\n\t  SnakeToCamel,\n\t  SnakeToKebab,\n\t} from './transforms'\n", "export type * from './types'\n"]}
{"filename": "src/api.test.ts", "chunked_list": ["import { HTTP_METHODS } from './constants'\n\timport * as subject from './api'\n\timport * as z from 'zod'\n\timport { HTTPMethod } from './types'\n\timport { kebabToCamel } from './transforms'\n\tconst reqMock = vi.fn()\n\tfunction successfulFetch(response: string | Record<string, unknown>) {\n\t  return async (input: URL | RequestInfo, init?: RequestInit | undefined) => {\n\t    reqMock({\n\t      url: input,\n", "      headers: init?.headers,\n\t      method: init?.method,\n\t      body: init?.body,\n\t    })\n\t    return new Response(\n\t      typeof response === 'string' ? response : JSON.stringify(response),\n\t    )\n\t  }\n\t}\n\tbeforeEach(() => {\n", "  vi.clearAllMocks()\n\t})\n\tdescribe('enhancedFetch', () => {\n\t  describe('json', () => {\n\t    it('should be untyped by default', async () => {\n\t      vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t        successfulFetch({ foo: 'bar' }),\n\t      )\n\t      const result = await subject\n\t        .enhancedFetch('https://example.com/api/users')\n", "        .then((r) => r.json())\n\t      type _R = Expect<Equal<typeof result, unknown>>\n\t      expect(result).toEqual({ foo: 'bar' })\n\t    })\n\t    it('should accept a type', async () => {\n\t      vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t        successfulFetch({ foo: 'bar' }),\n\t      )\n\t      const result = await subject\n\t        .enhancedFetch('https://example.com/api/users')\n", "        .then((r) => r.json<{ foo: string }>())\n\t      type _R = Expect<Equal<typeof result, { foo: string }>>\n\t      expect(result).toEqual({ foo: 'bar' })\n\t    })\n\t    it('should accept a parser', async () => {\n\t      vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t        successfulFetch({ foo: 'bar' }),\n\t      )\n\t      const result = await subject\n\t        .enhancedFetch('https://example.com/api/users')\n", "        .then((r) => r.json(z.object({ foo: z.string() })))\n\t      type _R = Expect<Equal<typeof result, { foo: string }>>\n\t      expect(result).toEqual({ foo: 'bar' })\n\t    })\n\t  })\n\t  describe('text', () => {\n\t    it('should be untyped by default', async () => {\n\t      vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t        successfulFetch({ foo: 'bar' }),\n\t      )\n", "      const result = await subject\n\t        .enhancedFetch('https://example.com/api/users')\n\t        .then((r) => r.text())\n\t      type _R = Expect<Equal<typeof result, string>>\n\t      expect(result).toEqual(`{\"foo\":\"bar\"}`)\n\t    })\n\t    it('should accept a type', async () => {\n\t      vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t        successfulFetch('john@doe.com'),\n\t      )\n", "      const result = await subject\n\t        .enhancedFetch('https://example.com/api/users')\n\t        .then((r) => r.text<`${string}@${string}.${string}`>())\n\t      type _R = Expect<Equal<typeof result, `${string}@${string}.${string}`>>\n\t      expect(result).toEqual('john@doe.com')\n\t    })\n\t    it('should accept a parser', async () => {\n\t      vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t        successfulFetch('john@doe.com'),\n\t      )\n", "      const result = await subject\n\t        .enhancedFetch('https://example.com/api/users')\n\t        .then((r) => r.text(z.string().email()))\n\t      type _R = Expect<Equal<typeof result, string>>\n\t      expect(result).toEqual('john@doe.com')\n\t    })\n\t  })\n\t  it('should accept a schema that transforms the response', async () => {\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: { 'deep-nested': { 'kind-of-value': true } } }),\n", "    )\n\t    const result = await subject\n\t      .enhancedFetch('https://example.com/api/users')\n\t      .then((r) =>\n\t        r.json(\n\t          z\n\t            .object({\n\t              foo: z.object({\n\t                'deep-nested': z.object({ 'kind-of-value': z.boolean() }),\n\t              }),\n", "            })\n\t            .transform(kebabToCamel),\n\t        ),\n\t      )\n\t    type _R = Expect<\n\t      Equal<typeof result, { foo: { deepNested: { kindOfValue: boolean } } }>\n\t    >\n\t    expect(result).toEqual({ foo: { deepNested: { kindOfValue: true } } })\n\t  })\n\t  it('should replace params in the URL', async () => {\n", "    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    await subject.enhancedFetch(\n\t      'https://example.com/api/users/:user/page/:page',\n\t      {\n\t        params: {\n\t          user: '1',\n\t          page: '2',\n\t          // @ts-expect-error\n", "          foo: 'bar',\n\t        },\n\t      },\n\t    )\n\t    expect(reqMock).toHaveBeenCalledWith({\n\t      url: 'https://example.com/api/users/1/page/2',\n\t      headers: new Headers({\n\t        'content-type': 'application/json',\n\t      }),\n\t    })\n", "  })\n\t  it('should accept a requestInit and a query', async () => {\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    await subject.enhancedFetch('https://example.com/api/users', {\n\t      headers: { Authorization: 'Bearer 123' },\n\t      query: { admin: 'true' },\n\t    })\n\t    expect(reqMock).toHaveBeenCalledWith({\n", "      url: 'https://example.com/api/users?admin=true',\n\t      headers: new Headers({\n\t        authorization: 'Bearer 123',\n\t        'content-type': 'application/json',\n\t      }),\n\t    })\n\t  })\n\t  it('should accept a stringified body', async () => {\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n", "    )\n\t    await subject.enhancedFetch('https://example.com/api/users', {\n\t      body: JSON.stringify({ id: 1, name: { first: 'John', last: 'Doe' } }),\n\t      method: 'POST',\n\t    })\n\t    expect(reqMock).toHaveBeenCalledWith({\n\t      url: 'https://example.com/api/users',\n\t      headers: new Headers({ 'content-type': 'application/json' }),\n\t      method: 'POST',\n\t      body: `{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}`,\n", "    })\n\t  })\n\t  it('should stringify the body', async () => {\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    await subject.enhancedFetch('https://example.com/api/users', {\n\t      body: { id: 1, name: { first: 'John', last: 'Doe' } },\n\t      method: 'POST',\n\t    })\n", "    expect(reqMock).toHaveBeenCalledWith({\n\t      url: 'https://example.com/api/users',\n\t      headers: new Headers({ 'content-type': 'application/json' }),\n\t      method: 'POST',\n\t      body: `{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}`,\n\t    })\n\t  })\n\t  it('should accept a trace function for debugging purposes', async () => {\n\t    const trace = vi.fn()\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n", "      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    await subject.enhancedFetch('https://example.com/api/users', {\n\t      body: { id: 1, name: { first: 'John', last: 'Doe' } },\n\t      query: { admin: 'true' },\n\t      trace,\n\t      method: 'POST',\n\t    })\n\t    expect(trace).toHaveBeenCalledWith(\n\t      'https://example.com/api/users?admin=true',\n", "      {\n\t        headers: new Headers({ 'content-type': 'application/json' }),\n\t        method: 'POST',\n\t        body: `{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}`,\n\t      },\n\t    )\n\t  })\n\t})\n\tdescribe('makeFetcher', () => {\n\t  it('should return a applied enhancedFetch', async () => {\n", "    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    const service = subject.makeFetcher('https://example.com/api')\n\t    const result = await service('/users', { method: 'post' }).then((r) =>\n\t      r.json(z.object({ foo: z.string() })),\n\t    )\n\t    type _R = Expect<Equal<typeof result, { foo: string }>>\n\t    expect(result).toEqual({ foo: 'bar' })\n\t    expect(reqMock).toHaveBeenCalledWith({\n", "      url: 'https://example.com/api/users',\n\t      headers: new Headers({ 'content-type': 'application/json' }),\n\t      method: 'post',\n\t    })\n\t  })\n\t  it('should add headers to the request', async () => {\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    const fetcher = subject.makeFetcher('https://example.com/api', {\n", "      Authorization: 'Bearer 123',\n\t    })\n\t    await fetcher('/users')\n\t    expect(reqMock).toHaveBeenCalledWith({\n\t      url: 'https://example.com/api/users',\n\t      headers: new Headers({\n\t        authorization: 'Bearer 123',\n\t        'content-type': 'application/json',\n\t      }),\n\t    })\n", "  })\n\t  it('should accept a typed params object', async () => {\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    const fetcher = subject.makeFetcher('https://example.com/api')\n\t    await fetcher('/users/:id', {\n\t      params: {\n\t        id: '1',\n\t        // @ts-expect-error\n", "        foo: 'bar',\n\t      },\n\t    })\n\t    expect(reqMock).toHaveBeenCalledWith({\n\t      url: 'https://example.com/api/users/1',\n\t      headers: new Headers({ 'content-type': 'application/json' }),\n\t    })\n\t  })\n\t  it('should accept a function for dynamic headers', async () => {\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n", "      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    const fetcher = subject.makeFetcher('https://example.com/api', () => ({\n\t      Authorization: 'Bearer 123',\n\t    }))\n\t    await fetcher('/users')\n\t    expect(reqMock).toHaveBeenCalledWith({\n\t      url: 'https://example.com/api/users',\n\t      headers: new Headers({\n\t        authorization: 'Bearer 123',\n", "        'content-type': 'application/json',\n\t      }),\n\t    })\n\t  })\n\t  it('should accept an async function for dynamic headers', async () => {\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    const fetcher = subject.makeFetcher(\n\t      'https://example.com/api',\n", "      async () => ({\n\t        Authorization: 'Bearer 123',\n\t      }),\n\t    )\n\t    await fetcher('/users')\n\t    expect(reqMock).toHaveBeenCalledWith({\n\t      url: 'https://example.com/api/users',\n\t      headers: new Headers({\n\t        authorization: 'Bearer 123',\n\t        'content-type': 'application/json',\n", "      }),\n\t    })\n\t  })\n\t  it('should accept a query, trace, and JSON-like body', async () => {\n\t    const trace = vi.fn()\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    const fetcher = subject.makeFetcher('https://example.com/api')\n\t    await fetcher('/users', {\n", "      method: 'POST',\n\t      body: { id: 1, name: { first: 'John', last: 'Doe' } },\n\t      query: { admin: 'true' },\n\t      trace,\n\t    })\n\t    expect(trace).toHaveBeenCalledWith(\n\t      'https://example.com/api/users?admin=true',\n\t      {\n\t        headers: new Headers({ 'content-type': 'application/json' }),\n\t        method: 'POST',\n", "        body: `{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}`,\n\t      },\n\t    )\n\t  })\n\t})\n\tdescribe('makeService', () => {\n\t  it('should return an object with http methods', () => {\n\t    const service = subject.makeService('https://example.com/api')\n\t    for (const method of HTTP_METHODS) {\n\t      expect(\n", "        typeof service[method.toLocaleLowerCase() as Lowercase<HTTPMethod>],\n\t      ).toBe('function')\n\t    }\n\t  })\n\t  it('should return an API with enhancedFetch', async () => {\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    const service = subject.makeService('https://example.com/api')\n\t    const result = await service\n", "      .post('/users')\n\t      .then((r) => r.json(z.object({ foo: z.string() })))\n\t    type _R = Expect<Equal<typeof result, { foo: string }>>\n\t    expect(result).toEqual({ foo: 'bar' })\n\t    expect(reqMock).toHaveBeenCalledWith({\n\t      url: 'https://example.com/api/users',\n\t      headers: new Headers({ 'content-type': 'application/json' }),\n\t      method: 'POST',\n\t    })\n\t  })\n", "  it('should accept a typed params object', async () => {\n\t    vi.spyOn(global, 'fetch').mockImplementationOnce(\n\t      successfulFetch({ foo: 'bar' }),\n\t    )\n\t    const service = subject.makeService('https://example.com/api')\n\t    await service.get('/users/:id', {\n\t      params: {\n\t        id: '1',\n\t        // @ts-expect-error\n\t        foo: 'bar',\n", "      },\n\t    })\n\t    expect(reqMock).toHaveBeenCalledWith({\n\t      url: 'https://example.com/api/users/1',\n\t      headers: new Headers({ 'content-type': 'application/json' }),\n\t      method: 'GET',\n\t    })\n\t  })\n\t})\n\tdescribe('typedResponse', () => {\n", "  it('should return unknown by default when turning into a JSON', async () => {\n\t    const result = await subject.typedResponse(new Response('1')).json()\n\t    type _R = Expect<Equal<typeof result, unknown>>\n\t    expect(result).toEqual(1)\n\t  })\n\t  it('should accept a type for the JSON method', async () => {\n\t    const result = await subject\n\t      .typedResponse(new Response(`{\"foo\":\"bar\"}`))\n\t      .json<{ foo: string }>()\n\t    type _R = Expect<Equal<typeof result, { foo: string }>>\n", "    expect(result).toEqual({ foo: 'bar' })\n\t  })\n\t  it('should accept a parser for the JSON method', async () => {\n\t    const result = await subject\n\t      .typedResponse(new Response(`{\"foo\":\"bar\"}`))\n\t      .json(z.object({ foo: z.string() }))\n\t    type _R = Expect<Equal<typeof result, { foo: string }>>\n\t    expect(result).toEqual({ foo: 'bar' })\n\t  })\n\t})\n"]}
