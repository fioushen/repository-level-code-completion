{"filename": "src/utils.ts", "chunked_list": ["import Express from \"express\";\n\timport { ApiError } from \"./const/errors\";\n\texport function sendErrorResponse(res: Express.Response, error: ApiError) {\n\t    res.status(error.status);\n\t    res.json(error)\n\t}\n\texport function sendJSONResponse(res: Express.Response, obj: any, status?: number) {\n\t    res.status(obj.status ?? status ?? 200);\n\t    res.json(obj)\n\t}\n", "export function isURL(u: string): boolean {\n\t\t\ttry {\n\t\t\t\t\tnew URL(u)\n\t\t\t\t\treturn true;\n\t\t\t} catch { return false }\n\t}\n"]}
{"filename": "src/server.ts", "chunked_list": ["import express from \"express\";\n\timport routeEmailValidate from \"./routes/EmailValidate\"\n\timport routeEmailSend from \"./routes/EmailSend\"\n\timport EmailCache from \"./models/EmailCache\";\n\timport { ErrorCodes } from \"./const/errors\";\n\timport { sendErrorResponse } from \"./utils\" ;\n\timport path from \"node:path\";\n\tconst app = express();\n\tapp.use(express.static('./public'))\n\tapp.use(express.json());\n", "app.use((err: any, req: any, res: any, next: any) => {\n\t    if (err instanceof SyntaxError) \n\t\t\t\t\tsendErrorResponse(res as express.Response, {\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\t\tcode: ErrorCodes.BAD_INPUT,\n\t\t\t\t\t\t\t\t\tmessage: \"Bad JSON input\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstatus: 400\n\t\t\t\t\t})\n\t        return;\n", "});\n\t(async () => {\n\t    await EmailCache.init();\n\t\t\tapp.get(\"/\", (req, res) => {\n\t\t\t\t\tconsole.log(path.join(__dirname, \"./public/index.html\"))\n\t\t\t\t\tres.sendFile(path.join(__dirname, \"../public/index.html\"))\n\t\t\t})\n\t    app.get(\"/api/v1/email/validate\", routeEmailValidate)\n\t\t\tapp.post(\"/api/v1/email/send\", routeEmailSend)\n\t})();\n", "process.on(\"exit\", async () => {\n\t   await EmailCache.close();\n\t})\n\texport default app;\n"]}
{"filename": "src/index.ts", "chunked_list": ["import server from \"./server\";\n\tconst PORT = process.env.PORT || 3000;\n\tserver.listen(PORT, () => {\n\t    console.log(`server listening at http://127.0.0.1:${PORT}`)\n\t})"]}
{"filename": "src/const/vars.ts", "chunked_list": ["import dotenv from \"dotenv\";\n\tdotenv.config();\n\texport const MAIL_CONFIG = {\n\t\t\taddress: process.env.MAIL_ADDRESS,\n\t\t\tpassword: process.env.MAIL_PASSWORD,\n\t}\n\texport const REDIS_CONFIG = {\n\t\tusername: process.env.REDIS_USERNAME,\n\t\tpassword: process.env.REDIS_PASSWORD,\n\t\thost: process.env.REDIS_HOST,\n", "\tport: Number(process.env.REDIS_PORT),\n\t}"]}
{"filename": "src/const/email.ts", "chunked_list": ["export interface Mail {\n\t\t\tto: Array<{\n\t\t\t\t\tname: string,\n\t\t\t\t\temail: string,\n\t\t\t}>\n\t\t\tfrom: {\n\t\t\t\t\temail: string,\n\t\t\t\t\tname: string,\n\t\t\t}\n\t\t\tsubject: string,\n", "\t\tbody: {\n\t\t\t\t\ttype: \"text\" | \"html\",\n\t\t\t\t\tcontent: string,\n\t\t\t}\n\t}\n"]}
{"filename": "src/const/errors.ts", "chunked_list": ["export enum ErrorCodes {\n\t  VALIDATION = 'validation_error',\n\t  DATABASE = 'database_error',\n\t  EXTERNAL_SERVICE = 'external_service_error',\n\t  RESOURCE_NOT_FOUND = 'resource_not_found_error',\n\t  BAD_INPUT = \"bad_input\",\n\t  TOO_MANY_REQUESTS = \"too_many_requests\",\n\t  INTERNAL_ERROR = \"internal_error\",\n\t}\n\texport interface ApiError {\n", "\t\terror: {\n\t\t\t\t\tcode: ErrorCodes,\n\t\t\t\t\tmessage: string,\n\t\t\t\t\tdetails?: any,\n\t\t\t}\n\t\t\tstatus: number,\n\t}\n"]}
{"filename": "src/const/mailSchema.ts", "chunked_list": ["const schema = {\n\t  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n\t  \"type\": \"object\",\n\t  \"properties\": {\n\t    \"to\": {\n\t      \"type\": \"array\",\n\t      \"items\": {\n\t        \"type\": \"object\",\n\t        \"properties\": {\n\t          \"name\": {\"type\": \"string\"},\n", "          \"email\": {\"type\": \"string\", \"format\": \"email\"}\n\t        },\n\t        \"required\": [\"name\", \"email\"]\n\t      },\n\t      \"minItems\": 1\n\t    },\n\t\t\t\"from\": {\"type\": \"string\"},\n\t    \"subject\": {\"type\": \"string\"},\n\t    \"body\": {\n\t      \"type\": \"object\",\n", "      \"properties\": {\n\t        \"type\": {\"type\": \"string\", \"enum\": [\"text\", \"html\"]},\n\t        \"content\": {\"type\": \"string\"}\n\t      },\n\t      \"required\": [\"type\", \"content\"]\n\t    }\n\t  },\n\t  \"required\": [\"to\", \"from\", \"subject\", \"body\"]\n\t}\n\texport default schema;\n"]}
{"filename": "src/models/RateLimiter.ts", "chunked_list": ["import Express from \"express\";\n\tclass RateLimiter {\n\t\t\ttimeout: number;\n\t\t\tlimit: number;\n\t\t\ttimeOfLastRequestByIp: Map<string, number>;\n\t\t\trequestsSentByIp: Map<string, number>;\n\t\t\tconstructor(limit: number, timeout: number) {\n\t\t\t\t\tthis.timeOfLastRequestByIp = new Map();\n\t\t\t\t\tthis.requestsSentByIp = new Map();\n\t\t\t\t\tthis.limit = limit;\n", "\t\t\t\tthis.timeout = timeout;\n\t\t\t}\n\t\t\tcheckIfTimedOut(req: Express.Request): boolean {\n\t\t\t\t\tconst { ip } = req;\n\t\t\t\t\tconst reqCount = this.requestsSentByIp.get(ip) ?? 0;\n\t\t\t\t\tconst timeOfLast = this.timeOfLastRequestByIp.get(ip) ?? 0;\n\t\t\t\t\tif (reqCount === this.limit && (Date.now() - timeOfLast) < this.timeout) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n", "\t\t}\n\t\t\tlogRequest(req: Express.Request) {\n\t\t\t\t\tconst { ip } = req;\n\t\t\t\t\tthis.timeOfLastRequestByIp.set(ip, Date.now());\n\t\t\t\t\tconst reqCount = this.requestsSentByIp.get(ip) ?? 0;\n\t\t\t\t\tthis.requestsSentByIp.set(ip, reqCount + 1);\n\t\t\t}\n\t\t\tresetRequest(req: Express.Request) {\n\t\t\t\t\tconst { ip } = req;\n\t\t\t\t\tsetTimeout(() => {\n", "\t\t\t\t\t\tthis.requestsSentByIp.set(ip, 0);\n\t\t\t\t\t}, this.timeout)\n\t\t\t}\n\t}\n\texport default RateLimiter;\n"]}
{"filename": "src/models/EmailCache.ts", "chunked_list": ["import { createClient } from \"redis\";\n\timport { REDIS_CONFIG } from \"../const/vars\";\n\tclass EmailCache {\n\t\tclient: any;\n\t\tconstructor() {\n\t\t\tthis.client = createClient({\n\t\t\t\tsocket: {\n\t\t\t\t\thost: REDIS_CONFIG.host,\n\t\t\t\t\tport: REDIS_CONFIG.port,\n\t\t\t\t},\n", "\t\t\tusername: REDIS_CONFIG.username,\n\t\t\t\tpassword: REDIS_CONFIG.password\n\t\t\t});\n\t\t}\n\t\tasync init() {\n\t\t\tawait this.client.connect();\n\t\t}\n\t\tasync pushEmail(email: string, validity: Array<boolean>): Promise<string> {\n\t\t\ttry {\n\t\t\t\tconst resp = await this.client.set(email, JSON.stringify(validity));\n", "\t\t\treturn email;\n\t\t\t} catch (err) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t\tasync getEmail(email: string): Promise<Array<boolean> | null> {\n\t\t\ttry {\n\t\t\t\tconst resp = await this.client.get(email)\n\t\t\t\treturn JSON.parse(resp ?? \"[]\");\n\t\t\t} catch (err) {\n", "\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t\tasync close() {\n\t\t\tthis.client.close();\n\t\t}\n\t}\n\texport default new EmailCache();\n"]}
{"filename": "src/routes/EmailValidate.ts", "chunked_list": ["import Express from \"express\";\n\timport { ErrorCodes } from \"../const/errors\";\n\timport { sendErrorResponse, sendJSONResponse, isURL } from \"../utils\";\n\timport dns from \"node:dns\";\n\timport EmailCache from \"../models/EmailCache\";\n\timport RateLimiter from \"../models/RateLimiter\";\n\tconst RATE_TIMEOUT = 5000;\n\tconst RATE_LIMITER = new RateLimiter(5, RATE_TIMEOUT); // Throttle the requests to prevent overload \n\tfunction validateEmailSyntax(email: string): boolean {\n\t  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n", "  const maxDomainLength = 255;\n\t  const maxLocalPartLength = 64;\n\t  const maxEmailLength = maxLocalPartLength + 1 + maxDomainLength;\n\t  if (email.length > maxEmailLength) {\n\t    return false;\n\t  }\n\t  const [localPart, domain] = email.split(\"@\");\n\t  if (localPart?.length > maxLocalPartLength || domain?.length > maxDomainLength) {\n\t    return false;\n\t  }\n", "  return regex.test(email);\n\t}\n\tfunction validateEmailDomain(email: string): Promise<boolean>  {\n\t\t\tif (!validateEmailSyntax(email)) return Promise.resolve(false);\n\t\t\tconst [mail, tld] = email.split(\"@\");\n\t\t\tif (!tld || !isURL(tld)) return Promise.resolve(false);\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tdns.resolve(tld, \"MX\", (err, addresses) => {\n\t\t\t\t\t\t\tif (err) resolve(false);\n\t\t\t\t\t\t\tresolve(addresses?.length > 0)\n", "\t\t\t\t})\n\t    })\n\t}\n\texport default async function (req: Express.Request, res: Express.Response) {\n\t\t\tconst queryEmail = req.query?.email;\n\t\t\tif (RATE_LIMITER.checkIfTimedOut(req)) {\n\t\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\t\tcode: ErrorCodes.TOO_MANY_REQUESTS,\n\t\t\t\t\t\t\t\t\tdetails: {\n", "\t\t\t\t\t\t\t\t\t\tretry_after: `${RATE_TIMEOUT} ms`\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmessage: \"Too many requests. Please try again later\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstatus: 429\n\t\t\t\t\t});\n\t\t\t\t\tRATE_LIMITER.resetRequest(req);\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tRATE_LIMITER.logRequest(req);\n", "\t\tif (!queryEmail || queryEmail?.length === 0) {\n\t\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\t\tcode: ErrorCodes.BAD_INPUT,\n\t\t\t\t\t\t\t\t\tmessage: \"email is a required argument\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstatus: 400\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t}\n", "\t\tconst cachedEmailData = await EmailCache.getEmail(queryEmail as string);\n\t\t\tlet emailChecks;\n\t\t\tif (cachedEmailData?.length) {\n\t\t\t\t\temailChecks = cachedEmailData;\n\t\t\t} else {\n\t\t\t\t\temailChecks = [\n\t\t\t\t\t\t\tvalidateEmailSyntax(queryEmail as string),\n\t\t\t\t\t\t\tawait validateEmailDomain(queryEmail as string)\n\t\t\t\t\t]\n\t\t\t}\n", "\t\temailChecks = emailChecks as Array<boolean>;\n\t\t\tconst response = {\n\t\t\t\t\tdata: {\n\t\t\t\t\t\t\temail: queryEmail as string,\n\t\t\t\t\t\t\tvalid: emailChecks.every(e => e),\n\t\t\t\t\t\t\tformat_valid: emailChecks[0],\n\t\t\t\t\t\t\tdomain_valid: emailChecks[1],\n\t\t\t\t\t},\n\t\t\t\t\tstatus: 200\n\t\t\t}\n", "\t\tif (!cachedEmailData?.length) {\n\t\t\t\t\tawait EmailCache.pushEmail(queryEmail as string, emailChecks as Array<boolean>);\n\t\t\t}\n\t\t\tsendJSONResponse(res, response)\n\t}\n"]}
{"filename": "src/routes/EmailSend.ts", "chunked_list": ["import Express from \"express\";\n\timport { ErrorCodes } from \"../const/errors\";\n\timport { sendErrorResponse, sendJSONResponse, isURL } from \"../utils\";\n\timport { MAIL_CONFIG } from \"../const/vars\";\n\timport nodemailer from \"nodemailer\"\n\t;\n\timport mailSchema from \"../const/mailSchema\";\n\timport { Mail } from \"../const/email\";\n\timport RateLimiter from \"../models/RateLimiter\";\n\tconst RATE_TIMEOUT = 20_000;\n", "const RATE_LIMITER = new RateLimiter(1, RATE_TIMEOUT); // Throttle the requests to prevent overload \n\timport Ajv from \"ajv\";\n\tconst ajv = new Ajv({ allErrors: true });\n\tajv.addFormat('email', {\n\t\t\ttype: 'string',\n\t\t\tvalidate: (value: string) => {\n\t\t\t\t\tconst emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\t\t\t\t\treturn emailRegex.test(value);\n\t\t\t},\n\t});\n", "const transporter = nodemailer.createTransport({\n\t  maxConnections: 2,\n\t  pool: true,\n\t  service: \"hotmail\",\n\t  auth: {\n\t\t  user: MAIL_CONFIG.address,\n\t    pass: MAIL_CONFIG.password\n\t  }\n\t});\n\tfunction sendMail(blob: Mail): Promise<string> {\n", "\t\tconst toEmails = blob.to.map(e => e.email);\n\t\t\tconst fromEmail = blob.from;\n\t\t\tconst body = `Forwarded via Zap<https://github.com/aadv1k/zap> originally by ${fromEmail}\\n` + blob.body.content;\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\ttransporter.sendMail({\n\t\t\t\t\t\t\tfrom: MAIL_CONFIG.address,\n\t\t\t\t\t\t\tto: toEmails,\n\t\t\t\t\t\t\tsubject: blob.subject,\n\t\t\t\t\t\t\thtml: body\n\t\t\t\t\t}, (error: any, info: any) => {\n", "\t\t\t\t\t\tif (error) reject(error);\n\t\t\t\t\t\t\tresolve(info.messageId);\n\t\t\t\t\t})\n\t\t\t})\n\t}\n\texport default async function (req: Express.Request, res: Express.Response) {\n\t\t\tif (RATE_LIMITER.checkIfTimedOut(req)) {\n\t\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\t\tcode: ErrorCodes.TOO_MANY_REQUESTS,\n", "\t\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\t\t\t\tretry_after: `${RATE_TIMEOUT} ms`\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmessage: \"Too many requests. Please try again later\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstatus: 429\n\t\t\t\t\t});\n\t\t\t\t\tRATE_LIMITER.resetRequest(req);\n\t\t\t\t\treturn;\n\t\t\t}\n", "\t\tRATE_LIMITER.logRequest(req);\n\t\t\tlet body: Mail;\n\t\t\ttry {\n\t\t\t\t\tbody = req.body;\n\t\t\t} catch (err) {\n\t\t\t\t\tconsole.log(\"DEBUG LOG >>>>> \", err)\n\t\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\t\tcode: ErrorCodes.BAD_INPUT,\n\t\t\t\t\t\t\t\t\tmessage: \"Invalid JSON data\",\n", "\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstatus: 400\n\t\t\t\t\t})\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst isMailValid = ajv.validate(mailSchema, body);\n\t\t\tif (!isMailValid)  {\n\t\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\t\tcode: ErrorCodes.BAD_INPUT,\n", "\t\t\t\t\t\t\t\tmessage: \"Bad input\",\n\t\t\t\t\t\t\t\t\tdetails: ajv.errors,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstatus: 400\n\t\t\t\t\t})\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t\tconst receivedMailId = await sendMail(body);\n\t\t\t\t\tsendJSONResponse(res, {\n", "\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\tmessageId: receivedMailId,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstatus: 200,\n\t\t\t\t\t}, 200)\n\t\t\t} catch (error) {\n\t\t\t\t\tsendErrorResponse(res, {\n\t\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\t\t\tcode: ErrorCodes.INTERNAL_ERROR,\n\t\t\t\t\t\t\t\t\tmessage: \"Internall error while sending mail\",\n", "\t\t\t\t\t\t\t\tdetails: error,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstatus: 500\n\t\t\t\t\t})\n\t\t\t}\n\t}\n"]}
