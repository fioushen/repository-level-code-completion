{"filename": "index.ts", "chunked_list": ["export * from \"./src\";\n"]}
{"filename": "src/api.ts", "chunked_list": ["export type Result<\n\t  D extends unknown = unknown,\n\t  C extends unknown = number | string,\n\t> = Ok<D> | Err<C>;\n\texport interface Ok<D extends unknown = null> {\n\t  ok: true;\n\t  err: false;\n\t  data: D;\n\t}\n\texport interface Err<\n", "  C extends unknown = number | string,\n\t  E extends Error = Error,\n\t  X extends { [key: string]: unknown } = { [key: string]: unknown },\n\t> {\n\t  ok: false;\n\t  err: true;\n\t  errCode: C;\n\t  errMessage: string;\n\t  errException: E | null;\n\t  errContext: X | null;\n", "}\n"]}
{"filename": "src/testUtils.ts", "chunked_list": ["import type { Result } from \"./api\";\n\timport { expect } from \"vitest\";\n\texport function assertResultEquals<R extends Result>(\n\t  result: R,\n\t  data: Partial<R>,\n\t): void {\n\t  expect(result).toEqual(expect.objectContaining(data));\n\t}\n"]}
{"filename": "src/helpers.spec.ts", "chunked_list": ["import type { Result } from \"./api\";\n\timport { err } from \"./err\";\n\timport {\n\t  allErr,\n\t  allOk,\n\t  assertIsErr,\n\t  assertIsOk,\n\t  assertIsResult,\n\t  isErrResult,\n\t  isOkResult,\n", "  isResult,\n\t  someErr,\n\t  someOk,\n\t} from \"./helpers\";\n\timport { ok } from \"./ok\";\n\timport { describe, expect, it } from \"vitest\";\n\tdescribe(\"helpers\", () => {\n\t  describe(\"isResult()\", () => {\n\t    it(\"should return true for an Ok result\", () => {\n\t      expect(isResult(ok())).toBeTruthy();\n", "    });\n\t    it(\"should return true for an Err result\", () => {\n\t      expect(isResult(err())).toBeTruthy();\n\t    });\n\t    it(\"should return true for any non Result input value\", () => {\n\t      expect(isResult(null)).toBeFalsy();\n\t      expect(isResult(undefined)).toBeFalsy();\n\t      expect(isResult(false)).toBeFalsy();\n\t      expect(isResult(true)).toBeFalsy();\n\t      expect(isResult({})).toBeFalsy();\n", "      expect(isResult([])).toBeFalsy();\n\t      expect(isResult(0)).toBeFalsy();\n\t      expect(isResult(\"\")).toBeFalsy();\n\t    });\n\t  });\n\t  describe(\"isOkResult()\", () => {\n\t    it(\"should return true for an Ok result\", () => {\n\t      expect(isOkResult(ok())).toBeTruthy();\n\t    });\n\t    it(\"should return false for an Ok result\", () => {\n", "      expect(isOkResult(err())).toBeFalsy();\n\t    });\n\t    it(\"should return true for any non Result input value\", () => {\n\t      expect(isOkResult(null)).toBeFalsy();\n\t      expect(isOkResult(undefined)).toBeFalsy();\n\t      expect(isOkResult(false)).toBeFalsy();\n\t      expect(isOkResult(true)).toBeFalsy();\n\t      expect(isOkResult({})).toBeFalsy();\n\t      expect(isOkResult([])).toBeFalsy();\n\t      expect(isOkResult(0)).toBeFalsy();\n", "      expect(isOkResult(\"\")).toBeFalsy();\n\t    });\n\t  });\n\t  describe(\"isErrResult()\", () => {\n\t    it(\"should return false for an Ok result\", () => {\n\t      expect(isErrResult(ok())).toBeFalsy();\n\t    });\n\t    it(\"should return true for an Err result\", () => {\n\t      expect(isErrResult(err())).toBeTruthy();\n\t    });\n", "    it(\"should return true for any non Result input value\", () => {\n\t      expect(isErrResult(null)).toBeFalsy();\n\t      expect(isErrResult(undefined)).toBeFalsy();\n\t      expect(isErrResult(false)).toBeFalsy();\n\t      expect(isErrResult(true)).toBeFalsy();\n\t      expect(isErrResult({})).toBeFalsy();\n\t      expect(isErrResult([])).toBeFalsy();\n\t      expect(isErrResult(0)).toBeFalsy();\n\t      expect(isErrResult(\"\")).toBeFalsy();\n\t    });\n", "  });\n\t  describe(\"someErr()\", () => {\n\t    it(\"should return true if one or more errors is falsy\", () => {\n\t      expect(someErr([err()])).toBeTruthy();\n\t      expect(someErr([err(), err()])).toBeTruthy();\n\t    });\n\t    it(\"should return false if zero input values are Err instances\", () => {\n\t      expect(someErr([ok()])).toBeFalsy();\n\t      expect(someErr([ok(), ok()])).toBeFalsy();\n\t    });\n", "    it(\"should return false when an empty array is passed in\", () => {\n\t      expect(someErr([])).toBeFalsy();\n\t    });\n\t  });\n\t  describe(\"someOk()\", () => {\n\t    it(\"should return true if one or more errors is falsy\", () => {\n\t      expect(someOk([ok()])).toBeTruthy();\n\t      expect(someOk([ok(), ok()])).toBeTruthy();\n\t    });\n\t    it(\"should return false if zero input values are Err instances\", () => {\n", "      expect(someOk([err()])).toBeFalsy();\n\t      expect(someOk([err(), err()])).toBeFalsy();\n\t    });\n\t    it(\"should return false when an empty array is passed in\", () => {\n\t      expect(someOk([])).toBeFalsy();\n\t    });\n\t  });\n\t  describe(\"allErr()\", () => {\n\t    it(\"should return true if all input values are Err instances\", () => {\n\t      expect(allErr([err()])).toBeTruthy();\n", "      expect(allErr([err(), err()])).toBeTruthy();\n\t    });\n\t    it(\"should return false if one or more errors is falsy\", () => {\n\t      expect(allErr([ok()])).toBeFalsy();\n\t      expect(allErr([ok(), err()])).toBeFalsy();\n\t    });\n\t    it(\"should return true when an empty array is passed in\", () => {\n\t      expect(allErr([])).toBeFalsy();\n\t    });\n\t  });\n", "  describe(\"allOk()\", () => {\n\t    it(\"should return true if all input values are Ok instances\", () => {\n\t      expect(allOk([ok()])).toBeTruthy();\n\t      expect(allOk([ok(), ok()])).toBeTruthy();\n\t    });\n\t    it(\"should return false if one or more errors is falsy\", () => {\n\t      expect(allOk([err()])).toBeFalsy();\n\t      expect(allOk([err(), ok()])).toBeFalsy();\n\t    });\n\t    it(\"should return true when an empty array is passed in\", () => {\n", "      expect(allOk([])).toBeFalsy();\n\t    });\n\t  });\n\t  describe(\"assertIsResult()\", () => {\n\t    it(\"should throw an error if the provided value is not a Result instance\", () => {\n\t      expect(() => assertIsResult(undefined)).toThrow();\n\t      expect(() => assertIsResult(null)).toThrow();\n\t      expect(() => assertIsResult({})).toThrow();\n\t      expect(() => assertIsResult(ok())).not.toThrow();\n\t      expect(() => assertIsResult(err())).not.toThrow();\n", "    });\n\t  });\n\t  describe(\"assertIsOk()\", () => {\n\t    it(\"should throw an error if the provided value is not an Ok instance\", () => {\n\t      expect(() => assertIsOk(err())).toThrow();\n\t      expect(() => assertIsOk(undefined)).toThrow();\n\t      expect(() => assertIsOk(null)).toThrow();\n\t      expect(() => assertIsOk({})).toThrow();\n\t      expect(() => assertIsOk(ok())).not.toThrow();\n\t    });\n", "  });\n\t  describe(\"assertIsErr()\", () => {\n\t    it(\"should throw an error if the provided value is not an Err instance\", () => {\n\t      expect(() => assertIsErr(ok())).toThrow();\n\t      expect(() => assertIsErr(undefined)).toThrow();\n\t      expect(() => assertIsErr(null)).toThrow();\n\t      expect(() => assertIsErr({})).toThrow();\n\t      expect(() => assertIsErr(err())).not.toThrow();\n\t    });\n\t  });\n", "});\n\texport function assertResultEquals<R extends Result>(\n\t  result: R,\n\t  data: Partial<R>,\n\t): void {\n\t  expect(result).toEqual(expect.objectContaining(data));\n\t}\n"]}
{"filename": "src/err.spec.ts", "chunked_list": ["import type { Err, Result } from \"./api\";\n\timport { err } from \"./err\";\n\timport { assertResultEquals } from \"./testUtils\";\n\timport { describe, expect, it } from \"vitest\";\n\tdescribe(\"err()\", () => {\n\t  it(\"should return an Err result when called with nothing\", () => {\n\t    assertResultEquals(err(), { ok: false });\n\t    assertResultEquals(err(), { err: true });\n\t    assertResultEquals(err(), { errMessage: \"\" });\n\t    assertResultEquals(err(), { errCode: 0 });\n", "    assertResultEquals(err(), { errContext: null });\n\t    assertResultEquals(err(), { errException: null });\n\t  });\n\t  it(\"should return an Err result when called with null or undefined or boolean value\", () => {\n\t    const target = err();\n\t    errIsErr(err(null), target);\n\t    errIsErr(err(undefined), target);\n\t    errIsErr(err(true), target);\n\t    errIsErr(err(false), target);\n\t  });\n", "  it(\"should return an Err result with a number\", () => {\n\t    expect(err(0).errCode).toEqual(0);\n\t    expect(err(0).errMessage).toEqual(\"\");\n\t    expect(err(1).errCode).toEqual(1);\n\t    expect(err(1).errMessage).toEqual(\"\");\n\t  });\n\t  it(\"should return an Err result with a string\", () => {\n\t    expect(err(\"fail\").errMessage).toEqual(\"fail\");\n\t  });\n\t  it(\"should return an Err result with a string/number\", () => {\n", "    assertResultEquals(err(\"fail\", 123), {\n\t      errCode: 123,\n\t      errMessage: \"fail\",\n\t    });\n\t    assertResultEquals(err(\"fail\", 0), { errCode: 0, errMessage: \"fail\" });\n\t    assertResultEquals(err(\"fail\", -1), { errCode: -1, errMessage: \"fail\" });\n\t  });\n\t  it(\"should return an Err result with a string/string\", () => {\n\t    assertResultEquals(err(\"fail\", \"BAD_ERROR\"), {\n\t      errCode: \"BAD_ERROR\",\n", "      errMessage: \"fail\",\n\t    });\n\t  });\n\t  it(\"should return an Err result with a string/number/context\", () => {\n\t    const ctx = { some: \"data\" };\n\t    assertResultEquals(err(\"fail\", 123, ctx), {\n\t      errCode: 123,\n\t      errMessage: \"fail\",\n\t      errContext: ctx,\n\t    });\n", "  });\n\t  it(\"should return an Err result with the data extracted out of a Err input value\", () => {\n\t    expect(err(err()).errCode).toEqual(0);\n\t    expect(err(err(123)).errCode).toEqual(123);\n\t    expect(err(err(err(456))).errCode).toEqual(456);\n\t  });\n\t  it(\"should return an Err result with an Error value passed in as the input param\", () => {\n\t    const e = new Error(\"fail\");\n\t    expect(err(e).errException).toEqual(e);\n\t    expect(err(e).errCode).toEqual(0);\n", "    expect(err(e).errMessage).toEqual(\"fail\");\n\t  });\n\t  it(\"should override values if more params are passed in after the Error value\", () => {\n\t    const e = new Error(\"fail\");\n\t    assertResultEquals(err(e, \"mega fail\"), {\n\t      errMessage: \"mega fail\",\n\t      errException: e,\n\t    });\n\t    assertResultEquals(err(e, \"mega fail\", 456), {\n\t      errMessage: \"mega fail\",\n", "      errException: e,\n\t      errCode: 456,\n\t    });\n\t    assertResultEquals(err(e, \"mega fail\", 456, { data: \"123\" }), {\n\t      errMessage: \"mega fail\",\n\t      errException: e,\n\t      errCode: 456,\n\t      errContext: { data: \"123\" },\n\t    });\n\t  });\n", "  it(\"should allow the entire object as data to be passed in\", () => {\n\t    const e = new Error(\"fail\");\n\t    assertResultEquals(\n\t      err({\n\t        errCode: 123,\n\t        errMessage: \"not good\",\n\t        errContext: { some: \"data\" },\n\t        errException: e,\n\t      }),\n\t      {\n", "        errCode: 123,\n\t        errMessage: \"not good\",\n\t        errContext: { some: \"data\" },\n\t        errException: e,\n\t      },\n\t    );\n\t  });\n\t  it(\"should allow the entire object as data to be passed in but use the exception's error message if not overridden\", () => {\n\t    const e = new Error(\"error123: fail\");\n\t    assertResultEquals(\n", "      err({\n\t        errCode: 123,\n\t        errContext: { some: \"data\" },\n\t        errException: e,\n\t      }),\n\t      {\n\t        errCode: 123,\n\t        errMessage: \"error123: fail\",\n\t        errContext: { some: \"data\" },\n\t        errException: e,\n", "      },\n\t    );\n\t  });\n\t  it(\"should allow a partial object as data to be passed in\", () => {\n\t    assertResultEquals(\n\t      err({\n\t        errContext: { some: \"data\" },\n\t      }),\n\t      {\n\t        errCode: 0,\n", "        errMessage: \"\",\n\t        errContext: { some: \"data\" },\n\t        errException: null,\n\t      },\n\t    );\n\t  });\n\t  it(\"should not set any data on the Err result\", () => {\n\t    expect(err()).not.toHaveProperty(\"data\");\n\t  });\n\t  it(\"should support enums as error codes\", () => {\n", "    enum StringEnum {\n\t      BAD_ERROR = \"BAD_ERROR\",\n\t      GOOD_ERROR = \"GOOD_ERROR\",\n\t    }\n\t    enum NumEnum {\n\t      BAD_ERROR = 1,\n\t      GOOD_ERROR = 2,\n\t    }\n\t    const strError: Result<unknown, StringEnum> = err(\n\t      \"something broke abc\",\n", "      StringEnum.BAD_ERROR,\n\t    );\n\t    expect(strError.errCode).toEqual(StringEnum.BAD_ERROR);\n\t    const numError: Result<unknown, NumEnum> = err(\n\t      \"something broke 123\",\n\t      NumEnum.BAD_ERROR,\n\t    );\n\t    expect(numError.errCode).toEqual(NumEnum.BAD_ERROR);\n\t  });\n\t  it(\"should allow an Err object to be passed in with overrides\", () => {\n", "    const e = err(\"fail\", 555, { old: \"data\" });\n\t    // no overrides\n\t    assertResultEquals(err(e), {\n\t      errMessage: \"fail\",\n\t      errCode: 555,\n\t      errContext: { old: \"data\" },\n\t    });\n\t    // just the message\n\t    assertResultEquals(err(e, \"super fail\"), {\n\t      errMessage: \"super fail\",\n", "      errCode: 555,\n\t      errContext: { old: \"data\" },\n\t    });\n\t    // message and number\n\t    assertResultEquals(err(e, \"super fail\", 999), {\n\t      errMessage: \"super fail\",\n\t      errCode: 999,\n\t      errContext: { old: \"data\" },\n\t    });\n\t    // message, number and context\n", "    assertResultEquals(err(e, \"super fail\", 999, { some: \"data\" }), {\n\t      errMessage: \"super fail\",\n\t      errCode: 999,\n\t      errContext: { some: \"data\" },\n\t    });\n\t  });\n\t});\n\tfunction errIsErr(a: Err, b: Err): void {\n\t  expect(a.ok).toEqual(a.ok);\n\t  expect(a.err).toEqual(b.err);\n", "  expect(a.errMessage).toEqual(b.errMessage);\n\t  expect(a.errCode).toEqual(b.errCode);\n\t  expect(a.errContext).toEqual(b.errContext);\n\t  expect(a.errException).toEqual(b.errException);\n\t}\n"]}
{"filename": "src/from.ts", "chunked_list": ["import type { Err, Ok, Result } from \"./api\";\n\timport { err } from \"./err\";\n\timport { allOk, isResult } from \"./helpers\";\n\timport { ok } from \"./ok\";\n\texport function from<D extends unknown, R extends Result<D>[]>(\n\t  results: R,\n\t): Ok<D[]> | Err<number, Error, { results: R }> {\n\t  if (allOk(results)) {\n\t    const data = (results as Ok<D>[]).map((r) => {\n\t      let data = r.data;\n", "      while (isResult(data)) {\n\t        if (data.err) {\n\t          data = null as D;\n\t          break;\n\t        }\n\t        data = (data as Ok<D>).data;\n\t      }\n\t      return data;\n\t    });\n\t    return ok(data);\n", "  } else {\n\t    const context = { results };\n\t    return err({ errContext: context });\n\t  }\n\t}\n\texport async function fromPromise<D extends unknown>(\n\t  promise: Promise<D>,\n\t): Promise<Result<D>> {\n\t  try {\n\t    const data = await promise;\n", "    return ok(data);\n\t  } catch (e) {\n\t    return err(e);\n\t  }\n\t}\n"]}
{"filename": "src/err.ts", "chunked_list": ["import type { Err } from \"./api\";\n\timport { isJsError } from \"./shared\";\n\t// this is used to make sure that at least one of the\n\t// properties of an object is defined (becausePartial\n\t// makes all properties optional))\n\ttype AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &\n\t  U[keyof U];\n\t/**\n\t * Creates an Err result.\n\t */\n", "export function err(): Err;\n\texport function err(err: null | undefined | boolean): Err;\n\texport function err<T extends Err>(err: T): T;\n\texport function err<C extends number>(errCode: C): Err<C>;\n\texport function err(errMessage: string): Err;\n\texport function err<C extends unknown = number | string>(\n\t  errMessage: string,\n\t  errCode: C,\n\t): Err<C>;\n\texport function err<\n", "  C extends unknown = string | number,\n\t  X extends { [key: string]: unknown } = { [key: string]: unknown },\n\t>(errMessage: string, errCode: C, errContext: X): Err<number, Error, X>;\n\texport function err<\n\t  E extends Err,\n\t  C extends unknown = string | number,\n\t  X extends { [key: string]: unknown } = { [key: string]: unknown },\n\t>(\n\t  e: AtLeastOne<Partial<E>>,\n\t  errMessage?: string,\n", "  errCode?: C,\n\t  errContext?: X,\n\t): Err<C, NonNullable<E[\"errException\"]>, X>;\n\texport function err<\n\t  E extends Error,\n\t  C extends unknown = string | number,\n\t  X extends { [key: string]: unknown } = { [key: string]: unknown },\n\t>(\n\t  e: E | { stack: string; message: string } | unknown,\n\t  errMessage?: string,\n", "  errCode?: C,\n\t  errContext?: X,\n\t): Err<C, E, X>;\n\texport function err(a?: unknown, b?: unknown, c?: unknown, d?: unknown): Err {\n\t  let code: number | string = 0;\n\t  let message: string = \"\";\n\t  let context: { [key: string]: unknown } | null = null;\n\t  let exception: Error | null = null;\n\t  // err()\n\t  // err(null | undefined)\n", "  // --\n\t  // otherwise...\n\t  if (a !== null && a !== undefined) {\n\t    switch (typeof a) {\n\t      // err(number)\n\t      case \"number\":\n\t        code = a;\n\t        break;\n\t      // err(string, number?, context?)\n\t      case \"string\":\n", "        message = a;\n\t        if (typeof b === \"number\" || typeof b === \"string\") {\n\t          code = b;\n\t        }\n\t        if (c && typeof c === \"object\") {\n\t          context = c as { [key: string]: unknown };\n\t        }\n\t        break;\n\t      case \"object\":\n\t        if (isJsError(a)) {\n", "          // err(Error, message?, code?, context?)\n\t          exception = a;\n\t          message = typeof b === \"string\" ? b : a.message || \"\";\n\t          code = typeof c === \"number\" || typeof c === \"string\" ? c : 0;\n\t          context =\n\t            typeof d === \"object\" ? (d as { [key: string]: unknown }) : null;\n\t        } else {\n\t          // err({ errMessage?, errCode?, errContext?, errException? })\n\t          const { errCode, errMessage, errContext, errException } =\n\t            a as Partial<Err>;\n", "          exception = errException ?? null;\n\t          code =\n\t            typeof c === \"number\"\n\t              ? c\n\t              : typeof errCode === \"number\"\n\t              ? errCode\n\t              : 0;\n\t          message = isValidString(b)\n\t            ? b\n\t            : isValidString(errMessage)\n", "            ? errMessage\n\t            : exception\n\t            ? exception.message\n\t            : \"\";\n\t          context = isErrContext(d) ? d : errContext ?? null;\n\t        }\n\t        break;\n\t    }\n\t  }\n\t  return {\n", "    ok: false,\n\t    err: true,\n\t    errCode: code,\n\t    errContext: context,\n\t    errMessage: message,\n\t    errException: exception,\n\t  };\n\t}\n\tfunction isValidString(value: unknown): value is string {\n\t  return typeof value === \"string\" && value.length !== 0;\n", "}\n\tfunction isErrContext(value: unknown): value is { [key: string]: unknown } {\n\t  return typeof value === \"object\" && value !== null;\n\t}\n"]}
{"filename": "src/shared.ts", "chunked_list": ["export function isJsError(e: unknown): e is Error {\n\t  return (\n\t    e instanceof Error ||\n\t    (typeof e === \"object\" &&\n\t      e !== null &&\n\t      typeof (e as { message?: unknown }).message === \"string\")\n\t  );\n\t}\n"]}
{"filename": "src/from.spec.ts", "chunked_list": ["import { err } from \"./err\";\n\timport { from, fromPromise } from \"./from\";\n\timport { assertIsErr } from \"./helpers\";\n\timport { ok } from \"./ok\";\n\timport { describe, expect, it } from \"vitest\";\n\tdescribe(\"\", () => {\n\t  describe(\"from()\", () => {\n\t    it(\"should return a Ok result if all input values are Ok instances\", () => {\n\t      const a = ok(1);\n\t      const b = ok(2);\n", "      const c = ok({ value: 3 });\n\t      expect(from([a, b, c])).toEqual(ok([1, 2, { value: 3 }]));\n\t    });\n\t    it(\"should extract all inner data if there are any ok(ok()) values\", () => {\n\t      const a = ok(1);\n\t      const b = ok(ok(\"yes\"));\n\t      const c = ok(ok(ok({ value: \"no\" })));\n\t      expect(from([a, b, c])).toEqual(ok([1, \"yes\", { value: \"no\" }]));\n\t    });\n\t    it(\"should return a Err result if one or more input values are Err instances\", () => {\n", "      expect(from([err()]).err).toBeTruthy();\n\t      expect(from([err(), ok()]).err).toBeTruthy();\n\t    });\n\t    it(\"should collect expose all the input values on errContext if any errors are detected\", () => {\n\t      const a = ok(1);\n\t      const b = err(2);\n\t      const c = err(\"fail\");\n\t      const result = from([a, b, c]);\n\t      assertIsErr(result);\n\t      expect(result.err).toBeTruthy();\n", "      expect(result.errContext).toEqual({ results: [a, b, c] });\n\t    });\n\t    it(\"should return an Err result if there are zero values passed in\", () => {\n\t      expect(from([]).err).toBeTruthy();\n\t    });\n\t  });\n\t  describe(\"fromPromise()\", () => {\n\t    it(\"should return an Ok result if the promise resolves\", async () => {\n\t      const promise = Promise.resolve(1);\n\t      const result = await fromPromise(promise);\n", "      expect(result).toEqual(ok(1));\n\t    });\n\t    it(\"should return an Err result if the promise rejects\", async () => {\n\t      // eslint-disable-next-line prefer-promise-reject-errors\n\t      const promise = Promise.reject(1);\n\t      const result = await fromPromise(promise);\n\t      assertIsErr(result);\n\t      expect(result.err).toBeTruthy();\n\t    });\n\t  });\n", "});\n"]}
{"filename": "src/ok.ts", "chunked_list": ["import type { Err, Ok } from \"./api\";\n\timport { isOkResult } from \"./helpers\";\n\t/**\n\t * Creates an Ok result.\n\t */\n\texport function ok(): Ok<null>;\n\texport function ok(value: undefined): Ok<undefined>;\n\texport function ok<T extends Err>(value: T): Ok<null>;\n\texport function ok<T extends { ok: true; err: false }>(value: T): T;\n\texport function ok<T extends unknown>(value: T): Ok<T>;\n", "export function ok(value?: unknown): Ok<unknown> {\n\t  let resultData: any = value;\n\t  if (resultData === undefined) {\n\t    // special case for undefined actually being\n\t    // passed in as undefined\n\t    resultData = arguments.length === 1 ? undefined : null;\n\t  } else if (isOkResult(value)) {\n\t    // no need for a loop since ok(ok()) does this\n\t    // by way of the function call stack\n\t    resultData = value.data;\n", "  }\n\t  return { ok: true, err: false, data: resultData };\n\t}\n"]}
{"filename": "src/helpers.ts", "chunked_list": ["import type { Err, Ok, Result } from \"./api\";\n\texport function isOkResult<D extends unknown = unknown>(\n\t  value: unknown,\n\t): value is Ok<D> {\n\t  return isResult(value) && value.ok;\n\t}\n\texport function isErrResult(value: unknown): value is Err {\n\t  return isResult(value) && value.err;\n\t}\n\texport function isResult(value: unknown): value is Result {\n", "  if (\n\t    typeof value === \"object\" &&\n\t    value !== null &&\n\t    \"ok\" in value &&\n\t    \"err\" in value\n\t  ) {\n\t    const r = value as Result;\n\t    return typeof r.ok === \"boolean\" && typeof r.err === \"boolean\";\n\t  }\n\t  return false;\n", "}\n\texport function someErr(results: Result[]): boolean {\n\t  return results.some((r) => r.err);\n\t}\n\texport function allErr(results: Result[]): boolean {\n\t  return results.length ? results.every((r) => r.err) : false;\n\t}\n\texport function someOk(results: Result[]): boolean {\n\t  return results.some((r) => r.ok);\n\t}\n", "export function allOk(results: Result[]): boolean {\n\t  return results.length ? results.every((r) => r.ok) : false;\n\t}\n\texport function assertIsResult(value: unknown): asserts value is Result {\n\t  if (!isResult(value)) {\n\t    throw new TypeError(\"value is not a Result\");\n\t  }\n\t}\n\texport function assertIsErr(value: unknown): asserts value is Err {\n\t  if (!isErrResult(value)) {\n", "    throw new TypeError(\"value is not an Err result\");\n\t  }\n\t}\n\texport function assertIsOk(value: unknown): asserts value is Ok {\n\t  if (!isOkResult(value)) {\n\t    throw new TypeError(\"value is not an Ok result\");\n\t  }\n\t}\n"]}
{"filename": "src/toResult.ts", "chunked_list": ["import type { Err, Ok, Result } from \"./api\";\n\timport { err } from \"./err\";\n\timport { ok } from \"./ok\";\n\timport { isJsError } from \"./shared\";\n\texport function toResult<\n\t  D extends unknown,\n\t  T extends { ok: true; data?: D } | { err: false; data?: D },\n\t>(value: T): Ok<T>;\n\texport function toResult<\n\t  C extends unknown,\n", "  T extends { ok: false; errCode?: C } | { err: true; errCode?: C },\n\t>(value: T): Err<T[\"errCode\"]>;\n\texport function toResult<D extends false | \"\" | 0 | null | undefined>(\n\t  value: D,\n\t): Err;\n\texport function toResult<\n\t  D extends true | unknown[] | Record<string, unknown> | number | string,\n\t>(value: D): Ok<D>;\n\texport function toResult(value: unknown): Result {\n\t  if (value === undefined || value === null) {\n", "    return err();\n\t  }\n\t  if (typeof value === \"object\") {\n\t    if ((\"ok\" in value && value.ok) || (\"err\" in value && !value.err)) {\n\t      const data = (value as Ok).data ?? null;\n\t      return ok(data);\n\t    } else if ((\"err\" in value && value.err) || (\"ok\" in value && !value.ok)) {\n\t      const e = value as Err;\n\t      const errCode = e.errCode ?? 0;\n\t      const errMessage = e.errMessage || \"\";\n", "      const errContext = e.errContext ?? null;\n\t      const errException = isJsError(e.errException) ? e.errException : null;\n\t      return err({\n\t        errCode,\n\t        errMessage,\n\t        errContext,\n\t        errException,\n\t      });\n\t    }\n\t    // fallback for any {} object\n", "    return value ? ok(value) : err();\n\t  }\n\t  switch (typeof value) {\n\t    case \"boolean\":\n\t      return value ? ok(value) : err();\n\t    case \"number\":\n\t      return value === 0 ? err() : ok(value);\n\t    case \"string\":\n\t      return value === \"\" ? err() : ok(value);\n\t    default:\n", "      return err();\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"./api\";\n\texport * from \"./ok\";\n\texport * from \"./err\";\n\texport * from \"./helpers\";\n\texport * from \"./from\";\n\texport * from \"./toResult\";\n"]}
{"filename": "src/toResult.spec.ts", "chunked_list": ["import { err } from \"./err\";\n\timport { ok } from \"./ok\";\n\timport { toResult } from \"./toResult\";\n\timport { describe, expect, it } from \"vitest\";\n\tdescribe(\"toResult()\", () => {\n\t  it(\"should convert a simple {ok:true} or {err:false} object to an Ok result\", () => {\n\t    expect(toResult({ ok: true })).toEqual(ok());\n\t    expect(toResult({ ok: true, err: false })).toEqual(ok());\n\t    expect(toResult({ err: false })).toEqual(ok());\n\t    expect(toResult({ err: false, ok: false })).toEqual(ok());\n", "  });\n\t  it(\"should retain any data when accepting an ok-like input value\", () => {\n\t    expect(toResult({ ok: true, data: \"123\" })).toEqual(ok(\"123\"));\n\t    expect(toResult({ ok: true, data: { value: \"456\" } })).toEqual(\n\t      ok({ value: \"456\" }),\n\t    );\n\t    expect(toResult({ err: false, data: \"123\" })).toEqual(ok(\"123\"));\n\t    expect(toResult({ err: false, data: { value: \"456\" } })).toEqual(\n\t      ok({ value: \"456\" }),\n\t    );\n", "  });\n\t  it(\"should convert a simple {ok:false} or {err:true} object to an Err result\", () => {\n\t    expect(toResult({ ok: false })).toEqual(err());\n\t    expect(toResult({ err: true })).toEqual(err());\n\t  });\n\t  it(\"should retain the errMessage, errCode, errContext and errException when accepting an err-like input value\", () => {\n\t    expect(toResult({ ok: false, errMessage: \"noo\" })).toEqual(err(\"noo\"));\n\t    expect(toResult({ err: true, errMessage: \"noo!\" })).toEqual(err(\"noo!\"));\n\t    expect(toResult({ err: true, errCode: 999 })).toEqual(err(999));\n\t    expect(toResult({ ok: false, errCode: 999 })).toEqual(err(999));\n", "    expect(toResult({ err: true, errCode: \"FFF\" })).toEqual(\n\t      err({ errCode: \"FFF\" }),\n\t    );\n\t    expect(toResult({ ok: false, errCode: \"FFF\" })).toEqual(\n\t      err({ errCode: \"FFF\" }),\n\t    );\n\t    const ctx = { a: 1 };\n\t    expect(toResult({ err: true, errContext: ctx })).toEqual(\n\t      err({ errContext: ctx }),\n\t    );\n", "    expect(toResult({ ok: false, errContext: ctx })).toEqual(\n\t      err({ errContext: ctx }),\n\t    );\n\t    const e = new Error(\"!!!\");\n\t    expect(toResult({ err: true, errException: e })).toEqual(\n\t      err({ errException: e, errMessage: \"!!!\" }),\n\t    );\n\t    expect(toResult({ ok: false, errException: e })).toEqual(\n\t      err({ errException: e, errMessage: \"!!!\" }),\n\t    );\n", "    expect(\n\t      toResult({\n\t        ok: false,\n\t        errMessage: \"it broke\",\n\t        errCode: 999,\n\t        errContext: ctx,\n\t        errException: e,\n\t      }),\n\t    ).toEqual(\n\t      err({\n", "        errMessage: \"it broke\",\n\t        errCode: 999,\n\t        errContext: ctx,\n\t        errException: e,\n\t      }),\n\t    );\n\t    expect(\n\t      toResult({\n\t        err: true,\n\t        errMessage: \"it broke\",\n", "        errCode: 999,\n\t        errContext: ctx,\n\t        errException: e,\n\t      }),\n\t    ).toEqual(\n\t      err({\n\t        errMessage: \"it broke\",\n\t        errCode: 999,\n\t        errContext: ctx,\n\t        errException: e,\n", "      }),\n\t    );\n\t  });\n\t  it(\"should convert an input-value of false / empty string / zero / null / undefined to an Err result\", () => {\n\t    expect(toResult(false)).toEqual(err());\n\t    expect(toResult(\"\")).toEqual(err());\n\t    expect(toResult(0)).toEqual(err());\n\t    expect(toResult(null)).toEqual(err());\n\t    expect(toResult(undefined)).toEqual(err());\n\t  });\n", "  it(\"should convert an input-value of true / string / number / object / array to an Ok result\", () => {\n\t    expect(toResult(true)).toEqual(ok(true));\n\t    expect(toResult(\"abc\")).toEqual(ok(\"abc\"));\n\t    expect(toResult(123)).toEqual(ok(123));\n\t    expect(toResult({})).toEqual(ok({}));\n\t    expect(toResult({ a: 1 })).toEqual(ok({ a: 1 }));\n\t    expect(toResult([])).toEqual(ok([]));\n\t    expect(toResult([1, 2, 3])).toEqual(ok([1, 2, 3]));\n\t  });\n\t});\n"]}
{"filename": "src/ok.spec.ts", "chunked_list": ["import { ok } from \"./ok\";\n\timport { assertResultEquals } from \"./testUtils\";\n\timport { describe, expect, it } from \"vitest\";\n\tdescribe(\"ok()\", () => {\n\t  it(\"should return an Ok reuslt when called with nothing\", () => {\n\t    assertResultEquals(ok(), { ok: true });\n\t    assertResultEquals(ok(), { err: false });\n\t    assertResultEquals(ok(), { data: null });\n\t  });\n\t  it(\"should return an Ok result with the provided data\", () => {\n", "    assertResultEquals(ok(null), { ok: true, data: null });\n\t    assertResultEquals(ok(undefined), { ok: true, data: undefined });\n\t    assertResultEquals(ok(0), { ok: true, data: 0 });\n\t    assertResultEquals(ok(123), { ok: true, data: 123 });\n\t    assertResultEquals(ok(true), { ok: true, data: true });\n\t    assertResultEquals(ok(false), { ok: true, data: false });\n\t    assertResultEquals(ok(\"\"), { ok: true, data: \"\" });\n\t    assertResultEquals(ok([]), { ok: true, data: [] });\n\t    assertResultEquals(ok({}), { ok: true, data: {} });\n\t    assertResultEquals(ok({ key: \"value\" }), {\n", "      ok: true,\n\t      data: { key: \"value\" },\n\t    });\n\t  });\n\t  it(\"should return an Ok result with the data of an Ok\", () => {\n\t    assertResultEquals(ok(ok()), { ok: true, data: null });\n\t    assertResultEquals(ok(ok(1)), { ok: true, data: 1 });\n\t    assertResultEquals(ok(ok(\"abc\")), { ok: true, data: \"abc\" });\n\t    assertResultEquals(ok(ok(ok(true))), { ok: true, data: true });\n\t  });\n", "  it(\"should not set any error details on the Ok result\", () => {\n\t    expect(ok()).not.toHaveProperty(\"errCode\");\n\t    expect(ok()).not.toHaveProperty(\"errMessage\");\n\t    expect(ok()).not.toHaveProperty(\"errContext\");\n\t    expect(ok()).not.toHaveProperty(\"errException\");\n\t  });\n\t  it(\"should allow `any` data to be passed in\", () => {\n\t    const data: any = { key: \"value\" };\n\t    expect(ok(data).data).toBe(data);\n\t  });\n", "});\n"]}
