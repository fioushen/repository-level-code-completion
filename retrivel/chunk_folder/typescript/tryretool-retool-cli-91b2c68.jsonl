{"filename": "src/index.ts", "chunked_list": ["#!/usr/bin/env node\n\tconst axios = require(\"axios\");\n\trequire(\"yargs/yargs\")(process.argv.slice(2))\n\t  .commandDir(\"commands\", {\n\t    visit(commandModule: any) {\n\t      return commandModule.default;\n\t    },\n\t  })\n\t  .parserConfiguration({ \"boolean-negation\": false })\n\t  .demandCommand()\n", "  .strict()\n\t  .usage(\n\t    \"Work seamlessly with Retool from the command line. For feedback and issues visit https://github.com/tryretool/retool-cli.\\n\\nUsage: retool <command> [flags]\"\n\t  ).argv;\n\t// Setup axios defaults.\n\taxios.defaults.headers.accept = \"application/json\";\n\taxios.defaults.headers[\"content-type\"] = \"application/json\";\n"]}
{"filename": "src/commands/login.ts", "chunked_list": ["import express from \"express\";\n\timport { CommandModule } from \"yargs\";\n\timport { accessTokenFromCookies, xsrfTokenFromCookies } from \"../utils/cookies\";\n\timport {\n\t  askForCookies,\n\t  doCredentialsExist,\n\t  getCredentials,\n\t  persistCredentials,\n\t} from \"../utils/credentials\";\n\timport { getRequest, postRequest } from \"../utils/networking\";\n", "import { logDAU } from \"../utils/telemetry\";\n\tconst path = require(\"path\");\n\tconst axios = require(\"axios\");\n\tconst chalk = require(\"chalk\");\n\tconst inquirer = require(\"inquirer\");\n\tconst open = require(\"open\");\n\tconst command = \"login\";\n\tconst describe = \"Log in to Retool.\";\n\tconst builder = {};\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n", "const handler = async function (argv: any) {\n\t  // Ask user if they want to overwrite existing credentials.\n\t  if (doCredentialsExist()) {\n\t    const { overwrite } = await inquirer.prompt([\n\t      {\n\t        name: \"overwrite\",\n\t        message: \"You're already logged in. Do you want to re-authenticate?\",\n\t        type: \"confirm\",\n\t      },\n\t    ]);\n", "    if (!overwrite) {\n\t      return;\n\t    }\n\t  }\n\t  // Ask user how they want to login.\n\t  const { loginMethod } = await inquirer.prompt([\n\t    {\n\t      name: \"loginMethod\",\n\t      message: \"How would you like to login?\",\n\t      type: \"list\",\n", "      choices: [\n\t        {\n\t          name: \"Log in using Google SSO in a web browser\",\n\t          value: \"browser\",\n\t        },\n\t        {\n\t          name: \"Log in with email and password\",\n\t          value: \"email\",\n\t        },\n\t        {\n", "          name: \"Log in by pasting in cookies\",\n\t          value: \"cookies\",\n\t        },\n\t        {\n\t          name: \"Log in to localhost:3000\",\n\t          value: \"localhost\",\n\t        },\n\t      ],\n\t    },\n\t  ]);\n", "  if (loginMethod === \"browser\") {\n\t    await loginViaBrowser();\n\t  } else if (loginMethod === \"email\") {\n\t    await loginViaEmail(false);\n\t  } else if (loginMethod === \"cookies\") {\n\t    await askForCookies();\n\t  } else if (loginMethod === \"localhost\") {\n\t    await loginViaEmail(true);\n\t  }\n\t  await logDAU();\n", "};\n\t// Ask the user to input their email and password.\n\t// Fire off a request to Retool's login & auth endpoints.\n\t// Persist the credentials.\n\tasync function loginViaEmail(localhost = false) {\n\t  const { email, password } = await inquirer.prompt([\n\t    {\n\t      name: \"email\",\n\t      message: \"What is your email?\",\n\t      type: \"input\",\n", "    },\n\t    {\n\t      name: \"password\",\n\t      message: \"What is your password?\",\n\t      type: \"password\",\n\t    },\n\t  ]);\n\t  const loginOrigin = localhost\n\t    ? \"http://localhost:3000\"\n\t    : \"https://login.retool.com\";\n", "  // Step 1: Hit /api/login with email and password.\n\t  const login = await postRequest(`${loginOrigin}/api/login`, {\n\t    email,\n\t    password,\n\t  });\n\t  const { authUrl, authorizationToken } = login.data;\n\t  if (!authUrl || !authorizationToken) {\n\t    console.log(\"Error logging in, please try again\");\n\t    return;\n\t  }\n", "  // Step 2: Hit /auth/saveAuth with authorizationToken.\n\t  const authResponse = await postRequest(\n\t    localhost ? `${loginOrigin}${authUrl}` : authUrl,\n\t    {\n\t      authorizationToken,\n\t    },\n\t    true,\n\t    {\n\t      origin: loginOrigin,\n\t    }\n", "  );\n\t  const { redirectUri } = authResponse.data;\n\t  const redirectUrl = localhost\n\t    ? new URL(loginOrigin)\n\t    : redirectUri\n\t    ? new URL(redirectUri)\n\t    : undefined;\n\t  const accessToken = accessTokenFromCookies(\n\t    authResponse.headers[\"set-cookie\"]\n\t  );\n", "  const xsrfToken = xsrfTokenFromCookies(authResponse.headers[\"set-cookie\"]);\n\t  // Step 3: Persist the credentials.\n\t  if (redirectUrl?.origin && accessToken && xsrfToken) {\n\t    persistCredentials({\n\t      origin: redirectUrl.origin,\n\t      accessToken,\n\t      xsrf: xsrfToken,\n\t      firstName: authResponse.data.user?.firstName,\n\t      lastName: authResponse.data.user?.lastName,\n\t      email: authResponse.data.user?.email,\n", "      telemetryEnabled: true,\n\t    });\n\t    logSuccess();\n\t  } else {\n\t    console.log(\n\t      \"Error parsing credentials from HTTP Response. Please try again.\"\n\t    );\n\t  }\n\t}\n\tasync function loginViaBrowser() {\n", "  // Start a short lived local server to listen for the SSO response.\n\t  const app = express();\n\t  // Step 4: Handle the SSO response.\n\t  // Success scenario format: http://localhost:3020/auth?redirect=https://mycompany.retool.com\n\t  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\t  app.get(\"/auth\", async function (req, res) {\n\t    let url, accessToken, xsrfToken;\n\t    try {\n\t      accessToken = decodeURIComponent(req.query.accessToken as string);\n\t      xsrfToken = decodeURIComponent(req.query.xsrfToken as string);\n", "      url = new URL(decodeURIComponent(req.query.redirect as string));\n\t    } catch (e) {\n\t      console.log(e);\n\t    }\n\t    if (!accessToken || !xsrfToken || !url) {\n\t      console.log(\"Error: SSO response missing information. Try again.\");\n\t      res.sendFile(path.join(__dirname, \"../loginPages/loginFail.html\"));\n\t      server_online = false;\n\t      return;\n\t    }\n", "    axios.defaults.headers[\"x-xsrf-token\"] = xsrfToken;\n\t    axios.defaults.headers.cookie = `accessToken=${accessToken};`;\n\t    const userRes = await getRequest(`https://${url.hostname}/api/user`);\n\t    persistCredentials({\n\t      origin: url.origin,\n\t      accessToken,\n\t      xsrf: xsrfToken,\n\t      firstName: userRes.data.user?.firstName,\n\t      lastName: userRes.data.user?.lastName,\n\t      email: userRes.data.user?.email,\n", "      telemetryEnabled: true,\n\t    });\n\t    logSuccess();\n\t    res.sendFile(path.join(__dirname, \"../loginPages/loginSuccess.html\"));\n\t    server_online = false;\n\t  });\n\t  const server = app.listen(3020);\n\t  // Step 1: Open up the google SSO page in the browser.\n\t  // Step 2: User accepts the SSO request.\n\t  open(`https://login.retool.com/googlelogin?retoolCliRedirect=true`);\n", "  // For local testing:\n\t  // open(\"http://localhost:3000/googlelogin?retoolCliRedirect=true\");\n\t  // open(\"https://login.retool-qa.com/googlelogin?retoolCliRedirect=true\");\n\t  // open(\"https://admin.retool.dev/googlelogin?retoolCliRedirect=true\");\n\t  // Step 3: Keep the server online until localhost:3020/auth is hit.\n\t  let server_online = true;\n\t  while (server_online) {\n\t    await new Promise((resolve) => setTimeout(resolve, 100));\n\t  }\n\t  server.close();\n", "}\n\texport function logSuccess() {\n\t  const credentials = getCredentials();\n\t  if (credentials?.firstName && credentials.lastName && credentials.email) {\n\t    console.log(\n\t      `Logged in as ${chalk.bold(credentials.firstName)} ${chalk.bold(\n\t        credentials.lastName\n\t      )} (${credentials.email}) ✅`\n\t    );\n\t  } else {\n", "    console.log(\"Successfully saved credentials.\");\n\t  }\n\t}\n\tconst commandModule: CommandModule = {\n\t  command,\n\t  describe,\n\t  builder,\n\t  handler,\n\t};\n\texport default commandModule;\n"]}
{"filename": "src/commands/rpc.ts", "chunked_list": ["import { exec } from \"child_process\";\n\timport { promisify } from \"util\";\n\timport chalk from \"chalk\";\n\timport ora from \"ora\";\n\timport { CommandModule } from \"yargs\";\n\timport { getAndVerifyCredentials } from \"../utils/credentials\";\n\timport {\n\t  downloadGithubSubfolder,\n\t  saveEnvVariablesToFile,\n\t} from \"../utils/fileSave\";\n", "import { createPlaygroundQuery } from \"../utils/playgroundQuery\";\n\timport { createResource } from \"../utils/resources\";\n\timport { logDAU } from \"../utils/telemetry\";\n\tconst inquirer = require(\"inquirer\");\n\tconst command = \"rpc\";\n\tconst describe = \"Interface with Retool RPC.\";\n\tconst builder = {};\n\tconst handler = async function () {\n\t  const credentials = getAndVerifyCredentials();\n\t  const origin = credentials.origin;\n", "  // fire and forget\n\t  void logDAU(credentials);\n\t  console.log(\n\t    `We'll be showcasing RetoolRPC -- a simple way to connect to Retool from your local codebase. The three things you'll need are: `\n\t  );\n\t  console.log(\n\t    `1. An RPC resource on Retool (we'll create one for you automatically)`\n\t  );\n\t  console.log(`2. An access token to connect to Retool`);\n\t  console.log(\n", "    `3. A running local server that runs the code you want to execute on Retool\\n`\n\t  );\n\t  console.log(\"To learn more about RetoolRPC, check out our docs: <DOCS LINK>\");\n\t  console.log(\"\\nLet's get started! 🚀\\n\");\n\t  let resourceName = \"\";\n\t  let resourceId = 0;\n\t  await inquirer.prompt([\n\t    {\n\t      name: \"resourceDisplayName\",\n\t      message: \"What would you like the name of your RetoolRPC resource to be?\",\n", "      type: \"input\",\n\t      validate: async (displayName: string) => {\n\t        try {\n\t          const resource = await createResource({\n\t            resourceType: \"retoolSdk\",\n\t            credentials,\n\t            resourceOptions: {\n\t              requireExplicitVersion: false,\n\t            },\n\t            displayName,\n", "          });\n\t          resourceName = resource.name;\n\t          resourceId = resource.id;\n\t          return true;\n\t        } catch (error: any) {\n\t          return (\n\t            error.response?.data?.message || \"API call failed creating resource\"\n\t          );\n\t        }\n\t      },\n", "    },\n\t  ]);\n\t  console.log(\n\t    `Excellent choice! We've created resource ${resourceName} with that name. Now we'll need an access token.\\n`\n\t  );\n\t  const { rpcAccessToken } = (await inquirer.prompt([\n\t    {\n\t      name: \"rpcAccessToken\",\n\t      message: `Please enter an RPC access token. You can add a new one here: ${origin}/settings/api`,\n\t      type: \"password\",\n", "      validate: (rpcAccessToken: string) => {\n\t        // TODO: validate with an api call\n\t        if (rpcAccessToken === \"\") {\n\t          return \"Please enter a valid RPC access token\";\n\t        }\n\t        return true;\n\t      },\n\t    },\n\t  ])) as { rpcAccessToken: string };\n\t  const { languageType } = (await inquirer.prompt([\n", "    {\n\t      name: \"languageType\",\n\t      message:\n\t        \"Which of the following languages would you like to use for your local codebase?\",\n\t      type: \"list\",\n\t      choices: [\n\t        {\n\t          name: \"Typescript!\",\n\t          value: \"typescript\",\n\t        },\n", "      ],\n\t    },\n\t  ])) as { languageType: string };\n\t  const { destinationPath } = (await inquirer.prompt([\n\t    {\n\t      name: \"destinationPath\",\n\t      message: \"Where would you like to create your local server?\",\n\t      type: \"input\",\n\t      default: \"./retool_rpc\",\n\t    },\n", "  ])) as { destinationPath: string };\n\t  const githubUrl =\n\t    \"https://api.github.com/repos/tryretool/retool-examples/tarball/main\";\n\t  const subfolderPath = \"hello_world/\" + languageType;\n\t  await downloadGithubSubfolder(githubUrl, subfolderPath, destinationPath);\n\t  const spinner = ora(\n\t    \"Installing dependencies and creating starter code to connect to Retool...\"\n\t  ).start();\n\t  const queryResult = await createPlaygroundQuery(resourceId, credentials);\n\t  const envVariables = {\n", "    RETOOL_SDK_ID: resourceName,\n\t    RETOOL_SDK_HOST: origin,\n\t    RETOOL_SDK_API_TOKEN: rpcAccessToken,\n\t  };\n\t  saveEnvVariablesToFile(envVariables, destinationPath + \"/.env\");\n\t  await installYarnDependencies(destinationPath);\n\t  spinner.stop();\n\t  console.log(\"We've created your starter code to connect to Retool! 🎉\\n\");\n\t  console.log(\n\t    `Your local code is located at ${destinationPath}/src/index.ts. For Retool to interact with your code, start the server by completing the following steps:`\n", "  );\n\t  console.log(`1. cd ${destinationPath}`);\n\t  console.log(\"2. yarn example\\n\");\n\t  console.log(\n\t    `${chalk.bold(\n\t      \"Once your server is running, run the following query in Retool to see how it interacts with your local codebase:\"\n\t    )} ${credentials.origin}/queryLibrary/${queryResult.id}`\n\t  );\n\t};\n\tasync function installYarnDependencies(destinationPath: string) {\n", "  const executeCommand = promisify(exec);\n\t  try {\n\t    await executeCommand(\"yarn install\", { cwd: destinationPath });\n\t  } catch (error: any) {\n\t    console.error(`Error installing Yarn dependencies: ${error.message}`);\n\t  }\n\t}\n\tconst commandModule: CommandModule = {\n\t  command,\n\t  describe,\n", "  builder,\n\t  handler,\n\t};\n\texport default commandModule;\n"]}
{"filename": "src/commands/logout.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\timport { deleteCredentials } from \"../utils/credentials\";\n\tconst command = \"logout\";\n\tconst describe = \"Log out of Retool.\";\n\tconst builder = {};\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst handler = function (argv: any) {\n\t  deleteCredentials();\n\t  console.log(\"Successfully logged out. 👋🏻\");\n\t};\n", "const commandModule: CommandModule = {\n\t  command,\n\t  describe,\n\t  builder,\n\t  handler,\n\t};\n\texport default commandModule;\n"]}
{"filename": "src/commands/apps.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\timport {\n\t  collectAppName,\n\t  createApp,\n\t  createAppForTable,\n\t  deleteApp,\n\t  getAppsAndFolders,\n\t} from \"../utils/apps\";\n\timport type { App } from \"../utils/apps\";\n\timport { getAndVerifyCredentialsWithRetoolDB } from \"../utils/credentials\";\n", "import { dateOptions } from \"../utils/date\";\n\timport {\n\t  collectTableName,\n\t  fetchTableInfo,\n\t  verifyTableExists,\n\t} from \"../utils/table\";\n\timport { logDAU } from \"../utils/telemetry\";\n\tconst command = \"apps\";\n\tconst describe = \"Interface with Retool Apps.\";\n\tconst builder: CommandModule[\"builder\"] = {\n", "  create: {\n\t    alias: \"c\",\n\t    describe: `Create a new app.`,\n\t  },\n\t  \"create-from-table\": {\n\t    alias: \"t\",\n\t    describe: `Create a new app to visualize a Retool DB table.`,\n\t  },\n\t  list: {\n\t    alias: \"l\",\n", "    describe: `List folders and apps at root level. Optionally provide a folder name to list all apps in that folder. Usage:\n\t      retool apps -l [folder-name]`,\n\t  },\n\t  \"list-recursive\": {\n\t    alias: \"r\",\n\t    describe: `List all apps and folders.`,\n\t  },\n\t  delete: {\n\t    alias: \"d\",\n\t    describe: `Delete an app. Usage:\n", "      retool db -d <app-name>`,\n\t    type: \"array\",\n\t  },\n\t};\n\tconst handler = async function (argv: any) {\n\t  const credentials = await getAndVerifyCredentialsWithRetoolDB();\n\t  // fire and forget\n\t  void logDAU(credentials);\n\t  // Handle `retool apps --list [folder-name]`\n\t  if (argv.list || argv.r) {\n", "    let { apps, folders } = await getAppsAndFolders(credentials);\n\t    const rootFolderId = folders?.find(\n\t      (folder) => folder.name === \"root\" && folder.systemFolder === true\n\t    )?.id;\n\t    const trashFolderId = folders?.find(\n\t      (folder) => folder.name === \"archive\" && folder.systemFolder === true\n\t    )?.id;\n\t    // Only list apps in the specified folder.\n\t    if (typeof argv.list === \"string\") {\n\t      const folderId = folders?.find((folder) => folder.name === argv.list)?.id;\n", "      if (folderId) {\n\t        const appsInFolder = apps?.filter((app) => app.folderId === folderId);\n\t        if (appsInFolder && appsInFolder.length > 0) {\n\t          printApps(appsInFolder);\n\t        } else {\n\t          console.log(`No apps found in ${argv.list}.`);\n\t        }\n\t      } else {\n\t        console.log(`No folder named ${argv.list} found.`);\n\t      }\n", "    }\n\t    // List all folders, then all apps in root folder.\n\t    else {\n\t      // Filter out undesired folders/apps.\n\t      folders = folders?.filter((folder) => folder.systemFolder === false);\n\t      apps = apps?.filter((app) => app.folderId !== trashFolderId);\n\t      if (!argv.r) {\n\t        apps = apps?.filter((app) => app.folderId === rootFolderId);\n\t      }\n\t      // Sort from oldest to newest.\n", "      folders?.sort((a, b) => {\n\t        return Date.parse(a.updatedAt) - Date.parse(b.updatedAt);\n\t      });\n\t      apps?.sort((a, b) => {\n\t        return Date.parse(a.updatedAt) - Date.parse(b.updatedAt);\n\t      });\n\t      if ((!folders || folders.length === 0) && (!apps || apps.length === 0)) {\n\t        console.log(\"No folders or apps found.\");\n\t      } else {\n\t        // List all folders\n", "        if (folders && folders?.length > 0) {\n\t          folders.forEach((folder) => {\n\t            const date = new Date(Date.parse(folder.updatedAt));\n\t            console.log(\n\t              `${date.toLocaleString(undefined, dateOptions)}     📂     ${\n\t                folder.name\n\t              }/`\n\t            );\n\t          });\n\t        }\n", "        // List all apps in root folder.\n\t        printApps(apps);\n\t      }\n\t    }\n\t  }\n\t  // Handle `retool apps --create-from-table`\n\t  else if (argv.t) {\n\t    const tableName = await collectTableName();\n\t    await verifyTableExists(tableName, credentials);\n\t    const tableInfo = await fetchTableInfo(tableName, credentials);\n", "    if (!tableInfo) {\n\t      console.error(`Table ${tableName} info not found.`);\n\t      process.exit(1);\n\t    }\n\t    const appName = await collectAppName();\n\t    // Use the first non-pkey column as the search column.\n\t    const searchColumnName = tableInfo.fields.find(\n\t      (field) => field.name !== tableInfo.primaryKeyColumn\n\t    )?.name;\n\t    await createAppForTable(\n", "      appName,\n\t      tableName,\n\t      searchColumnName || tableInfo.primaryKeyColumn,\n\t      credentials\n\t    );\n\t  }\n\t  // Handle `retool apps --create`\n\t  else if (argv.create) {\n\t    const appName = await collectAppName();\n\t    await createApp(appName, credentials);\n", "  }\n\t  // Handle `retool apps -d <app-name>`\n\t  else if (argv.delete) {\n\t    const appNames = argv.delete;\n\t    for (const appName of appNames) {\n\t      await deleteApp(appName, credentials, true);\n\t    }\n\t  }\n\t  // No flag specified.\n\t  else {\n", "    console.log(\n\t      \"No flag specified. See `retool apps --help` for available flags.\"\n\t    );\n\t  }\n\t};\n\tfunction printApps(apps: Array<App> | undefined): void {\n\t  if (apps && apps?.length > 0) {\n\t    apps.forEach((app) => {\n\t      const date = new Date(Date.parse(app.updatedAt));\n\t      console.log(\n", "        `${date.toLocaleString(undefined, dateOptions)}     ${\n\t          app.isGlobalWidget ? \"🔧\" : \"💻\"\n\t        }     ${app.name}`\n\t      );\n\t    });\n\t  }\n\t}\n\tconst commandModule: CommandModule = {\n\t  command,\n\t  describe,\n", "  builder,\n\t  handler,\n\t};\n\texport default commandModule;\n"]}
{"filename": "src/commands/workflows.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\timport { getAndVerifyCredentialsWithRetoolDB } from \"../utils/credentials\";\n\timport { dateOptions } from \"../utils/date\";\n\timport { logDAU } from \"../utils/telemetry\";\n\timport {\n\t  Workflow,\n\t  deleteWorkflow,\n\t  getWorkflowsAndFolders,\n\t} from \"../utils/workflows\";\n\tconst command = \"workflows\";\n", "const describe = \"Interface with Retool Workflows.\";\n\tconst builder: CommandModule[\"builder\"] = {\n\t  list: {\n\t    alias: \"l\",\n\t    describe: `List folders and workflows at root level. Optionally provide a folder name to list all workflows in that folder. Usage:\n\t    retool workflows -l [folder-name]`,\n\t  },\n\t  \"list-recursive\": {\n\t    alias: \"r\",\n\t    describe: `List all apps and workflows.`,\n", "  },\n\t  delete: {\n\t    alias: \"d\",\n\t    describe: `Delete a workflow. Usage:\n\t      retool workflows -d <workflow-name>`,\n\t    type: \"array\",\n\t  },\n\t};\n\tconst handler = async function (argv: any) {\n\t  const credentials = await getAndVerifyCredentialsWithRetoolDB();\n", "  // fire and forget\n\t  void logDAU(credentials);\n\t  // Handle `retool workflows -l`\n\t  if (argv.list || argv.r) {\n\t    let { workflows, folders } = await getWorkflowsAndFolders(credentials);\n\t    const rootFolderId = folders?.find(\n\t      (folder) => folder.name === \"root\" && folder.systemFolder === true\n\t    )?.id;\n\t    const trashFolderId = folders?.find(\n\t      (folder) => folder.name === \"archive\" && folder.systemFolder === true\n", "    )?.id;\n\t    // Only list workflows in the specified folder.\n\t    if (typeof argv.list === \"string\") {\n\t      const folderId = folders?.find((folder) => folder.name === argv.list)?.id;\n\t      if (folderId) {\n\t        const workflowsInFolder = workflows?.filter(\n\t          (w) => w.folderId === folderId\n\t        );\n\t        if (workflowsInFolder && workflowsInFolder.length > 0) {\n\t          printWorkflows(workflowsInFolder);\n", "        } else {\n\t          console.log(`No workflows found in ${argv.list}.`);\n\t        }\n\t      } else {\n\t        console.log(`No folder named ${argv.list} found.`);\n\t      }\n\t    }\n\t    // List all folders, then all workflows in root folder.\n\t    else {\n\t      // Filter out undesired folders/workflows.\n", "      folders = folders?.filter((f) => f.systemFolder === false);\n\t      workflows = workflows?.filter((w) => w.folderId !== trashFolderId);\n\t      if (!argv.r) {\n\t        workflows = workflows?.filter((w) => w.folderId === rootFolderId);\n\t      }\n\t      // Sort from oldest to newest.\n\t      folders?.sort((a, b) => {\n\t        return Date.parse(a.updatedAt) - Date.parse(b.updatedAt);\n\t      });\n\t      workflows?.sort((a, b) => {\n", "        return Date.parse(a.lastDeployedAt) - Date.parse(b.lastDeployedAt);\n\t      });\n\t      if (\n\t        (!folders || folders.length === 0) &&\n\t        (!workflows || workflows.length === 0)\n\t      ) {\n\t        console.log(\"No folders or workflows found.\");\n\t      } else {\n\t        // List all folders\n\t        if (folders && folders?.length > 0) {\n", "          folders.forEach((folder) => {\n\t            const date = new Date(Date.parse(folder.updatedAt));\n\t            console.log(\n\t              `${date.toLocaleString(undefined, dateOptions)}     📂     ${\n\t                folder.name\n\t              }/`\n\t            );\n\t          });\n\t        }\n\t        // List all workflows in root folder.\n", "        printWorkflows(workflows);\n\t      }\n\t    }\n\t  }\n\t  // Handle `retool workflows -d <workflow-name>`\n\t  else if (argv.delete) {\n\t    const workflowNames = argv.delete;\n\t    for (const workflowName of workflowNames) {\n\t      await deleteWorkflow(workflowName, credentials, true);\n\t    }\n", "  }\n\t  // No flag specified.\n\t  else {\n\t    console.log(\n\t      \"No flag specified. See `retool workflows --help` for available flags.\"\n\t    );\n\t  }\n\t};\n\tfunction printWorkflows(workflows: Array<Workflow> | undefined): void {\n\t  if (workflows && workflows.length > 0) {\n", "    workflows.forEach((wf) => {\n\t      const date = new Date(Date.parse(wf.lastDeployedAt));\n\t      console.log(\n\t        `${date.toLocaleString(undefined, dateOptions)}     ${\n\t          wf.isEnabled ? \"🟢\" : \"🔴\"\n\t        }     ${wf.name}`\n\t      );\n\t    });\n\t  }\n\t}\n", "const commandModule: CommandModule = {\n\t  command,\n\t  describe,\n\t  builder,\n\t  handler,\n\t};\n\texport default commandModule;\n"]}
{"filename": "src/commands/custom_component.ts", "chunked_list": ["import { exec as _exec } from \"child_process\";\n\timport util from \"util\";\n\timport ora from \"ora\";\n\timport { CommandModule } from \"yargs\";\n\timport { logDAU } from \"../utils/telemetry\";\n\tconst exec = util.promisify(_exec);\n\tconst command: CommandModule[\"command\"] = \"custom-component\";\n\tconst describe: CommandModule[\"describe\"] = \"Interface with custom components.\";\n\tconst builder: CommandModule[\"builder\"] = {\n\t  clone: {\n", "    alias: \"c\",\n\t    describe: `Clones https://github.com/tryretool/custom-component-guide to the current directory.`,\n\t    demandOption: true,\n\t  },\n\t};\n\tconst handler = async function (argv: any) {\n\t  // fire and forget\n\t  void logDAU();\n\t  if (argv.clone) {\n\t    const spinner = ora(\"Scaffolding a new custom component\").start();\n", "    await exec(\n\t      \"git clone https://github.com/tryretool/custom-component-guide.git\"\n\t    );\n\t    spinner.stop();\n\t    console.log(\n\t      \"Scaffolded a new custom component in the custom-component-guide directory.\"\n\t    );\n\t  }\n\t};\n\tconst commandModule: CommandModule = {\n", "  command,\n\t  describe,\n\t  builder,\n\t  handler,\n\t};\n\texport default commandModule;\n"]}
{"filename": "src/commands/scaffold.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\timport { createAppForTable, deleteApp } from \"../utils/apps\";\n\timport {\n\t  Credentials,\n\t  getAndVerifyCredentialsWithRetoolDB,\n\t} from \"../utils/credentials\";\n\timport { getRequest, postRequest } from \"../utils/networking\";\n\timport {\n\t  collectColumnNames,\n\t  collectTableName,\n", "  createTable,\n\t  createTableFromCSV,\n\t  deleteTable,\n\t  generateDataWithGPT,\n\t} from \"../utils/table\";\n\timport type { DBInfoPayload } from \"../utils/table\";\n\timport { logDAU } from \"../utils/telemetry\";\n\timport { deleteWorkflow, generateCRUDWorkflow } from \"../utils/workflows\";\n\tconst inquirer = require(\"inquirer\");\n\tconst command = \"scaffold\";\n", "const describe = \"Scaffold a Retool DB table, CRUD Workflow, and App.\";\n\tconst builder: CommandModule[\"builder\"] = {\n\t  name: {\n\t    alias: \"n\",\n\t    describe: `Name of table to scaffold. Usage:\n\t    retool scaffold -n <table_name>`,\n\t    type: \"string\",\n\t    nargs: 1,\n\t  },\n\t  columns: {\n", "    alias: \"c\",\n\t    describe: `Column names in DB to scaffold. Usage:\n\t    retool scaffold -c <col1> <col2>`,\n\t    type: \"array\",\n\t  },\n\t  delete: {\n\t    alias: \"d\",\n\t    describe: `Delete a table, Workflow and App created via scaffold. Usage:\n\t    retool scaffold -d <db_name>`,\n\t    type: \"string\",\n", "    nargs: 1,\n\t  },\n\t  \"from-csv\": {\n\t    alias: \"f\",\n\t    describe: `Create a table, Workflow and App from a CSV file. Usage:\n\t    retool scaffold -f <path-to-csv>`,\n\t    type: \"array\",\n\t  },\n\t  \"no-workflow\": {\n\t    describe: `Modifier to avoid generating Workflow. Usage:\n", "    retool scaffold --no-workflow`,\n\t    type: \"boolean\",\n\t  },\n\t};\n\tconst handler = async function (argv: any) {\n\t  const credentials = await getAndVerifyCredentialsWithRetoolDB();\n\t  // fire and forget\n\t  void logDAU(credentials);\n\t  // Handle `retool scaffold -d <db_name>`\n\t  if (argv.delete) {\n", "    const tableName = argv.delete;\n\t    const workflowName = `${tableName} CRUD Workflow`;\n\t    // Confirm deletion.\n\t    const { confirm } = await inquirer.prompt([\n\t      {\n\t        name: \"confirm\",\n\t        message: `Are you sure you want to delete ${tableName} table, CRUD workflow and app?`,\n\t        type: \"confirm\",\n\t      },\n\t    ]);\n", "    if (!confirm) {\n\t      process.exit(0);\n\t    }\n\t    //TODO: Could be parallelized.\n\t    //TODO: Verify existence before trying to delete.\n\t    await deleteTable(tableName, credentials, false);\n\t    await deleteWorkflow(workflowName, credentials, false);\n\t    await deleteApp(`${tableName} App`, credentials, false);\n\t  }\n\t  // Handle `retool scaffold -f <path-to-csv>`\n", "  else if (argv.f) {\n\t    const csvFileNames = argv.f;\n\t    for (const csvFileName of csvFileNames) {\n\t      const { tableName, colNames } = await createTableFromCSV(\n\t        csvFileName,\n\t        credentials,\n\t        false,\n\t        false\n\t      );\n\t      if (!argv[\"no-workflow\"]) {\n", "        console.log(\"\\n\");\n\t        await generateCRUDWorkflow(tableName, credentials);\n\t      }\n\t      console.log(\"\\n\");\n\t      const searchColumnName = colNames.length > 0 ? colNames[0] : \"id\";\n\t      await createAppForTable(\n\t        `${tableName} App`,\n\t        tableName,\n\t        searchColumnName,\n\t        credentials\n", "      );\n\t      console.log(\"\");\n\t    }\n\t  }\n\t  // Handle `retool scaffold`\n\t  else {\n\t    let tableName = argv.name;\n\t    let colNames = argv.columns;\n\t    if (!tableName || tableName.length == 0) {\n\t      tableName = await collectTableName();\n", "    }\n\t    if (!colNames || colNames.length == 0) {\n\t      colNames = await collectColumnNames();\n\t    }\n\t    await createTable(tableName, colNames, undefined, credentials, false);\n\t    // Fire and forget\n\t    void insertSampleData(tableName, credentials);\n\t    if (!argv[\"no-workflow\"]) {\n\t      console.log(\"\\n\");\n\t      await generateCRUDWorkflow(tableName, credentials);\n", "    }\n\t    console.log(\"\\n\");\n\t    const searchColumnName = colNames.length > 0 ? colNames[0] : \"id\";\n\t    await createAppForTable(\n\t      `${tableName} App`,\n\t      tableName,\n\t      searchColumnName,\n\t      credentials\n\t    );\n\t  }\n", "};\n\tconst insertSampleData = async function (\n\t  tableName: string,\n\t  credentials: Credentials\n\t) {\n\t  const infoRes = await getRequest(\n\t    `${credentials.origin}/api/grid/${credentials.gridId}/table/${tableName}/info`,\n\t    false\n\t  );\n\t  const retoolDBInfo: DBInfoPayload = infoRes.data;\n", "  const { fields } = retoolDBInfo.tableInfo;\n\t  const generatedData = await generateDataWithGPT(\n\t    retoolDBInfo,\n\t    fields,\n\t    0,\n\t    credentials,\n\t    false\n\t  );\n\t  if (generatedData) {\n\t    await postRequest(\n", "      `${credentials.origin}/api/grid/${credentials.gridId}/action`,\n\t      {\n\t        kind: \"BulkInsertIntoTable\",\n\t        tableName: tableName,\n\t        additions: generatedData,\n\t      }\n\t    );\n\t  }\n\t};\n\tconst commandModule: CommandModule = {\n", "  command,\n\t  describe,\n\t  builder,\n\t  handler,\n\t};\n\texport default commandModule;\n"]}
{"filename": "src/commands/telemetry.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\timport {\n\t  getAndVerifyCredentials,\n\t  persistCredentials,\n\t} from \"../utils/credentials\";\n\tconst command = \"telemetry\";\n\tconst describe = \"Configure CLI telemetry.\";\n\tconst builder = {\n\t  disable: {\n\t    alias: \"d\",\n", "    describe: `Disable telemetry.`,\n\t  },\n\t  enable: {\n\t    alias: \"e\",\n\t    describe: `Enable telemetry.`,\n\t  },\n\t};\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst handler = function (argv: any) {\n\t  const credentials = getAndVerifyCredentials();\n", "  if (argv.disable) {\n\t    credentials.telemetryEnabled = false;\n\t    persistCredentials(credentials);\n\t    console.log(\"Successfully disabled telemetry. 📉\");\n\t  } else if (argv.enable) {\n\t    credentials.telemetryEnabled = true;\n\t    persistCredentials(credentials);\n\t    console.log(\"Successfully enabled telemetry. 📈\");\n\t  } else {\n\t    console.log(\n", "      \"No flag specified. See `retool telemetry --help` for available flags.\"\n\t    );\n\t  }\n\t};\n\tconst commandModule: CommandModule = {\n\t  command,\n\t  describe,\n\t  builder,\n\t  handler,\n\t};\n", "export default commandModule;\n"]}
{"filename": "src/commands/whoami.ts", "chunked_list": ["import { ArgumentsCamelCase, CommandModule } from \"yargs\";\n\timport { getCredentials } from \"../utils/credentials\";\n\timport { logDAU } from \"../utils/telemetry\";\n\tconst chalk = require(\"chalk\");\n\tconst command = \"whoami\";\n\tconst describe = \"Show the current Retool user.\";\n\tconst builder = {\n\t  verbose: {\n\t    alias: \"v\",\n\t    describe: \"Print additional debugging information.\",\n", "  },\n\t};\n\tconst handler = function (argv: ArgumentsCamelCase) {\n\t  const credentials = getCredentials();\n\t  // fire and forget\n\t  void logDAU(credentials);\n\t  if (credentials) {\n\t    if (\n\t      !process.env.DEBUG &&\n\t      !argv.verbose &&\n", "      credentials.firstName &&\n\t      credentials.lastName &&\n\t      credentials.email\n\t    ) {\n\t      console.log(\n\t        `Logged in to ${chalk.bold(credentials.origin)} as ${chalk.bold(\n\t          credentials.firstName\n\t        )} ${chalk.bold(credentials.lastName)} (${credentials.email}) 🙌🏻`\n\t      );\n\t    } else {\n", "      console.log(\"You are logged in with credentials:\");\n\t      console.log(credentials);\n\t    }\n\t  } else {\n\t    console.log(`No credentials found. To log in, run: \\`retool login\\``);\n\t  }\n\t};\n\tconst commandModule: CommandModule = {\n\t  command,\n\t  describe,\n", "  builder,\n\t  handler,\n\t};\n\texport default commandModule;\n"]}
{"filename": "src/commands/db.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\timport { getAndVerifyCredentialsWithRetoolDB } from \"../utils/credentials\";\n\timport { generateData, promptForDataType } from \"../utils/faker\";\n\timport { getRequest, postRequest } from \"../utils/networking\";\n\timport {\n\t  DBInfoPayload,\n\t  collectColumnNames,\n\t  collectTableName,\n\t  createTable,\n\t  createTableFromCSV,\n", "  deleteTable,\n\t  fetchAllTables,\n\t  generateDataWithGPT,\n\t  parseDBData,\n\t  verifyTableExists,\n\t} from \"../utils/table\";\n\timport { logDAU } from \"../utils/telemetry\";\n\tconst chalk = require(\"chalk\");\n\tconst inquirer = require(\"inquirer\");\n\tconst ora = require(\"ora\");\n", "const command = \"db\";\n\tconst describe = \"Interface with Retool DB.\";\n\tconst builder: CommandModule[\"builder\"] = {\n\t  list: {\n\t    alias: \"l\",\n\t    describe: \"List all tables in Retool DB.\",\n\t  },\n\t  create: {\n\t    alias: \"c\",\n\t    describe: `Create a new table.`,\n", "  },\n\t  upload: {\n\t    alias: \"u\",\n\t    describe: `Upload a new table from a CSV file. Usage:\n\t    retool db -u <path-to-csv>`,\n\t    type: \"string\",\n\t    nargs: 1,\n\t  },\n\t  delete: {\n\t    alias: \"d\",\n", "    describe: `Delete a table. Usage:\n\t    retool db -d <table-name>`,\n\t    type: \"array\",\n\t  },\n\t  gendata: {\n\t    alias: \"g\",\n\t    describe: `Generate data for a table interactively. Usage:\n\t    retool db -g <table-name>`,\n\t    type: \"string\",\n\t    nargs: 1,\n", "  },\n\t  gpt: {\n\t    describe: `A modifier for gendata that uses GPT. Usage:\n\t    retool db --gendata <table-name> --gpt`,\n\t  },\n\t};\n\tconst handler = async function (argv: any) {\n\t  const credentials = await getAndVerifyCredentialsWithRetoolDB();\n\t  // fire and forget\n\t  void logDAU(credentials);\n", "  // Handle `retool db --upload <path-to-csv>`\n\t  if (argv.upload) {\n\t    await createTableFromCSV(argv.upload, credentials, true, true);\n\t  }\n\t  // Handle `retool db --create`\n\t  else if (argv.create) {\n\t    const tableName = await collectTableName();\n\t    const colNames = await collectColumnNames();\n\t    await createTable(tableName, colNames, undefined, credentials, true);\n\t  }\n", "  // Handle `retool db --list`\n\t  else if (argv.list) {\n\t    const tables = await fetchAllTables(credentials);\n\t    if (tables && tables.length > 0) {\n\t      tables.forEach((table) => {\n\t        console.log(table.name);\n\t      });\n\t    } else {\n\t      console.log(\"No tables found.\");\n\t    }\n", "  }\n\t  // Handle `retool db --delete <table-name>`\n\t  else if (argv.delete) {\n\t    const tableNames = argv.delete;\n\t    for (const tableName of tableNames) {\n\t      await deleteTable(tableName, credentials, true);\n\t    }\n\t  }\n\t  // Handle `retool db --gendata <table-name>`\n\t  else if (argv.gendata) {\n", "    // Verify that the provided db name exists.\n\t    const tableName = argv.gendata;\n\t    await verifyTableExists(tableName, credentials);\n\t    // Fetch Retool DB schema and data.\n\t    const spinner = ora(`Fetching ${tableName} metadata`).start();\n\t    const infoReq = getRequest(\n\t      `${credentials.origin}/api/grid/${credentials.gridId}/table/${tableName}/info`\n\t    );\n\t    const dataReq = postRequest(\n\t      `${credentials.origin}/api/grid/${credentials.gridId}/table/${tableName}/data`,\n", "      {\n\t        filters: [],\n\t        sorting: [],\n\t      }\n\t    );\n\t    const [infoRes, dataRes] = await Promise.all([infoReq, dataReq]);\n\t    spinner.stop();\n\t    const retoolDBInfo: DBInfoPayload = infoRes.data;\n\t    const { fields } = retoolDBInfo.tableInfo;\n\t    const retoolDBData: string = dataRes.data;\n", "    // Find the max primary key value.\n\t    // 1. Parse the table data.\n\t    const parsedDBData = parseDBData(retoolDBData);\n\t    // 2. Find the index of the primary key column.\n\t    const primaryKeyColIndex = parsedDBData[0].indexOf(\n\t      retoolDBInfo.tableInfo.primaryKeyColumn\n\t    );\n\t    // 3. Find the max value of the primary key column.\n\t    const primaryKeyMaxVal = Math.max(\n\t      ...parsedDBData\n", "        .slice(1)\n\t        .map((row) => row[primaryKeyColIndex])\n\t        .map((id) => parseInt(id)),\n\t      0\n\t    );\n\t    let generatedData: { fields: string[]; data: string[][] };\n\t    // Generate data using GPT.\n\t    if (argv.gpt) {\n\t      spinner.start(\"Generating data using GPT\");\n\t      const gptRes = await generateDataWithGPT(\n", "        retoolDBInfo,\n\t        fields,\n\t        primaryKeyMaxVal,\n\t        credentials,\n\t        true\n\t      );\n\t      //Shouldn't happen, generateDataWithGPT should exit on failure.\n\t      if (!gptRes) {\n\t        process.exit(1);\n\t      }\n", "      generatedData = gptRes;\n\t      spinner.stop();\n\t    }\n\t    // Generate data using faker.\n\t    else {\n\t      // Ask how many rows to generate.\n\t      const MAX_BATCH_SIZE = 2500;\n\t      const { rowCount } = await inquirer.prompt([\n\t        {\n\t          name: \"rowCount\",\n", "          message: \"How many rows to generate?\",\n\t          type: \"input\",\n\t        },\n\t      ]);\n\t      if (Number.isNaN(parseInt(rowCount))) {\n\t        console.log(`Error: Must provide a number.`);\n\t        return;\n\t      }\n\t      if (rowCount < 0) {\n\t        console.log(`Error: Cannot generate <1 rows.`);\n", "        return;\n\t      }\n\t      if (rowCount > MAX_BATCH_SIZE) {\n\t        console.log(\n\t          `Error: Cannot generate more than ${MAX_BATCH_SIZE} rows at a time.`\n\t        );\n\t        return;\n\t      }\n\t      // Ask what type of data to generate for each column.\n\t      for (let i = 0; i < fields.length; i++) {\n", "        if (fields[i].name === retoolDBInfo.tableInfo.primaryKeyColumn)\n\t          continue;\n\t        fields[i].generatedColumnType = await promptForDataType(fields[i].name);\n\t      }\n\t      // Generate mock data.\n\t      generatedData = await generateData(\n\t        fields,\n\t        rowCount,\n\t        retoolDBInfo.tableInfo.primaryKeyColumn,\n\t        primaryKeyMaxVal\n", "      );\n\t    }\n\t    // Insert to Retool DB.\n\t    const bulkInsertRes = await postRequest(\n\t      `${credentials.origin}/api/grid/${credentials.gridId}/action`,\n\t      {\n\t        kind: \"BulkInsertIntoTable\",\n\t        tableName: tableName,\n\t        additions: generatedData,\n\t      }\n", "    );\n\t    if (bulkInsertRes.data.success) {\n\t      console.log(\"Successfully inserted data. 🤘🏻\");\n\t      console.log(\n\t        `\\n${chalk.bold(\"View in browser:\")} ${\n\t          credentials.origin\n\t        }/resources/data/${\n\t          credentials.retoolDBUuid\n\t        }/${tableName}?env=production`\n\t      );\n", "    } else {\n\t      console.log(\"Error inserting data.\");\n\t      console.log(bulkInsertRes.data);\n\t    }\n\t  }\n\t  // No flag specified.\n\t  else {\n\t    console.log(\n\t      \"No flag specified. See `retool db --help` for available flags.\"\n\t    );\n", "  }\n\t};\n\tconst commandModule: CommandModule = {\n\t  command,\n\t  describe,\n\t  builder,\n\t  handler,\n\t};\n\texport default commandModule;\n"]}
{"filename": "src/commands/signup.ts", "chunked_list": ["import { CommandModule } from \"yargs\";\n\timport { logSuccess } from \"./login\";\n\timport { accessTokenFromCookies, xsrfTokenFromCookies } from \"../utils/cookies\";\n\timport { doCredentialsExist, persistCredentials } from \"../utils/credentials\";\n\timport { getRequest, postRequest } from \"../utils/networking\";\n\timport { logDAU } from \"../utils/telemetry\";\n\timport { isEmailValid } from \"../utils/validation\";\n\tconst axios = require(\"axios\");\n\tconst inquirer = require(\"inquirer\");\n\tconst ora = require(\"ora\");\n", "const command = \"signup\";\n\tconst describe = \"Create a Retool account.\";\n\tconst builder = {};\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst handler = async function (argv: any) {\n\t  // Ask user if they want to overwrite existing credentials.\n\t  if (doCredentialsExist()) {\n\t    const { overwrite } = await inquirer.prompt([\n\t      {\n\t        name: \"overwrite\",\n", "        message:\n\t          \"You're already logged in. Do you want to log out and create a new account?\",\n\t        type: \"confirm\",\n\t      },\n\t    ]);\n\t    if (!overwrite) {\n\t      return;\n\t    }\n\t  }\n\t  // Step 1: Collect a valid email/password.\n", "  let email, password, name, org;\n\t  while (!email) {\n\t    email = await collectEmail();\n\t  }\n\t  while (!password) {\n\t    password = await colllectPassword();\n\t  }\n\t  // Step 2: Call signup endpoint, get cookies.\n\t  const spinner = ora(\n\t    \"Verifying that the email and password are valid on the server\"\n", "  ).start();\n\t  const signupResponse = await postRequest(\n\t    `https://login.retool.com/api/signup`,\n\t    {\n\t      email,\n\t      password,\n\t      planKey: \"free\",\n\t    }\n\t  );\n\t  spinner.stop();\n", "  const accessToken = accessTokenFromCookies(\n\t    signupResponse.headers[\"set-cookie\"]\n\t  );\n\t  const xsrfToken = xsrfTokenFromCookies(signupResponse.headers[\"set-cookie\"]);\n\t  if (!accessToken || !xsrfToken) {\n\t    if (process.env.DEBUG) {\n\t      console.log(signupResponse);\n\t    }\n\t    console.log(\n\t      \"Error creating account, please try again or signup at https://login.retool.com/auth/signup?plan=free.\"\n", "    );\n\t    return;\n\t  }\n\t  axios.defaults.headers[\"x-xsrf-token\"] = xsrfToken;\n\t  axios.defaults.headers.cookie = `accessToken=${accessToken};`;\n\t  // Step 3: Collect a valid name/org.\n\t  while (!name) {\n\t    name = await collectName();\n\t  }\n\t  while (!org) {\n", "    org = await collectOrg();\n\t  }\n\t  // Step 4: Initialize organization.\n\t  await postRequest(\n\t    `https://login.retool.com/api/organization/admin/initializeOrganization`,\n\t    {\n\t      subdomain: org,\n\t    }\n\t  );\n\t  // Step 5: Persist credentials\n", "  const origin = `https://${org}.retool.com`;\n\t  const userRes = await getRequest(`${origin}/api/user`);\n\t  persistCredentials({\n\t    origin,\n\t    accessToken,\n\t    xsrf: xsrfToken,\n\t    firstName: userRes.data.user?.firstName,\n\t    lastName: userRes.data.user?.lastName,\n\t    email: userRes.data.user?.email,\n\t    telemetryEnabled: true,\n", "  });\n\t  logSuccess();\n\t  await logDAU();\n\t};\n\tasync function collectEmail(): Promise<string | undefined> {\n\t  const { email } = await inquirer.prompt([\n\t    {\n\t      name: \"email\",\n\t      message: \"What is your email?\",\n\t      type: \"input\",\n", "    },\n\t  ]);\n\t  if (!isEmailValid(email)) {\n\t    console.log(\"Invalid email, try again.\");\n\t    return;\n\t  }\n\t  return email;\n\t}\n\tasync function colllectPassword(): Promise<string | undefined> {\n\t  const { password } = await inquirer.prompt([\n", "    {\n\t      name: \"password\",\n\t      message: \"Please create a password (min 8 characters):\",\n\t      type: \"password\",\n\t    },\n\t  ]);\n\t  const { confirmedPassword } = await inquirer.prompt([\n\t    {\n\t      name: \"confirmedPassword\",\n\t      message: \"Please confirm password:\",\n", "      type: \"password\",\n\t    },\n\t  ]);\n\t  if (password.length < 8) {\n\t    console.log(\"Password must be at least 8 characters long, try again.\");\n\t    return;\n\t  }\n\t  if (password !== confirmedPassword) {\n\t    console.log(\"Passwords do not match, try again.\");\n\t    return;\n", "  }\n\t  return password;\n\t}\n\tasync function collectName(): Promise<string | undefined> {\n\t  const { name } = await inquirer.prompt([\n\t    {\n\t      name: \"name\",\n\t      message: \"What is your first and last name?\",\n\t      type: \"input\",\n\t    },\n", "  ]);\n\t  if (!name || name.length === 0) {\n\t    console.log(\"Invalid name, try again.\");\n\t    return;\n\t  }\n\t  const parts = name.split(\" \");\n\t  const changeNameResponse = await postRequest(\n\t    `https://login.retool.com/api/user/changeName`,\n\t    {\n\t      firstName: parts[0],\n", "      lastName: parts[1],\n\t    },\n\t    false\n\t  );\n\t  if (!changeNameResponse) {\n\t    return;\n\t  }\n\t  return name;\n\t}\n\tasync function collectOrg(): Promise<string | undefined> {\n", "  let { org } = await inquirer.prompt([\n\t    {\n\t      name: \"org\",\n\t      message:\n\t        \"What is your organization name? Leave blank to generate a random name.\",\n\t      type: \"input\",\n\t    },\n\t  ]);\n\t  if (!org || org.length === 0) {\n\t    // Org must start with letter, append a random string after it.\n", "    // https://stackoverflow.com/a/8084248\n\t    org = \"z\" + (Math.random() + 1).toString(36).substring(2);\n\t  }\n\t  const checkSubdomainAvailabilityResponse = await getRequest(\n\t    `https://login.retool.com/api/organization/admin/checkSubdomainAvailability?subdomain=${org}`,\n\t    false\n\t  );\n\t  if (!checkSubdomainAvailabilityResponse.status) {\n\t    return;\n\t  }\n", "  return org;\n\t}\n\tconst commandModule: CommandModule = { command, describe, builder, handler };\n\texport default commandModule;\n"]}
{"filename": "src/utils/faker.ts", "chunked_list": ["import { RetoolDBField } from \"./table\";\n\tconst inquirer = require(\"inquirer\");\n\tconst TreePrompt = require(\"inquirer-tree-prompt\");\n\t// Generate `rowCount` rows for each field in `fields`.\n\texport async function generateData(\n\t  fields: Array<RetoolDBField>,\n\t  rowCount: number,\n\t  primaryKeyColumnName: string,\n\t  primaryKeyMaxVal: number\n\t): Promise<{\n", "  data: string[][]; // rows\n\t  fields: string[]; // column names\n\t}> {\n\t  const column_names = fields.map((field) => field.name);\n\t  const rows: string[][] = [];\n\t  // Init rows\n\t  for (let j = 0; j < rowCount; j++) {\n\t    rows.push([]);\n\t  }\n\t  for (let i = 0; i < fields.length; i++) {\n", "    for (let j = 0; j < rowCount; j++) {\n\t      // Handle primary key column.\n\t      if (fields[i].name === primaryKeyColumnName) {\n\t        rows[j].push((primaryKeyMaxVal + j + 1).toString());\n\t      } else {\n\t        rows[j].push(\n\t          await generateDataForColumnType(fields[i].generatedColumnType)\n\t        );\n\t      }\n\t    }\n", "  }\n\t  return {\n\t    data: rows,\n\t    fields: column_names,\n\t  };\n\t}\n\t// Each colType string is an option in `promptForDataType()`\n\tasync function generateDataForColumnType(\n\t  colType: string | undefined\n\t): Promise<string> {\n", "  // Faker is slow, dynamically import it.\n\t  return import(\"@faker-js/faker/locale/en_US\").then(({ faker }) => {\n\t    if (colType === \"First Name\") {\n\t      return faker.person.firstName();\n\t    } else if (colType === \"Last Name\") {\n\t      return faker.person.lastName();\n\t    } else if (colType === \"Full Name\" || colType === \"Person\") {\n\t      return faker.person.fullName();\n\t    } else if (colType === \"Phone Number\") {\n\t      return faker.phone.number();\n", "    } else if (colType === \"Email\") {\n\t      return faker.internet.email();\n\t    } else if (colType === \"Birthdate\") {\n\t      return faker.date.birthdate().toString();\n\t    } else if (colType === \"Gender\") {\n\t      return faker.person.gender();\n\t    } else if (colType === \"Street Address\" || colType === \"Location\") {\n\t      return faker.location.streetAddress();\n\t    } else if (colType === \"City\") {\n\t      return faker.location.city();\n", "    } else if (colType === \"State\") {\n\t      return faker.location.state();\n\t    } else if (colType === \"Zip Code\") {\n\t      return faker.location.zipCode();\n\t    } else if (colType === \"Country\") {\n\t      return faker.location.country();\n\t    } else if (colType === \"Country Code\") {\n\t      return faker.location.countryCode();\n\t    } else if (colType === \"Timezone\") {\n\t      return faker.location.timeZone();\n", "    } else if (colType === \"Past\" || colType === \"Date\") {\n\t      return faker.date.past().toString();\n\t    } else if (colType === \"Future\") {\n\t      return faker.date.future().toString();\n\t    } else if (colType === \"Month\") {\n\t      return faker.date.month();\n\t    } else if (colType === \"Weekday\") {\n\t      return faker.date.weekday();\n\t    } else if (colType === \"Unix Timestamp\") {\n\t      return faker.date.past().getTime().toString();\n", "    } else if (colType === \"Number\" || colType === \"Random\") {\n\t      return faker.number.int(10000).toString();\n\t    } else if (colType === \"String\") {\n\t      return faker.string.alpha(5);\n\t    } else if (colType === \"Boolean\") {\n\t      return faker.datatype.boolean().toString();\n\t    } else if (colType === \"Word\") {\n\t      return faker.word.words(1);\n\t    } else if (colType === \"Lorem Ipsum\") {\n\t      return faker.lorem.sentence(5);\n", "    } else if (colType === \"Bitcoin Address\") {\n\t      return faker.finance.bitcoinAddress();\n\t    } else {\n\t      return faker.string.alpha(5);\n\t    }\n\t  });\n\t}\n\t// Each option should have a corresponding case in `generateDataForColumnType()`\n\texport async function promptForDataType(fieldName: string): Promise<string> {\n\t  inquirer.registerPrompt(\"tree\", TreePrompt);\n", "  const { generatedType } = await inquirer.prompt([\n\t    {\n\t      type: \"tree\",\n\t      name: \"generatedType\",\n\t      message: `What type of data to generate for ${fieldName}?`,\n\t      tree: [\n\t        {\n\t          name: \"Person\",\n\t          children: [\n\t            \"First Name\",\n", "            \"Last Name\",\n\t            \"Full Name\",\n\t            \"Phone Number\",\n\t            \"Email\",\n\t            \"Birthdate\",\n\t            \"Gender\",\n\t          ],\n\t        },\n\t        {\n\t          value: \"Location\",\n", "          children: [\n\t            \"Street Address\",\n\t            \"City\",\n\t            \"State\",\n\t            \"Zip Code\",\n\t            \"Country\",\n\t            \"Country Code\",\n\t            \"Timezone\",\n\t          ],\n\t        },\n", "        {\n\t          value: \"Date\",\n\t          children: [\"Past\", \"Future\", \"Month\", \"Weekday\", \"Unix Timestamp\"],\n\t        },\n\t        {\n\t          value: \"Random\",\n\t          children: [\n\t            \"Number\",\n\t            \"String\",\n\t            \"Boolean\",\n", "            \"Word\",\n\t            \"Lorem Ipsum\",\n\t            \"Bitcoin Address\",\n\t          ],\n\t        },\n\t      ],\n\t    },\n\t  ]);\n\t  console.log(generatedType);\n\t  return generatedType;\n", "}\n"]}
{"filename": "src/utils/table.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\";\n\timport { parseDBData } from \"./table\";\n\tdescribe(\"parseDBData\", () => {\n\t  test(\"should transform data into expected format\", () => {\n\t    const input = `[\"col_1\",\"col_2\",\"col_3\"]\\n[\"val_1\",\"val_2\",\"val_3\"]`;\n\t    const expectedOutput = [[\"col_1\",\"col_2\",\"col_3\"],[\"val_1\",\"val_2\",\"val_3\"]];\n\t    expect(parseDBData(input)).toStrictEqual(expectedOutput);\n\t  });\n\t  test(\"should preserve brackets and \\\" in data\", () => {\n\t    const input = `[\"col[]_1\",\"col\"_2\",\"\"col_3]\"]`;\n", "    const expectedOutput = [[\"col[]_1\",`col\"_2`,`\"col_3]`]];\n\t    expect(parseDBData(input)).toStrictEqual(expectedOutput);\n\t  });\n\t});\n"]}
{"filename": "src/utils/cookies.ts", "chunked_list": ["export function accessTokenFromCookies(cookies: string[]): string | undefined {\n\t  for (const cookie of cookies) {\n\t    // Matches everything between accessToken= and ;\n\t    const matches = cookie.match(/accessToken=([^;]+)/);\n\t    if (matches) {\n\t      // The first match includes \"accessToken=\", so we want the second match.\n\t      return matches[1];\n\t    }\n\t  }\n\t}\n", "export function xsrfTokenFromCookies(cookies: string[]): string | undefined {\n\t  for (const cookie of cookies) {\n\t    // Matches everything between xsrfToken= and ;\n\t    const matches = cookie.match(/xsrfToken=([^;]+)/);\n\t    if (matches) {\n\t      // The first match includes \"xsrfToken=\", so we want the second match.\n\t      return matches[1];\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/utils/puppeteer.ts", "chunked_list": ["import {\n\t  WorkflowTemplateType,\n\t  workflowTemplate,\n\t} from \"../resources/workflowTemplate\";\n\timport { getCredentials } from \"../utils/credentials\";\n\t/*\n\t * CAUTION: Puppeteer import takes ~90ms. Prefer to dynamically import this file.\n\t */\n\tconst puppeteer = require(\"puppeteer\");\n\tdeclare global {\n", "  interface Window {\n\t    generateWorkflowFromTemplateData: any;\n\t  }\n\t}\n\t// https://stackoverflow.com/a/61304202\n\tconst waitTillHTMLRendered = async (page: any, timeout = 30000) => {\n\t  const checkDurationMsecs = 1000;\n\t  const maxChecks = timeout / checkDurationMsecs;\n\t  let lastHTMLSize = 0;\n\t  let checkCounts = 1;\n", "  let countStableSizeIterations = 0;\n\t  const minStableSizeIterations = 2;\n\t  while (checkCounts++ <= maxChecks) {\n\t    const html = await page.content();\n\t    const currentHTMLSize = html.length;\n\t    // Uncomment for debugging\n\t    // const bodyHTMLSize = await page.evaluate(\n\t    //   () => document.body.innerHTML.length\n\t    // );\n\t    // console.log(\n", "    //   \"last: \",\n\t    //   lastHTMLSize,\n\t    //   \" <> curr: \",\n\t    //   currentHTMLSize,\n\t    //   \" body html size: \",\n\t    //   bodyHTMLSize\n\t    // );\n\t    if (lastHTMLSize != 0 && currentHTMLSize == lastHTMLSize)\n\t      countStableSizeIterations++;\n\t    else countStableSizeIterations = 0; //reset the counter\n", "    // Page rendered fully\n\t    if (countStableSizeIterations >= minStableSizeIterations) {\n\t      break;\n\t    }\n\t    lastHTMLSize = currentHTMLSize;\n\t    await page.waitForTimeout(checkDurationMsecs);\n\t  }\n\t};\n\texport const generateWorkflowMetadata = async (tableName: string) => {\n\t  const credentials = getCredentials();\n", "  if (!credentials) {\n\t    return;\n\t  }\n\t  try {\n\t    // Launch Puppeteer and navigate to subdomain.retool.com/workflows\n\t    const browser = await puppeteer.launch({\n\t      headless: \"new\",\n\t      // Uncomment this line to see the browser in action\n\t      // headless: false,\n\t    });\n", "    const page = await browser.newPage();\n\t    const domain = new URL(credentials.origin).hostname;\n\t    const cookies = [\n\t      {\n\t        domain,\n\t        name: \"accessToken\",\n\t        value: credentials.accessToken,\n\t      },\n\t      {\n\t        domain,\n", "        name: \"xsrfToken\",\n\t        value: credentials.xsrf,\n\t      },\n\t    ];\n\t    await page.setCookie(...cookies);\n\t    await page.goto(`${credentials.origin}/workflows`);\n\t    await waitTillHTMLRendered(page);\n\t    // Call window.generateWorkflowFromTemplateData() on the page\n\t    const generatedWorkflowMetadata = await page.evaluate(\n\t      (\n", "        tableName: string,\n\t        workflowTemplate: WorkflowTemplateType,\n\t        retoolDBUuid: string\n\t      ) => {\n\t        // Replaces instances of \"name_placeholder\" with the newly created table name\n\t        workflowTemplate.map((item) => {\n\t          if (item.pluginTemplate.template.tableName === \"name_placeholder\") {\n\t            item.pluginTemplate.template.tableName = `\\\"${tableName}\\\"`;\n\t          }\n\t          if (item.pluginTemplate.template.query.includes(\"name_placeholder\")) {\n", "            item.pluginTemplate.template.query =\n\t              item.pluginTemplate.template.query.replace(\n\t                \"name_placeholder\",\n\t                `\\\"${tableName}\\\"`\n\t              );\n\t          }\n\t          // Inject retool DB UUID\n\t          if (\n\t            item.block.pluginId === \"createQuery\" ||\n\t            item.block.pluginId === \"readQuery\" ||\n", "            item.block.pluginId === \"updateQuery\" ||\n\t            item.block.pluginId === \"destroyQuery\"\n\t          ) {\n\t            item.block.resourceName = retoolDBUuid;\n\t            item.pluginTemplate.resourceName = retoolDBUuid;\n\t          }\n\t        });\n\t        const payload = {\n\t          name: `${tableName} CRUD Workflow`,\n\t          templateData: workflowTemplate,\n", "          resources: [],\n\t        };\n\t        const workflow = window.generateWorkflowFromTemplateData(payload);\n\t        return workflow;\n\t      },\n\t      tableName,\n\t      workflowTemplate,\n\t      credentials.retoolDBUuid\n\t    );\n\t    await browser.close();\n", "    return generatedWorkflowMetadata;\n\t  } catch (error) {\n\t    console.error(\"Error:\", error);\n\t  }\n\t};\n"]}
{"filename": "src/utils/credentials.ts", "chunked_list": ["import { Entry } from \"@napi-rs/keyring\";\n\timport { getRequest } from \"./networking\";\n\timport { isAccessTokenValid, isOriginValid, isXsrfValid } from \"./validation\";\n\tconst axios = require(\"axios\");\n\tconst inquirer = require(\"inquirer\");\n\tconst ora = require(\"ora\");\n\tconst RETOOL_CLI_SERVICE_NAME = \"Retool CLI\";\n\tconst RETOOL_CLI_ACCOUNT_NAME = \"retool-cli-user\";\n\t/*\n\t * Credential management using keyring-rs. This is a cross-platform library\n", " * which uses the OS's native credential manager.\n\t * https://github.com/Brooooooklyn/keyring-node\n\t * https://github.com/hwchen/keyring-rs\n\t */\n\texport type Credentials = {\n\t  origin: string; // The 3 required properties are fetched during login.\n\t  xsrf: string;\n\t  accessToken: string;\n\t  gridId?: string; // The next 3 properties are fetched the first time user interacts with RetoolDB.\n\t  retoolDBUuid?: string;\n", "  hasConnectionString?: boolean;\n\t  firstName?: string; // The next 3 properties are sometimes fetched during login.\n\t  lastName?: string;\n\t  email?: string;\n\t  telemetryEnabled: boolean; // The next 2 properties control telemetry.\n\t  telemetryLastSent?: number;\n\t};\n\t// Legacy way of getting credentials.\n\texport async function askForCookies() {\n\t  let { origin } = await inquirer.prompt([\n", "    {\n\t      name: \"origin\",\n\t      message: \"What is your Retool origin? (e.g., https://my-org.retool.com).\",\n\t      type: \"input\",\n\t    },\n\t  ]);\n\t  //Check if last character is a slash. If so, remove it.\n\t  if (origin[origin.length - 1] === \"/\") {\n\t    origin = origin.slice(0, -1);\n\t  }\n", "  if (!isOriginValid(origin)) {\n\t    console.log(\"Error: Origin is invalid. Remember to include https://.\");\n\t    process.exit(1);\n\t  }\n\t  const { xsrf } = await inquirer.prompt([\n\t    {\n\t      name: \"xsrf\",\n\t      message:\n\t        \"What is your XSRF token? (e.g., 26725f72-8129-47f7-835a-cba0e5dbcfe6) \\n  Log into Retool, open cookies inspector.\\n  In Chrome, hit ⌘+⌥+I (Mac) or Ctrl+Shift+I (Windows, Linux) to open dev tools.\\n  Application tab > your-org.retool.com in Cookies menu > double click cookie value and copy it.\",\n\t      type: \"input\",\n", "    },\n\t  ]);\n\t  if (!isXsrfValid(xsrf)) {\n\t    console.log(\"Error: XSRF token is invalid.\");\n\t    process.exit(1);\n\t  }\n\t  const { accessToken } = await inquirer.prompt([\n\t    {\n\t      name: \"accessToken\",\n\t      message: `What is your access token? It's also found in the cookies inspector.`,\n", "      type: \"input\",\n\t    },\n\t  ]);\n\t  if (!isAccessTokenValid(accessToken)) {\n\t    console.log(\"Error: Access token is invalid.\");\n\t    process.exit(1);\n\t  }\n\t  persistCredentials({\n\t    origin,\n\t    xsrf,\n", "    accessToken,\n\t    telemetryEnabled: true,\n\t  });\n\t  console.log(\"Successfully saved credentials.\");\n\t}\n\texport function persistCredentials(credentials: Credentials) {\n\t  const entry = new Entry(RETOOL_CLI_SERVICE_NAME, RETOOL_CLI_ACCOUNT_NAME);\n\t  entry.setPassword(JSON.stringify(credentials));\n\t}\n\texport function getCredentials(): Credentials | undefined {\n", "  const entry = new Entry(RETOOL_CLI_SERVICE_NAME, RETOOL_CLI_ACCOUNT_NAME);\n\t  const password = entry.getPassword();\n\t  if (password) {\n\t    return JSON.parse(password);\n\t  }\n\t}\n\texport function doCredentialsExist(): boolean {\n\t  const entry = new Entry(RETOOL_CLI_SERVICE_NAME, RETOOL_CLI_ACCOUNT_NAME);\n\t  const password = entry.getPassword();\n\t  if (password) {\n", "    return true;\n\t  }\n\t  return false;\n\t}\n\texport function deleteCredentials() {\n\t  const entry = new Entry(RETOOL_CLI_SERVICE_NAME, RETOOL_CLI_ACCOUNT_NAME);\n\t  entry.deletePassword();\n\t}\n\t// Fetch gridId and retoolDBUuid from Retool. Persist to keychain.\n\tasync function fetchDBCredentials() {\n", "  const credentials = getCredentials();\n\t  if (!credentials) {\n\t    return;\n\t  }\n\t  // 1. Fetch all resources\n\t  const resources = await getRequest(`${credentials.origin}/api/resources`);\n\t  // 2. Filter down to Retool DB UUID\n\t  const retoolDBs = resources?.data?.resources?.filter(\n\t    (resource: any) => resource.displayName === \"retool_db\"\n\t  );\n", "  if (retoolDBs?.length < 1) {\n\t    console.log(\n\t      `\\nError: Retool DB not found. Create one at ${credentials.origin}/resources`\n\t    );\n\t    return;\n\t  }\n\t  const retoolDBUuid = retoolDBs[0].name;\n\t  // 3. Fetch Grid Info\n\t  const grid = await getRequest(\n\t    `${credentials.origin}/api/grid/retooldb/${retoolDBUuid}?env=production`\n", "  );\n\t  persistCredentials({\n\t    ...credentials,\n\t    retoolDBUuid,\n\t    gridId: grid?.data?.gridInfo?.id,\n\t    hasConnectionString: grid?.data?.gridInfo?.connectionString?.length > 0,\n\t  });\n\t}\n\texport async function getAndVerifyCredentialsWithRetoolDB() {\n\t  const spinner = ora(\"Verifying Retool DB credentials\").start();\n", "  let credentials = getCredentials();\n\t  if (!credentials) {\n\t    spinner.stop();\n\t    console.log(\n\t      `Error: No credentials found. To log in, run: \\`retool login\\``\n\t    );\n\t    process.exit(1);\n\t  }\n\t  axios.defaults.headers[\"x-xsrf-token\"] = credentials.xsrf;\n\t  axios.defaults.headers.cookie = `accessToken=${credentials.accessToken};`;\n", "  if (!credentials.gridId || !credentials.retoolDBUuid) {\n\t    await fetchDBCredentials();\n\t    credentials = getCredentials();\n\t    if (!credentials?.gridId || !credentials?.retoolDBUuid) {\n\t      spinner.stop();\n\t      console.log(`Error: No Retool DB credentials found.`);\n\t      process.exit(1);\n\t    }\n\t  }\n\t  spinner.stop();\n", "  return credentials;\n\t}\n\texport function getAndVerifyCredentials() {\n\t  const spinner = ora(\"Verifying Retool credentials\").start();\n\t  const credentials = getCredentials();\n\t  if (!credentials) {\n\t    spinner.stop();\n\t    console.log(\n\t      `Error: No credentials found. To log in, run: \\`retool login\\``\n\t    );\n", "    process.exit(1);\n\t  }\n\t  axios.defaults.headers[\"x-xsrf-token\"] = credentials.xsrf;\n\t  axios.defaults.headers.cookie = `accessToken=${credentials.accessToken};`;\n\t  spinner.stop();\n\t  return credentials;\n\t}\n"]}
{"filename": "src/utils/apps.ts", "chunked_list": ["import chalk from \"chalk\";\n\timport { Credentials } from \"./credentials\";\n\timport { getRequest, postRequest } from \"./networking\";\n\tconst inquirer = require(\"inquirer\");\n\tconst ora = require(\"ora\");\n\texport type App = {\n\t  uuid: string;\n\t  name: string;\n\t  folderId: number;\n\t  id: string;\n", "  protected: boolean;\n\t  updatedAt: string;\n\t  createdAt: string;\n\t  isGlobalWidget: boolean; // is a module\n\t};\n\ttype Folder = {\n\t  id: number;\n\t  parentFolderId: number;\n\t  name: string;\n\t  systemFolder: boolean;\n", "  createdAt: string;\n\t  updatedAt: string;\n\t  folderType: string;\n\t  accessLevel: string;\n\t};\n\texport async function createApp(\n\t  appName: string,\n\t  credentials: Credentials\n\t): Promise<App | undefined> {\n\t  const spinner = ora(\"Creating App\").start();\n", "  const createAppResult = await postRequest(\n\t    `${credentials.origin}/api/pages/createPage`,\n\t    {\n\t      pageName: appName,\n\t      isGlobalWidget: false,\n\t      isMobileApp: false,\n\t      multiScreenMobileApp: false,\n\t    }\n\t  );\n\t  spinner.stop();\n", "  const { page } = createAppResult.data;\n\t  if (!page?.uuid) {\n\t    console.log(\"Error creating app.\");\n\t    console.log(createAppResult.data);\n\t    process.exit(1);\n\t  } else {\n\t    console.log(\"Successfully created an App. 🎉\");\n\t    console.log(\n\t      `${chalk.bold(\"View in browser:\")} ${credentials.origin}/editor/${\n\t        page.uuid\n", "      }`\n\t    );\n\t    return page;\n\t  }\n\t}\n\texport async function createAppForTable(\n\t  appName: string,\n\t  tableName: string,\n\t  columnName: string, //The column to use for search bar.\n\t  credentials: Credentials\n", ") {\n\t  const spinner = ora(\"Creating App\").start();\n\t  const createAppResult = await postRequest(\n\t    `${credentials.origin}/api/pages/autogeneratePage`,\n\t    {\n\t      appName,\n\t      resourceName: credentials.retoolDBUuid,\n\t      tableName,\n\t      columnName,\n\t    }\n", "  );\n\t  spinner.stop();\n\t  const { pageUuid } = createAppResult.data;\n\t  if (!pageUuid) {\n\t    console.log(\"Error creating app.\");\n\t    console.log(createAppResult.data);\n\t    process.exit(1);\n\t  } else {\n\t    console.log(\"Successfully created an App. 🎉\");\n\t    console.log(\n", "      `${chalk.bold(\"View in browser:\")} ${\n\t        credentials.origin\n\t      }/editor/${pageUuid}`\n\t    );\n\t  }\n\t}\n\texport async function deleteApp(\n\t  appName: string,\n\t  credentials: Credentials,\n\t  confirmDeletion: boolean\n", ") {\n\t  if (confirmDeletion) {\n\t    const { confirm } = await inquirer.prompt([\n\t      {\n\t        name: \"confirm\",\n\t        message: `Are you sure you want to delete ${appName}?`,\n\t        type: \"confirm\",\n\t      },\n\t    ]);\n\t    if (!confirm) {\n", "      process.exit(0);\n\t    }\n\t  }\n\t  // Verify that the provided appName exists.\n\t  const { apps } = await getAppsAndFolders(credentials);\n\t  const app = apps?.filter((app) => {\n\t    if (app.name === appName) {\n\t      return app;\n\t    }\n\t  });\n", "  if (app?.length != 1) {\n\t    console.log(`0 or >1 Apps named ${appName} found. 😓`);\n\t    process.exit(1);\n\t  }\n\t  // Delete the app.\n\t  const spinner = ora(\"Deleting App\").start();\n\t  await postRequest(`${credentials.origin}/api/folders/deletePage`, {\n\t    pageId: app[0].id,\n\t  });\n\t  spinner.stop();\n", "  console.log(`Deleted ${appName} app. 🗑️`);\n\t}\n\texport async function getAppsAndFolders(\n\t  credentials: Credentials\n\t): Promise<{ apps?: Array<App>; folders?: Array<Folder> }> {\n\t  const spinner = ora(`Fetching all apps.`).start();\n\t  const fetchAppsResponse = await getRequest(\n\t    `${credentials.origin}/api/pages?mobileAppsOnly=false`\n\t  );\n\t  spinner.stop();\n", "  return {\n\t    apps: fetchAppsResponse?.data?.pages,\n\t    folders: fetchAppsResponse?.data?.folders,\n\t  };\n\t}\n\texport async function collectAppName(): Promise<string> {\n\t  const { appName } = await inquirer.prompt([\n\t    {\n\t      name: \"appName\",\n\t      message: \"App name?\",\n", "      type: \"input\",\n\t    },\n\t  ]);\n\t  if (appName.length === 0) {\n\t    console.log(\"Error: App name cannot be blank.\");\n\t    process.exit(1);\n\t  }\n\t  // Remove spaces from app name.\n\t  return appName.replace(/\\s/g, \"_\");\n\t}\n"]}
{"filename": "src/utils/playgroundQuery.ts", "chunked_list": ["import { Credentials } from \"./credentials\";\n\timport { postRequest } from \"./networking\";\n\texport type PlaygroundQuery = {\n\t  id: number;\n\t  uuid: string;\n\t  name: string;\n\t  description: string;\n\t  shared: boolean;\n\t  createdAt: string;\n\t  updatedAt: string;\n", "  organizationId: number;\n\t  ownerId: number;\n\t  saveId: number;\n\t  template: Record<string, any>;\n\t  resourceId: number;\n\t  resourceUuid: string;\n\t  adhocResourceType: string;\n\t};\n\texport async function createPlaygroundQuery(\n\t  resourceId: number,\n", "  credentials: Credentials,\n\t  queryName?: string\n\t): Promise<PlaygroundQuery> {\n\t  const createPlaygroundQueryResult = await postRequest(\n\t    `${credentials.origin}/api/playground`,\n\t    {\n\t      name: queryName || \"CLI Generated RPC Query\",\n\t      description: \"\",\n\t      shared: false,\n\t      resourceId,\n", "      data: {},\n\t    }\n\t  );\n\t  const { query } = createPlaygroundQueryResult.data;\n\t  if (!query?.uuid) {\n\t    console.log(\"Error creating playground query.\");\n\t    console.log(createPlaygroundQueryResult.data);\n\t    process.exit(1);\n\t  } else {\n\t    return query;\n", "  }\n\t}\n"]}
{"filename": "src/utils/workflows.ts", "chunked_list": ["import { Credentials } from \"./credentials\";\n\timport { deleteRequest, getRequest, postRequest } from \"./networking\";\n\tconst chalk = require(\"chalk\");\n\tconst inquirer = require(\"inquirer\");\n\tconst ora = require(\"ora\");\n\texport type Workflow = {\n\t  id: string; //UUID\n\t  name: string;\n\t  folderId: number;\n\t  isEnabled: boolean;\n", "  protected: boolean;\n\t  deployedBy: string;\n\t  lastDeployedAt: string;\n\t};\n\ttype WorkflowFolder = {\n\t  id: number;\n\t  name: string;\n\t  systemFolder: boolean;\n\t  parentFolderId: number;\n\t  createdAt: string;\n", "  updatedAt: string;\n\t  folderType: string;\n\t  accessLevel: string;\n\t};\n\texport async function getWorkflowsAndFolders(\n\t  credentials: Credentials\n\t): Promise<{ workflows?: Array<Workflow>; folders?: Array<WorkflowFolder> }> {\n\t  const spinner = ora(\"Fetching Workflows\").start();\n\t  const fetchWorkflowsResponse = await getRequest(\n\t    `${credentials.origin}/api/workflow`\n", "  );\n\t  spinner.stop();\n\t  return {\n\t    workflows: fetchWorkflowsResponse?.data?.workflowsMetadata,\n\t    folders: fetchWorkflowsResponse?.data?.workflowFolders,\n\t  };\n\t}\n\texport async function deleteWorkflow(\n\t  workflowName: string,\n\t  credentials: Credentials,\n", "  confirmDeletion: boolean\n\t) {\n\t  if (confirmDeletion) {\n\t    const { confirm } = await inquirer.prompt([\n\t      {\n\t        name: \"confirm\",\n\t        message: `Are you sure you want to delete ${workflowName}?`,\n\t        type: \"confirm\",\n\t      },\n\t    ]);\n", "    if (!confirm) {\n\t      process.exit(0);\n\t    }\n\t  }\n\t  // Verify that the provided workflowName exists.\n\t  const { workflows } = await getWorkflowsAndFolders(credentials);\n\t  const workflow = workflows?.filter((workflow) => {\n\t    if (workflow.name === workflowName) {\n\t      return workflow;\n\t    }\n", "  });\n\t  if (workflow?.length != 1) {\n\t    console.log(`0 or >1 Workflows named ${workflowName} found. 😓`);\n\t    process.exit(1);\n\t  }\n\t  // Delete the Workflow.\n\t  const spinner = ora(`Deleting ${workflowName}`).start();\n\t  await deleteRequest(`${credentials.origin}/api/workflow/${workflow[0].id}`);\n\t  spinner.stop();\n\t  console.log(`Deleted ${workflowName}. 🗑️`);\n", "}\n\t// Generates a CRUD workflow for tableName from a template.\n\texport async function generateCRUDWorkflow(\n\t  tableName: string,\n\t  credentials: Credentials\n\t) {\n\t  let spinner = ora(\"Creating workflow\").start();\n\t  // Generate workflow metadata via puppeteer.\n\t  // Dynamic import b/c puppeteer is slow.\n\t  const workflowMeta = await import(\"./puppeteer\").then(\n", "    async ({ generateWorkflowMetadata }) => {\n\t      return await generateWorkflowMetadata(tableName);\n\t    }\n\t  );\n\t  const payload = {\n\t    name: workflowMeta.name,\n\t    crontab: workflowMeta.crontab,\n\t    fromTemplate: true,\n\t    templateData: workflowMeta.templateData,\n\t    timezone: workflowMeta.timezone,\n", "    triggerWebhooks: workflowMeta.triggerWebhooks,\n\t    blockData: workflowMeta.blockData,\n\t  };\n\t  // Create workflow.\n\t  const workflow = await postRequest(`${credentials.origin}/api/workflow`, {\n\t    ...payload,\n\t  });\n\t  spinner.stop();\n\t  if (workflow.data.id) {\n\t    console.log(\"Successfully created a workflow. 🎉\");\n", "    console.log(\n\t      `${chalk.bold(\"View in browser:\")} ${credentials.origin}/workflows/${\n\t        workflow.data.id\n\t      }`\n\t    );\n\t  } else {\n\t    console.log(\"Error creating workflow: \");\n\t    console.log(workflow);\n\t    return;\n\t  }\n", "  // Enable workflow.\n\t  spinner = ora(\"Deploying workflow\").start();\n\t  await postRequest(`${credentials.origin}/api/workflow/${workflow.data.id}`, {\n\t    isEnabled: true,\n\t  });\n\t  spinner.stop();\n\t  console.log(\"Successfully deployed a workflow. 🚀\");\n\t  if (workflow.data.apiKey) {\n\t    const curlCommand = `curl -X POST --url \"https://api.retool.com/v1/workflows/${workflow.data.id}/startTrigger?workflowApiKey=${workflow.data.apiKey}\" --data '{\"type\":\"read\"}' -H 'Content-Type: application/json'`;\n\t    console.log(\n", "      `Retool Cloud users can ${chalk.bold(\"cURL it:\")} ${curlCommand}`\n\t    );\n\t  }\n\t}\n"]}
{"filename": "src/utils/validation.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\";\n\timport {\n\t  isAccessTokenValid,\n\t  isEmailValid,\n\t  isOriginValid,\n\t  isXsrfValid,\n\t} from \"./validation\";\n\tdescribe(\"isEmailValid\", () => {\n\t  test(\"should return true for valid email\", () => {\n\t    expect(isEmailValid(\"hacker@retool.com\")).toBe(true);\n", "  });\n\t  test(\"should return false for missing @\", () => {\n\t    expect(isEmailValid(\"hackerretool.com\")).toBe(false);\n\t  });\n\t  test(\"should return false for missing user name\", () => {\n\t    expect(isEmailValid(\"@retool.com\")).toBe(false);\n\t  });\n\t  test(\"should return false for missing domain name\", () => {\n\t    expect(isEmailValid(\"hacker@com\")).toBe(false);\n\t  });\n", "  test(\"should return false for missing domain\", () => {\n\t    expect(isEmailValid(\"hacker@retool\")).toBe(false);\n\t  });\n\t});\n\tdescribe(\"isAccessTokenValid\", () => {\n\t  test(\"should return true for valid access token\", () => {\n\t    expect(\n\t      isAccessTokenValid(\n\t        \"eyJhbGciOiJIUzOOPiIsInR5cCI6IkpXVCJ9.eyJ4c3JmVG9rZW4iOiJjYzRjNmM3MC0wN2ZmLTQzNzktODI5ZS0wZDgyOWE1YjRiZTQiLCJ2ZXJzaW9uIjoiMS4yIiwiaWF0IjoxNjkwODIxMDUxfQ.-BjHNN9N9fDteokZmoIjdL0CbcZnkYKVCYwuzYugTzQ\"\n\t      )\n", "    ).toBe(true);\n\t  });\n\t  test(\"should return false for invalid access token\", () => {\n\t    expect(isAccessTokenValid(\"asdasdasd\")).toBe(false);\n\t  });\n\t});\n\tdescribe(\"isOriginValid\", () => {\n\t  test(\"should return true for valid https origin\", () => {\n\t    expect(isOriginValid(\"https://subdomain.retool.com\")).toBe(true);\n\t  });\n", "  test(\"should return true for valid http origin\", () => {\n\t    expect(isOriginValid(\"http://subdomain.retool.com\")).toBe(true);\n\t  });\n\t  test(\"should return false for missing http://\", () => {\n\t    expect(isOriginValid(\"hacker.retool.com\")).toBe(false);\n\t  });\n\t  test(\"should return false for ending with /\", () => {\n\t    expect(isOriginValid(\"http://hacker.retool.com/\")).toBe(false);\n\t  });\n\t});\n", "describe(\"isXsrfValid\", () => {\n\t  test(\"should return true for valid xsrf\", () => {\n\t    expect(isXsrfValid(\"cc4c6c70-07ff-4379-829e-0d829a5b4be4\")).toBe(true);\n\t  });\n\t  test(\"should return false for invalid xsrf\", () => {\n\t    expect(isXsrfValid(\"asdasdasd\")).toBe(false);\n\t  });\n\t});\n"]}
{"filename": "src/utils/table.ts", "chunked_list": ["import chalk from \"chalk\";\n\timport ora from \"ora\";\n\timport untildify from \"untildify\";\n\timport { logConnectionStringDetails } from \"./connectionString\";\n\timport { Credentials } from \"./credentials\";\n\timport { getRequest, postRequest } from \"./networking\";\n\timport { parseCSV } from \"../utils/csv\";\n\tconst fs = require(\"fs\");\n\tconst path = require(\"path\");\n\tconst inquirer = require(\"inquirer\");\n", "type Table = {\n\t  name: string;\n\t};\n\ttype FieldMapping = Array<{\n\t  csvField: string;\n\t  dbField: string | undefined;\n\t  ignored: boolean;\n\t  dbType?: string;\n\t}>;\n\texport type DBInfoPayload = {\n", "  success: true;\n\t  tableInfo: RetoolDBTableInfo;\n\t};\n\t// This type is returned from Retool table/info API endpoint.\n\texport type RetoolDBTableInfo = {\n\t  fields: Array<RetoolDBField>;\n\t  primaryKeyColumn: string;\n\t  totalRowCount: number;\n\t};\n\t// A \"field\" is a single Retool DB column.\n", "export type RetoolDBField = {\n\t  name: string;\n\t  type: any; //GridFieldType\n\t  columnDefault:\n\t    | {\n\t        kind: \"NoDefault\";\n\t      }\n\t    | {\n\t        kind: \"LiteralDefault\";\n\t        value: string;\n", "      }\n\t    | {\n\t        kind: \"ExpressionDefault\";\n\t        value: string;\n\t      };\n\t  generatedColumnType: string | undefined;\n\t};\n\t// Verify that the table exists in Retool DB, otherwise exit.\n\texport async function verifyTableExists(\n\t  tableName: string,\n", "  credentials: Credentials\n\t) {\n\t  const tables = await fetchAllTables(credentials);\n\t  if (!tables?.map((table) => table.name).includes(tableName)) {\n\t    console.log(`No table named ${tableName} found in Retool DB. 😓`);\n\t    console.log(`Use \\`retool db --list\\` to list all tables.`);\n\t    console.log(`Use \\`retool db --create\\` to create a new table.`);\n\t    process.exit(1);\n\t  }\n\t}\n", "// Fetches all existing tables from a Retool DB.\n\texport async function fetchAllTables(\n\t  credentials: Credentials\n\t): Promise<Array<Table> | undefined> {\n\t  const spinner = ora(\"Fetching tables from Retool DB\").start();\n\t  const fetchDBsResponse = await getRequest(\n\t    `${credentials.origin}/api/grid/retooldb/${credentials.retoolDBUuid}?env=production`\n\t  );\n\t  spinner.stop();\n\t  if (fetchDBsResponse.data) {\n", "    const { tables } = fetchDBsResponse.data.gridInfo;\n\t    return tables;\n\t  }\n\t}\n\t// Fetches the schema of a table from a Retool DB. Assumes the table exists.\n\texport async function fetchTableInfo(\n\t  tableName: string,\n\t  credentials: Credentials\n\t): Promise<RetoolDBTableInfo | undefined> {\n\t  const spinner = ora(`Fetching ${tableName} metadata`).start();\n", "  const infoResponse = await getRequest(\n\t    `${credentials.origin}/api/grid/${credentials.gridId}/table/${tableName}/info`\n\t  );\n\t  spinner.stop();\n\t  const { tableInfo } = infoResponse.data;\n\t  if (tableInfo) {\n\t    return tableInfo;\n\t  }\n\t}\n\texport async function deleteTable(\n", "  tableName: string,\n\t  credentials: Credentials,\n\t  confirmDeletion: boolean\n\t) {\n\t  // Verify that the provided table name exists.\n\t  await verifyTableExists(tableName, credentials);\n\t  if (confirmDeletion) {\n\t    const { confirm } = await inquirer.prompt([\n\t      {\n\t        name: \"confirm\",\n", "        message: `Are you sure you want to delete the ${tableName} table?`,\n\t        type: \"confirm\",\n\t      },\n\t    ]);\n\t    if (!confirm) {\n\t      process.exit(0);\n\t    }\n\t  }\n\t  // Delete the table.\n\t  const spinner = ora(`Deleting ${tableName}`).start();\n", "  await postRequest(\n\t    `${credentials.origin}/api/grid/${credentials.gridId}/action`,\n\t    {\n\t      kind: \"DeleteTable\",\n\t      payload: {\n\t        table: tableName,\n\t      },\n\t    }\n\t  );\n\t  spinner.stop();\n", "  console.log(`Deleted ${tableName} table. 🗑️`);\n\t}\n\texport async function createTable(\n\t  tableName: string,\n\t  headers: string[],\n\t  rows: string[][] | undefined,\n\t  credentials: Credentials,\n\t  printConnectionString: boolean\n\t) {\n\t  const spinner = ora(\"Uploading Table\").start();\n", "  const fieldMapping: FieldMapping = headers.map((header) => ({\n\t    csvField: header,\n\t    dbField: header,\n\t    ignored: false,\n\t  }));\n\t  // See NewTable.tsx if implementing more complex logic.\n\t  const payload = {\n\t    kind: \"CreateTable\",\n\t    payload: {\n\t      name: tableName,\n", "      fieldMapping,\n\t      data: rows,\n\t      allowSchemaEditOverride: true,\n\t      primaryKey: {\n\t        kind: headers.includes(\"id\") ? \"CustomColumn\" : \"IntegerAutoIncrement\",\n\t        name: \"id\",\n\t      },\n\t    },\n\t  };\n\t  const createTableResult = await postRequest(\n", "    `${credentials.origin}/api/grid/${credentials.gridId}/action`,\n\t    {\n\t      ...payload,\n\t    }\n\t  );\n\t  spinner.stop();\n\t  if (!createTableResult.data.success) {\n\t    console.log(\"Error creating table in RetoolDB.\");\n\t    console.log(createTableResult.data);\n\t    process.exit(1);\n", "  } else {\n\t    console.log(\n\t      `Successfully created a table named ${tableName} in RetoolDB. 🎉`\n\t    );\n\t    if (printConnectionString) {\n\t      console.log(\"\");\n\t    }\n\t    console.log(\n\t      `${chalk.bold(\"View in browser:\")} ${credentials.origin}/resources/data/${\n\t        credentials.retoolDBUuid\n", "      }/${tableName}?env=production`\n\t    );\n\t    if (credentials.hasConnectionString && printConnectionString) {\n\t      await logConnectionStringDetails();\n\t    }\n\t  }\n\t}\n\texport async function createTableFromCSV(\n\t  csvFilePath: string,\n\t  credentials: Credentials,\n", "  printConnectionString: boolean,\n\t  promptForTableName: boolean\n\t): Promise<{\n\t  tableName: string;\n\t  colNames: string[];\n\t}> {\n\t  const filePath = untildify(csvFilePath);\n\t  // Verify file exists, is a csv, and is < 18MB.\n\t  if (\n\t    !fs.existsSync(filePath) ||\n", "    !filePath.endsWith(\".csv\") ||\n\t    fs.statSync(filePath).size > 18000000\n\t  ) {\n\t    console.log(\"The file does not exist, is not a CSV, or is > 18MB.\");\n\t    process.exit(1);\n\t  }\n\t  //Default to csv filename if no table name is provided.\n\t  let tableName = path.basename(filePath).slice(0, -4);\n\t  if (promptForTableName) {\n\t    const { inputName } = await inquirer.prompt([\n", "      {\n\t        name: \"inputName\",\n\t        message: \"Table name? If blank, defaults to CSV filename.\",\n\t        type: \"input\",\n\t      },\n\t    ]);\n\t    if (inputName.length > 0) {\n\t      tableName = inputName;\n\t    }\n\t  }\n", "  // Remove spaces from table name.\n\t  tableName = tableName.replace(/\\s/g, \"_\");\n\t  const spinner = ora(\"Parsing CSV\").start();\n\t  const parseResult = await parseCSV(filePath);\n\t  spinner.stop();\n\t  if (!parseResult.success) {\n\t    console.log(\"Failed to parse CSV, error:\");\n\t    console.error(parseResult.error);\n\t    process.exit(1);\n\t  }\n", "  const { headers, rows } = parseResult;\n\t  await createTable(\n\t    tableName,\n\t    headers,\n\t    rows,\n\t    credentials,\n\t    printConnectionString\n\t  );\n\t  return {\n\t    tableName,\n", "    colNames: headers,\n\t  };\n\t}\n\t// data param is in format:\n\t// [\"col_1\",\"col_2\",\"col_3\"]\n\t// [\"val_1\",\"val_2\",\"val_3\"]\n\t// transform to:\n\t// [[\"col_1\",\"col_2\",\"col_3\"],[\"val_1\",\"val_2\",\"val_3\"]]\n\texport function parseDBData(data: string): string[][] {\n\t  try {\n", "    const rows = data.trim().split(\"\\n\");\n\t    rows.forEach(\n\t      (row, index, arr) => (arr[index] = row.slice(1, -1)) // Remove [] brackets.\n\t    );\n\t    const parsedRows: string[][] = [];\n\t    for (let i = 0; i < rows.length; i++) {\n\t      const row = rows[i].split(\",\");\n\t      row.forEach(\n\t        (val, index, arr) => (arr[index] = val.slice(1, -1)) // Remove \"\".\n\t      );\n", "      parsedRows.push(row);\n\t    }\n\t    return parsedRows;\n\t  } catch (e) {\n\t    console.log(\"Error parsing table data.\");\n\t    console.log(e);\n\t    process.exit(1);\n\t  }\n\t}\n\texport async function generateDataWithGPT(\n", "  retoolDBInfo: DBInfoPayload,\n\t  fields: RetoolDBField[],\n\t  primaryKeyMaxVal: number,\n\t  credentials: Credentials,\n\t  exitOnFailure: boolean\n\t): Promise<\n\t  | {\n\t      fields: string[];\n\t      data: string[][];\n\t    }\n", "  | undefined\n\t> {\n\t  const genDataRes: {\n\t    data: {\n\t      data: string[][];\n\t    };\n\t  } = await postRequest(\n\t    `${credentials.origin}/api/grid/retooldb/generateData`,\n\t    {\n\t      fields: retoolDBInfo.tableInfo.fields.map((field) => {\n", "        return {\n\t          fieldName: field.name,\n\t          fieldType: field.type,\n\t          isPrimaryKey: field.name === retoolDBInfo.tableInfo.primaryKeyColumn,\n\t        };\n\t      }),\n\t    },\n\t    exitOnFailure\n\t  );\n\t  const colNames = fields.map((field) => field.name);\n", "  const generatedRows: string[][] = [];\n\t  if (!genDataRes || colNames.length !== genDataRes?.data?.data[0]?.length) {\n\t    if (exitOnFailure) {\n\t      console.log(\"Error: GPT did not generate data with correct schema.\");\n\t      process.exit(1);\n\t    } else {\n\t      return;\n\t    }\n\t  }\n\t  // GPT does not generate primary keys correctly.\n", "  // Generate them manually by adding the max primary key value to row #.\n\t  for (let i = 0; i < genDataRes.data.data.length; i++) {\n\t    const row = genDataRes.data.data[i];\n\t    for (let j = 0; j < row.length; j++) {\n\t      if (colNames[j] === retoolDBInfo.tableInfo.primaryKeyColumn) {\n\t        row[j] = (primaryKeyMaxVal + i + 1).toString();\n\t      }\n\t    }\n\t    generatedRows.push(row);\n\t  }\n", "  return {\n\t    fields: colNames,\n\t    data: generatedRows,\n\t  };\n\t}\n\texport async function collectTableName(): Promise<string> {\n\t  const { tableName } = await inquirer.prompt([\n\t    {\n\t      name: \"tableName\",\n\t      message: \"Table name?\",\n", "      type: \"input\",\n\t    },\n\t  ]);\n\t  if (tableName.length === 0) {\n\t    console.log(\"Error: Table name cannot be blank.\");\n\t    process.exit(1);\n\t  }\n\t  // Remove spaces from table name.\n\t  return tableName.replace(/\\s/g, \"_\");\n\t}\n", "export async function collectColumnNames(): Promise<string[]> {\n\t  const columnNames: string[] = [];\n\t  let columnName = await collectColumnName();\n\t  while (columnName.length > 0) {\n\t    columnNames.push(columnName);\n\t    columnName = await collectColumnName();\n\t  }\n\t  return columnNames;\n\t}\n\tasync function collectColumnName(): Promise<string> {\n", "  const { columnName } = await inquirer.prompt([\n\t    {\n\t      name: \"columnName\",\n\t      message: \"Column name? Leave blank to finish.\",\n\t      type: \"input\",\n\t    },\n\t  ]);\n\t  // Remove spaces from column name.\n\t  return columnName.replace(/\\s/g, \"_\");\n\t}\n"]}
{"filename": "src/utils/csv.ts", "chunked_list": ["const fs = require(\"fs\");\n\tconst csvParser = require(\"csv-parser\");\n\texport type ParseResult =\n\t  | {\n\t      success: true;\n\t      headers: string[];\n\t      rows: string[][];\n\t    }\n\t  | { success: false; error: string };\n\texport async function parseCSV(csvFile: string): Promise<ParseResult> {\n", "  return new Promise<ParseResult>((resolve) => {\n\t    const rows: string[][] = [];\n\t    let headers: string[] = [];\n\t    let firstRow = true;\n\t    fs.createReadStream(csvFile)\n\t      .pipe(\n\t        csvParser({\n\t          skipEmptyLines: true, // Doesn't seem to work\n\t        })\n\t      )\n", "      .on(\"error\", (error: Error) => {\n\t        resolve({ success: false, error: error.message });\n\t      })\n\t      .on(\"data\", (row: any) => {\n\t        if (Object.keys(row).length > 0) {\n\t          if (firstRow) {\n\t            headers = Object.keys(row);\n\t            firstRow = false;\n\t          }\n\t          rows.push(Object.values(row));\n", "        }\n\t      })\n\t      .on(\"end\", () => {\n\t        resolve({ success: true, headers, rows });\n\t      });\n\t  });\n\t}\n"]}
{"filename": "src/utils/cookies.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\";\n\timport { accessTokenFromCookies, xsrfTokenFromCookies } from \"./cookies\";\n\tconst cookies = [\n\t    \"accessToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVPL8.eyJ4c3JmVG9rZW4iOiI0NWQ1ZmQ0MC00ODI5LTQ0ZmYtOWViYy1mYzk0ZGE1ZDkzN2MiLCJ2ZXJzaW9uIjoiMS4yIiwiaWF0IjoxNjkwOTEwODcwfQ.rjtgus6ml0D3wNG7QRZvSEtU0BDU5bGlJZvPc-PU-o0; Max-Age=604800; Path=/; Expires=Tue, 08 Aug 2023 17:27:50 GMT; HttpOnly; Secure; SameSite=None\",\n\t    \"xsrfToken=45d5fd40-4829-44ff-9ebc-fc94da5d654w; Max-Age=604800; Path=/; Expires=Tue, 08 Aug 2023 17:27:50 GMT; Secure; SameSite=None\",\n\t    \"xsrfTokenSameSite=45d5fd40-4829-44ff-9ebc-fc94da5d654w; Max-Age=604800; Path=/; Expires=Tue, 08 Aug 2023 17:27:50 GMT; HttpOnly; Secure; SameSite=Strict\",\n\t]\n\tdescribe(\"accessTokenFromCookies\", () => {\n\t    test(\"should return cookie from valid response\", () => {\n\t      expect(accessTokenFromCookies(cookies)).toBe(\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVPL8.eyJ4c3JmVG9rZW4iOiI0NWQ1ZmQ0MC00ODI5LTQ0ZmYtOWViYy1mYzk0ZGE1ZDkzN2MiLCJ2ZXJzaW9uIjoiMS4yIiwiaWF0IjoxNjkwOTEwODcwfQ.rjtgus6ml0D3wNG7QRZvSEtU0BDU5bGlJZvPc-PU-o0\");\n", "    });\n\t    test(\"should return undefined from invalid response\", () => {\n\t        expect(accessTokenFromCookies([])).toBe(undefined);\n\t    });\n\t});\n\tdescribe (\"xsrfTokenFromCookies\", () => {\n\t    test(\"should return cookie from valid response\", () => {\n\t        expect(xsrfTokenFromCookies(cookies)).toBe(\"45d5fd40-4829-44ff-9ebc-fc94da5d654w\");\n\t    });\n\t    test(\"should return undefined from invalid response\", () => {\n", "        expect(xsrfTokenFromCookies([])).toBe(undefined);\n\t    });\n\t});\n"]}
{"filename": "src/utils/fileSave.ts", "chunked_list": ["import * as fs from \"fs\";\n\timport * as path from \"path\";\n\timport * as tar from \"tar\";\n\tconst axios = require(\"axios\");\n\tconst inquirer = require(\"inquirer\");\n\t// url should be a tarfile link like https://api.github.com/repos/tryretool/retool-examples/tarball/main\n\t// subfolderPath should be a path to a subfolder within the tarfile, e.g. hello_world/typescript\n\t// destinationPath should be a path to a folder where the contents of the github subfolder will be extracted\n\texport async function downloadGithubSubfolder(\n\t  githubUrl: string,\n", "  subfolderPath: string,\n\t  destinationPath: string\n\t) {\n\t  try {\n\t    const url = `${githubUrl}?path=${subfolderPath}`;\n\t    const response = await axios.get(url, { responseType: \"arraybuffer\" });\n\t    // Delete the directory if it already exists\n\t    if (fs.existsSync(destinationPath)) {\n\t      const { proceedWithDirectoryCreation } = (await inquirer.prompt([\n\t        {\n", "          name: \"proceedWithDirectoryCreation\",\n\t          message:\n\t            \"It looks like this directory already exists, can we delete it and continue? (Y/N)\",\n\t          type: \"input\",\n\t        },\n\t      ])) as { proceedWithDirectoryCreation: string };\n\t      if (proceedWithDirectoryCreation.toLowerCase() !== \"y\") {\n\t        console.log(\"Aborting...\");\n\t        process.exit(1);\n\t      }\n", "      await fs.promises.rm(destinationPath, { recursive: true });\n\t    }\n\t    fs.mkdirSync(destinationPath, { recursive: true });\n\t    const tarballPath = path.join(destinationPath, \"tarball.tar.gz\");\n\t    fs.writeFileSync(tarballPath, response.data);\n\t    await tar.x({\n\t      file: tarballPath,\n\t      cwd: destinationPath,\n\t      strip: subfolderPath.split(\"/\").length + 1, // remove the top-level directories\n\t    });\n", "    fs.unlinkSync(tarballPath);\n\t  } catch (error: any) {\n\t    console.error(\"Error:\", error.message);\n\t  }\n\t}\n\texport function saveEnvVariablesToFile(\n\t  envVariables: Record<string, string>,\n\t  filePath: string\n\t) {\n\t  try {\n", "    const envContent = Object.entries(envVariables)\n\t      .map(([key, value]) => `${key}=${value}`)\n\t      .join(\"\\n\");\n\t    fs.writeFileSync(filePath, envContent);\n\t  } catch (error: any) {\n\t    console.error(\"Error saving environment variables:\", error.message);\n\t  }\n\t}\n"]}
{"filename": "src/utils/telemetry.ts", "chunked_list": ["import { Credentials, getCredentials, persistCredentials } from \"./credentials\";\n\timport { postRequest } from \"./networking\";\n\t// @ts-ignore\n\timport { version } from \"../../package.json\";\n\texport async function logDAU(\n\t  credentials?: Credentials,\n\t  persistCreds = true\n\t): Promise<boolean> {\n\t  credentials = credentials || getCredentials();\n\t  const twelveHours = 12 * 60 * 60 * 1000;\n", "  // Don't send telemetry if user has opted out or if we've already sent telemetry in the last 12 hours.\n\t  if (\n\t    !credentials ||\n\t    credentials.telemetryEnabled !== true ||\n\t    (credentials.telemetryLastSent &&\n\t      Date.now() - credentials.telemetryLastSent < twelveHours)\n\t  ) {\n\t    return false;\n\t  }\n\t  const payload = {\n", "    \"CLI Version\": version,\n\t    email: credentials.email,\n\t    origin: credentials.origin,\n\t    os: process.platform,\n\t  };\n\t  // Send a POST request to Retool's telemetry endpoint.\n\t  const res = await postRequest(`https://p.retool.com/v2/p`, {\n\t    event: \"CLI DAU\",\n\t    properties: payload,\n\t  });\n", "  if (res.status === 200) {\n\t    // Update the last time we sent telemetry.\n\t    credentials.telemetryLastSent = Date.now();\n\t    if (persistCreds) {\n\t      persistCredentials(credentials);\n\t    }\n\t    return true;\n\t  }\n\t  return false;\n\t}\n"]}
{"filename": "src/utils/validation.ts", "chunked_list": ["/* eslint-disable */\n\tconst emailRegex =\n\t  /^[-!#$%&'*+\\/0-9=?A-Z^_a-z{|}~](\\.?[-!#$%&'*+\\/0-9=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-*\\.?[a-zA-Z0-9])*\\.[a-zA-Z](-?[a-zA-Z0-9])+$/;\n\t/* eslint-enable */\n\t//https://stackoverflow.com/questions/52456065/how-to-format-and-validate-email-node-js\n\texport function isEmailValid(email: string) {\n\t  if (!email) return false;\n\t  if (email.length > 254) return false;\n\t  if (!emailRegex.test(email)) return false;\n\t  // Further checking of some things regex can't handle\n", "  const parts = email.split(\"@\");\n\t  if (parts[0].length > 64) return false;\n\t  const domainParts = parts[1].split(\".\");\n\t  if (\n\t    domainParts.some(function (part) {\n\t      return part.length > 63;\n\t    })\n\t  )\n\t    return false;\n\t  return true;\n", "}\n\texport function isOriginValid(origin: string) {\n\t  // https://www.regextester.com/23\n\t  const hostnameRegEx =\n\t    /^(https?:\\/\\/)(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n\t  if (origin.match(hostnameRegEx)) {\n\t    return true;\n\t  }\n\t  return false;\n\t}\n", "export function isXsrfValid(xsrf: string) {\n\t  // https://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid\n\t  const uuidRegEx =\n\t    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/;\n\t  if (xsrf.match(uuidRegEx)) {\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\texport function isAccessTokenValid(accessToken: string) {\n", "  // https://stackoverflow.com/questions/61802832/regex-to-match-jwt\n\t  const jwtRegEx = /^[\\w-]+\\.[\\w-]+\\.[\\w-]+$/;\n\t  if (accessToken.match(jwtRegEx)) {\n\t    return true;\n\t  }\n\t  return false;\n\t}\n"]}
{"filename": "src/utils/telemetry.test.ts", "chunked_list": ["import { describe, expect, jest, test } from \"@jest/globals\";\n\timport axios from \"axios\";\n\timport { logDAU } from \"./telemetry\";\n\tjest.mock(\"axios\");\n\tdescribe(\"telemetry\", () => {\n\t  test(\"should not log anything if telemetryEnabled is false \", async () => {\n\t    const creds = {\n\t      origin: \"\",\n\t      xsrf: \"\",\n\t      accessToken: \"\",\n", "      telemetryEnabled: false,\n\t    };\n\t    expect(await logDAU(creds, false)).toBe(false);\n\t  });\n\t  test(\"should not log anything if telemetry was sent 1 minute ago \", async () => {\n\t    const creds = {\n\t      origin: \"\",\n\t      xsrf: \"\",\n\t      accessToken: \"\",\n\t      telemetryEnabled: true,\n", "      telemetryLastSent: Date.now() - 60 * 1000,\n\t    };\n\t    expect(await logDAU(creds, false)).toBe(false);\n\t  });\n\t  test(\"should not log anything if telemetry was sent 11 hours ago \", async () => {\n\t    const creds = {\n\t      origin: \"\",\n\t      xsrf: \"\",\n\t      accessToken: \"\",\n\t      telemetryEnabled: true,\n", "      telemetryLastSent: Date.now() - 11 * 60 * 60 * 1000,\n\t    };\n\t    expect(await logDAU(creds, false)).toBe(false);\n\t  });\n\t  test(\"should log telemetry if telemetryEnabled is true and telemetryLastSent is undefined\", async () => {\n\t    const creds = {\n\t      origin: \"\",\n\t      xsrf: \"\",\n\t      accessToken: \"\",\n\t      telemetryEnabled: true,\n", "    };\n\t    // @ts-ignore\n\t    axios.post = jest.fn().mockReturnValue({ status: 200 });\n\t    expect(await logDAU(creds, false)).toBe(true);\n\t  });\n\t  test(\"should log telemetry if telemetryEnabled is true and telemetryLastSent is more than 12 hours ago\", async () => {\n\t    const creds = {\n\t      origin: \"\",\n\t      xsrf: \"\",\n\t      accessToken: \"\",\n", "      telemetryEnabled: true,\n\t      telemetryLastSent: Date.now() - 13 * 60 * 60 * 1000,\n\t    };\n\t    // @ts-ignore\n\t    axios.post = jest.fn().mockReturnValue({ status: 200 });\n\t    expect(await logDAU(creds, false)).toBe(true);\n\t  });\n\t});\n"]}
{"filename": "src/utils/date.ts", "chunked_list": ["import type { DateTimeFormatOptions } from \"intl\";\n\t// 07/19/2023, 09:07:58 PM\n\texport const dateOptions: DateTimeFormatOptions = {\n\t  month: \"2-digit\",\n\t  day: \"2-digit\",\n\t  year: \"numeric\",\n\t  hour: \"2-digit\",\n\t  minute: \"2-digit\",\n\t};\n"]}
{"filename": "src/utils/resources.ts", "chunked_list": ["import { Credentials } from \"./credentials\";\n\timport { getRequest, postRequest } from \"./networking\";\n\texport type ResourceByEnv = Record<string, Resource>;\n\texport type Resource = {\n\t  displayName: string;\n\t  id: number;\n\t  name: string;\n\t  type: string;\n\t  environment: string;\n\t  environmentId: string;\n", "  uuid: string;\n\t  organizationId: number;\n\t  resourceFolderId: number;\n\t};\n\texport async function getResourceByName(\n\t  resourceName: string,\n\t  credentials: Credentials\n\t): Promise<ResourceByEnv> {\n\t  const getResourceResult = await getRequest(\n\t    `${credentials.origin}/api/resources/names/${resourceName}`\n", "  );\n\t  const { resourceByEnv } = getResourceResult.data;\n\t  if (!resourceByEnv) {\n\t    console.log(\"Error finding resource by that id.\");\n\t    console.log(getResourceResult.data);\n\t    process.exit(1);\n\t  } else {\n\t    return resourceByEnv;\n\t  }\n\t}\n", "export async function createResource({\n\t  resourceType,\n\t  credentials,\n\t  displayName,\n\t  resourceFolderId,\n\t  resourceOptions,\n\t}: {\n\t  resourceType: string;\n\t  credentials: Credentials;\n\t  displayName?: string;\n", "  resourceFolderId?: number;\n\t  resourceOptions?: Record<string, any>;\n\t}): Promise<Resource> {\n\t  const createResourceResult = await postRequest(\n\t    `${credentials.origin}/api/resources/`,\n\t    {\n\t      type: resourceType,\n\t      displayName,\n\t      resourceFolderId,\n\t      options: resourceOptions ? resourceOptions : {},\n", "    },\n\t    false,\n\t    {},\n\t    false\n\t  );\n\t  const resource = createResourceResult.data;\n\t  if (!resource) {\n\t    throw new Error(\"Error creating resource.\");\n\t  } else {\n\t    return resource;\n", "  }\n\t}\n"]}
{"filename": "src/utils/networking.ts", "chunked_list": ["const axios = require(\"axios\");\n\t// Convenience function for making network requests. Error handling is centralized here.\n\t// If nothing is returned, the request failed and the process may exit.\n\texport async function postRequest(\n\t  url: string,\n\t  body: any,\n\t  exitOnFailure = true,\n\t  headers = {},\n\t  shouldHandleError = true\n\t) {\n", "  if (!shouldHandleError) {\n\t    return await axios.post(\n\t      url,\n\t      {\n\t        ...body,\n\t      },\n\t      {\n\t        headers: {\n\t          ...headers,\n\t        },\n", "      }\n\t    );\n\t  } else {\n\t    try {\n\t      const response = await axios.post(\n\t        url,\n\t        {\n\t          ...body,\n\t        },\n\t        {\n", "          headers: {\n\t            ...headers,\n\t          },\n\t        }\n\t      );\n\t      return response;\n\t    } catch (error: any) {\n\t      handleError(error, exitOnFailure, url);\n\t    }\n\t  }\n", "}\n\texport async function getRequest(url: string, exitOnFailure = true) {\n\t  try {\n\t    const response = await axios.get(url);\n\t    return response;\n\t  } catch (error: any) {\n\t    handleError(error, exitOnFailure, url);\n\t  }\n\t}\n\texport async function deleteRequest(url: string, exitOnFailure = true) {\n", "  try {\n\t    const response = await axios.delete(url);\n\t    return response;\n\t  } catch (error: any) {\n\t    handleError(error, exitOnFailure, url);\n\t  }\n\t}\n\tfunction handleError(error: any, exitOnFailure = true, url: string) {\n\t  if (error.response) {\n\t    // The request was made, but the server responded with a status code outside the 2xx range\n", "    console.error(\"\\n\\nHTTP Request Error:\", error.response.data);\n\t  } else {\n\t    console.error(\"\\n\\nNetwork error:\", error.toJSON());\n\t  }\n\t  if (process.env.DEBUG) {\n\t    console.error(error);\n\t  }\n\t  console.error(`\\nFailed to make request to ${url}.`);\n\t  if (exitOnFailure) {\n\t    process.exit(1);\n", "  }\n\t}\n"]}
{"filename": "src/utils/connectionString.ts", "chunked_list": ["import { ConnectionStringParser } from \"connection-string-parser\";\n\timport { getCredentials } from \"./credentials\";\n\timport { getRequest } from \"./networking\";\n\tconst chalk = require(\"chalk\");\n\t// Print a psql command to connect to the Retool DB.\n\t// Connnection string is never persisted, it's fetched when needed.\n\t// This is done to avoid storing the password in plaintext.\n\texport async function logConnectionStringDetails() {\n\t  const connectionString = await getConnectionString();\n\t  if (connectionString) {\n", "    const parsed = new ConnectionStringParser({\n\t      scheme: \"postgresql\",\n\t      hosts: [],\n\t    }).parse(connectionString);\n\t    console.log(\n\t      `${chalk.bold(\"Connect via psql:\")} PGPASSWORD=${\n\t        parsed.password\n\t      } psql -h ${parsed.hosts[0].host} -U ${parsed.username} ${\n\t        parsed.endpoint\n\t      }`\n", "    );\n\t    console.log(\n\t      `${chalk.bold(\"Postgres Connection URL:\")} ${connectionString}`\n\t    );\n\t  }\n\t}\n\tasync function getConnectionString(): Promise<string | undefined> {\n\t  const credentials = getCredentials();\n\t  if (\n\t    !credentials ||\n", "    !credentials.retoolDBUuid ||\n\t    !credentials.hasConnectionString\n\t  ) {\n\t    return;\n\t  }\n\t  const grid = await getRequest(\n\t    `${credentials.origin}/api/grid/retooldb/${credentials.retoolDBUuid}?env=production`,\n\t    false\n\t  );\n\t  return grid.data?.gridInfo?.connectionString;\n", "}\n"]}
{"filename": "src/resources/workflowTemplate.ts", "chunked_list": ["export type WorkflowTemplateType = typeof workflowTemplate;\n\texport const workflowTemplate = [\n\t  {\n\t    block: {\n\t      pluginId: \"startTrigger\",\n\t      incomingOnSuccessPlugins: [],\n\t      comment: {\n\t        body: 'This workflow supports performing CRUD operations on a Retool DB instance. Example valid JSON inputs:\\n\\n{\\n type: \"create\",\\n data:{ col1: \"val1\", col2: \"val2\"}\\n}\\n\\n{\\n type: \"read\"\\n}\\n\\n{\\n type: \"update\",\\n row: id,\\n data:{ col1: \"val1\", col2: \"val2\"}\\n}\\n\\n{\\n type: \"destroy\",\\n row: id\\n}',\n\t        visible: true,\n\t        pluginId: \"startTrigger-comment\",\n", "      },\n\t      top: 0,\n\t      left: -432,\n\t      environment: \"production\",\n\t      editorType: \"JavascriptQuery\",\n\t      resourceName: \"webhook\",\n\t      blockType: \"webhook\",\n\t    },\n\t    pluginTemplate: {\n\t      id: \"startTrigger\",\n", "      type: \"datasource\",\n\t      subtype: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      template: {\n\t        queryRefreshTime: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n", "        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n\t        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query: 'return {\\n type: \"read\"\\n}',\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n", "        error: null,\n\t        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        data: null,\n\t        importedQueryInputs: {},\n\t        _additionalScope: [],\n\t        isImported: false,\n\t        showSuccessToaster: true,\n\t        cacheKeyTtl: \"\",\n", "        requestSentTimestamp: null,\n\t        metadata: null,\n\t        workflowActionType: null,\n\t        queryRunTime: null,\n\t        changesetObject: \"\",\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n\t        finished: null,\n\t        confirmationMessage: null,\n\t        isFetching: false,\n", "        changeset: \"\",\n\t        rawData: null,\n\t        queryTriggerDelay: \"0\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n", "        showUpdateSetValueDynamicallyToggle: true,\n\t        runWhenPageLoads: false,\n\t        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        queryTimeout: \"10000\",\n\t        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: false,\n", "        enableCaching: false,\n\t        allowedGroups: [],\n\t        workflowBlockPluginId: null,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n\t      },\n\t    },\n\t  },\n", "  {\n\t    block: {\n\t      pluginId: \"createQuery\",\n\t      incomingOnSuccessPlugins: [],\n\t      top: -640,\n\t      left: 1040,\n\t      environment: \"production\",\n\t      editorType: \"SqlQueryUnified\",\n\t      resourceName: \"\",\n\t      blockType: \"default\",\n", "      incomingPortsPlugins: [\n\t        {\n\t          blockPluginId: \"switchType\",\n\t          portId: \"a620f4c4-57db-4732-9176-934bcf9b94a8\",\n\t        },\n\t      ],\n\t    },\n\t    pluginTemplate: {\n\t      id: \"createQuery\",\n\t      type: \"datasource\",\n", "      subtype: \"SqlQueryUnified\",\n\t      resourceName: null,\n\t      template: {\n\t        queryRefreshTime: \"\",\n\t        records: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        databasePasswordOverride: \"\",\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n", "        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n\t        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query: \"\",\n\t        playgroundQueryUuid: \"\",\n", "        playgroundQueryId: null,\n\t        error: null,\n\t        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        warningCodes: [],\n\t        data: null,\n\t        recordId: \"\",\n\t        importedQueryInputs: {},\n\t        isImported: false,\n", "        showSuccessToaster: true,\n\t        dataArray: [],\n\t        cacheKeyTtl: \"\",\n\t        filterBy: \"\",\n\t        requestSentTimestamp: null,\n\t        databaseHostOverride: \"\",\n\t        metadata: null,\n\t        workflowActionType: null,\n\t        editorMode: \"gui\",\n\t        queryRunTime: null,\n", "        actionType: \"INSERT\",\n\t        changesetObject: \"{{startTrigger.data.data}}\",\n\t        shouldUseLegacySql: false,\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n\t        finished: null,\n\t        databaseNameOverride: \"\",\n\t        confirmationMessage: null,\n\t        isFetching: false,\n\t        changeset: \"\",\n", "        rawData: null,\n\t        queryTriggerDelay: \"0\",\n\t        resourceTypeOverride: \"postgresql\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        enableBulkUpdates: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n", "        enableTransformer: false,\n\t        showUpdateSetValueDynamicallyToggle: true,\n\t        bulkUpdatePrimaryKey: \"\",\n\t        runWhenPageLoads: false,\n\t        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        tableName: \"name_placeholder\",\n\t        queryTimeout: \"120000\",\n\t        workflowId: null,\n", "        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: true,\n\t        enableCaching: false,\n\t        allowedGroups: [],\n\t        workflowBlockPluginId: null,\n\t        databaseUsernameOverride: \"\",\n\t        shouldEnableBatchQuerying: false,\n\t        doNotThrowOnNoOp: false,\n\t        offlineQueryType: \"None\",\n", "        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n\t      },\n\t    },\n\t  },\n\t  {\n\t    block: {\n\t      pluginId: \"switchType\",\n\t      incomingOnSuccessPlugins: [],\n", "      top: 0,\n\t      left: 528,\n\t      environment: \"production\",\n\t      editorType: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      blockType: \"conditional\",\n\t      options: {\n\t        conditions: [\n\t          {\n\t            id: \"4a38580b-830a-4f7b-9c3f-503bf1a0ed6d\",\n", "            type: \"if\",\n\t            statement: 'startTrigger.data.type === \"create\"',\n\t            outgoingPortId: \"a620f4c4-57db-4732-9176-934bcf9b94a8\",\n\t          },\n\t          {\n\t            id: \"5a1e5f9a-ac0e-4b7d-83d9-2ec42d766fb7\",\n\t            type: \"if\",\n\t            statement: 'startTrigger.data.type === \"read\"',\n\t            outgoingPortId: \"75cf13b9-ac7e-47b2-a48d-518ec1094659\",\n\t          },\n", "          {\n\t            id: \"42309937-c622-40bc-8d17-7b302e063b23\",\n\t            type: \"if\",\n\t            statement: 'startTrigger.data.type === \"update\"',\n\t            outgoingPortId: \"7d59ff82-a70b-4fe8-a6c8-3253898cf1a6\",\n\t          },\n\t          {\n\t            id: \"756ce9dc-9a06-4460-bf83-f4579d255dcc\",\n\t            type: \"if\",\n\t            statement: 'startTrigger.data.type === \"destroy\"',\n", "            outgoingPortId: \"221b4d5d-fb16-4581-9b71-f95ef77c66d0\",\n\t          },\n\t          {\n\t            id: \"41fd9758-049c-47b3-8d32-77c4399808c7\",\n\t            type: \"else\",\n\t            statement: \"\",\n\t            outgoingPortId: \"12676e07-8c10-4bb5-914a-98e6608a386e\",\n\t          },\n\t        ],\n\t      },\n", "      outgoingPorts: [\n\t        {\n\t          id: \"a620f4c4-57db-4732-9176-934bcf9b94a8\",\n\t          name: \"0\",\n\t          type: \"conditional\",\n\t        },\n\t        {\n\t          id: \"75cf13b9-ac7e-47b2-a48d-518ec1094659\",\n\t          name: \"1\",\n\t          type: \"conditional\",\n", "        },\n\t        {\n\t          id: \"7d59ff82-a70b-4fe8-a6c8-3253898cf1a6\",\n\t          name: \"2\",\n\t          type: \"conditional\",\n\t        },\n\t        {\n\t          id: \"221b4d5d-fb16-4581-9b71-f95ef77c66d0\",\n\t          name: \"3\",\n\t          type: \"conditional\",\n", "        },\n\t        {\n\t          id: \"12676e07-8c10-4bb5-914a-98e6608a386e\",\n\t          name: \"4\",\n\t          type: \"conditional\",\n\t        },\n\t      ],\n\t      incomingPortsPlugins: [\n\t        {\n\t          blockPluginId: \"filterBadRequest\",\n", "          portId: \"c7a9d846-836e-4fbd-87af-3d76aa66715c\",\n\t        },\n\t      ],\n\t    },\n\t    pluginTemplate: {\n\t      id: \"switchType\",\n\t      type: \"datasource\",\n\t      subtype: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      template: {\n", "        queryRefreshTime: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n\t        resourceNameOverride: \"\",\n", "        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query:\n\t          \"if (startTrigger.data.type === \\\"create\\\") {\\n  executePathAtMostOnce('0')\\n}\\nelse if (startTrigger.data.type === \\\"read\\\") {\\n  executePathAtMostOnce('1')\\n}\\nelse if (startTrigger.data.type === \\\"update\\\") {\\n  executePathAtMostOnce('2')\\n}\\nelse if (startTrigger.data.type === \\\"destroy\\\") {\\n  executePathAtMostOnce('3')\\n}\\nelse { executePathAtMostOnce('4') }\",\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n\t        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n", "        runWhenPageLoadsDelay: \"\",\n\t        data: null,\n\t        importedQueryInputs: {},\n\t        _additionalScope: [],\n\t        isImported: false,\n\t        showSuccessToaster: true,\n\t        cacheKeyTtl: \"\",\n\t        requestSentTimestamp: null,\n\t        metadata: null,\n\t        workflowActionType: null,\n", "        editorMode: \"sql\",\n\t        queryRunTime: null,\n\t        changesetObject: \"\",\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n\t        finished: null,\n\t        confirmationMessage: null,\n\t        isFetching: false,\n\t        changeset: \"\",\n\t        rawData: null,\n", "        queryTriggerDelay: \"0\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n\t        showUpdateSetValueDynamicallyToggle: true,\n\t        runWhenPageLoads: false,\n", "        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        queryTimeout: \"10000\",\n\t        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: false,\n\t        enableCaching: false,\n\t        allowedGroups: [],\n", "        workflowBlockPluginId: null,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n\t      },\n\t    },\n\t  },\n\t  {\n\t    block: {\n", "      pluginId: \"readQuery\",\n\t      incomingOnSuccessPlugins: [],\n\t      top: -240,\n\t      left: 1040,\n\t      environment: \"production\",\n\t      editorType: \"SqlQueryUnified\",\n\t      resourceName: \"\",\n\t      blockType: \"default\",\n\t      incomingPortsPlugins: [\n\t        {\n", "          blockPluginId: \"switchType\",\n\t          portId: \"75cf13b9-ac7e-47b2-a48d-518ec1094659\",\n\t        },\n\t      ],\n\t    },\n\t    pluginTemplate: {\n\t      id: \"readQuery\",\n\t      type: \"datasource\",\n\t      subtype: \"SqlQueryUnified\",\n\t      resourceName: null,\n", "      template: {\n\t        queryRefreshTime: \"\",\n\t        records: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        databasePasswordOverride: \"\",\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n\t        queryDisabled: \"\",\n", "        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n\t        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query: \"SELECT * from name_placeholder\",\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n", "        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        warningCodes: [],\n\t        data: null,\n\t        recordId: \"\",\n\t        importedQueryInputs: {},\n\t        isImported: false,\n\t        showSuccessToaster: true,\n\t        dataArray: [],\n", "        cacheKeyTtl: \"\",\n\t        filterBy: \"\",\n\t        requestSentTimestamp: null,\n\t        databaseHostOverride: \"\",\n\t        metadata: null,\n\t        workflowActionType: null,\n\t        editorMode: \"sql\",\n\t        queryRunTime: null,\n\t        actionType: \"\",\n\t        changesetObject: \"\",\n", "        shouldUseLegacySql: false,\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n\t        finished: null,\n\t        databaseNameOverride: \"\",\n\t        confirmationMessage: null,\n\t        isFetching: false,\n\t        changeset: \"\",\n\t        rawData: null,\n\t        queryTriggerDelay: \"0\",\n", "        resourceTypeOverride: \"postgresql\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        enableBulkUpdates: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n\t        showUpdateSetValueDynamicallyToggle: true,\n", "        bulkUpdatePrimaryKey: \"\",\n\t        runWhenPageLoads: false,\n\t        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        tableName: \"name_placeholder\",\n\t        queryTimeout: \"120000\",\n\t        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n", "        changesetIsObject: false,\n\t        enableCaching: false,\n\t        allowedGroups: [],\n\t        workflowBlockPluginId: null,\n\t        databaseUsernameOverride: \"\",\n\t        shouldEnableBatchQuerying: false,\n\t        doNotThrowOnNoOp: false,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n", "        notificationDuration: \"\",\n\t      },\n\t    },\n\t  },\n\t  {\n\t    block: {\n\t      pluginId: \"updateQuery\",\n\t      incomingOnSuccessPlugins: [],\n\t      top: 144,\n\t      left: 1056,\n", "      environment: \"production\",\n\t      editorType: \"SqlQueryUnified\",\n\t      resourceName: \"\",\n\t      blockType: \"default\",\n\t      incomingPortsPlugins: [\n\t        {\n\t          blockPluginId: \"switchType\",\n\t          portId: \"7d59ff82-a70b-4fe8-a6c8-3253898cf1a6\",\n\t        },\n\t      ],\n", "    },\n\t    pluginTemplate: {\n\t      id: \"updateQuery\",\n\t      type: \"datasource\",\n\t      subtype: \"SqlQueryUnified\",\n\t      resourceName: null,\n\t      template: {\n\t        queryRefreshTime: \"\",\n\t        records: \"\",\n\t        lastReceivedFromResourceAt: null,\n", "        databasePasswordOverride: \"\",\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n\t        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n", "        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query: \"-- Delete query goes here\",\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n\t        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        warningCodes: [],\n", "        data: null,\n\t        recordId: \"\",\n\t        importedQueryInputs: {},\n\t        isImported: false,\n\t        showSuccessToaster: true,\n\t        dataArray: [],\n\t        cacheKeyTtl: \"\",\n\t        filterBy:\n\t          '[{\"key\":\"id\",\"value\":\"{{startTrigger.data.row}}\",\"operation\":\"=\"}]',\n\t        requestSentTimestamp: null,\n", "        databaseHostOverride: \"\",\n\t        metadata: null,\n\t        workflowActionType: null,\n\t        editorMode: \"gui\",\n\t        queryRunTime: null,\n\t        actionType: \"UPDATE_BY\",\n\t        changesetObject: \"{{startTrigger.data.data}}\",\n\t        shouldUseLegacySql: false,\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n", "        finished: null,\n\t        databaseNameOverride: \"\",\n\t        confirmationMessage: null,\n\t        isFetching: false,\n\t        changeset: \"\",\n\t        rawData: null,\n\t        queryTriggerDelay: \"0\",\n\t        resourceTypeOverride: \"postgresql\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n", "        enableBulkUpdates: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n\t        showUpdateSetValueDynamicallyToggle: true,\n\t        bulkUpdatePrimaryKey: \"\",\n\t        runWhenPageLoads: false,\n\t        transformer:\n", "          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        tableName: \"name_placeholder\",\n\t        queryTimeout: \"120000\",\n\t        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: true,\n\t        enableCaching: false,\n\t        allowedGroups: [],\n", "        workflowBlockPluginId: null,\n\t        databaseUsernameOverride: \"\",\n\t        shouldEnableBatchQuerying: false,\n\t        doNotThrowOnNoOp: false,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n\t      },\n\t    },\n", "  },\n\t  {\n\t    block: {\n\t      pluginId: \"createReturn\",\n\t      incomingOnSuccessPlugins: [\"createQuery\"],\n\t      top: -640,\n\t      left: 1472,\n\t      environment: \"production\",\n\t      editorType: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n", "      blockType: \"webhookReturn\",\n\t      options: {\n\t        body: \"{\\n  data: createQuery.data,\\n  error: createQuery.error\\n }\",\n\t        status: \"200\",\n\t      },\n\t    },\n\t    pluginTemplate: {\n\t      id: \"createReturn\",\n\t      type: \"datasource\",\n\t      subtype: \"JavascriptQuery\",\n", "      resourceName: \"JavascriptQuery\",\n\t      template: {\n\t        queryRefreshTime: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n", "        workflowParams: null,\n\t        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query:\n\t          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 200\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  data: createQuery.data,\\n  error: createQuery.error\\n }\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of createReturn'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n", "        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        data: null,\n\t        importedQueryInputs: {},\n\t        _additionalScope: [],\n\t        isImported: false,\n\t        showSuccessToaster: true,\n\t        cacheKeyTtl: \"\",\n\t        requestSentTimestamp: null,\n", "        metadata: null,\n\t        workflowActionType: null,\n\t        editorMode: \"sql\",\n\t        queryRunTime: null,\n\t        changesetObject: \"\",\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n\t        finished: null,\n\t        confirmationMessage: null,\n\t        isFetching: false,\n", "        changeset: \"\",\n\t        rawData: null,\n\t        queryTriggerDelay: \"0\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n", "        showUpdateSetValueDynamicallyToggle: true,\n\t        runWhenPageLoads: false,\n\t        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        queryTimeout: \"10000\",\n\t        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: false,\n", "        enableCaching: false,\n\t        allowedGroups: [],\n\t        workflowBlockPluginId: null,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n\t      },\n\t    },\n\t  },\n", "  {\n\t    block: {\n\t      pluginId: \"readReturn\",\n\t      incomingOnSuccessPlugins: [\"readQuery\"],\n\t      top: -240,\n\t      left: 1488,\n\t      environment: \"production\",\n\t      editorType: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      blockType: \"webhookReturn\",\n", "      options: {\n\t        body: \"{\\n  data: readQuery.data,\\n  error: readQuery.error\\n }\",\n\t        status: \"200\",\n\t      },\n\t    },\n\t    pluginTemplate: {\n\t      id: \"readReturn\",\n\t      type: \"datasource\",\n\t      subtype: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n", "      template: {\n\t        queryRefreshTime: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n", "        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query:\n\t          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 200\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  data: readQuery.data,\\n  error: readQuery.error\\n }\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of readReturn'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n\t        workflowRunBodyType: \"raw\",\n", "        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        data: null,\n\t        importedQueryInputs: {},\n\t        _additionalScope: [],\n\t        isImported: false,\n\t        showSuccessToaster: true,\n\t        cacheKeyTtl: \"\",\n\t        requestSentTimestamp: null,\n\t        metadata: null,\n", "        workflowActionType: null,\n\t        editorMode: \"sql\",\n\t        queryRunTime: null,\n\t        changesetObject: \"\",\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n\t        finished: null,\n\t        confirmationMessage: null,\n\t        isFetching: false,\n\t        changeset: \"\",\n", "        rawData: null,\n\t        queryTriggerDelay: \"0\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n\t        showUpdateSetValueDynamicallyToggle: true,\n", "        runWhenPageLoads: false,\n\t        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        queryTimeout: \"10000\",\n\t        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: false,\n\t        enableCaching: false,\n", "        allowedGroups: [],\n\t        workflowBlockPluginId: null,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n\t      },\n\t    },\n\t  },\n\t  {\n", "    block: {\n\t      pluginId: \"updateReturn\",\n\t      incomingOnSuccessPlugins: [\"updateQuery\"],\n\t      top: 144,\n\t      left: 1504,\n\t      environment: \"production\",\n\t      editorType: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      blockType: \"webhookReturn\",\n\t      options: {\n", "        body: \"{\\n  data: updateQuery.data,\\n  error: updateQuery.error\\n }\",\n\t        status: \"200\",\n\t      },\n\t    },\n\t    pluginTemplate: {\n\t      id: \"updateReturn\",\n\t      type: \"datasource\",\n\t      subtype: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      template: {\n", "        queryRefreshTime: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n\t        resourceNameOverride: \"\",\n", "        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query:\n\t          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 200\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  data: updateQuery.data,\\n  error: updateQuery.error\\n }\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of updateReturn'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n\t        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n", "        runWhenPageLoadsDelay: \"\",\n\t        data: null,\n\t        importedQueryInputs: {},\n\t        _additionalScope: [],\n\t        isImported: false,\n\t        showSuccessToaster: true,\n\t        cacheKeyTtl: \"\",\n\t        requestSentTimestamp: null,\n\t        metadata: null,\n\t        workflowActionType: null,\n", "        editorMode: \"sql\",\n\t        queryRunTime: null,\n\t        changesetObject: \"\",\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n\t        finished: null,\n\t        confirmationMessage: null,\n\t        isFetching: false,\n\t        changeset: \"\",\n\t        rawData: null,\n", "        queryTriggerDelay: \"0\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n\t        showUpdateSetValueDynamicallyToggle: true,\n\t        runWhenPageLoads: false,\n", "        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        queryTimeout: \"10000\",\n\t        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: false,\n\t        enableCaching: false,\n\t        allowedGroups: [],\n", "        workflowBlockPluginId: null,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n\t      },\n\t    },\n\t  },\n\t  {\n\t    block: {\n", "      pluginId: \"invalidType\",\n\t      incomingOnSuccessPlugins: [],\n\t      top: 880,\n\t      left: 1056,\n\t      environment: \"production\",\n\t      editorType: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      blockType: \"webhookReturn\",\n\t      options: {\n\t        body: '{\\n  success:false,\\n  mesage:\"Invalid type in request body\"\\n}',\n", "        status: \"400\",\n\t      },\n\t      incomingPortsPlugins: [\n\t        {\n\t          blockPluginId: \"switchType\",\n\t          portId: \"12676e07-8c10-4bb5-914a-98e6608a386e\",\n\t        },\n\t      ],\n\t    },\n\t    pluginTemplate: {\n", "      id: \"invalidType\",\n\t      type: \"datasource\",\n\t      subtype: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      template: {\n\t        queryRefreshTime: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n", "        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n\t        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query:\n\t          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 400\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  success:false,\\n  mesage:\\\"Invalid type in request body\\\"\\n}\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of missingTypeReturn'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n", "        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n\t        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        data: null,\n\t        importedQueryInputs: {},\n\t        _additionalScope: [],\n\t        isImported: false,\n", "        showSuccessToaster: true,\n\t        cacheKeyTtl: \"\",\n\t        requestSentTimestamp: null,\n\t        metadata: null,\n\t        workflowActionType: null,\n\t        editorMode: \"sql\",\n\t        queryRunTime: null,\n\t        changesetObject: \"\",\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n", "        finished: null,\n\t        confirmationMessage: null,\n\t        isFetching: false,\n\t        changeset: \"\",\n\t        rawData: null,\n\t        queryTriggerDelay: \"0\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n", "        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n\t        showUpdateSetValueDynamicallyToggle: true,\n\t        runWhenPageLoads: false,\n\t        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        queryTimeout: \"10000\",\n\t        workflowId: null,\n", "        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: false,\n\t        enableCaching: false,\n\t        allowedGroups: [],\n\t        workflowBlockPluginId: null,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n", "      },\n\t    },\n\t  },\n\t  {\n\t    block: {\n\t      pluginId: \"destroyQuery\",\n\t      incomingOnSuccessPlugins: [],\n\t      top: 512,\n\t      left: 1056,\n\t      environment: \"production\",\n", "      editorType: \"SqlQueryUnified\",\n\t      resourceName: \"\",\n\t      blockType: \"default\",\n\t      incomingPortsPlugins: [\n\t        {\n\t          blockPluginId: \"switchType\",\n\t          portId: \"221b4d5d-fb16-4581-9b71-f95ef77c66d0\",\n\t        },\n\t      ],\n\t    },\n", "    pluginTemplate: {\n\t      id: \"destroyQuery\",\n\t      type: \"datasource\",\n\t      subtype: \"SqlQueryUnified\",\n\t      resourceName: null,\n\t      template: {\n\t        queryRefreshTime: \"\",\n\t        records: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        databasePasswordOverride: \"\",\n", "        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n\t        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n", "        showFailureToaster: true,\n\t        query:\n\t          'delete from name_placeholder where \"id\" = {{startTrigger.data.row}}',\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n\t        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        warningCodes: [],\n", "        data: null,\n\t        recordId: \"\",\n\t        importedQueryInputs: {},\n\t        isImported: false,\n\t        showSuccessToaster: true,\n\t        dataArray: [],\n\t        cacheKeyTtl: \"\",\n\t        filterBy:\n\t          '[{\"key\":\"id\",\"value\":\"{{startTrigger.data.row}}\",\"operation\":\"=\"}]',\n\t        requestSentTimestamp: null,\n", "        databaseHostOverride: \"\",\n\t        metadata: null,\n\t        workflowActionType: null,\n\t        editorMode: \"sql\",\n\t        queryRunTime: null,\n\t        actionType: \"DELETE_BY\",\n\t        changesetObject: \"\",\n\t        shouldUseLegacySql: false,\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n", "        finished: null,\n\t        databaseNameOverride: \"\",\n\t        confirmationMessage: null,\n\t        isFetching: false,\n\t        changeset: \"\",\n\t        rawData: null,\n\t        queryTriggerDelay: \"0\",\n\t        resourceTypeOverride: \"postgresql\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n", "        enableBulkUpdates: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n\t        showUpdateSetValueDynamicallyToggle: true,\n\t        bulkUpdatePrimaryKey: \"\",\n\t        runWhenPageLoads: false,\n\t        transformer:\n", "          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        tableName: \"name_placeholder\",\n\t        queryTimeout: \"120000\",\n\t        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: false,\n\t        enableCaching: false,\n\t        allowedGroups: [],\n", "        workflowBlockPluginId: null,\n\t        databaseUsernameOverride: \"\",\n\t        shouldEnableBatchQuerying: false,\n\t        doNotThrowOnNoOp: true,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n\t      },\n\t    },\n", "  },\n\t  {\n\t    block: {\n\t      pluginId: \"destroyReturn\",\n\t      incomingOnSuccessPlugins: [\"destroyQuery\"],\n\t      top: 512,\n\t      left: 1504,\n\t      environment: \"production\",\n\t      editorType: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n", "      blockType: \"webhookReturn\",\n\t      options: {\n\t        body: \"{\\n  data: destroyQuery.data,\\n  error: destroyQuery.error\\n }\",\n\t        status: \"200\",\n\t      },\n\t    },\n\t    pluginTemplate: {\n\t      id: \"destroyReturn\",\n\t      type: \"datasource\",\n\t      subtype: \"JavascriptQuery\",\n", "      resourceName: \"JavascriptQuery\",\n\t      template: {\n\t        queryRefreshTime: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n", "        workflowParams: null,\n\t        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query:\n\t          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 200\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  data: destroyQuery.data,\\n  error: destroyQuery.error\\n }\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of destroyReturn'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n", "        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        data: null,\n\t        importedQueryInputs: {},\n\t        _additionalScope: [],\n\t        isImported: false,\n\t        showSuccessToaster: true,\n\t        cacheKeyTtl: \"\",\n\t        requestSentTimestamp: null,\n", "        metadata: null,\n\t        workflowActionType: null,\n\t        editorMode: \"sql\",\n\t        queryRunTime: null,\n\t        changesetObject: \"\",\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n\t        finished: null,\n\t        confirmationMessage: null,\n\t        isFetching: false,\n", "        changeset: \"\",\n\t        rawData: null,\n\t        queryTriggerDelay: \"0\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n", "        showUpdateSetValueDynamicallyToggle: true,\n\t        runWhenPageLoads: false,\n\t        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        queryTimeout: \"10000\",\n\t        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: false,\n", "        enableCaching: false,\n\t        allowedGroups: [],\n\t        workflowBlockPluginId: null,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n\t      },\n\t    },\n\t  },\n", "  {\n\t    block: {\n\t      pluginId: \"filterBadRequest\",\n\t      incomingOnSuccessPlugins: [\"startTrigger\"],\n\t      top: 0,\n\t      left: 48,\n\t      environment: \"production\",\n\t      editorType: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      blockType: \"conditional\",\n", "      options: {\n\t        conditions: [\n\t          {\n\t            id: \"44af1908-d150-49f9-9f9b-340366665a96\",\n\t            type: \"if\",\n\t            statement: \"startTrigger.data?.type\",\n\t            outgoingPortId: \"c7a9d846-836e-4fbd-87af-3d76aa66715c\",\n\t          },\n\t          {\n\t            id: \"fde78ed6-12ea-4d47-b0ff-31404aa98db2\",\n", "            type: \"else\",\n\t            statement: \"\",\n\t            outgoingPortId: \"861a427e-f1c4-4ba1-8532-52580fc61da9\",\n\t          },\n\t        ],\n\t      },\n\t      outgoingPorts: [\n\t        {\n\t          id: \"c7a9d846-836e-4fbd-87af-3d76aa66715c\",\n\t          name: \"0\",\n", "          type: \"conditional\",\n\t        },\n\t        {\n\t          id: \"861a427e-f1c4-4ba1-8532-52580fc61da9\",\n\t          name: \"1\",\n\t          type: \"conditional\",\n\t        },\n\t      ],\n\t      incomingPortsPlugins: [],\n\t    },\n", "    pluginTemplate: {\n\t      id: \"filterBadRequest\",\n\t      type: \"datasource\",\n\t      subtype: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      template: {\n\t        queryRefreshTime: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n", "        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n\t        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query:\n", "          \"if (startTrigger.data?.type) {\\n  executePathAtMostOnce('0')\\n}\\nelse { executePathAtMostOnce('1') }\",\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n\t        workflowRunBodyType: \"raw\",\n\t        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        data: null,\n\t        importedQueryInputs: {},\n\t        _additionalScope: [],\n", "        isImported: false,\n\t        showSuccessToaster: true,\n\t        cacheKeyTtl: \"\",\n\t        requestSentTimestamp: null,\n\t        metadata: null,\n\t        workflowActionType: null,\n\t        editorMode: \"sql\",\n\t        queryRunTime: null,\n\t        changesetObject: \"\",\n\t        errorTransformer:\n", "          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n\t        finished: null,\n\t        confirmationMessage: null,\n\t        isFetching: false,\n\t        changeset: \"\",\n\t        rawData: null,\n\t        queryTriggerDelay: \"0\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        showLatestVersionUpdatedWarning: false,\n", "        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n\t        showUpdateSetValueDynamicallyToggle: true,\n\t        runWhenPageLoads: false,\n\t        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        queryTimeout: \"10000\",\n", "        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: false,\n\t        enableCaching: false,\n\t        allowedGroups: [],\n\t        workflowBlockPluginId: null,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n", "        notificationDuration: \"\",\n\t      },\n\t    },\n\t  },\n\t  {\n\t    block: {\n\t      pluginId: \"missingType\",\n\t      incomingOnSuccessPlugins: [],\n\t      top: 512,\n\t      left: 512,\n", "      environment: \"production\",\n\t      editorType: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n\t      blockType: \"webhookReturn\",\n\t      options: {\n\t        body: '{\\n  success:false,\\n  mesage:\"Missing type in request body\"\\n}',\n\t        status: \"400\",\n\t      },\n\t      incomingPortsPlugins: [\n\t        {\n", "          blockPluginId: \"filterBadRequest\",\n\t          portId: \"861a427e-f1c4-4ba1-8532-52580fc61da9\",\n\t        },\n\t      ],\n\t    },\n\t    pluginTemplate: {\n\t      id: \"missingType\",\n\t      type: \"datasource\",\n\t      subtype: \"JavascriptQuery\",\n\t      resourceName: \"JavascriptQuery\",\n", "      template: {\n\t        queryRefreshTime: \"\",\n\t        lastReceivedFromResourceAt: null,\n\t        queryDisabledMessage: \"\",\n\t        servedFromCache: false,\n\t        offlineUserQueryInputs: \"\",\n\t        successMessage: \"\",\n\t        queryDisabled: \"\",\n\t        playgroundQuerySaveId: \"latest\",\n\t        workflowParams: null,\n", "        resourceNameOverride: \"\",\n\t        runWhenModelUpdates: false,\n\t        workflowRunId: null,\n\t        showFailureToaster: true,\n\t        query:\n\t          \"const generateReturn = () => {\\n    const status = () => {\\n      try {\\n        return 400\\n      } catch {\\n        return 200\\n      }\\n    }\\n  const body = () => {\\n    try {\\n      return {\\n  success:false,\\n  mesage:\\\"Missing type in request body\\\"\\n}\\n    } catch {\\n      return {'error': true, 'messsage': 'there was a problem parsing the JSON body of missingType'}\\n    }\\n  }\\n  return {status: status(), body: body() }\\n  }\\n  return generateReturn()\\n  \",\n\t        playgroundQueryUuid: \"\",\n\t        playgroundQueryId: null,\n\t        error: null,\n\t        workflowRunBodyType: \"raw\",\n", "        privateParams: [],\n\t        runWhenPageLoadsDelay: \"\",\n\t        data: null,\n\t        importedQueryInputs: {},\n\t        _additionalScope: [],\n\t        isImported: false,\n\t        showSuccessToaster: true,\n\t        cacheKeyTtl: \"\",\n\t        requestSentTimestamp: null,\n\t        metadata: null,\n", "        workflowActionType: null,\n\t        editorMode: \"sql\",\n\t        queryRunTime: null,\n\t        changesetObject: \"\",\n\t        errorTransformer:\n\t          \"// The variable 'data' allows you to reference the request's data in the transformer. \\n// example: return data.find(element => element.isError)\\nreturn data.error\",\n\t        finished: null,\n\t        confirmationMessage: null,\n\t        isFetching: false,\n\t        changeset: \"\",\n", "        rawData: null,\n\t        queryTriggerDelay: \"0\",\n\t        watchedParams: [],\n\t        enableErrorTransformer: false,\n\t        showLatestVersionUpdatedWarning: false,\n\t        timestamp: 0,\n\t        evalType: \"script\",\n\t        importedQueryDefaults: {},\n\t        enableTransformer: false,\n\t        showUpdateSetValueDynamicallyToggle: true,\n", "        runWhenPageLoads: false,\n\t        transformer:\n\t          \"// Query results are available as the `data` variable\\nreturn formatDataAsArray(data)\",\n\t        events: [],\n\t        queryTimeout: \"10000\",\n\t        workflowId: null,\n\t        requireConfirmation: false,\n\t        queryFailureConditions: \"\",\n\t        changesetIsObject: false,\n\t        enableCaching: false,\n", "        allowedGroups: [],\n\t        workflowBlockPluginId: null,\n\t        offlineQueryType: \"None\",\n\t        queryThrottleTime: \"750\",\n\t        updateSetValueDynamically: false,\n\t        notificationDuration: \"\",\n\t      },\n\t    },\n\t  },\n\t];\n"]}
