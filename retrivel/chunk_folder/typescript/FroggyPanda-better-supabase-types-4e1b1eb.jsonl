{"filename": "example/afterSchema.ts", "chunked_list": ["export type Json =\n\t  | string\n\t  | number\n\t  | boolean\n\t  | null\n\t  | { [key: string]: Json | undefined }\n\t  | Json[];\n\texport interface Database {\n\t  public: {\n\t    Tables: {\n", "      todos: {\n\t        Row: {\n\t          id: number;\n\t          inserted_at: string;\n\t          is_complete: boolean | null;\n\t          task: string | null;\n\t          user_id: string;\n\t        };\n\t        Insert: {\n\t          id?: number;\n", "          inserted_at?: string;\n\t          is_complete?: boolean | null;\n\t          task?: string | null;\n\t          user_id: string;\n\t        };\n\t        Update: {\n\t          id?: number;\n\t          inserted_at?: string;\n\t          is_complete?: boolean | null;\n\t          task?: string | null;\n", "          user_id?: string;\n\t        };\n\t        Relationships: [\n\t          {\n\t            foreignKeyName: 'todos_user_id_fkey';\n\t            columns: ['user_id'];\n\t            referencedRelation: 'users';\n\t            referencedColumns: ['id'];\n\t          }\n\t        ];\n", "      };\n\t    };\n\t    Views: {\n\t      [_ in never]: never;\n\t    };\n\t    Functions: {\n\t      [_ in never]: never;\n\t    };\n\t    Enums: {\n\t      [_ in never]: never;\n", "    };\n\t    CompositeTypes: {\n\t      [_ in never]: never;\n\t    };\n\t  };\n\t}\n\t//Schema: public\n\t//Tables\n\texport type Todo = Database['public']['Tables']['todos']['Row'];\n\texport type InsertTodo = Database['public']['Tables']['todos']['Insert'];\n", "export type UpdateTodo = Database['public']['Tables']['todos']['Update'];\n"]}
{"filename": "example/beforeSchema.ts", "chunked_list": ["export type Json =\n\t  | string\n\t  | number\n\t  | boolean\n\t  | null\n\t  | { [key: string]: Json | undefined }\n\t  | Json[]\n\texport interface Database {\n\t  public: {\n\t    Tables: {\n", "      todos: {\n\t        Row: {\n\t          id: number\n\t          inserted_at: string\n\t          is_complete: boolean | null\n\t          task: string | null\n\t          user_id: string\n\t        }\n\t        Insert: {\n\t          id?: number\n", "          inserted_at?: string\n\t          is_complete?: boolean | null\n\t          task?: string | null\n\t          user_id: string\n\t        }\n\t        Update: {\n\t          id?: number\n\t          inserted_at?: string\n\t          is_complete?: boolean | null\n\t          task?: string | null\n", "          user_id?: string\n\t        }\n\t        Relationships: [\n\t          {\n\t            foreignKeyName: \"todos_user_id_fkey\"\n\t            columns: [\"user_id\"]\n\t            referencedRelation: \"users\"\n\t            referencedColumns: [\"id\"]\n\t          }\n\t        ]\n", "      }\n\t    }\n\t    Views: {\n\t      [_ in never]: never\n\t    }\n\t    Functions: {\n\t      [_ in never]: never\n\t    }\n\t    Enums: {\n\t      [_ in never]: never\n", "    }\n\t    CompositeTypes: {\n\t      [_ in never]: never\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["#!/usr/bin/env node\n\timport yargs from 'yargs';\n\timport { hideBin } from 'yargs/helpers';\n\timport { generate } from './generate';\n\timport { z } from 'zod';\n\timport fs from 'fs';\n\tconst configExists = fs.existsSync('.betterrc.json');\n\tconst prePackageJsonFile = fs.readFileSync('package.json', 'utf-8');\n\tconst packageJsonFile = JSON.parse(prePackageJsonFile);\n\tconst schema = z\n", "  .object({\n\t    input: z.string(),\n\t    output: z.string().optional(),\n\t    force: z.boolean().optional(),\n\t    prettier: z.string().optional().default('.prettierrc'),\n\t    singular: z.boolean().optional().default(false),\n\t  })\n\t  .strict();\n\t// Load config from '.betterrc' file\n\tif (configExists) {\n", "  const prefile = fs.readFileSync('.betterrc.json', 'utf-8');\n\t  const json = JSON.parse(prefile);\n\t  // Check if config is correct\n\t  const result = schema.safeParse(json);\n\t  if (!result.success) {\n\t    console.log('Invalid config file');\n\t  } else {\n\t    if (!result.data.output && !result.data.force) {\n\t      console.log(\n\t        'It looks like you want to overwrite your input file. Add the force property to do that in your config file.'\n", "      );\n\t    } else {\n\t      const input = result.data.input;\n\t      const output = result.data.output || result.data.input;\n\t      const prettier = result.data.prettier;\n\t      const singular = result.data.singular ?? false;\n\t      generate(input, output, prettier, singular);\n\t    }\n\t  }\n\t} else if (packageJsonFile['betterConfig']) {\n", "  // Load config from 'package.json' file\n\t  // Check if config is correct\n\t  const result = schema.safeParse(packageJsonFile['betterConfig']);\n\t  if (!result.success) {\n\t    console.log('Invalid config in package.json');\n\t  } else {\n\t    if (!result.data.output && !result.data.force) {\n\t      console.log(\n\t        'It looks like you want to overwrite your input file. Add the force property to do that in your config file.'\n\t      );\n", "    } else {\n\t      const input = result.data.input;\n\t      const output = result.data.output || result.data.input;\n\t      const prettier = result.data.prettier;\n\t      const singular = result.data.singular ?? false;\n\t      generate(input, output, prettier, singular);\n\t    }\n\t  }\n\t} else {\n\t  // Load config from command line\n", "  yargs(hideBin(process.argv))\n\t    .command(\n\t      '*',\n\t      '',\n\t      (yargs) => {\n\t        return yargs\n\t          .options({\n\t            input: {\n\t              type: 'string',\n\t              alias: ['i'],\n", "              describe: 'Path to the input file',\n\t              requiresArg: true,\n\t            },\n\t            output: {\n\t              type: 'string',\n\t              alias: ['o'],\n\t              describe: 'Path to the output file',\n\t              requiresArg: true,\n\t            },\n\t            prettier: {\n", "              type: 'string',\n\t              alias: ['p'],\n\t              describe: 'Path to the prettier config file',\n\t              requiresArg: false,\n\t              default: '.prettierrc',\n\t            },\n\t            force: {\n\t              type: 'boolean',\n\t              alias: ['f'],\n\t              describe: 'Force the overwrite of the input file',\n", "            },\n\t            singular: {\n\t              type: 'boolean',\n\t              alias: ['s'],\n\t              describe:\n\t                'Convert table names to singular form instead of plural form',\n\t              requiresArg: false,\n\t              default: false,\n\t            },\n\t          })\n", "          .demandOption(['input']);\n\t      },\n\t      (argv) => {\n\t        if (!argv.output && !argv.force) {\n\t          console.error(\n\t            'It looks like you want to overwrite your input file. Add the force flag to do that.'\n\t          );\n\t          return;\n\t        }\n\t        const input = argv.input;\n", "        const output = argv.output || argv.input;\n\t        const prettier = argv.prettier;\n\t        const singular = argv.singular ?? false;\n\t        generate(input, output, prettier, singular);\n\t      }\n\t    )\n\t    .help()\n\t    .strict()\n\t    .parse();\n\t}\n"]}
{"filename": "src/generate.ts", "chunked_list": ["import fs from 'fs';\n\timport {\n\t  getEnumValuesText,\n\t  getEnumsProperties,\n\t  getFunctionReturnTypes,\n\t  getSchemasProperties,\n\t  getTablesProperties,\n\t  prettierFormat,\n\t  toPascalCase,\n\t} from './utils';\n", "import { ModuleKind, Project, ScriptTarget } from 'ts-morph';\n\timport chalk from 'chalk';\n\texport async function generate(\n\t  input: string,\n\t  output: string,\n\t  prettierConfigPath?: string,\n\t  makeSingular: boolean = false\n\t) {\n\t  const exists = fs.existsSync(input);\n\t  const project = new Project({\n", "    compilerOptions: {\n\t      allowSyntheticDefaultImports: true,\n\t      esModuleInterop: true,\n\t      module: ModuleKind.ESNext,\n\t      target: ScriptTarget.ESNext,\n\t      strictNullChecks: true,\n\t    },\n\t  });\n\t  const sourceFile = project.addSourceFileAtPath(input);\n\t  if (!exists) {\n", "    console.error(`${chalk.red.bold('error')} Input file not found`);\n\t    return;\n\t  }\n\t  const types: string[] = [];\n\t  const schemas = getSchemasProperties(project, sourceFile);\n\t  for (const schema of schemas) {\n\t    types.push(`// Schema: ${schema.getName()}`);\n\t    const schemaName = schema.getName();\n\t    const tablesProperties = getTablesProperties(\n\t      project,\n", "      sourceFile,\n\t      schemaName\n\t    );\n\t    const enumsProperties = getEnumsProperties(project, sourceFile, schemaName);\n\t    const functionProperties = getFunctionReturnTypes(\n\t      project,\n\t      sourceFile,\n\t      schemaName\n\t    );\n\t    if (enumsProperties.length > 0) {\n", "      types.push('// Enums');\n\t    }\n\t    for (const enumProperty of enumsProperties) {\n\t      const enumName = enumProperty.getName();\n\t      const enumNameType = toPascalCase(enumName, makeSingular);\n\t      types.push(\n\t        `export enum ${enumNameType} {`,\n\t        ...(getEnumValuesText(enumProperty) ?? []),\n\t        '}',\n\t        '\\n'\n", "      );\n\t    }\n\t    if (tablesProperties.length > 0) {\n\t      types.push('// Tables');\n\t    }\n\t    for (const table of tablesProperties) {\n\t      const tableName = table.getName();\n\t      const tableNameType = toPascalCase(tableName, makeSingular);\n\t      types.push(\n\t        `export type ${tableNameType} = Database['${schemaName}']['Tables']['${tableName}']['Row'];`,\n", "        `export type Insert${tableNameType} = Database['${schemaName}']['Tables']['${tableName}']['Insert'];`,\n\t        `export type Update${tableNameType} = Database['${schemaName}']['Tables']['${tableName}']['Update'];`,\n\t        '\\n'\n\t      );\n\t    }\n\t    if (functionProperties.length > 0) {\n\t      types.push('// Functions');\n\t    }\n\t    for (const functionProperty of functionProperties) {\n\t      const functionName = functionProperty.getName();\n", "      const functionNameType = toPascalCase(functionName, makeSingular);\n\t      types.push(\n\t        `export type Args${functionNameType} = Database['${schemaName}']['Functions']['${functionName}']['Args'];`,\n\t        `export type ReturnType${functionNameType} = Database['${schemaName}']['Functions']['${functionName}']['Returns'];`,\n\t        '\\n'\n\t      );\n\t    }\n\t  }\n\t  const fileContent = fs.readFileSync(input, 'utf-8');\n\t  let updatedFileContent = fileContent + '\\n' + types.join('\\n') + '\\n';\n", "  if (prettierConfigPath) {\n\t    updatedFileContent = await prettierFormat(\n\t      updatedFileContent,\n\t      prettierConfigPath\n\t    );\n\t  }\n\t  fs.writeFileSync(output, updatedFileContent);\n\t}\n"]}
{"filename": "src/utils/toPascalCase.ts", "chunked_list": ["import { singular } from 'pluralize';\n\tconst wordToPascalCase = (makeSingular: boolean) => (word: string) => {\n\t  const singularWord = makeSingular ? singular(word) : word;\n\t  return singularWord.charAt(0).toUpperCase() + singularWord.substring(1);\n\t}\n\texport function toPascalCase(str: string, makeSingular: boolean = false) {\n\t  return str\n\t    .split('_')\n\t    .map(wordToPascalCase(makeSingular))\n\t    .join('');\n", "}\n"]}
{"filename": "src/utils/getSchemasProperties.ts", "chunked_list": ["import { Project, SourceFile } from 'ts-morph';\n\texport function getSchemasProperties(project: Project, sourceFile: SourceFile) {\n\t  const databaseInterface = sourceFile.getInterfaceOrThrow('Database');\n\t  const schemasType = project\n\t    .getProgram()\n\t    .getTypeChecker()\n\t    .getTypeAtLocation(databaseInterface);\n\t  const schemasProperties = schemasType.getProperties();\n\t  if (schemasProperties.length < 1)\n\t    throw new Error('No schemas found within the Database property.');\n", "  return schemasProperties;\n\t}\n"]}
{"filename": "src/utils/getEnumsProperties.ts", "chunked_list": ["import { LiteralTypeNode, Project, SourceFile, ts } from 'ts-morph';\n\timport { toCamelCase } from './toCamelCase';\n\timport chalk from 'chalk';\n\texport function getEnumsProperties(\n\t  project: Project,\n\t  sourceFile: SourceFile,\n\t  schema: string\n\t) {\n\t  const databaseInterface = sourceFile.getInterfaceOrThrow('Database');\n\t  const publicProperty = databaseInterface.getPropertyOrThrow(schema);\n", "  const publicType = publicProperty.getType();\n\t  const enumsProperty = publicType\n\t    .getApparentProperties()\n\t    .find((property) => property.getName() === 'Enums');\n\t  if (!enumsProperty) {\n\t    console.log(\n\t      `${chalk.yellow.bold(\n\t        'warn'\n\t      )} No Enums property found within the Database interface for schema ${schema}.`\n\t    );\n", "    return [];\n\t  }\n\t  const enumsType = project\n\t    .getProgram()\n\t    .getTypeChecker()\n\t    .getTypeAtLocation(enumsProperty.getValueDeclarationOrThrow());\n\t  const enumsProperties = enumsType.getProperties();\n\t  if (enumsProperties.length < 1) {\n\t    console.log(\n\t      `${chalk.yellow.bold(\n", "        'warn'\n\t      )} No enums found within the Enums property for schema ${schema}.`\n\t    );\n\t    return [];\n\t  }\n\t  return enumsProperties;\n\t}\n\tfunction getEnumValueLabel(value: LiteralTypeNode) {\n\t  let enumValue = value.getText().replace(/\"/g, '');\n\t  if (enumValue.includes(' ')) {\n", "    enumValue.replace(/ /g, '_');\n\t  }\n\t  if (enumValue.includes('-')) {\n\t    enumValue.replace(/-/g, '_');\n\t  }\n\t  if (enumValue.includes('.')) {\n\t    enumValue = toCamelCase(enumValue, '.');\n\t  }\n\t  return enumValue;\n\t}\n", "function getEnumValueText(value: LiteralTypeNode) {\n\t  return value.getText();\n\t}\n\texport function getEnumValuesText(\n\t  enumProperty: ReturnType<typeof getEnumsProperties>[number]\n\t) {\n\t  const enumValues = enumProperty\n\t    .getValueDeclarationOrThrow()\n\t    .getChildrenOfKind(ts.SyntaxKind.UnionType)\n\t    .flatMap((enumValue) =>\n", "      enumValue.getChildrenOfKind(ts.SyntaxKind.LiteralType)\n\t    );\n\t  return enumValues.map(\n\t    (value) => `  ${getEnumValueLabel(value)} = ${getEnumValueText(value)},`\n\t  );\n\t}\n"]}
{"filename": "src/utils/getTablesProperties.ts", "chunked_list": ["import chalk from 'chalk';\n\timport { Project, SourceFile } from 'ts-morph';\n\texport function getTablesProperties(\n\t  project: Project,\n\t  sourceFile: SourceFile,\n\t  schema: string\n\t) {\n\t  const databaseInterface = sourceFile.getInterfaceOrThrow('Database');\n\t  const publicProperty = databaseInterface.getPropertyOrThrow(schema);\n\t  const publicType = publicProperty.getType();\n", "  const tablesProperty = publicType\n\t    .getApparentProperties()\n\t    .find((property) => property.getName() === 'Tables');\n\t  if (!tablesProperty) {\n\t    console.log(\n\t      `${chalk.yellow.bold(\n\t        'warn'\n\t      )} No Tables property found within the Database interface for schema ${schema}.`\n\t    );\n\t    return [];\n", "  }\n\t  const tablesType = project\n\t    .getProgram()\n\t    .getTypeChecker()\n\t    .getTypeAtLocation(tablesProperty.getValueDeclarationOrThrow());\n\t  const tablesProperties = tablesType.getProperties();\n\t  if (tablesProperties.length < 1) {\n\t    console.log(\n\t      `${chalk.yellow.bold(\n\t        'warn'\n", "      )} No tables found within the Tables property for schema ${schema}.`\n\t    );\n\t    return [];\n\t  }\n\t  return tablesProperties;\n\t}\n"]}
{"filename": "src/utils/index.ts", "chunked_list": ["export * from './getEnumsProperties';\n\texport * from './getSchemasProperties';\n\texport * from './getTablesProperties';\n\texport * from './getFunctionProperties';\n\texport * from './prettierFormat';\n\texport * from './toPascalCase';\n"]}
{"filename": "src/utils/prettierFormat.ts", "chunked_list": ["import { format, resolveConfig } from 'prettier';\n\texport async function prettierFormat(fileContent: string, configPath: string): Promise<string> {\n\t  const prettierConfig = await resolveConfig(configPath);\n\t  const formattedFileContent = format(fileContent, {\n\t    parser: 'typescript',\n\t    ...(prettierConfig || {}),\n\t  });\n\t  return formattedFileContent;\n\t}\n"]}
{"filename": "src/utils/toCamelCase.ts", "chunked_list": ["export function toCamelCase(str: string, delimiter: string = '-') {\n\t  const pattern = new RegExp(('\\\\' + delimiter + '([a-z])'), 'g')\n\t  return str.replace(pattern, (match, capture) => capture.toUpperCase())\n\t}"]}
{"filename": "src/utils/getFunctionProperties.ts", "chunked_list": ["import chalk from 'chalk';\n\timport { Project, SourceFile } from 'ts-morph';\n\texport function getFunctionReturnTypes(\n\t  project: Project,\n\t  sourceFile: SourceFile,\n\t  schema: string\n\t) {\n\t  const databaseInterface = sourceFile.getInterfaceOrThrow('Database');\n\t  const publicProperty = databaseInterface.getPropertyOrThrow(schema);\n\t  const publicType = publicProperty.getType();\n", "  const functionProperty = publicType\n\t    .getApparentProperties()\n\t    .find((property) => property.getName() === 'Functions');\n\t  if (!functionProperty) {\n\t    console.log(\n\t      `${chalk.yellow.bold(\n\t        'warn'\n\t      )} No Functions property found within the Database interface for schema ${schema}.`\n\t    );\n\t    return [];\n", "  }\n\t  const functionType = project\n\t    .getProgram()\n\t    .getTypeChecker()\n\t    .getTypeAtLocation(functionProperty.getValueDeclarationOrThrow());\n\t  const functionProperties = functionType.getProperties();\n\t  if (functionProperties.length < 1) {\n\t    console.log(\n\t      `${chalk.yellow.bold(\n\t        'warn'\n", "      )} No functions found within the Functions property for schema ${schema}.`\n\t    );\n\t    return [];\n\t  }\n\t  return functionProperties;\n\t}\n"]}
