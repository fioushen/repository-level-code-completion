{"filename": "test/stackid.test.ts", "chunked_list": ["import { test, expect, describe } from 'vitest'\n\timport { Capture, Match, Template } from \"aws-cdk-lib/assertions\";\n\timport * as cdk from \"aws-cdk-lib\";\n\timport * as baselime from \"../src/index\";\n\timport { gt } from '../src/utils/filter';\n\tdescribe('stack id', () => {\n\t    test('stackId is added by default', () => {\n\t        const app = new cdk.App();\n\t        const stack = new cdk.Stack(app, 'TestStack');\n\t        baselime.Baselime.init(stack, {\n", "            apiKey: 'xxxx',\n\t        });\n\t        const query = new baselime.Query('abc', {\n\t            parameters: {\n\t                filters: [\n\t                    gt('timestamp', 1234)\n\t                ]\n\t            }\n\t        })\n\t        const template = Template.fromStack(stack);\n", "        template.hasResourceProperties(\"Custom::BaselimeQuery\", {\n\t            Parameters: {\n\t                filters: [\n\t                    \"timestamp > 1234\",\n\t                    \"$baselime.stackId = TestStack\"\n\t                ]\n\t            }\n\t        })\n\t    });\n\t    test('stackId is not added if parameter is set on init', () => {\n", "        const app = new cdk.App();\n\t        const stack = new cdk.Stack(app, 'TestStack');\n\t        baselime.Baselime.init(stack, {\n\t            apiKey: 'xxxx',\n\t            disableStackFilter: true,\n\t        });\n\t        const query = new baselime.Query('abc', {\n\t            parameters: {\n\t                filters: [\n\t                    gt('timestamp', 1234)\n", "                ]\n\t            }\n\t        })\n\t        const template = Template.fromStack(stack);\n\t        template.hasResourceProperties(\"Custom::BaselimeQuery\", {\n\t            Parameters: {\n\t                filters: [\n\t                    \"timestamp > 1234\",\n\t                ]\n\t            }\n", "        })\n\t    })\n\t    test('stackId is not added if parameter is set on query', () => {\n\t        const app = new cdk.App();\n\t        const stack = new cdk.Stack(app, 'TestStack');\n\t        baselime.Baselime.init(stack, {\n\t            apiKey: 'xxxx',\n\t        });\n\t        const query = new baselime.Query('abc', {\n\t            disableStackFilter: true,\n", "            parameters: {\n\t                filters: [\n\t                    gt('timestamp', 1234)\n\t                ]\n\t            }\n\t        })\n\t        const template = Template.fromStack(stack);\n\t        template.hasResourceProperties(\"Custom::BaselimeQuery\", {\n\t            Parameters: {\n\t                filters: [\n", "                    \"timestamp > 1234\",\n\t                ]\n\t            }\n\t        })\n\t    })\n\t});\n"]}
{"filename": "src/config.ts", "chunked_list": ["import { Construct } from \"constructs\";\n\timport { Channel } from './types/alert';\n\tinterface BaselimeConfiguration {\n\t\t/**\n\t\t * The Baselime API key\n\t\t */\n\t\treadonly apiKey: string;\n\t\t/**\n\t\t * The region to deploy this Observability as Code to.\n\t\t *\n", "\t * @default - Defaults to the CDK_DEPLOY_REGION environment variable\n\t\t */\n\t\treadonly region?: string;\n\t\t/**\n\t\t * The name of this service.\n\t\t * \n\t\t * @default - Defaults to the CDK stack name\n\t\t */\n\t\treadonly serviceName?: string;\n\t\t/**\n", "\t * The channel to send all the alerts for this service by default.\n\t\t */\n\t\treadonly defaultChannel?: Channel;\n\t\t/**\n\t\t * Wether or not to add a filter on stack name for all the queries created in this service\n\t\t * When `disableStackFilter` is set to `true`, this filter is removed:\n\t\t * `$baselime.stackId = stackName`\n\t\t * \n\t\t * @default - Defaults to false\n\t\t */\n", "\treadonly disableStackFilter?: boolean;\n\t\t/**\n\t\t * The AWS Account ID where Baselime is deployed.\n\t\t * Change this property only if you have self-deployed the entire Baselime BackEnd\n\t\t * \n\t\t * @default - Defaults to the Baselime AWS Account ID\n\t\t */\n\t\treadonly _account?: string;\n\t}\n\texport namespace Baselime {\n", "\tlet construct: Construct;\n\t\tlet baselimeSecret: string;\n\t\tlet serviceName: string | undefined;\n\t\tlet serviceToken: string;\n\t\tlet defaultChannel: Channel | undefined;\n\t\tlet disableStackFilter: boolean | undefined;\n\t\t/**\n\t\t * Initialize Baselime CDK. Make sure to use this method in the beginning of the stack.\n\t\t *\n\t\t * @param {Construct} target\n", "\t * @param {BaselimeConfiguration} options\n\t\t * @example\n\t\t * import { Baselime } from '@baselime/cdk'\n\t\t * import * as cdk from 'aws-cdk-lib'\n\t\t * import { Construct } from 'constructs'\n\t\t *\n\t\t * export class ExamplesStack extends cdk.Stack {\n\t\t *   constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n\t\t *     super(scope, id, props)\n\t\t *\n", "\t *     Baselime.init(this, {\n\t\t *       apiKey: process.env.BASELIME_API_KEY, // Ideally use SSM or Secrets Manager\n\t\t *       serviceName: 'my-service',\n\t\t *\t\t defaultChannel: { type: \"slack\", targets: [\"baselime-alerts\"] },\n\t\t *     });\n\t\t */\n\t\texport function init(\n\t\t\ttarget: Construct,\n\t\t\toptions: BaselimeConfiguration,\n\t\t) {\n", "\t\tconstruct = target;\n\t\t\tbaselimeSecret = options.apiKey;\n\t\t\tserviceName = options.serviceName;\n\t\t\tserviceToken = `arn:aws:lambda:${options.region || process.env.CDK_DEPLOY_REGION || \"eu-west-1\"\n\t\t\t\t}:${options._account || \"097948374213\"}:function:baselime-orl-cloudformation`;\n\t\t\tdefaultChannel = options.defaultChannel;\n\t\t\tdisableStackFilter = options.disableStackFilter;\n\t\t}\n\t\texport function getConstruct() {\n\t\t\treturn construct;\n", "\t}\n\t\texport function getApiKey() {\n\t\t\treturn baselimeSecret;\n\t\t}\n\t\texport function getServiceName() {\n\t\t\treturn serviceName;\n\t\t}\n\t\texport function getServiceToken() {\n\t\t\treturn serviceToken;\n\t\t}\n", "\texport function getDefaultChannel() {\n\t\t\treturn defaultChannel;\n\t\t}\n\t\texport function getDisableStackFilter() {\n\t\t\treturn disableStackFilter;\n\t\t}\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export interface QueryProps {\n\t\tDescription?: string;\n\t\tService?: string;\n\t\tParameters: {\n\t\t\tdatasets: string[];\n\t\t\tcalculations?: string[];\n\t\t\tfilters?: string[];\n\t\t\tgroupBys?: Array<{\n\t\t\t\ttype: \"string\" | \"number\" | \"boolean\";\n\t\t\t\tvalue: string;\n", "\t\t}>;\n\t\t\torderBy?: {\n\t\t\t\tvalue: string;\n\t\t\t\torder?: \"ASC\" | \"DESC\";\n\t\t\t};\n\t\t\tlimit?: number;\n\t\t\tneedle?: {\n\t\t\t\tvalue: string;\n\t\t\t\tisRegex?: boolean;\n\t\t\t\tmatchCase?: boolean;\n", "\t\t}\n\t\t};\n\t}\n\texport * from \"./resources/query\";\n\texport * from \"./resources/alert\";\n\texport * from \"./resources/dashboard\";\n\texport * from \"./config\";\n\texport * as filter from \"./utils/filter\";\n\texport * as threshold from './utils/threshold';\n\texport * as calc from './utils/calc';"]}
{"filename": "src/utils/filter.ts", "chunked_list": ["/**\n\t * Creates a filter operation object that narrows down the results where the key equals the value.\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @param {string | number | boolean} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function eq(key: string, value: string | number | boolean) {\n\t\treturn { key, value, operation: \"=\" } as const;\n\t}\n\t/**\n", " * Creates a filter operation object that narrows down the results where the key does not equal the value.\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @param {string | number | boolean} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function neq(key: string, value: string | number | boolean) {\n\t\treturn { key, value, operation: \"!=\" } as const;\n\t}\n\t/**\n\t * Creates a filter operation object that narrows down the results where the key is greater than the value.\n", " *  @param {string} key The field in the data used for filtering.\n\t *  @param {number} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function gt(key: string, value: number) {\n\t\treturn { key, value, operation: \">\" } as const;\n\t}\n\t/**\n\t * Creates a filter operation object that narrows down the results where the key is greater than or equal to the value.\n\t *  @param {string} key The field in the data used for filtering.\n", " *  @param {number} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function gte(key: string, value: number) {\n\t\treturn { key, value, operation: \">=\" } as const;\n\t}\n\t/**\n\t * Creates a filter operation object that narrows down the results where the key is less than the value.\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @param {number} value The value for the specified key used for filtering.\n", " *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function lt(key: string, value: number) {\n\t\treturn { key, value, operation: \"<\" } as const;\n\t}\n\t/**\n\t * Creates a filter operation object that narrows down the results where the key is less than or equal the value.\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @param {number} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n", " */\n\texport function lte(key: string, value: number) {\n\t\treturn { key, value, operation: \"<=\" } as const;\n\t}\n\t/**\n\t * Creates a filter operation object that narrows down the results where the key includes the value.\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @param {string} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n", "export function includes(key: string, value: string) {\n\t\treturn { key, value, operation: \"INCLUDES\" } as const;\n\t}\n\t/**\n\t * Creates a filter operation object that narrows down the results where the key does not include the value.\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @param {string} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function notIncludes(key: string, value: string) {\n", "\treturn { key, value, operation: \"DOES_NOT_INCLUDE\" } as const;\n\t}\n\t/**\n\t * Creates a filter operation object that narrows down the results where the key matches the regex.\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @param {RegExp} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function regex(key: string, value: RegExp) {\n\t\treturn { key, value: value.source, operation: \"MATCH_REGEX\" } as const;\n", "}\n\t/**\n\t * Creates a filter operation object that narrows down the results where the key starts with the value.\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @param {string} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function startsWith(key: string, value: string) {\n\t\treturn { key, value: value, operation: \"STARTS_WITH\" } as const;\n\t}\n", "/**\n\t * Creates a filter operation object that narrows down the results where the key is one of the values\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @param {string[]} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function inArray(key: string, value: string[]) {\n\t\treturn { key, value: value, operation: \"IN\" } as const;\n\t}\n\t/**\n", " * Creates a filter operation object that narrows down the results where the key is not one of the values\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @param {string[]} value The value for the specified key used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function notInArray(key: string, value: string[]) {\n\t\treturn { key, value: value, operation: \"NOT_IN\" } as const;\n\t}\n\t/**\n\t * Creates a filter operation object that narrows down the results where the key exists\n", " *  @param {string} key The field in the data used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n\t */\n\texport function exists(key: string) {\n\t    return { key, operation: \"EXISTS\" } as const\n\t}\n\t/**\n\t * Creates a filter operation object that narrows down the results where the key does not exist\n\t *  @param {string} key The field in the data used for filtering.\n\t *  @returns {Object} A filter operation object with the key, value, and operation properties.\n", " */\n\texport function notExists(key: string) {\n\t    return { key, operation: \"NOT_EXISTS\" } as const\n\t}"]}
{"filename": "src/utils/threshold.ts", "chunked_list": ["/**\n\t * Triggers alert where calculation result equals the value.\n\t *  @param {number} value The value used in the comparison\n\t *  @returns {Object} A threshold object\n\t */\n\texport function eq(value: number) {\n\t\treturn { value, operation: \"=\" } as const;\n\t}\n\t/**\n\t * Triggers alert where calculation result does not equal the value.\n", " *  @param {number} value The value used in the comparison\n\t *  @returns {Object} A threshold object\n\t */\n\texport function neq(value: number) {\n\t\treturn { value, operation: \"!=\" } as const;\n\t}\n\t/**\n\t * Triggers alert where calculation result is greater than the value.\n\t *  @param {number} value The value used in the comparison\n\t *  @returns {Object} A threshold object\n", " */\n\texport function gt(value: number) {\n\t\treturn { value, operation: \">\" } as const;\n\t}\n\t/**\n\t * Triggers alert where calculation result is greater than or equal to the value.\n\t *  @param {number} value The value used in the comparison\n\t *  @returns {Object} A threshold object\n\t */\n\texport function gte(value: number) {\n", "\treturn { value, operation: \">=\" } as const;\n\t}\n\t/**\n\t * Triggers alert where calculation result is less than the value.\n\t *  @param {number} value The value used in the comparison\n\t *  @returns {Object} A threshold object\n\t */\n\texport function lt(value: number) {\n\t\treturn { value, operation: \"<\" } as const;\n\t}\n", "/**\n\t * Triggers alert where calculation result is less than or equal to the value.\n\t *  @param {number} value The value used in the comparison\n\t *  @returns {Object} A threshold object\n\t */\n\texport function lte(value: number) {\n\t\treturn { value, operation: \"<=\" } as const;\n\t}"]}
{"filename": "src/utils/calc.ts", "chunked_list": ["export function count(alias?: string) {\n\t  return { operation: \"COUNT\", alias } as const\n\t}\n\texport function countDistinct(key: string, alias?: string) {\n\t  return { operation: \"COUNT_DISTINCT\", key, alias } as const;\n\t}\n\texport function max(key: string, alias?: string) {\n\t  return { operation: \"MAX\", key, alias } as const;\n\t}\n\texport function min(key: string, alias?: string) {\n", "  return { operation: \"MIN\", key, alias } as const;\n\t}\n\texport function sum(key: string, alias?: string) {\n\t  return { operation: \"SUM\", key, alias } as const;\n\t}\n\texport function avg(key: string, alias?: string) {\n\t  return { operation: \"AVG\", key, alias } as const;\n\t}\n\texport function median(key: string, alias?: string) {\n\t  return { operation: \"MEDIAN\", key, alias } as const;\n", "}\n\texport function p001(key: string, alias?: string) {\n\t  return { operation: \"P001\", key, alias } as const;\n\t}\n\texport function p01(key: string, alias?: string) {\n\t  return { operation: \"P01\", key, alias } as const;\n\t}\n\texport function p05(key: string, alias?: string) {\n\t  return { operation: \"P05\", key, alias } as const;\n\t}\n", "export function p10(key: string, alias?: string) {\n\t  return { operation: \"P10\", key, alias } as const;\n\t}\n\texport function p25(key: string, alias?: string) {\n\t  return { operation: \"P25\", key, alias } as const;\n\t}\n\texport function p75(key: string, alias?: string) {\n\t  return { operation: \"P75\", key, alias } as const;\n\t}\n\texport function p90(key: string, alias?: string) {\n", "  return { operation: \"P90\", key, alias } as const;\n\t}\n\texport function p95(key: string, alias?: string) {\n\t  return { operation: \"P95\", key, alias } as const;\n\t}\n\texport function p99(key: string, alias?: string) {\n\t  return { operation: \"P99\", key, alias } as const;\n\t}\n\texport function p999(key: string, alias?: string) {\n\t  return { operation: \"P999\", key, alias } as const;\n", "}\n\texport function stdDev(key: string, alias?: string) {\n\t  return { operation: \"STDDEV\", key, alias } as const;\n\t}\n\texport function variance(key: string, alias?: string) {\n\t  return { operation: \"VARIANCE\", key, alias } as const;\n\t}"]}
{"filename": "src/utils/needle.ts", "chunked_list": ["/**\n\t * Creates a needle object that narrows down the results by searching for the needle in the haystack of events.\n\t *  @param {string | RegExp} value The field in the data used for filtering.\n\t *  @param {Object} params Extra parameters for the search.\n\t *  @returns {Object} A needle object with the value, matchCase, and isRegex properties.\n\t */\n\texport function search(value: string | RegExp, params?: { matchCase: boolean }) {\n\t  return { value, isRegex: value instanceof RegExp, matchCase: params?.matchCase } as const;\n\t}\n"]}
{"filename": "src/utils/service-name.ts", "chunked_list": ["import { Stack } from \"aws-cdk-lib\";\n\timport { Baselime as Config } from \"../config\";\n\texport function getServiceName(stack: Stack): string {\n\t  const s = Config.getServiceName();\n\t  if (s) {\n\t    return s;\n\t  }\n\t  const tags = stack.tags.tagValues();\n\t  const isSST = Object.keys(tags).some((el) => el.includes(\"sst\"));\n\t  if (isSST) {\n", "    return `${tags['sst:stage']}-${tags['sst:app']}`;\n\t  }\n\t  return stack.stackName;\n\t}\n"]}
{"filename": "src/resources/dashboard.ts", "chunked_list": ["import { CfnResource, Stack } from \"aws-cdk-lib\";\n\timport { Baselime as Config } from \"../config\";\n\timport { DashboardProps } from \"../types/dashboard\";\n\timport { getServiceName } from \"../utils/service-name\";\n\texport class Dashboard extends CfnResource {\n\t\tconstructor(id: string, props: DashboardProps) {\n\t\t\tconst stack = Stack.of(Config.getConstruct());\n\t\t\tconst parameters = {\n\t\t\t\t...props.parameters,\n\t\t\t\twidgets: props.parameters.widgets.map(el => ({ ...el, query: el.query.ref }))\n", "\t\t}\n\t\t\tsuper(Config.getConstruct(), id, {\n\t\t\t\ttype: \"Custom::BaselimeDashboard\",\n\t\t\t\tproperties: {\n\t\t\t\t\tid,\n\t\t\t\t\tServiceToken: Config.getServiceToken(),\n\t\t\t\t\tBaselimeApiKey: Config.getApiKey(),\n\t\t\t\t\tDescription: props.description,\n\t\t\t\t\tService: getServiceName(stack),\n\t\t\t\t\tParameters: parameters,\n", "\t\t\t\tOrigin: \"cdk\"\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n"]}
{"filename": "src/resources/query.ts", "chunked_list": ["import { CfnResource, Stack } from \"aws-cdk-lib\";\n\timport { Baselime as Config } from \"../config\";\n\timport { QueryProps, Filter, DeploymentQueryParameters } from \"../types/query\";\n\timport { AlertProps } from \"../types/alert\";\n\timport { Alert } from './alert';\n\timport { getServiceName } from '../utils/service-name';\n\tfunction buildCalculation(cal: { alias?: string; operation: string; key?: string }) {\n\t\tconst short = buildShortCalculation(cal);\n\t\treturn `${short}${cal.alias ? ` as ${cal.alias}` : \"\"}`;\n\t}\n", "function hasDuplicates<T>(array: T[]) {\n\t\treturn (new Set(array)).size !== array.length;\n\t}\n\tfunction buildShortCalculation(cal: { alias?: string; operation: string; key?: string }) {\n\t\tif (cal.operation === \"COUNT\") {\n\t\t\treturn cal.operation;\n\t\t}\n\t\treturn `${cal.operation}(${cal.key})`;\n\t}\n\tfunction getCalculationAlias(cal: { alias?: string; operation: string; key?: string }) {\n", "\treturn cal.alias ? cal.alias : buildShortCalculation(cal);\n\t}\n\texport function stringifyFilter(filter: Filter): string {\n\t\tconst { key, operation, value } = filter;\n\t\tif (!operation) {\n\t\t\treturn `${key} = ${value}`;\n\t\t}\n\t\tif ([\"EXISTS\", \"DOES_NOT_EXIST\"].includes(operation)) {\n\t\t\treturn `${key} ${operation}`;\n\t\t}\n", "\tif ([\"IN\", \"NOT_IN\"].some(o => o === operation)) {\n\t\t\treturn `${key} ${operation} (${value})`;\n\t\t}\n\t\treturn `${key} ${operation} ${value}`;\n\t}\n\t/**\n\t * \n\t */\n\texport class Query<TKey extends string> extends CfnResource {\n\t\tid: string;\n", "\tprops: QueryProps<TKey>\n\t\tconstructor(id: string, props: QueryProps<TKey>) {\n\t\t\tconst stack = Stack.of(Config.getConstruct());\n\t\t\tconst calcs = props.parameters.calculations;\n\t\t\tconst orderByOptions = calcs?.map(cal => getCalculationAlias(cal));\n\t\t\tif (calcs?.length && hasDuplicates(calcs.filter(c => c.alias).map(c => c.alias))) {\n\t\t\t\tthrow Error(\"Aliases must me unique across all calculations / visualisations.\")\n\t\t\t}\n\t\t\tif (props.parameters.orderBy && !orderByOptions?.includes(props.parameters.orderBy.value)) {\n\t\t\t\tthrow Error(\"The orderBy must be present in the calculations / visualisations.\")\n", "\t\t}\n\t\t\tconst disableStackFilter = props.disableStackFilter || Config.getDisableStackFilter();\n\t\t\tif (!disableStackFilter) {\n\t\t\t\tprops.parameters.filters?.push({ operation: \"=\", key: \"$baselime.stackId\", value: stack.stackName })\n\t\t\t}\n\t\t\tconst Parameters: DeploymentQueryParameters = {\n\t\t\t\t...props.parameters,\n\t\t\t\tdatasets: props.parameters.datasets || ['lambda-logs'],\n\t\t\t\tcalculations: props.parameters.calculations ? props.parameters.calculations.map(buildCalculation) : [],\n\t\t\t\tfilters: props.parameters.filters?.map(stringifyFilter),\n", "\t\t\tgroupBys: props.parameters.groupBys?.map(groupBy => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...groupBy,\n\t\t\t\t\t\ttype: groupBy?.type || \"string\"\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\tfilterCombination: props.parameters.filterCombination || \"AND\",\n\t\t\t};\n\t\t\tsuper(Config.getConstruct(), id, {\n\t\t\t\ttype: \"Custom::BaselimeQuery\",\n", "\t\t\tproperties: {\n\t\t\t\t\tid,\n\t\t\t\t\tServiceToken: Config.getServiceToken(),\n\t\t\t\t\tBaselimeApiKey: Config.getApiKey(),\n\t\t\t\t\tDescription: props.description,\n\t\t\t\t\tService: getServiceName(stack),\n\t\t\t\t\tParameters,\n\t\t\t\t\tOrigin: \"cdk\"\n\t\t\t\t},\n\t\t\t});\n", "\t\tthis.id = id;\n\t\t\tthis.props = props;\n\t\t}\n\t\taddAlert(alert: ChangeFields<AlertProps<TKey>, {\n\t\t\tparameters: Omit<AlertProps<TKey>['parameters'], \"query\">\n\t\t}>) {\n\t\t\tconst alertProps = {\n\t\t\t\t...alert,\n\t\t\t\tparameters: {\n\t\t\t\t\t...alert.parameters,\n", "\t\t\t\tquery: this\n\t\t\t\t}\n\t\t\t}\n\t\t\tnew Alert(`${this.id}-alert`, alertProps);\n\t\t}\n\t\taddFilters(filters: QueryProps<string>[\"parameters\"][\"filters\"]) {\n\t\t\tthis.addPropertyOverride('Parameters.filters', [...filters || []])\n\t\t}\n\t};\n\ttype ChangeFields<T, R> = Omit<T, keyof R> & R;\n"]}
{"filename": "src/resources/alert.ts", "chunked_list": ["import { CfnResource, Stack } from \"aws-cdk-lib\";\n\timport { Baselime as Config } from \"../config\";\n\timport { Query } from \"./query\";\n\timport { AlertProps, DeploymentAlertParameters } from \"../types/alert\";\n\timport { QueryProps } from \"../types/query\";\n\timport { getServiceName } from \"../utils/service-name\";\n\texport class Alert<TKey extends string> extends CfnResource {\n\t\tconstructor(id: string, props: AlertProps<TKey>) {\n\t\t\tconst stack = Stack.of(Config.getConstruct());\n\t\t\tconst defaultFrequency = \"1hour\";\n", "\t\tconst defaultWindow = \"1hour\";\n\t\t\tlet Parameters: DeploymentAlertParameters | undefined = undefined;\n\t\t\tif (\"ref\" in props.parameters.query) {\n\t\t\t\tParameters = {\n\t\t\t\t\t...props.parameters,\n\t\t\t\t\tthreshold: `${props.parameters.threshold?.operation || \">\"} ${props.parameters.threshold?.value\n\t\t\t\t\t\t}`,\n\t\t\t\t\tquery: props.parameters.query.ref,\n\t\t\t\t\tfrequency: props.parameters.frequency || defaultFrequency,\n\t\t\t\t\twindow: props.parameters.window || defaultWindow,\n", "\t\t\t};\n\t\t\t}\n\t\t\tif (\"filters\" in props.parameters.query) {\n\t\t\t\tconst query = new Query(`${id}-query`, {\n\t\t\t\t\tparameters: {\n\t\t\t\t\t\t...props.parameters.query,\n\t\t\t\t\t\tcalculations: props.parameters.query.calculations || [\n\t\t\t\t\t\t\t{ operation: \"COUNT\" },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n", "\t\t\t});\n\t\t\t\tParameters = {\n\t\t\t\t\t...props.parameters,\n\t\t\t\t\tthreshold: `${props.parameters.threshold?.operation || \">\"} ${props.parameters.threshold?.value || 0\n\t\t\t\t\t\t}`,\n\t\t\t\t\tquery: query.ref,\n\t\t\t\t\tfrequency: props.parameters.frequency || defaultFrequency,\n\t\t\t\t\twindow: props.parameters.window || defaultWindow,\n\t\t\t\t};\n\t\t\t}\n", "\t\tif (!Parameters) throw new Error(\"Invalid alert parameters. Declare at least one of filters or ref in the query.\")\n\t\t\tsuper(Config.getConstruct(), id, {\n\t\t\t\ttype: \"Custom::BaselimeAlert\",\n\t\t\t\tproperties: {\n\t\t\t\t\tid,\n\t\t\t\t\tServiceToken: Config.getServiceToken(),\n\t\t\t\t\tBaselimeApiKey: Config.getApiKey(),\n\t\t\t\t\tenabled: props.enabled,\n\t\t\t\t\tDescription: props.description,\n\t\t\t\t\tService: getServiceName(stack),\n", "\t\t\t\tParameters,\n\t\t\t\t\tChannels: props.channels || Config.getDefaultChannel() && [Config.getDefaultChannel()],\n\t\t\t\t\tOrigin: \"cdk\",\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t}\n"]}
{"filename": "src/types/dashboard.ts", "chunked_list": ["import { CfnResource } from \"aws-cdk-lib\";\n\texport type DashboardProps = {\n\t\tdescription?: string;\n\t\tparameters: DeploymentDashboardParameters;\n\t};\n\tinterface DeploymentDashboardParameters {\n\t\twidgets: Array<{\n\t\t\tname?: string;\n\t\t\tdescription?: string;\n\t\t\tquery: CfnResource;\n", "\t}>;\n\t}"]}
{"filename": "src/types/query.ts", "chunked_list": ["import { F } from \"ts-toolbelt\";\n\texport type QueryProps<TKey extends string> = {\n\t\tdescription?: string;\n\t\tparameters: QueryParameters<TKey>\n\t\tdisableStackFilter?: boolean\n\t};\n\texport type QueryParameters<TKey extends string> = {\n\t\tdatasets?: Datasets[];\n\t\tfilterCombination?: \"AND\" | \"OR\";\n\t\tfilters: Filter[];\n", "\tneedle?: Needle;\n\t\tcalculations?: never;\n\t\tgroupBys?: never;\n\t\torderBy?: never;\n\t\tlimit?: number;\n\t} | {\n\t\tdatasets?: Datasets[];\n\t\tfilterCombination?: \"AND\" | \"OR\";\n\t\tfilters?: Filter[];\n\t\tneedle?: Needle;\n", "\tcalculations?: Calculation<TKey>[];\n\t\tgroupBys?: QueryGroupBy[];\n\t\torderBy?: {\n\t\t\t// This doesn\"t quite work yet. It should be a union of the key in the filters\n\t\t\tvalue: F.NoInfer<TKey> | \"COUNT\";\n\t\t\torder?: \"ASC\" | \"DESC\";\n\t\t};\n\t\tlimit?: number;\n\t};\n\ttype Needle = {\n", "\tvalue: string;\n\t\tisRegex?: boolean;\n\t\tmatchCase?: boolean;\n\t};\n\texport type QueryGroupBy = {\n\t\ttype?: \"string\" | \"number\" | \"boolean\";\n\t\tvalue: string;\n\t}\n\ttype Datasets =\n\t\t| \"lambda-logs\"\n", "\t| \"cloudwatch-metrics\"\n\t\t| \"apigateway-logs\"\n\t\t| \"cloudtrail\"\n\t\t| \"ecs-logs\"\n\t\t| \"otel\"\n\t\t| \"apprunner-logs\"\n\t\t| \"x-ray\";\n\texport type Calculation<TKey extends string> =\n\t\t| BaseCalculationObject<TKey>\n\t\t| CountCalculation<TKey>;\n", "export type Filter =\n\t\t| { key: Keys; operation: QueryOperationArray; value: string[] }\n\t\t| { key: Keys; operation: QueryOperationNull; value?: never }\n\t\t| {\n\t\t\tkey: Keys;\n\t\t\toperation?: QueryOperationString;\n\t\t\tvalue: string | number | boolean;\n\t\t};\n\ttype Keys =\n\t\t| string\n", "\t| \"$baselime.acount\"\n\t\t| \"$baselime.baselimeId\"\n\t\t| \"$baselime.namespace\"\n\t\t| \"$baselime.region\"\n\t\t| \"$baselime.requestId\"\n\t\t| \"$baselime.service\"\n\t\t| \"$baselime.spanId\"\n\t\t| \"$baselime.traceId\";\n\texport type QueryOperationString =\n\t\t| \"=\"\n", "\t| \"!=\"\n\t\t| \">\"\n\t\t| \">=\"\n\t\t| \"<\"\n\t\t| \"<=\"\n\t\t| \"LIKE\"\n\t\t| \"NOT_LIKE\"\n\t\t| \"INCLUDES\"\n\t\t| \"MATCH_REGEX\"\n\t\t| \"DOES_NOT_INCLUDE\"\n", "\t| \"STARTS_WITH\";\n\texport type QueryOperationArray = \"IN\" | \"NOT_IN\";\n\texport type QueryOperationNull = \"EXISTS\" | \"DOES_NOT_EXIST\";\n\ttype BaseCalculationObject<TKey> = {\n\t\toperation:\n\t\t| \"COUNT_DISTINCT\"\n\t\t| \"MAX\"\n\t\t| \"MIN\"\n\t\t| \"SUM\"\n\t\t| \"AVG\"\n", "\t| \"MEDIAN\"\n\t\t| \"P001\"\n\t\t| \"P01\"\n\t\t| \"P05\"\n\t\t| \"P10\"\n\t\t| \"P25\"\n\t\t| \"P75\"\n\t\t| \"P90\"\n\t\t| \"P95\"\n\t\t| \"P99\"\n", "\t| \"P999\"\n\t\t| \"STDDEV\"\n\t\t| \"VARIANCE\";\n\t\tkey: TKey;\n\t\talias?: TKey;\n\t};\n\ttype CountCalculation<TKey> = {\n\t\toperation: TKey extends \"COUNT\" ? \"COUNT\" : string;\n\t\talias?: TKey;\n\t\tkey?: never;\n", "};\n\texport type DeploymentQueryParameters = {\n\t\tdatasets: string[];\n\t\tcalculations?: string[];\n\t\tfilterCombination: \"AND\" | \"OR\";\n\t\tfilters?: string[];\n\t\tgroupBys?: QueryGroupBy[];\n\t\torderBy?: {\n\t\t\tvalue: string;\n\t\t\torder?: \"ASC\" | \"DESC\";\n", "\t};\n\t\tlimit?: number;\n\t\tneedle?: {\n\t\t\tvalue: string;\n\t\t\tisRegex?: boolean;\n\t\t\tmatchCase?: boolean;\n\t\t}\n\t};\n"]}
{"filename": "src/types/alert.ts", "chunked_list": ["import { CfnResource } from \"aws-cdk-lib\";\n\timport { QueryOperationString, QueryParameters } from \"./query\";\n\texport type AlertProps<TKey extends string> = {\n\t\tdescription?: string;\n\t\tenabled?: boolean;\n\t\tparameters: {\n\t\t\tquery: CfnResource | QueryParameters<TKey>,\n\t\t\tthreshold?: {\n\t\t\t\toperation?: QueryOperationString,\n\t\t\t\tvalue: string | number\n", "\t\t},\n\t\t\tfrequency?: string,\n\t\t\twindow?: string,\n\t\t};\n\t\tchannels?: Channel[];\n\t};\n\texport type Channel = { type: ChannelTypes; targets: string[] }\n\ttype ChannelTypes = \"slack\" | \"webhook\" | \"email\";\n\texport type DeploymentAlertParameters = {\n\t\tquery: string;\n", "\tthreshold: string;\n\t\tfrequency: string;\n\t\twindow: string;\n\t};\n"]}
