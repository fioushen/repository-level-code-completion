{"filename": "tests/didDocument.test.ts", "chunked_list": ["import { describe, it } from 'node:test'\n\timport { DID_DOCUMENTS } from './fixtures/didDocuments'\n\timport assert from 'node:assert'\n\timport { createDidDocumentConstructTest } from './utils/createDidDocumentConstructTest'\n\timport {\n\t  Did,\n\t  DidDocument,\n\t  VerificationMethod,\n\t  DidDocumentError,\n\t  VerificationMethodTypes,\n", "  ServiceTypes,\n\t} from '../src'\n\timport { ZodError } from 'zod'\n\tdescribe('Did Document', () => {\n\t  DID_DOCUMENTS.map(createDidDocumentConstructTest)\n\t  describe('Create did document with builder', () => {\n\t    it('should create basic did document with the builder', () => {\n\t      const doc = new DidDocument({ id: 'did:example:123' })\n\t      assert.deepStrictEqual(doc.toJSON(), { id: 'did:example:123' })\n\t    })\n", "    it('should strip URL parts on `id` field', () => {\n\t      const doc = new DidDocument({ id: 'did:example:123#key-01' })\n\t      assert.deepStrictEqual(doc.toJSON(), { id: 'did:example:123' })\n\t    })\n\t    it('should show undefined properties', () => {\n\t      const doc = new DidDocument({ id: 'did:example:123', someField: 'a' })\n\t      assert.deepStrictEqual(doc.toJSON(), {\n\t        id: 'did:example:123',\n\t        someField: 'a',\n\t      })\n", "    })\n\t    it('should not show undefined properties, if specified inside the toJSON method', () => {\n\t      const doc = new DidDocument({ id: 'did:example:123', someField: 'a' })\n\t      assert.deepStrictEqual(doc.toJSON(['someField']), {\n\t        id: 'did:example:123',\n\t      })\n\t    })\n\t    it('should error when providing a DID URL for the `controller` field', () => {\n\t      assert.throws(\n\t        () =>\n", "          new DidDocument({\n\t            id: 'did:example:123',\n\t            controller: 'did:key:abc/path',\n\t          }),\n\t        ZodError\n\t      )\n\t    })\n\t    it('should error when providing both a `publicKeyJwk` and `publicKeyMultibase` in a verification method', () => {\n\t      assert.throws(\n\t        () =>\n", "          new DidDocument({\n\t            id: 'did:example:123',\n\t            verificationMethod: [\n\t              {\n\t                id: 'did:some:id',\n\t                type: 'verification',\n\t                controller: 'did:example:123',\n\t                publicKeyJwk: { kty: 'keyType' },\n\t                publicKeyMultibase: 'someMultibase',\n\t              },\n", "            ],\n\t          }),\n\t        ZodError\n\t      )\n\t    })\n\t    it('should create a more complex did document with the builder', () => {\n\t      const doc = new DidDocument({ id: 'did:example:123' })\n\t        .addService({\n\t          id: 'some:uri',\n\t          type: ['a', 'b'],\n", "          serviceEndpoint: ['https://google.com', 'https://github.com'],\n\t        })\n\t        .addVerificationMethod({\n\t          id: new Did('did:example:123'),\n\t          type: 'some-type',\n\t          controller: 'did:example:123',\n\t          publicKeyJwk: { kty: 'a' },\n\t        })\n\t        .addController(new Did('did:example:123'), true)\n\t        .addAlsoKnownAs('AKA')\n", "        .addKeyAgreementUnsafe(new Did('did:foo:bar'))\n\t        .addAssertionMethod('did:example:123')\n\t        .addAuthentication({\n\t          controller: 'did:me:123',\n\t          type: 'again-some-other-type',\n\t          id: 'did:cheese:bar',\n\t        })\n\t        .addCapabilityDelegation(\n\t          new VerificationMethod({\n\t            id: 'did:some:id',\n", "            type: 'some-type',\n\t            controller: 'did:me:duh',\n\t          })\n\t        )\n\t        .addCapabilityInvocationUnsafe('did:me:duh')\n\t        .addAssertionMethod({\n\t          id: 'did:key:foobar',\n\t          type: 'a',\n\t          controller: 'did:example:123',\n\t        })\n", "      assert.deepStrictEqual(doc.toJSON(), {\n\t        id: 'did:example:123',\n\t        alsoKnownAs: ['AKA'],\n\t        controller: ['did:example:123'],\n\t        authentication: [\n\t          {\n\t            controller: 'did:me:123',\n\t            type: 'again-some-other-type',\n\t            id: 'did:cheese:bar',\n\t          },\n", "        ],\n\t        verificationMethod: [\n\t          {\n\t            id: 'did:example:123',\n\t            type: 'some-type',\n\t            controller: 'did:example:123',\n\t            publicKeyJwk: { kty: 'a' },\n\t          },\n\t        ],\n\t        assertionMethod: [\n", "          'did:example:123',\n\t          { id: 'did:key:foobar', type: 'a', controller: 'did:example:123' },\n\t        ],\n\t        keyAgreement: ['did:foo:bar'],\n\t        capabilityInvocation: ['did:me:duh'],\n\t        capabilityDelegation: [\n\t          { id: 'did:some:id', type: 'some-type', controller: 'did:me:duh' },\n\t        ],\n\t        service: [\n\t          {\n", "            id: 'some:uri',\n\t            type: ['a', 'b'],\n\t            serviceEndpoint: ['https://google.com', 'https://github.com'],\n\t          },\n\t        ],\n\t      })\n\t    })\n\t    it('should error with duplicate ID in service', () => {\n\t      assert.throws(\n\t        () =>\n", "          new DidDocument({ id: 'did:foo:bar' })\n\t            .addService({\n\t              id: 'some:id',\n\t              type: 'some-type',\n\t              serviceEndpoint: 'https://github.com',\n\t            })\n\t            .addService({\n\t              id: 'some:id',\n\t              type: 'some-type',\n\t              serviceEndpoint: 'https://github.com',\n", "            }),\n\t        ZodError\n\t      )\n\t    })\n\t    it('should error with duplicate ID in verificationMethod reference', () => {\n\t      assert.throws(\n\t        () =>\n\t          new DidDocument({ id: 'did:foo:bar' })\n\t            .addAuthentication({\n\t              id: 'did:url:ref#1',\n", "              type: 'some-type',\n\t              controller: 'did:foo:bar',\n\t            })\n\t            .addAuthentication({\n\t              id: 'did:url:ref#1',\n\t              type: 'some-type',\n\t              controller: 'did:foo:bar',\n\t            }),\n\t        ZodError\n\t      )\n", "    })\n\t    it('should error when the verification method reference is not inside the verification method', () => {\n\t      assert.throws(\n\t        () =>\n\t          new DidDocument({ id: 'did:foo:bar' }).addAuthentication(\n\t            'did:example:key#01'\n\t          ),\n\t        DidDocumentError\n\t      )\n\t    })\n", "    it('should not error when the verification method reference is not inside the verification method, but using unsafe', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:foo:bar',\n\t      }).addAuthenticationUnsafe('did:example:key#01')\n\t      assert.deepStrictEqual(doc.toJSON(), {\n\t        id: 'did:foo:bar',\n\t        authentication: ['did:example:key#01'],\n\t      })\n\t    })\n\t  })\n", "  describe('Dereferencing to verification method', () => {\n\t    it('should find correctly to the associated verification method', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:example:bar',\n\t      }).addVerificationMethod({\n\t        id: 'did:example:bar#01',\n\t        type: 'some-type',\n\t        controller: 'did:example:bar',\n\t        publicKeyJwk: { kty: 'some-kty' },\n\t      })\n", "      assert.deepStrictEqual(\n\t        doc.findVerificationMethodByDidUrl('did:example:bar#01').toJSON(),\n\t        {\n\t          id: 'did:example:bar#01',\n\t          type: 'some-type',\n\t          controller: 'did:example:bar',\n\t          publicKeyJwk: { kty: 'some-kty' },\n\t        }\n\t      )\n\t    })\n", "    it('should find safely to the associated verification method', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:example:bar',\n\t      }).addVerificationMethod({\n\t        id: 'did:example:bar#01',\n\t        type: 'some-type',\n\t        controller: 'did:example:bar',\n\t        publicKeyJwk: { kty: 'some-kty' },\n\t      })\n\t      assert.deepStrictEqual(\n", "        doc\n\t          .safeFindToVerificationMethodByDidUrl('did:example:bar#01')\n\t          ?.toJSON(),\n\t        {\n\t          id: 'did:example:bar#01',\n\t          type: 'some-type',\n\t          controller: 'did:example:bar',\n\t          publicKeyJwk: { kty: 'some-kty' },\n\t        }\n\t      )\n", "    })\n\t    it('should find safely to undefined if the verification method does not exist', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:example:bar',\n\t      })\n\t      assert.strictEqual(\n\t        doc.safeFindToVerificationMethodByDidUrl('did:example:bar#01'),\n\t        undefined\n\t      )\n\t    })\n", "    it('should not find if the verification method does not exist', () => {\n\t      assert.throws(() => {\n\t        const doc = new DidDocument({\n\t          id: 'did:example:bar',\n\t        })\n\t        doc.findVerificationMethodByDidUrl('did:example:bar#01')\n\t      }, DidDocumentError)\n\t    })\n\t  })\n\t  describe('Finding items in the did Document', () => {\n", "    it('should find the service by type', () => {\n\t      const doc = new DidDocument({ id: 'did:example:123' }).addService({\n\t        id: 'did:example:123#service-1',\n\t        type: 'some-type',\n\t        serviceEndpoint: 'https://example.org',\n\t      })\n\t      assert.deepStrictEqual(doc.findServiceByType('some-type').toJSON(), {\n\t        id: 'did:example:123#service-1',\n\t        type: 'some-type',\n\t        serviceEndpoint: 'https://example.org',\n", "      })\n\t    })\n\t    it('should find the service by id', () => {\n\t      const doc = new DidDocument({ id: 'did:example:123' }).addService({\n\t        id: 'did:example:123#service-1',\n\t        type: 'some-type',\n\t        serviceEndpoint: 'https://example.org',\n\t      })\n\t      assert.deepStrictEqual(\n\t        doc.findServiceById('did:example:123#service-1').toJSON(),\n", "        {\n\t          id: 'did:example:123#service-1',\n\t          type: 'some-type',\n\t          serviceEndpoint: 'https://example.org',\n\t        }\n\t      )\n\t    })\n\t    it('should not find the service if the type does not exist', () => {\n\t      const doc = new DidDocument({ id: 'did:example:123' }).addService({\n\t        id: 'did:example:123#service-1',\n", "        type: 'some-type',\n\t        serviceEndpoint: 'https://example.org',\n\t      })\n\t      assert.throws(\n\t        () => doc.findServiceByType('some-other-type'),\n\t        DidDocumentError\n\t      )\n\t    })\n\t    it('should not find the service if the id does not exist', () => {\n\t      const doc = new DidDocument({ id: 'did:example:123' }).addService({\n", "        id: 'did:example:123#service-1',\n\t        type: 'some-type',\n\t        serviceEndpoint: 'https://example.org',\n\t      })\n\t      assert.throws(\n\t        () => doc.findServiceById('did:example:123#service-2'),\n\t        DidDocumentError\n\t      )\n\t    })\n\t    it('should find the verification method by purpose and type', () => {\n", "      const doc = new DidDocument({ id: 'did:example:123' }).addKeyAgreement({\n\t        id: 'did:example:123#key-1',\n\t        type: 'some-type',\n\t        controller: 'did:example:123',\n\t      })\n\t      assert.deepStrictEqual(\n\t        doc\n\t          .findVerificationMethodByTypeAndPurpose('some-type', 'keyAgreement')\n\t          .toJSON(),\n\t        {\n", "          id: 'did:example:123#key-1',\n\t          type: 'some-type',\n\t          controller: 'did:example:123',\n\t        }\n\t      )\n\t    })\n\t    it('should find the verification method by purpose and type with reference', () => {\n\t      const doc = new DidDocument({ id: 'did:example:123' })\n\t        .addVerificationMethod({\n\t          id: 'did:example:123#key-1',\n", "          type: 'some-type',\n\t          controller: 'did:example:123',\n\t        })\n\t        .addKeyAgreement('did:example:123#key-1')\n\t      assert.deepStrictEqual(\n\t        doc\n\t          .findVerificationMethodByTypeAndPurpose('some-type', 'keyAgreement')\n\t          .toJSON(),\n\t        {\n\t          id: 'did:example:123#key-1',\n", "          type: 'some-type',\n\t          controller: 'did:example:123',\n\t        }\n\t      )\n\t    })\n\t    it('should not find the verification method if the type does not exist', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:example:123',\n\t      }).addVerificationMethod({\n\t        id: 'did:example:123#key-1',\n", "        type: 'some-type',\n\t        controller: 'did:example:123',\n\t      })\n\t      assert.throws(\n\t        () =>\n\t          doc.findVerificationMethodByTypeAndPurpose(\n\t            'some-other-type',\n\t            'verificationMethod'\n\t          ),\n\t        DidDocumentError\n", "      )\n\t    })\n\t    it('should not find the verification method if the purpose does not match', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:example:123',\n\t      }).addCapabilityDelegation({\n\t        id: 'did:example:123#key-1',\n\t        type: 'some-type',\n\t        controller: 'did:example:123',\n\t      })\n", "      assert.throws(\n\t        () =>\n\t          doc.findVerificationMethodByTypeAndPurpose(\n\t            'some-type',\n\t            'keyAgreement'\n\t          ),\n\t        DidDocumentError\n\t      )\n\t    })\n\t  })\n", "  describe('validate the registered types for verification methods and services', () => {\n\t    it('should validate a correct type of a verification method by id', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:example:123',\n\t        verificationMethod: [\n\t          {\n\t            id: 'did:example:123#key-1',\n\t            type: VerificationMethodTypes.JsonWebKey2020,\n\t            controller: 'did:example:123',\n\t          },\n", "        ],\n\t      })\n\t      assert(doc.isVerificationMethodTypeRegistered('did:example:123#key-1'))\n\t    })\n\t    it('should validate an custom added type of a verification method by id', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:example:123',\n\t        verificationMethod: [\n\t          {\n\t            id: 'did:example:123#key-1',\n", "            type: 'some-added-type',\n\t            controller: 'did:example:123',\n\t          },\n\t        ],\n\t      })\n\t      assert(\n\t        doc.isVerificationMethodTypeRegistered(\n\t          'did:example:123#key-1',\n\t          'some-added-type'\n\t        )\n", "      )\n\t    })\n\t    it('should not validate an incorrect type of a verification method by id', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:example:123',\n\t        verificationMethod: [\n\t          {\n\t            id: 'did:example:123#key-1',\n\t            type: 'some-incorrect-type',\n\t            controller: 'did:example:123',\n", "          },\n\t        ],\n\t      })\n\t      assert(\n\t        doc.isVerificationMethodTypeRegistered('did:example:123#key-1') ===\n\t          false\n\t      )\n\t    })\n\t    it('should validate a correct type of a service by id', () => {\n\t      const doc = new DidDocument({\n", "        id: 'did:example:123',\n\t        service: [\n\t          {\n\t            id: 'did:example:some:id',\n\t            type: ServiceTypes.LinkedDomains,\n\t            serviceEndpoint: 'https://example.org',\n\t          },\n\t        ],\n\t      })\n\t      assert(doc.isServiceTypeRegistered('did:example:some:id'))\n", "    })\n\t    it('should validate a correct type of a service by id', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:example:123',\n\t        service: [\n\t          {\n\t            id: 'did:example:some:id',\n\t            type: 'some-added-type',\n\t            serviceEndpoint: 'https://example.org',\n\t          },\n", "        ],\n\t      })\n\t      assert(\n\t        doc.isServiceTypeRegistered('did:example:some:id', 'some-added-type')\n\t      )\n\t    })\n\t    it('should not validate an incorrect type of a service by id', () => {\n\t      const doc = new DidDocument({\n\t        id: 'did:example:123',\n\t        service: [\n", "          {\n\t            id: 'did:example:some:id',\n\t            type: 'some-bad-type',\n\t            serviceEndpoint: 'https://example.org',\n\t          },\n\t        ],\n\t      })\n\t      assert(doc.isServiceTypeRegistered('did:example:some:id') === false)\n\t    })\n\t  })\n", "})\n"]}
{"filename": "tests/did.test.ts", "chunked_list": ["import { Did } from '../src'\n\timport assert from 'node:assert'\n\timport { describe, it } from 'node:test'\n\timport { DIDS } from './fixtures/dids'\n\timport {\n\t  createDidExtractPartsTest,\n\t  createDidExtractUrlPartsTest,\n\t  createDidIsDidUrlValidationTest,\n\t  createDidValidationTest,\n\t} from './utils'\n", "describe('Did', (_) => {\n\t  describe('Creation', () => {\n\t    it('should create a new did', () => {\n\t      const didUrl = 'did:key:abc'\n\t      const did = new Did(didUrl)\n\t      assert.strictEqual(did.did, didUrl)\n\t    })\n\t    it('should create a new did from a did-url', () => {\n\t      const didUrl = 'did:key:abc/some-path?versionId=1#key-1'\n\t      const did = new Did(didUrl)\n", "      assert.deepStrictEqual(did.toUrl(), didUrl)\n\t    })\n\t    it('should create a new did via the builder pattern', () => {\n\t      const did = new Did('did:key:abc')\n\t        .withPath('some-path')\n\t        .withQuery({ versionId: '1' })\n\t        .withFragment('key-1')\n\t      assert.deepStrictEqual(\n\t        did.toUrl(),\n\t        'did:key:abc/some-path?versionId=1#key-1'\n", "      )\n\t    })\n\t  })\n\t  describe('Validation', () => {\n\t    describe('Validate did', () => {\n\t      Object.keys(DIDS).forEach(createDidValidationTest)\n\t    })\n\t    describe('Validate whether did is url', () => {\n\t      Object.entries(DIDS).forEach(([did, expected]) =>\n\t        createDidIsDidUrlValidationTest(\n", "          did,\n\t          Boolean(\n\t            expected.urlParts.path ||\n\t              expected.urlParts.query ||\n\t              expected.urlParts.fragment ||\n\t              expected.urlParts.parameters\n\t          )\n\t        )\n\t      )\n\t    })\n", "  })\n\t  describe('Extraction', () => {\n\t    describe('Extract did parts', () => {\n\t      Object.entries(DIDS).forEach(([did, expected]) =>\n\t        createDidExtractPartsTest(did, expected.parts)\n\t      )\n\t    })\n\t    describe('Extract did url parts', () => {\n\t      Object.entries(DIDS).forEach(([did, expected]) =>\n\t        createDidExtractUrlPartsTest(did, expected.urlParts)\n", "      )\n\t    })\n\t  })\n\t  describe('Modify url parts', () => {\n\t    const baseDid = 'did:key:abc'\n\t    describe('Path', () => {\n\t      it('should add a new path (withPath)', () => {\n\t        const did = new Did(baseDid)\n\t        did.withPath('test')\n\t        assert.strictEqual(did.didUrlParts.path, 'test')\n", "      })\n\t      it('should add a new path (addPath)', () => {\n\t        const did = new Did(baseDid)\n\t        did.addPath('test')\n\t        assert.strictEqual(did.didUrlParts.path, 'test')\n\t      })\n\t      it('should append a new path', () => {\n\t        const did = new Did(baseDid)\n\t        did.addPath('test').addPath('testTwo')\n\t        assert.strictEqual(did.didUrlParts.path, 'test/testTwo')\n", "      })\n\t      it('should remove the path', () => {\n\t        const did = new Did(baseDid)\n\t        did.addPath('test').removePath()\n\t        assert.strictEqual(did.didUrlParts.path, undefined)\n\t      })\n\t    })\n\t    describe('Query', () => {\n\t      it('should add a new query (withQuery)', () => {\n\t        const did = new Did(baseDid)\n", "        did.withQuery({ a: 'b' })\n\t        assert.deepStrictEqual(did.didUrlParts.query, { a: 'b' })\n\t      })\n\t      it('should add a new query (addQuery)', () => {\n\t        const did = new Did(baseDid)\n\t        did.addQuery({ a: 'b' })\n\t        assert.deepStrictEqual(did.didUrlParts.query, { a: 'b' })\n\t      })\n\t      it('should append a new query', () => {\n\t        const did = new Did(baseDid)\n", "        did.addQuery({ a: 'b' }).addQuery({ c: 'd' })\n\t        assert.deepStrictEqual(did.didUrlParts.query, { a: 'b', c: 'd' })\n\t      })\n\t      it('should remove the query', () => {\n\t        const did = new Did(baseDid)\n\t        did.addQuery({ a: 'b' }).removeQuery()\n\t        assert.strictEqual(did.didUrlParts.query, undefined)\n\t      })\n\t    })\n\t    describe('Fragment', () => {\n", "      it('should add a new fragment', () => {\n\t        const did = new Did(baseDid)\n\t        did.withFragment('a')\n\t        assert.strictEqual(did.didUrlParts.fragment, 'a')\n\t      })\n\t      it('should remove the fragment', () => {\n\t        const did = new Did(baseDid)\n\t        did.withFragment('a').removeFragment()\n\t        assert.strictEqual(did.didUrlParts.fragment, undefined)\n\t      })\n", "    })\n\t    describe('Parameters', () => {\n\t      it('should add a new parameter', () => {\n\t        const did = new Did(baseDid)\n\t        did.addParameterKey('a').addQuery({ a: 'b' })\n\t        assert.deepStrictEqual(did.didUrlParts.parameters, { a: 'b' })\n\t      })\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/fixtures/dids.ts", "chunked_list": ["import { DidParts, DidUrlParts } from 'did'\n\texport const DIDS: Record<string, { parts: DidParts; urlParts: DidUrlParts }> =\n\t  {\n\t    'did:key:z6Mkon4zmgRrGa5zsXSM3irBdFqRrzQdQuHkmnViw4Bjie57#z6Mkon4zmgRrGa5zsXSM3irBdFqRrzQdQuHkmnViw4Bjie57':\n\t      {\n\t        parts: {\n\t          scheme: 'did',\n\t          method: 'key',\n\t          namespaces: undefined,\n\t          identifier: 'z6Mkon4zmgRrGa5zsXSM3irBdFqRrzQdQuHkmnViw4Bjie57',\n", "        },\n\t        urlParts: {\n\t          path: undefined,\n\t          query: undefined,\n\t          fragment: 'z6Mkon4zmgRrGa5zsXSM3irBdFqRrzQdQuHkmnViw4Bjie57',\n\t          parameters: undefined,\n\t        },\n\t      },\n\t    'did:key:z6MktP1rfftmkqV4HCCiRsmNj4tgbisxwocEVry6mKHoNiVu#z6MktP1rfftmkqV4HCCiRsmNj4tgbisxwocEVry6mKHoNiVu':\n\t      {\n", "        parts: {\n\t          scheme: 'did',\n\t          method: 'key',\n\t          namespaces: undefined,\n\t          identifier: 'z6MktP1rfftmkqV4HCCiRsmNj4tgbisxwocEVry6mKHoNiVu',\n\t        },\n\t        urlParts: {\n\t          path: undefined,\n\t          query: undefined,\n\t          fragment: 'z6MktP1rfftmkqV4HCCiRsmNj4tgbisxwocEVry6mKHoNiVu',\n", "          parameters: undefined,\n\t        },\n\t      },\n\t    'did:sov:2wJPyULfLLnYTEFYzByfUR': {\n\t      parts: {\n\t        scheme: 'did',\n\t        method: 'sov',\n\t        namespaces: undefined,\n\t        identifier: '2wJPyULfLLnYTEFYzByfUR',\n\t      },\n", "      urlParts: {\n\t        path: undefined,\n\t        query: undefined,\n\t        fragment: undefined,\n\t        parameters: undefined,\n\t      },\n\t    },\n\t    'did:sov:HR6vs6GEZ8rHaVgjg2WodM': {\n\t      parts: {\n\t        scheme: 'did',\n", "        method: 'sov',\n\t        namespaces: undefined,\n\t        identifier: 'HR6vs6GEZ8rHaVgjg2WodM',\n\t      },\n\t      urlParts: {\n\t        path: undefined,\n\t        query: undefined,\n\t        fragment: undefined,\n\t        parameters: undefined,\n\t      },\n", "    },\n\t    'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w': {\n\t      parts: {\n\t        scheme: 'did',\n\t        method: 'ion',\n\t        namespaces: undefined,\n\t        identifier: 'EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w',\n\t      },\n\t      urlParts: {\n\t        path: undefined,\n", "        query: undefined,\n\t        fragment: undefined,\n\t        parameters: undefined,\n\t      },\n\t    },\n\t    'did:ala:quor:redT:ec27f358fd0d11d8934ceb51305622ae79b6ad15': {\n\t      parts: {\n\t        scheme: 'did',\n\t        method: 'ala',\n\t        namespaces: ['quor', 'redT'],\n", "        identifier: 'ec27f358fd0d11d8934ceb51305622ae79b6ad15',\n\t      },\n\t      urlParts: {\n\t        path: undefined,\n\t        query: undefined,\n\t        fragment: undefined,\n\t        parameters: undefined,\n\t      },\n\t    },\n\t    'did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734': {\n", "      parts: {\n\t        scheme: 'did',\n\t        method: 'evan',\n\t        namespaces: ['testcore'],\n\t        identifier: '0x126E901F6F408f5E260d95c62E7c73D9B60fd734',\n\t      },\n\t      urlParts: {\n\t        path: undefined,\n\t        query: undefined,\n\t        fragment: undefined,\n", "        parameters: undefined,\n\t      },\n\t    },\n\t    'did:cheqd:testnet:55dbc8bf-fba3-4117-855c-1e0dc1d3bb47': {\n\t      parts: {\n\t        scheme: 'did',\n\t        method: 'cheqd',\n\t        namespaces: ['testnet'],\n\t        identifier: '55dbc8bf-fba3-4117-855c-1e0dc1d3bb47',\n\t      },\n", "      urlParts: {\n\t        path: undefined,\n\t        query: undefined,\n\t        fragment: undefined,\n\t        parameters: undefined,\n\t      },\n\t    },\n\t    'did:key:abc': {\n\t      parts: {\n\t        scheme: 'did',\n", "        method: 'key',\n\t        namespaces: undefined,\n\t        identifier: 'abc',\n\t      },\n\t      urlParts: {\n\t        path: undefined,\n\t        query: undefined,\n\t        fragment: undefined,\n\t        parameters: undefined,\n\t      },\n", "    },\n\t    'did:key:abc/some-path?versionId=1#key-1': {\n\t      parts: {\n\t        scheme: 'did',\n\t        method: 'key',\n\t        namespaces: undefined,\n\t        identifier: 'abc',\n\t      },\n\t      urlParts: {\n\t        path: 'some-path',\n", "        query: { versionId: '1' },\n\t        fragment: 'key-1',\n\t        parameters: { versionId: '1' },\n\t      },\n\t    },\n\t    'did:example:123456?versionId=1': {\n\t      parts: {\n\t        scheme: 'did',\n\t        method: 'example',\n\t        namespaces: undefined,\n", "        identifier: '123456',\n\t      },\n\t      urlParts: {\n\t        path: undefined,\n\t        query: { versionId: '1' },\n\t        fragment: undefined,\n\t        parameters: { versionId: '1' },\n\t      },\n\t    },\n\t    'did:example:123#public-key-0': {\n", "      parts: {\n\t        scheme: 'did',\n\t        method: 'example',\n\t        namespaces: undefined,\n\t        identifier: '123',\n\t      },\n\t      urlParts: {\n\t        path: undefined,\n\t        query: undefined,\n\t        fragment: 'public-key-0',\n", "        parameters: undefined,\n\t      },\n\t    },\n\t    'did:example:123?service=agent&relativeRef=/credentials#degree': {\n\t      parts: {\n\t        scheme: 'did',\n\t        method: 'example',\n\t        namespaces: undefined,\n\t        identifier: '123',\n\t      },\n", "      urlParts: {\n\t        path: undefined,\n\t        query: { service: 'agent', relativeRef: '/credentials' },\n\t        fragment: 'degree',\n\t        parameters: { service: 'agent', relativeRef: '/credentials' },\n\t      },\n\t    },\n\t    'did:example:123?service=files&relativeRef=/resume.pdf': {\n\t      parts: {\n\t        scheme: 'did',\n", "        method: 'example',\n\t        namespaces: undefined,\n\t        identifier: '123',\n\t      },\n\t      urlParts: {\n\t        path: undefined,\n\t        query: { service: 'files', relativeRef: '/resume.pdf' },\n\t        fragment: undefined,\n\t        parameters: { service: 'files', relativeRef: '/resume.pdf' },\n\t      },\n", "    },\n\t    'did:example:123#_Qq0UL2Fq651Q0Fjd6TvnYE-faHiOpRlPVQcY_-tA4A': {\n\t      parts: {\n\t        scheme: 'did',\n\t        method: 'example',\n\t        namespaces: undefined,\n\t        identifier: '123',\n\t      },\n\t      urlParts: {\n\t        path: undefined,\n", "        query: undefined,\n\t        fragment: '_Qq0UL2Fq651Q0Fjd6TvnYE-faHiOpRlPVQcY_-tA4A',\n\t        parameters: undefined,\n\t      },\n\t    },\n\t  }\n"]}
{"filename": "tests/fixtures/didDocuments.ts", "chunked_list": ["import { DidDocumentOptions } from '../../src'\n\texport const DID_DOCUMENTS: Array<DidDocumentOptions> = [\n\t  {\n\t    id: 'did:example:foobar',\n\t  },\n\t  {\n\t    id: 'did:example:123456789abcdefghi',\n\t    verificationMethod: [\n\t      {\n\t        id: 'did:example:123#_Qq0UL2Fq651Q0Fjd6TvnYE-faHiOpRlPVQcY_-tA4A',\n", "        type: 'JsonWebKey2020',\n\t        controller: 'did:example:123',\n\t        publicKeyJwk: {\n\t          crv: 'Ed25519',\n\t          jsldkfalskd: 'asldhfsadj',\n\t          x: 'VCpo2LMLhn6iWku8MKvSLg2ZAoC-nlOyPVQaO3FxVeQ',\n\t          kty: 'OKP',\n\t          kid: '_Qq0UL2Fq651Q0Fjd6TvnYE-faHiOpRlPVQcY_-tA4A',\n\t        },\n\t      },\n", "      {\n\t        id: 'did:example:123456789abcdefghi#keys-1',\n\t        type: 'Ed25519VerificationKey2020',\n\t        controller: 'did:example:pqrstuvwxyz0987654321',\n\t        publicKeyMultibase: 'zH3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV',\n\t      },\n\t    ],\n\t  },\n\t  {\n\t    '@context': [\n", "      'https://www.w3.org/ns/did/v1',\n\t      'https://w3id.org/security/suites/ed25519-2020/v1',\n\t    ],\n\t    id: 'did:example:123',\n\t    authentication: [\n\t      {\n\t        id: 'did:example:123#z6MkecaLyHuYWkayBDLw5ihndj3T1m6zKTGqau3A51G7RBf3',\n\t        type: 'Ed25519VerificationKey2020', // external (property value)\n\t        controller: 'did:example:123',\n\t        publicKeyMultibase: 'zAKJP3f7BD6W4iWEQ9jwndVTCBq8ua2Utt8EEjJ6Vxsf',\n", "      },\n\t    ],\n\t    capabilityInvocation: [\n\t      {\n\t        id: 'did:example:123#z6MkhdmzFu659ZJ4XKj31vtEDmjvsi5yDZG5L7Caz63oP39k',\n\t        type: 'Ed25519VerificationKey2020', // external (property value)\n\t        controller: 'did:example:123',\n\t        publicKeyMultibase: 'z4BWwfeqdp1obQptLLMvPNgBw48p7og1ie6Hf9p5nTpNN',\n\t      },\n\t    ],\n", "    capabilityDelegation: [\n\t      {\n\t        id: 'did:example:123#z6Mkw94ByR26zMSkNdCUi6FNRsWnc2DFEeDXyBGJ5KTzSWyi',\n\t        type: 'Ed25519VerificationKey2020', // external (property value)\n\t        controller: 'did:example:123',\n\t        publicKeyMultibase: 'zHgo9PAmfeoxHG8Mn2XHXamxnnSwPpkyBHAMNF3VyXJCL',\n\t      },\n\t    ],\n\t    assertionMethod: [\n\t      {\n", "        id: 'did:example:123#z6MkiukuAuQAE8ozxvmahnQGzApvtW7KT5XXKfojjwbdEomY',\n\t        type: 'Ed25519VerificationKey2020', // external (property value)\n\t        controller: 'did:example:123',\n\t        publicKeyMultibase: 'z5TVraf9itbKXrRvt2DSS95Gw4vqU3CHAdetoufdcKazA',\n\t      },\n\t    ],\n\t  },\n\t  {\n\t    '@context': [\n\t      'https://www.w3.org/ns/did/v1',\n", "      'https://w3id.org/security/suites/jws-2020/v1',\n\t    ],\n\t    id: 'did:example:method-id',\n\t    verificationMethod: [\n\t      {\n\t        id: 'did:example:123#key-0',\n\t        type: 'JsonWebKey2020',\n\t        controller: 'did:example:123',\n\t        publicKeyJwk: {\n\t          kty: 'OKP', // external (property name)\n", "          crv: 'Ed25519', // external (property name)\n\t          x: 'VCpo2LMLhn6iWku8MKvSLg2ZAoC-nlOyPVQaO3FxVeQ', // external (property name)\n\t        },\n\t      },\n\t      {\n\t        id: 'did:example:123#key-1',\n\t        type: 'JsonWebKey2020',\n\t        controller: 'did:example:123',\n\t        publicKeyJwk: {\n\t          kty: 'OKP', // external (property name)\n", "          crv: 'X25519', // external (property name)\n\t          x: 'pE_mG098rdQjY3MKK2D5SUQ6ZOEW3a6Z6T7Z4SgnzCE', // external (property name)\n\t        },\n\t      },\n\t      {\n\t        id: 'did:example:123#key-2',\n\t        type: 'JsonWebKey2020',\n\t        controller: 'did:example:123',\n\t        publicKeyJwk: {\n\t          kty: 'EC', // external (property name)\n", "          crv: 'secp256k1', // external (property name)\n\t          x: 'Z4Y3NNOxv0J6tCgqOBFnHnaZhJF6LdulT7z8A-2D5_8', // external (property name)\n\t          y: 'i5a2NtJoUKXkLm6q8nOEu9WOkso1Ag6FTUT6k_LMnGk', // external (property name)\n\t        },\n\t      },\n\t      {\n\t        id: 'did:example:123#key-3',\n\t        type: 'JsonWebKey2020',\n\t        controller: 'did:example:123',\n\t        publicKeyJwk: {\n", "          kty: 'EC', // external (property name)\n\t          crv: 'secp256k1', // external (property name)\n\t          x: 'U1V4TVZVMUpUa0ZVU1NBcU9CRm5IbmFaaEpGNkxkdWx', // external (property name)\n\t          y: 'i5a2NtJoUKXkLm6q8nOEu9WOkso1Ag6FTUT6k_LMnGk', // external (property name)\n\t        },\n\t      },\n\t      {\n\t        id: 'did:example:123#key-4',\n\t        type: 'JsonWebKey2020',\n\t        controller: 'did:example:123',\n", "        publicKeyJwk: {\n\t          kty: 'EC', // external (property name)\n\t          crv: 'P-256', // external (property name)\n\t          x: 'Ums5WVgwRkRTVVFnU3k5c2xvZllMbEcwM3NPRW91ZzN', // external (property name)\n\t          y: 'nDQW6XZ7b_u2Sy9slofYLlG03sOEoug3I0aAPQ0exs4', // external (property name)\n\t        },\n\t      },\n\t      {\n\t        id: 'did:example:123#key-5',\n\t        type: 'JsonWebKey2020',\n", "        controller: 'did:example:123',\n\t        publicKeyJwk: {\n\t          kty: 'EC', // external (property name)\n\t          crv: 'P-384', // external (property name)\n\t          x: 'VUZKSlUwMGdpSXplekRwODhzX2N4U1BYdHVYWUZsaXVDR25kZ1U0UXA4bDkxeHpE', // external (property name)\n\t          y: 'jq4QoAHKiIzezDp88s_cxSPXtuXYFliuCGndgU4Qp8l91xzD1spCmFIzQgVjqvcP', // external (property name)\n\t        },\n\t      },\n\t      {\n\t        id: 'did:example:123#key-6',\n", "        type: 'JsonWebKey2020',\n\t        controller: 'did:example:123',\n\t        publicKeyJwk: {\n\t          kty: 'EC', // external (property name)\n\t          crv: 'P-521', // external (property name)\n\t          x: 'VTI5c1lYSmZWMmx1WkhNZ0dQTXhaYkhtSnBEU3UtSXZwdUtpZ0VOMnB6Z1d0U28tLVJ3ZC1uNzhuclduWnplRGMx', // external (property name)\n\t          y: 'UW5WNVgwSnBkR052YVc0Z1VqY1B6LVpoZWNaRnliT3FMSUpqVk9sTEVUSDd1UGx5RzBnRW9NV25JWlhoUVZ5cFB5', // external (property name)\n\t        },\n\t      },\n\t      {\n", "        id: 'did:example:123#key-7',\n\t        type: 'JsonWebKey2020',\n\t        controller: 'did:example:123',\n\t        publicKeyJwk: {\n\t          kty: 'RSA', // external (property name)\n\t          e: 'AQAB', // external (property name)\n\t          n: 'UkhWaGJGOUZRMTlFVWtKSElBdENGV2hlU1F2djFNRXh1NVJMQ01UNGpWazlraEpLdjhKZU1YV2UzYldIYXRqUHNrZGYyZGxhR2tXNVFqdE9uVUtMNzQybXZyNHRDbGRLUzNVTElhVDFoSkluTUhIeGoyZ2N1Yk82ZUVlZ0FDUTRRU3U5TE8wSC1MTV9MM0RzUkFCQjdRamE4SGVjcHl1c3BXMVR1X0RicXhjU253ZW5kYW13TDUyVjE3ZUtobE80dVh3djJIRmx4dWZGSE0wS21DSnVqSUt5QXhqRF9tM3FfX0lpSFVWSEQxdERJRXZMUGhHOUF6c24zajk1ZC1zYU', // external (property name)\n\t        },\n\t      },\n\t    ],\n", "  },\n\t  {\n\t    '@context': [\n\t      'https://www.w3.org/ns/did/v1',\n\t      'https://w3id.org/security/suites/ed25519-2018/v1',\n\t      'https://w3id.org/security/suites/x25519-2019/v1',\n\t      'https://w3id.org/security/suites/secp256k1-2019/v1',\n\t      'https://w3id.org/security/suites/jws-2020/v1',\n\t    ],\n\t    id: 'did:example:method-id',\n", "    verificationMethod: [\n\t      {\n\t        id: 'did:example:123#key-0',\n\t        type: 'Ed25519VerificationKey2018',\n\t        controller: 'did:example:123',\n\t        // publicKeyBase58: '3M5RCDjPTWPkKSN3sxUmmMqHbmRPegYP1tjcKyrDbt9J', // external (property name)\n\t      },\n\t      {\n\t        id: 'did:example:123#key-1',\n\t        type: 'X25519KeyAgreementKey2019',\n", "        controller: 'did:example:123',\n\t        publicKeyBase58: 'FbQWLPRhTH95MCkQUeFYdiSoQt8zMwetqfWoxqPgaq7x', // external (property name)\n\t      },\n\t      {\n\t        id: 'did:example:123#key-2',\n\t        type: 'EcdsaSecp256k1VerificationKey2019',\n\t        controller: 'did:example:123',\n\t        publicKeyBase58: 'ns2aFDq25fEV1NUd3wZ65sgj5QjFW8JCAHdUJfLwfodt', // external (property name)\n\t      },\n\t      {\n", "        id: 'did:example:123#key-3',\n\t        type: 'JsonWebKey2020',\n\t        controller: 'did:example:123',\n\t        publicKeyJwk: {\n\t          kty: 'EC', // external (property name)\n\t          crv: 'P-256', // external (property name)\n\t          x: 'Er6KSSnAjI70ObRWhlaMgqyIOQYrDJTE94ej5hybQ2M', // external (property name)\n\t          y: 'pPVzCOTJwgikPjuUE6UebfZySqEJ0ZtsWFpj7YSPGEk', // external (property name)\n\t        },\n\t      },\n", "    ],\n\t  },\n\t  {\n\t    '@context': 'https://w3id.org/did/v1',\n\t    id: 'did:github:OR13',\n\t    publicKey: [\n\t      {\n\t        encoding: 'application/pgp-keys',\n\t        type: 'OpenPgpVerificationKey2019',\n\t        id: 'did:github:OR13#kid=ibHP1ksrJp5FQjP7hhmTXV7YE5o5bB6YFoODu9n_82E',\n", "        controller: 'did:github:OR13',\n\t        publicKeyPem:\n\t          '-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: OpenPGP.js v4.4.7\\r\\nComment: https://openpgpjs.org\\r\\n\\r\\nxk8EXNhPhBMFK4EEAAoCAwSTAb5KPYRzxaQoplpY8olodfbG3OxFqm6ULA6p\\r\\nvaCxZLKVwd4XCwSL8XcMMrPb78kmDEk0H5/Jl0qpRteRoy8CzRdhbm9uIDxh\\r\\nbm9uQGV4YW1wbGUuY29tPsJ3BBATCAAfBQJc2E+EBgsJBwgDAgQVCAoCAxYC\\r\\nAQIZAQIbAwIeAQAKCRAeL9f86407tSxDAP4/dXtxQKQxAsURQmNxwwlD03YM\\r\\n778dcM753Y4f96jW7QEAkLEDur/hKPLKKdFAi/9TCKNQvr7GVk1wYeYeiHMi\\r\\nJ/fOUwRc2E+EEgUrgQQACgIDBA7fIkmeQmvaG6a5B3X808pdFStePh7+uevf\\r\\njWpXbDYYTsxARpBT/xb34m0wrXGo7DEG6pAknQ6NBWiXSWX7qTkDAQgHwmEE\\r\\nGBMIAAkFAlzYT4QCGwwACgkQHi/X/OuNO7U8gQEAn3/lFx3C7iqzVG2BJgtH\\r\\n08Oc3h0YPwYnZjM9NXDsvEgA/3v5C28Jhx10RFKi9NDxAPjilwBDOZqYPK/s\\r\\nW3qWhGNU\\r\\n=RgYO\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n',\n\t      },\n\t      {\n\t        encoding: 'application/pgp-keys',\n\t        type: 'OpenPgpVerificationKey2019',\n\t        id: 'did:github:OR13#kid=jNeDDagaBn466F-wH26YdQ5_NiabBvOlXTv5xItQakU',\n\t        controller: 'did:github:OR13',\n\t        publicKeyPem:\n", "          '-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: OpenPGP.js v4.4.7\\r\\nComment: https://openpgpjs.org\\r\\n\\r\\nxk8EXNhPhBMFK4EEAAoCAwRzQtkzDYQJy7xfHE0ld/Yoznx0q5bfVrx51FPG\\r\\nXzjd28wktnePW+3Riq0+3YUa09mZJWEuGPwrrGGXEqobjlVBzRdhbm9uIDxh\\r\\nbm9uQGV4YW1wbGUuY29tPsJ3BBATCAAfBQJc2E+EBgsJBwgDAgQVCAoCAxYC\\r\\nAQIZAQIbAwIeAQAKCRC0BtN9z0XDqWsSAQCso31Utz8xji2B7WUBX+2798ae\\r\\ncqxSxMPWnOQKenBA0gD+N9Qiq6sQ/sDipXuG7xIg4NH4qpf96xvPwC4hX9Jv\\r\\n3FzOUwRc2E+EEgUrgQQACgIDBIPkRAFeFOrFMXa4XoZ8+aZb4iXLhce6N0LE\\r\\nCh3YZNJLwxWVKVCxr8niWq3Fa8RTkLA+F7PvIHjnpgx5UGeqPzgDAQgHwmEE\\r\\nGBMIAAkFAlzYT4QCGwwACgkQtAbTfc9Fw6nomAEAl+1tioF0BlbTNm3c879W\\r\\nadI46tXfqHt8T6TGdIsKbmoA/RjOfCUvMT277p+v3aYjROI3M7ygh24jbjzx\\r\\nKBQj/GIJ\\r\\n=UGd9\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n',\n\t      },\n\t    ],\n\t    authentication: [],\n\t    service: [],\n\t    proof: {\n\t      type: 'OpenPgpSignature2019',\n\t      creator:\n\t        'did:github:OR13#kid=ibHP1ksrJp5FQjP7hhmTXV7YE5o5bB6YFoODu9n_82E',\n\t      domain: 'GitHubDID',\n", "      nonce: '9c28424e440806718a5165670f79bbc2',\n\t      created: '2019-05-12T16:53:25.038Z',\n\t      signatureValue:\n\t        '-----BEGIN PGP SIGNATURE-----\\r\\nVersion: OpenPGP.js v4.4.7\\r\\nComment: https://openpgpjs.org\\r\\n\\r\\nwl0EARMIAAYFAlzYT4UACgkQHi/X/OuNO7WZQAD47BbeS2pgFW/WwPbHvC8I\\r\\nMfsOFhSJEywkED7uz0E4RwD/RRrsmPPb4S4Z+7D2skjiFtnd2nWd+BXcxvhm\\r\\nGzKk1FU=\\r\\n=W/tu\\r\\n-----END PGP SIGNATURE-----\\r\\n',\n\t    },\n\t  },\n\t  {\n\t    id: 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w',\n\t    '@context': [\n\t      'https://www.w3.org/ns/did/v1',\n", "      {\n\t        '@base': 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w',\n\t      },\n\t    ],\n\t    service: [\n\t      {\n\t        id: 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w#linkedin',\n\t        type: 'linkedin',\n\t        serviceEndpoint: 'https://linkedin.com/in/henry-tsai-6b884014',\n\t      },\n", "      {\n\t        id: 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w#github',\n\t        type: 'github',\n\t        serviceEndpoint: 'https://github.com/thehenrytsai',\n\t      },\n\t    ],\n\t    verificationMethod: [\n\t      {\n\t        id: 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w#someKeyId',\n\t        controller: 'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w',\n", "        type: 'EcdsaSecp256k1VerificationKey2019',\n\t        publicKeyJwk: {\n\t          kty: 'EC',\n\t          crv: 'secp256k1',\n\t          x: 'WfY7Px6AgH6x-_dgAoRbg8weYRJA36ON-gQiFnETrqw',\n\t          y: 'IzFx3BUGztK0cyDStiunXbrZYYTtKbOUzx16SUK0sAY',\n\t        },\n\t      },\n\t    ],\n\t    authentication: [\n", "      'did:ion:EiClkZMDxPKqC9c-umQfTkR8vvZ9JPhl_xLDI9Nfk38w5w#someKeyId',\n\t    ],\n\t  },\n\t  {\n\t    '@context': [\n\t      'https://www.w3.org/ns/did/v1',\n\t      'https://w3c-ccg.github.io/verifiable-conditions/contexts/verifiable-conditions-2021-v1.json',\n\t    ],\n\t    id: 'did:eosio:eos:eoscanadacom',\n\t    verificationMethod: [\n", "      {\n\t        id: 'did:eosio:eos:eoscanadacom#active',\n\t        controller: 'did:eosio:eos:eoscanadacom',\n\t        type: 'VerifiableCondition',\n\t        threshold: 1,\n\t        conditionWeightedThreshold: [\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#active-0',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n", "              type: 'EcdsaSecp256k1VerificationKey2019',\n\t              publicKeyJwk: {\n\t                crv: 'secp256k1',\n\t                kty: 'EC',\n\t                x: '0xMG4S6nDAGYjy6un2-l53-s0RC2t619_LqPDxyPcf0',\n\t                y: 'gRsWsrqWqnlr-jCDVeqatVjFghLADydjOlUPImBwhYs',\n\t                kid: 'PUB_K1_8SC96RUoYvM1X47isBBrebY1kjqVT4w37Q4tNNHtT8XN35v33D',\n\t              },\n\t            },\n\t            weight: 1,\n", "          },\n\t        ],\n\t        relationshipParent: ['did:eosio:eos:eoscanadacom#owner'],\n\t      },\n\t      {\n\t        id: 'did:eosio:eos:eoscanadacom#blacklistops',\n\t        controller: 'did:eosio:eos:eoscanadacom',\n\t        type: 'VerifiableCondition',\n\t        threshold: 1,\n\t        conditionWeightedThreshold: [\n", "          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#blacklistops-0',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'EcdsaSecp256k1VerificationKey2019',\n\t              publicKeyJwk: {\n\t                crv: 'secp256k1',\n\t                kty: 'EC',\n\t                x: 'dLOnSPgih47eVwlWAlrcm4wD1cJnjc-Jh_UFdlb29mw',\n\t                y: 'vwsVDd__tmPumdQ2Yo-TdozxbhGnyDMg3Htd52-SEw0',\n", "                kid: 'PUB_K1_7idX86zQ6M3mrzkGQ9MGHf4btSECmcTj4i8Le59ga7CpLxRu4s',\n\t              },\n\t            },\n\t            weight: 1,\n\t          },\n\t        ],\n\t        relationshipParent: ['did:eosio:eos:eoscanadacom#active'],\n\t      },\n\t      {\n\t        id: 'did:eosio:eos:eoscanadacom#claimer',\n", "        controller: 'did:eosio:eos:eoscanadacom',\n\t        type: 'VerifiableCondition',\n\t        threshold: 1,\n\t        conditionWeightedThreshold: [\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#claimer-0',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'EcdsaSecp256k1VerificationKey2019',\n\t              publicKeyJwk: {\n", "                crv: 'secp256k1',\n\t                kty: 'EC',\n\t                x: 'RnFk1oqh28hDY2WHWUhQzAZYXjfvv0oR43h69RCCkIA',\n\t                y: 'e8aXe3M9xKgYsj6U-KOonbgEtjHGPDtAUavq9nY4lI8',\n\t                kid: 'PUB_K1_7NFuBesBKK5XHHLtzFxm7S57Eq11gUtndrsvq3Mt3XZNNT5cXo',\n\t              },\n\t            },\n\t            weight: 1,\n\t          },\n\t        ],\n", "        relationshipParent: ['did:eosio:eos:eoscanadacom#active'],\n\t      },\n\t      {\n\t        id: 'did:eosio:eos:eoscanadacom#day2day',\n\t        controller: 'did:eosio:eos:eoscanadacom',\n\t        type: 'VerifiableCondition',\n\t        threshold: 1,\n\t        conditionWeightedThreshold: [\n\t          {\n\t            condition: {\n", "              id: 'did:eosio:eos:eoscanadacom#day2day-0',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n\t              conditionDelegated: 'id:eosio:eos::eoscanadaaaa#active',\n\t            },\n\t            weight: 1,\n\t          },\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#day2day-1',\n", "              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n\t              conditionDelegated: 'id:eosio:eos::eoscanadaaac#active',\n\t            },\n\t            weight: 1,\n\t          },\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#day2day-2',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n", "              type: 'VerifiableCondition',\n\t              conditionDelegated: 'id:eosio:eos::eoscanadaaaf#active',\n\t            },\n\t            weight: 1,\n\t          },\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#day2day-3',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n", "              conditionDelegated: 'id:eosio:eos::eoscanadaaag#active',\n\t            },\n\t            weight: 1,\n\t          },\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#day2day-4',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n\t              conditionDelegated: 'id:eosio:eos::eoscanadaaah#active',\n", "            },\n\t            weight: 1,\n\t          },\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#day2day-5',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n\t              conditionDelegated: 'id:eosio:eos::eoscanadaaai#active',\n\t            },\n", "            weight: 1,\n\t          },\n\t        ],\n\t        relationshipParent: ['did:eosio:eos:eoscanadacom#active'],\n\t      },\n\t      {\n\t        id: 'did:eosio:eos:eoscanadacom#eosforumdapp',\n\t        controller: 'did:eosio:eos:eoscanadacom',\n\t        type: 'VerifiableCondition',\n\t        threshold: 1,\n", "        conditionWeightedThreshold: [\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#eosforumdapp-0',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'EcdsaSecp256k1VerificationKey2019',\n\t              publicKeyJwk: {\n\t                crv: 'secp256k1',\n\t                kty: 'EC',\n\t                x: 'XWelm_LA5OvSwDPBQT_dwxWZ1Li1BiYbP3w2yhkcb6k',\n", "                y: 'wfydp1B25ylTsaR-W1Wld6TVLnJHXGgC7AgJ50Y0FHM',\n\t                kid: 'PUB_K1_7YNS1swh6QWANkzGgFrjiX8E3u8WK5CK9GMAb6EzKVNZKnMUfs',\n\t              },\n\t            },\n\t            weight: 1,\n\t          },\n\t        ],\n\t        relationshipParent: ['did:eosio:eos:eoscanadacom#active'],\n\t      },\n\t      {\n", "        id: 'did:eosio:eos:eoscanadacom#owner',\n\t        controller: 'did:eosio:eos:eoscanadacom',\n\t        type: 'VerifiableCondition',\n\t        threshold: 5,\n\t        conditionWeightedThreshold: [\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#owner-0',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n", "              conditionDelegated: 'id:eosio:eos::eoscanadaaaa#active',\n\t            },\n\t            weight: 2,\n\t          },\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#owner-1',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n\t              conditionDelegated: 'id:eosio:eos::eoscanadaaab#active',\n", "            },\n\t            weight: 2,\n\t          },\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#owner-2',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n\t              conditionDelegated: 'id:eosio:eos::eoscanadaaac#active',\n\t            },\n", "            weight: 2,\n\t          },\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#owner-3',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n\t              conditionDelegated: 'id:eosio:eos::eoscanadaaad#active',\n\t            },\n\t            weight: 2,\n", "          },\n\t          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#owner-4',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n\t              conditionDelegated: 'id:eosio:eos::eoscanadaaae#active',\n\t            },\n\t            weight: 2,\n\t          },\n", "          {\n\t            condition: {\n\t              id: 'did:eosio:eos:eoscanadacom#owner-5',\n\t              controller: 'did:eosio:eos:eoscanadacom',\n\t              type: 'VerifiableCondition',\n\t              conditionDelegated: 'id:eosio:eos::eoscanadaaaf#active',\n\t            },\n\t            weight: 1,\n\t          },\n\t        ],\n", "      },\n\t    ],\n\t    service: [\n\t      {\n\t        id: 'https://eos.greymass.com',\n\t        type: 'LinkedDomains',\n\t        serviceEndpoint: 'https://eos.greymass.com',\n\t      },\n\t      {\n\t        id: 'https://eos.dfuse.eosnation.io',\n", "        type: 'LinkedDomains',\n\t        serviceEndpoint: 'https://eos.dfuse.eosnation.io',\n\t      },\n\t    ],\n\t  },\n\t  {\n\t    '@context': 'https://w3id.org/did/v0.11',\n\t    id: 'did:meta:0000000000000000000000000000000000000000000000000000000000005e65',\n\t    publicKey: [\n\t      {\n", "        id: 'did:meta:0000000000000000000000000000000000000000000000000000000000005e65#MetaManagementKey#028efef184e144285eb1bf12c1a95c7bbc09ac2e',\n\t        type: 'EcdsaSecp256k1VerificationKey2019',\n\t        controller:\n\t          'did:meta:0000000000000000000000000000000000000000000000000000000000005e65',\n\t        publicKeyHex:\n\t          '041e5281968ebdd9266b7b841dd6f8ae9088b8399a1eab172ecad2cc5f98a795c98c82e60d58263c4cdfc7ff4ebafea06ab9cfdcdfb5529965b42817db331d66ce',\n\t      },\n\t    ],\n\t    authentication: [\n\t      'did:meta:0000000000000000000000000000000000000000000000000000000000005e65#MetaManagementKey#028efef184e144285eb1bf12c1a95c7bbc09ac2e',\n", "    ],\n\t    service: [\n\t      {\n\t        id: 'did:meta:0000000000000000000000000000000000000000000000000000000000000527',\n\t        publicKey:\n\t          'did:meta:0000000000000000000000000000000000000000000000000000000000005e65#MetaManagementKey#028efef184e144285eb1bf12c1a95c7bbc09ac2e',\n\t        type: 'identityHub',\n\t        serviceEndpoint: 'https://datahub.metadium.com',\n\t      },\n\t    ],\n", "  },\n\t  {\n\t    authentication: ['did:indy:sovrin:WRfXPg8dantKVubE3HX8pw#verkey'],\n\t    id: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw',\n\t    service: [\n\t      {\n\t        id: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw#xdi',\n\t        serviceEndpoint:\n\t          'https://xdi03-at.danubeclouds.com/cl/+!:did:sov:WRfXPg8dantKVubE3HX8pw',\n\t        type: 'xdi',\n", "      },\n\t      {\n\t        id: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw#agent',\n\t        serviceEndpoint:\n\t          'https://agents.danubeclouds.com/agent/WRfXPg8dantKVubE3HX8pw',\n\t        type: 'agent',\n\t      },\n\t    ],\n\t    verificationMethod: [\n\t      {\n", "        controller: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw',\n\t        id: 'did:indy:sovrin:WRfXPg8dantKVubE3HX8pw#verkey',\n\t        publicKeyBase58: 'H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV',\n\t        type: 'Ed25519VerificationKey2018',\n\t      },\n\t    ],\n\t  },\n\t  {\n\t    '@context': [\n\t      'https://www.w3.org/ns/did/v1',\n", "      {\n\t        '@vocab': 'https://www.iana.org/assignments/jose#',\n\t      },\n\t    ],\n\t    id: 'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ',\n\t    verificationMethod: [\n\t      {\n\t        id: 'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n\t        type: 'JsonWebKey2020',\n\t        controller:\n", "          'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ',\n\t        publicKeyJwk: {\n\t          kid: 'urn:ietf:params:oauth:jwk-thumbprint:sha-256:FfMbzOjMmQ4efT6kvwTIJjelTqjl0xjEIWQ2qobsRMM',\n\t          kty: 'OKP',\n\t          crv: 'Ed25519',\n\t          alg: 'EdDSA',\n\t          x: 'ANRjH_zxcKBxsjRPUtzRbp7FSVLKJXQ9APX9MP1j7k4',\n\t        },\n\t      },\n\t    ],\n", "    authentication: [\n\t      'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n\t    ],\n\t    assertionMethod: [\n\t      'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n\t    ],\n\t    capabilityInvocation: [\n\t      'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n\t    ],\n\t    capabilityDelegation: [\n", "      'did:jwk:eyJraWQiOiJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6andrLXRodW1icHJpbnQ6c2hhLTI1NjpGZk1iek9qTW1RNGVmVDZrdndUSUpqZWxUcWpsMHhqRUlXUTJxb2JzUk1NIiwia3R5IjoiT0tQIiwiY3J2IjoiRWQyNTUxOSIsImFsZyI6IkVkRFNBIiwieCI6IkFOUmpIX3p4Y0tCeHNqUlBVdHpSYnA3RlNWTEtKWFE5QVBYOU1QMWo3azQifQ#0',\n\t    ],\n\t  },\n\t  {\n\t    '@context': [\n\t      'https://www.w3.org/ns/did/v1',\n\t      {\n\t        '@base': 'did:web:did.actor:bob',\n\t      },\n\t    ],\n", "    id: 'did:web:did.actor:bob',\n\t    publicKey: [\n\t      {\n\t        id: '#z6MkkQBvgvqb6zGvS4cydworpUaRDzpszSFixq49ahbDeUTG',\n\t        type: 'Ed25519VerificationKey2018',\n\t        controller: '',\n\t        publicKeyBase58: '6wvt6gb9mSnTKZnGxNr1yP2RQRZ2aZ1NGp9DkRdCjFft',\n\t      },\n\t    ],\n\t  },\n", "]\n"]}
{"filename": "tests/utils/createDidExtractPartsTest.ts", "chunked_list": ["import { it } from 'node:test'\n\timport assert from 'node:assert'\n\timport { Did, DidParts, DidUrlParts } from '../../src'\n\texport const createDidExtractPartsTest = (\n\t  did: string,\n\t  expectedParts: DidParts\n\t) => {\n\t  it(`should extract did parts from ${did}`, () => {\n\t    assert.deepStrictEqual(new Did(did).didParts, expectedParts)\n\t  })\n", "}\n\texport const createDidExtractUrlPartsTest = (\n\t  did: string,\n\t  expectedUrlParts: DidUrlParts\n\t) => {\n\t  it(`should extract did url parts from ${did}`, () => {\n\t    assert.deepStrictEqual(new Did(did).didUrlParts, expectedUrlParts)\n\t  })\n\t}\n"]}
{"filename": "tests/utils/createDidValidationTest.ts", "chunked_list": ["import { it } from 'node:test'\n\timport assert from 'node:assert'\n\timport { Did } from '../../src'\n\texport const createDidValidationTest = (did: string) => {\n\t  it(`should validate ${did}`, (_) => {\n\t    assert.strictEqual(Did.validateDidUrl(did), true)\n\t  })\n\t}\n"]}
{"filename": "tests/utils/index.ts", "chunked_list": ["export * from './createDidExtractPartsTest'\n\texport * from './createDidValidationTest'\n\texport * from './createDidIsDidUrlTest'\n"]}
{"filename": "tests/utils/createDidIsDidUrlTest.ts", "chunked_list": ["import { Did } from '../../src'\n\timport { it } from 'node:test'\n\timport assert from 'node:assert'\n\texport const createDidIsDidUrlValidationTest = (\n\t  did: string,\n\t  expected: boolean\n\t) =>\n\t  it(`should validate if did is url for ${did}`, () => {\n\t    const instance = new Did(did)\n\t    assert.strictEqual(instance.isDidUrl(), expected)\n", "  })\n"]}
{"filename": "tests/utils/createDidDocumentConstructTest.ts", "chunked_list": ["import { DidDocument, DidDocumentOptions } from '../../src'\n\timport assert from 'node:assert'\n\timport { it } from 'node:test'\n\texport const createDidDocumentConstructTest = (\n\t  didDocument: DidDocumentOptions\n\t) =>\n\t  it(`should construct the did document for ${didDocument.id}`, () => {\n\t    const instance = new DidDocument(didDocument)\n\t    assert.strictEqual(instance.id.toString(), didDocument.id)\n\t  })\n"]}
{"filename": "src/representations.ts", "chunked_list": ["export enum Representations {\n\t  /**\n\t   * @see {@link https://www.w3.org/TR/did-core#json | DID Core}\n\t   */\n\t  DidJson = 'application/did+json',\n\t  /**\n\t   * JSON-LD has a representation-specific entry, which is the `@context` field inside the DID Document.\n\t   *\n\t   * @see {@link https://www.w3.org/TR/did-core#json | DID Core}\n\t   * @see {@link https://w3c.github.io/did-core/ | DID Core 1.0 Working draft }\n", "   *\n\t   * @example\n\t   * {\n\t   *  \"@context\": [\n\t   *    \"https://www.w3.org/ns/did/v1\",\n\t   *    \"https://example.com/blockchain-identity/v1\"\n\t   *  ],\n\t   *  ...\n\t   * }\n\t   */\n", "  DidJsonLd = 'application/did+ld+json',\n\t  /**\n\t   * @see {@link https://www.w3.org/TR/did-cbor-representation/#application-did-cbor | The Plain CBOR Representation}\n\t   */\n\t  DidCbor = 'application/did+cbor',\n\t}\n"]}
{"filename": "src/verificationMethodTypes.ts", "chunked_list": ["/**\n\t * These are values to be used for the type in a verification method object.\n\t *\n\t * @see {@link https://www.w3.org/TR/did-spec-registries/#verification-method-types}\n\t *\n\t * @note Do not include private or extraneous information in verification methods. The class of private information related to JWKs is defined here. Please review the DID Core specification for additional details on this topic.\n\t */\n\texport enum VerificationMethodTypes {\n\t  /**\n\t   * @see {@link https://w3c-ccg.github.io/lds-jws2020/ | Normative definition}\n", "   * @see {@link https://w3id.org/security/suite/jws-2020/v1 | JSON-LD}\n\t   *\n\t   * @example\n\t   * {\n\t   *  \"id\": \"did:example:123#_TKzHv2jFIyvdTGF1Dsgwngfdg3SH6TpDv0Ta1aOEkw\",\n\t   *  \"type\": \"JsonWebKey2020\",\n\t   *  \"controller\": \"did:example:123\",\n\t   *  \"publicKeyJwk\": {\n\t   *    \"crv\": \"P-256\",\n\t   *    \"x\": \"38M1FDts7Oea7urmseiugGW7tWc3mLpJh6rKe7xINZ8\",\n", "   *    \"y\": \"nDQW6XZ7b_u2Sy9slofYLlG03sOEoug3I0aAPQ0exs4\",\n\t   *    \"kty\": \"EC\",\n\t   *    \"kid\": \"_TKzHv2jFIyvdTGF1Dsgwngfdg3SH6TpDv0Ta1aOEkw\"\n\t   *  }\n\t   * }\n\t   */\n\t  JsonWebKey2020 = 'JsonWebKey2020',\n\t  /**\n\t   * @see {@link https://w3c-ccg.github.io/lds-ecdsa-secp256k1-2019/ | Normative definition}\n\t   * @see {@link https://w3id.org/security/suites/secp256k1-2019 | JSON-LD}\n", "   *\n\t   * @example\n\t   * {\n\t   *  \"id\": \"did:example:123#WjKgJV7VRw3hmgU6--4v15c0Aewbcvat1BsRFTIqa5Q\",\n\t   *  \"type\": \"EcdsaSecp256k1VerificationKey2019\",\n\t   *  \"controller\": \"did:example:123\",\n\t   *  \"publicKeyJwk\": {\n\t   *    \"crv\": \"secp256k1\",\n\t   *    \"x\": \"NtngWpJUr-rlNNbs0u-Aa8e16OwSJu6UiFf0Rdo1oJ4\",\n\t   *    \"y\": \"qN1jKupJlFsPFc1UkWinqljv4YE0mq_Ickwnjgasvmo\",\n", "   *    \"kty\": \"EC\",\n\t   *    \"kid\": \"WjKgJV7VRw3hmgU6--4v15c0Aewbcvat1BsRFTIqa5Q\"\n\t   *  }\n\t   * }\n\t   */\n\t  EcdsaSecp256k1VerificationKey2019 = 'EcdsaSecp256k1VerificationKey2019',\n\t  /**\n\t   * @see {@link https://w3c-ccg.github.io/lds-ed25519-2018/ | Normative definition}\n\t   * @see {@link https://w3id.org/security/suites/ed25519-2018/v1 | JSON-LD}\n\t   *\n", "   * @example\n\t   * {\n\t   *  \"id\": \"did:example:123#ZC2jXTO6t4R501bfCXv3RxarZyUbdP2w_psLwMuY6ec\",\n\t   *  \"type\": \"Ed25519VerificationKey2018\",\n\t   *  \"controller\": \"did:example:123\",\n\t   *  \"publicKeyBase58\": \"H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV\"\n\t   * }\n\t   */\n\t  Ed25519VerificationKey2018 = 'Ed25519VerificationKey2018',\n\t  /**\n", "   * @see {@link https://w3c-ccg.github.io/ldp-bbs2020/ | Normative definition}\n\t   * @see {@link https://w3id.org/security/suites/bls12381-2020/v1 | JSON-LD}\n\t   *\n\t   * @example\n\t   * {\n\t   *  \"id\": \"did:example:123#z3tEGVtEKzdhJB2rT5hLVjwQPis8k7bTM16t7vDZrQaoddk6wZ7or6xPPs1P8H9U16Xe75\",\n\t   *  \"type\": \"Bls12381G1Key2020\",\n\t   *  \"controller\": \"did:example:123\",\n\t   *  \"publicKeyBase58\": \"7bXhTVonHPizXP72AE92PPmRiaXipC519yU7F6NxUFExWpyQo57LuKKBoTyuZ3uWm9\",\n\t   * }\n", "   */\n\t  Bls12381G1Key2020 = 'Bls12381G1Key2020',\n\t  /**\n\t   * @see {@link https://w3c-ccg.github.io/ldp-bbs2020/ | Normative definition}\n\t   * @see {@link https://w3id.org/security/suites/bls12381-2020/v1 | JSON-LD}\n\t   *\n\t   * @example\n\t   * {\n\t   *   \"id\": \"did:example:123#zUC7K51WYEsj8y6KPVa1XfwdW5ZJrW5kSbMV619j128T6atCLLXJjjovMZsJ3Ay4STdngRkvM4ygT4qm1mk6HR8FvipSY435nLgYS1TTcaqJAzDWzM1iB9vh3hTL1DEKitwn56i\",\n\t   *   \"type\": \"Bls12381G2Key2020\",\n", "   *   \"controller\": \"did:example:123\",\n\t   *   \"publicKeyBase58\": \"25ETdUZDVnME6yYuAMjFRCnCPcDmYQcoZDcZuXAfeMhXPvjZg35QmZ7uctBcovA69YDM3Jf7s5BHo4u1y89nY6mHiji8yphZ4AMm4iNCRh35edSg76Dkasu3MY2VS9LnuaVQ\",\n\t   * }\n\t   */\n\t  Bls12381G2Key2020 = 'Bls12381G2Key2020',\n\t  /**\n\t   * @see {@link https://w3id.org/security/suites/pgp-2021#PgpVerificationKey2021 | Normative definition}\n\t   * @see {@link https://w3id.org/security/suites/pgp-2021/v1 | JSON-LD}\n\t   *\n\t   * @note Use of this verification key should be in line with the OpenPGP Message Format as defined in {@link https://datatracker.ietf.org/doc/html/rfc4880 | RFC 4880}\n", "   *\n\t   * @example\n\t   * {\n\t   *  \"@context\":[\n\t   *    \"https://www.w3.org/ns/did/v1\",\n\t   *    \"https://gpg.jsld.org/contexts/lds-gpg2020-v0.0.jsonld\"\n\t   *  ],\n\t   *  \"id\":\"did:example:123\",\n\t   *  \"verificationMethod\":[{\n\t   *    \"id\": \"did:example:123#989ed1057a294c8a3665add842e784c4d08de1e2\",\n", "   *    \"type\": \"PgpVerificationKey2021\",\n\t   *    \"controller\": \"did:example:123\",\n\t   *    \"publicKeyPgp\": \"-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: OpenPGP.js v4.9.0\\r\\nComment: https://openpgpjs.org\\r\\n\\r\\nxjMEXkm5LRYJKwYBBAHaRw8BAQdASmfrjYr7vrjwHNiBsdcImK397Vc3t4BL\\r\\nE8rnN......v6\\r\\nDw==\\r\\n=wSoi\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n\"\n\t   *  }]\n\t   * }\n\t   */\n\t  PgpVerificationKey2021 = 'PgpVerificationKey2021',\n\t  /**\n\t   * @see {@link https://w3c-ccg.github.io/lds-rsa2018/ | Normative definition}\n\t   * @see {@link https://www.w3.org/2018/credentials/v1 | JSON-LD}\n", "   *\n\t   * @note {@link https://github.com/w3c/did-spec-registries/issues/370 | DID Specification Registries Issue 370} This property should be moved into a separate suite and linked to here rather than relying on the Verifiable Credentials vocabulary. There are known issues with the first version of the Security vocabulary JSON-LD context and the first version of the Verifiable Credentials JSON-LD context which will prevent these contexts from being listed in the same document. For now it's suggested that implementers rely upon the first version of the Verifiable Credentials JSON-LD context and not rely on the Security vocabulary JSON-LD context in the same document.\n\t   *\n\t   * @example\n\t   * {\n\t   *  \"id\": \"did:example:123#key-0\",\n\t   *  \"type\": \"RsaVerificationKey2018\",\n\t   *  \"controller\": \"did:example:123\",\n\t   *  \"publicKeyJwk\": {\n\t   *    \"kty\":\"RSA\",\n", "   *    \"e\":\"AQAB\",\n\t   *    \"use\":\"sig\",\n\t   *    \"kid\":\"tNksV42EUs3Xct9AkgZyFWglItRGMxVZ1A1XM68SNq0\n\t   *    \"n\":\"kO2d_qQTEBjYFGcoY_da7ziFY4L2QX14K7snCee09n-cY2eP-oJXk8T2_lL20YnpYhf4i\n\t   *    jhkWHGU8kY8-FWPRrzSeu3JUMVSZoqTgoAiKWdnSLNvPVxvGuD2CiA3T6AkwUC03D2AkOLCcJV\n\t   *    8h_hxUEPeDawF7ArpuJW5DXzEJjE7gOjN4r6d7VB6sd5y-3la54H2ADz2amHLdBWs30fL4BRBH\n\t   *    lVdx0YmF37V4u5yvnnb5Iyr3kBXJes8t0MUMPkjqEEXRmukpKUzZYNpWDXY0tVcXeK5sRx0DAn\n\t   *    lNgNNf14-vsyjGkj2Rz0oGW73jjWa8dw-yVlDEHyIkQU9-UY4dFXbVjdIO8j_5ghh62o1T7Y4w\n\t   *    5CWMc-FxPE3LHe-_teW97X__NN-ToYgfi42IvV2mYOdQMCbvnvY2oMdK3b9wmeVi0marToauL5\n\t   *    LMg5xHDKopmIR7E3VyRtNYwDFAZ89kadcbSrZ8zTR5APaB7Tmp2L2ZfXKxqKQuxlFTTCcZtg4e\n", "   *    5AN8QuYdI18DEDQn2umUU_Twj7k4CXvuIKVL8p4yRHC4CHAGIm9cH_t11dF3wXygaENVOGRXQu\n\t   *    0g1iKq0mO2rWpOqkGJ5uXMFb5lx54i8uOjCdZ9y2el28xA55Ve95KCxeTHp997Bn3TIgbeQ-B_\n\t   *    -3PBVTuuAAH8y9fFNKtu5E\"\n\t   *  }\n\t   * }\n\t   */\n\t  RsaVerificationKey2018 = 'RsaVerificationKey2018',\n\t  /**\n\t   * Normative definition pending\n\t   * @see {@link http://w3id.org/security/suites/x25519-2019/v1 | JSON-LD}\n", "   *\n\t   * @note Normative definition in a suite is required for registration, this entry should be updated or removed.\n\t   */\n\t  X25519KeyAgreementKey2019 = 'X25519KeyAgreementKey2019',\n\t  /**\n\t   * @see {@link https://identity.foundation/EcdsaSecp256k1RecoverySignature2020/#ES256K-R | Normative definition}\n\t   * @see {@link https://w3id.org/security/suites/secp256k1recovery-2020/v1 | JSON-LD}\n\t   *\n\t   * @example\n\t   * {\n", "   *  \"@context\": [\n\t   *    \"https://www.w3.org/ns/did/v1\",\n\t   *    \"https://identity.foundation/EcdsaSecp256k1RecoverySignature2020#\"\n\t   *  ],\n\t   *  \"id\":\"did:example:123\",\n\t   *  \"verificationMethod\": [\n\t   *    {\n\t   *      \"id\": \"did:example:123#vm-1\",\n\t   *      \"controller\": \"did:example:123\",\n\t   *      \"type\": \"EcdsaSecp256k1RecoveryMethod2020\",\n", "   *      \"publicKeyJwk\": {\n\t   *        \"crv\": \"secp256k1\",\n\t   *        \"kid\": \"JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw\",\n\t   *        \"kty\": \"EC\",\n\t   *        \"x\": \"dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A\",\n\t   *        \"y\": \"36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA\"\n\t   *      }\n\t   *    },\n\t   *    {\n\t   *      \"id\": \"did:example:123#vm-2\",\n", "   *      \"controller\": \"did:example:123\",\n\t   *      \"type\": \"EcdsaSecp256k1RecoveryMethod2020\",\n\t   *      \"publicKeyHex\": \"027560af3387d375e3342a6968179ef3c6d04f5d33b2b611cf326d4708badd7770\"\n\t   *    },\n\t   *    {\n\t   *      \"id\": \"did:example:123#vm-3\",\n\t   *      \"controller\": \"did:example:123\",\n\t   *      \"type\": \"EcdsaSecp256k1RecoveryMethod2020\",\n\t   *      \"ethereumAddress\": \"0xF3beAC30C498D9E26865F34fCAa57dBB935b0D74\"\n\t   *    }\n", "   *  ]\n\t   * }\n\t   */\n\t  EcdsaSecp256k1RecoveryMethod2020 = 'EcdsaSecp256k1RecoveryMethod2020',\n\t  /**\n\t   * @see {@link https://w3c-ccg.github.io/verifiable-conditions | Normative definition}\n\t   * @see {@link https://w3c-ccg.github.io/verifiable-conditions/contexts/verifiable-conditions-2021-v1.json | JSON-LD}\n\t   *\n\t   * @example\n\t   * {\n", "   *    \"id\": \"did:example:123#1\",\n\t   *    \"controller\": \"did:example:123\",\n\t   *    \"type\": \"VerifiableCondition2021\",\n\t   *    \"conditionAnd\": [{\n\t   *        \"id\": \"did:example:123#1-1\",\n\t   *        \"controller\": \"did:example:123\",\n\t   *        \"type\": \"VerifiableCondition2021\",\n\t   *        \"conditionOr\": [{\n\t   *            \"id\": \"did:example:123#1-1-1\",\n\t   *            \"controller\": \"did:example:123\",\n", "   *            \"type\": \"EcdsaSecp256k1VerificationKey2019\",\n\t   *            \"publicKeyBase58\": \"5JBxKqYKzzoHrzeqwp6zXk8wZU3Ah94ChWAinSj1fYmyJvJS5rT\"\n\t   *        }, {\n\t   *            \"id\": \"did:example:123#1-1-2\",\n\t   *            \"controller\": \"did:example:123\",\n\t   *            \"type\": \"Ed25519VerificationKey2018\",\n\t   *            \"publicKeyBase58\": \"PZ8Tyr4Nx8MHsRAGMpZmZ6TWY63dXWSCzamP7YTHkZc78MJgqWsAy\"\n\t   *        }]\n\t   *    }, {\n\t   *        \"id\": \"did:example:123#1-2\",\n", "   *        \"controller\": \"did:example:123\",\n\t   *        \"type\": \"Ed25519VerificationKey2018\",\n\t   *        \"publicKeyBase58\": \"H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV\"\n\t   *    }]\n\t   * }\n\t   */\n\t  VerifiableCondition2021 = 'VerifiableCondition2021',\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["export type Modify<T, R> = Omit<T, keyof R> & R\n\texport type Impossible<T, K extends keyof T> = Omit<T, K> & { [P in K]: never }\n\texport type OrPromise<T> = T | Promise<T>\n\texport type MakePropertyRequired<T, K extends keyof T> = T &\n\t  Required<Pick<T, K>>\n"]}
{"filename": "src/didDocument.ts", "chunked_list": ["import { z } from 'zod'\n\timport { Did } from './did'\n\timport { Service, ServiceOptions } from './service'\n\timport {\n\t  VerificationMethod,\n\t  VerificationMethodOptions,\n\t} from './verificationMethod'\n\timport {\n\t  didDocumentSchema,\n\t  stringOrDid,\n", "  uniqueServicesSchema,\n\t  uniqueStringOrVerificationMethodsSchema,\n\t  uniqueVerificationMethodsSchema,\n\t} from './schemas'\n\timport { DidDocumentError } from './error'\n\timport { MakePropertyRequired, Modify } from './types'\n\ttype DidOrVerificationMethodArray = Array<VerificationMethodOrDidOrString>\n\ttype VerificationMethodOrDidOrString =\n\t  | VerificationMethod\n\t  | VerificationMethodOptions\n", "  | Did\n\t  | string\n\texport type DidDocumentOptions<T extends Record<string, unknown> = {}> = Modify<\n\t  z.input<typeof didDocumentSchema>,\n\t  {\n\t    verificationMethod?: Array<VerificationMethodOptions>\n\t    authentication?: DidOrVerificationMethodArray\n\t    assertionMethod?: DidOrVerificationMethodArray\n\t    keyAgreement?: DidOrVerificationMethodArray\n\t    capabilityInvocation?: DidOrVerificationMethodArray\n", "    capabilityDelegation?: DidOrVerificationMethodArray\n\t    service?: Array<ServiceOptions | Service>\n\t  }\n\t> &\n\t  Record<string, unknown> &\n\t  T\n\ttype ReturnBuilderWithAlsoKnownAs<T extends DidDocument> = MakePropertyRequired<\n\t  T,\n\t  'alsoKnownAs'\n\t>\n", "type ReturnBuilderWithController<T extends DidDocument> = MakePropertyRequired<\n\t  T,\n\t  'controller'\n\t>\n\ttype ReturnBuilderWithVerificationMethod<T extends DidDocument> =\n\t  MakePropertyRequired<T, 'verificationMethod'>\n\ttype ReturnBuilderWithAuthentication<T extends DidDocument> =\n\t  MakePropertyRequired<T, 'authentication'>\n\ttype ReturnBuilderWithAssertionMethod<T extends DidDocument> =\n\t  MakePropertyRequired<T, 'assertionMethod'>\n", "type ReturnBuilderWithKeyAgreementMethod<T extends DidDocument> =\n\t  MakePropertyRequired<T, 'keyAgreement'>\n\ttype ReturnBuilderWithCapabilityInvocation<T extends DidDocument> =\n\t  MakePropertyRequired<T, 'capabilityInvocation'>\n\ttype ReturnBuilderWithCapabilityDelegation<T extends DidDocument> =\n\t  MakePropertyRequired<T, 'capabilityDelegation'>\n\ttype ReturnBuilderWithService<T extends DidDocument> = MakePropertyRequired<\n\t  T,\n\t  'service'\n\t>\n", "export class DidDocument {\n\t  public fullDocument: DidDocumentOptions\n\t  public id: Did\n\t  public alsoKnownAs?: Array<string>\n\t  public controller?: Did | Array<Did>\n\t  public verificationMethod?: Array<VerificationMethod>\n\t  public authentication?: Array<VerificationMethod | Did>\n\t  public assertionMethod?: Array<VerificationMethod | Did>\n\t  public keyAgreement?: Array<VerificationMethod | Did>\n\t  public capabilityInvocation?: Array<VerificationMethod | Did>\n", "  public capabilityDelegation?: Array<VerificationMethod | Did>\n\t  public service?: Array<Service>\n\t  public constructor(options: DidDocumentOptions) {\n\t    this.fullDocument = options\n\t    const parsed = didDocumentSchema.parse(options)\n\t    this.id = parsed.id\n\t    this.alsoKnownAs = parsed.alsoKnownAs\n\t    this.controller = parsed.controller\n\t    this.verificationMethod = parsed.verificationMethod\n\t    this.authentication = parsed.authentication\n", "    this.assertionMethod = parsed.assertionMethod\n\t    this.keyAgreement = parsed.keyAgreement\n\t    this.capabilityDelegation = parsed.capabilityDelegation\n\t    this.capabilityInvocation = parsed.capabilityInvocation\n\t    this.service = parsed.service\n\t  }\n\t  public findVerificationMethodByDidUrl(didUrl: z.input<typeof stringOrDid>) {\n\t    const did = stringOrDid.parse(didUrl)\n\t    const verificationMethod = this.verificationMethod?.find(\n\t      (verificationMethod) => verificationMethod.id.toUrl() === did.toUrl()\n", "    )\n\t    if (!verificationMethod) {\n\t      throw new DidDocumentError(\n\t        `Verification method for did '${did.toString()}' not found`\n\t      )\n\t    }\n\t    return verificationMethod\n\t  }\n\t  public safeFindToVerificationMethodByDidUrl(\n\t    didUrl: z.input<typeof stringOrDid>\n", "  ) {\n\t    try {\n\t      return this.findVerificationMethodByDidUrl(didUrl)\n\t    } catch {\n\t      return undefined\n\t    }\n\t  }\n\t  public addAlsoKnownAs(\n\t    alsoKnownAs: string\n\t  ): ReturnBuilderWithAlsoKnownAs<this> {\n", "    if (this.alsoKnownAs) {\n\t      this.alsoKnownAs.push(alsoKnownAs)\n\t    } else {\n\t      this.alsoKnownAs = [alsoKnownAs]\n\t    }\n\t    return this as ReturnBuilderWithAlsoKnownAs<this>\n\t  }\n\t  public addController(\n\t    controller: string | Did,\n\t    asArray = true\n", "  ): ReturnBuilderWithController<this> {\n\t    const instancedController =\n\t      typeof controller === 'string' ? new Did(controller) : controller\n\t    if (this.controller) {\n\t      if (Array.isArray(this.controller)) {\n\t        this.controller.push(instancedController)\n\t      } else {\n\t        this.controller = [this.controller, instancedController]\n\t      }\n\t    } else {\n", "      this.controller = asArray ? [instancedController] : instancedController\n\t    }\n\t    return this as ReturnBuilderWithController<this>\n\t  }\n\t  public addVerificationMethod(\n\t    verificationMethod: VerificationMethodOptions\n\t  ): ReturnBuilderWithVerificationMethod<this> {\n\t    if (this.verificationMethod) {\n\t      this.verificationMethod.push(new VerificationMethod(verificationMethod))\n\t    } else {\n", "      this.verificationMethod = [new VerificationMethod(verificationMethod)]\n\t    }\n\t    uniqueVerificationMethodsSchema.parse(this.verificationMethod)\n\t    return this as ReturnBuilderWithVerificationMethod<this>\n\t  }\n\t  public addAuthentication(\n\t    verificationMethodOrDidOrString: VerificationMethodOrDidOrString\n\t  ): ReturnBuilderWithAuthentication<this> {\n\t    this.authentication = this.addVerificationMethodOrDidOrString(\n\t      'authentication',\n", "      this.authentication,\n\t      verificationMethodOrDidOrString\n\t    )\n\t    return this as ReturnBuilderWithAuthentication<this>\n\t  }\n\t  public addAuthenticationUnsafe(\n\t    verificationMethodOrDidOrString: VerificationMethodOrDidOrString\n\t  ): ReturnBuilderWithAuthentication<this> {\n\t    this.authentication = this.addVerificationMethodOrDidOrString(\n\t      'authentication',\n", "      this.authentication,\n\t      verificationMethodOrDidOrString,\n\t      true\n\t    )\n\t    return this as ReturnBuilderWithAuthentication<this>\n\t  }\n\t  public addKeyAgreement(\n\t    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n\t  ): ReturnBuilderWithKeyAgreementMethod<this> {\n\t    this.keyAgreement = this.addVerificationMethodOrDidOrString(\n", "      'keyAgreement',\n\t      this.keyAgreement,\n\t      verificationMethodOrStringOrDid\n\t    )\n\t    return this as ReturnBuilderWithKeyAgreementMethod<this>\n\t  }\n\t  public addKeyAgreementUnsafe(\n\t    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n\t  ): ReturnBuilderWithKeyAgreementMethod<this> {\n\t    this.keyAgreement = this.addVerificationMethodOrDidOrString(\n", "      'keyAgreement',\n\t      this.keyAgreement,\n\t      verificationMethodOrStringOrDid,\n\t      true\n\t    )\n\t    return this as ReturnBuilderWithKeyAgreementMethod<this>\n\t  }\n\t  public addAssertionMethod(\n\t    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n\t  ): ReturnBuilderWithAssertionMethod<this> {\n", "    this.assertionMethod = this.addVerificationMethodOrDidOrString(\n\t      'assertionMethod',\n\t      this.assertionMethod,\n\t      verificationMethodOrStringOrDid\n\t    )\n\t    return this as ReturnBuilderWithAssertionMethod<this>\n\t  }\n\t  public addAssertionMethodUnsafe(\n\t    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n\t  ): ReturnBuilderWithAssertionMethod<this> {\n", "    this.assertionMethod = this.addVerificationMethodOrDidOrString(\n\t      'assertionMethod',\n\t      this.assertionMethod,\n\t      verificationMethodOrStringOrDid,\n\t      true\n\t    )\n\t    return this as ReturnBuilderWithAssertionMethod<this>\n\t  }\n\t  public addCapabilityDelegation(\n\t    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n", "  ): ReturnBuilderWithCapabilityDelegation<this> {\n\t    this.capabilityDelegation = this.addVerificationMethodOrDidOrString(\n\t      'capabilityDelegation',\n\t      this.capabilityDelegation,\n\t      verificationMethodOrStringOrDid\n\t    )\n\t    return this as ReturnBuilderWithCapabilityDelegation<this>\n\t  }\n\t  public addCapabilityDelegationUnsafe(\n\t    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n", "  ): ReturnBuilderWithCapabilityDelegation<this> {\n\t    this.capabilityDelegation = this.addVerificationMethodOrDidOrString(\n\t      'capabilityDelegation',\n\t      this.capabilityDelegation,\n\t      verificationMethodOrStringOrDid,\n\t      true\n\t    )\n\t    return this as ReturnBuilderWithCapabilityDelegation<this>\n\t  }\n\t  public addCapabilityInvocation(\n", "    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n\t  ): ReturnBuilderWithCapabilityInvocation<this> {\n\t    this.capabilityInvocation = this.addVerificationMethodOrDidOrString(\n\t      'capabilityInvocation',\n\t      this.capabilityInvocation,\n\t      verificationMethodOrStringOrDid\n\t    )\n\t    return this as ReturnBuilderWithCapabilityInvocation<this>\n\t  }\n\t  public addCapabilityInvocationUnsafe(\n", "    verificationMethodOrStringOrDid: VerificationMethodOrDidOrString\n\t  ): ReturnBuilderWithCapabilityInvocation<this> {\n\t    this.capabilityInvocation = this.addVerificationMethodOrDidOrString(\n\t      'capabilityInvocation',\n\t      this.capabilityInvocation,\n\t      verificationMethodOrStringOrDid,\n\t      true\n\t    )\n\t    return this as ReturnBuilderWithCapabilityInvocation<this>\n\t  }\n", "  public addService(service: ServiceOptions): ReturnBuilderWithService<this> {\n\t    const instanceService = new Service(service)\n\t    if (this.service) {\n\t      this.service.push(instanceService)\n\t    } else {\n\t      this.service = [instanceService]\n\t    }\n\t    uniqueServicesSchema.parse(this.service)\n\t    return this as ReturnBuilderWithService<this>\n\t  }\n", "  private addVerificationMethodOrDidOrString(\n\t    fieldName: string,\n\t    previousItem: Array<VerificationMethod | Did> | undefined,\n\t    verificationMethodOrDidOrString: VerificationMethodOrDidOrString,\n\t    unsafe = false\n\t  ) {\n\t    let newItem = previousItem\n\t    const id =\n\t      verificationMethodOrDidOrString instanceof Did\n\t        ? verificationMethodOrDidOrString\n", "        : typeof verificationMethodOrDidOrString === 'string'\n\t        ? new Did(verificationMethodOrDidOrString)\n\t        : undefined\n\t    if (id && !unsafe) {\n\t      const verificationMethodIds = this.verificationMethod?.map((vm) =>\n\t        vm.id.toUrl()\n\t      )\n\t      if (\n\t        verificationMethodIds === undefined ||\n\t        !verificationMethodIds.includes(id.toUrl())\n", "      ) {\n\t        throw new DidDocumentError(\n\t          `Tried to add '${id.toUrl()}' to '${fieldName}', but it was not found in the verificationMethod. If you want to add it anyways, try 'this.add${\n\t            fieldName.charAt(0).toUpperCase() + fieldName.slice(1)\n\t          }Unsafe(...)'`\n\t        )\n\t      }\n\t    }\n\t    const vm =\n\t      id === undefined\n", "        ? verificationMethodOrDidOrString instanceof VerificationMethod\n\t          ? verificationMethodOrDidOrString\n\t          : new VerificationMethod(\n\t              verificationMethodOrDidOrString as VerificationMethodOptions\n\t            )\n\t        : undefined\n\t    const item = id ?? vm\n\t    if (item) {\n\t      if (newItem) {\n\t        newItem.push(item)\n", "      } else {\n\t        newItem = [item]\n\t      }\n\t    } else {\n\t      throw new DidDocumentError(\n\t        `Something went wrong while trying to parse verification method for ${fieldName} with item ${verificationMethodOrDidOrString}`\n\t      )\n\t    }\n\t    uniqueStringOrVerificationMethodsSchema(fieldName).parse(newItem)\n\t    return newItem\n", "  }\n\t  public findServiceByType(type: string): Service {\n\t    const service = this.service?.find((s) =>\n\t      (typeof s.type === 'string' ? [s.type] : s.type).includes(type)\n\t    )\n\t    if (!service) {\n\t      throw new DidDocumentError(`Service not found for type '${type}'`)\n\t    }\n\t    return service\n\t  }\n", "  public safeFindServiceByType(type: string): Service | undefined {\n\t    try {\n\t      return this.findServiceByType(type)\n\t    } catch {\n\t      return undefined\n\t    }\n\t  }\n\t  public findServiceById(id: string): Service {\n\t    const service = this.service?.find((s) => s.id === id)\n\t    if (!service) {\n", "      throw new DidDocumentError(`Service not found with id '${id}'`)\n\t    }\n\t    return service\n\t  }\n\t  public safeFindServiceById(id: string): Service | undefined {\n\t    try {\n\t      return this.findServiceById(id)\n\t    } catch {\n\t      return undefined\n\t    }\n", "  }\n\t  public findVerificationMethodByTypeAndPurpose(\n\t    type: string,\n\t    purpose:\n\t      | 'authentication'\n\t      | 'keyAgreement'\n\t      | 'assertionMethod'\n\t      | 'capabilityInvocation'\n\t      | 'capabilityDelegation'\n\t      | 'verificationMethod' = 'verificationMethod'\n", "  ): VerificationMethod {\n\t    const field =\n\t      purpose === 'authentication'\n\t        ? this.authentication\n\t        : purpose === 'keyAgreement'\n\t        ? this.keyAgreement\n\t        : purpose === 'assertionMethod'\n\t        ? this.assertionMethod\n\t        : purpose === 'capabilityInvocation'\n\t        ? this.capabilityInvocation\n", "        : purpose === 'capabilityDelegation'\n\t        ? this.capabilityInvocation\n\t        : this.verificationMethod\n\t    if (!field) {\n\t      throw new DidDocumentError(\n\t        `Purpose '${purpose}' does not exist inside the did document`\n\t      )\n\t    }\n\t    const vm = field\n\t      .map((f) =>\n", "        f instanceof Did ? this.safeFindToVerificationMethodByDidUrl(f) : f\n\t      )\n\t      .find((vm) => vm?.type === type)\n\t    if (!vm) {\n\t      throw new DidDocumentError(\n\t        `Purpose '${purpose}' does not have a field with type '${type}'`\n\t      )\n\t    }\n\t    return vm\n\t  }\n", "  public safeFindVerificationMethodByTypeAndPurpose(\n\t    type: string,\n\t    purpose:\n\t      | 'authentication'\n\t      | 'keyAgreement'\n\t      | 'assertionMethod'\n\t      | 'capabilityInvocation'\n\t      | 'capabilityDelegation'\n\t      | 'verificationMethod' = 'verificationMethod'\n\t  ): VerificationMethod | undefined {\n", "    try {\n\t      return this.findVerificationMethodByTypeAndPurpose(type, purpose)\n\t    } catch {\n\t      return undefined\n\t    }\n\t  }\n\t  public isVerificationMethodTypeRegistered(\n\t    id: Did | string,\n\t    additionalAcceptedTypes: string | Array<string> = []\n\t  ): boolean {\n", "    const vm = this.findVerificationMethodByDidUrl(id)\n\t    return vm.isTypeInDidSpecRegistry(additionalAcceptedTypes)\n\t  }\n\t  public isServiceTypeRegistered(\n\t    id: string,\n\t    additionalAcceptedTypes: string | Array<string> = []\n\t  ): boolean {\n\t    const service = this.findServiceById(id)\n\t    return service.isTypeInDidSpecRegistry(additionalAcceptedTypes)\n\t  }\n", "  public toJSON(omitKeys?: Array<string>): Record<string, unknown> {\n\t    const mapStringOrVerificationMethod = (i: Did | VerificationMethod) =>\n\t      i.toJSON()\n\t    const omitBase = ['fullDocument']\n\t    const omitKeysWithBase = omitKeys ? [...omitBase, ...omitKeys] : omitBase\n\t    const mappedRest = {\n\t      ...this.fullDocument,\n\t      id: this.id.did,\n\t      alsoKnownAs: this.alsoKnownAs,\n\t      controller:\n", "        this.controller && this.controller instanceof Did\n\t          ? this.controller?.did\n\t          : this.controller?.map((c) => c.did),\n\t      verificationMethod: this.verificationMethod?.map((v) => v.toJSON()),\n\t      service: this.service?.map((s) => s.toJSON()),\n\t      assertionMethod: this.assertionMethod?.map(mapStringOrVerificationMethod),\n\t      keyAgreement: this.keyAgreement?.map(mapStringOrVerificationMethod),\n\t      capabilityInvocation: this.capabilityInvocation?.map(\n\t        mapStringOrVerificationMethod\n\t      ),\n", "      capabilityDelegation: this.capabilityDelegation?.map(\n\t        mapStringOrVerificationMethod\n\t      ),\n\t      authentication: this.authentication?.map(mapStringOrVerificationMethod),\n\t    }\n\t    const cleanedRest = Object.fromEntries(\n\t      Object.entries(mappedRest)\n\t        .filter(([_, value]) => value !== undefined)\n\t        .filter(([key]) => !omitKeysWithBase.includes(key))\n\t    )\n", "    return cleanedRest\n\t  }\n\t}\n"]}
{"filename": "src/service.ts", "chunked_list": ["import { z } from 'zod'\n\timport { serviceSchema } from './schemas'\n\timport { ServiceTypes } from './serviceTypes'\n\texport type ServiceOptions = z.input<typeof serviceSchema> &\n\t  Record<string, unknown>\n\texport class Service {\n\t  public fullService: ServiceOptions\n\t  public id: string\n\t  public type: ServiceTypes | string | Array<ServiceTypes | string>\n\t  public serviceEndpoint: string | Array<string> | Record<string, string>\n", "  public constructor(options: ServiceOptions) {\n\t    this.fullService = options\n\t    const { id, type, serviceEndpoint } = serviceSchema.parse(options)\n\t    this.id = id\n\t    this.type = type\n\t    this.serviceEndpoint = serviceEndpoint\n\t  }\n\t  /**\n\t   * Checks whether the service type is registered inside the @{link https://www.w3.org/TR/did-spec-registries/#service-types | service types}\n\t   *\n", "   */\n\t  public isTypeInDidSpecRegistry(\n\t    additionalAcceptedTypes: string | Array<string> = []\n\t  ): boolean {\n\t    const additionalAcceptedTypesArray =\n\t      typeof additionalAcceptedTypes === 'string'\n\t        ? [additionalAcceptedTypes]\n\t        : additionalAcceptedTypes\n\t    const allTypes = (Object.values(ServiceTypes) as Array<string>).concat(\n\t      additionalAcceptedTypesArray\n", "    )\n\t    return typeof this.type === 'string'\n\t      ? allTypes.includes(this.type)\n\t      : this.type.every(allTypes.includes)\n\t  }\n\t  public toJSON() {\n\t    const { fullService, ...rest } = this\n\t    return rest\n\t  }\n\t}\n"]}
{"filename": "src/publicKeyJwk.ts", "chunked_list": ["import { publicKeyJwkSchema } from './schemas'\n\timport { z } from 'zod'\n\texport type PublicKeyJwkOptions = z.input<typeof publicKeyJwkSchema> &\n\t  Record<string, unknown>\n\texport class PublicKeyJwk {\n\t  public fullPublicKeyJwk: PublicKeyJwkOptions\n\t  public constructor(options: PublicKeyJwkOptions) {\n\t    this.fullPublicKeyJwk = options\n\t    publicKeyJwkSchema.parse(options)\n\t  }\n", "  public toJSON() {\n\t    const { fullPublicKeyJwk, ...rest } = this.fullPublicKeyJwk\n\t    return rest\n\t  }\n\t}\n"]}
{"filename": "src/publicKeyMultibase.ts", "chunked_list": ["import { publicKeyMultibaseSchema } from './schemas'\n\timport { z } from 'zod'\n\texport type PublicKeyMultibaseOptions = z.input<typeof publicKeyMultibaseSchema>\n\texport class PublicKeyMultibase {\n\t  public publicKeyMultibase: PublicKeyMultibaseOptions\n\t  public properties: PublicKeyMultibaseOptions\n\t  public constructor(options: PublicKeyMultibaseOptions) {\n\t    this.publicKeyMultibase = options\n\t    this.properties = publicKeyMultibaseSchema.parse(options)\n\t  }\n", "  public toJSON() {\n\t    this.publicKeyMultibase.toString()\n\t  }\n\t}\n"]}
{"filename": "src/didResolution.ts", "chunked_list": ["import { Impossible, OrPromise } from './types'\n\timport { DidDocumentOptions } from './didDocument'\n\texport type ResolutionOptions<T extends Record<string, unknown>> = {\n\t  accept: string\n\t} & T\n\texport type DidResolutionMetadata<T extends Record<string, unknown>> = {\n\t  contentType: string\n\t  error?: 'invalidDid' | 'notFound' | 'representationNotSupported' | string\n\t} & T\n\t// resolveRepresentation(did, resolutionOptions) \n", "//  didResolutionMetadata, didDocumentStream, didDocumentMetadata \n\texport type DidDocumentMetadata<T extends Record<string, unknown>> = {\n\t  created?: string\n\t  updated?: string\n\t  deactivated?: string\n\t  nextUpdate?: string\n\t  versionId?: string\n\t  equivalentId?: Array<string>\n\t  canonicalId?: string\n\t} & T\n", "export interface DidResolution<\n\t  AdditionalOptions extends Record<string, unknown> = {},\n\t  AdditionalDidResolutionMetadata extends Record<string, unknown> = {},\n\t  AdditionalDidDocument extends Record<string, unknown> = {},\n\t  AdditionalDidDocumentMetadata extends Record<string, unknown> = {}\n\t> {\n\t  resolve(\n\t    did: string,\n\t    resolutionOptions?: Impossible<\n\t      ResolutionOptions<AdditionalOptions>,\n", "      'accept'\n\t    >\n\t  ): OrPromise<{\n\t    didResolutionMetadata: Impossible<\n\t      DidResolutionMetadata<AdditionalDidResolutionMetadata>,\n\t      'contentType'\n\t    >\n\t    didDocument: DidDocumentOptions<AdditionalDidDocument>\n\t    didDocumentMetadata: DidDocumentMetadata<AdditionalDidDocumentMetadata>\n\t  }>\n", "  resolvePresentation(\n\t    did: string,\n\t    resolutionOptions?: ResolutionOptions<AdditionalOptions>\n\t  ): OrPromise<{\n\t    didResolutionMetadata: DidResolutionMetadata<AdditionalDidResolutionMetadata>\n\t    didDocumentStream: Uint8Array\n\t    didDocumentMetadata: DidDocumentMetadata<AdditionalDidDocumentMetadata>\n\t  }>\n\t}\n"]}
{"filename": "src/error.ts", "chunked_list": ["export class DidDocumentError extends Error {}\n\texport class DidError extends Error {}\n\texport class VerificationMethodError extends Error {}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './did'\n\texport * from './didDocument'\n\texport * from './verificationMethod'\n\texport * from './service'\n\texport * from './publicKeyJwk'\n\texport * from './publicKeyMultibase'\n\texport * from './error'\n\texport * from './verificationMethodTypes'\n\texport * from './serviceTypes'\n\texport * from './representations'\n", "export * from './didResolution'\n\texport * from './didUrlDereference'\n\texport * from './schemas'\n"]}
{"filename": "src/serviceTypes.ts", "chunked_list": ["/**\n\t * These are values to be used for the type property in a service object.\n\t *\n\t * @see {@link https://www.w3.org/TR/did-spec-registries/#service-types}\n\t */\n\texport enum ServiceTypes {\n\t  /**\n\t   * LinkedDomains IRI is not stable\n\t   *\n\t   * @see {@link https://identity.foundation/.well-known/resources/did-configuration/#LinkedDomains}\n", "   *\n\t   * @note If this link changes the term defintion registered in did core will need to change, we should be sure we like this URL as is... forever.\n\t   */\n\t  LinkedDomains = 'LinkedDomains',\n\t  DIDCommMessaging = 'DIDCommMessaging',\n\t  /**\n\t   * The CredentialRegistry endpoint allows publication of a dedicated service\n\t   * endpoint in a DID document, through which verifiable credentials can be\n\t   * queried. Each registry endpoint is a REST endpoint. When a GET request is\n\t   * sent to the URI formed by appending the credentialSubject.id as a\n", "   * URL-encoded string to the given endpoint URI, the registry MUST return an\n\t   * array of verifiable credentials associated with the subject ID. A sample\n\t   * registry endpoint can be found {@link https://ssi.eecc.de/api/registry/swagger/#/Credentials/get_api_registry_vcs__id_ | here}.\n\t   */\n\t  CredentialRegistry = 'CredentialRegistry',\n\t}\n"]}
{"filename": "src/did.ts", "chunked_list": ["import { z } from 'zod'\n\timport {\n\t  didUrlSchemaWithouttransformation,\n\t  stringOrDid,\n\t  stringOrDidUrl,\n\t} from './schemas'\n\texport const PREFIX_PATH = '/'\n\texport const PREFIX_QUERY = '?'\n\texport const PREFIX_FRAGMENT = '#'\n\tconst DEFAULT_PARAMETER_KEYS = [\n", "  'service',\n\t  'relativeRef',\n\t  'versionId',\n\t  'versionTime',\n\t  'hl',\n\t]\n\texport type DidParts = {\n\t  scheme: string\n\t  method: string\n\t  namespaces?: Array<string>\n", "  identifier: string\n\t}\n\texport type DidUrlParts = {\n\t  path?: string\n\t  query?: Record<string, string>\n\t  fragment?: string\n\t  parameters?: Record<string, string>\n\t}\n\texport class Did {\n\t  public did: string\n", "  private path?: string\n\t  private query?: Record<string, string>\n\t  private fragment?: string\n\t  private parameters?: Record<string, string>\n\t  private parameterKeys: Array<string>\n\t  public constructor(did: string, parameterKeys?: Array<string>) {\n\t    const parsedDid = didUrlSchemaWithouttransformation.parse(did)\n\t    const url = new URL(parsedDid)\n\t    const prefixPathIndex = url.pathname.indexOf(PREFIX_PATH)\n\t    const stripUntil = Math.min(\n", "      ...[\n\t        did.indexOf(PREFIX_PATH),\n\t        did.indexOf(PREFIX_QUERY),\n\t        did.indexOf(PREFIX_FRAGMENT),\n\t      ].filter((i) => i !== -1)\n\t    )\n\t    const didBase = stripUntil !== -1 ? did.slice(0, stripUntil) : did\n\t    const path = (\n\t      prefixPathIndex !== -1 ? url.pathname.slice(prefixPathIndex) : ''\n\t    ).substring(1)\n", "    const query = url.search.substring(1)\n\t    const queryParams = new URLSearchParams(query)\n\t    const fragment = url.hash.substring(1)\n\t    this.parameterKeys = parameterKeys\n\t      ? [...DEFAULT_PARAMETER_KEYS, ...parameterKeys]\n\t      : DEFAULT_PARAMETER_KEYS\n\t    this.did = didBase\n\t    this.path = path.length > 0 ? path : undefined\n\t    this.query =\n\t      queryParams.size > 0\n", "        ? [...queryParams.entries()].reduce(\n\t            (prev, [k, v]) => ({ [k]: v, ...prev } as Record<string, string>),\n\t            {}\n\t          )\n\t        : undefined\n\t    this.fragment = fragment.length > 0 ? fragment : undefined\n\t    this.parameters = this.query\n\t      ? Object.entries(this.query).reduce((prev, [k, v]) => {\n\t          if (this.parameterKeys?.includes(k)) {\n\t            return { [k]: v, ...prev }\n", "          }\n\t          return prev\n\t        }, {})\n\t      : undefined\n\t  }\n\t  public isDidUrl(): boolean {\n\t    return Boolean(this.path || this.query || this.fragment)\n\t  }\n\t  public static validateDid(did: z.input<typeof stringOrDid>): boolean {\n\t    return stringOrDid.safeParse(did).success\n", "  }\n\t  public static validateDidUrl(did: z.input<typeof stringOrDidUrl>): boolean {\n\t    return stringOrDidUrl.safeParse(did).success\n\t  }\n\t  public validate(): boolean {\n\t    if (this.isDidUrl()) {\n\t      return Did.validateDidUrl(this.toUrl())\n\t    } else {\n\t      return Did.validateDid(this.did)\n\t    }\n", "  }\n\t  public toUrl(): string {\n\t    const path = this.path ? `${PREFIX_PATH}${this.path}` : ''\n\t    const queryString = new URLSearchParams(this.query).toString()\n\t    const query = this.query ? `${PREFIX_QUERY}${queryString}` : ''\n\t    const fragment = this.fragment ? `${PREFIX_FRAGMENT}${this.fragment}` : ''\n\t    return `${this.did}${path}${query}${fragment}`\n\t  }\n\t  public withPath(path: string): this {\n\t    this.path = this.stripOptionalPrefix(path, PREFIX_PATH)\n", "    return this\n\t  }\n\t  public addPath(path: string): this {\n\t    if (this.path) {\n\t      this.path = this.path + this.addPrefixIfNotSupplied(path, PREFIX_PATH)\n\t    } else {\n\t      return this.withPath(path)\n\t    }\n\t    return this\n\t  }\n", "  public removePath(): this {\n\t    this.path = undefined\n\t    return this\n\t  }\n\t  public withQuery(query: Record<string, string>): this {\n\t    this.query = query\n\t    return this\n\t  }\n\t  public addQuery(query: Record<string, string>): this {\n\t    if (this.query) {\n", "      this.query = { ...this.query, ...query }\n\t    } else {\n\t      this.withQuery(query)\n\t    }\n\t    return this\n\t  }\n\t  public removeQuery(): this {\n\t    this.query = undefined\n\t    return this\n\t  }\n", "  public withFragment(fragment: string): this {\n\t    this.fragment = this.stripOptionalPrefix(fragment, PREFIX_FRAGMENT)\n\t    return this\n\t  }\n\t  public removeFragment(): this {\n\t    this.fragment = undefined\n\t    return this\n\t  }\n\t  public get didParts(): DidParts {\n\t    const parts = this.did.split(':')\n", "    const scheme = parts[0]\n\t    const method = parts[1]\n\t    const identifier = parts[parts.length - 1]\n\t    const namespaces = parts.slice(2, parts.length - 1)\n\t    return {\n\t      scheme,\n\t      method,\n\t      identifier,\n\t      namespaces: namespaces.length > 0 ? namespaces : undefined,\n\t    }\n", "  }\n\t  public get didUrlParts(): DidUrlParts {\n\t    // This is done because the params are calculated based on the query and parameterKeys, but is you set additional parameter keys later on the new parameter field is not updated\n\t    const newDid = new Did(this.toUrl(), this.parameterKeys)\n\t    return {\n\t      fragment: newDid.fragment,\n\t      path: newDid.path,\n\t      query: newDid.query,\n\t      parameters: newDid.parameters,\n\t    }\n", "  }\n\t  private stripOptionalPrefix(s: string, p: string): string {\n\t    if (s.startsWith(p)) {\n\t      return s.slice(1)\n\t    }\n\t    return s\n\t  }\n\t  private addPrefixIfNotSupplied(s: string, p: string): string {\n\t    if (s.startsWith(p)) {\n\t      return s\n", "    }\n\t    return `${p}${s}`\n\t  }\n\t  public addParameterKey(key: string | Array<string>): this {\n\t    if (typeof key === 'string') {\n\t      this.parameterKeys.push(key)\n\t    } else if (Array.isArray(key)) {\n\t      this.parameterKeys.push(...key)\n\t    }\n\t    return this\n", "  }\n\t  public toString() {\n\t    return this.toUrl()\n\t  }\n\t  public toJSON() {\n\t    return this.toString()\n\t  }\n\t}\n"]}
{"filename": "src/didUrlDereference.ts", "chunked_list": ["import { OrPromise } from './types'\n\texport type DereferenceOptions<T extends Record<string, unknown>> = {\n\t  accept?: string\n\t} & T\n\texport type DereferencingMetadata<T extends Record<string, unknown>> = {\n\t  contentType?: string\n\t  error?: 'invalidDidUrl' | 'notFound' | string\n\t} & T\n\texport interface DidUrlDereference<\n\t  AdditionalDereferenceOptions extends Record<string, unknown> = {},\n", "  AdditionalDereferencingMetadata extends Record<string, unknown> = {},\n\t  ContentStream = unknown,\n\t  ContentMetadata extends Record<string, unknown> = {}\n\t> {\n\t  dereference(\n\t    didUrl: string,\n\t    dereferenceOptions: DereferenceOptions<AdditionalDereferenceOptions>\n\t  ): OrPromise<{\n\t    dereferencingMetadata: DereferencingMetadata<AdditionalDereferencingMetadata>\n\t    contentStream?: ContentStream\n", "    contentMetadata: ContentMetadata\n\t  }>\n\t}\n"]}
{"filename": "src/verificationMethod.ts", "chunked_list": ["import type { Modify } from './types'\n\timport { verificationMethodSchema } from './schemas'\n\timport { Did } from './did'\n\timport { z } from 'zod'\n\timport { PublicKeyJwk, PublicKeyJwkOptions } from './publicKeyJwk'\n\timport {\n\t  PublicKeyMultibaseOptions,\n\t  PublicKeyMultibase,\n\t} from './publicKeyMultibase'\n\timport { VerificationMethodTypes } from './verificationMethodTypes'\n", "export type VerificationMethodOptions = Modify<\n\t  z.input<typeof verificationMethodSchema>,\n\t  {\n\t    publicKeyJwk?: PublicKeyJwkOptions | PublicKeyJwk\n\t    publicKeyMultibase?: PublicKeyMultibaseOptions | PublicKeyMultibase\n\t  }\n\t> &\n\t  Record<string, unknown>\n\texport class VerificationMethod {\n\t  public fullVerificationMethod: VerificationMethodOptions\n", "  id: Did\n\t  controller: Did\n\t  type: VerificationMethodTypes | string\n\t  publicKeyJwk?: PublicKeyJwk\n\t  publicKeyMultibase?: PublicKeyMultibase\n\t  public constructor(options: VerificationMethodOptions) {\n\t    this.fullVerificationMethod = options\n\t    const { id, controller, type, publicKeyJwk, publicKeyMultibase } =\n\t      verificationMethodSchema.parse(options)\n\t    this.id = id\n", "    this.controller = controller\n\t    this.type = type\n\t    this.publicKeyJwk = publicKeyJwk\n\t    this.publicKeyMultibase = publicKeyMultibase\n\t  }\n\t  /**\n\t   * Checks whether the verification method type is registered inside the @{link https://www.w3.org/TR/did-spec-registries/#verification-method-types | verification method types}\n\t   *\n\t   */\n\t  public isTypeInDidSpecRegistry(\n", "    additionalAcceptedTypes: string | Array<string> = []\n\t  ): boolean {\n\t    const additionalAcceptedTypesArray =\n\t      typeof additionalAcceptedTypes === 'string'\n\t        ? [additionalAcceptedTypes]\n\t        : additionalAcceptedTypes\n\t    const allTypes = (\n\t      Object.values(VerificationMethodTypes) as Array<string>\n\t    ).concat(additionalAcceptedTypesArray)\n\t    return allTypes.includes(this.type)\n", "  }\n\t  public toJSON() {\n\t    const mappedRest = {\n\t      id: this.id.toJSON(),\n\t      controller: this.controller.toJSON(),\n\t      type: this.type,\n\t      publicKeyJwk: this.publicKeyJwk?.toJSON(),\n\t      publicKeyMultibase: this.publicKeyMultibase?.toJSON(),\n\t    }\n\t    const cleanedRest = Object.fromEntries(\n", "      Object.entries(mappedRest).filter(([_, value]) => value !== undefined)\n\t    )\n\t    return cleanedRest\n\t  }\n\t}\n"]}
{"filename": "src/schemas/serviceSchema.ts", "chunked_list": ["import { z } from 'zod'\n\texport const serviceSchema = z.object({\n\t  id: z.string().url(),\n\t  type: z.union([z.string(), z.array(z.string())]),\n\t  serviceEndpoint: z.union([\n\t    z.string().url(),\n\t    z.array(z.string().url()),\n\t    z.object({}),\n\t  ]),\n\t})\n", "export const uniqueServicesSchema = z\n\t  .array(serviceSchema)\n\t  .refine((services) => {\n\t    const idSet = new Set()\n\t    for (const obj of services) {\n\t      if (idSet.has(obj.id)) {\n\t        return false\n\t      }\n\t      idSet.add(obj.id)\n\t    }\n", "    return true\n\t  }, 'Duplicate service.id found. They must be unique')\n"]}
{"filename": "src/schemas/publicKeyJwkSchema.ts", "chunked_list": ["import { PublicKeyJwk } from '../publicKeyJwk'\n\timport { z } from 'zod'\n\texport const publicKeyJwkSchema = z.union([\n\t  z.object({\n\t    kty: z.string(),\n\t    use: z.optional(z.string()),\n\t    crv: z.optional(z.string()),\n\t    x: z.optional(z.string()),\n\t    y: z.optional(z.string()),\n\t    e: z.optional(z.string()),\n", "    n: z.optional(z.string()),\n\t    key_ops: z.optional(z.string()),\n\t    alg: z.optional(z.string()),\n\t    kid: z.optional(z.string()),\n\t    d: z.optional(\n\t      z.undefined({\n\t        invalid_type_error:\n\t          \"'d' is not allowed to be supplied as it contains a private key material\",\n\t      })\n\t    ),\n", "  }),\n\t  z.custom<PublicKeyJwk>(\n\t    (publicKeyJwk) => publicKeyJwk instanceof PublicKeyJwk\n\t  ),\n\t])\n"]}
{"filename": "src/schemas/verificationMethodSchema.ts", "chunked_list": ["import { z } from 'zod'\n\timport { stringOrDid, stringOrDidUrl } from './didSchema'\n\timport { publicKeyJwkSchema } from './publicKeyJwkSchema'\n\timport { publicKeyMultibaseSchema } from './publicKeyMultibaseSchema'\n\timport { PublicKeyJwk } from '../publicKeyJwk'\n\timport { PublicKeyMultibase } from '../publicKeyMultibase'\n\timport { VerificationMethod } from '../verificationMethod'\n\timport { Did } from '../did'\n\texport const verificationMethodSchema = z\n\t  .union([\n", "    z.object({\n\t      id: stringOrDidUrl,\n\t      controller: stringOrDid,\n\t      type: z.string(),\n\t      publicKeyJwk: z.optional(publicKeyJwkSchema),\n\t      publicKeyMultibase: z.optional(publicKeyMultibaseSchema),\n\t    }),\n\t    z.custom<VerificationMethod>(\n\t      (verificationMethod) => verificationMethod instanceof VerificationMethod\n\t    ),\n", "  ])\n\t  .superRefine((data, ctx) => {\n\t    if (data.publicKeyJwk && data.publicKeyMultibase) {\n\t      ctx.addIssue({\n\t        code: z.ZodIssueCode.custom,\n\t        path: ['publicKeyJwk & publicKeyMultibase'],\n\t        message:\n\t          'Supplying both publicKeyJwk and publicKeyMultibase is not permitted',\n\t      })\n\t    }\n", "  })\n\t  .transform((verificationMethod) => ({\n\t    id: verificationMethod.id,\n\t    type: verificationMethod.type,\n\t    controller: verificationMethod.controller,\n\t    publicKeyJwk: verificationMethod.publicKeyJwk\n\t      ? verificationMethod.publicKeyJwk instanceof PublicKeyJwk\n\t        ? verificationMethod.publicKeyJwk\n\t        : new PublicKeyJwk(verificationMethod.publicKeyJwk)\n\t      : undefined,\n", "    publicKeyMultibase: verificationMethod.publicKeyMultibase\n\t      ? verificationMethod.publicKeyMultibase instanceof PublicKeyMultibase\n\t        ? verificationMethod.publicKeyMultibase\n\t        : new PublicKeyMultibase(verificationMethod.publicKeyMultibase)\n\t      : undefined,\n\t  }))\n\texport const uniqueVerificationMethodsSchema = z\n\t  .array(verificationMethodSchema)\n\t  .refine((verificationMethods) => {\n\t    const idSet = new Set()\n", "    for (const obj of verificationMethods) {\n\t      if (idSet.has(obj.id)) {\n\t        return false\n\t      }\n\t      idSet.add(obj.id)\n\t    }\n\t    return true\n\t  }, `Duplicate verificationMethod.id found. They must be unique`)\n\texport const stringOrVerificationMethod = z\n\t  .union([stringOrDidUrl, verificationMethodSchema])\n", "  .transform((verificationMethod) => {\n\t    if (verificationMethod instanceof Did) {\n\t      return verificationMethod\n\t    }\n\t    return new VerificationMethod(verificationMethod)\n\t  })\n\texport const uniqueStringOrVerificationMethodsSchema = (name: string) =>\n\t  z.array(stringOrVerificationMethod).refine((verificationMethods) => {\n\t    const idSet = new Set()\n\t    for (const obj of verificationMethods) {\n", "      const id = obj instanceof Did ? obj.toUrl() : obj.id.toUrl()\n\t      if (idSet.has(id)) {\n\t        return false\n\t      }\n\t      idSet.add(id)\n\t    }\n\t    return true\n\t  }, `Duplicate ${name}.id found. They must be unique`)\n"]}
{"filename": "src/schemas/index.ts", "chunked_list": ["export * from './didSchema'\n\texport * from './didDocumentSchema'\n\texport * from './verificationMethodSchema'\n\texport * from './serviceSchema'\n\texport * from './publicKeyJwkSchema'\n\texport * from './publicKeyMultibaseSchema'\n"]}
{"filename": "src/schemas/publicKeyMultibaseSchema.ts", "chunked_list": ["import { PublicKeyMultibase } from '../publicKeyMultibase'\n\timport { z } from 'zod'\n\texport const publicKeyMultibaseSchema = z.union([\n\t  z.string(),\n\t  z.custom<PublicKeyMultibase>(\n\t    (publicKeyMultibase) => publicKeyMultibase instanceof PublicKeyMultibase\n\t  ),\n\t])\n"]}
{"filename": "src/schemas/didSchema.ts", "chunked_list": ["import { DidError } from '../error'\n\timport { Did } from '../did'\n\timport { z } from 'zod'\n\tconst DID_URL_REGEXP =\n\t  /^did:[a-z0-9]+(?::[a-z0-9]+(?:[._-][a-z0-9]+)*)*:(?:[a-z0-9]+(?:[._-][a-z0-9]+)*)?(?:\\/[^?\\s]*)?(?:\\?[^#\\s]*)?(?:#[^\\s]*)?$/i\n\tconst DID_REGEXP =\n\t  /^did:[a-z0-9]+(?::[a-z0-9]+(?:[._-][a-z0-9]+)*)*(?:#[^s]*)?$/i\n\texport const didUrlSchemaWithouttransformation = z\n\t  .string()\n\t  .regex(DID_URL_REGEXP, { message: 'Invalid did url syntax' })\n", "export const didSchemaWithouttransformation = z\n\t  .string()\n\t  .regex(DID_REGEXP, { message: 'Invalid did syntax' })\n\texport const stringOrDid = z\n\t  .union([\n\t    didSchemaWithouttransformation,\n\t    z.custom<Did>((did) => did instanceof Did),\n\t  ])\n\t  .transform((did: string | Did): Did => {\n\t    if (typeof did === 'string') {\n", "      return new Did(did)\n\t    } else if (did instanceof Did) {\n\t      return did\n\t    } else {\n\t      throw new DidError(`id must be of type 'string' or an instance of 'Did'`)\n\t    }\n\t  })\n\texport const stringOrDidUrl = z\n\t  .union([\n\t    didUrlSchemaWithouttransformation,\n", "    z.custom<Did>((did) => did instanceof Did),\n\t  ])\n\t  .transform((did: string | Did): Did => {\n\t    if (typeof did === 'string') {\n\t      return new Did(did)\n\t    } else if (did instanceof Did) {\n\t      return did\n\t    } else {\n\t      throw new DidError(`id must be of type 'string' or an instance of 'Did'`)\n\t    }\n", "  })\n"]}
{"filename": "src/schemas/didDocumentSchema.ts", "chunked_list": ["import { z } from 'zod'\n\timport { stringOrDid } from './didSchema'\n\timport {\n\t  uniqueStringOrVerificationMethodsSchema,\n\t  verificationMethodSchema,\n\t} from './verificationMethodSchema'\n\timport { uniqueServicesSchema } from './serviceSchema'\n\timport { Service } from '../service'\n\timport { VerificationMethod } from '../verificationMethod'\n\texport const didDocumentSchema = z\n", "  .object({\n\t    id: stringOrDid,\n\t    alsoKnownAs: z.optional(z.array(z.string().url())),\n\t    controller: z.optional(z.union([stringOrDid, z.array(stringOrDid)])),\n\t    verificationMethod: z.optional(z.array(verificationMethodSchema)),\n\t    authentication: z.optional(\n\t      uniqueStringOrVerificationMethodsSchema('authentication')\n\t    ),\n\t    assertionMethod: z.optional(\n\t      uniqueStringOrVerificationMethodsSchema('assertionMethod')\n", "    ),\n\t    keyAgreement: z.optional(\n\t      uniqueStringOrVerificationMethodsSchema('keyAgreement')\n\t    ),\n\t    capabilityInvocation: z.optional(\n\t      uniqueStringOrVerificationMethodsSchema('capabilityInvocation')\n\t    ),\n\t    capabilityDelegation: z.optional(\n\t      uniqueStringOrVerificationMethodsSchema('capabilityInvocation')\n\t    ),\n", "    service: z.optional(uniqueServicesSchema),\n\t  })\n\t  .transform((didDocument) => ({\n\t    ...didDocument,\n\t    service: didDocument.service?.map((s) => new Service(s)),\n\t    verificationMethod: didDocument.verificationMethod?.map(\n\t      (v) => new VerificationMethod(v)\n\t    ),\n\t  }))\n"]}
