{"filename": "vite.config.ts", "chunked_list": ["import react from '@vitejs/plugin-react-swc';\n\timport { resolve } from 'path';\n\timport { defineConfig } from 'vite';\n\timport eslint from 'vite-plugin-eslint';\n\timport { dependencies } from './package.json';\n\tconst projectRootDir = resolve(__dirname);\n\tconst BASE_CHUNKS = {\n\t  vendor: ['react', 'react-router-dom', 'react-dom', 'swr', 'react-icons'],\n\t  ui: ['@chakra-ui/react', '@emotion/react'],\n\t};\n", "function renderChunks(deps: Record<string, string>) {\n\t  const chunks = {};\n\t  const alreadySplit = Object.values(BASE_CHUNKS).reduce((acc, l) => acc.concat(l), []);\n\t  Object.keys(deps).forEach((key) => {\n\t    if (alreadySplit.includes(key)) return;\n\t    chunks[key] = [key];\n\t  });\n\t  return chunks;\n\t}\n\t// https://vitejs.dev/config/\n", "export default defineConfig({\n\t  plugins: [\n\t    react(),\n\t    {\n\t      // default settings on build (i.e. fail on error)\n\t      ...eslint(),\n\t      apply: 'build',\n\t    },\n\t    {\n\t      // do not fail on serve (i.e. local development)\n", "      ...eslint({\n\t        failOnWarning: false,\n\t        failOnError: false,\n\t        fix: true,\n\t      }),\n\t      apply: 'serve',\n\t      enforce: 'post',\n\t    },\n\t    // splitVendorChunkPlugin(),\n\t  ],\n", "  // base: \"/Encryptly/\",\n\t  resolve: {\n\t    alias: { '@app': resolve(projectRootDir, '/src') },\n\t  },\n\t  server: {\n\t    host: '0.0.0.0',\n\t    port: 3000,\n\t    open: false,\n\t    cors: true,\n\t  },\n", "  preview: {\n\t    host: '0.0.0.0',\n\t    port: 3000,\n\t  },\n\t  build: {\n\t    outDir: 'dist',\n\t    sourcemap: false,\n\t    rollupOptions: {\n\t      cache: true,\n\t      output: {\n", "        format: 'esm',\n\t        manualChunks: {\n\t          ...BASE_CHUNKS,\n\t          ...renderChunks(dependencies),\n\t        },\n\t      },\n\t    },\n\t  },\n\t});\n"]}
{"filename": "src/theme.ts", "chunked_list": ["import { ComponentStyleConfig, extendTheme } from '@chakra-ui/react';\n\tconst AlertStyle: ComponentStyleConfig = {\n\t  // style object for base or default style\n\t  baseStyle: {\n\t    container: {\n\t      borderWidth: '3px',\n\t      borderRadius: '6px',\n\t      borderColor: 'black',\n\t      // maxWidth: \"25rem\",\n\t      padding: '1rem',\n", "      boxShadow: 'none',\n\t    },\n\t    title: {\n\t      fontWeight: 'bold',\n\t      fontSize: 'lg',\n\t      marginBottom: '.8rem',\n\t    },\n\t    description: {\n\t      fontSize: 'sm',\n\t      fontWeight: 'medium',\n", "      lineHeight: '1rem',\n\t    },\n\t  },\n\t  // styles for different sizes (\"sm\", \"md\", \"lg\")\n\t  sizes: {},\n\t  // styles for different visual variants (\"outline\", \"solid\")\n\t  variants: {},\n\t  // default values for 'size', 'variant' and 'colorScheme'\n\t  defaultProps: {\n\t    variant: 'solid',\n", "  },\n\t};\n\tconst ButtonStyle: ComponentStyleConfig = {\n\t  baseStyle: {},\n\t  sizes: {},\n\t  variants: {\n\t    solid: {\n\t      borderRadius: '0',\n\t      borderWidth: '3px',\n\t      borderColor: 'black',\n", "      boxShadow: '-8px 8px 0px 0px #000',\n\t      _hover: {\n\t        boxShadow: 'none',\n\t      },\n\t    },\n\t  },\n\t  defaultProps: {},\n\t};\n\tconst InputStyle: ComponentStyleConfig = {\n\t  baseStyle: {\n", "    field: {\n\t      borderRadius: '10px',\n\t      borderWidth: '3px!important',\n\t      borderColor: 'black',\n\t      boxShadow: '-4px 4px 0px 0px #000',\n\t      _hover: { boxShadow: 'none' },\n\t    },\n\t    addon: {\n\t      border: '3px solid',\n\t    },\n", "  },\n\t  sizes: {},\n\t  variants: {},\n\t  defaultProps: {},\n\t};\n\tconst CardStyle: ComponentStyleConfig = {\n\t  baseStyle: {\n\t    padding: '1.5rem',\n\t    borderWidth: '3px',\n\t    borderRadius: '10px',\n", "    borderColor: 'black',\n\t    boxShadow: '-4px 4px 0px 0px #000',\n\t  },\n\t  sizes: {},\n\t  variants: {},\n\t  defaultProps: {},\n\t};\n\tconst ModalStyle: ComponentStyleConfig = {\n\t  baseStyle: {\n\t    dialog: {\n", "      color: 'white',\n\t      borderWidth: '3px',\n\t      borderRadius: '10px',\n\t      borderColor: 'black',\n\t      boxShadow: '-4px 4px 0px 0px #000',\n\t    },\n\t  },\n\t  sizes: {},\n\t  variants: {},\n\t  defaultProps: {},\n", "};\n\tconst theme = extendTheme({\n\t  fonts: {\n\t    heading: `'Cispeo'`,\n\t    body: `'Cispeo'`,\n\t  },\n\t  components: {\n\t    Alert: AlertStyle,\n\t    Button: ButtonStyle,\n\t    Input: InputStyle,\n", "    Card: CardStyle,\n\t    Modal: ModalStyle,\n\t  },\n\t});\n\texport default theme;\n"]}
{"filename": "src/vite-env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n\tinterface Error {\n\t  status?: number;\n\t  info?: string;\n\t}\n"]}
{"filename": "src/lib/files.ts", "chunked_list": ["export const saveFile = (\n\t  fileData: BlobPart[],\n\t  name: string,\n\t  type: string,\n\t  ref: React.RefObject<HTMLAnchorElement>,\n\t) => {\n\t  const file = new File(fileData, name, {\n\t    type,\n\t  });\n\t  const objectUrl = URL.createObjectURL(file);\n", "  if (ref.current) {\n\t    ref.current.href = objectUrl;\n\t    ref.current.download = name;\n\t    ref.current.click();\n\t  }\n\t};\n\texport const handleDataItem = async (items: DataTransferItem[]) => {\n\t  const files: File[] = [];\n\t  for (let i = 0; i < items.length; i++) {\n\t    const item = items[0].webkitGetAsEntry();\n", "    if (!item) {\n\t      continue;\n\t    }\n\t    switch (true) {\n\t      case item.isFile: {\n\t        const file = await getFile(item as FileSystemFileEntry);\n\t        files.push(file);\n\t        break;\n\t      }\n\t      case item.isDirectory: {\n", "        const tree: File[] = [];\n\t        await traverseFileTree(item as FileSystemDirectoryEntry, '', tree);\n\t        const archive = await createArchive(tree);\n\t        const archiveFile = new File([archive], item.name + '.zip', {\n\t          type: 'application/zip',\n\t        });\n\t        files.push(archiveFile);\n\t        break;\n\t      }\n\t      default:\n", "        break;\n\t    }\n\t  }\n\t  return files;\n\t};\n\tconst getFile = async (fileEntry: FileSystemFileEntry): Promise<File> => {\n\t  return new Promise((resolve, reject) => fileEntry.file(resolve, reject));\n\t};\n\tconst traverseFileTree = async (\n\t  item: FileSystemFileEntry | FileSystemDirectoryEntry | FileSystemEntry,\n", "  path: string,\n\t  acc: File[],\n\t) => {\n\t  path = path || '';\n\t  switch (true) {\n\t    case item.isFile: {\n\t      const file = await getFile(item as FileSystemFileEntry);\n\t      acc.push(new File([file], path + file.name, { type: file.type }));\n\t      return;\n\t    }\n", "    case item.isDirectory: {\n\t      const dirReader = (item as FileSystemDirectoryEntry).createReader();\n\t      const entries = await readEntries(dirReader);\n\t      for (const entry of entries) {\n\t        await traverseFileTree(entry, path + item.name + '/', acc);\n\t      }\n\t      return;\n\t    }\n\t    default:\n\t      return;\n", "  }\n\t};\n\tconst readEntries = (reader: FileSystemDirectoryReader): Promise<FileSystemEntry[]> => {\n\t  return new Promise((resolve, _) => {\n\t    reader.readEntries((entries) => {\n\t      resolve(entries);\n\t    });\n\t  });\n\t};\n\t/**\n", " * Investigate which format to use: .zip or .tar\n\t * Check for better/lighter library for archiving multiple File into a single one\n\t */\n\tconst createArchive = async (files: File[]) => {\n\t  const { BlobReader, BlobWriter, ZipWriter } = await import('@zip.js/zip.js');\n\t  const zipFileWriter = new BlobWriter();\n\t  const zipWriter = new ZipWriter(zipFileWriter);\n\t  for (const file of files) {\n\t    await zipWriter.add(file.name, new BlobReader(file));\n\t  }\n", "  await zipWriter.close();\n\t  const zipFileBlob = await zipFileWriter.getData();\n\t  return zipFileBlob;\n\t};\n"]}
{"filename": "src/lib/promisify.ts", "chunked_list": ["const promisify = <T, K>(worker: Worker, args: T): Promise<K> => {\n\t  return new Promise((resolve, reject) => {\n\t    try {\n\t      worker.onmessage = (result) => {\n\t        resolve(result.data);\n\t        worker.terminate();\n\t      };\n\t      worker.onerror = (error) => {\n\t        reject(error);\n\t        worker.terminate();\n", "      };\n\t      worker.postMessage(args);\n\t    } catch (error) {\n\t      reject(error);\n\t      worker.terminate();\n\t    }\n\t  });\n\t};\n\texport default promisify;\n"]}
{"filename": "src/lib/formatBytes.ts", "chunked_list": ["const formatBytes = (bytes: number, decimals = 2): string => {\n\t  if (!+bytes) return '0 Bytes';\n\t  const k = 1024;\n\t  const dm = decimals < 0 ? 0 : decimals;\n\t  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\t  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\t  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;\n\t};\n\texport default formatBytes;\n"]}
{"filename": "src/lib/storage.ts", "chunked_list": ["const ACCESS_TOKEN = 'ACCESS_TOKEN';\n\texport const getStorageAccessToken = (): string => {\n\t  return sessionStorage.getItem(ACCESS_TOKEN) || '';\n\t};\n\texport const setStorageAccessToken = (token: string) => {\n\t  sessionStorage.setItem(ACCESS_TOKEN, token);\n\t};\n\texport const delStorageAccessToken = () => {\n\t  sessionStorage.removeItem(ACCESS_TOKEN);\n\t};\n"]}
{"filename": "src/lib/authorizationUrl.ts", "chunked_list": ["const APP_SCOPES = [\n\t  'https://www.googleapis.com/auth/drive.file',\n\t  'https://www.googleapis.com/auth/drive.appdata',\n\t  'https://www.googleapis.com/auth/userinfo.email',\n\t];\n\texport const verifyScopes = (scopes: string[]): boolean => {\n\t  for (const scope of APP_SCOPES) {\n\t    if (!scopes.includes(scope)) return false;\n\t  }\n\t  return true;\n", "};\n\texport const getAuthorizationUrl = (): string => {\n\t  // Documentation:\n\t  // https://developers.google.com/identity/protocols/oauth2/javascript-implicit-flow#creatingclient\n\t  const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID;\n\t  const redirectUri = import.meta.env.VITE_REDIRECT_URI;\n\t  const url =\n\t    'https://accounts.google.com/o/oauth2/v2/auth?' +\n\t    'access_type=online&' +\n\t    'prompt=select_account&' +\n", "    'response_type=token&' +\n\t    'include_granted_scopes=true&' +\n\t    `client_id=${clientId}&` +\n\t    `scope=${APP_SCOPES.join(' ')}&` +\n\t    `redirect_uri=${redirectUri}&`;\n\t  return url;\n\t};\n"]}
{"filename": "src/lib/crypto.ts", "chunked_list": ["import { WrappedKey } from '@app/models';\n\t// Recommended nonce byte lenght for AES-GCM 256bytes\n\tconst NONCE_SIZE = 12;\n\t// Store a 1 byte VERSION flag in\n\t// for backward compatibility\n\tconst VERSION = 0x01;\n\tconst VERSION_SIZE = 1;\n\texport const decrypt = async (data: Blob, key: CryptoKey): Promise<Blob> => {\n\t  const buff = await data.arrayBuffer();\n\t  const version = buff.slice(0, VERSION_SIZE);\n", "  const iv = buff.slice(VERSION_SIZE, NONCE_SIZE + VERSION_SIZE);\n\t  const cipher = buff.slice(NONCE_SIZE + VERSION_SIZE);\n\t  if (VERSION !== new Uint8Array(version)[0]) {\n\t    throw new Error('File version not recognized');\n\t  }\n\t  const decrypted = await self.crypto.subtle.decrypt(\n\t    { name: 'AES-GCM', iv },\n\t    key,\n\t    cipher,\n\t  );\n", "  return new Blob([decrypted]);\n\t};\n\texport const encrypt = async (data: Blob, key: CryptoKey): Promise<Blob> => {\n\t  const iv = self.crypto.getRandomValues(new Uint8Array(NONCE_SIZE));\n\t  const plain = await data.arrayBuffer();\n\t  const encrypted = await self.crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, plain);\n\t  return new Blob([new Uint8Array([VERSION]).buffer, iv.buffer, encrypted]);\n\t};\n\texport const generateEncryptionKey = async () => {\n\t  const key = await self.crypto.subtle.generateKey(\n", "    {\n\t      name: 'AES-GCM',\n\t      length: 256,\n\t    },\n\t    true,\n\t    ['encrypt', 'decrypt'],\n\t  );\n\t  return key;\n\t};\n\tconst getKeyMaterial = async (passphrase: string): Promise<CryptoKey> => {\n", "  const enc = new TextEncoder();\n\t  return self.crypto.subtle.importKey(\n\t    'raw',\n\t    enc.encode(passphrase),\n\t    { name: 'PBKDF2' },\n\t    false,\n\t    ['deriveBits', 'deriveKey'],\n\t  );\n\t};\n\tconst getWrapKey = async (keyMaterial: CryptoKey, salt: Uint8Array) => {\n", "  return self.crypto.subtle.deriveKey(\n\t    {\n\t      name: 'PBKDF2',\n\t      salt,\n\t      iterations: 100000,\n\t      hash: 'SHA-256',\n\t    },\n\t    keyMaterial,\n\t    { name: 'AES-KW', length: 256 },\n\t    true,\n", "    ['wrapKey', 'unwrapKey'],\n\t  );\n\t};\n\texport const wrapEncryptionKey = async (\n\t  encryptionKey: CryptoKey,\n\t  passphrase: string,\n\t): Promise<WrappedKey> => {\n\t  const keyMaterial = await getKeyMaterial(passphrase);\n\t  const salt = self.crypto.getRandomValues(new Uint8Array(16));\n\t  const wrapKey = await getWrapKey(keyMaterial, salt);\n", "  const key = await self.crypto.subtle.wrapKey('raw', encryptionKey, wrapKey, 'AES-KW');\n\t  return {\n\t    enc: toB64(key),\n\t    salt: [...salt],\n\t  };\n\t};\n\texport const unwrapEncryptionKey = async (\n\t  wrappedKey: WrappedKey,\n\t  passphrase: string,\n\t): Promise<CryptoKey> => {\n", "  const salt = new Uint8Array(wrappedKey.salt);\n\t  const keyMaterial = await getKeyMaterial(passphrase);\n\t  const wrapKey = await getWrapKey(keyMaterial, salt);\n\t  return self.crypto.subtle.unwrapKey(\n\t    'raw',\n\t    fromB64(wrappedKey.enc),\n\t    wrapKey,\n\t    'AES-KW',\n\t    {\n\t      name: 'AES-GCM',\n", "      length: 256,\n\t    },\n\t    true,\n\t    ['encrypt', 'decrypt'],\n\t  );\n\t};\n\texport const exportEncryptionKey = async (encryptionKey: CryptoKey): Promise<string> => {\n\t  return toB64(await self.crypto.subtle.exportKey('raw', encryptionKey));\n\t};\n\texport const importEncryptionKey = async (encryptionKey: string): Promise<CryptoKey> => {\n", "  return self.crypto.subtle.importKey(\n\t    'raw',\n\t    fromB64(encryptionKey),\n\t    {\n\t      name: 'AES-GCM',\n\t      length: 256,\n\t    },\n\t    true,\n\t    ['encrypt', 'decrypt'],\n\t  );\n", "};\n\texport const sha256 = async (str: string): Promise<string> => {\n\t  const digest = await self.crypto.subtle.digest('SHA-512', fromB64(str));\n\t  return toB64(digest);\n\t};\n\tconst toB64 = (buf: ArrayBuffer): string => {\n\t  return self.btoa(\n\t    new Uint8Array(buf).reduce((data, byte) => data + String.fromCharCode(byte), ''),\n\t  );\n\t};\n", "const fromB64 = (buf: string): ArrayBuffer => {\n\t  return new Uint8Array(\n\t    [...self.atob(buf)].reduce(\n\t      (data, char) => data.concat([char.charCodeAt(0)]),\n\t      [] as number[],\n\t    ),\n\t  ).buffer;\n\t};\n"]}
{"filename": "src/lib/webworkers/encrypt.worker.ts", "chunked_list": ["import { encrypt, importEncryptionKey } from '@app/lib/crypto';\n\tself.onmessage = async function (e) {\n\t  try {\n\t    const { file, key }: { file: File; key: string } = e.data;\n\t    const importKey = await importEncryptionKey(key);\n\t    const encrypted = await encrypt(file, importKey);\n\t    self.postMessage(encrypted);\n\t  } catch (err) {\n\t    self.reportError(err);\n\t  }\n", "};\n"]}
{"filename": "src/lib/webworkers/decrypt.worker.ts", "chunked_list": ["import { decrypt, importEncryptionKey } from '@app/lib/crypto';\n\tself.onmessage = async function (e) {\n\t  try {\n\t    const { data, key }: { data: Blob; key: string } = e.data;\n\t    const importKey = await importEncryptionKey(key);\n\t    const decrypted = await decrypt(data, importKey);\n\t    self.postMessage(decrypted);\n\t  } catch (err) {\n\t    self.reportError(err);\n\t  }\n", "};\n"]}
{"filename": "src/models/index.ts", "chunked_list": ["export interface UserInfo {\n\t  email: string;\n\t}\n\texport interface StorageQuota {\n\t  limit: number;\n\t  usage: number;\n\t  usageInDrive: number;\n\t}\n\texport interface FileMetadata {\n\t  id: string;\n", "  name: string;\n\t  size: number;\n\t  createdTime: Date;\n\t  mimeType: string;\n\t}\n\texport interface WrappedKey {\n\t  enc: string;\n\t  salt: number[];\n\t}\n\texport interface AppData {\n", "  encryptionKey: WrappedKey;\n\t}\n"]}
{"filename": "src/hooks/http.ts", "chunked_list": ["import { AppData, FileMetadata, StorageQuota, UserInfo } from '../models';\n\tconst JSONtoUserInfo = (json: any): UserInfo => {\n\t  const userInfo: UserInfo = {\n\t    email: json['emailAddress'],\n\t  };\n\t  return userInfo;\n\t};\n\tconst JSONtoFileMetadata = (json: any): FileMetadata => {\n\t  const fileMetadata: FileMetadata = {\n\t    id: json['id'],\n", "    name: json['name'],\n\t    size: parseInt(json['size'] || 0),\n\t    createdTime: new Date(json['createdTime']),\n\t    mimeType: json['mimeType'],\n\t  };\n\t  return fileMetadata;\n\t};\n\tconst JSONtoFilesMetadata = (json: any): FileMetadata[] => {\n\t  return json\n\t    .map((file: any): FileMetadata | undefined => {\n", "      if (file['trashed'] === true) {\n\t        return;\n\t      }\n\t      return JSONtoFileMetadata(file);\n\t    })\n\t    .filter((e: any) => e != null)\n\t    .sort((a: FileMetadata, b: FileMetadata) =>\n\t      a.createdTime && b.createdTime ? a.createdTime > b.createdTime : 0,\n\t    );\n\t};\n", "const JSONtoAppData = (json: any): AppData => {\n\t  const appData: AppData = {\n\t    encryptionKey: {\n\t      enc: json['encryptionKey']['enc'],\n\t      salt: json['encryptionKey']['salt'],\n\t    },\n\t  };\n\t  return appData;\n\t};\n\tconst JSONtoStorageQuota = (json: any): StorageQuota => {\n", "  const storageQuota: StorageQuota = {\n\t    limit: parseInt(json['limit']),\n\t    usage: parseInt(json['usage']),\n\t    usageInDrive: parseInt(json['usageInDrive']),\n\t  };\n\t  return storageQuota;\n\t};\n\texport const getUserInfo = async (token: string): Promise<UserInfo> => {\n\t  const res = await fetch('https://www.googleapis.com/drive/v3/about?fields=user', {\n\t    method: 'GET',\n", "    headers: { Authorization: `Bearer ${token}` },\n\t  });\n\t  const json = await res.json();\n\t  if (!res.ok) {\n\t    const error = new Error('Failed fetching user.');\n\t    error.info = json;\n\t    error.status = res.status;\n\t    throw error;\n\t  }\n\t  return JSONtoUserInfo(json['user']);\n", "};\n\texport const revokeToken = async (token: string): Promise<void> => {\n\t  fetch(`https://oauth2.googleapis.com/revoke?token=${token}type=accesstoken`, {\n\t    method: 'POST',\n\t    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n\t  });\n\t};\n\texport const revokeApp = async (token: string): Promise<void> => {\n\t  fetch(`https://oauth2.googleapis.com/revoke`, {\n\t    method: 'POST',\n", "    headers: { Authorization: `Bearer ${token}` },\n\t  });\n\t};\n\tconst CONFIG_FILE_NAME = 'config.json';\n\tconst APP_DATA_FOLDER = 'appDataFolder';\n\tconst createConfigFile = async (token: string): Promise<string> => {\n\t  const res = await fetch('https://www.googleapis.com/drive/v3/files?fields=id', {\n\t    method: 'POST',\n\t    body: JSON.stringify({\n\t      mimeType: 'application/json',\n", "      parents: [APP_DATA_FOLDER],\n\t      name: CONFIG_FILE_NAME,\n\t    }),\n\t    headers: {\n\t      Authorization: `Bearer ${token}`,\n\t      'Content-Type': 'application/json',\n\t    },\n\t  });\n\t  const json = await res.json();\n\t  return json['id'];\n", "};\n\tconst uploadConfigFile = async (\n\t  token: string,\n\t  configFileId: string,\n\t  data: AppData,\n\t): Promise<void> => {\n\t  const bytes = new TextEncoder().encode(JSON.stringify(data));\n\t  const file = new File([bytes], 'config.json', { type: 'application/json' });\n\t  await fetch(\n\t    `https://www.googleapis.com/upload/drive/v3/files/${configFileId}?uploadType=media`,\n", "    {\n\t      method: 'PATCH',\n\t      body: file,\n\t      headers: { Authorization: `Bearer ${token}` },\n\t    },\n\t  );\n\t};\n\texport const saveAppData = async (token: string, data: AppData): Promise<void> => {\n\t  const configFileId = await createConfigFile(token);\n\t  await uploadConfigFile(token, configFileId, data);\n", "};\n\tconst getAppFiles = async (token: string) => {\n\t  const res = await fetch(\n\t    'https://www.googleapis.com/drive/v3/files?spaces=appDataFolder&fields=files(*)',\n\t    {\n\t      method: 'GET',\n\t      headers: { Authorization: `Bearer ${token}` },\n\t    },\n\t  );\n\t  const json = await res.json();\n", "  return JSONtoFilesMetadata(json['files']);\n\t};\n\tconst loadConfigFile = async (token: string, configFileId: string): Promise<AppData> => {\n\t  const res = await fetch(\n\t    `https://www.googleapis.com/drive/v3/files/${configFileId}?spaces=appDataFolder&alt=media`,\n\t    {\n\t      method: 'GET',\n\t      headers: { Authorization: `Bearer ${token}` },\n\t    },\n\t  );\n", "  const json = await res.json();\n\t  return JSONtoAppData(json);\n\t};\n\texport const loadAppData = async (token: string): Promise<AppData | undefined> => {\n\t  const files = await getAppFiles(token);\n\t  const configFile = files.find((f) => f.name == CONFIG_FILE_NAME);\n\t  if (!configFile) {\n\t    // throw new Error(`Config file <${CONFIG_FILE_NAME}> not found`);\n\t    return;\n\t  }\n", "  return await loadConfigFile(token, configFile.id);\n\t};\n\t// only for debug\n\texport const deleteAppFolder = async (token: string): Promise<void> => {\n\t  const files = await getAppFiles(token);\n\t  const promises = files.map(({ id: fileId }) => {\n\t    return fetch(`https://www.googleapis.com/drive/v3/files/${fileId}`, {\n\t      method: 'DELETE',\n\t      headers: { Authorization: `Bearer ${token}` },\n\t    });\n", "  });\n\t  await Promise.all(promises);\n\t};\n\texport const getStorageQuota = async (token: string): Promise<StorageQuota> => {\n\t  const res = await fetch(\n\t    'https://www.googleapis.com/drive/v3/about?fields=storageQuota',\n\t    {\n\t      method: 'GET',\n\t      headers: { Authorization: `Bearer ${token}` },\n\t    },\n", "  );\n\t  const json = await res.json();\n\t  return JSONtoStorageQuota(json['storageQuota']);\n\t};\n\texport const getUserFiles = async (token: string): Promise<FileMetadata[]> => {\n\t  const res = await fetch('https://www.googleapis.com/drive/v3/files?fields=*', {\n\t    method: 'GET',\n\t    headers: { Authorization: `Bearer ${token}` },\n\t  });\n\t  const json = await res.json();\n", "  return JSONtoFilesMetadata(json['files']);\n\t};\n\tconst uploadFileMetadata = async (token: string, name: string): Promise<string> => {\n\t  // https://developers.google.com/drive/api/guides/manage-uploads#http_2\n\t  const res = await fetch(\n\t    'https://www.googleapis.com/upload/drive/v3/files?uploadType=resumable',\n\t    {\n\t      method: 'POST',\n\t      body: JSON.stringify({\n\t        name: name,\n", "        originalFilename: name,\n\t        mimeType: 'application/octet-stream', // \"text/plain\"\n\t        description: 'From encryptly',\n\t      }),\n\t      headers: {\n\t        Authorization: `Bearer ${token}`,\n\t        'Content-Type': 'application/json; charset=UTF-8',\n\t        'X-Upload-Content-Type': 'application/octet-stream',\n\t      },\n\t    },\n", "  );\n\t  const location = res.headers.get('location');\n\t  if (!res.ok || !location) {\n\t    const error = new Error('Failed upload session resume.');\n\t    error.info = await res.json();\n\t    error.status = res.status;\n\t    throw error;\n\t  }\n\t  return location;\n\t};\n", "interface Chunk {\n\t  data: Blob;\n\t  ratio: number;\n\t  contentLength: string;\n\t  contentRange: string;\n\t}\n\tconst generateChunks = (data: Blob): Chunk[] => {\n\t  /**\n\t   *  Create chunks in multiples of 256 KB (256 x 1024 bytes) in size,\n\t   *  except for the final chunk that completes the upload.\n", "   *  Keep the chunk size as large as possible so that the upload is efficient.\n\t   *\n\t   *  Add headers:\n\t   *  - Content-Length. Set to the number of bytes in the current chunk.\n\t   *  - Content-Range. Set to show which bytes in the file you upload.\n\t   *  For example, Content-Range: bytes 0-524287/2000000 shows that you\n\t   *  upload the first 524,288 bytes (256 x 1024 x 2) in a 2,000,000 byte file.\n\t   */\n\t  const chunkSize = 256 * 1024 * 16;\n\t  const dataSize = data.size;\n", "  const chunks: Chunk[] = [];\n\t  let chunkCount = 0;\n\t  for (; (chunkCount + 1) * chunkSize < dataSize; chunkCount += 1) {\n\t    const start = chunkSize * chunkCount;\n\t    const end = chunkSize * (chunkCount + 1);\n\t    const chunk: Chunk = {\n\t      data: data.slice(start, end),\n\t      ratio: (end / dataSize) * 100,\n\t      contentLength: (end - start).toString(),\n\t      contentRange: `bytes ${start}-${end - 1}/${dataSize}`,\n", "    };\n\t    chunks.push(chunk);\n\t  }\n\t  const start = chunkSize * chunkCount;\n\t  const end = dataSize;\n\t  const lastChunk: Chunk = {\n\t    data: data.slice(start, end),\n\t    ratio: 100,\n\t    contentLength: (end - start).toString(),\n\t    contentRange: `bytes ${start}-${end - 1}/${dataSize}`,\n", "  };\n\t  chunks.push(lastChunk);\n\t  return chunks;\n\t};\n\tasync function* uploadFileMedia(\n\t  token: string,\n\t  file: Blob,\n\t  session: string,\n\t): AsyncGenerator<number, string, void> {\n\t  // https://developers.google.com/drive/api/guides/manage-uploads#http---multiple-requests\n", "  const chunks = generateChunks(file);\n\t  for (const { data, ratio, contentLength, contentRange } of chunks) {\n\t    await fetch(session, {\n\t      method: 'PUT',\n\t      body: data,\n\t      headers: {\n\t        Authorization: `Bearer ${token}`,\n\t        'Content-Length': contentLength,\n\t        'Content-Range': contentRange,\n\t      },\n", "    });\n\t    yield ratio;\n\t  }\n\t  return 'ok';\n\t}\n\texport const uploadFile = async (\n\t  token: string,\n\t  name: string,\n\t  data: Blob,\n\t): Promise<AsyncGenerator<number, string, void>> => {\n", "  const uploadSession = await uploadFileMetadata(token, name);\n\t  return uploadFileMedia(token, data, uploadSession);\n\t};\n\tconst downloadFileMedia = async (token: string, fileId: string): Promise<Blob> => {\n\t  const res = await fetch(\n\t    `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,\n\t    {\n\t      method: 'GET',\n\t      headers: { Authorization: `Bearer ${token}` },\n\t    },\n", "  );\n\t  const data = await res.blob();\n\t  return data;\n\t};\n\tconst downloadFileMetadata = async (\n\t  token: string,\n\t  fileId: string,\n\t): Promise<FileMetadata> => {\n\t  const res = await fetch(\n\t    `https://www.googleapis.com/drive/v3/files/${fileId}?fields=*`,\n", "    {\n\t      method: 'GET',\n\t      headers: { Authorization: `Bearer ${token}` },\n\t    },\n\t  );\n\t  const json = await res.json();\n\t  const metadata = JSONtoFileMetadata(json);\n\t  return metadata;\n\t};\n\texport const downloadFile = async (\n", "  token: string,\n\t  fileId: string,\n\t): Promise<{\n\t  metadata: FileMetadata;\n\t  data: Blob;\n\t}> => {\n\t  const data = await downloadFileMedia(token, fileId);\n\t  const metadata = await downloadFileMetadata(token, fileId);\n\t  return { metadata, data };\n\t};\n", "export const deleteFile = async (token: string, fileId: string): Promise<void> => {\n\t  await fetch(`https://www.googleapis.com/drive/v2/files/${fileId}`, {\n\t    method: 'DELETE',\n\t    headers: { Authorization: `Bearer ${token}` },\n\t  });\n\t};\n"]}
{"filename": "src/hooks/index.ts", "chunked_list": ["import { useCallback, useContext } from 'react';\n\timport { AppContext } from '@app/context';\n\timport { generateEncryptionKey, wrapEncryptionKey } from '@app/lib/crypto';\n\timport promisify from '@app/lib/promisify';\n\timport {\n\t  delStorageAccessToken,\n\t  getStorageAccessToken,\n\t  setStorageAccessToken,\n\t} from '@app/lib/storage';\n\timport DecryptWorker from '@app/lib/webworkers/decrypt.worker?worker';\n", "import EncryptWorker from '@app/lib/webworkers/encrypt.worker?worker';\n\timport useSWR, { mutate } from 'swr';\n\timport {\n\t  deleteAppFolder,\n\t  deleteFile,\n\t  downloadFile,\n\t  getStorageQuota,\n\t  getUserFiles,\n\t  getUserInfo,\n\t  loadAppData,\n", "  revokeToken,\n\t  saveAppData,\n\t  uploadFile,\n\t} from './http';\n\texport const useIsAuthenticated = () => {\n\t  const { accessToken, encryptionKey } = useContext(AppContext);\n\t  const hasAccessToken = accessToken.value != '' && accessToken.value != null;\n\t  const hasEncryptionKey = encryptionKey.value != '' && encryptionKey.value != null;\n\t  return hasAccessToken && hasEncryptionKey;\n\t};\n", "export const useRecoverAccessToken = () => {\n\t  const { accessToken } = useContext(AppContext);\n\t  return async () => {\n\t    const token = getStorageAccessToken();\n\t    if (token) {\n\t      try {\n\t        await getUserInfo(token);\n\t        accessToken.setValue(token);\n\t        setStorageAccessToken(token);\n\t        return true;\n", "      } catch (err) {\n\t        accessToken.setValue('');\n\t        delStorageAccessToken();\n\t      }\n\t    }\n\t    return false;\n\t  };\n\t};\n\texport const useUserInfo = () => {\n\t  const { accessToken } = useContext(AppContext);\n", "  return useSWR('UserInfo', () => getUserInfo(accessToken.value));\n\t};\n\texport const useLogout = () => {\n\t  const { accessToken, encryptionKey } = useContext(AppContext);\n\t  return async () => {\n\t    sessionStorage.clear();\n\t    encryptionKey.setValue('');\n\t    await revokeToken(accessToken.value);\n\t    accessToken.setValue('');\n\t    // Clear all previous, to force refetch new data with new token/user\n", "    await mutate(() => true, undefined, {\n\t      revalidate: true,\n\t      populateCache: true,\n\t    });\n\t  };\n\t};\n\texport const useDriveQuota = () => {\n\t  const { accessToken } = useContext(AppContext);\n\t  return useSWR('driveQuota', () => getStorageQuota(accessToken.value));\n\t};\n", "export const useListFiles = () => {\n\t  const { accessToken } = useContext(AppContext);\n\t  return useSWR('listFiles', () => getUserFiles(accessToken.value), {\n\t    revalidateOnFocus: false,\n\t    revalidateIfStale: false,\n\t  });\n\t};\n\texport const revalidateListFiles = async () => {\n\t  const keys = ['listFiles', 'driveQuota'];\n\t  await mutate((key: string) => keys.includes(key), undefined, {\n", "    revalidate: true,\n\t    populateCache: false,\n\t  });\n\t};\n\texport const useEncryptFile = () => {\n\t  const { encryptionKey } = useContext(AppContext);\n\t  return useCallback(\n\t    (file: File): Promise<Blob> => {\n\t      const worker = new EncryptWorker();\n\t      return promisify(worker, { file, key: encryptionKey.value });\n", "    },\n\t    [encryptionKey.value],\n\t  );\n\t};\n\texport const useDecryptFile = () => {\n\t  const { encryptionKey } = useContext(AppContext);\n\t  return useCallback(\n\t    async (data: Blob): Promise<Blob> => {\n\t      const worker = new DecryptWorker();\n\t      return promisify(worker, { data, key: encryptionKey.value });\n", "    },\n\t    [encryptionKey.value],\n\t  );\n\t};\n\texport const useUploadFile = () => {\n\t  const { accessToken } = useContext(AppContext);\n\t  return async (file: { data: Blob; name: string }) => {\n\t    const generator = await uploadFile(accessToken.value, file.name, file.data);\n\t    return generator;\n\t  };\n", "};\n\texport const useDownloadFile = () => {\n\t  const { accessToken } = useContext(AppContext);\n\t  return async (fileId: string) => {\n\t    const { metadata, data } = await downloadFile(accessToken.value, fileId);\n\t    return { data, metadata };\n\t  };\n\t};\n\texport const useDeleteFile = () => {\n\t  const { accessToken } = useContext(AppContext);\n", "  return async (fileId: string) => {\n\t    await deleteFile(accessToken.value, fileId);\n\t    await revalidateListFiles();\n\t  };\n\t};\n\texport const useAppData = () => {\n\t  const { accessToken } = useContext(AppContext);\n\t  return useSWR('appData', () => loadAppData(accessToken.value), {\n\t    revalidateOnFocus: false,\n\t    revalidateIfStale: false,\n", "    revalidateOnReconnect: false,\n\t  });\n\t};\n\texport const useSaveAppData = () => {\n\t  const { accessToken } = useContext(AppContext);\n\t  return async (passphrase: string) => {\n\t    const encryptionKey = await generateEncryptionKey();\n\t    const wrappedKey = await wrapEncryptionKey(encryptionKey, passphrase);\n\t    await saveAppData(accessToken.value, { encryptionKey: wrappedKey });\n\t    await mutate((key: string) => key == 'appData', undefined, {\n", "      revalidate: true,\n\t      populateCache: false,\n\t    });\n\t  };\n\t};\n\t// only for debug\n\texport const useDeleteAppDataFolder = () => {\n\t  const { accessToken } = useContext(AppContext);\n\t  return () => deleteAppFolder(accessToken.value);\n\t};\n"]}
