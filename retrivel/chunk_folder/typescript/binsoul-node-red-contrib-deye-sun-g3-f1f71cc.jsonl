{"filename": "src/deye-sun-g3/NodeOutput.d.ts", "chunked_list": ["interface PV {\n\t    voltage: number;\n\t    current: number;\n\t    power: number;\n\t}\n\tinterface Output {\n\t    power: number;\n\t    voltage: number;\n\t    current: number;\n\t    frequency: number;\n", "}\n\tinterface Counters {\n\t    totalEnergy: number;\n\t    totalEnergyToday: number;\n\t    pv1TotalEnergy: number;\n\t    pv1TotalEnergyToday: number;\n\t    pv2TotalEnergy: number;\n\t    pv2TotalEnergyToday: number;\n\t    pv3TotalEnergy: number;\n\t    pv3TotalEnergyToday: number;\n", "    pv4TotalEnergy: number;\n\t    pv4TotalEnergyToday: number;\n\t}\n\texport interface NodeOutput {\n\t    pv1: PV;\n\t    pv2: PV;\n\t    pv3: PV;\n\t    pv4: PV;\n\t    output: Output;\n\t    counters: Counters;\n", "    temperature: number | null;\n\t    isAvailable: boolean;\n\t}\n"]}
{"filename": "src/deye-sun-g3/ActionFactory.ts", "chunked_list": ["import { Action, ActionFactory as ActionFactoryInterface, Message } from '@binsoul/node-red-bundle-processing';\n\timport type { Node, NodeAPI } from '@node-red/registry';\n\timport { NodeMessageInFlow, NodeStatus } from 'node-red';\n\timport { clearTimeout, setTimeout } from 'timers';\n\timport { DailyResetAction } from './Action/DailyResetAction';\n\timport { OutputAction } from './Action/OutputAction';\n\timport { UnavailableAction } from './Action/UnavailableAction';\n\timport { UpdateAction } from './Action/UpdateAction';\n\timport type { Configuration } from './Configuration';\n\timport { Storage } from './Storage';\n", "interface MessageData extends NodeMessageInFlow {\n\t    command?: string;\n\t    timestamp?: number;\n\t}\n\tfunction formatTime(timestamp: number) {\n\t    const date = new Date(timestamp);\n\t    return date.getHours().toString().padStart(2, '0') + ':' + date.getMinutes().toString().padStart(2, '0');\n\t}\n\t/**\n\t * Generates actions.\n", " */\n\texport class ActionFactory implements ActionFactoryInterface {\n\t    private readonly configuration: Configuration;\n\t    private readonly RED: NodeAPI;\n\t    private readonly node: Node;\n\t    private readonly storage: Storage;\n\t    private firstMessage = true;\n\t    private updateTimer: NodeJS.Timeout | null = null;\n\t    private dailyResetTimer: NodeJS.Timeout | null = null;\n\t    private unavailableTimer: NodeJS.Timeout | null = null;\n", "    constructor(RED: NodeAPI, node: Node, configuration: Configuration) {\n\t        this.RED = RED;\n\t        this.node = node;\n\t        this.configuration = configuration;\n\t        this.storage = new Storage(configuration);\n\t    }\n\t    build(message: Message): Action | Array<Action> | null {\n\t        const data: MessageData = message.data;\n\t        const command = data.command;\n\t        if (this.firstMessage) {\n", "            this.firstMessage = false;\n\t            this.scheduleUnavailableCheck();\n\t        }\n\t        if (typeof command !== 'undefined' && ('' + command).trim() !== '') {\n\t            switch (command.toLowerCase()) {\n\t                case 'update':\n\t                    this.storage.setUpdating(true);\n\t                    return new UpdateAction(\n\t                        this.configuration,\n\t                        this.storage,\n", "                        () => this.outputCallback(),\n\t                        (status: NodeStatus) => this.nodeStatusCallback(status),\n\t                    );\n\t                case 'output':\n\t                    this.storage.setUpdating(false);\n\t                    this.scheduleUnavailableCheck();\n\t                    return new OutputAction(this.configuration, this.storage);\n\t                case 'dailyreset':\n\t                    return new DailyResetAction(this.configuration, this.storage);\n\t                case 'unavailable':\n", "                    return new UnavailableAction(this.configuration, this.storage);\n\t            }\n\t        }\n\t        if (!this.storage.isUpdating()) {\n\t            if (this.updateTimer !== null) {\n\t                clearTimeout(this.updateTimer);\n\t                this.updateTimer = null;\n\t            }\n\t            this.scheduleUpdate();\n\t            this.storage.setUpdating(true);\n", "            return new UpdateAction(\n\t                this.configuration,\n\t                this.storage,\n\t                () => this.outputCallback(),\n\t                (status: NodeStatus) => this.nodeStatusCallback(status),\n\t            );\n\t        }\n\t        return null;\n\t    }\n\t    setup(): void {\n", "        if (this.configuration.updateMode === 'never') {\n\t            this.node.status({\n\t                fill: 'yellow',\n\t                shape: 'dot',\n\t                text: 'waiting for message',\n\t            });\n\t            return;\n\t        }\n\t        const now = Date.now();\n\t        const firstUpdateAt = Math.ceil(now / (this.configuration.updateFrequency * 60000)) * this.configuration.updateFrequency * 60000;\n", "        this.updateTimer = setTimeout(() => this.executeUpdate(), firstUpdateAt - now + 1000);\n\t        const tomorrow = new Date();\n\t        tomorrow.setDate(tomorrow.getDate() + 1);\n\t        tomorrow.setHours(0, 0, 0);\n\t        this.dailyResetTimer = setTimeout(() => this.executeDailyReset(), tomorrow.getTime() - now);\n\t        this.node.status({\n\t            fill: 'yellow',\n\t            shape: 'dot',\n\t            text: `waiting until ${formatTime(firstUpdateAt)}`,\n\t        });\n", "    }\n\t    teardown(): void {\n\t        if (this.updateTimer !== null) {\n\t            clearTimeout(this.updateTimer);\n\t            this.updateTimer = null;\n\t        }\n\t        if (this.dailyResetTimer !== null) {\n\t            clearTimeout(this.dailyResetTimer);\n\t            this.dailyResetTimer = null;\n\t        }\n", "        if (this.unavailableTimer !== null) {\n\t            clearTimeout(this.unavailableTimer);\n\t            this.unavailableTimer = null;\n\t        }\n\t    }\n\t    /**\n\t     * Starts a timer if automatic updates are enabled and no timer exists.\n\t     */\n\t    private scheduleUpdate(): void {\n\t        if (this.updateTimer !== null || this.configuration.updateMode === 'never') {\n", "            return;\n\t        }\n\t        const now = Date.now();\n\t        this.updateTimer = setTimeout(() => this.executeUpdate(), this.getStartOfSlot(now) - now + this.configuration.updateFrequency * 60000 + 1000);\n\t    }\n\t    /**\n\t     * Handles automatic updates.\n\t     */\n\t    executeUpdate(): void {\n\t        const now = new Date().getTime();\n", "        const nextUpdateAt = this.getStartOfSlot(now) + this.configuration.updateFrequency * 60000 + 1000;\n\t        this.updateTimer = setTimeout(() => this.executeUpdate(), nextUpdateAt - now);\n\t        // trigger node.on('input', () => {})\n\t        this.node.receive(<MessageData>{\n\t            command: 'update',\n\t            timestamp: now,\n\t        });\n\t    }\n\t    /**\n\t     * Handles daily resets of counters.\n", "     */\n\t    executeDailyReset(): void {\n\t        const now = Date.now();\n\t        const tomorrow = new Date();\n\t        tomorrow.setDate(tomorrow.getDate() + 1);\n\t        tomorrow.setHours(0, 0, 0);\n\t        this.dailyResetTimer = setTimeout(() => this.executeDailyReset(), tomorrow.getTime() - now);\n\t        // trigger node.on('input', () => {})\n\t        this.node.receive(<MessageData>{\n\t            command: 'dailyReset',\n", "            timestamp: now,\n\t        });\n\t    }\n\t    /**\n\t     * Starts a timer which changes the device status to unavailable.\n\t     */\n\t    private scheduleUnavailableCheck(): void {\n\t        if (this.unavailableTimer !== null) {\n\t            clearTimeout(this.unavailableTimer);\n\t            this.unavailableTimer = null;\n", "        }\n\t        const now = Date.now();\n\t        this.unavailableTimer = setTimeout(() => this.executeUnavailableCheck(), this.getStartOfSlot(now) - now + this.configuration.deviceTimeout * 60000);\n\t    }\n\t    private executeUnavailableCheck(): void {\n\t        this.unavailableTimer = null;\n\t        this.node.receive(<MessageData>{\n\t            command: 'unavailable',\n\t        });\n\t    }\n", "    outputCallback(): void {\n\t        this.node.receive(<MessageData>{\n\t            command: 'output',\n\t        });\n\t    }\n\t    nodeStatusCallback(status: NodeStatus): void {\n\t        this.node.status(status);\n\t    }\n\t    private getStartOfSlot(timestamp: number) {\n\t        return Math.floor(timestamp / 60000) * 60000;\n", "    }\n\t}\n"]}
{"filename": "src/deye-sun-g3/ConfigurationBuilder.ts", "chunked_list": ["import { Configuration } from './Configuration';\n\timport type { UserConfiguration } from './UserConfiguration';\n\tconst getString = function (value: unknown, defaultValue: string): string {\n\t    const result = value || defaultValue;\n\t    const stringValue = '' + result;\n\t    if (stringValue.trim() === '') {\n\t        return defaultValue;\n\t    }\n\t    return stringValue;\n\t};\n", "/**\n\t * Creates a sanitized configuration from user input.\n\t */\n\texport function buildConfiguration(config: UserConfiguration): Configuration {\n\t    const outputTarget = getString(config.outputTarget, 'msg');\n\t    const outputProperty = getString(config.outputProperty, 'payload');\n\t    const deviceIp = getString(config.deviceIp, '');\n\t    const deviceSerialNumber = getString(config.deviceSerialNumber, '');\n\t    const deviceTimeout = Number(config.deviceTimeout || 30);\n\t    const updateMode = getString(config.updateMode, 'never');\n", "    const updateFrequency = Number(config.updateFrequency || 5);\n\t    return new Configuration(outputTarget, outputProperty, deviceIp, deviceSerialNumber, deviceTimeout, updateMode, updateFrequency);\n\t}\n"]}
{"filename": "src/deye-sun-g3/Node.ts", "chunked_list": ["import { MessageHandler } from '@binsoul/node-red-bundle-processing';\n\timport type { Node, NodeInitializer } from 'node-red';\n\timport { ActionFactory } from './ActionFactory';\n\timport { buildConfiguration } from './ConfigurationBuilder';\n\timport type { UserConfiguration } from './UserConfiguration';\n\tconst nodeInitializer: NodeInitializer = (RED): void => {\n\t    function NodeConstructor(this: Node, userConfiguration: UserConfiguration): void {\n\t        RED.nodes.createNode(this, userConfiguration);\n\t        const configuration = buildConfiguration(userConfiguration);\n\t        const actionFactory = new ActionFactory(RED, this, configuration);\n", "        const messageHandler = new MessageHandler(RED, this, actionFactory);\n\t        actionFactory.setup();\n\t        this.on('input', (msg, send, done) => messageHandler.handle(msg, send, done));\n\t        this.on('close', () => actionFactory.teardown());\n\t    }\n\t    RED.nodes.registerType('binsoul-deye-sun-g3', NodeConstructor);\n\t};\n\texport = nodeInitializer;\n"]}
{"filename": "src/deye-sun-g3/UserConfiguration.d.ts", "chunked_list": ["import type { NodeDef } from 'node-red';\n\t/**\n\t * Configuration options available to users.\n\t */\n\texport interface UserConfigurationOptions {\n\t    outputTarget?: string;\n\t    outputProperty?: string;\n\t    deviceIp?: string;\n\t    deviceSerialNumber?: string;\n\t    deviceTimeout?: number;\n", "    updateMode?: string;\n\t    updateFrequency?: number;\n\t}\n\t/**\n\t * Configuration generated by the user in the editor.\n\t */\n\texport interface UserConfiguration extends NodeDef, UserConfigurationOptions {}\n"]}
{"filename": "src/deye-sun-g3/Configuration.ts", "chunked_list": ["/**\n\t * Sanitized configuration generated from user input.\n\t */\n\texport class Configuration {\n\t    outputProperty: string;\n\t    outputTarget: string;\n\t    deviceIp: string;\n\t    deviceSerialNumber: string;\n\t    deviceTimeout: number;\n\t    updateMode: string;\n", "    updateFrequency: number;\n\t    constructor(outputTarget = 'msg', outputProperty = 'payload', deviceIp: string, deviceSerialNumber: string, deviceTimeout = 30, updateMode = 'never', updateFrequency = 5) {\n\t        this.outputTarget = outputTarget;\n\t        this.outputProperty = outputProperty;\n\t        this.deviceIp = deviceIp;\n\t        this.deviceSerialNumber = deviceSerialNumber;\n\t        this.deviceTimeout = deviceTimeout;\n\t        this.updateMode = updateMode;\n\t        this.updateFrequency = updateFrequency;\n\t    }\n", "}\n"]}
{"filename": "src/deye-sun-g3/Storage.ts", "chunked_list": ["import { Configuration } from './Configuration';\n\timport { RegisterValues } from './DeyeRegisters';\n\timport { NodeOutput } from './NodeOutput';\n\t/**\n\t * Stores events and a history of past events.\n\t */\n\texport class Storage {\n\t    private configuration: Configuration;\n\t    private updating = false;\n\t    private connected = false;\n", "    private lastConnectionAt: number | null = null;\n\t    private lastDataAt: number | null = null;\n\t    private available = true;\n\t    private data: RegisterValues | null = null;\n\t    constructor(configuration: Configuration) {\n\t        this.configuration = configuration;\n\t    }\n\t    public isUpdating(): boolean {\n\t        return this.updating;\n\t    }\n", "    public setUpdating(value: boolean) {\n\t        this.updating = value;\n\t        if (value) {\n\t            this.connected = false;\n\t        }\n\t    }\n\t    public setConnected() {\n\t        this.connected = true;\n\t        this.lastConnectionAt = Date.now();\n\t        this.available = true;\n", "    }\n\t    public getData(): NodeOutput | null {\n\t        if (this.data === null || !this.available) {\n\t            return null;\n\t        }\n\t        const pv1 = {\n\t            voltage: this.data.pv1Voltage,\n\t            current: this.data.pv1Current,\n\t            power: this.round(this.data.pv1Voltage * this.data.pv1Current, '4'),\n\t        };\n", "        const pv2 = {\n\t            voltage: this.data.pv2Voltage,\n\t            current: this.data.pv2Current,\n\t            power: this.round(this.data.pv2Voltage * this.data.pv2Current, '4'),\n\t        };\n\t        const pv3 = {\n\t            voltage: this.data.pv3Voltage,\n\t            current: this.data.pv3Current,\n\t            power: this.round(this.data.pv3Voltage * this.data.pv3Current, '4'),\n\t        };\n", "        const pv4 = {\n\t            voltage: this.data.pv4Voltage,\n\t            current: this.data.pv4Current,\n\t            power: this.round(this.data.pv4Voltage * this.data.pv4Current, '4'),\n\t        };\n\t        const output = {\n\t            power: this.data.acPower,\n\t            voltage: this.data.acVoltage,\n\t            current: this.data.acCurrent,\n\t            frequency: this.data.acFrequency,\n", "        };\n\t        const counters = {\n\t            totalEnergy: this.data.totalEnergy,\n\t            pv1TotalEnergy: this.data.pv1TotalEnergy,\n\t            pv2TotalEnergy: this.data.pv2TotalEnergy,\n\t            pv3TotalEnergy: this.data.pv3TotalEnergy,\n\t            pv4TotalEnergy: this.data.pv4TotalEnergy,\n\t            totalEnergyToday: this.data.totalEnergyToday,\n\t            pv1TotalEnergyToday: this.data.pv1TotalEnergyToday,\n\t            pv2TotalEnergyToday: this.data.pv2TotalEnergyToday,\n", "            pv3TotalEnergyToday: this.data.pv3TotalEnergyToday,\n\t            pv4TotalEnergyToday: this.data.pv4TotalEnergyToday,\n\t        };\n\t        return {\n\t            pv1: pv1,\n\t            pv2: pv2,\n\t            pv3: pv3,\n\t            pv4: pv4,\n\t            output: output,\n\t            counters: counters,\n", "            temperature: this.data.temperature,\n\t            isAvailable: this.available,\n\t        };\n\t    }\n\t    public setData(data: RegisterValues) {\n\t        if (this.data !== null && this.data.totalEnergy > data.totalEnergy) {\n\t            // totalEnergy should always increase while the node is running\n\t            return;\n\t        }\n\t        this.data = data;\n", "        this.lastDataAt = Date.now();\n\t        this.available = true;\n\t    }\n\t    public resetCounters(): void {\n\t        if (this.data !== null) {\n\t            this.data.pv1TotalEnergyToday = 0;\n\t            this.data.pv2TotalEnergyToday = 0;\n\t            this.data.pv3TotalEnergyToday = 0;\n\t            this.data.pv4TotalEnergyToday = 0;\n\t            this.data.totalEnergyToday = 0;\n", "        }\n\t    }\n\t    public resetRuntime(): void {\n\t        if (this.data !== null) {\n\t            this.data.pv1Voltage = 0;\n\t            this.data.pv1Current = 0;\n\t            this.data.pv2Voltage = 0;\n\t            this.data.pv2Current = 0;\n\t            this.data.pv3Voltage = 0;\n\t            this.data.pv3Current = 0;\n", "            this.data.pv4Voltage = 0;\n\t            this.data.pv4Current = 0;\n\t            this.data.acFrequency = 0;\n\t            this.data.acPower = 0;\n\t            this.data.acVoltage = 0;\n\t            this.data.acCurrent = 0;\n\t            this.data.uptime = 0;\n\t            this.data.operatingPower = 0;\n\t            this.data.temperature = null;\n\t        }\n", "    }\n\t    public isAvailable(): boolean {\n\t        return this.available;\n\t    }\n\t    public setAvailable(value: boolean): void {\n\t        this.available = value;\n\t    }\n\t    private round(value: number, decimals: string): number {\n\t        return Number(Math.round(<number>(<unknown>(value + 'e' + decimals))) + 'e-' + decimals);\n\t    }\n", "}\n"]}
{"filename": "src/deye-sun-g3/DeyeRegisters.ts", "chunked_list": ["interface Definition {\n\t    name: string;\n\t    type: 'unsigned' | 'signed' | 'string';\n\t    scale?: number;\n\t    offset?: number;\n\t    registers: Array<number>;\n\t    unit: string;\n\t}\n\texport interface RegisterValues {\n\t    [key: string]: number | string | null;\n", "    id: string;\n\t    statusCode: number;\n\t    totalEnergy: number;\n\t    totalEnergyToday: number;\n\t    acPower: number;\n\t    acVoltage: number;\n\t    acCurrent: number;\n\t    acFrequency: number;\n\t    pv1Voltage: number;\n\t    pv1Current: number;\n", "    pv1TotalEnergy: number;\n\t    pv1TotalEnergyToday: number;\n\t    pv2Voltage: number;\n\t    pv2Current: number;\n\t    pv2TotalEnergy: number;\n\t    pv2TotalEnergyToday: number;\n\t    pv3Voltage: number;\n\t    pv3Current: number;\n\t    pv3TotalEnergy: number;\n\t    pv3TotalEnergyToday: number;\n", "    pv4Voltage: number;\n\t    pv4Current: number;\n\t    pv4TotalEnergy: number;\n\t    pv4TotalEnergyToday: number;\n\t    temperature: number | null;\n\t    uptime: number;\n\t    operatingPower: number;\n\t}\n\texport class DeyeRegisters {\n\t    private dataDefinition: Array<Definition> = [\n", "        { name: 'id', type: 'string', registers: [0, 1, 2, 3, 4], unit: '' },\n\t        { name: 'statusCode', scale: 1, type: 'unsigned', registers: [56], unit: '' },\n\t        { name: 'totalEnergy', scale: 0.1, type: 'unsigned', registers: [60, 61], unit: 'kWh' },\n\t        { name: 'totalEnergyToday', scale: 0.1, type: 'unsigned', registers: [57], unit: 'kWh' },\n\t        { name: 'acPower', scale: 0.1, type: 'unsigned', registers: [83, 84], unit: 'W' },\n\t        { name: 'acVoltage', scale: 0.1, type: 'unsigned', registers: [70], unit: 'V' },\n\t        { name: 'acCurrent', scale: 0.1, type: 'signed', registers: [73], unit: 'A' },\n\t        { name: 'acFrequency', scale: 0.01, type: 'unsigned', registers: [76], unit: 'Hz' },\n\t        { name: 'pv1Voltage', scale: 0.1, type: 'unsigned', registers: [106], unit: 'V' },\n\t        { name: 'pv1Current', scale: 0.1, type: 'unsigned', registers: [107], unit: 'A' },\n", "        { name: 'pv1TotalEnergy', scale: 0.1, type: 'unsigned', registers: [66, 67], unit: 'kWh' },\n\t        { name: 'pv1TotalEnergyToday', scale: 0.1, type: 'unsigned', registers: [62], unit: 'kWh' },\n\t        { name: 'pv2Voltage', scale: 0.1, type: 'unsigned', registers: [108], unit: 'V' },\n\t        { name: 'pv2Current', scale: 0.1, type: 'unsigned', registers: [109], unit: 'A' },\n\t        { name: 'pv2TotalEnergy', scale: 0.1, type: 'unsigned', registers: [68, 69], unit: 'kWh' },\n\t        { name: 'pv2TotalEnergyToday', scale: 0.1, type: 'unsigned', registers: [63], unit: 'kWh' },\n\t        { name: 'pv3Voltage', scale: 0.1, type: 'unsigned', registers: [110], unit: 'V' },\n\t        { name: 'pv3Current', scale: 0.1, type: 'unsigned', registers: [111], unit: 'A' },\n\t        { name: 'pv3TotalEnergy', scale: 0.1, type: 'unsigned', registers: [71, 72], unit: 'kWh' },\n\t        { name: 'pv3TotalEnergyToday', scale: 0.1, type: 'unsigned', registers: [64], unit: 'kWh' },\n", "        { name: 'pv4Voltage', scale: 0.1, type: 'unsigned', registers: [112], unit: 'V' },\n\t        { name: 'pv4Current', scale: 0.1, type: 'unsigned', registers: [113], unit: 'A' },\n\t        { name: 'pv4TotalEnergy', scale: 0.1, type: 'unsigned', registers: [74, 75], unit: 'kWh' },\n\t        { name: 'pv4TotalEnergyToday', scale: 0.1, type: 'unsigned', registers: [65], unit: 'kWh' },\n\t        { name: 'temperature', scale: 0.01, offset: 1000, type: 'unsigned', registers: [87], unit: '°C' },\n\t        { name: 'uptime', scale: 1, type: 'unsigned', registers: [59], unit: 'm' },\n\t        { name: 'operatingPower', scale: 0.1, type: 'unsigned', registers: [77], unit: 'W' },\n\t    ];\n\t    public parse(modbusRegisters: Array<number>): RegisterValues {\n\t        const result: RegisterValues = {\n", "            id: '',\n\t            statusCode: 0,\n\t            totalEnergy: 0,\n\t            totalEnergyToday: 0,\n\t            acPower: 0,\n\t            acVoltage: 0,\n\t            acCurrent: 0,\n\t            acFrequency: 0,\n\t            pv1Voltage: 0,\n\t            pv1Current: 0,\n", "            pv1TotalEnergy: 0,\n\t            pv1TotalEnergyToday: 0,\n\t            pv2Voltage: 0,\n\t            pv2Current: 0,\n\t            pv2TotalEnergy: 0,\n\t            pv2TotalEnergyToday: 0,\n\t            pv3Voltage: 0,\n\t            pv3Current: 0,\n\t            pv3TotalEnergy: 0,\n\t            pv3TotalEnergyToday: 0,\n", "            pv4Voltage: 0,\n\t            pv4Current: 0,\n\t            pv4TotalEnergy: 0,\n\t            pv4TotalEnergyToday: 0,\n\t            temperature: 0,\n\t            uptime: 0,\n\t            operatingPower: 0,\n\t        };\n\t        for (const definition of this.dataDefinition) {\n\t            let value;\n", "            const type = definition.type;\n\t            if (type === 'unsigned') {\n\t                value = this.parseUnsigned(modbusRegisters, definition.registers, definition.scale || 1, definition.offset || 0);\n\t            } else if (type === 'signed') {\n\t                value = this.parseSigned(modbusRegisters, definition.registers, definition.scale || 1, definition.offset || 0);\n\t            } else if (type === 'string') {\n\t                value = this.parseString(modbusRegisters, definition.registers);\n\t            } else {\n\t                value = 'unknown';\n\t            }\n", "            result[definition.name] = value;\n\t        }\n\t        return result;\n\t    }\n\t    private parseUnsigned(modbusRegisters: Array<number>, registers: Array<number>, scale: number, offset: number): number {\n\t        let value = 0;\n\t        let shift = 0;\n\t        for (const index of registers) {\n\t            const temp = modbusRegisters[index];\n\t            value += (temp & 0xffff) << shift;\n", "            shift += 16;\n\t        }\n\t        value = value - offset;\n\t        value = value * scale;\n\t        return this.round(value, '4');\n\t    }\n\t    private parseSigned(modbusRegisters: Array<number>, registers: Array<number>, scale: number, offset: number): number {\n\t        let value = 0;\n\t        let shift = 0;\n\t        let maxint = 0;\n", "        for (const index of registers) {\n\t            maxint <<= 16;\n\t            maxint |= 0xffff;\n\t            const temp = modbusRegisters[index];\n\t            value += (temp & 0xffff) << shift;\n\t            shift += 16;\n\t        }\n\t        value = value - offset;\n\t        if (value > maxint / 2) {\n\t            value = (value - maxint) * scale;\n", "        } else {\n\t            value = value * scale;\n\t        }\n\t        return this.round(value, '4');\n\t    }\n\t    private parseString(modbusRegisters: Array<number>, registers: Array<number>): string {\n\t        let value = '';\n\t        for (const index of registers) {\n\t            const temp = modbusRegisters[index];\n\t            value = value + String.fromCharCode(temp >> 8) + String.fromCharCode(temp & 0xff);\n", "        }\n\t        return value;\n\t    }\n\t    private round(value: number, decimals: string): number {\n\t        return Number(Math.round(<number>(<unknown>(value + 'e' + decimals))) + 'e-' + decimals);\n\t    }\n\t}\n"]}
{"filename": "src/deye-sun-g3/Action/DailyResetAction.ts", "chunked_list": ["import { Action, InputDefinition, Output, OutputDefinition } from '@binsoul/node-red-bundle-processing';\n\timport type { Configuration } from '../Configuration';\n\timport { Storage } from '../Storage';\n\texport class DailyResetAction implements Action {\n\t    private readonly configuration: Configuration;\n\t    private storage: Storage;\n\t    constructor(configuration: Configuration, storage: Storage) {\n\t        this.configuration = configuration;\n\t        this.storage = storage;\n\t    }\n", "    defineInput(): InputDefinition {\n\t        return new InputDefinition();\n\t    }\n\t    defineOutput(): OutputDefinition {\n\t        const result = new OutputDefinition();\n\t        result.set('output', {\n\t            target: this.configuration.outputTarget,\n\t            property: this.configuration.outputProperty,\n\t            type: 'object',\n\t            channel: 0,\n", "        });\n\t        return result;\n\t    }\n\t    execute(): Output {\n\t        const result = new Output();\n\t        const isAvailable = this.storage.isAvailable();\n\t        this.storage.setAvailable(true);\n\t        this.storage.resetCounters();\n\t        const data = this.storage.getData();\n\t        this.storage.setAvailable(isAvailable);\n", "        if (data !== null) {\n\t            data.isAvailable = isAvailable;\n\t            result.setValue('output', data);\n\t            result.setNodeStatus({\n\t                fill: 'green',\n\t                shape: 'dot',\n\t                text: `daily reset`,\n\t            });\n\t        }\n\t        return result;\n", "    }\n\t}\n"]}
{"filename": "src/deye-sun-g3/Action/UnavailableAction.ts", "chunked_list": ["import { Action, InputDefinition, Output, OutputDefinition } from '@binsoul/node-red-bundle-processing';\n\timport type { Configuration } from '../Configuration';\n\timport { Storage } from '../Storage';\n\texport class UnavailableAction implements Action {\n\t    private readonly configuration: Configuration;\n\t    private storage: Storage;\n\t    constructor(configuration: Configuration, storage: Storage) {\n\t        this.configuration = configuration;\n\t        this.storage = storage;\n\t    }\n", "    defineInput(): InputDefinition {\n\t        return new InputDefinition();\n\t    }\n\t    defineOutput(): OutputDefinition {\n\t        const result = new OutputDefinition();\n\t        result.set('output', {\n\t            target: this.configuration.outputTarget,\n\t            property: this.configuration.outputProperty,\n\t            type: 'object',\n\t            channel: 0,\n", "        });\n\t        return result;\n\t    }\n\t    execute(): Output {\n\t        const result = new Output();\n\t        this.storage.setAvailable(true);\n\t        this.storage.resetRuntime();\n\t        const data = this.storage.getData();\n\t        this.storage.setAvailable(false);\n\t        if (data !== null) {\n", "            data.isAvailable = false;\n\t            result.setValue('output', data);\n\t        }\n\t        result.setNodeStatus({\n\t            fill: 'yellow',\n\t            shape: 'dot',\n\t            text: 'unavailable',\n\t        });\n\t        return result;\n\t    }\n", "}\n"]}
{"filename": "src/deye-sun-g3/Action/OutputAction.ts", "chunked_list": ["import { Action, InputDefinition, Output, OutputDefinition } from '@binsoul/node-red-bundle-processing';\n\timport type { Configuration } from '../Configuration';\n\timport { Storage } from '../Storage';\n\texport class OutputAction implements Action {\n\t    private readonly configuration: Configuration;\n\t    private storage: Storage;\n\t    constructor(configuration: Configuration, storage: Storage) {\n\t        this.configuration = configuration;\n\t        this.storage = storage;\n\t    }\n", "    defineInput(): InputDefinition {\n\t        return new InputDefinition();\n\t    }\n\t    defineOutput(): OutputDefinition {\n\t        const result = new OutputDefinition();\n\t        result.set('output', {\n\t            target: this.configuration.outputTarget,\n\t            property: this.configuration.outputProperty,\n\t            type: 'object',\n\t            channel: 0,\n", "        });\n\t        return result;\n\t    }\n\t    execute(): Output {\n\t        const result = new Output();\n\t        const data = this.storage.getData();\n\t        if (data !== null) {\n\t            result.setValue('output', data);\n\t            result.setNodeStatus({\n\t                fill: 'green',\n", "                shape: 'dot',\n\t                text: `${data.output.power} W`,\n\t            });\n\t        }\n\t        return result;\n\t    }\n\t}\n"]}
{"filename": "src/deye-sun-g3/Action/UpdateAction.ts", "chunked_list": ["import { Action, InputDefinition, Output, OutputDefinition } from '@binsoul/node-red-bundle-processing';\n\timport { ModbusRtu } from '@binsoul/nodejs-modbus';\n\timport { SolarmanV5 } from '@binsoul/nodejs-solarman';\n\timport * as net from 'net';\n\timport { NodeStatus } from 'node-red';\n\timport type { Configuration } from '../Configuration';\n\timport { DeyeRegisters } from '../DeyeRegisters';\n\timport { Storage } from '../Storage';\n\texport class UpdateAction implements Action {\n\t    private readonly configuration: Configuration;\n", "    private readonly storage: Storage;\n\t    private readonly outputCallback: () => void;\n\t    private readonly nodeStatusCallback: (status: NodeStatus) => void;\n\t    constructor(configuration: Configuration, storage: Storage, outputCallback: () => void, nodeStatusCallback: (status: NodeStatus) => void) {\n\t        this.configuration = configuration;\n\t        this.storage = storage;\n\t        this.outputCallback = outputCallback;\n\t        this.nodeStatusCallback = nodeStatusCallback;\n\t    }\n\t    defineInput(): InputDefinition {\n", "        return new InputDefinition();\n\t    }\n\t    defineOutput(): OutputDefinition {\n\t        return new OutputDefinition();\n\t    }\n\t    execute(): Output {\n\t        const client = new net.Socket();\n\t        client.setTimeout(5000);\n\t        let hasConnected = false;\n\t        let errorMessage = '';\n", "        let retryCount = 0;\n\t        const unitAddress = 1;\n\t        const firstRegister = 0x0003;\n\t        const lastRegister = 0x0080;\n\t        const modbus = new ModbusRtu(unitAddress);\n\t        const modbusFrame = modbus.requestHoldingRegisters(firstRegister, lastRegister);\n\t        const solarman = new SolarmanV5(this.configuration.deviceSerialNumber, true);\n\t        const request = solarman.wrapModbusFrame(modbusFrame);\n\t        // Functions to handle socket events\n\t        const makeConnection = () => {\n", "            client.connect({ host: this.configuration.deviceIp, port: 8899 });\n\t        };\n\t        const connectEventHandler = () => {\n\t            hasConnected = true;\n\t            this.storage.setConnected();\n\t            client.write(request);\n\t        };\n\t        const dataEventHandler = (data: Buffer) => {\n\t            try {\n\t                const modbusFrame = solarman.unwrapModbusFrame(data);\n", "                const values = modbus.fetchHoldingRegisters(modbusFrame);\n\t                const parser = new DeyeRegisters();\n\t                this.storage.setData(parser.parse(values));\n\t                this.outputCallback();\n\t            } catch (error) {\n\t                if (error instanceof Error) {\n\t                    this.nodeStatusCallback({\n\t                        fill: 'red',\n\t                        shape: 'dot',\n\t                        text: error.message,\n", "                    });\n\t                }\n\t            }\n\t            client.end();\n\t        };\n\t        const timeoutEventHandler = () => {\n\t            errorMessage = 'Connection timed out';\n\t            client.end();\n\t        };\n\t        const errorEventHandler = (error: Error) => {\n", "            errorMessage = error.message;\n\t            client.end();\n\t        };\n\t        const closeEventHandler = () => {\n\t            if (hasConnected) {\n\t                return;\n\t            }\n\t            if (!this.storage.isAvailable()) {\n\t                this.nodeStatusCallback({\n\t                    fill: 'yellow',\n", "                    shape: 'dot',\n\t                    text: 'unavailable',\n\t                });\n\t            } else if (retryCount < 5) {\n\t                retryCount++;\n\t                this.nodeStatusCallback({\n\t                    fill: 'yellow',\n\t                    shape: 'dot',\n\t                    text: 'retry ' + retryCount,\n\t                });\n", "                setTimeout(makeConnection, 5000);\n\t            } else {\n\t                this.nodeStatusCallback({\n\t                    fill: 'red',\n\t                    shape: 'dot',\n\t                    text: errorMessage,\n\t                });\n\t            }\n\t        };\n\t        client.on('connect', connectEventHandler);\n", "        client.on('data', dataEventHandler);\n\t        client.on('timeout', timeoutEventHandler);\n\t        client.on('error', errorEventHandler);\n\t        client.on('close', closeEventHandler);\n\t        this.nodeStatusCallback({\n\t            fill: 'yellow',\n\t            shape: 'dot',\n\t            text: 'updating',\n\t        });\n\t        makeConnection();\n", "        return new Output();\n\t    }\n\t}\n"]}
{"filename": "src/deye-sun-g3/Node.html/editor.ts", "chunked_list": ["import type { EditorNodeProperties, EditorRED } from 'node-red';\n\timport type { UserConfigurationOptions } from '../UserConfiguration';\n\tdeclare const RED: EditorRED;\n\tinterface NodeEditorProperties extends EditorNodeProperties, UserConfigurationOptions {}\n\tRED.nodes.registerType<NodeEditorProperties>('binsoul-deye-sun-g3', {\n\t    category: 'device',\n\t    color: '#4594d1',\n\t    defaults: {\n\t        outputProperty: {\n\t            value: 'payload',\n", "            required: true,\n\t        },\n\t        outputTarget: {\n\t            value: 'msg',\n\t            required: true,\n\t        },\n\t        deviceIp: {\n\t            value: '192.168.33.1',\n\t            required: true,\n\t        },\n", "        deviceSerialNumber: {\n\t            value: '',\n\t            required: true,\n\t        },\n\t        deviceTimeout: {\n\t            value: 30,\n\t            required: true,\n\t            validate: RED.validators.number(),\n\t        },\n\t        updateMode: {\n", "            value: 'never',\n\t            required: true,\n\t        },\n\t        updateFrequency: {\n\t            value: 5,\n\t            required: true,\n\t            validate: RED.validators.number(),\n\t        },\n\t        name: { value: '' },\n\t    },\n", "    inputs: 1,\n\t    outputs: 1,\n\t    icon: 'font-awesome/fa-share-square-o',\n\t    label: function () {\n\t        return this.name || 'Deye SUN G3';\n\t    },\n\t    labelStyle: function () {\n\t        return this.name ? 'node_label_italic' : '';\n\t    },\n\t    paletteLabel: 'Deye SUN G3',\n", "    inputLabels: 'Incoming message',\n\t    outputLabels: ['Outgoing message'],\n\t    oneditprepare: function () {\n\t        setTimeout(() => {\n\t            $('.binsoul-deye-sun-g3-wrapper').css('width', '100%');\n\t            $('.binsoul-deye-sun-g3-wrapper .red-ui-typedInput-container').css({\n\t                width: 'auto',\n\t                display: 'flex',\n\t            });\n\t        });\n", "        $('#node-input-outputProperty').typedInput({\n\t            typeField: '#node-input-outputTarget',\n\t            types: ['msg', 'flow', 'global'],\n\t            default: 'msg',\n\t        });\n\t    },\n\t});\n"]}
