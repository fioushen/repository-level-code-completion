{"filename": "jest.config.ts", "chunked_list": ["export default {\n\t  preset: 'ts-jest',\n\t  testEnvironment: 'node',\n\t  modulePathIgnorePatterns: ['<rootDir>/dist/']\n\t}\n"]}
{"filename": "src/app.ts", "chunked_list": ["import express from 'express'\n\timport type { Express } from 'express'\n\timport bodyParser from 'body-parser'\n\timport cors from 'cors'\n\timport { dataSource } from './configs/dbConfig'\n\timport authRouter from './routes/auth/auth.route'\n\timport profileRouter from './routes/profile/profile.route'\n\timport passport from 'passport'\n\timport './configs/passport'\n\timport cookieParser from 'cookie-parser'\n", "const app = express()\n\tapp.use(cookieParser())\n\tapp.use(bodyParser.json())\n\tapp.use(cors())\n\tapp.use(passport.initialize())\n\tapp.get('/', (req, res) => {\n\t  res.send('ScholarX Backend')\n\t})\n\tapp.use('/api/auth', authRouter)\n\tapp.use('/api/me', profileRouter)\n", "export const startServer = async (port: number): Promise<Express> => {\n\t  try {\n\t    await dataSource.initialize()\n\t    console.log('DB connection is successful')\n\t    app.listen(port, () => {\n\t      console.log(`Server is running on http://localhost:${port}`)\n\t    })\n\t    return app\n\t  } catch (err) {\n\t    console.log('DB connection was not successful', err)\n", "    throw err\n\t  }\n\t}\n\texport default startServer\n"]}
{"filename": "src/types.ts", "chunked_list": ["interface Option {\n\t  // todo: To be determined (Not final)\n\t  answer: string\n\t}\n\tinterface Question {\n\t  question: string\n\t  answer: string\n\t  // todo: Types should be declared here (Not final)\n\t  type: 'TYPES'\n\t  options: Option\n", "}\n\texport interface MenteeApplication {\n\t  answers: Question[]\n\t  state: string\n\t  mentor_id: bigint\n\t}\n"]}
{"filename": "src/server.ts", "chunked_list": ["import startServer from './app'\n\timport { SERVER_PORT } from './configs/envConfig'\n\tconst port = SERVER_PORT as number\n\tasync function start(): Promise<void> {\n\t  try {\n\t    await startServer(port)\n\t    console.log('Server started!')\n\t  } catch (err) {\n\t    console.error('Something went wrong!', err)\n\t  }\n", "}\n\tstart().catch((err) => {\n\t  console.error(err)\n\t})\n"]}
{"filename": "src/configs/envConfig.ts", "chunked_list": ["import dotenv from 'dotenv'\n\tdotenv.config()\n\texport const DB_USER = process.env.DB_USER\n\texport const DB_HOST = process.env.DB_HOST\n\texport const DB_NAME = process.env.DB_NAME\n\texport const DB_PASSWORD = process.env.DB_PASSWORD\n\texport const DB_PORT = process.env.DB_PORT\n\texport const SERVER_PORT = process.env.SERVER_PORT ?? 3000\n\texport const JWT_SECRET = process.env.JWT_SECRET ?? ''\n"]}
{"filename": "src/configs/db.test.ts", "chunked_list": ["import { dataSource } from './dbConfig'\n\texport const initConnection = async (): Promise<void> => {\n\t  await dataSource\n\t    .initialize()\n\t    .then(() => {\n\t      console.log('Data Source has been initialized!')\n\t    })\n\t    .catch((err) => {\n\t      console.error('Error during Data Source initialization:', err)\n\t      throw new Error('Data Source initialization failed')\n", "    })\n\t}\n\tdescribe('typeorm connection', () => {\n\t  it('should test typeorm connection', async () => {\n\t    await expect(initConnection()).resolves.not.toThrow()\n\t  })\n\t})\n"]}
{"filename": "src/configs/dbConfig.ts", "chunked_list": ["import { DataSource } from 'typeorm'\n\timport { DB_PASSWORD, DB_HOST, DB_PORT, DB_USER, DB_NAME } from './envConfig'\n\texport const dataSource = new DataSource({\n\t  type: 'postgres',\n\t  host: DB_HOST,\n\t  port: Number(DB_PORT) ?? 5432,\n\t  username: DB_USER,\n\t  password: DB_PASSWORD,\n\t  database: DB_NAME,\n\t  entities: ['src/entities/*.ts'],\n", "  logging: false,\n\t  synchronize: true\n\t})\n"]}
{"filename": "src/configs/passport.ts", "chunked_list": ["import passport from 'passport'\n\timport { Strategy as JwtStrategy } from 'passport-jwt'\n\timport { dataSource } from './dbConfig'\n\timport Profile from '../entities/profile.entity'\n\timport { JWT_SECRET } from './envConfig'\n\timport type { Request } from 'express'\n\tconst cookieExtractor = (req: Request): string => {\n\t  let token = null\n\t  if (req?.cookies) {\n\t    token = req.cookies.jwt\n", "  }\n\t  return token\n\t}\n\tconst options = {\n\t  jwtFromRequest: cookieExtractor,\n\t  secretOrKey: JWT_SECRET\n\t}\n\tpassport.use(\n\t  new JwtStrategy(options, async (jwtPayload, done) => {\n\t    try {\n", "      const profileRepository = dataSource.getRepository(Profile)\n\t      const profile = await profileRepository.findOne({\n\t        where: { uuid: jwtPayload.userId }\n\t      })\n\t      if (!profile) {\n\t        done(null, false)\n\t      } else {\n\t        done(null, profile)\n\t      }\n\t    } catch (error) {\n", "      done(error, false)\n\t    }\n\t  })\n\t)\n\texport default passport\n"]}
{"filename": "src/enums/index.ts", "chunked_list": ["export enum ProfileTypes {\n\t  DEFAULT = 'default',\n\t  ADMIN = 'admin'\n\t}\n\texport enum EmailStatusTypes {\n\t  SENT = 'sent',\n\t  DELIVERED = 'delivered',\n\t  FAILED = 'failed'\n\t}\n\texport enum ApplicationStatus {\n", "  PENDING = 'pending',\n\t  REJECTED = 'rejected',\n\t  ACCEPTED = 'accepted'\n\t}\n"]}
{"filename": "src/services/profile.service.ts", "chunked_list": ["import { dataSource } from '../configs/dbConfig'\n\timport Profile from '../entities/profile.entity'\n\texport const updateProfile = async (\n\t  user: Profile,\n\t  {\n\t    primary_email,\n\t    contact_email,\n\t    first_name,\n\t    last_name,\n\t    image_url,\n", "    linkedin_url\n\t  }: Partial<Profile>\n\t): Promise<{\n\t  statusCode: number\n\t  profile?: Profile | null\n\t  message: string\n\t}> => {\n\t  try {\n\t    const profileRepository = dataSource.getRepository(Profile)\n\t    await profileRepository.update(\n", "      { uuid: user.uuid },\n\t      {\n\t        primary_email,\n\t        contact_email,\n\t        first_name,\n\t        last_name,\n\t        image_url,\n\t        linkedin_url\n\t      }\n\t    )\n", "    const savedProfile = await profileRepository.findOneBy({\n\t      uuid: user.uuid\n\t    })\n\t    return {\n\t      statusCode: 200,\n\t      profile: savedProfile,\n\t      message: 'Successfully updated the profile'\n\t    }\n\t  } catch (error) {\n\t    console.error('Error executing login', error)\n", "    return { statusCode: 500, message: 'Internal server error' }\n\t  }\n\t}\n"]}
{"filename": "src/services/auth.service.ts", "chunked_list": ["import { dataSource } from '../configs/dbConfig'\n\timport bcrypt from 'bcrypt'\n\timport jwt from 'jsonwebtoken'\n\timport Profile from '../entities/profile.entity'\n\timport { JWT_SECRET } from '../configs/envConfig'\n\texport const registerUser = async (\n\t  email: string,\n\t  password: string\n\t): Promise<{\n\t  statusCode: number\n", "  message: string\n\t  profile?: Profile | null\n\t}> => {\n\t  try {\n\t    const profileRepository = dataSource.getRepository(Profile)\n\t    const existingProfile = await profileRepository.findOne({\n\t      where: { primary_email: email }\n\t    })\n\t    if (existingProfile != null) {\n\t      return { statusCode: 409, message: 'Email already exists' }\n", "    }\n\t    const hashedPassword = await bcrypt.hash(password, 10)\n\t    const newProfile = profileRepository.create({\n\t      primary_email: email,\n\t      password: hashedPassword,\n\t      contact_email: '',\n\t      first_name: '',\n\t      last_name: '',\n\t      image_url: '',\n\t      linkedin_url: ''\n", "    })\n\t    await profileRepository.save(newProfile)\n\t    const savedProfile = await profileRepository.findOne({\n\t      where: { primary_email: email }\n\t    })\n\t    return {\n\t      statusCode: 201,\n\t      message: 'Registration successful',\n\t      profile: savedProfile\n\t    }\n", "  } catch (error) {\n\t    console.error('Error executing registration', error)\n\t    return { statusCode: 500, message: 'Internal server error' }\n\t  }\n\t}\n\texport const loginUser = async (\n\t  email: string,\n\t  password: string\n\t): Promise<{ statusCode: number; message: string; token?: string }> => {\n\t  try {\n", "    const profileRepository = dataSource.getRepository(Profile)\n\t    const profile = await profileRepository\n\t      .createQueryBuilder('profile')\n\t      .addSelect('profile.password')\n\t      .where({ primary_email: email })\n\t      .getOne()\n\t    if (!profile) {\n\t      return { statusCode: 401, message: 'Invalid email or password' }\n\t    }\n\t    const passwordMatch = await bcrypt.compare(password, profile.password)\n", "    if (!passwordMatch) {\n\t      return { statusCode: 401, message: 'Invalid email or password' }\n\t    }\n\t    const token = jwt.sign({ userId: profile.uuid }, JWT_SECRET ?? '', {\n\t      expiresIn: '10h' // To-Do: Change value in production\n\t    })\n\t    return { statusCode: 200, message: 'Login successful', token }\n\t  } catch (error) {\n\t    console.error('Error executing login', error)\n\t    return { statusCode: 500, message: 'Internal server error' }\n", "  }\n\t}\n"]}
{"filename": "src/controllers/auth.controller.ts", "chunked_list": ["import type { Request, Response, NextFunction } from 'express'\n\timport { registerUser, loginUser } from '../services/auth.service'\n\timport passport from 'passport'\n\timport type Profile from '../entities/profile.entity'\n\timport jwt from 'jsonwebtoken'\n\timport { JWT_SECRET } from '../configs/envConfig'\n\texport const register = async (req: Request, res: Response): Promise<void> => {\n\t  try {\n\t    const { email, password } = req.body\n\t    if (!email || !password) {\n", "      res.status(400).json({ error: 'Email and password are required fields' })\n\t    }\n\t    const { statusCode, message, profile } = await registerUser(email, password)\n\t    res.status(statusCode).json({ message, profile })\n\t  } catch (err) {\n\t    if (err instanceof Error) {\n\t      console.error('Error executing query', err)\n\t      res\n\t        .status(500)\n\t        .json({ error: 'Internal server error', message: err.message })\n", "    }\n\t  }\n\t}\n\texport const login = async (req: Request, res: Response): Promise<void> => {\n\t  try {\n\t    const { email, password } = req.body\n\t    if (!email || !password) {\n\t      res.status(400).json({ error: 'Email and password are required fields' })\n\t    }\n\t    const { statusCode, message, token } = await loginUser(email, password)\n", "    res.cookie('jwt', token, {\n\t      httpOnly: true,\n\t      maxAge: 24 * 60 * 60 * 1000,\n\t      secure: false // TODO: Set to true when using HTTPS\n\t    })\n\t    res.status(statusCode).json({ message })\n\t  } catch (err) {\n\t    if (err instanceof Error) {\n\t      console.error('Error executing query', err)\n\t      res\n", "        .status(500)\n\t        .json({ error: 'Internal server error', message: err.message })\n\t    }\n\t  }\n\t}\n\texport const logout = async (req: Request, res: Response): Promise<void> => {\n\t  try {\n\t    res.clearCookie('jwt', { httpOnly: true })\n\t    res.status(200).json({ message: 'Logged out successfully' })\n\t  } catch (err) {\n", "    if (err instanceof Error) {\n\t      console.error('Something went wrong', err)\n\t      res\n\t        .status(500)\n\t        .json({ error: 'Internal server error', message: err.message })\n\t    }\n\t  }\n\t}\n\texport const requireAuth = (\n\t  req: Request,\n", "  res: Response,\n\t  next: NextFunction\n\t): void => {\n\t  passport.authenticate(\n\t    'jwt',\n\t    { session: false },\n\t    (err: Error, user: Profile) => {\n\t      if (err) {\n\t        next(err)\n\t        return\n", "      }\n\t      const token = req.cookies.jwt\n\t      if (!token) {\n\t        return res.status(401).json({ error: 'No token provided' })\n\t      }\n\t      const decoded = jwt.verify(token, JWT_SECRET) as jwt.JwtPayload\n\t      if (decoded.exp && Date.now() > decoded.exp * 1000) {\n\t        return res\n\t          .status(401)\n\t          .json({ error: 'Token expired, please log in again' })\n", "      }\n\t      if (!user) {\n\t        return res.status(401).json({ message: 'Unauthorised' })\n\t      } else {\n\t        req.user = user\n\t        next()\n\t      }\n\t    }\n\t  )(req, res, next)\n\t}\n"]}
{"filename": "src/controllers/profile.controller.ts", "chunked_list": ["import type { Request, Response } from 'express'\n\timport { updateProfile } from '../services/profile.service'\n\timport type Profile from '../entities/profile.entity'\n\texport const getProfileHandler = async (\n\t  req: Request,\n\t  res: Response\n\t): Promise<void> => {\n\t  try {\n\t    const { user } = req\n\t    if (!user) {\n", "      res.status(404).json({ message: 'Profile not found' })\n\t    }\n\t    res.status(200).json(user)\n\t  } catch (err) {\n\t    if (err instanceof Error) {\n\t      console.error('Error executing query', err)\n\t      res\n\t        .status(500)\n\t        .json({ error: 'Internal server error', message: err.message })\n\t    }\n", "  }\n\t}\n\texport const updateProfileHandler = async (\n\t  req: Request,\n\t  res: Response\n\t): Promise<void> => {\n\t  try {\n\t    const user = req.user as Profile\n\t    if (!user) {\n\t      res.status(404).json({ message: 'Profile not found' })\n", "    }\n\t    const { statusCode, message, profile } =\n\t      user && (await updateProfile(user, req.body))\n\t    res.status(statusCode).json({ message, profile })\n\t  } catch (err) {\n\t    if (err instanceof Error) {\n\t      console.error('Error executing query', err)\n\t      res\n\t        .status(500)\n\t        .json({ error: 'Internal server error', message: err.message })\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src/routes/profile/profile.route.ts", "chunked_list": ["import express from 'express'\n\timport {\n\t  getProfileHandler,\n\t  updateProfileHandler\n\t} from '../../controllers/profile.controller'\n\timport { requireAuth } from '../../controllers/auth.controller'\n\tconst profileRouter = express.Router()\n\tprofileRouter.get('/profile', requireAuth, getProfileHandler)\n\tprofileRouter.put('/profile', requireAuth, updateProfileHandler)\n\texport default profileRouter\n"]}
{"filename": "src/routes/profile/profile.route.test.ts", "chunked_list": ["import { startServer } from '../../app'\n\timport type { Express } from 'express'\n\timport supertest from 'supertest'\n\timport { dataSource } from '../../configs/dbConfig'\n\tconst randomString = Math.random().toString(36)\n\tconst port = Math.floor(Math.random() * (9999 - 3000 + 1)) + 3000\n\tlet server: Express\n\tlet agent: supertest.SuperAgentTest\n\tdescribe('profile', () => {\n\t  beforeAll(async () => {\n", "    server = await startServer(port)\n\t    agent = supertest.agent(server)\n\t    const testUser = {\n\t      email: `test${randomString}@gmail.com`,\n\t      password: '123'\n\t    }\n\t    await supertest(server)\n\t      .post('/api/auth/register')\n\t      .send(testUser)\n\t      .expect(201)\n", "    await agent.post('/api/auth/login').send(testUser).expect(200)\n\t  }, 5000)\n\t  describe('Get profile route', () => {\n\t    it('should return a 200 with a user profile object', async () => {\n\t      const response = await agent.get('/api/me/profile').expect(200)\n\t      expect(response.body).toHaveProperty('created_at')\n\t      expect(response.body).toHaveProperty('updated_at')\n\t      expect(response.body).toHaveProperty('primary_email')\n\t      expect(response.body).toHaveProperty('contact_email')\n\t      expect(response.body).toHaveProperty('first_name')\n", "      expect(response.body).toHaveProperty('last_name')\n\t      expect(response.body).toHaveProperty('image_url')\n\t      expect(response.body).toHaveProperty('linkedin_url')\n\t      expect(response.body).toHaveProperty('type')\n\t      expect(response.body).toHaveProperty('uuid')\n\t      expect(response.body).not.toHaveProperty('password')\n\t    })\n\t  })\n\t  describe('Update profile route', () => {\n\t    it('should update the user profile and return a 200', async () => {\n", "      const updatedProfile = {\n\t        contact_email: 'test_contact@example.com',\n\t        first_name: 'John',\n\t        last_name: 'Doe',\n\t        image_url: 'https://example.com/test_profile_image.jpg',\n\t        linkedin_url: 'https://www.linkedin.com/in/johndoe'\n\t      }\n\t      await agent.put('/api/me/profile').send(updatedProfile).expect(200)\n\t    })\n\t    it('should return a 401 when a valid access token is not provided', async () => {\n", "      await supertest(server).put('/api/me/profile').send({}).expect(401)\n\t    })\n\t    afterAll(async () => {\n\t      await dataSource.destroy()\n\t    })\n\t  })\n\t})\n"]}
{"filename": "src/routes/auth/auth.route.test.ts", "chunked_list": ["import { startServer } from '../../app'\n\timport type { Express } from 'express'\n\timport supertest from 'supertest'\n\timport { dataSource } from '../../configs/dbConfig'\n\tconst randomString = Math.random().toString(36)\n\tconst port = Math.floor(Math.random() * (9999 - 3000 + 1)) + 3000\n\tlet server: Express\n\tlet agent: supertest.SuperAgentTest\n\tconst testUser = {\n\t  email: `test${randomString}@gmail.com`,\n", "  password: '123'\n\t}\n\tbeforeAll(async () => {\n\t  server = await startServer(port)\n\t  agent = supertest.agent(server)\n\t}, 5000)\n\tdescribe('auth controllers', () => {\n\t  describe('register', () => {\n\t    it('should return a 400 when email or password is missing', async () => {\n\t      await supertest(server).post('/api/auth/register').send({}).expect(400)\n", "    })\n\t    it('should return a 201 with a user profile after successful registration', async () => {\n\t      const response = await supertest(server)\n\t        .post('/api/auth/register')\n\t        .send(testUser)\n\t        .expect(201)\n\t      expect(response.body).toHaveProperty('message')\n\t      expect(response.body.profile).toHaveProperty('created_at')\n\t      expect(response.body.profile).toHaveProperty('updated_at')\n\t      expect(response.body.profile).toHaveProperty('primary_email')\n", "      expect(response.body.profile).toHaveProperty('contact_email')\n\t      expect(response.body.profile).toHaveProperty('first_name')\n\t      expect(response.body.profile).toHaveProperty('last_name')\n\t      expect(response.body.profile).toHaveProperty('image_url')\n\t      expect(response.body.profile).toHaveProperty('linkedin_url')\n\t      expect(response.body.profile).toHaveProperty('type')\n\t      expect(response.body.profile).toHaveProperty('uuid')\n\t      expect(response.body.profile).not.toHaveProperty('password')\n\t    })\n\t    it('should return a 400 when registering with a duplicate email', async () => {\n", "      await supertest(server)\n\t        .post('/api/auth/register')\n\t        .send(testUser)\n\t        .expect(409)\n\t    })\n\t  })\n\t  describe('login', () => {\n\t    it('should return a 400 when email or password is missing', async () => {\n\t      await supertest(server).post('/api/auth/login').send({}).expect(400)\n\t    })\n", "    it('should return a 200 after successful login', async () => {\n\t      const response = await supertest(server)\n\t        .post('/api/auth/login')\n\t        .send(testUser)\n\t        .expect(200)\n\t      expect(response.body).toHaveProperty('message')\n\t    })\n\t    it('should return a 401 when logging in with incorrect credentials', async () => {\n\t      const incorrectUser = {\n\t        email: `test${randomString}@gmail.com`,\n", "        password: 'incorrect_password'\n\t      }\n\t      await supertest(server)\n\t        .post('/api/auth/login')\n\t        .send({ email: incorrectUser.email, password: 'wrong_password' })\n\t        .expect(401)\n\t    })\n\t  })\n\t  describe('logout', () => {\n\t    it('should clear the jwt cookie and return a 200', async () => {\n", "      const response = await agent.get('/api/auth/logout').expect(200)\n\t      const jwtCookie = response.headers['set-cookie']\n\t      expect(\n\t        jwtCookie.some((cookie: string[]) => cookie.includes('jwt='))\n\t      ).toBe(true)\n\t    })\n\t  })\n\t  afterAll(async () => {\n\t    await dataSource.destroy()\n\t  })\n", "})\n"]}
{"filename": "src/routes/auth/auth.route.ts", "chunked_list": ["import express from 'express'\n\timport { register, login, logout } from '../../controllers/auth.controller'\n\tconst authRouter = express.Router()\n\tauthRouter.post('/register', register)\n\tauthRouter.post('/login', login)\n\tauthRouter.get('/logout', logout)\n\texport default authRouter\n"]}
{"filename": "src/entities/mentee.entity.ts", "chunked_list": ["import { Column, Entity, JoinColumn, ManyToOne, OneToOne } from 'typeorm'\n\timport { MenteeApplication } from '../types'\n\timport Mentor from './mentor.entity'\n\timport profileEntity from './profile.entity'\n\timport { ApplicationStatus } from '../enums'\n\timport BaseEntity from './baseEntity'\n\t@Entity('mentee')\n\tclass Mentee extends BaseEntity {\n\t  @Column({\n\t    type: 'enum',\n", "    enum: ApplicationStatus,\n\t    default: ApplicationStatus.PENDING\n\t  })\n\t  state: ApplicationStatus\n\t  @Column({ type: 'json' })\n\t  answers: MenteeApplication\n\t  @Column({ type: 'bigint' })\n\t  certificate_id: bigint\n\t  @Column()\n\t  journal: string\n", "  @OneToOne(() => profileEntity)\n\t  @JoinColumn()\n\t  profile: profileEntity\n\t  @ManyToOne(() => Mentor, (mentor) => mentor.mentees)\n\t  mentor: Mentor\n\t  constructor(\n\t    state: ApplicationStatus,\n\t    answers: MenteeApplication,\n\t    certificate_id: bigint,\n\t    journal: string,\n", "    profile: profileEntity,\n\t    mentor: Mentor\n\t  ) {\n\t    super()\n\t    this.state = state\n\t    this.answers = answers\n\t    this.certificate_id = certificate_id\n\t    this.journal = journal\n\t    this.profile = profile\n\t    this.mentor = mentor\n", "  }\n\t}\n\texport default Mentee\n"]}
{"filename": "src/entities/platform.entity.ts", "chunked_list": ["import { Column, Entity } from 'typeorm'\n\timport BaseEntity from './baseEntity'\n\t@Entity('platform')\n\tclass Platform extends BaseEntity {\n\t  @Column()\n\t  description: string\n\t  @Column({ type: 'json' })\n\t  mentor_questions: JSON\n\t  @Column()\n\t  image_url: string\n", "  @Column()\n\t  landing_page_url: string\n\t  @Column({ type: 'json' })\n\t  email_templates: JSON\n\t  @Column({ type: 'varchar', length: 255 })\n\t  title: string\n\t  constructor(\n\t    description: string,\n\t    mentor_questions: JSON,\n\t    image_url: string,\n", "    landing_page_url: string,\n\t    email_templates: JSON,\n\t    title: string\n\t  ) {\n\t    super()\n\t    this.description = description\n\t    this.mentor_questions = mentor_questions\n\t    this.image_url = image_url\n\t    this.landing_page_url = landing_page_url\n\t    this.email_templates = email_templates\n", "    this.title = title\n\t  }\n\t}\n\texport default Platform\n"]}
{"filename": "src/entities/email.entity.ts", "chunked_list": ["import { Column, Entity } from 'typeorm'\n\timport { EmailStatusTypes } from '../enums'\n\timport BaseEntity from './baseEntity'\n\t@Entity('email')\n\tclass Email extends BaseEntity {\n\t  @Column({ type: 'varchar', length: 255 })\n\t  recipient: string\n\t  @Column({ type: 'varchar', length: 255 })\n\t  subject: string\n\t  @Column({ type: 'varchar', length: 655 })\n", "  content: string\n\t  @Column({ type: 'enum', enum: EmailStatusTypes })\n\t  state: EmailStatusTypes\n\t  constructor(\n\t    recipient: string,\n\t    subject: string,\n\t    content: string,\n\t    state: EmailStatusTypes\n\t  ) {\n\t    super()\n", "    this.recipient = recipient\n\t    this.subject = subject\n\t    this.content = content\n\t    this.state = state\n\t  }\n\t}\n\texport default Email\n"]}
{"filename": "src/entities/mentor.entity.ts", "chunked_list": ["import { Column, Entity, JoinColumn, OneToMany, OneToOne } from 'typeorm'\n\timport profileEntity from './profile.entity'\n\timport Mentee from './mentee.entity'\n\timport Category from './category.entity'\n\timport { ApplicationStatus } from '../enums'\n\timport BaseEntity from './baseEntity'\n\t@Entity('mentor')\n\tclass Mentor extends BaseEntity {\n\t  @Column({\n\t    type: 'enum',\n", "    enum: ApplicationStatus,\n\t    default: ApplicationStatus.PENDING\n\t  })\n\t  state: ApplicationStatus\n\t  @OneToMany(() => Category, (category) => category.category)\n\t  category: Category\n\t  @Column({ type: 'json', select: false })\n\t  application: JSON\n\t  @Column({ type: 'boolean' })\n\t  availability: boolean\n", "  @OneToOne(() => profileEntity)\n\t  @JoinColumn()\n\t  profile: profileEntity\n\t  @OneToMany(() => Mentee, (mentee) => mentee.mentor)\n\t  mentees: Mentee[]\n\t  constructor(\n\t    state: ApplicationStatus,\n\t    category: Category,\n\t    application: JSON,\n\t    availability: boolean,\n", "    profile: profileEntity,\n\t    mentees: Mentee[]\n\t  ) {\n\t    super()\n\t    this.state = state\n\t    this.category = category\n\t    this.application = application\n\t    this.availability = availability\n\t    this.profile = profile\n\t    this.mentees = mentees\n", "  }\n\t}\n\texport default Mentor\n"]}
{"filename": "src/entities/profile.entity.ts", "chunked_list": ["import bcrypt from 'bcrypt'\n\timport { Entity, Column } from 'typeorm'\n\timport { ProfileTypes } from '../enums'\n\timport BaseEntity from './baseEntity'\n\t@Entity({ name: 'profile' })\n\tclass Profile extends BaseEntity {\n\t  @Column({ type: 'varchar', length: 255, unique: true })\n\t  primary_email: string\n\t  @Column({ type: 'varchar', length: 255 })\n\t  contact_email: string\n", "  @Column({ type: 'varchar', length: 255 })\n\t  first_name: string\n\t  @Column({ type: 'varchar', length: 255 })\n\t  last_name: string\n\t  @Column({ type: 'varchar', length: 255 })\n\t  image_url: string\n\t  @Column({ type: 'varchar', length: 255 })\n\t  linkedin_url: string\n\t  @Column({ type: 'enum', enum: ProfileTypes, default: ProfileTypes.DEFAULT })\n\t  type: ProfileTypes\n", "  @Column({ type: 'varchar', length: 255, select: false })\n\t  password: string\n\t  constructor(\n\t    primary_email: string,\n\t    contact_email: string,\n\t    first_name: string,\n\t    last_name: string,\n\t    image_uri: string,\n\t    linkedin_uri: string,\n\t    type: ProfileTypes,\n", "    password: string\n\t  ) {\n\t    super()\n\t    this.primary_email = primary_email\n\t    this.contact_email = contact_email\n\t    this.first_name = first_name\n\t    this.last_name = last_name\n\t    this.image_url = image_uri\n\t    this.linkedin_url = linkedin_uri\n\t    this.type = type || ProfileTypes.DEFAULT\n", "    this.password = password\n\t  }\n\t  async comparePassword(candidatePassword: string): Promise<boolean> {\n\t    return await bcrypt.compare(candidatePassword, this.password)\n\t  }\n\t}\n\texport default Profile\n"]}
{"filename": "src/entities/baseEntity.ts", "chunked_list": ["import {\n\t  BeforeInsert,\n\t  BeforeUpdate,\n\t  Column,\n\t  PrimaryGeneratedColumn\n\t} from 'typeorm'\n\timport { v4 as uuidv4 } from 'uuid'\n\tclass BaseEntity {\n\t  @PrimaryGeneratedColumn('uuid')\n\t  uuid!: string\n", "  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n\t  created_at: Date | undefined\n\t  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n\t  updated_at: Date | undefined\n\t  @BeforeInsert()\n\t  @BeforeUpdate()\n\t  updateTimestamps(): void {\n\t    this.updated_at = new Date()\n\t    if (!this.uuid) {\n\t      this.created_at = new Date()\n", "    }\n\t  }\n\t  @BeforeInsert()\n\t  async generateUuid(): Promise<void> {\n\t    if (!this.uuid) {\n\t      this.uuid = uuidv4()\n\t    }\n\t  }\n\t}\n\texport default BaseEntity\n"]}
{"filename": "src/entities/category.entity.ts", "chunked_list": ["import { Column, Entity } from 'typeorm'\n\timport BaseEntity from './baseEntity'\n\t@Entity('category')\n\tclass Category extends BaseEntity {\n\t  @Column({ type: 'varchar', length: 255 })\n\t  category: string\n\t  constructor(category: string) {\n\t    super()\n\t    this.category = category\n\t  }\n", "}\n\texport default Category\n"]}
