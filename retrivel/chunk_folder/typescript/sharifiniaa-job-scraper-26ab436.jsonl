{"filename": "src/types.ts", "chunked_list": ["import {Job} from 'prisma/prisma-client';\n\texport type TJob = Omit<Job, 'id' | 'job_name' | 'created_date'>;\n"]}
{"filename": "src/server.ts", "chunked_list": ["require('dotenv').config();\n\tconst http = require('http');\n\timport {scraper} from './modules/scraper';\n\timport {collectCompanies} from './modules/companies';\n\timport {cli} from './modules/cli';\n\timport {gatheringCompanies, generateCoverLetter, getJD, getUserInformation, startScarpData, updateInformation} from './modules/telegram';\n\tgenerateCoverLetter();\n\tgetUserInformation();\n\tstartScarpData();\n\tupdateInformation();\n", "gatheringCompanies();\n\tgetJD()\n\texport async function runScripts(locations?: string[], keyword?: string, description?: boolean) {\n\t  if (locations && keyword) {\n\t    console.log('we are here');\n\t    await scraper(locations, keyword, description);\n\t    return;\n\t  }\n\t  const userArgs = await cli();\n\t  if (userArgs) {\n", "    await collectCompanies();\n\t    console.log(userArgs);\n\t    await scraper(userArgs.locations, userArgs.keyword, userArgs.d);\n\t  }\n\t}\n\tconst server = http.createServer((req: any, res: any) => {\n\t  if (req.method === 'GET' && req.url === '/start') {\n\t    res.writeHead(200, {'Content-Type': 'application/json'});\n\t    res.write(JSON.stringify({message: 'Script ran'}));\n\t    res.end();\n", "    void runScripts(['Amsterdam'], 'react', false);\n\t  } else {\n\t    res.writeHead(404, {'Content-Type': 'text/plain'});\n\t    res.write('404 Not Found\\n');\n\t    res.end();\n\t  }\n\t});\n\tconst PORT = process.env.PORT || 6000;\n\tserver.listen(PORT, () => {\n\t  console.log(`Server listening on port ${PORT}`);\n", "});\n"]}
{"filename": "src/index.ts", "chunked_list": ["require('dotenv').config();\n\timport {scraper} from './modules/scraper';\n\timport {collectCompanies} from './modules/companies';\n\timport {cli} from './modules/cli';\n\texport async function runScripts() {\n\t  const userArgs = await cli();\n\t  if (userArgs) {\n\t    await collectCompanies();\n\t    await scraper(userArgs.locations, userArgs.keyword, userArgs.d);\n\t  }\n", "}\n\tvoid runScripts();\n"]}
{"filename": "src/modules/cli/index.ts", "chunked_list": ["import yargs from 'yargs';\n\timport {hideBin} from 'yargs/helpers';\n\texport type TCli = {\n\t  locations: string[];\n\t  keyword: string;\n\t  d: boolean;\n\t};\n\texport async function cli(): Promise<TCli | undefined> {\n\t  try {\n\t    const argv = await yargs(hideBin(process.argv))\n", "      .option('locations', {\n\t        type: 'array',\n\t        description: 'List of locations',\n\t        demandOption: true,\n\t        coerce: arg => (typeof arg === 'string' ? [arg] : arg),\n\t      })\n\t      .option('keyword', {\n\t        type: 'string',\n\t        description: 'Keyword for searching',\n\t        demandOption: true,\n", "        coerce: arg => arg,\n\t      })\n\t      .option('d', {\n\t        type: 'boolean',\n\t        description: 'Get Description or not? (default is False)',\n\t        default: false,\n\t      }).argv;\n\t    return {\n\t      locations: argv.locations,\n\t      keyword: argv.keyword,\n", "      d: argv.d,\n\t    } as TCli;\n\t  } catch (err) {\n\t    console.log(err);\n\t  }\n\t}\n"]}
{"filename": "src/modules/companies/siaExplains.ts", "chunked_list": ["import prisma from '../db';\n\timport {createDriver} from '../driver';\n\timport {By} from 'selenium-webdriver';\n\texport const siaExplains = async () => {\n\t  const driver = await createDriver();\n\t  try {\n\t    await driver.get('https://siaexplains.github.io/visa-sponsorship-companies/');\n\t    await driver.sleep(3000);\n\t    const parentElement = await driver.findElements(By.className('odd:bg-white'));\n\t    const companies: string[] = [];\n", "    for (const element of parentElement) {\n\t      const childElement = await element.findElement(By.css('td:first-child'));\n\t      const company = await childElement.getText();\n\t      companies.push(company.toLocaleLowerCase());\n\t    }\n\t    let newCompanies = 0;\n\t    for (const el of companies) {\n\t      const isExist = await prisma.companies.findUnique({\n\t        where: {\n\t          name: el,\n", "        },\n\t      });\n\t      if (!isExist) {\n\t        newCompanies = newCompanies + 1;\n\t        await prisma.companies.create({data: {name: el, source: 'siaexplains'}});\n\t      }\n\t    }\n\t    return {newCompanies, companies: companies.length};\n\t  } catch (err) {\n\t    console.log(err);\n", "  } finally {\n\t    await driver.quit();\n\t  }\n\t};\n"]}
{"filename": "src/modules/companies/relocateMe.ts", "chunked_list": ["import prisma from '../db';\n\timport {createDriver} from '../driver';\n\timport {By} from 'selenium-webdriver';\n\texport const relocateMe = async () => {\n\t  const driver = await createDriver();\n\t  try {\n\t    await driver.get('https://relocate.me/companies');\n\t    await driver.sleep(3000);\n\t    const parentElement = await driver.findElements(By.className('wwbc-companies__link'));\n\t    const companies: string[] = [];\n", "    for (const element of parentElement) {\n\t      const childElement = await element.findElement(By.css('span:first-child'));\n\t      const company = await childElement.getText();\n\t      companies.push(company.toLocaleLowerCase());\n\t    }\n\t    let newCompanies = 0;\n\t    for (const el of companies) {\n\t      const isExist = await prisma.companies.findUnique({\n\t        where: {\n\t          name: el,\n", "        },\n\t      });\n\t      if (!isExist) {\n\t        newCompanies = newCompanies + 1;\n\t        await prisma.companies.create({data: {name: el, source: 'relocate.me'}});\n\t      }\n\t    }\n\t    return {newCompanies, companies: companies.length};\n\t  } catch (err) {\n\t    console.log(err);\n", "  } finally {\n\t    await driver.quit();\n\t  }\n\t};\n"]}
{"filename": "src/modules/companies/index.ts", "chunked_list": ["import {relocateMe} from './relocateMe';\n\timport {siaExplains} from './siaExplains';\n\ttype companiesData = {\n\t  relocateCom: Record<string, number>;\n\t  newCompanies: number;\n\t  siaExplains: Record<string, number>;\n\t};\n\texport async function collectCompanies(): Promise<companiesData | undefined> {\n\t  try {\n\t    const companiesData: companiesData = {\n", "      newCompanies: 0,\n\t      relocateCom: {\n\t        companies: 0,\n\t      },\n\t      siaExplains: {\n\t        newCompanies: 0,\n\t        companies: 0,\n\t      },\n\t    };\n\t    const relocateCom = await relocateMe();\n", "    if (relocateCom) {\n\t      companiesData.relocateCom.companies = relocateCom.companies;\n\t      companiesData.newCompanies += relocateCom.newCompanies;\n\t    }\n\t    const siaExplainData = await siaExplains();\n\t    if (siaExplainData) {\n\t      companiesData.siaExplains.companies = siaExplainData.companies;\n\t      companiesData.newCompanies += siaExplainData.newCompanies;\n\t    }\n\t    return companiesData;\n", "  } catch (err) {\n\t    console.log(err);\n\t  }\n\t}\n"]}
{"filename": "src/modules/scraper/jobCollector.ts", "chunked_list": ["import {By, until} from 'selenium-webdriver';\n\timport {createDriver} from '../driver';\n\timport {elementGetter} from './elements';\n\timport {isExcludedByTitle} from './isExcludedByTitle';\n\timport {TJob} from '../../types';\n\texport async function jobCollector(locations: string[], keyword: string) {\n\t  const driver = await createDriver();\n\t  const jobs: TJob[] = [];\n\t  try {\n\t    for (const location of locations) {\n", "      const keywords = encodeURI(keyword);\n\t      await driver.get(\n\t        `https://www.linkedin.com/jobs/search?keywords=${keywords}&location=${location}&f_TPR=r86400&trk=public_jobs_jobs-search-bar_search-submit&position=1&pageNum=0`,\n\t      );\n\t      /* \n\t        **FOR Getting All Job Element**\n\t        const jobCount = await driver.findElement(By.className('results-context-header__job-count'))?.getText();\n\t        Math.ceil(+jobCount)\n\t        with Select on Show More Button!\n\t      */\n", "      for (let i = 0; i < 4; i++) {\n\t        // Scroll to the bottom of the page\n\t        await driver.executeScript('window.scrollTo(0, document.body.scrollHeight);');\n\t        // Wait for new content to load\n\t        await driver.wait(until.elementLocated(By.css('ul.jobs-search__results-list>li')));\n\t        // Wait for some additional time to allow the page to fully render\n\t        await driver.sleep(3000);\n\t      }\n\t      // Get job listings\n\t      console.log('before listing...');\n", "      const jobElements = await driver.findElements(By.css('ul.jobs-search__results-list>li'));\n\t      console.log(jobElements.length, `count of jobs for ${location}`);\n\t      for (const el of jobElements) {\n\t        const title = await elementGetter({el, selector: 'h3.base-search-card__title'});\n\t        const company = await elementGetter({\n\t          el,\n\t          selector: '[data-tracking-control-name=\"public_jobs_jserp-result_job-search-card-subtitle\"]',\n\t        });\n\t        const location = await elementGetter({el, selector: 'span.job-search-card__location'});\n\t        const time = await elementGetter({el, selector: 'time'});\n", "        const link = await elementGetter({el, selector: 'a.base-card__full-link', method: 'attribute', attr: 'href'});\n\t        if (isExcludedByTitle(title.toLocaleLowerCase()) && link.length > 1) {\n\t          jobs.push({\n\t            title: title.toLocaleLowerCase(),\n\t            company,\n\t            location,\n\t            time,\n\t            link,\n\t            visa: false,\n\t            description: '',\n", "            source: 'Linkedin',\n\t          });\n\t        } else {\n\t          console.log('filtered by title:', title);\n\t        }\n\t      }\n\t    }\n\t    return jobs;\n\t  } catch (err) {\n\t    console.log(err);\n", "  } finally {\n\t    // Close the browser\n\t    await driver?.quit();\n\t  }\n\t}\n"]}
{"filename": "src/modules/scraper/filterKeywords.ts", "chunked_list": ["import {TJob} from 'types';\n\timport {createDriver} from '../driver';\n\timport {By} from 'selenium-webdriver';\n\timport prisma from '../db';\n\timport {cleanedText} from '../../helper/cleanedText';\n\timport {jobDescriptionClicker} from './elements';\n\texport async function filterKeyword(jobs: TJob[]): Promise<TJob[]> {\n\t  const driver = await createDriver();\n\t  const jobItems = jobs.filter(job => job.link.length > 1);\n\t  try {\n", "    const filteredJobs: TJob[] = [];\n\t    for (const job of jobItems) {\n\t      console.log('finding keywords ...', job.link);\n\t      await driver.get(job.link);\n\t      await jobDescriptionClicker(driver);\n\t      await driver.sleep(3000);\n\t      const element = await driver.findElement(By.className('core-section-container'));\n\t      const text = await element.getText();\n\t      await driver.sleep(3000);\n\t      const companyName = text.toLocaleLowerCase();\n", "      const haveVisa =\n\t        (await prisma.companies.findUnique({where: {name: companyName}})) ||\n\t        text.toLocaleLowerCase().includes('visa sponsorship');\n\t      job.visa = !!haveVisa;\n\t      job.description = cleanedText(text).substring(0, 300) + '...';\n\t      filteredJobs.push(job);\n\t      const handles = await driver.getAllWindowHandles();\n\t      for (let i = 1; i < handles.length; i++) {\n\t        await driver.switchTo().window(handles[i]);\n\t        await driver.close();\n", "      }\n\t      await driver.switchTo().window(handles[0]);\n\t    }\n\t    return filteredJobs;\n\t  } catch (err) {\n\t    console.log(err);\n\t    await driver.quit();\n\t    throw new Error('filtered broken');\n\t  } finally {\n\t    await driver?.quit();\n", "  }\n\t}\n"]}
{"filename": "src/modules/scraper/parsPath.ts", "chunked_list": ["const url = require('url');\n\texport function parsPath(jobUrl: string) {\n\t  const pathName = validateURL(jobUrl) ? url?.parse(jobUrl)?.pathname : '';\n\t  return pathName.split('/').pop();\n\t}\n\texport function validateURL(url: string) {\n\t  let valid = true;\n\t  try {\n\t    new URL(url);\n\t  } catch (error) {\n", "    valid = false;\n\t  } finally {\n\t    return valid;\n\t  }\n\t}\n"]}
{"filename": "src/modules/scraper/isExcludedByTitle.ts", "chunked_list": ["export function isExcludedByTitle(title: string): boolean {\n\t  // const keywords = ['junior', 'no visa sponsorship', 'no visasponsorship', 'no visa', 'entry level', 'remote'];\n\t  const keywords = (process.env.TITLE_FILTER_KEYWORDS as string).split(',').map(el => el.trim());\n\t  const forceKeyword = (process.env.TITLE_MUST_KEYWORD as string).split(',').map(el => el.trim());\n\t  return !keywords.some(keyword => title.includes(keyword)) && forceKeyword.some(keyword => title.includes(keyword));\n\t}\n"]}
{"filename": "src/modules/scraper/index.ts", "chunked_list": ["import {jobCollector} from './jobCollector';\n\timport {filterKeyword} from './filterKeywords';\n\timport {checkAndSaveJobs} from './saveJobs';\n\timport TelegramBot from 'node-telegram-bot-api';\n\texport const scraper = async (\n\t  locations: string[],\n\t  keyword: string,\n\t  isCheckDescription?: boolean,\n\t  bot?: TelegramBot,\n\t  chatId?: number,\n", ") => {\n\t  try {\n\t    const jobs = (await jobCollector(locations, keyword)) ?? [];\n\t    const filteredJobs = isCheckDescription ? await filterKeyword(jobs) : jobs;\n\t    await checkAndSaveJobs(filteredJobs, bot, chatId);\n\t  } catch (err) {\n\t    console.log(err);\n\t  } finally {\n\t    console.log('job done!');\n\t  }\n", "};\n"]}
{"filename": "src/modules/scraper/saveJobs.ts", "chunked_list": ["import {TJob} from 'types';\n\timport {parsPath} from './parsPath';\n\timport prisma from '../db';\n\timport {sendJobToChannel} from '../telegram';\n\timport {cleanedText} from '../../helper/cleanedText';\n\timport TelegramBot from 'node-telegram-bot-api';\n\texport async function checkAndSaveJobs(jobs: TJob[], bot?: TelegramBot, chatId?: number) {\n\t  let count = 0;\n\t  try {\n\t    for (const job of jobs) {\n", "      const job_name: string = parsPath(job?.link);\n\t      const existingJob = await prisma.job.findUnique({\n\t        where: {\n\t          job_name: job_name,\n\t        },\n\t      });\n\t      if (!existingJob) {\n\t        count += 1;\n\t        const response = await prisma.job.create({\n\t          data: {\n", "            title: job.title,\n\t            company: job.company,\n\t            location: job.location,\n\t            time: job.time,\n\t            link: job.link,\n\t            description: cleanedText(job.description as string),\n\t            job_name: job_name,\n\t          },\n\t        });\n\t        await sendJobToChannel(response, count, jobs.length);\n", "        console.log('Jobs saved to database successfully!', `${count}/${jobs.length}`);\n\t      }\n\t    }\n\t  } catch (e: any) {\n\t    console.error(`Error saving jobs to database: ${e.message}`);\n\t  } finally {\n\t    if(bot && chatId) {\n\t      bot.sendMessage(chatId, `${jobs.length} jobs found by scraping üòà`);\n\t      bot.sendMessage(chatId, `${count} jobs are new üò¨`);\n\t    }\n", "    await prisma.$disconnect();\n\t  }\n\t}\n"]}
{"filename": "src/modules/scraper/getDescription.ts", "chunked_list": ["import {cleanedText} from '../../helper/cleanedText';\n\timport {createDriver} from '../driver';\n\timport {jobDescriptionClicker} from './elements';\n\timport {By} from 'selenium-webdriver';\n\timport prisma from '../db';\n\texport async function getDescription(id: number) {\n\t  try {\n\t    const job = await prisma.job.findUnique({\n\t      where: {\n\t        id,\n", "      },\n\t    });\n\t    if (!job) {\n\t      console.log(`Job ${id} is not exist in db`);\n\t      return null;\n\t    }\n\t    if (job.description) {\n\t      return job.description;\n\t    }\n\t    const description = await scrapDescription(job.link);\n", "    const updatedJob = await prisma.job.update({\n\t      where: {id},\n\t      data: {\n\t        description,\n\t      },\n\t    });\n\t    return updatedJob?.description;\n\t  } catch (err) {\n\t    console.log(err);\n\t  }\n", "}\n\texport async function scrapDescription(link: string) {\n\t  const driver = await createDriver();\n\t  try {\n\t    await driver.get(link);\n\t    await jobDescriptionClicker(driver);\n\t    await driver.sleep(5000);\n\t    const element = await driver.findElement(By.className('core-section-container'));\n\t    const text = await element.getText();\n\t    const editedText = cleanedText(text).substring(0, 3500);\n", "    return editedText;\n\t  } catch (err) {\n\t    console.log(err);\n\t  } finally {\n\t    driver?.quit();\n\t  }\n\t}\n"]}
{"filename": "src/modules/scraper/elements.ts", "chunked_list": ["import {By, WebDriver, WebElement} from 'selenium-webdriver';\n\ttype TElementGetter = {\n\t  el: WebElement;\n\t  selector: string;\n\t  method?: 'text' | 'attribute';\n\t  attr?: string;\n\t};\n\texport async function elementGetter({el, selector, method = 'text', attr = 'href'}: TElementGetter) {\n\t  let name = '';\n\t  try {\n", "    const element = await el.findElement(By.css(selector));\n\t    name = method == 'text' ? await element.getText() : await element.getAttribute(attr);\n\t  } catch {\n\t    name = '';\n\t  } finally {\n\t    return name;\n\t  }\n\t}\n\texport async function jobDescriptionClicker(el: WebDriver) {\n\t  try {\n", "    const showMoreBtn = await el.findElement(By.className('show-more-less-html__button--more'));\n\t    await showMoreBtn?.click();\n\t  }\n\t  catch (err){\n\t    console.log(\"element didn't had description\", err)\n\t  }\n\t}\n"]}
{"filename": "src/modules/openAI/index.ts", "chunked_list": ["import {sendMessageToBot} from '../telegram';\n\timport {Configuration, OpenAIApi} from 'openai';\n\texport async function getCoverLetter(jobDescription: string, chatId: number, info: string) {\n\t  const configuration = new Configuration({\n\t    apiKey: process.env.OPENAI_API_KEY,\n\t  });\n\t  const openai = new OpenAIApi(configuration);\n\t  try {\n\t    const res = await openai.createCompletion(\n\t      {\n", "        model: 'text-davinci-003',\n\t        prompt: `${info} write cover letter for below job description:\\n ${jobDescription}`,\n\t        max_tokens: 1000,\n\t        temperature: 0.5,\n\t        stream: true,\n\t      },\n\t      {responseType: 'stream'},\n\t    );\n\t    console.log(jobDescription, 'JOB Description');\n\t    let response = '';\n", "    // @ts-ignore\n\t    res.data.on('data', (data: any) => {\n\t      const lines = data\n\t        .toString()\n\t        .split('\\n')\n\t        .filter((line: string) => line.trim() !== '');\n\t      for (const line of lines) {\n\t        const message = line.replace(/^data: /, '');\n\t        if (message.trim() === '[DONE]') {\n\t          console.log(response.trim(), 'generated cover letter finished!');\n", "          sendMessageToBot(response, chatId);\n\t          return; // Stream finished\n\t        }\n\t        try {\n\t          const parsed = JSON.parse(message);\n\t          response += parsed.choices[0].text;\n\t        } catch (error) {\n\t          console.error('Could not JSON parse stream message', message, error);\n\t        }\n\t      }\n", "    });\n\t  } catch (error) {\n\t    console.log(error);\n\t  }\n\t}\n"]}
{"filename": "src/modules/db/index.ts", "chunked_list": ["import { PrismaClient } from 'prisma/prisma-client'\n\tconst prisma = new PrismaClient();\n\t(async function prismaConnection() {\n\t  try {\n\t    await prisma.$connect();\n\t    console.log('Connected to database successfully!');\n\t  } catch (e: any) {\n\t    console.error(`Error connecting to database: ${e.message}`);\n\t  } finally {\n\t    await prisma.$disconnect();\n", "  }\n\t})();\n\texport default prisma;\n"]}
{"filename": "src/modules/telegram/index.ts", "chunked_list": ["require('dotenv').config();\n\timport {companyLogoMapper} from '../../helper/countryMapper';\n\timport TelegramBot from 'node-telegram-bot-api';\n\timport {Job} from 'prisma/prisma-client';\n\timport {getDescription} from '../scraper/getDescription';\n\timport {getCoverLetter} from '../openAI';\n\timport prisma from '../db';\n\timport {scraper} from '../scraper';\n\timport {collectCompanies} from '../companies';\n\tconst botToken = `${process.env.TELEGRAM_BOT_TOKEN}`;\n", "const channelName = `${process.env.TELEGRAM_CHANNEL_NAME}`;\n\tconst bot = new TelegramBot(botToken, {polling: true});\n\tlet isActionRunning = false;\n\texport const sendJobToChannel = async (job: Job, count: number, total: number) => {\n\t  try {\n\t    const convertedDate = new Date(job.created_date!);\n\t    const chat = await bot.getChat(channelName);\n\t    const message = `<b>üåü${String(job.title).toLocaleUpperCase()}</b>\\n\\nCompany: ${\n\t      job.company\n\t    }\\n\\nLocation: ${companyLogoMapper(job.location as string)}\\n\\nüìÜ Date: <i>${\n", "      convertedDate.toLocaleDateString() + ' ' + convertedDate.toLocaleTimeString()\n\t    }</i>\\n${job.description ? `\\nüîπDescription: <i>${job.description}</i>\\n\\n` : ''}\\nSource:${\n\t      job.source === 'linkedin' ? '<strong>LinkedIn</strong>' : ''\n\t    }\\n${job.visa ? '<u>üåê#visa</u>' : ''}\\n üÜî <code>${job.id}</code>`;\n\t    const keyboard = {\n\t      inline_keyboard: [\n\t        [\n\t          {text: 'View Job & Apply', url: job.link},\n\t          {\n\t            text: 'Generate cover letter',\n", "            url: `https://t.me/${process.env.TELEGRAM_BOT_NAME}?start=cover-letter-${job.id}`,\n\t          },\n\t        ],\n\t      ],\n\t    };\n\t    setTimeout(async () => {\n\t      await bot.sendMessage(chat.id, message, {reply_markup: keyboard, parse_mode: 'HTML', disable_notification: true});\n\t      console.log('sent to telegram', `${count}/${total} (TOTAL(not filtered))`);\n\t    }, count * 5000);\n\t  } catch (err) {\n", "    console.log(err);\n\t  }\n\t};\n\texport const generateCoverLetter = () => {\n\t  bot.onText(/\\/coverletter (.+)/, async (msg, match: RegExpExecArray | null) => {\n\t    if (isActionRunning) {\n\t      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... üé≤');\n\t      return;\n\t    }\n\t    isActionRunning = true;\n", "    if (!match) {\n\t      bot.sendMessage(msg.chat.id, 'Invalid command format. Please use the format: /coverletter <job id>');\n\t      return;\n\t    }\n\t    console.log(`Request for cover letter by job id ${match?.[1]}`);\n\t    const response = await getDescription(+match[1]);\n\t    if (!response) {\n\t      bot.sendMessage(msg.chat.id, 'job description is not exist' + response);\n\t      return;\n\t    }\n", "    try {\n\t      const information = await prisma.information.findFirst();\n\t      bot.sendMessage(msg.chat.id, information ? 'loading...' : 'information is not found');\n\t      if (information) await getCoverLetter(response, msg.chat.id, information?.description);\n\t    } catch (error) {\n\t      console.error(error);\n\t      bot.sendMessage(msg.chat.id, 'Failed to generate cover letter.');\n\t    } finally {\n\t      isActionRunning = false;\n\t    }\n", "  });\n\t};\n\texport const getUserInformation = () => {\n\t  bot.onText(/\\/information (.+)/, async (msg, match: RegExpExecArray | null) => {\n\t    if (isActionRunning) {\n\t      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... üé≤');\n\t      return;\n\t    }\n\t    isActionRunning = true;\n\t    if (!match || !match[1]) {\n", "      bot.sendMessage(msg.chat.id, 'Invalid command format. Please use the format: /information <user information>');\n\t      return;\n\t    }\n\t    try {\n\t      const isInformationExist = await prisma.information.findFirst();\n\t      if (!!isInformationExist) {\n\t        throw new Error('you have information please remove or edit!');\n\t      }\n\t      const information = await prisma.information.create({data: {description: match[1]}});\n\t      if (information) {\n", "        bot.sendMessage(msg.chat.id, 'Your data saved...');\n\t        return;\n\t      }\n\t      throw new Error(\"Your information Can't saved please check your message!\");\n\t    } catch (error) {\n\t      bot.sendMessage(msg.chat.id, (error as Error)?.message || 'failed to save data please try few minutes later!');\n\t    } finally {\n\t      isActionRunning = false;\n\t    }\n\t  });\n", "};\n\texport const updateInformation = () => {\n\t  bot.onText(/\\/information_update (.+)/, async (msg, match: RegExpExecArray | null) => {\n\t    if (isActionRunning) {\n\t      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... üé≤');\n\t      return;\n\t    }\n\t    isActionRunning = true;\n\t    if (!match || !match[1]) {\n\t      bot.sendMessage(msg.chat.id, 'Invalid command format. Please use the format: /information <user information>');\n", "      return;\n\t    }\n\t    try {\n\t      const information = await prisma.information.findFirst();\n\t      if (information) {\n\t        const response = await prisma.information.update({\n\t          data: {description: match[1]},\n\t          where: {id: information.id},\n\t        });\n\t        if (response) {\n", "          bot.sendMessage(msg.chat.id, 'Your data updated successfully...');\n\t        }\n\t        return;\n\t      }\n\t      bot.sendMessage(msg.chat.id, 'You must first add information with /information <message>');\n\t    } catch (error) {\n\t      bot.sendMessage(msg.chat.id, 'failed to save data please try few minutes later!');\n\t    } finally {\n\t      isActionRunning = false;\n\t    }\n", "  });\n\t};\n\texport const sendMessageToBot = async (message: string, chatId: number) => {\n\t  try {\n\t    bot.sendMessage(chatId, message);\n\t  } catch (err) {\n\t    console.log(err);\n\t  }\n\t};\n\texport const startScarpData = () => {\n", "  bot.onText(/\\/start (.+)/, async (msg, match: RegExpExecArray | null) => {\n\t    if (isActionRunning) {\n\t      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... üé≤');\n\t      return;\n\t    }\n\t    isActionRunning = true;\n\t    if (!match || !match[1]) {\n\t      bot.sendMessage(msg.chat.id, 'Your arguments is not valid');\n\t      return;\n\t    }\n", "    if (match[0].includes('cover-letter')) {\n\t      const jobId = match[0].split('-')?.[2];\n\t      const response = await getDescription(+jobId);\n\t      if (!response) {\n\t        bot.sendMessage(msg.chat.id, 'job description is not exist' + response);\n\t        return;\n\t      }\n\t      try {\n\t        const information = await prisma.information.findFirst();\n\t        bot.sendMessage(msg.chat.id, information ? 'loading...' : 'information is not found');\n", "        if (information) await getCoverLetter(response, msg.chat.id, information?.description);\n\t      } catch (error) {\n\t        console.error(error);\n\t        bot.sendMessage(msg.chat.id, 'Failed to generate cover letter.');\n\t      } finally {\n\t        isActionRunning = false;\n\t      }\n\t      return;\n\t    }\n\t    const args = match?.[1]?.split('-');\n", "    const locations = args?.[0]?.trim()?.split(',');\n\t    const keyword = args?.[1]?.trim();\n\t    try {\n\t      if (locations && keyword) {\n\t        bot.sendMessage(msg.chat.id, 'Your script is running üé∞');\n\t        await scraper(locations, keyword, false, bot, msg.chat.id);\n\t      }\n\t    } catch (err) {\n\t      console.log(err);\n\t      bot.sendMessage(msg.chat.id, 'There are some problem on running scraper!');\n", "    } finally {\n\t      isActionRunning = false;\n\t    }\n\t  });\n\t};\n\texport const gatheringCompanies = () => {\n\t  bot.onText(/\\/companies/, async msg => {\n\t    try {\n\t      if (isActionRunning) {\n\t        bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... üé≤');\n", "        return;\n\t      }\n\t      bot.sendMessage(msg.chat.id, 'gathering data please wait... üåò');\n\t      const data = await collectCompanies();\n\t      if (!data) {\n\t        throw new Error('cant find data!');\n\t      }\n\t      const {relocateCom, siaExplains, newCompanies} = data;\n\t      bot.sendMessage(\n\t        msg.chat.id,\n", "        `relocateMe:${relocateCom.companies} companies found \\n\n\t        siaExplains: ${siaExplains.companies} \\n\n\t        ${newCompanies} of them are new!üåù\n\t        `,\n\t      );\n\t    } catch (err) {\n\t      bot.sendMessage(msg.chat.id, (err as Error)?.message || 'failed to find data please try few minutes later!');\n\t    } finally {\n\t      isActionRunning = false;\n\t    }\n", "  });\n\t};\n\texport const getJD = () => {\n\t  bot.onText(/\\/jd (.+)/, async (msg, match: RegExpExecArray | null) => {\n\t    if (isActionRunning) {\n\t      bot.sendMessage(msg.chat.id, 'Sorry, a previous action is still running. Please wait... üé≤');\n\t      return;\n\t    }\n\t    isActionRunning = true;\n\t    if (!match || !match[0]) {\n", "      bot.sendMessage(msg.chat.id, 'Invalid command format. Please use the format: /jd <jobId>');\n\t      return;\n\t    }\n\t    try {\n\t      const jobId = +match[1];\n\t      const jobDescription = await prisma.job.findUnique({\n\t        where: {\n\t          id: jobId,\n\t        },\n\t      });\n", "      if (jobDescription?.description) {\n\t        const code = `${jobDescription.description}`;\n\t        await bot.sendMessage(msg.chat.id, code);\n\t        return;\n\t      }\n\t      const scrapJd = await getDescription(jobId);\n\t      bot.sendMessage(msg.chat.id, scrapJd ? String(scrapJd) : 'nothing found!');\n\t    } catch (error) {\n\t      bot.sendMessage(msg.chat.id, 'failed to save data please try few minutes later!');\n\t    } finally {\n", "      isActionRunning = false;\n\t    }\n\t  });\n\t};\n"]}
{"filename": "src/modules/driver/index.ts", "chunked_list": ["import {Builder} from 'selenium-webdriver';\n\timport firefox from 'selenium-webdriver/firefox';\n\texport async function createDriver() {\n\t  const options = new firefox.Options();\n\t  options.headless();\n\t  options.addArguments('--ignore-ssl-errors=yes');\n\t  options.addArguments('--ignore-certificate-errors');\n\t  return new Builder().forBrowser('firefox').setFirefoxOptions(options).build();\n\t}\n"]}
{"filename": "src/helper/countryMapper.ts", "chunked_list": ["import {capitalizedString} from './delay';\n\texport function companyLogoMapper(location: string) {\n\t  const countryLogo = {\n\t    netherlands: 'üá≥üá±',\n\t    'united kingdom': 'üá¨üáß',\n\t    finland: 'üá´üáÆ',\n\t    sweden: 'üá∏üá™',\n\t    france: 'üá´üá∑',\n\t    denmark: 'üá¶üáπ',\n\t  };\n", "  const country = location.toLocaleLowerCase().split(',');\n\t  const countryName = country[country.length - 1];\n\t  const logo = countryLogo[countryName.trim() as keyof typeof countryLogo] ?? 'üè≥Ô∏è';\n\t  return `${logo} ${capitalizedString(countryName.trim())}`;\n\t}\n"]}
{"filename": "src/helper/delay.ts", "chunked_list": ["export const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\texport function capitalizedString(str: string){\n\t    return str.charAt(0).toUpperCase() + str.slice(1)\n\t}"]}
{"filename": "src/helper/cleanedText.ts", "chunked_list": ["export function cleanedText(text: string) {\n\t  return text.replace(/(\\r\\n|\\n|\\r)/gm, '');\n\t}\n"]}
