{"filename": "src/extension.ts", "chunked_list": ["import * as vscode from \"vscode\";\n\timport * as fs from \"fs\";\n\timport path from \"path\";\n\timport {\n\t  createOZAccount,\n\t  deleteAccount,\n\t  deployAccount,\n\t  selectDeployedAccount,\n\t  selectNotDeployedAccount,\n\t} from \"./config/account\";\n", "import {\n\t  declareContract,\n\t  deployContract,\n\t  executeContractFunction,\n\t  executeContractFunctionFromTreeView,\n\t  getContractInfo,\n\t  isCairo1Contract,\n\t  loadAllCompiledContract,\n\t  selectCompiledContract,\n\t  setContract,\n", "} from \"./config/contract\";\n\timport { updateSelectedNetwork } from \"./config/network\";\n\timport { logger } from \"./lib\";\n\timport { ContractTreeDataProvider } from \"./treeView/ContractTreeView/ContractTreeDataProvider\";\n\timport { editContractAddress, refreshContract } from \"./treeView/ContractTreeView/function\";\n\timport { Contract as ContractTreeItem } from \"./treeView/ContractTreeView/ContractTreeDataProvider\";\n\timport { AbiTreeDataProvider } from \"./treeView/ABITreeView/AbiTreeDataProvider\";\n\timport { editInput } from \"./treeView/ABITreeView/functions\";\n\timport { AccountTreeDataProvider } from \"./treeView/AccountTreeView/AccountTreeDataProvider\";\n\texport function activate(context: vscode.ExtensionContext) {\n", "  if (vscode.workspace.workspaceFolders === undefined) {\n\t    logger.error(\"Error: Please open your solidity project to vscode\");\n\t    return;\n\t  }\n\t  const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t  const watcher = vscode.workspace.createFileSystemWatcher(`${path_}/starkode/**`);\n\t  watcher.onDidChange((event: vscode.Uri) => {\n\t    const contractName: string | undefined = context.workspaceState.get(\"selectedContract\");\n\t    if (contractName === undefined) {\n\t      abiTreeView.message = \"Select a contract and its ABI functions will appear here.\";\n", "    } else {\n\t      abiTreeView.message = undefined;\n\t      const contractInfo = getContractInfo(path_, contractName);\n\t      abiTreeView.description = `${contractName.slice(0, -5)} @ ${contractInfo.address}`;\n\t    }\n\t    abiTreeDataProvider.refresh();\n\t  });\n\t  // Contract Tree View\n\t  const contractTreeDataProvider = new ContractTreeDataProvider(\n\t    vscode.workspace.workspaceFolders?.[0].uri.fsPath\n", "  );\n\t  let contractTreeView = vscode.window.createTreeView(\"starkode.contracts\", {\n\t    treeDataProvider: contractTreeDataProvider,\n\t  });\n\t  // if contract tree view is empty\n\t  const contracts = loadAllCompiledContract();\n\t  if (contracts === undefined || contracts.length === 0) {\n\t    contractTreeView.message = \"No contract found. Please compile your contract.\";\n\t  }\n\t  contractTreeView.onDidChangeSelection(event => {\n", "    const selectedNodes = event.selection;\n\t    if (selectedNodes && selectedNodes.length > 0) {\n\t      console.log('Selected nodes:', selectedNodes[0].label);\n\t    }\n\t  });\n\t  // Account Tree View\n\t  const accountTreeDataProvider = new AccountTreeDataProvider(\n\t    context\n\t  );\n\t  const accountTreeView = vscode.window.createTreeView(\"starkode.account\", {\n", "    treeDataProvider: accountTreeDataProvider,\n\t  });\n\t  const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n\t  const selectedAccount: string | undefined = context.workspaceState.get(\"account\") as string;\n\t  accountTreeView.message = selectedAccount ? `Account : ${selectedAccount.slice(0, 5) + \"...\" + selectedAccount.slice(-5)} | ${selectedNetwork}` : \"Select a deployed account , or create an account and deploy it\";\n\t  // ABI Tree View\n\t  const abiTreeDataProvider = new AbiTreeDataProvider(\n\t    context\n\t  );\n\t  const abiTreeView = vscode.window.createTreeView(\"starkode.abis\", {\n", "    treeDataProvider: abiTreeDataProvider,\n\t  });\n\t  const contractName: string | undefined = context.workspaceState.get(\"selectedContract\");\n\t  if (!contractName || contractName === undefined) {\n\t    abiTreeView.message = \"Select a contract and its ABI functions will appear here.\";\n\t  }\n\t  else {\n\t    const contractInfo = getContractInfo(path_, contractName);\n\t    if (contractInfo !== undefined) {\n\t      abiTreeView.description = `${contractName.slice(0, -5)} @ ${contractInfo.address}`;\n", "    } else {\n\t      abiTreeView.message = \"Select a contract and its ABI functions will appear here.\";\n\t    }\n\t  }\n\t  context.subscriptions.push(\n\t    vscode.commands.registerCommand(\"starkode.activate\", () => {\n\t      try {\n\t        if (!fs.existsSync(path.join(path_, \"starkode\"))) {\n\t          fs.mkdirSync(path.join(path_, \"starkode\"));\n\t        }\n", "        vscode.window.showInformationMessage(\"Starkode activated.\");\n\t      } catch (error) {\n\t        console.log(error);\n\t      }\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.refreshContracts\", async (node: ContractTreeItem) => {\n\t      contractTreeView = await refreshContract(node, contractTreeDataProvider);\n\t      contractTreeView.message = undefined;\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.useContract\", async (node: ContractTreeItem) => {\n", "      setContract(context, node.label);\n\t      abiTreeView.message = undefined;\n\t      const contractInfo = getContractInfo(path_, `${node.label}.json`);\n\t      if (contractInfo !== undefined) {\n\t        abiTreeView.description = `${node.label} @ ${contractInfo.address}`;\n\t      }\n\t      abiTreeDataProvider.refresh();\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.useAccount\", async (node: any) => {\n\t      console.log(node);\n", "      if (node.context === \"deployedAccount\") {\n\t        void context.workspaceState.update(\"account\", node.account.accountAddress);\n\t        logger.log(`${node.account.accountAddress} selected`);\n\t        const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n\t        const selectedAccount = context.workspaceState.get(\"account\") as string;\n\t        if (selectedAccount !== undefined) {\n\t          accountTreeView.message = `Account : ${selectedAccount.slice(0, 5) + \"...\" + selectedAccount.slice(-5)} | ${selectedNetwork}`;\n\t        }\n\t        abiTreeDataProvider.refresh();\n\t      } else {\n", "        vscode.window.showErrorMessage(\"Please deploy the account first.\");\n\t      }\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.createAccountTreeView\", async () => {\n\t      createOZAccount(context);\n\t      accountTreeDataProvider.refresh();\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.selectNetwork\", async () => {\n\t      await updateSelectedNetwork(context, accountTreeView, accountTreeDataProvider);\n\t    }),\n", "    vscode.commands.registerCommand(\"starkode.deployAccountTreeView\", async (node: any) => {\n\t      void context.workspaceState.update(\"undeployedAccount\", node.account.accountAddress);\n\t      logger.log(`${node.account.accountAddress} selected`);\n\t      await deployAccount(context, accountTreeDataProvider);\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.copyAccountAddress\", async (node: any) => {\n\t      vscode.env.clipboard.writeText(node.account.accountAddress);\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.deleteAccount\", async (node: any) => {\n\t      await deleteAccount(context, node);\n", "      accountTreeDataProvider.refresh();\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.editContractAddress\", async (node: ContractTreeItem) => {\n\t      await editContractAddress(node, context);\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.editInput\", async (node: any) => {\n\t      const selectedContract: string = context.workspaceState.get(\n\t        \"selectedContract\"\n\t      ) as string;\n\t      await editInput(node, abiTreeDataProvider, selectedContract);\n", "    }),\n\t    vscode.commands.registerCommand(\"starkode.deploycontract\", async (node: any) => {\n\t      const selectedContract: string = context.workspaceState.get(\n\t        \"selectedContract\"\n\t      ) as string;\n\t      if (selectedContract === undefined) {\n\t        logger.log(\"No Contract selected\");\n\t        return;\n\t      }\n\t      if (selectedContract.slice(0, -5) !== node.label) {\n", "        logger.log(\"Please select the contract first.\");\n\t      } else {\n\t        if (isCairo1Contract(selectedContract)) {\n\t          await vscode.commands.executeCommand(\"starkode.declareContract\");\n\t        } else {\n\t          await vscode.commands.executeCommand(\"starkode.deployContract\");\n\t        }\n\t      }\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.selectnetwork\", async () => {\n", "      await updateSelectedNetwork(context, accountTreeView, accountTreeDataProvider);\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.createaccount\", async () => {\n\t      createOZAccount(context);\n\t      contractTreeDataProvider.refresh();\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.unDeployedAccount\", async () => {\n\t      selectNotDeployedAccount(context);\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.declareContract\", async () => {\n", "      await declareContract(context);\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.deployaccount\", async () => {\n\t      await deployAccount(context, accountTreeDataProvider);\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.selectaccount\", async () => {\n\t      await selectDeployedAccount(context);\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.selectContract\", async () => {\n\t      selectCompiledContract(context);\n", "    }),\n\t    vscode.commands.registerCommand(\"starkode.deployContract\", async () => {\n\t      await deployContract(context);\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.callFunction\", async () => {\n\t      await executeContractFunction(context);\n\t    }),\n\t    vscode.commands.registerCommand(\"starkode.callContract\", async (node: any) => {\n\t      await executeContractFunctionFromTreeView(context, node.abi);\n\t    })\n", "  );\n\t}\n"]}
{"filename": "src/treeView/ABITreeView/functions.ts", "chunked_list": ["import * as vscode from 'vscode';\n\timport { Abi } from './AbiTreeItem';\n\timport { logger } from '../../lib';\n\timport path from 'path';\n\tasync function search(filePath: string, searchString: string, startLine = 0) {\n\t    const document = await vscode.workspace.openTextDocument(filePath);\n\t    const text = document.getText();\n\t    const start = text.indexOf(searchString, document.offsetAt(new vscode.Position(startLine, 0)));\n\t    const startPosition = document.positionAt(start);\n\t    return startPosition;\n", "}\n\texport const editInput = async (input: Abi, abiTreeDataProvider: any, fileName: string) => {\n\t    let filePath = \"\";\n\t    if (vscode.workspace.workspaceFolders === undefined) {\n\t        logger.error(\"Error: Please open your solidity project to vscode\");\n\t        return [];\n\t    }\n\t    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t    const file = fileName.substring(0, fileName.length - 5);\n\t    filePath = path.join(path_, \"starkode\", file, `${file}_abi.json`);\n", "    const document = await vscode.workspace.openTextDocument(filePath);\n\t    const lineNumber = await search(filePath, `\"name\": \"${input.parent?.label}\"`);\n\t    const line = await search(filePath, `\"name\": \"${input.abi.name}\"`, lineNumber.line);\n\t    const cursorPosition = new vscode.Position(line.line + 2, line.character + 10);\n\t    const editor = await vscode.window.showTextDocument(document);\n\t    editor.selection = new vscode.Selection(cursorPosition, cursorPosition);\n\t    editor.revealRange(new vscode.Range(cursorPosition, cursorPosition));\n\t    abiTreeDataProvider.refresh(input);\n\t};"]}
{"filename": "src/treeView/ABITreeView/AbiTreeItem.ts", "chunked_list": ["import { TreeItem, TreeItemCollapsibleState, ThemeIcon } from 'vscode';\n\texport class Abi extends TreeItem {\n\t  public value: any;\n\t  constructor(\n\t    public readonly label: string,\n\t    public readonly abi: any,\n\t    contextValue: string,\n\t    public parent: Abi | null,\n\t    public children: Abi[],\n\t    public readonly collapsibleState: TreeItemCollapsibleState\n", "  ) {\n\t    super(label, collapsibleState);\n\t    this.contextValue = contextValue;\n\t    if (abi.type === \"function\") {\n\t      this.iconPath = new ThemeIcon(\"symbol-method\");\n\t    } else {\n\t      this.description = abi.type + \" : \" + abi.value;\n\t      this.iconPath = new ThemeIcon(\"symbol-parameter\");\n\t    }\n\t  }\n", "}"]}
{"filename": "src/treeView/ABITreeView/AbiTreeDataProvider.ts", "chunked_list": ["import vscode, { TreeDataProvider, TreeItem, TreeItemCollapsibleState, EventEmitter, Event } from 'vscode';\n\timport { Abi } from './AbiTreeItem';\n\timport { ABIFragment } from '../../types';\n\timport { getContractABI } from '../../config/contract';\n\timport { logger } from '../../lib';\n\texport class AbiTreeDataProvider implements TreeDataProvider<Abi> {\n\t  context: vscode.ExtensionContext;\n\t  constructor(context: vscode.ExtensionContext) {\n\t    this.context = context;\n\t  }\n", "  getTreeItem(element: Abi): TreeItem {\n\t    return element;\n\t  }\n\t  async getChildren(element?: Abi): Promise<Abi[] | undefined> {\n\t    const leaves: Abi[] = [];\n\t    if (vscode.workspace.workspaceFolders === undefined) {\n\t      logger.error(\"Error: Please open your solidity project to vscode\");\n\t      return undefined;\n\t    }\n\t    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n", "    const selectedContract: string | undefined = this.context.workspaceState.get(\"selectedContract\") as string;\n\t    const data = getContractABI(path_,selectedContract);\n\t    const inputFunction: Array<ABIFragment> | undefined = selectedContract !== undefined ? data === undefined ? undefined : data.abi :\n\t      [];\n\t    if (inputFunction === undefined) {\n\t      return undefined;\n\t    } \n\t    else {\n\t      if (!element) {\n\t        for (const entry of inputFunction) {\n", "          if (entry.type === \"function\") {\n\t            const colapse = (entry.inputs && entry.inputs.length > 0)\n\t              ? TreeItemCollapsibleState.Expanded\n\t              : TreeItemCollapsibleState.None;\n\t            leaves.push(\n\t              new Abi(\n\t                entry.name,\n\t                entry,\n\t                entry.stateMutability === \"view\" || entry.stateMutability === \"external\" ? \"abiReadFunction\" : \"abiFunction\",\n\t                null,\n", "                [],\n\t                colapse\n\t              )\n\t            );\n\t          }\n\t        }\n\t      } else if (element.abi.type === \"function\") {\n\t        const value: any = inputFunction.find((i: any) => i.name === element.abi.name);\n\t        for (const input of value.inputs) {\n\t          leaves.push(\n", "            new Abi(\n\t              input.name,\n\t              input,\n\t              \"abiInput\",\n\t              element,\n\t              [],\n\t              TreeItemCollapsibleState.None\n\t            )\n\t          );\n\t        }\n", "        element.children = leaves;\n\t      }\n\t    }\n\t    return leaves;\n\t  }\n\t  private _onDidChangeTreeData: EventEmitter<Abi | undefined> = new EventEmitter<Abi | undefined>();\n\t  readonly onDidChangeTreeData: Event<Abi | undefined> = this._onDidChangeTreeData.event;\n\t  refresh(item?: Abi): void {\n\t    this._onDidChangeTreeData.fire(item);\n\t  }\n", "}\n"]}
{"filename": "src/treeView/AccountTreeView/AccountTreeDataProvider.ts", "chunked_list": ["import * as vscode from \"vscode\";\n\timport { loadAllCompiledContract } from \"../../config/contract\";\n\timport { JSONAccountType } from \"../../types\";\n\timport { getDeployedAccounts, getNotDeployedAccounts } from \"../../config/account\";\n\timport { getNetworkProvider } from \"../../config/network\";\n\texport class AccountTreeDataProvider\n\t  implements vscode.TreeDataProvider<Account>\n\t{\n\t  constructor(public context: vscode.ExtensionContext) { }\n\t  getTreeItem(element: Account): vscode.TreeItem {\n", "    return element;\n\t  }\n\t  async getChildren(element?: Account): Promise<Account[]> {\n\t    const accounts: Array<JSONAccountType> | undefined = getDeployedAccounts(this.context);\n\t    const undeployedAccounts: Array<JSONAccountType> | undefined = await getNotDeployedAccounts(this.context);\n\t    if ((accounts === undefined && undeployedAccounts === undefined)){\n\t      return [];\n\t    } else {\n\t      const leaves = [];\n\t      if (accounts !== undefined) {\n", "        for (const account of accounts) {\n\t          leaves.push(new Account(\n\t            account.accountAddress.slice(0, 5) + \"...\" + account.accountAddress.slice(-5),\n\t            vscode.TreeItemCollapsibleState.None,\n\t            \"deployedAccount\",\n\t            account,\n\t            \"verified\"\n\t          ));\n\t        }\n\t      }\n", "      if (undeployedAccounts !== undefined) {\n\t        for (const account of undeployedAccounts) {\n\t          leaves.push(new Account(\n\t            account.accountAddress.slice(0, 5) + \"...\" + account.accountAddress.slice(-5),\n\t            vscode.TreeItemCollapsibleState.None,\n\t            \"undeployedAccount\",\n\t            account,\n\t            \"unverified\"\n\t          ));\n\t        }\n", "      }\n\t      return leaves;\n\t    }\n\t  }\n\t  private _onDidChangeTreeData: vscode.EventEmitter<Account | undefined> =\n\t    new vscode.EventEmitter<Account | undefined>();\n\t  readonly onDidChangeTreeData: vscode.Event<Account | undefined> =\n\t    this._onDidChangeTreeData.event;\n\t  refresh(): void {\n\t    this._onDidChangeTreeData.fire(undefined);\n", "  }\n\t}\n\texport class Account extends vscode.TreeItem {\n\t  contextValue: string;\n\t  constructor(\n\t    public readonly label: string,\n\t    public readonly collapsibleState: vscode.TreeItemCollapsibleState,\n\t    public readonly context: string,\n\t    public account: JSONAccountType | undefined,\n\t    public readonly icon: string\n", "  ) {\n\t    super(label, collapsibleState);\n\t    this.contextValue = context;\n\t  }\n\t  command = {\n\t    title: \"Use Account\",\n\t    command: \"starkode.useAccount\",\n\t    arguments: [this],\n\t  };\n\t  iconPath = new vscode.ThemeIcon(this.icon);\n", "}\n"]}
{"filename": "src/treeView/ContractTreeView/ContractTreeDataProvider.ts", "chunked_list": ["import * as vscode from \"vscode\";\n\timport { isCairo1Contract, loadAllCompiledContract } from \"../../config/contract\";\n\texport class ContractTreeDataProvider implements vscode.TreeDataProvider<Contract> {\n\t  constructor(private workspaceRoot: string | undefined) { }\n\t  getTreeItem(element: Contract): vscode.TreeItem {\n\t    return element;\n\t  }\n\t  async getChildren(element?: Contract): Promise<Contract[]> {\n\t    const contracts = loadAllCompiledContract();\n\t    if (contracts === undefined || contracts.length === 0) {\n", "      vscode.window.showInformationMessage(\"No Contracts in workspace\");\n\t      return [];\n\t    } else {\n\t      const leaves = [];\n\t      for (const file of contracts) {\n\t        leaves.push(new Contract(\n\t          file.slice(0, -5),\n\t          vscode.TreeItemCollapsibleState.None,\n\t          \"contract\",\n\t          isCairo1Contract(file) ? \"file-code\" : \"file-text\"\n", "        ));\n\t      }\n\t      return leaves;\n\t    }\n\t  }\n\t  private _onDidChangeTreeData: vscode.EventEmitter<Contract | undefined> =\n\t    new vscode.EventEmitter<Contract | undefined>();\n\t  readonly onDidChangeTreeData: vscode.Event<Contract | undefined> =\n\t    this._onDidChangeTreeData.event;\n\t  refresh(): void {\n", "    this._onDidChangeTreeData.fire(undefined);\n\t  }\n\t}\n\texport class Contract extends vscode.TreeItem {\n\t  contextValue: string;\n\t  constructor(\n\t    public readonly label: string,\n\t    public readonly collapsibleState: vscode.TreeItemCollapsibleState,\n\t    public readonly context: string,\n\t    public icon: string\n", "  ) {\n\t    super(label, collapsibleState);\n\t    this.contextValue = context;\n\t  }\n\t  command = {\n\t    title: \"Use Contract\",\n\t    command: \"starkode.useContract\",\n\t    arguments: [this],\n\t  };\n\t  iconPath = new vscode.ThemeIcon(this.icon);\n", "}\n"]}
{"filename": "src/treeView/ContractTreeView/function.ts", "chunked_list": ["import * as vscode from \"vscode\";\n\timport { Contract as ContractTreeItem } from \"./ContractTreeDataProvider\";\n\timport { logger } from \"../../lib\";\n\timport path = require(\"path\");\n\texport const refreshContract = async (node: ContractTreeItem, contractTreeDataProvider: any): Promise<vscode.TreeView<ContractTreeItem>> => {\n\t    return vscode.window.createTreeView(\"starkode.contracts\", { treeDataProvider: contractTreeDataProvider, });\n\t};\n\texport const editContractAddress = async (input : any,context: vscode.ExtensionContext) => {\n\t    if (vscode.workspace.workspaceFolders === undefined) {\n\t        logger.error(\"Error: Open or Create a cairo project.\");\n", "        return;\n\t    }\n\t    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t    const filePath = path.join(path_, \"starkode\", input.label, `${input.label}_address.json`);\n\t    const document = await vscode.workspace.openTextDocument(filePath);\n\t    const editor = await vscode.window.showTextDocument(document);\n\t};\n"]}
{"filename": "src/utils/functions.ts", "chunked_list": ["import * as vscode from \"vscode\";\n\timport * as fs from \"fs\";\n\timport path from \"path\";\n\timport { logger } from \"../lib\";\n\timport { ABIFragment, JSONAccountType, TIsAccountDeployed } from \"../types\";\n\texport const createABIFile = (file: string) => {\n\t  try {\n\t    if (vscode.workspace.workspaceFolders === undefined) {\n\t      logger.error(\"Error: Please open your solidity project to vscode\");\n\t      return;\n", "    }\n\t    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t    const fileName = file.substring(0, file.length - 5);\n\t    if (!fs.existsSync(path.join(path_, \"starkode\", fileName))) {\n\t      fs.mkdirSync(path.join(path_, \"starkode\", fileName),{recursive: true});\n\t    }\n\t    if (\n\t      !fs.existsSync(\n\t        path.join(path_, \"starkode\", fileName, `${fileName}_abi.json`)\n\t      )\n", "    ) {\n\t      const filePath = path.join(path_, file);\n\t      const fileData = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n\t      const isCairo1Contract =\n\t        JSON.parse(fileData).contract_class_version === \"0.1.0\" ? true : false;\n\t      const abi: Array<ABIFragment> = JSON.parse(fileData).abi;\n\t      const abiFunctions = abi.filter((e) => e.type === \"function\");\n\t      const functionsValue = abiFunctions.map((func) => {\n\t        return {\n\t          type: func.type,\n", "          name: func.name,\n\t          inputs: func.inputs.map((e) => {\n\t            return { ...e, value: \"\" };\n\t          }),\n\t          stateMutability: func.stateMutability\n\t            ? func.stateMutability\n\t            : func.state_mutability,\n\t          outputs: func.outputs,\n\t        };\n\t      });\n", "      fs.writeFileSync(\n\t        path.join(path_, \"starkode\", fileName, `${fileName}_abi.json`),\n\t        JSON.stringify({ isCairo1: isCairo1Contract, abi: functionsValue }, null, 2)\n\t      );\n\t      logger.log(\"ABI file created successfully.\");\n\t    } else {\n\t      logger.log(`${fileName}_abi.json already exist.`);\n\t    }\n\t  } catch (error) {\n\t    logger.log(`Error while writing to file: ${error}`);\n", "  }\n\t};\n\texport const createAddressFile = (file: string) => {\n\t  try {\n\t    if (vscode.workspace.workspaceFolders === undefined) {\n\t      logger.error(\"Error: Please open your solidity project to vscode\");\n\t      return;\n\t    }\n\t    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t    const fileName = file.substring(0, file.length - 5);\n", "    if (\n\t      !fs.existsSync(\n\t        path.join(path_, \"starkode\", fileName, `${fileName}_address.json`)\n\t      )\n\t    ) {\n\t      fs.writeFileSync(\n\t        path.join(path_, \"starkode\", fileName, `${fileName}_address.json`),\n\t        JSON.stringify({\n\t          name: fileName,\n\t          address: \"\",\n", "          classHash: \"\",\n\t        }, null, 2)\n\t      );\n\t      logger.log(\"Address file created successfully.\");\n\t    } else {\n\t      logger.log(`${fileName}_address.json already exist.`);\n\t    }\n\t  } catch (error) {\n\t    logger.log(`Error while writing to file: ${error}`);\n\t  }\n", "};\n\texport const accountDeployStatus = (\n\t  accounts: Array<JSONAccountType>,\n\t  selectedNetwork: string,\n\t  status: boolean\n\t) => {\n\t  const networks = [\"goerli-alpha\", \"goerli-alpha-2\", \"mainnet-alpha\"];\n\t  let result: Array<JSONAccountType> | undefined;\n\t  switch (selectedNetwork) {\n\t    case networks[0]: {\n", "      result = accounts.filter((e) => e.isDeployed.gAlpha === status);\n\t      break;\n\t    }\n\t    case networks[1]: {\n\t      result = accounts.filter((e) => e.isDeployed.gAlpha2 === status);\n\t      break;\n\t    }\n\t    case networks[2]: {\n\t      result = accounts.filter((e) => e.isDeployed.mainnet === status);\n\t      break;\n", "    }\n\t    default:\n\t      break;\n\t  }\n\t  return result;\n\t};\n"]}
{"filename": "src/config/network.ts", "chunked_list": ["import * as vscode from \"vscode\";\n\timport { logger } from \"../lib\";\n\timport { INetworkQP } from \"../types\";\n\timport { Provider, SequencerProviderOptions } from \"starknet\";\n\timport { Account } from \"../treeView/AccountTreeView/AccountTreeDataProvider\";\n\texport const NETWORKS = [\"goerli-alpha\", \"goerli-alpha-2\", \"mainnet-alpha\"];\n\texport const updateSelectedNetwork = async (\n\t  context: vscode.ExtensionContext,\n\t  accountTreeView: vscode.TreeView<Account>,\n\t  accountTreeDataProvider: any\n", ") => {\n\t  const quickPick = vscode.window.createQuickPick<INetworkQP>();\n\t  quickPick.items = NETWORKS.map((name: string) => ({\n\t    label: name,\n\t  }));\n\t  quickPick.onDidChangeActive(() => {\n\t    quickPick.placeholder = \"Select network\";\n\t  });\n\t  quickPick.onDidChangeSelection((selection: any) => {\n\t    if (selection[0] != null) {\n", "      const { label } = selection[0];\n\t      void context.workspaceState.update(\"selectedNetwork\", label);\n\t      quickPick.dispose();\n\t      logger.success(`Selected network is ${label}`);\n\t      const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n\t      const selectedAccount = context.workspaceState.get(\"account\") as string;\n\t      if (selectedAccount !== undefined) {\n\t        accountTreeView.message = `Account : ${selectedAccount.slice(0, 5) + \"...\" + selectedAccount.slice(-5)} | ${selectedNetwork}`;\n\t      }\n\t      accountTreeDataProvider.refresh();\n", "    }\n\t  });\n\t  quickPick.onDidHide(() => {\n\t    quickPick.dispose();\n\t  });\n\t  quickPick.show();\n\t};\n\texport const getNetworkProvider = (\n\t  context: vscode.ExtensionContext\n\t): Provider | undefined => {\n", "  const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n\t  let networkBaseUrl: string | undefined = undefined;\n\t  switch (selectedNetwork) {\n\t    case NETWORKS[0]: {\n\t      networkBaseUrl = \"https://alpha4.starknet.io\";\n\t      break;\n\t    }\n\t    case NETWORKS[1]: {\n\t      networkBaseUrl = \"https://alpha4-2.starknet.io\";\n\t      break;\n", "    }\n\t    case NETWORKS[2]: {\n\t      networkBaseUrl = \"https://alpha-mainnet.starknet.io\";\n\t      break;\n\t    }\n\t    default: {\n\t      break;\n\t    }\n\t  }\n\t  if (networkBaseUrl === undefined) {\n", "    // logger.log(\"No network selected.\");\n\t    return;\n\t  }\n\t  const provider = new Provider({\n\t    sequencer: { baseUrl: networkBaseUrl },\n\t  });\n\t  return provider;\n\t};\n"]}
{"filename": "src/config/account.ts", "chunked_list": ["import * as vscode from \"vscode\";\n\timport * as fs from \"fs\";\n\timport {\n\t  Account,\n\t  ec,\n\t  json,\n\t  stark,\n\t  Provider,\n\t  hash,\n\t  CallData,\n", "  Signer,\n\t} from \"starknet\";\n\timport { logger } from \"../lib\";\n\timport { IAccountQP, JSONAccountType } from \"../types\";\n\timport { NETWORKS, getNetworkProvider } from \"./network\";\n\timport { accountDeployStatus } from \"../utils/functions\";\n\texport const createOZAccount = async (context: vscode.ExtensionContext) => {\n\t  try {\n\t    const privateKey = stark.randomAddress();\n\t    const publicKey = await new Signer(privateKey).getPubKey();\n", "    const OZaccountClassHash =\n\t      \"0x06f3ec04229f8f9663ee7d5bb9d2e06f213ba8c20eb34c58c25a54ef8fc591cb\";\n\t    const OZaccountConstructorCallData = CallData.compile({\n\t      publicKey: publicKey,\n\t    });\n\t    const OZcontractAddress = hash.calculateContractAddressFromHash(\n\t      publicKey,\n\t      OZaccountClassHash,\n\t      OZaccountConstructorCallData,\n\t      0\n", "    );\n\t    if (fs.existsSync(`${context.extensionPath}/accounts.json`)) {\n\t      const filedata = fs.readFileSync(\n\t        `${context.extensionPath}/accounts.json`,\n\t        {\n\t          encoding: \"utf-8\",\n\t        }\n\t      );\n\t      const parsedFileData = JSON.parse(filedata);\n\t      const writeNewAccount: Array<JSONAccountType> = [\n", "        ...parsedFileData,\n\t        {\n\t          accountHash: OZaccountClassHash,\n\t          constructorCallData: OZaccountConstructorCallData,\n\t          accountPubKey: publicKey,\n\t          accountAddress: OZcontractAddress,\n\t          privateKey: privateKey,\n\t          isDeployed: {\n\t            gAlpha: false,\n\t            gAlpha2: false,\n", "            mainnet: false,\n\t          },\n\t        },\n\t      ];\n\t      fs.writeFileSync(\n\t        `${context.extensionPath}/accounts.json`,\n\t        JSON.stringify(writeNewAccount)\n\t      );\n\t    } else {\n\t      const writeNewAccount: Array<JSONAccountType> = [\n", "        {\n\t          accountHash: OZaccountClassHash,\n\t          constructorCallData: OZaccountConstructorCallData,\n\t          accountPubKey: publicKey,\n\t          accountAddress: OZcontractAddress,\n\t          privateKey: privateKey,\n\t          isDeployed: {\n\t            gAlpha: false,\n\t            gAlpha2: false,\n\t            mainnet: false,\n", "          },\n\t        },\n\t      ];\n\t      fs.writeFileSync(\n\t        `${context.extensionPath}/accounts.json`,\n\t        JSON.stringify(writeNewAccount)\n\t      );\n\t    }\n\t    logger.log(`New account created: ${OZcontractAddress}`);\n\t  } catch (error) {\n", "    logger.error(`Error while creating new account: ${error}`);\n\t  }\n\t};\n\texport const getNotDeployedAccounts = async (context: vscode.ExtensionContext) => {\n\t  const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n\t  if (selectedNetwork === undefined) {\n\t    logger.log(\"Network not selected\");\n\t    return;\n\t  }\n\t  if (!fs.existsSync(`${context.extensionPath}/accounts.json`)) {\n", "    logger.log(\"No account exist.\");\n\t    return;\n\t  }\n\t  const fileData = fs.readFileSync(`${context.extensionPath}/accounts.json`, {\n\t    encoding: \"utf-8\",\n\t  });\n\t  const parsedFileData: Array<JSONAccountType> = JSON.parse(fileData);\n\t  const accounts: Array<JSONAccountType> | undefined = accountDeployStatus(\n\t    parsedFileData,\n\t    selectedNetwork,\n", "    false\n\t  );\n\t  if (accounts === undefined || accounts.length === 0) {\n\t    logger.log(`No undeployed account available on ${selectedNetwork}`);\n\t    return;\n\t  }\n\t  return accounts;\n\t};\n\texport const selectNotDeployedAccount = async (\n\t  context: vscode.ExtensionContext\n", ") => {\n\t  const accounts: Array<JSONAccountType> | undefined =\n\t    await getNotDeployedAccounts(context);\n\t  if (accounts === undefined) return;\n\t  const quickPick = vscode.window.createQuickPick<IAccountQP>();\n\t  quickPick.items = accounts.map((account: JSONAccountType) => ({\n\t    label: account.accountAddress,\n\t  }));\n\t  quickPick.onDidChangeActive(() => {\n\t    quickPick.placeholder = \"Select account\";\n", "  });\n\t  quickPick.onDidChangeSelection((selection: any) => {\n\t    if (selection[0] != null) {\n\t      const { label } = selection[0];\n\t      void context.workspaceState.update(\"undeployedAccount\", label);\n\t      logger.log(`${label} selected`);\n\t      quickPick.dispose();\n\t    }\n\t  });\n\t  quickPick.onDidHide(() => {\n", "    quickPick.dispose();\n\t  });\n\t  quickPick.show();\n\t};\n\texport const deployAccount = async (context: vscode.ExtensionContext , accountTreeDataProvider: any) => {\n\t  const presentAccounts: Array<JSONAccountType> | undefined =\n\t    await getNotDeployedAccounts(context);\n\t  const unDeployedAccount = await context.workspaceState.get(\n\t    \"undeployedAccount\"\n\t  );\n", "  if (presentAccounts === undefined) return;\n\t  const isAccountPresent: any = presentAccounts.filter(\n\t    (account) => account.accountAddress === unDeployedAccount\n\t  );\n\t  const selectedAccount: JSONAccountType = isAccountPresent[0];\n\t  const selectedNetwork = context.workspaceState.get(\"selectedNetwork\");\n\t  const provider = getNetworkProvider(context);\n\t  console.log(`Account address: ${selectedAccount.accountAddress}`);\n\t  if (provider === undefined) return;\n\t  const account = new Account(\n", "    provider,\n\t    selectedAccount.accountAddress,\n\t    selectedAccount.privateKey,\n\t    \"1\"\n\t  );\n\t  logger.log(\n\t    `Deploying account ${selectedAccount.accountAddress} on ${selectedNetwork}`\n\t  );\n\t  const { contract_address, transaction_hash } = await account.deployAccount({\n\t    classHash: selectedAccount.accountHash,\n", "    constructorCalldata: selectedAccount.constructorCallData,\n\t    addressSalt: selectedAccount.accountPubKey,\n\t  });\n\t  logger.log(`Transaction hash: ${transaction_hash}`);\n\t  await provider.waitForTransaction(transaction_hash);\n\t  await updateAccountJSON( context, `${context.extensionPath}/accounts.json`, selectedAccount);\n\t  logger.log(`Account deployed successfully at address: ${contract_address}`);\n\t  accountTreeDataProvider.refresh();\n\t};\n\tconst updateAccountJSON = async ( context: vscode.ExtensionContext , path: string, selectedAccount:JSONAccountType ) => {\n", "  const selectedNetwork = context.workspaceState.get(\"selectedNetwork\");\n\t  fs.readFile(path, 'utf8', (err, data) => {\n\t    if (err) {\n\t      console.error('Error reading file:', err);\n\t      return;\n\t    }\n\t    const accounts = JSON.parse(data);\n\t    const indexToUpdate = accounts.findIndex((account: { accountAddress: string; }) => account.accountAddress === selectedAccount.accountAddress);\n\t    if (indexToUpdate !== -1) {\n\t      accounts[indexToUpdate].isDeployed = {\n", "        gAlpha: selectedNetwork === NETWORKS[0] ? true : false,\n\t        gAlpha2: selectedNetwork === NETWORKS[1] ? true : false,\n\t        mainnet: selectedNetwork === NETWORKS[2] ? true : false,\n\t      };\n\t      fs.writeFile(path, JSON.stringify(accounts, null, 2), 'utf8', (err) => {\n\t        if (err) {\n\t          console.error('Error writing file:', err);\n\t          return;\n\t        }\n\t        console.log('JSON file successfully updated.');\n", "      });\n\t    } else {\n\t      console.error('Element not found in JSON file.');\n\t    }\n\t  });\n\t};\n\texport const getDeployedAccounts = (context: vscode.ExtensionContext) => {\n\t  const selectedNetwork: any = context.workspaceState.get(\"selectedNetwork\");\n\t  if (selectedNetwork === undefined){\n\t    // logger.log(\"Network not selected\");\n", "    return;\n\t  }\n\t  if (!fs.existsSync(`${context.extensionPath}/accounts.json`)) {\n\t    logger.log(\"No deployed account exist.\");\n\t    return;\n\t  }\n\t  const fileData = fs.readFileSync(`${context.extensionPath}/accounts.json`, {\n\t    encoding: \"utf-8\",\n\t  });\n\t  const parsedFileData: Array<JSONAccountType> = JSON.parse(fileData);\n", "  const accounts: Array<JSONAccountType> | undefined = accountDeployStatus(\n\t    parsedFileData,\n\t    selectedNetwork,\n\t    true\n\t  );\n\t  if (accounts === undefined || accounts.length === 0) {\n\t    logger.log(`No deployed account available on ${selectedNetwork}`);\n\t    return;\n\t  }\n\t  return accounts;\n", "};\n\texport const deleteAccount = async (context: vscode.ExtensionContext,node: any) => {\n\t  const fileData = fs.readFileSync(`${context.extensionPath}/accounts.json`, {\n\t    encoding: \"utf-8\",\n\t  });\n\t  const parsedFileData: Array<JSONAccountType> = JSON.parse(fileData);\n\t  const filteredData = parsedFileData.filter(obj => obj.accountAddress !== node.account.accountAddress);\n\t  fs.writeFileSync(`${context.extensionPath}/accounts.json`, JSON.stringify(filteredData, null, 2));\n\t};\n\texport const selectDeployedAccount = async (\n", "  context: vscode.ExtensionContext\n\t) => {\n\t  const accounts: Array<JSONAccountType> | undefined =\n\t    await getDeployedAccounts(context);\n\t  if (accounts === undefined) return;\n\t  const quickPick = vscode.window.createQuickPick<IAccountQP>();\n\t  quickPick.items = accounts.map((account: JSONAccountType) => ({\n\t    label: account.accountAddress,\n\t  }));\n\t  quickPick.onDidChangeActive(() => {\n", "    quickPick.placeholder = \"Select account\";\n\t  });\n\t  quickPick.onDidChangeSelection((selection: any) => {\n\t    if (selection[0] != null) {\n\t      const { label } = selection[0];\n\t      void context.workspaceState.update(\"account\", label);\n\t      logger.log(`${label} selected`);\n\t      quickPick.dispose();\n\t    }\n\t  });\n", "  quickPick.onDidHide(() => {\n\t    quickPick.dispose();\n\t  });\n\t  quickPick.show();\n\t};\n\texport const getAccountInfo = (\n\t  context: vscode.ExtensionContext,\n\t  accountAddress: string\n\t) => {\n\t  const accounts = getDeployedAccounts(context) as JSONAccountType[];\n", "  const selectedAccountInfo = accounts.filter(\n\t    (account) => account.accountAddress === accountAddress\n\t  );\n\t  return selectedAccountInfo[0];\n\t};\n"]}
{"filename": "src/config/contract.ts", "chunked_list": ["import * as vscode from \"vscode\";\n\timport * as fs from \"fs\";\n\timport path, { resolve } from \"path\";\n\timport { logger } from \"../lib\";\n\timport { ABIFragment, IContractQP, IFunctionQP } from \"../types\";\n\timport { createABIFile, createAddressFile } from \"../utils/functions\";\n\timport { getAccountInfo } from \"./account\";\n\timport { Account, CairoAssembly, Contract, ec, Provider } from \"starknet\";\n\timport { getNetworkProvider } from \"./network\";\n\texport const loadAllCompiledContract = () => {\n", "  if (vscode.workspace.workspaceFolders === undefined) {\n\t    logger.error(\"Error: Please open your solidity project to vscode\");\n\t    return;\n\t  }\n\t  const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t  const compiledCairoContract = fs\n\t    .readdirSync(path_)\n\t    .filter((file) => exportPathOfJSONfiles(path_, file));\n\t  return compiledCairoContract;\n\t};\n", "const exportPathOfJSONfiles = (path_: string, file: string) => {\n\t  const filePath = path.join(path_, file);\n\t  if (path.extname(filePath) === \".json\") {\n\t    const fileData = fs.readFileSync(filePath, {\n\t      encoding: \"utf-8\",\n\t    });\n\t    if (JSON.parse(fileData).program) return filePath;\n\t    if (JSON.parse(fileData).contract_class_version) {\n\t      return filePath;\n\t    }\n", "  }\n\t};\n\texport const setContract = async (context: vscode.ExtensionContext, label: string) => {\n\t  if (label === undefined) {\n\t    // logger.log(\"No Contract selected.\");\n\t    return;\n\t  }\n\t  void context.workspaceState.update(\"selectedContract\", `${label}.json`);\n\t  logger.log(`${label} contract selected`);\n\t  createABIFile(`${label}.json`);\n", "  createAddressFile(`${label}.json`);\n\t};\n\texport const selectCompiledContract = (context: vscode.ExtensionContext) => {\n\t  const contracts = loadAllCompiledContract();\n\t  if (contracts === undefined) {\n\t    logger.log(\"No Contract available.\");\n\t    return;\n\t  }\n\t  const quickPick = vscode.window.createQuickPick<IContractQP>();\n\t  quickPick.items = contracts.map((contract: string) => ({\n", "    label: contract.substring(0, contract.length - 5),\n\t  }));\n\t  quickPick.onDidChangeActive(() => {\n\t    quickPick.placeholder = \"Select Contract\";\n\t  });\n\t  quickPick.onDidChangeSelection((selection: any) => {\n\t    if (selection[0] != null) {\n\t      const { label } = selection[0];\n\t      setContract(context, label);\n\t      quickPick.dispose();\n", "    }\n\t  });\n\t  quickPick.onDidHide(() => {\n\t    quickPick.dispose();\n\t  });\n\t  quickPick.show();\n\t};\n\texport const getContractInfo = (path_: string, fileName: string) => {\n\t  try {\n\t    const file = fileName.substring(0, fileName.length - 5);\n", "    const fileData = fs.readFileSync(\n\t      path.join(path_, \"starkode\", file, `${file}_address.json`),\n\t      { encoding: \"utf-8\" }\n\t    );\n\t    const parsedFileData = JSON.parse(fileData);\n\t    return parsedFileData;\n\t  } catch (error) {\n\t    // console.log(error);\n\t    return undefined;\n\t  }\n", "};\n\texport const getContractABI = (path_: string, fileName: string) => {\n\t  try {\n\t    const file = fileName.substring(0, fileName.length - 5);\n\t    const fileData = fs.readFileSync(\n\t      path.join(path_, \"starkode\", file, `${file}_abi.json`),\n\t      { encoding: \"utf-8\" }\n\t    );\n\t    const parsedFileData = JSON.parse(fileData);\n\t    return parsedFileData;\n", "  } catch (error) {\n\t    // console.log(error);\n\t    return undefined;\n\t  }\n\t};\n\texport const isCairo1Contract = (fileName: string): boolean => {\n\t  if (vscode.workspace.workspaceFolders === undefined) {\n\t    logger.error(\"Error: Please open your solidity project to vscode\");\n\t    return false;\n\t  }\n", "  const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t  const fileData = fs.readFileSync(\n\t    path.join(path_, fileName),\n\t    { encoding: \"utf-8\" }\n\t  );\n\t  return JSON.parse(fileData).contract_class_version === \"0.1.0\" ? true : false;\n\t};\n\texport const declareContract = async (context: vscode.ExtensionContext) => {\n\t  try {\n\t    if (vscode.workspace.workspaceFolders === undefined) {\n", "      logger.error(\"Error: Please open your solidity project to vscode\");\n\t      return;\n\t    }\n\t    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t    const provider = getNetworkProvider(context) as Provider;\n\t    const selectedContract: string = context.workspaceState.get(\n\t      \"selectedContract\"\n\t    ) as string;\n\t    const selectedAccount = context.workspaceState.get(\"account\") as string;\n\t    if (selectedAccount === undefined) {\n", "      logger.log(\"No account selected.\");\n\t      return;\n\t    }\n\t    const accountInfo = getAccountInfo(context, selectedAccount);\n\t    const account = new Account(\n\t      provider,\n\t      accountInfo.accountAddress,\n\t      accountInfo.privateKey,\n\t      \"0\"\n\t    );\n", "    const fileName = selectedContract.substring(0, selectedContract.length - 5);\n\t    if (\n\t      !fs.existsSync(path.join(path_, selectedContract)) ||\n\t      !fs.existsSync(path.join(path_, `${fileName}.casm`))\n\t    ) {\n\t      logger.log(`${fileName}.json or ${fileName}.casm must be present.`);\n\t      return;\n\t    }\n\t    const compiledContract = fs.readFileSync(\n\t      path.join(path_, selectedContract),\n", "      {\n\t        encoding: \"ascii\",\n\t      }\n\t    );\n\t    const casmFileData = fs\n\t      .readFileSync(path.join(path_, `${fileName}.casm`))\n\t      .toString(\"ascii\");\n\t    const casmAssembly: CairoAssembly = JSON.parse(casmFileData);\n\t    logger.log(\"Declaring contract...\");\n\t    const declareResponse = await account.declareAndDeploy({\n", "      contract: compiledContract,\n\t      casm: casmAssembly,\n\t    });\n\t    logger.log(\n\t      `declare transaction hash: ${declareResponse.deploy.transaction_hash}`\n\t    );\n\t    logger.log(`declare classHash: ${declareResponse.deploy.classHash}`);\n\t    logger.log(\"transaction successful\");\n\t  } catch (error) {\n\t    logger.log(`Error while contract declaration: ${error}`);\n", "  }\n\t};\n\texport const deployContract = async (context: vscode.ExtensionContext) => {\n\t  try {\n\t    if (vscode.workspace.workspaceFolders === undefined) {\n\t      logger.error(\"Error: Please open your solidity project to vscode\");\n\t      return;\n\t    }\n\t    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t    const provider = getNetworkProvider(context) as Provider;\n", "    const selectedContract: string = context.workspaceState.get(\n\t      \"selectedContract\"\n\t    ) as string;\n\t    const selectedAccount = context.workspaceState.get(\"account\") as string;\n\t    if (selectedAccount === undefined) {\n\t      logger.log(\"No account selected.\");\n\t      return;\n\t    }\n\t    const accountInfo = getAccountInfo(context, selectedAccount);\n\t    logger.log(\"Deploying contract...\");\n", "    const account = new Account(\n\t      provider,\n\t      accountInfo.accountAddress,\n\t      accountInfo.privateKey,\n\t      \"0\"\n\t    );\n\t    const contractInfo = getContractInfo(path_, selectedContract);\n\t    if (contractInfo.classHash === \"\") {\n\t      logger.log(\"No classHash available for selected contract.\");\n\t      return;\n", "    }\n\t    const deployResponse = await account.deployContract({\n\t      classHash: contractInfo.classHash,\n\t    });\n\t    logger.log(`transaction hash: ${deployResponse.transaction_hash}`);\n\t    logger.log(\"waiting for transaction success...\");\n\t    await provider.waitForTransaction(deployResponse.transaction_hash);\n\t    const { abi: testAbi } = await provider.getClassAt(\n\t      deployResponse.contract_address\n\t    );\n", "    if (testAbi === undefined) {\n\t      throw new Error(\"no abi.\");\n\t    }\n\t    const myTestContract = new Contract(\n\t      testAbi,\n\t      deployResponse.contract_address,\n\t      provider\n\t    );\n\t    await provider.waitForTransaction(myTestContract.transaction_hash);\n\t    logger.log(`contract deployed successfully: ${myTestContract.address}`);\n", "  } catch (error) {\n\t    logger.log(`Error while contract deployment: ${error}`);\n\t  }\n\t};\n\texport const executeContractFunction = async (\n\t  context: vscode.ExtensionContext\n\t) => {\n\t  try {\n\t    if (vscode.workspace.workspaceFolders === undefined) {\n\t      logger.error(\"Error: Please open your solidity project to vscode\");\n", "      return;\n\t    }\n\t    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t    const provider = getNetworkProvider(context) as Provider;\n\t    const selectedContract: string = context.workspaceState.get(\n\t      \"selectedContract\"\n\t    ) as string;\n\t    const selectedAccount = context.workspaceState.get(\"account\") as string;\n\t    if (selectedAccount === undefined) {\n\t      logger.log(\"No account selected.\");\n", "      return;\n\t    }\n\t    const accountInfo = getAccountInfo(context, selectedAccount);\n\t    const functionABI = await getSelectedFunction(path_, selectedContract);\n\t    const contractInfo = getContractInfo(path_, selectedContract);\n\t    const params_: Array<any> = functionABI.inputs.map((e) => {\n\t      return e.value;\n\t    });\n\t    const params: Array<any> = params_ !== undefined ? params_ : [];\n\t    if (\n", "      functionABI.stateMutability === \"view\" ||\n\t      functionABI.state_mutability === \"view\"\n\t    ) {\n\t      const Abi = getContractABI(path_, selectedContract).abi;\n\t      const contract = new Contract(Abi, contractInfo.address, provider);\n\t      logger.log(`calling function: ${functionABI.name}`);\n\t      const functionCall: any = await contract.call(`${functionABI.name}`);\n\t      logger.log(`result: ${functionCall.res.toString()}`);\n\t    } else {\n\t      const Abi = getContractABI(path_, selectedContract).abi;\n", "      logger.log(`calling function: ${functionABI.name}`);\n\t      const account = new Account(\n\t        provider,\n\t        accountInfo.accountAddress,\n\t        accountInfo.privateKey,\n\t        \"0\"\n\t      );\n\t      const contract = new Contract(Abi, contractInfo.address, provider);\n\t      contract.connect(account);\n\t      const result = await contract.invoke(functionABI.name, params);\n", "      logger.log(`transaction hash: ${result.transaction_hash}`);\n\t      logger.log(\"waiting for transaction success...\");\n\t      await provider.waitForTransaction(result.transaction_hash);\n\t      logger.log(\"transaction successfull\");\n\t    }\n\t  } catch (error) {\n\t    logger.log(error);\n\t  }\n\t};\n\texport const executeContractFunctionFromTreeView = async (\n", "  context: vscode.ExtensionContext,\n\t  functionabi: ABIFragment\n\t) => {\n\t  try {\n\t    if (vscode.workspace.workspaceFolders === undefined) {\n\t      logger.error(\"Error: Please open your solidity project to vscode\");\n\t      return;\n\t    }\n\t    const path_ = vscode.workspace.workspaceFolders[0].uri.fsPath;\n\t    const provider = getNetworkProvider(context) as Provider;\n", "    const selectedContract: string = context.workspaceState.get(\n\t      \"selectedContract\"\n\t    ) as string;\n\t    const selectedAccount = context.workspaceState.get(\"account\") as string;\n\t    if (selectedAccount === undefined) {\n\t      logger.log(\"No account selected.\");\n\t      return;\n\t    }\n\t    const accountInfo = getAccountInfo(context, selectedAccount);\n\t    const functionABI = functionabi;\n", "    const contractInfo = getContractInfo(path_, selectedContract);\n\t    const params_: Array<any> = functionABI.inputs.map((e) => {\n\t      return e.value;\n\t    });\n\t    const params: Array<any> = params_ !== undefined ? params_ : [];\n\t    if (\n\t      functionABI.stateMutability === \"view\" ||\n\t      functionABI.state_mutability === \"view\"\n\t    ) {\n\t      const Abi = getContractABI(path_, selectedContract).abi;\n", "      const contract = new Contract(Abi, contractInfo.address, provider);\n\t      logger.log(`calling function: ${functionABI.name}`);\n\t      const functionCall: any = await contract.call(`${functionABI.name}`);\n\t      logger.log(`result: ${functionCall.res.toString()}`);\n\t    } else {\n\t      const Abi = getContractABI(path_, selectedContract).abi;\n\t      logger.log(`calling function: ${functionABI.name}`);\n\t      const account = new Account(\n\t        provider,\n\t        accountInfo.accountAddress,\n", "        accountInfo.privateKey,\n\t        \"0\"\n\t      );\n\t      const contract = new Contract(Abi, contractInfo.address, provider);\n\t      contract.connect(account);\n\t      const result = await contract.invoke(functionABI.name, params);\n\t      logger.log(`transaction hash: ${result.transaction_hash}`);\n\t      logger.log(\"waiting for transaction success...\");\n\t      await provider.waitForTransaction(result.transaction_hash);\n\t      logger.log(\"transaction successfull\");\n", "    }\n\t  } catch (error) {\n\t    logger.log(error);\n\t  }\n\t};\n\tconst getSelectedFunction = (\n\t  path_: string,\n\t  selectedContract: string\n\t): Promise<ABIFragment> => {\n\t  return new Promise((resolve, reject) => {\n", "    try {\n\t      const contractInfo: Array<ABIFragment> = getContractABI(\n\t        path_,\n\t        selectedContract\n\t      ).abi;\n\t      if (contractInfo === undefined) return;\n\t      const quickPick = vscode.window.createQuickPick<IFunctionQP>();\n\t      quickPick.items = contractInfo.map((account: ABIFragment) => ({\n\t        label: account.name,\n\t      }));\n", "      quickPick.onDidChangeActive(() => {\n\t        quickPick.placeholder = \"Select Function\";\n\t      });\n\t      quickPick.onDidChangeSelection((selection: any) => {\n\t        if (selection[0] != null) {\n\t          const { label } = selection[0];\n\t          quickPick.dispose();\n\t          const functionItem = contractInfo.filter(\n\t            (i: ABIFragment) => i.name === label\n\t          );\n", "          if (functionItem.length === 0)\n\t            throw new Error(\"No function is selected\");\n\t          resolve(functionItem[0]);\n\t        }\n\t      });\n\t      quickPick.onDidHide(() => {\n\t        quickPick.dispose();\n\t      });\n\t      quickPick.show();\n\t    } catch (error) {\n", "      reject(error);\n\t    }\n\t  });\n\t};\n"]}
{"filename": "src/lib/logger.ts", "chunked_list": ["import { window, OutputChannel } from \"vscode\";\n\tconst successToast = (msg: string) => {\n\t  window.showInformationMessage(msg, \"Dismiss\");\n\t};\n\tconst warningToast = (msg: string) => {\n\t  window.showWarningMessage(msg, \"Dismiss\");\n\t};\n\tconst errorToast = (msg: string) => {\n\t  window.showErrorMessage(msg, \"Dismiss\");\n\t};\n", "const actionToast = (msg: string, actionName: string) => {\n\t  return window.showInformationMessage(msg, actionName, \"Dismiss\");\n\t};\n\texport class Logger {\n\t  private outputChannel: OutputChannel;\n\t  constructor(name?: string) {\n\t    this.outputChannel = window.createOutputChannel(name || \"Starkode\");\n\t  }\n\t  private getNow = (): string => {\n\t    const date = new Date(Date.now());\n", "    return date.toLocaleTimeString();\n\t  };\n\t  public log(...m: Array<any>) {\n\t    const now = this.getNow();\n\t    this.outputChannel.appendLine(`[${now}]: ${m}`);\n\t    this.outputChannel.show();\n\t  }\n\t  public error(e: any) {\n\t    const now = this.getNow();\n\t    this.outputChannel.appendLine(`[${now}] Error: ${e.message}`);\n", "    this.outputChannel.appendLine(`[${now}] stack: ${e.stack}`);\n\t    this.outputChannel.show();\n\t    errorToast(`Error: ${e.message}`);\n\t  }\n\t  public success(m: string) {\n\t    const now = this.getNow();\n\t    this.outputChannel.appendLine(`[${now}]: ${m}`);\n\t    this.outputChannel.show();\n\t    successToast(m);\n\t  }\n", "}\n"]}
{"filename": "src/lib/index.ts", "chunked_list": ["import { Logger } from \"./logger\";\n\texport const logger = new Logger();"]}
{"filename": "src/types/index.ts", "chunked_list": ["import { Calldata } from \"starknet\";\n\timport { QuickPickItem } from \"vscode\";\n\texport interface INetworkQP extends QuickPickItem {\n\t  label: string;\n\t}\n\texport interface TIsAccountDeployed {\n\t  gAlpha: boolean;\n\t  gAlpha2: boolean;\n\t  mainnet: boolean;\n\t}\n", "export interface JSONAccountType {\n\t  accountHash: string;\n\t  constructorCallData: Calldata;\n\t  accountPubKey: string;\n\t  accountAddress: string;\n\t  privateKey: string;\n\t  isDeployed: TIsAccountDeployed;\n\t}\n\texport interface IAccountQP extends QuickPickItem {\n\t  label: string;\n", "}\n\texport interface IContractQP extends QuickPickItem {\n\t  label: string;\n\t}\n\texport interface IFunctionQP extends QuickPickItem {\n\t  label: string;\n\t}\n\tinterface inputType {\n\t  name: string;\n\t  type: string;\n", "  value: string;\n\t}\n\tinterface outputType {\n\t  name: string;\n\t  type: string;\n\t}\n\texport interface ABIFragment {\n\t  inputs: Array<inputType>;\n\t  name: string;\n\t  stateMutability: string;\n", "  type: string;\n\t  outputs: Array<outputType>;\n\t  state_mutability?: string;\n\t}\n"]}
