{"filename": "src/index.ts", "chunked_list": ["export type {Rule} from './rules';\n\texport {rule} from './rules';\n\texport {signal} from './signals';\n"]}
{"filename": "src/rules/rule.ts", "chunked_list": ["import type {SignalSet} from '../signals';\n\timport type {EncodedGroupRule} from './group';\n\timport type {EncodedInverseRule} from './inverse';\n\timport type {EncodedSignalRule} from './signal';\n\timport Evaluator from '../core/evaluator';\n\texport type EncodedRule<TContext> =\n\t  | EncodedGroupRule<TContext>\n\t  | EncodedInverseRule<TContext>\n\t  | EncodedSignalRule;\n\t/**\n", " * Allows you to define complex conditions and criteria for decision-making. It\n\t * consists of one or more signals, which can be combined using logical\n\t * operators to create intricate structures.\n\t *\n\t * Takes a TContext argument which encapsulates the necessary information\n\t * required by signals to make decisions and determine the outcome of rules.\n\t */\n\texport default abstract class Rule<TContext> extends Evaluator<\n\t  TContext,\n\t  boolean\n", "> {\n\t  abstract encode(signals: SignalSet<TContext>): EncodedRule<TContext>;\n\t}\n"]}
{"filename": "src/rules/group.ts", "chunked_list": ["import type {SignalSet} from '../signals';\n\timport type {EncodedRule} from './rule';\n\timport {getOperatorKey} from '../core/operators';\n\timport Rule from './rule';\n\texport type EncodedGroupRule<TContext> = {\n\t  [operator: string]: Array<EncodedRule<TContext>>;\n\t};\n\texport default class GroupRule<TContext> extends Rule<TContext> {\n\t  constructor(\n\t    protected operator: (\n", "      context: Array<TContext>,\n\t      rules: Array<Rule<TContext>>,\n\t    ) => Promise<boolean>,\n\t    protected rules: Array<Rule<TContext>>,\n\t  ) {\n\t    super(context => operator([context], rules));\n\t  }\n\t  encode(signals: SignalSet<TContext>): EncodedGroupRule<TContext> {\n\t    return {\n\t      [getOperatorKey(this.operator)]: this.rules.map(rule =>\n", "        rule.encode(signals),\n\t      ),\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/rules/index.ts", "chunked_list": ["import type Rule from './rule';\n\timport {operator} from '../core/operators';\n\timport GroupRule from './group';\n\timport InverseRule from './inverse';\n\timport parse from './parse';\n\texport type {default as Rule} from './rule';\n\texport const rule = {\n\t  every<TContext>(rules: Array<Rule<TContext>>): Rule<TContext> {\n\t    return new GroupRule(operator.$and, rules);\n\t  },\n", "  none<TContext>(rules: Array<Rule<TContext>>): Rule<TContext> {\n\t    return new InverseRule(new GroupRule(operator.$or, rules));\n\t  },\n\t  parse,\n\t  some<TContext>(rules: Array<Rule<TContext>>): Rule<TContext> {\n\t    return new GroupRule(operator.$or, rules);\n\t  },\n\t};\n"]}
{"filename": "src/rules/inverse.ts", "chunked_list": ["import type {SignalSet} from '../signals';\n\timport type {EncodedRule} from './rule';\n\timport {operator} from '../core/operators';\n\timport Rule from './rule';\n\texport type EncodedInverseRule<TContext> = {\n\t  $not: EncodedRule<TContext>;\n\t};\n\texport default class InverseRule<TContext> extends Rule<TContext> {\n\t  constructor(protected rule: Rule<TContext>) {\n\t    super(async context => operator.$not(await rule.evaluate(context)));\n", "  }\n\t  encode(signals: SignalSet<TContext>): EncodedInverseRule<TContext> {\n\t    return {$not: this.rule.encode(signals)};\n\t  }\n\t}\n"]}
{"filename": "src/rules/signal.ts", "chunked_list": ["import type {Signal, SignalSet} from '../signals';\n\timport {getOperatorKey} from '../core/operators';\n\timport {getSignalKey} from '../signals/set';\n\timport Rule from './rule';\n\texport type EncodedSignalRule = {\n\t  [signal: string]: {[operator: string]: unknown};\n\t};\n\texport default class SignalRule<\n\t  TContext,\n\t  TFirst,\n", "  TSecond,\n\t> extends Rule<TContext> {\n\t  constructor(\n\t    protected operator: (\n\t      first: TFirst,\n\t      second: TSecond,\n\t    ) => boolean | Promise<boolean>,\n\t    protected first: Signal<TContext, TFirst>,\n\t    protected second: TSecond,\n\t  ) {\n", "    super(async context => operator(await first.evaluate(context), second));\n\t  }\n\t  encode(signals: SignalSet<TContext>): EncodedSignalRule {\n\t    return {\n\t      [getSignalKey(this.first, signals)]: {\n\t        [getOperatorKey(this.operator)]:\n\t          this.second instanceof Rule\n\t            ? this.second.encode(signals)\n\t            : this.second instanceof RegExp\n\t            ? this.second.toString()\n", "            : this.second,\n\t      },\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/rules/parse.ts", "chunked_list": ["import type {OperatorKey} from '../core/operators';\n\timport type {Signal, SignalSet} from '../signals';\n\timport type Rule from './rule';\n\timport {assertArray, assertString} from '../core/assert';\n\timport {operator} from '../core/operators';\n\timport GroupRule from './group';\n\timport InverseRule from './inverse';\n\timport SignalRule from './signal';\n\tfunction assertObjectWithSingleKey(\n\t  data: unknown,\n", "): asserts data is {[key: string]: unknown} {\n\t  if (data == null || typeof data !== 'object') {\n\t    throw new Error('Expected an object, got: ' + data);\n\t  }\n\t  if (Object.keys(data).length !== 1) {\n\t    throw new Error('Expected an object with a single key, got: ' + data);\n\t  }\n\t}\n\tfunction assertOperatorKey(data: unknown): asserts data is OperatorKey {\n\t  if (!Object.keys(operator).includes(assertString(data))) {\n", "    throw new Error('Expected an operator key, got: ' + data);\n\t  }\n\t}\n\texport default async function parse<TContext>(\n\t  data: unknown,\n\t  signals: SignalSet<TContext>,\n\t): Promise<Rule<TContext>> {\n\t  assertObjectWithSingleKey(data);\n\t  const key = Object.keys(data)[0];\n\t  const value = data[key];\n", "  switch (key) {\n\t    case '$and':\n\t    case '$or':\n\t      return new GroupRule<TContext>(\n\t        operator[key],\n\t        await Promise.all(\n\t          assertArray(value).map(element => parse(element, signals)),\n\t        ),\n\t      );\n\t    case '$not':\n", "      return new InverseRule(await parse(value, signals));\n\t  }\n\t  const signal = signals[key];\n\t  assertObjectWithSingleKey(value);\n\t  const operatorKey = Object.keys(value)[0];\n\t  assertOperatorKey(operatorKey);\n\t  const operatorValue = value[operatorKey];\n\t  const arraySignal = signal as Signal<TContext, Array<unknown>>;\n\t  const numberSignal = signal as Signal<TContext, number>;\n\t  const stringSignal = signal as Signal<TContext, string>;\n", "  switch (operatorKey) {\n\t    case '$and':\n\t    case '$or':\n\t      return new SignalRule<TContext, Array<TContext>, Array<Rule<TContext>>>(\n\t        operator[operatorKey],\n\t        signal as Signal<TContext, Array<TContext>>,\n\t        [await parse(operatorValue, signals)],\n\t      );\n\t    case '$not':\n\t      throw new Error('Invalid operator key: ' + operatorKey);\n", "    case '$all':\n\t    case '$any':\n\t      return new SignalRule(\n\t        operator[operatorKey],\n\t        arraySignal,\n\t        await arraySignal.__assert(operatorValue),\n\t      );\n\t    case '$inc':\n\t    case '$pfx':\n\t    case '$sfx':\n", "      return new SignalRule(\n\t        operator[operatorKey],\n\t        stringSignal,\n\t        await stringSignal.__assert(operatorValue),\n\t      );\n\t    case '$rx':\n\t      const match = (await stringSignal.__assert(operatorValue)).match(\n\t        new RegExp('^/(.*?)/([dgimsuy]*)$'),\n\t      );\n\t      if (match == null) {\n", "        throw new Error('Expected a regular expression, got: ' + operatorValue);\n\t      }\n\t      return new SignalRule(\n\t        operator[operatorKey],\n\t        signal,\n\t        new RegExp(match[1], match[2]),\n\t      );\n\t    case '$gt':\n\t    case '$gte':\n\t    case '$lt':\n", "    case '$lte':\n\t      return new SignalRule(\n\t        operator[operatorKey],\n\t        numberSignal,\n\t        await numberSignal.__assert(operatorValue),\n\t      );\n\t    case '$eq':\n\t      return new SignalRule(operator[operatorKey], signal, operatorValue);\n\t    case '$in':\n\t      return new SignalRule(\n", "        operator[operatorKey],\n\t        signal,\n\t        assertArray(operatorValue),\n\t      );\n\t  }\n\t}\n"]}
{"filename": "src/signals/factory.ts", "chunked_list": ["import type Rule from '../rules/rule';\n\timport type {Infer, Schema} from '@decs/typeschema';\n\timport {createAssert} from '@decs/typeschema';\n\timport {operator} from '../core/operators';\n\timport InverseRule from '../rules/inverse';\n\timport SignalRule from '../rules/signal';\n\texport type Signal<TContext, TValue> = {\n\t  __assert: (data: unknown) => Promise<TValue>;\n\t  evaluate: (context: TContext) => Promise<TValue>;\n\t  not: Omit<Signal<TContext, TValue>, 'evaluate' | 'not'>;\n", "  equals(value: TValue): Rule<TContext>;\n\t  in(values: Array<TValue>): Rule<TContext>;\n\t} & (TValue extends Array<infer TElement>\n\t  ? {\n\t      every(rule: Rule<TElement>): Rule<TContext>;\n\t      some(rule: Rule<TElement>): Rule<TContext>;\n\t      contains(value: TElement): Rule<TContext>;\n\t      containsEvery(values: Array<TElement>): Rule<TContext>;\n\t      containsSome(values: Array<TElement>): Rule<TContext>;\n\t    }\n", "  : TValue extends boolean\n\t  ? {\n\t      isTrue(): Rule<TContext>;\n\t      isFalse(): Rule<TContext>;\n\t    }\n\t  : TValue extends number\n\t  ? {\n\t      lessThan(value: TValue): Rule<TContext>;\n\t      lessThanOrEquals(value: TValue): Rule<TContext>;\n\t      greaterThan(value: TValue): Rule<TContext>;\n", "      greaterThanOrEquals(value: TValue): Rule<TContext>;\n\t    }\n\t  : TValue extends string\n\t  ? {\n\t      includes(value: TValue): Rule<TContext>;\n\t      endsWith(value: TValue): Rule<TContext>;\n\t      startsWith(value: TValue): Rule<TContext>;\n\t      matches(value: RegExp): Rule<TContext>;\n\t    }\n\t  : Record<string, never>);\n", "export type SignalFactory<TValue> = {\n\t  value: <TContext>(\n\t    fn: (context: TContext) => TValue | Promise<TValue>,\n\t  ) => Signal<TContext, TValue>;\n\t};\n\tfunction createSignal<TContext, TValue>(\n\t  assert: (data: unknown) => Promise<TValue>,\n\t  fn: (context: TContext) => TValue | Promise<TValue>,\n\t): Signal<TContext, TValue> {\n\t  return {\n", "    __assert: assert,\n\t    evaluate: async (context: TContext) => assert(await fn(context)),\n\t  } as Signal<TContext, TValue>;\n\t}\n\tfunction addOperators<TContext, TValue>(\n\t  signal: Signal<TContext, TValue>,\n\t): Signal<TContext, TValue> {\n\t  return {\n\t    ...signal,\n\t    equals: value => new SignalRule(operator.$eq, signal, value),\n", "    in: values => new SignalRule(operator.$in, signal, values),\n\t  };\n\t}\n\tfunction addArrayOperators<TContext, TValue>(\n\t  signal: Signal<TContext, TValue>,\n\t): Signal<TContext, TValue> {\n\t  const arraySignal = signal as unknown as Signal<TContext, Array<unknown>>;\n\t  return {\n\t    ...signal,\n\t    contains: value => new SignalRule(operator.$all, arraySignal, [value]),\n", "    containsEvery: values => new SignalRule(operator.$all, arraySignal, values),\n\t    containsSome: values => new SignalRule(operator.$any, arraySignal, values),\n\t    every: rule => new SignalRule(operator.$and, arraySignal, [rule]),\n\t    some: rule => new SignalRule(operator.$or, arraySignal, [rule]),\n\t  };\n\t}\n\tfunction addBooleanOperators<TContext, TValue>(\n\t  signal: Signal<TContext, TValue>,\n\t): Signal<TContext, TValue> {\n\t  const booleanSignal = signal as unknown as Signal<TContext, boolean>;\n", "  return {\n\t    ...signal,\n\t    isFalse: () => new SignalRule(operator.$eq, booleanSignal, false),\n\t    isTrue: () => new SignalRule(operator.$eq, booleanSignal, true),\n\t  };\n\t}\n\tfunction addNumberOperators<TContext, TValue>(\n\t  signal: Signal<TContext, TValue>,\n\t): Signal<TContext, TValue> {\n\t  const numberSignal = signal as unknown as Signal<TContext, number>;\n", "  return {\n\t    ...signal,\n\t    greaterThan: value => new SignalRule(operator.$gt, numberSignal, value),\n\t    greaterThanOrEquals: value =>\n\t      new SignalRule(operator.$gte, numberSignal, value),\n\t    lessThan: value => new SignalRule(operator.$lt, numberSignal, value),\n\t    lessThanOrEquals: value =>\n\t      new SignalRule(operator.$lte, numberSignal, value),\n\t  };\n\t}\n", "function addStringOperators<TContext, TValue>(\n\t  signal: Signal<TContext, TValue>,\n\t): Signal<TContext, TValue> {\n\t  const stringSignal = signal as unknown as Signal<TContext, string>;\n\t  return {\n\t    ...signal,\n\t    endsWith: value => new SignalRule(operator.$sfx, stringSignal, value),\n\t    includes: value => new SignalRule(operator.$inc, stringSignal, value),\n\t    matches: value => new SignalRule(operator.$rx, stringSignal, value),\n\t    startsWith: value => new SignalRule(operator.$pfx, stringSignal, value),\n", "  };\n\t}\n\tfunction addModifiers<TContext, TValue>(\n\t  signal: Signal<TContext, TValue>,\n\t): Signal<TContext, TValue> {\n\t  return {\n\t    ...signal,\n\t    not: new Proxy(signal, {\n\t      get: (target, property, receiver) => {\n\t        const value = Reflect.get(target, property, receiver);\n", "        return typeof value === 'function'\n\t          ? (...args: Array<unknown>) =>\n\t              new InverseRule(value.bind(target)(...args))\n\t          : value;\n\t      },\n\t    }),\n\t  };\n\t}\n\texport function type<TSchema extends Schema>(\n\t  schema: TSchema,\n", "): SignalFactory<Infer<TSchema>> {\n\t  return {\n\t    value<TContext>(\n\t      fn: (context: TContext) => Infer<TSchema> | Promise<Infer<TSchema>>,\n\t    ) {\n\t      return [\n\t        addOperators,\n\t        addArrayOperators,\n\t        addBooleanOperators,\n\t        addNumberOperators,\n", "        addStringOperators,\n\t        addModifiers,\n\t      ].reduce(\n\t        (value, operation) => operation(value),\n\t        createSignal(createAssert(schema), fn),\n\t      );\n\t    },\n\t  };\n\t}\n"]}
{"filename": "src/signals/set.ts", "chunked_list": ["import type {Signal} from './factory';\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\texport type SignalSet<TContext> = Record<string, Signal<TContext, any>>;\n\texport function getSignalKey<TContext, TValue>(\n\t  signal: Signal<TContext, TValue>,\n\t  signals: SignalSet<TContext>,\n\t): string {\n\t  const signalKey = Object.keys(signals).find(\n\t    key => signals[key].equals === signal.equals,\n\t  );\n", "  if (signalKey == null) {\n\t    throw new Error('Invalid signal: ' + signal.evaluate);\n\t  }\n\t  return signalKey;\n\t}\n"]}
{"filename": "src/signals/index.ts", "chunked_list": ["import {type} from './factory';\n\texport type {Signal} from './factory';\n\texport type {SignalSet} from './set';\n\texport const signal = {type};\n"]}
{"filename": "src/core/evaluator.ts", "chunked_list": ["export default abstract class Evaluator<TContext, TValue> {\n\t  constructor(protected fn: (context: TContext) => TValue | Promise<TValue>) {}\n\t  async evaluate(context: TContext): Promise<TValue> {\n\t    return this.fn(context);\n\t  }\n\t}\n"]}
{"filename": "src/core/assert.ts", "chunked_list": ["export function assertArray<T>(value: unknown): Array<T> {\n\t  if (!Array.isArray(value)) {\n\t    throw new Error('Expected an array, got: ' + value);\n\t  }\n\t  return value;\n\t}\n\texport function assertBoolean(value: unknown): boolean {\n\t  if (typeof value !== 'boolean') {\n\t    throw new Error('Expected a boolean, got: ' + value);\n\t  }\n", "  return value;\n\t}\n\texport function assertNumber(value: unknown): number {\n\t  if (typeof value !== 'number') {\n\t    throw new Error('Expected a number, got: ' + value);\n\t  }\n\t  return value;\n\t}\n\texport function assertString(value: unknown): string {\n\t  if (typeof value !== 'string') {\n", "    throw new Error('Expected a string, got: ' + value);\n\t  }\n\t  return value;\n\t}\n"]}
{"filename": "src/core/operators.ts", "chunked_list": ["import type Rule from '../rules/rule';\n\texport type OperatorKey = keyof typeof operator;\n\texport const operator = {\n\t  $all<T>(first: Array<T>, second: Array<T>): boolean {\n\t    return second.every(element => first.includes(element));\n\t  },\n\t  async $and<T>(first: Array<T>, second: Array<Rule<T>>): Promise<boolean> {\n\t    const values = await Promise.all(\n\t      first.flatMap(firstElement =>\n\t        second.map(secondElement => secondElement.evaluate(firstElement)),\n", "      ),\n\t    );\n\t    return values.every(Boolean);\n\t  },\n\t  $any<T>(first: Array<T>, second: Array<T>): boolean {\n\t    return second.some(element => first.includes(element));\n\t  },\n\t  $eq<T>(first: T, second: T): boolean {\n\t    return first === second;\n\t  },\n", "  $gt<T extends number>(first: T, second: T): boolean {\n\t    return first > second;\n\t  },\n\t  $gte<T extends number>(first: T, second: T): boolean {\n\t    return first >= second;\n\t  },\n\t  $in<T>(first: T, second: Array<T>): boolean {\n\t    return second.includes(first);\n\t  },\n\t  $inc<T extends string>(first: T, second: T): boolean {\n", "    return first.includes(second);\n\t  },\n\t  $lt<T extends number>(first: T, second: T): boolean {\n\t    return first < second;\n\t  },\n\t  $lte<T extends number>(first: T, second: T): boolean {\n\t    return first <= second;\n\t  },\n\t  $not<T extends boolean>(value: T): boolean {\n\t    return !value;\n", "  },\n\t  async $or<T>(first: Array<T>, second: Array<Rule<T>>): Promise<boolean> {\n\t    const values = await Promise.all(\n\t      first.flatMap(firstElement =>\n\t        second.map(secondElement => secondElement.evaluate(firstElement)),\n\t      ),\n\t    );\n\t    return values.some(Boolean);\n\t  },\n\t  $pfx<T extends string>(first: T, second: T): boolean {\n", "    return first.startsWith(second);\n\t  },\n\t  $rx<T extends string>(first: T, second: RegExp): boolean {\n\t    return first.match(second) != null;\n\t  },\n\t  $sfx<T extends string>(first: T, second: T): boolean {\n\t    return first.endsWith(second);\n\t  },\n\t};\n\texport function getOperatorKey<TFirst, TSecond>(\n", "  fn: (first: TFirst, second: TSecond) => boolean | Promise<boolean>,\n\t): OperatorKey {\n\t  const operatorKey = (Object.keys(operator) as Array<OperatorKey>).find(\n\t    key => operator[key] === fn,\n\t  );\n\t  if (operatorKey == null) {\n\t    throw new Error('Invalid operator: ' + fn);\n\t  }\n\t  return operatorKey;\n\t}\n"]}
{"filename": "src/__tests__/async.test.ts", "chunked_list": ["import {describe, expect, test} from '@jest/globals';\n\timport {z} from 'zod';\n\timport {signal} from '../signals';\n\ttype Record = {\n\t  name: string;\n\t};\n\ttype Context = {\n\t  id: number;\n\t};\n\tasync function fetchRecord(id: number): Promise<Record> {\n", "  return {name: `record_${id}`};\n\t}\n\tdescribe('ruls', () => {\n\t  const signals = {\n\t    name: signal\n\t      .type(z.string())\n\t      .value<Context>(async ({id}) => (await fetchRecord(id)).name),\n\t  };\n\t  test('evaluate', async () => {\n\t    expect(await signals.name.evaluate({id: 123})).toEqual('record_123');\n", "    expect(await signals.name.evaluate({id: 246})).toEqual('record_246');\n\t  });\n\t});\n"]}
{"filename": "src/__tests__/comparison.test.ts", "chunked_list": ["import {describe, expect, test} from '@jest/globals';\n\timport {z} from 'zod';\n\timport {rule} from '../rules';\n\timport {signal} from '../signals';\n\tdescribe('json-rules-engine', () => {\n\t  test('basic example', async () => {\n\t    type Context = {\n\t      gameDuration: number;\n\t      personalFouls: number;\n\t    };\n", "    const signals = {\n\t      gameDuration: signal\n\t        .type(z.number())\n\t        .value<Context>(({gameDuration}) => gameDuration),\n\t      personalFouls: signal\n\t        .type(z.number())\n\t        .value<Context>(({personalFouls}) => personalFouls),\n\t    };\n\t    const fouledOut = rule.some([\n\t      rule.every([\n", "        signals.gameDuration.equals(40),\n\t        signals.personalFouls.greaterThanOrEquals(5),\n\t      ]),\n\t      rule.every([\n\t        signals.gameDuration.equals(48),\n\t        signals.personalFouls.greaterThanOrEquals(6),\n\t      ]),\n\t    ]);\n\t    expect(\n\t      await fouledOut.evaluate({gameDuration: 40, personalFouls: 6}),\n", "    ).toBeTruthy();\n\t    expect(\n\t      await fouledOut.evaluate({gameDuration: 48, personalFouls: 5}),\n\t    ).toBeFalsy();\n\t  });\n\t  test('advanced example', async () => {\n\t    type Context = {\n\t      company: string;\n\t      status: string;\n\t      ptoDaysTaken: Array<string>;\n", "    };\n\t    const signals = {\n\t      company: signal.type(z.string()).value<Context>(({company}) => company),\n\t      ptoDaysTaken: signal\n\t        .type(z.array(z.string()))\n\t        .value<Context>(({ptoDaysTaken}) => ptoDaysTaken),\n\t      status: signal.type(z.string()).value<Context>(({status}) => status),\n\t    };\n\t    const microsoftEmployeeOutOnChristmas = rule.every([\n\t      signals.company.equals('microsoft'),\n", "      signals.status.in(['active', 'paid-leave']),\n\t      signals.ptoDaysTaken.contains('2016-12-25'),\n\t    ]);\n\t    const accountInformation = {\n\t      company: 'microsoft',\n\t      ptoDaysTaken: ['2016-12-24', '2016-12-25'],\n\t      status: 'active',\n\t    };\n\t    expect(\n\t      await microsoftEmployeeOutOnChristmas.evaluate(accountInformation),\n", "    ).toBeTruthy();\n\t    accountInformation.company = 'apple';\n\t    expect(\n\t      await microsoftEmployeeOutOnChristmas.evaluate(accountInformation),\n\t    ).toBeFalsy();\n\t  });\n\t});\n"]}
{"filename": "src/__tests__/main.test.ts", "chunked_list": ["import {describe, expect, test} from '@jest/globals';\n\timport {z} from 'zod';\n\timport {rule} from '../rules';\n\timport Rule from '../rules/rule';\n\timport {signal} from '../signals';\n\ttype Context = {\n\t  id: number;\n\t};\n\tdescribe('ruls', () => {\n\t  const signals = {\n", "    sampleArray: signal\n\t      .type(z.array(z.number()))\n\t      .value<Context>(({id}) => [id]),\n\t    sampleBoolean: signal.type(z.boolean()).value<Context>(({id}) => id > 0),\n\t    sampleNumber: signal.type(z.number()).value<Context>(({id}) => 2 * id),\n\t    sampleString: signal.type(z.string()).value<Context>(({id}) => `id=${id}`),\n\t  };\n\t  test('evaluate', async () => {\n\t    expect(await signals.sampleArray.evaluate({id: 123})).toEqual([123]);\n\t    expect(await signals.sampleBoolean.evaluate({id: 123})).toEqual(true);\n", "    expect(await signals.sampleNumber.evaluate({id: 123})).toEqual(246);\n\t    expect(await signals.sampleString.evaluate({id: 123})).toEqual('id=123');\n\t  });\n\t  test('rules', async () => {\n\t    const check = rule.every([\n\t      signals.sampleString.matches(/3$/g),\n\t      signals.sampleArray.not.contains(246),\n\t    ]);\n\t    expect(check).toBeInstanceOf(Rule);\n\t    const encodedCheck = check.encode(signals);\n", "    expect(encodedCheck).toEqual({\n\t      $and: [\n\t        {sampleString: {$rx: '/3$/g'}},\n\t        {$not: {sampleArray: {$all: [246]}}},\n\t      ],\n\t    });\n\t    expect(JSON.stringify(encodedCheck)).toEqual(\n\t      '{\"$and\":[{\"sampleString\":{\"$rx\":\"/3$/g\"}},{\"$not\":{\"sampleArray\":{\"$all\":[246]}}}]}',\n\t    );\n\t    const parsedCheck = await rule.parse(encodedCheck, signals);\n", "    expect(parsedCheck.encode(signals)).toEqual(encodedCheck);\n\t  });\n\t});\n"]}
