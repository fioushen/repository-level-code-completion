{"filename": "vite.config.ts", "chunked_list": ["import { defineConfig } from 'vite';\n\timport { crx } from '@crxjs/vite-plugin';\n\timport { svelte } from '@sveltejs/vite-plugin-svelte';\n\timport path from 'path';\n\timport sveltePreprocess from 'svelte-preprocess';\n\timport manifest from './src/manifest';\n\texport default defineConfig(({ mode }) => {\n\t  const production = mode === 'production';\n\t  return {\n\t    build: {\n", "      emptyOutDir: true,\n\t      outDir: 'build',\n\t      rollupOptions: {\n\t        output: {\n\t          chunkFileNames: 'assets/chunk-[hash].js',\n\t        },\n\t      },\n\t    },\n\t    plugins: [\n\t      crx({ manifest }),\n", "      svelte({\n\t        compilerOptions: {\n\t          dev: !production,\n\t        },\n\t        preprocess: sveltePreprocess(),\n\t      }),\n\t    ],\n\t    resolve: {\n\t      alias: {\n\t        '@': path.resolve(__dirname, 'src'),\n", "      },\n\t    },\n\t  };\n\t});\n"]}
{"filename": "src/global.d.ts", "chunked_list": ["/// <reference types=\"svelte\" />\n\t/// <reference types=\"vite/client\" />\n\tdeclare const __APP_VERSION__: string;\n"]}
{"filename": "src/background.ts", "chunked_list": ["chrome.runtime.onMessage.addListener((packet: Packet) => {\n\t  if (packet.ext !== 'share-on-nostr') {\n\t    return;\n\t  }\n\t  if (packet.kind === 'share') {\n\t    chrome.tabs.sendMessage(packet.tabId, packet);\n\t  }\n\t  if (packet.kind === 'updatePreferences') {\n\t    resetContextMenu();\n\t  }\n", "});\n\tconst contextMenuId = 'share-on-nostr';\n\tasync function resetContextMenu() {\n\t  chrome.contextMenus.removeAll();\n\t  const enableContextMenu = await chrome.storage.local\n\t    .get('enableContextMenu')\n\t    .then(({ enableContextMenu }) => enableContextMenu?.[1]);\n\t  if (!enableContextMenu) {\n\t    return;\n\t  }\n", "  const postMethod = await chrome.storage.local\n\t    .get('postMethod')\n\t    .then(({ postMethod }) => postMethod?.[1]);\n\t  if (postMethod === 'nsec' || postMethod === 'externalApp') {\n\t    chrome.contextMenus.create({\n\t      id: contextMenuId,\n\t      title: 'Share on Nostr',\n\t      contexts: ['page'],\n\t    });\n\t  }\n", "}\n\tresetContextMenu();\n\tchrome.contextMenus.onClicked.addListener((info, tab) => {\n\t  const tabId = tab?.id ?? 0;\n\t  if (tabId && info.menuItemId === contextMenuId) {\n\t    chrome.tabs.create({\n\t      url: `/src/pages/popup/index.html?t=${encodeURIComponent(\n\t        tab?.title ?? 'No Title',\n\t      )}&u=${encodeURIComponent(tab?.url ?? '')}`,\n\t      active: true,\n", "    });\n\t  }\n\t});\n"]}
{"filename": "src/manifest.ts", "chunked_list": ["import { defineManifest } from '@crxjs/vite-plugin';\n\texport default defineManifest({\n\t  name: 'share-on-nostr',\n\t  description: 'Share URL of active tab on Nostr',\n\t  version: '0.3.1',\n\t  manifest_version: 3,\n\t  icons: {\n\t    '16': 'img/logo-16.png',\n\t    '32': 'img/logo-34.png',\n\t    '48': 'img/logo-48.png',\n", "    '128': 'img/logo-128.png',\n\t  },\n\t  action: {\n\t    default_popup: 'src/pages/popup/index.html',\n\t    default_icon: 'img/logo-48.png',\n\t  },\n\t  options_page: 'src/pages/preferences/index.html',\n\t  background: {\n\t    service_worker: 'src/background.ts',\n\t    type: 'module',\n", "  },\n\t  web_accessible_resources: [\n\t    {\n\t      resources: ['img/logo-16.png', 'img/logo-34.png', 'img/logo-48.png', 'img/logo-128.png'],\n\t      matches: [],\n\t    },\n\t    {\n\t      resources: ['js/share-on-nostr.js'],\n\t      matches: ['https://*/*', 'http://localhost:*/*'],\n\t    },\n", "  ],\n\t  permissions: ['storage', 'activeTab', 'scripting', 'contextMenus'],\n\t});\n"]}
{"filename": "src/pages/popup/share.ts", "chunked_list": ["import { createEventBySecretKey } from '../../lib/nostr/event';\n\timport { load } from '../../lib/store';\n\tinterface ShareParams {\n\t  tabId: number;\n\t  text: string;\n\t  url: string;\n\t}\n\texport async function share(params: ShareParams) {\n\t  const postMethod = await load('postMethod', 'v1');\n\t  switch (postMethod) {\n", "    case 'nip07':\n\t      await shareByNip07(params);\n\t      break;\n\t    case 'nsec':\n\t      await shareByNsec(params);\n\t      break;\n\t    case 'externalApp':\n\t      await shareByExternalApp(params);\n\t      break;\n\t  }\n", "}\n\tasync function shareByNip07({ tabId, text, url }: ShareParams) {\n\t  const packet: Packet = {\n\t    ext: 'share-on-nostr',\n\t    kind: 'share',\n\t    tabId,\n\t    text,\n\t    url,\n\t  };\n\t  await chrome.runtime.sendMessage(packet);\n", "}\n\tasync function shareByNsec({ text, url }: ShareParams) {\n\t  const relays = await load('relayUrls', 'v1');\n\t  onReceiveRelaysHandler(relays);\n\t  const event = JSON.stringify([\n\t    'EVENT',\n\t    await createEventBySecretKey(\n\t      {\n\t        kind: 1,\n\t        content: text,\n", "        tags: [['r', url]],\n\t      },\n\t      await load('nsec', 'v1'),\n\t    ),\n\t  ]);\n\t  for (const url of relays) {\n\t    const ws = new WebSocket(url);\n\t    ws.addEventListener('open', () => {\n\t      ws.send(event);\n\t    });\n", "    ws.addEventListener('error', () => {\n\t      onReceivedPostResultHandler({ url, success: false });\n\t    });\n\t    ws.addEventListener('message', ({ data }) => {\n\t      const [ok] = JSON.parse(data);\n\t      onReceivedPostResultHandler({ url, success: ok === 'OK' });\n\t      ws.close();\n\t    });\n\t  }\n\t}\n", "export async function shareByExternalApp({ text, url }: ShareParams) {\n\t  const intentUrl = await load('intentUrl', 'v1');\n\t  await chrome.tabs.create({\n\t    url: intentUrl\n\t      .replace('{text}', encodeURIComponent(text))\n\t      .replace('{url}', encodeURIComponent(url)),\n\t    active: true,\n\t  });\n\t}\n\tinterface OnReceiveRelaysHandler {\n", "  (relays: string[]): void;\n\t}\n\tlet onReceiveRelaysHandler: OnReceiveRelaysHandler = () => {};\n\texport async function onReceivedRelays(callback: OnReceiveRelaysHandler) {\n\t  const postMethod = await load('postMethod', 'v1');\n\t  if (postMethod === 'nip07') {\n\t    chrome.runtime.onMessage.addListener((packet: Packet) => {\n\t      if (packet.ext !== 'share-on-nostr') {\n\t        return;\n\t      }\n", "      if (packet.kind === 'relays') {\n\t        callback(packet.relays);\n\t      }\n\t    });\n\t  }\n\t  if (postMethod === 'nsec') {\n\t    onReceiveRelaysHandler = callback;\n\t  }\n\t}\n\tinterface OnReceivedPostResultHandler {\n", "  (result: { url: string; success: boolean }): void;\n\t}\n\tlet onReceivedPostResultHandler: OnReceivedPostResultHandler = () => {};\n\texport async function onReceivedPostResult(callback: OnReceivedPostResultHandler) {\n\t  const postMethod = await load('postMethod', 'v1');\n\t  if (postMethod === 'nip07') {\n\t    chrome.runtime.onMessage.addListener((packet: Packet) => {\n\t      if (packet.ext !== 'share-on-nostr') {\n\t        return;\n\t      }\n", "      if (packet.kind === 'result') {\n\t        callback(packet);\n\t      }\n\t    });\n\t  }\n\t  if (postMethod === 'nsec') {\n\t    onReceivedPostResultHandler = callback;\n\t  }\n\t}\n"]}
{"filename": "src/pages/popup/connection.ts", "chunked_list": ["declare global {\n\t  interface Window {\n\t    __shareOnNostr__loaded: boolean;\n\t  }\n\t}\n\texport async function connectToActiveTab(params: { inject: boolean }): Promise<{\n\t  tabId: number;\n\t  title: string;\n\t  url: string;\n\t}> {\n", "  const [tab] = await chrome.tabs.query({ active: true, lastFocusedWindow: true });\n\t  const { id: tabId = 0, url = '', title = '' } = tab;\n\t  if (params.inject) {\n\t    chrome.scripting.executeScript({\n\t      target: { tabId },\n\t      func: () => {\n\t        if (window.__shareOnNostr__loaded) {\n\t          return;\n\t        }\n\t        window.__shareOnNostr__loaded = true;\n", "        injectResourceScript('js/share-on-nostr.js');\n\t        window.addEventListener('message', async ({ data }: MessageEvent<Packet>) => {\n\t          if (data.ext !== 'share-on-nostr') {\n\t            return;\n\t          }\n\t          if (data.kind === 'relays' || data.kind === 'result') {\n\t            chrome.runtime.sendMessage(data);\n\t          }\n\t        });\n\t        chrome.runtime.onMessage.addListener((packet: Packet) => {\n", "          if (packet.ext !== 'share-on-nostr') {\n\t            return;\n\t          }\n\t          if (packet.kind === 'share') {\n\t            window.postMessage(packet);\n\t          }\n\t        });\n\t        function injectResourceScript(path: string) {\n\t          const script = document.createElement('script');\n\t          script.setAttribute('async', 'false');\n", "          script.setAttribute('type', 'text/javascript');\n\t          script.setAttribute('src', chrome.runtime.getURL(path));\n\t          document.head.appendChild(script);\n\t        }\n\t      },\n\t    });\n\t  }\n\t  return {\n\t    tabId,\n\t    title,\n", "    url,\n\t  };\n\t}\n"]}
{"filename": "src/pages/popup/index.ts", "chunked_list": ["import App from './Popup.svelte';\n\timport '../../lib/svelte-material-ui';\n\tconst app = new (App as any)({\n\t  target: document.getElementById('app')!,\n\t});\n\texport default app;\n"]}
{"filename": "src/pages/preferences/preferences.ts", "chunked_list": ["import { writable, get } from 'svelte/store';\n\timport { load, getDefault, savePreferences, type NostrPostMethod } from '../../lib/store';\n\timport { toHex } from '../../lib/nostr/bech32';\n\timport { getPublicKey } from '../../lib/nostr/event';\n\texport const NostrPostMethods: Record<NostrPostMethod, NostrPostMethod> = {\n\t  nip07: 'nip07',\n\t  nsec: 'nsec',\n\t  externalApp: 'externalApp',\n\t};\n\texport async function preferences() {\n", "  const postMethod = writable(await load('postMethod', 'v1'));\n\t  const nsec = writable(await load('nsec', 'v1'));\n\t  const relayUrls = writable((await load('relayUrls', 'v1')).join('\\n'));\n\t  const intentUrl = writable(await load('intentUrl', 'v1'));\n\t  const noteTemplate = writable(await load('noteTemplate', 'v1'));\n\t  const enableContextMenu = writable(await load('enableContextMenu', 'v1'));\n\t  const errors = writable({\n\t    nsec: '',\n\t    relayUrls: '',\n\t    intentUrl: '',\n", "  });\n\t  return {\n\t    postMethod,\n\t    nsec,\n\t    relayUrls,\n\t    intentUrl,\n\t    noteTemplate,\n\t    enableContextMenu,\n\t    errors,\n\t    useDefaultNoteTemplate() {\n", "      noteTemplate.set(getDefault('noteTemplate'));\n\t    },\n\t    async save(): Promise<'success' | 'validation-error' | 'unknown-error'> {\n\t      const _postMethod = get(postMethod);\n\t      let _nsec = get(nsec);\n\t      let _npub = '';\n\t      const _relayUrls = get(relayUrls)\n\t        .split('\\n')\n\t        .map((e) => e.trimEnd())\n\t        .filter((e) => !!e);\n", "      const _intentUrl = get(intentUrl);\n\t      // --- begin validation ---\n\t      let canSave = true;\n\t      const errorMessages = {\n\t        nsec: '',\n\t        intentUrl: '',\n\t        relayUrls: '',\n\t      };\n\t      if (_postMethod === 'nsec') {\n\t        if (!_nsec) {\n", "          canSave = false;\n\t          errorMessages.nsec = 'nsec is required.';\n\t        } else {\n\t          try {\n\t            _nsec = _nsec.startsWith('nsec1') ? toHex(_nsec) : _nsec;\n\t            _npub = getPublicKey(_nsec);\n\t          } catch {\n\t            canSave = false;\n\t            errorMessages.nsec = 'Invalid format.';\n\t          }\n", "        }\n\t        if (_relayUrls.length <= 0) {\n\t          canSave = false;\n\t          errorMessages.relayUrls = 'At least one or more relays are required.';\n\t        } else if (\n\t          !_relayUrls.every((url) => url.startsWith('ws://') || url.startsWith('wss://'))\n\t        ) {\n\t          canSave = false;\n\t          errorMessages.relayUrls = 'Each line must be a valid relay URL.';\n\t        }\n", "      }\n\t      if (_postMethod === 'externalApp') {\n\t        if (!_intentUrl) {\n\t          canSave = false;\n\t          errorMessages.intentUrl = 'URL is required.';\n\t        } else if (!(_intentUrl.startsWith('http://') || _intentUrl.startsWith('https://'))) {\n\t          canSave = false;\n\t          errorMessages.intentUrl = 'URL must start with http:// or https://.';\n\t        } else if (!_intentUrl.includes('{text}')) {\n\t          canSave = false;\n", "          errorMessages.intentUrl = 'URL must include {text} to take text to be posted.';\n\t        }\n\t      }\n\t      errors.set(errorMessages);\n\t      // --- end validation ---\n\t      try {\n\t        if (canSave) {\n\t          await savePreferences({\n\t            postMethod: _postMethod,\n\t            nsec: _nsec,\n", "            npub: _npub,\n\t            relayUrls: _relayUrls,\n\t            intentUrl: _intentUrl,\n\t            noteTemplate: get(noteTemplate),\n\t            enableContextMenu: get(enableContextMenu),\n\t          });\n\t          const packet: Packet = {\n\t            ext: 'share-on-nostr',\n\t            kind: 'updatePreferences',\n\t          };\n", "          chrome.runtime.sendMessage(packet);\n\t          return 'success';\n\t        } else {\n\t          return 'validation-error';\n\t        }\n\t      } catch (err) {\n\t        console.error(err);\n\t        return 'unknown-error';\n\t      }\n\t    },\n", "  };\n\t}\n"]}
{"filename": "src/pages/preferences/index.ts", "chunked_list": ["import App from './Preferences.svelte';\n\timport '../../lib/svelte-material-ui';\n\tconst app = new (App as any)({\n\t  target: document.getElementById('app')!,\n\t});\n\texport default app;\n"]}
{"filename": "src/lib/svelte-material-ui.ts", "chunked_list": ["import 'svelte-material-ui/bare.css';\n\timport 'svelte-material-ui/themes/svelte.css';\n\timport 'material-icons/iconfont/material-icons.css';\n"]}
{"filename": "src/lib/store.ts", "chunked_list": ["export interface ShareOnNostrPreferences {\n\t  postMethod: NostrPostMethod;\n\t  nsec: string;\n\t  npub: string;\n\t  relayUrls: string[];\n\t  intentUrl: string;\n\t  noteTemplate: string;\n\t  enableContextMenu: boolean;\n\t}\n\texport type NostrPostMethod = 'nip07' | 'nsec' | 'externalApp';\n", "export async function savePreferences(pref: ShareOnNostrPreferences) {\n\t  await Promise.all([\n\t    save('postMethod', 'v1', pref.postMethod),\n\t    save('nsec', 'v1', pref.nsec),\n\t    save('npub', 'v1', pref.npub),\n\t    save('relayUrls', 'v1', pref.relayUrls),\n\t    save('intentUrl', 'v1', pref.intentUrl),\n\t    save('noteTemplate', 'v1', pref.noteTemplate),\n\t    save('enableContextMenu', 'v1', pref.enableContextMenu),\n\t  ]);\n", "}\n\tinterface AppStorage {\n\t  postMethod: ['v1', NostrPostMethod];\n\t  nsec: ['v1', string];\n\t  npub: ['v1', string];\n\t  relayUrls: ['v1', string[]];\n\t  intentUrl: ['v1', string];\n\t  noteTemplate: ['v1', string];\n\t  enableContextMenu: ['v1', boolean];\n\t}\n", "type AppStorageDefaultValues = {\n\t  [K in keyof AppStorage]: AppStoredData<K>;\n\t};\n\tconst defaultValues: AppStorageDefaultValues = {\n\t  postMethod: 'nip07',\n\t  npub: '',\n\t  nsec: '',\n\t  relayUrls: [],\n\t  intentUrl: '',\n\t  noteTemplate: '{title} {url}',\n", "  enableContextMenu: true,\n\t};\n\ttype AppStoredDataVersion<K extends keyof AppStorage> = AppStorage[K][0];\n\ttype AppStoredData<K extends keyof AppStorage> = AppStorage[K][1];\n\texport async function load<K extends keyof AppStorage>(\n\t  key: K,\n\t  version: AppStoredDataVersion<K>,\n\t): Promise<AppStoredData<K>> {\n\t  try {\n\t    const { [key]: data } = await chrome.storage.local.get(key);\n", "    const [storedVersion, val]: AppStorage[K] = data;\n\t    if (storedVersion === version) {\n\t      return val;\n\t    } else {\n\t      return defaultValues[key];\n\t    }\n\t  } catch {\n\t    return defaultValues[key];\n\t  }\n\t}\n", "export function getDefault<K extends keyof AppStorage>(key: K): AppStoredData<K> {\n\t  return defaultValues[key];\n\t}\n\tasync function save<K extends keyof AppStorage>(\n\t  key: K,\n\t  version: AppStoredDataVersion<K>,\n\t  val: AppStoredData<K>,\n\t): Promise<void> {\n\t  await chrome.storage.local.set({ [key]: [version, val] });\n\t}\n"]}
{"filename": "src/lib/nostr/primitive.ts", "chunked_list": ["export namespace Nostr {\n\t  export interface Event<K = number> {\n\t    id: string;\n\t    sig: string;\n\t    kind: K;\n\t    tags: string[][];\n\t    pubkey: string;\n\t    content: string;\n\t    created_at: number;\n\t  }\n", "  export interface UnsignedEvent<K = number> {\n\t    kind: K;\n\t    tags: string[][];\n\t    pubkey: string;\n\t    content: string;\n\t    created_at: number;\n\t  }\n\t  export interface EventParameters<K = number> {\n\t    id?: string;\n\t    sig?: string;\n", "    kind: K;\n\t    tags?: string[][];\n\t    pubkey?: string;\n\t    content: string;\n\t    created_at?: number;\n\t  }\n\t  export enum Kind {\n\t    Metadata = 0,\n\t    Text = 1,\n\t    RecommendRelay = 2,\n", "    Contacts = 3,\n\t    EncryptedDirectMessage = 4,\n\t    EventDeletion = 5,\n\t    Repost = 6,\n\t    Reaction = 7,\n\t    BadgeAward = 8,\n\t    ChannelCreation = 40,\n\t    ChannelMetadata = 41,\n\t    ChannelMessage = 42,\n\t    ChannelHideMessage = 43,\n", "    ChannelMuteUser = 44,\n\t    Blank = 255,\n\t    Report = 1984,\n\t    ZapRequest = 9734,\n\t    Zap = 9735,\n\t    RelayList = 10002,\n\t    Auth = 22242,\n\t    BadgeDefinition = 30008,\n\t    ProfileBadge = 30009,\n\t    Article = 30023,\n", "  }\n\t  export type TagName = `#${string}`;\n\t  export interface Filter {\n\t    ids?: string[];\n\t    kinds?: number[];\n\t    authors?: string[];\n\t    since?: number;\n\t    until?: number;\n\t    limit?: number;\n\t    [key: TagName]: string[];\n", "  }\n\t}\n"]}
{"filename": "src/lib/nostr/bech32.ts", "chunked_list": ["import { bytesToHex } from '@noble/hashes/utils';\n\timport { bech32 } from '@scure/base';\n\texport function toHex(str: string): string {\n\t  const { words } = bech32.decode(str);\n\t  const data = new Uint8Array(bech32.fromWords(words));\n\t  return bytesToHex(data);\n\t}\n"]}
{"filename": "src/lib/nostr/nip07.ts", "chunked_list": ["export interface Nip07 {\n\t  getPublicKey: () => Promise<string>;\n\t  signEvent: (event: {\n\t    kind: number;\n\t    tags: string[][];\n\t    content: string;\n\t    created_at: number;\n\t  }) => Promise<{\n\t    id: string;\n\t    sig: string;\n", "    kind: number;\n\t    tags: string[][];\n\t    pubkey: string;\n\t    content: string;\n\t    created_at: number;\n\t  }>;\n\t  getRelays(): Promise<{ [url: string]: { read: boolean; write: boolean } }>;\n\t}\n\tdeclare global {\n\t  interface Window {\n", "    nostr?: Nip07;\n\t  }\n\t}\n"]}
{"filename": "src/lib/nostr/event.ts", "chunked_list": ["import { schnorr } from '@noble/curves/secp256k1';\n\timport { sha256 } from '@noble/hashes/sha256';\n\timport { bytesToHex } from '@noble/hashes/utils';\n\timport { toHex } from './bech32';\n\timport { Nostr } from './primitive';\n\tconst utf8Encoder = new TextEncoder();\n\texport function getPublicKey(seckey: string): string {\n\t  return bytesToHex(schnorr.getPublicKey(seckey));\n\t}\n\texport function createEventBySecretKey(params: Nostr.EventParameters, seckey: string): Nostr.Event {\n", "  const sechex = seckey?.startsWith('nsec1') ? toHex(seckey) : seckey;\n\t  const pubhex = !params.pubkey\n\t    ? getPublicKey(sechex)\n\t    : params.pubkey.startsWith('npub1')\n\t    ? toHex(params.pubkey)\n\t    : params.pubkey;\n\t  const event = {\n\t    ...params,\n\t    tags: params.tags ?? [],\n\t    pubkey: pubhex,\n", "    created_at: params.created_at ?? getCreatedAt(),\n\t  };\n\t  const id = event.id ?? getEventHash(event);\n\t  const sig = event.sig ?? getSignature(id, sechex);\n\t  return {\n\t    ...event,\n\t    id,\n\t    sig,\n\t  };\n\t}\n", "export async function createEventByNip07(params: Nostr.EventParameters): Promise<Nostr.Event> {\n\t  const nostr = (window ?? {})?.nostr;\n\t  if (!nostr) {\n\t    throw new Error('NIP-07 interface is not ready.');\n\t  }\n\t  return nostr.signEvent({\n\t    kind: params.kind,\n\t    tags: params.tags ?? [],\n\t    content: params.content,\n\t    created_at: params.created_at ?? getCreatedAt(),\n", "  });\n\t}\n\texport function getEventHash(event: Nostr.UnsignedEvent): string {\n\t  const serialized = JSON.stringify([\n\t    0,\n\t    event.pubkey,\n\t    event.created_at,\n\t    event.kind,\n\t    event.tags,\n\t    event.content,\n", "  ]);\n\t  return bytesToHex(sha256(utf8Encoder.encode(serialized)));\n\t}\n\texport function getSignature(eventHash: string, seckey: string): string {\n\t  return bytesToHex(schnorr.sign(eventHash, seckey));\n\t}\n\tfunction getCreatedAt() {\n\t  return Math.floor(new Date().getTime() / 1000);\n\t}\n"]}
{"filename": "src/@types/common/index.d.ts", "chunked_list": ["type ExtName = 'share-on-nostr';\n\ttype Packet = { ext: ExtName } & (\n\t  | { kind: 'share'; tabId: number; text: string; url: string }\n\t  | { kind: 'relays'; relays: string[] }\n\t  | { kind: 'result'; url: string; success: boolean }\n\t  | { kind: 'updatePreferences' }\n\t);\n"]}
{"filename": "src/resource/share-on-nostr.ts", "chunked_list": ["window.addEventListener('message', async ({ data }: MessageEvent<Packet>) => {\n\t  if (data.ext !== 'share-on-nostr') {\n\t    return;\n\t  }\n\t  if (data.kind === 'share') {\n\t    shareOnNostr(data.text, data.url);\n\t  }\n\t});\n\tasync function shareOnNostr(message: string, url: string) {\n\t  const nostr = window.nostr;\n", "  if (!nostr) {\n\t    console.warn('NIP-07 interface is not found.');\n\t    return;\n\t  }\n\t  const relays = await nostr.getRelays();\n\t  const writableRelays = Object.entries(relays)\n\t    .filter(([, { write }]) => write)\n\t    .map(([url]) => url);\n\t  const packet: Packet = {\n\t    ext: 'share-on-nostr',\n", "    kind: 'relays',\n\t    relays: writableRelays,\n\t  };\n\t  window.postMessage(packet);\n\t  if (writableRelays.length <= 0) {\n\t    console.warn('No writable relays.');\n\t    return;\n\t  }\n\t  const event = JSON.stringify([\n\t    'EVENT',\n", "    await nostr.signEvent({\n\t      kind: 1,\n\t      tags: [['r', url]],\n\t      content: message,\n\t      created_at: Math.floor(new Date().getTime() / 1000),\n\t    }),\n\t  ]);\n\t  for (const url of writableRelays) {\n\t    const ws = new WebSocket(url);\n\t    ws.addEventListener('open', () => {\n", "      ws.send(event);\n\t    });\n\t    ws.addEventListener('error', () => {\n\t      const packet: Packet = {\n\t        ext: 'share-on-nostr',\n\t        kind: 'result',\n\t        url,\n\t        success: false,\n\t      };\n\t      window.postMessage(packet);\n", "    });\n\t    ws.addEventListener('message', ({ data }) => {\n\t      const [ok] = JSON.parse(data);\n\t      const packet: Packet = {\n\t        ext: 'share-on-nostr',\n\t        kind: 'result',\n\t        url,\n\t        success: ok === 'OK',\n\t      };\n\t      window.postMessage(packet);\n", "      ws.close();\n\t    });\n\t  }\n\t}\n\tinterface UnsignedEvent {\n\t  kind: number;\n\t  tags: string[][];\n\t  content: string;\n\t  created_at: number;\n\t}\n", "interface SignedEvent extends UnsignedEvent {\n\t  id: string;\n\t  sig: string;\n\t  pubkey: string;\n\t}\n\tinterface Nip07 {\n\t  getPublicKey: () => Promise<string>;\n\t  signEvent: (event: {\n\t    kind: number;\n\t    tags: string[][];\n", "    content: string;\n\t    created_at: number;\n\t  }) => Promise<{\n\t    id: string;\n\t    sig: string;\n\t    kind: number;\n\t    tags: string[][];\n\t    pubkey: string;\n\t    content: string;\n\t    created_at: number;\n", "  }>;\n\t  getRelays(): Promise<{ [url: string]: { read: boolean; write: boolean } }>;\n\t}\n\tinterface Window {\n\t  nostr?: Nip07;\n\t}\n"]}
