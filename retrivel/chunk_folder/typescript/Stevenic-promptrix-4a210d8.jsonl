{"filename": "src/GroupSection.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { GroupSection } from \"./GroupSection\";\n\timport { TextSection } from \"./TextSection\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\timport { FunctionRegistry } from \"./FunctionRegistry\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"GroupSection\", () => {\n\t    const memory = new VolatileMemory();\n\t    const functions = new FunctionRegistry();\n\t    const tokenizer = new GPT3Tokenizer();\n", "    describe(\"constructor\", () => {\n\t        it(\"should create a GroupSection\", () => {\n\t            const section = new GroupSection([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ]);\n\t            assert.equal(section.sections.length, 1);\n\t            assert.equal(section.tokens, -1);\n\t            assert.equal(section.required, true);\n\t            assert.equal(section.separator, \"\\n\\n\");\n\t        });\n", "        it(\"should create a GroupSection with a custom params\", () => {\n\t            const section = new GroupSection([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ], 'user', 100, false, \" \");\n\t            assert.equal(section.sections.length, 1);\n\t            assert.equal(section.role, 'user');\n\t            assert.equal(section.tokens, 100);\n\t            assert.equal(section.required, false);\n\t            assert.equal(section.separator, \" \");\n\t        });\n", "    });\n\t    describe(\"renderAsMessages\", () => {\n\t        it(\"should render a TextSection to an array of messages\", async () => {\n\t            const section = new GroupSection([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ]);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n", "        });\n\t        it(\"should identify a output as being too long\", async () => {\n\t            const section = new GroupSection([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ]);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n\t            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, true);\n\t        });\n", "        it(\"should render multiple TextSections as a single messages\", async () => {\n\t            const section = new GroupSection([\n\t                new TextSection(\"Hello\", \"user\"),\n\t                new TextSection(\"World\", \"user\")\n\t            ]);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello\\n\\nWorld\" }]);\n\t            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n", "        it(\"should render a hierarchy of sections to a single message\", async () => {\n\t            const section = new GroupSection([\n\t                new GroupSection([\n\t                    new TextSection(\"Hello\", \"user\")\n\t                ]),\n\t                new TextSection(\"World\", \"user\")\n\t            ]);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello\\n\\nWorld\" }]);\n\t            assert.equal(rendered.length, 4);\n", "            assert.equal(rendered.tooLong, false);\n\t        });\n\t    });\n\t    describe(\"renderAsText\", () => {\n\t        it(\"should render a TextSection to a string\", async () => {\n\t            const section = new GroupSection([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ]);\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello World\");\n", "            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should identify a text output as being too long\", async () => {\n\t            const section = new GroupSection([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ]);\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 1);\n\t            assert.equal(rendered.output, \"Hello World\");\n\t            assert.equal(rendered.length, 2);\n", "            assert.equal(rendered.tooLong, true);\n\t        });\n\t        it(\"should render multiple TextSections to a string\", async () => {\n\t            const section = new GroupSection([\n\t                new TextSection(\"Hello\", \"user\"),\n\t                new TextSection(\"World\", \"user\")\n\t            ]);\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n\t            assert.equal(rendered.length, 4);\n", "            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should render a hierarchy of sections to a string\", async () => {\n\t            const section = new GroupSection([\n\t                new GroupSection([\n\t                    new TextSection(\"Hello\", \"user\")\n\t                ]),\n\t                new TextSection(\"World\", \"user\")\n\t            ]);\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n", "            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n\t            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/ConversationHistory.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\n\timport { PromptSectionBase } from \"./PromptSectionBase\";\n\timport { Utilities } from \"./Utilities\";\n\t/**\n\t * A section that renders the conversation history.\n\t */\n\texport class ConversationHistory extends PromptSectionBase {\n\t    public readonly variable: string;\n\t    public readonly userPrefix: string;\n\t    public readonly assistantPrefix: string;\n", "    /**\n\t     * Creates a new 'ConversationHistory' instance.\n\t     * @param variable Name of memory variable used to store the histories `Message[]`.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `proportional` with a value of `1.0`.\n\t     * @param required Optional. Indicates if this section is required. Defaults to `false`.\n\t     * @param userPrefix Optional. Prefix to use for user messages when rendering as text. Defaults to `user: `.\n\t     * @param assistantPrefix Optional. Prefix to use for assistant messages when rendering as text. Defaults to `assistant: `.\n\t     */\n\t    public constructor(variable: string, tokens: number = 1.0, required: boolean = false, userPrefix: string = 'user: ', assistantPrefix: string = 'assistant: ', separator: string = '\\n') {\n\t        super(tokens, required, separator);\n", "        this.variable = variable;\n\t        this.userPrefix = userPrefix;\n\t        this.assistantPrefix = assistantPrefix;\n\t    }\n\t    public async renderAsText(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<string>> {\n\t      // Get messages from memory\n\t      const history: Message[] = memory.has(this.variable) ? (memory.get(this.variable) as Message[]).slice() : [];\n\t      // Populate history and stay under the token budget\n\t      let tokens = 0;\n\t      const budget = this.tokens > 1.0 ? Math.min(this.tokens, maxTokens) : maxTokens;\n", "      const separatorLength = tokenizer.encode(this.separator).length;\n\t      const lines: string[] = [];\n\t      for (let i = history.length - 1; i >= 0; i--) {\n\t          const msg = history[i];\n\t            const message: Message = { role: msg.role, content: Utilities.toString(tokenizer, msg.content) };\n\t          const prefix = message.role === 'user' ? this.userPrefix : this.assistantPrefix;\n\t          const line = prefix + message.content;\n\t          const length = tokenizer.encode(line).length + (lines.length > 0 ? separatorLength : 0);\n\t          // Add initial line if required\n\t          if (lines.length === 0 && this.required) {\n", "              tokens += length;\n\t              lines.unshift(line);\n\t              continue;\n\t          }\n\t          // Stop if we're over the token budget\n\t          if (tokens + length > budget) {\n\t              break;\n\t          }\n\t          // Add line\n\t          tokens += length;\n", "          lines.unshift(line);\n\t      }\n\t      return { output: lines.join(this.separator), length: tokens, tooLong: tokens > maxTokens };\n\t   }\n\t    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n\t        // Get messages from memory\n\t        const history: Message[] = memory.has(this.variable) ? (memory.get(this.variable) as Message[]).slice() : [];\n\t        // Populate messages and stay under the token budget\n\t        let tokens = 0;\n\t        const budget = this.tokens > 1.0 ? Math.min(this.tokens, maxTokens) : maxTokens;\n", "        const messages: Message[] = [];\n\t        for (let i = history.length - 1; i >= 0; i--) {\n\t            // Clone message\n\t            const msg = history[i];\n\t            const message: Message = Object.assign({}, msg);\n\t            if (msg.content !== null) {\n\t                message.content = Utilities.toString(tokenizer, msg.content);\n\t            }\n\t            // Get message length\n\t            const length = tokenizer.encode(PromptSectionBase.getMessageText(message)).length;\n", "            // Add initial message if required\n\t            if (messages.length === 0 && this.required) {\n\t                tokens += length;\n\t                messages.unshift(message);\n\t                continue;\n\t            }\n\t            // Stop if we're over the token budget\n\t            if (tokens + length > budget) {\n\t                break;\n\t            }\n", "            // Add message\n\t            tokens += length;\n\t            messages.unshift(message);\n\t        }\n\t        return { output: messages, length: tokens, tooLong: tokens > maxTokens };\n\t    }\n\t}"]}
{"filename": "src/FunctionRegistry.ts", "chunked_list": ["import { PromptFunctions, PromptFunction, PromptMemory, Tokenizer } from \"./types\";\n\t/**\n\t * Registry of functions that can be invoked from a prompt template.\n\t */\n\texport class FunctionRegistry implements PromptFunctions {\n\t    private readonly _functions: Map<string, PromptFunction> = new Map<string, PromptFunction>();\n\t    /**\n\t     * Creates a new 'FunctionRegistry' instance.\n\t     * @param functions Optional. Functions to add to this registry.\n\t     */\n", "    public constructor(functions?: Record<string, PromptFunction>) {\n\t        if (functions) {\n\t            for (const key in functions) {\n\t                this._functions.set(key, functions[key]);\n\t            }\n\t        }\n\t    }\n\t    public has(name: string): boolean {\n\t        return this._functions.has(name);\n\t    }\n", "    public get(name: string): PromptFunction {\n\t        const fn = this._functions.get(name);\n\t        if (!fn) {\n\t            throw new Error(`Function '${name}' not found.`);\n\t        }\n\t        return fn;\n\t    }\n\t    public addFunction(name: string, value: PromptFunction): void {\n\t        if (this._functions.has(name)) {\n\t            throw new Error(`Function '${name}' already exists.`);\n", "        }\n\t        this._functions.set(name, value);\n\t    }\n\t    public invoke(key: string, memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, args: string[]): Promise<any> {\n\t        const fn = this.get(key);\n\t        return fn(memory, functions, tokenizer, args);\n\t    }\n\t}"]}
{"filename": "src/SystemMessage.ts", "chunked_list": ["import { TemplateSection } from \"./TemplateSection\";\n\t/**\n\t * A system message.\n\t */\n\texport class SystemMessage extends TemplateSection {\n\t    /**\n\t     * Creates a new 'SystemMessage' instance.\n\t     * @param template Template to use for this section.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n\t     */\n", "    public constructor(template: string, tokens: number = -1) {\n\t        super(template, 'system', tokens, true, '\\n', '');\n\t    }\n\t}"]}
{"filename": "src/UserMessage.ts", "chunked_list": ["import { TemplateSection } from \"./TemplateSection\";\n\t/**\n\t * A user message.\n\t */\n\texport class UserMessage extends TemplateSection {\n\t    /**\n\t     * Creates a new 'UserMessage' instance.\n\t     * @param template Template to use for this section.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n\t     * @param userPrefix Optional. Prefix to use for user messages when rendering as text. Defaults to `user: `.\n", "     */\n\t    public constructor(template: string, tokens: number = -1, userPrefix: string = 'user: ') {\n\t        super(template, 'user', tokens, true, '\\n', userPrefix);\n\t    }\n\t}"]}
{"filename": "src/Prompt.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, PromptSection, RenderedPromptSection, Tokenizer } from \"./types\";\n\timport { LayoutEngine } from \"./LayoutEngine\";\n\t/**\n\t * Top level prompt section.\n\t * @remarks\n\t * Prompts are compositional such that they can be nested to create complex prompt hierarchies.\n\t */\n\texport class Prompt extends LayoutEngine {\n\t    /**\n\t     * Creates a new 'Prompt' instance.\n", "     * @param sections Sections to render.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n\t     * @param required Optional. Indicates if this section is required. Defaults to `true`.\n\t     * @param separator Optional. Separator to use between sections when rendering as text. Defaults to `\\n\\n`.\n\t     */\n\t    public constructor(sections: PromptSection[], tokens: number = -1, required: boolean = true, separator: string = '\\n\\n') {\n\t        super(sections, tokens, required, separator);\n\t    }\n\t}\n"]}
{"filename": "src/LayoutEngine.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, PromptSection, RenderedPromptSection, Tokenizer } from \"./types\";\n\t/**\n\t * Base layout engine that renders a set of `auto`, `fixed`, or `proportional` length sections.\n\t * @remarks\n\t * This class is used internally by the `Prompt` and `GroupSection` classes to render their sections.\n\t */\n\texport class LayoutEngine implements PromptSection {\n\t    public readonly sections: PromptSection[];\n\t    public readonly required: boolean;\n\t    public readonly tokens: number;\n", "    public readonly separator: string;\n\t    public constructor(sections: PromptSection[], tokens: number, required: boolean, separator: string) {\n\t        this.sections = sections;\n\t        this.required = required;\n\t        this.tokens = tokens;\n\t        this.separator = separator;\n\t    }\n\t    public async renderAsText(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<string>> {\n\t        // Start a new layout\n\t        // - Adds all sections from the current LayoutEngine hierarchy to a flat array\n", "        const layout: PromptSectionLayout<string>[] = [];\n\t        this.addSectionsToLayout(this.sections, layout);\n\t        // Layout sections\n\t        const remaining = await this.layoutSections(\n\t            layout,\n\t            maxTokens,\n\t            (section) => section.renderAsText(memory, functions, tokenizer, maxTokens),\n\t            (section, remaining) => section.renderAsText(memory, functions, tokenizer, remaining),\n\t            true,\n\t            tokenizer\n", "        );\n\t        // Build output\n\t        const output: string[] = [];\n\t        for (let i = 0; i < layout.length; i++) {\n\t            const section = layout[i];\n\t            if (section.layout) {\n\t                output.push(section.layout.output);\n\t            }\n\t        }\n\t        const text = output.join(this.separator);\n", "        return { output: text, length: tokenizer.encode(text).length, tooLong: remaining < 0 };\n\t    }\n\t    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n\t        // Start a new layout\n\t        // - Adds all sections from the current LayoutEngine hierarchy to a flat array\n\t        const layout: PromptSectionLayout<Message[]>[] = [];\n\t        this.addSectionsToLayout(this.sections, layout);\n\t        // Layout sections\n\t        const remaining = await this.layoutSections(\n\t            layout,\n", "            maxTokens,\n\t            (section) => section.renderAsMessages(memory, functions, tokenizer, maxTokens),\n\t            (section, remaining) => section.renderAsMessages(memory, functions, tokenizer, remaining)\n\t        );\n\t        // Build output\n\t        const output: Message[] = [];\n\t        for (let i = 0; i < layout.length; i++) {\n\t            const section = layout[i];\n\t            if (section.layout) {\n\t                output.push(...section.layout.output);\n", "            }\n\t        }\n\t        return { output: output, length: this.getLayoutLength(layout), tooLong: remaining < 0 };\n\t    }\n\t    private addSectionsToLayout<T>(sections: PromptSection[], layout: PromptSectionLayout<T>[]): void {\n\t        for (let i = 0; i < sections.length; i++) {\n\t            const section = sections[i];\n\t            if (section instanceof LayoutEngine) {\n\t                this.addSectionsToLayout(section.sections, layout);\n\t            } else {\n", "                layout.push({ section: section });\n\t            }\n\t        }\n\t    }\n\t    private async layoutSections<T>(\n\t        layout: PromptSectionLayout<T>[],\n\t        maxTokens: number,\n\t        cbFixed: (section: PromptSection) => Promise<RenderedPromptSection<T>>,\n\t        cbProportional: (section: PromptSection, remaining: number) => Promise<RenderedPromptSection<T>>,\n\t        textLayout: boolean = false,\n", "        tokenizer?: Tokenizer\n\t    ): Promise<number> {\n\t        // Layout fixed sections\n\t        await this.layoutFixedSections(layout, cbFixed);\n\t        // Get tokens remaining and drop optional sections if too long\n\t        let remaining = maxTokens - this.getLayoutLength(layout, textLayout, tokenizer);\n\t        while (remaining < 0 && this.dropLastOptionalSection(layout)) {\n\t            remaining = maxTokens - this.getLayoutLength(layout, textLayout, tokenizer);\n\t        }\n\t        // Layout proportional sections\n", "        if (this.needsMoreLayout(layout) && remaining > 0) {\n\t            // Layout proportional sections\n\t            await this.layoutProportionalSections(layout, (section) => cbProportional(section, remaining));\n\t            // Get tokens remaining and drop optional sections if too long\n\t            remaining = maxTokens - this.getLayoutLength(layout, textLayout, tokenizer);\n\t            while (remaining < 0 && this.dropLastOptionalSection(layout)) {\n\t                remaining = maxTokens - this.getLayoutLength(layout, textLayout, tokenizer);\n\t            }\n\t        }\n\t        return remaining;\n", "    }\n\t    private async layoutFixedSections<T>(layout: PromptSectionLayout<T>[], callback: (section: PromptSection) => Promise<RenderedPromptSection<T>>): Promise<void> {\n\t        const promises: Promise<RenderedPromptSection<T>>[] = [];\n\t        for (let i = 0; i < layout.length; i++) {\n\t            const section = layout[i];\n\t            if (section.section.tokens < 0 || section.section.tokens > 1.0) {\n\t                promises.push(callback(section.section).then((output) => section.layout = output));\n\t            }\n\t        }\n\t        await Promise.all(promises);\n", "    }\n\t    private async layoutProportionalSections<T>(layout: PromptSectionLayout<T>[], callback: (section: PromptSection) => Promise<RenderedPromptSection<T>>): Promise<void> {\n\t        const promises: Promise<RenderedPromptSection<T>>[] = [];\n\t        for (let i = 0; i < layout.length; i++) {\n\t            const section = layout[i];\n\t            if (section.section.tokens >= 0.0 && section.section.tokens <= 1.0) {\n\t                promises.push(callback(section.section).then((output) => section.layout = output));\n\t            }\n\t        }\n\t        await Promise.all(promises);\n", "    }\n\t    private getLayoutLength<T>(layout: PromptSectionLayout<T>[], textLayout: boolean = false, tokenizer?: Tokenizer): number {\n\t        if (textLayout && tokenizer) {\n\t            const output: string[] = [];\n\t            for (let i = 0; i < layout.length; i++) {\n\t                const section = layout[i];\n\t                if (section.layout) {\n\t                    output.push(section.layout.output as string);\n\t                }\n\t            }\n", "            return tokenizer.encode(output.join(this.separator)).length;\n\t        } else {\n\t            let length = 0;\n\t            for (let i = 0; i < layout.length; i++) {\n\t                const section = layout[i];\n\t                if (section.layout) {\n\t                    length += section.layout.length;\n\t                }\n\t            }\n\t            return length;\n", "        }\n\t    }\n\t    private dropLastOptionalSection<T>(layout: PromptSectionLayout<T>[]): boolean {\n\t        for (let i = layout.length - 1; i >= 0; i--) {\n\t            const section = layout[i];\n\t            if (!section.section.required) {\n\t                layout.splice(i, 1);\n\t                return true;\n\t            }\n\t        }\n", "        return false;\n\t    }\n\t    private needsMoreLayout<T>(layout: PromptSectionLayout<T>[]): boolean {\n\t        for (let i = 0; i < layout.length; i++) {\n\t            const section = layout[i];\n\t            if (!section.layout) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n", "    }\n\t}\n\tinterface PromptSectionLayout<T> {\n\t    section: PromptSection;\n\t    layout?: RenderedPromptSection<T>;\n\t}"]}
{"filename": "src/PromptSectionBase.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\n\timport { PromptSectionBase } from \"./PromptSectionBase\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\timport { FunctionRegistry } from \"./FunctionRegistry\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\texport class TestSection extends PromptSectionBase {\n\t    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n\t        return this.returnMessages([{ role: 'test', content: 'Hello Big World' }], 3, tokenizer, maxTokens);\n\t    }\n", "}\n\texport class MultiTestSection extends PromptSectionBase {\n\t    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n\t        return this.returnMessages([{ role: 'test', content: 'Hello Big' },{ role: 'test', content: 'World' }], 3, tokenizer, maxTokens);\n\t    }\n\t}\n\tdescribe(\"PromptSectionBase\", () => {\n\t    const memory = new VolatileMemory();\n\t    const functions = new FunctionRegistry();\n\t    const tokenizer = new GPT3Tokenizer();\n", "    describe(\"constructor\", () => {\n\t        it(\"should create a TestSection\", () => {\n\t            const section = new TestSection();\n\t            assert.equal(section.tokens, -1);\n\t            assert.equal(section.required, true);\n\t            assert.equal(section.separator, \"\\n\");\n\t            assert.equal(section.textPrefix, \"\");\n\t        });\n\t    });\n\t    describe(\"renderAsMessages\", () => {\n", "        it(\"should render a TestSection to an array of messages\", async () => {\n\t            const section = new TestSection();\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"test\", content: \"Hello Big World\" }]);\n\t            assert.equal(rendered.length, 3);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should truncate a fixed length TestSection\", async () => {\n\t            const section = new TestSection(2);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n", "            assert.deepEqual(rendered.output, [{ role: \"test\", content: \"Hello Big\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should identify a fixed length TestSection as being tooLong\", async () => {\n\t            const section = new TestSection(2);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n\t            assert.deepEqual(rendered.output, [{ role: \"test\", content: \"Hello Big\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, true);\n", "        });\n\t        it(\"should drop messages to truncate a fixed length MultiTestSection\", async () => {\n\t            const section = new MultiTestSection(2);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"test\", content: \"Hello Big\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t    });\n\t    describe(\"renderAsText\", () => {\n", "        it(\"should render a TestSection to a string\", async () => {\n\t            const section = new TestSection();\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello Big World\");\n\t            assert.equal(rendered.length, 3);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should truncate a fixed length TestSection\", async () => {\n\t            const section = new TestSection(4, true, \"\\n\", \"user: \");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n", "            assert.equal(rendered.output, \"user: Hello Big\");\n\t            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should identify a fixed length TestSection as being tooLong\", async () => {\n\t            const section = new TestSection(4, true, \"\\n\", \"user: \");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 1);\n\t            assert.equal(rendered.output, \"user: Hello Big\");\n\t            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, true);\n", "        });\n\t    });\n\t});\n"]}
{"filename": "src/AssistantMessage.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { AssistantMessage } from \"./AssistantMessage\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\timport { FunctionRegistry } from \"./FunctionRegistry\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"AssistantMessage\", () => {\n\t    const memory = new VolatileMemory();\n\t    const functions = new FunctionRegistry();\n\t    const tokenizer = new GPT3Tokenizer();\n\t    describe(\"constructor\", () => {\n", "        it(\"should create a AssistantMessage\", () => {\n\t            const section = new AssistantMessage(\"Hello World\");\n\t            assert.equal(section.template, \"Hello World\");\n\t            assert.equal(section.role, \"assistant\");\n\t            assert.equal(section.tokens, -1);\n\t            assert.equal(section.required, true);\n\t            assert.equal(section.separator, \"\\n\");\n\t            assert.equal(section.textPrefix, \"assistant: \");\n\t        });\n\t    });\n", "    describe(\"renderAsMessages\", () => {\n\t        it(\"should render a AssistantMessage to an array of messages\", async () => {\n\t            const section = new AssistantMessage(\"Hello World\");\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"assistant\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t    });\n\t    describe(\"renderAsText\", () => {\n", "        it(\"should render a TemplateSection to a string\", async () => {\n\t            const section = new AssistantMessage(\"Hello World\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"assistant: Hello World\");\n\t            assert.equal(rendered.length, 6);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/TemplateSection.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\n\timport { PromptSectionBase } from \"./PromptSectionBase\";\n\timport { Utilities } from \"./Utilities\";\n\t/**\n\t * A template section that will be rendered as a message.\n\t * @remarks\n\t * This section type is used to render a template as a message. The template can contain\n\t * parameters that will be replaced with values from memory or call functions to generate\n\t * dynamic content.\n\t *\n", " * Template syntax:\n\t * - `{{$memoryKey}}` - Renders the value of the specified memory key.\n\t * - `{{functionName}}` - Calls the specified function and renders the result.\n\t * - `{{functionName arg1 arg2 ...}}` - Calls the specified function with the provided list of arguments.\n\t *\n\t * Function arguments are optional and separated by spaces. They can be quoted using `'`, `\"`, or `\\`` delimiters.\n\t */\n\texport class TemplateSection extends PromptSectionBase {\n\t    private _parts: PartRenderer[] = [];\n\t    public readonly template: string;\n", "    public readonly role: string;\n\t    /**\n\t     * Creates a new 'TemplateSection' instance.\n\t     * @param template Template to use for this section.\n\t     * @param role Message role to use for this section.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n\t     * @param required Optional. Indicates if this section is required. Defaults to `true`.\n\t     * @param separator Optional. Separator to use between sections when rendering as text. Defaults to `\\n`.\n\t     * @param textPrefix Optional. Prefix to use for text output. Defaults to `undefined`.\n\t     */\n", "    public constructor(template: string, role: string, tokens: number = -1, required: boolean = true, separator: string = '\\n', textPrefix?: string) {\n\t        super(tokens, required, separator, textPrefix);\n\t        this.template = template;\n\t        this.role = role;\n\t        this.parseTemplate();\n\t    }\n\t    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n\t        // Render parts in parallel\n\t        const renderedParts = await Promise.all(this._parts.map((part) => part(memory, functions, tokenizer, maxTokens)));\n\t        // Join all parts\n", "        const text = renderedParts.join('');\n\t        const length = tokenizer.encode(text).length;\n\t        // Return output\n\t        return this.returnMessages([{ role: this.role, content: text }], length, tokenizer, maxTokens);\n\t    }\n\t    private parseTemplate(): void {\n\t        // Parse template\n\t        let part = '';\n\t        let state = ParseState.inText;\n\t        let stringDelim = '';\n", "        for (let i = 0; i < this.template.length; i++) {\n\t            const char = this.template[i];\n\t            switch (state) {\n\t                case ParseState.inText:\n\t                    if (char === '{' && this.template[i + 1] === '{') {\n\t                        if (part.length > 0) {\n\t                            this._parts.push(this.createTextRenderer(part));\n\t                            part = '';\n\t                        }\n\t                        state = ParseState.inParameter;\n", "                        i++;\n\t                    } else {\n\t                        part += char;\n\t                    }\n\t                    break;\n\t                case ParseState.inParameter:\n\t                    if (char === '}' && this.template[i + 1] === '}') {\n\t                        if (part.length > 0) {\n\t                            if (part[0] === '$') {\n\t                                this._parts.push(this.createVariableRenderer(part.substring(1)));\n", "                            } else {\n\t                                this._parts.push(this.createFunctionRenderer(part));\n\t                            }\n\t                            part = '';\n\t                        }\n\t                        state = ParseState.inText;\n\t                        i++;\n\t                    } else if ([\"'\", '\"', '`'].includes(char)) {\n\t                        stringDelim = char;\n\t                        state = ParseState.inString;\n", "                        part += char;\n\t                    } else {\n\t                        part += char;\n\t                    }\n\t                    break;\n\t                case ParseState.inString:\n\t                    part += char;\n\t                    if (char === stringDelim) {\n\t                        state = ParseState.inParameter;\n\t                    }\n", "                    break;\n\t            }\n\t        }\n\t        // Ensure we ended in the correct state\n\t        if (state !== ParseState.inText) {\n\t            throw new Error(`Invalid template: ${this.template}`);\n\t        }\n\t        // Add final part\n\t        if (part.length > 0) {\n\t            this._parts.push(this.createTextRenderer(part));\n", "        }\n\t    }\n\t    private createTextRenderer(text: string): PartRenderer {\n\t        return (memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<string> => {\n\t            return Promise.resolve(text);\n\t        };\n\t    }\n\t    private createVariableRenderer(name: string): PartRenderer {\n\t        return (memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<string> => {\n\t            const vaue = memory.get(name);\n", "            return Promise.resolve(Utilities.toString(tokenizer, vaue));\n\t        };\n\t    }\n\t    private createFunctionRenderer(param: string): PartRenderer {\n\t        let name = '';\n\t        let args: string[] = [];\n\t        function savePart() {\n\t            if (part.length > 0) {\n\t                if (!name) {\n\t                    name = part;\n", "                } else {\n\t                    args.push(part);\n\t                }\n\t                part = '';\n\t            }\n\t        }\n\t        // Parse function name and args\n\t        let part = '';\n\t        let state = ParseState.inText;\n\t        let stringDelim = '';\n", "        for (let i = 0; i < param.length; i++) {\n\t            const char = param[i];\n\t            switch (state) {\n\t                case ParseState.inText:\n\t                    if ([\"'\", '\"', '`'].includes(char)) {\n\t                        savePart();\n\t                        stringDelim = char;\n\t                        state = ParseState.inString;\n\t                    } else if (char == ' ') {\n\t                        savePart();\n", "                    } else {\n\t                        part += char;\n\t                    }\n\t                    break;\n\t                case ParseState.inString:\n\t                    if (char === stringDelim) {\n\t                        savePart();\n\t                        state = ParseState.inText;\n\t                    } else {\n\t                        part += char;\n", "                    }\n\t                    break;\n\t            }\n\t        }\n\t        // Add final part\n\t        savePart();\n\t        // Return renderer\n\t        return async (memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<string> => {\n\t            const value = await functions.invoke(name, memory, functions, tokenizer, args);\n\t            return Utilities.toString(tokenizer, value);\n", "        };\n\t    }\n\t}\n\ttype PartRenderer = (memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number) => Promise<string>;\n\tenum ParseState {\n\t    inText,\n\t    inParameter,\n\t    inString\n\t}"]}
{"filename": "src/types.ts", "chunked_list": ["export interface PromptSection {\n\t    /**\n\t     * If true the section is mandatory otherwise it can be safely dropped.\n\t     */\n\t    readonly required: boolean;\n\t    /**\n\t     * The requested token budget for this section.\n\t     * - Values between 0.0 and 1.0 represent a percentage of the total budget and the section will be layed out proportionally to all other sections.\n\t     * - Values greater than 1.0 represent the max number of tokens the section should be allowed to consume.\n\t     */\n", "    readonly tokens: number;\n\t    /**\n\t     * Renders the section as a string of text.\n\t     * @param memory Memory that can be referenced by the section.\n\t     * @param functions Registry of functions that can be used by the section.\n\t     * @param tokenizer Tokenizer to use when rendering the section.\n\t     * @param maxTokens Maximum number of tokens allowed to be rendered.\n\t     */\n\t    renderAsText(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<string>>;\n\t    /**\n", "     * Renders the section as a list of messages.\n\t     * @param memory Memory that can be referenced by the section.\n\t     * @param functions Registry of functions that can be used by the section.\n\t     * @param tokenizer Tokenizer to use when rendering the section.\n\t     * @param maxTokens Maximum number of tokens allowed to be rendered.\n\t     */\n\t    renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>>;\n\t}\n\texport interface RenderedPromptSection<T> {\n\t    /**\n", "     * The section that was rendered.\n\t     */\n\t    output: T;\n\t    /**\n\t     * The number of tokens that were rendered.\n\t     */\n\t    length: number;\n\t    /**\n\t     * If true the section was truncated because it exceeded the maxTokens budget.\n\t     */\n", "    tooLong: boolean;\n\t}\n\texport interface Message<TContent = string> {\n\t    /**\n\t     * The messages role. Typically 'system', 'user', 'assistant', 'function'.\n\t     */\n\t    role: string;\n\t    /**\n\t     * Text of the message.\n\t     */\n", "    content: TContent|null;\n\t    /**\n\t     * Optional. A named function to call.\n\t     */\n\t    function_call?: FunctionCall;\n\t    /**\n\t     * Optional. Name of the function that was called.\n\t     */\n\t    name?: string;\n\t}\n", "export interface FunctionCall {\n\t    name?: string;\n\t    arguments?: string;\n\t}\n\texport interface PromptMemory {\n\t    has(key: string): boolean;\n\t    get<TValue = any>(key: string): TValue;\n\t    set<TValue = any>(key: string, value: TValue): void;\n\t    delete(key: string): void;\n\t    clear(): void;\n", "}\n\texport interface PromptFunctions {\n\t    has(name: string): boolean;\n\t    get(name: string): PromptFunction;\n\t    invoke(name: string, memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, args: string[]): Promise<any>;\n\t}\n\texport interface Tokenizer {\n\t    decode(tokens: number[]): string;\n\t    encode(text: string): number[];\n\t}\n", "export type PromptFunction<TArgs = any> = (memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, args: TArgs) => Promise<any>;"]}
{"filename": "src/VolatileMemory.ts", "chunked_list": ["import { PromptMemory } from \"./types\";\n\t/**\n\t * An in-memory store that lives for the length of the process.\n\t */\n\texport class VolatileMemory implements PromptMemory {\n\t    private readonly _memory: Map<string, any> = new Map<string, any>();\n\t    /**\n\t     * Creates a new 'VolatileMemory' instance.\n\t     * @param memory Optional. Variables to initialize this instance with.\n\t     */\n", "    public constructor(memory?: Record<string, any>) {\n\t        if (memory) {\n\t            for (const key in memory) {\n\t                this._memory.set(key, memory[key]);\n\t            }\n\t        }\n\t    }\n\t    public has(key: string): boolean {\n\t        return this._memory.has(key);\n\t    }\n", "    public get(key: string): any {\n\t        const value = this._memory.get(key);\n\t        if (value !== null && typeof value === \"object\") {\n\t            return JSON.parse(JSON.stringify(value));\n\t        } else {\n\t            return value;\n\t        }\n\t    }\n\t    public set(key: string, value: any): void {\n\t        if (value !== null && typeof value === \"object\") {\n", "            const clone = JSON.parse(JSON.stringify(value));\n\t            this._memory.set(key, clone);\n\t        } else {\n\t            this._memory.set(key, value);\n\t        }\n\t    }\n\t    public delete(key: string): void {\n\t        this._memory.delete(key);\n\t    }\n\t    public clear(): void {\n", "        this._memory.clear();\n\t    }\n\t}"]}
{"filename": "src/Prompt.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { Prompt } from \"./Prompt\";\n\timport { TextSection } from \"./TextSection\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\timport { FunctionRegistry } from \"./FunctionRegistry\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"Prompt\", () => {\n\t    const memory = new VolatileMemory();\n\t    const functions = new FunctionRegistry();\n\t    const tokenizer = new GPT3Tokenizer();\n", "    describe(\"constructor\", () => {\n\t        it(\"should create a Prompt\", () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ]);\n\t            assert.equal(prompt.sections.length, 1);\n\t            assert.equal(prompt.tokens, -1);\n\t            assert.equal(prompt.required, true);\n\t            assert.equal(prompt.separator, \"\\n\\n\");\n\t        });\n", "        it(\"should create a Prompt with a custom params\", () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ], 100, false, \" \");\n\t            assert.equal(prompt.sections.length, 1);\n\t            assert.equal(prompt.tokens, 100);\n\t            assert.equal(prompt.required, false);\n\t            assert.equal(prompt.separator, \" \");\n\t        });\n\t    });\n", "    describe(\"renderAsMessages\", () => {\n\t        it(\"should render a TextSection to an array of messages\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ]);\n\t            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n", "        it(\"should identify a output as being too long\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ]);\n\t            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 1);\n\t            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, true);\n\t        });\n\t        it(\"should render multiple TextSections to an array of messages\", async () => {\n", "            const prompt = new Prompt([\n\t                new TextSection(\"Hello\", \"user\"),\n\t                new TextSection(\"World\", \"user\")\n\t            ]);\n\t            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello\" }, { role: \"user\", content: \"World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should render a hierarchy of prompts to an array of messages\", async () => {\n", "            const prompt = new Prompt([\n\t                new Prompt([\n\t                    new TextSection(\"Hello\", \"user\")\n\t                ]),\n\t                new TextSection(\"World\", \"user\")\n\t            ]);\n\t            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello\" }, { role: \"user\", content: \"World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n", "        });\n\t    });\n\t    describe(\"renderAsText\", () => {\n\t        it(\"should render a TextSection to a string\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ]);\n\t            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello World\");\n\t            assert.equal(rendered.length, 2);\n", "            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should identify a text output as being too long\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello World\", \"user\")\n\t            ]);\n\t            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 1);\n\t            assert.equal(rendered.output, \"Hello World\");\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, true);\n", "        });\n\t        it(\"should render multiple TextSections to a string\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello\", \"user\"),\n\t                new TextSection(\"World\", \"user\")\n\t            ]);\n\t            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n\t            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, false);\n", "        });\n\t        it(\"should render a hierarchy of prompts to a string\", async () => {\n\t            const prompt = new Prompt([\n\t                new Prompt([\n\t                    new TextSection(\"Hello\", \"user\")\n\t                ]),\n\t                new TextSection(\"World\", \"user\")\n\t            ]);\n\t            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n", "            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t    });\n\t    describe(\"proportional rendering\", () => {\n\t        it(\"should render both fixed and proportional sections as messages\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello\", \"user\", 10, true),\n\t                new TextSection(\"There Big\", \"user\", 1.0, false),\n\t                new TextSection(\"World\", \"user\", 10, true)\n", "            ]);\n\t            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [\n\t                { role: \"user\", content: \"Hello\" },\n\t                { role: \"user\", content: \"There Big\" },\n\t                { role: \"user\", content: \"World\" }\n\t            ]);\n\t            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n", "        it(\"should render both fixed and proportional sections as text\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello\", \"user\", 10, true),\n\t                new TextSection(\"There Big\", \"user\", 1.0, false),\n\t                new TextSection(\"World\", \"user\", 10, true)\n\t            ]);\n\t            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello\\n\\nThere Big\\n\\nWorld\");\n\t            assert.equal(rendered.length, 8);\n\t            assert.equal(rendered.tooLong, false);\n", "        });\n\t        it(\"should render only fixed sections\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello\", \"user\", 10, true),\n\t                new TextSection(\"World\", \"user\", 10, true)\n\t            ]);\n\t            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 2);\n\t            assert.deepEqual(rendered.output, [\n\t                { role: \"user\", content: \"Hello\" },\n\t                { role: \"user\", content: \"World\" }\n", "            ]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should drop optional sections as needed\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello\", \"user\", 10, true),\n\t                new TextSection(\"There Big\", \"user\", 0.5, false),\n\t                new TextSection(\"World\", \"user\", 0.5, true)\n\t            ]);\n", "            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 4);\n\t            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n\t            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should drop multiple optional sections as needed\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello\", \"user\", 10, true),\n\t                new TextSection(\"There\", \"user\", 10, false),\n\t                new TextSection(\"Big\", \"user\", 10, false),\n", "                new TextSection(\"World\", \"user\", 10, true)\n\t            ]);\n\t            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 2);\n\t            assert.deepEqual(rendered.output, [\n\t                { role: \"user\", content: \"Hello\" },\n\t                { role: \"user\", content: \"World\" }\n\t            ]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n", "        it(\"should keep required sections even if too long\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello\", \"user\", 10, true),\n\t                new TextSection(\"There Big\", \"user\", 0.5, false),\n\t                new TextSection(\"World\", \"user\", 0.5, true)\n\t            ]);\n\t            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 2);\n\t            assert.equal(rendered.output, \"Hello\\n\\nWorld\");\n\t            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, true);\n", "        });\n\t        it(\"should skip rendering proportional sections if fixed sections too big\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello There\", \"user\", 10, true),\n\t                new TextSection(\"Big\", \"user\", 0.5, true),\n\t                new TextSection(\"World\", \"user\", 0.5, true)\n\t            ]);\n\t            const rendered = await prompt.renderAsText(memory, functions, tokenizer, 1);\n\t            assert.equal(rendered.output, \"Hello There\");\n\t            assert.equal(rendered.length, 2);\n", "            assert.equal(rendered.tooLong, true);\n\t        });\n\t        it(\"should skip rendering proportional sections if fixed sections too big for messages\", async () => {\n\t            const prompt = new Prompt([\n\t                new TextSection(\"Hello There\", \"user\", 10, true),\n\t                new TextSection(\"Big\", \"user\", 0.5, true),\n\t                new TextSection(\"World\", \"user\", 0.5, true)\n\t            ]);\n\t            const rendered = await prompt.renderAsMessages(memory, functions, tokenizer, 1);\n\t            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello There\" }]);\n", "            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, true);\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/FunctionRegistry.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { FunctionRegistry } from \"./FunctionRegistry\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"FunctionRegistry\", () => {\n\t    describe(\"constructor\", () => {\n\t        it(\"should create a FunctionRegistry\", () => {\n\t            const registry = new FunctionRegistry();\n\t            assert.notEqual(registry, null);\n\t            assert.equal(registry.has(\"test\"), false);\n", "        });\n\t        it(\"should create a FunctionRegistry with initial functions\", () => {\n\t            const registry = new FunctionRegistry({\n\t                \"test\": async (memory, functions, tokenizer, args) => { }\n\t            });\n\t            assert.notEqual(registry, null);\n\t            assert.equal(registry.has(\"test\"), true);\n\t        });\n\t    });\n\t    describe(\"addFunction\", () => {\n", "        it(\"should add a function\", () => {\n\t            const registry = new FunctionRegistry();\n\t            registry.addFunction(\"test\", async (memory, functions, tokenizer, args) => { });\n\t            assert.equal(registry.has(\"test\"), true);\n\t        });\n\t        it(\"should throw when adding a function that already exists\", () => {\n\t            const registry = new FunctionRegistry({\n\t                \"test\": async (memory, functions, tokenizer, args) => { }\n\t            });\n\t            assert.throws(() => registry.addFunction(\"test\", async (memory, functions, tokenizer, args) => { }));\n", "        });\n\t    });\n\t    describe(\"get\", () => {\n\t        it(\"should get a function\", () => {\n\t            const registry = new FunctionRegistry({\n\t                \"test\": async (memory, functions, tokenizer, args) => { }\n\t            });\n\t            const fn = registry.get(\"test\");\n\t            assert.notEqual(fn, null);\n\t        });\n", "        it(\"should throw when getting a function that doesn't exist\", () => {\n\t            const registry = new FunctionRegistry();\n\t            assert.throws(() => registry.get(\"test\"));\n\t        });\n\t    });\n\t    describe(\"has\", () => {\n\t        it(\"should return false when a function doesn't exist\", () => {\n\t            const registry = new FunctionRegistry();\n\t            assert.equal(registry.has(\"test\"), false);\n\t        });\n", "        it(\"should return true when a function exists\", () => {\n\t            const registry = new FunctionRegistry({\n\t                \"test\": async (memory, functions, tokenizer, args) => { }\n\t            });\n\t            assert.equal(registry.has(\"test\"), true);\n\t        });\n\t    });\n\t    describe(\"invoke\", () => {\n\t        const memory = new VolatileMemory();\n\t        const tokenizer = new GPT3Tokenizer();\n", "        it(\"should invoke a function\", async () => {\n\t            let called = false;\n\t            const registry = new FunctionRegistry({\n\t                \"test\": async (memory, functions, tokenizer, args) => {\n\t                    assert.equal(args.length, 1);\n\t                    assert.equal(args[0], \"Hello World\");\n\t                    called = true;\n\t                }\n\t            });\n\t            await registry.invoke(\"test\", memory, registry, tokenizer, [\"Hello World\"]);\n", "            assert.equal(called, true);\n\t        });\n\t        it(\"should throw when invoking a function that doesn't exist\", () => {\n\t            const registry = new FunctionRegistry();\n\t            assert.throws(() => registry.invoke(\"test\", memory, registry, tokenizer, [\"Hello World\"]));\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/VolatileMemory.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\tdescribe(\"VolatileMemory\", () => {\n\t    describe(\"constructor\", () => {\n\t        it(\"should create a VolatileMemory\", () => {\n\t            const memory = new VolatileMemory();\n\t            assert.notEqual(memory, null);\n\t        });\n\t        it(\"should create a VolatileMemory with initial values\", () => {\n\t            const memory = new VolatileMemory({\n", "                \"test\": 123\n\t            });\n\t            assert.notEqual(memory, null);\n\t            assert.equal(memory.has(\"test\"), true);\n\t        });\n\t    });\n\t    const obj = { foo: 'bar' };\n\t    const memory = new VolatileMemory();\n\t    describe(\"set\", () => {\n\t        it(\"should set a primitive value\", () => {\n", "            memory.set(\"test\", 123);\n\t            assert.equal(memory.has(\"test\"), true);\n\t        });\n\t        it(\"should set an object\", () => {\n\t            memory.set(\"test2\", obj);\n\t            assert.equal(memory.has(\"test2\"), true);\n\t        });\n\t    });\n\t    describe(\"get\", () => {\n\t        it(\"should get a primitive value\", () => {\n", "            const value = memory.get(\"test\");\n\t            assert.equal(value, 123);\n\t        });\n\t        it(\"should get an object that's a clone\", () => {\n\t            const value = memory.get(\"test2\");\n\t            assert.deepEqual(value, { foo: 'bar' });\n\t            assert.notEqual(value, obj);\n\t        });\n\t        it(\"should return undefined when getting a value that doesn't exist\", () => {\n\t            const value = memory.get(\"test3\");\n", "            assert.equal(value, undefined);\n\t        });\n\t    });\n\t    describe(\"has\", () => {\n\t        it(\"should return false when a value doesn't exist\", () => {\n\t            assert.equal(memory.has(\"test3\"), false);\n\t        });\n\t        it(\"should return true when a value exists\", () => {\n\t            assert.equal(memory.has(\"test\"), true);\n\t        });\n", "    });\n\t    describe(\"delete\", () => {\n\t        it(\"should delete a value\", () => {\n\t            memory.delete(\"test\");\n\t            assert.equal(memory.has(\"test\"), false);\n\t            assert.equal(memory.has(\"test2\"), true);\n\t        });\n\t    });\n\t    describe(\"clear\", () => {\n\t        it(\"should clear all values\", () => {\n", "            memory.set(\"test\", 123);\n\t            memory.clear();\n\t            assert.equal(memory.has(\"test\"), false);\n\t            assert.equal(memory.has(\"test2\"), false);\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/TextSection.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\n\timport { PromptSectionBase } from \"./PromptSectionBase\";\n\t/**\n\t * A section of text that will be rendered as a message.\n\t */\n\texport class TextSection extends PromptSectionBase {\n\t    private _length: number = -1;\n\t    public readonly text: string;\n\t    public readonly role: string;\n\t    /**\n", "     * Creates a new 'TextSection' instance.\n\t     * @param text Text to use for this section.\n\t     * @param role Message role to use for this section.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n\t     * @param required Optional. Indicates if this section is required. Defaults to `true`.\n\t     * @param separator Optional. Separator to use between sections when rendering as text. Defaults to `\\n`.\n\t     * @param textPrefix Optional. Prefix to use for text output. Defaults to `undefined`.\n\t     */\n\t    public constructor(text: string, role: string, tokens: number = -1, required: boolean = true, separator: string = '\\n', textPrefix?: string) {\n\t        super(tokens, required, separator, textPrefix);\n", "        this.text = text;\n\t        this.role = role;\n\t    }\n\t    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n\t        // Calculate and cache length\n\t        if (this._length < 0) {\n\t            this._length = tokenizer.encode(this.text).length;\n\t        }\n\t        // Return output\n\t        return this.returnMessages([{ role: this.role, content: this.text }], this._length, tokenizer, maxTokens);\n", "    }\n\t}"]}
{"filename": "src/TextSection.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { TextSection } from \"./TextSection\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\timport { FunctionRegistry } from \"./FunctionRegistry\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"TextSection\", () => {\n\t    const memory = new VolatileMemory();\n\t    const functions = new FunctionRegistry();\n\t    const tokenizer = new GPT3Tokenizer();\n\t    describe(\"constructor\", () => {\n", "        it(\"should create a TextSection\", () => {\n\t            const section = new TextSection(\"Hello World\", \"user\");\n\t            assert.equal(section.text, \"Hello World\");\n\t            assert.equal(section.role, \"user\");\n\t            assert.equal(section.tokens, -1);\n\t            assert.equal(section.required, true);\n\t            assert.equal(section.separator, \"\\n\");\n\t        });\n\t        it(\"should create a TextSection with other params\", () => {\n\t            const section = new TextSection(\"Hello World\", \"system\", 2.0, false);\n", "            assert.equal(section.text, \"Hello World\");\n\t            assert.equal(section.role, \"system\");\n\t            assert.equal(section.tokens, 2.0);\n\t            assert.equal(section.required, false);\n\t            assert.equal(section.separator, \"\\n\");\n\t        });\n\t    });\n\t    describe(\"renderAsMessages\", () => {\n\t        it(\"should render a TextSection to an array of messages\", async () => {\n\t            const section = new TextSection(\"Hello World\", \"user\");\n", "            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should identify a output as being too long\", async () => {\n\t            const section = new TextSection(\"Hello World\", \"user\");\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n\t            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n", "            assert.equal(rendered.tooLong, true);\n\t        });\n\t        it(\"should support multiple message render calls\", async () => {\n\t            const section = new TextSection(\"Hello World\", \"user\");\n\t            const rendered1 = await section.renderAsMessages(memory, functions, tokenizer, 1);\n\t            assert.deepEqual(rendered1.output, [{ role: \"user\", content: \"Hello World\" }]);\n\t            const rendered2 = await section.renderAsMessages(memory, functions, tokenizer, 1);\n\t            assert.deepEqual(rendered2.output, [{ role: \"user\", content: \"Hello World\" }]);\n\t        });\n\t    });\n", "    describe(\"renderAsText\", () => {\n\t        it(\"should render a TextSection to a string\", async () => {\n\t            const section = new TextSection(\"Hello World\", \"user\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello World\");\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should identify a text output as being too long\", async () => {\n\t            const section = new TextSection(\"Hello World\", \"user\");\n", "            const rendered = await section.renderAsText(memory, functions, tokenizer, 1);\n\t            assert.equal(rendered.output, \"Hello World\");\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, true);\n\t        });\n\t        it(\"should support multiple text render calls\", async () => {\n\t            const section = new TextSection(\"Hello World\", \"user\");\n\t            const rendered1 = await section.renderAsText(memory, functions, tokenizer, 1);\n\t            assert.equal(rendered1.output, \"Hello World\");\n\t            const rendered2 = await section.renderAsText(memory, functions, tokenizer, 1);\n", "            assert.equal(rendered2.output, \"Hello World\");\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/TemplateSection.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { TemplateSection } from \"./TemplateSection\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\timport { FunctionRegistry } from \"./FunctionRegistry\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"TemplateSection\", () => {\n\t    const memory = new VolatileMemory({\n\t        foo: 'bar'\n\t    });\n\t    const functions = new FunctionRegistry({\n", "        'test': async (memory, functions, tokenizer, args) => 'Hello World',\n\t        'test2': async (memory, functions, tokenizer, args) => args[0],\n\t        'test3': async (memory, functions, tokenizer, args) => args.join(' '),\n\t    });\n\t    const tokenizer = new GPT3Tokenizer();\n\t    describe(\"constructor\", () => {\n\t        it(\"should create a TemplateSection\", () => {\n\t            const section = new TemplateSection(\"Hello World\", \"user\");\n\t            assert.equal(section.template, \"Hello World\");\n\t            assert.equal(section.role, \"user\");\n", "            assert.equal(section.tokens, -1);\n\t            assert.equal(section.required, true);\n\t            assert.equal(section.separator, \"\\n\");\n\t        });\n\t        it(\"should create a TemplateSection with other params\", () => {\n\t            const section = new TemplateSection(\"Hello World\", \"system\", 2.0, false);\n\t            assert.equal(section.template, \"Hello World\");\n\t            assert.equal(section.role, \"system\");\n\t            assert.equal(section.tokens, 2.0);\n\t            assert.equal(section.required, false);\n", "            assert.equal(section.separator, \"\\n\");\n\t        });\n\t    });\n\t    describe(\"renderAsMessages\", () => {\n\t        it(\"should render a TemplateSection to an array of messages\", async () => {\n\t            const section = new TemplateSection(\"Hello World\", \"user\");\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n", "        });\n\t        it(\"should identify a output as being too long\", async () => {\n\t            const section = new TemplateSection(\"Hello World\", \"user\");\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n\t            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, true);\n\t        });\n\t    });\n\t    describe(\"renderAsText\", () => {\n", "        it(\"should render a TemplateSection to a string\", async () => {\n\t            const section = new TemplateSection(\"Hello World\", \"user\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello World\");\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should identify a text output as being too long\", async () => {\n\t            const section = new TemplateSection(\"Hello World\", \"user\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 1);\n", "            assert.equal(rendered.output, \"Hello World\");\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, true);\n\t        });\n\t    });\n\t    describe(\"template syntax\", () => {\n\t        it(\"should render a template with a {{$variable}}\", async () => {\n\t            const section = new TemplateSection(\"Hello {{$foo}}\", \"user\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello bar\");\n", "            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should render a template with a {{$variable}} and a {{function}}\", async () => {\n\t            const section = new TemplateSection(\"Hello {{$foo}} {{test}}\", \"user\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello bar Hello World\");\n\t            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n", "        it(\"should render a template with a {{function}} and arguments\", async () => {\n\t            const section = new TemplateSection(\"Hello {{test2 World}}\", \"user\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello World\");\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should render a template with a {{function}} and quoted arguments\", async () => {\n\t            const section = new TemplateSection(\"Hello {{test2 'Big World'}}\", \"user\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n", "            assert.equal(rendered.output, \"Hello Big World\");\n\t            assert.equal(rendered.length, 3);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should render a template with a {{function}} and backtick arguments\", async () => {\n\t            const section = new TemplateSection(\"Hello {{test2 `Big World`}}\", \"user\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello Big World\");\n\t            assert.equal(rendered.length, 3);\n\t            assert.equal(rendered.tooLong, false);\n", "        });\n\t        it(\"should render a template with a {{function}} and multiple arguments\", async () => {\n\t            const section = new TemplateSection(\"Hello {{test3 'Big' World}}\", \"user\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello Big World\");\n\t            assert.equal(rendered.length, 3);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should skip {{}} empty template params\", async () => {\n\t            const section = new TemplateSection(\"{{}}\", \"user\");\n", "            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"\");\n\t            assert.equal(rendered.length, 0);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should throw an error for an invalid template\", () => {\n\t            try {\n\t                const section = new TemplateSection(\"Hello {{test3 'Big' World}\", \"user\");\n\t                assert.fail(\"Should have thrown an error\");\n\t            } catch (e: unknown) {\n", "                assert.equal((e as Error).message, \"Invalid template: Hello {{test3 'Big' World}\");\n\t            }\n\t        });\n\t        it(\"should throw an error for an invalid {{function 'arg}}\", () => {\n\t            try {\n\t                const section = new TemplateSection(\"Hello {{test3 'Big}}\", \"user\");\n\t                assert.fail(\"Should have thrown an error\");\n\t            } catch (e: unknown) {\n\t                assert.equal((e as Error).message, \"Invalid template: Hello {{test3 'Big}}\");\n\t            }\n", "        });\n\t    });\n\t});\n"]}
{"filename": "src/GPT3Tokenizer.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"GPT3Tokenizer\", () => {\n\t    describe(\"constructor\", () => {\n\t        it(\"should create a GPT3Tokenizer\", () => {\n\t            const tokenizer = new GPT3Tokenizer();\n\t            assert.notEqual(tokenizer, null);\n\t        });\n\t    });\n\t    let encoded: number[] = [];\n", "    describe(\"encode\", () => {\n\t        it(\"should encode a string\", async () => {\n\t            const tokenizer = new GPT3Tokenizer();\n\t            encoded = await tokenizer.encode(\"Hello World\");\n\t            assert.equal(encoded.length, 2);\n\t            assert.equal(typeof encoded[0], \"number\");\n\t        });\n\t    });\n\t    describe(\"decode\", () => {\n\t        it(\"should decode an array of numbers\", async () => {\n", "            const tokenizer = new GPT3Tokenizer();\n\t            const decoded = await tokenizer.decode(encoded);\n\t            assert.equal(decoded, \"Hello World\");\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/SystemMessage.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { SystemMessage } from \"./SystemMessage\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\timport { FunctionRegistry } from \"./FunctionRegistry\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"SystemMessage\", () => {\n\t    const memory = new VolatileMemory();\n\t    const functions = new FunctionRegistry();\n\t    const tokenizer = new GPT3Tokenizer();\n\t    describe(\"constructor\", () => {\n", "        it(\"should create a SystemMessage\", () => {\n\t            const section = new SystemMessage(\"Hello World\");\n\t            assert.equal(section.template, \"Hello World\");\n\t            assert.equal(section.role, \"system\");\n\t            assert.equal(section.tokens, -1);\n\t            assert.equal(section.required, true);\n\t            assert.equal(section.separator, \"\\n\");\n\t        });\n\t    });\n\t    describe(\"renderAsMessages\", () => {\n", "        it(\"should render a SystemMessage to an array of messages\", async () => {\n\t            const section = new SystemMessage(\"Hello World\");\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"system\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t    });\n\t    describe(\"renderAsText\", () => {\n\t        it(\"should render a TemplateSection to a string\", async () => {\n", "            const section = new SystemMessage(\"Hello World\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"Hello World\");\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/GroupSection.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, PromptSection, RenderedPromptSection, Tokenizer } from \"./types\";\n\timport { PromptSectionBase } from \"./PromptSectionBase\";\n\timport { LayoutEngine } from \"./LayoutEngine\";\n\t/**\n\t * A group of sections that will rendered as a single message.\n\t */\n\texport class GroupSection extends PromptSectionBase {\n\t    private readonly _layoutEngine: LayoutEngine;\n\t    public readonly sections: PromptSection[];\n\t    public readonly role: string;\n", "    /**\n\t     *\n\t     * @param sections List of sections to group together.\n\t     * @param role Optional. Message role to use for this section. Defaults to `system`.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n\t     * @param required Optional. Indicates if this section is required. Defaults to `true`.\n\t     * @param separator Optional. Separator to use between sections when rendering as text. Defaults to `\\n\\n`.\n\t     * @param textPrefix Optional. Prefix to use for text output. Defaults to `undefined`.\n\t     */\n\t    public constructor(sections: PromptSection[], role: string = 'system', tokens: number = -1, required: boolean = true, separator: string = '\\n\\n', textPrefix?: string) {\n", "        super(tokens, required, separator, textPrefix);\n\t        this._layoutEngine = new LayoutEngine(sections, tokens, required, separator);\n\t        this.sections = sections;\n\t        this.role = role;\n\t    }\n\t    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n\t        // Render sections to text\n\t        const { output, length, tooLong } = await this._layoutEngine.renderAsText(memory, functions, tokenizer, maxTokens);\n\t        // Return output as a single message\n\t        return this.returnMessages([{ role: this.role, content: output }], length, tokenizer, maxTokens);\n", "    }\n\t}"]}
{"filename": "src/AssistantMessage.ts", "chunked_list": ["import { TemplateSection } from \"./TemplateSection\";\n\t/**\n\t * A message sent by the assistant.\n\t */\n\texport class AssistantMessage extends TemplateSection {\n\t    /**\n\t     * Creates a new 'AssistantMessage' instance.\n\t     * @param template Template to use for this section.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n\t     * @param assistantPrefix Optional. Prefix to use for assistant messages when rendering as text. Defaults to `assistant: `.\n", "     */\n\t    public constructor(template: string, tokens: number = -1, assistantPrefix: string = 'assistant: ') {\n\t        super(template, 'assistant', tokens, true, '\\n', assistantPrefix);\n\t    }\n\t}"]}
{"filename": "src/ConversationHistory.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { ConversationHistory } from \"./ConversationHistory\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\timport { FunctionRegistry } from \"./FunctionRegistry\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"ConversationHistory\", () => {\n\t    const memory = new VolatileMemory({\n\t        \"history\": [\n\t            { role: \"user\", content: \"Hello\" },\n\t            { role: \"assistant\", content: \"Hi\" },\n", "        ],\n\t        \"longHistory\": [\n\t            { role: \"user\", content: \"Hello\" },\n\t            { role: \"assistant\", content: \"Hi! How can I help you?\" },\n\t            { role: \"user\", content: \"I'd like to book a flight\" },\n\t            { role: \"assistant\", content: \"Sure, where would you like to go?\" },\n\t        ]\n\t    });\n\t    const functions = new FunctionRegistry();\n\t    const tokenizer = new GPT3Tokenizer();\n", "    describe(\"constructor\", () => {\n\t        it(\"should create a ConversationHistory\", () => {\n\t            const section = new ConversationHistory('history');\n\t            assert.equal(section.variable, 'history');\n\t            assert.equal(section.tokens, 1.0);\n\t            assert.equal(section.required, false);\n\t            assert.equal(section.separator, \"\\n\");\n\t            assert.equal(section.userPrefix, \"user: \");\n\t            assert.equal(section.assistantPrefix, \"assistant: \");\n\t            assert.equal(section.textPrefix, \"\");\n", "        });\n\t    });\n\t    describe(\"renderAsMessages\", () => {\n\t        it(\"should render a ConversationHistory to an array of messages\", async () => {\n\t            const section = new ConversationHistory('history', 100);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [\n\t                { role: \"user\", content: \"Hello\" },\n\t                { role: \"assistant\", content: \"Hi\" },\n\t            ]);\n", "            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should truncate its output to match available budget\", async () => {\n\t            const section = new ConversationHistory('history', 1);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 1);\n\t            assert.deepEqual(rendered.output, [\n\t                { role: \"assistant\", content: \"Hi\" },\n\t            ]);\n\t            assert.equal(rendered.length, 1);\n", "            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should render nothing when there's no history\", async () => {\n\t            const section = new ConversationHistory('nohistory', 100);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, []);\n\t            assert.equal(rendered.length, 0);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should render nothing for a long last message\", async () => {\n", "            const section = new ConversationHistory('longHistory', 100);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 2);\n\t            assert.deepEqual(rendered.output, []);\n\t            assert.equal(rendered.length, 0);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should always render the last message when section is required\", async () => {\n\t            const section = new ConversationHistory('longHistory', 100, true);\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 2);\n\t            assert.deepEqual(rendered.output, [\n", "                { role: \"assistant\", content: \"Sure, where would you like to go?\" },\n\t            ]);\n\t            assert.equal(rendered.length, 9);\n\t            assert.equal(rendered.tooLong, true);\n\t        });\n\t    });\n\t    describe(\"renderAsText\", () => {\n\t        it(\"should render a ConversationHistory to a string\", async () => {\n\t            const section = new ConversationHistory('history', 100);\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n", "            assert.equal(rendered.output, \"user: Hello\\nassistant: Hi\");\n\t            assert.equal(rendered.length, 8);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should truncate its output to match available budget\", async () => {\n\t            const section = new ConversationHistory('history', 1);\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 4);\n\t            assert.equal(rendered.output, \"assistant: Hi\");\n\t            assert.equal(rendered.length, 4);\n\t            assert.equal(rendered.tooLong, false);\n", "        });\n\t        it(\"should render nothing when there's no history\", async () => {\n\t            const section = new ConversationHistory('nohistory', 100);\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"\");\n\t            assert.equal(rendered.length, 0);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should render nothing for a long last message\", async () => {\n\t            const section = new ConversationHistory('longHistory', 100);\n", "            const rendered = await section.renderAsText(memory, functions, tokenizer, 2);\n\t            assert.equal(rendered.output, \"\");\n\t            assert.equal(rendered.length, 0);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t        it(\"should always render the last message when section is required\", async () => {\n\t            const section = new ConversationHistory('longHistory', 100, true);\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 2);\n\t            assert.equal(rendered.output, \"assistant: Sure, where would you like to go?\");\n\t            assert.equal(rendered.length, 12);\n", "            assert.equal(rendered.tooLong, true);\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/PromptSectionBase.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, PromptSection, RenderedPromptSection, Tokenizer } from \"./types\";\n\t/**\n\t * Abstract Base class for most prompt sections.\n\t */\n\texport abstract class PromptSectionBase implements PromptSection {\n\t    public readonly required: boolean;\n\t    public readonly tokens: number;\n\t    public readonly separator: string;\n\t    public readonly textPrefix: string;\n\t    /**\n", "     * Creates a new 'PromptSectionBase' instance.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n\t     * @param required Optional. Indicates if this section is required. Defaults to `true`.\n\t     * @param separator Optional. Separator to use between sections when rendering as text. Defaults to `\\n`.\n\t     * @param textPrefix Optional. Prefix to use for text output. Defaults to `undefined`.\n\t     */\n\t    public constructor(tokens: number = -1, required: boolean = true, separator: string = '\\n', textPrefix: string = '') {\n\t        this.required = required;\n\t        this.tokens = tokens;\n\t        this.separator = separator;\n", "        this.textPrefix = textPrefix;\n\t    }\n\t    public async renderAsText(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<string>> {\n\t        // Render as messages\n\t        const asMessages = await this.renderAsMessages(memory, functions, tokenizer, maxTokens);\n\t        // Convert to text\n\t        let text = asMessages.output.map((message) => PromptSectionBase.getMessageText(message)).join(this.separator);\n\t        // Calculate length\n\t        const prefixLength = tokenizer.encode(this.textPrefix).length;\n\t        const separatorLength = tokenizer.encode(this.separator).length;\n", "        let length = prefixLength + asMessages.length + ((asMessages.output.length - 1) * separatorLength);\n\t        // Truncate if fixed length\n\t        text = this.textPrefix + text;\n\t        if (this.tokens > 1.0 && length > this.tokens) {\n\t            const encoded = tokenizer.encode(text);\n\t            text = tokenizer.decode(encoded.slice(0, this.tokens));\n\t            length = this.tokens;\n\t        }\n\t        return { output: text, length: length, tooLong: length > maxTokens };\n\t    }\n", "    public abstract renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>>;\n\t    protected returnMessages(output: Message[], length: number, tokenizer: Tokenizer, maxTokens: number): RenderedPromptSection<Message[]> {\n\t        // Truncate if fixed length\n\t        if (this.tokens > 1.0) {\n\t            while (length > this.tokens) {\n\t                const msg = output.pop();\n\t                const encoded = tokenizer.encode(PromptSectionBase.getMessageText(msg!));\n\t                length -= encoded.length;\n\t                if (length < this.tokens) {\n\t                    const delta = this.tokens - length;\n", "                    const truncated = tokenizer.decode(encoded.slice(0, delta));\n\t                    output.push({ role: msg!.role, content: truncated });\n\t                    length += delta;\n\t                }\n\t            }\n\t        }\n\t        return { output: output, length: length, tooLong: length > maxTokens };\n\t    }\n\t    public static getMessageText(message: Message): string {\n\t        let text = message.content ?? '';\n", "        if (message.function_call) {\n\t            text = JSON.stringify(message.function_call);\n\t        } else if (message.name) {\n\t            text = `${message.name} returned ${text}`;\n\t        }\n\t        return text;\n\t    }\n\t}"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"./AssistantMessage\";\n\texport * from \"./ConversationHistory\";\n\texport * from \"./FunctionCallMessage\";\n\texport * from \"./FunctionRegistry\";\n\texport * from \"./FunctionResponseMessage\";\n\texport * from \"./GPT3Tokenizer\";\n\texport * from \"./GroupSection\";\n\texport * from \"./LayoutEngine\";\n\texport * from \"./Prompt\";\n\texport * from \"./PromptSectionBase\";\n", "export * from \"./SystemMessage\";\n\texport * from \"./TemplateSection\";\n\texport * from \"./TextSection\";\n\texport * from \"./types\";\n\texport * from \"./UserMessage\";\n\texport * from \"./Utilities\";\n\texport * from \"./VolatileMemory\";\n"]}
{"filename": "src/GPT3Tokenizer.ts", "chunked_list": ["import { Tokenizer } from \"./types\";\n\timport { encode, decode } from \"gpt-3-encoder\";\n\t/**\n\t * Tokenizer that uses GPT-3's encoder.\n\t */\n\texport class GPT3Tokenizer implements Tokenizer {\n\t    public decode(tokens: number[]): string {\n\t        return decode(tokens);\n\t    }\n\t    public encode(text: string): number[] {\n", "        return encode(text);\n\t    }\n\t}\n"]}
{"filename": "src/Utilities.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { Utilities } from \"./Utilities\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"Utilities\", () => {\n\t    const tokenizer = new GPT3Tokenizer();\n\t    describe(\"toString\", () => {\n\t        it(\"should convert a number to a string\", () => {\n\t            const result = Utilities.toString(tokenizer, 1);\n\t            assert.equal(result, \"1\");\n\t        });\n", "        it(\"should convert a string to a string\", () => {\n\t            const result = Utilities.toString(tokenizer, \"1\");\n\t            assert.equal(result, \"1\");\n\t        });\n\t        it(\"should convert a boolean to a string\", () => {\n\t            const result = Utilities.toString(tokenizer, true);\n\t            assert.equal(result, \"true\");\n\t        });\n\t        it(\"should convert a simple object to yaml\", () => {\n\t            const result = Utilities.toString(tokenizer, { a: 1 });\n", "            assert.equal(result, \"a: 1\\n\");\n\t        });\n\t        it(\"should convert a deep object to JSON\", () => {\n\t            const result = Utilities.toString(tokenizer, { a: { b: { c: { d: 1 } } } });\n\t            assert.equal(result, `{\"a\":{\"b\":{\"c\":{\"d\":1}}}}`);\n\t        });\n\t        it(\"should convert a date to a string\", () => {\n\t            const result = Utilities.toString(tokenizer, new Date(\"2021-01-01\"));\n\t            assert.equal(result, \"2021-01-01T00:00:00.000Z\");\n\t        });\n", "        it(\"should return an empty string for undefined\", () => {\n\t            const result = Utilities.toString(tokenizer, undefined);\n\t            assert.equal(result, \"\");\n\t        });\n\t        it(\"should return an empty string for null\", () => {\n\t            const result = Utilities.toString(tokenizer, null);\n\t            assert.equal(result, \"\");\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/FunctionCallMessage.ts", "chunked_list": ["import { FunctionCall, Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\n\timport { PromptSectionBase } from \"./PromptSectionBase\";\n\timport { Utilities } from \"./Utilities\";\n\t/**\n\t * An `assistant` message containing a function to call.\n\t * @remarks\n\t * The function call information is returned by the model so we use an \"assistant\" message to\n\t * represent it in conversation history.\n\t */\n\texport class FunctionCallMessage extends PromptSectionBase {\n", "    private _length: number = -1;\n\t    public readonly function_call: FunctionCall;\n\t    /**\n\t     * Creates a new 'FunctionCallMessage' instance.\n\t     * @param function_call name and arguments of the function to call.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n\t     * @param assistantPrefix Optional. Prefix to use for assistant messages when rendering as text. Defaults to `assistant: `.\n\t     */\n\t    public constructor(function_call: FunctionCall, tokens: number = -1, assistantPrefix: string = 'assistant: ') {\n\t        super(tokens, true, '\\n', assistantPrefix);\n", "        this.function_call = function_call;\n\t    }\n\t    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n\t        // Calculate and cache response text and length\n\t        if (this._length < 0) {\n\t            this._length = tokenizer.encode(JSON.stringify(this.function_call)).length;\n\t        }\n\t        // Return output\n\t        return this.returnMessages([{ role: 'assistant', content: null, function_call: this.function_call }], this._length, tokenizer, maxTokens);\n\t    }\n", "}"]}
{"filename": "src/Utilities.ts", "chunked_list": ["import { Tokenizer } from \"./types\";\n\timport { stringify } from \"yaml\";\n\t/**\n\t * Utility functions.\n\t */\n\texport class Utilities {\n\t    /**\n\t     * Converts a value to a string.\n\t     * @remarks\n\t     * Dates are converted to ISO strings and Objects are converted to JSON or YAML, whichever is shorter.\n", "     * @param tokenizer Tokenizer to use for encoding.\n\t     * @param value Value to convert.\n\t     * @param asJSON Optional. If true objects will always be converted to JSON instead of YAML. Defaults to false.\n\t     * @returns Converted value.\n\t     */\n\t    public static toString(tokenizer: Tokenizer, value: any, asJSON: boolean = false): string {\n\t        if (value === undefined || value === null) {\n\t            return '';\n\t        } else if (typeof value === \"object\") {\n\t            if (typeof value.toISOString == \"function\") {\n", "                return value.toISOString();\n\t            } else if (asJSON) {\n\t                return JSON.stringify(value);\n\t            } else {\n\t                // Return shorter version of object\n\t                const asYaml = stringify(value);\n\t                const asJSON = JSON.stringify(value);\n\t                if (tokenizer.encode(asYaml).length < tokenizer.encode(asJSON).length) {\n\t                    return asYaml;\n\t                } else {\n", "                    return asJSON;\n\t                }\n\t            }\n\t        } else {\n\t            return value.toString();\n\t        }\n\t    }\n\t}"]}
{"filename": "src/UserMessage.spec.ts", "chunked_list": ["import { strict as assert } from \"assert\";\n\timport { UserMessage } from \"./UserMessage\";\n\timport { VolatileMemory } from \"./VolatileMemory\";\n\timport { FunctionRegistry } from \"./FunctionRegistry\";\n\timport { GPT3Tokenizer } from \"./GPT3Tokenizer\";\n\tdescribe(\"UserMessage\", () => {\n\t    const memory = new VolatileMemory();\n\t    const functions = new FunctionRegistry();\n\t    const tokenizer = new GPT3Tokenizer();\n\t    describe(\"constructor\", () => {\n", "        it(\"should create a UserMessage\", () => {\n\t            const section = new UserMessage(\"Hello World\");\n\t            assert.equal(section.template, \"Hello World\");\n\t            assert.equal(section.role, \"user\");\n\t            assert.equal(section.tokens, -1);\n\t            assert.equal(section.required, true);\n\t            assert.equal(section.separator, \"\\n\");\n\t            assert.equal(section.textPrefix, \"user: \");\n\t        });\n\t    });\n", "    describe(\"renderAsMessages\", () => {\n\t        it(\"should render a UserMessage to an array of messages\", async () => {\n\t            const section = new UserMessage(\"Hello World\");\n\t            const rendered = await section.renderAsMessages(memory, functions, tokenizer, 100);\n\t            assert.deepEqual(rendered.output, [{ role: \"user\", content: \"Hello World\" }]);\n\t            assert.equal(rendered.length, 2);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t    });\n\t    describe(\"renderAsText\", () => {\n", "        it(\"should render a TemplateSection to a string\", async () => {\n\t            const section = new UserMessage(\"Hello World\");\n\t            const rendered = await section.renderAsText(memory, functions, tokenizer, 100);\n\t            assert.equal(rendered.output, \"user: Hello World\");\n\t            assert.equal(rendered.length, 5);\n\t            assert.equal(rendered.tooLong, false);\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/FunctionResponseMessage.ts", "chunked_list": ["import { Message, PromptFunctions, PromptMemory, RenderedPromptSection, Tokenizer } from \"./types\";\n\timport { PromptSectionBase } from \"./PromptSectionBase\";\n\timport { Utilities } from \"./Utilities\";\n\t/**\n\t * Message containing the response to a function call.\n\t */\n\texport class FunctionResponseMessage extends PromptSectionBase {\n\t    private _text: string = '';\n\t    private _length: number = -1;\n\t    public readonly name: string;\n", "    public readonly response: any;\n\t    /**\n\t     * Creates a new 'FunctionResponseMessage' instance.\n\t     * @param name Name of the function that was called.\n\t     * @param response The response returned by the called function.\n\t     * @param tokens Optional. Sizing strategy for this section. Defaults to `auto`.\n\t     * @param functionPrefix Optional. Prefix to use for function messages when rendering as text. Defaults to `user: ` to simulate the response coming from the user.\n\t     */\n\t    public constructor(name: string, response: any, tokens: number = -1, functionPrefix: string = 'user: ') {\n\t        super(tokens, true, '\\n', functionPrefix);\n", "        this.name = name;\n\t        this.response = response;\n\t    }\n\t    public async renderAsMessages(memory: PromptMemory, functions: PromptFunctions, tokenizer: Tokenizer, maxTokens: number): Promise<RenderedPromptSection<Message[]>> {\n\t        // Calculate and cache response text and length\n\t        if (this._length < 0) {\n\t            this._text = Utilities.toString(tokenizer, this.response);\n\t            this._length = tokenizer.encode(this.name).length + tokenizer.encode(this._text).length;\n\t        }\n\t        // Return output\n", "        return this.returnMessages([{ role: 'function', name: this.name, content: this._text }], this._length, tokenizer, maxTokens);\n\t    }\n\t}"]}
