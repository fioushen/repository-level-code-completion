{"filename": "src/index.ts", "chunked_list": ["// core\n\texport { logger } from './core/logger';\n\t// fetch\n\texport { isMethod, handleFetchRequest } from './fetch/fetch';\n\texport {\n\t  isAssetRequest,\n\t  isDocumentRequest,\n\t  isLoaderRequest,\n\t  matchRequest\n\t} from './fetch/match';\n", "export type { MatchRequest, MatchResponse } from './fetch/match';\n\t// message\n\texport { MessageHandler } from './message/message';\n\texport { PrecacheHandler } from './message/precacheHandler';\n\texport { RemixNavigationHandler } from './message/remixNavigationHandler';\n\texport type { RemixNavigationHandlerOptions } from './message/remixNavigationHandler';\n\texport type { PrecacheHandlerOptions } from './message/precacheHandler';\n\texport type { MessageHandlerParams } from './message/message';\n\texport type { MessageEnv } from './message/types';\n\t// plugins\n", "export { StrategyPlugin } from './plugins/interfaces/strategyPlugin';\n\texport type { MessagePlugin } from './plugins/interfaces/messagePlugin';\n\texport { ExpirationPlugin } from './plugins/cache/expirationPlugin';\n\t// react\n\texport { loadServiceWorker } from './react/loader';\n\texport { unregisterServiceWorker } from './react/registration'\n\texport type { LoadServiceWorkerOptions } from './react/loader';\n\texport { useSWEffect } from './react/useSWEffect';\n\t// strategy\n\texport { CacheStrategy } from './strategy/strategy';\n", "export { CacheFirst } from './strategy/cacheFirst';\n\texport { CacheOnly } from './strategy/cacheOnly';\n\texport { NetworkFirst } from './strategy/networkFirst';\n\texport { NetworkOnly } from './strategy/networkOnly';\n\t// export { StaleWhileRevalidate } from './strategy/staleWhileRevalidate';\n\texport type { StrategyHandlerParams } from './strategy/strategy';\n\texport type { NetworkFirstOptions } from './strategy/networkFirst';\n\texport type { NetworkOnlyOptions } from './strategy/networkOnly';\n\t// workbox\n\texport { remixLoaderPlugin } from './workbox/plugins/loaderPlugin';\n", "export { matchAssetRequest, matchDocumentRequest, matchLoaderRequest } from './workbox/main';\n\texport type { RemixLoaderPlugin } from './workbox/plugins/loaderPlugin';\n\texport type { WorkBoxProps } from './workbox/main';\n"]}
{"filename": "src/plugins/interfaces/strategyPlugin.ts", "chunked_list": ["// todo: Add more typings to the callbacks. This is quite ugly, I wasn't in the mood for\n\t// writing all the types for the callbacks. ==TODO==\n\timport { CacheQueryMatchOptions } from '../../strategy/types.js';\n\texport declare interface StrategyPlugin {\n\t  // Called before a request is made to the network or cache.\n\t  // Can be used to modify the request or return a different request, for example.\n\t  /**\n\t   * Called whenever a request is about to go to the network. Useful when you need \n\t   * to change the Request just before it goes to the network.\n\t   */\n", "  requestWillFetch?: (options: {\n\t    request: Request;\n\t    event?: ExtendableEvent;\n\t  }) => Promise<Request>;\n\t  // Called before a response is stored in the cache.\n\t  /**\n\t   * Called before a Response is used to update a cache. In this method, \n\t   * the response can be changed before it's added to the cache, or you can \n\t   * return null to avoid updating the cache entirely.\n\t   */\n", "  cacheWillUpdate?: (options: {\n\t    response: Response;\n\t    request: Request;\n\t    event?: ExtendableEvent;\n\t  }) => Promise<Response | null>;\n\t  // Called after a response is stored in the cache.\n\t  /**\n\t   * Called when a new entry is added to a cache or if an existing entry is updated. \n\t   * Plugins that use this method may be useful when you want to perform an action after a cache update.\n\t   */\n", "  cacheDidUpdate?: (options: {\n\t    cacheName: string;\n\t    request: Request;\n\t    oldResponse?: Response;\n\t    newResponse: Response;\n\t    event?: ExtendableEvent;\n\t  }) => Promise<void>;\n\t  // Called before a cached response is used to respond to a fetch event.\n\t  /**\n\t   * This is called just before a response from a cache is used, which allows you to examine that \n", "   * response. At this point in time, you could either return a different response, or return null (fetch from server at all costs?).\n\t   */\n\t  cachedResponseWillBeUsed?: (options: {\n\t    cacheName: string;\n\t    request: Request;\n\t    matchOptions: CacheQueryMatchOptions;\n\t    cachedResponse: Response;\n\t    event?: ExtendableEvent;\n\t  }) => Promise<Response | null>;\n\t  // Called after a fetch request is made and a response is received from the network, but before it's returned to the application.\n", "  // Can be used to modify the response, for example.\n\t  /**\n\t   * Called whenever a network request succeeds, regardless of the HTTP response code.\n\t   */\n\t  fetchDidSucceed?: (options: {\n\t    request: Request;\n\t    response: Response;\n\t    event?: ExtendableEvent;\n\t  }) => Promise<Response>;\n\t  // Called when a request fails to be fetched and stored in the cache.\n", "  // Can be used to register a background sync task, for example.\n\t  /**\n\t   * Called when a network request fails, most likely due to an absence of network connectivity, \n\t   * and will not fire when the browser has a network connection, but receives an error (for example, 404 Not Found).\n\t   */\n\t  fetchDidFail?: (options: {\n\t    request: Request;\n\t    error: Error;\n\t    event?: ExtendableEvent;\n\t  }) => Promise<void | null | undefined>;\n", "}\n"]}
{"filename": "src/plugins/interfaces/messagePlugin.ts", "chunked_list": ["import { MessageEnv } from '../../message/types.js';\n\t/**\n\t * A plugin that can be used to modify the message environment\n\t */\n\texport interface MessagePlugin {\n\t  /**\n\t   * A function that is called when a message is received\n\t   */\n\t  messageDidReceive?: (env: MessageEnv) => void;\n\t  /**\n", "   * A function that is called before a message is sent\n\t   * or broadcasted back to the client\n\t   */\n\t  messageWillSend?: (env: MessageEnv) => void;\n\t}\n"]}
{"filename": "src/plugins/cache/expirationPlugin.ts", "chunked_list": ["import { logger } from \"../../core/logger\";\n\timport { CacheQueryMatchOptions } from \"../../strategy/types\";\n\timport { StrategyPlugin } from \"../interfaces/strategyPlugin\";\n\texport class ExpirationPlugin implements StrategyPlugin {\n\t  private readonly maxEntries: number;\n\t  private readonly maxAgeSeconds: number;\n\t  constructor({\n\t    maxEntries,\n\t    maxAgeSeconds,\n\t  }: { maxEntries?: number; maxAgeSeconds?: number } = {}) {\n", "    this.maxAgeSeconds = maxAgeSeconds || 30 * 24 * 3_600;\n\t    this.maxEntries = maxEntries || Infinity;\n\t  }\n\t  async cachedResponseWillBeUsed(options: {\n\t    cacheName: string;\n\t    request: Request;\n\t    matchOptions: CacheQueryMatchOptions;\n\t    cachedResponse: Response;\n\t    event?: ExtendableEvent | undefined;\n\t  }): Promise<Response | null> {\n", "    const now = Date.now();\n\t    const expirationDate = options.cachedResponse.headers.get(\"X-Expires\");\n\t    const newResponse = options.cachedResponse.clone()\n\t    const headers = new Headers(newResponse.headers)\n\t    const modifedResponse = new Response(newResponse.body, {\n\t      status: newResponse.status,\n\t      statusText: newResponse.statusText,\n\t      headers\n\t    })\n\t    if (expirationDate) {\n", "      const elapsedTime = new Date(expirationDate).getTime() - now;\n\t      if (elapsedTime < 0) {\n\t        const cache = await caches.open(options.cacheName);\n\t        await cache.delete(options.request, options.matchOptions);\n\t        console.log(\"cacheResponseWillBeUsed\", options.request.url);\n\t        return options.cachedResponse;\n\t      }\n\t      modifedResponse.headers.set(\n\t        \"X-Access-Time\",\n\t        new Date(now).toUTCString()\n", "      );\n\t      return modifedResponse\n\t    } else {\n\t      modifedResponse.headers.set(\n\t        \"X-Access-Time\",\n\t        new Date(now).toUTCString()\n\t      );\n\t      return modifedResponse;\n\t    }\n\t  }\n", "  async cacheWillUpdate(options: {\n\t    response: Response;\n\t    request: Request;\n\t    event?: ExtendableEvent | undefined;\n\t  }): Promise<Response | null> {\n\t    const now = Date.now();\n\t    console.log(\"cacheWillUpdate\", options.request.url);\n\t    let newResponse = options.response.clone();\n\t    const headers = new Headers(newResponse.headers)\n\t    const modifedResponse = new Response(newResponse.body, {\n", "      status: newResponse.status,\n\t      statusText: newResponse.statusText,\n\t      headers\n\t    })\n\t    modifedResponse.headers.set(\n\t      \"X-Expires\",\n\t      new Date(now + this.maxAgeSeconds * 1_000).toUTCString()\n\t    );\n\t    return modifedResponse;\n\t  }\n", "  async cacheDidUpdate(options: {\n\t    cacheName: string;\n\t    request: Request;\n\t    oldResponse?: Response | undefined;\n\t    newResponse: Response;\n\t    event?: ExtendableEvent | undefined;\n\t  }) {\n\t    const cache = await caches.open(options.cacheName);\n\t    const keys = await cache.keys();\n\t    console.error(keys.length, this.maxEntries);\n", "    if (keys.length > this.maxEntries) {\n\t      logger.debug(\"Cache is full, removing oldest entry\");\n\t      this.removeLRUEntry(options.cacheName);\n\t    }\n\t  }\n\t  async removeLRUEntry(cacheName: string) {\n\t    const cache = await caches.open(cacheName);\n\t    const keys = await cache.keys();\n\t    let oldestEntry: Response | null = null;\n\t    for (const key of keys) {\n", "      const entry = await cache.match(key);\n\t      if (!entry) {\n\t        continue;\n\t      }\n\t      if (!oldestEntry) {\n\t        oldestEntry = entry;\n\t        continue;\n\t      }\n\t      const oldestEntryDate = oldestEntry.headers.get(\"X-Access-Time\");\n\t      const entryDate = entry.headers.get(\"X-Access-Time\");\n", "      if (!oldestEntryDate || !entryDate) {\n\t        continue;\n\t      }\n\t      if (new Date(oldestEntryDate).getTime() > new Date(entryDate).getTime()) {\n\t        oldestEntry = entry;\n\t      }\n\t    }\n\t    if (oldestEntry) {\n\t      await cache.delete(oldestEntry.url);\n\t    }\n", "  }\n\t}"]}
{"filename": "src/message/types.ts", "chunked_list": ["/**\n\t * @fileoverview Global typings for `message` sub-module\n\t */\n\texport interface MessageEnv {\n\t  event?: ExtendableMessageEvent;\n\t  state?: Record<string, any>;\n\t}\n"]}
{"filename": "src/message/precacheHandler.ts", "chunked_list": ["import { MessageHandler } from \"./message.js\";\n\timport { logger } from \"../core/logger.js\";\n\timport type { AssetsManifest } from \"@remix-run/dev\";\n\timport type { MessageHandlerParams } from \"./message.js\";\n\timport type { EntryRoute } from \"@remix-run/react/dist/routes.js\";\n\texport interface PrecacheHandlerOptions\n\t  extends Omit<MessageHandlerParams, \"state\"> {\n\t  dataCacheName: string;\n\t  documentCacheName: string;\n\t  assetCacheName: string;\n", "  state?: PrecacheHandlerState;\n\t}\n\t/**\n\t * The state of the precache handler.\n\t * \n\t * Takes in additional payload (information) to pass to the handler.\n\t */\n\texport interface PrecacheHandlerState {\n\t  /**\n\t   * An array of routes to ignore when precaching. \n", "   * \n\t   * Can be an array of strings, regex patterns, or functions that takes in a route of type \n\t   * {@link https://github.com/remix-run/remix/blob/97d82db0556ba8b40518898a75d6838e0bf3ced1/packages/remix-react/routes.tsx#L38 EntryRoute}\n\t   * as argument and returns `boolean`. Or just a single function.\n\t   * \n\t   * *Example with strings*:\n\t   * ```ts\n\t   * ignoredRoutes: [\n\t   *  \"/catch\",\n\t   *  \"/error\",\n", "   * ]\n\t   * ```\n\t   * \n\t   * *Example with functions*:\n\t   * ```ts\n\t   * ignoredRoutes: [\n\t   *  (route) => route.id.includes(\"dashboard\")\n\t   * ]\n\t   * ```\n\t   */\n", "  ignoredRoutes?:\n\t    | RegExp[]\n\t    | string[]\n\t    | ((route: EntryRoute) => boolean)[]\n\t    | ((route: EntryRoute) => boolean)\n\t    | null;\n\t}\n\texport class PrecacheHandler extends MessageHandler {\n\t  dataCacheName: string;\n\t  documentCacheName: string;\n", "  assetCacheName: string;\n\t  private _ignoredFiles: PrecacheHandlerState[\"ignoredRoutes\"] = null;\n\t  constructor({\n\t    plugins,\n\t    dataCacheName,\n\t    documentCacheName,\n\t    assetCacheName,\n\t    state,\n\t  }: PrecacheHandlerOptions) {\n\t    super({ plugins, state: {} });\n", "    this.dataCacheName = dataCacheName;\n\t    this.documentCacheName = documentCacheName;\n\t    this.assetCacheName = assetCacheName;\n\t    this._handleMessage = this._handleMessage.bind(this);\n\t    this._ignoredFiles = state?.ignoredRoutes || null;\n\t  }\n\t  override async _handleMessage(event: ExtendableMessageEvent): Promise<void> {\n\t    let DATA_CACHE, DOCUMENT_CACHE, ASSET_CACHE;\n\t    DATA_CACHE = this.dataCacheName;\n\t    DOCUMENT_CACHE = this.documentCacheName;\n", "    ASSET_CACHE = this.assetCacheName;\n\t    this.runPlugins(\"messageDidReceive\", {\n\t      event,\n\t    });\n\t    const cachePromises: Map<string, Promise<void>> = new Map();\n\t    const [dataCache, documentCache, assetCache] = await Promise.all([\n\t      caches.open(DATA_CACHE),\n\t      caches.open(DOCUMENT_CACHE),\n\t      caches.open(ASSET_CACHE),\n\t    ]);\n", "    const manifest: AssetsManifest = event.data.manifest;\n\t    const routes = Object.values(manifest?.routes || {});\n\t    for (const route of routes) {\n\t      if (route.id.includes(\"$\")) {\n\t        logger.info(\"Skipping parametrized route:\", route.id);\n\t        continue;\n\t      }\n\t      // Handle ignored routes \n\t      if (Array.isArray(this._ignoredFiles)) {\n\t        // E.g '/dashboard' or 'dashboard'\n", "        if (typeof this._ignoredFiles[0] === \"string\") {\n\t          const map = this._ignoredFiles.map((ignoredRoute) => {\n\t            ignoredRoute = ignoredRoute as unknown as string;\n\t            ignoredRoute = ignoredRoute.charAt(0) === \"/\" ? ignoredRoute : ignoredRoute = \"/\" + ignoredRoute;\n\t            // The || operator is still unknown imo, is it needed? Idk 🤨.\n\t            // We could add a feature that checks if the last char is a '/' and if it is, ignore all the children. Else, just that route.\n\t            if (getPathname(route) == ignoredRoute /* || route.id.includes(ignoredRoute) */) {\n\t              logger.debug(\"Skipping ignored route:\", route.id);\n\t              return true;\n\t            } else {\n", "              return false;\n\t            }\n\t          });\n\t          if (map.includes(true)) continue;\n\t        }\n\t        // E.g (route) => route.id.includes('dashboard')\n\t        else if (typeof this._ignoredFiles[0] === \"function\") {\n\t          const map = this._ignoredFiles.map((ignoredRoute) => {\n\t            ignoredRoute = ignoredRoute as unknown as ((route: EntryRoute) => boolean);\n\t            if (ignoredRoute(route)) {\n", "              logger.debug(\"Skipping ignored route:\", route.id);\n\t              return true;\n\t            } else {\n\t              return false;\n\t            }\n\t          })\n\t          if (map.includes(true)) continue;\n\t        }\n\t        // E.g /dashboard/\n\t        else if (this._ignoredFiles[0] instanceof RegExp) {\n", "          let map = this._ignoredFiles.map((ignoredRoute) => {\n\t            ignoredRoute = ignoredRoute as unknown as RegExp;\n\t            if (ignoredRoute.test(getPathname(route))) {\n\t              logger.debug(\"Skipping ignored route:\", route.id);\n\t              return true;\n\t            } else {\n\t              return false;\n\t            }\n\t          })\n\t          if (map.includes(true)) continue;\n", "        }\n\t        else {\n\t          logger.error(\"Invalid ignoredRoutes type:\", this._ignoredFiles);\n\t        }\n\t      } else if (typeof this._ignoredFiles === \"function\") {\n\t        if (this._ignoredFiles(route)) {\n\t          logger.debug(\"Skipping ignored route:\", route.id);\n\t          continue;\n\t        }\n\t      }\n", "      logger.log(\"Precaching route:\", route.id);\n\t      cacheRoute(route);\n\t    }\n\t    await Promise.all(cachePromises.values());\n\t    function cacheRoute(route: EntryRoute) {\n\t      const pathname = getPathname(route);\n\t      if (route.hasLoader) {\n\t        cacheLoaderData(route);\n\t      }\n\t      if (route.module) {\n", "        cachePromises.set(route.module, cacheAsset(route.module));\n\t      }\n\t      if (route.imports) {\n\t        for (const assetUrl of route.imports) {\n\t          logger.groupCollapsed(\"Caching asset: \", assetUrl);\n\t          logger.log(\"Is index:\", route.index || false);\n\t          logger.log(\"Parent ID:\", route.parentId);\n\t          logger.log(\"Imports:\", route.imports);\n\t          logger.log(\"Module:\", route.module);\n\t          logger.groupEnd();\n", "          if (cachePromises.has(assetUrl)) {\n\t            continue;\n\t          }\n\t          cachePromises.set(assetUrl, cacheAsset(assetUrl));\n\t        }\n\t      }\n\t      logger.info(\"Caching document:\", pathname);\n\t      cachePromises.set(\n\t        pathname,\n\t        documentCache.add(pathname).catch((error) => {\n", "          if (error instanceof TypeError) {\n\t            logger.error(`TypeError when caching document ${pathname}:`, error.message);\n\t          } else if (error instanceof DOMException) {\n\t            logger.error(`DOMException when caching document ${pathname}:`, error.message);\n\t          } else {\n\t            logger.error(`Failed to cache document ${pathname}:`, error);\n\t          }\n\t        })\n\t      );\n\t    }\n", "    function cacheLoaderData(route: EntryRoute) {\n\t      const pathname = getPathname(route);\n\t      const params = new URLSearchParams({ _data: route.id });\n\t      const search = `?${params.toString()}`;\n\t      const url = pathname + search;\n\t      if (!cachePromises.has(url)) {\n\t        logger.debug(\"caching loader data\", url);\n\t        cachePromises.set(\n\t          url,\n\t          dataCache.add(url).catch((error) => {\n", "            if (error instanceof TypeError) {\n\t              logger.error(`TypeError when caching data ${pathname}:`, error.message);\n\t            } else if (error instanceof DOMException) {\n\t              logger.error(`DOMException when caching data ${pathname}:`, error.message);\n\t            } else {\n\t              logger.error(`Failed to cache data ${pathname}:`, error);\n\t            }\n\t          })\n\t        );\n\t      }\n", "    }\n\t    async function cacheAsset(assetUrl: string) {\n\t      if (await assetCache.match(assetUrl)) {\n\t        return;\n\t      }\n\t      logger.debug(\"Caching asset:\", assetUrl);\n\t      return assetCache.add(assetUrl).catch((error) => {\n\t        if (error instanceof TypeError) {\n\t          logger.error(`TypeError when caching asset ${assetUrl}:`, error.message);\n\t        } else if (error instanceof DOMException) {\n", "          logger.error(`DOMException when caching asset ${assetUrl}:`, error.message);\n\t        } else {\n\t          logger.error(`Failed to cache asset ${assetUrl}:`, error);\n\t        }\n\t      });\n\t    }\n\t    function getPathname(route: EntryRoute) {\n\t      if (route.index && route.parentId === \"root\") return \"/\";\n\t      let pathname = \"\";\n\t      if (route.path && route.path.length > 0) {\n", "        pathname = \"/\" + route.path;\n\t      }\n\t      if (route.parentId) {\n\t        const parentPath = getPathname(manifest.routes[route.parentId]);\n\t        if (parentPath) {\n\t          pathname = parentPath + pathname;\n\t        }\n\t      }\n\t      return pathname;\n\t    }\n", "  }\n\t}\n"]}
{"filename": "src/message/remixNavigationHandler.ts", "chunked_list": ["import { logger } from '../core/logger.js';\n\timport { MessageHandler } from './message.js';\n\timport type { MessageHandlerParams } from './message.js';\n\texport interface RemixNavigationHandlerOptions extends MessageHandlerParams {\n\t  dataCacheName: string;\n\t  documentCacheName: string;\n\t}\n\texport class RemixNavigationHandler extends MessageHandler {\n\t  dataCacheName: string;\n\t  documentCacheName: string;\n", "  constructor({\n\t    plugins,\n\t    dataCacheName,\n\t    documentCacheName,\n\t    state\n\t  }: RemixNavigationHandlerOptions) {\n\t    super({ plugins, state });\n\t    this.dataCacheName = dataCacheName;\n\t    this.documentCacheName = documentCacheName;\n\t    this._handleMessage = this._handleMessage.bind(this);\n", "  }\n\t  override async _handleMessage(\n\t    event: ExtendableMessageEvent\n\t  ): Promise<void> {\n\t    const { data } = event;\n\t    let DATA, PAGES;\n\t    DATA = this.dataCacheName;\n\t    PAGES = this.documentCacheName;\n\t    this.runPlugins(\"messageDidReceive\", {\n\t      event,\n", "    })\n\t    let cachePromises: Map<string, Promise<void>> = new Map();\n\t    if (data.type === 'REMIX_NAVIGATION') {\n\t      let { isMount, location, matches, manifest } = data;\n\t      let documentUrl = location.pathname + location.search + location.hash;\n\t      let [dataCache, documentCache, existingDocument] = await Promise.all([\n\t        caches.open(DATA),\n\t        caches.open(PAGES),\n\t        caches.match(documentUrl)\n\t      ]);\n", "      if (!existingDocument || !isMount) {\n\t        cachePromises.set(\n\t          documentUrl,\n\t          documentCache.add(documentUrl).catch((error) => {\n\t            logger.error(`Failed to cache document for ${documentUrl}:`, error);\n\t          })\n\t        );\n\t      }\n\t      if (isMount) {\n\t        for (let match of matches) {\n", "          if (manifest.routes[match.id].hasLoader) {\n\t            let params = new URLSearchParams(location.search);\n\t            params.set('_data', match.id);\n\t            let search = params.toString();\n\t            search = search ? `?${search}` : '';\n\t            let url = location.pathname + search + location.hash;\n\t            if (!cachePromises.has(url)) {\n\t              logger.debug('Caching data for:', url);\n\t              cachePromises.set(\n\t                url,\n", "                dataCache.add(url).catch((error) => {\n\t                  logger.error(`Failed to cache data for ${url}:`, error);\n\t                })\n\t              );\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t    await Promise.all(cachePromises.values());\n", "  }\n\t}\n"]}
{"filename": "src/message/message.ts", "chunked_list": ["import type { MessagePlugin } from '../plugins/interfaces/messagePlugin.js';\n\timport type { MessageEnv } from './types.js';\n\texport interface MessageHandlerParams {\n\t  plugins?: MessagePlugin[];\n\t  state?: MessageEnv;\n\t}\n\texport abstract class MessageHandler {\n\t  /**\n\t   * The plugins array is used to run plugins before and after the message handler.\n\t   * They are passed in when the handler is initialised.\n", "   */\n\t  protected plugins: MessagePlugin[];\n\t  /**\n\t   * The state object is used to pass data between plugins.\n\t   */\n\t  protected state: MessageEnv;\n\t  constructor({ plugins, state }: MessageHandlerParams = {}) {\n\t    this.plugins = plugins || [];\n\t    this.state = state || {};\n\t  }\n", "  /**\n\t   * The method that handles the message event. \n\t   * \n\t   * Takes in the MessageEvent as a mandatory argument as well as an optional \n\t   * object that can be used to pass further information/data. \n\t   */\n\t  async handle(event: ExtendableMessageEvent, state: Record<string, any> = {}) {\n\t    await this._handleMessage(event, state);\n\t  }\n\t  protected abstract _handleMessage(\n", "    event: ExtendableMessageEvent,\n\t    state: Record<string, any>\n\t  ): Promise<void> | void;\n\t  /**\n\t   * Runs the plugins that are passed in when the handler is initialised.\n\t   */\n\t  protected async runPlugins(hook: keyof MessagePlugin, env: MessageEnv) {\n\t    for (const plugin of this.plugins) {\n\t      if (plugin[hook]) {\n\t        plugin[hook]!(env);\n", "      }\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/strategy/strategy.ts", "chunked_list": ["import { isHttpRequest } from '../core/helper.js';\n\timport { StrategyPlugin } from '../plugins/interfaces/strategyPlugin.js';\n\timport { CacheQueryMatchOptions, CacheStrategyOptions } from './types.js';\n\texport type StrategyHandlerParams = {\n\t  request: Request;\n\t  options?: CacheQueryMatchOptions;\n\t};\n\texport abstract class CacheStrategy {\n\t  protected cacheName: string;\n\t  protected plugins: StrategyPlugin[];\n", "  protected isLoader: boolean;\n\t  protected matchOptions?: CacheQueryMatchOptions;\n\t  // todo: (ShafSpecs) Fix this!\n\t  constructor({\n\t    cacheName,\n\t    isLoader = false,\n\t    plugins = [],\n\t    matchOptions = {}\n\t  }: CacheStrategyOptions) {\n\t    this.cacheName = cacheName;\n", "    this.isLoader = isLoader;\n\t    this.plugins = plugins;\n\t    this.matchOptions = matchOptions;\n\t  }\n\t  protected abstract _handle(request: Request): Promise<Response>;\n\t  // Can you return null or a custom, handled error???\n\t  async handle(request: Request): Promise<Response> {\n\t    if (!isHttpRequest(request)) {\n\t      // (ShafSpecs) todo: Handle this better. Can't be throwing errors\n\t      // all over the user app if the SW intercepts an extension request\n", "      // throw new Error(\"The request is not an HTTP request\");\n\t      // (ShafSpecs) todo: also improve on this\n\t      return new Response('Not a HTTP request', { status: 403 });\n\t    }\n\t    return this._handle(request);\n\t  }\n\t}\n"]}
{"filename": "src/strategy/types.ts", "chunked_list": ["/**\n\t * Contains global types for this sub-module\n\t */\n\timport { StrategyPlugin } from '../plugins/interfaces/strategyPlugin.js';\n\texport interface CacheQueryMatchOptions\n\t  extends Omit<CacheQueryOptions, 'cacheName' | 'ignoreMethod'> {}\n\texport interface CacheStrategyOptions {\n\t  cacheName: string;\n\t  plugins?: StrategyPlugin[];\n\t  isLoader?: boolean;\n", "  matchOptions?: CacheQueryMatchOptions;\n\t}\n\texport interface FetchListenerEnvState extends Record<string, any> {\n\t  fetcher?: typeof fetch;\n\t}\n\texport interface FetchListenerEnv {\n\t  event?: FetchEvent;\n\t  state?: FetchListenerEnvState;\n\t}\n"]}
{"filename": "src/strategy/networkFirst.ts", "chunked_list": ["import { toError } from '../core/helper.js';\n\timport { CacheStrategy } from './strategy.js';\n\timport { CacheStrategyOptions, FetchListenerEnv } from './types.js';\n\texport interface NetworkFirstOptions extends CacheStrategyOptions {\n\t  networkTimeoutSeconds?: number;\n\t}\n\texport class NetworkFirst extends CacheStrategy {\n\t  private fetchListenerEnv: FetchListenerEnv;\n\t  private readonly _networkTimeoutSeconds: number;\n\t  constructor(options: NetworkFirstOptions, env: FetchListenerEnv = {}) {\n", "    super(options);\n\t    this.fetchListenerEnv = env;\n\t    // Default timeout of `Infinity`\n\t    this._networkTimeoutSeconds = options.networkTimeoutSeconds || Infinity;\n\t  }\n\t  override async _handle(request: Request) {\n\t    const cache = await caches.open(this.cacheName);\n\t    try {\n\t      const response = await this.fetchAndCache(request);\n\t      return response;\n", "    } catch (error) {\n\t      let err = toError(error);\n\t      const cachedResponse = await cache.match(request, this.matchOptions);\n\t      if (cachedResponse) {\n\t        const body = cachedResponse.clone().body;\n\t        const headers = new Headers(cachedResponse.clone().headers);\n\t        // Safari throws an error if we try to mutate the headers directly\n\t        const newResponse = new Response(body, {\n\t          headers: { ...headers, 'X-Remix-Worker': 'yes' },\n\t          status: cachedResponse.status,\n", "          statusText: cachedResponse.statusText\n\t        });\n\t        return newResponse;\n\t      }\n\t      // throw error;\n\t      return new Response(JSON.stringify({ message: 'Network Error' }), {\n\t        status: 500,\n\t        headers: { 'X-Remix-Catch': 'yes', 'X-Remix-Worker': 'yes' }\n\t      });\n\t    }\n", "  }\n\t  private async fetchAndCache(request: Request): Promise<Response> {\n\t    const cache = await caches.open(this.cacheName);\n\t    const timeoutPromise =\n\t      this._networkTimeoutSeconds !== Infinity\n\t        ? new Promise<Response>((_, reject) => {\n\t            setTimeout(() => {\n\t              reject(\n\t                new Error(\n\t                  `Network timed out after ${this._networkTimeoutSeconds} seconds`\n", "                )\n\t              );\n\t            }, this._networkTimeoutSeconds * 1000);\n\t          })\n\t        : null;\n\t    const fetcher = this.fetchListenerEnv.state?.fetcher || fetch;\n\t    let updatedRequest = request.clone();\n\t    for (const plugin of this.plugins) {\n\t      if (plugin.requestWillFetch) {\n\t        updatedRequest = await plugin.requestWillFetch({\n", "          request: updatedRequest\n\t        });\n\t      }\n\t    }\n\t    const fetchPromise = fetcher(updatedRequest).catch((err) => {\n\t      for (const plugin of this.plugins) {\n\t        if (plugin.fetchDidFail)\n\t          plugin.fetchDidFail({\n\t            request: updatedRequest,\n\t            error: err as unknown as Error\n", "          });\n\t      }\n\t    });\n\t    let response = timeoutPromise\n\t      ? await Promise.race([fetchPromise, timeoutPromise])\n\t      : await fetchPromise;\n\t    // If the fetch was successful, then proceed along else throw an error\n\t    if (response) {\n\t      // `fetchDidSucceed` performs some changes to response so store it elsewhere\n\t      // to avoid overtyping original variable\n", "      let updatedResponse: Response = response.clone();\n\t      for (const plugin of this.plugins) {\n\t        if (plugin.fetchDidSucceed) {\n\t          updatedResponse = await plugin.fetchDidSucceed({\n\t            request: updatedRequest,\n\t            response: updatedResponse\n\t          });\n\t        }\n\t      }\n\t      // `null` can be returned here to avoid caching resources. Hence store in\n", "      // a new variable that can be checked for if null.\n\t      let aboutToBeCachedResponse: Response | null = updatedResponse;\n\t      for (const plugin of this.plugins) {\n\t        if (plugin.cacheWillUpdate) {\n\t          aboutToBeCachedResponse = await plugin.cacheWillUpdate({\n\t            request: updatedRequest,\n\t            response: aboutToBeCachedResponse!\n\t          });\n\t          if (!aboutToBeCachedResponse) {\n\t            break;\n", "          }\n\t        }\n\t      }\n\t      // If response wasn't null, update cache and return the response\n\t      if (aboutToBeCachedResponse) {\n\t        await cache.put(request, response.clone());\n\t        for (const plugin of this.plugins) {\n\t          if (plugin.cacheDidUpdate) {\n\t            await plugin.cacheDidUpdate({\n\t              request: updatedRequest,\n", "              cacheName: this.cacheName,\n\t              newResponse: updatedResponse\n\t            });\n\t          }\n\t        }\n\t        return aboutToBeCachedResponse;\n\t      }\n\t      return updatedResponse;\n\t    }\n\t    throw new Error('No response received from fetch: Timeout');\n", "  }\n\t}\n"]}
{"filename": "src/strategy/cacheFirst.ts", "chunked_list": ["import { CacheStrategy } from './strategy.js';\n\texport class CacheFirst extends CacheStrategy {\n\t  override async _handle(request: Request) {\n\t    let response = await this.getFromCache(request);\n\t    if (!response) {\n\t      response = await this.getFromNetwork(request);\n\t      if (response) {\n\t        await this.updateCache(request, response.clone());\n\t      }\n\t    }\n", "    const headers = { 'X-Remix-Catch': 'yes', 'X-Remix-Worker': 'yes' };\n\t    return response\n\t      ? response\n\t      : new Response('Not found', {\n\t          status: 404,\n\t          headers: this.isLoader ? headers : {}\n\t        });\n\t  }\n\t  private async getFromCache(request: Request): Promise<Response | null> {\n\t    const cache = await caches.open(this.cacheName);\n", "    let cachedResponse = await cache.match(request, {\n\t      ignoreVary: this.matchOptions?.ignoreVary || false,\n\t      ignoreSearch: this.matchOptions?.ignoreSearch || false\n\t    });\n\t    if (cachedResponse) {\n\t      let res: Response | null = cachedResponse.clone();\n\t      for (const plugin of this.plugins) {\n\t        if (plugin.cachedResponseWillBeUsed) {\n\t          res = await plugin.cachedResponseWillBeUsed({\n\t            cacheName: this.cacheName,\n", "            request,\n\t            cachedResponse,\n\t            matchOptions: this.matchOptions || {}\n\t          });\n\t          if (!res) {\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      return res;\n", "    }\n\t    return null;\n\t  }\n\t  private async getFromNetwork(request: Request): Promise<Response | null> {\n\t    let req: Request = request.clone();\n\t    for (const plugin of this.plugins) {\n\t      if (plugin.requestWillFetch) {\n\t        req = await plugin.requestWillFetch({ request: req });\n\t      }\n\t    }\n", "    let response = await fetch(req).catch((err) => {\n\t      for (const plugin of this.plugins) {\n\t        if (plugin.fetchDidFail) {\n\t          plugin.fetchDidFail({\n\t            request: req.clone(),\n\t            error: err\n\t          });\n\t        }\n\t      }\n\t    });\n", "    if (response) {\n\t      for (const plugin of this.plugins) {\n\t        if (plugin.fetchDidSucceed) {\n\t          response = await plugin.fetchDidSucceed({ request: req, response });\n\t        }\n\t      }\n\t      return response;\n\t    }\n\t    return null;\n\t  }\n", "  private async updateCache(\n\t    request: Request,\n\t    response: Response\n\t  ): Promise<void> {\n\t    const cache = await caches.open(this.cacheName);\n\t    const oldResponse = await cache.match(request);\n\t    let newResponse: Response | null = response.clone();\n\t    for (const plugin of this.plugins) {\n\t      if (plugin.cacheWillUpdate) {\n\t        newResponse = await plugin.cacheWillUpdate({\n", "          response: newResponse.clone(),\n\t          request\n\t        });\n\t        if (!newResponse) {\n\t          break;\n\t        }\n\t      }\n\t    }\n\t    if (newResponse) {\n\t      await cache.put(request, newResponse.clone());\n", "      for (const plugin of this.plugins) {\n\t        if (plugin.cacheDidUpdate) {\n\t          plugin.cacheDidUpdate({\n\t            cacheName: this.cacheName,\n\t            request,\n\t            oldResponse,\n\t            newResponse\n\t          });\n\t        }\n\t      }\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src/strategy/cacheOnly.ts", "chunked_list": ["import { CacheStrategy } from './strategy.js';\n\t// todo: Should include a way to cache everything at once when the service worker gets loaded\n\texport class CacheOnly extends CacheStrategy {\n\t  override async _handle(request: Request) {\n\t    const cache = await caches.open(this.cacheName);\n\t    let response = await cache.match(request, {\n\t      ignoreSearch: this.matchOptions?.ignoreSearch ?? false,\n\t      ignoreVary: this.matchOptions?.ignoreVary ?? false\n\t    });\n\t    if (!response) {\n", "      // throw new Error(`Unable to find response in cache.`);\n\t      const headers = { 'X-Remix-Catch': 'yes', 'X-Remix-Worker': 'yes' };\n\t      return new Response(JSON.stringify({ message: 'Not Found' }), {\n\t        status: 404,\n\t        ...(this.isLoader ? { headers } : {})\n\t      });\n\t    } else {\n\t      let modifiedResponse: Response | null = response.clone();\n\t      for (const plugin of this.plugins) {\n\t        if (plugin.cachedResponseWillBeUsed) {\n", "          modifiedResponse = await plugin.cachedResponseWillBeUsed({\n\t            cacheName: this.cacheName,\n\t            matchOptions: this.matchOptions || {},\n\t            request,\n\t            cachedResponse: response.clone()\n\t          });\n\t        }\n\t      }\n\t      if (!modifiedResponse) {\n\t        // throw new Error(`Unable to find response in cache.`);\n", "        const headers = { 'X-Remix-Catch': 'yes', 'X-Remix-Worker': 'yes' };\n\t        return new Response(JSON.stringify({ message: 'Not Found' }), {\n\t          status: 404,\n\t          ...(this.isLoader ? { headers } : {})\n\t        });\n\t      }\n\t      if (this.isLoader) {\n\t        modifiedResponse.headers.set('X-Remix-Worker', 'yes');\n\t      }\n\t      return modifiedResponse;\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src/strategy/networkOnly.ts", "chunked_list": ["import { toError } from '../core/helper.js';\n\timport { CacheStrategy } from './strategy.js';\n\timport { CacheStrategyOptions, FetchListenerEnv } from './types.js';\n\texport interface NetworkOnlyOptions\n\t  extends Omit<CacheStrategyOptions, 'cacheName' | 'matchOptions'> {\n\t  networkTimeoutSeconds?: number;\n\t}\n\texport class NetworkOnly extends CacheStrategy {\n\t  private fetchListenerEnv: FetchListenerEnv;\n\t  private readonly _networkTimeoutSeconds: number;\n", "  constructor(options: NetworkOnlyOptions = {}, env?: FetchListenerEnv) {\n\t    // this is gonna come back and bite me. \n\t    // I need to sort this out quick though\n\t    //@ts-ignore\n\t    super(options);\n\t    this.fetchListenerEnv = env || {};\n\t    this._networkTimeoutSeconds = options.networkTimeoutSeconds || 10;\n\t  }\n\t  override async _handle(request: Request) {\n\t    if (request.method !== 'GET') {\n", "      return fetch(request);\n\t    }\n\t    // `fetcher` is a custom fetch function that can de defined and passed to the constructor or just regular fetch\n\t    const fetcher = this.fetchListenerEnv.state!.fetcher || fetch;\n\t    const timeoutPromise = new Promise((_, reject) => {\n\t      setTimeout(() => {\n\t        reject(\n\t          new Error(\n\t            `Network request timed out after ${\n\t              this._networkTimeoutSeconds * 1000\n", "            } seconds`\n\t          )\n\t        );\n\t      }, this._networkTimeoutSeconds * 1000);\n\t    });\n\t    try {\n\t      for (let plugin of this.plugins) {\n\t        if (plugin.requestWillFetch) {\n\t          plugin.requestWillFetch({\n\t            request\n", "          });\n\t        }\n\t      }\n\t      const fetchPromise: Response = await fetcher(request);\n\t      const response = (await Promise.race([\n\t        fetchPromise,\n\t        timeoutPromise\n\t      ])) as Response;\n\t      if (response) {\n\t        for (const plugin of this.plugins) {\n", "          if (plugin.fetchDidSucceed) {\n\t            await plugin.fetchDidSucceed({\n\t              request,\n\t              response\n\t            });\n\t          }\n\t        }\n\t        return response;\n\t      }\n\t      // Re-thrown error to be caught by `catch` block\n", "      throw new Error('Network request failed');\n\t    } catch (error) {\n\t      for (const plugin of this.plugins) {\n\t        if (plugin.fetchDidFail) {\n\t          await plugin.fetchDidFail({\n\t            request,\n\t            error: toError(error)\n\t          });\n\t        }\n\t      }\n", "      const headers = { 'X-Remix-Catch': 'yes', 'X-Remix-Worker': 'yes' };\n\t      return new Response(JSON.stringify({ message: 'Network Error' }), {\n\t        status: 500,\n\t        ...(this.isLoader ? { headers } : {})\n\t      });\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/workbox/main.ts", "chunked_list": ["import { isAssetRequest, isDocumentRequest, isLoaderRequest } from \"../fetch/match\";\n\texport type WorkBoxProps = {\n\t  url: URL;\n\t  request: Request;\n\t  event: Event;\n\t};\n\texport function matchAssetRequest({ request }: WorkBoxProps, assetUrls: string[]) {\n\t  return isAssetRequest(request, assetUrls);\n\t}\n\texport function matchDocumentRequest({ request }: WorkBoxProps) {\n", "  return isDocumentRequest(request);\n\t}\n\texport function matchLoaderRequest({ request }: WorkBoxProps) {\n\t  return isLoaderRequest(request);\n\t}"]}
{"filename": "src/workbox/plugins/loaderPlugin.ts", "chunked_list": ["import type {\n\t  CachedResponseWillBeUsedCallback,\n\t  HandlerDidErrorCallback,\n\t  CachedResponseWillBeUsedCallbackParam,\n\t  FetchDidSucceedCallback,\n\t  FetchDidSucceedCallbackParam\n\t} from 'workbox-core/types.js';\n\t/* Plugins */\n\texport type RemixLoaderPlugin = {\n\t  cachedResponseWillBeUsed: CachedResponseWillBeUsedCallback;\n", "  handlerDidError: HandlerDidErrorCallback;\n\t  fetchDidSucceed: FetchDidSucceedCallback;\n\t};\n\t// Loader Plugin\n\texport const remixLoaderPlugin: RemixLoaderPlugin = {\n\t  fetchDidSucceed: async ({ response }: FetchDidSucceedCallbackParam) => {\n\t    // @ts-ignore\n\t    console.log('manifest', self.__remixManifest);\n\t    return response;\n\t  },\n", "  cachedResponseWillBeUsed: async ({\n\t    cachedResponse\n\t  }: CachedResponseWillBeUsedCallbackParam) => {\n\t    cachedResponse?.headers.set('X-Remix-Worker', 'yes');\n\t    return cachedResponse;\n\t  },\n\t  handlerDidError: async () => {\n\t    return new Response(JSON.stringify({ message: 'Network Error' }), {\n\t      status: 500,\n\t      statusText: 'Internal Server Error',\n", "      headers: {\n\t        'Content-Type': 'application/json; charset=utf-8',\n\t        'X-Remix-Catch': 'yes',\n\t        'X-Remix-Worker': 'yes'\n\t      }\n\t    });\n\t  }\n\t};\n"]}
{"filename": "src/fetch/match.ts", "chunked_list": ["import { isMethod } from './fetch.js';\n\texport function isAssetRequest(\n\t  request: Request,\n\t  assetUrls: string[] = ['/build/', '/icons']\n\t): boolean {\n\t  return (\n\t    isMethod(request, ['get']) &&\n\t    assetUrls.some((publicPath) => request.url.includes(publicPath))\n\t  );\n\t}\n", "export function isDocumentRequest(request: Request): boolean {\n\t  return isMethod(request, ['get']) && request.mode === 'navigate';\n\t}\n\texport function isLoaderRequest(request: Request): string | false | null {\n\t  const url = new URL(request.url);\n\t  return isMethod(request, ['get']) && url.searchParams.get('_data');\n\t}\n\texport type MatchResponse = 'loader' | 'document' | 'asset' | null;\n\texport type MatchRequest = (\n\t  request: Request,\n", "  assetUrls?: string[]\n\t) => MatchResponse;\n\texport const matchRequest: MatchRequest = (\n\t  request: Request,\n\t  assetUrls = ['/build/', '/icons']\n\t): MatchResponse => {\n\t  if (isAssetRequest(request, assetUrls)) {\n\t    return 'asset';\n\t  } else if (isLoaderRequest(request)) {\n\t    return 'loader';\n", "  } else if (isDocumentRequest(request)) {\n\t    return 'document';\n\t  } else {\n\t    return null;\n\t  }\n\t};\n"]}
{"filename": "src/fetch/fetch.ts", "chunked_list": ["import { CacheStrategy } from '../strategy/strategy';\n\texport function isMethod(request: Request, methods: string[]): boolean {\n\t  return methods.includes(request.method.toLowerCase());\n\t}\n\texport const handleFetchRequest = (\n\t  request: Request,\n\t  strategy: CacheStrategy\n\t) => {\n\t  return strategy.handle(request);\n\t};\n"]}
{"filename": "src/react/registration.ts", "chunked_list": ["export async function unregisterServiceWorker() {\n\t  const registration = await navigator.serviceWorker.getRegistration();\n\t  await registration?.unregister();\n\t}"]}
{"filename": "src/react/useSWEffect.ts", "chunked_list": ["import React from \"react\";\n\timport { useLocation, useMatches } from \"@remix-run/react\";\n\timport type { RouteMatch} from \"@remix-run/react\";\n\tlet isMount = true;\n\t/**\n\t * This hook is used to send navigation events to the service worker.\n\t * It is to be called in the `root` file of your Remix application.\n\t */\n\texport function useSWEffect(): void {\n\t  let location = useLocation();\n", "  let matches = useMatches();\n\t  function isPromise(p: any): boolean {\n\t    if (p && typeof p === \"object\" && typeof p.then === \"function\") {\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t  function isFunction(p: any): boolean {\n\t    if (typeof p === \"function\") {\n\t      return true;\n", "    }\n\t    return false;\n\t  }\n\t  React.useEffect(() => {\n\t    let mounted = isMount;\n\t    isMount = false;\n\t    if (\"serviceWorker\" in navigator) {\n\t      if (navigator.serviceWorker.controller) {\n\t        navigator.serviceWorker.controller?.postMessage({\n\t          type: \"REMIX_NAVIGATION\",\n", "          isMount: mounted,\n\t          location,\n\t          matches: matches.filter(filteredMatches).map(sanitizeHandleObject),\n\t          manifest: window.__remixManifest,\n\t        });\n\t      } else {\n\t        let listener = async () => {\n\t          await navigator.serviceWorker.ready;\n\t          navigator.serviceWorker.controller?.postMessage({\n\t            type: \"REMIX_NAVIGATION\",\n", "            isMount: mounted,\n\t            location,\n\t            matches: matches.filter(filteredMatches).map(sanitizeHandleObject),\n\t            manifest: window.__remixManifest,\n\t          });\n\t        };\n\t        navigator.serviceWorker.addEventListener(\"controllerchange\", listener);\n\t        return () => {\n\t          navigator.serviceWorker.removeEventListener(\n\t            \"controllerchange\",\n", "            listener\n\t          );\n\t        };\n\t      }\n\t    }\n\t    function filteredMatches(route: RouteMatch) {\n\t      if (route.data) {\n\t        return (\n\t          Object.values(route.data).filter((elem) => {\n\t            return isPromise(elem);\n", "          }).length === 0\n\t        );\n\t      }\n\t      return true;\n\t    }\n\t    function sanitizeHandleObject(route: RouteMatch) {\n\t      let handle = route.handle;\n\t      if (handle) {\n\t        const filterInvalidTypes = ([, value]: any) =>\n\t          !isPromise(value) && !isFunction(value);\n", "        //@ts-ignore Seems like typescript had too much fun last night :(\n\t        handle = Object.fromEntries(\n\t          Object.entries(route.handle!).filter(filterInvalidTypes)\n\t        );\n\t      }\n\t      return { ...route, handle };\n\t    }\n\t    return () => {};\n\t  }, [location, matches]);\n\t}\n"]}
{"filename": "src/react/loader.ts", "chunked_list": ["/// <reference lib=\"WebWorker\" />\n\timport type { AssetsManifest } from '@remix-run/dev';\n\timport { logger } from '../core/logger.js';\n\tdeclare global {\n\t  interface Window {\n\t    __remixManifest: AssetsManifest;\n\t  }\n\t}\n\texport type LoadServiceWorkerOptions = {\n\t  scope?: string;\n", "  serviceWorkerUrl?: string;\n\t};\n\t/**\n\t * Load service worker in `entry.client` when the client gets hydrated.\n\t *\n\t * All parameters are optional.\n\t *\n\t * @param {string} LoadServiceWorkerOptions.scope - Scope of the service worker.\n\t * @param {string} LoadServiceWorkerOptions.serviceWorkerUrl - URL of the service worker.\n\t *\n", " * ```ts\n\t * loadServiceWorker({\n\t *  scope: \"/\",\n\t *  serviceWorkerUrl: \"/entry.worker.js\"\n\t * })\n\t * ```\n\t */\n\texport function loadServiceWorker(\n\t  options: LoadServiceWorkerOptions = {\n\t    scope: '/',\n", "    serviceWorkerUrl: '/entry.worker.js'\n\t  }\n\t) {\n\t  if ('serviceWorker' in navigator) {\n\t    async function register() {\n\t      try {\n\t        await navigator.serviceWorker\n\t          //@ts-ignore\n\t          .register(options.serviceWorkerUrl, {\n\t            scope: options.scope\n", "          })\n\t          .then(() => navigator.serviceWorker.ready)\n\t          .then(() => {\n\t            logger.debug('Syncing manifest...');\n\t            if (navigator.serviceWorker.controller) {\n\t              navigator.serviceWorker.controller.postMessage({\n\t                type: 'SYNC_REMIX_MANIFEST',\n\t                manifest: window.__remixManifest\n\t              });\n\t            } else {\n", "              navigator.serviceWorker.addEventListener(\n\t                'controllerchange',\n\t                () => {\n\t                  logger.debug('Syncing manifest...');\n\t                  navigator.serviceWorker.controller?.postMessage({\n\t                    type: 'SYNC_REMIX_MANIFEST',\n\t                    manifest: window.__remixManifest\n\t                  });\n\t                }\n\t              );\n", "            }\n\t          });\n\t      } catch (error) {\n\t        // console.error('Service worker registration failed', error);\n\t      }\n\t    }\n\t    if (\n\t      document.readyState === 'complete' ||\n\t      document.readyState === 'interactive'\n\t    ) {\n", "      register();\n\t    } else {\n\t      window.addEventListener('load', register);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/core/helper.ts", "chunked_list": ["/**\n\t * @fileoverview Helper functions used across the codebase.\n\t */\n\texport const isHttpRequest = (request: Request): boolean => {\n\t  return request.url.startsWith('http');\n\t};\n\texport function isDev(): boolean {\n\t  return process.env.NODE_ENV === 'development';\n\t}\n\texport function toError(error: unknown): Error {\n", "  if (error instanceof Error) {\n\t    return error;\n\t  }\n\t  return error as Error;\n\t}\n"]}
{"filename": "src/core/logger.ts", "chunked_list": ["declare global {\n\t  interface WorkerGlobalScope {\n\t    /**\n\t     * Disable all logs from displaying in the console.\n\t     *\n\t     * @default false\n\t     */\n\t    __DISABLE_PWA_DEV_LOGS: boolean;\n\t    /**\n\t     * Disable debug logs from displaying in the console.\n", "     *\n\t     * @default false\n\t     */\n\t    __DISABLE_PWA_DEBUG_LOGS: boolean;\n\t    /**\n\t     * Disable info logs from displaying in the console.\n\t     *\n\t     * @default false\n\t     */\n\t    __DISABLE_PWA_INFO_LOGS: boolean;\n", "    /**\n\t     * Disable warning logs from displaying in the console.\n\t     *\n\t     * @default false\n\t     */\n\t    __DISABLE_PWA_WARN_LOGS: boolean;\n\t    /**\n\t     * Disable error logs from displaying in the console.\n\t     *\n\t     * @default false\n", "     */\n\t    __DISABLE_PWA_ERROR_LOGS: boolean;\n\t  }\n\t  interface Window {\n\t    /**\n\t     * Disable all logs from displaying in the console.\n\t     *\n\t     * @default false\n\t     */\n\t    __DISABLE_PWA_DEV_LOGS: boolean;\n", "    /**\n\t     * Disable debug logs from displaying in the console.\n\t     *\n\t     * @default false\n\t     */\n\t    __DISABLE_PWA_DEBUG_LOGS: boolean;\n\t    /**\n\t     * Disable info logs from displaying in the console.\n\t     *\n\t     * @default false\n", "     */\n\t    __DISABLE_PWA_INFO_LOGS: boolean;\n\t    /**\n\t     * Disable warning logs from displaying in the console.\n\t     *\n\t     * @default false\n\t     */\n\t    __DISABLE_PWA_WARN_LOGS: boolean;\n\t    /**\n\t     * Disable error logs from displaying in the console.\n", "     *\n\t     * @default false\n\t     */\n\t    __DISABLE_PWA_ERROR_LOGS: boolean;\n\t  }\n\t}\n\texport type LoggerMethods =\n\t  | 'debug'\n\t  | 'info'\n\t  | 'log'\n", "  | 'warn'\n\t  | 'error'\n\t  | 'groupCollapsed'\n\t  | 'groupEnd';\n\t  const methodToColorMap: { [methodName: string]: string | null } = {\n\t    debug: `#7f8c8d`, // Gray\n\t    log: `#2ecc71`, // Green\n\t    info: `#3498db`, // Blue\n\t    warn: `#f39c12`, // Yellow\n\t    error: `#c0392b`, // Red\n", "    groupCollapsed: `#3498db`, // Blue\n\t    groupEnd: null // No colored prefix on groupEnd\n\t  };\n\t  const noop = () => {};\n\texport const logger = (\n\t  process.env.NODE_ENV === 'production'\n\t    ? (() => { // eslint-disable-next-line @typescript-eslint/ban-types\n\t      const api: { [methodName: string]: Function } = {};\n\t      const loggerMethods = Object.keys(methodToColorMap);\n\t      self.__DISABLE_PWA_DEBUG_LOGS = true;\n", "      self.__DISABLE_PWA_DEV_LOGS = true;\n\t      self.__DISABLE_PWA_INFO_LOGS = true;\n\t      self.__DISABLE_PWA_WARN_LOGS = true;\n\t      self.__DISABLE_PWA_ERROR_LOGS = true;\n\t      for (const key of loggerMethods) {\n\t        const method = key as LoggerMethods;\n\t        api[method] = noop;\n\t      }\n\t      return api as unknown;\n\t    })()\n", "    : (() => {\n\t        // Todo: Add a way to disable logs by default, ig.\n\t        // This throws an error: `self is not defined`\n\t        // if (('__DISABLE_PWA_DEBUG_LOGS' in self) == false) {\n\t        //   self.__DISABLE_PWA_DEBUG_LOGS = false;\n\t        // }\n\t        // if (('__DISABLE_PWA_DEV_LOGS' in self) == false) {\n\t        //   self.__DISABLE_PWA_DEV_LOGS = false;\n\t        // }\n\t        // if (('__DISABLE_PWA_DEBUG_LOGS' in self) == false) {\n", "        //   self.__DISABLE_PWA_DEBUG_LOGS = false;\n\t        // }\n\t        // if (('__DISABLE_PWA_INFO_LOGS' in self) == false) {\n\t        //   self.__DISABLE_PWA_INFO_LOGS = false;\n\t        // }\n\t        // if (('__DISABLE_PWA_WARN_LOGS' in self) == false) {\n\t        //   self.__DISABLE_PWA_WARN_LOGS = false;\n\t        // }\n\t        let inGroup = false;\n\t        const print = function (method: LoggerMethods, args: any[]) {\n", "          // Conditionals to handle various log levels.\n\t          if (self.__DISABLE_PWA_DEV_LOGS) {\n\t            return;\n\t          }\n\t          if (method === 'debug' && self.__DISABLE_PWA_DEBUG_LOGS) {\n\t            return;\n\t          }\n\t          if (method === 'info' && self.__DISABLE_PWA_INFO_LOGS) {\n\t            return;\n\t          }\n", "          if (method === 'warn' && self.__DISABLE_PWA_WARN_LOGS) {\n\t            return;\n\t          }\n\t          if (method === 'error' && self.__DISABLE_PWA_ERROR_LOGS) {\n\t            return;\n\t          }\n\t          if (method === 'groupCollapsed') {\n\t            // Safari doesn't print all console.groupCollapsed() arguments:\n\t            // https://bugs.webkit.org/show_bug.cgi?id=182754\n\t            if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n", "              console[method](...args);\n\t              return;\n\t            }\n\t          }\n\t          const styles = [\n\t            `background: ${methodToColorMap[method]!}`,\n\t            `border-radius: 0.5em`,\n\t            `color: white`,\n\t            `font-weight: bold`,\n\t            `padding: 2px 0.5em`\n", "          ];\n\t          const logPrefix = inGroup ? [] : ['%cremix-pwa', styles.join(';')];\n\t          console[method](...logPrefix, ...args);\n\t          if (method === 'groupCollapsed') {\n\t            inGroup = true;\n\t          }\n\t          if (method === 'groupEnd') {\n\t            inGroup = false;\n\t          }\n\t        };\n", "        // eslint-disable-next-line @typescript-eslint/ban-types\n\t        const api: { [methodName: string]: Function } = {};\n\t        const loggerMethods = Object.keys(methodToColorMap);\n\t        for (const key of loggerMethods) {\n\t          const method = key as LoggerMethods;\n\t          api[method] = (...args: any[]) => {\n\t            print(method, args);\n\t          };\n\t        }\n\t        return api as unknown;\n", "      })()\n\t) as Console;\n"]}
