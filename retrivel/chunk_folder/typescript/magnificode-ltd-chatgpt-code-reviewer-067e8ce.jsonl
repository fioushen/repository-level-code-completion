{"filename": "src/index.ts", "chunked_list": ["import CommentOnPullRequestService from './services/commentOnPullRequestService';\n\tconst commentOnPrService = new CommentOnPullRequestService();\n\tcommentOnPrService.addCommentToPr();\n"]}
{"filename": "src/config/promptsConfig.ts", "chunked_list": ["enum Prompt {\n\t  SYSTEM_PROMPT,\n\t}\n\tconst promptsConfig: { [key in Prompt]: string } = {\n\t  [Prompt.SYSTEM_PROMPT]:\n\t    'You now assume the role of a code reviewer. Based on the patch provide a list of suggestions how to improve the code with examples according to coding standards and best practices.\\nStart every suggestion with path to the file. Path to the file should start with @@ and end with @@',\n\t};\n\texport default promptsConfig;\n\texport { Prompt };\n"]}
{"filename": "src/config/errorsConfig.ts", "chunked_list": ["enum ErrorMessage {\n\t  MISSING_GITHUB_TOKEN,\n\t  MISSING_OPENAI_TOKEN,\n\t  NO_PULLREQUEST_IN_CONTEXT,\n\t  MISSING_PATCH_FOR_OPENAI_SUGGESTION,\n\t  NO_CHANGED_FILES_IN_PULL_REQUEST,\n\t}\n\tconst errorsConfig: { [key in ErrorMessage]: string } = {\n\t  [ErrorMessage.MISSING_GITHUB_TOKEN]:\n\t    'A GitHub token must be provided to use the Octokit API.',\n", "  [ErrorMessage.MISSING_OPENAI_TOKEN]:\n\t    'An OpenAI API token must be provided to use the OpenAI API. Make sure you have add a token with a name OPENAI_API_KEY in https://github.com/{user}/{repository}/settings/secrets/actions',\n\t  [ErrorMessage.NO_PULLREQUEST_IN_CONTEXT]:\n\t    'Pull request data must be provided, check payload and try again.',\n\t  [ErrorMessage.MISSING_PATCH_FOR_OPENAI_SUGGESTION]:\n\t    'The patch must be exist to provide a suggestions with Open AI',\n\t  [ErrorMessage.NO_CHANGED_FILES_IN_PULL_REQUEST]:\n\t    'There are not any changed files in provided pull request',\n\t};\n\texport default errorsConfig;\n", "export { ErrorMessage };\n"]}
{"filename": "src/services/types.ts", "chunked_list": ["import { getOctokit } from '@actions/github';\n\ttype Octokit = ReturnType<typeof getOctokit>;\n\ttype FilenameWithPatch = {\n\t  filename: string;\n\t  patch: string;\n\t  tokensUsed: number;\n\t};\n\ttype PullRequestInfo = {\n\t  owner: string;\n\t  repo: string;\n", "  pullHeadRef: string;\n\t  pullBaseRef: string;\n\t  pullNumber: number;\n\t};\n\texport type { Octokit, FilenameWithPatch, PullRequestInfo };\n"]}
{"filename": "src/services/commentOnPullRequestService.ts", "chunked_list": ["import { getInput } from '@actions/core';\n\timport { context, getOctokit } from '@actions/github';\n\timport { encode } from 'gpt-3-encoder';\n\timport errorsConfig, { ErrorMessage } from '../config/errorsConfig';\n\timport { FilenameWithPatch, Octokit, PullRequestInfo } from './types';\n\timport concatenatePatchesToString from './utils/concatenatePatchesToString';\n\timport divideFilesByTokenRange from './utils/divideFilesByTokenRange';\n\timport extractFirstChangedLineFromPatch from './utils/extractFirstChangedLineFromPatch';\n\timport getOpenAiSuggestions from './utils/getOpenAiSuggestions';\n\timport parseOpenAISuggestions from './utils/parseOpenAISuggestions';\n", "const MAX_TOKENS = parseInt(getInput('max_tokens'), 10) || 4096;\n\tconst OPENAI_TIMEOUT = 20000;\n\tclass CommentOnPullRequestService {\n\t  private readonly octokitApi: Octokit;\n\t  private readonly pullRequest: PullRequestInfo;\n\t  constructor() {\n\t    if (!process.env.GITHUB_TOKEN) {\n\t      throw new Error(errorsConfig[ErrorMessage.MISSING_GITHUB_TOKEN]);\n\t    }\n\t    if (!process.env.OPENAI_API_KEY) {\n", "      throw new Error(errorsConfig[ErrorMessage.MISSING_OPENAI_TOKEN]);\n\t    }\n\t    if (!context.payload.pull_request) {\n\t      throw new Error(errorsConfig[ErrorMessage.NO_PULLREQUEST_IN_CONTEXT]);\n\t    }\n\t    this.octokitApi = getOctokit(process.env.GITHUB_TOKEN);\n\t    this.pullRequest = {\n\t      owner: context.repo.owner,\n\t      repo: context.repo.repo,\n\t      pullHeadRef: context.payload?.pull_request.head.ref,\n", "      pullBaseRef: context.payload?.pull_request.base.ref,\n\t      pullNumber: context.payload?.pull_request.number,\n\t    };\n\t  }\n\t  private async getBranchDiff() {\n\t    const { owner, repo, pullBaseRef, pullHeadRef } = this.pullRequest;\n\t    const { data: branchDiff } =\n\t      await this.octokitApi.rest.repos.compareCommits({\n\t        owner,\n\t        repo,\n", "        base: pullBaseRef,\n\t        head: pullHeadRef,\n\t      });\n\t    return branchDiff;\n\t  }\n\t  private async getLastCommit() {\n\t    const { owner, repo, pullNumber } = this.pullRequest;\n\t    const { data: commitsList } = await this.octokitApi.rest.pulls.listCommits({\n\t      owner,\n\t      repo,\n", "      per_page: 50,\n\t      pull_number: pullNumber,\n\t    });\n\t    return commitsList[commitsList.length - 1].sha;\n\t  }\n\t  private async createReviewComments(files: FilenameWithPatch[]) {\n\t    const suggestionsListText = await getOpenAiSuggestions(\n\t      concatenatePatchesToString(files),\n\t    );\n\t    const suggestionsByFile = parseOpenAISuggestions(suggestionsListText);\n", "    const { owner, repo, pullNumber } = this.pullRequest;\n\t    const lastCommitId = await this.getLastCommit();\n\t    for (const file of files) {\n\t      const firstChangedLine = extractFirstChangedLineFromPatch(file.patch);\n\t      const suggestionForFile = suggestionsByFile.find(\n\t        (suggestion) => suggestion.filename === file.filename,\n\t      );\n\t      if (suggestionForFile) {\n\t        try {\n\t          const consoleTimeLabel = `Comment was created successfully for file: ${file.filename}`;\n", "          console.time(consoleTimeLabel);\n\t          await this.octokitApi.rest.pulls.createReviewComment({\n\t            owner,\n\t            repo,\n\t            pull_number: pullNumber,\n\t            line: firstChangedLine,\n\t            path: suggestionForFile.filename,\n\t            body: `[ChatGPTReviewer]\\n${suggestionForFile.suggestionText}`,\n\t            commit_id: lastCommitId,\n\t          });\n", "          console.timeEnd(consoleTimeLabel);\n\t        } catch (error) {\n\t          console.error(\n\t            'An error occurred while trying to add a comment',\n\t            error,\n\t          );\n\t          throw error;\n\t        }\n\t      }\n\t    }\n", "  }\n\t  public async addCommentToPr() {\n\t    const { files } = await this.getBranchDiff();\n\t    if (!files) {\n\t      throw new Error(\n\t        errorsConfig[ErrorMessage.NO_CHANGED_FILES_IN_PULL_REQUEST],\n\t      );\n\t    }\n\t    const patchesList: FilenameWithPatch[] = [];\n\t    const filesTooLongToBeChecked: string[] = [];\n", "    for (const file of files) {\n\t      if (file.patch && encode(file.patch).length <= MAX_TOKENS / 2) {\n\t        patchesList.push({\n\t          filename: file.filename,\n\t          patch: file.patch,\n\t          tokensUsed: encode(file.patch).length,\n\t        });\n\t      } else {\n\t        filesTooLongToBeChecked.push(file.filename);\n\t      }\n", "    }\n\t    if (filesTooLongToBeChecked.length > 0) {\n\t      console.log(\n\t        `The changes for ${filesTooLongToBeChecked.join(\n\t          ', ',\n\t        )} is too long to be checked.`,\n\t      );\n\t    }\n\t    const listOfFilesByTokenRange = divideFilesByTokenRange(\n\t      MAX_TOKENS / 2,\n", "      patchesList,\n\t    );\n\t    await this.createReviewComments(listOfFilesByTokenRange[0]);\n\t    if (listOfFilesByTokenRange.length > 1) {\n\t      let requestCount = 1;\n\t      const intervalId = setInterval(async () => {\n\t        if (requestCount >= listOfFilesByTokenRange.length) {\n\t          clearInterval(intervalId);\n\t          return;\n\t        }\n", "        await this.createReviewComments(listOfFilesByTokenRange[requestCount]);\n\t        requestCount += 1;\n\t      }, OPENAI_TIMEOUT);\n\t    }\n\t  }\n\t}\n\texport default CommentOnPullRequestService;\n"]}
{"filename": "src/services/utils/getOpenAiSuggestions.ts", "chunked_list": ["import { getInput } from '@actions/core';\n\timport fetch from 'node-fetch';\n\timport errorsConfig, { ErrorMessage } from '../../config/errorsConfig';\n\timport promptsConfig, { Prompt } from '../../config/promptsConfig';\n\tconst OPENAI_MODEL = getInput('model') || 'gpt-3.5-turbo';\n\tconst getOpenAiSuggestions = async (patch: string): Promise<any> => {\n\t  if (!patch) {\n\t    throw new Error(\n\t      errorsConfig[ErrorMessage.MISSING_PATCH_FOR_OPENAI_SUGGESTION],\n\t    );\n", "  }\n\t  try {\n\t    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n\t      method: 'POST',\n\t      headers: {\n\t        'Content-Type': 'application/json',\n\t        Authorization: `Bearer  ${process.env.OPENAI_API_KEY}`,\n\t      },\n\t      body: JSON.stringify({\n\t        model: OPENAI_MODEL,\n", "        messages: [\n\t          { role: 'system', content: promptsConfig[Prompt.SYSTEM_PROMPT] },\n\t          { role: 'user', content: patch },\n\t        ],\n\t      }),\n\t    });\n\t    if (!response.ok) throw new Error('Failed to post data.');\n\t    const responseJson = (await response.json()) as any;\n\t    const openAiSuggestion =\n\t      responseJson.choices.shift()?.message?.content || '';\n", "    return openAiSuggestion;\n\t  } catch (error) {\n\t    console.error('Error posting data:', error);\n\t    throw error;\n\t  }\n\t};\n\texport default getOpenAiSuggestions;\n"]}
{"filename": "src/services/utils/parseOpenAISuggestions.ts", "chunked_list": ["const parseOpenAISuggestions = (suggestionsText: string) => {\n\t  const regex = /@@(.+?)@@\\n([\\s\\S]*?)(?=\\n@@|$)/g;\n\t  const suggestionMatches = suggestionsText.matchAll(regex);\n\t  const suggestions = [];\n\t  for (const match of suggestionMatches) {\n\t    const filename = match[1].trim();\n\t    const suggestionText = match[2].trim();\n\t    suggestions.push({ filename, suggestionText });\n\t  }\n\t  return suggestions;\n", "};\n\texport default parseOpenAISuggestions;\n"]}
{"filename": "src/services/utils/divideFilesByTokenRange.ts", "chunked_list": ["import { FilenameWithPatch } from '../types';\n\tconst divideFilesByTokenRange = (\n\t  tokensRange: number,\n\t  files: FilenameWithPatch[],\n\t) => {\n\t  const result: FilenameWithPatch[][] = [];\n\t  let currentArray: FilenameWithPatch[] = [];\n\t  let currentTokensUsed = 0;\n\t  for (const file of files) {\n\t    if (currentTokensUsed + file.tokensUsed <= tokensRange) {\n", "      currentArray.push(file);\n\t      currentTokensUsed += file.tokensUsed;\n\t    } else {\n\t      result.push(currentArray);\n\t      currentArray = [file];\n\t      currentTokensUsed = file.tokensUsed;\n\t    }\n\t  }\n\t  if (currentArray.length > 0) {\n\t    result.push(currentArray);\n", "  }\n\t  return result;\n\t};\n\texport default divideFilesByTokenRange;\n"]}
{"filename": "src/services/utils/extractFirstChangedLineFromPatch.ts", "chunked_list": ["const extractFirstChangedLineFromPatch = (patch: string) => {\n\t  const lineHeaderRegExp = /^@@ -\\d+,\\d+ \\+(\\d+),(\\d+) @@/;\n\t  const lines = patch.split('\\n');\n\t  const lineHeaderMatch = lines[0].match(lineHeaderRegExp);\n\t  let firstChangedLine = 1;\n\t  if (lineHeaderMatch) {\n\t    firstChangedLine = parseInt(lineHeaderMatch[1], 10);\n\t  }\n\t  return firstChangedLine;\n\t};\n", "export default extractFirstChangedLineFromPatch;\n"]}
{"filename": "src/services/utils/concatenatePatchesToString.ts", "chunked_list": ["import { FilenameWithPatch } from '../types';\n\tconst concatenatePatchesToString = (files: FilenameWithPatch[]) =>\n\t  files.map(({ filename, patch }) => `${filename}\\n${patch}\\n`).join('');\n\texport default concatenatePatchesToString;\n"]}
