{"filename": "src/json.d.ts", "chunked_list": ["declare module \"*.json\" {\n\t  const value: any\n\t  export default value\n\t}\n\tdeclare module \"*.yml\" {\n\t  const value: any\n\t  export default value\n\t}"]}
{"filename": "src/main.ts", "chunked_list": ["export * from './services'\n\texport * from './types'"]}
{"filename": "src/index.ts", "chunked_list": ["// Dependencies\n\timport express, { Response } from 'express'\n\timport cors from 'cors'\n\timport morgan from 'morgan'\n\timport routes from './routes'\n\timport swaggerDocs from './services/swagger'\n\timport swaggerUI from 'swagger-ui-express'\n\t// Dotenv\n\trequire('dotenv').config()\n\t// Settings\n", "const port = process.env.PORT ?? 3030\n\tconst app = express()\n\t// Middlewares\n\tapp.use(express.json())\n\tapp.use(morgan('tiny'))\n\tapp.use(express.urlencoded({ extended: false }))\n\tapp.use(cors())\n\t// Routes\n\tconst URL = `${process.env.API_VER_URL}`\n\tconst OLD = `${process.env.API_OLD}`\n", "const DOC_URL = `${process.env.API_DOC}`\n\tapp.use(URL, routes)\n\tapp.use(OLD, routes)\n\tapp.use(DOC_URL, swaggerUI.serve, swaggerUI.setup(swaggerDocs))\n\t// Start server\n\tapp.get(URL, (_, res: Response) => res.send(`Connected!`))\n\tapp.listen(port, () => {\n\t  console.log(`Server is running on ${URL}`)\n\t})\n\t/**\n", " * This module is responsible for setting up an Express server that listens for incoming requests.\n\t * It uses Express, cors, and morgan as middleware for handling requests and responses.\n\t * The routes module is imported and used for routing incoming requests.\n\t * The getDollarPrices and getDollarPricesWithAverage functions are exported from the './controllers/CDollar' module.\n\t * The dotenv module is used for environment variable configuration.\n\t * The server listens on the specified port (either from environment variable or default 3030).\n\t * The base URL for the API is configured using environment variables and used for routing.\n\t * The server sends a 'Connected!' response for the base URL to indicate successful connection.\n\t */"]}
{"filename": "src/utils/responses.ts", "chunked_list": ["import { Response } from 'express'\n\tconst message = require('./messages')\n\t/**\n\t * Function that generates a JSON response with an error message for HTTP 404 status code.\n\t * @param res Response object from Express.\n\t * @param err Error object to be included in the response.\n\t * @param code Optional code parameter to specify the error message. Defaults to 'UnexpectedError'.\n\t */\n\tfunction makeResponsesError(res: Response, err: Error, code?: string) {\n\t  const msg = {\n", "    OK: 0,\n\t    Error: err,\n\t    Message: message[code || 'UnexpectedError']\n\t  }\n\t  res.status(404).json(msg)\n\t}\n\t/**\n\t * Function that generates a JSON response with an exception message for HTTP 404 status code.\n\t * @param res Response object from Express.\n\t * @param err Error object to be included in the response.\n", " */\n\tfunction makeResponsesException(res: Response, err: Error) {\n\t  const msg = {\n\t    OK: 0,\n\t    Message: err\n\t  }\n\t  res.status(404).json(msg)\n\t}\n\t/**\n\t * Function that generates a JSON response with a success message for HTTP 200 status code.\n", " * @param res Response object from Express.\n\t * @param code Optional code parameter to specify the success message. Defaults to 'Success'.\n\t */\n\tfunction makeResponsesOk(res: Response, code?: string) {\n\t  const msg = {\n\t    OK: 1,\n\t    Message: message[code || 'Success']\n\t  }\n\t  res.status(200).json(msg)\n\t}\n", "/**\n\t * Function that generates a JSON response with data, success message, and HTTP 200 status code.\n\t * @param res Response object from Express.\n\t * @param data Any object to be included in the response.\n\t * @param code Optional code parameter to specify the success message. Defaults to 'Success'.\n\t */\n\tfunction makeResponsesOkData(res: Response, data: any, code?: string) {\n\t  const msg = {\n\t    OK: 1,\n\t    Data: data,\n", "    Message: message[code || 'Success']\n\t  }\n\t  res.status(200).json(msg)\n\t}\n\tmodule.exports = {\n\t  makeResponsesException,\n\t  makeResponsesOkData,\n\t  makeResponsesError,\n\t  makeResponsesOk\n\t}\n"]}
{"filename": "src/utils/messages.ts", "chunked_list": ["const messages = {\n\t  \"Success\": \"Success\",\n\t  \"Error\": \"Error\",\n\t  \"UnexpectedError\": \"Unexpected error\"\n\t}\n\texport default messages"]}
{"filename": "src/utils/formatDate.ts", "chunked_list": ["import TimeUnits from \"../time/units\";\n\t/**\n\t * The locale for date and time formatting.\n\t */\n\texport const locale = \"es-VE\"\n\t/**\n\t * The time zone for date and time calculations.\n\t */\n\texport const timeZone = \"America/Caracas\"\n\t/**\n", " * The options for date and time formatting.\n\t */\n\tconst options = { timeZone }\n\t/**\n\t * Method to get the hour from a date string or Date object.\n\t * @param {string | Date | null} date - The date to extract the hour from.\n\t * @returns {string} The formatted hour in HH:mm AM/PM format.\n\t * @throws {Error} If the date value is missing or in an invalid format.\n\t */\n\texport const getHour = (date: string | Date | null): string => {\n", "  try {\n\t    if (!date) {\n\t      throw Error(\"The date value must exist in date or string format.\")\n\t    }\n\t    let localDate: Date\n\t    if (typeof date === \"string\") {\n\t      localDate = new Date(date)\n\t    } else {\n\t      localDate = date\n\t    }\n", "    return localDate\n\t      .toLocaleTimeString(locale, options)\n\t      .toUpperCase()\n\t  } catch (error) {\n\t    throw Error(`Error trying to get the hour: ${error}`)\n\t  }\n\t}\n\t/**\n\t * Method to get the formatted date information from a Date object.\n\t * @param {Date} date - The date to extract the information from (default: current date).\n", " * @returns {Object | null} An object containing the day of the week, day of the month, month, and year.\n\t * @throws {Error} If there is an error while retrieving the date information.\n\t */\n\texport const getDate = (date: Date = new Date()): { dayWeek: string, day: number, month: string, year: number } | null => {\n\t  try {\n\t    const months = [\n\t      \"Enero\", \"Febrero\", \"Marzo\",\n\t      \"Abril\", \"Mayo\", \"Junio\",\n\t      \"Julio\", \"Agosto\", \"Septiembre\",\n\t      \"Octubre\", \"Noviembre\", \"Diciembre\"\n", "    ]\n\t    const days = [\n\t      \"Domingo\", \"Lunes\", \"Martes\", \"Miércoles\", \"Jueves\",\n\t      \"Viernes\", \"Sábado\"\n\t    ]\n\t    const d = new Date(date)\n\t    return {\n\t      dayWeek: days[d.getDay()],\n\t      day: d.getDate(),\n\t      month: months[d.getMonth()].toLowerCase(),\n", "      year: d.getFullYear()\n\t    }\n\t  } catch (error) {\n\t    console.error(`Error trying to get the date: ${error}`)\n\t    return null\n\t  }\n\t}\n\t/**\n\t * Method for reformatting the supplied date into \"dd/MM/yyyy\" format.\n\t * @param {string | Date | null} date - The date to be formatted.\n", " * @returns {string} The formatted date.\n\t * @throws {Error} If the date value is missing or in an invalid format.\n\t */\n\texport const formatDate = (date: string | Date | null): string => {\n\t  try {\n\t    if (!date) {\n\t      throw Error(\"The date value must exist in date or string format.\")\n\t    }\n\t    if (typeof date === \"string\") {\n\t      let newDate = date.split(\"T\")[0].split(\"-\")\n", "      let [year, month, day] = newDate\n\t      day = Number(day) < 10 ? day[1] : day\n\t      month = Number(month) < 10 ? month[1] : month\n\t      return `${day}/${month}/${year}`\n\t    } else {\n\t      return date.toLocaleDateString(locale, options)\n\t    }\n\t  } catch (error) {\n\t    throw Error(`Error trying to format the date: ${error}`)\n\t  }\n", "}\n\texport const convertDate = (text: string) => {\n\t  const [_, period] = text.split(\"Actualizó hace\");\n\t  let [unit, time] = period.split(\" \")\n\t    .slice(-2);\n\t  let unitNumber = unit === \"un\" || unit === \"una\" ? 1 : Number(unit);\n\t  time = time.toLowerCase();\n\t  if (time.endsWith(\"s\")) {\n\t    if (time !== \"mes\") {\n\t      time = time.substring(0, time.length - 1);\n", "    }\n\t  }\n\t  const seconds = TimeUnits.find(unit => unit.text.toLowerCase() === time)?.value ?? 0\n\t  const now = new Date();\n\t  const date = new Date(now.getTime() - unitNumber * seconds * 1000);\n\t  return date;\n\t};"]}
{"filename": "src/time/units.ts", "chunked_list": ["import { TTimeUnit } from \"../types\"\n\t/**\n\t * Array of time units with their respective values in seconds.\n\t * \n\t * @remarks\n\t * This array provides a set of predefined time units along with their corresponding values in seconds.\n\t * Each time unit object in the array contains an `id`, `text`, and `value` property representing the unique identifier, name, and value in seconds, respectively.\n\t * The time units are ordered from smallest to largest.\n\t * \n\t * The array contains a total of 16 time units, starting from id 1 for \"Nanosecond\" and ending with id 16 for \"Millennium\".\n", " * \n\t * @example\n\t * ```typescript\n\t * // Access the value of \"Minute\"\n\t * const minute = time[6].value; // 60 seconds\n\t * \n\t * // Iterate over all time units\n\t * time.forEach((unit) => {\n\t *   console.log(unit.text, unit.value);\n\t * });\n", " * ```\n\t */\n\tconst time: TTimeUnit[] = [\n\t  { id: 1, text: 'Nanosegundo', value: 0.000000001 },\n\t  { id: 2, text: 'Microsegundo', value: 0.000001 },\n\t  { id: 3, text: 'Milisegundo', value: 0.001 },\n\t  { id: 4, text: 'Centisegundo', value: 0.01 },\n\t  { id: 5, text: 'Decitosegundo', value: 0.1 },\n\t  { id: 6, text: 'Segundo', value: 1 },\n\t  { id: 7, text: 'Minuto', value: 60 },\n", "  { id: 8, text: 'Hora', value: 3600 },\n\t  { id: 9, text: 'Día', value: 86400 },\n\t  { id: 10, text: 'Semana', value: 604800 },\n\t  { id: 11, text: 'Mes', value: 2419200 },\n\t  { id: 12, text: 'Año', value: 29030400 },\n\t  { id: 13, text: 'Lustro', value: 145152000 },\n\t  { id: 14, text: 'Década', value: 725760000 },\n\t  { id: 15, text: 'Siglo', value: 7257600000 },\n\t  { id: 16, text: 'Milenio', value: 72576000000 }\n\t]\n", "export default time"]}
{"filename": "src/types/TTimeUnit.ts", "chunked_list": ["export type TTimeUnit = {\n\t  id: number;\n\t  text: string;\n\t  value: number;\n\t};"]}
{"filename": "src/types/TEuro.ts", "chunked_list": ["/**\n\t * Represents a type for individual euro values in bolivars.\n\t *\n\t * @property {string} title - The title or name of the entity that monitors the euro value.\n\t * @property {number} euro - The value of the euro in bolivars.\n\t * @property {string} updatedDate - The date when the euro value was last updated.\n\t * @property {string} image - The image of the entity.\n\t */\n\texport type TEuro = {\n\t  title: string;\n", "  euro: number;\n\t  updatedDate: string;\n\t  image?: string;\n\t};\n\t/**\n\t * Represents a type for an array of euro values in bolivars.\n\t *\n\t * @property {string} title - The title or name of the entity that monitors the euro value.\n\t * @property {number} euro - The value of the euro in bolivars.\n\t * @property {string} updatedDate - The date when the euro value was last updated.\n", " * @property {string} image - The image of the entity.\n\t */\n\texport type TEuroArray = {\n\t  title: string;\n\t  euro: number;\n\t  updatedDate: string;\n\t  image?: string;\n\t}[];\n\t/**\n\t * Represents a type for entities that monitor the euro value and their corresponding information.\n", " *\n\t * @property {string} entity - The name of the entity that monitors the euro value.\n\t * @property {TEuro} info - The information about the euro value for the entity.\n\t */\n\texport type TEuroEntity = {\n\t  entity: string;\n\t  info: TEuro;\n\t};\n\t/**\n\t * Represents a type for entities that control the value of the euro, its corresponding information and the respective calculation.\n", " *\n\t * @property {string} entity - The name of the entity that monitors the euro value.\n\t * @property {TEuro} info - The information about the euro value for the entity.\n\t * @property {number} euroCalculated - The value calculated in euro terms.\n\t */\n\texport type TEuroCalculated = {\n\t  entity: string;\n\t  info: TEuro;\n\t  euroCalculated: number;\n\t};\n", "/**\n\t * Represents a type for entities that control the value of the euro, its corresponding information and the respective calculation.\n\t *\n\t * @property {string} entity - The name of the entity that monitors the euro value.\n\t * @property {TEuro} info - The information about the euro value for the entity.\n\t * @property {number} bolivarCalculated - The value calculated in bolivar terms.\n\t */\n\texport type TBsEuroCalculated = {\n\t  entity: string;\n\t  info: TEuro;\n", "  bolivarCalculated: number;\n\t};\n\t/**\n\t * Represents a type for average euro values in bolivars for a specific date.\n\t *\n\t * @property {Date} date - The date for which the average euro value is calculated.\n\t * @property {number} average - The average value of the euro in bolivars for the given date.\n\t * @property {TEntity[]} entities - The array of entities and their corresponding information for the given date.\n\t */\n\texport type TEuroAverage = {\n", "  date: Date;\n\t  average: number;\n\t  entities: TEuroEntity[];\n\t};\n\t/**\n\t * Represents a type for average euro values in bolivars for a specific date.\n\t *\n\t * @property {Date} date - The date for which the average euro value is calculated.\n\t * @property {number} average - The average value of the euro in bolivars for the given date.\n\t * @property {TEuroCalculated[]} entities - The array of entities and their corresponding information for the given date.\n", " */\n\texport type TEuroCalculatedAverage = {\n\t  date: Date;\n\t  average: number;\n\t  entities: TEuroCalculated[];\n\t};\n\t/**\n\t * Represents a type for average euro values in bolivars for a specific date.\n\t *\n\t * @property {Date} date - The date for which the average euro value is calculated.\n", " * @property {number} average - The average value of the euro in bolivars for the given date.\n\t * @property {TBsCalculated[]} entities - The array of entities and their corresponding information for the given date.\n\t */\n\texport type TBsEuroCalculatedAverage = {\n\t  date: Date;\n\t  average: number;\n\t  entities: TBsEuroCalculated[];\n\t};"]}
{"filename": "src/types/index.ts", "chunked_list": ["export * from './TDollar'\n\texport * from './TEuro'\n\texport * from './TTimeUnit'"]}
{"filename": "src/types/TDollar.ts", "chunked_list": ["/**\n\t * Represents a type for individual dollar values in bolivars.\n\t *\n\t * @property {string} title - The title or name of the entity that monitors the dollar value.\n\t * @property {number} dollar - The value of the dollar in bolivars.\n\t * @property {string} updatedDate - The date when the dollar value was last updated.\n\t * @property {string} image - The image of the entity.\n\t */\n\texport type TDollar = {\n\t  title: string;\n", "  dollar: number;\n\t  updatedDate: string;\n\t  image?: string;\n\t};\n\t/**\n\t * Represents a type for an array of dollar values in bolivars.\n\t *\n\t * @property {string} title - The title or name of the entity that monitors the dollar value.\n\t * @property {number} dollar - The value of the dollar in bolivars.\n\t * @property {string} updatedDate - The date when the dollar value was last updated.\n", " * @property {string} image - The image of the entity.\n\t */\n\texport type TDollarArray = {\n\t  title: string;\n\t  dollar: number;\n\t  updatedDate: string;\n\t  image?: string;\n\t}[];\n\t/**\n\t * Represents a type for entities that monitor the dollar value and their corresponding information.\n", " *\n\t * @property {string} entity - The name of the entity that monitors the dollar value.\n\t * @property {TDollar} info - The information about the dollar value for the entity.\n\t */\n\texport type TDollarEntity = {\n\t  entity: string;\n\t  info: TDollar;\n\t};\n\t/**\n\t * Represents a type for entities that control the value of the dollar, its corresponding information and the respective calculation.\n", " *\n\t * @property {string} entity - The name of the entity that monitors the dollar value.\n\t * @property {TDollar} info - The information about the dollar value for the entity.\n\t * @property {number} dollarCalculated - The value calculated in dollar terms.\n\t */\n\texport type TDollarCalculated = {\n\t  entity: string;\n\t  info: TDollar;\n\t  dollarCalculated: number;\n\t};\n", "/**\n\t * Represents a type for entities that control the value of the dollar, its corresponding information and the respective calculation.\n\t *\n\t * @property {string} entity - The name of the entity that monitors the dollar value.\n\t * @property {TDollar} info - The information about the dollar value for the entity.\n\t * @property {number} bolivarCalculated - The value calculated in bolivar terms.\n\t */\n\texport type TBsDollarCalculated = {\n\t  entity: string;\n\t  info: TDollar;\n", "  bolivarCalculated: number;\n\t};\n\t/**\n\t * Represents a type for average dollar values in bolivars for a specific date.\n\t *\n\t * @property {Date} date - The date for which the average dollar value is calculated.\n\t * @property {number} average - The average value of the dollar in bolivars for the given date.\n\t * @property {TEntity[]} entities - The array of entities and their corresponding information for the given date.\n\t */\n\texport type TDollarAverage = {\n", "  date: Date;\n\t  average: number;\n\t  entities: TDollarEntity[];\n\t};\n\t/**\n\t * Represents a type for average dollar values in bolivars for a specific date.\n\t *\n\t * @property {Date} date - The date for which the average dollar value is calculated.\n\t * @property {number} average - The average value of the dollar in bolivars for the given date.\n\t * @property {TDollarCalculated[]} entities - The array of entities and their corresponding information for the given date.\n", " */\n\texport type TDollarCalculatedAverage = {\n\t  date: Date;\n\t  average: number;\n\t  entities: TDollarCalculated[];\n\t};\n\t/**\n\t * Represents a type for average dollar values in bolivars for a specific date.\n\t *\n\t * @property {Date} date - The date for which the average dollar value is calculated.\n", " * @property {number} average - The average value of the dollar in bolivars for the given date.\n\t * @property {TBsCalculated[]} entities - The array of entities and their corresponding information for the given date.\n\t */\n\texport type TBsDollarCalculatedAverage = {\n\t  date: Date;\n\t  average: number;\n\t  entities: TBsDollarCalculated[];\n\t};"]}
{"filename": "src/services/dollar.ts", "chunked_list": ["import * as cheerio from 'cheerio'\n\timport { TBsDollarCalculated, TDollar, TDollarArray, TDollarAverage, TDollarCalculated, TDollarEntity } from '../types/TDollar'\n\timport { convertDate, getDate, getHour } from '../utils/formatDate'\n\timport { BASE_URL } from '.'\n\t/**\n\t * Fetches an array with different values of the dollar in bolivars managed by entities that monitor this value.\n\t *\n\t * @returns {Promise<TDollarArray | null>} - A promise that resolves to an array with different dollar values\n\t * in bolivars given by the entities that monitor this value. Returns null if an error occurs.\n\t * @throws {Error} - If there is an error obtaining dollar values.\n", " */\n\texport const getDollarPrices = async (): Promise<TDollarArray | null> => {\n\t  try {\n\t    // Fetch data from the specified URL\n\t    const response = await fetch(`${BASE_URL}/dolar-venezuela`, {\n\t      mode: 'cors',\n\t      headers: {\n\t        'Access-Control-Allow-Origin': '*'\n\t      }\n\t    })\n", "    if (!response.ok) {\n\t      throw new Error('Request failed')\n\t    }\n\t    // Parse text response from fetch function.\n\t    const data = await response.text()\n\t    // Parse HTML data using Cheerio\n\t    const cheerioData = cheerio.load(data)\n\t    // Extract relevant information from the parsed HTML\n\t    const formatHTML = cheerioData('div.row')\n\t      .find('div.col-xs-12.col-sm-6.col-md-4.col-tabla')\n", "    const priceResult: TDollarArray = []\n\t    formatHTML.each((_: number, div: any) => {\n\t      const title = cheerioData(div)\n\t        .find('h6.nombre')\n\t        .text()\n\t      const cheerioDate = cheerioData(div)\n\t        .find('p.fecha')\n\t        .text()\n\t      let dateFormat = convertDate(cheerioDate)\n\t      const hour = getHour(dateFormat);\n", "      const date = getDate(dateFormat);\n\t      const text = cheerioData(div)\n\t        .find('p.precio')\n\t        .text()\n\t        .replace('.', '')\n\t        .replace(',', '.')\n\t      const dollar = Number(text ?? 0)\n\t      const image = cheerioData(div)\n\t        .find('img')\n\t        .attr('src')\n", "      const dollarData = {\n\t        title,\n\t        dollar,\n\t        updatedDate: `${hour} del ${date?.dayWeek.toLowerCase()} ${date?.day} de ${date?.month}, ${date?.year}`,\n\t        image: BASE_URL + image\n\t      }\n\t      priceResult.push(dollarData)\n\t    })\n\t    // Return the array of dollar values\n\t    return priceResult\n", "  } catch (error) {\n\t    // Handle error obtaining dollar values\n\t    console.error(`Error obtaining dollar values.`, error)\n\t    // Return null if an error occurs\n\t    return null\n\t  }\n\t}\n\t/**\n\t * Fetches an array with different values of the dollar in bolivars managed by entities that monitor this value. \n\t * It also calculates the average of all entities with values greater than zero.\n", " *\n\t * @returns {Promise<TAverage | null>} - A promise that resolves to an array with different dollar values\n\t * in bolivars managed by entities that monitor this value, including an average of all these entities. Returns null if an error occurs.\n\t * @throws {Error} - If there is an error calculating data.\n\t */\n\texport const getDollarPricesWithAverage = async (): Promise<TDollarAverage | null> => {\n\t  try {\n\t    // Fetch dollar prices from a remote source\n\t    const priceResult: TDollarArray | null = await getDollarPrices()\n\t    if (priceResult) {\n", "      let average = 0\n\t      let length = 0\n\t      // Calculate average and create entities array\n\t      const prices = priceResult.map((price: TDollar) => {\n\t        average = price.title !== \"Petro\" ? Number(average) + Number(price.dollar) : Number(average)\n\t        length = Number(price.dollar) > 0 && price.title !== \"Petro\" ? length + 1 : length\n\t        let entity: TDollarEntity = {\n\t          entity: price.title,\n\t          info: price\n\t        }\n", "        return entity\n\t      })\n\t      // Create response object with average and entities array\n\t      const response: TDollarAverage = {\n\t        date: new Date(),\n\t        average: Number((average / length).toFixed(2)),\n\t        entities: prices\n\t      }\n\t      // Return the response object\n\t      return response\n", "    }\n\t    // Return null if priceResult is null\n\t    return null\n\t  } catch (error) {\n\t    // Handle error calculating data\n\t    console.error(`Error calculating data.`, error)\n\t    // Return null if an error occurs\n\t    return null\n\t  }\n\t}\n", "/**\n\t* Fetches an array with the different values of the dollar in bolivars handled by the entities that control this value and calculates the value of the amount of dollars supplied in bolivars. \n\t * @param dollar {number} - Amount in dollars to be calculated in bolivars.\n\t * @returns {Promise<TBsCalculated[] | null>} - A promise that resolves to an array with different dollar values.\n\t * in bolivars handled by entities that control this value, along with the calculation in bolivars of the amount supplied in dollars as a parameter. Returns null if an error occurs.\n\t * @throws {Error} - If there is an error calculating the data.\n\t */\n\texport const calculateDollarToBs = async (dollar: number): Promise<TBsDollarCalculated[] | null> => {\n\t  try {\n\t    if (!dollar || dollar <= 0) {\n", "      return null\n\t    }\n\t    const entities = await getDollarPricesWithAverage()\n\t    let calculatedEntities: TBsDollarCalculated [] = []\n\t    if (entities?.entities && entities?.entities.length > 0) {\n\t      entities.entities.forEach((item) => {\n\t        calculatedEntities.push({\n\t          ...item,\n\t          bolivarCalculated: Number(item.info.dollar) > 0 && item.info.title !== \"Petro\" ? Number(Number(Number(item.info.dollar) * dollar).toFixed(2)) : 0\n\t        })\n", "      })\n\t    }\n\t    return calculatedEntities\n\t  } catch (error) {\n\t    // Handle error calculating data\n\t    console.error(`Error calculating data.`, error)\n\t    // Return null if an error occurs\n\t    return null\n\t  }\n\t}\n", "/**\n\t* Fetches an array with the different values of the bolivars in dollars handled by the entities that control this value and calculates the value of the amount of bolivars supplied in dollars. \n\t * @param bs {number} - Amount in bolivars to be calculated in dollars.\n\t * @returns {Promise<TDollarCalculated[] | null>} - A promise that resolves to an array with different dollar values.\n\t * in bolivars handled by entities that control this value, along with the calculation in bolivars of the amount supplied in dollars as a parameter. Returns null if an error occurs.\n\t * @throws {Error} - If there is an error calculating the data.\n\t */\n\texport const calculateBsToDollar = async (bs: number): Promise<TDollarCalculated[] | null> => {\n\t  try {\n\t    if (!bs || bs <= 0) {\n", "      return null\n\t    }\n\t    const entities = await getDollarPricesWithAverage()\n\t    let calculatedEntities: TDollarCalculated[] = []\n\t    if (entities?.entities && entities?.entities.length > 0) {\n\t      entities.entities.forEach(item => {\n\t        calculatedEntities.push({\n\t          ...item,\n\t          dollarCalculated: Number(item.info.dollar) > 0 && item.info.title !== \"Petro\" ? Number(Number(bs / Number(item.info.dollar)).toFixed(2)) : 0\n\t        })\n", "      })\n\t    }\n\t    return calculatedEntities\n\t  } catch (error) {\n\t    // Handle error calculating data\n\t    console.error(`Error calculating data.`, error)\n\t    // Return null if an error occurs\n\t    return null\n\t  }\n\t}"]}
{"filename": "src/services/swagger.ts", "chunked_list": ["import swaggerJsonDoc from 'swagger-jsdoc'\n\tconst swaggerOptions = {\n\t  openapi: '3.0.0',\n\t  definition: {\n\t    info: {\n\t      title: `Venecodollar API Documentation`,\n\t      version: '2.1.0',\n\t      description: `This section represents the Swagger documentation of the API designed with Venecodollar's NPM package. Here it is possible to test the endpoints provided by this API.\\n\\nIf you wish to make use of the NPM package in your javascript or typescript project, please [click here](https://www.npmjs.com/package/venecodollar), where you will be redirected to the official Venecodollar NPM package page.`,\n\t      contact: {\n\t        name: 'the developer',\n", "        email: process.env.EMAIL ?? '',\n\t      },\n\t      license: {\n\t        name: 'MIT',\n\t        url: `https://github.com/gustavoerivero/venecodollar/blob/main/LICENSE`\n\t      },\n\t      schemes: ['http', 'https'],\n\t    servers: [{ url: 'https://venecodollar.vercel.app/api/v1' }],\n\t    }\n\t  },\n", "  apis: [`${__dirname}/routes/*.ts`, './build/routes/*.js']\n\t}\n\texport default swaggerJsonDoc(swaggerOptions)\n"]}
{"filename": "src/services/euro.ts", "chunked_list": ["import * as cheerio from 'cheerio'\n\timport { convertDate, getDate, getHour } from '../utils/formatDate'\n\timport { BASE_URL } from '.'\n\timport { TBsEuroCalculated, TEuro, TEuroArray, TEuroAverage, TEuroCalculated, TEuroEntity } from '../types'\n\t/**\n\t * Fetches an array with different values of the dollar in bolivars managed by entities that monitor this value.\n\t *\n\t * @returns {Promise<TEuroArray | null>} - A promise that resolves to an array with different dollar values\n\t * in bolivars given by the entities that monitor this value. Returns null if an error occurs.\n\t * @throws {Error} - If there is an error obtaining dollar values.\n", " */\n\texport const getEuroPrices = async (): Promise<TEuroArray | null> => {\n\t  try {\n\t    // Fetch data from the specified URL\n\t    const response = await fetch(`${BASE_URL}/dolar-venezuela/EUR`, {\n\t      mode: 'cors',\n\t      headers: {\n\t        'Access-Control-Allow-Origin': '*'\n\t      }\n\t    })\n", "    if (!response.ok) {\n\t      throw new Error('Request failed')\n\t    }\n\t    // Parse text response from fetch function.\n\t    const data = await response.text()\n\t    // Parse HTML data using Cheerio\n\t    const cheerioData = cheerio.load(data)\n\t    // Extract relevant information from the parsed HTML\n\t    const formatHTML = cheerioData('div.row')\n\t      .find('div.col-xs-12.col-sm-6.col-md-4.col-tabla')\n", "    const priceResult: TEuroArray = []\n\t    formatHTML.each((_: number, div: any) => {\n\t      const title = cheerioData(div)\n\t        .find('h6.nombre')\n\t        .text()\n\t      const cheerioDate = cheerioData(div)\n\t        .find('p.fecha')\n\t        .text()\n\t      let dateFormat = convertDate(cheerioDate)\n\t      const hour = getHour(dateFormat);\n", "      const date = getDate(dateFormat);\n\t      const text = cheerioData(div)\n\t        .find('p.precio')\n\t        .text()\n\t        .replace('.', '')\n\t        .replace(',', '.')\n\t      const euro = Number(text ?? 0)\n\t      const image = cheerioData(div)\n\t        .find('img')\n\t        .attr('src')\n", "      const euroData = {\n\t        title: title,\n\t        euro: euro,\n\t        updatedDate: `${hour} del ${date?.dayWeek.toLowerCase()} ${date?.day} de ${date?.month}, ${date?.year}`,\n\t        image: BASE_URL + image\n\t      }\n\t      priceResult.push(euroData)\n\t    })\n\t    // Return the array of dollar values\n\t    return priceResult\n", "  } catch (error) {\n\t    // Handle error obtaining dollar values\n\t    console.error(`Error obtaining dollar values.`, error)\n\t    // Return null if an error occurs\n\t    return null\n\t  }\n\t}\n\t/**\n\t * Fetches an array with different values of the dollar in bolivars managed by entities that monitor this value. \n\t * It also calculates the average of all entities with values greater than zero.\n", " *\n\t * @returns {Promise<TEuroAverage | null>} - A promise that resolves to an array with different dollar values\n\t * in bolivars managed by entities that monitor this value, including an average of all these entities. Returns null if an error occurs.\n\t * @throws {Error} - If there is an error calculating data.\n\t */\n\texport const getEuroPricesWithAverage = async (): Promise<TEuroAverage | null> => {\n\t  try {\n\t    // Fetch dollar prices from a remote source\n\t    const priceResult: TEuroArray | null = await getEuroPrices()\n\t    if (priceResult) {\n", "      let average = 0\n\t      let length = 0\n\t      // Calculate average and create entities array\n\t      const prices = priceResult.map((price: TEuro) => {\n\t        average = price.title !== \"Petro\" ? Number(average) + Number(price.euro) : Number(average)\n\t        length = Number(price.euro) > 0 && price.title !== \"Petro\" ? length + 1 : length\n\t        let entity: TEuroEntity = {\n\t          entity: price.title,\n\t          info: price\n\t        }\n", "        return entity\n\t      })\n\t      // Create response object with average and entities array\n\t      const response: TEuroAverage = {\n\t        date: new Date(),\n\t        average: Number((average / length).toFixed(2)),\n\t        entities: prices\n\t      }\n\t      // Return the response object\n\t      return response\n", "    }\n\t    // Return null if priceResult is null\n\t    return null\n\t  } catch (error) {\n\t    // Handle error calculating data\n\t    console.error(`Error calculating data.`, error)\n\t    // Return null if an error occurs\n\t    return null\n\t  }\n\t}\n", "/**\n\t* Fetches an array with the different values of the dollar in bolivars handled by the entities that control this value and calculates the value of the amount of euros supplied in bolivars. \n\t * @param euro {number} - Amount in euros to be calculated in bolivars.\n\t * @returns {Promise<TBsCalculated[] | null>} - A promise that resolves to an array with different dollar values.\n\t * in bolivars handled by entities that control this value, along with the calculation in bolivars of the amount supplied in euros as a parameter. Returns null if an error occurs.\n\t * @throws {Error} - If there is an error calculating the data.\n\t */\n\texport const calculateEuroToBs = async (euro: number): Promise<TBsEuroCalculated[] | null> => {\n\t  try {\n\t    if (!euro || euro <= 0) {\n", "      return null\n\t    }\n\t    const entities = await getEuroPricesWithAverage()\n\t    let calculatedEntities: TBsEuroCalculated[] = []\n\t    if (entities?.entities && entities?.entities.length > 0) {\n\t      entities.entities.forEach(item => {\n\t        calculatedEntities.push({\n\t          ...item,\n\t          bolivarCalculated: Number(item.info.euro) > 0 && item.info.title !== \"Petro\" ? Number(Number(Number(item.info.euro) * euro).toFixed(2)) : 0\n\t        })\n", "      })\n\t    }\n\t    return calculatedEntities\n\t  } catch (error) {\n\t    // Handle error calculating data\n\t    console.error(`Error calculating data.`, error)\n\t    // Return null if an error occurs\n\t    return null\n\t  }\n\t}\n", "/**\n\t* Fetches an array with the different values of the bolivars in euros handled by the entities that control this value and calculates the value of the amount of bolivars supplied in euros. \n\t * @param bs {number} - Amount in bolivars to be calculated in euros.\n\t * @returns {Promise<TEuroCalculated[] | null>} - A promise that resolves to an array with different dollar values.\n\t * in bolivars handled by entities that control this value, along with the calculation in bolivars of the amount supplied in euros as a parameter. Returns null if an error occurs.\n\t * @throws {Error} - If there is an error calculating the data.\n\t */\n\texport const calculateBsToEuro = async (bs: number): Promise<TEuroCalculated[] | null> => {\n\t  try {\n\t    if (!bs || bs <= 0) {\n", "      return null\n\t    }\n\t    const entities = await getEuroPricesWithAverage()\n\t    let calculatedEntities: TEuroCalculated[] = []\n\t    if (entities?.entities && entities?.entities.length > 0) {\n\t      entities.entities.forEach(item => {\n\t        calculatedEntities.push({\n\t          ...item,\n\t          euroCalculated: Number(item.info.euro) > 0 && item.info.title !== \"Petro\" ? Number(Number(bs / Number(item.info.euro)).toFixed(2)) : 0\n\t        })\n", "      })\n\t    }\n\t    return calculatedEntities\n\t  } catch (error) {\n\t    // Handle error calculating data\n\t    console.error(`Error calculating data.`, error)\n\t    // Return null if an error occurs\n\t    return null\n\t  }\n\t}"]}
{"filename": "src/services/index.ts", "chunked_list": ["/**\n\t * Base URL.\n\t */\n\texport const BASE_URL = \"https://exchangemonitor.net\";\n\texport {\n\t  getDollarPrices,\n\t  getDollarPricesWithAverage,\n\t  calculateBsToDollar,\n\t  calculateDollarToBs\n\t} from './dollar'\n", "export {\n\t  getEuroPrices,\n\t  getEuroPricesWithAverage,\n\t  calculateBsToEuro,\n\t  calculateEuroToBs\n\t} from './euro'"]}
{"filename": "src/controllers/CEuro.ts", "chunked_list": ["import { Request, Response } from 'express'\n\timport { TBsEuroCalculated, TEuroCalculated, TEuroEntity } from '../types'\n\timport { calculateBsToEuro, calculateEuroToBs, getEuroPricesWithAverage } from '../services'\n\trequire('dotenv').config()\n\tconst resp = require('../utils/responses')\n\t/**\n\t * Fetches euro prices with average from a remote source.\n\t *\n\t * @param {Request} _ - Express request object (not used).\n\t * @param {Response} res - Express response object to send the response.\n", " * @returns {Promise<void>} - A promise that resolves when the response is sent.\n\t * @throws {Error} - If there is an error obtaining euro values.\n\t */\n\texport const getEuro = async (_: Request, res: Response): Promise<void> => {\n\t  try {\n\t    // Fetch euro prices with average from a remote source\n\t    const response = await getEuroPricesWithAverage()\n\t    // Send successful response\n\t    return resp.makeResponsesOkData(res, response, 'Success')\n\t  } catch (error) {\n", "    // Handle error obtaining euro values\n\t    console.error(`Error obtaining euro values.`, error)\n\t    // Send error response\n\t    return resp.makeResponsesError(res, 'It has been impossible to connect to the server.')\n\t  }\n\t}\n\t/**\n\t * Fetches specific euro prices based on the entity name from a remote source.\n\t *\n\t * @param {Request} req - Express request object containing the query parameters.\n", " * @param {Response} res - Express response object to send the response.\n\t * @returns {Promise<void>} - A promise that resolves when the response is sent.\n\t * @throws {Error} - If there is an error obtaining euro values.\n\t */\n\texport const getSpecificEuro = async (req: Request, res: Response): Promise<void> => {\n\t  try {\n\t    // Fetch euro prices with average from a remote source\n\t    const prices = await getEuroPricesWithAverage()\n\t    const entity = req.query.name\n\t    let response: any\n", "    if (prices && typeof entity === 'string') {\n\t      // Filter entities based on the entity name\n\t      response = prices.entities.filter(item => item.entity.includes(entity))\n\t    } else {\n\t      response = prices?.entities\n\t    }\n\t    if (response.length > 1) {\n\t      let length = 0\n\t      let average = 0\n\t      response.forEach((item: TEuroEntity) => {\n", "        if (item.info.euro > 0) {\n\t          length = length + 1\n\t          average = item.info.euro + average\n\t        }\n\t      })\n\t      // Calculate average euro value and update response object\n\t      response = {\n\t        date: new Date(),\n\t        average: average !== 0 ? Number((average / length).toFixed(2)) : 0,\n\t        entities: response\n", "      }\n\t    } else {\n\t      // Update response object with single entity if only one entity is found\n\t      response = response.pop()\n\t    }\n\t    // Send successful response\n\t    return resp.makeResponsesOkData(res, response, 'Success')\n\t  } catch (error) {\n\t    // Handle error obtaining euro values\n\t    console.error(`Error obtaining euro values.`, error)\n", "    // Send error response\n\t    return resp.makeResponsesError(res, 'It has been impossible to connect to the server.')\n\t  }\n\t}\n\t/**\n\t * Fetches specific prices in euros based on the amount of bolivars from a remote source.\n\t *\n\t * @param {Request} req - Express request object containing the query parameters.\n\t * @param {Response} res - Express response object to send the response.\n\t * @returns {Promise<void>} - A promise that resolves when the response is sent.\n", " * @throws {Error} - If there is an error obtaining euro values.\n\t */\n\texport const calculatorBsToEuro = async (req: Request, res: Response): Promise<void> => {\n\t  try {\n\t    // Obtain the amount in bolivars to be calculated in terms of euros.\n\t    const bs = Number(req.query.bs ?? 0)\n\t    const entity = req.query.entity ?? null\n\t    if (!bs || bs <= 0) {\n\t      return resp.makeResponsesError(res, 'You must provide an amount to be calculated.')\n\t    }\n", "    let response: any\n\t    let prices = await calculateBsToEuro(bs)\n\t    if (prices && entity && typeof entity === 'string') {\n\t      // Filter entities based on the entity name\n\t      response = prices.filter(item => item.entity.includes(entity))\n\t    } else {\n\t      response = prices\n\t    }\n\t    if (response && response.length > 1) {\n\t      let length = 0\n", "      let average = 0\n\t      response.forEach((item: TEuroCalculated) => {\n\t        if (item.euroCalculated > 0) {\n\t          length = length + 1\n\t          average = item.euroCalculated + average\n\t        }\n\t      })\n\t      // Calculate average euro value and update response object\n\t      response = {\n\t        date: new Date(),\n", "        average: average !== 0 ? Number((average / length).toFixed(2)) : 0,\n\t        entities: response\n\t      }\n\t    } else {\n\t      // Update response object with single entity if only one entity is found\n\t      response = response.pop()\n\t    }\n\t    // Send successful response\n\t    return resp.makeResponsesOkData(res, response, 'Success')\n\t  } catch (error) {\n", "    // Handle error obtaining euro values\n\t    console.error(`Error obtaining euro values.`, error)\n\t    // Send error response\n\t    return resp.makeResponsesError(res, 'It has been impossible to connect to the server.')\n\t  }\n\t}\n\t/**\n\t * Fetches specific prices in bolivars based on the amount of euros from a remote source.\n\t *\n\t * @param {Request} req - Express request object containing the query parameters.\n", " * @param {Response} res - Express response object to send the response.\n\t * @returns {Promise<void>} - A promise that resolves when the response is sent.\n\t * @throws {Error} - If there is an error obtaining euro values.\n\t */\n\texport const calculatorEuroToBs = async (req: Request, res: Response): Promise<void> => {\n\t  try {\n\t    // Obtain the amount in bolivars to be calculated in terms of euros.\n\t    const euro = Number(req.query.euro ?? 0)\n\t    const entity = req.query.entity ?? null\n\t    if (!euro || euro <= 0) {\n", "      return resp.makeResponsesError(res, 'You must provide an amount to be calculated.')\n\t    }\n\t    let response: any\n\t    let prices = await calculateEuroToBs(euro)\n\t    if (prices && entity && typeof entity === 'string') {\n\t      // Filter entities based on the entity name\n\t      response = prices.filter(item => item.entity.includes(entity))\n\t    } else {\n\t      response = prices\n\t    }\n", "    if (response && response.length > 1) {\n\t      let length = 0\n\t      let average = 0\n\t      response.forEach((item: TBsEuroCalculated) => {\n\t        if (item.bolivarCalculated > 0) {\n\t          length = length + 1\n\t          average = item.bolivarCalculated + average\n\t        }\n\t      })\n\t      // Calculate average euro value and update response object\n", "      response = {\n\t        date: new Date(),\n\t        average: average !== 0 ? Number((average / length).toFixed(2)) : 0,\n\t        entities: response\n\t      }\n\t    } else {\n\t      // Update response object with single entity if only one entity is found\n\t      response = response.pop()\n\t    }\n\t    // Send successful response\n", "    return resp.makeResponsesOkData(res, response, 'Success')\n\t  } catch (error) {\n\t    // Handle error obtaining euro values\n\t    console.error(`Error obtaining euro values.`, error)\n\t    // Send error response\n\t    return resp.makeResponsesError(res, 'It has been impossible to connect to the server.')\n\t  }\n\t}"]}
{"filename": "src/controllers/index.ts", "chunked_list": ["export * from './CDollar'\n\texport * from './CEuro'"]}
{"filename": "src/controllers/CDollar.ts", "chunked_list": ["import { Request, Response } from 'express'\n\timport { TBsDollarCalculated, TDollarCalculated, TDollarEntity } from '../types'\n\timport { calculateBsToDollar, calculateDollarToBs, getDollarPricesWithAverage } from '../services'\n\trequire('dotenv').config()\n\tconst resp = require('../utils/responses')\n\t/**\n\t * Fetches dollar prices with average from a remote source.\n\t *\n\t * @param {Request} _ - Express request object (not used).\n\t * @param {Response} res - Express response object to send the response.\n", " * @returns {Promise<void>} - A promise that resolves when the response is sent.\n\t * @throws {Error} - If there is an error obtaining dollar values.\n\t */\n\texport const getDollar = async (_: Request, res: Response): Promise<void> => {\n\t  try {\n\t    // Fetch dollar prices with average from a remote source\n\t    const response = await getDollarPricesWithAverage()\n\t    // Send successful response\n\t    return resp.makeResponsesOkData(res, response, 'Success')\n\t  } catch (error) {\n", "    // Handle error obtaining dollar values\n\t    console.error(`Error obtaining dollar values.`, error)\n\t    // Send error response\n\t    return resp.makeResponsesError(res, 'It has been impossible to connect to the server.')\n\t  }\n\t}\n\t/**\n\t * Fetches specific dollar prices based on the entity name from a remote source.\n\t *\n\t * @param {Request} req - Express request object containing the query parameters.\n", " * @param {Response} res - Express response object to send the response.\n\t * @returns {Promise<void>} - A promise that resolves when the response is sent.\n\t * @throws {Error} - If there is an error obtaining dollar values.\n\t */\n\texport const getSpecificDollar = async (req: Request, res: Response): Promise<void> => {\n\t  try {\n\t    // Fetch dollar prices with average from a remote source\n\t    const prices = await getDollarPricesWithAverage()\n\t    const entity = req.query.name\n\t    let response: any\n", "    if (prices && typeof entity === 'string') {\n\t      // Filter entities based on the entity name\n\t      response = prices.entities.filter(item => item.entity.includes(entity))\n\t    } else {\n\t      response = prices?.entities\n\t    }\n\t    if (response.length > 1) {\n\t      let length = 0\n\t      let average = 0\n\t      response.forEach((item: TDollarEntity) => {\n", "        if (item.info.dollar > 0) {\n\t          length = length + 1\n\t          average = item.info.dollar + average\n\t        }\n\t      })\n\t      // Calculate average dollar value and update response object\n\t      response = {\n\t        date: new Date(),\n\t        average: average !== 0 ? Number((average / length).toFixed(2)) : 0,\n\t        entities: response\n", "      }\n\t    } else {\n\t      // Update response object with single entity if only one entity is found\n\t      response = response.pop()\n\t    }\n\t    // Send successful response\n\t    return resp.makeResponsesOkData(res, response, 'Success')\n\t  } catch (error) {\n\t    // Handle error obtaining dollar values\n\t    console.error(`Error obtaining dollar values.`, error)\n", "    // Send error response\n\t    return resp.makeResponsesError(res, 'It has been impossible to connect to the server.')\n\t  }\n\t}\n\t/**\n\t * Fetches specific prices in dollars based on the amount of bolivars from a remote source.\n\t *\n\t * @param {Request} req - Express request object containing the query parameters.\n\t * @param {Response} res - Express response object to send the response.\n\t * @returns {Promise<void>} - A promise that resolves when the response is sent.\n", " * @throws {Error} - If there is an error obtaining dollar values.\n\t */\n\texport const calculatorBsToDollar = async (req: Request, res: Response): Promise<void> => {\n\t  try {\n\t    // Obtain the amount in bolivars to be calculated in terms of dollars.\n\t    const bs = Number(req.query.bs ?? 0)\n\t    const entity = req.query.entity ?? null\n\t    if (!bs || bs <= 0) {\n\t      return resp.makeResponsesError(res, 'You must provide an amount to be calculated.')\n\t    }\n", "    let response: any\n\t    let prices = await calculateBsToDollar(bs)\n\t    if (prices && entity && typeof entity === 'string') {\n\t      // Filter entities based on the entity name\n\t      response = prices.filter(item => item.entity.includes(entity))\n\t    } else {\n\t      response = prices\n\t    }\n\t    if (response && response.length > 1) {\n\t      let length = 0\n", "      let average = 0\n\t      response.forEach((item: TDollarCalculated) => {\n\t        if (item.dollarCalculated > 0) {\n\t          length = length + 1\n\t          average = item.dollarCalculated + average\n\t        }\n\t      })\n\t      // Calculate average dollar value and update response object\n\t      response = {\n\t        date: new Date(),\n", "        average: average !== 0 ? Number((average / length).toFixed(2)) : 0,\n\t        entities: response\n\t      }\n\t    } else {\n\t      // Update response object with single entity if only one entity is found\n\t      response = response.pop()\n\t    }\n\t    // Send successful response\n\t    return resp.makeResponsesOkData(res, response, 'Success')\n\t  } catch (error) {\n", "    // Handle error obtaining dollar values\n\t    console.error(`Error obtaining dollar values.`, error)\n\t    // Send error response\n\t    return resp.makeResponsesError(res, 'It has been impossible to connect to the server.')\n\t  }\n\t}\n\t/**\n\t * Fetches specific prices in bolivars based on the amount of dollars from a remote source.\n\t *\n\t * @param {Request} req - Express request object containing the query parameters.\n", " * @param {Response} res - Express response object to send the response.\n\t * @returns {Promise<void>} - A promise that resolves when the response is sent.\n\t * @throws {Error} - If there is an error obtaining dollar values.\n\t */\n\texport const calculatorDollarToBs = async (req: Request, res: Response): Promise<void> => {\n\t  try {\n\t    // Obtain the amount in bolivars to be calculated in terms of dollars.\n\t    const dollar = Number(req.query.dollar ?? 0)\n\t    const entity = req.query.entity ?? null\n\t    if (!dollar || dollar <= 0) {\n", "      return resp.makeResponsesError(res, 'You must provide an amount to be calculated.')\n\t    }\n\t    let response: any\n\t    let prices = await calculateDollarToBs(dollar)\n\t    if (prices && entity && typeof entity === 'string') {\n\t      // Filter entities based on the entity name\n\t      response = prices.filter(item => item.entity.includes(entity))\n\t    } else {\n\t      response = prices\n\t    }\n", "    if (response && response.length > 1) {\n\t      let length = 0\n\t      let average = 0\n\t      response.forEach((item: TBsDollarCalculated) => {\n\t        if (item.bolivarCalculated > 0) {\n\t          length = length + 1\n\t          average = item.bolivarCalculated + average\n\t        }\n\t      })\n\t      // Calculate average dollar value and update response object\n", "      response = {\n\t        date: new Date(),\n\t        average: average !== 0 ? Number((average / length).toFixed(2)) : 0,\n\t        entities: response\n\t      }\n\t    } else {\n\t      // Update response object with single entity if only one entity is found\n\t      response = response.pop()\n\t    }\n\t    // Send successful response\n", "    return resp.makeResponsesOkData(res, response, 'Success')\n\t  } catch (error) {\n\t    // Handle error obtaining dollar values\n\t    console.error(`Error obtaining dollar values.`, error)\n\t    // Send error response\n\t    return resp.makeResponsesError(res, 'It has been impossible to connect to the server.')\n\t  }\n\t}"]}
{"filename": "src/routes/RDollar.ts", "chunked_list": ["const router = require('express').Router()\n\timport { calculatorBsToDollar, calculatorDollarToBs, getDollar, getSpecificDollar } from '../controllers'\n\t/**\n\t * @swagger\n\t * /api/v1/dollar:\n\t *  get:\n\t *    summary: Get the dollar values in terms of bolivars (Bs.) given by the monitoring entities and an average of the same.\n\t *    tags:\n\t *      - dollar\n\t *    description: Get an object which contains the date on which the query was made, an average of all the dollar values given by the queried monitoring entities and an array with the monitored entities.\n", " *    responses:\n\t *      200:\n\t *        description: The API request has been successful.\n\t *      404:\n\t *        description: Not found.\n\t *      500:\n\t *        description: Internal server error.\n\t * \n\t * /api/v1/dollar/entity?name={name}:\n\t *  get:\n", " *    summary: Get the dollar values in terms of bolivars (Bs.) given by the control entities filtered by name and, in the event that the name coincides with more than one entity, an average of the same.\n\t *    tags:\n\t *      - dollar\n\t *    description: Gets an object containing the entities in charge of monitoring the dollar value filtered by name. In case the name matches more than one entity, the query date and an average of all displayed entities will be returned along with the data of those entities.\n\t *    parameters:\n\t *      - name: name\n\t *        in: path\n\t *        description: Name of entity to return\n\t *        required: true\n\t *        schema:\n", " *          type: string\n\t *          example: '@DolarToday'\n\t *    responses:\n\t *      200:\n\t *        description: The API request has been successful.\n\t *      404:\n\t *        description: Not found.\n\t *      500:\n\t *        description: Internal server error.\n\t * \n", " * /api/v1/dollar/toDollar?bs={amount}&entity={name}:\n\t *  get:\n\t *    summary: Obtain the dollar values of a bolivar amount provided by parameter.\n\t *    tags:\n\t *      - dollar\n\t *    description: Obtain the dollar values of a bolivar amount provided by parameter.\n\t *    parameters:\n\t *      - name: bs\n\t *        in: path\n\t *        description: Bolivar amount provided.\n", " *        required: true\n\t *        schema:\n\t *          type: number\n\t *          example: 1080\n\t *      - name: name\n\t *        in: path\n\t *        description: Name of entity to return\n\t *        required: true\n\t *        schema:\n\t *          type: string\n", " *          example: '@DolarToday'\n\t *    responses:\n\t *      200:\n\t *        description: The API request has been successful.\n\t *      404:\n\t *        description: Not found.\n\t *      500:\n\t *        description: Internal server error.\n\t * \n\t * /api/v1/dollar/toBs?dollar={amount}&entity={name}:\n", " *  get:\n\t *    summary: Obtain the bolivar values of a dollar amount provided by parameter.\n\t *    tags:\n\t *      - dollar\n\t *    description: Obtain the bolivar values of a dollar amount provided by parameter.\n\t *    parameters:\n\t *      - name: dollar\n\t *        in: path\n\t *        description: Dollar amount provided.\n\t *        required: true\n", " *        schema:\n\t *          type: number\n\t *          example: 1080\n\t *      - name: name\n\t *        in: path\n\t *        description: Name of entity to return\n\t *        required: true\n\t *        schema:\n\t *          type: string\n\t *          example: '@DolarToday'\n", " *    responses:\n\t *      200:\n\t *        description: The API request has been successful.\n\t *      404:\n\t *        description: Not found.\n\t *      500:\n\t *        description: Internal server error.\n\t */\n\trouter.get('/', getDollar)\n\trouter.get('/entity', getSpecificDollar)\n", "router.get('/toDollar', calculatorBsToDollar)\n\trouter.get('/toBs', calculatorDollarToBs)\n\tmodule.exports = router\n"]}
{"filename": "src/routes/REuro.ts", "chunked_list": ["const router = require('express').Router()\n\timport { calculatorBsToEuro, calculatorEuroToBs, getEuro, getSpecificEuro } from '../controllers'\n\t/**\n\t * @swagger\n\t * /api/v1/euro:\n\t *  get:\n\t *    summary: Get the euro values in terms of bolivars (Bs.) given by the monitoring entities and an average of the same.\n\t *    tags:\n\t *      - euro\n\t *    description: Get an object which contains the date on which the query was made, an average of all the euro values given by the queried monitoring entities and an array with the monitored entities.\n", " *    responses:\n\t *      200:\n\t *        description: The API request has been successful.\n\t *      404:\n\t *        description: Not found.\n\t *      500:\n\t *        description: Internal server error.\n\t * \n\t * /api/v1/euro/entity?name={name}:\n\t *  get:\n", " *    summary: Get the euro values in terms of bolivars (Bs.) given by the control entities filtered by name and, in the event that the name coincides with more than one entity, an average of the same.\n\t *    tags:\n\t *      - euro\n\t *    description: Gets an object containing the entities in charge of monitoring the euro value filtered by name. In case the name matches more than one entity, the query date and an average of all displayed entities will be returned along with the data of those entities.\n\t *    parameters:\n\t *      - name: name\n\t *        in: path\n\t *        description: Name of entity to return\n\t *        required: true\n\t *        schema:\n", " *          type: string\n\t *          example: '@DolarToday'\n\t *    responses:\n\t *      200:\n\t *        description: The API request has been successful.\n\t *      404:\n\t *        description: Not found.\n\t *      500:\n\t *        description: Internal server error.\n\t * \n", " * /api/v1/euro/toeuro?bs={amount}&entity={name}:\n\t *  get:\n\t *    summary: Obtain the euro values of a bolivar amount provided by parameter.\n\t *    tags:\n\t *      - euro\n\t *    description: Obtain the euro values of a bolivar amount provided by parameter.\n\t *    parameters:\n\t *      - name: bs\n\t *        in: path\n\t *        description: Bolivar amount provided.\n", " *        required: true\n\t *        schema:\n\t *          type: number\n\t *          example: 1080\n\t *      - name: name\n\t *        in: path\n\t *        description: Name of entity to return\n\t *        required: true\n\t *        schema:\n\t *          type: string\n", " *          example: '@DolarToday'\n\t *    responses:\n\t *      200:\n\t *        description: The API request has been successful.\n\t *      404:\n\t *        description: Not found.\n\t *      500:\n\t *        description: Internal server error.\n\t * \n\t * /api/v1/euro/toBs?euro={amount}&entity={name}:\n", " *  get:\n\t *    summary: Obtain the bolivar values of a euro amount provided by parameter.\n\t *    tags:\n\t *      - euro\n\t *    description: Obtain the bolivar values of a euro amount provided by parameter.\n\t *    parameters:\n\t *      - name: euro\n\t *        in: path\n\t *        description: euro amount provided.\n\t *        required: true\n", " *        schema:\n\t *          type: number\n\t *          example: 1080\n\t *      - name: name\n\t *        in: path\n\t *        description: Name of entity to return\n\t *        required: true\n\t *        schema:\n\t *          type: string\n\t *          example: '@DolarToday'\n", " *    responses:\n\t *      200:\n\t *        description: The API request has been successful.\n\t *      404:\n\t *        description: Not found.\n\t *      500:\n\t *        description: Internal server error.\n\t */\n\trouter.get('/', getEuro)\n\trouter.get('/entity', getSpecificEuro)\n", "router.get('/toEuro', calculatorBsToEuro)\n\trouter.get('/toBs', calculatorEuroToBs)\n\tmodule.exports = router\n"]}
{"filename": "src/routes/index.ts", "chunked_list": ["'use strict'\n\tconst router = require('express').Router()\n\t/**\n\t * Express router for handling requests to the '/dolar' endpoint.\n\t * @route /dolar\n\t * @handler require('./RDollar')\n\t */\n\trouter.use('/dollar', require('./RDollar'))\n\t/**\n\t * Express router for handling requests to the '/euro' endpoint.\n", " * @route /euro\n\t * @handler require('./REuro')\n\t */\n\trouter.use('/euro', require('./REuro'))\n\texport default router\n"]}
