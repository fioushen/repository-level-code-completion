{"filename": ".erb/configs/webpack.paths.ts", "chunked_list": ["const path = require('path');\n\tconst rootPath = path.join(__dirname, '../..');\n\tconst dllPath = path.join(__dirname, '../dll');\n\tconst srcPath = path.join(rootPath, 'src');\n\tconst srcMainPath = path.join(srcPath, 'main');\n\tconst srcRendererPath = path.join(srcPath, 'renderer');\n\tconst releasePath = path.join(rootPath, 'release');\n\tconst appPath = path.join(releasePath, 'app');\n\tconst appPackagePath = path.join(appPath, 'package.json');\n\tconst appNodeModulesPath = path.join(appPath, 'node_modules');\n", "const srcNodeModulesPath = path.join(srcPath, 'node_modules');\n\tconst distPath = path.join(appPath, 'dist');\n\tconst distMainPath = path.join(distPath, 'main');\n\tconst distRendererPath = path.join(distPath, 'renderer');\n\tconst buildPath = path.join(releasePath, 'build');\n\texport default {\n\t  rootPath,\n\t  dllPath,\n\t  srcPath,\n\t  srcMainPath,\n", "  srcRendererPath,\n\t  releasePath,\n\t  appPath,\n\t  appPackagePath,\n\t  appNodeModulesPath,\n\t  srcNodeModulesPath,\n\t  distPath,\n\t  distMainPath,\n\t  distRendererPath,\n\t  buildPath,\n", "};\n"]}
{"filename": ".erb/configs/webpack.config.base.ts", "chunked_list": ["/**\n\t * Base webpack config used across other specific configs\n\t */\n\timport webpack from 'webpack';\n\timport TsconfigPathsPlugins from 'tsconfig-paths-webpack-plugin';\n\timport webpackPaths from './webpack.paths';\n\timport { dependencies as externals } from '../../release/app/package.json';\n\tconst configuration: webpack.Configuration = {\n\t  externals: [...Object.keys(externals || {})],\n\t  stats: 'errors-only',\n", "  module: {\n\t    rules: [\n\t      {\n\t        test: /\\.[jt]sx?$/,\n\t        exclude: /node_modules/,\n\t        use: {\n\t          loader: 'ts-loader',\n\t          options: {\n\t            // Remove this line to enable type checking in webpack builds\n\t            transpileOnly: true,\n", "            compilerOptions: {\n\t              module: 'esnext',\n\t            },\n\t          },\n\t        },\n\t      },\n\t    ],\n\t  },\n\t  output: {\n\t    path: webpackPaths.srcPath,\n", "    // https://github.com/webpack/webpack/issues/1114\n\t    library: {\n\t      type: 'commonjs2',\n\t    },\n\t  },\n\t  /**\n\t   * Determine the array of extensions that should be used to resolve modules.\n\t   */\n\t  resolve: {\n\t    extensions: ['.js', '.jsx', '.json', '.ts', '.tsx'],\n", "    modules: [webpackPaths.srcPath, 'node_modules'],\n\t    // There is no need to add aliases here, the paths in tsconfig get mirrored\n\t    plugins: [new TsconfigPathsPlugins()],\n\t  },\n\t  plugins: [\n\t    new webpack.EnvironmentPlugin({\n\t      NODE_ENV: 'production',\n\t    }),\n\t  ],\n\t};\n", "export default configuration;\n"]}
{"filename": ".erb/configs/webpack.config.renderer.dev.dll.ts", "chunked_list": ["/**\n\t * Builds the DLL for development electron renderer process\n\t */\n\timport webpack from 'webpack';\n\timport path from 'path';\n\timport { merge } from 'webpack-merge';\n\timport baseConfig from './webpack.config.base';\n\timport webpackPaths from './webpack.paths';\n\timport { dependencies } from '../../package.json';\n\tconst dist = webpackPaths.dllPath;\n", "const configuration: webpack.Configuration = {\n\t  context: webpackPaths.rootPath,\n\t  devtool: 'eval',\n\t  mode: 'development',\n\t  target: 'electron-renderer',\n\t  externals: ['fsevents', 'crypto-browserify'],\n\t  /**\n\t   * Use `module` from `webpack.config.renderer.dev.js`\n\t   */\n\t  module: require('./webpack.config.renderer.dev').default.module,\n", "  entry: {\n\t    renderer: Object.keys(dependencies || {}),\n\t  },\n\t  output: {\n\t    path: dist,\n\t    filename: '[name].dev.dll.js',\n\t    library: {\n\t      name: 'renderer',\n\t      type: 'var',\n\t    },\n", "  },\n\t  plugins: [\n\t    new webpack.DllPlugin({\n\t      path: path.join(dist, '[name].json'),\n\t      name: '[name]',\n\t    }),\n\t    /**\n\t     * Create global constants which can be configured at compile time.\n\t     *\n\t     * Useful for allowing different behaviour between development builds and\n", "     * release builds\n\t     *\n\t     * NODE_ENV should be production so that modules do not perform certain\n\t     * development checks\n\t     */\n\t    new webpack.EnvironmentPlugin({\n\t      NODE_ENV: 'development',\n\t    }),\n\t    new webpack.LoaderOptionsPlugin({\n\t      debug: true,\n", "      options: {\n\t        context: webpackPaths.srcPath,\n\t        output: {\n\t          path: webpackPaths.dllPath,\n\t        },\n\t      },\n\t    }),\n\t  ],\n\t};\n\texport default merge(baseConfig, configuration);\n"]}
{"filename": ".erb/configs/webpack.config.renderer.dev.ts", "chunked_list": ["import 'webpack-dev-server';\n\timport path from 'path';\n\timport fs from 'fs';\n\timport webpack from 'webpack';\n\timport HtmlWebpackPlugin from 'html-webpack-plugin';\n\timport { merge } from 'webpack-merge';\n\timport { execSync, spawn } from 'child_process';\n\timport ReactRefreshWebpackPlugin from '@pmmmwh/react-refresh-webpack-plugin';\n\timport baseConfig from './webpack.config.base';\n\timport webpackPaths from './webpack.paths';\n", "const port = process.env.PORT || 1212;\n\tconst manifest = path.resolve(webpackPaths.dllPath, 'renderer.json');\n\tconst skipDLLs =\n\t  module.parent?.filename.includes('webpack.config.renderer.dev.dll') ||\n\t  module.parent?.filename.includes('webpack.config.eslint');\n\t/**\n\t * Warn if the DLL is not built\n\t */\n\tif (\n\t  !skipDLLs &&\n", "  !(fs.existsSync(webpackPaths.dllPath) && fs.existsSync(manifest))\n\t) {\n\t  execSync('npm run postinstall');\n\t}\n\tconst configuration: webpack.Configuration = {\n\t  devtool: false,\n\t  mode: 'development',\n\t  target: ['web', 'electron-renderer'],\n\t  entry: [\n\t    `webpack-dev-server/client?http://localhost:${port}/dist`,\n", "    'webpack/hot/only-dev-server',\n\t    path.join(webpackPaths.srcRendererPath, 'index.tsx'),\n\t  ],\n\t  output: {\n\t    path: webpackPaths.distRendererPath,\n\t    publicPath: '/',\n\t    filename: 'renderer.dev.js',\n\t    library: {\n\t      type: 'umd',\n\t    },\n", "  },\n\t  module: {\n\t    rules: [\n\t      {\n\t        test: /\\.css$/,\n\t        use: [\n\t          'style-loader',\n\t          {\n\t            loader: 'css-loader',\n\t            options: {\n", "              modules: true,\n\t              sourceMap: true,\n\t              importLoaders: 1,\n\t            },\n\t          },\n\t        ],\n\t        include: /\\.module\\.css$/,\n\t      },\n\t      {\n\t        test: /\\.css$/,\n", "        use: ['style-loader', 'css-loader'],\n\t        exclude: /\\.module\\.css$/,\n\t      },\n\t      // Fonts\n\t      {\n\t        test: /\\.(woff|woff2|eot|ttf|otf)$/i,\n\t        type: 'asset/resource',\n\t      },\n\t      // Images\n\t      {\n", "        test: /\\.(png|jpg|jpeg|gif)$/i,\n\t        type: 'asset/resource',\n\t      },\n\t      // SVG\n\t      {\n\t        test: /\\.svg$/,\n\t        use: [\n\t          {\n\t            loader: '@svgr/webpack',\n\t            options: {\n", "              prettier: false,\n\t              svgo: false,\n\t              svgoConfig: {\n\t                plugins: [{ removeViewBox: false }],\n\t              },\n\t              titleProp: true,\n\t              ref: true,\n\t            },\n\t          },\n\t          'file-loader',\n", "        ],\n\t      },\n\t    ],\n\t  },\n\t  plugins: [\n\t    ...(skipDLLs\n\t      ? []\n\t      : [\n\t          new webpack.DllReferencePlugin({\n\t            context: webpackPaths.dllPath,\n", "            manifest: require(manifest),\n\t            sourceType: 'var',\n\t          }),\n\t        ]),\n\t    new webpack.NoEmitOnErrorsPlugin(),\n\t    /**\n\t     * Create global constants which can be configured at compile time.\n\t     *\n\t     * Useful for allowing different behaviour between development builds and\n\t     * release builds\n", "     *\n\t     * NODE_ENV should be production so that modules do not perform certain\n\t     * development checks\n\t     *\n\t     * By default, use 'development' as NODE_ENV. This can be overriden with\n\t     * 'staging', for example, by changing the ENV variables in the npm scripts\n\t     */\n\t    new webpack.EnvironmentPlugin({\n\t      NODE_ENV: 'development',\n\t    }),\n", "    new webpack.LoaderOptionsPlugin({\n\t      debug: true,\n\t    }),\n\t    new ReactRefreshWebpackPlugin(),\n\t    new HtmlWebpackPlugin({\n\t      filename: path.join('index.html'),\n\t      template: path.join(webpackPaths.srcRendererPath, 'index.html'),\n\t      minify: {\n\t        collapseWhitespace: true,\n\t        removeAttributeQuotes: true,\n", "        removeComments: true,\n\t      },\n\t      isBrowser: false,\n\t      env: process.env.NODE_ENV,\n\t      isDevelopment: process.env.NODE_ENV !== 'production',\n\t      nodeModules: webpackPaths.appNodeModulesPath,\n\t    }),\n\t  ],\n\t  node: {\n\t    __dirname: false,\n", "    __filename: false,\n\t  },\n\t  devServer: {\n\t    port,\n\t    compress: true,\n\t    hot: true,\n\t    headers: { 'Access-Control-Allow-Origin': '*' },\n\t    static: {\n\t      publicPath: '/',\n\t    },\n", "    historyApiFallback: {\n\t      verbose: true,\n\t    },\n\t    setupMiddlewares(middlewares) {\n\t      console.log('Starting preload.js builder...');\n\t      const preloadProcess = spawn('npm', ['run', 'start:preload'], {\n\t        shell: true,\n\t        stdio: 'inherit',\n\t      })\n\t        .on('close', (code: number) => process.exit(code!))\n", "        .on('error', (spawnError) => console.error(spawnError));\n\t      console.log('Starting Main Process...');\n\t      let args = ['run', 'start:main'];\n\t      if (process.env.MAIN_ARGS) {\n\t        args = args.concat(\n\t          ['--', ...process.env.MAIN_ARGS.matchAll(/\"[^\"]+\"|[^\\s\"]+/g)].flat()\n\t        );\n\t      }\n\t      spawn('npm', args, {\n\t        shell: true,\n", "        stdio: 'inherit',\n\t      })\n\t        .on('close', (code: number) => {\n\t          preloadProcess.kill();\n\t          process.exit(code!);\n\t        })\n\t        .on('error', (spawnError) => console.error(spawnError));\n\t      return middlewares;\n\t    },\n\t  },\n", "};\n\texport default merge(baseConfig, configuration);\n"]}
{"filename": ".erb/configs/webpack.config.renderer.prod.ts", "chunked_list": ["/**\n\t * Build config for electron renderer process\n\t */\n\timport path from 'path';\n\timport webpack from 'webpack';\n\timport HtmlWebpackPlugin from 'html-webpack-plugin';\n\timport MiniCssExtractPlugin from 'mini-css-extract-plugin';\n\timport { merge } from 'webpack-merge';\n\timport baseConfig from './webpack.config.base';\n\timport webpackPaths from './webpack.paths';\n", "const configuration: webpack.Configuration = {\n\t  devtool: false,\n\t  mode: 'production',\n\t  target: ['web', 'electron-renderer'],\n\t  entry: [path.join(webpackPaths.srcRendererPath, 'index.tsx')],\n\t  output: {\n\t    path: webpackPaths.distRendererPath,\n\t    publicPath: './',\n\t    filename: 'renderer.js',\n\t    library: {\n", "      type: 'umd',\n\t    },\n\t  },\n\t  module: {\n\t    rules: [\n\t      {\n\t        test: /\\.css$/,\n\t        use: [\n\t          MiniCssExtractPlugin.loader,\n\t          {\n", "            loader: 'css-loader',\n\t            options: {\n\t              modules: true,\n\t              sourceMap: true,\n\t              importLoaders: 1,\n\t            },\n\t          },\n\t        ],\n\t        include: /\\.module\\.css$/,\n\t      },\n", "      {\n\t        test: /\\.css$/,\n\t        use: [MiniCssExtractPlugin.loader, 'css-loader'],\n\t        exclude: /\\.module\\.css$/,\n\t      },\n\t      // Fonts\n\t      {\n\t        test: /\\.(woff|woff2|eot|ttf|otf)$/i,\n\t        type: 'asset/resource',\n\t      },\n", "      // Images\n\t      {\n\t        test: /\\.(png|jpg|jpeg|gif)$/i,\n\t        type: 'asset/resource',\n\t      },\n\t      // SVG\n\t      {\n\t        test: /\\.svg$/,\n\t        use: [\n\t          {\n", "            loader: '@svgr/webpack',\n\t            options: {\n\t              prettier: false,\n\t              svgo: false,\n\t              svgoConfig: {\n\t                plugins: [{ removeViewBox: false }],\n\t              },\n\t              titleProp: true,\n\t              ref: true,\n\t            },\n", "          },\n\t          'file-loader',\n\t        ],\n\t      },\n\t    ],\n\t  },\n\t  optimization: {\n\t    minimize: false,\n\t  },\n\t  plugins: [\n", "    /**\n\t     * Create global constants which can be configured at compile time.\n\t     *\n\t     * Useful for allowing different behaviour between development builds and\n\t     * release builds\n\t     *\n\t     * NODE_ENV should be production so that modules do not perform certain\n\t     * development checks\n\t     */\n\t    new webpack.EnvironmentPlugin({\n", "      NODE_ENV: 'production',\n\t      DEBUG_PROD: false,\n\t    }),\n\t    new MiniCssExtractPlugin({\n\t      filename: 'style.css',\n\t    }),\n\t    new HtmlWebpackPlugin({\n\t      filename: 'index.html',\n\t      template: path.join(webpackPaths.srcRendererPath, 'index.html'),\n\t      minify: {\n", "        collapseWhitespace: true,\n\t        removeAttributeQuotes: true,\n\t        removeComments: true,\n\t      },\n\t      isBrowser: false,\n\t      isDevelopment: process.env.NODE_ENV !== 'production',\n\t    }),\n\t    new webpack.DefinePlugin({\n\t      'process.type': '\"renderer\"',\n\t    }),\n", "  ],\n\t};\n\texport default merge(baseConfig, configuration);\n"]}
{"filename": ".erb/configs/webpack.config.eslint.ts", "chunked_list": ["module.exports = require('./webpack.config.renderer.dev').default;\n"]}
{"filename": ".erb/configs/webpack.config.preload.dev.ts", "chunked_list": ["import path from 'path';\n\timport webpack from 'webpack';\n\timport { merge } from 'webpack-merge';\n\timport baseConfig from './webpack.config.base';\n\timport webpackPaths from './webpack.paths';\n\tconst configuration: webpack.Configuration = {\n\t  devtool: false,\n\t  mode: 'development',\n\t  target: 'electron-preload',\n\t  entry: path.join(webpackPaths.srcMainPath, 'preload.ts'),\n", "  output: {\n\t    path: webpackPaths.dllPath,\n\t    filename: 'preload.js',\n\t    library: {\n\t      type: 'umd',\n\t    },\n\t  },\n\t  plugins: [\n\t    /**\n\t     * Create global constants which can be configured at compile time.\n", "     *\n\t     * Useful for allowing different behaviour between development builds and\n\t     * release builds\n\t     *\n\t     * NODE_ENV should be production so that modules do not perform certain\n\t     * development checks\n\t     *\n\t     * By default, use 'development' as NODE_ENV. This can be overriden with\n\t     * 'staging', for example, by changing the ENV variables in the npm scripts\n\t     */\n", "    new webpack.EnvironmentPlugin({\n\t      NODE_ENV: 'development',\n\t    }),\n\t    new webpack.LoaderOptionsPlugin({\n\t      debug: true,\n\t    }),\n\t  ],\n\t  /**\n\t   * Disables webpack processing of __dirname and __filename.\n\t   * If you run the bundle in node.js it falls back to these values of node.js.\n", "   * https://github.com/webpack/webpack/issues/2010\n\t   */\n\t  node: {\n\t    __dirname: false,\n\t    __filename: false,\n\t  },\n\t  watch: true,\n\t};\n\texport default merge(baseConfig, configuration);\n"]}
{"filename": ".erb/configs/webpack.config.main.prod.ts", "chunked_list": ["/**\n\t * Webpack config for production electron main process\n\t */\n\timport path from 'path';\n\timport webpack from 'webpack';\n\timport { merge } from 'webpack-merge';\n\timport baseConfig from './webpack.config.base';\n\timport webpackPaths from './webpack.paths';\n\tconst configuration: webpack.Configuration = {\n\t  devtool: false,\n", "  mode: 'production',\n\t  target: 'electron-main',\n\t  entry: {\n\t    main: path.join(webpackPaths.srcMainPath, 'main.ts'),\n\t    preload: path.join(webpackPaths.srcMainPath, 'preload.ts'),\n\t  },\n\t  output: {\n\t    path: webpackPaths.distMainPath,\n\t    filename: '[name].js',\n\t    library: {\n", "      type: 'umd',\n\t    },\n\t  },\n\t  optimization: {\n\t    minimize: false,\n\t  },\n\t  plugins: [\n\t    /**\n\t     * Create global constants which can be configured at compile time.\n\t     *\n", "     * Useful for allowing different behaviour between development builds and\n\t     * release builds\n\t     *\n\t     * NODE_ENV should be production so that modules do not perform certain\n\t     * development checks\n\t     */\n\t    new webpack.EnvironmentPlugin({\n\t      NODE_ENV: 'production',\n\t      DEBUG_PROD: false,\n\t      START_MINIMIZED: false,\n", "    }),\n\t    new webpack.DefinePlugin({\n\t      'process.type': '\"browser\"',\n\t    }),\n\t  ],\n\t  /**\n\t   * Disables webpack processing of __dirname and __filename.\n\t   * If you run the bundle in node.js it falls back to these values of node.js.\n\t   * https://github.com/webpack/webpack/issues/2010\n\t   */\n", "  node: {\n\t    __dirname: false,\n\t    __filename: false,\n\t  },\n\t  module: {\n\t    rules: [\n\t      // Images\n\t      {\n\t        test: /\\.(svg)$/i,\n\t        type: 'asset/resource',\n", "      },\n\t    ],\n\t  },\n\t};\n\texport default merge(baseConfig, configuration);\n"]}
{"filename": ".erb/scripts/link-modules.ts", "chunked_list": ["import fs from 'fs';\n\timport webpackPaths from '../configs/webpack.paths';\n\tconst { srcNodeModulesPath } = webpackPaths;\n\tconst { appNodeModulesPath } = webpackPaths;\n\tif (!fs.existsSync(srcNodeModulesPath) && fs.existsSync(appNodeModulesPath)) {\n\t  fs.symlinkSync(appNodeModulesPath, srcNodeModulesPath, 'junction');\n\t}\n"]}
{"filename": ".erb/scripts/check-build-exists.ts", "chunked_list": ["// Check if the renderer and main bundles are built\n\timport path from 'path';\n\timport fs from 'fs';\n\timport webpackPaths from '../configs/webpack.paths';\n\tconst mainPath = path.join(webpackPaths.distMainPath, 'main.js');\n\tconst rendererPath = path.join(webpackPaths.distRendererPath, 'renderer.js');\n\tif (!fs.existsSync(mainPath)) {\n\t  throw new Error(\n\t    'The main process is not built yet. Build it by running \"npm run build:main\"'\n\t  );\n", "}\n\tif (!fs.existsSync(rendererPath)) {\n\t  throw new Error(\n\t    'The renderer process is not built yet. Build it by running \"npm run build:renderer\"'\n\t  );\n\t}\n"]}
{"filename": "assets/assets.d.ts", "chunked_list": ["type Styles = Record<string, string>;\n\tdeclare module '*.svg' {\n\t  import React = require('react');\n\t  export const ReactComponent: React.FC<React.SVGProps<SVGSVGElement>>;\n\t  const content: string;\n\t  export default content;\n\t}\n\tdeclare module '*.png' {\n\t  const content: string;\n\t  export default content;\n", "}\n\tdeclare module '*.jpg' {\n\t  const content: string;\n\t  export default content;\n\t}\n\tdeclare module '*.css' {\n\t  const content: Styles;\n\t  export default content;\n\t}\n"]}
{"filename": "src/config.ts", "chunked_list": ["import { z } from 'zod';\n\texport const DappSchema = z\n\t  .object({\n\t    id: z.string(),\n\t    label: z.string(),\n\t    icon: z.string(),\n\t    ens: z.string().optional(),\n\t    ipns: z.string().optional(),\n\t    qm: z.string().optional(),\n\t    bafy: z.string().optional(),\n", "    url: z.string().optional(),\n\t  })\n\t  .strict()\n\t  .refine((obj) => Boolean(obj.ens || obj.ipns), {\n\t    message: 'ens or ipns must be defined',\n\t    path: ['ens'],\n\t  });\n\texport const DappsSchema = z.array(DappSchema);\n\texport const ConfigSchema = z\n\t  .object({\n", "    dapps: DappsSchema,\n\t  })\n\t  .strict();\n\texport type DappType = z.infer<typeof DappSchema>;\n"]}
{"filename": "src/const.ts", "chunked_list": ["export const SYNTHETIX_IPNS =\n\t  'k51qzi5uqu5dj0vqsuc4wyyj93tpaurdfjtulpx0w45q8eqd7uay49zodimyh7';\n\texport const SYNTHETIX_NODE_APP_CONFIG =\n\t  'k2k4r8jhn5r54sf708bnlxun971q0pteab82iw98544sj1e0hi3hp9q6';\n"]}
{"filename": "src/config-check.ts", "chunked_list": ["import { ConfigSchema } from './config';\n\timport config from '../config.json';\n\tConfigSchema.parse(config);\n"]}
{"filename": "src/scripts/follower-install.ts", "chunked_list": ["import {\n\t  downloadFollower,\n\t  followerDaemon,\n\t  followerKill,\n\t} from '../main/follower';\n\tasync function main() {\n\t  await downloadFollower();\n\t  await followerDaemon();\n\t}\n\tprocess.on('beforeExit', followerKill);\n", "main();\n"]}
{"filename": "src/scripts/ipfs-install.ts", "chunked_list": ["import { downloadIpfs, ipfsDaemon, ipfsKill } from '../main/ipfs';\n\tasync function main() {\n\t  await downloadIpfs();\n\t  await ipfsDaemon();\n\t}\n\tprocess.on('beforeExit', ipfsKill);\n\tmain();\n"]}
{"filename": "src/renderer/preload.d.ts", "chunked_list": ["import { ElectronHandler } from 'main/preload';\n\tdeclare global {\n\t  // eslint-disable-next-line no-unused-vars\n\t  interface Window {\n\t    electron: ElectronHandler;\n\t  }\n\t}\n\texport {};\n"]}
{"filename": "src/renderer/DApps/useDapp.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function useDapp(id: string) {\n\t  return useQuery({\n\t    queryKey: ['dapp', id],\n\t    queryFn: async () => {\n\t      const url = await ipcRenderer.invoke('dapp', id);\n\t      if (!url) {\n\t        return null;\n\t      }\n", "      return url;\n\t    },\n\t    initialData: () => null,\n\t    placeholderData: null,\n\t    enabled: Boolean(ipcRenderer),\n\t  });\n\t}\n"]}
{"filename": "src/renderer/DApps/index.ts", "chunked_list": ["export * from './Dapps';\n"]}
{"filename": "src/renderer/DApps/useDapps.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\timport { DappsSchema } from '../../config';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function useDapps() {\n\t  return useQuery({\n\t    queryKey: ['dapps'],\n\t    queryFn: async () => {\n\t      return DappsSchema.parse(await ipcRenderer.invoke('dapps'));\n\t    },\n\t    initialData: () => [],\n", "    placeholderData: [],\n\t    enabled: Boolean(ipcRenderer),\n\t  });\n\t}\n"]}
{"filename": "src/renderer/Ipfs/useRepoStat.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\timport { useIsIpfsRunning } from './useIsIpfsRunning';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function useRepoStat() {\n\t  const { data: isRunning } = useIsIpfsRunning();\n\t  return useQuery({\n\t    queryKey: ['ipfs', 'repo stat'],\n\t    queryFn: async () => {\n\t      const stats = await ipcRenderer.invoke('ipfs-repo-stat');\n\t      if (!stats) {\n", "        return '';\n\t      }\n\t      return stats;\n\t    },\n\t    initialData: () => '',\n\t    placeholderData: '',\n\t    enabled: Boolean(ipcRenderer && isRunning),\n\t  });\n\t}\n"]}
{"filename": "src/renderer/Ipfs/useHostingSize.ts", "chunked_list": ["import React from 'react';\n\timport { useRepoStat } from './useRepoStat';\n\texport function useHostingSize() {\n\t  const { data: repoStat } = useRepoStat();\n\t  return React.useMemo(() => {\n\t    if (!repoStat) {\n\t      return 0;\n\t    }\n\t    const numBytes = parseInt(repoStat.split('\\n')[1].split(':')[1].trim(), 10);\n\t    const numMegabytes = numBytes / 1024 / 1024;\n", "    return numMegabytes;\n\t  }, [repoStat]);\n\t}\n"]}
{"filename": "src/renderer/Ipfs/useIsIpfsInstalled.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function useIsIpfsInstalled() {\n\t  return useQuery({\n\t    queryKey: ['ipfs', 'isInstalled'],\n\t    queryFn: () => ipcRenderer.invoke('ipfs-isInstalled'),\n\t    initialData: () => false,\n\t    placeholderData: false,\n\t    enabled: Boolean(ipcRenderer),\n\t  });\n", "}\n"]}
{"filename": "src/renderer/Ipfs/useRateIn.ts", "chunked_list": ["import React from 'react';\n\timport { useStatsBw } from './useStatsBw';\n\texport function useRateIn() {\n\t  const { data: statsBw } = useStatsBw();\n\t  return React.useMemo(() => {\n\t    return statsBw ? statsBw.split('\\n')[3].split(':')[1].trim() : '';\n\t  }, [statsBw]);\n\t}\n"]}
{"filename": "src/renderer/Ipfs/usePeers.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\timport { useIsIpfsRunning } from './useIsIpfsRunning';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function usePeers() {\n\t  const { data: isRunning } = useIsIpfsRunning();\n\t  return useQuery({\n\t    queryKey: ['ipfs', 'peers'],\n\t    queryFn: async () => {\n\t      const peers = await ipcRenderer.invoke('peers');\n\t      if (!peers) {\n", "        return [];\n\t      }\n\t      return peers;\n\t    },\n\t    initialData: () => [],\n\t    placeholderData: [],\n\t    enabled: Boolean(ipcRenderer && isRunning),\n\t    refetchInterval: 30_000,\n\t    refetchOnWindowFocus: true,\n\t  });\n", "}\n"]}
{"filename": "src/renderer/Ipfs/useFollowerInfo.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\timport { useIsFollowerRunning } from './useIsFollowerRunning';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function useFollowerInfo() {\n\t  const { data: isRunning } = useIsFollowerRunning();\n\t  return useQuery({\n\t    queryKey: ['follower', 'info'],\n\t    queryFn: async () => {\n\t      const state = await ipcRenderer.invoke('ipfs-follower-info');\n\t      return {\n", "        ipfs: state?.includes('IPFS peer online: true'),\n\t        cluster: state?.includes('Cluster Peer online: true'),\n\t      };\n\t    },\n\t    initialData: () => ({\n\t      ipfs: false,\n\t      cluster: false,\n\t    }),\n\t    placeholderData: {\n\t      ipfs: false,\n", "      cluster: false,\n\t    },\n\t    enabled: Boolean(ipcRenderer && isRunning),\n\t    refetchInterval: 30_000,\n\t  });\n\t}\n"]}
{"filename": "src/renderer/Ipfs/useIsFollowerRunning.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\timport { useIsFollowerInstalled } from './useIsFollowerInstalled';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function useIsFollowerRunning() {\n\t  const { data: isInstalled } = useIsFollowerInstalled();\n\t  return useQuery({\n\t    queryKey: ['follower', 'isRunning'],\n\t    queryFn: () => ipcRenderer.invoke('follower-isRunning'),\n\t    initialData: () => false,\n\t    placeholderData: false,\n", "    enabled: Boolean(ipcRenderer && isInstalled),\n\t  });\n\t}\n"]}
{"filename": "src/renderer/Ipfs/useIsFollowerInstalled.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function useIsFollowerInstalled() {\n\t  return useQuery({\n\t    queryKey: ['follower', 'isInstalled'],\n\t    queryFn: () => ipcRenderer.invoke('follower-isInstalled'),\n\t    initialData: () => false,\n\t    placeholderData: false,\n\t    enabled: Boolean(ipcRenderer),\n\t  });\n", "}\n"]}
{"filename": "src/renderer/Ipfs/usePeerId.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\timport { useIsIpfsRunning } from './useIsIpfsRunning';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function usePeerId() {\n\t  const { data: isRunning } = useIsIpfsRunning();\n\t  return useQuery({\n\t    queryKey: ['ipfs', 'id'],\n\t    queryFn: async () => {\n\t      const id = await ipcRenderer.invoke('ipfs-id');\n\t      if (!id) {\n", "        return '';\n\t      }\n\t      return id;\n\t    },\n\t    initialData: () => '',\n\t    placeholderData: '',\n\t    enabled: Boolean(ipcRenderer && isRunning),\n\t  });\n\t}\n"]}
{"filename": "src/renderer/Ipfs/index.ts", "chunked_list": ["export * from './Ipfs';\n"]}
{"filename": "src/renderer/Ipfs/useIsIpfsRunning.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\timport { useIsIpfsInstalled } from './useIsIpfsInstalled';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function useIsIpfsRunning() {\n\t  const { data: isInstalled } = useIsIpfsInstalled();\n\t  return useQuery({\n\t    queryKey: ['ipfs', 'isRunning'],\n\t    queryFn: () => ipcRenderer.invoke('ipfs-isRunning'),\n\t    initialData: () => false,\n\t    placeholderData: false,\n", "    enabled: Boolean(ipcRenderer && isInstalled),\n\t  });\n\t}\n"]}
{"filename": "src/renderer/Ipfs/useRateOut.ts", "chunked_list": ["import React from 'react';\n\timport { useStatsBw } from './useStatsBw';\n\texport function useRateOut() {\n\t  const { data: statsBw } = useStatsBw();\n\t  return React.useMemo(() => {\n\t    return statsBw ? statsBw.split('\\n')[4].split(':')[1].trim() : '';\n\t  }, [statsBw]);\n\t}\n"]}
{"filename": "src/renderer/Ipfs/useStatsBw.ts", "chunked_list": ["import { useQuery } from '@tanstack/react-query';\n\timport { useIsIpfsRunning } from './useIsIpfsRunning';\n\tconst { ipcRenderer } = window?.electron || {};\n\texport function useStatsBw() {\n\t  const { data: isRunning } = useIsIpfsRunning();\n\t  return useQuery({\n\t    queryKey: ['ipfs', 'stats bw'],\n\t    queryFn: async () => {\n\t      const stats = await ipcRenderer.invoke('ipfs-stats-bw');\n\t      if (!stats) {\n", "        return '';\n\t      }\n\t      return stats;\n\t    },\n\t    initialData: () => '',\n\t    placeholderData: '',\n\t    enabled: Boolean(ipcRenderer && isRunning),\n\t  });\n\t}\n"]}
{"filename": "src/main/dapps.ts", "chunked_list": ["import logger from 'electron-log';\n\timport fetch from 'node-fetch';\n\timport { createPublicClient, http } from 'viem';\n\timport { mainnet } from 'viem/chains';\n\timport { namehash, normalize } from 'viem/ens';\n\t// @ts-ignore\n\timport * as contentHash from '@ensdomains/content-hash';\n\timport { ipfs } from './ipfs';\n\timport { getPid } from './pid';\n\timport { DappType } from '../config';\n", "Object.assign(global, { fetch });\n\texport const DAPPS: DappType[] = [];\n\tconst client = createPublicClient({\n\t  chain: mainnet,\n\t  transport: http(),\n\t});\n\tconst resolverAbi = [\n\t  {\n\t    constant: true,\n\t    inputs: [{ internalType: 'bytes32', name: 'node', type: 'bytes32' }],\n", "    name: 'contenthash',\n\t    outputs: [{ internalType: 'bytes', name: '', type: 'bytes' }],\n\t    payable: false,\n\t    stateMutability: 'view',\n\t    type: 'function',\n\t  },\n\t];\n\texport async function resolveEns(\n\t  dapp: DappType\n\t): Promise<{ codec: string; hash: string }> {\n", "  if (dapp.ipns) {\n\t    return {\n\t      codec: 'ipns-ns',\n\t      hash: dapp.ipns,\n\t    };\n\t  }\n\t  if (!dapp.ens) {\n\t    throw new Error('Neither ipns nor ens was set, cannot resolve');\n\t  }\n\t  const name = normalize(dapp.ens);\n", "  const resolverAddress = await client.getEnsResolver({ name });\n\t  const hash = await client.readContract({\n\t    address: resolverAddress,\n\t    abi: resolverAbi,\n\t    functionName: 'contenthash',\n\t    args: [namehash(name)],\n\t  });\n\t  const codec = contentHash.getCodec(hash);\n\t  return {\n\t    codec,\n", "    hash: contentHash.decode(hash),\n\t  };\n\t}\n\texport async function resolveQm(ipns: string): Promise<string> {\n\t  const ipfsPath = await ipfs(`resolve /ipns/${ipns}`);\n\t  const qm = ipfsPath.slice(6); // remove /ipfs/\n\t  return qm; // Qm\n\t}\n\texport async function convertCid(qm: string): Promise<string> {\n\t  return await ipfs(`cid base32 ${qm}`);\n", "}\n\texport async function isPinned(qm: string): Promise<boolean> {\n\t  try {\n\t    const result = await ipfs(`pin ls --type recursive ${qm}`);\n\t    return result.includes(qm);\n\t  } catch (e) {\n\t    return false;\n\t  }\n\t}\n\texport async function resolveDapp(dapp: DappType): Promise<void> {\n", "  try {\n\t    const { codec, hash } = await resolveEns(dapp);\n\t    logger.log(dapp.id, 'resolved', codec, hash);\n\t    const qm =\n\t      codec === 'ipns-ns'\n\t        ? await resolveQm(hash)\n\t        : codec === 'ipfs-ns'\n\t        ? hash\n\t        : undefined;\n\t    if (qm) {\n", "      Object.assign(dapp, { qm });\n\t    }\n\t    if (qm !== hash) {\n\t      logger.log(dapp.id, 'resolved CID', qm);\n\t    }\n\t    if (!qm) {\n\t      throw new Error(`Codec \"${codec}\" not supported`);\n\t    }\n\t    if (await getPid(`pin add --progress ${qm}`)) {\n\t      logger.log(dapp.id, 'pinning already in progres...');\n", "      return;\n\t    }\n\t    const isDappPinned = await isPinned(qm);\n\t    if (!isDappPinned) {\n\t      logger.log(dapp.id, 'pinning...', qm);\n\t      await ipfs(`pin add --progress ${qm}`);\n\t    }\n\t    const bafy = await convertCid(qm);\n\t    Object.assign(dapp, { bafy });\n\t    const url = `${bafy}.ipfs.localhost`;\n", "    Object.assign(dapp, { url });\n\t    logger.log(dapp.id, 'local IPFS host:', url);\n\t  } catch (e) {\n\t    logger.error(e);\n\t    return;\n\t  }\n\t}\n\texport async function cleanupOldDapps() {\n\t  const hashes = DAPPS.map((dapp) => dapp.qm);\n\t  logger.log('Current DAPPs hashes', hashes);\n", "  if (hashes.length < 1 || hashes.some((hash) => !hash)) {\n\t    // We only want to cleanup when all the dapps aer resolved\n\t    return;\n\t  }\n\t  try {\n\t    const pins = JSON.parse(await ipfs('pin ls --enc=json --type=recursive'));\n\t    const pinnedHashes = Object.keys(pins.Keys);\n\t    logger.log('Existing IPFS pins', pinnedHashes);\n\t    const toUnpin = pinnedHashes.filter((hash) => !hashes.includes(hash));\n\t    logger.log('Hashes to unpin', toUnpin);\n", "    if (toUnpin.length > 0) {\n\t      for (const hash of toUnpin) {\n\t        logger.log(`Unpinning ${hash}`);\n\t        await ipfs(`pin rm ${hash}`);\n\t      }\n\t      const pinsAfter = JSON.parse(\n\t        await ipfs('pin ls --enc=json --type=recursive')\n\t      );\n\t      logger.log('Updated IPFS pins', pinsAfter);\n\t      // Clenup the repo\n", "      await ipfs('repo gc');\n\t    }\n\t  } catch (e) {\n\t    // do nothing\n\t  }\n\t}\n"]}
{"filename": "src/main/main.ts", "chunked_list": ["/**\n\t * This module executes inside of electron's main process. You can start\n\t * electron renderer process from here and communicate with the other processes\n\t * through IPC.\n\t *\n\t * When running `npm run build` or `npm run build:main`, this file is compiled to\n\t * `./src/main.js` using webpack. This gives us some performance wins.\n\t */\n\timport path from 'path';\n\timport { app, BrowserWindow, ipcMain, Menu, shell, Tray } from 'electron';\n", "// import { autoUpdater } from 'electron-updater';\n\timport logger from 'electron-log';\n\timport { resolveHtmlPath } from './util';\n\timport {\n\t  configureIpfs,\n\t  downloadIpfs,\n\t  ipfs,\n\t  ipfsDaemon,\n\t  ipfsIsInstalled,\n\t  ipfsIsRunning,\n", "  ipfsKill,\n\t  waitForIpfs,\n\t} from './ipfs';\n\timport {\n\t  configureFollower,\n\t  downloadFollower,\n\t  follower,\n\t  followerDaemon,\n\t  followerId,\n\t  followerIsInstalled,\n", "  followerKill,\n\t  followerPid,\n\t} from './follower';\n\timport { DAPPS, resolveDapp } from './dapps';\n\timport { fetchPeers } from './peers';\n\timport { SYNTHETIX_NODE_APP_CONFIG } from '../const';\n\timport * as settings from './settings';\n\timport http from 'http';\n\timport { proxy } from './proxy';\n\tlogger.transports.file.level = 'info';\n", "const isDebug =\n\t  process.env.NODE_ENV === 'development' || process.env.DEBUG_PROD === 'true';\n\t// class AppUpdater {\n\t//   constructor() {\n\t//     log.transports.file.level = 'info';\n\t//     autoUpdater.logger = log;\n\t//     autoUpdater.checkForUpdatesAndNotify();\n\t//   }\n\t// }\n\tlet tray: Tray | null = null;\n", "let mainWindow: BrowserWindow | null = null;\n\tif (process.env.NODE_ENV === 'production') {\n\t  const sourceMapSupport = require('source-map-support');\n\t  sourceMapSupport.install();\n\t}\n\tconst RESOURCES_PATH = app.isPackaged\n\t  ? path.join(process.resourcesPath, 'assets')\n\t  : path.join(__dirname, '../../assets');\n\tconst getAssetPath = (...paths: string[]): string => {\n\t  return path.join(RESOURCES_PATH, ...paths);\n", "};\n\tfunction updateContextMenu() {\n\t  const menu = generateMenuItems();\n\t  if (tray && !tray.isDestroyed()) {\n\t    tray.setContextMenu(\n\t      Menu.buildFromTemplate([\n\t        menu.app,\n\t        menu.autoStart,\n\t        menu.devTools,\n\t        menu.dock,\n", "        { type: 'separator' },\n\t        ...menu.dapps,\n\t        { type: 'separator' },\n\t        menu.quit,\n\t      ])\n\t    );\n\t  }\n\t  app.dock.setMenu(\n\t    Menu.buildFromTemplate([\n\t      menu.app,\n", "      menu.autoStart,\n\t      menu.devTools,\n\t      menu.tray,\n\t      { type: 'separator' },\n\t      ...menu.dapps,\n\t    ])\n\t  );\n\t}\n\tfunction createWindow() {\n\t  mainWindow = new BrowserWindow({\n", "    show: true,\n\t    useContentSize: true,\n\t    center: true,\n\t    minWidth: 600,\n\t    minHeight: 470,\n\t    skipTaskbar: true,\n\t    fullscreen: false,\n\t    fullscreenable: false,\n\t    width: 600,\n\t    height: 470,\n", "    // frame: false,\n\t    icon: getAssetPath('icon.icns'),\n\t    webPreferences: {\n\t      preload: app.isPackaged\n\t        ? path.join(__dirname, 'preload.js')\n\t        : path.join(__dirname, '../../.erb/dll/preload.js'),\n\t    },\n\t  });\n\t  if (isDebug) {\n\t    mainWindow.webContents.openDevTools({ mode: 'detach' });\n", "  }\n\t  mainWindow.loadURL(resolveHtmlPath('index.html'));\n\t  mainWindow.on('closed', () => {\n\t    mainWindow = null;\n\t  });\n\t  // Open urls in the user's browser\n\t  mainWindow.webContents.setWindowOpenHandler((edata) => {\n\t    shell.openExternal(edata.url);\n\t    return { action: 'deny' };\n\t  });\n", "  mainWindow.webContents.on('devtools-opened', updateContextMenu);\n\t  mainWindow.webContents.on('devtools-closed', updateContextMenu);\n\t  mainWindow.on('hide', updateContextMenu);\n\t  mainWindow.on('show', updateContextMenu);\n\t  // Remove this if your app does not use auto updates\n\t  // eslint-disable-next-line\n\t  // new AppUpdater();\n\t}\n\tfunction generateMenuItems() {\n\t  return {\n", "    app: {\n\t      label: mainWindow?.isVisible() ? 'Hide App' : 'Open App',\n\t      click: () => {\n\t        if (mainWindow?.isVisible()) {\n\t          mainWindow.hide();\n\t          if (mainWindow.webContents.isDevToolsOpened()) {\n\t            mainWindow.webContents.closeDevTools();\n\t          }\n\t          return;\n\t        }\n", "        if (!mainWindow) {\n\t          createWindow();\n\t        } else {\n\t          mainWindow.show();\n\t        }\n\t        updateContextMenu();\n\t      },\n\t    },\n\t    autoStart: {\n\t      label: app.getLoginItemSettings().openAtLogin\n", "        ? 'Disable AutoStart'\n\t        : 'Enable AutoStart',\n\t      click: () => {\n\t        const settings = app.getLoginItemSettings();\n\t        settings.openAtLogin = !settings.openAtLogin;\n\t        app.setLoginItemSettings(settings);\n\t        updateContextMenu();\n\t      },\n\t    },\n\t    devTools: {\n", "      label:\n\t        mainWindow && mainWindow.webContents.isDevToolsOpened()\n\t          ? 'Close DevTools'\n\t          : 'Open DevTools',\n\t      click: () => {\n\t        if (mainWindow) {\n\t          if (mainWindow.webContents.isDevToolsOpened()) {\n\t            mainWindow.webContents.closeDevTools();\n\t          } else {\n\t            mainWindow.webContents.openDevTools({ mode: 'detach' });\n", "          }\n\t        }\n\t        updateContextMenu();\n\t      },\n\t    },\n\t    dock: {\n\t      label: app.dock && app.dock.isVisible() ? 'Hide Dock' : 'Show Dock',\n\t      click: async () => {\n\t        if (app.dock) {\n\t          if (app.dock.isVisible()) {\n", "            await settings.set('dock', false);\n\t            app.dock.hide();\n\t          } else {\n\t            await settings.set('dock', true);\n\t            app.dock.show();\n\t          }\n\t        }\n\t        updateContextMenu();\n\t      },\n\t    },\n", "    tray: {\n\t      label: tray && !tray.isDestroyed() ? 'Hide Tray icon' : 'Show Tray icon',\n\t      click: async () => {\n\t        if (tray && !tray.isDestroyed()) {\n\t          await settings.set('tray', false);\n\t          tray.destroy();\n\t        } else {\n\t          await settings.set('tray', true);\n\t          createTray();\n\t        }\n", "        updateContextMenu();\n\t      },\n\t    },\n\t    separator: {\n\t      type: 'separator',\n\t    },\n\t    dapps: DAPPS.map((dapp) => {\n\t      return {\n\t        enabled: Boolean(dapp.url),\n\t        label: dapp.label,\n", "        click: () => shell.openExternal(`http://${dapp.id}.localhost:8888`),\n\t      };\n\t    }),\n\t    quit: {\n\t      label: 'Quit',\n\t      click: () => {\n\t        app.quit();\n\t      },\n\t    },\n\t  };\n", "}\n\tapp.once('ready', async () => {\n\t  // Hide the app from the dock\n\t  if (app.dock && !(await settings.get('dock'))) {\n\t    app.dock.hide();\n\t  }\n\t  if (await settings.get('tray')) {\n\t    createTray();\n\t  }\n\t  updateContextMenu();\n", "});\n\tfunction createTray() {\n\t  // Create a Tray instance with the icon you want to use for the menu bar\n\t  tray = new Tray(getAssetPath('tray@3x.png'));\n\t  tray.on('mouse-down', (_event) => {\n\t    if (mainWindow?.isVisible()) {\n\t      mainWindow?.focus();\n\t    }\n\t  });\n\t}\n", "/**\n\t * Add event listeners...\n\t */\n\tapp.on('window-all-closed', () => {\n\t  // Respect the OSX convention of having the application in memory even\n\t  // after all windows have been closed\n\t  if (process.platform !== 'darwin') {\n\t    app.quit();\n\t  }\n\t});\n", "app\n\t  .whenReady()\n\t  .then(() => {\n\t    createWindow();\n\t    app.on('activate', () => {\n\t      // On macOS it's common to re-create a window in the app when the\n\t      // dock icon is clicked and there are no other windows open.\n\t      if (mainWindow === null) {\n\t        createWindow();\n\t      }\n", "    });\n\t  })\n\t  .catch(logger.error);\n\tipcMain.handle('install-ipfs', downloadIpfs);\n\tipcMain.handle('install-follower', downloadFollower);\n\tipcMain.handle('ipfs-isInstalled', ipfsIsInstalled);\n\tipcMain.handle('follower-isInstalled', followerIsInstalled);\n\tipcMain.handle('ipfs-isRunning', ipfsIsRunning);\n\tipcMain.handle('follower-isRunning', followerPid);\n\tipcMain.handle('run-ipfs', async () => {\n", "  await configureIpfs();\n\t  await ipfsDaemon();\n\t});\n\tipcMain.handle('run-follower', async () => {\n\t  await configureFollower();\n\t  await followerDaemon();\n\t});\n\tipcMain.handle('ipfs-peers', () => ipfs('swarm peers'));\n\tipcMain.handle('ipfs-id', () => followerId());\n\tipcMain.handle('ipfs-repo-stat', () => ipfs('repo stat'));\n", "ipcMain.handle('ipfs-stats-bw', () => ipfs('stats bw'));\n\tipcMain.handle('ipfs-follower-info', () => follower('synthetix info'));\n\tapp.on('will-quit', ipfsKill);\n\tapp.on('will-quit', followerKill);\n\tdownloadIpfs();\n\tipfsDaemon();\n\tconst ipfsCheck = setInterval(ipfsDaemon, 10_000);\n\tapp.on('will-quit', () => clearInterval(ipfsCheck));\n\tdownloadFollower();\n\tfollowerDaemon();\n", "const followerCheck = setInterval(followerDaemon, 10_000);\n\tapp.on('will-quit', () => clearInterval(followerCheck));\n\tipcMain.handle('dapps', async () => {\n\t  return DAPPS.map((dapp) => ({\n\t    ...dapp,\n\t    url: dapp.url ? `http://${dapp.id}.localhost:8888` : null,\n\t  }));\n\t});\n\tipcMain.handle('dapp', async (_event, id: string) => {\n\t  const dapp = DAPPS.find((dapp) => dapp.id === id);\n", "  return dapp && dapp.url ? `http://${dapp.id}.localhost:8888` : null;\n\t});\n\tasync function resolveAllDapps() {\n\t  DAPPS.forEach((dapp) => resolveDapp(dapp).then(updateContextMenu));\n\t}\n\tconst dappsResolver = setInterval(resolveAllDapps, 600_000); // 10 minutes\n\tapp.on('will-quit', () => clearInterval(dappsResolver));\n\twaitForIpfs().then(resolveAllDapps).catch(logger.error);\n\tasync function updateConfig() {\n\t  const config = JSON.parse(\n", "    await ipfs(`cat /ipns/${SYNTHETIX_NODE_APP_CONFIG}`)\n\t  );\n\t  logger.log('App config fetched', config);\n\t  if (config.dapps) {\n\t    const oldDapps = DAPPS.splice(0);\n\t    for (const dapp of config.dapps) {\n\t      const oldDapp = oldDapps.find((d) => d.id === dapp.id);\n\t      if (oldDapp) {\n\t        DAPPS.push(Object.assign({}, oldDapp, dapp));\n\t      } else {\n", "        DAPPS.push(dapp);\n\t      }\n\t    }\n\t    logger.log('Dapps updated', DAPPS);\n\t    await resolveAllDapps();\n\t  }\n\t}\n\tconst dappsUpdater = setInterval(updateConfig, 600_000); // 10 minutes\n\tapp.on('will-quit', () => clearInterval(dappsUpdater));\n\twaitForIpfs().then(updateConfig).catch(logger.error);\n", "ipcMain.handle('peers', async () => fetchPeers());\n\thttp\n\t  .createServer((req, res) => {\n\t    const id = `${req.headers.host}`.replace('.localhost:8888', '');\n\t    const dapp = DAPPS.find((dapp) => dapp.id === id);\n\t    if (dapp && dapp.url) {\n\t      req.headers.host = dapp.url;\n\t      proxy({ host: '127.0.0.1', port: 8080 }, req, res);\n\t      return;\n\t    }\n", "    res.writeHead(404);\n\t    res.end('Not found');\n\t  })\n\t  .listen(8888, '0.0.0.0');\n"]}
{"filename": "src/main/ipfs.ts", "chunked_list": ["import { exec, spawn } from 'child_process';\n\timport https from 'https';\n\timport {\n\t  createReadStream,\n\t  createWriteStream,\n\t  promises as fs,\n\t  rmSync,\n\t} from 'fs';\n\timport { pipeline } from 'stream/promises';\n\timport os from 'os';\n", "import zlib from 'zlib';\n\timport tar from 'tar';\n\timport http from 'http';\n\timport path from 'path';\n\timport type { IpcMainInvokeEvent } from 'electron';\n\timport { getPid, getPidsSync } from './pid';\n\timport { ROOT } from './settings';\n\timport logger from 'electron-log';\n\tconst HOME = os.homedir();\n\t// Change if we ever want IPFS to store its data in non-standart path\n", "const IPFS_PATH = path.join(HOME, '.ipfs');\n\texport function ipfsKill() {\n\t  try {\n\t    getPidsSync('.synthetix/go-ipfs/ipfs').forEach((pid) => {\n\t      logger.log('Killing ipfs', pid);\n\t      process.kill(pid);\n\t    });\n\t    logger.log('Removing .ipfs/repo.lock');\n\t    rmSync(path.join(IPFS_PATH, 'repo.lock'), { recursive: true });\n\t  } catch (_e) {\n", "    // whatever\n\t  }\n\t}\n\texport async function ipfsPid() {\n\t  return await getPid('.synthetix/go-ipfs/ipfs daemon');\n\t}\n\texport async function ipfsIsInstalled() {\n\t  try {\n\t    await fs.access(path.join(ROOT, 'go-ipfs/ipfs'), fs.constants.F_OK);\n\t    return true;\n", "  } catch (_e) {\n\t    return false;\n\t  }\n\t}\n\texport async function ipfsDaemon() {\n\t  const isInstalled = await ipfsIsInstalled();\n\t  if (!isInstalled) {\n\t    return;\n\t  }\n\t  const pid = await getPid('.synthetix/go-ipfs/ipfs daemon');\n", "  if (!pid) {\n\t    await configureIpfs();\n\t    spawn(path.join(ROOT, 'go-ipfs/ipfs'), ['daemon'], {\n\t      stdio: 'inherit',\n\t      detached: true,\n\t      env: { IPFS_PATH },\n\t    });\n\t  }\n\t}\n\texport async function ipfs(arg: string): Promise<string> {\n", "  return new Promise((resolve, reject) => {\n\t    exec(\n\t      `${path.join(ROOT, 'go-ipfs/ipfs')} ${arg}`,\n\t      { encoding: 'utf8', env: { IPFS_PATH } },\n\t      (error, stdout, stderr) => {\n\t        if (error) {\n\t          error.message = `${error.message} (${stderr})`;\n\t          reject(error);\n\t        } else {\n\t          resolve(stdout.trim());\n", "        }\n\t      }\n\t    );\n\t  });\n\t}\n\texport async function getLatestVersion(): Promise<string> {\n\t  return new Promise((resolve, reject) => {\n\t    https\n\t      .get('https://dist.ipfs.tech/go-ipfs/versions', (res) => {\n\t        let data = '';\n", "        res.on('data', (chunk) => {\n\t          data += chunk;\n\t        });\n\t        res.on('end', () => {\n\t          resolve(data.trim().split('\\n').pop() || '');\n\t        });\n\t      })\n\t      .on('error', (err) => {\n\t        reject(err);\n\t      });\n", "  });\n\t}\n\texport async function getInstalledVersion() {\n\t  try {\n\t    const ipfsVersion = await ipfs('--version');\n\t    const [, , installedVersion] = ipfsVersion.split(' ');\n\t    return installedVersion;\n\t  } catch (_error) {\n\t    return null;\n\t  }\n", "}\n\texport async function downloadIpfs(\n\t  _e?: IpcMainInvokeEvent,\n\t  { log = logger.log } = {}\n\t) {\n\t  const arch = os.arch();\n\t  const targetArch = arch === 'x64' ? 'amd64' : 'arm64';\n\t  log('Checking for existing ipfs installation...');\n\t  const latestVersion = await getLatestVersion();\n\t  const latestVersionNumber = latestVersion.slice(1);\n", "  const installedVersion = await getInstalledVersion();\n\t  if (installedVersion === latestVersionNumber) {\n\t    log(`ipfs version ${installedVersion} is already installed.`);\n\t    return;\n\t  }\n\t  if (installedVersion) {\n\t    log(\n\t      `Updating ipfs from version ${installedVersion} to ${latestVersionNumber}`\n\t    );\n\t  } else {\n", "    log(`Installing ipfs version ${latestVersionNumber}`);\n\t  }\n\t  const downloadUrl = `https://dist.ipfs.tech/go-ipfs/${latestVersion}/go-ipfs_${latestVersion}_darwin-${targetArch}.tar.gz`;\n\t  log(`IPFS package: ${downloadUrl}`);\n\t  await fs.rm(path.join(IPFS_PATH, 'config'), { recursive: true });\n\t  await fs.mkdir(ROOT, { recursive: true });\n\t  await new Promise((resolve, reject) => {\n\t    const file = createWriteStream(path.join(ROOT, 'ipfs.tar.gz'));\n\t    https.get(downloadUrl, (response) =>\n\t      pipeline(response, file).then(resolve).catch(reject)\n", "    );\n\t  });\n\t  await new Promise((resolve, reject) => {\n\t    createReadStream(path.join(ROOT, 'ipfs.tar.gz'))\n\t      .pipe(zlib.createGunzip())\n\t      .pipe(tar.extract({ cwd: ROOT }))\n\t      .on('error', reject)\n\t      .on('end', resolve);\n\t  });\n\t  const installedVersionCheck = await getInstalledVersion();\n", "  if (installedVersionCheck) {\n\t    log(`ipfs version ${installedVersionCheck} installed successfully.`);\n\t  } else {\n\t    throw new Error('IPFS installation failed.');\n\t  }\n\t  return installedVersionCheck;\n\t}\n\texport async function configureIpfs({ log = logger.log } = {}) {\n\t  try {\n\t    log(await ipfs('init'));\n", "    log(\n\t      await ipfs(\n\t        'config --json API.HTTPHeaders.Access-Control-Allow-Origin \\'[\"*\"]\\''\n\t      )\n\t    );\n\t    log(\n\t      await ipfs(\n\t        'config --json API.HTTPHeaders.Access-Control-Allow-Methods \\'[\"PUT\", \"POST\", \"GET\"]\\''\n\t      )\n\t    );\n", "    // log(await ipfs('config profile apply lowpower'));\n\t  } catch (_error) {\n\t    // whatever\n\t  }\n\t}\n\texport async function ipfsIsRunning() {\n\t  return new Promise((resolve, _reject) => {\n\t    http\n\t      .get('http://127.0.0.1:5001', (res) => {\n\t        const { statusCode } = res;\n", "        if (statusCode === 404) {\n\t          resolve(true);\n\t        } else {\n\t          resolve(false);\n\t        }\n\t        res.resume();\n\t      })\n\t      .once('error', (_error) => resolve(false));\n\t  });\n\t}\n", "export async function waitForIpfs() {\n\t  let isRunning = await ipfsIsRunning();\n\t  while (!isRunning) {\n\t    await new Promise((resolve) => setTimeout(resolve, 1000));\n\t    isRunning = await ipfsIsRunning();\n\t  }\n\t}\n"]}
{"filename": "src/main/proxy.ts", "chunked_list": ["import http, { IncomingMessage, ServerResponse } from 'http';\n\timport logger from 'electron-log';\n\texport function proxy(\n\t  upstream: {\n\t    host: string;\n\t    port: number;\n\t  },\n\t  req: IncomingMessage,\n\t  res: ServerResponse\n\t) {\n", "  const options = {\n\t    hostname: upstream.host,\n\t    port: upstream.port,\n\t    path: req.url,\n\t    method: req.method,\n\t    headers: req.headers,\n\t  };\n\t  const proxyReq = http.request(options, (proxyRes: IncomingMessage) => {\n\t    res.writeHead(proxyRes.statusCode!, proxyRes.headers);\n\t    proxyRes.pipe(res, { end: true });\n", "  });\n\t  req.pipe(proxyReq, { end: true });\n\t  proxyReq.once('error', (err) => {\n\t    logger.error(`Error in proxy request: ${err.message}`);\n\t    res.writeHead(500, { 'Content-Type': 'text/plain' });\n\t    res.end('Error occurred while processing the request.');\n\t  });\n\t}\n"]}
{"filename": "src/main/peers.ts", "chunked_list": ["import logger from 'electron-log';\n\timport fetch from 'node-fetch';\n\tObject.assign(global, { fetch });\n\texport type Peer = {\n\t  id: string;\n\t  version: string;\n\t};\n\texport async function fetchPeers(): Promise<Peer[]> {\n\t  try {\n\t    const response = await fetch('https://ipfs.synthetix.io/dash/api');\n", "    if (response.ok) {\n\t      const state = (await response.json()) as { peers: Peer[] };\n\t      return state.peers.sort((a, b) => a.id.localeCompare(b.id));\n\t    }\n\t    return [];\n\t  } catch (e) {\n\t    logger.error(e);\n\t    return [];\n\t  }\n\t}\n"]}
{"filename": "src/main/follower.ts", "chunked_list": ["import { exec, spawn } from 'child_process';\n\timport https from 'https';\n\timport { createReadStream, createWriteStream, promises as fs } from 'fs';\n\timport { pipeline } from 'stream/promises';\n\timport os from 'os';\n\timport zlib from 'zlib';\n\timport tar from 'tar';\n\timport path from 'path';\n\timport type { IpcMainInvokeEvent } from 'electron';\n\timport logger from 'electron-log';\n", "import { SYNTHETIX_IPNS } from '../const';\n\timport { ROOT } from './settings';\n\timport { getPid, getPidsSync } from './pid';\n\t// Change if we ever want to store all follower info in a custom folder\n\tconst HOME = os.homedir();\n\tconst IPFS_FOLLOW_PATH = path.join(HOME, '.ipfs-cluster-follow');\n\texport function followerKill() {\n\t  try {\n\t    getPidsSync('.synthetix/ipfs-cluster-follow/ipfs-cluster-follow').forEach(\n\t      (pid) => {\n", "        logger.log('Killing ipfs-cluster-follow', pid);\n\t        process.kill(pid);\n\t      }\n\t    );\n\t  } catch (_e) {\n\t    // whatever\n\t  }\n\t}\n\texport async function followerPid() {\n\t  return await getPid(\n", "    '.synthetix/ipfs-cluster-follow/ipfs-cluster-follow synthetix run'\n\t  );\n\t}\n\texport async function followerIsInstalled() {\n\t  try {\n\t    await fs.access(\n\t      path.join(ROOT, 'ipfs-cluster-follow/ipfs-cluster-follow'),\n\t      fs.constants.F_OK\n\t    );\n\t    return true;\n", "  } catch (_e) {\n\t    return false;\n\t  }\n\t}\n\texport async function followerDaemon() {\n\t  const isInstalled = await followerIsInstalled();\n\t  if (!isInstalled) {\n\t    return;\n\t  }\n\t  const pid = await getPid(\n", "    '.synthetix/ipfs-cluster-follow/ipfs-cluster-follow synthetix run'\n\t  );\n\t  if (!pid) {\n\t    await configureFollower();\n\t    try {\n\t      // Cleanup locks in case of a previous crash\n\t      await Promise.all([\n\t        fs.rm(path.join(IPFS_FOLLOW_PATH, 'synthetix/badger'), {\n\t          recursive: true,\n\t          force: true,\n", "        }),\n\t        fs.rm(path.join(IPFS_FOLLOW_PATH, 'synthetix/api-socket'), {\n\t          recursive: true,\n\t          force: true,\n\t        }),\n\t      ]);\n\t    } catch (e) {\n\t      logger.error(e);\n\t      // whatever\n\t    }\n", "    spawn(\n\t      path.join(ROOT, 'ipfs-cluster-follow/ipfs-cluster-follow'),\n\t      ['synthetix', 'run'],\n\t      {\n\t        stdio: 'inherit',\n\t        detached: true,\n\t        env: { HOME },\n\t      }\n\t    );\n\t  }\n", "}\n\texport async function follower(arg: string): Promise<string> {\n\t  return new Promise((resolve, reject) => {\n\t    exec(\n\t      `${path.join(ROOT, 'ipfs-cluster-follow/ipfs-cluster-follow')} ${arg}`,\n\t      { encoding: 'utf8', env: { HOME } },\n\t      (error, stdout, stderr) => {\n\t        if (error) {\n\t          error.message = `${error.message} (${stderr})`;\n\t          reject(error);\n", "        } else {\n\t          resolve(stdout.trim());\n\t        }\n\t      }\n\t    );\n\t  });\n\t}\n\texport async function getLatestVersion(): Promise<string> {\n\t  return new Promise((resolve, reject) => {\n\t    https\n", "      .get('https://dist.ipfs.tech/ipfs-cluster-follow/versions', (res) => {\n\t        let data = '';\n\t        res.on('data', (chunk) => {\n\t          data += chunk;\n\t        });\n\t        res.on('end', () => {\n\t          resolve(data.trim().split('\\n').pop() || '');\n\t        });\n\t      })\n\t      .on('error', (err) => {\n", "        reject(err);\n\t      });\n\t  });\n\t}\n\texport async function getInstalledVersion() {\n\t  try {\n\t    const version = await follower('--version');\n\t    const [, , installedVersion] = version.split(' ');\n\t    return installedVersion;\n\t  } catch (_error) {\n", "    return null;\n\t  }\n\t}\n\texport async function downloadFollower(\n\t  _e?: IpcMainInvokeEvent,\n\t  { log = logger.log } = {}\n\t) {\n\t  const arch = os.arch();\n\t  const targetArch = arch === 'x64' ? 'amd64' : 'arm64';\n\t  log('Checking for existing ipfs-cluster-follow installation...');\n", "  const latestVersion = await getLatestVersion();\n\t  const latestVersionNumber = latestVersion.slice(1);\n\t  const installedVersion = await getInstalledVersion();\n\t  if (installedVersion === latestVersionNumber) {\n\t    log(\n\t      `ipfs-cluster-follow version ${installedVersion} is already installed.`\n\t    );\n\t    return;\n\t  }\n\t  if (installedVersion) {\n", "    log(\n\t      `Updating ipfs-cluster-follow from version ${installedVersion} to ${latestVersionNumber}`\n\t    );\n\t  } else {\n\t    log(`Installing ipfs-cluster-follow version ${latestVersionNumber}`);\n\t  }\n\t  const downloadUrl = `https://dist.ipfs.tech/ipfs-cluster-follow/${latestVersion}/ipfs-cluster-follow_${latestVersion}_darwin-${targetArch}.tar.gz`;\n\t  log(`ipfs-cluster-follow package: ${downloadUrl}`);\n\t  await fs.mkdir(ROOT, { recursive: true });\n\t  await new Promise((resolve, reject) => {\n", "    const file = createWriteStream(\n\t      path.join(ROOT, 'ipfs-cluster-follow.tar.gz')\n\t    );\n\t    https.get(downloadUrl, (response) =>\n\t      pipeline(response, file).then(resolve).catch(reject)\n\t    );\n\t  });\n\t  await new Promise((resolve, reject) => {\n\t    createReadStream(path.join(ROOT, 'ipfs-cluster-follow.tar.gz'))\n\t      .pipe(zlib.createGunzip())\n", "      .pipe(tar.extract({ cwd: ROOT }))\n\t      .on('error', reject)\n\t      .on('end', resolve);\n\t  });\n\t  const installedVersionCheck = await getInstalledVersion();\n\t  if (installedVersionCheck) {\n\t    log(\n\t      `ipfs-cluster-follow version ${installedVersionCheck} installed successfully.`\n\t    );\n\t  } else {\n", "    throw new Error('ipfs-cluster-follow installation failed.');\n\t  }\n\t  return installedVersionCheck;\n\t}\n\texport async function isConfigured() {\n\t  try {\n\t    const service = await fs.readFile(\n\t      path.join(IPFS_FOLLOW_PATH, 'synthetix/service.json'),\n\t      'utf8'\n\t    );\n", "    return service.includes(SYNTHETIX_IPNS);\n\t  } catch (_error) {\n\t    return false;\n\t  }\n\t}\n\texport async function followerId() {\n\t  try {\n\t    const identity = JSON.parse(\n\t      await fs.readFile(\n\t        path.join(IPFS_FOLLOW_PATH, 'synthetix/identity.json'),\n", "        'utf8'\n\t      )\n\t    );\n\t    return identity.id;\n\t  } catch (_error) {\n\t    return '';\n\t  }\n\t}\n\texport async function configureFollower({ log = logger.log } = {}) {\n\t  if (await isConfigured()) {\n", "    return;\n\t  }\n\t  try {\n\t    log(\n\t      await follower(\n\t        `synthetix init \"http://127.0.0.1:8080/ipns/${SYNTHETIX_IPNS}\"`\n\t      )\n\t    );\n\t  } catch (_error) {\n\t    // ignore\n", "  }\n\t}\n"]}
{"filename": "src/main/pid.ts", "chunked_list": ["import { exec, execSync } from 'child_process';\n\texport function extractPids(processes: string): number[] {\n\t  return processes\n\t    .trim()\n\t    .split('\\n')\n\t    .filter((line) => !line.includes('grep'))\n\t    .map((line) => {\n\t      const [raw] = line.trim().split(' ');\n\t      return parseInt(raw, 10);\n\t    });\n", "}\n\texport function findPid(processes: string): number | undefined {\n\t  const [ipfsProcess] = extractPids(processes);\n\t  return ipfsProcess;\n\t}\n\texport function getPidSync(search: string): number | undefined {\n\t  try {\n\t    const processes = execSync(`ps -ax | grep \"${search}\"`, {\n\t      encoding: 'utf8',\n\t    });\n", "    return findPid(processes);\n\t  } catch (_e) {\n\t    // whatever\n\t  }\n\t}\n\texport function getPidsSync(search: string): number[] {\n\t  try {\n\t    const processes = execSync(`ps -ax | grep '${search}'`, {\n\t      encoding: 'utf8',\n\t    });\n", "    return extractPids(processes);\n\t  } catch (_e) {\n\t    return [];\n\t  }\n\t}\n\tfunction execCommand(command: string): Promise<string> {\n\t  return new Promise((resolve, reject) => {\n\t    exec(command, { encoding: 'utf8' }, (error, stdout, stderr) => {\n\t      if (error) {\n\t        error.message = `${error.message} (${stderr})`;\n", "        reject(error);\n\t      } else {\n\t        resolve(stdout.trim());\n\t      }\n\t    });\n\t  });\n\t}\n\texport async function getPid(search: string): Promise<number | undefined> {\n\t  try {\n\t    const processes = await execCommand(`ps -ax | grep '${search}'`);\n", "    return findPid(processes);\n\t  } catch (_e) {\n\t    // whatever\n\t  }\n\t}\n"]}
{"filename": "src/main/util.ts", "chunked_list": ["import { URL } from 'url';\n\timport path from 'path';\n\texport function resolveHtmlPath(htmlFileName: string) {\n\t  if (process.env.NODE_ENV === 'development') {\n\t    const port = process.env.PORT || 1212;\n\t    const url = new URL(`http://localhost:${port}`);\n\t    url.pathname = htmlFileName;\n\t    return url.href;\n\t  }\n\t  return `file://${path.resolve(__dirname, '../renderer/', htmlFileName)}`;\n", "}\n"]}
{"filename": "src/main/preload.ts", "chunked_list": ["// Disable no-unused-vars, broken for spread args\n\timport type { IpcRendererEvent } from 'electron';\n\t/* eslint no-unused-vars: off */\n\timport { contextBridge, ipcRenderer } from 'electron';\n\tconst electronHandler = {\n\t  ipcRenderer: {\n\t    invoke: (func: string, ...args: any[]) => ipcRenderer.invoke(func, ...args),\n\t    send: (channel: string, ...args: any[]) => {\n\t      ipcRenderer.send(channel, ...args);\n\t    },\n", "    on: (\n\t      channel: string,\n\t      listener: (event: IpcRendererEvent, ...args: any[]) => void\n\t    ) => {\n\t      ipcRenderer.on(channel, listener);\n\t    },\n\t    removeListener: (\n\t      channel: string,\n\t      listener: (event: IpcRendererEvent, ...args: any[]) => void\n\t    ) => {\n", "      ipcRenderer.removeListener(channel, listener);\n\t    },\n\t  },\n\t};\n\tcontextBridge.exposeInMainWorld('electron', electronHandler);\n\texport type ElectronHandler = typeof electronHandler;\n"]}
{"filename": "src/main/settings.ts", "chunked_list": ["import { promises as fs } from 'fs';\n\timport os from 'os';\n\timport path from 'path';\n\texport const ROOT = path.join(os.homedir(), '.synthetix');\n\tconst DEFAULTS = Object.freeze({\n\t  tray: true,\n\t  dock: true,\n\t});\n\texport async function read() {\n\t  try {\n", "    return JSON.parse(\n\t      await fs.readFile(path.join(ROOT, 'setting.json'), 'utf8')\n\t    );\n\t  } catch (_error) {\n\t    return DEFAULTS;\n\t  }\n\t}\n\texport async function write(settings: typeof DEFAULTS) {\n\t  try {\n\t    await fs.writeFile(\n", "      path.join(ROOT, 'setting.json'),\n\t      JSON.stringify(settings, null, 2),\n\t      'utf8'\n\t    );\n\t  } catch (_error) {\n\t    // whatever\n\t  }\n\t  return settings;\n\t}\n\texport async function get(key: string) {\n", "  const all = await read();\n\t  return all[key];\n\t}\n\texport async function set(key: string, value: boolean) {\n\t  const all = await read();\n\t  return await write({ ...all, [key]: value });\n\t}\n"]}
