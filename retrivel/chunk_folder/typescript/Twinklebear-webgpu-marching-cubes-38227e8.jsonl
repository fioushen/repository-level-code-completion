{"filename": "src/marching_cubes.ts", "chunked_list": ["import {ExclusiveScan} from \"./exclusive_scan\";\n\timport {MC_CASE_TABLE} from \"./mc_case_table\";\n\timport {StreamCompactIDs} from \"./stream_compact_ids\";\n\timport {Volume} from \"./volume\";\n\timport {compileShader} from \"./util\";\n\timport computeVoxelValuesWgsl from \"./compute_voxel_values.wgsl\";\n\timport markActiveVoxelsWgsl from \"./mark_active_voxel.wgsl\";\n\timport computeNumVertsWgsl from \"./compute_num_verts.wgsl\";\n\timport computeVerticesWgsl from \"./compute_vertices.wgsl\";\n\timport {PushConstants} from \"./push_constant_builder\";\n", "export class MarchingCubesResult\n\t{\n\t    count: number;\n\t    buffer: GPUBuffer;\n\t    constructor(count: number, buffer: GPUBuffer)\n\t    {\n\t        this.count = count;\n\t        this.buffer = buffer;\n\t    }\n\t};\n", "/* Marching Cubes execution has 5 steps\n\t * 1. Compute active voxels\n\t * 2. Stream compact active voxel IDs\n\t *    - Scan is done on isActive buffer to get compaction offsets\n\t * 3. Compute # of vertices output by active voxels\n\t * 4. Scan # vertices buffer to produce vertex output offsets\n\t * 5. Compute and output vertices\n\t */\n\texport class MarchingCubes\n\t{\n", "    #device: GPUDevice;\n\t    #volume: Volume;\n\t    #exclusiveScan: ExclusiveScan;\n\t    #streamCompactIds: StreamCompactIDs;\n\t    // Compute pipelines for each stage of the compute \n\t    #markActiveVoxelPipeline: GPUComputePipeline;\n\t    #computeNumVertsPipeline: GPUComputePipeline;\n\t    #computeVerticesPipeline: GPUComputePipeline;\n\t    #triCaseTable: GPUBuffer;\n\t    #volumeInfo: GPUBuffer;\n", "    #voxelActive: GPUBuffer;\n\t    #volumeInfoBG: GPUBindGroup;\n\t    #markActiveBG: GPUBindGroup;\n\t    // Timestamp queries and query output buffer\n\t    #timestampQuerySupport: boolean;\n\t    #timestampQuerySet: GPUQuerySet;\n\t    #timestampBuffer: GPUBuffer;\n\t    #timestampReadbackBuffer: GPUBuffer;\n\t    // Performance stats\n\t    computeActiveVoxelsTime = 0;\n", "    markActiveVoxelsKernelTime = -1;\n\t    computeActiveVoxelsScanTime = 0;\n\t    computeActiveVoxelsCompactTime = 0;\n\t    computeVertexOffsetsTime = 0;\n\t    computeNumVertsKernelTime = -1;\n\t    computeVertexOffsetsScanTime = 0;\n\t    computeVerticesTime = 0;\n\t    computeVerticesKernelTime = -1;\n\t    private constructor(volume: Volume, device: GPUDevice)\n\t    {\n", "        this.#device = device;\n\t        this.#volume = volume;\n\t        this.#timestampQuerySupport = device.features.has(\"timestamp-query\");\n\t    }\n\t    static async create(volume: Volume, device: GPUDevice)\n\t    {\n\t        let mc = new MarchingCubes(volume, device);\n\t        mc.#exclusiveScan = await ExclusiveScan.create(device);\n\t        mc.#streamCompactIds = await StreamCompactIDs.create(device);\n\t        // Upload the case table\n", "        // TODO: Can optimize the size of this buffer to store each case value\n\t        // as an int8, but since WGSL doesn't have an i8 type we then need some\n\t        // bit unpacking in the shader to do that. Will add this after the initial\n\t        // implementation.\n\t        mc.#triCaseTable = device.createBuffer({\n\t            size: MC_CASE_TABLE.byteLength,\n\t            usage: GPUBufferUsage.STORAGE,\n\t            mappedAtCreation: true,\n\t        });\n\t        new Int32Array(mc.#triCaseTable.getMappedRange()).set(MC_CASE_TABLE);\n", "        mc.#triCaseTable.unmap();\n\t        mc.#volumeInfo = device.createBuffer({\n\t            size: 8 * 4,\n\t            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t            mappedAtCreation: true\n\t        });\n\t        new Uint32Array(mc.#volumeInfo.getMappedRange()).set(volume.dims);\n\t        mc.#volumeInfo.unmap();\n\t        // Allocate the voxel active buffer. This buffer's size is fixed for\n\t        // the entire pipeline, we need to store a flag for each voxel if it's\n", "        // active or not. We'll run a scan on this buffer so it also needs to be\n\t        // aligned to the scan size.\n\t        mc.#voxelActive = device.createBuffer({\n\t            size: mc.#exclusiveScan.getAlignedSize(volume.dualGridNumVoxels) * 4,\n\t            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n\t        });\n\t        // Compile shaders for our compute kernels\n\t        let markActiveVoxel = await compileShader(device,\n\t            computeVoxelValuesWgsl + \"\\n\" + markActiveVoxelsWgsl, \"mark_active_voxel.wgsl\");\n\t        let computeNumVerts = await compileShader(device,\n", "            computeVoxelValuesWgsl + \"\\n\" + computeNumVertsWgsl, \"compute_num_verts.wgsl\");\n\t        let computeVertices = await compileShader(device,\n\t            computeVoxelValuesWgsl + \"\\n\" + computeVerticesWgsl, \"compute_vertices.wgsl\");\n\t        // Bind group layout for the volume parameters, shared by all pipelines in group 0\n\t        let volumeInfoBGLayout = device.createBindGroupLayout({\n\t            entries: [\n\t                {\n\t                    binding: 0,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    texture: {\n", "                        viewDimension: \"3d\",\n\t                    }\n\t                },\n\t                {\n\t                    binding: 1,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"uniform\"\n\t                    }\n\t                }\n", "            ]\n\t        });\n\t        mc.#volumeInfoBG = device.createBindGroup({\n\t            layout: volumeInfoBGLayout,\n\t            entries: [\n\t                {\n\t                    binding: 0,\n\t                    resource: mc.#volume.texture.createView(),\n\t                },\n\t                {\n", "                    binding: 1,\n\t                    resource: {\n\t                        buffer: mc.#volumeInfo,\n\t                    }\n\t                }\n\t            ]\n\t        });\n\t        let markActiveVoxelBGLayout = device.createBindGroupLayout({\n\t            entries: [\n\t                {\n", "                    binding: 0,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n\t                    }\n\t                }\n\t            ]\n\t        });\n\t        mc.#markActiveBG = device.createBindGroup({\n\t            layout: markActiveVoxelBGLayout,\n", "            entries: [\n\t                {\n\t                    binding: 0,\n\t                    resource: {\n\t                        buffer: mc.#voxelActive,\n\t                    }\n\t                }\n\t            ]\n\t        });\n\t        let computeNumVertsBGLayout = device.createBindGroupLayout({\n", "            entries: [\n\t                {\n\t                    binding: 0,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"read-only-storage\",\n\t                    }\n\t                },\n\t                {\n\t                    binding: 1,\n", "                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n\t                    }\n\t                },\n\t                {\n\t                    binding: 2,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n", "                    }\n\t                }\n\t            ]\n\t        });\n\t        let computeVerticesBGLayout = device.createBindGroupLayout({\n\t            entries: [\n\t                {\n\t                    binding: 0,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n", "                        type: \"read-only-storage\",\n\t                    }\n\t                },\n\t                {\n\t                    binding: 1,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n\t                    }\n\t                },\n", "                {\n\t                    binding: 2,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n\t                    }\n\t                },\n\t                {\n\t                    binding: 3,\n\t                    visibility: GPUShaderStage.COMPUTE,\n", "                    buffer: {\n\t                        type: \"storage\",\n\t                    }\n\t                }\n\t            ]\n\t        });\n\t        // Push constants BG layout\n\t        let pushConstantsBGLayout = device.createBindGroupLayout({\n\t            entries: [\n\t                {\n", "                    binding: 0,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"uniform\",\n\t                        hasDynamicOffset: true\n\t                    }\n\t                }\n\t            ]\n\t        });\n\t        // Create pipelines\n", "        mc.#markActiveVoxelPipeline = device.createComputePipeline({\n\t            layout: device.createPipelineLayout(\n\t                {bindGroupLayouts: [volumeInfoBGLayout, markActiveVoxelBGLayout]}),\n\t            compute: {\n\t                module: markActiveVoxel,\n\t                entryPoint: \"main\"\n\t            }\n\t        });\n\t        mc.#computeNumVertsPipeline = device.createComputePipeline({\n\t            layout: device.createPipelineLayout({\n", "                bindGroupLayouts: [\n\t                    volumeInfoBGLayout,\n\t                    computeNumVertsBGLayout,\n\t                    pushConstantsBGLayout\n\t                ]\n\t            }),\n\t            compute: {\n\t                module: computeNumVerts,\n\t                entryPoint: \"main\"\n\t            }\n", "        });\n\t        mc.#computeVerticesPipeline = device.createComputePipeline({\n\t            layout: device.createPipelineLayout({\n\t                bindGroupLayouts: [\n\t                    volumeInfoBGLayout,\n\t                    computeVerticesBGLayout,\n\t                    pushConstantsBGLayout\n\t                ]\n\t            }),\n\t            compute: {\n", "                module: computeVertices,\n\t                entryPoint: \"main\"\n\t            }\n\t        });\n\t        if (mc.#timestampQuerySupport) {\n\t            // We store 6 timestamps, for the start/end of each compute pass we run\n\t            mc.#timestampQuerySet = device.createQuerySet({\n\t                type: \"timestamp\",\n\t                count: 6\n\t            });\n", "            mc.#timestampBuffer = device.createBuffer({\n\t                size: 6 * 8,\n\t                usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t            });\n\t            mc.#timestampReadbackBuffer = device.createBuffer({\n\t                size: mc.#timestampBuffer.size,\n\t                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t            });\n\t        }\n\t        return mc;\n", "    }\n\t    // Computes the surface for the provided isovalue, returning the number of triangles\n\t    // in the surface and the GPUBuffer containing their vertices\n\t    async computeSurface(isovalue: number)\n\t    {\n\t        this.uploadIsovalue(isovalue);\n\t        let start = performance.now();\n\t        let activeVoxels = await this.computeActiveVoxels();\n\t        let end = performance.now();\n\t        this.computeActiveVoxelsTime = end - start;\n", "        if (activeVoxels.count == 0) {\n\t            return new MarchingCubesResult(0, null);\n\t        }\n\t        start = performance.now();\n\t        let vertexOffsets = await this.computeVertexOffsets(activeVoxels);\n\t        end = performance.now();\n\t        this.computeVertexOffsetsTime = end - start;\n\t        if (vertexOffsets.count == 0) {\n\t            return new MarchingCubesResult(0, null);\n\t        }\n", "        start = performance.now();\n\t        let vertices = await this.computeVertices(activeVoxels, vertexOffsets);\n\t        end = performance.now();\n\t        this.computeVerticesTime = end - start;\n\t        activeVoxels.buffer.destroy();\n\t        vertexOffsets.buffer.destroy();\n\t        // Map back the timestamps and get performance statistics\n\t        if (this.#timestampQuerySupport) {\n\t            await this.#timestampReadbackBuffer.mapAsync(GPUMapMode.READ);\n\t            let times = new BigUint64Array(this.#timestampReadbackBuffer.getMappedRange());\n", "            // Timestamps are in nanoseconds\n\t            this.markActiveVoxelsKernelTime = Number(times[1] - times[0]) * 1.0e-6;\n\t            this.computeNumVertsKernelTime = Number(times[3] - times[2]) * 1.0e-6;\n\t            this.computeVerticesKernelTime = Number(times[5] - times[4]) * 1.0e-6;\n\t            this.#timestampReadbackBuffer.unmap();\n\t        }\n\t        return new MarchingCubesResult(vertexOffsets.count, vertices);\n\t    }\n\t    private uploadIsovalue(isovalue: number)\n\t    {\n", "        let uploadIsovalue = this.#device.createBuffer({\n\t            size: 4,\n\t            usage: GPUBufferUsage.COPY_SRC,\n\t            mappedAtCreation: true\n\t        });\n\t        new Float32Array(uploadIsovalue.getMappedRange()).set([isovalue]);\n\t        uploadIsovalue.unmap();\n\t        var commandEncoder = this.#device.createCommandEncoder();\n\t        commandEncoder.copyBufferToBuffer(uploadIsovalue, 0, this.#volumeInfo, 16, 4);\n\t        this.#device.queue.submit([commandEncoder.finish()]);\n", "    }\n\t    private async computeActiveVoxels()\n\t    {\n\t        let dispatchSize = [\n\t            Math.ceil(this.#volume.dualGridDims[0] / 4),\n\t            Math.ceil(this.#volume.dualGridDims[1] / 4),\n\t            Math.ceil(this.#volume.dualGridDims[2] / 2)\n\t        ];\n\t        let activeVoxelOffsets = this.#device.createBuffer({\n\t            size: this.#voxelActive.size,\n", "            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE\n\t        });\n\t        var commandEncoder = this.#device.createCommandEncoder();\n\t        if (this.#timestampQuerySupport) {\n\t            commandEncoder.writeTimestamp(this.#timestampQuerySet, 0);\n\t        }\n\t        var pass = commandEncoder.beginComputePass();\n\t        pass.setPipeline(this.#markActiveVoxelPipeline);\n\t        pass.setBindGroup(0, this.#volumeInfoBG);\n\t        pass.setBindGroup(1, this.#markActiveBG);\n", "        pass.dispatchWorkgroups(dispatchSize[0], dispatchSize[1], dispatchSize[2]);\n\t        pass.end();\n\t        if (this.#timestampQuerySupport) {\n\t            commandEncoder.writeTimestamp(this.#timestampQuerySet, 1);\n\t        }\n\t        // Copy the active voxel info to the offsets buffer that we're going to scan,\n\t        // since scan happens in place\n\t        commandEncoder.copyBufferToBuffer(this.#voxelActive, 0, activeVoxelOffsets, 0, activeVoxelOffsets.size);\n\t        this.#device.queue.submit([commandEncoder.finish()]);\n\t        await this.#device.queue.onSubmittedWorkDone();\n", "        let start = performance.now();\n\t        // Scan the active voxel buffer to get offsets to output the active voxel IDs too\n\t        let nActive = await this.#exclusiveScan.scan(activeVoxelOffsets, this.#volume.dualGridNumVoxels);\n\t        let end = performance.now();\n\t        this.computeActiveVoxelsScanTime = end - start;\n\t        if (nActive == 0) {\n\t            return new MarchingCubesResult(0, null);\n\t        }\n\t        let activeVoxelIDs = this.#device.createBuffer({\n\t            size: nActive * 4,\n", "            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\n\t        });\n\t        start = performance.now();\n\t        // Output the compact buffer of active voxel IDs\n\t        await this.#streamCompactIds.compactActiveIDs(this.#voxelActive,\n\t            activeVoxelOffsets,\n\t            activeVoxelIDs,\n\t            this.#volume.dualGridNumVoxels);\n\t        end = performance.now();\n\t        this.computeActiveVoxelsCompactTime = end - start;\n", "        activeVoxelOffsets.destroy();\n\t        return new MarchingCubesResult(nActive, activeVoxelIDs);\n\t    }\n\t    private async computeVertexOffsets(activeVoxels: MarchingCubesResult)\n\t    {\n\t        let vertexOffsets = this.#device.createBuffer({\n\t            size: this.#exclusiveScan.getAlignedSize(activeVoxels.count) * 4,\n\t            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC\n\t        });\n\t        let bindGroup = this.#device.createBindGroup({\n", "            layout: this.#computeNumVertsPipeline.getBindGroupLayout(1),\n\t            entries: [\n\t                {\n\t                    binding: 0,\n\t                    resource: {\n\t                        buffer: this.#triCaseTable\n\t                    }\n\t                },\n\t                {\n\t                    binding: 1,\n", "                    resource: {\n\t                        buffer: activeVoxels.buffer,\n\t                    }\n\t                },\n\t                {\n\t                    binding: 2,\n\t                    resource: {\n\t                        buffer: vertexOffsets\n\t                    }\n\t                }\n", "            ]\n\t        });\n\t        let pushConstantsArg = new Uint32Array([activeVoxels.count]);\n\t        let pushConstants = new PushConstants(\n\t            this.#device, Math.ceil(activeVoxels.count / 32), pushConstantsArg.buffer);\n\t        let pushConstantsBG = this.#device.createBindGroup({\n\t            layout: this.#computeNumVertsPipeline.getBindGroupLayout(2),\n\t            entries: [{\n\t                binding: 0,\n\t                resource: {\n", "                    buffer: pushConstants.pushConstantsBuffer,\n\t                    size: 12,\n\t                }\n\t            }]\n\t        });\n\t        let commandEncoder = this.#device.createCommandEncoder();\n\t        if (this.#timestampQuerySupport) {\n\t            commandEncoder.writeTimestamp(this.#timestampQuerySet, 2);\n\t        }\n\t        let pass = commandEncoder.beginComputePass();\n", "        pass.setPipeline(this.#computeNumVertsPipeline);\n\t        pass.setBindGroup(0, this.#volumeInfoBG);\n\t        pass.setBindGroup(1, bindGroup);\n\t        for (let i = 0; i < pushConstants.numDispatches(); ++i) {\n\t            pass.setBindGroup(2, pushConstantsBG, [i * pushConstants.stride]);\n\t            pass.dispatchWorkgroups(pushConstants.dispatchSize(i), 1, 1);\n\t        }\n\t        pass.end();\n\t        if (this.#timestampQuerySupport) {\n\t            commandEncoder.writeTimestamp(this.#timestampQuerySet, 3);\n", "        }\n\t        this.#device.queue.submit([commandEncoder.finish()]);\n\t        await this.#device.queue.onSubmittedWorkDone();\n\t        let start = performance.now();\n\t        let nVertices = await this.#exclusiveScan.scan(vertexOffsets, activeVoxels.count);\n\t        let end = performance.now();\n\t        this.computeVertexOffsetsScanTime = end - start;\n\t        return new MarchingCubesResult(nVertices, vertexOffsets);\n\t    }\n\t    private async computeVertices(activeVoxels: MarchingCubesResult, vertexOffsets: MarchingCubesResult)\n", "    {\n\t        // We'll output a float4 per vertex\n\t        let vertices = this.#device.createBuffer({\n\t            size: vertexOffsets.count * 4 * 4,\n\t            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC\n\t        });\n\t        let bindGroup = this.#device.createBindGroup({\n\t            layout: this.#computeVerticesPipeline.getBindGroupLayout(1),\n\t            entries: [\n\t                {\n", "                    binding: 0,\n\t                    resource: {\n\t                        buffer: this.#triCaseTable\n\t                    }\n\t                },\n\t                {\n\t                    binding: 1,\n\t                    resource: {\n\t                        buffer: activeVoxels.buffer,\n\t                    }\n", "                },\n\t                {\n\t                    binding: 2,\n\t                    resource: {\n\t                        buffer: vertexOffsets.buffer\n\t                    }\n\t                },\n\t                {\n\t                    binding: 3,\n\t                    resource: {\n", "                        buffer: vertices\n\t                    }\n\t                }\n\t            ]\n\t        });\n\t        let pushConstantsArg = new Uint32Array([activeVoxels.count]);\n\t        let pushConstants = new PushConstants(\n\t            this.#device, Math.ceil(activeVoxels.count / 32), pushConstantsArg.buffer);\n\t        let pushConstantsBG = this.#device.createBindGroup({\n\t            layout: this.#computeNumVertsPipeline.getBindGroupLayout(2),\n", "            entries: [{\n\t                binding: 0,\n\t                resource: {\n\t                    buffer: pushConstants.pushConstantsBuffer,\n\t                    size: 12,\n\t                }\n\t            }]\n\t        });\n\t        let commandEncoder = this.#device.createCommandEncoder();\n\t        if (this.#timestampQuerySupport) {\n", "            commandEncoder.writeTimestamp(this.#timestampQuerySet, 4);\n\t        }\n\t        let pass = commandEncoder.beginComputePass();\n\t        pass.setPipeline(this.#computeVerticesPipeline);\n\t        pass.setBindGroup(0, this.#volumeInfoBG);\n\t        pass.setBindGroup(1, bindGroup);\n\t        for (let i = 0; i < pushConstants.numDispatches(); ++i) {\n\t            pass.setBindGroup(2, pushConstantsBG, [i * pushConstants.stride]);\n\t            pass.dispatchWorkgroups(pushConstants.dispatchSize(i), 1, 1);\n\t        }\n", "        pass.end();\n\t        if (this.#timestampQuerySupport) {\n\t            commandEncoder.writeTimestamp(this.#timestampQuerySet, 5);\n\t            // This is our last compute pass to compute the surface, so resolve the\n\t            // timestamp queries now as well\n\t            commandEncoder.resolveQuerySet(this.#timestampQuerySet, 0, 6, this.#timestampBuffer, 0);\n\t            commandEncoder.copyBufferToBuffer(this.#timestampBuffer,\n\t                0,\n\t                this.#timestampReadbackBuffer,\n\t                0,\n", "                this.#timestampBuffer.size);\n\t        }\n\t        this.#device.queue.submit([commandEncoder.finish()]);\n\t        await this.#device.queue.onSubmittedWorkDone();\n\t        return vertices;\n\t    }\n\t};\n"]}
{"filename": "src/mc_case_table.ts", "chunked_list": ["// Edge and triangle tables for the cases of marching cubes\n\t// From http://paulbourke.net/geometry/polygonise/ and\n\t// https://graphics.stanford.edu/~mdfisher/MarchingCubes.html\n\texport const MC_CASE_TABLE = new Int32Array([\n\t    -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 8, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    1, 9, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    8, 1, 9, 8, 3, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    2, 10, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 8, 3, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "    9, 2, 10, 9, 0, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    3, 2, 10, 3, 10, 8, 8, 10, 9, -1, 0, 0, 0, 0, 0, 0,\n\t    2, 3, 11, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    11, 0, 8, 11, 2, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    1, 9, 0, 2, 3, 11, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    2, 1, 9, 2, 9, 11, 11, 9, 8, -1, 0, 0, 0, 0, 0, 0,\n\t    3, 10, 1, 3, 11, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    1, 0, 8, 1, 8, 10, 10, 8, 11, -1, 0, 0, 0, 0, 0, 0,\n\t    0, 3, 11, 0, 11, 9, 9, 11, 10, -1, 0, 0, 0, 0, 0, 0,\n\t    11, 10, 9, 11, 9, 8, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "    4, 7, 8, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    4, 3, 0, 4, 7, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    4, 7, 8, 9, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    9, 4, 7, 9, 7, 1, 1, 7, 3, -1, 0, 0, 0, 0, 0, 0,\n\t    4, 7, 8, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    4, 3, 0, 4, 7, 3, 2, 10, 1, -1, 0, 0, 0, 0, 0, 0,\n\t    2, 9, 0, 2, 10, 9, 4, 7, 8, -1, 0, 0, 0, 0, 0, 0,\n\t    3, 2, 7, 7, 9, 4, 7, 2, 9, 9, 2, 10, -1, 0, 0, 0,\n\t    8, 4, 7, 3, 11, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    7, 11, 2, 7, 2, 4, 4, 2, 0, -1, 0, 0, 0, 0, 0, 0,\n", "    2, 3, 11, 1, 9, 0, 8, 4, 7, -1, 0, 0, 0, 0, 0, 0,\n\t    2, 1, 9, 2, 9, 4, 2, 4, 11, 11, 4, 7, -1, 0, 0, 0,\n\t    10, 3, 11, 10, 1, 3, 8, 4, 7, -1, 0, 0, 0, 0, 0, 0,\n\t    4, 7, 0, 0, 10, 1, 7, 10, 0, 7, 11, 10, -1, 0, 0, 0,\n\t    8, 4, 7, 0, 3, 11, 0, 11, 9, 9, 11, 10, -1, 0, 0, 0,\n\t    7, 9, 4, 7, 11, 9, 9, 11, 10, -1, 0, 0, 0, 0, 0, 0,\n\t    4, 9, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    8, 3, 0, 4, 9, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 5, 4, 0, 1, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    4, 8, 3, 4, 3, 5, 5, 3, 1, -1, 0, 0, 0, 0, 0, 0,\n", "    1, 2, 10, 9, 5, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    4, 9, 5, 8, 3, 0, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0,\n\t    10, 5, 4, 10, 4, 2, 2, 4, 0, -1, 0, 0, 0, 0, 0, 0,\n\t    4, 8, 3, 4, 3, 2, 4, 2, 5, 5, 2, 10, -1, 0, 0, 0,\n\t    2, 3, 11, 5, 4, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    11, 0, 8, 11, 2, 0, 9, 5, 4, -1, 0, 0, 0, 0, 0, 0,\n\t    5, 0, 1, 5, 4, 0, 3, 11, 2, -1, 0, 0, 0, 0, 0, 0,\n\t    11, 2, 8, 8, 5, 4, 2, 5, 8, 2, 1, 5, -1, 0, 0, 0,\n\t    3, 10, 1, 3, 11, 10, 5, 4, 9, -1, 0, 0, 0, 0, 0, 0,\n\t    9, 5, 4, 1, 0, 8, 1, 8, 10, 10, 8, 11, -1, 0, 0, 0,\n", "    10, 5, 11, 11, 0, 3, 11, 5, 0, 0, 5, 4, -1, 0, 0, 0,\n\t    4, 10, 5, 4, 8, 10, 10, 8, 11, -1, 0, 0, 0, 0, 0, 0,\n\t    7, 9, 5, 7, 8, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 9, 5, 0, 5, 3, 3, 5, 7, -1, 0, 0, 0, 0, 0, 0,\n\t    8, 0, 1, 8, 1, 7, 7, 1, 5, -1, 0, 0, 0, 0, 0, 0,\n\t    3, 1, 5, 3, 5, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    7, 9, 5, 7, 8, 9, 1, 2, 10, -1, 0, 0, 0, 0, 0, 0,\n\t    1, 2, 10, 0, 9, 5, 0, 5, 3, 3, 5, 7, -1, 0, 0, 0,\n\t    7, 8, 5, 5, 2, 10, 8, 2, 5, 8, 0, 2, -1, 0, 0, 0,\n\t    10, 3, 2, 10, 5, 3, 3, 5, 7, -1, 0, 0, 0, 0, 0, 0,\n", "    9, 7, 8, 9, 5, 7, 11, 2, 3, -1, 0, 0, 0, 0, 0, 0,\n\t    0, 9, 2, 2, 7, 11, 2, 9, 7, 7, 9, 5, -1, 0, 0, 0,\n\t    3, 11, 2, 8, 0, 1, 8, 1, 7, 7, 1, 5, -1, 0, 0, 0,\n\t    2, 7, 11, 2, 1, 7, 7, 1, 5, -1, 0, 0, 0, 0, 0, 0,\n\t    11, 1, 3, 11, 10, 1, 7, 8, 9, 7, 9, 5, -1, 0, 0, 0,\n\t    11, 10, 1, 11, 1, 7, 7, 1, 0, 7, 0, 9, 7, 9, 5, -1,\n\t    5, 7, 8, 5, 8, 10, 10, 8, 0, 10, 0, 3, 10, 3, 11, -1,\n\t    11, 10, 5, 11, 5, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    10, 6, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 8, 3, 10, 6, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "    9, 0, 1, 5, 10, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    8, 1, 9, 8, 3, 1, 10, 6, 5, -1, 0, 0, 0, 0, 0, 0,\n\t    6, 1, 2, 6, 5, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    6, 1, 2, 6, 5, 1, 0, 8, 3, -1, 0, 0, 0, 0, 0, 0,\n\t    5, 9, 0, 5, 0, 6, 6, 0, 2, -1, 0, 0, 0, 0, 0, 0,\n\t    6, 5, 2, 2, 8, 3, 5, 8, 2, 5, 9, 8, -1, 0, 0, 0,\n\t    2, 3, 11, 10, 6, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 11, 2, 0, 8, 11, 6, 5, 10, -1, 0, 0, 0, 0, 0, 0,\n\t    0, 1, 9, 3, 11, 2, 10, 6, 5, -1, 0, 0, 0, 0, 0, 0,\n\t    10, 6, 5, 2, 1, 9, 2, 9, 11, 11, 9, 8, -1, 0, 0, 0,\n", "    11, 6, 5, 11, 5, 3, 3, 5, 1, -1, 0, 0, 0, 0, 0, 0,\n\t    11, 6, 8, 8, 1, 0, 8, 6, 1, 1, 6, 5, -1, 0, 0, 0,\n\t    0, 3, 11, 0, 11, 6, 0, 6, 9, 9, 6, 5, -1, 0, 0, 0,\n\t    5, 11, 6, 5, 9, 11, 11, 9, 8, -1, 0, 0, 0, 0, 0, 0,\n\t    7, 8, 4, 6, 5, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    3, 4, 7, 3, 0, 4, 5, 10, 6, -1, 0, 0, 0, 0, 0, 0,\n\t    6, 5, 10, 7, 8, 4, 9, 0, 1, -1, 0, 0, 0, 0, 0, 0,\n\t    5, 10, 6, 9, 4, 7, 9, 7, 1, 1, 7, 3, -1, 0, 0, 0,\n\t    1, 6, 5, 1, 2, 6, 7, 8, 4, -1, 0, 0, 0, 0, 0, 0,\n\t    7, 0, 4, 7, 3, 0, 6, 5, 1, 6, 1, 2, -1, 0, 0, 0,\n", "    4, 7, 8, 5, 9, 0, 5, 0, 6, 6, 0, 2, -1, 0, 0, 0,\n\t    2, 6, 5, 2, 5, 3, 3, 5, 9, 3, 9, 4, 3, 4, 7, -1,\n\t    4, 7, 8, 5, 10, 6, 11, 2, 3, -1, 0, 0, 0, 0, 0, 0,\n\t    6, 5, 10, 7, 11, 2, 7, 2, 4, 4, 2, 0, -1, 0, 0, 0,\n\t    4, 7, 8, 9, 0, 1, 6, 5, 10, 3, 11, 2, -1, 0, 0, 0,\n\t    6, 5, 10, 11, 4, 7, 11, 2, 4, 4, 2, 9, 9, 2, 1, -1,\n\t    7, 8, 4, 11, 6, 5, 11, 5, 3, 3, 5, 1, -1, 0, 0, 0,\n\t    0, 4, 7, 0, 7, 1, 1, 7, 11, 1, 11, 6, 1, 6, 5, -1,\n\t    4, 7, 8, 9, 6, 5, 9, 0, 6, 6, 0, 11, 11, 0, 3, -1,\n\t    7, 11, 4, 11, 9, 4, 11, 5, 9, 11, 6, 5, -1, 0, 0, 0,\n", "    10, 4, 9, 10, 6, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    10, 4, 9, 10, 6, 4, 8, 3, 0, -1, 0, 0, 0, 0, 0, 0,\n\t    1, 10, 6, 1, 6, 0, 0, 6, 4, -1, 0, 0, 0, 0, 0, 0,\n\t    4, 8, 6, 6, 1, 10, 6, 8, 1, 1, 8, 3, -1, 0, 0, 0,\n\t    9, 1, 2, 9, 2, 4, 4, 2, 6, -1, 0, 0, 0, 0, 0, 0,\n\t    0, 8, 3, 9, 1, 2, 9, 2, 4, 4, 2, 6, -1, 0, 0, 0,\n\t    0, 2, 6, 0, 6, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    3, 4, 8, 3, 2, 4, 4, 2, 6, -1, 0, 0, 0, 0, 0, 0,\n\t    4, 10, 6, 4, 9, 10, 2, 3, 11, -1, 0, 0, 0, 0, 0, 0,\n\t    8, 2, 0, 8, 11, 2, 4, 9, 10, 4, 10, 6, -1, 0, 0, 0,\n", "    2, 3, 11, 1, 10, 6, 1, 6, 0, 0, 6, 4, -1, 0, 0, 0,\n\t    8, 11, 2, 8, 2, 4, 4, 2, 1, 4, 1, 10, 4, 10, 6, -1,\n\t    3, 11, 1, 1, 4, 9, 11, 4, 1, 11, 6, 4, -1, 0, 0, 0,\n\t    6, 4, 9, 6, 9, 11, 11, 9, 1, 11, 1, 0, 11, 0, 8, -1,\n\t    11, 0, 3, 11, 6, 0, 0, 6, 4, -1, 0, 0, 0, 0, 0, 0,\n\t    8, 11, 6, 8, 6, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    6, 7, 8, 6, 8, 10, 10, 8, 9, -1, 0, 0, 0, 0, 0, 0,\n\t    3, 0, 7, 7, 10, 6, 0, 10, 7, 0, 9, 10, -1, 0, 0, 0,\n\t    1, 10, 6, 1, 6, 7, 1, 7, 0, 0, 7, 8, -1, 0, 0, 0,\n\t    6, 1, 10, 6, 7, 1, 1, 7, 3, -1, 0, 0, 0, 0, 0, 0,\n", "    9, 1, 8, 8, 6, 7, 8, 1, 6, 6, 1, 2, -1, 0, 0, 0,\n\t    7, 3, 0, 7, 0, 6, 6, 0, 9, 6, 9, 1, 6, 1, 2, -1,\n\t    8, 6, 7, 8, 0, 6, 6, 0, 2, -1, 0, 0, 0, 0, 0, 0,\n\t    2, 6, 7, 2, 7, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    11, 2, 3, 6, 7, 8, 6, 8, 10, 10, 8, 9, -1, 0, 0, 0,\n\t    9, 10, 6, 9, 6, 0, 0, 6, 7, 0, 7, 11, 0, 11, 2, -1,\n\t    3, 11, 2, 0, 7, 8, 0, 1, 7, 7, 1, 6, 6, 1, 10, -1,\n\t    6, 7, 10, 7, 1, 10, 7, 2, 1, 7, 11, 2, -1, 0, 0, 0,\n\t    1, 3, 11, 1, 11, 9, 9, 11, 6, 9, 6, 7, 9, 7, 8, -1,\n\t    6, 7, 11, 9, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "    8, 0, 7, 0, 6, 7, 0, 11, 6, 0, 3, 11, -1, 0, 0, 0,\n\t    6, 7, 11, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    6, 11, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    3, 0, 8, 11, 7, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    6, 11, 7, 9, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    1, 8, 3, 1, 9, 8, 7, 6, 11, -1, 0, 0, 0, 0, 0, 0,\n\t    11, 7, 6, 2, 10, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    1, 2, 10, 0, 8, 3, 11, 7, 6, -1, 0, 0, 0, 0, 0, 0,\n\t    9, 2, 10, 9, 0, 2, 11, 7, 6, -1, 0, 0, 0, 0, 0, 0,\n\t    11, 7, 6, 3, 2, 10, 3, 10, 8, 8, 10, 9, -1, 0, 0, 0,\n", "    2, 7, 6, 2, 3, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    8, 7, 6, 8, 6, 0, 0, 6, 2, -1, 0, 0, 0, 0, 0, 0,\n\t    7, 2, 3, 7, 6, 2, 1, 9, 0, -1, 0, 0, 0, 0, 0, 0,\n\t    8, 7, 9, 9, 2, 1, 9, 7, 2, 2, 7, 6, -1, 0, 0, 0,\n\t    6, 10, 1, 6, 1, 7, 7, 1, 3, -1, 0, 0, 0, 0, 0, 0,\n\t    6, 10, 1, 6, 1, 0, 6, 0, 7, 7, 0, 8, -1, 0, 0, 0,\n\t    7, 6, 3, 3, 9, 0, 6, 9, 3, 6, 10, 9, -1, 0, 0, 0,\n\t    6, 8, 7, 6, 10, 8, 8, 10, 9, -1, 0, 0, 0, 0, 0, 0,\n\t    8, 6, 11, 8, 4, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    11, 3, 0, 11, 0, 6, 6, 0, 4, -1, 0, 0, 0, 0, 0, 0,\n", "    6, 8, 4, 6, 11, 8, 0, 1, 9, -1, 0, 0, 0, 0, 0, 0,\n\t    1, 9, 3, 3, 6, 11, 9, 6, 3, 9, 4, 6, -1, 0, 0, 0,\n\t    8, 6, 11, 8, 4, 6, 10, 1, 2, -1, 0, 0, 0, 0, 0, 0,\n\t    2, 10, 1, 11, 3, 0, 11, 0, 6, 6, 0, 4, -1, 0, 0, 0,\n\t    11, 4, 6, 11, 8, 4, 2, 10, 9, 2, 9, 0, -1, 0, 0, 0,\n\t    4, 6, 11, 4, 11, 9, 9, 11, 3, 9, 3, 2, 9, 2, 10, -1,\n\t    3, 8, 4, 3, 4, 2, 2, 4, 6, -1, 0, 0, 0, 0, 0, 0,\n\t    2, 0, 4, 2, 4, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 1, 9, 3, 8, 4, 3, 4, 2, 2, 4, 6, -1, 0, 0, 0,\n\t    9, 2, 1, 9, 4, 2, 2, 4, 6, -1, 0, 0, 0, 0, 0, 0,\n", "    6, 10, 4, 4, 3, 8, 4, 10, 3, 3, 10, 1, -1, 0, 0, 0,\n\t    1, 6, 10, 1, 0, 6, 6, 0, 4, -1, 0, 0, 0, 0, 0, 0,\n\t    10, 9, 0, 10, 0, 6, 6, 0, 3, 6, 3, 8, 6, 8, 4, -1,\n\t    10, 9, 4, 10, 4, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    6, 11, 7, 5, 4, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 8, 3, 9, 5, 4, 7, 6, 11, -1, 0, 0, 0, 0, 0, 0,\n\t    0, 5, 4, 0, 1, 5, 6, 11, 7, -1, 0, 0, 0, 0, 0, 0,\n\t    7, 6, 11, 4, 8, 3, 4, 3, 5, 5, 3, 1, -1, 0, 0, 0,\n\t    2, 10, 1, 11, 7, 6, 5, 4, 9, -1, 0, 0, 0, 0, 0, 0,\n\t    0, 8, 3, 1, 2, 10, 4, 9, 5, 11, 7, 6, -1, 0, 0, 0,\n", "    6, 11, 7, 10, 5, 4, 10, 4, 2, 2, 4, 0, -1, 0, 0, 0,\n\t    6, 11, 7, 5, 2, 10, 5, 4, 2, 2, 4, 3, 3, 4, 8, -1,\n\t    2, 7, 6, 2, 3, 7, 4, 9, 5, -1, 0, 0, 0, 0, 0, 0,\n\t    4, 9, 5, 8, 7, 6, 8, 6, 0, 0, 6, 2, -1, 0, 0, 0,\n\t    3, 6, 2, 3, 7, 6, 0, 1, 5, 0, 5, 4, -1, 0, 0, 0,\n\t    1, 5, 4, 1, 4, 2, 2, 4, 8, 2, 8, 7, 2, 7, 6, -1,\n\t    5, 4, 9, 6, 10, 1, 6, 1, 7, 7, 1, 3, -1, 0, 0, 0,\n\t    4, 9, 5, 7, 0, 8, 7, 6, 0, 0, 6, 1, 1, 6, 10, -1,\n\t    3, 7, 6, 3, 6, 0, 0, 6, 10, 0, 10, 5, 0, 5, 4, -1,\n\t    4, 8, 5, 8, 10, 5, 8, 6, 10, 8, 7, 6, -1, 0, 0, 0,\n", "    5, 6, 11, 5, 11, 9, 9, 11, 8, -1, 0, 0, 0, 0, 0, 0,\n\t    0, 9, 5, 0, 5, 6, 0, 6, 3, 3, 6, 11, -1, 0, 0, 0,\n\t    8, 0, 11, 11, 5, 6, 11, 0, 5, 5, 0, 1, -1, 0, 0, 0,\n\t    11, 5, 6, 11, 3, 5, 5, 3, 1, -1, 0, 0, 0, 0, 0, 0,\n\t    10, 1, 2, 5, 6, 11, 5, 11, 9, 9, 11, 8, -1, 0, 0, 0,\n\t    2, 10, 1, 3, 6, 11, 3, 0, 6, 6, 0, 5, 5, 0, 9, -1,\n\t    0, 2, 10, 0, 10, 8, 8, 10, 5, 8, 5, 6, 8, 6, 11, -1,\n\t    11, 3, 6, 3, 5, 6, 3, 10, 5, 3, 2, 10, -1, 0, 0, 0,\n\t    2, 3, 6, 6, 9, 5, 3, 9, 6, 3, 8, 9, -1, 0, 0, 0,\n\t    5, 0, 9, 5, 6, 0, 0, 6, 2, -1, 0, 0, 0, 0, 0, 0,\n", "    6, 2, 3, 6, 3, 5, 5, 3, 8, 5, 8, 0, 5, 0, 1, -1,\n\t    6, 2, 1, 6, 1, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    8, 9, 5, 8, 5, 3, 3, 5, 6, 3, 6, 10, 3, 10, 1, -1,\n\t    1, 0, 10, 0, 6, 10, 0, 5, 6, 0, 9, 5, -1, 0, 0, 0,\n\t    0, 3, 8, 10, 5, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    10, 5, 6, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    11, 5, 10, 11, 7, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    5, 11, 7, 5, 10, 11, 3, 0, 8, -1, 0, 0, 0, 0, 0, 0,\n\t    11, 5, 10, 11, 7, 5, 9, 0, 1, -1, 0, 0, 0, 0, 0, 0,\n\t    9, 3, 1, 9, 8, 3, 5, 10, 11, 5, 11, 7, -1, 0, 0, 0,\n", "    2, 11, 7, 2, 7, 1, 1, 7, 5, -1, 0, 0, 0, 0, 0, 0,\n\t    3, 0, 8, 2, 11, 7, 2, 7, 1, 1, 7, 5, -1, 0, 0, 0,\n\t    2, 11, 0, 0, 5, 9, 0, 11, 5, 5, 11, 7, -1, 0, 0, 0,\n\t    9, 8, 3, 9, 3, 5, 5, 3, 2, 5, 2, 11, 5, 11, 7, -1,\n\t    10, 2, 3, 10, 3, 5, 5, 3, 7, -1, 0, 0, 0, 0, 0, 0,\n\t    5, 10, 7, 7, 0, 8, 10, 0, 7, 10, 2, 0, -1, 0, 0, 0,\n\t    1, 9, 0, 10, 2, 3, 10, 3, 5, 5, 3, 7, -1, 0, 0, 0,\n\t    7, 5, 10, 7, 10, 8, 8, 10, 2, 8, 2, 1, 8, 1, 9, -1,\n\t    7, 5, 1, 7, 1, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    8, 1, 0, 8, 7, 1, 1, 7, 5, -1, 0, 0, 0, 0, 0, 0,\n", "    0, 5, 9, 0, 3, 5, 5, 3, 7, -1, 0, 0, 0, 0, 0, 0,\n\t    7, 5, 9, 7, 9, 8, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    4, 5, 10, 4, 10, 8, 8, 10, 11, -1, 0, 0, 0, 0, 0, 0,\n\t    11, 3, 10, 10, 4, 5, 10, 3, 4, 4, 3, 0, -1, 0, 0, 0,\n\t    9, 0, 1, 4, 5, 10, 4, 10, 8, 8, 10, 11, -1, 0, 0, 0,\n\t    3, 1, 9, 3, 9, 11, 11, 9, 4, 11, 4, 5, 11, 5, 10, -1,\n\t    8, 4, 11, 11, 1, 2, 4, 1, 11, 4, 5, 1, -1, 0, 0, 0,\n\t    5, 1, 2, 5, 2, 4, 4, 2, 11, 4, 11, 3, 4, 3, 0, -1,\n\t    11, 8, 4, 11, 4, 2, 2, 4, 5, 2, 5, 9, 2, 9, 0, -1,\n\t    2, 11, 3, 5, 9, 4, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "    4, 5, 10, 4, 10, 2, 4, 2, 8, 8, 2, 3, -1, 0, 0, 0,\n\t    10, 4, 5, 10, 2, 4, 4, 2, 0, -1, 0, 0, 0, 0, 0, 0,\n\t    0, 1, 9, 8, 2, 3, 8, 4, 2, 2, 4, 10, 10, 4, 5, -1,\n\t    10, 2, 5, 2, 4, 5, 2, 9, 4, 2, 1, 9, -1, 0, 0, 0,\n\t    4, 3, 8, 4, 5, 3, 3, 5, 1, -1, 0, 0, 0, 0, 0, 0,\n\t    0, 4, 5, 0, 5, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 3, 9, 3, 5, 9, 3, 4, 5, 3, 8, 4, -1, 0, 0, 0,\n\t    4, 5, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    7, 4, 9, 7, 9, 11, 11, 9, 10, -1, 0, 0, 0, 0, 0, 0,\n\t    8, 3, 0, 7, 4, 9, 7, 9, 11, 11, 9, 10, -1, 0, 0, 0,\n", "    0, 1, 4, 4, 11, 7, 1, 11, 4, 1, 10, 11, -1, 0, 0, 0,\n\t    10, 11, 7, 10, 7, 1, 1, 7, 4, 1, 4, 8, 1, 8, 3, -1,\n\t    2, 11, 7, 2, 7, 4, 2, 4, 1, 1, 4, 9, -1, 0, 0, 0,\n\t    0, 8, 3, 1, 4, 9, 1, 2, 4, 4, 2, 7, 7, 2, 11, -1,\n\t    7, 2, 11, 7, 4, 2, 2, 4, 0, -1, 0, 0, 0, 0, 0, 0,\n\t    7, 4, 11, 4, 2, 11, 4, 3, 2, 4, 8, 3, -1, 0, 0, 0,\n\t    7, 4, 3, 3, 10, 2, 3, 4, 10, 10, 4, 9, -1, 0, 0, 0,\n\t    2, 0, 8, 2, 8, 10, 10, 8, 7, 10, 7, 4, 10, 4, 9, -1,\n\t    4, 0, 1, 4, 1, 7, 7, 1, 10, 7, 10, 2, 7, 2, 3, -1,\n\t    4, 8, 7, 1, 10, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "    9, 7, 4, 9, 1, 7, 7, 1, 3, -1, 0, 0, 0, 0, 0, 0,\n\t    8, 7, 0, 7, 1, 0, 7, 9, 1, 7, 4, 9, -1, 0, 0, 0,\n\t    4, 0, 3, 4, 3, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    4, 8, 7, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    8, 9, 10, 8, 10, 11, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 11, 3, 0, 9, 11, 11, 9, 10, -1, 0, 0, 0, 0, 0, 0,\n\t    1, 8, 0, 1, 10, 8, 8, 10, 11, -1, 0, 0, 0, 0, 0, 0,\n\t    3, 1, 10, 3, 10, 11, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    2, 9, 1, 2, 11, 9, 9, 11, 8, -1, 0, 0, 0, 0, 0, 0,\n\t    0, 9, 3, 9, 11, 3, 9, 2, 11, 9, 1, 2, -1, 0, 0, 0,\n", "    11, 8, 0, 11, 0, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    2, 11, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    3, 10, 2, 3, 8, 10, 10, 8, 9, -1, 0, 0, 0, 0, 0, 0,\n\t    9, 10, 2, 9, 2, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    3, 8, 2, 8, 10, 2, 8, 1, 10, 8, 0, 1, -1, 0, 0, 0,\n\t    2, 1, 10, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    8, 9, 1, 8, 1, 3, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    1, 0, 9, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    0, 3, 8, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t    -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n", "]);\n"]}
{"filename": "src/wgsl.d.ts", "chunked_list": ["declare module \"*.wgsl\"\n\t{\n\t    const content: string;\n\t    export default content;\n\t}\n"]}
{"filename": "src/app.ts", "chunked_list": ["import {ArcballCamera} from \"arcball_camera\";\n\timport {Controller} from \"ez_canvas_controller\";\n\timport {mat4, vec3} from \"gl-matrix\";\n\timport {Volume, volumes} from \"./volume\";\n\timport {MarchingCubes} from \"./marching_cubes\";\n\timport renderMeshShaders from \"./render_mesh.wgsl\";\n\timport {compileShader, fillSelector} from \"./util\";\n\t(async () =>\n\t{\n\t    if (navigator.gpu === undefined) {\n", "        document.getElementById(\"webgpu-canvas\").setAttribute(\"style\", \"display:none;\");\n\t        document.getElementById(\"no-webgpu\").setAttribute(\"style\", \"display:block;\");\n\t        return;\n\t    }\n\t    // Get a GPU device to render with\n\t    let adapter = await navigator.gpu.requestAdapter();\n\t    console.log(adapter.limits);\n\t    let deviceRequiredFeatures: GPUFeatureName[] = [];\n\t    const timestampSupport = adapter.features.has(\"timestamp-query\");\n\t    // Enable timestamp queries if the device supports them\n", "    if (timestampSupport) {\n\t        deviceRequiredFeatures.push(\"timestamp-query\");\n\t    } else {\n\t        console.log(\"Device does not support timestamp queries\");\n\t    }\n\t    let deviceDescriptor = {\n\t        requiredFeatures: deviceRequiredFeatures,\n\t        requiredLimits: {\n\t            maxBufferSize: adapter.limits.maxBufferSize,\n\t            maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,\n", "        }\n\t    };\n\t    let device = await adapter.requestDevice(deviceDescriptor);\n\t    // Get a context to display our rendered image on the canvas\n\t    let canvas = document.getElementById(\"webgpu-canvas\") as HTMLCanvasElement;\n\t    let context = canvas.getContext(\"webgpu\");\n\t    let volumePicker = document.getElementById(\"volumeList\") as HTMLSelectElement;\n\t    fillSelector(volumePicker, volumes);\n\t    let isovalueSlider = document.getElementById(\"isovalueSlider\") as HTMLInputElement;\n\t    // Force computing the surface on the initial load\n", "    let currentIsovalue = -1;\n\t    let perfDisplay = document.getElementById(\"stats\") as HTMLElement;\n\t    let timestampDisplay = document.getElementById(\"timestamp-stats\") as HTMLElement;\n\t    // Setup shader modules\n\t    let shaderModule = await compileShader(device, renderMeshShaders, \"renderMeshShaders\");\n\t    if (window.location.hash) {\n\t        let linkedDataset = decodeURI(window.location.hash.substring(1));\n\t        if (volumes.has(linkedDataset)) {\n\t            volumePicker.value = linkedDataset;\n\t        }\n", "    }\n\t    let currentVolume = volumePicker.value;\n\t    let volume = await Volume.load(volumes.get(currentVolume), device);\n\t    let mc = await MarchingCubes.create(volume, device);\n\t    let isosurface = null;\n\t    // Vertex attribute state and shader stage\n\t    let vertexState = {\n\t        // Shader stage info\n\t        module: shaderModule,\n\t        entryPoint: \"vertex_main\",\n", "        // Vertex buffer info\n\t        buffers: [{\n\t            arrayStride: 4 * 4,\n\t            attributes: [\n\t                {format: \"float32x4\" as GPUVertexFormat, offset: 0, shaderLocation: 0}\n\t            ]\n\t        }]\n\t    };\n\t    // Setup render outputs\n\t    let swapChainFormat = \"bgra8unorm\" as GPUTextureFormat;\n", "    context.configure(\n\t        {device: device, format: swapChainFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT});\n\t    let depthFormat = \"depth24plus-stencil8\" as GPUTextureFormat;\n\t    let depthTexture = device.createTexture({\n\t        size: {width: canvas.width, height: canvas.height, depthOrArrayLayers: 1},\n\t        format: depthFormat,\n\t        usage: GPUTextureUsage.RENDER_ATTACHMENT\n\t    });\n\t    let fragmentState = {\n\t        // Shader info\n", "        module: shaderModule,\n\t        entryPoint: \"fragment_main\",\n\t        // Output render target info\n\t        targets: [{format: swapChainFormat}]\n\t    };\n\t    let bindGroupLayout = device.createBindGroupLayout({\n\t        entries: [{binding: 0, visibility: GPUShaderStage.VERTEX, buffer: {type: \"uniform\"}}]\n\t    });\n\t    // Create render pipeline\n\t    let layout = device.createPipelineLayout({bindGroupLayouts: [bindGroupLayout]});\n", "    let renderPipeline = device.createRenderPipeline({\n\t        layout: layout,\n\t        vertex: vertexState,\n\t        fragment: fragmentState,\n\t        depthStencil: {format: depthFormat, depthWriteEnabled: true, depthCompare: \"less\"}\n\t    });\n\t    let renderPassDesc = {\n\t        colorAttachments: [{\n\t            view: null as GPUTextureView,\n\t            loadOp: \"clear\" as GPULoadOp,\n", "            clearValue: [0.3, 0.3, 0.3, 1],\n\t            storeOp: \"store\" as GPUStoreOp\n\t        }],\n\t        depthStencilAttachment: {\n\t            view: depthTexture.createView(),\n\t            depthLoadOp: \"clear\" as GPULoadOp,\n\t            depthClearValue: 1.0,\n\t            depthStoreOp: \"store\" as GPUStoreOp,\n\t            stencilLoadOp: \"clear\" as GPULoadOp,\n\t            stencilClearValue: 0,\n", "            stencilStoreOp: \"store\" as GPUStoreOp\n\t        }\n\t    };\n\t    let viewParamsBuffer = device.createBuffer({\n\t        size: (4 * 4 + 4) * 4,\n\t        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t        mappedAtCreation: false,\n\t    });\n\t    let uploadBuffer = device.createBuffer({\n\t        size: viewParamsBuffer.size,\n", "        usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,\n\t        mappedAtCreation: false,\n\t    });\n\t    let bindGroup = device.createBindGroup({\n\t        layout: bindGroupLayout,\n\t        entries: [{binding: 0, resource: {buffer: viewParamsBuffer}}]\n\t    });\n\t    // Setup camera and camera controls\n\t    const defaultEye = vec3.set(vec3.create(), 0.0, 0.0, volume.dims[2] * 0.75);\n\t    const center = vec3.set(vec3.create(), 0.0, 0.0, 0.5);\n", "    const up = vec3.set(vec3.create(), 0.0, 1.0, 0.0);\n\t    let camera = new ArcballCamera(defaultEye, center, up, 2, [canvas.width, canvas.height]);\n\t    let proj = mat4.perspective(\n\t        mat4.create(), 50 * Math.PI / 180.0, canvas.width / canvas.height, 0.1, 1000);\n\t    let projView = mat4.create();\n\t    // Register mouse and touch listeners\n\t    var controller = new Controller();\n\t    controller.mousemove = function (prev: Array<number>, cur: Array<number>, evt: MouseEvent)\n\t    {\n\t        if (evt.buttons == 1) {\n", "            camera.rotate(prev, cur);\n\t        } else if (evt.buttons == 2) {\n\t            camera.pan([cur[0] - prev[0], prev[1] - cur[1]]);\n\t        }\n\t    };\n\t    controller.wheel = function (amt: number)\n\t    {\n\t        camera.zoom(amt);\n\t    };\n\t    controller.pinch = controller.wheel;\n", "    controller.twoFingerDrag = function (drag: number)\n\t    {\n\t        camera.pan(drag);\n\t    };\n\t    controller.registerForCanvas(canvas);\n\t    let animationFrame = function ()\n\t    {\n\t        let resolve = null;\n\t        let promise = new Promise(r => resolve = r);\n\t        window.requestAnimationFrame(resolve);\n", "        return promise\n\t    };\n\t    requestAnimationFrame(animationFrame);\n\t    // Render!\n\t    while (true) {\n\t        await animationFrame();\n\t        if (document.hidden) {\n\t            continue;\n\t        }\n\t        let sliderValue = parseFloat(isovalueSlider.value) / 255.0;\n", "        let recomputeSurface = sliderValue != currentIsovalue;\n\t        // When a new volume is selected, recompute the surface and reposition the camera\n\t        if (volumePicker.value != currentVolume) {\n\t            if (isosurface.buffer) {\n\t                isosurface.buffer.destroy();\n\t            }\n\t            currentVolume = volumePicker.value;\n\t            history.replaceState(history.state, \"#\" + currentVolume, \"#\" + currentVolume);\n\t            volume = await Volume.load(volumes.get(currentVolume), device);\n\t            mc = await MarchingCubes.create(volume, device);\n", "            isovalueSlider.value = \"128\";\n\t            sliderValue = parseFloat(isovalueSlider.value) / 255.0;\n\t            recomputeSurface = true;\n\t            const defaultEye = vec3.set(vec3.create(), 0.0, 0.0, volume.dims[2] * 0.75);\n\t            camera = new ArcballCamera(defaultEye, center, up, 2, [canvas.width, canvas.height]);\n\t        }\n\t        if (recomputeSurface) {\n\t            if (isosurface && isosurface.buffer) {\n\t                isosurface.buffer.destroy();\n\t            }\n", "            currentIsovalue = sliderValue;\n\t            let start = performance.now();\n\t            isosurface = await mc.computeSurface(currentIsovalue);\n\t            let end = performance.now();\n\t            perfDisplay.innerHTML =\n\t                `<p>Compute Time: ${(end - start).toFixed((2))}ms<br/># Triangles: ${isosurface.count / 3}</p>`\n\t            timestampDisplay.innerHTML =\n\t                `<h4>Timing Breakdown</h4>\n\t                    <p>Note: if timestamp-query is not supported, -1 is shown for kernel times</p>\n\t                    Compute Active Voxels: ${mc.computeActiveVoxelsTime.toFixed(2)}ms\n", "                    <ul>\n\t                    <li>\n\t                    Mark Active Voxels Kernel: ${mc.markActiveVoxelsKernelTime.toFixed(2)}ms\n\t                    </li>\n\t                    <li>\n\t                    Exclusive Scan: ${mc.computeActiveVoxelsScanTime.toFixed(2)}ms\n\t                    </li>\n\t                    <li>\n\t                    Stream Compact: ${mc.computeActiveVoxelsCompactTime.toFixed(2)}ms\n\t                    </li>\n", "                    </ul>\n\t                    Compute Vertex Offsets: ${mc.computeVertexOffsetsTime.toFixed(2)}ms\n\t                    <ul>\n\t                    <li>\n\t                    Compute # of Vertices Kernel: ${mc.computeNumVertsKernelTime.toFixed(2)}ms\n\t                    </li>\n\t                    <li>\n\t                    Exclusive Scan: ${mc.computeVertexOffsetsScanTime.toFixed(2)}ms\n\t                    </li>\n\t                    </ul>\n", "                    Compute Vertices: ${mc.computeVerticesTime.toFixed(2)}ms\n\t                    <ul>\n\t                    <li>\n\t                    Compute Vertices Kernel: ${mc.computeVerticesKernelTime.toFixed(2)}ms\n\t                    </li>\n\t                    </ul>`;\n\t        }\n\t        projView = mat4.mul(projView, proj, camera.camera);\n\t        {\n\t            await uploadBuffer.mapAsync(GPUMapMode.WRITE);\n", "            let map = uploadBuffer.getMappedRange();\n\t            new Float32Array(map).set(projView);\n\t            new Uint32Array(map, 16 * 4, 4).set(volume.dims);\n\t            uploadBuffer.unmap();\n\t        }\n\t        renderPassDesc.colorAttachments[0].view = context.getCurrentTexture().createView();\n\t        let commandEncoder = device.createCommandEncoder();\n\t        commandEncoder.copyBufferToBuffer(\n\t            uploadBuffer, 0, viewParamsBuffer, 0, viewParamsBuffer.size);\n\t        let renderPass = commandEncoder.beginRenderPass(renderPassDesc);\n", "        if (isosurface.count > 0) {\n\t            renderPass.setBindGroup(0, bindGroup);\n\t            renderPass.setPipeline(renderPipeline);\n\t            renderPass.setVertexBuffer(0, isosurface.buffer);\n\t            renderPass.draw(isosurface.count, 1, 0, 0);\n\t        }\n\t        renderPass.end();\n\t        device.queue.submit([commandEncoder.finish()]);\n\t    }\n\t})();\n"]}
{"filename": "src/arcball_camera.d.ts", "chunked_list": ["// TODO: typescript type bindings for this repo\n\tdeclare module \"arcball_camera\";\n"]}
{"filename": "src/volume.ts", "chunked_list": ["import {alignTo} from \"./util\";\n\texport const volumes = new Map<string, string>([\n\t    [\"Fuel\", \"fuel_64x64x64_uint8.raw\"],\n\t    [\"Neghip\", \"neghip_64x64x64_uint8.raw\"],\n\t    [\"Hydrogen Atom\", \"hydrogen_atom_128x128x128_uint8.raw\"],\n\t    [\"Bonsai\", \"bonsai_256x256x256_uint8.raw\"],\n\t    [\"Foot\", \"foot_256x256x256_uint8.raw\"],\n\t    [\"Skull\", \"skull_256x256x256_uint8.raw\"],\n\t    [\"Aneurysm\", \"aneurism_256x256x256_uint8.raw\"]\n\t]);\n", "export enum VoxelType\n\t{\n\t    UINT8,\n\t    UINT16,\n\t    UINT32,\n\t    FLOAT32\n\t};\n\texport function parseVoxelType(str: string)\n\t{\n\t    if (str == \"uint8\") {\n", "        return VoxelType.UINT8;\n\t    }\n\t    if (str == \"uint16\") {\n\t        return VoxelType.UINT16;\n\t    }\n\t    if (str == \"UINT32\") {\n\t        return VoxelType.UINT32;\n\t    }\n\t    if (str == \"FLOAT32\") {\n\t        return VoxelType.FLOAT32;\n", "    }\n\t    throw Error(`Unsupported/invalid voxel type string ${str}`);\n\t}\n\texport function voxelTypeSize(ty: VoxelType)\n\t{\n\t    switch (ty) {\n\t        case VoxelType.UINT8:\n\t            return 1;\n\t        case VoxelType.UINT16:\n\t            return 2;\n", "        case VoxelType.UINT32:\n\t        case VoxelType.FLOAT32:\n\t            return 4;\n\t    }\n\t}\n\texport function voxelTypeToTextureType(ty: VoxelType)\n\t{\n\t    switch (ty) {\n\t        case VoxelType.UINT8:\n\t            // TODO: should use the non-normalized types later\n", "            return \"r8unorm\";\n\t        case VoxelType.UINT16:\n\t            return \"r16uint\";\n\t        case VoxelType.UINT32:\n\t            return \"r32uint\";\n\t        case VoxelType.FLOAT32:\n\t            return \"r32float\";\n\t    }\n\t}\n\texport class Volume\n", "{\n\t    readonly #dimensions: Array<number>;\n\t    readonly #dataType: VoxelType;\n\t    readonly #file: string;\n\t    #data: Uint8Array;\n\t    #texture: GPUTexture;\n\t    private constructor(file: string)\n\t    {\n\t        let fileRegex = /(\\w+)_(\\d+)x(\\d+)x(\\d+)_(\\w+)\\.*/;\n\t        let m = file.match(fileRegex);\n", "        this.#dimensions = [parseInt(m[2]), parseInt(m[3]), parseInt(m[4])];\n\t        this.#dataType = parseVoxelType(m[5]);\n\t        this.#file = file;\n\t    }\n\t    static async load(file: string, device: GPUDevice)\n\t    {\n\t        let volume = new Volume(file);\n\t        await volume.fetch();\n\t        await volume.upload(device);\n\t        return volume;\n", "    }\n\t    async upload(device: GPUDevice)\n\t    {\n\t        this.#texture = device.createTexture({\n\t            size: this.#dimensions,\n\t            format: voxelTypeToTextureType(this.#dataType),\n\t            dimension: \"3d\",\n\t            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST\n\t        });\n\t        // TODO: might need to chunk the upload to support very large volumes?\n", "        // I had some note about hitting some timeout or hang issues with 512^3 in the past?\n\t        let uploadBuf = device.createBuffer(\n\t            {size: this.#data.byteLength, usage: GPUBufferUsage.COPY_SRC, mappedAtCreation: true});\n\t        new Uint8Array(uploadBuf.getMappedRange()).set(this.#data);\n\t        uploadBuf.unmap();\n\t        let commandEncoder = device.createCommandEncoder();\n\t        let src = {\n\t            buffer: uploadBuf,\n\t            // Volumes must be aligned to 256 bytes per row, fetchVolume does this padding\n\t            bytesPerRow: alignTo(this.#dimensions[0] * voxelTypeSize(this.#dataType), 256),\n", "            rowsPerImage: this.#dimensions[1]\n\t        };\n\t        let dst = {texture: this.#texture};\n\t        commandEncoder.copyBufferToTexture(src, dst, this.#dimensions);\n\t        device.queue.submit([commandEncoder.finish()]);\n\t        await device.queue.onSubmittedWorkDone();\n\t    }\n\t    get dims()\n\t    {\n\t        return this.#dimensions;\n", "    }\n\t    get dualGridDims()\n\t    {\n\t        return [this.#dimensions[0] - 1, this.#dimensions[1] - 1, this.#dimensions[2] - 1];\n\t    }\n\t    get voxelType()\n\t    {\n\t        return this.#dataType;\n\t    }\n\t    get texture()\n", "    {\n\t        return this.#texture;\n\t    }\n\t    get numVoxels()\n\t    {\n\t        return this.#dimensions[0] * this.#dimensions[1] * this.#dimensions[2];\n\t    }\n\t    get dualGridNumVoxels()\n\t    {\n\t        return (this.#dimensions[0] - 1) * (this.#dimensions[1] - 1) * (this.#dimensions[2] - 1);\n", "    }\n\t    private pad(buf: Uint8Array)\n\t    {\n\t        const voxelSize = voxelTypeSize(this.#dataType);\n\t        const paddedByteDims = [\n\t            alignTo(this.#dimensions[0] * voxelSize, 256),\n\t            this.#dimensions[1] * voxelSize,\n\t            this.#dimensions[2] * voxelSize\n\t        ];\n\t        let padded =\n", "            new Uint8Array(paddedByteDims[0] * paddedByteDims[1] * paddedByteDims[2]);\n\t        // Copy each row into the padded volume buffer\n\t        const nrows = this.#dimensions[1] * this.#dimensions[2];\n\t        for (let i = 0; i < nrows; ++i) {\n\t            let inrow = buf.subarray(i * this.#dimensions[0] * voxelSize,\n\t                i * this.#dimensions[0] * voxelSize + this.#dimensions[0] * voxelSize);\n\t            padded.set(inrow, i * paddedByteDims[0]);\n\t        }\n\t        return padded;\n\t    }\n", "    private async fetch()\n\t    {\n\t        const voxelSize = voxelTypeSize(this.#dataType);\n\t        const volumeSize = this.#dimensions[0] * this.#dimensions[1]\n\t            * this.#dimensions[2] * voxelSize;\n\t        let loadingProgressText = document.getElementById(\"loadingText\");\n\t        let loadingProgressBar = document.getElementById(\"loadingProgressBar\");\n\t        loadingProgressText.innerHTML = \"Loading Volume...\";\n\t        loadingProgressBar.setAttribute(\"style\", \"width: 0%\");\n\t        let url = \"https://cdn.willusher.io/demo-volumes/\" + this.#file;\n", "        try {\n\t            let response = await fetch(url);\n\t            let reader = response.body.getReader();\n\t            let receivedSize = 0;\n\t            let buf = new Uint8Array(volumeSize);\n\t            while (true) {\n\t                let {done, value} = await reader.read();\n\t                if (done) {\n\t                    break;\n\t                }\n", "                buf.set(value, receivedSize);\n\t                receivedSize += value.length;\n\t                let percentLoaded = receivedSize / volumeSize * 100;\n\t                loadingProgressBar.setAttribute(\"style\",\n\t                    `width: ${percentLoaded.toFixed(2)}%`);\n\t            }\n\t            loadingProgressText.innerHTML = \"Volume Loaded\";\n\t            // WebGPU requires that bytes per row = 256, so we need to pad volumes\n\t            // that are smaller than this\n\t            if ((this.#dimensions[0] * voxelSize) % 256 != 0) {\n", "                this.#data = this.pad(buf);\n\t            } else {\n\t                this.#data = buf;\n\t            }\n\t        } catch (err) {\n\t            loadingProgressText.innerHTML = \"Error loading volume\";\n\t            throw Error(`Error loading volume data ${err}`);\n\t        }\n\t    }\n\t};\n"]}
{"filename": "src/push_constant_builder.ts", "chunked_list": ["import {alignTo} from \"./util\";\n\t// Generate the work group ID offset buffer and the dynamic offset buffer to use for chunking\n\t// up a large compute dispatch. The start of the push constants data will be:\n\t// {\n\t//      u32: work group id offset\n\t//      u32: totalWorkGroups\n\t//      ...: optional additional data (if any)\n\t// }\n\texport class PushConstants\n\t{\n", "    // The GPU buffer containing the push constant data, to be used\n\t    // as a uniform buffer with a dynamic offset\n\t    pushConstantsBuffer: GPUBuffer;\n\t    // Stride in bytes between push constants\n\t    // will be a multiple of device.minUniformBufferOffsetAlignment\n\t    stride: number;\n\t    // The total number of work groups that were chunked up into smaller\n\t    // dispatches for this set of push constants\n\t    totalWorkGroups: number;\n\t    #maxWorkgroupsPerDimension: number;\n", "    constructor(device: GPUDevice, totalWorkGroups: number, appPushConstants?: ArrayBuffer)\n\t    {\n\t        this.#maxWorkgroupsPerDimension = device.limits.maxComputeWorkgroupsPerDimension;\n\t        this.totalWorkGroups = totalWorkGroups;\n\t        let nDispatches =\n\t            Math.ceil(totalWorkGroups / device.limits.maxComputeWorkgroupsPerDimension);\n\t        // Determine if we have some additional push constant data and align the push constant\n\t        // stride accordingly\n\t        this.stride = device.limits.minUniformBufferOffsetAlignment;\n\t        let appPushConstantsView = null;\n", "        if (appPushConstants) {\n\t            this.stride = alignTo(8 + appPushConstants.byteLength,\n\t                device.limits.minUniformBufferOffsetAlignment);\n\t            appPushConstantsView = new Uint8Array(appPushConstants);\n\t        }\n\t        if (this.stride * nDispatches > device.limits.maxUniformBufferBindingSize) {\n\t            console.log(\"Error! PushConstants uniform buffer is too big for a uniform buffer\");\n\t            throw Error(\"PushConstants uniform buffer is too big for a uniform buffer\");\n\t        }\n\t        this.pushConstantsBuffer = device.createBuffer({\n", "            size: this.stride * nDispatches,\n\t            usage: GPUBufferUsage.UNIFORM,\n\t            mappedAtCreation: true,\n\t        });\n\t        let mapping = this.pushConstantsBuffer.getMappedRange();\n\t        for (let i = 0; i < nDispatches; ++i) {\n\t            // Write the work group offset push constants data\n\t            let u32view = new Uint32Array(mapping, i * this.stride, 2);\n\t            u32view[0] = device.limits.maxComputeWorkgroupsPerDimension * i;\n\t            u32view[1] = totalWorkGroups;\n", "            // Copy in any additional push constants data if provided\n\t            if (appPushConstantsView) {\n\t                var u8view =\n\t                    new Uint8Array(mapping, i * this.stride + 8, appPushConstants.byteLength);\n\t                u8view.set(appPushConstantsView);\n\t            }\n\t        }\n\t        this.pushConstantsBuffer.unmap();\n\t    }\n\t    // Get the total number of dispatches that must be performed to run the total set\n", "    // of workgroups, obeying the maxComputeWorkgroupsPerDimension restriction of the device.\n\t    numDispatches()\n\t    {\n\t        return this.pushConstantsBuffer.size / this.stride;\n\t    }\n\t    // Get the offset to use for the pushConstants for a given dispatch index\n\t    pushConstantsOffset(dispatchIndex: number)\n\t    {\n\t        return this.stride * dispatchIndex;\n\t    }\n", "    // Get the number of workgroups to launch for the given dispatch index\n\t    dispatchSize(dispatchIndex: number)\n\t    {\n\t        let remainder = this.totalWorkGroups % this.#maxWorkgroupsPerDimension;\n\t        if (remainder == 0 || dispatchIndex + 1 < this.numDispatches()) {\n\t            return this.#maxWorkgroupsPerDimension;\n\t        }\n\t        return remainder;\n\t    }\n\t};\n"]}
{"filename": "src/util.ts", "chunked_list": ["export function alignTo(val: number, align: number)\n\t{\n\t    return Math.floor((val + align - 1) / align) * align;\n\t};\n\t// Compute the shader and print any error log\n\texport async function compileShader(device: GPUDevice, src: string, debugLabel?: string)\n\t{\n\t    let shaderModule = device.createShaderModule({code: src});\n\t    let compilationInfo = await shaderModule.getCompilationInfo();\n\t    if (compilationInfo.messages.length > 0) {\n", "        let hadError = false;\n\t        if (debugLabel) {\n\t            console.log(`Shader compilation log for ${debugLabel}:`);\n\t        } else {\n\t            console.log(`Shader compilation log:`);\n\t        }\n\t        let lines = src.split(\"\\n\");\n\t        for (let i = 0; i < compilationInfo.messages.length; ++i) {\n\t            let msg = compilationInfo.messages[i];\n\t            console.log(`${msg.lineNum}:${msg.linePos} - ${msg.message}`);\n", "            // TODO: Could use length/offset here but they seem to always be 0?\n\t            // Same for linepos, but the error in the console has a valid linepos.\n\t            // it seems to be lost?\n\t            console.log(`    ${lines[msg.lineNum - 1]}`);\n\t            hadError = hadError || msg.type == \"error\";\n\t        }\n\t        if (hadError) {\n\t            console.log(\"Shader failed to compile\");\n\t            throw Error(\"Shader failed to compile\");\n\t        }\n", "    }\n\t    return shaderModule;\n\t}\n\texport function fillSelector(selector: HTMLSelectElement, dict: Map<string, string>)\n\t{\n\t    for (let v of dict.keys()) {\n\t        let opt = document.createElement(\"option\") as HTMLOptionElement;\n\t        opt.value = v;\n\t        opt.innerHTML = v;\n\t        selector.appendChild(opt);\n", "    }\n\t}\n"]}
{"filename": "src/exclusive_scan.ts", "chunked_list": ["import addBlockSums from \"./exclusive_scan_add_block_sums.wgsl\";\n\timport prefixSum from \"./exclusive_scan_prefix_sum.wgsl\";\n\timport prefixSumBlocks from \"./exclusive_scan_prefix_sum_blocks.wgsl\";\n\timport {alignTo, compileShader} from \"./util\";\n\t// Note: This also means the min size we can scan is 128 elements\n\tconst SCAN_BLOCK_SIZE = 512;\n\t// Serial scan for validation\n\texport function serialExclusiveScan(array: Uint32Array, output: Uint32Array)\n\t{\n\t    output[0] = 0;\n", "    for (let i = 1; i < array.length; ++i) {\n\t        output[i] = array[i - 1] + output[i - 1];\n\t    }\n\t    return output[array.length - 1] + array[array.length - 1];\n\t}\n\texport class ExclusiveScan\n\t{\n\t    #device: GPUDevice;\n\t    // The max # of elements that can be scanned without carry in/out\n\t    readonly #maxScanSize = SCAN_BLOCK_SIZE * SCAN_BLOCK_SIZE;\n", "    // Pipeline for scanning the individual blocks of ScanBlockSize elements\n\t    #scanBlocksPipeline: GPUComputePipeline;\n\t    // Pipeline for scanning the block scan results which will then be added back to\n\t    // the individual block scan results\n\t    #scanBlockResultsPipeline: GPUComputePipeline;\n\t    // Pipeline that adds the block scan results back to each individual block so\n\t    // that its scan result is globally correct based on the elements preceeding the block\n\t    #addBlockSumsPipeline: GPUComputePipeline;\n\t    private constructor(device: GPUDevice)\n\t    {\n", "        this.#device = device;\n\t    }\n\t    static async create(device: GPUDevice)\n\t    {\n\t        let self = new ExclusiveScan(device);\n\t        let scanAddBGLayout = device.createBindGroupLayout({\n\t            entries: [\n\t                {\n\t                    binding: 0,\n\t                    visibility: GPUShaderStage.COMPUTE,\n", "                    buffer: {type: \"storage\", hasDynamicOffset: true}\n\t                },\n\t                {\n\t                    binding: 1,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n\t                    }\n\t                },\n\t            ],\n", "        });\n\t        let scanBlockBGLayout = device.createBindGroupLayout({\n\t            entries: [\n\t                {\n\t                    binding: 0,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n\t                    }\n\t                },\n", "                {\n\t                    binding: 1,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n\t                    }\n\t                },\n\t            ],\n\t        });\n\t        self.#scanBlocksPipeline = device.createComputePipeline({\n", "            layout: device.createPipelineLayout({\n\t                bindGroupLayouts: [scanAddBGLayout],\n\t            }),\n\t            compute: {\n\t                module: await compileShader(device, prefixSum, \"ExclusiveScan::prefixSum\"),\n\t                entryPoint: \"main\",\n\t                constants: {\"0\": SCAN_BLOCK_SIZE}\n\t            }\n\t        });\n\t        self.#scanBlockResultsPipeline = device.createComputePipeline({\n", "            layout: device.createPipelineLayout({\n\t                bindGroupLayouts: [scanBlockBGLayout],\n\t            }),\n\t            compute: {\n\t                module: await compileShader(\n\t                    device, prefixSumBlocks, \"ExclusiveScan::prefixSumBlocks\"),\n\t                entryPoint: \"main\",\n\t                constants: {\"0\": SCAN_BLOCK_SIZE}\n\t            }\n\t        });\n", "        self.#addBlockSumsPipeline = device.createComputePipeline({\n\t            layout: device.createPipelineLayout({\n\t                bindGroupLayouts: [scanAddBGLayout],\n\t            }),\n\t            compute: {\n\t                module:\n\t                    await compileShader(device, addBlockSums, \"ExclusiveScan::addBlockSums\"),\n\t                entryPoint: \"main\",\n\t                constants: {\"0\": SCAN_BLOCK_SIZE}\n\t            }\n", "        });\n\t        return self;\n\t    }\n\t    getAlignedSize(size: number)\n\t    {\n\t        return alignTo(size, SCAN_BLOCK_SIZE);\n\t    }\n\t    async scan(buffer: GPUBuffer, size: number)\n\t    {\n\t        const bufferTotalSize = buffer.size / 4;\n", "        if (bufferTotalSize != this.getAlignedSize(bufferTotalSize)) {\n\t            throw Error(`Error: GPU input buffer size (${bufferTotalSize}) must be aligned to ExclusiveScan::getAlignedSize, expected ${this.getAlignedSize(bufferTotalSize)}`)\n\t        }\n\t        let readbackBuf = this.#device.createBuffer({\n\t            size: 4,\n\t            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n\t        });\n\t        let blockSumBuf = this.#device.createBuffer({\n\t            size: SCAN_BLOCK_SIZE * 4,\n\t            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n", "        });\n\t        let carryBuf = this.#device.createBuffer({\n\t            size: 8,\n\t            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n\t        })\n\t        let carryIntermediateBuf = this.#device.createBuffer({\n\t            size: 4,\n\t            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n\t        })\n\t        let scanBlockResultsBG = this.#device.createBindGroup({\n", "            layout: this.#scanBlockResultsPipeline.getBindGroupLayout(0),\n\t            entries: [\n\t                {\n\t                    binding: 0,\n\t                    resource: {\n\t                        buffer: blockSumBuf,\n\t                    },\n\t                },\n\t                {\n\t                    binding: 1,\n", "                    resource: {\n\t                        buffer: carryBuf,\n\t                    },\n\t                },\n\t            ],\n\t        });\n\t        const numChunks = Math.ceil(size / this.#maxScanSize);\n\t        let scanBlocksBG = null;\n\t        let scanRemainderBlocksBG = null;\n\t        if (numChunks > 1) {\n", "            scanBlocksBG = this.#device.createBindGroup({\n\t                layout: this.#scanBlocksPipeline.getBindGroupLayout(0),\n\t                entries: [\n\t                    {\n\t                        binding: 0,\n\t                        resource: {\n\t                            buffer: buffer,\n\t                            size: this.#maxScanSize * 4,\n\t                        }\n\t                    },\n", "                    {\n\t                        binding: 1,\n\t                        resource: {\n\t                            buffer: blockSumBuf,\n\t                        },\n\t                    },\n\t                ],\n\t            });\n\t            if (bufferTotalSize % this.#maxScanSize != 0) {\n\t                scanRemainderBlocksBG = this.#device.createBindGroup({\n", "                    layout: this.#scanBlocksPipeline.getBindGroupLayout(0),\n\t                    entries: [\n\t                        {\n\t                            binding: 0,\n\t                            resource: {\n\t                                buffer: buffer,\n\t                                size: (bufferTotalSize % this.#maxScanSize) * 4,\n\t                            }\n\t                        },\n\t                        {\n", "                            binding: 1,\n\t                            resource: {\n\t                                buffer: blockSumBuf,\n\t                            },\n\t                        },\n\t                    ],\n\t                });\n\t            } else {\n\t                scanRemainderBlocksBG = scanBlocksBG;\n\t            }\n", "        } else {\n\t            scanBlocksBG = this.#device.createBindGroup({\n\t                layout: this.#scanBlocksPipeline.getBindGroupLayout(0),\n\t                entries: [\n\t                    {\n\t                        binding: 0,\n\t                        resource: {\n\t                            buffer: buffer,\n\t                            size: Math.min(this.#maxScanSize, bufferTotalSize) * 4,\n\t                        }\n", "                    },\n\t                    {\n\t                        binding: 1,\n\t                        resource: {\n\t                            buffer: blockSumBuf,\n\t                        },\n\t                    },\n\t                ],\n\t            });\n\t            scanRemainderBlocksBG = scanBlocksBG;\n", "        }\n\t        let commandEncoder = this.#device.createCommandEncoder();\n\t        commandEncoder.clearBuffer(blockSumBuf);\n\t        commandEncoder.clearBuffer(carryBuf);\n\t        // If the size being scanned is less than the buffer size, clear the end of it\n\t        // so we don't pull down invalid values\n\t        if (size < bufferTotalSize) {\n\t            // TODO: Later the scan should support not reading these values by doing proper\n\t            // range checking so that we don't have to touch regions of the buffer you don't\n\t            // tell us to\n", "            commandEncoder.clearBuffer(buffer, size * 4, 4);\n\t        }\n\t        // Record the scan commands\n\t        for (let i = 0; i < numChunks; ++i) {\n\t            let currentScanBlocksBG = scanBlocksBG;\n\t            if (i + 1 == numChunks) {\n\t                currentScanBlocksBG = scanRemainderBlocksBG;\n\t            }\n\t            let nWorkGroups = Math.min(\n\t                (bufferTotalSize - i * this.#maxScanSize) / SCAN_BLOCK_SIZE, SCAN_BLOCK_SIZE);\n", "            // Clear the previous block sums\n\t            commandEncoder.clearBuffer(blockSumBuf);\n\t            let computePass = commandEncoder.beginComputePass();\n\t            computePass.setPipeline(this.#scanBlocksPipeline);\n\t            computePass.setBindGroup(0, currentScanBlocksBG, [i * this.#maxScanSize * 4]);\n\t            computePass.dispatchWorkgroups(nWorkGroups, 1, 1);\n\t            computePass.setPipeline(this.#scanBlockResultsPipeline);\n\t            computePass.setBindGroup(0, scanBlockResultsBG);\n\t            computePass.dispatchWorkgroups(1, 1, 1);\n\t            computePass.setPipeline(this.#addBlockSumsPipeline);\n", "            computePass.setBindGroup(0, currentScanBlocksBG, [i * this.#maxScanSize * 4]);\n\t            computePass.dispatchWorkgroups(nWorkGroups, 1, 1);\n\t            computePass.end();\n\t            // Update the carry in value for the next chunk, copy carry out to carry in\n\t            commandEncoder.copyBufferToBuffer(carryBuf, 4, carryIntermediateBuf, 0, 4);\n\t            commandEncoder.copyBufferToBuffer(carryIntermediateBuf, 0, carryBuf, 0, 4);\n\t        }\n\t        // Copy the final scan result back to the readback buffer\n\t        if (size < bufferTotalSize) {\n\t            commandEncoder.copyBufferToBuffer(buffer, size * 4, readbackBuf, 0, 4);\n", "        } else {\n\t            commandEncoder.copyBufferToBuffer(carryBuf, 4, readbackBuf, 0, 4);\n\t        }\n\t        this.#device.queue.submit([commandEncoder.finish()]);\n\t        await this.#device.queue.onSubmittedWorkDone();\n\t        await readbackBuf.mapAsync(GPUMapMode.READ);\n\t        let mapping = new Uint32Array(readbackBuf.getMappedRange());\n\t        let sum = mapping[0];\n\t        readbackBuf.unmap();\n\t        return sum;\n", "    }\n\t};\n"]}
{"filename": "src/ez_canvas_controller.d.ts", "chunked_list": ["// TODO: typescript type bindings for this repo\n\tdeclare module \"ez_canvas_controller\";\n"]}
{"filename": "src/stream_compact_ids.ts", "chunked_list": ["import {PushConstants} from \"./push_constant_builder\";\n\timport streamCompactIDs from \"./stream_compact_ids.wgsl\";\n\timport {compileShader} from \"./util\";\n\t// Serial version for validation\n\texport function serialStreamCompactIDs(\n\t    isActiveBuffer: Uint32Array, offsetBuffer: Uint32Array, idOutputBuffer: Uint32Array)\n\t{\n\t    for (let i = 0; i < isActiveBuffer.length; ++i) {\n\t        if (isActiveBuffer[i] != 0) {\n\t            idOutputBuffer[offsetBuffer[i]] = i;\n", "        }\n\t    }\n\t}\n\texport class StreamCompactIDs\n\t{\n\t    #device: GPUDevice;\n\t    // Should be at least 64 so that we process elements\n\t    // in 256b blocks with each WG. This will ensure that our\n\t    // dynamic offsets meet the 256b alignment requirement\n\t    readonly WORKGROUP_SIZE: number = 64;\n", "    readonly #maxDispatchSize: number;\n\t    #computePipeline: GPUComputePipeline;\n\t    private constructor(device: GPUDevice)\n\t    {\n\t        this.#device = device;\n\t        this.#maxDispatchSize = device.limits.maxComputeWorkgroupsPerDimension;\n\t    }\n\t    static async create(device: GPUDevice)\n\t    {\n\t        let self = new StreamCompactIDs(device);\n", "        let paramsBGLayout = device.createBindGroupLayout({\n\t            entries: [\n\t                {\n\t                    binding: 0,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n\t                        hasDynamicOffset: true,\n\t                    }\n\t                },\n", "                {\n\t                    binding: 1,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n\t                        hasDynamicOffset: true,\n\t                    }\n\t                },\n\t                {\n\t                    binding: 2,\n", "                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {\n\t                        type: \"storage\",\n\t                    }\n\t                },\n\t            ],\n\t        });\n\t        let pushConstantsBGLayout = device.createBindGroupLayout({\n\t            entries: [\n\t                {\n", "                    binding: 0,\n\t                    visibility: GPUShaderStage.COMPUTE,\n\t                    buffer: {type: \"uniform\", hasDynamicOffset: true}\n\t                },\n\t            ]\n\t        });\n\t        self.#computePipeline = device.createComputePipeline({\n\t            layout: device.createPipelineLayout(\n\t                {bindGroupLayouts: [paramsBGLayout, pushConstantsBGLayout]}),\n\t            compute: {\n", "                module: await compileShader(device, streamCompactIDs, \"StreamCompactIDs\"),\n\t                entryPoint: \"main\",\n\t                constants: {\"0\": self.WORKGROUP_SIZE}\n\t            }\n\t        });\n\t        return self;\n\t    }\n\t    async compactActiveIDs(isActiveBuffer: GPUBuffer,\n\t        offsetBuffer: GPUBuffer,\n\t        idOutputBuffer: GPUBuffer,\n", "        size: number)\n\t    {\n\t        // Build the push constants\n\t        let pushConstantsArg = new Uint32Array([size]);\n\t        let pushConstants = new PushConstants(\n\t            this.#device, Math.ceil(size / this.WORKGROUP_SIZE), pushConstantsArg.buffer);\n\t        let pushConstantsBG = this.#device.createBindGroup({\n\t            layout: this.#computePipeline.getBindGroupLayout(1),\n\t            entries: [{\n\t                binding: 0,\n", "                resource: {\n\t                    buffer: pushConstants.pushConstantsBuffer,\n\t                    size: 12,\n\t                }\n\t            }]\n\t        });\n\t        // # of elements we can compact in a single dispatch.\n\t        const elementsPerDispatch = this.#maxDispatchSize * this.WORKGROUP_SIZE;\n\t        // Ensure we won't break the dynamic offset alignment rules\n\t        if (pushConstants.numDispatches() > 1 && (elementsPerDispatch * 4) % 256 != 0) {\n", "            throw Error(\n\t                \"StreamCompactIDs: Buffer dynamic offsets will not be 256b aligned! Set WORKGROUP_SIZE = 64\");\n\t        }\n\t        // With dynamic offsets the size/offset validity checking means we still need to\n\t        // create a separate bind group for the remainder elements that don't evenly fall into\n\t        // a full size dispatch\n\t        let paramsBG = this.#device.createBindGroup({\n\t            layout: this.#computePipeline.getBindGroupLayout(0),\n\t            entries: [\n\t                {\n", "                    binding: 0,\n\t                    resource: {\n\t                        buffer: isActiveBuffer,\n\t                        size: Math.min(size, elementsPerDispatch) * 4,\n\t                    }\n\t                },\n\t                {\n\t                    binding: 1,\n\t                    resource: {\n\t                        buffer: offsetBuffer,\n", "                        size: Math.min(size, elementsPerDispatch) * 4,\n\t                    }\n\t                },\n\t                {\n\t                    binding: 2,\n\t                    resource: {\n\t                        buffer: idOutputBuffer,\n\t                    }\n\t                }\n\t            ]\n", "        });\n\t        // Make a remainder elements bindgroup if we have some remainder to make sure\n\t        // we don't bind out of bounds regions of the buffer. If there's no remiander we\n\t        // just set remainderParamsBG to paramsBG so that on our last dispatch we can just\n\t        // always bindg remainderParamsBG\n\t        let remainderParamsBG = paramsBG;\n\t        const remainderElements = size % elementsPerDispatch;\n\t        if (remainderElements != 0) {\n\t            // Note: We don't set the offset here, as that will still be handled by the\n\t            // dynamic offsets. We just need to set the right size, so that\n", "            // dynamic offset + binding size is >= buffer size\n\t            remainderParamsBG = this.#device.createBindGroup({\n\t                layout: this.#computePipeline.getBindGroupLayout(0),\n\t                entries: [\n\t                    {\n\t                        binding: 0,\n\t                        resource: {\n\t                            buffer: isActiveBuffer,\n\t                            size: remainderElements * 4,\n\t                        }\n", "                    },\n\t                    {\n\t                        binding: 1,\n\t                        resource: {\n\t                            buffer: offsetBuffer,\n\t                            size: remainderElements * 4,\n\t                        }\n\t                    },\n\t                    {\n\t                        binding: 2,\n", "                        resource: {\n\t                            buffer: idOutputBuffer,\n\t                        }\n\t                    }\n\t                ]\n\t            });\n\t        }\n\t        let commandEncoder = this.#device.createCommandEncoder();\n\t        let pass = commandEncoder.beginComputePass();\n\t        pass.setPipeline(this.#computePipeline);\n", "        for (let i = 0; i < pushConstants.numDispatches(); ++i) {\n\t            let dispatchParamsBG = paramsBG;\n\t            if (i + 1 == pushConstants.numDispatches()) {\n\t                dispatchParamsBG = remainderParamsBG;\n\t            }\n\t            pass.setBindGroup(0,\n\t                dispatchParamsBG,\n\t                [i * elementsPerDispatch * 4, i * elementsPerDispatch * 4]);\n\t            pass.setBindGroup(1, pushConstantsBG, [i * pushConstants.stride]);\n\t            pass.dispatchWorkgroups(pushConstants.dispatchSize(i), 1, 1);\n", "        }\n\t        pass.end();\n\t        this.#device.queue.submit([commandEncoder.finish()]);\n\t        await this.#device.queue.onSubmittedWorkDone();\n\t    }\n\t}\n"]}
