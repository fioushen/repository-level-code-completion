{"filename": "test/app.e2e-spec.ts", "chunked_list": ["import { Test, TestingModule } from '@nestjs/testing';\n\timport { INestApplication } from '@nestjs/common';\n\timport * as request from 'supertest';\n\timport { AppModule } from './../src/app.module';\n\tdescribe('AppController (e2e)', () => {\n\t  let app: INestApplication;\n\t  beforeEach(async () => {\n\t    const moduleFixture: TestingModule = await Test.createTestingModule({\n\t      imports: [AppModule],\n\t    }).compile();\n", "    app = moduleFixture.createNestApplication();\n\t    app.setGlobalPrefix('v1');\n\t    await app.init();\n\t  });\n\t  afterEach(async () => {\n\t    await app.close(); // close the app instance after each test\n\t  });\n\t  it('/v1 (GET)', async () => {\n\t    return await request(app.getHttpServer()).get('/v1').expect(404);\n\t  });\n", "});\n"]}
{"filename": "test/developers.e2e-spec.ts", "chunked_list": ["import { Test, TestingModule } from '@nestjs/testing';\n\timport { INestApplication, ValidationPipe } from '@nestjs/common';\n\timport * as request from 'supertest';\n\timport { AppModule } from '../src/app.module';\n\tdescribe('DeveloperController (e2e)', () => {\n\t  let app: INestApplication;\n\t  const headers = {\n\t    'Content-Type': 'application/json',\n\t  };\n\t  let id: string;\n", "  beforeEach(async () => {\n\t    const moduleFixture: TestingModule = await Test.createTestingModule({\n\t      imports: [AppModule],\n\t    }).compile();\n\t    app = moduleFixture.createNestApplication();\n\t    app.setGlobalPrefix('v1');\n\t    app.useGlobalPipes(new ValidationPipe());\n\t    await app.init();\n\t  });\n\t  afterEach(async () => {\n", "    await app.close();\n\t  });\n\t  // create a developer\n\t  describe('POST /v1/developers', () => {\n\t    it('should create a new developer with valid request', async () => {\n\t      const response = await request(app.getHttpServer())\n\t        .post(`/v1/developers`)\n\t        .set(headers)\n\t        .send({\n\t          name: 'Olha Gaievska',\n", "          email: 'tester@mail.com',\n\t          level: 'senior',\n\t        });\n\t      expect(response.status).toBe(201);\n\t      expect(response.body).toBeInstanceOf(Object);\n\t      expect(response.body._id).toBeDefined();\n\t      id = response.body._id;\n\t    });\n\t    it('should return failed with invalid request to create developer', async () => {\n\t      const response = await request(app.getHttpServer())\n", "        .post(`/v1/developers`)\n\t        .set(headers)\n\t        .send({\n\t          name: '',\n\t          email: '',\n\t          level: 'backend',\n\t        });\n\t      expect(response.status).toBe(400);\n\t      expect(response.body).toBeInstanceOf(Object);\n\t      expect(response.body).toEqual({\n", "        statusCode: 400,\n\t        message: [\n\t          'name must be longer than or equal to 3 characters',\n\t          'email should not be empty',\n\t          'email must be an email',\n\t          'level must be one of the following values: junior, senior',\n\t        ],\n\t        error: 'Bad Request',\n\t      });\n\t    });\n", "  });\n\t  // return all developers\n\t  describe('GET /v1/developers', () => {\n\t    it('should return all the developers with valid request', async () => {\n\t      const response = await request(app.getHttpServer())\n\t        .get(`/v1/developers`)\n\t        .set(headers)\n\t        .send();\n\t      expect(response.status).toBe(200);\n\t      expect(response.body).toBeInstanceOf(Array);\n", "    });\n\t  });\n\t  // return a specific developer\n\t  describe('GET /v1/developers/{id}', () => {\n\t    it('should return the specific developer with valid id', async () => {\n\t      const response = await request(app.getHttpServer())\n\t        .get(`/v1/developers/${id}`)\n\t        .set(headers)\n\t        .send();\n\t      expect(response.status).toBe(200);\n", "      expect(response.body).toBeInstanceOf(Object);\n\t      expect(response.body._id).toBeDefined();\n\t      expect(response.body.name).toBeDefined();\n\t      expect(response.body.email).toBeDefined();\n\t      expect(response.body.level).toBeDefined();\n\t    });\n\t    it('should return failed for the wrong developer id', async () => {\n\t      const response = await request(app.getHttpServer())\n\t        .get(`/v1/developers/${id}e404`)\n\t        .set(headers)\n", "        .send();\n\t      expect(response.status).toBe(404);\n\t      expect(response.body.error).toEqual('Not Found');\n\t      expect(response.body.message).toEqual('developer not found!');\n\t    });\n\t  });\n\t  // filter by level\n\t  describe('POST /v1/developers/filter', () => {\n\t    it('should return the filtered developers by level', async () => {\n\t      const response = await request(app.getHttpServer())\n", "        .post(`/v1/developers/filter`)\n\t        .set(headers)\n\t        .send({ level: 'senior' });\n\t      expect(response.status).toBe(201);\n\t      expect(response.body).toBeInstanceOf(Array);\n\t    });\n\t  });\n\t  // edit a developer\n\t  describe('PUT /v1/developers/{id}', () => {\n\t    it('should update the developer information with valid request', async () => {\n", "      const response = await request(app.getHttpServer())\n\t        .put(`/v1/developers/${id}`)\n\t        .set(headers)\n\t        .send({ email: 'olhag@mail.com', level: 'junior' });\n\t      expect(response.status).toBe(200);\n\t      expect(response.body).toBeInstanceOf(Object);\n\t    });\n\t    it('should return failed to update for a wrong developer id', async () => {\n\t      const response = await request(app.getHttpServer())\n\t        .put(`/v1/developers/${id}e404`)\n", "        .set(headers)\n\t        .send({ email: 'olhag@mail.com', level: 'junior' });\n\t      expect(response.status).toBe(404);\n\t      expect(response.body.error).toEqual('Not Found');\n\t    });\n\t    it('should return failed with invalid request to update developer', async () => {\n\t      const response = await request(app.getHttpServer())\n\t        .put(`/v1/developers/${id}`)\n\t        .set(headers)\n\t        .send({ level: 'lead' });\n", "      expect(response.status).toBe(400);\n\t      expect(response.body.error).toEqual('Bad Request');\n\t      expect(response.body.message[0]).toEqual(\n\t        'level must be one of the following values: junior, senior',\n\t      );\n\t    });\n\t  });\n\t  // delete a developer\n\t  describe('DELETE /v1/developers/{id}', () => {\n\t    it('should delete successfully the developer with valid id', async () => {\n", "      const response = await request(app.getHttpServer())\n\t        .delete(`/v1/developers/${id}`)\n\t        .set(headers)\n\t        .send();\n\t      expect(response.status).toBe(200);\n\t      expect(response.body.message).toEqual('The data has been deleted successfully');\n\t    });\n\t    it('should return failed to delete for a wrong developer id', async () => {\n\t      const response = await request(app.getHttpServer())\n\t        .delete(`/v1/developers/${id}`)\n", "        .set(headers)\n\t        .send();\n\t      expect(response.status).toBe(404);\n\t      expect(response.body.error).toEqual('Not Found');\n\t      expect(response.body.message).toEqual('failed to delete developer!');\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { NestFactory } from '@nestjs/core';\n\timport { NestExpressApplication } from '@nestjs/platform-express';\n\timport { ValidationPipe } from '@nestjs/common';\n\timport { AppModule } from './app.module';\n\tasync function bootstrap() {\n\t  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\t  app.setGlobalPrefix('v1');\n\t  app.useGlobalPipes(\n\t    new ValidationPipe({\n\t      whitelist: true,\n", "    }),\n\t  );\n\t  // port initialize\n\t  const port = process.env.PORT || 3000;\n\t  await app.listen(port, () => {\n\t    console.log(`Listening on port ${port}!`);\n\t  });\n\t}\n\tbootstrap();\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { ConfigModule, ConfigService } from '@nestjs/config';\n\timport { CacheInterceptor, CacheModule, CacheStore } from '@nestjs/cache-manager';\n\timport { DeveloperModule } from './developer/developer.module';\n\timport { APP_INTERCEPTOR } from '@nestjs/core';\n\timport { MongooseModule } from '@nestjs/mongoose';\n\timport { redisStore } from 'cache-manager-redis-store';\n\timport type { RedisClientOptions } from 'redis';\n\t@Module({\n\t  imports: [\n", "    ConfigModule.forRoot({ isGlobal: true }),\n\t    ...(process.env.NODE_ENV !== 'development'\n\t      ? [\n\t          MongooseModule.forRootAsync({\n\t            imports: [ConfigModule],\n\t            inject: [ConfigService],\n\t            useFactory: async (config: ConfigService) => ({\n\t              uri: config.get<string>('MONGODB_URI', 'mongodb://localhost:27017/test'),\n\t            }),\n\t          }),\n", "        ]\n\t      : []),\n\t    CacheModule.registerAsync<RedisClientOptions>({\n\t      imports: [ConfigModule],\n\t      inject: [ConfigService],\n\t      useFactory: async (config: ConfigService) => {\n\t        const options = {\n\t          store: redisStore as unknown as CacheStore,\n\t          url: config.get<string>('REDIS_URL', 'redis://localhost:6379'),\n\t          ttl: config.get<number>('CACHE_TTL', 180), // 3 * 60 = 3 minutes\n", "        };\n\t        // set a different TTL for development environment\n\t        if (config.get<string>('NODE_ENV') === 'development') {\n\t          options.ttl = 1800; // 30 minutes\n\t        }\n\t        return options;\n\t      },\n\t      isGlobal: true,\n\t    }),\n\t    DeveloperModule,\n", "  ],\n\t  providers: [\n\t    {\n\t      provide: APP_INTERCEPTOR,\n\t      useFactory: () => {\n\t        if (process.env.NODE_ENV === 'development') {\n\t          return null;\n\t        }\n\t        return CacheInterceptor;\n\t      },\n", "    },\n\t  ],\n\t})\n\texport class AppModule {}\n"]}
{"filename": "src/developer/in-memory-developer.service.ts", "chunked_list": ["import { CACHE_MANAGER } from '@nestjs/cache-manager';\n\timport { Cache } from 'cache-manager';\n\timport {\n\t  HttpException,\n\t  HttpStatus,\n\t  Inject,\n\t  Injectable,\n\t  NotFoundException,\n\t} from '@nestjs/common';\n\timport { DeveloperDTO, PartialDeveloperDTO } from './dto';\n", "import { randomUUID } from 'crypto';\n\timport { IDeveloperService, IDeveloper } from 'src/core/interfaces/IDeveloperService';\n\t@Injectable()\n\texport class InMemoryDeveloperService implements IDeveloperService {\n\t  private key = 'developers';\n\t  constructor(@Inject(CACHE_MANAGER) private readonly cacheManager: Cache) {}\n\t  async create(dto: DeveloperDTO): Promise<object> {\n\t    const data: IDeveloper = {\n\t      _id: this.uuid(),\n\t      name: dto.name,\n", "      email: dto.email,\n\t      level: dto.level,\n\t    };\n\t    const cached = await this.cacheManager.get(this.key);\n\t    if (cached) {\n\t      const jsonArray = JSON.parse(cached as unknown as string);\n\t      jsonArray.push(data);\n\t      await this.cacheManager.del(this.key);\n\t      await this.cacheManager.set(this.key, JSON.stringify(jsonArray), 0);\n\t      return data;\n", "    }\n\t    const developers = [];\n\t    developers.push(data);\n\t    await this.cacheManager.set(this.key, JSON.stringify(developers), 0);\n\t    return data;\n\t  }\n\t  async readBatch(): Promise<object[]> {\n\t    const cached = await this.cacheManager.get(this.key);\n\t    return JSON.parse(cached as unknown as string);\n\t  }\n", "  async read(id: string): Promise<object> {\n\t    const cached = await this.cacheManager.get(this.key);\n\t    if (cached) {\n\t      const developers = JSON.parse(cached as unknown as string);\n\t      const developer = developers.find(\n\t        (developer: { _id: string }) => developer._id === id,\n\t      );\n\t      if (!developer) throw new NotFoundException(`developer not found!`);\n\t      return developer;\n\t    }\n", "    throw new NotFoundException(`developer not found!`);\n\t  }\n\t  async filterByLevel(dto: PartialDeveloperDTO): Promise<object[]> {\n\t    const cached = await this.cacheManager.get(this.key);\n\t    const developers = JSON.parse(cached as unknown as string);\n\t    return developers.filter(\n\t      (developer: { level: string }) => developer.level === dto.level,\n\t    );\n\t  }\n\t  async update(id: string, dto: PartialDeveloperDTO): Promise<object> {\n", "    const cached = await this.cacheManager.get(this.key);\n\t    const developers = JSON.parse(cached as unknown as string);\n\t    const index = developers.findIndex(\n\t      (developer: { _id: { toString: () => string } }) => developer._id.toString() === id,\n\t    );\n\t    if (index < 0) throw new NotFoundException(`failed to update developer!`);\n\t    const updated = Object.assign(developers[index], dto);\n\t    developers[index] = updated;\n\t    await this.cacheManager.del(this.key);\n\t    await this.cacheManager.set(this.key, JSON.stringify(developers), 0);\n", "    return updated;\n\t  }\n\t  async delete(id: string): Promise<HttpException> {\n\t    const cached = await this.cacheManager.get(this.key);\n\t    const developers = JSON.parse(cached as unknown as string);\n\t    const index = developers.findIndex((developer) => developer._id === id);\n\t    if (index === -1) throw new NotFoundException(`failed to delete developer!`);\n\t    developers.splice(index, 1);\n\t    await this.cacheManager.del(this.key);\n\t    await this.cacheManager.set(this.key, JSON.stringify(developers), 0);\n", "    throw new HttpException('The data has been deleted successfully', HttpStatus.OK);\n\t  }\n\t  private uuid(): string {\n\t    return randomUUID();\n\t  }\n\t}\n"]}
{"filename": "src/developer/developer.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { DeveloperController } from './developer.controller';\n\timport { DeveloperService } from './developer.service';\n\timport { Developer, DeveloperSchema } from './schemas/developer.schema';\n\timport { MongooseModule } from '@nestjs/mongoose';\n\timport { InMemoryDeveloperService } from './in-memory-developer.service';\n\t@Module({\n\t  imports: [\n\t    ...(process.env.NODE_ENV !== 'development'\n\t      ? [MongooseModule.forFeature([{ name: Developer.name, schema: DeveloperSchema }])]\n", "      : []),\n\t  ],\n\t  controllers: [DeveloperController],\n\t  providers: [\n\t    ...(process.env.NODE_ENV !== 'development'\n\t      ? [DeveloperService]\n\t      : [InMemoryDeveloperService]),\n\t  ],\n\t})\n\texport class DeveloperModule {}\n"]}
{"filename": "src/developer/developer.controller.ts", "chunked_list": ["import { Body, Controller, Inject, Param, Get, Post, Put, Delete } from '@nestjs/common';\n\timport { DeveloperDTO, PartialDeveloperDTO } from './dto';\n\timport { DeveloperService } from './developer.service';\n\timport { InMemoryDeveloperService } from './in-memory-developer.service';\n\t@Controller('developers')\n\texport class DeveloperController {\n\t  constructor(\n\t    @Inject(\n\t      process.env.NODE_ENV === 'development'\n\t        ? InMemoryDeveloperService\n", "        : DeveloperService,\n\t    )\n\t    private readonly developerService: DeveloperService,\n\t  ) {}\n\t  @Post()\n\t  postDeveloper(@Body() dto: DeveloperDTO): object {\n\t    return this.developerService.create(dto);\n\t  }\n\t  @Post('filter')\n\t  filterDevelopersByLevel(@Body() dto: PartialDeveloperDTO): object {\n", "    return this.developerService.filterByLevel(dto);\n\t  }\n\t  @Get()\n\t  getDevelopers(): object {\n\t    return this.developerService.readBatch();\n\t  }\n\t  @Get(':id')\n\t  getDeveloper(@Param('id') id: string): object {\n\t    return this.developerService.read(id);\n\t  }\n", "  @Put(':id')\n\t  putDeveloper(@Param('id') id: string, @Body() dto: PartialDeveloperDTO): object {\n\t    return this.developerService.update(id, dto);\n\t  }\n\t  @Delete(':id')\n\t  deleteDeveloper(@Param('id') id: string): object {\n\t    return this.developerService.delete(id);\n\t  }\n\t}\n"]}
{"filename": "src/developer/developer.service.ts", "chunked_list": ["import {\n\t  HttpException,\n\t  HttpStatus,\n\t  Inject,\n\t  Injectable,\n\t  NotFoundException,\n\t} from '@nestjs/common';\n\timport { CACHE_MANAGER } from '@nestjs/cache-manager';\n\timport { Cache } from 'cache-manager';\n\timport { InjectModel } from '@nestjs/mongoose';\n", "import { Model } from 'mongoose';\n\timport { DeveloperDTO, PartialDeveloperDTO } from './dto';\n\timport { Developer, DeveloperDocument } from './schemas/developer.schema';\n\timport { IDeveloperService } from '../core/interfaces/IDeveloperService';\n\t@Injectable()\n\texport class DeveloperService implements IDeveloperService {\n\t  constructor(\n\t    @InjectModel(Developer.name)\n\t    private developerModel: Model<DeveloperDocument>,\n\t    @Inject(CACHE_MANAGER) private readonly cacheManager: Cache,\n", "  ) {}\n\t  async create(dto: DeveloperDTO): Promise<DeveloperDocument> {\n\t    try {\n\t      const developer = await this.developerModel.create(dto);\n\t      if (!developer) throw new NotFoundException(`failed to create developer!`);\n\t      return developer;\n\t    } catch (error) {\n\t      throw new NotFoundException(`failed to create developer for duplicate email!`);\n\t    }\n\t  }\n", "  async readBatch(): Promise<DeveloperDocument[]> {\n\t    return await this.developerModel.find().exec();\n\t  }\n\t  async read(id: string): Promise<DeveloperDocument> {\n\t    try {\n\t      const cacheKey = `developer:${id}`;\n\t      const cached = await this.cacheManager.get(cacheKey);\n\t      if (cached) {\n\t        return JSON.parse(cached as unknown as string);\n\t      }\n", "      const developer = await this.developerModel.findById(id);\n\t      if (!developer) throw new NotFoundException(`developer not found!`);\n\t      await this.cacheManager.set(cacheKey, JSON.stringify(developer), 0);\n\t      return developer;\n\t    } catch (error) {\n\t      throw new NotFoundException(`developer not found!`);\n\t    }\n\t  }\n\t  async filterByLevel(dto: PartialDeveloperDTO): Promise<DeveloperDocument[]> {\n\t    try {\n", "      const cacheKey = `developers:${dto.level}`;\n\t      const cached = await this.cacheManager.get(cacheKey);\n\t      if (cached) return JSON.parse(cached as unknown as string);\n\t      const developers = await this.developerModel.find({ level: dto.level }).exec();\n\t      if (developers) {\n\t        await this.cacheManager.set(cacheKey, JSON.stringify(developers), 0);\n\t      }\n\t      return developers;\n\t    } catch (error) {\n\t      throw new NotFoundException(`failed to filter developer!`);\n", "    }\n\t  }\n\t  async update(id: string, dto: PartialDeveloperDTO): Promise<DeveloperDocument> {\n\t    const { _id } = await this.read(id);\n\t    const developer = await this.developerModel.findByIdAndUpdate(_id, dto, {\n\t      new: true,\n\t    });\n\t    if (!developer) throw new NotFoundException(`failed to update developer!`);\n\t    const cacheKey = `developer:${id}`;\n\t    await this.cacheManager.set(cacheKey, JSON.stringify(developer), 0);\n", "    return developer;\n\t  }\n\t  async delete(id: string): Promise<HttpException> {\n\t    const developer = await this.developerModel.findByIdAndDelete(id);\n\t    if (!developer) throw new NotFoundException(`failed to delete developer!`);\n\t    const cacheKey = `developer:${id}`;\n\t    const cached = await this.cacheManager.get(cacheKey);\n\t    if (cached) await this.cacheManager.del(cacheKey);\n\t    throw new HttpException('The data has been deleted successfully', HttpStatus.OK);\n\t  }\n", "}\n"]}
{"filename": "src/developer/schemas/developer.schema.ts", "chunked_list": ["import { EDeveloperLevel } from './../../core/enums/EDeveloper';\n\timport { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\n\timport { HydratedDocument } from 'mongoose';\n\texport type DeveloperDocument = HydratedDocument<Developer>;\n\t@Schema()\n\texport class Developer {\n\t  @Prop()\n\t  name: string;\n\t  @Prop({ unique: true })\n\t  email: string;\n", "  @Prop({ type: String, enum: EDeveloperLevel, default: EDeveloperLevel.JUNIOR })\n\t  level: EDeveloperLevel;\n\t}\n\texport const DeveloperSchema = SchemaFactory.createForClass(Developer);\n"]}
{"filename": "src/developer/dto/developer.dto.ts", "chunked_list": ["import {\n\t  IsEmail,\n\t  IsEnum,\n\t  IsNotEmpty,\n\t  IsOptional,\n\t  IsString,\n\t  Length,\n\t} from 'class-validator';\n\timport { PartialType } from '@nestjs/mapped-types';\n\timport { EDeveloperLevel } from './../../core/enums/EDeveloper';\n", "export class DeveloperDTO {\n\t  @IsString()\n\t  @Length(3)\n\t  name: string;\n\t  @IsEmail()\n\t  @IsNotEmpty()\n\t  email: string;\n\t  @IsString()\n\t  @IsEnum(EDeveloperLevel)\n\t  @IsOptional()\n", "  level: EDeveloperLevel;\n\t}\n\texport class PartialDeveloperDTO extends PartialType(DeveloperDTO) {}\n"]}
{"filename": "src/developer/dto/index.ts", "chunked_list": ["export * from './developer.dto';\n"]}
{"filename": "src/core/interfaces/IDeveloperService.ts", "chunked_list": ["import { EDeveloperLevel } from '../enums/EDeveloper';\n\timport { IService } from './IService';\n\timport { DeveloperDocument } from '../../developer/schemas/developer.schema';\n\timport { DeveloperDTO, PartialDeveloperDTO } from 'src/developer/dto';\n\timport { HttpException } from '@nestjs/common';\n\texport interface IDeveloperService extends IService<DeveloperDTO, PartialDeveloperDTO> {\n\t  developer?: IDeveloper;\n\t  /**\n\t   * create record\n\t   */\n", "  create(dto: DeveloperDTO): Promise<DeveloperDocument | object>;\n\t  /**\n\t   * get the full records\n\t   */\n\t  readBatch(): Promise<DeveloperDocument[] | object[]>;\n\t  /**\n\t   * get a single record\n\t   */\n\t  read(id: string): Promise<DeveloperDocument | object>;\n\t  /**\n", "   * get all the developers by level\n\t   */\n\t  filterByLevel(dto: PartialDeveloperDTO): Promise<DeveloperDocument[] | object[]>;\n\t  /**\n\t   * update a single record\n\t   */\n\t  update(id: string, dto: PartialDeveloperDTO): Promise<DeveloperDocument | object>;\n\t  /**\n\t   * delete a single record\n\t   */\n", "  delete(id: string): Promise<HttpException>;\n\t}\n\texport interface IDeveloper {\n\t  readonly _id: string;\n\t  name: string;\n\t  email: string;\n\t  level: EDeveloperLevel.JUNIOR | EDeveloperLevel.SENIOR;\n\t}\n"]}
{"filename": "src/core/interfaces/IService.ts", "chunked_list": ["export interface IService<T, PT> {\n\t  /**\n\t   * create record\n\t   */\n\t  create(dto?: T);\n\t  /**\n\t   * get the full records\n\t   */\n\t  readBatch();\n\t  /**\n", "   * get a single record\n\t   */\n\t  read(id?: string);\n\t  /**\n\t   * update a single record\n\t   */\n\t  update(id?: string, dto?: PT);\n\t  /**\n\t   * delete a single record\n\t   */\n", "  delete(id?: string);\n\t}\n"]}
{"filename": "src/core/enums/EDeveloper.ts", "chunked_list": ["export enum EDeveloperLevel {\n\t  JUNIOR = 'junior',\n\t  SENIOR = 'senior',\n\t}\n"]}
