{"filename": "examples/classes.ts", "chunked_list": ["import type { Component, Mixed } from \"@susisu/hokemi\";\n\timport { impl, mixer } from \"@susisu/hokemi\";\n\t// 1. Declare components\n\texport interface Clock {\n\t  getTime(): number;\n\t}\n\texport type ClockComponent = Component<\"clock\", Clock>;\n\texport interface Random {\n\t  getRandom(): number;\n\t}\n", "export type RandomComponent = Component<\"random\", Random>;\n\texport interface MyService {\n\t  getTimeAndRandom(): [number, number];\n\t}\n\texport type MyServiceComponent = Component<\"myService\", MyService>;\n\t// 2. Implement components\n\tclass ClockImpl implements Clock {\n\t  getTime(): number {\n\t    return Date.now();\n\t  }\n", "}\n\texport const clockImpl = impl<ClockComponent>(\"clock\", ClockImpl);\n\tclass RandomImpl implements Random {\n\t  getRandom(): number {\n\t    return Math.random();\n\t  }\n\t}\n\texport const randomImpl = impl<RandomComponent>(\"random\", RandomImpl);\n\tclass MyServiceImpl implements MyService {\n\t  private clock: Clock;\n", "  private random: Random;\n\t  constructor({ clock, random }: Mixed<[ClockComponent, RandomComponent]>) {\n\t    this.clock = clock;\n\t    this.random = random;\n\t  }\n\t  getTimeAndRandom(): [number, number] {\n\t    return [this.clock.getTime(), this.random.getRandom()];\n\t  }\n\t}\n\texport const myServiceImpl = impl<MyServiceComponent, [ClockComponent, RandomComponent]>(\n", "  \"myService\",\n\t  MyServiceImpl\n\t);\n\t// 3. Mix implementations and create an instance\n\tconst app = mixer(myServiceImpl, clockImpl, randomImpl).new();\n\tconsole.log(app.myService.getTimeAndRandom());\n"]}
{"filename": "examples/basic.ts", "chunked_list": ["import type { Component } from \"@susisu/hokemi\";\n\timport { impl, mixer } from \"@susisu/hokemi\";\n\t// 1. Declare components\n\texport type Clock = {\n\t  getTime: () => number;\n\t};\n\texport type ClockComponent = Component<\"clock\", Clock>;\n\texport type Random = {\n\t  getRandom: () => number;\n\t};\n", "export type RandomComponent = Component<\"random\", Random>;\n\texport type MyService = {\n\t  getTimeAndRandom: () => [number, number];\n\t};\n\texport type MyServiceComponent = Component<\"myService\", MyService>;\n\t// 2. Implement components\n\texport const clockImpl = impl<ClockComponent>(\"clock\", () => ({\n\t  getTime: () => Date.now(),\n\t}));\n\texport const randomImpl = impl<RandomComponent>(\"random\", () => ({\n", "  getRandom: () => Math.random(),\n\t}));\n\texport const myServiceImpl = impl<MyServiceComponent, [ClockComponent, RandomComponent]>(\n\t  \"myService\",\n\t  ({ clock, random }) => ({\n\t    getTimeAndRandom: () => [clock.getTime(), random.getRandom()],\n\t  })\n\t);\n\t// 3. Mix implementations and create an instance\n\tconst app = mixer(myServiceImpl, clockImpl, randomImpl).new();\n", "console.log(app.myService.getTimeAndRandom());\n"]}
{"filename": "src/provider.ts", "chunked_list": ["import type { AbstractComponent, Component, Mixed } from \"./component\";\n\t/**\n\t * `Provider<N, T, D>` represents a component provider.\n\t * @param N The name of the component.\n\t * @param T The type of the provided instance.\n\t * @param D The type of the dependencies.\n\t */\n\texport type Provider<N extends string, T extends unknown, D extends unknown> = Readonly<{\n\t  // eslint-disable-next-line @typescript-eslint/naming-convention\n\t  __type: \"hokemi.type.Provider\";\n", "  name: N;\n\t  factory: Factory<T, D>;\n\t}>;\n\texport type Factory<T extends unknown, D extends unknown> =\n\t  | FactoryFunction<T, D>\n\t  | FactoryClass<T, D>;\n\texport type FactoryFunction<T extends unknown, D extends unknown> = (deps: D) => T;\n\texport type FactoryClass<T extends unknown, D extends unknown> = new (deps: D) => T;\n\texport function invokecFactory<T extends unknown, D extends unknown>(\n\t  factory: Factory<T, D>,\n", "  deps: D\n\t): T {\n\t  // check if the factory is a class (not a perfect check though)\n\t  const desc = Object.getOwnPropertyDescriptor(factory, \"prototype\");\n\t  if (desc && !desc.writable) {\n\t    // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n\t    return new (factory as FactoryClass<T, D>)(deps);\n\t  } else {\n\t    // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n\t    return (factory as FactoryFunction<T, D>)(deps);\n", "  }\n\t}\n\t/**\n\t * The upper bound of provider types.\n\t */\n\texport type AbstractProvider = Provider<string, unknown, never>;\n\texport type ProviderName<P extends AbstractProvider> = P extends Provider<infer N, unknown, never>\n\t  ? N\n\t  : never;\n\texport type ProviderDependencies<P extends AbstractProvider> = (\n", "  P extends Provider<string, unknown, infer D> ? (deps: D) => unknown : never\n\t) extends (deps: infer I) => unknown\n\t  ? I\n\t  : never;\n\texport type ReconstructComponent<P extends AbstractProvider> = P extends Provider<\n\t  infer N,\n\t  infer T,\n\t  never\n\t>\n\t  ? Component<N, T>\n", "  : never;\n\texport type MixedProvidedInstance<Ps extends AbstractProvider[]> = Mixed<{\n\t  [K in keyof Ps]: ReconstructComponent<Ps[K]>;\n\t}>;\n\t/**\n\t * Returns the provider type that implements a component.\n\t * @param C A component.\n\t * @param Ds A list of dependencies.\n\t */\n\texport type Impl<\n", "  C extends AbstractComponent,\n\t  Ds extends AbstractComponent[] = [],\n\t> = C extends Component<infer N, infer T> ? Provider<N, T, Mixed<Ds>> : never;\n\texport type ImplArgs<C extends AbstractComponent, Ds extends AbstractComponent[] = []> = _ImplArgs<\n\t  Impl<C, Ds>\n\t>;\n\ttype _ImplArgs<P extends AbstractProvider> = P extends Provider<infer N, infer T, infer D>\n\t  ? [name: N, factory: Factory<T, D>]\n\t  : never;\n\t/**\n", " * Creates an implementation of a component.\n\t * @param name The name of the component.\n\t * @param factory A factory function or class that creates an instance of the component.\n\t * @returns An implementation (provider) of the component.\n\t */\n\texport function impl<C extends AbstractComponent, Ds extends AbstractComponent[] = []>(\n\t  ...[name, factory]: ImplArgs<C, Ds>\n\t): Impl<C, Ds> {\n\t  const provider: AbstractProvider = {\n\t    // eslint-disable-next-line @typescript-eslint/naming-convention\n", "    __type: \"hokemi.type.Provider\",\n\t    name,\n\t    factory,\n\t  };\n\t  // ImplArgs<C, Ds> and Impl<C, Ds> always have the same shape, so it's safe to cast.\n\t  // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n\t  return provider as Impl<C, Ds>;\n\t}\n"]}
{"filename": "src/provider.spec.ts", "chunked_list": ["import type { Equals } from \"./__tests__/types\";\n\timport { assertType } from \"./__tests__/types\";\n\timport type { Component } from \"./component\";\n\timport type {\n\t  Factory,\n\t  Impl,\n\t  ImplArgs,\n\t  MixedProvidedInstance,\n\t  Provider,\n\t  ProviderDependencies,\n", "  ProviderName,\n\t  ReconstructComponent,\n\t} from \"./provider\";\n\timport { invokecFactory, impl } from \"./provider\";\n\tdescribe(\"invokecFactory\", () => {\n\t  it(\"calls the argument if it is a function\", () => {\n\t    type Foo = { getFoo: () => number };\n\t    const factory = (foo: number): Foo => ({ getFoo: () => foo });\n\t    const value = invokecFactory(factory, 42);\n\t    assertType<Equals<typeof value, Foo>>();\n", "    expect(value.getFoo()).toBe(42);\n\t  });\n\t  it(\"calls the constructor of the argument if it is a class\", () => {\n\t    const factory = class Foo {\n\t      private foo: number;\n\t      constructor(foo: number) {\n\t        this.foo = foo;\n\t      }\n\t      getFoo(): number {\n\t        return this.foo;\n", "      }\n\t    };\n\t    const value = invokecFactory(factory, 42);\n\t    assertType<Equals<typeof value, InstanceType<typeof factory>>>();\n\t    expect(value.getFoo()).toBe(42);\n\t  });\n\t});\n\tdescribe(\"ProviderName\", () => {\n\t  it(\"returns the name of the provider\", () => {\n\t    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n", "    assertType<Equals<ProviderName<FooProvider>, \"foo\">>();\n\t  });\n\t  it(\"distributes over union members\", () => {\n\t    assertType<Equals<ProviderName<never>, never>>();\n\t    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n\t    type BarProvider = Provider<\n\t      \"bar\",\n\t      { getBar: () => string },\n\t      { baz: { getBaz: () => boolean } }\n\t    >;\n", "    assertType<Equals<ProviderName<FooProvider | BarProvider>, \"foo\" | \"bar\">>();\n\t  });\n\t});\n\tdescribe(\"ProviderDependencies\", () => {\n\t  it(\"returns the dependencies of the provider\", () => {\n\t    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n\t    assertType<Equals<ProviderDependencies<FooProvider>, { bar: { getBar: () => string } }>>();\n\t  });\n\t  it(\"returns the intersection of the dependencies of all the union members\", () => {\n\t    assertType<Equals<ProviderDependencies<never>, unknown>>();\n", "    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n\t    type BarProvider = Provider<\n\t      \"bar\",\n\t      { getBar: () => string },\n\t      { baz: { getBaz: () => boolean } }\n\t    >;\n\t    assertType<\n\t      Equals<\n\t        ProviderDependencies<FooProvider | BarProvider>,\n\t        { bar: { getBar: () => string } } & { baz: { getBaz: () => boolean } }\n", "      >\n\t    >();\n\t  });\n\t});\n\tdescribe(\"ReconstructComponent\", () => {\n\t  it(\"reconstructs a component type from the provider type\", () => {\n\t    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n\t    assertType<\n\t      Equals<ReconstructComponent<FooProvider>, Component<\"foo\", { getFoo: () => number }>>\n\t    >();\n", "  });\n\t  it(\"distributes over union members\", () => {\n\t    assertType<Equals<ReconstructComponent<never>, never>>();\n\t    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n\t    type BarProvider = Provider<\"bar\", { getBar: () => string }, {}>;\n\t    assertType<\n\t      Equals<\n\t        ReconstructComponent<FooProvider | BarProvider>,\n\t        Component<\"foo\", { getFoo: () => number }> | Component<\"bar\", { getBar: () => string }>\n\t      >\n", "    >();\n\t  });\n\t});\n\tdescribe(\"MixedProvidedInstance\", () => {\n\t  it(\"returns a mixed instance type of the providers\", () => {\n\t    assertType<Equals<MixedProvidedInstance<[]>, {}>>();\n\t    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n\t    type BarProvider = Provider<\"bar\", { getBar: () => string }, {}>;\n\t    type BazProvider = Provider<\"baz\", { getBaz: () => boolean }, {}>;\n\t    assertType<\n", "      Equals<\n\t        MixedProvidedInstance<[FooProvider, BarProvider, BazProvider]>,\n\t        Readonly<{\n\t          foo: { getFoo: () => number };\n\t          bar: { getBar: () => string };\n\t          baz: { getBaz: () => boolean };\n\t        }>\n\t      >\n\t    >();\n\t    type Bar2Provider = Provider<\"bar\", { getBar2: () => string }, {}>;\n", "    assertType<\n\t      Equals<\n\t        MixedProvidedInstance<[FooProvider, BarProvider, BazProvider, Bar2Provider]>,\n\t        Readonly<{\n\t          foo: { getFoo: () => number };\n\t          bar: { getBar2: () => string };\n\t          baz: { getBaz: () => boolean };\n\t        }>\n\t      >\n\t    >();\n", "  });\n\t  it(\"distibutes over union members\", () => {\n\t    type FooProvider = Provider<\"foo\", { getFoo: () => number }, { bar: { getBar: () => string } }>;\n\t    type BarProvider = Provider<\"bar\", { getBar: () => string }, {}>;\n\t    type BazProvider = Provider<\"baz\", { getBaz: () => boolean }, {}>;\n\t    assertType<\n\t      Equals<\n\t        MixedProvidedInstance<[FooProvider, BarProvider] | [BazProvider]>,\n\t        | Readonly<{\n\t            foo: { getFoo: () => number };\n", "            bar: { getBar: () => string };\n\t          }>\n\t        | Readonly<{\n\t            baz: { getBaz: () => boolean };\n\t          }>\n\t      >\n\t    >();\n\t  });\n\t});\n\tdescribe(\"Impl\", () => {\n", "  it(\"returns a provider type that implements the component\", () => {\n\t    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\t    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n\t    assertType<\n\t      Equals<\n\t        Impl<FooComponent, [BarComponent, BazComponent]>,\n\t        Provider<\n\t          \"foo\",\n\t          { getFoo: () => number },\n", "          Readonly<{\n\t            bar: { getBar: () => string };\n\t            baz: { getBaz: () => boolean };\n\t          }>\n\t        >\n\t      >\n\t    >();\n\t  });\n\t  it(\"distributes over union members\", () => {\n\t    assertType<Equals<Impl<never, [BazComponent]>, never>>();\n", "    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\t    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n\t    assertType<\n\t      Equals<\n\t        Impl<FooComponent | BarComponent, [BazComponent]>,\n\t        | Provider<\"foo\", { getFoo: () => number }, Readonly<{ baz: { getBaz: () => boolean } }>>\n\t        | Provider<\"bar\", { getBar: () => string }, Readonly<{ baz: { getBaz: () => boolean } }>>\n\t      >\n\t    >();\n", "  });\n\t});\n\tdescribe(\"ImplArgs\", () => {\n\t  it(\"returns a tuple that has the same shape of the provider that implements the component\", () => {\n\t    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\t    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n\t    assertType<\n\t      Equals<\n\t        ImplArgs<FooComponent, [BarComponent, BazComponent]>,\n", "        [\n\t          \"foo\",\n\t          Factory<\n\t            { getFoo: () => number },\n\t            Readonly<{\n\t              bar: { getBar: () => string };\n\t              baz: { getBaz: () => boolean };\n\t            }>\n\t          >,\n\t        ]\n", "      >\n\t    >();\n\t  });\n\t  it(\"distributes over union members\", () => {\n\t    assertType<Equals<ImplArgs<never, [BazComponent]>, never>>();\n\t    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\t    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n\t    assertType<\n\t      Equals<\n", "        ImplArgs<FooComponent | BarComponent, [BazComponent]>,\n\t        | [\"foo\", Factory<{ getFoo: () => number }, Readonly<{ baz: { getBaz: () => boolean } }>>]\n\t        | [\"bar\", Factory<{ getBar: () => string }, Readonly<{ baz: { getBaz: () => boolean } }>>]\n\t      >\n\t    >();\n\t  });\n\t});\n\tdescribe(\"impl\", () => {\n\t  it(\"creates a provider that implements a component\", () => {\n\t    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n", "    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\t    const foo = impl<FooComponent, [BarComponent]>(\"foo\", ({ bar }) => ({\n\t      getFoo: () => bar.getBar().length,\n\t    }));\n\t    assertType<Equals<typeof foo, Impl<FooComponent, [BarComponent]>>>();\n\t    expect(foo.name).toBe(\"foo\");\n\t    const value = invokecFactory(foo.factory, {\n\t      bar: {\n\t        getBar: () => \"Hello\",\n\t      },\n", "    });\n\t    expect(value.getFoo()).toBe(5);\n\t  });\n\t});\n"]}
{"filename": "src/utils.spec.ts", "chunked_list": ["import type { Equals } from \"./__tests__/types\";\n\timport { assertType } from \"./__tests__/types\";\n\timport type { AsString, IsFiniteString, Merge, OrElse, Prod, Wrap } from \"./utils\";\n\tdescribe(\"IsFiniteString\", () => {\n\t  it(\"returns true if and only if the type has a finite number of inhabitants\", () => {\n\t    assertType<Equals<IsFiniteString<never>, true>>();\n\t    assertType<Equals<IsFiniteString<\"foo\">, true>>();\n\t    assertType<Equals<IsFiniteString<\"foo\" | \"bar\">, true>>();\n\t    assertType<Equals<IsFiniteString<string>, false>>();\n\t    assertType<Equals<IsFiniteString<`x-${string}`>, false>>();\n", "    assertType<Equals<IsFiniteString<`x-${number}`>, false>>();\n\t    assertType<Equals<IsFiniteString<`x-${bigint}`>, false>>();\n\t    assertType<Equals<IsFiniteString<`x-${boolean}`>, true>>();\n\t    assertType<Equals<IsFiniteString<\"foo\" | `x-${string}`>, false>>();\n\t    assertType<Equals<IsFiniteString<\"foo\" | `x-${number}`>, false>>();\n\t    assertType<Equals<IsFiniteString<\"foo\" | `x-${bigint}`>, false>>();\n\t    assertType<Equals<IsFiniteString<\"foo\" | `x-${boolean}`>, true>>();\n\t  });\n\t});\n\tdescribe(\"AsString\", () => {\n", "  it(\"removes non-string components of a type\", () => {\n\t    assertType<Equals<AsString<never>, never>>();\n\t    assertType<Equals<AsString<string | number>, string>>();\n\t    assertType<Equals<AsString<\"foo\" | \"bar\" | 42>, \"foo\" | \"bar\">>();\n\t  });\n\t});\n\tdescribe(\"Prod\", () => {\n\t  it(\"returns the product type of the given tuple type\", () => {\n\t    assertType<Equals<Prod<[]>, unknown>>();\n\t    assertType<Equals<Prod<[{ foo: \"foo\" }, { bar: \"bar\" }]>, { foo: \"foo\" } & { bar: \"bar\" }>>();\n", "    assertType<\n\t      Equals<\n\t        Prod<[{ foo: \"foo\" } | { bar: \"bar\" }, { baz: \"baz\" }]>,\n\t        ({ foo: \"foo\" } | { bar: \"bar\" }) & { baz: \"baz\" }\n\t      >\n\t    >();\n\t    assertType<\n\t      Equals<\n\t        Prod<[{ foo: \"foo\" }, { bar: \"bar\" } | { baz: \"baz\" }]>,\n\t        { foo: \"foo\" } & ({ bar: \"bar\" } | { baz: \"baz\" })\n", "      >\n\t    >();\n\t  });\n\t  it(\"distributes over union members\", () => {\n\t    assertType<Equals<Prod<never>, never>>();\n\t    assertType<\n\t      Equals<\n\t        Prod<[{ foo: \"foo\" }, { bar: \"bar\" }] | [{ baz: \"baz\" }, { qux: \"qux\" }]>,\n\t        ({ foo: \"foo\" } & { bar: \"bar\" }) | ({ baz: \"baz\" } & { qux: \"qux\" })\n\t      >\n", "    >();\n\t  });\n\t});\n\tdescribe(\"Merge\", () => {\n\t  it(\"merges an intersection type into a sinlge type\", () => {\n\t    assertType<Equals<Merge<{}>, {}>>();\n\t    assertType<Equals<Merge<{ foo: \"foo\" } & { bar: \"bar\" }>, { foo: \"foo\"; bar: \"bar\" }>>();\n\t  });\n\t  it(\"keeps the original property modifiers\", () => {\n\t    assertType<\n", "      Equals<Merge<{ readonly foo: \"foo\" } & { bar?: \"bar\" }>, { readonly foo: \"foo\"; bar?: \"bar\" }>\n\t    >();\n\t  });\n\t  it(\"distributes over union members\", () => {\n\t    assertType<Equals<Merge<never>, never>>();\n\t    assertType<\n\t      Equals<\n\t        Merge<({ foo: \"foo\" } & { bar: \"bar\" }) | ({ baz: \"baz\" } & { qux: \"qux\" })>,\n\t        { foo: \"foo\"; bar: \"bar\" } | { baz: \"baz\"; qux: \"qux\" }\n\t      >\n", "    >();\n\t  });\n\t});\n\tdescribe(\"OrElse\", () => {\n\t  it(\"returns the first type if it is not `never`; otherwise, returns the second type\", () => {\n\t    assertType<Equals<OrElse<never, \"xxx\">, \"xxx\">>();\n\t    assertType<Equals<OrElse<\"foo\", \"xxx\">, \"foo\">>();\n\t    assertType<Equals<OrElse<\"foo\" | \"bar\", \"xxx\">, \"foo\" | \"bar\">>();\n\t  });\n\t});\n", "describe(\"Wrap\", () => {\n\t  it(\"returns the type wrapped in a tupple if it is not `never`; otherwise, returns `never`\", () => {\n\t    assertType<Equals<Wrap<never>, never>>();\n\t    assertType<Equals<Wrap<\"foo\">, [\"foo\"]>>();\n\t    assertType<Equals<Wrap<\"foo\" | \"bar\">, [\"foo\" | \"bar\"]>>();\n\t  });\n\t});\n"]}
{"filename": "src/utils.ts", "chunked_list": ["export type IsFiniteString<S extends string> = _IsFiniteString<S> extends true ? true : false;\n\t// prettier-ignore\n\ttype _IsFiniteString<S extends string> =\n\t    string extends S ? false\n\t  : S extends \"\" ? true\n\t  : S extends `${infer H}${infer R}` ? (\n\t      string extends H ? false\n\t    : `${number}` extends H ? false\n\t    : `${bigint}` extends H ? false\n\t    : _IsFiniteString<R>\n", "  )\n\t  : never;\n\texport type AsString<T> = T extends string ? T : never;\n\texport type Prod<Xs extends unknown[]> = Xs extends unknown\n\t  ? { [K in keyof Xs]: (x: Xs[K]) => unknown }[number] extends (x: infer P) => unknown\n\t    ? P\n\t    : never\n\t  : never;\n\texport type Merge<T> = { [K in keyof T]: T[K] };\n\texport type OrElse<T, E> = [T] extends [never] ? E : T;\n", "export type Wrap<T> = [T] extends [never] ? never : [T];\n"]}
{"filename": "src/component.spec.ts", "chunked_list": ["import type { Equals } from \"./__tests__/types\";\n\timport { assertType } from \"./__tests__/types\";\n\timport type { Component, Instance, Mixed } from \"./component\";\n\tdescribe(\"Instance\", () => {\n\t  it(\"returns an object type with a property whose name is the component name and whose type is the component type\", () => {\n\t    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    assertType<Equals<Instance<FooComponent>, Readonly<{ foo: { getFoo: () => number } }>>>();\n\t  });\n\t  it(\"returns the union type of object types if the component name is a union string\", () => {\n\t    type XxxComponent = Component<never, { getXxx: () => number }>;\n", "    assertType<Equals<Instance<XxxComponent>, never>>();\n\t    type FooComponent = Component<\"foo1\" | \"foo2\", { getFoo: () => number }>;\n\t    assertType<\n\t      Equals<\n\t        Instance<FooComponent>,\n\t        Readonly<{ foo1: { getFoo: () => number } }> | Readonly<{ foo2: { getFoo: () => number } }>\n\t      >\n\t    >();\n\t  });\n\t  it(\"returns an object type with an optional index signature if the component name is not of a finite string type\", () => {\n", "    type XxxComponent = Component<string, { getXxx: () => number }>;\n\t    assertType<\n\t      Equals<\n\t        Instance<XxxComponent>,\n\t        Readonly<{ [key: string]: { getXxx: () => number } | undefined }>\n\t      >\n\t    >();\n\t    type YyyComponent = Component<`x-${string}`, { getYyy: () => number }>;\n\t    assertType<\n\t      Equals<\n", "        Instance<YyyComponent>,\n\t        Readonly<{ [key: `x-${string}`]: { getYyy: () => number } | undefined }>\n\t      >\n\t    >();\n\t  });\n\t  it(\"distributes over union members\", () => {\n\t    assertType<Equals<Instance<never>, never>>();\n\t    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\t    assertType<\n", "      Equals<\n\t        Instance<FooComponent | BarComponent>,\n\t        Readonly<{ foo: { getFoo: () => number } }> | Readonly<{ bar: { getBar: () => string } }>\n\t      >\n\t    >();\n\t  });\n\t});\n\tdescribe(\"Mixed\", () => {\n\t  it(\"returns a mixed instance type of the components\", () => {\n\t    assertType<Equals<Mixed<[]>, {}>>();\n", "    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\t    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n\t    assertType<\n\t      Equals<\n\t        Mixed<[FooComponent, BarComponent, BazComponent]>,\n\t        Readonly<{\n\t          foo: { getFoo: () => number };\n\t          bar: { getBar: () => string };\n\t          baz: { getBaz: () => boolean };\n", "        }>\n\t      >\n\t    >();\n\t  });\n\t  it(\"overrides previously declared component instances\", () => {\n\t    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\t    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n\t    type Bar2Component = Component<\"bar\", { getBar2: () => bigint }>;\n\t    assertType<\n", "      Equals<\n\t        Mixed<[FooComponent, BarComponent, BazComponent, Bar2Component]>,\n\t        Readonly<{\n\t          foo: { getFoo: () => number };\n\t          bar: { getBar2: () => bigint };\n\t          baz: { getBaz: () => boolean };\n\t        }>\n\t      >\n\t    >();\n\t  });\n", "  it(\"erases all matching component instances before a component with an infinite name\", () => {\n\t    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\t    type BazComponent = Component<\"x-baz\", { getBaz: () => boolean }>;\n\t    type QuxComponent = Component<\"qux\", { getQux: () => bigint }>;\n\t    type XxxComponent = Component<string, { getXxx: () => number }>;\n\t    type YyyComponent = Component<`x-${string}`, { getYyy: () => number }>;\n\t    assertType<\n\t      Equals<\n\t        Mixed<[FooComponent, XxxComponent, BarComponent, BazComponent, YyyComponent, QuxComponent]>,\n", "        Readonly<{\n\t          bar: { getBar: () => string };\n\t          qux: { getQux: () => bigint };\n\t        }>\n\t      >\n\t    >();\n\t  });\n\t  it(\"returns an empty object type if the input is not a tuple\", () => {\n\t    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n", "    assertType<Equals<Mixed<FooComponent[]>, {}>>();\n\t    assertType<Equals<Mixed<[...FooComponent[], BarComponent]>, {}>>();\n\t    assertType<Equals<Mixed<[FooComponent, ...BarComponent[]]>, {}>>();\n\t  });\n\t  it(\"distibutes over union members\", () => {\n\t    type FooComponent = Component<\"foo\", { getFoo: () => number }>;\n\t    type BarComponent = Component<\"bar\", { getBar: () => string }>;\n\t    type BazComponent = Component<\"baz\", { getBaz: () => boolean }>;\n\t    assertType<\n\t      Equals<\n", "        Mixed<[FooComponent, BarComponent] | [BazComponent]>,\n\t        | Readonly<{\n\t            foo: { getFoo: () => number };\n\t            bar: { getBar: () => string };\n\t          }>\n\t        | Readonly<{\n\t            baz: { getBaz: () => boolean };\n\t          }>\n\t      >\n\t    >();\n", "  });\n\t});\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { Component, AbstractComponent, Instance, Mixed } from \"./component\";\n\texport { Provider, AbstractProvider, Impl, impl } from \"./provider\";\n\texport { Mixer, mixer } from \"./mixer\";\n"]}
{"filename": "src/component.ts", "chunked_list": ["import type { AsString, IsFiniteString, Merge, Prod } from \"./utils\";\n\t/**\n\t * `Component<N, T>` represents a component.\n\t * @param N The name of the component.\n\t * @param T The type of the component instance.\n\t */\n\texport type Component<N extends string, T extends unknown> = {\n\t  // eslint-disable-next-line @typescript-eslint/naming-convention\n\t  __type: \"hokemi.type.Component\";\n\t  name: N;\n", "  type: T;\n\t};\n\t/**\n\t * The upper bound of component types.\n\t */\n\texport type AbstractComponent = Component<string, unknown>;\n\t/**\n\t * Returns the instance type of a component.\n\t * @param C A component.\n\t */\n", "export type Instance<C extends AbstractComponent> = C extends Component<infer N, infer T>\n\t  ? _Instance<N, T>\n\t  : never;\n\ttype _Instance<N extends string, T extends unknown> = N extends unknown\n\t  ? IsFiniteString<N> extends true\n\t    ? { readonly [N0 in N]: T }\n\t    : { readonly [N0 in N]?: T }\n\t  : never;\n\t/**\n\t * Returns the mixed instance type of components.\n", " * @param Cs Components.\n\t */\n\texport type Mixed<Cs extends AbstractComponent[]> = Merge<Prod<FilteredInstances<Cs, [], never>>>;\n\t// prettier-ignore\n\ttype FilteredInstances<\n\t  Cs extends AbstractComponent[],\n\t  Is extends Array<{}>,\n\t  K extends string\n\t> = Cs extends [] ? Is\n\t  : Cs extends [\n", "      ...infer Xs extends AbstractComponent[],\n\t      infer X extends AbstractComponent,\n\t    ] ? _FilteredInstances<Xs, Is, Instance<X>, K>\n\t  : [];\n\t// prettier-ignore\n\ttype _FilteredInstances<\n\t  Cs extends AbstractComponent[],\n\t  Is extends Array<{}>,\n\t  I extends {},\n\t  K extends string\n", "> = I extends unknown\n\t  ? keyof I extends K\n\t    ? FilteredInstances<Cs, Is, K>\n\t    : IsFiniteString<AsString<keyof I>> extends true\n\t      ? FilteredInstances<Cs, [I, ...Is], K | AsString<keyof I>>\n\t      : FilteredInstances<Cs, Is, K | AsString<keyof I>>\n\t  : never;\n"]}
{"filename": "src/mixer.ts", "chunked_list": ["import type {\n\t  AbstractProvider,\n\t  ProviderDependencies,\n\t  ProviderName,\n\t  MixedProvidedInstance,\n\t} from \"./provider\";\n\timport { invokecFactory } from \"./provider\";\n\timport type { OrElse, Wrap } from \"./utils\";\n\t/**\n\t * `Mixer<Ps>` represents a mixer object.\n", " * @param Ps A list of providers to be mixed.\n\t */\n\texport type Mixer<Ps extends AbstractProvider[]> = Readonly<{\n\t  /**\n\t   * Extends the mixer with more providers.\n\t   * @params providers Additional providers to be mixed.\n\t   * @returns An extended mixer object.\n\t   */\n\t  with: MixerMethodWith<Ps>;\n\t  /**\n", "   * Creates a new mixed instance.\n\t   * @returns A mixed instance.\n\t   */\n\t  new: MixerMethodNew<Ps>;\n\t}>;\n\ttype MixerMethodWith<Ps extends AbstractProvider[]> = <Qs extends AbstractProvider[]>(\n\t  ...providers: Qs\n\t) => Mixer<[...Ps, ...Qs]>;\n\ttype MixerMethodNew<Ps extends AbstractProvider[]> = MixerError<Ps> extends never\n\t  ? () => MixedProvidedInstance<Ps>\n", "  : MixerError<Ps>;\n\ttype MixerError<Ps extends AbstractProvider[]> = {\n\t  [K in keyof Ps]: PerProviderError<Ps[K], Ps>;\n\t}[number];\n\ttype PerProviderError<\n\t  P extends AbstractProvider,\n\t  Ps extends AbstractProvider[],\n\t> = MixedProvidedInstance<Ps> extends ProviderDependencies<P>\n\t  ? never\n\t  : OrElse<\n", "      MissingDependenciesError<P, Ps> | IncompatibleDependenciesError<P, Ps>,\n\t      UnknownError<{\n\t        reason: \"unknown dependency error (this is likely a bug; please file an issue)\";\n\t        providerName: ProviderName<P>;\n\t      }>\n\t    >;\n\ttype UnknownError<E extends unknown> = {\n\t  // eslint-disable-next-line @typescript-eslint/naming-convention\n\t  __unknownError?: E;\n\t};\n", "type MissingDependenciesError<\n\t  P extends AbstractProvider,\n\t  Ps extends AbstractProvider[],\n\t> = MissingDependencies<P, Ps> extends never\n\t  ? never\n\t  : {\n\t      // eslint-disable-next-line @typescript-eslint/naming-convention\n\t      __missingDependenciesError?: {\n\t        reason: \"some dependencies are missing\";\n\t        providerName: ProviderName<P>;\n", "        dependencies: MissingDependencies<P, Ps>;\n\t      };\n\t    };\n\ttype MissingDependencies<\n\t  P extends AbstractProvider,\n\t  Ps extends AbstractProvider[],\n\t> = _MissingDependencies<ProviderDependencies<P>, MixedProvidedInstance<Ps>>;\n\ttype _MissingDependencies<D extends unknown, I extends unknown> = D extends unknown\n\t  ? Wrap<\n\t      {\n", "        [N in keyof D]: N extends keyof I\n\t          ? never\n\t          : {\n\t              name: N;\n\t              expectedType: D[N];\n\t            };\n\t      }[keyof D]\n\t    >\n\t  : never;\n\ttype IncompatibleDependenciesError<\n", "  P extends AbstractProvider,\n\t  Ps extends AbstractProvider[],\n\t> = IncompatibleDependencies<P, Ps> extends never\n\t  ? never\n\t  : {\n\t      // eslint-disable-next-line @typescript-eslint/naming-convention\n\t      __incompatibleDependenciesError?: {\n\t        reason: \"some dependencies are incompatible\";\n\t        providerName: ProviderName<P>;\n\t        dependencies: IncompatibleDependencies<P, Ps>;\n", "      };\n\t    };\n\ttype IncompatibleDependencies<\n\t  P extends AbstractProvider,\n\t  Ps extends AbstractProvider[],\n\t> = _IncompatibleDependencies<ProviderDependencies<P>, MixedProvidedInstance<Ps>>;\n\ttype _IncompatibleDependencies<D extends unknown, I extends unknown> = D extends unknown\n\t  ? Wrap<\n\t      {\n\t        [N in keyof D & keyof I]: I[N] extends D[N]\n", "          ? never\n\t          : {\n\t              name: N;\n\t              expectedType: D[N];\n\t              actualType: I[N];\n\t            };\n\t      }[keyof D & keyof I]\n\t    >\n\t  : never;\n\t/**\n", " * Creates a new mixer object.\n\t * @param providers Providers to be mixed.\n\t * @returns A mixer object.\n\t */\n\texport function mixer<Ps extends AbstractProvider[]>(...providers: Ps): Mixer<Ps> {\n\t  return {\n\t    with: (...otherProviders) => mixer(...providers, ...otherProviders),\n\t    // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n\t    new: (() => {\n\t      const mixed = {};\n", "      const instances = new Map<string, unknown>();\n\t      const getters = new Map<string, () => unknown>();\n\t      const lock = new Set<string>();\n\t      for (const { name, factory } of providers) {\n\t        const getter = (): unknown => {\n\t          if (instances.has(name)) {\n\t            return instances.get(name);\n\t          }\n\t          if (lock.has(name)) {\n\t            throw new Error(`'${name}' is referenced during its initialization`);\n", "          }\n\t          lock.add(name);\n\t          // eslint-disable-next-line @susisu/safe-typescript/no-type-assertion\n\t          const value = invokecFactory(factory, mixed as never);\n\t          lock.delete(name);\n\t          instances.set(name, value);\n\t          return value;\n\t        };\n\t        getters.set(name, getter);\n\t        Object.defineProperty(mixed, name, {\n", "          get: getter,\n\t          configurable: true,\n\t          enumerable: true,\n\t        });\n\t      }\n\t      // instantiate all the components\n\t      for (const getter of getters.values()) {\n\t        getter();\n\t      }\n\t      return mixed;\n", "    }) as MixerMethodNew<Ps>,\n\t  };\n\t}\n"]}
{"filename": "src/mixer.spec.ts", "chunked_list": ["import type { Equals } from \"./__tests__/types\";\n\timport { assertType } from \"./__tests__/types\";\n\timport type { Component, Mixed } from \"./component\";\n\timport type { Mixer } from \"./mixer\";\n\timport { mixer } from \"./mixer\";\n\timport type { Impl } from \"./provider\";\n\timport { impl } from \"./provider\";\n\tdescribe(\"Mixer\", () => {\n\t  describe(\"new\", () => {\n\t    /* eslint-disable @typescript-eslint/naming-convention */\n", "    type Foo = { getFoo: () => number };\n\t    type Bar = { getBar: () => string };\n\t    type Baz = { getBaz: () => boolean };\n\t    type FooComponent = Component<\"foo\", Foo>;\n\t    type BarComponent = Component<\"bar\", Bar>;\n\t    type BazComponent = Component<\"baz\", Baz>;\n\t    it(\"creates an instance if there is no error\", () => {\n\t      type FooImpl = Impl<FooComponent, [BarComponent, BazComponent]>;\n\t      type BarImpl = Impl<BarComponent, [BazComponent]>;\n\t      type BazImpl = Impl<BazComponent>;\n", "      type M = Mixer<[FooImpl, BarImpl, BazImpl]>;\n\t      assertType<Equals<M[\"new\"], () => Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n\t    });\n\t    it(\"reports missing dependencies if some dependencies are missing\", () => {\n\t      type FooImpl = Impl<FooComponent, [BarComponent, BazComponent]>;\n\t      type BarImpl = Impl<BarComponent, [BazComponent]>;\n\t      type M = Mixer<[FooImpl, BarImpl]>;\n\t      assertType<\n\t        Equals<\n\t          M[\"new\"],\n", "          | {\n\t              __missingDependenciesError?: {\n\t                reason: \"some dependencies are missing\";\n\t                providerName: \"foo\";\n\t                dependencies: [\n\t                  {\n\t                    name: \"baz\";\n\t                    expectedType: Baz;\n\t                  },\n\t                ];\n", "              };\n\t            }\n\t          | {\n\t              __missingDependenciesError?: {\n\t                reason: \"some dependencies are missing\";\n\t                providerName: \"bar\";\n\t                dependencies: [\n\t                  {\n\t                    name: \"baz\";\n\t                    expectedType: Baz;\n", "                  },\n\t                ];\n\t              };\n\t            }\n\t        >\n\t      >();\n\t    });\n\t    it(\"reports incompatible dependencies if some dependencies are incompatible\", () => {\n\t      type FooImpl = Impl<FooComponent, [BarComponent, BazComponent]>;\n\t      type BarImpl = Impl<BarComponent, [BazComponent]>;\n", "      type BazImpl = Impl<BazComponent>;\n\t      type Bar2 = { getBar2: () => string };\n\t      type Bar2Component = Component<\"bar\", Bar2>;\n\t      type Bar2Impl = Impl<Bar2Component, [BazComponent]>;\n\t      type M = Mixer<[FooImpl, BarImpl, BazImpl, Bar2Impl]>;\n\t      assertType<\n\t        Equals<\n\t          M[\"new\"],\n\t          {\n\t            __incompatibleDependenciesError?: {\n", "              reason: \"some dependencies are incompatible\";\n\t              providerName: \"foo\";\n\t              dependencies: [\n\t                {\n\t                  name: \"bar\";\n\t                  expectedType: Bar;\n\t                  actualType: Bar2;\n\t                },\n\t              ];\n\t            };\n", "          }\n\t        >\n\t      >();\n\t    });\n\t    it(\"reports missing dependencies if some dependencies are possibly missing\", () => {\n\t      type FooImpl = Impl<FooComponent, [BarComponent]>;\n\t      type BarImpl = Impl<BarComponent>;\n\t      type BarBazImpl = Impl<BarComponent | BazComponent>;\n\t      type M1 = Mixer<[FooImpl, BarBazImpl]>;\n\t      assertType<\n", "        Equals<\n\t          M1[\"new\"],\n\t          {\n\t            __missingDependenciesError?: {\n\t              reason: \"some dependencies are missing\";\n\t              providerName: \"foo\";\n\t              dependencies: [\n\t                {\n\t                  name: \"bar\";\n\t                  expectedType: Bar;\n", "                },\n\t              ];\n\t            };\n\t          }\n\t        >\n\t      >();\n\t      type M2 = Mixer<[FooImpl, BarBazImpl, BarImpl]>;\n\t      assertType<\n\t        Equals<M2[\"new\"], () => Mixed<[FooComponent, BarComponent | BazComponent, BarComponent]>>\n\t      >();\n", "    });\n\t    it(\"allows creating an instance if any possible combination of dependencies is provided\", () => {\n\t      type FooImpl = Impl<FooComponent, [BarComponent] | [BazComponent]>;\n\t      type BarImpl = Impl<BarComponent>;\n\t      type BazImpl = Impl<BazComponent>;\n\t      type M1 = Mixer<[FooImpl]>;\n\t      assertType<\n\t        Equals<\n\t          M1[\"new\"],\n\t          {\n", "            __missingDependenciesError?: {\n\t              reason: \"some dependencies are missing\";\n\t              providerName: \"foo\";\n\t              dependencies:\n\t                | [\n\t                    {\n\t                      name: \"bar\";\n\t                      expectedType: Bar;\n\t                    },\n\t                  ]\n", "                | [\n\t                    {\n\t                      name: \"baz\";\n\t                      expectedType: Baz;\n\t                    },\n\t                  ];\n\t            };\n\t          }\n\t        >\n\t      >();\n", "      type M2 = Mixer<[FooImpl, BarImpl]>;\n\t      assertType<Equals<M2[\"new\"], () => Mixed<[FooComponent, BarComponent]>>>();\n\t      type M3 = Mixer<[FooImpl, BazImpl]>;\n\t      assertType<Equals<M3[\"new\"], () => Mixed<[FooComponent, BazComponent]>>>();\n\t    });\n\t    it(\"reports missing dependencies unless all possible dependencies are provided\", () => {\n\t      type FooImpl = Impl<FooComponent, [BarComponent]> | Impl<FooComponent, [BazComponent]>;\n\t      type BarImpl = Impl<BarComponent>;\n\t      type BazImpl = Impl<BazComponent>;\n\t      type M1 = Mixer<[FooImpl]>;\n", "      assertType<\n\t        Equals<\n\t          M1[\"new\"],\n\t          {\n\t            __missingDependenciesError?: {\n\t              reason: \"some dependencies are missing\";\n\t              providerName: \"foo\";\n\t              dependencies: [\n\t                | {\n\t                    name: \"bar\";\n", "                    expectedType: Bar;\n\t                  }\n\t                | {\n\t                    name: \"baz\";\n\t                    expectedType: Baz;\n\t                  },\n\t              ];\n\t            };\n\t          }\n\t        >\n", "      >();\n\t      type M2 = Mixer<[FooImpl, BarImpl]>;\n\t      assertType<\n\t        Equals<\n\t          M2[\"new\"],\n\t          {\n\t            __missingDependenciesError?: {\n\t              reason: \"some dependencies are missing\";\n\t              providerName: \"foo\";\n\t              dependencies: [\n", "                {\n\t                  name: \"baz\";\n\t                  expectedType: Baz;\n\t                },\n\t              ];\n\t            };\n\t          }\n\t        >\n\t      >();\n\t      type M3 = Mixer<[FooImpl, BazImpl]>;\n", "      assertType<\n\t        Equals<\n\t          M3[\"new\"],\n\t          {\n\t            __missingDependenciesError?: {\n\t              reason: \"some dependencies are missing\";\n\t              providerName: \"foo\";\n\t              dependencies: [\n\t                {\n\t                  name: \"bar\";\n", "                  expectedType: Bar;\n\t                },\n\t              ];\n\t            };\n\t          }\n\t        >\n\t      >();\n\t      type M4 = Mixer<[FooImpl, BarImpl, BazImpl]>;\n\t      assertType<Equals<M4[\"new\"], () => Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n\t    });\n", "    /* eslint-enable @typescript-eslint/naming-convention */\n\t  });\n\t});\n\tdescribe(\"mixer\", () => {\n\t  type Foo = { getFoo: () => number };\n\t  type Bar = { getBar: () => string };\n\t  type Baz = { getBaz: () => boolean };\n\t  type FooComponent = Component<\"foo\", Foo>;\n\t  type BarComponent = Component<\"bar\", Bar>;\n\t  type BazComponent = Component<\"baz\", Baz>;\n", "  it(\"mixes components and creates a mixed instance\", () => {\n\t    const foo = impl<FooComponent, [BarComponent, BazComponent]>(\"foo\", ({ bar, baz }) => ({\n\t      getFoo: () => (baz.getBaz() ? bar.getBar().length : 42),\n\t    }));\n\t    const bar = impl<BarComponent, [BazComponent]>(\"bar\", ({ baz }) => ({\n\t      getBar: () => (baz.getBaz() ? \"Hello\" : \"Bye\"),\n\t    }));\n\t    const baz = impl<BazComponent>(\"baz\", () => ({\n\t      getBaz: () => true,\n\t    }));\n", "    const m = mixer(foo, bar, baz);\n\t    assertType<Equals<typeof m, Mixer<[typeof foo, typeof bar, typeof baz]>>>();\n\t    const mixed = m.new();\n\t    assertType<Equals<typeof mixed, Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n\t    expect(mixed.foo.getFoo()).toBe(5);\n\t  });\n\t  it(\"overrides previous mixed components\", () => {\n\t    const foo = impl<FooComponent, [BarComponent, BazComponent]>(\"foo\", ({ bar, baz }) => ({\n\t      getFoo: () => (baz.getBaz() ? bar.getBar().length : 42),\n\t    }));\n", "    const bar = impl<BarComponent, [BazComponent]>(\"bar\", ({ baz }) => ({\n\t      getBar: () => (baz.getBaz() ? \"Hello\" : \"Bye\"),\n\t    }));\n\t    const baz = impl<BazComponent>(\"baz\", () => ({\n\t      getBaz: () => true,\n\t    }));\n\t    const baz2 = impl<BazComponent>(\"baz\", () => ({\n\t      getBaz: () => false,\n\t    }));\n\t    const m = mixer(foo, bar, baz).with(baz2);\n", "    assertType<Equals<typeof m, Mixer<[typeof foo, typeof bar, typeof baz, typeof baz2]>>>();\n\t    const mixed = m.new();\n\t    assertType<Equals<typeof mixed, Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n\t    expect(mixed.foo.getFoo()).toBe(42);\n\t  });\n\t  it(\"throws if a component is referenced during its initialization\", () => {\n\t    // foo and bar reference each other during initialization\n\t    const foo = impl<FooComponent, [BarComponent]>(\"foo\", ({ bar }) => ({\n\t      getFoo: () => bar.getBar().length,\n\t    }));\n", "    const bar = impl<BarComponent, [FooComponent]>(\"bar\", ({ foo }) => ({\n\t      getBar: () => foo.getFoo().toString(),\n\t    }));\n\t    expect(() => {\n\t      mixer(foo, bar).new();\n\t    }).toThrow(\"'foo' is referenced during its initialization\");\n\t  });\n\t  it(\"does not throw if a component is referenced after its initialization, even if there is a circular dependency\", () => {\n\t    // foo references bar during its initialization, while bar defers referencing foo until it is actually used\n\t    // (this is not a good example though; it loops forever if you call foo.getFoo() or bar.getBar())\n", "    const foo = impl<FooComponent, [BarComponent]>(\"foo\", ({ bar }) => ({\n\t      getFoo: () => bar.getBar().length,\n\t    }));\n\t    const bar = impl<BarComponent, [FooComponent]>(\"bar\", deps => ({\n\t      getBar: () => deps.foo.getFoo().toString(),\n\t    }));\n\t    expect(() => {\n\t      mixer(foo, bar).new();\n\t    }).not.toThrow();\n\t  });\n", "  it(\"accepts classes as compoent factories\", () => {\n\t    const foo = impl<FooComponent, [BarComponent, BazComponent]>(\n\t      \"foo\",\n\t      class FooImpl {\n\t        private bar: Bar;\n\t        private baz: Baz;\n\t        constructor({ bar, baz }: Mixed<[BarComponent, BazComponent]>) {\n\t          this.bar = bar;\n\t          this.baz = baz;\n\t        }\n", "        getFoo(): number {\n\t          return this.baz.getBaz() ? this.bar.getBar().length : 42;\n\t        }\n\t      }\n\t    );\n\t    const bar = impl<BarComponent, [BazComponent]>(\n\t      \"bar\",\n\t      class BarImpl {\n\t        private baz: Baz;\n\t        constructor({ baz }: Mixed<[BazComponent]>) {\n", "          this.baz = baz;\n\t        }\n\t        getBar(): string {\n\t          return this.baz.getBaz() ? \"Hello\" : \"Bye\";\n\t        }\n\t      }\n\t    );\n\t    const baz = impl<BazComponent>(\n\t      \"baz\",\n\t      class BazImpl {\n", "        getBaz(): boolean {\n\t          return true;\n\t        }\n\t      }\n\t    );\n\t    const m = mixer(foo, bar, baz);\n\t    assertType<Equals<typeof m, Mixer<[typeof foo, typeof bar, typeof baz]>>>();\n\t    const mixed = m.new();\n\t    assertType<Equals<typeof mixed, Mixed<[FooComponent, BarComponent, BazComponent]>>>();\n\t    expect(mixed.foo.getFoo()).toBe(5);\n", "  });\n\t});\n"]}
{"filename": "src/__tests__/types.ts", "chunked_list": ["// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\texport function assertType<_T extends true>(): void {}\n\texport type Equals<T, U> = (<X>() => X extends T ? 1 : 2) extends <X>() => X extends U ? 1 : 2\n\t  ? true\n\t  : false;\n"]}
