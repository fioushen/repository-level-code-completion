{"filename": "tsup.config.ts", "chunked_list": ["import { defineConfig } from 'tsup'\n\texport default defineConfig([\n\t  {\n\t    entry: ['src/index.ts'],\n\t    outDir: 'build',\n\t    target: 'node16',\n\t    platform: 'node',\n\t    format: ['esm'],\n\t    splitting: false,\n\t    sourcemap: true,\n", "    minify: false,\n\t    shims: true,\n\t    dts: true\n\t  }\n\t])\n"]}
{"filename": "tests/test-templates.spec.ts", "chunked_list": ["import test from 'ava'\n\timport { extractPrompts, replacePrompt } from '../src/lib/template'\n\timport { readFileSync } from 'fs'\n\ttest('Extract prompts', t => {\n\t  const template = readFileSync('./tests/data/template.md', 'utf8')\n\t  const prompts = extractPrompts(template)\n\t  t.not(prompts, null)\n\t  console.log(prompts)\n\t})\n\ttest('Replace prompt', t => {\n", "  const template = readFileSync('./tests/data/template.md', 'utf8')\n\t  let newContent = replacePrompt(template, 0, '')\n\t  newContent = replacePrompt(newContent, 1, 'This is the content for the prompt 1')\n\t  newContent = replacePrompt(newContent, 2, 'This is the content for the prompt 2')\n\t  newContent = replacePrompt(newContent, 3, 'This is the content for the prompt 3')\n\t  newContent = replacePrompt(newContent, 4, 'This is the content for the prompt 4')\n\t  t.not(newContent, null)\n\t  console.log(newContent)\n\t})\n"]}
{"filename": "tests/test-api.spec.ts", "chunked_list": ["import test from 'ava'\n\timport { OpenAIPostGenerator } from '../src/post'\n\timport { PostPrompt } from '../src/types'\n\timport { log } from 'console'\n\ttest.skip('API with custom template', async t => {\n\t  const postPrompt : PostPrompt = {\n\t    language: 'english',\n\t    model: 'gpt-4',\n\t    topic: 'Test prompt answer',\n\t    temperature: 0.7,\n", "    frequencyPenalty: 0.5,\n\t    presencePenalty: 0.5,\n\t    logitBias: 0,\n\t    templateFile: './tests/data/template-2.md',\n\t    debug: true,\n\t    debugapi: true\n\t  }\n\t  const postGenerator = new OpenAIPostGenerator(postPrompt)\n\t  const post = await postGenerator.generate()\n\t  t.not(post, null)\n", "  log(post)\n\t})\n\ttest('API', async t => {\n\t  try {\n\t    const postPrompt : PostPrompt = {\n\t      language: 'english',\n\t      model: 'gpt-4',\n\t      topic: 'Test prompt answer',\n\t      temperature: 0.7,\n\t      frequencyPenalty: 0.5,\n", "      presencePenalty: 0.5,\n\t      logitBias: 0,\n\t      debug: false,\n\t      debugapi: false\n\t    }\n\t    const postGenerator = new OpenAIPostGenerator(postPrompt)\n\t    const post = await postGenerator.generate()\n\t    t.not(post, null)\n\t    log(post)\n\t  } catch (e) {\n", "    log(e)\n\t  }\n\t})\n"]}
{"filename": "tests/test-images.spec.ts", "chunked_list": ["import test from 'ava'\n\timport { generateImage } from '../src/lib/image/midjourney'\n\tconst IMAGE_PROMPT = `\n\tGenerate a realistic photography illustrating the concept of 'administrative management' made by a award winning photographer.\n\tIt should include elements commonly associated with administration such as an office desk, paperwork, a laptop, and a calendar. \n\tAlso, incorporate a manager in a professional attire overseeing these tasks. \n\tThe image should reflect a sense of organization, precision, and professionalism in a business setting.\n\t--ar 16:9 --v 5.1 --style raw --q 2 --s 750\n\t`\n\ttest.skip('Generate Image', async t => {\n", "  try {\n\t    await generateImage(IMAGE_PROMPT)\n\t  } catch (err) {\n\t    console.log(err)\n\t  }\n\t})\n"]}
{"filename": "tests/test-extractor.spec.ts", "chunked_list": ["import test from 'ava'\n\timport { PostOutlineValidationError, extractPostOutlineFromCodeBlock, extractCodeBlock } from '../src/lib/extractor'\n\timport fs from 'fs'\n\timport { PostOutline } from '../src/types'\n\ttest.skip('extract outline', t => {\n\t  const content = readTextFileSync('./tests/data/outline-test.txt')\n\t  const result : PostOutline = extractPostOutlineFromCodeBlock(content)\n\t  t.not(result.title, null)\n\t  t.not(result.title, '')\n\t})\n", "test.skip('Invalid outline', t => {\n\t  t.throws(() => extractInvalidOutline(), { instanceOf: PostOutlineValidationError })\n\t})\n\ttest('extract code block', t => {\n\t  const text = '```markdownThis is markdown text```'\n\t  const result = extractCodeBlock(text)\n\t  t.is(result, 'This is markdown text')\n\t  const text2 = '```This is markdown text```'\n\t  const result2 = extractCodeBlock(text2)\n\t  t.is(result2, 'This is markdown text')\n", "  const text3 = '```html<p>This is html text</p>```'\n\t  const result3 = extractCodeBlock(text3)\n\t  t.is(result3, '<p>This is html text</p>')\n\t  const text4 = '```json{\"title\": \"This is json text\"}```'\n\t  const result4 = extractCodeBlock(text4)\n\t  t.is(result4, '{\"title\": \"This is json text\"}')\n\t})\n\tfunction extractInvalidOutline () {\n\t  const content = readTextFileSync('./tests/data/invalid-outline.txt')\n\t  return extractPostOutlineFromCodeBlock(content)\n", "}\n\tfunction readTextFileSync (file) {\n\t  return fs.readFileSync(file, 'utf8')\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["export type TotalTokens = {\n\t  promptTokens: number,\n\t  completionTokens: number,\n\t  total : number\n\t}\n\texport type PostPrompt = {\n\t  topic? : string\n\t  country? : string\n\t  intent? : string\n\t  audience? : string\n", "  language: string\n\t  tone? : 'informative' | 'captivating'\n\t  generate? : boolean // generate the audience and intent\n\t  withConclusion? : boolean\n\t  model : 'gpt-4' | 'gpt-4-32k' | 'gpt-3.5-turbo' | 'gpt-3.5-turbo-16k',\n\t  maxModelTokens? : 4000 | 8000,\n\t  temperature? : number\n\t  frequencyPenalty? : number\n\t  presencePenalty? : number\n\t  logitBias? : number\n", "  debug? : boolean\n\t  debugapi? : boolean\n\t  apiKey? : string\n\t  filename? : string\n\t  // The following attributes are only used for custom templates\n\t  templateFile? : string\n\t  templateContent? : string\n\t  prompts? : string[]\n\t}\n\texport type Heading = {\n", "  title: string\n\t  keywords?: string[]\n\t  headings?: Heading[]\n\t}\n\texport type PostOutline = {\n\t  title: string\n\t  headings : Heading[],\n\t  slug : string,\n\t  seoTitle : string,\n\t  seoDescription : string\n", "}\n\texport type Post = {\n\t  title : string\n\t  content : string\n\t  seoTitle : string\n\t  seoDescription : string\n\t  slug : string,\n\t  categories? : number[],\n\t  status? : string,\n\t  totalTokens : TotalTokens\n", "}\n\texport type SeoInfo = {\n\t  h1 : string\n\t  slug : string\n\t  seoTitle : string\n\t  seoDescription : string\n\t}\n\texport type AudienceIntentInfo = {\n\t  audience : string\n\t  intent : string\n", "}\n"]}
{"filename": "src/post.ts", "chunked_list": ["import { oraPromise } from 'ora'\n\timport { ChatGptHelper, GeneratorHelperInterface } from './lib/post-helpers'\n\timport {\n\t  PostPrompt,\n\t  Post\n\t} from './types'\n\timport { replaceAllPrompts } from './lib/template'\n\t/**\n\t * Class for generating a post. It need a helper class to generate the post\n\t * Each helper class must implement the GeneratorHelperInterface\n", " */\n\texport class PostGenerator {\n\t  private helper : GeneratorHelperInterface\n\t  public constructor (helper : GeneratorHelperInterface) {\n\t    this.helper = helper\n\t  }\n\t  public async generate () : Promise<Post> {\n\t    return this.helper.isCustom() ? await this.customGenerate() : await this.autoGenerate()\n\t  }\n\t  /**\n", "   * Generate a post using the custom prompt based on a template\n\t   */\n\t  private async customGenerate () : Promise<Post> {\n\t    const promptContents = []\n\t    await oraPromise(\n\t      this.helper.init(),\n\t      {\n\t        text: ' Init the completion parameters ...'\n\t      }\n\t    )\n", "    // We remove the first prompt because it is the system prompt\n\t    const prompts = this.helper.getPrompt().prompts.slice(1)\n\t    // for each prompt, we generate the content\n\t    const templatePrompts = prompts.entries()\n\t    for (const [index, prompt] of templatePrompts) {\n\t      const content = await oraPromise(\n\t        this.helper.generateCustomPrompt(prompt),\n\t        {\n\t          text: `Generating the prompt num. ${index + 1} ...`\n\t        }\n", "      )\n\t      promptContents.push(content)\n\t    }\n\t    // We replace the prompts by the AI answer in the template content\n\t    const content = replaceAllPrompts(this.helper.getPrompt().templateContent, promptContents)\n\t    const seoInfo = await oraPromise(\n\t      this.helper.generateSeoInfo(),\n\t      {\n\t        text: 'Generating SEO info ...'\n\t      }\n", "    )\n\t    return {\n\t      title: seoInfo.h1,\n\t      slug: seoInfo.slug,\n\t      seoTitle: seoInfo.seoTitle,\n\t      seoDescription: seoInfo.seoDescription,\n\t      content,\n\t      totalTokens: this.helper.getTotalTokens()\n\t    }\n\t  }\n", "  /**\n\t   * Generate a post using the auto mode\n\t   */\n\t  private async autoGenerate () : Promise<Post> {\n\t    await oraPromise(\n\t      this.helper.init(),\n\t      {\n\t        text: ' Init the completion parameters ...'\n\t      }\n\t    )\n", "    const tableOfContent = await oraPromise(\n\t      this.helper.generateContentOutline(),\n\t      {\n\t        text: 'Generating post outline ...'\n\t      }\n\t    )\n\t    let content = await oraPromise(\n\t      this.helper.generateIntroduction(),\n\t      {\n\t        text: 'Generating introduction...'\n", "      }\n\t    )\n\t    content += await oraPromise(\n\t      this.helper.generateHeadingContents(tableOfContent),\n\t      {\n\t        text: 'Generating content ...'\n\t      }\n\t    )\n\t    if (this.helper.getPrompt().withConclusion) {\n\t      content += await oraPromise(\n", "        this.helper.generateConclusion(),\n\t        {\n\t          text: 'Generating conclusion...'\n\t        }\n\t      )\n\t    }\n\t    return {\n\t      title: tableOfContent.title,\n\t      slug: tableOfContent.slug,\n\t      seoTitle: tableOfContent.seoTitle,\n", "      seoDescription: tableOfContent.seoDescription,\n\t      content,\n\t      totalTokens: this.helper.getTotalTokens()\n\t    }\n\t  }\n\t}\n\t/**\n\t * Class for generating a post using the OpenAI API\n\t */\n\texport class OpenAIPostGenerator extends PostGenerator {\n", "  public constructor (postPrompt : PostPrompt) {\n\t    super(new ChatGptHelper(postPrompt))\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["// for the\n\texport * from './bin/command/post'\n\texport * from './bin/command/wp'\n\texport * from './lib/store/store'\n\t// for the api\n\texport * from './post'\n\texport * from './types'\n"]}
{"filename": "src/bin/command/post.ts", "chunked_list": ["import fs from 'fs'\n\timport { Command } from 'commander'\n\timport { marked } from 'marked'\n\timport { askCustomQuestions, askQuestions } from '../question/questions'\n\timport { OpenAIPostGenerator } from '../../post'\n\timport { Post, PostPrompt } from 'src/types'\n\timport { NoApiKeyError } from 'src/lib/errors'\n\tconst GPT4_PROMPT_PRICE = 0.03\n\tconst GPT4_COMPLETION_PRICE = 0.06\n\tconst GPT35_PROMPT_PRICE = 0.002\n", "const GPT_COMPLETION_PRICE = 0.002\n\ttype Options = {\n\t  interactive: boolean\n\t  debug: boolean\n\t  debugapi: boolean\n\t  apiKey: string\n\t  templateFile: string\n\t  language: string\n\t  model: string\n\t  filename: string\n", "  topic: string\n\t  country: string\n\t  generate: boolean // generate the audience and intent\n\t  conclusion: boolean\n\t  tone: string\n\t  temperature: number\n\t  frequencyPenalty: number\n\t  presencePenalty: number\n\t  logitBias: number\n\t}\n", "export function buildPostCommands (program: Command) {\n\t  program.command('post')\n\t    .description('Generate a post')\n\t    .option('-t, --templateFile <file>', 'Set the template file (optional)')\n\t    .option('-i, --interactive', 'Use interactive mode (CLI questions)')\n\t    .option('-l, --language <language>', 'Set the language (optional), english by default')\n\t    .option('-m, --model <model>', 'Set the LLM : \"gpt-4\" | \"gpt-4-32k\" | \"gpt-3.5-turbo\" | \"gpt-3.5-turbo-16k\" (optional), GPT-4 by default')\n\t    .option('-f, --filename <filename>', 'Set the post file name (optional)')\n\t    .option('-tp, --topic <topic>', 'Set the post topic (optional)')\n\t    .option('-c, --country <country>', 'Set the country (optional)')\n", "    .option('-g, --generate', 'Generate the audience and intent (optional)')\n\t    .option('-co, --conclusion', 'With conclusion (optional)')\n\t    .option('-to, --tone <tone>', 'Set the tone : \"informative\" | \"captivating\" (optional)')\n\t    .option('-tp, --temperature <temperature>', 'Set the temperature (optional)')\n\t    .option('-fp, --frequencypenalty <frequencyPenalty>', 'Set the frequency penalty (optional)')\n\t    .option('-pp, --presencepenalty <presencePenalty>', 'Set the presence penalty (optional)')\n\t    .option('-lb, --logitbias <logitBias>', 'Set the logit bias (optional)')\n\t    .option('-d, --debug', 'Output extra debugging')\n\t    .option('-da, --debugapi', 'Debug the api calls')\n\t    .option('-k, --apiKey <key>', 'Set the OpenAI api key (optional, you can also set the OPENAI_API_KEY environment variable)')\n", "    .action(async (options) => {\n\t      try {\n\t        await generatePost(options)\n\t      } catch (error) {\n\t        if (error instanceof NoApiKeyError) {\n\t          console.error('Unable to initialize the ChatGPT API. Please make sure that you have set the OPENAI_API_KEY environment variable or use the -K option for setting the API key')\n\t        } else {\n\t          console.error(`Error during the generation of the post : ${error}`)\n\t        }\n\t      }\n", "    })\n\t}\n\tasync function generatePost (options: Options) {\n\t  let answers : any = {}\n\t  if (isInteractive(options)) {\n\t    answers = isCustom(options) ? await askCustomQuestions() : await askQuestions()\n\t  }\n\t  const defaultPostPrompt = buildDefaultPostPrompt()\n\t  const postPrompt : PostPrompt = {\n\t    ...defaultPostPrompt,\n", "    ...options,\n\t    ...answers,\n\t    maxModelTokens: answers.model === 'gpt-4' ? 8000 : 4000\n\t  }\n\t  if (!postPrompt.topic) {\n\t    throw new Error('The topic is mandatory, use the option -tp or --topic')\n\t  }\n\t  const postGenerator = new OpenAIPostGenerator(postPrompt)\n\t  const post = await postGenerator.generate()\n\t  const jsonData = {\n", "    ...post,\n\t    content: isCustom(options)\n\t      ? (isMarkdown(options)\n\t          ? marked(post.content)\n\t          : post.content)\n\t      : marked(post.content)\n\t  }\n\t  const jsonFile = `${postPrompt.filename}.json`\n\t  const contentFile = `${postPrompt.filename}.${getFileExtension(options)}`\n\t  const writeJSONPromise = fs.promises.writeFile(jsonFile, JSON.stringify(jsonData), 'utf8')\n", "  const writeDocPromise = fs.promises.writeFile(contentFile, buildContent(options, post), 'utf8')\n\t  await Promise.all([writeJSONPromise, writeDocPromise])\n\t  console.log(`ðŸ”¥ Content is successfully generated in the file : ${contentFile}. Use the file ${jsonFile} to publish the content on Wordpress.`)\n\t  console.log(`- Slug : ${post.slug}`)\n\t  console.log(`- H1 : ${post.title}`)\n\t  console.log(`- SEO Title : ${post.seoTitle}`)\n\t  console.log(`- SEO Description : ${post.seoDescription}`)\n\t  console.log(`- Total prompts tokens : ${post.totalTokens.promptTokens}`)\n\t  console.log(`- Total completion tokens : ${post.totalTokens.completionTokens}`)\n\t  console.log(`- Estimated cost :  ${estimatedCost(postPrompt.model, post)}$`)\n", "}\n\tfunction isInteractive (options : Options) {\n\t  return options?.interactive\n\t}\n\tfunction isCustom (options : Options) {\n\t  return options.templateFile !== undefined\n\t}\n\tfunction buildDefaultPostPrompt () : PostPrompt {\n\t  return {\n\t    model: 'gpt-4',\n", "    language: 'english',\n\t    tone: 'informative',\n\t    withConclusion: true,\n\t    temperature: 0.8,\n\t    frequencyPenalty: 0,\n\t    presencePenalty: 1,\n\t    logitBias: 0\n\t  }\n\t}\n\tfunction buildContent (options : Options, post : Post) {\n", "  return isHTML(options)\n\t    ? buildHTMLPage(post)\n\t    // in automatic mode, we add the title (h1) into the content\n\t    : buildMDPage(post)\n\t}\n\tfunction isHTML (options : Options) {\n\t  return getFileExtension(options) === 'html'\n\t}\n\tfunction isMarkdown (options : Options) {\n\t  return getFileExtension(options) === 'md'\n", "}\n\tfunction getFileExtension (options : Options) {\n\t  // in custom mode, we use the template extension\n\t  // in auto/default mode, we use the markdown extension in all cases\n\t  return isCustom(options) ? options.templateFile.split('.').pop() : 'md'\n\t}\n\tfunction buildMDPage (post: Post) {\n\t  return '# ' + post.title + '\\n' + post.content\n\t}\n\tfunction buildHTMLPage (post : Post) {\n", "  return `\n\t  <!DOCTYPE html>\n\t  <html>\n\t  <head>\n\t    <meta charset=\"UTF-8\">\n\t    <title>${post.seoTitle}</title>\n\t    <meta name=\"description\" content=\"${post.seoDescription}\">\n\t  </head>\n\t  <body>\n\t    <h1>${post.title}</h1>\n", "    ${post.content}\n\t  </body>\n\t  </html>\n\t  `\n\t}\n\tfunction estimatedCost (model : string, post : Post) {\n\t  const promptTokens = post.totalTokens.promptTokens\n\t  const completionTokens = post.totalTokens.completionTokens\n\t  return (model === 'gpt-4')\n\t    ? Number(((promptTokens / 1000) * GPT4_PROMPT_PRICE) + ((completionTokens / 1000) * GPT4_COMPLETION_PRICE)).toFixed(4)\n", "    : Number(((promptTokens / 1000) * GPT35_PROMPT_PRICE) + ((completionTokens / 1000) * GPT_COMPLETION_PRICE)).toFixed(4)\n\t}\n"]}
{"filename": "src/bin/command/wp.ts", "chunked_list": ["import fs from 'fs'\n\timport util from 'util'\n\timport { Command } from 'commander'\n\timport {\n\t  getAllWordpress,\n\t  getWordpress,\n\t  addWordpress,\n\t  removeWordpress,\n\t  exportWordpressList,\n\t  importWordpressList\n", "} from '../../lib/store/store'\n\timport { getCategories, createPost, updatePost } from '../../lib/wp/wp-api'\n\timport { Post } from '../../types'\n\tconst readFile = util.promisify(fs.readFile)\n\ttype UpdateOptions = {\n\t  date : string\n\t}\n\texport function buildWpCommands (program: Command) {\n\t  const wpCommand = program\n\t    .command('wp')\n", "    .description('Wordpress related commands. The wp list is stored in the local store : ~/.julius/wordpress.json')\n\t    .action(() => {\n\t      console.log('Please provide a sub-command: \"add\" or \"ls\" or \"rm\" , ... ')\n\t    })\n\t  wpCommand\n\t    .command('ls')\n\t    .description('List all Wordpress sites')\n\t    .action(async () => {\n\t      await getAllWp()\n\t    })\n", "  wpCommand\n\t    .command('info <domain|index>')\n\t    .description('Info on a Wordpress site')\n\t    .action(async (domain) => {\n\t      const domainFound = await getWordpress(domain)\n\t      if (domainFound) {\n\t        console.log('\\nWordpress site found :\\n')\n\t        console.log(`\\ndomain : ${domainFound.domain}`)\n\t        console.log(`username : ${domainFound.username}`)\n\t        console.log(`password : ${domainFound.password}\\n`)\n", "      } else {\n\t        console.log(`\\nWordpress site ${domain} not found\\n`)\n\t      }\n\t    })\n\t  wpCommand\n\t    .command('add <domain:username:password>')\n\t    .description('Add a new Wordpress site')\n\t    .action(async (site) => {\n\t      await addWpSite(site)\n\t    })\n", "  wpCommand\n\t    .command('rm <domain|index>')\n\t    .description('Remove Wordpress site')\n\t    .action(async (domain) => {\n\t      const deleted = await removeWordpress(domain)\n\t      console.log(deleted ? `\\nWordpress site ${domain} removed successfully\\n` : `Wordpress site ${domain} not found\\n`)\n\t    })\n\t  wpCommand\n\t    .command('export <file>')\n\t    .description('Export the list of wordpress sites (with credentials) the console')\n", "    .action(async (file) => {\n\t      await exportWordpressList(file)\n\t    })\n\t  wpCommand\n\t    .command('import <file>')\n\t    .description('Import the list of wordpress sites (with credentials) from a file')\n\t    .action(async (file) => {\n\t      await importWordpressList(file)\n\t    })\n\t  wpCommand\n", "    .command('categories <domain|index>')\n\t    .description('Fetch the categories for one Wordpress site')\n\t    .action(async (domain) => {\n\t      const domainFound = await getWordpress(domain)\n\t      if (domainFound) {\n\t        const categories = await getCategories(domainFound)\n\t        console.log(categories)\n\t      } else {\n\t        console.log(`\\nWordpress site ${domain} not found\\n`)\n\t      }\n", "    })\n\t  wpCommand\n\t    .command('post <domain> <categoryId> <jsonfile>')\n\t    .description('Create a new post to a Wordpress site. The file has to be a json file containing : { content, categories, seoTitle, seoDescription }')\n\t    .action(async (domain, categoryId, jsonFile) => {\n\t      const domainFound = await getWordpress(domain)\n\t      if (!domainFound) {\n\t        console.log(`\\nWordpress site ${domain} not found\\n`)\n\t        return\n\t      }\n", "      const jsonContent = await readFile(jsonFile, 'utf8')\n\t      const post: Post = JSON.parse(jsonContent)\n\t      post.categories = [categoryId]\n\t      post.status = 'draft'\n\t      await createPost(domainFound, post)\n\t      console.log(`\\nContent has been published on https://${domainFound.domain}/${post.slug}\\n`)\n\t    })\n\t  wpCommand\n\t    .command('update <domain> <slug> <jsonfile>')\n\t    .option('-d, --date <date>', 'Update the publish date of the post. Use the format YYYY-MM-DD:HH:MM:SS')\n", "    .description('Update a new post to a Wordpress site. The file has to be a json file containing : { content, seoTitle, seoDescription }')\n\t    .action(async (domain, slug, jsonFile, options : UpdateOptions) => {\n\t      const domainFound = await getWordpress(domain)\n\t      if (!domainFound) {\n\t        console.log(`\\nWordpress site ${domain} not found\\n`)\n\t        return\n\t      }\n\t      const jsonContent = await readFile(jsonFile, 'utf8')\n\t      const newContent: Post = JSON.parse(jsonContent)\n\t      await updatePost(domainFound, slug, newContent, options.date)\n", "      console.log(`\\nContent has been updated on https://${domainFound.domain}${slug}\\n\\n`)\n\t    })\n\t}\n\tasync function getAllWp () {\n\t  const wpSites = await getAllWordpress()\n\t  if (wpSites.length === 0) {\n\t    console.log('\\nNo Wordpress site found\\n')\n\t    return\n\t  }\n\t  console.log('\\nWordpress sites :\\n')\n", "  console.log(wpSites.map((wp, index) => `${index + 1}. ${wp.domain} (${wp.username})`).join('\\n') + '\\n')\n\t}\n\tasync function addWpSite (site) {\n\t  const [domain, username, password] = site.split(':')\n\t  if (!domain || !username || !password) {\n\t    console.error('Invalid format for adding a new wp site. Expected : domain:username:password')\n\t    return\n\t  }\n\t  await addWordpress({ domain, username, password })\n\t  console.log(`\\nWordpress site ${domain} added successfully\\n`)\n", "}\n"]}
{"filename": "src/bin/question/questions.ts", "chunked_list": ["import inquirer from 'inquirer'\n\timport inquirerPrompt from 'inquirer-autocomplete-prompt'\n\timport inquirerFileTreeSelection from 'inquirer-file-tree-selection-prompt'\n\tinquirer.registerPrompt('autocomplete', inquirerPrompt)\n\tinquirer.registerPrompt('file-tree-selection', inquirerFileTreeSelection)\n\tconst LANGUAGES = ['english', 'french', 'spanish', 'german', 'italian', 'russian',\n\t  'portuguese', 'polish', 'turkish', 'swedish', 'norwegian', 'dutch', 'danish',\n\t  'czech', 'greek', 'hungarian', 'finnish', 'romanian', 'bulgarian', 'serbian',\n\t  'slovak', 'croatian', 'ukrainian', 'slovene', 'estonian', 'latvian', 'lithuanian',\n\t  'chinese', 'hindi', 'arabic', 'japanese']\n", "const CONTENT_TONE = ['informative', 'captivating']\n\tconst MODELS = ['gpt-4', 'gpt-3.5-turbo', 'gpt-3.5-turbo-16k', 'gpt-4-32k']\n\tconst questions = [\n\t  {\n\t    type: 'autocomplete',\n\t    name: 'language',\n\t    message: 'Language ?',\n\t    source: (answersSoFar, input) => LANGUAGES.filter((language) => language.startsWith(input)),\n\t    default: 'english'\n\t  },\n", "  {\n\t    type: 'list',\n\t    name: 'model',\n\t    message: 'AI model ?',\n\t    choices: MODELS,\n\t    default: 'gpt-4'\n\t  },\n\t  {\n\t    type: 'input',\n\t    name: 'filename',\n", "    message: 'Filename (without extension) ?',\n\t    default: 'post'\n\t  },\n\t  {\n\t    type: 'input',\n\t    name: 'topic',\n\t    message: 'Topic/ Artitle Title ? '\n\t  },\n\t  {\n\t    type: 'input',\n", "    name: 'country',\n\t    message: 'Country ?',\n\t    default: 'none'\n\t  },\n\t  {\n\t    type: 'input',\n\t    name: 'intent',\n\t    message: 'Intent ?',\n\t    default: 'The article should be informative and offer advice to the reader.'\n\t  },\n", "  {\n\t    type: 'input',\n\t    name: 'audience',\n\t    message: 'Audience ?',\n\t    default: 'The article should be written for a general audience.'\n\t  },\n\t  {\n\t    type: 'confirm',\n\t    name: 'withConclusion',\n\t    message: 'With conclusion ?'\n", "  },\n\t  {\n\t    type: 'list',\n\t    choices: CONTENT_TONE,\n\t    name: 'tone',\n\t    message: 'Content Tone ?',\n\t    default: 'Informative'\n\t  },\n\t  {\n\t    type: 'number',\n", "    name: 'temperature',\n\t    message: 'Temperature ?',\n\t    default: 0.8\n\t  },\n\t  {\n\t    type: 'number',\n\t    name: 'frequencyPenalty',\n\t    message: 'Frequency Penalty (-2/2) ?',\n\t    default: 0\n\t  },\n", "  {\n\t    type: 'number',\n\t    name: 'presencePenalty',\n\t    message: 'Presence Penalty (-2/2) ?',\n\t    default: 1\n\t  },\n\t  {\n\t    type: 'number',\n\t    name: 'logitBias',\n\t    message: 'Logit bias ?',\n", "    default: 0\n\t  }\n\t]\n\tconst customQuestions = [\n\t  {\n\t    type: 'autocomplete',\n\t    name: 'language',\n\t    message: 'Language ?',\n\t    source: (answersSoFar, input) => LANGUAGES.filter((language) => language.startsWith(input)),\n\t    default: 'english'\n", "  },\n\t  {\n\t    type: 'list',\n\t    name: 'model',\n\t    message: 'AI model ?',\n\t    choices: MODELS,\n\t    default: 'gpt-4'\n\t  },\n\t  {\n\t    type: 'input',\n", "    name: 'filename',\n\t    message: 'Filename (without extension) ?',\n\t    default: 'post'\n\t  },\n\t  {\n\t    type: 'number',\n\t    name: 'temperature',\n\t    message: 'Temperature ?',\n\t    default: 0.8\n\t  },\n", "  {\n\t    type: 'number',\n\t    name: 'frequencyPenalty',\n\t    message: 'Frequency Penalty (-2/2) ?',\n\t    default: 0\n\t  },\n\t  {\n\t    type: 'number',\n\t    name: 'presencePenalty',\n\t    message: 'Presence Penalty (-2/2) ?',\n", "    default: 1\n\t  }\n\t]\n\texport async function askQuestions () {\n\t  return inquirer.prompt(questions)\n\t}\n\texport async function askCustomQuestions () {\n\t  return inquirer.prompt(customQuestions)\n\t}\n"]}
{"filename": "src/lib/tokenizer.ts", "chunked_list": ["// eslint-disable-next-line camelcase\n\timport { get_encoding } from '@dqbd/tiktoken'\n\t// TODO: make this configurable\n\tconst tokenizer = get_encoding('cl100k_base')\n\texport function encode (input: string): Uint32Array {\n\t  return tokenizer.encode(input)\n\t}\n"]}
{"filename": "src/lib/template.ts", "chunked_list": ["export function extractPrompts (template: string): string[] {\n\t  const regex = /{\\d+:((?:.|\\n)*?)}/g\n\t  return Array.from(template.matchAll(regex)).map((match) => match[1].trim())\n\t}\n\texport function replacePrompt (template: string, index: number, content: string): string {\n\t  const regex = new RegExp(`{${index}:((?:.|\\n)*?)}`)\n\t  return template.replace(regex, content)\n\t}\n\texport function replaceAllPrompts (template: string, contents: string[]): string {\n\t  // We are removing the first prompt because it is the system prompt\n", "  let tmpTemplate = replacePrompt(template, 0, '')\n\t  contents.forEach((content, index) => {\n\t    tmpTemplate = replacePrompt(tmpTemplate, index + 1, content)\n\t  })\n\t  return tmpTemplate.trim()\n\t}\n"]}
{"filename": "src/lib/prompts.ts", "chunked_list": ["import { PostPrompt } from '../types'\n\tconst STRUCTURE_OUTLINE = 'Generate the blog post outline with the following JSON format: ' +\n\t'{\"title\": \"\", // Add the post title here ' +\n\t'\"headings\" : [ { \"title\": \"\", // Add the heading title here ' +\n\t  '\"keywords\": [\"...\", \"...\", \"...\", \"...\"], // Add a list of keywords here. They will help to generate the final content of this heading.' +\n\t  '\"headings\": [ // If necessary, add subheadings here. This is optional.' +\n\t    '{ \"title\": \"\", ' + '\"keywords\": [\"...\", \"...\"] },' +\n\t    '{ \"title\": \"\", \"keywords\": [\"...\", \"...\"] }, ... ] } ... ],' +\n\t'\"slug\" : \"\", // Use the main keywords for the slug based on the topic of the post. Do not mention the country. Max 3 or 4 keywords, without stop words and with text normalization and accent stripping.' +\n\t'\"seoTitle\" : \"\", // Not the same as the post title, max 60 characters, do not mention the country.' +\n", "'\"seoDescription : \"\" // Max 155 characters }'\n\tconst INFORMATIVE_INTRO_PROMPT = 'Compose the introduction for this blog post topic, without using phrases such as, \"In this article,...\" to introduce the subject.' +\n\t  'Instead, explain the context and/or explain the main problem. If necessary, mention facts to help the user better understand the context or the problem. Do not describe or introduce the content of the different headings of the outline.' +\n\t  'Do not add a heading. Your responses should be in the markdown format. Do not add the title in the beginning of the introduction.'\n\tconst CAPTIVATING_INTO_PROMPT = 'Compose a captivating introduction for this blog post topic, without using phrases such as, \"In this article,...\" to introduce the subject.' +\n\t  'Instead, focus on creating a hook to capture the reader\\'s attention, setting the tone and style, and seamlessly leading the reader into the main content of the article.' +\n\t  'Your introduction should entice readers to continue reading the article and learn more about the subject presented.' +\n\t  ' Do not add a heading. Your responses should be in the markdown format. Do not add the title in the beginning of the introduction.'\n\t// ------------------------------------------------------\n\t// PROMPTS FOR THE INTERACTIVE / AUTO MODE\n", "// ------------------------------------------------------\n\texport function getAutoSystemPrompt (postPrompt : PostPrompt) {\n\t  return 'You are a copywriter with a strong expertise in SEO. I need a detailed blog post in ' + postPrompt.language + ' about the topic: \"' + postPrompt.topic + '\".' +\n\t    'Do not add a paragraph summarizing your response/explanation at the end of your answers.'\n\t}\n\texport function getPromptForIntentAudience (postPrompt : PostPrompt) {\n\t  return 'For a post based on the topic : ' + postPrompt.topic + ', describe the ideal audience and intent for this topic.' +\n\t  'Write maximum 3 statements for the audience and also 3 statements for the intent.' +\n\t  'Your response should be only the following object in json format : ' +\n\t  '{\"audience\" : \"\", \"intent\": \"\"}'\n", "}\n\texport function getPromptForOutline (postPrompt : PostPrompt) {\n\t  const { country, intent, audience } = postPrompt\n\t  const prompt = STRUCTURE_OUTLINE +\n\t  'For the title and headings, do not capitalize words unless the first one.' +\n\t  'Please make sure your title is clear, concise, and accurately represents the topic of the post.' +\n\t  'Do not add a heading for an introduction, conclusion, or to summarize the article.' +\n\t  (country ? 'Market/country/region:' + country + '.' : '') +\n\t  (audience ? 'Audience: ' + audience + '.' : '') +\n\t  (intent ? 'Content intent: ' + intent + '.' : '')\n", "  return prompt\n\t}\n\texport function getPromptForMainKeyword () {\n\t  const prompt = 'Give me the most important SEO keyword in a JSON array in which each item matches a word without the stop words.'\n\t  return prompt\n\t}\n\texport function getPromptForIntroduction (postPrompt : PostPrompt) {\n\t  return (!postPrompt.tone) || postPrompt.tone === 'informative' ? INFORMATIVE_INTRO_PROMPT : CAPTIVATING_INTO_PROMPT\n\t}\n\texport function getPromptForHeading (tone : string, title : string, keywords : string[] | null) {\n", "  return tone === 'informative' ? getPromptForInformativeHeading(title, keywords) : getPromptForCaptivatingHeading(title, keywords)\n\t}\n\texport function getPromptForConclusion () {\n\t  return 'Write a compelling conclusion for this blog post topic without using transitional phrases such as, \"In conclusion\", \"In summary\", \"In short\", \"So\", \"Thus\", or any other transitional expressions.' +\n\t  'Focus on summarizing the main points of the post, emphasizing the significance of the topic, and leaving the reader with a lasting impression or a thought-provoking final remark.' +\n\t  'Ensure that your conclusion effectively wraps up the article and reinforces the central message or insights presented in the blog post.' +\n\t  'Do not add a heading. Your responses should be in the markdown format.'\n\t}\n\tfunction getPromptForInformativeHeading (title : string, keywords : string[] | null) {\n\t  const promptAboutKeywords = keywords ? ' based on the following list of keywords: ' + keywords.join(', ') + '.' : ''\n", "  return 'Write some informative content for the heading (without the heading)  \"' + title + '\"' + promptAboutKeywords +\n\t    'Make sure to provide in-depth information and valuable insights. Use clear and concise language, along with relevant examples or anecdotes if needed.' +\n\t    'Do not start the first sentence with the heading. Instead, start with a sentence that introduces and provides context for the heading.' +\n\t    'I do not want a conclusion or summary at the end of the generated text. Just the information requested. ' +\n\t    'This rule applies to all languages. ' +\n\t    'So do not add a paragraph at the end of your text beginning with one of the following words or variants: in conclusion, in sum, to conclude, in summary, ... ' +\n\t    'Your response should be in the markdown format.'\n\t}\n\tfunction getPromptForCaptivatingHeading (title : string, keywords : string[] | null) {\n\t  const promptAboutKeywords = keywords ? ' based on the following list of keywords: ' + keywords.join(', ') + '.' : ''\n", "  return 'Write some captivating content for the heading (without the heading): \"' + title + '\"' + promptAboutKeywords +\n\t  'Make sure to provide in-depth information and valuable insights. Use clear and concise language, along with relevant examples or anecdotes, to engage the reader and enhance their understanding.' +\n\t  'Do not start the first sentence with the heading. Instead, start with a sentence that introduces and provides context for the heading.' +\n\t  'I do not want a conclusion or summary at the end of the generated text. Just the information requested. ' +\n\t  'This rule applies to all languages. ' +\n\t  'So do not add a paragraph at the end of your text beginning with one of the following words or variants: in conclusion, in sum, to conclude, in summary, ... ' +\n\t  'Your response should be in the markdown format.'\n\t}\n\t// ------------------------------------------------------\n\t// PROMPTS FOR THE CUSTOM MODE (based on a template)\n", "// ------------------------------------------------------\n\texport function getCustomSystemPrompt (postPrompt : PostPrompt) {\n\t  // The prompt with the index 0 in the template is the system prompt\n\t  return postPrompt.prompts[0] + '\\n' + ' Language: ' + postPrompt.language + '. '\n\t}\n\texport function getSeoSystemPrompt (postPrompt : PostPrompt) {\n\t  return 'You are a SEO expert and you need to optimize a web page based on the following info in ' + postPrompt.language + ': ' +\n\t    '\\n' + postPrompt.prompts[0]\n\t}\n\texport function getPromptForSeoInfo (postPrompt : PostPrompt) {\n", "  return 'For content based on the topic of this conversation, Use the H1 provided in the system prompt. If not, write a new H1. ' +\n\t  'Use the slug provided in the system prompt. If not, write a new slug.' +\n\t  'Write an SEO title and an SEO description for this blog post.' +\n\t  'The SEO title should be no more than 60 characters long.' +\n\t  'The H1 and the title should be different.' +\n\t  'The SEO description should be no more than 155 characters long.' +\n\t  'Use the main keywords for the slug based on the topic of the post. Do not mention the country. Max 3 or 4 keywords, without stop words, and with text normalization and accent stripping.' +\n\t  'Your response should be in the JSON format based on the following structure: ' +\n\t  '{\"h1\" : \"\", \"seoTitle\": \"\", \"\": \"seoDescription\": \"\", \"slug\": \"\"}'\n\t}\n"]}
{"filename": "src/lib/errors.ts", "chunked_list": ["export class NoApiKeyError extends Error {\n\t  constructor () {\n\t    super()\n\t    this.name = 'NoApiKeyError'\n\t  }\n\t}\n"]}
{"filename": "src/lib/extractor.ts", "chunked_list": ["import JSON5 from 'json5'\n\timport { validate } from 'jsonschema'\n\timport { AudienceIntentInfo, PostOutline, SeoInfo } from '../types'\n\texport class PostOutlineValidationError extends Error {\n\t  constructor (message: string, public readonly errors: any[]) {\n\t    super(message)\n\t  }\n\t}\n\tconst schemaValidiation = {\n\t  $schema: 'http://json-schema.org/draft-07/schema#',\n", "  type: 'object',\n\t  properties: {\n\t    title: {\n\t      type: 'string'\n\t    },\n\t    headings: {\n\t      type: 'array',\n\t      items: {\n\t        $ref: '#/definitions/Heading'\n\t      }\n", "    },\n\t    slug: {\n\t      type: 'string'\n\t    },\n\t    seoTitle: {\n\t      type: 'string'\n\t    },\n\t    seoDescription: {\n\t      type: 'string'\n\t    }\n", "  },\n\t  required: [\n\t    'title',\n\t    'headings',\n\t    'slug',\n\t    'seoTitle',\n\t    'seoDescription'\n\t  ],\n\t  additionalProperties: false,\n\t  definitions: {\n", "    Heading: {\n\t      type: 'object',\n\t      properties: {\n\t        title: {\n\t          type: 'string'\n\t        },\n\t        keywords: {\n\t          type: 'array',\n\t          items: {\n\t            type: 'string'\n", "          }\n\t        },\n\t        headings: {\n\t          type: 'array',\n\t          items: {\n\t            $ref: '#/definitions/Heading'\n\t          }\n\t        }\n\t      },\n\t      required: [\n", "        'title'\n\t      ],\n\t      additionalProperties: false\n\t    }\n\t  }\n\t}\n\texport function extractCodeBlock (text: string): string {\n\t  // Extract code blocks with specified tags\n\t  const codeBlockTags = ['markdown', 'html', 'json']\n\t  for (const tag of codeBlockTags) {\n", "    const regex = new RegExp(`\\`\\`\\`${tag}((.|\\\\n|\\\\r)*?)\\`\\`\\``, 'i')\n\t    const match = text.match(regex)\n\t    if (match) {\n\t      return match[1]\n\t    }\n\t  }\n\t  // Extract code blocks without specified tags\n\t  const genericRegex = /```\\n?((.|\\\\n|\\\\r)*?)```/\n\t  const genericMatch = text.match(genericRegex)\n\t  if (genericMatch) {\n", "    return genericMatch[1]\n\t  }\n\t  // No code blocks found\n\t  return text\n\t}\n\texport function extractPostOutlineFromCodeBlock (text: string) : PostOutline {\n\t  // Use JSON5 because it supports trailing comma and comments in the json text\n\t  const jsonData = JSON5.parse(extractCodeBlock(text))\n\t  const v = validate(jsonData, schemaValidiation)\n\t  if (!v.valid) {\n", "    const errorList = v.errors.map((val) => val.toString())\n\t    throw new PostOutlineValidationError('Invalid json for the post outline', errorList)\n\t  }\n\t  return jsonData\n\t}\n\texport function extractJsonArray (text : string) : string[] {\n\t  return JSON5.parse(extractCodeBlock(text))\n\t}\n\texport function extractSeoInfo (text : string) : SeoInfo {\n\t  return JSON5.parse(extractCodeBlock(text))\n", "}\n\texport function extractAudienceIntentInfo (text : string) : AudienceIntentInfo {\n\t  return JSON5.parse(extractCodeBlock(text))\n\t}\n"]}
{"filename": "src/lib/post-helpers.ts", "chunked_list": ["import * as dotenv from 'dotenv'\n\timport { readFile as rd } from 'fs'\n\timport { promisify } from 'util'\n\timport { ChatGPTAPI, ChatGPTError, ChatMessage, SendMessageOptions } from 'chatgpt'\n\timport pRetry, { AbortError, FailedAttemptError } from 'p-retry'\n\timport { extractJsonArray, extractCodeBlock, extractPostOutlineFromCodeBlock, extractSeoInfo, extractAudienceIntentInfo } from './extractor'\n\timport {\n\t  getPromptForMainKeyword,\n\t  getPromptForOutline,\n\t  getPromptForIntroduction,\n", "  getPromptForHeading,\n\t  getPromptForConclusion,\n\t  getAutoSystemPrompt,\n\t  getPromptForSeoInfo,\n\t  getCustomSystemPrompt,\n\t  getSeoSystemPrompt,\n\t  getPromptForIntentAudience as getPromptForAudienceIntent\n\t} from './prompts'\n\timport {\n\t  Heading,\n", "  PostOutline,\n\t  PostPrompt,\n\t  TotalTokens,\n\t  SeoInfo\n\t} from '../types'\n\timport { encode } from './tokenizer'\n\timport { extractPrompts } from './template'\n\timport { log } from 'console'\n\timport { NoApiKeyError } from './errors'\n\tdotenv.config()\n", "const readFile = promisify(rd)\n\t/**\n\t* Specific Open AI API parameters for the completion\n\t*/\n\texport type CompletionParams = {\n\t  temperature?: number | null,\n\t  top_p?: number | null,\n\t  max_tokens?: number,\n\t  presence_penalty?: number | null,\n\t  frequency_penalty?: number | null,\n", "  logit_bias?: object | null,\n\t}\n\t/**\n\t * Interface for the helper class for generating a post. it defines how to generate a post\n\t * Each helper class must implement this interface\n\t * @interface\n\t */\n\texport interface GeneratorHelperInterface {\n\t  init () : Promise<void>\n\t  isCustom() : boolean\n", "  generateContentOutline () : Promise<PostOutline>\n\t  generateMainKeyword () : Promise<string[]>\n\t  generateIntroduction () : Promise<string>\n\t  generateConclusion () : Promise<string>\n\t  generateHeadingContents (tableOfContent : PostOutline) : Promise<string>\n\t  generateCustomPrompt(prompt : string) : Promise<string>\n\t  generateSeoInfo () : Promise<SeoInfo>\n\t  getTotalTokens() : TotalTokens\n\t  getPrompt() : PostPrompt\n\t}\n", "/**\n\t * Helper implementation for generating a post using the ChatGPT API\n\t * @class\n\t */\n\texport class ChatGptHelper implements GeneratorHelperInterface {\n\t  private postPrompt : PostPrompt\n\t  private api : ChatGPTAPI\n\t  // The parent message is either the previous one in the conversation (if a template is used)\n\t  // or the generated outline (if we are in auto mode)\n\t  private chatParentMessage : ChatMessage\n", "  private completionParams : CompletionParams\n\t  private totalTokens : TotalTokens = {\n\t    promptTokens: 0,\n\t    completionTokens: 0,\n\t    total: 0\n\t  }\n\t  // -----------------------------------------------\n\t  // CONSTRUCTOR AND INITIALIZATION\n\t  // -----------------------------------------------\n\t  public constructor (postPrompt : PostPrompt) {\n", "    this.postPrompt = postPrompt\n\t  }\n\t  isCustom () : boolean {\n\t    return this.postPrompt?.templateFile !== undefined\n\t  }\n\t  getPrompt (): PostPrompt {\n\t    return this.postPrompt\n\t  }\n\t  getTotalTokens (): TotalTokens {\n\t    return this.totalTokens\n", "  }\n\t  async init () {\n\t    if (this.isCustom()) {\n\t      if (this.postPrompt.debug) {\n\t        console.log(`Use template : ${this.postPrompt.templateFile}`)\n\t      }\n\t      this.postPrompt.templateContent = await this.readTemplate()\n\t      this.postPrompt.prompts = extractPrompts(this.postPrompt.templateContent)\n\t    }\n\t    const systemMessage = this.isCustom() ? getCustomSystemPrompt(this.postPrompt) : getAutoSystemPrompt(this.postPrompt)\n", "    await this.buildChatGPTAPI(systemMessage)\n\t  }\n\t  private async buildChatGPTAPI (systemMessage : string) {\n\t    try {\n\t      this.api = new ChatGPTAPI({\n\t        apiKey: this.postPrompt?.apiKey || process.env.OPENAI_API_KEY,\n\t        completionParams: {\n\t          model: this.postPrompt.model\n\t        },\n\t        systemMessage,\n", "        debug: this.postPrompt.debugapi\n\t      })\n\t    } catch (error) {\n\t      throw new NoApiKeyError()\n\t    }\n\t    if (this.postPrompt.debug) {\n\t      console.log(`OpenAI API initialized with model : ${this.postPrompt.model}`)\n\t    }\n\t    this.completionParams = {\n\t      temperature: this.postPrompt.temperature ?? 0.8,\n", "      frequency_penalty: this.postPrompt.frequencyPenalty ?? 0,\n\t      presence_penalty: this.postPrompt.presencePenalty ?? 1\n\t    }\n\t    if (this.postPrompt.logitBias) {\n\t      const mainKwWords = await this.generateMainKeyword()\n\t      // set the logit bias in order to force the model to minimize the usage of the main keyword\n\t      const logitBiais: Record<number, number> = {}\n\t      mainKwWords.forEach((kw) => {\n\t        const encoded = encode(kw)\n\t        encoded.forEach((element) => {\n", "          logitBiais[element] = Number(this.postPrompt.logitBias) || -1\n\t        })\n\t      })\n\t      this.completionParams.logit_bias = logitBiais\n\t    }\n\t    if (this.postPrompt.debug) {\n\t      console.log('---------- COMPLETION PARAMETERS ----------')\n\t      console.log('Max Tokens  : ' + this.completionParams.max_tokens)\n\t      console.log('Temperature : ' + this.completionParams.temperature)\n\t      console.log('Frequency Penalty : ' + this.completionParams.frequency_penalty)\n", "      console.log('Presence Penalty : ' + this.completionParams.presence_penalty)\n\t      console.log('Logit Biais : ' + this.completionParams.logit_bias)\n\t    }\n\t  }\n\t  // -----------------------------------------------\n\t  // METHODS FOR THE AUTOMATIC MODE\n\t  // -----------------------------------------------\n\t  async generateMainKeyword () {\n\t    const prompt = getPromptForMainKeyword()\n\t    if (this.postPrompt.debug) {\n", "      console.log('---------- PROMPT MAIN KEYWORD ----------')\n\t      console.log(prompt)\n\t    }\n\t    const response = await this.sendRequest(prompt)\n\t    if (this.postPrompt.debug) {\n\t      console.log('---------- MAIN KEYWORD ----------')\n\t      console.log(response.text)\n\t    }\n\t    return extractJsonArray(response.text)\n\t  }\n", "  async generateContentOutline () {\n\t    if (this.postPrompt.generate) {\n\t      const audienceIntent = await this.generateAudienceIntent()\n\t      this.postPrompt = {\n\t        ...audienceIntent,\n\t        ...this.postPrompt\n\t      }\n\t    }\n\t    const prompt = getPromptForOutline(this.postPrompt)\n\t    if (this.postPrompt.debug) {\n", "      console.log('---------- PROMPT OUTLINE ----------')\n\t      console.log(prompt)\n\t    }\n\t    // the parent message is the outline for the upcoming content\n\t    // By this way, we can decrease the cost of the API call by minimizing the number of prompt tokens\n\t    // TODO : add an option to disable this feature\n\t    this.chatParentMessage = await this.sendRequest(prompt)\n\t    if (this.postPrompt.debug) {\n\t      console.log('---------- OUTLINE ----------')\n\t      console.log(this.chatParentMessage.text)\n", "    }\n\t    return extractPostOutlineFromCodeBlock(this.chatParentMessage.text)\n\t  }\n\t  async generateAudienceIntent () {\n\t    const prompt = getPromptForAudienceIntent(this.postPrompt)\n\t    if (this.postPrompt.debug) {\n\t      console.log('---------- PROMPT AUDIENCE INTENT ----------')\n\t      console.log(prompt)\n\t    }\n\t    const response = await this.sendRequest(prompt)\n", "    if (this.postPrompt.debug) {\n\t      console.log('---------- AUDIENCE INTENT ----------')\n\t      console.log(response.text)\n\t    }\n\t    return extractAudienceIntentInfo(response.text)\n\t  }\n\t  async generateIntroduction () {\n\t    const response = await this.sendRequest(getPromptForIntroduction(this.postPrompt), this.completionParams)\n\t    return extractCodeBlock(response.text)\n\t  }\n", "  async generateConclusion () {\n\t    const response = await this.sendRequest(getPromptForConclusion(), this.completionParams)\n\t    return extractCodeBlock(response.text)\n\t  }\n\t  async generateHeadingContents (postOutline : PostOutline) {\n\t    const headingLevel = 2\n\t    return await this.buildContent(postOutline.headings, headingLevel)\n\t  }\n\t  private async buildContent (headings: Heading[], headingLevel : number, previousContent: string = ''): Promise<string> {\n\t    if (headings.length === 0) {\n", "      return previousContent\n\t    }\n\t    const [currentHeading, ...remainingHeadings] = headings\n\t    const mdHeading = Array(headingLevel).fill('#').join('')\n\t    let content = previousContent + '\\n' + mdHeading + ' ' + currentHeading.title\n\t    if (currentHeading.headings && currentHeading.headings.length > 0) {\n\t      content = await this.buildContent(currentHeading.headings, headingLevel + 1, content)\n\t    } else {\n\t      content += '\\n' + await this.getContent(currentHeading)\n\t    }\n", "    return this.buildContent(remainingHeadings, headingLevel, content)\n\t  }\n\t  private async getContent (heading: Heading): Promise<string> {\n\t    if (this.postPrompt.debug) {\n\t      console.log(`\\nHeading : ${heading.title}  ...'\\n`)\n\t    }\n\t    const response = await this.sendRequest(getPromptForHeading(this.postPrompt.tone, heading.title, heading.keywords), this.completionParams)\n\t    return `${extractCodeBlock(response.text)}\\n`\n\t  }\n\t  // -----------------------------------------------\n", "  // METHODS FOR THE CUSTOM MODE base on a template\n\t  // -----------------------------------------------\n\t  /**\n\t   * Generate a content based on one of prompt defined in the template\n\t   * @param customPrompt :  the prompt defined in the template\n\t   * @returns the AI answer\n\t   */\n\t  async generateCustomPrompt (customPrompt : string) {\n\t    this.chatParentMessage = await this.sendRequest(customPrompt, this.completionParams)\n\t    return extractCodeBlock(this.chatParentMessage.text)\n", "  }\n\t  /**\n\t   * Generate the SEO info for the post based on the template\n\t   * @returns the SEO info\n\t   */\n\t  async generateSeoInfo (): Promise<SeoInfo> {\n\t    const systemPrompt = getSeoSystemPrompt(this.postPrompt)\n\t    await this.buildChatGPTAPI(systemPrompt)\n\t    this.chatParentMessage = await this.sendRequest(getPromptForSeoInfo(this.postPrompt), this.completionParams)\n\t    if (this.postPrompt.debug) {\n", "      log('---------- SEO INFO ----------')\n\t      console.log(this.chatParentMessage.text)\n\t    }\n\t    return extractSeoInfo(this.chatParentMessage.text)\n\t  }\n\t  private async readTemplate () : Promise<string> {\n\t    const templatePath = this.postPrompt.templateFile\n\t    return await readFile(templatePath, 'utf-8')\n\t  }\n\t  // -----------------------------------------------\n", "  // SEND REQUEST TO OPENAI API\n\t  // -----------------------------------------------\n\t  private async sendRequest (prompt : string, completionParams? : CompletionParams) {\n\t    return await pRetry(async () => {\n\t      const options : SendMessageOptions = { parentMessageId: this.chatParentMessage?.id }\n\t      if (completionParams) {\n\t        options.completionParams = completionParams\n\t      }\n\t      const response = await this.api.sendMessage(prompt, options)\n\t      this.totalTokens.promptTokens += response.detail.usage.prompt_tokens\n", "      this.totalTokens.completionTokens += response.detail.usage.completion_tokens\n\t      this.totalTokens.total += response.detail.usage.total_tokens\n\t      return response\n\t    }, {\n\t      retries: 10,\n\t      onFailedAttempt: async (error) => {\n\t        this.manageError(error)\n\t      }\n\t    })\n\t  }\n", "  private manageError (error: FailedAttemptError) {\n\t    if (this.postPrompt.debug) {\n\t      console.log('---------- OPENAI REQUEST ERROR ----------')\n\t      console.log(error)\n\t    }\n\t    if (error instanceof ChatGPTError) {\n\t      const chatGPTError = error as ChatGPTError\n\t      if (chatGPTError.statusCode === 401) {\n\t        console.log('OpenAI API Error : Invalid API key: please check your API key in the option -k or in the OPENAI_API_KEY env var.')\n\t        process.exit(1)\n", "      }\n\t      if (chatGPTError.statusCode === 404) {\n\t        console.log(`OpenAI API Error :  Invalid model for your OpenAI subscription. Check if you can use : ${this.postPrompt.model}.`)\n\t        console.log(this.postPrompt.model === 'gpt-4' || this.postPrompt.model === 'gpt-4-32k' ? 'You need to join the waiting list to use the GPT-4 API : https://openai.com/waitlist/gpt-4-api' : '')\n\t        process.exit(1)\n\t      }\n\t    }\n\t    if (error instanceof AbortError) {\n\t      console.log(`OpenAI API - Request aborted. ${error.message}`)\n\t    } else {\n", "      console.log(`OpenAI API - Request failed - Attempt ${error.attemptNumber} failed. There are ${error.retriesLeft} retries left. ${error.message}`)\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/lib/store/store.ts", "chunked_list": ["import os from 'os'\n\timport fs from 'fs'\n\timport path from 'path'\n\timport util from 'util'\n\timport { Wordpress } from './types'\n\tconst readFile = util.promisify(fs.readFile)\n\tconst userHomeDir = os.homedir()\n\tconst HIDDEN_DIR_NAME = '.julius'\n\tconst hiddenDirPath = path.join(userHomeDir, HIDDEN_DIR_NAME)\n\tconst WORDPRESS_FILE = `${hiddenDirPath}/wordpress.json`\n", "export function initStore () {\n\t  if (!fs.existsSync(hiddenDirPath)) {\n\t    fs.mkdirSync(hiddenDirPath)\n\t  }\n\t  if (!fs.existsSync(WORDPRESS_FILE)) {\n\t    fs.writeFileSync(WORDPRESS_FILE, '[]', 'utf8')\n\t  }\n\t}\n\texport async function getAllWordpress () : Promise<Wordpress[]> {\n\t  const data = await readFile(WORDPRESS_FILE, 'utf8')\n", "  return JSON.parse(data)\n\t}\n\texport async function addWordpress (wp: Wordpress): Promise<void> {\n\t  const wpSites = [...await getAllWordpress(), wp].sort((a, b) => a.domain.localeCompare(b.domain))\n\t  await fs.promises.writeFile(WORDPRESS_FILE, JSON.stringify(wpSites), 'utf8')\n\t}\n\texport async function getWordpress (domain: string): Promise<Wordpress | undefined> {\n\t  const wpSites = await getAllWordpress()\n\t  const index = !isNaN(Number(domain)) ? Number(domain) - 1 : wpSites.findIndex((wp) => wp.domain === domain)\n\t  return wpSites[index]\n", "}\n\texport async function removeWordpress (domain: string): Promise<Boolean> {\n\t  const wpSites = await getAllWordpress()\n\t  const index = !isNaN(Number(domain)) ? Number(domain) - 1 : wpSites.findIndex((wp) => wp.domain === domain)\n\t  if (index < 0) {\n\t    return false\n\t  }\n\t  wpSites.splice(index, 1)\n\t  await fs.promises.writeFile(WORDPRESS_FILE, JSON.stringify(wpSites), 'utf8')\n\t  return true\n", "}\n\texport async function exportWordpressList (exportFile : string) {\n\t  await fs.promises.copyFile(WORDPRESS_FILE, exportFile)\n\t}\n\texport async function importWordpressList (importFile : string) {\n\t  const data = await readFile(importFile, 'utf8')\n\t  const wpSites = JSON.parse(data)\n\t  await fs.promises.writeFile(WORDPRESS_FILE, JSON.stringify(wpSites), 'utf8')\n\t}\n"]}
{"filename": "src/lib/store/types.ts", "chunked_list": ["export type Wordpress = {\n\t    domain : string,\n\t    username: string,\n\t    password: string\n\t}\n"]}
{"filename": "src/lib/wp/wp-api.ts", "chunked_list": ["import moment from 'moment-timezone'\n\timport axios from 'axios'\n\timport { Wordpress } from '../store/types'\n\timport { Post } from 'src/types'\n\ttype UpdatePost = {\n\t  content: string;\n\t  title: string;\n\t  meta: {\n\t    yoast_wpseo_title: string,\n\t    yoast_wpseo_metadesc: string\n", "  };\n\t  date?: string;\n\t  date_gmt?: string;\n\t}\n\texport async function getCategories (wp : Wordpress) {\n\t  const { domain, username, password } = wp\n\t  const response = await axios.get(`${getApiUrl(domain)}/categories`, authenticate(username, password))\n\t  return response.data.map((category) => {\n\t    return {\n\t      id: category.id,\n", "      name: category.name,\n\t      slug: category.slug\n\t    }\n\t  })\n\t}\n\texport async function createPost (wp : Wordpress, post : Post) {\n\t  const { domain, username, password } = wp\n\t  const postData : any = {\n\t    ...post\n\t  }\n", "  postData.meta = {\n\t    yoast_wpseo_title: post.seoTitle,\n\t    yoast_wpseo_metadesc: post.seoDescription\n\t  }\n\t  return await axios.post(`${getApiUrl(domain)}/posts`, postData, authenticate(username, password))\n\t}\n\texport async function updatePost (wp : Wordpress, slug: string, newContent : Post, publishDate : string) {\n\t  const { domain, username, password } = wp\n\t  const apiUrl = getApiUrl(domain)\n\t  const response = await axios.get(`${apiUrl}/posts?slug=${slug}`, authenticate(username, password))\n", "  if (response.data.length === 0) {\n\t    throw new Error(`Post with ${slug} not found`)\n\t  }\n\t  const postId: number = response.data[0].id\n\t  const updatedPost : UpdatePost = {\n\t    content: newContent.content,\n\t    title: newContent.title,\n\t    meta: {\n\t      yoast_wpseo_title: newContent.seoTitle,\n\t      yoast_wpseo_metadesc: newContent.seoDescription\n", "    }\n\t  }\n\t  if (publishDate) {\n\t    updatedPost.date = publishDate\n\t    updatedPost.date_gmt = moment(publishDate).utc().format()\n\t  }\n\t  await axios.put(`${apiUrl}/posts/${postId}`, updatedPost, authenticate(username, password))\n\t}\n\tfunction getApiUrl (domain) {\n\t  return `https://${domain}/wp-json/wp/v2`\n", "}\n\tfunction authenticate (username : string, password : string) {\n\t  const token = Buffer.from(`${username}:${password}`, 'utf8').toString('base64')\n\t  return {\n\t    headers: {\n\t      Authorization: `Basic ${token}`,\n\t      'Content-Type': 'application/json'\n\t    }\n\t  }\n\t};\n"]}
{"filename": "src/lib/image/midjourney.ts", "chunked_list": ["import * as dotenv from 'dotenv'\n\timport { Midjourney } from 'midjourney'\n\tdotenv.config()\n\texport async function generateImage (prompt : string) : Promise<string[]> {\n\t  const client = new Midjourney({\n\t    ServerId: process.env.SERVER_ID,\n\t    ChannelId: process.env.CHANNEL_ID,\n\t    SalaiToken: process.env.SALAI_TOKEN,\n\t    Debug: true,\n\t    Ws: true\n", "  })\n\t  await client.Connect()\n\t  const imagine = await client.Imagine(prompt)\n\t  const upscale1 = await client.Upscale({\n\t    index: 1,\n\t    msgId: <string>imagine.id,\n\t    hash: <string>imagine.hash,\n\t    flags: imagine.flags,\n\t    loading: (uri: string, progress: string) => {\n\t      console.log('Upscale.loading', uri, 'progress', progress)\n", "    }\n\t  })\n\t  const upscale2 = await client.Upscale({\n\t    index: 2,\n\t    msgId: <string>imagine.id,\n\t    hash: <string>imagine.hash,\n\t    flags: imagine.flags,\n\t    loading: (uri: string, progress: string) => {\n\t      console.log('Upscale.loading', uri, 'progress', progress)\n\t    }\n", "  })\n\t  const upscale3 = await client.Upscale({\n\t    index: 3,\n\t    msgId: <string>imagine.id,\n\t    hash: <string>imagine.hash,\n\t    flags: imagine.flags,\n\t    loading: (uri: string, progress: string) => {\n\t      console.log('Upscale.loading', uri, 'progress', progress)\n\t    }\n\t  })\n", "  const upscale4 = await client.Upscale({\n\t    index: 4,\n\t    msgId: <string>imagine.id,\n\t    hash: <string>imagine.hash,\n\t    flags: imagine.flags,\n\t    loading: (uri: string, progress: string) => {\n\t      console.log('Upscale.loading', uri, 'progress', progress)\n\t    }\n\t  })\n\t  return [upscale1.uri, upscale2.uri, upscale3.uri, upscale4.uri]\n", "}\n"]}
