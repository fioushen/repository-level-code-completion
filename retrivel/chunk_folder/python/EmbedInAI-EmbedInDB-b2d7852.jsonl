{"filename": "setup.py", "chunked_list": ["import os\n\timport setuptools\n\tdef read(fname):\n\t    with open(\n\t        os.path.join(os.path.dirname(__file__), fname), \"r\", encoding=\"utf-8\"\n\t    ) as fh:\n\t        return fh.read()\n\tsetuptools.setup(\n\t    name=\"embedin\",\n\t    version=\"0.2.2-alpha\",\n", "    author=\"EmbedInAI\",\n\t    author_email=\"EmbedInAI@gmail.com\",\n\t    description=\"A lightweight vector database\",\n\t    long_description=read(\"README.md\"),\n\t    long_description_content_type=\"text/markdown\",\n\t    url=\"https://github.com/EmbedInAI/EmbedInDB\",\n\t    packages=setuptools.find_packages(exclude=[\"tests\"]),\n\t    install_requires=read(\"requirements.txt\"),\n\t    include_package_data=True,\n\t    classifiers=[\n", "        \"Programming Language :: Python :: 3\",\n\t        \"License :: OSI Approved :: Apache Software License\",\n\t        \"Operating System :: OS Independent\",\n\t    ],\n\t    python_requires=\">=3.6\",\n\t)\n"]}
{"filename": "tests/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n"]}
{"filename": "tests/index/test_flat_index.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\timport numpy as np\n\tfrom faiss import IndexFlatIP\n\tfrom embedin.index.flat_index import FlatIndex\n\tclass TestFlatIndex(unittest.TestCase):\n", "    def setUp(self):\n\t        d = 64  # dimension\n\t        nb = 10**5  # database size\n\t        nq = 2  # nb of queries - TODO >= 5 will have segmentation fault\n\t        np.random.seed(1234)  # make reproducible\n\t        self.xb = np.random.random((nb, d)).astype(\"float32\")\n\t        self.xb[:, 0] += np.arange(nb) / 1000.0\n\t        self.xq = np.random.random((nq, d)).astype(\"float32\")\n\t        self.xq[:, 0] += np.arange(nq) / 1000.0\n\t        self.top_k = 2\n", "        self.gold_answer = np.array(\n\t            [207, 381, 1394, 1019, 555, 210, 417, 1619, 837, 557]\n\t        )\n\t        self.nn = FlatIndex(self.xb)\n\t    def test_init(self):\n\t        self.assertTrue(np.array_equal(self.nn.embeddings, np.array(self.xb)))\n\t        self.assertIsInstance(self.nn.index, IndexFlatIP)\n\t        self.assertEqual(self.nn.index.ntotal, len(self.xb))\n\t    def test_build_index(self):\n\t        index = self.nn._build_index()\n", "        self.assertTrue(isinstance(index, IndexFlatIP))\n\t    def test_search_index(self):\n\t        indices = self.nn._search_index(self.xq, top_k=10)\n\t        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\t    def test_search(self):\n\t        indices = self.nn.search(self.xq, top_k=10)\n\t        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\t    def test_update_index(self):\n\t        count = len(self.xb)\n\t        self.assertEqual(self.nn.index.ntotal, count)\n", "        new_embeddings = self.xq[0].tolist()\n\t        self.nn.update_index(new_embeddings)\n\t        count += 1\n\t        self.assertEqual(self.nn.index.ntotal, count)\n\t        indices = self.nn.search(self.xq[0], top_k=10)\n\t        self.assertTrue(count - 1 in indices.tolist())\n\t        new_embeddings = [self.xq[0].tolist(), self.xq[0].tolist()]\n\t        self.nn.update_index(new_embeddings)\n\t        count += len(new_embeddings)\n\t        self.assertEqual(self.nn.index.ntotal, count)\n", "        indices = self.nn.search(self.xq[0], top_k=10)\n\t        for i in range(len(new_embeddings)):\n\t            self.assertTrue(count - 1 - i in indices.tolist())\n\t        new_embeddings = []\n\t        self.nn.update_index(new_embeddings)\n\t        count += len(new_embeddings)\n\t        self.assertEqual(self.nn.index.ntotal, count)\n\t        new_embeddings = None\n\t        self.nn.update_index(new_embeddings)\n\t        self.assertEqual(self.nn.index.ntotal, count)\n", "    def test_get_embeddings(self):\n\t        embeddings = self.nn.get_embeddings()\n\t        self.assertTrue(np.array_equal(embeddings, np.array(self.xb)))\n"]}
{"filename": "tests/index/test_hnsw_index.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\timport numpy as np\n\timport torch\n\tfrom hnswlib import Index\n\tfrom embedin.index.hnsw_index import HNSWIndex\n", "class TestHNSWIndex(unittest.TestCase):\n\t    def setUp(self):\n\t        d = 64  # dimension\n\t        nb = 10**5  # database size\n\t        nq = 10  # nb of queries\n\t        np.random.seed(1234)  # make reproducible\n\t        self.xb = np.random.random((nb, d)).astype(\"float32\")\n\t        self.xb[:, 0] += np.arange(nb) / 1000.0\n\t        self.xq = np.random.random((nq, d)).astype(\"float32\")\n\t        self.xq[:, 0] += np.arange(nq) / 1000.0\n", "        self.top_k = 10\n\t        cos = torch.nn.CosineSimilarity()\n\t        output = cos(torch.from_numpy(self.xq[0]), torch.from_numpy(self.xb))\n\t        result = torch.topk(output.flatten(), self.top_k).indices.numpy()\n\t        self.gold_answer = np.array(\n\t            [207, 381, 1394, 1019, 555, 210, 417, 1619, 837, 557]\n\t        )\n\t        self.assertTrue(np.array_equal(self.gold_answer, result))\n\t        self.nn = HNSWIndex(self.xb)\n\t    def test_init(self):\n", "        self.assertTrue(np.array_equal(self.nn.embeddings, np.array(self.xb)))\n\t        self.assertIsInstance(self.nn.index, Index)\n\t        self.assertEqual(self.nn.index.get_current_count(), len(self.xb))\n\t    def test_build_index(self):\n\t        index = self.nn._build_index()\n\t        self.assertTrue(isinstance(index, Index))\n\t    def test_search_index(self):\n\t        indices = self.nn._search_index(self.xq, top_k=10)\n\t        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\t    def test_search(self):\n", "        indices = self.nn.search(self.xq, top_k=10)\n\t        self.assertTrue(np.array_equal(indices[0], self.gold_answer))\n\t    def test_update_index(self):\n\t        count = len(self.xb)\n\t        self.assertEqual(self.nn.index.get_current_count(), count)\n\t        new_embeddings = self.xq[0].tolist()\n\t        self.nn.update_index(new_embeddings)\n\t        count += 1\n\t        self.assertEqual(self.nn.index.get_current_count(), count)\n\t        indices = self.nn.search(self.xq, top_k=10)\n", "        self.assertTrue(count - 1 in indices[0].tolist())\n\t        new_embeddings = [self.xq[0].tolist(), self.xq[0].tolist()]\n\t        self.nn.update_index(new_embeddings)\n\t        count += len(new_embeddings)\n\t        self.assertEqual(self.nn.index.get_current_count(), count)\n\t        indices = self.nn.search(self.xq, top_k=10)\n\t        for i in range(len(new_embeddings)):\n\t            self.assertTrue(count - 1 - i in indices[0].tolist())\n\t        new_embeddings = []\n\t        self.nn.update_index(new_embeddings)\n", "        count += len(new_embeddings)\n\t        self.assertEqual(self.nn.index.get_current_count(), count)\n\t        new_embeddings = None\n\t        self.nn.update_index(new_embeddings)\n\t        self.assertEqual(self.nn.index.get_current_count(), count)\n\t    def test_get_embeddings(self):\n\t        embeddings = self.nn.get_embeddings()\n\t        self.assertTrue(np.array_equal(embeddings, np.array(self.xb)))\n"]}
{"filename": "tests/index/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\timport numpy as np\n\tfrom embedin.index import Index, HNSWIndex, FlatIndex\n\tclass TestIndex(unittest.TestCase):\n\t    def test_index_selection(self):\n", "        # Test when index_hint is hnsw\n\t        embeddings = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=\"float32\")\n\t        index = Index(embeddings, \"hnsw\")\n\t        self.assertIsInstance(index.index, HNSWIndex)\n\t        # Test when index_hint is flat\n\t        index = Index(embeddings, \"flat\")\n\t        self.assertIsInstance(index.index, FlatIndex)\n\t        # Test when embeddings length is less than or equal to 10^6\n\t        embeddings = np.random.random((10**6 - 1, 3)).astype(\"float32\")\n\t        index = Index(embeddings)\n", "        self.assertIsInstance(index.index, FlatIndex)\n\t        # Test when embeddings length is greater than 10^6\n\t        embeddings = np.random.random((10**6 + 1, 3)).astype(\"float32\")\n\t        index = Index(embeddings)\n\t        self.assertIsInstance(index.index, HNSWIndex)\n\t        # Test when embeddings is None\n\t        embeddings = np.random.random((4, 3)).astype(\"float32\")\n\t        index = Index(embeddings)\n\t        self.assertIsInstance(index.index, FlatIndex)\n\t    def test_search(self):\n", "        # Test search method with top_k=3\n\t        embeddings = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=\"float32\")\n\t        index = Index(embeddings)\n\t        query = np.array([1, 2, 3], dtype=\"float32\")\n\t        results = index.search(query)\n\t        self.assertEqual(len(results), 3)\n\t        embeddings = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\t        index = Index(embeddings)\n\t        query = [1, 2, 3]\n\t        results = index.search(query)\n", "        self.assertEqual(len(results), 3)\n\t    def test_update_index(self):\n\t        # Test update_index method\n\t        embeddings = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\t        index = Index(embeddings)\n\t        new_embeddings = [[10, 11, 12], [13, 14, 15]]\n\t        index.update_index(new_embeddings)\n\t        results = index.search([10, 11, 12])\n\t        self.assertEqual(len(results), 3)\n"]}
{"filename": "tests/repository/test_embedding_repository.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom datetime import datetime\n\tfrom unittest import TestCase\n\tfrom sqlalchemy import create_engine\n\tfrom sqlalchemy.orm import sessionmaker\n\tfrom embedin.model.embedding_model import EmbeddingModel, Base\n", "from embedin.repository.embedding_repository import EmbeddingRepository\n\tengine = create_engine(\"sqlite:///:memory:\", echo=True)\n\tSession = sessionmaker(bind=engine)\n\tclass TestEmbeddingRepository(TestCase):\n\t    def setUp(self):\n\t        Base.metadata.create_all(engine)\n\t        self.session = Session()\n\t        self.repository = EmbeddingRepository(self.session)\n\t        # Create some EmbeddingModel instances for testing\n\t        self.embeddings_dict = [\n", "            dict(\n\t                id=\"id1\",\n\t                collection_id=\"collection1\",\n\t                text=\"some text\",\n\t                embedding_data=[1.0, 2.0, 3.0],\n\t                meta_data={\"key1\": \"value1\"},\n\t                hash=\"hash1\",\n\t                created_at=datetime.now(),\n\t            ),\n\t            dict(\n", "                id=\"id2\",\n\t                collection_id=\"collection1\",\n\t                text=\"some other text\",\n\t                embedding_data=[4.0, 5.0, 6.0],\n\t                meta_data={\"key2\": \"value2\"},\n\t                hash=\"hash2\",\n\t                created_at=datetime.now(),\n\t            ),\n\t        ]\n\t        self.embeddings = [EmbeddingModel(**data) for data in self.embeddings_dict]\n", "    def tearDown(self):\n\t        self.session.rollback()\n\t        # Close the session and drop the in-memory database after testing\n\t        self.session.close()\n\t        Base.metadata.drop_all(engine)\n\t    def test_add_rows_one_by_one(self):\n\t        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 0)\n\t        self.repository._add_rows_one_by_one(self.embeddings)\n\t        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 2)\n\t        self.assertEqual(\n", "            self.session.query(EmbeddingModel).filter_by(id=\"id1\").first().text,\n\t            \"some text\",\n\t        )\n\t        self.assertEqual(\n\t            self.session.query(EmbeddingModel).filter_by(id=\"id2\").first().text,\n\t            \"some other text\",\n\t        )\n\t    def test_add_rows_one_by_one_duplicate(self):\n\t        self.repository.add_all(self.embeddings_dict)\n\t        # Test adding duplicate embeddings\n", "        duplicate_embeddings = [\n\t            EmbeddingModel(\n\t                id=\"id3\",\n\t                collection_id=\"collection1\",\n\t                text=\"some text\",\n\t                embedding_data=[1.0, 2.0, 3.0],\n\t                meta_data={\"key1\": \"value1\"},\n\t                hash=\"hash1\",\n\t                created_at=datetime.now(),\n\t            ),\n", "            EmbeddingModel(\n\t                id=\"id4\",\n\t                collection_id=\"collection1\",\n\t                text=\"some new text\",\n\t                embedding_data=[7.0, 8.0, 9.0],\n\t                meta_data={\"key3\": \"value3\"},\n\t                hash=\"hash4\",\n\t                created_at=datetime.now(),\n\t            ),\n\t        ]\n", "        self.repository._add_rows_one_by_one(duplicate_embeddings)\n\t        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 3)\n\t        self.assertEqual(\n\t            self.session.query(EmbeddingModel).filter_by(id=\"id1\").first().text,\n\t            \"some text\",\n\t        )\n\t        self.assertEqual(\n\t            self.session.query(EmbeddingModel).filter_by(id=\"id2\").first().text,\n\t            \"some other text\",\n\t        )\n", "        self.assertEqual(\n\t            self.session.query(EmbeddingModel).filter_by(id=\"id4\").first().text,\n\t            \"some new text\",\n\t        )\n\t    def test_add_all(self):\n\t        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 0)\n\t        self.repository.add_all(self.embeddings_dict)\n\t        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 2)\n\t        self.assertEqual(\n\t            self.session.query(EmbeddingModel).filter_by(id=\"id1\").first().text,\n", "            \"some text\",\n\t        )\n\t        self.assertEqual(\n\t            self.session.query(EmbeddingModel).filter_by(id=\"id2\").first().text,\n\t            \"some other text\",\n\t        )\n\t    def test_add_all_with_duplicates(self):\n\t        self.repository.add_all(self.embeddings_dict)\n\t        # Test adding duplicate embeddings\n\t        duplicate_embeddings = [\n", "            dict(\n\t                id=\"id3\",\n\t                collection_id=\"collection1\",\n\t                text=\"some text\",\n\t                embedding_data=[1.0, 2.0, 3.0],\n\t                meta_data={\"key1\": \"value1\"},\n\t                hash=\"hash1\",\n\t                created_at=datetime.now(),\n\t            ),\n\t            dict(\n", "                id=\"id4\",\n\t                collection_id=\"collection1\",\n\t                text=\"some new text\",\n\t                embedding_data=[7.0, 8.0, 9.0],\n\t                meta_data={\"key3\": \"value3\"},\n\t                hash=\"hash4\",\n\t                created_at=datetime.now(),\n\t            ),\n\t        ]\n\t        self.repository.add_all(duplicate_embeddings)\n", "        self.assertEqual(len(self.session.query(EmbeddingModel).all()), 3)\n\t        self.assertEqual(\n\t            self.session.query(EmbeddingModel).filter_by(id=\"id1\").first().text,\n\t            \"some text\",\n\t        )\n\t        self.assertEqual(\n\t            self.session.query(EmbeddingModel).filter_by(id=\"id2\").first().text,\n\t            \"some other text\",\n\t        )\n\t        self.assertEqual(\n", "            self.session.query(EmbeddingModel).filter_by(id=\"id4\").first().text,\n\t            \"some new text\",\n\t        )\n\t    def test_get_by_ids(self):\n\t        self.repository.add_all(self.embeddings_dict)\n\t        ids = [\"id1\", \"id2\"]\n\t        rows = self.repository.get_by_ids(ids)\n\t        self.assertEqual(len(rows), 2)\n\t        self.assertEqual(rows[0].get(\"id\"), \"id1\")\n\t        self.assertEqual(rows[0].get(\"collection_id\"), \"collection1\")\n", "        self.assertEqual(rows[0].get(\"text\"), \"some text\")\n\t        self.assertEqual(rows[0].get(\"embedding_data\"), [1.0, 2.0, 3.0])\n\t        self.assertEqual(rows[0].get(\"meta_data\"), {\"key1\": \"value1\"})\n\t        self.assertEqual(rows[0].get(\"hash\"), \"hash1\")\n\t        self.assertIsInstance(rows[0].get(\"created_at\"), str)\n\t        self.assertEqual(rows[1].get(\"id\"), \"id2\")\n\t        self.assertEqual(rows[1].get(\"collection_id\"), \"collection1\")\n\t        self.assertEqual(rows[1].get(\"text\"), \"some other text\")\n\t        self.assertEqual(rows[1].get(\"embedding_data\"), [4.0, 5.0, 6.0])\n\t        self.assertEqual(rows[1].get(\"meta_data\"), {\"key2\": \"value2\"})\n", "        self.assertEqual(rows[1].get(\"hash\"), \"hash2\")\n\t        self.assertIsInstance(rows[1].get(\"created_at\"), str)\n\t    def test_get_by_collection_id(self):\n\t        self.repository.add_all(self.embeddings_dict)\n\t        collection_id = \"collection1\"\n\t        rows = self.repository.get_by_collection_id(collection_id)\n\t        self.assertEqual(len(rows), 2)\n\t        self.assertEqual(rows[0].get(\"id\"), \"id1\")\n\t        self.assertEqual(rows[0].get(\"collection_id\"), \"collection1\")\n\t        self.assertEqual(rows[0].get(\"text\"), \"some text\")\n", "        self.assertEqual(rows[0].get(\"embedding_data\"), [1.0, 2.0, 3.0])\n\t        self.assertEqual(rows[0].get(\"meta_data\"), {\"key1\": \"value1\"})\n\t        self.assertEqual(rows[0].get(\"hash\"), \"hash1\")\n\t        self.assertIsInstance(rows[0].get(\"created_at\"), str)\n\t        self.assertEqual(rows[1].get(\"id\"), \"id2\")\n\t        self.assertEqual(rows[1].get(\"collection_id\"), \"collection1\")\n\t        self.assertEqual(rows[1].get(\"text\"), \"some other text\")\n\t        self.assertEqual(rows[1].get(\"embedding_data\"), [4.0, 5.0, 6.0])\n\t        self.assertEqual(rows[1].get(\"meta_data\"), {\"key2\": \"value2\"})\n\t        self.assertEqual(rows[1].get(\"hash\"), \"hash2\")\n", "        self.assertIsInstance(rows[1].get(\"created_at\"), str)\n"]}
{"filename": "tests/repository/test_collection_repository.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom unittest import TestCase, mock\n\tfrom unittest.mock import Mock, patch, MagicMock\n\tfrom embedin.model.collection_model import CollectionModel\n\tfrom embedin.repository.collection_repository import CollectionRepository\n\tclass TestCollectionRepository(TestCase):\n", "    def setUp(self):\n\t        self.session_mock = Mock()\n\t        self.repo = CollectionRepository(self.session_mock)\n\t    def test_get_by_name(self):\n\t        # Mocking a CollectionModel object\n\t        collection = CollectionModel(id=\"123\", name=\"test_collection\")\n\t        self.session_mock.query.return_value.filter_by.return_value.first.return_value = (\n\t            collection\n\t        )\n\t        # Call the method and assert the result\n", "        result = self.repo.get_by_name(\"test_collection\")\n\t        self.assertEqual(result, collection.to_dict())\n\t        # Verify that the query was executed with the correct arguments\n\t        self.session_mock.query.assert_called_once_with(CollectionModel)\n\t        self.session_mock.query.return_value.filter_by.assert_called_once_with(\n\t            name=\"test_collection\"\n\t        )\n\t        self.session_mock.query.return_value.filter_by.return_value.first.assert_called_once()\n\t    def test_get_by_name_return_empty_dict(self):\n\t        self.session_mock.query.return_value.filter_by.return_value.first.return_value = (\n", "            None\n\t        )\n\t        # Call the method and assert the result\n\t        result = self.repo.get_by_name(\"test_collection\")\n\t        self.assertEqual(result, {})\n\t    def test_create(self):\n\t        # call create method\n\t        name = \"test_collection\"\n\t        # mock the get_by_name method\n\t        with patch.object(self.repo, \"get_by_name\", return_value=None):\n", "            collection = self.repo.create(name)\n\t            self.assertIsInstance(collection, dict)\n\t            self.assertIsNotNone(collection)\n\t            self.assertEqual(collection.get(\"name\"), name)\n\t            self.assertIsInstance(collection.get(\"id\"), str)\n\t    def test_create_raise_exception(self):\n\t        # call create method\n\t        name = \"test_collection\"\n\t        # Mocking a CollectionModel object\n\t        mock_collection = CollectionModel(id=\"123\", name=name)\n", "        with patch.object(self.repo, \"get_by_name\", return_value=mock_collection):\n\t            with self.assertRaises(ValueError):\n\t                self.repo.create(name, get_if_exist=False)\n\t    def test_create_with_commit_error(self):\n\t        # Configure the commit method of the mock session to raise an exception\n\t        self.session_mock.commit.side_effect = Exception(\"Mocked commit error\")\n\t        name = \"test_collection\"\n\t        with patch.object(self.repo, \"get_by_name\", return_value=None):\n\t            collection = self.repo.create(name, get_if_exist=True)\n\t            self.assertIsNone(collection)\n", "            self.session_mock.rollback.assert_called_once_with()\n\t    def test_create_already_exists(self):\n\t        # call create method\n\t        name = \"test_collection\"\n\t        # Mocking a CollectionModel object\n\t        mock_collection = dict(id=\"123\", name=name)\n\t        with patch.object(self.repo, \"get_by_name\", return_value=mock_collection):\n\t            collection = self.repo.create(name)\n\t            self.assertIsInstance(collection, dict)\n\t            self.assertIsNotNone(collection)\n", "            self.assertEqual(collection.get(\"name\"), mock_collection[\"name\"])\n\t            self.assertEqual(collection.get(\"id\"), mock_collection[\"id\"])\n"]}
{"filename": "tests/repository/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n"]}
{"filename": "tests/model/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport datetime\n\timport unittest\n\tfrom unittest.mock import MagicMock\n\tfrom embedin.model import Model\n\tclass ModelTestCase(unittest.TestCase):\n", "    def test_to_dict(self):\n\t        # Create a mock object for the self.__table__ attribute\n\t        mock_table = MagicMock()\n\t        # Mock the columns and their names\n\t        mock_col1 = MagicMock()\n\t        mock_col2 = MagicMock()\n\t        mock_col1.name = \"col1\"\n\t        mock_col2.name = \"col2\"\n\t        mock_table.c = [mock_col1, mock_col2]\n\t        # Create a mock instance of the Model class\n", "        model = Model()\n\t        # Set mock values for the attributes\n\t        model.col1 = \"value1\"\n\t        model.col2 = datetime.datetime(2023, 5, 20)\n\t        # Assign the mock_table directly to the __table__ attribute\n\t        Model.__table__ = mock_table\n\t        # Call the to_dict() method\n\t        result = model.to_dict()\n\t        # Check if the output is as expected\n\t        expected = {\"col1\": \"value1\", \"col2\": \"2023-05-20T00:00:00\"}\n", "        self.assertEqual(result, expected)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/model/test_collection_model.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\tfrom sqlalchemy import create_engine\n\tfrom sqlalchemy.orm import sessionmaker\n\tfrom embedin.model.collection_model import CollectionModel, Base\n\tengine = create_engine(\"sqlite:///:memory:\", echo=True)\n", "Session = sessionmaker(bind=engine)\n\tclass TestCollectionModel(unittest.TestCase):\n\t    def setUp(self):\n\t        Base.metadata.create_all(engine)\n\t        self.session = Session()\n\t    def tearDown(self):\n\t        self.session.rollback()\n\t        self.session.close()\n\t        Base.metadata.drop_all(engine)\n\t    def test_collection_model(self):\n", "        # Create a new collection\n\t        collection = CollectionModel(id=\"1\", name=\"test\")\n\t        self.session.add(collection)\n\t        self.session.commit()\n\t        # Retrieve the collection from the database\n\t        retrieved_collection = (\n\t            self.session.query(CollectionModel).filter_by(id=\"1\").one()\n\t        )\n\t        # Check that the retrieved collection matches the original collection\n\t        self.assertEqual(collection.id, retrieved_collection.id)\n", "        self.assertEqual(collection.name, retrieved_collection.name)\n\t    def test_duplicate_name(self):\n\t        # Create a new collection with a duplicate name\n\t        collection1 = CollectionModel(id=\"1\", name=\"test\")\n\t        collection2 = CollectionModel(id=\"2\", name=\"test\")\n\t        # Add the first collection to the database\n\t        self.session.add(collection1)\n\t        self.session.commit()\n\t        # Try to add the second collection to the database\n\t        with self.assertRaises(Exception):\n", "            self.session.add(collection2)\n\t            self.session.commit()\n\t        # Roll back the session to clear the transaction\n\t        self.session.rollback()\n\t        # Check that the second collection was not added to the database\n\t        self.assertEqual(\n\t            self.session.query(CollectionModel).filter_by(name=\"test\").count(), 1\n\t        )\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/model/test_embedding_model.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\tfrom datetime import datetime\n\tfrom sqlalchemy import create_engine\n\tfrom sqlalchemy.orm import sessionmaker\n\tfrom embedin.model.embedding_model import Base, EmbeddingModel\n", "engine = create_engine(\"sqlite:///:memory:\", echo=True)\n\tSession = sessionmaker(bind=engine)\n\tclass EmbeddingModelTestCase(unittest.TestCase):\n\t    def setUp(self):\n\t        Base.metadata.create_all(engine)\n\t        self.session = Session()\n\t        self.embedding = EmbeddingModel(\n\t            id=\"123\",\n\t            collection_id=\"abc\",\n\t            text=\"sample text\",\n", "            embedding_data={\"sample\": [1, 2, 3]},\n\t            meta_data={\"created_by\": \"user1\"},\n\t            hash=\"1234\",\n\t            created_at=datetime.now(),\n\t        )\n\t        self.session.add(self.embedding)\n\t        self.session.commit()\n\t    def tearDown(self):\n\t        self.session.rollback()\n\t        self.session.close()\n", "        Base.metadata.drop_all(engine)\n\t    def test_embedding_model(self):\n\t        embedding = self.session.query(EmbeddingModel).first()\n\t        self.assertIsNotNone(embedding)\n\t        self.assertEqual(embedding.id, \"123\")\n\t        self.assertEqual(embedding.collection_id, \"abc\")\n\t        self.assertEqual(embedding.text, \"sample text\")\n\t        self.assertEqual(embedding.embedding_data, {\"sample\": [1, 2, 3]})\n\t        self.assertEqual(embedding.meta_data, {\"created_by\": \"user1\"})\n\t        self.assertEqual(embedding.hash, \"1234\")\n", "        self.assertIsInstance(embedding.created_at, datetime)\n\t        # Try to add another embedding model with the same hash (should fail due to unique constraint)\n\t        duplicate_embedding = EmbeddingModel(\n\t            id=\"2\",\n\t            collection_id=\"3\",\n\t            text=\"other text\",\n\t            embedding_data={\"data\": [4, 5, 6]},\n\t            meta_data={\"meta\": \"data\"},\n\t            hash=\"1234\",\n\t            created_at=datetime.now(),\n", "        )\n\t        self.session.add(duplicate_embedding)\n\t        with self.assertRaises(Exception):\n\t            self.session.commit()\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/util/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\timport numpy as np\n\tfrom embedin.util import to_np_array\n\tclass TestToNpArray(unittest.TestCase):\n\t    def test_to_np_array_none_input(self):\n", "        query_embeddings = None\n\t        with self.assertRaises(ValueError):\n\t            to_np_array(query_embeddings)\n\t    def test_to_np_array_empty_list(self):\n\t        query_embeddings = []\n\t        with self.assertRaises(ValueError):\n\t            to_np_array(query_embeddings)\n\t        query_embeddings = [[]]\n\t        with self.assertRaises(ValueError):\n\t            to_np_array(query_embeddings)\n", "        query_embeddings = [[], []]\n\t        with self.assertRaises(ValueError):\n\t            to_np_array(query_embeddings)\n\t    def test_to_np_array_one_dim(self):\n\t        query_embeddings = [1, 2, 3]\n\t        result = to_np_array(query_embeddings)\n\t        assert result.shape == (1, 3)\n\t        assert result.dtype == \"float32\"\n\t    def test_to_np_array_two_dims(self):\n\t        query_embeddings = [[1, 2, 3]]\n", "        result = to_np_array(query_embeddings)\n\t        assert result.shape == (1, 3)\n\t        assert result.dtype == \"float32\"\n\t    def test_to_np_array_two_dims_multiple(self):\n\t        query_embeddings = [[1, 2, 3], [4, 5, 6]]\n\t        result = to_np_array(query_embeddings)\n\t        assert result.shape == (2, 3)\n\t        assert result.dtype == \"float32\"\n\t    def test_to_np_array_already_ndarray(self):\n\t        query_embeddings = np.array([1, 2, 3])\n", "        result = to_np_array(query_embeddings)\n\t        assert result.shape == (1, 3)\n\t        assert result.dtype == \"float32\"\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/client/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\tfrom unittest.mock import MagicMock\n\timport numpy as np\n\tfrom embedin.client import Client\n\tclass TestClient(unittest.TestCase):\n", "    def test_constructor(self):\n\t        np.random.seed(42)\n\t        embeddings = np.random.rand(3, 4).astype(np.float32).tolist()\n\t        texts = [\"hello\", \"test\", \"world\"]\n\t        client = Client(\n\t            collection_name=\"test_collection\", texts=texts, embeddings=embeddings\n\t        )\n\t        self.assertIsNotNone(client.collection_service)\n\t        self.assertIsNotNone(client.embedding_service)\n\t        client = Client(collection_name=\"test_collection\", texts=texts)\n", "        self.assertIsNotNone(client.collection_service)\n\t        self.assertIsNotNone(client.embedding_service)\n\t    def test_create_or_get_collection(self):\n\t        collection_name = \"test_collection\"\n\t        client = Client(collection_name=collection_name)\n\t        collection_id = client.create_or_get_collection(collection_name)\n\t        self.assertIsNotNone(collection_id)\n\t        self.assertEqual(client.collection_id, collection_id)\n\t    def test_create_collection(self):\n\t        # Test that a collection is created with the given name\n", "        collection_name = \"new_collection\"\n\t        client = Client(collection_name=collection_name)\n\t        collection_id = client.create_collection(collection_name)\n\t        self.assertIsNotNone(collection_id)\n\t        self.assertEqual(client.collection_id, collection_id)\n\t    def test_get_collection(self):\n\t        # Test that a collection is retrieved with the given name\n\t        collection_name = \"new_collection\"\n\t        client = Client(collection_name=collection_name)\n\t        client.create_collection(collection_name)\n", "        collection_id = client.get_collection(collection_name)\n\t        self.assertIsNotNone(collection_id)\n\t        self.assertEqual(client.collection_id, collection_id)\n\t    def test_add_data(self):\n\t        collection_name = \"new_collection\"\n\t        client = Client(collection_name=collection_name)\n\t        # Test that data is added to the collection\n\t        texts = [\"text1\", \"text2\"]\n\t        meta_data = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}]\n\t        client.embedding_fn = MagicMock(return_value=[[1, 2, 3], [4, 5, 6]])\n", "        client.add_data(texts, meta_data)\n\t        client.embedding_fn.assert_called_once_with(texts)\n\t        self.assertEqual(len(client.embedding_rows), 2)\n\t    def test_query(self):\n\t        collection_name = \"new_collection\"\n\t        client = Client(collection_name=collection_name)\n\t        # Test that queries return the expected results\n\t        client.embedding_fn = MagicMock(return_value=[[1, 2, 3], [4, 5, 6]])\n\t        client.add_data([\"test\", \"text\"])\n\t        client.embedding_fn = MagicMock(return_value=[[1, 2, 3]])\n", "        result = client.query(\"test\", top_k=1)\n\t        expected_result = [{\"text\": \"test\", \"meta_data\": None}]\n\t        self.assertEqual(result, expected_result)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/service/test_embedding_service.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\tfrom datetime import datetime\n\tfrom unittest.mock import Mock\n\tfrom embedin.model.embedding_model import EmbeddingModel\n\tfrom embedin.repository.collection_repository import CollectionRepository\n", "from embedin.repository.embedding_repository import EmbeddingRepository\n\tfrom embedin.service.embedding_service import EmbeddingService\n\tclass TestEmbeddingService(unittest.TestCase):\n\t    def setUp(self):\n\t        self.session = Mock()\n\t        self.embedding_repo = EmbeddingRepository(self.session)\n\t        self.collection_repo = CollectionRepository(self.session)\n\t        self.service = EmbeddingService(self.session)\n\t    def test_add_all(self):\n\t        # Define mock data\n", "        collection_id = \"test_collection\"\n\t        embeddings = [[1, 2, 3], [4, 5, 6], [1, 2, 3]]\n\t        texts = [\"test_text_1\", \"test_text_2\", \"test_text_1\"]\n\t        metadata_list = [{\"meta1\": \"value1\"}, {\"meta2\": \"value2\"}, {\"meta1\": \"value1\"}]\n\t        expected_rows = [\n\t            dict(\n\t                id=\"test_id_1\",\n\t                collection_id=collection_id,\n\t                text=texts[0],\n\t                embedding_data=[1, 2, 3],\n", "                meta_data=metadata_list[0],\n\t                hash=\"test_hash_1\",\n\t                created_at=datetime.now(),\n\t            ),\n\t            dict(\n\t                id=\"test_id_2\",\n\t                collection_id=collection_id,\n\t                text=texts[1],\n\t                embedding_data=[4, 5, 6],\n\t                meta_data=metadata_list[1],\n", "                hash=\"test_hash_2\",\n\t                created_at=datetime.now(),\n\t            ),\n\t        ]\n\t        # Mock dependency methods\n\t        self.service.embedding_repo.add_all = Mock(return_value=expected_rows)\n\t        # Call the function being tested\n\t        actual_rows = self.service.add_all(\n\t            collection_id, embeddings, texts, metadata_list\n\t        )\n", "        # Check the result\n\t        self.assertEqual(actual_rows, expected_rows)\n\t        self.assertEqual(len(actual_rows), 2)\n\t        self.assertEqual(actual_rows[0].get(\"hash\"), expected_rows[0].get(\"hash\"))\n\t        self.assertEqual(actual_rows[0].get(\"embedding_data\"), embeddings[0])\n\t        self.assertEqual(actual_rows[1].get(\"hash\"), expected_rows[1].get(\"hash\"))\n\t        self.assertEqual(actual_rows[1].get(\"embedding_data\"), embeddings[1])\n\t    def test_get_by_collection_id(self):\n\t        # Define mock data\n\t        collection_id = \"test_collection\"\n", "        embeddings = [[1, 2, 3], [4, 5, 6]]\n\t        expected_rows = [\n\t            dict(\n\t                id=\"test_id_1\",\n\t                collection_id=collection_id,\n\t                text=\"test_text_1\",\n\t                embedding_data=[1, 2, 3],\n\t                meta_data=None,\n\t                hash=\"test_hash_1\",\n\t                created_at=datetime.now(),\n", "            ),\n\t            dict(\n\t                id=\"test_id_2\",\n\t                collection_id=collection_id,\n\t                text=\"test_text_2\",\n\t                embedding_data=[4, 5, 6],\n\t                meta_data=None,\n\t                hash=\"test_hash_2\",\n\t                created_at=datetime.now(),\n\t            ),\n", "        ]\n\t        # Mock dependency methods\n\t        self.service.embedding_repo.get_by_collection_id = Mock(\n\t            return_value=expected_rows\n\t        )\n\t        # Call the function being tested\n\t        actual_rows = self.service.get_by_collection_id(collection_id)\n\t        # Check the result\n\t        self.assertEqual(actual_rows, expected_rows)\n\t        self.assertEqual(len(actual_rows), 2)\n", "        self.assertEqual(actual_rows[0].get(\"hash\"), expected_rows[0].get(\"hash\"))\n\t        self.assertEqual(actual_rows[0].get(\"embedding_data\"), embeddings[0])\n\t        self.assertEqual(actual_rows[1].get(\"hash\"), expected_rows[1].get(\"hash\"))\n\t        self.assertEqual(actual_rows[1].get(\"embedding_data\"), embeddings[1])\n"]}
{"filename": "tests/service/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n"]}
{"filename": "tests/service/test_collection_service.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\tfrom unittest.mock import Mock\n\tfrom embedin.repository.collection_repository import CollectionRepository\n\tfrom embedin.service.collection_service import CollectionService\n\tclass TestCollectionService(unittest.TestCase):\n", "    def setUp(self):\n\t        self.session = Mock()\n\t        self.collection_repo = CollectionRepository(self.session)\n\t        self.service = CollectionService(self.session)\n\t    def test_get_by_name(self):\n\t        # Define mock data\n\t        name = \"test_collection\"\n\t        expected_rows = [{\"name\": name, \"id\": 1}]\n\t        # Mock dependency methods\n\t        self.service.collection_repo.get_by_name = Mock(return_value=expected_rows)\n", "        # Call the function being tested\n\t        actual_rows = self.service.get_by_name(name)\n\t        # Check the result\n\t        self.assertEqual(actual_rows, expected_rows)\n\t        self.service.collection_repo.get_by_name.assert_called_once_with(name)\n\t    def test_create(self):\n\t        # Define mock data\n\t        name = \"test_collection\"\n\t        get_if_exist = True\n\t        # Mock dependency methods\n", "        self.service.collection_repo.create = Mock()\n\t        # Call the function being tested\n\t        self.service.create(name, get_if_exist)\n\t        # Check the result\n\t        self.service.collection_repo.create.assert_called_once_with(name, get_if_exist)\n"]}
{"filename": "tests/embedding/test_openai_embedding.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\tfrom unittest.mock import patch\n\tfrom embedin.embedding.openai_embedding import OpenAIEmbedding\n\tclass TestOpenAIEmbedding(unittest.TestCase):\n\t    def setUp(self):\n", "        self.api_key = \"my_api_key\"\n\t        self.texts = [\"hello\", \"world\"]\n\t        self.model = \"text-davinci-002\"\n\t        self.embedding = OpenAIEmbedding(api_key=self.api_key, model=self.model)\n\t    @patch(\"openai.Embedding.create\")\n\t    def test_call(self, mock_create):\n\t        mock_create.return_value = {\n\t            \"data\": [{\"embedding\": [1.0, 2.0, 3.0]}, {\"embedding\": [4.0, 5.0, 6.0]}]\n\t        }\n\t        result = self.embedding(self.texts)\n", "        self.assertEqual(result, [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n\t        mock_create.assert_called_once_with(model=self.model, input=self.texts)\n\t    def tearDown(self):\n\t        pass\n"]}
{"filename": "tests/embedding/test_embedding_base.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\tfrom embedin.embedding.embedding_base import EmbeddingBase\n\tclass TestEmbedding(unittest.TestCase):\n\t    def test_call_method_not_implemented(self):\n\t        embedding = EmbeddingBase()\n", "        with self.assertRaises(NotImplementedError):\n\t            embedding([\"some\", \"texts\"])\n"]}
{"filename": "tests/embedding/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\tfrom embedin.embedding import Embedding, OpenAIEmbedding, SentenceTransformerEmbedding\n\tclass TestEmbedding(unittest.TestCase):\n\t    def test_create_openai_embedding(self):\n\t        model_type = \"openai\"\n", "        api_key = \"my_secret_api_key\"\n\t        embedding = Embedding.create_embedding(model_type, api_key)\n\t        self.assertIsInstance(embedding, OpenAIEmbedding)\n\t    def test_create_openai_embedding_without_api_key(self):\n\t        model_type = \"openai\"\n\t        api_key = None\n\t        with self.assertRaises(ValueError):\n\t            Embedding.create_embedding(model_type, api_key)\n\t    def test_create_sentence_transformer_embedding(self):\n\t        model_type = \"sentence_transformer\"\n", "        embedding = Embedding.create_embedding(model_type, None)\n\t        self.assertIsInstance(embedding, SentenceTransformerEmbedding)\n\t    def test_create_unsupported_model_type(self):\n\t        model_type = \"unsupported\"\n\t        with self.assertRaises(ValueError):\n\t            Embedding.create_embedding(model_type, None)\n\t    def test_call_method_not_implemented(self):\n\t        embedding = Embedding()\n\t        with self.assertRaises(NotImplementedError):\n\t            embedding(\"some text\")\n", "if __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "tests/embedding/test_sentence_transformer_embedding.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport unittest\n\tfrom embedin.embedding.sentence_transformer import SentenceTransformerEmbedding\n\tclass TestSentenceTransformerEmbedding(unittest.TestCase):\n\t    def test_embedding_single_text(self):\n\t        embedding = SentenceTransformerEmbedding()\n", "        text = \"This is a test sentence.\"\n\t        expected_output = embedding.model.encode([text], convert_to_numpy=True)\n\t        self.assertTrue((embedding(text) == expected_output).all())\n\t    def test_embedding_multiple_texts(self):\n\t        embedding = SentenceTransformerEmbedding()\n\t        texts = [\"This is a test sentence.\", \"This is another test sentence.\"]\n\t        expected_output = embedding.model.encode(texts, convert_to_numpy=True)\n\t        self.assertTrue((embedding(texts) == expected_output).all())\n\t    def test_embedding_empty_text(self):\n\t        embedding = SentenceTransformerEmbedding()\n", "        text = \"\"\n\t        expected_output = embedding.model.encode([text], convert_to_numpy=True)\n\t        self.assertTrue((embedding(text) == expected_output).all())\n\t    def test_embedding_invalid_input(self):\n\t        embedding = SentenceTransformerEmbedding()\n\t        invalid_input = 123\n\t        with self.assertRaises(TypeError):\n\t            embedding(invalid_input)\n\t        invalid_input = [123, \"string\"]\n\t        with self.assertRaises(TypeError):\n", "            embedding(invalid_input)\n\tif __name__ == \"__main__\":\n\t    unittest.main()\n"]}
{"filename": "embedin/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"\n\tembedin - A vector database that empowers AI with persistent memory.\n\t    >>> from embedin import Embedin\n\t    >>> client = Embedin(collection_name=\"test_collection\",\n\t    ...                  texts=[\"This is a test\", \"Hello world!\"])\n", "    >>> result = client.query(\"These are tests\", top_k=1)\n\t    >>> print(result)\n\t:copyright: (C) 2023 EmbedInAI\n\t:license: Apache 2.0, see LICENSE for more details.\n\t\"\"\"\n\tfrom .client import Client as Embedin\n"]}
{"filename": "embedin/index/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom embedin.index.flat_index import FlatIndex\n\tfrom embedin.index.hnsw_index import HNSWIndex\n\tclass Index:\n\t    def __init__(self, embeddings, index_hint=None):\n\t        if index_hint == \"hnsw\":\n", "            self.index = HNSWIndex(embeddings)\n\t        elif index_hint == \"flat\":\n\t            self.index = FlatIndex(embeddings)\n\t        elif len(embeddings) > 10**6:\n\t            self.index = HNSWIndex(embeddings)\n\t        else:\n\t            self.index = FlatIndex(embeddings)\n\t    def search(self, query, top_k=3):\n\t        return self.index.search(query, top_k)\n\t    def update_index(self, embeddings):\n", "        self.index.update_index(embeddings)\n\t        # TODO: switch index when exceeding 10 ** 6\n"]}
{"filename": "embedin/index/index_base.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom abc import ABC, abstractmethod\n\tfrom embedin.util import to_np_array\n\tclass IndexBase(ABC):\n\t    def __init__(self, embeddings):\n\t        \"\"\"\n", "        Args:\n\t            embeddings: A list of embeddings, where each embedding is a list\n\t            or array of floats.\n\t        \"\"\"\n\t        self.embeddings = to_np_array(embeddings)\n\t        self.index = self._build_index()\n\t    @abstractmethod\n\t    def _build_index(self):\n\t        pass\n\t    @abstractmethod\n", "    def _search_index(self, query_embeddings, top_k):\n\t        pass\n\t    @abstractmethod\n\t    def update_index(self, embeddings):\n\t        pass\n\t    def search(self, query_embeddings, top_k=3):\n\t        \"\"\"\n\t        Perform nearest neighbor on a set of embeddings.\n\t        Args:\n\t            query_embeddings (list or array): The query embedding to use for the\n", "            nearest neighbor search.\n\t            top_k (int, optional): The number of nearest neighbors to return.\n\t            Defaults to 3.\n\t        Returns:\n\t           A list of the indices of the nearest neighbors, and a list of their\n\t           corresponding distances.\n\t        \"\"\"\n\t        count = len(self.embeddings)\n\t        top_k = min(top_k, count)\n\t        query_embeddings = to_np_array(query_embeddings)\n", "        indices = self._search_index(query_embeddings, top_k)\n\t        return indices\n\t    def get_embeddings(self):\n\t        return self.embeddings\n"]}
{"filename": "embedin/index/flat_index.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport faiss\n\timport numpy as np\n\tfrom embedin.index.index_base import IndexBase\n\tfrom embedin.util import to_np_array\n\tclass FlatIndex(IndexBase):\n", "    \"\"\"\n\t    This class implements a nearest neighbors search using brute-force cosine similarity metric.\n\t    Inherits from the abstract class 'NearestNeighbors'.\n\t    \"\"\"\n\t    def _build_index(self):\n\t        \"\"\"\n\t        Build an index using the brute-force with the cosine similarity metric and returns it.\n\t        Returns:\n\t        -------\n\t        index: faiss.IndexFlatIP\n", "            The index built using brute-force.\n\t        \"\"\"\n\t        d = self.embeddings.shape[1]  # dimension\n\t        index = faiss.IndexFlatIP(d)\n\t        xb_norm = np.linalg.norm(self.embeddings, axis=1, keepdims=True)\n\t        xb_normalized = self.embeddings / xb_norm\n\t        index.add(xb_normalized)\n\t        return index\n\t    def update_index(self, embeddings):\n\t        \"\"\"\n", "        Updates the index with new embeddings.\n\t        Parameters:\n\t        ----------\n\t        embeddings: A list of embeddings, where each embedding is a list\n\t            or array of floats.\n\t        \"\"\"\n\t        if not embeddings:\n\t            return\n\t        embeddings = to_np_array(embeddings)\n\t        xb_norm = np.linalg.norm(embeddings, axis=1, keepdims=True)\n", "        xb_normalized = embeddings / xb_norm\n\t        self.index.add(xb_normalized)\n\t        self.embeddings = np.concatenate((self.embeddings, embeddings), axis=0)\n\t    def _search_index(self, query_embeddings, top_k):\n\t        \"\"\"\n\t        Searches the index for the top K nearest embeddings to the given query embeddings.\n\t        Parameters:\n\t        ----------\n\t        query_embeddings: numpy array\n\t            Query embeddings to search the nearest neighbors.\n", "        top_k: int\n\t            Number of the top k nearest embeddings to return.\n\t        Returns:\n\t        -------\n\t        indices: numpy array\n\t            Array of indices representing the nearest embeddings to the given query embeddings.\n\t        \"\"\"\n\t        # faiss.normalize_L2(query_embeddings)\n\t        xq_norm = np.linalg.norm(query_embeddings, axis=1, keepdims=True)\n\t        xq_normalized = query_embeddings / xq_norm\n", "        distances, indices = self.index.search(xq_normalized, k=top_k)\n\t        # Remove the singleton dimension\n\t        indices = np.squeeze(indices)\n\t        return indices\n"]}
{"filename": "embedin/index/hnsw_index.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport numpy as np\n\tfrom hnswlib import Index\n\tfrom embedin.index.index_base import IndexBase\n\tfrom embedin.util import to_np_array\n\tclass HNSWIndex(IndexBase):\n", "    \"\"\"\n\t    This class implements a nearest neighbors search with HNSW algorithm using cosine similarity metric.\n\t    Inherits from the abstract class 'NearestNeighbors'.\n\t    \"\"\"\n\t    # TODO: save index to DB; load index from DB\n\t    def _build_index(self):\n\t        \"\"\"\n\t        Build an index using the HNSW algorithm with the cosine similarity metric and returns it.\n\t        Returns:\n\t        -------\n", "        index: Index\n\t            The index built using HNSW algorithm.\n\t        \"\"\"\n\t        # M - vertex nearest neighbors, affect index size linearly\n\t        # ef_construction - depth of search during build\n\t        ef_search = 128  # depth of search during search\n\t        d = self.embeddings.shape[1]  # dimension\n\t        index = Index(\"cosine\", d)\n\t        index.init_index(\n\t            max_elements=self.embeddings.shape[0], ef_construction=64, M=32\n", "        )\n\t        index.add_items(self.embeddings)\n\t        index.set_ef(ef_search)\n\t        return index\n\t    def update_index(self, embeddings):\n\t        \"\"\"\n\t        Updates the index with new embeddings.\n\t        Parameters:\n\t        ----------\n\t        embeddings: numpy array\n", "            Embeddings to be added to the index.\n\t        \"\"\"\n\t        if not embeddings:\n\t            return\n\t        embeddings = to_np_array(embeddings)\n\t        new_index_size = self.index.get_current_count() + embeddings.shape[0]\n\t        self.index.resize_index(new_index_size)\n\t        self.index.add_items(embeddings)\n\t        self.embeddings = np.concatenate((self.embeddings, embeddings), axis=0)\n\t    def _search_index(self, query_embeddings, top_k):\n", "        \"\"\"\n\t        Searches the index for the top K nearest embeddings to the given query embeddings.\n\t        Parameters:\n\t        ----------\n\t        query_embeddings: numpy array\n\t            Query embeddings to search the nearest neighbors.\n\t        top_k: int\n\t            Number of nearest embeddings to return.\n\t        Returns:\n\t        -------\n", "        indices: numpy array\n\t            Array of indices representing the nearest embeddings to the given query embeddings.\n\t        \"\"\"\n\t        indices, distances = self.index.knn_query(query_embeddings, k=top_k)\n\t        return indices\n"]}
{"filename": "embedin/repository/embedding_repository.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport logging\n\tfrom sqlalchemy.exc import IntegrityError\n\tfrom tqdm import tqdm\n\tfrom embedin.model.embedding_model import EmbeddingModel\n\t# Configure the root logger to output to the console\n", "logging.basicConfig(\n\t    format=\"%(asctime)s - %(levelname)s - %(message)s\", level=logging.INFO\n\t)\n\tlogger = logging.getLogger(__name__)\n\tclass EmbeddingRepository:\n\t    \"\"\"\n\t    This class provides methods to interact with embeddings stored in the database.\n\t    Attributes:\n\t        session (sqlalchemy.orm.Session): The database session to use for querying and modifying data.\n\t    Methods:\n", "        create_table(): Creates the EmbeddingModel table in the database.\n\t        add_all(rows): Adds multiple embeddings to the database, returning the successfully inserted rows.\n\t        get_by_ids(ids): Returns the embeddings with the given ids.\n\t        get_by_collection_id(collection_id): Returns all embeddings in the collection with the given id.\n\t    \"\"\"\n\t    def __init__(self, session):\n\t        \"\"\"\n\t        Constructs an EmbeddingRepository object.\n\t        Args:\n\t            session (sqlalchemy.orm.Session): The database session to use for querying and modifying data.\n", "        \"\"\"\n\t        self.session = session\n\t        self.create_table()\n\t    def create_table(self):\n\t        \"\"\"\n\t        Creates the EmbeddingModel table in the database.\n\t        \"\"\"\n\t        EmbeddingModel.metadata.create_all(self.session.bind)\n\t    def _add_rows_one_by_one(self, rows):\n\t        \"\"\"\n", "        Adds multiple embeddings to the database using loop, returning the successfully inserted rows.\n\t        Args:\n\t            rows (List[EmbeddingModel]): A list of EmbeddingModel objects to add to the database.\n\t        Returns:\n\t            List[EmbeddingModel]: A list of successfully inserted EmbeddingModel.\n\t        \"\"\"\n\t        inserted_rows = []\n\t        for row in rows:\n\t            try:\n\t                self.session.merge(row)\n", "                self.session.commit()\n\t                inserted_rows.append(row)\n\t            except (IntegrityError, Exception):\n\t                self.session.rollback()\n\t        return inserted_rows\n\t    def add_all(self, rows):\n\t        \"\"\"\n\t        The method adds multiple embeddings to the database in batches, and in case of exceptions,\n\t        it switches to adding them one by one. It then returns the list of successfully inserted rows.\n\t        Args:\n", "            rows (List[dct]): A list of dict objects to add to the database.\n\t        Returns:\n\t            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n\t        \"\"\"\n\t        rows = [EmbeddingModel(**row) for row in rows]\n\t        inserted_rows = []\n\t        batch_size = 200\n\t        extra_batch = len(rows) % batch_size > 0\n\t        num_batches = len(rows) // batch_size + extra_batch\n\t        with tqdm(total=len(rows), desc=\"Inserting rows to database\") as pbar:\n", "            for batch_index in range(num_batches):\n\t                batch_start = batch_index * batch_size\n\t                batch_end = batch_start + batch_size\n\t                batch = rows[batch_start:batch_end]\n\t                try:\n\t                    self.session.bulk_save_objects(batch)  # TODO using SQL\n\t                    self.session.commit()\n\t                    inserted_rows.extend(batch)\n\t                except (IntegrityError, Exception) as e:\n\t                    self.session.rollback()\n", "                    self.session.expunge_all()\n\t                    inserted_rows.extend(self._add_rows_one_by_one(batch))\n\t                pbar.update(len(batch))\n\t        inserted_rows = [r.to_dict() for r in inserted_rows]\n\t        return inserted_rows\n\t    # This is only needed when bulk add in add_all is implemented\n\t    def get_by_ids(self, ids):\n\t        \"\"\"\n\t        Returns the embeddings with the given ids.\n\t        Args:\n", "            ids (List[str]): A list of embedding ids to retrieve.\n\t        Returns:\n\t            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n\t        \"\"\"\n\t        # Get the successfully inserted data\n\t        rows = (\n\t            self.session.query(EmbeddingModel).filter(EmbeddingModel.id.in_(ids)).all()\n\t        )\n\t        rows = [r.to_dict() for r in rows]\n\t        return rows\n", "    def get_by_collection_id(self, collection_id):\n\t        \"\"\"\n\t        Returns all embeddings in the collection with the given id.\n\t        Args:\n\t            collection_id (str): The id of the collection to retrieve embeddings from.\n\t        Returns:\n\t            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n\t        \"\"\"\n\t        rows = (\n\t            self.session.query(EmbeddingModel)\n", "            .filter(EmbeddingModel.collection_id == collection_id)\n\t            .all()\n\t        )\n\t        rows = [r.to_dict() for r in rows]\n\t        return rows\n"]}
{"filename": "embedin/repository/collection_repository.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport logging\n\timport uuid\n\tfrom sqlalchemy.exc import IntegrityError\n\tfrom embedin.model.collection_model import CollectionModel\n\t# Configure the root logger to output to the console\n", "logging.basicConfig(\n\t    format=\"%(asctime)s - %(levelname)s - %(message)s\", level=logging.INFO\n\t)\n\tlogger = logging.getLogger(__name__)\n\tclass CollectionRepository:\n\t    \"\"\"\n\t    A repository for managing collections in a database.\n\t    Parameters:\n\t    -----------\n\t    session: sqlalchemy.orm.Session\n", "        The database session to use.\n\t    Methods:\n\t    --------\n\t    create_table():\n\t        Creates the table in the database for collections.\n\t    get_by_name(name: str) -> CollectionModel or None:\n\t        Retrieves a collection from the database by name.\n\t    create(name: str, get_if_exist: bool = True) -> CollectionModel:\n\t        Creates a new collection in the database with the given name.\n\t        If the collection already exists and get_if_exist is True, it returns the existing collection.\n", "        If get_if_exist is False, it raises a ValueError.\n\t    \"\"\"\n\t    def __init__(self, session):\n\t        \"\"\"\n\t        Constructs a new CollectionRepository with the given database session.\n\t        \"\"\"\n\t        self.session = session\n\t        self.create_table()\n\t    def create_table(self):\n\t        \"\"\"\n", "        Creates the table in the database for collections.\n\t        \"\"\"\n\t        CollectionModel.metadata.create_all(self.session.bind)\n\t    def get_by_name(self, name):\n\t        \"\"\"\n\t        Retrieves a collection from the database by name.\n\t        Parameters:\n\t        -----------\n\t        name: str\n\t            The name of the collection to retrieve.\n", "        Returns:\n\t        --------\n\t        collection: dict\n\t            The collection with the given name,\n\t        \"\"\"\n\t        collection = self.session.query(CollectionModel).filter_by(name=name).first()\n\t        collection = collection.to_dict() if collection else {}\n\t        return collection\n\t    def create(self, name, get_if_exist=True):\n\t        \"\"\"\n", "        Creates a new collection in the database with the given name.\n\t        Parameters:\n\t        -----------\n\t        name: str\n\t            The name of the collection to create.\n\t        get_if_exist: bool, optional (default=True)\n\t            If the collection already exists and get_if_exist is True, it returns the existing collection.\n\t            If get_if_exist is False, it raises a ValueError.\n\t        Returns:\n\t        --------\n", "        collection: dict\n\t            The newly created collection.\n\t        \"\"\"\n\t        collection = self.get_by_name(name)\n\t        if collection:\n\t            if get_if_exist:\n\t                return collection\n\t            raise ValueError(f\"Collection with name {name} already exists\")\n\t        collection_id = str(uuid.uuid4())\n\t        collection_model = CollectionModel(id=collection_id, name=name)\n", "        try:\n\t            self.session.add(collection_model)\n\t            self.session.commit()\n\t            return collection_model.to_dict()\n\t        except (IntegrityError, Exception) as e:\n\t            self.session.rollback()\n\t            logger.error(f\"creating collection encounter an error: {str(e)}\")\n"]}
{"filename": "embedin/repository/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n"]}
{"filename": "embedin/model/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport datetime\n\tclass Model:\n\t    def to_dict(self):\n\t        out = {}\n\t        for col in self.__table__.c:\n", "            obj = getattr(self, col.name)\n\t            if isinstance(obj, datetime.datetime):\n\t                obj = obj.isoformat()\n\t            out[col.name] = obj\n\t        return out\n"]}
{"filename": "embedin/model/embedding_model.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom sqlalchemy import Column, String, Text, JSON, DateTime\n\tfrom sqlalchemy.ext.declarative import declarative_base\n\tfrom embedin.model import Model\n\tBase = declarative_base()\n\tclass EmbeddingModel(Base, Model):\n", "    __tablename__ = \"embedding\"\n\t    id = Column(String(36), primary_key=True)\n\t    collection_id = Column(String(36))\n\t    text = Column(Text)\n\t    # TODO: Only Postgres supports ARRAY(Float). Using JSON for now\n\t    # https://docs.sqlalchemy.org/en/20/core/type_basics.html#sqlalchemy.types.ARRAY\n\t    embedding_data = Column(JSON)\n\t    meta_data = Column(JSON)\n\t    hash = Column(String(64), unique=True)\n\t    created_at = Column(DateTime)\n"]}
{"filename": "embedin/model/collection_model.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom sqlalchemy import Column, String\n\tfrom sqlalchemy.ext.declarative import declarative_base\n\tfrom embedin.model import Model\n\tBase = declarative_base()\n\tclass CollectionModel(Base, Model):\n", "    __tablename__ = \"collection\"\n\t    id = Column(String(36), primary_key=True)\n\t    name = Column(String(64), unique=True)\n"]}
{"filename": "embedin/util/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport numpy as np\n\tdef to_np_array(embeddings, dtype=\"float32\"):\n\t    \"\"\"\n\t    Convert a list of embeddings to a numpy array.\n\t    Args:\n", "        embeddings (list): A list of embeddings, where each element is a number or\n\t        a list of numbers.\n\t        dtype (string): Data type of the array\n\t    Returns:\n\t        numpy.ndarray: A 2D numpy array of shape (num_examples, embedding_size), where\n\t        `num_examples` is the number of embeddings in the input list and `embedding_size`\n\t        is the length of each individual embedding.\n\t    Raises:\n\t        ValueError: If the input list is empty or contains embeddings of inconsistent length.\n\t    Example:\n", "        >>> embeddings_list = [[1,2,3],[4,5,6]]\n\t        >>> to_np_array(embeddings_list)\n\t        array([[1, 2, 3],\n\t               [4, 5, 6]], dtype=float32)\n\t    \"\"\"\n\t    if embeddings is None:\n\t        raise ValueError(\"Input list cannot be None.\")\n\t    if len(embeddings) == 0:\n\t        raise ValueError(\"Input list cannot contain empty list\")\n\t    embeddings_array = np.array(embeddings, dtype=dtype)\n", "    if embeddings_array.size == 0:\n\t        raise ValueError(\"Input list cannot be empty\")\n\t    # If the array has only one dimension, add an extra dimension\n\t    if len(embeddings_array.shape) == 1:\n\t        embeddings_array = np.expand_dims(embeddings_array, axis=0)\n\t    return embeddings_array\n"]}
{"filename": "embedin/client/__init__.py", "chunked_list": ["import logging\n\tfrom sqlalchemy import create_engine\n\tfrom sqlalchemy.orm import sessionmaker\n\tfrom embedin.embedding import Embedding\n\tfrom embedin.index import Index\n\tfrom embedin.service.collection_service import CollectionService\n\tfrom embedin.service.embedding_service import EmbeddingService\n\t# Configure the root logger to output to the console\n\tlogging.basicConfig(\n\t    format=\"%(asctime)s - %(levelname)s - %(message)s\", level=logging.INFO\n", ")\n\tlogger = logging.getLogger(__name__)\n\tclass Client:\n\t    \"\"\"\n\t    Client class for managing embeddings and performing nearest neighbor search.\n\t    Args:\n\t        collection_name (str): Name of the collection.\n\t        url (str, optional): Database URL. Defaults to None.\n\t        embedding_fn (str or EmbeddingFunction, optional): The embedding function to use. The default is the SentenceTransformer model. Supported options are 'sentence_transformer' and 'openai'. If 'openai' is selected, the 'OPENAI_API_KEY' environment variable must be set to authenticate with the OpenAI API.\n\t        index_hint (str, optional): Similarity search index to use. Supports: 'flat' and 'hnsw'\n", "        debug (bool, optional): Enable debug mode. Defaults to False.\n\t    Attributes:\n\t        collection_id (int): ID of the collection.\n\t        embedding_fn (str or EmbeddingFunction): Embedding function to use. Support 'sentence_transformer' and 'openai'.\n\t        session (Session): SQLAlchemy session.\n\t        collection_service (CollectionService): CollectionService instance.\n\t        embedding_service (EmbeddingService): EmbeddingService instance.\n\t        embedding_rows (List[EmbeddingModel]): List of Embedding instances for the current collection.\n\t    Methods:\n\t        create_or_get_collection(name): Get the ID of an existing collection or create a new one.\n", "        create_collection(name): Create a new collection with the given name.\n\t        get_collection(name): Get the ID of an existing collection with the given name.\n\t        add_data(texts, meta_data=None): Add new data to the collection.\n\t        query(query_texts, top_k=3): Find nearest neighbors for the given query text(s).\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        collection_name,\n\t        url=None,\n\t        embedding_fn=\"sentence_transformer\",\n", "        index_hint=None,\n\t        debug=False,\n\t        **kwargs\n\t    ):\n\t        self.collection_id = None\n\t        if callable(embedding_fn):\n\t            self.embedding_fn = embedding_fn\n\t        else:\n\t            self.embedding_fn = Embedding.create_embedding(embedding_fn)\n\t        if url is None:\n", "            engine = create_engine(\"sqlite:///:memory:\", echo=debug)\n\t        else:\n\t            engine = create_engine(url)\n\t        session = sessionmaker(bind=engine, expire_on_commit=False)\n\t        self.session = session()\n\t        self.collection_service = CollectionService(self.session)\n\t        self.embedding_service = EmbeddingService(self.session)\n\t        embeddings = kwargs.get(\"embeddings\")\n\t        embeddings_meta = kwargs.get(\"meta\")\n\t        texts = kwargs.get(\"texts\")\n", "        self.collection_id = self.create_or_get_collection(collection_name)\n\t        self.embedding_rows = self.embedding_service.get_by_collection_id(\n\t            self.collection_id\n\t        )\n\t        # Insert user-provided texts and embeddings into the database\n\t        inserted_rows = []\n\t        if embeddings is not None and texts is not None:\n\t            # TODO validate embeddings' shape and dtype; validate text as well\n\t            inserted_rows = self.embedding_service.add_all(\n\t                self.collection_id, embeddings, texts, embeddings_meta\n", "            )\n\t        elif texts is not None:\n\t            embeddings = self.embedding_fn(texts)\n\t            inserted_rows = self.embedding_service.add_all(\n\t                self.collection_id, embeddings, texts, embeddings_meta\n\t            )\n\t        self.embedding_rows.extend(inserted_rows)\n\t        total_embeddings = [row.get(\"embedding_data\") for row in self.embedding_rows]\n\t        self.index_hint = index_hint\n\t        self.search_index = None\n", "        if total_embeddings:\n\t            self.search_index = Index(total_embeddings, self.index_hint)\n\t    def create_or_get_collection(self, name):\n\t        \"\"\"\n\t        Get the ID of an existing collection or create a new one with the given name.\n\t        Args:\n\t            name (str): Name of the collection.\n\t        Returns:\n\t            str: ID of the collection.\n\t        \"\"\"\n", "        collection_id = self.get_collection(name)\n\t        if not collection_id:\n\t            collection_id = self.create_collection(name)\n\t        self.collection_id = collection_id\n\t        return collection_id\n\t    def create_collection(self, name):\n\t        \"\"\"\n\t        Create a new collection with the given name.\n\t        Args:\n\t            name (str): Name of the collection.\n", "        Returns:\n\t            str: ID of the new collection.\n\t        \"\"\"\n\t        collection = self.collection_service.create(name)\n\t        self.collection_id = collection.get(\"id\")\n\t        return self.collection_id\n\t    def get_collection(self, name):\n\t        \"\"\"\n\t        Retrieve the ID of an existing collection with the given name.\n\t        Args:\n", "            name (str): Name of the collection.\n\t        Returns:\n\t            str: ID of the collection, or None if no collection with the given name exists.\n\t        \"\"\"\n\t        collection = self.collection_service.get_by_name(name)\n\t        self.collection_id = collection.get(\"id\")\n\t        return self.collection_id\n\t    def add_data(self, texts, meta_data=None):\n\t        \"\"\"\n\t        Add new data to the collection.\n", "        Args:\n\t            texts (list of str): List of text data to add to the collection.\n\t            meta_data (list or None): List of associated metadata for the added text data (optional).\n\t        Returns:\n\t            None.\n\t        \"\"\"\n\t        embeddings = self.embedding_fn(texts)\n\t        logger.info(\"Adding embedding to the database\")\n\t        inserted_data = self.embedding_service.add_all(\n\t            self.collection_id, embeddings, texts, meta_data\n", "        )\n\t        self.embedding_rows.extend(inserted_data)\n\t        inserted_embeddings = [row.get(\"embedding_data\") for row in inserted_data]\n\t        if self.search_index is None:\n\t            self.search_index = Index(embeddings, self.index_hint)\n\t        else:\n\t            self.search_index.update_index(inserted_embeddings)\n\t    def query(self, query_texts, top_k=3):\n\t        \"\"\"\n\t        Search for the most similar text data in the collection to the given query text.\n", "        Args:\n\t            query_texts (list or str): List of query text strings or a single query text string.\n\t            top_k (int): The number of top matches to return (default is 3).\n\t        Returns:\n\t            list of dict: A list of dictionaries containing the most similar text data in the collection to the given query text.\n\t                          Each dictionary has the following format:\n\t                          {'text': str, 'meta_data': object or None}\n\t        \"\"\"\n\t        if isinstance(query_texts, str):\n\t            query_texts = [query_texts]\n", "        query_embeddings = self.embedding_fn(query_texts)\n\t        indices = self.search_index.search(query_embeddings, top_k)\n\t        matched_embeddings = [\n\t            {\"text\": r.get(\"text\"), \"meta_data\": r.get(\"meta_data\")}\n\t            for i, r in enumerate(self.embedding_rows)\n\t            if i in indices\n\t        ]\n\t        return matched_embeddings\n\tif __name__ == \"__main__\":\n\t    url = \"sqlite:///test.db\"\n", "    texts = [\n\t        \"Which fourteen hundred years ago were nail'd\",\n\t        \"Over whose acres walk'd those blessed feet\",\n\t        \"Which fourteen hundred years ago were nail'd\",\n\t        \"For our advantage on the bitter cross.\",\n\t        \"But this our purpose now is twelve month old,\",\n\t        \"And bootless 'tis to tell you we will go:\",\n\t        \"Therefore we meet not now. Then let me hear\",\n\t        \"Of you, my gentle cousin Westmoreland,\",\n\t        \"What yesternight our council did decree\",\n", "        \"In forwarding this dear expedience.\",\n\t        \"My liege, this haste was hot in quest\",\n\t    ]\n\t    client = Client(collection_name=\"test_collection\", texts=texts, url=url)\n\t    client.add_data([\"That is a good day!\"])\n\t    result = client.query(texts[0:10], top_k=2)\n\t    print(result)\n"]}
{"filename": "embedin/service/embedding_service.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport hashlib\n\timport json\n\timport logging\n\timport uuid\n\tfrom datetime import datetime\n", "from embedin.repository.embedding_repository import EmbeddingRepository\n\t# Configure the root logger to output to the console\n\tlogging.basicConfig(\n\t    format=\"%(asctime)s - %(levelname)s - %(message)s\", level=logging.INFO\n\t)\n\tlogger = logging.getLogger(__name__)\n\tclass EmbeddingService:\n\t    \"\"\"\n\t    A service class for handling operations related to embeddings.\n\t    Attributes:\n", "        embedding_repo (EmbeddingRepository): The repository instance for handling database interactions.\n\t    Methods:\n\t        add_all(collection_id, embeddings, texts, metadata_list=None):\n\t            Adds multiple embeddings to the database.\n\t            Args:\n\t                collection_id (str): The ID of the collection that the embeddings belong to.\n\t                embeddings (list): A list of embedding vectors, represented as numpy arrays.\n\t                texts (list): A list of text strings that correspond to the embeddings.\n\t                metadata_list (list, optional): A list of metadata objects, one for each embedding.\n\t            Returns:\n", "                List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n\t        get_by_collection_id(collection_id):\n\t            Fetches all embeddings from the database for a specified collection ID.\n\t            Args:\n\t                collection_id (str): The ID of the collection to retrieve embeddings for.\n\t            Returns:\n\t                List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n\t    \"\"\"\n\t    def __init__(self, session):\n\t        \"\"\"\n", "        Initializes a new instance of the EmbeddingService class.\n\t        Args:\n\t            session (Session): A database session object for making database queries.\n\t        \"\"\"\n\t        self.embedding_repo = EmbeddingRepository(session)\n\t    def add_all(self, collection_id, embeddings, texts, metadata_list=None):\n\t        \"\"\"\n\t        Adds multiple embeddings to the database.\n\t        Args:\n\t            collection_id (str): The ID of the collection that the embeddings belong to.\n", "            embeddings (list): A list of embedding vectors, represented as numpy arrays.\n\t            texts (list): A list of text strings that correspond to the embeddings.\n\t            metadata_list (list, optional): A list of metadata objects, one for each embedding.\n\t        Returns:\n\t            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n\t        \"\"\"\n\t        # Generate a list of Embedding objects\n\t        rows = []\n\t        hash_value_set = set()\n\t        for i, embedding in enumerate(embeddings):\n", "            # Generate a UUID for the embedding\n\t            emb_id = str(uuid.uuid4())\n\t            meta_data = metadata_list[i] if metadata_list else None\n\t            data = texts[i] + collection_id + json.dumps(meta_data)\n\t            hashed = hashlib.sha256(data.encode()).hexdigest()\n\t            if hashed in hash_value_set:\n\t                continue\n\t            hash_value_set.add(hashed)\n\t            # Construct an Embedding object\n\t            row = dict(\n", "                id=emb_id,\n\t                collection_id=collection_id,\n\t                text=texts[i],\n\t                embedding_data=embedding,  # json.dumps(embedding),\n\t                meta_data=meta_data,\n\t                hash=hashed,\n\t                created_at=datetime.now(),\n\t            )\n\t            rows.append(row)\n\t        # Add the Embedding objects to the session and commit the transaction\n", "        inserted_rows = self.embedding_repo.add_all(rows)\n\t        logger.info(f\"{len(inserted_rows)} rows inserted\")\n\t        return inserted_rows\n\t    def get_by_collection_id(self, collection_id):\n\t        \"\"\"\n\t        Fetches all embeddings from the database for a specified collection ID.\n\t        Args:\n\t            collection_id (str): The ID of the collection to retrieve embeddings for.\n\t        Returns:\n\t            List[dict]: A list of dictionaries representing EmbeddingModel objects from the collection with the given id.\n", "        \"\"\"\n\t        # Get the Embedding objects for the specified collection_id\n\t        rows = self.embedding_repo.get_by_collection_id(collection_id)\n\t        return rows\n"]}
{"filename": "embedin/service/collection_service.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom embedin.repository.collection_repository import CollectionRepository\n\tclass CollectionService:\n\t    \"\"\"\n\t    A service class for handling operations related to collections.\n\t    Attributes:\n", "        collection_repo (CollectionRepository): The repository instance for handling database interactions.\n\t    Methods:\n\t        get_by_name(name):\n\t            Fetches a collection from the database by its name.\n\t            Args:\n\t                name (str): The name of the collection to retrieve.\n\t            Returns:\n\t                CollectionModel: A CollectionModel representing the row of the collection fetched from the database.\n\t        create(name, get_if_exist=True):\n\t            Creates a new collection in the database.\n", "            Args:\n\t                name (str): The name of the new collection.\n\t                get_if_exist (bool): If True, return the existing collection if it already exists. If False, create a new collection with the given name.\n\t            Returns:\n\t                CollectionModel: A CollectionModel representing the newly created collection.\n\t    \"\"\"\n\t    def __init__(self, session):\n\t        \"\"\"\n\t        Initializes a new instance of the CollectionService class.\n\t        Args:\n", "            session (Session): A database session object for making database queries.\n\t        \"\"\"\n\t        self.collection_repo = CollectionRepository(session)\n\t    def get_by_name(self, name):\n\t        \"\"\"\n\t        Fetches a collection from the database by its name.\n\t        Args:\n\t            name (str): The name of the collection to retrieve.\n\t        Returns:\n\t            collection: dict\n", "            The collection with the given name\n\t        \"\"\"\n\t        row = self.collection_repo.get_by_name(name)\n\t        return row\n\t    def create(self, name, get_if_exist=True):\n\t        \"\"\"\n\t        Creates a new collection in the database.\n\t        Args:\n\t            name (str): The name of the new collection.\n\t            get_if_exist (bool): If True, return the existing collection if it already exists. If False, create a new collection with the given name.\n", "        Returns:\n\t            CollectionModel: A CollectionModel representing the newly created collection.\n\t        \"\"\"\n\t        collection = self.collection_repo.create(name, get_if_exist)\n\t        return collection\n"]}
{"filename": "embedin/service/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n"]}
{"filename": "embedin/embedding/sentence_transformer.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom sentence_transformers import SentenceTransformer\n\tfrom embedin.embedding.embedding_base import EmbeddingBase\n\tclass SentenceTransformerEmbedding(EmbeddingBase):\n\t    \"\"\"\n\t    A class for generating text embeddings using the SentenceTransformer model.\n", "    Args:\n\t    model_name (str): The name or path of the SentenceTransformer model to be used for generating embeddings. Default is \"all-MiniLM-L6-v2\".\n\t    Methods:\n\t    __call__(texts):\n\t    Generates embeddings for the given input text(s).\n\t    Returns:\n\t    embeddings (list): A list of embeddings generated for the input text(s). Each embedding is a list of float values.\n\t    \"\"\"\n\t    def __init__(self, model=\"all-MiniLM-L6-v2\"):\n\t        \"\"\"\n", "        Initialize a SentenceTransformerEmbedding object.\n\t        Args:\n\t        model_name (str): The name or path of the SentenceTransformer model to be used for generating embeddings. Default is \"all-MiniLM-L6-v2\".\n\t        \"\"\"\n\t        self.model = SentenceTransformer(model)\n\t    def __call__(self, texts):\n\t        \"\"\"\n\t        Generates embeddings for the given input text(s).\n\t        Args:\n\t        texts (str/list): The input text(s) for which embeddings are to be generated. It can be a string or a list of strings.\n", "        Returns:\n\t        embeddings (list): A list of embeddings generated for the input text(s). Each embedding is a list of float values.\n\t        \"\"\"\n\t        # Return it as a numpy array\n\t        # Check if texts is a string\n\t        if isinstance(texts, str):\n\t            return self.model.encode(\n\t                [texts], convert_to_numpy=True, show_progress_bar=True\n\t            ).tolist()\n\t        # Check if texts is a list of strings\n", "        if isinstance(texts, list):\n\t            if all(isinstance(text, str) for text in texts):\n\t                return self.model.encode(\n\t                    texts, convert_to_numpy=True, show_progress_bar=True\n\t                ).tolist()\n\t            raise TypeError(\"Input must be a string, a list of strings\")\n\t        raise TypeError(\"Input must be a string, a list of strings\")\n"]}
{"filename": "embedin/embedding/__init__.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport os\n\tfrom embedin.embedding.openai_embedding import OpenAIEmbedding\n\tfrom embedin.embedding.sentence_transformer import SentenceTransformerEmbedding\n\tclass Embedding:\n\t    \"\"\"\n", "    A class for creating text embeddings using different models.\n\t    Methods:\n\t    create_embedding(model_type, api_key):\n\t    Creates an instance of an embedding model based on the specified type and API key.\n\t    __call__(texts):\n\t    Raises a NotImplementedError. Subclasses must implement __call__() method.\n\t    \"\"\"\n\t    @staticmethod\n\t    def create_embedding(model_type, api_key=os.getenv(\"OPENAI_API_KEY\")):\n\t        \"\"\"\n", "        Creates an instance of an embedding model based on the specified type and API key.\n\t        Args:\n\t        model_type (str): The type of embedding model to create. Currently supported models are \"openai\" and \"sentence_transformer\".\n\t        api_key (str): The API key required to use the OpenAI embedding model.\n\t        Returns:\n\t        An instance of the specified embedding model.\n\t        \"\"\"\n\t        if model_type == \"openai\":\n\t            if api_key is None:\n\t                raise ValueError(\n", "                    \"Please set OPENAI_API_KEY environment variable. Windows: set OPENAI_API_KEY=your_api_key macOS/Linux: export OPENAI_API_KEY=your_api_key\"\n\t                )\n\t            return OpenAIEmbedding(api_key=api_key)\n\t        elif model_type == \"sentence_transformer\":\n\t            return SentenceTransformerEmbedding()\n\t        raise ValueError(\"Unsupported model type: {}\".format(model_type))\n\t    def __call__(self, texts):\n\t        \"\"\"\n\t        Raises a NotImplementedError. Subclasses must implement __call__() method.\n\t        Args:\n", "        texts: The input text(s) for which embeddings are to be generated.\n\t        Raises:\n\t        NotImplementedError: This method is not implemented in the parent Embedding class.\n\t        \"\"\"\n\t        raise NotImplementedError(\"Subclasses must implement __call__() method.\")\n"]}
{"filename": "embedin/embedding/embedding_base.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tclass EmbeddingBase:\n\t    def __call__(self, texts):\n\t        raise NotImplementedError(\"Subclasses must implement __call__() method.\")\n"]}
{"filename": "embedin/embedding/openai_embedding.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t# embedin - A vector database that empowers AI with persistent memory,\n\t# (C) 2023 EmbedInAI\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport openai\n\tfrom embedin.embedding.embedding_base import EmbeddingBase\n\tclass OpenAIEmbedding(EmbeddingBase):\n\t    \"\"\"\n\t    A class for generating text embeddings using the OpenAI API.\n", "    Args:\n\t    api_key (str): The API key for authenticating with the OpenAI API.\n\t    model (str, optional): The name or ID of the OpenAI model to use for generating embeddings. Default is \"text-embedding-ada-002\".\n\t    Methods:\n\t    __call__(texts):\n\t    Generates embeddings for the given input text(s).\n\t    Returns:\n\t    embeddings (list): A list of embeddings generated for the input text(s). Each embedding is a list of float values.\n\t    \"\"\"\n\t    def __init__(self, api_key, model=\"text-embedding-ada-002\"):\n", "        \"\"\"\n\t        Initialize an OpenAIEmbedding object.\n\t        Args:\n\t        api_key (str): The API key for authenticating with the OpenAI API.\n\t        model (str, optional): The name or ID of the OpenAI model to use for generating embeddings. Default is \"text-embedding-ada-002\".\n\t        \"\"\"\n\t        openai.api_key = api_key\n\t        self.model = model\n\t    def __call__(self, texts):\n\t        \"\"\"\n", "        Generates embeddings for the given input text(s) using the OpenAI API.\n\t        Args:\n\t        texts (str/list): The input text(s) for which embeddings are to be generated. It can be a string or a list of strings.\n\t        Returns:\n\t        embeddings (list): A list of embeddings generated for the input text(s). Each embedding is a list of float values.\n\t        \"\"\"\n\t        embeddings = openai.Embedding.create(model=self.model, input=texts)\n\t        embeddings = [data[\"embedding\"] for data in embeddings[\"data\"]]\n\t        return embeddings\n"]}
