{"filename": "platform/mkrules/files/scripts/vppcfg_load.py", "chunked_list": ["#!/usr/bin/python3\n\t# -*- coding: utf-8 -*-\n\t# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport json\n\timport sys\n\timport os\n\timport tempfile\n\tdef load_config():\n\t    cfg = {}\n", "    vpp = {}\n\t    conf_db_set = os.getenv('VPP_CONF_DB', '')\n\t    if not conf_db_set or conf_db_set != 'y':\n\t        sys.exit(0)\n\t    portlist = os.getenv('VPP_DPDK_PORTS', '')\n\t    vports = {}\n\t    dpdk_ports = {}\n\t    index=0\n\t    for port in portlist.split(','):\n\t        rc = os.system('ip link show type veth dev {}'.format(port))\n", "        if rc == 0:\n\t            vports[port] = ''\n\t        else:\n\t            dpdk_ports[port] = {'name': 'bobm{}'.format(index)}\n\t            index += 1\n\t    if len(vports):\n\t        vpp['vports'] = vports\n\t    if len(dpdk_ports):\n\t        dpdk = { 'dev': dpdk_ports }\n\t        vpp['dpdk'] = dpdk\n", "    cfg['PLATFORM'] = { 'vpp': vpp }\n\t    print(cfg)\n\t    fd, tmpfile = tempfile.mkstemp(prefix='vppcfg')\n\t    with open(tmpfile, 'w') as fp:\n\t        json.dump(cfg, fp, indent=4)\n\t    rc = os.system('cat {}'.format(tmpfile))\n\t    rc += os.system('config load -y {}'.format(tmpfile))\n\t    os.close(fd)\n\t    os.unlink(tmpfile)\n\t    return rc\n", "if __name__ == '__main__':\n\t   sys.exit(load_config())\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/setup.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport setuptools\n\tsetuptools.setup(\n\t    name = 'sonic-vppcfgd',\n\t    version = '1.0',\n\t    description = 'Utility to configure vpp startup config based on vpp cfg in config_db',\n\t    author = 'Shashidhar Patil',\n\t    author_email = 'shaship@cisco.com',\n\t    url = 'https://github.com/sonic-net/sonic-platform-vpp',\n", "    packages = setuptools.find_packages(),\n\t    entry_points = {\n\t        'console_scripts': [\n\t            'vppcfgd = vppcfgd.main:main',\n\t        ]\n\t    },\n\t    install_requires = [\n\t        'jinja2>=2.10',\n\t        'pyyaml==5.4.1',\n\t    ],\n", "    setup_requires = [\n\t        'pytest-runner',\n\t        'wheel'\n\t    ],\n\t    tests_require = [\n\t        'pytest',\n\t        'pytest-cov',\n\t        'sonic-config-engine'\n\t    ]\n\t)\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/vars.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n\t# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tg_debug = True  # FIXME: read from env variable, or from constants\n\tg_dev_debug = True\n\tINDENT='    '\n\tVPP_CONFIG_JSON_PATH='/etc/sonic/vpp/startup.json'\n\tVPP_CFG_STARTUP_PATH='/etc/sonic/vpp/startup.conf'\n\tVPP_BOOTUP_CFG_PATH='/etc/sonic/vpp/bootup.conf'\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/manager.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n\t# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom swsscommon import swsscommon\n\tfrom .log import log_debug, log_err\n\tclass Manager(object):\n\t    \"\"\" This class represents a SONiC DB table \"\"\"\n\t    def __init__(self, common_objs, deps, database, table_name):\n\t        \"\"\"\n\t        Initialize class\n", "        :param common_objs: common object dictionary\n\t        :param deps: dependencies list\n\t        :param database: database name\n\t        :param table_name: table name\n\t        \"\"\"\n\t        self.directory = common_objs['directory']\n\t        self.cfg_mgr = common_objs['cfg_mgr']\n\t        self.constants = common_objs['constants']\n\t        self.deps = deps\n\t        self.db_name = database\n", "        self.table_name = table_name\n\t        self.set_queue = []\n\t        self.directory.subscribe(deps, self.on_deps_change)  # subscribe this class method on directory changes\n\t    def get_database(self):\n\t        \"\"\" Return associated database \"\"\"\n\t        return self.db_name\n\t    def get_table_name(self):\n\t        \"\"\" Return associated table name\"\"\"\n\t        return self.table_name\n\t    def handler(self, key, op, data):\n", "        \"\"\"\n\t        This method is executed on each add/remove event on the table.\n\t        :param key: key of the table entry\n\t        :param op: operation on the table entry. Could be either 'SET' or 'DEL'\n\t        :param data: associated data of the event. Empty for 'DEL' operation.\n\t        \"\"\"\n\t        if op == swsscommon.SET_COMMAND:\n\t            if self.directory.available_deps(self.deps):  # all required dependencies are set in the Directory?\n\t                res = self.set_handler(key, data)\n\t                if not res:  # set handler returned False, which means it is not ready to process is. Save it for later.\n", "                    log_debug(\"'SET' handler returned NOT_READY for the Manager: %s\" % self.__class__)\n\t                    self.set_queue.append((key, data))\n\t            else:\n\t                log_debug(\"Not all dependencies are met for the Manager: %s\" % self.__class__)\n\t                self.set_queue.append((key, data))\n\t        elif op == swsscommon.DEL_COMMAND:\n\t            self.del_handler(key)\n\t        else:\n\t            log_err(\"Invalid operation '%s' for key '%s'\" % (op, key))\n\t    def on_deps_change(self):\n", "        \"\"\" This method is being executed on every dependency change \"\"\"\n\t        if not self.directory.available_deps(self.deps):\n\t            return\n\t        new_queue = []\n\t        for key, data in self.set_queue:\n\t            res = self.set_handler(key, data)\n\t            if not res:\n\t                new_queue.append((key, data))\n\t        self.set_queue = new_queue\n\t    def set_handler(self, key, data):\n", "        \"\"\" Placeholder for 'SET' command \"\"\"\n\t        log_err(\"set_handler() wasn't implemented for %s\" % self.__class__.__name__)\n\t    def del_handler(self, key):\n\t        \"\"\" Placeholder for 'DEL' command \"\"\"\n\t        log_err(\"del_handler wasn't implemented for %s\" % self.__class__.__name__)\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/main.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport os\n\timport signal\n\timport sys\n\timport syslog\n\timport threading\n\timport traceback\n\tfrom swsscommon import swsscommon\n\tfrom .config import ConfigMgr\n", "from .directory import Directory\n\tfrom .log import log_notice, log_crit\n\tfrom .vpp import VppMgr\n\tfrom .managers_vppcfg import VppCfgMgr\n\tfrom .runner import Runner, signal_handler\n\tfrom .template import TemplateFabric\n\tfrom .utils import read_constants\n\tfrom .vars import g_debug\n\tVPP_TEMPLATE=\"/etc/sonic/vpp/vpp_template.json\"\n\tdef do_work():\n", "    \"\"\" Main function \"\"\"\n\t    vpp = VppMgr(VPP_TEMPLATE)\n\t    common_objs = {\n\t        'directory': Directory(),\n\t        'cfg_mgr':   ConfigMgr(vpp),\n\t        'tf':        TemplateFabric(),\n\t        'constants': read_constants(),\n\t    }\n\t    managers = [\n\t        VppCfgMgr(common_objs, \"CONFIG_DB\", \"PLATFORM\"),\n", "        VppCfgMgr(common_objs, \"STATE_DB\", \"PLATFORM\"),\n\t    ]\n\t    runner = Runner(common_objs['cfg_mgr'])\n\t    for mgr in managers:\n\t        runner.add_manager(mgr)\n\t    runner.run()\n\tdef main():\n\t    rc = 0\n\t    try:\n\t        syslog.openlog('vppcfgd')\n", "        signal.signal(signal.SIGTERM, signal_handler)\n\t        signal.signal(signal.SIGINT, signal_handler)\n\t        do_work()\n\t    except KeyboardInterrupt:\n\t        log_notice(\"Keyboard interrupt\")\n\t    except RuntimeError as exc:\n\t        log_crit(str(exc))\n\t        rc = -2\n\t        if g_debug:\n\t            raise\n", "    except Exception as exc:\n\t        log_crit(\"Got an exception %s: Traceback: %s\" % (str(exc), traceback.format_exc()))\n\t        rc = -1\n\t        if g_debug:\n\t            raise\n\t    finally:\n\t        syslog.closelog()\n\t    try:\n\t        sys.exit(rc)\n\t    except SystemExit:\n", "        os._exit(rc)\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/__main__.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom .main import main\n\tif __name__ == '__main__':\n\t    main()\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/managers_vppcfg.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport traceback\n\tfrom .log import log_crit, log_err, log_debug, log_notice, dev_debug, g_dev_debug\n\tfrom .manager import Manager\n\tfrom .template import TemplateFabric\n\timport socket\n\timport json\n\tfrom .utils import print_dict\n\tclass VppCfgMgr(Manager):\n", "    \"\"\" This class updates vpp startup.conf when PLATFORM|vpp table entry is updated \"\"\"\n\t    def __init__(self, common_objs, db, table):\n\t        \"\"\"\n\t        Initialize the object\n\t        :param common_objs: common object dictionary\n\t        :param db: name of the db\n\t        :param table: name of the table in the db\n\t        \"\"\"\n\t        super(VppCfgMgr, self).__init__(\n\t            common_objs,\n", "            [],\n\t            db,\n\t            table,\n\t        )\n\t    def set_handler(self, key, data):\n\t        if key != \"vpp\":\n\t            return True\n\t        dev_debug(\"Key %s data %s\" % (key, data))\n\t        self.handle_config_data(data)\n\t        return True\n", "    def del_handler(self, key):\n\t        pass\n\t    @staticmethod\n\t    def split_key(key):\n\t        \"\"\"\n\t        :param key: key to split\n\t        :return:  table, key\n\t        \"\"\"\n\t        if '|' in key:\n\t            return tuple(key.split('|', 1))\n", "        else:\n\t            return None, key\n\t    def handle_config_data(self, data):\n\t        print_dict(data)\n\t        self.vpp_cfg = {}\n\t        for key, val in data.items():\n\t            val = val.replace(\"'\", \"\\\"\")\n\t            self.vpp_cfg[key] = json.loads(val)\n\t        self.cfg_mgr.update(self.vpp_cfg)\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/log.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n\t# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport syslog\n\tfrom .vars import g_debug, g_dev_debug\n\tdef log_debug(msg):\n\t    \"\"\" Send a message msg to the syslog as DEBUG \"\"\"\n\t    dev_debug(msg)\n\t    if g_debug:\n\t        syslog.syslog(syslog.LOG_DEBUG, msg)\n", "def log_notice(msg):\n\t    \"\"\" Send a message msg to the syslog as NOTICE \"\"\"\n\t    dev_debug(msg)\n\t    syslog.syslog(syslog.LOG_NOTICE, msg)\n\tdef log_info(msg):\n\t    \"\"\" Send a message msg to the syslog as INFO \"\"\"\n\t    dev_debug(msg)\n\t    syslog.syslog(syslog.LOG_INFO, msg)\n\tdef log_warn(msg):\n\t    \"\"\" Send a message msg to the syslog as WARNING \"\"\"\n", "    dev_debug(msg)\n\t    syslog.syslog(syslog.LOG_WARNING, msg)\n\tdef log_err(msg):\n\t    \"\"\" Send a message msg to the syslog as ERR \"\"\"\n\t    dev_debug(msg)\n\t    syslog.syslog(syslog.LOG_ERR, msg)\n\tdef log_crit(msg):\n\t    \"\"\" Send a message msg to the syslog as CRIT \"\"\"\n\t    dev_debug(msg)\n\t    syslog.syslog(syslog.LOG_CRIT, msg)\n", "def dev_debug(msg):\n\t    if g_dev_debug:\n\t        print(msg)\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/runner.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n\t# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom collections import defaultdict\n\tfrom swsscommon import swsscommon\n\tfrom .log import log_debug, log_crit\n\tg_run = True\n\tdef signal_handler(_, __):  # signal_handler(signum, frame)\n\t    \"\"\" signal handler \"\"\"\n\t    global g_run\n", "    g_run = False\n\tclass Runner(object):\n\t    \"\"\" Implements main io-loop of the application\n\t        It will run event handlers inside of Manager objects\n\t        when corresponding db/table is updated\n\t    \"\"\"\n\t    SELECT_TIMEOUT = 1000\n\t    def __init__(self, cfg_manager):\n\t        \"\"\" Constructor \"\"\"\n\t        self.cfg_manager = cfg_manager\n", "        self.db_connectors = {}\n\t        self.selector = swsscommon.Select()\n\t        self.callbacks = defaultdict(lambda: defaultdict(list))  # db -> table -> handlers[]\n\t        self.subscribers = set()\n\t    def add_manager(self, manager):\n\t        \"\"\"\n\t        Add a manager to the Runner.\n\t        As soon as new events will be receiving by Runner,\n\t        handlers of corresponding objects will be executed\n\t        :param manager: an object implementing Manager\n", "        \"\"\"\n\t        db_name = manager.get_database()\n\t        table_name = manager.get_table_name()\n\t        db = swsscommon.SonicDBConfig.getDbId(db_name)\n\t        if db not in self.db_connectors:\n\t            self.db_connectors[db] = swsscommon.DBConnector(db_name, 0)\n\t        if table_name not in self.callbacks[db]:\n\t            conn = self.db_connectors[db]\n\t            subscriber = swsscommon.SubscriberStateTable(conn, table_name)\n\t            self.subscribers.add(subscriber)\n", "            self.selector.addSelectable(subscriber)\n\t        self.callbacks[db][table_name].append(manager.handler)\n\t    def run(self):\n\t        \"\"\" Main loop \"\"\"\n\t        while g_run:\n\t            state, _ = self.selector.select(Runner.SELECT_TIMEOUT)\n\t            if state == self.selector.TIMEOUT:\n\t                continue\n\t            elif state == self.selector.ERROR:\n\t                raise Exception(\"Received error from select\")\n", "            for subscriber in self.subscribers:\n\t                while True:\n\t                    key, op, fvs = subscriber.pop()\n\t                    if not key:\n\t                        break\n\t                    log_debug(\"Received message : '%s'\" % str((key, op, fvs)))\n\t                    for callback in self.callbacks[subscriber.getDbConnector().getDbId()][subscriber.getTableName()]:\n\t                        callback(key, op, dict(fvs))\n\t            rc = self.cfg_manager.commit()\n\t            if not rc:\n", "                log_crit(\"Runner::commit was unsuccessful\")\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/config.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport json\n\tfrom .vars import g_dev_debug, VPP_CONFIG_JSON_PATH, VPP_CFG_STARTUP_PATH, VPP_BOOTUP_CFG_PATH, INDENT\n\tfrom .log import dev_debug, log_notice\n\tfrom .utils import print_dict\n\timport os\n\tclass ConfigMgr(object):\n\t    \"\"\" The class represents vpp configuration \"\"\"\n\t    def __init__(self, vpp):\n", "        self.vpp = vpp\n\t        self.vpp_json_cfg = None\n\t        self.vpp_startup_conf = ''\n\t        self.vpp_vports_conf = ''\n\t    def reset(self):\n\t        \"\"\" Reset stored config \"\"\"\n\t        self.vpp_json_cfg = None\n\t        self.vpp_startup_conf = ''\n\t        self.vpp_vports_conf = ''\n\t    def deep_update(self, input, output):\n", "        for key, val in input.items():\n\t            dev_debug(\"key {} : val {}\".format(key, val))\n\t            if key in output:\n\t                out_val = output[key]\n\t                if type(val) == dict:\n\t                    self.deep_update(val, out_val)\n\t                else:\n\t                    output[key] = val\n\t            else:\n\t                output[key] = val\n", "    def update(self, sonic_vpp_cfg):\n\t        \"\"\" Read current config from VPP \"\"\"\n\t        self.vpp_json_cfg = self.vpp.get_config()\n\t        self.deep_update(sonic_vpp_cfg, self.vpp_json_cfg)\n\t        print_dict(self.vpp_json_cfg)\n\t    def render_vpp_config(self):\n\t        indoff=''\n\t        self.vpp_startup_conf=''\n\t        self.gen_vpp_conf(self.vpp_json_cfg, indoff)\n\t    def gen_vpp_conf(self, cfg, indoff):\n", "        for key, val in cfg.items():\n\t            if type(val) == dict:\n\t                if key == 'vports':\n\t                    continue\n\t                if key == 'dev':\n\t                    self.gen_dpdk_dev_cfg(val, indoff)\n\t                elif key == 'plugin':\n\t                    self.gen_plugins_cfg(val, indoff)\n\t                else:\n\t                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+key+' '+'{'+'\\n'\n", "                    self.gen_vpp_conf(val, indoff+INDENT)\n\t                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+'}'+'\\n'\n\t            else:\n\t                if val:\n\t                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+key+' '+val+'\\n'\n\t                else:\n\t                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+key+'\\n'\n\t    def gen_dpdk_dev_cfg(self, cfg, indoff):\n\t        for key, val in cfg.items():\n\t            if type(val) == dict:\n", "                self.vpp_startup_conf = self.vpp_startup_conf+indoff+'dev '+key+' '+'{'+'\\n'\n\t                self.gen_dpdk_dev_cfg(val, indoff+INDENT)\n\t                self.vpp_startup_conf = self.vpp_startup_conf+indoff+'}'+'\\n'\n\t            else:\n\t                if val:\n\t                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+key+' '+val+'\\n'\n\t                else:\n\t                    self.vpp_startup_conf = self.vpp_startup_conf+indoff+key+'\\n'\n\t    def gen_plugins_cfg(self, cfg, indoff):\n\t        for key, val in cfg.items():\n", "            self.vpp_startup_conf = self.vpp_startup_conf+indoff+'plugin '+key+' '+'{ '+val+' }'+'\\n'\n\t    def commit(self):\n\t        \"\"\"\n\t        Write configuration change to VPP.\n\t        :return: True if change was applied successfully, False otherwise\n\t        \"\"\"\n\t        self.vpp_vports_config()\n\t        self.vpp_dpdk_config()\n\t        self.vpp_env_config()\n\t        self.render_vpp_config()\n", "        with open(VPP_CONFIG_JSON_PATH, \"w\") as fp:\n\t            json.dump(self.vpp_json_cfg, fp, indent=4)\n\t        dev_debug(\"bootup ports config {}\".format(self.vpp_vports_conf))\n\t        with open(VPP_BOOTUP_CFG_PATH, \"w\") as fp:\n\t            fp.write(self.vpp_vports_conf)\n\t        dev_debug(\"startup {}\".format(self.vpp_startup_conf))\n\t        with open(VPP_CFG_STARTUP_PATH, \"w\") as fp:\n\t            fp.write(self.vpp_startup_conf)\n\t        self.reset()\n\t        log_notice(\"Config changes committed.\");\n", "        return True\n\t    def vpp_vports_config(self):\n\t        if 'vports' in self.vpp_json_cfg:\n\t            for key, val in self.vpp_json_cfg['vports'].items():\n\t                self.vpp_vports_conf = self.vpp_vports_conf + 'create host-interface name {}\\n'.format(key)\n\t    def vpp_dpdk_config(self):\n\t        disable_dpdk = True\n\t        if 'dpdk' in self.vpp_json_cfg and 'dev' in self.vpp_json_cfg['dpdk']:\n\t            for key, val in self.vpp_json_cfg['dpdk']['dev'].items():\n\t                if key != 'default':\n", "                    disable_dpdk = False\n\t        if disable_dpdk:\n\t            self.disable_dpdk_cfg()\n\t    def vpp_env_config(self):\n\t        disable_dpdk = os.getenv('DPDK_DISABLE', 'n')\n\t        if disable_dpdk == 'y':\n\t            self.disable_dpdk_cfg()\n\t        no_linux_nl = os.getenv('NO_LINUX_NL', 'n')\n\t        if no_linux_nl == 'y':\n\t            self.vpp_json_cfg['plugins']['plugin']['linux_nl_plugin.so'] = 'disable'\n", "    def disable_dpdk_cfg(self):\n\t        self.vpp_json_cfg['plugins']['plugin']['dpdk_plugin.so'] = 'disable'\n\t        self.vpp_json_cfg.pop('dpdk', None)\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/vpp.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport json\n\tclass VppMgr(object):\n\t    \"\"\" The class represents vpp  configuration template in json\"\"\"\n\t    def __init__(self, template):\n\t        self.vpp_config = {}\n\t        with open(template, \"r\") as flp:\n\t            self.vpp_config = json.load(flp)\n\t            print(\"Template {}\".format(self.vpp_config))\n", "    def get_config(self):\n\t        return self.vpp_config\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/template.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n\t# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom collections import OrderedDict\n\tfrom functools import partial\n\timport jinja2\n\timport netaddr\n\tfrom .log import log_err\n\tclass TemplateFabric(object):\n\t    \"\"\" Fabric for rendering jinja2 templates \"\"\"\n", "    def __init__(self, template_path = '/usr/share/sonic/templates'):\n\t        j2_template_paths = [template_path]\n\t        j2_loader = jinja2.FileSystemLoader(j2_template_paths)\n\t        j2_env = jinja2.Environment(loader=j2_loader, trim_blocks=False)\n\t        j2_env.filters['ipv4'] = self.is_ipv4\n\t        j2_env.filters['ipv6'] = self.is_ipv6\n\t        j2_env.filters['pfx_filter'] = self.pfx_filter\n\t        for attr in ['ip', 'network', 'prefixlen', 'netmask']:\n\t            j2_env.filters[attr] = partial(self.prefix_attr, attr)\n\t        self.env = j2_env\n", "    def from_file(self, filename):\n\t        \"\"\"\n\t        Read a template from a file\n\t        :param filename: filename of the file. Type String\n\t        :return: Jinja2 template object\n\t        \"\"\"\n\t        return self.env.get_template(filename)\n\t    def from_string(self, tmpl):\n\t        \"\"\"\n\t        Read a template from a string\n", "        :param tmpl: Text representation of Jinja2 template\n\t        :return: Jinja2 template object\n\t        \"\"\"\n\t        return self.env.from_string(tmpl)\n\t    @staticmethod\n\t    def is_ipv4(value):\n\t        \"\"\" Return True if the value is an ipv4 address \"\"\"\n\t        if not value:\n\t            return False\n\t        if isinstance(value, netaddr.IPNetwork):\n", "            addr = value\n\t        else:\n\t            try:\n\t                addr = netaddr.IPNetwork(str(value))\n\t            except (netaddr.NotRegisteredError, netaddr.AddrFormatError, netaddr.AddrConversionError):\n\t                return False\n\t        return addr.version == 4\n\t    @staticmethod\n\t    def is_ipv6(value):\n\t        \"\"\" Return True if the value is an ipv6 address \"\"\"\n", "        if not value:\n\t            return False\n\t        if isinstance(value, netaddr.IPNetwork):\n\t            addr = value\n\t        else:\n\t            try:\n\t                addr = netaddr.IPNetwork(str(value))\n\t            except (netaddr.NotRegisteredError, netaddr.AddrFormatError, netaddr.AddrConversionError):\n\t                return False\n\t        return addr.version == 6\n", "    @staticmethod\n\t    def prefix_attr(attr, value):\n\t        \"\"\"\n\t        Extract attribute from IPNetwork object\n\t        :param attr: attribute to extract\n\t        :param value: the string representation of ip prefix which will be converted to IPNetwork.\n\t        :return: the value of the extracted attribute\n\t        \"\"\"\n\t        if not value:\n\t            return None\n", "        else:\n\t            try:\n\t                prefix = netaddr.IPNetwork(str(value).strip())\n\t            except (netaddr.NotRegisteredError, netaddr.AddrFormatError, netaddr.AddrConversionError):\n\t                return None\n\t        return str(getattr(prefix, attr))\n\t    @staticmethod\n\t    def pfx_filter(value):\n\t        \"\"\"INTERFACE Table can have keys in one of the two formats:\n\t           string or tuple - This filter skips the string keys and only\n", "           take into account the tuple.\n\t           For eg - VLAN_INTERFACE|Vlan1000 vs VLAN_INTERFACE|Vlan1000|192.168.0.1/21\n\t        \"\"\"\n\t        table = OrderedDict()\n\t        if not value:\n\t            return table\n\t        for key, val in value.items():\n\t            if not isinstance(key, tuple):\n\t                continue\n\t            intf, ip_address = key\n", "            if '/' not in ip_address:\n\t                if TemplateFabric.is_ipv4(ip_address):\n\t                    table[(intf, \"%s/32\" % ip_address)] = val\n\t                elif TemplateFabric.is_ipv6(ip_address):\n\t                    table[(intf, \"%s/128\" % ip_address)] = val\n\t                else:\n\t                    log_err(\"'%s' is invalid ip address\" % ip_address)\n\t            else:\n\t                table[key] = val\n\t        return table\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/__init__.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/utils.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n\t# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport subprocess\n\timport yaml\n\tfrom .log import log_crit, log_debug, log_err\n\tfrom .vars import g_dev_debug\n\tdef run_command(command, shell=False, hide_errors=False):\n\t    \"\"\"\n\t    Run a linux command. The command is defined as a list. See subprocess.Popen documentation on format\n", "    :param command: command to execute. Type: List of strings\n\t    :param shell: execute the command through shell when True. Type: Boolean\n\t    :param hide_errors: don't report errors to syslog when True. Type: Boolean\n\t    :return: Tuple: integer exit code from the command, stdout as a string, stderr as a string\n\t    \"\"\"\n\t    log_debug(\"execute command '%s'.\" % str(command))\n\t    p = subprocess.Popen(command, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='utf-8')\n\t    stdout, stderr = p.communicate()\n\t    if p.returncode != 0:\n\t        if not hide_errors:\n", "            print_tuple = p.returncode, str(command), stdout, stderr\n\t            log_err(\"command execution returned %d. Command: '%s', stdout: '%s', stderr: '%s'\" % print_tuple)\n\t    return p.returncode, stdout, stderr\n\tdef read_constants():\n\t    \"\"\" Read file with constants values from /etc/sonic/constants.yml \"\"\"\n\t    with open('/etc/sonic/constants.yml') as fp:\n\t        content = yaml.load(fp) # FIXME: , Loader=yaml.FullLoader)\n\t        if \"constants\" not in content:\n\t            log_crit(\"/etc/sonic/constants.yml doesn't have 'constants' key\")\n\t            raise Exception(\"/etc/sonic/constants.yml doesn't have 'constants' key\")\n", "        return content[\"constants\"]\n\tdef print_dict(data):\n\t    if not g_dev_debug:\n\t        return\n\t    print(\"Printing dictionary {}\".format(data))\n\t    for key, val in data.items():\n\t        print(\"key {} : val {}\".format(key, val))\n\t        if type(val) == dict:\n\t            print_dict(val)\n"]}
{"filename": "platform/mkrules/src/sonic-vppcfgd/vppcfgd/directory.py", "chunked_list": ["# Copyright 2016 Microsoft, Inc.\n\t# Modifications copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n", "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom collections import defaultdict\n\tfrom .log import log_err\n\tclass Directory(object):\n\t    \"\"\" This class stores values and notifies callbacks which were registered to be executed as soon\n\t        as some value is changed. This class works as DB cache mostly \"\"\"\n\t    def __init__(self):\n\t        self.data = defaultdict(dict)  # storage. A key is a slot name, a value is a dictionary with data\n", "        self.notify = defaultdict(lambda: defaultdict(list))  # registered callbacks: slot -> path -> handlers[]\n\t    @staticmethod\n\t    def get_slot_name(db, table):\n\t        \"\"\" Convert db, table pair into a slot name \"\"\"\n\t        return db + \"__\" + table\n\t    def path_traverse(self, slot, path):\n\t        \"\"\"\n\t        Traverse a path in the storage.\n\t        If the path is an empty string, it returns a value as it is.\n\t        If the path is not an empty string, the method will traverse through the dictionary value.\n", "        Example:\n\t            self.data[\"key_1\"] = { \"abc\": { \"cde\": { \"fgh\": \"val_1\", \"ijk\": \"val_2\" } } }\n\t            self.path_traverse(\"key_1\", \"abc/cde\") will return True, { \"fgh\": \"val_1\", \"ijk\": \"val_2\" }\n\t        :param slot: storage key\n\t        :param path: storage path as a string where each internal key is separated by '/'\n\t        :return: a pair: True if the path was found, object if it was found\n\t        \"\"\"\n\t        if slot not in self.data:\n\t            return False, None\n\t        elif path == '':\n", "            return True, self.data[slot]\n\t        d = self.data[slot]\n\t        for p in path.split(\"/\"):\n\t            if p not in d:\n\t                return False, None\n\t            d = d[p]\n\t        return True, d\n\t    def path_exist(self, db, table, path):\n\t        \"\"\"\n\t        Check if the path exists in the storage\n", "        :param db: db name\n\t        :param table: table name\n\t        :param path: requested path\n\t        :return: True if the path is available, False otherwise\n\t        \"\"\"\n\t        slot = self.get_slot_name(db, table)\n\t        return self.path_traverse(slot, path)[0]\n\t    def get_path(self, db, table, path):\n\t        \"\"\"\n\t        Return the requested path from the storage\n", "        :param db: db name\n\t        :param table: table name\n\t        :param path: requested path\n\t        :return: object if the path was found, None otherwise\n\t        \"\"\"\n\t        slot = self.get_slot_name(db, table)\n\t        return self.path_traverse(slot, path)[1]\n\t    def put(self, db, table, key, value):\n\t        \"\"\"\n\t        Put information into the storage. Notify handlers which are dependant to the information\n", "        :param db: db name\n\t        :param table: table name\n\t        :param key: key to change\n\t        :param value: value to put\n\t        :return:\n\t        \"\"\"\n\t        slot = self.get_slot_name(db, table)\n\t        self.data[slot][key] = value\n\t        if slot in self.notify:\n\t            for path in self.notify[slot].keys():\n", "                if self.path_exist(db, table, path):\n\t                    for handler in self.notify[slot][path]:\n\t                        handler()\n\t    def get(self, db, table, key):\n\t        \"\"\"\n\t        Get a value from the storage\n\t        :param db: db name\n\t        :param table: table name\n\t        :param key: ket to get\n\t        :return: value for the key\n", "        \"\"\"\n\t        slot = self.get_slot_name(db, table)\n\t        return self.data[slot][key]\n\t    def get_slot(self, db, table):\n\t        \"\"\"\n\t        Get an object from the storage\n\t        :param db: db name\n\t        :param table: table name\n\t        :return: object for the slot\n\t        \"\"\"\n", "        slot = self.get_slot_name(db, table)\n\t        return self.data[slot]\n\t    def remove(self, db, table, key):\n\t        \"\"\"\n\t        Remove a value from the storage\n\t        :param db: db name\n\t        :param table: table name\n\t        :param key: key to remove\n\t        \"\"\"\n\t        slot = self.get_slot_name(db, table)\n", "        if slot in self.data:\n\t            if key in self.data[slot]:\n\t                del self.data[slot][key]\n\t            else:\n\t                log_err(\"Directory: Can't remove key '%s' from slot '%s'. The key doesn't exist\" % (key, slot))\n\t        else:\n\t            log_err(\"Directory: Can't remove key '%s' from slot '%s'. The slot doesn't exist\" % (key, slot))\n\t    def remove_slot(self, db, table):\n\t        \"\"\"\n\t        Remove an object from the storage\n", "        :param db: db name\n\t        :param table: table name\n\t        \"\"\"\n\t        slot = self.get_slot_name(db, table)\n\t        if slot in self.data:\n\t            del self.data[slot]\n\t        else:\n\t            log_err(\"Directory: Can't remove slot '%s'. The slot doesn't exist\" % slot)\n\t    def available(self, db, table):\n\t        \"\"\"\n", "        Check if the table is available\n\t        :param db: db name\n\t        :param table: table name\n\t        :return: True if the slot is available, False if not\n\t        \"\"\"\n\t        slot = self.get_slot_name(db, table)\n\t        return slot in self.data\n\t    def available_deps(self, deps):\n\t        \"\"\"\n\t        Check if all items from the deps list is available in the storage\n", "        :param deps: list of dependencies\n\t        :return: True if all dependencies are presented, False otherwise\n\t        \"\"\"\n\t        res = True\n\t        for db, table, path in deps:\n\t            res = res and self.path_exist(db, table, path)\n\t        return res\n\t    def subscribe(self, deps, handler):\n\t        \"\"\"\n\t        Subscribe the handler to be run as soon as all dependencies are presented\n", "        :param deps:\n\t        :param handler:\n\t        :return:\n\t        \"\"\"\n\t        for db, table, path in deps:\n\t            slot = self.get_slot_name(db, table)\n\t            self.notify[slot][path].append(handler)\n"]}
{"filename": "platform/vpp/docker-sonic-vpp/scripts/vppcfg_load.py", "chunked_list": ["#!/usr/bin/python3\n\t# -*- coding: utf-8 -*-\n\t# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport json\n\timport sys\n\timport os\n\timport tempfile\n\tdef load_config():\n\t    cfg = {}\n", "    vpp = {}\n\t    conf_db_set = os.getenv('VPP_CONF_DB', '')\n\t    if not conf_db_set or conf_db_set != 'y':\n\t        sys.exit(0)\n\t    portlist = os.getenv('VPP_DPDK_PORTS', '')\n\t    vports = {}\n\t    dpdk_ports = {}\n\t    index=0\n\t    for port in portlist.split(','):\n\t        rc = os.system('ip link show type veth dev {}'.format(port))\n", "        if rc == 0:\n\t            vports[port] = ''\n\t        else:\n\t            dpdk_ports[port] = {'name': 'bobm{}'.format(index)}\n\t            index += 1\n\t    if len(vports):\n\t        vpp['vports'] = vports\n\t    if len(dpdk_ports):\n\t        dpdk = { 'dev': dpdk_ports }\n\t        vpp['dpdk'] = dpdk\n", "    cfg['PLATFORM'] = { 'vpp': vpp }\n\t    print(cfg)\n\t    fd, tmpfile = tempfile.mkstemp(prefix='vppcfg')\n\t    with open(tmpfile, 'w') as fp:\n\t        json.dump(cfg, fp, indent=4)\n\t    rc = os.system('cat {}'.format(tmpfile))\n\t    rc += os.system('config load -y {}'.format(tmpfile))\n\t    os.close(fd)\n\t    os.unlink(tmpfile)\n\t    return rc\n", "if __name__ == '__main__':\n\t   sys.exit(load_config())\n"]}
{"filename": "platform/vpp/tests/breakout/test_breakout_cli.py", "chunked_list": ["from swsscommon import swsscommon\n\timport time\n\timport os\n\timport json\n\timport ast\n\timport pytest\n\timport collections\n\t@pytest.mark.usefixtures('dpb_setup_fixture')\n\tclass TestBreakoutCli(object):\n\t    def setup_db(self, dvs):\n", "        self.cdb = swsscommon.DBConnector(4, dvs.redis_sock, 0)\n\t    def read_Json(self, dvs):\n\t        test_dir = os.path.dirname(os.path.realpath(__file__))\n\t        sample_output_file = os.path.join(test_dir, 'sample_output', 'sample_new_port_config.json')\n\t        with open(sample_output_file, 'rb') as fh:\n\t            fh_data = json.load(fh)\n\t        if not fh_data:\n\t            return False\n\t        expected = ast.literal_eval(json.dumps(fh_data))\n\t        return expected\n", "    def breakout(self, dvs, interface, brkout_mode):\n\t        (exitcode, result) = dvs.runcmd(\"config interface breakout {} {} -y\".format(interface, brkout_mode))\n\t        if result.strip(\"\\n\")[0] == \"[ERROR] Breakout feature is not available without platform.json file\" :\n\t            pytest.skip(\"**** This test is not needed ****\")\n\t        root_dir = os.path.dirname('/')\n\t        (exitcode, output_dict) = dvs.runcmd(\"jq '.' new_port_config.json\")\n\t        if output_dict is None:\n\t            raise Exception(\"Breakout output cant be None\")\n\t        output_dict = ast.literal_eval(output_dict.strip())\n\t        return output_dict\n", "    # Check Initial Brakout Mode\n\t    def test_InitialBreakoutMode(self, dvs, testlog):\n\t        self.setup_db(dvs)\n\t        output_dict = {}\n\t        brkoutTbl = swsscommon.Table(self.cdb, \"BREAKOUT_CFG\")\n\t        brkout_entries = brkoutTbl.getKeys()\n\t        assert len(brkout_entries) == 32\n\t        for key in brkout_entries:\n\t            (status, fvs) = brkoutTbl.get(key)\n\t            assert status\n", "            brkout_mode = fvs[0][1]\n\t            output_dict[key] = brkout_mode\n\t        output = collections.OrderedDict(sorted(output_dict.items(), key=lambda t: t[0]))\n\t        expected_dict = \\\n\t                {'Ethernet8': '1x100G[40G]', 'Ethernet0': '1x100G[40G]', 'Ethernet4': '1x100G[40G]', \\\n\t                'Ethernet108': '1x100G[40G]', 'Ethernet100': '1x100G[40G]', 'Ethernet104': '1x100G[40G]', \\\n\t                'Ethernet68': '1x100G[40G]', 'Ethernet96': '1x100G[40G]', 'Ethernet124': '1x100G[40G]', \\\n\t                'Ethernet92': '1x100G[40G]', 'Ethernet120': '1x100G[40G]', 'Ethernet52': '1x100G[40G]', \\\n\t                'Ethernet56': '1x100G[40G]', 'Ethernet76': '1x100G[40G]', 'Ethernet72': '1x100G[40G]', \\\n\t                'Ethernet32': '1x100G[40G]', 'Ethernet16': '1x100G[40G]', 'Ethernet36': '1x100G[40G]', \\\n", "                'Ethernet12': '1x100G[40G]', 'Ethernet28': '1x100G[40G]', 'Ethernet88': '1x100G[40G]', \\\n\t                'Ethernet116': '1x100G[40G]', 'Ethernet80': '1x100G[40G]', 'Ethernet112': '1x100G[40G]', \\\n\t                'Ethernet84': '1x100G[40G]', 'Ethernet48': '1x100G[40G]', 'Ethernet44': '1x100G[40G]', \\\n\t                'Ethernet40': '1x100G[40G]', 'Ethernet64': '1x100G[40G]', 'Ethernet60': '1x100G[40G]', \\\n\t                'Ethernet20': '1x100G[40G]', 'Ethernet24': '1x100G[40G]'}\n\t        expected = collections.OrderedDict(sorted(expected_dict.items(), key=lambda t: t[0]))\n\t        assert output == expected\n\t    # Breakout Cli Test Mode\n\t    def test_breakout_modes(self, dvs):\n\t        expected = self.read_Json(dvs)\n", "        assert expected\n\t        print(\"**** Breakout Cli test Starts ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet0', '2x50G')\n\t        expected_dict = expected[\"Ethernet0_2x50G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 1X100G --> 2x50G passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet4', '4x25G[10G]')\n\t        expected_dict = expected[\"Ethernet4_4x25G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 1X100G --> 4x25G[10G] passed ****\")\n", "        output_dict = self.breakout(dvs, 'Ethernet8', '2x25G(2)+1x50G(2)')\n\t        expected_dict = expected[\"Ethernet8_2x25G_1x50G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 1X100G --> 2x25G(2)+1x50G(2) passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet12', '1x50G(2)+2x25G(2)')\n\t        expected_dict = expected[\"Ethernet12_1x50G_2x25G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 1X100G --> 1x50G(2)+2x25G(2) passed ****\")\n\t        # TODOFIX: remove comments once #4442 PR got merged and\n\t        # yang model for DEVICE_METADATA becomes available.\n", "        # As below test cases are dependent on DEVICE_METADATA to go\n\t        # from a non-default breakout mode to a different breakout mode.\n\t        \"\"\"\n\t        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n\t        expected_dict = expected[\"Ethernet0_1x100G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 2x50G --> 1x100G[40G] passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet0', '4x25G[10G]')\n\t        expected_dict = expected[\"Ethernet0_4x25G\"]\n\t        assert output_dict == expected_dict\n", "        print(\"**** 1X100G --> 4x25G[10G] passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n\t        expected_dict = expected[\"Ethernet0_1x100G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 4x25G[10G] --> 1x100G[40G] passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet4', '2x50G')\n\t        print(\"**** 1X100G --> 2x50G mode change ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet4', '4x25G[10G]')\n\t        expected_dict = expected[\"Ethernet4_4x25G\"]\n\t        assert output_dict == expected_dict\n", "        print(\"**** 2X50G --> 4x25G[10G] passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet4', '2x50G')\n\t        expected_dict = expected[\"Ethernet4_2x50G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 4x25G[10G] --> 2X50G passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet4', '1x100G[40G]')\n\t        print(\"**** 2x50G  -- > 1X100G mode change ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet0', '2x25G(2)+1x50G(2)')\n\t        expected_dict = expected[\"Ethernet0_2x25G_1x50G\"]\n\t        assert output_dict == expected_dict\n", "        print(\"**** 1x100G[40G] --> 2x25G(2)+1x50G(2) passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n\t        expected_dict = expected[\"Ethernet0_1x100G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 2x25G(2)+1x50G(2) --> 1x100G[40G] passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet0', '1x50G(2)+2x25G(2)')\n\t        expected_dict = expected[\"Ethernet0_1x50G_2x25G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 1x100G[40G] --> 1x50G(2)+2x25G(2)  passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet0', '1x100G[40G]')\n", "        expected_dict = expected[\"Ethernet0_1x100G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 1x50G(2)+2x25G(2) --> 1x100G[40G] passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet8', '2x50G')\n\t        print(\"**** 1x100G[40G] --> 2x50G  mode change ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet8', '1x50G(2)+2x25G(2)')\n\t        expected_dict = expected[\"Ethernet8_1x50G_2x25G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 2x50G --> 2x25G(2)+1x50G(2)  passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet8', '2x25G(2)+1x50G(2)')\n", "        expected_dict = expected[\"Ethernet8_2x25G_1x50G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 1x50G(2)+2x25G(2) --> 2x25G(2)+1x50G(2)  passed ****\")\n\t        output_dict = self.breakout(dvs, 'Ethernet8', '1x100G[40G]')\n\t        expected_dict = expected[\"Ethernet8_1x100G\"]\n\t        assert output_dict == expected_dict\n\t        print(\"**** 2x25G(2)+1x50G(2)  --> 1x100G[40G]  passed ****\")\n\t        \"\"\"\n"]}
{"filename": "platform/vpp/tests/teamd/test_portchannel.py", "chunked_list": ["from swsscommon import swsscommon\n\timport time\n\timport re\n\timport json\n\tdef test_PortChannel(dvs, testlog):\n\t    appldb = swsscommon.DBConnector(0, dvs.redis_sock, 0)\n\t    statdb = swsscommon.DBConnector(6, dvs.redis_sock, 0)\n\t    # create the lag\n\t    dvs.runcmd(\"config portchannel add PortChannel0001\")\n\t    time.sleep(1)\n", "    # test lag table in appl db\n\t    tbl = swsscommon.Table(appldb, \"LAG_TABLE\")\n\t    (status, fvs) = tbl.get(\"PortChannel0001\")\n\t    assert status == True\n\t    # test lag table in state db\n\t    tbl = swsscommon.Table(statdb, \"LAG_TABLE\")\n\t    (status, fvs) = tbl.get(\"PortChannel0001\")\n\t    assert status == True\n\t    # create the lag member\n\t    dvs.runcmd(\"config portchannel member add PortChannel0001 Ethernet112\")\n", "    time.sleep(1)\n\t    # test lag member table in appl db\n\t    tbl = swsscommon.Table(appldb, \"LAG_MEMBER_TABLE\")\n\t    (status, fvs) = tbl.get(\"PortChannel0001:Ethernet112\")\n\t    assert status == True\n\t    # remove the lag member\n\t    dvs.runcmd(\"config portchannel member del PortChannel0001 Ethernet112\")\n\t    # remove the lag\n\t    dvs.runcmd(\"config portchannel del PortChannel0001\")\n"]}
{"filename": "platform/vpp/tests/bgp/test_invalid_nexthop.py", "chunked_list": ["from swsscommon import swsscommon\n\timport os\n\timport re\n\timport time\n\timport json\n\timport pytest\n\tdef test_InvalidNexthop(dvs, testlog):\n\t    dvs.copy_file(\"/etc/frr/\", \"bgp/files/invalid_nexthop/bgpd.conf\")\n\t    dvs.runcmd(\"supervisorctl start bgpd\")\n\t    dvs.runcmd(\"ip addr add fc00::1/126 dev Ethernet0\")\n", "    dvs.runcmd(\"config interface startup Ethernet0\")\n\t    dvs.servers[0].runcmd(\"ip addr add fc00::2/126 dev eth0\")\n\t    dvs.servers[0].runcmd(\"ifconfig eth0 up\")\n\t    time.sleep(5)\n\t    print(dvs.runcmd(\"supervisorctl status\"))\n\t    p = dvs.servers[0].runcmd_async(\"exabgp -d bgp/files/invalid_nexthop/invalid_nexthop.conf\")\n\t    time.sleep(10)\n\t    (exit_code, output) = dvs.runcmd([\"vtysh\", \"-c\", \"show bgp ipv6\"])\n\t    p.terminate()\n\t    p = p.wait()\n", "    print(exit_code, output)\n\t    assert \"3333::/64\" in output\n"]}
{"filename": "platform/vpp/tests/bgp/test_no_export.py", "chunked_list": ["from swsscommon import swsscommon\n\timport os\n\timport re\n\timport time\n\timport json\n\tdef test_bounce(dvs, testlog):\n\t    dvs.copy_file(\"/etc/frr/\", \"bgp/files/no_export/bgpd.conf\")\n\t    dvs.runcmd(\"supervisorctl start bgpd\")\n\t    dvs.runcmd(\"ip addr add 10.0.0.0/31 dev Ethernet0\")\n\t    dvs.runcmd(\"config interface startup Ethernet0\")\n", "    dvs.runcmd(\"ip addr add 10.0.0.2/31 dev Ethernet4\")\n\t    dvs.runcmd(\"config interface startup Ethernet4\")\n\t    dvs.servers[0].runcmd(\"ip addr add 10.0.0.1/31 dev eth0\")\n\t    dvs.servers[0].runcmd(\"ifconfig eth0 up\")\n\t    dvs.servers[1].runcmd(\"ip addr add 10.0.0.3/31 dev eth0\")\n\t    dvs.servers[1].runcmd(\"ifconfig eth0 up\")\n\t    time.sleep(5)\n\t    p1 = dvs.servers[0].runcmd_async(\"exabgp -d bgp/files/no_export/exabgp1.conf\")\n\t    p2 = dvs.servers[1].runcmd_async(\"exabgp -d bgp/files/no_export/exabgp2.conf\")\n\t    time.sleep(60)\n", "    (exit_code, sum_res) =  dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp sum\"])\n\t    (exit_code, all_route) = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp\"])\n\t    (exit_code, announce_route) = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.3 advertised-routes\"])\n\t    p1.terminate()\n\t    p1 = p1.wait()\n\t    p2.terminate()\n\t    p2 = p2.wait()\n\t    print(sum_res)\n\t    print(announce_route)\n\t    assert \"1.1.1.1/32\" in all_route\n", "    assert \"1.1.1.1/32\" not in announce_route\n\t    assert \"2.2.2.2/32\" in all_route\n\t    assert \"2.2.2.2/32\" in announce_route\n"]}
{"filename": "platform/vpp/tests/bgp/test_gr_livelock.py", "chunked_list": ["from swsscommon import swsscommon\n\timport os\n\timport re\n\timport time\n\timport json\n\timport random\n\tdef output(dvs, title):\n\t    print(\"=========================== %s ===========================\" % title)\n\t    exit_cod,  sum_res =  dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp sum\"])\n\t    exit_code, all_route = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp\"])\n", "    exit_code, neig_1           = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.1\"])\n\t    exit_code, announce_route_1 = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.1 advertised-routes\"])\n\t    exit_code, received_route_1 = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.1 routes\"])\n\t    exit_code, announce_route_3 = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.3 advertised-routes\"])\n\t    exit_code, received_route_3 = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.3 routes\"])\n\t    print(\"Summary:\")\n\t    print(sum_res)\n\t    print(\"Received routes:\")\n\t    print(\"10.0.0.1\")\n\t    print(received_route_1)\n", "    print(\"10.0.0.3\")\n\t    print(received_route_3)\n\t    print(\"Announces routes:\")\n\t    print(\"10.0.0.1\")\n\t    print(announce_route_1)\n\t    print(\"10.0.0.3\")\n\t    print(announce_route_3)\n\t    print(\"Neighbors\")\n\t    print(\"10.0.0.1\")\n\t    print(neig_1)\n", "    print(\"======================================================\")\n\tdef mkdir(path):\n\t    if not os.path.exists(path):\n\t        os.makedirs(path)\n\tdef remove(path):\n\t    if os.path.exists(path):\n\t        os.unlink(path)\n\tdef get_target_env(idx):\n\t    return '/usr/local/etc/exabgp/exabgp_%d.env' % idx\n\tdef prepare_exa_env(dvs, idx):\n", "    mkdir('/usr/local/etc')\n\t    mkdir('/usr/local/etc/exabgp')\n\t    tmp_name = '/tmp/env.%d.%d' % (random.randint(0, 10000000), os.getpid())\n\t    dvs.servers[idx].runcmd(\"exabgp --fi > %s\" % tmp_name)\n\t    with open(tmp_name) as r_fp:\n\t        with open(get_target_env(idx), 'w') as w_fp:\n\t            for line in r_fp:\n\t                if line.startswith('pipename'):\n\t                    line = \"pipename = 'exabgp.%d'\\n\" % idx\n\t                w_fp.write(line)\n", "    os.unlink(tmp_name)\n\tdef run_exa(dvs, idx, cfg):\n\t    prepare_exa_env(dvs, idx)\n\t    run_dir = \"/var/run/exabgp\"\n\t    mkdir(run_dir)\n\t    fifo_in_path  = \"%s/exabgp.%d.in\"  % (run_dir, idx)\n\t    fifo_out_path = \"%s/exabgp.%d.out\" % (run_dir, idx)\n\t    remove(fifo_in_path)\n\t    remove(fifo_out_path)\n\t    os.mkfifo(fifo_in_path)\n", "    os.mkfifo(fifo_out_path)\n\t    os.chmod(fifo_in_path,  0o666)\n\t    os.chmod(fifo_out_path, 0o666)\n\t    print(\"!!! Start exabgp instance %d\" % idx)\n\t    cmd = \"exabgp -d --env %s %s\" % (get_target_env(idx), cfg)\n\t    print(\"Cmd is ___ %s ___\" % cmd)\n\t    return dvs.servers[idx].runcmd_async(cmd)\n\tdef run_exacli(dvs, idx, cmd):\n\t    return dvs.servers[idx].runcmd('exabgpcli --env %s %s' % (get_target_env(idx), cmd))\n\tdef test_gr_livelock(dvs, testlog):\n", "    # update exabgp to version 4.0.10\n\t    dvs.servers[0].runcmd(\"pip install 'exabgp==4.0.10' --force-reinstall \")\n\t    #\n\t    dvs.copy_file(\"/etc/frr/\", \"bgp/files/gr_livelock/bgpd.conf\")\n\t    dvs.runcmd(\"supervisorctl stop bgpd\")\n\t    time.sleep(5)\n\t    dvs.runcmd(\"supervisorctl start bgpd\")\n\t    dvs.runcmd(\"ip addr add 10.0.0.0/31 dev Ethernet0\")\n\t    dvs.runcmd(\"config interface startup Ethernet0\")\n\t    dvs.runcmd(\"ip addr add 10.0.0.2/31 dev Ethernet4\")\n", "    dvs.runcmd(\"config interface startup Ethernet4\")\n\t    dvs.servers[0].runcmd(\"ip addr add 10.0.0.1/31 dev eth0\")\n\t    dvs.servers[0].runcmd(\"ifconfig eth0 up\")\n\t    dvs.servers[1].runcmd(\"ip addr add 10.0.0.3/31 dev eth0\")\n\t    dvs.servers[1].runcmd(\"ifconfig eth0 up\")\n\t    time.sleep(5)\n\t    # Run two bgp neighbors\n\t    p1 = run_exa(dvs, 0, \"bgp/files/gr_livelock/exabgp1.conf\")\n\t    p2 = run_exa(dvs, 1, \"bgp/files/gr_livelock/exabgp2.conf\")\n\t    time.sleep(30)\n", "    output(dvs, \"First neighbor doesn't have GR enabled\")\n\t    # Check that we announce routes from the 1st neigbbor to 2nd, if 1st neighbor doesn't support graceful restart\n\t    _, announced_routes = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.3 advertised-routes\"])\n\t    assert '2.2.2.2/32' in announced_routes\n\t    # Stop 1st neighbor\n\t    run_exacli(dvs, 0, 'shutdown')\n\t    p1 = p1.wait()\n\t    # Wait until frr thinks that 1st neighbor was shut down\n\t    time.sleep(300)\n\t    # Start the 1st neighbor again with graceful restart enabled\n", "    p1 = run_exa(dvs, 0, \"bgp/files/gr_livelock/exabgp1.graceful.conf\")\n\t    time.sleep(60)\n\t    output(dvs, \"First neighbor has GR enalbed\")\n\t    run_exacli(dvs, 0, 'announce route 1.10.0.0/24 next-hop self')\n\t    time.sleep(60)\n\t    output(dvs, \"Announced a new route from the first neighbor\")\n\t    # Check that we announce all routes from the 1st neighbor\n\t    _, announced_routes = dvs.runcmd([\"vtysh\", \"-c\", \"show ip bgp neighbors 10.0.0.3 advertised-routes\"])\n\t    assert '2.2.2.2/32'  in announced_routes\n\t    assert '1.10.0.0/24' in announced_routes\n", "    run_exacli(dvs, 0, 'shutdown')\n\t    p1 = p1.wait()\n\t    run_exacli(dvs, 1, 'shutdown')\n\t    p2 = p2.wait()\n"]}
{"filename": "platform/vpp/tests/bgp/test_default_route.py", "chunked_list": ["from swsscommon import swsscommon\n\timport os\n\timport re\n\timport time\n\timport json\n\timport pytest\n\tdef test_DefaultRoute(dvs, testlog):\n\t    dvs.copy_file(\"/etc/frr/\", \"bgp/files/default_route/bgpd.conf\")\n\t    dvs.runcmd(\"supervisorctl start bgpd\")\n\t    dvs.runcmd(\"ip addr add 10.10.10.0/31 dev Ethernet0\")\n", "    dvs.runcmd(\"config interface startup Ethernet0\")\n\t    dvs.runcmd(\"ip route del 0.0.0.0/0\")\n\t    dvs.runcmd(\"vtysh -c \\\"confgure terminal\\\" -c \\\"ip route 0.0.0.0/0 via 172.17.0.1 200\\\"\")\n\t    dvs.servers[0].runcmd(\"ip addr add 10.10.10.1/31 dev eth0\")\n\t    dvs.servers[0].runcmd(\"ifconfig eth0 up\")\n\t    time.sleep(5)\n\t    print(dvs.runcmd(\"supervisorctl status\"))\n\t    p = dvs.servers[0].runcmd_async(\"exabgp -d bgp/files/default_route/default_route.conf\")\n\t    time.sleep(10)\n\t    (exit_code, output) = dvs.runcmd([\"redis-cli\", \"hgetall\", \"ROUTE_TABLE:0.0.0.0/0\"])\n", "    print(exit_code, output)\n\t    # make sure 10.10.10.1 is the correct next hop for default route\n\t    assert \"10.10.10.1\" in output\n\t    # insert default route for table default\n\t    dvs.runcmd(\"ip route add default via 172.17.0.1 table default\")\n\t    (exit_code, output) = dvs.runcmd([\"redis-cli\", \"hgetall\", \"ROUTE_TABLE:0.0.0.0/0\"])\n\t    print(exit_code, output)\n\t    time.sleep(10)\n\t    # make sure 10.10.10.1 is still the correct next hop for default route\n\t    assert \"10.10.10.1\" in output\n", "    p.terminate()\n\t    p = p.wait()\n"]}
{"filename": "tests/validate-sonic-vpp-vm-routing.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport sys\n\timport subprocess\n\timport yaml\n\timport ipaddress\n\timport pprint\n\timport re\n\timport argparse\n\tfrom jinja2 import Environment, FileSystemLoader\n", "def getIppoolAndCidrMask(ipPoolCidr):\n\t    separator = \"/\"\n\t    ippool = ipPoolCidr.split(separator)\n\t    return ippool[0], ippool[1]\n\tdef checkPosInteger(num):\n\t    if not num.isdigit():\n\t        print(f'Invalid IPPool has been provided')\n\t        sys.exit(1)\n\tdef checkIp(ip):\n\t    try:\n", "        ipaddress.ip_address(ip)\n\t    except ValueError:\n\t        print(f'Invalid IP address specified - {ip}')\n\t        sys.exit(1)\n\tdef checkAction(action):\n\t    if  action != \"build\" and action != \"tear\" and action != \"build,tear\":\n\t        print(\"Invalid action specified\")\n\t        sys.exit(1)\n\tdef getSubnet(ippool):\n\t    separator = \".\"\n", "    subnetArr = ippool.split(separator)\n\t    subnetReqdArr = subnetArr[:2]\n\t    subnet =  separator.join(subnetReqdArr)\n\t    return subnet\n\tdef checkVerboselog(verboselog):\n\t    for i in verboselog:\n\t        if i != 'v' and verboselog.count(i) != len(verboselog):\n\t            print(\"Invalid verbose argument passed. Please pass like - 'v' or 'vv' or 'vvv' or 'vvvv' or 'vvvvvv\")\n\t            sys.exit(1)\n\tdef createInventoryFromTemplate(username, password, host):\n", "    environment = Environment(loader=FileSystemLoader(\".\"))\n\t    #inventory.j2\n\t    template = environment.get_template(\"inventory-vm.j2\")\n\t    #new inventory file with values filled at templatized variables\n\t    filename = \"inventory-vm.yaml\"\n\t    content = template.render(\n\t        username = username,\n\t        password = password,\n\t        host = host\n\t    )\n", "    with open(filename, mode=\"w\", encoding=\"utf-8\") as message:\n\t        message.write(content)\n\t        print(f\"... wrote {filename}\")\n\tdef runSonic(action, verboselogArg):\n\t    ansiblePlaybook = \"sonic-vpp-vm-bring-up.yaml\"\n\t    print(\"ansible-playbook : \", ansiblePlaybook, \"\\n\")\n\t    cmd = ['ansible-playbook', '-i', 'inventory-vm.yaml',  ansiblePlaybook, '--extra-vars', '@inventory-vm.yaml', '--tags', action, verboselogArg]\n\t    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n\t    for l in p.stdout.readlines():\n\t        loglineDecoded = l.decode()\n", "        print(loglineDecoded)\n\t        if  re.search('failed=', loglineDecoded) != None and re.search('unreachable=', loglineDecoded) != None:\n\t            if None == re.search('failed=0', loglineDecoded):\n\t                print(f'failed to execute {loglineDecoded.split().pop(0)} ansible {action} task')\n\t                sys.exit(1)\n\t            if None == re.search('unreachable=0', loglineDecoded):\n\t                print(f'failed to execute {loglineDecoded.split().pop(0)} ansible {action} task, VM is unreachable')\n\t                sys.exit(1)\n\t        if None != re.search('ok=0', loglineDecoded):\n\t            print(f'unable to execute {loglineDecoded.split().pop(0)} ansible {action} task')\n", "            sys.exit(1)\n\t    if action == \"build\" or action == \"build,tear\":\n\t        print(\"SUCCESSFUL in validating SONiC VM routing...\\n\")\n\t    else:\n\t        print(\"SUCCESSFUL in tearing down SONiC VM routing...\\n\")    \n\t    print(\"OPERATION COMPLETE...\\n\") \n\t#Main\n\tparser = argparse.ArgumentParser()\n\tparser.add_argument(\"--action\", type=str, help=\"enter action -  {'build' | 'tear'}\", nargs='?', default=\"build,tear\")\n\tparser.add_argument(\"--IPPool\", type=str, help=\"enter IPPool - example : '172.16.0.0/16'\", nargs='?', default=\"172.16.0.0/16\") \n", "parser.add_argument(\"--host\", type=str, help=\"enter host - example : '10.64.98.181'\", nargs='?',required=True )   \n\tparser.add_argument(\"--username\", type=str, help=\"enter SSH username for host\", nargs='?',required=True ) \n\tparser.add_argument(\"--password\", type=str, help=\"enter SSH user password for host\", nargs='?',required=True )                       \n\tparser.add_argument(\"--verboselog\", type=str, help=\"enter verbose logging - example : 'v or vv or vvv etc'\", nargs='?', default=\"v\")\n\targs = parser.parse_args()\n\taction = args.action\n\tippoolCidr = args.IPPool\n\thost = args.host\n\tusername = args.username\n\tpassword = args.password\n", "verboselog = args.verboselog\n\t#check action\n\tcheckAction(action)\n\t#get ippool\n\tipPool, cidrMask = getIppoolAndCidrMask(ippoolCidr)\n\t#validate ippool\n\tcheckIp(ipPool)\n\t#validate cidrMask\n\tcheckPosInteger(cidrMask)\n\t#extract subnet\n", "subnet =  getSubnet(ipPool)\n\t#validate host\n\tcheckIp(host)\n\t#validate verbose argument\n\tcheckVerboselog(verboselog)\n\tprint('Arguments passed:\\n')\n\tprint('_________________________\\n')\n\tprint(f'action - {action}\\nusername - {username}\\npassword - {password}\\nhost - {host}\\nverbose - {verboselog}')\n\tprint('_________________________\\n')\n\t#create inventory yaml file\n", "createInventoryFromTemplate(username, password, host)\n\t#run python script\n\trunSonic(action, \"-\"+verboselog)\n\tsys.exit(0)\n"]}
{"filename": "tests/validate-sonic-vpp-docker-routing.py", "chunked_list": ["# Copyright (c) 2023 Cisco and/or its affiliates.\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at:\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport sys\n\timport subprocess\n\timport yaml\n\timport ipaddress\n\timport pprint\n\timport re\n\timport argparse\n\tfrom jinja2 import Environment, FileSystemLoader\n", "def getIppoolAndCidrMask(ipPoolCidr):\n\t    separator = \"/\"\n\t    ippool = ipPoolCidr.split(separator)\n\t    if len(ippool) != 2:\n\t        print(f'Invalid IP Pool - \"{ipPoolCidr}\" is specified')\n\t        sys.exit(1)\n\t    return ippool[0], ippool[1]\n\tdef checkPosInteger(num):\n\t    if not num.isdigit():\n\t        print(f'Invalid IPPool has been provided')\n", "        sys.exit(1)\n\tdef checkIp(ip):\n\t    try:\n\t        ipaddress.ip_address(ip)\n\t    except ValueError:\n\t        print(f'Invalid IP address specified - {ip}')\n\t        sys.exit(1)\n\tdef checkAction(action):\n\t    if  action != \"build\" and action != \"tear\" and action != \"build,tear\":\n\t        print(\"Invalid action specified\")\n", "        sys.exit(1)\n\tdef checkTopology(topology):\n\t    if not (topology == \"singleHop\" or topology == \"multiHop\"):\n\t        print(\"Invalid topology specified\")\n\t        sys.exit(1)\n\tdef checkRouting(routing):\n\t    if not (routing == \"static\" or routing == \"bgp\"):\n\t        print(\"Invalid routing protocol specified\")\n\t        sys.exit(1)\n\tdef checkIpType(ip, iptype):\n", "    if iptype == \"ipv4\":\n\t        if not type(ipaddress.ip_address(ip)) is ipaddress.IPv4Address:\n\t            print(f'Invalid IPV4 address - \"{ip}\" is specified')\n\t            sys.exit(1)\n\t    elif iptype == \"ipv6\":\n\t         if not type(ipaddress.ip_address(ip)) is ipaddress.IPv6Address:\n\t            print(f'Invalid IPV6 address - \"{ip}\" is specified')\n\t            sys.exit(1)        \n\tdef getSubnet(ippool, separator):\n\t    subnetArr = ippool.split(separator)\n", "    subnetReqdArr = subnetArr[:2]\n\t    subnet =  separator.join(subnetReqdArr)\n\t    return subnet\n\tdef checkVerboselog(verboselog):\n\t    for i in verboselog:\n\t        if i != 'v' and verboselog.count(i) != len(verboselog):\n\t            print(\"Invalid verbose argument passed. Please pass like - 'v' or 'vv' or 'vvv' or 'vvvv' or 'vvvvvv\")\n\t            sys.exit(1)\n\tdef checkNoLinuxNl(noLinuxNl):\n\t    if noLinuxNl != \"yes\" and noLinuxNl != \"no\":\n", "        print(\"Invalid 'noLinuxNl' argument specified. Enter 'yes' or 'no'\")\n\t        sys.exit(1)\n\tdef createInventoryFromTemplate(subnet, username, password, host, subnetV6, noLinuxNl):\n\t    environment = Environment(loader=FileSystemLoader(\".\"))\n\t    #inventory.j2\n\t    template = environment.get_template(\"inventory.j2\")\n\t    #new inventory file with values filled at templatized variables\n\t    filename = \"inventory.yaml\"\n\t    noLinuxNlArg = \"\"\n\t    if noLinuxNl == \"yes\":\n", "        noLinuxNlArg = \"y\"\n\t    elif noLinuxNl == \"no\":\n\t        noLinuxNlArg = \"n\"\n\t    content = template.render(\n\t        subnet = subnet,\n\t        username = username,\n\t        password = password,\n\t        host = host,\n\t        ipv6_subnet = subnetV6,\n\t        no_linux_nl = noLinuxNlArg\n", "    )\n\t    with open(filename, mode=\"w\", encoding=\"utf-8\") as message:\n\t        message.write(content)\n\t        print(f\"... wrote {filename}\")\n\tdef execute(ansiblePlaybook, topology, verboselogArg):\n\t    cmd = ['ansible-playbook', '-i', 'inventory.yaml',  ansiblePlaybook, '--extra-vars', '@inventory.yaml', '--tags', topology,  verboselogArg]\n\t    print(cmd)\n\t    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n\t    for l in p.stdout.readlines():\n\t        loglineDecoded = l.decode()\n", "        print(loglineDecoded)\n\t        if  re.search('failed=', loglineDecoded) != None and re.search('unreachable=', loglineDecoded) != None:\n\t            if None == re.search('failed=0', loglineDecoded):\n\t                print(f'failed to execute {loglineDecoded.split().pop(0)} ansible {topology} task')\n\t                sys.exit(1)\n\t            if None == re.search('unreachable=0', loglineDecoded):\n\t                print(f'failed to execute {loglineDecoded.split().pop(0)} ansible {topology} task, VM is unreachable')\n\t                sys.exit(1)\n\t        if None != re.search('ok=0', loglineDecoded):\n\t            print(f'unable to execute {loglineDecoded.split().pop(0)} ansible {topology} task')\n", "            sys.exit(1)\n\tdef runSonic(action, topology, routing, verboselogArg):\n\t    #playbook file is first argument taken\n\t    if action == \"build\":\n\t        ansiblePlaybook = \"sonic-sw-dp-bring-up.yaml\"\n\t        print(\"ansiblePlaybook : \", ansiblePlaybook, \"\\n\")\n\t        if topology == \"multiHop\":\n\t           topology = topology + ',' + routing\n\t        execute(ansiblePlaybook, topology, verboselogArg)\n\t        print(\"SUCCESSFUL in validating SONiC routing...\\n\")\n", "    elif action == \"tear\":\n\t        ansiblePlaybook = \"sonic-sw-dp-bring-down.yaml\"\n\t        print(\"ansiblePlaybook : \", ansiblePlaybook, \"\\n\")\n\t        execute(ansiblePlaybook, topology, verboselogArg)\n\t        print(\"SUCCESSFUL in tearing down...\\n\")    \n\t#Main\n\tparser = argparse.ArgumentParser()\n\tparser.add_argument(\"--action\", type=str, help=\"enter action -  {'build' | 'tear'}\", nargs='?', default=\"build,tear\")\n\tparser.add_argument(\"--topology\", type=str, help=\"enter topology - {'singleHop' | 'multiHop'}\", nargs='?', default=\"multiHop\")\n\tparser.add_argument(\"--routing\", type=str, help=\"enter routing protocol - {'static' | 'bgp'}\", nargs='?', default=\"bgp\")\n", "parser.add_argument(\"--IPPool\", type=str, help=\"enter IPPool - example : '172.16.0.0/16'\", nargs='?', default=\"172.16.0.0/16\") \n\tparser.add_argument(\"--IPV6Pool\", type=str, help=\"enter IPV6Pool - example : '2001:0db8::/64'\", nargs='?', default=\"2001:0db8::/64\") \n\tparser.add_argument(\"--host\", type=str, help=\"enter host - example : '10.64.98.181'\", nargs='?',required=True )   \n\tparser.add_argument(\"--username\", type=str, help=\"enter SSH username for host\", nargs='?',required=True ) \n\tparser.add_argument(\"--password\", type=str, help=\"enter SSH user password for host\", nargs='?',required=True )                       \n\tparser.add_argument(\"--verboselog\", type=str, help=\"enter verbose logging - example : 'v or vv or vvv etc'\", nargs='?', default=\"v\")\n\tparser.add_argument(\"--noLinuxNl\", type=str, help=\"enter noLinuxNl - example : 'yes' or 'no'\", nargs='?', default=\"no\")\n\targs = parser.parse_args()\n\taction = args.action\n\ttopology = args.topology\n", "routing = args.routing\n\tippoolCidr = args.IPPool\n\tipv6poolCidr = args.IPV6Pool\n\thost = args.host\n\tusername = args.username\n\tpassword = args.password\n\tverboselog = args.verboselog\n\tnoLinuxNl = args.noLinuxNl\n\t#check action\n\tcheckAction(action)\n", "#check topology\n\tcheckTopology(topology)\n\t#check routing protocol\n\tcheckRouting(routing)\n\t#get ippool\n\tipPool, cidrMask = getIppoolAndCidrMask(ippoolCidr)\n\t#validate ippool\n\tcheckIp(ipPool)\n\t#check if ipv4\n\tcheckIpType(ipPool, \"ipv4\")\n", "#validate cidrMask\n\tcheckPosInteger(cidrMask)\n\t#extract subnet\n\tsubnet =  getSubnet(ipPool, \".\")\n\t#get ipv6pool\n\tipV6Pool, cidrV6Mask = getIppoolAndCidrMask(ipv6poolCidr)\n\t#validate ipv6pool\n\tcheckIp(ipV6Pool)\n\t#validate ipv6\n\tcheckIpType(ipV6Pool, \"ipv6\")\n", "#validate cidrMask\n\tcheckPosInteger(cidrV6Mask)\n\t#extract subnet\n\tsubnetV6 =  getSubnet(ipV6Pool, \":\")\n\t#validate host\n\tcheckIp(host)\n\t#validate verbose argument\n\tcheckVerboselog(verboselog)\n\t#validate noLinuxNl\n\tcheckNoLinuxNl(noLinuxNl)\n", "print('Arguments passed:\\n')\n\tprint('_________________________\\n')\n\tprint(f'action - {action}\\ntopology - {topology}\\nrouting - {routing}\\nippool - {ippoolCidr}\\nipv6pool - {ipv6poolCidr}\\nusername - {username}\\npassword - {password}\\nhost - {host}\\nverbose - {verboselog}\\nnoLinuxNl - {noLinuxNl}')\n\tprint('_________________________\\n')\n\t#create inventory yaml file\n\tcreateInventoryFromTemplate(subnet, username, password, host, subnetV6, noLinuxNl)\n\t#run python script\n\tif action == \"build,tear\":\n\t    runSonic(\"build\", topology, routing, \"-\"+verboselog)\n\t    print(\"Now tearing down...\\n\")\n", "    runSonic(\"tear\", topology, routing, \"-\"+verboselog)\n\telse:\n\t    runSonic(action, topology, routing, \"-\"+verboselog)\n\tprint(\"OPERATION COMPLETE...\\n\")    \n\tsys.exit(0)\n"]}
