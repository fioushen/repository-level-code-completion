{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/conftest.py", "chunked_list": ["import os\n\timport pytest\n\t@pytest.fixture\n\tdef requirements_txt_file(tmp_path):\n\t    requirements_txt_file = tmp_path / \"requirements.txt\"\n\t    requirements_txt_file.write_text(\n\t        \"\"\"\n\t        South==1.0.1 --hash=sha256:abcdefghijklmno\n\t        pycrypto>=2.6\n\t        \"\"\"\n", "    )\n\t    yield requirements_txt_file\n\t    os.remove(requirements_txt_file)\n\t@pytest.fixture\n\tdef poetry_lock_file_lt_1_5(tmp_path):\n\t    \"\"\"Poetry lock version < 1.5.\"\"\"\n\t    poetry_lock_file = tmp_path / \"poetry.lock\"\n\t    poetry_lock_file.write_text(\n\t        \"\"\"\n\t            [[package]]\n", "            name = \"charset-normalizer\"\n\t            version = \"3.0.1\"\n\t            description = \"The Real First Universal Charset Detector. Open, modern and \\\n\t                actively maintained alternative to Chardet.\"\n\t            category = \"main\"\n\t            optional = false\n\t            python-versions = \"*\"\n\t            [[package]]\n\t            name = \"flake8\"\n\t            version = \"5.0.4\"\n", "            description = \"the modular source code checker: pep8 pyflakes and co\"\n\t            category = \"dev\"\n\t            optional = false\n\t            python-versions = \">=3.6.1\"\n\t            [package.dependencies]\n\t            mccabe = \">=0.7.0,<0.8.0\"\n\t            [[package]]\n\t            name = \"mccabe\"\n\t            version = \"0.7.0\"\n\t            description = \"McCabe checker, plugin for flake8\"\n", "            category = \"dev\"\n\t            optional = false\n\t            python-versions = \">=3.6\"\n\t            [metadata]\n\t            lock-version = \"1.1\"\n\t            python-versions = \"^3.9\"\n\t            content-hash = \"d518428f67ed390edb669028a3136be9a363472e206d4dec455af35381e\"\n\t            [metadata.files]\n\t            charset-normalizer = []\n\t            flake8 = []\n", "            mccabe = []\n\t        \"\"\"\n\t    )\n\t    yield poetry_lock_file\n\t    os.remove(poetry_lock_file)\n\t@pytest.fixture\n\tdef poetry_lock_file_ge_1_5(tmp_path):\n\t    \"\"\"Poetry lock version >= 1.5.\"\"\"\n\t    poetry_lock_file = tmp_path / \"poetry.lock\"\n\t    poetry_lock_file.write_text(\n", "        \"\"\"\n\t            [[package]]\n\t            name = \"charset-normalizer\"\n\t            version = \"3.0.1\"\n\t            description = \"The Real First Universal Charset Detector. Open, modern and \\\n\t                actively maintained alternative to Chardet.\"\n\t            optional = false\n\t            python-versions = \"*\"\n\t            [[package]]\n\t            name = \"flake8\"\n", "            version = \"5.0.4\"\n\t            description = \"the modular source code checker: pep8 pyflakes and co\"\n\t            optional = false\n\t            python-versions = \">=3.6.1\"\n\t            [package.dependencies]\n\t            mccabe = \">=0.7.0,<0.8.0\"\n\t            [[package]]\n\t            name = \"mccabe\"\n\t            version = \"0.7.0\"\n\t            description = \"McCabe checker, plugin for flake8\"\n", "            optional = false\n\t            python-versions = \">=3.6\"\n\t            [metadata]\n\t            lock-version = \"1.1\"\n\t            python-versions = \"^3.9\"\n\t            content-hash = \"d518428f67ed390edb669028a3136be9a363472e206d4dec455af35381e\"\n\t            [metadata.files]\n\t            charset-normalizer = []\n\t            flake8 = []\n\t            mccabe = []\n", "        \"\"\"\n\t    )\n\t    yield poetry_lock_file\n\t    os.remove(poetry_lock_file)\n\t@pytest.fixture\n\tdef pyproject_toml_file(tmp_path):\n\t    pyproject_toml = tmp_path / \"pyproject.toml\"\n\t    pyproject_toml.write_text(\n\t        \"\"\"\n\t    [tool.poetry.dependencies]\n", "    python = \"^3.11\"\n\t    requests = \"^2.28.2\"\n\t    dparse = \"^0.6.2\"\n\t    click = \"^8.1.3\"\n\t    rich = \"^13.3.1\"\n\t    rapidfuzz = \"^2.13.7\"\n\t    regex = \"^2022.10.31\"\n\t    [tool.poetry.scripts]\n\t    twyn = \"twyn.cli:entry_point\"\n\t    [tool.twyn]\n", "    dependency_file=\"my_file.txt\"\n\t    selector_method=\"my_selector\"\n\t    logging_level=\"debug\"\n\t    allowlist=[\"boto4\", \"boto2\"]\n\t    \"\"\"\n\t    )\n\t    yield pyproject_toml\n\t    os.remove(pyproject_toml)\n"]}
{"filename": "tests/dependency_parser/__init__.py", "chunked_list": []}
{"filename": "tests/dependency_parser/test_dependency_parser.py", "chunked_list": ["from unittest.mock import patch\n\timport pytest\n\tfrom twyn.base.exceptions import TwynError\n\tfrom twyn.dependency_parser import PoetryLockParser, RequirementsTxtParser\n\tfrom twyn.dependency_parser.abstract_parser import AbstractParser\n\tfrom twyn.dependency_parser.exceptions import PathIsNotFileError, PathNotFoundError\n\tclass TestAbstractParser:\n\t    class TemporaryParser(AbstractParser):\n\t        \"\"\"Subclass of AbstractParser to test methods.\"\"\"\n\t        def parse(self) -> set[str]:\n", "            self._read()\n\t            return set()\n\t    @patch(\"twyn.dependency_parser.abstract_parser.AbstractParser.raise_for_valid_file\")\n\t    def test_file_exists_success(self, _mock_raise_for_valid_file):\n\t        parser = self.TemporaryParser(\"fake_path.txt\")\n\t        assert parser.file_exists() is True\n\t    @patch(\"twyn.dependency_parser.abstract_parser.AbstractParser.raise_for_valid_file\")\n\t    def test_file_exists_fail(self, mock_raise_for_valid_file):\n\t        def raise_twyn_error():\n\t            raise TwynError\n", "        mock_raise_for_valid_file.side_effect = raise_twyn_error\n\t        parser = self.TemporaryParser(\"fake_path.txt\")\n\t        assert parser.file_exists() is False\n\t    @patch(\"pathlib.Path.exists\")\n\t    @patch(\"pathlib.Path.is_file\")\n\t    @pytest.mark.parametrize(\n\t        \"file_exists, is_file, exception\",\n\t        [[False, False, PathNotFoundError], [True, False, PathIsNotFileError]],\n\t    )\n\t    def test_raise_for_valid_file(\n", "        self, mock_is_file, mock_exists, file_exists, is_file, exception\n\t    ):\n\t        mock_exists.return_value = file_exists\n\t        mock_is_file.return_value = is_file\n\t        with pytest.raises(exception):\n\t            self.TemporaryParser(\"fake_path\").raise_for_valid_file()\n\tclass TestRequirementsTxtParser:\n\t    def test_parse_requirements_txt_file(self, requirements_txt_file):\n\t        parser = RequirementsTxtParser(file_path=requirements_txt_file)\n\t        assert parser.parse() == {\"South\", \"pycrypto\"}\n", "class TestPoetryLockParser:\n\t    def test_parse_poetry_lock_file_lt_1_5(self, poetry_lock_file_lt_1_5):\n\t        parser = PoetryLockParser(file_path=poetry_lock_file_lt_1_5)\n\t        assert parser.parse() == {\"charset-normalizer\", \"flake8\", \"mccabe\"}\n\t    def test_parse_poetry_lock_file_ge_1_5(self, poetry_lock_file_ge_1_5):\n\t        parser = PoetryLockParser(file_path=poetry_lock_file_ge_1_5)\n\t        assert parser.parse() == {\"charset-normalizer\", \"flake8\", \"mccabe\"}\n"]}
{"filename": "tests/dependency_parser/test_dependency_selector.py", "chunked_list": ["from unittest.mock import patch\n\timport pytest\n\tfrom twyn.dependency_parser import PoetryLockParser, RequirementsTxtParser\n\tfrom twyn.dependency_parser.dependency_selector import DependencySelector\n\tfrom twyn.dependency_parser.exceptions import (\n\t    MultipleParsersError,\n\t    NoMatchingParserError,\n\t)\n\tclass TestDependencySelector:\n\t    @patch(\"twyn.dependency_parser.poetry_lock.PoetryLockParser.file_exists\")\n", "    @patch(\"twyn.dependency_parser.requirements_txt.RequirementsTxtParser.file_exists\")\n\t    @patch(\"twyn.dependency_parser.abstract_parser.AbstractParser.raise_for_valid_file\")\n\t    @patch(\n\t        \"twyn.dependency_parser.dependency_selector.DependencySelector._raise_for_selected_parsers\"\n\t    )\n\t    @pytest.mark.parametrize(\n\t        \"file_name, requirements_exists, poetry_exists, parser_obj\",\n\t        [\n\t            (None, True, False, RequirementsTxtParser),  # auto detect requirements.txt\n\t            (None, False, True, PoetryLockParser),  # auto detect poetry.lock\n", "            (\n\t                \"requirements.txt\",\n\t                None,\n\t                None,\n\t                RequirementsTxtParser,\n\t            ),  # because file is specified, we won't autocheck\n\t            (\"poetry.lock\", None, None, PoetryLockParser),\n\t            (\"/some/path/poetry.lock\", None, None, PoetryLockParser),\n\t            (\"/some/path/requirements.txt\", None, None, RequirementsTxtParser),\n\t        ],\n", "    )\n\t    def test_get_dependency_parser(\n\t        self,\n\t        _raise_for_selected_parsers,\n\t        _raise_for_valid_file,\n\t        req_exists,\n\t        poet_exists,\n\t        file_name,\n\t        requirements_exists,\n\t        poetry_exists,\n", "        parser_obj,\n\t    ):\n\t        req_exists.return_value = requirements_exists\n\t        poet_exists.return_value = poetry_exists\n\t        parser = DependencySelector(file_name).get_dependency_parser()\n\t        assert isinstance(parser, parser_obj)\n\t    @pytest.mark.parametrize(\n\t        \"exists, exception\",\n\t        [(True, MultipleParsersError), (False, NoMatchingParserError)],\n\t    )\n", "    @patch(\"twyn.dependency_parser.abstract_parser.AbstractParser.file_exists\")\n\t    def test_auto_detect_dependency_file_parser_exceptions(\n\t        self, file_exists, exists, exception\n\t    ):\n\t        file_exists.return_value = exists\n\t        with pytest.raises(exception):\n\t            DependencySelector().get_dependency_parser()\n\t    @pytest.mark.parametrize(\"file_name\", [\"unknown.txt\", \"\"])\n\t    def test_get_dependency_file_parser_unknown_file_type(self, file_name):\n\t        with pytest.raises(NoMatchingParserError):\n", "            DependencySelector(file_name).get_dependency_file_parser_from_file_name()\n"]}
{"filename": "tests/trusted_packages/test_references.py", "chunked_list": ["from contextlib import contextmanager\n\tfrom unittest.mock import Mock, call, patch\n\timport pytest\n\timport requests\n\tfrom pyparsing import Iterable, Iterator\n\tfrom twyn.trusted_packages import TopPyPiReference\n\tfrom twyn.trusted_packages.exceptions import (\n\t    EmptyPackagesListError,\n\t    InvalidJSONError,\n\t    InvalidPyPiFormatError,\n", ")\n\tfrom twyn.trusted_packages.references import AbstractPackageReference\n\t@contextmanager\n\tdef patch_pypi_requests_get(packages: Iterable[str]) -> Iterator[Mock]:\n\t    \"\"\"Patcher of `requests.get` for Top PyPi list.\n\t    Replaces call with the output you would get from downloading the top PyPi packages list.\n\t    \"\"\"\n\t    json_response = {\"rows\": [{\"project\": name} for name in packages]}\n\t    with patch(\"requests.get\") as mock_get:\n\t        mock_get.return_value.json.return_value = json_response\n", "        yield mock_get\n\tclass TestAbstractPackageReference:\n\t    class HardcodedPackageReference(AbstractPackageReference):\n\t        \"\"\"Returns always the same packages, used for testing the interface.\"\"\"\n\t        def get_packages(self) -> set[str]:\n\t            return {\"foo\", \"bar\"}\n\t    def test_get_packages(self):\n\t        assert self.HardcodedPackageReference().get_packages() == {\"foo\", \"bar\"}\n\tclass TestTopPyPiReference:\n\t    @patch_pypi_requests_get(packages=[\"boto3\", \"urllib3\", \"requests\"])\n", "    def test_get_trusted_packages(self):\n\t        top_pypi = TopPyPiReference(source=\"foo\")\n\t        assert top_pypi.get_packages() == {\"boto3\", \"urllib3\", \"requests\"}\n\t    def test__parse_no_rows(self):\n\t        data = {\"bananas\": 5}\n\t        top_pypi = TopPyPiReference(source=\"foo\")\n\t        with pytest.raises(InvalidPyPiFormatError, match=\"Invalid JSON format.\"):\n\t            top_pypi._parse(data)\n\t    def test_empty_packages_list_exception(self):\n\t        with pytest.raises(\n", "            EmptyPackagesListError,\n\t            match=\"Downloaded packages list is empty\",\n\t        ):\n\t            TopPyPiReference._parse({\"rows\": []})\n\t    def test__parse_retrieves_package_names(self):\n\t        data = {\"rows\": [{\"project\": \"boto3\"}, {\"project\": \"requests\"}]}\n\t        top_pypi = TopPyPiReference(source=\"foo\")\n\t        assert top_pypi._parse(data) == {\"boto3\", \"requests\"}\n\t    @pytest.mark.parametrize(\"source\", [\"foo.com\", \"bar.com\"])\n\t    def test_can_use_different_pypi_sources(self, source):\n", "        top_pypi = TopPyPiReference(source=source)\n\t        with patch_pypi_requests_get(packages=[\"foo\"]) as mock_get:\n\t            top_pypi.get_packages()\n\t        assert mock_get.call_args_list == [call(source)]\n\t    @patch(\"requests.get\")\n\t    def test__download_json_exception(self, mock_get):\n\t        mock_get.return_value.json.side_effect = requests.exceptions.JSONDecodeError(\n\t            \"This exception will be mapped and never shown\", \"\", 1\n\t        )\n\t        top_pypi = TopPyPiReference(source=\"foo\")\n", "        with pytest.raises(\n\t            InvalidJSONError,\n\t            match=\"Could not json decode the downloaded packages list\",\n\t        ):\n\t            top_pypi._download()\n\t    @patch_pypi_requests_get(packages=[\"boto3\", \"requests\"])\n\t    def test__download(self):\n\t        top_pypi = TopPyPiReference(source=\"foo\")\n\t        assert top_pypi._download() == {\n\t            \"rows\": [\n", "                {\"project\": \"boto3\"},\n\t                {\"project\": \"requests\"},\n\t            ]\n\t        }\n"]}
{"filename": "tests/trusted_packages/__init__.py", "chunked_list": []}
{"filename": "tests/trusted_packages/test_selectors.py", "chunked_list": ["import pytest\n\tfrom twyn.trusted_packages.exceptions import CharacterNotInMatrixError\n\tfrom twyn.trusted_packages.selectors import (\n\t    AllSimilar,\n\t    FirstLetterExact,\n\t    FirstLetterNearbyInKeyboard,\n\t)\n\tNAMES = {\"f\": {\"foo\", \"ffoo\"}, \"b\": {\"bar\"}, \"z\": {\"zoo\"}, \"d\": {\"dellows\"}}\n\tclass TestFirstLetterExact:\n\t    def test_select_similar_names(self):\n", "        selector = FirstLetterExact()\n\t        assert set(selector.select_similar_names(NAMES, \"fellows\")) == {\n\t            \"foo\",\n\t            \"ffoo\",\n\t        }\n\tclass TestFirstLetterNearbyInKeyboard:\n\t    def test_select_similar_names(self):\n\t        selector = FirstLetterNearbyInKeyboard()\n\t        assert set(selector.select_similar_names(NAMES, \"fellows\")) == {\n\t            \"foo\",\n", "            \"ffoo\",\n\t            \"dellows\",\n\t        }\n\t    def test__get_candidate_characters(self):\n\t        assert FirstLetterNearbyInKeyboard._get_candidate_characters(\"c\") == [\n\t            \"d\",\n\t            \"f\",\n\t            \"x\",\n\t            \"v\",\n\t            \"c\",\n", "        ]\n\t    def test_character_not_in_matrix(self):\n\t        with pytest.raises(\n\t            CharacterNotInMatrixError,\n\t            match=\"Character '.' not supported\",\n\t        ):\n\t            FirstLetterNearbyInKeyboard._get_candidate_characters(\".\")\n\tclass TestAllSimilar:\n\t    def test_select_similar_names(self):\n\t        selector = AllSimilar()\n", "        assert set(selector.select_similar_names(NAMES, \"fellows\")) == {\n\t            \"foo\",\n\t            \"ffoo\",\n\t            \"dellows\",\n\t            \"bar\",\n\t            \"zoo\",\n\t        }\n"]}
{"filename": "tests/trusted_packages/test_trusted_packages.py", "chunked_list": ["from unittest.mock import Mock\n\timport pytest\n\tfrom twyn.similarity.algorithm import (\n\t    EditDistance,\n\t    SimilarityThreshold,\n\t)\n\tfrom twyn.trusted_packages.selectors import (\n\t    FirstLetterExact,\n\t    FirstLetterNearbyInKeyboard,\n\t)\n", "from twyn.trusted_packages.trusted_packages import (\n\t    TrustedPackages,\n\t    TyposquatCheckResult,\n\t)\n\tclass TestTrustedPackages:\n\t    @pytest.mark.parametrize(\n\t        \"package_name, is_a_trusted_package\",\n\t        [(\"foo\", True), (\"FOO\", False), (\"asdf\", False)],\n\t    )\n\t    def test_can_check_package_is_trusted(\n", "        self, package_name: str, is_a_trusted_package: bool\n\t    ):\n\t        trusted_packages = TrustedPackages(\n\t            names={\"foo\", \"bar\"},\n\t            algorithm=Mock(),\n\t            selector=Mock(),\n\t            threshold_class=Mock(),\n\t        )\n\t        assert (package_name in trusted_packages) is is_a_trusted_package\n\t    def test_tree_representation(self):\n", "        trusted_packages = TrustedPackages(\n\t            names={\"foo\", \"ffoo\", \"bar\", \"zoo\"},\n\t            algorithm=Mock(),\n\t            selector=Mock(),\n\t            threshold_class=Mock(),\n\t        )\n\t        assert trusted_packages.names == {\n\t            \"f\": {\"foo\", \"ffoo\"},\n\t            \"b\": {\"bar\"},\n\t            \"z\": {\"zoo\"},\n", "        }\n\t    @pytest.mark.parametrize(\n\t        \"package_name, trusted_packages, selector, matches\",\n\t        [\n\t            # First letter exact\n\t            (\n\t                \"foo\",\n\t                {\"foo\"},\n\t                FirstLetterExact(),\n\t                [],\n", "            ),  # shares first letter, distance is 0, below threshold\n\t            (\n\t                \"fooo\",\n\t                {\"foo\"},\n\t                FirstLetterExact(),\n\t                [\"foo\"],\n\t            ),  # shares first letter, distance is 1, inside threshold\n\t            (\n\t                \"foooo\",\n\t                {\"foo\"},\n", "                FirstLetterExact(),\n\t                [],\n\t            ),  # shares first letter, distance is 2, above threshold\n\t            (\n\t                \"numpy\",\n\t                {\"lumpy\"},\n\t                FirstLetterExact(),\n\t                [],\n\t            ),  # distance is 1, inside threshold, but start with different letter\n\t            (\n", "                \"abcdef\",\n\t                {\"abcdefgh\"},\n\t                FirstLetterExact(),\n\t                [\"abcdefgh\"],\n\t            ),  # distance is 2, inside threshold (because it's a longer word)\n\t            # Nearby letters\n\t            (\n\t                \"numpy\",\n\t                {\"numpy\"},\n\t                FirstLetterNearbyInKeyboard(),\n", "                [],\n\t            ),  # distance is 0, outside threshold.\n\t            (\n\t                \"lumpy\",\n\t                {\"numpy\"},\n\t                FirstLetterNearbyInKeyboard(),\n\t                [],\n\t            ),  # distance is 1, inside threshold. First letter is changed but not nearby\n\t            (\n\t                \"mumpy\",\n", "                {\"numpy\"},\n\t                FirstLetterNearbyInKeyboard(),\n\t                [\"numpy\"],\n\t            ),  # distance is 1, inside threshold. First letter is changed and nearby\n\t            (\n\t                \"mumpyy\",\n\t                {\"numpy\"},\n\t                FirstLetterNearbyInKeyboard(),\n\t                [\"numpy\"],\n\t            ),  # distance is 2, inside threshold. First letter is changed and nearby\n", "            (\n\t                \"rest_framework\",\n\t                {\"erst_framweork\"},\n\t                FirstLetterNearbyInKeyboard(),\n\t                [\"erst_framweork\"],\n\t            ),  # distance is 2, inside threshold (cause it's a long word). First letter is changed and nearby.\n\t        ],\n\t    )\n\t    def test_get_typosquat(self, package_name, trusted_packages, selector, matches):\n\t        trusted_packages = TrustedPackages(\n", "            names=trusted_packages,\n\t            algorithm=EditDistance(),\n\t            selector=selector,\n\t            threshold_class=SimilarityThreshold,\n\t        )\n\t        assert trusted_packages.get_typosquat(\n\t            package_name=package_name\n\t        ) == TyposquatCheckResult(\n\t            candidate_dependency=package_name, similar_dependencies=matches\n\t        )\n"]}
{"filename": "tests/main/test_main.py", "chunked_list": ["from unittest.mock import Mock, call, patch\n\timport pytest\n\tfrom twyn.base.constants import AvailableLoggingLevels\n\tfrom twyn.dependency_parser import RequirementsTxtParser\n\tfrom twyn.main import (\n\t    check_dependencies,\n\t    get_configuration,\n\t    get_logging_level,\n\t    get_parsed_dependencies,\n\t)\n", "@pytest.mark.usefixtures(\"disable_track\")\n\tclass TestCheckDependencies:\n\t    @pytest.mark.parametrize(\n\t        \"selector_method, dependency_file, verbosity, config, expected_args, log_level\",\n\t        [\n\t            (\n\t                \"requirements.txt\",\n\t                \"first-letter\",\n\t                AvailableLoggingLevels.info,\n\t                {\n", "                    \"logging_level\": \"WARNING\",\n\t                    \"selector_method\": \"nearby-letter\",\n\t                    \"dependency_file\": \"poetry.lock\",\n\t                    \"allowlist\": {\"boto4\", \"boto2\"},\n\t                },\n\t                [\"first-letter\", \"requirements.txt\", {\"boto4\", \"boto2\"}],\n\t                AvailableLoggingLevels.info,\n\t            ),\n\t            (\n\t                None,\n", "                None,\n\t                AvailableLoggingLevels.none,\n\t                {\n\t                    \"logging_level\": \"debug\",\n\t                    \"selector_method\": \"nearby-letter\",\n\t                    \"dependency_file\": \"poetry.lock\",\n\t                    \"allowlist\": {\"boto4\", \"boto2\"},\n\t                },\n\t                [\"poetry.lock\", \"nearby-letter\", {\"boto4\", \"boto2\"}],\n\t                AvailableLoggingLevels.debug,\n", "            ),\n\t            (\n\t                None,\n\t                None,\n\t                AvailableLoggingLevels.none,\n\t                {\n\t                    \"logging_level\": None,\n\t                    \"selector_method\": None,\n\t                    \"dependency_file\": None,\n\t                    \"allowlist\": set(),\n", "                },\n\t                [None, \"all\", set()],\n\t                AvailableLoggingLevels.warning,\n\t            ),\n\t            (\n\t                None,\n\t                \"requirements.txt\",\n\t                AvailableLoggingLevels.debug,\n\t                {\n\t                    \"logging_level\": \"INFO\",\n", "                    \"selector_method\": None,\n\t                    \"dependency_file\": \"poetry.lock\",\n\t                    \"allowlist\": set(),\n\t                },\n\t                [\"requirements.txt\", \"all\", set()],\n\t                AvailableLoggingLevels.debug,\n\t            ),\n\t        ],\n\t    )\n\t    @patch(\"twyn.main.set_logging_level\")\n", "    def test_options_priorities_assignation(\n\t        self,\n\t        mock_logging_level,\n\t        selector_method,\n\t        dependency_file,\n\t        verbosity,\n\t        config,\n\t        expected_args,\n\t        log_level,\n\t    ):\n", "        \"\"\"\n\t        Checks that the configuration values are picked accordingly to the priority they have.\n\t        From more relevant to less:\n\t        1. command line\n\t        2. config file\n\t        3. default values\n\t        \"\"\"\n\t        with patch(\"twyn.main.ConfigHandler\", return_value=Mock(**config)):\n\t            config = get_configuration(\n\t                dependency_file=dependency_file,\n", "                config_file=None,\n\t                selector_method=selector_method,\n\t                verbosity=verbosity,\n\t            )\n\t        assert config.dependency_file == expected_args[0]\n\t        assert config.selector_method == expected_args[1]\n\t        assert config.allowlist == expected_args[2]\n\t        assert mock_logging_level.call_args == call(log_level)\n\t    @pytest.mark.parametrize(\n\t        \"passed_logging_level, config, logging_level\",\n", "        [\n\t            [AvailableLoggingLevels.none, None, AvailableLoggingLevels.warning],\n\t            [AvailableLoggingLevels.info, None, AvailableLoggingLevels.info],\n\t            [AvailableLoggingLevels.debug, None, AvailableLoggingLevels.debug],\n\t            [AvailableLoggingLevels.none, \"debug\", AvailableLoggingLevels.debug],\n\t        ],\n\t    )\n\t    def test_logging_level(self, passed_logging_level, config, logging_level):\n\t        log_level = get_logging_level(\n\t            logging_level=passed_logging_level,\n", "            config_logging_level=config,\n\t        )\n\t        assert log_level == logging_level\n\t    @pytest.mark.parametrize(\n\t        \"package_name\",\n\t        (\n\t            \"my.package\",\n\t            \"my-package\",\n\t            \"my_package\",\n\t            \"My.Package\",\n", "        ),\n\t    )\n\t    @patch(\"twyn.main.TopPyPiReference\")\n\t    @patch(\"twyn.main.get_parsed_dependencies\")\n\t    def test_check_dependencies_detects_typosquats(\n\t        self, mock_get_parsed_dependencies, mock_top_pypi_reference, package_name\n\t    ):\n\t        mock_top_pypi_reference.return_value.get_packages.return_value = {\"mypackage\"}\n\t        mock_get_parsed_dependencies.return_value = {package_name}\n\t        error = check_dependencies(\n", "            config_file=None,\n\t            dependency_file=None,\n\t            selector_method=\"first-letter\",\n\t        )\n\t        assert error is True\n\t    @pytest.mark.parametrize(\n\t        \"package_name\",\n\t        (\n\t            \"my.package\",\n\t            \"my-package\",\n", "            \"my_package\",\n\t            \"My.Package\",\n\t        ),\n\t    )\n\t    @patch(\"twyn.main.TopPyPiReference\")\n\t    @patch(\"twyn.main.get_parsed_dependencies\")\n\t    def test_check_dependencies_ignores_package_in_allowlist(\n\t        self, mock_get_parsed_dependencies, mock_top_pypi_reference, package_name\n\t    ):\n\t        mock_top_pypi_reference.return_value.get_packages.return_value = {\"mypackage\"}\n", "        mock_get_parsed_dependencies.return_value = {package_name}\n\t        m_config = Mock(\n\t            allowlist={package_name},\n\t            dependency_file=None,\n\t            selector_method=\"first-letter\",\n\t        )\n\t        with patch(\"twyn.main.get_configuration\", return_value=m_config):\n\t            error = check_dependencies(\n\t                config_file=None,\n\t                dependency_file=None,\n", "                selector_method=\"first-letter\",\n\t            )\n\t        assert error is False\n\t    @pytest.mark.parametrize(\n\t        \"package_name\", (\"my.package\", \"my-package\", \"my_package\", \"My.Package\")\n\t    )\n\t    @patch(\"twyn.main.TopPyPiReference\")\n\t    @patch(\"twyn.main.get_parsed_dependencies\")\n\t    def test_check_dependencies_does_not_error_on_same_package(\n\t        self, mock_get_parsed_dependencies, mock_top_pypi_reference, package_name\n", "    ):\n\t        mock_top_pypi_reference.return_value.get_packages.return_value = {\"my-package\"}\n\t        mock_get_parsed_dependencies.return_value = {package_name}\n\t        error = check_dependencies(\n\t            config_file=None,\n\t            dependency_file=None,\n\t            selector_method=\"first-letter\",\n\t        )\n\t        assert error is False\n\t    @patch(\n", "        \"twyn.dependency_parser.dependency_selector.DependencySelector.get_dependency_parser\"\n\t    )\n\t    @patch(\"twyn.dependency_parser.requirements_txt.RequirementsTxtParser.parse\")\n\t    def test_get_parsed_dependencies(self, mock_parse, mock_get_dependency_parser):\n\t        mock_get_dependency_parser.return_value = RequirementsTxtParser()\n\t        mock_parse.return_value = {\"boto3\"}\n\t        assert get_parsed_dependencies() == {\"boto3\"}\n"]}
{"filename": "tests/main/__init__.py", "chunked_list": []}
{"filename": "tests/main/test_cli.py", "chunked_list": ["from unittest.mock import call, patch\n\timport pytest\n\tfrom click.testing import CliRunner\n\tfrom twyn import cli\n\tfrom twyn.base.constants import AvailableLoggingLevels\n\tclass TestCli:\n\t    @patch(\"twyn.core.config_handler.ConfigHandler.add_package_to_allowlist\")\n\t    def test_allowlist_add_package_to_allowlist(self, mock_allowlist_add):\n\t        runner = CliRunner()\n\t        runner.invoke(\n", "            cli.add,\n\t            [\"requests\"],\n\t        )\n\t        assert mock_allowlist_add.call_args == call(\"requests\")\n\t    @patch(\"twyn.core.config_handler.ConfigHandler.remove_package_from_allowlist\")\n\t    def test_allowlist_remove(self, mock_allowlist_add):\n\t        runner = CliRunner()\n\t        runner.invoke(\n\t            cli.remove,\n\t            [\"requests\"],\n", "        )\n\t        assert mock_allowlist_add.call_args == call(\"requests\")\n\t    @patch(\"twyn.cli.check_dependencies\")\n\t    def test_click_arguments(self, mock_check_dependencies):\n\t        runner = CliRunner()\n\t        runner.invoke(\n\t            cli.run,\n\t            [\n\t                \"--config\",\n\t                \"my-config\",\n", "                \"--selector-method\",\n\t                \"first-letter\",\n\t                \"--dependency-file\",\n\t                \"requirements.txt\",\n\t                \"-vv\",\n\t            ],\n\t        )\n\t        assert mock_check_dependencies.call_args_list == [\n\t            call(\n\t                config_file=\"my-config\",\n", "                dependency_file=\"requirements.txt\",\n\t                selector_method=\"first-letter\",\n\t                verbosity=AvailableLoggingLevels.debug,\n\t            )\n\t        ]\n\t    @patch(\"twyn.cli.check_dependencies\")\n\t    def test_click_arguments_default(self, mock_check_dependencies):\n\t        runner = CliRunner()\n\t        runner.invoke(cli.run)\n\t        assert mock_check_dependencies.call_args_list == [\n", "            call(\n\t                config_file=None,\n\t                dependency_file=None,\n\t                selector_method=None,\n\t                verbosity=AvailableLoggingLevels.none,\n\t            )\n\t        ]\n\t    def test_only_one_verbosity_level_is_allowed(self):\n\t        runner = CliRunner()\n\t        with pytest.raises(\n", "            ValueError,\n\t            match=\"Only one verbosity level is allowed. Choose either -v or -vv.\",\n\t        ):\n\t            runner.invoke(cli.run, [\"-v\", \"-vv\"], catch_exceptions=False)\n"]}
{"filename": "tests/main/conftest.py", "chunked_list": ["from unittest.mock import patch\n\timport pytest\n\t@pytest.fixture(scope=\"module\")\n\tdef disable_track():\n\t    \"\"\"Disables the track UI for running tests.\"\"\"\n\t    with patch(\"twyn.main.track\") as m_track:\n\t        m_track.side_effect = lambda iterable, description: iterable\n\t        yield\n"]}
{"filename": "tests/core/__init__.py", "chunked_list": []}
{"filename": "tests/core/test_config_handler.py", "chunked_list": ["from unittest.mock import patch\n\timport pytest\n\tfrom twyn.core.config_handler import ConfigHandler\n\tfrom twyn.core.exceptions import (\n\t    AllowlistPackageAlreadyExistsError,\n\t    AllowlistPackageDoesNotExistError,\n\t)\n\tclass TestConfig:\n\t    def throw_exception(self):\n\t        raise FileNotFoundError\n", "    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_file_pointer\")\n\t    def test_enforce_file_error(self, mock_is_file):\n\t        mock_is_file.side_effect = self.throw_exception\n\t        with pytest.raises(FileNotFoundError):\n\t            ConfigHandler(enforce_file=True)\n\t    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_file_pointer\")\n\t    def test_no_enforce_file_on_non_existent_file(self, mock_is_file):\n\t        mock_is_file.side_effect = self.throw_exception\n\t        config = ConfigHandler(enforce_file=False)\n\t        assert config.dependency_file is None\n", "        assert config.selector_method is None\n\t        assert config.logging_level is None\n\t        assert config.allowlist == set()\n\t    def test_config_raises_for_unknown_file(self):\n\t        with pytest.raises(FileNotFoundError):\n\t            ConfigHandler(file_path=\"non-existent-file.toml\")\n\t    def test_read_config_values(self, pyproject_toml_file):\n\t        config = ConfigHandler(file_path=pyproject_toml_file)\n\t        assert config.dependency_file == \"my_file.txt\"\n\t        assert config.selector_method == \"my_selector\"\n", "        assert config.logging_level == \"debug\"\n\t        assert config.allowlist == {\"boto4\", \"boto2\"}\n\t    def test_get_toml_as_dict(self, pyproject_toml_file):\n\t        config = ConfigHandler(file_path=pyproject_toml_file)\n\t        assert config._get_toml_as_dict() == {\n\t            \"tool\": {\n\t                \"poetry\": {\n\t                    \"dependencies\": {\n\t                        \"python\": \"^3.11\",\n\t                        \"requests\": \"^2.28.2\",\n", "                        \"dparse\": \"^0.6.2\",\n\t                        \"click\": \"^8.1.3\",\n\t                        \"rich\": \"^13.3.1\",\n\t                        \"rapidfuzz\": \"^2.13.7\",\n\t                        \"regex\": \"^2022.10.31\",\n\t                    },\n\t                    \"scripts\": {\"twyn\": \"twyn.cli:entry_point\"},\n\t                },\n\t                \"twyn\": {\n\t                    \"dependency_file\": \"my_file.txt\",\n", "                    \"selector_method\": \"my_selector\",\n\t                    \"logging_level\": \"debug\",\n\t                    \"allowlist\": [\"boto4\", \"boto2\"],\n\t                },\n\t            }\n\t        }\n\t    def test_write_toml(self, pyproject_toml_file):\n\t        config = ConfigHandler(file_path=pyproject_toml_file)\n\t        config._toml[\"tool\"][\"twyn\"] = {}\n\t        config._toml[\"tool\"][\"twyn\"][\"allowlist\"] = []\n", "        config._write_toml()\n\t        assert config._get_toml_as_dict() == {\n\t            \"tool\": {\n\t                \"poetry\": {\n\t                    \"dependencies\": {\n\t                        \"python\": \"^3.11\",\n\t                        \"requests\": \"^2.28.2\",\n\t                        \"dparse\": \"^0.6.2\",\n\t                        \"click\": \"^8.1.3\",\n\t                        \"rich\": \"^13.3.1\",\n", "                        \"rapidfuzz\": \"^2.13.7\",\n\t                        \"regex\": \"^2022.10.31\",\n\t                    },\n\t                    \"scripts\": {\"twyn\": \"twyn.cli:entry_point\"},\n\t                },\n\t                \"twyn\": {\"allowlist\": []},\n\t            }\n\t        }\n\tclass TestAllowlistConfigHandler:\n\t    @patch(\"twyn.core.config_handler.ConfigHandler._write_toml\")\n", "    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_as_dict\")\n\t    def test_allowlist_add(self, mock_toml, mock_write_toml):\n\t        mock_toml.return_value = {}\n\t        config = ConfigHandler()\n\t        assert config._toml == {}\n\t        config.add_package_to_allowlist(\"mypackage\")\n\t        assert config._toml == {\"tool\": {\"twyn\": {\"allowlist\": [\"mypackage\"]}}}\n\t        assert mock_write_toml.called\n\t    @patch(\"twyn.core.config_handler.ConfigHandler._write_toml\")\n\t    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_as_dict\")\n", "    def test_allowlist_add_duplicate_error(self, mock_toml, mock_write_toml):\n\t        mock_toml.return_value = {\"tool\": {\"twyn\": {\"allowlist\": [\"mypackage\"]}}}\n\t        config = ConfigHandler()\n\t        with pytest.raises(\n\t            AllowlistPackageAlreadyExistsError,\n\t            match=\"Package 'mypackage' is already present in the allowlist. Skipping.\",\n\t        ):\n\t            config.add_package_to_allowlist(\"mypackage\")\n\t        assert not mock_write_toml.called\n\t    @pytest.mark.parametrize(\n", "        \"toml_content, expected\",\n\t        [\n\t            ({}, {\"tool\": {\"twyn\": {\"allowlist\": []}}}),\n\t            (\n\t                {\"tool\": {\"ruff\": {}}},\n\t                {\"tool\": {\"twyn\": {\"allowlist\": []}, \"ruff\": {}}},\n\t            ),\n\t            ({\"tool\": {\"twyn\": {}}}, {\"tool\": {\"twyn\": {\"allowlist\": []}}}),\n\t            (\n\t                {\"tool\": {\"twyn\": {\"allowlist\": []}}},\n", "                {\"tool\": {\"twyn\": {\"allowlist\": []}}},\n\t            ),\n\t            (\n\t                {\"tool\": {\"twyn\": {\"allowlist\": [\"requests\"]}}},\n\t                {\"tool\": {\"twyn\": {\"allowlist\": [\"requests\"]}}},\n\t            ),\n\t        ],\n\t    )\n\t    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_as_dict\")\n\t    def test_check_allowlist_integrity(self, mock_toml, toml_content, expected):\n", "        mock_toml.return_value = toml_content\n\t        config = ConfigHandler()\n\t        config._create_allowlist_in_toml_if_not_exists()\n\t        assert config._toml == expected\n\t    @patch(\"twyn.core.config_handler.ConfigHandler._write_toml\")\n\t    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_as_dict\")\n\t    def test_allowlist_remove(self, mock_toml, mock_write_toml):\n\t        mock_toml.return_value = {\"tool\": {\"twyn\": {\"allowlist\": [\"mypackage\"]}}}\n\t        config = ConfigHandler()\n\t        config.remove_package_from_allowlist(\"mypackage\")\n", "        assert config._toml == {\"tool\": {\"twyn\": {\"allowlist\": []}}}\n\t        assert mock_write_toml.called\n\t    @patch(\"twyn.core.config_handler.ConfigHandler._write_toml\")\n\t    @patch(\"twyn.core.config_handler.ConfigHandler._get_toml_as_dict\")\n\t    def test_allowlist_remove_non_existent_package_error(\n\t        self, mock_toml, mock_write_toml\n\t    ):\n\t        mock_toml.return_value = {\"tool\": {\"twyn\": {\"allowlist\": [\"mypackage\"]}}}\n\t        config = ConfigHandler()\n\t        with pytest.raises(\n", "            AllowlistPackageDoesNotExistError,\n\t            match=\"Package 'mypackage2' is not present in the allowlist. Skipping.\",\n\t        ):\n\t            config.remove_package_from_allowlist(\"mypackage2\")\n\t        assert not mock_write_toml.called\n"]}
{"filename": "tests/similarity/test_algorithm.py", "chunked_list": ["from typing import Union\n\timport pytest\n\tfrom twyn.similarity.algorithm import (\n\t    AbstractSimilarityAlgorithm,\n\t    EditDistance,\n\t    SimilarityThreshold,\n\t)\n\tfrom twyn.similarity.exceptions import DistanceAlgorithmError, ThresholdError\n\tclass TestAbstractSimilarityAlgorithm:\n\t    class DifferentLettersSimilarityAlgorithm(AbstractSimilarityAlgorithm):\n", "        def _run_algorithm(\n\t            self, first_sequence: str, second_sequence: str\n\t        ) -> Union[float, int]:\n\t            first_letters = set(first_sequence)\n\t            second_letters = set(second_sequence)\n\t            return len(first_letters.symmetric_difference(second_letters))\n\t    @pytest.mark.parametrize(\n\t        \"word1, word2, expected_distance\",\n\t        [\n\t            (\"foo\", \"bar\", 5),\n", "            (\"foo\", \"foo\", 0),\n\t            (\"foo\", \"fooo\", 0),\n\t            (\"foo\", \"boo\", 2),\n\t        ],\n\t    )\n\t    def test_distance_between_words(self, word1, word2, expected_distance):\n\t        algorithm = self.DifferentLettersSimilarityAlgorithm()\n\t        assert algorithm.get_distance(word1, word2) == expected_distance\n\tclass TestEditDistance:\n\t    @pytest.mark.parametrize(\n", "        \"word1, word2, expected_distance\",\n\t        [\n\t            (\"requests\", \"requests\", 0),\n\t            (\"requests\", \"requets\", 1),\n\t            (\"reque\", \"requests\", 3),\n\t        ],\n\t    )\n\t    def test_distance_between_words(self, word1, word2, expected_distance):\n\t        algorithm = EditDistance()\n\t        assert algorithm.get_distance(word1, word2) == expected_distance\n", "class TestExceptions:\n\t    class ExceptionAlgorithm(AbstractSimilarityAlgorithm):\n\t        def _run_algorithm(\n\t            self, first_sequence: str, second_sequence: str\n\t        ) -> Union[float, int]:\n\t            raise KeyError\n\t    def test_exception(self):\n\t        with pytest.raises(\n\t            DistanceAlgorithmError,\n\t            match=\"Exception raised while running distance algorithm\",\n", "        ):\n\t            self.ExceptionAlgorithm().get_distance(\"\", \"\")\n\tclass TestSimilarityThreshold:\n\t    def test_invalid_threshold(self):\n\t        with pytest.raises(ThresholdError):\n\t            SimilarityThreshold(max=0)\n"]}
{"filename": "tests/similarity/__init__.py", "chunked_list": []}
{"filename": "src/twyn/main.py", "chunked_list": ["import logging\n\timport re\n\tfrom typing import Optional\n\tfrom rich.logging import RichHandler\n\tfrom rich.progress import track\n\tfrom twyn.base.constants import (\n\t    DEFAULT_SELECTOR_METHOD,\n\t    SELECTOR_METHOD_MAPPING,\n\t    AvailableLoggingLevels,\n\t)\n", "from twyn.core.config_handler import ConfigHandler\n\tfrom twyn.dependency_parser.dependency_selector import DependencySelector\n\tfrom twyn.similarity.algorithm import EditDistance, SimilarityThreshold\n\tfrom twyn.trusted_packages import TopPyPiReference\n\tfrom twyn.trusted_packages.selectors import AbstractSelector\n\tfrom twyn.trusted_packages.trusted_packages import (\n\t    TrustedPackages,\n\t    TyposquatCheckResult,\n\t)\n\tlogging.basicConfig(\n", "    format=\"%(message)s\",\n\t    datefmt=\"[%X]\",\n\t    handlers=[RichHandler(rich_tracebacks=True, show_path=False)],\n\t)\n\tlogger = logging.getLogger()\n\tdef check_dependencies(\n\t    config_file: Optional[str],\n\t    dependency_file: str,\n\t    selector_method: str,\n\t    verbosity: AvailableLoggingLevels = AvailableLoggingLevels.none,\n", ") -> bool:\n\t    \"\"\"Check if dependencies could be typosquats.\"\"\"\n\t    config = get_configuration(config_file, dependency_file, selector_method, verbosity)\n\t    trusted_packages = TrustedPackages(\n\t        names=TopPyPiReference().get_packages(),\n\t        algorithm=EditDistance(),\n\t        selector=get_candidate_selector(config.selector_method),\n\t        threshold_class=SimilarityThreshold,\n\t    )\n\t    normalized_allowlist_packages = normalize_packages(config.allowlist)\n", "    dependencies = get_parsed_dependencies(config.dependency_file)\n\t    normalized_dependencies = normalize_packages(dependencies)\n\t    errors: list[TyposquatCheckResult] = []\n\t    for dependency in track(normalized_dependencies, description=\"Processing...\"):\n\t        if dependency in normalized_allowlist_packages:\n\t            logger.info(f\"Dependency {dependency} is in the allowlist\")\n\t            continue\n\t        logger.info(f\"Analyzing {dependency}\")\n\t        if dependency not in trusted_packages and (\n\t            typosquat_results := trusted_packages.get_typosquat(dependency)\n", "        ):\n\t            errors.append(typosquat_results)\n\t    for possible_typosquats in errors:\n\t        logger.error(\n\t            f\"Possible typosquat detected: `{possible_typosquats.candidate_dependency}`, \"\n\t            f\"did you mean any of [{', '.join(possible_typosquats.similar_dependencies)}]?\"\n\t        )\n\t    return bool(errors)\n\tdef get_configuration(\n\t    config_file: Optional[str],\n", "    dependency_file: str,\n\t    selector_method: str,\n\t    verbosity: AvailableLoggingLevels,\n\t) -> ConfigHandler:\n\t    \"\"\"Read configuration and return configuration object.\n\t    Selects the appropriate values based on priorities between those in the file, and those directly provided.\n\t    \"\"\"\n\t    # Read config from file\n\t    config = ConfigHandler(file_path=config_file, enforce_file=False)\n\t    # Set logging level according to priority order\n", "    logging_level: AvailableLoggingLevels = get_logging_level(\n\t        logging_level=verbosity,\n\t        config_logging_level=config.logging_level,\n\t    )\n\t    set_logging_level(logging_level)\n\t    config.logging_level = logging_level.value\n\t    # Set selector method according to priority order\n\t    config.selector_method = (\n\t        selector_method or config.selector_method or DEFAULT_SELECTOR_METHOD\n\t    )\n", "    # Set dependency file according to priority order\n\t    config.dependency_file = dependency_file or config.dependency_file or None\n\t    return config\n\tdef get_logging_level(\n\t    logging_level: AvailableLoggingLevels,\n\t    config_logging_level: Optional[str],\n\t) -> AvailableLoggingLevels:\n\t    \"\"\"Return the appropriate logging level, considering that the one in config has less priority than the one passed directly.\"\"\"\n\t    if logging_level is AvailableLoggingLevels.none:\n\t        if config_logging_level:\n", "            return AvailableLoggingLevels[config_logging_level.lower()]\n\t        else:\n\t            # default logging level\n\t            return AvailableLoggingLevels.warning\n\t    return logging_level\n\tdef set_logging_level(logging_level: AvailableLoggingLevels) -> None:\n\t    logger.setLevel(logging_level.value)\n\t    logger.debug(f\"Logging level: {logging_level.value}\")\n\tdef get_candidate_selector(selector_method_name: Optional[str]) -> AbstractSelector:\n\t    logger.debug(f\"Selector method received {selector_method_name}\")\n", "    selector_method_name = selector_method_name or DEFAULT_SELECTOR_METHOD\n\t    selector_method = SELECTOR_METHOD_MAPPING[selector_method_name]()\n\t    logger.debug(f\"Instantiated {selector_method} selector\")\n\t    return selector_method\n\tdef get_parsed_dependencies(dependency_file: Optional[str] = None) -> set[str]:\n\t    dependency_parser = DependencySelector(dependency_file).get_dependency_parser()\n\t    dependencies = dependency_parser.parse()\n\t    logger.debug(\"Successfully parsed local dependencies file.\")\n\t    return dependencies\n\tdef normalize_packages(packages: set[str]) -> set[str]:\n", "    \"\"\"Normalize dependency names according to PyPi https://packaging.python.org/en/latest/specifications/name-normalization/.\"\"\"\n\t    return {re.sub(r\"[-_.]+\", \"-\", name).lower() for name in packages}\n"]}
{"filename": "src/twyn/__init__.py", "chunked_list": []}
{"filename": "src/twyn/__version__.py", "chunked_list": ["from importlib import metadata\n\t__version__: str = metadata.version(\"twyn\")\n"]}
{"filename": "src/twyn/cli.py", "chunked_list": ["import sys\n\timport click\n\tfrom twyn.__version__ import __version__\n\tfrom twyn.base.constants import (\n\t    DEPENDENCY_FILE_MAPPING,\n\t    SELECTOR_METHOD_MAPPING,\n\t    AvailableLoggingLevels,\n\t)\n\tfrom twyn.core.config_handler import ConfigHandler\n\tfrom twyn.main import check_dependencies\n", "@click.group()\n\t@click.version_option(__version__, \"--version\")\n\tdef entry_point() -> None:\n\t    pass\n\t@entry_point.command()\n\t@click.option(\"--config\", type=click.STRING)\n\t@click.option(\n\t    \"--dependency-file\",\n\t    type=click.Choice(list(DEPENDENCY_FILE_MAPPING.keys())),\n\t    help=(\n", "        \"Dependency file to analyze. By default, twyn will search in the current directory \"\n\t        \"for supported files, but this option will override that behavior.\"\n\t    ),\n\t)\n\t@click.option(\n\t    \"--selector-method\",\n\t    type=click.Choice(list(SELECTOR_METHOD_MAPPING.keys())),\n\t    help=(\n\t        \"Which method twyn should use to select possible typosquats. \"\n\t        \"`first-letter` only compares dependencies that share the first letter, \"\n", "        \"while `nearby-letter` compares against dependencies whose first letter \"\n\t        \"is nearby in an English keyboard. `all` compares the given dependencies \"\n\t        \"against all of those in the reference.\"\n\t    ),\n\t)\n\t@click.option(\n\t    \"-v\",\n\t    default=False,\n\t    is_flag=True,\n\t)\n", "@click.option(\n\t    \"-vv\",\n\t    default=False,\n\t    is_flag=True,\n\t)\n\tdef run(\n\t    config: str,\n\t    dependency_file: str,\n\t    selector_method: str,\n\t    v: bool,\n", "    vv: bool,\n\t) -> int:\n\t    if v and vv:\n\t        raise ValueError(\n\t            \"Only one verbosity level is allowed. Choose either -v or -vv.\"\n\t        )\n\t    if v:\n\t        verbosity = AvailableLoggingLevels.info\n\t    elif vv:\n\t        verbosity = AvailableLoggingLevels.debug\n", "    else:\n\t        verbosity = AvailableLoggingLevels.none\n\t    return int(\n\t        check_dependencies(\n\t            config_file=config,\n\t            dependency_file=dependency_file,\n\t            selector_method=selector_method,\n\t            verbosity=verbosity,\n\t        )\n\t    )\n", "@entry_point.group()\n\tdef allowlist() -> None:\n\t    pass\n\t@allowlist.command()\n\t@click.argument(\"package_name\")\n\tdef add(package_name: str) -> None:\n\t    ConfigHandler().add_package_to_allowlist(package_name)\n\t@allowlist.command()\n\t@click.argument(\"package_name\")\n\tdef remove(package_name: str) -> None:\n", "    ConfigHandler().remove_package_from_allowlist(package_name)\n\tif __name__ == \"__main__\":\n\t    sys.exit(entry_point())\n"]}
{"filename": "src/twyn/dependency_parser/poetry_lock.py", "chunked_list": ["\"\"\"Parser for poetry.lock dependencies.\"\"\"\n\timport tomllib\n\tfrom dparse import filetypes\n\tfrom twyn.dependency_parser.abstract_parser import AbstractParser\n\tclass PoetryLockParser(AbstractParser):\n\t    \"\"\"Parser for poetry.lock.\"\"\"\n\t    def __init__(self, file_path: str = filetypes.poetry_lock) -> None:\n\t        super().__init__(file_path)\n\t    def parse(self) -> set[str]:\n\t        \"\"\"Parse poetry.lock dependencies into set of dependency names.\"\"\"\n", "        data = tomllib.loads(self._read())\n\t        return {dependency[\"name\"] for dependency in data[\"package\"]}\n"]}
{"filename": "src/twyn/dependency_parser/requirements_txt.py", "chunked_list": ["\"\"\"Parser for requirements.txt dependencies.\"\"\"\n\tfrom dparse import filetypes, parse\n\tfrom dparse.dependencies import Dependency, DependencyFile\n\tfrom twyn.dependency_parser.abstract_parser import AbstractParser\n\tclass RequirementsTxtParser(AbstractParser):\n\t    \"\"\"Parser for requirements.txt dependencies.\"\"\"\n\t    def __init__(self, file_path: str = filetypes.requirements_txt) -> None:\n\t        super().__init__(file_path)\n\t    def parse(self) -> set[str]:\n\t        \"\"\"Parse requirements.txt dependencies into set of dependency names.\"\"\"\n", "        dependency_file: DependencyFile = parse(\n\t            self._read(), file_type=filetypes.requirements_txt\n\t        )\n\t        dependencies: list[Dependency] = dependency_file.resolved_dependencies\n\t        return {dependency.name for dependency in dependencies}\n"]}
{"filename": "src/twyn/dependency_parser/dependency_selector.py", "chunked_list": ["import logging\n\tfrom typing import Optional\n\tfrom twyn.base.constants import DEPENDENCY_FILE_MAPPING\n\tfrom twyn.dependency_parser.abstract_parser import AbstractParser\n\tfrom twyn.dependency_parser.exceptions import (\n\t    MultipleParsersError,\n\t    NoMatchingParserError,\n\t)\n\tlogger = logging.getLogger()\n\tclass DependencySelector:\n", "    def __init__(self, dependency_file: Optional[str] = None) -> None:\n\t        self.dependency_file = dependency_file or \"\"\n\t    @staticmethod\n\t    def _raise_for_selected_parsers(parsers) -> None:\n\t        if len(parsers) > 1:\n\t            raise MultipleParsersError\n\t        if not parsers:\n\t            raise NoMatchingParserError\n\t    def auto_detect_dependency_file_parser(self) -> type[AbstractParser]:\n\t        parsers = [\n", "            dependency_parser\n\t            for dependency_parser in DEPENDENCY_FILE_MAPPING.values()\n\t            if dependency_parser().file_exists()\n\t        ]\n\t        self._raise_for_selected_parsers(parsers)\n\t        logger.debug(\"Dependencies file found\")\n\t        return parsers[0]\n\t    def get_dependency_file_parser_from_file_name(\n\t        self,\n\t    ) -> type[AbstractParser]:\n", "        parsers = []\n\t        for known_dependency_file_name in DEPENDENCY_FILE_MAPPING:\n\t            if self.dependency_file.endswith(known_dependency_file_name):\n\t                parsers.append(DEPENDENCY_FILE_MAPPING[known_dependency_file_name])\n\t        self._raise_for_selected_parsers(parsers)\n\t        return parsers[0]\n\t    def get_dependency_parser(self) -> AbstractParser:\n\t        logger.debug(f\"Dependency file: {self.dependency_file}\")\n\t        if self.dependency_file:\n\t            logger.debug(\"Dependency file provided. Assigning a parser.\")\n", "            dependency_file_parser = self.get_dependency_file_parser_from_file_name()\n\t        else:\n\t            logger.debug(\"No dependency file provided. Attempting to locate one.\")\n\t            dependency_file_parser = self.auto_detect_dependency_file_parser()\n\t        file_parser = dependency_file_parser()\n\t        logger.debug(f\"Assigned {file_parser} parser for local dependencies file.\")\n\t        file_parser.raise_for_valid_file()\n\t        return file_parser\n"]}
{"filename": "src/twyn/dependency_parser/__init__.py", "chunked_list": ["\"\"\"Dependency parsers.\"\"\"\n\tfrom twyn.dependency_parser.poetry_lock import PoetryLockParser\n\tfrom twyn.dependency_parser.requirements_txt import RequirementsTxtParser\n\t__all__ = [\"RequirementsTxtParser\", \"PoetryLockParser\"]\n"]}
{"filename": "src/twyn/dependency_parser/exceptions.py", "chunked_list": ["from twyn.base.exceptions import TwynError\n\tclass PathIsNotFileError(TwynError):\n\t    message = \"Specified dependencies path is not a file\"\n\tclass PathNotFoundError(TwynError, FileNotFoundError):\n\t    message = \"Specified dependencies file path does not exist\"\n\tclass NoMatchingParserError(TwynError):\n\t    message = \"Could not assign a dependency file parser. Please specify it with --dependency-file\"\n\tclass MultipleParsersError(TwynError):\n\t    message = (\n\t        \"Can't auto detect dependencies file to parse. More than one format was found.\"\n", "    )\n"]}
{"filename": "src/twyn/dependency_parser/abstract_parser.py", "chunked_list": ["import logging\n\timport os\n\tfrom abc import ABC, abstractmethod\n\tfrom pathlib import Path\n\tfrom twyn.base.exceptions import TwynError\n\tfrom twyn.dependency_parser.exceptions import (\n\t    PathIsNotFileError,\n\t    PathNotFoundError,\n\t)\n\tlogger = logging.getLogger()\n", "class AbstractParser(ABC):\n\t    def __init__(self, file_path: str = \"\") -> None:\n\t        self.file_path = Path(os.path.abspath(os.path.join(os.getcwd(), file_path)))\n\t    def __str__(self):\n\t        return self.__class__.__name__\n\t    def _read(self) -> str:\n\t        content = self.file_path.read_text()\n\t        logger.debug(\"Successfully read content from local dependencies file\")\n\t        return content\n\t    def file_exists(self) -> bool:\n", "        try:\n\t            self.raise_for_valid_file()\n\t        except TwynError:\n\t            return False\n\t        return True\n\t    def raise_for_valid_file(self) -> None:\n\t        if not self.file_path.exists():\n\t            raise PathNotFoundError\n\t        if not self.file_path.is_file():\n\t            raise PathIsNotFileError\n", "    @abstractmethod\n\t    def parse(self) -> set[str]:\n\t        \"\"\"\n\t        Parse text into dependencies set.\n\t        Parse the file's contents into a set of dependency names (type: str).\n\t        All data other than the dependency names (e.g. whether a dependency is\n\t        a dev dependency or main dependency; version constraints) is omitted.\n\t        \"\"\"\n"]}
{"filename": "src/twyn/trusted_packages/trusted_packages.py", "chunked_list": ["from collections import defaultdict\n\tfrom dataclasses import dataclass, field\n\tfrom typing import Any, Set\n\tfrom twyn.similarity.algorithm import (\n\t    AbstractSimilarityAlgorithm,\n\t    SimilarityThreshold,\n\t)\n\tfrom twyn.trusted_packages.selectors import AbstractSelector\n\t_PackageNames = defaultdict[str, set[str]]\n\t@dataclass\n", "class TyposquatCheckResult:\n\t    \"\"\"Represents the result of analyzing a dependency for a possible typosquat.\"\"\"\n\t    candidate_dependency: str\n\t    similar_dependencies: list[str] = field(default_factory=list)\n\t    def __bool__(self) -> bool:\n\t        return bool(self.similar_dependencies)\n\t    def add(self, similar_name: str) -> None:\n\t        \"\"\"Add a similar dependency to this typosquat check result.\"\"\"\n\t        self.similar_dependencies.append(similar_name)\n\tclass TrustedPackages:\n", "    \"\"\"Representation of packages that can be trusted.\"\"\"\n\t    def __init__(\n\t        self,\n\t        names: Set[str],\n\t        algorithm: AbstractSimilarityAlgorithm,\n\t        selector: AbstractSelector,\n\t        threshold_class: type[SimilarityThreshold],\n\t    ) -> None:\n\t        self.names: _PackageNames = self._create_names_dictionary(names)\n\t        self.threshold_class = threshold_class\n", "        self.selector = selector\n\t        self.algorithm = algorithm\n\t    def __eq__(self, obj: Any) -> bool:\n\t        return isinstance(obj, self.__class__) and self.names == obj.names\n\t    def __contains__(self, obj: Any) -> bool:\n\t        if isinstance(obj, str):\n\t            return obj in self.names[obj[0]]\n\t        return False\n\t    @staticmethod\n\t    def _create_names_dictionary(names: set[str]) -> _PackageNames:\n", "        \"\"\"Create a dictionary which will group all packages that start with the same letter under the same key.\"\"\"\n\t        first_letter_names = defaultdict(set)\n\t        for name in names:\n\t            first_letter_names[name[0]].add(name)\n\t        return first_letter_names\n\t    def get_typosquat(\n\t        self,\n\t        package_name: str,\n\t    ) -> TyposquatCheckResult:\n\t        \"\"\"Check if a given package name is similar to any trusted package and returns it.\n", "        Only if there is a match on the first letter can a package name be\n\t        considered similar to another one. The algorithm provided and the threshold\n\t        are used to determine if the package name can be considered similar.\n\t        \"\"\"\n\t        threshold = self.threshold_class.from_name(package_name)\n\t        typosquat_result = TyposquatCheckResult(package_name)\n\t        for trusted_package_name in self.selector.select_similar_names(\n\t            names=self.names, name=package_name\n\t        ):\n\t            distance = self.algorithm.get_distance(package_name, trusted_package_name)\n", "            if threshold.is_inside_threshold(distance):\n\t                typosquat_result.add(trusted_package_name)\n\t        return typosquat_result\n"]}
{"filename": "src/twyn/trusted_packages/references.py", "chunked_list": ["import logging\n\tfrom abc import ABC, abstractmethod\n\tfrom typing import Any\n\timport requests\n\tfrom twyn.trusted_packages.constants import TOP_PYPI_PACKAGES, Url\n\tfrom twyn.trusted_packages.exceptions import (\n\t    EmptyPackagesListError,\n\t    InvalidJSONError,\n\t    InvalidPyPiFormatError,\n\t)\n", "logger = logging.getLogger()\n\tclass AbstractPackageReference(ABC):\n\t    \"\"\"Represents a reference to retrieve trusted packages from.\"\"\"\n\t    def __init__(self, *args: Any, **kwargs: Any) -> None:\n\t        super().__init__(*args, **kwargs)\n\t    @abstractmethod\n\t    def get_packages(self) -> set[str]:\n\t        \"\"\"Return the names of the trusted packages available in the reference.\"\"\"\n\tclass TopPyPiReference(AbstractPackageReference):\n\t    \"\"\"Top PyPi packages retrieved from an online source.\"\"\"\n", "    def __init__(\n\t        self, source: Url = TOP_PYPI_PACKAGES, *args: Any, **kwargs: Any\n\t    ) -> None:\n\t        super().__init__(*args, **kwargs)\n\t        self.source = source\n\t    def get_packages(self) -> set[str]:\n\t        \"\"\"Download and parse online source of top Python Package Index packages.\"\"\"\n\t        packages_info = self._download()\n\t        return self._parse(packages_info)\n\t    def _download(self) -> dict[str, Any]:\n", "        packages = requests.get(self.source)\n\t        packages.raise_for_status()\n\t        try:\n\t            packages_json: dict[str, Any] = packages.json()\n\t        except requests.exceptions.JSONDecodeError as err:\n\t            raise InvalidJSONError from err\n\t        logger.debug(\n\t            f\"Successfully downloaded trusted packages list from {self.source}\"\n\t        )\n\t        return packages_json\n", "    @staticmethod\n\t    def _parse(packages_info: dict[str, Any]) -> set[str]:\n\t        try:\n\t            names = {row[\"project\"] for row in packages_info[\"rows\"]}\n\t        except KeyError as err:\n\t            raise InvalidPyPiFormatError from err\n\t        if not names:\n\t            raise EmptyPackagesListError\n\t        logger.debug(\"Successfully parsed trusted packages list\")\n\t        return names\n"]}
{"filename": "src/twyn/trusted_packages/selectors.py", "chunked_list": ["from __future__ import annotations\n\timport logging\n\tfrom abc import ABC, abstractmethod\n\tfrom typing import TYPE_CHECKING, Iterable\n\tfrom twyn.trusted_packages.constants import ADJACENCY_MATRIX\n\tfrom twyn.trusted_packages.exceptions import CharacterNotInMatrixError\n\tif TYPE_CHECKING:\n\t    from twyn.trusted_packages.trusted_packages import _PackageNames\n\tlogger = logging.getLogger()\n\tclass AbstractSelector(ABC):\n", "    @abstractmethod\n\t    def select_similar_names(self, names: _PackageNames, name: str) -> Iterable[str]:\n\t        \"\"\"Override this to select names that are similar to the provided one.\"\"\"\n\t    def __str__(self):\n\t        return self.__class__.__name__\n\tclass FirstLetterNearbyInKeyboard(AbstractSelector):\n\t    \"\"\"Selects names that start with a letter that is nearby in an English Keyboard.\"\"\"\n\t    def select_similar_names(self, names: _PackageNames, name: str) -> Iterable[str]:\n\t        candidate_characters = self._get_candidate_characters(name[0])\n\t        for letter in candidate_characters:\n", "            for candidate in names.get(letter, []):\n\t                yield candidate\n\t    @staticmethod\n\t    def _get_candidate_characters(character: str) -> list[str]:\n\t        if character not in ADJACENCY_MATRIX:\n\t            raise CharacterNotInMatrixError(f\"Character '{character}' not supported\")\n\t        return ADJACENCY_MATRIX[character] + [character]\n\tclass FirstLetterExact(AbstractSelector):\n\t    \"\"\"Selects names that share the same first letter.\"\"\"\n\t    def select_similar_names(self, names: _PackageNames, name: str) -> Iterable[str]:\n", "        for candidate in names[name[0]]:\n\t            yield candidate\n\tclass AllSimilar(AbstractSelector):\n\t    \"\"\"Consider all names to be similar.\"\"\"\n\t    def select_similar_names(self, names: _PackageNames, name: str) -> Iterable[str]:\n\t        for candidates in names.values():\n\t            for candidate in candidates:\n\t                yield candidate\n"]}
{"filename": "src/twyn/trusted_packages/__init__.py", "chunked_list": ["from twyn.trusted_packages.references import TopPyPiReference\n\tfrom twyn.trusted_packages.trusted_packages import (\n\t    TrustedPackages,\n\t)\n\t__all__ = [\"TopPyPiReference\", \"TrustedPackages\"]\n"]}
{"filename": "src/twyn/trusted_packages/constants.py", "chunked_list": ["from typing import NewType\n\tUrl = NewType(\"Url\", str)\n\tTOP_PYPI_PACKAGES = Url(\n\t    \"https://hugovk.github.io/top-pypi-packages/top-pypi-packages-30-days.min.json\"\n\t)\n\tADJACENCY_MATRIX = {\n\t    \"1\": [\"2\", \"q\", \"w\"],\n\t    \"2\": [\"1\", \"3\", \"q\", \"w\"],\n\t    \"3\": [\"2\", \"4\", \"w\", \"e\"],\n\t    \"4\": [\"3\", \"5\", \"e\", \"r\"],\n", "    \"5\": [\"4\", \"6\", \"r\", \"t\"],\n\t    \"6\": [\"5\", \"7\", \"t\", \"y\"],\n\t    \"7\": [\"6\", \"8\", \"y\", \"u\"],\n\t    \"8\": [\"7\", \"9\", \"u\", \"i\"],\n\t    \"9\": [\"8\", \"0\", \"i\", \"o\"],\n\t    \"0\": [\"9\", \"o\", \"p\"],\n\t    \"q\": [\"1\", \"2\", \"w\", \"a\"],\n\t    \"w\": [\"2\", \"3\", \"q\", \"e\", \"a\", \"s\", \"d\"],\n\t    \"e\": [\"3\", \"4\", \"w\", \"r\", \"s\", \"d\", \"f\"],\n\t    \"r\": [\"4\", \"5\", \"e\", \"t\", \"d\", \"f\", \"g\"],\n", "    \"t\": [\"5\", \"6\", \"r\", \"y\", \"f\", \"g\", \"h\"],\n\t    \"y\": [\"6\", \"7\", \"t\", \"u\", \"g\", \"h\", \"j\"],\n\t    \"u\": [\"7\", \"8\", \"y\", \"i\", \"h\", \"j\", \"k\"],\n\t    \"i\": [\"8\", \"9\", \"u\", \"o\", \"j\", \"k\", \"l\"],\n\t    \"o\": [\"9\", \"0\", \"i\", \"p\", \"k\", \"l\"],\n\t    \"p\": [\"0\", \"o\", \"l\"],\n\t    \"a\": [\"q\", \"w\", \"s\", \"z\"],\n\t    \"s\": [\"q\", \"w\", \"e\", \"a\", \"d\", \"z\", \"x\"],\n\t    \"d\": [\"w\", \"e\", \"r\", \"s\", \"f\", \"x\", \"c\"],\n\t    \"f\": [\"e\", \"r\", \"t\", \"d\", \"g\", \"c\", \"v\"],\n", "    \"g\": [\"r\", \"t\", \"y\", \"f\", \"h\", \"v\", \"b\"],\n\t    \"h\": [\"t\", \"y\", \"u\", \"g\", \"j\", \"b\", \"n\"],\n\t    \"j\": [\"y\", \"u\", \"i\", \"h\", \"k\", \"n\", \"m\"],\n\t    \"k\": [\"u\", \"i\", \"o\", \"j\", \"l\", \"m\"],\n\t    \"l\": [\"i\", \"o\", \"p\", \"k\"],\n\t    \"z\": [\"a\", \"s\", \"x\"],\n\t    \"x\": [\"s\", \"d\", \"z\", \"c\"],\n\t    \"c\": [\"d\", \"f\", \"x\", \"v\"],\n\t    \"v\": [\"f\", \"g\", \"c\", \"b\"],\n\t    \"b\": [\"g\", \"h\", \"v\", \"n\"],\n", "    \"n\": [\"h\", \"j\", \"b\", \"m\"],\n\t    \"m\": [\"j\", \"k\", \"n\"],\n\t}\n"]}
{"filename": "src/twyn/trusted_packages/exceptions.py", "chunked_list": ["from twyn.base.exceptions import TwynError\n\tclass InvalidJSONError(TwynError):\n\t    message = \"Could not json decode the downloaded packages list\"\n\tclass InvalidPyPiFormatError(TwynError, KeyError):\n\t    message = \"Invalid JSON format.\"\n\tclass EmptyPackagesListError(TwynError):\n\t    message = \"Downloaded packages list is empty\"\n\tclass CharacterNotInMatrixError(TwynError, KeyError):\n\t    ...\n"]}
{"filename": "src/twyn/base/__init__.py", "chunked_list": []}
{"filename": "src/twyn/base/constants.py", "chunked_list": ["from __future__ import annotations\n\timport enum\n\tfrom typing import TYPE_CHECKING\n\timport twyn.dependency_parser as dependency_parser\n\tfrom twyn.trusted_packages import selectors\n\tif TYPE_CHECKING:\n\t    from twyn.dependency_parser.abstract_parser import AbstractParser\n\tSELECTOR_METHOD_MAPPING: dict[str, type[selectors.AbstractSelector]] = {\n\t    \"first-letter\": selectors.FirstLetterExact,\n\t    \"nearby-letter\": selectors.FirstLetterNearbyInKeyboard,\n", "    \"all\": selectors.AllSimilar,\n\t}\n\tDEPENDENCY_FILE_MAPPING: dict[str, type[AbstractParser]] = {\n\t    \"requirements.txt\": dependency_parser.requirements_txt.RequirementsTxtParser,\n\t    \"poetry.lock\": dependency_parser.poetry_lock.PoetryLockParser,\n\t}\n\tDEFAULT_SELECTOR_METHOD = \"all\"\n\tDEFAULT_DEPENDENCY_FILE = \"requirements.txt\"\n\tDEFAULT_PROJECT_TOML_FILE = \"pyproject.toml\"\n\tclass AvailableLoggingLevels(enum.Enum):\n", "    none = \"NONE\"\n\t    debug = \"DEBUG\"\n\t    info = \"INFO\"\n\t    warning = \"WARNING\"\n"]}
{"filename": "src/twyn/base/exceptions.py", "chunked_list": ["class TwynError(Exception):\n\t    message = \"\"\n\t    def __init__(self, message: str = \"\") -> None:\n\t        super().__init__(message or self.message)\n"]}
{"filename": "src/twyn/core/config_handler.py", "chunked_list": ["import logging\n\tfrom os import getcwd\n\tfrom pathlib import Path\n\tfrom typing import Any, Optional\n\tfrom tomlkit import dumps, parse\n\tfrom twyn.base.constants import DEFAULT_PROJECT_TOML_FILE\n\tfrom twyn.core.exceptions import (\n\t    AllowlistPackageAlreadyExistsError,\n\t    AllowlistPackageDoesNotExistError,\n\t)\n", "logger = logging.getLogger()\n\tclass ConfigHandler:\n\t    \"\"\"Read certain values into a central ConfigHandler object.\"\"\"\n\t    def __init__(self, file_path: Optional[str] = None, enforce_file: bool = True):\n\t        self._file_path = file_path or DEFAULT_PROJECT_TOML_FILE\n\t        self._enforce_file = enforce_file\n\t        self._toml = self._get_toml_as_dict()\n\t        self._twyn_data = self._get_twyn_data()\n\t        self.dependency_file: Optional[str] = self._twyn_data.get(\"dependency_file\")\n\t        self.selector_method: Optional[str] = self._twyn_data.get(\"selector_method\")\n", "        self.logging_level: Optional[str] = self._twyn_data.get(\"logging_level\")\n\t        self.allowlist: set[str] = set(self._twyn_data.get(\"allowlist\", []))\n\t    def add_package_to_allowlist(self, package_name: str) -> None:\n\t        if package_name in self.allowlist:\n\t            raise AllowlistPackageAlreadyExistsError(package_name)\n\t        self._create_allowlist_in_toml_if_not_exists()\n\t        self._toml[\"tool\"][\"twyn\"][\"allowlist\"].append(package_name)\n\t        self._write_toml()\n\t        logger.warning(f\"Package '{package_name}' successfully added to allowlist\")\n\t    def remove_package_from_allowlist(self, package_name: str) -> None:\n", "        if package_name not in self.allowlist:\n\t            raise AllowlistPackageDoesNotExistError(package_name)\n\t        self._toml[\"tool\"][\"twyn\"][\"allowlist\"].remove(package_name)\n\t        self._write_toml()\n\t        logger.warning(f\"Package '{package_name}' successfully removed from allowlist\")\n\t    def _get_twyn_data(self) -> dict[str, Any]:\n\t        return self._toml.get(\"tool\", {}).get(\"twyn\", {})\n\t    def _get_toml_file_pointer(self) -> Path:\n\t        \"\"\"Create a path for the toml file with the format <current working directory>/self.file_path.\"\"\"\n\t        fp = Path(getcwd()) / Path(self._file_path)\n", "        if not fp.is_file():\n\t            raise FileNotFoundError(f\"File not found at path '{fp}'.\")\n\t        return fp\n\t    def _write_toml(self) -> None:\n\t        with open(self._get_toml_file_pointer(), \"w\") as f:\n\t            f.write(dumps(self._toml))\n\t    def _get_toml_as_dict(self) -> dict[str, Any]:\n\t        \"\"\"Read TOML into a dictionary.\"\"\"\n\t        try:\n\t            fp = self._get_toml_file_pointer()\n", "        except FileNotFoundError:\n\t            if not self._enforce_file and self._file_path == DEFAULT_PROJECT_TOML_FILE:\n\t                return {}\n\t            raise\n\t        with open(fp, \"r\") as f:\n\t            content = parse(f.read())\n\t        return parse(dumps(content))\n\t    def _create_allowlist_in_toml_if_not_exists(self) -> None:\n\t        try:\n\t            isinstance(self._toml[\"tool\"][\"twyn\"][\"allowlist\"], list)\n", "        except KeyError:\n\t            if \"tool\" not in self._toml:\n\t                self._toml[\"tool\"] = {}\n\t            if \"twyn\" not in self._toml[\"tool\"]:\n\t                self._toml[\"tool\"][\"twyn\"] = {}\n\t            if \"allowlist\" not in self._toml[\"tool\"][\"twyn\"]:\n\t                self._toml[\"tool\"][\"twyn\"][\"allowlist\"] = []\n"]}
{"filename": "src/twyn/core/__init__.py", "chunked_list": []}
{"filename": "src/twyn/core/exceptions.py", "chunked_list": ["from twyn.base.exceptions import TwynError\n\tclass AllowlistError(TwynError):\n\t    def __init__(self, package_name: str = \"\"):\n\t        message = self.message.format(package_name) if package_name else self.message\n\t        super().__init__(message)\n\tclass AllowlistPackageAlreadyExistsError(AllowlistError):\n\t    message = \"Package '{}' is already present in the allowlist. Skipping.\"\n\tclass AllowlistPackageDoesNotExistError(AllowlistError):\n\t    message = \"Package '{}' is not present in the allowlist. Skipping.\"\n"]}
{"filename": "src/twyn/similarity/algorithm.py", "chunked_list": ["from __future__ import annotations\n\timport logging\n\tfrom abc import ABC, abstractmethod\n\tfrom rapidfuzz.distance import DamerauLevenshtein\n\tfrom twyn.similarity.exceptions import DistanceAlgorithmError, ThresholdError\n\tlogger = logging.getLogger()\n\tclass SimilarityThreshold:\n\t    LENGTH_CUTOFF = 5\n\t    MIN_VALUE = 1.0\n\t    MAX_FOR_SHORT_WORDS = 1.0\n", "    MAX_FOR_LONG_WORDS = 2.0\n\t    def __init__(self, max: float) -> None:\n\t        self.min = self.MIN_VALUE\n\t        self.max = max\n\t        if self.min > self.max:\n\t            raise ThresholdError\n\t    @classmethod\n\t    def from_name(cls, name: str) -> SimilarityThreshold:\n\t        name_length = len(name)\n\t        if name_length <= cls.LENGTH_CUTOFF:\n", "            logger.debug(f\"max length of {cls.MAX_FOR_SHORT_WORDS} selected for {name}\")\n\t            return cls(max=cls.MAX_FOR_SHORT_WORDS)\n\t        logger.debug(f\"max length of {cls.MAX_FOR_LONG_WORDS} selected for {name}\")\n\t        return cls(\n\t            max=cls.MAX_FOR_LONG_WORDS\n\t        )  # we allow more typos if the name is longer\n\t    def is_inside_threshold(self, value: float) -> bool:\n\t        return self.min <= value <= self.max\n\tclass AbstractSimilarityAlgorithm(ABC):\n\t    \"\"\"Algorithm that can compare sequences based of a particular similarity measure.\"\"\"\n", "    def get_distance(self, first_sequence: str, second_sequence: str) -> float | int:\n\t        \"\"\"\n\t        Perform the alignment between sequences and return the computed distance.\n\t        Will raise DistanceAlgorithmError if an exception occurs.\n\t        \"\"\"\n\t        try:\n\t            return self._run_algorithm(first_sequence, second_sequence)\n\t        except Exception as exc:\n\t            raise DistanceAlgorithmError from exc\n\t    @abstractmethod\n", "    def _run_algorithm(self, first_sequence: str, second_sequence: str) -> float | int:\n\t        \"\"\"Abstract method that runs the selected algorithm for computing the distance between two words.\"\"\"\n\tclass EditDistance(AbstractSimilarityAlgorithm):\n\t    \"\"\"Levenshtein algorithm that computes the edit distance between words.\"\"\"\n\t    def _run_algorithm(self, first_sequence: str, second_sequence: str) -> int:\n\t        return DamerauLevenshtein.distance(s1=first_sequence, s2=second_sequence)\n"]}
{"filename": "src/twyn/similarity/__init__.py", "chunked_list": []}
{"filename": "src/twyn/similarity/exceptions.py", "chunked_list": ["from twyn.base.exceptions import TwynError\n\tclass DistanceAlgorithmError(TwynError):\n\t    message = \"Exception raised while running distance algorithm\"\n\tclass ThresholdError(TwynError, ValueError):\n\t    message = \"Minimum threshold cannot be greater than maximum threshold.\"\n"]}
