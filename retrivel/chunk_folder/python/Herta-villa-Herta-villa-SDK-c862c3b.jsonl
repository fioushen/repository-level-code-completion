{"filename": "hertavilla/exception.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Any\n\tcall_api_exceptions: dict[int, type[_ExceptionWithRetcode]] = {}\n\tclass PubkeyNoneWarning(Warning):\n\t    ...\n\tclass SDKException(Exception):\n\t    ...\n\tclass HTTPStatusError(SDKException):\n\t    def __init__(\n\t        self,\n", "        /,\n\t        status: int,\n\t    ) -> None:\n\t        self.status = status\n\t    def __repr__(self) -> str:\n\t        return \"<HTTPStatusError status={self.status}\"\n\tclass _ExceptionWithRetcode(SDKException):\n\t    def __init__(self, /, retcode: int, message: str) -> None:\n\t        self.retcode = retcode\n\t        self.message = message\n", "    def to_dict(self):\n\t        return {\"retcode\": self.retcode, \"message\": self.message}\n\tclass CallingApiException(_ExceptionWithRetcode):\n\t    def __repr__(self) -> str:\n\t        return (\n\t            \"<CallingApiException \"\n\t            f\"retcode={self.retcode}, message={self.message!r}>\"\n\t        )\n\t    def __init_subclass__(cls, retcode: int) -> None:\n\t        call_api_exceptions[retcode] = cls\n", "        return super().__init_subclass__()\n\t    def __str__(self) -> str:\n\t        return repr(self)\n\tclass UnknownServerError(CallingApiException, retcode=-502):\n\t    ...\n\tclass InvalidRequest(CallingApiException, retcode=-1):\n\t    ...\n\tclass InsufficientPermission(CallingApiException, retcode=10318001):\n\t    ...\n\tclass BotNotAdded(CallingApiException, retcode=10322002):\n", "    ...\n\tclass PermissionDenied(CallingApiException, retcode=10322003):\n\t    ...\n\tclass InvalidMemberBotAccessToken(CallingApiException, retcode=10322004):\n\t    ...\n\tclass InvalidBotAuthInfo(CallingApiException, retcode=10322005):\n\t    ...\n\tclass UnsupportedMsgType(CallingApiException, retcode=10322006):\n\t    ...\n\tdef raise_exception(payload: dict[str, Any]):\n", "    if payload[\"retcode\"] != 0:\n\t        retcode = payload[\"retcode\"]\n\t        raise call_api_exceptions.get(retcode, CallingApiException)(\n\t            retcode,\n\t            payload[\"message\"],\n\t        )\n"]}
{"filename": "hertavilla/version.py", "chunked_list": ["from __future__ import annotations\n\t__version__ = \"0.8.3\"\n"]}
{"filename": "hertavilla/match.py", "chunked_list": ["from __future__ import annotations\n\timport abc\n\tfrom contextvars import ContextVar\n\tfrom dataclasses import dataclass\n\timport re\n\tfrom hertavilla.message.chain import MessageChain\n\tcurrent_match_result: ContextVar[MatchResult] = ContextVar(\n\t    \"currect_match_result\",\n\t)\n\tclass Match(abc.ABC):\n", "    @abc.abstractmethod\n\t    def check(self, chain: MessageChain) -> bool:\n\t        raise NotImplementedError\n\tclass Regex(Match):\n\t    def __init__(self, pattern: str | re.Pattern) -> None:\n\t        if isinstance(pattern, str):\n\t            pattern = re.compile(pattern)\n\t        self.pattern = pattern\n\t    def __repr__(self) -> str:\n\t        return f\"<Match:Regex pattern={self.pattern!r}>\"\n", "    def check(self, chain: MessageChain) -> bool:\n\t        match = re.match(self.pattern, chain.plaintext)\n\t        if match is not None:\n\t            current_match_result.set(RegexResult(match=self, re_match=match))\n\t            return True\n\t        return False\n\tclass Startswith(Match):\n\t    def __init__(self, prefix: str) -> None:\n\t        self.prefix = prefix\n\t    def check(self, chain: MessageChain) -> bool:\n", "        plain = chain.plaintext\n\t        if plain.startswith(self.prefix):\n\t            current_match_result.set(\n\t                StartswithResult(match=self, text=plain[len(self.prefix) :]),\n\t            )\n\t            return True\n\t        return False\n\t    def __repr__(self) -> str:\n\t        return f\"<Match:Startswith prefix={self.prefix!r}>\"\n\tclass Endswith(Match):\n", "    def __init__(self, suffix: str) -> None:\n\t        self.suffix = suffix\n\t    def check(self, chain: MessageChain) -> bool:\n\t        plain = chain.plaintext\n\t        if plain.endswith(self.suffix):\n\t            current_match_result.set(\n\t                EndswithResult(match=self, text=plain[: len(self.suffix)]),\n\t            )\n\t            return True\n\t        return False\n", "    def __repr__(self) -> str:\n\t        return f\"<Match:Endswith suffix={self.suffix!r}>\"\n\tclass Keywords(Regex):\n\t    def __init__(self, *keywords: str) -> None:\n\t        self.keywords = keywords\n\t        self.pattern = re.compile(\"|\".join(keywords))\n\t    def __repr__(self) -> str:\n\t        return f\"<Match:Keywords words={self.keywords!r}>\"\n\t    def check(self, chain: MessageChain) -> bool:\n\t        match = re.match(self.pattern, chain.plaintext)\n", "        if match is not None:\n\t            matches = re.findall(self.pattern, chain.plaintext)\n\t            current_match_result.set(\n\t                KeywordsResult(match=self, matched_keywords=set(matches)),\n\t            )\n\t            return True\n\t        return False\n\t@dataclass\n\tclass MatchResult:\n\t    match: Match\n", "@dataclass\n\tclass RegexResult(MatchResult):\n\t    match: Regex\n\t    re_match: re.Match\n\t    @property\n\t    def pattern(self) -> re.Pattern:\n\t        return self.match.pattern\n\t@dataclass\n\tclass StartswithResult(MatchResult):\n\t    match: Startswith\n", "    text: str\n\t    @property\n\t    def prefix(self) -> str:\n\t        return self.match.prefix\n\t@dataclass\n\tclass EndswithResult(MatchResult):\n\t    match: Endswith\n\t    text: str\n\t    @property\n\t    def suffix(self) -> str:\n", "        return self.match.suffix\n\t@dataclass\n\tclass KeywordsResult(MatchResult):\n\t    match: Keywords\n\t    matched_keywords: set[str]\n\t    @property\n\t    def keywords(self) -> tuple[str]:\n\t        return self.match.keywords\n"]}
{"filename": "hertavilla/model.py", "chunked_list": ["# ruff: noqa: A003\n\tfrom __future__ import annotations\n\tfrom enum import Enum\n\tfrom typing import List, Optional\n\tfrom pydantic import BaseModel\n\tclass _BotMemberAccess(BaseModel):\n\t    uid: int\n\t    \"\"\"用户 id\"\"\"\n\t    villa_id: int\n\t    \"\"\"大别野 id\"\"\"\n", "    member_access_token: str\n\t    \"\"\"用户机器人访问凭证\"\"\"\n\t    bot_tpl_id: str\n\t    \"\"\"机器人模板 id\"\"\"\n\tclass MemberRoleType(str, Enum):\n\t    ALL_MEMBER = \"MEMBER_ROLE_TYPE_ALL_MEMBER\"\n\t    \"\"\"所有人身份组\"\"\"\n\t    ADMIN = \"MEMBER_ROLE_TYPE_ADMIN\"\n\t    \"\"\"管理员身份组\"\"\"\n\t    OWNER = \"MEMBER_ROLE_TYPE_OWNER\"\n", "    \"\"\"大别野房主身份组\"\"\"\n\t    CUSTOM = \"MEMBER_ROLE_TYPE_CUSTOM\"\n\t    \"\"\"其他自定义身份组\"\"\"\n\t    UNKNOWN = \"MEMBER_ROLE_TYPE_UNKNOWN\"\n\t    \"\"\"未知\"\"\"\n\tclass RolePermissionDetail(BaseModel):\n\t    key: str\n\t    \"\"\"权限 key 字符串\"\"\"\n\t    name: str\n\t    \"\"\"权限名称\"\"\"\n", "    describe: str\n\t    \"\"\"权限描述\"\"\"\n\tclass Role(BaseModel):\n\t    id: str\n\t    \"\"\"身份组 id\"\"\"\n\t    name: str\n\t    \"\"\"身份组名称\"\"\"\n\t    color: str\n\t    \"\"\"颜色\"\"\"\n\t    villa_id: str\n", "    \"\"\"所属大别野 id\"\"\"\n\t    role_type: MemberRoleType\n\t    \"\"\"身份组类型\"\"\"\n\t    member_num: str\n\t    \"\"\"身份组下成员数量\"\"\"\n\t    permissions: Optional[List[RolePermissionDetail]] = None\n\t    \"\"\"身份组拥有的权限列表\"\"\"\n\t    web_color: str\n\t    \"\"\"在网页端显示的颜色\"\"\"\n\t    font_color: str\n", "    \"\"\"字体颜色（未知）\"\"\"\n\t    bg_color: str\n\t    \"\"\"背景颜色（未知）\"\"\"\n\t    is_all_room: bool\n\t    \"\"\"是否可以管理所有可见房间\"\"\"\n\t    room_ids: List[int]\n\t    \"\"\"可管理房间 id\"\"\"\n\t    color_scheme_id: int\n\tclass MemberBasic(BaseModel):\n\t    uid: int\n", "    \"\"\"用户 uid\"\"\"\n\t    nickname: str\n\t    \"\"\"昵称\"\"\"\n\t    introduce: str\n\t    \"\"\"个性签名\"\"\"\n\t    avatar: str\n\t    \"\"\"头像\"\"\"\n\t    avatar_url: str\n\t    \"\"\"\"\"\"\n\tclass Member(BaseModel):\n", "    basic: MemberBasic\n\t    \"\"\"用户基本信息\"\"\"\n\t    role_id_list: List[int]\n\t    \"\"\"用户加入的身份组 id 列表\"\"\"\n\t    joined_at: str\n\t    \"\"\"用户加入时间 (ISO8601 timestamp)\"\"\"\n\t    role_list: List[Role]\n\tclass BotMemberAccessInfo(BaseModel):\n\t    access_info: _BotMemberAccess\n\t    \"\"\"token 解析的用户信息\"\"\"\n", "    member: Member\n\t    \"\"\"用户详细信息\"\"\"\n\tclass Villa(BaseModel):\n\t    villa_id: int\n\t    \"\"\"大别野 id\"\"\"\n\t    name: str\n\t    \"\"\"名称\"\"\"\n\t    villa_avatar_url: str\n\t    \"\"\"别野头像链接\"\"\"\n\t    owner_uid: int\n", "    \"\"\"别野主人 id\"\"\"\n\t    is_official: bool\n\t    \"\"\"是否是官方别野\"\"\"\n\t    introduce: str\n\t    \"\"\"介绍\"\"\"\n\t    category_id: int\n\t    \"\"\"\"\"\"\n\t    tags: List[str]\n\t    \"\"\"标签\"\"\"\n\tclass RoomType(str, Enum):\n", "    CHAT_ROOM = \"BOT_PLATFORM_ROOM_TYPE_CHAT_ROOM\"\n\t    \"\"\"聊天房间\"\"\"\n\t    POST_ROOM = \"BOT_PLATFORM_ROOM_TYPE_POST_ROOM\"\n\t    \"\"\"帖子房间\"\"\"\n\t    SCENE_ROOM = \"BOT_PLATFORM_ROOM_TYPE_SCENE_ROOM\"\n\t    \"\"\"场景房间\"\"\"\n\t    INVALID = \"BOT_PLATFORM_ROOM_TYPE_INVALID\"\n\t    \"\"\"无效\"\"\"\n\t    LIVE_ROOM = \"BOT_PLATFORM_ROOM_TYPE_LIVE_ROOM\"\n\t    \"\"\"直播房间\"\"\"\n", "class SendMsgAuthRange(BaseModel):\n\t    is_all_send_msg: bool\n\t    \"\"\"是否全局可发送\"\"\"\n\t    roles: List[int]\n\t    \"\"\"可发消息的身份组 id\"\"\"\n\tclass Group(BaseModel):\n\t    group_id: int\n\t    \"\"\"分组 id\"\"\"\n\t    group_name: str\n\t    \"\"\"分组名称\"\"\"\n", "class Room(BaseModel):\n\t    room_id: int\n\t    \"\"\"房间 id\"\"\"\n\t    room_name: str\n\t    \"\"\"房间名称\"\"\"\n\t    room_type: RoomType\n\t    \"\"\"房间类型\"\"\"\n\t    group_id: int\n\t    \"\"\"分组 id\"\"\"\n\t    room_default_notify_type: str\n", "    \"\"\"房间默认通知类型\"\"\"\n\t    send_msg_auth_range: SendMsgAuthRange\n\t    \"\"\"房间消息发送权限范围设置\"\"\"\n\tclass ListRoom(BaseModel):\n\t    room_id: int\n\t    \"\"\"房间 id\"\"\"\n\t    room_name: str\n\t    \"\"\"房间名称\"\"\"\n\t    room_type: RoomType\n\t    \"\"\"房间类型\"\"\"\n", "    group_id: int\n\t    \"\"\"分组 id\"\"\"\n\tclass GroupRoom(BaseModel):\n\t    group_id: int\n\t    \"\"\"分组 id\"\"\"\n\t    group_name: str\n\t    \"\"\"分组名称\"\"\"\n\t    room_list: List[ListRoom]\n\t    \"\"\"房间信息\"\"\"\n\tclass RoleColor(str, Enum):\n", "    BLUE = \"#6173AB\"\n\t    PINK = \"#F485D8\"\n\t    RED = \"#F47884\"\n\t    ORANGE = \"#FFA54B\"\n\t    GREEN = \"#7BC26F\"\n\t    SKY_BLUE = \"#59A1EA\"\n\t    PURPLE = \"#977EE1\"\n\t    # 此颜色为所有人身份组颜色，无法作为创建和编辑身份组的颜色\n\t    LIGHT_BLUE = \"#8F9BBF\"\n\tclass RolePermission(str, Enum):\n", "    MENTION_ALL = \"mention_all\"\n\t    \"\"\"@全体全员 - 允许成员能够 @全体成员\"\"\"\n\t    RECALL_MESSAGE = \"recall_message\"\n\t    \"\"\"撤回消息 - 允许成员能够在聊天房间中撤回任何人的消息\"\"\"\n\t    PIN_MESSAGE = \"pin_message\"\n\t    \"\"\"置顶消息 - 允许成员能够在聊天房间中置顶消息\"\"\"\n\t    MANAGE_MEMBER_ROLE = \"manage_member_role\"\n\t    \"\"\"身份组管理 - 允许成员添加、删除身份组，管理身份组成员，修改身份组的权限\"\"\"  # noqa: E501\n\t    EDIT_VILLA_INFO = \"edit_villa_info\"\n\t    \"\"\"编辑大别野详情 - 允许成员编辑大别野的简介、标签、设置大别野加入条件等\"\"\"\n", "    MANAGE_GROUP_AND_ROOM = \"manage_group_and_room\"\n\t    \"\"\"房间及分组管理 - 允许成员新建房间，新建/删除房间分组，调整房间及房间分组的排序\"\"\"  # noqa: E501\n\t    VILLA_SILENCE = \"villa_silence\"\n\t    \"\"\"禁言 - 允许成员能够在房间里禁言其他人\"\"\"\n\t    BLACK_OUT = \"black_out\"\n\t    \"\"\"拉黑 - 允许成员能够拉黑和将其他人移出大别野\"\"\"\n\t    HANDLE_APPLY = \"handle_apply\"\n\t    \"\"\"加入审核 - 允许成员审核大别野的加入申请\"\"\"\n\t    MANAGE_CHAT_ROOM = \"manage_chat_room\"\n\t    \"\"\"聊天房间管理 - 允许成员编辑房间信息及设置可见、发言权限\"\"\"\n", "    VIEW_DATA_BOARD = \"view_data_board\"\n\t    \"\"\"查看大别野数据 - 允许成员查看大别野数据看板\"\"\"\n\t    MANAGE_CUSTOM_EVENT = \"manage_custom_event\"\n\t    \"\"\"组织活动 - 允许成员创建活动，编辑活动信息\"\"\"\n\t    LIVE_ROOM_ORDER = \"live_room_order\"\n\t    \"\"\"点播房间节目 - 允许成员在直播房间中点播节目及控制节目播放\"\"\"\n\t    MANAGE_SPOTLIGHT_COLLECTION = \"manage_spotlight_collection\"\n\t    \"\"\"设置精选消息 - 允许成员设置、移除精选消息\"\"\"\n\tclass Emoticon(BaseModel):\n\t    emoticon_id: int\n", "    \"\"\"表情 id\"\"\"\n\t    describe_text: str\n\t    \"\"\"描述文本\"\"\"\n\t    icon: str\n\t    \"\"\"表情图片链接\"\"\"\n\tclass AuditContentType(str, Enum):\n\t    TEXT = \"AuditContentTypeText\"\n\t    IMAGE = \"AuditContentTypeImage\"\n"]}
{"filename": "hertavilla/bot.py", "chunked_list": ["from __future__ import annotations\n\timport asyncio\n\timport base64\n\tfrom dataclasses import dataclass\n\timport logging\n\timport re\n\tfrom typing import (\n\t    TYPE_CHECKING,\n\t    Any,\n\t    Awaitable,\n", "    Callable,\n\t    Coroutine,\n\t    Generic,\n\t    TypeVar,\n\t)\n\timport urllib.parse\n\tfrom hertavilla.apis.audit import AuditAPIMixin\n\tfrom hertavilla.apis.auth import AuthAPIMixin\n\tfrom hertavilla.apis.img import ImgAPIMixin\n\tfrom hertavilla.apis.member import MemberAPIMixin\n", "from hertavilla.apis.message import MessageAPIMixin\n\tfrom hertavilla.apis.role import RoleAPIMixin\n\tfrom hertavilla.apis.room import RoomAPIMixin\n\tfrom hertavilla.apis.villa import VillaAPIMixin\n\tfrom hertavilla.match import (\n\t    Endswith,\n\t    EndswithResult,\n\t    Keywords,\n\t    KeywordsResult,\n\t    Match,\n", "    MatchResult,\n\t    Regex,\n\t    RegexResult,\n\t    Startswith,\n\t    StartswithResult,\n\t    current_match_result,\n\t)\n\timport rsa\n\tif TYPE_CHECKING:\n\t    from hertavilla.event import Command, Event, SendMessageEvent, Template\n", "    from hertavilla.message import MessageChain\n\tTE = TypeVar(\"TE\", bound=\"Event\")\n\tTR = TypeVar(\"TR\", bound=\"MatchResult\")\n\tlogger = logging.getLogger(\"hertavilla.bot\")\n\t@dataclass\n\tclass Handler(Generic[TE]):\n\t    event: type[TE]\n\t    func: Callable[[TE, VillaBot], Coroutine[Any, Any, None]]\n\t    temp: bool = False\n\t    def __call__(self, *args: Any, **kwargs: Any) -> Any:\n", "        return self.func(*args, **kwargs)\n\t    def __eq__(self, __value: Event) -> bool:\n\t        return isinstance(__value, self.event)\n\t@dataclass\n\tclass MessageHandler(Generic[TR]):\n\t    match: Match\n\t    func: Callable[[\"SendMessageEvent\", \"VillaBot\", TR], Awaitable[Any]]\n\t    temp: bool = False\n\t    def __call__(self, *args: Any, **kwargs: Any) -> Any:\n\t        return self.func(*args, **kwargs)\n", "    def check(self, chain: MessageChain) -> bool:\n\t        return self.match.check(chain)\n\tRegexHandlerFunc = Callable[\n\t    [\"SendMessageEvent\", \"VillaBot\", RegexResult],\n\t    Awaitable[Any],\n\t]\n\tStartswithHandlerFunc = Callable[\n\t    [\"SendMessageEvent\", \"VillaBot\", StartswithResult],\n\t    Awaitable[Any],\n\t]\n", "EndswithHandlerFunc = Callable[\n\t    [\"SendMessageEvent\", \"VillaBot\", EndswithResult],\n\t    Awaitable[Any],\n\t]\n\tKeywordsHandlerFunc = Callable[\n\t    [\"SendMessageEvent\", \"VillaBot\", KeywordsResult],\n\t    Awaitable[Any],\n\t]\n\tclass VillaBot(\n\t    AuthAPIMixin,\n", "    MemberAPIMixin,\n\t    MessageAPIMixin,\n\t    RoomAPIMixin,\n\t    VillaAPIMixin,\n\t    RoleAPIMixin,\n\t    ImgAPIMixin,\n\t    AuditAPIMixin,\n\t):\n\t    def __init__(\n\t        self,\n", "        bot_id: str,\n\t        secret: str,\n\t        callback_endpoint: str,\n\t        pub_key: str,\n\t        bot_info: \"Template\" | None = None,\n\t    ) -> None:\n\t        from hertavilla.event import SendMessageEvent\n\t        super().__init__(bot_id, secret, pub_key)\n\t        self.rsa_pub_key = rsa.PublicKey.load_pkcs1_openssl_pem(\n\t            pub_key.encode(),\n", "        )\n\t        self._bot_info = bot_info\n\t        self.callback_endpoint = callback_endpoint\n\t        self.handlers: list[Handler] = []\n\t        self.message_handlers: list[MessageHandler] = []\n\t        self.register_handler(SendMessageEvent, self.message_handler)\n\t    @property\n\t    def bot_info(self) -> \"Template\":\n\t        assert (\n\t            self._bot_info is not None\n", "        ), f\"No bot info, maybe bot {self.bot_id} not connected\"\n\t        return self._bot_info\n\t    @bot_info.setter\n\t    def bot_info(self, value: \"Template\") -> None:\n\t        self._bot_info = value\n\t    @property\n\t    def name(self) -> str:\n\t        \"\"\"Bot 昵称\"\"\"\n\t        return self.bot_info.name\n\t    @property\n", "    def avatar(self) -> str:\n\t        \"\"\"Bot 头像地址\"\"\"\n\t        return self.bot_info.icon\n\t    @property\n\t    def commands(self) -> list[\"Command\"]:\n\t        \"\"\"Bot 预设命令列表\"\"\"\n\t        return self.bot_info.commands\n\t    @property\n\t    def description(self) -> str | None:\n\t        \"\"\"Bot 介绍\"\"\"\n", "        return self.bot_info.desc\n\t    def __repr__(self) -> str:\n\t        return f\"<VillaBot id={self.bot_id!r}>\"\n\t    def __eq__(self, __value: str | VillaBot) -> bool:\n\t        if isinstance(__value, VillaBot):\n\t            return (\n\t                self.bot_id == __value.bot_id and self.secret == __value.secret\n\t            )\n\t        return self.bot_id == __value\n\t    def __hash__(self) -> int:\n", "        return hash(self.bot_id)\n\t    def verify(\n\t        self,\n\t        sign: str,\n\t        body: str,\n\t    ) -> bool:\n\t        sign_ = base64.b64decode(sign)\n\t        sign_msg = urllib.parse.urlencode(\n\t            {\"body\": body, \"secret\": self.secret},\n\t        ).encode()\n", "        try:\n\t            rsa.verify(sign_msg, sign_, self.rsa_pub_key)\n\t        except rsa.VerificationError:\n\t            return False\n\t        else:\n\t            return True\n\t    async def send(\n\t        self,\n\t        villa_id: int,\n\t        room_id: int,\n", "        chain: \"MessageChain\",\n\t    ) -> str:\n\t        \"\"\"通用发送消息方法\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            room_id (int): 房间 id\n\t            chain (MessageChain): 消息链\n\t        Returns:\n\t            str: bot_msg_id 机器人所发送消息的唯一标识符\n\t        \"\"\"\n", "        return await self.send_message(\n\t            villa_id,\n\t            room_id,\n\t            *(await chain.to_content_json(self)),\n\t        )\n\t    # event handle\n\t    def register_handler(\n\t        self,\n\t        event: type[TE],\n\t        func: Callable[[TE, VillaBot], Coroutine[Any, Any, None]],\n", "        temp: bool = False,\n\t    ):\n\t        self.handlers.append(Handler[TE](event, func, temp))\n\t        logger.info(\n\t            f\"Registered the handler {func} \"\n\t            f\"for {event.__name__} (temp: {temp})\",\n\t        )\n\t        return func\n\t    def listen(\n\t        self,\n", "        event: type[TE],\n\t        temp: bool = False,\n\t    ) -> Callable[\n\t        [Callable[[TE, VillaBot], Coroutine[Any, Any, None]]],\n\t        Callable[[TE, VillaBot], Coroutine[Any, Any, None]],\n\t    ]:\n\t        def wrapper(\n\t            func: Callable[[TE, VillaBot], Coroutine[Any, Any, None]],\n\t        ) -> Callable[[TE, VillaBot], Coroutine[Any, Any, None]]:\n\t            self.register_handler(event, func, temp)\n", "            return func\n\t        return wrapper\n\t    async def handle_event(self, event: Event) -> None:\n\t        handlers = list(filter(lambda x: x == event, self.handlers))\n\t        logger.info(f\"Handling event {event.__class__.__name__}\")\n\t        need_remove_handlers = filter(lambda x: x.temp, handlers)\n\t        try:\n\t            await asyncio.gather(\n\t                *[handler(event, self) for handler in handlers],\n\t            )\n", "        except Exception:\n\t            logger.exception(\"Raised exceptions while handling event.\")\n\t        for handler in need_remove_handlers:\n\t            self.handlers.remove(handler)\n\t            logger.debug(f\"Removed handler for {event.__class__.__name__}\")\n\t    # message handle\n\t    @staticmethod\n\t    async def message_handler(event: \"SendMessageEvent\", bot: \"VillaBot\"):\n\t        await asyncio.gather(\n\t            *[\n", "                bot._run_message_handler(event, bot, handler)  # noqa: SLF001\n\t                for handler in bot.message_handlers\n\t            ],\n\t        )\n\t    @staticmethod\n\t    async def _run_message_handler(\n\t        event: \"SendMessageEvent\",\n\t        bot: \"VillaBot\",\n\t        handler: MessageHandler,\n\t    ):\n", "        if not handler.check(event.message):\n\t            return\n\t        result = current_match_result.get()\n\t        await handler(event, bot, result)\n\t        if handler.temp:\n\t            bot.message_handlers.remove(handler)\n\t            logger.debug(f\"Removed message handler with {handler.match}\")\n\t    def register_msg_handler(\n\t        self,\n\t        match: Match,\n", "        func: Callable[[\"SendMessageEvent\", \"VillaBot\", TR], Awaitable[Any]],\n\t        temp: bool = False,\n\t    ):\n\t        self.message_handlers.append(MessageHandler[TR](match, func, temp))\n\t        logger.info(\n\t            f\"Registered the handler {func} with {match} (temp: {temp})\",\n\t        )\n\t        return func\n\t    def match(\n\t        self,\n", "        match: Match,\n\t        temp: bool = False,\n\t    ) -> Callable[\n\t        [Callable[[\"SendMessageEvent\", \"VillaBot\", TR], Awaitable[Any]]],\n\t        Callable[[\"SendMessageEvent\", \"VillaBot\", TR], Awaitable[Any]],\n\t    ]:\n\t        def wrapper(\n\t            func: Callable[\n\t                [\"SendMessageEvent\", \"VillaBot\", TR],\n\t                Awaitable[Any],\n", "            ],\n\t        ) -> Callable[[\"SendMessageEvent\", \"VillaBot\", TR], Awaitable[Any]]:\n\t            self.register_msg_handler(match, func, temp)\n\t            return func\n\t        return wrapper\n\t    def regex(\n\t        self,\n\t        pattern: str | re.Pattern,\n\t        temp: bool = False,\n\t    ) -> Callable[[RegexHandlerFunc], RegexHandlerFunc]:\n", "        def wrapper(\n\t            func: RegexHandlerFunc,\n\t        ) -> RegexHandlerFunc:\n\t            self.register_msg_handler(Regex(pattern), func, temp)\n\t            return func\n\t        return wrapper\n\t    def startswith(\n\t        self,\n\t        prefix: str,\n\t        temp: bool = False,\n", "    ) -> Callable[[StartswithHandlerFunc], StartswithHandlerFunc]:\n\t        def wrapper(\n\t            func: StartswithHandlerFunc,\n\t        ) -> StartswithHandlerFunc:\n\t            self.register_msg_handler(Startswith(prefix), func, temp)\n\t            return func\n\t        return wrapper\n\t    def endswith(\n\t        self,\n\t        suffix: str,\n", "        temp: bool = False,\n\t    ) -> Callable[[EndswithHandlerFunc], EndswithHandlerFunc]:\n\t        def wrapper(\n\t            func: EndswithHandlerFunc,\n\t        ) -> EndswithHandlerFunc:\n\t            self.register_msg_handler(Endswith(suffix), func, temp)\n\t            return func\n\t        return wrapper\n\t    def keyword(\n\t        self,\n", "        *keywords: str,\n\t        temp: bool = False,\n\t    ) -> Callable[[KeywordsHandlerFunc], KeywordsHandlerFunc]:\n\t        def wrapper(\n\t            func: KeywordsHandlerFunc,\n\t        ) -> KeywordsHandlerFunc:\n\t            self.register_msg_handler(Keywords(*keywords), func, temp)\n\t            return func\n\t        return wrapper\n"]}
{"filename": "hertavilla/__init__.py", "chunked_list": ["from __future__ import annotations\n\tfrom .bot import VillaBot as VillaBot\n\tfrom .event import (\n\t    AddQuickEmoticonEvent as AddQuickEmoticonEvent,\n\t    AuditCallbackEvent as AuditCallbackEvent,\n\t    CreateRobotEvent as CreateRobotEvent,\n\t    DeleteRobotEvent as DeleteRobotEvent,\n\t    Event as Event,\n\t    JoinVillaEvent as JoinVillaEvent,\n\t    SendMessageEvent as SendMessageEvent,\n", ")\n\tfrom .match import (\n\t    EndswithResult as EndswithResult,\n\t    KeywordsResult as KeywordsResult,\n\t    RegexResult as RegexResult,\n\t    StartswithResult as StartswithResult,\n\t)\n\tfrom .message import (\n\t    Image as Image,\n\t    Link as Link,\n", "    MentionedAll as MentionedAll,\n\t    MentionedRobot as MentionedRobot,\n\t    MentionedUser as MentionedUser,\n\t    MessageChain as MessageChain,\n\t    Post as Post,\n\t    Quote as Quote,\n\t    VillaRoomLink as VillaRoomLink,\n\t)\n\tfrom .server import (\n\t    AIOHTTPBackend as AIOHTTPBackend,\n", "    get_backend as get_backend,\n\t    init_backend as init_backend,\n\t    run as run,\n\t)\n\tfrom .version import __version__ as __version__\n"]}
{"filename": "hertavilla/utils.py", "chunked_list": ["from __future__ import annotations\n\timport json\n\tclass MsgEncoder(json.JSONEncoder):\n\t    def default(self, obj):\n\t        from hertavilla.message.internal import MsgContent\n\t        if isinstance(obj, MsgContent):\n\t            data = obj.dict()\n\t            for k in data.copy().keys():\n\t                if k.startswith(\"_\"):\n\t                    data.pop(k)\n", "            return data\n\t        return json.JSONEncoder.default(self, obj)\n\tdef _c(text: str) -> int:\n\t    return (len(text.encode(\"utf-16\")) // 2) - 1\n\tdef _rc(length: int) -> int:\n\t    return (length + 1) * 2\n"]}
{"filename": "hertavilla/typing.py", "chunked_list": ["from __future__ import annotations\n\timport sys\n\t# Because of pydantic's exception\n\t# Herta SDK provides this `TypedDict`\n\t# Import it by this:\n\t# from hertavilla.typing import TypedDict\n\t# Pydantic exception:\n\t#   TypeError: You should use `typing_extensions.TypedDict`\n\t#   instead of `typing.TypedDict` with Python < 3.9.2.\n\t#   Without it, there is no way to differentiate\n", "#   required and optional fields when subclassed.\n\tif sys.version_info >= (3, 9, 2):\n\t    from typing import TypedDict as TypedDict\n\telse:\n\t    from typing_extensions import TypedDict as TypedDict\n"]}
{"filename": "hertavilla/event.py", "chunked_list": ["# ruff: noqa: A003\n\tfrom __future__ import annotations\n\tfrom enum import IntEnum\n\timport json\n\timport sys\n\tfrom typing import Any, List, Literal, Optional, Type\n\tfrom hertavilla.message import (\n\t    MessageChain,\n\t)\n\tfrom hertavilla.message.text import (\n", "    EntityDict,\n\t    MentionedInfo,\n\t    QuoteInfo,\n\t    Text,\n\t    entity_types,\n\t)\n\tfrom hertavilla.utils import _rc\n\tfrom pydantic import BaseModel, Field, create_model_from_typeddict, validator\n\tif sys.version_info >= (3, 11):\n\t    from typing import Self\n", "else:\n\t    from typing_extensions import Self\n\tevents: dict[int, tuple[Type[\"Event\"], str]] = {}\n\tclass Command(BaseModel):\n\t    name: str\n\t    desc: Optional[str] = None\n\tclass Template(BaseModel):\n\t    id: str\n\t    name: str\n\t    desc: Optional[str] = None\n", "    icon: str\n\t    commands: List[Command]\n\tclass Robot(BaseModel):\n\t    \"\"\"机器人相关信息\"\"\"\n\t    template: Template\n\t    \"\"\"机器人模板信息\"\"\"\n\t    villa_id: int\n\t    \"\"\"事件所属的大别野 id\"\"\"\n\tclass Event(BaseModel):\n\t    robot: Robot\n", "    \"\"\"用户机器人访问凭证\"\"\"\n\t    type: int\n\t    \"\"\"事件类型\"\"\"\n\t    created_at: int\n\t    \"\"\"事件创建时间\"\"\"\n\t    id: str\n\t    \"\"\"事件 id\"\"\"\n\t    send_at: int\n\t    \"\"\"事件回调时间\"\"\"\n\t    @property\n", "    def villa_id(self) -> int:\n\t        return self.robot.villa_id\n\t    def __init_subclass__(cls: Type[Self]) -> None:\n\t        super().__init_subclass__()\n\t        literal = cls.__annotations__[\"type\"]\n\t        type_: int = (\n\t            eval(cls.__annotations__[\"type\"])\n\t            if isinstance(literal, str)\n\t            else literal\n\t        ).__args__[\n", "            0\n\t        ]  # 获取类型\n\t        name = cls.__name__.replace(\"Event\", \"\")  # 获取名称\n\t        events[type_] = cls, name\n\t# JoinVilla\n\tclass JoinVillaEvent(Event):\n\t    type: Literal[1]\n\t    join_uid: int\n\t    \"\"\"用户 id\"\"\"\n\t    join_user_nickname: str\n", "    \"\"\"用户昵称\"\"\"\n\t    join_at: int\n\t    \"\"\"用户加入时间\"\"\"\n\t# SendMessage\n\t# why ignore type: https://github.com/pydantic/pydantic/issues/5953\n\tMentionedInfoModel = create_model_from_typeddict(MentionedInfo)  # type: ignore\n\tQuoteInfoModel = create_model_from_typeddict(QuoteInfo)  # type: ignore\n\tclass User(BaseModel):\n\t    portrait_uri: str = Field(alias=\"portraitUri\")\n\t    extra: dict\n", "    name: str\n\t    alias: str\n\t    id: str\n\t    portrait: str\n\t    @validator(\"extra\", pre=True)\n\t    def extra_str_to_dict(cls, v: Any):\n\t        return json.loads(v) if isinstance(v, str) else v\n\tclass Trace(BaseModel):\n\t    visual_room_version: str\n\t    app_version: str\n", "    action_type: int\n\t    bot_msg_id: str\n\t    client: str\n\t    rong_sdk_version: str\n\tclass MessageContent(BaseModel):\n\t    content: MessageChain\n\t    mentioned_info: Optional[MentionedInfoModel] = Field(  # type: ignore\n\t        None,\n\t        alias=\"mentionedInfo\",\n\t    )\n", "    quote: Optional[QuoteInfoModel] = None  # type: ignore\n\t    user: Optional[User] = None\n\t    trace: Optional[Trace] = None\n\t    @validator(\"content\", pre=True)\n\t    def parse_content(cls, v: Any):\n\t        chain = MessageChain()\n\t        text = v[\"text\"].encode(\"utf-16\")\n\t        entities = v[\"entities\"]\n\t        last_offset = 0\n\t        last_length = 0\n", "        end_offset = 0\n\t        for entity in entities:\n\t            entity: EntityDict\n\t            offset = entity[\"offset\"]\n\t            body = entity[\"entity\"]\n\t            type_ = body.pop(\"type\")\n\t            if offset != end_offset:\n\t                # 两个 Entity 偏移相差为文字\n\t                chain.append(\n\t                    Text(text[_rc(end_offset) : _rc(offset)].decode(\"utf-16\")),\n", "                )\n\t            chain.append(entity_types[type_](**body))\n\t            last_offset = offset\n\t            last_length = entity[\"length\"]\n\t            end_offset = last_offset + last_length\n\t        if _rc(end_offset) != len(text):\n\t            # 最后一个 Entity 之后是文字\n\t            chain.append(\n\t                Text(text[_rc(end_offset) :].decode(\"utf-16\")),\n\t            )\n", "        return chain\n\tclass SendMessageEvent(Event):\n\t    type: Literal[2]\n\t    content: MessageContent\n\t    \"\"\"消息内容\"\"\"\n\t    from_user_id: int\n\t    \"\"\"发送者 id\"\"\"\n\t    send_at: int\n\t    \"\"\"发送时间的时间戳\"\"\"\n\t    room_id: int\n", "    \"\"\"房间 id\"\"\"\n\t    object_name: int\n\t    \"\"\"目前只支持文本类型消息\"\"\"\n\t    nickname: str\n\t    \"\"\"用户昵称\"\"\"\n\t    msg_uid: str\n\t    \"\"\"消息 id\"\"\"\n\t    bot_msg_id: Optional[str]\n\t    \"\"\"如果被回复的消息从属于机器人，则该字段不为空字符串\"\"\"\n\t    @validator(\"content\", pre=True)\n", "    def str_to_json(cls, v: Any):\n\t        return json.loads(v)\n\t    @property\n\t    def message(self) -> MessageChain:\n\t        return self.content.content\n\tclass CreateRobotEvent(Event):\n\t    type: Literal[3]\n\tclass DeleteRobotEvent(Event):\n\t    type: Literal[4]\n\tclass AddQuickEmoticonEvent(Event):\n", "    type: Literal[5]\n\t    room_id: int\n\t    \"\"\"房间 id\"\"\"\n\t    uid: int\n\t    \"\"\"发送表情的用户 id\"\"\"\n\t    emoticon_id: int\n\t    \"\"\"表情 id\"\"\"\n\t    emoticon: str\n\t    \"\"\"表情内容\"\"\"\n\t    msg_uid: str\n", "    \"\"\"被回复的消息 id\"\"\"\n\t    bot_msg_id: str\n\t    \"\"\"如果被回复的消息从属于机器人，则该字段不为空字符串\"\"\"\n\t    is_cancel: bool = False\n\t    \"\"\"是否是取消表情\"\"\"\n\tclass AuditResult(IntEnum):\n\t    COMPATIBLE = 0\n\t    APPROVED = 1\n\t    REJECTED = 2\n\tclass AuditCallbackEvent(Event):\n", "    type: Literal[6]\n\t    audit_id: str\n\t    \"\"\"审核事件 id\"\"\"\n\t    bot_tpl_id: str\n\t    \"\"\"机器人 id\"\"\"\n\t    room_id: int\n\t    \"\"\"房间 id（和审核接口调用方传入的值一致）\"\"\"\n\t    user_id: int\n\t    \"\"\"用户 id（和审核接口调用方传入的值一致）\"\"\"\n\t    pass_through: Optional[str] = None\n", "    \"\"\"透传数据（和审核接口调用方传入的值一致）\"\"\"\n\t    audit_result: AuditResult\n\t    \"\"\"审核结果，0作兼容，1审核通过，2审核驳回\"\"\"\n\t    def __bool__(self) -> bool:\n\t        return self.audit_result != AuditResult.REJECTED\n\t    def compare(self, audit_id: str, pass_through: str | None = None) -> bool:\n\t        return self.audit_id == audit_id and self.pass_through == pass_through\n\tdef parse_event(payload: dict[str, Any]) -> Event:\n\t    type_: int = payload[\"type\"]\n\t    cls_, name = events[type_]\n", "    data = payload[\"extend_data\"][\"EventData\"][name]\n\t    payload.pop(\"extend_data\")\n\t    payload |= data\n\t    return cls_.parse_obj(payload)\n"]}
{"filename": "hertavilla/apis/role.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import List, Sequence\n\tfrom hertavilla.apis.internal import _BaseAPIMixin\n\tfrom hertavilla.model import Role, RoleColor, RolePermission\n\tfrom pydantic import parse_obj_as\n\tclass RoleAPIMixin(_BaseAPIMixin):\n\t    async def operate_member_to_role(\n\t        self,\n\t        villa_id: int,\n\t        role_id: int,\n", "        uid: int,\n\t        is_add: bool = True,\n\t    ) -> None:\n\t        \"\"\"向身份组操作用户，包括把用户添加到身份组或者从身份组删除用户\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            role_id (int): 身份组 id\n\t            uid (int): 用户 id\n\t            is_add (bool, optional): 是否是添加用户. Defaults to True.\n\t        \"\"\"\n", "        await self.base_request(\n\t            \"/operateMemberToRole\",\n\t            \"POST\",\n\t            villa_id,\n\t            data={\"role_id\": role_id, \"uid\": uid, \"is_add\": is_add},\n\t        )\n\t    async def create_member_role(\n\t        self,\n\t        villa_id: int,\n\t        name: str,\n", "        color: RoleColor,\n\t        permissions: Sequence[RolePermission],\n\t    ) -> int:\n\t        \"\"\"为大别野创建新的身份组，可以设置该身份组拥有的权限，并为身份组添加用户。\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            name (str): 身份组名称\n\t            color (RoleColor): 身份组颜色，可选项见 ``hertavilla.model.RoleColor``\n\t            permissions (Sequence[RolePermission]): 权限列表，可选项见 ``hertavilla.model.RolePermission``\n\t        Returns:\n", "            int: 身份组 id\n\t        \"\"\"  # noqa: E501\n\t        return int(\n\t            (\n\t                await self.base_request(\n\t                    \"/createMemberRole\",\n\t                    \"POST\",\n\t                    villa_id,\n\t                    data={\n\t                        \"name\": name,\n", "                        \"color\": color.value,\n\t                        \"permissions\": [perm.value for perm in permissions],\n\t                    },\n\t                )\n\t            )[\"id\"],\n\t        )\n\t    async def edit_member_role(\n\t        self,\n\t        villa_id: int,\n\t        id_: int,\n", "        name: str,\n\t        color: RoleColor,\n\t        permissions: Sequence[RolePermission],\n\t    ) -> None:\n\t        \"\"\"编辑身份组，可以修改身份组的名称、颜色和权限。\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            id_ (int): 身份组 id\n\t            name (str): 身份组名称\n\t            color (RoleColor): 身份组颜色，可选项见 ``hertavilla.model.RoleColor``\n", "            permissions (Sequence[RolePermission]): 权限列表，可选项见 ``hertavilla.model.RolePermission``\n\t        \"\"\"  # noqa: E501\n\t        await self.base_request(\n\t            \"/editMemberRole\",\n\t            \"POST\",\n\t            villa_id,\n\t            data={\n\t                \"id\": id_,\n\t                \"name\": name,\n\t                \"color\": color.value,\n", "                \"permissions\": [perm.value for perm in permissions],\n\t            },\n\t        )\n\t    async def delete_member_role(self, villa_id: int, id_: int) -> None:\n\t        \"\"\"删除身份组\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            id_ (int): 身份组 id\n\t        \"\"\"\n\t        await self.base_request(\n", "            \"/deleteMemberRole\",\n\t            \"POST\",\n\t            villa_id,\n\t            data={\"id\": id_},\n\t        )\n\t    async def get_member_role_info(self, villa_id: int, role_id: int) -> Role:\n\t        \"\"\"获取身份组信息\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            role_id (int): 身份组 id\n", "        Returns:\n\t            Role: 身份组信息\n\t        \"\"\"\n\t        return Role.parse_obj(\n\t            (\n\t                await self.base_request(\n\t                    \"/getMemberRoleInfo\",\n\t                    \"GET\",\n\t                    villa_id,\n\t                    params={\"role_id\": role_id},\n", "                )\n\t            )[\"role\"],\n\t        )\n\t    async def get_villa_member_roles(self, villa_id: int) -> list[Role]:\n\t        \"\"\"获取大别野下所有身份组\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t        Returns:\n\t            list[Role]: 身份组列表\n\t        \"\"\"\n", "        return parse_obj_as(\n\t            List[Role],\n\t            (\n\t                await self.base_request(\n\t                    \"/getVillaMemberRoles\",\n\t                    \"GET\",\n\t                    villa_id,\n\t                )\n\t            )[\"list\"],\n\t        )\n"]}
{"filename": "hertavilla/apis/auth.py", "chunked_list": ["from __future__ import annotations\n\tfrom hertavilla.apis.internal import _BaseAPIMixin\n\tfrom hertavilla.model import BotMemberAccessInfo\n\tclass AuthAPIMixin(_BaseAPIMixin):\n\t    async def check_member_bot_access_token(\n\t        self,\n\t        token: str,\n\t    ) -> BotMemberAccessInfo:\n\t        \"\"\"校验用户机器人访问凭证，并返回用户信息\n\t        Args:\n", "            token (str): 用户机器人访问凭证\n\t        Returns:\n\t            BotMemberAccessInfo: 返回数据，包含 token 解析的用户信息 和 用户详细信息\n\t        \"\"\"  # noqa: E501\n\t        return BotMemberAccessInfo.parse_obj(\n\t            await self.base_request(\n\t                \"/checkMemberBotAccessToken\",\n\t                \"POST\",\n\t                data={\"token\": token},\n\t            ),\n", "        )\n"]}
{"filename": "hertavilla/apis/internal.py", "chunked_list": ["from __future__ import annotations\n\timport hashlib\n\timport hmac\n\timport logging\n\tfrom typing import Any, Literal\n\tfrom hertavilla.exception import (\n\t    HTTPStatusError,\n\t    raise_exception,\n\t)\n\tfrom aiohttp import ClientSession\n", "logger = logging.getLogger(\"hertavilla.api\")\n\tBASE_API = \"https://bbs-api.miyoushe.com/vila/api/bot/platform\"\n\tclass _BaseAPIMixin:\n\t    def __init__(\n\t        self,\n\t        bot_id: str,\n\t        secret: str,\n\t        pub_key: str,\n\t    ):\n\t        self.bot_id = bot_id\n", "        self.secret = secret\n\t        self.pub_key = pub_key\n\t    def _make_header(self, villa_id: int) -> dict[str, str]:\n\t        secret = hmac.new(\n\t            self.pub_key.encode(),\n\t            self.secret.encode(),\n\t            hashlib.sha256,\n\t        ).hexdigest()\n\t        return {\n\t            \"x-rpc-bot_id\": self.bot_id,\n", "            \"x-rpc-bot_secret\": secret,\n\t            \"x-rpc-bot_villa_id\": str(villa_id),\n\t        }\n\t    async def base_request(\n\t        self,\n\t        api: str,\n\t        method: Literal[\"POST\"] | Literal[\"GET\"],\n\t        /,\n\t        villa_id: int | None = None,\n\t        *,\n", "        data: dict[str, Any] | None = None,\n\t        params: dict[str, Any] | None = None,\n\t    ):\n\t        logger.info(f\"Calling API {api}.\")\n\t        async with ClientSession() as session:\n\t            async with session.request(\n\t                method,\n\t                f\"{BASE_API}{api}\",\n\t                json=data,\n\t                params=params,\n", "                headers=self._make_header(villa_id) if villa_id else None,\n\t            ) as resp:\n\t                if not resp.ok:\n\t                    raise HTTPStatusError(resp.status)\n\t                payload = await resp.json()\n\t                raise_exception(payload)\n\t                return payload[\"data\"]\n"]}
{"filename": "hertavilla/apis/room.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import List\n\tfrom hertavilla.apis.internal import _BaseAPIMixin\n\tfrom hertavilla.model import Group, GroupRoom, Room\n\tfrom pydantic import parse_obj_as\n\tclass RoomAPIMixin(_BaseAPIMixin):\n\t    async def create_group(self, villa_id: int, group_name: str) -> int:\n\t        \"\"\"创建分组\n\t        Args:\n\t            villa_id (int): 大别野 id\n", "            group_name (str): 分组名称\n\t        Returns:\n\t            int: 分组 id\n\t        \"\"\"\n\t        return int(\n\t            (\n\t                await self.base_request(\n\t                    \"/createGroup\",\n\t                    \"POST\",\n\t                    villa_id,\n", "                    data={\n\t                        \"group_name\": group_name,\n\t                    },\n\t                )\n\t            )[\"group_id\"],\n\t        )\n\t    async def edit_group(\n\t        self,\n\t        villa_id: int,\n\t        group_id: int,\n", "        group_name: str,\n\t    ) -> None:\n\t        \"\"\"编辑分组，只允许编辑分组的名称\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            group_id (int): 分组 id\n\t            group_name (str): 分组名称\n\t        \"\"\"\n\t        await self.base_request(\n\t            \"/editGroup\",\n", "            \"POST\",\n\t            villa_id,\n\t            data={\"group_id\": group_id, \"group_name\": group_name},\n\t        )\n\t    async def delete_group(self, villa_id: int, group_id: int) -> None:\n\t        \"\"\"删除分组\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            group_id (int): 分组 id\n\t        \"\"\"\n", "        await self.base_request(\n\t            \"/deleteGroup\",\n\t            \"POST\",\n\t            villa_id,\n\t            data={\"group_id\": group_id},\n\t        )\n\t    async def get_group_list(self, villa_id: int) -> list[Group]:\n\t        \"\"\"获取大别野下的所有分组的列表，只返回分组的基本信息，不包含分组内的房间信息。\n\t        Args:\n\t            villa_id (int): 大别野 id\n", "        Returns:\n\t            list[Group]: 分组列表\n\t        \"\"\"\n\t        return parse_obj_as(\n\t            List[Group],\n\t            (\n\t                await self.base_request(\n\t                    \"/getGroupList\",\n\t                    \"GET\",\n\t                    villa_id,\n", "                )\n\t            )[\"list\"],\n\t        )\n\t    async def edit_room(\n\t        self,\n\t        villa_id: int,\n\t        room_id: int,\n\t        room_name: str,\n\t    ) -> None:\n\t        \"\"\"编辑房间，只允许编辑房间的名称\n", "        Args:\n\t            villa_id (int): 大别野 id\n\t            room_id (int): 房间 id\n\t            room_name (str): 房间名称\n\t        \"\"\"\n\t        await self.base_request(\n\t            \"/editRoom\",\n\t            \"POST\",\n\t            villa_id,\n\t            data={\"room_id\": room_id, \"room_name\": room_name},\n", "        )\n\t    async def delete_room(self, villa_id: int, room_id: int) -> None:\n\t        \"\"\"删除房间\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            room_id (int): 房间 id\n\t        \"\"\"\n\t        await self.base_request(\n\t            \"/deleteRoom\",\n\t            \"POST\",\n", "            villa_id,\n\t            data={\"room_id\": room_id},\n\t        )\n\t    async def get_room(self, villa_id: int, room_id: int) -> Room:\n\t        \"\"\"获取房间信息\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            room_id (int): 房间 id\n\t        Returns:\n\t            Room: 房间信息\n", "        \"\"\"\n\t        return Room.parse_obj(\n\t            (\n\t                await self.base_request(\n\t                    \"/getRoom\",\n\t                    \"GET\",\n\t                    villa_id,\n\t                    params={\"room_id\": room_id},\n\t                )\n\t            )[\"room\"],\n", "        )\n\t    async def get_villa_group_room_list(\n\t        self,\n\t        villa_id: int,\n\t    ) -> list[GroupRoom]:\n\t        \"\"\"获取大别野下的所有分组和房间的列表\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t        Returns:\n\t            list[GroupRoom]: 房间列表\n", "        \"\"\"\n\t        return parse_obj_as(\n\t            List[GroupRoom],\n\t            (\n\t                await self.base_request(\n\t                    \"/getVillaGroupRoomList\",\n\t                    \"GET\",\n\t                    villa_id,\n\t                )\n\t            )[\"list\"],\n", "        )\n"]}
{"filename": "hertavilla/apis/message.py", "chunked_list": ["from __future__ import annotations\n\timport json\n\tfrom hertavilla.apis.internal import _BaseAPIMixin\n\tfrom hertavilla.message.internal import MsgContentInfo\n\tfrom hertavilla.utils import MsgEncoder\n\tclass MessageAPIMixin(_BaseAPIMixin):\n\t    async def send_message(\n\t        self,\n\t        villa_id: int,\n\t        room_id: int,\n", "        msg_content_info: MsgContentInfo,\n\t        object_name: str = \"MHY:Text\",\n\t    ) -> str:\n\t        \"\"\"发送消息\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            room_id (int): 房间 id\n\t            msg_content_info (MsgContentInfo): 消息信息\n\t            object_name (str, optional): 消息类型，目前支持: MHY:Text 文本类型. Defaults to \"MHY:Text\".\n\t        Returns:\n", "            str: bot_msg_id 机器人所发送消息的唯一标识符\n\t        \"\"\"  # noqa: E501\n\t        return (\n\t            await self.base_request(\n\t                \"/sendMessage\",\n\t                \"POST\",\n\t                villa_id,\n\t                data={\n\t                    \"room_id\": room_id,\n\t                    \"object_name\": object_name,\n", "                    \"msg_content\": json.dumps(\n\t                        msg_content_info,\n\t                        ensure_ascii=False,\n\t                        cls=MsgEncoder,\n\t                    ),\n\t                },\n\t            )\n\t        )[\"bot_msg_id\"]\n\t    async def pin_message(\n\t        self,\n", "        villa_id: int,\n\t        msg_uid: str,\n\t        room_id: int,\n\t        send_at: int,\n\t        is_cancel: bool = False,\n\t    ) -> None:\n\t        \"\"\"置顶消息\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            msg_uid (str): 消息 id\n", "            room_id (int): 房间 id\n\t            send_at (int): 发送时间\n\t            is_cancel (bool, optional): 是否取消置顶. Defaults to False.\n\t        \"\"\"\n\t        await self.base_request(\n\t            \"/pinMessage\",\n\t            \"POST\",\n\t            villa_id,\n\t            data={\n\t                \"msg_uid\": msg_uid,\n", "                \"room_id\": room_id,\n\t                \"send_at\": send_at,\n\t                \"is_cancel\": is_cancel,\n\t            },\n\t        )\n\t    async def recall_message(\n\t        self,\n\t        villa_id: int,\n\t        msg_uid: str,\n\t        room_id: int,\n", "        msg_time: int,\n\t    ) -> None:\n\t        \"\"\"撤回消息\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            msg_uid (str): 消息 id\n\t            room_id (int): 房间 id\n\t            msg_time (int): 发送时间\n\t        \"\"\"\n\t        await self.base_request(\n", "            \"/recallMessage\",\n\t            \"POST\",\n\t            villa_id,\n\t            data={\n\t                \"msg_uid\": msg_uid,\n\t                \"room_id\": room_id,\n\t                \"msg_time\": msg_time,\n\t            },\n\t        )\n"]}
{"filename": "hertavilla/apis/__init__.py", "chunked_list": []}
{"filename": "hertavilla/apis/audit.py", "chunked_list": ["from __future__ import annotations\n\tfrom hertavilla.apis.internal import _BaseAPIMixin\n\tfrom hertavilla.model import AuditContentType\n\tclass AuditAPIMixin(_BaseAPIMixin):\n\t    async def audit(\n\t        self,\n\t        villa_id: int,\n\t        audit_content: str,\n\t        room_id: int,\n\t        uid: int,\n", "        pass_through: str | None = None,\n\t        content_type: AuditContentType = AuditContentType.TEXT,\n\t    ) -> str:\n\t        \"\"\"审核用户配置内容是否合规，调用成功后会返回审核事件id(audit_id)。审核结果会通过回调接口异步通知 (`AuditCallback`)。\n\t        如果机器人存在大别野用户自定义内容，就要调用审核接口，判断内容是否合规。\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            audit_content (str): 待审核内容\n\t            room_id (int): 房间 id\n\t            uid (int): 用户 id\n", "            pass_through (str | None, optional): 透传信息，该字段会在审核结果回调时携带给开发者，选填. Defaults to None.\n\t            content_type (AuditContentType, optional): 审核内容的类型. Defaults to AuditContentType.TEXT.\n\t        Returns:\n\t            str: 审核事件 id\n\t        \"\"\"  # noqa: E501\n\t        # FIXME: 文档所说 room_id 和 uid 为选填\n\t        # 但是不填会 -1，所以这里设置成了必填\n\t        return (\n\t            await self.base_request(\n\t                \"/audit\",\n", "                \"POST\",\n\t                villa_id,\n\t                data={\n\t                    \"audit_content\": audit_content,\n\t                    \"room_id\": room_id,\n\t                    \"uid\": uid,\n\t                    \"pass_through\": pass_through,\n\t                    \"content_type\": content_type.value,\n\t                },\n\t            )\n", "        )[\"audit_id\"]\n"]}
{"filename": "hertavilla/apis/emoticon.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import List\n\tfrom hertavilla.apis.internal import _BaseAPIMixin\n\tfrom hertavilla.model import Emoticon\n\tfrom pydantic import parse_obj_as\n\tclass EmoticonAPIMixin(_BaseAPIMixin):\n\t    async def get_all_emoticon(self) -> list[Emoticon]:\n\t        \"\"\"获取全量表情\n\t        Returns:\n\t            list[Emoticon]: 表情列表\n", "        \"\"\"\n\t        return parse_obj_as(\n\t            List[Emoticon],\n\t            (await self.base_request(\"/getAllEmoticons\", \"GET\"))[\"list\"],\n\t        )\n"]}
{"filename": "hertavilla/apis/img.py", "chunked_list": ["from __future__ import annotations\n\tfrom hertavilla.apis.internal import _BaseAPIMixin\n\tclass ImgAPIMixin(_BaseAPIMixin):\n\t    async def transfer_image(\n\t        self,\n\t        villa_id: int,\n\t        url: str,\n\t    ) -> str:\n\t        \"\"\"将非米游社的三方图床图片转存到米游社官方图床\n\t        Args:\n", "            villa_id (int): 大别野 id\n\t            url (str): 三方图床的图片链接\n\t        Returns:\n\t            str: 新的米游社官方图床的图片链接\n\t        \"\"\"\n\t        return (\n\t            await self.base_request(\n\t                \"/transferImage\",\n\t                \"POST\",\n\t                villa_id,\n", "                data={\"url\": url},\n\t            )\n\t        )[\"new_url\"]\n"]}
{"filename": "hertavilla/apis/member.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import List\n\tfrom hertavilla.apis.internal import _BaseAPIMixin\n\tfrom hertavilla.model import Member\n\tfrom pydantic import parse_obj_as\n\tclass MemberAPIMixin(_BaseAPIMixin):\n\t    async def get_member(self, villa_id: int, uid: int) -> Member:\n\t        \"\"\"获取用户信息\n\t        Args:\n\t            villa_id (int): 大别野 id\n", "            uid (int): 用户 id\n\t        Returns:\n\t            Member: 用户详情\n\t        \"\"\"\n\t        return Member.parse_obj(\n\t            (\n\t                await self.base_request(\n\t                    \"/getMember\",\n\t                    \"GET\",\n\t                    villa_id,\n", "                    params={\"uid\": uid},\n\t                )\n\t            )[\"member\"],\n\t        )\n\t    async def get_villa_members(\n\t        self,\n\t        villa_id: int,\n\t        offset_str: str = \"0\",\n\t        size: int = 10,\n\t    ) -> tuple[list[Member], str]:\n", "        \"\"\"获取大别野成员列表。\n\t        当 offset_str 为空时，返回第一页的成员列表信息；\n\t        当使用本次请求返回值中的`下一页的偏移量起始位置`作为下次请求中的 offset_str 时，会返回下一页的成员列表。\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            offset_str (str, optional): 起始位置偏移量. Defaults to \"0\".\n\t            size (int, optional): 分页大小. Defaults to 10.\n\t        Returns:\n\t            tuple[list[Member], str]: 用户信息列表与下一页的偏移量起始位置\n\t        \"\"\"  # noqa: E501\n", "        data = await self.base_request(\n\t            \"/getVillaMembers\",\n\t            \"GET\",\n\t            villa_id,\n\t            params={\"offset_str\": offset_str, \"size\": size},\n\t        )\n\t        return (\n\t            parse_obj_as(List[Member], data[\"list\"]),\n\t            data[\"next_offset_str\"],\n\t        )\n", "    async def delete_villa_member(self, villa_id: int, uid: int) -> None:\n\t        \"\"\"踢出大别野用户\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t            uid (int): 用户 id\n\t        \"\"\"\n\t        await self.base_request(\n\t            \"/deleteVillaMember\",\n\t            \"POST\",\n\t            villa_id,\n", "            data={\"uid\": uid},\n\t        )\n"]}
{"filename": "hertavilla/apis/villa.py", "chunked_list": ["from __future__ import annotations\n\tfrom hertavilla.apis.internal import _BaseAPIMixin\n\tfrom hertavilla.model import Villa\n\tclass VillaAPIMixin(_BaseAPIMixin):\n\t    async def get_villa(self, villa_id: int) -> Villa:\n\t        \"\"\"获取大别野信息\n\t        Args:\n\t            villa_id (int): 大别野 id\n\t        Returns:\n\t            Villa: 大别野信息\n", "        \"\"\"\n\t        return Villa.parse_obj(\n\t            (\n\t                await self.base_request(\n\t                    \"/getVilla\",\n\t                    \"GET\",\n\t                    villa_id,\n\t                    params={\"villa_id\": villa_id},\n\t                )\n\t            )[\"villa\"],\n", "        )\n"]}
{"filename": "hertavilla/message/internal.py", "chunked_list": ["from __future__ import annotations\n\timport abc\n\tfrom typing import TYPE_CHECKING\n\tfrom hertavilla.typing import TypedDict\n\tfrom pydantic import BaseModel\n\tif TYPE_CHECKING:\n\t    from hertavilla.bot import VillaBot\n\tclass _Segment(abc.ABC):\n\t    ...\n\t    @abc.abstractmethod\n", "    async def get_text(self, bot: \"VillaBot\") -> str:\n\t        raise NotImplementedError\n\tclass MsgContentInfo(TypedDict):\n\t    ...\n\tclass MsgContent(BaseModel):\n\t    ...\n"]}
{"filename": "hertavilla/message/text.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING, Any, List, Literal, Optional, cast\n\tfrom hertavilla.message.image import ImageMsgContent\n\tfrom hertavilla.message.internal import MsgContent, MsgContentInfo, _Segment\n\tfrom hertavilla.typing import TypedDict\n\tfrom hertavilla.utils import _c\n\tif TYPE_CHECKING:\n\t    from hertavilla.bot import VillaBot\n\tentity_types: dict[str, type[\"_TextEntity\"]] = {}\n\t# MsgContentInfo for text\n", "class TextMsgContentInfo(MsgContentInfo):\n\t    content: TextMsgContent\n\t    mentionedInfo: Optional[MentionedInfo]\n\t    quote: Optional[QuoteInfo]\n\tclass QuoteInfo(TypedDict):\n\t    quoted_message_id: str\n\t    \"\"\"引用消息 id\"\"\"\n\t    quoted_message_send_time: str\n\t    \"\"\"引用消息发送时间戳\"\"\"\n\t    original_message_id: str\n", "    \"\"\"引用树初始消息 id，和 quoted_message_id 保持一致即可\"\"\"\n\t    original_message_send_time: str\n\t    \"\"\"引用树初始消息发送时间戳，和 quoted_message_send_time 保持一致即可\"\"\"\n\tclass MentionedInfo(TypedDict):\n\t    type: Literal[1, 2]  # noqa: A003\n\t    \"\"\"提及类型:\n\t    值为1: @全员\n\t    值为2: @部分成员\"\"\"\n\t    userIdList: List[str]\n\t    \"\"\"如果不是提及全员，应该填写被提及的用户 id 列表\"\"\"\n", "class EntityDict(TypedDict):\n\t    entity: Any\n\t    length: int\n\t    offset: int\n\t# Segment for text\n\tclass _TextEntity(_Segment):\n\t    type_: str\n\t    def __init__(self, **kwargs) -> None:\n\t        ...\n\t    def get_mention(self) -> tuple[Literal[1, 2], str] | None:\n", "        return None\n\t    def __init_subclass__(cls) -> None:\n\t        if cls.__name__ not in {\"Text\", \"Quote\"}:\n\t            entity_types[cls.type_] = cls\n\t        return super().__init_subclass__()\n\tclass Text(_TextEntity):\n\t    def __init__(self, text: str) -> None:\n\t        self.text = text\n\t    async def get_text(self, _: VillaBot) -> str:\n\t        return self.text\n", "    def __str__(self) -> str:\n\t        return self.text\n\tclass VillaRoomLink(_TextEntity):\n\t    type_ = \"villa_room_link\"\n\t    def __init__(self, villa_id: int, room_id: int) -> None:\n\t        self.villa_id = str(villa_id)\n\t        self.room_id = str(room_id)\n\t    async def get_text(self, bot: VillaBot) -> str:\n\t        room = await bot.get_room(self.villa_id, self.room_id)  # type: ignore\n\t        return f\"#{room.room_name}\"\n", "class Link(_TextEntity):\n\t    type_ = \"link\"\n\t    def __init__(\n\t        self,\n\t        url: str,\n\t        requires_bot_access_token: bool = False,\n\t    ) -> None:\n\t        self.url = url\n\t        self.requires_bot_access_token = requires_bot_access_token\n\t    async def get_text(self, _: VillaBot) -> str:\n", "        return self.url\n\tclass MentionedRobot(_TextEntity):\n\t    type_ = \"mentioned_robot\"\n\t    def __init__(self, bot_id: str) -> None:\n\t        self.bot_id = bot_id\n\t    async def get_text(self, bot: VillaBot) -> str:\n\t        # 目前只能 @ 机器人自身，故直接从 bot 处获取名称\n\t        return f\"@{bot.name}\"\n\t    def get_mention(self) -> tuple[Literal[1, 2], str] | None:\n\t        return 2, self.bot_id\n", "class MentionedUser(_TextEntity):\n\t    type_ = \"mentioned_user\"\n\t    def __init__(\n\t        self,\n\t        user_id: str,\n\t        _villa_id: int = 0,\n\t    ) -> None:\n\t        self.user_id = user_id\n\t        self._villa_id = _villa_id\n\t    async def get_text(self, bot: VillaBot) -> str:\n", "        member = await bot.get_member(self._villa_id, int(self.user_id))\n\t        return f\"@{member.basic.nickname}\"\n\t    def get_mention(self) -> tuple[Literal[1, 2], str] | None:\n\t        return 2, self.user_id\n\tclass MentionedAll(_TextEntity):\n\t    type_ = \"mentioned_all\"\n\t    async def get_text(self, _: VillaBot) -> str:\n\t        return \"@全体成员\"\n\t    def get_mention(self) -> tuple[Literal[1, 2], str] | None:\n\t        return 1, \"\"\n", "class Quote(_TextEntity):\n\t    def __init__(self, message_id: str, time: int) -> None:\n\t        self.message_id = message_id\n\t        self.time = time\n\t    async def get_text(self, bot: VillaBot) -> str:\n\t        raise NotImplementedError\n\t# MsgContent for text\n\tclass TextMsgContent(MsgContent):\n\t    text: str\n\t    entities: List[EntityDict]\n", "    images: Optional[List[ImageMsgContent]] = None\n\tasync def text_to_content(\n\t    text_entities: list[_TextEntity],\n\t    bot: VillaBot,\n\t    image: list[ImageMsgContent] | None = None,\n\t) -> TextMsgContentInfo:\n\t    texts: list[str] = []\n\t    entities: list[EntityDict] = []\n\t    mentioned_info: MentionedInfo | None = None\n\t    quote: QuoteInfo | None = None\n", "    offset = 0\n\t    for i, entity in enumerate(text_entities):\n\t        if isinstance(entity, Quote):\n\t            # 存在 Quote Entity 转换成 quote\n\t            message_id = entity.message_id\n\t            time = entity.time\n\t            quote = cast(\n\t                QuoteInfo,\n\t                {\n\t                    \"original_message_id\": message_id,\n", "                    \"original_message_send_time\": time,\n\t                    \"quoted_message_id\": message_id,\n\t                    \"quoted_message_send_time\": time,\n\t                },\n\t            )\n\t            continue\n\t        # 非文字 entity 尾随空格，最末除外\n\t        space = \"\" if i == len(text_entities) - 1 else \" \"\n\t        if isinstance(entity, Text):\n\t            text = str(entity)\n", "            length = len(text)\n\t        else:\n\t            text = f\"{await entity.get_text(bot)}{space}\"\n\t            length = _c(text)\n\t            entities.append(\n\t                {\n\t                    \"entity\": {\"type\": entity.type_, **entity.__dict__},\n\t                    \"length\": length,\n\t                    \"offset\": offset,\n\t                },\n", "            )\n\t            if mention := entity.get_mention():\n\t                type_, id_ = mention\n\t                if mentioned_info is None:\n\t                    user_id_list = []\n\t                    mentioned_info = cast(\n\t                        MentionedInfo,\n\t                        {\"type\": type_, \"userIdList\": user_id_list},\n\t                    )\n\t                else:\n", "                    if mentioned_info[\"type\"] != 1:\n\t                        mentioned_info[\"type\"] = type_\n\t                    user_id_list = mentioned_info[\"userIdList\"]\n\t                if type_ != 1:\n\t                    user_id_list.append(id_)\n\t        offset += len(text)\n\t        texts.append(text)\n\t    return {\n\t        \"content\": TextMsgContent(\n\t            text=\"\".join(texts),\n", "            entities=entities,\n\t            images=image,\n\t        ),\n\t        \"quote\": quote,\n\t        \"mentionedInfo\": mentioned_info,\n\t    }\n"]}
{"filename": "hertavilla/message/chain.py", "chunked_list": ["from __future__ import annotations\n\tfrom copy import deepcopy\n\timport logging\n\timport sys\n\tfrom typing import TYPE_CHECKING, Iterable, List\n\tfrom hertavilla.message.image import (\n\t    Image,\n\t    ImageMsgContentInfo,\n\t    image_to_content,\n\t)\n", "from hertavilla.message.internal import MsgContentInfo, _Segment\n\tfrom hertavilla.message.post import Post, post_to_content\n\tfrom hertavilla.message.text import Text, text_to_content\n\tif TYPE_CHECKING:\n\t    from hertavilla.bot import VillaBot\n\tif sys.version_info >= (3, 11):\n\t    from typing import Self\n\telse:\n\t    from typing_extensions import Self\n\tlogger = logging.getLogger(\"hertavilla.message\")\n", "class MessageChain(List[_Segment]):\n\t    def __init__(\n\t        self,\n\t        message: str | _Segment | Iterable[_Segment] | None = None,\n\t    ) -> None:\n\t        super().__init__()\n\t        if message is None:\n\t            return\n\t        if isinstance(message, (_Segment, str)):\n\t            self.append(message)\n", "        else:\n\t            self.extend(message)\n\t    def append(self, __object: str | _Segment) -> None:\n\t        if isinstance(__object, str):\n\t            __object = Text(__object)\n\t        super().append(__object)\n\t    def copy(self) -> Self:\n\t        return deepcopy(self)\n\t    def __add__(self, other: str | _Segment | Iterable[_Segment]) -> Self:\n\t        result = self.copy()\n", "        result += other\n\t        return result\n\t    def __radd__(self, other: str | _Segment | Iterable[_Segment]) -> Self:\n\t        result = self.__class__(other)\n\t        return result + self\n\t    def __iadd__(self, other: str | _Segment | Iterable[_Segment]) -> Self:\n\t        if isinstance(other, str):\n\t            self.append(Text(other))\n\t        elif isinstance(other, _Segment):\n\t            self.append(other)\n", "        elif isinstance(other, Iterable):\n\t            self.extend(other)\n\t        else:\n\t            raise TypeError(f\"Unsupported type {type(other)!r}\")\n\t        return self\n\t    def extend(self, obj: Iterable[_Segment]) -> Self:\n\t        for segment in obj:\n\t            self.append(segment)\n\t        return self\n\t    async def to_content_json(\n", "        self,\n\t        bot: VillaBot,\n\t    ) -> tuple[MsgContentInfo, str]:\n\t        text_entities = []\n\t        image = []\n\t        posts = []\n\t        for segment in self:\n\t            if isinstance(segment, Image):\n\t                image.append(image_to_content(segment))\n\t            elif isinstance(segment, Post):\n", "                posts.append(post_to_content(segment))\n\t            else:\n\t                text_entities.append(segment)\n\t        if not text_entities:\n\t            if image:\n\t                if posts:\n\t                    logger.warn(\n\t                        \"Both Image and Post in the message is not allowed, \"\n\t                        \"Image has been selected\",\n\t                    )\n", "                if len(image) <= 1:\n\t                    return ImageMsgContentInfo(content=image[0]), \"MHY:Image\"\n\t                logger.warn(\n\t                    \"Multiple images will be sent using MHY:Text, \"\n\t                    \"which will cause the \"\n\t                    \"images to not be displayed on the web side\",\n\t                )\n\t                logger.warn(\n\t                    \"Recommend to send the images using multiple times\",\n\t                )\n", "                return (\n\t                    await text_to_content([Text(\"\\u200B\")], bot, image),\n\t                    \"MHY:Text\",\n\t                )\n\t            if posts:\n\t                if len(posts) > 1:\n\t                    logger.warn(\n\t                        \"Only support one post in one message, \"\n\t                        \"so use the last one\",\n\t                    )\n", "                return posts[-1], \"MHY:Post\"\n\t            raise ValueError(\"Message is empty\")\n\t        if image:\n\t            logger.warn(\n\t                \"When the image and text exist at the same time, \"\n\t                \"the message will be sent as MHY:Text, \"\n\t                \"and the image will not be displayed on the web side\",\n\t            )\n\t        if posts:\n\t            logger.warn(\n", "                \"When post and text are present at the same time, \"\n\t                \"the post will not be displayed\",\n\t            )\n\t        return await text_to_content(text_entities, bot, image), \"MHY:Text\"\n\t    async def get_text(\n\t        self,\n\t        bot: \"VillaBot\",\n\t    ) -> str:\n\t        \"\"\"获取文本（每段消息的文本形式）。\n\t        需要注意此函数与 plaintext 不同。\n", "        Args:\n\t            bot (VillaBot): 大别野 Bot\n\t        Returns:\n\t            str: 文本内容\n\t        \"\"\"\n\t        texts: list[str] = []\n\t        for i, x in enumerate(self):\n\t            space = \"\" if i == len(self) - 1 else \" \"\n\t            text = await x.get_text(bot)\n\t            if not isinstance(x, (Text, Image, Post)):\n", "                text += space\n\t            texts.append(text)\n\t        return \"\".join(texts)\n\t    @property\n\t    def plaintext(self) -> str:\n\t        \"\"\"获取纯文本。\n\t        需要注意此属性与 get_text() 不同。\n\t        Returns:\n\t            str: 纯文本内容\n\t        \"\"\"\n", "        return \"\".join(map(str, filter(lambda x: isinstance(x, Text), self)))\n\t    def __str__(self) -> str:\n\t        return self.plaintext\n"]}
{"filename": "hertavilla/message/post.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom hertavilla.message.internal import (\n\t    MsgContent,\n\t    MsgContentInfo,\n\t    _Segment,\n\t)\n\tif TYPE_CHECKING:\n\t    from hertavilla.bot import VillaBot\n\t# MsgContentInfo for post\n", "class PostMsgContentInfo(MsgContentInfo):\n\t    content: PostMsgContent\n\t# Segment for post\n\tclass Post(_Segment):\n\t    def __init__(self, post_id: str) -> None:\n\t        self.post_id = post_id\n\t    async def get_text(self, _: VillaBot) -> str:\n\t        # TODO: 帖子名\n\t        # 米游社的 API 可以获取到，但是需要 DS\n\t        # 感觉加到这里有点臃肿了\n", "        #\n\t        # https://bbs-api.miyoushe.com/post/wapi/semPosts?gids=6&post_id={}\n\t        return \"[帖子]\"\n\t# MsgContent for post\n\tclass PostMsgContent(MsgContent):\n\t    post_id: str\n\tdef post_to_content(post: Post) -> PostMsgContentInfo:\n\t    return {\"content\": PostMsgContent(post_id=post.post_id)}\n"]}
{"filename": "hertavilla/message/__init__.py", "chunked_list": ["from __future__ import annotations\n\tfrom .chain import MessageChain as MessageChain\n\tfrom .image import Image as Image\n\tfrom .post import Post as Post\n\tfrom .text import (\n\t    Link as Link,\n\t    MentionedAll as MentionedAll,\n\t    MentionedRobot as MentionedRobot,\n\t    MentionedUser as MentionedUser,\n\t    Quote as Quote,\n", "    VillaRoomLink as VillaRoomLink,\n\t)\n"]}
{"filename": "hertavilla/message/image.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING, Optional, cast\n\tfrom hertavilla.message.internal import MsgContent, MsgContentInfo, _Segment\n\tfrom hertavilla.typing import TypedDict\n\tif TYPE_CHECKING:\n\t    from hertavilla.bot import VillaBot\n\t# MsgContentInfo for image\n\tclass ImageMsgContentInfo(MsgContentInfo):\n\t    content: ImageMsgContent\n\t# Segment for image\n", "class Size(TypedDict):\n\t    width: int\n\t    height: int\n\tclass Image(_Segment):\n\t    def __init__(\n\t        self,\n\t        url: str,\n\t        width: int | None = None,\n\t        height: int | None = None,\n\t        file_size: int | None = None,\n", "    ) -> None:\n\t        if width is None and height is None:\n\t            self.size = None\n\t        elif width and height:\n\t            self.size = {\"width\": width, \"height\": height}\n\t        else:\n\t            raise ValueError(\n\t                \"Parameter width and height are not both None or int\",\n\t            )\n\t        self.url = url\n", "        self.file_size = file_size\n\t    async def get_text(self, _: VillaBot) -> str:\n\t        return \"[图片]\"\n\t# MsgContent for image\n\tclass ImageMsgContent(MsgContent):\n\t    url: str\n\t    size: Optional[Size] = None\n\t    file_size: Optional[int] = None\n\tdef image_to_content(image: Image) -> ImageMsgContent:\n\t    return ImageMsgContent(\n", "        url=image.url,\n\t        size=cast(Optional[Size], image.size),\n\t        file_size=image.file_size,\n\t    )\n"]}
{"filename": "hertavilla/server/_lifespan.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Any, Awaitable, Callable\n\tL_FUNC = Callable[[], Awaitable[Any]]\n\tclass LifespanManager:\n\t    def __init__(self) -> None:\n\t        self._startup_funcs: list[L_FUNC] = []\n\t        self._shutdown_funcs: list[L_FUNC] = []\n\t    def on_startup(self, func: L_FUNC) -> L_FUNC:\n\t        self._startup_funcs.append(func)\n\t        return func\n", "    def on_shutdown(self, func: L_FUNC) -> L_FUNC:\n\t        self._shutdown_funcs.append(func)\n\t        return func\n\t    async def startup(self) -> None:\n\t        if self._startup_funcs:\n\t            for func in self._startup_funcs:\n\t                await func()\n\t    async def shutdown(self) -> None:\n\t        if self._shutdown_funcs:\n\t            for func in self._shutdown_funcs:\n", "                await func()\n"]}
{"filename": "hertavilla/server/aiohttp.py", "chunked_list": ["from __future__ import annotations\n\timport functools\n\tfrom typing import Any\n\tfrom hertavilla.bot import VillaBot\n\tfrom hertavilla.server.internal import BaseBackend\n\tfrom ._lifespan import L_FUNC, LifespanManager\n\tfrom aiohttp import web\n\tclass AIOHTTPBackend(BaseBackend):\n\t    def __init__(self, host: str = \"0.0.0.0\", port: int = 8080, **kwargs: Any):\n\t        super().__init__(host, port, **kwargs)\n", "        self._app = web.Application()\n\t        self._lifespan_manager = LifespanManager()\n\t    @property\n\t    def app(self) -> web.Application:\n\t        return self._app\n\t    @property\n\t    def name(self) -> str:\n\t        return \"AIOHTTP\"\n\t    async def _run_startup(self, _: web.Application):\n\t        await self._lifespan_manager.startup()\n", "    async def _run_shutdown(self, _: web.Application):\n\t        await self._lifespan_manager.shutdown()\n\t    def run(\n\t        self,\n\t        *bots_: VillaBot,\n\t        host: str | None = None,\n\t        port: int | None = None,\n\t    ):\n\t        async def http_handle(request: web.Request):\n\t            resp = await self._run_handles(\n", "                request.headers.get(\"x-rpc-bot_sign\"),\n\t                (await request.text()).strip(),\n\t            )\n\t            return web.json_response(\n\t                {\"retcode\": resp.retcode, \"message\": resp.message},\n\t                status=resp.status_code,\n\t            )\n\t        self._register_bots(\n\t            bots_,\n\t            functools.partial(\n", "                self.app.router.add_post,\n\t                handler=http_handle,\n\t            ),\n\t        )\n\t        self.app.on_startup.append(self._run_startup)\n\t        self.app.on_cleanup.append(self._run_shutdown)\n\t        web.run_app(\n\t            self.app,\n\t            host=host or self.host,\n\t            port=port or self.port,\n", "            print=self.logger.info,\n\t        )\n\t    def on_startup(self, func: L_FUNC):\n\t        self._lifespan_manager.on_startup(func)\n\t    def on_shutdown(self, func: L_FUNC):\n\t        self._lifespan_manager.on_shutdown(func)\n"]}
{"filename": "hertavilla/server/internal.py", "chunked_list": ["from __future__ import annotations\n\timport abc\n\timport asyncio\n\tfrom dataclasses import dataclass\n\timport json\n\timport logging\n\tfrom typing import Any, Callable, Sequence\n\tfrom hertavilla.bot import VillaBot\n\tfrom hertavilla.event import parse_event\n\tfrom ._lifespan import L_FUNC\n", "background_tasks = set()\n\t@dataclass\n\tclass ResponseData:\n\t    status_code: int = 200\n\t    retcode: int = 0\n\t    message: str = \"\"\n\tINVALID_EVENT = ResponseData(400, -1, \"event body is invalid\")\n\tVERIFY_FAILED = ResponseData(401, -2, \"verify failed\")\n\tNO_BOT = ResponseData(404, 1, \"no bot with this id\")\n\tclass BaseBackend(abc.ABC):\n", "    def __init__(self, host: str = \"0.0.0.0\", port: int = 8080, **kwargs: Any):\n\t        self.host = host\n\t        self.port = port\n\t        self.backend_extra_config = kwargs\n\t        self.bots: dict[str, VillaBot] = {}\n\t        self.logger = logging.getLogger(\n\t            f\"hertavilla.backend.{self.name.lower()}\",\n\t        )\n\t    @abc.abstractproperty\n\t    def name(self) -> str:\n", "        raise NotImplementedError\n\t    @abc.abstractproperty\n\t    def app(self) -> Any:\n\t        raise NotImplementedError\n\t    @abc.abstractmethod\n\t    def run(\n\t        self,\n\t        *bots_: VillaBot,\n\t        host: str | None = None,\n\t        port: int | None = None,\n", "    ):\n\t        raise NotImplementedError\n\t    @abc.abstractmethod\n\t    def on_startup(self, func: L_FUNC):\n\t        raise NotImplementedError\n\t    @abc.abstractmethod\n\t    def on_shutdown(self, func: L_FUNC):\n\t        raise NotImplementedError\n\t    def _register_bots(\n\t        self,\n", "        bots: Sequence[VillaBot],\n\t        add_router_callback: Callable[[str], Any],\n\t    ) -> None:\n\t        for bot in bots:\n\t            self.bots[bot.bot_id] = bot\n\t            endpoint = bot.callback_endpoint\n\t            add_router_callback(endpoint)\n\t            self.logger.info(\n\t                f\"Register endpoint {endpoint} for bot {bot.bot_id}\",\n\t            )\n", "    async def _run_handles(\n\t        self,\n\t        sign: str | None,\n\t        body: str,\n\t    ) -> ResponseData:\n\t        payload = json.loads(body)\n\t        if not (event_payload := payload.get(\"event\")):\n\t            self.logger.warning(\"Event is invalid\")\n\t            return INVALID_EVENT\n\t        try:\n", "            event = parse_event(event_payload)\n\t        except ValueError:\n\t            self.logger.warning(\"Event is invalid\")\n\t            return INVALID_EVENT\n\t        if bot := self.bots.get(event.robot.template.id):\n\t            if sign is None or not bot.verify(sign, body):\n\t                logging.warn(\"Event verify check is failed. Reject handling.\")\n\t                return VERIFY_FAILED\n\t            self.logger.info(\n\t                (\n", "                    f\"[RECV] {event.__class__.__name__} \"\n\t                    f\"on bot {event.robot.template.name}\"\n\t                    f\"({event.robot.template.id}) \"\n\t                    f\"in villa {event.robot.villa_id}\"\n\t                ),\n\t            )\n\t            if bot._bot_info is None:  # noqa: SLF001\n\t                bot.bot_info = event.robot.template\n\t            task = asyncio.create_task(bot.handle_event(event))\n\t            background_tasks.add(task)\n", "            task.add_done_callback(background_tasks.discard)\n\t            return ResponseData()\n\t        self.logger.warning(\n\t            f\"Received event but no bot with id {event.robot.template.id}\",\n\t        )\n\t        return NO_BOT\n"]}
{"filename": "hertavilla/server/__init__.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Any\n\tfrom hertavilla.bot import VillaBot\n\tfrom hertavilla.server.aiohttp import AIOHTTPBackend\n\tfrom hertavilla.server.internal import BaseBackend\n\tDEFAULT_BACKEND = AIOHTTPBackend\n\t_backend: BaseBackend | None = None\n\tdef run(\n\t    *bots_: VillaBot,\n\t    host: str = \"0.0.0.0\",\n", "    port: int = 8080,\n\t    **kwargs: Any,\n\t):\n\t    backend = get_backend()\n\t    backend.run(*bots_, host=host, port=port, **kwargs)\n\tdef init_backend(\n\t    backend_class: type[BaseBackend] = DEFAULT_BACKEND,\n\t    host: str = \"0.0.0.0\",\n\t    port: int = 8080,\n\t) -> None:\n", "    global _backend  # noqa: PLW0603\n\t    if _backend is not None:\n\t        raise RuntimeError(\n\t            \"Backend has already been initialized\",\n\t        )\n\t    _backend = backend_class(host, port)\n\tdef get_backend() -> BaseBackend:\n\t    if _backend is None:\n\t        raise RuntimeError(\"Backend isn't initialized\")\n\t    return _backend\n"]}
{"filename": "hertavilla/server/fastapi.py", "chunked_list": ["from __future__ import annotations\n\tfrom contextlib import asynccontextmanager\n\timport functools\n\tfrom typing import Any\n\tfrom hertavilla.bot import VillaBot\n\tfrom hertavilla.server.internal import BaseBackend\n\tfrom ._lifespan import L_FUNC, LifespanManager\n\ttry:\n\t    from fastapi import FastAPI, Request\n\t    from fastapi.responses import JSONResponse\n", "    import uvicorn\n\texcept ImportError as e:\n\t    raise ImportError(\n\t        \"FastAPI Backend isn't installed. Please install extra `fastapi`\",\n\t    ) from e\n\tclass FastAPIBackend(BaseBackend):\n\t    def __init__(self, host: str = \"0.0.0.0\", port: int = 8080, **kwargs: Any):\n\t        super().__init__(host, port, **kwargs)\n\t        self._lifespan_manager = LifespanManager()\n\t        self._app = FastAPI(\n", "            lifespan=self.lifespan,\n\t            openapi_url=None,\n\t            docs_url=None,\n\t            include_in_schema=False,\n\t            redoc_url=None,\n\t        )\n\t    @property\n\t    def app(self) -> FastAPI:\n\t        return self._app\n\t    @property\n", "    def name(self) -> str:\n\t        return \"FastAPI\"\n\t    @asynccontextmanager\n\t    async def lifespan(self, _: FastAPI):\n\t        await self._lifespan_manager.startup()\n\t        try:\n\t            yield\n\t        finally:\n\t            await self._lifespan_manager.shutdown()\n\t    def run(\n", "        self,\n\t        *bots_: VillaBot,\n\t        host: str | None = None,\n\t        port: int | None = None,\n\t    ):\n\t        async def http_handle(request: Request) -> JSONResponse:\n\t            resp = await self._run_handles(\n\t                request.headers.get(\"x-rpc-bot_sign\"),\n\t                (await request.body()).decode().strip(),\n\t            )\n", "            return JSONResponse(\n\t                {\"retcode\": resp.retcode, \"message\": resp.message},\n\t                status_code=resp.status_code,\n\t            )\n\t        self._register_bots(\n\t            bots_,\n\t            functools.partial(\n\t                self.app.add_api_route,\n\t                endpoint=http_handle,\n\t                methods=[\"POST\"],\n", "            ),\n\t        )\n\t        uvicorn.run(\n\t            self.app,\n\t            host=host or self.host,\n\t            port=port or self.port,\n\t            log_config=None,\n\t        )\n\t    def on_startup(self, func: L_FUNC):\n\t        self._lifespan_manager.on_startup(func)\n", "    def on_shutdown(self, func: L_FUNC):\n\t        self._lifespan_manager.on_shutdown(func)\n"]}
{"filename": "tests/test_utils.py", "chunked_list": ["# ruff: noqa: PLR2004\n\tfrom __future__ import annotations\n\tdef test_utf16_cal():\n\t    from hertavilla.utils import _c, _rc\n\t    assert _c(\"你好\") == 2\n\t    assert _c(\"😊\") == 2\n\t    assert _rc(2) == 6\n\tdef test_msg_encoder():\n\t    import json\n\t    from hertavilla.message.internal import MsgContent\n", "    from hertavilla.utils import MsgEncoder\n\t    class TestMsgContent(MsgContent):\n\t        test: int = 1\n\t        _private: int = 0\n\t    assert json.loads(json.dumps(TestMsgContent(), cls=MsgEncoder)) == {\n\t        \"test\": 1,\n\t    }\n"]}
{"filename": "examples/message_segments.py", "chunked_list": ["from __future__ import annotations\n\tfrom hertavilla import (\n\t    Image,\n\t    Link,\n\t    MentionedAll,\n\t    MentionedRobot,\n\t    MentionedUser,\n\t    MessageChain,\n\t    Post,\n\t    SendMessageEvent,\n", "    VillaBot,\n\t    VillaRoomLink,\n\t    run,\n\t)\n\tfrom hertavilla.message.text import Text\n\tfrom hertavilla.server import init_backend\n\tbot = VillaBot(\n\t    \"bot_id\",\n\t    \"bot_secret\",\n\t    \"/\",\n", "    \"pub_key\",\n\t)\n\t@bot.listen(SendMessageEvent)  # 注册一个消息匹配器\n\tasync def _(event: SendMessageEvent, bot: VillaBot):\n\t    # 消息链\n\t    # 需要通过对这个链拼接构成消息\n\t    chain = MessageChain()\n\t    # Text: 文字类型\n\t    # https://webstatic.mihoyo.com/vila/bot/doc/message_api/msg_define/text_msg_content.html#textentity\n\t    # 可以直接添加 str，SDK 会自动转成 Text\n", "    # 以下两行代码等价\n\t    chain.append(\"hello\")\n\t    chain.append(Text(\"hello\"))\n\t    # Mention*: 提及类型\n\t    # @指定成员\n\t    # 注意需要填写大别野 ID\n\t    chain.append(MentionedUser(str(event.from_user_id), event.villa_id))\n\t    # @全体成员\n\t    chain.append(MentionedAll())\n\t    # @机器人（目前只能@自身）\n", "    chain.append(MentionedRobot(bot.bot_id))\n\t    # VillaRoomLink: 链接房间（#房间）\n\t    chain.append(VillaRoomLink(event.villa_id, event.room_id))\n\t    # Link: 链接\n\t    chain.append(Link(\"https://www.miyoushe.com/\"))\n\t    # Image: 图片\n\t    # https://webstatic.mihoyo.com/vila/bot/doc/message_api/msg_define/img_msg_content.html\n\t    chain.append(Image(url=\"\"))\n\t    # Post: 帖子转发\n\t    # https://webstatic.mihoyo.com/vila/bot/doc/message_api/msg_define/post_msg_content.html\n", "    chain.append(\n\t        Post(\"40569017\"),\n\t    )  # https://www.miyoushe.com/sr/article/40569017\n\t    # 请注意\n\t    # Post:\n\t    #   如果存在多个 Post，SDK 会选择最后一个 Post 发送\n\t    #   如果存在 Text，SDK 不会发送 Post\n\t    # Image:\n\t    #   如果存在 Text，则将使用 MHY:Text 发送，Web 端无法查看图片（不受支持）\n\t    #   如果存在多张图片，则将使用 MHY:Text 发送，Web 端无法查看（不受支持）\n", "init_backend()\n\trun(bot)\n"]}
{"filename": "examples/event_handle.py", "chunked_list": ["from __future__ import annotations\n\tfrom hertavilla import Event, SendMessageEvent, VillaBot, run\n\tfrom hertavilla.match import MatchResult, Regex\n\tfrom hertavilla.server import init_backend\n\tbot = VillaBot(\n\t    \"bot_id\",\n\t    \"bot_secret\",\n\t    \"/\",\n\t    \"pub_key\",\n\t)\n", "# bot.listen 装饰器用来监听指定类型的事件\n\t@bot.listen(Event)\n\tasync def _(event: Event, bot: VillaBot):\n\t    ...\n\t# 手动注册（不建议）\n\tasync def handler(event: Event, bot: VillaBot):\n\t    ...\n\tbot.register_handler(Event, handler)\n\t# @bot.regex(\"a|b|c\")  # 正则匹配 -- RegexResult\n\t# @bot.startswith(\"/\")  # 前缀匹配 -- StartswithResult\n", "# @bot.endswith(\".\")  # 后缀匹配 -- EndswithResult\n\t# @bot.keyword(\"a\", \"b\")  # 关键词匹配 -- KeywordsResult\n\t# bot.match 会要求填入一个 Match 进行匹配\n\t# 上面的四个方法分别是 Regex、Startswith、Endswith、Keywords 的语法糖\n\t@bot.match(Regex(\"a|b|c\"))  # 等价于 @bot.regex(\"a|b|c\")\n\tasync def _(event: SendMessageEvent, bot: VillaBot, match_result: MatchResult):\n\t    # match_result 参数用于获取从匹配器获得的匹配信息\n\t    ...\n\tinit_backend()\n\trun(bot)\n"]}
