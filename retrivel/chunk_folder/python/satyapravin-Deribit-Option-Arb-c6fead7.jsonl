{"filename": "src/optarber/selection_data.py", "chunked_list": ["class SelectionData:\n\t\tdef __init__(self):\n\t\t\tself.positions = []\n\t\t\tself.cols = 10\n\t\tdef clear(self):\n\t\t\tself.positions = []\n\t\t\tself.cols = 10\n\t\tdef update(self, positions):\n\t\t\tself.positions = positions\n\t\tdef getRows(self):\n", "\t\treturn len(self.positions) + 1\n\t\tdef getCols(self):\n\t\t\treturn self.cols\n\t\tdef getData(self, j, i):\n\t\t\tif j == 0:\n\t\t\t\tif i == 0:\n\t\t\t\t\treturn \"Instr\"\n\t\t\t\telif i == 1:\n\t\t\t\t\treturn \"Size\"\n\t\t\t\telif i == 2:\n", "\t\t\t\treturn \"BidAmount\"\n\t\t\t\telif i == 3:\n\t\t\t\t\treturn \"BidPrice\"\n\t\t\t\telif i == 4:\n\t\t\t\t\treturn \"AskPrice\"\n\t\t\t\telif i == 5:\n\t\t\t\t\treturn \"AskAmount\"\n\t\t\t\telif i == 6:\n\t\t\t\t\treturn \"Delta\"\n\t\t\t\telif i == 7:\n", "\t\t\t\treturn \"Gamma\"\n\t\t\t\telif i == 8:\n\t\t\t\t\treturn \"Vega\"\n\t\t\t\telif i == 9:\n\t\t\t\t\treturn \"Theta\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"\"\n\t\t\telse:\n\t\t\t\top = self.positions[j-1].op\n\t\t\t\tsize = self.positions[j-1].size\n", "\t\t\tif i == 0:\n\t\t\t\t\treturn op.name\n\t\t\t\telif i == 1:\n\t\t\t\t\treturn size\n\t\t\t\telif i == 2:\n\t\t\t\t\treturn op.bid_amount\n\t\t\t\telif i == 3:\n\t\t\t\t\treturn op.bid_price\n\t\t\t\telif i == 4:\n\t\t\t\t\treturn op.ask_price\n", "\t\t\telif i == 5:\n\t\t\t\t\treturn op.ask_amount\n\t\t\t\telif i == 6:\n\t\t\t\t\treturn size * op.delta\n\t\t\t\telif i == 7:\n\t\t\t\t\treturn size * op.gamma\n\t\t\t\telif i == 8:\n\t\t\t\t\treturn size * op.vega\n\t\t\t\telif i == 9:\n\t\t\t\t\treturn size * op.theta\n", "\t\t\telse:\n\t\t\t\t\treturn 0"]}
{"filename": "src/optarber/optimise_params.py", "chunked_list": ["class OptimiseParams:\n\t    def __init__(self):\n\t        self.minimize = True\n\t        self.currObjective = \"Min Cost\"\n\t        self.maxDeltaPct = 0.01\n\t        self.minTheta = 5\n\t        self.minGammaBps = 0.001\n\t        self.putNeutral = True\n\t        self.callNeutral = True\n\t        self.positiveVega = True\n", "        self.longPut = True\n\t        self.longCall = True\n\t        self.maxUnit = 5\n\t        self.maxTotal = 15\n\t        self.usePositions = True\n\t        self.maxSpreadBps = 0.001\n\t        self.contract_size = 1\n\t        self.doubleFee = True\n\t    @staticmethod\n\t    def create_default():\n", "        return OptimiseParams()"]}
{"filename": "src/optarber/account_data.py", "chunked_list": ["class AccountData:\n\t\tdef __init__(self):\n\t\t\tself.currency = None\n\t\t\tself.equity = 0\n\t\t\tself.availableMargin = 0\n\t\t\tself.initialMargin = 0\n\t\t\tself.maintenanceMargin = 0\n\t\t\tself.withdrawableFunds = 0\n\t\t\tself.PnL = 0\n\t\t\tself.delta = 0\n", "\t\tself.gamma = 0\n\t\t\tself.vega = 0\n\t\t\tself.theta = 0\n\t\t\tself.rows = 11\n\t\t\tself.cols = 2\n\t\tdef clear(self):\n\t\t\tself.currency = \"\"\n\t\t\tself.equity = 0\n\t\t\tself.availableMargin = 0\n\t\t\tself.initialMargin = 0\n", "\t\tself.maintenanceMargin = 0\n\t\t\tself.withdrawableFunds = 0\n\t\t\tself.PnL = 0\n\t\t\tself.delta = 0\n\t\t\tself.gamma = 0\n\t\t\tself.vega = 0\n\t\t\tself.theta = 0\n\t\t\tself.rows = 11\n\t\t\tself.cols = 2\n\t\tdef update(self, dict_obj):\n", "\t\tself.currency = dict_obj['currency']\n\t\t\tself.equity = dict_obj[\"equity\"]\n\t\t\tself.availableMargin = dict_obj[\"margin_balance\"]\n\t\t\tself.initialMargin = dict_obj[\"initial_margin\"]\n\t\t\tself.maintenanceMargin = dict_obj[\"maintenance_margin\"]\n\t\t\tself.withdrawableFunds = dict_obj[\"available_withdrawal_funds\"]\n\t\t\tself.PnL = dict_obj[\"total_pl\"]\n\t\t\tself.delta = dict_obj[\"options_delta\"]\n\t\t\tself.gamma = dict_obj[\"options_gamma\"]\n\t\t\tself.vega = dict_obj[\"options_vega\"]\n", "\t\tself.theta = dict_obj[\"options_theta\"]\n\t\tdef getRows(self):\n\t\t\treturn self.rows\n\t\tdef getCols(self):\n\t\t\treturn self.cols\n\t\tdef getData(self, i, j):\n\t\t\tif j == 0:\n\t\t\t\tif i == 0:\n\t\t\t\t\treturn \"Currency\"\n\t\t\t\telif i == 1:\n", "\t\t\t\treturn \"Equity\"\n\t\t\t\telif i == 2:\n\t\t\t\t\treturn \"margin_bal\"\n\t\t\t\telif i == 3:\n\t\t\t\t\treturn \"init_margin\"\n\t\t\t\telif i == 4:\n\t\t\t\t\treturn \"mnt_margin\"\n\t\t\t\telif i == 5:\n\t\t\t\t\treturn \"avlble_funds\"\n\t\t\t\telif i == 6:\n", "\t\t\t\treturn \"PnL\"\n\t\t\t\telif i == 7:\n\t\t\t\t\treturn \"Delta\"\n\t\t\t\telif i == 8:\n\t\t\t\t\treturn \"Gamma\"\n\t\t\t\telif i == 9:\n\t\t\t\t\treturn \"Vega\"\n\t\t\t\telif i == 10:\n\t\t\t\t\treturn \"Theta\"\n\t\t\t\telse:\n", "\t\t\t\treturn \"\"\n\t\t\telse:\n\t\t\t\tif i == 0:\n\t\t\t\t\treturn self.currency\n\t\t\t\telif i == 1:\n\t\t\t\t\treturn self.equity\n\t\t\t\telif i == 2:\n\t\t\t\t\treturn self.availableMargin\n\t\t\t\telif i == 3:\n\t\t\t\t\treturn self.initialMargin\n", "\t\t\telif i == 4:\n\t\t\t\t\treturn self.maintenanceMargin\n\t\t\t\telif i == 5:\n\t\t\t\t\treturn self.withdrawableFunds\n\t\t\t\telif i == 6:\n\t\t\t\t\treturn self.PnL\n\t\t\t\telif i == 7:\n\t\t\t\t\treturn self.delta\n\t\t\t\telif i == 8:\n\t\t\t\t\treturn self.gamma\n", "\t\t\telif i == 9:\n\t\t\t\t\treturn self.vega\n\t\t\t\telif i == 10:\n\t\t\t\t\treturn self.theta\n\t\t\t\telse:\n\t\t\t\t\treturn 0"]}
{"filename": "src/optarber/account_model.py", "chunked_list": ["from PyQt6 import QtCore, QtGui\n\tfrom account_data import AccountData\n\tclass AccountModel(QtCore.QAbstractTableModel): \n\t    def __init__(self, parent=None, *args): \n\t        super(AccountModel, self).__init__()\n\t        self.accountData = None\n\t    def update(self, accountData):\n\t        self.accountData = accountData\n\t    def rowCount(self, parent=QtCore.QModelIndex()):\n\t        return self.accountData.getRows()\n", "    def columnCount(self, parent=QtCore.QModelIndex()):\n\t        return self.accountData.getCols()\n\t    def data(self, index, role=QtCore.Qt):\n\t        if self.accountData is not None:\n\t            i = index.row()\n\t            j = index.column()\n\t            if role == QtCore.Qt.ItemDataRole.DisplayRole:\n\t                if j == 0 or i == 0:\n\t                    return '{0}'.format(self.accountData.getData(i, j))\n\t                elif i > 0 and j == 1:\n", "                    return '{:.8f}'.format(self.accountData.getData(i, j))\n\t            elif role == QtCore.Qt.ItemDataRole.TextAlignmentRole:\n\t                if j == 1:\n\t                    return QtCore.Qt.AlignmentFlag.AlignRight\n\t            elif role == QtCore.Qt.ItemDataRole.ForegroundRole:\n\t                if j == 1 and i > 0:\n\t                    if self.accountData.getData(i, j) > 0:\n\t                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkBlue)\n\t                    elif self.accountData.getData(i, j) < 0:\n\t                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkRed)\n", "            return QtCore.QVariant()"]}
{"filename": "src/optarber/position_model.py", "chunked_list": ["from PyQt6 import QtCore, QtGui\n\tclass PositionModel(QtCore.QAbstractTableModel): \n\t    def __init__(self, parent=None, *args): \n\t        super(PositionModel, self).__init__()\n\t        self.positionData = None\n\t    def update(self, positionData):\n\t        self.positionData = positionData\n\t    def rowCount(self, parent=QtCore.QModelIndex()):\n\t        return self.positionData.getRows()\n\t    def columnCount(self, parent=QtCore.QModelIndex()):\n", "        return self.positionData.getCols()\n\t    def data(self, index, role=QtCore.Qt):\n\t        if self.positionData is not None:\n\t            i = index.row()\n\t            j = index.column()\n\t            if role == QtCore.Qt.ItemDataRole.DisplayRole:\n\t                if j == 0 or i == 0:\n\t                    return '{0}'.format(self.positionData.getData(i, j))\n\t                elif i > 0 and j > 0:\n\t                    return '{:.4f}'.format(self.positionData.getData(i, j))\n", "            elif role == QtCore.Qt.ItemDataRole.TextAlignmentRole:\n\t                if j > 0 and i > 0:\n\t                    return QtCore.Qt.AlignmentFlag.AlignRight\n\t            elif role == QtCore.Qt.ItemDataRole.ForegroundRole:\n\t                if j > 0 and i > 0:\n\t                    if self.positionData.getData(i, j) > 0:\n\t                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkBlue)\n\t                    elif self.positionData.getData(i, j) < 0:\n\t                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkRed)\n\t            return QtCore.QVariant()"]}
{"filename": "src/optarber/optimizer.py", "chunked_list": ["import cvxpy as cvx\n\timport numpy as np\n\tfrom deribit_option_position import DeribitPosition\n\tclass Optimizer:\n\t    def __init__(self, params, fetches, positions):\n\t        self.params = params\n\t        self.fetches = fetches\n\t        self.positions = positions\n\t    def compute(self):\n\t        option_dict = {}\n", "        for op in self.fetches:\n\t            if op.ask_price is not None and op.bid_price is not None:\n\t                if (op.ask_price - op.bid_price) <= self.params.maxSpreadBps:\n\t                    option_dict[op.name] = op\n\t        for pos in self.positions:\n\t            if pos.op.name not in option_dict:\n\t                if self.params.usePositions:\n\t                    option_dict[pos.op.name] = pos.op\n\t            else:\n\t                if not self.params.usePositions:\n", "                    option_dict.pop(pos.op.name)\n\t        option_data = list(option_dict.values())\n\t        N = len(option_data)\n\t        deltas = np.zeros(N)\n\t        gammas = np.zeros(N)\n\t        vegas = np.zeros(N)\n\t        thetas = np.zeros(N)\n\t        bids = np.zeros(N)\n\t        bidamounts = np.zeros(N)\n\t        askamounts = np.zeros(N)\n", "        asks = np.zeros(N)\n\t        calls = np.zeros(N)\n\t        puts = np.zeros(N)\n\t        strikes = np.zeros(N)\n\t        for i in range(0, N):\n\t            deltas[i] = option_data[i].delta\n\t            gammas[i] = option_data[i].gamma\n\t            vegas[i] = option_data[i].vega\n\t            thetas[i] = option_data[i].theta\n\t            bids[i] = option_data[i].bid_price\n", "            asks[i] = option_data[i].ask_price\n\t            bidamounts[i] = option_data[i].bid_amount / self.params.contract_size\n\t            askamounts[i] = option_data[i].ask_amount / self.params.contract_size\n\t            kind = 1 if option_data[i].kind[0] == 'c' else -1\n\t            calls[i] = max(kind, 0)\n\t            puts[i] = min(kind, 0)\n\t            strikes[i] = option_data[i].strike\n\t        res = self._calculate(list(option_dict.keys()), deltas, gammas, vegas, thetas, bids, asks, bidamounts, askamounts, calls, puts, strikes)\n\t        selections = []\n\t        if res is not None:\n", "            for i, op in enumerate(option_data):\n\t                if res[0, i] != 0:\n\t                    p = DeribitPosition(op, res[0, i])\n\t                    selections.append(p)\n\t        return selections\n\t    def _calculate(self, option_names, deltas, gammas, vegas, thetas, bids, asks, bidamounts, askamounts, calls, puts, strikes):\n\t        N = len(option_names)\n\t        if N == 0:\n\t            return None\n\t        x = cvx.Variable((1, N), integer=True)\n", "        y = cvx.Variable((1, N), integer=True)\n\t        p = cvx.Variable((1, N), integer=True)\n\t        obj = None\n\t        if self.params.currObjective == \"Min Cost\":\n\t            obj = cvx.Minimize(x@asks + y@bids)\n\t        elif self.params.currObjective == \"Max Gamma\":\n\t            obj = cvx.Maximize((x+y+p)@gammas)\n\t        elif self.params.currObjective == \"Max Theta\":\n\t            obj = cvx.Maximize((x+y+p)@thetas)\n\t        else:\n", "            return None\n\t        cons = [(x+y+p)@deltas <= self.params.maxDeltaPct, \n\t                (x+y+p)@deltas >= -self.params.maxDeltaPct]\n\t        cons.append((x+y+p)@gammas >= self.params.minGammaBps)\n\t        cons.append((x+y+p)@thetas >= self.params.minTheta)\n\t        if self.params.positiveVega: cons.append((x+y+p)@vegas >= 0)\n\t        if self.params.callNeutral: cons.append((x+y+p)@calls == 0)\n\t        if self.params.putNeutral: cons.append((x+y+p)@puts == 0)\n\t        if self.params.longPut: cons.append(cvx.multiply(y[0, :] + x[0, :] + p[0, :], puts)@strikes <= 0)\n\t        if self.params.longCall: cons.append(cvx.multiply(y[0, :] + x[0, :] + p[0, :], calls)@strikes >= 0)\n", "        cons.append(x <= self.params.maxUnit)\n\t        cons.append(x >= 0)\n\t        cons.append(y >= -self.params.maxUnit)\n\t        cons.append(y <= 0)\n\t        cons.append(cvx.sum(x + cvx.pos(p)) <= self.params.maxTotal)\n\t        cons.append(cvx.sum(y - cvx.neg(p)) >= -self.params.maxTotal)\n\t        sizes = np.zeros((1, N))\n\t        if self.params.usePositions:\n\t            for pos in self.positions:\n\t                idx = option_names.index(pos.op.name)\n", "                sizes[0, idx] = pos.size  / self.params.contract_size\n\t        cons.append(p == np.asarray(sizes))\n\t        for i in range(N):\n\t            cons.append(x[0, i] <= askamounts[i])\n\t            cons.append(y[0, i] >= -bidamounts[i])\n\t        prob = cvx.Problem(objective=obj, constraints=cons)\n\t        prob.solve(verbose=1)\n\t        if prob.status == 'optimal':\n\t            return np.around((x.value + y.value) * self.params.contract_size, 1)\n\t        else:\n", "            return None"]}
{"filename": "src/optarber/program.py", "chunked_list": ["import sys\n\tfrom mainUI import Ui_optionAtillaWindow\n\tfrom optionAtilla import Atilla\n\tfrom PyQt6 import QtCore\n\tfrom PyQt6.QtWidgets import QApplication, QMainWindow\n\tif __name__ == '__main__':\n\t    app = QApplication(sys.argv)\n\t    window = QMainWindow()\n\t    ui = Ui_optionAtillaWindow()\n\t    ui.setupUi(window)\n", "    atilla = Atilla(app, \"config.ini\")\n\t    atilla.setWindow(ui, window)\n\t    window.show()\n\t    sys.exit(app.exec())\n"]}
{"filename": "src/optarber/optionAtilla.py", "chunked_list": ["import configparser\n\tfrom datetime import datetime as dt\n\timport opstrat\n\tfrom account_data import AccountData\n\tfrom image_viewer import ImageViewer\n\tfrom position_data import PositionData\n\tfrom results_data import Results\n\tfrom selection_data import SelectionData\n\tfrom account_model import AccountModel\n\tfrom optimise_params import OptimiseParams\n", "from optimizer import Optimizer\n\tfrom deribit_option import Option\n\tfrom deribit_option_position import DeribitPosition\n\tfrom position_model import PositionModel\n\tfrom results_model import ResultsModel\n\tfrom selection_model import SelectionModel\n\tfrom deribit_rest import RestClient\n\tfrom deribit_ws import Deribit_WS\n\tfrom PyQt6 import QtCore\n\tclass Atilla(QtCore.QObject):\n", "\tdef __init__(self, parent, config_file):\n\t\t\tsuper().__init__(parent)\n\t\t\tself.parent = parent\n\t\t\tself.currency = None\n\t\t\tself.counter = 0\n\t\t\tself.subscriptions = 0\n\t\t\tself.subscribed = set()\n\t\t\tself.market_cache = {}\n\t\t\tself.fetches = []\n\t\t\tself.account = AccountData()\n", "\t\tself.positions = PositionData()\n\t\t\tself.selections = SelectionData()\n\t\t\tself.results = Results()\n\t\t\tself.account_model = AccountModel(parent)\n\t\t\tself.position_model = PositionModel(parent)\n\t\t\tself.selection_model = SelectionModel(parent)\n\t\t\tself.results_model = ResultsModel(parent)\n\t\t\tself.account_model.update(self.account)\n\t\t\tself.position_model.update(self.positions)\n\t\t\tself.selection_model.update(self.selections)\n", "\t\tself.results_model.update(self.results)\n\t\t\tself.cfg = configparser.ConfigParser()\n\t\t\tself.cfg.read(config_file)\n\t\t\tself.client_ws = None\n\t\t\tself.client_rest = None\n\t\t\tself.window = None\n\t\t\tself.mainW = None\n\t\tdef setWindow(self, window, mainW):\n\t\t\tself.window = window\n\t\t\tself.mainW = mainW\n", "\t\tself.window.tableViewAccount.setModel(self.account_model)\n\t\t\tself.window.tableViewPositions.setModel(self.position_model)\n\t\t\tself.window.tableViewResults.setModel(self.results_model)\n\t\t\tself.window.tableViewSelections.setModel(self.selection_model)\n\t\t\tself.window.pushButtonConnect.clicked.connect(self.connect)\n\t\t\tself.window.pushButtonClose.clicked.connect(self.close)\n\t\t\tself.window.pushButtonFetch.clicked.connect(self.fetch)\n\t\t\tself.window.pushButtonPositions.clicked.connect(self.queryPos)\n\t\t\tself.window.pushButtonDisplay.clicked.connect(self.display)\n\t\t\tself.window.pushButtonCompute.clicked.connect(self.compute)\n", "\t\tself.window.pushButtonRefresh.clicked.connect(self.computeResults)\n\t\t\tself.window.pushButtonClearSelection.clicked.connect(self.clearSelections)\n\t\t\tself.window.pushButtonTrade.clicked.connect(self.execute)\n\t\t\tQtCore.QMetaObject.connectSlotsByName(self)\n\t\tdef close(self):\n\t\t\tself.disconnect()\n\t\t\tself.window.centralwidget.close()\n\t\tdef authenticate(self):\n\t\t\tself.client_ws.authenticate()\n\t\t\tprint(\"sent authenticate request\")\n", "\tdef getChanges(self):\n\t\t\tcurr = self.window.comboCurr.currentText()\n\t\t\tself.client_ws.account_summary(curr)\n\t\t\tself.client_ws.change_summary(curr)\n\t\tdef connect(self):\n\t\t\tself.disconnect()\n\t\t\tkey = self.window.comboEnv.currentText()\n\t\t\tcurr = self.window.comboCurr.currentText()\n\t\t\tapi_key = self.cfg[key][\"api_key\"]\n\t\t\tapi_secret = self.cfg[key][\"api_secret\"]\n", "\t\tws_url = self.cfg[key][\"ws_url\"]\n\t\t\tself.client_rest = RestClient(api_key, api_secret, False if key == \"PROD\" else True)\n\t\t\tself.client_ws = Deribit_WS(self.parent)\n\t\t\tself.client_ws.connect(self, api_key, api_secret, ws_url)\n\t\t\tQtCore.QTimer.singleShot(3000, self.authenticate)\n\t\t\tQtCore.QTimer.singleShot(6000, self.getChanges)\n\t\tdef onMarketData(self, mkt_data):\n\t\t\tinstr = mkt_data['instrument_name']\n\t\t\tif instr not in self.subscribed:\n\t\t\t\tself.subscribed.add(instr)\n", "\t\t\tself.window.progressBarFetch.setVisible(False)\n\t\t\t\tself.window.progressBarFetch.setValue(len(self.subscribed) * 100.0 / self.counter)\n\t\t\t\tself.window.progressBarFetch.setVisible(True)\n\t\t\tgreeks = mkt_data['greeks']\n\t\t\topt = self.market_cache[instr]\n\t\t\topt.delta = greeks['delta']\n\t\t\topt.gamma = greeks['gamma'] \n\t\t\topt.vega=greeks['vega']\n\t\t\topt.theta = greeks['theta']\n\t\t\topt.bid_price = mkt_data['best_bid_price']\n", "\t\topt.bid_amount = mkt_data['best_bid_amount']\n\t\t\topt.ask_price = mkt_data['best_ask_price']\n\t\t\topt.ask_amount = mkt_data['best_ask_amount']\n\t\t\tself.window.tableViewPositions.viewport().update()\n\t\t\tself.window.tableViewSelections.viewport().update()\n\t\tdef onAccountData(self, dict_obj):\n\t\t\tself.account.update(dict_obj)\n\t\t\tself.window.tableViewAccount.viewport().update()\n\t\tdef onPositionCreate(self, positions):\n\t\t\tself.position_model.beginResetModel()\n", "\t\tself.positions.add(positions)\n\t\t\tself.position_model.endResetModel()\n\t\t\tself.window.tableViewPositions.resizeColumnsToContents()\n\t\t\tself.window.tableViewPositions.viewport().update()\n\t\tdef onPositionData(self, positions):\n\t\t\tself.positions.update(positions)\n\t\t\tself.window.tableViewPositions.viewport().update()\n\t\tdef disconnect(self):\n\t\t\tif self.client_ws is not None:\n\t\t\t\tself.client_ws.close()\n", "\t\t\tself.client_ws = None\n\t\t\tself.account_model.beginResetModel()\n\t\t\tself.position_model.beginResetModel()\n\t\t\tself.selection_model.beginResetModel()\n\t\t\tself.results_model.beginResetModel()\n\t\t\tself.account.clear()\n\t\t\tself.positions.clear()\n\t\t\tself.market_cache.clear()\n\t\t\tself.subscribed.clear()\n\t\t\tself.selections.clear()\n", "\t\tself.results.clear()\n\t\t\tself.account_model.endResetModel()\n\t\t\tself.position_model.endResetModel()\n\t\t\tself.selection_model.endResetModel()\n\t\t\tself.results_model.endResetModel()\n\t\t\tself.counter = 0\n\t\t\tself.subscriptions = 0\n\t\t\tself.fetches = []\n\t\tdef queryPos(self):\n\t\t\tcurr = self.window.comboCurr.currentText()\n", "\t\tpositions = self.client_rest.getpositions(curr, \"option\")\n\t\t\tnow = dt.today()\n\t\t\tresults = []\n\t\t\tfor pos in positions:\n\t\t\t\tname = pos['instrument_name']\n\t\t\t\tinstr = self.client_rest.getinstrument(name)\n\t\t\t\texpiry = self.timestamp_to_datetime(instr['expiration_timestamp'])\n\t\t\t\tdays_left = (expiry - now).days\n\t\t\t\tsize = pos['size']\n\t\t\t\topt = Option(name, instr['option_type'], days_left, instr['strike'], \n", "\t\t                 pos['delta'] / size,pos['gamma'] / size,pos['vega'] / size, pos['theta'] / size,0,0,0,0)\n\t\t\t\tdpos = DeribitPosition(opt, pos['size'])\n\t\t\t\tresults.append(dpos)\n\t\t\t\tif name not in self.market_cache.keys():\n\t\t\t\t\tself.market_cache[name] = opt\n\t\t\t\t\tself.counter += 1\n\t\t\t\t\tQtCore.QThread.msleep(100)\n\t\t\t\t\tself.client_ws.ticker(name)\n\t\t\tself.onPositionCreate(results)\n\t\tdef fetch(self):\n", "\t\tself.window.progressBarFetch.setValue(0)\n\t\t\tself.fetches = []\n\t\t\tcurr = self.window.comboCurr.currentText()\n\t\t\tpctStrike = self.window.spinBoxStrikePercent.value() / 100.0\n\t\t\tminExpiry = self.window.spinBoxMinExpiry.value()\n\t\t\tmaxExpiry = self.window.spinBoxMaxExpiry.value()\n\t\t\tresponse = self.client_rest.getindex(curr)\n\t\t\tidxPrice = response[curr]\n\t\t\tnow = dt.today()\n\t\t\tself.queryPos()\n", "\t\tself.fetchInstruments(now, curr, idxPrice, pctStrike, minExpiry, maxExpiry)\n\t\t\tself.window.progressBarFetch.setValue(len(self.subscribed) * 100.0 / self.counter)\n\t\t\tself.window.labelNumOfOptions.setText(str(self.counter) + \" options\")\n\t\tdef timestamp_to_datetime(self, timestamp): \n\t\t\treturn dt.fromtimestamp(timestamp/1000)\n\t\tdef fetchInstruments(self, now, curr, idxPrice, pctStrike, minExpiry, maxExpiry):\n\t\t\tinstrs = self.client_rest.getinstruments(curr, \"option\")\n\t\t\tminStrike = (1.0 - pctStrike) * idxPrice\n\t\t\tmaxStrike = (1.0 + pctStrike) * idxPrice\n\t\t\tfor instr in instrs:\n", "\t\t\tif instr['option_type'] == 'call' and instr['strike'] < idxPrice:\n\t\t\t\t\tcontinue\n\t\t\t\tif instr['option_type'] == 'put' and instr['strike'] > idxPrice:\n\t\t\t\t\tcontinue\n\t\t\t\tif instr['strike'] >= minStrike and instr['strike'] <= maxStrike:\n\t\t\t\t\texpiry = instr['expiration_timestamp']\n\t\t\t\t\tdays_left = (self.timestamp_to_datetime(expiry) - now).days\n\t\t\t\t\tif days_left >= minExpiry and days_left <= maxExpiry:\n\t\t\t\t\t\tname = instr['instrument_name']\n\t\t\t\t\t\tif name not in self.market_cache.keys():\n", "\t\t\t\t\t\tself.market_cache[name] = Option(name, instr['option_type'], days_left,\n\t\t\t\t\t\t                                      instr['strike'], 0,0,0,0,0,0,0,0)\n\t\t\t\t\t\t\tself.counter += 1\n\t\t\t\t\t\t\tQtCore.QThread.msleep(300)\n\t\t\t\t\t\t\tself.client_ws.ticker(name)\n\t\t\t\t\t\tself.fetches.append(self.market_cache[name])\n\t\tdef display(self):\n\t\t\tpositions = self.positions.positions\n\t\t\toplist = []\n\t\t\tcurr = self.window.comboCurr.currentText()\n", "\t\tcontract_size = 1\n\t\t\tif curr == \"BTC\":\n\t\t\t\tcontract_size = 0.1\n\t\t\tfor posit in positions:\n\t\t\t\tpos = posit.op\n\t\t\t\top = {'op_type': pos.kind[0],\n\t            \t\t'strike': pos.strike,\n\t            \t\t'tr_type': 'b' if posit.size > 0 else 's',\n\t            \t\t'op_pr': pos.bid_price if posit.size < 0 else pos.ask_price,\n\t            \t\t'contract': abs(int(posit.size / contract_size))}\n", "\t\t\toplist.append(op)\n\t\t\tfor posit in self.selections.positions:\n\t\t\t\tpos = posit.op\n\t\t\t\top = {'op_type': pos.kind[0],\n\t            \t\t'strike': pos.strike,\n\t            \t\t'tr_type': 'b' if posit.size > 0 else 's',\n\t            \t\t'op_pr': pos.bid_price if posit.size < 0 else pos.ask_price,\n\t            \t\t'contract': abs(int(posit.size / contract_size))}\n\t\t\t\toplist.append(op)\n\t\t\tidx_price = self.client_rest.getindex(curr)[curr]\n", "\t\topstrat.multi_plotter(spot=idx_price, spot_range=20, op_list=oplist, save=True, file='file.png')\n\t\t\tviewer = ImageViewer()\n\t\t\tviewer.update()\n\t\t\tviewer.show()\n\t\t\tviewer.deleteLater()\n\t\tdef create_optimiser_params(self):\n\t\t\tcurr = self.window.comboCurr.currentText()\n\t\t\tparams = OptimiseParams.create_default()\n\t\t\tif curr == 'BTC':\n\t\t\t\tparams.contract_size = 0.1\n", "\t\telse:\n\t\t\t\tparams.contract_size = 1\n\t\t\tparams.currObjective = self.window.comboObjective.currentText()\n\t\t\tparams.maxDeltaPct = self.window.spinDelta.value() / 100.0\n\t\t\tparams.minGammaBps = self.window.spinGamma.value() / 10000.0\n\t\t\tparams.minTheta = self.window.spinMinTheta.value()\n\t\t\tparams.positiveVega = self.window.checkVega.isChecked()\n\t\t\tparams.putNeutral = self.window.checkPutNeutral.isChecked()\n\t\t\tparams.callNeutral = self.window.checkCallNeutral.isChecked()\n\t\t\tparams.longPut = self.window.checkLongPut.isChecked()\n", "\t\tparams.longCall = self.window.checkLongCall.isChecked()\n\t\t\tparams.usePositions = self.window.checkPositions.isChecked()\n\t\t\tparams.maxUnit = self.window.spinMaxUnit.value()\n\t\t\tparams.maxTotal = self.window.spinMaxTotal.value()\n\t\t\tparams.maxSpreadBps = self.window.spinBoxSpread.value() / 10000.0\n\t\t\tparams.doubleFee = self.window.checkDoubleFee.isChecked()\n\t\t\treturn params\n\t\tdef clearSelections(self):\n\t\t\tself.selection_model.beginResetModel()\n\t\t\tself.selections.update([])\n", "\t\tself.selection_model.endResetModel()\n\t\tdef compute(self):\n\t\t\tparams = self.create_optimiser_params()\n\t\t\toptim = Optimizer(params, self.fetches, self.positions.positions)\n\t\t\tselections = optim.compute()\n\t\t\tself.selection_model.beginResetModel()\n\t\t\tself.selections.update(selections)\n\t\t\tself.selection_model.endResetModel()\n\t\t\tself.window.tableViewSelections.resizeColumnsToContents()\n\t\t\tself.window.tableViewSelections.viewport().update()\n", "\t\tself.computeResults()\n\t\tdef computeResults(self):\n\t\t\tpositions = []\n\t\t\tpositions.extend(self.positions.positions)\n\t\t\tpositions.extend(self.selections.positions)\n\t\t\tfeeBps = 0.0006 if self.window.checkDoubleFee.isChecked() else 0.0003\n\t\t\tself.results_model.beginResetModel()\n\t\t\tself.results.clear()\n\t\t\tinstrs = {}\n\t\t\tposCheck = self.window.checkPositions.isChecked()\n", "\t\tfor pos in positions:\n\t\t\t\tself.results.delta += pos.size * pos.op.delta\n\t\t\t\tself.results.gamma += pos.size * pos.op.gamma\n\t\t\t\tself.results.vega += pos.size * pos.op.vega\n\t\t\t\tself.results.theta += pos.size * pos.op.theta\n\t\t\t\tif not posCheck and pos in self.positions.positions:\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tif pos.op.name in instrs:\n\t\t\t\t\t\tinstrs[pos.op.name] += pos.size\n", "\t\t\t\telse:\n\t\t\t\t\t\tinstrs[pos.op.name] = pos.size\n\t\t\tfor pos in self.selections.positions:\n\t\t\t\tcost = pos.size * (pos.op.bid_price if pos.size < 0 else pos.op.ask_price)\n\t\t\t\tself.results.income += cost\n\t\t\t\tself.results.fees += min(abs(pos.size * feeBps), abs(cost) * 0.125)\n\t\t\tself.results.net_income = -self.results.income - self.results.fees\n\t\t\tcurr = self.window.comboCurr.currentText()\n\t\t\tif len(instrs) > 0:\n\t\t\t\tres = self.client_rest.getportfoliomargin(curr, instrs)\n", "\t\t\tself.results.margin = res['margin']\n\t\t\telse:\n\t\t\t\tself.results.margin = 0\n\t\t\tminExpiry = 10000000\n\t\t\tfor pos in positions:\n\t\t\t\tif pos.op.expiry < minExpiry:\n\t\t\t\t\tminExpiry = pos.op.expiry\n\t\t\tinstrs = {}\n\t\t\tfor pos in positions:\n\t\t\t\tif pos.op.expiry <= minExpiry:\n", "\t\t\t\tcontinue\n\t\t\t\tif not posCheck and pos in self.positions.positions:\n\t\t\t\t\tcontinue\n\t\t\t\tif pos.op.name not in instrs:\n\t\t\t\t\tinstrs[pos.op.name] = pos.size\n\t\t\t\telse:\n\t\t\t\t\tinstrs[pos.op.name] += pos.size\n\t\t\tif len(instrs) > 0:\n\t\t\t\tres = self.client_rest.getportfoliomargin(curr, instrs)\n\t\t\t\tself.results.expiryMargin = res['margin']\n", "\t\telse:\n\t\t\t\tself.results.expiryMargin = 0\n\t\t\tself.results_model.endResetModel()\n\t\t\tself.window.tableViewResults.resizeColumnsToContents()\n\t\t\tself.window.tableViewResults.viewport().update()\n\t\tdef execute(self):\n\t\t\tif len(self.selections.positions) == 0:\n\t\t\t\tprint(\"No positions to execute\")\n\t\t\t\treturn\n\t\t\tbuycalls = {}\n", "\t\tsellcalls = {}\n\t\t\tbuyputs = {}\n\t\t\tsellputs = {}\n\t\t\tfor pos in self.selections.positions:\n\t\t\t\tif pos.op.kind[0] == \"c\":\n\t\t\t\t\tif pos.size > 0:\n\t\t\t\t\t\tif pos.op.strike not in buycalls:\n\t\t\t\t\t\t\tbuycalls[pos.op.strike] = []\n\t\t\t\t\t\tbuycalls[pos.op.strike].append(pos)\n\t\t\t\t\telse:\n", "\t\t\t\t\tif pos.op.strike not in sellcalls:\n\t\t\t\t\t\t\tsellcalls[pos.op.strike] = []\n\t\t\t\t\t\tsellcalls[pos.op.strike].append(pos)\n\t\t\t\telse:\n\t\t\t\t\tif pos.size > 0:\n\t\t\t\t\t\tif pos.op.strike not in buyputs:\n\t\t\t\t\t\t\tbuyputs[pos.op.strike] = []\n\t\t\t\t\t\tbuyputs[pos.op.strike].append(pos)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif pos.op.strike not in sellputs:\n", "\t\t\t\t\t\tsellputs[pos.op.strike] = []\n\t\t\t\t\t\tsellputs[pos.op.strike].append(pos)\n\t\t\tbuycalls = {k: v for k, v in sorted(buycalls.items(), key=lambda item: item[0], reverse=True)}\n\t\t\tbuyputs = {k: v for k, v in sorted(buyputs.items(), key=lambda item: item[0])}\n\t\t\tsellcalls = {k: v for k, v in sorted(sellcalls.items(), key=lambda item: item[0])}\n\t\t\tsellputs = {k: v for k, v in sorted(sellputs.items(), key=lambda item: item[0], reverse=True)}\n\t\t\tcalls = []\n\t\t\tputs = []\n\t\t\tfor strike in buycalls:\n\t\t\t\tcalls.extend(buycalls[strike])\n", "\t\tfor strike in sellcalls:\n\t\t\t\tcalls.extend(sellcalls[strike])\n\t\t\tfor strike in buyputs:\n\t\t\t\tputs.extend(buyputs[strike])\n\t\t\tfor strike in sellputs:\n\t\t\t\tputs.extend(sellputs[strike])\n\t\t\tself.execOptions(calls)\t\t\n\t\t\tself.execOptions(puts)\n\t\tdef execOptions(self, opts):\n\t\t\twhile len(opts) > 0:\n", "\t\t\tpos = opts[0]\n\t\t\t\tdel opts[0]\n\t\t\t\tif pos.size > 0:\n\t\t\t\t\tres = self.client_rest.buy(pos.op.name, pos.size, pos.op.ask_price)\n\t\t\t\telse:\n\t\t\t\t\tres = self.client_rest.sell(pos.op.name, abs(pos.size), pos.op.bid_price)\n\t\t\t\tif len(opts) > 0:\n\t\t\t\t\tpos = opts[-1]\n\t\t\t\t\tdel opts[-1]\n\t\t\t\t\tif pos.size > 0:\n", "\t\t\t\t\tres = self.client_rest.buy(pos.op.name, pos.size, pos.op.ask_price)\n\t\t\t\t\telse:\n\t\t\t\t\t\tres = self.client_rest.sell(pos.op.name, abs(pos.size), pos.op.bid_price)\n\t\t\t\tif 'trades' in res:\n\t\t\t\t\tprint(len(res['trades']))\n\t\t\t\telse:\n\t\t\t\t\tprint(res)\n"]}
{"filename": "src/optarber/results_data.py", "chunked_list": ["class Results:\n\t\tdef __init__(self):\n\t\t\tself.delta = 0\n\t\t\tself.gamma = 0\n\t\t\tself.vega = 0\n\t\t\tself.theta = 0\n\t\t\tself.net_income = 0\n\t\t\tself.income = 0\n\t\t\tself.fees = 0\n\t\t\tself.margin = 0\t\t\n", "\t\tself.expiryMargin = 0\n\t\t\tself.cols = 9\n\t\tdef clear(self):\n\t\t\tself.delta = 0\n\t\t\tself.gamma = 0\n\t\t\tself.vega = 0\n\t\t\tself.theta = 0\n\t\t\tself.net_income = 0\n\t\t\tself.income = 0\n\t\t\tself.fees = 0\n", "\t\tself.margin = 0\t\t\n\t\t\tself.expiryMargin = 0\n\t\t\tself.cols = 9\n\t\tdef getRows(self):\n\t\t\treturn 2\n\t\tdef getCols(self):\n\t\t\treturn self.cols\n\t\tdef getData(self, j, i):\n\t\t\tif j == 0:\n\t\t\t\tif i == 0:\n", "\t\t\t\treturn \"Delta\"\n\t\t\t\telif i == 1:\n\t\t\t\t\treturn \"Gamma\"\n\t\t\t\telif i == 2:\n\t\t\t\t\treturn \"Vega\"\n\t\t\t\telif i == 3:\n\t\t\t\t\treturn \"Theta\"\n\t\t\t\telif i == 4:\n\t\t\t\t\treturn \"NetIncome\"\n\t\t\t\telif i == 5:\n", "\t\t\t\treturn \"Income\"\n\t\t\t\telif i == 6:\n\t\t\t\t\treturn \"Fees\"\n\t\t\t\telif i == 7:\n\t\t\t\t\treturn \"Margin\"\n\t\t\t\telif i == 8:\n\t\t\t\t\treturn \"Next Margin\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"\"\n\t\t\telse:\n", "\t\t\tif i == 0:\n\t\t\t\t\treturn self.delta\n\t\t\t\telif i == 1:\n\t\t\t\t\treturn self.gamma\n\t\t\t\telif i == 2:\n\t\t\t\t\treturn self.vega\n\t\t\t\telif i == 3:\n\t\t\t\t\treturn self.theta\n\t\t\t\telif i == 4:\n\t\t\t\t\treturn self.net_income\n", "\t\t\telif i == 5:\n\t\t\t\t\treturn self.income\n\t\t\t\telif i == 6:\n\t\t\t\t\treturn self.fees\n\t\t\t\telif i == 7:\n\t\t\t\t\treturn self.margin\n\t\t\t\telif i == 8:\n\t\t\t\t\treturn self.expiryMargin\n\t\t\t\telse:\n\t\t\t\t\treturn 0"]}
{"filename": "src/optarber/ccxt_test.py", "chunked_list": ["import ccxt\n\timport configparser\n\timport json\n\tif __name__ == '__main__':\n\t    cfg = configparser.ConfigParser()\n\t    cfg.read(\"config\\\\config.ini\")\n\t    key = \"TEST\"\n\t    api_key = cfg[key][\"api_key\"]\n\t    api_secret = cfg[key][\"api_secret\"]\n\t    exch = ccxt.deribit({'apiKey': api_key, 'secret': api_secret})\n", "    exch.set_sandbox_mode(True)\n\t    exch.quoteJsonNumbers = False\n\t    response = exch.fetch2(\"get_portfolio_margins\", \"private\", params={\"currency\": \"BTC\"})\n\t    print(response)"]}
{"filename": "src/optarber/selection_model.py", "chunked_list": ["from PyQt6 import QtCore, QtGui\n\tclass SelectionModel(QtCore.QAbstractTableModel): \n\t    def __init__(self, parent=None, *args): \n\t        super(SelectionModel, self).__init__()\n\t        self.selectionData = None\n\t    def update(self, selectionData):\n\t        self.selectionData = selectionData\n\t    def rowCount(self, parent=QtCore.QModelIndex()):\n\t        return self.selectionData.getRows()\n\t    def columnCount(self, parent=QtCore.QModelIndex()):\n", "        return self.selectionData.getCols()\n\t    def data(self, index, role=QtCore.Qt):\n\t        if self.selectionData is not None:\n\t            i = index.row()\n\t            j = index.column()\n\t            if role == QtCore.Qt.ItemDataRole.DisplayRole:\n\t                if j == 0 or i == 0:\n\t                    return '{0}'.format(self.selectionData.getData(i, j))\n\t                elif i > 0 and j > 0:\n\t                    return '{:.4f}'.format(self.selectionData.getData(i, j))\n", "            elif role == QtCore.Qt.ItemDataRole.TextAlignmentRole:\n\t                if j > 0 and i > 0:\n\t                    return QtCore.Qt.AlignmentFlag.AlignRight\n\t            elif role == QtCore.Qt.ItemDataRole.ForegroundRole:\n\t                if j > 0 and i > 0:\n\t                    if self.selectionData.getData(i, j) > 0:\n\t                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkBlue)\n\t                    elif self.selectionData.getData(i, j) < 0:\n\t                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkRed)\n\t            return QtCore.QVariant()"]}
{"filename": "src/optarber/deribit_option.py", "chunked_list": ["class Option:\n\t    def __init__(self, name, kind, expiry, strike, delta, gamma, vega, theta, \n\t\t\t\t       bid_price, bid_amount, ask_price, ask_amount):\n\t        self.name = name\n\t        self.kind = kind\n\t        self.expiry = expiry\n\t        self.strike = strike\n\t        self.delta = delta\n\t        self.gamma = gamma\n\t        self.vega = vega\n", "        self.theta = theta\n\t        self.bid_price = bid_price\n\t        self.bid_amount = bid_amount\n\t        self.ask_price = ask_price\n\t        self.ask_amount = ask_amount"]}
{"filename": "src/optarber/image_viewer.py", "chunked_list": ["from PyQt6.QtWidgets import QDialog, QLabel\n\tfrom PyQt6.QtGui import QPixmap                                                                                                            \n\tclass ImageViewer(QDialog): \n\t    def __init__(self):  \n\t        super().__init__()                                                                                                                  \n\t        self.lbl = None\n\t        self.initUI()                                                                                                                 \n\t    def initUI(self):    \n\t        self.lbl = QLabel(self)                                                                                               \n\t        self.setWindowTitle('PayOff')  \n", "    def update(self):\n\t        pixmap = QPixmap(\"file.png\")                                                                                                        \n\t        self.lbl.setPixmap(pixmap)                                                                                                          \n"]}
{"filename": "src/optarber/mainUI.py", "chunked_list": ["# Form implementation generated from reading ui file 'UI\\optionAtilla.ui'\n\t#\n\t# Created by: PyQt6 UI code generator 6.4.2\n\t#\n\t# WARNING: Any manual changes made to this file will be lost when pyuic6 is\n\t# run again.  Do not edit this file unless you know what you are doing.\n\tfrom PyQt6 import QtCore, QtGui, QtWidgets\n\tclass Ui_optionAtillaWindow(object):\n\t    def setupUi(self, optionAtillaWindow):\n\t        optionAtillaWindow.setObjectName(\"optionAtillaWindow\")\n", "        optionAtillaWindow.setWindowModality(QtCore.Qt.WindowModality.WindowModal)\n\t        optionAtillaWindow.resize(1269, 879)\n\t        optionAtillaWindow.setAutoFillBackground(False)\n\t        optionAtillaWindow.setStyleSheet(\"background-color: rgb(177, 177, 177);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n\t        self.centralwidget = QtWidgets.QWidget(parent=optionAtillaWindow)\n\t        self.centralwidget.setObjectName(\"centralwidget\")\n\t        self.groupCriteria = QtWidgets.QGroupBox(parent=self.centralwidget)\n\t        self.groupCriteria.setGeometry(QtCore.QRect(0, 1, 1031, 141))\n\t        self.groupCriteria.setObjectName(\"groupCriteria\")\n", "        self.layoutWidget = QtWidgets.QWidget(parent=self.groupCriteria)\n\t        self.layoutWidget.setGeometry(QtCore.QRect(170, 20, 63, 71))\n\t        self.layoutWidget.setObjectName(\"layoutWidget\")\n\t        self.verticalLayout_10 = QtWidgets.QVBoxLayout(self.layoutWidget)\n\t        self.verticalLayout_10.setContentsMargins(0, 0, 0, 0)\n\t        self.verticalLayout_10.setObjectName(\"verticalLayout_10\")\n\t        self.labelStrikePercent = QtWidgets.QLabel(parent=self.layoutWidget)\n\t        self.labelStrikePercent.setObjectName(\"labelStrikePercent\")\n\t        self.verticalLayout_10.addWidget(self.labelStrikePercent)\n\t        self.labelMinExpiry = QtWidgets.QLabel(parent=self.layoutWidget)\n", "        self.labelMinExpiry.setObjectName(\"labelMinExpiry\")\n\t        self.verticalLayout_10.addWidget(self.labelMinExpiry)\n\t        self.labelMaxExpiry = QtWidgets.QLabel(parent=self.layoutWidget)\n\t        self.labelMaxExpiry.setObjectName(\"labelMaxExpiry\")\n\t        self.verticalLayout_10.addWidget(self.labelMaxExpiry)\n\t        self.pushButtonFetch = QtWidgets.QPushButton(parent=self.groupCriteria)\n\t        self.pushButtonFetch.setGeometry(QtCore.QRect(920, 110, 75, 23))\n\t        self.pushButtonFetch.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n\t        self.pushButtonFetch.setObjectName(\"pushButtonFetch\")\n\t        self.labelNumOfOptions = QtWidgets.QLabel(parent=self.groupCriteria)\n", "        self.labelNumOfOptions.setGeometry(QtCore.QRect(290, 52, 81, 41))\n\t        self.labelNumOfOptions.setObjectName(\"labelNumOfOptions\")\n\t        self.pushButtonCompute = QtWidgets.QPushButton(parent=self.groupCriteria)\n\t        self.pushButtonCompute.setGeometry(QtCore.QRect(790, 80, 91, 23))\n\t        self.pushButtonCompute.setObjectName(\"pushButtonCompute\")\n\t        self.progressBarFetch = QtWidgets.QProgressBar(parent=self.groupCriteria)\n\t        self.progressBarFetch.setGeometry(QtCore.QRect(10, 110, 911, 23))\n\t        self.progressBarFetch.setStyleSheet(\"color: rgb(0, 255, 0);\")\n\t        self.progressBarFetch.setProperty(\"value\", 0)\n\t        self.progressBarFetch.setObjectName(\"progressBarFetch\")\n", "        self.layoutWidget1 = QtWidgets.QWidget(parent=self.groupCriteria)\n\t        self.layoutWidget1.setGeometry(QtCore.QRect(376, 22, 81, 71))\n\t        self.layoutWidget1.setObjectName(\"layoutWidget1\")\n\t        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget1)\n\t        self.verticalLayout.setContentsMargins(0, 0, 0, 0)\n\t        self.verticalLayout.setObjectName(\"verticalLayout\")\n\t        self.labelDelta = QtWidgets.QLabel(parent=self.layoutWidget1)\n\t        self.labelDelta.setObjectName(\"labelDelta\")\n\t        self.verticalLayout.addWidget(self.labelDelta)\n\t        self.labelMinTheta = QtWidgets.QLabel(parent=self.layoutWidget1)\n", "        self.labelMinTheta.setObjectName(\"labelMinTheta\")\n\t        self.verticalLayout.addWidget(self.labelMinTheta)\n\t        self.labelGamma = QtWidgets.QLabel(parent=self.layoutWidget1)\n\t        self.labelGamma.setObjectName(\"labelGamma\")\n\t        self.verticalLayout.addWidget(self.labelGamma)\n\t        self.layoutWidget2 = QtWidgets.QWidget(parent=self.groupCriteria)\n\t        self.layoutWidget2.setGeometry(QtCore.QRect(467, 20, 61, 71))\n\t        self.layoutWidget2.setObjectName(\"layoutWidget2\")\n\t        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget2)\n\t        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)\n", "        self.verticalLayout_2.setObjectName(\"verticalLayout_2\")\n\t        self.spinDelta = QtWidgets.QSpinBox(parent=self.layoutWidget2)\n\t        self.spinDelta.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n\t        self.spinDelta.setReadOnly(False)\n\t        self.spinDelta.setMaximum(999)\n\t        self.spinDelta.setProperty(\"value\", 1)\n\t        self.spinDelta.setObjectName(\"spinDelta\")\n\t        self.verticalLayout_2.addWidget(self.spinDelta)\n\t        self.spinMinTheta = QtWidgets.QSpinBox(parent=self.layoutWidget2)\n", "        self.spinMinTheta.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n\t        self.spinMinTheta.setReadOnly(False)\n\t        self.spinMinTheta.setMinimum(-9999)\n\t        self.spinMinTheta.setMaximum(9999)\n\t        self.spinMinTheta.setProperty(\"value\", 5)\n\t        self.spinMinTheta.setObjectName(\"spinMinTheta\")\n\t        self.verticalLayout_2.addWidget(self.spinMinTheta)\n\t        self.spinGamma = QtWidgets.QSpinBox(parent=self.layoutWidget2)\n\t        self.spinGamma.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n", "\"color: rgb(0, 0, 0);\")\n\t        self.spinGamma.setReadOnly(False)\n\t        self.spinGamma.setMinimum(-9999)\n\t        self.spinGamma.setMaximum(9999)\n\t        self.spinGamma.setProperty(\"value\", 100)\n\t        self.spinGamma.setObjectName(\"spinGamma\")\n\t        self.verticalLayout_2.addWidget(self.spinGamma)\n\t        self.layoutWidget3 = QtWidgets.QWidget(parent=self.groupCriteria)\n\t        self.layoutWidget3.setGeometry(QtCore.QRect(10, 20, 62, 71))\n\t        self.layoutWidget3.setObjectName(\"layoutWidget3\")\n", "        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.layoutWidget3)\n\t        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)\n\t        self.verticalLayout_3.setObjectName(\"verticalLayout_3\")\n\t        self.labelEnv = QtWidgets.QLabel(parent=self.layoutWidget3)\n\t        self.labelEnv.setObjectName(\"labelEnv\")\n\t        self.verticalLayout_3.addWidget(self.labelEnv)\n\t        self.labelCurr = QtWidgets.QLabel(parent=self.layoutWidget3)\n\t        self.labelCurr.setObjectName(\"labelCurr\")\n\t        self.verticalLayout_3.addWidget(self.labelCurr)\n\t        self.labelObjective = QtWidgets.QLabel(parent=self.layoutWidget3)\n", "        self.labelObjective.setObjectName(\"labelObjective\")\n\t        self.verticalLayout_3.addWidget(self.labelObjective)\n\t        self.layoutWidget4 = QtWidgets.QWidget(parent=self.groupCriteria)\n\t        self.layoutWidget4.setGeometry(QtCore.QRect(80, 20, 90, 74))\n\t        self.layoutWidget4.setObjectName(\"layoutWidget4\")\n\t        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.layoutWidget4)\n\t        self.verticalLayout_4.setContentsMargins(0, 0, 0, 0)\n\t        self.verticalLayout_4.setObjectName(\"verticalLayout_4\")\n\t        self.comboEnv = QtWidgets.QComboBox(parent=self.layoutWidget4)\n\t        self.comboEnv.setStyleSheet(\"background-color: rgb(85, 255, 255);\\n\"\n", "\"color: rgb(0, 0, 0);\")\n\t        self.comboEnv.setObjectName(\"comboEnv\")\n\t        self.comboEnv.addItem(\"\")\n\t        self.comboEnv.addItem(\"\")\n\t        self.verticalLayout_4.addWidget(self.comboEnv)\n\t        self.comboCurr = QtWidgets.QComboBox(parent=self.layoutWidget4)\n\t        self.comboCurr.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n\t        self.comboCurr.setObjectName(\"comboCurr\")\n\t        self.comboCurr.addItem(\"\")\n", "        self.comboCurr.addItem(\"\")\n\t        self.verticalLayout_4.addWidget(self.comboCurr)\n\t        self.comboObjective = QtWidgets.QComboBox(parent=self.layoutWidget4)\n\t        self.comboObjective.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n\t        self.comboObjective.setObjectName(\"comboObjective\")\n\t        self.comboObjective.addItem(\"\")\n\t        self.comboObjective.addItem(\"\")\n\t        self.comboObjective.addItem(\"\")\n\t        self.verticalLayout_4.addWidget(self.comboObjective)\n", "        self.layoutWidget5 = QtWidgets.QWidget(parent=self.groupCriteria)\n\t        self.layoutWidget5.setGeometry(QtCore.QRect(550, 23, 104, 65))\n\t        self.layoutWidget5.setObjectName(\"layoutWidget5\")\n\t        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.layoutWidget5)\n\t        self.verticalLayout_5.setContentsMargins(0, 0, 0, 0)\n\t        self.verticalLayout_5.setObjectName(\"verticalLayout_5\")\n\t        self.checkPutNeutral = QtWidgets.QCheckBox(parent=self.layoutWidget5)\n\t        self.checkPutNeutral.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n\t        self.checkPutNeutral.setChecked(True)\n\t        self.checkPutNeutral.setObjectName(\"checkPutNeutral\")\n", "        self.verticalLayout_5.addWidget(self.checkPutNeutral)\n\t        self.checkCallNeutral = QtWidgets.QCheckBox(parent=self.layoutWidget5)\n\t        self.checkCallNeutral.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n\t        self.checkCallNeutral.setChecked(True)\n\t        self.checkCallNeutral.setObjectName(\"checkCallNeutral\")\n\t        self.verticalLayout_5.addWidget(self.checkCallNeutral)\n\t        self.checkVega = QtWidgets.QCheckBox(parent=self.layoutWidget5)\n\t        self.checkVega.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n\t        self.checkVega.setChecked(True)\n\t        self.checkVega.setObjectName(\"checkVega\")\n", "        self.verticalLayout_5.addWidget(self.checkVega)\n\t        self.layoutWidget6 = QtWidgets.QWidget(parent=self.groupCriteria)\n\t        self.layoutWidget6.setGeometry(QtCore.QRect(665, 24, 71, 42))\n\t        self.layoutWidget6.setObjectName(\"layoutWidget6\")\n\t        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.layoutWidget6)\n\t        self.verticalLayout_6.setContentsMargins(0, 0, 0, 0)\n\t        self.verticalLayout_6.setObjectName(\"verticalLayout_6\")\n\t        self.checkLongCall = QtWidgets.QCheckBox(parent=self.layoutWidget6)\n\t        self.checkLongCall.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n\t        self.checkLongCall.setChecked(False)\n", "        self.checkLongCall.setObjectName(\"checkLongCall\")\n\t        self.verticalLayout_6.addWidget(self.checkLongCall)\n\t        self.checkLongPut = QtWidgets.QCheckBox(parent=self.layoutWidget6)\n\t        self.checkLongPut.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n\t        self.checkLongPut.setChecked(False)\n\t        self.checkLongPut.setObjectName(\"checkLongPut\")\n\t        self.verticalLayout_6.addWidget(self.checkLongPut)\n\t        self.layoutWidget7 = QtWidgets.QWidget(parent=self.groupCriteria)\n\t        self.layoutWidget7.setGeometry(QtCore.QRect(760, 25, 61, 41))\n\t        self.layoutWidget7.setObjectName(\"layoutWidget7\")\n", "        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.layoutWidget7)\n\t        self.verticalLayout_7.setContentsMargins(0, 0, 0, 0)\n\t        self.verticalLayout_7.setObjectName(\"verticalLayout_7\")\n\t        self.labelMaxUnit = QtWidgets.QLabel(parent=self.layoutWidget7)\n\t        self.labelMaxUnit.setObjectName(\"labelMaxUnit\")\n\t        self.verticalLayout_7.addWidget(self.labelMaxUnit)\n\t        self.labelMaxTotal = QtWidgets.QLabel(parent=self.layoutWidget7)\n\t        self.labelMaxTotal.setObjectName(\"labelMaxTotal\")\n\t        self.verticalLayout_7.addWidget(self.labelMaxTotal)\n\t        self.layoutWidget8 = QtWidgets.QWidget(parent=self.groupCriteria)\n", "        self.layoutWidget8.setGeometry(QtCore.QRect(830, 22, 61, 48))\n\t        self.layoutWidget8.setObjectName(\"layoutWidget8\")\n\t        self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.layoutWidget8)\n\t        self.verticalLayout_8.setContentsMargins(0, 0, 0, 0)\n\t        self.verticalLayout_8.setObjectName(\"verticalLayout_8\")\n\t        self.spinMaxUnit = QtWidgets.QSpinBox(parent=self.layoutWidget8)\n\t        self.spinMaxUnit.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n\t        self.spinMaxUnit.setReadOnly(False)\n\t        self.spinMaxUnit.setMaximum(999)\n", "        self.spinMaxUnit.setProperty(\"value\", 5)\n\t        self.spinMaxUnit.setObjectName(\"spinMaxUnit\")\n\t        self.verticalLayout_8.addWidget(self.spinMaxUnit)\n\t        self.spinMaxTotal = QtWidgets.QSpinBox(parent=self.layoutWidget8)\n\t        self.spinMaxTotal.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n\t        self.spinMaxTotal.setReadOnly(False)\n\t        self.spinMaxTotal.setMaximum(999)\n\t        self.spinMaxTotal.setProperty(\"value\", 15)\n\t        self.spinMaxTotal.setObjectName(\"spinMaxTotal\")\n", "        self.verticalLayout_8.addWidget(self.spinMaxTotal)\n\t        self.layoutWidget9 = QtWidgets.QWidget(parent=self.groupCriteria)\n\t        self.layoutWidget9.setGeometry(QtCore.QRect(240, 20, 39, 74))\n\t        self.layoutWidget9.setObjectName(\"layoutWidget9\")\n\t        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.layoutWidget9)\n\t        self.verticalLayout_9.setContentsMargins(0, 0, 0, 0)\n\t        self.verticalLayout_9.setObjectName(\"verticalLayout_9\")\n\t        self.spinBoxStrikePercent = QtWidgets.QSpinBox(parent=self.layoutWidget9)\n\t        self.spinBoxStrikePercent.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n", "        self.spinBoxStrikePercent.setProperty(\"value\", 10)\n\t        self.spinBoxStrikePercent.setObjectName(\"spinBoxStrikePercent\")\n\t        self.verticalLayout_9.addWidget(self.spinBoxStrikePercent)\n\t        self.spinBoxMinExpiry = QtWidgets.QSpinBox(parent=self.layoutWidget9)\n\t        self.spinBoxMinExpiry.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n\t        self.spinBoxMinExpiry.setProperty(\"value\", 0)\n\t        self.spinBoxMinExpiry.setObjectName(\"spinBoxMinExpiry\")\n\t        self.verticalLayout_9.addWidget(self.spinBoxMinExpiry)\n\t        self.spinBoxMaxExpiry = QtWidgets.QSpinBox(parent=self.layoutWidget9)\n", "        self.spinBoxMaxExpiry.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n\t        self.spinBoxMaxExpiry.setProperty(\"value\", 10)\n\t        self.spinBoxMaxExpiry.setObjectName(\"spinBoxMaxExpiry\")\n\t        self.verticalLayout_9.addWidget(self.spinBoxMaxExpiry)\n\t        self.checkPositions = QtWidgets.QCheckBox(parent=self.groupCriteria)\n\t        self.checkPositions.setGeometry(QtCore.QRect(900, 20, 121, 20))\n\t        self.checkPositions.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n\t        self.checkPositions.setChecked(True)\n\t        self.checkPositions.setObjectName(\"checkPositions\")\n", "        self.spinBoxSpread = QtWidgets.QSpinBox(parent=self.groupCriteria)\n\t        self.spinBoxSpread.setGeometry(QtCore.QRect(970, 40, 51, 22))\n\t        self.spinBoxSpread.setStyleSheet(\"background-color: rgb(255, 255, 255);\\n\"\n\t\"color: rgb(0, 0, 0);\")\n\t        self.spinBoxSpread.setMinimum(1)\n\t        self.spinBoxSpread.setProperty(\"value\", 10)\n\t        self.spinBoxSpread.setObjectName(\"spinBoxSpread\")\n\t        self.labelSpread = QtWidgets.QLabel(parent=self.groupCriteria)\n\t        self.labelSpread.setGeometry(QtCore.QRect(906, 40, 61, 20))\n\t        self.labelSpread.setObjectName(\"labelSpread\")\n", "        self.checkDoubleFee = QtWidgets.QCheckBox(parent=self.groupCriteria)\n\t        self.checkDoubleFee.setGeometry(QtCore.QRect(900, 64, 121, 20))\n\t        self.checkDoubleFee.setLayoutDirection(QtCore.Qt.LayoutDirection.RightToLeft)\n\t        self.checkDoubleFee.setChecked(True)\n\t        self.checkDoubleFee.setObjectName(\"checkDoubleFee\")\n\t        self.pushButtonConnect = QtWidgets.QPushButton(parent=self.groupCriteria)\n\t        self.pushButtonConnect.setGeometry(QtCore.QRect(280, 20, 91, 21))\n\t        self.pushButtonConnect.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n\t        self.pushButtonConnect.setObjectName(\"pushButtonConnect\")\n\t        self.tableViewAccount = QtWidgets.QTableView(parent=self.centralwidget)\n", "        self.tableViewAccount.setGeometry(QtCore.QRect(1040, 0, 221, 671))\n\t        self.tableViewAccount.setAutoFillBackground(True)\n\t        self.tableViewAccount.setStyleSheet(\"\")\n\t        self.tableViewAccount.setObjectName(\"tableViewAccount\")\n\t        self.tableViewAccount.horizontalHeader().setVisible(False)\n\t        self.tableViewAccount.verticalHeader().setVisible(False)\n\t        self.groupBox_2 = QtWidgets.QGroupBox(parent=self.centralwidget)\n\t        self.groupBox_2.setGeometry(QtCore.QRect(10, 140, 1021, 101))\n\t        self.groupBox_2.setObjectName(\"groupBox_2\")\n\t        self.tableViewResults = QtWidgets.QTableView(parent=self.groupBox_2)\n", "        self.tableViewResults.setEnabled(True)\n\t        self.tableViewResults.setGeometry(QtCore.QRect(0, 20, 1011, 71))\n\t        self.tableViewResults.setAutoFillBackground(False)\n\t        self.tableViewResults.setStyleSheet(\"\")\n\t        self.tableViewResults.setObjectName(\"tableViewResults\")\n\t        self.tableViewResults.horizontalHeader().setVisible(False)\n\t        self.tableViewResults.horizontalHeader().setStretchLastSection(False)\n\t        self.tableViewResults.verticalHeader().setVisible(False)\n\t        self.tableViewSelections = QtWidgets.QTableView(parent=self.centralwidget)\n\t        self.tableViewSelections.setGeometry(QtCore.QRect(10, 250, 641, 421))\n", "        self.tableViewSelections.setAutoFillBackground(True)\n\t        self.tableViewSelections.setStyleSheet(\"\")\n\t        self.tableViewSelections.setObjectName(\"tableViewSelections\")\n\t        self.tableViewSelections.horizontalHeader().setVisible(False)\n\t        self.tableViewSelections.horizontalHeader().setStretchLastSection(False)\n\t        self.tableViewSelections.verticalHeader().setVisible(False)\n\t        self.tableViewPositions = QtWidgets.QTableView(parent=self.centralwidget)\n\t        self.tableViewPositions.setGeometry(QtCore.QRect(660, 250, 371, 421))\n\t        self.tableViewPositions.setAutoFillBackground(True)\n\t        self.tableViewPositions.setStyleSheet(\"\")\n", "        self.tableViewPositions.setObjectName(\"tableViewPositions\")\n\t        self.tableViewPositions.horizontalHeader().setVisible(False)\n\t        self.tableViewPositions.horizontalHeader().setStretchLastSection(False)\n\t        self.tableViewPositions.verticalHeader().setVisible(False)\n\t        self.tableViewPositions.verticalHeader().setHighlightSections(True)\n\t        self.pushButtonClose = QtWidgets.QPushButton(parent=self.centralwidget)\n\t        self.pushButtonClose.setGeometry(QtCore.QRect(1140, 810, 121, 41))\n\t        self.pushButtonClose.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n\t        self.pushButtonClose.setObjectName(\"pushButtonClose\")\n\t        self.tableViewCallTrades = QtWidgets.QTableView(parent=self.centralwidget)\n", "        self.tableViewCallTrades.setGeometry(QtCore.QRect(11, 679, 641, 121))\n\t        self.tableViewCallTrades.setObjectName(\"tableViewCallTrades\")\n\t        self.tableViewPutTrades = QtWidgets.QTableView(parent=self.centralwidget)\n\t        self.tableViewPutTrades.setGeometry(QtCore.QRect(660, 680, 601, 121))\n\t        self.tableViewPutTrades.setObjectName(\"tableViewPutTrades\")\n\t        self.widget = QtWidgets.QWidget(parent=self.centralwidget)\n\t        self.widget.setGeometry(QtCore.QRect(60, 820, 461, 25))\n\t        self.widget.setObjectName(\"widget\")\n\t        self.horizontalLayout = QtWidgets.QHBoxLayout(self.widget)\n\t        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)\n", "        self.horizontalLayout.setObjectName(\"horizontalLayout\")\n\t        self.pushButtonDisplay = QtWidgets.QPushButton(parent=self.widget)\n\t        self.pushButtonDisplay.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n\t        self.pushButtonDisplay.setObjectName(\"pushButtonDisplay\")\n\t        self.horizontalLayout.addWidget(self.pushButtonDisplay)\n\t        self.pushButtonClearSelection = QtWidgets.QPushButton(parent=self.widget)\n\t        self.pushButtonClearSelection.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n\t        self.pushButtonClearSelection.setObjectName(\"pushButtonClearSelection\")\n\t        self.horizontalLayout.addWidget(self.pushButtonClearSelection)\n\t        self.pushButtonRefresh = QtWidgets.QPushButton(parent=self.widget)\n", "        self.pushButtonRefresh.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n\t        self.pushButtonRefresh.setObjectName(\"pushButtonRefresh\")\n\t        self.horizontalLayout.addWidget(self.pushButtonRefresh)\n\t        self.pushButtonTrade = QtWidgets.QPushButton(parent=self.widget)\n\t        self.pushButtonTrade.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n\t        self.pushButtonTrade.setObjectName(\"pushButtonTrade\")\n\t        self.horizontalLayout.addWidget(self.pushButtonTrade)\n\t        self.widget1 = QtWidgets.QWidget(parent=self.centralwidget)\n\t        self.widget1.setGeometry(QtCore.QRect(760, 820, 166, 25))\n\t        self.widget1.setObjectName(\"widget1\")\n", "        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.widget1)\n\t        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)\n\t        self.horizontalLayout_2.setObjectName(\"horizontalLayout_2\")\n\t        self.pushButtonPositions = QtWidgets.QPushButton(parent=self.widget1)\n\t        self.pushButtonPositions.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n\t        self.pushButtonPositions.setObjectName(\"pushButtonPositions\")\n\t        self.horizontalLayout_2.addWidget(self.pushButtonPositions)\n\t        self.pushButtonClearTrades = QtWidgets.QPushButton(parent=self.widget1)\n\t        self.pushButtonClearTrades.setStyleSheet(\"background-color: rgb(100, 100, 100);\")\n\t        self.pushButtonClearTrades.setObjectName(\"pushButtonClearTrades\")\n", "        self.horizontalLayout_2.addWidget(self.pushButtonClearTrades)\n\t        optionAtillaWindow.setCentralWidget(self.centralwidget)\n\t        self.statusbar = QtWidgets.QStatusBar(parent=optionAtillaWindow)\n\t        self.statusbar.setObjectName(\"statusbar\")\n\t        optionAtillaWindow.setStatusBar(self.statusbar)\n\t        self.retranslateUi(optionAtillaWindow)\n\t        self.pushButtonClose.clicked.connect(optionAtillaWindow.close) # type: ignore\n\t        QtCore.QMetaObject.connectSlotsByName(optionAtillaWindow)\n\t    def retranslateUi(self, optionAtillaWindow):\n\t        _translate = QtCore.QCoreApplication.translate\n", "        optionAtillaWindow.setWindowTitle(_translate(\"optionAtillaWindow\", \"OptionAtilla\"))\n\t        self.groupCriteria.setTitle(_translate(\"optionAtillaWindow\", \"Criteria\"))\n\t        self.labelStrikePercent.setText(_translate(\"optionAtillaWindow\", \"Strike (%)\"))\n\t        self.labelMinExpiry.setText(_translate(\"optionAtillaWindow\", \"Expiry (Min)\"))\n\t        self.labelMaxExpiry.setText(_translate(\"optionAtillaWindow\", \"Expiry (Max)\"))\n\t        self.pushButtonFetch.setText(_translate(\"optionAtillaWindow\", \"FETCH\"))\n\t        self.labelNumOfOptions.setText(_translate(\"optionAtillaWindow\", \"No. of Options \\n\"\n\t\"No. of Expiries\"))\n\t        self.pushButtonCompute.setText(_translate(\"optionAtillaWindow\", \"Compute\"))\n\t        self.labelDelta.setText(_translate(\"optionAtillaWindow\", \"Max Delta (%)\"))\n", "        self.labelMinTheta.setText(_translate(\"optionAtillaWindow\", \"Min Theta\"))\n\t        self.labelGamma.setText(_translate(\"optionAtillaWindow\", \"Gamma (bps)\"))\n\t        self.labelEnv.setText(_translate(\"optionAtillaWindow\", \"Environmnt\"))\n\t        self.labelCurr.setText(_translate(\"optionAtillaWindow\", \"Currency\"))\n\t        self.labelObjective.setText(_translate(\"optionAtillaWindow\", \"Objective\"))\n\t        self.comboEnv.setItemText(0, _translate(\"optionAtillaWindow\", \"TEST\"))\n\t        self.comboEnv.setItemText(1, _translate(\"optionAtillaWindow\", \"PROD\"))\n\t        self.comboCurr.setItemText(0, _translate(\"optionAtillaWindow\", \"ETH\"))\n\t        self.comboCurr.setItemText(1, _translate(\"optionAtillaWindow\", \"BTC\"))\n\t        self.comboObjective.setItemText(0, _translate(\"optionAtillaWindow\", \"Min Cost\"))\n", "        self.comboObjective.setItemText(1, _translate(\"optionAtillaWindow\", \"Max Gamma\"))\n\t        self.comboObjective.setItemText(2, _translate(\"optionAtillaWindow\", \"Max Theta\"))\n\t        self.checkPutNeutral.setText(_translate(\"optionAtillaWindow\", \"Put neutral        \"))\n\t        self.checkCallNeutral.setText(_translate(\"optionAtillaWindow\", \"Call neutral        \"))\n\t        self.checkVega.setText(_translate(\"optionAtillaWindow\", \"Positive Vega     \"))\n\t        self.checkLongCall.setText(_translate(\"optionAtillaWindow\", \"Long Call \"))\n\t        self.checkLongPut.setText(_translate(\"optionAtillaWindow\", \"Long Put \"))\n\t        self.labelMaxUnit.setText(_translate(\"optionAtillaWindow\", \"Max Unit\"))\n\t        self.labelMaxTotal.setText(_translate(\"optionAtillaWindow\", \"Max Total\"))\n\t        self.checkPositions.setText(_translate(\"optionAtillaWindow\", \"Exisiting Positions\"))\n", "        self.labelSpread.setText(_translate(\"optionAtillaWindow\", \"Spread (bps)\"))\n\t        self.checkDoubleFee.setText(_translate(\"optionAtillaWindow\", \"Double Fee\"))\n\t        self.pushButtonConnect.setText(_translate(\"optionAtillaWindow\", \"Connect\"))\n\t        self.groupBox_2.setTitle(_translate(\"optionAtillaWindow\", \"Results\"))\n\t        self.pushButtonClose.setText(_translate(\"optionAtillaWindow\", \"Shutdown\"))\n\t        self.pushButtonDisplay.setText(_translate(\"optionAtillaWindow\", \"Display Payoff\"))\n\t        self.pushButtonClearSelection.setText(_translate(\"optionAtillaWindow\", \"Clear Selection\"))\n\t        self.pushButtonRefresh.setText(_translate(\"optionAtillaWindow\", \"Refresh\"))\n\t        self.pushButtonTrade.setText(_translate(\"optionAtillaWindow\", \"Execute\"))\n\t        self.pushButtonPositions.setText(_translate(\"optionAtillaWindow\", \"Query Positions\"))\n", "        self.pushButtonClearTrades.setText(_translate(\"optionAtillaWindow\", \"Clear Trades\"))\n"]}
{"filename": "src/optarber/position_data.py", "chunked_list": ["class PositionData:\n\t\tdef __init__(self):\n\t\t\tself.keys = {}\n\t\t\tself.positions = []\n\t\t\tself.cols = 6\n\t\tdef clear(self):\n\t\t\tself.positions = []\n\t\t\tself.cols = 6\n\t\tdef add(self, positions):\n\t\t\tself.keys = {}\n", "\t\tself.positions = []\n\t\t\tfor i, pos in enumerate(positions):\n\t\t\t\tname = pos.op.name\n\t\t\t\tself.keys[name] = i\n\t\t\t\tself.positions.append(pos)\n\t\tdef update(self, positions):\n\t\t\tfor pos in positions:\n\t\t\t\tname = pos['instrument_name']\n\t\t\t\tif name in self.keys:\n\t\t\t\t\tpos = self.positions[self.keys[name]]\n", "\t\t\t\tpos.size = pos['size']\n\t\t\t\t\topt = pos.op\n\t\t\t\t\topt.delta = pos['delta'] / opt.size\n\t\t\t\t\topt.gamma = pos['gamma'] / opt.size\n\t\t\t\t\topt.vega = pos['vega'] / opt.size\n\t\t\t\t\topt.theta = pos['theta'] / opt.size\n\t\tdef getRows(self):\n\t\t\treturn len(self.positions) + 1\n\t\tdef getCols(self):\n\t\t\treturn self.cols\n", "\tdef getData(self, j, i):\n\t\t\tif j == 0:\n\t\t\t\tif i == 0:\n\t\t\t\t\treturn \"Instr\"\n\t\t\t\telif i == 1:\n\t\t\t\t\treturn \"Size\"\n\t\t\t\telif i == 2:\n\t\t\t\t\treturn \"Delta\"\n\t\t\t\telif i == 3:\n\t\t\t\t\treturn \"Gamma\"\n", "\t\t\telif i == 4:\n\t\t\t\t\treturn \"Vega\"\n\t\t\t\telif i == 5:\n\t\t\t\t\treturn \"Theta\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"\"\n\t\t\telse:\n\t\t\t\tpos = self.positions[j-1]\n\t\t\t\tif i == 0:\n\t\t\t\t\treturn pos.op.name\n", "\t\t\telif i == 1:\n\t\t\t\t\treturn pos.size\n\t\t\t\telif i == 2:\n\t\t\t\t\treturn pos.op.delta * pos.size\n\t\t\t\telif i == 3:\n\t\t\t\t\treturn pos.op.gamma * pos.size\n\t\t\t\telif i == 4:\n\t\t\t\t\treturn pos.op.vega * pos.size\n\t\t\t\telif i == 5:\n\t\t\t\t\treturn pos.op.theta * pos.size\n", "\t\t\telse:\n\t\t\t\t\treturn 0"]}
{"filename": "src/optarber/results_model.py", "chunked_list": ["from PyQt6 import QtCore, QtGui\n\tclass ResultsModel(QtCore.QAbstractTableModel): \n\t    def __init__(self, parent=None, *args): \n\t        super(ResultsModel, self).__init__()\n\t        self.results = None\n\t    def update(self, results):\n\t        self.results = results\n\t    def rowCount(self, parent=QtCore.QModelIndex()):\n\t        return self.results.getRows()\n\t    def columnCount(self, parent=QtCore.QModelIndex()):\n", "        return self.results.getCols()\n\t    def data(self, index, role=QtCore.Qt):\n\t        if self.results is not None:\n\t            i = index.row()\n\t            j = index.column()\n\t            if role == QtCore.Qt.ItemDataRole.DisplayRole:\n\t                if i == 0:\n\t                    return '{0}'.format(self.results.getData(i, j))\n\t                else:\n\t                    return '{:.4f}'.format(self.results.getData(i, j))\n", "            elif role == QtCore.Qt.ItemDataRole.TextAlignmentRole:\n\t                if i > 0:\n\t                    return QtCore.Qt.AlignmentFlag.AlignRight\n\t            elif role == QtCore.Qt.ItemDataRole.ForegroundRole:\n\t                if i > 0:\n\t                    if self.results.getData(i, j) > 0:\n\t                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkBlue)\n\t                    elif self.results.getData(i, j) < 0:\n\t                        return QtGui.QBrush(QtCore.Qt.GlobalColor.darkRed)\n\t            return QtCore.QVariant()"]}
{"filename": "src/optarber/deribit_rest.py", "chunked_list": ["import datetime\n\timport json as json\n\timport ccxt \n\tclass RestClient(object):\n\t    def __init__(self, key, secret, Test=True):\n\t        self.key = key\n\t        self.secret = secret\n\t        self.session = ccxt.deribit({'apiKey': key, 'secret': secret})\n\t        self.session.set_sandbox_mode(Test)\n\t        self.session.quoteJsonNumbers = False\n", "    def call_api(self, command, access, options):\n\t        response = self.session.fetch2(command, access, params=options)\n\t        return response\n\t    def getinstruments(self, currency, kind):\n\t        '''\n\t        to get available trading instruments\n\t        input:\n\t            currency: string ['BTC', 'ETH']\n\t            kind:string [eg: 'future' or 'option']\n\t        '''\n", "        assert kind in ['future','option']\n\t        options = {\n\t            'currency': currency,\n\t            'kind':kind\n\t        }\n\t        response = self.call_api(\"get_instruments\", \"public\", options)\n\t        if \"result\" in response:\n\t            return response[\"result\"]\n\t        else:\n\t            return {}\n", "    def getportfoliomargin(self, curr, instrs):\n\t        options = {\n\t             'currency':curr, \n\t             'simulated_positions': json.dumps(instrs),\n\t             'add_positions': 'true'\n\t        }\n\t        response = self.call_api(\"get_portfolio_margins\", \"private\", options)\n\t        if \"result\" in response:\n\t            return response['result']\n\t        else:\n", "            return {}\n\t    def getinstrument(self, instr):\n\t        options = {\n\t            'instrument_name': instr,\n\t        }\n\t        response = self.call_api(\"get_instrument\", \"public\", options)\n\t        if \"result\" in response:\n\t            return response[\"result\"]\n\t        else:\n\t            return {}\n", "    def getindex(self, currency):\n\t        options = {\n\t            \"currency\":currency,\n\t            }\n\t        response = self.call_api(\"get_index\", \"public\", options)\n\t        if \"result\" in response:\n\t            return response[\"result\"]\n\t        else:\n\t            return {}\n\t    def getopenorders(self, currency, kind):\n", "        '''\n\t        to retrieve pending orders [order not yet settled]\n\t        input:\n\t            currency: string in 'BTC' or 'ETH'\n\t        output:\n\t            [ID1, ID2...]\n\t        '''\n\t        options = {\n\t            \"currency\":currency,\n\t            \"kind\": kind\n", "            }\n\t        return self.call_api(\"get_open_orders_by_currency\", \"private\", options);\n\t    def getpositions(self, currency, kind):\n\t        '''\n\t        to retrieve position by currency\n\t        input:\n\t            currency: string in 'BTC' or 'ETH'\n\t        return: \n\t            int [size of position. positive for 'buy' and negative for 'sell'\n\t        '''\n", "        options = {\n\t            \"currency\":currency,\n\t            \"kind\": kind\n\t            }\n\t        response = self.call_api(\"get_positions\", \"private\", options);\n\t        if \"result\" in response:\n\t            return response[\"result\"]\n\t        else:\n\t            return []\n\t    def buy(self, instrument, quantity, price, postOnly=None, time_in_force=\"fill_or_kill\"):\n", "        options = {\n\t            \"instrument_name\": instrument,\n\t            \"amount\": quantity,\n\t            \"price\": price,\n\t            \"time_in_force\": time_in_force\n\t        }\n\t        if postOnly:\n\t            options[\"postOnly\"] = postOnly\n\t        return self.call_api(\"buy\", \"private\", options)\n\t    def sell(self, instrument, quantity, price, postOnly=None, time_in_force=\"fill_or_kill\"):\n", "        options = {\n\t            \"instrument_name\": instrument,\n\t            \"amount\": quantity,\n\t            \"price\": price,\n\t            \"time_in_force\": time_in_force\n\t        }\n\t        if postOnly:\n\t            options[\"postOnly\"] = postOnly\n\t        return self.call_api(\"sell\", \"private\", options)\n"]}
{"filename": "src/optarber/deribit_option_position.py", "chunked_list": ["class DeribitPosition:\n\t    def __init__(self, op, size):\n\t        self.op = op\n\t        self.size = size"]}
{"filename": "src/optarber/deribit_ws.py", "chunked_list": ["import json\n\tfrom PyQt6 import QtCore, QtWebSockets, QtNetwork\n\t# create a websocket object\n\tclass Deribit_WS(QtCore.QObject):\n\t    def __init__(self, parent):\n\t        super().__init__(parent)\n\t        self.ids = { \"default\": 1,\n\t                     \"authenticate\": 2, \n\t                     \"accounts\": 3,\n\t                     \"changes\": 4,\n", "                     \"tickers\": 5,\n\t                    }\n\t        self.authenticated = False\n\t        self.controller = None\n\t    def connect(self, controller, client_id, client_secret, client_url):\n\t        self.controller = controller\n\t        self.client_id = client_id\n\t        self.client_secret = client_secret\n\t        self.client_url = client_url\n\t        self.json = {\n", "            \"jsonrpc\" : \"2.0\",\n\t            \"id\" : 1,\n\t            \"method\" : None,\n\t        }\n\t        self.client =  QtWebSockets.QWebSocket(\"Deribit_Socket\",QtWebSockets.QWebSocketProtocol.Version.VersionLatest, None)\n\t        self.client.error.connect(self.error)\n\t        self.client.textMessageReceived.connect(self.onMessage)\n\t        self.client.open(QtCore.QUrl(self.client_url))\n\t    def authenticate(self):\n\t        options = {\n", "            \"grant_type\" : \"client_credentials\",\n\t            \"client_id\" : self.client_id,\n\t            \"client_secret\" : self.client_secret\n\t        }\n\t        self.json[\"method\"] = \"public/auth\"\n\t        self.json[\"id\"] = self.ids[\"authenticate\"]\n\t        self.json[\"params\"] = options\n\t        auth = json.dumps(self.json)\n\t        self.client.sendTextMessage(auth)\n\t    def onMessage(self, textMessage):\n", "        response = json.loads(textMessage)\n\t        if \"id\" in response and response[\"id\"] == 2:\n\t            if \"result\" in response:\n\t                if \"token_type\" in response['result']:\n\t                    print(\"Authenticated\")\n\t                    self.authenticated = True\n\t        else:\n\t            if \"params\" in response and \"channel\" in response[\"params\"]:\n\t                channel = response[\"params\"][\"channel\"]\n\t                if channel.startswith(\"user.portfolio.\"):\n", "                    if \"data\" in response['params']:\n\t                        self.controller.onAccountData(response[\"params\"][\"data\"])\n\t                if channel.startswith(\"user.changes.\"):\n\t                    if 'data' in response:\n\t                        data = response['data']\n\t                        if 'positions' in data:\n\t                            self.controller.onPositionData(response[\"data\"][\"positions\"])\n\t                if channel.startswith(\"ticker.\"):\n\t                    self.controller.onMarketData(response[\"params\"][\"data\"])\n\t    def error(self, error_code):\n", "        print(\"error code: {}\".format(error_code))\n\t        print(self.client.errorString())\n\t    # send an authentication request\n\t    def call_api(self, request):\n\t        return self.client.sendTextMessage(json.dumps(request))\n\t    def limit_buy_aggressive(self, instrument_name, amount, reduce_only, price):\n\t        self.buy_raw(instrument_name, amount, \"limit\", reduce_only, price, False)\n\t    def buy_market(self, instrument_name, amount, reduce_only):\n\t        self.buy_raw(instrument_name, amount, \"market\", reduce_only, None, False)\n\t    def limit_buy_passive(self, instrument_name, amount, reduce_only, price):\n", "        self.buy_raw(instrument_name, amount, \"limit\", reduce_only, price, True)\n\t    def buy_raw(self, instrument_name, amount, order_type, reduce_only, price, post_only):\n\t        options = {\n\t            \"instrument_name\" : instrument_name,\n\t            \"amount\" : amount,\n\t            \"type\" : order_type,\n\t            \"reduce_only\" : reduce_only,\n\t        }\n\t        if price:\n\t            options[\"price\"] = price\n", "        if post_only:\n\t            options[\"post_only\"] = post_only\n\t        self.json[\"method\"] = \"private/buy\"\n\t        self.json[\"id\"] = self.ids[\"default\"]\n\t        self.json[\"params\"] = options\n\t        return self.call_api(self.json)\n\t    def limit_sell_aggressive(self, instrument_name, amount, reduce_only, price):\n\t        self.sell_raw(instrument_name, amount, \"limit\", reduce_only, price, False)\n\t    def sell_market(self, instrument_name, amount, reduce_only):\n\t        self.sell_raw(instrument_name, amount, \"market\", reduce_only, None, False)\n", "    def limit_sell_passive(self, instrument_name, amount, reduce_only, price):\n\t        self.sell_raw(instrument_name, amount, \"limit\", reduce_only, price, True)\n\t    def sell_raw(self, instrument_name, amount, order_type, reduce_only, price, post_only):\n\t        options = {\n\t            \"instrument_name\" : instrument_name,\n\t            \"amount\" : amount,\n\t            \"type\" : order_type,\n\t            \"reduce_only\" : reduce_only,\n\t        }\n\t        if price:\n", "            options[\"price\"] = price\n\t        if post_only:\n\t            options[\"post_only\"] = post_only\n\t        self.json[\"method\"] = \"private/sell\"\n\t        self.json[\"id\"] = self.ids[\"default\"]\n\t        self.json[\"params\"] = options\n\t        return self.call_api(self.json)\n\t    def edit(self, order_id, amount, price):\n\t        options= {\n\t            \"order_id\" : order_id,\n", "            \"amount\" : amount,\n\t            \"price\" : price\n\t        }\n\t        self.json[\"method\"] = \"private/edit\"\n\t        self.json[\"id\"] = self.ids[\"default\"]\n\t        self.json[\"params\"] = options\n\t        return self.call_api(self.json)\n\t    def cancel(self, order_id):\n\t        options = {\"order_id\" : order_id}\n\t        self.json[\"method\"] = \"private/cancel\"\n", "        self.json[\"id\"] = self.ids[\"default\"]\n\t        self.json[\"params\"] = options\n\t        return self.call_api(self.json)\n\t    def cancel_all(self):\n\t        self.json[\"method\"] = \"private/cancel_all\"\n\t        self.json[\"id\"] = self.ids[\"default\"]\n\t        return self.call_api(self.json)\n\t    def change_summary(self, currency):\n\t        options = {\"channels\" : [\"user.changes.option.\" + currency + \".100ms\"]}\n\t        self.json[\"method\"] = \"private/subscribe\"\n", "        self.json[\"id\"] = self.ids[\"changes\"]\n\t        self.json[\"params\"] = options\n\t        return self.call_api(self.json)\n\t    def account_summary(self, currency):\n\t        options = {\"channels\" : [\"user.portfolio.\" + currency]}\n\t        self.json[\"method\"] = \"private/subscribe\"\n\t        self.json[\"id\"] = self.ids[\"accounts\"]\n\t        self.json[\"params\"] = options\n\t        return self.call_api(self.json)\n\t    def ticker(self, instrument_name):\n", "        options = {\"channels\" : [\"ticker.\" + instrument_name + \".100ms\"]}\n\t        self.json[\"method\"] = \"public/subscribe\"\n\t        self.json[\"id\"] = self.ids[\"tickers\"]\n\t        self.json[\"params\"] = options\n\t        return self.call_api(self.json)\n\t    def unsubscribe_all_public(self):\n\t        self.json[\"method\"] = \"public/unsubscribe_all\"\n\t        options = {}\n\t        self.json[\"id\"] = self.ids[\"default\"]\n\t        self.json[\"params\"] = options\n", "        return self.call_api(self.json)\n\t    def unsubscribe_all_private(self):\n\t        self.json[\"method\"] = \"private/unsubscribe_all\"\n\t        options = {}\n\t        self.json[\"id\"] = self.ids[\"default\"]\n\t        self.json[\"params\"] = options\n\t        return self.call_api(self.json)\n\t    def close(self):\n\t        self.unsubscribe_all_private()\n\t        self.unsubscribe_all_public()\n", "        print(\"Closing websocket\")\n\t        self.client.close()"]}
{"filename": "src/deltahedger/program.py", "chunked_list": ["import scalper, asyncio\n\tdef main():\n\t\tobj = scalper.Scalper(\"config.ini\", \"Deribit\")\n\t\tasyncio.run(obj.run_loop())\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/deltahedger/scalper.py", "chunked_list": ["import asyncio\n\timport ccxt\n\timport configparser\n\timport logging\n\timport requests\n\timport time\n\tclass Scalper:\n\t    def __init__(self, config_file, exchange):\n\t        try:\n\t            cfg = configparser.ConfigParser()\n", "            cfg.read(config_file)\n\t            self._api_key = cfg[exchange]['api_key']\n\t            self._api_secret = cfg[exchange]['api_secret']\n\t            self.symbol = cfg[exchange]['symbol']\n\t            self.price_move = round(float(cfg[exchange]['price_move']), 2)\n\t            self.hedge_lookup = cfg[exchange]['hedge_lookup']\n\t            self.hedge_contract = cfg[exchange]['hedge_contract']\n\t            self.ladder_size = int(cfg[exchange]['ladder_size'])\n\t            self.tick_size = round(float(cfg[exchange]['tick_size']), 2)\n\t            self.delta_threshold = float(cfg[exchange]['delta_threshold'])\n", "            self.done = False\n\t            if exchange == \"Deribit\":\n\t                self.exchange = ccxt.deribit({'apiKey': self._api_key, 'secret': self._api_secret})\n\t                self.exchange.set_sandbox_mode(True)\n\t            else:\n\t                raise Exception(\"Exchange \" + exchange + \" not yet supported\")\n\t            if self.symbol != \"BTC\" and self.symbol != \"ETH\":\n\t                raise Exception(\"Only BTC and ETH supported symbols\")\n\t        except  Exception as e:\n\t            logging.error(\"Failed to initialize configuration from file \" + config_file, e)\n", "    async def get_option_greeks(self):\n\t        delta = float(self.exchange.fetch_balance({'currency': str(self.symbol)})['info']['options_delta'])\n\t        gamma = float(self.exchange.fetch_balance({'currency': str(self.symbol)})['info']['options_gamma'])\n\t        return delta, gamma\n\t    async def get_hedge_delta(self):\n\t        lookup = self.exchange.fetch_balance({'currency': str(self.symbol)})\n\t        hedge_lookup = lookup['info']['delta_total_map']\n\t        if self.hedge_lookup in hedge_lookup:\n\t            return float(hedge_lookup[self.hedge_lookup])\n\t        else:\n", "            return 0\n\t    async def get_open_orders(self, symbol):\n\t        return self.exchange.fetch_open_orders(symbol)\n\t    async def get_ticker(self, symbol):\n\t        ticker = self.exchange.publicGetTicker({\"instrument_name\": symbol})\n\t        ticker = ticker['result']\n\t        return float(ticker[\"best_bid_price\"]), float(ticker[\"best_ask_price\"]), float(ticker['mark_price'])\n\t    async def get_order_book(self, symbol):\n\t        orderbook = self.exchange.fetch_l2_order_book(symbol, 40)\n\t        bids = orderbook['bids']\n", "        asks = orderbook['asks']\n\t        return bids, asks\n\t    async def get_new_delta(self, net_delta, option_gamma, move):\n\t        return net_delta + option_gamma * move \n\t    async def delta_hedge(self, prev_index, prev_delta):\n\t        # get greeks\n\t        option_delta, option_gamma = await self.get_option_greeks()\n\t        hedge_delta = await self.get_hedge_delta()\n\t        net_delta = option_delta + hedge_delta\n\t        proposed_bids = {}\n", "        proposed_asks = {}\n\t        best_bid_price, best_ask_price, mark_price = await self.get_ticker(self.hedge_contract)\n\t        index_price = (best_ask_price + best_bid_price) * 0.5\n\t        if index_price == prev_index and abs(net_delta - prev_delta) > self.delta_threshold:\n\t            return index_price, prev_delta\n\t        if abs(net_delta) < self.delta_threshold:\n\t            print(\"not need to hedge\")\n\t            return index_price, net_delta\n\t        self.exchange.cancel_all_orders(self.hedge_contract)\n\t        print(\"bid price\", best_bid_price, \"ask price\", best_ask_price, \"mark price\", mark_price)\n", "        print(\"delta\", round(net_delta, 4), \"option delta\", round(option_delta, 4), \"hedge delta\", round(hedge_delta, 4))\n\t        net_bid_delta = 0\n\t        net_ask_delta = 0        \n\t        for ladder in range(self.ladder_size):\n\t            bid_price_delta = self.price_move * ladder\n\t            ask_price_delta = bid_price_delta\n\t            new_bid_price = round(round((best_bid_price - bid_price_delta) / self.tick_size) * self.tick_size, 2)\n\t            bdelta = await self.get_new_delta(net_delta, option_gamma, new_bid_price - best_bid_price) - net_bid_delta\n\t            if bdelta * new_bid_price < -50:\n\t                print(\"bid ladder\", ladder, new_bid_price, abs(bdelta) * new_bid_price)\n", "                proposed_bids[new_bid_price] = round(abs(bdelta) * new_bid_price, 0)\n\t                net_bid_delta += bdelta\n\t            new_ask_price = round(round((best_ask_price + ask_price_delta) / self.tick_size) * self.tick_size, 2)\n\t            adelta = await self.get_new_delta(net_delta, option_gamma, new_ask_price - best_ask_price) - net_ask_delta\n\t            if adelta * new_ask_price > 50:\n\t                print(\"ask ladder\", ladder, new_ask_price, adelta * new_ask_price)\n\t                proposed_asks[new_ask_price] = round(adelta * new_ask_price, 0)\n\t                net_ask_delta += adelta\n\t        # submit orders\n\t        for bid_price in proposed_bids:\n", "            print(\"bid_ladder\", bid_price, proposed_bids[bid_price])\n\t            self.exchange.create_limit_buy_order(self.hedge_contract, proposed_bids[bid_price], bid_price, {\"post_only\": True})\n\t        for ask_price in proposed_asks:\n\t            print(\"ask_ladder\", ask_price, proposed_asks[ask_price])\n\t            self.exchange.create_limit_sell_order(self.hedge_contract, proposed_asks[ask_price], ask_price, {\"post_only\": True})\n\t        print(\"====================================\")\n\t        return index_price, net_delta\n\t    async def get_balance(self, symbol):\n\t        return self.exchange.fetch_balance({'currency': self.symbol})\n\t    async def run_loop(self):\n", "        retry_count = 0\n\t        post_interval = 0\n\t        index_price = 0\n\t        prev_delta = 1\n\t        while not self.done:\n\t            try:\n\t                index_price, prev_delta = await self.delta_hedge(index_price, prev_delta)\n\t                time.sleep(3)\n\t                post_interval += 3\n\t                if post_interval > 300:\n", "                    await self.send_to_telegram()\n\t                    post_interval = 0\n\t                retry_count = 0\n\t            except Exception as e:\n\t                print(\"Hedge failed\", e)\n\t                retry_count += 1\n\t                if retry_count >= 9:\n\t                    self.done = True\n\t    async def send_to_telegram(self):\n\t        apiToken = '5715880531:AAEX0uW87-SHHTGtG6Wh0wJ3z140nm0l5hU'\n", "        apiURL = f'https://api.telegram.org/bot{apiToken}/sendMessage'\n\t        chatID = '1182531369'\n\t        try:\n\t            message = self.exchange.fetch_balance({'currency': str(self.symbol)})['info']\n\t            requests.post(apiURL, json={'chat_id': chatID, 'text': message})\n\t        except Exception as e:\n\t            print(\"telegram error\", e)\n\t    def run(self):\n\t        self.done = False\n\t        loop = asyncio.get_event_loop()\n", "        loop.run_until_complete(self.run_loop())\n"]}
