{"filename": "home/default/.jupyter/lab/jupyter_lab_config.py", "chunked_list": ["# Configuration file for lab.\n\timport os\n\tREMOTE_ACCESS = os.getenv(\"IFLAB_REMOTE_ACCESS\")\n\tc = get_config()\n\tc.IdentityProvider.token = ''\n\tc.NotebookApp.token = ''\n\tc.PasswordIdentityProvider.password_required = False\n\tc.ExtensionApp.open_browser = False\n\tc.ServerApp.root_dir = \"notebooks\"\n\tif REMOTE_ACCESS and REMOTE_ACCESS != \"0\":\n", "    c.ServerApp.allow_origin = '*'\n\t    c.ServerApp.ip = '0.0.0.0'\n"]}
{"filename": "modules/ifui.py", "chunked_list": ["import sys\n\tfrom IPython.display import clear_output\n\timport os\n\tdef unload_modules(of):\n\t    if_modules = []\n\t    for n, m in sys.modules.items():\n\t        if hasattr(m, \"__file__\") and m.__file__ and of in m.__file__:\n\t            if_modules.append(n)\n\t    for n in if_modules:\n\t        sys.modules.pop(n)\n", "def show_ui():\n\t    global stages\n\t    print(\"Loading DeepFloyd IF Lab UI, please wait...\")\n\t    unload_modules(\"iflab\")\n\t    from iflab.pipelines.stages import DeepFloydIFStages\n\t    from iflab.ui.main import DeepFloydIFUI\n\t    try:\n\t        stages\n\t    except NameError:\n\t        stages = DeepFloydIFStages()\n", "        stages.load()\n\t    clear_output()\n\t    ui = DeepFloydIFUI(stages)\n\t    ui.show()\n\t    return ui\n"]}
{"filename": "modules/iflab/settings.py", "chunked_list": ["import os\n\tfrom easysettings import JSONSettings\n\tSETTINGS_FILE = \"../home/settings.json\"\n\tsettings = JSONSettings(filename=SETTINGS_FILE)\n\tif os.path.exists(SETTINGS_FILE):\n\t    settings.load()\n"]}
{"filename": "modules/iflab/__init__.py", "chunked_list": ["from .const import *\n\tfrom .ui.open import open_ui\n"]}
{"filename": "modules/iflab/const.py", "chunked_list": ["import os\n\tVERSION = \"0.2.5\"\n\tDEBUG = os.getenv(\"IFLAB_DEBUG\", False)\n\tDEBUG = not not (DEBUG and DEBUG != \"0\")\n\tUI_THREADS = not DEBUG\n\tEXPERIMENTAL = os.getenv(\"IFLAB_EXPERIMENTAL\", False)\n\tEXPERIMENTAL = not not (EXPERIMENTAL and EXPERIMENTAL != \"0\")\n\tSEQ_LOAD_OFF = \"off\"\n\tSEQ_LOAD_MERGE = \"merge\"\n\tSEQ_LOAD_SEPARATE = \"separate\"\n", "RESPACING_MODES = ['fast27', 'smart27', 'smart50', 'smart100', 'smart185', 'super27', 'super40', 'super100']\n\tDEBUG_PROMPT = \"ultra close-up color photo portrait of rainbow owl with deer horns in the woods\"\n\tif DEBUG:\n\t    PROMPT_FILE = \"../home/debug_prompt.txt\"\n\t    if os.path.exists(PROMPT_FILE):\n\t        with open(PROMPT_FILE, \"r\", encoding=\"utf-8\") as f:\n\t            DEBUG_PROMPT = f.read()\n"]}
{"filename": "modules/iflab/init.py", "chunked_list": ["import torch\n\timport os\n\tfrom pathlib import Path\n\tfrom .const import SEQ_LOAD_OFF, SEQ_LOAD_MERGE, SEQ_LOAD_SEPARATE\n\tfrom .settings import settings\n\tdef get_total_gb_vram():\n\t    if torch.cuda.is_available():\n\t        return round(torch.cuda.get_device_properties(0).total_memory / 1024 ** 3)\n\t    else:\n\t        return 8\n", "def apply_default_mem_settings():\n\t    total_gb_vram = get_total_gb_vram()\n\t    seq_load = settings.get(\"sequential_load\", None)\n\t    if not seq_load:\n\t        if total_gb_vram >= 24:\n\t            settings.set(\"sequential_load\", SEQ_LOAD_OFF)\n\t        elif total_gb_vram >= 12:\n\t            settings.set(\"sequential_load\", SEQ_LOAD_MERGE)\n\t        else:\n\t            settings.set(\"sequential_load\", SEQ_LOAD_SEPARATE)\n", "            settings.set(\"stageI_model\", \"IF-I-L-v1.0\")\n\t            settings.set(\"stageII_model\", \"IF-II-L-v1.0\")\n\t        settings.save()\n\t    return settings.get(\"sequential_load\")\n\tdef init_installation():\n\t    apply_default_mem_settings()\n"]}
{"filename": "modules/iflab/pipelines/dream.py", "chunked_list": ["from deepfloyd_if.pipelines.dream import dream\n\tfrom .pipeline import Pipeline\n\tfrom .. import EXPERIMENTAL\n\tclass DreamPipeline(Pipeline):\n\t    def __init__(self, stages):\n\t        super().__init__(stages)\n\t    def invoke(self, **kwargs):\n\t        if EXPERIMENTAL and self.experimental:\n\t            return self.experimental.dream_mod(**kwargs)\n\t        else:\n", "            return dream(**kwargs)\n\t    def invoke_ref(self, **kwargs):\n\t        if EXPERIMENTAL and self.experimental:\n\t            print('reference dream')\n\t            return self.experimental.dream_ref(**kwargs)\n\t        else:\n\t            return dream(**kwargs)\n\t    def modify_args(self, args):\n\t        args[\"aspect_ratio\"] = self.aspect_ratio"]}
{"filename": "modules/iflab/pipelines/pipeline.py", "chunked_list": ["import importlib\n\timport time\n\timport random\n\timport traceback\n\tfrom abc import ABC, abstractmethod\n\tfrom collections import UserDict\n\tfrom dataclasses import dataclass\n\tfrom datetime import datetime\n\tfrom random import randint\n\timport numpy as np\n", "from torch import autocast\n\tfrom .stages import ModelError\n\tfrom .. import SEQ_LOAD_OFF, SEQ_LOAD_SEPARATE, DEBUG, SEQ_LOAD_MERGE\n\t@dataclass\n\tclass IFResult:\n\t    images: ...\n\t    tensors: ...\n\t    generations: ...\n\t    args: ...\n\t    seed: ...\n", "    time: ...\n\t    iterations: ...\n\t    duration: ...\n\tclass Pipeline(ABC):\n\t    def __init__(self, stages):\n\t        self.override_args = {}\n\t        self.settings = {}\n\t        self.stages = stages\n\t        self.count = 1\n\t        self.aspect_ratio = \"1:1\"\n", "        self.prompt = None\n\t        self.negative_prompt = None\n\t        self.style_prompt = None\n\t        self.t5_embs = None\n\t        self.negative_t5_embs = None\n\t        self.style_t5_embs = None\n\t        self.guidanceI = 7.0\n\t        self.stepsI = \"smart100\"\n\t        self.guidanceII = 4.0\n\t        self.stepsII = \"smart50\"\n", "        self.guidanceIII = 4.0\n\t        self.stepsIII = 75\n\t        self.noiseIII = 20\n\t        self.custom_paramsI = None\n\t        self.custom_paramsII = None\n\t        self.custom_paramsIII = None\n\t        self.iterationsI = 0\n\t        self.iterationsII = 0\n\t        self.iterationsIII = 0\n\t        self.result_stageI = None\n", "        self.result_upscale = None\n\t        self.generationsI = {}\n\t        self.support_image = None\n\t        self.mask_image = None\n\t        self.disable_watermark = False\n\t        self.pass_prompt_to_stage_III = None\n\t        self.on_before_embeddings = lambda: None\n\t        self.on_before_generation = lambda: None\n\t        self.on_before_upscale = lambda: None\n\t        self.on_before_checkpoints_loaded = lambda m: None\n", "        self.on_checkpoints_loaded = lambda: None\n\t        try:\n\t            self.experimental = importlib.import_module('.'.join(__name__.split('.')[:-1]) + \".experimental\")\n\t        except ImportError as e:\n\t            self.experimental = None\n\t    def prepare_embeddings(self):\n\t        if not self.stages.has_t5():\n\t            self.on_before_checkpoints_loaded(False)\n\t        self.stages.free_stageIII()\n\t        self.stages.free_stageII()\n", "        self.stages.free_stageI()\n\t        was_loaded = self.stages.ensure_t5()\n\t        if not self.has_t5_loaded:\n\t            raise ModelError(\"Error loading T5 encoder.\")\n\t        if was_loaded:\n\t            self.on_checkpoints_loaded()\n\t        self.on_before_embeddings()\n\t    def compute_t5_embs(self, update_prompt=True, update_negative=True, update_style=True):\n\t        self.prepare_embeddings()\n\t        if update_prompt:\n", "            if self.prompt is not None:\n\t                promptv = [self.prompt] * self.count\n\t                self.t5_embs = self.stages.t5.get_text_embeddings(promptv)\n\t            else:\n\t                self.t5_embs = None\n\t        if update_negative:\n\t            if self.negative_prompt is not None:\n\t                promptv = [self.negative_prompt] * self.count\n\t                self.negative_t5_embs = self.stages.t5.get_text_embeddings(promptv)\n\t            else:\n", "                self.negative_t5_embs = None\n\t        if update_style:\n\t            if self.style_prompt is not None:\n\t                promptv = [self.style_prompt] * self.count\n\t                self.style_t5_embs = self.stages.t5.get_text_embeddings(promptv)\n\t            else:\n\t                self.style_t5_embs = None\n\t    def generate_seed(self):\n\t        return randint(0, np.iinfo(np.int32).max)\n\t    def prepare_prompts(self):\n", "        prompt = [self.prompt] if isinstance(self.prompt, str) else self.prompt\n\t        negative = [self.negative_prompt] if isinstance(self.negative_prompt, str) else self.negative_prompt\n\t        style = [self.style_prompt] if isinstance(self.style_prompt, str) else self.style_prompt\n\t        return prompt, negative, style\n\t    def merge_args(self, args, override):\n\t        for k, v in override.items():\n\t            if (isinstance(v, dict) or isinstance(v, UserDict)) and k in args:\n\t                self.merge_args(args[k], v)\n\t            elif v is not None:\n\t                args[k] = v\n", "    def add_custom_parameters(self, stage_args, params):\n\t        if params and stage_args:\n\t            for k, v in params.items():\n\t                stage_args[k] = v\n\t    @property\n\t    def is_optimized(self):\n\t        return self.stages.sequential_load != SEQ_LOAD_OFF\n\t    @property\n\t    def has_t5_loaded(self):\n\t        return self.stages.has_t5()\n", "    @property\n\t    def has_stageI_loaded(self):\n\t        return self.stages.has_stageI()\n\t    @property\n\t    def has_stageII_loaded(self):\n\t        return self.stages.has_stageII()\n\t    @property\n\t    def has_stageIII_loaded(self):\n\t        return self.stages.has_stageIII()\n\t    def prepare_generation(self):\n", "        if not self.has_stageI_loaded:\n\t            self.on_before_checkpoints_loaded(not self.stages.downloaded_stageI())\n\t        self.stages.free_t5()\n\t        self.stages.free_stageII()\n\t        self.stages.free_stageIII()\n\t        was_loaded = self.stages.ensure_stageI()\n\t        if not self.has_stageI_loaded:\n\t            raise ModelError(\"Error loading stage I model.\")\n\t        if was_loaded:\n\t            self.on_checkpoints_loaded()\n", "        self.on_before_generation()\n\t    def generate(self, seed=None, progress=True, is_reference=False):\n\t        self.prepare_generation()\n\t        if seed is None:\n\t            seed = self.generate_seed()\n\t        prompt, negative, style = self.prepare_prompts()\n\t        if_I_kwargs = UserDict({\n\t            \"guidance_scale\": self.guidanceI,\n\t            \"sample_timestep_respacing\": self.stepsI\n\t        })\n", "        self.add_custom_parameters(if_I_kwargs, self.custom_paramsI)\n\t        if prompt:\n\t            if_I_kwargs[\"t5_embs\"] = self.t5_embs\n\t        if negative:\n\t            if_I_kwargs[\"negative_t5_embs\"] = self.negative_t5_embs\n\t        if style:\n\t            if_I_kwargs[\"style_t5_embs\"] = self.style_t5_embs\n\t        kwargs = dict(\n\t            t5=self.stages.t5, if_I=self.stages.if_I,\n\t            prompt=prompt,\n", "            negative_prompt=negative,\n\t            style_prompt=style,\n\t            disable_watermark=self.disable_watermark,\n\t            seed=seed,\n\t            if_I_kwargs=if_I_kwargs,\n\t            return_tensors=True,\n\t            progress=progress\n\t        )\n\t        self.modify_args(kwargs)\n\t        self.merge_args(kwargs, self.override_args)\n", "        seed = kwargs[\"seed\"]\n\t        time_start = time.perf_counter()\n\t        invoke = self.invoke_ref if is_reference else self.invoke\n\t        self.result_stageI = invoke(**kwargs)\n\t        duration = time.perf_counter() - time_start\n\t        its = self.iterationsI / duration\n\t        images, tensors = self.result_stageI\n\t        output = images.get(\"output\", [[]])\n\t        self.result_stageI = IFResult(images, tensors, output, if_I_kwargs, seed, time.time(), its, duration)\n\t        self.generationsI[seed] = self.result_stageI\n", "        return self.result_stageI\n\t    def prepare_upscale(self, stage):\n\t        if not self.stages.has_stageII() or not self.stages.has_stageIII():\n\t            missing = stage == \"II\" and not self.stages.downloaded_stageII() or \\\n\t                      stage == \"III\" and not self.stages.downloaded_stageIII()\n\t            self.on_before_checkpoints_loaded(missing)\n\t        self.stages.free_t5()\n\t        self.stages.free_stageI()\n\t        was_loaded = False\n\t        if stage == \"II\":\n", "            if self.stages.sequential_load == SEQ_LOAD_SEPARATE and self.has_stageIII_loaded:\n\t                self.stages.free_stageIII()\n\t            was_loaded = self.stages.ensure_stageII()\n\t            if not self.has_stageII_loaded:\n\t                raise ModelError(\"Error loading stage II model.\")\n\t        if stage == \"III\" or self.stages.sequential_load == SEQ_LOAD_MERGE:\n\t            if self.stages.sequential_load == SEQ_LOAD_SEPARATE and self.has_stageII_loaded:\n\t                self.stages.free_stageII()\n\t            try:\n\t                was_loaded = self.stages.ensure_stageIII() or was_loaded\n", "            except Exception as e:\n\t                if DEBUG:\n\t                    traceback.print_exc()\n\t            if not self.has_stageIII_loaded:\n\t                raise ModelError(\"Error loading stage III model.\")\n\t        if was_loaded:\n\t            self.on_checkpoints_loaded()\n\t        self.on_before_upscale()\n\t    def get_upscaleII_kwargs(self, resultI):\n\t        if_II_kwargs = UserDict({\n", "            \"guidance_scale\": self.guidanceII,\n\t            \"sample_timestep_respacing\": self.stepsII\n\t        })\n\t        self.add_custom_parameters(if_II_kwargs, self.custom_paramsII)\n\t        # the usage of patched pipelines is assumed here, although technically it will work without the patch\n\t        # some extra parameters are passed as metadata to preserve the original interface\n\t        resultI.args.imagesI = resultI.images[\"I\"]\n\t        resultI.args.tensorsI = resultI.tensors[0]\n\t        return if_II_kwargs\n\t    def get_upscaleIII_kwargs(self, resultII):\n", "        if_III_kwargs = UserDict({\n\t            \"guidance_scale\": self.guidanceIII,\n\t            \"noise_level\": self.noiseIII,\n\t            \"sample_timestep_respacing\": str(self.stepsIII),\n\t        })\n\t        self.add_custom_parameters(if_III_kwargs, self.custom_paramsIII)\n\t        if_III_kwargs.imagesII = resultII.images[\"II\"]\n\t        if_III_kwargs.tensorsII = resultII.tensors[1]\n\t        if_III_kwargs.pass_prompt_to_sIII = self.pass_prompt_to_stage_III\n\t        return if_III_kwargs\n", "    def upscale(self, resultI=None, resultII=None, progress=False, is_reference=False):\n\t        stage = \"III\" if resultII else \"II\"\n\t        self.prepare_upscale(stage)\n\t        seed = resultI.seed\n\t        rtime = resultI.time\n\t        if_I_kwargs = resultI.args\n\t        if_II_kwargs = self.get_upscaleII_kwargs(resultI) if stage == \"II\" else None\n\t        if_III_kwargs = self.get_upscaleIII_kwargs(resultII) if stage == \"III\" else None\n\t        if_III = self.stages.if_III if stage == \"III\" else None\n\t        prompt, negative, style = self.prepare_prompts()\n", "        time_start = time.perf_counter()\n\t        kwargs = dict(\n\t            t5=self.stages.t5, if_I=self.stages.if_I, if_II=self.stages.if_II, if_III=if_III,\n\t            prompt=prompt,\n\t            negative_prompt=negative,\n\t            style_prompt=style,\n\t            disable_watermark=self.disable_watermark,\n\t            seed=seed,\n\t            if_I_kwargs=if_I_kwargs,\n\t            if_II_kwargs=if_II_kwargs,\n", "            if_III_kwargs=if_III_kwargs,\n\t            return_tensors=True,\n\t            progress=progress\n\t        )\n\t        self.modify_args(kwargs)\n\t        self.merge_args(kwargs, self.override_args)\n\t        seed = kwargs[\"seed\"]\n\t        invoke = self.invoke_ref if is_reference else self.invoke\n\t        self.result_upscale = invoke(**kwargs)\n\t        duration = time.perf_counter() - time_start\n", "        images, tensors = self.result_upscale\n\t        output = images.get(\"output\", [[]])\n\t        self.result_upscale = IFResult(images, tensors, output, if_II_kwargs, seed, rtime, 0, duration)\n\t        return self.result_upscale\n\t    @abstractmethod\n\t    def invoke(self, **kwargs):\n\t        pass\n\t    @abstractmethod\n\t    def invoke_ref(self, **kwargs):\n\t        pass\n", "    @abstractmethod\n\t    def modify_args(self, args):\n\t        pass"]}
{"filename": "modules/iflab/pipelines/__init__.py", "chunked_list": []}
{"filename": "modules/iflab/pipelines/utils.py", "chunked_list": ["import torch\n\tdef get_total_gb_vram():\n\t    if torch.cuda.is_available():\n\t        return round(torch.cuda.get_device_properties(0).total_memory / 1024 ** 3)\n\t    else:\n\t        return 0\n\tdef get_default_settings():\n\t    result = {}\n\t    total_gb_vram = get_total_gb_vram()\n\t    if total_gb_vram >= 24:\n", "        result = {\"alternate_load\": False}\n\t    elif total_gb_vram >= 12:\n\t        result = {\n\t            \"alternate_load\": True\n\t        }\n\t    else:\n\t        result = {\n\t            \"stageI_model\": \"IF-I-L-v1.0\",\n\t            \"stageII_model\": \"IF-II-M-v1.0\",\n\t            \"alternate_load\": True\n", "        }\n\t    return result\n"]}
{"filename": "modules/iflab/pipelines/style_transfer.py", "chunked_list": ["from deepfloyd_if.pipelines import style_transfer\n\tfrom deepfloyd_if.pipelines.utils import _prepare_pil_image\n\tfrom .pipeline import Pipeline, IFResult\n\tfrom .stages import ModelError\n\tfrom .. import EXPERIMENTAL, SEQ_LOAD_OFF\n\tclass StylePipeline(Pipeline):\n\t    def __init__(self, stages):\n\t        super().__init__(stages)\n\t        self.custom_paramsI = {\"sample_timestep_respacing\": \"10,10,10,10,10,10,10,10,0,0\",\n\t                               \"support_noise_less_qsample_steps\": 5}\n", "        self.custom_paramsII = {\"support_noise_less_qsample_steps\": 5}\n\t    def invoke(self, **kwargs):\n\t        if EXPERIMENTAL and self.experimental:\n\t            return self.experimental.style_transfer_mod(**kwargs)\n\t        else:\n\t            return style_transfer(**kwargs)\n\t    def invoke_ref(self, **kwargs):\n\t        if EXPERIMENTAL and self.experimental:\n\t            print('reference style_transfer')\n\t            return self.experimental.style_transfer_ref(**kwargs)\n", "        else:\n\t            return style_transfer(**kwargs)\n\t    def modify_args(self, args):\n\t        args[\"support_pil_img\"] = self.support_image\n\t        # TODO: move support images to the class level in all pipelines for optimization\n\t        args[\"if_I_kwargs\"].low_res = _prepare_pil_image(self.support_image, 64)\n\t        args[\"if_I_kwargs\"].mid_res = _prepare_pil_image(self.support_image, 256)\n"]}
{"filename": "modules/iflab/pipelines/inpainting.py", "chunked_list": ["import numpy as np\n\tfrom PIL import Image\n\tfrom deepfloyd_if.pipelines import inpainting\n\tfrom deepfloyd_if.pipelines.utils import _prepare_pil_image\n\tfrom .pipeline import Pipeline\n\tfrom .. import EXPERIMENTAL\n\tclass InpaintingPipeline(Pipeline):\n\t    def __init__(self, stages):\n\t        super().__init__(stages)\n\t        self.custom_paramsI = {\"sample_timestep_respacing\": \"10,10,10,10,10,0,0,0,0,0\",\n", "                               \"support_noise_less_qsample_steps\": 0}\n\t        self.custom_paramsII = {\"aug_level\": 0.0}\n\t    def invoke(self, **kwargs):\n\t        if EXPERIMENTAL and self.experimental:\n\t            return self.experimental.inpainting_mod(**kwargs)\n\t        else:\n\t            return inpainting(**kwargs)\n\t    def invoke_ref(self, **kwargs):\n\t        if EXPERIMENTAL and self.experimental:\n\t            print('reference inpainting')\n", "            return self.experimental.inpainting_ref(**kwargs)\n\t        else:\n\t            return inpainting(**kwargs)\n\t    def modify_args(self, args):\n\t        del args[\"style_prompt\"]\n\t        if hasattr(args[\"if_I_kwargs\"], 'style_t5_embs'):\n\t            del args[\"if_I_kwargs\"]['style_t5_embs']\n\t        if self.support_image:\n\t            args[\"support_pil_img\"] = self.support_image\n\t            inpainting_mask = None\n", "            if self.mask_image:\n\t                inpainting_mask = np.array(self.mask_image)\n\t            else:\n\t                blank_pil_image = Image.new('RGB', self.support_image.size, (255, 255, 255))\n\t                inpainting_mask = np.array(blank_pil_image)\n\t            inpainting_mask = np.moveaxis(inpainting_mask, -1, 0)\n\t            args['inpainting_mask'] = inpainting_mask\n\t            args[\"if_I_kwargs\"].low_res = _prepare_pil_image(self.support_image, 64)\n\t            args[\"if_I_kwargs\"].mid_res = _prepare_pil_image(self.support_image, 256)\n\t            args[\"if_I_kwargs\"].high_res = _prepare_pil_image(self.support_image, 1024)\n"]}
{"filename": "modules/iflab/pipelines/stages.py", "chunked_list": ["import gc\n\timport importlib\n\timport os\n\timport sys\n\timport time\n\timport traceback\n\timport torch\n\tfrom huggingface_hub import notebook_login, login\n\tfrom deepfloyd_if.modules.t5 import T5Embedder\n\tfrom deepfloyd_if.modules import IFStageI, IFStageII, StableStageIII\n", "from .. import SEQ_LOAD_OFF, SEQ_LOAD_SEPARATE\n\tfrom ..const import EXPERIMENTAL, DEBUG\n\tfrom ..init import apply_default_mem_settings\n\tfrom ..settings import settings\n\tif sys.platform == \"darwin\":\n\t    from . import mac\n\tIFLAB_HOME = os.getenv(\"IFLAB_HOME\")\n\tLOGGED_IN_HF = os.path.exists(os.path.join(IFLAB_HOME, \"home\", \"huggingface\", \"token\"))\n\tDEFAULT_MODEL_T5 = \"t5-v1_1-xxl\"\n\tDEFAULT_MODEL_I = \"IF-I-XL-v1.0\"\n", "DEFAULT_MODEL_II = \"IF-II-L-v1.0\"\n\tDEFAULT_MODEL_III = \"stable-diffusion-x4-upscaler\"\n\tif EXPERIMENTAL:\n\t    try:\n\t        experimental_module = importlib.import_module('.'.join(__name__.split('.')[:-1]) + \".experimental\")\n\t    except ImportError as e:\n\t        experimental_module = None\n\t    ModIFStageI = experimental_module.ModIFStageI\n\t    ModIFStageII = experimental_module.ModIFStageII\n\t    ModIFStageIII = experimental_module.ModIFStageIII\n", "else:\n\t    ModIFStageI = IFStageI\n\t    ModIFStageII = IFStageII\n\t    ModIFStageIII = StableStageIII\n\tclass ModelError(Exception):\n\t    pass\n\tdef get_t5_device_map(device):\n\t    return {\n\t        'shared': device,\n\t        'encoder.embed_tokens': device,\n", "        'encoder.block.0': device,\n\t        'encoder.block.1': device,\n\t        'encoder.block.2': device,\n\t        'encoder.block.3': device,\n\t        'encoder.block.4': device,\n\t        'encoder.block.5': device,\n\t        'encoder.block.6': device,\n\t        'encoder.block.7': device,\n\t        'encoder.block.8': device,\n\t        'encoder.block.9': device,\n", "        'encoder.block.10': 'cpu',\n\t        'encoder.block.11': 'cpu',\n\t        'encoder.block.12': 'cpu',\n\t        'encoder.block.13': 'cpu',\n\t        'encoder.block.14': 'cpu',\n\t        'encoder.block.15': 'cpu',\n\t        'encoder.block.16': 'cpu',\n\t        'encoder.block.17': 'cpu',\n\t        'encoder.block.18': 'cpu',\n\t        'encoder.block.19': 'cpu',\n", "        'encoder.block.20': 'cpu',\n\t        'encoder.block.21': 'cpu',\n\t        'encoder.block.22': 'cpu',\n\t        'encoder.block.23': 'cpu',\n\t        'encoder.final_layer_norm': 'cpu',\n\t        'encoder.dropout': 'cpu',\n\t    }\n\tdef offload_to_disk(device_map):\n\t    device_map = device_map.copy()\n\t    for k, v in device_map.items():\n", "        if v == \"cpu\":\n\t            device_map[k] = \"disk\"\n\t    return device_map\n\tclass DeepFloydIFStages:\n\t    def __init__(self):\n\t        self.device = os.getenv(\"IFLAB_DEVICE\", \"cuda:0\")\n\t        if sys.platform == \"darwin\":\n\t            self.device = \"mps\"\n\t        self.t5 = None\n\t        self.t5_on_gpu = False\n", "        self.if_I = None\n\t        self.if_II = None\n\t        self.if_III = None\n\t        self.sequential_load = settings.get(\"sequential_load\", None)\n\t        if self.sequential_load is None:\n\t            self.sequential_load = apply_default_mem_settings()\n\t        self.t5_model_name = DEFAULT_MODEL_T5\n\t        self.t5_dtype = \"bfloat16\" if os.getenv(\"IFLAB_T5_DTYPE\", \"float32\").lower() == \"bfloat16\" else \"float32\"\n\t        self.stageI_model_name = settings.get(\"stageI_model\", DEFAULT_MODEL_I)\n\t        self.stageII_model_name = settings.get(\"stageII_model\", DEFAULT_MODEL_II)\n", "        self.stageIII_model_name = settings.get(\"stageIII_model\", DEFAULT_MODEL_III)\n\t        self.has_missing_models = False\n\t        self.loaded = False\n\t        vram_fraction = os.getenv(\"IFLAB_VRAM_FRACTION\", None)\n\t        if vram_fraction:\n\t            torch.cuda.set_per_process_memory_fraction(float(vram_fraction), self.device)\n\t    def load(self):\n\t        if not self.loaded:\n\t            if not LOGGED_IN_HF:\n\t                import pyperclip\n", "                hf_token = os.getenv(\"HF_TOKEN\") or pyperclip.paste()\n\t                if hf_token and hf_token.startswith(\"hf_\"):\n\t                    login(hf_token)\n\t                else:\n\t                    notebook_login()\n\t            if os.getenv(\"IFLAB_INSTALL\", False):\n\t                self.ensure_t5()\n\t                self.ensure_stageI()\n\t                self.unload_stageI()\n\t                self.ensure_stageII()\n", "                self.unload_stageII()\n\t                try:  # may raise error just after it was downloaded from HF\n\t                    self.load_stageIII()\n\t                except:\n\t                    try:\n\t                        time.sleep(.5)\n\t                        self.load_stageIII()\n\t                    except:\n\t                        traceback.print_exc()\n\t                self.unload_stageIII()\n", "            else:\n\t                self.has_missing_models = (not self.downloaded_t5() or not self.downloaded_stageI()\n\t                                           or not self.downloaded_stageII() or not self.downloaded_stageIII())\n\t            self.loaded = True\n\t    def load_t5(self):\n\t        try:\n\t            t5_dtype = torch.bfloat16 if self.t5_dtype == \"bfloat16\" else torch.float32\n\t            t5_model_kwargs = None\n\t            t5_device = \"cpu\"\n\t            if os.getenv(\"IFLAB_T5_ON_GPU\", False):\n", "                self.t5_on_gpu = True\n\t                t5_device = self.device\n\t                t5_device_map = get_t5_device_map(t5_device)\n\t                if os.getenv(\"IFLAB_LOWRAM\", False):\n\t                    t5_device_map = offload_to_disk(t5_device_map)\n\t                t5_model_kwargs = {\"low_cpu_mem_usage\": True,\n\t                                   \"device_map\": t5_device_map,\n\t                                   \"offload_folder\": \"../home/t5-offload\"}\n\t            self.t5 = T5Embedder(device=t5_device, torch_dtype=t5_dtype, t5_model_kwargs=t5_model_kwargs)\n\t        except:\n", "            if DEBUG:\n\t                traceback.print_exc()\n\t    def has_t5(self):\n\t        return not not self.t5\n\t    def downloaded_t5(self):\n\t        return self.if_stage_exists(self.t5_model_name)\n\t    def ensure_t5(self):\n\t        result = bool(self.t5)\n\t        if not self.t5:\n\t            self.load_t5()\n", "        return result\n\t    def unload_t5(self, empty_cache=True):\n\t        if self.t5:\n\t            self.unload_stage(\"t5\", empty_cache=empty_cache)\n\t    def free_t5(self, empty_cache=True):\n\t        if self.t5_on_gpu:\n\t            self.unload_t5(empty_cache=empty_cache)\n\t    def load_stageI(self):\n\t        try:\n\t            self.if_I = ModIFStageI(self.stageI_model_name, device=self.device)\n", "            return self.if_I\n\t        except:\n\t            traceback.print_exc()\n\t    def has_stageI(self):\n\t        current_stageI = settings.get(\"stageI_model\", DEFAULT_MODEL_I)\n\t        if current_stageI != self.stageI_model_name:\n\t            self.stageI_model_name = current_stageI\n\t            self.unload_stageI()\n\t        return not not self.if_I\n\t    def downloaded_stageI(self):\n", "        return self.if_stage_exists(self.stageI_model_name)\n\t    def if_stage_exists(self, model_name):\n\t        return os.path.exists(f\"../home/.cache/IF_/{model_name}\")\n\t    def ensure_stageI(self):\n\t        result = bool(self.if_I)\n\t        if not self.if_I:\n\t            self.load_stageI()\n\t        return result\n\t    def unload_stageI(self, empty_cache=True):\n\t        if self.if_I:\n", "            self.unload_stage(\"if_I\", empty_cache=empty_cache)\n\t    def unload_stage(self, stage, empty_cache=True):\n\t        try:\n\t            getattr(self, stage).model.to(\"cpu\")\n\t        except:\n\t            if DEBUG:\n\t                traceback.print_exc()\n\t        setattr(self, stage, None)\n\t        if empty_cache:\n\t            gc.collect()\n", "            torch.cuda.empty_cache()\n\t            torch.cuda.synchronize()\n\t    def free_stageI(self, empty_cache=True):\n\t        if self.sequential_load != SEQ_LOAD_OFF:\n\t            self.unload_stageI(empty_cache=empty_cache)\n\t    def load_stageII(self):\n\t        try:\n\t            self.if_II = ModIFStageII(self.stageII_model_name, device=self.device)\n\t            return self.if_II\n\t        except:\n", "            traceback.print_exc()\n\t    def has_stageII(self):\n\t        current_stageII = settings.get(\"stageII_model\", DEFAULT_MODEL_II)\n\t        if current_stageII != self.stageII_model_name:\n\t            self.stageII_model_name = current_stageII\n\t            self.unload_stageII()\n\t        return not not self.if_II\n\t    def downloaded_stageII(self):\n\t        return self.if_stage_exists(self.stageII_model_name)\n\t    def ensure_stageII(self):\n", "        result = bool(self.if_II)\n\t        if not self.if_II:\n\t            self.load_stageII()\n\t        return result\n\t    def free_stageII(self, empty_cache=True):\n\t        if self.sequential_load != SEQ_LOAD_OFF:\n\t            self.unload_stageII(empty_cache=empty_cache)\n\t    def unload_stageII(self, empty_cache=True):\n\t        if self.if_II:\n\t            self.unload_stage(\"if_II\", empty_cache=empty_cache)\n", "    def load_stageIII(self):\n\t        separate = self.sequential_load == SEQ_LOAD_SEPARATE\n\t        kwargs = None\n\t        if separate:\n\t            kwargs = {\"precision\": \"16\"}\n\t        self.if_III = ModIFStageIII(self.stageIII_model_name, device=self.device, model_kwargs=kwargs)\n\t        if separate:\n\t            self.if_III.model.enable_sequential_cpu_offload()\n\t        return self.if_III\n\t    def has_stageIII(self):\n", "        current_stageIII = settings.get(\"stageIII_model\", DEFAULT_MODEL_III)\n\t        if current_stageIII != self.stageIII_model_name:\n\t            self.stageIII_model_name = current_stageIII\n\t            self.unload_stageIII()\n\t        return not not self.if_III\n\t    def downloaded_stageIII(self):\n\t        if self.stageIII_model_name.startswith(\"IF\"):\n\t            return self.if_stage_exists(self.stageIII_model_name)\n\t        else:\n\t            return os.path.exists(\"../home/huggingface/hub/models--stabilityai--stable-diffusion-x4-upscaler/snapshots\")\n", "    def ensure_stageIII(self):\n\t        result = bool(self.if_III)\n\t        if not self.if_III:\n\t            self.load_stageIII()\n\t        return result\n\t    def unload_stageIII(self, empty_cache=True):\n\t        if self.if_III:\n\t            self.unload_stage(\"if_III\", empty_cache=empty_cache)\n\t    def free_stageIII(self, empty_cache=True):\n\t        if self.sequential_load != SEQ_LOAD_OFF:\n", "            self.unload_stageIII(empty_cache=empty_cache)\n"]}
{"filename": "modules/iflab/pipelines/super_resolution.py", "chunked_list": ["import time\n\tfrom abc import ABC\n\tfrom collections import UserDict\n\tfrom deepfloyd_if.pipelines import super_resolution\n\tfrom .pipeline import Pipeline, IFResult\n\tfrom .stages import ModelError\n\tfrom .. import EXPERIMENTAL, SEQ_LOAD_SEPARATE\n\tclass SuperResolutionPipeline(Pipeline):\n\t    def __init__(self, stages):\n\t        super().__init__(stages)\n", "        self.custom_paramsII = {\"aug_level\": 0.2}\n\t    def modify_args(self, args):\n\t        pass\n\t    def invoke(self, **kwargs):\n\t        if EXPERIMENTAL and self.experimental:\n\t            return self.experimental.super_resolution_mod(**kwargs)\n\t        else:\n\t            return super_resolution(**kwargs)\n\t    def invoke_ref(self, **kwargs):\n\t        if EXPERIMENTAL and self.experimental:\n", "            print('reference super_resolution')\n\t            return self.experimental.super_resolution_ref(**kwargs)\n\t        else:\n\t            return super_resolution(**kwargs)\n\t    def generate(self, seed=None, progress=True, reference=False):\n\t        if self.stages.sequential_load == SEQ_LOAD_SEPARATE:\n\t            raise ModelError(\"Not implemented for I/II/III\")\n\t        self.prepare_upscale(\"II\")\n\t        self.prepare_upscale(\"III\")\n\t        self.on_before_generation()\n", "        if seed is None:\n\t            seed = self.generate_seed()\n\t        if_II_kwargs = UserDict({\n\t            'sample_timestep_respacing': self.stepsII,\n\t            'guidance_scale': self.guidanceII,\n\t        })\n\t        self.add_custom_parameters(if_II_kwargs, self.custom_paramsII)\n\t        if_II_kwargs.t5_embs = self.t5_embs\n\t        if_II_kwargs.negative_t5_embs = self.negative_t5_embs\n\t        if_III_kwargs = {\n", "            \"guidance_scale\": self.guidanceIII,\n\t            \"noise_level\": self.noiseIII,\n\t            \"sample_timestep_respacing\": str(self.stepsIII),\n\t        }\n\t        kwargs = dict(\n\t            t5=self.stages.t5,\n\t            if_III=self.stages.if_II,\n\t            support_pil_img=self.support_image,\n\t            img_scale=4.,\n\t            img_size=64,\n", "            disable_watermark=self.disable_watermark,\n\t            progress=progress,\n\t            seed=seed,\n\t            if_III_kwargs=if_II_kwargs\n\t        )\n\t        prompt, negative, _ = self.prepare_prompts()\n\t        if prompt:\n\t            kwargs[\"prompt\"] = prompt\n\t        if negative:\n\t            kwargs[\"negative_prompt\"] = negative\n", "        self.merge_args(kwargs, self.override_args)\n\t        seed = kwargs[\"seed\"]\n\t        time_start = time.perf_counter()\n\t        invoke = self.invoke_ref if reference else self.invoke\n\t        middle_res = invoke(\n\t            **kwargs\n\t        )\n\t        self.on_before_upscale()\n\t        self.result_upscale = invoke(\n\t            t5=self.stages.t5,\n", "            if_III=self.stages.if_III,\n\t            prompt=[''],\n\t            support_pil_img=middle_res['III'][0],\n\t            img_scale=4.,\n\t            img_size=256,\n\t            disable_watermark=self.disable_watermark,\n\t            progress=progress,\n\t            seed=seed,\n\t            return_tensors=True,\n\t            if_III_kwargs=if_III_kwargs\n", "        )\n\t        duration = time.perf_counter() - time_start\n\t        images, tensors = self.result_upscale\n\t        output = images[\"output\"]\n\t        self.result_upscale = IFResult(images, tensors, output, None, seed, time.time(), 0, duration)\n\t        return self.result_upscale\n"]}
{"filename": "modules/iflab/pipelines/mac/__init__.py", "chunked_list": ["# mac support stub\n\t# Please see https://github.com/GChristensen/deepfloyd_if_lab_mac/"]}
{"filename": "modules/iflab/ui/pnginfo.py", "chunked_list": ["import weakref\n\timport ipywidgets as widgets\n\tfrom ipywidgets import HBox, Layout\n\tfrom .pipeline import PipelineUI, catch_handler_errors\n\tclass PNGInfoUI(PipelineUI):\n\t    def __init__(self, uis, tabs):\n\t        super().__init__(None)\n\t        self.uis = [weakref.ref(ui) for ui in uis]\n\t        self.tabs = tabs\n\t    def _tune_ui(self):\n", "        self.upload_support_img_button.layout.display = \"none\"\n\t        self.send_to_label = widgets.Label(\"Send to:\")\n\t        self.dream_button = widgets.Button(description='Dream')\n\t        self.dream_button.on_click(self.send_pnginfo)\n\t        self.style_button = widgets.Button(description='Style Transfer')\n\t        self.style_button.on_click(self.send_pnginfo)\n\t        self.sr_button = widgets.Button(description='Super Resolution')\n\t        self.sr_button.on_click(self.send_pnginfo)\n\t        self.inpainting_button = widgets.Button(description='Inpainting')\n\t        self.inpainting_button.on_click(self.send_pnginfo)\n", "        self.spacer = HBox(layout=Layout(flex=\"1 0 auto\"))\n\t        self.pnginfo_button = widgets.FileUpload(\n\t            description='PNG Info',\n\t            accept='.png',\n\t            multiple=False,\n\t            tooltip='Load PNG Info from image'\n\t        )\n\t        self.pnginfo_button.observe(self.load_pnginfo_image)\n\t        spacer = HBox([], layout=Layout(flex=\"1 0 auto\"))\n\t        self.button_box.children = [self.send_to_label, self.dream_button, self.style_button, self.sr_button,\n", "                                    self.inpainting_button, spacer, self.pnginfo_button]\n\t        self.paste_support_img_button.layout.display = \"none\"\n\t        self.info_button.tooltip = \"Browse PNGInfo\"\n\t    def on_display_info(self, button):\n\t        pass\n\t    def load_pnginfo_image(self, e):\n\t        self.load_support_image(e)\n\t        self.load_pnginfo(e)\n\t    def send_pnginfo(self, button):\n\t        for i, c in enumerate(self.button_box.children):\n", "            if c is button:\n\t                ui = self.uis[i - 1]()\n\t                parameters = self.get_ui_parameters()\n\t                ui.set_ui_parameters(parameters)\n\t                self.tabs.selected_index = i - 1\n\t                break\n\t    def get_title(self):\n\t        return \"PNG Info\"\n"]}
{"filename": "modules/iflab/ui/settings.py", "chunked_list": ["import json\n\timport ipywidgets as widgets\n\tfrom ipywidgets import VBox, Layout\n\tfrom ..settings import settings\n\tclass SettingsUI():\n\t    def __init__(self, uis):\n\t        self.uis = uis\n\t        models_label = widgets.Label(\" Models\", style=dict(background=\"var(--jp-layout-color2)\"))\n\t        self.stageI_model_dropdown = widgets.Dropdown(\n\t            options=['IF-I-XL-v1.0', 'IF-I-L-v1.0', 'IF-I-M-v1.0'],\n", "            value='IF-I-XL-v1.0',\n\t            description='Stage I: ',\n\t            style= {'description_width': 'max-content'},\n\t            disabled=False,\n\t        )\n\t        self.stageI_model_dropdown.observe(self.on_settings_changed, 'value', type='change')\n\t        self.stageI_model_dropdown.__setting = \"stageI_model\"\n\t        self.stageI_model_dropdown.value = settings.get(self.stageI_model_dropdown.__setting,\n\t                                                        self.stageI_model_dropdown.options[0])\n\t        self.stageII_model_dropdown = widgets.Dropdown(\n", "            options=['IF-II-L-v1.0', 'IF-II-M-v1.0'],\n\t            value='IF-II-L-v1.0',\n\t            description='Stage II: ',\n\t            style= {'description_width': 'max-content'},\n\t            disabled=False,\n\t        )\n\t        self.stageII_model_dropdown.observe(self.on_settings_changed, 'value', type='change')\n\t        self.stageII_model_dropdown.__setting = \"stageII_model\"\n\t        self.stageII_model_dropdown.value = settings.get(self.stageII_model_dropdown.__setting,\n\t                                                         self.stageII_model_dropdown.options[0])\n", "        self.stageIII_model_dropdown = widgets.Dropdown(\n\t            options=['stable-diffusion-x4-upscaler', 'IF-III-L-v1.0'],\n\t            value='stable-diffusion-x4-upscaler',\n\t            description='Stage III: ',\n\t            style= {'description_width': 'max-content'},\n\t            disabled=False,\n\t        )\n\t        self.stageIII_model_dropdown.observe(self.on_settings_changed, 'value', type='change')\n\t        self.stageIII_model_dropdown.__setting = \"stageIII_model\"\n\t        self.stageIII_model_dropdown.value = settings.get(self.stageIII_model_dropdown.__setting,\n", "                                                          self.stageIII_model_dropdown.options[0])\n\t        self.sequential_loading_dropdown = widgets.Dropdown(\n\t            options=[('I+II+III (24GB)', 'off',), ('I/II+III (12GB)', 'merge'), ('I/II/III (8GB)', 'separate')],\n\t            value='separate',\n\t            description='Layout: ',\n\t            style= {'description_width': 'max-content'},\n\t            disabled=False,\n\t        )\n\t        self.sequential_loading_dropdown.observe(self.on_settings_changed, 'value', type='change')\n\t        self.sequential_loading_dropdown.__setting = \"sequential_load\"\n", "        self.sequential_loading_dropdown.value = settings.get(self.sequential_loading_dropdown.__setting,\n\t                                                              self.sequential_loading_dropdown.options[2][1])\n\t        generation_label = widgets.Label(\" Generation\",\n\t                                         style=dict(background=\"var(--jp-layout-color2)\"))\n\t        self.disable_watermark_check = widgets.Checkbox(\n\t            description=\"Disable watermark\"\n\t        )\n\t        self.disable_watermark_check.observe(self.on_settings_changed, 'value', type='change')\n\t        self.disable_watermark_check.__setting = \"disable_watermark\"\n\t        self.disable_watermark_check.value = settings.get(self.disable_watermark_check.__setting, False)\n", "        ui_label = widgets.Label(\" User Interface\",\n\t                                 style=dict(background=\"var(--jp-layout-color2)\"))\n\t        self.remember_ui_state_check = widgets.Checkbox(\n\t            description=\"Remember UI state\"\n\t        )\n\t        self.remember_ui_state_check.observe(self.on_settings_changed, 'value', type='change')\n\t        self.remember_ui_state_check.__setting = \"remember_ui_state\"\n\t        self.remember_ui_state_check.value = settings.get(self.remember_ui_state_check.__setting, False)\n\t        self.root_box = VBox([models_label,\n\t                              self.stageI_model_dropdown, self.stageII_model_dropdown,\n", "                              self.stageIII_model_dropdown,\n\t                              self.sequential_loading_dropdown,\n\t                              generation_label,\n\t                              self.disable_watermark_check,\n\t                              ui_label,\n\t                              self.remember_ui_state_check],\n\t                             layout=Layout(min_height=\"500px\"))\n\t    def get(self):\n\t        return self.root_box\n\t    def get_title(self):\n", "        return \"Settings\"\n\t    def load_settings(self):\n\t        settings.load()\n\t        self.notify_uis()\n\t    def on_settings_changed(self, e):\n\t        key = e.owner.__setting\n\t        value = e[\"new\"]\n\t        self.setting_action(key, value)\n\t        settings[key] = value\n\t        settings.save()\n", "        self.notify_uis()\n\t    def setting_action(self, key, value):\n\t        pass\n\t    def settings_changed(self, e):\n\t        pass\n\t    def notify_uis(self):\n\t        for ui in self.uis:\n\t            ui.settings_changed(settings)\n"]}
{"filename": "modules/iflab/ui/dream.py", "chunked_list": ["from .pipeline import PipelineUI, catch_handler_errors\n\tclass Txt2ImgUI(PipelineUI):\n\t    def __init__(self, pipeline):\n\t        super().__init__(pipeline)\n\t        self.IMAGE_FOLDER = \"dream\"\n\t    def _tune_ui(self):\n\t        self.images_box.layout.display = \"none\"\n\t        self.info_button.tooltip = \"Generate images from a text prompt\"\n\t    def on_display_info(self, button):\n\t        pass\n", "        #webbrowser.open(\"https://github.com/deep-floyd/IF#i-dream\")\n\t    def get_title(self):\n\t        return \"Dream\"\n"]}
{"filename": "modules/iflab/ui/main.py", "chunked_list": ["import importlib\n\timport ipywidgets as widgets\n\tfrom IPython.core.display_functions import clear_output\n\tfrom IPython.display import display\n\tfrom ipywidgets import HTML, VBox, Layout\n\tfrom ..const import VERSION\n\tfrom ..settings import settings\n\tfrom ..pipelines.inpainting import InpaintingPipeline\n\tfrom ..pipelines.super_resolution import SuperResolutionPipeline\n\tfrom ..pipelines.style_transfer import StylePipeline\n", "from ..pipelines.dream import DreamPipeline\n\tfrom .settings import SettingsUI\n\tfrom .super_resolution import SuperResolutionUI\n\tfrom .dream import Txt2ImgUI\n\tfrom .style_transfer import Img2ImgUI\n\tfrom .inpainting import InpaintingUI\n\tfrom .pnginfo import PNGInfoUI\n\tclass DeepFloydIFUI:\n\t    def __init__(self, stages=None):\n\t        self.stages = stages\n", "        self.root_box = None\n\t        self.title_label = None\n\t        self.uis = None\n\t        self.inpainting = None\n\t        self.super_resolution = None\n\t        self.style_transfer = None\n\t        self.dream = None\n\t        self.tabs = None\n\t        if stages:\n\t            self.init(stages)\n", "    def init(self, stages):\n\t        self.tabs = widgets.Tab()\n\t        self.dream = self.create_dream_ui(stages)\n\t        self.style_transfer = self.create_style_ui(stages)\n\t        self.super_resolution = self.create_sr_ui(stages)\n\t        self.inpainting = self.create_inpainting_ui(stages)\n\t        self.uis = [\n\t            self.dream,\n\t            self.style_transfer,\n\t            self.super_resolution,\n", "            self.inpainting\n\t        ]\n\t        pipeline_uis = self.uis[:]\n\t        pnginfo_ui = PNGInfoUI(self.uis, self.tabs)\n\t        self.uis.append(pnginfo_ui)\n\t        settings_ui = SettingsUI(self.uis)\n\t        self.uis.append(settings_ui)\n\t        for ui in pipeline_uis:\n\t            ui.save_ui_state = self.save_ui_state\n\t            ui.load_ui_state = self.load_ui_state\n", "            ui.send_to_sr = self.send_to_super_resolution\n\t            ui.restore_ui_state()\n\t        self.tabs.children = [ui.get() for ui in self.uis]\n\t        for i in range(len(self.tabs.children)):\n\t            self.tabs.set_title(i, self.uis[i].get_title())\n\t        self.title_label = widgets.Label(f\"DeepFloyd IF Lab v{VERSION}\",\n\t                                         layout=Layout(display=\"flex\", justify_content=\"flex-end\"))\n\t        if settings.get(\"remember_ui_state\", False):\n\t            self.tabs.selected_index = settings.get(\"active_tab\", 0)\n\t        self.root_box = VBox([self.title_label, self.tabs])\n", "    def create_dream_ui(self, stages):\n\t        dream_pipeline = DreamPipeline(stages)\n\t        return Txt2ImgUI(dream_pipeline)\n\t    def create_style_ui(self, stages):\n\t        style_pipeline = StylePipeline(stages)\n\t        return Img2ImgUI(style_pipeline)\n\t    def create_sr_ui(self, stages):\n\t        sr_pipeline = SuperResolutionPipeline(stages)\n\t        return SuperResolutionUI(sr_pipeline)\n\t    def create_inpainting_ui(self, stages):\n", "        inpainting_pipeline = InpaintingPipeline(stages)\n\t        return InpaintingUI(inpainting_pipeline)\n\t    def save_ui_state(self, key, state):\n\t        ui_state = settings.get(\"ui_state\", {})\n\t        ui_state[key] = state\n\t        settings[\"ui_state\"] = ui_state\n\t        settings[\"active_tab\"] = self.tabs.selected_index\n\t        settings.save()\n\t    def load_ui_state(self, key):\n\t        ui_state = settings.get(\"ui_state\", {})\n", "        return ui_state.get(key, None)\n\t    def send_to_super_resolution(self, image, parameters):\n\t        self.super_resolution.set_support_image(image, parameters)\n\t        self.tabs.selected_index = 2\n\t    def get(self):\n\t        return self.root_box\n\t    def show(self):\n\t        self._apply_style()\n\t        display(self.root_box)\n\t    @staticmethod\n", "    def load():\n\t        stages_module = importlib.import_module('.'.join(__name__.split('.')[:-2]) + \".pipelines.stages\")\n\t        if_stages = stages_module.DeepFloydIFStages()\n\t        if_stages.load()\n\t        clear_output()\n\t        ui = DeepFloydIFUI()\n\t        ui.init(if_stages)\n\t        return ui\n\t    def _apply_style(self):\n\t        display(\n", "            HTML(\n\t                \"\"\"\n\t                    <style>\n\t                    .lm-TabBar-tab {\n\t                        flex: 0 1 var(--jp-widgets-horizontal-tab-width);\n\t                        min-width: 35px;\n\t                        min-height: calc(var(--jp-widgets-horizontal-tab-height) + var(--jp-border-width));\n\t                        line-height: var(--jp-widgets-horizontal-tab-height);\n\t                        margin-left: calc(-1 * var(--jp-border-width));\n\t                        padding: 0px 10px;\n", "                        background: var(--jp-layout-color2);\n\t                        color: var(--jp-ui-font-color2);\n\t                        border: var(--jp-border-width) solid var(--jp-border-color1);\n\t                        border-bottom: none;\n\t                        position: relative;\n\t                    }\n\t                    .lm-TabBar-tab.p-mod-current {\n\t                        color: var(--jp-ui-font-color0);\n\t                        /* We want the background to match the tab content background */\n\t                        background: var(--jp-layout-color1);\n", "                        min-height: calc(var(--jp-widgets-horizontal-tab-height) + 2 * var(--jp-border-width));\n\t                        transform: translateY(var(--jp-border-width));\n\t                        overflow: visible;\n\t                    }\n\t                    .lm-TabBar-tab.p-mod-current:before {\n\t                        position: absolute;\n\t                        top: calc(-1 * var(--jp-border-width));\n\t                        left: calc(-1 * var(--jp-border-width));\n\t                        content: '';\n\t                        height: var(--jp-widgets-horizontal-tab-top-border);\n", "                        width: calc(100% + 2 * var(--jp-border-width));\n\t                        background: var(--jp-brand-color1);\n\t                    }\n\t                    .lm-TabBar-tab:first-child {\n\t                        margin-left: 0;\n\t                    }\n\t                    .lm-TabBar-tab:hover:not(.p-mod-current) {\n\t                        background: var(--jp-layout-color1);\n\t                        color: var(--jp-ui-font-color1);\n\t                    }\n", "                    .lm-TabBar-tabIcon,\n\t                    .lm-TabBar-tabLabel,\n\t                    .lm-TabBar-tabCloseIcon {\n\t                        line-height: var(--jp-widgets-horizontal-tab-height);\n\t                    }\n\t                    .iflab-title-label {\n\t                        width: 99%;\n\t                        background-color: var(--jp-layout-color2);\n\t                        margin-top: 10px;\n\t                    }\n", "                    .iflab-upscale-separator {\n\t                        border: none;\n\t                        border-top: 1px solid var(--jp-layout-color2);\n\t                    }\n\t                    </style>\n\t                \"\"\"\n\t            ))\n"]}
{"filename": "modules/iflab/ui/pipeline.py", "chunked_list": ["import ast\n\timport os\n\timport random\n\timport re\n\timport json\n\timport threading\n\timport traceback\n\tfrom dataclasses import dataclass\n\tfrom datetime import datetime\n\tfrom functools import wraps\n", "from abc import ABC, abstractmethod\n\tfrom threading import Thread\n\tfrom io import BytesIO\n\tfrom pathlib import Path\n\timport ipywidgets as widgets\n\tfrom IPython.core.display import Javascript\n\tfrom IPython.core.display_functions import display\n\tfrom ipywidgets import HBox, VBox, Layout\n\tfrom PIL.PngImagePlugin import PngInfo\n\tfrom PIL import Image, ImageGrab\n", "from ..const import DEBUG, RESPACING_MODES, UI_THREADS, DEBUG_PROMPT\n\tfrom ..pipelines.stages import ModelError\n\tfrom .. import SEQ_LOAD_SEPARATE\n\tLOADING_CHECKPOINTS = \"Loading checkpoints...\"\n\tDOWNLOADING_CHECKPOINTS = \"Downloading checkpoints, please wait...\"\n\tdef catch_handler_errors(method):\n\t    @wraps(method)\n\t    def wrapped(*args, **kwargs):\n\t        result = None\n\t        try:\n", "            result = method(*args, **kwargs)\n\t        except Exception as e:\n\t            with args[0].output:\n\t                traceback.print_exc()\n\t        return result\n\t    return wrapped\n\tclass PipelineUI(ABC):\n\t    def __init__(self, pipeline):\n\t        self.DEFAULT_PROMPT = DEBUG_PROMPT if DEBUG else \"\"\n\t        self.STAGE_I_SCALE = 2.5\n", "        self.STOP_BUTTON_LABEL = \"Stop\"\n\t        self.WAIT_BUTTON_LABEL = \"⏳Waiting...\"\n\t        self.SERIES_BUTTON_LABEL = \"Batch Stage I\"\n\t        self.UPSCALE_BUTTON_LABEL = \"🔬Upscale\"\n\t        self.settings = {}\n\t        self.pipeline = pipeline\n\t        if self.pipeline:\n\t            self.pipeline.on_before_embeddings = self.on_before_embeddings\n\t            self.pipeline.on_before_generation = self.on_before_generation\n\t            self.pipeline.on_before_upscale = self.on_before_upscale\n", "            self.pipeline.on_before_checkpoints_loaded = self.on_before_checkpoints_loaded\n\t            self.pipeline.on_checkpoints_loaded = self.on_checkpoints_loaded\n\t        self.generation_thread = None\n\t        self.generation_finished_event = None\n\t        self.stop_generation = False\n\t        self.resultsI = {}\n\t        self.upscaleII = []\n\t        self.upscaleIII = []\n\t        self.upscale_resultsII = {}\n\t        self.upscale_result_boxes = {}\n", "        self.upscaling = False\n\t        self.upscaling_stage = None\n\t        self.upscaling_stage_max = None\n\t        self.upscaling_progress_thread = None\n\t        self.upscaling_progress_event = None\n\t        self.stop_upscale = False\n\t        self.stageI_time = 0\n\t        self.stageII_time = 0\n\t        self.stageIII_time = 0\n\t        self.stageIII_iter_time = 0\n", "        self.save_ui_state = lambda k, s: None\n\t        self.load_ui_state = lambda k: None\n\t        self.send_to_sr = lambda i, p: None\n\t        self.output = widgets.Output()\n\t        self.prompt_label = widgets.Label(\"Prompt\")\n\t        self.prompt_text = widgets.Textarea(value=self.DEFAULT_PROMPT, layout=Layout(width=\"99%\", height=\"6em\"))\n\t        self.negative_prompt_label = widgets.Label(\"Negative prompt\")\n\t        self.negative_prompt_text = widgets.Textarea(value=\"\", layout=Layout(width=\"99%\", height=\"6em\"))\n\t        self.style_prompt_label = widgets.Label(\"Style prompt\")\n\t        self.style_prompt_text = widgets.Textarea(value=\"\", layout=Layout(width=\"99%\", height=\"6em\"))\n", "        self.stageI_custom_params_text = widgets.Text(\n\t            description='if_I_kwargs:',\n\t            value=self.format_custom_parameters(pipeline.custom_paramsI if pipeline else \"\"),\n\t            layout=Layout(width=\"99%\")\n\t        )\n\t        self.stageII_custom_params_text = widgets.Text(\n\t            description='if_II_kwargs:',\n\t            value=self.format_custom_parameters(pipeline.custom_paramsII if pipeline else \"\"),\n\t            layout=Layout(width=\"99%\")\n\t        )\n", "        self.stageIII_custom_params_text = widgets.Text(\n\t            description='if_III_kwargs:',\n\t            value=self.format_custom_parameters(pipeline.custom_paramsIII if pipeline else \"\"),\n\t            layout=Layout(width=\"99%\")\n\t        )\n\t        self.aspect_ratio_text = widgets.Text(\n\t            value='1:1',\n\t            description='Aspect Ratio'\n\t        )\n\t        self.sIII_pass_prompt_check = widgets.Checkbox(\n", "            description=\"Pass prompt to the stage III\"\n\t        )\n\t        self.sIII_pass_prompt_check.value = True\n\t        self.custom_parameter_box = VBox([\n\t            widgets.Label(\"Advanced options\"),\n\t            self.stageI_custom_params_text,\n\t            self.stageII_custom_params_text,\n\t            self.stageIII_custom_params_text,\n\t            self.aspect_ratio_text,\n\t            self.sIII_pass_prompt_check\n", "        ], layout=Layout(display=\"none\"))\n\t        self.prompt_box = VBox([self.prompt_label, self.prompt_text,\n\t                                self.negative_prompt_label, self.negative_prompt_text,\n\t                                self.style_prompt_label, self.style_prompt_text,\n\t                                self.custom_parameter_box],\n\t                               layout=Layout(flex=\"1 0 auto\"))\n\t        self.params_label = widgets.Label(\" \")\n\t        self.batch_images_slider = widgets.IntSlider(\n\t            value=2 if DEBUG else 100,\n\t            min=1,\n", "            max=250,\n\t            step=1,\n\t            description='Batch Images',\n\t            orientation='horizontal',\n\t            readout=True,\n\t            readout_format='d'\n\t        )\n\t        self.respacingI_slider = widgets.SelectionSlider(\n\t            options=RESPACING_MODES,\n\t            value='smart27' if DEBUG else 'smart100',\n", "            description='Respacing I',\n\t            orientation='horizontal',\n\t            readout=True\n\t        )\n\t        self.guidanceI_slider = widgets.IntSlider(\n\t            value=7,\n\t            min=1,\n\t            max=20,\n\t            step=1,\n\t            description='Guidance I',\n", "            orientation='horizontal',\n\t            readout=True,\n\t            readout_format='d'\n\t        )\n\t        self.respacingII_slider = widgets.SelectionSlider(\n\t            options=RESPACING_MODES,\n\t            value='smart50',\n\t            description='Respacing II',\n\t            orientation='horizontal',\n\t            readout=True\n", "        )\n\t        self.guidanceII_slider = widgets.IntSlider(\n\t            value=4,\n\t            min=1,\n\t            max=20,\n\t            step=1,\n\t            description='Guidance II',\n\t            orientation='horizontal',\n\t            readout=True,\n\t            readout_format='d'\n", "        )\n\t        self.respacingIII_slider = widgets.IntSlider(\n\t            value=75,\n\t            min=0,\n\t            max=200,\n\t            step=5,\n\t            description='Respacing III',\n\t            orientation='horizontal',\n\t            readout=True,\n\t            readout_format='d'\n", "        )\n\t        self.guidanceIII_slider = widgets.IntSlider(\n\t            value=4,\n\t            min=1,\n\t            max=20,\n\t            step=1,\n\t            description='Guidance III',\n\t            orientation='horizontal',\n\t            readout=True,\n\t            readout_format='d'\n", "        )\n\t        self.noiseIII_slider = widgets.IntSlider(\n\t            value=20,\n\t            min=1,\n\t            max=100,\n\t            step=1,\n\t            description='Noise III',\n\t            orientation='horizontal',\n\t            readout=True,\n\t            readout_format='d'\n", "        )\n\t        self.seed_number = widgets.IntText(\n\t            value=-1,\n\t            description='Seed',\n\t            disabled=False\n\t        )\n\t        self.fast_presets = widgets.Button(\n\t            description='Fast',\n\t            tooltip='Fast generation (prompt tuning)',\n\t            layout=Layout(width=\"33.3%\")\n", "        )\n\t        self.fast_presets.on_click(self.on_set_fast_presets)\n\t        self.default_presets = widgets.Button(\n\t            description='Default',\n\t            tooltip='Default settings',\n\t            layout=Layout(width=\"33.3%\")\n\t        )\n\t        self.default_presets.on_click(self.on_set_default_presets)\n\t        self.hq_presets = widgets.Button(\n\t            description='Elaborate',\n", "            tooltip='Slow generation (more details)',\n\t            layout=Layout(width=\"33.3%\")\n\t        )\n\t        self.hq_presets.on_click(self.on_set_hq_presets)\n\t        self.preset_box = HBox([self.fast_presets, self.default_presets, self.hq_presets])\n\t        self.params_box = VBox([self.params_label, self.batch_images_slider, self.respacingI_slider, self.guidanceI_slider,\n\t                                self.respacingII_slider, self.guidanceII_slider,\n\t                                self.respacingIII_slider, self.guidanceIII_slider, self.noiseIII_slider,\n\t                                self.seed_number, self.preset_box])\n\t        self.input_box = HBox([self.prompt_box, self.params_box], layout=Layout(width=\"100%\"))\n", "        self.info_button = widgets.Button(description='ℹ️', tooltip='', layout=Layout(width='40px'),\n\t                                          style={\"button_color\": \"#212121\"})\n\t        self.info_button.on_click(self.on_display_info)\n\t        self.generate_button = widgets.Button(\n\t            description='Stage I',\n\t            tooltip='Generate stage I image'\n\t        )\n\t        self.generate_button.on_click(self.on_generate_click)\n\t        self.generate_series_button = widgets.Button(\n\t            description=self.SERIES_BUTTON_LABEL,\n", "            tooltip='Generate a series of stage I images'\n\t        )\n\t        self.generate_series_button.on_click(self.on_generate_series_click)\n\t        self.clear_results_button = widgets.Button(\n\t            description='🗑️',\n\t            tooltip='Clear stage I results',\n\t            layout=Layout(width=\"40px\")\n\t        )\n\t        self.clear_results_button.on_click(self.clear_results)\n\t        self.clear_results_button2 = widgets.Button(\n", "            description='🗑️',\n\t            tooltip='Clear stage I results',\n\t            layout=Layout(width=\"40px\")\n\t        )\n\t        self.clear_results_button2.on_click(self.clear_results)\n\t        self.upscale_button = widgets.Button(\n\t            description=self.UPSCALE_BUTTON_LABEL,\n\t            tooltip='Upscale the selected stage I images'\n\t        )\n\t        self.upscale_button.on_click(self.on_upscale_click)\n", "        self.upscale_button2 = widgets.Button(\n\t            description=self.UPSCALE_BUTTON_LABEL,\n\t            tooltip='Upscale the selected stage I images'\n\t        )\n\t        self.upscale_button2.on_click(self.on_upscale_click)\n\t        self.embeddings_button = widgets.Button(\n\t            description='T5',\n\t            tooltip='Only generate T5 embeddings',\n\t            layout=Layout(width=\"40px\", display=\"block\")\n\t        )\n", "        self.embeddings_button.on_click(lambda b: self.compute_embeddings())\n\t        self.pnginfo_button = widgets.FileUpload(\n\t            description='PNG Info',\n\t            accept='.png',\n\t            multiple=False,\n\t            tooltip='Load PNG Info from image'\n\t        )\n\t        self.pnginfo_button.observe(self.load_pnginfo, 'value', type='change')\n\t        self.clear_upscales_button = widgets.Button(\n\t            description='🗑️',\n", "            tooltip='Clear upscales',\n\t            layout=Layout(width=\"40px\")\n\t        )\n\t        self.clear_upscales_button.on_click(self.clear_upscales)\n\t        self.clear_upscales_button2 = widgets.Button(\n\t            description='🗑️',\n\t            tooltip='Clear upscales',\n\t            layout=Layout(width=\"40px\")\n\t        )\n\t        self.clear_upscales_button2.on_click(self.clear_upscales)\n", "        self.custom_parameters_button = widgets.Button(\n\t            description='🎰',\n\t            tooltip='Advanced options',\n\t            layout=Layout(width=\"40px\")\n\t        )\n\t        self.custom_parameters_button.on_click(self.toggle_custom_parameters)\n\t        self.random_seed_button = widgets.Button(\n\t            description='🎲',\n\t            tooltip='Use random seed',\n\t            layout=Layout(width=\"40px\")\n", "        )\n\t        self.random_seed_button.on_click(lambda b: setattr(self.seed_number, \"value\", -1))\n\t        spacer = HBox([], layout=Layout(flex=\"1 0 auto\"))\n\t        padder = HBox([], layout=Layout(flex=\"0 1 10px\"))\n\t        self.button_box = HBox([self.info_button, self.generate_button, self.generate_series_button,\n\t                                self.clear_results_button, self.upscale_button, self.clear_upscales_button,\n\t                                self.custom_parameters_button, self.random_seed_button, spacer,\n\t                                self.pnginfo_button, padder],\n\t                               layout=Layout(flex=\"1 0 auto\"))\n\t        self.progress_bar = widgets.IntProgress(\n", "            value=0,\n\t            min=0,\n\t            max=0,\n\t            bar_style='',\n\t            orientation='horizontal',\n\t            layout=Layout(width=\"100%\")\n\t        )\n\t        self.stageI_results_label = widgets.Label(\" Stage I Results\", layout=Layout(display=\"none\"),\n\t                                                  style={\"font_weight\": \"bold\"})\n\t        self.stageI_results_label.add_class(\"iflab-title-label\")\n", "        self.upscale_results_label = widgets.Label(\" Upscale Results\", layout=Layout(display=\"none\"),\n\t                                                   style={\"font_weight\": \"bold\"})\n\t        self.upscale_results_label.add_class(\"iflab-title-label\")\n\t        self.status_box = HBox([], layout=Layout(width=\"272px\", flex=\"0 0 auto\"))\n\t        self.status_icon = widgets.Label(value=\"  \", layout=Layout(width=\"2em\"))\n\t        self.status_container = HBox([self.status_icon, self.status_box])\n\t        self.control_box = HBox([self.button_box, self.status_container],\n\t                                layout=Layout(width=\"100%\", margin=\"20px 0\"))\n\t        self.upload_support_img_button = widgets.FileUpload(\n\t            description='Source Image',\n", "            multiple=False,\n\t            tooltip='Load source image'\n\t        )\n\t        self.upload_support_img_button.observe(self.load_support_image, 'value', type='change')\n\t        self.paste_support_img_button = widgets.Button(\n\t            description='Paste',\n\t            tooltip='Paste support image from clipboard'\n\t        )\n\t        self.paste_support_img_button.on_click(self.paste_support_image)\n\t        self.upload_mask_img_button = widgets.FileUpload(\n", "            description='Mask Image',\n\t            multiple=False,\n\t            tooltip='Load mask image',\n\t            layout=Layout(display=\"none\")\n\t        )\n\t        self.upload_mask_img_button.observe(self.load_mask_image, 'value', type='change')\n\t        self.paste_mask_img_button = widgets.Button(\n\t            description='Paste',\n\t            tooltip='Paste mask image from clipboard',\n\t            layout=Layout(display=\"none\")\n", "        )\n\t        self.paste_mask_img_button.on_click(self.paste_mask_image)\n\t        self.support_img_view = widgets.Image(layout=Layout(width=\"max-content\", height=\"max-content\", max_width=\"95%\", display=\"none\"))\n\t        self.mask_img_view = widgets.Image(layout=Layout(width=\"max-content\", height=\"max-content\", max_width=\"95%\", display=\"none\"))\n\t        self.support_image_box = HBox([self.support_img_view], layout=Layout(width=\"50%\"))\n\t        self.mask_image_box = HBox([self.mask_img_view], layout=Layout(width=\"50%\"))\n\t        self.images_box = VBox([\n\t            HBox([\n\t                HBox([self.upload_support_img_button,\n\t                      self.paste_support_img_button],\n", "                     layout=Layout(width=\"50%\")),\n\t                HBox([self.upload_mask_img_button,\n\t                      self.paste_mask_img_button],\n\t                     layout=Layout(width=\"50%\"))\n\t            ]),\n\t            HBox([self.support_image_box,\n\t                  self.mask_image_box])\n\t        ], layout=Layout(width=\"100%\"))\n\t        self.result_box = HBox([], layout=Layout(width=\"100%\", margin=\"20px 0\", flex_flow=\"row wrap\", display=\"none\"))\n\t        self.result_button_box = VBox([\n", "            widgets.HTML(\"<hr class='iflab-upscale-separator'>\"),\n\t            HBox([self.upscale_button2, self.clear_results_button2])\n\t        ], layout=Layout(width=\"100%\", margin=\"5px 0\", display=\"none\"))\n\t        self.upscale_box = VBox([], layout=Layout(width=\"100%\", margin=\"20px 0\", display=\"none\"))\n\t        self.upscale_button_box = VBox([\n\t            widgets.HTML(\"<hr class='iflab-upscale-separator'>\"),\n\t            HBox([self.clear_upscales_button2])\n\t        ], layout=Layout(width=\"100%\", margin=\"5px 0\", display=\"none\"))\n\t        self.root_box = VBox([self.input_box, self.control_box, self.images_box,\n\t                              self.stageI_results_label, self.result_box,self.result_button_box,\n", "                              self.upscale_results_label, self.upscale_box, self.upscale_button_box,\n\t                              self.output],\n\t                             layout=Layout(width=\"100%\"))\n\t        self._tune_ui()\n\t    def _get_nsfw_status(self, result, stage):\n\t        nsfw = result.tensors is not None and result.tensors[stage] is not None \\\n\t               and hasattr(result.tensors[stage], \"hentai\")\n\t        return \"*\" if nsfw else \"\"\n\t    def _image_to_bytes(self, image):\n\t        b = BytesIO()\n", "        image.save(b, format='png')\n\t        b.seek(0)\n\t        return b.read()\n\t    def _get_file_name(self, time, seed, stage):\n\t        time_label = self._get_time_label(time)\n\t        output_dir = os.getenv(\"IFLAB_OUTPUT_DIR\", \"outputs\")\n\t        return f\"{output_dir}/{self.IMAGE_FOLDER}/{time_label}-{seed}-stage-{stage}.png\"\n\t    def _get_time_label(self, t):\n\t        d = datetime.fromtimestamp(t)\n\t        return d.strftime(\"%Y%m%d_%H%M%S\")\n", "    def status_message(self, text):\n\t        self.status_box.children = [widgets.Label(text)]\n\t    def set_status_idle(self):\n\t        self.status_icon.value = \"  \"\n\t    def set_status_computing(self):\n\t        self.status_icon.value = \"💻\"\n\t    def set_status_waiting(self):\n\t        self.status_icon.value = \"⏳\"\n\t    def set_status_result(self):\n\t        self.status_icon.value = \"📶\"\n", "    def set_status_error(self):\n\t        self.status_icon.value = \"⚠️\"\n\t    def show_progress_bar(self):\n\t        self.progress_bar.value = 0\n\t        self.status_box.children = [self.progress_bar]\n\t    def is_prompt_valid(self):\n\t        return self.prompt_text.value or self.negative_prompt_text.value or self.style_prompt_text.value\n\t    def set_ui_parameters(self, parameters, is_pnginfo=False):\n\t        self.prompt_text.value = parameters.get(\"prompt\", \"\")\n\t        self.negative_prompt_text.value = parameters.get(\"negative_prompt\", \"\")\n", "        self.style_prompt_text.value = parameters.get(\"style_prompt\", \"\")\n\t        self.seed_number.value = parameters.get(\"seed\", -1)\n\t        self.aspect_ratio_text.value = parameters.get(\"aspect_ratio\", \"\")\n\t        self.guidanceI_slider.value = parameters.get(\"guidanceI\", 1)\n\t        self.respacingI_slider.value = parameters.get(\"respacingI\", \"\")\n\t        self.guidanceII_slider.value = parameters.get(\"guidanceII\", 1)\n\t        self.respacingII_slider.value = parameters.get(\"respacingII\", \"\")\n\t        self.guidanceIII_slider.value = parameters.get(\"guidanceIII\", 1)\n\t        self.respacingIII_slider.value = int(parameters.get(\"respacingIII\", 1))\n\t        self.noiseIII_slider.value = parameters.get(\"noiseIII\", 1)\n", "        self.stageI_custom_params_text.value = parameters.get(\"if_I_kwargs\", \"\") or \"\"\n\t        self.stageII_custom_params_text.value = parameters.get(\"if_II_kwargs\", \"\") or \"\"\n\t        self.stageIII_custom_params_text.value = parameters.get(\"if_III_kwargs\", \"\") or \"\"\n\t        self.sIII_pass_prompt_check.value = parameters.get(\"pass_prompt_to_stage_III\", True)\n\t        if is_pnginfo:\n\t            self.mask_image_box.children = [widgets.HTML(f\"\"\"\n\t                Stage: {parameters.get(\"stage\", \"\")}<br>\n\t                Stage I model: {parameters.get(\"stageI_model\", \"\")}<br>\n\t                Stage II model: {parameters.get(\"stageII_model\", \"\")}<br>\n\t                Stage III model: {parameters.get(\"stageIII_model\", \"\")}<br>\n", "                T5 precision: {parameters.get(\"t5_precision\", \"\")}<br>\n\t            \"\"\")]\n\t    def set_seed_value(self, seed):\n\t        self.seed_number.value = seed\n\t    def on_set_fast_presets(self, button):\n\t        self.respacingI_slider.value = \"smart27\"\n\t        self.respacingII_slider.value = \"smart27\"\n\t        self.respacingIII_slider.value = 20\n\t        self.guidanceIII_slider.value = 4\n\t    def on_set_default_presets(self, button):\n", "        self.aspect_ratio_text.value = \"1:1\"\n\t        self.guidanceI_slider.value = 7.0\n\t        self.respacingI_slider.value = \"smart100\"\n\t        self.guidanceII_slider.value = 4.0\n\t        self.respacingII_slider.value = \"smart50\"\n\t        self.guidanceIII_slider.value = 9.0\n\t        self.respacingIII_slider.value = 75\n\t        self.noiseIII_slider.value = 20\n\t    def on_set_hq_presets(self, button):\n\t        self.respacingI_slider.value = \"smart185\"\n", "        self.respacingII_slider.value = \"smart185\"\n\t        self.respacingIII_slider.value = 180\n\t        self.guidanceIII_slider.value = 4\n\t    def get_ui_parameters(self):\n\t        parameters = {\n\t            \"prompt\": self.prompt_text.value,\n\t            \"negative_prompt\": self.negative_prompt_text.value,\n\t            \"style_prompt\": self.style_prompt_text.value,\n\t            \"seed\": self.seed_number.value,\n\t            \"aspect_ratio\": self.aspect_ratio_text.value,\n", "            \"guidanceI\": self.guidanceI_slider.value,\n\t            \"respacingI\": self.respacingI_slider.value,\n\t            \"guidanceII\": self.guidanceII_slider.value,\n\t            \"respacingII\": self.respacingII_slider.value,\n\t            \"guidanceIII\": self.guidanceIII_slider.value,\n\t            \"respacingIII\": self.respacingIII_slider.value,\n\t            \"noiseIII\": self.noiseIII_slider.value,\n\t            \"if_I_kwargs\": self.stageI_custom_params_text.value,\n\t            \"if_II_kwargs\": self.stageII_custom_params_text.value,\n\t            \"if_III_kwargs\": self.stageIII_custom_params_text.value,\n", "            \"pass_prompt_to_stage_III\": self.sIII_pass_prompt_check.value\n\t        }\n\t        return parameters\n\t    def persist_ui_state(self):\n\t        if self.settings.get(\"remember_ui_state\", False):\n\t            key = self.pipeline.__class__.__name__\n\t            parameters = self.get_ui_parameters()\n\t            self.save_ui_state(key, parameters)\n\t    def restore_ui_state(self):\n\t        if self.settings.get(\"remember_ui_state\", False):\n", "            parameters = self.load_ui_state(self.pipeline.__class__.__name__)\n\t            if parameters:\n\t                self.set_ui_parameters(parameters)\n\t    def get_result_pnginfo(self, seed, stage):\n\t        parameters = {\n\t            \"prompt\": self.pipeline.prompt or \"\",\n\t            \"negative_prompt\": self.pipeline.negative_prompt or \"\",\n\t            \"style_prompt\": self.pipeline.style_prompt or \"\",\n\t            \"seed\": seed,\n\t            \"stage\": stage,\n", "            \"batch_size\": 1,\n\t            \"batch_image\": 1,\n\t            \"t5_precision\": self.pipeline.stages.t5_dtype,\n\t            \"stageI_model\": self.pipeline.stages.stageI_model_name,\n\t            \"stageII_model\": self.pipeline.stages.stageII_model_name,\n\t            \"stageIII_model\": self.pipeline.stages.stageIII_model_name,\n\t            \"aspect_ratio\": self.pipeline.aspect_ratio,\n\t            \"guidanceI\": self.pipeline.guidanceI,\n\t            \"respacingI\": self.pipeline.stepsI,\n\t            \"guidanceII\": self.pipeline.guidanceII,\n", "            \"respacingII\": self.pipeline.stepsII,\n\t            \"guidanceIII\": self.pipeline.guidanceIII,\n\t            \"respacingIII\": str(self.pipeline.stepsIII),\n\t            \"noiseIII\": self.pipeline.noiseIII,\n\t            \"if_I_kwargs\": self.pipeline.custom_paramsI,\n\t            \"if_II_kwargs\": self.pipeline.custom_paramsII,\n\t            \"if_III_kwargs\": self.pipeline.custom_paramsIII,\n\t            \"pass_prompt_to_stage_III\": self.sIII_pass_prompt_check.value\n\t        }\n\t        parameters_sd = (self.pipeline.prompt or \"\") + \"\\nNegative prompt: \" + (self.pipeline.negative_prompt or \"\")\n", "        pnginfo = PngInfo()\n\t        pnginfo.add_text(\"deepfloyd_if\", json.dumps(parameters))\n\t        pnginfo.add_text(\"parameters\", parameters_sd)\n\t        return pnginfo\n\t    @catch_handler_errors\n\t    def load_pnginfo(self, e):\n\t        if e[\"name\"] == \"value\":\n\t            file = e[\"new\"][0]\n\t            image = Image.open(BytesIO(file[\"content\"].tobytes()))\n\t            parameters_json = image.text.get(\"deepfloyd_if\", None)\n", "            if parameters_json:\n\t                parameters = json.loads(parameters_json)\n\t                parameters_modelI = parameters.get(\"stageI_model\", None)\n\t                current_modelI = self.settings.get(\"stageI_model\", None)\n\t                if parameters_modelI and current_modelI and parameters_modelI != current_modelI:\n\t                    with self.output:\n\t                        display(Javascript(f\"alert('Warning: the current stage I model {current_modelI} \"\n\t                                            + f\"differs from the stored {parameters_modelI}.')\"))\n\t                self.set_ui_parameters(parameters, self.__class__.__name__ == \"PNGInfoUI\")\n\t    @catch_handler_errors\n", "    def load_support_image(self, e):\n\t        if e[\"name\"] == \"value\":\n\t            file = e[\"new\"][0]\n\t            self.support_img_view.value = file[\"content\"].tobytes()\n\t            self.support_img_view.layout.display = \"inline-block\"\n\t    @catch_handler_errors\n\t    def paste_support_image(self, button):\n\t        image = ImageGrab.grabclipboard()\n\t        self.support_img_view.value = self._image_to_bytes(image)\n\t        self.support_img_view.layout.display = \"inline-block\"\n", "    @catch_handler_errors\n\t    def paste_mask_image(self, button):\n\t        image = ImageGrab.grabclipboard()\n\t        self.mask_img_view.value = self._image_to_bytes(image)\n\t        self.mask_img_view.layout.display = \"inline-block\"\n\t    @catch_handler_errors\n\t    def load_mask_image(self, e):\n\t        if e[\"name\"] == \"value\":\n\t            file = e[\"new\"][0]\n\t            self.mask_img_view.value = file[\"content\"].tobytes()\n", "            self.mask_img_view.layout.display = \"inline-block\"\n\t    def toggle_custom_parameters(self, button):\n\t        if self.custom_parameter_box.layout.display == \"none\":\n\t            self.custom_parameter_box.layout.display = \"block\"\n\t        else:\n\t            self.custom_parameter_box.layout.display = \"none\"\n\t    def format_custom_parameters(self, params):\n\t        result = \"\"\n\t        if params:\n\t            params = [k + \"=\" + (f\"'{v}'\" if isinstance(v, str) else str(v)) for k, v in params.items()]\n", "            result = \", \".join(params)\n\t        return result\n\t    def eval_custom_parameters(self, param_str):\n\t        if param_str:\n\t            def param_func(**kwargs):\n\t                return kwargs\n\t            try:\n\t                return eval(f\"param_func({param_str})\")\n\t            except Exception as e:\n\t                print(f\"Error evaluating custom parameters: {param_str}\")\n", "    def setup_pipeline(self, override_args={}):\n\t        # to save correct PNGInfo from facade-generated images\n\t        def ovr(key1, key2=None):\n\t            if key2:\n\t                v1 = override_args.get(key1, None)\n\t                if v1:\n\t                    return v1.get(key2, None)\n\t            else:\n\t                return override_args.get(key1, None)\n\t        self.pipeline.override_args = override_args\n", "        self.pipeline.aspect_ratio = ovr(\"aspect_ratio\") or self.aspect_ratio_text.value\n\t        self.pipeline.guidanceI = ovr(\"if_I_kwargs\", \"guidance_scale\") or float(self.guidanceI_slider.value)\n\t        self.pipeline.stepsI = ovr(\"if_I_kwargs\", \"sample_timestep_respacing\") or self.respacingI_slider.value\n\t        self.pipeline.guidanceII = ovr(\"if_II_kwargs\", \"guidance_scale\") or float(self.guidanceII_slider.value)\n\t        self.pipeline.stepsII = ovr(\"if_II_kwargs\", \"sample_timestep_respacing\") or self.respacingII_slider.value\n\t        self.pipeline.guidanceIII = ovr(\"if_III_kwargs\", \"guidance_scale\") or float(self.guidanceIII_slider.value)\n\t        self.pipeline.stepsIII = ovr(\"if_III_kwargs\", \"sample_timestep_respacing\") or self.respacingIII_slider.value\n\t        if isinstance(self.pipeline.stepsIII, str):\n\t            self.pipeline.stepsIII = int(self.pipeline.stepsIII)\n\t        self.pipeline.noiseIII = ovr(\"if_III_kwargs\", \"noise_level\") or self.noiseIII_slider.value\n", "        self.pipeline.custom_paramsI = self.eval_custom_parameters(self.stageI_custom_params_text.value)\n\t        self.pipeline.custom_paramsII = self.eval_custom_parameters(self.stageII_custom_params_text.value)\n\t        self.pipeline.custom_paramsIII = self.eval_custom_parameters(self.stageIII_custom_params_text.value)\n\t        self.pipeline.iterationsI = int(re.findall(\"\\d+\", self.pipeline.stepsI)[0])\n\t        self.pipeline.iterationsII = int(re.findall(\"\\d+\", self.pipeline.stepsII)[0])\n\t        self.pipeline.iterationsIII = self.pipeline.stepsIII\n\t        self.pipeline.disable_watermark = self.settings.get(\"disable_watermark\", False)\n\t        self.pipeline.pass_prompt_to_stage_III = self.sIII_pass_prompt_check.value\n\t        if self.support_img_view.layout.display != \"none\":\n\t            image = Image.open(BytesIO(self.support_img_view.value))\n", "            self.pipeline.support_image = image\n\t        if self.mask_img_view.layout.display != \"none\":\n\t            image = Image.open(BytesIO(self.mask_img_view.value))\n\t            self.pipeline.mask_image = image\n\t    def compute_embeddings(self):\n\t        if not self.is_prompt_valid():\n\t            self.status_message(\"Please provide a prompt\")\n\t        prompt = self.prompt_text.value or None\n\t        negative_prompt = self.negative_prompt_text.value or None\n\t        style_prompt = self.style_prompt_text.value or None\n", "        update_prompt = prompt != self.pipeline.prompt\n\t        update_negative = negative_prompt != self.pipeline.negative_prompt\n\t        update_style = style_prompt != self.pipeline.style_prompt\n\t        if update_prompt or update_negative or update_style:\n\t            try:\n\t                self.pipeline.prompt = prompt\n\t                self.pipeline.negative_prompt = negative_prompt\n\t                self.pipeline.style_prompt = style_prompt\n\t                self.pipeline.compute_t5_embs(update_prompt, update_negative, update_style)\n\t                self.output.clear_output()\n", "                self.show_progress_bar()\n\t            except Exception as e:\n\t                self.status_message(str(e))\n\t                self.set_status_error()\n\t    @catch_handler_errors\n\t    def on_generate_click(self, button):\n\t        if self.generation_thread is None:\n\t            with self.output:\n\t                self.persist_ui_state()\n\t                self.reset_results()\n", "                self.setup_pipeline()\n\t                self.compute_embeddings()\n\t                seed = self.seed_number.value\n\t                seed = seed if seed > 0 else None\n\t                if UI_THREADS:\n\t                    self.generation_thread = Thread(target=lambda: self.generate_series(seed=seed, steps=1, single=True))\n\t                    self.generation_thread.start()\n\t                else:\n\t                    self.generate_series(seed=seed, steps=1, single=True)\n\t    @catch_handler_errors\n", "    def on_generate_series_click(self, button):\n\t        with self.output:\n\t            if button.description == self.STOP_BUTTON_LABEL:\n\t                button.description = self.SERIES_BUTTON_LABEL\n\t                self.stop_generation = True\n\t            elif self.generation_thread is None:\n\t                button.description = self.STOP_BUTTON_LABEL\n\t                self.persist_ui_state()\n\t                self.reset_results()\n\t                self.setup_pipeline()\n", "                self.compute_embeddings()\n\t                steps = self.batch_images_slider.value\n\t                if UI_THREADS:\n\t                    self.generation_thread = Thread(target=lambda: self.generate_series(button=button, steps=steps))\n\t                    self.generation_thread.start()\n\t                else:\n\t                    self.generate_series(button=button, steps=steps)\n\t    @catch_handler_errors\n\t    def on_upscale_click(self, button):\n\t        with self.output:\n", "            if button.description == self.STOP_BUTTON_LABEL:\n\t                self.upscale_button.description = self.UPSCALE_BUTTON_LABEL\n\t                self.upscale_button2.description = self.UPSCALE_BUTTON_LABEL\n\t                self.stop_upscale = True\n\t            elif self.generation_thread is None:\n\t                self.upscale_button.description = self.STOP_BUTTON_LABEL\n\t                self.upscale_button2.description = self.STOP_BUTTON_LABEL\n\t                self.persist_ui_state()\n\t                self.show_progress_bar()\n\t                self.reset_upscale_results()\n", "                self.setup_pipeline()\n\t                self.compute_embeddings()\n\t                if UI_THREADS:\n\t                    self.generation_thread = Thread(target=self.generate_upscales)\n\t                    self.generation_thread.start()\n\t                else:\n\t                    self.generate_upscales()\n\t            elif self.generation_thread is not None and button.description != self.WAIT_BUTTON_LABEL:\n\t                self.upscale_button.description = self.WAIT_BUTTON_LABEL\n\t                self.upscale_button2.description = self.WAIT_BUTTON_LABEL\n", "                self.stop_generation = True\n\t                self.generation_finished_event.wait()\n\t                self.on_upscale_click(button)\n\t    def on_before_embeddings(self):\n\t        self.set_status_computing()\n\t        self.status_message(\"Computing T5 Embeddings...\")\n\t    def on_before_generation(self):\n\t        self.set_status_computing()\n\t        self.show_progress_bar()\n\t    @catch_handler_errors\n", "    def generate_series(self, button=None, seed=None, steps=None, single=False):\n\t        error = False\n\t        try:\n\t            self.upscaling = False\n\t            generate_seed = seed is None\n\t            self.generation_finished_event = threading.Event()\n\t            self.stop_generation = False\n\t            for i in range(0, steps):\n\t                if self.stop_generation:\n\t                    break\n", "                if generate_seed:\n\t                    seed = self.pipeline.generate_seed()\n\t                result = self.pipeline.generate(seed, progress=self.update_progress)\n\t                self.process_stageI_result(result)\n\t            if not self.upscaling:  # Super Resolution\n\t                self.status_message(f\"Stage I: ~{self.stageI_time}s\")\n\t        except ModelError as e:\n\t            error = True\n\t            self.status_message(str(e))\n\t        except MemoryError as e:\n", "            error = True\n\t            self.status_message(\"Memory error. Please restart the kernel.\")\n\t        finally:\n\t            self.reset_progress()\n\t            if error:\n\t                self.set_status_error()\n\t            else:\n\t                self.set_status_result()\n\t            if not single:\n\t                button.description = self.SERIES_BUTTON_LABEL\n", "            self.generation_thread = None\n\t            self.generation_finished_event.set()\n\t    def update_progress(self, n, p):\n\t        try:\n\t            self.stop_stageIII_progress()\n\t            if len(self.status_box.children) and self.status_box.children[0] is not self.progress_bar:\n\t                self.show_progress_bar()\n\t            self.progress_bar.max = n - 1\n\t            self.progress_bar.value = n - 1 - p\n\t        except:\n", "            pass\n\t    def reset_progress(self):\n\t        self.progress_bar.value = 0\n\t    def reset_results(self):\n\t        random.seed(datetime.now().timestamp())\n\t        self.resultsI = {}\n\t        self.upscale_resultsII = {}\n\t        self.upscaleII = []\n\t        self.upscaleIII = []\n\t        self.clear_results(None)\n", "        self.clear_upscales(None)\n\t        self.reset_progress()\n\t        self.output.clear_output()\n\t    def reset_upscale_results(self):\n\t        self.stageII_time = 0\n\t        self.stageIII_time = 0\n\t        self.upscale_resultsII = {}\n\t        self.upscale_box.children = []\n\t        self.upscale_result_boxes = {}\n\t        self.output.clear_output()\n", "    @catch_handler_errors\n\t    def process_stageI_result(self, result):\n\t        seed = result.seed\n\t        image_result = result.images['I'][0]\n\t        size = tuple([int(x * self.STAGE_I_SCALE) for x in image_result.size])\n\t        self.resultsI[seed] = result\n\t        self.stageI_time = round(result.duration)\n\t        self.save_result(image_result, result.time, result.seed, \"I\")\n\t        if DEBUG:\n\t            image = image_result.resize(size, Image.Resampling.LANCZOS)\n", "            image_view = widgets.Image(value=self._image_to_bytes(image), format='png')\n\t            nsfw = self._get_nsfw_status(result, 0)\n\t        else:\n\t            file_name = self._get_file_name(result.time, seed, \"I\")\n\t            image_view = widgets.HTML(f\"<img src='/files/{file_name}' style='width: {size[0]}px; height: {size[1]}px'/>\",\n\t                                      layout=Layout(width=str(size[0]) + \"px\", height=str(size[1]) + \"px\"))\n\t            nsfw = \"\"\n\t        seed_text = widgets.Label(f\"Seed: {seed}{nsfw}\")\n\t        spacer = HBox([], layout=Layout(flex=\"1 0 auto\"))\n\t        recycle_button = widgets.Button(\n", "            description=\"♻️\",\n\t            tooltip=\"Reuse image seed\",\n\t            layout=Layout(width=\"30px\"),\n\t            style={\"button_color\": \"#212121\"}\n\t        )\n\t        recycle_button.on_click(lambda b: self.set_seed_value(seed))\n\t        placeholder = widgets.Label(\" \")\n\t        top_box = widgets.HBox([seed_text, spacer, recycle_button, placeholder])\n\t        upscale_text = widgets.Label(f\"🔬\", layout=Layout(width=\"20px\", flex=\"1 0 20px\"))\n\t        upscaleII_check = widgets.Checkbox(\n", "            value=False,\n\t            description='II',\n\t            indent=False,\n\t            layout=Layout(max_width=\"38px\")\n\t        )\n\t        upscaleII_check.observe(lambda e: self.add_upscaleII(e, seed), 'value', type='change')\n\t        upscaleIII_check = widgets.Checkbox(\n\t            value=False,\n\t            description='III',\n\t            indent=False\n", "        )\n\t        spacer = HBox([], layout=Layout(flex=\"1 0 auto\"))\n\t        upscaleIII_check.observe(lambda e: self.add_upscaleIII(e, seed), 'value', type='change')\n\t        upscale_sr_button = widgets.Button(\n\t            description=\"SR\",\n\t            tooltip=\"Send to Super Resolution\",\n\t            style={\"button_color\": \"#212121\"}\n\t        )\n\t        def on_send_to_sr_click(button):\n\t            image_bytes = image_result\n", "            parameters = self.get_ui_parameters()\n\t            self.send_to_sr(image_bytes, parameters)\n\t        upscale_sr_button.on_click(on_send_to_sr_click)\n\t        upscale_box = HBox([upscale_text, upscaleII_check, upscaleIII_check, spacer, upscale_sr_button],\n\t                           layout=Layout(max_width=f\"calc({size[0]}px + 10px)\"))\n\t        result_box = VBox([top_box, image_view], layout=Layout(max_width=f\"calc({size[0]}px + 10px)\"))\n\t        if not hasattr(result, \"facade\"):\n\t            result_box.children += (upscale_box,)\n\t        self.result_box.layout.display = \"flex\"\n\t        self.result_button_box.layout.display = \"flex\"\n", "        self.stageI_results_label.layout.display = \"block\"\n\t        self.result_box.children += (result_box,)\n\t    def add_upscaleII(self, e, seed):\n\t        if e[\"name\"] == \"value\" and e[\"new\"]:\n\t            self.upscaleII.append(seed)\n\t        elif e[\"name\"] == \"value\" and not e[\"new\"]:\n\t            self.upscaleII.remove(seed)\n\t    def add_upscaleIII(self, e, seed):\n\t        if e[\"name\"] == \"value\" and e[\"new\"]:\n\t            self.upscaleIII.append(seed)\n", "        elif e[\"name\"] == \"value\" and not e[\"new\"]:\n\t            self.upscaleIII.remove(seed)\n\t    def on_before_upscale(self):\n\t        self.set_status_computing()\n\t        self.show_progress_bar()\n\t        if self.upscaling and self.upscaling_stage == \"III\":\n\t            self.stop_stageIII_progress()\n\t            self.upscaling_progress_event = threading.Event()\n\t            self.upscaling_progress_thread = Thread(target=self.stageIII_mock_progress)\n\t            self.upscaling_progress_thread.start()\n", "    def on_before_checkpoints_loaded(self, missing):\n\t        if missing:\n\t            self.status_message(DOWNLOADING_CHECKPOINTS)\n\t        else:\n\t            self.status_message(LOADING_CHECKPOINTS)\n\t        self.set_status_waiting()\n\t    def on_checkpoints_loaded(self):\n\t        pass\n\t    @catch_handler_errors\n\t    def generate_upscales(self):\n", "        error = False\n\t        try:\n\t            self.generation_finished_event = threading.Event()\n\t            self.upscaling = True\n\t            generations = {}\n\t            upscales = {}\n\t            for seed in self.resultsI.keys():\n\t                if seed in self.upscaleIII:\n\t                    generations[seed] = \"III\"\n\t                elif seed in self.upscaleII:\n", "                    generations[seed] = \"II\"\n\t                else:\n\t                    generations[seed] = None\n\t            for (seed, stage) in generations.items():\n\t                if stage:\n\t                    upscales[seed] = stage\n\t            total_images = len(self.upscaleIII) * 2 + len(set(self.upscaleII) - set(self.upscaleIII))\n\t            i = 0\n\t            self.stop_upscale = False\n\t            for (seed, stage) in upscales.items():\n", "                if self.stop_upscale:\n\t                    break\n\t                if self.pipeline.stages.sequential_load == SEQ_LOAD_SEPARATE:\n\t                    self.generate_upscale(seed, \"II\", stage, (i := i + 1), total_images)\n\t                else:\n\t                    if stage == \"II\":\n\t                        self.generate_upscale(seed, \"II\", stage, (i := i + 1), total_images)\n\t                    elif stage == \"III\":\n\t                        self.generate_upscale(seed, \"II\", stage, (i := i + 1), total_images)\n\t                        self.generate_upscale(seed, \"III\", stage, (i := i + 1), total_images)\n", "            if not self.stop_upscale and self.pipeline.stages.sequential_load == SEQ_LOAD_SEPARATE:\n\t                for (i, seed) in enumerate(self.upscaleIII):\n\t                    if self.stop_upscale:\n\t                        break\n\t                    self.generate_upscale(seed, \"III\", \"III\", (i := i + 1), total_images)\n\t            sII_time = f\"Stage II: ~{self.stageII_time}s\"\n\t            sIII_time = f\"Stage III: ~{self.stageIII_time}s\"\n\t            result_time = sII_time if self.stageIII_time == 0 else sII_time + \", \" + sIII_time\n\t            self.status_message(result_time)\n\t        except ModelError as e:\n", "            error = True\n\t            self.status_message(str(e))\n\t        except MemoryError as e:\n\t            error = True\n\t            self.status_message(\"Memory error, please restart.\")\n\t        finally:\n\t            self.reset_progress()\n\t            if error:\n\t                self.set_status_error()\n\t            else:\n", "                self.set_status_result()\n\t            self.generation_thread = None\n\t            self.generation_finished_event.set()\n\t            self.upscale_button.description = self.UPSCALE_BUTTON_LABEL\n\t            self.upscale_button2.description = self.UPSCALE_BUTTON_LABEL\n\t    def generate_upscale(self, seed, stage, stage_max, image_index=None, total_images=None):\n\t        self.upscaling_stage = stage\n\t        self.upscaling_stage_max = stage_max\n\t        if stage == \"II\":\n\t            self.stop_stageIII_progress()\n", "            resultI = self.resultsI[seed]\n\t            result = self.pipeline.upscale(resultI=resultI, progress=self.update_progress)\n\t            self.stageII_time = round(result.duration)\n\t            self.upscale_resultsII[seed] = result\n\t            self.process_upscale_result(seed, result, \"II\", stage_max, image_index, total_images)\n\t        elif stage == \"III\":\n\t            resultI = self.resultsI[seed]\n\t            resultII = self.upscale_resultsII[seed]\n\t            result = self.pipeline.upscale(resultI=resultI, resultII=resultII, progress=self.update_progress)\n\t            self.stageIII_time = round(result.duration)\n", "            self.stageIII_iter_time = result.duration / self.pipeline.iterationsIII\n\t            self.process_upscale_result(seed, result, \"III\", stage_max, image_index, total_images)\n\t    def process_upscale_result(self, seed, result, stage, stage_max=None, image_index=None, total_images=None):\n\t        image = result.images[stage][0]\n\t        self.save_result(image, result.time, seed, stage)\n\t        stage_index = 1 if stage == \"II\" else 2\n\t        nsfw = self._get_nsfw_status(result, stage_index) if DEBUG else \"\"\n\t        seed_text = widgets.Label(f\"Seed: {result.seed} ({stage}){nsfw}\")\n\t        spacer = HBox([], layout=Layout(flex=\"1 0 auto\"))\n\t        image_index = f\"{image_index}/{total_images}\" if image_index is not None and total_images is not None else \"\"\n", "        image_index_label = widgets.Label(image_index)\n\t        image_header = HBox([seed_text, spacer, image_index_label])\n\t        if DEBUG:\n\t            image_view = widgets.Image(\n\t                value=self._image_to_bytes(image),\n\t                format='png',\n\t                layout=Layout(width=\"max-content\")\n\t            )\n\t        else:\n\t            file_name = self._get_file_name(result.time, seed, stage)\n", "            image_view = widgets.HTML(f\"<img src='/files/{file_name}' style='width: max-content'/>\")\n\t        spacer = HBox([], layout=Layout(flex=\"1 0 auto\"))\n\t        generateIII_button = widgets.Button(\n\t            description=\"III\",\n\t            tooltip=\"Generate stage III\",\n\t            layout=Layout(width=\"30px\"),\n\t            style={\"button_color\": \"#212121\"}\n\t        )\n\t        def generate_stageIII(button):\n\t            if self.generation_thread is None:\n", "                try:\n\t                    generateIII_button.description = \"⏳\"\n\t                    self.generation_thread = True\n\t                    self.generate_upscale(seed, \"III\", \"III\")\n\t                    generateIII_button.layout.display = \"none\"\n\t                    self.status_message(f\"Stage III: ~{self.stageIII_time}s\")\n\t                finally:\n\t                    self.generation_thread = None\n\t        generateIII_button.on_click(generate_stageIII)\n\t        result_footer = HBox([spacer, generateIII_button])\n", "        result_box = VBox([image_header, image_view], layout=Layout(max_width=\"max-content\"))\n\t        if stage_max == \"II\" and not hasattr(result, \"facade\"):\n\t            result_box.children += (result_footer,)\n\t        hr = widgets.HTML(\"<hr class='iflab-upscale-separator'>\")\n\t        upscale_result_box = self.upscale_result_boxes.get(seed, None)\n\t        if upscale_result_box:\n\t            upscale_result_box.children += (result_box,)\n\t        else:\n\t            upscale_result_box = VBox([])\n\t            upscale_result_box.children += (result_box,) if image_index == 1 else (hr, result_box,)\n", "            self.upscale_result_boxes[seed] = upscale_result_box\n\t            self.upscale_box.children += (upscale_result_box,)\n\t        self.upscale_box.layout.display = \"flex\"\n\t        self.upscale_button_box.layout.display = \"flex\"\n\t        self.upscale_results_label.layout.display = \"block\"\n\t    # deeper patching is required to hook into the stage III progress, so here is a mock now\n\t    def stageIII_mock_progress(self):\n\t        self.progress_bar.max = self.pipeline.iterationsIII - 1\n\t        wait_time = 1 if self.stageIII_iter_time == 0 else self.stageIII_iter_time\n\t        for i in range(0, self.pipeline.iterationsIII):\n", "            self.progress_bar.value = i\n\t            if self.upscaling_progress_event and self.upscaling_progress_event.wait(wait_time):\n\t                self.upscaling_progress_event = None\n\t                break\n\t    def stop_stageIII_progress(self):\n\t        if self.upscaling_progress_event:\n\t            try:\n\t                self.upscaling_progress_event.set()\n\t            except:\n\t                traceback.print_exc()\n", "    def clear_results(self, button):\n\t        self.resultsI = {}\n\t        self.result_box.children = []\n\t        self.result_box.layout.display = \"none\"\n\t        self.result_button_box.layout.display = \"none\"\n\t        self.stageI_results_label.layout.display = \"none\"\n\t    def clear_upscales(self, button):\n\t        self.upscale_box.children = []\n\t        self.upscale_box.layout.display = \"none\"\n\t        self.upscale_button_box.layout.display = \"none\"\n", "        self.upscale_results_label.layout.display = \"none\"\n\t    def save_result(self, image, time, seed, stage):\n\t        file_name = self._get_file_name(time, seed, stage)\n\t        file_dir = os.path.dirname(file_name)\n\t        p = Path(file_dir)\n\t        p.mkdir(parents=True, exist_ok=True)\n\t        with open(file_name, \"wb\") as f:\n\t            image.save(f, format='png', pnginfo=self.get_result_pnginfo(seed, stage))\n\t    def get(self):\n\t        return self.root_box\n", "    def settings_changed(self, new_settings):\n\t        self.settings = new_settings\n\t    class GeneratorFacade:\n\t        def __init__(self, ui, options):\n\t            self.ui = ui\n\t            self.options = options\n\t        def __call__(self, *args, **kwargs):\n\t            return self.ui.invoke_pipeline(kwargs, self.options)\n\t    def get_pipeline(self, **kwargs):\n\t        return PipelineUI.GeneratorFacade(self, kwargs)\n", "    def invoke_pipeline(self, kwargs, options):\n\t        update_ui = options.get(\"update_ui\", False)\n\t        reference_pipeline = options.get(\"reference\", False)\n\t        return_tensors = kwargs.get(\"return_tensors\", False)\n\t        seed = self.seed_number.value\n\t        seed = seed if seed > 0 else None\n\t        self.setup_pipeline(override_args=kwargs)\n\t        self.compute_embeddings()\n\t        result = self.pipeline.generate(seed=seed, progress=True, is_reference=reference_pipeline)\n\t        self.resultsI[seed] = result\n", "        if update_ui:\n\t            setattr(result, \"facade\", True)\n\t            self.process_stageI_result(result)\n\t        upscale = \"if_II_kwargs\" in kwargs or \"if_III_kwargs\" in kwargs\n\t        stage = \"III\" if \"if_III_kwargs\" in kwargs else \"II\"\n\t        if upscale:\n\t            if stage == \"II\":\n\t                result = self.pipeline.upscale(resultI=result, progress=True, is_reference=reference_pipeline)\n\t                setattr(result, \"facade\", True)\n\t                self.upscale_resultsII[seed] = result\n", "                if update_ui:\n\t                    self.process_upscale_result(seed, result, \"II\", \"II\")\n\t            elif stage == \"III\":\n\t                resultII = self.pipeline.upscale(resultI=result, progress=True, is_reference=reference_pipeline)\n\t                self.upscale_resultsII[seed] = result\n\t                if update_ui:\n\t                    setattr(resultII, \"facade\", True)\n\t                    self.process_upscale_result(seed, resultII, \"II\", \"III\")\n\t                result = self.pipeline.upscale(resultI=result, resultII=resultII, progress=True,\n\t                                               is_reference=reference_pipeline)\n", "                setattr(result, \"facade\", True)\n\t                if update_ui:\n\t                    self.process_upscale_result(seed, result, \"III\", \"III\")\n\t        if \"output\" in result.images:\n\t            del result.images[\"output\"]\n\t        return (result.images, result.tensors) if return_tensors else result.images\n\t    @abstractmethod\n\t    def _tune_ui(self):\n\t        pass\n\t    @abstractmethod\n", "    def get_title(self):\n\t        pass\n"]}
{"filename": "modules/iflab/ui/__init__.py", "chunked_list": []}
{"filename": "modules/iflab/ui/open.py", "chunked_list": ["import socket\n\timport subprocess\n\timport time\n\timport os\n\timport sys\n\timport traceback\n\tfrom contextlib import closing\n\tfrom threading import Thread\n\tdef port_online(port):\n\t    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:\n", "        sock.settimeout(0.1)\n\t        result = sock.connect_ex((\"127.0.0.1\", int(port)))\n\t        if result == 0:\n\t            return True\n\t        else:\n\t            return False\n\tdef wait_for_port(port):\n\t    ctr = 6000\n\t    while ctr > 0:\n\t        if port_online(port):\n", "            return True\n\t        ctr -= 1\n\t        time.sleep(1)\n\t    return False\n\tdef open_ui_thread(port):\n\t    if wait_for_port(port):\n\t        time.sleep(3)\n\t        url = f\"http://localhost:{port}\"\n\t        if sys.platform == \"win32\":\n\t            os.startfile(url)\n", "        elif sys.platform == \"darwin\":\n\t            subprocess.Popen([\"open\", url])\n\t        else:\n\t            try:\n\t                env_mod = os.environ.copy()\n\t                ture_userprofile = os.getenv(\"IFLAB_TRUE_USERPROFILE\", None)\n\t                ture_home = os.getenv(\"IFLAB_TRUE_HOME\", None)\n\t                if ture_userprofile:\n\t                    env_mod[\"USERPROFILE\"] = ture_userprofile\n\t                if ture_home:\n", "                    env_mod[\"HOME\"] = ture_home\n\t                subprocess.Popen([\"xdg-open\", url], env=env_mod)\n\t            except OSError:\n\t                print(\"Please open a browser on: \" + url)\n\tdef open_ui(port):\n\t    Thread(target=lambda: open_ui_thread(port), daemon=True).start()\n"]}
{"filename": "modules/iflab/ui/style_transfer.py", "chunked_list": ["from .pipeline import PipelineUI\n\tclass Img2ImgUI(PipelineUI):\n\t    def __init__(self, pipeline):\n\t        super().__init__(pipeline)\n\t        self.IMAGE_FOLDER = \"style_transfer\"\n\t    def _tune_ui(self):\n\t        self.info_button.tooltip = \"Upload source image and provide a style prompt to produce image of a different style\"\n\t    def on_display_info(self, button):\n\t        pass\n\t    def get_title(self):\n", "        return \"Style Transfer\"\n\t    def generate_series(self, **kwargs):\n\t        with self.output:\n\t            if self.pipeline.style_prompt:\n\t                super().generate_series(**kwargs)\n\t            else:\n\t                print(\"Please provide a style prompt\")\n"]}
{"filename": "modules/iflab/ui/inpainting.py", "chunked_list": ["from .pipeline import PipelineUI\n\tclass InpaintingUI(PipelineUI):\n\t    def __init__(self, pipeline):\n\t        super().__init__(pipeline)\n\t        self.IMAGE_FOLDER = \"inpainting\"\n\t    def _tune_ui(self):\n\t        self.upload_mask_img_button.layout.display = \"block\"\n\t        self.paste_mask_img_button.layout.display = \"block\"\n\t        self.info_button.tooltip = (\"Inpaint on a region of the source image defined by the mask image\\n\" +\n\t                                    \"Source and mask images should be of the same size\")\n", "    def on_display_info(self, button):\n\t        pass\n\t    def get_title(self):\n\t        return \"Inpainting\""]}
{"filename": "modules/iflab/ui/super_resolution.py", "chunked_list": ["import ipywidgets as widgets\n\tfrom .pipeline import PipelineUI, catch_handler_errors\n\tclass SuperResolutionUI(PipelineUI):\n\t    def __init__(self, pipeline):\n\t        super().__init__(pipeline)\n\t        self.IMAGE_FOLDER = \"super_resolution\"\n\t    def _tune_ui(self):\n\t        self.SERIES_BUTTON_LABEL = \"Batch Stage III\"\n\t        self.result_box.layout.display = \"none\"\n\t        self.upscale_button.layout.display = \"none\"\n", "        self.clear_results_button.layout.display = \"none\"\n\t        self.generate_button.description = \"Stage III\"\n\t        self.generate_series_button.description = self.SERIES_BUTTON_LABEL\n\t        self.info_button.tooltip = \"Upload source image and provide a prompt to generate an upscaled version\"\n\t    def on_display_info(self, button):\n\t        pass\n\t    def get_title(self):\n\t        return \"Super Resolution\"\n\t    def on_before_generation(self):\n\t        self.upscaling = True\n", "        self.upscaling_stage = \"III\"\n\t        super().on_before_generation()\n\t    def process_stageI_result(self, result):\n\t        if self.upscaling_progress_event:\n\t            self.upscaling_progress_event.set()\n\t        self.process_upscale_result(result.seed, result, \"III\")\n\t        duration = round(result.duration)\n\t        self.status_message(f\"Stages II-III: {duration}s\")\n\t    def set_support_image(self, image, parameters):\n\t        self.support_img_view.value = self._image_to_bytes(image)\n", "        self.support_img_view.layout.display = \"inline-block\"\n\t        self.prompt_text.value = parameters.get(\"prompt\", \"\")\n\t        self.negative_prompt_text.value = parameters.get(\"negative_prompt\", \"\")\n\t        self.style_prompt_text.value = parameters.get(\"style_prompt\", \"\")\n"]}
