{"filename": "scripts/docker.py", "chunked_list": ["from scripts import CommandProcessor\n\tdef main():\n\t    commands = {\n\t        \"removing old packages\": \"rm -rf dist\",\n\t        \"building the project\": \"poetry build\",\n\t        \"creating docker image\": \"docker build -t sauljabin/kayak:latest -f docker/Dockerfile .\",\n\t    }\n\t    command_processor = CommandProcessor(commands)\n\t    command_processor.run()\n\tif __name__ == \"__main__\":\n", "    main()\n"]}
{"filename": "scripts/banner.py", "chunked_list": ["from rich import box\n\tfrom rich.console import Console\n\tfrom rich.panel import Panel\n\tfrom kayak.renderables.kayak_name import KayakName\n\tfrom kayak.styles.colors import PRIMARY\n\tdef main():\n\t    console = Console()\n\t    panel = Panel.fit(KayakName(False), box=box.ROUNDED, border_style=PRIMARY)\n\t    console.print(panel)\n\tif __name__ == \"__main__\":\n", "    main()\n"]}
{"filename": "scripts/tests.py", "chunked_list": ["from scripts import CommandProcessor\n\tdef main():\n\t    commands = {\n\t        \"executing tests\": \"poetry run python -m unittest -v\",\n\t    }\n\t    command_processor = CommandProcessor(commands)\n\t    command_processor.run()\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "scripts/__init__.py", "chunked_list": ["import shlex\n\timport subprocess\n\timport sys\n\tfrom rich.console import Console\n\tclass CommandProcessor:\n\t    def __init__(self, commands, rollback={}):\n\t        self.commands = commands\n\t        self.rollback = rollback\n\t        self.console = Console()\n\t    def run(self):\n", "        for name, command in self.commands.items():\n\t            result = self.execute_command(name, command)\n\t            if result.returncode:\n\t                self.console.print(\n\t                    \"\\n[bold red]Error[/] when executing \"\n\t                    f'[bold blue]\"{name}\" ([bold yellow]{command}[/])[/]:exclamation::\\n'\n\t                    f\"[red]{result.stdout.decode().strip()}{result.stderr.decode().strip()}[/]\\n\"\n\t                )\n\t                if self.rollback:\n\t                    self.console.print(\"[bold yellow]Rolling back:[/]\")\n", "                    for rollback_name, rollback_command in self.rollback.items():\n\t                        self.execute_command(rollback_name, rollback_command)\n\t                sys.exit(result.returncode)\n\t    def execute_command(self, name, command):\n\t        self.console.print()\n\t        self.console.print(f\"[bold blue]{name.lower()}:\")\n\t        self.console.print(f\"[bold yellow]{command}[/]\")\n\t        return subprocess.run(shlex.split(command), capture_output=True)\n\tif __name__ == \"__main__\":\n\t    test_commands = {\n", "        \"list files\": \"ls .\",\n\t        \"testing echo\": \"echo 'hello world'\",\n\t        \"no command\": \"false\",\n\t    }\n\t    test_rollback = {\"echo rollback\": \"echo 'error'\"}\n\t    command_processor = CommandProcessor(test_commands, test_rollback)\n\t    command_processor.run()\n"]}
{"filename": "scripts/bump.py", "chunked_list": ["import click\n\timport toml\n\tfrom rich.console import Console\n\tfrom scripts import CommandProcessor\n\t@click.command()\n\t@click.argument(\n\t    \"rule\",\n\t    nargs=1,\n\t    type=click.Choice([\"major\", \"minor\", \"patch\"], case_sensitive=False),\n\t)\n", "def main(rule):\n\t    \"\"\"\n\t    \\b\n\t    Examples:\n\t        poetry run python -m scripts.bump major\n\t        poetry run python -m scripts.bump minor\n\t        poetry run python -m scripts.bump patch\n\t    More info at https://python-poetry.org/docs/cli/#version and https://semver.org/.\n\t    \"\"\"\n\t    bump_version(rule)\n", "    new_app_version = get_app_version()\n\t    changelog_release(new_app_version)\n\t    console = Console()\n\t    confirmation = console.input(\n\t        f\"\\n[bold]Release a new [purple]{rule}[/] version [purple]{new_app_version}[/]\"\n\t        \" ([green]yes[/]/[red]no[/])? [/]\"\n\t    )\n\t    if confirmation != \"yes\":\n\t        revert_changes()\n\t        exit(1)\n", "    confirm_changes(new_app_version)\n\tdef changelog_release(version):\n\t    init_commands = {\n\t        f\"bumping changelog to a [purple bold]{version}[/] version\": (\n\t            f\"poetry run changeloggh release {version}\"\n\t        ),\n\t    }\n\t    revert_commands = {\n\t        \"deleting changes\": \"git checkout .\",\n\t    }\n", "    command_processor = CommandProcessor(init_commands, revert_commands)\n\t    command_processor.run()\n\tdef bump_version(rule):\n\t    init_commands = {\n\t        \"checking pending changes\": \"git diff --exit-code\",\n\t        \"checking pending changes in stage\": \"git diff --staged --exit-code\",\n\t        \"checking not pushed commits\": \"git diff --exit-code main origin/main\",\n\t        f\"bumping to a [purple bold]{rule}[/] version\": f\"poetry version {rule}\",\n\t    }\n\t    command_processor = CommandProcessor(init_commands)\n", "    command_processor.run()\n\tdef confirm_changes(app_version):\n\t    confirm_commands = {\n\t        \"adding new version\": \"git add --all\",\n\t        \"committing new version\": f\"git commit -m 'bumping version to {app_version}'\",\n\t        \"adding new version tag\": f\"git tag v{app_version}\",\n\t        \"pushing new changes\": \"git push origin main\",\n\t        \"pushing tag\": \"git push --tags\",\n\t    }\n\t    command_processor = CommandProcessor(confirm_commands)\n", "    command_processor.run()\n\tdef revert_changes():\n\t    revert_commands = {\n\t        \"deleting changes\": \"git checkout .\",\n\t    }\n\t    command_processor = CommandProcessor(revert_commands)\n\t    command_processor.run()\n\tdef get_app_version():\n\t    toml_data = toml.load(\"pyproject.toml\")\n\t    app_version = toml_data[\"tool\"][\"poetry\"][\"version\"]\n", "    return app_version\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "scripts/styles.py", "chunked_list": ["from scripts import CommandProcessor\n\tdef main():\n\t    commands = {\n\t        \"black\": \"poetry run black . --preview\",\n\t        \"ruff\": \"poetry run ruff . --fix\",\n\t    }\n\t    command_processor = CommandProcessor(commands)\n\t    command_processor.run()\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "scripts/analyze.py", "chunked_list": ["from scripts import CommandProcessor\n\tdef main():\n\t    commands = {\n\t        \"checking types\": \"poetry run mypy kayak/\",\n\t        \"black\": \"poetry run black --check .\",\n\t        \"ruff\": \"poetry run ruff check .\",\n\t    }\n\t    command_processor = CommandProcessor(commands)\n\t    command_processor.run()\n\tif __name__ == \"__main__\":\n", "    main()\n"]}
{"filename": "tests/test_app.py", "chunked_list": ["from logging import DEBUG\n\tfrom unittest import TestCase\n\tfrom unittest.mock import patch\n\tfrom click.testing import CliRunner\n\tfrom kayak import VERSION\n\tfrom kayak.app import main\n\tclass TestApp(TestCase):\n\t    def test_print_version(self):\n\t        runner = CliRunner()\n\t        result = runner.invoke(main, [\"--version\"])\n", "        self.assertEqual(result.exit_code, 0)\n\t        self.assertIn(VERSION, result.output)\n\t    @patch(\"kayak.app.logger\")\n\t    def test_debug_version(self, mock_logger):\n\t        runner = CliRunner()\n\t        runner.invoke(main, [\"--debug\"])\n\t        mock_logger.setLevel.assert_called_once_with(DEBUG)\n\t        mock_logger.debug.assert_called_once_with(\"Starting in debug mode\")\n\t    def test_missing_server(self):\n\t        runner = CliRunner()\n", "        result = runner.invoke(main)\n\t        self.assertEqual(result.exit_code, 1)\n\t        self.assertIn(\"Missing argument 'SERVER'\", result.output)\n\t    def test_missing_pass(self):\n\t        runner = CliRunner()\n\t        result = runner.invoke(main, [\"--user\", \"user\"])\n\t        self.assertEqual(result.exit_code, 1)\n\t        self.assertIn(\"Please provide an --user and --password\", result.output)\n\t    def test_missing_user(self):\n\t        runner = CliRunner()\n", "        result = runner.invoke(main, [\"--password\", \"password\"])\n\t        self.assertEqual(result.exit_code, 1)\n\t        self.assertIn(\"Please provide an --user and --password\", result.output)\n\t    @patch(\"kayak.app.Tui\")\n\t    def test_run_tui(self, mock_class_tui):\n\t        runner = CliRunner()\n\t        runner.invoke(main, [\"--user\", \"user\", \"--password\", \"password\", \"server\"])\n\t        mock_class_tui.assert_called_once_with(\"server\", \"user\", \"password\")\n\t        mock_class_tui.return_value.run.assert_called_once_with()\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "kayak/app.py", "chunked_list": ["import os\n\tfrom logging import DEBUG\n\timport click\n\tfrom rich.console import Console\n\tfrom kayak import logger\n\tfrom kayak.renderables.kayak_name import KayakName\n\tfrom kayak.tui import Tui\n\t@click.command()\n\t@click.option(\"--version\", is_flag=True, help=\"Show the app version and exit.\")\n\t@click.option(\n", "    \"--debug\",\n\t    is_flag=True,\n\t    help=\"Enable debug mode, it writes a log file in ~/.kayak/kayak.log.\",\n\t)\n\t@click.option(\n\t    \"--password\",\n\t    prompt=True,\n\t    hide_input=True,\n\t    prompt_required=False,\n\t    default=lambda: os.environ.get(\"KSQLDB_PASSWORD\", None),\n", "    help=(\n\t        \"If your KSQL server is configured for authentication, then provide your password here. The\"\n\t        \" username must be specified separately with the --user option. Use KSQLDB_PASSWORD env\"\n\t        \" variable to set a default value.\"\n\t    ),\n\t)\n\t@click.option(\n\t    \"--user\",\n\t    default=lambda: os.environ.get(\"KSQLDB_USER\", None),\n\t    help=(\n", "        \"If your KSQL server is configured for authentication, then provide your user name here.\"\n\t        \" The password must be specified separately with the --password option. Use KSQLDB_USER env\"\n\t        \" variable to set a default value.\"\n\t    ),\n\t)\n\t@click.argument(\"server\", nargs=1, required=False, default=None)\n\tdef main(\n\t    version: bool,\n\t    debug: bool,\n\t    password: str | None,\n", "    user: str | None,\n\t    server: str | None,\n\t) -> None:\n\t    \"\"\"\n\t    kayak is a ksqlDB TUI (text user interface).\n\t    \\b\n\t    SERVER  The address of the Ksql server to connect to\n\t            (ex: http://localhost:8088).\n\t            This option may occur a maximum of 1 times.\n\t    \"\"\"\n", "    if debug:\n\t        logger.setLevel(DEBUG)\n\t        logger.debug(\"Starting in debug mode\")\n\t    console = Console()\n\t    if version:\n\t        console.print(KayakName())\n\t        exit(0)\n\t    if [user, password].count(None) == 1:\n\t        console.print(\"[bold red]Please provide an --user and --password[/]\")\n\t        exit(1)\n", "    if server is None:\n\t        console.print(\"[bold red]Missing argument 'SERVER'[/]\")\n\t        exit(1)\n\t    tui = Tui(server, user, password)\n\t    tui.run()\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "kayak/__init__.py", "chunked_list": ["import logging\n\tfrom importlib.metadata import version\n\tfrom pathlib import Path\n\tNAME = \"kayak\"\n\t__version__ = VERSION = version(NAME)\n\tdef get_home() -> Path:\n\t    user_home = Path.home()\n\t    app_home = user_home.joinpath(\".\" + NAME)\n\t    if not app_home.exists():\n\t        app_home.mkdir()\n", "    return app_home\n\tLOG = get_home().joinpath(NAME + \".log\")\n\tlogger_handler = logging.FileHandler(LOG)\n\tlogger_handler.setFormatter(logging.Formatter(\"%(asctime)-15s %(levelname)-8s %(message)s\"))\n\tlogger = logging.getLogger()\n\tlogger.addHandler(logger_handler)\n\tlogger.setLevel(logging.INFO)\n"]}
{"filename": "kayak/tui.py", "chunked_list": ["import asyncio\n\timport json\n\tfrom enum import Enum\n\tfrom typing import Any, Final, List, Literal, Type\n\tfrom rich.columns import Columns\n\tfrom rich.console import RenderableType\n\tfrom rich.json import JSON\n\tfrom rich.text import Text\n\tfrom textual.app import App, ComposeResult, CSSPathType\n\tfrom textual.binding import Binding\n", "from textual.containers import Container, Horizontal\n\tfrom textual.driver import Driver\n\tfrom textual.keys import Keys\n\tfrom textual.reactive import reactive\n\tfrom textual.widgets import DataTable, Footer, Input, Label, Static, Switch, Tree\n\tfrom textual.widgets._tree import EventTreeDataType, TreeNode\n\tfrom kayak import logger\n\tfrom kayak.ksql.ksql_service import KsqlService\n\tfrom kayak.ksql.models import Server\n\tfrom kayak.renderables.kayak_name import KayakName\n", "from kayak.renderables.server_info import ServerInfo\n\tfrom kayak.styles.colors import DESIGN, ERROR, GREEN\n\tRIGHT: Final = \"right\"\n\tLEFT: Final = \"left\"\n\tclass Statuses(Enum):\n\t    RUNNING = f\"bold {GREEN}\"\n\t    IDLE = \"bold\"\n\t    ERROR = f\"bold {ERROR}\"\n\tclass Status(Container):\n\t    status = reactive(Statuses.IDLE)\n", "    def render(self) -> RenderableType:\n\t        return Text.from_markup(f\"STATUS: [{self.status.value}]{self.status.name}[/]\")\n\tclass Settings(Container):\n\t    earliest = True\n\t    def on_switch_changed(self, event: Switch.Changed) -> None:\n\t        self.earliest = event.value\n\t    def compose(self) -> ComposeResult:\n\t        yield Label(\"SETTINGS\", classes=\"title\")\n\t        yield Horizontal(Static(\"EARLIEST:     \", classes=\"label\"), Switch(value=self.earliest))\n\tclass JsonViewer(Container, can_focus=True):\n", "    json = reactive(\"{}\")\n\t    def watch_json(self, json: str) -> None:\n\t        json_widget = self.query_one(Json)\n\t        json_widget.update(JSON(json, sort_keys=True))\n\t        self.scroll_home()\n\t    def compose(self) -> ComposeResult:\n\t        yield Container(Json(expand=True))\n\tclass Json(Static):\n\t    pass\n\tclass Editor(Container):\n", "    pass\n\tclass Header(Static):\n\t    server = Server()\n\t    def render(self) -> RenderableType:\n\t        kayak_name = KayakName()\n\t        ksql_info = ServerInfo(self.server)\n\t        return Columns([kayak_name, ksql_info], padding=3)\n\tclass Tui(App[None]):\n\t    CSS_PATH = \"tui.css\"\n\t    BINDINGS = [\n", "        Binding(Keys.ControlC, \"quit\", \"QUIT\"),\n\t        # Binding(Keys.F1, \"push_screen('help')\", \"HELP\"),\n\t        Binding(Keys.ControlX, \"kill_query\", \"KILL QUERY\"),\n\t        Binding(Keys.ControlS, \"toggle_settings\", \"TOGGLE SETTINGS\"),\n\t    ]\n\t    status = reactive(Statuses.IDLE)\n\t    query_id: str | None = None\n\t    def __init__(\n\t        self,\n\t        server: str,\n", "        user: str | None,\n\t        password: str | None,\n\t        driver_class: Type[Driver] | None = None,\n\t        css_path: CSSPathType | None = None,\n\t        watch_css: bool = False,\n\t    ):\n\t        super().__init__(driver_class, css_path, watch_css)\n\t        self.ksql_service = KsqlService(server, user, password)\n\t        self.server = self.ksql_service.info()\n\t        self.topics = self.ksql_service.topics()\n", "        self.streams = self.ksql_service.streams()\n\t        self.tables = self.ksql_service.tables()\n\t        self.queries = self.ksql_service.queries()\n\t    def on_mount(self) -> None:\n\t        input_query = self.query_one(Input)\n\t        input_query.placeholder = \"QUERY\"\n\t        input_query.focus()\n\t        header = self.query_one(Header)\n\t        header.server = self.server\n\t        tree = self.query_one(Tree)\n", "        tree.show_root = False\n\t        tree.root.expand()\n\t        tree.cursor_line = -1\n\t        topics_node = tree.root.add(\"TOPICS\", expand=True, data=\"TOPICS\")\n\t        for topic in self.topics:\n\t            topics_node.add_leaf(topic.name, data=topic.name)\n\t        streams_node = tree.root.add(\"STREAMS\", expand=True, data=\"STREAMS\")\n\t        for stream in self.streams:\n\t            streams_node.add_leaf(stream.name, data=stream.name)\n\t        tables_node = tree.root.add(\"TABLES\", expand=True, data=\"TABLES\")\n", "        for table in self.tables:\n\t            tables_node.add_leaf(table.name, data=table.name)\n\t        queries_node = tree.root.add(\"QUERIES\", expand=True, data=\"QUERIES\")\n\t        for query in self.queries:\n\t            queries_node.add_leaf(query.id, data=query.id)\n\t        table_widget = self.query_one(DataTable)\n\t        table_widget.cursor_type = \"row\"\n\t        self.design = DESIGN\n\t        self.refresh_css()\n\t    async def action_kill_query(self) -> None:\n", "        logger.debug(\"Killing query %s\", self.query_id)\n\t        if self.query_id:\n\t            self.ksql_service.close_query(self.query_id)\n\t    async def action_toggle_settings(self) -> None:\n\t        input_widget = self.query_one(Input)\n\t        settings = self.query_one(Settings)\n\t        switch = settings.query_one(Switch)\n\t        if switch.has_focus:\n\t            input_widget.focus()\n\t        else:\n", "            switch.focus()\n\t    def watch_status(self, status: Statuses) -> None:\n\t        status_widget = self.query_one(Status)\n\t        status_widget.status = status\n\t    async def on_tree_node_selected(\n\t        self, selected_node_event: Tree.NodeSelected[EventTreeDataType]\n\t    ) -> None:\n\t        node: TreeNode[EventTreeDataType] = selected_node_event.node\n\t        if node.parent is None:\n\t            return\n", "        parent: TreeNode[EventTreeDataType] = node.parent\n\t        str_parent: str = str(parent.data)\n\t        str_child: str = str(node.data)\n\t        logger.debug(\"parent selected node: %s\", str_parent)\n\t        logger.debug(\"selected node: %s\", str_child)\n\t        if str_parent.upper() in [\"STREAMS\", \"TABLES\"]:\n\t            self.fill_input(f\"DESCRIBE {str_child};\")\n\t        if str_parent.upper() in [\"QUERIES\"]:\n\t            self.fill_input(f\"EXPLAIN {str_child};\")\n\t    def fill_input(self, value: str) -> None:\n", "        input_query = self.query_one(Input)\n\t        input_query.value = value\n\t        input_query.focus()\n\t    async def on_input_submitted(self, input_submitted_event: Input.Submitted) -> None:\n\t        input_value = input_submitted_event.value\n\t        if not input_value:\n\t            return\n\t        await self.action_kill_query()\n\t        settings = self.query_one(Settings)\n\t        json_viewer = self.query_one(JsonViewer)\n", "        table = self.query_one(DataTable)\n\t        if input_value.upper().startswith(\"PRINT\"):\n\t            self.error_state(\n\t                json.dumps(\n\t                    {\n\t                        \"message\": (\n\t                            'PRINT query is not allowed. Import the topic as a \"stream\" and use'\n\t                            \" SELECT\"\n\t                        )\n\t                    }\n", "                )\n\t            )\n\t        elif input_value.upper().startswith(\"SELECT\"):\n\t            table.remove_class(\"hidden\")\n\t            json_viewer.add_class(\"hidden\")\n\t            table.focus()\n\t            table.clear(columns=True)\n\t            columns = []\n\t            def on_close() -> None:\n\t                self.query_id = None\n", "                if self.status == Statuses.RUNNING:\n\t                    self.status = Statuses.IDLE\n\t            def on_init(data: dict[str, Any]) -> None:\n\t                self.status = Statuses.RUNNING\n\t                self.query_id = data[\"queryId\"]\n\t                nonlocal columns\n\t                column_names: List[str] = data[\"columnNames\"]\n\t                justify_list: List[Literal[\"left\", \"right\"]] = [\n\t                    LEFT if column_type.upper() in [\"VARCHAR\", \"STRING\"] else RIGHT\n\t                    for column_type in data[\"columnTypes\"]\n", "                ]\n\t                columns = list(\n\t                    zip(\n\t                        column_names,\n\t                        justify_list,\n\t                    )\n\t                )\n\t                logger.debug(\"adding columns: %s\", columns)\n\t                for column_name, justify in columns:\n\t                    table.add_column(Text(str(column_name), justify=justify))\n", "            def on_new_row(row: list[Any]) -> None:\n\t                nonlocal columns\n\t                zip_row = list(zip(row, [justify for column_name, justify in columns]))\n\t                logger.debug(\"adding row: %s\", zip_row)\n\t                row = [Text(str(cell), justify=justify) for cell, justify in zip_row]\n\t                table.add_row(*row)\n\t                table.scroll_end()\n\t            def on_error(code: int, content: str) -> None:\n\t                self.error_state(content)\n\t            asyncio.create_task(\n", "                self.ksql_service.query(\n\t                    query=input_value,\n\t                    earliest=settings.earliest,\n\t                    on_init=on_init,\n\t                    on_new_row=on_new_row,\n\t                    on_close=on_close,\n\t                    on_error=on_error,\n\t                )\n\t            )\n\t        else:\n", "            json_viewer.remove_class(\"hidden\")\n\t            table.add_class(\"hidden\")\n\t            json_viewer.focus()\n\t            response = self.ksql_service.statement(input_value)\n\t            json_viewer.json = response.text\n\t            if response.status_code != 200:\n\t                json_viewer.add_class(\"error\")\n\t                self.status = Statuses.ERROR\n\t            else:\n\t                json_viewer.remove_class(\"error\")\n", "                self.status = Statuses.IDLE\n\t    def error_state(self, error_content: str) -> None:\n\t        json_viewer = self.query_one(JsonViewer)\n\t        table = self.query_one(DataTable)\n\t        json_viewer.remove_class(\"hidden\")\n\t        table.add_class(\"hidden\")\n\t        json_viewer.focus()\n\t        json_viewer.json = error_content\n\t        json_viewer.add_class(\"error\")\n\t        self.status = Statuses.ERROR\n", "    def compose(self) -> ComposeResult:\n\t        yield Header()\n\t        yield Footer()\n\t        yield Settings(classes=\"-hidden\")\n\t        yield Tree(\"\")\n\t        with Editor():\n\t            yield Input()\n\t            yield DataTable()\n\t            yield JsonViewer(classes=\"hidden\")\n\t            yield Status()\n"]}
{"filename": "kayak/styles/colors.py", "chunked_list": ["from textual.design import ColorSystem\n\tERROR = \"#ba3c5b\"\n\tGREEN = \"#4EBF71\"\n\tPRIMARY = \"#ff5f00\"\n\tSECONDARY = \"#0087ff\"\n\tDESIGN = {\n\t    \"dark\": ColorSystem(\n\t        primary=PRIMARY,\n\t        secondary=SECONDARY,\n\t        error=ERROR,\n", "        dark=True,\n\t    ),\n\t    \"light\": ColorSystem(\n\t        primary=PRIMARY,\n\t        secondary=SECONDARY,\n\t        error=ERROR,\n\t        dark=False,\n\t    ),\n\t}\n"]}
{"filename": "kayak/styles/__init__.py", "chunked_list": []}
{"filename": "kayak/renderables/kayak_name.py", "chunked_list": ["from pyfiglet import Figlet\n\tfrom rich.text import Text\n\tfrom kayak import NAME, VERSION\n\tfrom kayak.styles.colors import PRIMARY, SECONDARY\n\tclass KayakName:\n\t    def __init__(self, include_version: bool = True):\n\t        self.include_version = include_version\n\t    def __str__(self) -> str:\n\t        figlet = Figlet(font=\"chunky\")\n\t        text: str = figlet.renderText(NAME)\n", "        return text.rstrip()\n\t    def __rich__(self) -> Text:\n\t        text = Text(str(self), style=f\"{PRIMARY} bold\")\n\t        if self.include_version:\n\t            text.append(f\"v{VERSION}\", style=f\"{SECONDARY} bold\")\n\t        return text\n"]}
{"filename": "kayak/renderables/__init__.py", "chunked_list": []}
{"filename": "kayak/renderables/server_info.py", "chunked_list": ["from rich.table import Table\n\tfrom kayak.ksql.models import Server\n\tfrom kayak.styles.colors import SECONDARY\n\tclass ServerInfo:\n\t    def __init__(self, server: Server) -> None:\n\t        self.server = server\n\t    def __str__(self) -> str:\n\t        return str(self.server)\n\t    def __rich__(self) -> Table:\n\t        table = Table(box=None, expand=False)\n", "        table.add_column(style=f\"{SECONDARY} bold\")\n\t        table.add_column()\n\t        table.add_row(\"SERVER:\", self.server.server)\n\t        table.add_row(\"ID:\", self.server.id)\n\t        table.add_row(\"VERSION:\", self.server.version if self.server.version else \"unknown\")\n\t        table.add_row(\"STATUS:\", self.server.status.lower())\n\t        table.add_row(\"SERVICE ID:\", self.server.service_id)\n\t        return table\n"]}
{"filename": "kayak/ksql/ksql_service.py", "chunked_list": ["import asyncio\n\timport json\n\tfrom typing import Any, Callable, Dict, List\n\tfrom urllib.parse import urljoin\n\timport httpx\n\tfrom httpx import Response\n\tfrom kayak.ksql.models import Server, Stream, Topic, Table, Query\n\tTIMEOUT_1H = 60 * 60\n\tKSQL_HEADERS = {\"Accept\": \"application/vnd.ksql.v1+json\"}\n\tclass KsqlService:\n", "    def __init__(\n\t        self,\n\t        server: str,\n\t        user: str | None = None,\n\t        password: str | None = None,\n\t    ):\n\t        self.server = server\n\t        self.user = user\n\t        self.password = password\n\t    def info(self) -> Server:\n", "        response = self.introspect(\"info\")\n\t        response.raise_for_status()\n\t        def json_to_server(obj: dict[Any, Any], server: str) -> Any:\n\t            if \"KsqlServerInfo\" in obj:\n\t                return obj[\"KsqlServerInfo\"]\n\t            if \"version\" in obj:\n\t                return Server(\n\t                    id=obj[\"kafkaClusterId\"],\n\t                    service_id=obj[\"ksqlServiceId\"],\n\t                    status=obj[\"serverStatus\"],\n", "                    version=obj[\"version\"],\n\t                    server=server,\n\t                )\n\t            return obj\n\t        server_obj: Server = response.json(object_hook=lambda d: json_to_server(d, self.server))\n\t        return server_obj\n\t    def streams(self) -> List[Stream]:\n\t        response = self.statement(\"LIST STREAMS;\")\n\t        response.raise_for_status()\n\t        def json_to_stream(obj: dict[Any, Any]) -> Any:\n", "            if \"streams\" in obj:\n\t                return obj[\"streams\"]\n\t            if \"name\" in obj:\n\t                return Stream(\n\t                    name=obj[\"name\"],\n\t                    topic=obj[\"topic\"],\n\t                    key_format=obj[\"keyFormat\"],\n\t                    value_format=obj[\"valueFormat\"],\n\t                )\n\t            return obj\n", "        streams: List[Stream] = response.json(object_hook=json_to_stream)[0]\n\t        return streams\n\t    def tables(self) -> List[Table]:\n\t        response = self.statement(\"LIST TABLES;\")\n\t        response.raise_for_status()\n\t        def json_to_table(obj: dict[Any, Any]) -> Any:\n\t            if \"tables\" in obj:\n\t                return obj[\"tables\"]\n\t            if \"name\" in obj:\n\t                return Table(\n", "                    name=obj[\"name\"],\n\t                    topic=obj[\"topic\"],\n\t                    key_format=obj[\"keyFormat\"],\n\t                    value_format=obj[\"valueFormat\"],\n\t                )\n\t            return obj\n\t        tables: List[Table] = response.json(object_hook=json_to_table)[0]\n\t        return tables\n\t    def queries(self) -> List[Query]:\n\t        response = self.statement(\"LIST QUERIES;\")\n", "        response.raise_for_status()\n\t        def json_to_query(obj: dict[Any, Any]) -> Any:\n\t            if \"queries\" in obj:\n\t                return obj[\"queries\"]\n\t            if \"id\" in obj:\n\t                return Query(\n\t                    id=obj[\"id\"],\n\t                    topics=obj[\"sinkKafkaTopics\"],\n\t                    query_type=obj[\"queryType\"],\n\t                    state=obj[\"state\"],\n", "                )\n\t            return obj\n\t        queries: List[Query] = response.json(object_hook=json_to_query)[0]\n\t        return queries\n\t    def topics(self) -> List[Topic]:\n\t        response = self.statement(\"LIST TOPICS;\")\n\t        response.raise_for_status()\n\t        def json_to_topic(obj: dict[Any, Any]) -> Any:\n\t            if \"topics\" in obj:\n\t                return obj[\"topics\"]\n", "            if \"name\" in obj:\n\t                return Topic(\n\t                    name=obj[\"name\"],\n\t                )\n\t            return obj\n\t        topic_list: List[Topic] = response.json(object_hook=json_to_topic)[0]\n\t        return topic_list\n\t    def auth(self) -> tuple[str, str] | None:\n\t        return None if None in [self.user, self.password] else (str(self.user), str(self.password))\n\t    def introspect(self, resource: str) -> Response:\n", "        url = urljoin(self.server, resource)\n\t        response = httpx.get(\n\t            url,\n\t            headers=KSQL_HEADERS,\n\t            auth=self.auth(),\n\t        )\n\t        return response\n\t    def statement(self, statement: str) -> Response:\n\t        data = {\"ksql\": statement}\n\t        url = urljoin(self.server, \"/ksql\")\n", "        response = httpx.post(\n\t            url,\n\t            json=data,\n\t            headers=KSQL_HEADERS,\n\t            auth=self.auth(),\n\t        )\n\t        return response\n\t    async def query(\n\t        self,\n\t        query: str,\n", "        earliest: bool = False,\n\t        on_init: Callable[[dict[str, Any]], None] = lambda data: None,\n\t        on_new_row: Callable[[list[Any]], None] = lambda row: None,\n\t        on_close: Callable[[], None] = lambda: None,\n\t        on_error: Callable[[int, str], None] = lambda code, content: None,\n\t    ) -> None:\n\t        url = urljoin(self.server, \"/query-stream\")\n\t        data = {\n\t            \"sql\": query,\n\t            \"properties\": {\"auto.offset.reset\": \"earliest\"} if earliest else {},\n", "        }\n\t        async with httpx.AsyncClient(\n\t            http2=True,\n\t            timeout=TIMEOUT_1H,\n\t            auth=self.auth(),\n\t        ) as client:\n\t            async with client.stream(method=\"POST\", url=url, json=data) as stream:\n\t                async for chunk in stream.aiter_text():\n\t                    if chunk:\n\t                        results = json.loads(chunk)\n", "                        if stream.status_code != 200:\n\t                            on_error(stream.status_code, chunk)\n\t                            break\n\t                        if isinstance(results, Dict):\n\t                            on_init(results)\n\t                        elif isinstance(results, List):\n\t                            on_new_row(results)\n\t        on_close()\n\t    def close_query(self, id: str) -> None:\n\t        url = urljoin(self.server, \"/close-query\")\n", "        data = {\"queryId\": id}\n\t        httpx.post(\n\t            url,\n\t            json=data,\n\t            headers=KSQL_HEADERS,\n\t            auth=self.auth(),\n\t        )\n\tif __name__ == \"__main__\":\n\t    service = KsqlService(\"http://localhost:8088\")\n\t    print(\"--REQUESTS--\")\n", "    print(\"info\", service.info())\n\t    print(\"streams\", service.streams())\n\t    print(\"topics\", service.topics())\n\t    print(\"tables\", service.tables())\n\t    print(\"queries\", service.queries())\n\t    print(\"--QUERIES--\")\n\t    asyncio.run(\n\t        service.query(\n\t            \"SELECT * FROM orders;\",\n\t            on_init=print,\n", "            on_new_row=print,\n\t            on_close=lambda: print(\"orders finished\"),\n\t        )\n\t    )\n\t    query_id = \"\"\n\t    async def close_query() -> None:\n\t        global query_id\n\t        await asyncio.sleep(10)\n\t        service.close_query(query_id)\n\t    async def pull_query() -> None:\n", "        def on_init(data: dict[str, Any]) -> None:\n\t            global query_id\n\t            query_id = data[\"queryId\"]\n\t            print(query_id)\n\t            print(data[\"columnTypes\"])\n\t        query = asyncio.create_task(\n\t            service.query(\n\t                \"SELECT * FROM orderSizes EMIT CHANGES;\",\n\t                True,\n\t                on_init=on_init,\n", "                on_new_row=print,\n\t                on_close=lambda: print(\"orderSizes finished\"),\n\t            )\n\t        )\n\t        close = asyncio.create_task(close_query())\n\t        await query\n\t        await close\n\t    asyncio.run(pull_query())\n\t    print(\"--QUERY ERROR--\")\n\t    asyncio.run(\n", "        service.query(\n\t            \"SELECT * FROM orders\",\n\t            on_error=lambda code, content: print(\"response status:\", code, \"content:\", content),\n\t            on_close=lambda: print(\"error closed\"),\n\t        )\n\t    )\n"]}
{"filename": "kayak/ksql/models.py", "chunked_list": ["import json\n\tfrom typing import List\n\tclass Server:\n\t    def __init__(\n\t        self,\n\t        id: str = \"\",\n\t        server: str = \"\",\n\t        service_id: str = \"\",\n\t        status: str = \"\",\n\t        version: str = \"\",\n", "    ) -> None:\n\t        self.id = id\n\t        self.server = server\n\t        self.service_id = service_id\n\t        self.status = status\n\t        self.version = version\n\t    def __repr__(self) -> str:\n\t        return json.dumps(\n\t            {\n\t                \"id\": self.id,\n", "                \"server\": self.server,\n\t                \"service_id\": self.service_id,\n\t                \"status\": self.status,\n\t                \"version\": self.version,\n\t            }\n\t        )\n\t    def __str__(self) -> str:\n\t        return repr(self)\n\tclass Stream:\n\t    def __init__(\n", "        self,\n\t        name: str = \"\",\n\t        topic: str = \"\",\n\t        key_format: str = \"\",\n\t        value_format: str = \"\",\n\t    ) -> None:\n\t        self.name = name\n\t        self.topic = topic\n\t        self.key_format = key_format\n\t        self.value_format = value_format\n", "    def __repr__(self) -> str:\n\t        return json.dumps(\n\t            {\n\t                \"name\": self.name,\n\t                \"topic\": self.topic,\n\t                \"key_format\": self.key_format,\n\t                \"value_format\": self.value_format,\n\t            }\n\t        )\n\t    def __str__(self) -> str:\n", "        return repr(self)\n\tclass Table:\n\t    def __init__(\n\t        self,\n\t        name: str = \"\",\n\t        topic: str = \"\",\n\t        key_format: str = \"\",\n\t        value_format: str = \"\",\n\t    ) -> None:\n\t        self.name = name\n", "        self.topic = topic\n\t        self.key_format = key_format\n\t        self.value_format = value_format\n\t    def __repr__(self) -> str:\n\t        return json.dumps(\n\t            {\n\t                \"name\": self.name,\n\t                \"topic\": self.topic,\n\t                \"key_format\": self.key_format,\n\t                \"value_format\": self.value_format,\n", "            }\n\t        )\n\t    def __str__(self) -> str:\n\t        return repr(self)\n\tclass Query:\n\t    def __init__(\n\t        self,\n\t        id: str = \"\",\n\t        topics: List[str] = [],\n\t        query_type: str = \"\",\n", "        state: str = \"\",\n\t    ) -> None:\n\t        self.id = id\n\t        self.topics = topics\n\t        self.query_type = query_type\n\t        self.state = state\n\t    def __repr__(self) -> str:\n\t        return json.dumps(\n\t            {\n\t                \"id\": self.id,\n", "                \"topics\": self.topics,\n\t                \"query_type\": self.query_type,\n\t                \"state\": self.state,\n\t            }\n\t        )\n\t    def __str__(self) -> str:\n\t        return repr(self)\n\tclass Topic:\n\t    def __init__(\n\t        self,\n", "        name: str = \"\",\n\t    ) -> None:\n\t        self.name = name\n\t    def __repr__(self) -> str:\n\t        return json.dumps({\"name\": self.name})\n\t    def __str__(self) -> str:\n\t        return repr(self)\n"]}
{"filename": "kayak/ksql/__init__.py", "chunked_list": []}
