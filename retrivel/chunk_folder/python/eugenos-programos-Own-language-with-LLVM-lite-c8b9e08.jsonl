{"filename": "main.py", "chunked_list": ["import sys\n\timport os\n\tfrom antlr4 import *\n\tfrom lexer.LangLexer import LangLexer\n\tfrom parser.LangParser import LangParser\n\tfrom parser.LangParserListener import LangParserListener, SemanticAnalyzerException\n\tfrom parser.LangParserVisitor import LangParserVisitor\n\tfrom MyErrorStrategy import MyErrorStrategy\n\tfrom MyErrorListener import MyErrorListener\n\tdef get_username():\n", "    from pwd import getpwuid\n\t    from os import getuid\n\t    return getpwuid(getuid())[0]\n\tif __name__ == '__main__':\n\t    print(get_username())\n\t    if len(sys.argv) > 1:\n\t        data = FileStream(sys.argv[1])\n\t        lexer = LangLexer(data)\n\t        stream = CommonTokenStream(lexer)\n\t        parser = LangParser(stream)\n", "        parser.removeErrorListeners()\n\t        parser.addErrorListener(MyErrorListener())\n\t        parser.addParseListener(LangParserListener())\n\t        parser.resetErrHandler(MyErrorStrategy())\n\t        tree = parser.program()\n\t        visitor = LangParserVisitor()\n\t        output = visitor.visit(tree)\n\t        if output:\n\t            print(output)\n\t    else:\n", "        listener = LangParserListener()\n\t        while True:\n\t            try:\n\t                data = InputStream(input(\">>> \"))\n\t                lexer = LangLexer(data)\n\t                stream = CommonTokenStream(lexer)\n\t                parser = LangParser(stream)\n\t                parser.removeErrorListeners()\n\t                parser.addErrorListener(MyErrorListener())\n\t                parser.addParseListener(listener)\n", "                parser.resetErrHandler(MyErrorStrategy())\n\t                tree = parser.program()\n\t                visitor = LangParserVisitor()\n\t                output = visitor.visit(tree)\n\t            except SemanticAnalyzerException as exc:\n\t                listener.clear_func_cache()\n\t                print(\"Error - \", exc)\n"]}
{"filename": "MyErrorStrategy.py", "chunked_list": ["from antlr4.error.Errors import RecognitionException, NoViableAltException, InputMismatchException, \\\n\t    FailedPredicateException\n\tfrom antlr4.error.ErrorStrategy import DefaultErrorStrategy\n\tfrom antlr4 import *\n\tfrom parser.LangParser import LangParser\n\tclass MyErrorStrategy(DefaultErrorStrategy):\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t    def reportError(self, recognizer: Parser, e: RecognitionException, localctx: ParserRuleContext = None):\n\t       # if we've already reported an error and have not matched a token\n", "       # yet successfully, don't report any errors.\n\t        if self.inErrorRecoveryMode(recognizer):\n\t            return # don't report spurious errors\n\t        self.beginErrorCondition(recognizer)\n\t        if isinstance( e, NoViableAltException ):\n\t            msg = self.checkContext(localctx)\n\t            self.reportNoViableAlternative(recognizer, e, msg)\n\t        elif isinstance( e, InputMismatchException ):\n\t            msg = self.checkContext(localctx)\n\t            self.reportInputMismatch(recognizer, e, msg)\n", "        elif isinstance( e, FailedPredicateException ):\n\t            msg = self.checkContext(localctx)\n\t            self.reportFailedPredicate(recognizer, e, msg)\n\t        else:\n\t            print(\"unknown recognition error type: \" + type(e).__name__)\n\t            recognizer.notifyErrorListeners(e.message, e.offendingToken, e)\n\t    def checkContext(self, localctx : ParserRuleContext):\n\t        msg = None\n\t        if isinstance(localctx, LangParser.ForStatContext):\n\t            msg = \"For statement mismatched input - {}. Expected expression like for(<>;<>;<>)...\"\n", "        elif isinstance(localctx, LangParser.IfElseStmtContext):\n\t            msg = \"IF/Else statement mismatched input - {}. Expected expression like if bool_stmt <else >.\"\n\t        elif isinstance(localctx, LangParser.AssignExprContext):\n\t            msg = \"Assign expression mismatched form - {}. Expected expression <type> ID [= value];\"\n\t        elif isinstance(localctx, LangParser.PrintStmtContext):\n\t            msg = \"Print function mismatched form - {}. Expected print(<value>);\"\n\t        elif isinstance(localctx, LangParser.FuncContext):\n\t            msg = \"Function definition mismatched form - {}. Expected <type> function ID (params).\"\n\t        elif isinstance(localctx, LangParser.WhileStmtContext):\n\t            msg = \"While statement mismatched form - {}. Expected while(boolExpr)...\"\n", "        elif isinstance(localctx, LangParser.UntilStmtContext):\n\t            msg = \"Until statement mismatched form - {}. Expected ...until(boolExpr)\"\n\t        elif isinstance(localctx, LangParser.IncDecrStatContext):\n\t            msg = \"Increment or decrement statement mismatched form - {}. Expected ++/--value.\"\n\t        elif isinstance(localctx, LangParser.VarDeclStmtContext):\n\t            msg = \"Variable declaration mismatched form - {}. Expected basic_type <name> value?\"\n\t        elif isinstance(localctx, LangParser.CustFuncCallContext):\n\t            msg = \"Function call mismatched form - {}. Expected func_name(params)\"\n\t        elif isinstance(localctx, LangParser.IndexStmtContext):\n\t            msg = \"Index statement mismatched form - {}. Expected value[value]\"\n", "        elif isinstance(localctx, LangParser.ReadStrStmtContext):\n\t            msg = \"read_string function mismatched form - {}. Expected read_string();\"\n\t        elif isinstance(localctx, LangParser.ReturnStmtContext):\n\t            msg = \"return statement mismatched form - {}. Expected return value;\"\n\t        elif isinstance(localctx, (LangParser.CreateColStmtContext, LangParser.CreateRowStmtContext, LangParser.CreateTablStmtContext)):\n\t            msg = \"create function has a different form - {}. Expected create_function(params).\"\n\t        elif isinstance(localctx, LangParser.DelFuncContext):\n\t            msg = \"delete function has a mismatched form - {}. Expected delete_function(params).\"\n\t        elif isinstance(localctx, LangParser.InsertStmtContext):\n\t            msg = \"Insert function has a mismatched form - {}. Expected insert(value, value, value).\"\n", "        elif isinstance(localctx, LangParser.FindStmtContext):\n\t            msg = \"Find function has a different form - {}. Expected find(val1, val2)\"\n\t        elif isinstance(localctx, LangParser.LengthStmtContext):\n\t            msg = \"Find function has a different form - {}. Expected length(value)\"\n\t        elif isinstance(localctx, LangParser.CustFuncCallContext):\n\t            msg = \"Custom function call has a different form - {}. Expected func_name(params)\"\n\t        elif isinstance(localctx, LangParser.MinMaxFuncStmtContext):\n\t            msg = \"min/max function call has a different form - {}. Expected min_max_name(value)\"\n\t        elif isinstance(localctx, LangParser.ReshapeStmtContext):\n\t            msg = \"reshape function has a different form - {}. Expected reshape(val1, val2, val3)\"\n", "        elif isinstance(localctx, LangParser.ListStmtContext):\n\t            msg = \"List definition has a different form - {}. Expected [...,...,...]\"\n\t        elif isinstance(localctx, LangParser.BoolExprContext):\n\t            msg = \"Boolean expresion has a different form - {}. Expeted val1 <bool_sign> val2\"\n\t        elif isinstance(localctx, LangParser.ReturnTypeContext):\n\t            msg = \"Return value has a different form - {}. Gotten non return statement.\"\n\t        elif isinstance(localctx, LangParser.BasicTypeNameContext):\n\t            msg = \"Basic type name expected. But {} received.\"\n\t        elif isinstance(localctx, LangParser.StatContext):\n\t            msg = \"Expression has an incorrect form - {}.\"\n", "        return msg\n\t    def reportNoViableAlternative(self, recognizer: Parser, e: NoViableAltException, msg : str = None):\n\t        tokens = recognizer.getTokenStream()\n\t        if tokens is not None:\n\t            if e.startToken.type==Token.EOF:\n\t                input = \"<EOF>\"\n\t            else:\n\t                input = tokens.getText((e.startToken, e.offendingToken))\n\t        else:\n\t            input = \"<unknown input>\"\n", "        if msg:\n\t            msg = msg.format(self.escapeWSAndQuote(input))\n\t        else:\n\t            msg = \"Name \" + self.escapeWSAndQuote(input) + \" is not defined\"\n\t        recognizer.notifyErrorListeners(msg, e.offendingToken, e)\n\t    def reportInputMismatch(self, recognizer: Parser, e: InputMismatchException, msg : str = None):\n\t        if msg:\n\t            msg = msg.format(self.getTokenErrorDisplay(e.offendingToken))\n\t        if not msg: \n\t            msg = \"mismatched input \" + self.getTokenErrorDisplay(e.offendingToken) \\\n", "              + \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames)\n\t        recognizer.notifyErrorListeners(msg, e.offendingToken, e)\n\t    def reportFailedPredicate(self, recognizer, e, msg):\n\t        ruleName = recognizer.ruleNames[recognizer._ctx.getRuleIndex()]\n\t        msg = msg.format(ruleName)\n\t        if not msg:\n\t            msg = \"rule \" + ruleName + \" \" + e.message\n\t        recognizer.notifyErrorListeners(msg, e.offendingToken, e)\n\t    def reportMissingToken(self, recognizer:Parser):\n\t        if self.inErrorRecoveryMode(recognizer):\n", "            return\n\t        self.beginErrorCondition(recognizer)\n\t        t = recognizer.getCurrentToken()\n\t        expecting = self.getExpectedTokens(recognizer)\n\t        msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) \\\n\t              + \" after line \" + self.getTokenErrorDisplay(t)\n\t        recognizer.notifyErrorListeners(msg, t, None)\n"]}
{"filename": "MyErrorListener.py", "chunked_list": ["from antlr4.error.ErrorListener import ErrorListener\n\tclass MyErrorListener(ErrorListener):\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):\n\t        raise SyntaxError(f\"Error in line {line}:{column} - {msg}\")\n"]}
{"filename": "lexer/LangLexer.py", "chunked_list": ["# Generated from LangLexer.g4 by ANTLR 4.7.2\n\tfrom antlr4 import *\n\tfrom io import StringIO\n\tfrom typing.io import TextIO\n\timport sys\n\tdef serializedATN():\n\t    with StringIO() as buf:\n\t        buf.write(\"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\2B\")\n\t        buf.write(\"\\u01db\\b\\1\\4\\2\\t\\2\\4\\3\\t\\3\\4\\4\\t\\4\\4\\5\\t\\5\\4\\6\\t\\6\\4\\7\")\n\t        buf.write(\"\\t\\7\\4\\b\\t\\b\\4\\t\\t\\t\\4\\n\\t\\n\\4\\13\\t\\13\\4\\f\\t\\f\\4\\r\\t\\r\")\n", "        buf.write(\"\\4\\16\\t\\16\\4\\17\\t\\17\\4\\20\\t\\20\\4\\21\\t\\21\\4\\22\\t\\22\\4\\23\")\n\t        buf.write(\"\\t\\23\\4\\24\\t\\24\\4\\25\\t\\25\\4\\26\\t\\26\\4\\27\\t\\27\\4\\30\\t\\30\")\n\t        buf.write(\"\\4\\31\\t\\31\\4\\32\\t\\32\\4\\33\\t\\33\\4\\34\\t\\34\\4\\35\\t\\35\\4\\36\")\n\t        buf.write(\"\\t\\36\\4\\37\\t\\37\\4 \\t \\4!\\t!\\4\\\"\\t\\\"\\4#\\t#\\4$\\t$\\4%\\t%\")\n\t        buf.write(\"\\4&\\t&\\4\\'\\t\\'\\4(\\t(\\4)\\t)\\4*\\t*\\4+\\t+\\4,\\t,\\4-\\t-\\4.\")\n\t        buf.write(\"\\t.\\4/\\t/\\4\\60\\t\\60\\4\\61\\t\\61\\4\\62\\t\\62\\4\\63\\t\\63\\4\\64\")\n\t        buf.write(\"\\t\\64\\4\\65\\t\\65\\4\\66\\t\\66\\4\\67\\t\\67\\48\\t8\\49\\t9\\4:\\t:\")\n\t        buf.write(\"\\4;\\t;\\4<\\t<\\4=\\t=\\4>\\t>\\4?\\t?\\4@\\t@\\4A\\tA\\3\\2\\3\\2\\3\\3\")\n\t        buf.write(\"\\3\\3\\3\\4\\3\\4\\3\\5\\3\\5\\3\\5\\3\\6\\3\\6\\3\\6\\3\\7\\3\\7\\3\\7\\3\\b\\3\")\n\t        buf.write(\"\\b\\3\\b\\3\\t\\3\\t\\3\\n\\3\\n\\3\\13\\3\\13\\3\\f\\3\\f\\3\\r\\3\\r\\3\\16\")\n", "        buf.write(\"\\3\\16\\3\\16\\3\\17\\3\\17\\3\\20\\3\\20\\3\\21\\3\\21\\3\\22\\3\\22\\3\\23\")\n\t        buf.write(\"\\3\\23\\3\\24\\3\\24\\3\\25\\3\\25\\3\\26\\3\\26\\3\\27\\3\\27\\3\\30\\3\\30\")\n\t        buf.write(\"\\3\\30\\3\\31\\3\\31\\3\\32\\3\\32\\3\\32\\3\\33\\3\\33\\3\\33\\3\\34\\3\\34\")\n\t        buf.write(\"\\3\\34\\3\\35\\3\\35\\3\\35\\3\\35\\3\\35\\3\\35\\3\\35\\3\\35\\3\\35\\3\\36\")\n\t        buf.write(\"\\3\\36\\3\\36\\3\\36\\3\\37\\3\\37\\3\\37\\3\\37\\3\\37\\3\\37\\3\\37\\3 \")\n\t        buf.write(\"\\3 \\3 \\3!\\3!\\3!\\3!\\3!\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3#\\3#\\3\")\n\t        buf.write(\"#\\3#\\3#\\3#\\3$\\3$\\7$\\u00ed\\n$\\f$\\16$\\u00f0\\13$\\3%\\3%\\3\")\n\t        buf.write(\"%\\3%\\3%\\3%\\3&\\3&\\3&\\3&\\3&\\3&\\3&\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3\")\n\t        buf.write(\"\\'\\3\\'\\3\\'\\3(\\3(\\3(\\3(\\3(\\3(\\3(\\3(\\3)\\3)\\3)\\3)\\3)\\3)\\3\")\n\t        buf.write(\")\\3)\\3*\\3*\\3*\\3*\\3+\\3+\\3+\\3+\\3+\\3+\\3+\\3,\\3,\\3,\\3,\\3-\\3\")\n", "        buf.write(\"-\\3-\\3-\\3.\\3.\\3.\\3.\\3.\\3.\\3.\\3/\\3/\\3/\\3/\\3/\\3/\\3/\\3\\60\")\n\t        buf.write(\"\\3\\60\\3\\60\\3\\60\\3\\60\\3\\61\\3\\61\\3\\61\\3\\61\\3\\61\\3\\61\\3\\61\")\n\t        buf.write(\"\\3\\61\\3\\61\\3\\61\\3\\61\\3\\62\\3\\62\\3\\62\\3\\62\\3\\62\\3\\62\\3\\62\")\n\t        buf.write(\"\\3\\62\\3\\62\\3\\62\\3\\62\\3\\62\\3\\62\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\")\n\t        buf.write(\"\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\\3\\63\\3\\64\\3\\64\")\n\t        buf.write(\"\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\64\\3\\65\")\n\t        buf.write(\"\\3\\65\\3\\65\\3\\65\\3\\65\\3\\66\\3\\66\\3\\66\\3\\66\\3\\66\\3\\67\\3\\67\")\n\t        buf.write(\"\\3\\67\\3\\67\\3\\67\\3\\67\\3\\67\\38\\38\\38\\38\\38\\38\\39\\39\\39\\3\")\n\t        buf.write(\"9\\39\\39\\39\\3:\\3:\\3:\\3:\\3;\\3;\\3;\\3;\\3;\\3<\\3<\\5<\\u0198\\n\")\n\t        buf.write(\"<\\3<\\6<\\u019b\\n<\\r<\\16<\\u019c\\3<\\3<\\6<\\u01a1\\n<\\r<\\16\")\n", "        buf.write(\"<\\u01a2\\5<\\u01a5\\n<\\3<\\3<\\3<\\5<\\u01aa\\n<\\3<\\6<\\u01ad\\n\")\n\t        buf.write(\"<\\r<\\16<\\u01ae\\5<\\u01b1\\n<\\3=\\3=\\3=\\3=\\7=\\u01b7\\n=\\f=\")\n\t        buf.write(\"\\16=\\u01ba\\13=\\3=\\3=\\3>\\3>\\7>\\u01c0\\n>\\f>\\16>\\u01c3\\13\")\n\t        buf.write(\">\\3?\\6?\\u01c6\\n?\\r?\\16?\\u01c7\\3?\\3?\\3@\\3@\\3@\\3@\\3@\\3@\")\n\t        buf.write(\"\\3@\\3@\\3A\\3A\\3A\\3A\\3A\\3A\\3A\\3A\\2\\2B\\3\\3\\5\\4\\7\\5\\t\\6\\13\")\n\t        buf.write(\"\\7\\r\\b\\17\\t\\21\\n\\23\\13\\25\\f\\27\\r\\31\\16\\33\\17\\35\\20\\37\")\n\t        buf.write(\"\\21!\\22#\\23%\\24\\'\\25)\\26+\\27-\\30/\\31\\61\\32\\63\\33\\65\\34\")\n\t        buf.write(\"\\67\\359\\36;\\37= ?!A\\\"C#E$G%I&K\\'M(O)Q*S+U,W-Y.[/]\\60_\")\n\t        buf.write(\"\\61a\\62c\\63e\\64g\\65i\\66k\\67m8o9q:s;u<w=y>{?}@\\177A\\u0081\")\n\t        buf.write(\"B\\3\\2\\t\\4\\2\\f\\f\\17\\17\\3\\2\\62;\\4\\2GGgg\\4\\2$$^^\\5\\2C\\\\a\")\n", "        buf.write(\"ac|\\6\\2\\62;C\\\\aac|\\5\\2\\13\\f\\16\\17\\\"\\\"\\2\\u01e8\\2\\3\\3\\2\")\n\t        buf.write(\"\\2\\2\\2\\5\\3\\2\\2\\2\\2\\7\\3\\2\\2\\2\\2\\t\\3\\2\\2\\2\\2\\13\\3\\2\\2\\2\")\n\t        buf.write(\"\\2\\r\\3\\2\\2\\2\\2\\17\\3\\2\\2\\2\\2\\21\\3\\2\\2\\2\\2\\23\\3\\2\\2\\2\\2\")\n\t        buf.write(\"\\25\\3\\2\\2\\2\\2\\27\\3\\2\\2\\2\\2\\31\\3\\2\\2\\2\\2\\33\\3\\2\\2\\2\\2\\35\")\n\t        buf.write(\"\\3\\2\\2\\2\\2\\37\\3\\2\\2\\2\\2!\\3\\2\\2\\2\\2#\\3\\2\\2\\2\\2%\\3\\2\\2\\2\")\n\t        buf.write(\"\\2\\'\\3\\2\\2\\2\\2)\\3\\2\\2\\2\\2+\\3\\2\\2\\2\\2-\\3\\2\\2\\2\\2/\\3\\2\\2\")\n\t        buf.write(\"\\2\\2\\61\\3\\2\\2\\2\\2\\63\\3\\2\\2\\2\\2\\65\\3\\2\\2\\2\\2\\67\\3\\2\\2\\2\")\n\t        buf.write(\"\\29\\3\\2\\2\\2\\2;\\3\\2\\2\\2\\2=\\3\\2\\2\\2\\2?\\3\\2\\2\\2\\2A\\3\\2\\2\")\n\t        buf.write(\"\\2\\2C\\3\\2\\2\\2\\2E\\3\\2\\2\\2\\2G\\3\\2\\2\\2\\2I\\3\\2\\2\\2\\2K\\3\\2\")\n\t        buf.write(\"\\2\\2\\2M\\3\\2\\2\\2\\2O\\3\\2\\2\\2\\2Q\\3\\2\\2\\2\\2S\\3\\2\\2\\2\\2U\\3\")\n", "        buf.write(\"\\2\\2\\2\\2W\\3\\2\\2\\2\\2Y\\3\\2\\2\\2\\2[\\3\\2\\2\\2\\2]\\3\\2\\2\\2\\2_\")\n\t        buf.write(\"\\3\\2\\2\\2\\2a\\3\\2\\2\\2\\2c\\3\\2\\2\\2\\2e\\3\\2\\2\\2\\2g\\3\\2\\2\\2\\2\")\n\t        buf.write(\"i\\3\\2\\2\\2\\2k\\3\\2\\2\\2\\2m\\3\\2\\2\\2\\2o\\3\\2\\2\\2\\2q\\3\\2\\2\\2\")\n\t        buf.write(\"\\2s\\3\\2\\2\\2\\2u\\3\\2\\2\\2\\2w\\3\\2\\2\\2\\2y\\3\\2\\2\\2\\2{\\3\\2\\2\")\n\t        buf.write(\"\\2\\2}\\3\\2\\2\\2\\2\\177\\3\\2\\2\\2\\2\\u0081\\3\\2\\2\\2\\3\\u0083\\3\")\n\t        buf.write(\"\\2\\2\\2\\5\\u0085\\3\\2\\2\\2\\7\\u0087\\3\\2\\2\\2\\t\\u0089\\3\\2\\2\\2\")\n\t        buf.write(\"\\13\\u008c\\3\\2\\2\\2\\r\\u008f\\3\\2\\2\\2\\17\\u0092\\3\\2\\2\\2\\21\")\n\t        buf.write(\"\\u0095\\3\\2\\2\\2\\23\\u0097\\3\\2\\2\\2\\25\\u0099\\3\\2\\2\\2\\27\\u009b\")\n\t        buf.write(\"\\3\\2\\2\\2\\31\\u009d\\3\\2\\2\\2\\33\\u009f\\3\\2\\2\\2\\35\\u00a2\\3\")\n\t        buf.write(\"\\2\\2\\2\\37\\u00a4\\3\\2\\2\\2!\\u00a6\\3\\2\\2\\2#\\u00a8\\3\\2\\2\\2\")\n", "        buf.write(\"%\\u00aa\\3\\2\\2\\2\\'\\u00ac\\3\\2\\2\\2)\\u00ae\\3\\2\\2\\2+\\u00b0\")\n\t        buf.write(\"\\3\\2\\2\\2-\\u00b2\\3\\2\\2\\2/\\u00b4\\3\\2\\2\\2\\61\\u00b7\\3\\2\\2\")\n\t        buf.write(\"\\2\\63\\u00b9\\3\\2\\2\\2\\65\\u00bc\\3\\2\\2\\2\\67\\u00bf\\3\\2\\2\\2\")\n\t        buf.write(\"9\\u00c2\\3\\2\\2\\2;\\u00cb\\3\\2\\2\\2=\\u00cf\\3\\2\\2\\2?\\u00d6\\3\")\n\t        buf.write(\"\\2\\2\\2A\\u00d9\\3\\2\\2\\2C\\u00de\\3\\2\\2\\2E\\u00e4\\3\\2\\2\\2G\\u00ea\")\n\t        buf.write(\"\\3\\2\\2\\2I\\u00f1\\3\\2\\2\\2K\\u00f7\\3\\2\\2\\2M\\u00fe\\3\\2\\2\\2\")\n\t        buf.write(\"O\\u0106\\3\\2\\2\\2Q\\u010e\\3\\2\\2\\2S\\u0116\\3\\2\\2\\2U\\u011a\\3\")\n\t        buf.write(\"\\2\\2\\2W\\u0121\\3\\2\\2\\2Y\\u0125\\3\\2\\2\\2[\\u0129\\3\\2\\2\\2]\\u0130\")\n\t        buf.write(\"\\3\\2\\2\\2_\\u0137\\3\\2\\2\\2a\\u013c\\3\\2\\2\\2c\\u0147\\3\\2\\2\\2\")\n\t        buf.write(\"e\\u0154\\3\\2\\2\\2g\\u0162\\3\\2\\2\\2i\\u016e\\3\\2\\2\\2k\\u0173\\3\")\n", "        buf.write(\"\\2\\2\\2m\\u0178\\3\\2\\2\\2o\\u017f\\3\\2\\2\\2q\\u0185\\3\\2\\2\\2s\\u018c\")\n\t        buf.write(\"\\3\\2\\2\\2u\\u0190\\3\\2\\2\\2w\\u0197\\3\\2\\2\\2y\\u01b2\\3\\2\\2\\2\")\n\t        buf.write(\"{\\u01bd\\3\\2\\2\\2}\\u01c5\\3\\2\\2\\2\\177\\u01cb\\3\\2\\2\\2\\u0081\")\n\t        buf.write(\"\\u01d3\\3\\2\\2\\2\\u0083\\u0084\\7(\\2\\2\\u0084\\4\\3\\2\\2\\2\\u0085\")\n\t        buf.write(\"\\u0086\\7~\\2\\2\\u0086\\6\\3\\2\\2\\2\\u0087\\u0088\\7#\\2\\2\\u0088\")\n\t        buf.write(\"\\b\\3\\2\\2\\2\\u0089\\u008a\\7?\\2\\2\\u008a\\u008b\\7?\\2\\2\\u008b\")\n\t        buf.write(\"\\n\\3\\2\\2\\2\\u008c\\u008d\\7#\\2\\2\\u008d\\u008e\\7?\\2\\2\\u008e\")\n\t        buf.write(\"\\f\\3\\2\\2\\2\\u008f\\u0090\\7>\\2\\2\\u0090\\u0091\\7?\\2\\2\\u0091\")\n\t        buf.write(\"\\16\\3\\2\\2\\2\\u0092\\u0093\\7@\\2\\2\\u0093\\u0094\\7?\\2\\2\\u0094\")\n\t        buf.write(\"\\20\\3\\2\\2\\2\\u0095\\u0096\\7>\\2\\2\\u0096\\22\\3\\2\\2\\2\\u0097\")\n", "        buf.write(\"\\u0098\\7@\\2\\2\\u0098\\24\\3\\2\\2\\2\\u0099\\u009a\\7-\\2\\2\\u009a\")\n\t        buf.write(\"\\26\\3\\2\\2\\2\\u009b\\u009c\\7/\\2\\2\\u009c\\30\\3\\2\\2\\2\\u009d\")\n\t        buf.write(\"\\u009e\\7\\61\\2\\2\\u009e\\32\\3\\2\\2\\2\\u009f\\u00a0\\7\\61\\2\\2\")\n\t        buf.write(\"\\u00a0\\u00a1\\7\\61\\2\\2\\u00a1\\34\\3\\2\\2\\2\\u00a2\\u00a3\\7,\")\n\t        buf.write(\"\\2\\2\\u00a3\\36\\3\\2\\2\\2\\u00a4\\u00a5\\7.\\2\\2\\u00a5 \\3\\2\\2\")\n\t        buf.write(\"\\2\\u00a6\\u00a7\\7=\\2\\2\\u00a7\\\"\\3\\2\\2\\2\\u00a8\\u00a9\\7*\\2\")\n\t        buf.write(\"\\2\\u00a9$\\3\\2\\2\\2\\u00aa\\u00ab\\7+\\2\\2\\u00ab&\\3\\2\\2\\2\\u00ac\")\n\t        buf.write(\"\\u00ad\\7}\\2\\2\\u00ad(\\3\\2\\2\\2\\u00ae\\u00af\\7\\177\\2\\2\\u00af\")\n\t        buf.write(\"*\\3\\2\\2\\2\\u00b0\\u00b1\\7]\\2\\2\\u00b1,\\3\\2\\2\\2\\u00b2\\u00b3\")\n\t        buf.write(\"\\7_\\2\\2\\u00b3.\\3\\2\\2\\2\\u00b4\\u00b5\\7-\\2\\2\\u00b5\\u00b6\")\n", "        buf.write(\"\\7?\\2\\2\\u00b6\\60\\3\\2\\2\\2\\u00b7\\u00b8\\7?\\2\\2\\u00b8\\62\\3\")\n\t        buf.write(\"\\2\\2\\2\\u00b9\\u00ba\\7/\\2\\2\\u00ba\\u00bb\\7?\\2\\2\\u00bb\\64\")\n\t        buf.write(\"\\3\\2\\2\\2\\u00bc\\u00bd\\7,\\2\\2\\u00bd\\u00be\\7?\\2\\2\\u00be\\66\")\n\t        buf.write(\"\\3\\2\\2\\2\\u00bf\\u00c0\\7\\61\\2\\2\\u00c0\\u00c1\\7?\\2\\2\\u00c1\")\n\t        buf.write(\"8\\3\\2\\2\\2\\u00c2\\u00c3\\7h\\2\\2\\u00c3\\u00c4\\7w\\2\\2\\u00c4\")\n\t        buf.write(\"\\u00c5\\7p\\2\\2\\u00c5\\u00c6\\7e\\2\\2\\u00c6\\u00c7\\7v\\2\\2\\u00c7\")\n\t        buf.write(\"\\u00c8\\7k\\2\\2\\u00c8\\u00c9\\7q\\2\\2\\u00c9\\u00ca\\7p\\2\\2\\u00ca\")\n\t        buf.write(\":\\3\\2\\2\\2\\u00cb\\u00cc\\7h\\2\\2\\u00cc\\u00cd\\7q\\2\\2\\u00cd\")\n\t        buf.write(\"\\u00ce\\7t\\2\\2\\u00ce<\\3\\2\\2\\2\\u00cf\\u00d0\\7t\\2\\2\\u00d0\")\n\t        buf.write(\"\\u00d1\\7g\\2\\2\\u00d1\\u00d2\\7v\\2\\2\\u00d2\\u00d3\\7w\\2\\2\\u00d3\")\n", "        buf.write(\"\\u00d4\\7t\\2\\2\\u00d4\\u00d5\\7p\\2\\2\\u00d5>\\3\\2\\2\\2\\u00d6\")\n\t        buf.write(\"\\u00d7\\7k\\2\\2\\u00d7\\u00d8\\7h\\2\\2\\u00d8@\\3\\2\\2\\2\\u00d9\")\n\t        buf.write(\"\\u00da\\7g\\2\\2\\u00da\\u00db\\7n\\2\\2\\u00db\\u00dc\\7u\\2\\2\\u00dc\")\n\t        buf.write(\"\\u00dd\\7g\\2\\2\\u00ddB\\3\\2\\2\\2\\u00de\\u00df\\7y\\2\\2\\u00df\")\n\t        buf.write(\"\\u00e0\\7j\\2\\2\\u00e0\\u00e1\\7k\\2\\2\\u00e1\\u00e2\\7n\\2\\2\\u00e2\")\n\t        buf.write(\"\\u00e3\\7g\\2\\2\\u00e3D\\3\\2\\2\\2\\u00e4\\u00e5\\7w\\2\\2\\u00e5\")\n\t        buf.write(\"\\u00e6\\7p\\2\\2\\u00e6\\u00e7\\7v\\2\\2\\u00e7\\u00e8\\7k\\2\\2\\u00e8\")\n\t        buf.write(\"\\u00e9\\7n\\2\\2\\u00e9F\\3\\2\\2\\2\\u00ea\\u00ee\\7%\\2\\2\\u00eb\")\n\t        buf.write(\"\\u00ed\\n\\2\\2\\2\\u00ec\\u00eb\\3\\2\\2\\2\\u00ed\\u00f0\\3\\2\\2\\2\")\n\t        buf.write(\"\\u00ee\\u00ec\\3\\2\\2\\2\\u00ee\\u00ef\\3\\2\\2\\2\\u00efH\\3\\2\\2\")\n", "        buf.write(\"\\2\\u00f0\\u00ee\\3\\2\\2\\2\\u00f1\\u00f2\\7r\\2\\2\\u00f2\\u00f3\")\n\t        buf.write(\"\\7t\\2\\2\\u00f3\\u00f4\\7k\\2\\2\\u00f4\\u00f5\\7p\\2\\2\\u00f5\\u00f6\")\n\t        buf.write(\"\\7v\\2\\2\\u00f6J\\3\\2\\2\\2\\u00f7\\u00f8\\7n\\2\\2\\u00f8\\u00f9\")\n\t        buf.write(\"\\7g\\2\\2\\u00f9\\u00fa\\7p\\2\\2\\u00fa\\u00fb\\7i\\2\\2\\u00fb\\u00fc\")\n\t        buf.write(\"\\7v\\2\\2\\u00fc\\u00fd\\7j\\2\\2\\u00fdL\\3\\2\\2\\2\\u00fe\\u00ff\")\n\t        buf.write(\"\\7t\\2\\2\\u00ff\\u0100\\7g\\2\\2\\u0100\\u0101\\7u\\2\\2\\u0101\\u0102\")\n\t        buf.write(\"\\7j\\2\\2\\u0102\\u0103\\7c\\2\\2\\u0103\\u0104\\7r\\2\\2\\u0104\\u0105\")\n\t        buf.write(\"\\7g\\2\\2\\u0105N\\3\\2\\2\\2\\u0106\\u0107\\7f\\2\\2\\u0107\\u0108\")\n\t        buf.write(\"\\7g\\2\\2\\u0108\\u0109\\7n\\2\\2\\u0109\\u010a\\7a\\2\\2\\u010a\\u010b\")\n\t        buf.write(\"\\7e\\2\\2\\u010b\\u010c\\7q\\2\\2\\u010c\\u010d\\7n\\2\\2\\u010dP\\3\")\n", "        buf.write(\"\\2\\2\\2\\u010e\\u010f\\7f\\2\\2\\u010f\\u0110\\7g\\2\\2\\u0110\\u0111\")\n\t        buf.write(\"\\7n\\2\\2\\u0111\\u0112\\7a\\2\\2\\u0112\\u0113\\7t\\2\\2\\u0113\\u0114\")\n\t        buf.write(\"\\7q\\2\\2\\u0114\\u0115\\7y\\2\\2\\u0115R\\3\\2\\2\\2\\u0116\\u0117\")\n\t        buf.write(\"\\7f\\2\\2\\u0117\\u0118\\7g\\2\\2\\u0118\\u0119\\7n\\2\\2\\u0119T\\3\")\n\t        buf.write(\"\\2\\2\\2\\u011a\\u011b\\7k\\2\\2\\u011b\\u011c\\7p\\2\\2\\u011c\\u011d\")\n\t        buf.write(\"\\7u\\2\\2\\u011d\\u011e\\7g\\2\\2\\u011e\\u011f\\7t\\2\\2\\u011f\\u0120\")\n\t        buf.write(\"\\7v\\2\\2\\u0120V\\3\\2\\2\\2\\u0121\\u0122\\7o\\2\\2\\u0122\\u0123\")\n\t        buf.write(\"\\7c\\2\\2\\u0123\\u0124\\7z\\2\\2\\u0124X\\3\\2\\2\\2\\u0125\\u0126\")\n\t        buf.write(\"\\7o\\2\\2\\u0126\\u0127\\7k\\2\\2\\u0127\\u0128\\7p\\2\\2\\u0128Z\\3\")\n\t        buf.write(\"\\2\\2\\2\\u0129\\u012a\\7o\\2\\2\\u012a\\u012b\\7c\\2\\2\\u012b\\u012c\")\n", "        buf.write(\"\\7z\\2\\2\\u012c\\u012d\\7n\\2\\2\\u012d\\u012e\\7g\\2\\2\\u012e\\u012f\")\n\t        buf.write(\"\\7p\\2\\2\\u012f\\\\\\3\\2\\2\\2\\u0130\\u0131\\7o\\2\\2\\u0131\\u0132\")\n\t        buf.write(\"\\7k\\2\\2\\u0132\\u0133\\7p\\2\\2\\u0133\\u0134\\7n\\2\\2\\u0134\\u0135\")\n\t        buf.write(\"\\7g\\2\\2\\u0135\\u0136\\7p\\2\\2\\u0136^\\3\\2\\2\\2\\u0137\\u0138\")\n\t        buf.write(\"\\7h\\2\\2\\u0138\\u0139\\7k\\2\\2\\u0139\\u013a\\7p\\2\\2\\u013a\\u013b\")\n\t        buf.write(\"\\7f\\2\\2\\u013b`\\3\\2\\2\\2\\u013c\\u013d\\7e\\2\\2\\u013d\\u013e\")\n\t        buf.write(\"\\7t\\2\\2\\u013e\\u013f\\7g\\2\\2\\u013f\\u0140\\7c\\2\\2\\u0140\\u0141\")\n\t        buf.write(\"\\7v\\2\\2\\u0141\\u0142\\7g\\2\\2\\u0142\\u0143\\7a\\2\\2\\u0143\\u0144\")\n\t        buf.write(\"\\7t\\2\\2\\u0144\\u0145\\7q\\2\\2\\u0145\\u0146\\7y\\2\\2\\u0146b\\3\")\n\t        buf.write(\"\\2\\2\\2\\u0147\\u0148\\7e\\2\\2\\u0148\\u0149\\7t\\2\\2\\u0149\\u014a\")\n", "        buf.write(\"\\7g\\2\\2\\u014a\\u014b\\7c\\2\\2\\u014b\\u014c\\7v\\2\\2\\u014c\\u014d\")\n\t        buf.write(\"\\7g\\2\\2\\u014d\\u014e\\7a\\2\\2\\u014e\\u014f\\7v\\2\\2\\u014f\\u0150\")\n\t        buf.write(\"\\7c\\2\\2\\u0150\\u0151\\7d\\2\\2\\u0151\\u0152\\7n\\2\\2\\u0152\\u0153\")\n\t        buf.write(\"\\7g\\2\\2\\u0153d\\3\\2\\2\\2\\u0154\\u0155\\7e\\2\\2\\u0155\\u0156\")\n\t        buf.write(\"\\7t\\2\\2\\u0156\\u0157\\7g\\2\\2\\u0157\\u0158\\7c\\2\\2\\u0158\\u0159\")\n\t        buf.write(\"\\7v\\2\\2\\u0159\\u015a\\7g\\2\\2\\u015a\\u015b\\7a\\2\\2\\u015b\\u015c\")\n\t        buf.write(\"\\7e\\2\\2\\u015c\\u015d\\7q\\2\\2\\u015d\\u015e\\7n\\2\\2\\u015e\\u015f\")\n\t        buf.write(\"\\7w\\2\\2\\u015f\\u0160\\7o\\2\\2\\u0160\\u0161\\7p\\2\\2\\u0161f\\3\")\n\t        buf.write(\"\\2\\2\\2\\u0162\\u0163\\7t\\2\\2\\u0163\\u0164\\7g\\2\\2\\u0164\\u0165\")\n\t        buf.write(\"\\7c\\2\\2\\u0165\\u0166\\7f\\2\\2\\u0166\\u0167\\7a\\2\\2\\u0167\\u0168\")\n", "        buf.write(\"\\7u\\2\\2\\u0168\\u0169\\7v\\2\\2\\u0169\\u016a\\7t\\2\\2\\u016a\\u016b\")\n\t        buf.write(\"\\7k\\2\\2\\u016b\\u016c\\7p\\2\\2\\u016c\\u016d\\7i\\2\\2\\u016dh\\3\")\n\t        buf.write(\"\\2\\2\\2\\u016e\\u016f\\7e\\2\\2\\u016f\\u0170\\7q\\2\\2\\u0170\\u0171\")\n\t        buf.write(\"\\7r\\2\\2\\u0171\\u0172\\7{\\2\\2\\u0172j\\3\\2\\2\\2\\u0173\\u0174\")\n\t        buf.write(\"\\7p\\2\\2\\u0174\\u0175\\7w\\2\\2\\u0175\\u0176\\7o\\2\\2\\u0176\\u0177\")\n\t        buf.write(\"\\7d\\2\\2\\u0177l\\3\\2\\2\\2\\u0178\\u0179\\7u\\2\\2\\u0179\\u017a\")\n\t        buf.write(\"\\7v\\2\\2\\u017a\\u017b\\7t\\2\\2\\u017b\\u017c\\7k\\2\\2\\u017c\\u017d\")\n\t        buf.write(\"\\7p\\2\\2\\u017d\\u017e\\7i\\2\\2\\u017en\\3\\2\\2\\2\\u017f\\u0180\")\n\t        buf.write(\"\\7v\\2\\2\\u0180\\u0181\\7c\\2\\2\\u0181\\u0182\\7d\\2\\2\\u0182\\u0183\")\n\t        buf.write(\"\\7n\\2\\2\\u0183\\u0184\\7g\\2\\2\\u0184p\\3\\2\\2\\2\\u0185\\u0186\")\n", "        buf.write(\"\\7e\\2\\2\\u0186\\u0187\\7q\\2\\2\\u0187\\u0188\\7n\\2\\2\\u0188\\u0189\")\n\t        buf.write(\"\\7w\\2\\2\\u0189\\u018a\\7o\\2\\2\\u018a\\u018b\\7p\\2\\2\\u018br\\3\")\n\t        buf.write(\"\\2\\2\\2\\u018c\\u018d\\7t\\2\\2\\u018d\\u018e\\7q\\2\\2\\u018e\\u018f\")\n\t        buf.write(\"\\7y\\2\\2\\u018ft\\3\\2\\2\\2\\u0190\\u0191\\7x\\2\\2\\u0191\\u0192\")\n\t        buf.write(\"\\7q\\2\\2\\u0192\\u0193\\7k\\2\\2\\u0193\\u0194\\7f\\2\\2\\u0194v\\3\")\n\t        buf.write(\"\\2\\2\\2\\u0195\\u0198\\5\\25\\13\\2\\u0196\\u0198\\5\\27\\f\\2\\u0197\")\n\t        buf.write(\"\\u0195\\3\\2\\2\\2\\u0197\\u0196\\3\\2\\2\\2\\u0197\\u0198\\3\\2\\2\\2\")\n\t        buf.write(\"\\u0198\\u019a\\3\\2\\2\\2\\u0199\\u019b\\t\\3\\2\\2\\u019a\\u0199\\3\")\n\t        buf.write(\"\\2\\2\\2\\u019b\\u019c\\3\\2\\2\\2\\u019c\\u019a\\3\\2\\2\\2\\u019c\\u019d\")\n\t        buf.write(\"\\3\\2\\2\\2\\u019d\\u01a4\\3\\2\\2\\2\\u019e\\u01a0\\7\\60\\2\\2\\u019f\")\n", "        buf.write(\"\\u01a1\\t\\3\\2\\2\\u01a0\\u019f\\3\\2\\2\\2\\u01a1\\u01a2\\3\\2\\2\\2\")\n\t        buf.write(\"\\u01a2\\u01a0\\3\\2\\2\\2\\u01a2\\u01a3\\3\\2\\2\\2\\u01a3\\u01a5\\3\")\n\t        buf.write(\"\\2\\2\\2\\u01a4\\u019e\\3\\2\\2\\2\\u01a4\\u01a5\\3\\2\\2\\2\\u01a5\\u01b0\")\n\t        buf.write(\"\\3\\2\\2\\2\\u01a6\\u01a9\\t\\4\\2\\2\\u01a7\\u01aa\\5\\25\\13\\2\\u01a8\")\n\t        buf.write(\"\\u01aa\\5\\27\\f\\2\\u01a9\\u01a7\\3\\2\\2\\2\\u01a9\\u01a8\\3\\2\\2\")\n\t        buf.write(\"\\2\\u01a9\\u01aa\\3\\2\\2\\2\\u01aa\\u01ac\\3\\2\\2\\2\\u01ab\\u01ad\")\n\t        buf.write(\"\\t\\3\\2\\2\\u01ac\\u01ab\\3\\2\\2\\2\\u01ad\\u01ae\\3\\2\\2\\2\\u01ae\")\n\t        buf.write(\"\\u01ac\\3\\2\\2\\2\\u01ae\\u01af\\3\\2\\2\\2\\u01af\\u01b1\\3\\2\\2\\2\")\n\t        buf.write(\"\\u01b0\\u01a6\\3\\2\\2\\2\\u01b0\\u01b1\\3\\2\\2\\2\\u01b1x\\3\\2\\2\")\n\t        buf.write(\"\\2\\u01b2\\u01b8\\7$\\2\\2\\u01b3\\u01b7\\n\\5\\2\\2\\u01b4\\u01b5\")\n", "        buf.write(\"\\7^\\2\\2\\u01b5\\u01b7\\13\\2\\2\\2\\u01b6\\u01b3\\3\\2\\2\\2\\u01b6\")\n\t        buf.write(\"\\u01b4\\3\\2\\2\\2\\u01b7\\u01ba\\3\\2\\2\\2\\u01b8\\u01b6\\3\\2\\2\\2\")\n\t        buf.write(\"\\u01b8\\u01b9\\3\\2\\2\\2\\u01b9\\u01bb\\3\\2\\2\\2\\u01ba\\u01b8\\3\")\n\t        buf.write(\"\\2\\2\\2\\u01bb\\u01bc\\7$\\2\\2\\u01bcz\\3\\2\\2\\2\\u01bd\\u01c1\\t\")\n\t        buf.write(\"\\6\\2\\2\\u01be\\u01c0\\t\\7\\2\\2\\u01bf\\u01be\\3\\2\\2\\2\\u01c0\\u01c3\")\n\t        buf.write(\"\\3\\2\\2\\2\\u01c1\\u01bf\\3\\2\\2\\2\\u01c1\\u01c2\\3\\2\\2\\2\\u01c2\")\n\t        buf.write(\"|\\3\\2\\2\\2\\u01c3\\u01c1\\3\\2\\2\\2\\u01c4\\u01c6\\t\\b\\2\\2\\u01c5\")\n\t        buf.write(\"\\u01c4\\3\\2\\2\\2\\u01c6\\u01c7\\3\\2\\2\\2\\u01c7\\u01c5\\3\\2\\2\\2\")\n\t        buf.write(\"\\u01c7\\u01c8\\3\\2\\2\\2\\u01c8\\u01c9\\3\\2\\2\\2\\u01c9\\u01ca\\b\")\n\t        buf.write(\"?\\2\\2\\u01ca~\\3\\2\\2\\2\\u01cb\\u01cc\\7e\\2\\2\\u01cc\\u01cd\\7\")\n", "        buf.write(\"q\\2\\2\\u01cd\\u01ce\\7p\\2\\2\\u01ce\\u01cf\\7u\\2\\2\\u01cf\\u01d0\")\n\t        buf.write(\"\\7v\\2\\2\\u01d0\\u01d1\\3\\2\\2\\2\\u01d1\\u01d2\\5w<\\2\\u01d2\\u0080\")\n\t        buf.write(\"\\3\\2\\2\\2\\u01d3\\u01d4\\7e\\2\\2\\u01d4\\u01d5\\7q\\2\\2\\u01d5\\u01d6\")\n\t        buf.write(\"\\7p\\2\\2\\u01d6\\u01d7\\7u\\2\\2\\u01d7\\u01d8\\7v\\2\\2\\u01d8\\u01d9\")\n\t        buf.write(\"\\3\\2\\2\\2\\u01d9\\u01da\\5y=\\2\\u01da\\u0082\\3\\2\\2\\2\\17\\2\\u00ee\")\n\t        buf.write(\"\\u0197\\u019c\\u01a2\\u01a4\\u01a9\\u01ae\\u01b0\\u01b6\\u01b8\")\n\t        buf.write(\"\\u01c1\\u01c7\\3\\b\\2\\2\")\n\t        return buf.getvalue()\n\tclass LangLexer(Lexer):\n\t    atn = ATNDeserializer().deserialize(serializedATN())\n", "    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]\n\t    AND = 1\n\t    OR = 2\n\t    NOT = 3\n\t    EQUAL = 4\n\t    NOT_EQUAL = 5\n\t    LESS_EQUAL = 6\n\t    GREATER_EQUAL = 7\n\t    LESS = 8\n\t    GREATER = 9\n", "    PLUS = 10\n\t    MINUS = 11\n\t    DIV = 12\n\t    FULL_DIV = 13\n\t    MULT = 14\n\t    COMMA = 15\n\t    SEMI = 16\n\t    LPAREN = 17\n\t    RPAREN = 18\n\t    LCURLY = 19\n", "    RCURLY = 20\n\t    L_SQBRACK = 21\n\t    P_SQBRACK = 22\n\t    PLUS_EQUAL = 23\n\t    ASSIGN = 24\n\t    MINUS_EQUAL = 25\n\t    MULT_EQUAL = 26\n\t    DIV_EQUAL = 27\n\t    FUNCTION = 28\n\t    FOR = 29\n", "    RETURN = 30\n\t    IF = 31\n\t    ELSE = 32\n\t    WHILE = 33\n\t    UNTIL = 34\n\t    COMMENT = 35\n\t    PRINT = 36\n\t    LENGTH = 37\n\t    RESHAPE = 38\n\t    DEL_COL = 39\n", "    DEL_ROW = 40\n\t    DEL = 41\n\t    INSERT = 42\n\t    MAX = 43\n\t    MIN = 44\n\t    MAXLEN = 45\n\t    MINLEN = 46\n\t    FIND = 47\n\t    CREATE_ROW = 48\n\t    CREATE_TABLE = 49\n", "    CREATE_COL = 50\n\t    READ_STRING = 51\n\t    COPY = 52\n\t    NUMBER_type = 53\n\t    STRING_type = 54\n\t    TABLE = 55\n\t    COLUMN = 56\n\t    ROW = 57\n\t    VOID = 58\n\t    NUMBER = 59\n", "    STRING = 60\n\t    ID = 61\n\t    WS = 62\n\t    CONST_NUMBER = 63\n\t    CONST_STRING = 64\n\t    channelNames = [ u\"DEFAULT_TOKEN_CHANNEL\", u\"HIDDEN\" ]\n\t    modeNames = [ \"DEFAULT_MODE\" ]\n\t    literalNames = [ \"<INVALID>\",\n\t            \"'&'\", \"'|'\", \"'!'\", \"'=='\", \"'!='\", \"'<='\", \"'>='\", \"'<'\", \n\t            \"'>'\", \"'+'\", \"'-'\", \"'/'\", \"'//'\", \"'*'\", \"','\", \"';'\", \"'('\", \n", "            \"')'\", \"'{'\", \"'}'\", \"'['\", \"']'\", \"'+='\", \"'='\", \"'-='\", \"'*='\", \n\t            \"'/='\", \"'function'\", \"'for'\", \"'return'\", \"'if'\", \"'else'\", \n\t            \"'while'\", \"'until'\", \"'print'\", \"'length'\", \"'reshape'\", \"'del_col'\", \n\t            \"'del_row'\", \"'del'\", \"'insert'\", \"'max'\", \"'min'\", \"'maxlen'\", \n\t            \"'minlen'\", \"'find'\", \"'create_row'\", \"'create_table'\", \"'create_column'\", \n\t            \"'read_string'\", \"'copy'\", \"'numb'\", \"'string'\", \"'table'\", \n\t            \"'column'\", \"'row'\", \"'void'\" ]\n\t    symbolicNames = [ \"<INVALID>\",\n\t            \"AND\", \"OR\", \"NOT\", \"EQUAL\", \"NOT_EQUAL\", \"LESS_EQUAL\", \"GREATER_EQUAL\", \n\t            \"LESS\", \"GREATER\", \"PLUS\", \"MINUS\", \"DIV\", \"FULL_DIV\", \"MULT\", \n", "            \"COMMA\", \"SEMI\", \"LPAREN\", \"RPAREN\", \"LCURLY\", \"RCURLY\", \"L_SQBRACK\", \n\t            \"P_SQBRACK\", \"PLUS_EQUAL\", \"ASSIGN\", \"MINUS_EQUAL\", \"MULT_EQUAL\", \n\t            \"DIV_EQUAL\", \"FUNCTION\", \"FOR\", \"RETURN\", \"IF\", \"ELSE\", \"WHILE\", \n\t            \"UNTIL\", \"COMMENT\", \"PRINT\", \"LENGTH\", \"RESHAPE\", \"DEL_COL\", \n\t            \"DEL_ROW\", \"DEL\", \"INSERT\", \"MAX\", \"MIN\", \"MAXLEN\", \"MINLEN\", \n\t            \"FIND\", \"CREATE_ROW\", \"CREATE_TABLE\", \"CREATE_COL\", \"READ_STRING\", \n\t            \"COPY\", \"NUMBER_type\", \"STRING_type\", \"TABLE\", \"COLUMN\", \"ROW\", \n\t            \"VOID\", \"NUMBER\", \"STRING\", \"ID\", \"WS\", \"CONST_NUMBER\", \"CONST_STRING\" ]\n\t    ruleNames = [ \"AND\", \"OR\", \"NOT\", \"EQUAL\", \"NOT_EQUAL\", \"LESS_EQUAL\", \n\t                  \"GREATER_EQUAL\", \"LESS\", \"GREATER\", \"PLUS\", \"MINUS\", \"DIV\", \n", "                  \"FULL_DIV\", \"MULT\", \"COMMA\", \"SEMI\", \"LPAREN\", \"RPAREN\", \n\t                  \"LCURLY\", \"RCURLY\", \"L_SQBRACK\", \"P_SQBRACK\", \"PLUS_EQUAL\", \n\t                  \"ASSIGN\", \"MINUS_EQUAL\", \"MULT_EQUAL\", \"DIV_EQUAL\", \"FUNCTION\", \n\t                  \"FOR\", \"RETURN\", \"IF\", \"ELSE\", \"WHILE\", \"UNTIL\", \"COMMENT\", \n\t                  \"PRINT\", \"LENGTH\", \"RESHAPE\", \"DEL_COL\", \"DEL_ROW\", \"DEL\", \n\t                  \"INSERT\", \"MAX\", \"MIN\", \"MAXLEN\", \"MINLEN\", \"FIND\", \"CREATE_ROW\", \n\t                  \"CREATE_TABLE\", \"CREATE_COL\", \"READ_STRING\", \"COPY\", \"NUMBER_type\", \n\t                  \"STRING_type\", \"TABLE\", \"COLUMN\", \"ROW\", \"VOID\", \"NUMBER\", \n\t                  \"STRING\", \"ID\", \"WS\", \"CONST_NUMBER\", \"CONST_STRING\" ]\n\t    grammarFileName = \"LangLexer.g4\"\n", "    def __init__(self, input=None, output:TextIO = sys.stdout):\n\t        super().__init__(input, output)\n\t        self.checkVersion(\"4.7.2\")\n\t        self._interp = LexerATNSimulator(self, self.atn, self.decisionsToDFA, PredictionContextCache())\n\t        self._actions = None\n\t        self._predicates = None\n"]}
{"filename": "parser/LangParserListener.py", "chunked_list": ["# Generated from LangParser.g4 by ANTLR 4.7.2\n\tfrom antlr4 import *\n\tif __name__ is not None and \".\" in __name__:\n\t    from .LangParser import LangParser\n\telse:\n\t    from LangParser import LangParser\n\tfrom src.compilers import ProgramCompiler\n\tfrom src.variables import *\n\tclass SemanticAnalyzerException(Exception):\n\t    def __init__(self, *args: object) -> None:\n", "        super().__init__(*args)\n\tdef get_dict(params: list, out_type: str, func_local_vars: list = None):\n\t    if func_local_vars is None:\n\t        return {\"params\": params, \"return_type\": out_type}\n\t    return {\"params\": params, \"return_type\": out_type, \"local_vars\": func_local_vars}\n\t# This class defines a complete listener for a parse tree produced by LangParser.\n\tclass LangParserListener(ParseTreeListener):\n\t    global_vars = {}\n\t    function_vars = {\n\t        # built-in functions\n", "        # output is a number == it depends on {number} param\n\t        \"print\": get_dict([\"table/row/column/string/numb\"], \"void\"),\n\t        \"length\": get_dict([\"table/row/column\"], \"numb\"),\n\t        \"reshape\": get_dict([\"table\", \"numb\", \"numb\"], \"table\"),\n\t        \"del\": get_dict([\"row/column\", \"numb\"], \"0\"),\n\t        \"insert\": get_dict([\"column/row\", \"string/numb\", \"numb\"], \"0\"),\n\t        \"max\": get_dict([\"table/row/column\"], \"numb\"),\n\t        \"min\": get_dict([\"table/row/column\"], \"numb\"),\n\t        \"maxlen\": get_dict([\"table/row/column\"], \"string\"),\n\t        \"minlen\": get_dict([\"table/row/column\"], \"string\"),\n", "        \"find\": get_dict([\"table/row/column\", \"string/numb\"], \"numb\"),\n\t        \"create_row\": get_dict([\"numb\", \"list\"], \"row\"),\n\t        \"create_column\": get_dict([\"numb\", \"list\"], \"column\"),\n\t        \"create_table\": get_dict([\"numb\", \"numb\", \"list\"], \"table\"),\n\t        \"read_string\": get_dict([], \"string\"),\n\t        \"copy\": get_dict([\"table/row/column/string/numb\"], \"0\")\n\t    }\n\t    available_operands = {\n\t        # bool operators\n\t        \"==\": (\"numb\", \"string\", \"column\", \"row\", \"table\"),\n", "        \"!=\": (\"numb\", \"string\", \"column\", \"row\", \"table\"),\n\t        \"<=\": (\"numb\", \"string\", \"column\", \"row\"),\n\t        \">=\": (\"numb\", \"string\", \"column\", \"row\"),\n\t        \"<\": (\"numb\", \"string\", \"column\", \"row\"),\n\t        \">\": (\"numb\", \"string\", \"column\", \"row\"),\n\t        \"&\": (\"numb\"),\n\t        \"|\": (\"numb\"),\n\t        \"!\": (\"numb\"),\n\t        # number operators\n\t        \"+\": (\"numb\", \"string\", \"column\", \"row\", \"table\"),\n", "        \"-\": (\"numb\"),\n\t        \"/\": (\"numb\", \"column\", \"row\", \"table\"),\n\t        \"//\": (\"numb\", \"table\"),\n\t        \"*\": (\"numb\", \"table\")\n\t    }\n\t    # Enter a parse tree produced by LangParser#program.\n\t    def enterProgram(self, ctx: LangParser.ProgramContext):\n\t        # function vars\n\t        self.is_func_init = False\n\t        self.main_func_started = False\n", "        self.local_func_vars = {}\n\t        self.local_func_params = {}\n\t        self.local_func_name = None\n\t        # for vars\n\t        self.all_for_vars = {}\n\t        self.for_stat_init = False\n\t        # while vars\n\t        self.local_while_vars = {}\n\t        # until vars\n\t        self.local_until_vars = {}\n", "        # if else vars\n\t        self.local_ifels_vars = {}\n\t        # init program compiler\n\t        self.program_compiler = ProgramCompiler()\n\t    # Exit a parse tree produced by LangParser#program.\n\t    def exitProgram(self, ctx: LangParser.ProgramContext):\n\t        # print(self.function_vars)\n\t        # print(self.global_vars)\n\t        self.program_compiler.finish_compiling()\n\t    # Enter a parse tree produced by LangParser#func.\n", "    def enterFunc(self, ctx: LangParser.FuncContext):\n\t        self.is_func_return_smth = False\n\t    def clear_func_cache(self):\n\t        if self.is_func_init:\n\t            self.function_vars.pop(self.local_func_name)\n\t        for key in self.local_func_vars:\n\t            self.global_vars.pop(key)\n\t    # Exit a parse tree produced by LangParser#func.\n\t    def exitFunc(self, ctx: LangParser.FuncContext):\n\t        if not self.is_func_init:\n", "            self.checkAndInitUserFunc(ctx)\n\t        if not self.is_func_return_smth and self.local_func_params.get('return_type') != 'void':\n\t            raise SemanticAnalyzerException(\n\t                f\"Function doesn't return {self.local_func_params.get('return_type')} value.\")\n\t        if self.is_func_return_smth and self.local_func_params.get('return_type') == 'void':\n\t            raise SemanticAnalyzerException(f\"Void function returns value\")\n\t        for func_param in self.local_func_vars:\n\t            self.global_vars.pop(func_param)\n\t        self.is_func_init = False\n\t        if self.program_compiler.local_function is not None:\n", "            self.program_compiler.end_local_func()\n\t    def checkAndInitUserFunc(self, ctx: LangParser.FuncContext):\n\t        func_type = str(ctx.children[0].children[0]) if str(\n\t            ctx.children[0]) != 'void' else 'void'\n\t        func_name = str(ctx.ID(0))\n\t        self.local_func_name = func_name\n\t        func_params = list(map(str, ctx.ID()[1:]))\n\t        func_params_types = list(map(lambda ctx: str(\n\t            ctx.children[0]), ctx.basicTypeName()[int(func_type != 'void'):]))\n\t        self.program_compiler.start_local_func(\n", "            func_name, func_type, func_params_types)\n\t        if self.function_vars.get(func_name) is not None and self.function_vars.get(func_name).get(\"params\") == func_params_types and\\\n\t                func_type == self.function_vars.get(func_name).get(\"return_type\"):\n\t            raise SemanticAnalyzerException(\n\t                f\"Function {func_name} with such params is already defined\")\n\t        if len(func_params) != len(func_params_types):\n\t            raise SemanticAnalyzerException(\n\t                \"Check params number and number of their types\")\n\t        for func_index, func_param in enumerate(func_params):\n\t            if self.local_func_vars.get(func_param) is not None:\n", "                raise SemanticAnalyzerException(\n\t                    f\"Function parameter {func_param} is already defined\")\n\t            self.local_func_vars[func_param] = func_params_types[func_index]\n\t            self.addNewVariable(\n\t                func_param, func_params_types[func_index], self.program_compiler.local_func_args[func_index])\n\t        self.function_vars[func_name] = self.local_func_params = get_dict(\n\t            func_params_types, func_type, func_params)\n\t        self.is_func_init = True\n\t    # Enter a parse tree produced by LangParser#stat.\n\t    def enterStat(self, ctx: LangParser.StatContext):\n", "        if self.program_compiler.local_function is None and not self.program_compiler.is_main_function_started():\n\t            self.program_compiler.start_main_func()\n\t        self.main_func_started = True\n\t    # Exit a parse tree produced by LangParser#stat.\n\t    def exitStat(self, ctx: LangParser.StatContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#funcStat.\n\t    def enterFuncStat(self, ctx: LangParser.FuncStatContext):\n\t        if isinstance(ctx.parentCtx, LangParser.ForStatContext):\n\t            self.initUserForLocSpace(ctx.parentCtx)\n", "        if not self.is_func_init and isinstance(ctx.parentCtx, LangParser.FuncContext):\n\t            self.checkAndInitUserFunc(ctx.parentCtx)\n\t    def initUserForLocSpace(self, ctx: LangParser.ForStatContext):\n\t        if ctx.assignExpr() and ctx.assignExpr().basicTypeName():\n\t            ass_ctxt = ctx.assignExpr()\n\t            type_ = str(ass_ctxt.basicTypeName().children[0])\n\t            vars_ = list(map(str, ass_ctxt.ID()))\n\t            for_vars = self.all_for_vars.get(\"for_local\")\n\t            if for_vars:\n\t                while for_vars.get(\"for_local\"):\n", "                    for_vars = for_vars.get(\"for_local\")\n\t            else:\n\t                for_vars = self.all_for_vars\n\t            for var in vars_:\n\t                for_vars[var] = [type_, False]\n\t    # Exit a parse tree produced by LangParser#funcStat.\n\t    def exitFuncStat(self, ctx: LangParser.FuncStatContext):\n\t        if ctx.returnStmt() and not self.is_func_init:\n\t            raise SemanticAnalyzerException(\n\t                \"Cannot return value outside function space\")\n", "        elif ctx.returnStmt():\n\t            self.is_func_return_smth = True\n\t            return_type = self.findExpressionOutType(\n\t                ctx.returnStmt().numbExpr())\n\t            if return_type != self.local_func_params.get('return_type'):\n\t                raise SemanticAnalyzerException(\n\t                    f\"{self.local_func_params.get('return_type')} function returns {return_type} object\")\n\t            self.program_compiler.end_local_func(\n\t                self.findNumbExprResult(ctx.returnStmt().numbExpr()))\n\t        elif ctx.stat() and ((ctx.stat().assignExpr() and ctx.stat().assignExpr().basicTypeName()) or ctx.stat().varDeclStmt() is not None):\n", "            ass_ctxt = ctx.stat().assignExpr() if ctx.stat(\n\t            ).assignExpr() else ctx.stat().varDeclStmt()\n\t            if ass_ctxt.basicTypeName() is None:\n\t                return\n\t            _type = str(ass_ctxt.basicTypeName().children[0])\n\t            if isinstance(ctx.parentCtx, LangParser.FuncContext):\n\t                for id in ass_ctxt.ID():\n\t                    self.local_func_vars[str(id)] = (_type, False)\n\t            elif isinstance(ctx.parentCtx, LangParser.ForStatContext):\n\t                for_vars = self.all_for_vars.get(\"for_local\")\n", "                if for_vars:\n\t                    while for_vars:\n\t                        for_vars = for_vars.get(\"for_local\")\n\t                else:\n\t                    for_vars = self.all_for_vars\n\t                for id in ass_ctxt.ID():\n\t                    for_vars[str(id)] = (_type, False)\n\t            elif isinstance(ctx.parentCtx, LangParser.UntilStmtContext):\n\t                until_vars = self.local_until_vars.get(\"until_local\")\n\t                while until_vars:\n", "                    until_vars = until_vars.get(\"until_local\")\n\t                for id in ass_ctxt.ID():\n\t                    until_vars[str(id)] = (_type, False)\n\t            elif isinstance(ctx.parentCtx, LangParser.WhileStmtContext):\n\t                while_vars = self.local_while_vars.get(\"while_local\")\n\t                while while_vars:\n\t                    while_vars = while_vars.get(\"while_local\")\n\t                for id in ass_ctxt.ID():\n\t                    while_vars[str(id)] = (_type, False)\n\t            elif isinstance(ctx.parentCtx, LangParser.IfElseStmtContext):\n", "                ifels_vars = self.local_ifels_vars.get(\"ifels_local\")\n\t                while ifels_vars:\n\t                    ifels_vars = ifels_vars.get(\"ifels_local\")\n\t                for id in ass_ctxt.ID():\n\t                    ifels_vars[str(id)] = (_type, False)\n\t    # Enter a parse tree produced by LangParser#forStat.\n\t    def enterForStat(self, ctx: LangParser.ForStatContext):\n\t        if isinstance(ctx.parentCtx.parentCtx, LangParser.FuncStatContext):\n\t            self.all_for_vars = {}\n\t        elif isinstance(ctx.parentCtx.parentCtx, LangParser.ProgramContext):\n", "            self.all_for_vars[\"for_local\"] = {}\n\t    # Exit a parse tree produced by LangParser#forStat.\n\t    def exitForStat(self, ctx: LangParser.ForStatContext):\n\t        for_vars_space = self.all_for_vars.get(\"for_local\")\n\t        if for_vars_space:\n\t            while for_vars_space.get(\"for_local\"):\n\t                for_vars_space = for_vars_space.get(\"for_local\")\n\t        else:\n\t            for_vars_space = self.all_for_vars\n\t        for local_var in for_vars_space:\n", "            self.global_vars.pop(local_var)\n\t        # delete\n\t        if not self.all_for_vars.get(\"for_local\"):\n\t            self.all_for_vars = {}\n\t        else:\n\t            tmp = self.all_for_vars\n\t            while tmp.get(\"for_local\").get(\"for_local\"):\n\t                tmp = tmp.get(\"for_local\")\n\t            tmp.pop(\"for_local\")\n\t    # Enter a parse tree produced by LangParser#assignExpr.\n", "    def enterAssignExpr(self, ctx: LangParser.AssignExprContext):\n\t        pass\n\t    def findVarType(self, ctx: LangParser.BasicTypeContext | LangParser.IterBasicTypeContext | str) -> str:\n\t        if isinstance(ctx, str) or ctx.ID():\n\t            str_id = str(ctx.ID()) if not isinstance(ctx, str) else ctx\n\t            if self.global_vars.get(str_id) is None:\n\t                raise SemanticAnalyzerException(\"Variable {} is not defined\".format(str_id))\n\t            var_obj = self.global_vars.get(str_id)\n\t            if isinstance(var_obj, NumbVariable):\n\t                var_type = 'numb'\n", "            elif isinstance(var_obj, StringVariable):\n\t                var_type = 'string'\n\t            elif isinstance(var_obj, ColumnVariable):\n\t                var_type = 'column'\n\t            elif isinstance(var_obj, RowVariable):\n\t                var_type = 'row'\n\t            elif isinstance(var_obj, TableVariable):\n\t                var_type = 'table'\n\t            else:\n\t                raise TypeError(\"Bro here is unknown object -- {} | {}\".format(type(var_obj), str_id))\n", "            return var_type, False\n\t        elif isinstance(ctx, LangParser.BasicTypeContext) and ctx.NUMBER():\n\t            return 'numb', False\n\t        elif isinstance(ctx, LangParser.BasicTypeContext) and ctx.STRING():\n\t            return 'string', False\n\t        else:\n\t            raise SemanticAnalyzerException(\n\t                \"Incorrect expression construction - {}\".format(str(ctx.children[0])))\n\t    def findBuiltinFunctionType(self, ctx: LangParser.BuiltinFuncStmtContext) -> tuple[str, str]:\n\t        function_ctxt = ctx.children[0]\n", "        func_return_type, func_name = None, None\n\t        func_name = str(function_ctxt.children[0])\n\t        if isinstance(function_ctxt, LangParser.CustFuncCallContext):\n\t            find_name = self.function_vars.get(func_name)\n\t            if find_name is None:\n\t                raise SemanticAnalyzerException(\n\t                    f\"Function {func_name} is not found\")\n\t            func_return_type = find_name.get(\"return_type\")\n\t        elif isinstance(function_ctxt, LangParser.InsertStmtContext):\n\t            first_param = function_ctxt.numbExpr(0)\n", "            func_return_type = self.findExpressionOutType(first_param)\n\t        elif isinstance(function_ctxt, LangParser.CopyStmtContext):\n\t            func_return_type = self.findVarType(str(function_ctxt.ID()))[0]\n\t        elif (isinstance(function_ctxt, LangParser.DelFuncStmtContext) and function_ctxt.delFunc().DEL() is not None):\n\t            first_param = function_ctxt.numbExpr(0)\n\t            func_return_type = self.findExpressionOutType(first_param)\n\t        elif isinstance(function_ctxt, LangParser.MinMaxFuncStmtContext):\n\t            func_name = str(function_ctxt.minMaxFunc().children[0])\n\t            func_return_type = self.function_vars.get(\n\t                func_name).get(\"return_type\")\n", "        elif isinstance(function_ctxt, LangParser.DelFuncStmtContext):\n\t            func_name = str(function_ctxt.delFunc().children[0])\n\t            func_return_type = self.function_vars.get(\n\t                func_name).get(\"return_type\")\n\t        else:\n\t            func_return_type = self.function_vars.get(\n\t                func_name).get(\"return_type\")\n\t        if isinstance(function_ctxt, LangParser.DelFuncStmtContext):\n\t            func_name = str(function_ctxt.delFunc().children[0])\n\t        return func_return_type, func_name\n", "    def findIndexStmtType(self, ctx: LangParser.IndexStmtContext) -> str:\n\t        if not isinstance(ctx, LangParser.IndexStmtContext):\n\t            raise TypeError(f\"Incorrect context type {type(ctx)}\")\n\t        if ctx.iterBasicType():\n\t            iter_var = ctx.iterBasicType()\n\t            if iter_var.ID():\n\t                var_type, _ = self.findVarType(iter_var)\n\t                if var_type not in ('column', 'row', 'table'):\n\t                    raise SemanticAnalyzerException(\n\t                        f\"{var_type} object is not subscriptable\")\n", "                return var_type\n\t        elif ctx.builtinFuncStmt():\n\t            var_type = self.findBuiltinFunctionType(ctx.builtinFuncStmt())[0]\n\t            if var_type not in ('column', 'row', 'table'):\n\t                raise SemanticAnalyzerException(\n\t                    f\"Function {str(ctx.builtinFuncStmt().ID(0))} returns not iterable object\")\n\t            return var_type\n\t    def findExprTypeWithTwoOperands(self, first_operand_ctxt: LangParser.NumbExprContext,\n\t                                    sign_ctxt: LangParser.BoolNumbSignContext,\n\t                                    second_operand_ctxt: LangParser.NumbExprContext\n", "                                    ) -> str:\n\t        first_operand_type = self.findExpressionOutType(first_operand_ctxt)\n\t        second_operand_type = self.findExpressionOutType(second_operand_ctxt)\n\t        sign = str(sign_ctxt.boolSign().children[0]) if sign_ctxt.boolSign() else str(\n\t            sign_ctxt.numbSign().children[0])\n\t        if first_operand_type not in self.available_operands.get(sign) or\\\n\t                second_operand_type not in self.available_operands.get(sign):\n\t            raise SemanticAnalyzerException(\n\t                f\"Incorrect operands types ({first_operand_type},{second_operand_type}) for {sign} sign\")\n\t        if first_operand_type == second_operand_type:\n", "            if sign_ctxt.boolSign():\n\t                return 'numb'\n\t            elif sign_ctxt.numbSign():\n\t                if sign in [\"/\", \"//\"] and first_operand_type != 'numb':\n\t                    raise SemanticAnalyzerException(\n\t                        f\"Incorrect operands types ({first_operand_type},{second_operand_type}) for {sign} sign\")\n\t                return first_operand_type\n\t        else:\n\t            if sign in [\"==\", \"!=\", \"<=\", \">=\", \">\", \"<\", \"!\", \"&\", \"|\", \"-\", \"*\"]:\n\t                raise SemanticAnalyzerException(\n", "                    f\"Operands types for {sign} sign should be equal\")\n\t            elif sign == '+':\n\t                types_set = set((first_operand_type, second_operand_type))\n\t                if not (types_set == {'row', 'table'} or types_set == {'column', 'table'}):\n\t                    raise SemanticAnalyzerException(\n\t                        f\"Incorrect operands types ({first_operand_type},{second_operand_type}) for {sign} sign\")\n\t                return 'table'\n\t            elif sign == '/':\n\t                if not (second_operand_type == 'numb' and first_operand_type in ['column', 'row', 'table']):\n\t                    raise SemanticAnalyzerException(\n", "                        f\"Incorrect operands types ({first_operand_type},{second_operand_type}) for {sign} sign\")\n\t                return first_operand_type\n\t            elif sign == '//':\n\t                if not (first_operand_type == 'table' and second_operand_type == 'numb'):\n\t                    raise SemanticAnalyzerException(\n\t                        f\"Operator // can be used for table and number types\")\n\t                return 'table'\n\t    def findExpressionOutType(self, expr_context: LangParser.NumbExprContext) -> str:\n\t        if expr_context.returnType():\n\t            if expr_context.returnType().basicType():\n", "                var_type, _ = self.findVarType(\n\t                    expr_context.returnType().basicType())\n\t                return var_type\n\t            elif expr_context.returnType().builtinFuncStmt():\n\t                func_type, func_name = self.findBuiltinFunctionType(\n\t                    expr_context.returnType().builtinFuncStmt())\n\t                return func_type\n\t            elif expr_context.returnType().indexStmt():\n\t                index_stmt_type = self.findIndexStmtType(\n\t                    expr_context.returnType().indexStmt())\n", "                return index_stmt_type\n\t        elif expr_context.boolNumbSign():\n\t            return self.findExprTypeWithTwoOperands(\n\t                expr_context.numbExpr(0),\n\t                expr_context.boolNumbSign(),\n\t                expr_context.numbExpr(1)\n\t            )\n\t    # Exit a parse tree produced by LangParser#assignExpr.\n\t    def exitAssignExpr(self, ctx: LangParser.AssignExprContext):\n\t        if ctx.ID() and ctx.indexStmt():\n", "            raise SemanticAnalyzerException(\n\t                \"Cannot initialize variables and index statements in one assign expression\")\n\t        if ctx.indexStmt():\n\t            if ctx.basicTypeName():\n\t                raise SemanticAnalyzerException(\n\t                    f\"Cannot initialize index stmt with specified type - {str(ctx.basicTypeName().children[0])}\")\n\t            for idx_stmt in ctx.indexStmt():\n\t                if idx_stmt.builtinFuncStmt():\n\t                    raise SemanticAnalyzerException(f\"Function {str(idx_stmt.builtinFuncStmt().children[0].children[0])} only returns values\")\n\t                self.findIndexStmtType(idx_stmt)\n", "        elif ctx.ID():\n\t            if ctx.basicTypeName():\n\t                var_type = str(ctx.basicTypeName().children[0])\n\t            else:\n\t                var_type, is_const = self.findVarType(str(ctx.ID(0)))\n\t                if is_const:\n\t                    raise SemanticAnalyzerException(\n\t                        f\"Variable {str(ctx.ID())} is constant\")\n\t            var_names = []\n\t            for var_name in ctx.ID():\n", "                var_names.append(str(var_name))\n\t            if len(var_names) != len(set(var_names)):\n\t                raise SemanticAnalyzerException(f\"Attempt to define variables with similar name\")\n\t            assign_exprs_n = 0\n\t            for numb_expr in ctx.numbExpr():\n\t                if numb_expr.returnType() is not None:\n\t                    return_type = numb_expr.returnType()\n\t                    if return_type.basicType():\n\t                        bas_type_ctx = return_type.basicType()\n\t                        assign_var_type, _ = self.findVarType(bas_type_ctx)\n", "                        if var_type != assign_var_type:\n\t                            raise SemanticAnalyzerException(\n\t                                f\"Variable {str(bas_type_ctx.children[0])} type ({assign_var_type}) is incompatible with '{var_type}' type\")\n\t                        assign_exprs_n += 1\n\t                    elif return_type.builtinFuncStmt():\n\t                        func_type, func_name = self.findBuiltinFunctionType(\n\t                            return_type.builtinFuncStmt())\n\t                        if func_type == 'void':\n\t                            raise SemanticAnalyzerException(\n\t                                f\"Function {func_name} returns nothing\")\n", "                        if var_type != func_type:\n\t                            raise SemanticAnalyzerException(\n\t                                f\"Function '{func_name}' return type ({func_type}) is incompatible with '{var_type}' type\")\n\t                        assign_exprs_n += 1\n\t                    elif return_type.indexStmt():\n\t                        iter_obj_ctxt = return_type.indexStmt().children[0]\n\t                        if isinstance(iter_obj_ctxt, LangParser.BuiltinFuncStmtContext):\n\t                            func_type, func_name = self.findBuiltinFunctionType(\n\t                                iter_obj_ctxt)\n\t                            if var_type != func_type:\n", "                                raise SemanticAnalyzerException(\n\t                                    f\"Function '{func_name}' return type ({func_type}) is incompatible with '{var_type}' type\")\n\t                            assign_exprs_n += 1\n\t                        if isinstance(iter_obj_ctxt, LangParser.IterBasicTypeContext):\n\t                            obj_type = str(iter_obj_ctxt.children[0])\n\t                            if iter_obj_ctxt.ID():\n\t                                obj_type, _ = self.findVarType(\n\t                                    str(iter_obj_ctxt.ID()))\n\t                            else:\n\t                                raise SemanticAnalyzerException(\n", "                                    f\"Incorrect subscritable variable\")\n\t                            if var_type != obj_type:\n\t                                # raise SemanticAnalyzerException(f\"Iterable object output doesn't match to variable type\")\n\t                                pass\n\t                            assign_exprs_n += 1\n\t                elif numb_expr.boolNumbSign() is not None:\n\t                    sign_ctxt = numb_expr.boolNumbSign()\n\t                    return_type = self.findExprTypeWithTwoOperands(numb_expr.numbExpr(0),\n\t                                                                   sign_ctxt,\n\t                                                                   numb_expr.numbExpr(\n", "                                                                       1)\n\t                                                                   )\n\t                    if var_type != return_type:\n\t                        raise SemanticAnalyzerException(\"Expression returned type is {} instead of {} type\".format(\n\t                            return_type, var_type\n\t                        ))\n\t                    assign_exprs_n += 1\n\t            if len(var_names) != assign_exprs_n:\n\t                raise SemanticAnalyzerException(\n\t                    \"Variables number doesn't match to expressions number\")\n", "            assign_results = []\n\t            for numbExprCtxt in ctx.numbExpr():\n\t                assign_results.append(self.findNumbExprResult(numbExprCtxt))\n\t            if ctx.basicTypeName():\n\t                for idx, var_name in enumerate(var_names):\n\t                    self.addNewVariable(var_name, var_type,\n\t                                        assign_results[idx])\n\t            else:\n\t                if ctx.ID(0):\n\t                    for idx, var_name in enumerate(var_names):\n", "                        self.changeVarValue(var_name, str(ctx.assignSign().children[0]), assign_results[idx])\n\t    def changeVarValue(self, str_name: str, ass_sign: str, value: Variable):\n\t        self.program_compiler.assign_value(\n\t            self.global_vars.get(str_name),\n\t            ass_sign,\n\t            value\n\t        )\n\t    def addNewVariable(self, str_name: str, var_type: str, value):\n\t        if self.function_vars.get(str_name):\n\t            raise SemanticAnalyzerException(\n", "                f\"Function with name '{str_name}' is already defined\")\n\t        if self.global_vars.get(str_name):\n\t            raise SemanticAnalyzerException(\n\t                f\"Variable with name '{str_name}' is already defined\")\n\t        if var_type == 'numb':\n\t            if isinstance(value, NumbVariable):\n\t                self.global_vars[str_name] = value\n\t            else:\n\t                self.global_vars[str_name] = NumbVariable(value, self.program_compiler._builder)\n\t        elif var_type == 'string':\n", "            if not isinstance(value, StringVariable):\n\t                self.global_vars[str_name] = StringVariable(value, self.program_compiler._builder)\n\t            else:\n\t                self.global_vars[str_name] = value\n\t        elif var_type in ['row', 'column', 'table']:\n\t            self.global_vars[str_name] = value\n\t    def findNumbExprResult(self, ctx: LangParser.NumbExprContext):\n\t        if ctx.returnType():\n\t            expr: LangParser.ReturnTypeContext = ctx.returnType()\n\t            if expr.basicType():\n", "                if expr.basicType().ID():\n\t                    return self.global_vars.get(str(expr.basicType().ID()))\n\t                elif expr.basicType().NUMBER():\n\t                    value = float(str(expr.basicType().NUMBER()))\n\t                    return NumbVariable(value, self.program_compiler._builder)\n\t                elif expr.basicType().STRING():\n\t                    value = StringVariable(str(expr.basicType().STRING()), self.program_compiler._builder)\n\t                    return value\n\t            elif expr.builtinFuncStmt():\n\t                func_expr: LangParser.BuiltinFuncStmtContext = expr.builtinFuncStmt()\n", "                if func_expr.createColStmt() or func_expr.createRowStmt():\n\t                    elements = self.pad_values_in_create_stmt(\n\t                        func_expr.createColStmt() if func_expr.createColStmt() else func_expr.createRowStmt()\n\t                    )\n\t                    var = self.program_compiler.create_row(elements) if func_expr.createRowStmt() \\\n\t                        else self.program_compiler.create_column(elements)\n\t                    return var\n\t                elif func_expr.readStrStmt():\n\t                    return self.program_compiler.call_function(\"read_string\")\n\t                elif func_expr.delFuncStmt():\n", "                    return self.program_compiler.call_function(\n\t                        \"del\", \n\t                        [\n\t                            self.findNumbExprResult(func_expr.delFuncStmt().numbExpr(0)),\n\t                            self.findNumbExprResult(func_expr.delFuncStmt().numbExpr(1))\n\t                        ]\n\t                    )\n\t                elif func_expr.createTablStmt():\n\t                    func_ctxt: LangParser.CreateTablStmtContext = func_expr.createTablStmt()\n\t                    if len(func_ctxt.NUMBER()) > 2:\n", "                        raise SemanticAnalyzerException(\n\t                            \"Table can be only 2-dimensional\")\n\t                    if len(func_ctxt.NUMBER()) < 2:\n\t                        raise SemanticAnalyzerException(\"n_rows param and n_cols param are required\")\n\t                    n_cols = int(float(str(func_ctxt.NUMBER(1))))\n\t                    n_rows = int(float(str(func_ctxt.NUMBER(0))))\n\t                    if func_ctxt.listStmt():\n\t                        elements = self.pad_values_in_create_stmt(func_ctxt)\n\t                    else:\n\t                        elements = []\n", "                    if n_cols < 0 or n_rows < 0 or n_rows * n_cols < len(elements):\n\t                        raise SemanticAnalyzerException(\n\t                            \"Invalid n_rows and n_cols combination\")\n\t                    return self.program_compiler.create_table(elements, n_cols, n_rows)\n\t                elif func_expr.reshapeStmt():\n\t                    return self.findreshapeStmtCtxtRes(func_expr.reshapeStmt())\n\t                elif func_expr.lengthStmt():\n\t                    return self.findLengthStmtCtxtResult(func_expr.lengthStmt())\n\t                elif func_expr.custFuncCall():\n\t                    args = [self.findNumbExprResult(\n", "                        ex) for ex in func_expr.custFuncCall().numbExpr()]\n\t                    name = str(func_expr.custFuncCall().ID())\n\t                    return self.program_compiler.call_custom_func(name, args)\n\t                elif func_expr.copyStmt():\n\t                    copy_stmt : LangParser.CopyStmtContext = func_expr.copyStmt()\n\t                    return self.program_compiler.call_function(\"copy\", [self.global_vars[str(copy_stmt.ID())]])\n\t            elif expr.indexStmt():\n\t                pass\n\t        elif ctx.boolNumbSign():\n\t            result = self.findExprResultWithTwoOperands(\n", "                ctx.numbExpr(0),\n\t                self.findExpressionOutType(ctx.numbExpr(0)),\n\t                ctx.boolNumbSign(),\n\t                ctx.numbExpr(1),\n\t                self.findExpressionOutType(ctx.numbExpr(1))\n\t            )\n\t            return result\n\t    def findLengthStmtCtxtResult(self, ctx: LangParser.LengthStmtContext):\n\t        var = self.findNumbExprResult(ctx.numbExpr())\n\t        return self.program_compiler.call_function(\"length\", [var])\n", "    def findreshapeStmtCtxtRes(self, ctx: LangParser.ReshapeStmtContext):\n\t        arg1 = self.findNumbExprResult(ctx.numbExpr(0))\n\t        arg2 = self.findNumbExprResult(ctx.numbExpr(1))\n\t        arg3 = self.findNumbExprResult(ctx.numbExpr(2))\n\t        return self.program_compiler.call_reshape_func(arg1, int(arg2), int(arg3))\n\t    def findExprResultWithTwoOperands(self, nexprctx1: LangParser.NumbExprContext,\n\t                                      type1: str,\n\t                                      signctxt: LangParser.BoolNumbSignContext,\n\t                                      nexprctx2: LangParser.NumbExprContext,\n\t                                      type2: str):\n", "        res1 = self.findNumbExprResult(nexprctx1)\n\t        res2 = self.findNumbExprResult(nexprctx2)\n\t        sign = str(signctxt.boolSign().children[0]) if signctxt.boolSign() else str(\n\t            signctxt.numbSign().children[0])\n\t        if type1 == type2:\n\t            return self.program_compiler.find_expression_result(res1, sign, res2)\n\t    # Enter a parse tree produced by LangParser#va  rDeclStmt.\n\t    def enterVarDeclStmt(self, ctx: LangParser.VarDeclStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#varDeclStmt.\n", "    def exitVarDeclStmt(self, ctx: LangParser.VarDeclStmtContext):\n\t        var_type = str(ctx.basicTypeName().children[0])\n\t        var_names = list(map(str, ctx.ID()))\n\t        if len(var_names) != len(set(var_names)):\n\t            raise SemanticAnalyzerException(\n\t                f\"Attempt to define variables with similar name\")\n\t        for var_ctxt in ctx.ID():\n\t            self.addNewVariable(str(var_ctxt), var_type)\n\t    # Enter a parse tree produced by LangParser#incStat.\n\t    def enterIncDecrStat(self, ctx: LangParser.IncDecrStatContext):\n", "        pass\n\t    # Exit a parse tree produced by LangParser#incDecrStat.\n\t    def exitIncDecrStat(self, ctx: LangParser.IncDecrStatContext):\n\t        var_type, is_const = self.findVarType(str(ctx.ID()))\n\t        if var_type != 'numb':\n\t            raise SemanticAnalyzerException(\n\t                \"Increment and decrement are used for number variables\")\n\t        if is_const:\n\t            raise SemanticAnalyzerException(\n\t                f\"Variable {str(ctx.ID())} is constant\")\n", "        var_name = str(ctx.ID())\n\t        var = self.global_vars.get(var_name)\n\t        if ctx.PLUS():\n\t            self.program_compiler.incr_var(var)\n\t        else:\n\t            self.global_vars[var_name] = self.program_compiler.decr_var(var)\n\t    # Enter a parse tree produced by LangParser#assignSign.\n\t    def enterAssignSign(self, ctx: LangParser.AssignSignContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#assignSign.\n", "    def exitAssignSign(self, ctx: LangParser.AssignSignContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#basicTypeName.\n\t    def enterBasicTypeName(self, ctx: LangParser.BasicTypeNameContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#basicTypeName.\n\t    def exitBasicTypeName(self, ctx: LangParser.BasicTypeNameContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#boolSign.\n\t    def enterBoolSign(self, ctx: LangParser.BoolSignContext):\n", "        pass\n\t    # Exit a parse tree produced by LangParser#boolSign.\n\t    def exitBoolSign(self, ctx: LangParser.BoolSignContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#numbSign.\n\t    def enterNumbSign(self, ctx: LangParser.NumbSignContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#numbSign.\n\t    def exitNumbSign(self, ctx: LangParser.NumbSignContext):\n\t        pass\n", "    # Enter a parse tree produced by LangParser#boolNumbSign.\n\t    def enterBoolNumbSign(self, ctx: LangParser.BoolNumbSignContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#boolNumbSign.\n\t    def exitBoolNumbSign(self, ctx: LangParser.BoolNumbSignContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#iterBasicType.\n\t    def enterIterBasicType(self, ctx: LangParser.IterBasicTypeContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#iterBasicType.\n", "    def exitIterBasicType(self, ctx: LangParser.IterBasicTypeContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#basicType.\n\t    def enterBasicType(self, ctx: LangParser.BasicTypeContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#basicType.\n\t    def exitBasicType(self, ctx: LangParser.BasicTypeContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#returnType.\n\t    def enterReturnType(self, ctx: LangParser.ReturnTypeContext):\n", "        pass\n\t    # Exit a parse tree produced by LangParser#returnType.\n\t    def exitReturnType(self, ctx: LangParser.ReturnTypeContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#numbExpr.\n\t    def enterNumbExpr(self, ctx: LangParser.NumbExprContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#numbExpr.\n\t    def exitNumbExpr(self, ctx: LangParser.NumbExprContext):\n\t        self.findExpressionOutType(ctx)\n", "    # Enter a parse tree produced by LangParser#boolExpr.\n\t    def enterBoolExpr(self, ctx: LangParser.BoolExprContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#boolExpr.\n\t    def exitBoolExpr(self, ctx: LangParser.BoolExprContext):\n\t        first_operand_type = self.findExpressionOutType(ctx.numbExpr(0))\n\t        second_operand_type = self.findExpressionOutType(ctx.numbExpr(1))\n\t        if first_operand_type != second_operand_type:\n\t            raise SemanticAnalyzerException(\n\t                \"Bool operations can perform only with equal types\")\n", "    # Enter a parse tree produced by LangParser#ifElseStmt.\n\t    def enterIfElseStmt(self, ctx: LangParser.IfElseStmtContext):\n\t        if isinstance(ctx.parentCtx.parentCtx, LangParser.FuncStatContext):\n\t            self.local_ifels_vars[\"ifels_local\"] = {}\n\t        elif isinstance(ctx.parentCtx.parentCtx, LangParser.ProgramContext):\n\t            self.local_ifels_vars = {}\n\t    # Exit a parse tree produced by LangParser#ifElseStmt.\n\t    def exitIfElseStmt(self, ctx: LangParser.IfElseStmtContext):\n\t        ifels_local_space = self.local_ifels_vars.get(\"ifels_local\")\n\t        if ifels_local_space:\n", "            while ifels_local_space.get(\"ifels_local\"):\n\t                ifels_local_space = ifels_local_space.get(\"ifels_local\")\n\t        else:\n\t            ifels_local_space = self.local_ifels_vars\n\t        for local_var in ifels_local_space:\n\t            if local_var != 'ifels_local':\n\t                self.global_vars.pop(local_var)\n\t        if not self.local_ifels_vars.get(\"ifels_local\"):\n\t            self.local_ifels_vars = {}\n\t        else:\n", "            tmp = self.local_ifels_vars\n\t            while tmp.get(\"ifels_local\").get(\"ifels_local\"):\n\t                tmp = tmp.get(\"ifels_local\")\n\t            tmp.pop(\"ifels_local\")\n\t    # Enter a parse tree produced by LangParser#whileStmt.\n\t    def enterWhileStmt(self, ctx: LangParser.WhileStmtContext):\n\t        if isinstance(ctx.parentCtx.parentCtx, LangParser.FuncStatContext):\n\t            self.local_while_vars[\"while_local\"] = {}\n\t        elif isinstance(ctx.parentCtx.parentCtx, LangParser.ProgramContext):\n\t            self.local_while_vars = {}\n", "    # Exit a parse tree produced by LangParser#whileStmt.\n\t    def exitWhileStmt(self, ctx: LangParser.WhileStmtContext):\n\t        while_local_space = self.local_while_vars.get(\"while_local\")\n\t        if while_local_space:\n\t            while while_local_space.get(\"while_local\"):\n\t                while_local_space = while_local_space.get(\"while_local\")\n\t        else:\n\t            while_local_space = self.local_while_vars\n\t        for local_var in while_local_space:\n\t            if local_var != 'while_local':\n", "                self.global_vars.pop(local_var)\n\t        if not self.local_while_vars.get(\"while_local\"):\n\t            self.local_while_vars = {}\n\t        else:\n\t            tmp = self.local_while_vars\n\t            while tmp.get(\"while_local\").get(\"while_local\"):\n\t                tmp = tmp.get(\"while_local\")\n\t            tmp.pop(\"while_local\")\n\t    # Enter a parse tree produced by LangParser#untilStmt.\n\t    def enterUntilStmt(self, ctx: LangParser.UntilStmtContext):\n", "        pass\n\t    # Exit a parse tree produced by LangParser#untilStmt.\n\t    def exitUntilStmt(self, ctx: LangParser.UntilStmtContext):\n\t        until_local_space = self.local_until_vars.get(\"until_local\")\n\t        if until_local_space:\n\t            while until_local_space.get(\"while_local\"):\n\t                until_local_space = until_local_space.get(\"until_local\")\n\t        else:\n\t            until_local_space = self.local_until_vars\n\t        for local_var in until_local_space:\n", "            if local_var != 'until_local':\n\t                self.global_vars.pop(local_var)\n\t        if not self.local_until_vars.get(\"until_local\"):\n\t            self.local_until_vars = {}\n\t        else:\n\t            tmp = self.local_until_vars\n\t            while tmp.get(\"until_local\").get(\"until_local\"):\n\t                tmp = tmp.get(\"until_local\")\n\t            tmp.pop(\"until_local\")\n\t    # Enter a parse tree produced by LangParser#custFuncCall.\n", "    def enterCustFuncCall(self, ctx: LangParser.CustFuncCallContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#custFuncCall.\n\t    def exitCustFuncCall(self, ctx: LangParser.CustFuncCallContext):\n\t        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.ID()))\n\t    # Enter a parse tree produced by LangParser#indexStmt.\n\t    def enterIndexStmt(self, ctx: LangParser.IndexStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#indexStmt.\n\t    def exitIndexStmt(self, ctx: LangParser.IndexStmtContext):\n", "        self.findIndexStmtType(ctx)\n\t    # Enter a parse tree produced by LangParser#listStmt.\n\t    def enterListStmt(self, ctx: LangParser.ListStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#listStmt.\n\t    def exitListStmt(self, ctx: LangParser.ListStmtContext):\n\t        if ctx.listStmt(0):\n\t            raise SemanticAnalyzerException(\"Only 1-dim lists are supported\")\n\t        if ctx.NUMBER(0) and ctx.STRING(0):\n\t            pass\n", "    # Enter a parse tree produced by LangParser#builtinFuncStmt.\n\t    def enterBuiltinFuncStmt(self, ctx: LangParser.BuiltinFuncStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#builtinFuncStmt.\n\t    def exitBuiltinFuncStmt(self, ctx: LangParser.BuiltinFuncStmtContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#lengthStmt.\n\t    def enterLengthStmt(self, ctx: LangParser.LengthStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#lengthStmt.\n", "    def exitLengthStmt(self, ctx: LangParser.LengthStmtContext):\n\t        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.LENGTH()))\n\t    # Enter a parse tree produced by LangParser#returnStmt.\n\t    def enterReturnStmt(self, ctx: LangParser.ReturnStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#returnStmt.\n\t    def exitReturnStmt(self, ctx: LangParser.ReturnStmtContext):\n\t        pass\n\t    def extractListVals(self, ctx: LangParser.ListStmtContext):\n\t        vals = []\n", "        for idx, child in enumerate(ctx.children):\n\t            if idx != 0 and str(child) != ',' and idx != len(ctx.children) - 1:\n\t                vals.append(str(child))\n\t        return vals\n\t    # Enter a parse tree produced by LangParser#createRowStmt.\n\t    def enterCreateRowStmt(self, ctx: LangParser.CreateRowStmtContext):\n\t        pass\n\t    def pad_values_in_create_stmt(self, ctx: LangParser.CreateColStmtContext | LangParser.CreateRowStmtContext | LangParser.CreateTablStmtContext) -> list:\n\t        vals = self.extractListVals(ctx.listStmt())\n\t        if not isinstance(ctx, LangParser.CreateTablStmtContext):\n", "            n_vals = int(str(ctx.NUMBER())) if ctx.NUMBER() else 0\n\t        else:\n\t            n_vals = int(str(ctx.NUMBER(0))) * int(str(ctx.NUMBER(1)))\n\t        if len(vals) < n_vals:\n\t            while len(vals) != n_vals:\n\t                vals.append(\" \")\n\t        if len(vals) != n_vals:\n\t            raise SemanticAnalyzerException(\"Input list number mismatch\")\n\t        return vals\n\t    # Exit a parse tree produced by LangParser#createRowStmt.\n", "    def exitCreateRowStmt(self, ctx: LangParser.CreateRowStmtContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#createTablStmt.\n\t    def enterCreateTablStmt(self, ctx: LangParser.CreateTablStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#createTablStmt.\n\t    def exitCreateTablStmt(self, ctx: LangParser.CreateTablStmtContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#createColStmt.\n\t    def enterCreateColStmt(self, ctx: LangParser.CreateColStmtContext):\n", "        pass\n\t    # Exit a parse tree produced by LangParser#createColStmt.\n\t    def exitCreateColStmt(self, ctx: LangParser.CreateColStmtContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#copyStmt.\n\t    def enterCopyStmt(self, ctx: LangParser.CopyStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#copyStmt.\n\t    def exitCopyStmt(self, ctx: LangParser.CopyStmtContext):\n\t        self.findVarType(str(ctx.ID()))\n", "    # Enter a parse tree produced by LangParser#minMaxFunc.\n\t    def enterMinMaxFunc(self, ctx: LangParser.MinMaxFuncContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#minMaxFunc.\n\t    def exitMinMaxFunc(self, ctx: LangParser.MinMaxFuncContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#minMaxFuncStmt.\n\t    def enterMinMaxFuncStmt(self, ctx: LangParser.MinMaxFuncStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#minMaxFuncStmt.\n", "    def exitMinMaxFuncStmt(self, ctx: LangParser.MinMaxFuncStmtContext):\n\t        self.checkNumbExprCorrectInFunctionCall(\n\t            ctx, str(ctx.minMaxFunc().children[0]))\n\t    # Enter a parse tree produced by LangParser#delFunc.\n\t    def enterDelFunc(self, ctx: LangParser.DelFuncContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#delFunc.\n\t    def exitDelFunc(self, ctx: LangParser.DelFuncContext):\n\t        pass\n\t    # Enter a parse tree produced by LangParser#delFuncStmt.\n", "    def enterDelFuncStmt(self, ctx: LangParser.DelFuncStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#delFuncStmt.\n\t    def exitDelFuncStmt(self, ctx: LangParser.DelFuncStmtContext):\n\t        self.checkNumbExprCorrectInFunctionCall(\n\t            ctx, str(ctx.delFunc().children[0]))\n\t    # Enter a parse tree produced by LangParser#reshapeStmt.\n\t    def enterReshapeStmt(self, ctx: LangParser.ReshapeStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#reshapeStmt.\n", "    def exitReshapeStmt(self, ctx: LangParser.ReshapeStmtContext):\n\t        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.RESHAPE()))\n\t    # Enter a parse tree produced by LangParser#insertStmt.\n\t    def enterInsertStmt(self, ctx: LangParser.InsertStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#insertStmt.\n\t    def exitInsertStmt(self, ctx: LangParser.InsertStmtContext):\n\t        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.INSERT()))\n\t    # Enter a parse tree produced by LangParser#findStmt.\n\t    def enterFindStmt(self, ctx: LangParser.FindStmtContext):\n", "        pass\n\t    # Exit a parse tree produced by LangParser#findStmt.\n\t    def exitFindStmt(self, ctx: LangParser.FindStmtContext):\n\t        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.FIND()))\n\t    # Enter a parse tree produced by LangParser#printStmt.\n\t    def enterPrintStmt(self, ctx: LangParser.PrintStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#printStmt.\n\t    def exitPrintStmt(self, ctx: LangParser.PrintStmtContext):\n\t        self.checkNumbExprCorrectInFunctionCall(ctx, str(ctx.PRINT()))\n", "        self.program_compiler.call_function(str(ctx.PRINT()),\n\t            [self.findNumbExprResult(ctx.numbExpr(0))])\n\t    # Enter a parse tree produced by LangParser#readStrStmt.\n\t    def enterReadStrStmt(self, ctx: LangParser.ReadStrStmtContext):\n\t        pass\n\t    # Exit a parse tree produced by LangParser#readStrStmt.\n\t    def exitReadStrStmt(self, ctx: LangParser.ReadStrStmtContext):\n\t        pass\n\t    def checkNumbExprCorrectInFunctionCall(self, ctx, func_name):\n\t        params = ctx.numbExpr() if isinstance(\n", "            ctx.numbExpr(), list) else [ctx.numbExpr()]\n\t        params_types = list(map(self.findExpressionOutType, params))\n\t        if not self.function_vars.get(func_name):\n\t            raise SemanticAnalyzerException(\n\t                \"Function {} is not defined\".format(func_name))\n\t        available_types = [aval_param.split(\n\t            '/') for aval_param in self.function_vars.get(func_name).get(\"params\")]\n\t        if len(available_types) != len(params_types):\n\t            raise SemanticAnalyzerException(\"Expected {} parameters, received - {} in function {}\".format(\n\t                len(available_types), len(params_types), func_name))\n", "        for param_index, aval_types_for_each_param in enumerate(available_types):\n\t            if params_types[param_index] not in aval_types_for_each_param:\n\t                raise SemanticAnalyzerException(\n\t                    f\"Expected {param_index} parameter to be {aval_types_for_each_param} in {func_name} function. Received - {params_types[param_index]}\")\n"]}
{"filename": "parser/LangParser.py", "chunked_list": ["# Generated from LangParser.g4 by ANTLR 4.7.2\n\t# encoding: utf-8\n\tfrom antlr4 import *\n\tfrom io import StringIO\n\tfrom typing.io import TextIO\n\tfrom antlr4.error.ErrorStrategy import ErrorStrategy\n\timport sys\n\tdef serializedATN():\n\t    with StringIO() as buf:\n\t        buf.write(\"\\3\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\\u5964\\3B\")\n", "        buf.write(\"\\u01f1\\4\\2\\t\\2\\4\\3\\t\\3\\4\\4\\t\\4\\4\\5\\t\\5\\4\\6\\t\\6\\4\\7\\t\\7\")\n\t        buf.write(\"\\4\\b\\t\\b\\4\\t\\t\\t\\4\\n\\t\\n\\4\\13\\t\\13\\4\\f\\t\\f\\4\\r\\t\\r\\4\\16\")\n\t        buf.write(\"\\t\\16\\4\\17\\t\\17\\4\\20\\t\\20\\4\\21\\t\\21\\4\\22\\t\\22\\4\\23\\t\\23\")\n\t        buf.write(\"\\4\\24\\t\\24\\4\\25\\t\\25\\4\\26\\t\\26\\4\\27\\t\\27\\4\\30\\t\\30\\4\\31\")\n\t        buf.write(\"\\t\\31\\4\\32\\t\\32\\4\\33\\t\\33\\4\\34\\t\\34\\4\\35\\t\\35\\4\\36\\t\\36\")\n\t        buf.write(\"\\4\\37\\t\\37\\4 \\t \\4!\\t!\\4\\\"\\t\\\"\\4#\\t#\\4$\\t$\\4%\\t%\\4&\\t\")\n\t        buf.write(\"&\\4\\'\\t\\'\\4(\\t(\\4)\\t)\\3\\2\\7\\2T\\n\\2\\f\\2\\16\\2W\\13\\2\\3\\2\")\n\t        buf.write(\"\\7\\2Z\\n\\2\\f\\2\\16\\2]\\13\\2\\3\\2\\3\\2\\3\\3\\3\\3\\5\\3c\\n\\3\\3\\3\")\n\t        buf.write(\"\\3\\3\\3\\3\\3\\3\\3\\3\\3\\3\\5\\3k\\n\\3\\3\\3\\3\\3\\3\\3\\3\\3\\7\\3q\\n\\3\")\n\t        buf.write(\"\\f\\3\\16\\3t\\13\\3\\3\\3\\3\\3\\3\\3\\7\\3y\\n\\3\\f\\3\\16\\3|\\13\\3\\3\")\n", "        buf.write(\"\\3\\3\\3\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\")\n\t        buf.write(\"\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\3\\4\\5\\4\\u0093\\n\\4\\3\\4\\5\\4\\u0096\")\n\t        buf.write(\"\\n\\4\\3\\5\\3\\5\\5\\5\\u009a\\n\\5\\3\\6\\3\\6\\3\\6\\5\\6\\u009f\\n\\6\\3\")\n\t        buf.write(\"\\6\\3\\6\\5\\6\\u00a3\\n\\6\\3\\6\\3\\6\\5\\6\\u00a7\\n\\6\\3\\6\\3\\6\\3\\6\")\n\t        buf.write(\"\\7\\6\\u00ac\\n\\6\\f\\6\\16\\6\\u00af\\13\\6\\3\\6\\3\\6\\3\\7\\5\\7\\u00b4\")\n\t        buf.write(\"\\n\\7\\3\\7\\3\\7\\5\\7\\u00b8\\n\\7\\3\\7\\3\\7\\3\\7\\7\\7\\u00bd\\n\\7\\f\")\n\t        buf.write(\"\\7\\16\\7\\u00c0\\13\\7\\3\\7\\3\\7\\3\\7\\3\\7\\7\\7\\u00c6\\n\\7\\f\\7\\16\")\n\t        buf.write(\"\\7\\u00c9\\13\\7\\3\\b\\3\\b\\3\\b\\3\\b\\7\\b\\u00cf\\n\\b\\f\\b\\16\\b\\u00d2\")\n\t        buf.write(\"\\13\\b\\3\\t\\3\\t\\3\\t\\3\\t\\5\\t\\u00d8\\n\\t\\3\\t\\3\\t\\3\\n\\3\\n\\3\")\n\t        buf.write(\"\\13\\3\\13\\3\\f\\3\\f\\3\\r\\3\\r\\3\\16\\3\\16\\5\\16\\u00e6\\n\\16\\3\\17\")\n", "        buf.write(\"\\3\\17\\3\\20\\3\\20\\3\\21\\3\\21\\3\\21\\5\\21\\u00ef\\n\\21\\3\\22\\3\")\n\t        buf.write(\"\\22\\3\\22\\3\\22\\3\\22\\3\\22\\3\\22\\7\\22\\u00f8\\n\\22\\f\\22\\16\\22\")\n\t        buf.write(\"\\u00fb\\13\\22\\3\\23\\3\\23\\3\\23\\3\\23\\3\\24\\3\\24\\3\\24\\3\\24\\7\")\n\t        buf.write(\"\\24\\u0105\\n\\24\\f\\24\\16\\24\\u0108\\13\\24\\3\\24\\3\\24\\3\\24\\3\")\n\t        buf.write(\"\\24\\3\\24\\3\\24\\7\\24\\u0110\\n\\24\\f\\24\\16\\24\\u0113\\13\\24\\3\")\n\t        buf.write(\"\\24\\3\\24\\7\\24\\u0117\\n\\24\\f\\24\\16\\24\\u011a\\13\\24\\3\\24\\3\")\n\t        buf.write(\"\\24\\3\\24\\7\\24\\u011f\\n\\24\\f\\24\\16\\24\\u0122\\13\\24\\3\\24\\7\")\n\t        buf.write(\"\\24\\u0125\\n\\24\\f\\24\\16\\24\\u0128\\13\\24\\3\\25\\3\\25\\3\\25\\3\")\n\t        buf.write(\"\\25\\3\\25\\3\\25\\7\\25\\u0130\\n\\25\\f\\25\\16\\25\\u0133\\13\\25\\3\")\n\t        buf.write(\"\\25\\3\\25\\3\\26\\3\\26\\7\\26\\u0139\\n\\26\\f\\26\\16\\26\\u013c\\13\")\n", "        buf.write(\"\\26\\3\\26\\3\\26\\3\\26\\3\\26\\3\\26\\3\\26\\3\\27\\3\\27\\3\\27\\5\\27\")\n\t        buf.write(\"\\u0147\\n\\27\\3\\27\\3\\27\\7\\27\\u014b\\n\\27\\f\\27\\16\\27\\u014e\")\n\t        buf.write(\"\\13\\27\\3\\27\\3\\27\\3\\30\\3\\30\\5\\30\\u0154\\n\\30\\3\\30\\3\\30\\5\")\n\t        buf.write(\"\\30\\u0158\\n\\30\\3\\30\\6\\30\\u015b\\n\\30\\r\\30\\16\\30\\u015c\\3\")\n\t        buf.write(\"\\31\\3\\31\\3\\31\\3\\31\\5\\31\\u0163\\n\\31\\3\\31\\3\\31\\3\\31\\3\\31\")\n\t        buf.write(\"\\5\\31\\u0169\\n\\31\\7\\31\\u016b\\n\\31\\f\\31\\16\\31\\u016e\\13\\31\")\n\t        buf.write(\"\\3\\31\\3\\31\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\\3\\32\")\n\t        buf.write(\"\\3\\32\\3\\32\\3\\32\\5\\32\\u017e\\n\\32\\3\\33\\3\\33\\3\\33\\3\\33\\3\")\n\t        buf.write(\"\\33\\3\\34\\3\\34\\3\\34\\3\\34\\3\\35\\3\\35\\3\\35\\5\\35\\u018c\\n\\35\")\n\t        buf.write(\"\\3\\35\\3\\35\\5\\35\\u0190\\n\\35\\3\\35\\3\\35\\3\\36\\3\\36\\3\\36\\5\")\n", "        buf.write(\"\\36\\u0197\\n\\36\\3\\36\\3\\36\\7\\36\\u019b\\n\\36\\f\\36\\16\\36\\u019e\")\n\t        buf.write(\"\\13\\36\\3\\36\\3\\36\\5\\36\\u01a2\\n\\36\\3\\36\\3\\36\\3\\37\\3\\37\\3\")\n\t        buf.write(\"\\37\\5\\37\\u01a9\\n\\37\\3\\37\\3\\37\\5\\37\\u01ad\\n\\37\\3\\37\\3\\37\")\n\t        buf.write(\"\\3 \\3 \\3 \\3 \\3 \\3!\\3!\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3\\\"\\3#\\3#\\3$\\3$\")\n\t        buf.write(\"\\3$\\3$\\3$\\3$\\3$\\3%\\3%\\3%\\3%\\3%\\3%\\3%\\3%\\3%\\3&\\3&\\3&\\3\")\n\t        buf.write(\"&\\3&\\3&\\3&\\3&\\3&\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3\\'\\3(\\3(\\3(\")\n\t        buf.write(\"\\5(\\u01e2\\n(\\3(\\3(\\7(\\u01e6\\n(\\f(\\16(\\u01e9\\13(\\3(\\3(\")\n\t        buf.write(\"\\3)\\3)\\3)\\3)\\3)\\2\\3\\\"*\\2\\4\\6\\b\\n\\f\\16\\20\\22\\24\\26\\30\\32\")\n\t        buf.write(\"\\34\\36 \\\"$&(*,.\\60\\62\\64\\668:<>@BDFHJLNP\\2\\n\\3\\2\\31\\35\")\n\t        buf.write(\"\\3\\2\\67;\\3\\2\\3\\13\\3\\2\\f\\20\\4\\29;??\\4\\29;=?\\3\\2-\\60\\3\\2\")\n", "        buf.write(\")+\\2\\u020d\\2U\\3\\2\\2\\2\\4b\\3\\2\\2\\2\\6\\u0092\\3\\2\\2\\2\\b\\u0099\")\n\t        buf.write(\"\\3\\2\\2\\2\\n\\u009b\\3\\2\\2\\2\\f\\u00b3\\3\\2\\2\\2\\16\\u00ca\\3\\2\")\n\t        buf.write(\"\\2\\2\\20\\u00d7\\3\\2\\2\\2\\22\\u00db\\3\\2\\2\\2\\24\\u00dd\\3\\2\\2\")\n\t        buf.write(\"\\2\\26\\u00df\\3\\2\\2\\2\\30\\u00e1\\3\\2\\2\\2\\32\\u00e5\\3\\2\\2\\2\")\n\t        buf.write(\"\\34\\u00e7\\3\\2\\2\\2\\36\\u00e9\\3\\2\\2\\2 \\u00ee\\3\\2\\2\\2\\\"\\u00f0\")\n\t        buf.write(\"\\3\\2\\2\\2$\\u00fc\\3\\2\\2\\2&\\u0100\\3\\2\\2\\2(\\u0129\\3\\2\\2\\2\")\n\t        buf.write(\"*\\u0136\\3\\2\\2\\2,\\u0143\\3\\2\\2\\2.\\u0153\\3\\2\\2\\2\\60\\u015e\")\n\t        buf.write(\"\\3\\2\\2\\2\\62\\u017d\\3\\2\\2\\2\\64\\u017f\\3\\2\\2\\2\\66\\u0184\\3\")\n\t        buf.write(\"\\2\\2\\28\\u0188\\3\\2\\2\\2:\\u0193\\3\\2\\2\\2<\\u01a5\\3\\2\\2\\2>\\u01b0\")\n\t        buf.write(\"\\3\\2\\2\\2@\\u01b5\\3\\2\\2\\2B\\u01b7\\3\\2\\2\\2D\\u01bc\\3\\2\\2\\2\")\n", "        buf.write(\"F\\u01be\\3\\2\\2\\2H\\u01c5\\3\\2\\2\\2J\\u01ce\\3\\2\\2\\2L\\u01d7\\3\")\n\t        buf.write(\"\\2\\2\\2N\\u01de\\3\\2\\2\\2P\\u01ec\\3\\2\\2\\2RT\\5\\4\\3\\2SR\\3\\2\\2\")\n\t        buf.write(\"\\2TW\\3\\2\\2\\2US\\3\\2\\2\\2UV\\3\\2\\2\\2V[\\3\\2\\2\\2WU\\3\\2\\2\\2X\")\n\t        buf.write(\"Z\\5\\6\\4\\2YX\\3\\2\\2\\2Z]\\3\\2\\2\\2[Y\\3\\2\\2\\2[\\\\\\3\\2\\2\\2\\\\^\")\n\t        buf.write(\"\\3\\2\\2\\2][\\3\\2\\2\\2^_\\7\\2\\2\\3_\\3\\3\\2\\2\\2`c\\5\\24\\13\\2ac\")\n\t        buf.write(\"\\7<\\2\\2b`\\3\\2\\2\\2ba\\3\\2\\2\\2cd\\3\\2\\2\\2de\\7\\36\\2\\2ef\\7?\")\n\t        buf.write(\"\\2\\2fj\\7\\23\\2\\2gh\\5\\24\\13\\2hi\\7?\\2\\2ik\\3\\2\\2\\2jg\\3\\2\\2\")\n\t        buf.write(\"\\2jk\\3\\2\\2\\2kr\\3\\2\\2\\2lm\\7\\21\\2\\2mn\\5\\24\\13\\2no\\7?\\2\\2\")\n\t        buf.write(\"oq\\3\\2\\2\\2pl\\3\\2\\2\\2qt\\3\\2\\2\\2rp\\3\\2\\2\\2rs\\3\\2\\2\\2su\\3\")\n\t        buf.write(\"\\2\\2\\2tr\\3\\2\\2\\2uv\\7\\24\\2\\2vz\\7\\25\\2\\2wy\\5\\b\\5\\2xw\\3\\2\")\n", "        buf.write(\"\\2\\2y|\\3\\2\\2\\2zx\\3\\2\\2\\2z{\\3\\2\\2\\2{}\\3\\2\\2\\2|z\\3\\2\\2\\2\")\n\t        buf.write(\"}~\\7\\26\\2\\2~\\5\\3\\2\\2\\2\\177\\u0080\\5\\f\\7\\2\\u0080\\u0081\\7\")\n\t        buf.write(\"\\22\\2\\2\\u0081\\u0093\\3\\2\\2\\2\\u0082\\u0083\\5\\62\\32\\2\\u0083\")\n\t        buf.write(\"\\u0084\\7\\22\\2\\2\\u0084\\u0093\\3\\2\\2\\2\\u0085\\u0086\\5N(\\2\")\n\t        buf.write(\"\\u0086\\u0087\\7\\22\\2\\2\\u0087\\u0093\\3\\2\\2\\2\\u0088\\u0093\")\n\t        buf.write(\"\\5\\n\\6\\2\\u0089\\u0093\\5&\\24\\2\\u008a\\u0093\\5(\\25\\2\\u008b\")\n\t        buf.write(\"\\u0093\\5*\\26\\2\\u008c\\u008d\\5\\20\\t\\2\\u008d\\u008e\\7\\22\\2\")\n\t        buf.write(\"\\2\\u008e\\u0093\\3\\2\\2\\2\\u008f\\u0090\\5\\16\\b\\2\\u0090\\u0091\")\n\t        buf.write(\"\\7\\22\\2\\2\\u0091\\u0093\\3\\2\\2\\2\\u0092\\177\\3\\2\\2\\2\\u0092\")\n\t        buf.write(\"\\u0082\\3\\2\\2\\2\\u0092\\u0085\\3\\2\\2\\2\\u0092\\u0088\\3\\2\\2\\2\")\n", "        buf.write(\"\\u0092\\u0089\\3\\2\\2\\2\\u0092\\u008a\\3\\2\\2\\2\\u0092\\u008b\\3\")\n\t        buf.write(\"\\2\\2\\2\\u0092\\u008c\\3\\2\\2\\2\\u0092\\u008f\\3\\2\\2\\2\\u0093\\u0095\")\n\t        buf.write(\"\\3\\2\\2\\2\\u0094\\u0096\\7%\\2\\2\\u0095\\u0094\\3\\2\\2\\2\\u0095\")\n\t        buf.write(\"\\u0096\\3\\2\\2\\2\\u0096\\7\\3\\2\\2\\2\\u0097\\u009a\\5\\6\\4\\2\\u0098\")\n\t        buf.write(\"\\u009a\\5\\66\\34\\2\\u0099\\u0097\\3\\2\\2\\2\\u0099\\u0098\\3\\2\\2\")\n\t        buf.write(\"\\2\\u009a\\t\\3\\2\\2\\2\\u009b\\u009c\\7\\37\\2\\2\\u009c\\u009e\\7\")\n\t        buf.write(\"\\23\\2\\2\\u009d\\u009f\\5\\f\\7\\2\\u009e\\u009d\\3\\2\\2\\2\\u009e\")\n\t        buf.write(\"\\u009f\\3\\2\\2\\2\\u009f\\u00a0\\3\\2\\2\\2\\u00a0\\u00a2\\7\\22\\2\")\n\t        buf.write(\"\\2\\u00a1\\u00a3\\5$\\23\\2\\u00a2\\u00a1\\3\\2\\2\\2\\u00a2\\u00a3\")\n\t        buf.write(\"\\3\\2\\2\\2\\u00a3\\u00a4\\3\\2\\2\\2\\u00a4\\u00a6\\7\\22\\2\\2\\u00a5\")\n", "        buf.write(\"\\u00a7\\5\\20\\t\\2\\u00a6\\u00a5\\3\\2\\2\\2\\u00a6\\u00a7\\3\\2\\2\")\n\t        buf.write(\"\\2\\u00a7\\u00a8\\3\\2\\2\\2\\u00a8\\u00a9\\7\\24\\2\\2\\u00a9\\u00ad\")\n\t        buf.write(\"\\7\\25\\2\\2\\u00aa\\u00ac\\5\\b\\5\\2\\u00ab\\u00aa\\3\\2\\2\\2\\u00ac\")\n\t        buf.write(\"\\u00af\\3\\2\\2\\2\\u00ad\\u00ab\\3\\2\\2\\2\\u00ad\\u00ae\\3\\2\\2\\2\")\n\t        buf.write(\"\\u00ae\\u00b0\\3\\2\\2\\2\\u00af\\u00ad\\3\\2\\2\\2\\u00b0\\u00b1\\7\")\n\t        buf.write(\"\\26\\2\\2\\u00b1\\13\\3\\2\\2\\2\\u00b2\\u00b4\\5\\24\\13\\2\\u00b3\\u00b2\")\n\t        buf.write(\"\\3\\2\\2\\2\\u00b3\\u00b4\\3\\2\\2\\2\\u00b4\\u00b7\\3\\2\\2\\2\\u00b5\")\n\t        buf.write(\"\\u00b8\\7?\\2\\2\\u00b6\\u00b8\\5.\\30\\2\\u00b7\\u00b5\\3\\2\\2\\2\")\n\t        buf.write(\"\\u00b7\\u00b6\\3\\2\\2\\2\\u00b8\\u00be\\3\\2\\2\\2\\u00b9\\u00ba\\7\")\n\t        buf.write(\"\\21\\2\\2\\u00ba\\u00bd\\7?\\2\\2\\u00bb\\u00bd\\5.\\30\\2\\u00bc\\u00b9\")\n", "        buf.write(\"\\3\\2\\2\\2\\u00bc\\u00bb\\3\\2\\2\\2\\u00bd\\u00c0\\3\\2\\2\\2\\u00be\")\n\t        buf.write(\"\\u00bc\\3\\2\\2\\2\\u00be\\u00bf\\3\\2\\2\\2\\u00bf\\u00c1\\3\\2\\2\\2\")\n\t        buf.write(\"\\u00c0\\u00be\\3\\2\\2\\2\\u00c1\\u00c2\\5\\22\\n\\2\\u00c2\\u00c7\")\n\t        buf.write(\"\\5\\\"\\22\\2\\u00c3\\u00c4\\7\\21\\2\\2\\u00c4\\u00c6\\5\\\"\\22\\2\\u00c5\")\n\t        buf.write(\"\\u00c3\\3\\2\\2\\2\\u00c6\\u00c9\\3\\2\\2\\2\\u00c7\\u00c5\\3\\2\\2\\2\")\n\t        buf.write(\"\\u00c7\\u00c8\\3\\2\\2\\2\\u00c8\\r\\3\\2\\2\\2\\u00c9\\u00c7\\3\\2\\2\")\n\t        buf.write(\"\\2\\u00ca\\u00cb\\5\\24\\13\\2\\u00cb\\u00d0\\7?\\2\\2\\u00cc\\u00cd\")\n\t        buf.write(\"\\7\\21\\2\\2\\u00cd\\u00cf\\7?\\2\\2\\u00ce\\u00cc\\3\\2\\2\\2\\u00cf\")\n\t        buf.write(\"\\u00d2\\3\\2\\2\\2\\u00d0\\u00ce\\3\\2\\2\\2\\u00d0\\u00d1\\3\\2\\2\\2\")\n\t        buf.write(\"\\u00d1\\17\\3\\2\\2\\2\\u00d2\\u00d0\\3\\2\\2\\2\\u00d3\\u00d4\\7\\f\")\n", "        buf.write(\"\\2\\2\\u00d4\\u00d8\\7\\f\\2\\2\\u00d5\\u00d6\\7\\r\\2\\2\\u00d6\\u00d8\")\n\t        buf.write(\"\\7\\r\\2\\2\\u00d7\\u00d3\\3\\2\\2\\2\\u00d7\\u00d5\\3\\2\\2\\2\\u00d8\")\n\t        buf.write(\"\\u00d9\\3\\2\\2\\2\\u00d9\\u00da\\7?\\2\\2\\u00da\\21\\3\\2\\2\\2\\u00db\")\n\t        buf.write(\"\\u00dc\\t\\2\\2\\2\\u00dc\\23\\3\\2\\2\\2\\u00dd\\u00de\\t\\3\\2\\2\\u00de\")\n\t        buf.write(\"\\25\\3\\2\\2\\2\\u00df\\u00e0\\t\\4\\2\\2\\u00e0\\27\\3\\2\\2\\2\\u00e1\")\n\t        buf.write(\"\\u00e2\\t\\5\\2\\2\\u00e2\\31\\3\\2\\2\\2\\u00e3\\u00e6\\5\\26\\f\\2\\u00e4\")\n\t        buf.write(\"\\u00e6\\5\\30\\r\\2\\u00e5\\u00e3\\3\\2\\2\\2\\u00e5\\u00e4\\3\\2\\2\")\n\t        buf.write(\"\\2\\u00e6\\33\\3\\2\\2\\2\\u00e7\\u00e8\\t\\6\\2\\2\\u00e8\\35\\3\\2\\2\")\n\t        buf.write(\"\\2\\u00e9\\u00ea\\t\\7\\2\\2\\u00ea\\37\\3\\2\\2\\2\\u00eb\\u00ef\\5\")\n\t        buf.write(\"\\36\\20\\2\\u00ec\\u00ef\\5\\62\\32\\2\\u00ed\\u00ef\\5.\\30\\2\\u00ee\")\n", "        buf.write(\"\\u00eb\\3\\2\\2\\2\\u00ee\\u00ec\\3\\2\\2\\2\\u00ee\\u00ed\\3\\2\\2\\2\")\n\t        buf.write(\"\\u00ef!\\3\\2\\2\\2\\u00f0\\u00f1\\b\\22\\1\\2\\u00f1\\u00f2\\5 \\21\")\n\t        buf.write(\"\\2\\u00f2\\u00f9\\3\\2\\2\\2\\u00f3\\u00f4\\f\\3\\2\\2\\u00f4\\u00f5\")\n\t        buf.write(\"\\5\\32\\16\\2\\u00f5\\u00f6\\5\\\"\\22\\4\\u00f6\\u00f8\\3\\2\\2\\2\\u00f7\")\n\t        buf.write(\"\\u00f3\\3\\2\\2\\2\\u00f8\\u00fb\\3\\2\\2\\2\\u00f9\\u00f7\\3\\2\\2\\2\")\n\t        buf.write(\"\\u00f9\\u00fa\\3\\2\\2\\2\\u00fa#\\3\\2\\2\\2\\u00fb\\u00f9\\3\\2\\2\")\n\t        buf.write(\"\\2\\u00fc\\u00fd\\5\\\"\\22\\2\\u00fd\\u00fe\\5\\26\\f\\2\\u00fe\\u00ff\")\n\t        buf.write(\"\\5\\\"\\22\\2\\u00ff%\\3\\2\\2\\2\\u0100\\u0101\\7!\\2\\2\\u0101\\u0102\")\n\t        buf.write(\"\\5$\\23\\2\\u0102\\u0106\\7\\25\\2\\2\\u0103\\u0105\\5\\b\\5\\2\\u0104\")\n\t        buf.write(\"\\u0103\\3\\2\\2\\2\\u0105\\u0108\\3\\2\\2\\2\\u0106\\u0104\\3\\2\\2\\2\")\n", "        buf.write(\"\\u0106\\u0107\\3\\2\\2\\2\\u0107\\u0109\\3\\2\\2\\2\\u0108\\u0106\\3\")\n\t        buf.write(\"\\2\\2\\2\\u0109\\u0118\\7\\26\\2\\2\\u010a\\u010b\\7\\\"\\2\\2\\u010b\")\n\t        buf.write(\"\\u010c\\7!\\2\\2\\u010c\\u010d\\5$\\23\\2\\u010d\\u0111\\7\\25\\2\\2\")\n\t        buf.write(\"\\u010e\\u0110\\5\\b\\5\\2\\u010f\\u010e\\3\\2\\2\\2\\u0110\\u0113\\3\")\n\t        buf.write(\"\\2\\2\\2\\u0111\\u010f\\3\\2\\2\\2\\u0111\\u0112\\3\\2\\2\\2\\u0112\\u0114\")\n\t        buf.write(\"\\3\\2\\2\\2\\u0113\\u0111\\3\\2\\2\\2\\u0114\\u0115\\7\\26\\2\\2\\u0115\")\n\t        buf.write(\"\\u0117\\3\\2\\2\\2\\u0116\\u010a\\3\\2\\2\\2\\u0117\\u011a\\3\\2\\2\\2\")\n\t        buf.write(\"\\u0118\\u0116\\3\\2\\2\\2\\u0118\\u0119\\3\\2\\2\\2\\u0119\\u0126\\3\")\n\t        buf.write(\"\\2\\2\\2\\u011a\\u0118\\3\\2\\2\\2\\u011b\\u011c\\7\\\"\\2\\2\\u011c\\u0120\")\n\t        buf.write(\"\\7\\25\\2\\2\\u011d\\u011f\\5\\b\\5\\2\\u011e\\u011d\\3\\2\\2\\2\\u011f\")\n", "        buf.write(\"\\u0122\\3\\2\\2\\2\\u0120\\u011e\\3\\2\\2\\2\\u0120\\u0121\\3\\2\\2\\2\")\n\t        buf.write(\"\\u0121\\u0123\\3\\2\\2\\2\\u0122\\u0120\\3\\2\\2\\2\\u0123\\u0125\\7\")\n\t        buf.write(\"\\26\\2\\2\\u0124\\u011b\\3\\2\\2\\2\\u0125\\u0128\\3\\2\\2\\2\\u0126\")\n\t        buf.write(\"\\u0124\\3\\2\\2\\2\\u0126\\u0127\\3\\2\\2\\2\\u0127\\'\\3\\2\\2\\2\\u0128\")\n\t        buf.write(\"\\u0126\\3\\2\\2\\2\\u0129\\u012a\\7#\\2\\2\\u012a\\u012b\\7\\23\\2\\2\")\n\t        buf.write(\"\\u012b\\u012c\\5$\\23\\2\\u012c\\u012d\\7\\24\\2\\2\\u012d\\u0131\")\n\t        buf.write(\"\\7\\25\\2\\2\\u012e\\u0130\\5\\b\\5\\2\\u012f\\u012e\\3\\2\\2\\2\\u0130\")\n\t        buf.write(\"\\u0133\\3\\2\\2\\2\\u0131\\u012f\\3\\2\\2\\2\\u0131\\u0132\\3\\2\\2\\2\")\n\t        buf.write(\"\\u0132\\u0134\\3\\2\\2\\2\\u0133\\u0131\\3\\2\\2\\2\\u0134\\u0135\\7\")\n\t        buf.write(\"\\26\\2\\2\\u0135)\\3\\2\\2\\2\\u0136\\u013a\\7\\25\\2\\2\\u0137\\u0139\")\n", "        buf.write(\"\\5\\b\\5\\2\\u0138\\u0137\\3\\2\\2\\2\\u0139\\u013c\\3\\2\\2\\2\\u013a\")\n\t        buf.write(\"\\u0138\\3\\2\\2\\2\\u013a\\u013b\\3\\2\\2\\2\\u013b\\u013d\\3\\2\\2\\2\")\n\t        buf.write(\"\\u013c\\u013a\\3\\2\\2\\2\\u013d\\u013e\\7\\26\\2\\2\\u013e\\u013f\")\n\t        buf.write(\"\\7$\\2\\2\\u013f\\u0140\\7\\23\\2\\2\\u0140\\u0141\\5$\\23\\2\\u0141\")\n\t        buf.write(\"\\u0142\\7\\24\\2\\2\\u0142+\\3\\2\\2\\2\\u0143\\u0144\\7?\\2\\2\\u0144\")\n\t        buf.write(\"\\u0146\\7\\23\\2\\2\\u0145\\u0147\\5\\\"\\22\\2\\u0146\\u0145\\3\\2\\2\")\n\t        buf.write(\"\\2\\u0146\\u0147\\3\\2\\2\\2\\u0147\\u014c\\3\\2\\2\\2\\u0148\\u0149\")\n\t        buf.write(\"\\7\\21\\2\\2\\u0149\\u014b\\5\\\"\\22\\2\\u014a\\u0148\\3\\2\\2\\2\\u014b\")\n\t        buf.write(\"\\u014e\\3\\2\\2\\2\\u014c\\u014a\\3\\2\\2\\2\\u014c\\u014d\\3\\2\\2\\2\")\n\t        buf.write(\"\\u014d\\u014f\\3\\2\\2\\2\\u014e\\u014c\\3\\2\\2\\2\\u014f\\u0150\\7\")\n", "        buf.write(\"\\24\\2\\2\\u0150-\\3\\2\\2\\2\\u0151\\u0154\\5\\34\\17\\2\\u0152\\u0154\")\n\t        buf.write(\"\\5\\62\\32\\2\\u0153\\u0151\\3\\2\\2\\2\\u0153\\u0152\\3\\2\\2\\2\\u0154\")\n\t        buf.write(\"\\u015a\\3\\2\\2\\2\\u0155\\u0157\\7\\27\\2\\2\\u0156\\u0158\\5\\\"\\22\")\n\t        buf.write(\"\\2\\u0157\\u0156\\3\\2\\2\\2\\u0157\\u0158\\3\\2\\2\\2\\u0158\\u0159\")\n\t        buf.write(\"\\3\\2\\2\\2\\u0159\\u015b\\7\\30\\2\\2\\u015a\\u0155\\3\\2\\2\\2\\u015b\")\n\t        buf.write(\"\\u015c\\3\\2\\2\\2\\u015c\\u015a\\3\\2\\2\\2\\u015c\\u015d\\3\\2\\2\\2\")\n\t        buf.write(\"\\u015d/\\3\\2\\2\\2\\u015e\\u0162\\7\\27\\2\\2\\u015f\\u0163\\5\\60\")\n\t        buf.write(\"\\31\\2\\u0160\\u0163\\7=\\2\\2\\u0161\\u0163\\7>\\2\\2\\u0162\\u015f\")\n\t        buf.write(\"\\3\\2\\2\\2\\u0162\\u0160\\3\\2\\2\\2\\u0162\\u0161\\3\\2\\2\\2\\u0162\")\n\t        buf.write(\"\\u0163\\3\\2\\2\\2\\u0163\\u016c\\3\\2\\2\\2\\u0164\\u0168\\7\\21\\2\")\n", "        buf.write(\"\\2\\u0165\\u0169\\5\\60\\31\\2\\u0166\\u0169\\7=\\2\\2\\u0167\\u0169\")\n\t        buf.write(\"\\7>\\2\\2\\u0168\\u0165\\3\\2\\2\\2\\u0168\\u0166\\3\\2\\2\\2\\u0168\")\n\t        buf.write(\"\\u0167\\3\\2\\2\\2\\u0169\\u016b\\3\\2\\2\\2\\u016a\\u0164\\3\\2\\2\\2\")\n\t        buf.write(\"\\u016b\\u016e\\3\\2\\2\\2\\u016c\\u016a\\3\\2\\2\\2\\u016c\\u016d\\3\")\n\t        buf.write(\"\\2\\2\\2\\u016d\\u016f\\3\\2\\2\\2\\u016e\\u016c\\3\\2\\2\\2\\u016f\\u0170\")\n\t        buf.write(\"\\7\\30\\2\\2\\u0170\\61\\3\\2\\2\\2\\u0171\\u017e\\5\\64\\33\\2\\u0172\")\n\t        buf.write(\"\\u017e\\58\\35\\2\\u0173\\u017e\\5,\\27\\2\\u0174\\u017e\\5:\\36\\2\")\n\t        buf.write(\"\\u0175\\u017e\\5<\\37\\2\\u0176\\u017e\\5P)\\2\\u0177\\u017e\\5>\")\n\t        buf.write(\" \\2\\u0178\\u017e\\5B\\\"\\2\\u0179\\u017e\\5F$\\2\\u017a\\u017e\\5\")\n\t        buf.write(\"H%\\2\\u017b\\u017e\\5J&\\2\\u017c\\u017e\\5L\\'\\2\\u017d\\u0171\")\n", "        buf.write(\"\\3\\2\\2\\2\\u017d\\u0172\\3\\2\\2\\2\\u017d\\u0173\\3\\2\\2\\2\\u017d\")\n\t        buf.write(\"\\u0174\\3\\2\\2\\2\\u017d\\u0175\\3\\2\\2\\2\\u017d\\u0176\\3\\2\\2\\2\")\n\t        buf.write(\"\\u017d\\u0177\\3\\2\\2\\2\\u017d\\u0178\\3\\2\\2\\2\\u017d\\u0179\\3\")\n\t        buf.write(\"\\2\\2\\2\\u017d\\u017a\\3\\2\\2\\2\\u017d\\u017b\\3\\2\\2\\2\\u017d\\u017c\")\n\t        buf.write(\"\\3\\2\\2\\2\\u017e\\63\\3\\2\\2\\2\\u017f\\u0180\\7\\'\\2\\2\\u0180\\u0181\")\n\t        buf.write(\"\\7\\23\\2\\2\\u0181\\u0182\\5\\\"\\22\\2\\u0182\\u0183\\7\\24\\2\\2\\u0183\")\n\t        buf.write(\"\\65\\3\\2\\2\\2\\u0184\\u0185\\7 \\2\\2\\u0185\\u0186\\5\\\"\\22\\2\\u0186\")\n\t        buf.write(\"\\u0187\\7\\22\\2\\2\\u0187\\67\\3\\2\\2\\2\\u0188\\u0189\\7\\62\\2\\2\")\n\t        buf.write(\"\\u0189\\u018b\\7\\23\\2\\2\\u018a\\u018c\\7=\\2\\2\\u018b\\u018a\\3\")\n\t        buf.write(\"\\2\\2\\2\\u018b\\u018c\\3\\2\\2\\2\\u018c\\u018f\\3\\2\\2\\2\\u018d\\u018e\")\n", "        buf.write(\"\\7\\21\\2\\2\\u018e\\u0190\\5\\60\\31\\2\\u018f\\u018d\\3\\2\\2\\2\\u018f\")\n\t        buf.write(\"\\u0190\\3\\2\\2\\2\\u0190\\u0191\\3\\2\\2\\2\\u0191\\u0192\\7\\24\\2\")\n\t        buf.write(\"\\2\\u01929\\3\\2\\2\\2\\u0193\\u0194\\7\\63\\2\\2\\u0194\\u0196\\7\\23\")\n\t        buf.write(\"\\2\\2\\u0195\\u0197\\7=\\2\\2\\u0196\\u0195\\3\\2\\2\\2\\u0196\\u0197\")\n\t        buf.write(\"\\3\\2\\2\\2\\u0197\\u019c\\3\\2\\2\\2\\u0198\\u0199\\7\\21\\2\\2\\u0199\")\n\t        buf.write(\"\\u019b\\7=\\2\\2\\u019a\\u0198\\3\\2\\2\\2\\u019b\\u019e\\3\\2\\2\\2\")\n\t        buf.write(\"\\u019c\\u019a\\3\\2\\2\\2\\u019c\\u019d\\3\\2\\2\\2\\u019d\\u01a1\\3\")\n\t        buf.write(\"\\2\\2\\2\\u019e\\u019c\\3\\2\\2\\2\\u019f\\u01a0\\7\\21\\2\\2\\u01a0\")\n\t        buf.write(\"\\u01a2\\5\\60\\31\\2\\u01a1\\u019f\\3\\2\\2\\2\\u01a1\\u01a2\\3\\2\\2\")\n\t        buf.write(\"\\2\\u01a2\\u01a3\\3\\2\\2\\2\\u01a3\\u01a4\\7\\24\\2\\2\\u01a4;\\3\\2\")\n", "        buf.write(\"\\2\\2\\u01a5\\u01a6\\7\\64\\2\\2\\u01a6\\u01a8\\7\\23\\2\\2\\u01a7\\u01a9\")\n\t        buf.write(\"\\7=\\2\\2\\u01a8\\u01a7\\3\\2\\2\\2\\u01a8\\u01a9\\3\\2\\2\\2\\u01a9\")\n\t        buf.write(\"\\u01ac\\3\\2\\2\\2\\u01aa\\u01ab\\7\\21\\2\\2\\u01ab\\u01ad\\5\\60\\31\")\n\t        buf.write(\"\\2\\u01ac\\u01aa\\3\\2\\2\\2\\u01ac\\u01ad\\3\\2\\2\\2\\u01ad\\u01ae\")\n\t        buf.write(\"\\3\\2\\2\\2\\u01ae\\u01af\\7\\24\\2\\2\\u01af=\\3\\2\\2\\2\\u01b0\\u01b1\")\n\t        buf.write(\"\\7\\66\\2\\2\\u01b1\\u01b2\\7\\23\\2\\2\\u01b2\\u01b3\\7?\\2\\2\\u01b3\")\n\t        buf.write(\"\\u01b4\\7\\24\\2\\2\\u01b4?\\3\\2\\2\\2\\u01b5\\u01b6\\t\\b\\2\\2\\u01b6\")\n\t        buf.write(\"A\\3\\2\\2\\2\\u01b7\\u01b8\\5@!\\2\\u01b8\\u01b9\\7\\23\\2\\2\\u01b9\")\n\t        buf.write(\"\\u01ba\\5\\\"\\22\\2\\u01ba\\u01bb\\7\\24\\2\\2\\u01bbC\\3\\2\\2\\2\\u01bc\")\n\t        buf.write(\"\\u01bd\\t\\t\\2\\2\\u01bdE\\3\\2\\2\\2\\u01be\\u01bf\\5D#\\2\\u01bf\")\n", "        buf.write(\"\\u01c0\\7\\23\\2\\2\\u01c0\\u01c1\\5\\\"\\22\\2\\u01c1\\u01c2\\7\\21\")\n\t        buf.write(\"\\2\\2\\u01c2\\u01c3\\5\\\"\\22\\2\\u01c3\\u01c4\\7\\24\\2\\2\\u01c4G\")\n\t        buf.write(\"\\3\\2\\2\\2\\u01c5\\u01c6\\7(\\2\\2\\u01c6\\u01c7\\7\\23\\2\\2\\u01c7\")\n\t        buf.write(\"\\u01c8\\5\\\"\\22\\2\\u01c8\\u01c9\\7\\21\\2\\2\\u01c9\\u01ca\\5\\\"\\22\")\n\t        buf.write(\"\\2\\u01ca\\u01cb\\7\\21\\2\\2\\u01cb\\u01cc\\5\\\"\\22\\2\\u01cc\\u01cd\")\n\t        buf.write(\"\\7\\24\\2\\2\\u01cdI\\3\\2\\2\\2\\u01ce\\u01cf\\7,\\2\\2\\u01cf\\u01d0\")\n\t        buf.write(\"\\7\\23\\2\\2\\u01d0\\u01d1\\5\\\"\\22\\2\\u01d1\\u01d2\\7\\21\\2\\2\\u01d2\")\n\t        buf.write(\"\\u01d3\\5\\\"\\22\\2\\u01d3\\u01d4\\7\\21\\2\\2\\u01d4\\u01d5\\5\\\"\\22\")\n\t        buf.write(\"\\2\\u01d5\\u01d6\\7\\24\\2\\2\\u01d6K\\3\\2\\2\\2\\u01d7\\u01d8\\7\\61\")\n\t        buf.write(\"\\2\\2\\u01d8\\u01d9\\7\\23\\2\\2\\u01d9\\u01da\\5\\\"\\22\\2\\u01da\\u01db\")\n", "        buf.write(\"\\7\\21\\2\\2\\u01db\\u01dc\\5\\\"\\22\\2\\u01dc\\u01dd\\7\\24\\2\\2\\u01dd\")\n\t        buf.write(\"M\\3\\2\\2\\2\\u01de\\u01df\\7&\\2\\2\\u01df\\u01e1\\7\\23\\2\\2\\u01e0\")\n\t        buf.write(\"\\u01e2\\5\\\"\\22\\2\\u01e1\\u01e0\\3\\2\\2\\2\\u01e1\\u01e2\\3\\2\\2\")\n\t        buf.write(\"\\2\\u01e2\\u01e7\\3\\2\\2\\2\\u01e3\\u01e4\\7\\21\\2\\2\\u01e4\\u01e6\")\n\t        buf.write(\"\\5\\\"\\22\\2\\u01e5\\u01e3\\3\\2\\2\\2\\u01e6\\u01e9\\3\\2\\2\\2\\u01e7\")\n\t        buf.write(\"\\u01e5\\3\\2\\2\\2\\u01e7\\u01e8\\3\\2\\2\\2\\u01e8\\u01ea\\3\\2\\2\\2\")\n\t        buf.write(\"\\u01e9\\u01e7\\3\\2\\2\\2\\u01ea\\u01eb\\7\\24\\2\\2\\u01ebO\\3\\2\\2\")\n\t        buf.write(\"\\2\\u01ec\\u01ed\\7\\65\\2\\2\\u01ed\\u01ee\\7\\23\\2\\2\\u01ee\\u01ef\")\n\t        buf.write(\"\\7\\24\\2\\2\\u01efQ\\3\\2\\2\\2\\62U[bjrz\\u0092\\u0095\\u0099\\u009e\")\n\t        buf.write(\"\\u00a2\\u00a6\\u00ad\\u00b3\\u00b7\\u00bc\\u00be\\u00c7\\u00d0\")\n", "        buf.write(\"\\u00d7\\u00e5\\u00ee\\u00f9\\u0106\\u0111\\u0118\\u0120\\u0126\")\n\t        buf.write(\"\\u0131\\u013a\\u0146\\u014c\\u0153\\u0157\\u015c\\u0162\\u0168\")\n\t        buf.write(\"\\u016c\\u017d\\u018b\\u018f\\u0196\\u019c\\u01a1\\u01a8\\u01ac\")\n\t        buf.write(\"\\u01e1\\u01e7\")\n\t        return buf.getvalue()\n\tclass LangParser ( Parser ):\n\t    grammarFileName = \"LangParser.g4\"\n\t    atn = ATNDeserializer().deserialize(serializedATN())\n\t    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]\n\t    sharedContextCache = PredictionContextCache()\n", "    literalNames = [ \"<INVALID>\", \"'&'\", \"'|'\", \"'!'\", \"'=='\", \"'!='\", \"'<='\", \n\t                     \"'>='\", \"'<'\", \"'>'\", \"'+'\", \"'-'\", \"'/'\", \"'//'\", \n\t                     \"'*'\", \"','\", \"';'\", \"'('\", \"')'\", \"'{'\", \"'}'\", \"'['\", \n\t                     \"']'\", \"'+='\", \"'='\", \"'-='\", \"'*='\", \"'/='\", \"'function'\", \n\t                     \"'for'\", \"'return'\", \"'if'\", \"'else'\", \"'while'\", \"'until'\", \n\t                     \"<INVALID>\", \"'print'\", \"'length'\", \"'reshape'\", \"'del_col'\", \n\t                     \"'del_row'\", \"'del'\", \"'insert'\", \"'max'\", \"'min'\", \n\t                     \"'maxlen'\", \"'minlen'\", \"'find'\", \"'create_row'\", \"'create_table'\", \n\t                     \"'create_column'\", \"'read_string'\", \"'copy'\", \"'numb'\", \n\t                     \"'string'\", \"'table'\", \"'column'\", \"'row'\", \"'void'\" ]\n", "    symbolicNames = [ \"<INVALID>\", \"AND\", \"OR\", \"NOT\", \"EQUAL\", \"NOT_EQUAL\", \n\t                      \"LESS_EQUAL\", \"GREATER_EQUAL\", \"LESS\", \"GREATER\", \n\t                      \"PLUS\", \"MINUS\", \"DIV\", \"FULL_DIV\", \"MULT\", \"COMMA\", \n\t                      \"SEMI\", \"LPAREN\", \"RPAREN\", \"LCURLY\", \"RCURLY\", \"L_SQBRACK\", \n\t                      \"P_SQBRACK\", \"PLUS_EQUAL\", \"ASSIGN\", \"MINUS_EQUAL\", \n\t                      \"MULT_EQUAL\", \"DIV_EQUAL\", \"FUNCTION\", \"FOR\", \"RETURN\", \n\t                      \"IF\", \"ELSE\", \"WHILE\", \"UNTIL\", \"COMMENT\", \"PRINT\", \n\t                      \"LENGTH\", \"RESHAPE\", \"DEL_COL\", \"DEL_ROW\", \"DEL\", \n\t                      \"INSERT\", \"MAX\", \"MIN\", \"MAXLEN\", \"MINLEN\", \"FIND\", \n\t                      \"CREATE_ROW\", \"CREATE_TABLE\", \"CREATE_COL\", \"READ_STRING\", \n", "                      \"COPY\", \"NUMBER_type\", \"STRING_type\", \"TABLE\", \"COLUMN\", \n\t                      \"ROW\", \"VOID\", \"NUMBER\", \"STRING\", \"ID\", \"WS\", \"CONST_NUMBER\", \n\t                      \"CONST_STRING\" ]\n\t    RULE_program = 0\n\t    RULE_func = 1\n\t    RULE_stat = 2\n\t    RULE_funcStat = 3\n\t    RULE_forStat = 4\n\t    RULE_assignExpr = 5\n\t    RULE_varDeclStmt = 6\n", "    RULE_incDecrStat = 7\n\t    RULE_assignSign = 8\n\t    RULE_basicTypeName = 9\n\t    RULE_boolSign = 10\n\t    RULE_numbSign = 11\n\t    RULE_boolNumbSign = 12\n\t    RULE_iterBasicType = 13\n\t    RULE_basicType = 14\n\t    RULE_returnType = 15\n\t    RULE_numbExpr = 16\n", "    RULE_boolExpr = 17\n\t    RULE_ifElseStmt = 18\n\t    RULE_whileStmt = 19\n\t    RULE_untilStmt = 20\n\t    RULE_custFuncCall = 21\n\t    RULE_indexStmt = 22\n\t    RULE_listStmt = 23\n\t    RULE_builtinFuncStmt = 24\n\t    RULE_lengthStmt = 25\n\t    RULE_returnStmt = 26\n", "    RULE_createRowStmt = 27\n\t    RULE_createTablStmt = 28\n\t    RULE_createColStmt = 29\n\t    RULE_copyStmt = 30\n\t    RULE_minMaxFunc = 31\n\t    RULE_minMaxFuncStmt = 32\n\t    RULE_delFunc = 33\n\t    RULE_delFuncStmt = 34\n\t    RULE_reshapeStmt = 35\n\t    RULE_insertStmt = 36\n", "    RULE_findStmt = 37\n\t    RULE_printStmt = 38\n\t    RULE_readStrStmt = 39\n\t    ruleNames =  [ \"program\", \"func\", \"stat\", \"funcStat\", \"forStat\", \"assignExpr\", \n\t                   \"varDeclStmt\", \"incDecrStat\", \"assignSign\", \"basicTypeName\", \n\t                   \"boolSign\", \"numbSign\", \"boolNumbSign\", \"iterBasicType\", \n\t                   \"basicType\", \"returnType\", \"numbExpr\", \"boolExpr\", \"ifElseStmt\", \n\t                   \"whileStmt\", \"untilStmt\", \"custFuncCall\", \"indexStmt\", \n\t                   \"listStmt\", \"builtinFuncStmt\", \"lengthStmt\", \"returnStmt\", \n\t                   \"createRowStmt\", \"createTablStmt\", \"createColStmt\", \"copyStmt\", \n", "                   \"minMaxFunc\", \"minMaxFuncStmt\", \"delFunc\", \"delFuncStmt\", \n\t                   \"reshapeStmt\", \"insertStmt\", \"findStmt\", \"printStmt\", \n\t                   \"readStrStmt\" ]\n\t    EOF = Token.EOF\n\t    AND=1\n\t    OR=2\n\t    NOT=3\n\t    EQUAL=4\n\t    NOT_EQUAL=5\n\t    LESS_EQUAL=6\n", "    GREATER_EQUAL=7\n\t    LESS=8\n\t    GREATER=9\n\t    PLUS=10\n\t    MINUS=11\n\t    DIV=12\n\t    FULL_DIV=13\n\t    MULT=14\n\t    COMMA=15\n\t    SEMI=16\n", "    LPAREN=17\n\t    RPAREN=18\n\t    LCURLY=19\n\t    RCURLY=20\n\t    L_SQBRACK=21\n\t    P_SQBRACK=22\n\t    PLUS_EQUAL=23\n\t    ASSIGN=24\n\t    MINUS_EQUAL=25\n\t    MULT_EQUAL=26\n", "    DIV_EQUAL=27\n\t    FUNCTION=28\n\t    FOR=29\n\t    RETURN=30\n\t    IF=31\n\t    ELSE=32\n\t    WHILE=33\n\t    UNTIL=34\n\t    COMMENT=35\n\t    PRINT=36\n", "    LENGTH=37\n\t    RESHAPE=38\n\t    DEL_COL=39\n\t    DEL_ROW=40\n\t    DEL=41\n\t    INSERT=42\n\t    MAX=43\n\t    MIN=44\n\t    MAXLEN=45\n\t    MINLEN=46\n", "    FIND=47\n\t    CREATE_ROW=48\n\t    CREATE_TABLE=49\n\t    CREATE_COL=50\n\t    READ_STRING=51\n\t    COPY=52\n\t    NUMBER_type=53\n\t    STRING_type=54\n\t    TABLE=55\n\t    COLUMN=56\n", "    ROW=57\n\t    VOID=58\n\t    NUMBER=59\n\t    STRING=60\n\t    ID=61\n\t    WS=62\n\t    CONST_NUMBER=63\n\t    CONST_STRING=64\n\t    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):\n\t        super().__init__(input, output)\n", "        self.checkVersion(\"4.7.2\")\n\t        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)\n\t        self._predicates = None\n\t    class ProgramContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def EOF(self):\n\t            return self.getToken(LangParser.EOF, 0)\n\t        def func(self, i:int=None):\n", "            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.FuncContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.FuncContext,i)\n\t        def stat(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.StatContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.StatContext,i)\n\t        def getRuleIndex(self):\n", "            return LangParser.RULE_program\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterProgram\" ):\n\t                listener.enterProgram(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitProgram\" ):\n\t                listener.exitProgram(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitProgram\" ):\n\t                return visitor.visitProgram(self)\n", "            else:\n\t                return visitor.visitChildren(self)\n\t    def program(self):\n\t        localctx = LangParser.ProgramContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 0, self.RULE_program)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 83\n\t            self._errHandler.sync(self)\n", "            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)\n\t            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:\n\t                if _alt==1:\n\t                    self.state = 80\n\t                    self.func() \n\t                self.state = 85\n\t                self._errHandler.sync(self)\n\t                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)\n\t            self.state = 89\n\t            self._errHandler.sync(self)\n", "            _la = self._input.LA(1)\n\t            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n\t                self.state = 86\n\t                self.stat()\n\t                self.state = 91\n\t                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n\t            self.state = 92\n\t            self.match(LangParser.EOF)\n\t        except RecognitionException as re:\n", "            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class FuncContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n", "        def FUNCTION(self):\n\t            return self.getToken(LangParser.FUNCTION, 0)\n\t        def ID(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.ID)\n\t            else:\n\t                return self.getToken(LangParser.ID, i)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def RPAREN(self):\n", "            return self.getToken(LangParser.RPAREN, 0)\n\t        def LCURLY(self):\n\t            return self.getToken(LangParser.LCURLY, 0)\n\t        def RCURLY(self):\n\t            return self.getToken(LangParser.RCURLY, 0)\n\t        def basicTypeName(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.BasicTypeNameContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.BasicTypeNameContext,i)\n", "        def VOID(self):\n\t            return self.getToken(LangParser.VOID, 0)\n\t        def COMMA(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.COMMA)\n\t            else:\n\t                return self.getToken(LangParser.COMMA, i)\n\t        def funcStat(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.FuncStatContext)\n", "            else:\n\t                return self.getTypedRuleContext(LangParser.FuncStatContext,i)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_func\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterFunc\" ):\n\t                listener.enterFunc(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitFunc\" ):\n\t                listener.exitFunc(self)\n", "        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitFunc\" ):\n\t                return visitor.visitFunc(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def func(self):\n\t        localctx = LangParser.FuncContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 2, self.RULE_func)\n\t        self._la = 0 # Token type\n\t        try:\n", "            self.enterOuterAlt(localctx, 1)\n\t            self.state = 96\n\t            self._errHandler.sync(self)\n\t            token = self._input.LA(1)\n\t            if token in [LangParser.NUMBER_type, LangParser.STRING_type, LangParser.TABLE, LangParser.COLUMN, LangParser.ROW]:\n\t                self.state = 94\n\t                self.basicTypeName()\n\t                pass\n\t            elif token in [LangParser.VOID]:\n\t                self.state = 95\n", "                self.match(LangParser.VOID)\n\t                pass\n\t            else:\n\t                raise NoViableAltException(self)\n\t            self.state = 98\n\t            self.match(LangParser.FUNCTION)\n\t            self.state = 99\n\t            self.match(LangParser.ID)\n\t            self.state = 100\n\t            self.match(LangParser.LPAREN)\n", "            self.state = 104\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW))) != 0):\n\t                self.state = 101\n\t                self.basicTypeName()\n\t                self.state = 102\n\t                self.match(LangParser.ID)\n\t            self.state = 112\n\t            self._errHandler.sync(self)\n", "            _la = self._input.LA(1)\n\t            while _la==LangParser.COMMA:\n\t                self.state = 106\n\t                self.match(LangParser.COMMA)\n\t                self.state = 107\n\t                self.basicTypeName()\n\t                self.state = 108\n\t                self.match(LangParser.ID)\n\t                self.state = 114\n\t                self._errHandler.sync(self)\n", "                _la = self._input.LA(1)\n\t            self.state = 115\n\t            self.match(LangParser.RPAREN)\n\t            self.state = 116\n\t            self.match(LangParser.LCURLY)\n\t            self.state = 120\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n\t                self.state = 117\n", "                self.funcStat()\n\t                self.state = 122\n\t                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n\t            self.state = 123\n\t            self.match(LangParser.RCURLY)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n", "        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class StatContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def assignExpr(self):\n\t            return self.getTypedRuleContext(LangParser.AssignExprContext,0)\n\t        def SEMI(self):\n", "            return self.getToken(LangParser.SEMI, 0)\n\t        def builtinFuncStmt(self):\n\t            return self.getTypedRuleContext(LangParser.BuiltinFuncStmtContext,0)\n\t        def printStmt(self):\n\t            return self.getTypedRuleContext(LangParser.PrintStmtContext,0)\n\t        def forStat(self):\n\t            return self.getTypedRuleContext(LangParser.ForStatContext,0)\n\t        def ifElseStmt(self):\n\t            return self.getTypedRuleContext(LangParser.IfElseStmtContext,0)\n\t        def whileStmt(self):\n", "            return self.getTypedRuleContext(LangParser.WhileStmtContext,0)\n\t        def untilStmt(self):\n\t            return self.getTypedRuleContext(LangParser.UntilStmtContext,0)\n\t        def incDecrStat(self):\n\t            return self.getTypedRuleContext(LangParser.IncDecrStatContext,0)\n\t        def varDeclStmt(self):\n\t            return self.getTypedRuleContext(LangParser.VarDeclStmtContext,0)\n\t        def COMMENT(self):\n\t            return self.getToken(LangParser.COMMENT, 0)\n\t        def getRuleIndex(self):\n", "            return LangParser.RULE_stat\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterStat\" ):\n\t                listener.enterStat(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitStat\" ):\n\t                listener.exitStat(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitStat\" ):\n\t                return visitor.visitStat(self)\n", "            else:\n\t                return visitor.visitChildren(self)\n\t    def stat(self):\n\t        localctx = LangParser.StatContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 4, self.RULE_stat)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 144\n\t            self._errHandler.sync(self)\n", "            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)\n\t            if la_ == 1:\n\t                self.state = 125\n\t                self.assignExpr()\n\t                self.state = 126\n\t                self.match(LangParser.SEMI)\n\t                pass\n\t            elif la_ == 2:\n\t                self.state = 128\n\t                self.builtinFuncStmt()\n", "                self.state = 129\n\t                self.match(LangParser.SEMI)\n\t                pass\n\t            elif la_ == 3:\n\t                self.state = 131\n\t                self.printStmt()\n\t                self.state = 132\n\t                self.match(LangParser.SEMI)\n\t                pass\n\t            elif la_ == 4:\n", "                self.state = 134\n\t                self.forStat()\n\t                pass\n\t            elif la_ == 5:\n\t                self.state = 135\n\t                self.ifElseStmt()\n\t                pass\n\t            elif la_ == 6:\n\t                self.state = 136\n\t                self.whileStmt()\n", "                pass\n\t            elif la_ == 7:\n\t                self.state = 137\n\t                self.untilStmt()\n\t                pass\n\t            elif la_ == 8:\n\t                self.state = 138\n\t                self.incDecrStat()\n\t                self.state = 139\n\t                self.match(LangParser.SEMI)\n", "                pass\n\t            elif la_ == 9:\n\t                self.state = 141\n\t                self.varDeclStmt()\n\t                self.state = 142\n\t                self.match(LangParser.SEMI)\n\t                pass\n\t            self.state = 147\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n", "            if _la==LangParser.COMMENT:\n\t                self.state = 146\n\t                self.match(LangParser.COMMENT)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n", "    class FuncStatContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def stat(self):\n\t            return self.getTypedRuleContext(LangParser.StatContext,0)\n\t        def returnStmt(self):\n\t            return self.getTypedRuleContext(LangParser.ReturnStmtContext,0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_funcStat\n", "        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterFuncStat\" ):\n\t                listener.enterFuncStat(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitFuncStat\" ):\n\t                listener.exitFuncStat(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitFuncStat\" ):\n\t                return visitor.visitFuncStat(self)\n\t            else:\n", "                return visitor.visitChildren(self)\n\t    def funcStat(self):\n\t        localctx = LangParser.FuncStatContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 6, self.RULE_funcStat)\n\t        try:\n\t            self.state = 151\n\t            self._errHandler.sync(self)\n\t            token = self._input.LA(1)\n\t            if token in [LangParser.PLUS, LangParser.MINUS, LangParser.LCURLY, LangParser.FOR, LangParser.IF, LangParser.WHILE, LangParser.PRINT, LangParser.LENGTH, LangParser.RESHAPE, LangParser.DEL_COL, LangParser.DEL_ROW, LangParser.DEL, LangParser.INSERT, LangParser.MAX, LangParser.MIN, LangParser.MAXLEN, LangParser.MINLEN, LangParser.FIND, LangParser.CREATE_ROW, LangParser.CREATE_TABLE, LangParser.CREATE_COL, LangParser.READ_STRING, LangParser.COPY, LangParser.NUMBER_type, LangParser.STRING_type, LangParser.TABLE, LangParser.COLUMN, LangParser.ROW, LangParser.ID]:\n\t                self.enterOuterAlt(localctx, 1)\n", "                self.state = 149\n\t                self.stat()\n\t                pass\n\t            elif token in [LangParser.RETURN]:\n\t                self.enterOuterAlt(localctx, 2)\n\t                self.state = 150\n\t                self.returnStmt()\n\t                pass\n\t            else:\n\t                raise NoViableAltException(self)\n", "        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class ForStatContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n", "            self.parser = parser\n\t        def FOR(self):\n\t            return self.getToken(LangParser.FOR, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def SEMI(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.SEMI)\n\t            else:\n\t                return self.getToken(LangParser.SEMI, i)\n", "        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def LCURLY(self):\n\t            return self.getToken(LangParser.LCURLY, 0)\n\t        def RCURLY(self):\n\t            return self.getToken(LangParser.RCURLY, 0)\n\t        def assignExpr(self):\n\t            return self.getTypedRuleContext(LangParser.AssignExprContext,0)\n\t        def boolExpr(self):\n\t            return self.getTypedRuleContext(LangParser.BoolExprContext,0)\n", "        def incDecrStat(self):\n\t            return self.getTypedRuleContext(LangParser.IncDecrStatContext,0)\n\t        def funcStat(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.FuncStatContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.FuncStatContext,i)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_forStat\n\t        def enterRule(self, listener:ParseTreeListener):\n", "            if hasattr( listener, \"enterForStat\" ):\n\t                listener.enterForStat(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitForStat\" ):\n\t                listener.exitForStat(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitForStat\" ):\n\t                return visitor.visitForStat(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n", "    def forStat(self):\n\t        localctx = LangParser.ForStatContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 8, self.RULE_forStat)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 153\n\t            self.match(LangParser.FOR)\n\t            self.state = 154\n\t            self.match(LangParser.LPAREN)\n", "            self.state = 156\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n\t                self.state = 155\n\t                self.assignExpr()\n\t            self.state = 158\n\t            self.match(LangParser.SEMI)\n\t            self.state = 160\n\t            self._errHandler.sync(self)\n", "            _la = self._input.LA(1)\n\t            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):\n\t                self.state = 159\n\t                self.boolExpr()\n\t            self.state = 162\n\t            self.match(LangParser.SEMI)\n\t            self.state = 164\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if _la==LangParser.PLUS or _la==LangParser.MINUS:\n", "                self.state = 163\n\t                self.incDecrStat()\n\t            self.state = 166\n\t            self.match(LangParser.RPAREN)\n\t            self.state = 167\n\t            self.match(LangParser.LCURLY)\n\t            self.state = 171\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n", "                self.state = 168\n\t                self.funcStat()\n\t                self.state = 173\n\t                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n\t            self.state = 174\n\t            self.match(LangParser.RCURLY)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n", "            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class AssignExprContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def assignSign(self):\n\t            return self.getTypedRuleContext(LangParser.AssignSignContext,0)\n", "        def numbExpr(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\t        def ID(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.ID)\n\t            else:\n\t                return self.getToken(LangParser.ID, i)\n", "        def indexStmt(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.IndexStmtContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.IndexStmtContext,i)\n\t        def basicTypeName(self):\n\t            return self.getTypedRuleContext(LangParser.BasicTypeNameContext,0)\n\t        def COMMA(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.COMMA)\n", "            else:\n\t                return self.getToken(LangParser.COMMA, i)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_assignExpr\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterAssignExpr\" ):\n\t                listener.enterAssignExpr(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitAssignExpr\" ):\n\t                listener.exitAssignExpr(self)\n", "        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitAssignExpr\" ):\n\t                return visitor.visitAssignExpr(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def assignExpr(self):\n\t        localctx = LangParser.AssignExprContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 10, self.RULE_assignExpr)\n\t        self._la = 0 # Token type\n\t        try:\n", "            self.enterOuterAlt(localctx, 1)\n\t            self.state = 177\n\t            self._errHandler.sync(self)\n\t            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)\n\t            if la_ == 1:\n\t                self.state = 176\n\t                self.basicTypeName()\n\t            self.state = 181\n\t            self._errHandler.sync(self)\n\t            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)\n", "            if la_ == 1:\n\t                self.state = 179\n\t                self.match(LangParser.ID)\n\t                pass\n\t            elif la_ == 2:\n\t                self.state = 180\n\t                self.indexStmt()\n\t                pass\n\t            self.state = 188\n\t            self._errHandler.sync(self)\n", "            _la = self._input.LA(1)\n\t            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.COMMA) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n\t                self.state = 186\n\t                self._errHandler.sync(self)\n\t                token = self._input.LA(1)\n\t                if token in [LangParser.COMMA]:\n\t                    self.state = 183\n\t                    self.match(LangParser.COMMA)\n\t                    self.state = 184\n\t                    self.match(LangParser.ID)\n", "                    pass\n\t                elif token in [LangParser.LENGTH, LangParser.RESHAPE, LangParser.DEL_COL, LangParser.DEL_ROW, LangParser.DEL, LangParser.INSERT, LangParser.MAX, LangParser.MIN, LangParser.MAXLEN, LangParser.MINLEN, LangParser.FIND, LangParser.CREATE_ROW, LangParser.CREATE_TABLE, LangParser.CREATE_COL, LangParser.READ_STRING, LangParser.COPY, LangParser.TABLE, LangParser.COLUMN, LangParser.ROW, LangParser.ID]:\n\t                    self.state = 185\n\t                    self.indexStmt()\n\t                    pass\n\t                else:\n\t                    raise NoViableAltException(self)\n\t                self.state = 190\n\t                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n", "            self.state = 191\n\t            self.assignSign()\n\t            self.state = 192\n\t            self.numbExpr(0)\n\t            self.state = 197\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            while _la==LangParser.COMMA:\n\t                self.state = 193\n\t                self.match(LangParser.COMMA)\n", "                self.state = 194\n\t                self.numbExpr(0)\n\t                self.state = 199\n\t                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n", "            self.exitRule()\n\t        return localctx\n\t    class VarDeclStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def basicTypeName(self):\n\t            return self.getTypedRuleContext(LangParser.BasicTypeNameContext,0)\n\t        def ID(self, i:int=None):\n\t            if i is None:\n", "                return self.getTokens(LangParser.ID)\n\t            else:\n\t                return self.getToken(LangParser.ID, i)\n\t        def COMMA(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.COMMA)\n\t            else:\n\t                return self.getToken(LangParser.COMMA, i)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_varDeclStmt\n", "        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterVarDeclStmt\" ):\n\t                listener.enterVarDeclStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitVarDeclStmt\" ):\n\t                listener.exitVarDeclStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitVarDeclStmt\" ):\n\t                return visitor.visitVarDeclStmt(self)\n\t            else:\n", "                return visitor.visitChildren(self)\n\t    def varDeclStmt(self):\n\t        localctx = LangParser.VarDeclStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 12, self.RULE_varDeclStmt)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 200\n\t            self.basicTypeName()\n\t            self.state = 201\n", "            self.match(LangParser.ID)\n\t            self.state = 206\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            while _la==LangParser.COMMA:\n\t                self.state = 202\n\t                self.match(LangParser.COMMA)\n\t                self.state = 203\n\t                self.match(LangParser.ID)\n\t                self.state = 208\n", "                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class IncDecrStatContext(ParserRuleContext):\n", "        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def ID(self):\n\t            return self.getToken(LangParser.ID, 0)\n\t        def PLUS(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.PLUS)\n\t            else:\n\t                return self.getToken(LangParser.PLUS, i)\n", "        def MINUS(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.MINUS)\n\t            else:\n\t                return self.getToken(LangParser.MINUS, i)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_incDecrStat\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterIncDecrStat\" ):\n\t                listener.enterIncDecrStat(self)\n", "        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitIncDecrStat\" ):\n\t                listener.exitIncDecrStat(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitIncDecrStat\" ):\n\t                return visitor.visitIncDecrStat(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def incDecrStat(self):\n\t        localctx = LangParser.IncDecrStatContext(self, self._ctx, self.state)\n", "        self.enterRule(localctx, 14, self.RULE_incDecrStat)\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 213\n\t            self._errHandler.sync(self)\n\t            token = self._input.LA(1)\n\t            if token in [LangParser.PLUS]:\n\t                self.state = 209\n\t                self.match(LangParser.PLUS)\n\t                self.state = 210\n", "                self.match(LangParser.PLUS)\n\t                pass\n\t            elif token in [LangParser.MINUS]:\n\t                self.state = 211\n\t                self.match(LangParser.MINUS)\n\t                self.state = 212\n\t                self.match(LangParser.MINUS)\n\t                pass\n\t            else:\n\t                raise NoViableAltException(self)\n", "            self.state = 215\n\t            self.match(LangParser.ID)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class AssignSignContext(ParserRuleContext):\n", "        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def ASSIGN(self):\n\t            return self.getToken(LangParser.ASSIGN, 0)\n\t        def PLUS_EQUAL(self):\n\t            return self.getToken(LangParser.PLUS_EQUAL, 0)\n\t        def MINUS_EQUAL(self):\n\t            return self.getToken(LangParser.MINUS_EQUAL, 0)\n\t        def MULT_EQUAL(self):\n", "            return self.getToken(LangParser.MULT_EQUAL, 0)\n\t        def DIV_EQUAL(self):\n\t            return self.getToken(LangParser.DIV_EQUAL, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_assignSign\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterAssignSign\" ):\n\t                listener.enterAssignSign(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitAssignSign\" ):\n", "                listener.exitAssignSign(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitAssignSign\" ):\n\t                return visitor.visitAssignSign(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def assignSign(self):\n\t        localctx = LangParser.AssignSignContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 16, self.RULE_assignSign)\n\t        self._la = 0 # Token type\n", "        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 217\n\t            _la = self._input.LA(1)\n\t            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS_EQUAL) | (1 << LangParser.ASSIGN) | (1 << LangParser.MINUS_EQUAL) | (1 << LangParser.MULT_EQUAL) | (1 << LangParser.DIV_EQUAL))) != 0)):\n\t                self._errHandler.recoverInline(self)\n\t            else:\n\t                self._errHandler.reportMatch(self)\n\t                self.consume()\n\t        except RecognitionException as re:\n", "            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class BasicTypeNameContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n", "        def NUMBER_type(self):\n\t            return self.getToken(LangParser.NUMBER_type, 0)\n\t        def STRING_type(self):\n\t            return self.getToken(LangParser.STRING_type, 0)\n\t        def COLUMN(self):\n\t            return self.getToken(LangParser.COLUMN, 0)\n\t        def ROW(self):\n\t            return self.getToken(LangParser.ROW, 0)\n\t        def TABLE(self):\n\t            return self.getToken(LangParser.TABLE, 0)\n", "        def getRuleIndex(self):\n\t            return LangParser.RULE_basicTypeName\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterBasicTypeName\" ):\n\t                listener.enterBasicTypeName(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitBasicTypeName\" ):\n\t                listener.exitBasicTypeName(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitBasicTypeName\" ):\n", "                return visitor.visitBasicTypeName(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def basicTypeName(self):\n\t        localctx = LangParser.BasicTypeNameContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 18, self.RULE_basicTypeName)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 219\n", "            _la = self._input.LA(1)\n\t            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW))) != 0)):\n\t                self._errHandler.recoverInline(self)\n\t            else:\n\t                self._errHandler.reportMatch(self)\n\t                self.consume()\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n", "        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class BoolSignContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def EQUAL(self):\n\t            return self.getToken(LangParser.EQUAL, 0)\n\t        def NOT_EQUAL(self):\n", "            return self.getToken(LangParser.NOT_EQUAL, 0)\n\t        def LESS_EQUAL(self):\n\t            return self.getToken(LangParser.LESS_EQUAL, 0)\n\t        def GREATER_EQUAL(self):\n\t            return self.getToken(LangParser.GREATER_EQUAL, 0)\n\t        def LESS(self):\n\t            return self.getToken(LangParser.LESS, 0)\n\t        def GREATER(self):\n\t            return self.getToken(LangParser.GREATER, 0)\n\t        def AND(self):\n", "            return self.getToken(LangParser.AND, 0)\n\t        def OR(self):\n\t            return self.getToken(LangParser.OR, 0)\n\t        def NOT(self):\n\t            return self.getToken(LangParser.NOT, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_boolSign\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterBoolSign\" ):\n\t                listener.enterBoolSign(self)\n", "        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitBoolSign\" ):\n\t                listener.exitBoolSign(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitBoolSign\" ):\n\t                return visitor.visitBoolSign(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def boolSign(self):\n\t        localctx = LangParser.BoolSignContext(self, self._ctx, self.state)\n", "        self.enterRule(localctx, 20, self.RULE_boolSign)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 221\n\t            _la = self._input.LA(1)\n\t            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.AND) | (1 << LangParser.OR) | (1 << LangParser.NOT) | (1 << LangParser.EQUAL) | (1 << LangParser.NOT_EQUAL) | (1 << LangParser.LESS_EQUAL) | (1 << LangParser.GREATER_EQUAL) | (1 << LangParser.LESS) | (1 << LangParser.GREATER))) != 0)):\n\t                self._errHandler.recoverInline(self)\n\t            else:\n\t                self._errHandler.reportMatch(self)\n", "                self.consume()\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class NumbSignContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n", "            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def PLUS(self):\n\t            return self.getToken(LangParser.PLUS, 0)\n\t        def MINUS(self):\n\t            return self.getToken(LangParser.MINUS, 0)\n\t        def DIV(self):\n\t            return self.getToken(LangParser.DIV, 0)\n\t        def FULL_DIV(self):\n\t            return self.getToken(LangParser.FULL_DIV, 0)\n", "        def MULT(self):\n\t            return self.getToken(LangParser.MULT, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_numbSign\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterNumbSign\" ):\n\t                listener.enterNumbSign(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitNumbSign\" ):\n\t                listener.exitNumbSign(self)\n", "        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitNumbSign\" ):\n\t                return visitor.visitNumbSign(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def numbSign(self):\n\t        localctx = LangParser.NumbSignContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 22, self.RULE_numbSign)\n\t        self._la = 0 # Token type\n\t        try:\n", "            self.enterOuterAlt(localctx, 1)\n\t            self.state = 223\n\t            _la = self._input.LA(1)\n\t            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.DIV) | (1 << LangParser.FULL_DIV) | (1 << LangParser.MULT))) != 0)):\n\t                self._errHandler.recoverInline(self)\n\t            else:\n\t                self._errHandler.reportMatch(self)\n\t                self.consume()\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n", "            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class BoolNumbSignContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def boolSign(self):\n", "            return self.getTypedRuleContext(LangParser.BoolSignContext,0)\n\t        def numbSign(self):\n\t            return self.getTypedRuleContext(LangParser.NumbSignContext,0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_boolNumbSign\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterBoolNumbSign\" ):\n\t                listener.enterBoolNumbSign(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitBoolNumbSign\" ):\n", "                listener.exitBoolNumbSign(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitBoolNumbSign\" ):\n\t                return visitor.visitBoolNumbSign(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def boolNumbSign(self):\n\t        localctx = LangParser.BoolNumbSignContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 24, self.RULE_boolNumbSign)\n\t        try:\n", "            self.state = 227\n\t            self._errHandler.sync(self)\n\t            token = self._input.LA(1)\n\t            if token in [LangParser.AND, LangParser.OR, LangParser.NOT, LangParser.EQUAL, LangParser.NOT_EQUAL, LangParser.LESS_EQUAL, LangParser.GREATER_EQUAL, LangParser.LESS, LangParser.GREATER]:\n\t                self.enterOuterAlt(localctx, 1)\n\t                self.state = 225\n\t                self.boolSign()\n\t                pass\n\t            elif token in [LangParser.PLUS, LangParser.MINUS, LangParser.DIV, LangParser.FULL_DIV, LangParser.MULT]:\n\t                self.enterOuterAlt(localctx, 2)\n", "                self.state = 226\n\t                self.numbSign()\n\t                pass\n\t            else:\n\t                raise NoViableAltException(self)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n", "            self.exitRule()\n\t        return localctx\n\t    class IterBasicTypeContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def ID(self):\n\t            return self.getToken(LangParser.ID, 0)\n\t        def COLUMN(self):\n\t            return self.getToken(LangParser.COLUMN, 0)\n", "        def ROW(self):\n\t            return self.getToken(LangParser.ROW, 0)\n\t        def TABLE(self):\n\t            return self.getToken(LangParser.TABLE, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_iterBasicType\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterIterBasicType\" ):\n\t                listener.enterIterBasicType(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n", "            if hasattr( listener, \"exitIterBasicType\" ):\n\t                listener.exitIterBasicType(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitIterBasicType\" ):\n\t                return visitor.visitIterBasicType(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def iterBasicType(self):\n\t        localctx = LangParser.IterBasicTypeContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 26, self.RULE_iterBasicType)\n", "        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 229\n\t            _la = self._input.LA(1)\n\t            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0)):\n\t                self._errHandler.recoverInline(self)\n\t            else:\n\t                self._errHandler.reportMatch(self)\n\t                self.consume()\n", "        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class BasicTypeContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n", "            self.parser = parser\n\t        def ID(self):\n\t            return self.getToken(LangParser.ID, 0)\n\t        def NUMBER(self):\n\t            return self.getToken(LangParser.NUMBER, 0)\n\t        def STRING(self):\n\t            return self.getToken(LangParser.STRING, 0)\n\t        def COLUMN(self):\n\t            return self.getToken(LangParser.COLUMN, 0)\n\t        def ROW(self):\n", "            return self.getToken(LangParser.ROW, 0)\n\t        def TABLE(self):\n\t            return self.getToken(LangParser.TABLE, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_basicType\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterBasicType\" ):\n\t                listener.enterBasicType(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitBasicType\" ):\n", "                listener.exitBasicType(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitBasicType\" ):\n\t                return visitor.visitBasicType(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def basicType(self):\n\t        localctx = LangParser.BasicTypeContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 28, self.RULE_basicType)\n\t        self._la = 0 # Token type\n", "        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 231\n\t            _la = self._input.LA(1)\n\t            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0)):\n\t                self._errHandler.recoverInline(self)\n\t            else:\n\t                self._errHandler.reportMatch(self)\n\t                self.consume()\n\t        except RecognitionException as re:\n", "            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class ReturnTypeContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n", "        def basicType(self):\n\t            return self.getTypedRuleContext(LangParser.BasicTypeContext,0)\n\t        def builtinFuncStmt(self):\n\t            return self.getTypedRuleContext(LangParser.BuiltinFuncStmtContext,0)\n\t        def indexStmt(self):\n\t            return self.getTypedRuleContext(LangParser.IndexStmtContext,0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_returnType\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterReturnType\" ):\n", "                listener.enterReturnType(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitReturnType\" ):\n\t                listener.exitReturnType(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitReturnType\" ):\n\t                return visitor.visitReturnType(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def returnType(self):\n", "        localctx = LangParser.ReturnTypeContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 30, self.RULE_returnType)\n\t        try:\n\t            self.state = 236\n\t            self._errHandler.sync(self)\n\t            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)\n\t            if la_ == 1:\n\t                self.enterOuterAlt(localctx, 1)\n\t                self.state = 233\n\t                self.basicType()\n", "                pass\n\t            elif la_ == 2:\n\t                self.enterOuterAlt(localctx, 2)\n\t                self.state = 234\n\t                self.builtinFuncStmt()\n\t                pass\n\t            elif la_ == 3:\n\t                self.enterOuterAlt(localctx, 3)\n\t                self.state = 235\n\t                self.indexStmt()\n", "                pass\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class NumbExprContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n", "            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def returnType(self):\n\t            return self.getTypedRuleContext(LangParser.ReturnTypeContext,0)\n\t        def numbExpr(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\t        def boolNumbSign(self):\n", "            return self.getTypedRuleContext(LangParser.BoolNumbSignContext,0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_numbExpr\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterNumbExpr\" ):\n\t                listener.enterNumbExpr(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitNumbExpr\" ):\n\t                listener.exitNumbExpr(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n", "            if hasattr( visitor, \"visitNumbExpr\" ):\n\t                return visitor.visitNumbExpr(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def numbExpr(self, _p:int=0):\n\t        _parentctx = self._ctx\n\t        _parentState = self.state\n\t        localctx = LangParser.NumbExprContext(self, self._ctx, _parentState)\n\t        _prevctx = localctx\n\t        _startState = 32\n", "        self.enterRecursionRule(localctx, 32, self.RULE_numbExpr, _p)\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 239\n\t            self.returnType()\n\t            self._ctx.stop = self._input.LT(-1)\n\t            self.state = 247\n\t            self._errHandler.sync(self)\n\t            _alt = self._interp.adaptivePredict(self._input,22,self._ctx)\n\t            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:\n", "                if _alt==1:\n\t                    if self._parseListeners is not None:\n\t                        self.triggerExitRuleEvent()\n\t                    _prevctx = localctx\n\t                    localctx = LangParser.NumbExprContext(self, _parentctx, _parentState)\n\t                    self.pushNewRecursionContext(localctx, _startState, self.RULE_numbExpr)\n\t                    self.state = 241\n\t                    if not self.precpred(self._ctx, 1):\n\t                        from antlr4.error.Errors import FailedPredicateException\n\t                        raise FailedPredicateException(self, \"self.precpred(self._ctx, 1)\")\n", "                    self.state = 242\n\t                    self.boolNumbSign()\n\t                    self.state = 243\n\t                    self.numbExpr(2) \n\t                self.state = 249\n\t                self._errHandler.sync(self)\n\t                _alt = self._interp.adaptivePredict(self._input,22,self._ctx)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n", "            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.unrollRecursionContexts(_parentctx)\n\t        return localctx\n\t    class BoolExprContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def numbExpr(self, i:int=None):\n\t            if i is None:\n", "                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\t        def boolSign(self):\n\t            return self.getTypedRuleContext(LangParser.BoolSignContext,0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_boolExpr\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterBoolExpr\" ):\n\t                listener.enterBoolExpr(self)\n", "        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitBoolExpr\" ):\n\t                listener.exitBoolExpr(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitBoolExpr\" ):\n\t                return visitor.visitBoolExpr(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def boolExpr(self):\n\t        localctx = LangParser.BoolExprContext(self, self._ctx, self.state)\n", "        self.enterRule(localctx, 34, self.RULE_boolExpr)\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 250\n\t            self.numbExpr(0)\n\t            self.state = 251\n\t            self.boolSign()\n\t            self.state = 252\n\t            self.numbExpr(0)\n\t        except RecognitionException as re:\n", "            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class IfElseStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n", "        def IF(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.IF)\n\t            else:\n\t                return self.getToken(LangParser.IF, i)\n\t        def boolExpr(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.BoolExprContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.BoolExprContext,i)\n", "        def LCURLY(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.LCURLY)\n\t            else:\n\t                return self.getToken(LangParser.LCURLY, i)\n\t        def RCURLY(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.RCURLY)\n\t            else:\n\t                return self.getToken(LangParser.RCURLY, i)\n", "        def funcStat(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.FuncStatContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.FuncStatContext,i)\n\t        def ELSE(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.ELSE)\n\t            else:\n\t                return self.getToken(LangParser.ELSE, i)\n", "        def getRuleIndex(self):\n\t            return LangParser.RULE_ifElseStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterIfElseStmt\" ):\n\t                listener.enterIfElseStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitIfElseStmt\" ):\n\t                listener.exitIfElseStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitIfElseStmt\" ):\n", "                return visitor.visitIfElseStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def ifElseStmt(self):\n\t        localctx = LangParser.IfElseStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 36, self.RULE_ifElseStmt)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 254\n", "            self.match(LangParser.IF)\n\t            self.state = 255\n\t            self.boolExpr()\n\t            self.state = 256\n\t            self.match(LangParser.LCURLY)\n\t            self.state = 260\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n\t                self.state = 257\n", "                self.funcStat()\n\t                self.state = 262\n\t                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n\t            self.state = 263\n\t            self.match(LangParser.RCURLY)\n\t            self.state = 278\n\t            self._errHandler.sync(self)\n\t            _alt = self._interp.adaptivePredict(self._input,25,self._ctx)\n\t            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:\n", "                if _alt==1:\n\t                    self.state = 264\n\t                    self.match(LangParser.ELSE)\n\t                    self.state = 265\n\t                    self.match(LangParser.IF)\n\t                    self.state = 266\n\t                    self.boolExpr()\n\t                    self.state = 267\n\t                    self.match(LangParser.LCURLY)\n\t                    self.state = 271\n", "                    self._errHandler.sync(self)\n\t                    _la = self._input.LA(1)\n\t                    while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n\t                        self.state = 268\n\t                        self.funcStat()\n\t                        self.state = 273\n\t                        self._errHandler.sync(self)\n\t                        _la = self._input.LA(1)\n\t                    self.state = 274\n\t                    self.match(LangParser.RCURLY) \n", "                self.state = 280\n\t                self._errHandler.sync(self)\n\t                _alt = self._interp.adaptivePredict(self._input,25,self._ctx)\n\t            self.state = 292\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            while _la==LangParser.ELSE:\n\t                self.state = 281\n\t                self.match(LangParser.ELSE)\n\t                self.state = 282\n", "                self.match(LangParser.LCURLY)\n\t                self.state = 286\n\t                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n\t                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n\t                    self.state = 283\n\t                    self.funcStat()\n\t                    self.state = 288\n\t                    self._errHandler.sync(self)\n\t                    _la = self._input.LA(1)\n", "                self.state = 289\n\t                self.match(LangParser.RCURLY)\n\t                self.state = 294\n\t                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n", "            self.exitRule()\n\t        return localctx\n\t    class WhileStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def WHILE(self):\n\t            return self.getToken(LangParser.WHILE, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n", "        def boolExpr(self):\n\t            return self.getTypedRuleContext(LangParser.BoolExprContext,0)\n\t        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def LCURLY(self):\n\t            return self.getToken(LangParser.LCURLY, 0)\n\t        def RCURLY(self):\n\t            return self.getToken(LangParser.RCURLY, 0)\n\t        def funcStat(self, i:int=None):\n\t            if i is None:\n", "                return self.getTypedRuleContexts(LangParser.FuncStatContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.FuncStatContext,i)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_whileStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterWhileStmt\" ):\n\t                listener.enterWhileStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitWhileStmt\" ):\n", "                listener.exitWhileStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitWhileStmt\" ):\n\t                return visitor.visitWhileStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def whileStmt(self):\n\t        localctx = LangParser.WhileStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 38, self.RULE_whileStmt)\n\t        self._la = 0 # Token type\n", "        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 295\n\t            self.match(LangParser.WHILE)\n\t            self.state = 296\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 297\n\t            self.boolExpr()\n\t            self.state = 298\n\t            self.match(LangParser.RPAREN)\n", "            self.state = 299\n\t            self.match(LangParser.LCURLY)\n\t            self.state = 303\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n\t                self.state = 300\n\t                self.funcStat()\n\t                self.state = 305\n\t                self._errHandler.sync(self)\n", "                _la = self._input.LA(1)\n\t            self.state = 306\n\t            self.match(LangParser.RCURLY)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n", "    class UntilStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def LCURLY(self):\n\t            return self.getToken(LangParser.LCURLY, 0)\n\t        def RCURLY(self):\n\t            return self.getToken(LangParser.RCURLY, 0)\n\t        def UNTIL(self):\n\t            return self.getToken(LangParser.UNTIL, 0)\n", "        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def boolExpr(self):\n\t            return self.getTypedRuleContext(LangParser.BoolExprContext,0)\n\t        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def funcStat(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.FuncStatContext)\n\t            else:\n", "                return self.getTypedRuleContext(LangParser.FuncStatContext,i)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_untilStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterUntilStmt\" ):\n\t                listener.enterUntilStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitUntilStmt\" ):\n\t                listener.exitUntilStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n", "            if hasattr( visitor, \"visitUntilStmt\" ):\n\t                return visitor.visitUntilStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def untilStmt(self):\n\t        localctx = LangParser.UntilStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 40, self.RULE_untilStmt)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n", "            self.state = 308\n\t            self.match(LangParser.LCURLY)\n\t            self.state = 312\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.PLUS) | (1 << LangParser.MINUS) | (1 << LangParser.LCURLY) | (1 << LangParser.FOR) | (1 << LangParser.RETURN) | (1 << LangParser.IF) | (1 << LangParser.WHILE) | (1 << LangParser.PRINT) | (1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.NUMBER_type) | (1 << LangParser.STRING_type) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.ID))) != 0):\n\t                self.state = 309\n\t                self.funcStat()\n\t                self.state = 314\n\t                self._errHandler.sync(self)\n", "                _la = self._input.LA(1)\n\t            self.state = 315\n\t            self.match(LangParser.RCURLY)\n\t            self.state = 316\n\t            self.match(LangParser.UNTIL)\n\t            self.state = 317\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 318\n\t            self.boolExpr()\n\t            self.state = 319\n", "            self.match(LangParser.RPAREN)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class CustFuncCallContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n", "            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def ID(self):\n\t            return self.getToken(LangParser.ID, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def numbExpr(self, i:int=None):\n\t            if i is None:\n", "                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\t        def COMMA(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.COMMA)\n\t            else:\n\t                return self.getToken(LangParser.COMMA, i)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_custFuncCall\n", "        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterCustFuncCall\" ):\n\t                listener.enterCustFuncCall(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitCustFuncCall\" ):\n\t                listener.exitCustFuncCall(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitCustFuncCall\" ):\n\t                return visitor.visitCustFuncCall(self)\n\t            else:\n", "                return visitor.visitChildren(self)\n\t    def custFuncCall(self):\n\t        localctx = LangParser.CustFuncCallContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 42, self.RULE_custFuncCall)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 321\n\t            self.match(LangParser.ID)\n\t            self.state = 322\n", "            self.match(LangParser.LPAREN)\n\t            self.state = 324\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):\n\t                self.state = 323\n\t                self.numbExpr(0)\n\t            self.state = 330\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n", "            while _la==LangParser.COMMA:\n\t                self.state = 326\n\t                self.match(LangParser.COMMA)\n\t                self.state = 327\n\t                self.numbExpr(0)\n\t                self.state = 332\n\t                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n\t            self.state = 333\n\t            self.match(LangParser.RPAREN)\n", "        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class IndexStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n", "            self.parser = parser\n\t        def iterBasicType(self):\n\t            return self.getTypedRuleContext(LangParser.IterBasicTypeContext,0)\n\t        def builtinFuncStmt(self):\n\t            return self.getTypedRuleContext(LangParser.BuiltinFuncStmtContext,0)\n\t        def L_SQBRACK(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.L_SQBRACK)\n\t            else:\n\t                return self.getToken(LangParser.L_SQBRACK, i)\n", "        def P_SQBRACK(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.P_SQBRACK)\n\t            else:\n\t                return self.getToken(LangParser.P_SQBRACK, i)\n\t        def numbExpr(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n", "        def getRuleIndex(self):\n\t            return LangParser.RULE_indexStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterIndexStmt\" ):\n\t                listener.enterIndexStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitIndexStmt\" ):\n\t                listener.exitIndexStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitIndexStmt\" ):\n", "                return visitor.visitIndexStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def indexStmt(self):\n\t        localctx = LangParser.IndexStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 44, self.RULE_indexStmt)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 337\n", "            self._errHandler.sync(self)\n\t            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)\n\t            if la_ == 1:\n\t                self.state = 335\n\t                self.iterBasicType()\n\t                pass\n\t            elif la_ == 2:\n\t                self.state = 336\n\t                self.builtinFuncStmt()\n\t                pass\n", "            self.state = 344 \n\t            self._errHandler.sync(self)\n\t            _alt = 1\n\t            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:\n\t                if _alt == 1:\n\t                    self.state = 339\n\t                    self.match(LangParser.L_SQBRACK)\n\t                    self.state = 341\n\t                    self._errHandler.sync(self)\n\t                    _la = self._input.LA(1)\n", "                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):\n\t                        self.state = 340\n\t                        self.numbExpr(0)\n\t                    self.state = 343\n\t                    self.match(LangParser.P_SQBRACK)\n\t                else:\n\t                    raise NoViableAltException(self)\n\t                self.state = 346 \n\t                self._errHandler.sync(self)\n\t                _alt = self._interp.adaptivePredict(self._input,34,self._ctx)\n", "        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class ListStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n", "            self.parser = parser\n\t        def L_SQBRACK(self):\n\t            return self.getToken(LangParser.L_SQBRACK, 0)\n\t        def P_SQBRACK(self):\n\t            return self.getToken(LangParser.P_SQBRACK, 0)\n\t        def listStmt(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.ListStmtContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.ListStmtContext,i)\n", "        def NUMBER(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.NUMBER)\n\t            else:\n\t                return self.getToken(LangParser.NUMBER, i)\n\t        def STRING(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.STRING)\n\t            else:\n\t                return self.getToken(LangParser.STRING, i)\n", "        def COMMA(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.COMMA)\n\t            else:\n\t                return self.getToken(LangParser.COMMA, i)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_listStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterListStmt\" ):\n\t                listener.enterListStmt(self)\n", "        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitListStmt\" ):\n\t                listener.exitListStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitListStmt\" ):\n\t                return visitor.visitListStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def listStmt(self):\n\t        localctx = LangParser.ListStmtContext(self, self._ctx, self.state)\n", "        self.enterRule(localctx, 46, self.RULE_listStmt)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 348\n\t            self.match(LangParser.L_SQBRACK)\n\t            self.state = 352\n\t            self._errHandler.sync(self)\n\t            token = self._input.LA(1)\n\t            if token in [LangParser.L_SQBRACK]:\n", "                self.state = 349\n\t                self.listStmt()\n\t                pass\n\t            elif token in [LangParser.NUMBER]:\n\t                self.state = 350\n\t                self.match(LangParser.NUMBER)\n\t                pass\n\t            elif token in [LangParser.STRING]:\n\t                self.state = 351\n\t                self.match(LangParser.STRING)\n", "                pass\n\t            elif token in [LangParser.COMMA, LangParser.P_SQBRACK]:\n\t                pass\n\t            else:\n\t                pass\n\t            self.state = 362\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            while _la==LangParser.COMMA:\n\t                self.state = 354\n", "                self.match(LangParser.COMMA)\n\t                self.state = 358\n\t                self._errHandler.sync(self)\n\t                token = self._input.LA(1)\n\t                if token in [LangParser.L_SQBRACK]:\n\t                    self.state = 355\n\t                    self.listStmt()\n\t                    pass\n\t                elif token in [LangParser.NUMBER]:\n\t                    self.state = 356\n", "                    self.match(LangParser.NUMBER)\n\t                    pass\n\t                elif token in [LangParser.STRING]:\n\t                    self.state = 357\n\t                    self.match(LangParser.STRING)\n\t                    pass\n\t                else:\n\t                    raise NoViableAltException(self)\n\t                self.state = 364\n\t                self._errHandler.sync(self)\n", "                _la = self._input.LA(1)\n\t            self.state = 365\n\t            self.match(LangParser.P_SQBRACK)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n", "    class BuiltinFuncStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def lengthStmt(self):\n\t            return self.getTypedRuleContext(LangParser.LengthStmtContext,0)\n\t        def createRowStmt(self):\n\t            return self.getTypedRuleContext(LangParser.CreateRowStmtContext,0)\n\t        def custFuncCall(self):\n\t            return self.getTypedRuleContext(LangParser.CustFuncCallContext,0)\n", "        def createTablStmt(self):\n\t            return self.getTypedRuleContext(LangParser.CreateTablStmtContext,0)\n\t        def createColStmt(self):\n\t            return self.getTypedRuleContext(LangParser.CreateColStmtContext,0)\n\t        def readStrStmt(self):\n\t            return self.getTypedRuleContext(LangParser.ReadStrStmtContext,0)\n\t        def copyStmt(self):\n\t            return self.getTypedRuleContext(LangParser.CopyStmtContext,0)\n\t        def minMaxFuncStmt(self):\n\t            return self.getTypedRuleContext(LangParser.MinMaxFuncStmtContext,0)\n", "        def delFuncStmt(self):\n\t            return self.getTypedRuleContext(LangParser.DelFuncStmtContext,0)\n\t        def reshapeStmt(self):\n\t            return self.getTypedRuleContext(LangParser.ReshapeStmtContext,0)\n\t        def insertStmt(self):\n\t            return self.getTypedRuleContext(LangParser.InsertStmtContext,0)\n\t        def findStmt(self):\n\t            return self.getTypedRuleContext(LangParser.FindStmtContext,0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_builtinFuncStmt\n", "        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterBuiltinFuncStmt\" ):\n\t                listener.enterBuiltinFuncStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitBuiltinFuncStmt\" ):\n\t                listener.exitBuiltinFuncStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitBuiltinFuncStmt\" ):\n\t                return visitor.visitBuiltinFuncStmt(self)\n\t            else:\n", "                return visitor.visitChildren(self)\n\t    def resetErrHandler(self, newErrHandler : ErrorStrategy):\n\t        self._errHandler = newErrHandler\n\t    def builtinFuncStmt(self):\n\t        localctx = LangParser.BuiltinFuncStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 48, self.RULE_builtinFuncStmt)\n\t        try:\n\t            self.state = 379\n\t            self._errHandler.sync(self)\n\t            token = self._input.LA(1)\n", "            if token in [LangParser.LENGTH]:\n\t                self.enterOuterAlt(localctx, 1)\n\t                self.state = 367\n\t                self.lengthStmt()\n\t                pass\n\t            elif token in [LangParser.CREATE_ROW]:\n\t                self.enterOuterAlt(localctx, 2)\n\t                self.state = 368\n\t                self.createRowStmt()\n\t                pass\n", "            elif token in [LangParser.ID]:\n\t                self.enterOuterAlt(localctx, 3)\n\t                self.state = 369\n\t                self.custFuncCall()\n\t                pass\n\t            elif token in [LangParser.CREATE_TABLE]:\n\t                self.enterOuterAlt(localctx, 4)\n\t                self.state = 370\n\t                self.createTablStmt()\n\t                pass\n", "            elif token in [LangParser.CREATE_COL]:\n\t                self.enterOuterAlt(localctx, 5)\n\t                self.state = 371\n\t                self.createColStmt()\n\t                pass\n\t            elif token in [LangParser.READ_STRING]:\n\t                self.enterOuterAlt(localctx, 6)\n\t                self.state = 372\n\t                self.readStrStmt()\n\t                pass\n", "            elif token in [LangParser.COPY]:\n\t                self.enterOuterAlt(localctx, 7)\n\t                self.state = 373\n\t                self.copyStmt()\n\t                pass\n\t            elif token in [LangParser.MAX, LangParser.MIN, LangParser.MAXLEN, LangParser.MINLEN]:\n\t                self.enterOuterAlt(localctx, 8)\n\t                self.state = 374\n\t                self.minMaxFuncStmt()\n\t                pass\n", "            elif token in [LangParser.DEL_COL, LangParser.DEL_ROW, LangParser.DEL]:\n\t                self.enterOuterAlt(localctx, 9)\n\t                self.state = 375\n\t                self.delFuncStmt()\n\t                pass\n\t            elif token in [LangParser.RESHAPE]:\n\t                self.enterOuterAlt(localctx, 10)\n\t                self.state = 376\n\t                self.reshapeStmt()\n\t                pass\n", "            elif token in [LangParser.INSERT]:\n\t                self.enterOuterAlt(localctx, 11)\n\t                self.state = 377\n\t                self.insertStmt()\n\t                pass\n\t            elif token in [LangParser.FIND]:\n\t                self.enterOuterAlt(localctx, 12)\n\t                self.state = 378\n\t                self.findStmt()\n\t                pass\n", "            else:\n\t                raise NoViableAltException(self)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class LengthStmtContext(ParserRuleContext):\n", "        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def LENGTH(self):\n\t            return self.getToken(LangParser.LENGTH, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def numbExpr(self):\n\t            return self.getTypedRuleContext(LangParser.NumbExprContext,0)\n\t        def RPAREN(self):\n", "            return self.getToken(LangParser.RPAREN, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_lengthStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterLengthStmt\" ):\n\t                listener.enterLengthStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitLengthStmt\" ):\n\t                listener.exitLengthStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n", "            if hasattr( visitor, \"visitLengthStmt\" ):\n\t                return visitor.visitLengthStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def lengthStmt(self):\n\t        localctx = LangParser.LengthStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 50, self.RULE_lengthStmt)\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 381\n", "            self.match(LangParser.LENGTH)\n\t            self.state = 382\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 383\n\t            self.numbExpr(0)\n\t            self.state = 384\n\t            self.match(LangParser.RPAREN)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n", "            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class ReturnStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def RETURN(self):\n\t            return self.getToken(LangParser.RETURN, 0)\n", "        def numbExpr(self):\n\t            return self.getTypedRuleContext(LangParser.NumbExprContext,0)\n\t        def SEMI(self):\n\t            return self.getToken(LangParser.SEMI, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_returnStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterReturnStmt\" ):\n\t                listener.enterReturnStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n", "            if hasattr( listener, \"exitReturnStmt\" ):\n\t                listener.exitReturnStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitReturnStmt\" ):\n\t                return visitor.visitReturnStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def returnStmt(self):\n\t        localctx = LangParser.ReturnStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 52, self.RULE_returnStmt)\n", "        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 386\n\t            self.match(LangParser.RETURN)\n\t            self.state = 387\n\t            self.numbExpr(0)\n\t            self.state = 388\n\t            self.match(LangParser.SEMI)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n", "            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class CreateRowStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def CREATE_ROW(self):\n", "            return self.getToken(LangParser.CREATE_ROW, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def NUMBER(self):\n\t            return self.getToken(LangParser.NUMBER, 0)\n\t        def COMMA(self):\n\t            return self.getToken(LangParser.COMMA, 0)\n\t        def listStmt(self):\n", "            return self.getTypedRuleContext(LangParser.ListStmtContext,0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_createRowStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterCreateRowStmt\" ):\n\t                listener.enterCreateRowStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitCreateRowStmt\" ):\n\t                listener.exitCreateRowStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n", "            if hasattr( visitor, \"visitCreateRowStmt\" ):\n\t                return visitor.visitCreateRowStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def createRowStmt(self):\n\t        localctx = LangParser.CreateRowStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 54, self.RULE_createRowStmt)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n", "            self.state = 390\n\t            self.match(LangParser.CREATE_ROW)\n\t            self.state = 391\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 393\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if _la==LangParser.NUMBER:\n\t                self.state = 392\n\t                self.match(LangParser.NUMBER)\n", "            self.state = 397\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if _la==LangParser.COMMA:\n\t                self.state = 395\n\t                self.match(LangParser.COMMA)\n\t                self.state = 396\n\t                self.listStmt()\n\t            self.state = 399\n\t            self.match(LangParser.RPAREN)\n", "        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class CreateTablStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n", "            self.parser = parser\n\t        def CREATE_TABLE(self):\n\t            return self.getToken(LangParser.CREATE_TABLE, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def NUMBER(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.NUMBER)\n", "            else:\n\t                return self.getToken(LangParser.NUMBER, i)\n\t        def COMMA(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.COMMA)\n\t            else:\n\t                return self.getToken(LangParser.COMMA, i)\n\t        def listStmt(self):\n\t            return self.getTypedRuleContext(LangParser.ListStmtContext,0)\n\t        def getRuleIndex(self):\n", "            return LangParser.RULE_createTablStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterCreateTablStmt\" ):\n\t                listener.enterCreateTablStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitCreateTablStmt\" ):\n\t                listener.exitCreateTablStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitCreateTablStmt\" ):\n\t                return visitor.visitCreateTablStmt(self)\n", "            else:\n\t                return visitor.visitChildren(self)\n\t    def createTablStmt(self):\n\t        localctx = LangParser.CreateTablStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 56, self.RULE_createTablStmt)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 401\n\t            self.match(LangParser.CREATE_TABLE)\n", "            self.state = 402\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 404\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if _la==LangParser.NUMBER:\n\t                self.state = 403\n\t                self.match(LangParser.NUMBER)\n\t            self.state = 410\n\t            self._errHandler.sync(self)\n", "            _alt = self._interp.adaptivePredict(self._input,42,self._ctx)\n\t            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:\n\t                if _alt==1:\n\t                    self.state = 406\n\t                    self.match(LangParser.COMMA)\n\t                    self.state = 407\n\t                    self.match(LangParser.NUMBER) \n\t                self.state = 412\n\t                self._errHandler.sync(self)\n\t                _alt = self._interp.adaptivePredict(self._input,42,self._ctx)\n", "            self.state = 415\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if _la==LangParser.COMMA:\n\t                self.state = 413\n\t                self.match(LangParser.COMMA)\n\t                self.state = 414\n\t                self.listStmt()\n\t            self.state = 417\n\t            self.match(LangParser.RPAREN)\n", "        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class CreateColStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n", "            self.parser = parser\n\t        def CREATE_COL(self):\n\t            return self.getToken(LangParser.CREATE_COL, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def NUMBER(self):\n\t            return self.getToken(LangParser.NUMBER, 0)\n\t        def COMMA(self):\n", "            return self.getToken(LangParser.COMMA, 0)\n\t        def listStmt(self):\n\t            return self.getTypedRuleContext(LangParser.ListStmtContext,0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_createColStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterCreateColStmt\" ):\n\t                listener.enterCreateColStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitCreateColStmt\" ):\n", "                listener.exitCreateColStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitCreateColStmt\" ):\n\t                return visitor.visitCreateColStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def createColStmt(self):\n\t        localctx = LangParser.CreateColStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 58, self.RULE_createColStmt)\n\t        self._la = 0 # Token type\n", "        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 419\n\t            self.match(LangParser.CREATE_COL)\n\t            self.state = 420\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 422\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if _la==LangParser.NUMBER:\n", "                self.state = 421\n\t                self.match(LangParser.NUMBER)\n\t            self.state = 426\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if _la==LangParser.COMMA:\n\t                self.state = 424\n\t                self.match(LangParser.COMMA)\n\t                self.state = 425\n\t                self.listStmt()\n", "            self.state = 428\n\t            self.match(LangParser.RPAREN)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class CopyStmtContext(ParserRuleContext):\n", "        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def COPY(self):\n\t            return self.getToken(LangParser.COPY, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def ID(self):\n\t            return self.getToken(LangParser.ID, 0)\n\t        def RPAREN(self):\n", "            return self.getToken(LangParser.RPAREN, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_copyStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterCopyStmt\" ):\n\t                listener.enterCopyStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitCopyStmt\" ):\n\t                listener.exitCopyStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n", "            if hasattr( visitor, \"visitCopyStmt\" ):\n\t                return visitor.visitCopyStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def copyStmt(self):\n\t        localctx = LangParser.CopyStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 60, self.RULE_copyStmt)\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 430\n", "            self.match(LangParser.COPY)\n\t            self.state = 431\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 432\n\t            self.match(LangParser.ID)\n\t            self.state = 433\n\t            self.match(LangParser.RPAREN)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n", "            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class MinMaxFuncContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def MAX(self):\n\t            return self.getToken(LangParser.MAX, 0)\n", "        def MIN(self):\n\t            return self.getToken(LangParser.MIN, 0)\n\t        def MAXLEN(self):\n\t            return self.getToken(LangParser.MAXLEN, 0)\n\t        def MINLEN(self):\n\t            return self.getToken(LangParser.MINLEN, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_minMaxFunc\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterMinMaxFunc\" ):\n", "                listener.enterMinMaxFunc(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitMinMaxFunc\" ):\n\t                listener.exitMinMaxFunc(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitMinMaxFunc\" ):\n\t                return visitor.visitMinMaxFunc(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def minMaxFunc(self):\n", "        localctx = LangParser.MinMaxFuncContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 62, self.RULE_minMaxFunc)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 435\n\t            _la = self._input.LA(1)\n\t            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN))) != 0)):\n\t                self._errHandler.recoverInline(self)\n\t            else:\n", "                self._errHandler.reportMatch(self)\n\t                self.consume()\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class MinMaxFuncStmtContext(ParserRuleContext):\n", "        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def minMaxFunc(self):\n\t            return self.getTypedRuleContext(LangParser.MinMaxFuncContext,0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def numbExpr(self):\n\t            return self.getTypedRuleContext(LangParser.NumbExprContext,0)\n\t        def RPAREN(self):\n", "            return self.getToken(LangParser.RPAREN, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_minMaxFuncStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterMinMaxFuncStmt\" ):\n\t                listener.enterMinMaxFuncStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitMinMaxFuncStmt\" ):\n\t                listener.exitMinMaxFuncStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n", "            if hasattr( visitor, \"visitMinMaxFuncStmt\" ):\n\t                return visitor.visitMinMaxFuncStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def minMaxFuncStmt(self):\n\t        localctx = LangParser.MinMaxFuncStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 64, self.RULE_minMaxFuncStmt)\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 437\n", "            self.minMaxFunc()\n\t            self.state = 438\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 439\n\t            self.numbExpr(0)\n\t            self.state = 440\n\t            self.match(LangParser.RPAREN)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n", "            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class DelFuncContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def DEL_COL(self):\n\t            return self.getToken(LangParser.DEL_COL, 0)\n", "        def DEL_ROW(self):\n\t            return self.getToken(LangParser.DEL_ROW, 0)\n\t        def DEL(self):\n\t            return self.getToken(LangParser.DEL, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_delFunc\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterDelFunc\" ):\n\t                listener.enterDelFunc(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n", "            if hasattr( listener, \"exitDelFunc\" ):\n\t                listener.exitDelFunc(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitDelFunc\" ):\n\t                return visitor.visitDelFunc(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def delFunc(self):\n\t        localctx = LangParser.DelFuncContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 66, self.RULE_delFunc)\n", "        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 442\n\t            _la = self._input.LA(1)\n\t            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL))) != 0)):\n\t                self._errHandler.recoverInline(self)\n\t            else:\n\t                self._errHandler.reportMatch(self)\n\t                self.consume()\n", "        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class DelFuncStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n", "            self.parser = parser\n\t        def delFunc(self):\n\t            return self.getTypedRuleContext(LangParser.DelFuncContext,0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def numbExpr(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n", "        def COMMA(self):\n\t            return self.getToken(LangParser.COMMA, 0)\n\t        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_delFuncStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterDelFuncStmt\" ):\n\t                listener.enterDelFuncStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n", "            if hasattr( listener, \"exitDelFuncStmt\" ):\n\t                listener.exitDelFuncStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitDelFuncStmt\" ):\n\t                return visitor.visitDelFuncStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def delFuncStmt(self):\n\t        localctx = LangParser.DelFuncStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 68, self.RULE_delFuncStmt)\n", "        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 444\n\t            self.delFunc()\n\t            self.state = 445\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 446\n\t            self.numbExpr(0)\n\t            self.state = 447\n\t            self.match(LangParser.COMMA)\n", "            self.state = 448\n\t            self.numbExpr(0)\n\t            self.state = 449\n\t            self.match(LangParser.RPAREN)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n", "        return localctx\n\t    class ReshapeStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def RESHAPE(self):\n\t            return self.getToken(LangParser.RESHAPE, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def numbExpr(self, i:int=None):\n", "            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\t        def COMMA(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.COMMA)\n\t            else:\n\t                return self.getToken(LangParser.COMMA, i)\n\t        def RPAREN(self):\n", "            return self.getToken(LangParser.RPAREN, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_reshapeStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterReshapeStmt\" ):\n\t                listener.enterReshapeStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitReshapeStmt\" ):\n\t                listener.exitReshapeStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n", "            if hasattr( visitor, \"visitReshapeStmt\" ):\n\t                return visitor.visitReshapeStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def reshapeStmt(self):\n\t        localctx = LangParser.ReshapeStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 70, self.RULE_reshapeStmt)\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 451\n", "            self.match(LangParser.RESHAPE)\n\t            self.state = 452\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 453\n\t            self.numbExpr(0)\n\t            self.state = 454\n\t            self.match(LangParser.COMMA)\n\t            self.state = 455\n\t            self.numbExpr(0)\n\t            self.state = 456\n", "            self.match(LangParser.COMMA)\n\t            self.state = 457\n\t            self.numbExpr(0)\n\t            self.state = 458\n\t            self.match(LangParser.RPAREN)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n", "            self.exitRule()\n\t        return localctx\n\t    class InsertStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def INSERT(self):\n\t            return self.getToken(LangParser.INSERT, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n", "        def numbExpr(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\t        def COMMA(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.COMMA)\n\t            else:\n\t                return self.getToken(LangParser.COMMA, i)\n", "        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_insertStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterInsertStmt\" ):\n\t                listener.enterInsertStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitInsertStmt\" ):\n\t                listener.exitInsertStmt(self)\n", "        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitInsertStmt\" ):\n\t                return visitor.visitInsertStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def insertStmt(self):\n\t        localctx = LangParser.InsertStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 72, self.RULE_insertStmt)\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n", "            self.state = 460\n\t            self.match(LangParser.INSERT)\n\t            self.state = 461\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 462\n\t            self.numbExpr(0)\n\t            self.state = 463\n\t            self.match(LangParser.COMMA)\n\t            self.state = 464\n\t            self.numbExpr(0)\n", "            self.state = 465\n\t            self.match(LangParser.COMMA)\n\t            self.state = 466\n\t            self.numbExpr(0)\n\t            self.state = 467\n\t            self.match(LangParser.RPAREN)\n\t        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n", "        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class FindStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n\t        def FIND(self):\n\t            return self.getToken(LangParser.FIND, 0)\n\t        def LPAREN(self):\n", "            return self.getToken(LangParser.LPAREN, 0)\n\t        def numbExpr(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n\t            else:\n\t                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\t        def COMMA(self):\n\t            return self.getToken(LangParser.COMMA, 0)\n\t        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n", "        def getRuleIndex(self):\n\t            return LangParser.RULE_findStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterFindStmt\" ):\n\t                listener.enterFindStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitFindStmt\" ):\n\t                listener.exitFindStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitFindStmt\" ):\n", "                return visitor.visitFindStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def findStmt(self):\n\t        localctx = LangParser.FindStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 74, self.RULE_findStmt)\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 469\n\t            self.match(LangParser.FIND)\n", "            self.state = 470\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 471\n\t            self.numbExpr(0)\n\t            self.state = 472\n\t            self.match(LangParser.COMMA)\n\t            self.state = 473\n\t            self.numbExpr(0)\n\t            self.state = 474\n\t            self.match(LangParser.RPAREN)\n", "        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class PrintStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n", "            self.parser = parser\n\t        def PRINT(self):\n\t            return self.getToken(LangParser.PRINT, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def numbExpr(self, i:int=None):\n\t            if i is None:\n\t                return self.getTypedRuleContexts(LangParser.NumbExprContext)\n", "            else:\n\t                return self.getTypedRuleContext(LangParser.NumbExprContext,i)\n\t        def COMMA(self, i:int=None):\n\t            if i is None:\n\t                return self.getTokens(LangParser.COMMA)\n\t            else:\n\t                return self.getToken(LangParser.COMMA, i)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_printStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n", "            if hasattr( listener, \"enterPrintStmt\" ):\n\t                listener.enterPrintStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitPrintStmt\" ):\n\t                listener.exitPrintStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitPrintStmt\" ):\n\t                return visitor.visitPrintStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n", "    def printStmt(self):\n\t        localctx = LangParser.PrintStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 76, self.RULE_printStmt)\n\t        self._la = 0 # Token type\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 476\n\t            self.match(LangParser.PRINT)\n\t            self.state = 477\n\t            self.match(LangParser.LPAREN)\n", "            self.state = 479\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LangParser.LENGTH) | (1 << LangParser.RESHAPE) | (1 << LangParser.DEL_COL) | (1 << LangParser.DEL_ROW) | (1 << LangParser.DEL) | (1 << LangParser.INSERT) | (1 << LangParser.MAX) | (1 << LangParser.MIN) | (1 << LangParser.MAXLEN) | (1 << LangParser.MINLEN) | (1 << LangParser.FIND) | (1 << LangParser.CREATE_ROW) | (1 << LangParser.CREATE_TABLE) | (1 << LangParser.CREATE_COL) | (1 << LangParser.READ_STRING) | (1 << LangParser.COPY) | (1 << LangParser.TABLE) | (1 << LangParser.COLUMN) | (1 << LangParser.ROW) | (1 << LangParser.NUMBER) | (1 << LangParser.STRING) | (1 << LangParser.ID))) != 0):\n\t                self.state = 478\n\t                self.numbExpr(0)\n\t            self.state = 485\n\t            self._errHandler.sync(self)\n\t            _la = self._input.LA(1)\n\t            while _la==LangParser.COMMA:\n", "                self.state = 481\n\t                self.match(LangParser.COMMA)\n\t                self.state = 482\n\t                self.numbExpr(0)\n\t                self.state = 487\n\t                self._errHandler.sync(self)\n\t                _la = self._input.LA(1)\n\t            self.state = 488\n\t            self.match(LangParser.RPAREN)\n\t        except RecognitionException as re:\n", "            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    class ReadStrStmtContext(ParserRuleContext):\n\t        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):\n\t            super().__init__(parent, invokingState)\n\t            self.parser = parser\n", "        def READ_STRING(self):\n\t            return self.getToken(LangParser.READ_STRING, 0)\n\t        def LPAREN(self):\n\t            return self.getToken(LangParser.LPAREN, 0)\n\t        def RPAREN(self):\n\t            return self.getToken(LangParser.RPAREN, 0)\n\t        def getRuleIndex(self):\n\t            return LangParser.RULE_readStrStmt\n\t        def enterRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"enterReadStrStmt\" ):\n", "                listener.enterReadStrStmt(self)\n\t        def exitRule(self, listener:ParseTreeListener):\n\t            if hasattr( listener, \"exitReadStrStmt\" ):\n\t                listener.exitReadStrStmt(self)\n\t        def accept(self, visitor:ParseTreeVisitor):\n\t            if hasattr( visitor, \"visitReadStrStmt\" ):\n\t                return visitor.visitReadStrStmt(self)\n\t            else:\n\t                return visitor.visitChildren(self)\n\t    def readStrStmt(self):\n", "        localctx = LangParser.ReadStrStmtContext(self, self._ctx, self.state)\n\t        self.enterRule(localctx, 78, self.RULE_readStrStmt)\n\t        try:\n\t            self.enterOuterAlt(localctx, 1)\n\t            self.state = 490\n\t            self.match(LangParser.READ_STRING)\n\t            self.state = 491\n\t            self.match(LangParser.LPAREN)\n\t            self.state = 492\n\t            self.match(LangParser.RPAREN)\n", "        except RecognitionException as re:\n\t            localctx.exception = re\n\t            self._errHandler.reportError(self, re, localctx)\n\t            self._errHandler.recover(self, re)\n\t        finally:\n\t            self.exitRule()\n\t        return localctx\n\t    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):\n\t        if self._predicates == None:\n\t            self._predicates = dict()\n", "        self._predicates[16] = self.numbExpr_sempred\n\t        pred = self._predicates.get(ruleIndex, None)\n\t        if pred is None:\n\t            raise Exception(\"No predicate with index:\" + str(ruleIndex))\n\t        else:\n\t            return pred(localctx, predIndex)\n\t    def numbExpr_sempred(self, localctx:NumbExprContext, predIndex:int):\n\t            if predIndex == 0:\n\t                return self.precpred(self._ctx, 1)\n"]}
{"filename": "parser/LangParserVisitor.py", "chunked_list": ["# Generated from LangParser.g4 by ANTLR 4.7.2\n\tfrom antlr4 import *\n\tif __name__ is not None and \".\" in __name__:\n\t    from .LangParser import LangParser\n\telse:\n\t    from LangParser import LangParser\n\t# This class defines a complete generic visitor for a parse tree produced by LangParser.\n\tclass LangParserVisitor(ParseTreeVisitor):\n\t    # Visit a parse tree produced by LangParser#program.\n\t    def visitProgram(self, ctx:LangParser.ProgramContext):\n", "        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#func.\n\t    def visitFunc(self, ctx:LangParser.FuncContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#stat.\n\t    def visitStat(self, ctx:LangParser.StatContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#funcStat.\n\t    def visitFuncStat(self, ctx:LangParser.FuncStatContext):\n\t        return self.visitChildren(ctx)\n", "    # Visit a parse tree produced by LangParser#forStat.\n\t    def visitForStat(self, ctx:LangParser.ForStatContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#assignExpr.\n\t    def visitAssignExpr(self, ctx:LangParser.AssignExprContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#varDeclStmt.\n\t    def visitVarDeclStmt(self, ctx:LangParser.VarDeclStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#incDecrStat.\n", "    def visitIncDecrStat(self, ctx:LangParser.IncDecrStatContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#assignSign.\n\t    def visitAssignSign(self, ctx:LangParser.AssignSignContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#basicTypeName.\n\t    def visitBasicTypeName(self, ctx:LangParser.BasicTypeNameContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#boolSign.\n\t    def visitBoolSign(self, ctx:LangParser.BoolSignContext):\n", "        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#numbSign.\n\t    def visitNumbSign(self, ctx:LangParser.NumbSignContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#boolNumbSign.\n\t    def visitBoolNumbSign(self, ctx:LangParser.BoolNumbSignContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#iterBasicType.\n\t    def visitIterBasicType(self, ctx:LangParser.IterBasicTypeContext):\n\t        return self.visitChildren(ctx)\n", "    # Visit a parse tree produced by LangParser#basicType.\n\t    def visitBasicType(self, ctx:LangParser.BasicTypeContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#returnType.\n\t    def visitReturnType(self, ctx:LangParser.ReturnTypeContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#numbExpr.\n\t    def visitNumbExpr(self, ctx:LangParser.NumbExprContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#boolExpr.\n", "    def visitBoolExpr(self, ctx:LangParser.BoolExprContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#ifElseStmt.\n\t    def visitIfElseStmt(self, ctx:LangParser.IfElseStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#whileStmt.\n\t    def visitWhileStmt(self, ctx:LangParser.WhileStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#untilStmt.\n\t    def visitUntilStmt(self, ctx:LangParser.UntilStmtContext):\n", "        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#custFuncCall.\n\t    def visitCustFuncCall(self, ctx:LangParser.CustFuncCallContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#indexStmt.\n\t    def visitIndexStmt(self, ctx:LangParser.IndexStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#listStmt.\n\t    def visitListStmt(self, ctx:LangParser.ListStmtContext):\n\t        return self.visitChildren(ctx)\n", "    # Visit a parse tree produced by LangParser#builtinFuncStmt.\n\t    def visitBuiltinFuncStmt(self, ctx:LangParser.BuiltinFuncStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#lengthStmt.\n\t    def visitLengthStmt(self, ctx:LangParser.LengthStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#returnStmt.\n\t    def visitReturnStmt(self, ctx:LangParser.ReturnStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#createRowStmt.\n", "    def visitCreateRowStmt(self, ctx:LangParser.CreateRowStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#createTablStmt.\n\t    def visitCreateTablStmt(self, ctx:LangParser.CreateTablStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#createColStmt.\n\t    def visitCreateColStmt(self, ctx:LangParser.CreateColStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#copyStmt.\n\t    def visitCopyStmt(self, ctx:LangParser.CopyStmtContext):\n", "        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#minMaxFunc.\n\t    def visitMinMaxFunc(self, ctx:LangParser.MinMaxFuncContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#minMaxFuncStmt.\n\t    def visitMinMaxFuncStmt(self, ctx:LangParser.MinMaxFuncStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#delFunc.\n\t    def visitDelFunc(self, ctx:LangParser.DelFuncContext):\n\t        return self.visitChildren(ctx)\n", "    # Visit a parse tree produced by LangParser#delFuncStmt.\n\t    def visitDelFuncStmt(self, ctx:LangParser.DelFuncStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#reshapeStmt.\n\t    def visitReshapeStmt(self, ctx:LangParser.ReshapeStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#insertStmt.\n\t    def visitInsertStmt(self, ctx:LangParser.InsertStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#findStmt.\n", "    def visitFindStmt(self, ctx:LangParser.FindStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#printStmt.\n\t    def visitPrintStmt(self, ctx:LangParser.PrintStmtContext):\n\t        return self.visitChildren(ctx)\n\t    # Visit a parse tree produced by LangParser#readStrStmt.\n\t    def visitReadStrStmt(self, ctx:LangParser.ReadStrStmtContext):\n\t        return self.visitChildren(ctx)\n\tdel LangParser"]}
{"filename": "src/configs.py", "chunked_list": ["import json \n\tif __name__ == '__main__':\n\t    dict_ = {\n\t        \"MAX_STR_SIZE\": 20,\n\t        \"MAX_ARR_SIZE\": 1000\n\t    }\n\t    with open(\"src/confs.json\", 'w', encoding='utf-8') as conffile:\n\t        json.dump(dict_, conffile)\n\twith open(\"src/confs.json\", 'r', encoding='utf-8') as conffile:\n\t    confs = json.load(conffile)\n", "MAX_STR_SIZE = confs[\"MAX_STR_SIZE\"]\n\tMAX_ARR_SIZE = confs[\"MAX_ARR_SIZE\"]\n"]}
{"filename": "src/basic_types.py", "chunked_list": ["from llvmlite import ir\n\tfrom src.configs import MAX_STR_SIZE\n\ti8 = ir.IntType(8)\n\ti32 = ir.IntType(32)\n\tarray = ir.ArrayType\n\tvoid = ir.VoidType()\n\tstring = i8.as_pointer()\n\titer = i8.as_pointer().as_pointer()\n\tnumber = ir.DoubleType()\n"]}
{"filename": "src/RowVariable.py", "chunked_list": ["from llvmlite import ir\n\tfrom src.IterVariable import IterVariable\n\tfrom basic_types import iter\n\tclass RowVariable(IterVariable):\n\t    def __init__(self, elements: tuple = None, builder: ir.builder.IRBuilder = None, ptr=None) -> None:\n\t        super().__init__(elements, len(elements), builder, ptr)\n\t    def set_value(self, value):\n\t        self.size = value.size\n\t        self.type = value.type\n\t        self.var = value.var\n", "        self.compile_init()\n\t    def get_value(self):\n\t        return self.ptr\n\t    def get_element(self, index: int):\n\t        return self.ptr\n\t    def insert_element(self, value: int | str, index):\n\t        return self.builder.insert_value(self.ptr, value, index)\n"]}
{"filename": "src/utils.py", "chunked_list": ["import string\n\timport random\n"]}
{"filename": "src/Function.py", "chunked_list": ["from typing import Any, Sequence, Union\n\tfrom llvmlite import ir\n\tfrom src.variables import *\n\tclass Function:\n\t    def __init__(self, module: ir.Module, function_type: ir.FunctionType, name: str, return_var_type: Variable | Sequence[Variable]) -> None:\n\t        self.arg_types = function_type.args\n\t        self._return_type = return_var_type\n\t        self.type = function_type\n\t        self._function = ir.Function(\n\t            module, \n", "            function_type,\n\t            name\n\t        )\n\t        self._is_convert_func = \"toDynamic\" in name   # if function is used for dynamic converting -> return raw alloca inst\n\t    def _save_function_result(self, func_res: ir.AllocaInstr, builder: ir.builder, result_size: int | list, first_arg_type: Variable) -> Variable | ir.AllocaInstr:\n\t        if self._is_convert_func:\n\t            return func_res\n\t        if self._return_type == VoidVariable:\n\t            return None\n\t        elif self._return_type == StringVariable:\n", "            return StringVariable(func_res, builder)\n\t        elif self._return_type == TableVariable:\n\t            return TableVariable(func_res, *result_size, builder)\n\t        elif self._return_type == IterVariable:\n\t            return IterVariable(func_res, result_size, builder)\n\t        elif isinstance(self._return_type, list):\n\t            if first_arg_type not in [RowVariable, ColumnVariable, TableVariable]:\n\t                raise ValueError(f\"Arg type - {first_arg_type}\")\n\t            if first_arg_type in [RowVariable, ColumnVariable]:\n\t                return first_arg_type(func_res, result_size, builder)\n", "            else:\n\t                return first_arg_type(func_res, *result_size, builder)\n\t    def __call__(self, builder: ir.builder, *args, **kwargs) -> Any:\n\t        raw_args = [arg.get_value() for arg in args]\n\t        function_result = builder.call(self._function, raw_args)\n\t        return self._save_function_result(function_result, builder, kwargs.get(\"result_size\"), type(args[0]))\n"]}
{"filename": "src/compilers/ExpressionCompiler.py", "chunked_list": ["from src.variables import NumbVariable, Variable\n\tfrom llvmlite import ir\n\tclass ExpressionCompiler:\n\t    def __init__(self) -> None:\n\t        pass\n\t    def increment_variable(self, var: NumbVariable, builder: ir.builder.IRBuilder):\n\t        temp_val = builder.load(var.ptr)\n\t        new_val = builder.fadd(temp_val, ir.Constant(ir.DoubleType(), 1.))\n\t        builder.store(new_val, var.ptr)\n\t        return var\n", "    def decrement_variable(self, var: NumbVariable, builder: ir.builder.IRBuilder):\n\t        temp_val = builder.load(var.ptr)\n\t        new_val = builder.fsub(temp_val, ir.Constant(ir.DoubleType(), 1.))\n\t        builder.store(new_val, var.ptr)\n\t        return var\n\t    def process_numb_expr(self, first_var: Variable, operation_sign: str, second_var: Variable):\n\t        if isinstance(first_var, NumbVariable) and isinstance(second_var, NumbVariable):\n\t            if operation_sign == '+':\n\t                return first_var + second_var\n\t            elif operation_sign == '-':\n", "                return first_var - second_var\n\t            elif operation_sign == '/':\n\t                return first_var / second_var\n\t            elif operation_sign == '//':\n\t                return first_var // second_var\n\t            elif operation_sign == '*':\n\t                return first_var * second_var\n\t            elif operation_sign == '==':\n\t                return first_var == second_var\n\t            elif operation_sign == '!=':\n", "                return first_var != second_var\n\t        raise ValueError(f\"Uknown operation operands and sign - {first_var}, {operation_sign}, {second_var}\")\n"]}
{"filename": "src/compilers/AssignExpressionCompiler.py", "chunked_list": ["from llvmlite.ir import Module\n\tfrom src.variables import Variable\n\tclass AssignExpressionCompiler:\n\t    def __init__(self, module: Module) -> None:\n\t        self._module = module\n\t    def compile_assign_expr(self, variable: Variable, assign_sign: str, value: Variable) -> None:\n\t        if assign_sign == '=':\n\t            variable.set_value(value)\n\t        elif assign_sign == '+=':\n\t            variable.set_value(variable + value)\n", "        elif assign_sign == '-=':\n\t            variable.set_value(variable - value)\n\t        elif assign_sign == '/=':\n\t            variable.set_value(variable / value)\n\t        elif assign_sign == '*=':\n\t            variable.set_value(variable * value)\n\t        else:\n\t            raise ValueError(f\"Unknown assign sign - {assign_sign}\")"]}
{"filename": "src/compilers/FunctionCompiler.py", "chunked_list": ["from llvmlite.ir import Module\n\tfrom llvmlite import ir\n\tfrom src.basic_types import *\n\tfrom src.configs import MAX_STR_SIZE, MAX_ARR_SIZE\n\tfrom src.Function import Function\n\tfrom src.variables import *\n\tclass FunctionCompiler:\n\t    def __init__(self, module: Module) -> None:\n\t        self.module = module\n\t        self._functions = {}\n", "        self._load_builtin_functions()\n\t        self._call_function_map = {\n\t            \"print\": self.call_print_func,\n\t            \"length\": self.call_length_func,\n\t            \"del\": self.call_del_func,\n\t            \"copy\": self.call_copy_func\n\t        }\n\t        StringVariable.convert_func = self._functions[\"toDynamicStr\"]\n\t        IterVariable.convert_func = self._functions[\"toDynamic2\"]\n\t    def _load_builtin_functions(self):\n", "        function_parameters = [\n\t            [VoidVariable, [string], \"printf\", True],\n\t            [NumbVariable, [], \"length\", False],\n\t            [VoidVariable, [iter, number, number], \"print_row_or_column\", False],\n\t            [StringVariable, [], \"read_string\", False],\n\t            [VoidVariable, [iter, number, number], \"print_table\", False],\n\t            [TableVariable, [iter, number, number, iter, number, number], \"mul_tables\", False],\n\t            [[RowVariable, ColumnVariable, TableVariable], [number, ir.ArrayType(ir.ArrayType(i8, MAX_STR_SIZE), MAX_ARR_SIZE).as_pointer()], \"toDynamic2\", False],\n\t            [StringVariable, [ir.ArrayType(ir.IntType(8), MAX_STR_SIZE).as_pointer()], \"toDynamicStr\", False],\n\t            [[RowVariable, ColumnVariable], [iter, number, number], \"delete_el\", False]\n", "        ]\n\t        for func_params in function_parameters:\n\t            self._save_func_to_dict(*func_params)\n\t    def _save_func_to_dict(self, return_var: Variable, arg_types: list, name: str, var_arg: bool = False):\n\t        function = Function(\n\t            self.module,\n\t            ir.FunctionType(\n\t                return_var.basic_type if not isinstance(return_var, list) else iter,\n\t                arg_types,\n\t                var_arg=var_arg\n", "            ),\n\t            name,\n\t            return_var\n\t        )\n\t        self._functions[name] = function\n\t    def get_function_by_name(self, name: str) -> ir.Function:\n\t        return self._functions.get(name)\n\t    def call_function(self, name: str, args: list, builder: ir.builder.IRBuilder):\n\t        call_function_var = self._call_function_map[name] if self._call_function_map.get(name) is not None \\\n\t                                                          else self._functions[name]\n", "        return call_function_var(builder, *args)\n\t    def call_mult_tables_function(self, builder: ir.builder.IRBuilder, first_table: TableVariable, second_table: TableVariable):\n\t        if first_table.n_rows != second_table.n_rows:\n\t            raise ValueError(\"N rows is not equal\")\n\t        args = (\n\t            first_table,\n\t            NumbVariable(first_table.n_rows, builder),\n\t            NumbVariable(second_table.n_cols, builder),\n\t            second_table,\n\t            NumbVariable(second_table.n_rows, builder),\n", "            NumbVariable(second_table.n_cols, builder)\n\t        )\n\t    def call_print_func(self, builder: ir.builder.IRBuilder, variable: RowVariable | NumbVariable | TableVariable | ColumnVariable | StringVariable) -> VoidVariable:\n\t        if isinstance(variable, NumbVariable):\n\t            format_string = StringVariable(\"%.3f\\n\\0\", builder)\n\t            return self._functions[\"printf\"](builder, format_string, variable)\n\t        elif isinstance(variable, StringVariable):\n\t            format_string = StringVariable(\"%s\\n\\0\", builder)\n\t            return self._functions[\"printf\"](builder, format_string, variable)\n\t        elif isinstance(variable, (ColumnVariable, RowVariable)):\n", "            is_column = NumbVariable(1, builder) if isinstance(variable, ColumnVariable) else NumbVariable(0, builder)\n\t            return self._functions[\"print_row_or_column\"](builder, variable, variable.size, is_column)\n\t        elif isinstance(variable, TableVariable):\n\t            return self._functions[\"print_table\"](builder, variable, variable.n_rows, variable.n_cols)\n\t    def call_length_func(self, builder: ir.builder.IRBuilder, variable: IterVariable) -> NumbVariable:\n\t        return variable.size\n\t    def call_reshape_func(self, builder, arg1: TableVariable, arg2: NumbVariable, arg3: NumbVariable):\n\t        if not isinstance(arg1, TableVariable) and not isinstance(arg2, NumbVariable) and not isinstance(arg3, NumbVariable):\n\t            raise ValueError(\"Invalid arg types combination - {}, {}, {}\".format(type(arg1), type(arg2), type(arg3)))\n\t        return TableVariable(arg1.var, arg2, arg3, builder)\n", "    def call_del_func(self, builder: ir.builder.IRBuilder, arg1: RowVariable | ColumnVariable, arg2: NumbVariable):\n\t        return self._functions[\"delete_el\"](builder, arg1, arg2, arg1.size, result_size=arg1.size - NumbVariable(1, builder))\n\t    def call_copy_func(self, builder, arg1: Variable):\n\t        return arg1.copy_variable(builder)\n"]}
{"filename": "src/compilers/ProgramCompiler.py", "chunked_list": ["import llvmlite.ir as ir\n\tfrom parser.LangParser import LangParser\n\tfrom src.variables import *\n\tfrom .FunctionCompiler import FunctionCompiler\n\tfrom .ExpressionCompiler import ExpressionCompiler\n\tfrom .AssignExpressionCompiler import AssignExpressionCompiler\n\tfrom src.configs import MAX_STR_SIZE\n\tfrom src.basic_types import *\n\timport time\n\timport os\n", "class ProgramCompiler:\n\t    def __init__(self) -> None:\n\t        print(\"Program compilation into IR code is starting...\")\n\t        self._module = ir.Module()\n\t        self._module.triple = \"x86_64-pc-linux-gnu\"\n\t        self._builtin_funcs = {}\n\t        self.function_compiler = FunctionCompiler(self._module)\n\t        self.expression_compiler = ExpressionCompiler()\n\t        self.assign_expression_compiler = AssignExpressionCompiler(self._module)\n\t        self.local_function = None\n", "        self._main_func = None\n\t    def finish_compiling(self, file_name='ir_program.ll'):\n\t        self.finish_main_func()\n\t        print(str(self._module))\n\t        with open(file_name, \"w\") as ir_file:\n\t            ir_file.write(str(self._module))\n\t        print(\"Program translation into IR code is finished. IR file - {}\".format(file_name))\n\t        time.sleep(1)\n\t        print(\"Program is converting from IR into executable file\")\n\t        os.system(f\"llvm-as {file_name} -o mylang.bc\")\n", "        os.system(f\"clang -c -emit-llvm src/main.c -o main.bc\")\n\t        os.system(f\"clang -c -emit-llvm src/func_utilities.c -o func_utilities.bc\")\n\t        os.system(f\"clang mylang.bc main.bc func_utilities.bc -o executable\")\n\t        os.system(f\"rm main.bc mylang.bc func_utilities.bc\")\n\t    def start_main_func(self):\n\t        main_type = ir.FunctionType(ir.IntType(32), [])\n\t        self._main_func = ir.Function(self._module, main_type, name='run_llvmlite_compiler')\n\t        self._builder = ir.IRBuilder(self._main_func.append_basic_block(name='entry'))\n\t    def is_main_function_started(self):\n\t        return self._main_func is not None\n", "    def finish_main_func(self):\n\t        if self._builder is not None:\n\t            self._builder.ret(ir.Constant(ir.IntType(32), 0))\n\t    def start_local_function(self, func_name, return_type, arg_types):\n\t        if self.local_function is not None:\n\t            return\n\t        type_ = self.convert_type(return_type)\n\t        converted_types = [self.convert_type(\n\t            arg_type) for arg_type in arg_types]\n\t        func_type = ir.FunctionType(\n", "            type_, converted_types)\n\t        self.local_function = ir.Function(\n\t            self.module, func_type, name=func_name)\n\t        self._builder = ir.builder.IRBuilder(\n\t            self.local_function.append_basic_block(name='entry'))\n\t        self.builtin_funcs[func_name] = (\n\t            self.local_function, return_type, arg_types)\n\t        self.local_func_args = [self.create_var_by_type(\n\t            arg_type) for arg_type in arg_types]\n\t    def finish_local_function(self, return_const: ir.Constant = None):\n", "        self._builder.ret(return_const.var)\n\t        self.local_function = None\n\t        self._builder = None\n\t    def _load_builtin_func(self):\n\t        self.function_compiler.load_builtin_functions()\n\t    def find_expression_result(self, first_variable, operation_sign: str, second_variable):\n\t        return self.expression_compiler.process_numb_expr(first_variable, operation_sign, second_variable)\n\t    def call_function(self, name: str, args: list = []):\n\t        return self.function_compiler.call_function(name, args, self._builder)\n\t    def create_empty_var_by_type(self, type: ir.Type):\n", "        if type == 'numb':\n\t            return NumbVariable(1, self._builder)\n\t        elif type == 'string':\n\t            return StringVariable(\"\", self._builder)\n\t        elif type == 'row':\n\t            return RowVariable([], self._builder)\n\t        elif type == 'column':\n\t            return ColumnVariable([], self._builder)\n\t        elif type == 'table':\n\t            return TableVariable([], self._builder)\n", "        else:\n\t            raise ValueError(\"Unkown type - {}\".format(type))\n\t    def create_table(self, elements, n_col, n_row):\n\t        return TableVariable(elements, NumbVariable(n_row, self._builder), NumbVariable(n_col, self._builder), self._builder)\n\t    def create_row(self, elements: list[str]):\n\t        return RowVariable(elements, NumbVariable(len(elements), self._builder), self._builder)\n\t    def create_column(self, elements: list[str]):\n\t        return ColumnVariable(elements, NumbVariable(len(elements), self._builder), self._builder)\n\t    def convert_type(self, type: str) -> ir.Type:\n\t        result_type = None\n", "        match type:\n\t            case \"numb\":\n\t                result_type = number\n\t            case \"string\":\n\t                result_type = string\n\t            case \"iter\"|\"row\"|\"table\"|\"column\":\n\t                result_type = iter\n\t            case \"void\":\n\t                result_type = number\n\t            case \"int\":\n", "                result_type = i8\n\t            case _:\n\t                raise ValueError(\"Unknown type - {}\".format(type))\n\t        return result_type\n\t    def assign_value(self, variable: Variable, assign_sign: str, value: Variable) -> None:\n\t        if type(variable) != type(value):\n\t            raise TypeError(\"Different type of assign value\")\n\t        self.assign_expression_compiler.compile_assign_expr(variable, assign_sign, value)\n"]}
{"filename": "src/compilers/__init__.py", "chunked_list": ["from .ProgramCompiler import ProgramCompiler"]}
{"filename": "src/variables/Variable.py", "chunked_list": ["from abc import ABC, abstractmethod, abstractproperty\n\tfrom llvmlite.ir import Type\n\tclass Variable(ABC):\n\t    basic_type: Type\n\t    @abstractmethod\n\t    def get_value():\n\t        pass\n\t    @abstractmethod\n\t    def copy_variable():\n\t        pass\n", "    @abstractmethod\n\t    def set_value(value):\n\t        pass\n"]}
{"filename": "src/variables/IterVariable.py", "chunked_list": ["from llvmlite import ir\n\tfrom src.configs import MAX_STR_SIZE, MAX_ARR_SIZE\n\tfrom ..basic_types import iter, i8\n\tfrom .NumbVariable import NumbVariable\n\tfrom .Variable import Variable\n\tclass IterVariable(Variable):\n\t    basic_type = iter\n\t    convert_func: ir.Function\n\t    def __init__(self, elements: tuple | object | ir.instructions.Instruction, size: NumbVariable, builder: ir.builder.IRBuilder, ptr=None) -> None:\n\t        self.builder = builder\n", "        self.size = NumbVariable(size, builder) if not isinstance(size, NumbVariable) else size\n\t        if isinstance(elements, ir.instructions.Instruction):\n\t            self.var = elements\n\t            self.ptr = self.builder.alloca(self.basic_type)\n\t            self.builder.store(self.var, self.ptr)\n\t            self.ptr = self.builder.load(self.ptr)\n\t            return\n\t        elif not isinstance(elements, (tuple, list)):\n\t            self.var = elements.var\n\t            self.ptr = self.builder.alloca(self.basic_type)\n", "            self.builder.store(self.var, self.ptr)\n\t            self.ptr = self.builder.load(self.ptr)\n\t            return\n\t        elements = [element + \" \" * (MAX_STR_SIZE - len(element) - 1) for element in elements]\n\t        elements += [\" \" * (MAX_STR_SIZE - 1)] * (MAX_ARR_SIZE - len(elements))\n\t        if ptr is not None:\n\t            self.ptr = ptr\n\t            self.var = self.builder.load(self.ptr)\n\t        else:\n\t            cvars = [ir.Constant(ir.ArrayType(ir.IntType(8), MAX_STR_SIZE), bytearray(\n", "                var + ' ' * (MAX_STR_SIZE - len(var) - 1) + '\\0', 'utf-8')) for var in elements]\n\t            type_ = ir.ArrayType(ir.ArrayType(ir.IntType(8), MAX_STR_SIZE), len(elements))\n\t            self.var = ir.Constant(type_, cvars)\n\t            self.ptr = self.builder.alloca(type_)\n\t            self.builder.store(self.var, self.ptr)\n\t            result = self.convert_func(self.builder, self.size, self)\n\t            self.ptr = self.builder.alloca(self.basic_type)\n\t            self.builder.store(result, self.ptr)\n\t            self.ptr = self.builder.load(self.ptr)\n\t    def set_value(self, value):\n", "        self.var = value.var\n\t        self.size = value.size\n\t        self.ptr = value.ptr\n\t    def get_value(self):\n\t        return self.ptr\n"]}
{"filename": "src/variables/StringVariable.py", "chunked_list": ["from llvmlite import ir\n\tfrom llvmlite.ir import CallInstr \n\tfrom src.configs import MAX_STR_SIZE\n\tfrom ..basic_types import string\n\tfrom .Variable import Variable\n\tclass StringVariable(Variable):\n\t    basic_type: ir.Type = string\n\t    convert_func: ir.Function\n\t    def __init__(self, value: str | CallInstr | Variable, builder: ir.builder.IRBuilder) -> None:\n\t        if isinstance(value, CallInstr):\n", "            self.builder = builder\n\t            self.ptr = self.builder.alloca(self.basic_type)\n\t            self.builder.store(value, self.ptr)\n\t            self.ptr = self.builder.load(self.ptr)\n\t        elif isinstance(value, str):\n\t            if len(value) < MAX_STR_SIZE - 1:\n\t                value += \" \" * (MAX_STR_SIZE - 1 - len(value))\n\t            value += '\\0'\n\t            self.builder = builder\n\t            self.var = ir.Constant(ir.ArrayType(ir.IntType(8), MAX_STR_SIZE), bytearray(value, 'utf-8'))\n", "            self.ptr = self.builder.alloca(ir.ArrayType(ir.IntType(8), MAX_STR_SIZE))\n\t            self.builder.store(self.var, self.ptr)\n\t            result = self.convert_func(self.builder, self)\n\t            self.ptr = self.builder.alloca(self.basic_type)\n\t            self.builder.store(result, self.ptr)\n\t            self.ptr = self.builder.load(self.ptr)\n\t        else:\n\t            self.var = self.builder.load(value.ptr)\n\t            self.ptr = self.builder.alloca(self.basic_type)\n\t            self.builder.store(self.var, self.ptr)\n", "    def get_value(self):\n\t        return self.ptr\n\t    def copy_variable(self, builder: ir.builder.IRBuilder):\n\t        return StringVariable(self, builder)\n\t    def set_value(self, other_variable, builder):\n\t        return StringVariable(other_variable, builder)\n"]}
{"filename": "src/variables/__init__.py", "chunked_list": ["from .ColumnVariable import ColumnVariable\n\tfrom .IterVariable import IterVariable\n\tfrom .NumbVariable import NumbVariable\n\tfrom .RowVariable import RowVariable\n\tfrom .TableVariable import TableVariable\n\tfrom .StringVariable import StringVariable\n\tfrom .VoidVariable import VoidVariable\n\tfrom .Variable import Variable"]}
{"filename": "src/variables/ColumnVariable.py", "chunked_list": ["from llvmlite import ir\n\tfrom .IterVariable import IterVariable\n\tfrom .NumbVariable import NumbVariable\n\tclass ColumnVariable(IterVariable):\n\t    def __init__(self, elements: tuple, size: NumbVariable, builder: ir.builder.IRBuilder, ptr=None) -> None:\n\t        super().__init__(elements, size, builder, ptr)\n\t    def copy_variable(self, builder):\n\t        return ColumnVariable(self, self.size, builder)\n"]}
{"filename": "src/variables/RowVariable.py", "chunked_list": ["from llvmlite import ir\n\tfrom .IterVariable import IterVariable\n\tfrom .NumbVariable import NumbVariable\n\tclass RowVariable(IterVariable):\n\t    def __init__(self, elements: list, size: NumbVariable, builder: ir.builder.IRBuilder) -> None:\n\t        super().__init__(elements, size, builder)\n\t    def set_value(self, value: IterVariable):\n\t        self.size = value.size\n\t        self.var = value.var\n\t        self.ptr = value.ptr\n", "    def copy_variable(self, builder):\n\t        return RowVariable(self, self.size, builder)\n"]}
{"filename": "src/variables/VoidVariable.py", "chunked_list": ["from llvmlite import ir\n\tfrom ..basic_types import void\n\tclass VoidVariable:\n\t    basic_type = void\n\t    def __init__(self) -> None:\n\t        pass\n"]}
{"filename": "src/variables/NumbVariable.py", "chunked_list": ["from llvmlite import ir\n\tfrom .Variable import Variable\n\tclass NumbVariable(Variable):\n\t    basic_type = ir.DoubleType()\n\t    def __init__(self, value: float | Variable | ir.instructions.Instruction, builder: ir.builder.IRBuilder) -> None:\n\t        self.builder = builder\n\t        value = float(value) if isinstance(value, int) else value\n\t        if isinstance(value, float):\n\t            self.var = ir.Constant(\n\t                self.basic_type,\n", "                value\n\t            )\n\t        elif isinstance(value, ir.instructions.Instruction):\n\t            self.var = value\n\t        else:\n\t            self.var = self.builder.load(value.ptr)\n\t        self.ptr = self.builder.alloca(self.basic_type)\n\t        self.builder.store(self.var, self.ptr)\n\t    def get_value(self):\n\t        return self.builder.load(self.ptr)\n", "    def copy_variable(self, builder: ir.builder.IRBuilder):\n\t        return NumbVariable(self, builder) \n\t    def set_value(self, other_variable):\n\t        self.var = other_variable.var\n\t        self.ptr = other_variable.ptr\n\t    def __add__(self, other_var) -> int:\n\t        return NumbVariable(\n\t            self.builder.fadd(\n\t                self.get_value(),\n\t                other_var.get_value()\n", "            ),\n\t            self.builder\n\t        )\n\t    def __eq__(self, other):\n\t        return NumbVariable(\n\t            ir.Constant(\n\t                self.basic_type,\n\t                self.raw_var == other.raw_var\n\t            ),\n\t            self.builder\n", "        )\n\t    def __ne__(self, other):\n\t        return NumbVariable(\n\t            ir.Constant(\n\t                self.basic_type,\n\t                self.raw_var != other.raw_var\n\t            ),\n\t            self.builder\n\t        )\n\t    def __sub__(self, other_var):\n", "        return NumbVariable(\n\t            self.builder.fsub(\n\t                self.get_value(),\n\t                other_var.get_value()\n\t            ),\n\t            self.builder\n\t        )\n\t    def __truediv__(self, other_var):\n\t        return NumbVariable(\n\t            self.builder.fdiv(\n", "                self.get_value(),\n\t                other_var.get_value()\n\t            ),\n\t            self.builder\n\t        )\n\t    def __floordiv__(self, other_var):\n\t        var1 = self.get_value()\n\t        var2 = other_var.get_value()\n\t        return NumbVariable(\n\t            self.builder.frem(\n", "                var1,\n\t                var2\n\t            ),\n\t            self.builder\n\t        )\n\t    def __mul__(self, other_var):\n\t        return NumbVariable(\n\t            self.builder.fmul(\n\t                self.get_value(),\n\t                other_var.get_value()\n", "            ),\n\t            self.builder\n\t        )\n"]}
{"filename": "src/variables/TableVariable.py", "chunked_list": ["from llvmlite import ir\n\tfrom src.configs import MAX_STR_SIZE\n\tfrom .IterVariable import IterVariable\n\tfrom .NumbVariable import NumbVariable\n\tclass TableVariable(IterVariable):\n\t    def __init__(self, elements: tuple, n_rows: NumbVariable, n_cols: NumbVariable, builder: ir.builder.IRBuilder) -> None:\n\t        super().__init__(elements, n_cols * n_rows, builder)\n\t        self.n_rows = n_rows\n\t        self.n_cols = n_cols\n\t    def set_value(self, value):\n", "        self.n_cols = value.n_cols\n\t        self.n_rows = value.n_rows\n\t        self.type = value.type\n\t        self.var = value.var\n\t        self.compile_init()\n\t    def copy_variable(self, builder):\n\t        return TableVariable(self, self.n_rows, self.n_cols, builder)\n"]}
