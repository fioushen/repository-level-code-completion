{"filename": "run.py", "chunked_list": ["import asyncio\n\timport yaml\n\tfrom src.config import AppConfig, log_init, get_app_config\n\tfrom src.constant import MainConstant\n\tfrom src.property import PropertyConfig\n\tdef main():\n\t    with open(MainConstant.LOG_CONFIG, encoding=MainConstant.UTF8) as stream:\n\t        log_init(yaml.load(stream, Loader=yaml.loader.SafeLoader))\n\t    with open(MainConstant.CONFIG, encoding=MainConstant.UTF8) as stream:\n\t        cfg_dict = get_app_config(stream)\n", "        PropertyConfig(cfg_dict)\n\t        AppConfig().app_config()\n\t    loop = asyncio.get_event_loop()\n\t    loop.run_forever()\n\tif __name__ == MainConstant.MAIN:\n\t    main()\n"]}
{"filename": "test/main.py", "chunked_list": ["import asyncio\n\timport sys\n\tsys.path.append('..')\n\tasync def main():\n\t    await asyncio.sleep(0)\n\tif __name__ == '__main__':\n\t    asyncio.run(main())\n"]}
{"filename": "src/constant.py", "chunked_list": ["from dataclasses import dataclass\n\t@dataclass\n\tclass ConfigConstant:\n\t    CRON = 'cron'\n\t    ENV = 'env'\n\t    LOG = 'log'\n\t    SCHEDULER = 'apscheduler'\n\t    THREAD = 'thread'\n\t@dataclass\n\tclass MainConstant:\n", "    CONFIG = 'config.yml'\n\t    LOG_CONFIG = 'log.yml'\n\t    MAIN = '__main__'\n\t    READ_ONLY = 'r'\n\t    WRITE_BINARY = 'wb'\n\t    TMP_DIR = 'runtime/tmp'\n\t    LOG_DIR = 'runtime/log'\n\t    UTF8 = 'UTF-8'\n\t@dataclass\n\tclass NumberConstant:\n", "    ZERO = 0\n\t    ONE = 1\n\t    TWO = 2\n\t    THREE = 3\n\t    FOUR = 4\n\t    TEN = 10\n\t    THIRTY = 30\n\t    SIXTY = 60\n\t    EIGHTY = 80\n\t    HUNDRED = 100\n", "    TWO_HUNDRED = 200\n\t    SIX_HUNDRED = 600\n\t    THOUSAND = 1000\n\t    HTTP_OK = TWO_HUNDRED\n\t@dataclass\n\tclass PunctuationConstant:\n\t    COMMA = ','\n\t    COLON = ':'\n\t    SEMICOLON = ';'\n\t    QUESTION = '?'\n", "@dataclass\n\tclass TimeFormatConstant:\n\t    RFC_FORMAT = '%a, %d %b %Y %H:%M:%S GMT'\n\t    U_FORMAT = '%Y-%m-%dT%H:%M:%SZ'\n\t    STANDARD_DATE = '%Y-%m-%d'\n\t    STANDARD_DATE_TIME = '%Y-%m-%d %H:%M:%S'\n\t    HOUR_DATE_TIME = '%Y-%m-%d %H:%M'\n\t    COMPACT_DATE = '%Y%m%d'\n\t    SHORT_STANDARD_DATE = '%Y-%-m-%-d'\n\t@dataclass\n", "class TimeZoneConstant:\n\t    SHANGHAI = 'Asia/Shanghai'\n\t    UTC = 'UTC'\n"]}
{"filename": "src/property.py", "chunked_list": ["from src.constant import PunctuationConstant\n\tfrom src.helper.singleton import Singleton\n\t@Singleton\n\tclass QCloudProperty:\n\t    def __init__(self, config_property: dict = None):\n\t        self.__access_key_id = config_property.get('access_key_id')\n\t        self.__access_key_secret = config_property.get('access_key_secret')\n\t    @property\n\t    def access_key_id(self) -> str:\n\t        return self.__access_key_id\n", "    @property\n\t    def access_key_secret(self) -> str:\n\t        return self.__access_key_secret\n\t@Singleton\n\tclass TelegramProperty:\n\t    def __init__(self, config_property: dict = None):\n\t        self.__enabled = config_property.get('enabled')\n\t        self.__telegram_bot_token = config_property.get('telegram_bot_token')\n\t        self.__telegram_chat_id = config_property.get('telegram_chat_id')\n\t    @property\n", "    def enabled(self) -> bool:\n\t        return self.__enabled\n\t    @property\n\t    def telegram_bot_token(self) -> str:\n\t        return self.__telegram_bot_token\n\t    @property\n\t    def telegram_chat_id(self) -> str:\n\t        return self.__telegram_chat_id\n\t@Singleton\n\tclass ForceProperty:\n", "    def __init__(self, config_property: dict = None):\n\t        self.__enabled = config_property.get('enabled')\n\t        self.__interval = config_property.get('interval')\n\t    @property\n\t    def enabled(self) -> bool:\n\t        return self.__enabled\n\t    @property\n\t    def interval(self) -> int:\n\t        return self.__interval\n\t@Singleton\n", "class ClashProperty:\n\t    def __init__(self, config_property: dict = None):\n\t        self.__enabled = config_property.get('enabled')\n\t        self.__host = config_property.get('host')\n\t        self.__port = config_property.get('port')\n\t        self.__user = config_property.get('user')\n\t        self.__passwd = config_property.get('passwd')\n\t    def __str__(self) -> str:\n\t        return str(self.__dict__)\n\t    @property\n", "    def enabled(self) -> bool:\n\t        return self.__enabled\n\t    @property\n\t    def host(self) -> str:\n\t        return self.__host\n\t    @property\n\t    def port(self) -> int:\n\t        return self.__port\n\t    @property\n\t    def user(self) -> str:\n", "        return self.__user\n\t    @property\n\t    def passwd(self) -> str:\n\t        return self.__passwd\n\t@Singleton\n\tclass RecordProperty:\n\t    def __init__(self, config_property: dict = None):\n\t        self.__ids = config_property.get('ids')\n\t    @property\n\t    def ids(self) -> list[int]:\n", "        return list(map(int, self.__ids.split(PunctuationConstant.COMMA)))\n\t@Singleton\n\tclass PropertyConfig:\n\t    def __init__(self, config_dict: dict = None):\n\t        self.__config_dict = config_dict\n\t        self.__qc = QCloudProperty(self.__config_dict.get('qcloud'))\n\t        self.__rp = RecordProperty(self.__config_dict.get('record'))\n\t        self.__fp = ForceProperty(self.__config_dict.get('force_update'))\n\t        self.__cp = ClashProperty(self.__config_dict.get('clash'))\n\t        self.__tp = TelegramProperty(self.__config_dict.get('notify').get('telegram'))\n", "    @property\n\t    def qc(self) -> QCloudProperty:\n\t        return self.__qc\n\t    @property\n\t    def rp(self) -> RecordProperty:\n\t        return self.__rp\n\t    @property\n\t    def fp(self) -> ForceProperty:\n\t        return self.__fp\n\t    @property\n", "    def cp(self) -> ClashProperty:\n\t        return self.__cp\n\t    @property\n\t    def tp(self) -> TelegramProperty:\n\t        return self.__tp\n"]}
{"filename": "src/config.py", "chunked_list": ["import logging\n\timport pathlib\n\timport sys\n\tfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\n\tfrom pyaml_env import parse_config\n\tfrom src.constant import ConfigConstant, MainConstant, NumberConstant, TimeZoneConstant\n\tfrom src.helper.singleton import Singleton\n\tfrom src.log.main import LogConfig\n\tfrom src.property import RecordProperty\n\tlogger = logging.getLogger(__name__)\n", "def log_init(config: dict) -> None:\n\t    LogConfig(config).log_setup()\n\t    logger.info('Logger config finished...')\n\tdef get_app_config(stream) -> dict:\n\t    try:\n\t        return parse_config(data=stream, raise_if_na=False)\n\t    except Exception as exp:\n\t        logger.error(','.join(exp.args))\n\t        sys.exit(-NumberConstant.ONE)\n\t@Singleton\n", "class AppConfig:\n\t    def __init__(self):\n\t        pass\n\t    def app_config(self) -> None:\n\t        self.__dir_config()\n\t        self.__scheduler_task_config()\n\t        logger.info('App config finished...')\n\t    @classmethod\n\t    def __dir_config(cls) -> None:\n\t        pathlib.Path(MainConstant.TMP_DIR).mkdir(parents=True, exist_ok=True)\n", "        logger.info('Dir config finished...')\n\t    @classmethod\n\t    def __scheduler_task_config(cls) -> None:\n\t        from src.scheduler.task.main import CDN\n\t        # def listener(event):\n\t        #     pass\n\t        scheduler = AsyncIOScheduler(timezone=TimeZoneConstant.SHANGHAI)\n\t        scheduler.add_job(CDN.main, trigger=ConfigConstant.CRON, args=[RecordProperty().ids],\n\t                          hour=NumberConstant.TEN)\n\t        scheduler.start()\n", "        logger.info(\"Scheduler task config finished...\")\n"]}
{"filename": "src/__init__.py", "chunked_list": []}
{"filename": "src/enum/__init__.py", "chunked_list": []}
{"filename": "src/enum/http.py", "chunked_list": ["from enum import Enum\n\tclass HttpMethod(Enum):\n\t    GET = \"GET\"\n\t    POST = \"POST\"\n\t    PUT = \"PUT\"\n\t    PATCH = \"PATCH\"\n\t    DELETE = \"DELETE\"\n\tclass ContentType(Enum):\n\t    JSON = \"application/json\"\n"]}
{"filename": "src/notification/__init__.py", "chunked_list": []}
{"filename": "src/notification/telegram/main.py", "chunked_list": ["import asyncio\n\timport logging\n\tfrom typing import List, Tuple, Union\n\timport prettytable as pt\n\timport telegram\n\tfrom prettytable import ALL\n\tfrom telegram.constants import ParseMode\n\tfrom src.constant import NumberConstant\n\tfrom src.property import TelegramProperty\n\ttp = TelegramProperty()\n", "BOT_TOKEN = tp.telegram_bot_token\n\tCHAT_ID = tp.telegram_chat_id\n\tlogger = logging.getLogger(__name__)\n\tasync def __send_text(chat_id: Union[int, str], text: str, parse_mode: str, read_timeout: int,\n\t                      write_timeout: int, try_num: int = NumberConstant.THREE) -> None:\n\t    bot = telegram.Bot(token=BOT_TOKEN)\n\t    tried_num = NumberConstant.ONE\n\t    while tried_num < try_num:\n\t        try:\n\t            await bot.send_message(chat_id=chat_id, text=text, parse_mode=parse_mode,\n", "                                   read_timeout=read_timeout, write_timeout=write_timeout)\n\t            return\n\t        except Exception:\n\t            logger.error('发送通知失败, 异常栈如下:', exc_info=True)\n\t            logger.warning('开始第 %s 次尝试...', tried_num)\n\t            await asyncio.sleep(NumberConstant.SIXTY * tried_num)\n\t            tried_num += NumberConstant.ONE\n\tasync def send_nip_info(nip_info: List[Tuple], read_timeout=NumberConstant.TEN,\n\t                        write_timeout=NumberConstant.TEN) -> None:\n\t    header = ['IP_ADDR', 'DLY(ms)', 'DL(MB/s)']\n", "    table = pt.PrettyTable(header, border=True, hrules=ALL)\n\t    for h in header:\n\t        table.align[h] = 'c'\n\t    if nip_info:\n\t        for ip, delay, dl_rate in nip_info:\n\t            table.add_row([ip, delay, dl_rate])\n\t        txt = 'CDN 记录已更新, 详情见表格'\n\t        logger.info('%s\\n%s', txt, table)\n\t        await __send_text(CHAT_ID, f\"<b>{txt}</b>\", parse_mode=ParseMode.HTML,\n\t                          read_timeout=read_timeout, write_timeout=write_timeout)\n", "        await __send_text(CHAT_ID, f'```\\n{table}```', parse_mode=ParseMode.MARKDOWN_V2,\n\t                          read_timeout=read_timeout, write_timeout=write_timeout)\n\t    else:\n\t        await __send_text(CHAT_ID, '<b>CDN 记录更新失败, 详情见日志</b>', parse_mode=ParseMode.HTML,\n\t                          read_timeout=read_timeout, write_timeout=write_timeout)\n"]}
{"filename": "src/notification/telegram/__init__.py", "chunked_list": []}
{"filename": "src/util/main.py", "chunked_list": ["import decimal\n\tfrom decimal import Decimal\n\tfrom typing import Union\n\tfrom src.constant import NumberConstant\n\tdef get_round(num: Union[int, float], precision: int = NumberConstant.TWO) -> Decimal:\n\t    decimal.getcontext().rounding = 'ROUND_HALF_UP'\n\t    prefix = '0.'\n\t    return decimal.Decimal(num).quantize(decimal.Decimal(prefix.ljust(precision + len(prefix), '0')))\n"]}
{"filename": "src/util/__init__.py", "chunked_list": []}
{"filename": "src/util/qc/main.py", "chunked_list": ["import base64\n\timport hmac\n\timport operator\n\tfrom datetime import datetime\n\tfrom hashlib import sha256\n\tfrom typing import Dict\n\tfrom src.constant import MainConstant, NumberConstant, TimeFormatConstant\n\tfrom src.enum.http import HttpMethod\n\tfrom src.property import QCloudProperty\n\tqc = QCloudProperty()\n", "QY_ACCESS_KEY_ID = qc.access_key_id\n\tQY_ACCESS_KEY_SECRET = qc.access_key_secret\n\tdef get_signature(verb: HttpMethod, time_stamp: datetime, resource: str) -> str:\n\t    now = time_stamp or datetime.utcnow()\n\t    string_to_sign = f'{verb.name}\\n{now.strftime(TimeFormatConstant.RFC_FORMAT)}\\n{resource}'\n\t    h = hmac.new(key=QY_ACCESS_KEY_SECRET.encode(\n\t        encoding=MainConstant.UTF8), digestmod=sha256)\n\t    h.update(msg=string_to_sign.encode(encoding=MainConstant.UTF8))\n\t    return base64.b64encode(h.digest()).strip().decode(MainConstant.UTF8)\n\tdef get_auth(sign: str) -> str:\n", "    return f'QC-HMAC-SHA256 {QY_ACCESS_KEY_ID}:{sign}'\n\tdef get_iaas_url(url: str, resource: str, signature: str) -> str:\n\t    return f'{url}?{resource}&signature={signature}'\n\tdef get_sorted_params(_old: Dict) -> Dict:\n\t    return dict(sorted(_old.items(), key=operator.itemgetter(NumberConstant.ZERO)))\n"]}
{"filename": "src/util/qc/__init__.py", "chunked_list": []}
{"filename": "src/scheduler/main.py", "chunked_list": ["from apscheduler.schedulers.asyncio import AsyncIOScheduler\n\tfrom src.helper.singleton import Singleton\n\t@Singleton\n\tclass Scheduler:\n\t    def __init__(self, config):\n\t        self._scheduler = AsyncIOScheduler(config)\n"]}
{"filename": "src/scheduler/__init__.py", "chunked_list": []}
{"filename": "src/scheduler/task/main.py", "chunked_list": ["import asyncio\n\timport decimal\n\timport logging\n\timport time\n\tfrom typing import Dict, List, Tuple\n\tfrom src.constant import NumberConstant, PunctuationConstant\n\tfrom src.helper.cf.main import get_high_quality_ip\n\tfrom src.helper.clash.main import ClashClient\n\tfrom src.helper.ping.main import get_ping_info\n\tfrom src.notification.telegram.main import send_nip_info\n", "from src.property import PropertyConfig\n\tfrom src.service.qc.record import Record\n\tfrom src.util.main import get_round\n\tlogger = logging.getLogger(__name__)\n\tclass CDN:\n\t    __last_updated = int(round(time.time()))\n\t    __DAY_IN_SECONDS = 86400\n\t    __pc = PropertyConfig()\n\t    @classmethod\n\t    async def main(cls, record_ids: List[int]) -> None:\n", "        cur_recs = [await cls.__get_cur_record(i) for i in record_ids]\n\t        # 所有记录执行相同操作, 取其中一条获取原记录\n\t        c_ip = cur_recs[NumberConstant.ZERO]['record'][NumberConstant.ZERO]\n\t        logger.info('获取到当前 ip: %s, 对其进行质检...', c_ip)\n\t        check_result = await cls.__check(c_ip, count=NumberConstant.TEN)\n\t        update_interval = int(round(time.time())) - cls.__last_updated\n\t        fp = cls.__pc.fp\n\t        if fp.enabled and update_interval >= cls.__DAY_IN_SECONDS * fp.interval:\n\t            logger.warning('记录距上次更新时间超过 %s 天, 将强制更新记录', fp.interval)\n\t        elif check_result:\n", "            logger.info('质检通过, 不需要更新 ip')\n\t            return\n\t        else:\n\t            logger.warning('质检未通过, 需更新 ip')\n\t        cp = cls.__pc.cp\n\t        if cp.enabled:\n\t            async with ClashClient(cp) as client:\n\t                await client.login()\n\t                flag = await client.switch_clash(False)\n\t                if not flag:\n", "                    return\n\t                await asyncio.sleep(NumberConstant.THIRTY)\n\t                logger.info('开始获取优质 ip...')\n\t                nip_info = await cls.__update_rec(cur_recs)\n\t                await client.switch_clash(True)\n\t                # await asyncio.sleep(NumberConstant.SIXTY)\n\t        else:\n\t            logger.info('开始获取优质 ip...')\n\t            nip_info = await cls.__update_rec(cur_recs)\n\t        if cls.__pc.tp.enabled:\n", "            await asyncio.sleep(NumberConstant.HUNDRED * NumberConstant.THREE)\n\t            logger.info('向电报发送更新通知...')\n\t            await send_nip_info(nip_info)\n\t    @classmethod\n\t    async def __check(cls, host: str, count: int) -> bool:\n\t        loss_ratio, avg_ms = get_ping_info(host, count=count)\n\t        decimal.getcontext().rounding = \"ROUND_HALF_UP\"\n\t        logger.info('ip: %s, 丢包率: %s, 平均延迟: %s ms',\n\t                    host, get_round(loss_ratio), avg_ms)\n\t        if loss_ratio >= NumberConstant.ONE / NumberConstant.TEN or avg_ms > NumberConstant.THREE * NumberConstant.HUNDRED:\n", "            return False\n\t        return True\n\t    @classmethod\n\t    async def __get_cur_record(cls, record_id: int) -> Dict:\n\t        record = Record()\n\t        record_info = await record.get_record_info(record_id)\n\t        data = record_info['data']\n\t        domain = data['domain_name']\n\t        zone = data['zone_name']\n\t        record = data['record']\n", "        result = []\n\t        for r in record:\n\t            result += [d['value'] for d in r['data']]\n\t        return {'domain': domain, 'zone': zone, 'record_id': record_id, 'record': result}\n\t    @classmethod\n\t    async def __update_rec(cls, cur_recs: List,\n\t                           retry_times: int = NumberConstant.TWO,\n\t                           nip_info=None) -> List[Tuple] | None:\n\t        if nip_info is None:\n\t            nip_info = []\n", "        r = get_high_quality_ip()\n\t        if not r[NumberConstant.ZERO]:\n\t            r_list = r[-NumberConstant.ONE]\n\t            for idx, val in enumerate(r_list):\n\t                x = val.split(PunctuationConstant.COMMA)\n\t                ip = x[NumberConstant.ZERO]\n\t                delay = x[-NumberConstant.TWO]\n\t                dl_rate = float(x[-NumberConstant.ONE])\n\t                nip_info.append((ip, delay, dl_rate))\n\t                if idx == (len(r_list) - NumberConstant.ONE) and nip_info[NumberConstant.ZERO][\n", "                        NumberConstant.TWO] < NumberConstant.TEN and retry_times > NumberConstant.ZERO:\n\t                    logger.warning('下载速率: %s MB/s, 第 %s 次尝试...', dl_rate, NumberConstant.THREE - retry_times)\n\t                    return await cls.__update_rec(cur_recs, retry_times - NumberConstant.ONE, nip_info)\n\t                logger.info('获取到 ip: %s, 延迟: %s ms, 下载速率: %s MB/s',\n\t                            ip, delay, dl_rate)\n\t            nip_info.sort(key=lambda e: e[NumberConstant.TWO], reverse=True)\n\t            nip = [i[NumberConstant.ZERO] for i in nip_info][NumberConstant.ZERO:NumberConstant.TWO]\n\t            logger.info('开始更新 ip...')\n\t            record = Record()\n\t            for r in cur_recs:\n", "                resp = await record.update_record(domain=r['domain'], zone=r['zone'], record_id=r['record_id'],\n\t                                                  records=nip)\n\t                if resp['code']:\n\t                    logger.error('更新 ip 错误: %s', resp['message'])\n\t                    return None\n\t            cls.__last_updated = int(round(time.time()))\n\t            return nip_info\n\t        logger.error('获取优质 ip 失败!')\n\t        return None\n"]}
{"filename": "src/scheduler/task/__init__.py", "chunked_list": []}
{"filename": "src/log/main.py", "chunked_list": ["import logging\n\timport logging.config\n\timport os\n\timport sys\n\tfrom src.constant import NumberConstant\n\tfrom src.helper.singleton import Singleton\n\t@Singleton\n\tclass LogConfig:\n\t    def __init__(self, config: dict, default_level=logging.INFO):\n\t        self.__config = config\n", "        self.__default_level = default_level\n\t    def log_setup(self):\n\t        try:\n\t            if self.__config:\n\t                logging.config.dictConfig(self.__config)\n\t            else:\n\t                logging.basicConfig(level=self.__default_level)\n\t        except ValueError as exp:\n\t            inner_exp = exp.__context__\n\t            if isinstance(inner_exp, FileNotFoundError):\n", "                os.makedirs(os.path.dirname(inner_exp.filename))\n\t            else:\n\t                sys.exit(-NumberConstant.ONE)\n"]}
{"filename": "src/log/__init__.py", "chunked_list": []}
{"filename": "src/service/__init__.py", "chunked_list": []}
{"filename": "src/service/qc/host.py", "chunked_list": ["import logging\n\tfrom datetime import datetime\n\tfrom typing import Dict\n\tfrom urllib import parse\n\tfrom httpx import AsyncClient\n\tfrom src.enum.http import HttpMethod\n\tfrom src.helper.qc.http import get_common_headers, get_common_params\n\tfrom src.util.qc.main import get_auth, get_signature, get_sorted_params\n\tlogger = logging.getLogger(__name__)\n\tclass Host:\n", "    def __init__(self, zone):\n\t        self.__api_url = 'http://api.routewize.com/v1/dns/host'\n\t        self.__resource = '/v1/dns/host'\n\t        self.__zone = zone\n\t    async def get_zone_hosts(self, domain: str = None) -> Dict | None:\n\t        async with AsyncClient() as session:\n\t            utc_now = datetime.utcnow()\n\t            params = get_common_params()\n\t            params['zone_name'] = self.__zone\n\t            if domain:\n", "                params['domain_name'] = domain\n\t            params = get_sorted_params(params)\n\t            url_encoded = parse.urlencode(params)\n\t            sign = get_signature(HttpMethod.GET, utc_now,\n\t                                 f'{self.__resource}?{url_encoded}')\n\t            headers = get_common_headers(get_auth(sign), utc_now)\n\t            resp = await session.get(f'{self.__api_url}{self.__resource}',\n\t                                     headers=headers, params=params)\n\t            resp_json = resp.json()\n\t            if not resp_json['code']:\n", "                return resp_json\n\t            logger.error('域名 %s host 查询失败: %s',\n\t                         domain, resp_json['message'])\n\t            return None\n"]}
{"filename": "src/service/qc/view.py", "chunked_list": ["import logging\n\tfrom datetime import datetime\n\tfrom typing import Dict\n\tfrom urllib import parse\n\tfrom httpx import AsyncClient\n\tfrom src.enum.http import HttpMethod\n\tfrom src.helper.qc.http import get_common_headers, get_common_params\n\tfrom src.util.qc.main import get_auth, get_signature, get_sorted_params\n\tlogger = logging.getLogger(__name__)\n\tclass View:\n", "    def __init__(self):\n\t        self.__api_url = 'http://api.routewize.com'\n\t        self.__resource = '/v1/view'\n\t    async def get_view(self) -> Dict | None:\n\t        async with AsyncClient() as session:\n\t            utc_now = datetime.utcnow()\n\t            params = get_sorted_params(get_common_params())\n\t            url_encoded = parse.urlencode(params)\n\t            sign = get_signature(HttpMethod.GET, utc_now,\n\t                                 f'{self.__resource}/?{url_encoded}')\n", "            headers = get_common_headers(get_auth(sign), utc_now)\n\t            resp = await session.get(f'{self.__api_url}{self.__resource}',\n\t                                     headers=headers, params=params)\n\t            resp_json = resp.json()\n\t            if not resp_json['code']:\n\t                return resp_json\n\t            logger.error('view 查询失败: %s', resp_json['message'])\n\t            return None\n"]}
{"filename": "src/service/qc/__init__.py", "chunked_list": []}
{"filename": "src/service/qc/record.py", "chunked_list": ["import json\n\timport logging\n\tfrom datetime import datetime\n\tfrom typing import Dict, List\n\tfrom httpx import AsyncClient\n\tfrom src.constant import NumberConstant\n\tfrom src.enum.http import HttpMethod\n\tfrom src.helper.qc.http import get_common_headers\n\tfrom src.util.qc.main import get_auth, get_signature\n\tlogger = logging.getLogger(__name__)\n", "class Record:\n\t    def __init__(self):\n\t        self.__api_url = 'http://api.routewize.com'\n\t        self.__resource = '/v1/dr_id'\n\t    async def get_record_info(self, record_id: int) -> Dict:\n\t        async with AsyncClient() as session:\n\t            utc_now = datetime.utcnow()\n\t            sign = get_signature(HttpMethod.GET, utc_now,\n\t                                 f'{self.__resource}/{record_id}')\n\t            headers = get_common_headers(get_auth(sign), utc_now)\n", "            resp = await session.get(f'{self.__api_url}{self.__resource}/{record_id}',\n\t                                     headers=headers)\n\t            return resp.json()\n\t    async def update_record(\n\t            self,\n\t            domain: str,\n\t            zone: str,\n\t            record_id: int,\n\t            records: List[str],\n\t            rd_class: str = 'IN',\n", "            rd_type: str = 'A',\n\t            view_id: int = NumberConstant.THREE,\n\t            ttl: int = NumberConstant.SIX_HUNDRED,\n\t            mode: int = NumberConstant.TWO\n\t    ) -> Dict:\n\t        async with AsyncClient() as session:\n\t            utc_now = datetime.utcnow()\n\t            sign = get_signature(HttpMethod.POST, utc_now,\n\t                                 f'{self.__resource}/{record_id}')\n\t            headers = get_common_headers(get_auth(sign), utc_now)\n", "            records = [{\n\t                'weight': NumberConstant.ZERO,\n\t                'values': [{'value': i, 'status': NumberConstant.ONE} for i in records]\n\t            }]\n\t            data = {\n\t                'domain_name': domain.replace(zone, ''),\n\t                'view_id': view_id,\n\t                'type': rd_type,\n\t                'ttl': ttl,\n\t                'class': rd_class,\n", "                'record': json.dumps(records),\n\t                'mode': mode\n\t            }\n\t            resp = await session.post(f'{self.__api_url}{self.__resource}/{record_id}',\n\t                                      headers=headers, data=data)\n\t            resp_json = resp.json()\n\t            if not resp_json['code']:\n\t                logger.info('域名 %s 记录更新成功!', domain)\n\t            else:\n\t                logger.error('域名 %s 记录更新失败: %s', domain,\n", "                             resp_json['message'])\n\t            return resp_json\n"]}
{"filename": "src/service/qc/zone.py", "chunked_list": ["import logging\n\tfrom datetime import datetime\n\tfrom typing import Dict\n\tfrom urllib import parse\n\tfrom httpx import AsyncClient\n\tfrom src.enum.http import HttpMethod\n\tfrom src.helper.qc.http import get_common_headers, get_common_params\n\tfrom src.util.qc.main import get_auth, get_signature, get_sorted_params\n\tlogger = logging.getLogger(__name__)\n\tclass Zone:\n", "    def __init__(self):\n\t        self.__api_url = 'http://api.routewize.com/v1/user/zones'\n\t        self.__resource = '/v1/user/zones'\n\t    async def get_zones(self) -> Dict | None:\n\t        async with AsyncClient() as session:\n\t            utc_now = datetime.utcnow()\n\t            params = get_sorted_params(get_common_params())\n\t            url_encoded = parse.urlencode(params)\n\t            sign = get_signature(HttpMethod.GET, utc_now,\n\t                                 f'{self.__resource}?{url_encoded}')\n", "            headers = get_common_headers(get_auth(sign), utc_now)\n\t            resp = await session.get(f'{self.__api_url}{self.__resource}',\n\t                                     headers=headers, params=params)\n\t            resp_json = resp.json()\n\t            if not resp_json['code']:\n\t                return resp_json\n\t            logger.error('zone 查询失败: %s', resp_json['message'])\n\t            return None\n"]}
{"filename": "src/helper/singleton.py", "chunked_list": ["class Singleton:\n\t    \"\"\"\n\t        单例模式的类装饰器实现\n\t    \"\"\"\n\t    def __init__(self, cls):\n\t        self._cls = cls\n\t        self._instance = {}\n\t    def __call__(self, *args, **kwargs):\n\t        if self._cls not in self._instance:\n\t            self._instance[self._cls] = self._cls(*args, **kwargs)\n", "        return self._instance[self._cls]\n\tdef singleton(cls):\n\t    \"\"\"\n\t        单例模式的函数装饰器实现\n\t    \"\"\"\n\t    _instance = {}\n\t    def inner(*args, **kwargs):\n\t        if cls not in _instance:\n\t            _instance[cls] = cls(*args, **kwargs)\n\t        return _instance[cls]\n", "    return inner\n"]}
{"filename": "src/helper/__init__.py", "chunked_list": []}
{"filename": "src/helper/clash/main.py", "chunked_list": ["import logging\n\tfrom httpx import AsyncClient\n\tfrom lxml import etree\n\tfrom src.constant import MainConstant, NumberConstant\n\tfrom src.property import ClashProperty\n\tlogger = logging.getLogger(__name__)\n\t# @Singleton\n\tclass ClashClient:\n\t    def __init__(self, cp: ClashProperty):\n\t        self.__host = cp.host\n", "        self.__port = cp.port\n\t        self.__user = cp.user\n\t        self.__passwd = cp.passwd\n\t        self.__session = AsyncClient()\n\t    async def __aenter__(self):\n\t        return self\n\t    async def __aexit__(self, exc_type, exc_val, exc_tb):\n\t        await self.__session.aclose()\n\t    async def login(self) -> bool:\n\t        logger.info('用户 %s 尝试登录 OpenWrt...', self.__user)\n", "        url = f'http://{self.__host}:{self.__port}/cgi-bin/luci'\n\t        data = {\n\t            'luci_username': self.__user,\n\t            'luci_password': self.__passwd\n\t        }\n\t        resp = await self.__session.post(url, data=data)\n\t        if resp.status_code == 200:\n\t            logger.info('用户 %s 登录成功!', self.__user)\n\t            return True\n\t        logger.error('用户 %s 登录失败!', self.__user, exc_info=True)\n", "        return False\n\t    async def switch_clash(self, flag: bool) -> bool:\n\t        url = f'http://{self.__host}:{self.__port}/cgi-bin/luci/admin/services/openclash'\n\t        url_status = f'{url}/status'\n\t        # with self.__session.get(url_status) as status_resp:\n\t        status_resp = await self.__session.get(url_status)\n\t        if status_resp.status_code == NumberConstant.HTTP_OK:\n\t            resp_json = status_resp.json()\n\t            if resp_json.get('clash') is flag:\n\t                logger.warning('open-clash 已经是 %s 状态!', flag)\n", "                return True\n\t            logger.info('尝试切换 open-clash 状态...')\n\t            data = {\n\t                'cbi.submit': NumberConstant.ONE\n\t            }\n\t            if flag:\n\t                data['cbid.table.1.enable'] = 'start'\n\t            else:\n\t                data['cbid.table.1.disable'] = 'stop'\n\t            # get token\n", "            clash_resp = await self.__session.get(url)\n\t            if clash_resp.status_code == NumberConstant.HTTP_OK:\n\t                html = etree.HTML(clash_resp.content.decode(MainConstant.UTF8))\n\t                token_ele = html.xpath('//input[@name=\"token\" and @type=\"hidden\"]')\n\t                data['token'] = token_ele[NumberConstant.ZERO].get('value')\n\t            else:\n\t                logger.error('获取 token 失败!', exc_info=True)\n\t                return False\n\t            clash_resp = await self.__session.post(url, data=data)\n\t            if clash_resp.status_code == NumberConstant.HTTP_OK:\n", "                logger.info('open-clash 状态切换成功!')\n\t                return True\n\t            logger.error('open-clash 状态切换失败, 状态码: %s', clash_resp.status_code)\n\t            return False\n\t        logger.error('查询 open-clash 状态失败, 状态码: %s', status_resp.status_code)\n\t        return False\n"]}
{"filename": "src/helper/clash/__init__.py", "chunked_list": []}
{"filename": "src/helper/cf/main.py", "chunked_list": ["import subprocess\n\tfrom typing import Tuple\n\tfrom src.constant import MainConstant, NumberConstant\n\tdef get_high_quality_ip() -> Tuple:\n\t    with subprocess.Popen([\n\t        'lib/cf/CloudflareST',\n\t        '-url', 'https://cdn.cloudflare.steamstatic.com/steam/apps/256843155/movie_max.mp4',\n\t        '-p', '0',\n\t        '-f', 'lib/cf/ip.txt',\n\t        '-o', 'lib/cf/result.csv'\n", "    ]) as proc:\n\t        stdout, stderr = proc.communicate()\n\t        with open('lib/cf/result.csv', encoding=MainConstant.UTF8) as result:\n\t            r_list = result.readlines()[NumberConstant.ONE:NumberConstant.THREE]\n\t        return proc.returncode, stdout, stderr, r_list\n"]}
{"filename": "src/helper/cf/__init__.py", "chunked_list": []}
{"filename": "src/helper/qc/__init__.py", "chunked_list": []}
{"filename": "src/helper/qc/http.py", "chunked_list": ["from datetime import datetime\n\tfrom typing import Dict\n\tfrom src.constant import NumberConstant as Number, TimeFormatConstant as TimeFormat\n\tdef get_api_base() -> str:\n\t    return 'https://api.qingcloud.com/iaas/'\n\tdef get_common_headers(auth: str, time_stamp: datetime = None) -> Dict:\n\t    now = time_stamp or datetime.utcnow()\n\t    headers = {\n\t        'Authorization': auth,\n\t        'Date': now.strftime(TimeFormat.RFC_FORMAT)\n", "    }\n\t    return headers\n\tdef get_common_params() -> Dict:\n\t    params = {\n\t        'limit': Number.TEN,\n\t        'offset': Number.ZERO,\n\t        # 'refresh': Number.ZERO\n\t    }\n\t    return params\n"]}
{"filename": "src/helper/ping/main.py", "chunked_list": ["from typing import Tuple\n\tfrom pythonping import ping\n\tfrom tcppinglib import async_tcpping\n\tfrom src.constant import NumberConstant\n\tdef get_ping_info(host: str, count: int = NumberConstant.FOUR) -> Tuple:\n\t    resp_list = ping(host, count=count, verbose=True)\n\t    return resp_list.stats_lost_ratio, resp_list.rtt_avg_ms\n\tasync def get_tcpping_info(host: str, port: int = NumberConstant.EIGHTY, timeout: float = NumberConstant.THREE,\n\t                           count: int = NumberConstant.TEN, interval: float = NumberConstant.ZERO) -> Tuple:\n\t    host = await async_tcpping(host, port, timeout, count, interval)\n", "    return host.packet_loss / host.packets_sent, host.avg_rtt\n"]}
{"filename": "src/helper/ping/__init__.py", "chunked_list": []}
