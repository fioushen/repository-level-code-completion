{"filename": "main_in_memory_custom.py", "chunked_list": ["from adapters.in_memory_person_repository import InMemoryPersonRepository\n\tfrom adapters.base_repository import BaseRepository\n\tfrom adapters.in_memory_order_repository import InMemoryOrderRepository\n\tfrom adapters.in_memory_connection import InMemoryConnection\n\tfrom adapters.base_connection import BaseConnection\n\tfrom use_cases.unit_of_work import UnitOfWork\n\tfrom domain.person import Person\n\tfrom domain.order import Order\n\tfrom use_cases.create_person_and_order_use_case import (\n\t    CreatePersonAndOrderUseCase)\n", "from custom_di.container import Container\n\tcontainer = Container()\n\tcontainer.register(BaseConnection, InMemoryConnection)\n\tcontainer.register(BaseRepository[Person], InMemoryPersonRepository)\n\tcontainer.register(BaseRepository[Order], InMemoryOrderRepository)\n\tcontainer.register(UnitOfWork)\n\tcontainer.register(CreatePersonAndOrderUseCase)\n\tcreate_use_case = container.resolve(CreatePersonAndOrderUseCase)\n\tnew_person = Person(id=1, name=\"John Doe\", age=30)\n\tnew_order = Order(id=1, order_date=\"2023-04-03\", total_amount=100.0)\n", "person, order = create_use_case.execute(new_person, new_order)\n\tprint(person, order)\n"]}
{"filename": "main_in_memory_injector.py", "chunked_list": ["from injector import Injector, inject, Module, provider, singleton\n\tfrom adapters.in_memory_person_repository import InMemoryPersonRepository\n\tfrom adapters.in_memory_order_repository import InMemoryOrderRepository\n\tfrom adapters.in_memory_connection import InMemoryConnection\n\tfrom use_cases.unit_of_work import UnitOfWork\n\tfrom domain.person import Person\n\tfrom domain.order import Order\n\tfrom use_cases.create_person_and_order_use_case import (\n\t    CreatePersonAndOrderUseCase)\n\tclass AppModule(Module):\n", "    @singleton\n\t    @provider\n\t    def provide_connection(self) -> InMemoryConnection:\n\t        return InMemoryConnection()\n\t    @singleton\n\t    @provider\n\t    def provide_person_repository(self) -> InMemoryPersonRepository:\n\t        return InMemoryPersonRepository()\n\t    @singleton\n\t    @provider\n", "    def provide_order_repository(self) -> InMemoryOrderRepository:\n\t        return InMemoryOrderRepository()\n\t    @inject\n\t    @singleton\n\t    @provider\n\t    def provide_unit_of_work(\n\t        self,\n\t        connection: InMemoryConnection,\n\t        person_repository: InMemoryPersonRepository,\n\t        order_repository: InMemoryOrderRepository\n", "    ) -> UnitOfWork:\n\t        return UnitOfWork(connection, person_repository, order_repository)\n\t    @inject\n\t    @singleton\n\t    @provider\n\t    def provide_create_use_case(\n\t        self,\n\t        unit_of_work: UnitOfWork\n\t    ) -> CreatePersonAndOrderUseCase:\n\t        return CreatePersonAndOrderUseCase(unit_of_work)\n", "injector = Injector(AppModule())\n\tcreate_use_case = injector.get(CreatePersonAndOrderUseCase)\n\tnew_person = Person(id=1, name=\"John Doe\", age=30)\n\tnew_order = Order(id=1, order_date=\"2023-04-03\", total_amount=100.0)\n\tperson, order = create_use_case.execute(new_person, new_order)\n\tprint(person, order)\n"]}
{"filename": "main_in_memory_dependency_injector.py", "chunked_list": ["from dependency_injector import providers, containers\n\tfrom adapters.in_memory_person_repository import InMemoryPersonRepository\n\tfrom adapters.in_memory_order_repository import InMemoryOrderRepository\n\tfrom adapters.in_memory_connection import InMemoryConnection\n\tfrom use_cases.unit_of_work import UnitOfWork\n\tfrom domain.person import Person\n\tfrom domain.order import Order\n\tfrom use_cases.create_person_and_order_use_case import (\n\t    CreatePersonAndOrderUseCase)\n\tclass Container(containers.DeclarativeContainer):\n", "    connection = providers.Singleton(\n\t        InMemoryConnection\n\t    )\n\t    person_repository = providers.Singleton(\n\t        InMemoryPersonRepository\n\t    )\n\t    order_repository = providers.Singleton(\n\t        InMemoryOrderRepository\n\t    )\n\t    unit_of_work = providers.Singleton(\n", "        UnitOfWork,\n\t        connection=connection,\n\t        person_repository=person_repository,\n\t        order_repository=order_repository\n\t    )\n\t    create_use_case = providers.Factory(\n\t        CreatePersonAndOrderUseCase,\n\t        unit_of_work=unit_of_work\n\t    )\n\tif __name__ == '__main__':\n", "    container = Container()\n\t    create_use_case = container.create_use_case()\n\t    new_person = Person(id=1, name=\"John Doe\", age=30)\n\t    new_order = Order(id=1, order_date=\"2023-04-03\", total_amount=100.0)\n\t    person, order = create_use_case.execute(new_person, new_order)\n\t    print(person, order)\n"]}
{"filename": "adapters/sqlite_person_repository.py", "chunked_list": ["from typing import Optional\n\tfrom adapters.base_repository import BaseRepository\n\tfrom domain.person import Person\n\tclass SQLitePersonRepository(BaseRepository[Person]):\n\t    def __init__(self, connection):\n\t        self.connection = connection\n\t        self._create_table()\n\t    def _create_table(self):\n\t        cursor = self.connection.cursor()\n\t        cursor.execute(\"\"\"\n", "            CREATE TABLE IF NOT EXISTS persons (\n\t                id INTEGER PRIMARY KEY AUTOINCREMENT,\n\t                name TEXT NOT NULL,\n\t                age INTEGER NOT NULL\n\t            )\n\t        \"\"\")\n\t        self.connection.commit()\n\t    def add(self, person: Person):\n\t        cursor = self.connection.cursor()\n\t        cursor.execute(\n", "            \"INSERT INTO persons (name, age) VALUES (?, ?)\",\n\t            (person.name, person.age)\n\t        )\n\t        person.id = cursor.lastrowid\n\t    def get_by_id(self, person_id: int) -> Optional[Person]:\n\t        cursor = self.connection.cursor()\n\t        cursor.execute(\"SELECT id, name, age FROM persons WHERE id=?\",\n\t                       (person_id,))\n\t        row = cursor.fetchone()\n\t        if row:\n", "            return Person(row[1], row[2], row[0])\n\t        return None\n\t    def update(self, person: Person):\n\t        cursor = self.connection.cursor()\n\t        cursor.execute(\n\t            \"UPDATE persons SET name=?, age=? WHERE id=?\",\n\t            (person.name, person.age, person.id)\n\t        )\n\t    def delete(self, person_id: int):\n\t        cursor = self.connection.cursor()\n", "        cursor.execute(\"DELETE FROM persons WHERE id=?\", (person_id,))\n"]}
{"filename": "adapters/sql_alchemy_connection.py", "chunked_list": ["from sqlalchemy.orm import Session\n\tfrom adapters.base_connection import BaseConnection\n\tclass SQLAlchemyConnection(BaseConnection):\n\t    def __init__(self, session: Session):\n\t        self.session = session\n\t    def commit(self):\n\t        self.session.commit()\n\t    def rollback(self):\n\t        self.session.rollback()\n"]}
{"filename": "adapters/in_memory_person_repository.py", "chunked_list": ["from typing import Optional\n\tfrom adapters.base_repository import BaseRepository\n\tfrom domain.person import Person\n\tclass InMemoryPersonRepository(BaseRepository[Person]):\n\t    def __init__(self):\n\t        self.persons = {}\n\t    def add(self, person: Person):\n\t        self.persons[person.id] = person\n\t    def get_by_id(self, person_id: int) -> Optional[Person]:\n\t        return self.persons.get(person_id)\n", "    def update(self, person: Person):\n\t        self.persons[person.id] = person\n\t    def delete(self, person_id: int):\n\t        self.persons.pop(person_id, None)\n"]}
{"filename": "adapters/sql_alchemy_mappers.py", "chunked_list": ["from sqlalchemy import Table, Column, Integer, String, Float, ForeignKey\n\tfrom sqlalchemy.orm import registry\n\tfrom domain.order import Order\n\tfrom domain.person import Person\n\tdef create_tables_and_mappers(metadata):\n\t    person_table = Table(\n\t        'person', metadata,\n\t        Column('id', Integer, primary_key=True),\n\t        Column('name', String),\n\t        Column('age', Integer)\n", "    )\n\t    order_table = Table(\n\t        'order', metadata,\n\t        Column('id', Integer, primary_key=True),\n\t        Column('person_id', Integer, ForeignKey('person.id')),\n\t        Column('order_date', String),\n\t        Column('total_amount', Float)\n\t    )\n\t    mapper_registry = registry()\n\t    mapper_registry.map_imperatively(Person, person_table)\n", "    mapper_registry.map_imperatively(Order, order_table)\n"]}
{"filename": "adapters/__init__.py", "chunked_list": []}
{"filename": "adapters/sqlite_connection.py", "chunked_list": ["import sqlite3\n\tfrom adapters.base_connection import BaseConnection\n\tclass SQLiteConnection(BaseConnection):\n\t    def __init__(self, connection: sqlite3.Connection):\n\t        self.connection = connection\n\t    def commit(self):\n\t        self.connection.commit()\n\t    def rollback(self):\n\t        self.connection.rollback()\n"]}
{"filename": "adapters/in_memory_connection.py", "chunked_list": ["from adapters.base_connection import BaseConnection\n\tclass InMemoryConnection(BaseConnection):\n\t    def commit(self):\n\t        pass\n\t    def rollback(self):\n\t        pass\n"]}
{"filename": "adapters/base_connection.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tclass BaseConnection(ABC):\n\t    @abstractmethod\n\t    def commit(self):\n\t        raise NotImplementedError()\n\t    @abstractmethod\n\t    def rollback(self):\n\t        raise NotImplementedError()\n"]}
{"filename": "adapters/base_repository.py", "chunked_list": ["from typing import TypeVar, Generic, Optional\n\tfrom abc import ABC, abstractmethod\n\tT = TypeVar('T')\n\tclass BaseRepository(ABC, Generic[T]):\n\t    \"\"\"A base class for repositories\"\"\"\n\t    @abstractmethod\n\t    def add(self, item: T):\n\t        \"\"\"Add a new item to a repository\"\"\"\n\t        raise NotImplementedError()\n\t    @abstractmethod\n", "    def update(self, item: T):\n\t        \"\"\"Update an existing item in the repository\"\"\"\n\t        raise NotImplementedError()\n\t    @abstractmethod\n\t    def delete(self, item_id: int):\n\t        \"\"\"Delete an existing item from a repository\"\"\"\n\t        raise NotImplementedError()\n\t    @abstractmethod\n\t    def get_by_id(self, item_id: int) -> Optional[T]:\n\t        \"\"\"Retrieve an item by its id\"\"\"\n", "        raise NotImplementedError()\n"]}
{"filename": "adapters/in_memory_order_repository.py", "chunked_list": ["from typing import Optional\n\tfrom adapters.base_repository import BaseRepository\n\tfrom domain.order import Order\n\tclass InMemoryOrderRepository(BaseRepository[Order]):\n\t    def __init__(self):\n\t        self.orders = {}\n\t    def add(self, order: Order):\n\t        self.orders[order.id] = order\n\t    def get_by_id(self, order_id: int) -> Optional[Order]:\n\t        return self.orders.get(order_id)\n", "    def update(self, order: Order):\n\t        self.orders[order.id] = order\n\t    def delete(self, order_id: int):\n\t        self.orders.pop(order_id, None)\n"]}
{"filename": "adapters/sqlite_order_repository.py", "chunked_list": ["from typing import Optional\n\tfrom domain.order import Order\n\tfrom adapters.base_repository import BaseRepository\n\tclass SQLiteOrderRepository(BaseRepository[Order]):\n\t    def __init__(self, connection):\n\t        self.connection = connection\n\t        self._create_table()\n\t    def _create_table(self):\n\t        cursor = self.connection.cursor()\n\t        cursor.execute('''\n", "            CREATE TABLE IF NOT EXISTS orders (\n\t                id INTEGER PRIMARY KEY AUTOINCREMENT,\n\t                person_id INTEGER NOT NULL,\n\t                order_date TEXT NOT NULL,\n\t                total_amount REAL NOT NULL,\n\t                FOREIGN KEY (person_id) REFERENCES persons (id)\n\t            )\n\t        ''')\n\t        self.connection.commit()\n\t    def add(self, order: Order):\n", "        query = \"\"\"\n\t        INSERT INTO orders (person_id, order_date, total_amount)\n\t        VALUES (?, ?, ?)\n\t        \"\"\"\n\t        cursor = self.connection.cursor()\n\t        cursor.execute(query, (order.person_id, order.order_date,\n\t                               order.total_amount))\n\t        order.id = cursor.lastrowid\n\t    def update(self, order: Order):\n\t        query = \"\"\"\n", "        UPDATE orders\n\t        SET person_id = ?, order_date = ?, total_amount = ?\n\t        WHERE id = ?\n\t        \"\"\"\n\t        self.connection.execute(query, (order.person_id, order.order_date,\n\t                                order.total_amount, order.id))\n\t    def delete(self, order_id: int):\n\t        query = \"DELETE FROM orders WHERE id = ?\"\n\t        self.connection.execute(query, (order_id,))\n\t    def get_by_id(self, order_id: int) -> Optional[Order]:\n", "        query = \"\"\"\n\t        SELECT id, person_id, order_date, total_amount\n\t        FROM orders WHERE id = ?\n\t        \"\"\"\n\t        cursor = self.connection.execute(query, (order_id,))\n\t        row = cursor.fetchone()\n\t        if row:\n\t            return Order(id=row[0], person_id=row[1], order_date=row[2],\n\t                         total_amount=row[3])\n\t        return None\n"]}
{"filename": "adapters/sql_alchemy_order_repository.py", "chunked_list": ["from typing import Optional\n\tfrom sqlalchemy.orm import Session\n\tfrom adapters.base_repository import BaseRepository\n\tfrom domain.order import Order\n\tclass SQLAlchemyOrderRepository(BaseRepository[Order]):\n\t    def __init__(self, session: Session):\n\t        self.session = session\n\t    def add(self, order: Order):\n\t        self.session.add(order)\n\t    def update(self, order: Order):\n", "        self.session.merge(order)\n\t    def delete(self, order_id: int):\n\t        order = self.session.get(Order, order_id)\n\t        if order:\n\t            self.session.delete(order)\n\t    def get_by_id(self, order_id: int) -> Optional[Order]:\n\t        return self.session.get(Order, order_id)\n"]}
{"filename": "adapters/sql_alchemy_person_repository.py", "chunked_list": ["from typing import Optional\n\tfrom sqlalchemy.orm import Session\n\tfrom adapters.base_repository import BaseRepository\n\tfrom domain.person import Person\n\tclass SQLAlchemyPersonRepository(BaseRepository[Person]):\n\t    def __init__(self, session: Session):\n\t        self.session = session\n\t    def add(self, person: Person):\n\t        self.session.add(person)\n\t        # flush() is needed to get the id of the person\n", "        self.session.flush()\n\t    def update(self, person: Person):\n\t        self.session.merge(person)\n\t    def delete(self, person_id: int):\n\t        person = self.session.get(Person, person_id)\n\t        if person:\n\t            self.session.delete(person)\n\t    def get_by_id(self, person_id: int) -> Optional[Person]:\n\t        return self.session.get(Person, person_id)\n"]}
{"filename": "domain/__init__.py", "chunked_list": []}
{"filename": "domain/order.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom typing import Optional\n\t@dataclass\n\tclass Order:\n\t    order_date: str\n\t    total_amount: float\n\t    person_id: Optional[int] = None\n\t    id: Optional[int] = None\n"]}
{"filename": "domain/person.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom typing import Optional\n\t@dataclass\n\tclass Person:\n\t    name: str\n\t    age: int\n\t    id: Optional[int] = None\n"]}
{"filename": "tests/test_sqlite_order_repository.py", "chunked_list": ["import sqlite3\n\tfrom domain.order import Order\n\tfrom adapters.sqlite_order_repository import SQLiteOrderRepository\n\timport pytest\n\t@pytest.fixture\n\tdef connection():\n\t    conn = sqlite3.connect(\":memory:\")\n\t    yield conn\n\t    conn.close()\n\t@pytest.fixture\n", "def repository(connection):\n\t    return SQLiteOrderRepository(connection)\n\tdef test_add_order(repository):\n\t    order = Order(person_id=1, order_date=\"2022-01-01\", total_amount=100.0)\n\t    repository.add(order)\n\t    retrieved_order = repository.get_by_id(order.id)\n\t    assert retrieved_order is not None\n\t    assert retrieved_order.person_id == order.person_id\n\t    assert retrieved_order.order_date == order.order_date\n\t    assert retrieved_order.total_amount == order.total_amount\n", "def test_update_order(repository):\n\t    order = Order(person_id=1, order_date=\"2022-01-01\", total_amount=100.0)\n\t    repository.add(order)\n\t    order.person_id = 2\n\t    order.order_date = \"2022-01-02\"\n\t    order.total_amount = 200.0\n\t    repository.update(order)\n\t    updated_order = repository.get_by_id(order.id)\n\t    assert updated_order.person_id == 2\n\t    assert updated_order.order_date == \"2022-01-02\"\n", "    assert updated_order.total_amount == 200.0\n\tdef test_delete_order(repository):\n\t    order = Order(person_id=1, order_date=\"2022-01-01\", total_amount=100.0)\n\t    repository.add(order)\n\t    repository.delete(order.id)\n\t    deleted_order = repository.get_by_id(order.id)\n\t    assert deleted_order is None\n\tdef test_get_by_id_order_not_found(repository):\n\t    non_existent_order = repository.get_by_id(999)\n\t    assert non_existent_order is None\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_in_memory_person_repository.py", "chunked_list": ["import pytest\n\tfrom domain.person import Person\n\tfrom adapters.in_memory_person_repository import InMemoryPersonRepository\n\t@pytest.fixture\n\tdef repository():\n\t    return InMemoryPersonRepository()\n\tdef test_add_person(repository):\n\t    person = Person(name=\"John Doe\", age=30, id=1)\n\t    repository.add(person)\n\t    retrieved_person = repository.get_by_id(1)\n", "    assert retrieved_person is not None\n\t    assert retrieved_person.name == person.name\n\t    assert retrieved_person.age == person.age\n\tdef test_update_person(repository):\n\t    person = Person(name=\"John Doe\", age=30, id=1)\n\t    repository.add(person)\n\t    person.name = \"Jane Doe\"\n\t    person.age = 28\n\t    repository.update(person)\n\t    updated_person = repository.get_by_id(1)\n", "    assert updated_person.name == \"Jane Doe\"\n\t    assert updated_person.age == 28\n\tdef test_delete_person(repository):\n\t    person = Person(name=\"John Doe\", age=30, id=1)\n\t    repository.add(person)\n\t    repository.delete(1)\n\t    deleted_person = repository.get_by_id(1)\n\t    assert deleted_person is None\n\tdef test_get_by_id_person_not_found(repository):\n\t    non_existent_person = repository.get_by_id(999)\n", "    assert non_existent_person is None\n"]}
{"filename": "tests/test_container.py", "chunked_list": ["import pytest\n\tfrom custom_di.container import Container\n\t# Sample classes for testing\n\tclass Engine:\n\t    pass\n\tclass DieselEngine(Engine):\n\t    pass\n\tclass Car:\n\t    def __init__(self, engine: Engine):\n\t        self.engine = engine\n", "# Test functions\n\tdef test_resolve_simple_dependency():\n\t    container = Container()\n\t    container.register(Engine, DieselEngine)\n\t    container.register(Car)\n\t    car_instance = container.resolve(Car)\n\t    assert isinstance(car_instance, Car)\n\t    assert isinstance(car_instance.engine, DieselEngine)\n\tdef test_resolve_unregistered_dependency():\n\t    container = Container()\n", "    with pytest.raises(ValueError):\n\t        container.resolve(Engine)\n\tdef test_resolve_base_class_dependency():\n\t    container = Container()\n\t    container.register(Engine, DieselEngine)\n\t    container.register(Car)\n\t    engine_instance = container.resolve(Engine)\n\t    assert isinstance(engine_instance, DieselEngine)\n"]}
{"filename": "tests/test_sqlite_person_repository.py", "chunked_list": ["import sqlite3\n\tfrom domain.person import Person\n\tfrom adapters.sqlite_person_repository import SQLitePersonRepository\n\timport pytest\n\t@pytest.fixture\n\tdef connection():\n\t    conn = sqlite3.connect(\":memory:\")\n\t    yield conn\n\t    conn.close()\n\t@pytest.fixture\n", "def repository(connection):\n\t    return SQLitePersonRepository(connection)\n\tdef test_add_person(repository):\n\t    person = Person(name=\"John Doe\", age=30)\n\t    repository.add(person)\n\t    retrieved_person = repository.get_by_id(person.id)\n\t    assert retrieved_person is not None\n\t    assert retrieved_person.name == person.name\n\t    assert retrieved_person.age == person.age\n\tdef test_update_person(repository):\n", "    person = Person(name=\"John Doe\", age=30)\n\t    repository.add(person)\n\t    person.name = \"Jane Doe\"\n\t    person.age = 28\n\t    repository.update(person)\n\t    updated_person = repository.get_by_id(person.id)\n\t    assert updated_person.name == \"Jane Doe\"\n\t    assert updated_person.age == 28\n\tdef test_delete_person(repository):\n\t    person = Person(name=\"John Doe\", age=30)\n", "    repository.add(person)\n\t    repository.delete(person.id)\n\t    deleted_person = repository.get_by_id(person.id)\n\t    assert deleted_person is None\n\tdef test_get_by_id_person_not_found(repository):\n\t    non_existent_person = repository.get_by_id(999)\n\t    assert non_existent_person is None\n"]}
{"filename": "tests/test_in_memory_order_repository.py", "chunked_list": ["from domain.order import Order\n\tfrom adapters.in_memory_order_repository import InMemoryOrderRepository\n\tdef test_in_memory_order_repository():\n\t    repo = InMemoryOrderRepository()\n\t    order1 = Order(id=1, person_id=1, order_date=\"2022-01-01\",\n\t                   total_amount=10.0)\n\t    order2 = Order(id=2, person_id=2, order_date=\"2022-01-02\",\n\t                   total_amount=20.0)\n\t    # Add orders\n\t    repo.add(order1)\n", "    repo.add(order2)\n\t    # Get order by id\n\t    assert repo.get_by_id(order1.id) == order1\n\t    assert repo.get_by_id(order2.id) == order2\n\t    # Update order\n\t    order1.total_amount = 15.0\n\t    repo.update(order1)\n\t    assert repo.get_by_id(order1.id).total_amount == 15.0\n\t    # Delete order\n\t    repo.delete(order2.id)\n", "    assert repo.get_by_id(order2.id) is None\n"]}
{"filename": "tests/test_sql_alchemy_person_repository.py", "chunked_list": ["import pytest\n\tfrom sqlalchemy import create_engine\n\tfrom sqlalchemy.orm import sessionmaker, declarative_base\n\tfrom domain.person import Person\n\tfrom adapters.sql_alchemy_person_repository import SQLAlchemyPersonRepository\n\tfrom adapters.sql_alchemy_mappers import create_tables_and_mappers\n\tBase = declarative_base()\n\t@pytest.fixture(scope=\"module\")\n\tdef engine():\n\t    return create_engine(\"sqlite:///:memory:\")\n", "@pytest.fixture(scope=\"module\")\n\tdef connection(engine):\n\t    with engine.connect() as connection:\n\t        yield connection\n\t@pytest.fixture(scope=\"module\")\n\tdef session(engine, connection):\n\t    Session = sessionmaker(bind=engine)\n\t    create_tables_and_mappers(Base.metadata)\n\t    Base.metadata.create_all(bind=engine)\n\t    session = Session(bind=connection)\n", "    yield session\n\t    session.close()\n\t@pytest.fixture\n\tdef repository(session):\n\t    return SQLAlchemyPersonRepository(session)\n\tdef test_add_person(repository):\n\t    person = Person(name=\"John Doe\", age=30)\n\t    repository.add(person)\n\t    retrieved_person = repository.get_by_id(person.id)\n\t    assert retrieved_person is not None\n", "    assert retrieved_person.name == person.name\n\t    assert retrieved_person.age == person.age\n\tdef test_update_person(repository):\n\t    person = Person(name=\"John Doe\", age=30)\n\t    repository.add(person)\n\t    person.name = \"Jane Doe\"\n\t    person.age = 28\n\t    repository.update(person)\n\t    updated_person = repository.get_by_id(person.id)\n\t    assert updated_person.name == \"Jane Doe\"\n", "    assert updated_person.age == 28\n\tdef test_delete_person(repository, session):\n\t    person = Person(name=\"John Doe\", age=30)\n\t    repository.add(person)\n\t    repository.delete(person.id)\n\t    session.flush()\n\t    deleted_person = repository.get_by_id(person.id)\n\t    assert deleted_person is None\n\tdef test_get_by_id_person_not_found(repository):\n\t    non_existent_person = repository.get_by_id(999)\n", "    assert non_existent_person is None\n"]}
{"filename": "use_cases/unit_of_work.py", "chunked_list": ["from adapters.base_connection import BaseConnection\n\tfrom adapters.base_repository import BaseRepository\n\tfrom domain.order import Order\n\tfrom domain.person import Person\n\tclass UnitOfWork:\n\t    def __init__(self, connection: BaseConnection,\n\t                 person_repository: BaseRepository[Person],\n\t                 order_repository: BaseRepository[Order]):\n\t        self.persons = person_repository\n\t        self.orders = order_repository\n", "        self.connection = connection\n\t    def __enter__(self):\n\t        return self\n\t    def __exit__(self, exc_type, exc_val, exc_tb):\n\t        if exc_type:\n\t            self.rollback()\n\t        else:\n\t            self.commit()\n\t    def commit(self):\n\t        self.connection.commit()\n", "    def rollback(self):\n\t        self.connection.rollback()\n"]}
{"filename": "use_cases/create_person_and_order_use_case.py", "chunked_list": ["from typing import Tuple\n\tfrom domain.person import Person\n\tfrom domain.order import Order\n\tfrom use_cases.unit_of_work import UnitOfWork\n\tclass CreatePersonAndOrderUseCase:\n\t    def __init__(self, unit_of_work: UnitOfWork):\n\t        self.unit_of_work = unit_of_work\n\t    def execute(self, person: Person, order: Order) -> Tuple[Person, Order]:\n\t        with self.unit_of_work as uow:\n\t            uow.persons.add(person)\n", "            if person.id is not None:\n\t                order.person_id = int(person.id)\n\t            else:\n\t                raise ValueError(\"Person id cannot be None\")\n\t            uow.orders.add(order)\n\t        return person, order\n"]}
{"filename": "use_cases/__init__.py", "chunked_list": []}
{"filename": "custom_di/container.py", "chunked_list": ["import inspect\n\tclass Container:\n\t    def __init__(self):\n\t        self._registry = {}\n\t    def register(self, dependency_type, implementation=None):\n\t        if not implementation:\n\t            implementation = dependency_type\n\t        for base in inspect.getmro(implementation):\n\t            if base not in (object, dependency_type):\n\t                self._registry[base] = implementation\n", "        self._registry[dependency_type] = implementation\n\t    def resolve(self, dependency_type):\n\t        if dependency_type not in self._registry:\n\t            raise ValueError(f\"Dependency {dependency_type} not registered\")\n\t        implementation = self._registry[dependency_type]\n\t        constructor_signature = inspect.signature(implementation.__init__)\n\t        constructor_params = constructor_signature.parameters.values()\n\t        dependencies = [\n\t            self.resolve(param.annotation)\n\t            for param in constructor_params\n", "            if param.annotation is not inspect.Parameter.empty\n\t        ]\n\t        return implementation(*dependencies)\n"]}
{"filename": "custom_di/__init__.py", "chunked_list": []}
