{"filename": "NOTICE-snippet.py", "chunked_list": ["# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n"]}
{"filename": "penvm-build.py", "chunked_list": ["#! /usr/bin/env -S python3 -B\n\t#\n\t# penvmbuild.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Build and install PENVM.\n\tMost items are taken from src/ to populate the install directory as:\n", "    bin/\n\t    lib/\n\t    share/penvm\n\tAll executables are single zipapp applications. The penvmlib is a\n\tzip archive of all the source. Documents, etc. are under the share\n\tdirectory.\n\t\"\"\"\n\timport os\n\timport os.path\n\timport shutil\n", "import subprocess\n\timport sys\n\timport traceback\n\tHEREFILE = os.path.abspath(sys.argv[0])\n\tHEREDIR = os.path.dirname(HEREFILE)\n\tTOPDIR = HEREDIR\n\tSRCDIR = f\"{TOPDIR}/src\"\n\tLIBDIR = f\"{SRCDIR}/lib\"\n\tTESTSDIR = f\"{SRCDIR}/tests\"\n\tTOOLSDIR = f\"{SRCDIR}/tools\"\n", "PENVMZIP = f\"{TOOLSDIR}/penvm-zip/penvmzip.py\"\n\tPENVM_CLIENT_LIBS = [\n\t    \"penvmlib-client\",\n\t]\n\tPENVM_SERVER_LIBS = [\n\t    \"penvmlib-server\",\n\t]\n\tAPPS = [\n\t    # (appname, appdir, modname, penvmlibs, extralibs)\n\t    (\"penvm-connect\", f\"{TOOLSDIR}/penvm-connect\", \"penvmconnect\", PENVM_CLIENT_LIBS, None),\n", "    (\"penvm-boot\", f\"{TOOLSDIR}/penvm-boot\", \"penvmboot\", PENVM_CLIENT_LIBS, None),\n\t    (\"penvm-deploy\", f\"{TOOLSDIR}/penvm-deploy\", \"penvmdeploy\", PENVM_CLIENT_LIBS, None),\n\t    (\"penvm-win\", f\"{TOOLSDIR}/penvm-win\", \"penvmwin\", PENVM_CLIENT_LIBS, None),\n\t    (\"penvm-zip\", f\"{TOOLSDIR}/penvm-zip\", \"penvmzip\", PENVM_CLIENT_LIBS, None),\n\t    (\"penvm-server\", f\"{TOOLSDIR}/penvm-server\", \"penvmserver\", PENVM_SERVER_LIBS, None),\n\t]\n\tLIBS = [\n\t    # (libname, libdirs, extralibs)\n\t    (\n\t        \"penvmlib-client\",\n", "        [\n\t            f\"{SRCDIR}/client\",\n\t            f\"{SRCDIR}/lib\",\n\t            f\"{SRCDIR}/kernels\",\n\t            f\"{SRCDIR}/app\",\n\t            f\"{SRCDIR}/ext\",\n\t        ],\n\t        None,\n\t    ),\n\t    # (\"penvmlib-lib\", [f\"{SRCDIR}/lib\"], None),\n", "    # (\"penvmlib-kernels\", [f\"{SRCDIR}/kernels\"], None),\n\t    (\"penvmlib-server\", [f\"{SRCDIR}/server\", f\"{SRCDIR}/lib\", f\"{SRCDIR}/kernels\"], None),\n\t]\n\tTESTS = [\n\t    (\"queue_test\", f\"{TESTSDIR}/queue_test.py\", \"queue_test\", None, None),\n\t    (\"semaphore_test\", f\"{TESTSDIR}/semaphore_test.py\", \"semaphore_test\", None, None),\n\t    (\"session_test\", f\"{TESTSDIR}/session_test.py\", \"session_test\", None, None),\n\t]\n\tdef build_apps(apps, libdir, dstdir):\n\t    \"\"\"Build a zip application with app file and libs then store in a\n", "    directory.\"\"\"\n\t    for appname, appdir, modname, libs, extralibs in apps:\n\t        print()\n\t        extralibs = extralibs or []\n\t        dstfilename = f\"{dstdir}/{appname}\"\n\t        pargs = [\n\t            PENVMZIP,\n\t            \"app\",\n\t            \"-o\",\n\t            dstfilename,\n", "            \"-m\",\n\t            modname,\n\t        ]\n\t        if libs:\n\t            for lib in libs:\n\t                pargs.extend([\"-l\", f\"{libdir}/{lib}\"])\n\t        if extralibs:\n\t            for extralib in extralibs:\n\t                pargs.extend([\"-l\", extralib])\n\t        pargs.append(appdir)\n", "        subprocess.run(pargs)\n\t        os.chmod(dstfilename, 0o755)\n\tdef build_libs(libs, dstdir):\n\t    \"\"\"Build a zip library with libs then store in a directory.\"\"\"\n\t    for libname, libdirs, extralibs in libs:\n\t        print()\n\t        extralibs = extralibs or []\n\t        dstfilename = f\"{dstdir}/{libname}\"\n\t        pargs = [\n\t            PENVMZIP,\n", "            \"lib\",\n\t            \"-o\",\n\t            dstfilename,\n\t        ]\n\t        for extralib in extralibs:\n\t            pargs.extend([\"-l\", extralib])\n\t        if libdirs:\n\t            pargs.extend(libdirs)\n\t        subprocess.run(pargs)\n\t        os.chmod(dstfilename, 0o644)\n", "def print_usage():\n\t    progname = os.path.basename(sys.argv[0])\n\t    print(\n\t        f\"\"\"\\\n\tusage: {progname} <installdir>\n\t       {progname} -h|--help\n\tBuild files and install.\n\tArguments:\n\t<installdir>            Installation directory.\n\t\"\"\",\n", "        end=\"\",\n\t    )\n\tclass ArgOpts:\n\t    pass\n\tdef main():\n\t    try:\n\t        argopts = ArgOpts()\n\t        argopts.installdir = None\n\t        args = sys.argv[1:]\n\t        while args:\n", "            arg = args.pop(0)\n\t            if arg in [\"-h\", \"--help\"]:\n\t                print_usage()\n\t                sys.exit(0)\n\t            elif not args:\n\t                argopts.installdir = arg\n\t            else:\n\t                raise Exception()\n\t        if argopts.installdir == None:\n\t            raise Exception()\n", "    except SystemExit:\n\t        raise\n\t    except Exception as e:\n\t        print(e)\n\t        msg = e.msg if e and e.msg != \"\" else \"bad/missing arguments\"\n\t        print(f\"error: {msg}\", file=sys.stderr)\n\t        sys.exit(1)\n\t    try:\n\t        bindir = f\"{argopts.installdir}/bin\"\n\t        libdir = f\"{argopts.installdir}/lib\"\n", "        testsdir = f\"{argopts.installdir}/tests\"\n\t        sharedir = f\"{argopts.installdir}/share/penvm\"\n\t        os.makedirs(bindir, exist_ok=True)\n\t        os.makedirs(libdir, exist_ok=True)\n\t        os.makedirs(sharedir, exist_ok=True)\n\t        os.makedirs(testsdir, exist_ok=True)\n\t        # this tool: penvmzip\n\t        # shutil.copy(PENVMZIP, f\"{bindir}/penvm-zip\")\n\t        # library (FIRST!)\n\t        build_libs(LIBS, libdir)\n", "        # apps\n\t        build_apps(APPS, libdir, bindir)\n\t        build_apps(TESTS, libdir, testsdir)\n\t        # miscellaneous\n\t        shutil.copy(f\"{TOPDIR}/README.md\", f\"{sharedir}/README.md\")\n\t        shutil.copy(f\"{TOPDIR}/LICENSE\", f\"{sharedir}/LICENSE\")\n\t    except Exception as e:\n\t        traceback.print_exc()\n\t        print(f\"error: {e}\", file=sys.stderr)\n\t        sys.exit(1)\n", "if __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/tools/penvm-boot/penvmboot.py", "chunked_list": ["#! /usr/bin/env python3\n\t#\n\t# tools/penvmboot.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Set up a PENVM network.\n\t\"\"\"\n", "import os\n\timport os.path\n\timport subprocess\n\timport sys\n\timport time\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.app.boot import Booter\n\tdef print_usage():\n\t    progname = os.path.basename(sys.argv[0])\n\t    print(\n", "        f\"\"\"\\\n\tusage: {progname} [--shell <path>] [-N <network>] <config>\n\t       {progname} -h|--help\n\tStart PENVM network. Optionally start a shell, else wait indefinitely\n\t(until killed).\n\tArguments:\n\t<config>            Configuration file (.penvm).\n\t-N <network>        Start named network. Default is \"default\".\n\t--shell <path>      Run a shell.\n\t--verbose           Output informative details.\n", "\"\"\",\n\t        end=\"\",\n\t    )\n\tclass ArgOpts:\n\t    pass\n\tdef main():\n\t    try:\n\t        argopts = ArgOpts()\n\t        argopts.filename = None\n\t        argopts.network = \"default\"\n", "        argopts.release = None\n\t        argopts.shell = None\n\t        argopts.verbose = False\n\t        args = sys.argv[1:]\n\t        while args:\n\t            arg = args.pop(0)\n\t            if arg in [\"-h\", \"--help\"]:\n\t                print_usage()\n\t                sys.exit(0)\n\t            elif arg == \"-N\" and args:\n", "                argopts.network = args.pop(0)\n\t            elif arg == \"-r\" and args:\n\t                argopts.release = args.pop(0)\n\t            elif arg == \"--shell\" and args:\n\t                argopts.shell = args.pop(0)\n\t            elif arg == \"--verbose\":\n\t                argopts.verbose = True\n\t            elif not args:\n\t                argopts.filename = arg\n\t            else:\n", "                raise Exception(\"bad/missing argument\")\n\t        if None in [argopts.filename]:\n\t            raise Exception()\n\t    except SystemExit:\n\t        raise\n\t    except Exception as e:\n\t        print(f\"error: {e}\", file=sys.stderr)\n\t        sys.exit(1)\n\t    try:\n\t        booter = Booter(\n", "            argopts.filename,\n\t            argopts.network,\n\t            argopts.release,\n\t        )\n\t        booter.boot()\n\t        if argopts.verbose:\n\t            print(f\"machines available ({len(booter.network.get_machines())})\")\n\t        if argopts.shell:\n\t            PS1 = f\"\"\"[pvshell] {booter.env.get(\"PS1\", \"\")}\"\"\"\n\t            booter.env[\"PS1\"] = PS1\n", "            booter.env[\"XPS1\"] = PS1\n\t        # print env info\n\t        if argopts.verbose:\n\t            print(\"environment settings:\")\n\t            print(f\"\"\"    export PENVM_AUTO_NETWORK=\"{booter.env['PENVM_AUTO_NETWORK']}\" \"\"\")\n\t            print(f\"\"\"    export PENVM_RELEASE={booter.release}\"\"\")\n\t            print(f\"\"\"    export PYTHONPATH=\"{booter.env['PYTHONPATH']}\" \"\"\")\n\t            # print(f\"\"\"    export PS1=\"{PS1}\" \"\"\")\n\t        if not argopts.shell:\n\t            if argopts.verbose:\n", "                print(\"sleeping ...\")\n\t            booter.wait()\n\t        else:\n\t            if argopts.verbose:\n\t                print(f\"starting shell ({argopts.shell}) ...\")\n\t            booter.shell(argopts.shell)\n\t        if 0:\n\t            world = World(filename=argopts.filename)\n\t            network = world.get_network(argopts.network)\n\t            # print(f\"{network=}\")\n", "            if network == None or network.get_targets() in [None, []]:\n\t                raise Exception(f\"network ({argopts.network}) not found\")\n\t            network.boot()\n\t            machines = network.get_machines()\n\t            if machines in [None, []]:\n\t                raise Exception(\"no machines\")\n\t            if None in machines:\n\t                raise Exception(\"not all machines found\")\n\t            if argopts.verbose:\n\t                print(f\"machines available ({len(machines)})\")\n", "            machconnspecs = [MachineConnectionSpec(machine=machine) for machine in machines]\n\t            release = argopts.release or world.get_meta(\"release\") or get_version_string()\n\t            if release == None:\n\t                raise Exception(f\"could not determine release value\")\n\t            releasepath = os.path.expanduser(f\"~/.penvm/releases/{release}\")\n\t            releaselibs = \":\".join([f\"{releasepath}/{name}\" for name in [\"penvmlib-client\"]])\n\t            # patch env\n\t            env = os.environ.copy()\n\t            PENVM_AUTO_NETWORK = \" \".join([str(machconnspec) for machconnspec in machconnspecs])\n\t            PYTHONPATH = env.get(\"PYTHONPATH\")\n", "            PYTHONPATH = f\":{PYTHONPATH}\" if PYTHONPATH != None else \"\"\n\t            PS1 = f\"\"\"[pvshell] {env[\"PS1\"]}\"\"\"\n\t            env[\"PENVM_AUTO_NETWORK\"] = PENVM_AUTO_NETWORK\n\t            env[\"PYTHONPATH\"] = f\"{releaselibs}{PYTHONPATH}\"\n\t            env[\"PENVM_RELEASE\"] = release\n\t            env[\"PS1\"] = PS1\n\t            env[\"XPS1\"] = PS1\n\t            # print env info\n\t            if argopts.verbose:\n\t                print(\"environment settings:\")\n", "                print(f\"\"\"    export PENVM_AUTO_NETWORK=\"{PENVM_AUTO_NETWORK}\" \"\"\")\n\t                print(f\"\"\"    export PENVM_RELEASE={release}\"\"\")\n\t                print(f\"\"\"    export PYTHONPATH=\"{releaselibs}:$PYTHONPATH\" \"\"\")\n\t                print(f\"\"\"    export PS1=\"{PS1}\" \"\"\")\n\t            if not argopts.shell:\n\t                if argopts.verbose:\n\t                    print(\"sleeping ...\")\n\t                time.sleep(10000000)\n\t            else:\n\t                if argopts.verbose:\n", "                    print(f\"starting shell ({argopts.shell}) ...\")\n\t                try:\n\t                    sp = subprocess.Popen(\n\t                        [argopts.shell],\n\t                        pass_fds=[0, 1, 2],\n\t                        env=env,\n\t                    )\n\t                except Exception as e:\n\t                    raise Exception(f\"failed to start shell ({argopts.shell})\")\n\t                try:\n", "                    # close streams\n\t                    sys.stdin.close()\n\t                    sys.stdout.close()\n\t                    sys.stderr.close()\n\t                    # close fds\n\t                    os.close(0)\n\t                    os.close(1)\n\t                    os.close(2)\n\t                except Exception as e:\n\t                    raise Exception(\"failed to close streams/fds\")\n", "                os.waitpid(sp.pid, 0)\n\t    except KeyboardInterrupt:\n\t        pass\n\t    except Exception as e:\n\t        print(f\"error: {e}\", file=sys.stderr)\n\t        sys.exit(1)\n\t    if argopts.verbose:\n\t        print(\"exiting ...\")\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/tools/penvm-win/penvmwin.py", "chunked_list": ["#! /usr/bin/env python3\n\t#\n\t# tools/penvmwin.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Set up (local) windows/terminals for a PENVM network.\n\t\"\"\"\n", "import os\n\timport os.path\n\timport subprocess\n\timport sys\n\timport tempfile\n\timport time\n\timport traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.client.world import World\n\tHEREFILE = os.path.abspath(sys.argv[0])\n", "TERMINAL_EXEC = os.environ.get(\"PENVM_WIN_TERMINAL\", \"xterm\")\n\tdef bytetail_main():\n\t    import codecs\n\t    import fcntl\n\t    def bytetail_open():\n\t        try:\n\t            filename = sys.argv[1]\n\t            # print(f\"{filename=}\")\n\t            if filename == \"-\":\n\t                f = os.fdopen(sys.stdin.fileno(), \"rb\", buffering=0)\n", "            else:\n\t                f = open(filename, \"rb\", buffering=0)\n\t            # print(f\"opening file ({filename=}) ({f=})\")\n\t            return f\n\t        except Exception as e:\n\t            traceback.print_exc()\n\t            print(f\"error: {e}\", file=sys.stderr)\n\t            sys.exit(1)\n\t    def bytetail_read(f):\n\t        try:\n", "            dec = codecs.getincrementaldecoder(\"utf-8\")()\n\t            flags = fcntl.fcntl(f.fileno(), fcntl.F_GETFL)\n\t            flags_block = flags\n\t            flags_nonblock = flags | os.O_NONBLOCK\n\t            while True:\n\t                # read one byte as soon as available\n\t                fcntl.fcntl(f.fileno(), fcntl.F_SETFL, flags_block)\n\t                buf = f.read(1)\n\t                if buf in [b\"\", None]:\n\t                    # EOF\n", "                    break\n\t                s = dec.decode(buf)\n\t                if s:\n\t                    print(s, end=\"\", flush=True)\n\t                # read chunks of bytes in non-blocking until nothing\n\t                fcntl.fcntl(f.fileno(), fcntl.F_SETFL, flags_nonblock)\n\t                while True:\n\t                    buf = f.read(1024)\n\t                    if buf in [b\"\", None]:\n\t                        # EOF or timeout\n", "                        break\n\t                    s = dec.decode(buf)\n\t                    if s:\n\t                        print(s, end=\"\", flush=True)\n\t        except Exception as e:\n\t            traceback.print_exc()\n\t            pass\n\t    try:\n\t        while True:\n\t            # print(\"starting bytetail loop ...\")\n", "            timestamp = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime())\n\t            print(f\"---- [{timestamp}] ------ ↑ ↑ ↑ ↑ ----------\")\n\t            f = bytetail_open()\n\t            bytetail_read(f)\n\t    finally:\n\t        windows.close()\n\t    sys.exit(0)\n\tclass Window:\n\t    \"\"\"Log window which creates and monitors a log/fifo file.\"\"\"\n\t    tempd = tempfile.TemporaryDirectory()\n", "    def __init__(self, name, title, usefifo=True, cleanlog=True):\n\t        self.name = name\n\t        self.title = title\n\t        self.path = f\"{self.tempd.name}/{self.name}\"\n\t        self.usefifo = usefifo\n\t        self.cleanlog = cleanlog\n\t        if usefifo:\n\t            os.mkfifo(self.path, mode=0o600)\n\t        else:\n\t            # touch\n", "            self.fd = os.open(self.path, os.O_CREAT, mode=0o600)\n\t            os.close(self.fd)\n\t        self.fd = None\n\t        self.p = None\n\t    def __del__(self):\n\t        \"\"\"Clean up.\"\"\"\n\t        try:\n\t            if self.fd != None:\n\t                os.close(self.fd)\n\t                self.fd = None\n", "        except:\n\t            pass\n\t        try:\n\t            if os.path.exists(self.path):\n\t                if self.cleanlog or self.usefifo:\n\t                    os.remove(self.path)\n\t        except:\n\t            pass\n\t    def kill(self):\n\t        try:\n", "            self.p.kill()\n\t            self.p = None\n\t        except:\n\t            pass\n\t    def write(self, buf):\n\t        if self.p == None:\n\t            return\n\t        if self.fd == None:\n\t            self.fd = os.open(self.path, os.O_RDWR)\n\t        os.write(self.fd, buf.encode(\"utf-8\"))\n", "    def terminal(self):\n\t        filename = os.path.basename(TERMINAL_EXEC)\n\t        if filename in [\"xterm\"]:\n\t            title_opt = \"-title\"\n\t            execute_opt = \"-e\"\n\t        elif filename in [\"gnome-terminal\"]:\n\t            title_opt = \"--title\"\n\t            execute_opt = \"--\"\n\t        else:\n\t            title_opt = \"--title\"\n", "            execute_opt = \"-x\"\n\t        self.p = subprocess.Popen(\n\t            [TERMINAL_EXEC, title_opt, self.name, execute_opt, HEREFILE, \"--bytetail\", self.path],\n\t            stdout=subprocess.DEVNULL,\n\t            stderr=subprocess.DEVNULL,\n\t            stdin=subprocess.DEVNULL,\n\t            close_fds=True,\n\t        )\n\tclass Windows:\n\t    \"\"\"Manage multiple log windows.\"\"\"\n", "    def __init__(self, usefifo=True, cleanlog=True):\n\t        self.usefifo = usefifo\n\t        self.cleanlog = cleanlog\n\t        self.windows = {}\n\t    def add(self, name):\n\t        self.windows[name] = Window(\n\t            name,\n\t            f\"Machine: {name}\",\n\t            usefifo=self.usefifo,\n\t            cleanlog=self.cleanlog,\n", "        )\n\t    def close(self):\n\t        for w in self.windows.values():\n\t            w.kill()\n\t    def get_spec(self):\n\t        # TODO: change method name\n\t        return \" \".join([f\"{w.name}:{w.path}\" for w in self.windows.values()])\n\t    def terminal(self):\n\t        for w in self.windows.values():\n\t            w.terminal()\n", "    def write(self, name, out):\n\t        w = self.windows.get(name)\n\t        if w:\n\t            w.write(str(out))\n\t    def write_all(self, out):\n\t        for w in self.windows.values():\n\t            w.write(out)\n\t    def write_named(self, d):\n\t        for name, out in d.items():\n\t            self.write(name, out)\n", "    def write_sep(self, name, sep=None):\n\t        sep = sep or \"-\" * 40\n\t        self.write(name, sep)\n\tdef print_usage():\n\t    progname = os.path.basename(sys.argv[0])\n\t    print(\n\t        f\"\"\"\\\n\tusage: {progname} [--shell <path>] [<networkstr]\n\t       {progname} -h|--help\n\tStart log windows for a running PENVM network (at\n", "PENVM_AUTO_NETWORK). Optionally start a shell, else wait\n\tindefinitely (until killed).\n\tArguments:\n\t<networkstr>        PENVM network of running machine instances.\n\t--shell <path>      Run a shell.\n\t\"\"\",\n\t        end=\"\",\n\t    )\n\tclass ArgOpts:\n\t    pass\n", "def main():\n\t    try:\n\t        argopts = ArgOpts()\n\t        argopts.networkstr = os.environ.get(\"PENVM_AUTO_NETWORK\")\n\t        argopts.shell = None\n\t        args = sys.argv[1:]\n\t        # special/unadvertised\n\t        if args and args[0] == \"--bytetail\":\n\t            del sys.argv[1]\n\t            bytetail_main()\n", "            sys.exit(0)\n\t        while args:\n\t            arg = args.pop(0)\n\t            if arg in [\"-h\", \"--help\"]:\n\t                print_usage()\n\t                sys.exit(0)\n\t            elif arg == \"--shell\" and args:\n\t                argopts.shell = args.pop(0)\n\t            elif not args:\n\t                argopts.networkstr = arg\n", "            else:\n\t                raise Exception(\"bad/missing argument\")\n\t        if argopts.networkstr in [None, \"\"]:\n\t            raise Exception(\"network string not found\")\n\t    except SystemExit:\n\t        raise\n\t    except Exception as e:\n\t        print(\"error: {e}\", file=sys.stderr)\n\t        sys.exit(1)\n\t    try:\n", "        world = World()\n\t        network = World.network()\n\t        windows = Windows()\n\t        machidhostports = argopts.machidhostports.split()\n\t        for machidhostport in machidhostports:\n\t            machid, sslprofile, host, port = machidhostport.split(\":\", 3)\n\t            # print(f\"adding machine ({machid})\")\n\t            windows.add(machid)\n\t        windows.terminal()\n\t        env = os.environ.copy()\n", "        env[\"PENVM_WINDOWS\"] = windows.get_spec()\n\t        print(f\"\"\"export PENVM_WINDOWS=\"{env.get('PENVM_WINDOWS')}\" \"\"\")\n\t        if not argopts.shell:\n\t            print(\"sleeping ...\")\n\t            time.sleep(10000000)\n\t        else:\n\t            print(f\"starting shell ({argopts.shell}) ...\")\n\t            try:\n\t                sp = subprocess.Popen(\n\t                    [argopts.shell],\n", "                    pass_fds=[0, 1, 2],\n\t                    env=env,\n\t                )\n\t            except Exception as e:\n\t                raise Exception(f\"failed to start shell ({argopts.shell})\")\n\t            try:\n\t                # close streams\n\t                sys.stdin.close()\n\t                sys.stdout.close()\n\t                sys.stderr.close()\n", "                # close fds\n\t                os.close(0)\n\t                os.close(1)\n\t                os.close(2)\n\t            except Exception as e:\n\t                raise Exception(\"failed to close streams/fds\")\n\t            os.waitpid(sp.pid, 0)\n\t        print(\"exiting\")\n\t    except Exception as e:\n\t        # traceback.print_exc()\n", "        print(f\"error: {e}\", file=sys.stderr)\n\t        sys.exit(1)\n\t    sys.exit(0)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/tools/penvm-server/penvmserver.py", "chunked_list": ["#! /usr/bin/env python3\n\t#\n\t# tools/penvmserver.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"PENVM server.\n\t\"\"\"\n", "import logging\n\timport os\n\timport os.path\n\timport subprocess\n\timport sys\n\tfrom sys import stderr\n\timport tempfile\n\timport time\n\timport traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n", "from penvm.lib.base import BaseObject\n\tfrom penvm.server.machine import Machine\n\t# set in main()\n\tlogger = None\n\tclass Server(BaseObject):\n\t    def __init__(self):\n\t        try:\n\t            super().__init__(None, logger)\n\t            self.logger.debug(\"init\")\n\t        except Exception as e:\n", "            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            pass\n\t    def background(self):\n\t        \"\"\"Put in background.\n\t        Steps:\n\t        1. Forks (multistep).\n\t        2. Closes stdin, stdout, stderr.\"\"\"\n\t        self.logger.debug(\"backgrounding ...\")\n\t        # fork 1\n", "        pid = os.fork()\n\t        if pid > 0:\n\t            # os._exit(0)\n\t            sys.exit(0)\n\t        os.setsid()\n\t        os.chdir(\"/\")\n\t        # fork 2\n\t        pid = os.fork()\n\t        if pid > 0:\n\t            # os._exit(0)\n", "            sys.exit(0)\n\t        # close fds\n\t        sys.stdout.flush()\n\t        sys.stderr.flush()\n\t        si = open(\"/dev/null\", \"r\")\n\t        so = open(\"/dev/null\", \"a+\")\n\t        se = open(\"/dev/null\", \"a+\")\n\t        os.dup2(si.fileno(), sys.stdin.fileno())\n\t        os.dup2(so.fileno(), sys.stdout.fileno())\n\t        os.dup2(se.fileno(), sys.stderr.fileno())\n", "        self.logger.debug(\"background exit\")\n\t    def respawn(self, argopts):\n\t        self.logger.debug(\"respawning ...\")\n\t        args = sys.argv[:]\n\t        # force full path\n\t        args[0] = os.path.realpath(args[0])\n\t        f = tempfile.NamedTemporaryFile(\"rt\")\n\t        # print(f\"{f.name=} {f.file=}\")\n\t        args.insert(1, \"--announce-file\")\n\t        args.insert(2, f.name)\n", "        # force python3\n\t        if args[0] != \"python3\":\n\t            args.insert(0, \"python3\")\n\t        self.logger.debug(f\"{args=}\")\n\t        cp = subprocess.run(\n\t            args,\n\t            stdin=subprocess.DEVNULL,\n\t            stdout=subprocess.DEVNULL,\n\t            stderr=subprocess.DEVNULL,\n\t            # capture_output=True,\n", "            # text=True,\n\t            cwd=\"/\",\n\t            start_new_session=True,\n\t        )\n\t        # print(f\"{cp=}\")\n\t        if cp.returncode != 0:\n\t            # print(f\"error: failed to respawn\", file=sys.stderr, flush=True)\n\t            self.logger.debug(f\"failed to respawn {cp.returncode=} {cp.stdout=} {cp.stderr=}\")\n\t            sys.exit(cp.returncode)\n\t        if argopts.announce:\n", "            # TODO: change this to a pipe!\n\t            s = \"announce::\"\n\t            while True:\n\t                s += f.file.read()\n\t                # print(f\"{s=}\")\n\t                if \"\\n\" in s:\n\t                    break\n\t                time.sleep(0.2)\n\t            print(s, flush=True)\n\t        sys.exit(0)\n", "    def run(self, argopts):\n\t        self.logger.debug(\"running ...\")\n\t        if argopts.background:\n\t            self.background()\n\t        self.logger.debug(\n\t            f\"machine configuration: id={argopts.machineid} host={argopts.host} port={argopts.port}\"\n\t        )\n\t        self.logger.debug(\"creating machine ...\")\n\t        try:\n\t            machine = Machine(\n", "                argopts.host,\n\t                argopts.port,\n\t                sslprofile=argopts.sslprofile,\n\t                machineid=argopts.machineid,\n\t            )\n\t            time.sleep(0.2)\n\t            if argopts.announce and argopts.announce_filename:\n\t                lhost, lport = machine.get_addr_port()\n\t                self.logger.debug(\n\t                    f\"announcement machineid={argopts.machineid} addr={lhost} port={lport} ssl-profile={argopts.sslprofile}\"\n", "                )\n\t                print(\n\t                    f\"{argopts.machineid}:{argopts.sslprofile or ''}:{lhost}:{lport}\",\n\t                    file=open(argopts.announce_filename, \"a\"),\n\t                    flush=True,\n\t                )\n\t        except Exception as e:\n\t            self.logger.debug(f\"failed to start machine {traceback.format_exc()}\")\n\t        # sys.exit(0)\n\t        self.logger.debug(\"starting/running machine ...\")\n", "        # TODO: move `ltimeout`` setting elsewhere\n\t        machine.connmgr.ltimeout = argopts.firstwait\n\t        if 1:\n\t            machine.start()\n\t            machine.wait()\n\t        if 0:\n\t            machine.run()\n\t        self.logger.debug(\"exiting ...\")\n\tdef print_usage():\n\t    progname = os.path.basename(sys.argv[0])\n", "    print(\n\t        f\"\"\"\\\n\tusage: {progname} [<options>] <host> [<port>]\n\t       {progname} -h|--help\n\tStart penvm server.\n\tArguments:\n\t<host>          Address to listen on.\n\t<port>          Port to listen on. Default is 0, which autoselects an\n\t                available port.\n\t--announce      Write <host>:<port> of the listening socket to the\n", "                announce file.\n\t--announce-file <filename>\n\t                Filename to hold the announce info.\n\t--background    Put server into background: detach from session and\n\t                redirect I/O to `/dev/null`.\n\t--firstwait <seconds>\n\t                Time to wait for first connection before exiting.\n\t                Default is 30 seconds.\n\t--machineid <id>\n\t                Id to use for machine.\n", "--ssl-profile <name>\n\t                SSL profile name.\n\t\"\"\",\n\t        end=\"\",\n\t    )\n\tclass ArgOpts:\n\t    pass\n\tdef main():\n\t    global logger\n\t    try:\n", "        argopts = ArgOpts()\n\t        argopts.announce = False\n\t        argopts.announce_filename = None\n\t        argopts.background = False\n\t        argopts.firstwait = 30\n\t        argopts.host = None\n\t        argopts.machineid = None\n\t        argopts.port = 0\n\t        argopts.sslprofile = None\n\t        args = sys.argv[1:]\n", "        while args:\n\t            arg = args.pop(0)\n\t            if arg == \"--announce\":\n\t                argopts.announce = True\n\t            elif arg == \"--announce-file\" and args:\n\t                argopts.announce_filename = args.pop(0)\n\t            elif arg == \"--background\":\n\t                argopts.background = True\n\t            elif arg == \"--firstwait\" and args:\n\t                argopts.firstwait = int(args.pop(0))\n", "            elif arg in [\"-h\", \"--help\"]:\n\t                print_usage()\n\t                sys.exit(0)\n\t            elif arg == \"--machineid\" and args:\n\t                argopts.machineid = args.pop(0)\n\t            elif arg == \"--ssl-profile\" and args:\n\t                argopts.sslprofile = args.pop(0)\n\t            else:\n\t                argopts.host = arg\n\t                if args:\n", "                    argopts.port = int(args.pop(0))\n\t                if args:\n\t                    raise Exception()\n\t        if argopts.host == None:\n\t            raise Exception()\n\t    except SystemExit:\n\t        raise\n\t    except Exception as e:\n\t        print(\"error: bad/missing argument\", file=sys.stderr)\n\t        sys.exit(1)\n", "    # set up logger\n\t    username = os.environ.get(\"USER\", os.environ.get(\"LOGNAME\", os.getpid()))\n\t    logging.basicConfig(\n\t        filename=f\"/tmp/penvmserver-{username}.log\",\n\t        format=\"%(asctime)s:%(levelname)s:%(process)s:%(name)s:%(lineno)d:%(funcName)s:%(msg)s\",\n\t    )\n\t    logger = logging.getLogger()\n\t    logger.setLevel(logging.DEBUG)\n\t    logger = logging.getLogger(__name__)\n\t    # create server\n", "    server = Server()\n\t    if not argopts.announce_filename:\n\t        # patch sys.argv for respawn\n\t        sys.argv[0] = os.path.abspath(sys.argv[0])\n\t        server.respawn(argopts)\n\t    else:\n\t        server.run(argopts)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/tools/penvm-connect/penvmconnect.py", "chunked_list": ["#! /usr/bin/env python3\n\t#\n\t# tools/penvmconnect.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Connect to the servers running on a PENVM network/machine.\n\t\"\"\"\n", "import code\n\timport os.path\n\timport sys\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.client.world import World\n\tdef print_usage():\n\t    progname = os.path.basename(sys.argv[0])\n\t    print(\n\t        f\"\"\"\\\n\tusage: {progname} [<networkstr>]\n", "       {progname} -h|--help\n\tConnect to a PENVM network of running machine instances and interact\n\tin a Python shell.\n\tArguments:\n\t<networkstr>        Network string consisting of one or more,\n\t                    space-separated, machine connection strings\n\t                    (format <machineid>:<sslprofile>:<host>:<port>)\n\t                    for each running machine. Defaults to\n\t                    PENVM_AUTO_NETWORK.\n\t\"\"\",\n", "        end=\"\",\n\t    )\n\tclass ArgOpts:\n\t    pass\n\tdef main():\n\t    try:\n\t        argopts = ArgOpts()\n\t        argopts.networkstr = os.environ.get(\"PENVM_AUTO_NETWORK\")\n\t        args = sys.argv[1:]\n\t        while args:\n", "            arg = args.pop(0)\n\t            if arg in [\"-h\", \"--help\"]:\n\t                print_usage()\n\t                sys.exit(1)\n\t            elif not args:\n\t                argopts.networkstr = arg\n\t            else:\n\t                raise Exception(\"bad/missing argument\")\n\t        if argopts.networkstr in [None, \"\"]:\n\t            raise Exception(\"network string not found\")\n", "    except SystemExit:\n\t        raise\n\t    except Exception as e:\n\t        print(f\"error: {e}\", file=sys.stderr)\n\t        sys.exit(1)\n\t    try:\n\t        world = World(networkstr=argopts.networkstr)\n\t        network = world.get_network()\n\t        network.boot()\n\t        machines = network.get_machines()\n", "        machconnspecs = [m.get_machconnspec() for m in machines]\n\t        # TODO: restrict globals and locals\n\t        code.interact(\n\t            banner=\"\"\"Ready.\\n\"\"\"\n\t            \"\"\"Use \"machines\" to access machines.\\n\"\"\"\n\t            \"\"\"Use \"machconnspecs\" to access machine connection specs.\\n\"\"\"\n\t            \"\"\"Use \"network\" for network.\"\"\",\n\t            local=dict(globals(), **locals()),\n\t        )\n\t    except SystemExit:\n", "        raise\n\t    except Exception as e:\n\t        print(f\"error: {e}\", file=sys.stderr)\n\t        sys.exit(1)\n\t    sys.exit(0)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/tools/penvm-deploy/penvmdeploy.py", "chunked_list": ["#! /usr/bin/env -S python3 -B\n\t#\n\t# tools/penvmdeploy.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"PENVM library and server deployment tool.\n\tUsing a .penvm configration, deploys the zipped penvm libraries and\n", "zipapp penvmserver to a set of targets.\n\t\"\"\"\n\timport os.path\n\timport subprocess\n\timport sys\n\timport traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tHEREFILE = os.path.abspath(sys.argv[0])\n\tHEREDIR = os.path.dirname(HEREFILE)\n\tTOPDIR = os.path.dirname(HEREDIR)\n", "BINDIR = f\"{TOPDIR}/bin\"\n\tLIBDIR = f\"{TOPDIR}/lib\"\n\tPENVMLIBS = [\n\t    f\"{LIBDIR}/penvmlib-client\",\n\t    # f\"{LIBDIR}/penvmlib-kernels\",\n\t    # f\"{LIBDIR}/penvmlib-lib\",\n\t    f\"{LIBDIR}/penvmlib-server\",\n\t]\n\tPENVMSERVER = f\"{BINDIR}/penvm-server\"\n\t# access local libs\n", "sys.path.insert(0, f\"{LIBDIR}/penvmlib-lib\")\n\tsys.path.insert(0, f\"{LIBDIR}/penvmlib-client\")\n\tfrom penvm.client.world import World\n\tfrom penvm.lib.misc import get_version_string\n\tdef deploy_penvmfiles(release, fshomeid, user, host, filenames, dryrun=False):\n\t    \"\"\"Install file(s) under ~/.penvm/releases/<release>.\"\"\"\n\t    dstdir = f\".penvm/releases/{release}\"\n\t    for filename in filenames:\n\t        print(f\"{filename} -> {user or ''}@{host} fshomeid ({fshomeid}) release ({release}) ... \")\n\t        if dryrun:\n", "            continue\n\t        cp = remote_mkdir(user, host, dstdir)\n\t        if cp.returncode != 0:\n\t            print(f\"failed ({cp.stderr})\")\n\t            continue\n\t        dstpath = f\"{dstdir}/{os.path.basename(filename)}\"\n\t        cp = remote_copyfile(user, host, filename, dstpath)\n\t        if cp.returncode != 0:\n\t            print(f\"failed ({cp.stderr})\")\n\tdef remote_copyfile(user, host, srcpath, dstpath):\n", "    \"\"\"Copy local file to remote.\"\"\"\n\t    userhost = f\"{user}@{host}\" if user != None else host\n\t    userhostpath = f\"{userhost}:{dstpath}\"\n\t    spargs = [\n\t        \"scp\",\n\t        srcpath,\n\t        userhostpath,\n\t    ]\n\t    cp = subprocess.run(spargs, capture_output=True)\n\t    return cp\n", "def remote_mkdir(user, host, path):\n\t    \"\"\"Create remote directory.\"\"\"\n\t    userhost = f\"{user}@{host}\" if user != None else host\n\t    spargs = [\n\t        \"ssh\",\n\t        userhost,\n\t        \"python3\",\n\t        \"-c\",\n\t        f\"\"\"'import os; os.makedirs(\"{path}\", exist_ok=True)'\"\"\",\n\t    ]\n", "    cp = subprocess.run(spargs, capture_output=True)\n\t    return cp\n\tdef print_usage():\n\t    progname = os.path.basename(sys.argv[0])\n\t    print(\n\t        f\"\"\"\\\n\tusage: {progname} [--dry] [-N <network>[,...] [-l <libfile>] [-s <serverfile>] <config>\n\t       {progname} [--list] <config>\n\t       {progname} -h|--help\n\tDeploy libraries and penvmserver to targets taken from a .penvm\n", "configuration file.\n\tArguments:\n\t<config>            Configuration file (.penvm suffix).\n\t--dry               Run without making any changes.\n\t-l <libfile>        Libraries. Default is from lib/.\n\t-N <network>[,...]  Apply to targets in named networks.\n\t-r <release>        Deploy to alternate release name.\n\t-s <serverfile>     Server file. Default is from bin/.\n\t\"\"\",\n\t        end=\"\",\n", "    )\n\tclass ArgOpts:\n\t    pass\n\tdef main():\n\t    try:\n\t        argopts = ArgOpts()\n\t        argopts.dryrun = False\n\t        argopts.list = False\n\t        argopts.networks = None\n\t        argopts.penvmlib_filenames = PENVMLIBS\n", "        argopts.penvmserver_filename = PENVMSERVER\n\t        argopts.release = None\n\t        argopts.world_filename = None\n\t        args = sys.argv[1:]\n\t        while args:\n\t            arg = args.pop(0)\n\t            if arg in [\"-h\", \"--help\"]:\n\t                print_usage()\n\t                sys.exit(0)\n\t            elif arg == \"--dry\":\n", "                argopts.dryrun = True\n\t            elif arg == \"-l\" and args:\n\t                argopts.penvmlib_filename = args.pop(0)\n\t            elif arg == \"--list\":\n\t                argopts.list = True\n\t            elif arg == \"-N\":\n\t                argopts.networks = args.pop(0).split(\",\")\n\t            elif arg == \"-r\" and args:\n\t                argopts.release = args.pop(0)\n\t            elif arg == \"-s\" and args:\n", "                argopts.penvmserver_filename = args.pop(0)\n\t            elif not args:\n\t                argopts.world_filename = arg\n\t            else:\n\t                raise Exception()\n\t        if argopts.list:\n\t            if None in [argopts.world_filename]:\n\t                raise Exception()\n\t        else:\n\t            if None in [argopts.penvmserver_filename, argopts.world_filename]:\n", "                raise Exception()\n\t    except SystemExit:\n\t        raise\n\t    except Exception as e:\n\t        print(f\"error: bad/missing arguments ({e})\", file=sys.stderr)\n\t        sys.exit(1)\n\t    try:\n\t        try:\n\t            world = World(filename=argopts.world_filename)\n\t        except Exception as e:\n", "            print(e)\n\t            print(\n\t                f\"error: bad or nonexistent config file ({argopts.world_filename})\",\n\t                file=sys.stderr,\n\t            )\n\t            sys.exit(1)\n\t        if argopts.list == True:\n\t            network_names = world.get_network_names()\n\t            print(f\"networks: {list(network_names)}\")\n\t            for network_name in network_names:\n", "                network = world.get_network(network_name)\n\t                if network != None:\n\t                    print(f\"targets[{network_name}]: {list(network.get_target_names())}\")\n\t            print(f\"targets[*]: {list(world.get_target_names())}\")\n\t            sys.exit(0)\n\t        if argopts.networks:\n\t            target_names = set()\n\t            for network_name in argopts.networks:\n\t                network = world.get_network(network_name)\n\t                if network != None:\n", "                    target_names.update(network.get_target_names())\n\t        else:\n\t            target_names = world.get_target_names()\n\t        # print(f\"{target_names=}\")\n\t        userfshomeid2hosts = {}\n\t        for target_name in target_names:\n\t            target = world.get_target(target_name)\n\t            # print(f\"{target=}\")\n\t            fshomeid = target.config.get(\"fshome-id\")\n\t            user = target.config.get(\"user\")\n", "            host = target.config.get(\"host\")\n\t            hosts = userfshomeid2hosts.setdefault((user, fshomeid), set())\n\t            hosts.add(host)\n\t        # print(f\"{userfshomeid2hosts=}\")\n\t        filenames = argopts.penvmlib_filenames[:]\n\t        filenames.append(argopts.penvmserver_filename)\n\t        release = argopts.release or world.get_meta(\"release\") or get_version_string()\n\t        for userfshomeid, hosts in userfshomeid2hosts.items():\n\t            user, fshomeid = userfshomeid\n\t            if fshomeid != None:\n", "                hosts = [list(hosts)[0]]\n\t            for host in hosts:\n\t                deploy_penvmfiles(\n\t                    release,\n\t                    fshomeid,\n\t                    user,\n\t                    host,\n\t                    filenames,\n\t                    dryrun=argopts.dryrun,\n\t                )\n", "    except SystemExit:\n\t        raise\n\t    except Exception as e:\n\t        traceback.print_exc()\n\t        print(f\"unexpected error ({e})\", file=sys.stderr)\n\t        sys.exit(1)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/tools/penvm-zip/penvmzip.py", "chunked_list": ["#! /usr/bin/env -S python3 -B\n\t#\n\t# tools/penvmzip.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Build penvm app or lib file.\n\t\"\"\"\n", "import os\n\timport os.path\n\timport sys\n\timport traceback\n\timport zipapp\n\timport zipfile\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tHEREFILE = os.path.realpath(sys.argv[0])\n\tHEREDIR = os.path.dirname(HEREFILE)\n\tPENVMLIBFILE = os.path.abspath(f\"{HEREDIR}/../../lib/penvmlib\")\n", "PENVMLIBDIR = os.path.abspath(f\"{HEREDIR}/../../lib\")\n\tif 0:\n\t    if os.path.exists(PENVMLIBFILE):\n\t        sys.path.insert(0, PENVMLIBFILE)\n\t        print(\"info: using penvmlib file\")\n\t    elif os.path.exists(PENVMLIBDIR):\n\t        sys.path.insert(0, PENVMLIBDIR)\n\t        print(\"info: using penvm source\")\n\t        PENVMLIBFILE = None\n\t    else:\n", "        print(\"fatal: cannot find PENVM library file or directory\", file=sys.stderr)\n\t        sys.exit(1)\n\t    # from penvm.lib.misc import get_version_string\n\tdef penvmappzip(appname, appfilename, appdir, extralibs, modname, fnname):\n\t    \"\"\"Create a zipapp (application zip archive) application file.\n\t    It will include the PENVM library, the application file, and\n\t    optional extra, non-PENVM, library files.\n\t    \"\"\"\n\t    try:\n\t        print(\n", "            f\"building {appname} ...\\n\"\n\t            f\"    appfile:  {appfilename}\\n\"\n\t            f\"    module:   {modname}\\n\"\n\t            f\"    function: {fnname}\\n\",\n\t            end=\"\",\n\t        )\n\t        print(\"    creating archive ...\")\n\t        zipapp.create_archive(\n\t            source=appdir,\n\t            target=appfilename,\n", "            interpreter=\"/usr/bin/env python3\",\n\t            main=f\"{modname}:{fnname}\",\n\t            compressed=True,\n\t        )\n\t        with zipfile.ZipFile(appfilename, \"a\") as zipf:\n\t            if extralibs:\n\t                for name in extralibs:\n\t                    print(f\"    adding extralib ({name}) ...\")\n\t                    if not os.path.exists(name):\n\t                        raise Exception(f\"cannot find extralib ({name})\")\n", "                    zipfileadd(zipf, name, stripbase=True)\n\t        os.chmod(appfilename, 0o755)\n\t    except Exception as e:\n\t        traceback.print_exc()\n\t        raise Exception(\"failed to build penvm app\")\n\tdef penvmlibzip(libfilename, penvmlibs, extralibs):\n\t    \"\"\"Create a zip archive for the PENVM library. Optionally, add\n\t    extra, non-PENVM, library files.\n\t    \"\"\"\n\t    try:\n", "        print(f\"building library {libfilename} ...\")\n\t        zipf = zipfile.ZipFile(libfilename, \"w\", compression=zipfile.ZIP_DEFLATED)\n\t        if penvmlibs:\n\t            for name in penvmlibs:\n\t                print(f\"    adding library ({name}) ...\")\n\t                if not os.path.exists(name):\n\t                    raise Exception(f\"cannot find penvm lib ({name})\")\n\t                zipfileadd(zipf, name, stripbase=True)\n\t        if extralibs:\n\t            for name in extralibs:\n", "                print(f\"    adding extralib ({name}) ...\")\n\t                if not os.path.exists(name):\n\t                    raise Exception(f\"cannot find extralib ({name})\")\n\t                zipfileadd(zipf, name, stripbase=True)\n\t        zipf.close()\n\t    except Exception as e:\n\t        traceback.print_exc()\n\t        raise Exception(\"failed to build penvm library\")\n\tdef zipfileadd(zipf, path, stripbase=False):\n\t    try:\n", "        zipf2 = zipfile.ZipFile(path, \"r\")\n\t    except:\n\t        zipf2 = None\n\t    if zipf2 != None:\n\t        zipfilemerge(zipf, path)\n\t    else:\n\t        zipfiledirfile(zipf, path, stripbase)\n\tdef zipfiledirfile(zipf, path, stripbase=False):\n\t    arcname = None\n\t    if os.path.isfile(path):\n", "        if stripbase:\n\t            arcname = os.path.basename(path)\n\t        zipf.write(path, arcname=arcname)\n\t    else:\n\t        for root, dirnames, filenames in os.walk(path):\n\t            if stripbase:\n\t                _root = root[len(path) + 1 :]\n\t            else:\n\t                _root = root\n\t            # ensure dirs are added (for non-__init__.py support)\n", "            allnames = dirnames + filenames\n\t            for name in allnames:\n\t                _path = os.path.join(root, name)\n\t                arcname = os.path.join(_root, name)\n\t                # print(f\"{path=} {_path=} {arcname=}\")\n\t                zipf.write(_path, arcname=arcname)\n\tdef zipfilemerge(zipf, path):\n\t    with zipfile.ZipFile(path, \"r\") as zipf2:\n\t        for name in zipf2.namelist():\n\t            zi = zipf2.open(name)\n", "            zipf.writestr(name, zi.read())\n\tdef print_usage():\n\t    progname = os.path.basename(sys.argv[0])\n\t    print(\n\t        f\"\"\"\\\n\tusage: {progname} app [-f <fnname>] [-l <extralibs>] [-m <modname>] [-o <appfile>] <appdir>\n\t       {progname} lib [-l <extralibs>] -o <libfile> [<libdir> ...]\n\t       {progname} -h|--help\n\tBuild single file PENVM application or library file.\n\tArguments:\n", "<appdir>            Application directory with same named file containing \"main()\".\n\t<libdir>            Library directory (containing content).\n\t--dry               Dry run with making changes.\n\t-f <fnname>         Function name. Default is \"main\".\n\t-l <extralibs>      Addtitional files/dirs to add to the zip file.\n\t                    Multiple uses supported.\n\t-m <modname>        Module name.\n\t-o <appfile>|<libfile>\n\t                    Destination for single file application or library.\n\t\"\"\",\n", "        end=\"\",\n\t    )\n\tclass ArgOpts:\n\t    pass\n\tdef main():\n\t    try:\n\t        argopts = ArgOpts()\n\t        argopts.appdir = None\n\t        argopts.buildfilename = None\n\t        argopts.buildtype = None\n", "        argopts.dryrun = False\n\t        argopts.extralibs = []\n\t        argopts.fnname = \"main\"\n\t        argopts.libdirs = []\n\t        argopts.modname = None\n\t        args = sys.argv[1:]\n\t        if args:\n\t            arg = args.pop(0)\n\t            if arg in [\"-h\", \"--help\"]:\n\t                print_usage()\n", "                sys.exit(0)\n\t            elif arg in [\"app\", \"lib\"]:\n\t                argopts.buildtype = arg\n\t            else:\n\t                raise Exception()\n\t        else:\n\t            raise Exception(\"bad/missing build type\")\n\t        if argopts.buildtype == \"app\":\n\t            while args:\n\t                arg = args.pop(0)\n", "                if arg == \"--dry\":\n\t                    argopts.dryrun = True\n\t                elif arg == \"-f\" and args:\n\t                    argopts.fnname = args.pop(0)\n\t                elif arg == \"-l\" and args:\n\t                    argopts.extralibs.append(args.pop(0))\n\t                elif arg == \"-m\" and args:\n\t                    argopts.modname = args.pop(0)\n\t                elif arg == \"-o\" and args:\n\t                    argopts.buildfilename = args.pop(0)\n", "                elif not args:\n\t                    argopts.appdir = arg\n\t                else:\n\t                    raise Exception()\n\t            if None in [argopts.appdir]:\n\t                raise Exception()\n\t        elif argopts.buildtype == \"lib\":\n\t            while args:\n\t                arg = args.pop(0)\n\t                if arg == \"--dry\":\n", "                    argopts.dryrun = True\n\t                elif arg == \"-l\" and args:\n\t                    argopts.extralibs.append(args.pop(0))\n\t                elif arg == \"-o\" and args:\n\t                    argopts.buildfilename = args.pop(0)\n\t                else:\n\t                    argopts.libdirs = [arg] + args\n\t                    del args[:]\n\t            if None in [argopts.buildfilename]:\n\t                raise Exception()\n", "    except SystemExit:\n\t        raise\n\t    except Exception as e:\n\t        traceback.print_exc()\n\t        print(\"error: bad/missing argument\", file=sys.stderr)\n\t        sys.exit(1)\n\t    try:\n\t        if argopts.buildtype == \"app\":\n\t            if argopts.buildfilename:\n\t                buildfilename = argopts.buildfilename\n", "            else:\n\t                buildfilename = os.path.basename(argopts.appdir)\n\t                if buildfilename.endswith(\".py\"):\n\t                    buildfilename = buildfilename[:-3]\n\t            argopts.buildfilename = buildfilename\n\t        if argopts.dryrun:\n\t            print(f\"appdir:        {argopts.appdir}\")\n\t            print(f\"buildtype:     {argopts.buildtype}\")\n\t            print(f\"buildfilename: {argopts.buildfilename}\")\n\t            print(f\"extralibs:     {argopts.extralibs}\")\n", "            print(f\"fnname:        {argopts.fnname}\")\n\t            print(f\"libdirs:       {argopts.libdirs}\")\n\t            print(f\"modname:       {argopts.modname}\")\n\t            print(f\"penvmlibdir:   {PENVMLIBDIR}\")\n\t            print(f\"penvmlibfile:  {PENVMLIBFILE}\")\n\t        else:\n\t            if argopts.buildtype == \"app\":\n\t                appname = os.path.basename(buildfilename)\n\t                penvmappzip(\n\t                    appname,\n", "                    argopts.buildfilename,\n\t                    argopts.appdir,\n\t                    argopts.extralibs,\n\t                    argopts.modname or appname,\n\t                    argopts.fnname,\n\t                )\n\t            elif argopts.buildtype == \"lib\":\n\t                penvmlibzip(\n\t                    argopts.buildfilename,\n\t                    argopts.libdirs,\n", "                    argopts.extralibs,\n\t                )\n\t    except Exception as e:\n\t        print(f\"{e}\", file=sys.stderr)\n\t        sys.exit(1)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/ext/penvm/ext/workers/__init__.py", "chunked_list": ["#\n\t# penvm/ext/workers/__init__.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"A Worker is a convenience tool to help parcel out the work to the\n\tnetwork of machines. The steps are:\n\t1. partition the problem space\n", "1. spawn the work to the network\n\t1. collect the results\n\t1. process the results\n\t1. combine (consolidate) the results into one\n\t1. return the final result\n\tWorkers may be tailored to suit specific needs. This is espectially\n\trequired for the paritition and combine steps, where both\n\timplementations cannot be known in advance.\n\t\"\"\"\n\timport io\n", "import logging\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.base import BaseObject\n\tlogger = logging.getLogger(__name__)\n\tclass WorkerException(Exception):\n\t    pass\n\tclass Worker(BaseObject):\n\t    \"\"\"Base, mostly abstract, class.\"\"\"\n\t    def __init__(\n\t        self,\n", "        network: \"Network\",\n\t        nworkers: Union[int, None] = None,\n\t        auto_collect: bool = True,\n\t    ):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            network: Network object.\n\t            nworkers: (Maximum) Number of workers to run with.\n\t            auto_collect: Collect response objects.\"\"\"\n\t        try:\n", "            super().__init__(None, logger)\n\t            tlogger = self.logger.enter()\n\t            self.network = network\n\t            self._nworkers = nworkers\n\t            self.enabled = True\n\t            self.auto_collect = auto_collect\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n", "    def call_one(\n\t        self,\n\t        idx: int,\n\t        session: \"Session\",\n\t        *args: List,\n\t        **kwargs: Dict,\n\t    ):\n\t        \"\"\"Call one.\n\t        Args:\n\t            idx: Call index.\n", "            session: Session for call.\n\t            *args: Positional arguments for call.\n\t            **kwargs: Keyword arguments for call.\n\t        Note:\n\t            Override.\n\t        \"\"\"\n\t        pass\n\t    def clean(\n\t        self,\n\t        sessions: List[\"Session\"],\n", "    ):\n\t        \"\"\"Clean/release all sessions.\n\t        Args:\n\t            sessions: List of sessions to clean.\n\t        Note:\n\t            Do not override.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            for idx, session in enumerate(sessions):\n", "                session.kernel.machine_drop_session()\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def collect(\n\t        self,\n\t        sessions: List[\"Session\"],\n\t    ) -> List[Any]:\n\t        \"\"\"Collect all results.\n", "        Results are collected using\n\t        [Worker.collect_one][penvm.ext.workers.Worker.collect_one].\n\t        Args:\n\t            sessions: List of sessions to collect for.\n\t        Returns:\n\t            Results from calls.\n\t        Note:\n\t            Do not override.\n\t        \"\"\"\n\t        try:\n", "            tlogger = self.logger.enter()\n\t            results = []\n\t            if self.auto_collect:\n\t                for idx, session in enumerate(sessions):\n\t                    results.append(self.collect_one(idx, session))\n\t            return results\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n", "    def collect_one(\n\t        self,\n\t        idx: int,\n\t        session: \"Session\",\n\t    ) -> Any:\n\t        \"\"\"Collect one result.\n\t        Args:\n\t            idx: Collect index.\n\t            session: Session to collect for.\n\t        Returns:\n", "            Collected result.\n\t        Note:\n\t            Override.\n\t        \"\"\"\n\t        pass\n\t    def combine(\n\t        self,\n\t        results: List[Any],\n\t    ) -> Any:\n\t        \"\"\"Combine all results into one and return it.\n", "        Args:\n\t            results: Collected results.\n\t        Returns:\n\t            Combined results.\n\t        Note:\n\t            Override.\n\t        \"\"\"\n\t        pass\n\t    def disable(self):\n\t        \"\"\"Disable worker.\n", "        Will use fallback if available.\n\t        \"\"\"\n\t        self.enabled = False\n\t    def enable(self):\n\t        \"\"\"Enable worker.\n\t        Will not force use of fallback.\n\t        \"\"\"\n\t        self.enabled = True\n\t    @property\n\t    def machines(self) -> List[\"Machine\"]:\n", "        \"\"\"Return the machines available for use, subject to the\n\t        number of workers.\n\t        Returns:\n\t            List of machines available for use.\n\t        \"\"\"\n\t        machines = self.network.get_machines()\n\t        return machines[: self.nworkers]\n\t    @property\n\t    def nworkers(self) -> int:\n\t        \"\"\"Return the number of workers to use.\n", "        Returns:\n\t            Number of workers to use.\n\t        \"\"\"\n\t        if self._nworkers != None:\n\t            return self._nworkers\n\t        else:\n\t            return len(self.network.get_machines())\n\t    def partition(\n\t        self,\n\t        *args: List,\n", "        **kwargs: Dict,\n\t    ):\n\t        \"\"\"Partition problem space. Yield for each.\n\t        Args:\n\t            *args: Positional arguments for call.\n\t            **kwargs: Keyword arguments for call.\n\t        Yields:\n\t            (Tuple[List, Dict]): `args` and `kwargs` unchanged.\n\t        Note:\n\t            Override.\n", "        \"\"\"\n\t        yield (args, kwargs)\n\t    def process(\n\t        self,\n\t        results: List[Any],\n\t    ) -> List[Any]:\n\t        \"\"\"Process and return all results.\n\t        Args:\n\t            results: Collected results.\n\t        Returns:\n", "            Results unchanged.\n\t        Note:\n\t            Override as needed.\n\t        \"\"\"\n\t        return results\n\t    def run(\n\t        self,\n\t        *args: List,\n\t        **kwargs: Dict,\n\t    ) -> Any:\n", "        \"\"\"Run work across network and return result.\n\t        Args:\n\t            *args: Positional arguments.\n\t            **kwargs: Keyword arguments.\n\t        Returns:\n\t            Final result.\n\t        Note:\n\t            Do not override.\n\t        \"\"\"\n\t        # ensure network is set up\n", "        try:\n\t            tlogger = self.logger.enter()\n\t            try:\n\t                self.network.boot()\n\t            except Exception as e:\n\t                raise WorkerException(\"cannot boot network\")\n\t            sessions = self.spawn(*args, **kwargs)\n\t            results = self.collect(sessions)\n\t            results = self.process(results)\n\t            result = self.combine(results)\n", "            self.clean(sessions)\n\t            return result\n\t        except WorkerException as e:\n\t            raise\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def spawn(\n\t        self,\n", "        *args: List,\n\t        **kwargs: Dict,\n\t    ) -> List[\"Session\"]:\n\t        \"\"\"Spawn partitioned work across machines.\n\t        Args:\n\t            *args: Positional arguments.\n\t            **kwargs: Keyword arguments.\n\t        Returns:\n\t            List of sessions used.\n\t        Note:\n", "            Do not override.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            sessions = []\n\t            machines = self.machines\n\t            nmachines = len(machines)\n\t            for idx, part in enumerate(self.partition(*args, **kwargs)):\n\t                _args, _kwargs = part\n\t                _args, _kwargs = self.transform(*_args, **_kwargs)\n", "                machine = machines[idx % nmachines]\n\t                session = machine.get_session()\n\t                sessions.append(session)\n\t                self.call_one(idx, session, *_args, **_kwargs)\n\t            return sessions\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def test(\n", "        self,\n\t        *args: List,\n\t        **kwargs: Dict,\n\t    ):\n\t        \"\"\"Test run.\n\t        No actual calls or processing are made.\n\t        Args:\n\t            *args: Positional arguments.\n\t            **kwargs: Keyword arguments.\n\t        Yields:\n", "            (Tuple[List, Dict]): `args` and `kwargs` after partitioning and transformation.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            # see spawn for calling pattern as below\n\t            for idx, part in enumerate(self.partition(*args, **kwargs)):\n\t                _args, _kwargs = part\n\t                _args, _kwargs = self.transform(*_args, **_kwargs)\n\t                yield (_args, _kwargs)\n\t        except Exception as e:\n", "            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def transform(\n\t        self,\n\t        *args: List,\n\t        **kwargs: Dict,\n\t    ) -> Tuple[List, Dict]:\n\t        \"\"\"Transform args and kwargs after partitioning and prior to\n\t        running.\n", "        Args:\n\t            *args: Positional arguments.\n\t            **kwargs: Keyword arguments.\n\t        Returns:\n\t            `args` and `kwargs` unchanged.\n\t        \"\"\"\n\t        return (args, kwargs)\n\tclass MirrorMixin:\n\t    \"\"\"Mixin to provide mirror support for Worker.\n\t    *All* workers are given the same parameters to use (see\n", "    `partition`).\n\t    \"\"\"\n\t    def combine(\n\t        self,\n\t        results: List[Any],\n\t    ) -> Dict[str, Any]:\n\t        \"\"\"Return dictionary with results given under respective\n\t        machine id keys.\n\t        Args:\n\t            results: Collected results.\n", "        Returns:\n\t            Combined results.\n\t        \"\"\"\n\t        machines = self.machines\n\t        d = {}\n\t        for i, result in enumerate(results):\n\t            d[machines[i].oid] = result\n\t        return d\n\t    def partition(\n\t        self,\n", "        *args: List,\n\t        **kwargs: Dict,\n\t    ):\n\t        \"\"\"Same args and kwargs (untouched) for each.\n\t        Args:\n\t            *args: Positional arguments.\n\t            **kwargs: Keyword arguments.\n\t        Yields:\n\t            (Tuple[List, Dict]): `args` and `kwargs` unchanged.\n\t        \"\"\"\n", "        for idx, machine in enumerate(self.machines):\n\t            yield (args, kwargs)\n\tclass PartitionByFunctionWorker(Worker):\n\t    \"\"\"No partitioning is done, but the `args` is extended with\n\t    `nworkers` and `index`. This is suitable for cases in which the\n\t    receiving function does the partition based on `nworkers` and the\n\t    `index`.\n\t    \"\"\"\n\t    def partition(\n\t        self,\n", "        *args: List,\n\t        **kwargs: Dict,\n\t    ):\n\t        nworkers = self.nworkers if self.nworkers != None else len(self.machines)\n\t        for i in range(nworkers):\n\t            yield (list(args) + [self.nworkers, i], kwargs)\n\tclass InputMixin:\n\t    \"\"\"Mixin to partition the problem space into an input-defined\n\t    number of partitions.\n\t    \"\"\"\n", "    def combine(\n\t        self,\n\t        results: List[Any],\n\t    ) -> Dict[int, Any]:\n\t        \"\"\"Return dictionary with results given under respective\n\t        partition index.\n\t        Args:\n\t            results: Collected results.\n\t        Returns:\n\t            Combined results.\n", "        \"\"\"\n\t        d = {}\n\t        for i, result in enumerate(results):\n\t            d[i] = result\n\t        return d\n\t    def partition(\n\t        self,\n\t        *args: List,\n\t        **kwargs: Dict,\n\t    ) -> Tuple[List, Dict]:\n", "        \"\"\"Partition input stream.\n\t        Keyword Args:\n\t            `_` (dict): Input directives.\n\t            `*` (Any): All others for the call.\n\t        Keyword Args: Keyword Input Directives:\n\t            `fieldsname` (str): Name of fields list referenced with\n\t                `transform`.Defaults to \"f\".\n\t            `file` (file): Input stream.\n\t            `fsep` (str): Field separator. Defaults to whitespace.\n\t            `data` (str|bytes): Input data.\n", "            `rsep` (str): Record separator. Defaults to newline.\n\t            `striprsep` (bool): Strip record separator. Defaults to\n\t                `False`.\n\t            `transform` (str): Python code to transform data fields\n\t                (accessible via list named `fieldsname`). Defaults to\n\t                identity.\n\t        Yields:\n\t            `args` partitioned according to directives.\n\t        \"\"\"\n\t        idirectives = kwargs.get(\"_\", {})\n", "        fieldsname = idirectives.get(\"fieldsname\", \"f\")\n\t        file = idirectives.get(\"file\")\n\t        fsep = idirectives.get(\"fsep\", None)\n\t        data = idirectives.get(\"data\")\n\t        rsep = idirectives.get(\"rsep\", \"\\n\")\n\t        striprsep = idirectives.get(\"striprsep\", False)\n\t        transformstr = idirectives.get(\"transform\", None)\n\t        if transformstr:\n\t            try:\n\t                transformcode = compile(transformstr, filename=\"transform\", mode=\"exec\")\n", "            except Exception as e:\n\t                raise Exception(f\"transform string compilation failed ({e})\")\n\t        else:\n\t            transformcode = None\n\t        # TODO: handle text and bytes lsep and fsep defaults\n\t        if data != None:\n\t            if type(data) == str:\n\t                f = io.StringIO(data)\n\t            else:\n\t                f = io.BytesIO(data)\n", "                if type(rsep) != bytes:\n\t                    rsep = rsep.encode()\n\t        elif file != None:\n\t            f = file\n\t        else:\n\t            raise Exception(\"no input stream/data provided\")\n\t        while True:\n\t            # TODO: update to support non-newline line separator\n\t            rec = f.readline()\n\t            if rec == \"\":\n", "                break\n\t            if striprsep == True:\n\t                rec = rec.rstrip(rsep)\n\t            fields = rec.split(fsep)\n\t            if transformcode:\n\t                import os.path\n\t                exec(transformcode, {fieldsname: fields, \"os\": os})\n\t            _args = [arg.format(*fields) for arg in args]\n\t            yield (_args, {})\n\tclass ExecWorker(Worker):\n", "    \"\"\"Worker to call executable.\"\"\"\n\t    def __init__(\n\t        self,\n\t        cwd: str,\n\t        network: \"Network\",\n\t        nworkers: Union[int, None] = None,\n\t        auto_collect: bool = True,\n\t        text: bool = True,\n\t        env: dict = None,\n\t    ):\n", "        \"\"\"Initialize.\n\t        Args:\n\t            cwd: Working directory to use.\n\t            network: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n\t            nworkers: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n\t            auto_collect: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n\t            text: Work in text mode.\n\t            env: Environment variable settings.\n\t        \"\"\"\n\t        super().__init__(network, nworkers, auto_collect)\n", "        self.cwd = cwd\n\t        self.text = text\n\t        self.env = env\n\t    def call_one(\n\t        self,\n\t        idx: int,\n\t        session: \"Session\",\n\t        *args: List,\n\t        **kwargs: Dict,\n\t    ):\n", "        \"\"\"Call one.\n\t        Args:\n\t            args (str): `[0]`: Command path.\n\t            args (List[Any]): `[1:]`: Command arguments.\n\t        See [Worker.call_one][penvm.ext.workers.Worker.call_one].\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            session.kernel.run_exec(\n\t                args[0],\n", "                args[1:],\n\t                capture_output=True,\n\t                text=self.text,\n\t                cwd=self.cwd,\n\t                env=self.env,\n\t            )\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n", "    def collect_one(\n\t        self,\n\t        idx: int,\n\t        session: \"Session\",\n\t    ) -> Dict:\n\t        \"\"\"Collect one result.\n\t        Extract information from the payload:\n\t        * `status`: Response status.\n\t        * `returncode`: Return code from execution.\n\t        * `stderr`: Stderr output.\n", "        * `stdout`: Stdout output.\n\t        See [Worker.collect_one][penvm.ext.workers.Worker.collect_one].\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            resp = session.get_response()\n\t            payload = resp.payload\n\t            return {\n\t                \"status\": payload.get(\"-status\"),\n\t                \"returncode\": payload.get(\"returncode\"),\n", "                \"stderr\": payload.get(\"stderr\", \"\"),\n\t                \"stdout\": payload.get(\"stdout\", \"\"),\n\t            }\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\tclass OpWorker(Worker):\n\t    \"\"\"Worker to call an op.\n\t    Note:\n", "        `auto_collect` is `False` by default because of the\n\t        nature of operations (many do *not* send responses.)\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        kernelname: str,\n\t        network: \"Network\",\n\t        nworkers: Union[int, None] = None,\n\t        auto_collect: bool = False,\n\t    ):\n", "        \"\"\"Initialize.\n\t        Args:\n\t            kernelname: Name of kernel to use.\n\t            network: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n\t            nworkers: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n\t            auto_collect: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n\t        \"\"\"\n\t        super().__init__(network, nworkers, auto_collect)\n\t        self.kernelname = kernelname\n\t    def call_one(\n", "        self,\n\t        idx: int,\n\t        session: \"Session\",\n\t        *args: List,\n\t        **kwargs: Dict,\n\t    ) -> Any:\n\t        \"\"\"Call one.\n\t        Args:\n\t            args (str): `[0]`: Kernel client op method name.\n\t            args (List[Any]): `[1:]`: Arguments for the method call.\n", "        See [Worker.call_one][penvm.ext.workers.Worker.call_one].\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            opname = args[0]\n\t            fn = getattr(session.kernel, opname)\n\t            fn(*args[1:], **kwargs)\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n", "            tlogger.exit()\n\t    def collect_one(\n\t        self,\n\t        idx: int,\n\t        session: \"Session\",\n\t    ) -> Dict:\n\t        \"\"\"Collect one result.\n\t        See [Worker.collect_one][penvm.ext.workers.Worker.collect_one].\n\t        \"\"\"\n\t        try:\n", "            tlogger = self.logger.enter()\n\t            resp = session.get_response()\n\t            payload = resp.payload\n\t            return payload.dict()\n\t        except Exception as e:\n\t            tlogger.error(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\tclass PythonCodeWorker(Worker):\n\t    \"\"\"Worker to call Python code.\"\"\"\n", "    def __init__(\n\t        self,\n\t        fallback: str,\n\t        code: str,\n\t        network: \"Network\",\n\t        nworkers: Union[int, None] = None,\n\t        auto_collect: bool = True,\n\t    ):\n\t        \"\"\"Initialize.\n\t        Args:\n", "            fallback: Fallback function/method to call.\n\t            code: Python code to run.\n\t            network: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n\t            nworkers: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n\t            auto_collect: See [Worker.__init__][penvm.ext.workers.Worker.__init__].\n\t        \"\"\"\n\t        super().__init__(network, nworkers, auto_collect)\n\t        self.fallback = fallback\n\t        self.code = code\n\t    def call_one(\n", "        self,\n\t        idx: int,\n\t        session: \"Session\",\n\t        *args: List,\n\t        **kwargs: Dict,\n\t    ) -> Any:\n\t        \"\"\"Call one.\n\t        Args:\n\t            args (str): `[0]`: Function name to call in provided code.<br>\n\t            args (List[Any]): `[1:]`: Arguments to call function with.\n", "            kwargs: Keyword arguments to call function with.\n\t        See [Worker.call_one][penvm.ext.workers.Worker.call_one].\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            session.kernel.run_python_function(\n\t                self.code,\n\t                args[0],\n\t                args[1:],\n\t                kwargs,\n", "            )\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def collect_one(\n\t        self,\n\t        idx: int,\n\t        session: \"Session\",\n\t    ) -> Any:\n", "        \"\"\"Collect one result.\n\t        Extract information from the payload:\n\t        * `-status`: Execution status.\n\t        * `return-value`: Function return value.\n\t        See [Worker.collect_one][penvm.ext.workers.Worker.collect_one].\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            resp = session.get_response()\n\t            payload = resp.payload\n", "            if payload.get(\"-status\") == \"error\":\n\t                # TODO: what to do?\n\t                pass\n\t            return payload.get(\"return-value\")\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def run(\n\t        self,\n", "        *args: List,\n\t        **kwargs: Dict,\n\t    ) -> Any:\n\t        \"\"\"Run fallback or worker run.\n\t        See [Worker.run][penvm.ext.workers.Worker.run].\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            if self.use_fallback(*args, **kwargs) or not self.enabled:\n\t                return self.fallback(*args, **kwargs)\n", "            else:\n\t                return super().run(*args, **kwargs)\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def use_fallback(\n\t        self,\n\t        *args: List,\n\t        **kwargs: Dict,\n", "    ):\n\t        \"\"\"Call fallback by default, if available.\"\"\"\n\t        return self.fallback != None\n\t    def wrun(\n\t        self,\n\t        fnname: str,\n\t    ) -> Callable:\n\t        \"\"\"Wrap run call to provide `fnname` with `args` and `kwargs`.\n\t        This allows for the function name to *not* have to be in the\n\t        `args` and better mirror what may have been the original call\n", "        signature.\n\t        Args:\n\t            fnname: Function name to call.\n\t        Returns:\n\t            Wrapped function call.\n\t        \"\"\"\n\t        def _run(*args, **kwargs) -> Any:\n\t            return self.run(fnname, *args, **kwargs)\n\t        return _run\n\tclass InputExecWorker(InputMixin, ExecWorker):\n", "    \"\"\"Combined [penvm.ext.workers.InputMixin][] and\n\t    [penvm.ext.workers.ExecWorker][].\"\"\"\n\t    pass\n\tclass InputPythonCodeWorker(InputMixin, PythonCodeWorker):\n\t    \"\"\"Combined [penvm.ext.workers.InputMixin][] and\n\t    [penvm.ext.workers.PythonCodeWorker][].\"\"\"\n\t    pass\n\tclass MirrorOpWorker(MirrorMixin, OpWorker):\n\t    \"\"\"Combined [penvm.ext.workers.MirrorMixin][] and\n\t    [penvm.ext.workers.OpWorker][].\"\"\"\n", "    pass\n\tclass MirrorExecWorker(MirrorMixin, ExecWorker):\n\t    \"\"\"Combined [penvm.ext.workers.MirrorMixin][] and\n\t    [penvm.ext.workers.ExecWorker][].\"\"\"\n\t    pass\n\tclass MirrorPythonCodeWorker(MirrorMixin, PythonCodeWorker):\n\t    \"\"\"Combined [penvm.ext.workers.MirrorMixin][] and\n\t    [penvm.ext.workers.PythonCodeWorker][].\"\"\"\n\t    pass\n"]}
{"filename": "src/tests/semaphore_test.py", "chunked_list": ["#! /usr/bin/env python3\n\t#\n\t# tests/semaphore_test.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom threading import Thread\n\timport time\n", "from penvm.lib.semaphore import AdjustableSemaphore\n\tdef sem_acquire(sem):\n\t    print(\"sem_acquire ...\")\n\t    sem.acquire()\n\t    print(\"sem_acquired ...\")\n\t    print(f\"{sem.count()=} {sem.max()=}\")\n\tdef sem_2acquire_release_test():\n\t    print(\"sem_2acquire_release_test\")\n\t    sem = AdjustableSemaphore()\n\t    print(f\"{sem.count()=} {sem.max()=}\")\n", "    sem.acquire()\n\t    Thread(target=sem_acquire, args=(sem,)).start()\n\t    time.sleep(1)\n\t    print(f\"{sem.count()=} {sem.max()=}\")\n\t    print(\"releasing ...\")\n\t    sem.release()\n\t    print(f\"{sem.count()=} {sem.max()=}\")\n\t    sem.release()\n\t    print(f\"{sem.count()=} {sem.max()=}\")\n\tdef sem_acquire_release_test():\n", "    print(\"sem_acquire_release_test\")\n\t    sem = AdjustableSemaphore(1)\n\t    print(f\"{sem.count()=} {sem.max()=}\")\n\t    sem.acquire()\n\t    print(f\"{sem.count()=} {sem.max()=}\")\n\t    sem.release()\n\t    print(f\"{sem.count()=} {sem.max()=}\")\n\tdef main():\n\t    sem_acquire_release_test()\n\t    print()\n", "    sem_2acquire_release_test()\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/tests/session_test.py", "chunked_list": ["#! /usr/bin/env python3\n\t#\n\t# tests/session_test.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom threading import Thread\n\timport time\n", "from penvm.client.world import World\n\tdef main():\n\t    w = World(filename=\"world.penvm\")\n\t    print(f\"{w=}\")\n\t    t = w.get_target(\"localhost\")\n\t    print(f\"{t=}\")\n\t    m = t.boot()\n\t    print(f\"{m=}\")\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/tests/queue_test.py", "chunked_list": ["#! /usr/bin/env python3\n\t#\n\t# tests/queue_test.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom threading import Thread\n\timport time\n", "from penvm.lib.mqueue import MessageQueue\n\tdef pop_wait(q):\n\t    print(\"pop_wait ...\")\n\t    print(f\"pop_wait {q.pop()=}\")\n\tdef popwait_put_test():\n\t    print(\"popwait_put_test\")\n\t    q = MessageQueue()\n\t    Thread(target=pop_wait, args=(q,)).start()\n\t    time.sleep(1)\n\t    q.put(1)\n", "def put_pop_test():\n\t    print(\"put_pop_test\")\n\t    q = MessageQueue()\n\t    q.put(1)\n\t    print(f\"{q.pop()=}\")\n\tdef main():\n\t    put_pop_test()\n\t    print()\n\t    popwait_put_test()\n\tif __name__ == \"__main__\":\n", "    main()\n"]}
{"filename": "src/lib/penvm/lib/thread.py", "chunked_list": ["#\n\t# penvm/lib/thread.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Provides modified `Thread` to support thread termination.\n\t\"\"\"\n\timport ctypes\n", "import logging\n\timport threading\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.misc import State\n\tlogger = logging.getLogger(__name__)\n\tclass ThreadInterrupt(Exception):\n\t    \"\"\"Special exception for augmented Thread.\"\"\"\n\t    def __init__(self):\n\t        \"\"\"Initialize.\"\"\"\n", "        super().__init__(\"interrupted thread\")\n\tclass Thread(BaseObject, threading.Thread):\n\t    \"\"\"Thread with specific settings and functionality:\n\t    * Will die on main thread exit.\n\t    * Support for exception to thread.\n\t    * Terminatable.\n\t    See https://code.activestate.com/recipes/496960-thread2-killable-threads/.\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n", "        *args: List,\n\t        **kwargs: Dict,\n\t    ):\n\t        \"\"\"Initialize.\n\t        See [theading.Thread][].\n\t        \"\"\"\n\t        try:\n\t            BaseObject.__init__(self, None, logger)\n\t            threading.Thread.__init__(self, *args, **kwargs)\n\t            self.oid = self.name\n", "            self.daemon = True\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            pass\n\t    def get_id(self) -> int:\n\t        \"\"\"Return thread id.\n\t        Returns:\n\t            Thread id.\n\t        \"\"\"\n", "        if hasattr(self, \"_thread_id\"):\n\t            return self._thread_id\n\t        for id, thread in threading._active.items():\n\t            if thread is self:\n\t                return id\n\t    def raise_exception(self, exc: Exception):\n\t        \"\"\"Raise a specific exception.\n\t        Args:\n\t            exc: Exception to raise.\n\t        \"\"\"\n", "        self.logger.debug(\"raising exception ({exc}) ...\")\n\t        # TODO: should this be repeated until it is effective?\n\t        threadid = self.get_id()\n\t        if threadid != None:\n\t            res = ctypes.pythonapi.PyThreadState_SetAsyncExc(\n\t                ctypes.c_long(threadid),\n\t                ctypes.py_object(exc),\n\t            )\n\t            self.logger.info(\"raise exception result ({res})\")\n\t            if res > 1:\n", "                res2 = ctypes.pythonapi.PyThreadState_SetAsyncExc(\n\t                    ctypes.c_long(threadid),\n\t                    0,\n\t                )\n\t                # exception raise failure\n\t    def state(self) -> \"State\":\n\t        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n\t        \"\"\"\n", "        try:\n\t            return State(\n\t                \"thread\",\n\t                self.oid,\n\t                {\n\t                    \"args\": [str(arg) for arg in self._args],\n\t                    \"kwargs\": [str(arg) for arg in self._kwargs.items()],\n\t                    \"name\": self._name,\n\t                    \"native-id\": self.native_id,\n\t                    \"target\": str(self._target),\n", "                },\n\t            )\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t    def terminate(self):\n\t        \"\"\"Terminate. Raises exception.\"\"\"\n\t        # TODO: will this ultimately work, e.g., even when returning\n\t        # from C code/extension? should it repeat until effective?\n\t        self.logger.debug(\"terminating ...\")\n\t        self.raise_exception(ThreadInterrupt)\n"]}
{"filename": "src/lib/penvm/lib/base.py", "chunked_list": ["#\n\t# penvm/lib/base.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Provide `BaseObject` for all PENVM classes that need its\n\tfunctionality.\"\"\"\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n", "from penvm.lib.misc import LoggerAdapter, get_uuid\n\tclass BaseObject:\n\t    \"\"\"Base object for PENVM classes.\n\t    Provides common support for `oid` (UU object id) and\n\t    object-specific `LoggerAdapter` logger.\"\"\"\n\t    name = \"base\"\n\t    def __init__(self, oid: str, logger: \"Logger\"):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            oid: Universally unique object id.\n", "            logger: Logger to wrap with `LoggerAdapter`.\n\t        \"\"\"\n\t        self.oid = oid or get_uuid()\n\t        self.logger = LoggerAdapter(logger, {\"self\": self, \"id\": self.oid})\n"]}
{"filename": "src/lib/penvm/lib/kvstore.py", "chunked_list": ["#\n\t# penvm/lib/kvstore.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport fnmatch\n\timport logging\n\timport os\n", "import os.path\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tlogger = logging.getLogger(__name__)\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.misc import State\n\tclass KVStore(BaseObject):\n\t    \"\"\"Base key+value store.\"\"\"\n\t    def __init__(self):\n\t        \"\"\"Initialize.\"\"\"\n\t        super().__init__(None, logger)\n", "    def drop(\n\t        self,\n\t        k: Any,\n\t    ):\n\t        \"\"\"Drop value for k.\n\t        Args:\n\t            k: Key.\n\t        \"\"\"\n\t        self.pop(k)\n\t    def exists(\n", "        self,\n\t        k: Any,\n\t    ) -> bool:\n\t        \"\"\"Indicate if key exists or not.\n\t        Args:\n\t            k: Key.\n\t        Returns:\n\t            Status of k in store.\n\t        \"\"\"\n\t        pass\n", "    def get(\n\t        self,\n\t        k: Any,\n\t        default: Any = None,\n\t    ) -> Any:\n\t        \"\"\"Get value for k.\n\t        Args:\n\t            k: Any.\n\t            default: Any.\n\t        Returns:\n", "            Value for k.\n\t        \"\"\"\n\t        pass\n\t    def keys(\n\t        self,\n\t        pattern: Union[str, None] = None,\n\t    ) -> List[Any]:\n\t        \"\"\"List of keys in store.\n\t        Args:\n\t            pattern: Filter for keys to return.\n", "        Returns:\n\t            Keys matching pattern.\n\t        \"\"\"\n\t        return []\n\t    def pop(\n\t        self,\n\t        k: Any,\n\t        default: Any = None,\n\t    ) -> Any:\n\t        \"\"\"Pop value from store for k.\n", "        Args:\n\t            k: Key.\n\t        Returns:\n\t            Value for k or `default` otherwise.\n\t        \"\"\"\n\t        pass\n\t    def put(\n\t        self,\n\t        k: Any,\n\t        v: Any,\n", "    ):\n\t        \"\"\"Put value in store.\n\t        Args:\n\t            k: Key.\n\t            v: Value.\n\t        \"\"\"\n\t        pass\n\t    def state(self) -> \"State\":\n\t        \"\"\"Get object state.\n\t        Returns:\n", "            `State` of store.\n\t        \"\"\"\n\t        try:\n\t            return State(\n\t                \"kvstore\",\n\t                self.oid,\n\t                {\n\t                    \"names\": list(self.keys()),\n\t                },\n\t            )\n", "        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\tclass MemoryKVStore(KVStore):\n\t    \"\"\"Memory based [penvm.lib.kvstore.KVStore][].\"\"\"\n\t    def __init__(self):\n\t        \"\"\"Initialize.\"\"\"\n\t        super().__init__()\n\t        self.oid = \"memory\"\n\t        self.d = {}\n\t    def exists(self, k: str) -> bool:\n", "        \"\"\"See [penvm.lib.kvstore.KVStore.exists][].\"\"\"\n\t        return k in self.d\n\t    def get(\n\t        self,\n\t        k: str,\n\t        default: Any = None,\n\t    ) -> Any:\n\t        \"\"\"See [penvm.lib.kvstore.KVStore.get][].\"\"\"\n\t        return self.d.get(k, default)\n\t    def keys(\n", "        self,\n\t        pattern: Union[str, None] = None,\n\t    ) -> List[str]:\n\t        \"\"\"See See [penvm.lib.kvstore.KVStore.keys][].\"\"\"\n\t        return fnmatch.filter(self.d.keys(), pattern)\n\t    def pop(self, k: str) -> Any:\n\t        \"\"\"See [penvm.lib.kvstore.KVStore.pop][].\"\"\"\n\t        self.d.pop(k)\n\t    def put(self, k: str, v: Any):\n\t        \"\"\"See [penvm.lib.kvstore.KVStore.put][].\"\"\"\n", "        self.d[k] = v\n\tclass FInfo:\n\t    \"\"\"File info for [penvm.lib.kvstore.FileKVStore][].\n\t    Tracks value type (text, bytes).\n\t    \"\"\"\n\t    def __init__(self):\n\t        \"\"\"Initialize.\"\"\"\n\t        self.type = None\n\tclass FileKVStore(KVStore):\n\t    \"\"\"File based [penvm.lib.kvstore.KVStore][].\"\"\"\n", "    def __init__(\n\t        self,\n\t        dirpath: str,\n\t    ):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            dirpath: Directory path to store files.\n\t        See See [penvm.lib.kvstore.KVStore.__init__][].\n\t        \"\"\"\n\t        try:\n", "            super().__init__()\n\t            self.oid = \"file\"\n\t            self.dirpath = dirpath\n\t            if not self.dirpath.startswith(\"/tmp/\"):\n\t                raise Exception(\"FileKVStore must be under allowed directory\")\n\t            self.d = {}\n\t            os.mkdir(self.dirpath, 0o700)\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n", "            pass\n\t    def __del__(self):\n\t        if not self.dirpath.startswith(\"/tmp/\"):\n\t            return\n\t        for name in self.d.keys():\n\t            self.drop(name)\n\t        try:\n\t            os.rmdir(self.dirpath)\n\t        except Exception as e:\n\t            pass\n", "    def get(\n\t        self,\n\t        k: str,\n\t        default: Union[str, bytes, None] = None,\n\t    ) -> Union[str, bytes, None]:\n\t        \"\"\"See [penvm.lib.kvstore.KVStore.get][].\"\"\"\n\t        try:\n\t            k = k.replace(\"/\", \"__\")\n\t            finfo = self.d.get(k)\n\t            if not finfo:\n", "                return None\n\t            if finfo.type == \"text\":\n\t                mode = \"r+t\"\n\t            elif finfo.type == \"binary\":\n\t                mode = \"r+b\"\n\t            path = f\"{self.dirpath}/{k}\"\n\t            if os.path.exists(path):\n\t                v = open(path, mode).read()\n\t        except Exception as e:\n\t            self.logger.warning(f\"put EXCEPTION ({e})\")\n", "        return v\n\t    def get_path(\n\t        self,\n\t        k: str,\n\t        default: Union[str, None] = None,\n\t    ) -> str:\n\t        \"\"\"Return the path associated with the key.\n\t        Args:\n\t            k: Key.\n\t            default: Default value.\n", "        Returns:\n\t            File path holding value.\n\t        \"\"\"\n\t        try:\n\t            path = f\"{self.dirpath}/{k}\"\n\t            if not os.path.exists(path):\n\t                return None\n\t            return path\n\t        except Exception as e:\n\t            pass\n", "    def keys(\n\t        self,\n\t        pattern=None,\n\t    ) -> List[str]:\n\t        \"\"\"See [penvm.lib.kvstore.KVStore.keys][].\"\"\"\n\t        try:\n\t            names = list(self.d.keys())\n\t            # names = os.listdir(f\"{self.dirpath}\")\n\t        except Exception as e:\n\t            names = []\n", "        if pattern:\n\t            names = fnmatch.filter(names, pattern)\n\t        return names\n\t    def pop(\n\t        self,\n\t        k: str,\n\t    ) -> Union[str, bytes, None]:\n\t        \"\"\"See [penvm.lib.kvstore.KVStore.pop][].\"\"\"\n\t        try:\n\t            v = self.get(k)\n", "            k = k.replace(\"/\", \"__\")\n\t            path = f\"{self.dirpath}/{k}\"\n\t            os.remove(path)\n\t            self.d.pop(k)\n\t            return v\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t    def put(\n\t        self,\n\t        k: str,\n", "        v: Union[str, bytes],\n\t    ):\n\t        \"\"\"See [penvm.lib.kvstore.KVStore.put][].\"\"\"\n\t        try:\n\t            k = k.replace(\"/\", \"__\")\n\t            path = f\"{self.dirpath}/{k}\"\n\t            self.logger.debug(f\"put {k=} {path=}\")\n\t            finfo = FInfo()\n\t            if type(v) == str:\n\t                finfo.type = \"text\"\n", "                mode = \"w+t\"\n\t            else:\n\t                finfo.type = \"binary\"\n\t                mode = \"w+b\"\n\t            open(path, mode).write(v)\n\t            self.d[k] = finfo\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n"]}
{"filename": "src/lib/penvm/lib/message.py", "chunked_list": ["#\n\t# penvm/lib/message.py\n\t#\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport base64\n\tfrom collections.abc import MutableMapping\n", "import copy\n\timport io\n\timport json\n\timport logging\n\timport time\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\timport yaml\n\tfrom penvm.lib.misc import State, get_uuid\n\tlogger = logging.getLogger(__name__)\n\tHEADER_SZ_LEN = 5\n", "HEADER_SZ_FMT = b\"%%0.%dd\" % HEADER_SZ_LEN\n\tHEADER_SZ_MAX = 100_000 - 1\n\tPAYLOAD_SZ_LEN = 8\n\tPAYLOAD_SZ_FMT = b\"%%0.%dd\" % PAYLOAD_SZ_LEN\n\tPAYLOAD_SZ_MAX = 100_000_000 - 1 - HEADER_SZ_MAX - 40\n\tNON_CONFORMING = \"__non-conforming__\"\n\tclass JSONEncoder(json.JSONEncoder):\n\t    \"\"\"Enhanced JSONEncoder with support for non-conforming types:\n\t    * `bytes` - Bytes.\n\t    * `complex` - Complex.\n", "    * `numpy.*` - Python-only.\n\t    \"\"\"\n\t    def default(self, o):\n\t        # TODO: optimize/clean up\n\t        otype = type(o)\n\t        if otype == bytes:\n\t            o = {\n\t                NON_CONFORMING: {\n\t                    \"type\": \"bytes\",\n\t                    \"value\": base64.b64encode(o).decode(\"utf-8\"),\n", "                }\n\t            }\n\t            return o\n\t        elif otype == complex:\n\t            o = {\n\t                NON_CONFORMING: {\n\t                    \"type\": \"complex\",\n\t                    \"value\": [o.real, o.imag],\n\t                }\n\t            }\n", "            return o\n\t        elif otype.__module__ == \"numpy\":\n\t            try:\n\t                import numpy\n\t            except:\n\t                numpy = None\n\t            f = io.BytesIO()\n\t            numpy.save(f, o)\n\t            o = {\n\t                NON_CONFORMING: {\n", "                    \"type\": \"numpy\",\n\t                    \"class\": o.__class__.__name__,\n\t                    \"value\": base64.b64encode(f.getvalue()).decode(\"utf-8\"),\n\t                }\n\t            }\n\t            return o\n\t        return json.JSONEncoder.default(self, o)\n\tdef json_decoder_object_hook(o):\n\t    \"\"\"Support for decoding of non-conforming types:\n\t    * `bytes` - Bytes.\n", "    * `complex` - Complex.\n\t    * `numpy.*` - Numpy serialized objects (Python-only).\n\t    The encoding is an object as:\n\t    ```\n\t    NON_CONFORMING: {\n\t        \"type\": <str>,\n\t        \"value\": <base64encoding>,\n\t    }\n\t    ```\n\t    Note: Object keys cannot be bytes.\n", "    \"\"\"\n\t    if NON_CONFORMING in o:\n\t        nctype = o.get(NON_CONFORMING).get(\"type\")\n\t        ncvalue = o.get(NON_CONFORMING).get(\"value\")\n\t        if nctype:\n\t            if nctype == \"bytes\":\n\t                return base64.b64decode(ncvalue.encode(\"utf-8\"))\n\t            elif nctype == \"complex\":\n\t                return complex(ncvalue[0], ncvalue[1])\n\t            elif nctype == \"numpy\":\n", "                try:\n\t                    import numpy\n\t                except:\n\t                    numpy = None\n\t                f = io.BytesIO(base64.b64decode(ncvalue.encode(\"utf-8\")))\n\t                return numpy.load(f, allow_pickle=False)\n\t    return o\n\tclass MessagePart(MutableMapping):\n\t    \"\"\"Dict-type object with enhanced json codec support for bytes.\"\"\"\n\t    def __init__(\n", "        self,\n\t        d: dict = None,\n\t    ):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            d: Initial configuration.\n\t        \"\"\"\n\t        self.d = {}\n\t        if d != None:\n\t            self.d.update(d)\n", "    def __delitem__(\n\t        self,\n\t        k: Any,\n\t    ):\n\t        del self.d[k]\n\t    def __getitem__(self, k):\n\t        return self.d[k]\n\t    def __iter__(self):\n\t        return iter(self.d.keys())\n\t    def __len__(self):\n", "        return len(self.d)\n\t    def __repr__(self):\n\t        # this can be expensive for big payloads\n\t        s = str(self.d)\n\t        if len(s) > 256:\n\t            s = s[:253] + \"...\"\n\t        return f\"<{self.__class__.__name__} ({s})>\"\n\t    def __setitem__(self, k, v):\n\t        self.d[k] = v\n\t    @staticmethod\n", "    def decode(b: bytes) -> str:\n\t        \"\"\"Decode bytes with support for local decodings.\n\t        Args:\n\t            b: Bytes to decode.\n\t        Returns:\n\t            JSON string.\n\t        \"\"\"\n\t        return json.loads(b.decode(\"utf-8\"), object_hook=json_decoder_object_hook)\n\t    def dict(\n\t        self,\n", "        clean: bool = False,\n\t    ) -> Dict:\n\t        \"\"\"Return a copy as a dict. Optionally clean of \"private\"\n\t        top-level items (keys start with \"-\").\n\t        Args:\n\t            clean: Remove keys starting with \"-\".\n\t        Returns:\n\t            Dictionary.\n\t        \"\"\"\n\t        d = copy.deepcopy(self.d)\n", "        if clean:\n\t            for k in list(d.keys()):\n\t                if k.startswith(\"-\"):\n\t                    del d[k]\n\t        return d\n\t    def dumps(\n\t        self,\n\t        indent: Union[int, None] = None,\n\t        sort_keys: Union[bool, None] = None,\n\t    ) -> str:\n", "        \"\"\"Dump contents as a stringified dict.\n\t        Args:\n\t            indent: Indent size.\n\t            sort_keys: Sort keys.\n\t        Returns:\n\t            Stringified dictionary.\n\t        \"\"\"\n\t        # TODO: not reall a stringified dict. drop in favor of json()?\n\t        kwargs = {}\n\t        if indent != None:\n", "            kwargs[\"indent\"] = indent\n\t        if sort_keys != None:\n\t            kwargs[\"sort_keys\"] = sort_keys\n\t        return json.dumps(self.d, **kwargs)\n\t    def encode(self) -> str:\n\t        \"\"\"Encode items and return JSON string.\n\t        Returns:\n\t            JSON string.\n\t        \"\"\"\n\t        return json.dumps(self.d, cls=JSONEncoder).encode(\"utf-8\")\n", "    def json(\n\t        self,\n\t        indent: Union[int, None] = 2,\n\t        clean: bool = False,\n\t    ) -> str:\n\t        \"\"\"Return JSON string.\n\t        Args:\n\t            indent: Indent size.\n\t            clean: Remove for keys starting with \"-\".\n\t        Returns:\n", "            JSON string.\n\t        \"\"\"\n\t        d = self.dict(clean)\n\t        return json.dumps(d, indent=indent)\n\t    def yaml(\n\t        self,\n\t        clean: bool = False,\n\t    ) -> str:\n\t        \"\"\"Return YAML.\n\t        Args:\n", "            clean: Remove for keys starting with \"-\".\n\t        Returns:\n\t            YAML.\n\t        \"\"\"\n\t        d = self.dict(clean)\n\t        return yaml.dump(d)\n\tclass Header(MessagePart):\n\t    \"\"\"Header.\"\"\"\n\t    def __init__(self, d=None):\n\t        \"\"\"Initialize.\n", "        See [penvm.lib.message.MessagePart][].\n\t        \"\"\"\n\t        super().__init__(d)\n\t        # for new only\n\t        if \"id\" not in self:\n\t            self[\"id\"] = get_uuid()\n\tclass Payload(MessagePart):\n\t    \"\"\"Payload.\"\"\"\n\t    def __init__(self, d=None):\n\t        \"\"\"Initialize.\n", "        See [penvm.lib.message.MessagePart][].\n\t        \"\"\"\n\t        super().__init__(d)\n\t        # for new only\n\t        if \"-id\" not in self:\n\t            self[\"-id\"] = get_uuid()\n\tclass Message:\n\t    \"\"\"Object consisting of header and payload objects.\n\t    The header and payload objects are `MessagePart` objects.\n\t    All parts have a `-id` setting unique to the object.\n", "    Message payloads take special fields with `-` prefix:\n\t    * `-type` - Message type (e.g., request, response)\n\t    * `-status` - Status (e.g., ok, error)\n\t    * `-message` - Status message, usually for \"error\" status.\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        header: Union[Header, None] = None,\n\t        payload: Union[Payload, None] = None,\n\t    ):\n", "        \"\"\"Initialize.\n\t        Args:\n\t            header: Header object.\n\t            payload: Payload object.\n\t        \"\"\"\n\t        self.header = header or Header()\n\t        self.payload = payload or Payload()\n\t    def __repr__(self):\n\t        return f\"<{self.__class__.__name__} header ({self.header}) payload ({self.payload})>\"\n\t    @staticmethod\n", "    def decode(b):\n\t        \"\"\"Decode bytes according to Message format.\n\t        Bytes as:\n\t        * header[HEADER_SZ_LEN] -> sz (encoded as plain text number)\n\t        * header[HEADER_SZ_LEN:HEADER_SZ_LEN+sz] -> bytes\n\t        * payload[PAYLOAD_SZ_LEN] -> sz (encoded as plain text number)\n\t        * payload[PAYLOAD_SZ_LEN:PAYLOAD_SZ_LEN+sz] -> bytes\n\t        See [penvm.lib.message.MessagePart][].\n\t        \"\"\"\n\t        hsz = int(b[:HEADER_SZ_LEN])\n", "        t0 = time.time()\n\t        h = Header(Header.decode(b[HEADER_SZ_LEN : HEADER_SZ_LEN + hsz]))\n\t        t1 = time.time()\n\t        h[\"-decode-elapsed\"] = t1 - t0\n\t        t0 = time.time()\n\t        pb = b[HEADER_SZ_LEN + hsz :]\n\t        psz = int(pb[:PAYLOAD_SZ_LEN])\n\t        p = Payload(Payload.decode(pb[PAYLOAD_SZ_LEN : PAYLOAD_SZ_LEN + psz]))\n\t        t1 = time.time()\n\t        p[\"-decode-elapsed\"] = t1 - t0\n", "        return h, p\n\t    def encode(self):\n\t        \"\"\"Encode.\"\"\"\n\t        h = self.header.encode()\n\t        p = self.payload.encode()\n\t        return (HEADER_SZ_FMT % len(h)) + h + (PAYLOAD_SZ_FMT % len(p)) + p\n\t    def state(self) -> \"State\":\n\t        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n", "        \"\"\"\n\t        try:\n\t            return State(\n\t                \"message\",\n\t                self.header.get(\"id\"),\n\t                {\n\t                    \"header\": self.header.dict(),\n\t                    \"payload\": self.payload.dict(),\n\t                },\n\t            )\n", "        except Exception as e:\n\t            logger.warning(f\"EXCEPTION ({e})\")\n\t#\n\t# conveniences\n\t#\n\tdef Request(*args, **kwargs):\n\t    \"\"\"Return a request message.\n\t    See [penvm.lib.message.Message][].\n\t    \"\"\"\n\t    msg = Message(*args, **kwargs)\n", "    msg.payload[\"-type\"] = \"request\"\n\t    return msg\n\tdef Response(*args, **kwargs):\n\t    \"\"\"Return a response message.\n\t    See [penvm.lib.message.Message][].\n\t    \"\"\"\n\t    refmsg = kwargs.pop(\"refmsg\", None)\n\t    msg = Message(*args, **kwargs)\n\t    if refmsg:\n\t        msg.header[\"ref-id\"] = refmsg.header.get(\"id\")\n", "    msg.payload[\"-type\"] = \"response\"\n\t    return msg\n\tdef ErrorResponse(message, *args, **kwargs):\n\t    \"\"\"Return an error response message.\n\t    See [penvm.lib.message.Message][].\n\t    \"\"\"\n\t    msg = Response(*args, **kwargs)\n\t    msg.payload.update(\n\t        {\n\t            \"-status\": \"error\",\n", "            \"-message\": message,\n\t        }\n\t    )\n\t    return msg\n\tdef OkResponse(*args, **kwargs):\n\t    \"\"\"Return an ok response message.\n\t    See [penvm.lib.message.Message][].\n\t    \"\"\"\n\t    msg = Response(*args, **kwargs)\n\t    msg.payload[\"-status\"] = \"ok\"\n", "    return msg\n"]}
{"filename": "src/lib/penvm/lib/queue.py", "chunked_list": ["#\n\t# penvm/lib/queue.py\n\t#\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport queue\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n", "class QueueEmpty:\n\t    pass\n\tclass Queue:\n\t    \"\"\"Implementation allowing for inspection and peeking.\n\t    Built on top of [queue.Queue][].\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        qsize: int = 0,\n\t    ):\n", "        \"\"\"Initialize.\n\t        Args:\n\t            qsize: Maximum queue size. 0 for unlimited.\n\t        \"\"\"\n\t        self.frozen = False\n\t        # TODO: support sizing of queue\n\t        self.qsize = qsize = 10\n\t        self._queue = queue.Queue(qsize)\n\t        self._tmp = QueueEmpty\n\t        self.npop = 0\n", "        self.nput = 0\n\t    def clear(self):\n\t        \"\"\"Clear all queued objects.\"\"\"\n\t        try:\n\t            while True:\n\t                self._queue.get(block=False)\n\t        except queue.Empty as e:\n\t            pass\n\t        except Exception:\n\t            pass\n", "    def freeze(\n\t        self,\n\t        state: bool,\n\t    ):\n\t        \"\"\"Allow/disallow additions.\n\t        Args:\n\t            state: New state of queue.\n\t        \"\"\"\n\t        self.frozen = state\n\t    def get(self) -> Any:\n", "        \"\"\"Get copy of object from queue.\n\t        Returns:\n\t            Item.\n\t        \"\"\"\n\t        # TODO: needs some work?\n\t        if self._queue.qsize():\n\t            return self._queue.queue[0].copy()\n\t        return QueueEmpty\n\t    def pop(\n\t        self,\n", "        block: bool = True,\n\t    ) -> Any:\n\t        \"\"\"Pop object from queue.\n\t        Args:\n\t            block: Wait for object.\n\t        Returns:\n\t            Item.\n\t        \"\"\"\n\t        try:\n\t            v = self._queue.get(block=block)\n", "            self.npop += 1\n\t            # TODO: what to return if not blocking and no value? None!\n\t        except queue.Empty as e:\n\t            v = None\n\t        return v\n\t    def put(self, o: Any):\n\t        \"\"\"Put object on queue.\n\t        Args:\n\t            o: Object.\n\t        \"\"\"\n", "        if not self.frozen:\n\t            self.nput += 1\n\t            self._queue.put(o)\n\t        # TODO: raise exception if frozen\n\t    def size(self) -> int:\n\t        \"\"\"Return queue size.\n\t        Returns:\n\t            Queue size.\n\t        \"\"\"\n\t        return self._queue.qsize()\n", "    def values(self) -> List[Any]:\n\t        \"\"\"Return (actual) queued values.\n\t        Returns:\n\t            Queue values.\n\t        \"\"\"\n\t        return [v for v in self._queue.queue]\n\tclass RoutingQueue(Queue):\n\t    \"\"\"Route queue operations elsewhere.\n\t    Three functions are registered to handle the different kinds of\n\t    queueing (and this routing) operations.\n", "    \"\"\"\n\t    def __init__(\n\t        self,\n\t        get: Union[Callable, None] = None,\n\t        pop: Union[Callable, None] = None,\n\t        put: Union[Callable, None] = None,\n\t    ):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            get: Function to call for `get`.\n", "            pop: Function to call for `pop`.\n\t            put: Function to call for `put`.\n\t        \"\"\"\n\t        super().__init__()\n\t        self._get = get\n\t        self._pop = pop\n\t        self._put = put\n\t    def get(self) -> Union[Any, None]:\n\t        \"\"\"Get a copy of an object.\n\t        Returns:\n", "            Copy of an object.\n\t        \"\"\"\n\t        return None if self._get == None else self._get()\n\t    def pop(\n\t        self,\n\t        block: bool = True,\n\t    ) -> Union[Any, None]:\n\t        \"\"\"Pop an object.\n\t        Returns:\n\t            An object.\n", "        \"\"\"\n\t        return None if self._pop == None else self._pop(block)\n\t    def put(\n\t        self,\n\t        o: Any,\n\t    ):\n\t        \"\"\"Put an object.\n\t        Args:\n\t            o: Object to queue/route.\n\t        \"\"\"\n", "        self._put(o)\n\t    def size(self) -> int:\n\t        \"\"\"Queue size is always 0.\n\t        Returns:\n\t            0\n\t        \"\"\"\n\t        return 0\n\t    def values(self) -> List:\n\t        \"\"\"Never any values on queue.\n\t        Returns:\n", "            Empty list.\"\"\"\n\t        return []\n"]}
{"filename": "src/lib/penvm/lib/misc.py", "chunked_list": ["#\n\t# penvm/lib/misc.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Collection of miscellaneous code.\n\t\"\"\"\n\t# import secrets\n", "import logging\n\tfrom logging import LoggerAdapter as _LoggerAdapter\n\tfrom threading import Lock\n\timport time\n\timport traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom uuid import uuid1\n\tlogger = logging.getLogger(__name__)\n\tVERSION = (0, 1, 0)\n\tclass LogMark:\n", "    \"\"\"Provides unique id and time information: t0 (start time) and\n\t    tlast (lap time).\"\"\"\n\t    def __init__(self):\n\t        \"\"\"Initialize.\"\"\"\n\t        self.t0 = time.time()\n\t        self.tlast = self.t0\n\t        self.uuid = get_log_uuid()\n\t    def elapsed(self) -> float:\n\t        \"\"\"Return elapsed time since object initialize.\n\t        Returns:\n", "            Elapsed time in seconds.\n\t        \"\"\"\n\t        t1 = time.time()\n\t        return t1, t1 - self.t0\n\t    def lap(self) -> Tuple[float, float, float]:\n\t        \"\"\"Return triple (now, elasped since init, elapsed since last lap).\n\t        Returns:\n\t            Tuple of (not, elapsed since init, elapsed since lap) in\n\t            seconds.\n\t        \"\"\"\n", "        tnow = time.time()\n\t        tlast = self.tlast\n\t        self.tlast = tnow\n\t        return tnow, tnow - self.t0, tnow - tlast\n\t    def reset(self):\n\t        \"\"\"Reset the \"init\" time.\"\"\"\n\t        self.t0 = time.time()\n\tclass LoggerAdapter(_LoggerAdapter):\n\t    \"\"\"Log adapter which provides \"owner\" information as a prefix in\n\t    the log entry.\n", "    \"\"\"\n\t    def __init__(\n\t        self,\n\t        *args,\n\t        **kwargs,\n\t    ):\n\t        \"\"\"Initialize.\"\"\"\n\t        super().__init__(*args, **kwargs)\n\t        o = self.extra.get(\"self\")\n\t        if o != None:\n", "            classname = o.__class__.__name__\n\t            idval = self.extra.get(\"id\", \"-\")\n\t            self.extra[\"prefix\"] = f\"\"\"{classname}[{idval}]\"\"\"\n\t        else:\n\t            self.extra[\"prefix\"] = self.extra.get(\"prefix\", \"\")\n\t    def process(\n\t        self,\n\t        msg: str,\n\t        kwargs: dict,\n\t    ) -> str:\n", "        \"\"\"Return processed log message.\n\t        Args:\n\t            msg: Message format string.\n\t            kwargs: Dictionary containers items for populating `msg.\n\t        Return:\n\t            Processed message format string.\n\t        \"\"\"\n\t        return \"%s: %s\" % (self.extra.get(\"prefix\"), msg), kwargs\n\t    def enter(\n\t        self,\n", "        *args: List,\n\t        **kwargs: Dict,\n\t    ) -> \"TaggedLoggerAdapter\":\n\t        \"\"\"Set up a TaggedLoggerAdapter, call enter(), return new\n\t        adapter.\n\t        Args:\n\t            args: Log message args.\n\t            kwargs: Log message kwargs.\n\t        Returns:\n\t            TaggedLoggerAdapter.\n", "        \"\"\"\n\t        tlogger = TaggedLoggerAdapter(self, stacklevel=4)\n\t        tlogger.enter(*args, stacklevel=5, **kwargs)\n\t        return tlogger\n\tclass MachineConnectionSpec:\n\t    \"\"\"Machine connection spec.\n\t    Information required to establish a connection to a machine.\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n", "        machconnstr: Union[str, None] = None,\n\t        config: Union[dict, None] = None,\n\t        machine: Union[\"Machine\", None] = None,\n\t    ):\n\t        \"\"\"\n\t        Initialize.\n\t        One of the arguments is used to configure.\n\t        Args:\n\t            machconnstr: Machine connection string: colon-separated\n\t                string consisting of machine id, ssl profile, host,\n", "                port.\n\t            config: Dictionary of machine configuration settings.\n\t            machine: Machine object.\n\t        \"\"\"\n\t        if machconnstr != None:\n\t            self.machid, self.sslprofile, self.host, self.port = machconnstr.split(\":\", 3)\n\t            if self.sslprofile == \"\":\n\t                self.sslprofile = None\n\t            self.port = int(self.port)\n\t        elif config != None:\n", "            self.machid = config.get(\"machine-id\")\n\t            self.sslprofile = config.get(\"ssl-profile\")\n\t            self.host = config.get(\"host\")\n\t            self.port = config.get(\"port\")\n\t        elif machine != None:\n\t            self.machid = machine.oid\n\t            self.sslprofile = machine.sslprofile\n\t            self.host = machine.conn.host\n\t            self.port = machine.conn.port\n\t        else:\n", "            raise Exception(\"cannot set up MachineConnectionSpec\")\n\t    def __str__(self):\n\t        return f\"{self.machid}:{self.sslprofile or ''}:{self.host}:{self.port}\"\n\tclass State(dict):\n\t    \"\"\"Object state.\n\t    Holds object identifying information and a dictionary containing\n\t    relevant object state.\n\t    \"\"\"\n\t    def __init__(self, otype: str, oid: str, state: dict):\n\t        \"\"\"Initialize.\n", "        Args:\n\t            otype: Object type string.\n\t            oid: Object id string.\n\t            state: State information.\n\t        \"\"\"\n\t        super().__init__()\n\t        self.update(\n\t            {\n\t                \"timestamp\": get_timestamp(),\n\t                \"object\": {\n", "                    \"type\": otype,\n\t                    \"id\": oid,\n\t                },\n\t                \"state\": state,\n\t            }\n\t        )\n\tclass TaggedLoggerAdapter(_LoggerAdapter):\n\t    \"\"\"Logger adapter which tags each log entry with a unique id to\n\t    allow for tracking. Also provides a means to track timing\n\t    performance.\n", "    Also provides special methods for local (e.g., function/method)\n\t    logger: enter, exit, elapsed, lap.\n\t    \"\"\"\n\t    def __init__(self, *args, **kwargs):\n\t        \"\"\"Initialize.\"\"\"\n\t        self.stacklevel = kwargs.pop(\"stacklevel\", 4)\n\t        super().__init__(*args, **kwargs)\n\t        self.default_level = logging.DEBUG\n\t        self.mark = LogMark()\n\t    def critical(self, msg, *args, **kwargs):\n", "        \"\"\"Make a \"critical\" log entry.\"\"\"\n\t        _msg = f\"[{self.mark.uuid}] {msg}\"\n\t        self.log(logging.CRITICAL, _msg, *args, stacklevel=self.stacklevel, **kwargs)\n\t    def debug(self, msg, *args, **kwargs):\n\t        \"\"\"Make a \"debug\" log entry.\"\"\"\n\t        _msg = f\"[{self.mark.uuid}] {msg}\"\n\t        self.log(logging.DEBUG, _msg, *args, stacklevel=self.stacklevel, **kwargs)\n\t    def elapsed(\n\t        self,\n\t        msg: Union[str, None] = None,\n", "    ):\n\t        \"\"\"Make a log entry with special format string containing:\n\t        \"ELAPSED\", a tag, time, and elapsed time (from start).\n\t        Args:\n\t            msg: Additional message to log.\n\t        \"\"\"\n\t        t1, elapsed = self.mark.elapsed()\n\t        _msg = f\"ELAPSED [{self.mark.uuid}, {t1:.5f}, {elapsed:.5f}]\"\n\t        if msg:\n\t            _msg = f\"{_msg} {msg}\"\n", "        self.log(self.default_level, _msg, stacklevel=self.stacklevel)\n\t    def enter(\n\t        self,\n\t        msg: Union[str, None] = None,\n\t        stacklevel: Union[int, None] = None,\n\t    ):\n\t        \"\"\"Make a log entry with special format string containing:\n\t        \"ENTER\", tag, and time.\n\t        Args:\n\t            msg: Additional message to log.\n", "            stacklevel: Stack level to extract information from.\n\t        \"\"\"\n\t        _msg = f\"ENTER [{self.mark.uuid}, {self.mark.t0:.5f}]\"\n\t        if msg:\n\t            _msg = f\"{_msg} {msg}\"\n\t        stacklevel = stacklevel if stacklevel != None else self.stacklevel\n\t        self.log(self.default_level, _msg, stacklevel=stacklevel)\n\t        return self\n\t    def error(self, msg, *args, **kwargs):\n\t        \"\"\"Mark an \"error\" log entry.\"\"\"\n", "        _msg = f\"[{self.mark.uuid}] {msg}\"\n\t        self.log(logging.ERROR, _msg, *args, stacklevel=self.stacklevel, **kwargs)\n\t    def exit(\n\t        self,\n\t        msg: Union[str, None] = None,\n\t    ):\n\t        \"\"\"Make a log entry with special format string containing:\n\t        \"EXIT\", tag, time, and elapsed (from start).\n\t        Args:\n\t            msg: Additional message to log.\n", "        \"\"\"\n\t        t1, elapsed = self.mark.elapsed()\n\t        _msg = f\"EXIT [{self.mark.uuid}, {t1:.5f}, {elapsed:.5f}]\"\n\t        if msg:\n\t            _msg = f\"{_msg} {msg}\"\n\t        self.log(self.default_level, _msg, stacklevel=self.stacklevel)\n\t    def state(\n\t        self,\n\t        msg,\n\t        *args: List,\n", "        **kwargs: Dict,\n\t    ):\n\t        _msg = f\"[{self.mark.uuid}] {msg}\"\n\t        self.log(logging.INFO, _msg, *args, stacklevel=self.stacklevel, **kwargs)\n\t    def lap(\n\t        self,\n\t        msg: Union[str, None] = None,\n\t    ):\n\t        \"\"\"Make a log entry with special format string containing:\n\t        \"LAP\", tag, time, and elapsed from split, and from lap split.\n", "        Args:\n\t            msg: Additional message to log.\n\t        \"\"\"\n\t        t1, elapsed, lap = self.mark.lap()\n\t        _msg = f\"LAP [{self.mark.uuid}, {t1:.5f}, {elapsed:.5f}, {lap:.5f}]\"\n\t        if msg:\n\t            _msg = f\"{_msg} {msg}\"\n\t        self.log(self.default_level, _msg, stacklevel=self.stacklevel)\n\t    def warning(self, msg, *args, **kwargs):\n\t        \"\"\"Make a \"warning\" log entry.\"\"\"\n", "        _msg = f\"[{self.mark.uuid}] {msg}\"\n\t        self.log(logging.WARNING, _msg, *args, stacklevel=self.stacklevel, **kwargs)\n\t# variables for logging\n\t_log_counter = int(time.time() * 100)\n\t_log_counter_lock = Lock()\n\tdef get_log_uuid() -> str:\n\t    \"\"\"Return UUID for logging.\n\t    Returns:\n\t        UUID string value.\n\t    \"\"\"\n", "    global _log_counter, _log_counter_lock\n\t    with _log_counter_lock:\n\t        _log_counter += 1\n\t        return \"%x\" % _log_counter\n\tdef get_log_uuid1() -> str:\n\t    \"\"\"Return UUID1 log logging.\n\t    Returns:\n\t        UUID1 string value.\n\t    \"\"\"\n\t    return str(uuid1())\n", "def get_log_mark() -> Tuple[float, str]:\n\t    \"\"\"Get log mark of (now, uuid).\"\"\"\n\t    return (time.time(), get_log_uuid())\n\tdef get_timestamp() -> str:\n\t    \"\"\"Get timestamp as string.\"\"\"\n\t    return str(time.time())\n\t_counter = int(time.time() * 100)\n\t_counter_lock = Lock()\n\tdef get_uuid() -> str:\n\t    \"\"\"Alternate `get_uuid` implementation.\"\"\"\n", "    global _counter, _counter_lock\n\t    with _counter_lock:\n\t        _counter += 1\n\t        return \"%x\" % _counter\n\tdef get_uuid1() -> str:\n\t    \"\"\"Get UUID1 value.\n\t    Returns:\n\t        UUID1 string value.\n\t    \"\"\"\n\t    # return uuid1().hex\n", "    return str(uuid1())\n\t    # return secrets.token_urlsafe()\n\tdef get_version() -> Tuple:\n\t    \"\"\"Return PENVM version tuple.\n\t    Returns:\n\t        Version tuple.\"\"\"\n\t    return VERSION\n\tdef get_version_string() -> str:\n\t    \"\"\"Return PENVM version as a string.\n\t    Returns:\n", "        Version string.\n\t    \"\"\"\n\t    return \"%s.%s.%s\" % VERSION\n"]}
{"filename": "src/lib/penvm/lib/mqueue.py", "chunked_list": ["#\n\t# penvm/lib/mqueue.py\n\t#\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport logging\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n", "from penvm.lib.base import BaseObject\n\tfrom penvm.lib.message import Message\n\tfrom penvm.lib.misc import State, get_uuid\n\tfrom penvm.lib.queue import Queue\n\tlogger = logging.getLogger(__name__)\n\tclass MessageQueue(BaseObject, Queue):\n\t    \"\"\"Message queue.\n\t    Built on top of [penvm.lib.queue.Queue][].\n\t    \"\"\"\n\t    def __init__(self, qsize: int = 0):\n", "        \"\"\"Initialize.\n\t        Args:\n\t            qsize: Maximum queue size. 0 for unlimited.\n\t        \"\"\"\n\t        BaseObject.__init__(self, None, logger)\n\t        Queue.__init__(self, qsize)\n\t    def find(\n\t        self,\n\t        id: str,\n\t    ) -> \"Message\":\n", "        \"\"\"Find and return message in queue with given header id.\n\t        Args:\n\t            id: Message header id.\n\t        Returns:\n\t            Matching Message.\n\t        \"\"\"\n\t        for v in self.values():\n\t            if v.header.get(\"id\") == id:\n\t                return v\n\t    def state(self) -> \"State\":\n", "        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n\t        \"\"\"\n\t        try:\n\t            values = []\n\t            for v in self.values():\n\t                if type(v) == Message:\n\t                    values.append(v.state())\n\t                else:\n", "                    values.append(None)\n\t            return State(\n\t                \"mqueue\",\n\t                self.oid,\n\t                {\n\t                    \"frozen\": self.frozen,\n\t                    \"npop\": self.npop,\n\t                    \"nput\": self.nput,\n\t                    \"size\": self.qsize,\n\t                    \"values\": values,\n", "                },\n\t            )\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n"]}
{"filename": "src/lib/penvm/lib/connectionmanager.py", "chunked_list": ["#\n\t# penvm/lib/connectionmanager.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport logging\n\timport socket\n\timport threading\n", "import traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.connection import Listener\n\tfrom penvm.lib.misc import State\n\tlogger = logging.getLogger(__name__)\n\tclass ConnectionManager(BaseObject):\n\t    \"\"\"Manage connections set up by Listener.\n\t    * Listen for new connections (running in a thread).\n\t    * Spawn accepted connections (`Connection` runs its own threads).\n", "    \"\"\"\n\t    def __init__(\n\t        self,\n\t        machine: \"Machine\",\n\t        host: str,\n\t        port: int,\n\t        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n\t    ):\n\t        \"\"\"Set up.\n\t        Args:\n", "            machine: Machine owning this manager.\n\t            host: Host address to listen on. 0.0.0.0 for all\n\t                interfaces.\n\t            port: Port to listen on. 0 for auto assign.\n\t            sslcontext: SSL context for SSL encrypted connections.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(None, logger)\n\t            tlogger = self.logger.enter()\n\t            self.machine = machine\n", "            self.host = host\n\t            self.port = port\n\t            self.sslcontext = sslcontext\n\t            self.conns = {}\n\t            self.exit = False\n\t            self.listener = Listener(self.machine, host, port, sslcontext)\n\t            # TODO: should listen() be called here?\n\t            self.listener.listen(100)\n\t            self.ltimeout = 30\n\t            self.th = None\n", "            self.init_conn = None\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def drop(\n\t        self,\n\t        connectionid: str,\n\t    ):\n\t        \"\"\"Drop connection by connection id.\n", "        Args:\n\t            connectionid: Connection id.\n\t        \"\"\"\n\t        self.logger.debug(f\"DROPPED connection {connectionid=} {self.conns.get(connectionid)=}\")\n\t        self.conns.pop(connectionid)\n\t    def get(\n\t        self,\n\t        connectionid: str,\n\t    ) -> \"Connection\":\n\t        \"\"\"Get connection by connection id.\n", "        Args:\n\t            connectionid: Connection id.\n\t        Returns:\n\t            Connection for connection id.\n\t        \"\"\"\n\t        return self.conns.get(connectionid)\n\t    def list(self) -> List[str]:\n\t        \"\"\"Get list of connection ids.\n\t        Returns:\n\t            Connection ids.\n", "        \"\"\"\n\t        return list(self.conns.keys())\n\t    def run(self):\n\t        \"\"\"Run.\n\t        Listen for connections and add.\n\t        The initial connection must occur within a short amount of\n\t        time (first-wait) and remain up for the lifetime of the\n\t        machine. Once the initial connection drops, all others are\n\t        dropped and the machine will end up shutting down.\n\t        \"\"\"\n", "        try:\n\t            tlogger = self.logger.enter()\n\t            CHECK_TIMEOUT = 10.125\n\t            CHECK_TIMEOUT = 120.125\n\t            CHECK_TIMEOUT = 10000000\n\t            try:\n\t                # initial/firstwait timeout\n\t                self.listener.settimeout(self.ltimeout)\n\t                while not self.exit:\n\t                    try:\n", "                        tlogger.debug(\n\t                            f\"listening for connection {self.listener.lhost=} {self.listener.lport=} ...\"\n\t                        )\n\t                        conn = self.listener.accept()\n\t                        tlogger.debug(f\"accepted connection {conn=}\")\n\t                        if self.init_conn == None:\n\t                            # set to shutdown on connection close/fail of initial connection\n\t                            self.init_conn = conn\n\t                            conn.onclose = self.shutdown\n\t                        else:\n", "                            # TODO: should be part of accept step?\n\t                            conn.onclose = self.drop\n\t                        self.conns[conn.oid] = conn\n\t                        conn.start()\n\t                        # non-initial/post-firstwait update to timeout\n\t                        if self.ltimeout >= 0 and self.ltimeout != CHECK_TIMEOUT:\n\t                            tlogger.debug(\"non-intial timeout\")\n\t                            self.ltimeout = CHECK_TIMEOUT\n\t                            self.listener.settimeout(self.ltimeout)\n\t                    except (socket.timeout, TimeoutError):\n", "                        # periodic wakeup\n\t                        self.logger.debug(f\"listener timed out after {self.ltimeout}\")\n\t                        if len(self.conns) == 0 and self.ltimeout == CHECK_TIMEOUT:\n\t                            # cleanup opportunity\n\t                            break\n\t                        # setup check timeout if not already in place\n\t                        if self.ltimeout != CHECK_TIMEOUT:\n\t                            self.ltimeout = CHECK_TIMEOUT\n\t                            self.listener.settimeout(self.ltimeout)\n\t                    except Exception as e:\n", "                        self.logger.debug(f\"EXCEPTION ({e})\")\n\t            finally:\n\t                # cleanup\n\t                for conn in self.conns.values():\n\t                    conn.close()\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def shutdown(\n", "        self,\n\t        connectionid: str,\n\t    ):\n\t        \"\"\"Force termination.\n\t        Intended to be called by `Connection.onclose` instead of\n\t        `ConnectionManager.drop()` when the initial connection\n\t        (`init_conn`) is closed.\n\t        Args:\n\t            connectionid: Connection id.\n\t        \"\"\"\n", "        try:\n\t            tlogger = self.logger.enter()\n\t            self.machine.shutdown(now=True)\n\t            # should not reach here!\n\t        finally:\n\t            tlogger.exit()\n\t    def start(self):\n\t        \"\"\"Start.\n\t        Background thread to handle connections.\"\"\"\n\t        try:\n", "            self.logger.debug(\"starting ...\")\n\t            if not self.th:\n\t                try:\n\t                    self.th = threading.Thread(target=self.run)\n\t                    self.th.daemon = True\n\t                    self.th.start()\n\t                except Exception as e:\n\t                    self.logger.critical(f\"failed to start ({e}\")\n\t                    self.th = None\n\t        except Exception as e:\n", "            self.logger.warning(f\"EXCEPTION ({e})\")\n\t    def state(self) -> \"State\":\n\t        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n\t        \"\"\"\n\t        try:\n\t            return State(\n\t                \"connection-manager\",\n\t                None,\n", "                {\n\t                    \"connection-ids\": self.list(),\n\t                    \"nconnections\": len(self.conns),\n\t                    \"listener\": {\n\t                        \"timeout\": self.ltimeout,\n\t                        \"addr\": self.listener.lhost,\n\t                        \"port\": self.listener.lport,\n\t                    },\n\t                },\n\t            )\n", "        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n"]}
{"filename": "src/lib/penvm/lib/debug.py", "chunked_list": ["#\n\t# penvm/lib/debug.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Debugging tools.\"\"\"\n\tfrom threading import Lock\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n", "class DataDumper:\n\t    \"\"\"Dumps data to a destination (e.g., file) with support for\n\t    serialization.\"\"\"\n\t    def __init__(self, path: str):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            path: File path to dump data.\n\t        \"\"\"\n\t        self.path = path\n\t        self.lock = Lock()\n", "        self.f = open(path, \"ab\")\n\t    def __del__(self):\n\t        try:\n\t            self.f.close()\n\t        except:\n\t            pass\n\t    def writebytes(\n\t        self,\n\t        b: bytes,\n\t        flush: bool = True,\n", "    ):\n\t        \"\"\"Write bytes.\n\t        Args:\n\t            b: Bytes to write\n\t            flush: Flush stream.\n\t        \"\"\"\n\t        try:\n\t            self.lock.acquire()\n\t            self.f.write(b)\n\t            if flush:\n", "                self.f.flush()\n\t        except Exception as e:\n\t            print(f\"EXCEPTION {e}\")\n\t        finally:\n\t            self.lock.release()\n\t    def writetext(self, t: str, flush: bool = False):\n\t        \"\"\"Write text.\n\t        Args:\n\t            t: String to write.\n\t            flush: Flush to stream.\n", "        \"\"\"\n\t        self.writebytes(t.decode(\"utf-8\"), flush)\n"]}
{"filename": "src/lib/penvm/lib/semaphore.py", "chunked_list": ["#\n\t# penvm/lib/semaphore.py\n\t#\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n", "#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport logging\n\tfrom threading import Lock\n", "from typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tlogger = logging.getLogger(__name__)\n\tclass AdjustableSemaphore:\n\t    \"\"\"Semaphore with support for adjusting the limit `n` while in\n\t    use.\"\"\"\n\t    def __init__(\n\t        self,\n\t        n: int = 1,\n\t    ):\n\t        \"\"\"Initialize.\n", "        Args:\n\t            n: Count.\n\t        \"\"\"\n\t        self._max = n\n\t        self._curr = 0\n\t        self._lock = Lock()\n\t        self._waitlock = Lock()\n\t    def acquire(self):\n\t        \"\"\"Acquire a semaphore.\n\t        Increase current count.\n", "        \"\"\"\n\t        while True:\n\t            if self._lock.acquire(blocking=False):\n\t                if self._curr < self._max:\n\t                    self._curr += 1\n\t                    self._lock.release()\n\t                    return\n\t                self._lock.release()\n\t            self._waitlock.acquire()\n\t    def adjust(self, n: int = 1):\n", "        \"\"\"Adjust count.\n\t        Args:\n\t            n: New count.\n\t        \"\"\"\n\t        self._lock.acquire()\n\t        n = n if n > 0 else 1\n\t        self._max = n\n\t        self._lock.release()\n\t        # wake up waiter that might *now* acquire a lock\n\t        try:\n", "            self._waitlock.release()\n\t        except:\n\t            # ignore if already unlocked!\n\t            pass\n\t    def count(self) -> int:\n\t        \"\"\"Return current count.\n\t        Returns:\n\t            Current count.\n\t        \"\"\"\n\t        return self._curr\n", "    def max(self) -> int:\n\t        \"\"\"Return maximum count allowed.\n\t        Returns:\n\t            Maximum count.\n\t        \"\"\"\n\t        return self._max\n\t    def release(self):\n\t        \"\"\"Release a semaphore.\n\t        Decreases current count.\n\t        \"\"\"\n", "        self._lock.acquire()\n\t        self._curr = max(self._curr - 1, 0)\n\t        self._lock.release()\n\t        try:\n\t            # wake up waiters\n\t            self._waitlock.release()\n\t        except Exception as e:\n\t            pass\n"]}
{"filename": "src/lib/penvm/lib/connection.py", "chunked_list": ["#\n\t# penvm/lib/connection.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Wrappers for low-level connections.\n\t\"\"\"\n\timport logging\n", "import socket\n\timport time\n\timport traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.message import Message\n\tfrom penvm.lib.misc import State\n\tfrom penvm.lib.mqueue import MessageQueue\n\tfrom penvm.lib.queue import RoutingQueue\n\tfrom penvm.lib.thread import Thread\n", "DEBUG = False\n\tif DEBUG:\n\t    import os\n\t    from penvm.lib.debug import DataDumper\n\t    ddrecv = DataDumper(f\"/tmp/penvm-ddrecv-{os.getpid()}.log\")\n\t    ddsend = DataDumper(f\"/tmp/penvm-ddsend-{os.getpid()}.log\")\n\tlogger = logging.getLogger(__name__)\n\tHOSTNAME = socket.gethostname()\n\tBLK_SZ_LEN = 8\n\tBLK_SZ_FMT = b\"%%0.%dd\" % BLK_SZ_LEN\n", "BLK_SZ_MAX = 100_000_000 - 1\n\tKB = 1024\n\tMB = KB * 1024\n\tGB = MB * 1024\n\tclass ConnectionError(Exception):\n\t    pass\n\tclass Listener(BaseObject):\n\t    \"\"\"Listener side/socket.\"\"\"\n\t    def __init__(\n\t        self,\n", "        machine: \"Machine\",\n\t        host: str,\n\t        port: int,\n\t        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n\t    ):\n\t        try:\n\t            super().__init__(None, logger)\n\t            tlogger = self.logger.enter()\n\t            self.machine = machine\n\t            self.host = host\n", "            self.port = port\n\t            self.sslcontext = sslcontext\n\t            self.lsock = None\n\t            self.lhost = None\n\t            self.lport = None\n\t        finally:\n\t            tlogger.exit()\n\t    def accept(self):\n\t        try:\n\t            tlogger = self.logger.enter()\n", "            tlogger.debug(\"accepting ...\")\n\t            sock, addr = self.lsock.accept()\n\t            tlogger.debug(f\"accepted from sock={sock} addr={addr}\")\n\t            if self.sslcontext:\n\t                # TODO: ensure (failed/slow/non-ssl) ssl negotiation does not block\n\t                tlogger.debug(f\"setting up ssl {self.sslcontext=}...\")\n\t                sock = self.sslcontext.wrap_socket(sock, server_side=True)\n\t                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n\t                tlogger.debug(f\"ssl socket ({sock=})\")\n\t            tlogger.debug(\"creating ServerConnection ...\")\n", "            return ServerConnection(self.machine, addr[0], addr[1], self.sslcontext, sock)\n\t        except Exception as e:\n\t            tlogger.debug(f\"EXCEPTION ({e})\")\n\t            # allow timeout to percolate up\n\t            raise\n\t        finally:\n\t            tlogger.exit()\n\t    def is_listening(self):\n\t        return self.lsock != None\n\t    def listen(\n", "        self,\n\t        n: int = 1,\n\t    ):\n\t        \"\"\"Set up to listen for connection.\n\t        Args:\n\t            n: Number of outstanding socket connection requests\n\t                allowed.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n", "            self.lsock = lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t            lsock.bind((self.host, self.port))\n\t            lsock.listen(n)\n\t            self.lhost, self.lport = lsock.getsockname()\n\t        finally:\n\t            tlogger.exit()\n\t    def settimeout(\n\t        self,\n\t        delay: int,\n\t    ):\n", "        \"\"\"Set timeout.\n\t        Args:\n\t            delay: Seconds before timing out on idle connection.\n\t        \"\"\"\n\t        self.lsock.settimeout(delay)\n\tclass SocketConnection(BaseObject):\n\t    \"\"\"Socket connection.\n\t    Provides the interface to the socket.\"\"\"\n\t    def __init__(\n\t        self,\n", "        host: str,\n\t        port: int,\n\t        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n\t        sock: Union[\"socket.socket\", None] = None,\n\t    ):\n\t        \"\"\"Setup.\n\t        Args:\n\t            host: Host address.\n\t            port: Port.\n\t            sslcontext: SSL context used for wrapping a regular socket\n", "                to provide encryption.\n\t            sock: Network socket.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(None, logger)\n\t            tlogger = self.logger.enter()\n\t            self.host = host\n\t            self.port = port\n\t            self.sslcontext = sslcontext\n\t            self.sock = sock\n", "        finally:\n\t            tlogger.exit()\n\t    def __repr__(self):\n\t        return f\"<SocketConnection id={self.oid} host={self.host} port={self.port}>\"\n\t    def connect(self):\n\t        \"\"\"Connection to server.\"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            try:\n\t                sock = None\n", "                for i in range(5):\n\t                    try:\n\t                        tlogger.debug(f\"connecting to server ({self.host}) ({self.port}) ...\")\n\t                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t                        if self.sslcontext:\n\t                            sock = self.sslcontext.wrap_socket(sock, server_side=False)\n\t                            tlogger.debug(f\"socket ssl wrapped\")\n\t                        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n\t                        tlogger.debug(f\"connection info host={self.host} port={self.port}\")\n\t                        sock.connect((self.host, self.port))\n", "                        break\n\t                    except socket.error as e:\n\t                        # TODO: clean up sock if/as needed\n\t                        tlogger.debug(f\"socket error ({e})\")\n\t                        time.sleep(2)\n\t                    except Exception as e:\n\t                        if i == 5:\n\t                            raise\n\t                tlogger.debug(\"connected\")\n\t                self.sock = sock\n", "            except Exception as e:\n\t                tlogger.debug(f\"connection failed ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def recv(\n\t        self,\n\t        sz: int,\n\t    ) -> bytes:\n\t        \"\"\"Receive (all) bytes.\n\t        Args:\n", "            sz: Number of bytes.\n\t        Returns:\n\t            Bytes received.\n\t        \"\"\"\n\t        l = []\n\t        while sz > 0:\n\t            b = self.sock.recv(sz)\n\t            # TODO: handle signal? not needd since v3.5!\n\t            if len(b) == 0:\n\t                self.logger.debug(f\"connection closed ({sz=}) ({l=})\")\n", "                raise Exception(\"connection closed\")\n\t                break\n\t            # self.logger.debug(f\"recv {len(b)=}\")\n\t            l.append(b)\n\t            sz -= len(b)\n\t        # TODO: improve this!?!\n\t        return b\"\".join(l)\n\t    def recvblk(\n\t        self,\n\t        blkszlen: int = BLK_SZ_LEN,\n", "    ) -> bytes:\n\t        \"\"\"Receive and return a block.\n\t        Args:\n\t            blkszlen: Maximum receivable block size.\n\t        Returns:\n\t            Bytes received.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            try:\n", "                sz = int(self.recv(blkszlen))\n\t                t0 = time.time()\n\t                b = self.recv(sz)\n\t                elapsed = time.time() - t0\n\t                if DEBUG:\n\t                    ddrecv.writebytes(b)\n\t                tlogger.lap(f\"size ({len(b)}) perf ({len(b)/MB/elapsed:.4f} MB/s)\")\n\t                return b\n\t            except Exception as e:\n\t                # traceback.print_exc()\n", "                raise ConnectionError(\"failed to receive block\")\n\t        finally:\n\t            tlogger.exit()\n\t    def xsend(\n\t        self,\n\t        b: bytes,\n\t    ):\n\t        \"\"\"Send all bytes.\"\"\"\n\t        self.sock.sendall(b)\n\t    def send(\n", "        self,\n\t        b: bytes,\n\t    ):\n\t        \"\"\"Send bytes.\n\t        Args:\n\t            b: Bytes to send.\n\t        \"\"\"\n\t        total = 0\n\t        sz = len(b)\n\t        while total < sz:\n", "            count = self.sock.send(b)\n\t            if count == 0:\n\t                raise Exception(\"send failed\")\n\t            total += count\n\t            b = b[count:]\n\t        # print(f\"------------ send ({total=}) ({sz=})\")\n\t        self.logger.debug(f\"------------ send ({total=}) ({sz=})\")\n\t        return total\n\t    def sendblk(\n\t        self,\n", "        b: bytes,\n\t        blkszmax: int = BLK_SZ_MAX,\n\t        blkszfmt: int = BLK_SZ_FMT,\n\t    ):\n\t        \"\"\"Send a block (as bytes).\n\t        Size information is sent over the stream before the data.\n\t        Args:\n\t            b: Bytes to send.\n\t            blkszmax: Maximum sendable block size.\n\t            blkszfmt: Block size field format.\n", "        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            try:\n\t                if len(b) > blkszmax:\n\t                    raise Exception(f\"block exceeds size ({blkszmax})\")\n\t                b = (blkszfmt % len(b)) + b\n\t                t0 = time.time()\n\t                self.send(b)\n\t                elapsed = time.time() - t0\n", "                if DEBUG:\n\t                    ddsend.writebytes(b)\n\t                # print(f\"size ({len(b)}) perf ({len(b)/MB/elapsed:.4f} MB/s)\")\n\t                tlogger.lap(f\"size ({len(b)}) perf ({len(b)/MB/elapsed:.4f} MB/s)\")\n\t            except Exception as e:\n\t                traceback.print_exc()\n\t                raise ConnectionError(\"failed to send block\")\n\t        finally:\n\t            tlogger.exit()\n\t    def close(self):\n", "        \"\"\"Close connection.\"\"\"\n\t        self.logger.debug(\"close\")\n\t        self.sock.close()\n\t        self.sock = None\n\t    def is_alive(self) -> bool:\n\t        \"\"\"Indicate if connection is alive or not.\n\t        Returns:\n\t            Alive status.\n\t        \"\"\"\n\t        return True\n", "    def is_connected(self) -> bool:\n\t        \"\"\"Indicate if connected or not.\n\t        Returns:\n\t            Connection status.\n\t        \"\"\"\n\t        return self.sock != None\n\tclass MessageConnection(SocketConnection):\n\t    \"\"\"Message connection.\n\t    Provides the interface to the socket with support for messages.\n\t    The headers of incoming and outgoing message are all updated with\n", "    the connection id.\"\"\"\n\t    def __init__(\n\t        self,\n\t        host: str,\n\t        port: int,\n\t        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n\t        sock: Union[\"socket.socket\", None] = None,\n\t    ):\n\t        \"\"\"Setup.\n\t        Args:\n", "            host: Host address.\n\t            port: Port.\n\t            sslcontext: SSL context used for wrapping a regular\n\t                socket to provide encryption.\n\t            sock: Network socket.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(host, port, sslcontext, sock)\n\t            # self.logger already set up\n\t            tlogger = self.logger.enter()\n", "        finally:\n\t            tlogger.exit()\n\t    def __repr__(self):\n\t        return f\"<MessageConnection id={self.oid} host={self.host} port={self.port}>\"\n\t    def recvmsg(self) -> \"Message\":\n\t        \"\"\"Receive message and return (as generic Message).\n\t        Returns:\n\t            Received message.\n\t        \"\"\"\n\t        try:\n", "            tlogger = self.logger.enter()\n\t            b = self.recvblk()\n\t            t0 = time.time()\n\t            h, p = Message.decode(b)\n\t            elapsed = time.time() - t0\n\t            tlogger.lap(f\"size ({len(b)}) decode time ({elapsed}:.4f)\")\n\t            # print(f\"size ({len(b)}) decode time ({elapsed}:.4f)\")\n\t            return Message(h, p)\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n", "            raise\n\t        finally:\n\t            tlogger.exit()\n\t    def sendmsg(\n\t        self,\n\t        msg: \"Message\",\n\t    ):\n\t        \"\"\"Send message (serialized).\n\t        Args:\n\t            msg: Message to send.\n", "        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            t0 = time.time()\n\t            b = msg.encode()\n\t            elapsed = time.time() - t0\n\t            tlogger.lap(f\"size ({len(b)}) encode time ({elapsed}:.4f)\")\n\t            self.sendblk(b)\n\t            # print(f\"size ({len(b)}) encode time ({elapsed}:.4f)\")\n\t        except Exception as e:\n", "            self.logger.warning(f\"EXCEPTION ({e})\")\n\t            raise\n\t        finally:\n\t            tlogger.exit()\n\tclass Connection(MessageConnection):\n\t    \"\"\"Connection.\n\t    Provides the interface between the network socket and message\n\t    queues (incoming, outgoing).\n\t    The headers of incoming and outgoing message are all augmented\n\t    with the connection id.\"\"\"\n", "    def __init__(\n\t        self,\n\t        machine: \"Machine\",\n\t        host: str,\n\t        port: int,\n\t        sslcontext: Union[\"ssl.SSLContext\", None] = None,\n\t        sock: Union[\"socket.socket\", None] = None,\n\t        onclose: Union[Callable, None] = None,\n\t    ):\n\t        \"\"\"Initialize.\n", "        Args:\n\t            machine: Machine.\n\t            host: Host address.\n\t            port: Port.\n\t            sslcontext: SSL Context.\n\t            onclose: Function to call to when connection is closed.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(host, port, sslcontext, sock)\n\t            self.machine = machine\n", "            self.onclose = onclose\n\t            self.exit = False\n\t            self.imq = RoutingQueue(put=self.imq_put)\n\t            self.omq = MessageQueue()\n\t            self.recvmsgs_th = None\n\t            self.sendmsgs_th = None\n\t        finally:\n\t            pass\n\t    def __repr__(self):\n\t        return f\"<Connection id={self.oid} machine={self.machine.oid} host={self.host} port={self.port}>\"\n", "    def close(self):\n\t        \"\"\"Close connection.\"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            super().close()\n\t            self.exit = True\n\t            tlogger.debug(f\"onclose ({self.onclose})\")\n\t            if self.onclose:\n\t                self.onclose(self.oid)\n\t        except Exception as e:\n", "            tlogger.debug(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def imq_put(\n\t        self,\n\t        msg: \"Message\",\n\t    ):\n\t        \"\"\"Put message on IMQ.\n\t        Args:\n\t            msg: Message to enqueue.\n", "        \"\"\"\n\t        self.machine.imq.put(msg)\n\t    def recvmsgs(self):\n\t        \"\"\"Receive messages over connection.\n\t        Loops while `self.exit` is `True`.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            while not self.exit:\n\t                try:\n", "                    tlogger.debug(\"recvmsgs waiting ...\")\n\t                    msg = self.recvmsg()\n\t                    tlogger.debug(\"recvmsgs message received\")\n\t                    # patch header with `Connection.oid`\n\t                    msg.header[\"connection-id\"] = self.oid\n\t                    self.imq.put(msg)\n\t                    tlogger.debug(\"recvmsgs message put\")\n\t                except Exception as e:\n\t                    tlogger.debug(f\"EXCEPTION ({e})\")\n\t                    # raise\n", "                    # TODO: close/cleanup should be elsewhere\n\t                    self.close()\n\t                    break\n\t        finally:\n\t            tlogger.exit()\n\t    def sendmsgs(self):\n\t        \"\"\"Send message over connection.\n\t        Loops while `self.exit` is `True`.\n\t        \"\"\"\n\t        try:\n", "            tlogger = self.logger.enter()\n\t            while not self.exit:\n\t                try:\n\t                    tlogger.debug(\"sendmsgs waiting ...\")\n\t                    msg = self.omq.pop()\n\t                    tlogger.debug(\"sendmsgs popped message\")\n\t                    msg.header[\"connection-id\"] = self.oid\n\t                    self.sendmsg(msg)\n\t                    tlogger.debug(\"sendmsgs sent\")\n\t                except Exception as e:\n", "                    tlogger.debug(f\"EXCEPTION ({e})\")\n\t                    self.close()\n\t                    raise\n\t                    break\n\t        finally:\n\t            tlogger.exit()\n\t    def start(self):\n\t        \"\"\"Start recv and send message handing.\"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n", "            # TODO: fix to handle ssl situation\n\t            if self.sock == None:\n\t                self.connect()\n\t                # raise Exception(\"no connection!!!\")\n\t            if not self.sendmsgs_th:\n\t                try:\n\t                    tlogger.debug(\"starting sendmsgs ...\")\n\t                    self.sendmsgs_th = Thread(target=self.sendmsgs)\n\t                    self.sendmsgs_th.daemon = True\n\t                    self.sendmsgs_th.start()\n", "                except Exception as e:\n\t                    tlogger.debug(f\"starting sendmsgs EXCEPTION ({e})\")\n\t                    self.sendmsgs_th = None\n\t            if not self.recvmsgs_th:\n\t                try:\n\t                    tlogger.debug(\"starting recvmsgs ...\")\n\t                    self.recvmsgs_th = Thread(target=self.recvmsgs)\n\t                    self.recvmsgs_th.daemon = True\n\t                    self.recvmsgs_th.start()\n\t                except Exception as e:\n", "                    tlogger.debug(f\"starting recvmsgs EXCEPTION ({e})\")\n\t                    self.recvmsgs_th = None\n\t        except Exception as e:\n\t            tlogger.debug(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def state(self) -> \"State\":\n\t        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n", "        \"\"\"\n\t        try:\n\t            peer = self.sock.getpeername()\n\t            return State(\n\t                \"connection\",\n\t                self.oid,\n\t                {\n\t                    \"initial-connection\": self.machine.connmgr.init_conn == self,\n\t                    \"host\": self.host,\n\t                    \"port\": self.port,\n", "                    \"peer-host\": peer[0],\n\t                    \"peer-port\": peer[1],\n\t                    \"nimq\": self.imq.size(),\n\t                    \"nomq\": self.omq.size(),\n\t                    \"ssl\": self.sslcontext != None,\n\t                },\n\t            )\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\tclass ClientConnection(Connection):\n", "    \"\"\"Client-side message queue connection.\"\"\"\n\t    def __init__(self, *args, **kwargs):\n\t        \"\"\"Initialize.\"\"\"\n\t        try:\n\t            super().__init__(*args, **kwargs)\n\t            tlogger = self.logger.enter()\n\t        finally:\n\t            tlogger.exit()\n\tclass ServerConnection(Connection):\n\t    \"\"\"Server-side message queue connection.\n", "    Returned by Listener.\"\"\"\n\t    def __init__(self, *args, **kwargs):\n\t        \"\"\"Initialize.\"\"\"\n\t        try:\n\t            super().__init__(*args, **kwargs)\n\t            tlogger = self.logger.enter()\n\t        finally:\n\t            tlogger.exit()\n"]}
{"filename": "src/server/penvm/server/machine.py", "chunked_list": ["#\n\t# penvm/server/machine.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport logging\n\timport os\n\timport socket\n", "import sys\n\timport threading\n\timport time\n\timport traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.connectionmanager import ConnectionManager\n\tfrom penvm.lib.misc import State, get_timestamp, get_uuid1\n\tfrom penvm.lib.queue import RoutingQueue\n\tfrom penvm.server.kernelmanager import KernelManager\n", "from penvm.server.sessionmanager import SessionManager\n\t# from penvm.server.storage import StorageManager\n\tfrom penvm.lib.kvstore import FileKVStore\n\tfrom penvm.kernels.core.server import Kernel as CoreKernel\n\tfrom penvm.kernels.default.server import Kernel as DefaultKernel\n\tlogger = logging.getLogger(__name__)\n\tclass Machine(BaseObject):\n\t    \"\"\"Server-side machine.\n\t    Provides access to all \"managers\" (e.g, connection, kernel,\n\t    session, store), main incoming and outgoing message queues, and\n", "    state/control to support debug mode.\"\"\"\n\t    def __init__(\n\t        self,\n\t        host: str,\n\t        port: int,\n\t        sslprofile: Union[str, None] = None,\n\t        machineid: Union[str, None] = None,\n\t    ):\n\t        \"\"\"Set up server-side machine.\n\t        Args:\n", "            host: Host address.\n\t            port: Port.\n\t            sslprofile: SSL profile for SSL context.\n\t            machineid: Machine id. Generated if not provided.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(machineid, logger)\n\t            tlogger = self.logger.enter()\n\t            self.sslprofile = sslprofile\n\t            self.sslcontext = self.get_sslcontext(self.sslprofile)\n", "            self.connmgr = ConnectionManager(self, host, port, self.sslcontext)\n\t            self.kernelmgr = KernelManager(self)\n\t            self.sessmgr = SessionManager(self)\n\t            # self.storemgr = StorageManager(self)\n\t            self.fkvstore = FileKVStore(f\"/tmp/penvm-store-{self.oid}-{get_uuid1()}\")\n\t            for kernel_cls in [CoreKernel, DefaultKernel]:\n\t                self.kernelmgr.set(kernel_cls.name, kernel_cls())\n\t            self._background = False\n\t            self.debug = False\n\t            self.schedlock = threading.Lock()\n", "            self.imq = RoutingQueue(put=self.imq_put)\n\t            self.omq = RoutingQueue(put=self.omq_put)\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def features(self) -> Dict:\n\t        \"\"\"Get a dictionary of features.\n\t        Returns:\n\t            Dictionary of features.\n", "        \"\"\"\n\t        try:\n\t            # languages\n\t            d = {\n\t                \"language\": \"python\",\n\t                \"python\": {\n\t                    \"platform\": sys.platform,\n\t                    \"version\": list(sys.version_info),\n\t                },\n\t                \"library\": {},\n", "            }\n\t            # libraries\n\t            try:\n\t                import numpy\n\t                d[\"library\"][\"numpy\"] = numpy.version.full_version\n\t            except:\n\t                pass\n\t            return d\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n", "    def get_addr_port(self) -> Tuple[str, int]:\n\t        \"\"\"Get machine listener address and port.\n\t        Returns:\n\t            Tuple of listener host and port.\n\t        \"\"\"\n\t        return (self.connmgr.listener.lhost, self.connmgr.listener.lport)\n\t    def get_session(\n\t        self,\n\t        sessionid: str = \"default\",\n\t    ) -> \"Session\":\n", "        \"\"\"Get/create session.\n\t        Args:\n\t            sessionid (str): Session id (optional).\n\t        Returns:\n\t            Session.\n\t        \"\"\"\n\t        # TODO: no default. must be provided by client\n\t        return self.sessmgr.setdefault(sessionid)\n\t    def get_sslcontext(\n\t        self,\n", "        sslprofile: Union[str, None],\n\t    ) -> Union[\"ssl.SSLContext\", None]:\n\t        \"\"\"Load server-side SSLContext based on named ssl profile.\n\t        Args:\n\t            sslprofile: SSL profile name.\n\t        Returns:\n\t            SSLContext.\n\t        \"\"\"\n\t        if sslprofile:\n\t            try:\n", "                import ssl\n\t                sslprofile_dir = os.path.expanduser(f\"~/.penvm/ssl/{sslprofile}\")\n\t                sslcontext = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n\t                # sslcontext.verify_mode = ssl.CERT_REQUIRED\n\t                sslcontext.load_cert_chain(\n\t                    certfile=f\"{sslprofile_dir}/server.crt\",\n\t                    keyfile=f\"{sslprofile_dir}/server.key\",\n\t                )\n\t                return sslcontext\n\t            except Exception as e:\n", "                logger.debug(f\"ssl required but missing for ssl profile ({sslprofile})\")\n\t                raise Exception(f\"ssl required but missing for ssl profile ({sslprofile})\")\n\t    def imq_put(\n\t        self,\n\t        msg: \"Message\",\n\t    ):\n\t        \"\"\"Triage message and put on proper session incoming message\n\t        queue.\n\t        Note: This is where incoming requests result in session\n\t        creation, then request processing!\n", "        Args:\n\t            msg: Message to enqueue.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            sessionid = msg.header.get(\"session-id\", \"default\")\n\t            sess = self.sessmgr.setdefault(sessionid)\n\t            if sess:\n\t                sess.imq.put(msg)\n\t            else:\n", "                # DROP!\n\t                tlogger.warning(f\"dropped message for session {sessionid}\")\n\t                pass\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def omq_put(\n\t        self,\n\t        msg: \"Message\",\n", "    ):\n\t        \"\"\"Triage message and put on proper connection outgoing\n\t        message queue.\n\t        Args:\n\t            msg: Message to enqueue.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            connectionid = msg.header.get(\"connection-id\")\n\t            conn = self.connmgr.get(connectionid)\n", "            if conn:\n\t                conn.omq.put(msg)\n\t            else:\n\t                # DROP!\n\t                tlogger.warning(\"omq_put dropped message\")\n\t                pass\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n", "    def pop_session(\n\t        self,\n\t        sessionid: str = \"default\",\n\t    ) -> \"Session\":\n\t        \"\"\"Pop session.\n\t        Args:\n\t            sessionid: Session id.\n\t        Returns:\n\t            Session.\n\t        \"\"\"\n", "        return self.sessmgr.pop(sessionid)\n\t    def run(self):\n\t        \"\"\"Run \"runnable\" managers.\"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            self.connmgr.run()\n\t            # self.sessmgr.run()\n\t            # self.opsmgr.run()\n\t        finally:\n\t            tlogger.exit()\n", "    def set_debug(\n\t        self,\n\t        enabled: bool,\n\t    ):\n\t        \"\"\"Set debug mode\n\t        Args:\n\t            enabled: New state for debug mode.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n", "            tlogger.debug(\"setting debug ({enabled})\")\n\t            self.debug = enabled\n\t            if self.debug:\n\t                try:\n\t                    if self.schedlock.locked():\n\t                        self.schedlock.release()\n\t                except Exception as e:\n\t                    pass\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n", "        finally:\n\t            tlogger.exit()\n\t    def shutdown(\n\t        self,\n\t        now: bool = False,\n\t    ):\n\t        \"\"\"Shutdown machine.\n\t        Args:\n\t            now: To shut down \"now\".\n\t        \"\"\"\n", "        try:\n\t            tlogger = self.logger.enter()\n\t            tlogger.debug(\"SHUTTTING DOWN ...\")\n\t            if now:\n\t                os._exit(0)\n\t        finally:\n\t            tlogger.exit()\n\t    def start(self):\n\t        \"\"\"Start machine.\"\"\"\n\t        try:\n", "            tlogger = self.logger.enter()\n\t            self.connmgr.start()\n\t            self.sessmgr.start()\n\t            self.kernelmgr.start()\n\t        finally:\n\t            tlogger.exit()\n\t    def state(self) -> \"State\":\n\t        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n", "        \"\"\"\n\t        try:\n\t            uname = os.uname()\n\t            return State(\n\t                \"machine\",\n\t                self.oid,\n\t                {\n\t                    \"debug\": self.debug,\n\t                    \"features\": self.features(),\n\t                    \"host\": socket.gethostname(),\n", "                    \"schedlock\": self.schedlock.locked(),\n\t                    \"timestamp\": get_timestamp(),\n\t                    \"uname\": {\n\t                        \"machine\": uname.machine,\n\t                        \"nodename\": uname.nodename,\n\t                        \"release\": uname.release,\n\t                        \"sysname\": uname.sysname,\n\t                        \"version\": uname.version,\n\t                    },\n\t                },\n", "            )\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t    def step_debug(self):\n\t        \"\"\"Allow a step if in debug mode.\"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            tlogger.debug(\"stepping debug\")\n\t            if self.debug:\n\t                try:\n", "                    if self.schedlock.locked():\n\t                        self.schedlock.release()\n\t                except Exception as e:\n\t                    pass\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def stop(self):\n\t        \"\"\"Step machine.\"\"\"\n", "        try:\n\t            tlogger = self.logger.enter()\n\t            self.connmgr.stop()\n\t            # self.sessmgr.stop()\n\t        finally:\n\t            tlogger.exit()\n\t    def wait(self):\n\t        \"\"\"Wait (indefinitely) for machine to exit.\"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n", "            time.sleep(1000000000)\n\t        finally:\n\t            tlogger.exit()\n"]}
{"filename": "src/server/penvm/server/processor.py", "chunked_list": ["#\n\t# penvm/server/processor.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport logging\n\timport threading\n\timport time\n", "import traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.misc import State\n\tfrom penvm.lib.thread import Thread, ThreadInterrupt\n\tfrom penvm.lib.semaphore import AdjustableSemaphore\n\tlogger = logging.getLogger(__name__)\n\tclass Processor(BaseObject):\n\t    \"\"\"Runs kernel operations.\n\t    Kernel operations are scheduled by the session and run on the\n", "    processor. Operations are run on a selected kernel. Up to\n\t    `max_threads` messages can be processsed at a time.\n\t    The number of running \"threads\" can be adjusted dynamically with\n\t    `max_threads` limiting the number of running thread. Scheduling of\n\t    new threads resumes when the number of running threads goes below\n\t    `max_threads`.\"\"\"\n\t    def __init__(\n\t        self,\n\t        session: \"Session\",\n\t        kernelname: str = \"default\",\n", "    ):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            session: Owning session.\n\t            kernelname: Kernel name.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(None, logger)\n\t            tlogger = self.logger.enter()\n\t            self.session = session\n", "            self.kernelname = kernelname\n\t            self.kill = False\n\t            self.max_threads = 1\n\t            self.kernel = self.session.machine.kernelmgr.get(kernelname)\n\t            self.runsem = AdjustableSemaphore(self.max_threads)\n\t            self.th = None\n\t            self.threads = set()\n\t            self.reqid2thread = {}\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n", "        finally:\n\t            tlogger.exit()\n\t    def __repr__(self):\n\t        return f\"<Processor id={self.oid} max_threads={self.max_threads} nthreads={self.active_count()}>\"\n\t    def active_count(self) -> int:\n\t        \"\"\"Get number of running threads.\n\t        Returns:\n\t            Number of running threads.\n\t        \"\"\"\n\t        return len(self.threads)\n", "    def get_thread_reqids(self) -> List[str]:\n\t        \"\"\"Get list of request ids for each running thread.\n\t        Returns:\n\t            List of request ids.\n\t        \"\"\"\n\t        return list(self.reqid2thread.keys())\n\t    def run_thread(self, fn: Callable, fargs: List):\n\t        \"\"\"Runs a thread (to handle a request).\n\t        Machinery manages creating a context, starting a thread,\n\t        adhering to the thread limit, `ThreadInterrupt` handling,\n", "        tracking information, and `runsem` semaphore.\n\t        Args:\n\t            fn: Function to call.\n\t            fargs: Arguments to pass to function.\n\t        \"\"\"\n\t        def _run(reqid, target, *args, **kwargs):\n\t            try:\n\t                # tlogger = self.logger.enter()\n\t                try:\n\t                    tlogger.debug(f\"_run calling target={target} args={args}\")\n", "                    target(*args)\n\t                    tlogger.lap(f\"target {target} run completed \")\n\t                except ThreadInterrupt as e:\n\t                    tlogger.info(f\"thread interrupted {threading.current_thread()}\")\n\t                except Exception as e:\n\t                    tlogger.debug(f\"_run exception ({traceback.format_exc()}\")\n\t                try:\n\t                    tlogger.debug(f\"removing thread {threading.current_thread()}...\")\n\t                    self.threads.discard(threading.current_thread())\n\t                    self.reqid2thread.pop(reqid, None)\n", "                    tlogger.debug(f\"removed thread {threading.current_thread()}\")\n\t                    if 0:\n\t                        # clean up \"empty\" sessions unless pinned\n\t                        tlogger.debug(\"checking to clean up\")\n\t                        self.session.machine.sessmgr.cleanup(self.session.oid)\n\t                except Exception as e:\n\t                    tlogger.debug(f\"thread cleanup EXCEPTION ({e})\")\n\t                tlogger.debug(f\"releasing runsem ({self.session.oid=})...\")\n\t                self.runsem.release()\n\t                tlogger.debug(f\"release runsem ({self.session.oid=})\")\n", "            except Exception as e:\n\t                self.logger.warning(f\"EXCEPTION ({e})\")\n\t            finally:\n\t                # tlogger.exit()\n\t                pass\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            tlogger.debug(f\"acquiring runsem ({self.session.oid=})...\")\n\t            self.runsem.acquire()\n\t            tlogger.debug(f\"acquired runsem ({self.session.oid=})\")\n", "            _opname, _ctxt, _req = fargs\n\t            reqid = _req.header.get(\"id\")\n\t            sessionid = _ctxt.session.oid\n\t            args = [reqid, fn] + list(fargs)\n\t            th = Thread(target=_run, name=reqid, args=args)\n\t            th.daemon = True\n\t            self.threads.add(th)\n\t            self.reqid2thread[reqid] = th\n\t            th.start()\n\t            # cleanup is done in _run()\n", "        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def schedule(self, ctxt: \"OpContext\", req: \"Message\"):\n\t        \"\"\"Schedule thread to run the requested kernel operation.\n\t        Args:\n\t            ctxt: Context in which to run operation.\n\t            req: Request message.\n\t        \"\"\"\n", "        try:\n\t            tlogger = self.logger.enter()\n\t            opname = req.payload.get(\"op\")\n\t            if opname:\n\t                tlogger.info(f\"opname={opname}\")\n\t                self.run_thread(self.kernel.run, (opname, ctxt, req))\n\t            else:\n\t                tlogger.warning(f\"opname={opname} not found\")\n\t                # TODO: does this hang here?\n\t        except Exception as e:\n", "            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def set_max_threads(self, n: int):\n\t        \"\"\"Set the upper limit of the number of threads to run.\n\t        Updates the `runsem` semaphore to allow acquisition, if\n\t        possible.\n\t        Args:\n\t            n: Maximum number of threads.\n\t        \"\"\"\n", "        try:\n\t            self.max_threads = max(1, n)\n\t            self.runsem.adjust(self.max_threads)\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t    def start(self):\n\t        \"\"\"Start main processor thread.\"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            return\n", "            # TODO: are start()/run() necessary?\n\t            if not self.th:\n\t                self.th = Thread(target=self.run)\n\t                self.th.daemon = True\n\t            self.th.start()\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def state(self) -> \"State\":\n", "        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n\t        \"\"\"\n\t        try:\n\t            return State(\n\t                \"processor\",\n\t                self.oid,\n\t                {\n\t                    \"kernel\": self.kernelname,\n", "                    \"max-threads\": self.max_threads,\n\t                    \"nthreads\": len(self.threads),\n\t                    \"runsem\": {\n\t                        \"_lock-locked\": self.runsem._lock.locked(),\n\t                        \"_waitlock-locked\": self.runsem._waitlock.locked(),\n\t                        \"count\": self.runsem.count(),\n\t                        \"max\": self.runsem.max(),\n\t                    },\n\t                    \"threads\": [th.state() for th in self.threads],\n\t                },\n", "            )\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t    def terminate_thread(self, reqid: str):\n\t        \"\"\"Forcefully terminate a running thread.\n\t        A `ThreadInterrupt` exception is raised for the thread.\n\t        Args:\n\t            reqid: Request id.\n\t        \"\"\"\n\t        try:\n", "            tlogger = self.logger.enter()\n\t            tlogger.info(\"terminating thread ({reqid})\")\n\t            th = self.reqid2thread.get(reqid)\n\t            th.terminate()\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n"]}
{"filename": "src/server/penvm/server/session.py", "chunked_list": ["#\n\t# penvm/server/session.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"\n\tA (server-side) session isolates communication, operations, and\n\tprocessing. Except for special kernel operations which allow for one\n", "session to affect another, there are no inter-session dependencies.\n\tEach session has its own incoming and outgoing message queues.\n\tEach session has and manages its own `Processor` which performs all\n\tsession-related processing.\n\tConcurrency is supported by the `Processor` (dynamically adjustable\n\tnumber of threads) and between sessions. Which means that while\n\tone/some session(s) may be blocked, others may not be.\n\t\"\"\"\n\timport logging\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n", "from penvm.lib.base import BaseObject\n\tfrom penvm.lib.misc import State\n\tfrom penvm.lib.mqueue import MessageQueue\n\tfrom penvm.lib.thread import Thread\n\tfrom penvm.kernels.base.server import OpContext\n\tfrom penvm.server.processor import Processor\n\tlogger = logging.getLogger(__name__)\n\tclass Session(BaseObject):\n\t    \"\"\"Server-side session.\"\"\"\n\t    def __init__(\n", "        self,\n\t        machine: \"Machine\",\n\t        sessionid: str,\n\t        kernelname: str = \"default\",\n\t    ):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            machine: Owning machine.\n\t            sessionid: Session id.\n\t            kernelname: Kernel name.\n", "        \"\"\"\n\t        try:\n\t            super().__init__(sessionid, logger)\n\t            tlogger = self.logger.enter()\n\t            self.machine = machine\n\t            self.exit = False\n\t            # TODO: should session/sessionid be passed to Processor()?\n\t            self.imq = MessageQueue()\n\t            self.omq = MessageQueue()\n\t            self.proc = Processor(self, kernelname)\n", "            self.th = None\n\t            self.pinned = False\n\t        finally:\n\t            tlogger.exit()\n\t    def __repr__(self):\n\t        return f\"<Session id={self.oid} machine={self.machine}>\"\n\t    def is_empty(self) -> bool:\n\t        \"\"\"Return if session is \"empty\", and therefore deletable.\n\t        Returns:\n\t            \"Emptiness\" status.\n", "        \"\"\"\n\t        # TODO: verify that active_count is an appropriate check\n\t        if self.proc.active_count() == 0 and self.imq.size() == 0 and self.omq.size() == 0:\n\t            return True\n\t        return False\n\t    def is_running(self) -> bool:\n\t        \"\"\"Return running status.\n\t        Returns:\n\t            Running status.\n\t        \"\"\"\n", "        return self.th != None\n\t    def run(self):\n\t        \"\"\"Run session.\n\t        Loops until `self.exit` is `False`.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            self.proc.start()\n\t            ctxt = OpContext()\n\t            ctxt.machine = self.machine\n", "            ctxt.processor = self.proc\n\t            ctxt.session = self\n\t            try:\n\t                while not self.exit:\n\t                    tlogger.debug(\"waiting for message ...\")\n\t                    req = self.imq.pop()\n\t                    if req == None:\n\t                        # reject dummy \"message\"\n\t                        continue\n\t                    tlogger.debug(f\"popped message and scheduling ({req.payload.get('op')}) ...\")\n", "                    if self.machine.debug and not self.oid.startswith(\"-debug-\"):\n\t                        self.machine.schedlock.acquire()\n\t                    self.proc.schedule(ctxt, req)\n\t                    tlogger.debug(f\"message scheduled ({req.payload.get('op')})\")\n\t            except Exception as e:\n\t                tlogger.warning(f\"EXCEPTION ({e})\")\n\t                raise\n\t            self.th = None\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n", "        finally:\n\t            tlogger.exit()\n\t    def set_kernel(\n\t        self,\n\t        kernel: \"Kernel\",\n\t    ):\n\t        \"\"\"Set the kernel to use.\n\t        Args:\n\t            kernel: Kernel.\n\t        \"\"\"\n", "        self.logger.debug(\"set kernel\")\n\t        self.proc.kernel = kernel\n\t    def start(self):\n\t        \"\"\"Start the main session thread.\"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            if not self.th:\n\t                try:\n\t                    self.th = Thread(target=self.run)\n\t                    self.th.daemon = True\n", "                    self.th.start()\n\t                except Exception as e:\n\t                    tlogger.debug(f\"failed to start ({e})\")\n\t                    self.th = None\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def stop(self):\n\t        \"\"\"Stop the `run` method running in a thread.\"\"\"\n", "        self.exit = True\n\t        # dummy \"message\" to wake up thread\n\t        self.imq.put(None)\n\t    def state(self) -> \"State\":\n\t        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n\t        \"\"\"\n\t        try:\n\t            return State(\n", "                \"session\",\n\t                self.oid,\n\t                {\n\t                    \"imq\": self.imq.state(),\n\t                    \"nimq\": self.imq.size(),\n\t                    \"nomq\": self.omq.size(),\n\t                    \"omq\": self.omq.state(),\n\t                    \"processor\": self.proc.state(),\n\t                },\n\t            )\n", "        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n"]}
{"filename": "src/server/penvm/server/storage.py", "chunked_list": ["#\n\t# penvm/server/storage.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport logging\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tlogger = logging.getLogger(__name__)\n", "from penvm.lib.base import BaseObject\n\tclass StorageManager(BaseObject):\n\t    \"\"\"Storage manager.\n\t    NIY.\n\t    \"\"\"\n\t    def __init__(self, machine: \"Machine\"):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            machine: Owning machine.\n\t        \"\"\"\n", "        try:\n\t            super().__init__(None, logger)\n\t            tlogger = self.logger.enter()\n\t            self.machine = machine\n\t            self.stores = {}\n\t        finally:\n\t            tlogger.exit()\n\t    def create(self):\n\t        pass\n\t    def delete(\n", "        self,\n\t        storeid: str,\n\t    ):\n\t        \"\"\"Delete by id.\n\t        Args:\n\t            storeid: Store id.\n\t        \"\"\"\n\t        store = self.stores.pop(storeid)\n\t        if store:\n\t            # delete\n", "            pass\n\t    def get(self, storeid: str) -> Any:\n\t        \"\"\"Get object by id.\n\t        Args:\n\t            storeid: Store id.\n\t        Returns:\n\t            Store.\n\t        \"\"\"\n\t        return self.store.get(storeid)\n\t    def list(self) -> List[str]:\n", "        \"\"\"List store ids.\n\t        Returns:\n\t            Store ids.\n\t        \"\"\"\n\t        return self.store.keys()\n\t    def run(self):\n\t        pass\n"]}
{"filename": "src/server/penvm/server/sessionmanager.py", "chunked_list": ["#\n\t# penvm/server/sessionmanager.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"All sessions are managed by `SessionManager`. Creation, removal,\n\tcleanup, and lookups are centrally handled by the `SessionManager`.\n\t\"\"\"\n", "import logging\n\timport threading\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.misc import State\n\tfrom penvm.server.session import Session\n\tlogger = logging.getLogger(__name__)\n\tclass SessionManager(BaseObject):\n\t    \"\"\"Manages server-side sessions.\n\t    All sessions are managed by a SessionManager owned by the machine.\"\"\"\n", "    def __init__(\n\t        self,\n\t        machine: \"Machine\",\n\t    ):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            machine: Owning machine.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(None, logger)\n", "            tlogger = self.logger.enter()\n\t            self.machine = machine\n\t            self.lock = threading.Lock()\n\t            self.sessions = {}\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def cleanup(\n\t        self,\n", "        sessionid: str,\n\t    ):\n\t        \"\"\"Clean up session (if \"empty\").\n\t        Args:\n\t            sessionid: Session id.\n\t        \"\"\"\n\t        try:\n\t            self.lock.acquire()\n\t            sess = self.sessions.get(sessionid)\n\t            if sess and not sess.pinned:\n", "                if sess.is_empty():\n\t                    sess.stop()\n\t                    self.pop(sessionid)\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            self.lock.release()\n\t    def delete(\n\t        self,\n\t        sessionid: str,\n", "    ):\n\t        \"\"\"Delete (forced) a session by session id.\n\t        Args:\n\t            sessionid: Session id.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            sess = self.sessions.pop(sessionid)\n\t            if sess:\n\t                # delete\n", "                pass\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def get(\n\t        self,\n\t        sessionid: str,\n\t    ) -> \"Session\":\n\t        \"\"\"Get a session by session id.\n", "        Args:\n\t            sessionid: Session id.\n\t        Returns:\n\t            Session.\n\t        \"\"\"\n\t        try:\n\t            self.lock.acquire()\n\t            return self.sessions.get(sessionid)\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n", "        finally:\n\t            self.lock.release()\n\t    def list(self) -> List[str]:\n\t        \"\"\"List sessions by session id.\n\t        Returns:\n\t            Session ids.\n\t        \"\"\"\n\t        return list(self.sessions.keys())\n\t    def pop(self, sessionid: str) -> \"Session\":\n\t        \"\"\"Pop a session by session id.\n", "        Args:\n\t            sessionid: Session id.\n\t        Returns:\n\t            Session.\n\t        \"\"\"\n\t        try:\n\t            self.lock.acquire()\n\t            sess = self.sessions.pop(sessionid)\n\t            return sess\n\t        except Exception as e:\n", "            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            self.lock.release()\n\t    def setdefault(\n\t        self,\n\t        sessionid: Union[str, None],\n\t        default: Union[\"Session\", None] = None,\n\t    ) -> \"Session\":\n\t        \"\"\"Get a session (or create new one if not present) by session\n\t        id.\n", "        Args:\n\t            sessionid: Session id.\n\t            default: Session if session not found.\n\t        Returns:\n\t            Session.\n\t        \"\"\"\n\t        try:\n\t            self.lock.acquire()\n\t            session = self.sessions.get(sessionid)\n\t            if not session:\n", "                session = self.sessions[sessionid] = default or Session(self.machine, sessionid)\n\t                session.start()\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            self.lock.release()\n\t        return session\n\t    def start(self):\n\t        \"\"\"Start.\n\t        NOOP. No background threads.\"\"\"\n", "        pass\n\t    def state(self) -> \"State\":\n\t        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n\t        \"\"\"\n\t        try:\n\t            return State(\n\t                \"session-manager\",\n\t                None,\n", "                {\n\t                    \"nsessions\": len(self.sessions),\n\t                    \"session-ids\": self.list(),\n\t                },\n\t            )\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n"]}
{"filename": "src/server/penvm/server/kernelmanager.py", "chunked_list": ["#\n\t# penvm/server/kernelmanager.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"\n\tAll server-side kernels are registered with the manager and accessible\n\tby name.\n", "\"\"\"\n\timport logging\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.misc import State\n\tlogger = logging.getLogger(__name__)\n\tclass KernelManager(BaseObject):\n\t    \"\"\"Manage server-side kernels.\"\"\"\n\t    def __init__(self, machine: \"Machine\"):\n\t        \"\"\"Initialize.\n", "        Args:\n\t            machine: Machine.\n\t        \"\"\"\n\t        super().__init__(None, logger)\n\t        self.machine = machine\n\t        self.kernels = {}\n\t    def drop(self, name: str):\n\t        \"\"\"Drop kernel by name.\n\t        Args:\n\t            name: Kernel name.\n", "        \"\"\"\n\t        self.kernels.pop(name)\n\t    def get(self, name: str) -> \"Kernel\":\n\t        \"\"\"Get kernel by name.\n\t        Args:\n\t            name: Kernel name.\n\t        \"\"\"\n\t        return self.kernels.get(name)\n\t    def list(self) -> List[str]:\n\t        \"\"\"Get list of kernel names.\n", "        Returns:\n\t            Kernel names.\n\t        \"\"\"\n\t        return list(self.kernels.keys())\n\t    def set(self, name: str, kernel: \"Kernel\"):\n\t        \"\"\"Register kernel by name.\n\t        Args:\n\t            name: Kernel name.\n\t            kernel: Kernel.\n\t        \"\"\"\n", "        self.kernels[name] = kernel\n\t    def start(self):\n\t        \"\"\"Start.\n\t        No background threads.\"\"\"\n\t        pass\n\t    def state(self) -> \"State\":\n\t        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n\t        \"\"\"\n", "        try:\n\t            return State(\n\t                \"kernel-manager\",\n\t                None,\n\t                {\n\t                    \"kernel-ids\": self.list(),\n\t                    \"nkernels\": len(self.kernels),\n\t                },\n\t            )\n\t        except Exception as e:\n", "            self.logger.warning(f\"EXCEPTION ({e})\")\n"]}
{"filename": "src/client/penvm/client/world.py", "chunked_list": ["#\n\t# penvm/client/world.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"\n\tThe World object is foundational for defining the set of networks\n\tand machines available to an application. It can be set up in various\n", "ways: configuration, configuration file, network string, environment\n\tvariables. All of these provide flexibility for many use cases.\n\tAn application is associated with a world configuration explicitly\n\t(specific configuration or named configuration file) or implicitly\n\t(environment variable or related .penvm file).\n\tEach running machine instance is defined by a `MachineConnectionSpec`\n\twhich can be represented as a Machine Connection string. A machine\n\tconnection consists of:\n\t* machine id (unique)\n\t* ssl profile (name)\n", "* hostname/address\n\t* port\n\tA network string consists of one or more machine connection strings.\n\t\"\"\"\n\timport concurrent.futures\n\timport os\n\timport os.path\n\timport logging\n\timport subprocess\n\timport sys\n", "import threading\n\timport time\n\timport traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.client.config import WorldConfig\n\tfrom penvm.client.machine import Machine\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.misc import MachineConnectionSpec, get_uuid, get_version_string\n\tlogger = logging.getLogger(__name__)\n\tclass World(BaseObject):\n", "    \"\"\"World of networks and hosts.\n\t    Configuration is taken from:\n\t    1. `config` keyword argument\n\t    1. `networkstr` keyword argument\n\t    1. `filename` keyword argument\n\t    1. `PENVM_AUTO_NETWORK` environment variable\n\t    1. `PENVM_WORLD_FILENAME` environment variable\n\t    1. `<binname>.penvm` found in directory containing executable\n\t    \"\"\"\n\t    def __init__(self, **kwargs):\n", "        \"\"\"Initialize.\n\t        Keyword Args:\n\t            config (dict): Dictionary configuration.\n\t            filename (str): Configuration filename.\n\t            networkstr (str): Network string of machine connection\n\t                strings.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(kwargs.get(\"filename\"), logger)\n\t            tlogger = self.logger.enter()\n", "            self.config = WorldConfig()\n\t            self.networks = {}\n\t            self.filename = None\n\t            # print(f\"{kwargs=}\")\n\t            if kwargs.get(\"config\") != None:\n\t                # print(\"World config\")\n\t                self.config.load_config(kwargs[\"config\"])\n\t            elif kwargs.get(\"networkstr\") != None:\n\t                # print(\"World networkstr\")\n\t                self.load_auto_network(\"default\", kwargs[\"networkstr\"])\n", "            elif kwargs.get(\"filename\") != None:\n\t                # print(\"World filename\")\n\t                self.filename = kwargs[\"filename\"]\n\t                self.config.load(self.filename)\n\t            elif os.environ.get(\"PENVM_AUTO_NETWORK\") != None:\n\t                # print(\"World PENVM_AUTO_NETWORK\")\n\t                self.load_auto_network(\"default\", os.environ.get(\"PENVM_AUTO_NETWORK\"))\n\t            elif os.environ.get(\"PENVM_WORLD_FILENAME\") != None:\n\t                # print(\"World PENVM_WORLD_FILENAME\")\n\t                self.filename = os.environ.get(\"PENVM_WORLD_FILENAME\")\n", "                self.config.load(self.filename)\n\t            else:\n\t                # print(\"World .penvm\")\n\t                filename, ext = os.path.splitext(os.path.basename(sys.argv[0]))\n\t                filename = f\"{os.path.dirname(sys.argv[0])}/{filename}.penvm\"\n\t                # TODO: abspath(filename)?\n\t                if filename and os.path.exists(filename):\n\t                    self.config.load(filename)\n\t                    self.filename = filename\n\t            if self.filename:\n", "                # TODO: is this the right place for this or way to do this?\n\t                self.oid = self.filename\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def get_group_names(self):\n\t        return self.config.get_groups()\n\t    def get_meta(self, name: str) -> Any:\n\t        \"\"\"Get meta(data) value.\n", "        Returns:\n\t            Value.\n\t        \"\"\"\n\t        return self.config.get_meta(name)\n\t    def get_network(self, network_name: str = \"default\") -> \"Network\":\n\t        \"\"\"Get network object by name.\n\t        Args:\n\t            network_name: Network name.\n\t        Returns:\n\t            Network.\n", "        \"\"\"\n\t        network = self.networks.get(network_name)\n\t        if not network:\n\t            netconfig = self.config.get_network(network_name)\n\t            if not netconfig:\n\t                return None\n\t            targets = []\n\t            for target_name in netconfig.get_targets():\n\t                target = self.get_target(target_name)\n\t                if target:\n", "                    targets.append(target)\n\t            network = Network(network_name, targets, netconfig)\n\t            self.networks[network_name] = network\n\t        return network\n\t    def get_networks(self) -> List[\"Network\"]:\n\t        \"\"\"Get networks.\n\t        Return:\n\t            List of networks.\n\t        \"\"\"\n\t        return list(self.networks.values())\n", "    def get_network_names(self) -> List[str]:\n\t        \"\"\"Get network names.\n\t        Return:\n\t            Network names.\n\t        \"\"\"\n\t        return self.config.get_networks()\n\t    def get_target(self, target_name: str) -> \"Target\":\n\t        \"\"\"Get target by name.\n\t        Args:\n\t            target_name: Target name.\n", "        Returns:\n\t            Target.\n\t        \"\"\"\n\t        return Target(target_name, self.config.get_target(target_name))\n\t    def get_target_names(self) -> List[str]:\n\t        \"\"\"Get target names.\n\t        Returns:\n\t            List of target names.\n\t        \"\"\"\n\t        return self.config.get_targets()\n", "    def load_auto_network(self, name: str, networkstr: str):\n\t        \"\"\"Load auto-scheme (predefined, running) network\n\t        The machine connection strings are used to generate a\n\t        configuration for targets (by machid) and a network.\n\t        Args:\n\t            name: Network name.\n\t            networkstr: Network string.\n\t        \"\"\"\n\t        try:\n\t            targets = []\n", "            for machconnstr in networkstr.split():\n\t                mcs = MachineConnectionSpec(machconnstr=machconnstr)\n\t                target_config = {\n\t                    \"machine-id\": mcs.machid,\n\t                    \"scheme\": \"auto\",\n\t                    \"host\": mcs.host,\n\t                    \"port\": mcs.port,\n\t                    \"ssl-profile\": mcs.sslprofile,\n\t                }\n\t                targets.append(mcs.machid)\n", "                self.config.add_target(mcs.machid, target_config)\n\t            net_config = {\n\t                \"targets\": \" \".join(targets),\n\t            }\n\t            self.config.add_network(name, net_config)\n\t        except Exception as e:\n\t            traceback.print_exc()\n\t    def shutdown(self):\n\t        \"\"\"Shut down network.\n\t        Results in machine instances being shut down.\n", "        \"\"\"\n\t        for network in self.get_networks():\n\t            try:\n\t                network.shutdown()\n\t            except Exception as e:\n\t                pass\n\tclass Network(BaseObject):\n\t    \"\"\"Network.\n\t    Encapsulates references to targets and booted machine instances.\n\t    \"\"\"\n", "    def __init__(self, name: str, targets: List[\"Target\"], config: \"NetworkConfig\"):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            name: Network name.\n\t            targets: List of network targets.\n\t            config: Network configuration.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(name, logger)\n\t            tlogger = self.logger.enter()\n", "            self.name = name\n\t            self.targets = targets\n\t            self.config = config\n\t            # augment from net config\n\t            overrides = self.config.get(\"overrides\")\n\t            if overrides:\n\t                for target in self.targets:\n\t                    target.update(overrides)\n\t            self.machines = {}\n\t        finally:\n", "            tlogger.exit()\n\t    def __len__(self):\n\t        return len(self.machines)\n\t    def __str__(self):\n\t        return \" \".join(self.get_machconnstrs())\n\t    def boot(\n\t        self,\n\t        concurrency: Union[int, None] = None,\n\t    ):\n\t        \"\"\"Boot (machines in) network.\n", "        Boots machine instances using target information.\n\t        Boot concurrency (\"boot-concurrency\" configuration\n\t        setting) is: 0: number of targets, 1: serial, > 1\n\t        concurrent. Final minimum is 1. Default is 1.\n\t        Args:\n\t            concurrency: Boot concurrency. Overrides configuration if\n\t                provided.\n\t        \"\"\"\n\t        # TODO: run threaded to improve startup/setup times and smooth\n\t        # out wait/delay/connect times\n", "        try:\n\t            tlogger = self.logger.enter()\n\t            if self.machines:\n\t                # already booted\n\t                return\n\t            if concurrency == None:\n\t                concurrency = self.config.get(\"boot-concurrency\", 1)\n\t                if concurrency == 0:\n\t                    concurrency = len(self.targets)\n\t            concurrency = max(1, concurrency)\n", "            # print(f\"{concurrency=}\")\n\t            if concurrency == 1:\n\t                # sequential boot\n\t                for target in self.targets:\n\t                    self.machines[target.name] = target.boot()\n\t            else:\n\t                # TODO: figure out why terminal gets messed up\n\t                # concurrent boot\n\t                def _boot(target):\n\t                    machine = target.boot()\n", "                    lock.acquire()\n\t                    self.machines[target.name] = machine\n\t                    lock.release()\n\t                    self.logger.debug(f\"booted target ({target.name}) machine ({machine.oid})\")\n\t                    # print(f\"{machine=}\")\n\t                    return machine\n\t                lock = threading.Lock()\n\t                with concurrent.futures.ThreadPoolExecutor(max_workers=concurrency) as executor:\n\t                    # with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:\n\t                    results = {executor.submit(_boot, target) for target in self.targets}\n", "                    for future in concurrent.futures.as_completed(results):\n\t                        # print(f\"{future.result()=}\")\n\t                        pass\n\t            # TODO: launch penvm-server\n\t            # TODO: capture host/addr and port\n\t            # TODO: set up Machines for each\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n", "    def get_machconnspecs(self) -> List[\"MachineConnectionSpec\"]:\n\t        \"\"\"Get `MachineConnectionSpec`s for machines.\n\t        Returns:\n\t            List of `MachineConnectionSpec`s.\n\t        \"\"\"\n\t        return [m.get_machconnspec() for m in self.machines.values()]\n\t    def get_machconnstrs(self) -> List[str]:\n\t        \"\"\"Get machine connection strings for machines.\n\t        Returns:\n\t            List of machine connection strings.\n", "        \"\"\"\n\t        return [m.get_machconnstr() for m in self.machines.values()]\n\t    def get_machine(self, target_name: str) -> \"Machine\":\n\t        \"\"\"Get machine.\n\t        Args:\n\t            target_name (str): Target name.\n\t        Returns:\n\t            Machine for named target.\n\t        \"\"\"\n\t        return self.machines.get(target_name)\n", "    def get_machines(self) -> List[\"Machine\"]:\n\t        \"\"\"Get list of machines for network.\n\t        Returns:\n\t            List of `Machine`s.\n\t        \"\"\"\n\t        return list(self.machines.values())\n\t    def get_machine_names(self) -> List[str]:\n\t        \"\"\"Get list of machine names for network.\n\t        Returns:\n\t            List of machine names.\n", "        \"\"\"\n\t        return list(self.machines.keys())\n\t    def get_targets(self) -> List[\"Target\"]:\n\t        \"\"\"Get targets for network.\n\t        Returns:\n\t            List of Targets.\n\t        \"\"\"\n\t        return self.targets\n\t    def get_target_names(self) -> List[str]:\n\t        \"\"\"Get target names for network.\n", "        Returns:\n\t            List of target names.\n\t        \"\"\"\n\t        return [target.name for target in self.targets]\n\t    def is_alive(self) -> bool:\n\t        \"\"\"Indicate if network is alive, or not.\n\t        Returns:\n\t            `True` or `False`.\n\t        \"\"\"\n\t        return self.machines and True or False\n", "    def shutdown(self):\n\t        \"\"\"Shut down network.\n\t        Request for machines to be shutdown. Clear local tracking\n\t        of machines by network.\n\t        \"\"\"\n\t        self.logger.debug(\"shutdown\")\n\t        for k, machine in self.machines.items()[:]:\n\t            s = machine.get_session()\n\t            s.kernel.machine_shutdown()\n\t            self.machines.pop(k, None)\n", "class Target(BaseObject):\n\t    \"\"\"Target.\"\"\"\n\t    def __init__(self, name: str, config: Union[\"TargetConfiguration\", None] = None):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            name: Target name.\n\t            config: Target configuration.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(name, logger)\n", "            tlogger = self.logger.enter()\n\t            self.name = name\n\t            self.config = config or {}\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def __repr__(self):\n\t        # url = self.config.get(\"url\") if self.config else \"\"\n\t        scheme = self.config.get(\"scheme\")\n", "        host = self.config.get(\"host\")\n\t        port = self.config.get(\"port\")\n\t        user = self.config.get(\"user\")\n\t        return f\"<Target name={self.name} scheme={scheme} host={host} port={port} user={user}>\"\n\t    def boot(self):\n\t        \"\"\"Boot machine on target.\n\t        Spawns `penvm-server` processes for each target.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n", "            scheme = self.config.get(\"scheme\")\n\t            host = self.config.get(\"host\")\n\t            port = self.config.get(\"port\")\n\t            user = self.config.get(\"user\")\n\t            sslprofile = self.config.get(\"ssl-profile\")\n\t            # assign unique machine id\n\t            machineid = self.config.get(\"machine-id\", get_uuid())\n\t            serverpath = f\".penvm/releases/{get_version_string()}/penvm-server\"\n\t            t0 = time.time()\n\t            if scheme == \"auto\":\n", "                pass\n\t            else:\n\t                if scheme == \"ssh\":\n\t                    spargs = [\n\t                        \"ssh\",\n\t                        host,\n\t                        # \"-T\",\n\t                        \"-tt\",\n\t                        \"-x\",\n\t                    ]\n", "                    if user:\n\t                        spargs.extend([\"-l\", user])\n\t                    if port:\n\t                        spargs.extend([\"-p\", port])\n\t                elif scheme == \"local\":\n\t                    serverpath = os.path.expanduser(f\"~/{serverpath}\")\n\t                    spargs = []\n\t                else:\n\t                    return\n\t                spargs.extend(\n", "                    [\n\t                        \"python3\",\n\t                        serverpath,\n\t                        \"--machineid\",\n\t                        machineid,\n\t                        \"--announce\",\n\t                        \"--background\",\n\t                        \"--firstwait\",\n\t                        # \"15\",\n\t                        \"5\",\n", "                    ]\n\t                )\n\t                if sslprofile:\n\t                    spargs.extend([\"--ssl-profile\", sslprofile])\n\t                spargs.append(host)\n\t                tlogger.debug(\"booting server ...\")\n\t                tlogger.debug(f\"boot args={spargs}\")\n\t                # print(f\"boot args={spargs}\")\n\t                cp = subprocess.run(\n\t                    spargs,\n", "                    stdin=subprocess.DEVNULL,\n\t                    capture_output=True,\n\t                    text=True,\n\t                    cwd=\"/\",\n\t                    timeout=5,\n\t                )\n\t                if cp.returncode != 0:\n\t                    tlogger.debug(f\"boot failed returncode={cp.returncode} stderr={cp.stderr}\")\n\t                t1 = time.time()\n\t                # tlogger.debug(f\"machine booted elapsed ({t1-t0})\")\n", "            # set up Machine info\n\t            try:\n\t                # print(f\"{scheme=}\")\n\t                # print(f\"{self.config=}\")\n\t                if scheme == \"auto\":\n\t                    mcs = MachineConnectionSpec(config=self.config)\n\t                else:\n\t                    # print(f\"{cp.stdout=}\")\n\t                    # print(f\"{cp.stderr=}\")\n\t                    if not cp.stdout.startswith(\"announce::\"):\n", "                        raise Exception(\n\t                            f\"could not get penvm-server information ({cp.stderr}). (is penvm-server deployed?)\"\n\t                        )\n\t                    # trim announcement\n\t                    s = cp.stdout[10:]\n\t                    mcs = MachineConnectionSpec(machconnstr=s)\n\t                for _ in range(10):\n\t                    # TODO: be smart about `sleep`/waiting for remote readiness\n\t                    if scheme != \"auto\":\n\t                        time.sleep(0.05)\n", "                    tlogger.debug(f\"machine announcement received machineconnectionstr={mcs}\")\n\t                    tlogger.debug(\"creating Machine ...\")\n\t                    mach = Machine(\n\t                        mcs.host,\n\t                        mcs.port,\n\t                        mcs.sslprofile,\n\t                        mcs.machid,\n\t                    )\n\t                    if mach:\n\t                        mach.start()\n", "                        break\n\t                t1 = time.time()\n\t                tlogger.debug(f\"machine created elapsed ({t1-t0})\")\n\t                if mach:\n\t                    # set up sessions\n\t                    sessions = self.config.get(\"sessions\")\n\t                    if sessions:\n\t                        sess = mach.get_session(\"_\")\n\t                        for sessionid, session in sessions.items():\n\t                            kernelname = session.get(\"kernel\")\n", "                            maxthreads = session.get(\"max-threads\")\n\t                            if kernelname != None:\n\t                                tlogger.debug(\n\t                                    f\"session ({sessionid}) setting kernel ({kernelname})\"\n\t                                )\n\t                                sess.kernel.session_use_kernel(kernelname, sessionid=sessionid)\n\t                            if maxthreads != None:\n\t                                tlogger.debug(\n\t                                    f\"session ({sessionid}) setting max threads ({maxthreads})\"\n\t                                )\n", "                                sess.kernel.session_set_max_threads(\n\t                                    maxthreads, sessionid=sessionid\n\t                                )\n\t                    # load assets\n\t                    pass\n\t                return mach\n\t            except Exception as e:\n\t                raise\n\t        finally:\n\t            tlogger.exit()\n", "    def update(self, config: dict):\n\t        \"\"\"Update configuration.\n\t        Args:\n\t            config: Configuration.\n\t        \"\"\"\n\t        self.config.update(config)\n"]}
{"filename": "src/client/penvm/client/config.py", "chunked_list": ["#\n\t# penvm/client/config.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Collection of configuration support, mostly used in\n\t[penvm.client.world][].\n\t\"\"\"\n", "import copy\n\timport itertools\n\timport logging\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\timport yaml\n\tlogger = logging.getLogger(__name__)\n\tdef expand_range(s: str) -> str:\n\t    \"\"\"Expand range settings in string.\n\t    Uses Python style range: `<start>:<end>:<step>`.\n\t    Deprecated.\n", "    Args:\n\t        s (str): Range string to expand.\n\t    Returns:\n\t        List of expanded ranges.\n\t    \"\"\"\n\t    l = []\n\t    # print(f\"expand_range ({s=})\")\n\t    while s:\n\t        if \"[\" in s:\n\t            i = s.find(\"[\")\n", "            ii = s.find(\"]\")\n\t            l.append([s[:i]])\n\t            start, end, *rest = s[i + 1 : ii].split(\":\")\n\t            step = rest[0] if rest else \"1\"\n\t            sz = min(map(len, [start, end]))\n\t            start, end, step = int(start), int(end), int(step)\n\t            l.append(srange(start, end, step, sz))\n\t            s = s[ii + 1 :]\n\t        else:\n\t            l.append([s])\n", "            s = \"\"\n\t    return [\"\".join(t) for t in itertools.product(*l)]\n\tdef expand_range(s: str) -> List[str]:\n\t    \"\"\"Expand numbered, comma-separated ranges.\n\t    Supported formats are:\n\t    * &lt;start>-&lt;end>\n\t    * &lt;single>\n\t    Leading 0s set width of resulting numbers (e.g., 001 for a width\n\t    of three digits).\n\t    Args:\n", "        s (str): Formatted string.\n\t    Returns:\n\t        List of expanded ranges.\n\t    \"\"\"\n\t    l = []\n\t    while s:\n\t        if \"[\" in s:\n\t            i = s.find(\"[\")\n\t            ii = s.find(\"]\")\n\t            l.append([s[:i]])\n", "            ll = []\n\t            segment = s[i + 1 : ii]\n\t            chunks = segment.split(\",\")\n\t            for chunk in chunks:\n\t                chunk = chunk.strip()\n\t                if \"-\" in chunk:\n\t                    first, last = chunk.split(\"-\")\n\t                    sz = min(map(len, [first, last]))\n\t                    first, last = int(first), int(last)\n\t                    ll.extend(list(srange(first, last + 1, 1, sz)))\n", "                else:\n\t                    ll.append(chunk)\n\t            l.append(ll)\n\t            s = s[ii + 1 :]\n\t        else:\n\t            l.append([s])\n\t            s = \"\"\n\t    return [\"\".join(t) for t in itertools.product(*l)]\n\tdef listify_targets(s: str) -> List[str]:\n\t    \"\"\"Expand targets settings.\n", "    Args:\n\t        s: String of targets/target ranges.\n\t    Returns:\n\t        List of expanded ranges.\n\t    \"\"\"\n\t    l = []\n\t    for name in s.split():\n\t        l.extend(expand_range(name))\n\t    return l\n\tdef expand_value(v: str, d: dict) -> str:\n", "    \"\"\"Expand/resolve value using dictionary.\n\t    Resolvable items are specified using the `str.format`.\n\t    Args:\n\t        v: Regular or format string.\n\t        d: Dictionary used to resolve format string.\n\t    Returns:\n\t        Resolved \"value\".\n\t    \"\"\"\n\t    if type(v) == str:\n\t        return v.format(**d)\n", "    return v\n\tdef srange(start: int, end: int, step: int, sz: str):\n\t    \"\"\"\n\t    Args:\n\t        start: Start value.\n\t        end: End value.\n\t        step: Step value.\n\t        sz: Field width.\n\t    Yields:\n\t        (str): Range value.\n", "    \"\"\"\n\t    fmt = \"%%0.%dd\" % (sz,)\n\t    for v in range(start, end, step):\n\t        yield fmt % v\n\tclass WorldConfig:\n\t    \"\"\"World configuation.\n\t    Provide high-level methods for working with the world\n\t    configuration file. This is normally used only by\n\t    [penvm.client.world.World][].\n\t    \"\"\"\n", "    def __init__(self):\n\t        \"\"\"Initialize.\"\"\"\n\t        self.groups = {}\n\t        self.meta = {}\n\t        self.networks = {}\n\t        self.targets = {}\n\t        self.templates = {}\n\t    def __repr__(self):\n\t        return f\"<WorldConfig nnetworks={len(self.networks)}  ngroups={len(self.groups)} ntargets={len(self.targets)}>\"\n\t    def add_group(self, name: str, config: dict):\n", "        \"\"\"Add group.\n\t        Args:\n\t            name: Group name.\n\t            config: Configuration.\n\t        \"\"\"\n\t        self.groups[name] = GroupConfig(self, name, config)\n\t    def add_meta(self, config: dict):\n\t        \"\"\"Add meta(data).\n\t        Args:\n\t            config: Configuration.\n", "        \"\"\"\n\t        self.meta.update(config)\n\t    def add_network(self, name: str, config: dict):\n\t        \"\"\"Add network.\n\t        Args:\n\t            name: Network name.\n\t            config: Configuration.\n\t        \"\"\"\n\t        self.networks[name] = NetworkConfig(self, name, config)\n\t    def add_target(self, name: str, config: dict):\n", "        \"\"\"Add target.\n\t        Args:\n\t            name: Target name.\n\t            config: Configuration.\n\t        \"\"\"\n\t        self.targets[name] = TargetConfig(self, name, config)\n\t    def add_template(self, name: str, config: dict):\n\t        \"\"\"Add template.\n\t        Args:\n\t            name: Template name.\n", "            config: Configuration.\n\t        \"\"\"\n\t        template = self.templates[name] = TemplateConfig(self, name, config)\n\t        template.run()\n\t    def clear(self):\n\t        \"\"\"Clear configuration.\"\"\"\n\t        self.networks = {}\n\t        self.groups = {}\n\t        self.targets = {}\n\t        self.templates = {}\n", "        self.meta = {}\n\t    def load(self, path: str):\n\t        \"\"\"Load configuration from a file.\n\t        Args:\n\t            path: File path.\n\t        \"\"\"\n\t        try:\n\t            d = yaml.safe_load(open(path, \"r\"))\n\t        except Exception as e:\n\t            print(f\"failed to load world file ({e})\")\n", "            raise\n\t        self.load_config(d)\n\t    def load_config(self, d: dict):\n\t        \"\"\"Load configuration from a dictionary.\n\t        Args:\n\t            d: Configuration.\n\t        \"\"\"\n\t        self.add_meta(d.get(\"meta\", {}))\n\t        for name, config in d.get(\"templates\", {}).items():\n\t            self.add_template(name, config)\n", "        for name, config in d.get(\"targets\", {}).items():\n\t            self.add_target(name, config)\n\t        for name, config in d.get(\"groups\", {}).items():\n\t            self.add_group(name, config)\n\t        for name, config in d.get(\"networks\", {}).items():\n\t            self.add_network(name, config)\n\t    def get_group(self, name: str) -> \"GroupConfig\":\n\t        \"\"\"Get group.\n\t        Args:\n\t            name: Group name.\n", "        Returns:\n\t            Group confguration object.\n\t        \"\"\"\n\t        return self.groups.get(name)\n\t    def get_groups(self) -> List[str]:\n\t        \"\"\"Get group names.\n\t        Returns:\n\t            List of group names.\n\t        \"\"\"\n\t        return self.groups.keys()\n", "    def get_meta(self, name: str) -> Any:\n\t        \"\"\"Get meta(data).\n\t        Args:\n\t            name: Metadata item name.\n\t        Returns:\n\t            Metadata item value.\n\t        \"\"\"\n\t        return self.meta.get(name)\n\t    def get_network(self, name: str) -> \"NetworkConfig\":\n\t        \"\"\"Get network configuration.\n", "        Args:\n\t            name: Network name.\n\t        Returns:\n\t            Network configuration object.\n\t        \"\"\"\n\t        return self.networks.get(name)\n\t    def get_networks(self) -> List[str]:\n\t        \"\"\"Get network names.\n\t        Returns:\n\t            List of network names.\n", "        \"\"\"\n\t        return self.networks.keys()\n\t    def get_target(self, name: str) -> \"TargetConfig\":\n\t        \"\"\"Get target.\n\t        Args:\n\t            name (str): Target name.\n\t        Returns:\n\t            Target configuration object.\n\t        \"\"\"\n\t        return self.targets.get(name)\n", "    def get_targets(self) -> List[str]:\n\t        \"\"\"Get target names.\n\t        Returns:\n\t            List of target names.\n\t        \"\"\"\n\t        return self.targets.keys()\n\tclass BaseConfig:\n\t    \"\"\"Base configuration.\n\t    Provides standard methods: `add`, `get`, `update`.\"\"\"\n\t    def __init__(self, world: \"WorldConfig\", name: str, config: Union[dict, None] = None):\n", "        \"\"\"Initialize.\n\t        Args:\n\t            world: World configuration object.\n\t            name: Configuration name.\n\t            config: Configuration.\n\t        \"\"\"\n\t        self.world = world\n\t        self.config = {\"name\": name}\n\t        if config:\n\t            for k, v in config.items():\n", "                self.add(k, v)\n\t    def add(self, k: Any, v: Any):\n\t        \"\"\"Add key+value.\n\t        Args:\n\t            k: Key.\n\t            v: Value.\n\t        \"\"\"\n\t        if k == \"targets\":\n\t            targets = listify_targets(v)\n\t            v = \" \".join(targets)\n", "        self.config[k] = v\n\t    def get(self, k: Any, default: Any = None) -> Any:\n\t        \"\"\"Get value for key.\n\t        Args:\n\t            k: Key.\n\t            default: Default value if key is not found.\n\t        Returns:\n\t            Value for key.\n\t        \"\"\"\n\t        return self.config.get(k, default)\n", "    def update(self, config: dict):\n\t        \"\"\"Update configuration.\n\t        Args:\n\t            config: Configuration.\n\t        \"\"\"\n\t        self.config.update(config)\n\tclass GroupConfig(BaseConfig):\n\t    \"\"\"Group configuration.\"\"\"\n\t    def __repr__(self):\n\t        return f\"<GroupConfig name={self.config['name']} config={self.config}>\"\n", "    def get_targets(self) -> List[\"TargetConfig\"]:\n\t        \"\"\"Get target configuration objects.\n\t        Returns:\n\t            List of Target configuration objects.\n\t        \"\"\"\n\t        targets = []\n\t        for target in listify_targets(self.config.get(\"targets\", \"\")):\n\t            targets.extend(target)\n\t        return targets\n\tclass NetworkConfig(BaseConfig):\n", "    \"\"\"Network configuration.\"\"\"\n\t    def __repr__(self):\n\t        return f\"<NetworkConfig name={self.config['name']} config={self.config}>\"\n\t    def get_targets(self) -> List[\"TargetConfig\"]:\n\t        \"\"\"Get target configuration objects.\n\t        Returns:\n\t            List of Target configuration objects.\n\t        \"\"\"\n\t        targets = []\n\t        for target in listify_targets(self.config.get(\"targets\", \"\")):\n", "            if target.startswith(\"@\"):\n\t                group = self.world.groups.get(target[1:])\n\t                if group:\n\t                    targets.extend(group.get_targets())\n\t            else:\n\t                targets.append(target)\n\t        return targets\n\tclass TargetConfig(BaseConfig):\n\t    \"\"\"Target configuration.\"\"\"\n\t    def __init__(self, *args, **kwargs):\n", "        \"\"\"Initialize.\"\"\"\n\t        super().__init__(*args, **kwargs)\n\t        self.config[\"host\"] = self.config.get(\"host\", self.config.get(\"name\"))\n\t    def __repr__(self):\n\t        return f\"<TargetConfig name={self.config['name']} config={self.config}>\"\n\tclass TemplateConfig(BaseConfig):\n\t    \"\"\"Template configuration.\"\"\"\n\t    def run(self):\n\t        \"\"\"Add target configurations based on template.\n\t        Automatic substitution for `$target` is done for`host`,\n", "        `machine-id` with target name.\n\t        \"\"\"\n\t        targets = self.config.get(\"targets\")\n\t        for name in listify_targets(targets):\n\t            config = copy.deepcopy(self.config)\n\t            config[\"name\"] = name\n\t            if config.get(\"host\") == \"$target\":\n\t                config[\"host\"] = name\n\t            if config.get(\"machine-id\") == \"$target\":\n\t                config[\"machine-id\"] = name\n", "            config.pop(\"targets\")\n\t            self.world.add_target(name, config)\n"]}
{"filename": "src/client/penvm/client/machine.py", "chunked_list": ["#\n\t# penvm/client/machine.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport importlib\n\timport logging\n\timport threading\n", "import traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.client.session import Session\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.connection import ClientConnection\n\tfrom penvm.lib.misc import MachineConnectionSpec\n\tfrom penvm.lib.mqueue import MessageQueue\n\tfrom penvm.lib.queue import RoutingQueue\n\tlogger = logging.getLogger(__name__)\n\tclass Machine(BaseObject):\n", "    \"\"\"Client-side representation of a server-side machine.\"\"\"\n\t    def __init__(\n\t        self,\n\t        host: str,\n\t        port: int,\n\t        sslprofile: Union[str, None] = None,\n\t        machineid: Union[str, None] = None,\n\t    ):\n\t        \"\"\"Initialize.\n\t        Set up client-side machine representation.\n", "        Args:\n\t            host: Host address.\n\t            port: Port.\n\t            sslprofile: SSL profile for SSL context.\n\t            machineid: Machine id. Generated if not provided.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(machineid, logger)\n\t            tlogger = self.logger.enter()\n\t            self.sslprofile = sslprofile\n", "            self.sslcontext = self.get_sslcontext(self.sslprofile)\n\t            self.conn = ClientConnection(self, host, port, self.sslcontext)\n\t            self.conn.connect()\n\t            # time.sleep(0.5)\n\t            self.conn.start()\n\t            self.exit = False\n\t            self.imq = RoutingQueue(put=self.imq_put)\n\t            if self.conn:\n\t                self.omq = RoutingQueue(put=self.omq_put)\n\t            else:\n", "                # for testing without a connection\n\t                self.omq = MessageQueue()\n\t            self.lock = threading.Lock()\n\t            self.kernels = {}\n\t            self.sessions = {}\n\t            # standard kernels\n\t            self.load_kernel(\"core\", \"penvm.kernels.core\")\n\t            self.load_kernel(\"default\", \"penvm.kernels.default\")\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n", "        finally:\n\t            tlogger.exit()\n\t    def __repr__(self):\n\t        return f\"<Machine id={self.oid} conn={self.conn} nsessions={len(self.sessions)}>\"\n\t    def get_debug_session(self, sessionid: str = None) -> \"Session\":\n\t        \"\"\"Get debug-specific session.\n\t        Debug sessions (should) start with \"-debug-\". They are treated\n\t        specially by machines: they are not subject to the debug mode.\n\t        Args:\n\t            sessionid: Session id (suffix) for a debug session.\n", "        Returns:\n\t            Session for debugging.\n\t        \"\"\"\n\t        return self.get_session(\"\"\"-debug-{sessionid or \"\"}\"\"\")\n\t    def get_kernel_class(self, kernel_name: str) -> Type[\"KernelClient\"]:\n\t        \"\"\"Get kernel client class.\n\t        Args:\n\t            kernel_name: Kernel name.\n\t        Returns:\n\t            Kernel client class for `kernel_name`.\n", "        \"\"\"\n\t        return self.kernels.get(kernel_name)\n\t    def get_machconnspec(self) -> MachineConnectionSpec:\n\t        \"\"\"Get `MachineConnectionSpec` object for this machine.\n\t        Returns:\n\t            `MachineConnectionSpec` of object for this machine.\n\t        \"\"\"\n\t        return MachineConnectionSpec(machine=self)\n\t    def get_machconnstr(self) -> str:\n\t        \"\"\"Get machine connection string for this machine.\n", "        Returns:\n\t            Machine connection string.\n\t        \"\"\"\n\t        return str(self.get_machconnspec())\n\t    def get_session(\n\t        self, sessionid: Union[str, None] = None, kernelname: str = \"default\"\n\t    ) -> \"Session\":\n\t        \"\"\"Get session.\n\t        Args:\n\t            sessionid: Session id. Generated if not provided.\n", "            kernelname: Kernel name.\n\t        Returns:\n\t            New `Session` for `sessionid` and `kernelname`.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            tlogger.debug(f\"getting session for sessionid={sessionid}\")\n\t            # lock\n\t            self.lock.acquire()\n\t            try:\n", "                kernelcls = self.get_kernel_class(kernelname)\n\t                if kernelcls == None:\n\t                    tlogger.debug(f\"kernel ({kernelname}) not found\")\n\t                    return\n\t                session = self.sessions.get(sessionid) if sessionid != None else None\n\t                if session == None:\n\t                    session = Session(self, sessionid, kernelcls)\n\t                    session = self.sessions.setdefault(session.oid, session)\n\t            finally:\n\t                self.lock.release()\n", "            return session\n\t        finally:\n\t            tlogger.exit()\n\t    def get_sslcontext(self, sslprofile: str) -> \"SSLContext\":\n\t        \"\"\"Load client-side SSLContext based on named ssl profile.\n\t        Args:\n\t            sslprofile (str): SSL profile name.\n\t        Returns:\n\t            `SSLContext` for ssl profile.\n\t        \"\"\"\n", "        if sslprofile:\n\t            try:\n\t                import ssl\n\t                sslcontext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n\t                sslcontext.check_hostname = False\n\t                sslcontext.verify_mode = ssl.CERT_NONE\n\t                return sslcontext\n\t            except Exception as e:\n\t                logger.debug(f\"ssl required but missing for ssl profile ({sslprofile})\")\n\t                raise Exception(f\"ssl required but missing for ssl profile ({sslprofile})\")\n", "    def imq_put(self, msg: \"Message\"):\n\t        \"\"\"Put a message on the IMQ.\n\t        Args:\n\t            msg: Message object.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            sessionid = msg.header.get(\"session-id\")\n\t            tlogger.debug(f\"imq_put sessionid={sessionid}\")\n\t            sess = self.sessions.get(sessionid)\n", "            if sess:\n\t                sess.imq.put(msg)\n\t            else:\n\t                # DROP!\n\t                tlogger.debug(\"imp_put dropping message\")\n\t        finally:\n\t            tlogger.exit()\n\t    def list_kernels(self) -> List[str]:\n\t        \"\"\"Get list of kernel names.\n\t        Returns:\n", "            List of kernel names.\n\t        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            return list(self.kernels.keys())\n\t        finally:\n\t            tlogger.exit()\n\t    def load_assets(self, assets):\n\t        \"\"\"Load/copy assets to the machines.\n\t        NIY.\n", "        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t        finally:\n\t            tlogger.exit()\n\t    def load_kernel(self, kernel_name: str, pkgname: str) -> \"KernelClient\":\n\t        \"\"\"Load/copy kernel to the machine.\n\t        Kernel support is provided as:\n\t        ```\n\t            <pkg>/\n", "              client.py\n\t                KernelClient\n\t              server.py\n\t                Kernel\n\t        ```\n\t        Args:\n\t            kernel_name: Kernel name.\n\t            pkgname: Package name (as a string).\n\t        Returns:\n\t            Kernel client class.\n", "        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            if kernel_name in self.kernels:\n\t                # TODO: test? allow overwrite for now?\n\t                pass\n\t            try:\n\t                mod = importlib.import_module(\".client\", pkgname)\n\t                cls = getattr(mod, \"KernelClient\")\n\t                self.kernels[kernel_name] = cls\n", "            except Exception as e:\n\t                pass\n\t            # TODO: send kernel to machine (server side)\n\t            return cls\n\t        finally:\n\t            tlogger.exit()\n\t    def omq_put(self, msg: \"Message\"):\n\t        \"\"\"Put a message on the OMQ.\n\t        Args:\n\t            msg: Message to enqueue.\n", "        \"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n\t            self.conn.omq.put(msg)\n\t        finally:\n\t            tlogger.exit()\n\t    def start(self):\n\t        \"\"\"Start machine.\"\"\"\n\t        try:\n\t            tlogger = self.logger.enter()\n", "            if 0 and self.conn:\n\t                self.conn.connect()\n\t                self.conn.start()\n\t        finally:\n\t            tlogger.exit()\n\t    def stop(self):\n\t        \"\"\"Stop machine.\n\t        Set `exit` attribute to signal machine should exit.\n\t        \"\"\"\n\t        try:\n", "            tlogger = self.logger.enter()\n\t            self.exit = True\n\t        finally:\n\t            tlogger.exit()\n"]}
{"filename": "src/client/penvm/client/session.py", "chunked_list": ["#\n\t# penvm/client/session.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"A client-side session is used to interact with a machine. Each\n\tsession has its own unique session id, specified on the client side.\n\tAny number of concurrent sessions are supported, subject to resource\n", "limits.\n\tEach client-side session has its own incoming and outgoing message\n\tqueues (not the same as those on the server side but related). All\n\tcommunication is mediated with these message queues with forwarding\n\tto and from handle automatically (see\n\t[penvm.lib.connection][]).\n\tConvenience methods are provided for interacting at a high level\n\twith the message queues (e.g., `Session.get_response()`).\n\tEach client-side session is set up with access to a selected,\n\tsession-specific, client-side kernel interface. Although not\n", "absolutely required, this interface is highly recommended to provide\n\ta function-style interface rather than having to build a `Request`\n\tmessage.\n\tSee [penvm.server.session][] for details.\n\t\"\"\"\n\timport logging\n\tfrom pathlib import Path\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.message import Request\n", "from penvm.lib.mqueue import MessageQueue\n\tlogger = logging.getLogger(__name__)\n\tclass Session(BaseObject):\n\t    \"\"\"Client-side session object.\n\t    Provides unique sessionid and access to client-side machine services.\n\t    Low-level methods return the request object. This allows for tracking and\n\t    followup of a session.\n\t    High-level methods return None.\n\t    \"\"\"\n\t    def __init__(\n", "        self,\n\t        machine: \"Machine\",\n\t        sessionid: Union[str, None] = None,\n\t        kernelcls: Type[\"KernelClient\"] = None,\n\t    ):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            machine: Machine owning this session.\n\t            sessionid: Session id.\n\t            kernelcls: `KernelClient` class.\n", "        \"\"\"\n\t        try:\n\t            super().__init__(sessionid, logger)\n\t            tlogger = self.logger.enter()\n\t            self.machine = machine\n\t            self.imq = MessageQueue()\n\t            self.kernel = kernelcls(self)\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n", "            tlogger.exit()\n\t    def __repr__(self):\n\t        return f\"<Session id={self.oid} machine={self.machine}>\"\n\t    def get_response(self) -> \"Message\":\n\t        \"\"\"Pull (from remote) and pop from local and return.\n\t        Returns:\n\t            Response message.\n\t        \"\"\"\n\t        self.pull_response()\n\t        return self.pop_response()\n", "    def new_request(self, op: str, d: Union[dict, None] = None) -> \"Message\":\n\t        \"\"\"Return session-specific Request object with `op`.\n\t        Args:\n\t            op: Operation name.\n\t            d: Request payload settings.\n\t        Returns:\n\t            Created request.\n\t        \"\"\"\n\t        req = Request()\n\t        req.header[\"session-id\"] = self.oid\n", "        req.payload[\"op\"] = op\n\t        if d != None:\n\t            req.payload.update(d)\n\t        return req\n\t    def newput_request(self, op: str, d: Union[dict, None] = None) -> \"Message\":\n\t        \"\"\"Create request and *put it out* to be sent.\n\t        Args:\n\t            op: Operation name.\n\t            d: Request payload settings.\n\t        Returns:\n", "            Created request.\n\t        \"\"\"\n\t        req = self.new_request(op, d)\n\t        return self.put_request(req)\n\t    def pop_response(self) -> \"Message\":\n\t        \"\"\"Pop response from local and return.\n\t        Returns:\n\t            Response message.\n\t        \"\"\"\n\t        return self.imq.pop()\n", "    def pull_response(self, sessionid: Union[str, None] = None):\n\t        \"\"\"Pull (pop from remote to local) response.\n\t        Args:\n\t            sessionid: Session id.\n\t        \"\"\"\n\t        self.kernel.session_pop_omq(sessionid)\n\t    def put_request(self, req: \"Message\") -> \"Message\":\n\t        \"\"\"Put the request on the machine OMQ. Return it, also.\n\t        Args:\n\t            req: Request message.\n", "        Returns:\n\t            The Request message, itself.\n\t        \"\"\"\n\t        self.machine.omq.put(req)\n\t        return req\n"]}
{"filename": "src/kernels/penvm/kernels/base/client.py", "chunked_list": ["#\n\t# penvm/kernels/base/client.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Client-side base kernel support.\"\"\"\n\timport logging\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n", "from penvm.lib.base import BaseObject\n\tlogger = logging.getLogger(__name__)\n\tclass KernelClient(BaseObject):\n\t    \"\"\"Base kernel client.\n\t    Provides name/oid and logger setup.\n\t    \"\"\"\n\t    name = \"base\"\n\t    def __init__(\n\t        self,\n\t        session: \"Session\",\n", "    ):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            session: Owning session.\n\t        \"\"\"\n\t        try:\n\t            super().__init__(self.name, logger)\n\t            tlogger = self.logger.enter()\n\t            self.session = session\n\t        except Exception as e:\n", "            self.logger.warning(f\"EXCEPTION ({e})\")\n\t        finally:\n\t            tlogger.exit()\n\t    def __repr__(self):\n\t        return f\"<KernelClient name={self.name}>\"\n"]}
{"filename": "src/kernels/penvm/kernels/base/__init__.py", "chunked_list": ["# blocks changes to this package\n"]}
{"filename": "src/kernels/penvm/kernels/base/server.py", "chunked_list": ["#\n\t# penvm/kernels/base/server.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Server-side base Kernel, Op, and OpContext support.\"\"\"\n\timport importlib.util\n\timport logging\n", "import time\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.base import BaseObject\n\tfrom penvm.lib.misc import State\n\tfrom penvm.lib.message import Message\n\tlogger = logging.getLogger(__name__)\n\tclass Kernel(BaseObject):\n\t    \"\"\"Base kernel.\n\t    Provides base functionality for working with the kernel.\n\t    \"\"\"\n", "    name = \"base\"\n\t    def __init__(self):\n\t        \"\"\"Initialize.\"\"\"\n\t        try:\n\t            super().__init__(self.name, logger)\n\t            tlogger = self.logger.enter()\n\t            self.updated = False\n\t            self.ops = {}\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n", "        finally:\n\t            tlogger.exit()\n\t    def copy(self):\n\t        \"\"\"Deep copy of this kernel.\"\"\"\n\t        return copy.deepcopy(self)\n\t    def get_bases(self):\n\t        \"\"\"Bases (MRO) for kernel.\"\"\"\n\t        return self.__class__.__mro__\n\t    def list(self):\n\t        \"\"\"List operation names.\"\"\"\n", "        return list(self.ops.keys())\n\t    def register(\n\t        self,\n\t        opname: str,\n\t        op: \"Op\",\n\t    ):\n\t        \"\"\"Register operation.\n\t        Args:\n\t            opname: Operation name.\n\t            op: Op reference.\n", "        \"\"\"\n\t        self.updated = True\n\t        self.ops[opname] = op\n\t    def register_code(\n\t        self,\n\t        opname: str,\n\t        opclassname: str,\n\t        code: str,\n\t    ):\n\t        \"\"\"Register an op by code (in a string).\n", "        Args:\n\t            opname: Operation name.\n\t            opclassname: Class name in code snippet.\n\t            code: Code snippet.\n\t        \"\"\"\n\t        try:\n\t            spec = importlib.util.spec_from_loader(\"ext\", loader=None)\n\t            ext = importlib.util.module_from_spec(spec)\n\t            exec(code, ext.__dict__)\n\t            cls = getattr(ext, opclassname)\n", "            if cls:\n\t                op = cls()\n\t                if hasattr(op, \"run\"):\n\t                    self.ops[opname] = cls()\n\t                    self.logger.debug(f\"ops ({list(self.ops.keys())} {cls=}\")\n\t                    self.logger.debug(\"register code succeeded\")\n\t                else:\n\t                    self.logger.debug(\"register class has no run method\")\n\t            else:\n\t                self.logger.debug(f\"class {opclassname} not found in code\")\n", "        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION register code failed {e}\")\n\t    def run(\n\t        self,\n\t        opname: str,\n\t        ctxt: \"OpContext\",\n\t        req: \"Message\",\n\t    ):\n\t        \"\"\"Run the op for `opname`.\n\t        As a *convenience*, a response return value is put into the\n", "        `session.omq`.\n\t        Args:\n\t            opname: Operation to run, referenced by name.\n\t            ctxt: Context to provide operation.\n\t            req: Request message to provide operation.\n\t        \"\"\"\n\t        t0 = time.time()\n\t        resp = self.run_local(opname, ctxt, req)\n\t        if isinstance(resp, Message):\n\t            t1 = time.time()\n", "            resp.payload[\"-oprun-elapsed\"] = t1 - t0\n\t            ctxt.session.omq.put(resp)\n\t        else:\n\t            if opname not in self.ops:\n\t                self.logger.error(f\"run opname={opname} not found\")\n\t            else:\n\t                # TODO: why is this here? a non-responding op is ok!\n\t                self.logger.error(f\"run opname={opname} did not succeed\")\n\t    def run_local(\n\t        self,\n", "        opname: str,\n\t        ctxt: \"OpContext\",\n\t        req: \"Message\",\n\t    ) -> \"Message\":\n\t        \"\"\"Run the op for `opname` and return result.\n\t        Suitable for local use.\n\t        Args:\n\t            opname: See [penvm.kernels.base.server.Kernel.run][].\n\t            ctxt: See [penvm.kernels.base.server.Kernel.run][].\n\t            req: See [penvm.kernels.base.server.Kernel.run][].\n", "        Returns:\n\t            Response (if generated).\n\t        \"\"\"\n\t        op = self.ops.get(opname)\n\t        if op:\n\t            return op.run(ctxt, req)\n\t    def state(self) -> \"State\":\n\t        \"\"\"Get object state.\n\t        Returns:\n\t            `State` object.\n", "        \"\"\"\n\t        try:\n\t            opnames = sorted(list(self.ops.keys()))\n\t            return State(\n\t                \"kernel\",\n\t                self.name,\n\t                {\n\t                    \"bases\": [getattr(cls, \"name\") for cls in self.get_bases() if cls != object],\n\t                    \"nops\": len(opnames),\n\t                    \"ops\": opnames,\n", "                    \"updated\": self.updated,\n\t                },\n\t            )\n\t        except Exception as e:\n\t            self.logger.warning(f\"EXCEPTION ({e})\")\n\t    def unregister(self, opname: str):\n\t        \"\"\"Unregister operation.\n\t        Args:\n\t            opname: Operation name.\n\t        \"\"\"\n", "        try:\n\t            del self.ops[opname]\n\t        except Exception as e:\n\t            pass\n\tclass Op(BaseObject):\n\t    \"\"\"Encapsulates functionality for an operation.\"\"\"\n\t    def __init__(self):\n\t        \"\"\"Initialize.\"\"\"\n\t        super().__init__(None, logger)\n\t    def run(self, req: \"Message\"):\n", "        \"\"\"Run method.\"\"\"\n\t        pass\n\tclass OpContext:\n\t    \"\"\"Context to run operation.\n\t    Provides an easy way for an operation to access important and\n\t    necessary objects and information.\n\t    \"\"\"\n\t    def __init__(self):\n\t        \"\"\"Initialize.\"\"\"\n\t        self.conn = None\n", "        self.machine = None\n\t        self.processor = None\n\t        self.session = None\n"]}
{"filename": "src/kernels/penvm/kernels/core/client.py", "chunked_list": ["#\n\t# penvm/kernels/core/client.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Client-side interface to access the \"core\" kernel operations.\n\tSee [penvm.kernels.core.server][].\"\"\"\n\timport logging\n", "from typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.kernels.base.client import KernelClient as _KernelClient\n\tlogger = logging.getLogger(__name__)\n\tclass KernelClient(_KernelClient):\n\t    name = \"core\"\n\t    def connection_get_state(self, connectionid):\n\t        \"\"\"See [penvm.kernels.core.server.ConnectionGetState][].\"\"\"\n\t        d = {\n\t            \"connection-id\": connectionid,\n\t        }\n", "        return self.session.newput_request(\"connection-get-info\", d)\n\t    def echo(self, d):\n\t        \"\"\"See [penvm.kernels.core.server.Echo][].\"\"\"\n\t        return self.session.newput_request(\"echo\", d)\n\t    def kernel_add(self, kernelname, kernelsrc):\n\t        \"\"\"See [penvm.kernels.core.server.KernelAdd][].\"\"\"\n\t        d = {\n\t            \"kernel\": kernelname,\n\t            \"source\": kernelsrc,\n\t        }\n", "        return self.session.newput_request(\"kernel-add\", d)\n\t    def kernel_copy(self, src_kernelname, dst_kernelname):\n\t        \"\"\"See [penvm.kernels.core.server.KernelCopy][].\"\"\"\n\t        d = {\n\t            \"src-kernel\": src_kernelname,\n\t            \"dst-kernel\": dst_kernelname,\n\t        }\n\t        return self.session.newput_request(\"kernel-copy\", d)\n\t    def kernel_drop(self, kernelname):\n\t        \"\"\"See [penvm.kernels.core.server.KernelDrop][].\"\"\"\n", "        d = {\n\t            \"kernel\": kernelname,\n\t        }\n\t        return self.session.newput_request(\"kernel-drop\", d)\n\t    def kernel_get_state(self, kernelname):\n\t        \"\"\"See [penvm.kernels.core.server.KernelGetState][].\"\"\"\n\t        d = {\n\t            \"kernel\": kernelname,\n\t        }\n\t        return self.session.newput_request(\"kernel-get-state\", d)\n", "    def kernel_list_ops(self, kernelname):\n\t        \"\"\"See [penvm.kernels.core.server.KernelListOps][].\"\"\"\n\t        d = {\n\t            \"kernel\": kernelname,\n\t        }\n\t        return self.session.newput_request(\"kernel-list-ops\", d)\n\t    def kernel_register_op(\n\t        self,\n\t        kernelname,\n\t        opname,\n", "        opclassname,\n\t        code,\n\t        code_key=None,\n\t    ):\n\t        \"\"\"See [penvm.kernels.core.server.KernelRegisterOp][].\"\"\"\n\t        d = {\n\t            \"code\": code,\n\t            \"kernel\": kernelname,\n\t            \"new-op\": opname,\n\t            \"op-class\": opclassname,\n", "        }\n\t        if code_key:\n\t            d[\"code-key\"] = code_key\n\t        return self.session.newput_request(\"kernel-register-op\", d)\n\t    def kernel_unregister_op(\n\t        self,\n\t        kernelname,\n\t        opname,\n\t    ):\n\t        \"\"\"See [penvm.kernels.core.server.KernelUnregisterOp][].\"\"\"\n", "        d = {\n\t            \"kernel\": kernelname,\n\t            \"old-op\": opname,\n\t        }\n\t        return self.session.newput_request(\"kernel-unregister-op\", d)\n\t    def machine_disable_debug(self):\n\t        \"\"\"See [penvm.kernels.core.server.MachineDisableDebug][].\"\"\"\n\t        # TODO: should this force sessionid to \"debug\"?\n\t        return self.session.newput_request(\"machine-enable-debug\")\n\t    def machine_drop_session(self, sessionid=None):\n", "        \"\"\"See [penvm.kernels.core.server.MachineDropSession][].\"\"\"\n\t        d = {}\n\t        if sessionid:\n\t            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"machine-drop-session\", d)\n\t    def machine_enable_debug(self):\n\t        \"\"\"See [penvm.kernels.core.server.MachineEnableDebug][].\"\"\"\n\t        # TODO: should this force sessionid to \"debug\"?\n\t        return self.session.newput_request(\"machine-enable-debug\")\n\t    def machine_get_features(self):\n", "        \"\"\"See [penvm.kernels.core.server.MachineGetFeatures][].\"\"\"\n\t        return self.session.newput_request(\"machine-get-features\")\n\t    def machine_get_state(self):\n\t        \"\"\"See [penvm.kernels.core.server.MachineGetState][].\"\"\"\n\t        return self.session.newput_request(\"machine-get-state\")\n\t    def machine_list_kernels(self):\n\t        \"\"\"See [penvm.kernels.core.server.MachineListKernels][].\"\"\"\n\t        return self.session.newput_request(\"machine-list-kernels\")\n\t    def machine_list_sessions(self):\n\t        \"\"\"See [penvm.kernels.core.server.MachineListSessions][].\"\"\"\n", "        return self.session.newput_request(\"machine-list-sessions\")\n\t    def machine_shutdown(self):\n\t        \"\"\"See [penvm.kernels.core.server.MachineShutdown][].\"\"\"\n\t        return self.session.newput_request(\"machine-shutdown\")\n\t    def machine_snapshot(self):\n\t        \"\"\"See [penvm.kernels.core.server.MachineSnapshot][].\"\"\"\n\t        return self.session.newput_request(\"machine-snapshot\")\n\t    def machine_step_debug(self):\n\t        \"\"\"See [penvm.kernels.core.server.MachineStepDebug][].\"\"\"\n\t        # TODO: should this force sessionid to \"debug\"?\n", "        return self.session.newput_request(\"machine-step-debug\")\n\t    def session_drop_request(self, reqid, sessionid=None):\n\t        \"\"\"See [penvm.kernels.core.server.SessionDropRequest][].\"\"\"\n\t        d = {\n\t            \"request-id\": reqid,\n\t        }\n\t        if sessionid:\n\t            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"session-drop-request\", d)\n\t    def session_get_message_state(self, msgid, msgqueue, sessionid=None):\n", "        \"\"\"See [penvm.kernels.core.server.SessionGetMessageState][].\"\"\"\n\t        d = {\n\t            \"message-id\": msgid,\n\t            \"message-queue\": msgqueue,\n\t        }\n\t        if sessionid:\n\t            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"session-get-message-state\", d)\n\t    def session_get_processor_state(self, sessionid=None):\n\t        \"\"\"See [penvm.kernels.core.server.SessionGetProcessorState][].\"\"\"\n", "        d = {}\n\t        if sessionid:\n\t            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"session-get-processor-state\", d)\n\t    def session_get_state(self, sessionid=None):\n\t        \"\"\"See [penvm.kernels.core.server.SessionGetState][].\"\"\"\n\t        d = {}\n\t        if sessionid:\n\t            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"session-get-state\", d)\n", "    def session_pin_session(self, sessionid=None):\n\t        \"\"\"See [penvm.kernels.core.server.SessionPinSession][].\"\"\"\n\t        d = {}\n\t        if sessionid:\n\t            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"session-pin-session\", d)\n\t    def session_pop_omq(self, sessionid=None, count=1):\n\t        \"\"\"See [penvm.kernels.core.server.SessionPopOmq][].\"\"\"\n\t        d = {\n\t            \"count\": count,\n", "        }\n\t        if sessionid != None:\n\t            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"session-pop-omq\", d)\n\t    def session_set_max_threads(self, nthreads, sessionid=None):\n\t        \"\"\"See [penvm.kernels.core.server.SessionSetMaxThreads][].\"\"\"\n\t        d = {\n\t            \"nthreads\": nthreads,\n\t        }\n\t        if sessionid:\n", "            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"session-set-max-threads\", d)\n\t    def session_terminate_request(self, reqid, sessionid=None):\n\t        \"\"\"See [penvm.kernels.core.server.SessionTerminateRequest][].\"\"\"\n\t        d = {\n\t            \"request-id\": reqid,\n\t        }\n\t        if sessionid:\n\t            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"session-terminate-request\", d)\n", "    def session_unpin_session(self, sessionid=None):\n\t        \"\"\"See [penvm.kernels.core.server.SessionUnpinSession][].\"\"\"\n\t        d = {}\n\t        if sessionid:\n\t            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"session-unpin-session\", d)\n\t    def session_use_kernel(self, kernelname, sessionid=None):\n\t        \"\"\"See [penvm.kernels.core.server.SessionUseKernel][].\"\"\"\n\t        d = {\n\t            \"kernel\": kernelname,\n", "        }\n\t        if sessionid:\n\t            d[\"session-id\"] = sessionid\n\t        return self.session.newput_request(\"session-use-kernel\", d)\n\t    def sleep(self, seconds):\n\t        \"\"\"See [penvm.kernels.core.server.Sleep][].\"\"\"\n\t        d = {\n\t            \"seconds\": seconds,\n\t        }\n\t        return self.session.newput_request(\"sleep\", d)\n"]}
{"filename": "src/kernels/penvm/kernels/core/__init__.py", "chunked_list": ["# blocks changes to this package\n"]}
{"filename": "src/kernels/penvm/kernels/core/server.py", "chunked_list": ["#\n\t# penvm/kernels/core/server.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Server-side \"core\" kernel operations.\n\tThe core operations provide the necessary functionality on which to\n\tbuild others.\n", "All kernel operations use messages to receive and replay. Convenience\n\tfunctions are available:\n\t* request: `Request`\n\t* response: `Response`, `OkResponse`, `ErrorResponse`\n\tWhen a `Request` or `Response` is unused/empty, this is reflected in\n\tthe respective attributes section.\n\tWhereas only one `Request` possible, responses may be `OkResponse` or\n\t`ErrorResponse`. Both may be described to account for possible\n\tresponses according to the situation.\n\tThe `OkResponse` indicates success and contains response information\n", "in its payload. The `ErrorResponse` indicates an error (or failure)\n\tand contains an error messsage in its payload (`-message` field).\"\"\"\n\tfrom importlib.machinery import SourceFileLoader\n\timport logging\n\timport sys\n\timport tempfile\n\timport time\n\timport traceback\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.kernels.base.server import Kernel as _Kernel, Op\n", "from penvm.lib.message import ErrorResponse, OkResponse, Payload, Request\n\tfrom penvm.lib.thread import ThreadInterrupt\n\tlogger = logging.getLogger(__name__)\n\tclass ConnectionGetState(Op):\n\t    \"\"\"Get connection info.\n\t    Attributes: Request:\n\t        connection-id (str): Connection id.\n\t    Attributes: OkResponse:\n\t        connection-id (str): Connection id.\n\t        initial-connection (str): Is initial machine connection.\n", "        host (str): Connection host name.\n\t        port (int): Connection port.\n\t        peer-host (str): Client/peer host name.\n\t        peer-port (int): Client/peer port.\n\t        nimq (int): Number of IMQ messages.\n\t        nomq (int): Number of OMQ messages.\n\t    Attributes: ErrorResponse:\n\t        -: Error message.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n", "        try:\n\t            self.logger.debug(\"run\")\n\t            connid = req.payload.get(\"connection-id\")\n\t            conn = ctxt.machine.connmgr.get(connid)\n\t            if conn != None:\n\t                return OkResponse(\n\t                    payload=Payload(conn.state()),\n\t                    refmsg=req,\n\t                )\n\t            else:\n", "                raise Exception(\"bad connection\")\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                \"connection not found\",\n\t                refmsg=req,\n\t            )\n\tclass Echo(Op):\n\t    \"\"\"Echo request payload.\n\t    Attributes: Request:\n", "        -: Unused.\n\t    Attributes: OkResponse:\n\t        -: Matches request payload.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            resp = OkResponse(\n\t                payload=req.payload,\n\t                refmsg=req,\n\t            )\n", "            return resp\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass Log(Op):\n\t    def run(self, ctxt, req):\n\t        try:\n\t            with open(\"/tmp/log\", \"a\") as f:\n\t                f.write(\"%s\\n\" % req.payload.get(\"text\", \"n/a\"))\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n", "class KernelAdd(Op):\n\t    \"\"\"Add a new kernel.\n\t    Attributes: Request:\n\t        kernel (str): Name of the kernel.\n\t        data (str): Kernel file.\n\t    Attributes: Response:\n\t        -: None.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n", "            self.logger.debug(\"run\")\n\t            kernel_name = req.payload.get(\"kernel\")\n\t            kernel_source = req.payload.get(\"source\")\n\t            if None in [kernel_name, kernel_source]:\n\t                return\n\t            try:\n\t                with tempfile.NamedTemporaryFile() as f:\n\t                    f.write(kernel_source.encode(\"utf-8\"))\n\t                    f.seek(0)\n\t                    mod = SourceFileLoader(\"\", f.name).load_module()\n", "                ctxt.machine.kernelmgr.set(kernel_name, mod.Kernel())\n\t                self.logger.info(f\"completed ({kernel_name})\")\n\t            except Exception as e:\n\t                self.logger.critical(f\"EXCEPTION ({e})\")\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass KernelCopy(Op):\n\t    \"\"\"Make a copy of an existing kernel.\n\t    Attributes: Request:\n\t        dst-kernel (str): Name of destination kernel.\n", "        src-kernel (str): Name of source kernel.\n\t    Attributes: Response:\n\t        -: None.\n\t    \"\"\"\n\t    # TODO: what kind of return value if any?\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            src_kernelname = req.payload.get(\"src-kernel\")\n\t            dst_kernelname = req.payload.get(\"dst-kernel\")\n", "            if None in [src_kernelname, dst_kernelname]:\n\t                return\n\t            src_kernel = ctxt.machine.kernelmgr.get(src_kernelname)\n\t            dst_kernel = src_kernel.copy()\n\t            if None in [src_kernel, dst_kernel]:\n\t                return\n\t            ctxt.machine.kernelmgr.set(dst_kernelname, dst_kernel)\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass KernelDrop(Op):\n", "    \"\"\"Drop an kernel. The \"default\" kernel cannot be dropped.\n\t    Attributes: Request:\n\t        kernel (str): Name of kernel.\n\t    Attributes Response:\n\t        -: None.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            name = req.payload.get(\"kernel\")\n", "            ctxt.machine.kernelmgr.drop(name)\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass KernelGetState(Op):\n\t    \"\"\"Get kernel info.\n\t    Attributes: Request:\n\t        kernel (str): Kernel name.\n\t    Attributes: OkResponse:\n\t        bases (list of str): List of base kernel names.\n\t        nops (int): Number of operations.\n", "        ops (list of str): List of operation names.\n\t        updated (bool): If updated.\n\t    Attributes: ErrorResponse:\n\t        -: Error message.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            kernelname = req.payload.get(\"kernel\")\n\t            kernel = ctxt.machine.kernelmgr.get(kernelname)\n\t            return OkResponse(\n", "                payload=Payload(kernel.state()),\n\t                refmsg=req,\n\t            )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                \"kernel not found\",\n\t                refmsg=req,\n\t            )\n\tclass KernelListOps(Op):\n", "    \"\"\"List op names for kernel.\n\t    Attributes: Request:\n\t        kernel (str): Kernel name.\n\t    Attributes: OkResponse:\n\t        names (list of str): List of kernel operation names.\n\t    Attributes: ErrorResponse:\n\t        -: Error message.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n", "            self.logger.debug(\"run\")\n\t            kernelname = req.payload.get(\"kernel\")\n\t            if kernelname == None:\n\t                return ErrorResponse(\n\t                    f\"kernel name not provided\",\n\t                    refmsg=req,\n\t                )\n\t            kernel = ctxt.machine.kernelmgr.get(kernelname)\n\t            if kernel == None:\n\t                return ErrorResponse(\n", "                    f\"kernel ({kernelname}) not found\",\n\t                    refmsg=req,\n\t                )\n\t            names = kernel.list()\n\t            return OkResponse(\n\t                payload=Payload({\"names\": names}),\n\t                refmsg=req,\n\t            )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n", "class KernelRegisterOp(Op):\n\t    \"\"\"Register a new op for an kernel.\n\t    Attributes: Request:\n\t        kernel (str): Kernel name.\n\t        new-op (str): Op name.\n\t        op-class (str): Op class name.\n\t        code (str): Kernel class definition.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n", "            self.logger.debug(\"run\")\n\t            kernel_name = req.payload.get(\"kernel\")\n\t            opname = req.payload.get(\"new-op\")\n\t            opclassname = req.payload.get(\"op-class\")\n\t            code = req.payload.get(\"code\")\n\t            if code == None:\n\t                code_key = req.payload.get(\"code-key\")\n\t                if code_key != None:\n\t                    code = ctxt.machine.fkvstore.get(code_key)\n\t            if None in [kernel_name, opname, opclassname, code]:\n", "                self.logger.debug(\n\t                    f\"missing params ({kernel_name=} {opname=} {opclassname=} {code=}\"\n\t                )\n\t                return\n\t            kernel = ctxt.machine.kernelmgr.get(kernel_name)\n\t            if kernel == None:\n\t                self.logger.debug(f\"cannot find kernel\")\n\t                return\n\t            kernel.register_code(opname, opclassname, code)\n\t        except Exception as e:\n", "            self.logger.error(f\"{e}\")\n\tclass KernelUnregisterOp(Op):\n\t    \"\"\"Unregister an op for an kernel.\"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            kernel_name = req.payload.get(\"kernel\")\n\t            opname = req.payload.get(\"old-op\")\n\t            if None in [kernel_name, opname]:\n\t                return\n", "            kernel = ctxt.machine.kernelmgr.get(kernel_name)\n\t            kernel.unregister(opname)\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass MachineDisableDebug(Op):\n\t    \"\"\"Disable debug mode.\n\t    Attributes: Request:\n\t        : Unused.\n\t    Attributes: Response:\n\t        : None.\n", "    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            ctxt.machine.set_debug(False)\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass MachineDropConnection(Op):\n\t    \"\"\"Drop connection.\n\t    Attributes: Request:\n\t        connection-id: Sessionid for session processor. Defaults to\n", "            sessionid of session running this op.\n\t    Attributes: Response:\n\t        : None.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            connid = re.payload.get(\"connection-id\")\n\t            conn = ctxt.machine.connmgr.get(connid)\n\t            if conn:\n", "                conn.close()\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass MachineDropSession(Op):\n\t    \"\"\"Drop session.\n\t    Attributes: Request:\n\t        session-id: Sessionid for session processor. Defaults to\n\t            sessionid of session running this op.\n\t    Attributes: Response:\n\t        : None.\n", "    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            reqid = req.header.get(\"id\")\n\t            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n\t            if sessionid == None:\n\t                self.logger.warning(\"bad/missing session id\")\n\t                return\n\t            session = ctxt.machine.pop_session(sessionid)\n", "            if session == None:\n\t                self.logger.warning(f\"session not found for session id ({sessionid}\")\n\t                return\n\t            self.logger.debug(f\"dropping session ({sessionid}) reqid ({reqid}) ...\")\n\t            # clean up\n\t            self.logger.debug(f\"imq ({session.imq.values()}) omq ({session.omq.values()}) ...\")\n\t            self.logger.debug(f\"freezing imq ...\")\n\t            session.imq.freeze(True)\n\t            self.logger.debug(f\"freezing omq ...\")\n\t            session.omq.freeze(True)\n", "            self.logger.debug(f\"clearing imq ...\")\n\t            session.imq.clear()\n\t            self.logger.debug(f\"clearing omq ...\")\n\t            session.omq.clear()\n\t            self.logger.debug(f\"imq ({session.imq.values()}) omq ({session.omq.values()}) ...\")\n\t            self.logger.debug(f\"terminating request threads ({session.proc.active_count()})...\")\n\t            for _reqid in session.proc.get_thread_reqids():\n\t                try:\n\t                    if _reqid == reqid:\n\t                        self.logger.debug(f\"skip terminating reqid ({_reqid})\")\n", "                    else:\n\t                        self.logger.debug(f\"terminating reqid ({_reqid})\")\n\t                        session.proc.terminate_thread(_reqid)\n\t                except Exception as e:\n\t                    self.logger.debug(f\"EXCEPTION ({e})\")\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass MachineEnableDebug(Op):\n\t    \"\"\"Disable debug mode.\n\t    Attributes: Request:\n", "        : Unused.\n\t    Attributes: Response:\n\t        : None.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            ctxt.machine.set_debug(True)\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass MachineStepDebug(Op):\n", "    \"\"\"Trigger step of debug.\n\t    Requires that debug is on.\n\t    See [penvm.kernels.core.server.MachineEnableDebug][] and\n\t    [penvm.kernels.core.server.MachineDisableDebug][].\n\t    Attributes: Request:\n\t        -: Unused.\n\t    Attributes: OkResponse:\n\t        -: None.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n", "        try:\n\t            ctxt.machine.step_debug()\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass MachineGetFeatures(Op):\n\t    \"\"\"Get and return machine features.\n\t    Features are settings which describe the environment and context\n\t    that a machine runs with. E.g., the base language (i.e., python)\n\t    and the version.\n\t    Attributes: Request:\n", "        -: Unused.\n\t    Attributes: OkResponse:\n\t        -: Dictionary of machine features.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            return OkResponse(\n\t                payload=Payload(ctxt.machine.features()),\n\t                refmsg=req,\n\t            )\n", "        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                \"machine not found\",\n\t                refmsg=req,\n\t            )\n\tclass MachineGetState(Op):\n\t    \"\"\"Get and return machine state.\n\t    Attributes: Request:\n\t        -: Unused.\n", "    Attributes: OkResponse:\n\t        : Dictionary of state.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            return OkResponse(\n\t                payload=Payload(ctxt.machine.state()),\n\t                refmsg=req,\n\t            )\n", "        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                \"machine not found\",\n\t                refmsg=req,\n\t            )\n\tclass MachineListConnections(Op):\n\t    \"\"\"List machine connections.\n\t    Attributes: Request:\n\t        -: Unused.\n", "    Attributes: OkResponse:\n\t        names: List of connection ids.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            connids = ctxt.machine.connmgr.list()\n\t            return OkResponse(\n\t                payload=Payload(\n\t                    {\n", "                        \"names\": list(connids),\n\t                    }\n\t                ),\n\t                refmsg=req,\n\t            )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                f\"{e}\",\n\t                refmsg=req,\n", "            )\n\tclass MachineListKernels(Op):\n\t    \"\"\"List kernels by name registered with the machine.\n\t    Attributes: Request:\n\t        -: Unused.\n\t    Attributes: OkResponse:\n\t        names: List of kernel names.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n", "            self.logger.debug(\"run\")\n\t            return OkResponse(\n\t                payload=Payload(\n\t                    {\n\t                        \"names\": ctxt.machine.kernelmgr.list(),\n\t                    }\n\t                ),\n\t                refmsg=req,\n\t            )\n\t        except Exception as e:\n", "            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                f\"{e}\",\n\t                refmsg=req,\n\t            )\n\tclass MachineListSessions(Op):\n\t    \"\"\"List machine sessions.\n\t    Attributes: Request:\n\t        -: Unused.\n\t    Attributes: OkResponse:\n", "        names: List of session ids.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            sessionids = ctxt.machine.sessmgr.list()\n\t            return OkResponse(\n\t                payload=Payload(\n\t                    {\n\t                        \"names\": list(sessionids),\n", "                    },\n\t                ),\n\t                refmsg=req,\n\t            )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                f\"{e}\",\n\t                refmsg=req,\n\t            )\n", "class MachineSnapshot(Op):\n\t    \"\"\"Snapshot machine state and return.\n\t    Snapshottable state taken from:\n\t    * Single: [penvm.kernels.core.server.MachineGetState][].\n\t    * Single: [penvm.kernels.default.server.StoreGetState][].\n\t    * For each: [penvm.kernels.core.server.ConnectionGetState][].\n\t    * For each: [penvm.kernels.core.server.SessionGetState][].\n\t    * For each: [penvm.kernels.core.server.KernelGetState][].\n\t    Attributes: Request:\n\t        -: Unused.\n", "    Attributes: OkResponse:\n\t        -: Dictionary of state.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            # TODO: ensure this runs in a session with the required ops\n\t            self.logger.debug(\"run\")\n\t            run_local = ctxt.session.proc.kernel.run_local\n\t            payload = Payload()\n\t            _req = Request()\n", "            _resp = run_local(\"machine-get-state\", ctxt, _req)\n\t            self.logger.debug(f\"{_resp=}\")\n\t            payload[\"machine\"] = _resp.payload.dict(clean=True)\n\t            _resp = run_local(\"store-get-state\", ctxt, _req)\n\t            self.logger.debug(f\"{_resp=}\")\n\t            payload[\"store\"] = _resp.payload.dict(clean=True)\n\t            _req = Request()\n\t            conns = payload[\"connections\"] = {}\n\t            for connid in ctxt.machine.connmgr.list():\n\t                _req.payload[\"connection-id\"] = connid\n", "                _resp = run_local(\"connection-get-state\", ctxt, _req)\n\t                self.logger.debug(f\"{_resp=}\")\n\t                conns[connid] = _resp.payload.dict(clean=True)\n\t            _req = Request()\n\t            sessions = payload[\"sessions\"] = {}\n\t            for sessid in ctxt.machine.sessmgr.list():\n\t                _req.payload[\"session-id\"] = sessid\n\t                _resp = run_local(\"session-get-state\", ctxt, _req)\n\t                self.logger.debug(f\"{_resp=}\")\n\t                sessions[sessid] = _resp.payload.dict(clean=True)\n", "            _req = Request()\n\t            kernels = payload[\"kernels\"] = {}\n\t            for name in ctxt.machine.kernelmgr.list():\n\t                _req.payload[\"kernel\"] = name\n\t                _resp = run_local(\"kernel-get-state\", ctxt, _req)\n\t                self.logger.debug(f\"{_resp=}\")\n\t                kernels[name] = _resp.payload.dict(clean=True)\n\t            self.logger.debug(f\"{payload=}\")\n\t            return OkResponse(\n\t                payload=payload,\n", "                refmsg=req,\n\t            )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                f\"{e}\",\n\t                refmsg=req,\n\t            )\n\tclass MachineShutdown(Op):\n\t    \"\"\"Shut down the machine.\n", "    Attributes: Request:\n\t        : Unused.\n\t    Attributes: Response:\n\t        : None.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        \"\"\"Shut down machine.\"\"\"\n\t        self.logger.debug(\"run\")\n\t        # TODO: can a reply be sent to ack? I think so!\n\t        sys.exit(0)\n", "class SessionDropRequest(Op):\n\t    \"\"\"Drop request from session IMQ.\"\"\"\n\t    def run(self, ctxt, req):\n\t        \"\"\"Run operation.\"\"\"\n\t        pass\n\tclass SessionGetMessageState(Op):\n\t    \"\"\"Get session message state (from message queue).\n\t    Attributes: Request:\n\t        session-id: Session id for session.\n\t        message-id: Message id of request held by session.\n", "        message-queue: One of \"in\" or \"out\".\n\t    Attributes: Response:\n\t        dict: Request state dictionary.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        \"\"\"Run operation.\"\"\"\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n\t            msgid = req.payload.get(\"message-id\")\n", "            msgqueue = req.payload.get(\"message-queue\")\n\t            sess = ctxt.machine.get_session(sessionid)\n\t            if msgqueue == \"in\":\n\t                mq = sess.imq\n\t            elif msgqueue == \"out\":\n\t                mq = sess.omq\n\t            else:\n\t                mq = None\n\t            msg = mq.find(msgid)\n\t            if msg == None:\n", "                return ErrorResponse(\n\t                    \"message not found\",\n\t                    refmsg=req,\n\t                )\n\t            return OkResponse(payload=Payload(msg.state()))\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                \"message not found\",\n\t                refmsg=req,\n", "            )\n\tclass SessionGetProcessorState(Op):\n\t    \"\"\"Get session processor state.\n\t    Attributes: Request:\n\t        session-id: Session id for session.\n\t    Attributes: Response:\n\t        dict: Request state dictionary.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        \"\"\"Run operation.\"\"\"\n", "        try:\n\t            self.logger.debug(\"run\")\n\t            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n\t            sess = ctxt.machine.get_session(sessionid)\n\t            return OkResponse(payload=Payload(sess.proc.state()))\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                \"session not found\",\n\t                refmsg=req,\n", "            )\n\tclass SessionGetState(Op):\n\t    \"\"\"Get session info.\n\t    Attributes: Request:\n\t        session-id: Session id for session.\n\t    Attributes: OkResponse:\n\t        -: Dictionary of state.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n", "            self.logger.debug(\"run\")\n\t            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n\t            sess = ctxt.machine.get_session(sessionid)\n\t            return OkResponse(\n\t                payload=Payload(sess.state()),\n\t                refmsg=req,\n\t            )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n", "                \"session not found\",\n\t                refmsg=req,\n\t            )\n\tclass SessionPinSession(Op):\n\t    \"\"\"Pin session.\n\t    Attributes: Request:\n\t        session-id: Session id for session.\n\t    Attributes: Response:\n\t        : None.\n\t    \"\"\"\n", "    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n\t            sess = ctxt.machine.get_session(sessionid)\n\t            sess.pin = True\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass SessionPopOmq(Op):\n\t    \"\"\"\n", "    Pop waiting message from session OMQ.\n\t    Attributes: Request:\n\t        count: Number of times to pop the OMQ. Blocking for values\n\t            of >= 1. For 0, pop all values. Defaults to 1.\n\t        session-id: Override sessionid. Defaults to sessionid of\n\t            session running this op.\n\t    Attributes: Response:\n\t        : None.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n", "        try:\n\t            self.logger.debug(\"run\")\n\t            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n\t            connectionid = req.header.get(\"connection-id\")\n\t            session = ctxt.machine.sessmgr.get(sessionid)\n\t            count = req.payload.get(\"count\", 1)\n\t            if count >= 1:\n\t                for _ in range(count):\n\t                    resp = session.omq.pop()\n\t                    resp.header[\"session-id\"] = sessionid\n", "                    resp.header[\"connection-id\"] = connectionid\n\t                    ctxt.machine.omq.put(resp)\n\t            elif count == 0:\n\t                while True:\n\t                    resp = session.omq.pop(block=False)\n\t                    if resp == None:\n\t                        break\n\t                    resp.header[\"session-id\"] = sessionid\n\t                    resp.header[\"connection-id\"] = connectionid\n\t                    ctxt.machine.omq.put(resp)\n", "        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass SessionSetMaxThreads(Op):\n\t    \"\"\"Set max threads for session.\"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n\t            nthreads = req.payload.get(\"nthreads\")\n\t            if None in [nthreads, sessionid]:\n\t                return\n", "            if type(nthreads) != int:\n\t                return\n\t            session = ctxt.machine.get_session(sessionid)\n\t            session.proc.set_max_threads(nthreads)\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass SessionUseKernel(Op):\n\t    \"\"\"Set session to use an kernel.\"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n", "            self.logger.debug(\"run\")\n\t            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n\t            kernel_name = req.payload.get(\"kernel\")\n\t            if None in [sessionid, kernel_name]:\n\t                self.logger.warning(f\"kernel and or sessionid not provided\")\n\t                return\n\t            kernel = ctxt.machine.kernelmgr.get(kernel_name)\n\t            if not kernel:\n\t                self.logger.warning(f\"kernel ({kernel_name}) not found\")\n\t                return\n", "            sess = ctxt.machine.get_session(sessionid)\n\t            sess.set_kernel(kernel)\n\t            self.logger.state(f\"session ({sessionid}) using kernel ({kernel_name})\")\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass SessionTerminateRequest(Op):\n\t    \"\"\"Terminate running request thread/task for session.\n\t    Attributes: Request:\n\t        reqid: Request id.\n\t        session-id: Session id for session processor.\n", "    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            reqid = req.payload.get(\"request-id\")\n\t            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n\t            self.logger.debug(f\"^^^^^^^^ terminate payload {reqid=} {sessionid=}\")\n\t            if reqid == None:\n\t                self.logger.warning(\"bad/missing request id\")\n\t                return\n", "            if sessionid == None:\n\t                self.logger.warning(\"bad/missing session id\")\n\t                return\n\t            session = ctxt.machine.get_session(sessionid)\n\t            if session == None:\n\t                self.logger.warning(f\"session not found for session id ({sessionid}\")\n\t                return\n\t            session.proc.terminate_thread(reqid)\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n", "class SessionUnpinSession(Op):\n\t    \"\"\"Unpin session.\n\t    Attributes: Request:\n\t        session-id: Session id for session.\n\t    Attributes: Response:\n\t        : None.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n", "            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n\t            sess = ctxt.machine.get_session(sessionid)\n\t            sess.pin = False\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass SessionUsekernel(Op):\n\t    \"\"\"Update session to use a specific, previously registered kernel.\"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            sessionid = req.payload.get(\"session-id\", req.header.get(\"session-id\"))\n", "            if sessionid == None:\n\t                return\n\t            session = ctxt.machine.get_session(sessionid)\n\t            kernelname = req.payload.get(\"kernel\")\n\t            kernel = ctxt.machine.kernelmgr.get(kernelname)\n\t            session.set_kernel(kernel)\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass Sleep(Op):\n\t    \"\"\"Sleep.\n", "    Attributes: Request:\n\t        seconds: Number (int or float) of seconds to sleep.\n\t        check-interval: Number of seconds to between checks for an\n\t            interrupt.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            seconds = req.payload.get(\"seconds\")\n\t            check_interval = req.payload.get(\"check-interval\", 1)\n", "            if type(seconds) not in [int, float] or seconds < 0:\n\t                return\n\t            if type(check_interval) not in [int, float] or seconds < 0:\n\t                return\n\t            while seconds > 0:\n\t                time.sleep(min(seconds, check_interval))\n\t                seconds -= check_interval\n\t        except ThreadInterrupt as e:\n\t            raise\n\t        except Exception as e:\n", "            self.logger.error(f\"{e}\")\n\t            self.logger.warning(f\"bad/missing sleep time ({seconds})\")\n\tclass Kernel(_Kernel):\n\t    name = \"core\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self.ops.update(\n\t            {\n\t                \"connection-get-state\": ConnectionGetState(),\n\t                \"echo\": Echo(),\n", "                \"log\": Log(),\n\t                \"machine-disable-debug\": MachineDisableDebug(),\n\t                \"machine-drop-connection\": MachineDropConnection(),\n\t                \"machine-drop-session\": MachineDropSession(),\n\t                \"machine-enable-debug\": MachineEnableDebug(),\n\t                \"machine-get-features\": MachineGetFeatures(),\n\t                \"machine-get-state\": MachineGetState(),\n\t                \"machine-list-connections\": MachineListConnections(),\n\t                \"machine-list-kernels\": MachineListKernels(),\n\t                \"machine-list-sessions\": MachineListSessions(),\n", "                \"machine-shutdown\": MachineShutdown(),\n\t                \"machine-step-debug\": MachineStepDebug(),\n\t                \"machine-snapshot\": MachineSnapshot(),\n\t                \"kernel-add\": KernelAdd(),\n\t                \"kernel-copy\": KernelCopy(),\n\t                \"kernel-drop\": KernelDrop(),\n\t                \"kernel-get-state\": KernelGetState(),\n\t                \"kernel-list-ops\": KernelListOps(),\n\t                \"kernel-register-op\": KernelRegisterOp(),\n\t                \"kernel-unregister-op\": KernelUnregisterOp(),\n", "                \"session-drop-request\": SessionDropRequest(),\n\t                \"session-get-message-state\": SessionGetMessageState(),\n\t                \"session-get-processor-state\": SessionGetProcessorState(),\n\t                \"session-get-state\": SessionGetState(),\n\t                \"session-pop-omq\": SessionPopOmq(),\n\t                \"session-set-max-threads\": SessionSetMaxThreads(),\n\t                \"session-terminate-request\": SessionTerminateRequest(),\n\t                \"session-use-kernel\": SessionUseKernel(),\n\t                \"sleep\": Sleep(),\n\t            },\n", "        )\n"]}
{"filename": "src/kernels/penvm/kernels/default/client.py", "chunked_list": ["#\n\t# penvm/kernels/default/client.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Client-side interface to access the \"default\" kernel operations.\n\tSee [penvm.kernels.default.server][].\"\"\"\n\timport copy\n", "import logging\n\tfrom pathlib import Path\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.lib.message import Request\n\tfrom penvm.kernels.core.client import KernelClient as _KernelClient\n\tlogger = logging.getLogger(__name__)\n\tclass KernelClient(_KernelClient):\n\t    \"\"\"Additional kernel ops.\"\"\"\n\t    name = \"default\"\n\t    def __init__(self, session):\n", "        super().__init__(session)\n\t    def file_copyto(self, lpath, rpath, blksize=1024):\n\t        \"\"\"Copy local file to remote.\"\"\"\n\t        lpp = Path(lpath)\n\t        if not lpp.exists():\n\t            # TODO: what to do?\n\t            return\n\t        try:\n\t            with open(lpath, \"rb\") as f:\n\t                count = 0\n", "                start = 0\n\t                while True:\n\t                    req = Request(\"file-put\")\n\t                    req.payload[\"path\"] = rpath\n\t                    req.payload[\"start\"] = start\n\t                    data = req.payload[\"data\"] = f.read(blksize)\n\t                    self.session.put_request(req)\n\t                    self.session.put_request(Request(\"omq-pop\"))\n\t                    if data == b\"\":\n\t                        break\n", "                    start + len(data)\n\t                    count += 1\n\t            for i in range(count):\n\t                resp = self.imq.pop()\n\t                if resp.payload.get(\"-status\") == \"error\":\n\t                    raise Exception(f\"expected {count} responses got error on {i}\")\n\t        except Exception as e:\n\t            # TODO: what to do here?\n\t            self.logger.debug(\"failed ({e})\")\n\t    def file_copyfrom(self, rpath, lpath, blksize=1024):\n", "        \"\"\"Copy remote file to local.\"\"\"\n\t        pass\n\t    def file_get_block(self, filename, start=None, size=None):\n\t        \"\"\"See [penvm.kernels.default.server.FileGetBlock][].\"\"\"\n\t        d = {\n\t            \"path\": filename,\n\t        }\n\t        if start != None:\n\t            d[\"start\"] = start\n\t        if size != None:\n", "            d[\"size\"] = size\n\t        return self.session.newput_request(\"file-get-block\", d)\n\t    def file_get_status(self, path):\n\t        \"\"\"See [penvm.kernels.default.server.FileGetStatus][].\"\"\"\n\t        d = {\n\t            \"path\": path,\n\t        }\n\t        return self.session.newput_request(\"file-get-status\", d)\n\t    def file_list(self, path, pattern=None, sort=None, split=None):\n\t        \"\"\"See [penvm.kernels.default.server.FileList][].\"\"\"\n", "        d = {\n\t            \"path\": path,\n\t        }\n\t        if pattern != None:\n\t            d[\"pattern\"] = pattern\n\t        if sort != None:\n\t            d[\"sort\"] = sort\n\t        if split != None:\n\t            d[\"split\"] = split\n\t        return self.session.newput_request(\"file-list\", d)\n", "    def file_put_block(self, path, data, start=None, size=None, truncate=None):\n\t        \"\"\"See [penvm.kernels.default.server.FilePutBlock][].\"\"\"\n\t        d = {\n\t            \"path\": path,\n\t            \"data\": data,\n\t        }\n\t        if start != None:\n\t            d[\"start\"] = start\n\t        if size != None:\n\t            d[\"size\"] = size\n", "        if truncate != None:\n\t            d[\"truncate\"] = truncate\n\t        return self.session.newput_request(\"file-put-block\", d)\n\t    def file_set_status(self, path, uid=None, gid=None, user=None, group=None, mode=None):\n\t        \"\"\"See [penvm.kernels.default.server.FileSetStatus][].\"\"\"\n\t        d = {\n\t            \"path\": path,\n\t            \"uid\": uid,\n\t            \"gid\": gid,\n\t            \"user\": user,\n", "            \"group\": group,\n\t            \"mode\": mode,\n\t        }\n\t        return self.session.newput_request(\"file-set-status\", d)\n\t    def run_exec(\n\t        self,\n\t        path,\n\t        args,\n\t        capture_output=False,\n\t        text=True,\n", "        env=None,\n\t        cwd=None,\n\t        path_key=None,\n\t    ):\n\t        \"\"\"See [penvm.kernels.default.server.RunExec][].\"\"\"\n\t        d = {\n\t            \"args\": [str(arg) for arg in args],\n\t            \"capture-output\": capture_output,\n\t            \"text\": text,\n\t        }\n", "        if path != None:\n\t            d[\"path\"] = path\n\t        elif path_key != None:\n\t            d[\"path-key\"] = path_key\n\t        if env != None:\n\t            d[\"env\"] = env\n\t        if cwd != None:\n\t            d[\"cwd\"] = cwd\n\t        return self.session.newput_request(\"run-exec\", d)\n\t    def run_exec_stream(\n", "        self,\n\t        path,\n\t        args,\n\t        capture_output=False,\n\t        text=True,\n\t        env=None,\n\t        wd=None,\n\t        path_key=None,\n\t    ):\n\t        \"\"\"See [penvm.kernels.default.server.RunExecStream][].\"\"\"\n", "        d = {\n\t            \"args\": [str(arg) for arg in args],\n\t            \"capture-output\": capture_output,\n\t            \"text\": text,\n\t        }\n\t        if path != None:\n\t            d[\"path\"] = path\n\t        elif path_key != None:\n\t            d[\"path-key\"] = path_key\n\t        if env != None:\n", "            d[\"env\"] = env\n\t        if wd != None:\n\t            d[\"wd\"] = wd\n\t        return self.session.newput_request(\"run-exec-stream\", d)\n\t    def run_python(self, code, args=None, kwargs=None, _globals=None, _locals=None):\n\t        \"\"\"See [penvm.kernels.default.server.RunPython][].\"\"\"\n\t        _locals = copy.deepcopy(_locals) if _locals != None else {}\n\t        _locals[\"__penvm__\"] = True\n\t        d = {\n\t            \"code\": code,\n", "        }\n\t        if args != None:\n\t            d[\"args\"] = args\n\t        if kwargs != None:\n\t            d[\"kwargs\"] = kwargs\n\t        if _locals != None:\n\t            d[\"locals\"] = _locals\n\t        if _globals != None:\n\t            d[\"globals\"] = _globals\n\t        return self.session.newput_request(\"run-python\", d)\n", "    def run_python_function(self, code, fnname, args=None, kwargs=None):\n\t        \"\"\"See [penvm.kernels.default.server.RunPythonFunction][].\"\"\"\n\t        d = {\n\t            \"args\": args,\n\t            \"code\": code,\n\t            \"fn-name\": fnname,\n\t            \"kwargs\": kwargs,\n\t        }\n\t        return self.session.newput_request(\"run-python-function\", d)\n\t    def store_drop(self, name):\n", "        \"\"\"See [penvm.kernels.default.server.StoreDrop][].\"\"\"\n\t        d = {\n\t            \"name\": name,\n\t        }\n\t        return self.session.newput_request(\"store-drop\", d)\n\t    def store_get(self, name):\n\t        \"\"\"See [penvm.kernels.default.server.StoreGet][].\"\"\"\n\t        d = {\n\t            \"name\": name,\n\t        }\n", "        return self.session.newput_request(\"store-get\", d)\n\t    def store_get_state(self):\n\t        \"\"\"See [penvm.kernels.default.server.StoreGetState][].\"\"\"\n\t        return self.session.newput_request(\"store-get-state\")\n\t    def store_list(self, pattern=None):\n\t        \"\"\"See [penvm.kernels.default.server.StoreList][].\"\"\"\n\t        d = {}\n\t        if pattern:\n\t            d[\"pattern\"] = pattern\n\t        return self.session.newput_request(\"store-list\", d)\n", "    def store_pop(self, name):\n\t        \"\"\"See [penvm.kernels.default.server.StorePop][].\"\"\"\n\t        d = {\n\t            \"name\": name,\n\t        }\n\t        return self.session.newput_request(\"store-pop\", d)\n\t    def store_put(self, name, data):\n\t        \"\"\"See [penvm.kernels.default.server.StorePut][].\"\"\"\n\t        d = {\n\t            \"name\": name,\n", "            \"data\": data,\n\t        }\n\t        return self.session.newput_request(\"store-put\", d)\n"]}
{"filename": "src/kernels/penvm/kernels/default/__init__.py", "chunked_list": ["# blocks changes to this package\n"]}
{"filename": "src/kernels/penvm/kernels/default/server.py", "chunked_list": ["#\n\t# penvm/kernels/default/server.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Server-side \"default\" kernel operations.\n\tThe default operations providing the necessary functionality for\n\tmany/most use cases including support for: filesystem, kv store, and\n", "binary and python code execution.\n\tFor an explanation of the Request and Response sections see\n\t[penvm.kernels.core.server][].\"\"\"\n\timport fnmatch\n\ttry:\n\t    import grp\n\texcept:\n\t    grp = None\n\timport logging\n\timport os\n", "import os.path\n\tfrom pathlib import Path\n\ttry:\n\t    import pwd\n\texcept:\n\t    pwd = None\n\timport select\n\timport shutil\n\timport subprocess\n\timport traceback\n", "from typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.kernels.base.server import Op\n\tfrom penvm.kernels.core.server import Kernel as _Kernel\n\tfrom penvm.lib.message import ErrorResponse, OkResponse, Payload\n\tlogger = logging.getLogger(__name__)\n\tclass FileGetBlock(Op):\n\t    \"\"\"Read data (block) from a file object.\n\t    Attributes: Request:\n\t        path (str): File path.\n\t        size (int): Size (in bytes) to read. Defaults to 1024.\n", "        start (int): Offset from file start. Defaults to 0.\n\t    Attributes: OkResponse:\n\t        data (bytes): Bytes (up to `size`) from file block.\n\t        size (int): Size (in bytes) read.\n\t        start (int): Offset from file start.\n\t    Attributes: ErrorResponse:\n\t        -: Error message.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n", "            payload = req.payload\n\t            path = payload.get(\"path\")\n\t            size = payload.get(\"size\", 1024)\n\t            start = payload.get(\"start\", 0)\n\t            if not path:\n\t                return ErrorResponse(\n\t                    \"path not provided\",\n\t                    refmsg=req,\n\t                )\n\t            pp = Path(path)\n", "            if not pp.exists():\n\t                return ErrorResponse(\n\t                    f\"path ({path}) not found\",\n\t                    refmsg=req,\n\t                )\n\t            try:\n\t                f = pp.open(\"rb\")\n\t                f.seek(start)\n\t                return OkResponse(\n\t                    payload=Payload(\n", "                        {\"data\": f.read(size), \"size\": size, \"start\": start},\n\t                    ),\n\t                    refmsg=req,\n\t                )\n\t            except Exception as e:\n\t                return ErrorResponse(\n\t                    f\"{e}\",\n\t                    refmsg=req,\n\t                )\n\t        except Exception as e:\n", "            self.logger.error(f\"{e}\")\n\tclass FileGetStatus(Op):\n\t    \"\"\"Get file status (`os.stat()`).\n\t    Attributes: Request:\n\t        path (str): File path to stat.\n\t    Attributes: OkResponse:\n\t        mode (int): File mode.\n\t        ino (int): Inode.\n\t        dev (int): Device identifier.\n\t        nlink (int): Number of hard links.\n", "        uid (int): User id of file owner.\n\t        gid (int): Group id of file owner.\n\t        size (int): File size (in bytes).\n\t        atime (int): Most recent access time (in seconds).\n\t        mtime (int): Most recent content modication time (in seconds).\n\t        ctime (int): Most recent metadata change time (in seconds).\n\t    Attributes: ErrorResponse:\n\t        -: Error message.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n", "        try:\n\t            path = req.payload.get(\"path\")\n\t            if path != None:\n\t                return ErrorResponse(\"path not provided\")\n\t            if not os.path.exists(path):\n\t                return ErrorResponse(\"path not found\")\n\t            st = os.stat(path)\n\t            return OkResponse(\n\t                payload={\n\t                    \"mode\": st.st_mode,\n", "                    \"ino\": st.st_ino,\n\t                    \"dev\": st.st_dev,\n\t                    \"nlink\": st.st_nlink,\n\t                    \"uid\": st.st_uid,\n\t                    \"gid\": st.st_gid,\n\t                    \"size\": st.st_size,\n\t                    \"atime\": st.st_atime,\n\t                    \"mtime\": st.st_mtime,\n\t                    \"ctime\": st.st_ctime,\n\t                },\n", "                refmsg=req,\n\t            )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass FileList(Op):\n\t    \"\"\"List filenames/dirnames at filesystem path.\n\t    Attributes: Request:\n\t        path (str): Directory path.\n\t        filter (str): Filename filter. Defaults to no filter.\n\t        sort (bool): Sort names. Defaults to False.\n", "    Attributes: Response:\n\t        names (list of str): List of directory entries.\n\t    Attributes: ErrorResponse:\n\t        -: Error message.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            payload = req.payload\n\t            path = payload.get(\"path\")\n\t            pattern = payload.get(\"pattern\")\n", "            sort = payload.get(\"sort\", False)\n\t            split = payload.get(\"split\", False)\n\t            if not path:\n\t                return ErrorResponse(\n\t                    \"path not provided\",\n\t                    refmsg=req,\n\t                )\n\t            try:\n\t                if split:\n\t                    if os.path.isdir(path):\n", "                        for root, dirnames, filenames in os.walk(path):\n\t                            break\n\t                    else:\n\t                        root, dirnames, filenames = None, [], [path]\n\t                    if pattern:\n\t                        dirnames = fnmatch.filter(dirnames, pattern)\n\t                        filenames = fnmatch.filter(filenames, pattern)\n\t                    if sort:\n\t                        dirnames.sort()\n\t                        filenames.sort()\n", "                    return OkResponse(\n\t                        payload=Payload(\n\t                            {\n\t                                \"dirnames\": dirnames,\n\t                                \"filenames\": filenames,\n\t                            }\n\t                        ),\n\t                        refmsg=req,\n\t                    )\n\t                else:\n", "                    if os.path.isdir(path):\n\t                        names = os.listdir(path)\n\t                    elif os.path.isfile(path):\n\t                        names = [os.path.basename(path)]\n\t                    if pattern:\n\t                        names = fnmatch.filter(names, pattern)\n\t                    if sort:\n\t                        names.sort()\n\t                    return OkResponse(\n\t                        payload=Payload({\"names\": names}),\n", "                        refmsg=req,\n\t                    )\n\t            except Exception as e:\n\t                return ErrorResponse(\n\t                    f\"{e}\",\n\t                    refmsg=req,\n\t                )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass FilePutBlock(Op):\n", "    \"\"\"Write data (block) to a file object.\n\t    Attributes: Request:\n\t        data (bytes): Data to store.\n\t        path (str): File path.\n\t        size (int): Size (in bytes) of data.\n\t        start (int): Offset from file start. Defaults to 0.\n\t        truncate (bool): Flag to indicate truncation of file. Defaults\n\t            to False.\n\t    Attributes: OkResponse:\n\t        -: Empty.\n", "    Attributes: ErrorResponse:\n\t        -: Error message.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            payload = req.payload\n\t            data = payload.get(\"data\")\n\t            path = payload.get(\"path\")\n\t            size = payload.get(\"size\", len(data))\n\t            start = payload.get(\"start\", 0)\n", "            truncate = payload.get(\"truncate\", False)\n\t            if not path:\n\t                return ErrorResponse(\n\t                    \"path not provided\",\n\t                    refmsg=req,\n\t                )\n\t            if not data:\n\t                return ErrorResponse(\n\t                    \"data not provided\",\n\t                    refmsg=req,\n", "                )\n\t            pp = Path(path)\n\t            if not pp.parent.is_dir():\n\t                return ErrorResponse(\n\t                    f\"parent path ({pp.parent.isabsolute()}) does not exist\",\n\t                    refmsg=req,\n\t                )\n\t            try:\n\t                with pp.open(\"wb+\") as f:\n\t                    if truncate:\n", "                        # TODO: support truncateat?\n\t                        f.truncate()\n\t                    f.seek(start)\n\t                    if size != None:\n\t                        f.write(data[:size])\n\t                    else:\n\t                        f.write(data)\n\t                    f.close()\n\t                return OkResponse(\n\t                    refmsg=req,\n", "                )\n\t            except Exception as e:\n\t                return ErrorResponse(\n\t                    f\"{e}\",\n\t                    refmsg=req,\n\t                )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass FileSetStatus(Op):\n\t    \"\"\"Set file status settings.\n", "    Attributes: Request:\n\t        path (str): File object path.\n\t        uid (int): User id of file owner.\n\t        user (str): User name of file owner.\n\t        gid (int): Group id of file owner.\n\t        group (int): Group name of file owner.\n\t        mode (int): File mode.\n\t    Attributes: Response:\n\t        -: None.\n\t    \"\"\"\n", "    def run(self, ctxt, req):\n\t        try:\n\t            payload = req.payload\n\t            path = payload.get(\"path\")\n\t            uid = payload.get(\"uid\")\n\t            user = payload.get(\"user\")\n\t            gid = payload.get(\"gid\")\n\t            group = payload.get(\"group\")\n\t            mode = payload.get(\"mode\")\n\t            if path == None:\n", "                return\n\t            if not os.path.exists(path):\n\t                return\n\t            if user and pwd:\n\t                pw = pwd.getpwnam(user)\n\t                if pw:\n\t                    uid = pw.pw_uid\n\t            if group and grp:\n\t                gr = grp.getgrnam(group)\n\t                if gr:\n", "                    gid = gr.gr_gid\n\t            if uid == None:\n\t                uid = -1\n\t            if gid == None:\n\t                gid = -1\n\t            try:\n\t                if mode != None:\n\t                    os.chmod(path, mode)\n\t            except:\n\t                pass\n", "            try:\n\t                if uid != -1 and gid != -1:\n\t                    os.chown(path, uid, gid)\n\t            except:\n\t                pass\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass RunExec(Op):\n\t    \"\"\"Run a locally available executable via a path with arguments.\n\t    Attributes: Request:\n", "        args (list of string): Arguments. Defaults to empty list.\n\t        capture_output (bool): Capture stdout/stderr. Defaults to\n\t            True.\n\t        env (dict|list of strings): Dictionary or list of strings for\n\t            the environment.\n\t        path (str): Path of executable. See also `path-key`.\n\t        path-key (str): Name of item in file kvstore. See also `path`.\n\t        text (bool): Treat output as \"text\". Otherwise, \"binary\".\n\t        cwd (str): Working directory to run under. Defaults to \"/\".\n\t    Attributes: OkResponse:\n", "        returncode (int): Exit/return code\n\t        stderr (str): stderr output\n\t        stdout (str): stdout output\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        \"\"\"Run operation.\"\"\"\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            payload = req.payload\n\t            args = list(payload.get(\"args\", []))\n", "            capture_output = payload.get(\"capture-output\", True)\n\t            env = payload.get(\"env\", None)\n\t            path = payload.get(\"path\")\n\t            path_key = payload.get(\"path-key\")\n\t            text = payload.get(\"text\", False)\n\t            cwd = payload.get(\"cwd\", \"/\")\n\t            self.logger.debug(f\"path {path} path-key {path_key}\")\n\t            if path == None:\n\t                path = ctxt.machine.fkvstore.get_path(path_key)\n\t                # TODO: make it executable in a different call?\n", "                os.chmod(path, 0o700)\n\t            if None in [path]:\n\t                return ErrorResponse(\n\t                    \"path not provided\",\n\t                    refmsg=req,\n\t                )\n\t            elif not os.path.exists(path):\n\t                _path = shutil.which(path)\n\t                if _path == None:\n\t                    return ErrorResponse(\n", "                        f\"file ({path}) not found\",\n\t                        refmsg=req,\n\t                    )\n\t                path = _path\n\t            kwargs = {\n\t                \"capture_output\": capture_output,\n\t                \"cwd\": cwd,\n\t                \"text\": text,\n\t            }\n\t            if env:\n", "                kwargs[\"env\"] = env\n\t            cp = subprocess.run(\n\t                [path] + args,\n\t                **kwargs,\n\t            )\n\t            return OkResponse(\n\t                payload=Payload(\n\t                    {\n\t                        \"stdout\": cp.stdout,\n\t                        \"stderr\": cp.stderr,\n", "                        \"returncode\": cp.returncode,\n\t                    }\n\t                ),\n\t                refmsg=req,\n\t            )\n\t        except Exception as e:\n\t            return ErrorResponse(\n\t                f\"{e}\",\n\t                refmsg=req,\n\t            )\n", "class RunExecStream(Op):\n\t    \"\"\"Run a locally available executable via a path with arguments\n\t    with streaming capability.\n\t    Whereas `RunExec` runs the executable, waits for it to complete,\n\t    then collects and returns the `stdout`, `stderr`, and\n\t    `returncode`, `RunExecStream` streams partial results over the\n\t    lifetime of the operation. As such, an undetermined number of\n\t    responses are collected and returned. When the operation\n\t    completes, a final message will contain a `returncode` != `None`.\n\t    The requester must perform queue management (e.g.,\n", "    `session-pop-omq` at the server, and consume the messages at the\n\t    client side).\n\t    Note:\n\t        `stdin` is not supported.\n\t    Attributes: Request:\n\t        args (list of string): Arguments. Defaults to empty list.\n\t        capture_output (bool): Capture stdout/stderr. Defaults to\n\t            True.\n\t        env: (dict|list of strings): Dictionary or list of strings for\n\t            the environment.\n", "        path (str): Path of executable. See also `path-key`.\n\t        path-key (str): Name of item in file kvstore. See also `path`.\n\t        text (bool): Treat output as \"text\". Otherwise, \"binary\".\n\t        cwd (str): Working directory to run under. Defaults to \"/\".\n\t    Attributes: OkResponse:\n\t        returncode (int|None): Exit/return code. Last response sends\n\t            `returncode` != `None`.\n\t        stderr (str): `stderr` output.\n\t        stdout (str): `stdout` output.\n\t    \"\"\"\n", "    def run(self, ctxt, req):\n\t        \"\"\"Run operation.\"\"\"\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            payload = req.payload\n\t            args = list(payload.get(\"args\", []))\n\t            capture_output = payload.get(\"capture-output\", True)\n\t            env = payload.get(\"env\", None)\n\t            path = payload.get(\"path\")\n\t            path_key = payload.get(\"path-key\")\n", "            text = payload.get(\"text\", False)\n\t            cwd = payload.get(\"cwd\", \"/\")\n\t            self.logger.debug(f\"path {path} path-key {path_key}\")\n\t            if path == None:\n\t                path = ctxt.machine.fkvstore.get_path(path_key)\n\t                # TODO: make it executable in a different call?\n\t                os.chmod(path, 0o700)\n\t            if None in [path]:\n\t                return ErrorResponse(\n\t                    \"path not provided\",\n", "                    refmsg=req,\n\t                )\n\t            elif not os.path.exists(path):\n\t                return ErrorResponse(\n\t                    f\"file ({path}) not found\",\n\t                    refmsg=req,\n\t                )\n\t            else:\n\t                kwargs = {\n\t                    \"cwd\": cwd,\n", "                    \"text\": text,\n\t                }\n\t                if capture_output:\n\t                    kwargs[\"stdout\"] = subprocess.PIPE\n\t                    kwargs[\"stderr\"] = subprocess.PIPE\n\t                if env:\n\t                    kwargs[\"env\"] = env\n\t                if 0:\n\t                    # no buffering, allows short reads\n\t                    kwargs[\"bufsize\"] = 0\n", "                if 1:\n\t                    # line buffered\n\t                    kwargs[\"bufsize\"] = 1\n\t                try:\n\t                    sp = subprocess.Popen(\n\t                        [path] + args,\n\t                        **kwargs,\n\t                    )\n\t                    POLLIN = select.POLLIN\n\t                    POLLOUT = select.POLLOUT\n", "                    POLLHEN = select.POLLHUP | select.POLLERR | select.POLLNVAL\n\t                    stdout_fd = sp.stdout.fileno()\n\t                    stderr_fd = sp.stderr.fileno()\n\t                    poll = select.poll()\n\t                    poll.register(stdout_fd, select.POLLIN)\n\t                    poll.register(stderr_fd, select.POLLIN)\n\t                    self.logger.debug(f\"{sp.stdout=} {sp.stdout.line_buffering=} {sp.stderr=}\")\n\t                    sp.stdout.reconfigure(line_buffering=True)\n\t                    sp.stderr.reconfigure(line_buffering=True)\n\t                    self.logger.debug(f\"starting ...\")\n", "                    nfds = 2\n\t                    while nfds:\n\t                        populated = False\n\t                        resp = OkResponse(\n\t                            refmsg=req,\n\t                        )\n\t                        for fd, event in poll.poll():\n\t                            self.logger.debug(f\"{fd=} {event=}\")\n\t                            if event & POLLIN:\n\t                                if fd == stdout_fd:\n", "                                    populated = True\n\t                                    resp.payload[\"stdout\"] = sp.stdout.read(128)\n\t                                else:\n\t                                    # assume stderr\n\t                                    populated = True\n\t                                    resp.payload[\"stderr\"] = sp.stderr.read(128)\n\t                            if event & POLLHEN:\n\t                                poll.unregister(fd)\n\t                                nfds -= 1\n\t                        if populated:\n", "                            ctxt.session.omq.put(resp)\n\t                    sp.wait()\n\t                    self.logger.debug(f\"final\")\n\t                    resp = OkResponse(\n\t                        refmsg=req,\n\t                    )\n\t                    resp.payload[\"returncode\"] = sp.returncode\n\t                    return resp\n\t                except Exception as e:\n\t                    # TODO: cleanup? kill?\n", "                    sp.kill()\n\t                    raise\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                f\"{e}\",\n\t                refmsg=req,\n\t            )\n\tclass RunPython(Op):\n\t    \"\"\"Run python code snippet with typed args and typed kwargs.\n", "    The code is executed in a thread of the `machine`.\n\t    Danger:\n\t        Running in the machine process can cause problems.\n\t    See [penvm.kernels.default.server.RunExec][].\n\t    Attributes: Request:\n\t        args (typed list): Arguments.\n\t        code (str): Code snippet.\n\t        globals (typed dict): Dictionary of \"globals\" to use. Defaults\n\t            to current \"globals\".\n\t        kwargs (typed dict): Keyword arguments.\n", "        locals (typed dict): Dictionary of \"locals\" to use. Defaults\n\t            to empty dict.\n\t        path-key (str): Path of code snippet in file kvstore. See also\n\t            `code`.\n\t    Attributes: Response:\n\t        return-value (typed value): Taken from `returnvalue` in locals.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        \"\"\"Run operation.\"\"\"\n\t        try:\n", "            self.logger.debug(\"run\")\n\t            payload = req.payload\n\t            code = payload.get(\"code\")\n\t            path_key = payload.get(\"path-key\")\n\t            if code == None:\n\t                code = ctxt.machine.fkvstore.get(path_key)\n\t            # TODO: should args and kwargs be distinct or in one of locals or globals\n\t            args = payload.get(\"args\", [])\n\t            _locals = payload.get(\"locals\", {})\n\t            _globals = payload.get(\"globals\", None)\n", "            kwargs = payload.get(\"kwargs\", {})\n\t            if None in [code]:\n\t                return ErrorResponse(\n\t                    \"code not provided\",\n\t                    refmsg=req,\n\t                )\n\t            else:\n\t                try:\n\t                    co = compile(code, \"<string>\", \"exec\")\n\t                except Exception as e:\n", "                    self.logger.warning(f\"EXCEPTION ({e})\")\n\t                    co = None\n\t                if co == None:\n\t                    return ErrorResponse(\n\t                        \"code does not compile\",\n\t                        refmsg=req,\n\t                    )\n\t                else:\n\t                    try:\n\t                        exec(code, _globals, _locals)\n", "                        return OkResponse(\n\t                            payload=Payload({\"return-value\": _locals.get(\"returnvalue\")}),\n\t                            refmsg=req,\n\t                        )\n\t                    except Exception as e:\n\t                        self.logger.warning(f\"EXCEPTION ({e})\")\n\t                        resp = ErrorResponse(\n\t                            f\"{e}\",\n\t                            refmsg=req,\n\t                        )\n", "        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass RunPythonFunction(Op):\n\t    \"\"\"Run function from python code snippet with typed args and typed\n\t    kwargs.\n\t    The code is executed in a thread of the `machine`.\n\t    Danger:\n\t        Running in the machine process can cause problems.\n\t    See [penvm.kernels.default.server.RunExec][].\n\t    Attributes: Request:\n", "        args (typed list): Arguments.\n\t        code (str): Code snippet.\n\t        code-key (str): Code snippet in file kvstore. See also `code`.\n\t        globals (typed dict): Dictionary of \"globals\" to use. Defaults\n\t            to current \"globals\"\n\t        kwargs (typed dict): Keyword arguments.\n\t        locals (typed dict): Dictionary of \"locals\" to use. Defaults\n\t            to empty dict\n\t        path-key (str): Path of code snippet in file kvstore. See also\n\t            `code`.\n", "    Attributes: OkResponse:\n\t        return-value (typed): Return value from function call.\n\t    \"\"\"\n\t    code_template = \"\"\"\\\n\tfn = globals().get(fnname)\n\t__penvm_returnvalue__ = fn(*args, **kwargs)\n\t\"\"\"\n\t    def run(self, ctxt, req):\n\t        \"\"\"Run operation.\"\"\"\n\t        try:\n", "            self.logger.debug(\"run\")\n\t            payload = req.payload\n\t            # TODO: tweak args and kwargs handling\n\t            args = payload.get(\"args\", [])\n\t            code = payload.get(\"code\")\n\t            path_key = payload.get(\"path-key\")\n\t            if code == None:\n\t                code = ctxt.machine.fkvstore.get(path_key)\n\t            fnname = payload.get(\"fn-name\")\n\t            kwargs = payload.get(\"kwargs\") or {}\n", "            _globals = payload.get(\"globals\", {})\n\t            _locals = payload.get(\n\t                \"locals\",\n\t                {\n\t                    \"args\": args,\n\t                    \"fnname\": fnname,\n\t                    \"kwargs\": kwargs,\n\t                },\n\t            )\n\t            if code == None:\n", "                return ErrorResponse(\n\t                    \"code not provided\",\n\t                    refmsg=req,\n\t                )\n\t            elif fnname == None:\n\t                return ErrorResponse(\n\t                    \"fnname not provided\",\n\t                    refmsg=req,\n\t                )\n\t            else:\n", "                try:\n\t                    co = compile(code, \"<string>\", \"exec\")\n\t                except Exception as e:\n\t                    self.logger.warning(f\"EXCEPTION ({e})\")\n\t                    co = None\n\t                if co == None:\n\t                    return ErrorResponse(\n\t                        \"code does not compile\",\n\t                        refmsg=req,\n\t                    )\n", "                else:\n\t                    try:\n\t                        # load provided code\n\t                        exec(code, _globals)\n\t                        # run fn\n\t                        exec(self.code_template, _globals, _locals)\n\t                        resp = OkResponse(\n\t                            payload=Payload(\n\t                                {\"return-value\": _locals.get(\"__penvm_returnvalue__\")}\n\t                            ),\n", "                            refmsg=req,\n\t                        )\n\t                        return resp\n\t                    except Exception as e:\n\t                        self.logger.warning(f\"EXCEPTION ({e})\")\n\t                        resp = ErrorResponse(\n\t                            f\"{e}\",\n\t                            refmsg=req,\n\t                        )\n\t        except Exception as e:\n", "            self.logger.error(f\"{e}\")\n\tclass StoreDrop(Op):\n\t    \"\"\"Drop item from store.\n\t    Attributes: Request:\n\t        name: Item name.\n\t    TODO: should an reponse be sent?\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n", "            name = req.payload.get(\"name\")\n\t            if name != None:\n\t                ctxt.machine.fkvstore.drop(name)\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass StoreGet(Op):\n\t    \"\"\"Get item from store.\n\t    Attributes: Request:\n\t        name: Item name.\n\t    Attributes: Response:\n", "        data: Data as text or binary.\n\t        name: Item name.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            name = req.payload.get(\"name\")\n\t            data = ctxt.machine.fkvstore.get(name)\n\t            if data == None:\n\t                return ErrorResponse(\n", "                    f\"name ({name}) not in store\",\n\t                    refmsg=req,\n\t                )\n\t            else:\n\t                return OkResponse(\n\t                    payload=Payload(\n\t                        {\n\t                            \"name\": name,\n\t                            \"data\": data,\n\t                        }\n", "                    ),\n\t                    refmsg=req,\n\t                )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                f\"{e}\",\n\t                refmsg=req,\n\t            )\n\tclass StoreGetState(Op):\n", "    \"\"\"Get store state.\n\t    Attributes: Request:\n\t        : Unused.\n\t    Attributes: OkResponse:\n\t        : Dictionary of state.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            return OkResponse(\n", "                payload=Payload(ctxt.machine.fkvstore.state()),\n\t                refmsg=req,\n\t            )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                \"store not found\",\n\t                refmsg=req,\n\t            )\n\tclass StoreList(Op):\n", "    \"\"\"Get item from store.\n\t    Attributes: Request:\n\t        -: Unused.\n\t    Attributes: Response:\n\t        names: Item name.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            fkvstore = ctxt.machine.fkvstore\n", "            return OkResponse(\n\t                payload=Payload({\"names\": list(fkvstore.keys())}),\n\t                refmsg=req,\n\t            )\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\t            return ErrorResponse(\n\t                f\"{e}\",\n\t                refmsg=req,\n\t            )\n", "class StorePop(Op):\n\t    \"\"\"Get item from store and remove from store.\n\t    Attributes: Request:\n\t        name: Item name.\n\t    Attributes: Response:\n\t        data: Data as text or binary.\n\t        name: Item name.\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n", "            self.logger.debug(\"run\")\n\t            name = req.payload.get(\"name\")\n\t            resp = StoreGet().run(ctxt, req)\n\t            if name != None:\n\t                ctxt.machine.fkvstore.drop(name)\n\t            return resp\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n\tclass StorePut(Op):\n\t    \"\"\"Put item into store.\n", "    Attributes: Request:\n\t        data: Data as text or binary.\n\t        name: Item name.\n\t    TODO: should an reponse be sent?\n\t    \"\"\"\n\t    def run(self, ctxt, req):\n\t        try:\n\t            self.logger.debug(\"run\")\n\t            ftype = req.payload.get(\"type\", \"text\")\n\t            name = req.payload.get(\"name\")\n", "            data = req.payload.get(\"data\")\n\t            if None in [name, data]:\n\t                # DROP!\n\t                self.logger.debug(f\"drop for bad 'name' or 'data'\")\n\t                return\n\t            if data:\n\t                self.logger.debug(f\"putting {name=} {ftype=} {ctxt.machine.fkvstore.dirpath=} ...\")\n\t                ctxt.machine.fkvstore.put(name, data)\n\t        except Exception as e:\n\t            self.logger.error(f\"{e}\")\n", "class Kernel(_Kernel):\n\t    name = \"default\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self.ops.update(\n\t            {\n\t                \"file-get-block\": FileGetBlock(),\n\t                \"file-get-stat\": FileGetStatus(),\n\t                \"file-list\": FileList(),\n\t                \"file-put-block\": FilePutBlock(),\n", "                \"file-set-stat\": FileSetStatus(),\n\t                \"run-exec\": RunExec(),\n\t                \"run-exec-stream\": RunExecStream(),\n\t                \"run-python\": RunPython(),\n\t                \"run-python-function\": RunPythonFunction(),\n\t                \"store-drop\": StoreDrop(),\n\t                \"store-get\": StoreGet(),\n\t                \"store-get-state\": StoreGetState(),\n\t                \"store-list\": StoreList(),\n\t                \"store-pop\": StorePop(),\n", "                \"store-put\": StorePut(),\n\t            }\n\t        )\n"]}
{"filename": "src/app/penvm/app/connect.py", "chunked_list": []}
{"filename": "src/app/penvm/app/boot.py", "chunked_list": ["#\n\t# penvm/app/boot.py\n\t# PENVM\n\t#\n\t# Copyright 2023 J4M Solutions\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n", "#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t\"\"\"Boot support for PENVM world/network.\n\t\"\"\"\n\timport os\n", "import os.path\n\timport subprocess\n\timport sys\n\timport time\n\tfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\tfrom penvm.client.world import World\n\tfrom penvm.lib.misc import MachineConnectionSpec, get_version_string\n\tclass Booter:\n\t    \"\"\"Provides PENVM network boot support from configuration file.\"\"\"\n\t    def __init__(\n", "        self,\n\t        configfilename: str,\n\t        networkname: str,\n\t        release: str,\n\t    ):\n\t        \"\"\"Initialize.\n\t        Args:\n\t            configfilename: Configuration file name.\n\t            networkname: Network name.\n\t            release: PENVM release.\n", "        \"\"\"\n\t        self.configfilename = configfilename\n\t        self.networkname = networkname\n\t        self.release = release\n\t        self.world = None\n\t        self.network = None\n\t        self.env = None\n\t    def boot(self):\n\t        \"\"\"Boot.\"\"\"\n\t        try:\n", "            self.world = World(filename=self.configfilename)\n\t            self.network = self.world.get_network(self.networkname)\n\t            # print(f\"{self.networkname=}\")\n\t            if self.network == None or self.network.get_targets() in [None, []]:\n\t                raise Exception(f\"network ({self.networkname}) not found\")\n\t            self.network.boot()\n\t            machines = self.network.get_machines()\n\t            if machines in [None, []]:\n\t                raise Exception(\"no machines\")\n\t            if None in machines:\n", "                raise Exception(\"not all machines found\")\n\t            self.release = self.release or self.world.get_meta(\"release\") or get_version_string()\n\t            if self.release == None:\n\t                raise Exception(f\"could not determine release value\")\n\t            releasepath = os.path.expanduser(f\"~/.penvm/releases/{self.release}\")\n\t            releaselibs = \":\".join([f\"{releasepath}/{name}\" for name in [\"penvmlib-client\"]])\n\t            # patch env\n\t            self.env = os.environ.copy()\n\t            PENVM_AUTO_NETWORK = str(self.network)\n\t            PYTHONPATH = self.env.get(\"PYTHONPATH\")\n", "            if PYTHONPATH != None:\n\t                PYTHONPATH = f\"{releaselibs}:{PYTHONPATH}\"\n\t            else:\n\t                PYTHONPATH = releaselibs\n\t            self.env[\"PENVM_AUTO_NETWORK\"] = PENVM_AUTO_NETWORK\n\t            self.env[\"PENVM_RELEASE\"] = self.release\n\t            self.env[\"PYTHONPATH\"] = PYTHONPATH\n\t        except Exception as e:\n\t            raise\n\t        finally:\n", "            pass\n\t    def shell(\n\t        self,\n\t        path: str,\n\t    ):\n\t        \"\"\"Start shell with environment.\"\"\"\n\t        try:\n\t            try:\n\t                sp = subprocess.Popen(\n\t                    [path],\n", "                    pass_fds=[0, 1, 2],\n\t                    env=self.env,\n\t                )\n\t            except Exception as e:\n\t                raise Exception(f\"failed to start shell ({path})\")\n\t            try:\n\t                # close streams\n\t                sys.stdin.close()\n\t                sys.stdout.close()\n\t                sys.stderr.close()\n", "                # close fds\n\t                os.close(0)\n\t                os.close(1)\n\t                os.close(2)\n\t            except Exception as e:\n\t                raise Exception(\"failed to close streams/fds\")\n\t            os.waitpid(sp.pid, 0)\n\t        except Exception as e:\n\t            raise\n\t    def wait(self, secs: int = 1000000):\n", "        \"\"\"Wait indefinitely.\"\"\"\n\t        time.sleep(secs)\n"]}
