{"filename": "up4ros/setup.py", "chunked_list": ["# ! DO NOT MANUALLY INVOKE THIS setup.py, USE CATKIN INSTEAD\n\tfrom distutils.core import setup\n\tfrom catkin_pkg.python_setup import generate_distutils_setup\n\t# fetch values from package.xml\n\tsetup_args = generate_distutils_setup(packages=[\"up4ros\"], package_dir={\"\": \"src\"})\n\tsetup(**setup_args)\n"]}
{"filename": "up4ros/scripts/example_client.py", "chunked_list": ["#!/usr/bin/env python3\n\timport actionlib\n\timport rospy\n\tfrom up4ros.ros_interface_writer import ROSInterfaceWriter\n\tfrom unified_planning.test.examples import get_example_problems\n\timport up_msgs.msg as msgs\n\tdef run_plan_one_shot(action_name=\"/up4ros/action/planOneShot\"):\n\t    client = actionlib.SimpleActionClient(action_name, msgs.PlanOneShotAction)\n\t    pb_writter = ROSInterfaceWriter()\n\t    goal_msg = msgs.PlanOneShotGoal()\n", "    goal_msg.plan_request.problem = pb_writter.convert(\n\t        get_example_problems()[\"robot\"].problem\n\t    )\n\t    rospy.loginfo(\n\t        \"Sending to '%s' the following goal message:\\n%s\\n\", action_name, goal_msg\n\t    )\n\t    def print_feedback(msg):\n\t        rospy.loginfo(\"Received feedback \\n%s\\n\", msg)\n\t    rospy.sleep(\n\t        0.1\n", "    )  # sleep due to https://github.com/ros/ros_comm/issues/176#issuecomment-13930136\n\t    client.send_goal(goal_msg, feedback_cb=print_feedback)\n\t    # Waits for the server to finish performing the action.\n\t    rospy.loginfo(\"Waiting for results...\")\n\t    client.wait_for_result()\n\t    # Prints out the result of executing the action\n\t    result = client.get_result()\n\t    rospy.loginfo(\"Received from '%s' the following result:\\n%s\\n\", action_name, result)\n\t    return result\n\tif __name__ == \"__main__\":\n", "    rospy.init_node(\"test_up4ros_client\")\n\t    run_plan_one_shot()\n"]}
{"filename": "up4ros/scripts/start_up4ros.py", "chunked_list": ["#!/usr/bin/env python3\n\t# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t#\n\timport rospy\n\tfrom up4ros.up4ros_node import UP4ROSNode\n\tdef main():\n\t    rospy.init_node(\"up4ros\")\n", "    _ = UP4ROSNode()\n\t    rospy.spin()\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "up4ros/scripts/example_pddl_client.py", "chunked_list": ["#!/usr/bin/env python3\n\timport actionlib\n\timport rospy\n\timport up_msgs.msg as msgs\n\tfrom up4ros.test_utils import get_domain_and_problem\n\tdef run_plan_one_shot_pddl(action_name=\"/up4ros/action/planOneShotPDDL\"):\n\t    client = actionlib.SimpleActionClient(action_name, msgs.PDDLPlanOneShotAction)\n\t    goal_msg = msgs.PDDLPlanOneShotGoal()\n\t    goal_msg.plan_request.mode = msgs.PDDLPlanRequest.FILE\n\t    domain, problem = get_domain_and_problem(\n", "        \"pddl/gripper_domain.pddl\", \"pddl/gripper_problem_0.pddl\"\n\t    )\n\t    goal_msg.plan_request.domain = domain\n\t    goal_msg.plan_request.problem = problem\n\t    rospy.loginfo(\n\t        \"Sending to '%s' the following goal message:\\n%s\\n\", action_name, goal_msg\n\t    )\n\t    def print_feedback(msg):\n\t        rospy.loginfo(\"Received feedback \\n%s\\n\", msg)\n\t    rospy.sleep(\n", "        0.1\n\t    )  # sleep due to https://github.com/ros/ros_comm/issues/176#issuecomment-13930136\n\t    client.send_goal(goal_msg, feedback_cb=print_feedback)\n\t    # Waits for the server to finish performing the action.\n\t    rospy.loginfo(\"Waiting for results...\")\n\t    client.wait_for_result()\n\t    # Prints out the result of executing the action\n\t    result = client.get_result()\n\t    rospy.loginfo(\"Received from '%s' the following result:\\n%s\\n\", action_name, result)\n\t    return result\n", "if __name__ == \"__main__\":\n\t    rospy.init_node(\"test_up4ros_client\")\n\t    run_plan_one_shot_pddl()\n"]}
{"filename": "up4ros/tests/test_set_and_get_problem_service.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom unified_planning.test.examples import get_example_problems\n\tfrom up4ros.ros_interface_reader import ROSInterfaceReader\n\tfrom up4ros.ros_interface_writer import ROSInterfaceWriter\n\tfrom up_msgs import srv as srvs\n\tfrom up4ros.up4ros_node import UP4ROSNode\n\tdef test_set_get_problem():\n", "    node_test = UP4ROSNode(init_ros_interfaces=False)\n\t    pb_writer = ROSInterfaceWriter()\n\t    problems = get_example_problems()\n\t    problem = problems[\"robot\"].problem\n\t    req = srvs.SetProblemRequest()\n\t    req.problem_name = \"problem_test_robot\"\n\t    req.problem = pb_writer.convert(problem)\n\t    response = node_test.set_problem(req)\n\t    assert response.success\n\t    assert response.message == \"\"\n", "    req = srvs.SetProblemRequest()\n\t    req.problem_name = \"problem_test_robot\"\n\t    req.problem = pb_writer.convert(problem)\n\t    response = node_test.set_problem(req)\n\t    assert not response.success\n\t    assert response.message == \"Problem problem_test_robot already exists\"\n\t    pb_reader = ROSInterfaceReader()\n\t    req2 = srvs.GetProblemRequest()\n\t    req2.problem_name = \"problem_test_robot\"\n\t    response2 = node_test.get_problem(req2)\n", "    assert response2.success\n\t    problem_ret = pb_reader.convert(response2.problem)\n\t    assert problem == problem_ret\n"]}
{"filename": "up4ros/tests/test_plan_one_shot_remote_action.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom mock.mock import MagicMock\n\tfrom unified_planning.test.examples import get_example_problems\n\tfrom up_msgs import msg as msgs\n\tfrom up_msgs import srv as srvs\n\tfrom up4ros.ros_interface_reader import ROSInterfaceReader\n\tfrom up4ros.ros_interface_writer import ROSInterfaceWriter\n", "from up4ros.up4ros_node import UP4ROSNode\n\tdef test_one_shot_remote_success():\n\t    node_test = UP4ROSNode(init_ros_interfaces=False)\n\t    # prepare the magic mock\n\t    action_server_mock = MagicMock()\n\t    pb_writer = ROSInterfaceWriter()\n\t    req = srvs.SetProblemRequest()\n\t    req.problem_name = \"problem_test_robot\"\n\t    req.problem = pb_writer.convert(get_example_problems()[\"robot\"].problem)\n\t    response = node_test.set_problem(req)\n", "    assert response.success\n\t    assert response.message == \"\"\n\t    problem = node_test.problems[\"problem_test_robot\"]\n\t    goal_msg = msgs.PlanOneShotRemoteGoal()\n\t    goal_msg.plan_request.problem = \"problem_test_robot\"\n\t    def feedback_mock(feedback_msg):\n\t        pb_reader = ROSInterfaceReader()\n\t        upf_plan = pb_reader.convert(feedback_msg.plan_result.plan, problem)\n\t        good_plan = \"[move(l1, l2)]\"\n\t        assert upf_plan.__repr__() == good_plan\n", "    action_server_mock.publish_feedback = feedback_mock\n\t    # let's now replace the action server and plan\n\t    node_test._plan_one_shot_remote_server = action_server_mock\n\t    node_test.plan_one_shot_remote_callback(goal_msg)\n\t    expected_result = msgs.PlanOneShotRemoteResult()\n\t    expected_result.success = True\n\t    expected_result.message = \"\"\n\t    action_server_mock.set_succeeded.assert_called_with(expected_result)\n\tdef test_one_shot_remote_failure():\n\t    node_test = UP4ROSNode(init_ros_interfaces=False)\n", "    # prepare the magic mock\n\t    action_server_mock = MagicMock()\n\t    goal_msg = msgs.PlanOneShotRemoteGoal()\n\t    goal_msg.plan_request.problem = \"problem\"\n\t    # let's now replace the action server and plan\n\t    node_test._plan_one_shot_remote_server = action_server_mock\n\t    node_test.plan_one_shot_remote_callback(goal_msg)\n\t    expected_result = msgs.PlanOneShotRemoteResult()\n\t    expected_result.success = False\n\t    expected_result.message = \"Problem problem does not exist\"\n", "    action_server_mock.set_succeeded.assert_called_with(expected_result)\n"]}
{"filename": "up4ros/tests/test_plan_one_shot_service.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom unified_planning.io.pddl_reader import PDDLReader\n\tfrom up_msgs import msg as msgs\n\tfrom up_msgs import srv as srvs\n\tfrom up4ros.ros_interface_reader import ROSInterfaceReader\n\tfrom up4ros.test_utils import get_domain_and_problem\n\tfrom up4ros.up4ros_node import UP4ROSNode\n", "def test_plan_from_file_pddl_tt_service():\n\t    node_test = UP4ROSNode(init_ros_interfaces=False)\n\t    req = srvs.PDDLPlanOneShotRequest()\n\t    req.plan_request.mode = msgs.PDDLPlanRequest.FILE\n\t    domain, problem = get_domain_and_problem(\n\t        \"/pddl/domain_tt.pddl\", \"/pddl/problem_tt_1.pddl\"\n\t    )\n\t    req.plan_request.domain = domain\n\t    req.plan_request.problem = problem\n\t    # let's mock the publish_feedback method\n", "    reader = PDDLReader()\n\t    upf_problem = reader.parse_problem(\n\t        req.plan_request.domain, req.plan_request.problem\n\t    )\n\t    response = node_test.pddl_plan_one_shot(req)\n\t    pb_reader = ROSInterfaceReader()\n\t    upf_plan = pb_reader.convert(response.plan_result.plan, upf_problem)\n\t    good_plan = \"[(Fraction(0, 1), move(leia, kitchen, bedroom), Fraction(5, 1))]\"\n\t    assert upf_plan.__repr__() == good_plan\n\t    assert response.success\n", "    assert response.message == \"\"\n"]}
{"filename": "up4ros/tests/test_conversion.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t#\n\timport unittest\n\tfrom unified_planning import engines, environment, model, shortcuts\n\tfrom unified_planning.model import metrics\n\tfrom unified_planning.plans import ActionInstance\n\tfrom unified_planning.shortcuts import (\n", "    CompilationKind,\n\t    Compiler,\n\t    OneshotPlanner,\n\t    PlanValidator,\n\t    Problem,\n\t    UserType,\n\t)\n\tfrom unified_planning.test.examples import get_example_problems\n\tfrom unified_planning.plans import PlanKind\n\tfrom up4ros.ros_interface_reader import ROSInterfaceReader\n", "from up4ros.ros_interface_writer import ROSInterfaceWriter\n\tclass TestROSInterfaces(unittest.TestCase):\n\t    @classmethod\n\t    def setUpClass(cls):\n\t        environment.get_environment().credits_stream = None\n\t        pass\n\t    def __init__(self, *args, **kwargs):\n\t        super().__init__(*args, **kwargs)\n\t        self.problems = get_example_problems()\n\t        self.pb_writer = ROSInterfaceWriter()\n", "        self.pb_reader = ROSInterfaceReader()\n\t    def test_fluent(self):\n\t        problem = shortcuts.Problem(\"test\")\n\t        x = shortcuts.Fluent(\"x\")\n\t        x_pb = self.pb_writer.convert(x, problem)\n\t        self.assertEqual(x_pb.name, \"x\")\n\t        self.assertEqual(x_pb.value_type, \"up:bool\")\n\t        x_up = self.pb_reader.convert(x_pb, problem)\n\t        self.assertEqual(x_up.name, \"x\")\n\t        self.assertEqual(x_up.type, shortcuts.BoolType())\n", "    def test_fluent_2(self):\n\t        problem = self.problems[\"robot\"].problem\n\t        for f in problem.fluents:\n\t            f_pb = self.pb_writer.convert(f, problem)\n\t            f_up = self.pb_reader.convert(f_pb, problem)\n\t            self.assertEqual(f, f_up)\n\t    def test_fluent_3(self):\n\t        \"\"\"Test to handle subtypes of usertypes of Fluent Expression.\"\"\"\n\t        problem = self.problems[\"hierarchical_blocks_world\"].problem\n\t        for f in problem.fluents:\n", "            f_pb = self.pb_writer.convert(f, problem)\n\t            f_up = self.pb_reader.convert(f_pb, problem)\n\t            self.assertEqual(f, f_up)\n\t    def test_objects(self):\n\t        \"\"\"Test to handle subtypes of usertypes of Fluent Expression.\"\"\"\n\t        problem = self.problems[\"hierarchical_blocks_world\"].problem\n\t        for o in problem.all_objects:\n\t            o_pb = self.pb_writer.convert(o)\n\t            o_up = self.pb_reader.convert(o_pb, problem)\n\t            self.assertEqual(o, o_up)\n", "    def test_expression(self):\n\t        problem = Problem(\"test\")\n\t        ex = problem.environment.expression_manager.true_expression\n\t        ex_pb = self.pb_writer.convert(ex)\n\t        ex_up = self.pb_reader.convert(ex_pb, problem)\n\t        self.assertEqual(ex, ex_up)\n\t        ex = problem.environment.expression_manager.Int(10)\n\t        ex_pb = self.pb_writer.convert(ex)\n\t        ex_up = self.pb_reader.convert(ex_pb, problem)\n\t        self.assertEqual(ex, ex_up)\n", "    def test_fluent_expressions(self):\n\t        problem = self.problems[\"hierarchical_blocks_world\"].problem\n\t        problem_pb = self.pb_writer.convert(problem)\n\t        problem_up = self.pb_reader.convert(problem_pb)\n\t        self.assertEqual(problem, problem_up)\n\t    def test_type_declaration(self):\n\t        problem = Problem(\"test\")\n\t        ex = UserType(\"object\")\n\t        ex_pb = self.pb_writer.convert(ex)\n\t        ex_up = self.pb_reader.convert(ex_pb, problem)\n", "        self.assertEqual(ex, ex_up)\n\t        o = model.Object(\"o\", ex)\n\t        problem.add_object(o)\n\t        ex = UserType(\"location\", ex)\n\t        ex_pb = self.pb_writer.convert(ex)\n\t        ex_up = self.pb_reader.convert(ex_pb, problem)\n\t        self.assertEqual(ex, ex_up)\n\t    def test_object_declaration(self):\n\t        problem = Problem(\"test\")\n\t        loc_type = UserType(\"location\")\n", "        obj = problem.add_object(\"l1\", loc_type)\n\t        obj_pb = self.pb_writer.convert(obj)\n\t        obj_up = self.pb_reader.convert(obj_pb, problem)\n\t        self.assertEqual(obj, obj_up)\n\t    def test_problem(self):\n\t        import unified_planning.grpc.generated.unified_planning_pb2 as up_pb2\n\t        problem = self.problems[\"robot\"].problem\n\t        problem_pb = self.pb_writer.convert(problem)\n\t        problem_up = self.pb_reader.convert(problem_pb)\n\t        pb_features = {up_pb2.Feature.Name(feature) for feature in problem_pb.features}\n", "        self.assertEqual(set(problem.kind.features), pb_features)\n\t        self.assertEqual(problem, problem_up)\n\t    def test_action(self):\n\t        problem = self.problems[\"robot\"].problem\n\t        action = problem.action(\"move\")\n\t        action_pb = self.pb_writer.convert(action)\n\t        action_up = self.pb_reader.convert(action_pb, problem)\n\t        self.assertEqual(action, action_up)\n\t    def test_durative_action(self):\n\t        problem = self.problems[\"matchcellar\"].problem\n", "        action = problem.action(\"mend_fuse\")\n\t        action_pb = self.pb_writer.convert(action)\n\t        action_up = self.pb_reader.convert(action_pb, problem)\n\t        self.assertEqual(action, action_up)\n\t    def test_action_instance(self):\n\t        problem = self.problems[\"robot\"].problem\n\t        plan = self.problems[\"robot\"].plan\n\t        action_instance = plan.actions[0]\n\t        action_instance_pb = self.pb_writer.convert(action_instance)\n\t        action_instance_up = self.pb_reader.convert(action_instance_pb, problem)\n", "        self.assertEqual(action_instance.action, action_instance_up.action)\n\t        self.assertEqual(\n\t            action_instance.actual_parameters, action_instance_up.actual_parameters\n\t        )\n\t    def test_plan(self):\n\t        problem = self.problems[\"robot\"].problem\n\t        plan = self.problems[\"robot\"].plan\n\t        plan_pb = self.pb_writer.convert(plan)\n\t        plan_up = self.pb_reader.convert(plan_pb, problem)\n\t        self.assertEqual(plan, plan_up)\n", "    def test_time_triggered_plan(self):\n\t        problem = self.problems[\"temporal_conditional\"].problem\n\t        plan = self.problems[\"temporal_conditional\"].plan\n\t        plan_pb = self.pb_writer.convert(plan)\n\t        plan_up = self.pb_reader.convert(plan_pb, problem)\n\t        self.assertEqual(plan, plan_up)\n\t    def test_metric(self):\n\t        problem = Problem(\"test\")\n\t        problem.add_quality_metric(metric=metrics.MinimizeSequentialPlanLength())\n\t        problem.add_quality_metric(metric=metrics.MinimizeMakespan())\n", "        problem.add_quality_metric(metric=metrics.MinimizeExpressionOnFinalState(0))\n\t        problem.add_quality_metric(metric=metrics.MaximizeExpressionOnFinalState(0))\n\t        for metric in problem.quality_metrics:\n\t            metric_pb = self.pb_writer.convert(metric)\n\t            metric_up = self.pb_reader.convert(metric_pb, problem)\n\t            self.assertEqual(str(metric), str(metric_up))\n\t    def test_log_message(self):\n\t        def assert_log(log):\n\t            logger_pb = self.pb_writer.convert(log)\n\t            logger_up = self.pb_reader.convert(logger_pb)\n", "            self.assertEqual(log, logger_up)\n\t        log = engines.LogMessage(engines.LogLevel.DEBUG, \"test message\")\n\t        assert_log(log)\n\t        log = engines.LogMessage(engines.LogLevel.INFO, \"test message\")\n\t        assert_log(log)\n\t        log = engines.LogMessage(engines.LogLevel.WARNING, \"test message\")\n\t        assert_log(log)\n\t        log = engines.LogMessage(engines.LogLevel.ERROR, \"test message\")\n\t        assert_log(log)\n\t    def test_plan_generation(self):\n", "        problem = self.problems[\"robot\"].problem\n\t        with OneshotPlanner(name=\"tamer\", params={\"weight\": 0.8}) as planner:\n\t            self.assertNotEqual(planner, None)\n\t            final_report = planner.solve(problem)\n\t            final_report_pb = self.pb_writer.convert(final_report)\n\t            final_report_up = self.pb_reader.convert(final_report_pb, problem)\n\t            self.assertEqual(final_report, final_report_up)\n\t    def test_compiler_result(self):\n\t        problem, _ = self.problems[\"hierarchical_blocks_world\"]\n\t        with Compiler(name=\"up_grounder\") as grounder:\n", "            ground_result = grounder.compile(problem, CompilationKind.GROUNDING)\n\t            ground_result_pb = self.pb_writer.convert(ground_result)\n\t            ground_result_up = self.pb_reader.convert(ground_result_pb, problem)\n\t            self.assertEqual(ground_result.problem, ground_result_up.problem)\n\t            for grounded_action in ground_result.problem.actions:\n\t                # Test both callable 'map_back_action_instance' act\n\t                # the same on every action of the grounded_problem\n\t                grounded_action_instance = ActionInstance(grounded_action)\n\t                original_action_instance_up = ground_result.map_back_action_instance(\n\t                    grounded_action_instance\n", "                )\n\t                original_action_instance_pb = ground_result_up.map_back_action_instance(\n\t                    grounded_action_instance\n\t                )\n\t                self.assertEqual(\n\t                    original_action_instance_pb.action,\n\t                    original_action_instance_up.action,\n\t                )\n\t                self.assertEqual(\n\t                    original_action_instance_pb.actual_parameters,\n", "                    original_action_instance_up.actual_parameters,\n\t                )\n\t    def test_validation_result(self):\n\t        problem = self.problems[\"robot\"].problem\n\t        with OneshotPlanner(name=\"tamer\", params={\"weight\": 0.8}) as planner:\n\t            self.assertNotEqual(planner, None)\n\t            final_report = planner.solve(problem)\n\t            with PlanValidator(name=\"tamer\") as validator:\n\t                validation_result = validator.validate(problem, final_report.plan)\n\t                validation_result_pb = self.pb_writer.convert(validation_result)\n", "                validation_result_up = self.pb_reader.convert(validation_result_pb)\n\t                self.assertEqual(validation_result, validation_result_up)\n\tclass TestROSInterfacesProblems(unittest.TestCase):\n\t    def __init__(self, *args, **kwargs):\n\t        super().__init__(*args, **kwargs)\n\t        self.problems = get_example_problems()\n\t        self.pb_writer = ROSInterfaceWriter()\n\t        self.pb_reader = ROSInterfaceReader()\n\t    def test_all_problems(self):\n\t        for name, example in self.problems.items():\n", "            problem = example.problem\n\t            if \"HIERARCHICAL\" in problem.kind.features:\n\t                continue\n\t            problem_pb = self.pb_writer.convert(problem)\n\t            problem_up = self.pb_reader.convert(problem_pb)\n\t            self.assertEqual(problem, problem_up)\n\t            self.assertEqual(hash(problem), hash(problem_up))\n\t    def test_all_plans(self):\n\t        for name, example in self.problems.items():\n\t            problem = example.problem\n", "            plan = example.plan\n\t            if plan.kind == PlanKind.HIERARCHICAL_PLAN:\n\t                continue\n\t            plan_pb = self.pb_writer.convert(plan)\n\t            plan_up = self.pb_reader.convert(plan_pb, problem)\n\t            self.assertEqual(plan, plan_up)\n\t            self.assertEqual(hash(plan), hash(plan_up))\n\t    def test_some_plan_generations(self):\n\t        problems = [\n\t            \"basic\",\n", "            \"basic_without_negative_preconditions\",\n\t            \"basic_nested_conjunctions\",\n\t            \"robot_loader\",\n\t            \"robot_loader_mod\",\n\t            \"robot_loader_adv\",\n\t            \"robot_real_constants\",\n\t            \"robot_int_battery\",\n\t            \"robot\",\n\t        ]\n\t        for name in problems:\n", "            problem = self.problems[name].problem\n\t            with shortcuts.OneshotPlanner(name=\"tamer\") as planner:\n\t                self.assertNotEqual(planner, None)\n\t                final_report = planner.solve(problem)\n\t                final_report_pb = self.pb_writer.convert(final_report)\n\t                final_report_up = self.pb_reader.convert(final_report_pb, problem)\n\t                self.assertEqual(final_report.status, final_report_up.status)\n\t                self.assertEqual(final_report.plan, final_report_up.plan)\n\t                self.assertEqual(final_report.engine_name, final_report_up.engine_name)\n\tif __name__ == \"__main__\":\n", "    unittest.main()\n"]}
{"filename": "up4ros/tests/test_new_problem_service.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom mock.mock import MagicMock\n\tfrom up_msgs import srv as srvs\n\tfrom up4ros.up4ros_node import UP4ROSNode\n\tdef test_new_problem():\n\t    node_test = UP4ROSNode(init_ros_interfaces=False)\n\t    # prepare the magic mock\n", "    service_mock = MagicMock()\n\t    node_test._new_problem = service_mock\n\t    req = srvs.NewProblemRequest()\n\t    req.problem_name = \"problem_test_1\"\n\t    response = node_test.new_problem(req)\n\t    assert response.success\n\t    assert response.message == \"\"\n\t    srv = srvs.NewProblemRequest()\n\t    srv.problem_name = \"problem_test_1\"\n\t    response = node_test.new_problem(req)\n", "    assert not response.success\n\t    assert response.message == \"Problem problem_test_1 already exists\"\n"]}
{"filename": "up4ros/tests/test_plan_one_shot_action.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom mock.mock import MagicMock\n\tfrom unified_planning.test.examples import get_example_problems\n\tfrom up_msgs import msg as msgs\n\tfrom up4ros.ros_interface_reader import ROSInterfaceReader\n\tfrom up4ros.ros_interface_writer import ROSInterfaceWriter\n\tfrom up4ros.up4ros_node import UP4ROSNode\n", "def test_plan_robot():\n\t    node_test = UP4ROSNode(init_ros_interfaces=False)\n\t    # prepare the magic mock\n\t    action_server_mock = MagicMock()\n\t    problems = get_example_problems()\n\t    problem = problems[\"robot\"].problem\n\t    pb_writter = ROSInterfaceWriter()\n\t    goal_msg = msgs.PlanOneShotGoal()\n\t    goal_msg.plan_request.problem = pb_writter.convert(problem)\n\t    def feedback_mock(feedback_msg):\n", "        pb_reader = ROSInterfaceReader()\n\t        upf_plan = pb_reader.convert(feedback_msg.plan_result.plan, problem)\n\t        good_plan = \"[move(l1, l2)]\"\n\t        assert upf_plan.__repr__() == good_plan\n\t    action_server_mock.publish_feedback = feedback_mock\n\t    # let's now replace the action server and plan\n\t    node_test._plan_one_shot_server = action_server_mock\n\t    node_test.plan_one_shot_callback(goal_msg)\n\t    expected_result = msgs.PlanOneShotResult()\n\t    expected_result.success = True\n", "    expected_result.message = \"\"\n\t    action_server_mock.set_succeeded.assert_called_with(expected_result)\n"]}
{"filename": "up4ros/tests/test_pddl_plan_one_shot_action.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom mock.mock import MagicMock\n\tfrom unified_planning.io.pddl_reader import PDDLReader\n\tfrom up_msgs import msg as msgs\n\tfrom up4ros.ros_interface_reader import ROSInterfaceReader\n\tfrom up4ros.test_utils import get_domain_and_problem\n\tfrom up4ros.up4ros_node import UP4ROSNode\n", "def test_plan_from_file_pddl_no_tt():\n\t    node_test = UP4ROSNode(init_ros_interfaces=False)\n\t    # prepare the magic mock\n\t    action_server_mock = MagicMock()\n\t    goal_msg = msgs.PDDLPlanOneShotGoal()\n\t    goal_msg.plan_request.mode = msgs.PDDLPlanRequest.FILE\n\t    domain, problem = get_domain_and_problem(\n\t        \"pddl/gripper_domain.pddl\", \"pddl/gripper_problem_0.pddl\"\n\t    )\n\t    goal_msg.plan_request.domain = domain\n", "    goal_msg.plan_request.problem = problem\n\t    # let's mock the publish_feedback method\n\t    reader = PDDLReader()\n\t    upf_problem = reader.parse_problem(\n\t        goal_msg.plan_request.domain, goal_msg.plan_request.problem\n\t    )\n\t    def feedback_mock(msg):\n\t        pb_reader = ROSInterfaceReader()\n\t        upf_plan = pb_reader.convert(msg.plan_result.plan, upf_problem)\n\t        good_plans = [\n", "            \"[pick(ball1, rooma, right), move(rooma, roomb), drop(ball1, roomb, right)]\",\n\t            \"[pick(ball1, rooma, left), move(rooma, roomb), drop(ball1, roomb, left)]\",\n\t        ]\n\t        assert upf_plan.__repr__() in good_plans\n\t    action_server_mock.publish_feedback = feedback_mock\n\t    # let's now replace the action server and plan\n\t    node_test._pddl_plan_one_shot_server = action_server_mock\n\t    node_test.pddl_plan_one_shot_callback(goal_msg)\n\t    expected_result = msgs.PDDLPlanOneShotResult()\n\t    expected_result.success = True\n", "    expected_result.message = \"\"\n\t    action_server_mock.set_succeeded.assert_called_with(expected_result)\n\tdef test_plan_from_file_pddl_tt():\n\t    node_test = UP4ROSNode(init_ros_interfaces=False)\n\t    # prepare the magic mock\n\t    action_server_mock = MagicMock()\n\t    goal_msg = msgs.PDDLPlanOneShotGoal()\n\t    goal_msg.plan_request.mode = msgs.PDDLPlanRequest.FILE\n\t    domain, problem = get_domain_and_problem(\n\t        \"/pddl/domain_tt.pddl\", \"/pddl/problem_tt_1.pddl\"\n", "    )\n\t    goal_msg.plan_request.domain = domain\n\t    goal_msg.plan_request.problem = problem\n\t    # let's mock the publish_feedback method\n\t    reader = PDDLReader()\n\t    upf_problem = reader.parse_problem(\n\t        goal_msg.plan_request.domain, goal_msg.plan_request.problem\n\t    )\n\t    def feedback_mock(msg):\n\t        pb_reader = ROSInterfaceReader()\n", "        upf_plan = pb_reader.convert(msg.plan_result.plan, upf_problem)\n\t        good_plan = \"[(Fraction(0, 1), move(leia, kitchen, bedroom), Fraction(5, 1))]\"\n\t        assert upf_plan.__repr__() == good_plan\n\t    action_server_mock.publish_feedback = feedback_mock\n\t    # let's now replace the action server and plan\n\t    node_test._pddl_plan_one_shot_server = action_server_mock\n\t    node_test.pddl_plan_one_shot_callback(goal_msg)\n\t    expected_result = msgs.PDDLPlanOneShotResult()\n\t    expected_result.success = True\n\t    expected_result.message = \"\"\n", "    action_server_mock.set_succeeded.assert_called_with(expected_result)\n"]}
{"filename": "up4ros/tests/test_set_and_add_fluent_service.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom unified_planning import model\n\tfrom unified_planning import shortcuts\n\tfrom unified_planning.test.examples import get_example_problems\n\tfrom up_msgs import msg as msgs\n\tfrom up_msgs import srv as srvs\n\tfrom up4ros.ros_interface_reader import ROSInterfaceReader\n", "from up4ros.ros_interface_writer import ROSInterfaceWriter\n\tfrom up4ros.up4ros_node import UP4ROSNode\n\tdef test_add_set_fluent():\n\t    node_test = UP4ROSNode(init_ros_interfaces=False)\n\t    pb_writer = ROSInterfaceWriter()\n\t    problems = get_example_problems()\n\t    problem = problems[\"robot\"].problem\n\t    srv = srvs.SetProblemRequest()\n\t    srv.problem_name = \"problem_test_robot\"\n\t    srv.problem = pb_writer.convert(problem)\n", "    response = node_test.set_problem(srv)\n\t    assert response.success\n\t    assert response.message == \"\"\n\t    Location = shortcuts.UserType(\"Location\")\n\t    robot_at = model.Fluent(\"robot_at_bis\", shortcuts.BoolType(), l=Location)\n\t    add_fluent_req = srvs.AddFluentRequest()\n\t    add_fluent_req.problem_name = \"problem_test_robot\"\n\t    add_fluent_req.fluent = pb_writer.convert(robot_at, problem)\n\t    item = msgs.ExpressionItem()\n\t    item.atom.append(msgs.Atom())\n", "    item.atom[0].boolean_atom.append(False)\n\t    item.type = \"up:bool\"\n\t    item.kind = msgs.ExpressionItem.CONSTANT\n\t    value = msgs.Expression()\n\t    value.expressions.append(item)\n\t    value.level = [0]\n\t    add_fluent_req.default_value = value\n\t    add_fluent_response = node_test.add_fluent(add_fluent_req)\n\t    assert add_fluent_response.success\n\t    assert add_fluent_response.message == \"\"\n", "    problem.add_fluent(robot_at, default_initial_value=False)\n\t    set_initial_value_req = srvs.SetInitialValueRequest()\n\t    set_initial_value_req.problem_name = \"problem_test_robot\"\n\t    l2 = model.Object(\"l2\", Location)\n\t    set_initial_value_req.expression = pb_writer.convert(robot_at(l2))\n\t    set_initial_value_req.value = value\n\t    set_initial_value_response = node_test.set_initial_value(set_initial_value_req)\n\t    assert set_initial_value_response.success\n\t    assert set_initial_value_response.message == \"\"\n\t    problem.set_initial_value(robot_at(l2), False)\n", "    add_goal_srv = srvs.AddGoalRequest()\n\t    add_goal_srv.problem_name = \"problem_test_robot\"\n\t    l1 = model.Object(\"l1\", Location)\n\t    add_goal_srv.goal.append(msgs.Goal())\n\t    add_goal_srv.goal[0].goal = pb_writer.convert(robot_at(l1))\n\t    add_goal_response = node_test.add_goal(add_goal_srv)\n\t    assert add_goal_response.success\n\t    assert add_goal_response.message == \"\"\n\t    problem.add_goal(robot_at(l1))\n\t    pb_reader = ROSInterfaceReader()\n", "    srv2 = srvs.GetProblemRequest()\n\t    srv2.problem_name = \"problem_test_robot\"\n\t    response2 = node_test.get_problem(srv2)\n\t    assert response2.success\n\t    problem_ret = pb_reader.convert(response2.problem)\n\t    assert problem == problem_ret\n"]}
{"filename": "up4ros/tests/test_add_action_service.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom unified_planning import model\n\tfrom unified_planning import shortcuts\n\tfrom unified_planning.test.examples import get_example_problems\n\tfrom up_msgs import srv as srvs\n\tfrom up4ros.ros_interface_reader import ROSInterfaceReader\n\tfrom up4ros.ros_interface_writer import ROSInterfaceWriter\n", "from up4ros.up4ros_node import UP4ROSNode\n\tdef test_add_action():\n\t    node_test = UP4ROSNode(init_ros_interfaces=False)\n\t    pb_writer = ROSInterfaceWriter()\n\t    problems = get_example_problems()\n\t    problem = problems[\"robot\"].problem\n\t    req = srvs.SetProblemRequest()\n\t    req.problem_name = \"problem_test_robot\"\n\t    req.problem = pb_writer.convert(problem)\n\t    response = node_test.set_problem(req)\n", "    assert response.success\n\t    assert response.message == \"\"\n\t    Location = shortcuts.UserType(\"Location\")\n\t    robot_at = model.Fluent(\"robot_at\", shortcuts.BoolType(), l=Location)\n\t    move = model.InstantaneousAction(\"move2\", l_from=Location, l_to=Location)\n\t    l_from = move.parameter(\"l_from\")\n\t    l_to = move.parameter(\"l_to\")\n\t    move.add_precondition(robot_at(l_from))\n\t    move.add_effect(robot_at(l_from), False)\n\t    move.add_effect(robot_at(l_to), True)\n", "    add_action_srv = srvs.AddActionRequest()\n\t    add_action_srv.problem_name = \"problem_test_robot\"\n\t    add_action_srv.action = pb_writer.convert(move)\n\t    add_action_response = node_test.add_action(add_action_srv)\n\t    assert add_action_response.success\n\t    assert add_action_response.message == \"\"\n\t    problem.add_action(move)\n\t    pb_reader = ROSInterfaceReader()\n\t    req2 = srvs.GetProblemRequest()\n\t    req2.problem_name = \"problem_test_robot\"\n", "    response2 = node_test.get_problem(req2)\n\t    assert response2.success\n\t    # Todo understand why this was commented out\n\t    # problem_ret = pb_reader.convert(response2.problem)\n\t    # assert (problem == problem_ret)\n"]}
{"filename": "up4ros/tests/test_add_object_service.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom unified_planning import model\n\tfrom unified_planning import shortcuts\n\tfrom unified_planning.test.examples import get_example_problems\n\tfrom up_msgs import srv as srvs\n\tfrom up4ros.ros_interface_reader import ROSInterfaceReader\n\tfrom up4ros.ros_interface_writer import ROSInterfaceWriter\n", "from up4ros.up4ros_node import UP4ROSNode\n\tdef test_add_object():\n\t    node_test = UP4ROSNode(init_ros_interfaces=False)\n\t    pb_writer = ROSInterfaceWriter()\n\t    problems = get_example_problems()\n\t    problem = problems[\"robot\"].problem\n\t    req = srvs.SetProblemRequest()\n\t    req.problem_name = \"problem_test_robot\"\n\t    req.problem = pb_writer.convert(problem)\n\t    response = node_test.set_problem(req)\n", "    assert response.success\n\t    assert response.message == \"\"\n\t    Location = shortcuts.UserType(\"Location\")\n\t    upf_object = model.Object(\"l3\", Location)\n\t    add_object_req = srvs.AddObjectRequest()\n\t    add_object_req.problem_name = \"problem_test_robot\"\n\t    add_object_req.object = pb_writer.convert(upf_object)\n\t    add_object_response = node_test.add_object(add_object_req)\n\t    assert add_object_response.success\n\t    assert add_object_response.message == \"\"\n", "    # TODO: understand why this was commented out\n\t    #\n\t    # problem.add_object(upf_object)\n\t    #\n\t    # pb_reader = ROSInterfaceReader()\n\t    #\n\t    # req2 = srvs.GetProblemRequest()\n\t    # req2.problem_name = 'problem_test_robot'\n\t    #\n\t    # response2 = node_test.get_problem(req2)\n", "    # assert response2.success\n\t    #\n\t    # problem_ret = pb_reader.convert(response2.problem)\n\t    #\n\t    # assert(problem == problem_ret)\n"]}
{"filename": "up4ros/src/up4ros/__init__.py", "chunked_list": []}
{"filename": "up4ros/src/up4ros/ros_interface_writer.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# This module started from the proto_writer.py module from the\n\t# AIPlan4EU project, with the same license\n\t# type: ignore[valid-type]\n\timport fractions\n\tfrom itertools import product\n\tfrom typing import Dict, List\n", "from unified_planning import model\n\tfrom unified_planning.engines import (\n\t    PlanGenerationResult,\n\t    PlanGenerationResultStatus,\n\t    LogMessage,\n\t    LogLevel,\n\t    CompilerResult,\n\t    ValidationResult,\n\t    ValidationResultStatus,\n\t)\n", "from unified_planning.exceptions import UPException\n\timport unified_planning.model.htn\n\tfrom unified_planning.model.operators import (\n\t    BOOL_OPERATORS,\n\t    IRA_OPERATORS,\n\t    OperatorKind,\n\t    RELATIONS,\n\t)\n\tfrom unified_planning.model.timing import TimepointKind, Interval\n\tfrom unified_planning.model.types import domain_item, domain_size\n", "import unified_planning.model.walkers as walkers\n\tfrom unified_planning.plans import (\n\t    ActionInstance,\n\t    SequentialPlan,\n\t    TimeTriggeredPlan,\n\t    HierarchicalPlan,\n\t)\n\tfrom up4ros.converter import Converter, handles\n\tfrom up_msgs import msg as msgs\n\tdef map_operator(op: int) -> str:\n", "    if op == OperatorKind.PLUS:\n\t        return \"up:plus\"\n\t    elif op == OperatorKind.MINUS:\n\t        return \"up:minus\"\n\t    elif op == OperatorKind.TIMES:\n\t        return \"up:times\"\n\t    elif op == OperatorKind.DIV:\n\t        return \"up:div\"\n\t    elif op == OperatorKind.LE:\n\t        return \"up:le\"\n", "    elif op == OperatorKind.LT:\n\t        return \"up:lt\"\n\t    elif op == OperatorKind.EQUALS:\n\t        return \"up:equals\"\n\t    elif op == OperatorKind.AND:\n\t        return \"up:and\"\n\t    elif op == OperatorKind.OR:\n\t        return \"up:or\"\n\t    elif op == OperatorKind.NOT:\n\t        return \"up:not\"\n", "    elif op == OperatorKind.IMPLIES:\n\t        return \"up:implies\"\n\t    elif op == OperatorKind.IFF:\n\t        return \"up:iff\"\n\t    elif op == OperatorKind.EXISTS:\n\t        return \"up:exists\"\n\t    elif op == OperatorKind.FORALL:\n\t        return \"up:forall\"\n\t    raise ValueError(f\"Unknown operator `{op}`\")\n\tdef interface_type(tpe: model.Type) -> str:\n", "    if tpe.is_bool_type():\n\t        return \"up:bool\"\n\t    elif tpe.is_time_type():\n\t        return \"up:time\"\n\t    elif tpe.is_int_type() or tpe.is_real_type():\n\t        return f\"up:{tpe}\"\n\t    elif isinstance(tpe, model.types._UserType):\n\t        return str(tpe.name)\n\tclass FNode2ROS(walkers.DagWalker):\n\t    def __init__(self, ros2_writer):\n", "        super().__init__()\n\t        self._ros2_writer = ros2_writer\n\t    def convert(self, expression: model.FNode) -> msgs.Expression:\n\t        return self.walk(expression)\n\t    @staticmethod\n\t    def walk_bool_constant(\n\t        expression: model.FNode, args: List[msgs.Expression]\n\t    ) -> msgs.Expression:\n\t        item = msgs.ExpressionItem()\n\t        item.atom.append(msgs.Atom())\n", "        item.atom[0].boolean_atom.append(expression.bool_constant_value())\n\t        item.type = \"up:bool\"\n\t        item.kind = msgs.ExpressionItem.CONSTANT\n\t        ret = msgs.Expression()\n\t        ret.expressions.append(item)\n\t        ret.level = [0]\n\t        return ret\n\t    @staticmethod\n\t    def walk_int_constant(\n\t        expression: model.FNode, args: List[msgs.Expression]\n", "    ) -> msgs.Expression:\n\t        item = msgs.ExpressionItem()\n\t        item.atom.append(msgs.Atom())\n\t        item.atom[0].int_atom.append(expression.int_constant_value())\n\t        item.type = \"up:integer\"\n\t        item.kind = msgs.ExpressionItem.CONSTANT\n\t        ret = msgs.Expression()\n\t        ret.expressions.append(item)\n\t        ret.level = [0]\n\t        return ret\n", "    @staticmethod\n\t    def walk_real_constant(\n\t        expression: model.FNode, args: List[msgs.Expression]\n\t    ) -> msgs.Expression:\n\t        item = msgs.ExpressionItem()\n\t        real = msgs.Real()\n\t        real.numerator = expression.real_constant_value().numerator\n\t        real.denominator = expression.real_constant_value().denominator\n\t        item.atom.append(msgs.Atom())\n\t        item.atom[0].real_atom.append(real)\n", "        item.type = \"up:real\"\n\t        item.kind = msgs.ExpressionItem.CONSTANT\n\t        ret = msgs.Expression()\n\t        ret.expressions.append(item)\n\t        ret.level = [0]\n\t        return ret\n\t    @staticmethod\n\t    def walk_param_exp(\n\t        expression: model.FNode, args: List[msgs.Expression]\n\t    ) -> msgs.Expression:\n", "        item = msgs.ExpressionItem()\n\t        item.atom.append(msgs.Atom())\n\t        item.atom[0].symbol_atom.append(expression.parameter().name)\n\t        item.type = interface_type(expression.parameter().type)\n\t        item.kind = msgs.ExpressionItem.PARAMETER\n\t        ret = msgs.Expression()\n\t        ret.expressions.append(item)\n\t        ret.level = [0]\n\t        return ret\n\t    @staticmethod\n", "    def walk_variable_exp(\n\t        expression: model.FNode, args: List[msgs.Expression]\n\t    ) -> msgs.Expression:\n\t        item = msgs.ExpressionItem()\n\t        s_atom = msgs.Atom()\n\t        s_atom.symbol_atom.append(expression.variable().name)\n\t        item.atom.append(s_atom)\n\t        item.type = interface_type(expression.variable().type)\n\t        item.kind = msgs.ExpressionItem.VARIABLE\n\t        ret = msgs.Expression()\n", "        ret.expressions.append(item)\n\t        ret.level = [0]\n\t        return ret\n\t    @staticmethod\n\t    def walk_object_exp(\n\t        expression: model.FNode, args: List[msgs.Expression]\n\t    ) -> msgs.Expression:\n\t        item = msgs.ExpressionItem()\n\t        item.atom.append(msgs.Atom())\n\t        item.atom[0].symbol_atom.append(expression.object().name)\n", "        item.type = interface_type(expression.object().type)\n\t        item.kind = msgs.ExpressionItem.CONSTANT\n\t        ret = msgs.Expression()\n\t        ret.expressions.append(item)\n\t        ret.level = [0]\n\t        return ret\n\t    def walk_timing_exp(\n\t        self, expression: model.FNode, args: List[msgs.Expression]\n\t    ) -> msgs.Expression:\n\t        timing = expression.timing()\n", "        tp = timing.timepoint\n\t        if timing.timepoint.container is not None:\n\t            item = msgs.ExpressionItem()\n\t            atom = msgs.Atom()\n\t            atom.symbol_atom.append(timing.timepoint.container)\n\t            item.atom.append(atom)\n\t            item.type = \"up:container\"\n\t            item.kind = msgs.ExpressionItem.CONTAINER_ID\n\t            expr = msgs.Expression()\n\t            expr.expressions.append(item)\n", "            expr.level = bytearray(expr.level) + bytearray([0])\n\t            args = [expr]\n\t        else:\n\t            args = []\n\t        if tp.kind == TimepointKind.GLOBAL_START:\n\t            fn = \"up:global_start\"\n\t        elif tp.kind == TimepointKind.GLOBAL_END:\n\t            fn = \"up:global_end\"\n\t        elif tp.kind == TimepointKind.START:\n\t            fn = \"up:start\"\n", "        elif tp.kind == TimepointKind.END:\n\t            fn = \"up:end\"\n\t        else:\n\t            raise ValueError(f\"Unknown timepoint kind: {tp.kind}\")\n\t        fn_exp_item = msgs.ExpressionItem()\n\t        fn_atom = msgs.Atom()\n\t        fn_atom.symbol_atom.append(fn)\n\t        fn_exp_item.atom.append(fn_atom)\n\t        fn_exp_item.kind = msgs.ExpressionItem.FUNCTION_SYMBOL\n\t        tp_exp = msgs.Expression()\n", "        tp_exp.expressions.append(msgs.ExpressionItem())\n\t        tp_exp.level = bytearray(tp_exp.level) + bytearray([0])\n\t        tp_exp.expressions[0].kind = msgs.ExpressionItem.FUNCTION_APPLICATION\n\t        tp_exp.expressions[0].type = \"up:time\"\n\t        tp_exp.expressions.append(fn_exp_item)\n\t        tp_exp.level = bytearray(tp_exp.level) + bytearray([1])\n\t        (other_expr, other_levels) = self.increase_level_expressions(args, 1)\n\t        tp_exp.expressions.extend(other_expr)\n\t        tp_exp.level = bytearray(tp_exp.level) + bytearray(other_levels)\n\t        assert timing.delay == 0\n", "        return tp_exp\n\t    @staticmethod\n\t    def increase_level_expressions(\n\t        expressions: List[msgs.Expression], base_level: int\n\t    ) -> (List[msgs.ExpressionItem], List[int]):\n\t        ret_expr = []\n\t        ret_levels = []\n\t        for expr in expressions:\n\t            ret_expr.extend(expr.expressions)\n\t            for level in expr.level:\n", "                ret_levels.append(level + base_level)\n\t        return ret_expr, ret_levels\n\t    def walk_fluent_exp(\n\t        self, expression: model.FNode, args: List[msgs.Expression]\n\t    ) -> msgs.Expression:\n\t        ret = msgs.Expression()\n\t        item_root = msgs.ExpressionItem()\n\t        item_root.type = interface_type(expression.fluent().type)\n\t        item_root.kind = msgs.ExpressionItem.STATE_VARIABLE\n\t        ret.expressions.append(item_root)\n", "        ret.level = [0]\n\t        item = msgs.ExpressionItem()\n\t        item.atom.append(msgs.Atom())\n\t        item.atom[0].symbol_atom.append(expression.fluent().name)\n\t        item.type = interface_type(expression.fluent().type)\n\t        item.kind = msgs.ExpressionItem.FLUENT_SYMBOL\n\t        ret.expressions.append(item)\n\t        ret.level = bytearray(ret.level) + bytearray([1])\n\t        (extended_expr, extended_levels) = self.increase_level_expressions(args, 1)\n\t        ret.expressions.extend(extended_expr)\n", "        ret.level = bytearray(ret.level) + bytearray(extended_levels)\n\t        return ret\n\t    @walkers.handles(BOOL_OPERATORS.union(IRA_OPERATORS).union(RELATIONS))\n\t    def walk_operator(\n\t        self, expression: model.FNode, args: List[msgs.Expression]\n\t    ) -> msgs.Expression:\n\t        sub_list = []\n\t        expr_item = msgs.ExpressionItem()\n\t        expr_item.atom.append(msgs.Atom())\n\t        expr_item.atom[0].symbol_atom.append(map_operator(expression.node_type))\n", "        expr_item.kind = msgs.ExpressionItem.FUNCTION_SYMBOL\n\t        expr_item.type = \"up:operator\"\n\t        sub_list.append(expr_item)\n\t        # forall/exists: add the declared variables from the payload to\n\t        # the beginning of the parameter list.\n\t        other_expr = []\n\t        other_levels = []\n\t        if expression.is_exists() or expression.is_forall():\n\t            list_prev = [self._ros2_writer.convert(p) for p in expression.variables()]\n\t            (other_expr, other_levels) = self.increase_level_expressions(list_prev, 1)\n", "        (args_expr, args_level) = self.increase_level_expressions(args, 1)\n\t        ret = msgs.Expression()\n\t        ret.expressions.append(msgs.ExpressionItem())\n\t        ret.level = [0]\n\t        ret.expressions[0].kind = msgs.ExpressionItem.FUNCTION_APPLICATION\n\t        ret.expressions[0].type = \"\"\n\t        ret.expressions.append(expr_item)\n\t        ret.level = bytearray(ret.level) + bytearray([1])\n\t        ret.expressions.extend(other_expr)\n\t        ret.level.extend(other_levels)\n", "        ret.expressions.extend(args_expr)\n\t        ret.level = bytearray(ret.level) + bytearray(args_level)\n\t        return ret\n\tmap_features = {\n\t    \"ACTION_BASED\": msgs.Problem.ACTION_BASED,\n\t    \"HIERARCHICAL\": msgs.Problem.HIERARCHICAL,\n\t    \"SIMPLE_NUMERIC_PLANNING\": msgs.Problem.SIMPLE_NUMERIC_PLANNING,\n\t    \"GENERAL_NUMERIC_PLANNING\": msgs.Problem.GENERAL_NUMERIC_PLANNING,\n\t    \"CONTINUOUS_TIME\": msgs.Problem.CONTINUOUS_TIME,\n\t    \"DISCRETE_TIME\": msgs.Problem.DISCRETE_TIME,\n", "    \"INTERMEDIATE_CONDITIONS_AND_EFFECTS\": msgs.Problem.INTERMEDIATE_CONDITIONS_AND_EFFECTS,\n\t    \"TIMED_EFFECT\": msgs.Problem.TIMED_EFFECT,\n\t    \"TIMED_GOALS\": msgs.Problem.TIMED_GOALS,\n\t    \"DURATION_INEQUALITIES\": msgs.Problem.DURATION_INEQUALITIES,\n\t    \"STATIC_FLUENTS_IN_DURATIONS\": msgs.Problem.STATIC_FLUENTS_IN_DURATIONS,\n\t    \"FLUENTS_IN_DURATIONS\": msgs.Problem.FLUENTS_IN_DURATIONS,\n\t    \"CONTINUOUS_NUMBERS\": msgs.Problem.CONTINUOUS_NUMBERS,\n\t    \"DISCRETE_NUMBERS\": msgs.Problem.DISCRETE_NUMBERS,\n\t    \"BOUNDED_TYPES\": msgs.Problem.BOUNDED_TYPES,\n\t    \"NEGATIVE_CONDITIONS\": msgs.Problem.NEGATIVE_CONDITIONS,\n", "    \"DISJUNCTIVE_CONDITIONS\": msgs.Problem.DISJUNCTIVE_CONDITIONS,\n\t    \"EQUALITIES\": msgs.Problem.EQUALITIES,\n\t    \"EXISTENTIAL_CONDITIONS\": msgs.Problem.EXISTENTIAL_CONDITIONS,\n\t    \"UNIVERSAL_CONDITIONS\": msgs.Problem.UNIVERSAL_CONDITIONS,\n\t    \"CONDITIONAL_EFFECTS\": msgs.Problem.CONDITIONAL_EFFECTS,\n\t    \"INCREASE_EFFECTS\": msgs.Problem.INCREASE_EFFECTS,\n\t    \"DECREASE_EFFECTS\": msgs.Problem.DECREASE_EFFECTS,\n\t    \"STATIC_FLUENTS_IN_BOOLEAN_ASSIGNMENTS\": msgs.Problem.STATIC_FLUENTS_IN_BOOLEAN_ASSIGNMENTS,\n\t    \"STATIC_FLUENTS_IN_NUMERIC_ASSIGNMENTS\": msgs.Problem.STATIC_FLUENTS_IN_NUMERIC_ASSIGNMENTS,\n\t    \"FLUENTS_IN_BOOLEAN_ASSIGNMENTS\": msgs.Problem.FLUENTS_IN_BOOLEAN_ASSIGNMENTS,\n", "    \"FLUENTS_IN_NUMERIC_ASSIGNMENTS\": msgs.Problem.FLUENTS_IN_NUMERIC_ASSIGNMENTS,\n\t    \"FLAT_TYPING\": msgs.Problem.FLAT_TYPING,\n\t    \"HIERARCHICAL_TYPING\": msgs.Problem.HIERARCHICAL_TYPING,\n\t    \"NUMERIC_FLUENTS\": msgs.Problem.NUMERIC_FLUENTS,\n\t    \"OBJECT_FLUENTS\": msgs.Problem.OBJECT_FLUENTS,\n\t    \"ACTIONS_COST\": msgs.Problem.ACTIONS_COST,\n\t    \"FINAL_VALUE\": msgs.Problem.FINAL_VALUE,\n\t    \"MAKESPAN\": msgs.Problem.MAKESPAN,\n\t    \"PLAN_LENGTH\": msgs.Problem.PLAN_LENGTH,\n\t    \"OVERSUBSCRIPTION\": msgs.Problem.OVERSUBSCRIPTION,\n", "    \"STATIC_FLUENTS_IN_ACTIONS_COST\": msgs.Problem.STATIC_FLUENTS_IN_ACTIONS_COST,\n\t    \"FLUENTS_IN_ACTIONS_COST\": msgs.Problem.FLUENTS_IN_ACTIONS_COST,\n\t    \"SIMULATED_EFFECTS\": msgs.Problem.SIMULATED_EFFECTS,\n\t}\n\tdef map_feature(feature: str) -> int:\n\t    pb_feature = map_features[feature]\n\t    if pb_feature is None:\n\t        raise ValueError(f\"Cannot convert feature to protobuf {feature}\")\n\t    return pb_feature\n\tclass ROSInterfaceWriter(Converter):\n", "    \"\"\"Class to convert from unified_planning Problem instance to ROS 2 Interfaces.\"\"\"\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._fnode2ros2 = FNode2ROS(self)\n\t    @handles(model.Fluent)\n\t    def _convert_fluent(\n\t        self, fluent: model.Fluent, problem: model.Problem\n\t    ) -> msgs.Fluent:\n\t        name = fluent.name\n\t        sig = [self.convert(t) for t in fluent.signature]\n", "        ret = msgs.Fluent()\n\t        ret.name = name\n\t        ret.value_type = interface_type(fluent.type)\n\t        ret.parameters = sig\n\t        if fluent in problem.fluents_defaults:\n\t            ret.default_value.append(self.convert(problem.fluents_defaults[fluent]))\n\t        return ret\n\t    @handles(model.Object)\n\t    def _convert_object(self, obj: model.Object) -> msgs.ObjectDeclaration:\n\t        ret = msgs.ObjectDeclaration()\n", "        ret.name = obj.name\n\t        ret.type = interface_type(obj.type)\n\t        return ret\n\t    @handles(model.FNode)\n\t    def _convert_fnode(self, exp: model.FNode) -> msgs.Expression:\n\t        return self._fnode2ros2.convert(exp)\n\t    @handles(model.types._BoolType)\n\t    def _convert_bool_type(self, tpe: model.types._BoolType) -> msgs.TypeDeclaration:\n\t        ret = msgs.TypeDeclaration()\n\t        ret.type_name = interface_type(tpe)\n", "        return ret\n\t    @handles(model.types._UserType)\n\t    def _convert_user_type(self, t: model.types._UserType) -> msgs.TypeDeclaration:\n\t        ret = msgs.TypeDeclaration()\n\t        ret.type_name = interface_type(t)\n\t        ret.parent_type = \"\" if t.father is None else interface_type(t.father)\n\t        return ret\n\t    @handles(model.types._IntType)\n\t    def _convert_integer_type(self, t: model.types._IntType) -> msgs.TypeDeclaration:\n\t        ret = msgs.TypeDeclaration()\n", "        ret.type_name = interface_type(t)\n\t        return ret\n\t    @handles(model.types._RealType)\n\t    def _convert_real(self, t: model.types._RealType) -> msgs.TypeDeclaration:\n\t        ret = msgs.TypeDeclaration()\n\t        ret.type_name = interface_type(t)\n\t        return ret\n\t    @handles(model.Effect)\n\t    def _convert_effect(self, effect: model.Effect) -> msgs.EffectExpression:\n\t        if effect.is_assignment():\n", "            kind = msgs.EffectExpression.ASSIGN\n\t        elif effect.is_increase():\n\t            kind = msgs.EffectExpression.INCREASE\n\t        elif effect.is_decrease():\n\t            kind = msgs.EffectExpression.DECREASE\n\t        else:\n\t            raise ValueError(f\"Unsupported effect: {effect}\")\n\t        ret = msgs.EffectExpression()\n\t        ret.kind = kind\n\t        ret.fluent = self.convert(effect.fluent)\n", "        ret.value = self.convert(effect.value)\n\t        ret.condition = self.convert(effect.condition)\n\t        return ret\n\t    @handles(model.InstantaneousAction)\n\t    def _convert_instantaneous_action(\n\t        self, a: model.InstantaneousAction\n\t    ) -> msgs.Action:\n\t        effects = []\n\t        conditions = []\n\t        for cond in a.preconditions:\n", "            r2cond = msgs.Condition()\n\t            r2cond.cond = self.convert(cond)\n\t            conditions.append(r2cond)\n\t        for eff in a.effects:\n\t            r2eff = msgs.Effect()\n\t            r2eff.effect = self.convert(eff)\n\t            effects.append(r2eff)\n\t        ret = msgs.Action()\n\t        ret.name = a.name\n\t        ret.parameters = [self.convert(p) for p in a.parameters]\n", "        ret.conditions = conditions\n\t        ret.effects = effects\n\t        return ret\n\t    @handles(model.DurativeAction)\n\t    def _convert_durative_action(self, a: model.DurativeAction) -> msgs.Action:\n\t        effects = []\n\t        conditions = []\n\t        for span, cond in a.conditions.items():\n\t            span = self.convert(span)\n\t            for c in cond:\n", "                new_cond = msgs.Condition()\n\t                new_cond.cond = self.convert(c)\n\t                new_cond.span.append(span)\n\t                conditions.append(new_cond)\n\t        for ot, eff in a.effects.items():\n\t            ot = self.convert(ot)\n\t            for e in eff:\n\t                new_eff = msgs.Effect()\n\t                new_eff.effect = self.convert(e)\n\t                new_eff.occurrence_time.append(ot)\n", "                effects.append(new_eff)\n\t        ret = msgs.Action()\n\t        ret.name = a.name\n\t        ret.parameters = [self.convert(p) for p in a.parameters]\n\t        ret.duration.append(self.convert(a.duration))\n\t        ret.conditions = conditions\n\t        ret.effects = effects\n\t        return ret\n\t    @handles(model.timing.Timepoint)\n\t    def _convert_timepoint(self, tp: model.timing.Timepoint) -> msgs.Timepoint:\n", "        if tp.kind == TimepointKind.START:\n\t            kind = msgs.Timepoint.START\n\t        elif tp.kind == TimepointKind.END:\n\t            kind = msgs.Timepoint.END\n\t        elif tp.kind == TimepointKind.GLOBAL_START:\n\t            kind = msgs.Timepoint.GLOBAL_START\n\t        elif tp.kind == TimepointKind.GLOBAL_END:\n\t            kind = msgs.Timepoint.GLOBAL_END\n\t        else:\n\t            raise ValueError(f\"Unsupported time point kind: {tp.kind}\")\n", "        ret = msgs.Timepoint()\n\t        ret.kind = kind\n\t        if tp.container is not None:\n\t            ret.container_id = tp.container\n\t        return ret\n\t    @handles(model.Timing)\n\t    def _convert_timing(self, timing: model.Timing) -> msgs.Timing:\n\t        ret = msgs.Timing()\n\t        ret.timepoint = self.convert(timing._timepoint)\n\t        ret.delay.append(self.convert(fractions.Fraction(timing.delay)))\n", "        return ret\n\t    @handles(fractions.Fraction)\n\t    def _convert_fraction(self, fraction: fractions.Fraction) -> msgs.Real:\n\t        ret = msgs.Real()\n\t        ret.numerator = fraction.numerator\n\t        ret.denominator = fraction.denominator\n\t        return ret\n\t    @handles(Interval)\n\t    def _convert_interval(self, interval: Interval) -> msgs.Interval:\n\t        ret = msgs.Interval()\n", "        ret.is_left_open = interval.is_left_open()\n\t        ret.lower = self.convert(interval.lower())\n\t        ret.is_right_open = interval.is_right_open()\n\t        ret.upper = self.convert(interval.lower())\n\t        return ret\n\t    @handles(model.TimeInterval)\n\t    def _convert_time_interval(self, interval: model.TimeInterval) -> msgs.TimeInterval:\n\t        ret = msgs.TimeInterval()\n\t        ret.is_left_open = interval.is_left_open()\n\t        ret.lower = self.convert(interval.lower)\n", "        ret.is_right_open = interval.is_right_open()\n\t        ret.upper = self.convert(interval.upper)\n\t        return ret\n\t    @handles(model.DurationInterval)\n\t    def _convert_duration_interval(\n\t        self, interval: model.DurationInterval\n\t    ) -> msgs.Duration:\n\t        ret = msgs.Duration()\n\t        ret.controllable_in_bounds.is_left_open = interval.is_left_open()\n\t        ret.controllable_in_bounds.lower = self.convert(interval.lower)\n", "        ret.controllable_in_bounds.is_right_open = interval.is_right_open()\n\t        ret.controllable_in_bounds.upper = self.convert(interval.upper)\n\t        return ret\n\t    @handles(model.htn.Task)\n\t    def _convert_abstract_task(\n\t        self, task: model.htn.Task\n\t    ) -> msgs.AbstractTaskDeclaration:\n\t        ret = msgs.AbstractTaskDeclaration()\n\t        ret.name = task.name\n\t        ret.parameters = [self.convert(p) for p in task.parameters]\n", "        return ret\n\t    @handles(model.htn.ParameterizedTask)\n\t    def _convert_parameterized_task(\n\t        self, task: model.htn.ParameterizedTask\n\t    ) -> msgs.Task:\n\t        parameters = []\n\t        for p in task.parameters:\n\t            expr = msgs.Expression()\n\t            aux = msgs.ExpressionItem()\n\t            aux.atom.append(msgs.Atom())\n", "            aux.atom[0].symbol_atom.append(p.name)\n\t            aux.kind = msgs.ExpressionItem.PARAMETER\n\t            aux.type = interface_type(p.type)\n\t            expr.expressions.append(aux)\n\t            expr.level = bytearray(expr.level) + bytearray([0])\n\t            parameters.append(expr)\n\t        ret = msgs.Task()\n\t        ret.id = \"\"\n\t        ret.task_name = task.task.name\n\t        ret.parameters = parameters\n", "        return ret\n\t    @handles(model.htn.Subtask)\n\t    def _convert_subtask(self, subtask: model.htn.Subtask) -> msgs.Task:\n\t        ret = msgs.Task()\n\t        ret.id = subtask.identifier\n\t        ret.task_name = subtask.task.name\n\t        ret.parameters = [self.convert(p) for p in subtask.parameters]\n\t        return ret\n\t    @handles(model.htn.Method)\n\t    def _convert_method(self, method: model.htn.Method) -> msgs.Method:\n", "        ret = msgs.Method()\n\t        ret.name = method.name\n\t        ret.parameters = [self.convert(p) for p in method.parameters]\n\t        ret.achieved_task = self.convert(method.achieved_task)\n\t        ret.subtasks = [self.convert(st) for st in method.subtasks]\n\t        ret.constraints = [self.convert(c) for c in method.constraints]\n\t        for c in method.preconditions:\n\t            cond = msgs.Condition()\n\t            cond.cond = self.convert(c)\n\t            ret.conditions.append(cond)\n", "        return ret\n\t    @handles(model.htn.TaskNetwork)\n\t    def _convert_task_network(self, tn: model.htn.TaskNetwork) -> msgs.TaskNetwork:\n\t        ret = msgs.TaskNetwork()\n\t        ret.variables = [self.convert(v) for v in tn.variables]\n\t        ret.subtasks = [self.convert(st) for st in tn.subtasks]\n\t        ret.constraints = [self.convert(c) for c in tn.constraints]\n\t        return ret\n\t    def build_hierarchy(self, problem: model.htn.HierarchicalProblem) -> msgs.Hierarchy:\n\t        ret = msgs.Hierarchy()\n", "        ret.initial_task_network = self.convert(problem.task_network)\n\t        ret.abstract_tasks = [self.convert(t) for t in problem.tasks]\n\t        ret.methods = [self.convert(m) for m in problem.methods]\n\t        return ret\n\t    @handles(model.Problem, model.htn.HierarchicalProblem)\n\t    def _convert_problem(self, problem: model.Problem) -> msgs.Problem:\n\t        goals = [msgs.Goal(goal=self.convert(g)) for g in problem.goals]\n\t        for (t, gs) in problem.timed_goals:\n\t            for g in gs:\n\t                goal = msgs.Goal()\n", "                goal.goal = self.convert(g)\n\t                goal.timing.append(self.convert(t))\n\t                goals += [goal]\n\t        problem_name = str(problem.name) if problem.name is not None else \"\"\n\t        hierarchy = []\n\t        if isinstance(problem, model.htn.HierarchicalProblem):\n\t            hierarchy.append(self.build_hierarchy(problem))\n\t        ret = msgs.Problem()\n\t        ret.domain_name = problem_name + \"_domain\"\n\t        ret.problem_name = problem_name\n", "        ret.types = [self.convert(t) for t in problem.user_types]\n\t        ret.fluents = [self.convert(f, problem) for f in problem.fluents]\n\t        ret.objects = [self.convert(o) for o in problem.all_objects]\n\t        ret.actions = [self.convert(a) for a in problem.actions]\n\t        for (x, v) in problem.initial_values.items():\n\t            assignment = msgs.Assignment()\n\t            assignment.fluent = self.convert(x)\n\t            assignment.value = self.convert(v)\n\t            ret.initial_state.append(assignment)\n\t        ret.timed_effects = [self.convert(e) for e in problem.timed_effects]\n", "        ret.goals = goals\n\t        ret.features = [map_feature(feature) for feature in problem.kind.features]\n\t        ret.metrics = [self.convert(m) for m in problem.quality_metrics]\n\t        ret.hierarchy = hierarchy\n\t        return ret\n\t    @handles(model.metrics.MinimizeActionCosts)\n\t    def _convert_minimize_action_costs(\n\t        self, metric: model.metrics.MinimizeActionCosts\n\t    ) -> msgs.Metric:\n\t        action_costs = {}\n", "        for action, cost in metric.costs.items():\n\t            action_costs[action.name] = self.convert(cost)\n\t        ret = msgs.Metric()\n\t        ret.kind = msgs.Metric.MINIMIZE_ACTION_COSTS\n\t        ret.action_cost_names = action_costs.keys()\n\t        ret.action_cost_expr = list(action_costs.values())\n\t        if metric.default is not None:\n\t            ret.default_action_cost.append(self.convert(metric.default))\n\t        return ret\n\t    @handles(model.metrics.MinimizeSequentialPlanLength)\n", "    def _convert_minimize_sequential_plan_length(self, _) -> msgs.Metric:\n\t        ret = msgs.Metric()\n\t        ret.kind = msgs.Metric.MINIMIZE_SEQUENTIAL_PLAN_LENGTH\n\t        return ret\n\t    @handles(model.metrics.MinimizeMakespan)\n\t    def _convert_minimize_makespan(self, _) -> msgs.Metric:\n\t        ret = msgs.Metric()\n\t        ret.kind = msgs.Metric.MINIMIZE_MAKESPAN\n\t        return ret\n\t    @handles(model.metrics.MinimizeExpressionOnFinalState)\n", "    def _convert_minimize_expression_on_final_state(\n\t        self, metric: model.metrics.MinimizeExpressionOnFinalState\n\t    ) -> msgs.Metric:\n\t        ret = msgs.Metric()\n\t        ret.kind = msgs.Metric.MINIMIZE_EXPRESSION_ON_FINAL_STATE\n\t        ret.expression = self.convert(metric.expression)\n\t        return ret\n\t    @handles(model.metrics.MaximizeExpressionOnFinalState)\n\t    def _convert_maximize_expression_on_final_state(\n\t        self, metric: model.metrics.MaximizeExpressionOnFinalState\n", "    ) -> msgs.Metric:\n\t        ret = msgs.Metric()\n\t        ret.kind = msgs.Metric.MAXIMIZE_EXPRESSION_ON_FINAL_STATE\n\t        ret.expression = self.convert(metric.expression)\n\t        return ret\n\t    @handles(model.metrics.Oversubscription)\n\t    def _convert_oversubscription_metric(\n\t        self, metric: model.metrics.Oversubscription\n\t    ) -> msgs.Metric:\n\t        goals = []\n", "        for g, c in metric.goals.items():\n\t            goal = msgs.GoalWithCost()\n\t            goal.goal = self.convert(g)\n\t            goal.cost = self.convert(fractions.Fraction(c))\n\t            goals.append(goal)\n\t        ret = msgs.Metric()\n\t        ret.kind = msgs.Metric.OVERSUBSCRIPTION\n\t        ret.goals = goals\n\t        return ret\n\t    @handles(model.Parameter)\n", "    def _convert_action_parameter(self, p: model.Parameter) -> msgs.Parameter:\n\t        ret = msgs.Parameter()\n\t        ret.name = p.name\n\t        ret.type = interface_type(p.type)\n\t        return ret\n\t    @handles(model.Variable)\n\t    def _convert_expression_variable(self, variable: model.Variable) -> msgs.Expression:\n\t        ret = msgs.Expression()\n\t        ret.expressions.append(msgs.ExpressionItem())\n\t        ret.level = [0]\n", "        ret.expressions[0].atom.append(msgs.Atom())\n\t        ret.expressions[0].atom[0].symbol_atom.append(variable.name)\n\t        ret.expressions[0].kind = msgs.ExpressionItem.VARIABLE\n\t        ret.expressions[0].type = interface_type(variable.type)\n\t        return ret\n\t    @handles(ActionInstance)\n\t    def _convert_action_instance(\n\t        self, a: ActionInstance, start_time=None, end_time=None\n\t    ) -> msgs.ActionInstance:\n\t        parameters = []\n", "        for param in a.actual_parameters:\n\t            # The parameters are atoms\n\t            parameters.append(self.convert(param).expressions[0].atom[0])\n\t        ret = msgs.ActionInstance()\n\t        ret.action_name = a.action.name\n\t        ret.parameters = parameters\n\t        if bool(start_time) and bool(end_time):\n\t            ret.start_time = start_time\n\t            ret.end_time = end_time\n\t            ret.time_triggered = True\n", "        else:\n\t            ret.time_triggered = False\n\t        return ret\n\t    @handles(str)\n\t    def _convert_str_atom(self, s: str) -> msgs.Atom:\n\t        ret = msgs.Atom()\n\t        ret.symbol_atom = [s]\n\t        return ret\n\t    @handles(SequentialPlan)\n\t    def _convert_sequential_plan(self, plan: SequentialPlan) -> msgs.Plan:\n", "        ret = msgs.Plan()\n\t        ret.actions = [self.convert(a) for a in plan.actions]\n\t        return ret\n\t    @handles(TimeTriggeredPlan)\n\t    def _convert_time_triggered_plan(self, plan: TimeTriggeredPlan) -> msgs.Plan:\n\t        action_instances = []\n\t        for a in plan.timed_actions:\n\t            start_time = self.convert(a[0])\n\t            end_time = self.convert(a[0] + a[2])\n\t            instance = self._convert_action_instance(\n", "                a[1], start_time=start_time, end_time=end_time\n\t            )\n\t            action_instances.append(instance)\n\t        ret = msgs.Plan()\n\t        ret.actions = action_instances\n\t        return ret\n\t    @handles(HierarchicalPlan)\n\t    def _convert_hierarchical_plan(self, plan: HierarchicalPlan) -> msgs.Plan:\n\t        # FIXME: TO BE IMPLEMENTED\n\t        return None\n", "    @handles(PlanGenerationResult)\n\t    def _convert_plan_generation_result(\n\t        self, result: PlanGenerationResult\n\t    ) -> msgs.PlanGenerationResult:\n\t        log_messages = None\n\t        if result.log_messages is not None:\n\t            log_messages = [self.convert(log) for log in result.log_messages]\n\t        ret = msgs.PlanGenerationResult()\n\t        ret.status = self.convert(result.status)\n\t        ret.plan = self.convert(result.plan)\n", "        ret.engine_name = result.engine_name\n\t        if bool(result.metrics):\n\t            ret.metric_names = list(result.metrics.keys())\n\t            ret.metric_values = list(result.metrics.values())\n\t        if bool(log_messages):\n\t            ret.log_messages = log_messages\n\t        return ret\n\t    @handles(PlanGenerationResultStatus)\n\t    def _convert_plan_generation_status(\n\t        self, status: PlanGenerationResultStatus\n", "    ) -> int:\n\t        if status == PlanGenerationResultStatus.SOLVED_SATISFICING:\n\t            return msgs.PlanGenerationResult.SOLVED_SATISFICING\n\t        elif status == PlanGenerationResultStatus.SOLVED_OPTIMALLY:\n\t            return msgs.PlanGenerationResult.SOLVED_OPTIMALLY\n\t        elif status == PlanGenerationResultStatus.UNSOLVABLE_PROVEN:\n\t            return msgs.PlanGenerationResult.UNSOLVABLE_PROVEN\n\t        elif status == PlanGenerationResultStatus.UNSOLVABLE_INCOMPLETELY:\n\t            return msgs.PlanGenerationResult.UNSOLVABLE_INCOMPLETELY\n\t        elif status == PlanGenerationResultStatus.TIMEOUT:\n", "            return msgs.PlanGenerationResult.TIMEOUT\n\t        elif status == PlanGenerationResultStatus.MEMOUT:\n\t            return msgs.PlanGenerationResult.MEMOUT\n\t        elif status == PlanGenerationResultStatus.INTERNAL_ERROR:\n\t            return msgs.PlanGenerationResult.INTERNAL_ERROR\n\t        elif status == PlanGenerationResultStatus.UNSUPPORTED_PROBLEM:\n\t            return msgs.PlanGenerationResult.UNSUPPORTED_PROBLEM\n\t        elif status == PlanGenerationResultStatus.INTERMEDIATE:\n\t            return msgs.PlanGenerationResult.INTERMEDIATE\n\t        else:\n", "            raise ValueError(\"Unknown status: {}\".format(status))\n\t    @handles(LogMessage)\n\t    def _convert_log_messages(self, log: LogMessage) -> msgs.LogMessage:\n\t        if log.level == LogLevel.INFO:\n\t            level = msgs.LogMessage.INFO\n\t        elif log.level == LogLevel.WARNING:\n\t            level = msgs.LogMessage.WARNING\n\t        elif log.level == LogLevel.ERROR:\n\t            level = msgs.LogMessage.ERROR\n\t        elif log.level == LogLevel.DEBUG:\n", "            level = msgs.LogMessage.DEBUG\n\t        else:\n\t            raise UPException(f\"Unknown log level: {log.level}\")\n\t        ret = msgs.LogMessage()\n\t        ret.level = level\n\t        ret.message = str(log.message)\n\t        return ret\n\t    @handles(CompilerResult)\n\t    def _convert_compiler_result(self, result: CompilerResult) -> msgs.CompilerResult:\n\t        mymap: Dict[str, msgs.ActionInstance] = {}\n", "        log_messages = result.log_messages\n\t        if log_messages is None:\n\t            log_messages = []\n\t        if result.map_back_action_instance is not None:\n\t            for compiled_action in result.problem.actions:\n\t                type_list = [param.type for param in compiled_action.parameters]\n\t                if len(type_list) == 0:\n\t                    ai = unified_planning.plans.ActionInstance(compiled_action)\n\t                    mymap[str(ai)] = self.convert(result.map_back_action_instance(ai))\n\t                    continue\n", "                ground_size = 1\n\t                domain_sizes = []\n\t                for t in type_list:\n\t                    ds = domain_size(result.problem, t)\n\t                    domain_sizes.append(ds)\n\t                    ground_size *= ds\n\t                items_list: List[List[model.FNode]] = []\n\t                for size, mtype in zip(domain_sizes, type_list):\n\t                    items_list.append(\n\t                        [domain_item(result.problem, mtype, j) for j in range(size)]\n", "                    )\n\t                grounded_params_list = product(*items_list)\n\t                for grounded_params in grounded_params_list:\n\t                    ai = unified_planning.plans.ActionInstance(\n\t                        compiled_action, tuple(grounded_params)\n\t                    )\n\t                    mymap[str(ai)] = self.convert(result.map_back_action_instance(ai))\n\t        ret = msgs.CompilerResult()\n\t        ret.problem = self.convert(result.problem)\n\t        ret.map_back_plan_keys = mymap.keys()\n", "        ret.map_back_plan_values = list(mymap.values())\n\t        ret.log_messages = [self.convert(log) for log in log_messages]\n\t        ret.engine = result.engine_name\n\t        return ret\n\t    @handles(ValidationResult)\n\t    def _convert_validation_result(\n\t        self, result: ValidationResult\n\t    ) -> msgs.ValidationResult:\n\t        ret = msgs.ValidationResult()\n\t        ret.status = self.convert(result.status)\n", "        ret.log_messages = [self.convert(log) for log in result.log_messages]\n\t        ret.engine = result.engine_name\n\t        return ret\n\t    @handles(ValidationResultStatus)\n\t    def _convert_validation_result_status(self, status: ValidationResultStatus) -> int:\n\t        if status == ValidationResultStatus.VALID:\n\t            return msgs.ValidationResult.VALID\n\t        elif status == ValidationResultStatus.INVALID:\n\t            return msgs.ValidationResult.INVALID\n\t        else:\n", "            raise UPException(f\"Unknown result status: {status}\")\n"]}
{"filename": "up4ros/src/up4ros/ros_interface_reader.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# This module started from the proto_reader.py module from the\n\t# AIPlan4EU project, with the same license\n\t# type: ignore[attr-defined]\n\timport fractions\n\tfrom functools import partial\n\tfrom typing import Dict, List, Optional, OrderedDict, Tuple, Union\n", "from unified_planning import Environment\n\tfrom unified_planning import model\n\tfrom unified_planning.engines import (\n\t    PlanGenerationResult,\n\t    PlanGenerationResultStatus,\n\t    LogMessage,\n\t    CompilerResult,\n\t    ValidationResult,\n\t    ValidationResultStatus,\n\t    LogLevel,\n", ")\n\tfrom unified_planning.engines.compilers.utils import lift_action_instance\n\tfrom unified_planning.exceptions import UPException\n\tfrom unified_planning.model import (\n\t    DurativeAction,\n\t    Effect,\n\t    Fluent,\n\t    InstantaneousAction,\n\t    Parameter,\n\t    Problem,\n", "    Variable,\n\t)\n\tfrom unified_planning.model import metrics\n\tfrom unified_planning.model.effect import EffectKind\n\tfrom unified_planning.model.htn import Task\n\tfrom unified_planning.model.operators import OperatorKind\n\timport unified_planning.plans\n\tfrom unified_planning.plans import (\n\t    Plan,\n\t    TimeTriggeredPlan,\n", "    SequentialPlan,\n\t    ActionInstance,\n\t)\n\tfrom up4ros.converter import Converter, handles\n\tfrom up_msgs import msg as msgs\n\tdef convert_type_str(s: str, problem: Problem) -> model.types.Type:\n\t    if s == \"up:bool\":\n\t        return problem.environment.type_manager.BoolType()\n\t    elif s == \"up:integer\":\n\t        return problem.environment.type_manager.IntType()\n", "    elif \"up:integer[\" in s:\n\t        lb = int(s.split(\"[\")[1].split(\",\")[0])\n\t        ub = int(s.split(\",\")[1].split(\"]\")[0])\n\t        return problem.environment.type_manager.IntType(lb, ub)\n\t    elif s == \"up:real\":\n\t        return problem.environment.type_manager.RealType()\n\t    elif \"up:real[\" in s:\n\t        return problem.environment.type_manager.RealType(\n\t            lower_bound=fractions.Fraction(s.split(\"[\")[1].split(\",\")[0]),\n\t            upper_bound=fractions.Fraction(s.split(\",\")[1].split(\"]\")[0]),\n", "        )\n\t    else:\n\t        assert not s.startswith(\"up:\"), f\"Unhandled builtin type: {s}\"\n\t        return problem.user_type(s)\n\t# The operators are based on SExpressions supported in PDDL.\n\tdef op_to_node_type(op: str) -> OperatorKind:\n\t    if op == \"up:plus\":\n\t        return OperatorKind.PLUS\n\t    elif op == \"up:minus\":\n\t        return OperatorKind.MINUS\n", "    elif op == \"up:times\":\n\t        return OperatorKind.TIMES\n\t    elif op == \"up:div\":\n\t        return OperatorKind.DIV\n\t    elif op == \"up:equals\":\n\t        return OperatorKind.EQUALS\n\t    elif op == \"up:le\":\n\t        return OperatorKind.LE\n\t    elif op == \"up:lt\":\n\t        return OperatorKind.LT\n", "    elif op == \"up:and\":\n\t        return OperatorKind.AND\n\t    elif op == \"up:or\":\n\t        return OperatorKind.OR\n\t    elif op == \"up:not\":\n\t        return OperatorKind.NOT\n\t    elif op == \"up:exists\":\n\t        return OperatorKind.EXISTS\n\t    elif op == \"up:forall\":\n\t        return OperatorKind.FORALL\n", "    elif op == \"up:implies\":\n\t        return OperatorKind.IMPLIES\n\t    elif op == \"up:iff\":\n\t        return OperatorKind.IFF\n\t    raise ValueError(f\"Unknown operator `{op}`\")\n\tclass ROSInterfaceReader(Converter):\n\t    \"\"\"Class to convert ROS 2 Interfaces representation to unified_planning Problem instance.\"\"\"\n\t    @handles(msgs.Parameter)\n\t    def _convert_parameter(\n\t        self, msg: msgs.Parameter, problem: Problem\n", "    ) -> model.Parameter:\n\t        return model.Parameter(\n\t            msg.name, convert_type_str(msg.type, problem), problem.environment\n\t        )\n\t    @handles(msgs.Fluent)\n\t    def _convert_fluent(self, msg: msgs.Fluent, problem: Problem) -> Fluent:\n\t        value_type: model.types.Type = convert_type_str(msg.value_type, problem)\n\t        sig: list = []\n\t        for p in msg.parameters:\n\t            sig.append(self.convert(p, problem))\n", "        fluent = model.Fluent(msg.name, value_type, sig, problem.environment)\n\t        return fluent\n\t    @handles(msgs.ObjectDeclaration)\n\t    def _convert_object(\n\t        self, msg: msgs.ObjectDeclaration, problem: Problem\n\t    ) -> model.Object:\n\t        return model.Object(msg.name, convert_type_str(msg.type, problem))\n\t    def cluster_args(self, expression: msgs.Expression):\n\t        ret = []\n\t        if len(expression.expressions) == 0:\n", "            return ret\n\t        current_expr_cluster = []\n\t        current_level_cluster = []\n\t        base_index = expression.level[0]\n\t        expr_index = 0\n\t        while expr_index < len(expression.expressions):\n\t            current_expr_cluster.append(expression.expressions[expr_index])\n\t            current_level_cluster.append(expression.level[expr_index])\n\t            if (expr_index + 1) < len(expression.expressions) and expression.level[\n\t                expr_index + 1\n", "            ] == base_index:\n\t                new_expr = msgs.Expression()\n\t                new_expr.expressions = current_expr_cluster.copy()\n\t                new_expr.level = current_level_cluster.copy()\n\t                ret.append(new_expr)\n\t                current_expr_cluster = []\n\t                current_level_cluster = []\n\t            expr_index += 1\n\t        new_expr = msgs.Expression()\n\t        new_expr.expressions = current_expr_cluster.copy()\n", "        new_expr.level = current_level_cluster.copy()\n\t        ret.append(new_expr)\n\t        return ret\n\t    @handles(msgs.Expression)\n\t    def _convert_expression(\n\t        self, msg: msgs.Expression, problem: Problem\n\t    ) -> model.Expression:\n\t        root_expr = msg.expressions[0]\n\t        if root_expr.kind == msgs.ExpressionItem.CONSTANT:\n\t            assert len(root_expr.atom) > 0\n", "            return self.convert(root_expr.atom[0], problem)\n\t        elif root_expr.kind == msgs.ExpressionItem.PARAMETER:\n\t            return problem.environment.expression_manager.ParameterExp(\n\t                param=Parameter(\n\t                    root_expr.atom[0].symbol_atom[0],\n\t                    convert_type_str(root_expr.type, problem),\n\t                    problem.environment,\n\t                )\n\t            )\n\t        elif root_expr.kind == msgs.ExpressionItem.VARIABLE:\n", "            return problem.environment.expression_manager.VariableExp(\n\t                var=Variable(\n\t                    root_expr.atom[0].symbol_atom[0],\n\t                    convert_type_str(root_expr.type, problem),\n\t                    problem.environment,\n\t                )\n\t            )\n\t        elif root_expr.kind == msgs.ExpressionItem.STATE_VARIABLE:\n\t            args = []\n\t            payload = None\n", "            fluent = msg.expressions[1]\n\t            if fluent.kind == msgs.ExpressionItem.FLUENT_SYMBOL:\n\t                payload = self.convert(fluent.atom[0], problem)\n\t            rest_msg = msgs.Expression()\n\t            rest_msg.expressions = msg.expressions[2:]\n\t            rest_msg.level = msg.level[2:]\n\t            clusters = self.cluster_args(rest_msg)\n\t            args.extend([self.convert(m, problem) for m in clusters])\n\t            if payload is not None:\n\t                return problem.environment.expression_manager.FluentExp(\n", "                    payload, tuple(args)\n\t                )\n\t            else:\n\t                raise UPException(f\"Unable to form fluent expression {msg}\")\n\t        elif (\n\t            root_expr.kind == msgs.ExpressionItem.FUNCTION_APPLICATION\n\t            and root_expr.type != \"up:time\"\n\t        ):\n\t            node_type = None\n\t            args = []\n", "            payload = None\n\t            symbol = msg.expressions[1]\n\t            if symbol.kind == msgs.ExpressionItem.FUNCTION_SYMBOL:\n\t                node_type = op_to_node_type(symbol.atom[0].symbol_atom[0])\n\t            rest_msg = msgs.Expression()\n\t            rest_msg.expressions = msg.expressions[2:]\n\t            rest_msg.level = msg.level[2:]\n\t            clusters = self.cluster_args(rest_msg)\n\t            if node_type in [OperatorKind.EXISTS, OperatorKind.FORALL]:\n\t                variables = clusters[:-1]\n", "                quantified_expression = clusters[-1]\n\t                args.append(self.convert(quantified_expression, problem))\n\t                payload = tuple(\n\t                    [self.convert(var, problem).variable() for var in variables]\n\t                )\n\t            else:\n\t                args.extend([self.convert(m, problem) for m in clusters])\n\t            assert node_type is not None\n\t            return problem.environment.expression_manager.create_node(\n\t                node_type=node_type, args=tuple(args), payload=payload\n", "            )\n\t        elif (\n\t            root_expr.kind == msgs.ExpressionItem.FUNCTION_APPLICATION\n\t            and root_expr.type == \"up:time\"\n\t        ):\n\t            fn = msg.expressions[1].atom[0].symbol_atom[0]\n\t            if fn == \"up:start\":\n\t                kd = model.TimepointKind.START\n\t            elif fn == \"up:end\":\n\t                kd = model.TimepointKind.END\n", "            elif fn == \"up:global_start\":\n\t                kd = model.TimepointKind.GLOBAL_START\n\t            elif fn == \"up:global_end\":\n\t                kd = model.TimepointKind.GLOBAL_END\n\t            else:\n\t                raise ValueError(f\"Invalid temporal qualifier {fn}\")\n\t            container = None\n\t            if len(msg.expressions) > 1:\n\t                container = msg.expressions[2].atom[0].symbol_atom[0]\n\t            tp = model.timing.Timepoint(kd, container)\n", "            return problem.environment.expression_manager.TimingExp(model.Timing(0, tp))\n\t        raise ValueError(f\"Unknown expression kind `{root_expr.kind}`\")\n\t    @handles(msgs.Atom)\n\t    def _convert_atom(\n\t        self, msg: msgs.Atom, problem: Problem\n\t    ) -> Union[model.FNode, model.Fluent, model.Object]:\n\t        if len(msg.int_atom) > 0:\n\t            return problem.environment.expression_manager.Int(msg.int_atom[0])\n\t        elif len(msg.real_atom) > 0:\n\t            return problem.environment.expression_manager.Real(\n", "                fractions.Fraction(\n\t                    msg.real_atom[0].numerator, msg.real_atom[0].denominator\n\t                )\n\t            )\n\t        elif len(msg.boolean_atom) > 0:\n\t            return problem.environment.expression_manager.Bool(msg.boolean_atom[0])\n\t        elif len(msg.symbol_atom) > 0:\n\t            # If atom symbols, return the equivalent UP alternative\n\t            # Note that parameters are directly handled at expression level\n\t            if problem.has_object(msg.symbol_atom[0]):\n", "                return problem.environment.expression_manager.ObjectExp(\n\t                    obj=problem.object(msg.symbol_atom[0])\n\t                )\n\t            else:\n\t                return problem.fluent(msg.symbol_atom[0])\n\t        else:\n\t            raise ValueError(\"Atom empty\")\n\t    @handles(msgs.TypeDeclaration)\n\t    def _convert_type_declaration(\n\t        self, msg: msgs.TypeDeclaration, problem: Problem\n", "    ) -> model.Type:\n\t        if msg.type_name == \"up:bool\":\n\t            return problem.environment.type_manager.BoolType()\n\t        elif msg.type_name.startswith(\"up:integer[\"):\n\t            tmp = msg.type_name.split(\"[\")[1].split(\"]\")[0].split(\", \")\n\t            return problem.environment.type_manager.IntType(\n\t                lower_bound=int(tmp[0]) if tmp[0] != \"-inf\" else None,\n\t                upper_bound=int(tmp[1]) if tmp[1] != \"inf\" else None,\n\t            )\n\t        elif msg.type_name.startswith(\"up:real[\"):\n", "            tmp = msg.type_name.split(\"[\")[1].split(\"]\")[0].split(\", \")\n\t            lower_bound = fractions.Fraction(tmp[0]) if tmp[0] != \"-inf\" else None\n\t            upper_bound = fractions.Fraction(tmp[1]) if tmp[1] != \"inf\" else None\n\t            return problem.environment.type_manager.RealType(\n\t                lower_bound=lower_bound, upper_bound=upper_bound\n\t            )\n\t        else:\n\t            father = (\n\t                problem.user_type(msg.parent_type) if msg.parent_type != \"\" else None\n\t            )\n", "            return problem.environment.type_manager.UserType(\n\t                name=msg.type_name, father=father\n\t            )\n\t    @handles(msgs.Problem)\n\t    def _convert_problem(\n\t        self, msg: msgs.Problem, env: Optional[Environment] = None\n\t    ) -> Problem:\n\t        problem_name = str(msg.problem_name) if str(msg.problem_name) != \"\" else None\n\t        if len(msg.hierarchy) > 0:\n\t            problem = model.htn.HierarchicalProblem(name=problem_name, environment=env)\n", "        else:\n\t            problem = Problem(name=problem_name, environment=env)\n\t        for t in msg.types:\n\t            problem._add_user_type(self.convert(t, problem))\n\t        for obj in msg.objects:\n\t            problem.add_object(self.convert(obj, problem))\n\t        for f in msg.fluents:\n\t            problem.add_fluent(\n\t                self.convert(f, problem),\n\t                default_initial_value=self.convert(f.default_value[0], problem)\n", "                if len(f.default_value) > 0\n\t                else None,\n\t            )\n\t        for f in msg.actions:\n\t            problem.add_action(self.convert(f, problem))\n\t        for eff in msg.timed_effects:\n\t            ot = self.convert(eff.occurrence_time, problem)\n\t            effect = self.convert(eff.effect, problem)\n\t            problem.add_timed_effect(\n\t                timing=ot,\n", "                fluent=effect.fluent,\n\t                value=effect.value,\n\t                condition=effect.condition,\n\t            )\n\t        for assign in msg.initial_state:\n\t            problem.set_initial_value(\n\t                fluent=self.convert(assign.fluent, problem),\n\t                value=self.convert(assign.value, problem),\n\t            )\n\t        for g in msg.goals:\n", "            goal = self.convert(g.goal, problem)\n\t            if len(g.timing) == 0:\n\t                problem.add_goal(goal)\n\t            else:\n\t                timing = self.convert(g.timing[0])\n\t                problem.add_timed_goal(interval=timing, goal=goal)\n\t        for metric in msg.metrics:\n\t            problem.add_quality_metric(self.convert(metric, problem))\n\t        if len(msg.hierarchy) > 0:\n\t            for task in msg.hierarchy[0].abstract_tasks:\n", "                problem.add_task(self.convert(task, problem))\n\t            for method in msg.hierarchy[0].methods:\n\t                problem.add_method(self.convert(method, problem))\n\t            problem._initial_task_network = self.convert(\n\t                msg.hierarchy[0].initial_task_network, problem\n\t            )\n\t        return problem\n\t    @handles(msgs.AbstractTaskDeclaration)\n\t    def _convert_abstract_task(\n\t        self, msg: msgs.AbstractTaskDeclaration, problem: Problem\n", "    ):\n\t        return model.htn.Task(\n\t            msg.name,\n\t            [self.convert(p, problem) for p in msg.parameters],\n\t            problem.environment,\n\t        )\n\t    @handles(msgs.Task)\n\t    def _convert_task(\n\t        self, msg: msgs.Task, problem: model.htn.HierarchicalProblem\n\t    ) -> model.htn.Subtask:\n", "        if problem.has_task(msg.task_name):\n\t            task = problem.get_task(msg.task_name)\n\t        elif problem.has_action(msg.task_name):\n\t            task = problem.action(msg.task_name)\n\t        else:\n\t            raise ValueError(f\"Unknown task name: {msg.task_name}\")\n\t        parameters = [self.convert(p, problem) for p in msg.parameters]\n\t        return model.htn.Subtask(\n\t            task, *parameters, ident=msg.id, _env=problem.environment\n\t        )\n", "    @handles(msgs.Method)\n\t    def _convert_method(\n\t        self, msg: msgs.Method, problem: model.htn.HierarchicalProblem\n\t    ) -> model.htn.Method:\n\t        method = model.htn.Method(\n\t            msg.name,\n\t            [self.convert(p, problem) for p in msg.parameters],\n\t            problem.environment,\n\t        )\n\t        achieved_task_params = []\n", "        for p in msg.achieved_task.parameters:\n\t            achieved_task_params.append(\n\t                method.parameter(p.expressions[0].atom[0].symbol_atom[0])\n\t            )\n\t        method.set_task(\n\t            problem.get_task(msg.achieved_task.task_name), *achieved_task_params\n\t        )\n\t        for st in msg.subtasks:\n\t            method.add_subtask(self.convert(st, problem))\n\t        for c in msg.constraints:\n", "            method.add_constraint(self.convert(c, problem))\n\t        for c in msg.conditions:\n\t            assert len(c.span) == 0, \"Timed conditions are currently unsupported.\"\n\t            method.add_precondition(self.convert(c.cond, problem))\n\t        return method\n\t    @handles(msgs.TaskNetwork)\n\t    def _convert_task_network(\n\t        self, msg: msgs.TaskNetwork, problem: model.htn.HierarchicalProblem\n\t    ) -> model.htn.TaskNetwork:\n\t        tn = model.htn.TaskNetwork(problem.environment)\n", "        for v in msg.variables:\n\t            tn.add_variable(v.name, convert_type_str(v.type, problem))\n\t        for st in msg.subtasks:\n\t            tn.add_subtask(self.convert(st, problem))\n\t        for c in msg.constraints:\n\t            tn.add_constraint(self.convert(c, problem))\n\t        return tn\n\t    @handles(msgs.Metric)\n\t    def _convert_metric(\n\t        self, msg: msgs.Metric, problem: Problem\n", "    ) -> Union[\n\t        metrics.MinimizeActionCosts,\n\t        metrics.MinimizeSequentialPlanLength,\n\t        metrics.MinimizeMakespan,\n\t        metrics.MinimizeExpressionOnFinalState,\n\t        metrics.MaximizeExpressionOnFinalState,\n\t        metrics.Oversubscription,\n\t    ]:\n\t        if msg.kind == msgs.Metric.MINIMIZE_ACTION_COSTS:\n\t            costs = {}\n", "            for i in range(len(msg.action_cost_names)):\n\t                costs[problem.action(list(msg.action_cost_names)[i])] = self.convert(\n\t                    msg.action_cost_expr[i], problem\n\t                )\n\t            return metrics.MinimizeActionCosts(\n\t                costs=costs,\n\t                default=self.convert(msg.default_action_cost[0], problem)\n\t                if len(msg.default_action_cost) > 0\n\t                else None,\n\t            )\n", "        elif msg.kind == msgs.Metric.MINIMIZE_SEQUENTIAL_PLAN_LENGTH:\n\t            return metrics.MinimizeSequentialPlanLength()\n\t        elif msg.kind == msgs.Metric.MINIMIZE_MAKESPAN:\n\t            return metrics.MinimizeMakespan()\n\t        elif msg.kind == msgs.Metric.MINIMIZE_EXPRESSION_ON_FINAL_STATE:\n\t            return metrics.MinimizeExpressionOnFinalState(\n\t                expression=self.convert(msg.expression, problem)\n\t            )\n\t        elif msg.kind == msgs.Metric.MAXIMIZE_EXPRESSION_ON_FINAL_STATE:\n\t            return metrics.MaximizeExpressionOnFinalState(\n", "                expression=self.convert(msg.expression, problem)\n\t            )\n\t        elif msg.kind == msgs.Metric.OVERSUBSCRIPTION:\n\t            goals = {}\n\t            for g in msg.goals:\n\t                goals[self.convert(g.goal, problem)] = self.convert(g.cost)\n\t            return metrics.Oversubscription(goals)\n\t        else:\n\t            raise UPException(f\"Unknown metric kind `{msg.kind}`\")\n\t    @handles(msgs.Action)\n", "    def _convert_action(self, msg: msgs.Action, problem: Problem) -> model.Action:\n\t        action: model.Action\n\t        parameters = OrderedDict()\n\t        for param in msg.parameters:\n\t            parameters[param.name] = convert_type_str(param.type, problem)\n\t        if len(msg.duration) > 0:\n\t            action = DurativeAction(msg.name, parameters)\n\t            action.set_duration_constraint(self.convert(msg.duration[0], problem))\n\t        else:\n\t            action = InstantaneousAction(msg.name, parameters)\n", "        conditions = []\n\t        for condition in msg.conditions:\n\t            cond = self.convert(condition.cond, problem)\n\t            span = self.convert(condition.span[0]) if len(condition.span) > 0 else None\n\t            conditions.append((cond, span))\n\t        effects = []\n\t        for effect in msg.effects:\n\t            eff = self.convert(effect.effect, problem)\n\t            time = (\n\t                self.convert(effect.occurrence_time[0])\n", "                if len(effect.occurrence_time) > 0\n\t                else None\n\t            )\n\t            effects.append((eff, time))\n\t        if isinstance(action, DurativeAction):\n\t            for c, span in conditions:\n\t                action.add_condition(span, c)\n\t            for e, ot in effects:\n\t                if e.kind == EffectKind.ASSIGN:\n\t                    action.add_effect(ot, e.fluent, e.value, e.condition)\n", "                elif e.kind == EffectKind.DECREASE:\n\t                    action.add_decrease_effect(ot, e.fluent, e.value, e.condition)\n\t                elif e.kind == EffectKind.INCREASE:\n\t                    action.add_increase_effect(ot, e.fluent, e.value, e.condition)\n\t        elif isinstance(action, InstantaneousAction):\n\t            for c, _ in conditions:\n\t                action.add_precondition(c)\n\t            for e, _ in effects:\n\t                if e.kind == EffectKind.ASSIGN:\n\t                    action.add_effect(e.fluent, e.value, e.condition)\n", "                elif e.kind == EffectKind.DECREASE:\n\t                    action.add_decrease_effect(e.fluent, e.value, e.condition)\n\t                elif e.kind == EffectKind.INCREASE:\n\t                    action.add_increase_effect(e.fluent, e.value, e.condition)\n\t        return action\n\t    @handles(msgs.EffectExpression)\n\t    def _convert_effect(\n\t        self, msg: msgs.EffectExpression, problem: Problem\n\t    ) -> model.Effect:\n\t        # EffectKind\n", "        if msg.kind == msgs.EffectExpression.INCREASE:\n\t            kind = EffectKind.INCREASE\n\t        elif msg.kind == msgs.EffectExpression.DECREASE:\n\t            kind = EffectKind.DECREASE\n\t        else:\n\t            kind = EffectKind.ASSIGN\n\t        fluent = self.convert(msg.fluent, problem)\n\t        condition = self.convert(msg.condition, problem)\n\t        value = self.convert(msg.value, problem)\n\t        return Effect(fluent=fluent, value=value, condition=condition, kind=kind)\n", "    @handles(msgs.Duration)\n\t    def _convert_duration(\n\t        self, msg: msgs.Duration, problem: Problem\n\t    ) -> model.timing.DurationInterval:\n\t        return model.timing.DurationInterval(\n\t            lower=self.convert(msg.controllable_in_bounds.lower, problem),\n\t            upper=self.convert(msg.controllable_in_bounds.upper, problem),\n\t            is_left_open=bool(msg.controllable_in_bounds.is_left_open),\n\t            is_right_open=bool(msg.controllable_in_bounds.is_right_open),\n\t        )\n", "    @handles(msgs.TimeInterval)\n\t    def _convert_timed_interval(self, msg: msgs.TimeInterval) -> model.TimeInterval:\n\t        return model.TimeInterval(\n\t            lower=self.convert(msg.lower),\n\t            upper=self.convert(msg.upper),\n\t            is_left_open=msg.is_left_open,\n\t            is_right_open=msg.is_right_open,\n\t        )\n\t    @handles(msgs.Timing)\n\t    def _convert_timing(self, msg: msgs.Timing) -> model.timing.Timing:\n", "        return model.Timing(\n\t            delay=self.convert(msg.delay[0])\n\t            if len(msg.delay) > 0\n\t            else fractions.Fraction(0),\n\t            timepoint=self.convert(msg.timepoint),\n\t        )\n\t    @handles(msgs.Real)\n\t    def _convert_real(self, msg: msgs.Real) -> fractions.Fraction:\n\t        return fractions.Fraction(msg.numerator, msg.denominator)\n\t    @handles(msgs.Timepoint)\n", "    def _convert_timepoint(self, msg: msgs.Timepoint) -> model.timing.Timepoint:\n\t        if msg.kind == msgs.Timepoint.GLOBAL_START:\n\t            kind = model.timing.TimepointKind.GLOBAL_START\n\t        elif msg.kind == msgs.Timepoint.GLOBAL_END:\n\t            kind = model.timing.TimepointKind.GLOBAL_END\n\t        elif msg.kind == msgs.Timepoint.START:\n\t            kind = model.timing.TimepointKind.START\n\t        elif msg.kind == msgs.Timepoint.END:\n\t            kind = model.timing.TimepointKind.END\n\t        else:\n", "            raise UPException(\"Unknown timepoint kind: {}\".format(msg.kind))\n\t        container = msg.container_id if msg.container_id != \"\" else None\n\t        return model.timing.Timepoint(kind, container)\n\t    @handles(msgs.Plan)\n\t    def _convert_plan(self, msg: msgs.Plan, problem: Problem) -> Plan:\n\t        actions = [self.convert(a, problem) for a in msg.actions]\n\t        if all(isinstance(a, tuple) for a in actions):\n\t            return TimeTriggeredPlan(actions)\n\t        else:\n\t            return SequentialPlan(actions=actions)\n", "    @handles(msgs.ActionInstance)\n\t    def _convert_action_instance(\n\t        self, msg: msgs.ActionInstance, problem: Problem\n\t    ) -> Union[\n\t        Tuple[model.timing.Timing, ActionInstance, model.timing.Duration],\n\t        ActionInstance,\n\t    ]:\n\t        # action instance parameters are atoms but in UP they are FNodes\n\t        # converting to up.model.FNode\n\t        parameters = tuple([self.convert(param, problem) for param in msg.parameters])\n", "        action_instance = ActionInstance(problem.action(msg.action_name), parameters)\n\t        start_time = self.convert(msg.start_time) if msg.time_triggered else None\n\t        end_time = self.convert(msg.end_time) if msg.time_triggered else None\n\t        if start_time is not None:\n\t            return (\n\t                start_time,  # Absolute Start Time\n\t                action_instance,\n\t                end_time - start_time if end_time else None,  # Duration\n\t            )\n\t        else:\n", "            return action_instance\n\t    @handles(msgs.PlanGenerationResult)\n\t    def _convert_plan_generation_result(\n\t        self, result: msgs.PlanGenerationResult, problem: Problem\n\t    ) -> PlanGenerationResult:\n\t        if result.status == msgs.PlanGenerationResult.SOLVED_SATISFICING:\n\t            status = PlanGenerationResultStatus.SOLVED_SATISFICING\n\t        elif result.status == msgs.PlanGenerationResult.SOLVED_OPTIMALLY:\n\t            status = PlanGenerationResultStatus.SOLVED_OPTIMALLY\n\t        elif result.status == msgs.PlanGenerationResult.UNSOLVABLE_PROVEN:\n", "            status = PlanGenerationResultStatus.UNSOLVABLE_PROVEN\n\t        elif result.status == msgs.PlanGenerationResult.UNSOLVABLE_INCOMPLETELY:\n\t            status = PlanGenerationResultStatus.UNSOLVABLE_INCOMPLETELY\n\t        elif result.status == msgs.PlanGenerationResult.TIMEOUT:\n\t            status = PlanGenerationResultStatus.TIMEOUT\n\t        elif result.status == msgs.PlanGenerationResult.MEMOUT:\n\t            status = PlanGenerationResultStatus.MEMOUT\n\t        elif result.status == msgs.PlanGenerationResult.INTERNAL_ERROR:\n\t            status = PlanGenerationResultStatus.INTERNAL_ERROR\n\t        elif result.status == msgs.PlanGenerationResult.UNSUPPORTED_PROBLEM:\n", "            status = PlanGenerationResultStatus.UNSUPPORTED_PROBLEM\n\t        else:\n\t            raise UPException(f\"Unknown Planner Status: {result.status}\")\n\t        log_messages = None\n\t        metrics = None\n\t        if len(result.metric_names) > 0:\n\t            metrics = dict(zip(result.metric_names, result.metric_values))\n\t        if len(result.log_messages) > 0:\n\t            log_messages = [self.convert(log) for log in result.log_messages]\n\t        return PlanGenerationResult(\n", "            status=status,\n\t            plan=self.convert(result.plan, problem),\n\t            engine_name=result.engine_name,\n\t            metrics=metrics,\n\t            log_messages=log_messages,\n\t        )\n\t    @handles(msgs.LogMessage)\n\t    def _convert_log_message(self, log: msgs.LogMessage) -> LogMessage:\n\t        if log.level == msgs.LogMessage.INFO:\n\t            return LogMessage(level=LogLevel.INFO, message=log.message)\n", "        elif log.level == msgs.LogMessage.WARNING:\n\t            return LogMessage(level=LogLevel.WARNING, message=log.message)\n\t        elif log.level == msgs.LogMessage.ERROR:\n\t            return LogMessage(level=LogLevel.ERROR, message=log.message)\n\t        elif log.level == msgs.LogMessage.DEBUG:\n\t            return LogMessage(level=LogLevel.DEBUG, message=log.message)\n\t        else:\n\t            raise UPException(f\"Unexpected Log Level: {log.level}\")\n\t    @handles(msgs.CompilerResult)\n\t    def _convert_compiler_result(\n", "        self,\n\t        result: msgs.CompilerResult,\n\t        lifted_problem: unified_planning.model.Problem,\n\t    ) -> CompilerResult:\n\t        problem = self.convert(result.problem, lifted_problem.environment)\n\t        mymap: Dict[\n\t            unified_planning.model.Action,\n\t            Tuple[unified_planning.model.Action, List[unified_planning.model.FNode]],\n\t        ] = {}\n\t        for grounded_action in problem.actions:\n", "            map_back_plan = dict(\n\t                zip(result.map_back_plan_keys, result.map_back_plan_values)\n\t            )\n\t            original_action_instance = self.convert(\n\t                map_back_plan[grounded_action.name], lifted_problem\n\t            )\n\t            mymap[grounded_action] = (\n\t                original_action_instance.action,\n\t                original_action_instance.actual_parameters,\n\t            )\n", "        return CompilerResult(\n\t            problem=problem,\n\t            map_back_action_instance=partial(lift_action_instance, map=mymap),\n\t            engine_name=result.engine,\n\t            log_messages=[self.convert(log) for log in result.log_messages],\n\t        )\n\t    @handles(msgs.ValidationResult)\n\t    def _convert_validation_result(\n\t        self, result: msgs.ValidationResult\n\t    ) -> ValidationResult:\n", "        if result.status == msgs.ValidationResult.VALID:\n\t            r_status = ValidationResultStatus.VALID\n\t        elif result.status == msgs.ValidationResult.INVALID:\n\t            r_status = ValidationResultStatus.INVALID\n\t        else:\n\t            raise UPException(f\"Unexpected ValidationResult status: {result.status}\")\n\t        return ValidationResult(\n\t            status=r_status,\n\t            engine_name=result.engine,\n\t            log_messages=[self.convert(log) for log in result.log_messages],\n", "        )\n"]}
{"filename": "up4ros/src/up4ros/ros_utils.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom up_msgs import msg as msgs\n\tkind_to_string = {\n\t    msgs.ExpressionItem.UNKNOWN: \"UNKNOWN\",\n\t    msgs.ExpressionItem.CONSTANT: \"CONSTANT\",\n\t    msgs.ExpressionItem.PARAMETER: \"PARAMETER\",\n\t    msgs.ExpressionItem.VARIABLE: \"VARIABLE\",\n", "    msgs.ExpressionItem.FLUENT_SYMBOL: \"FLUENT_SYMBOL\",\n\t    msgs.ExpressionItem.FUNCTION_SYMBOL: \"FUNCTION_SYMBOL\",\n\t    msgs.ExpressionItem.STATE_VARIABLE: \"STATE_VARIABLE\",\n\t    msgs.ExpressionItem.FUNCTION_APPLICATION: \"FUNCTION_APPLICATION\",\n\t    msgs.ExpressionItem.CONTAINER_ID: \"CONTAINER_ID\",\n\t}\n\tdef print_expr(expr: msgs.Expression):\n\t    for i in range(len(expr.expressions)):\n\t        print(\n\t            f'{expr.level[i] * \"    \"} '\n", "            f\"[{kind_to_string[expr.expressions[i].kind]}] {expr.expressions[i]}\"\n\t        )\n"]}
{"filename": "up4ros/src/up4ros/test_utils.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom os.path import exists\n\timport rospkg\n\tdef get_domain_and_problem(path_domain, path_problem):\n\t    rospack = rospkg.RosPack()\n\t    # needed to make the github pipelines work\n\t    domain = rospack.get_path(\"up4ros\") + \"/tests/\" + path_domain\n", "    problem = rospack.get_path(\"up4ros\") + \"/tests/\" + path_problem\n\t    if not exists(domain):\n\t        domain = rospack.get_path(\"up4ros\") + \"/\" + path_domain\n\t        problem = rospack.get_path(\"up4ros\") + \"/\" + path_problem\n\t    return domain, problem\n"]}
{"filename": "up4ros/src/up4ros/converter.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tclass handles:\n\t    def __init__(self, *what):\n\t        self.what = what\n\t    def __call__(self, func):\n\t        func._what = self.what\n\t        return func\n", "class Converter:\n\t    def __init__(self):\n\t        self.functions = {}\n\t        for k in dir(self):\n\t            v = getattr(self, k)\n\t            if hasattr(v, \"_what\"):\n\t                for x in v._what:\n\t                    self.functions[x] = v\n\t    def convert(self, element, *args):\n\t        f = self.functions[type(element)]\n", "        return f(element, *args)\n"]}
{"filename": "up4ros/src/up4ros/up4ros_node.py", "chunked_list": ["# Copyright 2023 Magazino GmbH\n\t# Copyright 2022 Intelligent Robotics Lab\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t#\n\timport tempfile\n\timport actionlib\n\timport rospy\n\tfrom unified_planning import model\n\tfrom unified_planning.io.pddl_reader import PDDLReader\n", "from unified_planning.shortcuts import OneshotPlanner\n\tfrom up4ros.ros_interface_reader import ROSInterfaceReader\n\tfrom up4ros.ros_interface_writer import ROSInterfaceWriter\n\tfrom up_msgs.msg import (\n\t    PDDLPlanRequest,\n\t    PDDLPlanOneShotAction,\n\t    PDDLPlanOneShotFeedback,\n\t    PDDLPlanOneShotResult,\n\t    PlanOneShotAction,\n\t    PlanOneShotFeedback,\n", "    PlanOneShotResult,\n\t    PlanOneShotRemoteAction,\n\t    PlanOneShotRemoteFeedback,\n\t    PlanOneShotRemoteResult,\n\t)\n\tfrom up_msgs.srv import (\n\t    AddAction,\n\t    AddActionResponse,\n\t    AddFluent,\n\t    AddFluentResponse,\n", "    AddGoal,\n\t    AddGoalResponse,\n\t    AddObject,\n\t    AddObjectResponse,\n\t    GetProblem,\n\t    GetProblemResponse,\n\t    NewProblem,\n\t    NewProblemResponse,\n\t    PDDLPlanOneShot,\n\t    PDDLPlanOneShotResponse,\n", "    SetInitialValue,\n\t    SetInitialValueResponse,\n\t    SetProblem,\n\t    SetProblemResponse,\n\t)\n\tclass UP4ROSNode:\n\t    def __init__(self, init_ros_interfaces=True):\n\t        self.problems = {}\n\t        self._ros_interface_writer = ROSInterfaceWriter()\n\t        self._ros_interface_reader = ROSInterfaceReader()\n", "        self._add_action = None\n\t        self._add_fluent = None\n\t        self._add_goal = None\n\t        self._add_object = None\n\t        self._get_problem = None\n\t        self._new_problem = None\n\t        self._pddl_plan_one_shot_server = None\n\t        self._pddl_plan_one_shot_srv = None\n\t        self._plan_one_shot_server = None\n\t        self._set_initial_value = None\n", "        self._set_problem = None\n\t        if init_ros_interfaces:\n\t            self.initialize_ros()\n\t    def initialize_ros(self):\n\t        self._pddl_plan_one_shot_server = actionlib.SimpleActionServer(\n\t            \"up4ros/action/planOneShotPDDL\",\n\t            PDDLPlanOneShotAction,\n\t            self.pddl_plan_one_shot_callback,\n\t        )\n\t        self._plan_one_shot_server = actionlib.SimpleActionServer(\n", "            \"up4ros/action/planOneShot\", PlanOneShotAction, self.plan_one_shot_callback\n\t        )\n\t        self._plan_one_shot_remote_server = actionlib.SimpleActionServer(\n\t            \"up4ros/action/planOneShotRemote\",\n\t            PlanOneShotRemoteAction,\n\t            self.plan_one_shot_remote_callback,\n\t        )\n\t        self._add_action = rospy.Service(\n\t            \"up4ros/srv/add_action\", AddAction, self.add_action\n\t        )\n", "        self._add_fluent = rospy.Service(\n\t            \"up4ros/srv/add_fluent\", AddFluent, self.add_fluent\n\t        )\n\t        self._add_object = rospy.Service(\n\t            \"up4ros/srv/add_object\", AddObject, self.add_object\n\t        )\n\t        self._add_goal = rospy.Service(\"up4ros/srv/add_goal\", AddGoal, self.add_goal)\n\t        self._get_problem = rospy.Service(\n\t            \"up4ros/srv/get_problem\", GetProblem, self.get_problem\n\t        )\n", "        self._new_problem = rospy.Service(\n\t            \"up4ros/srv/new_problem\", NewProblem, self.new_problem\n\t        )\n\t        self._pddl_plan_one_shot_srv = rospy.Service(\n\t            \"up4ros/srv/planOneShotPDDL\", PDDLPlanOneShot, self.pddl_plan_one_shot\n\t        )\n\t        self._set_initial_value = rospy.Service(\n\t            \"up4ros/srv/set_initial_value\", SetInitialValue, self.set_initial_value\n\t        )\n\t        self._set_problem = rospy.Service(\n", "            \"up4ros/srv/set_problem\", SetProblem, self.set_problem\n\t        )\n\t    def get_problem(self, request):\n\t        response = GetProblemResponse()\n\t        if request.problem_name not in self.problems:\n\t            response.success = False\n\t            response.message = f\"Problem {request.problem_name} does not exist\"\n\t        else:\n\t            response.problem = self._ros_interface_writer.convert(\n\t                self.problems[request.problem_name]\n", "            )\n\t            response.success = True\n\t        return response\n\t    def new_problem(self, request):\n\t        response = NewProblemResponse()\n\t        if request.problem_name in self.problems:\n\t            response.success = False\n\t            response.message = f\"Problem {request.problem_name} already exists\"\n\t        else:\n\t            self.problems[request.problem_name] = model.Problem(request.problem_name)\n", "            response.success = True\n\t        return response\n\t    def set_problem(self, request):\n\t        response = SetProblemResponse()\n\t        if request.problem_name in self.problems:\n\t            response.success = False\n\t            response.message = f\"Problem {request.problem_name} already exists\"\n\t        else:\n\t            self.problems[request.problem_name] = self._ros_interface_reader.convert(\n\t                request.problem\n", "            )\n\t            response.success = True\n\t        return response\n\t    def add_fluent(self, request):\n\t        response = AddFluentResponse()\n\t        if request.problem_name not in self.problems:\n\t            response.success = False\n\t            response.message = f\"Problem {request.problem_name} does not exist\"\n\t        else:\n\t            problem = self.problems[request.problem_name]\n", "            fluent = self._ros_interface_reader.convert(request.fluent, problem)\n\t            value = self._ros_interface_reader.convert(request.default_value, problem)\n\t            problem.add_fluent(fluent, default_initial_value=value)\n\t            response.success = True\n\t        return response\n\t    def add_action(self, request):\n\t        response = AddActionResponse()\n\t        if request.problem_name not in self.problems:\n\t            response.success = False\n\t            response.message = f\"Problem {request.problem_name} does not exist\"\n", "        else:\n\t            problem = self.problems[request.problem_name]\n\t            action = self._ros_interface_reader.convert(request.action, problem)\n\t            problem.add_action(action)\n\t            response.success = True\n\t        return response\n\t    def add_object(self, request):\n\t        response = AddObjectResponse()\n\t        if request.problem_name not in self.problems:\n\t            response.success = False\n", "            response.message = f\"Problem {request.problem_name} does not exist\"\n\t        else:\n\t            problem = self.problems[request.problem_name]\n\t            action = self._ros_interface_reader.convert(request.object, problem)\n\t            problem.add_object(action)\n\t            response.success = True\n\t        return response\n\t    def set_initial_value(self, request):\n\t        response = SetInitialValueResponse()\n\t        if request.problem_name not in self.problems:\n", "            response.success = False\n\t            response.message = f\"Problem {request.problem_name} does not exist\"\n\t        else:\n\t            problem = self.problems[request.problem_name]\n\t            expression = self._ros_interface_reader.convert(request.expression, problem)\n\t            value = self._ros_interface_reader.convert(request.value, problem)\n\t            problem.set_initial_value(expression, value)\n\t            response.success = True\n\t        return response\n\t    def add_goal(self, request):\n", "        response = AddGoalResponse()\n\t        if request.problem_name not in self.problems:\n\t            response.success = False\n\t            response.message = f\"Problem {request.problem_name} does not exist\"\n\t        else:\n\t            problem = self.problems[request.problem_name]\n\t            if len(request.goal) > 0:\n\t                goal = self._ros_interface_reader.convert(request.goal[0].goal, problem)\n\t                problem.add_goal(goal)\n\t                response.success = True\n", "            elif len(request.goal_with_cost) > 0:\n\t                goal = self._ros_interface_reader.convert(\n\t                    request.goal_with_cost[0].goal, problem\n\t                )\n\t                problem.add_goal(goal)\n\t                response.success = True\n\t            else:\n\t                response.success = False\n\t                response.message = \"Goal is void\"\n\t        return response\n", "    def pddl_plan_one_shot(self, request):\n\t        if request.plan_request.mode == PDDLPlanRequest.RAW:\n\t            domain_file = tempfile.NamedTemporaryFile()\n\t            problem_file = tempfile.NamedTemporaryFile()\n\t            with open(domain_file, \"w\") as pddl_writer:\n\t                pddl_writer.write(request.plan_request.domain)\n\t            with open(problem_file, \"w\") as pddl_writer:\n\t                pddl_writer.write(request.plan_request.problem)\n\t        else:\n\t            domain_file = request.plan_request.domain\n", "            problem_file = request.plan_request.problem\n\t        reader = PDDLReader()\n\t        response = PDDLPlanOneShotResponse()\n\t        try:\n\t            up_problem = reader.parse_problem(domain_file, problem_file)\n\t        except Exception:\n\t            response.success = False\n\t            response.message = \"Error parsing problem\"\n\t            return response\n\t        with OneshotPlanner(problem_kind=up_problem.kind) as planner:\n", "            result = planner.solve(up_problem)\n\t            print(\"%s returned: %s\" % (planner.name, result.plan))\n\t            if result.plan is not None:\n\t                response.plan_result = self._ros_interface_writer.convert(result)\n\t                response.success = True\n\t                response.message = \"\"\n\t            else:\n\t                response.success = False\n\t                response.message = \"No plan found\"\n\t            return response\n", "    def pddl_plan_one_shot_callback(self, goal):\n\t        if goal.plan_request.mode == PDDLPlanRequest.RAW:\n\t            domain_file = tempfile.NamedTemporaryFile()\n\t            problem_file = tempfile.NamedTemporaryFile()\n\t            with open(domain_file, \"w\") as pddl_writer:\n\t                pddl_writer.write(goal.plan_request.domain)\n\t            with open(problem_file, \"w\") as pddl_writer:\n\t                pddl_writer.write(goal.plan_request.problem)\n\t        else:\n\t            domain_file = goal.plan_request.domain\n", "            problem_file = goal.plan_request.problem\n\t        reader = PDDLReader()\n\t        up_problem = reader.parse_problem(domain_file, problem_file)\n\t        with OneshotPlanner(problem_kind=up_problem.kind) as planner:\n\t            result = planner.solve(up_problem)\n\t            print(\"%s returned: %s\" % (planner.name, result.plan))\n\t            feedback_msg = PDDLPlanOneShotFeedback()\n\t            feedback_msg.plan_result = self._ros_interface_writer.convert(result)\n\t            self._pddl_plan_one_shot_server.publish_feedback(feedback_msg)\n\t            rospy.sleep(0.1)  # sleep to allow the feedback to be sent\n", "            result = PDDLPlanOneShotResult()\n\t            result.success = True\n\t            result.message = \"\"\n\t            self._pddl_plan_one_shot_server.set_succeeded(result)\n\t    def plan_one_shot_callback(self, goal):\n\t        up_problem = self._ros_interface_reader.convert(goal.plan_request.problem)\n\t        with OneshotPlanner(problem_kind=up_problem.kind) as planner:\n\t            result = planner.solve(up_problem)\n\t            print(\"%s returned: %s\" % (planner.name, result.plan))\n\t            feedback_msg = PlanOneShotFeedback()\n", "            feedback_msg.plan_result = self._ros_interface_writer.convert(result)\n\t            self._plan_one_shot_server.publish_feedback(feedback_msg)\n\t            rospy.sleep(0.1)  # sleep to allow the feedback to be sent\n\t            result = PlanOneShotResult()\n\t            result.success = True\n\t            result.message = \"\"\n\t            self._plan_one_shot_server.set_succeeded(result)\n\t    def plan_one_shot_remote_callback(self, goal):\n\t        up_problem = self.problems.get(goal.plan_request.problem)\n\t        if up_problem is None:\n", "            result = PlanOneShotRemoteResult()\n\t            result.success = False\n\t            result.message = f\"Problem {goal.plan_request.problem} does not exist\"\n\t            self._plan_one_shot_remote_server.set_succeeded(result)\n\t            return\n\t        with OneshotPlanner(problem_kind=up_problem.kind) as planner:\n\t            result = planner.solve(up_problem)\n\t            print(\"%s returned: %s\" % (planner.name, result.plan))\n\t            feedback_msg = PlanOneShotRemoteFeedback()\n\t            feedback_msg.plan_result = self._ros_interface_writer.convert(result)\n", "            self._plan_one_shot_remote_server.publish_feedback(feedback_msg)\n\t            rospy.sleep(0.1)  # sleep to allow the feedback to be sent\n\t            result = PlanOneShotRemoteResult()\n\t            result.success = True\n\t            result.message = \"\"\n\t            self._plan_one_shot_remote_server.set_succeeded(result)\n"]}
{"filename": "up_msgs/setup.py", "chunked_list": ["# ! DO NOT MANUALLY INVOKE THIS setup.py, USE CATKIN INSTEAD\n\tfrom distutils.core import setup\n\tfrom catkin_pkg.python_setup import generate_distutils_setup\n\t# fetch values from package.xml\n\tsetup_args = generate_distutils_setup(packages=[\"up_msgs\"], package_dir={\"\": \"src\"})\n\tsetup(**setup_args)\n"]}
{"filename": "docs/source/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t# -- Project information\n\tproject = \"UP4ROS\"\n\tcopyright = \"2023, Magazino GmbH\"\n\tauthor = \"Guglielmo Gemignani\"\n\trelease = \"0.1\"\n\tversion = \"0.1.0\"\n\t# -- General configuration\n\textensions = [\n\t    # \"sphinx.ext.duration\",\n", "    \"sphinx.ext.doctest\",\n\t    \"sphinx.ext.autodoc\",\n\t    \"sphinx.ext.autosummary\",\n\t    \"sphinx.ext.intersphinx\",\n\t]\n\tintersphinx_mapping = {\n\t    \"python\": (\"https://docs.python.org/3/\", None),\n\t    \"sphinx\": (\"https://www.sphinx-doc.org/en/master/\", None),\n\t}\n\tintersphinx_disabled_domains = [\"std\"]\n", "templates_path = [\"_templates\"]\n\t# -- Options for HTML output\n\thtml_theme = \"sphinx_rtd_theme\"\n\t# -- Options for EPUB output\n\tepub_show_urls = \"footnote\"\n"]}
