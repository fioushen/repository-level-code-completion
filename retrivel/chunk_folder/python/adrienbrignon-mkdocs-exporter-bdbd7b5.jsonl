{"filename": "mkdocs_exporter/plugin.py", "chunked_list": ["from mkdocs.plugins import BasePlugin\n\tfrom mkdocs_exporter.page import Page\n\tfrom mkdocs.plugins import event_priority\n\tfrom mkdocs_exporter.config import Config\n\tfrom mkdocs.structure.files import File, Files\n\tfrom mkdocs_exporter.preprocessor import Preprocessor\n\tfrom mkdocs_exporter.themes.factory import Factory as ThemeFactory\n\tclass Plugin(BasePlugin[Config]):\n\t  \"\"\"The plugin.\"\"\"\n\t  def __init__(self) -> None:\n", "    \"\"\"The constructor.\"\"\"\n\t    self.stylesheets: list[File] = []\n\t  def on_config(self, config: dict) -> None:\n\t    \"\"\"Invoked when the configuration has been loaded.\"\"\"\n\t    self.theme = ThemeFactory.create(self.config.theme or config['theme'])\n\t  def on_pre_build(self, **kwargs) -> None:\n\t    \"\"\"Invoked before the build process starts.\"\"\"\n\t    self.stylesheets.clear()\n\t  def on_pre_page(self, page: Page, **kwargs) -> None:\n\t    \"\"\"Invoked after a page has been built.\"\"\"\n", "    page.html = None\n\t    page.formats = {}\n\t    page.theme = self.theme\n\t  @event_priority(-100)\n\t  def on_post_page(self, html: str, page: Page, **kwargs) -> str:\n\t    \"\"\"Invoked after a page has been built (and after all other plugins).\"\"\"\n\t    preprocessor = Preprocessor(theme=page.theme)\n\t    preprocessor.preprocess(html)\n\t    preprocessor.remove('*[data-decompose=\"true\"]')\n\t    preprocessor.teleport()\n", "    return preprocessor.done()\n\t  def on_files(self, files: Files, **kwargs) -> Files:\n\t    \"\"\"Invoked when files are ready to be manipulated.\"\"\"\n\t    self.stylesheets.extend(files.css_files())\n\t    return files\n\t  @event_priority(100)\n\t  def on_post_build(self, **kwargs) -> None:\n\t    \"\"\"Invoked when the build process is done.\"\"\"\n\t    for stylesheet in self.stylesheets:\n\t      content = None\n", "      with open(stylesheet.abs_dest_path, 'r', encoding='utf-8') as reader:\n\t        content = self.theme.stylesheet(reader.read())\n\t      with open(stylesheet.abs_dest_path, 'w+', encoding='utf-8') as writer:\n\t        writer.write(content)\n"]}
{"filename": "mkdocs_exporter/page.py", "chunked_list": ["from typing import Optional\n\tfrom mkdocs_exporter.theme import Theme\n\tfrom mkdocs.structure.pages import Page as BasePage\n\tclass Page(BasePage):\n\t  \"\"\"A page.\"\"\"\n\t  def __init__(self, *args, **kwargs):\n\t    \"\"\"The constructor.\"\"\"\n\t    self.html: Optional[str] = None\n\t    \"\"\"The page's HTML content.\"\"\"\n\t    self.formats: dict[str, str]\n", "    \"\"\"The documents that have been generated for this page (format as key, path to the file as value).\"\"\"\n\t    self.theme: Theme = None\n\t    \"\"\"The theme of the page.\"\"\"\n\t    super().__init__(*args, **kwargs)\n"]}
{"filename": "mkdocs_exporter/config.py", "chunked_list": ["from mkdocs.config import config_options as c\n\tfrom mkdocs.config.base import Config as BaseConfig\n\tclass Config(BaseConfig):\n\t  \"\"\"The plugin's configuration.\"\"\"\n\t  theme = c.Optional(c.Theme(default=None))\n\t  \"\"\"Override the theme used by your MkDocs instance.\"\"\"\n"]}
{"filename": "mkdocs_exporter/preprocessor.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\timport sass\n\tfrom typing import Union\n\tfrom urllib.parse import urlparse\n\tfrom bs4 import BeautifulSoup, Tag\n\tfrom mkdocs_exporter.theme import Theme\n\tfrom mkdocs_exporter.logging import logger\n\tclass Preprocessor():\n\t  \"\"\"The HTML preprocessor.\"\"\"\n", "  def __init__(self, html: str = None, **kwargs):\n\t    \"\"\"The constructor.\"\"\"\n\t    self.html = None\n\t    self.theme = None\n\t    if 'theme' in kwargs:\n\t      self.set_theme(kwargs['theme'])\n\t    self.preprocess(html)\n\t  def set_theme(self, theme: Theme) -> Preprocessor:\n\t    \"\"\"Sets the current theme.\"\"\"\n\t    self.theme = theme\n", "    return self\n\t  def preprocess(self, html: str) -> Preprocessor:\n\t    \"\"\"Gives the preprocessor some HTML to work on.\"\"\"\n\t    self.html = BeautifulSoup(html, 'lxml') if isinstance(html, str) else None\n\t    return self\n\t  def teleport(self) -> Preprocessor:\n\t    \"\"\"Teleport elements to their destination.\"\"\"\n\t    for element in self.html.select('*[data-teleport]'):\n\t      selector = element.attrs['data-teleport']\n\t      destination = self.html.select_one(selector)\n", "      tag = Tag(None, name=element.name, attrs=element.attrs)\n\t      if destination is None:\n\t        if element.string:\n\t          tag.string = '...'\n\t        logger.warn('Failed to teleport element `%s`: destination `%s` was not found', tag, selector)\n\t        continue\n\t      element.attrs['data-teleport'] = None\n\t      destination.append(element)\n\t    return self\n\t  def button(self, title: str, icon: str, attributes: dict = {}, **kwargs) -> Preprocessor:\n", "    \"\"\"Adds a button at the top of the page.\"\"\"\n\t    if kwargs.get('enabled', True) and self.theme:\n\t      self.theme.button(self, title, icon, attributes)\n\t    return self\n\t  def script(self, script: str = None, type: str = 'text/javascript', **kwargs) -> Preprocessor:\n\t    \"\"\"Appends a script to the document's body.\"\"\"\n\t    element = self.html.new_tag('script', type=type, **kwargs)\n\t    element.string = script\n\t    self.html.body.append(element)\n\t    return self\n", "  def stylesheet(self, stylesheet: str, **kwargs) -> Preprocessor:\n\t    \"\"\"Appends a stylesheet to the document's head.\"\"\"\n\t    css = sass.compile(string=stylesheet, output_style='compressed')\n\t    element = self.html.new_tag('style', type='text/css', rel='stylesheet', **kwargs)\n\t    element.string = css\n\t    self.html.head.append(element)\n\t    return self\n\t  def remove(self, selectors: Union[str, list[str]]) -> Preprocessor:\n\t    \"\"\"Removes some elements.\"\"\"\n\t    if isinstance(selectors, str):\n", "      selectors = [selectors]\n\t    for selector in selectors:\n\t      for element in self.html.select(selector):\n\t        element.decompose()\n\t    return self\n\t  def set_attribute(self, selector: str, key: str, value: str) -> Preprocessor:\n\t    \"\"\"Set an attribute on elements matching the given selector.\"\"\"\n\t    for element in self.html.select(selector):\n\t      element.attrs[key] = value\n\t    return self\n", "  def update_links(self, base: str, root: str = None) -> Preprocessor:\n\t    \"\"\"Updates links to their new base location.\"\"\"\n\t    for element in self.html.find_all('link', href=True):\n\t      element['href'] = self._resolve_link(element['href'], base, root)\n\t    for element in self.html.find_all(src=True):\n\t      element['src'] = self._resolve_link(element['src'], base, root)\n\t    return self\n\t  def done(self) -> str:\n\t    \"\"\"End the preprocessing, returning the result.\"\"\"\n\t    result = str(self.html)\n", "    self.html = None\n\t    return result\n\t  def _resolve_link(self, url: str, base: str, root: str = None) -> str:\n\t    \"\"\"Resolves a link to its new base location.\"\"\"\n\t    if bool(urlparse(url).netloc):\n\t      return url\n\t    if root is not None and os.path.isabs(url):\n\t      return 'file://' + os.path.abspath(os.path.join(root, url.strip('/')))\n\t    return 'file://' + os.path.abspath(os.path.join(base, url.strip('/')))\n"]}
{"filename": "mkdocs_exporter/theme.py", "chunked_list": ["from abc import abstractmethod\n\tfrom mkdocs.theme import Theme as BaseTheme\n\tclass Theme:\n\t  \"\"\"A theme.\"\"\"\n\t  def __init__(self, theme: BaseTheme):\n\t    \"\"\"The constructor.\"\"\"\n\t    self.theme = theme\n\t  @abstractmethod\n\t  def preprocess():\n\t    \"\"\"Preprocess the page especially for this theme.\"\"\"\n", "    raise NotImplementedError()\n\t  @abstractmethod\n\t  def button(self, preprocessor, title: str, icon: str, attributes: dict = {}):\n\t    \"\"\"Inserts a custom themed button.\"\"\"\n\t    raise NotImplementedError()\n\t  def stylesheet(self, css: str) -> str:\n\t    \"\"\"Transforms a stylesheet.\"\"\"\n\t    return css\n"]}
{"filename": "mkdocs_exporter/__init__.py", "chunked_list": []}
{"filename": "mkdocs_exporter/logging.py", "chunked_list": ["import logging\n\tlogger = logging.getLogger('mkdocs.plugins.mkdocs_exporter')\n\t\"\"\"The logger.\"\"\"\n"]}
{"filename": "mkdocs_exporter/renderer.py", "chunked_list": ["from abc import abstractmethod\n\tfrom mkdocs_exporter.page import Page\n\tclass Renderer:\n\t  \"\"\"A generic renderer.\"\"\"\n\t  @abstractmethod\n\t  def render(self, page: Page) -> any:\n\t    \"\"\"Renders the given page.\"\"\"\n\t    raise NotImplementedError()\n"]}
{"filename": "mkdocs_exporter/plugins/__init__.py", "chunked_list": []}
{"filename": "mkdocs_exporter/plugins/extras/plugin.py", "chunked_list": ["from typing import Optional\n\tfrom collections import UserDict\n\tfrom mkdocs.plugins import BasePlugin\n\tfrom mkdocs_exporter.page import Page\n\tfrom mkdocs.plugins import event_priority\n\tfrom mkdocs_exporter.preprocessor import Preprocessor\n\tfrom mkdocs_exporter.plugins.extras.config import Config\n\tclass Plugin(BasePlugin[Config]):\n\t  \"\"\"The plugin.\"\"\"\n\t  @event_priority(-85)\n", "  def on_post_page(self, html: str, page: Page, config: dict, **kwargs) -> Optional[str]:\n\t    \"\"\"Invoked after a page has been built.\"\"\"\n\t    if not self.config.enabled:\n\t      return\n\t    def resolve(object):\n\t      if callable(object):\n\t        return resolve(object(page, config=config))\n\t      if isinstance(object, list):\n\t        return [resolve(v) for v in object]\n\t      if isinstance(object, (dict, UserDict)):\n", "        return {k: resolve(v) for k, v in object.items()}\n\t      return object\n\t    preprocessor = Preprocessor(theme=page.theme)\n\t    preprocessor.preprocess(html)\n\t    for button in [*self.config.buttons, *page.meta.get('buttons', [])]:\n\t      if resolve(button.get('enabled', True)):\n\t        preprocessor.button(**resolve(button))\n\t    return preprocessor.done()\n"]}
{"filename": "mkdocs_exporter/plugins/extras/config.py", "chunked_list": ["from typing import Callable\n\tfrom mkdocs.config import config_options as c\n\tfrom mkdocs.config.base import Config as BaseConfig\n\tclass ButtonConfig(BaseConfig):\n\t  \"\"\"The configuration of a button.\"\"\"\n\t  enabled = c.Type((bool, Callable), default=True)\n\t  \"\"\"Is the button enabled?\"\"\"\n\t  title = c.Type((str, Callable))\n\t  \"\"\"The button's title.\"\"\"\n\t  icon = c.Type((str, Callable))\n", "  \"\"\"The button's icon (typically, an SVG element).\"\"\"\n\t  attributes = c.Type((dict, Callable), default={})\n\t  \"\"\"Some extra attributes to add to the button.\"\"\"\n\tclass Config(BaseConfig):\n\t  \"\"\"The plugin's configuration.\"\"\"\n\t  enabled = c.Type(bool, default=True)\n\t  \"\"\"Is the plugin enabled?\"\"\"\n\t  downloads = c.ListOfItems(c.Choice(('pdf', 'html')), default=['pdf'])\n\t  \"\"\"The download buttons to show.\"\"\"\n\t  buttons = c.ListOfItems(c.SubConfig(ButtonConfig))\n", "  \"\"\"The buttons to add.\"\"\"\n"]}
{"filename": "mkdocs_exporter/plugins/extras/__init__.py", "chunked_list": []}
{"filename": "mkdocs_exporter/plugins/pdf/button.py", "chunked_list": ["import os\n\tfrom mkdocs_exporter.page import Page\n\tdef enabled(page: Page, **kwargs) -> bool:\n\t  \"\"\"Is the button enabled?\"\"\"\n\t  return 'pdf' in page.formats\n\tdef href(page: Page, **kwargs) -> str:\n\t  \"\"\"The button's 'href' attribute.\"\"\"\n\t  return os.path.relpath(page.formats['pdf'], page.url)\n\tdef download(page: Page, **kwargs) -> str:\n\t  \"\"\"The button's 'download' attribute.\"\"\"\n", "  return page.title + os.path.extsep + 'pdf'\n\tdef icon(page: Page, **kwargs) -> str:\n\t  \"\"\"The button's icon.\"\"\"\n\t  return page.meta.get('pdf-icon', 'material-file-download-outline')\n"]}
{"filename": "mkdocs_exporter/plugins/pdf/plugin.py", "chunked_list": ["import os\n\timport types\n\timport asyncio\n\timport nest_asyncio\n\tfrom mkdocs.plugins import BasePlugin\n\tfrom mkdocs_exporter.page import Page\n\tfrom mkdocs.plugins import event_priority\n\tfrom mkdocs_exporter.logging import logger\n\tfrom mkdocs.livereload import LiveReloadServer\n\tfrom typing import Optional, Coroutine, Sequence\n", "from mkdocs_exporter.plugins.pdf.config import Config\n\tfrom mkdocs_exporter.plugins.pdf.renderer import Renderer\n\tclass Plugin(BasePlugin[Config]):\n\t  \"\"\"The plugin.\"\"\"\n\t  def __init__(self):\n\t    \"\"\"The constructor.\"\"\"\n\t    self.watch: list[str] = []\n\t    self.renderer: Optional[Renderer] = None\n\t    self.tasks: list[types.CoroutineType] = []\n\t    self.loop: asyncio.AbstractEventLoopPolicy = asyncio.new_event_loop()\n", "  def on_startup(self, **kwargs) -> None:\n\t    \"\"\"Invoked when the plugin is starting...\"\"\"\n\t    nest_asyncio.apply(self.loop)\n\t    asyncio.set_event_loop(self.loop)\n\t  def on_config(self, config: dict) -> None:\n\t    \"\"\"Invoked when the configuration has been validated.\"\"\"\n\t    self.watch = []\n\t  def on_serve(self, server: LiveReloadServer, **kwargs) -> LiveReloadServer:\n\t    \"\"\"Invoked when the website is being served.\"\"\"\n\t    if not self._enabled():\n", "      return\n\t    for path in [*self.config.stylesheets, *self.config.scripts]:\n\t      server.watch(path)\n\t    for path in set(os.path.normpath(path) for path in self.watch):\n\t      server.watch(path)\n\t    return server\n\t  def on_page_markdown(self, markdown: str, page: Page, config: Config, **kwargs) -> str:\n\t    \"\"\"Invoked when the page's markdown has been loaded.\"\"\"\n\t    if not self._enabled(page) or 'covers' in page.meta.get('hide', []):\n\t      return\n", "    content = markdown\n\t    covers = {**self.config.covers, **{k: os.path.join(os.path.dirname(config['config_file_path']), v) for k, v in page.meta.get('covers', {}).items()}}\n\t    if covers.get('front'):\n\t      with open(covers['front'], 'r', encoding='utf-8') as file:\n\t        content = self.renderer.cover(file.read()) + content\n\t    if covers.get('back'):\n\t      with open(covers['back'], 'r', encoding='utf-8') as file:\n\t        content = content + self.renderer.cover(file.read())\n\t    for path in [path for path in covers.values() if path is not None]:\n\t      self.watch.append(path)\n", "    return content\n\t  def on_pre_build(self, **kwargs) -> None:\n\t    \"\"\"Invoked before the build process starts.\"\"\"\n\t    self.tasks.clear()\n\t    if not self._enabled():\n\t      return\n\t    self.renderer = Renderer(browser_options=self.config.browser)\n\t    for stylesheet in self.config.stylesheets:\n\t      self.renderer.add_stylesheet(stylesheet)\n\t    for script in self.config.scripts:\n", "      self.renderer.add_script(script)\n\t  def on_pre_page(self, page: Page, config: dict, **kwargs):\n\t    \"\"\"Invoked before building the page.\"\"\"\n\t    if not self._enabled():\n\t      return\n\t    if not hasattr(page, 'html'):\n\t      raise Exception('Missing `mkdocs/exporter` plugin or your plugins are not ordered properly!')\n\t    directory = os.path.dirname(page.file.abs_dest_path)\n\t    filename = os.path.splitext(os.path.basename(page.file.abs_dest_path))[0] + '.pdf'\n\t    fullpath = os.path.join(directory, filename)\n", "    page.formats['pdf'] = os.path.relpath(fullpath, config['site_dir'])\n\t  @event_priority(-75)\n\t  def on_post_page(self, html: str, page: Page, config: dict) -> Optional[str]:\n\t    \"\"\"Invoked after a page has been built.\"\"\"\n\t    if not self._enabled(page) and 'pdf' in page.formats:\n\t      del page.formats['pdf']\n\t    if 'pdf' not in page.formats:\n\t      return html\n\t    page.html = html\n\t    async def render(page: Page) -> None:\n", "      logger.info(\"[pdf] Rendering '%s'...\", page.file.src_path)\n\t      html = self.renderer.preprocess(page)\n\t      pdf = await self.renderer.render(html)\n\t      page.html = None\n\t      with open(os.path.join(config['site_dir'], page.formats['pdf']), 'wb+') as file:\n\t        file.write(pdf)\n\t        logger.info(\"[pdf] File written to '%s'!\", file.name)\n\t    self.tasks.append(render(page))\n\t    return page.html\n\t  def on_post_build(self, **kwargs) -> None:\n", "    \"\"\"Invoked after the build process.\"\"\"\n\t    if not self._enabled():\n\t      return\n\t    def concurrently(coroutines: Sequence[Coroutine], concurrency: int) -> Sequence[Coroutine]:\n\t      semaphore = asyncio.Semaphore(concurrency)\n\t      async def limit(coroutine: Coroutine) -> Coroutine:\n\t        async with semaphore:\n\t          return await asyncio.create_task(coroutine)\n\t      return [limit(coroutine) for coroutine in coroutines]\n\t    self.loop.run_until_complete(asyncio.gather(*concurrently(self.tasks, max(1, self.config.concurrency or 1))))\n", "    self.loop.run_until_complete(self.renderer.dispose())\n\t    self.tasks.clear()\n\t    self.renderer = None\n\t  def _enabled(self, page: Page = None) -> bool:\n\t    \"\"\"Is the plugin enabled for this page?\"\"\"\n\t    if not self.config.enabled:\n\t      return False\n\t    if page and not page.meta.get('pdf', not self.config.explicit):\n\t      return False\n\t    return True\n"]}
{"filename": "mkdocs_exporter/plugins/pdf/config.py", "chunked_list": ["from mkdocs.config import config_options as c\n\tfrom mkdocs.config.base import Config as BaseConfig\n\tclass BrowserConfig(BaseConfig):\n\t  \"\"\"The browser's configuration.\"\"\"\n\t  debug = c.Type(bool, default=False)\n\t  \"\"\"Should console messages sent to the browser be logged?\"\"\"\n\tclass CoversConfig(BaseConfig):\n\t  \"\"\"The cover's configuration.\"\"\"\n\t  front = c.Optional(c.File(exists=True))\n\t  \"\"\"The front cover template location.\"\"\"\n", "  back = c.Optional(c.File(exists=True))\n\t  \"\"\"The back cover template location.\"\"\"\n\tclass Config(BaseConfig):\n\t  \"\"\"The plugin's configuration.\"\"\"\n\t  enabled = c.Type(bool, default=True)\n\t  \"\"\"Is the generator enabled?\"\"\"\n\t  explicit = c.Type(bool, default=False)\n\t  \"\"\"Should pages specify explicitly that they should be rendered as PDF?\"\"\"\n\t  concurrency = c.Type(int, default=4)\n\t  \"\"\"The maximum number of concurrent PDF generation tasks.\"\"\"\n", "  stylesheets = c.ListOfItems(c.File(exists=True), default=[])\n\t  \"\"\"A list of custom stylesheets to apply before rendering documents.\"\"\"\n\t  scripts = c.ListOfItems(c.File(exists=True), default=[])\n\t  \"\"\"A list of custom scripts to inject before rendering documents.\"\"\"\n\t  covers = c.SubConfig(CoversConfig)\n\t  \"\"\"The document's cover pages.\"\"\"\n\t  browser = c.SubConfig(BrowserConfig)\n\t  \"\"\"The browser's configuration.\"\"\"\n"]}
{"filename": "mkdocs_exporter/plugins/pdf/__init__.py", "chunked_list": []}
{"filename": "mkdocs_exporter/plugins/pdf/renderer.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\timport importlib_resources\n\tfrom urllib.parse import unquote\n\tfrom mkdocs_exporter.page import Page\n\tfrom mkdocs_exporter.resources import js\n\tfrom mkdocs_exporter.preprocessor import Preprocessor\n\tfrom mkdocs_exporter.plugins.pdf.browser import Browser\n\tfrom mkdocs_exporter.renderer import Renderer as BaseRenderer\n\tclass Renderer(BaseRenderer):\n", "  \"\"\"The renderer.\"\"\"\n\t  def __init__(self, browser: Browser = None, browser_options: dict = None):\n\t    \"\"\"The constructor.\"\"\"\n\t    self.scripts: list[str] = []\n\t    self.stylesheets: list[str] = []\n\t    self.browser = browser or Browser(browser_options)\n\t  def add_stylesheet(self, path: str) -> Renderer:\n\t    \"\"\"Adds a stylesheet to the renderer.\"\"\"\n\t    self.stylesheets.append(path)\n\t    return self\n", "  def add_script(self, path: str) -> Renderer:\n\t    \"\"\"Adds a script to the renderer.\"\"\"\n\t    self.scripts.append(path)\n\t    return self\n\t  def cover(self, template: str) -> Renderer:\n\t    \"\"\"Renders a cover.\"\"\"\n\t    content = template.strip('\\n')\n\t    return f'<div data-decompose=\"true\">{content}</div>' + '\\n'\n\t  def preprocess(self, page: Page) -> str:\n\t    \"\"\"Preprocesses a page, returning HTML that can be printed.\"\"\"\n", "    preprocessor = Preprocessor(theme=page.theme)\n\t    base = os.path.dirname(page.file.abs_dest_path)\n\t    root = base.replace(unquote(page.url).rstrip('/'), '', 1).rstrip('/')\n\t    preprocessor.preprocess(page.html)\n\t    preprocessor.set_attribute('details:not([open])', 'open', 'open')\n\t    page.theme.preprocess(preprocessor)\n\t    preprocessor.script(importlib_resources.files(js).joinpath('pdf.js').read_text(encoding='utf-8'))\n\t    for stylesheet in self.stylesheets:\n\t      with open(stylesheet, 'r', encoding='utf-8') as file:\n\t        preprocessor.stylesheet(file.read())\n", "    for script in self.scripts:\n\t      with open(script, 'r', encoding='utf-8') as file:\n\t        preprocessor.script(file.read())\n\t    preprocessor.script(importlib_resources.files(js).joinpath('pagedjs.min.js').read_text(encoding='utf-8'))\n\t    preprocessor.teleport()\n\t    preprocessor.update_links(base, root)\n\t    return preprocessor.done()\n\t  async def render(self, page: str | Page) -> bytes:\n\t    \"\"\"Renders a page as a PDF document.\"\"\"\n\t    if not self.browser.launched:\n", "      await self.browser.launch()\n\t    html = page if isinstance(page, str) else self.preprocess(page)\n\t    return await self.browser.print(html)\n\t  async def dispose(self) -> None:\n\t    \"\"\"Dispose of the renderer.\"\"\"\n\t    if self.browser:\n\t      await self.browser.close()\n"]}
{"filename": "mkdocs_exporter/plugins/pdf/browser.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\timport asyncio\n\tfrom tempfile import NamedTemporaryFile\n\tfrom mkdocs_exporter.logging import logger\n\tfrom playwright.async_api import async_playwright\n\tclass Browser:\n\t  \"\"\"A web browser instance.\"\"\"\n\t  args = [\n\t    '--allow-file-access-from-files'\n", "  ]\n\t  \"\"\"The browser's arguments...\"\"\"\n\t  @property\n\t  def launched(self):\n\t    \"\"\"Has the browser been launched?\"\"\"\n\t    return self._launched\n\t  def __init__(self, options: dict = {}):\n\t    \"\"\"The constructor.\"\"\"\n\t    self.browser = None\n\t    self.context = None\n", "    self._launched = False\n\t    self.playwright = None\n\t    self.lock = asyncio.Lock()\n\t    self.debug = options.get('debug', False)\n\t  async def launch(self) -> Browser:\n\t    \"\"\"Launches the browser.\"\"\"\n\t    if self.launched:\n\t      return self\n\t    async with self.lock:\n\t      if self.launched:\n", "        return self\n\t      logger.info('Launching browser...')\n\t      self.playwright = await async_playwright().start()\n\t      self.browser = await self.playwright.chromium.launch(headless=True, args=self.args)\n\t      self.context = await self.browser.new_context()\n\t      if self.debug:\n\t        async def log(msg):\n\t          for arg in msg.args:\n\t            logger.info(f\"[pdf.browser] ({msg.type}) {await msg.page.title()}\\n\\t{await arg.json_value()}\")\n\t        self.context.on('console', log)\n", "      self._launched = True\n\t    return self\n\t  async def close(self) -> Browser:\n\t    \"\"\"Closes the browser.\"\"\"\n\t    if self.context:\n\t      await self.context.close()\n\t    if self.browser:\n\t      await self.browser.close()\n\t    if self.playwright:\n\t      await self.playwright.stop()\n", "    self._launched = False\n\t    return self\n\t  async def print(self, html: str) -> bytes:\n\t    \"\"\"Prints some HTML to PDF.\"\"\"\n\t    page = await self.context.new_page()\n\t    file = NamedTemporaryFile(suffix='.html', mode='w+', encoding='utf-8', delete=False)\n\t    file.write(html)\n\t    file.close()\n\t    await page.goto('file://' + file.name, wait_until='networkidle')\n\t    await page.locator('body[mkdocs-exporter=\"true\"]').wait_for(timeout=30000)\n", "    pdf = await page.pdf(prefer_css_page_size=True, print_background=True, display_header_footer=False)\n\t    try:\n\t      os.unlink(file)\n\t    except Exception:\n\t      pass\n\t    await page.close()\n\t    return pdf\n"]}
{"filename": "mkdocs_exporter/themes/__init__.py", "chunked_list": []}
{"filename": "mkdocs_exporter/themes/factory.py", "chunked_list": ["from mkdocs_exporter.theme import Theme\n\tfrom mkdocs.theme import Theme as BaseTheme\n\tfrom mkdocs_exporter.themes.material.theme import Theme as MaterialTheme\n\tfrom mkdocs_exporter.themes.readthedocs.theme import Theme as ReadTheDocsTheme\n\tclass Factory:\n\t  \"\"\"The theme factory.\"\"\"\n\t  themes: 'list[Theme]' = [MaterialTheme, ReadTheDocsTheme]\n\t  \"\"\"The themes that are available.\"\"\"\n\t  @classmethod\n\t  def create(self, theme: BaseTheme):\n", "    \"\"\"Creates a theme instance.\"\"\"\n\t    for t in self.themes:\n\t      if t.name == theme.name:\n\t        return t(theme)\n\t    raise RuntimeError(f'The theme you are using ({theme.name}) is not supported yet, sorry.')\n"]}
{"filename": "mkdocs_exporter/themes/readthedocs/theme.py", "chunked_list": ["from __future__ import annotations\n\timport importlib_resources\n\tfrom mkdocs_exporter.resources import css\n\tfrom mkdocs_exporter.theme import Theme as BaseTheme\n\tfrom mkdocs_exporter.preprocessor import Preprocessor\n\tclass Theme(BaseTheme):\n\t  \"\"\"The \"readthedocs\" theme.\"\"\"\n\t  name = 'readthedocs'\n\t  \"\"\"The name of the theme.\"\"\"\n\t  def preprocess(self, preprocessor: Preprocessor) -> None:\n", "    \"\"\"Preprocesses the DOM before rendering a document.\"\"\"\n\t    preprocessor.remove(['.rst-content > div[role=\"navigation\"]', 'nav.wy-nav-side'])\n\t    preprocessor.stylesheet(importlib_resources.files(css).joinpath('readthedocs.css').read_text(encoding='utf-8'))\n\t  def button(self, preprocessor: Preprocessor, title: str, icon: str, attributes: dict = {}):\n\t    \"\"\"Inserts a custom themed button.\"\"\"\n\t    button = preprocessor.html.new_tag('a', title=title, attrs={'class': 'btn btn-neutral float-right', **attributes})\n\t    button.string = title\n\t    preprocessor.html.find('div', {'class': 'document'}).insert(0, button)\n\t  def icon(self, name: str):\n\t    \"\"\"Gets a themed icon.\"\"\"\n", "    return None\n\t  def stylesheet(self, css: str) -> str:\n\t    \"\"\"Transforms a stylesheet.\"\"\"\n\t    return css.replace(':nth-of-type(3n+1)', ':nth-of-type(3n)')\n"]}
{"filename": "mkdocs_exporter/themes/readthedocs/__init__.py", "chunked_list": []}
{"filename": "mkdocs_exporter/themes/material/icons.py", "chunked_list": ["from materialx.emoji import twemoji, to_svg\n\tclass HTMLStash:\n\t  \"\"\"Markdown HTML stash stub.\"\"\"\n\t  def store(self, str):\n\t    return str\n\tclass MarkdownEmoji:\n\t  \"\"\"Markdown Emojij stub.\"\"\"\n\t  emoji_index = twemoji({}, None)\n\tclass Markdown:\n\t  \"\"\"Markdown stub.\"\"\"\n", "  htmlStash = HTMLStash()\n\t  inlinePatterns = {\n\t    'emoji': MarkdownEmoji()\n\t  }\n\tdef get_icon(name):\n\t  \"\"\"Gets an icon by its name.\"\"\"\n\t  if not name.startswith(':'):\n\t    name = ':' + name\n\t  if not name.endswith(':'):\n\t    name = name + ':'\n", "  try:\n\t    icon = to_svg('twemoji', name, None, None, None, None, None, {}, Markdown())\n\t    if icon is not None:\n\t      return icon.text\n\t  except KeyError:\n\t    return None\n"]}
{"filename": "mkdocs_exporter/themes/material/theme.py", "chunked_list": ["from __future__ import annotations\n\tfrom bs4 import BeautifulSoup\n\tfrom mkdocs_exporter.theme import Theme as BaseTheme\n\tfrom mkdocs_exporter.preprocessor import Preprocessor\n\tfrom mkdocs_exporter.themes.material.icons import get_icon\n\tclass Theme(BaseTheme):\n\t  \"\"\"The \"material\" theme.\"\"\"\n\t  name = 'material'\n\t  \"\"\"The name of the theme.\"\"\"\n\t  def preprocess(self, preprocessor: Preprocessor) -> None:\n", "    \"\"\"Preprocesses the DOM before rendering a document.\"\"\"\n\t    preprocessor.remove(['.md-sidebar.md-sidebar--primary', '.md-sidebar.md-sidebar--secondary', 'header.md-header', '.md-container > nav', 'nav.md-tags'])\n\t  def button(self, preprocessor: Preprocessor, title: str, icon: str, attributes: dict = {}):\n\t    \"\"\"Inserts a custom themed button.\"\"\"\n\t    tags = preprocessor.html.find('nav', {'class': 'md-tags'})\n\t    button = preprocessor.html.new_tag('a', title=title, attrs={'class': 'md-content__button md-icon', **attributes})\n\t    icon = self.icon(icon) or self.icon('material-progress-question')\n\t    button.append(BeautifulSoup(icon, 'lxml'))\n\t    if tags:\n\t      tags.insert_after(button)\n", "    else:\n\t      preprocessor.html.find('article', {'class': 'md-content__inner'}).insert(0, button)\n\t    return self\n\t  def icon(self, name: str):\n\t    \"\"\"Gets a themed icon.\"\"\"\n\t    return get_icon(name)\n"]}
{"filename": "mkdocs_exporter/themes/material/__init__.py", "chunked_list": []}
{"filename": "mkdocs_exporter/resources/__init__.py", "chunked_list": []}
{"filename": "mkdocs_exporter/resources/css/__init__.py", "chunked_list": []}
{"filename": "mkdocs_exporter/resources/js/__init__.py", "chunked_list": []}
