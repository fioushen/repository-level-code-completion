{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "slonogram/bot.py", "chunked_list": ["import warnings\n\tfrom adaptix import Retort, name_mapping\n\tfrom typing import Optional, Self\n\tfrom .types.api_session import ApiSession\n\tfrom .schemas import Message, Update\n\tfrom .consts import DEFAULT_API_URL\n\tfrom .call_groups import chat, user, updates, queries\n\tclass Bot:\n\t    def __init__(\n\t        self,\n", "        token: Optional[str] = None,\n\t        base_url: Optional[str] = None,\n\t        session: Optional[ApiSession] = None,\n\t    ) -> None:\n\t        u_session: ApiSession\n\t        retort = Retort(\n\t            debug_path=True,\n\t            recipe=[\n\t                name_mapping(Update, map={\"id\": \"update_id\"}),\n\t                name_mapping(Message, map={\"id\": \"message_id\"}),\n", "                name_mapping(trim_trailing_underscore=True),\n\t            ],\n\t        )\n\t        if session is None:\n\t            from .extra.aiohttp_session import Session\n\t            if token is None:\n\t                raise ValueError(\"No bot token passed\")\n\t            u_session = Session(\n\t                token=token, base_url=base_url or DEFAULT_API_URL\n\t            )\n", "        else:\n\t            u_session = session\n\t        self.chat = chat.ChatCallGroup(retort, u_session)\n\t        self.user = user.UserCallGroup(retort, u_session)\n\t        self.updates = updates.UpdatesCallGroup(retort, u_session)\n\t        self.queries = queries.QueriesCallGroup(retort, u_session)\n\t        self._session = u_session\n\t        self._finalized = False\n\t    async def __aenter__(self) -> Self:\n\t        return self\n", "    async def __aexit__(self, exc_type, exc_value, traceback) -> None:\n\t        _ = exc_value\n\t        _ = traceback\n\t        await self.finalize()\n\t        if exc_type is not None:\n\t            raise exc_type\n\t    async def finalize(self) -> None:\n\t        if self._finalized:\n\t            warnings.warn(\n\t                \"tried to call `finalize` when `Bot`\"\n", "                \" instance is already finalized.\"\n\t            )\n\t            return\n\t        await self._session.finalize()\n\t        self._finalized = True\n\t    def __del__(self) -> None:\n\t        if not self._finalized:\n\t            warnings.warn(\n\t                \"`Bot` is not finalized properly, you can do\"\n\t                \" this either by calling `await bot.finalize()` or wrapping \"\n", "                \"`Bot` creation in the `async with` context\"\n\t            )\n"]}
{"filename": "slonogram/consts.py", "chunked_list": ["DEFAULT_API_URL = \"https://api.telegram.org/\"\n\tCOMMAND_REGEX = r\"\\/([\\w\\d_\\-]+)(@([\\w\\d_]+))?\"\n\t__all__ = [\"COMMAND_REGEX\", \"DEFAULT_API_URL\"]\n"]}
{"filename": "slonogram/schemas.py", "chunked_list": ["from __future__ import annotations\n\tfrom enum import Enum\n\tfrom dataclasses import dataclass\n\tfrom typing import List, Optional\n\tclass ChatAction(str, Enum):\n\t    TYPING = \"typing\"\n\t    UPLOAD_PHOTO = \"upload_photo\"\n\t    RECORD_VIDEO = \"record_video\"\n\t    UPLOAD_VIDEO = \"upload_video\"\n\t    RECORD_VOICE = \"record_voice\"\n", "    UPLOAD_VOICE = \"upload_voice\"\n\t    UPLOAD_DOCUMENT = \"upload_document\"\n\t    CHOOSE_STICKER = \"choose_sticker\"\n\t    FIND_LOCATION = \"find_location\"\n\t    RECORD_VIDEO_NOTE = \"record_video_note\"\n\t    UPLOAD_VIDEO_NOTE = \"upload_video_note\"\n\tclass EntityType(str, Enum):\n\t    MENTION = \"mention\"\n\t    HASHTAG = \"hashtag\"\n\t    CASHTAG = \"cashtag\"\n", "    BOT_COMMAND = \"bot_command\"\n\t    URL = \"url\"\n\t    EMAIL = \"email\"\n\t    PHONE_NUMBER = \"phone_number\"\n\t    BOLD = \"bold\"\n\t    ITALIC = \"italic\"\n\t    UNDERLINE = \"underline\"\n\t    STRIKETHROUGH = \"strikethrough\"\n\t    SPOILER = \"spoiler\"\n\t    CODE = \"code\"\n", "    PRE = \"pre\"\n\t    TEXT_LINK = \"text_link\"\n\t    TEXT_MENTION = \"text_mention\"\n\t    CUSTOM_EMOJI = \"custom_emoji\"\n\tclass UpdateType(str, Enum):\n\t    MESSAGE = \"message\"\n\t    EDITED_MESSAGE = \"edited_message\"\n\t    CHANNEL_POST = \"channel_post\"\n\t    EDITED_CHANNEL_POST = \"edited_channel_post\"\n\t    INLINE_QUERY = \"inline_query\"\n", "    CHOSEN_INLINE_RESULT = \"chosen_inline_result\"\n\t    CALLBACK_QUERY = \"callback_query\"\n\t    SHIPPING_QUERY = \"shipping_query\"\n\t    PRE_CHECKOUT_QUERY = \"pre_checkout_query\"\n\t    POLL = \"poll\"\n\t    POLL_ANSWER = \"poll_answer\"\n\t    MY_CHAT_MEMBER = \"my_chat_member\"\n\t    CHAT_MEMBER = \"chat_member\"\n\t    CHAT_JOIN_REQUEST = \"chat_join_request\"\n\tclass ParseMode(str, Enum):\n", "    MARKDOWN_V2 = \"MarkdownV2\"\n\t    HTML = \"HTML\"\n\t    MARKDOWN = \"Markdown\"\n\t@dataclass(slots=True)\n\tclass Update:\n\t    id: int\n\t    message: Optional[Message] = None\n\t    edited_message: Optional[Message] = None\n\t    channel_post: Optional[Message] = None\n\t    edited_channel_post: Optional[Message] = None\n", "    inline_query: Optional[InlineQuery] = None\n\t    chosen_inline_result: Optional[ChosenInlineResult] = None\n\t    callback_query: Optional[CallbackQuery] = None\n\t    shipping_query: Optional[ShippingQuery] = None\n\t    pre_checkout_query: Optional[PreCheckoutQuery] = None\n\t    poll: Optional[Poll] = None\n\t    poll_answer: Optional[PollAnswer] = None\n\t    my_chat_member: Optional[ChatMemberUpdated] = None\n\t    chat_member: Optional[ChatMemberUpdated] = None\n\t    chat_join_request: Optional[ChatJoinRequest] = None\n", "@dataclass(slots=True)\n\tclass WebhookInfo:\n\t    url: str\n\t    has_custom_certificate: bool\n\t    pending_update_count: int\n\t    ip_address: Optional[str] = None\n\t    last_error_date: Optional[int] = None\n\t    last_error_message: Optional[str] = None\n\t    last_synchronization_error_date: Optional[int] = None\n\t    max_connections: Optional[int] = None\n", "    allowed_updates: Optional[List[str]] = None\n\t@dataclass(slots=True)\n\tclass User:\n\t    id: int\n\t    is_bot: bool\n\t    first_name: str\n\t    last_name: Optional[str] = None\n\t    username: Optional[str] = None\n\t    language_code: Optional[str] = None\n\t    is_premium: Optional[bool] = None\n", "    added_to_attachment_menu: Optional[bool] = None\n\t    can_join_groups: Optional[bool] = None\n\t    can_read_all_group_messages: Optional[bool] = None\n\t    supports_inline_queries: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass Chat:\n\t    id: int\n\t    type: str\n\t    title: Optional[str] = None\n\t    username: Optional[str] = None\n", "    first_name: Optional[str] = None\n\t    last_name: Optional[str] = None\n\t    is_forum: Optional[bool] = None\n\t    photo: Optional[ChatPhoto] = None\n\t    active_usernames: Optional[List[str]] = None\n\t    emoji_status_custom_emoji_id: Optional[str] = None\n\t    bio: Optional[str] = None\n\t    has_private_forwards: Optional[bool] = None\n\t    has_restricted_voice_and_video_messages: Optional[bool] = None\n\t    join_to_send_messages: Optional[bool] = None\n", "    join_by_request: Optional[bool] = None\n\t    description: Optional[str] = None\n\t    invite_link: Optional[str] = None\n\t    pinned_message: Optional[Message] = None\n\t    permissions: Optional[ChatPermissions] = None\n\t    slow_mode_delay: Optional[int] = None\n\t    message_auto_delete_time: Optional[int] = None\n\t    has_aggressive_anti_spam_enabled: Optional[bool] = None\n\t    has_hidden_members: Optional[bool] = None\n\t    has_protected_content: Optional[bool] = None\n", "    sticker_set_name: Optional[str] = None\n\t    can_set_sticker_set: Optional[bool] = None\n\t    linked_chat_id: Optional[int] = None\n\t    location: Optional[ChatLocation] = None\n\t@dataclass(slots=True)\n\tclass Message:\n\t    id: int\n\t    date: int\n\t    chat: Chat\n\t    message_thread_id: Optional[int] = None\n", "    from_: Optional[User] = None\n\t    sender_chat: Optional[Chat] = None\n\t    forward_from: Optional[User] = None\n\t    forward_from_chat: Optional[Chat] = None\n\t    forward_from_message_id: Optional[int] = None\n\t    forward_signature: Optional[str] = None\n\t    forward_sender_name: Optional[str] = None\n\t    forward_date: Optional[int] = None\n\t    is_topic_message: Optional[bool] = None\n\t    is_automatic_forward: Optional[bool] = None\n", "    reply_to_message: Optional[Message] = None\n\t    via_bot: Optional[User] = None\n\t    edit_date: Optional[int] = None\n\t    has_protected_content: Optional[bool] = None\n\t    media_group_id: Optional[str] = None\n\t    author_signature: Optional[str] = None\n\t    text: Optional[str] = None\n\t    entities: Optional[List[MessageEntity]] = None\n\t    animation: Optional[Animation] = None\n\t    audio: Optional[Audio] = None\n", "    document: Optional[Document] = None\n\t    photo: Optional[List[PhotoSize]] = None\n\t    sticker: Optional[Sticker] = None\n\t    video: Optional[Video] = None\n\t    video_note: Optional[VideoNote] = None\n\t    voice: Optional[Voice] = None\n\t    caption: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    has_media_spoiler: Optional[bool] = None\n\t    contact: Optional[Contact] = None\n", "    dice: Optional[Dice] = None\n\t    game: Optional[Game] = None\n\t    poll: Optional[Poll] = None\n\t    venue: Optional[Venue] = None\n\t    location: Optional[Location] = None\n\t    new_chat_members: Optional[List[User]] = None\n\t    left_chat_member: Optional[User] = None\n\t    new_chat_title: Optional[str] = None\n\t    new_chat_photo: Optional[List[PhotoSize]] = None\n\t    delete_chat_photo: Optional[bool] = None\n", "    group_chat_created: Optional[bool] = None\n\t    supergroup_chat_created: Optional[bool] = None\n\t    channel_chat_created: Optional[bool] = None\n\t    message_auto_delete_timer_changed: Optional[\n\t        MessageAutoDeleteTimerChanged\n\t    ] = None\n\t    migrate_to_chat_id: Optional[int] = None\n\t    migrate_from_chat_id: Optional[int] = None\n\t    pinned_message: Optional[Message] = None\n\t    invoice: Optional[Invoice] = None\n", "    successful_payment: Optional[SuccessfulPayment] = None\n\t    user_shared: Optional[UserShared] = None\n\t    chat_shared: Optional[ChatShared] = None\n\t    connected_website: Optional[str] = None\n\t    write_access_allowed: Optional[WriteAccessAllowed] = None\n\t    passport_data: Optional[PassportData] = None\n\t    proximity_alert_triggered: Optional[ProximityAlertTriggered] = None\n\t    forum_topic_created: Optional[ForumTopicCreated] = None\n\t    forum_topic_edited: Optional[ForumTopicEdited] = None\n\t    forum_topic_closed: Optional[ForumTopicClosed] = None\n", "    forum_topic_reopened: Optional[ForumTopicReopened] = None\n\t    general_forum_topic_hidden: Optional[GeneralForumTopicHidden] = None\n\t    general_forum_topic_unhidden: Optional[\n\t        GeneralForumTopicUnhidden\n\t    ] = None\n\t    video_chat_scheduled: Optional[VideoChatScheduled] = None\n\t    video_chat_started: Optional[VideoChatStarted] = None\n\t    video_chat_ended: Optional[VideoChatEnded] = None\n\t    video_chat_participants_invited: Optional[\n\t        VideoChatParticipantsInvited\n", "    ] = None\n\t    web_app_data: Optional[WebAppData] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t@dataclass(slots=True)\n\tclass MessageId:\n\t    message_id: int\n\t@dataclass(slots=True)\n\tclass MessageEntity:\n\t    type: EntityType\n\t    offset: int\n", "    length: int\n\t    url: Optional[str] = None\n\t    user: Optional[User] = None\n\t    language: Optional[str] = None\n\t    custom_emoji_id: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass PhotoSize:\n\t    file_id: str\n\t    file_unique_id: str\n\t    width: int\n", "    height: int\n\t    file_size: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass Animation:\n\t    file_id: str\n\t    file_unique_id: str\n\t    width: int\n\t    height: int\n\t    duration: int\n\t    thumbnail: Optional[PhotoSize] = None\n", "    file_name: Optional[str] = None\n\t    mime_type: Optional[str] = None\n\t    file_size: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass Audio:\n\t    file_id: str\n\t    file_unique_id: str\n\t    duration: int\n\t    performer: Optional[str] = None\n\t    title: Optional[str] = None\n", "    file_name: Optional[str] = None\n\t    mime_type: Optional[str] = None\n\t    file_size: Optional[int] = None\n\t    thumbnail: Optional[PhotoSize] = None\n\t@dataclass(slots=True)\n\tclass Document:\n\t    file_id: str\n\t    file_unique_id: str\n\t    thumbnail: Optional[PhotoSize] = None\n\t    file_name: Optional[str] = None\n", "    mime_type: Optional[str] = None\n\t    file_size: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass Video:\n\t    file_id: str\n\t    file_unique_id: str\n\t    width: int\n\t    height: int\n\t    duration: int\n\t    thumbnail: Optional[PhotoSize] = None\n", "    file_name: Optional[str] = None\n\t    mime_type: Optional[str] = None\n\t    file_size: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass VideoNote:\n\t    file_id: str\n\t    file_unique_id: str\n\t    length: int\n\t    duration: int\n\t    thumbnail: Optional[PhotoSize] = None\n", "    file_size: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass Voice:\n\t    file_id: str\n\t    file_unique_id: str\n\t    duration: int\n\t    mime_type: Optional[str] = None\n\t    file_size: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass Contact:\n", "    phone_number: str\n\t    first_name: str\n\t    last_name: Optional[str] = None\n\t    user_id: Optional[int] = None\n\t    vcard: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass Dice:\n\t    emoji: str\n\t    value: int\n\t@dataclass(slots=True)\n", "class PollOption:\n\t    text: str\n\t    voter_count: int\n\t@dataclass(slots=True)\n\tclass PollAnswer:\n\t    poll_id: str\n\t    user: User\n\t    option_ids: List[int]\n\t@dataclass(slots=True)\n\tclass Poll:\n", "    id: str\n\t    question: str\n\t    options: List[PollOption]\n\t    total_voter_count: int\n\t    is_closed: bool\n\t    is_anonymous: bool\n\t    type: str\n\t    allows_multiple_answers: bool\n\t    correct_option_id: Optional[int] = None\n\t    explanation: Optional[str] = None\n", "    explanation_entities: Optional[List[MessageEntity]] = None\n\t    open_period: Optional[int] = None\n\t    close_date: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass Location:\n\t    longitude: float\n\t    latitude: float\n\t    horizontal_accuracy: Optional[float] = None\n\t    live_period: Optional[int] = None\n\t    heading: Optional[int] = None\n", "    proximity_alert_radius: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass Venue:\n\t    location: Location\n\t    title: str\n\t    address: str\n\t    foursquare_id: Optional[str] = None\n\t    foursquare_type: Optional[str] = None\n\t    google_place_id: Optional[str] = None\n\t    google_place_type: Optional[str] = None\n", "@dataclass(slots=True)\n\tclass WebAppData:\n\t    data: str\n\t    button_text: str\n\t@dataclass(slots=True)\n\tclass ProximityAlertTriggered:\n\t    traveler: User\n\t    watcher: User\n\t    distance: int\n\t@dataclass(slots=True)\n", "class MessageAutoDeleteTimerChanged:\n\t    message_auto_delete_time: int\n\t@dataclass(slots=True)\n\tclass ForumTopicCreated:\n\t    name: str\n\t    icon_color: int\n\t    icon_custom_emoji_id: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass ForumTopicClosed:\n\t    pass\n", "@dataclass(slots=True)\n\tclass ForumTopicEdited:\n\t    name: Optional[str] = None\n\t    icon_custom_emoji_id: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass ForumTopicReopened:\n\t    pass\n\t@dataclass(slots=True)\n\tclass GeneralForumTopicHidden:\n\t    pass\n", "@dataclass(slots=True)\n\tclass GeneralForumTopicUnhidden:\n\t    pass\n\t@dataclass(slots=True)\n\tclass UserShared:\n\t    request_id: int\n\t    user_id: int\n\t@dataclass(slots=True)\n\tclass ChatShared:\n\t    request_id: int\n", "    chat_id: int\n\t@dataclass(slots=True)\n\tclass WriteAccessAllowed:\n\t    web_app_name: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass VideoChatScheduled:\n\t    start_date: int\n\t@dataclass(slots=True)\n\tclass VideoChatStarted:\n\t    pass\n", "@dataclass(slots=True)\n\tclass VideoChatEnded:\n\t    duration: int\n\t@dataclass(slots=True)\n\tclass VideoChatParticipantsInvited:\n\t    users: List[User]\n\t@dataclass(slots=True)\n\tclass UserProfilePhotos:\n\t    total_count: int\n\t    photos: List[List[PhotoSize]]\n", "@dataclass(slots=True)\n\tclass File:\n\t    file_id: str\n\t    file_unique_id: str\n\t    file_size: Optional[int] = None\n\t    file_path: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass WebAppInfo:\n\t    url: str\n\t@dataclass(slots=True)\n", "class ReplyKeyboardMarkup:\n\t    keyboard: List[List[KeyboardButton]]\n\t    is_persistent: Optional[bool] = None\n\t    resize_keyboard: Optional[bool] = None\n\t    one_time_keyboard: Optional[bool] = None\n\t    input_field_placeholder: Optional[str] = None\n\t    selective: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass KeyboardButton:\n\t    text: str\n", "    request_user: Optional[KeyboardButtonRequestUser] = None\n\t    request_chat: Optional[KeyboardButtonRequestChat] = None\n\t    request_contact: Optional[bool] = None\n\t    request_location: Optional[bool] = None\n\t    request_poll: Optional[KeyboardButtonPollType] = None\n\t    web_app: Optional[WebAppInfo] = None\n\t@dataclass(slots=True)\n\tclass KeyboardButtonRequestUser:\n\t    request_id: int\n\t    user_is_bot: Optional[bool] = None\n", "    user_is_premium: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass KeyboardButtonRequestChat:\n\t    request_id: int\n\t    chat_is_channel: bool\n\t    chat_is_forum: Optional[bool] = None\n\t    chat_has_username: Optional[bool] = None\n\t    chat_is_created: Optional[bool] = None\n\t    user_administrator_rights: Optional[ChatAdministratorRights] = None\n\t    bot_administrator_rights: Optional[ChatAdministratorRights] = None\n", "    bot_is_member: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass KeyboardButtonPollType:\n\t    type: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass ReplyKeyboardRemove:\n\t    remove_keyboard: bool\n\t    selective: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass InlineKeyboardMarkup:\n", "    inline_keyboard: List[List[InlineKeyboardButton]]\n\t@dataclass(slots=True)\n\tclass InlineKeyboardButton:\n\t    text: str\n\t    url: Optional[str] = None\n\t    callback_data: Optional[str] = None\n\t    web_app: Optional[WebAppInfo] = None\n\t    login_url: Optional[LoginUrl] = None\n\t    switch_inline_query: Optional[str] = None\n\t    switch_inline_query_current_chat: Optional[str] = None\n", "    switch_inline_query_chosen_chat: Optional[\n\t        SwitchInlineQueryChosenChat\n\t    ] = None\n\t    callback_game: Optional[CallbackGame] = None\n\t    pay: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass LoginUrl:\n\t    url: str\n\t    forward_text: Optional[str] = None\n\t    bot_username: Optional[str] = None\n", "    request_write_access: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass SwitchInlineQueryChosenChat:\n\t    query: Optional[str] = None\n\t    allow_user_chats: Optional[bool] = None\n\t    allow_bot_chats: Optional[bool] = None\n\t    allow_group_chats: Optional[bool] = None\n\t    allow_channel_chats: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass CallbackQuery:\n", "    id: str\n\t    from_: User\n\t    chat_instance: str\n\t    message: Optional[Message] = None\n\t    inline_message_id: Optional[str] = None\n\t    data: Optional[str] = None\n\t    game_short_name: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass ForceReply:\n\t    force_reply: bool\n", "    input_field_placeholder: Optional[str] = None\n\t    selective: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass ChatPhoto:\n\t    small_file_id: str\n\t    small_file_unique_id: str\n\t    big_file_id: str\n\t    big_file_unique_id: str\n\t@dataclass(slots=True)\n\tclass ChatInviteLink:\n", "    invite_link: str\n\t    creator: User\n\t    creates_join_request: bool\n\t    is_primary: bool\n\t    is_revoked: bool\n\t    name: Optional[str] = None\n\t    expire_date: Optional[int] = None\n\t    member_limit: Optional[int] = None\n\t    pending_join_request_count: Optional[int] = None\n\t@dataclass(slots=True)\n", "class ChatAdministratorRights:\n\t    is_anonymous: bool\n\t    can_manage_chat: bool\n\t    can_delete_messages: bool\n\t    can_manage_video_chats: bool\n\t    can_restrict_members: bool\n\t    can_promote_members: bool\n\t    can_change_info: bool\n\t    can_invite_users: bool\n\t    can_post_messages: Optional[bool] = None\n", "    can_edit_messages: Optional[bool] = None\n\t    can_pin_messages: Optional[bool] = None\n\t    can_manage_topics: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass ChatMember:\n\t    pass\n\t@dataclass(slots=True)\n\tclass ChatMemberOwner:\n\t    status: str\n\t    user: User\n", "    is_anonymous: bool\n\t    custom_title: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass ChatMemberAdministrator:\n\t    status: str\n\t    user: User\n\t    can_be_edited: bool\n\t    is_anonymous: bool\n\t    can_manage_chat: bool\n\t    can_delete_messages: bool\n", "    can_manage_video_chats: bool\n\t    can_restrict_members: bool\n\t    can_promote_members: bool\n\t    can_change_info: bool\n\t    can_invite_users: bool\n\t    can_post_messages: Optional[bool] = None\n\t    can_edit_messages: Optional[bool] = None\n\t    can_pin_messages: Optional[bool] = None\n\t    can_manage_topics: Optional[bool] = None\n\t    custom_title: Optional[str] = None\n", "@dataclass(slots=True)\n\tclass ChatMemberMember:\n\t    status: str\n\t    user: User\n\t@dataclass(slots=True)\n\tclass ChatMemberRestricted:\n\t    status: str\n\t    user: User\n\t    is_member: bool\n\t    can_send_messages: bool\n", "    can_send_audios: bool\n\t    can_send_documents: bool\n\t    can_send_photos: bool\n\t    can_send_videos: bool\n\t    can_send_video_notes: bool\n\t    can_send_voice_notes: bool\n\t    can_send_polls: bool\n\t    can_send_other_messages: bool\n\t    can_add_web_page_previews: bool\n\t    can_change_info: bool\n", "    can_invite_users: bool\n\t    can_pin_messages: bool\n\t    can_manage_topics: bool\n\t    until_date: int\n\t@dataclass(slots=True)\n\tclass ChatMemberLeft:\n\t    status: str\n\t    user: User\n\t@dataclass(slots=True)\n\tclass ChatMemberBanned:\n", "    status: str\n\t    user: User\n\t    until_date: int\n\t@dataclass(slots=True)\n\tclass ChatMemberUpdated:\n\t    chat: Chat\n\t    from_: User\n\t    date: int\n\t    old_chat_member: ChatMember\n\t    new_chat_member: ChatMember\n", "    invite_link: Optional[ChatInviteLink] = None\n\t    via_chat_folder_invite_link: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass ChatJoinRequest:\n\t    chat: Chat\n\t    from_: User\n\t    user_chat_id: int\n\t    date: int\n\t    bio: Optional[str] = None\n\t    invite_link: Optional[ChatInviteLink] = None\n", "@dataclass(slots=True)\n\tclass ChatPermissions:\n\t    can_send_messages: Optional[bool] = None\n\t    can_send_audios: Optional[bool] = None\n\t    can_send_documents: Optional[bool] = None\n\t    can_send_photos: Optional[bool] = None\n\t    can_send_videos: Optional[bool] = None\n\t    can_send_video_notes: Optional[bool] = None\n\t    can_send_voice_notes: Optional[bool] = None\n\t    can_send_polls: Optional[bool] = None\n", "    can_send_other_messages: Optional[bool] = None\n\t    can_add_web_page_previews: Optional[bool] = None\n\t    can_change_info: Optional[bool] = None\n\t    can_invite_users: Optional[bool] = None\n\t    can_pin_messages: Optional[bool] = None\n\t    can_manage_topics: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass ChatLocation:\n\t    location: Location\n\t    address: str\n", "@dataclass(slots=True)\n\tclass ForumTopic:\n\t    message_thread_id: int\n\t    name: str\n\t    icon_color: int\n\t    icon_custom_emoji_id: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass BotCommand:\n\t    command: str\n\t    description: str\n", "@dataclass(slots=True)\n\tclass BotCommandScope:\n\t    pass\n\t@dataclass(slots=True)\n\tclass BotCommandScopeDefault:\n\t    type: str\n\t@dataclass(slots=True)\n\tclass BotCommandScopeAllPrivateChats:\n\t    type: str\n\t@dataclass(slots=True)\n", "class BotCommandScopeAllGroupChats:\n\t    type: str\n\t@dataclass(slots=True)\n\tclass BotCommandScopeAllChatAdministrators:\n\t    type: str\n\t@dataclass(slots=True)\n\tclass BotCommandScopeChat:\n\t    type: str\n\t    chat_id: int | str\n\t@dataclass(slots=True)\n", "class BotCommandScopeChatAdministrators:\n\t    type: str\n\t    chat_id: int | str\n\t@dataclass(slots=True)\n\tclass BotCommandScopeChatMember:\n\t    type: str\n\t    chat_id: int | str\n\t    user_id: int\n\t@dataclass(slots=True)\n\tclass BotName:\n", "    name: str\n\t@dataclass(slots=True)\n\tclass BotDescription:\n\t    description: str\n\t@dataclass(slots=True)\n\tclass BotShortDescription:\n\t    short_description: str\n\t@dataclass(slots=True)\n\tclass MenuButton:\n\t    pass\n", "@dataclass(slots=True)\n\tclass MenuButtonCommands:\n\t    type: str\n\t@dataclass(slots=True)\n\tclass MenuButtonWebApp:\n\t    type: str\n\t    text: str\n\t    web_app: WebAppInfo\n\t@dataclass(slots=True)\n\tclass MenuButtonDefault:\n", "    type: str\n\t@dataclass(slots=True)\n\tclass ResponseParameters:\n\t    migrate_to_chat_id: Optional[int] = None\n\t    retry_after: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass InputMedia:\n\t    pass\n\t@dataclass(slots=True)\n\tclass InputMediaPhoto:\n", "    type: str\n\t    media: str\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    has_spoiler: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass InputMediaVideo:\n\t    type: str\n\t    media: str\n", "    thumbnail: Optional[InputFile | str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    width: Optional[int] = None\n\t    height: Optional[int] = None\n\t    duration: Optional[int] = None\n\t    supports_streaming: Optional[bool] = None\n\t    has_spoiler: Optional[bool] = None\n\t@dataclass(slots=True)\n", "class InputMediaAnimation:\n\t    type: str\n\t    media: str\n\t    thumbnail: Optional[InputFile | str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    width: Optional[int] = None\n\t    height: Optional[int] = None\n\t    duration: Optional[int] = None\n", "    has_spoiler: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass InputMediaAudio:\n\t    type: str\n\t    media: str\n\t    thumbnail: Optional[InputFile | str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    duration: Optional[int] = None\n", "    performer: Optional[str] = None\n\t    title: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass InputMediaDocument:\n\t    type: str\n\t    media: str\n\t    thumbnail: Optional[InputFile | str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n", "    disable_content_type_detection: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass InputFile:\n\t    pass\n\t@dataclass(slots=True)\n\tclass Sticker:\n\t    file_id: str\n\t    file_unique_id: str\n\t    type: str\n\t    width: int\n", "    height: int\n\t    is_animated: bool\n\t    is_video: bool\n\t    thumbnail: Optional[PhotoSize] = None\n\t    emoji: Optional[str] = None\n\t    set_name: Optional[str] = None\n\t    premium_animation: Optional[File] = None\n\t    mask_position: Optional[MaskPosition] = None\n\t    custom_emoji_id: Optional[str] = None\n\t    needs_repainting: Optional[bool] = None\n", "    file_size: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass StickerSet:\n\t    name: str\n\t    title: str\n\t    sticker_type: str\n\t    is_animated: bool\n\t    is_video: bool\n\t    stickers: List[Sticker]\n\t    thumbnail: Optional[PhotoSize] = None\n", "@dataclass(slots=True)\n\tclass MaskPosition:\n\t    point: str\n\t    x_shift: float\n\t    y_shift: float\n\t    scale: float\n\t@dataclass(slots=True)\n\tclass InputSticker:\n\t    sticker: InputFile | str\n\t    emoji_list: List[str]\n", "    mask_position: Optional[MaskPosition] = None\n\t    keywords: Optional[List[str]] = None\n\t@dataclass(slots=True)\n\tclass InlineQuery:\n\t    id: str\n\t    from_: User\n\t    query: str\n\t    offset: str\n\t    chat_type: Optional[str] = None\n\t    location: Optional[Location] = None\n", "@dataclass(slots=True)\n\tclass InlineQueryResultsButton:\n\t    text: str\n\t    web_app: Optional[WebAppInfo] = None\n\t    start_parameter: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResult:\n\t    pass\n\t@dataclass(slots=True)\n\tclass InlineQueryResultArticle:\n", "    type: str\n\t    id: str\n\t    title: str\n\t    input_message_content: InputMessageContent\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    url: Optional[str] = None\n\t    hide_url: Optional[bool] = None\n\t    description: Optional[str] = None\n\t    thumbnail_url: Optional[str] = None\n\t    thumbnail_width: Optional[int] = None\n", "    thumbnail_height: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultPhoto:\n\t    type: str\n\t    id: str\n\t    photo_url: str\n\t    thumbnail_url: str\n\t    photo_width: Optional[int] = None\n\t    photo_height: Optional[int] = None\n\t    title: Optional[str] = None\n", "    description: Optional[str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultGif:\n\t    type: str\n\t    id: str\n", "    gif_url: str\n\t    thumbnail_url: str\n\t    gif_width: Optional[int] = None\n\t    gif_height: Optional[int] = None\n\t    gif_duration: Optional[int] = None\n\t    thumbnail_mime_type: Optional[str] = None\n\t    title: Optional[str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n", "    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultMpeg4Gif:\n\t    type: str\n\t    id: str\n\t    mpeg4_url: str\n\t    thumbnail_url: str\n\t    mpeg4_width: Optional[int] = None\n\t    mpeg4_height: Optional[int] = None\n", "    mpeg4_duration: Optional[int] = None\n\t    thumbnail_mime_type: Optional[str] = None\n\t    title: Optional[str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultVideo:\n", "    type: str\n\t    id: str\n\t    video_url: str\n\t    mime_type: str\n\t    thumbnail_url: str\n\t    title: str\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    video_width: Optional[int] = None\n", "    video_height: Optional[int] = None\n\t    video_duration: Optional[int] = None\n\t    description: Optional[str] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultAudio:\n\t    type: str\n\t    id: str\n\t    audio_url: str\n", "    title: str\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    performer: Optional[str] = None\n\t    audio_duration: Optional[int] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultVoice:\n", "    type: str\n\t    id: str\n\t    voice_url: str\n\t    title: str\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    voice_duration: Optional[int] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n", "@dataclass(slots=True)\n\tclass InlineQueryResultDocument:\n\t    type: str\n\t    id: str\n\t    title: str\n\t    document_url: str\n\t    mime_type: str\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n", "    description: Optional[str] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t    thumbnail_url: Optional[str] = None\n\t    thumbnail_width: Optional[int] = None\n\t    thumbnail_height: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultLocation:\n\t    type: str\n\t    id: str\n", "    latitude: float\n\t    longitude: float\n\t    title: str\n\t    horizontal_accuracy: Optional[float] = None\n\t    live_period: Optional[int] = None\n\t    heading: Optional[int] = None\n\t    proximity_alert_radius: Optional[int] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t    thumbnail_url: Optional[str] = None\n", "    thumbnail_width: Optional[int] = None\n\t    thumbnail_height: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultVenue:\n\t    type: str\n\t    id: str\n\t    latitude: float\n\t    longitude: float\n\t    title: str\n\t    address: str\n", "    foursquare_id: Optional[str] = None\n\t    foursquare_type: Optional[str] = None\n\t    google_place_id: Optional[str] = None\n\t    google_place_type: Optional[str] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t    thumbnail_url: Optional[str] = None\n\t    thumbnail_width: Optional[int] = None\n\t    thumbnail_height: Optional[int] = None\n\t@dataclass(slots=True)\n", "class InlineQueryResultContact:\n\t    type: str\n\t    id: str\n\t    phone_number: str\n\t    first_name: str\n\t    last_name: Optional[str] = None\n\t    vcard: Optional[str] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t    thumbnail_url: Optional[str] = None\n", "    thumbnail_width: Optional[int] = None\n\t    thumbnail_height: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultGame:\n\t    type: str\n\t    id: str\n\t    game_short_name: str\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultCachedPhoto:\n", "    type: str\n\t    id: str\n\t    photo_file_id: str\n\t    title: Optional[str] = None\n\t    description: Optional[str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n", "@dataclass(slots=True)\n\tclass InlineQueryResultCachedGif:\n\t    type: str\n\t    id: str\n\t    gif_file_id: str\n\t    title: Optional[str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n", "    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultCachedMpeg4Gif:\n\t    type: str\n\t    id: str\n\t    mpeg4_file_id: str\n\t    title: Optional[str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n", "    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultCachedSticker:\n\t    type: str\n\t    id: str\n\t    sticker_file_id: str\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n", "class InlineQueryResultCachedDocument:\n\t    type: str\n\t    id: str\n\t    title: str\n\t    document_file_id: str\n\t    description: Optional[str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n", "    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultCachedVideo:\n\t    type: str\n\t    id: str\n\t    video_file_id: str\n\t    title: str\n\t    description: Optional[str] = None\n\t    caption: Optional[str] = None\n\t    parse_mode: Optional[str] = None\n", "    caption_entities: Optional[List[MessageEntity]] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultCachedVoice:\n\t    type: str\n\t    id: str\n\t    voice_file_id: str\n\t    title: str\n\t    caption: Optional[str] = None\n", "    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InlineQueryResultCachedAudio:\n\t    type: str\n\t    id: str\n\t    audio_file_id: str\n\t    caption: Optional[str] = None\n", "    parse_mode: Optional[str] = None\n\t    caption_entities: Optional[List[MessageEntity]] = None\n\t    reply_markup: Optional[InlineKeyboardMarkup] = None\n\t    input_message_content: Optional[InputMessageContent] = None\n\t@dataclass(slots=True)\n\tclass InputMessageContent:\n\t    pass\n\t@dataclass(slots=True)\n\tclass InputTextMessageContent:\n\t    message_text: str\n", "    parse_mode: Optional[str] = None\n\t    entities: Optional[List[MessageEntity]] = None\n\t    disable_web_page_preview: Optional[bool] = None\n\t@dataclass(slots=True)\n\tclass InputLocationMessageContent:\n\t    latitude: float\n\t    longitude: float\n\t    horizontal_accuracy: Optional[float] = None\n\t    live_period: Optional[int] = None\n\t    heading: Optional[int] = None\n", "    proximity_alert_radius: Optional[int] = None\n\t@dataclass(slots=True)\n\tclass InputVenueMessageContent:\n\t    latitude: float\n\t    longitude: float\n\t    title: str\n\t    address: str\n\t    foursquare_id: Optional[str] = None\n\t    foursquare_type: Optional[str] = None\n\t    google_place_id: Optional[str] = None\n", "    google_place_type: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass InputContactMessageContent:\n\t    phone_number: str\n\t    first_name: str\n\t    last_name: Optional[str] = None\n\t    vcard: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass InputInvoiceMessageContent:\n\t    title: str\n", "    description: str\n\t    payload: str\n\t    provider_token: str\n\t    currency: str\n\t    prices: List[LabeledPrice]\n\t    max_tip_amount: Optional[int] = None\n\t    suggested_tip_amounts: Optional[List[int]] = None\n\t    provider_data: Optional[str] = None\n\t    photo_url: Optional[str] = None\n\t    photo_size: Optional[int] = None\n", "    photo_width: Optional[int] = None\n\t    photo_height: Optional[int] = None\n\t    need_name: Optional[bool] = None\n\t    need_phone_number: Optional[bool] = None\n\t    need_email: Optional[bool] = None\n\t    need_shipping_address: Optional[bool] = None\n\t    send_phone_number_to_provider: Optional[bool] = None\n\t    send_email_to_provider: Optional[bool] = None\n\t    is_flexible: Optional[bool] = None\n\t@dataclass(slots=True)\n", "class ChosenInlineResult:\n\t    result_id: str\n\t    from_: User\n\t    query: str\n\t    location: Optional[Location] = None\n\t    inline_message_id: Optional[str] = None\n\t@dataclass(slots=True)\n\tclass SentWebAppMessage:\n\t    inline_message_id: Optional[str] = None\n\t@dataclass(slots=True)\n", "class LabeledPrice:\n\t    label: str\n\t    amount: int\n\t@dataclass(slots=True)\n\tclass Invoice:\n\t    title: str\n\t    description: str\n\t    start_parameter: str\n\t    currency: str\n\t    total_amount: int\n", "@dataclass(slots=True)\n\tclass ShippingAddress:\n\t    country_code: str\n\t    state: str\n\t    city: str\n\t    street_line1: str\n\t    street_line2: str\n\t    post_code: str\n\t@dataclass(slots=True)\n\tclass OrderInfo:\n", "    name: Optional[str] = None\n\t    phone_number: Optional[str] = None\n\t    email: Optional[str] = None\n\t    shipping_address: Optional[ShippingAddress] = None\n\t@dataclass(slots=True)\n\tclass ShippingOption:\n\t    id: str\n\t    title: str\n\t    prices: List[LabeledPrice]\n\t@dataclass(slots=True)\n", "class SuccessfulPayment:\n\t    currency: str\n\t    total_amount: int\n\t    invoice_payload: str\n\t    telegram_payment_charge_id: str\n\t    provider_payment_charge_id: str\n\t    shipping_option_id: Optional[str] = None\n\t    order_info: Optional[OrderInfo] = None\n\t@dataclass(slots=True)\n\tclass ShippingQuery:\n", "    id: str\n\t    from_: User\n\t    invoice_payload: str\n\t    shipping_address: ShippingAddress\n\t@dataclass(slots=True)\n\tclass PreCheckoutQuery:\n\t    id: str\n\t    from_: User\n\t    currency: str\n\t    total_amount: int\n", "    invoice_payload: str\n\t    shipping_option_id: Optional[str] = None\n\t    order_info: Optional[OrderInfo] = None\n\t@dataclass(slots=True)\n\tclass PassportData:\n\t    data: List[EncryptedPassportElement]\n\t    credentials: EncryptedCredentials\n\t@dataclass(slots=True)\n\tclass PassportFile:\n\t    file_id: str\n", "    file_unique_id: str\n\t    file_size: int\n\t    file_date: int\n\t@dataclass(slots=True)\n\tclass EncryptedPassportElement:\n\t    type: str\n\t    hash: str\n\t    data: Optional[str] = None\n\t    phone_number: Optional[str] = None\n\t    email: Optional[str] = None\n", "    files: Optional[List[PassportFile]] = None\n\t    front_side: Optional[PassportFile] = None\n\t    reverse_side: Optional[PassportFile] = None\n\t    selfie: Optional[PassportFile] = None\n\t    translation: Optional[List[PassportFile]] = None\n\t@dataclass(slots=True)\n\tclass EncryptedCredentials:\n\t    data: str\n\t    hash: str\n\t    secret: str\n", "@dataclass(slots=True)\n\tclass PassportElementError:\n\t    pass\n\t@dataclass(slots=True)\n\tclass PassportElementErrorDataField:\n\t    source: str\n\t    type: str\n\t    field_name: str\n\t    data_hash: str\n\t    message: str\n", "@dataclass(slots=True)\n\tclass PassportElementErrorFrontSide:\n\t    source: str\n\t    type: str\n\t    file_hash: str\n\t    message: str\n\t@dataclass(slots=True)\n\tclass PassportElementErrorReverseSide:\n\t    source: str\n\t    type: str\n", "    file_hash: str\n\t    message: str\n\t@dataclass(slots=True)\n\tclass PassportElementErrorSelfie:\n\t    source: str\n\t    type: str\n\t    file_hash: str\n\t    message: str\n\t@dataclass(slots=True)\n\tclass PassportElementErrorFile:\n", "    source: str\n\t    type: str\n\t    file_hash: str\n\t    message: str\n\t@dataclass(slots=True)\n\tclass PassportElementErrorFiles:\n\t    source: str\n\t    type: str\n\t    file_hashes: List[str]\n\t    message: str\n", "@dataclass(slots=True)\n\tclass PassportElementErrorTranslationFile:\n\t    source: str\n\t    type: str\n\t    file_hash: str\n\t    message: str\n\t@dataclass(slots=True)\n\tclass PassportElementErrorTranslationFiles:\n\t    source: str\n\t    type: str\n", "    file_hashes: List[str]\n\t    message: str\n\t@dataclass(slots=True)\n\tclass PassportElementErrorUnspecified:\n\t    source: str\n\t    type: str\n\t    element_hash: str\n\t    message: str\n\t@dataclass(slots=True)\n\tclass Game:\n", "    title: str\n\t    description: str\n\t    photo: List[PhotoSize]\n\t    text: Optional[str] = None\n\t    text_entities: Optional[List[MessageEntity]] = None\n\t    animation: Optional[Animation] = None\n\t@dataclass(slots=True)\n\tclass CallbackGame:\n\t    pass\n\t@dataclass(slots=True)\n", "class GameHighScore:\n\t    position: int\n\t    user: User\n\t    score: int\n"]}
{"filename": "slonogram/__init__.py", "chunked_list": ["from .bot import Bot\n\tfrom .dispatching.dispatcher import Dispatcher\n\tfrom .dispatching.local_set import LocalSet\n\t__all__ = [\"Bot\", \"Dispatcher\", \"LocalSet\"]\n"]}
{"filename": "slonogram/extra/__init__.py", "chunked_list": []}
{"filename": "slonogram/extra/aiohttp_session.py", "chunked_list": ["from typing import Any, Dict, AnyStr\n\ttry:\n\t    from aiohttp import ClientSession\n\texcept ImportError as ie:\n\t    raise ImportError(\n\t        \"failed to import `aiohttp`, install slonogram[aiohttp] \"\n\t        \"to use aiohttp client\"\n\t    ) from ie\n\tfrom ..types.api_session import ApiSession, MethodArgs\n\tfrom ..utils.json import loads\n", "class Session(ApiSession):\n\t    def __init__(self, token: str, base_url: str) -> None:\n\t        self._token = token\n\t        self._session = ClientSession(base_url=base_url)\n\t    async def call_method(\n\t        self, method: str, args: MethodArgs\n\t    ) -> Dict[AnyStr, Any]:\n\t        async with self._session.post(\n\t            f\"/bot{self._token}/{method}\", data=args\n\t        ) as response:\n", "            raw = await response.read()\n\t            return loads(raw)\n\t    async def finalize(self) -> None:\n\t        await self._session.close()\n\t__all__ = [\"Session\"]\n"]}
{"filename": "slonogram/extra/scratches.py", "chunked_list": ["from typing import Optional\n\tfrom ..types.scratch import attr_scratch, Scratch\n\tfrom ..schemas import Message\n\tText: Scratch[Message, Optional[str]] = attr_scratch(\"text\")\n\t__all__ = [\"Text\"]\n"]}
{"filename": "slonogram/extra/di.py", "chunked_list": ["from functools import partial\n\tfrom inspect import Parameter\n\tfrom typing import (\n\t    Any,\n\t    Dict,\n\t    Mapping,\n\t    TypeVar,\n\t    Generic,\n\t    Tuple,\n\t    Callable,\n", "    TypeAlias,\n\t    List,\n\t    get_origin,\n\t)\n\tfrom slonodi.container import Container\n\tfrom slonodi.specifiers import DeferredEvaluation\n\tfrom slonodi.injector import Provider, Injector\n\tfrom ..bot import Bot\n\tfrom ..types.model_types import MODEL_TYPES\n\tfrom ..types.scratch import Scratch\n", "from ..types.context import Context\n\tT = TypeVar(\"T\")\n\tR = TypeVar(\"R\")\n\t_EMPTY_DICT: dict = {}\n\tdef create_injector() -> Injector:\n\t    return Injector(\n\t        SlonodiProvider(),\n\t        default_specifiers=(DefaultSpecifier(),),\n\t    )\n\tNameItem: TypeAlias = Tuple[str, Callable[[Context[T]], Any]]\n", "def _bot(context: Context[Any]) -> Bot:\n\t    return context.inter.bot\n\tdef _identity(v: T) -> T:\n\t    return v\n\tdef _model(context: Context[T]) -> T:\n\t    return context.model\n\tclass DefaultSpecifier:\n\t    def _deferred(\n\t        self,\n\t        names: Tuple[NameItem[Any], ...],\n", "        context: Context[Any],\n\t    ) -> Dict[str, Any]:\n\t        return {name: getter(context) for name, getter in names}\n\t    def write_dependencies(\n\t        self, params: Mapping[str, Parameter], _: Container\n\t    ) -> Dict[str, Any] | Tuple[Dict[str, Any], DeferredEvaluation]:\n\t        names: List[NameItem[Any]] = []\n\t        for name, param in params.items():\n\t            annot = param.annotation\n\t            origin = get_origin(annot)\n", "            if annot is Bot:\n\t                names.append((name, _bot))\n\t            elif origin is Context:\n\t                names.append((name, _identity))\n\t            elif annot in MODEL_TYPES:\n\t                names.append((name, _model))\n\t        return (_EMPTY_DICT, partial(self._deferred, tuple(names)))\n\tclass SlonodiProvider(Provider[Context[Any]]):\n\t    def provide_ctx(self, data: Any) -> Context[Any]:\n\t        return data\n", "    def provide_container(self, ctx: Context[Any]) -> Container:\n\t        return ctx.inter.data\n\tclass FromScratchSpecifier(Generic[T, R]):\n\t    __slots__ = (\"scratch\", \"name\")\n\t    def __init__(self, name: str, scratch: Scratch[T, R]) -> None:\n\t        self.scratch = scratch\n\t        self.name = name\n\t    def _deferred(self, context: Context[T]) -> Dict[str, Any]:\n\t        return {self.name: context.pad[self.scratch]}\n\t    def write_dependencies(\n", "        self, _: Mapping[str, Parameter], __: Container\n\t    ) -> Dict[str, Any] | Tuple[Dict[str, Any], DeferredEvaluation]:\n\t        return (_EMPTY_DICT, self._deferred)\n\tdef from_scratch(\n\t    name: str, scratch: Scratch[T, R]\n\t) -> FromScratchSpecifier[T, R]:\n\t    return FromScratchSpecifier(name, scratch)\n"]}
{"filename": "slonogram/utils/__init__.py", "chunked_list": []}
{"filename": "slonogram/utils/dict.py", "chunked_list": []}
{"filename": "slonogram/utils/json.py", "chunked_list": ["from typing import Callable, Any\n\tloads: Callable[[bytes], Any]\n\ttry:\n\t    import orjson\n\t    loads = orjson.loads\n\t    def dumps(d: Any) -> str:\n\t        return orjson.dumps(d).decode()\n\texcept ImportError:\n\t    from json import loads, dumps  # type: ignore\n\t__all__ = [\"loads\", \"dumps\"]\n"]}
{"filename": "slonogram/exceptions/control_flow.py", "chunked_list": ["class _ShowIsABug(Exception):\n\t    def __init__(self) -> None:\n\t        super().__init__(\n\t            \"This exception should never be shown, \"\n\t            \"this is a bug in `slonogram`\"\n\t        )\n\tclass SkipLocalSet(_ShowIsABug):\n\t    \"\"\"\n\t    Skips current `LocalSet`\n\t    \"\"\"\n", "class DontHandle(_ShowIsABug):\n\t    \"\"\"\n\t    Skips current update\n\t    \"\"\"\n\t__all__ = [\"SkipLocalSet\"]\n"]}
{"filename": "slonogram/exceptions/__init__.py", "chunked_list": []}
{"filename": "slonogram/exceptions/api_error.py", "chunked_list": ["class ApiError(Exception):\n\t    def __init__(self, code: int, description: str) -> None:\n\t        self.code = code\n\t        self.description = description\n\t        super().__init__(f\"{description} (code = {code})\")\n"]}
{"filename": "slonogram/filtering/__init__.py", "chunked_list": []}
{"filename": "slonogram/filtering/text/word.py", "chunked_list": ["from typing import Iterable\n\tfrom slonogram.types.filter import ExtendedFilter\n\tfrom slonogram.types.context import Context\n\tfrom slonogram.extra.scratches import Text\n\tfrom slonogram.schemas import Message\n\timport re\n\tclass Word(ExtendedFilter[Message]):\n\t    __slots__ = \"pattern\", \"ignore_case\"\n\t    def __init__(\n\t        self,\n", "        variants: Iterable[str],\n\t        regex: bool = False,\n\t        ignore_case: bool = True,\n\t    ) -> None:\n\t        if isinstance(variants, str):\n\t            variants = (variants,)\n\t        if ignore_case:\n\t            variants = map(str.casefold, variants)\n\t        if not regex:\n\t            variants = map(re.escape, variants)\n", "        self.pattern = re.compile(\n\t            \"(\" + \"|\".join(variants) + \")\",\n\t            re.IGNORECASE if ignore_case else 0,\n\t        )\n\t        self.ignore_case = ignore_case\n\t    def __repr__(self) -> str:\n\t        i = \"i\" if self.ignore_case else \"\"\n\t        return f\"Word({i}/{self.pattern.pattern}/)\"\n\t    async def __call__(self, ctx: Context[Message]) -> bool:\n\t        text = ctx.pad[Text]\n", "        if not text:\n\t            return False\n\t        space_pos = text.find(\" \")\n\t        if space_pos == -1:\n\t            found_word = text\n\t        else:\n\t            found_word = text[:space_pos]\n\t        if match := self.pattern.fullmatch(found_word):\n\t            ctx.pad[Text] = text[match.end() :].lstrip()  # type: ignore\n\t            return True\n", "        return False\n"]}
{"filename": "slonogram/filtering/text/__init__.py", "chunked_list": ["from .prefix import Prefix\n\tfrom .word import Word\n\tfrom .command import Command\n\t__all__ = [\"Prefix\", \"Word\", \"Command\"]\n"]}
{"filename": "slonogram/filtering/text/prefix.py", "chunked_list": ["from slonogram.types.filter import ExtendedFilter\n\tfrom slonogram.types.context import Context\n\tfrom slonogram.schemas import Message\n\tfrom slonogram.extra.scratches import Text\n\timport re\n\tclass Prefix(ExtendedFilter[Message]):\n\t    __slots__ = \"ignore_case\", \"pattern\"\n\t    def __init__(self, pattern: str, ignore_case: bool = True) -> None:\n\t        self.pattern = re.compile(\n\t            pattern, re.IGNORECASE if ignore_case else 0\n", "        )\n\t        self.ignore_case = ignore_case\n\t    async def __call__(self, ctx: Context[Message]) -> bool:\n\t        text = ctx.pad[Text]\n\t        if text is None:\n\t            return False\n\t        match = self.pattern.match(text)\n\t        if match is None:\n\t            return False\n\t        end = match.end(0)\n", "        ctx.pad[Text] = text[end:]  # type: ignore\n\t        return True\n"]}
{"filename": "slonogram/filtering/text/command.py", "chunked_list": ["import re\n\tfrom typing import Iterable, Callable, TypeAlias, Optional\n\tfrom slonogram.types.filter import ExtendedFilter\n\tfrom slonogram.types.context import Context\n\tfrom slonogram.extra.scratches import Text\n\tfrom slonogram.schemas import Message, User\n\tUsernamePredicate: TypeAlias = Callable[[User, str], bool]\n\tdef same_username(user: User, given: str) -> bool:\n\t    return user.username == given\n\tclass Command(ExtendedFilter[Message]):\n", "    __slots__ = \"variants\", \"ignore_case\", \"pattern\", \"username_predicate\"\n\t    def __init__(\n\t        self,\n\t        variants: Iterable[str],\n\t        ignore_case: bool = True,\n\t        username_predicate: Optional[UsernamePredicate] = None,\n\t    ) -> None:\n\t        if isinstance(variants, str):\n\t            variants = (variants,)\n\t        if ignore_case:\n", "            variants = map(str.casefold, variants)\n\t        self.variants = tuple(variants)\n\t        self.ignore_case = ignore_case\n\t        self.pattern = re.compile(\n\t            r\"\\/([\\w\\d_\\-]+)(@([\\w\\d_]+))?\",\n\t            re.IGNORECASE if ignore_case else 0,\n\t        )\n\t        self.username_predicate = username_predicate or same_username\n\t    def __repr__(self) -> str:\n\t        return f\"Command({self.variants!r})\"\n", "    async def __call__(self, ctx: Context[Message]) -> bool:\n\t        text = ctx.pad[Text]\n\t        if text is None:\n\t            return False\n\t        command_match = self.pattern.match(text)\n\t        if command_match is None:\n\t            return False\n\t        command = command_match.group(1)\n\t        if self.ignore_case:\n\t            command = command.casefold()\n", "        if command not in self.variants:\n\t            return False\n\t        username = command_match.group(3)\n\t        if username is not None and not self.username_predicate(\n\t            ctx.inter.me, username\n\t        ):\n\t            return False\n\t        ctx.pad[Text] = text[command_match.end(0) :].lstrip()  # type: ignore\n\t        return True\n\t__all__ = [\"same_username\", \"Command\"]\n"]}
{"filename": "slonogram/handling/__init__.py", "chunked_list": []}
{"filename": "slonogram/handling/handler.py", "chunked_list": ["from __future__ import annotations\n\tfrom ..types.context import Context\n\tfrom ..types.filter import FilterFn\n\tfrom ..types.middleware import MiddlewareFn\n\tfrom ..types.handler_fn import HandlerFn, AnyHandlerFn, into_handler_fn\n\tfrom typing import Generic, TypeVar, Optional\n\tT = TypeVar(\"T\")\n\tclass Handler(Generic[T]):\n\t    def __init__(\n\t        self,\n", "        fn: AnyHandlerFn[T],\n\t        observer: bool,\n\t        filter_: Optional[FilterFn[T]],\n\t        middleware: Optional[MiddlewareFn[T]],\n\t    ) -> None:\n\t        self.filter_ = filter_\n\t        self.middleware = middleware\n\t        self._fn_name = getattr(fn, \"__name__\", repr(fn))\n\t        self.observer = observer\n\t        self.fn: HandlerFn[T] = into_handler_fn(fn)\n", "    def __repr__(self) -> str:\n\t        obs_flag = \":observer\" if self.observer else \"\"\n\t        return f\"<Handler{obs_flag} name={self._fn_name!r}>\"\n\t    async def try_invoke(self, ctx: Context[T]) -> bool:\n\t        filter_ = self.filter_\n\t        prev_pad = ctx.pad\n\t        ctx.pad = prev_pad.create_child()\n\t        try:\n\t            if filter_ is not None:\n\t                if not await filter_(ctx):\n", "                    return False\n\t            mw = self.middleware\n\t            if mw is not None:\n\t                await mw(ctx)\n\t            await self.fn(ctx)\n\t        finally:\n\t            ctx.pad = prev_pad\n\t        return not self.observer\n\t__all__ = [\n\t    \"Handler\",\n", "]\n"]}
{"filename": "slonogram/types/scratch_pad.py", "chunked_list": ["from __future__ import annotations\n\tfrom copy import copy\n\tfrom typing import Generic, TypeVar, Dict, Any, Optional\n\tfrom .scratch import Scratch\n\tT = TypeVar(\"T\")\n\tR = TypeVar(\"R\")\n\tclass ScratchPad(Generic[T]):\n\t    __slots__ = (\"_scratches\", \"_model\", \"_parent\")\n\t    def __init__(\n\t        self, model: T, parent: Optional[ScratchPad[T]] = None\n", "    ) -> None:\n\t        self._scratches: Dict[Scratch[T, Any], Any] = {}\n\t        self._model = model\n\t        self._parent = parent\n\t    def copy(self) -> ScratchPad[T]:\n\t        \"\"\"\n\t        Returns new `ScratchPad` with exact same parameters, but\n\t        scratches dict is copied, so scratches modification will not\n\t        affect original `ScratchPad`\n\t        \"\"\"\n", "        pad = ScratchPad(self._model, self._parent)\n\t        pad._scratches = copy(self._scratches)\n\t        return pad\n\t    def __repr__(self) -> str:\n\t        return (\n\t            f\"<ScratchPad scratches={self._scratches!r} \"\n\t            f\"parent={self._parent!r}>\"\n\t        )\n\t    def __setitem__(self, scratch: Scratch[T, R], value: R) -> None:\n\t        self._scratches[scratch] = value\n", "    def __getitem__(self, scratch: Scratch[T, R]) -> R:\n\t        try:\n\t            return self._scratches[scratch]\n\t        except KeyError:\n\t            parent = self._parent\n\t            if parent is None:\n\t                return scratch(self._model)\n\t            return parent[scratch]\n\t    def create_child(self) -> ScratchPad[T]:\n\t        return ScratchPad(self._model, self)\n", "    def clear(self) -> None:\n\t        self._scratches.clear()\n"]}
{"filename": "slonogram/types/event_flags.py", "chunked_list": ["from enum import IntFlag, auto\n\tfrom typing import TypeAlias\n\tclass MessageFlags(IntFlag):\n\t    SENT = auto()\n\t    EDITED = auto()\n\tEventFlags: TypeAlias = MessageFlags\n"]}
{"filename": "slonogram/types/scratch.py", "chunked_list": ["from typing import TypeVar, TypeAlias, Callable\n\tT = TypeVar(\"T\")\n\tR = TypeVar(\"R\")\n\tScratch: TypeAlias = Callable[[T], R]\n\tdef attr_scratch(attr: str) -> Scratch[T, R]:\n\t    class Impl:\n\t        def __repr__(self) -> str:\n\t            return f\"<Scratch:attr attr={attr!r}>\"\n\t        def __call__(self, model: T) -> R:\n\t            return getattr(model, attr)\n", "    return Impl()\n"]}
{"filename": "slonogram/types/context.py", "chunked_list": ["from __future__ import annotations\n\tfrom anyio.abc import TaskGroup\n\tfrom typing import TypeVar, Generic, Any\n\tfrom .event_flags import EventFlags\n\tfrom .scratch_pad import ScratchPad\n\tfrom ..schemas import User\n\tfrom ..bot import Bot\n\tT = TypeVar(\"T\")\n\tR = TypeVar(\"R\")\n\tclass InterContextData:\n", "    __slots__ = \"data\", \"bot\", \"me\", \"task_group\"\n\t    def __init__(\n\t        self, me: User, data: Any, bot: Bot, task_group: TaskGroup\n\t    ) -> None:\n\t        self.data = data\n\t        self.bot = bot\n\t        self.me = me\n\t        self.task_group = task_group\n\tclass Context(Generic[T]):\n\t    __slots__ = \"pad\", \"inter\", \"flags\"\n", "    def __init__(\n\t        self, inter: InterContextData, flags: EventFlags, model: T\n\t    ) -> None:\n\t        self.flags = flags\n\t        self.inter = inter\n\t        self.pad = ScratchPad[T](model)\n\t    @property\n\t    def model(self) -> T:\n\t        return self.pad._model\n\t    @model.setter\n", "    def model(self, value: T) -> None:\n\t        self.pad._model = value\n"]}
{"filename": "slonogram/types/filter.py", "chunked_list": ["from __future__ import annotations\n\tfrom abc import ABCMeta, abstractmethod\n\tfrom typing import Callable, TypeAlias, Awaitable, TypeVar, Generic\n\tfrom .context import Context\n\tT = TypeVar(\"T\")\n\tFilterFn: TypeAlias = Callable[[Context[T]], Awaitable[bool]]\n\tclass AlwaysConst:\n\t    def __init__(self, const: bool) -> None:\n\t        self.const = const\n\t    def __repr__(self) -> str:\n", "        return f\"const({self.const})\"\n\t    async def __call__(self, _: Context[T]) -> bool:\n\t        return self.const\n\talways_true = AlwaysConst(True)\n\talways_false = AlwaysConst(False)\n\tclass ExtendedFilter(Generic[T], metaclass=ABCMeta):\n\t    def __invert__(self) -> Inverted[T]:\n\t        return Inverted(self)\n\t    def __or__(self, rhs: FilterFn[T]) -> Or[T]:\n\t        return Or(self, rhs, False)\n", "    def __xor__(self, rhs: FilterFn[T]) -> Or[T]:\n\t        return Or(self, rhs, True)\n\t    def __and__(self, rhs: FilterFn[T]) -> And[T]:\n\t        return And(self, rhs)\n\t    @abstractmethod\n\t    def __call__(self, ctx: Context[T]) -> Awaitable[bool]:\n\t        _ = ctx\n\t        raise NotImplementedError\n\tclass If(ExtendedFilter[T]):\n\t    __slots__ = \"condition\", \"on_then\", \"on_else\"\n", "    def __init__(\n\t        self,\n\t        condition: FilterFn[T],\n\t        on_then: FilterFn[T] = always_true,\n\t        on_else: FilterFn[T] = always_false,\n\t        restore_scratches: bool = True,\n\t    ) -> None:\n\t        self.condition = condition\n\t        self.on_then = on_then\n\t        self.on_else = on_else\n", "        self.restore_scratches = restore_scratches\n\t    def then(self, new_then: FilterFn[T]) -> If[T]:\n\t        return If(self.condition, new_then, self.on_else)\n\t    def else_(self, new_else: FilterFn[T]) -> If[T]:\n\t        return If(self.condition, self.on_then, new_else)\n\t    def __repr__(self) -> str:\n\t        restore_flag = \"\" if self.restore_scratches else \"!r\"\n\t        return (\n\t            f\"(if{restore_flag} {self.condition} then\"\n\t            f\" {self.on_then} else {self.on_else})\"\n", "        )\n\t    async def __call__(self, ctx: Context[T]) -> bool:\n\t        if self.restore_scratches:\n\t            _copy = ctx.pad.copy()\n\t        cond = await self.condition(ctx)\n\t        if cond:\n\t            return await self.on_then(ctx)\n\t        elif self.restore_scratches:\n\t            ctx.pad = _copy\n\t        return await self.on_else(ctx)\n", "class Predicate(ExtendedFilter[T]):\n\t    __slots__ = (\"fn\",)\n\t    def __init__(self, fn: FilterFn[T]) -> None:\n\t        self.fn = fn\n\t    def __call__(self, ctx: Context[T]) -> Awaitable[bool]:\n\t        return self.fn(ctx)\n\tclass Or(ExtendedFilter[T]):\n\t    __slots__ = \"lhs_fn\", \"rhs_fn\", \"exclusive\"\n\t    def __init__(\n\t        self, lhs: FilterFn[T], rhs: FilterFn[T], exclusive: bool\n", "    ) -> None:\n\t        self.lhs_fn = lhs\n\t        self.rhs_fn = rhs\n\t        self.exclusive = exclusive\n\t    @property\n\t    def symbol(self) -> str:\n\t        return \"^\" if self.exclusive else \"|\"\n\t    def __repr__(self) -> str:\n\t        return f\"{self.lhs_fn} {self.symbol} {self.rhs_fn}\"\n\t    async def __call__(self, ctx: Context[T]) -> bool:\n", "        if self.exclusive:\n\t            lhs = await self.lhs_fn(ctx)\n\t            rhs = await self.rhs_fn(ctx)\n\t            return bool(lhs ^ rhs)\n\t        else:\n\t            lhs = await self.lhs_fn(ctx)\n\t            if not lhs:\n\t                return await self.rhs_fn(ctx)\n\t            return lhs\n\tclass And(ExtendedFilter[T]):\n", "    __slots__ = \"lhs_fn\", \"rhs_fn\"\n\t    def __init__(self, lhs: FilterFn[T], rhs: FilterFn[T]) -> None:\n\t        self.lhs_fn = lhs\n\t        self.rhs_fn = rhs\n\t    def __repr__(self) -> str:\n\t        return f\"{self.lhs_fn} & {self.rhs_fn}\"\n\t    async def __call__(self, ctx: Context[T]) -> bool:\n\t        lhs = await self.lhs_fn(ctx)\n\t        if not lhs:\n\t            return False\n", "        return await self.rhs_fn(ctx)\n\tclass Inverted(ExtendedFilter[T]):\n\t    __slots__ = (\"fn\",)\n\t    def __init__(self, fn: FilterFn[T]) -> None:\n\t        self.fn = fn\n\t    def __repr__(self) -> str:\n\t        return f\"~{self.fn}\"\n\t    async def __call__(self, ctx: Context[T]) -> bool:\n\t        result = await self.fn(ctx)\n\t        return not result\n", "def not_(fn: FilterFn[T]) -> Inverted[T]:\n\t    return Inverted(fn)\n\t__all__ = [\n\t    \"FilterFn\",\n\t    \"ExtendedFilter\",\n\t    \"Inverted\",\n\t    \"And\",\n\t    \"Or\",\n\t    \"Predicate\",\n\t    \"If\",\n", "]\n"]}
{"filename": "slonogram/types/handler_fn.py", "chunked_list": ["from typing import (\n\t    Awaitable,\n\t    Protocol,\n\t    TypeAlias,\n\t    Generic,\n\t    TypeVar,\n\t    Callable,\n\t    cast,\n\t    get_origin,\n\t)\n", "from inspect import signature\n\tfrom .context import Context\n\tfrom ..bot import Bot\n\tT = TypeVar(\"T\")\n\tR = TypeVar(\"R\")\n\t_Single: TypeAlias = Callable[[T], Awaitable[None]]\n\t_Two: TypeAlias = Callable[[T, R], Awaitable[None]]\n\tAnyHandlerFn: TypeAlias = (\n\t    _Single[Bot]\n\t    | _Single[T]\n", "    | _Single[Context[T]]\n\t    | _Two[Bot, T]\n\t    | _Two[T, Bot]\n\t)\n\tclass HandlerFn(Protocol, Generic[T]):\n\t    def __call__(self, context: Context[T], /) -> Awaitable[None]:\n\t        ...\n\tclass _WrappedFn(Generic[T]):\n\t    __slots__ = \"fn\", \"__name__\", \"__call__\"\n\t    def __init__(self, anyfn: AnyHandlerFn[T], call_method: str) -> None:\n", "        self.fn = anyfn\n\t        self.__call__ = getattr(self, call_method)\n\t        self.__name__ = getattr(anyfn, \"__name__\", \"<unnamed>\")\n\t    def only_bot(self, ctx: Context[T]) -> Awaitable[None]:\n\t        return self.fn(ctx.inter.bot)  # type: ignore\n\t    def only_model(self, ctx: Context[T]) -> Awaitable[None]:\n\t        return self.fn(ctx.model)  # type: ignore\n\t    def bot_model(self, ctx: Context[T]) -> Awaitable[None]:\n\t        return self.fn(ctx.inter.bot, ctx.model)  # type: ignore\n\t    def model_bot(self, ctx: Context[T]) -> Awaitable[None]:\n", "        return self.fn(ctx.model, ctx.inter.bot)  # type: ignore\n\tdef into_handler_fn(anyfn: AnyHandlerFn[T]) -> HandlerFn[T]:\n\t    if getattr(anyfn, \"__cast_ctxed__\", False):\n\t        return cast(HandlerFn[T], anyfn)\n\t    sig = signature(anyfn)\n\t    params = sig.parameters\n\t    leading_pos = len(params)\n\t    if leading_pos == 1:\n\t        first = next(iter(params.values()))\n\t        annot = first.annotation\n", "        if annot is Bot:\n\t            return _WrappedFn(anyfn, \"only_bot\")\n\t        else:\n\t            return cast(HandlerFn[T], anyfn)\n\t    elif leading_pos == 2:\n\t        it = iter(params.values())\n\t        first = next(it)\n\t        second = next(it)\n\t        f_annot = first.annotation\n\t        s_annot = second.annotation\n", "        f_ty = get_origin(f_annot) or f_annot\n\t        s_ty = get_origin(s_annot) or s_annot\n\t        tps = (f_ty, s_ty)\n\t        if tps[0] is Bot:\n\t            return _WrappedFn(anyfn, \"bot_model\")\n\t        elif tps[1] is Bot:\n\t            return _WrappedFn(anyfn, \"model_bot\")\n\t        else:\n\t            raise TypeError(\"Unknown `AnyHandlerFn[T]` signature pattern\")\n\t    raise TypeError(\n", "        \"`AnyHandlerFn[T]` should take exactly 2 or 1 arguments\"\n\t    )\n\t__all__ = [\"AnyHandlerFn\", \"HandlerFn\", \"into_handler_fn\"]\n"]}
{"filename": "slonogram/types/__init__.py", "chunked_list": []}
{"filename": "slonogram/types/api_session.py", "chunked_list": ["from __future__ import annotations\n\tfrom abc import ABCMeta, abstractmethod\n\tfrom typing import Dict, AnyStr, TypeAlias, Any\n\tScalarSerializable: TypeAlias = AnyStr | float | int | bool\n\tMethodArgs: TypeAlias = Dict[AnyStr, ScalarSerializable]\n\tclass ApiSession(metaclass=ABCMeta):\n\t    @abstractmethod\n\t    async def call_method(\n\t        self, method: str, args: MethodArgs\n\t    ) -> Dict[AnyStr, Any]:\n", "        raise NotImplementedError\n\t    @abstractmethod\n\t    async def finalize(self) -> None:\n\t        pass\n\t__all__ = [\"ScalarSerializable\", \"MethodArgs\", \"ApiSession\"]\n"]}
{"filename": "slonogram/types/middleware.py", "chunked_list": ["from __future__ import annotations\n\tfrom .context import Context\n\tfrom typing import TypeVar, TypeAlias, Callable, Awaitable, List, Generic\n\tfrom functools import partial\n\tT = TypeVar(\"T\")\n\tMiddlewareFn: TypeAlias = Callable[[Context[T]], Awaitable[None]]\n\tAnyMiddlewareFn: TypeAlias = Callable[\n\t    [MiddlewareFn[T], Context[T]], Awaitable[None]\n\t]\n\tclass Chain(Generic[T]):\n", "    def __init__(self, *middlewares: AnyMiddlewareFn[T]) -> None:\n\t        tail: MiddlewareFn[T] = do_nothing\n\t        path: List[str] = []\n\t        for middleware in reversed(middlewares):\n\t            tail = partial(middleware, tail)\n\t            path.append(middleware.__name__)\n\t        self._fn = tail\n\t        self._path = path\n\t    def __call__(self, context: Context[T]) -> Awaitable[None]:\n\t        return self._fn(context)\n", "    def __matmul__(self, rhs: MiddlewareFn[T]) -> Group[T]:\n\t        return Group(self, rhs)\n\t    def __repr__(self) -> str:\n\t        return \" <| \".join(self._path)\n\tclass Group(Generic[T]):\n\t    def __init__(self, *chains: MiddlewareFn[T]) -> None:\n\t        self._chains = chains\n\t    async def __call__(self, context: Context[T]) -> None:\n\t        for chain in self._chains:\n\t            await chain(context)\n", "    def __matmul__(self, rhs: MiddlewareFn[T]) -> Group[T]:\n\t        return Group(*self._chains, rhs)\n\t    def __repr__(self) -> str:\n\t        wrapped = map(lambda chain: f\"({chain!r})\", self._chains)\n\t        return \" -> \".join(wrapped)\n\tasync def do_nothing(_: Context[T]) -> None:\n\t    pass\n"]}
{"filename": "slonogram/types/model_types.py", "chunked_list": ["from ..schemas import Message\n\tMODEL_TYPES = (Message,)\n"]}
{"filename": "slonogram/dispatching/_registrants.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import (\n\t    TYPE_CHECKING,\n\t    Optional,\n\t    TypeVar,\n\t    TypeAlias,\n\t    Callable,\n\t)\n\tfrom ..types.filter import FilterFn\n\tfrom ..types.middleware import MiddlewareFn\n", "from ..types.event_flags import MessageFlags\n\tfrom ..types.handler_fn import AnyHandlerFn\n\tfrom ..handling.handler import Handler\n\tfrom ..schemas import Message\n\tif TYPE_CHECKING:\n\t    from .local_set import LocalSet\n\tT = TypeVar(\"T\")\n\tMsgHandler: TypeAlias = Handler[Message]\n\t_OptFilterFn: TypeAlias = Optional[FilterFn[T]]\n\t_OptMid: TypeAlias = Optional[MiddlewareFn[T]]\n", "_RegRetDeco: TypeAlias = Callable[[AnyHandlerFn[T]], Handler[T]]\n\tclass OnMessage:\n\t    def __init__(self, set_: LocalSet) -> None:\n\t        self._set = set_\n\t    def _register(\n\t        self,\n\t        observer: bool,\n\t        subtypes: MessageFlags,\n\t        filter_: _OptFilterFn[Message],\n\t        middleware: _OptMid[Message],\n", "    ) -> _RegRetDeco[Message]:\n\t        def inner(fn: AnyHandlerFn) -> MsgHandler:\n\t            handler = MsgHandler(fn, observer, filter_, middleware)\n\t            if MessageFlags.SENT in subtypes:\n\t                self._set._sent_message_handlers.append(handler)\n\t            if MessageFlags.EDITED in subtypes:\n\t                self._set._edited_message_handlers.append(handler)\n\t            return handler\n\t        return inner\n\t    def __call__(\n", "        self,\n\t        subtypes: MessageFlags,\n\t        filter_: _OptFilterFn[Message] = None,\n\t        observer: bool = False,\n\t        middleware: _OptMid[Message] = None,\n\t    ) -> _RegRetDeco[Message]:\n\t        return self._register(observer, subtypes, filter_, middleware)\n\t    def sent(\n\t        self,\n\t        filter_: _OptFilterFn[Message] = None,\n", "        observer: bool = False,\n\t        middleware: _OptMid[Message] = None,\n\t    ) -> _RegRetDeco[Message]:\n\t        return self._register(\n\t            observer, MessageFlags.SENT, filter_, middleware\n\t        )\n\t    def edited(\n\t        self,\n\t        filter_: _OptFilterFn[Message] = None,\n\t        observer: bool = False,\n", "        middleware: _OptMid[Message] = None,\n\t    ) -> _RegRetDeco[Message]:\n\t        return self._register(\n\t            observer, MessageFlags.EDITED, filter_, middleware\n\t        )\n"]}
{"filename": "slonogram/dispatching/dispatcher.py", "chunked_list": ["from typing import (\n\t    TypeVar,\n\t    List,\n\t    NoReturn,\n\t    Optional,\n\t    TypeAlias,\n\t)\n\tfrom anyio import create_task_group\n\tfrom ..types.event_flags import MessageFlags\n\tfrom ..types.context import InterContextData, Context\n", "from ..exceptions.control_flow import DontHandle, SkipLocalSet\n\tfrom ..handling.handler import Handler\n\tfrom ..schemas import Message, UpdateType, Update\n\tfrom ..bot import Bot\n\tfrom .local_set import LocalSet\n\tT = TypeVar(\"T\")\n\tMsgCtx: TypeAlias = Context[Message]\n\tclass Dispatcher:\n\t    \"\"\"\n\t    ### skip_pending:\n", "    skips updates sent before the current time\n\t    (time is retrieved through the `time.time`)\n\t    \"\"\"\n\t    def __init__(self, bot: Bot, skip_pending: bool = False) -> None:\n\t        self.set: LocalSet = LocalSet(\"__dispatcher__\")\n\t        self.skip_pending = skip_pending\n\t        self._bot = bot\n\t        self.data = None\n\t    async def _handle_set(\n\t        self, attr: str, set_: LocalSet, ctx: Context[T]\n", "    ) -> bool:\n\t        filter_ = set_.filter_\n\t        parent_pad = ctx.pad\n\t        ctx.pad = parent_pad.create_child()\n\t        try:\n\t            if filter_ is not None and not await filter_(ctx):\n\t                return False\n\t            mw = set_._middleware\n\t            if mw is not None:\n\t                await mw(ctx)\n", "            h_list: List[Handler[T]] = getattr(set_, attr)\n\t            for handler in h_list:\n\t                if await handler.try_invoke(ctx):\n\t                    return True\n\t            for child in set_._children:\n\t                if await self._handle_set(attr, child, ctx):\n\t                    return True\n\t        except SkipLocalSet:\n\t            return False\n\t        finally:\n", "            ctx.pad = parent_pad\n\t        return False\n\t    async def feed_update(\n\t        self, inter: InterContextData, update: Update\n\t    ) -> bool:\n\t        try:\n\t            if update.message is not None:\n\t                return await self._handle_set(\n\t                    \"_sent_message_handlers\",\n\t                    self.set,\n", "                    Context(inter, MessageFlags.SENT, update.message),\n\t                )\n\t            elif update.edited_message is not None:\n\t                return await self._handle_set(\n\t                    \"_edited_message_handlers\",\n\t                    self.set,\n\t                    Context(\n\t                        inter, MessageFlags.EDITED, update.edited_message\n\t                    ),\n\t                )\n", "            elif update.callback_query is not None:\n\t                raise NotImplementedError\n\t            elif update.inline_query is not None:\n\t                raise NotImplementedError\n\t            elif update.channel_post is not None:\n\t                raise NotImplementedError\n\t            elif update.chat_join_request is not None:\n\t                raise NotImplementedError\n\t            elif update.chat_member is not None:\n\t                raise NotImplementedError\n", "            elif update.chosen_inline_result is not None:\n\t                raise NotImplementedError\n\t            elif update.edited_channel_post is not None:\n\t                raise NotImplementedError\n\t            elif update.my_chat_member is not None:\n\t                raise NotImplementedError\n\t            elif update.poll is not None:\n\t                raise NotImplementedError\n\t            elif update.poll_answer is not None:\n\t                raise NotImplementedError\n", "            elif update.pre_checkout_query is not None:\n\t                raise NotImplementedError\n\t            elif update.shipping_query is not None:\n\t                raise NotImplementedError\n\t        except DontHandle:\n\t            pass\n\t        return False\n\t    async def create_intercontext_data(self) -> InterContextData:\n\t        me = await self._bot.user.get_me()\n\t        return InterContextData(\n", "            me, self.data, self._bot, create_task_group()\n\t        )\n\t    async def run_polling(\n\t        self,\n\t        offset: Optional[int] = None,\n\t        limit: Optional[int] = None,\n\t        timeout: Optional[int] = None,\n\t        allowed_updates: Optional[List[UpdateType]] = None,\n\t    ) -> NoReturn:\n\t        inter = await self.create_intercontext_data()\n", "        get_updates = self._bot.updates.get\n\t        feed = self.feed_update\n\t        async with inter.task_group as tg:\n\t            while True:\n\t                updates = await get_updates(\n\t                    offset, limit, timeout, allowed_updates\n\t                )\n\t                if updates:\n\t                    offset = updates[-1].id + 1\n\t                for update in updates:\n", "                    tg.start_soon(feed, inter, update)  # type: ignore\n"]}
{"filename": "slonogram/dispatching/__init__.py", "chunked_list": ["from .dispatcher import Dispatcher\n\tfrom .local_set import LocalSet\n\t__all__ = [\"Dispatcher\", \"LocalSet\"]\n"]}
{"filename": "slonogram/dispatching/local_set.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import (\n\t    Optional,\n\t    List,\n\t    TypeVar,\n\t    Any,\n\t)\n\tfrom ..types.middleware import MiddlewareFn\n\tfrom ..types.filter import FilterFn\n\tfrom ._registrants import OnMessage, MsgHandler\n", "T = TypeVar(\"T\")\n\tclass LocalSet:\n\t    def __init__(\n\t        self,\n\t        name: Optional[str] = None,\n\t        filter_: Optional[FilterFn[Any]] = None,\n\t        middleware: Optional[MiddlewareFn[Any]] = None,\n\t    ) -> None:\n\t        self.name = name\n\t        self._children: List[LocalSet] = []\n", "        self.filter_ = filter_\n\t        self._sent_message_handlers: List[MsgHandler] = []\n\t        self._edited_message_handlers: List[MsgHandler] = []\n\t        self._middleware = middleware\n\t    def include(self, *sets: LocalSet) -> None:\n\t        self._children.extend(sets)\n\t    @property\n\t    def on_message(self) -> OnMessage:\n\t        return OnMessage(self)\n"]}
{"filename": "slonogram/call_groups/updates.py", "chunked_list": ["from typing import Optional, List, Awaitable\n\tfrom ..schemas import UpdateType, Update\n\tfrom .group import CallsGroup, UseRetort\n\tclass UpdatesCallGroup(CallsGroup):\n\t    def get(\n\t        self,\n\t        offset: Optional[int] = None,\n\t        limit: Optional[int] = None,\n\t        timeout: Optional[int] = None,\n\t        allowed_updates: Optional[List[UpdateType]] = None,\n", "    ) -> Awaitable[List[Update]]:\n\t        return self._call(\n\t            List[Update],\n\t            \"getUpdates\",\n\t            {},\n\t            (\n\t                (\"offset\", offset),\n\t                (\"limit\", limit),\n\t                (\"timeout\", timeout),\n\t                UseRetort(\"allowed_updates\", allowed_updates),\n", "            ),\n\t        )\n"]}
{"filename": "slonogram/call_groups/__init__.py", "chunked_list": []}
{"filename": "slonogram/call_groups/group.py", "chunked_list": ["from adaptix import Retort\n\tfrom typing import TypeVar, Type, Iterable, Tuple, Any, Generic, Optional\n\tfrom ..utils.json import dumps\n\tfrom ..types.api_session import (\n\t    ApiSession,\n\t    MethodArgs,\n\t    ScalarSerializable,\n\t)\n\tfrom ..exceptions.api_error import ApiError\n\tT = TypeVar(\"T\")\n", "class UseRetort(Generic[T]):\n\t    __slots__ = \"name\", \"value\"\n\t    def __init__(self, name: str, value: Optional[T]) -> None:\n\t        self.name = name\n\t        self.value = value\n\tclass CallsGroup:\n\t    def __init__(self, retort: Retort, session: ApiSession) -> None:\n\t        self._session = session\n\t        self._retort = retort\n\t    async def _call(\n", "        self,\n\t        ty: Type[T],\n\t        method: str,\n\t        args: MethodArgs,\n\t        optional_args: Iterable[\n\t            Tuple[str, Optional[ScalarSerializable]] | UseRetort[Any]\n\t        ] = [],\n\t    ) -> T:\n\t        retort = self._retort\n\t        for arg in optional_args:\n", "            if isinstance(arg, UseRetort):\n\t                i_value = arg.value\n\t                if i_value is None:\n\t                    continue\n\t                name = arg.name\n\t                value = dumps(retort.dump(i_value))\n\t                args[name] = value\n\t            else:\n\t                key, value = arg  # type: ignore\n\t                if value is not None:\n", "                    args[key] = value\n\t        result = await self._session.call_method(method, args)\n\t        if not result[\"ok\"]:\n\t            raise ApiError(\n\t                result[\"error_code\"],\n\t                result[\"description\"],\n\t            )\n\t        # TODO: Do we need ability to \"delay\" model loading?\n\t        # for example, when result is not used\n\t        return self._retort.load(result[\"result\"], ty)\n"]}
{"filename": "slonogram/call_groups/user.py", "chunked_list": ["from typing import Awaitable\n\tfrom .group import CallsGroup\n\tfrom ..schemas import User\n\tclass UserCallGroup(CallsGroup):\n\t    def get_me(self) -> Awaitable[User]:\n\t        return self._call(User, \"getMe\", {})\n"]}
{"filename": "slonogram/call_groups/chat.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import Optional, Awaitable, List\n\tfrom ..schemas import (\n\t    ParseMode,\n\t    Message,\n\t    MessageEntity,\n\t    InlineKeyboardMarkup,\n\t    ChatAction,\n\t    ReplyKeyboardMarkup,\n\t    ReplyKeyboardRemove,\n", "    ForceReply,\n\t)\n\tfrom .group import CallsGroup, UseRetort\n\tclass ChatCallGroup(CallsGroup):\n\t    def send_action(\n\t        self,\n\t        chat_id: int | str,\n\t        action: ChatAction,\n\t        message_thread_id: Optional[int] = None,\n\t    ) -> Awaitable[bool]:\n", "        return self._call(\n\t            bool,\n\t            \"sendChatAction\",\n\t            {\"chat_id\": chat_id, \"action\": action},\n\t            ((\"message_thread_id\", message_thread_id),),\n\t        )\n\t    def send_message(\n\t        self,\n\t        chat_id: int | str,\n\t        text: Optional[str] = None,\n", "        parse_mode: Optional[ParseMode] = None,\n\t        reply_to: Optional[int] = None,\n\t        entities: Optional[List[MessageEntity]] = None,\n\t        disable_web_page_preview: Optional[bool] = None,\n\t        disable_notification: Optional[bool] = None,\n\t        protect_content: Optional[bool] = None,\n\t        allow_sending_without_reply: Optional[bool] = None,\n\t        reply_markup: Optional[\n\t            InlineKeyboardMarkup\n\t            | ReplyKeyboardMarkup\n", "            | ReplyKeyboardRemove\n\t            | ForceReply\n\t        ] = None,\n\t    ) -> Awaitable[Message]:\n\t        \"\"\"\n\t        Sends a message to chat\n\t        :param chat_id: Chat's ID\n\t        :param text: Text of message\n\t        :param parse_mode: Parse-mode, can be `html` or `markdown`\n\t        :param reply_to: Reply to message? Pass `ID` of message to reply\n", "        :param entities: List of message's entities\n\t        :param disable_web_page_preview: Disable preview?\n\t        :param disable_notification: Disable notification?\n\t        :param protect_content: Protect content?\n\t        :param allow_sending_without_reply: Allow sending without reply?\n\t        :return: Sent message on success\n\t        \"\"\"\n\t        return self._call(\n\t            Message,\n\t            \"sendMessage\",\n", "            {\"chat_id\": chat_id},\n\t            (\n\t                (\"text\", text),\n\t                (\"parse_mode\", parse_mode),\n\t                (\"reply_to_message_id\", reply_to),\n\t                (\"entities\", entities),\n\t                (\"disable_web_page_preview\", disable_web_page_preview),\n\t                (\"disable_notification\", disable_notification),\n\t                (\"protect_content\", protect_content),\n\t                (\n", "                    \"allow_sending_without_reply\",\n\t                    allow_sending_without_reply,\n\t                ),\n\t                UseRetort(\"reply_markup\", reply_markup),\n\t            ),\n\t        )\n\t    def forward_message(\n\t        self,\n\t        chat_id: int | str,\n\t        from_chat_id: int | str,\n", "        message_id: int,\n\t        message_thread_id: Optional[int] = None,\n\t        disable_notification: Optional[bool] = None,\n\t        protect_content: Optional[bool] = None,\n\t    ) -> Awaitable[Message]:\n\t        \"\"\"\n\t        Use this method to forward messages of any kind\n\t        Service messages can't be forwarded.\n\t        On success, the sent `Message` is returned.\n\t        :param chat_id: Chat's ID\n", "        :param from_chat_id: Identifier for the chat where the original\n\t                             message was sent\n\t        :param message_id: Message identifier in the chat specified in\n\t                           `from_chat_id`\n\t        :param message_thread_id: Identifier for the target message thread\n\t                                  (topic) of the forum\n\t        :param disable_notification: Send the message silently?\n\t        :param protect_content: Protects the contents of the forwarded message\n\t                                from forwarding and saving\n\t        \"\"\"\n", "        return self._call(\n\t            Message,\n\t            \"forwardMessage\",\n\t            {\n\t                \"chat_id\": chat_id,\n\t                \"from_chat_id\": from_chat_id,\n\t                \"message_id\": message_id,\n\t            },\n\t            (\n\t                (\"message_thread_id\", message_thread_id),\n", "                (\"disable_notification\", disable_notification),\n\t                (\"protect_content\", protect_content),\n\t            ),\n\t        )\n\t    def edit_message_text(\n\t        self,\n\t        text: str,\n\t        chat_id: Optional[int | str] = None,\n\t        message_id: Optional[int] = None,\n\t        inline_message_id: Optional[str] = None,\n", "        parse_mode: Optional[ParseMode] = None,\n\t        entities: Optional[List[MessageEntity]] = None,\n\t        disable_web_page_preview: Optional[bool] = None,\n\t        reply_markup: Optional[InlineKeyboardMarkup] = None,\n\t    ) -> Awaitable[Message]:\n\t        \"\"\"\n\t        Edits message's text.\n\t        Pass `chat_id` with `message_id` or `inline_message_id`\n\t        :param text: New text for the message\n\t        :param chat_id: Chat's ID\n", "        :param parse_mode: Parse-mode, can be `html` or `markdown`\n\t        :param entities: List of message's entities\n\t        :param disable_web_page_preview: Disable preview?\n\t        :param reply_markup: New reply-markup\n\t        :return: Edited message on success\n\t        \"\"\"\n\t        return self._call(\n\t            Message,\n\t            \"editMessageText\",\n\t            {\"text\": text},\n", "            (\n\t                (\"chat_id\", chat_id),\n\t                (\"message_id\", message_id),\n\t                (\"inline_message_id\", inline_message_id),\n\t                (\"parse_mode\", parse_mode),\n\t                (\"entities\", entities),\n\t                (\"disable_web_page_preview\", disable_web_page_preview),\n\t                (\"reply_markup\", reply_markup),\n\t            ),\n\t        )\n"]}
{"filename": "slonogram/call_groups/queries.py", "chunked_list": ["from .group import CallsGroup\n\tfrom typing import Awaitable, Optional\n\tclass QueriesCallGroup(CallsGroup):\n\t    def answer_callback(\n\t        self,\n\t        query_id: str,\n\t        text: Optional[str] = None,\n\t        show_alert: Optional[bool] = None,\n\t        url: Optional[str] = None,\n\t        cache_time: Optional[int] = None,\n", "    ) -> Awaitable[bool]:\n\t        return self._call(\n\t            bool,\n\t            \"answerCallbackQuery\",\n\t            {\"query_id\": query_id},\n\t            (\n\t                (\"text\", text),\n\t                (\"show_alert\", show_alert),\n\t                (\"url\", url),\n\t                (\"cache_time\", cache_time),\n", "            ),\n\t        )\n"]}
{"filename": "examples/di_example.py", "chunked_list": ["import asyncio\n\tfrom typing import NewType\n\tfrom slonodi import Container\n\tfrom slonodi.specifiers import requires\n\tfrom slonogram.extra.scratches import Text\n\tfrom slonogram.extra.di import (\n\t    from_scratch,\n\t    create_injector,\n\t)\n\tfrom slonogram.bot import Bot\n", "from slonogram.schemas import Message\n\tfrom slonogram.filtering.text import Command\n\tfrom slonogram.dispatching import LocalSet, Dispatcher\n\tMaster = NewType(\"Master\", str)\n\tcontainer = Container()\n\tcontainer[Master] = Master(\"Nero\")\n\tinjector = create_injector()\n\tinject = injector.inject\n\tset_ = LocalSet()\n\t@set_.on_message.sent(Command(\"get_master\"))\n", "@inject(from_scratch(\"text\", Text), requires(\"master\"))\n\tasync def on_get_master(\n\t    bot: Bot, message: Message, text: str, master: Master\n\t) -> None:\n\t    await bot.chat.send_message(\n\t        message.chat.id,\n\t        f\"My master is {master} (scratch text = {text})\",\n\t    )\n\tasync def main() -> None:\n\t    async with Bot(open(\".test_token\").read()) as bot:\n", "        dp = Dispatcher(bot)\n\t        dp.data = container\n\t        dp.set.include(set_)\n\t        await dp.run_polling()\n\tasyncio.run(main())\n"]}
{"filename": "examples/edited_repeater.py", "chunked_list": ["import asyncio\n\tfrom slonogram import Bot\n\tfrom slonogram.schemas import Message\n\tfrom slonogram.dispatching import Dispatcher, LocalSet\n\tfrom slonogram.filtering.text import Command\n\tTOKEN = open(\".test_token\").read()\n\tset_ = LocalSet()\n\t@set_.on_message.sent(Command(\"start\"))\n\tasync def start(bot: Bot, message: Message) -> None:\n\t    await bot.chat.send_message(\n", "        message.chat.id, \"Hello! I'll repeat everything you edit\"\n\t    )\n\t@set_.on_message.edited()\n\tasync def edit_callback(bot: Bot, message: Message) -> None:\n\t    await bot.chat.send_message(\n\t        message.chat.id, f\"Edited: {message.text}\", reply_to=message.id\n\t    )\n\tasync def main() -> None:\n\t    async with Bot(TOKEN) as bot:\n\t        dp = Dispatcher(bot)\n", "        dp.set.include(set_)\n\t        await dp.run_polling()\n\tasyncio.run(main())\n"]}
{"filename": "misc/code_generator/parser.py", "chunked_list": ["from typing import Sequence\n\tfrom keyword import kwlist\n\tTP_MAPPINGS = {\n\t    \"String\": \"str\",\n\t    \"Integer\": \"int\",\n\t    \"Boolean\": \"bool\",\n\t    \"Float\": \"float\",\n\t}\n\tdef escape_hard_keywords(name: str) -> str:\n\t    if name in kwlist:\n", "        return name + \"_\"\n\t    return name\n\tdef parse_multiple_types(telegram_tps: Sequence[str]) -> str:\n\t    match telegram_tps:\n\t        case [tp]:\n\t            return parse_type(tp)\n\t        case anything:\n\t            return \" | \".join(parse_type(tp) for tp in anything)\n\tdef parse_type(telegram_tp: str) -> str:\n\t    tp = telegram_tp.strip()\n", "    if tp in TP_MAPPINGS:\n\t        return TP_MAPPINGS[tp]\n\t    if (wo_prefix := tp.removeprefix(\"Array of \")) != tp:\n\t        inside = parse_type(wo_prefix)\n\t        return f\"List[{inside}]\"\n\t    return tp\n"]}
{"filename": "misc/code_generator/__main__.py", "chunked_list": ["from pathlib import Path\n\tfrom os import mkdir\n\tfrom sys import argv, exit\n\tfrom json import load\n\tfrom .schemas_generator import generate_schemas\n\tfrom .types import CodegenerationConfig, Spec, RETORT\n\ttry:\n\t    config_path = Path(argv[1])\n\t    schemas_path = Path(argv[2])\n\t    call_groups_directory = Path(argv[3])\n", "except IndexError:\n\t    print(\n\t        \"usage: misc.code_generator <config_path>\"\n\t        \" <schemas_outpath> <call_groups_directory>\"\n\t    )\n\t    exit(1)\n\tconfig = CodegenerationConfig.read_from(config_path)\n\tspec_root = Path(__file__).parent.parent / \"telegram-bot-api-spec\"\n\traw_spec = load(open(spec_root / \"api.min.json\"))\n\tspec = RETORT.load(raw_spec, Spec)\n", "if not call_groups_directory.exists():\n\t    print(f\"> mkdir {call_groups_directory}\")\n\t    mkdir(call_groups_directory)\n\tif not (call_groups_directory / \"__init__.py\").exists():\n\t    print(\"> creating __init__.py file in the call groups directory\")\n\t    open(call_groups_directory / \"__init__.py\", \"wb\").close()\n\tschemas = generate_schemas(spec, config)\n\twith open(schemas_path, \"w\") as fp:\n\t    wrote = fp.write(schemas)\n\t    print(f\">>[Schema] Wrote {wrote} bytes to {schemas_path}\")\n"]}
{"filename": "misc/code_generator/types.py", "chunked_list": ["from yaml import safe_load  # type: ignore\n\tfrom adaptix import Retort\n\tfrom pathlib import Path\n\tfrom typing import Dict, NewType, TypeAlias, List\n\tfrom dataclasses import dataclass, field\n\tRETORT = Retort()\n\tAbsolutePath = NewType(\"AbsolutePath\", str)\n\tTy = NewType(\"Ty\", str)\n\tAlias: TypeAlias = str\n\tRenameValue: TypeAlias = str\n", "@dataclass\n\tclass Field:\n\t    name: str\n\t    types: List[str]\n\t    required: bool\n\t    description: str\n\t@dataclass\n\tclass Type:\n\t    name: str\n\t    href: str\n", "    description: List[str]\n\t    fields: List[Field] = field(default_factory=list)\n\t@dataclass\n\tclass Spec:\n\t    types: Dict[str, Type]\n\t@dataclass\n\tclass EnumsConfig:\n\t    types: Dict[Ty, List[Alias] | Dict[Alias, RenameValue]]\n\t    overrides: Dict[AbsolutePath, Ty]\n\t@dataclass\n", "class CodegenerationConfig:\n\t    enums: EnumsConfig\n\t    renames: Dict[AbsolutePath, RenameValue]\n\t    @classmethod\n\t    def read_from(cls, path: Path) -> \"CodegenerationConfig\":\n\t        d = safe_load(open(path, \"r\"))\n\t        return RETORT.load(d, cls)\n"]}
{"filename": "misc/code_generator/schemas_generator.py", "chunked_list": ["from typing import List\n\tfrom .parser import parse_multiple_types, escape_hard_keywords\n\tfrom .types import CodegenerationConfig, Spec, AbsolutePath\n\tfrom .helpers import (\n\t    GenerationHelper,\n\t    Import,\n\t    Class,\n\t    ClassField,\n\t    generate,\n\t    Decorate,\n", ")\n\tdef generate_schemas(spec: Spec, config: CodegenerationConfig) -> str:\n\t    schemas: List[GenerationHelper] = [\n\t        Import(\"__future__\", \"annotations\"),\n\t        Import(\"enum\", \"Enum\"),\n\t        Import(\"dataclasses\", \"dataclass\"),\n\t        Import(\"typing\", (\"List\", \"Optional\")),\n\t    ]\n\t    # Enums generation\n\t    for name, variants in config.enums.types.items():\n", "        fields: List[ClassField] = []\n\t        if isinstance(variants, dict):\n\t            for alias, rename in variants.items():\n\t                fields.append(\n\t                    ClassField(alias.upper(), default=repr(rename))\n\t                )\n\t        else:\n\t            for alias in variants:\n\t                fields.append(\n\t                    ClassField(alias.upper(), default=repr(alias))\n", "                )\n\t        schemas.append(Class(name, [], fields, inherits=(\"str\", \"Enum\")))\n\t    # Telegram types generation\n\t    for ty_name, ty in spec.types.items():\n\t        desc = \" \".join(ty.description)\n\t        desc = f'\"\"\"{desc}\"\"\"'\n\t        tp_fields: List[ClassField] = []\n\t        for field in ty.fields:\n\t            tp = parse_multiple_types(field.types)\n\t            field_name = escape_hard_keywords(field.name)\n", "            absolute_path = AbsolutePath(f\"{ty_name}.{field_name}\")\n\t            if absolute_path in config.renames:\n\t                field_name = config.renames[absolute_path]\n\t            if absolute_path in config.enums.overrides:\n\t                override_tp = config.enums.overrides[absolute_path]\n\t                tp = override_tp\n\t            if field.required:\n\t                tp_fields.append(ClassField(field_name, tp))\n\t            else:\n\t                tp_fields.append(\n", "                    ClassField(\n\t                        escape_hard_keywords(field_name),\n\t                        f\"Optional[{tp}]\",\n\t                        \"None\",\n\t                    )\n\t                )\n\t        class_ = Class(ty_name, [], tp_fields)\n\t        schemas.append(\n\t            Decorate(\n\t                \"dataclass(slots=True)\",\n", "                class_,\n\t            )\n\t        )\n\t    return generate(*schemas)\n"]}
{"filename": "misc/code_generator/__init__.py", "chunked_list": []}
{"filename": "misc/code_generator/helpers.py", "chunked_list": ["from dataclasses import dataclass, field\n\tfrom typing import Sequence, Optional, Protocol, TypeVar\n\tT = TypeVar(\"T\")\n\tclass GenerationHelper(Protocol):\n\t    def generate(self, indent: int, /) -> str:\n\t        raise NotImplementedError\n\t@dataclass\n\tclass SelfArg:\n\t    def generate(self, level: int, /) -> str:\n\t        return f\"{gen_indent(level)}self\"\n", "@dataclass\n\tclass FunctionArgument:\n\t    name: str\n\t    hint: str\n\t    default: Optional[str] = None\n\t    def generate(self, level: int, /) -> str:\n\t        default = f\" = {self.default}\" if self.default is not None else \"\"\n\t        return f\"{gen_indent(level)}{self.name}: {self.hint}{default}\"\n\t@dataclass\n\tclass ClassField:\n", "    name: str\n\t    hint: Optional[str] = None\n\t    default: Optional[str] = None\n\t    def generate(self, level: int, /) -> str:\n\t        base = f\"{gen_indent(level)}{self.name}\"\n\t        if self.hint is not None:\n\t            base += f\": {self.hint}\"\n\t        if self.default is not None:\n\t            return base + f\" = {self.default}\"\n\t        return base\n", "@dataclass\n\tclass Pass:\n\t    def generate(self, level: int, /) -> str:\n\t        return f\"{gen_indent(level)}pass\"\n\t@dataclass\n\tclass Function:\n\t    name: str\n\t    args: Sequence[FunctionArgument | SelfArg]\n\t    body: GenerationHelper\n\t    return_hint: str\n", "    async_: bool = False\n\t    def generate(self, level: int, /) -> str:\n\t        indent = gen_indent(level)\n\t        asyncness = \"async \" if self.async_ else \"\"\n\t        args = \", \".join(arg.generate(0) for arg in self.args)\n\t        lines = [\n\t            f\"{indent}{asyncness}def {self.name}({args}) \"\n\t            f\"-> {self.return_hint}:\",\n\t            self.body.generate(level + 1),\n\t        ]\n", "        return \"\\n\".join(lines)\n\t@dataclass\n\tclass Decorate:\n\t    expr: str\n\t    body: GenerationHelper\n\t    def generate(self, level: int, /) -> str:\n\t        return f\"{gen_indent(level)}@{self.expr}\\n\" + self.body.generate(\n\t            level\n\t        )\n\t@dataclass\n", "class Class:\n\t    name: str\n\t    methods: Sequence[Function]\n\t    fields: Sequence[ClassField] = field(default_factory=list)\n\t    inherits: Optional[Sequence[str]] = None\n\t    def generate(self, level: int, /) -> str:\n\t        body_level = level + 1\n\t        base_ind = gen_indent(level)\n\t        indent = gen_indent(body_level)\n\t        if self.inherits is not None:\n", "            inherits = f\"({', '.join(self.inherits)})\"\n\t        else:\n\t            inherits = \"\"\n\t        out = [f\"{base_ind}class {self.name}{inherits}:\"]\n\t        out.extend(\n\t            f.generate(body_level)\n\t            for f in sorted(\n\t                self.fields, key=lambda f: f.default is not None\n\t            )\n\t        )\n", "        out.extend(m.generate(body_level) for m in self.methods)\n\t        if len(out) == 1:\n\t            out.append(f\"{indent}pass\")\n\t        return \"\\n\".join(out)\n\t@dataclass\n\tclass IndentedLines:\n\t    lines: Sequence[str]\n\t    def generate(self, level: int, /) -> str:\n\t        indent = gen_indent(level)\n\t        return \"\\n\".join(indent + line for line in self.lines)\n", "@dataclass\n\tclass Import:\n\t    package: str\n\t    only: Optional[str | Sequence[str]] = None\n\t    def generate(self, level: int, /) -> str:\n\t        indent = gen_indent(level)\n\t        if self.only is not None:\n\t            if isinstance(self.only, str):\n\t                return f\"{indent}from {self.package} import {self.only}\"\n\t            return (\n", "                f\"{indent}from {self.package} \"\n\t                f\"import ({', '.join(self.only)})\"\n\t            )\n\t        return f\"{indent}import {self.package}\"\n\tdef generate(*helpers: GenerationHelper, use_black: bool = True) -> str:\n\t    result = \"\\n\".join(helper.generate(0) for helper in helpers)\n\t    if use_black:\n\t        import black\n\t        from black.report import NothingChanged\n\t        mode = black.FileMode(line_length=75)\n", "        try:\n\t            result = black.format_file_contents(\n\t                result, fast=True, mode=mode\n\t            )\n\t        except NothingChanged:\n\t            pass\n\t    return result\n\tdef gen_indent(level: int) -> str:\n\t    return \"    \" * level\n"]}
