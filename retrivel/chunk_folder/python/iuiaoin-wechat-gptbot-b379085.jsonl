{"filename": "app.py", "chunked_list": ["from channel.wechat import WeChatChannel\n\tfrom config import load_config\n\tfrom utils.log import logger\n\tfrom utils.print import color_print\n\tfrom plugins.manager import PluginManager\n\tif __name__ == \"__main__\":\n\t    try:\n\t        # load config\n\t        load_config()\n\t        # print banner\n", "        color_print(\"WeChat GPTBot\")\n\t        # load plugins\n\t        PluginManager().load_plugins()\n\t        # start wechat channel\n\t        WeChatChannel().startup()\n\t    except Exception as e:\n\t        logger.error(\"App startup failed!\")\n\t        logger.exception(e)\n"]}
{"filename": "config.py", "chunked_list": ["import json\n\timport os\n\tfrom utils.log import logger\n\tconfig = {}\n\tdef load_config():\n\t    global config\n\t    config_path = \"config.json\"\n\t    if not os.path.exists(config_path):\n\t        raise Exception(\"Config file is not exist, please create config.json according to config.template.json\")\n\t    config_str = read_file(config_path)\n", "    # deserialize json string to dict\n\t    config = json.loads(config_str)\n\t    logger.info(f\"Load config: {config}\")\n\tdef read_file(path):\n\t    with open(path, mode=\"r\", encoding=\"utf-8\") as f:\n\t        return f.read()\n\tdef conf():\n\t    return config\n"]}
{"filename": "plugins/built_in.py", "chunked_list": ["from config import conf\n\tfrom common.singleton import singleton\n\tfrom common.session import Session\n\tfrom common.reply import Reply, ReplyType\n\tfrom plugins.event import Event\n\tfrom utils.query_key import QueryKey\n\t@singleton\n\tclass Cmd:\n\t    def __init__(self, plugins: dict):\n\t        self.config = conf()\n", "        self.plugins = plugins\n\t    def will_generate_reply(self, event: Event):\n\t        query = event.context.query\n\t        session_id = event.context.session_id\n\t        if query == self.config.get(\"clear_current_session_command\", \"#clear session\"):\n\t            Session.clear_session(session_id)\n\t            event.reply = Reply(ReplyType.TEXT, \"The session has been cleared\")\n\t            event.bypass()\n\t        elif query == self.config.get(\n\t            \"clear_all_sessions_command\", \"#clear all sessions\"\n", "        ):\n\t            Session.clear_all_session()\n\t            event.reply = Reply(ReplyType.TEXT, \"All sessions have been cleared\")\n\t            event.bypass()\n\t        elif query == self.config.get(\"query_key_command\", \"#query key\"):\n\t            event.reply = Reply(ReplyType.TEXT, QueryKey.get_key())\n\t            event.bypass()\n\t        elif query.startswith(\"#help \"):\n\t            plugin_name = query.split(\" \")[1]\n\t            reply_text = f\"No plugin named {plugin_name}\"\n", "            for name in self.plugins:\n\t                if name == plugin_name:\n\t                    reply_text = self.plugins[name].help()\n\t                    break\n\t            event.reply = Reply(ReplyType.TEXT, reply_text)\n\t            event.bypass()\n"]}
{"filename": "plugins/manager.py", "chunked_list": ["import json\n\timport re\n\timport os\n\timport importlib\n\tfrom common.singleton import singleton\n\tfrom config import conf\n\tfrom utils.log import logger\n\tfrom typing import Set\n\tfrom dulwich import porcelain\n\tfrom utils.package import install_file\n", "from plugins.plugin import Plugin\n\tfrom common.emitter import Emitter\n\tfrom plugins.event import Event, EventType\n\tfrom plugins.built_in import Cmd\n\t@singleton\n\tclass PluginManager(Emitter):\n\t    def __init__(self):\n\t        super().__init__()\n\t        self._plugins = {}\n\t        self._configs = {}\n", "        self.built_in(self._plugins)\n\t    def register(self, cls: Plugin):\n\t        name = cls.name\n\t        config = self._configs.get(name)\n\t        self._plugins[name] = cls(config)\n\t        return cls\n\t    def load_plugins(self):\n\t        new_plugins = self.check_plugins()\n\t        failed_plugins = self.install_plugins(new_plugins)\n\t        all_plugins = conf().get(\"plugins\") or []\n", "        plugins = [\n\t            plugin for plugin in all_plugins if plugin[\"name\"] not in failed_plugins\n\t        ]\n\t        self.import_plugins(plugins)\n\t        self.activate_plugins(plugins)\n\t    def check_plugins(self) -> Set[str]:\n\t        logger.info(\"Checking plugins...\")\n\t        plugins = conf().get(\"plugins\") or []\n\t        existed_plugins = self.get_existed()\n\t        new_plugins = set()\n", "        for plugin in plugins:\n\t            if plugin[\"name\"] not in existed_plugins:\n\t                new_plugins.add(plugin[\"name\"])\n\t        return new_plugins\n\t    def install_plugins(self, plugins: Set[str]) -> Set[str]:\n\t        failed_plugins = set()\n\t        if len(plugins) == 0:\n\t            logger.info(\"All plugins are installed\")\n\t            return failed_plugins\n\t        else:\n", "            logger.info(f\"Installing plugins: {plugins}\")\n\t            source = dict()\n\t            try:\n\t                with open(\"./plugins/source.json\", \"r\", encoding=\"utf-8\") as f:\n\t                    source = json.load(f)\n\t            except Exception as e:\n\t                logger.error(f\"Invalid plugin source: {e}\")\n\t                return plugins\n\t            for plugin_name in plugins:\n\t                if plugin_name in source:\n", "                    repo = source[plugin_name][\"repo\"]\n\t                    match = re.match(\n\t                        r\"^(https?:\\/\\/|git@)([^\\/:]+)[\\/:]([^\\/:]+)\\/(.+).git$\", repo\n\t                    )\n\t                    if not match:\n\t                        failed_plugins.add(plugin_name)\n\t                        logger.error(f\"Invalid repo: {repo}\")\n\t                    else:\n\t                        try:\n\t                            dirname = os.path.join(\"./plugins\", plugin_name)\n", "                            porcelain.clone(repo, dirname, checkout=True)\n\t                            dependency_path = os.path.join(dirname, \"requirements.txt\")\n\t                            if os.path.exists(dependency_path):\n\t                                logger.info(\n\t                                    f\"Installing dependencies for {plugin_name}\"\n\t                                )\n\t                                install_file(dependency_path)\n\t                            logger.info(f\"Install plugin {plugin_name} successfully\")\n\t                        except Exception as e:\n\t                            failed_plugins.add(plugin_name)\n", "                            logger.error(f\"Fail to install plugin {plugin_name}: {e}\")\n\t                else:\n\t                    failed_plugins.add(plugin_name)\n\t                    logger.error(f\"Plugin {plugin_name} is not found in source.json\")\n\t            return failed_plugins\n\t    def get_existed(self) -> Set[str]:\n\t        plugins_dir = os.path.abspath(\"./plugins\")\n\t        existed_plugins = set()\n\t        for plugin_name in os.listdir(plugins_dir):\n\t            plugin_path = os.path.join(plugins_dir, plugin_name)\n", "            if os.path.isdir(plugin_path):\n\t                # detect __init__.py in the plugin directory\n\t                module_path = os.path.join(plugin_path, \"__init__.py\")\n\t                if os.path.isfile(module_path):\n\t                    existed_plugins.add(plugin_name)\n\t        return existed_plugins\n\t    def import_plugins(self, plugins: list) -> None:\n\t        for plugin in plugins:\n\t            try:\n\t                self._configs[plugin[\"name\"]] = plugin\n", "                importlib.import_module(f\"plugins.{plugin['name']}\")\n\t            except Exception as e:\n\t                logger.exception(f\"Failed to load plugin {plugin['name']}: {e}\")\n\t    def activate_plugins(self, plugins: list) -> None:\n\t        for plugin in plugins:\n\t            instance = self._plugins.get(plugin[\"name\"])\n\t            if instance is not None:\n\t                self.on(EventType.DID_RECEIVE_MESSAGE, instance.did_receive_message)\n\t                self.on(EventType.WILL_GENERATE_REPLY, instance.will_generate_reply)\n\t                self.on(EventType.WILL_DECORATE_REPLY, instance.will_decorate_reply)\n", "                self.on(EventType.WILL_SEND_REPLY, instance.will_send_reply)\n\t    def emit(self, event: Event) -> Event:\n\t        listeners = self.__events__.get(event.type)\n\t        if listeners is not None and len(listeners) > 0:\n\t            for fn in listeners:\n\t                if event.is_proceed:\n\t                    fn(event)\n\t                else:\n\t                    break\n\t        return event\n", "    def built_in(self, plugins: dict):\n\t        self.on(EventType.WILL_GENERATE_REPLY, Cmd(plugins).will_generate_reply)\n"]}
{"filename": "plugins/plugin.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tfrom plugins.event import Event\n\tclass Plugin(ABC):\n\t    name = None\n\t    def __init__(self, config: dict):\n\t        super().__init__()\n\t        if self.name is None:\n\t            raise NotImplementedError(\"Plugin name is not defined\")\n\t        self.config = config\n\t    @abstractmethod\n", "    def did_receive_message(self, event: Event):\n\t        pass\n\t    @abstractmethod\n\t    def will_generate_reply(self, event: Event):\n\t        pass\n\t    @abstractmethod\n\t    def will_decorate_reply(self, event: Event):\n\t        pass\n\t    @abstractmethod\n\t    def will_send_reply(self, event: Event):\n", "        pass\n\t    @abstractmethod\n\t    def help(self, **kwargs) -> str:\n\t        return \"No help docs\"\n"]}
{"filename": "plugins/__init__.py", "chunked_list": ["from .event import EventType, EventAction, Event\n\tfrom .manager import PluginManager\n\tfrom .plugin import Plugin\n\tfrom utils.log import logger\n\tfrom common.reply import Reply, ReplyType\n\t__all__ = [\n\t    \"EventType\",\n\t    \"EventAction\",\n\t    \"Event\",\n\t    \"PluginManager\",\n", "    \"Plugin\",\n\t    \"logger\",\n\t    \"Reply\",\n\t    \"ReplyType\",\n\t]\n\tregister = PluginManager().register\n"]}
{"filename": "plugins/event.py", "chunked_list": ["from enum import Enum\n\tfrom pydantic import BaseModel\n\tfrom common.context import Context\n\tfrom common.reply import Reply\n\tfrom channel.message import Message\n\tfrom channel.channel import Channel\n\tclass EventType(Enum):\n\t    DID_RECEIVE_MESSAGE = 1  # receive message\n\t    WILL_GENERATE_REPLY = 2  # generate reply\n\t    WILL_DECORATE_REPLY = 3  # decorate reply\n", "    WILL_SEND_REPLY = 4  # send reply\n\t    def __str__(self):\n\t        return self.name\n\tclass EventAction(Enum):\n\t    PROCEED = 1  # proceed the plugin chain\n\t    STOP = 2  # stop the plugin chain\n\t    BYPASS = 3  # bypass the plugin chain and default logic\n\tclass Event(BaseModel):\n\t    class Config:\n\t        arbitrary_types_allowed = True\n", "    type: EventType = None\n\t    channel: Channel = None\n\t    message: Message = None\n\t    context: Context = None\n\t    reply: Reply = None\n\t    action: EventAction = EventAction.PROCEED\n\t    def __init__(self, type: EventType, data: dict):\n\t        super().__init__()\n\t        self.type = type\n\t        self.channel = data.get(\"channel\")\n", "        self.message = data.get(\"message\")\n\t        self.context = data.get(\"context\")\n\t        self.reply = data.get(\"reply\")\n\t    def proceed(self):\n\t        self.action = EventAction.PROCEED\n\t    def stop(self):\n\t        self.action = EventAction.STOP\n\t    def bypass(self):\n\t        self.action = EventAction.BYPASS\n\t    @property\n", "    def is_proceed(self) -> bool:\n\t        return self.action == EventAction.PROCEED\n\t    @property\n\t    def is_stop(self) -> bool:\n\t        return self.action == EventAction.STOP\n\t    @property\n\t    def is_bypass(self) -> bool:\n\t        return self.action == EventAction.BYPASS\n"]}
{"filename": "utils/query_key.py", "chunked_list": ["import requests\n\tfrom config import conf\n\tclass QueryKey(object):\n\t    def get_key():\n\t        api_base = conf().get(\"openai_api_base\")\n\t        if api_base:\n\t            api_base = api_base\n\t        else:\n\t            api_base = \"https://api.openai.com/v1\"\n\t        subscription_url = api_base + \"/dashboard/billing/credit_grants\"\n", "        headers = {\n\t            \"Authorization\": \"Bearer \" + conf().get(\"openai_sensitive_id\"),\n\t            \"Content-Type\": \"application/json\",\n\t        }\n\t        subscription_response = requests.get(subscription_url, headers=headers)\n\t        if subscription_response.status_code == 200:\n\t            data = subscription_response.json()\n\t            total_granted = data.get(\"total_granted\")\n\t            total_used = data.get(\"total_used\")\n\t            total_available = data.get(\"total_available\")\n", "        else:\n\t            return subscription_response.text\n\t        return (\n\t            f\"## Total:\\t{total_granted:.2f}$  \\n\"\n\t            f\"## Used:\\t{total_used:.2f}$  \\n\"\n\t            f\"## Available:\\t{total_available:.2f}$  \\n\"\n\t        )\n"]}
{"filename": "utils/log.py", "chunked_list": ["import logging\n\timport sys\n\tdef _get_logger():\n\t    log = logging.getLogger(\"log\")\n\t    log.setLevel(logging.INFO)\n\t    console_handle = logging.StreamHandler(sys.stdout)\n\t    console_handle.setFormatter(\n\t        logging.Formatter(\n\t            \"[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d] - %(message)s\", datefmt=\"%Y-%m-%d %H:%M:%S\"\n\t        )\n", "    )\n\t    log.addHandler(console_handle)\n\t    return log\n\t# log handler\n\tlogger = _get_logger()\n"]}
{"filename": "utils/check.py", "chunked_list": ["def check_prefix(content, prefix_list):\n\t    for prefix in prefix_list:\n\t        if content.startswith(prefix):\n\t            return prefix\n\t    return None\n\tdef is_wx_account(id):\n\t    if id is None:\n\t        return False\n\t    return not id.lower().startswith(\"gh_\")\n"]}
{"filename": "utils/print.py", "chunked_list": ["from pyfiglet import Figlet\n\tfrom termcolor import cprint\n\tdef color_print(text, color=\"green\"):\n\t    content = Figlet(font=\"slant\", width=2000).renderText(text)\n\t    cprint(content, color)\n"]}
{"filename": "utils/api.py", "chunked_list": ["from utils import const\n\tfrom utils.gen import gen_id\n\timport requests\n\timport json\n\tfrom utils.log import logger\n\tfrom utils.const import MessageType\n\tdef fetch(path, data):\n\t    base_data = {\n\t        \"id\": gen_id(),\n\t        \"type\": \"null\",\n", "        \"roomid\": \"null\",\n\t        \"wxid\": \"null\",\n\t        \"content\": \"null\",\n\t        \"nickname\": \"null\",\n\t        \"ext\": \"null\",\n\t    }\n\t    base_data.update(data)\n\t    url = f\"http://{const.IP}:{const.PORT}/{path}\"\n\t    response = requests.post(url, json={\"para\": base_data}, timeout=5)\n\t    return response.json()\n", "def get_personal_info():\n\t    path = \"/api/get_personal_info\"\n\t    data = {\n\t        \"type\": MessageType.PERSONAL_INFO.value,\n\t        \"content\": \"op:personal info\",\n\t    }\n\t    try:\n\t        response = fetch(path, data)\n\t        content = json.loads(response[\"content\"])\n\t        logger.info(\n", "            f\"\"\"\n\t                wechat login info:\n\t                nickName: {content['wx_name']}\n\t                account: {content['wx_code']}\n\t                wechatId: {content['wx_id']}\n\t                startTime: {response['time']}\n\t                \"\"\"\n\t        )\n\t        return content\n\t    except Exception as e:\n", "        logger.error(\"Get personal info failed!\")\n\t        logger.exception(e)\n\t# get sender's nickname in group chat\n\tdef get_sender_name(room_id, sender_id):\n\t    path = \"api/getmembernick\"\n\t    data = {\n\t        \"type\": MessageType.CHATROOM_MEMBER_NICK.value,\n\t        \"wxid\": sender_id,\n\t        \"roomid\": room_id or \"null\",\n\t    }\n", "    response = fetch(path, data)\n\t    return json.loads(response[\"content\"])[\"nick\"]\n\tdef send_txt(msg, wx_id):\n\t    path = \"api/sendtxtmsg\"\n\t    data = {\n\t        \"type\": MessageType.TXT_MSG.value,\n\t        \"content\": msg,\n\t        \"wxid\": wx_id,\n\t    }\n\t    response = fetch(path, data)\n", "    if response[\"status\"] == const.SUCCESS:\n\t        logger.info(\"text sent successfully\")\n\t    else:\n\t        logger.error(f\"[Server Error]: {response.text}\")\n\tdef send_image(img_path, wx_id):\n\t    path = \"api/sendpic\"\n\t    data = {\n\t        \"type\": MessageType.PIC_MSG.value,\n\t        \"content\": img_path,\n\t        \"wxid\": wx_id,\n", "    }\n\t    response = fetch(path, data)\n\t    if response[\"status\"] == const.SUCCESS:\n\t        logger.info(\"image sent successfully\")\n\t    else:\n\t        logger.error(f\"[Server Error]: {response.text}\")\n\tdef send_file(file_path, wx_id):\n\t    path = \"api/sendattatch\"\n\t    data = {\n\t        \"type\": MessageType.ATTACH_FILE.value,\n", "        \"content\": file_path,\n\t        \"wxid\": wx_id,\n\t    }\n\t    response = fetch(path, data)\n\t    if response[\"status\"] == const.SUCCESS:\n\t        logger.info(\"file sent successfully\")\n\t    else:\n\t        logger.error(f\"[Server Error]: {response.text}\")\n"]}
{"filename": "utils/package.py", "chunked_list": ["import subprocess\n\timport sys\n\tdef install(package):\n\t    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package])\n\tdef install_file(file):\n\t    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"-r\", file])\n"]}
{"filename": "utils/const.py", "chunked_list": ["from enum import Enum\n\t# server\n\tIP = \"127.0.0.1\"\n\tPORT = \"5555\"\n\tSERVER = f\"ws://{IP}:{PORT}\"\n\t# \"SUCCSESSED\" should be a typo in the hook server😂\n\tSUCCESS = \"SUCCSESSED\"\n\tclass MessageType(Enum):\n\t    RECV_TXT_MSG = 1\n\t    RECV_PIC_MSG = 3\n", "    RECV_TXT_CITE_MSG = 49\n\t    PIC_MSG = 500\n\t    AT_MSG = 550\n\t    TXT_MSG = 555\n\t    USER_LIST = 5000\n\t    GET_USER_LIST_SUCCESS = 5001\n\t    GET_USER_LIST_FAIL = 5002\n\t    ATTACH_FILE = 5003\n\t    HEART_BEAT = 5005\n\t    CHATROOM_MEMBER = 5010\n", "    CHATROOM_MEMBER_NICK = 5020\n\t    PERSONAL_INFO = 6500\n\t    PERSONAL_DETAIL = 6550\n\t    DEBUG_SWITCH = 6000\n\t    DESTROY_ALL = 9999\n\t    JOIN_ROOM = 10000\n"]}
{"filename": "utils/gen.py", "chunked_list": ["import time\n\tdef gen_id():\n\t    return time.strftime(\"%Y%m%d%H%M%S\")"]}
{"filename": "utils/serialize.py", "chunked_list": ["import os\n\timport time\n\timport json\n\timport requests\n\tfrom channel.message import Message\n\tfrom utils.log import logger\n\tfrom utils.const import MessageType\n\tfrom utils.gen import gen_id\n\tdef serialize_img(image_url: str) -> str:\n\t    return serialize_file(image_url, \"png\")\n", "def serialize_video(video_url: str) -> str:\n\t    return serialize_file(video_url, \"mp4\")\n\tdef serialize_file(file_url: str, suffix: str) -> str:\n\t    try:\n\t        # download file\n\t        path = os.path.abspath(\"./assets\")\n\t        file_name = int(time.time() * 1000)\n\t        response = requests.get(file_url, stream=True)\n\t        response.raise_for_status()  # Raise exception if invalid response\n\t        with open(f\"{path}\\\\{file_name}.{suffix}\", \"wb+\") as f:\n", "            for chunk in response.iter_content(chunk_size=8192):\n\t                if chunk:  # filter out keep-alive new chunks\n\t                    f.write(chunk)\n\t            f.close()\n\t        img_path = os.path.abspath(f\"{path}\\\\{file_name}.{suffix}\").replace(\n\t            \"\\\\\", \"\\\\\\\\\"\n\t        )\n\t        return img_path\n\t    except Exception as e:\n\t        logger.error(f\"[Download File Error]: {e}\")\n", "def serialize_text(text: str, msg: Message) -> str:\n\t    msg_type = MessageType.AT_MSG.value if msg.is_group else MessageType.TXT_MSG.value\n\t    msg = {\n\t        \"id\": gen_id(),\n\t        \"type\": msg_type,\n\t        \"roomid\": msg.room_id or \"null\",\n\t        \"wxid\": msg.sender_id or \"null\",\n\t        \"content\": text,\n\t        \"nickname\": msg.sender_name or \"null\",\n\t        \"ext\": \"null\",\n", "    }\n\t    return json.dumps(msg)\n"]}
{"filename": "common/singleton.py", "chunked_list": ["def singleton(cls):\n\t    instances = {}\n\t    def get_instance(*args, **kwargs):\n\t        if cls not in instances:\n\t            instances[cls] = cls(*args, **kwargs)\n\t        return instances[cls]\n\t    return get_instance\n"]}
{"filename": "common/context.py", "chunked_list": ["from pydantic import BaseModel\n\tfrom enum import Enum\n\tfrom config import conf\n\tclass ContextType(Enum):\n\t    CREATE_TEXT = 1\n\t    CREATE_IMAGE = 2\n\t    def __str__(self):\n\t        return self.name\n\tclass Context(BaseModel):\n\t    session_id: str = None\n", "    type: ContextType = ContextType.CREATE_TEXT\n\t    query: str = None\n\t    system_prompt: str = None\n\t    def __init__(self):\n\t        super().__init__()\n\t        self.system_prompt = conf().get(\"role_desc\")\n"]}
{"filename": "common/session.py", "chunked_list": ["from common.expired_dict import ExpiredDict\n\tfrom config import conf\n\tfrom common.context import Context\n\tclass Session(object):\n\t    all_sessions = ExpiredDict(conf().get(\"session_expired_duration\") or 3600)\n\t    @staticmethod\n\t    def build_session_query(context: Context):\n\t        \"\"\"\n\t        build query with conversation history\n\t        e.g.  [\n", "            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n\t            {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"},\n\t            {\"role\": \"assistant\", \"content\": \"The Los Angeles Dodgers won the World Series in 2020.\"},\n\t            {\"role\": \"user\", \"content\": \"Where was it played?\"}\n\t        ]\n\t        :param query: query content\n\t        :param session_id: session id\n\t        :return: query content with conversaction\n\t        \"\"\"\n\t        session = Session.all_sessions.get(context.session_id, [])\n", "        if len(session) == 0:\n\t            system_item = {\"role\": \"system\", \"content\": context.system_prompt}\n\t            session.append(system_item)\n\t            Session.all_sessions[context.session_id] = session\n\t        user_item = {\"role\": \"user\", \"content\": context.query}\n\t        session.append(user_item)\n\t        return session\n\t    @staticmethod\n\t    def save_session(answer, session_id, total_tokens):\n\t        max_tokens = conf().get(\"max_tokens\")\n", "        session = Session.all_sessions.get(session_id)\n\t        if session:\n\t            # append conversation\n\t            gpt_item = {\"role\": \"assistant\", \"content\": answer}\n\t            session.append(gpt_item)\n\t        # discard exceed limit conversation\n\t        Session.discard_exceed_conversation(session, max_tokens, total_tokens)\n\t    @staticmethod\n\t    def discard_exceed_conversation(session, max_tokens, total_tokens):\n\t        dec_tokens = int(total_tokens)\n", "        while dec_tokens > max_tokens:\n\t            # pop first conversation\n\t            if len(session) > 3:\n\t                session.pop(1)\n\t                session.pop(1)\n\t            else:\n\t                break\n\t            dec_tokens = dec_tokens - max_tokens\n\t    @staticmethod\n\t    def clear_session(session_id):\n", "        Session.all_sessions[session_id] = []\n\t    @staticmethod\n\t    def clear_all_session():\n\t        Session.all_sessions.clear()\n"]}
{"filename": "common/expired_dict.py", "chunked_list": ["from datetime import datetime, timedelta\n\tclass ExpiredDict(dict):\n\t    def __init__(self, expired_duration):\n\t        super().__init__()\n\t        self.expired_duration = expired_duration\n\t    def __getitem__(self, key):\n\t        value, expired_time = super().__getitem__(key)\n\t        if datetime.now() > expired_time:\n\t            del self[key]\n\t            raise KeyError(f\"expired {key}\")\n", "        self.__setitem__(key, value)\n\t        return value\n\t    def __setitem__(self, key, value):\n\t        expired_time = datetime.now() + timedelta(seconds=self.expired_duration)\n\t        super().__setitem__(key, (value, expired_time))\n\t    def get(self, key, default=None):\n\t        try:\n\t            return self[key]\n\t        except KeyError:\n\t            return default\n"]}
{"filename": "common/emitter.py", "chunked_list": ["from enum import Enum\n\tfrom typing import Callable\n\tclass Emitter:\n\t    def __init__(self):\n\t        self.__events__ = {}\n\t    # subscribe event\n\t    def on(self, type: Enum, fn: Callable) -> None:\n\t        if type not in self.__events__:\n\t            self.__events__[type] = []\n\t        if not self.has(type, fn):\n", "            self.__events__[type].append(fn)\n\t    # unsubscribe event\n\t    def off(self, type: Enum, fn: Callable) -> None:\n\t        listeners = self.__events__.get(type)\n\t        if listeners is not None and len(listeners) > 0:\n\t            listeners.remove(fn)\n\t    # check if the function has subscribed the event\n\t    def has(self, type: Enum, fn: Callable) -> bool:\n\t        listeners = self.__events__.get(type)\n\t        if listeners is None or len(listeners) == 0:\n", "            return False\n\t        return fn in listeners\n\t    # emit event\n\t    def emit(self, type: Enum, *args, **kwargs) -> None:\n\t        listeners = self.__events__.get(type)\n\t        if listeners is not None and len(listeners) > 0:\n\t            for fn in listeners:\n\t                fn(*args, **kwargs)\n\t    # subscribe event and unsubscribe after once\n\t    def once(self, type: Enum, fn: Callable) -> None:\n", "        def once_fn(*args, **kwargs):\n\t            fn(*args, **kwargs)\n\t            self.off(type, once_fn)\n\t        self.on(type, once_fn)\n"]}
{"filename": "common/reply.py", "chunked_list": ["from enum import Enum\n\tfrom pydantic import BaseModel\n\tclass ReplyType(Enum):\n\t    TEXT = 1\n\t    IMAGE = 2\n\t    VIDEO = 3\n\t    def __str__(self):\n\t        return self.name\n\tclass Reply(BaseModel):\n\t    type: ReplyType = None\n", "    content: str = None\n\t    def __init__(self, type: ReplyType, content: str):\n\t        super().__init__()\n\t        self.type = type\n\t        self.content = content\n\t    def __str__(self):\n\t        return f\"Reply(type={self.type}, content={self.content})\"\n"]}
{"filename": "bot/bot.py", "chunked_list": ["import litellm\n\tfrom common.context import Context\n\tfrom config import conf\n\tfrom common.singleton import singleton\n\tfrom common.reply import Reply\n\t@singleton\n\tclass Bot:\n\t    def __init__(self):\n\t        use_azure_chatgpt = conf().get(\"use_azure_chatgpt\", False)\n\t        model = conf().get(\"model\", \"gpt-3.5-turbo\")\n", "        if use_azure_chatgpt:\n\t            from bot.azure_chatgpt import AzureChatGPTBot\n\t            self.bot = AzureChatGPTBot()\n\t        elif model in litellm.open_ai_chat_completion_models:\n\t            from bot.chatgpt import ChatGPTBot\n\t            self.bot = ChatGPTBot()\n\t        else:\n\t            # see litellm supported models here:\n\t            # https://litellm.readthedocs.io/en/latest/supported/\n\t            from bot.litellm import LiteLLMChatGPTBot\n", "            self.bot = LiteLLMChatGPTBot()\n\t    def reply(self, context: Context) -> Reply:\n\t        return self.bot.reply(context)\n"]}
{"filename": "bot/azure_chatgpt.py", "chunked_list": ["import openai\n\tfrom bot.chatgpt import ChatGPTBot\n\tfrom config import conf\n\tclass AzureChatGPTBot(ChatGPTBot):\n\t    def __init__(self):\n\t        super().__init__()\n\t        openai.api_type = \"azure\"\n\t        openai.api_version = \"2023-06-01-preview\"\n\t        self.args[\"deployment_id\"] = conf().get(\"azure_deployment_id\")\n"]}
{"filename": "bot/chatgpt.py", "chunked_list": ["import openai\n\tfrom config import conf\n\tfrom utils.log import logger\n\tfrom common.session import Session\n\tfrom common.reply import Reply, ReplyType\n\tfrom common.context import ContextType, Context\n\tclass ChatGPTBot:\n\t    def __init__(self):\n\t        openai.api_key = conf().get(\"openai_api_key\")\n\t        api_base = conf().get(\"openai_api_base\")\n", "        proxy = conf().get(\"proxy\")\n\t        if api_base:\n\t            openai.api_base = api_base\n\t        if proxy:\n\t            openai.proxy = proxy\n\t        self.name = self.__class__.__name__\n\t        self.args = {\n\t            \"model\": conf().get(\"model\"),\n\t            \"temperature\": conf().get(\"temperature\"),\n\t        }\n", "    def reply(self, context: Context) -> Reply:\n\t        query = context.query\n\t        logger.info(f\"[{self.name}] Query={query}\")\n\t        if context.type == ContextType.CREATE_IMAGE:\n\t            return self.reply_img(query)\n\t        else:\n\t            session_id = context.session_id\n\t            session = Session.build_session_query(context)\n\t            response = self.reply_text(session)\n\t            logger.info(f\"[{self.name}] Response={response['content']}\")\n", "            if response[\"completion_tokens\"] > 0:\n\t                Session.save_session(\n\t                    response[\"content\"], session_id, response[\"total_tokens\"]\n\t                )\n\t            return Reply(ReplyType.TEXT, response[\"content\"])\n\t    def reply_img(self, query) -> Reply:\n\t        create_image_size = conf().get(\"create_image_size\", \"256x256\")\n\t        try:\n\t            response = openai.Image.create(prompt=query, n=1, size=create_image_size)\n\t            image_url = response[\"data\"][0][\"url\"]\n", "            logger.info(f\"[{self.name}] Image={image_url}\")\n\t            return Reply(ReplyType.IMAGE, image_url)\n\t        except Exception as e:\n\t            logger.error(f\"[{self.name}] Create image failed: {e}\")\n\t            return Reply(ReplyType.TEXT, \"Image created failed\")\n\t    def reply_text(self, session):\n\t        try:\n\t            response = openai.ChatCompletion.create(\n\t                messages=session,\n\t                top_p=1.0,\n", "                frequency_penalty=0.0,\n\t                presence_penalty=0.0,\n\t                **self.args,\n\t            )\n\t            return {\n\t                \"total_tokens\": response[\"usage\"][\"total_tokens\"],\n\t                \"completion_tokens\": response[\"usage\"][\"completion_tokens\"],\n\t                \"content\": response.choices[0][\"message\"][\"content\"],\n\t            }\n\t        except Exception as e:\n", "            result = {\"completion_tokens\": 0, \"content\": \"Please ask me again\"}\n\t            if isinstance(e, openai.error.RateLimitError):\n\t                logger.warn(f\"[{self.name}] RateLimitError: {e}\")\n\t                result[\"content\"] = \"Ask too frequently, please try again in 20s\"\n\t            elif isinstance(e, openai.error.APIConnectionError):\n\t                logger.warn(f\"[{self.name}] APIConnectionError: {e}\")\n\t                result[\n\t                    \"content\"\n\t                ] = \"I cannot connect the server, please check the network and try again\"\n\t            elif isinstance(e, openai.error.Timeout):\n", "                logger.warn(f\"[{self.name}] Timeout: {e}\")\n\t                result[\"content\"] = \"I didn't receive your message, please try again\"\n\t            elif isinstance(e, openai.error.APIError):\n\t                logger.warn(f\"[{self.name}] APIError: {e}\")\n\t            else:\n\t                logger.exception(f\"[{self.name}] Exception: {e}\")\n\t        return result\n"]}
{"filename": "bot/litellm.py", "chunked_list": ["from bot.chatgpt import ChatGPTBot\n\timport openai\n\timport litellm\n\tfrom litellm import completion\n\tfrom utils.log import logger\n\tfrom config import conf\n\tclass LiteLLMChatGPTBot(ChatGPTBot):\n\t    def __init__(self):\n\t        api_key = conf().get(\"openai_api_key\")\n\t        model = conf().get(\"model\", \"gpt-3.5-turbo\")\n", "        api_base = conf().get(\"openai_api_base\")\n\t        proxy = conf().get(\"proxy\")\n\t        if model in litellm.cohere_models:\n\t            litellm.cohere_key = api_key\n\t        elif model in litellm.anthropic_models:\n\t            litellm.anthropic_key = api_key\n\t        else:\n\t            litellm.openai_key = api_key\n\t        if api_base:\n\t            litellm.api_base = api_base\n", "        if proxy:\n\t            openai.proxy = proxy\n\t        self.name = self.__class__.__name__\n\t        self.args = {\n\t            \"model\": model,\n\t            \"temperature\": conf().get(\"temperature\"),\n\t        }\n\t    def reply_text(self, session):\n\t        try:\n\t            response = completion(\n", "                messages=session,\n\t                top_p=1.0,\n\t                frequency_penalty=0.0,\n\t                presence_penalty=0.0,\n\t                **self.args,\n\t            )\n\t            return {\n\t                \"total_tokens\": response[\"usage\"][\"total_tokens\"],\n\t                \"completion_tokens\": response[\"usage\"][\"completion_tokens\"],\n\t                \"content\": response.choices[0][\"message\"][\"content\"],\n", "            }\n\t        except Exception as e:\n\t            result = {\"completion_tokens\": 0, \"content\": \"Please ask me again\"}\n\t            if isinstance(e, openai.error.RateLimitError):\n\t                logger.warn(f\"[{self.name}] RateLimitError: {e}\")\n\t                result[\"content\"] = \"Ask too frequently, please try again in 20s\"\n\t            elif isinstance(e, openai.error.APIConnectionError):\n\t                logger.warn(f\"[{self.name}] APIConnectionError: {e}\")\n\t                result[\n\t                    \"content\"\n", "                ] = \"I cannot connect the server, please check the network and try again\"\n\t            elif isinstance(e, openai.error.Timeout):\n\t                logger.warn(f\"[{self.name}] Timeout: {e}\")\n\t                result[\"content\"] = \"I didn't receive your message, please try again\"\n\t            elif isinstance(e, openai.error.APIError):\n\t                logger.warn(f\"[{self.name}] APIError: {e}\")\n\t            else:\n\t                logger.exception(f\"[{self.name}] Exception: {e}\")\n\t        return result\n"]}
{"filename": "channel/channel.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tclass Channel(ABC):\n\t    @abstractmethod\n\t    def handle_message(self, msg):\n\t        pass\n\t    @abstractmethod\n\t    def handle_group(self, msg):\n\t        pass\n\t    @abstractmethod\n\t    def handle_single(self, msg):\n", "        pass\n\t    @abstractmethod\n\t    def decorate_reply(self, reply, msg):\n\t        pass\n\t    @abstractmethod\n\t    def handle_reply(self, msg, context):\n\t        pass\n\t    @abstractmethod\n\t    def send(self, reply, msg):\n\t        pass\n"]}
{"filename": "channel/wechat.py", "chunked_list": ["import json\n\timport warnings\n\timport websocket\n\tfrom bs4 import BeautifulSoup\n\timport requests\n\tfrom utils.log import logger\n\tfrom utils import const\n\timport os\n\tfrom bot.bot import Bot\n\tfrom common.singleton import singleton\n", "from config import conf\n\tfrom utils.check import check_prefix, is_wx_account\n\tfrom common.reply import ReplyType, Reply\n\tfrom channel.message import Message\n\tfrom utils.api import get_personal_info, send_image, send_file\n\tfrom utils.const import MessageType\n\tfrom utils.serialize import serialize_img, serialize_text, serialize_video\n\tfrom plugins.manager import PluginManager\n\tfrom common.context import ContextType, Context\n\tfrom plugins.event import EventType, Event\n", "from channel.channel import Channel\n\t@singleton\n\tclass WeChatChannel(Channel):\n\t    def __init__(self):\n\t        requests.packages.urllib3.disable_warnings()\n\t        warnings.filterwarnings(\"ignore\")\n\t        os.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"1\"\n\t        self.personal_info = get_personal_info()\n\t        self.ws = websocket.WebSocketApp(\n\t            const.SERVER,\n", "            on_open=self.on_open,\n\t            on_message=self.on_message,\n\t            on_error=self.on_error,\n\t            on_close=self.on_close,\n\t        )\n\t    def startup(self):\n\t        logger.info(\"App startup successfully!\")\n\t        self.ws.run_forever()\n\t    def on_message(self, ws, message):\n\t        raw_msg = json.loads(message)\n", "        msg_type = raw_msg[\"type\"]\n\t        handlers = {\n\t            MessageType.AT_MSG.value: self.handle_message,\n\t            MessageType.TXT_MSG.value: self.handle_message,\n\t            MessageType.PIC_MSG.value: self.handle_message,\n\t            MessageType.RECV_PIC_MSG.value: self.handle_message,\n\t            MessageType.RECV_TXT_MSG.value: self.handle_message,\n\t            MessageType.RECV_TXT_CITE_MSG.value: self.handle_cite_message,\n\t            MessageType.HEART_BEAT.value: self.noop,\n\t        }\n", "        handlers.get(msg_type, logger.info)(raw_msg)\n\t    def noop(self, raw_msg):\n\t        pass\n\t    def handle_cite_message(self, raw_msg):\n\t        xml_msg = (\n\t            raw_msg[\"content\"][\"content\"]\n\t            .replace(\"&amp;\", \"&\")\n\t            .replace(\"&lt;\", \"<\")\n\t            .replace(\"&gt;\", \">\")\n\t        )\n", "        soup = BeautifulSoup(xml_msg, \"lxml\")\n\t        cooked_msg = {\n\t            \"content\": soup.select_one(\"title\").text,\n\t            \"id\": raw_msg[\"id\"],\n\t            \"id1\": raw_msg[\"content\"][\"id2\"],\n\t            \"id2\": \"\",\n\t            \"id3\": \"\",\n\t            \"srvid\": raw_msg[\"srvid\"],\n\t            \"time\": raw_msg[\"time\"],\n\t            \"type\": raw_msg[\"type\"],\n", "            \"wxid\": raw_msg[\"content\"][\"id1\"],\n\t        }\n\t        self.handle_message(cooked_msg)\n\t    def handle_message(self, raw_msg):\n\t        if \"wxid\" not in raw_msg and raw_msg[\"status\"] == const.SUCCESS:\n\t            logger.info(\"message sent successfully\")\n\t            return\n\t        # ignore message sent by self\n\t        if raw_msg[\"id2\"] == self.personal_info[\"wx_id\"]:\n\t            logger.info(\"message sent by self, ignore\")\n", "            return\n\t        msg = Message(raw_msg, self.personal_info)\n\t        logger.info(f\"message received: {msg}\")\n\t        e = PluginManager().emit(\n\t            Event(EventType.DID_RECEIVE_MESSAGE, {\"channel\": self, \"message\": msg})\n\t        )\n\t        if e.is_bypass:\n\t            return self.send(e.reply, e.message)\n\t        if e.message.is_group:\n\t            self.handle_group(e.message)\n", "        else:\n\t            self.handle_single(e.message)\n\t    def handle_group(self, msg: Message):\n\t        session_independent = conf().get(\"chat_group_session_independent\")\n\t        context = Context()\n\t        context.session_id = msg.sender_id if session_independent else msg.room_id\n\t        if msg.is_at:\n\t            query = msg.content.replace(f\"@{msg.receiver_name}\", \"\", 1).strip()\n\t            context.query = query\n\t            create_image_prefix = conf().get(\"create_image_prefix\")\n", "            match_prefix = check_prefix(query, create_image_prefix)\n\t            if match_prefix:\n\t                context.type = ContextType.CREATE_IMAGE\n\t            self.handle_reply(msg, context)\n\t    def handle_single(self, msg: Message):\n\t        # ignore message sent by public/subscription account\n\t        if not is_wx_account(msg.sender_id):\n\t            logger.info(\"message sent by public/subscription account, ignore\")\n\t            return\n\t        context = Context()\n", "        context.session_id = msg.sender_id\n\t        query = msg.content\n\t        single_chat_prefix = conf().get(\"single_chat_prefix\")\n\t        if single_chat_prefix is not None and len(single_chat_prefix) > 0:\n\t            match_chat_prefix = check_prefix(query, single_chat_prefix)\n\t            if match_chat_prefix is not None:\n\t                query = query.replace(match_chat_prefix, \"\", 1).strip()\n\t            else:\n\t                logger.info(\"your message is not start with single_chat_prefix, ignore\")\n\t                return\n", "        context.query = query\n\t        create_image_prefix = conf().get(\"create_image_prefix\")\n\t        match_image_prefix = check_prefix(query, create_image_prefix)\n\t        if match_image_prefix:\n\t            context.type = ContextType.CREATE_IMAGE\n\t        self.handle_reply(msg, context)\n\t    def decorate_reply(self, reply: Reply, msg: Message) -> Reply:\n\t        if reply.type == ReplyType.TEXT:\n\t            group_chat_reply_prefix = conf().get(\"group_chat_reply_prefix\", \"\")\n\t            group_chat_reply_suffix = conf().get(\"group_chat_reply_suffix\", \"\")\n", "            single_chat_reply_prefix = conf().get(\"single_chat_reply_prefix\", \"\")\n\t            single_chat_reply_suffix = conf().get(\"single_chat_reply_suffix\", \"\")\n\t            reply_text = reply.content\n\t            if msg.is_group:\n\t                reply_text = (\n\t                    group_chat_reply_prefix + reply_text + group_chat_reply_suffix\n\t                )\n\t            else:\n\t                reply_text = (\n\t                    single_chat_reply_prefix + reply_text + single_chat_reply_suffix\n", "                )\n\t            reply.content = reply_text\n\t        return reply\n\t    def handle_reply(self, msg: Message, context: Context):\n\t        e1 = PluginManager().emit(\n\t            Event(\n\t                EventType.WILL_GENERATE_REPLY,\n\t                {\"channel\": self, \"message\": msg, \"context\": context},\n\t            )\n\t        )\n", "        if e1.is_bypass:\n\t            return self.send(e1.reply, e1.message)\n\t        rawReply = Bot().reply(e1.context)\n\t        e2 = PluginManager().emit(\n\t            Event(\n\t                EventType.WILL_DECORATE_REPLY,\n\t                {\n\t                    \"channel\": self,\n\t                    \"message\": e1.message,\n\t                    \"context\": e1.context,\n", "                    \"reply\": rawReply,\n\t                },\n\t            )\n\t        )\n\t        if e2.is_bypass:\n\t            return self.send(e2.reply, e2.message)\n\t        reply = self.decorate_reply(rawReply, msg)\n\t        e3 = PluginManager().emit(\n\t            Event(\n\t                EventType.WILL_SEND_REPLY,\n", "                {\n\t                    \"channel\": self,\n\t                    \"message\": e2.message,\n\t                    \"context\": e2.context,\n\t                    \"reply\": reply,\n\t                },\n\t            )\n\t        )\n\t        self.send(e3.reply, e3.message)\n\t    def send(self, reply: Reply, msg: Message):\n", "        if reply is None:\n\t            return\n\t        if reply.type == ReplyType.IMAGE:\n\t            img_path = serialize_img(reply.content)\n\t            wx_id = msg.room_id if msg.is_group else msg.sender_id\n\t            send_image(img_path, wx_id)\n\t        elif reply.type == ReplyType.VIDEO:\n\t            file_path = serialize_video(reply.content)\n\t            wx_id = msg.room_id if msg.is_group else msg.sender_id\n\t            send_file(file_path, wx_id)\n", "        else:\n\t            reply_msg = serialize_text(reply.content, msg)\n\t            self.ws.send(reply_msg)\n\t    def on_open(self, ws):\n\t        logger.info(\"[Websocket] connected\")\n\t    def on_close(self, ws):\n\t        logger.info(\"[Websocket] disconnected\")\n\t    def on_error(self, ws, error):\n\t        logger.error(f\"[Websocket] Error: {error}\")\n"]}
{"filename": "channel/message.py", "chunked_list": ["from pydantic import BaseModel\n\tfrom utils.api import get_sender_name\n\tclass Message(BaseModel):\n\t    room_id: str = None\n\t    sender_id: str = None\n\t    sender_name: str = None\n\t    receiver_id: str = None\n\t    receiver_name: str = None\n\t    content: str = None\n\t    type: int = None  # MessageType value\n", "    is_group: bool = False\n\t    is_at: bool = False\n\t    create_time: str = None\n\t    _raw_msg: dict = None\n\t    def __init__(self, msg, info):\n\t        super().__init__()\n\t        self._raw_msg = msg\n\t        self.receiver_id = info[\"wx_id\"]\n\t        self.receiver_name = info[\"wx_name\"]\n\t        self.content = msg[\"content\"].strip()\n", "        self.type = msg[\"type\"]\n\t        self.create_time = msg[\"time\"]\n\t        if \"@chatroom\" in msg[\"wxid\"]:\n\t            self.is_group = True\n\t            self.room_id = msg[\"wxid\"]\n\t            self.sender_id = msg[\"id1\"]\n\t            self.is_at = f\"@{self.receiver_name}\" in self.content\n\t        else:\n\t            self.is_group = False\n\t            self.sender_id = msg[\"wxid\"]\n", "        self.sender_name = get_sender_name(self.room_id, self.sender_id)\n\t    def __str__(self):\n\t        return f\"Message(room_id={self.room_id}, sender_id={self.sender_id}, sender_name={self.sender_name}, receiver_id={self.receiver_id}, receiver_name={self.receiver_name}, content={self.content}, type={self.type}, is_group={self.is_group}, create_time={self.create_time}, is_at={self.is_at})\"\n"]}
