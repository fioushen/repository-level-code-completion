{"filename": "main.py", "chunked_list": ["from datetime import datetime\n\timport traceback\n\tfrom fastapi import Depends, FastAPI, HTTPException\n\tfrom fastapi_limiter.depends import FastAPILimiter\n\tfrom sqlalchemy import text\n\tfrom sqlalchemy.orm import Session\n\timport uvicorn\n\tfrom src.conf import messages\n\tfrom src.database.db import get_db, get_redis\n\tfrom src.routes import auth, comments, images, users, ratings\n", "from src.services.asyncdevlogging import async_logging_to_file\n\tapp = FastAPI()\n\tapp.include_router(auth.router, prefix='/api')\n\tapp.include_router(users.router, prefix='/api')\n\tapp.include_router(images.router, prefix='/api')\n\tapp.include_router(comments.router, prefix='/api')\n\tapp.include_router(ratings.router, prefix='/api')\n\t@app.on_event('startup')\n\tasync def startup() -> None:\n\t    await FastAPILimiter.init(get_redis())\n", "@app.get('/api/healthchecker')\n\tasync def healthchecker(db: Session = Depends(get_db)) -> dict:\n\t    \"\"\"\n\t    The healthchecker function is a simple function that returns a JSON object with the message 'Welcome to FastAPI!'\n\t    This function is used by the healthchecker endpoint, which can be accessed at http://localhost:8000/healthchecker.\n\t    The purpose of this endpoint is to provide an easy way for users and developers to check if the API server has been\n\t    successfully deployed and configured. This endpoint should return a 200 status code when everything works as\n\t    expected.\n\t    :param db: Session: Get the database session\n\t    :return: A dict with the message\n", "    :doc-author: Trelent\n\t    \"\"\"\n\t    try:\n\t        # Make request\n\t        result = db.execute(text('SELECT 1')).fetchone()\n\t        if result is None:\n\t            function_name = traceback.extract_stack(None, 2)[1][2]\n\t            add_log = f'\\n500:\\t{datetime.now()}\\t{messages.MSC500_DATABASE_CONNECT}\\t{function_name}'\n\t            await async_logging_to_file(add_log)\n\t            raise HTTPException(status_code=500, detail=messages.MSC500_DATABASE_CONFIG)\n", "        function_name = traceback.extract_stack(None, 2)[1][2]\n\t        add_log = f'\\n000:\\t{datetime.now()}\\t{messages.WELCOME_FASTAPI}\\t{function_name}'\n\t        await async_logging_to_file(add_log)\n\t        return {'message': messages.WELCOME_FASTAPI}\n\t    except Exception as e:\n\t        function_name = traceback.extract_stack(None, 2)[1][2]\n\t        add_log = f'\\n000:\\t{datetime.now()}\\t{messages.MSC500_DATABASE_CONNECT}: {e}\\t{function_name}'\n\t        await async_logging_to_file(add_log)\n\t        raise HTTPException(status_code=500, detail=messages.MSC500_DATABASE_CONNECT)\n\t@app.get('/')\n", "def read_root() -> dict:\n\t    \"\"\"\n\t    The read_root function returns a dictionary with the key 'message' and value of `WELCOME`\n\t    :return: A dictionary with the key 'message' and the value of `welcome`\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    return {'message': messages.WELCOME}\n\tif __name__ == '__main__':\n\t    uvicorn.run(app, host='0.0.0.0', port=8000)\n"]}
{"filename": "tests/test_repository_images.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import MagicMock\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import Image, Tag\n\tfrom src.schemas.images import ImageModel\n\tfrom src.repository.images import (\n\t    create_image,\n\t    get_image,\n\t    get_images,\n\t    transform_image,\n", "    remove_image,\n\t    update_image,\n\t    get_images_by_tag,\n\t    get_images_by_user\n\t)\n\t'''\n\tUnit tests for the application.\n\t'''\n\t'''\n\tTest src.repository.images \n", "1. create_image,\n\t2. get_image,\n\t3. get_images,\n\t4. transform_image,\n\t5. remove_image,\n\t6. update_image,\n\t7. get_images_by_tag,\n\t8. get_images_by_user\n\t'''\n\tclass TestImagesRepository(unittest.TestCase):\n", "    def setUp(self):\n\t        self.session = MagicMock(spec=Session)\n\t        self.user = {'id': 1, 'roles': 'user'}\n\t    async def test_create_image(self):\n\t        image = ImageModel(name='Test image', description='Test description', tags=['test', 'image'])\n\t        result = await create_image(body=image, user=self.user, db=self.session)\n\t        self.assertTrue(hasattr(result, 'id'))\n\t        self.assertEqual(result.description, image.description)\n\t        self.assertEqual(result.user_id, self.user['id'])\n\t        self.assertEqual(result.tags, image.tags)\n", "    async def test_get_image(self):\n\t        image = Image()\n\t        self.session.query().filter_by().first.return_value = image\n\t        result = await get_image(image_id=image.id, user=self.user, db=self.session)\n\t        self.assertEqual(image, result)\n\t    async def test_get_images(self):\n\t        images = [Image(), Image()]\n\t        self.session.query().filter_by().offset().limit().all.return_value = images\n\t        result = await get_images(user=self.user, db=self.session)\n\t        self.assertEqual(result, images)\n", "    async def test_transform_image(self):\n\t        image = Image()\n\t        self.session.query().filter_by().first.return_value = image\n\t        result = await transform_image(image_id=image.id, user=self.user, db=self.session)\n\t        self.assertEqual(image, result)\n\t    async def test_remove_image(self):\n\t        image = Image()\n\t        self.session.query().filter_by().first.return_value = image\n\t        result = await remove_image(image_id=image.id, user=self.user, db=self.session)\n\t        self.assertEqual(image, result)\n", "    async def test_update_image(self):\n\t        image = Image()\n\t        self.session.query().filter_by().first.return_value = image\n\t        result = await update_image(image_id=image.id, user=self.user, db=self.session)\n\t        self.assertEqual(image, result)\n\t    async def test_get_images_by_tag(self):\n\t        images = [Image(), Image()]\n\t        self.session.query().filter_by().offset().limit().all.return_value = images\n\t        result = await get_images_by_tag(tag='test', user=self.user, db=self.session)\n\t        self.assertEqual(result, images)\n", "    async def test_get_images_by_user(self):\n\t        images = [Image(), Image()]\n\t        self.session.query().filter_by().offset().limit().all.return_value = images\n\t        result = await get_images_by_user(user_id=self.user['id'], user=self.user, db=self.session)\n\t        self.assertEqual(result, images)\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "tests/test_routes_images.py", "chunked_list": ["from unittest.mock import patch, AsyncMock, MagicMock\n\timport unittest.mock as um\n\tfrom src.conf import messages\n\tfrom src.services.auth import AuthUser\n\tfrom src.database.models import User, Image\n\t'''\n\tIntegration tests for the application.\n\t'''\n\t'''\n\tTest src.routes.comments\n", "1. test_create_image\n\t2. test_get_image\n\t3. test_get_images\n\t4. test_get_image_by_tag_name\n\t5. test_get_image_by_user\n\t6. test_update_image\n\t7. test_remove_image\n\t8. test_transforme_image\n\t9. test_image_qrcode\n\t'''\n", "def test_create_image(client, session, admin, admin_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        mock_public_id = MagicMock()\n\t        monkeypatch.setattr('src.services.images.CloudImage.generate_name_image', mock_public_id)\n\t        mock_r = MagicMock()\n\t        monkeypatch.setattr('src.services.images.CloudImage.image_upload', mock_r)\n", "        mock_src_url = MagicMock()\n\t        mock_src_url.return_value = 'some url'\n\t        monkeypatch.setattr('src.services.images.CloudImage.get_url_for_image', mock_src_url)\n\t        current_user = session.query(User).filter_by(email=admin.get('email')).first()\n\t        session.expunge(current_user)\n\t        with um.patch('builtins.open', um.mock_open(read_data='test')) as mock_file:\n\t            response = client.post(\n\t                '/api/images/',\n\t                params={'description': image['description'], 'tags': image['tags']},\n\t                files={'file': ('filename', open(mock_file, 'rb'), 'image/jpeg')},\n", "                headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n\t            )\n\t        assert response.status_code == 200, response.text\n\t        data = response.json()\n\t        assert data['description'] == image['description']\n\t        assert data['tags'][0]['name'] == image['tags'].split()[0]\n\t        assert data['user_id'] == current_user.id\n\t        assert 'id' in data\n\tdef test_create_image_by_user(client, session, user, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n", "        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        mock_public_id = MagicMock()\n\t        monkeypatch.setattr('src.services.images.CloudImage.generate_name_image', mock_public_id)\n\t        mock_r = MagicMock()\n\t        monkeypatch.setattr('src.services.images.CloudImage.image_upload', mock_r)\n\t        mock_src_url = MagicMock()\n\t        mock_src_url.return_value = 'some url'\n", "        monkeypatch.setattr('src.services.images.CloudImage.get_url_for_image', mock_src_url)\n\t        current_user = session.query(User).filter_by(email=user.get('email')).first()\n\t        session.expunge(current_user)\n\t        with um.patch('builtins.open', um.mock_open(read_data='test')) as mock_file:\n\t            response = client.post(\n\t                '/api/images/',\n\t                params={'description': image['description'], 'tags': image['tags']},\n\t                files={'file': ('filename', open(mock_file, 'rb'), 'image/jpeg')},\n\t                headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t            )\n", "        assert response.status_code == 200, response.text\n\t        data = response.json()\n\t        assert data['description'] == image['description']\n\t        assert data['tags'][0]['name'] == image['tags'].split()[0]\n\t        assert data['user_id'] == current_user.id\n\t        assert 'id' in data\n\tdef test_create_image_toomanytags(client, session, user, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n", "        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        mock_public_id = MagicMock()\n\t        monkeypatch.setattr('src.services.images.CloudImage.generate_name_image', mock_public_id)\n\t        mock_r = MagicMock()\n\t        monkeypatch.setattr('src.services.images.CloudImage.image_upload', mock_r)\n\t        mock_src_url = MagicMock()\n\t        mock_src_url.return_value = 'some url'\n\t        monkeypatch.setattr('src.services.images.CloudImage.get_url_for_image', mock_src_url)\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n", "        session.expunge(user)\n\t        tags = ' '.join(['tag' for i in range(11)])\n\t        with um.patch('builtins.open', um.mock_open(read_data='test')) as mock_file:\n\t            response = client.post(\n\t                '/api/images/',\n\t                params={'description': image['description'], 'tags': tags},\n\t                files={'file': ('filename', open(mock_file, 'rb'), 'image/jpeg')},\n\t                headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t            )\n\t        assert response.status_code == 409, response.text\n", "        data = response.json()\n\t        assert data['detail'] == messages.MSC409_TAGS\n\tdef test_create_image_no_token(client, session, user, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        mock_public_id = MagicMock()\n\t        monkeypatch.setattr('src.services.images.CloudImage.generate_name_image', mock_public_id)\n", "        mock_r = MagicMock()\n\t        monkeypatch.setattr('src.services.images.CloudImage.image_upload', mock_r)\n\t        mock_src_url = MagicMock()\n\t        mock_src_url.return_value = 'some url'\n\t        monkeypatch.setattr('src.services.images.CloudImage.get_url_for_image', mock_src_url)\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        session.expunge(user)\n\t        with um.patch('builtins.open', um.mock_open(read_data='test')) as mock_file:\n\t            response = client.post(\n\t                '/api/images/',\n", "                params={'description': image['description'], 'tags': image['tags']},\n\t                files={'file': ('filename', open(mock_file, 'rb'), 'image/jpeg')},\n\t                # headers={'Authorization': f'Bearer some_token'}\n\t            )\n\t        assert response.status_code == 401, response.text\n\t        data = response.json()\n\t        assert data['detail'] == 'Not authenticated'\n\tdef test_get_image(client, session, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n", "        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        response = client.get(\n\t            '/api/images/1',\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert type(data) == dict\n", "        assert data['description'] == image['description']\n\t        assert 'id' in data\n\tdef test_image_no_such_image(client, session, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        response = client.get(\n\t            '/api/images/999',\n", "            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 404, response.text\n\t        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND\n\tdef test_get_images(client, session, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n", "        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        response = client.get(\n\t            '/api/images/',\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert type(data) == dict\n\t        assert data['items'][0]['description'] == image['description']\n\t        assert 'id' in data['items'][0]\n", "def test_get_images_not_authenticated(client, session, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        response = client.get(\n\t            '/api/images/',\n\t            # headers={'Authorization': f'Bearer {token['access_token']}'}\n\t        )\n", "        assert response.status_code == 401, response.text\n\t        data = response.json()\n\t        assert data['detail'] == 'Not authenticated'\n\tdef test_get_image_by_tag_name(client, session, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        response = client.get(\n", "                              f'''api//images/search_bytag/{image['tags'].split()[0]}''',\n\t                              params={'sort_direction': 'asc'},\n\t                              headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t                              )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert type(data) == list\n\t        assert data[0]['description'] == image['description']\n\t        assert 'id' in data[0]\n\tdef test_get_image_by_tag_name_no_tags(client, session, user_token, image, monkeypatch):\n", "    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        response = client.get(\n\t            # f'api//images/search_bytag/{image['tags'].split()[0]}',\n\t            f'api//images/search_bytag/no_tag',\n\t            params={'sort_direction': 'asc'},\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n", "        )\n\t        data = response.json()\n\t        assert response.status_code == 404, response.text\n\t        assert data['detail'] == messages.MSC404_TAG_NOT_FOUND\n\tdef test_get_image_by_user_userrole(client, session, user_token, user, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n", "        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        response = client.get(\n\t            f'/api/images/search_byuser/{user.id}',\n\t            params={'sort_direction': 'asc'},\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 403, response.text\n\t        assert data['detail'] == messages.MSC403_FORBIDDEN\n\tdef test_get_image_by_user_adminrole(client, session, admin_token, user, image, monkeypatch):\n", "    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        session.expunge(user)\n\t        response = client.get(\n\t            f'/api/images/search_byuser/{user.id}',\n\t            params={'sort_direction': 'asc'},\n", "            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert type(data) == list\n\t        assert data[0]['user_id'] == user.id\n\tdef test_get_image_by_user_no_user(client, session, admin_token, user, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n", "        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        response = client.get(\n\t            f'/api/images/search_byuser/9999',\n\t            params={'sort_direction': 'asc'},\n\t            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 404, response.text\n\t        assert data['detail'] == messages.MSC404_USER_NOT_FOUND\n", "def test_transforme_image(client, session, user, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\t        response = client.post(\n\t            f'/api/images/transformation/{test_image.id}',\n", "            params={'type': 'black_white'},\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert type(data) == dict\n\t        assert 'e_grayscale' in data['link']\n\tdef test_transforme_foreign_image(client, session, admin, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n", "        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        admin = session.query(User).filter_by(email=admin.get('email')).first()\n\t        test_image = session.query(Image).filter_by(user_id=admin.id).first()\n\t        response = client.post(\n\t            f'/api/images/transformation/{test_image.id}',\n\t            params={'type': 'black_white'},\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n", "        data = response.json()\n\t        assert response.status_code == 400, response.text\n\t        assert data['detail'] == messages.MSC400_BAD_REQUEST\n\tdef test_transforme_image_not_found(client, session, user, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        # user = session.query(User).filter_by(email=user.get('email')).first()\n", "        # test_image = session.query(Image).filter_by(user_id=user.id).first()\n\t        response = client.post(\n\t            f'/api/images/transformation/9999',\n\t            params={'type': 'black_white'},\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 404, response.text\n\t        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND\n\tdef test_image_qrcode(client, session, user, user_token, image, monkeypatch):\n", "    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\t        response = client.get(\n\t            f'/api/images/qrcode/{test_image.id}',\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n", "        )\n\t        assert response.status_code == 200\n\t        assert response.headers['Content-Type'] == 'image/png'\n\t        assert type(response._content) is bytes\n\tdef test_image_qrcode_not_found(client, session, user, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n", "        # user = session.query(User).filter_by(email=user.get('email')).first()\n\t        # test_image = session.query(Image).filter_by(user_id=user.id).first()\n\t        response = client.get(\n\t            f'/api/images/qrcode/9999',\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 404, response.text\n\t        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND\n\tdef test_update_image(client, session, user, user_token, image, monkeypatch):\n", "    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\t        response = client.put(\n\t            f'/api/images/{test_image.id}',\n\t            json={'description': 'update description', 'tags': 'update_tag'},\n", "            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert type(data) == dict\n\t        assert data['description'] == 'update description'\n\t        assert data['tags'][0]['name'] == 'update_tag'\n\t        assert 'id' in data\n\tdef test_update_foreign_image_by_user(client, session, admin, user_token, image, monkeypatch):\n\t    # image.id = 1 user.id = 1 roles = admin\n", "    # image.id = 2 user.id = 2 roles = user\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        admin = session.query(User).filter_by(email=admin.get('email')).first()\n\t        test_image = session.query(Image).filter_by(user_id=admin.id).first()\n\t        response = client.put(\n\t            f'/api/images/{test_image.id}',\n", "            json={'description': 'update description', 'tags': 'update_tag'},\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 404, response.text\n\t        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND\n\tdef test_update_foreign_image_by_admin(client, session, user, admin_token, image, monkeypatch):\n\t    # image.id = 1 user.id = 1 roles = admin\n\t    # image.id = 2 user.id = 2 roles = user\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n", "        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\t        response = client.put(\n\t            f'/api/images/{test_image.id}',\n\t            json={'description': 'update description', 'tags': 'update_tag'},\n\t            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n", "        )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert type(data) == dict\n\t        assert data['description'] == 'update description'\n\t        assert data['tags'][0]['name'] == 'update_tag'\n\t        assert 'id' in data\n\tdef test_remove_image(client, session, user, user_token, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n", "        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        test_image = session.query(Image).filter_by(user_id=user.id).first()\n\t        response = client.delete(\n\t            f'/api/images/{test_image.id}',\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n", "        assert response.status_code == 200, response.text\n\t        assert data['message'] == messages.IMAGE_DELETED\n\t        assert session.query(Image).filter_by(id=test_image.id).first() is None\n\tdef test_remove_foreign_image_by_user(client, session, admin, user_token, image, monkeypatch):\n\t    # image.id = 1 user.id = 1 roles = admin\n\t    # image.id = 2 user.id = 2 roles = user\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n", "        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        admin = session.query(User).filter_by(email=admin.get('email')).first()\n\t        test_image = session.query(Image).filter_by(user_id=admin.id).first()\n\t        response = client.delete(\n\t            f'/api/images/{test_image.id}',\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 404, response.text\n\t        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND\n", "def test_remove_foreign_image_by_admin(client, session, user, admin_token, image, monkeypatch):\n\t    # image.id = 1 user.id = 1 roles = admin\n\t    # image.id = 2 user.id = 2 roles = user\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        test_image = session.query(Image).filter_by(user_id=user.id).first()\n", "        response = client.delete(\n\t            f'/api/images/{test_image.id}',\n\t            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert data['message'] == messages.IMAGE_DELETED\n\t        assert session.query(Image).filter_by(id=test_image.id).first() is None\n\tdef test_get_image_by_user_no_image(client, session, admin_token, user, image, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n", "        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        session.expunge(user)\n\t        images = session.query(Image).all()\n\t        response = client.get(\n\t            f'/api/images/search_byuser/{user.id}',\n\t            params={'sort_direction': 'asc'},\n", "            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 404, response.text\n\t        assert data['detail'] == messages.MSC404_IMAGE_NOT_FOUND\n"]}
{"filename": "tests/test_repository_users.py", "chunked_list": ["from datetime import datetime\n\tfrom fastapi import HTTPException\n\timport unittest\n\tfrom unittest.mock import MagicMock\n\tfrom pydantic import EmailStr\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import Role, User\n\tfrom src.repository.users import (\n\t                                  get_user_by_email,\n\t                                  get_user_by_id,\n", "                                  create_user,\n\t                                  change_password_for_user,\n\t                                  update_token,\n\t                                  confirmed_email,\n\t                                  update_avatar,\n\t                                  get_number_of_images_per_user,\n\t                                  update_user_profile,\n\t                                  update_your_profile,\n\t                                  ban_user,\n\t                                  )\n", "from src.schemas.users import UserBase, UserModel, UserType\n\tclass TestUsers(unittest.IsolatedAsyncioTestCase):\n\t    @classmethod\n\t    def setUpClass(cls):\n\t        \"\"\"Start before all test.\"\"\"\n\t        cls.password = 'new_passw0rd'\n\t        cls.email = 'Unknown2@mail.com'\n\t        cls.user_id = 3\n\t        cls.role = UserType(\n\t                            username='NewName',\n", "                            email=EmailStr('Unknown3@mail.com'),\n\t                            roles='moderator'\n\t                            )\n\t        cls.body_base = UserBase(\n\t                                 username='NewName', \n\t                                 email=EmailStr('NewEMail@mail.com')\n\t                                 )\n\t        cls.body_user_model = UserModel(\n\t                                        username='Unknown2', \n\t                                        email=EmailStr('Unknown2@mail.com'),\n", "                                        password='Qwerty@123',\n\t                                        )\n\t        cls.admin = User(\n\t                         id=1, \n\t                         username='Admin', \n\t                         email=EmailStr('Unknown1@mail.com'),\n\t                         password='Qwerty@123',\n\t                         created_at=datetime.now(),\n\t                         updated_at=datetime.now(),\n\t                         avatar='default',\n", "                         refresh_token='eyJhb...-iV1MI',\n\t                         roles=Role.admin,\n\t                         confirmed=True,\n\t                         status_active=True\n\t                         )\n\t        cls.user = User(\n\t                        id=2, \n\t                        username='User', \n\t                        email=EmailStr('Unknown2@mail.com'),\n\t                        password='Qwerty@123',\n", "                        created_at=datetime.now(),\n\t                        updated_at=datetime.now(),\n\t                        avatar='non-standard',\n\t                        refresh_token='ey.....37Ns5pX-iV1MI',\n\t                        roles=Role.user,\n\t                        confirmed=False,\n\t                        status_active=True\n\t                        )\n\t    # @classmethod\n\t    # def tearDownClass(cls):\n", "    #     \"\"\"Start after all test.\"\"\"\n\t    #     ...\n\t    def setUp(self):\n\t        \"\"\"Start before each test.\"\"\"\n\t        self.session = MagicMock(spec=Session)\n\t    # def tearDown(self):\n\t    #     \"\"\"Start after each test.\"\"\"\n\t    #     ...\n\t    async def test_get_user_by_email_found(self):\n\t        self.session.query().filter().first.return_value = TestUsers.user\n", "        result = await get_user_by_email(email=self.user.email, db=self.session)\n\t        self.assertIsInstance(result, User)\n\t        self.assertEqual(result, TestUsers.user)\n\t        [self.assertEqual(result.__dict__[el], TestUsers.user.__dict__[el])\n\t            for el in TestUsers.user.__dict__]\n\t    async def test_get_user_by_email_not_found(self):\n\t        self.session.query().filter().first.return_value = None\n\t        result = await get_user_by_email(email=self.email, db=self.session)  # self.email === TestUsers.email\n\t        self.assertIsNone(result)\n\t    async def test_get_user_by_id_found(self):\n", "        self.session.query().filter().first.return_value = TestUsers.user\n\t        result = await get_user_by_id(user_id=self.user.id, db=self.session)\n\t        self.assertIsInstance(result, User)\n\t        self.assertEqual(result, TestUsers.user)\n\t        [self.assertEqual(result.__dict__[el], TestUsers.user.__dict__[el])\n\t            for el in TestUsers.user.__dict__]\n\t    async def test_get_user_by_id_not_found(self):\n\t        self.session.query().filter().first.return_value = None\n\t        result = await get_user_by_id(user_id=self.user_id, db=self.session)\n\t        self.assertIsNone(result)\n", "    async def test_create_user_first_success(self):  # admin\n\t        self.session.query().first.return_value = None\n\t        result: User = await create_user(body=TestUsers.body_user_model, db=self.session)\n\t        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n\t        [self.assertEqual(result.__dict__[el], TestUsers.body_user_model.__dict__[el]) for el in TestUsers.body_user_model.__dict__]\n\t        self.assertEqual(result.roles, TestUsers.admin.roles)\n\t    async def test_create_user_success(self):  # user\n\t        self.session.query().first.return_value = TestUsers.admin\n\t        result: User = await create_user(body=TestUsers.body_user_model, db=self.session)\n\t        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n", "        [self.assertEqual(result.__dict__[el], TestUsers.body_user_model.__dict__[el]) for el in TestUsers.body_user_model.__dict__]\n\t        self.assertEqual(result.roles, TestUsers.user.roles)\n\t    async def test_create_user_fail(self):  # in auth-rout when signUp\n\t        return\n\t    async def test_change_password_for_user(self):\n\t        result: User = await change_password_for_user(user=TestUsers.user, password=self.password, db=self.session)\n\t        [self.assertTrue(hasattr(result, el)) for el in TestUsers.user.__dict__]\n\t        self.assertEqual(result.password, self.password)\n\t    async def test_update_token(self):\n\t        result: User = await update_token(user=TestUsers.user, token=self.admin.refresh_token, db=self.session)\n", "        self.assertEqual(self.user.refresh_token, self.admin.refresh_token)\n\t        self.assertIsNone(result)\n\t    async def test_confirmed_email(self):\n\t        self.assertEqual(self.user.confirmed, False)\n\t        result: User = await confirmed_email(user=TestUsers.user, db=self.session)\n\t        self.assertEqual(self.user.confirmed, True)\n\t        self.assertIsNone(result)\n\t    async def test_update_avatar_success(self):\n\t        self.session.query().filter().first.return_value = TestUsers.admin\n\t        result: User = await update_avatar(email=TestUsers.admin.email, url=TestUsers.user.avatar, db=self.session)\n", "        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n\t        self.assertEqual(TestUsers.admin.avatar, TestUsers.user.avatar)\n\t    async def test_update_avatar_fail(self):\n\t        self.session.query().filter().first.return_value = None\n\t        result = await update_avatar(email=self.email, url=TestUsers.user.avatar, db=self.session)\n\t        self.assertIsNone(result)\n\t    async def test_get_number_of_images_per_user(self):\n\t        self.session.query().filter().count.return_value = 0\n\t        result: User = await get_number_of_images_per_user(email=TestUsers.admin.email, db=self.session)\n\t        self.assertEqual(result, 0)\n", "        self.session.query().filter().count.return_value = 17\n\t        result: User = await get_number_of_images_per_user(email=TestUsers.admin.email, db=self.session)\n\t        self.assertEqual(result, 17)\n\t    async def test_update_user_profile_success(self):\n\t        self.session.query().filter().first.return_value = TestUsers.user\n\t        result: User = await update_user_profile(\n\t                                                 user_id=TestUsers.user.id, \n\t                                                 current_user=TestUsers.admin.__dict__,\n\t                                                 body_data=self.role,\n\t                                                 db=self.session\n", "                                                 )\n\t        [self.assertTrue(hasattr(result, el)) for el in TestUsers.user.__dict__]\n\t        self.assertEqual(result.roles, TestUsers.user.roles)\n\t        self.assertEqual(self.role.roles, TestUsers.user.roles.value)\n\t    async def test_update_user_profile_fails(self):\n\t        self.session.query().filter().first.return_value = None\n\t        result: None = await update_user_profile(\n\t                                                 user_id=TestUsers.user.id, \n\t                                                 current_user=TestUsers.admin.__dict__,\n\t                                                 body_data=self.role,\n", "                                                 db=self.session\n\t                                                 )\n\t        self.assertIsNone(result)\n\t        self.session.query().filter().first.return_value = TestUsers.user\n\t        result: User = await update_user_profile(\n\t                                                 user_id=TestUsers.user.id, \n\t                                                 current_user=TestUsers.admin.__dict__,\n\t                                                 body_data=None,\n\t                                                 db=self.session\n\t                                                 )\n", "        self.assertIsNone(result)\n\t        self.session.query().filter().first.return_value = TestUsers.user\n\t        result: User = await update_user_profile(\n\t                                                 user_id=TestUsers.user.id, \n\t                                                 current_user=TestUsers.user.__dict__,\n\t                                                 body_data=self.role,\n\t                                                 db=self.session\n\t                                                 )\n\t        self.assertIsNone(result)\n\t        self.session.query().filter().first.return_value = TestUsers.admin\n", "        result: User = await update_user_profile(\n\t                                                 user_id=TestUsers.admin.id, \n\t                                                 current_user=TestUsers.admin.__dict__,\n\t                                                 body_data=self.role,\n\t                                                 db=self.session\n\t                                                 )\n\t        self.assertIsNone(result)\n\t    async def test_update_your_profile_success(self):\n\t        self.session.query().filter().first.return_value = TestUsers.admin\n\t        result: User = await update_your_profile(\n", "                                                 email=TestUsers.admin.email, \n\t                                                 body_data=self.body_base, \n\t                                                 db=self.session\n\t                                                 )\n\t        [self.assertTrue(hasattr(result, el)) for el in TestUsers.admin.__dict__]\n\t        [self.assertEqual(result.__dict__[el], self.body_base.__dict__[el]) for el in self.body_base.__dict__]\n\t    async def test_update_your_profile_fail(self):\n\t        self.session.query().filter().first.return_value = None\n\t        result = await update_your_profile(email=TestUsers.admin.email, body_data=self.body_base, db=self.session)\n\t        self.assertIsNone(result)\n", "        self.session.query().filter().first.return_value = TestUsers.admin\n\t        result = await update_your_profile(email=TestUsers.admin.email, body_data=None, db=self.session)\n\t        self.assertIsNone(result)\n\t    async def test_ban_user_success(self):\n\t        self.assertEqual(self.user.status_active, True)\n\t        self.session.query().filter_by().first.return_value = TestUsers.user\n\t        result: User = await ban_user(user_id=TestUsers.user.id, active_status=False, db=self.session)\n\t        [self.assertTrue(hasattr(result, el)) for el in TestUsers.user.__dict__]\n\t        self.assertEqual(result.status_active, False)\n\t        self.assertEqual(self.user.status_active, False)\n", "    async def test_ban_user_fail(self):\n\t        self.session.query().filter_by().first.return_value = None\n\t        result = await ban_user(user_id=TestUsers.user_id, active_status=False, db=self.session)\n\t        self.assertIsNone(result)\n\t        self.session.query().filter_by().first.return_value = TestUsers.admin\n\t        with self.assertRaises(HTTPException) as context:\n\t            await ban_user(user_id=TestUsers.admin.id, active_status=False, db=self.session)\n\t        self.assertTrue(context.exception)\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "tests/test_route_users.py", "chunked_list": ["from fastapi import status\n\t# import pytest\n\t# from sqlalchemy import select\n\tfrom src.conf import messages\n\tfrom src.schemas.users import UserDb, UserResponseFull\n\tdef test_read_users_me(client, access_token):\n\t    response = client.get('api/users/me/')\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\t    headers = {'Authorization': f'Bearer {access_token}'}\n\t    response = client.get('api/users/me/', headers=headers)\n", "    assert response.status_code == status.HTTP_200_OK\n\t    data = response.json()\n\t    expected_response: dict = UserDb.__fields__\n\t    for field in expected_response:\n\t        assert field in data\n\tdef test_read_user_by_id(client, access_token):\n\t    response = client.get('api/users/1/')\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\t    headers = {'Authorization': f'Bearer {access_token}'}\n\t    response = client.get('api/users/1000/', headers=headers)\n", "    assert response.status_code == status.HTTP_404_NOT_FOUND\n\t    assert 'detail' in response.json()\n\t    assert response.json()['detail'] == messages.MSC404_USER_NOT_FOUND\n\t    response = client.get('api/users/1/', headers=headers)\n\t    assert response.status_code == status.HTTP_200_OK\n\t    data = response.json()\n\t    expected_response: dict = UserResponseFull.__fields__\n\t    for field in expected_response:\n\t        assert field in data\n\tdef test_update_user_profile(client, admin, access_token, user, access_token_user):  # ! need\n", "    response = client.put('api/users/1/', json=admin)\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\t    headers = {'Authorization': f'Bearer {access_token}'}\n\t    response = client.put('api/users/9/', headers=headers, json=admin)\n\t    assert 'detail' in response.json()\n\t    assert response.json()['detail'] == messages.MSC404_USER_NOT_FOUND \n\t    response = client.put('api/users/1/', headers=headers, json=admin)\n\t    assert 'detail' in response.json()\n\t    assert response.json()['detail'] == messages.MSC404_USER_NOT_FOUND \n\t    response = client.put('api/users/2/', headers=headers, json=user)\n", "    assert response.status_code == status.HTTP_200_OK\n\t    data = response.json()\n\t    expected_response: dict = UserDb.__fields__\n\t    for field in expected_response:\n\t        assert field in data\n\tdef test_update_your_profile(client, admin, access_token, user, access_token_user):  # ! need\n\t    response = client.put('api/users/me/1/', json=admin)\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\t    headers = {'Authorization': f'Bearer {access_token}'}\n\t    response = client.put('api/users/me/1/', headers=headers)\n", "    assert 'detail' in response.json()\n\t    assert response.json()['detail'] == messages.MSC404_USER_NOT_FOUND \n\t    response = client.put('api/users/me/1/', headers=headers, json=admin)\n\t    assert response.status_code == status.HTTP_200_OK\n\t    data = response.json()\n\t    expected_response: dict = UserDb.__fields__\n\t    for field in expected_response:\n\t        assert field in data\n\tdef test_update_avatar_user(client, admin, access_token, mocker):\n\t    mock_avatar = 'https://pypi.org/static/images/logo-small.2a411bc6.svg'\n", "    mocker.patch('src.routes.users.CloudImage.avatar_upload', return_value=mock_avatar)\n\t    files = {'file': 'avatar_1.svg'}\n\t    response = client.patch('api/users/avatar', files=files)\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\t    headers = {'Authorization': f'Bearer {access_token}'}\n\t    response = client.patch('api/users/avatar', headers=headers, files=files)\n\t    assert response.status_code == status.HTTP_200_OK\n\t    data = response.json()\n\t    expected_response: dict = UserDb.__fields__\n\t    for field in expected_response:\n", "        assert field in data\n\t    assert response.json()['email'] == admin['email']\n\t    assert response.json()['avatar'] == mock_avatar\n\tdef test_ban_user(client, access_token, admin, access_token_user):\n\t    response = client.patch('api/users/ban_user/1/true')\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\t    headers = {'Authorization': f'Bearer {access_token}'}\n\t    response = client.patch('api/users/ban_user/999/true', headers=headers)\n\t    assert 'detail' in response.json()\n\t    assert response.json()['detail'] == messages.MSC404_USER_NOT_FOUND \n", "    response = client.patch('api/users/ban_user/1/true', headers=headers)\n\t    assert 'detail' in response.json()\n\t    assert response.json()['detail'] == messages.MSC403_USER_BANNED \n\t    response = client.patch('api/users/ban_user/2/false', headers=headers)\n\t    assert response.status_code == status.HTTP_200_OK\n\t    data = response.json()\n\t    expected_response: dict = UserDb.__fields__\n\t    for field in expected_response:\n\t        assert field in data\n"]}
{"filename": "tests/test_route_auth.py", "chunked_list": ["import asyncio\n\tfrom unittest.mock import MagicMock, AsyncMock\n\tfrom fastapi import status\n\tfrom src.conf import messages as m\n\tfrom src.database.models import User\n\tfrom src.schemas.users import UserResponse\n\tfrom src.services.auth import AuthToken\n\tmock_send_email = MagicMock()\n\tmock_send_reset_password = AsyncMock()\n\tdef test_signup_ok(client, user, monkeypatch):\n", "    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)  \n\t    response = client.post('api/auth/signup', json=user)\n\t    assert response.status_code == 201, response.text\n\t    data = response.json()\n\t    expected_response: dict = UserResponse.__fields__\n\t    for field in expected_response:\n\t        assert field in data\n\t    assert data['email'] == user.get('email')\n\t    assert data['detail'] == m.MSC201_USER_CREATED\n\tdef test_signup_fail(client, user): \n", "    response = client.post('api/auth/signup', json=user)\n\t    assert response.status_code == status.HTTP_409_CONFLICT\n\t    assert response.json()['detail'] == m.MSC409_CONFLICT\n\tdef test_login_ok(client, session, user):\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = True\n\t    session.commit()\n\t    response = client.post('api/auth/login', data={'username': user.get('email'), 'password': user.get('password')})\n\t    data = response.json()\n\t    assert response.status_code == status.HTTP_200_OK\n", "    assert data['token_type'] == m.TOKEN_TYPE\n\tdef test_logout(client, access_token):\n\t    headers = {'Authorization': f'Bearer {access_token}'}\n\t    response = client.get('api/auth/logout', headers=headers)\n\t    assert response.status_code == status.HTTP_205_RESET_CONTENT\n\tdef test_login_fail(client, session, user):  # split into several?\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = False\n\t    session.commit()\n\t    response1 = client.post('api/auth/login', data={'username': 'NonExistUser', 'password': user.get('password')})\n", "    assert response1.status_code == status.HTTP_401_UNAUTHORIZED\n\t    assert response1.json()['detail'] == m.MSC401_EMAIL\n\t    response2 = client.post('api/auth/login', data={'username': user.get('email'), 'password': user.get('password')})\n\t    assert response2.status_code == status.HTTP_401_UNAUTHORIZED\n\t    assert response2.json()['detail'] == m.MSC401_EMAIL_UNKNOWN\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = True\n\t    session.commit()\n\t    response3 = client.post('api/auth/login', data={'username': user.get('email'), 'password': '54327'})\n\t    assert response3.status_code == status.HTTP_401_UNAUTHORIZED\n", "    assert response3.json()['detail'] == m.MSC401_PASSWORD\n\tdef test_refresh_token_ok(client, session, user):\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    headers = {'Authorization': f'Bearer {current_user.refresh_token}'}\n\t    response = client.get('api/auth/refresh_token', headers=headers)\n\t    assert response.status_code == status.HTTP_200_OK\n\t    assert response.json()['token_type'] == m.TOKEN_TYPE\n\t    assert response.json()['access_token'] is not None\n\t    assert response.json()['refresh_token'] is not None\n\tdef test_refresh_token_fail(client, user, monkeypatch):\n", "    mock_async_logging_to_file = AsyncMock()\n\t    monkeypatch.setattr('src.services.asyncdevlogging.async_logging_to_file', mock_async_logging_to_file) \n\t    headers = {'Authorization': f'Bearer NOTOKEN'}\n\t    response = client.get('api/auth/refresh_token', headers=headers)\n\t    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\t    assert response.json()['detail'] == m.MSC422_INVALID_TOKEN  \n\t    untrue_refresh_token = asyncio.run(\n\t                                       AuthToken.create_token(data={'sub': user['email']}, expires_delta=1, token_type='refresh_token')\n\t                                       )\n\t    headers = {'Authorization': f'Bearer {untrue_refresh_token}'}\n", "    response = client.get('api/auth/refresh_token', headers=headers)\n\t    assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\t    assert response.json()['detail'] == m.MSC401_TOKEN\n\tdef test_request_confirm_email_ok(client, session, user):\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = True\n\t    session.commit()\n\t    response = client.post('api/auth/request_confirm_email', json={'email': user.get('email')})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    assert response.json()['message'] == m.EMAIL_ERROR_CONFIRMED\n", "def test_request_confirm_email_check(client, session, user, monkeypatch):  # , monkeypatch is redundant ?\n\t    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = False\n\t    session.commit()\n\t    response = client.post('api/auth/request_confirm_email', json={'email': user.get('email')})\n\t    assert response.status_code == status.HTTP_200_OK\n\t    assert response.json()['message'] == m.EMAIL_INFO_CONFIRMED\n\t    response2 = client.post('api/auth/request_confirm_email', json={'email': 'Email@notSignUp.user'})\n\t    assert response2.status_code == status.HTTP_200_OK\n", "    assert response2.json()['message'] == m.EMAIL_INFO_CONFIRMED\n\tdef test_confirmed_email_ok(client, session, user):\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = False\n\t    session.commit()\n\t    email_token = asyncio.run(\n\t                              AuthToken.create_token(data={\n\t                                                          'sub': user['email'],\n\t                                                          'email': user['email'],\n\t                                                          'username': user['username'],\n", "                                                          }, \n\t                                                     expires_delta=10, \n\t                                                     token_type='email_token')\n\t                              )\n\t    response = client.get(f'api/auth/confirmed_email/{email_token}')\n\t    assert response.status_code == status.HTTP_200_OK\n\t    assert response.json()['message'] == m.EMAIL_INFO_CONFIRM\n\tdef test_confirmed_email_fail(client, session, user):  # split into several?\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = True\n", "    session.commit()\n\t    email_token = asyncio.run(\n\t                              AuthToken.create_token(data={\n\t                                                          'sub': user['email'],\n\t                                                          'email': user['email'],\n\t                                                          'username': user['username'],\n\t                                                          }, \n\t                                                     expires_delta=10, \n\t                                                     token_type='email_token')\n\t                              )\n", "    response = client.get(f'api/auth/confirmed_email/{email_token}')\n\t    assert response.status_code == status.HTTP_200_OK\n\t    assert response.json()['message'] == m.EMAIL_ERROR_CONFIRMED\n\t    email_token = asyncio.run(\n\t                              AuthToken.create_token(data={\n\t                                                          'sub': 'NonRegistered@unknown.email',\n\t                                                          'email': '-',\n\t                                                          'username': '-',\n\t                                                          }, \n\t                                                     expires_delta=10, \n", "                                                     token_type='email_token')\n\t                              )\n\t    response = client.get(f'api/auth/confirmed_email/{email_token}')\n\t    assert response.status_code == status.HTTP_400_BAD_REQUEST\n\t    assert response.json()['detail'] == m.MSC400_BAD_REQUEST\n\tdef test_reset_password_ok(client, session, user, monkeypatch):\n\t    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)\n\t    monkeypatch.setattr('src.routes.auth.send_reset_password', mock_send_reset_password)\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = True\n", "    session.commit()\n\t    response = client.post('api/auth/reset-password', json={'email': user.get('email')})  \n\t    assert response.status_code == status.HTTP_200_OK\n\t    assert response.json()['message'] == m.MSG_SENT_PASSWORD\n\tdef test_reset_password_check(client, session, user):  # split into several?\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = False\n\t    session.commit()\n\t    response = client.post('api/auth/reset-password', json={'email': user.get('email')})\n\t    assert response.status_code == status.HTTP_200_OK\n", "    assert response.json()['message'] == m.EMAIL_INFO_CONFIRMED\n\t    response2 = client.post('api/auth/reset-password', json={'email': 'Non_exist@email.com'})\n\t    assert response2.status_code == status.HTTP_200_OK\n\t    assert response2.json()['message'] == m.MSC401_EMAIL_UNKNOWN\n\tdef test_reset_password_done(client):\n\t    response = client.get('api/auth/reset-password/done_request')\n\t    assert response.status_code == status.HTTP_200_OK\n\t    assert response.template.name == 'password_reset_done.html'\n\t    assert 'request' in response.context\n\t    assert 'title' in response.context\n", "    assert response.context['title'] == m.MSG_SENT_PASSWORD\n\tdef test_reset_password_confirm_ok(client, session, user, monkeypatch):\n\t    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)\n\t    monkeypatch.setattr('src.routes.auth.send_new_password', mock_send_reset_password) \n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = True\n\t    session.commit()\n\t    user.update(password='new_secret')\n\t    password_reset_token = asyncio.run(\n\t                                        AuthToken.create_token(data={\n", "                                                                    'sub': user['email'],\n\t                                                                    # 'email': user['email'],\n\t                                                                    'username': user['username'],\n\t                                                                    }, \n\t                                                                expires_delta=30, \n\t                                                                token_type='password_reset_token')\n\t                                        )\n\t    response = client.post(f'api/auth/reset-password/confirm/{password_reset_token}', json={'password': user['password']})  # , json={'password': user['password']}\n\t    assert response.status_code == status.HTTP_200_OK\n\t    assert 'user' in response.json()  # response.content  # context\n", "    assert response.json()['detail'] == m.MSG_PASSWORD_CHENGED\n\tdef test_reset_password_confirm_fail(client, session, user, monkeypatch):\n\t    current_user: User = session.query(User).filter(User.email == user.get('email')).first()\n\t    current_user.confirmed = False  # True\n\t    session.commit()\n\t    password_reset_token = asyncio.run(\n\t                                        AuthToken.create_token(data={\n\t                                                                    'sub': 'Non_exist@user.mail',\n\t                                                                    # 'email': user['email'],\n\t                                                                    'username': user['username'],\n", "                                                                    }, \n\t                                                                expires_delta=30, \n\t                                                                token_type='password_reset_token')\n\t                                        )\n\t    response = client.post(f'api/auth/reset-password/confirm/{password_reset_token}')  # , json={'password': 'new_secret'}  data=   json=\n\t    assert response.status_code == status.HTTP_503_SERVICE_UNAVAILABLE\n\t    assert response.json()['detail'] == m.MSC503_UNKNOWN_USER\n\tdef test_reset_password_complete_ok(client):\n\t    response = client.get('api/auth/reset-password/complete')\n\t    assert response.status_code == status.HTTP_200_OK\n", "    assert response.template.name == 'password_reset_complete.html'\n\t    assert 'request' in response.context\n\t    assert 'title' in response.context\n\t    assert response.context['title'] == m.MSG_PASSWORD_RESET\n"]}
{"filename": "tests/test_root.py", "chunked_list": ["from fastapi.testclient import TestClient\n\t# import pytest\n\timport main\n\tclient = TestClient(main.app)\n\tdef test_root():\n\t    response = client.get('/')\n\t    assert response.status_code == 200\n\t    assert response.json() == {'message': 'Welcome to Photo-Share by Fast Rabbit Team.'}\n\tdef test_healthchecker():\n\t    response = client.get('/api/healthchecker')\n", "    assert response.status_code == 200\n\t    assert response.json() == {'message': 'Welcome to FastAPI!'}\n"]}
{"filename": "tests/test_unit_repository_comments.py", "chunked_list": ["import unittest\n\tfrom unittest.mock import MagicMock\n\tfrom sqlalchemy.orm import Session\n\tfrom src.conf import messages\n\tfrom src.database.models import Comment, Image\n\tfrom src.schemas.images import CommentModel\n\tfrom src.repository.comments import (\n\t    add_comment,\n\t    update_comment,\n\t    remove_comment,\n", "    get_comments\n\t)\n\tclass TestComments(unittest.IsolatedAsyncioTestCase):\n\t    def setUp(self):\n\t        self.session = MagicMock(spec=Session)\n\t        self.image = Image(id=1)\n\t        self.user = {'id': 1, 'roles': 'user'}\n\t    async def test_get_comments(self):\n\t        comments = [Comment(), Comment()]\n\t        self.session.query.return_value.filter_by.return_value.all.return_value = comments\n", "        result = await get_comments(image_id=self.image.id, db=self.session)\n\t        self.assertEqual(result, comments)\n\t        self.session.query.assert_called_once_with(Comment)\n\t        self.session.query.return_value.filter_by.assert_called_once_with(image_id=self.image.id)\n\t        self.session.query.return_value.filter_by.return_value.all.assert_called_once()\n\t    async def test_add_comment(self):\n\t        comment = CommentModel(comment='Test comment')\n\t        result = await add_comment(body=comment, image_id=1, user=self.user, db=self.session)\n\t        self.assertTrue(hasattr(result, 'id'))\n\t        self.assertEqual(result.comment, comment.comment)\n", "        self.assertEqual(result.user_id, self.user['id'])\n\t    async def test_remove_contact(self):\n\t        comment = Comment()\n\t        self.session.query.return_value.filter_by.return_value.first.return_value = comment\n\t        result = await remove_comment(comment_id=comment.id, user=self.user, db=self.session)\n\t        self.assertEqual(result['message'], messages.COMMENT_DELETED)\n\t        self.session.query.assert_called_once_with(Comment)\n\t        self.session.query.return_value.filter_by.assert_called_once_with(id=comment.id)\n\t        self.session.delete.assert_called_once_with(comment)\n\t        self.session.commit.assert_called_once()\n", "    async def test_update_comment(self):\n\t        comment_id = 1\n\t        body = CommentModel(comment='Updated comment')\n\t        expected_comment = Comment(comment=body.comment, user_id=self.user['id'], image_id=None)\n\t        self.session.query.return_value.filter_by.return_value.first.return_value = expected_comment\n\t        self.session.commit.return_value = None\n\t        self.session.refresh.return_value = None\n\t        comment = await update_comment(comment_id, body, self.user, self.session)\n\t        self.assertEqual(comment, expected_comment)\n\t        self.session.query.assert_called_once_with(Comment)\n", "        self.session.query.return_value.filter_by.assert_called_once_with(id=comment_id, user_id=self.user['id'])\n\t        self.session.commit.assert_called_once()\n\t        self.session.refresh.assert_called_once_with(expected_comment)\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["from unittest.mock import MagicMock\n\timport pytest\n\tfrom fastapi.testclient import TestClient\n\tfrom sqlalchemy import create_engine, select\n\tfrom sqlalchemy.orm import sessionmaker\n\tfrom main import app\n\tfrom src.database.models import Base, Role, User\n\tfrom src.database.db import get_db\n\tSQLALCHEMY_DATABASE_URL = 'sqlite:///./test.db'\n\tengine = create_engine(\n", "                       SQLALCHEMY_DATABASE_URL, \n\t                       connect_args={'check_same_thread': False}\n\t                      )\n\tTestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\t@pytest.fixture(scope='module')\n\tdef session():\n\t    # Create the database\n\t    Base.metadata.drop_all(bind=engine)\n\t    Base.metadata.create_all(bind=engine)\n\t    db = TestingSessionLocal()\n", "    try:\n\t        yield db\n\t    finally:\n\t        db.close()\n\t@pytest.fixture(scope='module')\n\tdef client(session):\n\t    def override_get_db():\n\t        try:\n\t            yield session\n\t        finally:\n", "            session.close()\n\t    app.dependency_overrides[get_db] = override_get_db\n\t    yield TestClient(app)\n\t@pytest.fixture(scope='module')\n\tdef admin():\n\t    return {\n\t            'id': 1,\n\t            'username': 'admin', \n\t            'email': 'example@example.com', \n\t            'password': 'Qwerty@1',\n", "            'roles': 'admin',\n\t            'status_active': 'true',\n\t            }\n\t@pytest.fixture(scope='module')\n\tdef user():\n\t    return {\n\t            'id': 2,\n\t            'username': 'user',\n\t            'email': 'example2@example.com',\n\t            'password': 'Qwerty@1',\n", "            'roles': 'user',\n\t            'status_active': 'true',\n\t            }\n\t@pytest.fixture(scope='module')\n\tdef comment():\n\t    return {'comment': 'Test comment', 'image_id': '1'}\n\t@pytest.fixture(scope='module')\n\tdef image():\n\t    return {'description': 'Test image', 'tags': 'test tag'}\n\t@pytest.fixture\n", "def admin_token(client, admin, session, monkeypatch):\n\t    mock_send_email = MagicMock()\n\t    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)\n\t    client.post('/api/auth/signup', json=admin)\n\t    current_user: User = session.query(User).filter_by(email=admin.get('email')).first()\n\t    current_user.id = 1\n\t    current_user.confirmed = True\n\t    current_user.roles = Role.admin\n\t    session.commit()\n\t    response = client.post(\n", "        '/api/auth/login',\n\t        data={'username': admin.get('email'), 'password': admin.get('password')},\n\t    )\n\t    data = response.json()\n\t    # return data['access_token']\n\t    return {'access_token': data['access_token'], 'refresh_token': data['refresh_token'], 'token_type': 'bearer'}\n\t@pytest.fixture\n\tdef user_token(client, user, session, monkeypatch):\n\t    mock_send_email = MagicMock()\n\t    monkeypatch.setattr('src.routes.auth.send_email', mock_send_email)\n", "    client.post('/api/auth/signup', json=user)\n\t    current_user: User = session.query(User).filter_by(email=user.get('email')).first()\n\t    current_user.id = 2\n\t    current_user.confirmed = True\n\t    current_user.roles = Role.user\n\t    session.commit()\n\t    response = client.post(\n\t        '/api/auth/login',\n\t        data={'username': user.get('email'), 'password': user.get('password')},\n\t    )\n", "    data = response.json()\n\t    # return data['access_token']\n\t    return {'access_token': data['access_token'], 'refresh_token': data['refresh_token'], 'token_type': 'bearer'}\n\t@pytest.fixture(scope='function')\n\tdef access_token(client, admin, session, mocker) -> str:\n\t    mocker.patch('src.routes.auth.send_email')  # mocker\n\t    client.post('/api/auth/signup', json=admin)\n\t    current_user: User = session.scalar(select(User).filter(User.email == admin['email']))\n\t    current_user.confirmed = True\n\t    session.commit()\n", "    response = client.post(\n\t                           '/api/auth/login',\n\t                           data={'username': admin.get('email'), 'password': admin.get('password')},\n\t                           )\n\t    return response.json()['access_token']\n\t@pytest.fixture(scope='function')\n\tdef access_token_user(client, user, session, mocker) -> str:\n\t    mocker.patch('src.routes.auth.send_email')  # mocker\n\t    client.post('/api/auth/signup', json=user)\n\t    current_user: User = session.scalar(select(User).filter(User.email == user['email']))\n", "    current_user.confirmed = True\n\t    session.commit()\n\t    response = client.post(\n\t                           '/api/auth/login',\n\t                           data={'username': user.get('email'), 'password': user.get('password')},\n\t                           )\n\t    return response.json()['access_token']"]}
{"filename": "tests/test_routes_comments.py", "chunked_list": ["from unittest.mock import patch, AsyncMock\n\tfrom src.conf import messages\n\tfrom src.services.auth import AuthUser\n\tfrom src.database.models import User, Comment\n\t'''\n\tIntegration tests for the application.\n\t'''\n\t'''\n\tTest src.routes.comments\n\t1. test_add_comment\n", "2. test_get_comments_by_image_id\n\t3. test_update_comment\n\t4. test_remove_comment\n\t'''\n\tdef test_add_comment(client, session, user_token, user, comment, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n", "        mock_image = AsyncMock()\n\t        monkeypatch.setattr('src.repository.images.get_image', mock_image)\n\t        response = client.post(\n\t            f'''/api/comment/{comment['image_id']}''',\n\t            json={'comment': 'Test comment'},\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert type(data) == dict\n", "        assert data['comment'] == comment['comment']\n\tdef test_get_comments_by_image_id(client, session, user_token, user, comment, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        mock_image = AsyncMock()\n\t        monkeypatch.setattr('src.repository.images.get_image', mock_image)\n\t        response = client.get(\n", "            f'''/api/comment/{comment['image_id']}''',\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert type(data) == list\n\t        assert data[0]['comment'] == comment['comment']\n\tdef test_update_comment(client, session, user_token, user, comment, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n", "        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        test_comment = session.query(Comment).filter_by(user_id=user.id).first()\n\t        response = client.put(\n\t            '/api/comment/1',\n\t            json={'comment': 'New comment'},\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n", "        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert type(data) == dict\n\t        assert data['comment'] == 'New comment'\n\t        assert test_comment.comment == 'New comment'\n\t#\n\tdef test_remove_comment_by_user(client, session, user_token, user, comment, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n", "        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        test_comment = session.query(Comment).filter_by(user_id=user.id).first()\n\t        response = client.delete(\n\t            f'/api/comment/{test_comment.id}',\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 403, response.text\n", "        assert data['detail'] == messages.MSC403_FORBIDDEN\n\tdef test_remove_comment_by_admin(client, session, admin_token, user, comment, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        user = session.query(User).filter_by(email=user.get('email')).first()\n\t        test_comment = session.query(Comment).filter_by(user_id=user.id).first()\n\t        response = client.delete(\n", "            f'/api/comment/{test_comment.id}',\n\t            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n\t        )\n\t        data = response.json()\n\t        assert response.status_code == 200, response.text\n\t        assert data['message'] == messages.COMMENT_DELETED\n\t        try_find = session.query(Comment).filter_by(id=test_comment.id).first()\n\t        assert try_find == None\n\tdef test_update_comment_not_found(client, session, user_token, user, comment, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n", "        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        # user = session.query(User).fiomment).filter_by(user_id=comment['user_id']).first()\n\t        response = client.put(\n\t            '/api/comment/999',\n\t            json={'comment': 'New comment'},\n\t            headers={'Authorization': f'''Bearer {user_token['access_token']}'''}\n\t        )\n", "        data = response.json()\n\t        assert response.status_code == 404, response.text\n\t#\n\tdef test_remove_comment_not_found(client, session, admin_token, user, comment, monkeypatch):\n\t    with patch.object(AuthUser, 'redis_client') as redis_mock:\n\t        redis_mock.get.return_value = None\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.redis', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.identifier', AsyncMock())\n\t        monkeypatch.setattr('fastapi_limiter.FastAPILimiter.http_callback', AsyncMock())\n\t        response = client.delete(\n", "            '/api/comment/9999',\n\t            headers={'Authorization': f'''Bearer {admin_token['access_token']}'''}\n\t        )\n\t        assert response.status_code == 404, response.text\n"]}
{"filename": "docs/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t#\n\t# For the full list of built-in configuration values, see the documentation:\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\t# -- Project information -----------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\timport os\n\timport sys\n\tsys.path.append(os.path.abspath('..'))\n\tproject = 'frt-photo-share'\n", "copyright = '2023, FRT'\n\tauthor = 'FRT'\n\trelease = '0.0.0.1'\n\t# -- General configuration ---------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\textensions = ['sphinx.ext.autodoc']\n\ttemplates_path = ['_templates']\n\texclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n\t# -- Options for HTML output -------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n", "html_theme = 'nature'\n\thtml_static_path = ['_static']\n"]}
{"filename": "src/repository/images.py", "chunked_list": ["from typing import Optional\n\tfrom fastapi import HTTPException, status\n\tfrom fastapi_pagination import Page, Params\n\tfrom fastapi_pagination.ext.sqlalchemy import paginate\n\tfrom sqlalchemy import asc, desc\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import Image, image_m2m_tag\n\tfrom src.schemas.images import ImageModel\n\tfrom src.conf import messages\n\tfrom src.repository import tags as repository_tags\n", "async def get_images(\n\t                     user: dict,\n\t                     db: Session,\n\t                     pagination_params: Params\n\t                     ) -> Page:\n\t    \"\"\"\n\t    The get_images function returns a list of images.\n\t    :param user: dict: Pass the user's information to the function\n\t    :param db: Session: Access the database\n\t    :param pagination_params: Params: Pass in the pagination parameters\n", "    :return: A page object that contains the results of a paginated query\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    return paginate(\n\t                    query=db.query(Image).order_by(Image.user_id),\n\t                    params=pagination_params\n\t                    )\n\tasync def get_image(\n\t                    image_id: int, \n\t                    user: dict,\n", "                    db: Session\n\t                    ) -> Optional[Image]:\n\t    \"\"\"\n\t    The get_image function returns an image object from the database.\n\t    Args:\n\t    image_id (int): The id of the desired image.\n\t    user (dict): A dictionary containing a user's credentials and permissions.\n\t    This is used to determine if a user has permission to view this particular\n\t    resource, as well as for logging purposes.\n\t    :param image_id: int: Specify the id of the image that we want to get\n", "    :param user: dict: Pass the user information to the function\n\t    :param db: Session: Pass the database session to the function\n\t    :return: An image object\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    return (\n\t            db.query(Image)\n\t            .filter_by(id=image_id)\n\t            .first()\n\t            )\n", "async def create_image(\n\t                       body: dict,\n\t                       user_id: int,\n\t                       db: Session,\n\t                       tags_limit: int\n\t                       ) -> Image | Exception:\n\t    \"\"\"\n\t    The create_image function creates a new image in the database.\n\t    Args:\n\t    body (dict): The request body containing the image's description, link and tags.\n", "    user_id (int): The id of the user who created this image.\n\t    :param body: dict: Get the data from the request body\n\t    :param user_id: int: Get the user_id from the token\n\t    :param db: Session: Access the database\n\t    :param tags_limit: int: Limit the number of tags that can be added to an image\n\t    :return: The image created\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    tags_names = body['tags'].split()\n\t    if len(tags_names) > tags_limit:\n", "        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=messages.MSC409_TAGS)\n\t    tags = []\n\t    for el in tags_names:\n\t        tag = await repository_tags.get_tag_by_name(el, db)\n\t        if tag is None:\n\t            tag = await repository_tags.create_tag(el, db)\n\t        tags.append(tag)\n\t    try:\n\t        image = Image(description=body['description'], link=body['link'], user_id=user_id, tags=tags)\n\t    except Exception as er:\n", "        return er\n\t    db.add(image)\n\t    db.commit()\n\t    db.refresh(image)\n\t    return image\n\tasync def transform_image(\n\t                          body: dict,\n\t                          user_id: int,\n\t                          db: Session\n\t                          ) -> Image:\n", "    \"\"\"\n\t    The transform_image function takes in a dictionary of image data, the user_id of the user who created it, and a database session.\n\t    It then creates an Image object from that data and adds it to the database. It returns either an error or the newly created Image.\n\t    :param body: dict: Pass the data from the request body\n\t    :param user_id: int: Get the user id from the token\n\t    :param db: Session: Access the database\n\t    :return: A new image object\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    try:\n", "        image = Image(\n\t                      description=body['description'],\n\t                      link=body['link'],\n\t                      user_id=user_id,\n\t                      type=body['type'],\n\t                      tags=body['tags']\n\t                      )\n\t    except Exception as er:\n\t        return er\n\t    db.add(image)\n", "    db.commit()\n\t    db.refresh(image)\n\t    return image\n\tasync def remove_image(\n\t                       image_id: int,\n\t                       user: dict,\n\t                       db: Session\n\t                       ) -> dict:\n\t    \"\"\"\n\t    The remove_image function removes an image from the database.\n", "    :param image_id: int: Specify the image to be deleted\n\t    :param user: dict: Check if the user is an admin or moderator\n\t    :param db: Session: Access the database\n\t    :return: A message to the user\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    if user['roles'].value in ['admin', 'moderator']:\n\t        image: Image = db.query(Image).filter_by(id=image_id).first()\n\t    else:\n\t        image: Image = db.query(Image).filter_by(id=image_id, user_id=user['id']).first()\n", "    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\t    else:\n\t        db.delete(image)\n\t        db.commit()\n\t    return {'message': messages.IMAGE_DELETED}\n\tasync def update_image(\n\t                       image_id: int,\n\t                       body: ImageModel,\n\t                       user: dict,\n", "                       db: Session,\n\t                       tags_limit: int\n\t                       ) -> Optional[Image]:\n\t    \"\"\"\n\t    The update_image function updates an image in the database.\n\t    :param image_id: int: Get the image by id\n\t    :param body: ImageModel: Pass the image model to the function\n\t    :param user: dict: Check if the user is an admin or a moderator\n\t    :param db: Session: Pass the database session to the function\n\t    :param tags_limit: int: Limit the number of tags that can be added to an image\n", "    :return: The updated image\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    if user['roles'].value in ['admin', 'moderator']:\n\t        image: Image = db.query(Image).filter_by(id=image_id).first()\n\t    else:\n\t        image: Image = db.query(Image).filter_by(id=image_id, user_id=user['id']).first()\n\t    if not image or not body.description:\n\t        return None\n\t    image.description = body.description\n", "    tags_names = body.tags.split()[:tags_limit]\n\t    tags = []\n\t    for el in tags_names:\n\t        tag = await repository_tags.get_tag_by_name(el, db)\n\t        if tag is None:\n\t            tag = await repository_tags.create_tag(el, db)\n\t        tags.append(tag)\n\t    image.tags = tags\n\t    db.add(image)\n\t    db.commit()\n", "    db.refresh(image)\n\t    return image\n\tasync def get_images_by_tag(tag, sort_direction, db):\n\t    \"\"\"\n\t    The get_images_by_tag function takes in a tag and a sort direction, and returns all images associated with that tag.\n\t    The function first queries the image_m2m_tag table to find all rows where the tag id matches the inputted tags id.\n\t    It then creates an array of image ids from those rows, which it uses to query for images in the Image table. It then sorts these images by creation date based on whether or not they were sorted ascendingly or descendingly.\n\t    :param tag: Filter the images by tag\n\t    :param sort_direction: Determine whether the images should be sorted in ascending or descending order\n\t    :param db: Pass the database session to the function\n", "    :return: A list of images that have a specific tag\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    image_tag = db.query(image_m2m_tag).filter_by(tag_id=tag.id).all()\n\t    images_id = [el[1] for el in image_tag]\n\t    if sort_direction.value == 'desc':\n\t        images = db.query(Image).filter(Image.id.in_((images_id))).order_by(desc(Image.created_at)).all()\n\t    else:\n\t        images = db.query(Image).filter(Image.id.in_((images_id))).order_by(asc(Image.created_at)).all()\n\t    return images\n", "async def get_images_by_user(user_id, sort_direction, db):\n\t    \"\"\"\n\t    The get_images_by_user function returns a list of images that are associated with the user_id passed in.\n\t    The sort_direction parameter is an enum value that can be either 'asc' or 'desc'. The db parameter is a database session object.\n\t    :param user_id: Filter the images by user_id\n\t    :param sort_direction: Determine the order in which images are returned\n\t    :param db: Pass in the database session object\n\t    :return: A list of image objects\n\t    :doc-author: Trelent\n\t    \"\"\"\n", "    if sort_direction.value == 'desc':\n\t        images = db.query(Image).filter_by(user_id=user_id).order_by(desc(Image.created_at)).all()\n\t    else:\n\t        images = db.query(Image).filter_by(user_id=user_id).order_by(asc(Image.created_at)).all()\n\t    return images\n"]}
{"filename": "src/repository/ratings.py", "chunked_list": ["from typing import Optional, List\n\tfrom fastapi import HTTPException, status\n\tfrom sqlalchemy.orm import Session\n\tfrom sqlalchemy import func\n\tfrom src.conf import messages\n\tfrom src.database.models import Rating, Image, User\n\tfrom src.schemas.images import RatingModel\n\tasync def add_rating(\n\t                     body: RatingModel,\n\t                     image_id: int,\n", "                     user: dict,\n\t                     db: Session\n\t                     ) -> Rating:\n\t    rating = Rating(\n\t                    rating=body.rating,\n\t                    user_id=user['id'],\n\t                    image_id=image_id\n\t                    )\n\t    db.add(rating)\n\t    db.commit()\n", "    db.refresh(rating)\n\t    image = db.query(Image).get(image_id)\n\t    average_rating = db.query(func.avg(Rating.rating)).filter(Rating.image_id == image_id).scalar()\n\t    image.rating = average_rating\n\t    db.commit()\n\t    db.refresh(image)\n\t    return rating\n\tasync def get_ratings(\n\t                image_id: int,\n\t                db: Session\n", "                ) -> List[Rating]:\n\t    ratings = db.query(Rating).filter(Rating.image_id == image_id).all()\n\t    return ratings\n\tasync def remove_rating(\n\t                         rating_id: int,\n\t                         user: User,\n\t                         db: Session\n\t                         ) -> dict:\n\t    rating = db.query(Rating).filter_by(id=rating_id).first()\n\t    if rating is None:\n", "        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_RATING_NOT_FOUND)\n\t    image_id = rating.image_id\n\t    db.delete(rating)\n\t    db.commit()\n\t    image = db.query(Image).get(image_id)\n\t    average_rating = db.query(func.avg(Rating.rating)).filter(Rating.image_id == image_id).scalar()\n\t    image.rating = average_rating\n\t    db.commit()\n\t    db.refresh(image)\n\t    return {'message': messages.RATING_DELETED}\n"]}
{"filename": "src/repository/users.py", "chunked_list": ["from typing import Optional, Type\n\tfrom fastapi import HTTPException, status\n\tfrom fastapi.encoders import jsonable_encoder\n\tfrom libgravatar import Gravatar\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import Image, Role, User\n\tfrom src.schemas.users import UserBase, UserModel, UserType\n\tfrom src.conf import messages\n\tasync def get_user_by_email(email: str, db: Session) -> Optional[User]:\n\t    return db.query(User).filter(User.email == email).first()\n", "async def get_user_by_id(user_id: int, db: Session) -> Optional[User]:\n\t    return db.query(User).filter(User.id == user_id).first()\n\tasync def create_user(body: UserModel, db: Session) -> User:\n\t    avatar = None\n\t    try:\n\t        g = Gravatar(body.email)\n\t        avatar = g.get_image()\n\t    except Exception as e:\n\t        print(e)\n\t    new_user: User = User(**body.dict(), avatar=avatar)\n", "    new_user.roles = Role.admin if not db.query(User).first() else Role.user\n\t    db.add(new_user)\n\t    db.commit()\n\t    db.refresh(new_user)\n\t    return new_user\n\tasync def change_password_for_user(user: User, password: str, db: Session) -> User:\n\t    user.password = password\n\t    db.add(user)\n\t    db.commit()\n\t    db.refresh(user)\n", "    return user\n\tasync def update_token(user: User, token: str | None, db: Session) -> None:\n\t    user.refresh_token = token\n\t    db.commit()\n\tasync def confirmed_email(user: User, db: Session) -> None:\n\t    user.confirmed = True\n\t    db.commit()\n\tasync def update_avatar(email: str, url: str, db: Session) -> Optional[User]:\n\t    user: User = await get_user_by_email(email, db)\n\t    if user:\n", "        user.avatar = url\n\t        db.commit()\n\t        db.refresh(user)\n\t        return user\n\tasync def get_number_of_images_per_user(email: str, db: Session) -> int:\n\t    return db.query(Image).filter(User.email == email).count()\n\tasync def update_user_profile(user_id: int, current_user: dict, body_data: UserType, db: Session) -> Optional[User]:\n\t    body_data: Optional[dict] = jsonable_encoder(body_data) if body_data else {}\n\t    user: User = await get_user_by_id(user_id, db)\n\t    if not user:\n", "        return None\n\t    if not body_data.get('roles'):\n\t        return None\n\t    if current_user['roles'] != Role.admin:\n\t        return None\n\t    if (\n\t        current_user['roles'] == Role.admin and\n\t        user_id != current_user['id']\n\t        ):\n\t        role_mapping = {\n", "                        'admin': Role.admin,\n\t                        'moderator': Role.moderator,\n\t                        'user': Role.user\n\t                        }\n\t        body_data['roles'] = role_mapping.get(body_data['roles'].lower(), Role.user)\n\t        setattr(user, 'roles', body_data['roles'])\n\t        db.add(user)\n\t        db.commit()\n\t        db.refresh(user)\n\t        return user\n", "    return None\n\tasync def update_your_profile(email: str, body_data: UserBase, db: Session) -> Optional[User]:\n\t    user: User = await get_user_by_email(email, db)\n\t    if not user:\n\t        return None  # raise 500?\n\t    db_obj_data: Optional[dict] = user.__dict__\n\t    body_data: Optional[dict] = jsonable_encoder(body_data) if body_data else None\n\t    if not db_obj_data or not body_data:\n\t        return None\n\t    for field in db_obj_data:\n", "        if field in body_data:\n\t            setattr(user, field, body_data[field])\n\t    db.add(user)\n\t    db.commit()\n\t    db.refresh(user)\n\t    return user\n\tasync def ban_user(user_id: int, active_status: bool, db: Session) -> Type[User] | None:\n\t    user = db.query(User).filter_by(id=user_id).first()\n\t    if not user:\n\t        return None\n", "    if user.roles.value == 'admin':\n\t        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=messages.MSC403_USER_BANNED)\n\t    user.status_active = active_status\n\t    db.commit()\n\t    db.refresh(user)\n\t    return user\n"]}
{"filename": "src/repository/tags.py", "chunked_list": ["from typing import List\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import Tag\n\tasync def create_tag(name, db: Session) -> Tag:\n\t    tag = Tag(name=name)\n\t    db.add(tag)\n\t    db.commit()\n\t    db.refresh(tag)\n\t    return tag\n\tasync def get_tags(db: Session) -> List[Tag]:\n", "    return db.query(Tag).all()\n\tasync def get_tag(tag_id: int, db: Session) -> Tag:\n\t    return db.query(Tag).filter(Tag.id == tag_id).first()\n\tasync def get_tag_by_name(name: str, db: Session) -> Tag:\n\t    return db.query(Tag).filter_by(name=name).first()\n"]}
{"filename": "src/repository/comments.py", "chunked_list": ["from typing import Optional, List\n\tfrom fastapi import HTTPException, status\n\tfrom sqlalchemy.orm import Session\n\tfrom src.database.models import Comment, User\n\tfrom src.schemas.images import CommentModel\n\tfrom src.conf import messages\n\tasync def add_comment(\n\t        body: CommentModel,\n\t        image_id: int,\n\t        user: dict,\n", "        db: Session\n\t        ) -> Optional[Comment]:\n\t    \"\"\"\n\t    The add_comment function creates a new comment for an image.\n\t    Args:\n\t    body (CommentModel): The CommentModel object containing the comment to be added.\n\t    image_id (int): The id of the image that is being commented on.\n\t    user (dict): A dictionary containing information about the user who is adding a comment, including their id and username.\n\t    :param body: CommentModel: Get the comment from the request body\n\t    :param image_id: int: Get the image id from the url\n", "    :param user: dict: Get the user id from the token\n\t    :param db: Session: Access the database\n\t    :return: A comment object\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    comment = Comment(\n\t        comment=body.comment,\n\t        user_id=user['id'],\n\t        image_id=image_id\n\t    )\n", "    db.add(comment)\n\t    db.commit()\n\t    db.refresh(comment)\n\t    return comment\n\tasync def update_comment(\n\t        comment_id: int,\n\t        body: CommentModel,\n\t        user: dict,\n\t        db: Session,\n\t        ) -> Optional[Comment]:\n", "    \"\"\"\n\t    The update_comment function updates a comment in the database.\n\t    Args:\n\t    comment_id (int): The id of the comment to update.\n\t    body (CommentModel): The updated Comment object with new values for its attributes.\n\t    This is passed as JSON from the client and converted into a CommentModel object by Pydantic's BaseModel class.\n\t    See models/comment_model for more information on how this works, or visit https://pydantic-docs.helpmanual.io/.\n\t    :param comment_id: int: Identify the comment to be deleted\n\t    :param body: CommentModel: Get the comment from the request body\n\t    :param user: dict: Check if the user is authorized to delete a comment\n", "    :param db: Session: Access the database\n\t    :param : Get the comment id\n\t    :return: The updated comment\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    comment: Comment = db.query(Comment).filter_by(id=comment_id, user_id=user['id']).first()\n\t    if not comment or not body.comment:\n\t        return None\n\t    comment.comment = body.comment\n\t    db.add(comment)\n", "    db.commit()\n\t    db.refresh(comment)\n\t    return comment\n\tasync def remove_comment(\n\t        comment_id: int,\n\t        user: User,\n\t        db: Session\n\t    ) -> dict:\n\t    \"\"\"\n\t    The remove_comment function deletes a comment from the database.\n", "    :param comment_id: int: Specify the id of the comment that is to be deleted\n\t    :param user: User: Check if the user is authorized to delete a comment\n\t    :param db: Session: Access the database\n\t    :return: A dictionary with a message that the comment has been deleted\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    comment: Comment = db.query(Comment).filter_by(id=comment_id).first()\n\t    if comment is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_COMMENT_NOT_FOUND)\n\t    db.delete(comment)\n", "    db.commit()\n\t    return {'message': messages.COMMENT_DELETED}\n\tasync def get_comments(image_id, db) -> List[Comment]:\n\t    \"\"\"\n\t    The get_comments function takes in an image_id and a database connection,\n\t    and returns all comments associated with the given image_id.\n\t    :param image_id: Filter the comments by image_id\n\t    :param db: Query the database for comments that are associated with a specific image\n\t    :return: All comments associated with a particular image\n\t    :doc-author: Trelent\n", "    \"\"\"\n\t    return db.query(Comment).filter_by(image_id=image_id).all()\n"]}
{"filename": "src/schemas/images.py", "chunked_list": ["import enum\n\tfrom datetime import datetime\n\tfrom pydantic import BaseModel, Field\n\tfrom typing import List\n\tfrom src.database.models import TransformationsType\n\tclass TagModel(BaseModel):\n\t    name: str = Field(max_length=20)\n\t    class Config:\n\t        orm_mode = True\n\tclass ImageModel(BaseModel):\n", "    description: str = Field(max_length=50)\n\t    tags: str\n\t    rating: float = None\n\tclass ImageResponse(ImageModel):\n\t    id: int\n\t    link: str\n\t    user_id: int\n\t    created_at: datetime\n\t    updated_at: datetime\n\t    tags: List[TagModel]\n", "    rating: float = None\n\t    class Config:\n\t        orm_mode = True\n\tclass TransformateModel(BaseModel):\n\t    Type: TransformationsType\n\tclass SortDirection(enum.Enum):\n\t    up: str = 'asc'\n\t    down: str = 'desc'\n\tclass CommentModel(BaseModel):\n\t    comment: str = Field(max_length=2000)\n", "class CommentResponse(CommentModel):\n\t    id: int\n\t    class Config:\n\t        orm_mode = True\n\tclass RatingModel(BaseModel):\n\t    rating: float = Field(ge=1, le=5)\n\tclass RatingResponse(RatingModel):\n\t    id: int\n\t    class Config:\n\t        orm_mode = True\n"]}
{"filename": "src/schemas/users.py", "chunked_list": ["from datetime import datetime\n\tfrom pydantic import BaseModel, EmailStr, Field\n\tfrom src.conf import messages\n\tfrom src.database.models import Role\n\tclass UserBase(BaseModel):\n\t    username: str = Field(min_length=2, max_length=30)\n\t    email: EmailStr\n\tclass UserModel(UserBase):\n\t    password: str = Field(min_length=6, max_length=14)\n\tclass UserType(UserBase):\n", "    roles: str = 'user'\n\tclass UserDb(BaseModel):\n\t    id: int\n\t    username: str\n\t    email: str\n\t    created_at: datetime\n\t    avatar: str\n\t    class Config:\n\t        \"\"\"Indicates that the UserDb model is used to represent the ORM model.\"\"\"\n\t        orm_mode = True\n", "class UserResponse(BaseModel):\n\t    id: int\n\t    username: str\n\t    email: str\n\t    created_at: datetime\n\t    avatar: str\n\t    roles: Role\n\t    detail: str = messages.MSC201_USER_CREATED\n\t    status_active: bool\n\t    class Config:\n", "        orm_mode = True\n\tclass UserResponseFull(UserResponse):\n\t    number_images: int = 0\n\tclass Token(BaseModel):\n\t    access_token: str\n\t    refresh_token: str\n\t    token_type: str = messages.TOKEN_TYPE\n\tclass RequestEmail(BaseModel):\n\t    email: EmailStr\n\tclass PasswordRecovery(BaseModel):\n", "    \"\"\"To check the sufficiency of the password during the password recovery procedure.\"\"\"\n\t    password: str = Field(min_length=6, max_length=14)\n\tclass MessageResponse(BaseModel):\n\t    message: str = Field(max_length=2000)\n"]}
{"filename": "src/database/models.py", "chunked_list": ["import enum\n\tfrom sqlalchemy import Column, Boolean, Enum, func, Integer, String, Table\n\tfrom sqlalchemy.orm import relationship\n\tfrom sqlalchemy.sql.schema import ForeignKey, UniqueConstraint, CheckConstraint\n\tfrom sqlalchemy.sql.sqltypes import DateTime, Float\n\tfrom src.database.db import Base\n\tclass Role(enum.Enum):\n\t    admin: str = 'admin'\n\t    moderator: str = 'moderator'\n\t    user: str = 'user'\n", "class User(Base):\n\t    \"\"\"Base User class.\"\"\"\n\t    __tablename__ = 'users'\n\t    id = Column(Integer, primary_key=True)\n\t    username = Column(String(50))\n\t    email = Column(String(30), nullable=False, unique=True)\n\t    password = Column(String(255), nullable=False)\n\t    created_at = Column('crated_at', DateTime, default=func.now())\n\t    updated_at = Column('updated_at', DateTime, default=func.now(), onupdate=func.now())\n\t    avatar = Column(String(255), nullable=True)\n", "    refresh_token = Column(String(255), nullable=True)\n\t    roles = Column('roles', Enum(Role), default=Role.user)\n\t    confirmed = Column(Boolean, default=False)\n\t    status_active = Column(Boolean, default=True)\n\tclass TransformationsType(enum.Enum):\n\t    basic: str = 'basic'\n\t    avatar: str = 'avatar'\n\t    black_white: str = 'black_white'\n\t    delete_bg: str = 'delete_bg'\n\t    cartoonify: str = 'cartoonify'\n", "    oil_paint: str = 'oil_paint'\n\t    sepia: str = 'sepia'\n\t    vector: str = 'vector'\n\t    outline: str = 'outline'\n\timage_m2m_tag = Table('image_m2m_tag',\n\t                      Base.metadata,\n\t                      Column('id', Integer, primary_key=True),\n\t                      Column('image_id', Integer, ForeignKey('images.id', ondelete='CASCADE')),\n\t                      Column('tag_id', Integer, ForeignKey('tags.id', ondelete='CASCADE'))\n\t                      )\n", "class Image(Base):\n\t    __tablename__ = 'images'\n\t    id = Column(Integer, primary_key=True)\n\t    description = Column(String, nullable=True)\n\t    type = Column('TransformationsType', Enum(TransformationsType), default=TransformationsType.basic)\n\t    link = Column(String, nullable=False)\n\t    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=True)\n\t    user = relationship('User', backref='images')\n\t    tags = relationship('Tag', secondary=image_m2m_tag, backref='images')\n\t    rating = Column(Float, nullable=True)\n", "    created_at = Column(DateTime, default=func.now())\n\t    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())\n\tclass Tag(Base):\n\t    __tablename__ = 'tags'\n\t    id = Column(Integer, primary_key=True)\n\t    name = Column(String(20), nullable=False, unique=True)\n\tclass Comment(Base):\n\t    __tablename__ = 'comments'\n\t    id = Column(Integer, primary_key=True)\n\t    comment = Column(String(2000))\n", "    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=True)\n\t    user = relationship('User', backref='comments')\n\t    image_id = Column(Integer, ForeignKey('images.id', ondelete='CASCADE'), nullable=True)\n\t    image = relationship('Image', backref='comments')\n\t    created_at = Column(DateTime, default=func.now())\n\t    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())\n\tclass Rating(Base):\n\t    __tablename__ = 'ratings'\n\t    id = Column(Integer, primary_key=True)\n\t    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=True)\n", "    user = relationship(\"User\", backref='ratings')\n\t    image_id = Column(Integer, ForeignKey('images.id', ondelete='CASCADE'), nullable=True)\n\t    image = relationship(\"Image\", backref='ratings')\n\t    rating = Column(Float, CheckConstraint('rating >= 1 AND rating <= 5'))\n\t    created_at = Column(DateTime, default=func.now())\n\t    __table_args__ = (UniqueConstraint('user_id', 'image_id', name='_user_image_uc'),)\n"]}
{"filename": "src/database/db.py", "chunked_list": ["# from datetime import datetime\n\t# import traceback\n\tfrom fastapi import HTTPException, status\n\timport redis\n\timport redis.asyncio as aredis\n\tfrom redis.exceptions import AuthenticationError\n\tfrom sqlalchemy import create_engine\n\tfrom sqlalchemy.orm import declarative_base, sessionmaker\n\tfrom sqlalchemy.exc import SQLAlchemyError\n\tfrom src.conf.config import settings\n", "from src.conf.messages import MSC500_DATABASE_CONFIG, MSC500_DATABASE_CONNECT\n\tfrom src.services.asyncdevlogging import async_logging_to_file\n\tURI = settings.sqlalchemy_database_url\n\tengine = create_engine(URI, echo=True)\n\tDBSession = sessionmaker(bind=engine, autoflush=False, autocommit=False)\n\tBase = declarative_base()\n\tdef get_db():\n\t    db = DBSession()\n\t    try:\n\t        yield db\n", "    except SQLAlchemyError as err:\n\t        db.rollback()\n\t        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(err))\n\t    finally:\n\t        db.close()\n\tdef get_redis(is_async: bool = True):\n\t    module = {\n\t        True: aredis,\n\t        False: redis\n\t    }\n", "    redis_module = module[is_async]\n\t    try:\n\t        if settings.redis_password and settings.redis_password != '0':\n\t            redis_client = redis_module.Redis(\n\t                                    host=settings.redis_host,\n\t                                    port=settings.redis_port,\n\t                                    db=0,\n\t                                    password=settings.redis_password\n\t                                    )\n\t        else:\n", "            redis_client = redis_module.Redis(\n\t                                    host=settings.redis_host,\n\t                                    port=settings.redis_port,\n\t                                    db=0\n\t                                    )\n\t    except AuthenticationError as error:\n\t        redis_client = None\n\t        print(f'Authentication failed to connect to redis\\n{error}')\n\t        # await async_logging_to_file(f'\\n500:\\t{datetime.now()}\\t{MSC500_DATABASE_CONFIG}: {err}\\t{traceback.extract_stack(None, 2)[1][2]}')\n\t    except Exception as error:\n", "        redis_client = None\n\t        print(f'Unable to connect to redis\\n{error}')\n\t        # await async_logging_to_file(f'\\n500:\\t{datetime.now()}\\t{MSC500_DATABASE_CONNECT}: {err}\\t{traceback.extract_stack(None, 2)[1][2]}')\n\t    return redis_client if redis_client else None\n"]}
{"filename": "src/services/images.py", "chunked_list": ["import hashlib\n\timport io\n\tfrom typing import BinaryIO\n\timport qrcode\n\timport cloudinary\n\tfrom cloudinary.uploader import upload\n\tfrom src.conf.config import settings\n\tfrom src.database.models import Image\n\tclass CloudImage:\n\t    cloudinary.config(\n", "        cloud_name=settings.cloudinary_name,\n\t        api_key=settings.cloudinary_api_key,\n\t        api_secret=settings.cloudinary_api_secret,\n\t        secure=True\n\t    )\n\t    filters = {\n\t        'avatar': [\n\t            {'aspect_ratio': '1.0', 'gravity': 'face', 'width': 500, 'zoom': '1', 'crop': 'thumb'},\n\t            {'radius': 'max'},\n\t            {'color': 'brown', 'effect': 'outline'}\n", "        ],\n\t        'black_white': [{'effect': 'grayscale'}],\n\t        'delete_bg': [{'effect': 'bgremoval'}],\n\t        'cartoonify': [{'effect': 'cartoonify'}],\n\t        'oil_paint': [{'effect': 'oil_paint:100'}],\n\t        'vector': [{'effect': 'vectorize:colors:5:corners:40:detail:1.0'}],\n\t        'sepia': [{'effect': 'sepia:100'}],\n\t        'outline': [\n\t            {'width': 200, 'crop': 'scale'},\n\t            {'color': 'blue', 'effect': 'outline:20:200'},\n", "            {'color': 'yellow', 'effect': 'outline:15:200'}\n\t        ]\n\t    }\n\t    @classmethod\n\t    def generate_name_avatar(cls, email: str):\n\t        user_name = hashlib.sha256(email.encode('utf-8')).hexdigest()[:14]\n\t        return f'FRT-PHOTO-SHARE-AVATARS/{user_name}'\n\t    @classmethod\n\t    def get_url_for_avatar(cls, public_id, res, clipping: tuple[int, int] = (120, 120)) -> str:\n\t        return (\n", "            cloudinary\n\t            .CloudinaryImage(public_id)\n\t            .build_url(width=clipping[0], height=clipping[1], crop='fill', version=res.get('version'))\n\t        )\n\t    @classmethod\n\t    def avatar_upload(cls, file: BinaryIO, email: str, clipping: tuple[int, int] = (120, 120)) -> str:\n\t        avatar_id = cls.generate_name_avatar(email)\n\t        upload_result = cloudinary.uploader.upload(file, public_id=avatar_id, overwrite=True)\n\t        return cls.get_url_for_avatar(avatar_id, upload_result, clipping)\n\t    @classmethod\n", "    def generate_name_image(cls, email: str, filename: str):\n\t        image_name = hashlib.sha256(email.encode('utf-8')).hexdigest()[:12]\n\t        image_sufix = hashlib.sha256(filename.encode('utf-8')).hexdigest()[:12]\n\t        return f'FRT-PHOTO-SHARE-IMAGES/{image_name}-{image_sufix}'\n\t    @classmethod\n\t    def image_upload(cls, file, public_id: str):\n\t        return cloudinary.uploader.upload(file, public_id=public_id, overwrite=True)\n\t    @classmethod\n\t    def get_url_for_image(cls, public_id, r):\n\t        src_url = cloudinary.CloudinaryImage(public_id).build_url(version=r.get('version'))\n", "        return src_url\n\t    @classmethod\n\t    def transformation(cls, image: Image, type):\n\t        old_link = image.link\n\t        break_point = old_link.find('/upload/') + settings.break_point\n\t        image_name = old_link[break_point:]\n\t        new_link = cloudinary.CloudinaryImage(image_name).build_url(transformation=CloudImage.filters[type.value])\n\t        return new_link\n\t    @classmethod\n\t    def get_qrcode(cls, image: Image):\n", "        qr_code = qrcode.QRCode(\n\t            error_correction=qrcode.constants.ERROR_CORRECT_M,\n\t            box_size=7,\n\t            border=4,\n\t        )\n\t        url = image.link\n\t        qr_code.add_data(url)\n\t        qr_code.make(fit=True)\n\t        img = qr_code.make_image(fill_color=\"black\", back_color=\"white\")\n\t        output = io.BytesIO()\n", "        img.save(output)\n\t        output.seek(0)\n\t        return output\n"]}
{"filename": "src/services/auth.py", "chunked_list": ["from datetime import datetime, timedelta\n\timport traceback\n\timport pickle\n\tfrom typing import Optional\n\timport secrets\n\timport string\n\tfrom fastapi import HTTPException, Depends, status\n\tfrom fastapi.security import OAuth2PasswordBearer\n\tfrom jose import JWTError, jwt\n\tfrom passlib.context import CryptContext\n", "from fastapi.security import HTTPBearer\n\tfrom sqlalchemy.orm import Session\n\tfrom src.conf.config import settings\n\tfrom src.conf import messages\n\tfrom src.database.db import get_db, get_redis\n\tfrom src.database.models import User\n\tfrom src.repository import users as repository_users\n\tfrom src.services.asyncdevlogging import async_logging_to_file\n\tclass AuthPassword:\n\t    @staticmethod\n", "    def get_hash_password(password: str) -> str:\n\t        pwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')\n\t        return pwd_context.hash(password)\n\t    @staticmethod\n\t    def get_new_password(password_length: int = settings.password_length, meeting_limit: int = 3) -> str:\n\t        letters = string.ascii_letters\n\t        digits = string.digits\n\t        special_chars = string.punctuation\n\t        alphabet = letters + digits + special_chars\n\t        while True:\n", "            pwd = ''\n\t            for i in range(password_length):\n\t                pwd += ''.join(secrets.choice(alphabet))\n\t            if (any(char in special_chars for char in pwd) and\n\t                    sum(char in digits for char in pwd) >= meeting_limit):\n\t                break\n\t        return AuthPassword.get_hash_password(pwd)\n\t    @staticmethod\n\t    def verify_password(password: str, hashed_password: str) -> str:\n\t        pwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')\n", "        return pwd_context.verify(password, hashed_password)\n\tclass AuthToken:\n\t    oauth2_scheme: OAuth2PasswordBearer = OAuth2PasswordBearer(tokenUrl='/api/auth/login')\n\t    SECRET_KEY = settings.secret_key\n\t    ALGORITHM = settings.algorithm\n\t    credentials_exception = HTTPException(\n\t                                          status_code=status.HTTP_401_UNAUTHORIZED,\n\t                                          detail=messages.MSC401_CREDENTIALS,\n\t                                          headers={'WWW-Authenticate': messages.TOKEN_TYPE},\n\t                                          )\n", "    @classmethod\n\t    async def create_token(cls, data: dict, expires_delta: Optional[float] = None, token_type: str = None) -> str:\n\t        to_encode = data.copy()\n\t        token_type_mapping = {\n\t                              'access_token': settings.access_token_timer,\n\t                              'refresh_token': settings.refresh_token_timer,\n\t                              'password_reset_token': settings.password_reset_token_timer,\n\t                              'email_token': settings.email_token_timer,\n\t                              }\n\t        default_token_lifetime_limit = token_type_mapping.get(token_type, 0)\n", "        if expires_delta:\n\t            expire = datetime.utcnow() + timedelta(expires_delta)\n\t        else:\n\t            expire = datetime.utcnow() + timedelta(hours=default_token_lifetime_limit)\n\t        to_encode.update({'iat': datetime.utcnow(), 'exp': expire, 'scope': token_type})\n\t        token = jwt.encode(to_encode, AuthToken.SECRET_KEY, AuthToken.ALGORITHM)\n\t        return token\n\t    @classmethod\n\t    async def get_email_from_token(cls, token: str = Depends(oauth2_scheme), token_type: str = None) -> str:\n\t        try:\n", "            payload = jwt.decode(token, AuthToken.SECRET_KEY, algorithms=[AuthToken.ALGORITHM])\n\t            email = payload['sub']\n\t            if not token_type:\n\t                return email\n\t            elif payload['scope'] == token_type:\n\t                if email is None:\n\t                    raise AuthToken.credentials_exception  # MSC401_EMAIL ?\n\t            else:\n\t                raise AuthToken.credentials_exception  # MSC401_TOKEN_SCOPE ?\n\t        except JWTError as e:\n", "            await async_logging_to_file(f'\\n3XX:\\t{datetime.now()}\\tJWTError: {e}\\t{traceback.extract_stack(None, 2)[1][2]}')\n\t            raise HTTPException(\n\t                                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n\t                                detail=messages.MSC422_INVALID_TOKEN\n\t                                )\n\t        return email\n\t    @staticmethod\n\t    async def token_check(payload: dict, token_type: str = 'access_token') -> str:\n\t        if payload['scope'] == token_type:\n\t            email = payload['sub']\n", "            if email is None:\n\t                raise AuthToken.credentials_exception\n\t        else:\n\t            raise AuthToken.credentials_exception\n\t        return email\n\tclass AuthUser(AuthToken):\n\t    redis_client = get_redis(False)\n\t    @classmethod\n\t    async def clear_user_cash(cls, user_email) -> None:\n\t        AuthUser.redis_client.delete(user_email)\n", "    @classmethod\n\t    async def get_current_user(\n\t                               cls,\n\t                               token: str = Depends(AuthToken.oauth2_scheme),\n\t                               db: Session = Depends(get_db)\n\t                               ) -> dict:\n\t        email: str = await AuthToken.get_email_from_token(token, token_type='access_token')\n\t        bl_token = AuthUser.redis_client.get(token)\n\t        if bl_token:\n\t            raise AuthUser.credentials_exception\n", "        user: Optional[dict] = AuthUser.redis_client.get(email) if AuthUser.redis_client else None\n\t        if user is None:\n\t            user: User = await repository_users.get_user_by_email(email, db)\n\t            user = {\n\t                    'id': user.id,\n\t                    'username': user.username,\n\t                    'email': user.email,\n\t                    'roles': user.roles,\n\t                    'status_active': user.status_active,\n\t                   }\n", "            if user is None:\n\t                raise AuthUser.credentials_exception\n\t            AuthUser.redis_client.set(email, pickle.dumps(user)) if AuthUser.redis_client else None\n\t            AuthUser.redis_client.expire(email, settings.redis_user_timer) if AuthUser.redis_client else None\n\t        else:\n\t            user: User = pickle.loads(user)\n\t        if not user.get('status_active'):\n\t            await async_logging_to_file(f'\\n5XX:\\t{datetime.now()}\\tUser_status: {user[\"status_active\"]}\\t{traceback.extract_stack(None, 2)[1][2]}')\n\t            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=messages.MSC403_USER_BANNED)\n\t        return user\n", "    @classmethod\n\t    async def logout_user(cls,\n\t                          token: str = Depends(AuthToken.oauth2_scheme),\n\t                          db: Session = Depends(get_db)\n\t                          ) -> None:\n\t        try:\n\t            payload = jwt.decode(token, AuthUser.SECRET_KEY, AuthUser.ALGORITHM)\n\t            email = await AuthUser.token_check(payload, token_type='access_token')\n\t        except:\n\t            raise AuthUser.credentials_exception\n", "        now = datetime.timestamp(datetime.now())\n\t        time_delta = payload['exp'] - now + settings.redis_addition_lag\n\t        AuthUser.redis_client.set(token, 'True')\n\t        AuthUser.redis_client.expire(token, int(time_delta))\n\t        user = await repository_users.get_user_by_email(email, db)\n\t        user.refresh_token = None\n\t        db.commit()\n\tsecurity = HTTPBearer()\n"]}
{"filename": "src/services/asyncdevlogging.py", "chunked_list": ["from pathlib import Path\n\timport logging\n\timport sys\n\tfrom aiofile import async_open\n\tfrom aiopath import AsyncPath\n\tlogging.basicConfig(level=logging.DEBUG, format='%(threadName)s %(message)s')\n\tasync_log_file = 'frt_photo_share_asynclog.txt'\n\tasync_log_file = str(Path(sys.argv[0]).parent.absolute().joinpath('logs', async_log_file))\n\tasync def async_logging_to_file(message: str) -> None:\n\t    apath = AsyncPath(Path(async_log_file).parent)\n", "    await apath.mkdir(parents=True, exist_ok=True)\n\t    if apath.exists() and apath.is_file():\n\t        mode_file_open: str = 'a+'\n\t    elif not apath.exists():\n\t        mode_file_open: str = 'w+'\n\t    else:\n\t        logging.warning(f'Sorry, no log-file and can\\'t create \"{async_log_file}\".')\n\t        return None\n\t    async with async_open(async_log_file, mode_file_open) as afp:\n\t        await afp.write(f'{message}\\n')\n"]}
{"filename": "src/services/email.py", "chunked_list": ["from datetime import datetime\n\tfrom pathlib import Path\n\timport traceback\n\tfrom fastapi_mail import ConnectionConfig, FastMail, MessageSchema, MessageType\n\tfrom fastapi_mail.errors import ConnectionErrors\n\tfrom pydantic import EmailStr\n\tfrom src.conf.config import settings\n\tfrom src.conf import messages\n\tfrom src.services.asyncdevlogging import async_logging_to_file\n\tfrom src.services.auth import AuthToken\n", "conf = ConnectionConfig(\n\t    MAIL_USERNAME=settings.mail_username,\n\t    MAIL_PASSWORD=settings.mail_password,\n\t    MAIL_FROM=EmailStr(settings.mail_from),\n\t    MAIL_PORT=settings.mail_port,\n\t    MAIL_SERVER=settings.mail_server,\n\t    MAIL_FROM_NAME=settings.mail_from_name,\n\t    MAIL_STARTTLS=False,\n\t    MAIL_SSL_TLS=True,\n\t    USE_CREDENTIALS=True,\n", "    VALIDATE_CERTS=True,\n\t    TEMPLATE_FOLDER=Path(__file__).parent / 'templates',\n\t)\n\tasync def send_email(email: EmailStr, username: str, host: str):\n\t    try:\n\t        token_verification = await AuthToken.create_token(data={'sub': email}, token_type='email_token')\n\t        mail_subject = messages.EMAIL_CONFIRMATION_REQUEST\n\t        message = MessageSchema(\n\t            subject=mail_subject,\n\t            recipients=[email],\n", "            template_body={\n\t                'subject': mail_subject,\n\t                'host': host,\n\t                'username': username,\n\t                'token': token_verification\n\t            },\n\t            subtype=MessageType.html\n\t        )\n\t        fm = FastMail(conf)\n\t        await fm.send_message(message, template_name='email_template.html')\n", "    except ConnectionErrors as err:\n\t        await async_logging_to_file(f'\\n500:\\t{datetime.now()}\\t{messages.MSC500_SENDING_EMAIL}: {err}\\t{traceback.extract_stack(None, 2)[1][2]}')\n\tasync def send_new_password(email: EmailStr, username: str, host: str, password: str):\n\t    subject = 'New password'\n\t    try:\n\t        message = MessageSchema(\n\t            subject=messages.PASSWORD_RESET_REQUEST,\n\t            recipients=[email],\n\t            template_body={\n\t                'subject': subject,\n", "                'host': host,\n\t                'username': username,\n\t                'new_password': password,\n\t            },\n\t            subtype=MessageType.html\n\t        )\n\t        fm = FastMail(conf)\n\t        await fm.send_message(message, template_name='new_password.html')\n\t    except ConnectionErrors as err:\n\t        await async_logging_to_file(f'\\n500:\\t{datetime.now()}\\t{messages.MSC500_SENDING_EMAIL}: {err}\\t{traceback.extract_stack(None, 2)[1][2]}')\n", "async def send_reset_password(email: EmailStr, username: str, host: str):\n\t    subject = 'Reset password '\n\t    try:\n\t        token_verification = await AuthToken.create_token(data={'sub': email}, token_type='password_reset_token')\n\t        message = MessageSchema(\n\t            subject=messages.PASSWORD_RESET_REQUEST,\n\t            recipients=[email],\n\t            template_body={\n\t                'subject': subject,\n\t                'host': host,\n", "                'username': username,\n\t                'token': token_verification,\n\t            },\n\t            subtype=MessageType.html\n\t        )\n\t        fm = FastMail(conf)\n\t        await fm.send_message(message, template_name='password_reset.html')\n\t    except ConnectionErrors as err:\n\t        await async_logging_to_file(f'\\n500:\\t{datetime.now()}\\t{messages.MSC500_SENDING_EMAIL}: {err}\\t{traceback.extract_stack(None, 2)[1][2]}')\n"]}
{"filename": "src/services/roles.py", "chunked_list": ["from typing import List\n\tfrom fastapi import Depends, HTTPException, Request, status\n\tfrom src.database.models import Role\n\tfrom src.conf.messages import MSC403_FORBIDDEN\n\tfrom src.services.auth import AuthUser\n\tclass RoleAccess:\n\t    def __init__(self, allowed_roles: List[Role]):\n\t        self.allowed_roles = allowed_roles\n\t    async def __call__(self, request: Request, current_user: dict = Depends(AuthUser.get_current_user)):\n\t        if current_user.get('roles') not in self.allowed_roles:\n", "            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=MSC403_FORBIDDEN)\n\tallowed_all_roles_access = RoleAccess([Role.admin, Role.moderator, Role.user])\n\tallowed_admin_moderator = RoleAccess([Role.admin, Role.moderator])\n"]}
{"filename": "src/conf/config.py", "chunked_list": ["from pydantic import BaseSettings\n\tclass Settings(BaseSettings):\n\t    sqlalchemy_database_url: str = 'postgresql+psycopg2://user:password@localhost:5432/postgres'\n\t    secret_key: str = 'secret_key'\n\t    algorithm: str = 'HS256'\n\t    mail_username: str = 'example@meta.ua'\n\t    mail_password: str = 'password'\n\t    mail_from: str = 'example@meta.ua'\n\t    mail_port: int = 465\n\t    mail_server: str = 'smtp.meta.ua'\n", "    mail_from_name: str = 'sender: app photo-share'\n\t    redis_host: str = 'localhost'\n\t    redis_password: str = ''\n\t    redis_port: int = 6379\n\t    cloudinary_name: str = 'name'\n\t    cloudinary_api_key: int = 1\n\t    cloudinary_api_secret: str = 'secret'\n\t    limit_crit: int = 12\n\t    limit_warn: int = 2\n\t    tags_limit: int = 5\n", "    limit_crit_timer: int = 60 # seconds\n\t    access_token_timer: int = 1 # hours\n\t    refresh_token_timer: int = 168 # hours\n\t    email_token_timer: int = 1 # hours\n\t    password_reset_token_timer: int = 1 # hours\n\t    redis_user_timer: int = 3600 # seconds\n\t    redis_addition_lag: int = 300\n\t    break_point: int = 8\n\t    password_length: int = 12\n\t    class Config:\n", "        env_file = '.env'\n\t        env_file_encoding = 'utf-8'\n\tsettings = Settings()\n"]}
{"filename": "src/conf/messages.py", "chunked_list": ["WELCOME = 'Welcome to Photo-Share by Fast Rabbit Team.'\n\tTOKEN_TYPE = 'Bearer'\n\tWELCOME_FASTAPI = 'Welcome to FastAPI!'\n\tMSC400_BAD_REQUEST = 'Verification error.'\n\tMSC400_ALREADY_RATED = 'User already rated this image.'\n\tMSC401_EMAIL = 'Invalid email.'\n\tMSC401_EMAIL_UNKNOWN = 'Unknown email.'\n\tMSC401_PASSWORD = 'Invalid password.'\n\tMSC401_TOKEN = 'Invalid token.'\n\tMSC401_TOKEN_SCOPE = 'Invalid scope for token.'\n", "MSC401_CREDENTIALS = 'Could not validate credentials.'\n\tMSC404_IMAGE_NOT_FOUND = 'Image Not Found.'\n\tMSC404_USER_NOT_FOUND = 'User Not Found.'\n\tMSC404_COMMENT_NOT_FOUND = 'Comment Not Found.'\n\tMSC404_RATING_NOT_FOUND = 'Rating Not Found.'\n\tMSC404_TAG_NOT_FOUND = 'Tag Not Found.'\n\tMSC409_CONFLICT = 'This email is already in use.'\n\tMSC409_TAGS = 'To many tags. You can add 5 tags'\n\tMSC412_IMPOSSIBLE = 'Unable to complete the request.'\n\tMSC500_DATABASE_CONFIG = 'Database is not configured correctly.'\n", "MSC500_DATABASE_CONNECT = 'Error connecting to the database.'\n\tMSC503_UNKNOWN_USER = 'Can`t find user by email from token.'\n\tMSC201_USER_CREATED = 'User successfully created.'\n\tMSC403_FORBIDDEN = 'Operation forbidden.'\n\tMSC403_USER_BANNED = 'User is banned.'\n\tMSC422_EMAIL_VERIFICATION = 'Invalid token for email verification.'\n\tMSC422_INVALID_TOKEN = 'Invalid token does not contain an email.'\n\tEMAIL_ERROR_CONFIRMED = 'Your email is already confirmed.'\n\tEMAIL_INFO_CONFIRMED = 'Check your email for confirmation.'\n\tEMAIL_INFO_CONFIRM = 'Email confirmed.'\n", "EMAIL_CONFIRMATION_REQUEST = 'Confirm your email.'\n\tPASSWORD_RESET_REQUEST = 'Reset password.'\n\tMSG_PASSWORD_CHENGED = 'User`s password successfully changed.'\n\tMSG_PASSWORD_RESET = 'Complete password reset.'\n\tMSG_SENT_PASSWORD = 'Password-change email has been sent.'\n\tMSC500_SENDING_EMAIL = 'can`t send a letter.'\n\tRATING_DELETED = 'Rating deleted.'\n\tOWN_RATING = \"Can't rate own image.\"\n\tCOMMENT_DELETED = 'Comment deleted.'\n\tIMAGE_DELETED = 'Image deleted.'\n"]}
{"filename": "src/routes/images.py", "chunked_list": ["from typing import Optional, List\n\tfrom fastapi import APIRouter, Depends, File, HTTPException, Path, Security, status, UploadFile\n\tfrom fastapi_limiter.depends import RateLimiter\n\tfrom fastapi_pagination import add_pagination, Page, Params\n\tfrom fastapi.security import HTTPAuthorizationCredentials\n\tfrom starlette.responses import StreamingResponse\n\tfrom sqlalchemy.orm import Session\n\tfrom src.conf.config import settings\n\tfrom src.conf import messages\n\tfrom src.database.db import get_db\n", "from src.database.models import Image, TransformationsType\n\tfrom src.repository import images as repository_images\n\tfrom src.repository import tags as repository_tags\n\tfrom src.repository import users as repository_users\n\tfrom src.schemas.images import ImageModel, ImageResponse, SortDirection\n\tfrom src.schemas.users import MessageResponse\n\tfrom src.services.auth import AuthUser, security\n\tfrom src.services.images import CloudImage\n\tfrom src.services.roles import allowed_all_roles_access, allowed_admin_moderator\n\trouter = APIRouter(prefix='/images', tags=['images'])\n", "@router.get(\n\t            '/',\n\t            description=f'Get images.\\nNo more than {settings.limit_crit} requests per minute.',\n\t            dependencies=[\n\t                          Depends(allowed_all_roles_access),\n\t                          Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n\t                          ],\n\t            response_model=Page\n\t            )\n\tasync def get_images(\n", "                       db: Session = Depends(get_db),\n\t                       current_user: dict = Depends(AuthUser.get_current_user),\n\t                       credentials: HTTPAuthorizationCredentials = Security(security),\n\t                       pagination_params: Params = Depends()\n\t                       ) -> Page:\n\t    \"\"\"\n\t    The get_images function returns a list of images.\n\t    :param db: Session: Get the database session\n\t    :param current_user: dict: Get the current user from the database\n\t    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n", "    :param pagination_params: Params: Get the pagination parameters from the request\n\t    :return: A page object, which is a paginated list of image objects\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    images = await repository_images.get_images(current_user, db, pagination_params)\n\t    return images\n\t@router.post(\n\t             '/transformation/{image_id}',\n\t             description=f'Transform image.\\nNo more than {settings.limit_crit} requests per minute.',\n\t             dependencies=[\n", "                           Depends(allowed_all_roles_access),\n\t                           Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n\t                           ],\n\t             response_model=ImageResponse\n\t             )\n\tasync def transform_image(\n\t                          type: TransformationsType,\n\t                          image_id: int = Path(ge=1),\n\t                          db: Session = Depends(get_db),\n\t                          current_user: dict = Depends(AuthUser.get_current_user),\n", "                          credentials: HTTPAuthorizationCredentials = Security(security)\n\t                          ) -> Optional[Image]:\n\t    \"\"\"\n\t    The transform_image function is used to transform an image.\n\t    The function takes in the following parameters:\n\t    - type: TransformationsType, which is a transformation type from the enum TransformationsType.\n\t    - image_id: int = Path(ge=0), which is an integer representing the id of an existing image.\n\t    This parameter must be greater than or equal to 1 and it's required for this function to work properly.\n\t    :param type: TransformationsType: Define the type of transformation that will be applied to the image\n\t    :param image_id: int: Get the image from the database\n", "    :param db: Session: Get the database session\n\t    :param current_user: dict: Get the user id of the current user\n\t    :param credentials: HTTPAuthorizationCredentials: Validate the token\n\t    :return: A new image with the transformation applied\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    image = await repository_images.get_image(image_id, current_user, db)\n\t    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\t    if image.user_id != current_user['id']:\n", "        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=messages.MSC400_BAD_REQUEST)\n\t    transform_image_link = CloudImage.transformation(image, type)\n\t    body = {\n\t            'description': image.description,\n\t            'link': transform_image_link,\n\t            'tags': image.tags,\n\t            'type': type.value\n\t            }\n\t    new_image = await repository_images.transform_image(body, image.user_id, db)\n\t    return new_image\n", "@router.get(\n\t            '/qrcode/{image_id}',\n\t            description=f'No more than {settings.limit_crit} requests per minute',\n\t            dependencies=[\n\t                           Depends(allowed_all_roles_access),\n\t                           Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n\t                           ]\n\t            )\n\tasync def image_qrcode(\n\t                       image_id: int = Path(ge=1),\n", "                       db: Session = Depends(get_db),\n\t                       current_user: dict = Depends(AuthUser.get_current_user),\n\t                       credentials: HTTPAuthorizationCredentials = Security(security),\n\t                       ):\n\t    \"\"\"\n\t    The image_qrcode function returns a QR code for the image.\n\t    :param image_id: int: Identify the image that is to be deleted\n\t    :param db: Session: Access the database\n\t    :param current_user: dict: Get the current user's information\n\t    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n", "    :param : Get the image id from the url\n\t    :return: A qr code for the image that can be used to download it\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    image = await repository_images.get_image(image_id, current_user, db)\n\t    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\t    qr_code = CloudImage.get_qrcode(image)\n\t    return StreamingResponse(qr_code, media_type=\"image/png\")\n\t@router.get(\n", "            '/{image_id}',\n\t            description=f'Get image.\\nNo more than {settings.limit_warn} requests per minute.',\n\t            dependencies=[\n\t                          Depends(allowed_all_roles_access),\n\t                          Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))\n\t                          ],\n\t            response_model=ImageResponse\n\t            )\n\tasync def get_image(\n\t                    image_id: int = Path(ge=1),\n", "                    db: Session = Depends(get_db),\n\t                    current_user: dict = Depends(AuthUser.get_current_user),\n\t                    credentials: HTTPAuthorizationCredentials = Security(security)\n\t                    ) -> Optional[Image]:\n\t    \"\"\"\n\t    The get_image function is used to retrieve a single image from the database.\n\t    The function takes in an image_id, which is the id of the desired image. The function also takes in a db session,\n\t    which will be used to query for images within the database. The current_user and credentials are required by FastAPI's\n\t    security system.\n\t    :param image_id: int: Get the image id from the path\n", "    :param db: Session: Get a database session\n\t    :param current_user: dict: Get the current user\n\t    :param credentials: HTTPAuthorizationCredentials: Validate the authentication token\n\t    :return: A single image object\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    image = await repository_images.get_image(image_id, current_user, db)\n\t    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\t    return image\n", "@router.post(\n\t            '/',\n\t            description=f'Create image.\\nNo more than {settings.limit_warn} requests per minute.',\n\t            dependencies=[\n\t                          Depends(allowed_all_roles_access),\n\t                          Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))\n\t                          ],\n\t            response_model=ImageResponse\n\t            )\n\tasync def create_image(\n", "                       description: str = '-',\n\t                       tags: str = '',\n\t                       file: UploadFile = File(),\n\t                       db: Session = Depends(get_db),\n\t                       current_user: dict = Depends(AuthUser.get_current_user),\n\t                       credentials: HTTPAuthorizationCredentials = Security(security)\n\t                       ) -> Image:\n\t    \"\"\"\n\t    The create_image function creates a new image in the database.\n\t    :param description: str: Set the description of the image\n", "    :param tags: str: Pass the tags for the image\n\t    :param file: UploadFile: Upload the file to cloudinary\n\t    :param db: Session: Access the database\n\t    :param current_user: dict: Get the current user from the database\n\t    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n\t    :return: The created image object\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    public_id = CloudImage.generate_name_image(current_user.get('email'), file.filename)\n\t    r = CloudImage.image_upload(file.file, public_id)\n", "    src_url = CloudImage.get_url_for_image(public_id, r)\n\t    body = {\n\t            'description': description,\n\t            'link': src_url,\n\t            'tags': tags\n\t            }\n\t    image = await repository_images.create_image(body, current_user.get('id'), db, settings.tags_limit)\n\t    return image\n\t@router.delete(\n\t               '/{image_id}',\n", "               description=f'Remove image.\\nNo more than {settings.limit_crit} requests per minute.',\n\t               dependencies=[\n\t                             Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))\n\t                             ],\n\t               response_model=MessageResponse\n\t               )\n\tasync def remove_image(\n\t                       image_id: int = Path(ge=1),\n\t                       db: Session = Depends(get_db),\n\t                       current_user: dict = Depends(AuthUser.get_current_user),\n", "                       credentials: HTTPAuthorizationCredentials = Security(security)\n\t                       ) -> dict:\n\t    \"\"\"\n\t    The remove_image function is used to remove an image from the database.\n\t    The function takes in a required image_id parameter, which is the id of the image that will be removed.\n\t    The function also takes in a db parameter, which is used to access and modify data within our database.\n\t    This db parameter uses Depends(get_db) as its default value, meaning it will use get_db() as its default value if no other value for this paramter is provided when calling this function.\n\t    :param image_id: int: Specify the id of the image to be removed\n\t    :param db: Session: Pass the database connection to the function\n\t    :param current_user: dict: Get the current user information\n", "    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n\t    :return: A dict with a key &quot;message&quot; and value of the message\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    message = await repository_images.remove_image(image_id, current_user, db)\n\t    return message\n\t@router.put(\n\t            '/{image_id}',\n\t            description=f'Update image.\\nNo more than {settings.limit_crit} requests per minute.',\n\t            dependencies=[Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n", "                          ],\n\t            response_model=ImageResponse\n\t            )\n\tasync def update_image(\n\t                       body: ImageModel,\n\t                       image_id: int = Path(ge=1),\n\t                       db: Session = Depends(get_db),\n\t                       current_user: dict = Depends(AuthUser.get_current_user),\n\t                       credentials: HTTPAuthorizationCredentials = Security(security)\n\t                       ) -> Image:\n", "    \"\"\"\n\t    The update_image function updates an image in the database.\n\t    :param body: ImageModel: Validate the data sent in the request body\n\t    :param image_id: int: Get the image id from the path\n\t    :param db: Session: Get the database session\n\t    :param current_user: dict: Get the current user information\n\t    :param credentials: HTTPAuthorizationCredentials: Check if the user is authenticated\n\t    :return: The updated image\n\t    :doc-author: Trelent\n\t    \"\"\"\n", "    image = await repository_images.update_image(image_id, body, current_user, db, settings.tags_limit)\n\t    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\t    return image\n\t@router.get(\n\t            '/search_bytag/{tag_name}',\n\t            description=f'Get images by tag.\\nNo more than {settings.limit_warn} requests per minute.',\n\t            dependencies=[\n\t                          Depends(allowed_all_roles_access),\n\t                          Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))\n", "                          ],\n\t            response_model=List[ImageResponse]\n\t            )\n\tasync def get_image_by_tag_name(\n\t                                tag_name: str,\n\t                                sort_direction: SortDirection,\n\t                                db: Session = Depends(get_db),\n\t                                current_user: dict = Depends(AuthUser.get_current_user),\n\t                                credentials: HTTPAuthorizationCredentials = Security(security)\n\t                                ) -> List[Image]:\n", "    \"\"\"\n\t    The get_image_by_tag_name function returns a list of images that have the tag name specified in the request.\n\t    The function takes three parameters:\n\t    - tag_name: The name of the tag to search for. This is a required parameter and must be passed as part of\n\t    the URL path (e.g., /images/tags/{tag_name}). It is also validated by FastAPI to ensure it meets\n\t    certain criteria, such as being non-empty and not exceeding 255 characters in length.\n\t    :param tag_name: str: Specify the tag name to search for\n\t    :param sort_direction: SortDirection: Sort the images by date\n\t    :param db: Session: Get the database session\n\t    :param current_user: dict: Get the current user from the database\n", "    :param credentials: HTTPAuthorizationCredentials: Validate the token\n\t    :return: A list of images\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    tag = await repository_tags.get_tag_by_name(tag_name, db)\n\t    if tag is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_TAG_NOT_FOUND)\n\t    images = await repository_images.get_images_by_tag(tag, sort_direction, db)\n\t    if images is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n", "    return images\n\t@router.get(\n\t            '/search_byuser/{user_id}',\n\t            description=f'Get images by user_id.\\nNo more than {settings.limit_warn} requests per minute.',\n\t            dependencies=[\n\t                          Depends(allowed_admin_moderator),\n\t                          Depends(RateLimiter(times=settings.limit_warn, seconds=settings.limit_crit_timer))\n\t                          ],\n\t            response_model=List[ImageResponse]\n\t            )\n", "async def get_image_by_user(\n\t                            user_id: int,\n\t                            sort_direction: SortDirection,\n\t                            db: Session = Depends(get_db),\n\t                            current_user: dict = Depends(AuthUser.get_current_user),\n\t                            credentials: HTTPAuthorizationCredentials = Security(security)\n\t                            ) -> List[Image]:\n\t    \"\"\"\n\t    The get_image_by_user function returns a list of images that are associated with the user_id provided.\n\t    The function will return an HTTP 404 error if no image is found or if the user_id does not exist.\n", "    :param user_id: int: Get the user id from the url\n\t    :param sort_direction: SortDirection: Sort the images by date in ascending or descending order\n\t    :param db: Session: Get the database session\n\t    :param current_user: dict: Get the current user's id\n\t    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n\t    :return: A list of images\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    user = await repository_users.get_user_by_id(user_id, db)\n\t    if user is None:\n", "        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\t    images = await repository_images.get_images_by_user(user_id, sort_direction, db)\n\t    if not any(images):\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\t    return images\n\tadd_pagination(router)\n"]}
{"filename": "src/routes/ratings.py", "chunked_list": ["from typing import Optional, List\n\tfrom fastapi import APIRouter, Depends, Path, Security, HTTPException, status\n\tfrom fastapi.security import HTTPAuthorizationCredentials\n\tfrom fastapi_limiter.depends import RateLimiter\n\tfrom sqlalchemy.orm import Session\n\tfrom src.conf import messages\n\tfrom src.conf.config import settings\n\tfrom src.database.db import get_db\n\tfrom src.database.models import Rating\n\tfrom src.schemas.images import RatingResponse, RatingModel\n", "from src.schemas.users import MessageResponse\n\tfrom src.services.auth import AuthUser, security\n\tfrom src.services.roles import allowed_all_roles_access, allowed_admin_moderator\n\tfrom src.repository import images as repository_images\n\tfrom src.repository import ratings as repository_ratings\n\trouter = APIRouter(prefix='/rating', tags=['ratings'])\n\t@router.post(\n\t             '/{image_id}',\n\t             description=f'Add rating.\\nCan rate for an image only once.',\n\t             dependencies=[\n", "                           Depends(allowed_all_roles_access),\n\t                           Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n\t                           ],\n\t             response_model=RatingResponse\n\t             )\n\tasync def add_rating(\n\t                     body: RatingModel,\n\t                     image_id: int = Path(ge=1),\n\t                     db: Session = Depends(get_db),\n\t                     current_user: dict = Depends(AuthUser.get_current_user),\n", "                     credentials: HTTPAuthorizationCredentials = Security(security)\n\t                     ) -> RatingResponse:\n\t    image = await repository_images.get_image(image_id, current_user, db)\n\t    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\t    existing_rating = db.query(Rating).filter_by(user_id=current_user['id'], image_id=image_id).first()\n\t    if existing_rating:\n\t        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=messages.MSC400_ALREADY_RATED)\n\t    if image.user_id == current_user['id']:\n\t        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=messages.OWN_RATING)\n", "    rating = await repository_ratings.add_rating(body, image_id, current_user, db)\n\t    return rating\n\t@router.get(\n\t            '/{image_id}',\n\t            description=f'Get all ratings for image.\\nNo more than {settings.limit_crit} requests per minute.',\n\t            dependencies=[\n\t                          Depends(allowed_admin_moderator),\n\t                          Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n\t                          ],\n\t            response_model=List[RatingResponse]\n", "            )\n\tasync def get_ratings(\n\t                      image_id: int = Path(ge=1),\n\t                      db: Session = Depends(get_db),\n\t                      current_user: dict = Depends(AuthUser.get_current_user),\n\t                      credentials: HTTPAuthorizationCredentials = Security(security)\n\t                      ) -> List[RatingResponse]:\n\t    image = await repository_images.get_image(image_id, current_user, db)\n\t    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n", "    ratings = await repository_ratings.get_ratings(image_id, db)\n\t    return ratings\n\t@router.delete(\n\t               '/{rating_id}',\n\t               description=f'Delete rating.\\nNo more than {settings.limit_crit} requests per minute.',\n\t               dependencies=[\n\t                             Depends(allowed_admin_moderator),\n\t                             Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n\t                             ],\n\t               response_model=MessageResponse\n", "               )\n\tasync def remove_rating(\n\t                        rating_id: int = Path(ge=1),\n\t                        db: Session = Depends(get_db),\n\t                        current_user: dict = Depends(AuthUser.get_current_user),\n\t                        credentials: HTTPAuthorizationCredentials = Security(security)\n\t                        ) -> dict:\n\t    message = await repository_ratings.remove_rating(rating_id, current_user, db)\n\t    return message\n"]}
{"filename": "src/routes/auth.py", "chunked_list": ["from fastapi import (\n\t                     APIRouter,\n\t                     BackgroundTasks,\n\t                     Depends,\n\t                     HTTPException,\n\t                     Request,\n\t                     status,\n\t                     Security,\n\t                     )\n\tfrom fastapi.responses import HTMLResponse\n", "from fastapi.security import HTTPAuthorizationCredentials, OAuth2PasswordRequestForm\n\tfrom fastapi.templating import Jinja2Templates\n\tfrom starlette.responses import RedirectResponse\n\tfrom starlette.templating import _TemplateResponse\n\tfrom sqlalchemy.orm import Session\n\tfrom src.conf import messages\n\tfrom src.database.db import get_db\n\tfrom src.database.models import User\n\tfrom src.repository import users as repository_users\n\tfrom src.schemas.users import MessageResponse, RequestEmail, Token, UserModel, UserResponse\n", "from src.services.auth import AuthPassword, AuthToken, AuthUser, security\n\tfrom src.services.email import send_email, send_new_password, send_reset_password\n\trouter = APIRouter(prefix='/auth', tags=['auth'])\n\ttemplates = Jinja2Templates(directory='src/services/templates')\n\t@router.post('/signup', response_model=UserResponse, status_code=status.HTTP_201_CREATED,\n\t             description='Create new user')\n\tasync def sign_up(\n\t                  body: UserModel,\n\t                  background_tasks: BackgroundTasks,\n\t                  request: Request,\n", "                  db: Session = Depends(get_db)\n\t                  ) -> User:\n\t    \"\"\"\n\t    The sign_up function creates a new user in the database.\n\t    :param body: UserModel: Get the data from the request body\n\t    :param background_tasks: BackgroundTasks: Add a task to the background queue\n\t    :param request: Request: Get the base_url of the application\n\t    :param db: Session: Get the database session and pass it to the repository layer\n\t    :return: The new user created\n\t    :doc-author: Trelent\n", "    \"\"\"\n\t    check_user = await repository_users.get_user_by_email(body.email, db)\n\t    if check_user:\n\t        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=messages.MSC409_CONFLICT)\n\t    body.password = AuthPassword.get_hash_password(body.password)\n\t    new_user = await repository_users.create_user(body, db)\n\t    background_tasks.add_task(send_email, new_user.email, new_user.username, str(request.base_url))\n\t    return new_user\n\t@router.post('/login', response_model=Token)\n\tasync def login(body: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)) -> dict:\n", "    \"\"\"\n\t    The login function is used to authenticate a user.\n\t        It takes the username and password from the request body,\n\t        checks if they are correct, and returns an access token.\n\t    :param body: OAuth2PasswordRequestForm: Get the username and password from the request body\n\t    :param db: Session: Get a database session\n\t    :return: A new access token and a refresh token\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    user = await repository_users.get_user_by_email(body.username, db)\n", "    if user is None:\n\t        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=messages.MSC401_EMAIL)\n\t    if not AuthPassword.verify_password(body.password, user.password):\n\t        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=messages.MSC401_PASSWORD)\n\t    if not user.confirmed:\n\t        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=messages.MSC401_EMAIL_UNKNOWN)\n\t    access_token = await AuthToken.create_token(data={'sub': user.email}, token_type='access_token')\n\t    refresh_token = await AuthToken.create_token(data={'sub': user.email}, token_type='refresh_token')\n\t    await repository_users.update_token(user, refresh_token, db)\n\t    return {'access_token': access_token, 'refresh_token': refresh_token, 'token_type': messages.TOKEN_TYPE}\n", "@router.get(\"/logout\", response_class=HTMLResponse)\n\tasync def logout(\n\t           credentials: HTTPAuthorizationCredentials = Security(security),\n\t           current_user: dict = Depends(AuthUser.logout_user)\n\t           ) -> RedirectResponse:\n\t    \"\"\"\n\t    The logout function is used to logout a user from the system.\n\t    :param credentials: HTTPAuthorizationCredentials: Get the credentials of the user\n\t    :param current_user: dict: Get the current user from the database\n\t    :return: A redirectresponse object with a status code of 205\n", "    :doc-author: Trelent\n\t    \"\"\"\n\t    resp = RedirectResponse(url=\"/login\", status_code=status.HTTP_205_RESET_CONTENT)\n\t    return resp\n\t@router.get('/refresh_token', response_model=Token)\n\tasync def refresh_token(\n\t                        credentials: HTTPAuthorizationCredentials = Security(security),\n\t                        db: Session = Depends(get_db)\n\t                        ) -> dict:\n\t    \"\"\"\n", "    The refresh_token function is used to refresh the access_token.\n\t        The function takes in a token and an email, then checks if the user exists.\n\t        If so, it creates new tokens for that user and returns them.\n\t    :param credentials: HTTPAuthorizationCredentials: Get the token from the request header\n\t    :param db: Session: Access the database\n\t    :return: A new access_token and refresh_token\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    token = credentials.credentials\n\t    email = await AuthToken.get_email_from_token(token, 'refresh_token')\n", "    user = await repository_users.get_user_by_email(email, db)\n\t    if user.refresh_token != token:\n\t        await repository_users.update_token(user, None, db)\n\t        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=messages.MSC401_TOKEN)\n\t    access_token = await AuthToken.create_token(data={'sub': user.email}, token_type='access_token')\n\t    refresh_token = await AuthToken.create_token(data={'sub': user.email}, token_type='refresh_token')\n\t    await repository_users.update_token(user, refresh_token, db)\n\t    return {'access_token': access_token, 'refresh_token': refresh_token, 'token_type': messages.TOKEN_TYPE}\n\t@router.post('/request_confirm_email', response_model=MessageResponse)\n\tasync def request_confirm_email(\n", "                                body: RequestEmail,\n\t                                background_tasks: BackgroundTasks,\n\t                                request: Request,\n\t                                db: Session = Depends(get_db)\n\t                                ) -> dict:\n\t    \"\"\"\n\t    The request_confirm_email function is used to send a confirmation email to the user.\n\t        The function takes in an email address and sends a confirmation link to that address.\n\t        If the user already has an account, they will be sent another confirmation link.\n\t    :param body: RequestEmail: Get the email address from the request body\n", "    :param background_tasks: BackgroundTasks: Add a task to the background\n\t    :param request: Request: Get the base_url of the application\n\t    :param db: Session: Get a database session from the dependency injection container\n\t    :return: A dictionary with a message\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    user = await repository_users.get_user_by_email(body.email, db)\n\t    if user and user.confirmed:\n\t        return {'message': messages.EMAIL_ERROR_CONFIRMED}\n\t    if user:\n", "        background_tasks.add_task(send_email, user.email, user.username, request.base_url)\n\t    return {'message': messages.EMAIL_INFO_CONFIRMED}\n\t@router.get('/confirmed_email/{token}', response_model=MessageResponse)\n\tasync def confirmed_email(token: str, db: Session = Depends(get_db)) -> dict:\n\t    \"\"\"\n\t    The confirmed_email function is used to confirm the email of a user.\n\t        It takes in a token and returns an object with the message 'Email confirmed' if successful.\n\t    :param token: str: Get the email from the token\n\t    :param db: Session: Get a database session\n\t    :return: A dictionary with a message\n", "    :doc-author: Trelent\n\t    \"\"\"\n\t    email = await AuthToken.get_email_from_token(token)\n\t    user = await repository_users.get_user_by_email(email, db)\n\t    if user is None:\n\t        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=messages.MSC400_BAD_REQUEST)\n\t    if user.confirmed:\n\t        return {'message': messages.EMAIL_ERROR_CONFIRMED}\n\t    await repository_users.confirmed_email(user, db)\n\t    return {'message': messages.EMAIL_INFO_CONFIRM}\n", "@router.post('/reset-password')\n\tasync def reset_password(\n\t                         body: RequestEmail,\n\t                         background_tasks: BackgroundTasks,\n\t                         request: Request,\n\t                         db: Session = Depends(get_db)\n\t                         ) -> dict:\n\t    \"\"\"\n\t    The reset_password function is used to send a password reset email to the user.\n\t        The function takes in an email address and sends a password reset link to that\n", "        address if it exists in the database. If not, then an error message is returned.\n\t    :param body: RequestEmail: Receive the email from the user\n\t    :param background_tasks: BackgroundTasks: Add a task to the background tasks queue\n\t    :param request: Request: Get the base_url of the application\n\t    :param db: Session: Get the database session\n\t    :return: A message to the user\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    user = await repository_users.get_user_by_email(body.email, db)\n\t    if user:\n", "        if user.confirmed:\n\t            background_tasks.add_task(send_reset_password, user.email, user.username, request.base_url)\n\t            return {'message': messages.MSG_SENT_PASSWORD}\n\t        return {'message': messages.EMAIL_INFO_CONFIRMED}\n\t    return {'message': messages.MSC401_EMAIL_UNKNOWN}\n\t@router.get('/reset-password/done_request', response_class=HTMLResponse, description='Request password reset Page.')\n\tasync def reset_password_done(request: Request) -> _TemplateResponse:\n\t    \"\"\"\n\t    The reset_password_done function is called when the user clicks on the link in their email.\n\t    It displays a message that says `Your password has been reset.`\n", "    :param request: Request: Get the request object\n\t    :return: A templateresponse object\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    return templates.TemplateResponse('password_reset_done.html', {'request': request,\n\t                                                                   'title': messages.MSG_SENT_PASSWORD})\n\t@router.post('/reset-password/confirm/{token}')\n\tasync def reset_password_confirm(\n\t                                 background_tasks: BackgroundTasks,\n\t                                 request: Request,\n", "                                 token: str,\n\t                                 db: Session = Depends(get_db)\n\t                                 ) -> dict:\n\t    \"\"\"\n\t    The reset_password_confirm function is used to reset a user's password.\n\t        It takes the following parameters:\n\t            background_tasks: BackgroundTasks,\n\t            request: Request,\n\t            token: str,\n\t            db: Session = Depends(get_db)\n", "    :param background_tasks: BackgroundTasks: Add a background task to the queue\n\t    :param request: Request: Get the base_url of the application\n\t    :param token: str: Get the email from the token\n\t    :param db: Session: Get the database session\n\t    :return: A dict with the user and a message\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    email: str = await AuthToken.get_email_from_token(token)\n\t    exist_user = await repository_users.get_user_by_email(email, db)\n\t    if not exist_user:\n", "        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n\t                            detail=messages.MSC503_UNKNOWN_USER)\n\t    new_password: str = AuthPassword.get_new_password()\n\t    password: str = AuthPassword.get_hash_password(new_password)\n\t    updated_user: User = await repository_users.change_password_for_user(exist_user, password, db)\n\t    if updated_user is None:\n\t        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n\t                            detail=messages.MSC503_UNKNOWN_USER)\n\t    background_tasks.add_task(\n\t                              send_new_password,\n", "                              updated_user.email,\n\t                              updated_user.username,\n\t                              request.base_url,\n\t                              new_password\n\t                              )\n\t    return {'user': updated_user, 'detail': messages.MSG_PASSWORD_CHENGED}\n\t@router.get('/reset-password/complete', response_class=HTMLResponse, description='Complete password reset Page.')\n\tasync def reset_password_complete(request: Request) -> _TemplateResponse:\n\t    \"\"\"\n\t    The reset_password_complete function is called when the user has successfully reset their password.\n", "    It renders a template that informs the user of this fact.\n\t    :param request: Request: Get the request object\n\t    :return: The password_reset_complete\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    return templates.TemplateResponse('password_reset_complete.html', {'request': request,\n\t                                                                       'title': messages.MSG_PASSWORD_RESET})\n"]}
{"filename": "src/routes/users.py", "chunked_list": ["from typing import Optional\n\tfrom fastapi import APIRouter, Depends, HTTPException, Security, status, UploadFile, File\n\tfrom fastapi.security import HTTPAuthorizationCredentials\n\tfrom sqlalchemy.orm import Session\n\tfrom src.conf import messages\n\tfrom src.database.db import get_db\n\tfrom src.database.models import User\n\tfrom src.repository import users as repository_users\n\tfrom src.schemas.users import UserDb, UserResponseFull, UserType, UserBase\n\tfrom src.services.auth import AuthUser, security\n", "from src.services.images import CloudImage\n\tfrom src.services.roles import allowed_admin_moderator\n\trouter = APIRouter(prefix='/users', tags=['users'])\n\t@router.get('/me', response_model=UserDb, name='Get user info')\n\tasync def read_users_me(\n\t                        current_user: dict = Depends(AuthUser.get_current_user),\n\t                        credentials: HTTPAuthorizationCredentials = Security(security),\n\t                        db: Session = Depends(get_db)\n\t                        ) -> User:\n\t    \"\"\"\n", "    The read_users_me function is a GET request that returns the current user's information.\n\t    The function requires an authorization header with a valid JWT token to be passed in order for it to work.\n\t    :param current_user: dict: Get the current user from the database\n\t    :param credentials: HTTPAuthorizationCredentials: Validate the security scheme\n\t    :param db: Session: Pass the database session to the repository layer\n\t    :return: The user object of the currently logged in user\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    return await repository_users.get_user_by_id(current_user.get('id'), db)\n\t@router.get('/{user_id}', response_model=UserResponseFull, name='Get user info by id')\n", "async def read_user_by_id(\n\t                          user_id: int,\n\t                          current_user: dict = Depends(AuthUser.get_current_user),\n\t                          credentials: HTTPAuthorizationCredentials = Security(security),\n\t                          db: Session = Depends(get_db)\n\t                          ) -> dict:\n\t    \"\"\"\n\t    The read_user_by_id function reads a user by its id.\n\t    :param user_id: int: Get the user id from the url\n\t    :param current_user: dict: Get the current user\n", "    :param credentials: HTTPAuthorizationCredentials: Validate the token in the header of the request\n\t    :param db: Session: Pass the database session to the repository layer\n\t    :return: A dictionary with the user information\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    user = await repository_users.get_user_by_id(user_id, db)\n\t    if not user:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\t    user.number_images = await repository_users.get_number_of_images_per_user(user.email, db)\n\t    return user\n", "@router.put('/{user_id}', response_model=UserDb)\n\tasync def update_user_profile(\n\t                              user_id: int,\n\t                              body: UserType,\n\t                              current_user: dict = Depends(AuthUser.get_current_user),\n\t                              credentials: HTTPAuthorizationCredentials = Security(security),\n\t                              db: Session = Depends(get_db)\n\t                              ) -> User:\n\t    \"\"\"\n\t    The update_user_profile function updates the user profile.\n", "        Args:\n\t            user_id (int): The id of the user to update.\n\t            body (UserType): The updated information for the specified user.\n\t    :param user_id: int: Identify the user to be deleted\n\t    :param body: UserType: Validate the data sent by the user\n\t    :param current_user: dict: Get the current user\n\t    :param credentials: HTTPAuthorizationCredentials: Validate the token\n\t    :param db: Session: Access the database\n\t    :return: A user object\n\t    :doc-author: Trelent\n", "    \"\"\"\n\t    user = await repository_users.update_user_profile(user_id, current_user, body, db)\n\t    if not user:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\t    return user\n\t@router.put('/me/{user_id}', response_model=UserDb)\n\tasync def update_your_profile(\n\t                              user_id: int,\n\t                              body: Optional[UserBase] = None,\n\t                              current_user: dict = Depends(AuthUser.get_current_user),\n", "                              credentials: HTTPAuthorizationCredentials = Security(security),\n\t                              db: Session = Depends(get_db)\n\t                              ) -> User:\n\t    \"\"\"\n\t    The update_your_profile function updates the current user's profile.\n\t        Args:\n\t            user_id (int): The id of the user to update.\n\t            body (UserBase): The updated information for the User object.\n\t    :param user_id: int: Identify the user\n\t    :param body: UserBase: Get the data from the request body\n", "    :param current_user: dict: Get the current user's email\n\t    :param credentials: HTTPAuthorizationCredentials: Check the token\n\t    :param db: Session: Access the database\n\t    :return: The user object\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    user = await repository_users.update_your_profile(current_user.get('email'), body, db)\n\t    if not user:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\t    return user\n", "@router.patch('/avatar', response_model=UserDb)\n\tasync def update_avatar_user(\n\t                             file: UploadFile = File(),\n\t                             current_user: dict = Depends(AuthUser.get_current_user),\n\t                             credentials: HTTPAuthorizationCredentials = Security(security),\n\t                             db: Session = Depends(get_db)\n\t                             ) -> User:\n\t    \"\"\"\n\t    The update_avatar_user function updates the avatar of a user.\n\t        The function takes in an UploadFile object (picture), which is a file that has been uploaded to the server.\n", "        It also takes in current_user and credentials as dependencies, which are used for authentication purposes.\n\t        Finally it takes in db as a dependency, which is used to access the database.\n\t    :param file: UploadFile: Upload the file to the cloud\n\t    :param current_user: dict: Get the current user's email\n\t    :param credentials: HTTPAuthorizationCredentials: Validate the token\n\t    :param db: Session: Access the database\n\t    :return: The user data\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    src_url = CloudImage.avatar_upload(file.file, current_user.get('email'))\n", "    user = await repository_users.update_avatar(current_user.get('email'), src_url, db)\n\t    if not user:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\t    return user\n\t@router.patch(\n\t              '/ban_user/{user_id}/{active_status}', response_model=UserDb,\n\t              dependencies=[Depends(allowed_admin_moderator)],\n\t              description='Ban/unban user'\n\t              )\n\tasync def ban_user(\n", "                   user_id: int,\n\t                   active_status: bool,\n\t                   current_user: dict = Depends(AuthUser.get_current_user),\n\t                   credentials: HTTPAuthorizationCredentials = Security(security),\n\t                   db: Session = Depends(get_db)\n\t                   ) -> User:\n\t    \"\"\"\n\t    The ban_user function is used to ban a user from the system.\n\t    :param user_id: int: Identify the user to be banned\n\t    :param active_status: bool: Set the user's status to active or inactive\n", "    :param current_user: dict: Get the current user from the authuser class\n\t    :param db: Session: Access the database\n\t    :return: The banned user object\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    user: Optional[User] = await repository_users.ban_user(user_id, active_status, db)\n\t    if not user:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_USER_NOT_FOUND)\n\t    await AuthUser.clear_user_cash(user.email)\n\t    return user\n"]}
{"filename": "src/routes/comments.py", "chunked_list": ["from typing import Optional, List\n\tfrom fastapi import APIRouter, Depends, HTTPException, Path, Security, status\n\tfrom fastapi_limiter.depends import RateLimiter\n\tfrom fastapi.security import HTTPAuthorizationCredentials\n\tfrom sqlalchemy.orm import Session\n\tfrom src.schemas.users import MessageResponse\n\tfrom src.conf.config import settings\n\tfrom src.conf import messages\n\tfrom src.database.db import get_db\n\tfrom src.database.models import Comment\n", "from src.repository import images as repository_images\n\tfrom src.repository import comments as repository_comments\n\tfrom src.schemas.images import CommentModel, CommentResponse\n\tfrom src.services.auth import AuthUser, security\n\tfrom src.services.roles import allowed_all_roles_access, allowed_admin_moderator\n\trouter = APIRouter(prefix='/comment', tags=['comments'])\n\t@router.get(\n\t    '/{image_id}',\n\t    description=f'Get all comments on image.\\nNo more than {settings.limit_crit} requests per minute.',\n\t    dependencies=[\n", "        Depends(allowed_all_roles_access),\n\t        Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n\t    ],\n\t    response_model=List[CommentResponse],\n\t)\n\tasync def get_comments_by_image_id(\n\t        image_id: int = Path(ge=1),\n\t        db: Session = Depends(get_db),\n\t        current_user: dict = Depends(AuthUser.get_current_user),\n\t        credentials: HTTPAuthorizationCredentials = Security(security)\n", "        ) -> List[Comment]:\n\t    \"\"\"\n\t    The get_comments_by_image_id function returns a list of comments for the image with the given id.\n\t    :param image_id: int: Get the comments of a specific image\n\t    :param db: Session: Get the database session\n\t    :param current_user: dict: Get the current user's information\n\t    :param credentials: HTTPAuthorizationCredentials: Validate the token\n\t    :return: The comments associated with the image\n\t    :doc-author: Trelent\n\t    \"\"\"\n", "    image = await repository_images.get_image(image_id, current_user, db)\n\t    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\t    return await repository_comments.get_comments(image_id, db)\n\t@router.post(\n\t    '/{image_id}',\n\t    description=f'Add comment.\\nNo more than {settings.limit_crit} requests per minute.',\n\t    dependencies=[\n\t        Depends(allowed_all_roles_access),\n\t        Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n", "    ],\n\t    response_model=CommentResponse,\n\t)\n\tasync def add_comment(\n\t        body: CommentModel,\n\t        image_id: int = Path(ge=1),\n\t        db: Session = Depends(get_db),\n\t        current_user: dict = Depends(AuthUser.get_current_user),\n\t        credentials: HTTPAuthorizationCredentials = Security(security)\n\t) -> Optional[Comment]:\n", "    \"\"\"\n\t    The add_comment function creates a new comment for an image.\n\t    The function takes in the following parameters:\n\t    body: CommentModel - A model containing the information of the comment to be created.\n\t    image_id: int - The id of the image that will have a new comment added to it. This is passed as part of\n\t    path parameter and must be greater than or equal to 1 (Path(ge=0)).\n\t    :param body: CommentModel: Get the body of the comment\n\t    :param image_id: int: Get the image_id from the url\n\t    :param db: Session: Get the database session\n\t    :param current_user: dict: Get the current user from the database\n", "    :param credentials: HTTPAuthorizationCredentials: Validate the token\n\t    :return: The created comment\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    image = await repository_images.get_image(image_id, current_user, db)\n\t    if image is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_IMAGE_NOT_FOUND)\n\t    comment = await repository_comments.add_comment(body, image_id, current_user, db)\n\t    return comment\n\t@router.put(\n", "            '/{comment_id}',\n\t            description=f'Update comment.\\nNo more than {settings.limit_crit} requests per minute.',\n\t            dependencies=[\n\t                Depends(allowed_all_roles_access),\n\t                Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n\t            ],\n\t            response_model=CommentResponse,\n\t             )\n\tasync def update_comment(\n\t                         body: CommentModel,\n", "                         comment_id: int = Path(ge=1),\n\t                         db: Session = Depends(get_db),\n\t                         current_user: dict = Depends(AuthUser.get_current_user),\n\t                         credentials: HTTPAuthorizationCredentials = Security(security)\n\t                         ) -> Comment:\n\t    \"\"\"\n\t    The update_comment function updates a comment in the database.\n\t    The function takes an id, body and current_user as parameters.\n\t    It returns a Comment object if successful.\n\t    :param body: CommentModel: Get the data from the request body\n", "    :param comment_id: int: Get the comment id of the comment to be deleted\n\t    :param db: Session: Get the database session\n\t    :param current_user: dict: Get the user information from authuser\n\t    :param credentials: HTTPAuthorizationCredentials: Check the token\n\t    :return: A comment object\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    comment = await repository_comments.update_comment(comment_id, body, current_user, db)\n\t    if comment is None:\n\t        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=messages.MSC404_COMMENT_NOT_FOUND)\n", "    return comment\n\t@router.delete(\n\t               '/{comment_id}',\n\t               description=f'Delete comment.\\nNo more than {settings.limit_crit} requests per minute.',\n\t               dependencies=[\n\t                             Depends(allowed_admin_moderator),\n\t                             Depends(RateLimiter(times=settings.limit_crit, seconds=settings.limit_crit_timer))\n\t                             ],\n\t               response_model=MessageResponse\n\t               )\n", "async def remove_comment(\n\t                         comment_id: int = Path(ge=1),\n\t                         db: Session = Depends(get_db),\n\t                         current_user: dict = Depends(AuthUser.get_current_user),\n\t                         credentials: HTTPAuthorizationCredentials = Security(security)\n\t                         ) -> dict:\n\t    \"\"\"\n\t    The remove_comment function removes a comment from the database.\n\t    The function takes in an integer representing the id of the comment to be removed,\n\t    and returns a dictionary containing information about whether or not it was successful.\n", "    :param comment_id: int: Get the comment id from the path\n\t    :param db: Session: Pass the database session to the function\n\t    :param current_user: dict: Get the current user information\n\t    :param credentials: HTTPAuthorizationCredentials: Authenticate the user\n\t    :return: A dict with the message key and value\n\t    :doc-author: Trelent\n\t    \"\"\"\n\t    message = await repository_comments.remove_comment(comment_id, current_user, db)\n\t    return message\n"]}
