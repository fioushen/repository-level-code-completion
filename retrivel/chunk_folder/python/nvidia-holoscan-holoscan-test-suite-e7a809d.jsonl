{"filename": "setup.py", "chunked_list": ["#!/usr/bin/env python\n\t# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\tfrom setuptools import setup\n\tsetup(\n\t    name=\"holoscan_test_suite\",\n\t    version=\"0.1\",\n\t    author=\"Patrick O'Grady\",\n", "    author_email=\"pogrady@nvidia.com\",\n\t    description=\"Tools used by Holoscan Test Suite.\",\n\t    packages=[\"holoscan_test_suite\"],\n\t    include_package_data = True,\n\t    package_data = {\"\": [\"test_image.png\"]},\n\t    entry_points=dict(\n\t        console_scripts=[\"show_test_pattern=holoscan_test_suite.show_test_pattern:main\"]\n\t    ),\n\t    install_requires=[\n\t        \"opencv-python\",\n", "        \"pyyaml\",\n\t    ],\n\t    zip_safe=False,\n\t)\n"]}
{"filename": "holoscan_test_suite/controls.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t#\n\t# See README.md for detailed information.\n\t# This module provides support for a few HTML UI elements, using a websocket and\n\t# JS to 1) send UI selections to the server and 2) for the server to provide\n\t# updated data for the UI.  All these controls write their values using\n\t# websocket broadcast requests, so any number of clients can connect and they'll\n", "# always see synchonized state.\n\timport flask_socketio\n\tfrom . import html_render\n\timport os\n\timport subprocess\n\timport traceback\n\tclass Runner:\n\t    \"\"\"\n\t    Runner manages a subprocess that is invoked by the UI, providing a way\n\t    for the user to start and stop the command and for stdout and stderr\n", "    from the process to appear on the UI.  Once the runner is constructed,\n\t    be sure and call \"(runner).set_control(ui_element)\" in order for stderr\n\t    and stdout to be displayed as expected.\n\t    \"\"\"\n\t    def __init__(self, reactor, app, command, env_update={}, cwd=None):\n\t        self._app = app\n\t        self._command = command\n\t        self._process = None\n\t        self._env_update = env_update\n\t        self._cwd = cwd\n", "        self._reactor = reactor\n\t    def set_control(self, control):\n\t        \"\"\"I don't set self._control in the\n\t        constructor so we're sure to get an\n\t        error if someone doesn't call set_control.\n\t        \"\"\"\n\t        self._control = control\n\t        self._control_name = control._control_name\n\t    def start(self):\n\t        if self._process is None:\n", "            # Clear the stdout/stderr displayed on the page\n\t            with self._app.test_request_context(\"/\"):\n\t                flask_socketio.emit(\n\t                    \"%s-reset\" % self._control_name,\n\t                    {\"control\": self._control_name},\n\t                    broadcast=True,\n\t                    namespace=\"/\",\n\t                )\n\t            self._start()\n\t        else:\n", "            print('Already started \"%s\" -- ignoring' % (self._command,))\n\t    def _start(self):\n\t        print('Starting \"%s\"' % (self._command,))\n\t        env = {}\n\t        env.update(os.environ)  # make a copy of the current environment\n\t        env.update(self._env_update)  # update it according to our prefs\n\t        self._stdout_r, self._stdout_w = os.pipe()\n\t        self._stderr_r, self._stderr_w = os.pipe()\n\t        self._reactor.register(self._stdout_r, self.stdout)\n\t        self._reactor.register(self._stderr_r, self.stderr)\n", "        try:\n\t            self._process = subprocess.Popen(\n\t                args=self._command,\n\t                env=env,\n\t                stdout=self._stdout_w,\n\t                stderr=self._stderr_w,\n\t                cwd=self._cwd,\n\t                bufsize=0,\n\t            )\n\t        except Exception as e:\n", "            s = traceback.format_exception(e)\n\t            l = \"\".join(s)\n\t            os.write(self._stderr_w, l.encode(\"utf-8\"))\n\t            print(l)\n\t        os.close(self._stdout_w)\n\t        self._stdout_w = -1\n\t        os.close(self._stderr_w)\n\t        self._stderr_w = -1\n\t    def stop(self):\n\t        if self._process is not None:\n", "            self._stop()\n\t        else:\n\t            print('Not currently running \"%s\" -- ignoring' % (self._command,))\n\t    def _stop(self):\n\t        process = self._process\n\t        self._process = None\n\t        print('Stopping \"%s\"' % (self._command,))\n\t        process.terminate()\n\t        timeout_s = 20\n\t        process.communicate(timeout=timeout_s)\n", "        if self._stdout_w != -1:\n\t            os.close(self._stdout_w)\n\t            self._stdout_w = -1\n\t        if self._stderr_w != -1:\n\t            os.close(self._stderr_w)\n\t            self._stderr_w = -1\n\t        self._control.stopped()\n\t    def update(self, state):\n\t        if state:\n\t            self.start()\n", "        else:\n\t            self.stop()\n\t        return self._process is not None\n\t    def stderr(self, event):\n\t        value = os.read(self._stderr_r, 8192).decode()\n\t        if len(value) == 0:\n\t            print(\"stderr closed.\")\n\t            self._reactor.unregister(self._stderr_r)\n\t            os.close(self._stderr_r)\n\t            if self._process is not None:\n", "                self.stop()\n\t            return\n\t        with self._app.test_request_context(\"/\"):\n\t            flask_socketio.emit(\n\t                \"%s-stderr\" % self._control_name,\n\t                {\"control\": self._control_name, \"value\": value},\n\t                broadcast=True,\n\t                namespace=\"/\",\n\t            )\n\t    def stdout(self, event):\n", "        value = os.read(self._stdout_r, 8192).decode()\n\t        if len(value) == 0:\n\t            print(\"stdout closed.\")\n\t            self._reactor.unregister(self._stdout_r)\n\t            os.close(self._stdout_r)\n\t            if self._process is not None:\n\t                self.stop()\n\t            return\n\t        with self._app.test_request_context(\"/\"):\n\t            flask_socketio.emit(\n", "                \"%s-stdout\" % self._control_name,\n\t                {\"control\": self._control_name, \"value\": value},\n\t                broadcast=True,\n\t                namespace=\"/\",\n\t            )\n\tclass Control:\n\t    \"\"\"\n\t    Superclass for UI elements that have these methods:\n\t    - render: creates the HTML (including the JS),\n\t    - request: callback when the UI requests the current value,\n", "    - update: callback when the UI wishes to change the value\n\t    - stopped: runner calls this when the process terminates\n\t    \"\"\"\n\t    def __init__(self, app, label, control_name):\n\t        self._app = app\n\t        self._label = label\n\t        self._control_name = control_name\n\t    def render(self, r):\n\t        \"\"\"\n\t        This method is used to create the HTML that\n", "        renders the control, along with javascript\n\t        support (e.g. so that this control can call\n\t        request() or update()).  The HTML this guy\n\t        generates is to be appended to the list\n\t        given in the parameter 'r'.\n\t        \"\"\"\n\t        pass\n\t    def request(self, control_name):\n\t        \"\"\"\n\t        When the UI wants to know what the\n", "        state of this control is, the framework\n\t        generates a call to request.\n\t        @returns a dict with a \"value\" field\n\t        that controls the state of the item\n\t        in the UI.  For example, a Checkbox\n\t        expects the value to be True or False:\n\t        @code\n\t            return {\n\t                \"value\": True # or False as appropriate\n\t            }\n", "        @endcode\n\t        Other control types may expect strings or\n\t        other data types.\n\t        \"\"\"\n\t        pass\n\t    def update(self, control_name, value):\n\t        \"\"\"\n\t        The framework calls this method\n\t        when the user changes the value\n\t        on the UI.  This method returns\n", "        a dict following the same spec\n\t        as the request method.\n\t        \"\"\"\n\t        pass\n\t    def stopped(self):\n\t        \"\"\"\n\t        Runner calls this when it detects the program\n\t        it's supervising has terminated; e.g. Checkbox uses\n\t        this to set the UI value to False (unchecking\n\t        the box on the UI).\n", "        \"\"\"\n\t        pass\n\tclass Checkbox(Control):\n\t    \"\"\"\n\t    Provides a Control which is rendered as a checkbox\n\t    and the value is \"True\" or \"False\"\n\t    \"\"\"\n\t    def __init__(\n\t        self, app, label, control_name, value=False, update=lambda value: value\n\t    ):\n", "        super(Checkbox, self).__init__(app, label, control_name)\n\t        self._value = value\n\t        self._update = update\n\t    def render(self, r):\n\t        \"\"\"\n\t        Provide the HTML that implements the checkbox, including\n\t        the Checkbox control and Javascript support code to keep\n\t        the value shown in the browser up to date.\n\t        \"\"\"\n\t        r.append(\n", "            [\n\t                # Render the input element itself in a disabled (grayed out) mode;\n\t                # we'll enable it when we get the current value from the server via js.\n\t                html_render.checkbox(\n\t                    self._label,\n\t                    attributes={\n\t                        \"disabled\": None,\n\t                        \"id\": self._control_name,\n\t                    },\n\t                ),\n", "                # Render a table--which is normally hidden--where we'll put the\n\t                # stdout and stderr generated when this control is activated.\n\t                html_render.table(\n\t                    [\n\t                        [\n\t                            \"stdout\",\n\t                            html_render.pre(\n\t                                html_render.div(\n\t                                    \"\",\n\t                                    attributes={\"id\": \"%s_stdout\" % self._control_name},\n", "                                ),\n\t                            ),\n\t                        ],\n\t                        [\n\t                            \"stderr\",\n\t                            html_render.pre(\n\t                                html_render.div(\n\t                                    \"\",\n\t                                    attributes={\"id\": \"%s_stderr\" % self._control_name},\n\t                                ),\n", "                            ),\n\t                        ],\n\t                    ],\n\t                    attributes={\"id\": f\"{self._control_name}_output\", \"hidden\": None},\n\t                ),\n\t                # Javascript support\n\t                html_render.javascript(\n\t                    f\"\"\"\n\t                // Make js variables that point to the checkbox and it's stdout/stderr fields.\n\t                const {self._control_name} = document.getElementById(\"{self._control_name}\");\n", "                const {self._control_name}_stdout = document.getElementById(\"{self._control_name}_stdout\");\n\t                const {self._control_name}_stderr = document.getElementById(\"{self._control_name}_stderr\");\n\t                const {self._control_name}_output = document.getElementById(\"{self._control_name}_output\");\n\t                // Request the initial value from the server.\n\t                socket.on(\"connect\", (event) => {{\n\t                    console.log(\"Requesting status: {self._control_name}\");\n\t                    socket.emit(\"request\", {{control: \"{self._control_name}\"}});\n\t                }});\n\t                // Handle updates (incl the initial value) from the server;\n\t                // update the control per the value and enable the control.\n", "                socket.on(\"{self._control_name}-value\", (event) => {{\n\t                    value = event.value;\n\t                    console.log(\"Value received, {self._control_name}=\" + value);\n\t                    {self._control_name}.checked = value;\n\t                    {self._control_name}.disabled = !event.enable;\n\t                }});\n\t                // When the user clicks this thing, send the new value to the server.\n\t                {self._control_name}.onclick = function() {{\n\t                    socket.emit(\"update\", {{value: this.checked, control: \"{self._control_name}\"}});\n\t                }};\n", "                // When the websocket closes, gray this thing out.\n\t                socket.on(\"disconnect\", (event) => {{\n\t                    console.log(\"Closing {self._control_name}\");\n\t                    {self._control_name}.disabled = true;\n\t                }});\n\t                // add to stdout\n\t                socket.on(\"{self._control_name}-stdout\", (event) => {{\n\t                    value = event.value;\n\t                    console.log(\"stdout received, {self._control_name}=\" + value);\n\t                    {self._control_name}_stdout.append(value);\n", "                    {self._control_name}_output.hidden = false;\n\t                }});\n\t                // add to stderr\n\t                socket.on(\"{self._control_name}-stderr\", (event) => {{\n\t                    value = event.value;\n\t                    console.log(\"stderr received, {self._control_name}=\" + value);\n\t                    {self._control_name}_stderr.append(value);\n\t                    {self._control_name}_output.hidden = false;\n\t                }});\n\t                // clear both stdout and stderr\n", "                socket.on(\"{self._control_name}-reset\", (event) => {{\n\t                    {self._control_name}_stdout.innerHTML = \"\";\n\t                    {self._control_name}_stderr.innerHTML = \"\";\n\t                    {self._control_name}_output.hidden = true;\n\t                }});\n\t            \"\"\"\n\t                ),\n\t            ]\n\t        )\n\t    def update(self, control_name, value):\n", "        r = self._update(value)\n\t        self._value = r\n\t        return {\n\t            \"control\": control_name,\n\t            \"value\": self._value,\n\t            \"enable\": True,\n\t        }\n\t    def request(self, control_name):\n\t        return {\n\t            \"control\": control_name,\n", "            \"value\": self._value,\n\t            \"enable\": True,\n\t        }\n\t    def stopped(self):\n\t        reply = self.update(self._control_name, False)\n\t        with self._app.test_request_context(\"/\"):\n\t            flask_socketio.emit(\n\t                \"%s-value\" % self._control_name,\n\t                reply,\n\t                broadcast=True,\n", "                namespace=\"/\",\n\t            )\n\tclass Status(Control):\n\t    \"\"\"\n\t    Renders as a static <div> where a value can be displayed.\n\t    Calling \"publish\" on this object will update the UI.\n\t    @code\n\t        value = \"whatever new value you want to display\"\n\t        status_object.publish({\"value\": value})\n\t    @endcode\n", "    \"\"\"\n\t    def __init__(self, app, label, control_name):\n\t        super(Status, self).__init__(app, label, control_name)\n\t    def render(self, r):\n\t        attributes = {\n\t            \"id\": self._control_name,\n\t            \"disabled\": None,\n\t        }\n\t        r.append(\n\t            [\n", "                self._label,\n\t                [\n\t                    html_render.pre(html_render.div(\"\", attributes=attributes)),\n\t                    # Javascript support\n\t                    html_render.javascript(\n\t                        f\"\"\"\n\t                    // Make a js variable that points to the checkbox.\n\t                    const {self._control_name} = document.getElementById(\"{self._control_name}\");\n\t                    // Request the initial value from the server.\n\t                    socket.on(\"connect\", (event) => {{\n", "                        console.log(\"Requesting status: {self._control_name}\");\n\t                        socket.emit(\"request\", {{control: \"{self._control_name}\"}});\n\t                    }});\n\t                    // Handle updates (incl the initial value) from the server;\n\t                    // update the control per the value and enable the control.\n\t                    socket.on(\"{self._control_name}-value\", (event) => {{\n\t                        value = event.value;\n\t                        console.log(\"Value received, {self._control_name}=\" + value);\n\t                        {self._control_name}.innerHTML = value;\n\t                        {self._control_name}.disabled = false;\n", "                    }});\n\t                    // When the websocket closes, gray this thing out.\n\t                    socket.on(\"disconnect\", (event) => {{\n\t                        console.log(\"Closing {self._control_name}\");\n\t                        {self._control_name}.disabled = true;\n\t                    }});\n\t                \"\"\"\n\t                    ),\n\t                ],\n\t            ]\n", "        )\n\t    def publish(self, value):\n\t        reply = {\n\t            \"control\": self._control_name,\n\t            \"enable\": True,\n\t        }\n\t        reply.update(value)\n\t        with self._app.test_request_context(\"/\"):\n\t            flask_socketio.emit(\n\t                \"%s-value\" % self._control_name,\n", "                reply,\n\t                broadcast=True,\n\t                namespace=\"/\",\n\t            )\n\t    def stopped(self):\n\t        pass\n"]}
{"filename": "holoscan_test_suite/html_render.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t#\n\t# See README.md for detailed information.\n\t#\n\t# html_render is a simple tool that creates e.g. HTML pages.  The idea is that\n\t# content is represented as a list of lists (which is really a tree) which is\n\t# flattened out at the very end, when the page is rendered.  In this way,\n", "# almost any content can be the content of other tags.  For example::\n\t#\n\t#       content = italic(\"Hello, world!\")\n\t#\n\t# content is now a list of [\"<i>\", \"Hello, world!\", \"</i>\"].  Use \"append\" to\n\t# add to that content:\n\t#\n\t#       content.append(\"This is normal\")\n\t#       content.append(bold(\"This is bold\"))\n\t#\n", "# content is now [\"<i>\", \"Hello, world!\", \"</i>\", \"This is normal\", [\"<b>\",\n\t# \"This is bold\", \"</b>\"]].  To make a well-formed HTML page out of this:\n\t#\n\t#       doc = html(body(content))\n\t#\n\t# doc is now [\"<html>\", [\"<body>\", [\"<i>\", \"Hello, world!\", \"</i>\", \"This is\n\t# normal\", [\"<b>\", \"This is bold\", \"</b>\"]], \"</body>\"], \"</html>\"] The flatten\n\t# routine adds each element from the given tree as found by a depth-first\n\t# traversal:\n\t#\n", "#       l = flatten([], doc)\n\t#\n\t# l is now [\"<html>\", \"<body>\", \"<i>\", \"Hello, world!\", \"</i>\", \"This is\n\t# normal\", \"<b>\", \"This is bold\", \"</b>\", \"</body>\", \"</html>\"].  More commonly,\n\t# use render to flatten then join the results into a single string:\n\t#\n\t#       r = render(doc)\n\t#\n\t# r is now\n\t# \"<html><body><i>Hello, world!</i>This is normal<b>This is bold</b></body></html>\"\n", "# Note that render(l) and render(doc) produce the same result,\n\t# because render does a flatten step first, which would have no effect on\n\t# an already-flattened list.\n\t#\n\tfrom html import escape\n\timport yaml\n\t#\n\t# HTML Support\n\t#\n\tdef flatten(r, tree):\n", "    \"\"\"Given a tree, append to list r the elements in a depth-first traversal.\n\t    Application code doesn't normally call this method; just use render.\n\t    \"\"\"\n\t    for element in tree:\n\t        if hasattr(element, \"html\"):\n\t            v = element.html()\n\t            flatten(r, v)\n\t            continue\n\t        if isinstance(element, list):\n\t            flatten(r, element)\n", "        else:\n\t            r.append(str(element))\n\t    return r\n\tdef render(tree):\n\t    \"\"\"Flatten the given tree then return it, joined together into a single\n\t    string.\n\t    \"\"\"\n\t    out = \"\".join(flatten([], tree))\n\t    return out\n\tdef tag(tag_name, style=None, attributes=None):\n", "    \"\"\"Return content for \"<tag attribute(s)... style=style(s)...>\"\n\t    with the given elements from the maps for style or attributes.\n\t    style or attributes can be None or {}, in which case\n\t    the relevant section is omitted.\n\t    \"\"\"\n\t    r = [\"<\", tag_name]\n\t    if (attributes is not None) and len(attributes):\n\t        for k, v in attributes.items():\n\t            if v is None:\n\t                r.append(\" %s\" % k)\n", "            else:\n\t                r.append(' %s=\"%s\"' % (k, escape(v)))\n\t    if (style is not None) and len(style):\n\t        r.append(' style=\"')\n\t        r.append(\";\".join(\"%s:%s\" % (k, v) for k, v in style.items()))\n\t        r.append('\"')\n\t    r.append(\">\")\n\t    return r\n\tdef link(content, url, style=None, attributes=None):\n\t    href = dict(attributes) if attributes is not None else {}\n", "    href[\"href\"] = url\n\t    return [tag(\"a\", style=style, attributes=href), content, \"</a>\"]\n\tdef paragraph(content, style=None):\n\t    return [tag(\"p\", style=style), content, \"</p>\"]\n\tdef horizontal_rule():\n\t    return \"<hr/>\"\n\tdef pre(content, style=None):\n\t    return [tag(\"pre\", style=style), content, \"</pre>\"]\n\tdef italic(content):\n\t    return [\"<i>\", content, \"</i>\"]\n", "def bold(content):\n\t    return [\"<b>\", content, \"</b>\"]\n\t# Stop chrome from trying to translate from Maltese\n\tdefault_html_attributes = {\n\t    \"lang\": \"en-US\",\n\t}\n\tdef html_start(attributes=default_html_attributes):\n\t    return [tag(\"html\", attributes=attributes)]\n\tdef html_end():\n\t    return [\"</html>\"]\n", "def html(content, attributes=default_html_attributes):\n\t    return [html_start(attributes), content, html_end()]\n\tdef body_start(attributes={}):\n\t    return [tag(\"body\", attributes=attributes)]\n\tdef body_end():\n\t    return [\"</body>\"]\n\tdef body(content, attributes={}):\n\t    return [body_start(attributes), content, body_end()]\n\tdef ul(items):\n\t    r = [\"<ul>\"]\n", "    for i in items:\n\t        r.append([\"<li>\", i, \"</li>\"])\n\t    r.append(\"</ul>\")\n\t    return r\n\tdef header(level, content, style=None, attributes=None):\n\t    return [\n\t        tag(\"h%s\" % level, style=style, attributes=attributes),\n\t        content,\n\t        \"</h%s>\" % level,\n\t    ]\n", "default_col_style = {\n\t    \"border\": \"1px solid #CCCCCC\",\n\t    \"padding-left\": \"5px\",\n\t    \"padding-right\": \"5px\",\n\t}\n\tdefault_table_style = {\n\t    \"border-collapse\": \"collapse\",\n\t}\n\tdef table(\n\t    rows, style=default_table_style, col_style=default_col_style, attributes=None\n", "):\n\t    r = []\n\t    for cols in rows:\n\t        this_row = [[tag(\"td\", col_style), c, \"</td>\"] for c in cols]\n\t        r.append([tag(\"tr\"), this_row, \"</tr>\"])\n\t    return [tag(\"table\", style=style, attributes=attributes), r, \"</table>\"]\n\tdef div(content, style=None, attributes=None):\n\t    return [tag(\"div\", style=style, attributes=attributes), content, \"</div>\"]\n\tdef script(content, style=None, attributes=None):\n\t    return [tag(\"script\", style=style, attributes=attributes), content, \"</script>\"]\n", "def javascript(content, style=None, attributes={}):\n\t    u = {\"type\": \"text/javascript\", \"charset\": \"utf-8\"}\n\t    u.update(attributes)\n\t    return script(content, style, u)\n\tdef checkbox(content, style=None, attributes={}):\n\t    t = {\n\t        \"type\": \"checkbox\",\n\t    }\n\t    t.update(attributes)\n\t    return [\n", "        tag(\"label\"),\n\t        tag(\"input\", style=style, attributes=t),\n\t        content,\n\t        \"</label>\",\n\t    ]\n\tdef _option(value, content, attributes={}):\n\t    n = {}\n\t    n.update(attributes)\n\t    n.update({\"value\": value})\n\t    return [\n", "        tag(\"option\", attributes=n),\n\t        content,\n\t        \"</option>\",\n\t    ]\n\tdef select(name, options, style=None, attributes={}):\n\t    options = [_option(value, content) for value, content in options.items()]\n\t    return [\n\t        tag(\"select\", style=style, attributes=attributes),\n\t        options,\n\t        \"</select>\",\n", "    ]\n\tdef _rtable(m):\n\t    \"\"\"Do a depth-first search of m, returning a list of rows for all\n\t    name/value pairs found in m.  If a particular value is a dict, then\n\t    recursively call _rtable on that value, then add the first row from that\n\t    with a new td showing the current name, rowspan'd for the length of the\n\t    inner table; then extend the current row list with the inner list.  IOW\n\t    you'll get a list returned with one element for each row, with extra\n\t    columns (with appropriate rowspans) to serve as headers as appropriate.\n\t    \"\"\"\n", "    rows = []\n\t    for name, value in m.items():\n\t        if isinstance(value, dict):\n\t            ir = _rtable(value)\n\t            if len(ir):\n\t                h = tag(\"td\", default_col_style, attributes={\"rowspan\": \"%d\" % len(ir)})\n\t                this_row = [h, name, \"</td>\", ir[0]]\n\t                rows.append(this_row)\n\t                rows.extend(ir[1:])\n\t            continue\n", "        elif isinstance(value, list):\n\t            for n, v in enumerate(value):\n\t                ir = _rtable(v)\n\t                h = tag(\"td\", default_col_style, attributes={\"rowspan\": \"%d\" % len(ir)})\n\t                this_row = [h, \"%s %s\" % (name, n), \"</td>\", ir[0]]\n\t                rows.append(this_row)\n\t                rows.extend(ir[1:])\n\t            continue\n\t        this_row = [[tag(\"td\", default_col_style), c, \"</td>\"] for c in (name, value)]\n\t        rows.append(this_row)\n", "    return rows\n\tdef rtable(m):\n\t    \"\"\"Given a multi-level map, e.g. {\"a\": {\"b\": \"YES\", \"c\": \"NO\"}}, produces an HTML\n\t    table where the higher level keys (\"a\" in this case) will rowspan in front\n\t    of the lower levels in the map (\"b\" and \"c\").\n\t    \"\"\"\n\t    rows = [[tag(\"tr\"), this_row, \"</tr>\"] for this_row in _rtable(m)]\n\t    table = [tag(\"table\", style=default_table_style), rows, \"</table>\"]\n\t    return table\n\tdef head(content):\n", "    return [\n\t        tag(\"head\"),\n\t        content,\n\t        \"</head>\",\n\t    ]\n\tdef style(element, options):\n\t    nv = [\"%s:%s;\" % (k, v) for k, v in options.items()]\n\t    return [\n\t        tag(\"style\"),\n\t        \"%s {\" % element,\n", "        nv,\n\t        \"}\",\n\t        \"</style>\",\n\t    ]\n\t#\n\t# Test report support\n\t#\n\tdef na(context, style=None):\n\t    return paragraph(\n\t        italic(\n", "            \"N/A: %s\" % context,\n\t        ),\n\t        style,\n\t    )\n\tclass Div:\n\t    def __init__(self, content=[], style=None, attributes=None):\n\t        self._content = content\n\t        self._style = style\n\t        self._attributes = attributes\n\t    def html(self):\n", "        return div(self._content, style=self._style, attributes=self._attributes)\n\t    def __str__(self):\n\t        return \"%s\" % self._content\n\t    def yaml(self, dumper):\n\t        return dumper.represent_data(self._content)\n\tyaml.add_representer(Div, lambda dumper, data: data.yaml(dumper))\n\tclass Link:\n\t    def __init__(self, content, url, style=None, attributes=None):\n\t        self._content = content\n\t        self._url = url\n", "        self._style = style\n\t        self._attributes = attributes\n\t    def html(self):\n\t        return link(\n\t            self._content, self._url, style=self._style, attributes=self._attributes\n\t        )\n\t    def __str__(self):\n\t        return \"%s\" % self._content\n\t    def yaml(self, dumper):\n\t        return dumper.represent_data(self._content)\n", "yaml.add_representer(Link, lambda dumper, data: data.yaml(dumper))\n\t# Include this guy in your doc to pull in websocket support.\n\tsocket_io_js = script(\n\t    attributes={\n\t        \"src\": \"https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js\",\n\t        \"integrity\": \"sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==\",\n\t        \"crossorigin\": \"anonymous\",\n\t    },\n\t    content=\"\",\n\t)\n"]}
{"filename": "holoscan_test_suite/show_test_pattern.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\timport argparse\n\timport cv2\n\timport holoscan_test_suite\n\timport os\n\timport signal\n", "import time\n\tdone = False\n\tdef set_done(*args):\n\t    global done\n\t    done = True\n\tsignal.signal(signal.SIGTERM, set_done)\n\tdef show_test_pattern(filename, display):\n\t    # We may be restarted via control_app.py\n\t    global done\n\t    done = False\n", "    # We only support 1920x1080.\n\t    columns = 1920\n\t    rows = 1080\n\t    #\n\t    image = cv2.imread(filename)  # BGRA\n\t    image_rows, image_columns, image_width = image.shape\n\t    assert image_rows == rows\n\t    assert image_columns == columns\n\t    # Mount an overlayfs so we can temporarily patch /etc/X11/xorg.conf.d.\n\t    print(\"Setting up overlayfs.\")\n", "    os.makedirs(\"/tmp/overlay/etc\", exist_ok=True)\n\t    os.makedirs(\"/tmp/overlay/work\", exist_ok=True)\n\t    s = \"/bin/mount -t overlay overlay -o lowerdir=/etc,upperdir=/tmp/overlay/etc,workdir=/tmp/overlay/work /etc\"\n\t    assert os.system(s) == 0\n\t    try:\n\t        # Write our special xorg.conf stanza that sets us up for 1920x1080 mode.\n\t        s = \"\"\"\n\tSection \"Screen\"\n\t    Identifier     \"Screen0\"\n\t    Device         \"Device0\"\n", "    Monitor        \"Monitor0\"\n\t    DefaultDepth    24\n\t    SubSection     \"Display\"\n\t        Depth       24\n\t    EndSubSection\n\t    Option \"ConnectedMonitor\" \"GPU-0.DP-7\"\n\t    Option \"CustomEDID\" \"GPU-0.DP-7:/etc/X11/edid.bin\"\n\t    Option \"MetaModes\" \"GPU-0.DP-7:1920x1080+0+0\"\n\tEndSection\n\t\"\"\"\n", "        with open(\"/etc/X11/xorg.conf.d/mgx.conf\", \"wt\") as f:\n\t            f.write(s)\n\t        # That stanza relies on /etc/X11/edid.bin.  Write that now.\n\t        # fmt: off\n\t        # (Without fmt:off, black will spread this out to one byte per line.)\n\t        # This EDID data was recorded using \"xrandr --props\" when the port\n\t        # was connected to a powered-on P3785.\n\t        edid = bytes([\n\t            0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x4D, 0xD9, 0x06, 0x5A, 0x01, 0x01, 0x01, 0x01,\n\t            0x1E, 0x1E, 0x01, 0x03, 0x80, 0x6F, 0x3E, 0x78, 0x0A, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,\n", "            0x0F, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n\t            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,\n\t            0x45, 0x00, 0x50, 0x1D, 0x74, 0x00, 0x00, 0x1E, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,\n\t            0x58, 0x2C, 0x45, 0x00, 0x50, 0x1D, 0x74, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18,\n\t            0x4B, 0x0F, 0x87, 0x3C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,\n\t            0x00, 0x4C, 0x54, 0x36, 0x39, 0x31, 0x31, 0x55, 0x58, 0x43, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x22,\n\t        ])\n\t        # fmt: on\n\t        with open(\"/etc/X11/edid.bin\", \"wb\") as f:\n\t            f.write(edid)\n", "        # Now restart X so that it sees this new EDID.\n\t        print(\"Restarting display-manager.\")\n\t        assert os.system(\"/bin/systemctl restart display-manager\") == 0\n\t        # Let it start up.\n\t        time.sleep(5)\n\t        # Ask xrandr to change the display for us\n\t        os.environ[\"DISPLAY\"] = display\n\t        s = \"/usr/bin/xrandr --size %sx%s\" % (columns, rows)\n\t        assert os.system(s) == 0\n\t        # Deactivate the screen saver.  This works to bring\n", "        # up the display if we've been sitting around and it's\n\t        # gone off.\n\t        s = \"/usr/bin/xset -dpms s off s noblank s 0 0 s noexpose\"\n\t        assert os.system(s) == 0\n\t        #\n\t        cv2.namedWindow(filename, cv2.WND_PROP_FULLSCREEN)\n\t        cv2.setWindowProperty(filename, cv2.WND_PROP_FULLSCREEN, 1)\n\t        cv2.imshow(filename, image)\n\t        # Let cv2 update the display.\n\t        cv2.waitKey(10)\n", "        print(\"Image displayed.\")\n\t        while not done:\n\t            cv2.waitKey(100)\n\t        return 0\n\t    finally:\n\t        # Don't leave our /etc overlay sitting around.\n\t        print(\"Removing overlayfs.\")\n\t        s = \"/bin/umount /etc\"\n\t        r = os.system(s)\n\t        print(\"umount returned %s\" % (r,))\n", "        # Now restart X to go back to normal\n\t        print(\"Restarting display-manager.\")\n\t        os.system(\"/bin/systemctl restart display-manager\")\n\tdef main():\n\t    parser = argparse.ArgumentParser(\n\t        description=\"Tool to display a .png file in fullscreen mode.\"\n\t    )\n\t    parser.add_argument(\n\t        \"--filename\",\n\t        default=holoscan_test_suite.default_test_image,\n", "        help=\"Name of .png file to display.\",\n\t    )\n\t    parser.add_argument(\n\t        \"--display\",\n\t        default=\":0\",\n\t        help=\"Display to use\",\n\t    )\n\t    args = parser.parse_args()\n\t    show_test_pattern(args.filename, args.display)\n\tif __name__ == \"__main__\":\n", "    main()\n"]}
{"filename": "holoscan_test_suite/__init__.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport os\n\tdefault_test_image = os.path.join(os.path.dirname(__file__), \"test_image.png\")\n"]}
{"filename": "holoscan_test_suite/reactor.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t#\n\t# See README.md for detailed information.\n\t# Reactor provides a runtime environment for event handlers; where\n\t# events typically come from file descriptors that are ready to read.\n\t# Reactors also call handlers based on single-shot or periodic alarms.\n\timport collections\n", "import os\n\timport select\n\timport threading\n\timport time\n\timport traceback\n\t# Reactor has a list of alarms that are\n\t# instances of this.\n\tReactorAlarm = collections.namedtuple(\n\t    \"ReactorAlarm\", [\"deadline\", \"period_s\", \"callback\"]\n\t)\n", "class Reactor:\n\t    \"\"\"\n\t    Reactor provides a runtime environment for\n\t    handlers that are called when either a file\n\t    descriptor has data to read or if a timeout\n\t    expires.  Any number of file descriptors or\n\t    alarms can be connected to a reactor instance.\n\t    Handlers should not block; all reactor activity\n\t    is serialized, so the next handler will wait\n\t    until the currently executing handler is done.\n", "    @code\n\t        reactor = Reactor()\n\t        # Start the reactor in a daemon thread\n\t        reactor.start()\n\t        # Example usage\n\t        r_fd, w_fd = os.pipe()\n\t        def pipe_handler():\n\t            value = os.read(r_fd, 8192)\n\t        reactor.register(r_fd, pipe_handler)\n\t        # So now when someone calls\n", "        os.write(w_fd, b\"HELLO\")\n\t        # the reactor will call pipe_handler in its\n\t        # background thread; pipe_handler's call\n\t        # to os.read will complete immediately\n\t        # because there is data to be read.\n\t    @endcode\n\t    Reactor also supports alarms, with a deadline\n\t    that is compared to \"time.monotonic()\".\n\t    @code\n\t        def alarm():\n", "            print(\"Alarm expired!\")\n\t        timeout_s = 5\n\t        reactor.alarm(time.monotonic() + timeout_s, alarm)\n\t    @endcode\n\t    In (at least) 5 seconds from now, the background thread will\n\t    call alarm().\n\t    \"\"\"\n\t    ALARM_UPDATE = b\"ALARM_UPDATE\"\n\t    DONE = b\"DONE\"\n\t    def __init__(self):\n", "        self._alarms = []  # [ReactorAlarm, ...]; sorted earliest deadline first\n\t        self._alarms_lock = threading.Lock()\n\t        self._control_r, self._control_w = os.pipe()\n\t        self._epoll = select.epoll()\n\t        self._epoll_map = {}\n\t        self._done = False\n\t        self.register(self._control_r, self._control_ready)\n\t    def start(self):\n\t        self._thread = threading.Thread(\n\t            target=self._run,\n", "            daemon=True,\n\t        )\n\t        self._thread.start()\n\t    def _run(self):\n\t        while not self._done:\n\t            # Call all expired timeouts.\n\t            timeout_s = None\n\t            while True:\n\t                with self._alarms_lock:\n\t                    if len(self._alarms) < 1:\n", "                        break\n\t                    # self._alarms is always sorted, earliest deadline first\n\t                    reactor_alarm = self._alarms[0]\n\t                    now = time.monotonic()\n\t                    if reactor_alarm.deadline > now:\n\t                        timeout_s = reactor_alarm.deadline - now\n\t                        break\n\t                    # So this deadline has been reached.\n\t                    if reactor_alarm.period_s is None:\n\t                        self._alarms.pop(0)\n", "                    else:\n\t                        # Update the deadline and reorder\n\t                        self._alarms[0] = ReactorAlarm(\n\t                            deadline=reactor_alarm.deadline + reactor_alarm.period_s,\n\t                            period_s=reactor_alarm.period_s,\n\t                            callback=reactor_alarm.callback,\n\t                        )\n\t                        self._alarms.sort()\n\t                # Now self._alarms isn't locked anymore.\n\t                try:\n", "                    reactor_alarm.callback()\n\t                except Exception as e:\n\t                    print(\"Ignoring %s (%s)\" % (e, type(e)))\n\t                    traceback.print_exception(e)\n\t            # We've handled all our timeouts; timeout_s will\n\t            # either be None (because the alarms list was empty)\n\t            # or be the number of seconds until the next deadline.\n\t            events = self._epoll.poll(timeout=timeout_s)\n\t            for fileno, event in events:\n\t                try:\n", "                    handler = self._epoll_map[fileno]\n\t                    handler(event)\n\t                except Exception as e:\n\t                    print(\"Ignoring %s (%s)\" % (e, type(e)))\n\t                    traceback.print_exception(e)\n\t    def register(self, fd, handler, event=select.EPOLLIN | select.EPOLLHUP):\n\t        \"\"\"Set a callback on a ready filedescriptor.\"\"\"\n\t        self._epoll_map[fd] = handler\n\t        self._epoll.register(fd, event)\n\t    def unregister(self, fd):\n", "        \"\"\"Remove a previously registered handler.\"\"\"\n\t        self._epoll.unregister(fd)\n\t        del self._epoll_map[fd]\n\t    def alarm(self, deadline, callback):\n\t        \"\"\"Queue up a callback to execute once the\n\t        given deadline has passed.\n\t        \"\"\"\n\t        reactor_alarm = ReactorAlarm(deadline, None, callback)\n\t        with self._alarms_lock:\n\t            self._alarms.append(reactor_alarm)\n", "            self._alarms.sort()\n\t        # wake up the polling thread\n\t        self._signal(self.ALARM_UPDATE)\n\t        return reactor_alarm\n\t    def periodic_alarm(self, period_s, callback):\n\t        \"\"\"Queue up a callback to be executed periodically.\"\"\"\n\t        now = time.monotonic()\n\t        deadline = now + period_s\n\t        reactor_alarm = ReactorAlarm(deadline, period_s, callback)\n\t        with self._alarms_lock:\n", "            self._alarms.append(reactor_alarm)\n\t            self._alarms.sort()\n\t        # wake up the polling thread\n\t        self._signal(self.ALARM_UPDATE)\n\t        return reactor_alarm\n\t    def _control_ready(self, event):\n\t        \"\"\"\n\t        Callback when _control_r has data to read.\n\t        For now, we don't actually use the values\n\t        sent over the control pipe; it's really just\n", "        to bump the thread and reevaluate timeouts or\n\t        termination flags.\n\t        \"\"\"\n\t        value = os.read(self._control_r, 8192)\n\t    def _signal(self, message):\n\t        \"\"\"Send a message to the reactor, causing it\n\t        to wake up and reevaluate its alarm list.\n\t        \"\"\"\n\t        os.write(self._control_w, message)\n\t    def close(self):\n", "        \"\"\"Initiate shutdown of the reactor thread.\n\t        We don't actually wait for that here--\n\t        this way you can close the reactor\n\t        from within a handler itself.\n\t        \"\"\"\n\t        self._done = True\n\t        self._signal(self.DONE)\n"]}
{"filename": "src/ajantv2_util.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\timport ajantv2\n\timport util\n\tdef aja_board_information():\n\t    # Find the devices on PCI.  pci_devices is indexed by pci-id\n\t    # (e.g. \"f1d0:eb1f\") and is a list of boards found with that\n", "    # id.\n\t    command = [\"/usr/bin/lspci\", \"-n\", \"-d\", \"f1d0::0400\"]\n\t    pci_devices = {}\n\t    for l in util.run_command(command):\n\t        pci_rev = util.Na(\"No value given\")\n\t        try:\n\t            pci_bus_address, pci_class, pci_id, pci_rev = l.split(None, 3)\n\t        except ValueError:\n\t            pci_bus_address, pci_class, pci_id = l.split(None, 2)\n\t        r = {\n", "            \"pci_bus_address\": pci_bus_address,\n\t            \"pci_class\": pci_class,\n\t            \"pci_id\": pci_id,\n\t            \"pci_rev\": pci_rev,\n\t        }\n\t        pci_devices.setdefault(pci_id, []).append(r)\n\t    #\n\t    device_scanner = ajantv2.CNTV2DeviceScanner()\n\t    device_count = device_scanner.GetNumDevices()\n\t    #\n", "    for i in range(device_count):\n\t        card = ajantv2.CNTV2Card(i)\n\t        serial_number_status, serial_number_string = card.GetSerialNumberString()\n\t        pci_device_id_status, pci_device_id = card.GetPCIDeviceID()\n\t        (\n\t            firmware_status,\n\t            firmware_bytes,\n\t            firmware_date,\n\t            firmware_time,\n\t        ) = card.GetInstalledBitfileInfo()\n", "        firmware_info = util.Na(\"No bitfile info provided\")\n\t        if firmware_status:\n\t            firmware_info = \"firmware_bytes=%s firmware_date=%s firmware_time=%s\" % (\n\t                firmware_bytes,\n\t                firmware_date,\n\t                firmware_time,\n\t            )\n\t        (\n\t            failsafe_firmware_status,\n\t            failsafe_firmware_loaded,\n", "        ) = card.IsFailSafeBitfileLoaded()\n\t        pci_device_id_information = util.Na(\"Not provided\")\n\t        if pci_device_id_status:\n\t            pci_device_id_information = util.Hex(pci_device_id)\n\t        failsafe_firmware_loaded_information = util.Na(\"Not provided\")\n\t        if failsafe_firmware_status:\n\t            failsafe_firmware_loaded_information = failsafe_firmware_loaded\n\t        serial_number_information = util.Na(\"Not provided\")\n\t        if serial_number_status:\n\t            serial_number_information = serial_number_string\n", "        board_information = {\n\t            \"device_id\": util.Hex(card.GetDeviceID()),\n\t            \"model\": card.GetModelName(),\n\t            \"device_version\": card.GetDeviceVersion(),\n\t            \"driver_version\": card.GetDriverVersionString(),\n\t            \"serial_number\": serial_number_information,\n\t            \"pci_device_id\": pci_device_id_information,\n\t            \"breakout_hardware\": card.GetBreakoutHardware(),\n\t            \"firmware_info\": firmware_info,\n\t            \"failsafe_firmware\": failsafe_firmware_loaded_information,\n", "            \"fpga_version\": card.GetPCIFPGAVersionString(),\n\t        }\n\t        # The information from GetPCIDeviceID isn't enough to point us to\n\t        # a specific instance-- so if the length of devices in pci_devices[...]\n\t        # is 1, then we'll use that.  Otherwise we can't tell.\n\t        if pci_device_id_status:\n\t            pci_device = pci_devices.get(\"f1d0:%04x\" % pci_device_id, {})\n\t            if len(pci_device) == 1:\n\t                board_information.update(pci_device[0])\n\t        yield board_information\n", "def aja_driver_information():\n\t    r = {\n\t        \"sdk_version\": \"%s.%s.%s (0x%08X) build %s; %s\"\n\t        % (\n\t            ajantv2.AJA_NTV2_SDK_VERSION_MAJOR,\n\t            ajantv2.AJA_NTV2_SDK_VERSION_MINOR,\n\t            ajantv2.AJA_NTV2_SDK_VERSION_POINT,\n\t            ajantv2.AJA_NTV2_SDK_VERSION,\n\t            ajantv2.AJA_NTV2_SDK_BUILD_NUMBER,\n\t            ajantv2.AJA_NTV2_SDK_BUILD_DATETIME,\n", "        ),\n\t    }\n\t    device_scanner = ajantv2.CNTV2DeviceScanner()\n\t    device_count = device_scanner.GetNumDevices()\n\t    r[\"device_count\"] = device_count\n\t    return r\n"]}
{"filename": "src/test_dgpu.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\timport pytest\n\t@pytest.mark.igx_orin_devkit_only\n\tdef test_dgpu_igx_orin_devkit(script):\n\t    assert script.run(\"bringup_dgpu_igx_orin_devkit.sh\") == 0\n\t@pytest.mark.clara_agx_devkit_only\n", "def test_dgpu_clara_agx_devkit(script):\n\t    assert script.run(\"bringup_dgpu_clara_agx_devkit.sh\") == 0\n"]}
{"filename": "src/nvidia_util.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\timport argparse\n\timport ctypes\n\timport re\n\timport smbus2\n\timport sys\n", "import util\n\timport yaml\n\t# Tests use this with pytest.mark.skip.\n\tigx_orin_devkit = [\"p3701\"]\n\tclara_agx_devkit = [\"p2888\"]\n\tRESERVED = \"reserved_\"\n\t# Adapts the EEPROM layout described here:\n\t# https://docs.nvidia.com/jetson/archives/r34.1/DeveloperGuide/text/HR/JetsonEepromLayout.html\n\t# to the name/[array_]ctype list that ctypes.Structure wants.\n\tdef jetson_eeprom_to_ctypes(field_list):\n", "    \"\"\"field_list is a list of (first_byte_offset, last_byte_offset,\n\t    field_name, ctype) the number of bytes should always be an even multiple of\n\t    the ctype size; for a multiple of greater than one then we'll make an array\n\t    out of that here.\n\t    \"\"\"\n\t    # order by first_byte_offset\n\t    l = sorted(field_list)\n\t    address = 0\n\t    r = []\n\t    for first_byte_offset, last_byte_offset, field_name, ct in l:\n", "        # No overlapping data is allowed.\n\t        assert first_byte_offset >= address\n\t        # Do we need to fill with \"reserved\" bytes?\n\t        if address < first_byte_offset:\n\t            n = first_byte_offset - address\n\t            r.append((\"%s%s\" % (RESERVED, len(r)), ctypes.c_uint8 * n))\n\t            address += n\n\t        # How many of these data are here?\n\t        n = last_byte_offset - address + 1\n\t        count = n // ctypes.sizeof(ct)\n", "        # has to be an even number of elements\n\t        assert (count * ctypes.sizeof(ct)) == n\n\t        if count == 1:\n\t            r.append((field_name, ct))\n\t        else:\n\t            r.append((field_name, ct * count))\n\t        address += n\n\t    return r\n\t# https://docs.nvidia.com/jetson/archives/r34.1/DeveloperGuide/text/HR/JetsonEepromLayout.html\n\t# (also https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3231/index.html#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/jetson_eeprom_layout.html)\n", "class JetsonEepromCtypesAdapter(ctypes.Structure):\n\t    _pack_ = 1\n\t    _fields_ = jetson_eeprom_to_ctypes(\n\t        [\n\t            (0, 0, \"major_version\", ctypes.c_uint8),\n\t            (1, 1, \"minor_version\", ctypes.c_uint8),\n\t            (2, 3, \"id_data_bytes\", ctypes.c_uint16),\n\t            (4, 5, \"board_number\", ctypes.c_uint16),\n\t            (6, 7, \"sku\", ctypes.c_uint16),\n\t            (8, 8, \"fab\", ctypes.c_uint8),\n", "            (9, 9, \"rev\", ctypes.c_uint8),\n\t            (10, 10, \"minor_rev\", ctypes.c_uint8),\n\t            (11, 11, \"memory_type\", ctypes.c_uint8),\n\t            (12, 12, \"power_configuration\", ctypes.c_uint8),\n\t            (13, 13, \"miscellaneous_configuration\", ctypes.c_uint8),\n\t            (16, 16, \"display_configuration\", ctypes.c_uint8),\n\t            (17, 17, \"rework_level\", ctypes.c_uint8),\n\t            (19, 19, \"gigabit_mac_ids\", ctypes.c_uint8),\n\t            (20, 49, \"board_id\", ctypes.c_char),\n\t            (50, 55, \"wifi_mac_id\", ctypes.c_uint8),\n", "            (56, 61, \"bluetooth_mac_id\", ctypes.c_uint8),\n\t            (62, 67, \"secondary_wifi_mac_id\", ctypes.c_uint8),\n\t            (68, 73, \"gigabit_mac_id\", ctypes.c_uint8),\n\t            (74, 88, \"serial_number\", ctypes.c_char),\n\t            (150, 153, \"customer_block_signature\", ctypes.c_char),\n\t            (154, 155, \"customer_block_length\", ctypes.c_uint16),\n\t            (156, 157, \"customer_block_type\", ctypes.c_char),\n\t            (158, 159, \"customer_block_version\", ctypes.c_uint16),\n\t            (160, 165, \"customer_block_wifi_mac_id\", ctypes.c_uint8),\n\t            (166, 171, \"customer_block_bluetooth_mac_id\", ctypes.c_uint8),\n", "            (172, 177, \"customer_block_gigabit_mac_id\", ctypes.c_uint8),\n\t            (178, 178, \"customer_block_gigabit_mac_ids\", ctypes.c_uint8),\n\t            (200, 220, \"orin_system_part_number\", ctypes.c_char),\n\t            (221, 235, \"orin_serial_number\", ctypes.c_char),\n\t            (255, 255, \"crc8\", ctypes.c_uint8),\n\t        ]\n\t    )\n\tdef compute_crc8(b, crc=0):\n\t    \"\"\"See https://docs.nvidia.com/jetson/archives/r34.1/DeveloperGuide/text/HR/JetsonEepromLayout.html\"\"\"\n\t    for c in b:\n", "        assert c >= 0\n\t        assert c < 256\n\t        for bit in range(8):\n\t            odd = ((c ^ crc) & 1) == 1\n\t            crc >>= 1\n\t            c >>= 1\n\t            if odd:\n\t                crc ^= 0x8C\n\t    return crc\n\tclass EepromStr(str):\n", "    \"\"\"Some ASCII printable data is stored in eeprom with fill characters (\\x00\n\t    or \\xFF); use this adapter to get a printable string without that filler.\n\t    By subclassing str (and using __new__ to set immutable fields) we hide the\n\t    fact that we're adapting the value here from something else.  We'd use a str\n\t    directly if we didn't want to have special yaml or html handling.\n\t    \"\"\"\n\t    def __new__(cls, b, strip=b\"\\x00\"):\n\t        s = b.rstrip(strip).decode(\"utf-8\")\n\t        obj = str.__new__(cls, s)\n\t        obj._s = s\n", "        obj._present = len(obj._s) > 0\n\t        return obj\n\t    def yaml(self, dumper):\n\t        if self._present:\n\t            return dumper.represent_str(self._s)\n\t        return dumper.represent_none(None)\n\t    def html(self):\n\t        if self._present:\n\t            return self._s\n\t        return util.Na(\"Not specified\").html()\n", "yaml.add_representer(EepromStr, lambda dumper, data: data.yaml(dumper))\n\tclass EepromMac:\n\t    def __init__(self, b):\n\t        self._s = \":\".join([\"%02X\" % c for c in b])\n\t    def __str__(self):\n\t        return self._s\n\t    def yaml(self, dumper):\n\t        return dumper.represent_str(self._s)\n\t    def html(self):\n\t        return self._s\n", "yaml.add_representer(EepromMac, lambda dumper, data: data.yaml(dumper))\n\tdef _jetson_eeprom_information(device=0, address=0x50):\n\t    \"\"\"NOTE this returns the JetsonEeprom instance AND the computed CRC of\n\t    EEPROM data.  You really want to use jetson_eeprom_information() instead.\n\t    \"\"\"\n\t    with smbus2.SMBus(device) as bus:\n\t        bs = 16\n\t        r = bytearray()\n\t        for a in range(0, 256, bs):\n\t            assert (a >> 8) == 0\n", "            wr = smbus2.i2c_msg.write(address, [a & 0xFF])\n\t            rd = smbus2.i2c_msg.read(address, bs)\n\t            bus.i2c_rdwr(wr, rd)\n\t            r.extend(list(rd))\n\t    eeprom = JetsonEepromCtypesAdapter.from_buffer(r)\n\t    computed_crc = compute_crc8(r[:-1])\n\t    jetson_eeprom = {\n\t        \"version\": \"%d.%d\" % (eeprom.major_version, eeprom.minor_version),\n\t        \"board_number\": eeprom.board_number,\n\t        \"sku\": eeprom.sku,\n", "        \"fab\": eeprom.fab,\n\t        \"rev\": \"%d.%d\" % (eeprom.rev, eeprom.minor_rev),\n\t        \"memory_type\": eeprom.memory_type,\n\t        \"power_configuration\": eeprom.power_configuration,\n\t        \"miscellaneous_configuration\": eeprom.miscellaneous_configuration,\n\t        \"display_configuration\": eeprom.display_configuration,\n\t        \"rework_level\": eeprom.rework_level,\n\t        \"gigabit_mac_ids\": eeprom.gigabit_mac_ids,\n\t        \"board_id\": EepromStr(eeprom.board_id, strip=b\"\\x00\\xFF\"),\n\t        \"wifi_mac_id\": EepromMac(eeprom.wifi_mac_id),\n", "        \"bluetooth_mac_id\": EepromMac(eeprom.bluetooth_mac_id),\n\t        \"secondary_wifi_mac_id\": EepromMac(eeprom.secondary_wifi_mac_id),\n\t        \"gigabit_mac_id\": EepromMac(eeprom.gigabit_mac_id),\n\t        \"serial_number\": EepromStr(eeprom.serial_number),\n\t        \"customer_block_signature\": EepromStr(eeprom.customer_block_signature),\n\t        \"customer_block_length\": eeprom.customer_block_length,\n\t        \"customer_block_type\": EepromStr(eeprom.customer_block_type),\n\t        \"customer_block_version\": util.Hex(eeprom.customer_block_version),\n\t        \"customer_block_wifi_mac_id\": EepromMac(eeprom.customer_block_wifi_mac_id),\n\t        \"customer_block_bluetooth_mac_id\": EepromMac(\n", "            eeprom.customer_block_bluetooth_mac_id\n\t        ),\n\t        \"customer_block_gigabit_mac_id\": EepromMac(\n\t            eeprom.customer_block_gigabit_mac_id\n\t        ),\n\t        \"customer_block_gigabit_mac_ids\": eeprom.customer_block_gigabit_mac_ids,\n\t        \"orin_system_part_number\": EepromStr(eeprom.orin_system_part_number),\n\t        \"orin_serial_number\": EepromStr(eeprom.orin_serial_number),\n\t        \"crc8\": util.Hex(eeprom.crc8),\n\t    }\n", "    return jetson_eeprom, computed_crc\n\tdef jetson_eeprom_information(device=0, address=0x50):\n\t    \"\"\"Returns a dict with the data found in the on-board IDROM.\"\"\"\n\t    eeprom, computed_crc = _jetson_eeprom_information(device, address)\n\t    eeprom_crc = eeprom[\"crc8\"]\n\t    # If the EEPROM CRC doesn't match, let the user know.\n\t    eeprom[\"computed_crc\"] = util.Hex(computed_crc)\n\t    eeprom[\"crc_check\"] = \"CRC VALUES DO NOT MATCH\"\n\t    if eeprom_crc == computed_crc:\n\t        eeprom[\"crc_check\"] = \"Check ok\"\n", "    return eeprom\n\tdef model():\n\t    eeprom = jetson_eeprom_information()\n\t    board_id = eeprom[\"board_id\"]\n\t    g = re.match(\"699-(.)(....)-(....)-(...) (...)\", board_id)\n\t    assert g is not None\n\t    board_class, module_id, sku, version, revision = (\n\t        g.group(1),\n\t        g.group(2),\n\t        g.group(3),\n", "        g.group(4),\n\t        g.group(5),\n\t    )\n\t    return \"p\" + module_id\n\tdef main():\n\t    #\n\t    parser = argparse.ArgumentParser(\n\t        description=\"Tool to query NVIDIA configuration.\",\n\t    )\n\t    parser.add_argument(\n", "        \"--is-model\",\n\t        help=\"exits with a 0 if the given model is present.\",\n\t    )\n\t    parser.add_argument(\n\t        \"--model\",\n\t        action=\"store_true\",\n\t        help=\"Display the current board model.\",\n\t    )\n\t    args = parser.parse_args()\n\t    #\n", "    if args.is_model:\n\t        if model() == args.is_model:\n\t            return 0\n\t        else:\n\t            return 1\n\t    #\n\t    if args.model:\n\t        print(\"model=%s\" % (model(),))\n\t        return 0\n\t    # By default, just dump the contents.\n", "    eeprom = _jetson_eeprom_information()\n\t    return 0\n\tif __name__ == \"__main__\":\n\t    sys.exit(main())\n"]}
{"filename": "src/test_p3785.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\timport cv2\n\timport holoscan_test_suite\n\timport numpy as np\n\timport pytest\n\timport subprocess\n", "import sys\n\timport time\n\t# Check for video ingress on P3785;\n\t# relies on\n\t#   - a working P3785\n\t#   - Test image at 1920x1080,60fps\n\t#       presented to the HDMI input--\n\t#       show_test_pattern.py does this\n\t# \"capsys\" here is how we save our stdout/stderr\n\t# into the generated report.\n", "@pytest.mark.igx_orin_devkit_only\n\tdef test_p3785(capsys):\n\t    print(\"Test IGX Orin Devkit P3785.\")\n\t    # We only support 1920x1080 images.\n\t    columns = 1920\n\t    rows = 1080\n\t    pixel_format = \"BGRA\"\n\t    bytes_per_pixel = 4\n\t    device = \"/dev/video0\"\n\t    frames_per_sec = 60\n", "    record_filename = \"/tmp/video.raw\"\n\t    pixels_per_image = columns * rows\n\t    bytes_per_image = pixels_per_image * bytes_per_pixel\n\t    # Load up our test image; this is the same\n\t    # image that's expected to be recorded\n\t    test_image_filename = holoscan_test_suite.default_test_image\n\t    test_image_bgr = cv2.imread(test_image_filename)  # cv2.imread always returns BGR\n\t    # We acquire BGRA data, so convert our test image to that\n\t    test_image_bgra = cv2.cvtColor(test_image_bgr, cv2.COLOR_BGR2BGRA)\n\t    image_rows, image_columns, image_width = test_image_bgra.shape\n", "    assert image_rows == rows\n\t    assert image_columns == columns\n\t    # Run \"show_test_pattern\" to bring up the test image on X\n\t    command = f\"show_test_pattern --filename {test_image_filename}\"\n\t    print('Running \"%s\"' % (command,))\n\t    show_test_pattern = subprocess.Popen(\n\t        command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE\n\t    )\n\t    try:\n\t        # Let show_test_pattern start up\n", "        time.sleep(5)\n\t        # Run the recorder for 1 second at 60fps.\n\t        # Note that we impose the timeoverlay on the image--\n\t        # this way we see changes in the image itself and\n\t        # a difference from the test image that is greater\n\t        # than 0 but less than a relatively small threshold.\n\t        assert pixel_format == \"BGRA\"\n\t        command = f\"/usr/bin/gst-launch-1.0 v4l2src io-mode=mmap device={device} ! video/x-raw,format={pixel_format},width={columns},height={rows},framerate={frames_per_sec}/1 ! timeoverlay ! videoconvert ! filesink location={record_filename}\"\n\t        print('Running \"%s\"' % (command,))\n\t        gst = subprocess.Popen(\n", "            command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE\n\t        )\n\t        try:\n\t            # Record a few frames\n\t            time.sleep(5)\n\t        finally:\n\t            gst.kill()\n\t            time.sleep(2)\n\t        out, err = gst.communicate()\n\t        for l in out.decode(\"utf-8\").split(\"\\n\"):\n", "            print(l)\n\t        for l in err.decode(\"utf-8\").split(\"\\n\"):\n\t            print(l, file=sys.stderr)\n\t    finally:\n\t        show_test_pattern.terminate()\n\t        time.sleep(2)\n\t        out, err = show_test_pattern.communicate()\n\t        for l in out.decode(\"utf-8\").split(\"\\n\"):\n\t            print(l)\n\t        for l in err.decode(\"utf-8\").split(\"\\n\"):\n", "            print(l, file=sys.stderr)\n\t    # Load our actual recorded data.\n\t    with open(record_filename, \"rb\") as f:\n\t        # How many frames did we record?\n\t        SEEK_END = 2\n\t        f.seek(0, SEEK_END)\n\t        video_byte_length = f.tell()\n\t        # frames may have a fraction given that we kill gst without\n\t        # respect to where it was writing data.\n\t        frames = video_byte_length / bytes_per_image\n", "        print(\"video_byte_length=%s frames=%s\" % (video_byte_length, frames))\n\t        assert frames > 1\n\t        # Load the last frame.\n\t        last_whole_frame = int(frames) - 1\n\t        f.seek(last_whole_frame * bytes_per_image)\n\t        np_raw_data = np.fromfile(f, dtype=np.uint8, count=bytes_per_image)\n\t        last_acquired_image_bgra = np_raw_data.reshape(\n\t            rows, columns, bytes_per_pixel\n\t        )  # this is BGRA per pixel_format above\n\t        # How different is this from our test image?\n", "        diff = cv2.absdiff(test_image_bgra, last_acquired_image_bgra)\n\t        # Now many pixels are different?\n\t        gray_diff = cv2.cvtColor(diff, cv2.COLOR_BGRA2GRAY)\n\t        differences = np.count_nonzero(gray_diff)\n\t        percent = (differences / pixels_per_image) * 100.0\n\t        print(\n\t            \"differences, test_image_bgra to last_acquired_image_bgra=%s (%.1f%%)\"\n\t            % (differences, percent)\n\t        )\n\t        # gstreamer superimposed the timestamp on the test image,\n", "        # so it has have some differences; the display stream is also\n\t        # mathematically lossy, so some difference is expected.\n\t        assert percent > 0.1\n\t        # but not TOO different.\n\t        assert percent < 10.0\n"]}
{"filename": "src/test_wifi.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t#\n\t# See README.md for detailed information.\n\timport pytest\n\t@pytest.mark.igx_orin_devkit_only\n\tdef test_wifi(script):\n\t    assert script.run(\"bringup_wifi_igx_orin_devkit.sh\") == 0\n"]}
{"filename": "src/test_aja.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t#\n\t# See README.md for detailed information.\n\tdef test_aja(script):\n\t    assert script.run(\"bringup_aja.sh\") == 0\n"]}
{"filename": "src/infiniband_util.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\timport os.path\n\timport subprocess\n\timport util\n\tdef infiniband_information():\n\t    pci_devices = util.list_pci_devices([\"15b3::\"])\n", "    # What devices are there?\n\t    command = [\"/usr/sbin/ibstat\", \"--list_of_cas\"]\n\t    try:\n\t        result = subprocess.run(\n\t            command,\n\t            capture_output=True,\n\t        )\n\t        # Parse the output into an information table.\n\t        s = result.stdout\n\t        devices = []\n", "        for device in s.decode(\"utf-8\").split(\"\\n\"):\n\t            if len(device):\n\t                devices.append(device)\n\t    except FileNotFoundError:\n\t        return\n\t    for device in devices:\n\t        command = [\"/usr/sbin/ibstat\", \"--short\", device]\n\t        try:\n\t            result = subprocess.run(\n\t                command,\n", "                capture_output=True,\n\t            )\n\t            # Parse the output into an information table.\n\t            s = result.stdout\n\t            l = s.decode(\"utf-8\").split(\"\\n\")\n\t            information = {}\n\t            category = None\n\t            for i in l:\n\t                if len(i) == 0:\n\t                    continue\n", "                # We already know what device this is\n\t                if i == (\"CA '%s'\" % device):\n\t                    continue\n\t                name_value_pair = i.split(\":\", 1)\n\t                name = name_value_pair[0].strip()\n\t                value = \"\"\n\t                if len(name_value_pair) > 1:\n\t                    value = name_value_pair[1].strip()\n\t                if len(value) == 0:\n\t                    value = util.Na(\"No value given\")\n", "                information[util.to_snake(name)] = value\n\t            # Can we map this back to a PCI slot?\n\t            path = \"/sys/class/infiniband/%s/device\" % device\n\t            realpath = os.path.realpath(path)\n\t            _, slot = os.path.split(realpath)\n\t            if slot in pci_devices:\n\t                information.update(pci_devices[slot])\n\t            yield information\n\t        except FileNotFoundError:\n\t            information = {\"status\": util.Na(\"V4L2 driver not available\")}\n", "            yield information\n"]}
{"filename": "src/holoscan_test_controls.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\t# holoscan_test_controls.py creates the web UI that allows users to execute a list of\n\t# commands on demand.  See HoloscanTestControls.setup() below.\n\timport engineio.payload\n\timport flask\n\timport flask_socketio\n", "from holoscan_test_suite import controls\n\tfrom holoscan_test_suite import html_render\n\tfrom holoscan_test_suite import reactor\n\timport os\n\timport re\n\timport subprocess\n\t# When the UI requests the initial state, we get\n\t# a number of small requests-- don't limit the number\n\t# of requests we're allowed to queue up.\n\tengineio.payload.Payload.max_decode_packets = 100\n", "class HoloscanTestControls:\n\t    \"\"\"\n\t    HoloscanTestControls is a webapp where an HTML UI displays\n\t    - status values that are dynamically updated from the server\n\t    - actions that the user can perform.\n\t    The values shown on the display are dynamically updated\n\t    by snippets of javascript included in the HTML that\n\t    coordinate with a websocket server running here.\n\t    \"\"\"\n\t    def __init__(self, app):\n", "        self._app = app\n\t        self._actions = []\n\t        self._status = []\n\t        self._request = {}\n\t        self._update = {}\n\t        self._proc_stat = {}\n\t        #\n\t        self._reactor = reactor.Reactor()\n\t        self._reactor.start()\n\t        #\n", "        self.setup()\n\t        # Generate the index HTML page from the controls initialized by\n\t        # setup().  We always publish the same page so let's just cache that\n\t        # for whoever wants it.  (The controls update themselves dynamically.)\n\t        self._index_cache = self._index()\n\t    def setup(self):\n\t        # Control: show the test pattern\n\t        self.checkbox_command(\n\t            control_name=\"show_test_pattern\",\n\t            label=\"Enable 1920x1080 video test pattern\",\n", "            command=\"show_test_pattern\",\n\t        )\n\t        # Control: show the endoscopy demo from a recorded video input.\n\t        self.checkbox_command(\n\t            control_name=\"recorded_endoscopy_demo\",\n\t            label=\"Run the tool tracking demo (with recorded input)\",\n\t            command=\"./applications/endoscopy_tool_tracking/cpp/endoscopy_tool_tracking\",\n\t            env_update={\"DISPLAY\": \":0\"},\n\t            cwd=\"/opt/nvidia/holohub\",\n\t        )\n", "        # Control: run iperf3, the server that supports network performance testing\n\t        self.checkbox_command(\n\t            control_name=\"enable_iperf3\",\n\t            label=\"Run iperf server, listening to TCP and UDP port 5201 on all ethernets including WIFI\",\n\t            command=\"iperf3 -s\",\n\t        )\n\t        # Control: run \"e2fsck\" on nvme0n1\n\t        e2fsck_command = \"e2fsck -c -y /dev/nvme0n1\"\n\t        self.checkbox_command(\n\t            control_name=\"e2fsck_nvme0n1\",\n", "            label='Filesystem check of envme0n1 (via \"%s\")' % e2fsck_command,\n\t            command=e2fsck_command,\n\t        )\n\t        # Control: run \"mke2fs\" on nvme0n1; e2fsck won't work until\n\t        # we have a filesystem there.\n\t        mke2fs_command = \"mke2fs /dev/nvme0n1\"\n\t        self.checkbox_command(\n\t            control_name=\"mke2fs_nvme0n1\",\n\t            label='Make a ext2 filesystem on nvme0n1 (via \"%s\")' % mke2fs_command,\n\t            command=mke2fs_command,\n", "        )\n\t        # Control: run memtest on each core.\n\t        mb = 1024 * 1024\n\t        gb = 1024 * mb\n\t        memory_test_size = 2 * gb\n\t        for cpu in os.sched_getaffinity(0):\n\t            command = \"taskset -c %s memtester %sM\" % (cpu, (memory_test_size // mb))\n\t            self.checkbox_command(\n\t                control_name=\"memtest_with_cpu_%s\" % cpu,\n\t                label='Run memtest on CPU %s (via \"%s\")' % (cpu, command),\n", "                command=command,\n\t            )\n\t        # Control: disable the X-windows screen saver.\n\t        disable_screen_saver_command = (\n\t            \"/usr/bin/xset -dpms s off s noblank s 0 0 s noexpose\"\n\t        )\n\t        self.checkbox_command(\n\t            control_name=\"disable_screensaver\",\n\t            label='Disable X screen saver (via \"%s\")' % disable_screen_saver_command,\n\t            command=disable_screen_saver_command,\n", "            env_update={\"DISPLAY\": \":0\"},\n\t        )\n\t        # Status: Available RAM\n\t        def memory_free_status(control_name):\n\t            meminfo = self.get_meminfo()\n\t            r = {\n\t                \"value\": \"%sM\" % (meminfo[\"MemFree\"] // mb),\n\t            }\n\t            return r\n\t        memory_status = self.status(\n", "            control_name=\"memory_status\",\n\t            label=\"Memory free (MB)\",\n\t            requester=memory_free_status,\n\t        )\n\t        self._reactor.periodic_alarm(\n\t            period_s=5, callback=lambda: memory_status.publish(memory_free_status(None))\n\t        )\n\t        # Status: Thermal zones.\n\t        def get_thermal_zone(control_name, filename):\n\t            with open(filename, \"rt\") as f:\n", "                s = f.read()\n\t            v = int(s)\n\t            c = v / 1000\n\t            r = \"%.2fC\" % (c,)\n\t            # print(\"%s=%s\" % (self._control_name, r))\n\t            return {\n\t                \"value\": r,\n\t            }\n\t        for type_name, filename in self.thermal_zones():\n\t            requester = lambda control_name, filename=filename: get_thermal_zone(\n", "                control_name, filename\n\t            )\n\t            status = self.status(\n\t                control_name=type_name.lower().replace(\"-\", \"_\"),\n\t                label=\"Thermal zone: %s\" % type_name,\n\t                requester=requester,\n\t            )\n\t            self._reactor.periodic_alarm(\n\t                period_s=5,\n\t                callback=lambda status=status, requester=requester: status.publish(\n", "                    requester(None)\n\t                ),\n\t            )\n\t        # Status: CPU usage\n\t        self.update_proc_stat()\n\t        def get_cpu_usage(cpu_name):\n\t            r = \"Offline\"\n\t            with open(\"/sys/devices/system/cpu/%s/online\" % cpu_name, \"rt\") as f:\n\t                s = f.read()\n\t            online = int(s)\n", "            if online > 0:\n\t                u = self._proc_stat[cpu_name]\n\t                stat = [int(s) for s in u.split()]\n\t                last_cpu_name = \"last_%s\" % cpu_name\n\t                last_stat = self._proc_stat.get(last_cpu_name, None)\n\t                if last_stat:\n\t                    delta = [b - a for a, b in zip(last_stat, stat)]\n\t                else:\n\t                    delta = [\"N/A\" for a in stat]\n\t                self._proc_stat[last_cpu_name] = stat\n", "                r = \"user=%s nice=%s system=%s idle=%s iowait=%s irq=%s softirq=%s\" % (\n\t                    *delta[:7],\n\t                )\n\t            return {\n\t                \"value\": r,\n\t            }\n\t        # cpu_usage_update is set up so that it first calls\n\t        # self.update_proc_stat, then calls get_cpu_usage (which\n\t        # reads self._proc_stat) for each processor.  This way we\n\t        # don't get aliasing around the CPU usage on the display.\n", "        cpu_usage_update = [self.update_proc_stat]\n\t        for cpu_name in self.cpus():\n\t            requester = lambda control_name, cpu_name=cpu_name: get_cpu_usage(cpu_name)\n\t            status = self.status(\n\t                control_name=\"cpu_usage_%s\" % cpu_name,\n\t                label=\"CPU usage: %s\" % cpu_name,\n\t                requester=requester,\n\t            )\n\t            updater = lambda status=status, cpu_name=cpu_name: status.publish(\n\t                get_cpu_usage(cpu_name)\n", "            )\n\t            cpu_usage_update.append(updater)\n\t        self._reactor.periodic_alarm(\n\t            period_s=5,\n\t            callback=lambda cpu_usage_update=cpu_usage_update: [\n\t                u() for u in cpu_usage_update\n\t            ],\n\t        )\n\t        # Status: dGPU usage\n\t        dgpu_usage_command = \"/usr/bin/nvidia-smi pmon -c 1\"\n", "        dgpu_usage_status = controls.Status(\n\t            self._app, label=\"dGPU Usage\", control_name=\"dgpu_usage\"\n\t        )\n\t        self._status.append(dgpu_usage_status)\n\t        def update_dgpu_usage():\n\t            process = subprocess.Popen(\n\t                args=dgpu_usage_command.split(),\n\t                stdout=subprocess.PIPE,\n\t                stderr=subprocess.PIPE,\n\t            )\n", "            outs, errs = process.communicate(timeout=2)\n\t            stdout_value = outs.decode(\"utf-8\")\n\t            dgpu_usage_status.publish({\"value\": stdout_value})\n\t        self._reactor.periodic_alarm(period_s=5, callback=update_dgpu_usage)\n\t        self._request[dgpu_usage_status._control_name] = lambda control_name: {\n\t            \"value\": \"N/A\"\n\t        }\n\t        # Control: run gst, NVIDIA GPU stress test (https://github.com/NVIDIA/GPUStressTest)\n\t        self.checkbox_command(\n\t            control_name=\"gst\",\n", "            label=\"Run GST, the NVIDIA GPU Stress test\",\n\t            command=\"/usr/bin/gst\",\n\t        )\n\t        #\n\t    def checkbox_command(self, control_name, label, command, cwd=None, env_update={}):\n\t        \"\"\"\n\t        Creates an HTML UI element that is a checkbox; when the\n\t        user clicks it, we'll start the given command in the background.\n\t        If that program terminates, we'll drive the UI back to the\n\t        unchecked state; if it's checked and the user unchecks it,\n", "        we'll kill the background program.\n\t        \"\"\"\n\t        # runner is what supervises the command that this checkbox runs.\n\t        runner = controls.Runner(\n\t            self._reactor, self._app, command.split(), cwd=cwd, env_update=env_update\n\t        )\n\t        # control is how the checkbox and stdout/stderr is displayed\n\t        control = controls.Checkbox(\n\t            self._app, label, control_name, update=runner.update\n\t        )\n", "        # runner has asynchronous stdout/stderr data that it wants to pass up to UI\n\t        runner.set_control(control)\n\t        # when the control calls \"request\" (to fetch the current status), here's the handler for it\n\t        self._request[control_name] = control.request\n\t        # when the control calls \"update\" (to provide a new value), here's the handler for it\n\t        self._update[control_name] = control.update\n\t        # this is the list of items that are displayed on the page.\n\t        self._actions.append(control)\n\t        return runner\n\t    def status(self, control_name, label, requester):\n", "        \"\"\"\n\t        Creates an HTML UI item (which is really just a PRE section) that\n\t        we can write stuff to via websocket.\n\t        @returns the status object, call \"status.publish(dict)\" to update\n\t        the value displayed on the UI there.  For details on the dict to\n\t        be published, @see request() below.\n\t        @param requester fetches the value to be displayed and\n\t        takes control_name as a parameter.\n\t        \"\"\"\n\t        status = controls.Status(self._app, label, control_name)\n", "        # when the control calls \"request\" (to fetch the current status on startup), here's the handler for it\n\t        self._request[control_name] = requester\n\t        # add ourselves to the list of status displayed on the page.\n\t        self._status.append(status)\n\t        return status\n\t    def index(self):\n\t        \"\"\"\n\t        Called when a user requests the index page.  We've already\n\t        created (and cached) the index page so just publish that.\n\t        \"\"\"\n", "        return self._index_cache\n\t    def _index(self):\n\t        \"\"\"\n\t        Actually render the index page.  We sort the status\n\t        items for display at the top of the page, then sort\n\t        actions (which the user can enable or disable) and display\n\t        them next.  Items are sorted using \"naturally_sorted\"\n\t        below so that UI shows items in a consistent order.\n\t        \"\"\"\n\t        # Status comes first\n", "        rendered_status = []\n\t        for a in self.naturally_sorted(self._status):\n\t            a.render(rendered_status)\n\t        # Actions are next\n\t        rendered_actions = []\n\t        for a in self.naturally_sorted(self._actions):\n\t            a.render(rendered_actions)\n\t        # Here's the page itself\n\t        doc = [\n\t            html_render.socket_io_js,\n", "            html_render.javascript(\"var socket = io();\"),\n\t            self._reload_on_server_update(),\n\t            html_render.header(3, \"Status\"),\n\t            html_render.table(rendered_status),\n\t            html_render.horizontal_rule(),\n\t            html_render.header(3, \"Actions\"),\n\t            html_render.ul(rendered_actions),\n\t            html_render.horizontal_rule(),\n\t        ]\n\t        # Enable auto-wrapping of PRE sections\n", "        styles = [\n\t            html_render.style(\n\t                \"pre\",\n\t                {\n\t                    \"overflow-x\": \"auto\",\n\t                    \"white-space\": \"pre-wrap\",\n\t                    \"word-wrap\": \"break-word\",\n\t                },\n\t            )\n\t        ]\n", "        head = html_render.head(styles)\n\t        body = html_render.body(doc)\n\t        html = html_render.html([head, body])\n\t        # Send it.\n\t        r = html_render.render(html)\n\t        return r\n\t    def naturally_sorted(self, l):\n\t        \"\"\"\n\t        Sort the given list in a natural way, so that \"CPU_10\" comes after \"CPU_2\"\n\t        \"\"\"\n", "        extract_parts = re.compile(\"[^0-9]+|[0-9]+\")\n\t        def maybe_int(s):\n\t            try:\n\t                return int(s)\n\t            except ValueError:\n\t                return s\n\t        def key(control):\n\t            parts = extract_parts.findall(control._label)\n\t            r = [maybe_int(s) for s in parts]\n\t            return r\n", "        return sorted(l, key=key)\n\t    def _reload_on_server_update(self):\n\t        \"\"\"\n\t        Returns HTML that instructs the page\n\t        to reload itself if the server restarts.\n\t        This works by the server passing us\n\t        a \"reload\" instruction with it's PID;\n\t        if that PID is different than the one the\n\t        client is currently displaying, then\n\t        the client will reload to get the current\n", "        server's page (with it's new PID).  See\n\t        \"connection()\" below.\n\t        \"\"\"\n\t        return html_render.javascript(\n\t            \"\"\"\n\t            socket.on(\"reload\", (event) => {\n\t                console.log(\"event.id=\" + event.id);\n\t                if (event.id != %s) {\n\t                    location.reload();\n\t                }\n", "            });\n\t        \"\"\"\n\t            % os.getpid()\n\t        )\n\t    def request(self, message):\n\t        \"\"\"\n\t        Handle a UI \"request\", which reports the control's\n\t        current value.  We broadcast the result to make sure\n\t        all clients show a consistent state.\n\t        \"\"\"\n", "        control_name = message[\"control\"]\n\t        reply = {\n\t            \"control\": control_name,\n\t            \"enable\": True,\n\t        }\n\t        strategy = self._request.get(control_name, self._bad_request)\n\t        value = strategy(control_name)\n\t        reply.update(value)\n\t        flask_socketio.emit(\n\t            \"%s-value\" % control_name,\n", "            reply,\n\t            broadcast=True,\n\t        )\n\t    def _bad_request(self, control_name):\n\t        print('No request strategy for \"%s\"' % (control_name,))\n\t        return {\n\t            \"control_name\": control_name,\n\t            \"enable\": False,\n\t            \"value\": \"N/A\",\n\t        }\n", "    def update(self, message):\n\t        \"\"\"\n\t        Handle a UI \"update\", which changes the value of a control.\n\t        We call the given control's update callback, which returns\n\t        a new value to report to the user.  Send that new\n\t        value out in broadcast mode so everyone sees it.\n\t        \"\"\"\n\t        control_name = message[\"control\"]\n\t        requested_value = message[\"value\"]\n\t        reply = {\n", "            \"control\": control_name,\n\t            \"enable\": True,\n\t        }\n\t        strategy = self._update.get(control_name, self._bad_update)\n\t        value = strategy(control_name, requested_value)\n\t        reply.update(value)\n\t        flask_socketio.emit(\n\t            \"%s-value\" % control_name,\n\t            reply,\n\t            broadcast=True,\n", "        )\n\t    def _bad_update(self, control_name, new_value):\n\t        print('No update strategy for \"%s\"' % (control_name,))\n\t        return {\n\t            \"control_name\": control_name,\n\t            \"enable\": False,\n\t            \"value\": \"N/A\",\n\t        }\n\t    def get_meminfo(self):\n\t        \"\"\"\n", "        Returns a map of name/value pairs,\n\t        where the names and values are read from\n\t        \"/proc/meminfo\".  We use this to\n\t        e.g. figure out how much RAM is in use.\n\t        \"\"\"\n\t        r = {}\n\t        kb_match = re.compile(\"([a-zA-Z0-9_]+):[ ]+([0-9]+) kB\")\n\t        with open(\"/proc/meminfo\", \"rt\") as f:\n\t            for l in f:\n\t                m = kb_match.match(l)\n", "                if m:\n\t                    r[m.group(1)] = 1024 * int(m.group(2))\n\t        return r\n\t    def thermal_zones(self):\n\t        \"\"\"\n\t        yields the thermal zone's \"type\" and the filename where that zone's\n\t        temperature can be read.\n\t        \"\"\"\n\t        thermal = \"/sys/class/thermal\"\n\t        for zone_name in os.listdir(thermal):\n", "            temp = os.path.join(thermal, zone_name, \"temp\")\n\t            type_ = os.path.join(thermal, zone_name, \"type\")\n\t            if not os.path.isfile(temp):\n\t                continue\n\t            if not os.path.isfile(type_):\n\t                continue\n\t            with open(type_, \"rt\") as f:\n\t                type_name = f.read().strip()\n\t            yield type_name, temp\n\t    def update_proc_stat(self):\n", "        \"\"\"\n\t        Get a list of name/value pairs from \"/proc/stat\" and\n\t        save that to self._proc_stat.\n\t        \"\"\"\n\t        r = {}\n\t        with open(\"/proc/stat\", \"rt\") as f:\n\t            for l in f:\n\t                s = l.split(\" \", 1)\n\t                r[s[0]] = s[1]\n\t        self._proc_stat.update(r)\n", "    def cpus(self):\n\t        \"\"\"\n\t        Yields \"cpu0\", \"cpu1\", ...\n\t        \"\"\"\n\t        cpu_directory = \"/sys/devices/system/cpu\"\n\t        cpu_match = re.compile(\"(cpu[0-9]+)\")\n\t        for cpu_file in os.listdir(cpu_directory):\n\t            m = cpu_match.match(cpu_file)\n\t            if not m:\n\t                continue\n", "            yield m.group(1)\n\tapp = flask.Flask(__name__)\n\tsocketio = flask_socketio.SocketIO(app, cors_allowed_origins=\"*\")\n\tholoscan_test_controls = HoloscanTestControls(app)\n\t@app.route(\"/\")\n\tdef index():\n\t    return holoscan_test_controls.index()\n\t@socketio.on(\"update\")\n\tdef update(message):\n\t    holoscan_test_controls.update(message)\n", "@socketio.on(\"request\")\n\tdef request(message):\n\t    holoscan_test_controls.request(message)\n\t@socketio.on(\"connect\")\n\tdef connection():\n\t    \"\"\"\n\t    Support for telling the client to reload itself when the server\n\t    restarts.  The page itself includes our PID (via\n\t    _reload_on_server_update).  This callback--which we get when the client\n\t    reconnects to us--tells the client to reload itself if the PID they\n", "    have is different than ours.\n\t    \"\"\"\n\t    flask_socketio.emit(\"reload\", {\"id\": os.getpid()})\n\tdef main():\n\t    socketio.run(app, host=\"0.0.0.0\", port=8767)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "src/dgpu_util.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\timport subprocess\n\timport util\n\timport xml.etree.ElementTree as ET\n\tdef dgpu_board_information():\n\t    # Find all NVIDIA Video controller devices on the PCI bus.\n\t    command = [\"/usr/bin/lspci\", \"-n\", \"-d\", \"10de::0300\"]\n", "    for l in util.run_command(command):\n\t        pci_bus_address, pci_class, pci_id, rev = l.split(None, 3)\n\t        r = {\n\t            \"pci_bus_address\": pci_bus_address,\n\t            \"pci_class\": pci_class,\n\t            \"pci_id\": pci_id,\n\t            \"rev\": rev,\n\t        }\n\t        # Get nvidia-smi's output in XML format\n\t        command = [\"nvidia-smi\", \"-q\", \"--xml-format\", \"-i\", pci_bus_address]\n", "        try:\n\t            result = subprocess.run(\n\t                command,\n\t                capture_output=True,\n\t            )\n\t            xml_data = result.stdout\n\t            root = ET.fromstring(xml_data)\n\t            gpus = root.findall(\"./gpu\")\n\t            assert len(gpus) == 1\n\t            gpu = gpus[0]\n", "            r.update(\n\t                {\n\t                    \"serial\": gpu.find(\"serial\").text,\n\t                    \"uuid\": gpu.find(\"uuid\").text,\n\t                    \"vbios_version\": gpu.find(\"vbios_version\").text,\n\t                    \"board_id\": util.Hex(int(gpu.find(\"board_id\").text, 0)),\n\t                    \"gpu_part_number\": gpu.find(\"gpu_part_number\").text,\n\t                    \"img_version\": gpu.find(\"inforom_version\").find(\"img_version\").text,\n\t                }\n\t            )\n", "        except FileNotFoundError:\n\t            r[\"driver_status\"] = util.Na(\"DGPU driver not available\")\n\t        yield r\n\tdef dgpu_driver_information():\n\t    # Get nvidia-smi's output in XML format\n\t    command = [\"nvidia-smi\", \"-q\", \"--xml-format\"]\n\t    try:\n\t        result = subprocess.run(\n\t            command,\n\t            capture_output=True,\n", "        )\n\t        xml_data = result.stdout\n\t        root = ET.fromstring(xml_data)\n\t        information = {\n\t            \"driver_version\": root.find(\"driver_version\").text,\n\t            \"cuda_version\": root.find(\"cuda_version\").text,\n\t            \"attached_dgpus\": int(root.find(\"./attached_gpus\").text),\n\t        }\n\t    except FileNotFoundError:\n\t        information = {\"status\": util.Na(\"DGPU driver not available\")}\n", "    return information\n"]}
{"filename": "src/util.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t#\n\t# See README.md for detailed information.\n\t#\n\timport os\n\timport holoscan_test_suite.html_render as html_render\n\timport json\n", "import os.path\n\timport re\n\timport subprocess\n\timport yaml\n\tdef run_command(command, not_found_callback=None):\n\t    \"\"\"Runs the command (e.g. [\"/usr/sbin/ethtool\", \"-i\", \"wlan0\"]) in a\n\t    subshell, assert fails if there's anything on stderr or if the returncode\n\t    isn't 0, and yields back each line of stdout converted to a string (from\n\t    bytes).  If the command fails with a FileNotFoundError, we'll call\n\t    not_found_callback(command) unless it's None, in which case we'll propogate\n", "    the FileNotFoundError.\"\"\"\n\t    try:\n\t        result = subprocess.run(\n\t            command,\n\t            capture_output=True,\n\t        )\n\t    except FileNotFoundError:\n\t        if not_found_callback is None:\n\t            raise\n\t        not_found_callback(command)\n", "        return\n\t    if len(result.stderr) != 0:\n\t        print('ignoring \"%s\"' % (result.stderr,))\n\t    for s in result.stdout.decode(\"utf-8\").split(\"\\n\"):\n\t        # don't bother with blank lines.\n\t        if len(s) == 0:\n\t            continue\n\t        yield s\n\t    return result.returncode\n\tdef fetch(*path):\n", "    \"\"\"Shorthand that makes it easy to fetch the\n\t    contents of a file.  Typically used to fetch\n\t    e.g. /sys/class/net/(ethernet)/(setting)\"\"\"\n\t    with open(os.path.join(*path), \"rt\") as f:\n\t        v = f.read()\n\t    return v.strip()\n\tclass Hex(int):\n\t    \"\"\"Wraps int so that YAML and HTML will display it using hex.  NOTE that\n\t    because int's __new__ method stores the value that is used when this is\n\t    used in an int context, we don't need to worry about how that works here.\n", "    We just cache it for our own purposes.\"\"\"\n\t    def __init__(self, i, width=\"\"):\n\t        self._i = i\n\t        self._format = \"0x%%%sX\" % (width,)\n\t    def html(self):\n\t        return str(self)\n\t    def __str__(self):\n\t        return self._format % self._i\n\tyaml.add_representer(Hex, lambda dumper, data: dumper.represent_int(str(data)))\n\tclass Na:\n", "    \"\"\"Wraps a e.g. string value so that when it's rendered as HTML,\n\t    it uses the html_render.na style (e.g. italic).\"\"\"\n\t    def __init__(self, context):\n\t        self._context = context\n\t    def html(self):\n\t        return html_render.na(self._context)\n\t    def __str__(self):\n\t        return \"N/A: %s\" % self._context\n\tyaml.add_representer(Na, lambda dumper, data: dumper.represent_str(str(data)))\n\tdef emmc_information(path):\n", "    \"\"\"Fish around in e.g. /sys/block/mmcblk0 to\n\t    acquire data about the given device.\"\"\"\n\t    information = {\n\t        \"path\": path,\n\t        \"name\": fetch(path, \"device\", \"name\"),\n\t        \"rev\": Hex(int(fetch(path, \"device\", \"rev\"), 0)),\n\t        \"date\": fetch(path, \"device\", \"date\"),\n\t        \"fwrev\": fetch(path, \"device\", \"fwrev\"),\n\t        \"hwrev\": Hex(int(fetch(path, \"device\", \"hwrev\"), 0)),\n\t        \"serial\": int(fetch(path, \"device\", \"serial\"), 0),\n", "        \"type\": fetch(path, \"device\", \"type\"),\n\t        \"oemid\": Hex(int(fetch(path, \"device\", \"oemid\"), 0)),\n\t    }\n\t    return information\n\tdef list_pci_devices(device_ids):\n\t    # Find the devices on PCI.  pci_devices is indexed bus ID\n\t    # (e.g. \"0001:04:00.0\").  device_ids is a list of \"vendor:device:class\"\n\t    # per the lspci command-- leave a section blank to match all,\n\t    # (e.g. \"::0280\" will find all wifi devices).\n\t    pci_devices = {}\n", "    for device_id in device_ids:\n\t        # Sorry, we're not following the man page's instructions\n\t        # to use the \"machine readable\" format-- those values have\n\t        # quotes and stuff in them that make them hard to deal with.\n\t        command = [\"/usr/bin/lspci\", \"-n\", \"-d\", device_id]\n\t        for l in run_command(command):\n\t            pci_rev = Na(\"No value given\")\n\t            try:\n\t                pci_bus_address, pci_class, pci_id, pci_rev = l.split(None, 3)\n\t            except ValueError:\n", "                pci_bus_address, pci_class, pci_id = l.split(None, 2)\n\t            pci_devices[pci_bus_address] = {\n\t                \"pci_bus_address\": pci_bus_address,\n\t                \"pci_class\": pci_class,\n\t                \"pci_id\": pci_id,\n\t                \"pci_rev\": pci_rev,\n\t            }\n\t    return pci_devices\n\tdef nvme_information(path):\n\t    \"\"\"Use the \"nvme\" tool to fetch information about\n", "    this device.\"\"\"\n\t    # TO DO: Add PCI mapping information.\n\t    command = [\"/usr/sbin/nvme\", \"id-ctrl\", \"--output-format=json\", path]\n\t    information = {\"tool_status\": Na(\"nvme tool not found\")}\n\t    try:\n\t        result = subprocess.run(\n\t            command,\n\t            capture_output=True,\n\t        )\n\t        if len(result.stderr) != 0:\n", "            print(\"ignoring %s\" % (result.stderr,))\n\t        if result.returncode == 0:\n\t            m = json.loads(result.stdout)\n\t            information = {\n\t                \"path\": path,\n\t                \"vendor_oui\": m[\"ieee\"],\n\t                \"model_number\": m[\"mn\"].strip(),\n\t                \"serial_number\": m[\"sn\"].strip(),\n\t                \"firmware_revision\": m[\"fr\"].strip(),\n\t                \"pci_vendor_id\": m[\"vid\"],\n", "                \"pci_subsystem_vendor_id\": m[\"ssvid\"],\n\t                \"total_capacity_bytes\": m[\"tnvmcap\"],\n\t                \"total_capacity_gb\": round(m[\"tnvmcap\"] / (1024 * 1024 * 1024), 1),\n\t            }\n\t    except FileNotFoundError:\n\t        pass\n\t    return information\n\tdef sata_information(path):\n\t    \"\"\"Use hdparam to find information about this device (e.g. \"/dev/sda\").\"\"\"\n\t    command = [\"/sbin/hdparm\", \"-I\", path]\n", "    result = subprocess.run(\n\t        command,\n\t        capture_output=True,\n\t    )\n\t    binary_data = result.stdout\n\t    if len(result.stderr) != 0:\n\t        print(\"Ignoring stderr=%s\" % (result.stderr,))\n\t    if result.returncode != 0:\n\t        return {\"status\": Na(\"No device detected.\")}\n\t    data = binary_data.decode(\"utf-8\")\n", "    def match_group(rexp, group):\n\t        m = re.search(rexp, data, flags=re.MULTILINE)\n\t        return m.group(group)\n\t    # These regular expressions collect all the data, including spaces, in the\n\t    # line starting with e.g. \"Model Number:\"; but scraps spaces on either side of\n\t    # the model number string.\n\t    r = {\n\t        \"model_number\": match_group(\"Model Number:[ ]+(.+?)[ ]*$\", 1),\n\t        \"serial_number\": match_group(\"Serial Number:[ ]+(.+?)[ ]*$\", 1),\n\t        \"firmware_revision\": match_group(\"Firmware Revision:[ ]+(.+?)[ ]*$\", 1),\n", "    }\n\t    return r\n\tdef pci_network_device_information():\n\t    pci_devices = list_pci_devices([\"::0200\", \"::0280\"])\n\t    \"\"\"Look in /sys/class/net to learn about network devices.\"\"\"\n\t    network_path = \"/sys/class/net\"\n\t    interfaces = os.listdir(network_path)\n\t    for interface in interfaces:\n\t        # Can we map this back to a PCI slot?\n\t        path = \"/sys/class/net/%s/device\" % interface\n", "        realpath = os.path.realpath(path)\n\t        _, slot = os.path.split(realpath)\n\t        if slot not in pci_devices:\n\t            continue\n\t        information = {\n\t            \"interface\": interface,\n\t            \"mac_address\": fetch(network_path, interface, \"address\"),\n\t        }\n\t        information.update(pci_devices[slot])\n\t        command = [\"/usr/sbin/ethtool\", \"-i\", interface]\n", "        result = subprocess.run(\n\t            command,\n\t            capture_output=True,\n\t        )\n\t        if len(result.stderr) > 0:\n\t            # lo produces this error; don't include it at all.\n\t            assert b\"Operation not supported\" in result.stderr\n\t            continue\n\t        assert result.returncode == 0\n\t        for binary_line in result.stdout.split(b\"\\n\"):\n", "            if len(binary_line) == 0:\n\t                continue\n\t            l = binary_line.decode(\"utf-8\")\n\t            name, value = l.split(\": \", 1)\n\t            # don't clutter the report with irrelevant \"supports-...\" stuff\n\t            if name.startswith(\"supports-\"):\n\t                continue\n\t            name = name.replace(\"-\", \"_\")  # ethtool uses '-' to split up words in name\n\t            value = value if len(value) else Na(\"No value given\")\n\t            information[name] = value\n", "        yield information\n\tdef test_information(timestamp):\n\t    # What is our git revision\n\t    version = Na(\"Version not available.\")\n\t    try:\n\t        with open(\"project-version\", \"rt\") as f:\n\t            version = f.read().strip()\n\t    except FileNotFoundError:\n\t        pass\n\t    #\n", "    return {\n\t        \"device_time\": timestamp.isoformat(),\n\t        \"version\": version,\n\t    }\n\tdef to_snake(s):\n\t    l = \"_\".join(s.lower().split(\" \"))\n\t    return l\n\tdef v4l2_information(device):\n\t    try:\n\t        information = {}\n", "        category = None\n\t        for s in run_command([\"/usr/bin/v4l2-ctl\", \"--device\", device, \"--info\"]):\n\t            name_value_pair = s.split(\":\", 1)\n\t            name = name_value_pair[0].strip()\n\t            value = \"\"\n\t            if len(name_value_pair) > 1:\n\t                value = name_value_pair[1].strip()\n\t            if len(value) == 0:\n\t                value = Na(\"No value given\")\n\t            if s.startswith(\"\\t\\t\"):\n", "                continue\n\t            if s.startswith(\"\\t\"):\n\t                information[\"%s.%s\" % (category, to_snake(name))] = value\n\t                continue\n\t            category = to_snake(name)\n\t    except FileNotFoundError:\n\t        information = {\"status\": Na('V4L2 device \"%s\" not available' % device)}\n\t    return information\n"]}
{"filename": "src/test_sata.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\timport pytest\n\t@pytest.mark.clara_agx_devkit_only\n\tdef test_sata_clara_agx_devkit(script):\n\t    assert script.run(\"bringup_sata_clara_agx_devkit.sh\") == 0\n"]}
{"filename": "src/flask_wrapper.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t#\n\t# See README.md for detailed information.\n\t# This program configures the python flask framework to implement a simple web\n\t# application that wraps calls to pytest, possibly with a \"-k (test)\"\n\t# filter option.  The main program configures a web server that has URLs to\n\t# each of the tests established in the given script, and a special \"/test_all\"\n", "# URL and the \"/\" default URL are also added.\n\t#\n\t# The default URL (\"/\") produces an HTML page with a configuration report and\n\t# links to \"/test_all\" and each of the tests in the current directory.\n\t#\n\t# The \"/test_all\" URL results in running pytest on the all tests and accumulate\n\t# the results.  An HTML page is generated that includes the configuration\n\t# report above, a quick list of each test and it's pass/fail/skipped status,\n\t# and detail (stdout and stderr for each test) for each executed test, sorted\n\t# in test-name alphabetic order.\n", "#\n\t# Tests can be specifically marked as appropriate for IGX Orin Devkit or Clara\n\t# AGX devkit only, by prefixing the test with\n\t# \"@pytest.mark.igx_orin_devkit_only\" or \"@pytest.mark.clara_agx_devkit_only\":\n\t#\n\t#   import pytest\n\t#   @pytest.mark.clara_agx_devkit_only\n\t#   def test_sata_clara_agx_devkit(script):\n\t#       assert script.run(\"bringup_sata_clara_agx_devkit.sh\") == 0\n\t#\n", "# In this case, when run on an IGX Orin Devkit, this test will be skipped with an\n\t# appropriate message supplied.\n\t#\n\t# To run this program, tell it how to generate a configuration report:\n\t#\n\t#   python3 flask_wrapper.py demo_report\n\t#\n\t# This tells flask_wrapper.py to load demo_report.py.  This module provides an\n\t# \"identify()\" routine that returns a map of name/value pairs that describes\n\t# the system with sufficient detail to prove repeatability with a validated\n", "# configuration.\n\t#\n\t# Once the test cases are loaded, flask_wrapper sets up a web server on the\n\t# localhost at port 8765.\n\timport argparse\n\timport datetime\n\tfrom holoscan_test_suite.html_render import *\n\timport flask\n\timport importlib\n\timport os\n", "import pytest\n\timport sys\n\timport time\n\timport yaml\n\tREPORT_CACHE = \"/tmp/holoscan-test-suite-reports\"\n\tdef run_application(configuration, name):\n\t    \"\"\"Configure flask_wrapper with a server on port 8765.\"\"\"\n\t    # Get all the tests we know about.\n\t    test_name_accumulator = TestNameAccumulator()\n\t    pytest.main([\"--collect-only\"], plugins=[test_name_accumulator])\n", "    # Create and configure the flask application.\n\t    app = flask.Flask(name)\n\t    app.add_url_rule(\n\t        \"/\",\n\t        view_func=lambda: index_page(configuration, test_name_accumulator),\n\t        endpoint=\"/\",\n\t    )\n\t    app.add_url_rule(\n\t        \"/test_all\",\n\t        view_func=lambda: test_all(configuration, test_name_accumulator),\n", "        endpoint=\"/test_all\",\n\t    )\n\t    # Add /(testscript) pages\n\t    for test_script in test_name_accumulator.names():\n\t        app.add_url_rule(\n\t            \"/%s\" % test_script,\n\t            view_func=lambda test_script=test_script: run_script(\n\t                configuration, test_script\n\t            ),\n\t            endpoint=test_script,\n", "        )\n\t    app.add_url_rule(\n\t        \"/report\",\n\t        view_func=get_report,\n\t        endpoint=\"/report\",\n\t    )\n\t    # Allow the report to add pages\n\t    configuration.configure_app(app)\n\t    # Don't cache these pages on the browser side\n\t    app.after_request(disable_cache)\n", "    #\n\t    return app\n\tclass TestNameAccumulator:\n\t    \"\"\"This class listens to pytest for the tests\n\t    it finds.  Get that list of names by calling the\n\t    names() method.\n\t    \"\"\"\n\t    def __init__(self):\n\t        self._names = []\n\t    def pytest_collection_modifyitems(self, session, config, items):\n", "        \"\"\"Hooks into pytest to observe all the tests we're aware of.\"\"\"\n\t        for i in items:\n\t            self._names.append(i.name)\n\t        # we'll always run in a consistent order.\n\t        self._names.sort()\n\t    def names(self):\n\t        \"\"\"Fetch the list of test names we've found.\"\"\"\n\t        for name in self._names:\n\t            yield name\n\tdef index_page(configuration, test_name_accumulator):\n", "    \"\"\"Generate the index page.\"\"\"\n\t    #\n\t    now = time.time()\n\t    timestamp = datetime.datetime.fromtimestamp(now, tz=datetime.timezone.utc)\n\t    # Start with the configuration report\n\t    information = configuration.information()\n\t    # Save it.\n\t    configuration_report_name = timestamp.strftime(\n\t        \"configuration-report-%Y-%m-%d-%H-%M-%S.yaml\"\n\t    )\n", "    s = yaml.dump(information, default_flow_style=False)\n\t    os.makedirs(REPORT_CACHE, exist_ok=True)\n\t    with open(os.path.join(REPORT_CACHE, configuration_report_name), \"wt\") as f:\n\t        f.write(s)\n\t    # Reports.\n\t    doc = [\n\t        header(3, \"Reports\"),\n\t        rtable(\n\t            {\n\t                \"Configuration report\": Link(\n", "                    configuration_report_name,\n\t                    \"/report?report_name=%s\" % (escape(configuration_report_name),),\n\t                ),\n\t            }\n\t        ),\n\t        horizontal_rule(),\n\t    ]\n\t    # Actions.\n\t    include_timestamp = {\n\t        \"onclick\": 'now=new Date();this.href+=\"?iso_time_utc=\"+now.toISOString()+\"&local_time=\"+now.toLocaleString()+\" (\"+Intl.DateTimeFormat().resolvedOptions().timeZone+\")\"'\n", "    }\n\t    doc.append(\n\t        [\n\t            header(3, \"Actions\"),\n\t            ul([link(\"Run all tests\", \"test_all\", attributes=include_timestamp)]),\n\t            ul(\n\t                [\n\t                    link(\"Run %s\" % s, s, attributes=include_timestamp)\n\t                    for s in test_name_accumulator.names()\n\t                ]\n", "            ),\n\t            configuration.actions(),  # This configuration may have special controls.\n\t            horizontal_rule(),\n\t        ]\n\t    )\n\t    # Configuration.\n\t    doc.append(\n\t        [\n\t            header(3, \"Configuration\"),\n\t            rtable(information),\n", "            horizontal_rule(),\n\t        ]\n\t    )\n\t    # Send it.\n\t    r = render(html(body(doc)))\n\t    return r\n\tclass HoloscanTestSuitePlugin:\n\t    def __init__(self):\n\t        self._start = time.time()\n\t        self._information = {}\n", "    @pytest.hookimpl(tryfirst=True, hookwrapper=True)\n\t    def pytest_runtest_makereport(self, item, call):\n\t        # get the test report object; this is called\n\t        # after each test is run.\n\t        outcome = yield\n\t        report = outcome.get_result()\n\t        script = item.funcargs.get(\"script\", None)\n\t        capsys = item.funcargs.get(\"capsys\", None)\n\t        #\n\t        passed_style = {}\n", "        failed_style = {\"color\": \"red\"}\n\t        if (report.when == \"setup\") and report.skipped:\n\t            r = {\n\t                \"passed\": report.passed,\n\t                \"outcome\": report.outcome,\n\t                \"skipped\": report.skipped,\n\t                \"reason\": call.excinfo.value.msg,\n\t                \"pytest_output\": report.longreprtext,\n\t                \"stdout\": \"\",\n\t                \"stderr\": \"\",\n", "            }\n\t            self._information[item.name] = r\n\t            return\n\t        if report.when == \"call\":\n\t            r = {\n\t                \"passed\": report.passed,\n\t                \"outcome\": report.outcome,\n\t                \"skipped\": report.skipped,\n\t                \"duration\": report.duration,\n\t                \"pytest_output\": report.longreprtext,\n", "            }\n\t            # script._result is the output from the shell scripts.\n\t            if script is not None:\n\t                result = script._result\n\t                r.update(\n\t                    {\n\t                        \"stdout\": result.stdout.decode(\"utf-8\"),\n\t                        \"stderr\": result.stderr.decode(\"utf-8\"),\n\t                    }\n\t                )\n", "            elif capsys is not None:\n\t                outerr = capsys.readouterr()\n\t                r.update(\n\t                    {\n\t                        \"stdout\": outerr.out,\n\t                        \"stderr\": outerr.err,\n\t                    }\n\t                )\n\t            else:\n\t                r.update(\n", "                    {\n\t                        \"stdout\": \"N/A\",\n\t                        \"stderr\": \"N/A\",\n\t                    }\n\t                )\n\t            #\n\t            self._information[item.name] = r\n\t            return\n\t        # we ignore any other reports.\n\t    def information(self):\n", "        return self._information\n\t_passed_style = {}\n\t_failed_style = {\"color\": \"red\"}\n\tdef _test_status(status):\n\t    if status[\"skipped\"]:\n\t        return div(\"SKIPPED\")\n\t    if status[\"passed\"]:\n\t        return div(\"Passed\", style=_passed_style)\n\t    return div(\"FAILED\", style=_failed_style)\n\tdef html_results(results):\n", "    document = []\n\t    passed_style = {}\n\t    failed_style = {\"color\": \"red\"}\n\t    output_style = {\n\t        \"margin-left\": \"40px\",\n\t        \"background-color\": \"#EEEEEE\",\n\t    }\n\t    na_style = {\n\t        \"margin-left\": \"40px\",\n\t    }\n", "    # Include specific test data\n\t    items = []\n\t    for test_name, status in results.items():\n\t        #\n\t        detail = header(4, test_name, attributes={\"id\": test_name})\n\t        t = [(\"passed\", _test_status(status))]\n\t        if \"duration\" in status:\n\t            t.append((\"duration\", \"%.2fs\" % status[\"duration\"]))\n\t        if \"reason\" in status:\n\t            t.append((\"reason\", status[\"reason\"]))\n", "        detail.append(table(t))\n\t        pytest_output = status[\"pytest_output\"]\n\t        detail.append(paragraph(\"pytest output\"))\n\t        if len(pytest_output):\n\t            detail.append(pre(pytest_output, style=output_style))\n\t        else:\n\t            detail.append(na(\"No pytest output generated\", style=na_style))\n\t        #\n\t        standard_output = status[\"stdout\"]\n\t        detail.append(paragraph(\"Standard output\"))\n", "        if len(standard_output):\n\t            detail.append(pre(standard_output, style=output_style))\n\t        else:\n\t            detail.append(na(\"No standard output captured.\", style=na_style))\n\t        #\n\t        standard_error = status[\"stderr\"]\n\t        detail.append(paragraph(\"Standard error\"))\n\t        if len(standard_error):\n\t            detail.append(pre(standard_error, style=output_style))\n\t        else:\n", "            detail.append(na(\"No standard error captured.\", style=na_style))\n\t        detail.append(horizontal_rule())\n\t        items.append(detail)\n\t    document.append(ul(items))\n\t    return document\n\tdef _run_tests(configuration, test_names):\n\t    def generate(args):\n\t        now = time.time()\n\t        timestamp = datetime.datetime.fromtimestamp(now, tz=datetime.timezone.utc)\n\t        # Generate the output we can\n", "        information = configuration.information()\n\t        information[\"test\"][\"browser_iso_time_utc\"] = args[\"iso_time_utc\"]\n\t        information[\"test\"][\"browser_local_time\"] = args[\"local_time\"]\n\t        # Save the configuration report.\n\t        configuration_report_name = timestamp.strftime(\n\t            \"configuration-report-%Y-%m-%d-%H-%M-%S.yaml\"\n\t        )\n\t        report_name = timestamp.strftime(\"test-report-%Y-%m-%d-%H-%M-%S.yaml\")\n\t        s = yaml.dump(information, default_flow_style=False)\n\t        os.makedirs(REPORT_CACHE, exist_ok=True)\n", "        with open(os.path.join(REPORT_CACHE, configuration_report_name), \"wt\") as f:\n\t            f.write(s)\n\t        #\n\t        summary_rows = []\n\t        for test_name in test_names:\n\t            attributes = {\"id\": \"status_%s\" % test_name}\n\t            summary_rows.append(\n\t                [\n\t                    link(test_name, url=\"#%s\" % test_name),\n\t                    div(\"UNTESTED\", attributes=attributes),\n", "                ]\n\t            )\n\t        document_part = [\n\t            header(3, \"Testing Summary\"),\n\t            table(summary_rows),\n\t            horizontal_rule(),\n\t            header(3, \"Reports\"),\n\t            rtable(\n\t                {\n\t                    \"Configuration report\": Link(\n", "                        configuration_report_name,\n\t                        \"/report?report_name=%s\" % (escape(configuration_report_name),),\n\t                    ),\n\t                    \"Test results report\": Link(\n\t                        report_name, \"/report?report_name=%s\" % (escape(report_name),)\n\t                    ),\n\t                }\n\t            ),\n\t            horizontal_rule(),\n\t            header(3, \"Configuration\"),\n", "            rtable(information),\n\t            horizontal_rule(),\n\t            header(3, \"Testing Detail\"),\n\t        ]\n\t        html_out = render([html_start(), body_start(), document_part])\n\t        yield html_out\n\t        #\n\t        # Run it.\n\t        accumulated_results = {}\n\t        for test_name in test_names:\n", "            # We're underway\n\t            document_part = [\n\t                script(\n\t                    'document.getElementById(\"status_%s\").innerText = \"UNDERWAY\"'\n\t                    % test_name\n\t                ),\n\t            ]\n\t            html_out = render(document_part)\n\t            yield html_out\n\t            holoscan_test_suite_plugin = HoloscanTestSuitePlugin()\n", "            pytest_command_line = [\n\t                \"-p\",\n\t                \"no:cacheprovider\",\n\t                \"-k\",\n\t                test_name,\n\t            ]\n\t            pytest.main(\n\t                pytest_command_line,\n\t                plugins=[\n\t                    holoscan_test_suite_plugin,\n", "                ],\n\t            )\n\t            # Report it.\n\t            results = holoscan_test_suite_plugin.information()\n\t            accumulated_results.update(results)\n\t            # YAML\n\t            yaml_result = {\n\t                \"identification\": information,\n\t                \"results\": accumulated_results,\n\t            }\n", "            s = yaml.dump(yaml_result, default_flow_style=False)\n\t            os.makedirs(REPORT_CACHE, exist_ok=True)\n\t            with open(os.path.join(REPORT_CACHE, report_name), \"wt\") as f:\n\t                f.write(s)\n\t            # HTML\n\t            document_part = [html_results(results)]\n\t            for result_test_name, result_status in results.items():\n\t                if result_status[\"skipped\"]:\n\t                    s = \"SKIPPED\"\n\t                elif result_status[\"passed\"]:\n", "                    s = \"PASSED\"\n\t                else:\n\t                    s = \"FAILED\"\n\t                document_part.append(\n\t                    [\n\t                        script(\n\t                            'document.getElementById(\"status_%s\").innerText = \"%s\"'\n\t                            % (result_test_name, s)\n\t                        )\n\t                    ],\n", "                )\n\t            html_out = render(document_part)\n\t            yield html_out\n\t        document_part = [body_end(), html_end()]\n\t        html_out = render(document_part)\n\t        yield html_out\n\t    args = flask.request.args\n\t    return flask.Response(generate(args), mimetype=\"text/html\")\n\tdef test_all(configuration, test_name_accumulator):\n\t    \"\"\"Runs all the tests that test_name_accumulator knows about.\"\"\"\n", "    return _run_tests(configuration, list(test_name_accumulator.names()))\n\tdef run_script(configuration, test_script):\n\t    return _run_tests(configuration, [test_script])\n\tdef get_report():\n\t    args = flask.request.args\n\t    report_name = args[\"report_name\"]\n\t    print(\"REPORT_CACHE=%s report_name=%s\" % (REPORT_CACHE, report_name))\n\t    return flask.send_from_directory(REPORT_CACHE, report_name, as_attachment=True)\n\tdef disable_cache(response):\n\t    \"\"\"This hook (\"app.after_request\") allows us to tell\n", "    flask to include the html header that disables the\n\t    client browser cache.\n\t    \"\"\"\n\t    response.cache_control.no_cache = True\n\t    return response\n\tdef main():\n\t    #\n\t    parser = argparse.ArgumentParser(\n\t        description=\"Run a test application with the given configuration\",\n\t    )\n", "    parser.add_argument(\"configuration\", help=\"Name of configuration module\")\n\t    parser.add_argument(\n\t        \"factory\", help=\"Name of method that returns a Configuration object\"\n\t    )\n\t    args = parser.parse_args()\n\t    #\n\t    configuration_module = importlib.import_module(args.configuration)\n\t    factory = getattr(configuration_module, args.factory)\n\t    configuration = factory()\n\t    app = run_application(configuration, __name__)\n", "    app.run(host=\"0.0.0.0\", port=8765)\n\t    return 0\n\tif __name__ == \"__main__\":\n\t    sys.exit(main())\n"]}
{"filename": "src/conftest.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\t#\n\t# This file provides pytest with the \"script\" fixture.  Calling \"script.run\"\n\t# provides the convenient mechanism for executing a shell script and preserving\n\t# the returncode, stdout, and stderr.  flask_wrapper.py then knows how to fetch the\n\t# results from script instances and put those in the HTML generated output.\n", "#\n\timport pytest\n\timport nvidia_util\n\timport subprocess\n\tclass Script:\n\t    \"\"\"\n\t    The \"script\" fixture fetches an instance of\n\t    this object; use the \"run\" method here to run\n\t    the given script in the current directory\n\t    and save the data written to stdout and stderr.\n", "    In the nominal case, flask_wrapper.py will\n\t    write that data to the HTML page passed to\n\t    the calling browser.\n\t    \"\"\"\n\t    def __init__(self):\n\t        self._result = None\n\t    def run(self, script):\n\t        command = [\"bash\", script]\n\t        r = subprocess.run(\n\t            command,\n", "            capture_output=True,\n\t        )\n\t        self._result = r\n\t        return r.returncode\n\t@pytest.fixture\n\tdef script():\n\t    r = Script()\n\t    return r\n\tdef pytest_collection_modifyitems(items):\n\t    model = nvidia_util.model()\n", "    igx_orin_devkit = model in nvidia_util.igx_orin_devkit\n\t    clara_agx_devkit = model in nvidia_util.clara_agx_devkit\n\t    for item in items:\n\t        if \"igx_orin_devkit_only\" in item.keywords:\n\t            skip = pytest.mark.skip(\n\t                reason=\"%s isn't appropriate for %s\" % (item.name, model)\n\t            )\n\t            if not igx_orin_devkit:\n\t                item.add_marker(skip)\n\t        if \"clara_agx_devkit_only\" in item.keywords:\n", "            skip = pytest.mark.skip(\n\t                reason=\"%s isn't appropriate for %s\" % (item.name, model)\n\t            )\n\t            if not clara_agx_devkit:\n\t                item.add_marker(skip)\n"]}
{"filename": "src/test_nvme.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\timport pytest\n\t@pytest.mark.igx_orin_devkit_only\n\tdef test_nvme(script):\n\t    assert script.run(\"bringup_nvme_igx_orin_devkit.sh\") == 0\n"]}
{"filename": "src/configuration.py", "chunked_list": ["# SPDX-FileCopyrightText: Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n\t# SPDX-License-Identifier: Apache-2.0\n\t#\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#\n\t# http://www.apache.org/licenses/LICENSE-2.0\n\t#\n\t# Unless required by applicable law or agreed to in writing, software\n", "# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# See README.md for detailed information.\n\timport ajantv2_util\n\timport datetime\n\timport dgpu_util\n\timport infiniband_util\n\timport nvidia_util\n", "import os\n\timport time\n\timport util\n\timport yaml\n\tclass Configuration:\n\t    def __init__(self, information):\n\t        self._information = information\n\t    def information(self):\n\t        return self._information\n\t    def configure_app(self, flask_app):\n", "        pass\n\t    def actions(self):\n\t        return []\n\tfrom holoscan_test_suite.html_render import *\n\tpci_id_fixup = str.maketrans(\":.\", \"__\")\n\tdef by_pci_bus_address(prefix, iterable):\n\t    r = {}\n\t    for i in iterable:\n\t        r[prefix % i[\"pci_bus_address\"].translate(pci_id_fixup)] = i\n\t    return r\n", "class IgxOrinDevkitConfiguration(Configuration):\n\t    def __init__(self):\n\t        self._now = time.time()\n\t        self._timestamp = datetime.datetime.fromtimestamp(\n\t            self._now, tz=datetime.timezone.utc\n\t        )\n\t        no_dgpus = [util.Na(\"No dGPU found\")]\n\t        no_ajas = [util.Na(\"No AJA video adapter found\")]\n\t        configuration = {\n\t            \"test\": util.test_information(self._timestamp),\n", "            \"idrom\": nvidia_util.jetson_eeprom_information(),\n\t            \"dgpu_driver\": dgpu_util.dgpu_driver_information(),\n\t            **by_pci_bus_address(\"dgpu_%s\", dgpu_util.dgpu_board_information()),\n\t            \"aja_driver\": ajantv2_util.aja_driver_information(),\n\t            **by_pci_bus_address(\"aja_%s\", ajantv2_util.aja_board_information()),\n\t            \"mmcblk0\": util.emmc_information(\"/sys/block/mmcblk0\"),\n\t            \"nvme0n1\": util.nvme_information(\"/dev/nvme0n1\"),\n\t            \"sata_sda\": util.sata_information(\"/dev/sda\"),\n\t            \"video_0\": util.v4l2_information(\"/dev/video0\"),\n\t            **by_pci_bus_address(\n", "                \"mellanox_%s\", infiniband_util.infiniband_information()\n\t            ),\n\t            **by_pci_bus_address(\"net_%s\", util.pci_network_device_information()),\n\t        }\n\t        sorted_dict = lambda d: {k: d[k] for k in sorted(d)}\n\t        super(IgxOrinDevkitConfiguration, self).__init__(sorted_dict(configuration))\n\tdef igx_orin_devkit_configuration():\n\t    return IgxOrinDevkitConfiguration()\n\t# Produce the YAML report if we're just run at the command line.\n\tdef main():\n", "    configuration = igx_orin_devkit_configuration()\n\t    information = configuration.information()\n\t    s = yaml.dump(information, default_flow_style=False)\n\t    print(s)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
