{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/main.py", "chunked_list": ["\"\"\"Main FastAPI app instance declaration.\"\"\"\n\tfrom fastapi import FastAPI\n\tfrom fastapi.middleware.cors import CORSMiddleware\n\tfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\n\tfrom src.api.router import router\n\tfrom src.core import config\n\tapp = FastAPI(\n\t    title=config.settings.PROJECT_NAME,\n\t    version=config.settings.VERSION,\n\t    description=config.settings.DESCRIPTION,\n", "    openapi_url=\"/openapi.json\",\n\t    docs_url=\"/docs\",\n\t)\n\tapp.include_router(router)\n\t# Sets all CORS enabled origins\n\tapp.add_middleware(\n\t    CORSMiddleware,\n\t    allow_origins=[str(origin) for origin in config.settings.BACKEND_CORS_ORIGINS],\n\t    allow_credentials=True,\n\t    allow_methods=[\"*\"],\n", "    allow_headers=[\"*\"],\n\t)\n\t# Guards against HTTP Host Header attacks\n\tapp.add_middleware(TrustedHostMiddleware, allowed_hosts=config.settings.ALLOWED_HOSTS)\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/__init__.py", "chunked_list": []}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/conftest.py", "chunked_list": ["\"\"\"\n\tUsed to set environment variable before running tests.\n\tWe need this to use test database.\n\t\"\"\"\n\timport os\n\t# This will ensure using test database\n\tos.environ[\"ENVIRONMENT\"] = \"PYTEST\"\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/schemas/auth.py", "chunked_list": ["\"\"\"Auth schemas.\"\"\"\n\tfrom .base import BaseRequest, BaseResponse\n\tclass RefreshTokenRequest(BaseRequest):\n\t    refresh_token: str\n\tclass AccessTokenResponse(BaseResponse):\n\t    token_type: str\n\t    access_token: str\n\t    expires_at: int\n\t    issued_at: int\n\t    refresh_token: str\n", "    refresh_token_expires_at: int\n\t    refresh_token_issued_at: int\n\tclass JWTTokenPayload(BaseRequest):\n\t    sub: str\n\t    refresh: bool\n\t    issued_at: int\n\t    expires_at: int\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/schemas/base.py", "chunked_list": ["\"\"\"Base schemas for all requests and responses.\"\"\"\n\tfrom pydantic import BaseModel\n\tclass BaseRequest(BaseModel):\n\t    # may define additional fields or config shared across requests\n\t    pass\n\tclass BaseResponse(BaseModel):\n\t    # may define additional fields or config shared across responses\n\t    class Config:\n\t        orm_mode = True\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/schemas/users.py", "chunked_list": ["\"\"\"User schemas.\"\"\"\n\tfrom pydantic import EmailStr\n\tfrom .base import BaseRequest, BaseResponse\n\tclass UserCreateRequest(BaseRequest):\n\t    email: EmailStr\n\t    password: str\n\tclass UserUpdateRequest(BaseRequest):\n\t    email: EmailStr | None = None\n\t    password: str | None = None\n\tclass UserResponse(BaseResponse):\n", "    id: str\n\t    email: EmailStr\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/schemas/__init__.py", "chunked_list": ["from .auth import AccessTokenResponse, JWTTokenPayload, RefreshTokenRequest\n\tfrom .users import UserCreateRequest, UserResponse, UserUpdateRequest\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/test_users.py", "chunked_list": ["from httpx import AsyncClient\n\tfrom sqlalchemy import select\n\tfrom sqlalchemy.ext.asyncio import AsyncSession\n\tfrom src.main import app\n\tfrom src.models import User\n\tfrom src.tests.conftest import TEST_USER\n\tasync def test_get_current_user(client: AsyncClient, default_user_headers):\n\t    response = await client.get(\n\t        app.url_path_for(\"read_current_user\"), headers=default_user_headers\n\t    )\n", "    assert response.status_code == 200\n\t    assert response.json() == {\n\t        \"id\": TEST_USER.id,\n\t        \"email\": TEST_USER.email,\n\t    }\n\tasync def test_delete_current_user(\n\t    client: AsyncClient, default_user_headers, default_user, db_session: AsyncSession\n\t):\n\t    response = await client.delete(\n\t        app.url_path_for(\"delete_user\", id=default_user.id),\n", "        headers=default_user_headers,\n\t    )\n\t    assert response.status_code == 204\n\t    result = await db_session.execute(select(User).where(User.id == TEST_USER.id))\n\t    user = result.scalars().first()\n\t    assert user is None\n\tasync def test_update_current_user(\n\t    client: AsyncClient, default_user_headers, default_user, db_session: AsyncSession\n\t):\n\t    response = await client.patch(\n", "        app.url_path_for(\"update_user\", id=default_user.id),\n\t        headers=default_user_headers,\n\t        json={\"email\": \"new_test_email@test.com\"},\n\t    )\n\t    assert response.status_code == 200\n\t    result = await db_session.execute(select(User).where(User.id == TEST_USER.id))\n\t    user = result.scalars().first()\n\t    assert user is not None\n\t    assert user.email != TEST_USER.email\n\tasync def test_register_new_user(\n", "    client: AsyncClient, default_user_headers, db_session: AsyncSession\n\t):\n\t    response = await client.post(\n\t        app.url_path_for(\"register_new_user\"),\n\t        headers=default_user_headers,\n\t        json={\n\t            \"email\": \"new_user@test.com\",\n\t            \"password\": \"another_password\",\n\t        },\n\t    )\n", "    assert response.status_code == 201\n\t    result = await db_session.execute(\n\t        select(User).where(User.email == \"new_user@test.com\")\n\t    )\n\t    user = result.scalars().first()\n\t    assert user is not None\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/__init__.py", "chunked_list": []}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/test_auth.py", "chunked_list": ["from httpx import AsyncClient\n\tfrom src.main import app\n\tfrom src.models import User\n\tfrom src.tests.conftest import TEST_USER\n\tasync def test_auth_access_token(client: AsyncClient, default_user: User):\n\t    response = await client.post(\n\t        app.url_path_for(\"login_access_token\"),\n\t        data={\n\t            \"username\": TEST_USER.email,\n\t            \"password\": TEST_USER.unhashed_password,\n", "        },\n\t    )\n\t    assert response.status_code == 200\n\t    token = response.json()\n\t    assert token[\"token_type\"] == \"Bearer\"\n\t    assert \"access_token\" in token\n\t    assert \"expires_at\" in token\n\t    assert \"issued_at\" in token\n\t    assert \"refresh_token\" in token\n\t    assert \"refresh_token_expires_at\" in token\n", "    assert \"refresh_token_issued_at\" in token\n\tasync def test_auth_access_token_fail_no_user(client: AsyncClient):\n\t    response = await client.post(\n\t        app.url_path_for(\"login_access_token\"),\n\t        data={\n\t            \"username\": \"xxx\",\n\t            \"password\": \"yyy\",\n\t        },\n\t    )\n\t    assert response.status_code == 404\n", "    assert response.json() == {\"detail\": \"User not found.\"}\n\tasync def test_auth_refresh_token(client: AsyncClient, default_user: User):\n\t    response = await client.post(\n\t        app.url_path_for(\"login_access_token\"),\n\t        data={\n\t            \"username\": TEST_USER.email,\n\t            \"password\": TEST_USER.unhashed_password,\n\t        },\n\t    )\n\t    refresh_token = response.json()[\"refresh_token\"]\n", "    new_token_response = await client.post(\n\t        app.url_path_for(\"refresh_token\"), json={\"refresh_token\": refresh_token}\n\t    )\n\t    assert new_token_response.status_code == 200\n\t    token = new_token_response.json()\n\t    assert token[\"token_type\"] == \"Bearer\"\n\t    assert \"access_token\" in token\n\t    assert \"expires_at\" in token\n\t    assert \"issued_at\" in token\n\t    assert \"refresh_token\" in token\n", "    assert \"refresh_token_expires_at\" in token\n\t    assert \"refresh_token_issued_at\" in token\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/conftest.py", "chunked_list": ["\"\"\"Pytest configuration file.\n\tUsed to execute code before running tests, in this case we want to use test database.\n\t\"\"\"\n\timport asyncio\n\tfrom collections.abc import AsyncGenerator\n\timport pytest\n\timport pytest_asyncio\n\tfrom httpx import AsyncClient\n\tfrom sqlalchemy import select\n\tfrom sqlalchemy.ext.asyncio import create_async_engine\n", "from src.core.db import async_db\n\tfrom src.main import app\n\tfrom src.models import Base, User\n\tfrom .utils.test_database import create_database, drop_database\n\tfrom .utils.test_user import TestUser\n\tTEST_USER = TestUser()\n\tTEST_DATABASE_URL = async_db.set_async_db_uri\n\t@pytest.fixture(scope=\"session\")\n\tdef event_loop():\n\t    loop = asyncio.new_event_loop()\n", "    asyncio.set_event_loop(loop)\n\t    yield loop\n\t    loop.close()\n\t@pytest_asyncio.fixture(scope=\"session\")\n\tasync def client() -> AsyncGenerator[AsyncClient, None]:\n\t    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n\t        client.headers.update({\"Host\": \"localhost\"})\n\t        yield client\n\t@pytest.fixture(scope=\"session\")\n\tasync def database(event_loop):\n", "    await create_database(TEST_DATABASE_URL)\n\t    engine = create_async_engine(TEST_DATABASE_URL)\n\t    async with engine.begin() as conn:\n\t        await conn.run_sync(Base.metadata.create_all)\n\t    await engine.dispose()\n\t    try:\n\t        yield TEST_DATABASE_URL\n\t    finally:\n\t        await drop_database(TEST_DATABASE_URL)\n\t@pytest.fixture(scope=\"session\")\n", "async def sqla_engine(database):\n\t    async with async_db.async_engine.begin() as conn:\n\t        yield conn\n\t@pytest.fixture(scope=\"session\")\n\tasync def db_session(sqla_engine):\n\t    async with async_db.async_session() as session:\n\t        yield session\n\t@pytest_asyncio.fixture\n\tasync def default_user(database) -> User:\n\t    async with async_db.async_session() as session:\n", "        result = await session.execute(select(User).where(User.id == TEST_USER.id))\n\t        user = result.scalars().first()\n\t        if user is None:\n\t            new_user = User(\n\t                email=TEST_USER.email,\n\t                password=TEST_USER.password,\n\t            )\n\t            new_user.id = TEST_USER.id\n\t            session.add(new_user)\n\t            await session.commit()\n", "            await session.refresh(new_user)\n\t            return new_user\n\t        return user\n\t@pytest.fixture\n\tdef default_user_headers(default_user: User):\n\t    return {\"Authorization\": f\"Bearer {TEST_USER.access_token}\"}\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/utils/test_user.py", "chunked_list": ["from random import randint\n\tfrom uuid import uuid4\n\tfrom src.core.security.jwt import jwt_generator\n\tfrom src.core.security.password import password_generator\n\tclass TestUser:\n\t    id: str = str(uuid4())\n\t    email: str = f\"test_{randint(0, 10)}@test.com\"\n\t    unhashed_password: str = f\"testing_user_{randint(0, 10)}\"\n\t    password: str = password_generator.get_password_hash(unhashed_password)\n\t    access_token = jwt_generator._generate_jwt_token(\n", "        str(id), 60 * 60 * 24, refresh=False\n\t    )[0]\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/utils/test_database.py", "chunked_list": ["from sqlalchemy import text\n\tfrom sqlalchemy.engine import make_url\n\tfrom sqlalchemy.ext.asyncio import create_async_engine\n\tfrom src.core import config\n\tDEFAULT_DB = config.settings.DB_NAME\n\tasync def create_database(url: str):\n\t    \"\"\"Create the test database if it doesn't exist yet.\n\t    In case it does exist, drop it and create it again.\n\t    \"\"\"\n\t    url_object = make_url(url)\n", "    database_name = url_object.database\n\t    dbms_url = url_object.set(database=DEFAULT_DB)\n\t    engine = create_async_engine(dbms_url, isolation_level=\"AUTOCOMMIT\")\n\t    async with engine.connect() as conn:\n\t        result = await conn.execute(\n\t            text(f\"SELECT 1 FROM pg_database WHERE datname='{database_name}'\")\n\t        )\n\t        database_exists = result.scalar() == 1\n\t    if database_exists:\n\t        await drop_database(str(url_object))\n", "    async with engine.connect() as conn:\n\t        await conn.execute(\n\t            text(\n\t                f'CREATE DATABASE \"{database_name}\" ENCODING \"utf8\" TEMPLATE template1'\n\t            )\n\t        )\n\t    await engine.dispose()\n\tasync def drop_database(url: str):\n\t    \"\"\"Helper function to drop a database.\n\t    This is used to drop the test database after the tests are done.\n", "    \"\"\"\n\t    url_object = make_url(url)\n\t    dbms_url = url_object.set(database=DEFAULT_DB)\n\t    engine = create_async_engine(dbms_url, isolation_level=\"AUTOCOMMIT\")\n\t    async with engine.connect() as conn:\n\t        disc_users = \"\"\"\n\t        SELECT pg_terminate_backend(pg_stat_activity.%(pid_column)s)\n\t        FROM pg_stat_activity\n\t        WHERE pg_stat_activity.datname = '%(database)s'\n\t          AND %(pid_column)s <> pg_backend_pid();\n", "        \"\"\" % {\n\t            \"pid_column\": \"pid\",\n\t            \"database\": url_object.database,\n\t        }\n\t        await conn.execute(text(disc_users))\n\t        await conn.execute(text(f'DROP DATABASE \"{url_object.database}\"'))\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/tests/utils/__init__.py", "chunked_list": []}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/models/base.py", "chunked_list": ["from sqlalchemy.orm import DeclarativeBase\n\tclass Base(DeclarativeBase):\n\t    pass\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/models/users.py", "chunked_list": ["import uuid\n\tfrom sqlalchemy import String\n\tfrom sqlalchemy.dialects.postgresql import UUID\n\tfrom sqlalchemy.orm import Mapped, mapped_column\n\tfrom .base import Base\n\tclass User(Base):\n\t    __tablename__ = \"user_model\"\n\t    id: Mapped[str] = mapped_column(\n\t        UUID(as_uuid=False), primary_key=True, default=lambda _: str(uuid.uuid4())\n\t    )\n", "    email: Mapped[str] = mapped_column(String(128), nullable=False, unique=True)\n\t    password: Mapped[str] = mapped_column(String(128), nullable=False)\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/models/dogs.py", "chunked_list": ["import uuid\n\tfrom sqlalchemy import String\n\tfrom sqlalchemy.dialects.postgresql import UUID\n\tfrom sqlalchemy.orm import Mapped, mapped_column\n\tfrom .base import Base\n\tclass Dog(Base):\n\t    __tablename__ = \"dog_model\"\n\t    id: Mapped[str] = mapped_column(\n\t        UUID(as_uuid=False), primary_key=True, default=lambda _: str(uuid.uuid4())\n\t    )\n", "    name: Mapped[str] = mapped_column(String(128), nullable=False)\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/models/__init__.py", "chunked_list": ["from .base import Base\n\tfrom .dogs import Dog\n\tfrom .users import User\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/config.py", "chunked_list": ["\"\"\"\n\tFile with environment variables and general configuration logic.\n\t`SECRET_KEY`, `ENVIRONMENT` etc. map to env variables with the same names.\n\tFor project name, version, description we use pyproject.toml\n\tFor the rest, we use file `.env` (gitignored), see `.env.example`\n\tSee https://pydantic-docs.helpmanual.io/usage/settings/\n\tNote, complex types like lists are read as json-encoded strings.\n\t\"\"\"\n\tfrom pathlib import Path\n\tfrom secrets import token_hex\n", "from typing import Literal\n\timport toml\n\tfrom pydantic import AnyHttpUrl, BaseSettings, PostgresDsn, validator\n\tPROJECT_DIR = Path(__file__).parent.parent.parent\n\tPYPROJECT_CONTENT = toml.load(f\"{PROJECT_DIR}/pyproject.toml\")[\"tool\"][\"poetry\"]\n\tclass Settings(BaseSettings):\n\t    # CORE SETTINGS\n\t    SECRET_KEY: str = token_hex(32)  # Use an environment variable instead.\n\t    ENVIRONMENT: Literal[\"DEV\", \"PYTEST\", \"STG\", \"PRD\"] = \"DEV\"\n\t    SECURITY_BCRYPT_ROUNDS: int = 12\n", "    ACCESS_TOKEN_EXPIRE_MINUTES: int = 10080  # 7 days\n\t    REFRESH_TOKEN_EXPIRE_MINUTES: int = 20160  # 14 days\n\t    ACCESS_TOKEN_EXPIRE: int = ACCESS_TOKEN_EXPIRE_MINUTES * 60\n\t    REFRESH_TOKEN_EXPIRE: int = REFRESH_TOKEN_EXPIRE_MINUTES * 60\n\t    BACKEND_CORS_ORIGINS: list[AnyHttpUrl] = []\n\t    ALLOWED_HOSTS: list[str] = [\"localhost\", \"127.0.0.1\"]\n\t    # PROJECT NAME, VERSION AND DESCRIPTION\n\t    PROJECT_NAME: str = PYPROJECT_CONTENT[\"name\"]\n\t    VERSION: str = PYPROJECT_CONTENT[\"version\"]\n\t    DESCRIPTION: str = PYPROJECT_CONTENT[\"description\"]\n", "    # POSTGRESQL DEFAULT DATABASE\n\t    DB_HOST: str\n\t    DB_USER: str\n\t    DB_PASSWORD: str\n\t    DB_PORT: str\n\t    DB_NAME: str\n\t    DATABASE_URI: str = \"\"\n\t    TEST_DATABASE_URI: str = \"\"\n\t    # See https://docs.pydantic.dev/usage/validators/\n\t    @validator(\"DATABASE_URI\")\n", "    def _assemble_default_db_connection(cls, v: str, values: dict[str, str]) -> str:\n\t        return PostgresDsn.build(\n\t            scheme=\"postgresql+asyncpg\",\n\t            user=values[\"DB_USER\"],\n\t            password=values[\"DB_PASSWORD\"],\n\t            host=values[\"DB_HOST\"],\n\t            port=values[\"DB_PORT\"],\n\t            path=f\"/{values['DB_NAME']}\",\n\t        )\n\t    # See https://docs.pydantic.dev/usage/validators/\n", "    @validator(\"TEST_DATABASE_URI\")\n\t    def _assemble_test_db_connection(cls, v: str, values: dict[str, str]) -> str:\n\t        return PostgresDsn.build(\n\t            scheme=\"postgresql+asyncpg\",\n\t            user=values[\"DB_USER\"],\n\t            password=values[\"DB_PASSWORD\"],\n\t            host=values[\"DB_HOST\"],\n\t            port=values[\"DB_PORT\"],\n\t            path=f\"/{values['DB_NAME']}-test\",\n\t        )\n", "    class Config:\n\t        env_file = f\"{PROJECT_DIR}/.env\"\n\t        case_sensitive = True\n\tsettings: Settings = Settings()  # type: ignore\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/db.py", "chunked_list": ["\"\"\"\n\tSQLAlchemy async engine and sessions tools\n\thttps://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html\n\t\"\"\"\n\tfrom pydantic import PostgresDsn\n\tfrom sqlalchemy.ext.asyncio import AsyncEngine, async_sessionmaker, create_async_engine\n\tfrom sqlalchemy.pool import Pool as SQLAlchemyPool\n\tfrom src.core import config\n\tclass AsyncDatabase:\n\t    def __init__(self):\n", "        self.async_engine: AsyncEngine = create_async_engine(\n\t            url=self.set_async_db_uri,\n\t            pool_pre_ping=True,\n\t        )\n\t        self.async_session = async_sessionmaker(\n\t            self.async_engine, expire_on_commit=False\n\t        )\n\t        self.pool: SQLAlchemyPool = self.async_engine.pool\n\t    @property\n\t    def set_async_db_uri(self) -> str | PostgresDsn:\n", "        \"\"\"\n\t        Set the database uri for the async engine, depending on the environment\n\t        \"\"\"\n\t        if config.settings.ENVIRONMENT == \"PYTEST\":\n\t            database_uri = config.settings.TEST_DATABASE_URI\n\t        else:\n\t            database_uri = config.settings.DATABASE_URI\n\t        return database_uri\n\tasync_db: AsyncDatabase = AsyncDatabase()\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/__init__.py", "chunked_list": []}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/security/password.py", "chunked_list": ["\"\"\"Password generation and verification tools.\"\"\"\n\tfrom passlib.context import CryptContext\n\tfrom src.core.config import settings\n\tclass PasswordGenerator:\n\t    def __init__(self) -> None:\n\t        self.pwd_context = CryptContext(\n\t            schemes=[\"bcrypt\"],\n\t            deprecated=\"auto\",\n\t            bcrypt__rounds=settings.SECURITY_BCRYPT_ROUNDS,\n\t        )\n", "    def verify_password(self, plain_password: str, password: str) -> bool:\n\t        \"\"\"Verifies plain and hashed password matches\n\t        Applies passlib context based on bcrypt algorithm on plain password.\n\t        \"\"\"\n\t        return self.pwd_context.verify(plain_password, password)\n\t    def get_password_hash(self, password: str) -> str:\n\t        \"\"\"Creates hash from password\n\t        Applies passlib context based on bcrypt algorithm on plain password.\n\t        \"\"\"\n\t        return self.pwd_context.hash(password)\n", "password_generator: PasswordGenerator = PasswordGenerator()\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/security/jwt.py", "chunked_list": ["\"\"\"JWT generator used for authentication.\"\"\"\n\timport time\n\tfrom typing import Tuple\n\timport jwt\n\tfrom src.core.config import settings\n\tfrom src.schemas import AccessTokenResponse\n\tclass JWTGenerator:\n\t    def __init__(self) -> None:\n\t        self.jwt_algorithm = \"HS256\"\n\t    def _generate_jwt_token(\n", "        self, subject: str | int, exp_secs: int, refresh: bool\n\t    ) -> Tuple[str, int, int]:\n\t        \"\"\"Creates jwt access or refresh token for user.\n\t        Args:\n\t            subject: anything unique to user, id or email etc.\n\t            exp_secs: expire time in seconds\n\t            refresh: if True, this is refresh token\n\t        \"\"\"\n\t        issued_at = int(time.time())\n\t        expires_at = issued_at + exp_secs\n", "        to_encode: dict[str, int | str | bool] = {\n\t            \"issued_at\": issued_at,\n\t            \"expires_at\": expires_at,\n\t            \"sub\": subject,\n\t            \"refresh\": refresh,\n\t        }\n\t        encoded_jwt = jwt.encode(\n\t            to_encode,\n\t            key=settings.SECRET_KEY,\n\t            algorithm=self.jwt_algorithm,\n", "        )\n\t        return encoded_jwt, expires_at, issued_at\n\t    def generate_access_token(self, subject: str | int) -> AccessTokenResponse:\n\t        \"\"\"Generate tokens and return AccessTokenResponse\n\t        Args:\n\t            subject: anything unique to user, id or email etc.\n\t        \"\"\"\n\t        access_token, expires_at, issued_at = self._generate_jwt_token(\n\t            subject, settings.ACCESS_TOKEN_EXPIRE, refresh=False\n\t        )\n", "        refresh_token, refresh_expires_at, refresh_issued_at = self._generate_jwt_token(\n\t            subject, settings.REFRESH_TOKEN_EXPIRE, refresh=True\n\t        )\n\t        return AccessTokenResponse(\n\t            token_type=\"Bearer\",\n\t            access_token=access_token,\n\t            expires_at=expires_at,\n\t            issued_at=issued_at,\n\t            refresh_token=refresh_token,\n\t            refresh_token_expires_at=refresh_expires_at,\n", "            refresh_token_issued_at=refresh_issued_at,\n\t        )\n\tjwt_generator: JWTGenerator = JWTGenerator()\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/core/security/__init__.py", "chunked_list": []}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/dependencies.py", "chunked_list": ["\"\"\"Dependency functions for the API.\"\"\"\n\timport time\n\tfrom collections.abc import AsyncGenerator\n\tfrom typing import Callable, Type\n\timport jwt\n\tfrom fastapi import Depends, HTTPException, status\n\tfrom fastapi.security import OAuth2PasswordBearer\n\tfrom sqlalchemy.ext.asyncio import AsyncSession\n\tfrom src.controllers import BaseController, UserController\n\tfrom src.core import config\n", "from src.core.db import async_db\n\tfrom src.core.security.jwt import jwt_generator\n\tfrom src.models import User\n\tfrom src.schemas import JWTTokenPayload\n\treusable_oauth2 = OAuth2PasswordBearer(tokenUrl=\"auth/access-token\")\n\tasync def get_session() -> AsyncGenerator[AsyncSession, None]:\n\t    async with async_db.async_session() as session:\n\t        yield session\n\tdef get_controller(\n\t    controller_class: Type[BaseController],\n", ") -> Callable[[AsyncSession], BaseController]:\n\t    def _get_controller(session: AsyncSession = Depends(get_session)) -> BaseController:\n\t        return controller_class(session)\n\t    return _get_controller\n\tasync def get_current_user(\n\t    token: str = Depends(reusable_oauth2),\n\t    controller: UserController = Depends(get_controller(UserController)),\n\t) -> User:\n\t    \"\"\"Get current user based on the information in the access token\n\t    This function is used as a dependency for all routes that require authentication.\n", "    \"\"\"\n\t    try:\n\t        payload = jwt.decode(\n\t            token, config.settings.SECRET_KEY, algorithms=[jwt_generator.jwt_algorithm]\n\t        )\n\t    except jwt.DecodeError:\n\t        raise HTTPException(\n\t            status_code=status.HTTP_403_FORBIDDEN,\n\t            detail=\"Could not validate credentials.\",\n\t        )\n", "    # JWT guarantees payload will be unchanged (and thus valid), no errors here\n\t    token_data = JWTTokenPayload(**payload)\n\t    if token_data.refresh:\n\t        raise HTTPException(\n\t            status_code=status.HTTP_403_FORBIDDEN,\n\t            detail=\"Could not validate credentials, cannot use refresh token\",\n\t        )\n\t    now = int(time.time())\n\t    if now < token_data.issued_at or now > token_data.expires_at:\n\t        raise HTTPException(\n", "            status_code=status.HTTP_403_FORBIDDEN,\n\t            detail=\"Could not validate credentials, token expired or not yet valid\",\n\t        )\n\t    user = await controller.get_user_by_attribute(attribute=\"id\", value=token_data.sub)\n\t    return user\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/router.py", "chunked_list": ["from fastapi import APIRouter\n\tfrom src.api.routes import auth, users\n\trouter = APIRouter()\n\trouter.include_router(auth.router, prefix=\"/auth\", tags=[\"auth\"])\n\trouter.include_router(users.router, prefix=\"/users\", tags=[\"users\"])\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/__init__.py", "chunked_list": []}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/routes/auth.py", "chunked_list": ["import time\n\timport jwt\n\tfrom fastapi import APIRouter, Depends, HTTPException, status\n\tfrom fastapi.security import OAuth2PasswordRequestForm\n\tfrom pydantic import ValidationError\n\tfrom src.api.dependencies import get_controller\n\tfrom src.controllers import UserController\n\tfrom src.core import config\n\tfrom src.core.security.jwt import jwt_generator\n\tfrom src.core.security.password import password_generator\n", "from src.schemas import AccessTokenResponse, JWTTokenPayload, RefreshTokenRequest\n\trouter = APIRouter()\n\t@router.post(\"/access-token\", response_model=AccessTokenResponse)\n\tasync def login_access_token(\n\t    controller: UserController = Depends(get_controller(UserController)),\n\t    form_data: OAuth2PasswordRequestForm = Depends(),\n\t):\n\t    \"\"\"OAuth2 compatible token, get an access token for future requests using username and password\"\"\"\n\t    user = await controller.get_user_by_attribute(\n\t        attribute=\"email\", value=form_data.username\n", "    )\n\t    if not password_generator.verify_password(form_data.password, user.password):\n\t        raise HTTPException(status_code=400, detail=\"Incorrect password\")\n\t    return jwt_generator.generate_access_token(str(user.id))\n\t@router.post(\"/refresh-token\", response_model=AccessTokenResponse)\n\tasync def refresh_token(\n\t    input: RefreshTokenRequest,\n\t    controller: UserController = Depends(get_controller(UserController)),\n\t):\n\t    \"\"\"OAuth2 compatible token, get an access token for future requests using refresh token\"\"\"\n", "    try:\n\t        payload = jwt.decode(\n\t            input.refresh_token,\n\t            config.settings.SECRET_KEY,\n\t            algorithms=[jwt_generator.jwt_algorithm],\n\t        )\n\t    except (jwt.DecodeError, ValidationError):\n\t        raise HTTPException(\n\t            status_code=status.HTTP_403_FORBIDDEN,\n\t            detail=\"Could not validate credentials, unknown error\",\n", "        )\n\t    token_data = JWTTokenPayload(**payload)\n\t    if not token_data.refresh:\n\t        raise HTTPException(\n\t            status_code=status.HTTP_403_FORBIDDEN,\n\t            detail=\"Could not validate credentials, cannot use access token\",\n\t        )\n\t    now = int(time.time())\n\t    if now < token_data.issued_at or now > token_data.expires_at:\n\t        raise HTTPException(\n", "            status_code=status.HTTP_403_FORBIDDEN,\n\t            detail=\"Could not validate credentials, token expired or not yet valid\",\n\t        )\n\t    user = await controller.get_user_by_attribute(attribute=\"id\", value=token_data.sub)\n\t    return jwt_generator.generate_access_token(str(user.id))\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/routes/users.py", "chunked_list": ["from fastapi import APIRouter, Depends\n\tfrom src.api import dependencies\n\tfrom src.controllers import UserController\n\tfrom src.models import User\n\tfrom src.schemas import UserCreateRequest, UserResponse, UserUpdateRequest\n\trouter = APIRouter()\n\t@router.get(\"/me\", response_model=UserResponse)\n\tasync def read_current_user(\n\t    current_user: User = Depends(dependencies.get_current_user),\n\t):\n", "    \"\"\"Get current user\"\"\"\n\t    return current_user\n\t@router.delete(\"/me\", status_code=204)\n\tasync def delete_current_user(\n\t    current_user: User = Depends(dependencies.get_current_user),\n\t    controller: UserController = Depends(dependencies.get_controller(UserController)),\n\t):\n\t    \"\"\"Delete current user\"\"\"\n\t    await controller.delete_user_by_id(id=current_user.id)\n\t@router.get(\"/\", response_model=list[UserResponse])\n", "async def get_users(\n\t    controller: UserController = Depends(dependencies.get_controller(UserController)),\n\t):\n\t    \"\"\"Get all users\"\"\"\n\t    users = await controller.get_users()\n\t    return list(users)\n\t@router.get(\"/{id}\", response_model=UserResponse)\n\tasync def get_user(\n\t    id: str,\n\t    controller: UserController = Depends(dependencies.get_controller(UserController)),\n", "):\n\t    \"\"\"Get a user by id\"\"\"\n\t    user = await controller.get_user_by_attribute(attribute=\"id\", value=id)\n\t    return user\n\t@router.post(\"/register\", status_code=201, response_model=UserResponse)\n\tasync def register_new_user(\n\t    new_user: UserCreateRequest,\n\t    controller: UserController = Depends(dependencies.get_controller(UserController)),\n\t):\n\t    \"\"\"Create new user\"\"\"\n", "    user = await controller.create_user(new_user=new_user)\n\t    return user\n\t@router.delete(\"/{id}\", status_code=204)\n\tasync def delete_user(\n\t    id: str,\n\t    controller: UserController = Depends(dependencies.get_controller(UserController)),\n\t    current_user: User = Depends(dependencies.get_current_user),\n\t):\n\t    \"\"\"Delete a user by id\"\"\"\n\t    await controller.delete_user_by_id(id=id)\n", "@router.patch(\"/{id}\", response_model=UserResponse)\n\tasync def update_user(\n\t    id: str,\n\t    update_user: UserUpdateRequest,\n\t    controller: UserController = Depends(dependencies.get_controller(UserController)),\n\t    current_user: User = Depends(dependencies.get_current_user),\n\t):\n\t    \"\"\"Update user data\"\"\"\n\t    user = await controller.update_user_by_id(id=id, user_update=update_user)\n\t    return user\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/api/routes/__init__.py", "chunked_list": []}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/controllers/base.py", "chunked_list": ["from sqlalchemy.ext.asyncio import AsyncSession\n\tclass BaseController:\n\t    def __init__(self, session: AsyncSession):\n\t        self.session = session\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/controllers/users.py", "chunked_list": ["from typing import Sequence\n\tfrom fastapi import HTTPException\n\tfrom sqlalchemy import delete, select, update\n\tfrom src.controllers.base import BaseController\n\tfrom src.core.security.password import password_generator\n\tfrom src.models import User\n\tfrom src.schemas import UserCreateRequest, UserUpdateRequest\n\tclass UserController(BaseController):\n\t    async def get_users(self) -> Sequence[User]:\n\t        \"\"\"Get all users in the database\"\"\"\n", "        result = await self.session.execute(select(User))\n\t        return result.scalars().all()\n\t    async def get_user_by_attribute(self, attribute: str, value: str) -> User:\n\t        \"\"\"Returns a user in the database by the given attribute\"\"\"\n\t        attribute_obj = getattr(User, attribute)\n\t        result = await self.session.execute(select(User).where(attribute_obj == value))\n\t        user = result.scalar()\n\t        if not user:\n\t            raise HTTPException(status_code=404, detail=\"User not found.\")\n\t        return user\n", "    async def create_user(self, new_user: UserCreateRequest) -> User:\n\t        \"\"\"Create a new user in the database\"\"\"\n\t        result = await self.session.execute(\n\t            select(User).where(User.email == new_user.email)\n\t        )\n\t        if result.scalar() is not None:\n\t            raise HTTPException(status_code=400, detail=\"Cannot use this email address\")\n\t        user = User(\n\t            email=new_user.email,\n\t            password=password_generator.get_password_hash(new_user.password),\n", "        )\n\t        self.session.add(user)\n\t        await self.session.commit()\n\t        await self.session.refresh(user)\n\t        return user\n\t    async def update_user_by_id(self, id: str, user_update: UserUpdateRequest) -> User:\n\t        \"\"\"Update a user information in the database by id\"\"\"\n\t        new_user_data = user_update.dict(exclude_unset=True)\n\t        user = await self.get_user_by_attribute(attribute=\"id\", value=id)\n\t        await self.session.execute(\n", "            update(User).where(User.id == id).values(**new_user_data)\n\t        )\n\t        await self.session.commit()\n\t        await self.session.refresh(user)\n\t        return user\n\t    async def delete_user_by_id(self, id: str) -> None:\n\t        \"\"\"Delete a user in the database by id\"\"\"\n\t        await self.get_user_by_attribute(attribute=\"id\", value=id)\n\t        await self.session.execute(delete(User).where(User.id == id))\n\t        await self.session.commit()\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/controllers/__init__.py", "chunked_list": ["from .base import BaseController\n\tfrom .users import UserController\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/migrations/env.py", "chunked_list": ["import asyncio\n\tfrom logging.config import fileConfig\n\tfrom alembic import context\n\tfrom sqlalchemy import engine_from_config, pool\n\tfrom sqlalchemy.ext.asyncio import AsyncEngine\n\tfrom src.core import config as app_config\n\t# this is the Alembic Config object, which provides\n\t# access to the values within the .ini file in use.\n\tconfig = context.config\n\t# Interpret the config file for Python logging.\n", "# This line sets up loggers basically.\n\tfileConfig(config.config_file_name)  # type: ignore\n\t# add your model's MetaData object here\n\t# for 'autogenerate' support\n\t# from myapp import mymodel\n\t# target_metadata = mymodel.Base.metadata\n\tfrom src.models import Base  # noqa\n\ttarget_metadata = Base.metadata\n\t# other values from the config, defined by the needs of env.py,\n\t# can be acquired:\n", "# my_important_option = config.get_main_option(\"my_important_option\")\n\t# ... etc.\n\tdef get_database_uri():\n\t    return app_config.settings.DATABASE_URI\n\tdef run_migrations_offline():\n\t    \"\"\"Run migrations in 'offline' mode.\n\t    This configures the context with just a URL\n\t    and not an Engine, though an Engine is acceptable\n\t    here as well.  By skipping the Engine creation\n\t    we don't even need a DBAPI to be available.\n", "    Calls to context.execute() here emit the given string to the\n\t    script output.\n\t    \"\"\"\n\t    url = get_database_uri()\n\t    context.configure(\n\t        url=url,\n\t        target_metadata=target_metadata,\n\t        literal_binds=True,\n\t        dialect_opts={\"paramstyle\": \"named\"},\n\t        compare_type=True,\n", "        compare_server_default=True,\n\t    )\n\t    with context.begin_transaction():\n\t        context.run_migrations()\n\tdef do_run_migrations(connection):\n\t    context.configure(\n\t        connection=connection, target_metadata=target_metadata, compare_type=True\n\t    )\n\t    with context.begin_transaction():\n\t        context.run_migrations()\n", "async def run_migrations_online():\n\t    \"\"\"Run migrations in 'online' mode.\n\t    In this scenario we need to create an Engine\n\t    and associate a connection with the context.\n\t    \"\"\"\n\t    configuration = config.get_section(config.config_ini_section)\n\t    assert configuration\n\t    configuration[\"sqlalchemy.url\"] = get_database_uri()\n\t    connectable = AsyncEngine(\n\t        engine_from_config(\n", "            configuration,\n\t            prefix=\"sqlalchemy.\",\n\t            poolclass=pool.NullPool,\n\t            future=True,\n\t        )  # type: ignore\n\t    )\n\t    async with connectable.connect() as connection:\n\t        await connection.run_sync(do_run_migrations)\n\tif context.is_offline_mode():\n\t    run_migrations_offline()\n", "else:\n\t    asyncio.run(run_migrations_online())\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/migrations/versions/2023040500_rename_password_0a4b3a6eb149.py", "chunked_list": ["\"\"\"rename_password\n\tRevision ID: 0a4b3a6eb149\n\tRevises: 07c71f4389b6\n\tCreate Date: 2023-04-05 17:00:46.766553\n\t\"\"\"\n\timport sqlalchemy as sa\n\tfrom alembic import op\n\t# revision identifiers, used by Alembic.\n\trevision = \"0a4b3a6eb149\"\n\tdown_revision = \"07c71f4389b6\"\n", "branch_labels = None\n\tdepends_on = None\n\tdef upgrade():\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.create_table(\n\t        \"dog_model\",\n\t        sa.Column(\"id\", sa.UUID(as_uuid=False), nullable=False),\n\t        sa.Column(\"name\", sa.String(length=128), nullable=False),\n\t        sa.PrimaryKeyConstraint(\"id\"),\n\t    )\n", "    op.alter_column(\n\t        \"user_model\",\n\t        \"email\",\n\t        existing_type=sa.VARCHAR(length=254),\n\t        type_=sa.String(length=128),\n\t        existing_nullable=False,\n\t    )\n\t    op.drop_index(\"ix_user_model_email\", table_name=\"user_model\")\n\t    op.create_unique_constraint(None, \"user_model\", [\"email\"])\n\t    # ### end Alembic commands ###\n", "def downgrade():\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.drop_constraint(None, \"user_model\", type_=\"unique\")\n\t    op.create_index(\"ix_user_model_email\", \"user_model\", [\"email\"], unique=False)\n\t    op.alter_column(\n\t        \"user_model\",\n\t        \"email\",\n\t        existing_type=sa.String(length=128),\n\t        type_=sa.VARCHAR(length=254),\n\t        existing_nullable=False,\n", "    )\n\t    op.drop_table(\"dog_model\")\n\t    # ### end Alembic commands ###\n"]}
{"filename": "{{cookiecutter.project_name|lower|replace('-', '_')|replace(' ', '_')}}/src/migrations/versions/2023020440_init_user_model_07c71f4389b6.py", "chunked_list": ["\"\"\"init_user_model\n\tRevision ID: 07c71f4389b6\n\tRevises:\n\tCreate Date: 2023-02-04 23:40:00.426237\n\t\"\"\"\n\timport sqlalchemy as sa\n\tfrom alembic import op\n\t# revision identifiers, used by Alembic.\n\trevision = \"07c71f4389b6\"\n\tdown_revision = None\n", "branch_labels = None\n\tdepends_on = None\n\tdef upgrade():\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.create_table(\n\t        \"user_model\",\n\t        sa.Column(\"id\", sa.UUID(), nullable=False),\n\t        sa.Column(\"email\", sa.String(length=254), nullable=False),\n\t        sa.Column(\"password\", sa.String(length=128), nullable=False),\n\t        sa.PrimaryKeyConstraint(\"id\"),\n", "    )\n\t    op.create_index(op.f(\"ix_user_model_email\"), \"user_model\", [\"email\"], unique=True)\n\t    # ### end Alembic commands ###\n\tdef downgrade():\n\t    # ### commands auto generated by Alembic - please adjust! ###\n\t    op.drop_index(op.f(\"ix_user_model_email\"), table_name=\"user_model\")\n\t    op.drop_table(\"user_model\")\n\t    # ### end Alembic commands ###\n"]}
