{"filename": "backend/ingestion/tests/__init__.py", "chunked_list": []}
{"filename": "backend/ingestion/tests/test_file_system_tree.py", "chunked_list": ["import os\n\timport unittest\n\timport platform\n\timport networkx as nx\n\tfrom hashlib import sha256\n\tfrom unittest.mock import MagicMock, patch\n\tfrom server.server.system.fstree import FileSystemTree\n\tclass TestFileSystemTree(unittest.TestCase):\n\t    def setUp(self) -> None:\n\t        self.test_uri = \"neo4j://localhost:7687\"\n", "        self.test_user = \"neo4j\"\n\t        self.test_password = \"password\"\n\t    def test_init(self) -> None:\n\t        with patch(\"neo4j.GraphDatabase.driver\") as mock_driver:\n\t            fst = FileSystemTree(self.test_uri, self.test_user, self.test_password)\n\t            mock_driver.assert_called_once_with(\n\t                self.test_uri, auth=(self.test_user, self.test_password)\n\t            )\n\t    def test_ready(self) -> None:\n\t        with patch(\"builtins.print\") as mock_print:\n", "            with FileSystemTree(\n\t                self.test_uri, self.test_user, self.test_password\n\t            ) as fst:\n\t                fst.ready()\n\t                mock_print.assert_called_once_with(\"started neo4j\")\n\t    def test_close(self) -> None:\n\t        with patch(\"neo4j.GraphDatabase.driver\") as mock_driver:\n\t            with FileSystemTree(\n\t                self.test_uri, self.test_user, self.test_password\n\t            ) as fst:\n", "                fst.close()\n\t                fst.driver.close.assert_called_once()\n\t    def test_print_greeting(self) -> None:\n\t        test_message = \"Hello, World!\"\n\t        with patch(\"neo4j.GraphDatabase.driver\") as mock_driver:\n\t            session = MagicMock()\n\t            mock_driver.return_value.session.return_value.__enter__.return_value = (\n\t                session\n\t            )\n\t            fst = FileSystemTree(self.test_uri, self.test_user, self.test_password)\n", "            with patch(\"builtins.print\") as mock_print:\n\t                fst.print_greeting(test_message)\n\t                session.execute_write.assert_called_once()\n\t                mock_print.assert_called_once()\n\t    def test_get_system_info(self) -> None:\n\t        # get system info using the function\n\t        with FileSystemTree(\n\t                self.test_uri, self.test_user, self.test_password\n\t            ) as fst:\n\t            system_info = fst.get_system_info()\n", "            # verify that the output is correct\n\t            assert isinstance(system_info, dict)\n\t            assert \"platform\" in system_info and system_info[\"platform\"] == platform.system()\n\t            assert \"platform-release\" in system_info and system_info[\"platform-release\"] == platform.release()\n\t            assert \"platform-version\" in system_info and system_info[\"platform-version\"] == platform.version()\n\t            assert \"architecture\" in system_info and system_info[\"architecture\"] == platform.machine()\n\t            assert \"hostname\" in system_info and system_info[\"hostname\"] == platform.node()\n\t            assert \"processor\" in system_info and system_info[\"processor\"] == platform.processor()\n\t            assert \"ram\" in system_info and isinstance(system_info[\"ram\"], str) and \"GB\" in system_info[\"ram\"]\n\t            assert \"uptime\" in system_info and isinstance(system_info[\"uptime\"], int) and system_info[\"uptime\"] > 0\n", "    def test_map_file_system(self) -> None:\n\t        def cleanup(test_dir: str) -> None:\n\t            # clean up the temporary directory\n\t            os.remove(os.path.join(test_dir, \"file1.txt\"))\n\t            os.remove(os.path.join(test_dir, \"subdir\", \"file2.txt\"))\n\t            os.rmdir(os.path.join(test_dir, \"subdir\"))\n\t            os.rmdir(test_dir)\n\t        # create a temporary directory with some files and directories\n\t        base_dir = os.path.dirname(os.path.abspath(__file__))\n\t        test_dir = os.path.join(base_dir, \"test_dir\")\n", "        cleanup(test_dir)\n\t        os.makedirs(test_dir)\n\t        os.makedirs(os.path.join(test_dir, \"subdir\"))\n\t        with open(os.path.join(test_dir, \"file1.txt\"), \"w\") as f:\n\t            f.write(\"Hello, world!\")\n\t        with open(os.path.join(test_dir, \"subdir\", \"file2.txt\"), \"w\") as f:\n\t            f.write(\"Goodbye, world!\")\n\t        # run the map_file_system function\n\t        with FileSystemTree(\n\t                self.test_uri, self.test_user, self.test_password\n", "            ) as fst:\n\t            file_tree = fst.map_file_system(test_dir)\n\t            print(nx.to_dict_of_dicts(file_tree))\n\t            # verify that the output is correct\n\t            assert isinstance(file_tree, nx.DiGraph)\n\t            assert file_tree.has_node(test_dir)\n\t            print(f'file1: {os.path.join(test_dir, \"file1.txt\")}')\n\t            print(f'tree: {nx.to_dict_of_dicts(file_tree)}')\n\t            assert file_tree.has_node(os.path.join(test_dir, \"file1.txt\"))\n\t            assert file_tree.has_node(os.path.join(test_dir, \"subdir\"))\n", "            assert file_tree.has_node(os.path.join(test_dir, \"subdir\", \"file2.txt\"))\n\t            assert file_tree.nodes[test_dir][\"type\"] == \"directory\"\n\t            assert file_tree.nodes[os.path.join(test_dir, \"file1.txt\")][\"type\"] == \"file\"\n\t            assert file_tree.nodes[os.path.join(test_dir, \"subdir\")][\"type\"] == \"directory\"\n\t            assert file_tree.nodes[os.path.join(test_dir, \"subdir\", \"file2.txt\")][\"type\"] == \"file\"\n\t            assert file_tree.successors(test_dir) == [os.path.join(test_dir, \"file1.txt\"), os.path.join(test_dir, \"subdir\")]\n\t            assert file_tree.successors(os.path.join(test_dir, \"subdir\")) == [os.path.join(test_dir, \"subdir\", \"file2.txt\")]\n\t    def test__calculate_merkle_tree(self) -> None:\n\t        # Create a graph with nodes and attributes\n\t        G = nx.DiGraph()\n", "        G.add_node(\"a\", type=\"directory\")\n\t        G.add_node(\"b\", type=\"file\", name=\"file1.txt\")\n\t        G.add_node(\"c\", type=\"file\", name=\"file2.txt\")\n\t        G.add_edge(\"a\", \"b\")\n\t        G.add_edge(\"a\", \"c\")\n\t        with FileSystemTree(\n\t                self.test_uri, self.test_user, self.test_password\n\t            ) as fst:\n\t            # Calculate the Merkle tree\n\t            merkle_tree = fst._calculate_merkle_tree(G)\n", "            # Verify the expected hash values for each node\n\t            expected_hashes = {\n\t                \"a\": sha256(repr({\"type\": \"directory\"}).encode()).hexdigest(),\n\t                \"b\": sha256(repr({\"type\": \"file\", \"name\": \"file1.txt\"}).encode()).hexdigest(),\n\t                \"c\": sha256(repr({\"type\": \"file\", \"name\": \"file2.txt\"}).encode()).hexdigest(),\n\t            }\n\t            assert merkle_tree == expected_hashes\n\t    def test__find_differences(self) -> None:\n\t        # Create two Merkle trees\n\t        original_tree = {\"a\": \"hash1\", \"b\": \"hash2\", \"c\": \"hash3\"}\n", "        new_tree = {\"a\": \"hash1\", \"b\": \"newhash\", \"d\": \"hash4\"}\n\t        with FileSystemTree(\n\t                self.test_uri, self.test_user, self.test_password\n\t            ) as fst:\n\t            # Find the differences between the two trees\n\t            differences = fst._find_differences(original_tree, new_tree)\n\t            # Verify the expected differences\n\t            expected_differences = {\"b\": \"newhash\", \"c\": None, \"d\": \"hash4\"}\n\t            assert differences == expected_differences\n\t    def test_update_graph_with_merkle_tree(self) -> None:\n", "        # Create a graph with nodes and edges\n\t        G = nx.DiGraph()\n\t        G.add_node(\"a\", type=\"directory\")\n\t        G.add_node(\"b\", type=\"file\", name=\"file1.txt\")\n\t        G.add_node(\"c\", type=\"file\", name=\"file2.txt\")\n\t        G.add_edge(\"a\", \"b\")\n\t        G.add_edge(\"a\", \"c\")\n\t        # Write the graph to a file\n\t        graphml_file = \"test_graph.graphml\"\n\t        nx.write_graphml(G, graphml_file)\n", "        # Create a new file tree with some modifications\n\t        new_tree = nx.DiGraph()\n\t        new_tree.add_node(\"a\", type=\"directory\")\n\t        new_tree.add_node(\"b\", type=\"file\", name=\"file1.txt\", size=\"100KB\")\n\t        new_tree.add_edge(\"a\", \"b\")\n\t        new_tree.add_node(\"d\", type=\"file\", name=\"file3.txt\")\n\t        new_tree.add_edge(\"a\", \"d\")\n\t        with FileSystemTree(\n\t                self.test_uri, self.test_user, self.test_password\n\t            ) as fst:\n", "            # Update the original graph with the differences\n\t            updated_graph = fst.update_graph_with_merkle_tree(new_tree, graphml_file)\n\t            # Verify that the graph has been updated correctly\n\t            assert updated_graph.has_node(\"a\")\n\t            assert updated_graph.has_node(\"b\")\n\t            assert updated_graph.has_node(\"d\")\n\t            assert not updated_graph.has_node(\"c\")\n\t            assert updated_graph.has_edge(\"a\", \"b\")\n\t            assert updated_graph.has_edge(\"a\", \"d\")\n\t            # Clean up the test file\n", "            os.remove(graphml_file)\n"]}
{"filename": "backend/ingestion/server/manage.py", "chunked_list": ["#!/usr/bin/env python\n\t\"\"\"Django's command-line utility for administrative tasks.\"\"\"\n\timport os\n\timport sys\n\tdef main():\n\t    \"\"\"Run administrative tasks.\"\"\"\n\t    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"server.settings\")\n\t    try:\n\t        from django.core.management import execute_from_command_line\n\t    except ImportError as exc:\n", "        raise ImportError(\n\t            \"Couldn't import Django. Are you sure it's installed and \"\n\t            \"available on your PYTHONPATH environment variable? Did you \"\n\t            \"forget to activate a virtual environment?\"\n\t        ) from exc\n\t    execute_from_command_line(sys.argv)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "backend/ingestion/server/server/settings.py", "chunked_list": ["\"\"\"\n\tDjango settings for server project.\n\tGenerated by 'django-admin startproject' using Django 4.1.7.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/4.1/topics/settings/\n\tFor the full list of settings and their values, see\n\thttps://docs.djangoproject.com/en/4.1/ref/settings/\n\t\"\"\"\n\timport os\n\tfrom pathlib import Path\n", "from dotenv import load_dotenv\n\tDJANGO_ENV = os.environ.get(\"DJANGO_ENV\", \"dev\")\n\tcurrent_directory_path = os.path.dirname(os.path.abspath(__file__))\n\tif DJANGO_ENV == \"prod\":\n\t    load_dotenv(os.path.join(current_directory_path, \"../env/.env.prod\"))\n\telse:\n\t    load_dotenv(os.path.join(current_directory_path, \"../env/.env.dev\"))\n\t# Build paths inside the project like this: BASE_DIR / 'subdir'.\n\tBASE_DIR = Path(__file__).resolve().parent.parent\n\t# Quick-start development settings - unsuitable for production\n", "# See https://docs.djangoproject.com/en/4.1/howto/deployment/checklist/\n\t# SECURITY WARNING: keep the secret key used in production secret!\n\tSECRET_KEY = os.environ.get(\"SECRET_KEY\")\n\t# SECURITY WARNING: don't run with debug turned on in production!\n\tDEBUG = True\n\tALLOWED_HOSTS = []\n\t# Application definition\n\tINSTALLED_APPS = [\n\t    \"django.contrib.admin\",\n\t    \"django.contrib.auth\",\n", "    \"django.contrib.contenttypes\",\n\t    \"django.contrib.sessions\",\n\t    \"django.contrib.messages\",\n\t    \"django.contrib.staticfiles\",\n\t    \"backend.apis\",\n\t    \"backend.fstree\",\n\t]\n\tMIDDLEWARE = [\n\t    \"django.middleware.security.SecurityMiddleware\",\n\t    \"django.contrib.sessions.middleware.SessionMiddleware\",\n", "    \"django.middleware.common.CommonMiddleware\",\n\t    \"django.middleware.csrf.CsrfViewMiddleware\",\n\t    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n\t    \"django.contrib.messages.middleware.MessageMiddleware\",\n\t    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n\t]\n\tROOT_URLCONF = \"server.urls\"\n\tTEMPLATES = [\n\t    {\n\t        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n", "        \"DIRS\": [],\n\t        \"APP_DIRS\": True,\n\t        \"OPTIONS\": {\n\t            \"context_processors\": [\n\t                \"django.template.context_processors.debug\",\n\t                \"django.template.context_processors.request\",\n\t                \"django.contrib.auth.context_processors.auth\",\n\t                \"django.contrib.messages.context_processors.messages\",\n\t            ],\n\t        },\n", "    },\n\t]\n\tWSGI_APPLICATION = \"server.wsgi.application\"\n\t# Database\n\t# https://docs.djangoproject.com/en/4.1/ref/settings/#databases\n\tDATABASES = {\n\t    \"default\": {\n\t        \"ENGINE\": \"django.db.backends.sqlite3\",\n\t        \"NAME\": BASE_DIR / \"db.sqlite3\",\n\t    }\n", "}\n\t# Password validation\n\t# https://docs.djangoproject.com/en/4.1/ref/settings/#auth-password-validators\n\tAUTH_PASSWORD_VALIDATORS = [\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n\t    },\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n\t    },\n", "    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n\t    },\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n\t    },\n\t]\n\t# Internationalization\n\t# https://docs.djangoproject.com/en/4.1/topics/i18n/\n\tLANGUAGE_CODE = \"en-us\"\n", "TIME_ZONE = \"UTC\"\n\tUSE_I18N = True\n\tUSE_TZ = True\n\t# Static files (CSS, JavaScript, Images)\n\t# https://docs.djangoproject.com/en/4.1/howto/static-files/\n\tSTATIC_URL = \"static/\"\n\t# Default primary key field type\n\t# https://docs.djangoproject.com/en/4.1/ref/settings/#default-auto-field\n\tDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"\n"]}
{"filename": "backend/ingestion/server/server/urls.py", "chunked_list": ["\"\"\"server URL Configuration\n\tThe `urlpatterns` list routes URLs to views. For more information please see:\n\t    https://docs.djangoproject.com/en/4.1/topics/http/urls/\n\tExamples:\n\tFunction views\n\t    1. Add an import:  from my_app import views\n\t    2. Add a URL to urlpatterns:  path('', views.home, name='home')\n\tClass-based views\n\t    1. Add an import:  from other_app.views import Home\n\t    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\n", "Including another URLconf\n\t    1. Import the include() function: from django.urls import include, path\n\t    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\t\"\"\"\n\tfrom api.filesystem import get_urls\n\turlpatterns = []\n\turlpatterns.extend(get_urls())\n"]}
{"filename": "backend/ingestion/server/server/__init__.py", "chunked_list": []}
{"filename": "backend/ingestion/server/server/asgi.py", "chunked_list": ["\"\"\"\n\tASGI config for server project.\n\tIt exposes the ASGI callable as a module-level variable named ``application``.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/4.1/howto/deployment/asgi/\n\t\"\"\"\n\timport os\n\tfrom django.core.asgi import get_asgi_application\n\tos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"server.settings\")\n\tapplication = get_asgi_application()\n"]}
{"filename": "backend/ingestion/server/server/wsgi.py", "chunked_list": ["\"\"\"\n\tWSGI config for server project.\n\tIt exposes the WSGI callable as a module-level variable named ``application``.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/4.1/howto/deployment/wsgi/\n\t\"\"\"\n\timport os\n\tfrom django.core.wsgi import get_wsgi_application\n\tos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"server.settings\")\n\tapplication = get_wsgi_application()\n"]}
{"filename": "backend/ingestion/server/server/system/__init__.py", "chunked_list": []}
{"filename": "backend/ingestion/server/server/system/fstree.py", "chunked_list": ["import os\n\timport time\n\timport hashlib\n\tfrom collections import deque\n\tfrom typing import Dict, List, Union\n\timport psutil\n\timport platform\n\tfrom django.apps import AppConfig\n\tfrom neo4j import GraphDatabase\n\timport networkx as nx\n", "class FileSystemTree(AppConfig):\n\t    def __init__(self, uri, user, password):\n\t        self.uri = uri\n\t        self.user = user\n\t        self.password = password\n\t        self.driver = GraphDatabase.driver(uri, auth=(user, password))\n\t    def __enter__(self):\n\t        return self\n\t    def __exit__(self, exc_type, exc_value, traceback):\n\t        self.close()\n", "    def ready(self):\n\t        file_tree = self.map_file_system(\"/\")\n\t        nx.write_graphml(file_tree, \"file_tree.graphml\")\n\t    def close(self):\n\t        self.driver.close()\n\t    def print_greeting(self, message):\n\t        with self.driver.session() as session:\n\t            greeting = session.execute_write(self._create_and_return_greeting, message)\n\t            print(greeting)\n\t    @staticmethod\n", "    def _create_and_return_greeting(tx, message):\n\t        result = tx.run(\n\t            \"CREATE (a:Greeting) \"\n\t            \"SET a.message = $message \"\n\t            \"RETURN a.message + ', from node ' + id(a)\",\n\t            message=message,\n\t        )\n\t        return result.single()[0]\n\t    def get_system_info(self) -> Dict[str, Union[str, int, float]]:\n\t        system_info = {\n", "            \"platform\": platform.system(),\n\t            \"platform-release\": platform.release(),\n\t            \"platform-version\": platform.version(),\n\t            \"architecture\": platform.machine(),\n\t            \"hostname\": platform.node(),\n\t            \"processor\": platform.processor(),\n\t            \"ram\": str(round(psutil.virtual_memory().total / (1024 * 1024 * 1024), 2))\n\t            + \" GB\",\n\t            \"uptime\": int(time.time() - psutil.boot_time()),\n\t        }\n", "        return system_info\n\t    def map_file_system(self, path: str = \"/\") -> nx.DiGraph:\n\t        file_tree = nx.DiGraph()\n\t        file_tree.add_node(path, type=\"directory\")\n\t        queue = deque()\n\t        queue.append(path)\n\t        while queue:\n\t            current_path = queue.popleft()\n\t            if \"/dev\" in current_path or \"/proc\" in current_path:\n\t                continue\n", "            try:\n\t                with os.scandir(current_path) as entries:\n\t                    for entry in entries:\n\t                        if entry.is_file():\n\t                            file_tree.add_node(\n\t                                os.path.join(current_path, entry.name),\n\t                                type=\"file\",\n\t                                name=entry.name,\n\t                            )\n\t                            file_tree.add_edge(\n", "                                current_path, os.path.join(current_path, entry.name)\n\t                            )\n\t                        elif entry.is_dir():\n\t                            subdir = os.path.join(current_path, entry.name)\n\t                            file_tree.add_node(\n\t                                subdir, type=\"directory\", name=entry.name\n\t                            )\n\t                            file_tree.add_edge(current_path, subdir)\n\t                            queue.append(subdir)\n\t            except (PermissionError, FileNotFoundError):\n", "                pass\n\t        return file_tree\n\t    def update_graph_with_merkle_tree(\n\t        self, file_tree: nx.DiGraph, graphml_file: str\n\t    ) -> nx.DiGraph:\n\t        # load the graph from the graphml file\n\t        G = nx.read_graphml(graphml_file)\n\t        # calculate the Merkle Trees for the original and new file trees\n\t        original_merkle_tree = self._calculate_merkle_tree(G)\n\t        new_merkle_tree = self._calculate_merkle_tree(file_tree)\n", "        # find the differences between the two trees\n\t        differences = self._find_differences(original_merkle_tree, new_merkle_tree)\n\t        # apply the differences to the original graph\n\t        for node, attributes in differences.items():\n\t            if attributes is None:\n\t                G.remove_node(node)\n\t            else:\n\t                G.add_node(node, **attributes)\n\t        return G\n\t    def _calculate_merkle_tree(self, file_tree: nx.DiGraph) -> dict:\n", "        merkle_tree = {}\n\t        for node in sorted(file_tree.nodes):\n\t            hash_value = hashlib.sha256(\n\t                repr(file_tree.nodes[node]).encode()\n\t            ).hexdigest()\n\t            merkle_tree[node] = hash_value\n\t        return merkle_tree\n\t    def _find_differences(self, original_tree: dict, new_tree: dict) -> dict:\n\t        differences = {}\n\t        # find nodes in new_tree that are not in original_tree\n", "        for node, hash_value in new_tree.items():\n\t            if node not in original_tree:\n\t                differences[node] = new_tree[node]\n\t            elif original_tree[node] != hash_value:\n\t                differences[node] = new_tree[node]\n\t        # find nodes in original_tree that are not in new_tree\n\t        for node, hash_value in original_tree.items():\n\t            if node not in new_tree:\n\t                differences[node] = None\n\t        return differences\n"]}
{"filename": "backend/ingestion/server/server/api/__init__.py", "chunked_list": []}
{"filename": "backend/ingestion/server/server/api/filesystem.py", "chunked_list": ["import os\n\timport time\n\tfrom collections import deque\n\tfrom typing import Dict, List, Union\n\tfrom dotenv import load_dotenv\n\timport psutil\n\timport platform\n\tfrom django.contrib import admin\n\tfrom django.urls import path\n\tfrom django.http import HttpRequest, HttpResponse, HttpResponseBadRequest, JsonResponse\n", "\"\"\"\n\tPOST configurations to:\n\t1. Update connected APIs\n\t2. Modify refresh interval\n\t\"\"\"\n\tdef configure(req: HttpRequest) -> HttpResponse:\n\t    if req.method == \"POST\":\n\t        configuration = req.POST.get(\"config\")\n\tdef get_urls():\n\t    return [\n", "        path(\"admin/\", admin.site.urls),\n\t        path(\"api/v1/configure\", configure, name=\"configure\"),\n\t    ]\n"]}
{"filename": "backend/speech/manage.py", "chunked_list": ["#!/usr/bin/env python\n\t\"\"\"Django's command-line utility for administrative tasks.\"\"\"\n\timport os\n\timport sys\n\tdef main():\n\t    \"\"\"Run administrative tasks.\"\"\"\n\t    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"backend.settings\")\n\t    try:\n\t        from django.core.management import execute_from_command_line\n\t    except ImportError as exc:\n", "        raise ImportError(\n\t            \"Couldn't import Django. Are you sure it's installed and \"\n\t            \"available on your PYTHONPATH environment variable? Did you \"\n\t            \"forget to activate a virtual environment?\"\n\t        ) from exc\n\t    execute_from_command_line(sys.argv)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "backend/speech/backend/settings.py", "chunked_list": ["\"\"\"\n\tDjango settings for backend project.\n\tGenerated by 'django-admin startproject' using Django 4.1.7.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/4.1/topics/settings/\n\tFor the full list of settings and their values, see\n\thttps://docs.djangoproject.com/en/4.1/ref/settings/\n\t\"\"\"\n\timport os\n\tfrom pathlib import Path\n", "from dotenv import load_dotenv\n\tDJANGO_ENV = os.environ.get(\"DJANGO_ENV\", \"dev\")\n\tcurrent_directory_path = os.path.dirname(os.path.abspath(__file__))\n\tif DJANGO_ENV == \"prod\":\n\t    load_dotenv(os.path.join(current_directory_path, \"../env/.env.prod\"))\n\telse:\n\t    load_dotenv(os.path.join(current_directory_path, \"../env/.env.dev\"))\n\t# Build paths inside the project like this: BASE_DIR / 'subdir'.\n\tBASE_DIR = Path(__file__).resolve().parent.parent\n\t# Quick-start development settings - unsuitable for production\n", "# See https://docs.djangoproject.com/en/4.1/howto/deployment/checklist/\n\t# SECURITY WARNING: keep the secret key used in production secret!\n\tSECRET_KEY = os.environ.get(\"SECRET_KEY\")\n\t# SECURITY WARNING: don't run with debug turned on in production!\n\tDEBUG = True\n\tALLOWED_HOSTS = []\n\t# Application definition\n\tINSTALLED_APPS = [\n\t    \"django.contrib.admin\",\n\t    \"django.contrib.auth\",\n", "    \"django.contrib.contenttypes\",\n\t    \"django.contrib.sessions\",\n\t    \"django.contrib.messages\",\n\t    \"django.contrib.staticfiles\",\n\t]\n\tMIDDLEWARE = [\n\t    \"django.middleware.security.SecurityMiddleware\",\n\t    \"django.contrib.sessions.middleware.SessionMiddleware\",\n\t    \"django.middleware.common.CommonMiddleware\",\n\t    \"django.middleware.csrf.CsrfViewMiddleware\",\n", "    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n\t    \"django.contrib.messages.middleware.MessageMiddleware\",\n\t    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n\t]\n\tROOT_URLCONF = \"backend.urls\"\n\tTEMPLATES = [\n\t    {\n\t        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n\t        \"DIRS\": [],\n\t        \"APP_DIRS\": True,\n", "        \"OPTIONS\": {\n\t            \"context_processors\": [\n\t                \"django.template.context_processors.debug\",\n\t                \"django.template.context_processors.request\",\n\t                \"django.contrib.auth.context_processors.auth\",\n\t                \"django.contrib.messages.context_processors.messages\",\n\t            ],\n\t        },\n\t    },\n\t]\n", "WSGI_APPLICATION = \"backend.wsgi.application\"\n\t# Database\n\t# https://docs.djangoproject.com/en/4.1/ref/settings/#databases\n\tDATABASES = {\n\t    \"default\": {\n\t        \"ENGINE\": \"django.db.backends.sqlite3\",\n\t        \"NAME\": BASE_DIR / \"db.sqlite3\",\n\t    }\n\t}\n\t# Password validation\n", "# https://docs.djangoproject.com/en/4.1/ref/settings/#auth-password-validators\n\tAUTH_PASSWORD_VALIDATORS = [\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n\t    },\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n\t    },\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n", "    },\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n\t    },\n\t]\n\t# Internationalization\n\t# https://docs.djangoproject.com/en/4.1/topics/i18n/\n\tLANGUAGE_CODE = \"en-us\"\n\tTIME_ZONE = \"UTC\"\n\tUSE_I18N = True\n", "USE_TZ = True\n\t# Static files (CSS, JavaScript, Images)\n\t# https://docs.djangoproject.com/en/4.1/howto/static-files/\n\tSTATIC_URL = \"static/\"\n\t# Default primary key field type\n\t# https://docs.djangoproject.com/en/4.1/ref/settings/#default-auto-field\n\tDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"\n"]}
{"filename": "backend/speech/backend/urls.py", "chunked_list": ["\"\"\"backend URL Configuration\n\tThe `urlpatterns` list routes URLs to views. For more information please see:\n\t    https://docs.djangoproject.com/en/4.1/topics/http/urls/\n\tExamples:\n\tFunction views\n\t    1. Add an import:  from my_app import views\n\t    2. Add a URL to urlpatterns:  path('', views.home, name='home')\n\tClass-based views\n\t    1. Add an import:  from other_app.views import Home\n\t    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\n", "Including another URLconf\n\t    1. Import the include() function: from django.urls import include, path\n\t    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\t\"\"\"\n\tfrom django.contrib import admin\n\tfrom django.urls import path\n\tfrom backend.api import speech\n\turlpatterns = [path(\"admin/\", admin.site.urls)]\n\turlpatterns.extend(speech.get_urlpatterns())\n"]}
{"filename": "backend/speech/backend/__init__.py", "chunked_list": []}
{"filename": "backend/speech/backend/asgi.py", "chunked_list": ["\"\"\"\n\tASGI config for backend project.\n\tIt exposes the ASGI callable as a module-level variable named ``application``.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/4.1/howto/deployment/asgi/\n\t\"\"\"\n\timport os\n\tfrom django.core.asgi import get_asgi_application\n\tos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"backend.settings\")\n\tapplication = get_asgi_application()\n"]}
{"filename": "backend/speech/backend/wsgi.py", "chunked_list": ["\"\"\"\n\tWSGI config for backend project.\n\tIt exposes the WSGI callable as a module-level variable named ``application``.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/4.1/howto/deployment/wsgi/\n\t\"\"\"\n\timport os\n\timport shutil\n\timport atexit\n\tfrom django.core.wsgi import get_wsgi_application\n", "os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"backend.settings\")\n\tapplication = get_wsgi_application()\n\tdef shutdown_handler():\n\t    shutil.rmtree(\"media/\")\n\tatexit.register(shutdown_handler)\n"]}
{"filename": "backend/speech/backend/api/__init__.py", "chunked_list": []}
{"filename": "backend/speech/backend/api/speech.py", "chunked_list": ["import os\n\timport uuid\n\tfrom pydub import AudioSegment\n\tfrom django.urls import path\n\tfrom django.http import JsonResponse\n\tfrom django.views.decorators.csrf import csrf_exempt\n\tfrom model.speech.whisper import Whisper\n\tmodel = Whisper(os.environ.get(\"MODEL\", \"openai/whisper-tiny\"))\n\tALLOWED_EXTENSIONS = {\"mp3\", \"wav\", \"ogg\", \"m4a\", \"flac\", \"webm\"}\n\tdef allowed_file(filename: str) -> bool:\n", "    return \".\" in filename and filename.rsplit(\".\", 1)[1].lower() in ALLOWED_EXTENSIONS\n\t@csrf_exempt\n\tdef transcribe_audio(request):\n\t    if request.method == \"POST\":\n\t        if \"file\" not in request.FILES:\n\t            return JsonResponse({\"error\": \"No file provided.\"}, status=400)\n\t        file = request.FILES[\"file\"]\n\t        if not allowed_file(file.name):\n\t            return JsonResponse(\n\t                {\"error\": \"Invalid file type. Please upload an audio file.\"}, status=400\n", "            )\n\t        os.makedirs(\"media\", exist_ok=True)\n\t        # Save the received file\n\t        filename = f\"{uuid.uuid4()}.{file.name.rsplit('.', 1)[1].lower()}\"\n\t        filepath = os.path.join(\"media\", filename)\n\t        with open(filepath, \"wb\") as f:\n\t            for chunk in file.chunks():\n\t                f.write(chunk)\n\t        # Convert the file to .wav format\n\t        input_format = file.name.rsplit(\".\", 1)[1].lower()\n", "        if input_format != \"wav\":\n\t            wav_filename = f\"{uuid.uuid4()}.wav\"\n\t            wav_filepath = os.path.join(\"media\", wav_filename)\n\t            sound = AudioSegment.from_file(filepath, format=input_format)\n\t            sound.export(wav_filepath, format=\"wav\")\n\t            os.remove(filepath)  # Remove the original file\n\t        else:\n\t            wav_filepath = filepath\n\t        # Call the transcription function\n\t        # transcription = transcribe(wav_filepath)\n", "        transcription = model.transcribe(wav_filepath)\n\t        # Remove the .wav file\n\t        os.remove(wav_filepath)\n\t        return JsonResponse({\"transcription\": transcription})\n\t    else:\n\t        return JsonResponse({\"error\": \"Invalid request method. Use POST.\"}, status=405)\n\tdef get_urlpatterns():\n\t    return [\n\t        path(\"transcribe/\", transcribe_audio, name=\"transcribe\"),\n\t    ]\n"]}
{"filename": "backend/speech/tests/test_speech.py", "chunked_list": ["import os\n\timport pytest\n\tfrom scipy.io import wavfile\n\tdef test_transcribe():\n\t    pretrained_model = os.environ.get(\"MODEL\", \"openai/whisper-tiny\")\n\t    processor = WhisperProcessor.from_pretrained(pretrained_model)\n\t    model = WhisperForConditionalGeneration.from_pretrained(pretrained_model)\n\t    model.config.forced_decoder_ids = None\n\t    sampling_rate, data = wavfile.read(\"test.wav\")\n\t    data = whisper.convert_wav_to_flac(data, sampling_rate)\n", "    input_features = processor(\n\t        data, sampling_rate=sampling_rate, return_tensors=\"pt\"\n\t    ).input_features\n\t    predicted_ids = model.generate(input_features)\n\t    transcription = processor.batch_decode(predicted_ids, skip_special_tokens=True)\n\t    assert (\n\t        transcription[0].strip()\n\t        == \"Mr. Quilter is the apostle of the middle classes and we are glad to welcome his gospel.\"\n\t    )\n"]}
{"filename": "backend/speech/tests/test_whisper.py", "chunked_list": ["import pytest\n\timport numpy as np\n\tfrom scipy.io import wavfile\n\tfrom speech.whisper import Whisper\n\t@pytest.fixture\n\tdef whisper():\n\t    return Whisper()\n\tdef test_convert_wav_to_flac(whisper):\n\t    # Create a simple sine wave\n\t    sample_rate = 16000\n", "    frequency = 440\n\t    duration = 1\n\t    time = np.linspace(0, duration, sample_rate * duration, endpoint=False)\n\t    wav_data = np.sin(2 * np.pi * frequency * time) * (2**15 - 1)\n\t    flac_data = whisper.convert_wav_to_flac(wav_data, sample_rate)\n\t    assert isinstance(flac_data, np.ndarray)\n\t    assert len(flac_data) == len(wav_data)\n\tdef test_whisper(whisper):\n\t    sampling_rate, data = wavfile.read(\"test.wav\")\n\t    data = whisper.convert_wav_to_flac(data, sampling_rate)\n", "    transcription = whisper.speech_to_text(data, sampling_rate)\n\t    assert (\n\t        transcription[0].strip()\n\t        == \"Mr. Quilter is the apostle of the middle classes and we are glad to welcome his gospel.\"\n\t    )\n"]}
{"filename": "backend/speech/model/__init__.py", "chunked_list": []}
{"filename": "backend/speech/model/speech/main.py", "chunked_list": ["from whisper import Whisper\n\tdef main():\n\t    model = Whisper()\n\t    model.transcribe_audio()\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "backend/speech/model/speech/whisper.py", "chunked_list": ["\"\"\"\n\tThis script continuously listens for audio input, processes the audio in 5-second chunks, and \n\ttranscribes the speech using the \"openai/whisper\" model series with the Transformers pipeline \n\tand chunking enabled.\n\thttps://huggingface.co/openai/whisper-tiny\n\t\"\"\"\n\timport os\n\timport io\n\timport string\n\timport pyaudio\n", "import numpy as np\n\timport soundfile as sf\n\tfrom scipy.io import wavfile\n\tfrom typing import List\n\tfrom queue import Queue\n\tfrom threading import Thread\n\tfrom transformers import WhisperProcessor, WhisperForConditionalGeneration\n\tclass Whisper(object):\n\t    def __init__(self, model: str = \"openai/whisper-tiny\"):\n\t        self.seconds = int(os.environ.get(\"SECONDS\", 5))\n", "        self.sampling_rate = int(os.environ.get(\"SAMPLING_RATE\", 16000))\n\t        self.pretrained_model = model\n\t        self.processor = WhisperProcessor.from_pretrained(self.pretrained_model)\n\t        self.model = WhisperForConditionalGeneration.from_pretrained(\n\t            self.pretrained_model\n\t        )\n\t        self.model.config.forced_decoder_ids = None\n\t    # Record user audio\n\t    def record_audio(\n\t        self,\n", "        queue: Queue,\n\t        chunk: int = 1024,\n\t        channels: int = 1,\n\t        rate: int = 16000,\n\t        format: int = pyaudio.paInt16,\n\t    ) -> None:\n\t        audio = pyaudio.PyAudio()\n\t        stream = audio.open(\n\t            format=format,\n\t            channels=channels,\n", "            rate=rate,\n\t            input=True,\n\t            frames_per_buffer=chunk,\n\t        )\n\t        print(\"Listening...\")\n\t        while True:\n\t            try:\n\t                data = stream.read(chunk, exception_on_overflow=False)\n\t                queue.put(data)\n\t            except OSError as e:\n", "                if e.errno == -9981:\n\t                    print(\"Input overflowed. Skipping...\")\n\t                else:\n\t                    raise e\n\t    def convert_wav_to_flac(self, wav_data: np.ndarray, sample_rate: int) -> np.ndarray:\n\t        flac_data = io.BytesIO()\n\t        sf.write(flac_data, wav_data, sample_rate, format=\"FLAC\")\n\t        flac_data.seek(0)\n\t        flac_data_array, _ = sf.read(flac_data)\n\t        return flac_data_array\n", "    def speech_to_text(self, data: np.ndarray, sampling_rate: int) -> List[str]:\n\t        input_features = self.processor(\n\t            data, sampling_rate=sampling_rate, return_tensors=\"pt\"\n\t        ).input_features\n\t        predicted_ids = self.model.generate(input_features)\n\t        return self.processor.batch_decode(predicted_ids, skip_special_tokens=True)\n\t    def transcribe(self, file_path: str) -> str:\n\t        sampling_rate, data = wavfile.read(file_path)\n\t        data = self.convert_wav_to_flac(data, sampling_rate)\n\t        return self.speech_to_text(data, sampling_rate)\n", "    def transcribe_audio(self):\n\t        # Initialize the recording thread and queue\n\t        record_queue = Queue()\n\t        record_thread = Thread(target=self.record_audio, args=(record_queue,))\n\t        record_thread.daemon = True\n\t        record_thread.start()\n\t        # Set up continuous streaming\n\t        buffer = []\n\t        buffer_len = 0\n\t        buffer_max_len = self.seconds * self.sampling_rate\n", "        print(\"Starting transcription loop...\")\n\t        pattern = r\"[^\\w\\s]\"\n\t        while True:\n\t            if not record_queue.empty():\n\t                # Retrieve the recorded data and append it to the buffer\n\t                data = record_queue.get()\n\t                data_np = np.frombuffer(data, dtype=np.int16)\n\t                buffer.append(data_np)\n\t                buffer_len += len(data_np)\n\t                # Check if the buffer is full\n", "                if buffer_len >= buffer_max_len:\n\t                    # Concatenate the buffered data into a single array\n\t                    audio_input = np.concatenate(buffer, axis=0)\n\t                    # Save the audio input to a temporary file\n\t                    temp_filename = \"temp.wav\"\n\t                    sf.write(\n\t                        temp_filename, audio_input, self.sampling_rate, subtype=\"PCM_16\"\n\t                    )\n\t                    sampling_rate, data = wavfile.read(\"temp.wav\")\n\t                    data = self.convert_wav_to_flac(data, sampling_rate)\n", "                    transcription = self.speech_to_text(data, sampling_rate)\n\t                    # TODO: Trigger is for development purposes only. Remove later.\n\t                    print(\"Transcription:\", transcription)\n\t                    trigger = (\n\t                        transcription[0]\n\t                        .lower()\n\t                        .translate(str.maketrans(\"\", \"\", string.punctuation))\n\t                        .strip()\n\t                    )\n\t                    if trigger == \"stop\":\n", "                        os.remove(temp_filename)\n\t                        break\n\t                    # Clear the buffer and remove the temporary file\n\t                    buffer = []\n\t                    buffer_len = 0\n\t                    os.remove(temp_filename)\n"]}
{"filename": "backend/speech/model/speech/__init__.py", "chunked_list": []}
