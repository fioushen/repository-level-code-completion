{"filename": "tests/test_quantize.py", "chunked_list": ["import pytest\n\tfrom asciinema_scene.scenelib.scene import Scene\n\tfrom .contents import LONG_FILE_CONTENT, SHORT_FILE_CONTENT\n\tdef test_quant_err_1():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    with pytest.raises(AssertionError):\n\t        scene.quantize(2.0, 1.0, 5.0)\n\tdef test_quant_err_2():\n\t    scene = Scene()\n", "    scene.parse_content(SHORT_FILE_CONTENT)\n\t    with pytest.raises(AssertionError):\n\t        scene.quantize(1.0, 2.0, -5.0)\n\tdef test_quant_1():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.quantize(0.1, 1.0, 0.2)\n\t    result = scene.duration\n\t    assert result == 4.000055\n\tdef test_quant_2():\n", "    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    orig_duration = scene.duration\n\t    scene.quantize(10.0, 99999.0, 1000.0)\n\t    result = scene.duration\n\t    assert result == orig_duration\n\tdef test_quant_3():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.quantize(0.0, 99999.0, 0.0)\n", "    result = scene.duration\n\t    assert result == 0.0\n\tdef test_quant_long():\n\t    scene = Scene()\n\t    scene.parse_content(LONG_FILE_CONTENT)\n\t    scene.quantize(0.0, 1.0, 0.01)\n\t    result = scene.duration\n\t    assert result == 715.862995\n\tdef test_quant_4():\n\t    scene = Scene()\n", "    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.quantize(0.1, 0.2, 5.0)\n\t    result = scene.duration\n\t    assert result == 44.883721\n\tdef test_quant_5():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.quantize(0.1, 0.2, 5.0, start=4.0)\n\t    result = scene.duration\n\t    assert result == 20.601913\n", "def test_quant_6():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.quantize(0.1, 0.2, 5.0, end=4.0)\n\t    result = scene.duration\n\t    assert result == 30.417801\n\tdef test_quant_7():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.quantize(0.1, 0.2, 5.0, start=2.0, end=4.0)\n", "    result = scene.duration\n\t    assert result == 20.687072\n\tdef test_maximum_1():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.maximum(0.1)\n\t    result = scene.duration\n\t    assert result == 2.000055\n\tdef test_minimum_1():\n\t    scene = Scene()\n", "    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.minimum(0.25)\n\t    result = scene.duration\n\t    assert result == 7.265482\n"]}
{"filename": "tests/contents.py", "chunked_list": ["import gzip\n\tfrom importlib import resources as rso\n\tLONG_FILE_CONTENT = gzip.decompress(\n\t    rso.read_binary(\"tests.files\", \"long.cast.gz\")\n\t).decode()\n\tSHORT_FILE_CONTENT = rso.read_text(\"tests.files\", \"short.cast\", encoding=\"utf8\")\n"]}
{"filename": "tests/test_select.py", "chunked_list": ["from asciinema_scene.scenelib.scene import Scene\n\tfrom .contents import LONG_FILE_CONTENT, SHORT_FILE_CONTENT\n\tdef test_select_frames_short():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    result = scene.select_frames(0, 1000000000)\n\t    assert len(result) == scene.length\n\t    assert result[0] == scene.frames[0]\n\t    assert result[-1] == scene.frames[-1]\n\tdef test_select_frames_long():\n", "    scene = Scene()\n\t    scene.parse_content(LONG_FILE_CONTENT)\n\t    result = scene.select_frames(0, 1000000000)\n\t    assert result[0] == scene.frames[0]\n\t    assert result[1000] == scene.frames[1000]\n\tdef test_select_frames_short_2():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    result = scene.select_frames(2874000, end=3200000)\n\t    assert len(result) == 2\n", "    assert result[0].text == \"s\"\n\t    assert result[1].text == \"h\"\n\tdef test_select_frames_short_3():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    result = scene.select_frames(4400000, 1000000000)\n\t    assert len(result) == 6\n\t    assert result[0].text == \"s\"\n\tdef test_select_frames_short_4():\n\t    scene = Scene()\n", "    scene.parse_content(SHORT_FILE_CONTENT)\n\t    result = scene.select_frames(4400000, 4500000)\n\t    assert len(result) == 0\n\tdef test_select_frames_short_5():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    result = scene.select_frames(4400000, 4600000)\n\t    assert len(result) == 1\n\t    assert result[0].text == \"s\"\n"]}
{"filename": "tests/test_cut.py", "chunked_list": ["import time\n\tfrom asciinema_scene.scenelib.scene import Scene\n\tfrom .contents import LONG_FILE_CONTENT, SHORT_FILE_CONTENT\n\tdef test_set_timecodes_none():\n\t    scene = Scene()\n\t    scene.set_timecodes()\n\t    assert scene.length == 0\n\tdef test_set_timecodes_short():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n", "    orig = scene.dumps()\n\t    scene.set_timecodes()\n\t    result = scene.dumps()\n\t    assert result == orig\n\tdef test_cut_frames_short():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.cut_frames(start=4.4, end=None)\n\t    result = scene.header[\"timestamp\"]\n\t    assert time.time() - result < 3\n", "def test_cut_frames_short_adjust():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.cut_frames(start=4.4, end=None, adjust=True)\n\t    result = scene.header[\"timestamp\"]\n\t    assert time.time() - result < 3\n\tdef test_cut_frames_short_2():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.cut_frames(start=4.4, end=0.0)\n", "    assert scene.length == 17\n\t    assert scene.duration == 4.588233\n\tdef test_cut_frames_short_adjust_2():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.cut_frames(start=4.4, end=None, adjust=True)\n\t    assert scene.length == 17\n\t    assert scene.duration == 4.4\n\tdef test_cut_frames_short_3():\n\t    scene = Scene()\n", "    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.cut_frames(start=None, end=None)\n\t    assert scene.length == 0\n\t    assert scene.duration == 0.0\n\tdef test_cut_frames_short_adjust_3():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.cut_frames(adjust=True)\n\t    assert scene.length == 0\n\t    assert scene.duration == 0.0\n", "def test_cut_frames_short_4():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.cut_frames(start=4.4, end=5.0)\n\t    assert scene.length == 19\n\t    assert scene.duration == 5.330601\n\tdef test_cut_frames_short_adjust_4():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    orig_duration = scene.duration  # 7.145993\n", "    scene.cut_frames(start=4.4, end=5.0, adjust=True)\n\t    assert scene.length == 20\n\t    assert scene.duration == 5.535993\n\t    target = round(orig_duration + 4.4 - 5.0, 6)\n\t    assert scene.duration == target\n\tdef test_cut_frames_long():\n\t    scene = Scene()\n\t    scene.parse_content(LONG_FILE_CONTENT)\n\t    scene.cut_frames(start=1.0, end=16.0)\n\t    assert scene.length == 5653\n", "    assert scene.duration == 1.599407\n\tdef test_cut_frames_long_adjust():\n\t    scene = Scene()\n\t    scene.parse_content(LONG_FILE_CONTENT)\n\t    orig_duration = scene.duration  # 7.145993\n\t    scene.cut_frames(start=1.0, end=16.0, adjust=True)\n\t    assert scene.length == 5654\n\t    assert scene.duration == 1.789319\n\t    target = round(orig_duration - 15, 6)\n\t    assert scene.duration == target\n", "def test_cut_frames_short_small():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    orig = scene.duplicate()\n\t    scene.cut_frames(start=4.4, end=4.5)\n\t    assert scene.length == orig.length\n\t    assert scene.duration == orig.duration\n\tdef test_cut_frames_short_small_duration():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n", "    orig = scene.duplicate()\n\t    scene.cut_frames(start=4.4, end=4.5)\n\t    assert scene.length == orig.length\n\t    assert scene.duration == orig.duration\n\tdef test_cut_frames_short_small_duration_adjust():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    orig = scene.duplicate()\n\t    scene.cut_frames(start=4.4, end=4.5, adjust=True)\n\t    assert scene.length == orig.length\n", "    assert scene.duration == round(orig.duration - 0.1, 6)\n\tdef test_cut_frames_short_small_duration_out_limit():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    orig = scene.duplicate()\n\t    scene.cut_frames(start=100.0, end=100.0)\n\t    assert scene.length == orig.length\n\t    assert scene.duration == orig.duration\n\tdef test_cut_frames_short_small_duration_out_limit_adjust():\n\t    scene = Scene()\n", "    scene.parse_content(SHORT_FILE_CONTENT)\n\t    orig = scene.duplicate()\n\t    scene.cut_frames(start=100.0, end=100.0, adjust=True)\n\t    assert scene.length == orig.length\n\t    assert scene.duration == orig.duration\n"]}
{"filename": "tests/test_scene_content.py", "chunked_list": ["import json\n\timport tempfile\n\timport time\n\tfrom importlib import resources as rso\n\tfrom pathlib import Path\n\timport pytest\n\tfrom asciinema_scene.scenelib.scene_content import SceneContent\n\tfrom .contents import LONG_FILE_CONTENT, SHORT_FILE_CONTENT\n\tdef test_parse_status_short():\n\t    scene = SceneContent()\n", "    scene.parse_content(SHORT_FILE_CONTENT)\n\t    expected = (\n\t        \"Input: string\\nDate: 2023-05-28 11:15:06+00:00\\n\"\n\t        \"Frames: 22\\nDuration: 6.135993\"\n\t    )\n\t    result = scene.info\n\t    assert result == expected\n\tdef test_parse_status_long():\n\t    scene = SceneContent()\n\t    scene.parse_content(LONG_FILE_CONTENT)\n", "    expected = (\n\t        \"Input: string\\nDate: 2023-05-28 11:11:21+00:00\\n\"\n\t        \"Frames: 71369\\nDuration: 16.789319\"\n\t    )\n\t    result = scene.info\n\t    assert result == expected\n\tdef test_scene_header_short():\n\t    scene = SceneContent()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    expected = {\n", "        \"env\": {\"SHELL\": \"/bin/bash\", \"TERM\": \"linux\"},\n\t        \"height\": 36,\n\t        \"timestamp\": 1685272506,\n\t        \"version\": 2,\n\t        \"width\": 133,\n\t    }\n\t    result = scene.header\n\t    assert result == expected\n\tdef test_scene_header_short_2():\n\t    scene = SceneContent()\n", "    content = SHORT_FILE_CONTENT + '{\"env\": \"duplicate header\"}\\n'\n\t    scene.parse_content(content)\n\t    expected = {\n\t        \"env\": {\"SHELL\": \"/bin/bash\", \"TERM\": \"linux\"},\n\t        \"height\": 36,\n\t        \"timestamp\": 1685272506,\n\t        \"version\": 2,\n\t        \"width\": 133,\n\t    }\n\t    result = scene.header\n", "    assert result == expected\n\tdef test_scene_header_long():\n\t    scene = SceneContent()\n\t    scene.parse_content(LONG_FILE_CONTENT)\n\t    expected = {\n\t        \"env\": {\"SHELL\": \"/bin/bash\", \"TERM\": \"linux\"},\n\t        \"height\": 36,\n\t        \"timestamp\": 1685272281,\n\t        \"version\": 2,\n\t        \"width\": 133,\n", "    }\n\t    result = scene.header\n\t    assert result == expected\n\tdef test_scene_str():\n\t    scene = SceneContent()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    result = str(scene)\n\t    assert result == (\n\t        \"<Scene 'string', 2023-05-28 11:15:06+00:00, Frames:22, Duration:6.136>\"\n\t    )\n", "def test_raise_parse():\n\t    scene = SceneContent()\n\t    with pytest.raises(json.decoder.JSONDecodeError):\n\t        scene.parse_content(\"wrong content!\")\n\tdef test_raise_parse_2():\n\t    with pytest.raises(FileNotFoundError):\n\t        SceneContent.parse(\"test no existing file\")\n\tdef test_parse_file_cast():\n\t    for file in rso.files(\"tests.files\").iterdir():\n\t        if file.name == \"short.cast\":\n", "            with rso.as_file(file) as actual_path:\n\t                scene = SceneContent.parse(actual_path)\n\t                result = str(scene)\n\t                assert result == (\n\t                    \"<Scene 'short.cast', 2023-05-28 11:15:06+00:00, \"\n\t                    \"Frames:22, Duration:6.136>\"\n\t                )\n\t                break\n\tdef test_parse_file_gz():\n\t    for file in rso.files(\"tests.files\").iterdir():\n", "        if file.name == \"long.cast.gz\":\n\t            with rso.as_file(file) as actual_path:\n\t                scene = SceneContent.parse(actual_path)\n\t                result = str(scene)\n\t                assert result == (\n\t                    \"<Scene 'long.cast.gz', 2023-05-28 11:11:21+00:00, \"\n\t                    \"Frames:71369, Duration:16.789>\"\n\t                )\n\t                break\n\tdef test_parse_file_zip():\n", "    for file in rso.files(\"tests.files\").iterdir():\n\t        if file.name == \"short.cast.zip\":\n\t            with rso.as_file(file) as actual_path:\n\t                scene = SceneContent.parse(actual_path)\n\t                result = str(scene)\n\t                assert result == (\n\t                    \"<Scene 'short.cast.zip', 2023-05-28 11:15:06+00:00, \"\n\t                    \"Frames:22, Duration:6.136>\"\n\t                )\n\t                break\n", "def test_duplicate():\n\t    scene = SceneContent()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    result = scene.duplicate()\n\t    assert id(scene) != id(result)\n\t    assert scene.header == result.header\n\t    assert str(scene) == str(result)\n\t    assert id(scene.frames[5]) != id(result.frames[5])\n\t    assert str(scene.frames[5].as_list()) == str(result.frames[5].as_list())\n\tdef test_timestamp():\n", "    scene = SceneContent()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    result = scene.header[\"timestamp\"]\n\t    assert result == 1685272506\n\tdef test_set_timestamp():\n\t    scene = SceneContent()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.set_timestamp()\n\t    result = scene.header[\"timestamp\"]\n\t    assert time.time() - result < 3\n", "def test_length():\n\t    scene = SceneContent()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    result = scene.length\n\t    assert result == 22\n\tdef test_duration():\n\t    scene = SceneContent()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    result = scene.duration\n\t    assert result == 6.135993\n", "def test_dumps():\n\t    scene = SceneContent()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    dump = scene.dumps()\n\t    scene2 = SceneContent()\n\t    scene2.parse_content(dump)\n\t    result = scene2.dumps()\n\t    assert result == dump\n\tdef test_dump():\n\t    scene = SceneContent()\n", "    scene.parse_content(SHORT_FILE_CONTENT)\n\t    with tempfile.TemporaryDirectory() as tmp_folder:\n\t        cast_file = Path(tmp_folder) / \"tmp.cast\"\n\t        scene.dump(cast_file)\n\t        scene2 = SceneContent.parse(cast_file)\n\t    expected = scene.dumps()\n\t    result = scene2.dumps()\n\t    assert result == expected\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_cli.py", "chunked_list": ["import importlib.metadata\n\timport shlex\n\timport subprocess\n\timport time\n\tfrom importlib import resources as rso\n\tfrom click.testing import CliRunner\n\tfrom asciinema_scene.sciine import cli\n\tfrom .contents import SHORT_FILE_CONTENT\n\t__version__ = importlib.metadata.version(\"asciinema_scene\")\n\tdef my_invoke(command: str, input_content: str):\n", "    proc = subprocess.Popen(\n\t        shlex.split(\"sciine \" + command),\n\t        stdin=subprocess.PIPE,\n\t        stdout=subprocess.PIPE,\n\t    )\n\t    proc.stdin.write(input_content.encode())\n\t    proc.stdin.close()\n\t    proc.wait()\n\t    return proc.returncode, proc.stdout.read().decode()\n\tdef test_version_0():\n", "    assert isinstance(__version__, str)\n\tdef test_cli_version():\n\t    runner = CliRunner()\n\t    result = runner.invoke(cli, \"--version\")\n\t    assert result.exit_code == 0\n\t    assert result.output.strip().endswith(f\"version {__version__}\")\n\tdef test_cli_help():\n\t    runner = CliRunner()\n\t    result = runner.invoke(cli, \"--help\")\n\t    assert result.exit_code == 0\n", "    for text in (\n\t        \"copy      Copy content\",\n\t        \"cut       Cut content\",\n\t        \"header    Print the header\",\n\t        \"include   Include the content\",\n\t        \"insert    Insert a frame\",\n\t        \"maximum   Set maximum\",\n\t        \"minimum   Set minimum\",\n\t        \"quantize  Set the duration\",\n\t        \"show      Print detail\",\n", "        \"speed     Change the speed\",\n\t        \"status    Print information\",\n\t    ):\n\t        assert text in result.output\n\tdef test_cli_cut():\n\t    code, output = my_invoke(\"cut -e 3.0\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    code2, output2 = my_invoke(\"status\", output)\n\t    assert code2 == 0\n\t    assert \"Duration: 3.023\" in output2\n", "def test_cli_copy():\n\t    code, output = my_invoke(\"copy -e 1.0\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    code2, output2 = my_invoke(\"status\", output)\n\t    assert code2 == 0\n\t    assert \"Duration: 1.163\" in output2\n\tdef test_cli_header():\n\t    code, output = my_invoke(\"header\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    assert \"/bin/bash\" in output\n", "def test_cli_include():\n\t    code = output = None\n\t    for file in rso.files(\"tests.files\").iterdir():\n\t        with rso.as_file(file) as path:\n\t            if path.name != \"short.cast\":\n\t                continue\n\t            code, output = my_invoke(f\"include 1.0 {path}\", SHORT_FILE_CONTENT)\n\t            break\n\t    assert output is not None\n\t    assert code == 0\n", "    code2, output2 = my_invoke(\"status\", output)\n\t    assert code2 == 0\n\t    assert \"Duration: 12.271986\" in output2\n\tdef test_cli_insert():\n\t    code, output = my_invoke(\"insert 1.0 5.0 message\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    code2, output2 = my_invoke(\"status\", output)\n\t    assert code2 == 0\n\t    assert \"Duration: 11.135993\" in output2\n\tdef test_cli_delete():\n", "    code, output = my_invoke(\"delete 1.16\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    code2, output2 = my_invoke(\"status\", output)\n\t    assert code2 == 0\n\t    assert \"Duration: 5.835392\" in output2\n\tdef test_cli_replace():\n\t    code, output = my_invoke(\"replace 1.16 abc\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    code2, output2 = my_invoke(\"status\", output)\n\t    assert code2 == 0\n", "    assert \"Duration: 6.135993\" in output2\n\t    code3, output3 = my_invoke(\"show -s 1.16 -l 1\", output)\n\t    assert code3 == 0\n\t    assert \"abc\" in output3.strip()\n\tdef test_cli_insert_o():\n\t    code, output = my_invoke(\"insert 1.0 5.0 message o\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    code2, output2 = my_invoke(\"status\", output)\n\t    assert code2 == 0\n\t    assert \"Duration: 11.135993\" in output2\n", "def test_cli_maximum():\n\t    code, output = my_invoke(\"maximum 0.1\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    code2, output2 = my_invoke(\"status\", output)\n\t    assert code2 == 0\n\t    assert \"Duration: 2.000\" in output2\n\tdef test_cli_minimum():\n\t    code, output = my_invoke(\"minimum 10.0\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    code2, output2 = my_invoke(\"status\", output)\n", "    assert code2 == 0\n\t    assert \"Duration: 210.000\" in output2\n\tdef test_cli_quantize():\n\t    code, output = my_invoke(\"quantize 0.1 3.0 20.0\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    code2, output2 = my_invoke(\"status\", output)\n\t    assert code2 == 0\n\t    assert \"Duration: 400.000\" in output2\n\tdef test_cli_show_1():\n\t    code, output = my_invoke(\"show\", SHORT_FILE_CONTENT)\n", "    assert code == 0\n\t    assert \"0.000│ 0.89│ 'e'\\n\" in output\n\tdef test_cli_show_2():\n\t    code, output = my_invoke(\"show --precise\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    assert \"0.000000│ 0.894038│ 'e'\\n\" in output\n\tdef test_cli_show_3():\n\t    code, output = my_invoke(\"show --text\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    assert \"0.000│ 0.89│ e\" in output\n", "def test_cli_show_4():\n\t    code, output = my_invoke(\"show --text --precise\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    assert \"0.000000│ 0.894038│ e\\n\" in output\n\tdef test_cli_show_5():\n\t    code, output = my_invoke(\"show --lines 2\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    assert \"0.000│ 0.89│ 'e'\\n\" in output\n\tdef test_cli_show_6():\n\t    code, output = my_invoke(\"show -s 0.0\", SHORT_FILE_CONTENT)\n", "    assert code == 0\n\t    assert \"0.000│ 0.89│ 'e'\\n\" in output\n\t    assert len(output.strip().split(\"\\n\")) == 22\n\tdef test_cli_show_7():\n\t    code, output = my_invoke(\"show -s 1.0\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    assert \"0.000│ 0.89│ 'e'\\n\" not in output\n\t    assert len(output.strip().split(\"\\n\")) == 19\n\tdef test_cli_show_8():\n\t    code, output = my_invoke(\"show -s 1.0 -e 2.0\", SHORT_FILE_CONTENT)\n", "    assert code == 0\n\t    assert \"0.000│ 0.89│ 'e'\\n\" not in output\n\t    assert len(output.strip().split(\"\\n\")) == 3\n\tdef test_cli_speed():\n\t    code, output = my_invoke(\"speed 1.0\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    result_cast = output\n\t    code2, output2 = my_invoke(\"status \", result_cast)\n\t    assert code2 == 0\n\t    assert \"Duration: 6.135993\" in output2\n", "def test_cli_status():\n\t    code, output = my_invoke(\"status\", SHORT_FILE_CONTENT)\n\t    assert code == 0\n\t    assert \"Duration: 6.135993\" in output\n\tdef test_timeout():\n\t    command = \"status\"\n\t    proc = subprocess.Popen(\n\t        shlex.split(\"sciine \" + command),\n\t        stdin=subprocess.PIPE,\n\t        stdout=subprocess.PIPE,\n", "    )\n\t    time.sleep(2)\n\t    proc.stdin.close()\n\t    proc.wait()\n\t    assert proc.returncode == 0\n\t    output = proc.stdout.read().decode()\n\t    assert \"Timeout while waiting\" in output\n"]}
{"filename": "tests/test_frame.py", "chunked_list": ["from asciinema_scene.scenelib.frame import Frame\n\tdef test_frame_init():\n\t    result = Frame()\n\t    assert result.timecode == 0\n\t    assert result.duration == 0\n\t    assert result.tpe == \"\"\n\t    assert result.text == \"\"\n\tdef test_frame_parse():\n\t    data = [0.123456, \"o\", \"Some test\"]\n\t    result = Frame.parse(data)\n", "    assert result.timecode == 123456\n\t    assert result.duration == 0\n\t    assert result.tpe == \"o\"\n\t    assert result.text == \"Some test\"\n\tdef test_frame_parse_2():\n\t    data = [8899.123456999, \"o\", \"Some test\"]\n\t    result = Frame.parse(data)\n\t    assert result.timecode == 8899123457\n\tdef test_tc_float():\n\t    data = [8899.123456999, \"o\", \"Some test\"]\n", "    result = Frame.parse(data)\n\t    assert result.tc_float == 8899.123457\n\tdef test_tc_floor3_low():\n\t    data = [8899.123456, \"o\", \"Some test\"]\n\t    result = Frame.parse(data)\n\t    assert result.tc_floor3 == 8899.123\n\t    assert result.tc_floor6 == 8899.123456\n\tdef test_tc_floor3_high():\n\t    data = [8899.123999, \"o\", \"Some test\"]\n\t    result = Frame.parse(data)\n", "    assert result.tc_floor3 == 8899.123\n\t    assert result.tc_floor6 == 8899.123999\n\tdef test_dur_float():\n\t    data = [8899.123456999, \"o\", \"Some test\"]\n\t    result = Frame.parse(data)\n\t    assert result.dur_float == 0.0\n\tdef test_as_list():\n\t    data = [1.234567, \"o\", \"Some test\"]\n\t    frame = Frame.parse(data)\n\t    result = frame.as_list()\n", "    assert result == data\n\tdef test_tc_dur_text_short():\n\t    data = [1.234999, \"o\", \"Some test\"]\n\t    frame = Frame.parse(data)\n\t    result = frame.timecode_duration_text_short_repr\n\t    assert result == \"  1.234│ 0.00│ 'Some test'\\n\"\n\tdef test_tc_dur_text_long():\n\t    data = [1.234999, \"o\", \"Some test\"]\n\t    frame = Frame.parse(data)\n\t    result = frame.timecode_duration_text_long_repr\n", "    assert result == \"  1.234999│ 0.000000│ 'Some test'\\n\"\n\tdef test_tc_dur_text_short_str():\n\t    data = [1.234999, \"o\", \"Some test\"]\n\t    frame = Frame.parse(data)\n\t    result = frame.timecode_duration_text_short_str\n\t    assert result == \"  1.234│ 0.00│ Some test\\n\"\n\tdef test_tc_dur_text_long_str():\n\t    data = [1.234999, \"o\", \"Some test\"]\n\t    frame = Frame.parse(data)\n\t    result = frame.timecode_duration_text_long_str\n", "    assert result == \"  1.234999│ 0.000000│ Some test\\n\"\n\tdef test_dumps():\n\t    data = [1.234999, \"o\", \"Some \\n \\u2502 test\"]\n\t    frame = Frame.parse(data)\n\t    result = frame.dumps()\n\t    assert result == r'[1.234999, \"o\", \"Some \\n \\u2502 test\"]'\n\tdef test_str():\n\t    data = [1.234999, \"o\", \"Some \\n \\u2502 test\"]\n\t    frame = Frame.parse(data)\n\t    result = str(frame)\n", "    assert result == r'[1.234999, \"o\", \"Some \\n \\u2502 test\"]'\n\tdef test_copy():\n\t    data = [1.234999, \"o\", \"Some \\n \\u2502 test\"]\n\t    frame = Frame.parse(data)\n\t    result = frame.copy()\n\t    assert id(result) != id(frame)\n\t    assert result.timecode == frame.timecode\n\t    assert result.duration == frame.duration\n\t    assert result.tpe == frame.tpe\n\t    assert result.text == frame.text\n"]}
{"filename": "tests/test_include.py", "chunked_list": ["from asciinema_scene.scenelib.scene import Scene\n\tfrom .contents import SHORT_FILE_CONTENT\n\tdef some_scene() -> Scene:\n\t    scene = Scene()\n\t    scene.parse_content(\n\t        \"\"\"{\"version\": 2, \"width\": 133, \"height\": 36, \"timestamp\": 1685272506, \"env\": {\"SHELL\": \"/bin/bash\", \"TERM\": \"linux\"}}\n\t[0.0, \"o\", \"aaa\"]\n\t[0.1, \"o\", \"bbb\"]\n\t[0.2, \"o\", \"ccc\"]\n\t[0.3, \"o\", \"ddd\"]\n", "\"\"\"\n\t    )\n\t    return scene\n\tdef test_include_0():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    inc_scene = some_scene()\n\t    scene.include_scene(0.0, inc_scene)\n\t    assert scene.length == 27\n\t    assert scene.duration == 6.435993\n", "def test_insert_1():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    inc_scene = some_scene()\n\t    scene.include_scene(2.0, inc_scene)\n\t    assert scene.length == 27\n\t    assert scene.duration == 6.435993\n\tdef test_insert_last():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n", "    inc_scene = some_scene()\n\t    scene.include_scene(999.0, inc_scene)\n\t    assert scene.length == 27\n\t    assert scene.duration == 6.435993\n\tdef test_insert_last_empty():\n\t    scene = Scene()\n\t    inc_scene = some_scene()\n\t    print(scene)\n\t    scene.include_scene(10000.0, inc_scene)\n\t    assert scene.length == 5\n", "    assert scene.duration == 0.3\n"]}
{"filename": "tests/test_copy.py", "chunked_list": ["from asciinema_scene.scenelib.scene import Scene\n\tfrom .contents import LONG_FILE_CONTENT, SHORT_FILE_CONTENT\n\tdef test_copy_short_zerot():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.copy(start=0.0, end=0.0)\n\t    assert scene.length == 22\n\tdef test_copy_short_2():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n", "    scene.copy(start=2.86, end=3.99)\n\t    assert scene.length == 7\n\t    assert scene.duration == 1.318831\n\tdef test_copy_short_2_adjust():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.copy(start=2.88, end=3.99, adjust=True)\n\t    assert scene.length == 7\n\t    assert scene.duration == 1.110001\n\tdef test_copy_long():\n", "    scene = Scene()\n\t    scene.parse_content(LONG_FILE_CONTENT)\n\t    scene.copy(start=1.0, end=10.0)\n\t    assert scene.length == 46093\n\t    assert scene.duration == 8.99373\n\tdef test_copy_short_3():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.copy(end=3.84)\n\t    assert scene.length == 13\n", "    assert scene.duration == 3.849352\n\tdef test_copy_short_3_adjust():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.copy(end=3.84, adjust=True)\n\t    assert scene.length == 13\n\t    assert scene.duration == 3.84\n\tdef test_copy_short_4():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n", "    scene.copy(end=3.95)\n\t    assert scene.length == 14\n\t    assert scene.duration == 3.9829\n\tdef test_copy_short_4_adjust():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.copy(end=3.95, adjust=True)\n\t    assert scene.length == 14\n\t    assert scene.duration == 3.95\n\tdef test_copy_short_out_5():\n", "    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.copy(start=100.0, end=100.0)\n\t    assert scene.length == 0\n\t    assert scene.duration == 0.0\n\tdef test_copy_short_5_out_adjust():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.copy(start=100.0, end=100.0, adjust=True)\n\t    assert scene.length == 0\n", "    assert scene.duration == 0.0\n"]}
{"filename": "tests/test_insert.py", "chunked_list": ["import pytest\n\tfrom asciinema_scene.scenelib.scene import Scene\n\tfrom .contents import SHORT_FILE_CONTENT\n\tdef test_insert_err_1():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    with pytest.raises(AssertionError):\n\t        scene.insert(-2.0, 1.0, \"a\")\n\tdef test_insert_err_2():\n\t    scene = Scene()\n", "    scene.parse_content(SHORT_FILE_CONTENT)\n\t    with pytest.raises(AssertionError):\n\t        scene.insert(2.0, -1.0, \"a\")\n\tdef test_insert_0():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.insert(0.0, 1.0, \"before\")\n\t    assert scene.length == 23\n\t    assert scene.duration == 7.135993\n\tdef test_insert_1():\n", "    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.insert(2.0, 1.0, \"middle\")\n\t    assert scene.length == 23\n\t    assert scene.duration == 7.135993\n\tdef test_insert_last():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.insert(99999.0, 1.0, \"last\")\n\t    assert scene.length == 23\n", "    assert scene.duration == 7.135993\n\tdef test_insert_empty():\n\t    scene = Scene()\n\t    scene.insert(99999.0, 1.0, \"last\")\n\t    assert scene.length == 2\n\t    assert scene.duration == 1.0\n\tdef test_insert_empty_last_broken():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.frames[-1].text = \"aaa\"\n", "    scene.insert(99999.0, 1.0, \"last\")\n\t    assert scene.length == 24\n\t    assert scene.duration == 7.135993\n\tdef test_replace_one():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    expected1 = len(scene.frames)\n\t    scene.replace(0.01, \"abc\")\n\t    assert len(scene.frames) == expected1\n\t    assert scene.frames[1].text == \"abc\"\n", "def test_replace_none():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    expected = [str(frame) for frame in scene.frames]\n\t    scene.replace(5000.0, \"none\")\n\t    result = [str(frame) for frame in scene.frames]\n\t    assert result == expected\n\tdef test_delete_zero():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n", "    expected1 = len(scene.frames) - 1\n\t    expected2 = scene.frames[1].text\n\t    scene.delete(0.0)\n\t    assert len(scene.frames) == expected1\n\t    assert scene.frames[0].text == expected2\n\tdef test_delete_one():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    expected1 = len(scene.frames) - 1\n\t    expected2 = scene.frames[2].text\n", "    scene.delete(0.01)\n\t    assert len(scene.frames) == expected1\n\t    assert scene.frames[1].text == expected2\n\tdef test_delete_none():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    expected = [str(frame) for frame in scene.frames]\n\t    scene.delete(5000.0)\n\t    result = [str(frame) for frame in scene.frames]\n\t    assert result == expected\n"]}
{"filename": "tests/test_speed.py", "chunked_list": ["import pytest\n\tfrom asciinema_scene.scenelib.scene import Scene\n\tfrom .contents import LONG_FILE_CONTENT, SHORT_FILE_CONTENT\n\tdef test_speed_zero():\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    with pytest.raises(ValueError):\n\t        scene.speed(0.0)\n\tdef test_speed_2():\n\t    speed = 2.0\n", "    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    orig_duration = scene.duration\n\t    scene.speed(speed)\n\t    result = abs(orig_duration / speed - scene.duration)\n\t    assert result / orig_duration < 0.01\n\tdef test_speed_3():\n\t    speed = 1.0\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n", "    orig_duration = scene.duration\n\t    scene.speed(speed)\n\t    result = abs(orig_duration / speed - scene.duration)\n\t    assert result / orig_duration < 0.01\n\tdef test_speed_4():\n\t    speed = 10.0\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    orig_duration = scene.duration\n\t    scene.speed(speed)\n", "    result = abs(orig_duration / speed - scene.duration)\n\t    assert result / orig_duration < 0.01\n\tdef test_speed_5():\n\t    speed = 0.5\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    orig_duration = scene.duration\n\t    scene.speed(speed)\n\t    result = abs(orig_duration / speed - scene.duration)\n\t    assert result / orig_duration < 0.01\n", "def test_speed_6_long():\n\t    speed = 10.0\n\t    scene = Scene()\n\t    scene.parse_content(LONG_FILE_CONTENT)\n\t    orig_duration = scene.duration\n\t    scene.speed(speed)\n\t    result = abs(orig_duration / speed - scene.duration)\n\t    assert result / orig_duration < 0.01\n\tdef test_speed_7():\n\t    speed = 0.10\n", "    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.speed(speed, start=4.19)\n\t    result = scene.duration\n\t    assert result == 23.618142\n\tdef test_speed_8():\n\t    speed = 0.10\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.speed(speed, end=1.45)\n", "    result = scene.duration\n\t    assert result == 19.311183\n\tdef test_speed_9():\n\t    speed = 0.10\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.speed(speed, start=5.0, end=1.0)\n\t    result = scene.duration\n\t    assert result == 6.135993\n\tdef test_speed_10():\n", "    speed = 0.10\n\t    scene = Scene()\n\t    scene.parse_content(SHORT_FILE_CONTENT)\n\t    scene.speed(speed, start=2.8, end=3.9)\n\t    result = scene.duration\n\t    assert result == 16.109784\n"]}
{"filename": "tests/files/__init__.py", "chunked_list": []}
{"filename": "asciinema_scene/__init__.py", "chunked_list": []}
{"filename": "asciinema_scene/sciine.py", "chunked_list": ["import importlib.metadata\n\tfrom collections.abc import Callable\n\tfrom functools import wraps\n\tfrom pprint import pformat\n\tfrom typing import Any\n\timport click\n\tfrom .scenelib.scene import Scene\n\tfrom .scenelib.utils import SceneStdinError\n\t__version__ = importlib.metadata.version(\"asciinema_scene\")\n\tinput_option = click.option(\n", "    \"--input\",\n\t    \"-i\",\n\t    \"input_file\",\n\t    type=click.Path(exists=True),\n\t    help=\"Input .cast file, default is stdin.\",\n\t)\n\toutput_option = click.option(\n\t    \"--output\",\n\t    \"-o\",\n\t    \"output_file\",\n", "    type=click.Path(),\n\t    help=\"Output .cast file, default is stdout.\",\n\t)\n\tstart_option = click.option(\n\t    \"--start\",\n\t    \"-s\",\n\t    type=float,\n\t    help=\"Start timecode (sec), default is 0.0.\",\n\t)\n\tend_option = click.option(\n", "    \"--end\",\n\t    \"-e\",\n\t    type=float,\n\t    help=\"End timecode (sec), default is EOF.\",\n\t)\n\tadjust_option = click.option(\n\t    \"--adjust\",\n\t    \"-a\",\n\t    is_flag=True,\n\t    default=False,\n", "    help=\"Adjust durations of frames at precise cut values.\",\n\t)\n\tdef stdin_timeout_handler(function: Callable) -> Callable:\n\t    @wraps(function)\n\t    def wrapped(*args: list[Any], **kwargs: dict[str, Any]) -> Any:\n\t        try:\n\t            function(*args, **kwargs)\n\t        except SceneStdinError:\n\t            print(\"Timeout while waiting for STDIN input.\\n\")\n\t            ctx = click.get_current_context()\n", "            click.echo(ctx.get_help())\n\t            ctx.exit()\n\t    return wrapped\n\t@click.group(invoke_without_command=True, no_args_is_help=True)\n\t@click.version_option(version=__version__)\n\tdef cli() -> None:\n\t    pass\n\t@cli.command(\"status\")\n\t@stdin_timeout_handler\n\t@input_option\n", "def info_cmd(input_file: str | None) -> None:\n\t    \"\"\"Print informations about the content (duration, ...).\"\"\"\n\t    scene = Scene.parse(input_file)\n\t    print(scene.info)\n\t@cli.command(\"header\")\n\t@stdin_timeout_handler\n\t@input_option\n\tdef header_cmd(input_file: str | None) -> None:\n\t    \"\"\"Print the header field of the content.\"\"\"\n\t    scene = Scene.parse(input_file)\n", "    print(pformat(scene.header))\n\t@cli.command(\"show\")\n\t@stdin_timeout_handler\n\t@start_option\n\t@end_option\n\t@click.option(\n\t    \"--lines\",\n\t    \"-l\",\n\t    type=int,\n\t    help=\"Number of lines to show.\",\n", ")\n\t@click.option(\n\t    \"--precise\",\n\t    \"-p\",\n\t    is_flag=True,\n\t    default=False,\n\t    help=\"Show all digits of time codes.\",\n\t)\n\t@click.option(\n\t    \"--text\",\n", "    \"-t\",\n\t    \"as_str\",\n\t    is_flag=True,\n\t    default=False,\n\t    help=\"Show message field as plain text.\",\n\t)\n\t@input_option\n\tdef show_cmd(\n\t    start: float | None,\n\t    end: float | None,\n", "    lines: int | None,\n\t    precise: bool,\n\t    as_str: bool,\n\t    input_file: str | None,\n\t) -> None:\n\t    \"\"\"Print detail of frames, from START to END (max LINES).\n\t    Each line prints the timecode, duration and text of the frame.\n\t    If no START timecode is provided, start from the beginning.\n\t    If no END timecode is provided, display all lines until the end,\n\t    or LINES lines\n", "    \"\"\"\n\t    scene = Scene.parse(input_file)\n\t    scene.show(\n\t        start=start,\n\t        end=end,\n\t        max_lines=lines,\n\t        precise=precise,\n\t        as_str=as_str,\n\t    )\n\t@cli.command(\"cut\")\n", "@stdin_timeout_handler\n\t@start_option\n\t@end_option\n\t@adjust_option\n\t@input_option\n\t@output_option\n\tdef cut_cmd(\n\t    start: float | None,\n\t    end: float | None,\n\t    adjust: bool,\n", "    input_file: str | None,\n\t    output_file: str | None,\n\t) -> None:\n\t    \"\"\"Cut content between START and END timecodes.\n\t    If no START timecode is provided, cut from the beginning.\n\t    If no END timecode is provided, cut until the end.\n\t    \"\"\"\n\t    scene = Scene.parse(input_file)\n\t    scene.cut_frames(start=start, end=end, adjust=adjust)\n\t    scene.dump(output_file)\n", "@cli.command(\"copy\")\n\t@stdin_timeout_handler\n\t@start_option\n\t@end_option\n\t@input_option\n\t@output_option\n\tdef copy_cmd(\n\t    start: float | None,\n\t    end: float | None,\n\t    input_file: str | None,\n", "    output_file: str | None,\n\t    adjust: bool = False,\n\t) -> None:\n\t    \"\"\"Copy content between START and END timecodes.\"\"\"\n\t    scene = Scene.parse(input_file)\n\t    scene.copy(start=start, end=end, adjust=adjust)\n\t    scene.dump(output_file)\n\t@cli.command(\"speed\")\n\t@stdin_timeout_handler\n\t@click.argument(\"speed\", required=True, type=float)\n", "@start_option\n\t@end_option\n\t@input_option\n\t@output_option\n\tdef speed_cmd(\n\t    speed: float,\n\t    start: float | None,\n\t    end: float | None,\n\t    input_file: str | None,\n\t    output_file: str | None,\n", ") -> None:\n\t    \"\"\"Change the speed of the screen cast.\n\t    SPEED is the factor of acceleration. Use number below 1.0\n\t    to to slow down.\n\t    If no START timecode is provided, modify speed from the beginning.\n\t    If no END timecode is provided, modify speed until the end.\n\t    \"\"\"\n\t    scene = Scene.parse(input_file)\n\t    scene.speed(speed, start=start, end=end)\n\t    scene.dump(output_file)\n", "@cli.command(\"maximum\")\n\t@stdin_timeout_handler\n\t@click.argument(\"duration\", required=True, type=float)\n\t@start_option\n\t@end_option\n\t@input_option\n\t@output_option\n\tdef maximum_cmd(\n\t    duration: float,\n\t    start: float | None,\n", "    end: float | None,\n\t    input_file: str | None,\n\t    output_file: str | None,\n\t) -> None:\n\t    \"\"\"Set maximum duration of each frame.\n\t    The duration of frames will be limited to DURATION seconds,\n\t    the timecodes will be adjusted accordingly.\n\t    If no START timecode is provided, apply from the beginning.\n\t    If no END timecode is provided, apply until the end.\n\t    \"\"\"\n", "    scene = Scene.parse(input_file)\n\t    scene.maximum(duration, start=start, end=end)\n\t    scene.dump(output_file)\n\t@cli.command(\"minimum\")\n\t@stdin_timeout_handler\n\t@click.argument(\"duration\", required=True, type=float)\n\t@start_option\n\t@end_option\n\t@input_option\n\t@output_option\n", "def minimum_cmd(\n\t    duration: float,\n\t    start: float | None,\n\t    end: float | None,\n\t    input_file: str | None,\n\t    output_file: str | None,\n\t) -> None:\n\t    \"\"\"Set minimum duration of each frame.\n\t    The minimum duration of frames will be set to DURATION seconds,\n\t    the timecodes will be adjusted accordingly.\n", "    If no START timecode is provided, apply from the beginning.\n\t    If no END timecode is provided, apply until the end.\n\t    \"\"\"\n\t    scene = Scene.parse(input_file)\n\t    scene.minimum(duration, start=start, end=end)\n\t    scene.dump(output_file)\n\t@cli.command(\"quantize\")\n\t@stdin_timeout_handler\n\t@click.argument(\"range_min\", required=True, type=float)\n\t@click.argument(\"range_max\", required=True, type=float)\n", "@click.argument(\"duration\", required=True, type=float)\n\t@start_option\n\t@end_option\n\t@input_option\n\t@output_option\n\tdef quantize_cmd(\n\t    range_min: float,\n\t    range_max: float,\n\t    duration: float,\n\t    start: float | None,\n", "    end: float | None,\n\t    input_file: str | None,\n\t    output_file: str | None,\n\t) -> None:\n\t    \"\"\"Set the duration of frames in duration range to DURATION.\n\t    Set the duration of frames to DURATION if their current\n\t    duration is between RANGE_MIN and RANGE_MAX.\n\t    If no START timecode is provided, apply from the beginning.\n\t    If no END timecode is provided, apply until the end.\n\t    \"\"\"\n", "    scene = Scene.parse(input_file)\n\t    scene.quantize(range_min, range_max, duration, start=start, end=end)\n\t    scene.dump(output_file)\n\t@cli.command(\"insert\")\n\t@stdin_timeout_handler\n\t@click.argument(\"timecode\", required=True, type=float)\n\t@click.argument(\"duration\", required=True, type=float)\n\t@click.argument(\"text\", required=True, type=str)\n\t@click.argument(\"etype\", required=False, type=str)\n\t@input_option\n", "@output_option\n\tdef insert_cmd(\n\t    timecode: float,\n\t    duration: float,\n\t    text: str,\n\t    etype: str,\n\t    input_file: str | None,\n\t    output_file: str | None,\n\t) -> None:\n\t    \"\"\"Insert a frame at the TIMECODE position.\n", "    The frame will display TEXT during DURATION seconds. By default\n\t    the event type ETYPE is set to \"o\".\n\t    \"\"\"\n\t    scene = Scene.parse(input_file)\n\t    if not etype:\n\t        etype = \"o\"\n\t    scene.insert(timecode, duration, text, etype)\n\t    scene.dump(output_file)\n\t@cli.command(\"delete\")\n\t@stdin_timeout_handler\n", "@click.argument(\"timecode\", required=True, type=float)\n\t@input_option\n\t@output_option\n\tdef delete_cmd(\n\t    timecode: float,\n\t    input_file: str | None,\n\t    output_file: str | None,\n\t) -> None:\n\t    \"\"\"Delete the frame with timecode >= TIMECODE.\"\"\"\n\t    scene = Scene.parse(input_file)\n", "    scene.delete(timecode)\n\t    scene.dump(output_file)\n\t@cli.command(\"replace\")\n\t@stdin_timeout_handler\n\t@click.argument(\"timecode\", required=True, type=float)\n\t@click.argument(\"text\", required=True, type=str)\n\t@input_option\n\t@output_option\n\tdef replace_cmd(\n\t    timecode: float,\n", "    text: str,\n\t    input_file: str | None,\n\t    output_file: str | None,\n\t) -> None:\n\t    \"\"\"Replace the text of frame with timecode >= TIMECODE by TEXT.\"\"\"\n\t    scene = Scene.parse(input_file)\n\t    scene.replace(timecode, text)\n\t    scene.dump(output_file)\n\t@cli.command(\"include\")\n\t@stdin_timeout_handler\n", "@click.argument(\"timecode\", required=True, type=float)\n\t@click.argument(\"include_file\", type=click.Path(exists=True), required=True)\n\t@input_option\n\t@output_option\n\tdef include_cmd(\n\t    timecode: float,\n\t    include_file: str,\n\t    input_file: str | None,\n\t    output_file: str | None,\n\t) -> None:\n", "    \"\"\"Include the content of a .cast file at the timecode position.\n\t    All frames of the INCLUDE_FILE .cast file will be copied in the\n\t    current screen cast. The timecodes will be adjusted as required.\n\t    \"\"\"\n\t    scene = Scene.parse(input_file)\n\t    scene.include(timecode, include_file)\n\t    scene.dump(output_file)\n"]}
{"filename": "asciinema_scene/scenelib/frame.py", "chunked_list": ["from __future__ import annotations\n\timport json\n\tfrom math import floor\n\tfrom typing import Any\n\tfrom .constants import PRECISION, PRECISION_DECI\n\tclass Frame:\n\t    __slots__ = [\"timecode\", \"duration\", \"tpe\", \"text\"]\n\t    timecode: int\n\t    duration: int\n\t    tpe: str\n", "    text: str\n\t    def __init__(self) -> None:\n\t        self.timecode = 0\n\t        self.duration = 0\n\t        self.tpe = \"\"\n\t        self.text = \"\"\n\t    def __str__(self) -> str:\n\t        return self.dumps()\n\t    @classmethod\n\t    def parse(cls, frame_list: list[Any]) -> Frame:\n", "        frame = cls()\n\t        frame.timecode = int(round(frame_list[0] * PRECISION))\n\t        frame.tpe = frame_list[1]\n\t        frame.text = frame_list[2]\n\t        return frame\n\t    @property\n\t    def tc_float(self) -> float:\n\t        return round(self.timecode / PRECISION, PRECISION_DECI)  # type: ignore\n\t    @property\n\t    def tc_floor3(self) -> float:\n", "        return floor(self.tc_float * 1000) / 1000\n\t    @property\n\t    def tc_floor6(self) -> float:\n\t        return floor(self.tc_float * PRECISION) / PRECISION  # type: ignore\n\t    @property\n\t    def dur_float(self) -> float:\n\t        return round(self.duration / PRECISION, PRECISION_DECI)  # type: ignore\n\t    def as_list(self) -> list[Any]:\n\t        return [self.tc_float, self.tpe, self.text]\n\t    @property\n", "    def timecode_duration_text_short_str(self) -> str:\n\t        return f\"{self.tc_floor3:7.3f}\\u2502{self.dur_float:5.2f}\\u2502 {self.text.strip()}\\n\"\n\t    @property\n\t    def timecode_duration_text_long_str(self) -> str:\n\t        return f\"{self.tc_floor6:10.6f}\\u2502{self.dur_float:9.6f}\\u2502 {self.text.strip()}\\n\"\n\t    @property\n\t    def timecode_duration_text_short_repr(self) -> str:\n\t        return f\"{self.tc_floor3:7.3f}\\u2502{self.dur_float:5.2f}\\u2502 {self.text!r}\\n\"\n\t    @property\n\t    def timecode_duration_text_long_repr(self) -> str:\n", "        return (\n\t            f\"{self.tc_floor6:10.6f}\\u2502{self.dur_float:9.6f}\\u2502 {self.text!r}\\n\"\n\t        )\n\t    def set_duration(self, seconds: float) -> None:\n\t        self.duration = int(round(seconds * PRECISION))\n\t    def dumps(self) -> str:\n\t        return json.dumps(\n\t            self.as_list(),\n\t            ensure_ascii=True,\n\t            check_circular=False,\n", "        )\n\t    def copy(self) -> Frame:\n\t        frame = Frame()\n\t        frame.timecode = self.timecode\n\t        frame.duration = self.duration\n\t        frame.tpe = self.tpe\n\t        frame.text = self.text\n\t        return frame\n"]}
{"filename": "asciinema_scene/scenelib/__init__.py", "chunked_list": []}
{"filename": "asciinema_scene/scenelib/utils.py", "chunked_list": ["import selectors\n\timport sys\n\tfrom .constants import STDIN_TIMEOUT\n\tclass SceneStdinError(Exception):\n\t    pass\n\tdef detect_stdin_timeout() -> None:\n\t    selector = selectors.DefaultSelector()\n\t    selector.register(sys.stdin, selectors.EVENT_READ)\n\t    something = selector.select(timeout=STDIN_TIMEOUT)\n\t    if not something:\n", "        raise SceneStdinError\n\t    selector.close()\n"]}
{"filename": "asciinema_scene/scenelib/constants.py", "chunked_list": ["PRECISION_DECI = 6\n\tPRECISION = 10**PRECISION_DECI\n\tINFINITE_DURATION = 1e10\n\tSTDIN_TIMEOUT = 0.5\n"]}
{"filename": "asciinema_scene/scenelib/scene.py", "chunked_list": ["from __future__ import annotations\n\timport sys\n\tfrom pathlib import Path\n\tfrom .constants import INFINITE_DURATION, PRECISION\n\tfrom .frame import Frame\n\tfrom .scene_content import SceneContent\n\tclass Scene(SceneContent):\n\t    @classmethod\n\t    def parse(cls, input_file: str | Path | None = None) -> Scene:\n\t        content = SceneContent.parse(input_file)\n", "        scene = Scene()\n\t        scene.input_file = content.input_file\n\t        scene.header = content.header\n\t        scene.frames = content.frames\n\t        return scene\n\t    def _split_parts(\n\t        self,\n\t        tcode_start: int,\n\t        tcode_end: int,\n\t    ) -> tuple[int, int]:\n", "        idx1 = 0\n\t        for frame in self.frames:\n\t            if frame.timecode < tcode_start:\n\t                idx1 += 1\n\t                continue\n\t            break\n\t        idx2 = idx1\n\t        for frame in self.frames[idx1:]:\n\t            if frame.timecode < tcode_end:\n\t                idx2 += 1\n", "                continue\n\t            break\n\t        return idx1, idx2\n\t    def select_frames(self, start: int, end: int) -> list[Frame]:\n\t        idx1, idx2 = self._split_parts(start, end)\n\t        return self.frames[idx1:idx2]\n\t    @staticmethod\n\t    def start_end(start: float | None, end: float | None) -> tuple[int, int]:\n\t        tcode_start = int(start * PRECISION) if start and start > 0.0 else 0\n\t        if not end or end < 0.0:\n", "            end = INFINITE_DURATION\n\t        tcode_end = max(int(end * PRECISION), tcode_start)\n\t        return tcode_start, tcode_end\n\t    def find_frame_idx(self, timecode: float) -> int:\n\t        tcode_frame = int(timecode * PRECISION)\n\t        idx = 0\n\t        for frame in self.frames:\n\t            if frame.timecode < tcode_frame:\n\t                idx += 1\n\t                continue\n", "            return idx\n\t        return -1\n\t    def show(\n\t        self,\n\t        start: float | None = None,\n\t        end: float | None = None,\n\t        max_lines: int | None = None,\n\t        precise: bool = False,\n\t        as_str: bool = False,\n\t    ) -> None:\n", "        if not max_lines or max_lines < 0:\n\t            max_lines = 0\n\t        tcode_start, tcode_end = self.start_end(start, end)\n\t        if precise:\n\t            if as_str:\n\t                prop = \"timecode_duration_text_long_str\"\n\t            else:\n\t                prop = \"timecode_duration_text_long_repr\"\n\t        else:\n\t            if as_str:\n", "                prop = \"timecode_duration_text_short_str\"\n\t            else:\n\t                prop = \"timecode_duration_text_short_repr\"\n\t        frames = self.select_frames(tcode_start, tcode_end)\n\t        if max_lines:\n\t            frames = frames[:max_lines]\n\t        for frame in frames:\n\t            sys.stdout.write(getattr(frame, prop))\n\t    def _cut_frames_adjust(self, tcode_start: int, tcode_end: int) -> list[Frame]:\n\t        keep_start = []\n", "        for frame in self.frames:\n\t            if frame.timecode >= tcode_start:\n\t                break\n\t            keep_start.append(frame)\n\t        if keep_start:\n\t            last = keep_start[-1]\n\t            if last.timecode + last.duration > tcode_start:\n\t                if last.timecode + last.duration >= tcode_end:\n\t                    last.duration -= tcode_end - tcode_start\n\t                    return keep_start + self.frames[len(keep_start) :]\n", "                else:\n\t                    last.duration = tcode_start - last.timecode\n\t        keep_end = []\n\t        to_cut = None\n\t        for frame in self.frames[len(keep_start) :]:\n\t            if frame.timecode < tcode_end:\n\t                to_cut = frame\n\t                continue\n\t            keep_end.append(frame)\n\t        if to_cut:\n", "            to_cut.duration = to_cut.duration + to_cut.timecode - tcode_end\n\t            if to_cut.duration > 0:\n\t                keep_end.insert(0, to_cut)\n\t        return keep_start + keep_end\n\t    def _cut_frames_basic(self, tcode_start: int, tcode_end: int) -> list[Frame]:\n\t        idx1, idx2 = self._split_parts(tcode_start, tcode_end)\n\t        return self.frames[:idx1] + self.frames[idx2:]\n\t    def set_timecodes(self) -> None:\n\t        if not self.frames:\n\t            return\n", "        first = self.frames[0]\n\t        next_tc = first.timecode + first.duration\n\t        for frame in self.frames[1:]:\n\t            frame.timecode = next_tc\n\t            next_tc = frame.timecode + frame.duration\n\t    def cut_frames(\n\t        self,\n\t        start: float | None = None,\n\t        end: float | None = None,\n\t        adjust: bool = False,\n", "    ) -> None:\n\t        tcode_start, tcode_end = self.start_end(start, end)\n\t        if adjust:\n\t            keep = self._cut_frames_adjust(tcode_start, tcode_end)\n\t        else:\n\t            keep = self._cut_frames_basic(tcode_start, tcode_end)\n\t        self.frames = keep\n\t        self.set_timecodes()\n\t        self.post_normalize()\n\t    def _extract_frames_adjust(\n", "        self,\n\t        tcode_start: int,\n\t        tcode_end: int,\n\t    ) -> list[Frame]:\n\t        if tcode_start > 0:\n\t            self.frames = self._cut_frames_adjust(0, tcode_start - 1)\n\t        self.frames = self._cut_frames_adjust(tcode_end, int(1e16))\n\t        return self.frames\n\t    def extract_frames(\n\t        self,\n", "        tcode_start: int,\n\t        tcode_end: int,\n\t        adjust: bool = False,\n\t    ) -> list[Frame]:\n\t        # destructive\n\t        if adjust:\n\t            return self._extract_frames_adjust(tcode_start, tcode_end)\n\t        else:\n\t            return self.select_frames(tcode_start, tcode_end)\n\t    def copy(\n", "        self,\n\t        start: float | None = None,\n\t        end: float | None = None,\n\t        adjust: bool = False,\n\t    ) -> None:\n\t        tcode_start, tcode_end = self.start_end(start, end)\n\t        self.frames = self.extract_frames(tcode_start, tcode_end, adjust=adjust)\n\t        self.set_timecodes()\n\t        self.post_normalize()\n\t    def speed(\n", "        self,\n\t        speed: float = 1.0,\n\t        start: float | None = None,\n\t        end: float | None = None,\n\t    ) -> None:\n\t        if speed <= 0.0:\n\t            raise ValueError(speed)\n\t        factor = 1.0 / speed\n\t        self.pre_normalize()\n\t        tcode_start, tcode_end = self.start_end(start, end)\n", "        idx1, idx2 = self._split_parts(tcode_start, tcode_end)\n\t        for frame in self.frames[idx1:idx2]:\n\t            frame.duration = int(round(frame.duration * factor))\n\t        self.set_timecodes()\n\t        self.post_normalize()\n\t    def quantize(\n\t        self,\n\t        mini: float,\n\t        maxi: float,\n\t        duration: float,\n", "        start: float | None = None,\n\t        end: float | None = None,\n\t    ) -> None:\n\t        assert maxi >= mini  # noqa: S101\n\t        assert duration >= 0.0  # noqa: S101\n\t        mini_duration = int(mini * PRECISION)\n\t        maxi_duration = int(maxi * PRECISION)\n\t        new_duration = int(duration * PRECISION)\n\t        self.pre_normalize()\n\t        tcode_start, tcode_end = self.start_end(start, end)\n", "        idx1, idx2 = self._split_parts(tcode_start, tcode_end)\n\t        for frame in self.frames[idx1:idx2]:\n\t            if mini_duration <= frame.duration <= maxi_duration:\n\t                frame.duration = new_duration\n\t        self.set_timecodes()\n\t        self.post_normalize()\n\t    def maximum(\n\t        self,\n\t        maxi: float,\n\t        start: float | None = None,\n", "        end: float | None = None,\n\t    ) -> None:\n\t        self.quantize(maxi, INFINITE_DURATION, maxi, start, end)\n\t    def minimum(\n\t        self,\n\t        mini: float,\n\t        start: float | None = None,\n\t        end: float | None = None,\n\t    ) -> None:\n\t        self.quantize(0.0, mini, mini, start, end)\n", "    def _append_frame(self, new_frame: Frame) -> None:\n\t        \"\"\"Special case: append case to end, maybe remove last \"\\r\\n\"\"\"\n\t        if self.frames:\n\t            last = self.frames[-1]\n\t            if last.tpe == \"o\" and last.text == \"\\r\\n\":\n\t                self.frames = self.frames[:-1]\n\t        self.frames.append(new_frame)\n\t    def insert(\n\t        self,\n\t        timecode: float,\n", "        duration: float,\n\t        text: str,\n\t        tpe: str = \"o\",\n\t    ) -> None:\n\t        assert timecode >= 0.0  # noqa: S101\n\t        assert duration >= 0.0  # noqa: S101\n\t        new_frame = Frame.parse([timecode, tpe, text])\n\t        new_frame.set_duration(duration)\n\t        tc = new_frame.timecode\n\t        if not self.frames or tc > self.frames[-1].timecode:\n", "            self._append_frame(new_frame)\n\t        else:\n\t            if self.frames:\n\t                for index, frame in enumerate(self.frames):  # pragma: no cover\n\t                    if frame.timecode >= tc:\n\t                        self.frames.insert(index, new_frame)\n\t                        break\n\t        self.set_timecodes()\n\t        self.post_normalize()\n\t    def delete(self, timecode: float) -> None:\n", "        assert timecode >= 0.0  # noqa: S101\n\t        idx = self.find_frame_idx(timecode)\n\t        if idx < 0:\n\t            return\n\t        del self.frames[idx]\n\t        self.set_timecodes()\n\t        self.post_normalize()\n\t    def replace(self, timecode: float, text: str) -> None:\n\t        assert timecode >= 0.0  # noqa: S101\n\t        idx = self.find_frame_idx(timecode)\n", "        if idx < 0:\n\t            return\n\t        frame = self.frames[idx]\n\t        frame.text = text\n\t        self.post_normalize()\n\t    def include_scene(self, tcode_insert: int, inc_scene: Scene) -> None:\n\t        if not self.frames or tcode_insert > self.frames[-1].timecode:\n\t            self.frames.extend(inc_scene.frames)\n\t        else:\n\t            for index, frame in enumerate(self.frames):  # pragma: no cover\n", "                if frame.timecode >= tcode_insert:\n\t                    new_frames = (\n\t                        self.frames[:index] + inc_scene.frames + self.frames[index:]\n\t                    )\n\t                    self.frames = new_frames\n\t                    break\n\t        self.set_timecodes()\n\t        self.post_normalize()\n\t    def include(self, timecode: float, inc_file: str | Path) -> None:\n\t        assert timecode >= 0.0  # noqa: S101\n", "        tcode_insert = int(round(timecode * PRECISION))\n\t        inc_scene = Scene.parse(inc_file)\n\t        self.include_scene(tcode_insert, inc_scene)\n"]}
{"filename": "asciinema_scene/scenelib/scene_content.py", "chunked_list": ["from __future__ import annotations\n\timport gzip\n\timport json\n\timport sys\n\tfrom copy import deepcopy\n\tfrom datetime import datetime, timezone\n\tfrom pathlib import Path\n\tfrom time import time\n\tfrom typing import Any\n\tfrom zipfile import ZipFile\n", "from .frame import Frame\n\tfrom .utils import detect_stdin_timeout\n\tclass SceneContent:\n\t    def __init__(self) -> None:\n\t        self.input_file: str = \"string\"\n\t        self.header: dict[str, Any] = {}\n\t        self.frames: list[Frame] = []\n\t    @staticmethod\n\t    def _decode(line: str) -> Any:\n\t        try:\n", "            return json.loads(line)\n\t        except json.decoder.JSONDecodeError:\n\t            print(\"---- Error ---------------------\")\n\t            print(line)\n\t            print(\"--------------------------------\")\n\t            raise\n\t    def __str__(self) -> str:\n\t        return (\n\t            f\"<Scene {self.input_file!r}, {self.date}, \"\n\t            f\"Frames:{self.length}, Duration:{self.duration:.3f}>\"\n", "        )\n\t    def parse_content(self, raw_content: str) -> None:\n\t        for line in raw_content.split(\"\\n\"):\n\t            if not line:\n\t                continue\n\t            frame = self._decode(line)\n\t            if isinstance(frame, list):\n\t                self.frames.append(Frame.parse(frame))\n\t                continue\n\t            if not self.header and isinstance(frame, dict):\n", "                self.header = frame\n\t        self.pre_normalize()\n\t    @classmethod\n\t    def from_file(cls, input_file: str | Path) -> SceneContent:\n\t        scene = SceneContent()\n\t        path = Path(input_file)\n\t        scene.input_file = path.name\n\t        if path.suffix == \".gz\":\n\t            scene.parse_content(gzip.decompress(path.read_bytes()).decode(\"utf8\"))\n\t        elif path.suffix == \".zip\":\n", "            name = path.name[:-4]\n\t            zf = ZipFile(path, \"r\")\n\t            scene.parse_content(zf.read(name).decode(\"utf8\"))\n\t        else:\n\t            scene.parse_content(path.read_text(encoding=\"utf8\"))\n\t        return scene\n\t    @classmethod\n\t    def parse(cls, input_file: str | Path | None = None) -> SceneContent:\n\t        if input_file:\n\t            return cls.from_file(input_file)\n", "        detect_stdin_timeout()\n\t        scene = SceneContent()\n\t        scene.input_file = \"sys.stdin\"\n\t        scene.parse_content(\"\\n\".join(list(sys.stdin)))\n\t        return scene\n\t    def duplicate(self) -> SceneContent:\n\t        duplicate = SceneContent()\n\t        duplicate.header = deepcopy(self.header)\n\t        duplicate.frames = [line.copy() for line in self.frames]\n\t        return duplicate\n", "    def set_timestamp(self) -> None:\n\t        self.header[\"timestamp\"] = int(time())\n\t    @property\n\t    def info(self) -> str:\n\t        return \"\\n\".join(\n\t            (\n\t                f\"Input: {self.input_file}\",\n\t                f\"Date: {self.date}\",\n\t                f\"Frames: {self.length}\",\n\t                f\"Duration: {self.duration:.6f}\",\n", "            )\n\t        )\n\t    @property\n\t    def date(self) -> str:\n\t        timestamp = self.header.get(\"timestamp\", 0)\n\t        return datetime.fromtimestamp(timestamp, timezone.utc).isoformat(\" \")\n\t    @property\n\t    def length(self) -> int:\n\t        return len(self.frames)\n\t    @property\n", "    def duration(self) -> float:\n\t        if self.frames:\n\t            last = self.frames[-1]\n\t            return last.tc_float\n\t        else:\n\t            return 0.0\n\t    def dumps(self) -> str:\n\t        content = []\n\t        content.append(\n\t            json.dumps(\n", "                self.header,\n\t                ensure_ascii=True,\n\t                check_circular=False,\n\t            )\n\t        )\n\t        content.extend(frame.dumps() for frame in self.frames)\n\t        content.append(\"\")\n\t        return \"\\n\".join(content)\n\t    def dump(self, output_file: str | Path | None = None) -> None:\n\t        if output_file:\n", "            Path(output_file).write_text(self.dumps(), encoding=\"utf8\")\n\t        else:\n\t            sys.stdout.write(self.dumps())\n\t            sys.stdout.flush()\n\t    def _normalize_t0(self) -> None:\n\t        if not self.frames:\n\t            return\n\t        first = self.frames[0]\n\t        tc0 = first.timecode\n\t        if tc0 == 0:\n", "            return\n\t        for frame in self.frames:\n\t            frame.timecode -= tc0\n\t    def _normalize_crlf(self) -> None:\n\t        if not self.frames:\n\t            return\n\t        last = self.frames[-1]\n\t        if not last.text.endswith(\"\\r\\n\"):\n\t            self.frames.append(\n\t                Frame.parse([last.tc_float + last.dur_float, \"o\", \"\\r\\n\"])\n", "            )\n\t    def pre_normalize(self) -> None:\n\t        self._normalize_crlf()\n\t        self._normalize_t0()\n\t        self.set_durations()\n\t    def post_normalize(self) -> None:\n\t        self._normalize_crlf()\n\t        self._normalize_t0()\n\t        self.set_durations()\n\t        self.set_timestamp()\n", "    def set_durations(self) -> None:\n\t        if not self.frames:\n\t            return\n\t        last = self.frames[-1]\n\t        last.duration = 0  # default for last message (0 millisec)\n\t        next_tc = last.timecode\n\t        for frame in reversed(self.frames[:-1]):\n\t            frame.duration, next_tc = next_tc - frame.timecode, frame.timecode\n"]}
