{"filename": "setup.py", "chunked_list": ["import re\n\timport setuptools\n\twith open(\"README.md\", \"r\") as f:\n\t    LONG_DESCRIPTION = f.read()\n\twith open(\"requirements.txt\", \"r\") as f:\n\t    REQUIREMENTS = f.read().splitlines()\n\tversion = \"\"\n\twith open(\"kick/__init__.py\") as f:\n\t    version = re.search(\n\t        r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', f.read(), re.MULTILINE\n", "    ).group(  # type: ignore\n\t        1\n\t    )\n\tif not version:\n\t    raise RuntimeError(\"version is not set\")\n\tif version.endswith((\"a\", \"b\", \"rc\")):\n\t    # append version identifier based on commit count\n\t    try:\n\t        import subprocess\n\t        p = subprocess.Popen(\n", "            [\"git\", \"rev-list\", \"--count\", \"HEAD\"],\n\t            stdout=subprocess.PIPE,\n\t            stderr=subprocess.PIPE,\n\t        )\n\t        out, err = p.communicate()\n\t        if out:\n\t            version += out.decode(\"utf-8\").strip()\n\t        p = subprocess.Popen(\n\t            [\"git\", \"rev-parse\", \"--short\", \"HEAD\"],\n\t            stdout=subprocess.PIPE,\n", "            stderr=subprocess.PIPE,\n\t        )\n\t        out, err = p.communicate()\n\t        if out:\n\t            version += \"+g\" + out.decode(\"utf-8\").strip()\n\t    except Exception:\n\t        pass\n\tsetuptools.setup(\n\t    name=\"kick.py\",\n\t    author=\"cibere\",\n", "    author_email=\"contact@cibere.dev\",\n\t    url=\"https://github.com/cibere/kick.py\",\n\t    project_urls={\n\t        \"Code\": \"https://github.com/cibere/kick.py\",\n\t        \"Issue tracker\": \"https://github.com/cibere/kick.py/issues\",\n\t    },\n\t    version=\"0.0.1\",\n\t    python_requires=\">=3.11\",\n\t    install_requires=REQUIREMENTS,\n\t    packages=[\"kick\"],\n", "    description=\"\",\n\t    long_description=LONG_DESCRIPTION,\n\t    long_description_content_type=\"text/markdown\",\n\t    license=\"MIT\",\n\t)\n"]}
{"filename": "build_docs.py", "chunked_list": ["import glob\n\timport re\n\timport textwrap\n\tfrom copy import copy\n\tfrom typing import Callable, Type\n\timport kick\n\tDOC_STRING_REGEX = re.compile(r\"\\[\\[(?P<what>[^\\]]*)]]\")\n\tDISPLAY_REGEX = re.compile(r\"{{(?P<item>[^}]*)}}\")\n\tSHOW_ALL_REGEX = re.compile(r\"|\\[(?P<item>[^|]*)]|\")\n\tH3_REGEX = re.compile(r\"(?P<text>[a-zA-Z0-9_-]*)<br>\\n-----------\")\n", "CODEBLOCK_REGEX = re.compile(r\"`(?P<code>[^`]*)`\")\n\tHEADER = \"\"\"\n\t<head>\n\t    <link rel=\"stylesheet\" href=\"style.css\">\n\t</head>\"\"\"\n\tRAW_DOCS_DIR = \"raw_docs\"\n\tFINAL_DOCS_DIR = \"docs\"\n\tIGNORE_FORMAT_TEXT = \"!IGNORE-FORMAT\"\n\tdef convert_file(fp: str) -> None:\n\t    before_fp = fp\n", "    after_fp = fp.replace(RAW_DOCS_DIR, FINAL_DOCS_DIR)\n\t    with open(before_fp, \"r\", encoding=\"utf-8\") as f:\n\t        text = f.read()\n\t    if text.splitlines()[0] != IGNORE_FORMAT_TEXT:\n\t        for find in SHOW_ALL_REGEX.findall(text):\n\t            after = \"{{x}}\".replace(\"x\", find) + f\"[[{find}]]\"\n\t            text = text.replace(f\"|[{find}]|\", after)\n\t        # Docstring\n\t        for find in DOC_STRING_REGEX.findall(text):\n\t            try:\n", "                item = eval(f\"kick.{find}\")\n\t                doc = item.__doc__ or \"\"\n\t            except Exception as e:\n\t                pass\n\t            else:\n\t                doc = textwrap.dedent(copy(doc))\n\t                if doc and doc.splitlines()[1].strip() == \"|coro|\":\n\t                    temp = doc.splitlines()\n\t                    temp.pop(0)\n\t                    temp.pop(0)\n", "                    doc = \"\\n\".join(temp)\n\t                ret = []\n\t                for line in doc.splitlines():\n\t                    if line.startswith(\"    \"):\n\t                        line = f'<span style=\"margin-left: 30px\">{line}</span>'\n\t                    line += \"<br>\"\n\t                    ret.append(line)\n\t                text = text.replace(f\"[[{find}]]\", \"\\n\".join(ret))\n\t        for find in DISPLAY_REGEX.findall(text):\n\t            try:\n", "                item = eval(f\"kick.{find}\")\n\t            except Exception as e:\n\t                pass\n\t            else:\n\t                doc = copy(item.__doc__ or \"\")\n\t                class_ = \"\"\n\t                tag = 3\n\t                if doc and doc.splitlines()[1].strip() == \"|coro|\":\n\t                    prefix = \"async def \"\n\t                    temp = doc.splitlines()\n", "                    temp.pop(0)\n\t                    temp.pop(0)\n\t                    doc = \"\\n\".join(temp)\n\t                elif getattr(item, \"__is_decorator__\", False) is True:\n\t                    prefix = \"@\"\n\t                    class_ = \"at\"\n\t                elif isinstance(item, Type):\n\t                    prefix = \"class \"\n\t                    tag = 2\n\t                elif isinstance(item, Callable):\n", "                    prefix = \"def \"\n\t                else:\n\t                    prefix = \"\"\n\t                if prefix and not class_:\n\t                    class_ = prefix.split(\" \")[0]\n\t                after = f\"\"\"\n\t                <a href=\"#{find}\" class=\"h{tag} hidden\" id=\"{find}\">\n\t                    <span class=\"{class_}\">\n\t                        {prefix}\n\t                    </span>\n", "                    {find}\n\t                </a>\n\t                \"\"\"\n\t                text = text.replace(\"{{x}}\".replace(\"x\", find), textwrap.dedent(after))\n\t        for find in H3_REGEX.findall(text):\n\t            item = f\"{find}<br>\\n-----------\"\n\t            text = text.replace(item, f'<span class=\"h4\">{find}</span>')\n\t        # Codeblock hyperlinks\n\t        for find in CODEBLOCK_REGEX.findall(text):\n\t            after = f'<a href=\"#{find}\" class=\"hidden\">`{find}`</a>'\n", "            text = text.replace(f\"`{find}`\", after)\n\t    with open(after_fp, \"w\", encoding=\"utf-8\") as f:\n\t        f.write(f\"{HEADER}\\n{text}\")\n\tfiles = glob.glob(f\"{RAW_DOCS_DIR}/*.md\")\n\tfor file in files:\n\t    print(f\"Starting on {file}...\")\n\t    convert_file(file)\n\t    print(f\"Finished {file}\")\n"]}
{"filename": "kick/emotes.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom .assets import Asset\n\tfrom .object import HTTPDataclass\n\tfrom .utils import cached_property\n\tif TYPE_CHECKING:\n\t    from .types.emotes import EmotePayload\n\t__all__ = (\"Emote\",)\n\tclass Emote(HTTPDataclass[\"EmotePayload\"]):\n\t    \"\"\"\n", "    A dataclass which represents an emote on kick.\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        The emote's id\n\t    is_global: bool\n\t        If the emote is a global emote, or from a channel\n\t    channel_id: int | None\n\t        returns the channel_id the emote is from, or None if global\n\t    name: str\n", "        The emote's name\n\t    subscribers_only: bool\n\t        If you have to be a subscriber of the channel to use it. False for global emotes\n\t    source: `Asset`\n\t        An asset which contains the emote's source.\n\t    \"\"\"\n\t    @property\n\t    def id(self) -> int:\n\t        \"\"\"\n\t        The emote's id\n", "        \"\"\"\n\t        return self._data[\"id\"]\n\t    @cached_property\n\t    def is_global(self) -> bool:\n\t        \"\"\"\n\t        If the emote is a global emote, or from a channel\n\t        \"\"\"\n\t        return bool(self._data[\"channel_id\"])\n\t    @property\n\t    def channel_id(self) -> int | None:\n", "        \"\"\"\n\t        returns the channel_id the emote is from, or None if global\n\t        \"\"\"\n\t        return self._data[\"channel_id\"]\n\t    @property\n\t    def name(self) -> str:\n\t        \"\"\"\n\t        The emote's name\n\t        \"\"\"\n\t        return self._data[\"name\"]\n", "    @property\n\t    def subscribers_only(self) -> bool:\n\t        \"\"\"\n\t        If you have to be a subscriber of the channel to use it. False for global emotes\n\t        \"\"\"\n\t        return self._data[\"subscribers_only\"]\n\t    @cached_property\n\t    def source(self) -> Asset:\n\t        \"\"\"\n\t        An asset which contains the emote's source.\n", "        \"\"\"\n\t        return Asset._from_emote(self.id, http=self.http)\n\t    def __eq__(self, other: object) -> bool:\n\t        return isinstance(other, self.__class__) and other.id == self.id\n\t    def __str__(self) -> str:\n\t        return self.name\n\t    def __repr__(self) -> str:\n\t        return (\n\t            f\"<Emote id={self.id!r} channel_id={self.channel_id!r} name={self.name!r}>\"\n\t        )\n"]}
{"filename": "kick/videos.py", "chunked_list": ["from __future__ import annotations\n\tfrom datetime import datetime\n\tfrom typing import TYPE_CHECKING, Any\n\tfrom kick.assets import Asset\n\tfrom .categories import Category\n\tfrom .object import HTTPDataclass\n\tfrom .utils import cached_property\n\tif TYPE_CHECKING:\n\t    from .types.videos import VideoPayload\n\t__all__ = (\"Video\",)\n", "class Video(HTTPDataclass[\"VideoPayload\"]):\n\t    \"\"\"\n\t    This dataclass represents a video on kick\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        The video's id\n\t    slug: str\n\t        the video's slug\n\t    channel_id: int\n", "        Probably the id of the channel the video is from\n\t    created_at: datetime.datetime\n\t        When the video was created\n\t    updated_at: datetime.datetime\n\t        When the video was last updated\n\t    title: str\n\t        The video's title\n\t    live_stream_id: int\n\t        The id of the live stream the video is from\n\t    thumbnail: `Asset` | None\n", "        The video's thumbnail\n\t    duration: int\n\t        How long the video is in seconds\n\t    language: str\n\t        The language the video is in\n\t    is_mature: bool\n\t        If the video is marked as 18+\n\t    viewer_count: int\n\t        How many people have seen the video\n\t    categories: list[`Category`]\n", "        The categories the video is in\n\t    \"\"\"\n\t    @property\n\t    def id(self) -> int:\n\t        \"\"\"\n\t        The video's id\n\t        \"\"\"\n\t        return self._data[\"id\"]\n\t    @property\n\t    def slug(self) -> str:\n", "        \"\"\"\n\t        the video's slug\n\t        \"\"\"\n\t        return self._data[\"slug\"]\n\t    @property\n\t    def channel_id(self) -> int:\n\t        \"\"\"\n\t        Probably the id of the channel the video is from\n\t        \"\"\"\n\t        return self._data[\"channel_id\"]\n", "    @cached_property\n\t    def created_at(self) -> datetime:\n\t        \"\"\"\n\t        When the video was created\n\t        \"\"\"\n\t        return datetime.fromisoformat(self._data[\"created_at\"])\n\t    @cached_property\n\t    def updated_at(self) -> datetime:\n\t        \"\"\"\n\t        When the video was last updated\n", "        \"\"\"\n\t        return datetime.fromisoformat(self._data[\"video\"][\"updated_at\"])\n\t    @property\n\t    def title(self) -> str:\n\t        \"\"\"\n\t        The video's title\n\t        \"\"\"\n\t        return self._data[\"session_title\"]\n\t    @property\n\t    def live_stream_id(self) -> int:\n", "        \"\"\"\n\t        The id of the live stream the video is from\n\t        \"\"\"\n\t        return self._data[\"video\"][\"live_stream_id\"]\n\t    @property\n\t    def thumbnail(self) -> Asset | None:\n\t        \"\"\"\n\t        The video's thumbnail\n\t        \"\"\"\n\t        return (\n", "            None\n\t            if self._data[\"thumbnail\"] is None\n\t            else Asset._from_asset_src(data=self._data[\"thumbnail\"], http=self.http)\n\t        )\n\t    @property\n\t    def duration(self) -> int:\n\t        \"\"\"\n\t        How long the video is in seconds\n\t        \"\"\"\n\t        return self._data[\"duration\"]\n", "    @property\n\t    def language(self) -> str:\n\t        \"\"\"\n\t        The language the video is in\n\t        \"\"\"\n\t        return self._data[\"language\"]\n\t    @property\n\t    def is_mature(self) -> bool:\n\t        \"\"\"\n\t        If the video is marked as 18+\n", "        \"\"\"\n\t        return self._data[\"is_mature\"]\n\t    @property\n\t    def viewer_count(self) -> int:\n\t        \"\"\"\n\t        How many people have seen the video\n\t        \"\"\"\n\t        return self._data[\"viewer_count\"]\n\t    @cached_property\n\t    def categories(self) -> list[Category]:\n", "        \"\"\"\n\t        The categories the video is in\n\t        \"\"\"\n\t        return [Category(data=c, http=self.http) for c in self._data[\"categories\"]]\n\t    def __repr__(self) -> str:\n\t        return (\n\t            f\"<Video id={self.id!r} slug={self.slug!r} channel_id={self.channel_id!r}>\"\n\t        )\n"]}
{"filename": "kick/chatroom.py", "chunked_list": ["from __future__ import annotations\n\tfrom datetime import datetime\n\tfrom typing import TYPE_CHECKING, AsyncIterator, Optional\n\tfrom kick.http import HTTPClient\n\tfrom .emotes import Emote\n\tfrom .enums import ChatroomChatMode\n\tfrom .object import HTTPDataclass\n\tfrom .polls import Poll\n\tfrom .users import PartialUser\n\tfrom .utils import cached_property\n", "if TYPE_CHECKING:\n\t    from .chatter import Chatter\n\t    from .types.chatroom import BanEntryPayload\n\t    from .types.user import ChatroomPayload\n\t    from .users import User\n\t__all__ = (\"Chatroom\", \"BanEntry\", \"PartialChatroom\")\n\tclass BanEntry(HTTPDataclass[\"BanEntryPayload\"]):\n\t    \"\"\"\n\t    A dataclass which represents a ban entry on kick.\n\t    This includes timeouts.\n", "    Attributes\n\t    -----------\n\t    reason: str\n\t        The reason for the ban/timeout\n\t    is_permanent: bool\n\t        Whether the ban is permanent. True == ban, false == timeout\n\t    user: `PartialUser`\n\t        The user the action was towards\n\t    banned_by: `PartialUser`\n\t        The responsible mod\n", "    expires_at: datetime.datetime | None\n\t        when the timeout expires at. None for a ban\n\t    banned_at: datetime.datetime\n\t        When the action happened\n\t    chatroom: Chatroom\n\t        The chatroom the action happened in\n\t    \"\"\"\n\t    chatroom: Chatroom | PartialChatroom\n\t    @property\n\t    def reason(self) -> str:\n", "        \"\"\"\n\t        The reason for the ban/timeout\n\t        \"\"\"\n\t        return self._data[\"ban\"][\"reason\"]\n\t    @property\n\t    def is_permanent(self) -> bool:\n\t        \"\"\"\n\t        Whether the ban is permanent. True == ban, false == timeout\n\t        \"\"\"\n\t        return self._data[\"ban\"][\"permanent\"]\n", "    @cached_property\n\t    def user(self) -> PartialUser:\n\t        \"\"\"\n\t        The user the action was towards\n\t        \"\"\"\n\t        return PartialUser(\n\t            id=self._data[\"banned_user\"][\"id\"],\n\t            username=self._data[\"banned_user\"][\"username\"],\n\t            http=self.http,\n\t        )\n", "    @cached_property\n\t    def banned_by(self) -> PartialUser:\n\t        \"\"\"\n\t        The responsible mod\n\t        \"\"\"\n\t        return PartialUser(\n\t            id=self._data[\"banned_by\"][\"id\"],\n\t            username=self._data[\"banned_by\"][\"username\"],\n\t            http=self.http,\n\t        )\n", "    @cached_property\n\t    def banned_at(self) -> datetime:\n\t        \"\"\"\n\t        When the action happened\n\t        \"\"\"\n\t        return datetime.fromisoformat(self._data[\"ban\"][\"banned_at\"])\n\t    @cached_property\n\t    def expires_at(self) -> datetime | None:\n\t        \"\"\"\n\t        When the timeout expires at. None for a ban\n", "        \"\"\"\n\t        return (\n\t            None\n\t            if self.is_permanent is True\n\t            else datetime.fromisoformat(self._data[\"ban\"][\"expires_at\"])\n\t        )\n\t    async def unban(self) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Unbans the chatter from the chatroom.\n", "        Raises\n\t        -----------\n\t        NotFound\n\t            Streamer or chatter not found\n\t        HTTPException\n\t            Unbanning the chatter failed\n\t        Forbidden\n\t            You are unauthorized from unbanning the chatter\n\t        \"\"\"\n\t        await self.http.unban_user(self.chatroom.streamer_name, self.user.username)\n", "class PartialChatroom:\n\t    \"\"\"\n\t    A dataclass that represents a kick chatroom.\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        The chatroom's id\n\t    streamer: `User`\n\t        The user who this chatroom belongs to\n\t    \"\"\"\n", "    def __init__(self, *, id: int, streamer_name: str, http: HTTPClient) -> None:\n\t        self.id = id\n\t        self.streamer_name = streamer_name\n\t        self.http = http\n\t    async def connect(self) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Connects to the chatroom, making it so you can now listen for the messages.\n\t        \"\"\"\n\t        await self.http.ws.subscribe_to_chatroom(self.id)\n", "        self.http.client._chatrooms[self.id] = self\n\t    async def disconnect(self) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Disconnects to the chatroom, making it so you can no longer listen for the messages.\n\t        \"\"\"\n\t        await self.http.ws.unsubscribe_to_chatroom(self.id)\n\t        self.http.client._chatrooms.pop(self.id)\n\t    async def send(self, content: str, /) -> None:\n\t        \"\"\"\n", "        |coro|\n\t        Sends a message in the chatroom\n\t        Parameters\n\t        -----------\n\t        content: str\n\t            The message's content\n\t        Raises\n\t        -----------\n\t        NotFound\n\t            Streamer or chatter not found\n", "        HTTPException\n\t            Sending the message failed\n\t        Forbidden\n\t            You are unauthorized from sending the message\n\t        \"\"\"\n\t        await self.http.send_message(self.id, content)\n\t    async def fetch_chatter(self, chatter_name: str, /) -> Chatter:\n\t        \"\"\"\n\t        |coro|\n\t        Fetches a chatroom's chatter\n", "        Parameters\n\t        -----------\n\t        chatter_name: str\n\t            The chatter's username\n\t        Raises\n\t        -----------\n\t        NotFound\n\t            Streamer or chatter not found\n\t        HTTPException\n\t            Fetching the chatter failed\n", "        Returns\n\t        -----------\n\t        Chatter\n\t            The chatter\n\t        \"\"\"\n\t        from .chatter import Chatter\n\t        data = await self.http.get_chatter(self.streamer_name, chatter_name)\n\t        chatter = Chatter(data=data, http=self.http, chatroom=self)\n\t        return chatter\n\t    async def fetch_rules(self) -> str:\n", "        \"\"\"\n\t        |coro|\n\t        Fetches the chatroom's rules\n\t        Raises\n\t        -----------\n\t        NotFound\n\t            Streamer Not Found\n\t        HTTPException\n\t            Fetching the rules failed\n\t        Returns\n", "        -----------\n\t        str\n\t            The rules\n\t        \"\"\"\n\t        data = await self.http.get_chatroom_rules(self.streamer_name)\n\t        return data[\"data\"][\"rules\"]\n\t    async def fetch_banned_words(self) -> list[str]:\n\t        \"\"\"\n\t        |coro|\n\t        Fetches the chatroom's banned words\n", "        Raises\n\t        -----------\n\t        NotFound\n\t            Streamer Not Found\n\t        HTTPException\n\t            Fetching the words failed\n\t        Returns\n\t        -----------\n\t        list[str]\n\t            A list of the banned words\n", "        \"\"\"\n\t        data = await self.http.get_channels_banned_words(self.streamer_name)\n\t        return data[\"data\"][\"words\"]\n\t    async def fetch_bans(self) -> AsyncIterator[BanEntry]:\n\t        \"\"\"\n\t        |coro|\n\t        Fetches the chatroom's bans\n\t        Raises\n\t        -----------\n\t        NotFound\n", "            Streamer Not Found\n\t        HTTPException\n\t            Fetching the bans failed\n\t        Returns\n\t        -----------\n\t        AsyncIterator[BanEntry]\n\t            Yields all of the ban entries\n\t        \"\"\"\n\t        data = await self.http.get_channel_bans(self.streamer_name)\n\t        for entry_data in data:\n", "            entry = BanEntry(data=entry_data, http=self.http)\n\t            entry.chatroom = self\n\t            yield entry\n\t    async def fetch_poll(self) -> Poll:\n\t        \"\"\"\n\t        |coro|\n\t        Gets a poll from the chatroom\n\t        Raises\n\t        -----------\n\t        NotFound\n", "            There is no poll in the current chatroom or Streamer Not Found\n\t        HTTPException\n\t            Fetching the poll failed\n\t        Returns\n\t        -----------\n\t        Poll\n\t            The poll\n\t        \"\"\"\n\t        data = await self.http.get_poll(self.streamer_name)\n\t        poll = Poll(data=data, http=self.http)\n", "        poll.chatroom = self\n\t        return poll\n\t    async def fetch_emotes(\n\t        self, *, include_global: bool = False\n\t    ) -> AsyncIterator[Emote]:\n\t        \"\"\"\n\t        |coro|\n\t        Fetches the emotes from the current chatroom.\n\t        Parameters\n\t        -----------\n", "        include_global: bool = False\n\t            Whether to include global emotes or not\n\t        Raises\n\t        -----------\n\t        NotFound\n\t            Streamer Not Found\n\t        HTTPException\n\t            Fetching the bans failed\n\t        Returns\n\t        -----------\n", "        AsyncIterator[Emote]\n\t            Yields each emote. Starting with from the chatroom, then global\n\t        \"\"\"\n\t        data = await self.http.get_emotes(self.streamer_name)\n\t        for emote in data[2][\"emotes\"]:\n\t            yield Emote(data=emote, http=self.http)\n\t        if include_global is True:\n\t            for emote in data[1][\"emotes\"]:\n\t                yield Emote(data=emote, http=self.http)\n\tclass Chatroom(PartialChatroom):\n", "    \"\"\"\n\t    A dataclass that represents a kick chatroom.\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        The chatroom's id\n\t    chatable_type: str\n\t        The chatroom's type\n\t    created_at: datetime.datetime\n\t        When the chatroom was created\n", "    updated_at: datetime.datetime\n\t        When the chatroom was last updated\n\t    chat_mode: ChatroomChatMode\n\t        The mode the chatroom is in\n\t    slowmode: bool\n\t        Whether slowmode is enabled\n\t    followers_mode: bool\n\t        Whether followers_mode is enabled\n\t    subscribers_mode: bool\n\t        Whether subscribers_mode is enabled\n", "    emotes_mode: bool\n\t        Whether emotes_mode is enabled\n\t    slow_mode: bool\n\t        Whether slow_mode is enabled\n\t    message_interval: int\n\t        Interval at which messages can be sent when slow_mode is enabled\n\t    following_min_duration: int\n\t        Unknown on what this is\n\t    streamer: `User`\n\t        The user who this chatroom belongs to\n", "    \"\"\"\n\t    def __init__(self, *, data: ChatroomPayload, streamer: User, http: HTTPClient):\n\t        super().__init__(id=data[\"id\"], streamer_name=streamer.username, http=http)\n\t        self._data = data\n\t        self.streamer = streamer\n\t    @property\n\t    def chatable_type(self) -> str:\n\t        \"\"\"\n\t        The chatroom's type\n\t        \"\"\"\n", "        return self._data[\"chatable_type\"]\n\t    @cached_property\n\t    def created_at(self) -> datetime:\n\t        \"\"\"\n\t        When the chatroom was created\n\t        \"\"\"\n\t        return datetime.fromisoformat(self._data[\"created_at\"])\n\t    @cached_property\n\t    def updated_at(self) -> datetime:\n\t        \"\"\"\n", "        When the chatroom was last updated\n\t        \"\"\"\n\t        return datetime.fromisoformat(self._data[\"updated_at\"])\n\t    @property\n\t    def chat_mode(self) -> ChatroomChatMode:\n\t        \"\"\"\n\t        The mode the chatroom is in\n\t        \"\"\"\n\t        return ChatroomChatMode(self._data[\"chat_mode\"])\n\t    @property\n", "    def slowmode(self) -> bool:\n\t        \"\"\"\n\t        Whether slowmode is enabled\n\t        \"\"\"\n\t        return self._data[\"slow_mode\"]\n\t    @property\n\t    def followers_mode(self) -> bool:\n\t        \"\"\"\n\t        Whether followers_mode is enabled\n\t        \"\"\"\n", "        return self._data[\"followers_mode\"]\n\t    @property\n\t    def subscribers_mode(self) -> bool:\n\t        \"\"\"\n\t        Whether subscribers_mode is enabled\n\t        \"\"\"\n\t        return self._data[\"subscribers_mode\"]\n\t    @property\n\t    def emotes_mode(self) -> bool:\n\t        \"\"\"\n", "        Whether emotes_mode is enabled\n\t        \"\"\"\n\t        return self._data[\"emotes_mode\"]\n\t    @property\n\t    def slow_mode(self) -> bool:\n\t        \"\"\"\n\t        Whether slow_mode is enabled\n\t        \"\"\"\n\t        return self._data[\"slow_mode\"]\n\t    @property\n", "    def message_interval(self) -> int:\n\t        \"\"\"\n\t        Interval at which messages can be sent when slow_mode is enabled\n\t        \"\"\"\n\t        return self._data[\"message_interval\"]\n\t    @property\n\t    def following_min_duration(self) -> int:\n\t        \"\"\"\n\t        Unknown on what this is\n\t        \"\"\"\n", "        return self._data[\"following_min_duration\"]\n\t    async def edit(\n\t        self,\n\t        *,\n\t        followers_only_mode: Optional[bool] = None,\n\t        emotes_only_mode: Optional[bool] = None,\n\t        subscribers_only_mode: Optional[bool] = None,\n\t        slow_mode_enabled: Optional[bool] = None,\n\t        slow_mode_interval: Optional[int] = None,\n\t    ) -> None:\n", "        \"\"\"\n\t        |coro|\n\t        Edits the chatroom's settings\n\t        Parameters\n\t        -----------\n\t        followers_only_mode: Optional[bool] = None\n\t            Lets you enable/disable followers only mode.\n\t        emotes_only_mode: Optional[bool] = None\n\t            Lets you enable/disable emotes only mode.\n\t        subscribers_only_mode: Optional[bool] = None\n", "            Lets you enable/disable subscribers only mode.\n\t        slow_mode_enabled: Optional[bool] = None\n\t            Lets you enable/disable slow_mode only mode.\n\t        slow_mode_interval: Optional[int] = None\n\t            Lets you set the slow mode interval\n\t        Raises\n\t        -----------\n\t        `NotFound`\n\t            Streamer not found\n\t        `HTTPException`\n", "            Editing the chatroom failed\n\t        `Forbidden`\n\t            You are unauthorized from editing the chatroom.\n\t        \"\"\"\n\t        streamer_name = self.streamer_name\n\t        payload = {}\n\t        if self.followers_mode is not None:\n\t            payload[\"followers_mode\"] = self.followers_mode\n\t        if self.emotes_mode is not None:\n\t            payload[\"emotes_mode\"] = self.emotes_mode\n", "        if self.subscribers_mode is not None:\n\t            payload[\"subscribers_mode\"] = self.subscribers_mode\n\t        if self.slow_mode is not None:\n\t            payload[\"slow_mode\"] = self.slow_mode\n\t            if self.slow_mode and self.message_interval is not None:\n\t                payload[\"message_interval\"] = self.message_interval\n\t        if not payload:\n\t            raise ValueError(\"No valid parameters provided for chatroom editing.\")\n\t        await self.http.edit_chatroom(streamer_name, payload)\n\t    def __eq__(self, other: object) -> bool:\n", "        return isinstance(other, self.__class__) and other.id == self.id\n\t    def __repr__(self) -> str:\n\t        return f\"<{self.__class__.__name__} id={self.id!r} streamer={self.streamer_name!r}>\"\n"]}
{"filename": "kick/users.py", "chunked_list": ["from __future__ import annotations\n\tfrom datetime import datetime\n\tfrom typing import TYPE_CHECKING\n\tfrom kick.categories import Category\n\tfrom .assets import Asset\n\tfrom .badges import SubscriberBadge\n\tfrom .leaderboard import GiftLeaderboard\n\tfrom .livestream import Livestream\n\tfrom .object import BaseDataclass\n\tfrom .utils import cached_property\n", "from .videos import Video\n\tif TYPE_CHECKING:\n\t    from .chatroom import Chatroom\n\t    from .http import HTTPClient\n\t    from .types.user import ClientUserPayload, InnerUser, UserPayload\n\t__all__ = (\"User\", \"Socials\", \"PartialUser\", \"ClientUser\")\n\tclass Socials(BaseDataclass[\"InnerUser | ClientUserPayload\"]):\n\t    \"\"\"\n\t    The socials a user on kick has added to their profile\n\t    Attributes\n", "    -----------\n\t    instagram: str\n\t        Their instagram\n\t    youtube: str\n\t        Their youtube\n\t    twitter: str\n\t        Their twitter\n\t    discord: str\n\t        Their discord\n\t    tiktok: str\n", "        Their tiktok\n\t    facebook: str\n\t        Their facebook\n\t    \"\"\"\n\t    @property\n\t    def instagram(self) -> str:\n\t        \"\"\"\n\t        Their instagram\n\t        \"\"\"\n\t        return self._data[\"instagram\"] or \"\"\n", "    @property\n\t    def youtube(self) -> str:\n\t        \"\"\"\n\t        Their youtube\n\t        \"\"\"\n\t        return self._data[\"youtube\"] or \"\"\n\t    @property\n\t    def twitter(self) -> str:\n\t        \"\"\"\n\t        Their twitter\n", "        \"\"\"\n\t        return self._data[\"twitter\"] or \"\"\n\t    @property\n\t    def discord(self) -> str:\n\t        \"\"\"\n\t        Their discord\n\t        \"\"\"\n\t        return self._data[\"discord\"] or \"\"\n\t    @property\n\t    def tiktok(self) -> str:\n", "        \"\"\"\n\t        Their tiktok\n\t        \"\"\"\n\t        return self._data[\"tiktok\"] or \"\"\n\t    @property\n\t    def facebook(self) -> str:\n\t        \"\"\"\n\t        Their facebook\n\t        \"\"\"\n\t        return self._data[\"facebook\"] or \"\"\n", "class BaseUser:\n\t    def __init__(self, *, id: int, username: str, http: HTTPClient) -> None:\n\t        self.id = id\n\t        self.username = username\n\t        self.http = http\n\t    async def fetch_videos(self) -> list[Video]:\n\t        data = await self.http.get_streamer_videos(self.username)\n\t        return [Video(data=v, http=self.http) for v in data]\n\t    async def fetch_gift_leaderboard(self) -> GiftLeaderboard:\n\t        data = await self.http.get_channel_gift_leaderboard(self.username)\n", "        leaderboard = GiftLeaderboard(data=data)\n\t        leaderboard.streamer = self\n\t        return leaderboard\n\t    def __eq__(self, other: object) -> bool:\n\t        return isinstance(other, self.__class__) and other.id == self.id\n\t    def __str__(self) -> str:\n\t        return self.username\n\t    def __repr__(self) -> str:\n\t        return f\"<{self.__class__.__name__} id={self.id!r} username={self.username!r}>\"\n\tclass PartialUser(BaseUser):\n", "    \"\"\"\n\t    This dataclass represents a partial user on kick\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        The user's id\n\t    username: str\n\t        The user's name\n\t    \"\"\"\n\t    async def fetch(self) -> User:\n", "        \"\"\"\n\t        |coro|\n\t        Fetches a full user object\n\t        Raises\n\t        -----------\n\t        `HTTPException`\n\t            Fetching the user failed\n\t        `NotFound`\n\t            User not found\n\t        Returns\n", "        -----------\n\t        `User`\n\t            The full user object\n\t        \"\"\"\n\t        data = await self.http.get_user(self.username)\n\t        return User(data=data, http=self.http)\n\tclass User:\n\t    \"\"\"\n\t    A dataclass which represents a User on kick\n\t    Attributes\n", "    -----------\n\t    id: int\n\t        The user's id\n\t    channel_id: int\n\t        The user's channel id\n\t    username: str\n\t        The user's name\n\t    state: str\n\t        The state the user has said they live in\n\t    socials: `Socials`\n", "        The socials the user has said they have\n\t    country: str\n\t        The country the user has said they live in\n\t    playback_url: str\n\t        The user's playback url\n\t    slug: str\n\t        The user's slug\n\t    vod_enabled: bool\n\t        If the user has vods enabled\n\t    is_banned: bool\n", "        If the user is banned\n\t    subscription_enabled: bool\n\t        If the user has subscriptions enabled\n\t    follower_count: int\n\t        The amount of followers the user has\n\t    subscriber_badges: list[`SubscriberBadge`]\n\t        A list of subscriber badges the user has\n\t    online_banner: `Asset` | None\n\t        the banner that gets displayed when the user is live\n\t    offline_banner: `Asset` | None\n", "        the banner that gets displayed when the user is offline\n\t    is_muted: bool\n\t        If the user is muted\n\t    is_verified: bool\n\t        If the user is verified\n\t    avatar: `Asset`\n\t        The user's avatar\n\t    can_host: bool\n\t        If the user can host\n\t    bio: str\n", "        The user's bio\n\t    agreed_to_terms: bool\n\t        if the user has agreed to kick's TOS\n\t    email_verified_at: datetime.datetime\n\t        When the user verified their user\n\t    livestream: `Livestream` | None\n\t        The user's livestream\n\t    chatroom: `Chatroom`\n\t        The user's chatroom\n\t    recent_categories: list[`Category`]\n", "        The categories the user has recently gone live in\n\t    \"\"\"\n\t    def __init__(self, *, data: UserPayload, http: HTTPClient) -> None:\n\t        self._data = data\n\t        self.http = http\n\t    @property\n\t    def id(self) -> int:\n\t        return self._data[\"user_id\"]\n\t    @property\n\t    def channel_id(self) -> int:\n", "        return self._data[\"id\"]\n\t    @property\n\t    def playback_url(self) -> str:\n\t        return self._data[\"playback_url\"]\n\t    @property\n\t    def slug(self) -> str:\n\t        return self._data[\"slug\"]\n\t    @property\n\t    def vod_enabled(self) -> bool:\n\t        return self._data[\"vod_enabled\"]\n", "    @property\n\t    def is_banned(self) -> bool:\n\t        return self._data[\"is_banned\"]\n\t    @property\n\t    def subscription_enabled(self) -> bool:\n\t        return self._data[\"subscription_enabled\"]\n\t    @property\n\t    def follower_count(self) -> int:\n\t        return self._data[\"followers_count\"]\n\t    @property\n", "    def subscriber_badges(self) -> list[SubscriberBadge]:\n\t        return [\n\t            SubscriberBadge(data=c, http=self.http)\n\t            for c in self._data[\"subscriber_badges\"]\n\t        ]\n\t    @property\n\t    def follower_badges(self) -> list:\n\t        \"\"\"THIS IS RAW DATA\"\"\"\n\t        return self._data[\"follower_badges\"]\n\t    @cached_property\n", "    def online_banner(self) -> Asset | None:\n\t        return (\n\t            Asset(url=self._data[\"banner_image\"][\"url\"], http=self.http)  # type: ignore\n\t            if self._data.get(\"banner_image\", None)\n\t            else None\n\t        )\n\t    @cached_property\n\t    def offline_banner(self) -> Asset | None:\n\t        return (\n\t            Asset._from_asset_src(\n", "                data=self._data[\"offline_banner_image\"], http=self.http\n\t            )\n\t            if self._data[\"offline_banner_image\"]\n\t            else None\n\t        )\n\t    @property\n\t    def is_muted(self) -> bool:\n\t        return self._data[\"muted\"]\n\t    @property\n\t    def is_verified(self) -> bool:\n", "        return self._data[\"verified\"]\n\t    @cached_property\n\t    def avatar(self) -> Asset:\n\t        return Asset(url=self._data[\"user\"][\"profile_pic\"], http=self.http)\n\t    @property\n\t    def can_host(self) -> bool:\n\t        return self._data[\"can_host\"]\n\t    @property\n\t    def bio(self) -> str:\n\t        return self._data[\"user\"][\"bio\"]\n", "    @property\n\t    def agreed_to_terms(self) -> bool:\n\t        return self._data[\"user\"][\"agreed_to_terms\"]\n\t    @cached_property\n\t    def email_verified_at(self) -> datetime:\n\t        return datetime.fromisoformat(self._data[\"user\"][\"email_verified_at\"])\n\t    @property\n\t    def username(self) -> str:\n\t        return self._data[\"user\"][\"username\"]\n\t    @property\n", "    def country(self) -> str:\n\t        return self._data[\"user\"][\"country\"]\n\t    @property\n\t    def state(self) -> str:\n\t        return self._data[\"user\"][\"state\"]\n\t    @cached_property\n\t    def socials(self) -> Socials:\n\t        return Socials(data=self._data[\"user\"])\n\t    @cached_property\n\t    def livestream(self) -> Livestream | None:\n", "        livestream = self._data[\"livestream\"]\n\t        if not livestream:\n\t            return\n\t        return Livestream(data=livestream, http=self.http)\n\t    @cached_property\n\t    def chatroom(self) -> Chatroom:\n\t        from .chatroom import Chatroom\n\t        chatroom = Chatroom(data=self._data[\"chatroom\"], http=self.http, streamer=self)\n\t        return chatroom\n\t    @cached_property\n", "    def recent_categories(self) -> list[Category]:\n\t        return [\n\t            Category(data=c, http=self.http) for c in self._data[\"recent_categories\"]\n\t        ]\n\t    async def start_watch(self) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Watches a user to see if they go online.\n\t        \"\"\"\n\t        await self.http.ws.watch_channel(self.channel_id)\n", "        self.http.client._watched_users[self.channel_id] = self\n\t    async def stop_watching(self) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Stops watching the user\n\t        \"\"\"\n\t        await self.http.ws.unwatch_channel(self.channel_id)\n\t        self.http.client._watched_users.pop(self.channel_id)\n\tclass ClientUser(BaseUser):\n\t    def __init__(self, *, data: ClientUserPayload, http: HTTPClient) -> None:\n", "        self._data = data\n\t        self.http = http\n\t    @property\n\t    def id(self) -> int:\n\t        return self._data[\"id\"]\n\t    @property\n\t    def username(self) -> str:\n\t        return self._data[\"username\"]\n\t    @property\n\t    def slug(self) -> str:\n", "        return self._data[\"username\"].lower().replace(\"_\", \"-\")\n\t    @property\n\t    def bio(self) -> str:\n\t        return self._data[\"bio\"] or \"\"\n\t    @property\n\t    def agreed_to_terms(self) -> bool:\n\t        return self._data[\"agreed_to_terms\"]\n\t    @cached_property\n\t    def email_verified_at(self) -> datetime:\n\t        return datetime.fromisoformat(self._data[\"email_verified_at\"])\n", "    @property\n\t    def country(self) -> str | None:\n\t        return self._data[\"country\"]\n\t    @property\n\t    def city(self) -> str | None:\n\t        return self._data[\"city\"]\n\t    @property\n\t    def state(self) -> str | None:\n\t        return self._data[\"state\"]\n\t    @cached_property\n", "    def socials(self) -> Socials:\n\t        return Socials(data=self._data)\n\t    @cached_property\n\t    def avatar(self) -> Asset | None:\n\t        url = self._data[\"profilepic\"]\n\t        if url is None:\n\t            return\n\t        return Asset(url=url, http=self.http)\n\tAnyUser = ClientUser | BaseUser | User | PartialUser\n"]}
{"filename": "kick/categories.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING, Any\n\tfrom .assets import Asset\n\tfrom .object import HTTPDataclass\n\tfrom .utils import cached_property\n\tif TYPE_CHECKING:\n\t    from .types.categories import Category as CategoryPayload\n\t    from .types.categories import InnerCategory as ParentCategoryPayload\n\t__all__ = (\"Category\", \"ParentCategory\")\n\tclass ParentCategory(HTTPDataclass[\"ParentCategoryPayload\"]):\n", "    \"\"\"\n\t    A dataclass which represents one of kick's main categories\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        The categorie's ID\n\t    name: str\n\t        The categorie's name\n\t    slug: str\n\t        The categorie's slug\n", "    icon: `Asset`\n\t        The categorie's icon\n\t    \"\"\"\n\t    @property\n\t    def id(self) -> int:\n\t        \"\"\"\n\t        The categorie's ID\n\t        \"\"\"\n\t        return self._data[\"id\"]\n\t    @property\n", "    def name(self) -> str:\n\t        \"\"\"\n\t        The categorie's name\n\t        \"\"\"\n\t        return self._data[\"name\"]\n\t    @property\n\t    def slug(self) -> str:\n\t        \"\"\"\n\t        The categorie's slug\n\t        \"\"\"\n", "        return self._data[\"slug\"]\n\t    @cached_property\n\t    def icon(self) -> Asset:\n\t        \"\"\"\n\t        The categorie's icon\n\t        \"\"\"\n\t        return Asset(url=self._data[\"icon\"], http=self.http)\n\t    def __eq__(self, other: object) -> bool:\n\t        return isinstance(other, self.__class__) and other.id == self.id\n\t    def __repr__(self) -> str:\n", "        return f\"<ParentCategory id={self.id!r} name={self.name!r} icon={self.icon!r}>\"\n\tclass Category(HTTPDataclass[\"CategoryPayload\"]):\n\t    \"\"\"\n\t    A dataclass which represents one of kick's sub categories\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        The categorie's ID?\n\t    category_id: str\n\t        The categorie's ID?\n", "    slug: str\n\t        The categorie's slug\n\t    name: str\n\t        The categorie's name\n\t    tags: list[str]\n\t        A list of the categorie's tags\n\t    description: str | None\n\t        The categorie's description, if any\n\t    parent: `ParentCategory`\n\t        The categorie's parent category.\n", "    \"\"\"\n\t    @property\n\t    def id(self) -> int:\n\t        \"\"\"\n\t        The categorie's ID?\n\t        Unknown on the difference between this and `Category.category_id`\n\t        \"\"\"\n\t        return self._data[\"id\"]\n\t    @property\n\t    def category_id(self) -> int:\n", "        \"\"\"\n\t        The categorie's ID?\n\t        Unknown on the difference between this and `Category.id`\n\t        \"\"\"\n\t        return self._data[\"category_id\"]\n\t    @property\n\t    def name(self) -> str:\n\t        \"\"\"\n\t        The categorie's name\n\t        \"\"\"\n", "        return self._data[\"name\"]\n\t    @property\n\t    def slug(self) -> str:\n\t        \"\"\"\n\t        The categorie's slug\n\t        \"\"\"\n\t        return self._data[\"slug\"]\n\t    @property\n\t    def tags(self) -> list[str]:\n\t        \"\"\"\n", "        A list of the categorie's tags\n\t        \"\"\"\n\t        return self._data[\"tags\"]\n\t    @property\n\t    def description(self) -> str | None:\n\t        \"\"\"\n\t        The categorie's description, if any\n\t        \"\"\"\n\t        return self._data[\"description\"]\n\t    @cached_property\n", "    def parent(self) -> ParentCategory:\n\t        \"\"\"\n\t        The categorie's parent category.\n\t        \"\"\"\n\t        return ParentCategory(data=self._data[\"category\"], http=self.http)\n\t    def __eq__(self, other: object) -> bool:\n\t        return isinstance(other, self.__class__) and other.id == self.id\n\t    def __repr__(self) -> str:\n\t        return f\"<Category id={self.id!r} name={self.name!r} category_id={self.category_id!r}> tags={self.tags!r} description={self.description!r} parent={self.parent!r}\"\n"]}
{"filename": "kick/__main__.py", "chunked_list": ["import subprocess\n\timport click\n\t@click.group\n\tdef cli():\n\t    ...\n\t@cli.group(name=\"bypass\", help=\"Stuff regarding the cloudflare bypass script\")\n\tdef bypass():\n\t    ...\n\tBYPASS_CODE = \"\"\"\n\tpackage main\n", "import (\n\t    \"log\"\n\t    \"strings\"\n\t\t\"bytes\"\n\t    \"github.com/Danny-Dasilva/CycleTLS/cycletls\"\n\t    \"github.com/gin-gonic/gin\"\n\t)\n\tfunc sendKickMessage(context *gin.Context) cycletls.Response {\n\t    client := cycletls.Init()\n\t\theaders := make(map[string]string)\n", "\tfor key, values := range context.Request.Header {\n\t\theaders[key] = strings.Join(values, \",\")\n\t\t}\n\t\tbuf := new(bytes.Buffer)\n\t\tbuf.ReadFrom(context.Request.Body)\n\t\tbodyStr := buf.String()\n\t\turl := context.Query(\"url\")\n\t    response, err := client.Do(url, cycletls.Options{\n\t        Body:      bodyStr,\n\t\t\tHeaders:   headers,\n", "        Ja3:       \"771,4865-4867-4866-49195-49199-52393-52392-49196-49200-49162-49161-49171-49172-51-57-47-53-10,0-23-65281-10-11-35-16-5-51-43-13-45-28-21,29-23-24-25-256-257,0\",\n\t        UserAgent: \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko/20100101 Firefox/87.0\",\n\t        // PROXY_HERE\n\t    }, context.Request.Method)\n\t    if err != nil {\n\t        log.Print(\"Request Failed: \" + err.Error())\n\t    }\n\t    return response\n\t}\n\tfunc queryRespone(context *gin.Context) {\n", "    response := sendKickMessage(context)\n\t    context.String(response.Status, response.Body)\n\t}\n\tfunc main() {\n\t\tlog.Print(\"starting\")\n\t \tgin.SetMode(gin.ReleaseMode)\n\t    router := gin.Default()\n\t    router.Any(\"/request\", queryRespone)\n\t    router.Run(\"localhost:9090\")\n\t}\n", "\"\"\"\n\t@bypass.command(help=\"Creates the bypass file\", name=\"create\")\n\t@click.option(\n\t    \"--port\",\n\t    default=9090,\n\t    help=\"The port for the bypass script to run the webserver on\",\n\t)\n\t@click.option(\"--fp\", default=\"bypass.go\", help=\"The filepath for the file to go to\")\n\t@click.option(\n\t    \"--proxy\",\n", "    help=\"A proxy url in the format of: http://username:password@hostname.tld:port. Rotating proxy not supported\",\n\t    default=None,\n\t)\n\tdef create_file(port: int, fp: str, proxy: str | None) -> None:\n\t    code = BYPASS_CODE.replace(\"{port}\", f\"{port}\")\n\t    if proxy:\n\t        code = code.replace(f\"// PROXY_HERE\", f'Proxy: \"{proxy}\",')\n\t    with open(fp, \"w\", encoding=\"utf-8\") as f:\n\t        f.write(code)\n\t    print(f\"Done writing to {fp}.\\nMake sure to install the dependencys.\")\n", "@bypass.command(help=\"installs the script's dependencys\", name=\"install\")\n\tdef install_dependencys() -> None:\n\t    print(\"Running go init...\")\n\t    subprocess.run(\"go mod init example/project-name\")\n\t    print(\"Installing CycleTLS...\")\n\t    subprocess.run(\"go get github.com/Danny-Dasilva/CycleTLS/cycletls\")\n\t    print(\"Installing gin...\")\n\t    subprocess.run(\"go get github.com/gin-gonic/gin\")\n\t    print(\"\\n\\nAll done. Run `go run filepath` to run the file.\")\n\tif __name__ == \"__main__\":\n", "    cli()\n"]}
{"filename": "kick/assets.py", "chunked_list": ["from __future__ import annotations\n\timport os\n\tfrom io import BufferedIOBase\n\tfrom typing import TYPE_CHECKING, Any\n\tif TYPE_CHECKING:\n\t    from typing_extensions import Self\n\t    from .http import HTTPClient\n\t    from .types.assets import AssetOnlySrc, AssetSrcset\n\t__all__ = (\"Asset\",)\n\tclass Asset:\n", "    \"\"\"\n\t    A class which repersents a kick asset.\n\t    Attributes\n\t    -----------\n\t    url: str\n\t        The asset's url\n\t    \"\"\"\n\t    def __init__(self, *, url: str, http: HTTPClient) -> None:\n\t        self.http = http\n\t        self.url = url\n", "    async def read(self) -> bytes:\n\t        \"\"\"\n\t        |coro|\n\t        Fetches the asset from kick\n\t        Raises\n\t        -----------\n\t        HTTPException\n\t            Fetching the asset failed\n\t        NotFound\n\t            Asset no longer exists\n", "        Returns\n\t        -----------\n\t        bytes\n\t            The asset's bytes\n\t        \"\"\"\n\t        return await self.http.get_asset(self.url)\n\t    async def save(\n\t        self,\n\t        fp: str | bytes | os.PathLike[Any] | BufferedIOBase,\n\t        *,\n", "        seek_begin: bool = True,\n\t    ) -> int:\n\t        \"\"\"\n\t        |coro|\n\t        Saves the asset into a file-like object\n\t        Parameters\n\t        -----------\n\t        fp: str | bytes | os.PathLike[Any] | BufferedIOBase\n\t            The file-like object for the asset to be written to.\n\t            If a filepath is given, then a file will be created instead.\n", "        seek_begin: bool\n\t            Whether to seek to the beginning of the file after saving is\n\t            successfully done.\n\t        Raises\n\t        -----------\n\t        HTTPException\n\t            Fetching the asset failed\n\t        NotFound\n\t            Asset no longer exists\n\t        Returns\n", "        -----------\n\t        int\n\t            The amount of bytes written\n\t        \"\"\"\n\t        data = await self.read()\n\t        if isinstance(fp, BufferedIOBase):\n\t            written = fp.write(data)\n\t            if seek_begin:\n\t                fp.seek(0)\n\t            return written\n", "        else:\n\t            with open(fp, \"wb\") as f:\n\t                return f.write(data)\n\t    def __str__(self) -> str:\n\t        return self.url\n\t    def __len__(self) -> int:\n\t        return len(self.url)\n\t    def __eq__(self, other: object) -> bool:\n\t        return isinstance(other, self.__class__) and other.url == self.url\n\t    @classmethod\n", "    def _from_asset_src(\n\t        cls, *, data: AssetSrcset | AssetOnlySrc, http: HTTPClient\n\t    ) -> Self:\n\t        return cls(url=data[\"src\"], http=http)\n\t    @classmethod\n\t    def _from_emote(cls, emote_id: int, /, *, http: HTTPClient) -> Self:\n\t        return cls(url=f\"https://files.kick.com/emotes/{emote_id}/fullsize\", http=http)\n\t    def __repr__(self) -> str:\n\t        return f\"<Asset url={self.url}>\"\n"]}
{"filename": "kick/badges.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom .assets import Asset\n\tfrom .object import BaseDataclass, HTTPDataclass\n\tfrom .utils import cached_property\n\tif TYPE_CHECKING:\n\t    from .types.badges import ChatBadgePayload, SubscriberBadgePayload\n\t__all__ = (\"ChatBadge\", \"SubscriberBadge\")\n\tclass ChatBadge(BaseDataclass[\"ChatBadgePayload\"]):\n\t    \"\"\"\n", "    A dataclass which represents a badge from a chatroon.\n\t    Attributes\n\t    -----------\n\t    type: str\n\t        The type of badge\n\t    text: str\n\t        The badge's text\n\t    count: int\n\t        How many of that badge they have\n\t    active: bool\n", "        If the chatter actively has the badge\n\t    \"\"\"\n\t    @property\n\t    def type(self) -> str:\n\t        \"\"\"\n\t        The type of badge\n\t        \"\"\"\n\t        return self._data[\"type\"]\n\t    @property\n\t    def text(self) -> str:\n", "        \"\"\"\n\t        The badge's text\n\t        \"\"\"\n\t        return self._data[\"text\"]\n\t    @property\n\t    def count(self) -> int:\n\t        \"\"\"\n\t        How many of that badge they have\n\t        \"\"\"\n\t        return self._data[\"count\"]\n", "    @property\n\t    def active(self) -> bool:\n\t        \"\"\"\n\t        If the chatter actively has the badge\n\t        \"\"\"\n\t        return self._data[\"active\"]\n\t    def __repr__(self) -> str:\n\t        return f\"<ChatBadge type={self.type!r} text={self.text!r} count={self.count!r} active={self.active!r}>\"\n\tclass SubscriberBadge(HTTPDataclass[\"SubscriberBadgePayload\"]):\n\t    \"\"\"\n", "    A dataclass which represents a subscriber badge from a channel.\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        The badge's id\n\t    channel_id: int\n\t        The id of the channel the chatter is subscribed too\n\t    months: int\n\t        How many months they have been subscribed to the chatter\n\t    image: `Asset`\n", "        The badge's image\n\t    \"\"\"\n\t    @property\n\t    def id(self) -> int:\n\t        return self._data[\"id\"]\n\t    @property\n\t    def channel_id(self) -> int:\n\t        return self._data[\"channel_id\"]\n\t    @property\n\t    def months(self) -> int:\n", "        return self._data[\"months\"]\n\t    @cached_property\n\t    def image(self) -> Asset:\n\t        return Asset._from_asset_src(data=self._data[\"badge_image\"], http=self.http)\n\t    def __repr__(self) -> str:\n\t        return f\"<SubscriberBadge id={self.id!r} channel_id={self.channel_id!r} months={self.months!r} image={self.image!r}>\"\n"]}
{"filename": "kick/livestream.py", "chunked_list": ["from __future__ import annotations\n\tfrom datetime import datetime\n\tfrom typing import TYPE_CHECKING\n\tfrom .assets import Asset\n\tfrom .categories import Category\n\tfrom .object import HTTPDataclass\n\tfrom .utils import cached_property\n\tif TYPE_CHECKING:\n\t    from .http import HTTPClient\n\t    from .types.videos import LivestreamPayload\n", "    from .types.ws import PartialLivestreamPayload\n\t    from .users import User\n\t__all__ = (\"Livestream\", \"PartialLivestream\")\n\tclass PartialLivestream:\n\t    \"\"\"\n\t    A dataclass which represents a partial livestream on kick.\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        The livestream's id\n", "    channel_id: int\n\t        The livestream's channel id\n\t    title: str\n\t        The livestream's title\n\t    created_at: datetime.datetime\n\t        When the livestream started\n\t    streamer: `User` | None\n\t        The livestream's streaner\n\t    \"\"\"\n\t    def __init__(self, *, data: PartialLivestreamPayload, http: HTTPClient) -> None:\n", "        self._data = data\n\t        self.http = http\n\t        self.id: int = data[\"id\"]\n\t        self.channel_id: int = data[\"channel_id\"]\n\t        self.title: str = data[\"session_title\"]\n\t    @cached_property\n\t    def created_at(self) -> datetime:\n\t        return datetime.fromisoformat(self._data[\"created_at\"])\n\t    @property\n\t    def streamer(self) -> User | None:\n", "        return self.http.client._watched_users.get(self.channel_id)\n\tclass Livestream(HTTPDataclass[\"LivestreamPayload\"]):\n\t    \"\"\"\n\t    A dataclass which represents a livestream on kick.\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        probably the livestream's id\n\t    slug: str\n\t        The streamer's slug\n", "    channel_id: int\n\t        probably the streamer's id or the chatroom id\n\t    created_at: datetime.datetime\n\t        When the livestream started\n\t    title: str\n\t        The livestream's title\n\t    is_live: bool\n\t        If the livestream is currently live\n\t    thumbnail: `Asset` | None\n\t        Returns the livestream's thumbnail if it has one\n", "    duration: int\n\t        Probably how long the livestream is/was in seconds\n\t    language: str\n\t        The language the livestream is in\n\t    is_mature: bool\n\t        If the livestream is marked as 18+\n\t    viewer_count: int\n\t        The amount of people currently watching\n\t    tags: list[str]\n\t        Tags applied to the livestream\n", "    url: str\n\t        The livestream's url\n\t    embed_url: str\n\t        The livestream's player/embed url\n\t    categories: list[`Category`]\n\t        The categories the livestream is in\n\t    \"\"\"\n\t    @property\n\t    def id(self) -> int:\n\t        \"\"\"\n", "        probably the livestream's id\n\t        \"\"\"\n\t        return self._data[\"id\"]\n\t    @property\n\t    def slug(self) -> str:\n\t        \"\"\"\n\t        The streamer's slug\n\t        \"\"\"\n\t        return self._data[\"slug\"]\n\t    @property\n", "    def channel_id(self) -> int:\n\t        \"\"\"\n\t        probably the streamer's id or the chatroom id\n\t        \"\"\"\n\t        return self._data[\"channel_id\"]\n\t    @cached_property\n\t    def created_at(self) -> datetime:\n\t        \"\"\"\n\t        When the livestream started\n\t        \"\"\"\n", "        return datetime.fromisoformat(self._data[\"created_at\"])\n\t    @property\n\t    def title(self) -> str:\n\t        \"\"\"\n\t        The livestream's title\n\t        \"\"\"\n\t        return self._data[\"session_title\"]\n\t    @property\n\t    def is_live(self) -> bool:\n\t        \"\"\"\n", "        If the livestream is currently live\n\t        \"\"\"\n\t        return self._data[\"is_live\"]\n\t    @cached_property\n\t    def thumbnail(self) -> Asset | None:\n\t        \"\"\"\n\t        Returns the livestream's thumbnail if it has one\n\t        \"\"\"\n\t        return (\n\t            None\n", "            if self._data[\"thumbnail\"] is None\n\t            else Asset(url=self._data[\"thumbnail\"][\"url\"], http=self.http)\n\t        )\n\t    @property\n\t    def duration(self) -> int:\n\t        \"\"\"\n\t        Probably how long the livestream is/was in seconds\n\t        \"\"\"\n\t        return self._data[\"duration\"]\n\t    @property\n", "    def language(self) -> str:\n\t        \"\"\"\n\t        The language the livestream is in\n\t        \"\"\"\n\t        return self._data[\"language\"]\n\t    @property\n\t    def is_mature(self) -> bool:\n\t        \"\"\"\n\t        If the livestream is marked as 18+\n\t        \"\"\"\n", "        return self._data[\"is_mature\"]\n\t    @property\n\t    def viewer_count(self) -> int:\n\t        \"\"\"\n\t        The amount of people currently watching\n\t        \"\"\"\n\t        return self._data[\"viewer_count\"]\n\t    @property\n\t    def tags(self) -> list[str]:\n\t        \"\"\"\n", "        Tags applied to the livestream\n\t        \"\"\"\n\t        return self._data[\"tags\"]\n\t    @cached_property\n\t    def url(self) -> str:\n\t        \"\"\"\n\t        The livestream's url\n\t        \"\"\"\n\t        return f\"https://kick.com/{self.slug}\"\n\t    @cached_property\n", "    def embed_url(self) -> str:\n\t        \"\"\"\n\t        The livestream's player/embed url\n\t        \"\"\"\n\t        return f\"https://player.kick.com/{self.slug}\"\n\t    @cached_property\n\t    def categories(self) -> list[Category]:\n\t        \"\"\"\n\t        The categories the livestream is in\n\t        \"\"\"\n", "        return [Category(data=c, http=self.http) for c in self._data[\"categories\"]]\n\t    def __eq__(self, other: object) -> bool:\n\t        return isinstance(other, self.__class__) and other.id == self.id\n\t    def __repr__(self) -> str:\n\t        return f\"<Livestream id={self.id} title={self.title} streamer={self.slug}>\"\n"]}
{"filename": "kick/errors.py", "chunked_list": ["__all__ = (\n\t    \"KickException\",\n\t    \"HTTPException\",\n\t    \"Forbidden\",\n\t    \"NotFound\",\n\t    \"InternalKickException\",\n\t    \"LoginFailure\",\n\t    \"CloudflareBypassException\",\n\t)\n\tclass CloudflareBypassException(Exception):\n", "    \"\"\"\n\t    This error is used when there is an error with the bypass script.\n\t    \"\"\"\n\tclass KickException(Exception):\n\t    \"\"\"\n\t    This error is used when there is an error with kick.\n\t    \"\"\"\n\tclass LoginFailure(KickException):\n\t    \"\"\"\n\t    This error is used when there is an error with logging in.\n", "    \"\"\"\n\tclass HTTPException(KickException):\n\t    \"\"\"\n\t    This error is used when an error is ran into when making a request to kick.\n\t    Attributes\n\t    -----------\n\t    status_code: int\n\t        The HTTP code\n\t    \"\"\"\n\t    def __init__(self, txt: str, status_code: int) -> None:\n", "        super().__init__(txt)\n\t        self.status_code = status_code\n\tclass Forbidden(HTTPException):\n\t    \"\"\"\n\t    This error is used when kick returns a 403 status code.\n\t    Attributes\n\t    -----------\n\t    status_code: int = 403\n\t        The HTTP code\n\t    \"\"\"\n", "    def __init__(self, txt: str = \"\") -> None:\n\t        super().__init__(txt, 403)\n\tclass NotFound(HTTPException):\n\t    \"\"\"\n\t    This error is used when kick returns a 404 status code.\n\t    Attributes\n\t    -----------\n\t    status_code: int = 404\n\t        The HTTP code\n\t    \"\"\"\n", "    def __init__(self, txt: str) -> None:\n\t        super().__init__(txt, 404)\n\tclass InternalKickException(HTTPException):\n\t    \"\"\"\n\t    This error is used when kick returns a a 500 status code, or doesn't connect.\n\t    Attributes\n\t    -----------\n\t    status_code: int = 500\n\t        The HTTP code\n\t    \"\"\"\n", "    def __init__(self, txt: str) -> None:\n\t        super().__init__(txt, 500)\n"]}
{"filename": "kick/client.py", "chunked_list": ["from __future__ import annotations\n\timport asyncio\n\timport logging\n\tfrom logging import getLogger\n\tfrom typing import TYPE_CHECKING, Any, Callable, Coroutine, TypeVar\n\tfrom .chatroom import Chatroom, PartialChatroom\n\tfrom .chatter import PartialChatter\n\tfrom .http import HTTPClient\n\tfrom .livestream import PartialLivestream\n\tfrom .message import Message\n", "from .users import ClientUser, PartialUser, User\n\tfrom .utils import MISSING, decorator, setup_logging\n\tif TYPE_CHECKING:\n\t    from typing_extensions import Self\n\tEventT = TypeVar(\"EventT\", bound=Callable[..., Coroutine[Any, Any, None]])\n\tLOGGER = getLogger(__name__)\n\t__all__ = (\"Credentials\", \"Client\")\n\tclass Credentials:\n\t    \"\"\"\n\t    This holds credentials that can be used to authenticate yourself with kick.\n", "    Parameters\n\t    -----------\n\t    username: Optional[str]\n\t        The username to login with. Can not be used with the `email` arg\n\t    email: Optional[str]\n\t        The email to login with. Can not be used with the `username` arg\n\t    password: str\n\t        The account's password\n\t    one_time_password: Optional[str]\n\t        The 2FA code to login with\n", "    Attributes\n\t    -----------\n\t    username: Optional[str]\n\t        The username to login with. Can not be used with the `email` arg\n\t    email: Optional[str]\n\t        The email to login with. Can not be used with the `username` arg\n\t    password: str\n\t        The account's password\n\t    one_time_password: Optional[str]\n\t        The 2FA code to login with\n", "    \"\"\"\n\t    def __init__(\n\t        self,\n\t        *,\n\t        username: str = MISSING,\n\t        email: str = MISSING,\n\t        password: str,\n\t        one_time_password: str | None = None,\n\t    ) -> None:\n\t        if username is MISSING and email is MISSING:\n", "            raise ValueError(\"Provide either a `username` or `email` arg\")\n\t        elif username is not MISSING and email is not MISSING:\n\t            raise ValueError(\"Provide `username` or `email`, not both.\")\n\t        self.email: str = username or email\n\t        self.username_was_provided: bool = username is not MISSING\n\t        self.password: str = password\n\t        self.one_time_password: str | None = one_time_password\n\tclass Client:\n\t    \"\"\"\n\t    This repersents the Client you can use to interact with kick.\n", "    Parameters\n\t    -----------\n\t    **options: Any\n\t        Options that can be passed\n\t    Options\n\t    -----------\n\t    whitelisted: bool = False\n\t        If you have been api whitelisted. If set to True, the bypass script will not be used.\n\t    bypass_port: int = 9090\n\t        The port the bypass script is running on. Defaults to 9090\n", "    bypass_host: str = \"http://localhost\"\n\t        The host of the bypass script.\n\t    Attributes\n\t    -----------\n\t    user: ClientUser | None\n\t        The user you are logged in as. It is `None` until `Client.login` is called.\n\t    \"\"\"\n\t    def __init__(self, **options: Any) -> None:\n\t        self._options = options\n\t        self.http = HTTPClient(self)\n", "        self._chatrooms: dict[int, Chatroom | PartialChatroom] = {}\n\t        self._watched_users: dict[int, User] = {}\n\t        self.user: ClientUser | None = None\n\t        LOGGER.warning(\n\t            \"Kick's api is undocumented, possible unstable, and can change at any time without warning\"\n\t        )\n\t    def get_partial_chatroom(\n\t        self, chatroom_id: int, streamer_name: str\n\t    ) -> PartialChatroom:\n\t        \"\"\"\n", "        Gets a partial chatroom.\n\t        Parameters\n\t        -----------\n\t        chatroom_id: int\n\t            The id of the chatroom you want to connect to\n\t        streamer_name: str\n\t            The name of the streamer who's chatroom it is\n\t        Returns\n\t        -----------\n\t        `PartialChatroom`\n", "            The partial chatroom\n\t        \"\"\"\n\t        return PartialChatroom(\n\t            id=chatroom_id, streamer_name=streamer_name, http=self.http\n\t        )\n\t    def get_chatroom(self, chatroom_id: int, /) -> PartialChatroom | Chatroom | None:\n\t        \"\"\"\n\t        Gets a chatroom out of a cache that contains chatrooms that you are connected to.\n\t        Parameters\n\t        -----------\n", "        chatroom_id: int\n\t            The chatroom's id\n\t        Returns\n\t        -----------\n\t        Chatroom | None\n\t            Either the chatroom, or None\n\t        \"\"\"\n\t        return self._chatrooms.get(chatroom_id)\n\t    def get_partial_user(self, *, username: str, id: int) -> PartialUser:\n\t        \"\"\"\n", "        Gets a partial user instance by the username and id provided.\n\t        Parameters\n\t        -----------\n\t        username: str\n\t            The user's name\n\t        id: int\n\t            The user's id\n\t        Returns\n\t        -----------\n\t        `PartialUser`\n", "            The partial user\n\t        \"\"\"\n\t        return PartialUser(username=username, id=id, http=self.http)\n\t    def get_partial_chatter(\n\t        self, *, streamer_name: str, chatter_name: str\n\t    ) -> PartialChatter:\n\t        \"\"\"\n\t        Gets a partial chatter instance by the streamer and chatter names provided.\n\t        Parameters\n\t        -----------\n", "        streamer_name: str\n\t            The streamer's username or slug\n\t        chatter_name: str\n\t            The chatter's username or slug\n\t        Returns\n\t        -----------\n\t        `PartialChatter`\n\t            The partial chatter\n\t        \"\"\"\n\t        return PartialChatter(\n", "            streamer_name=streamer_name, chatter_name=chatter_name, http=self.http\n\t        )\n\t    async def fetch_user(self, name: str, /) -> User:\n\t        \"\"\"\n\t        |coro|\n\t        Fetches a user from the API.\n\t        Parameters\n\t        -----------\n\t        name: str\n\t            The user's slug or username\n", "        Raises\n\t        -----------\n\t        HTTPException\n\t            Fetching Failed\n\t        NotFound\n\t            No user with the username/slug exists\n\t        Returns\n\t        -----------\n\t        User\n\t            The user object associated with the streamer\n", "        \"\"\"\n\t        data = await self.http.get_user(name)\n\t        user = User(data=data, http=self.http)\n\t        return user\n\t    def dispatch(self, event_name: str, *args, **kwargs) -> None:\n\t        event_name = f\"on_{event_name}\"\n\t        event = getattr(self, event_name, None)\n\t        if event is not None:\n\t            asyncio.create_task(\n\t                event(*args, **kwargs), name=f\"event-dispatch: {event_name}\"\n", "            )\n\t    @decorator\n\t    def event(self, coro: EventT) -> EventT:\n\t        \"\"\"\n\t        Lets you set an event outside of a subclass.\n\t        \"\"\"\n\t        setattr(self, coro.__name__, coro)\n\t        return coro\n\t    async def login(self, credentials: Credentials) -> None:\n\t        \"\"\"\n", "        |coro|\n\t        Authenticates yourself, and fills `Client.user`\n\t        Unlike `Client.start`, this does not start the websocket\n\t        Parameters\n\t        -----------\n\t        credentials: Credentials\n\t            The credentials to authenticate yourself with\n\t        \"\"\"\n\t        await self.http.login(credentials)\n\t        data = await self.http.get_me()\n", "        self.user = ClientUser(data=data, http=self.http)\n\t    async def start(self, credentials: Credentials | None = None) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Starts the websocket so you can receive events\n\t        And authenticate yourself if credentials are provided.\n\t        Parameters\n\t        -----------\n\t        credentials: Optional[Credentials]\n\t            The credentials to authenticate yourself with, if any\n", "        \"\"\"\n\t        if credentials is not None:\n\t            await self.login(credentials)\n\t        await self.http.start()\n\t    async def close(self) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Closes the HTTPClient, no requests can be made after this.\n\t        \"\"\"\n\t        await self.http.close()\n", "    async def __aenter__(self) -> Self:\n\t        return self\n\t    async def __aexit__(self, exc_type, exc, tb) -> None:\n\t        await self.close()\n\t    async def on_ready(self) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        on_ready is an event that can be overriden with the `Client.event` decorator or with a subclass.\n\t        This is called after the client has started the websocket and is receiving events.\n\t        \"\"\"\n", "    async def on_message(self, message: Message) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        on_ready is an event that can be overriden with the `Client.event` decorator or with a subclass.\n\t        This is called when a message is received over the websocket\n\t        Parameters\n\t        -----------\n\t        message: `Message`\n\t            The message that was received\n\t        \"\"\"\n", "    async def on_payload_receive(self, event: str, payload: dict) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        on_payload_receive is an event that can be overriden with the `Client.event` decorator or with a subclass.\n\t        This is called when an event is received from the websocket.\n\t        Parameters\n\t        -----------\n\t        event: str\n\t            The payload's event\n\t        payload: dict\n", "            The payload\n\t        \"\"\"\n\t    async def on_livestream_start(self, livestream: PartialLivestream) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        on_livestream_start is an event that can be overriden with the `Client.event` decorator or with a subclass.\n\t        This is called when a user that is being watched starts streaming\n\t        Parameters\n\t        -----------\n\t        livestream: `PartialLivestream`\n", "            The livestream\n\t        \"\"\"\n\t    async def on_follow(self, streamer: User) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        on_livestream_start is an event that can be overriden with the `Client.event` decorator or with a subclass.\n\t        This is called when someone starts following a streamer that is being watched.\n\t        Parameters\n\t        -----------\n\t        streamer: `User`\n", "            The streamer\n\t        \"\"\"\n\t    async def on_unfollow(self, streamer: User) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        on_livestream_start is an event that can be overriden with the `Client.event` decorator or with a subclass.\n\t        This is called when someone stops following a streamer that is being watched.\n\t        Parameters\n\t        -----------\n\t        streamer: `PartialLivestream`\n", "            The streamer\n\t        \"\"\"\n\t    def run(\n\t        self,\n\t        credentials: Credentials | None = None,\n\t        *,\n\t        handler: logging.Handler = MISSING,\n\t        formatter: logging.Formatter = MISSING,\n\t        level: int = MISSING,\n\t        root: bool = True,\n", "        stream_supports_colour: bool = False,\n\t    ) -> None:\n\t        \"\"\"\n\t        Starts the websocket so you can receive events\n\t        And authenticate yourself if credentials are provided.\n\t        `Client.run` automatically calls `utils.setup_logging` with the provided kwargs, and calls `Client.start`.\n\t        Parameters\n\t        -----------\n\t        credentials: Optional[Credentials]\n\t            The credentials to authenticate yourself with, if any\n", "        \"\"\"\n\t        setup_logging(\n\t            handler=handler,\n\t            formatter=formatter,\n\t            level=level,\n\t            root=root,\n\t            stream_supports_colour=stream_supports_colour,\n\t        )\n\t        asyncio.run(self.start(credentials))\n"]}
{"filename": "kick/message.py", "chunked_list": ["from __future__ import annotations\n\tfrom datetime import datetime\n\tfrom typing import TYPE_CHECKING\n\tfrom .object import HTTPDataclass\n\tfrom .users import PartialUser, User\n\tfrom .utils import cached_property\n\tif TYPE_CHECKING:\n\t    from .chatroom import Chatroom, PartialChatroom\n\t    from .types.message import AuthorPayload, MessagePayload, ReplyMetaData\n\t__all__ = (\"Author\", \"Message\", \"PartialMessage\")\n", "class Author(HTTPDataclass[\"AuthorPayload\"]):\n\t    \"\"\"\n\t    Represents the author of a message on kick\n\t    Attributes\n\t    -----------\n\t    id: int\n\t        The author's id\n\t    slug: str\n\t        The author's slug\n\t    color: str\n", "        The authors... color?\n\t    badges: list\n\t        Unknown\n\t    \"\"\"\n\t    @property\n\t    def id(self) -> int:\n\t        \"\"\"\n\t        The author's id\n\t        \"\"\"\n\t        return self._data[\"id\"]\n", "    @property\n\t    def slug(self) -> str:\n\t        \"\"\"\n\t        The author's slug\n\t        \"\"\"\n\t        return self._data[\"slug\"]\n\t    @property\n\t    def color(self) -> str:\n\t        \"\"\"\n\t        The authors... color?\n", "        \"\"\"\n\t        return self._data[\"identity\"][\"color\"]\n\t    @property\n\t    def badges(self) -> list:\n\t        \"\"\"THIS IS RAW DATA\"\"\"\n\t        return self._data[\"identity\"][\"badges\"]\n\t    async def to_user(self) -> User:\n\t        \"\"\"\n\t        |coro|\n\t        Fetches a user object for the author\n", "        Raises\n\t        -----------\n\t        `HTTPException`\n\t            Fetching the user failed\n\t        `NotFound`\n\t            User Not Found\n\t        Returns\n\t        -----------\n\t        `User`\n\t            The user\n", "        \"\"\"\n\t        return await self.http.client.fetch_user(self.slug)\n\t    def __eq__(self, other: object) -> bool:\n\t        return isinstance(other, self.__class__) and other.id == self.id\n\t    def __str__(self) -> str:\n\t        return self.slug\n\t    def __repr__(self) -> str:\n\t        return f\"<Author id={self.id!r} slug={self.slug!r}>\"\n\tclass PartialMessage(HTTPDataclass[\"ReplyMetaData\"]):\n\t    \"\"\"\n", "    This represents a partial message. Mainly used as the message someone is replying too.\n\t    Attributes\n\t    -----------\n\t    id: str\n\t        The message's id\n\t    content: str\n\t        The message's content\n\t    author: `PartialUser`\n\t        The message's author\n\t    \"\"\"\n", "    @property\n\t    def id(self) -> str:\n\t        \"\"\"\n\t        The message's id\n\t        \"\"\"\n\t        return self._data[\"original_message\"][\"id\"]\n\t    @property\n\t    def content(self) -> str:\n\t        \"\"\"\n\t        The message's content\n", "        \"\"\"\n\t        return self._data[\"original_message\"][\"content\"]\n\t    @cached_property\n\t    def author(self) -> PartialUser:\n\t        \"\"\"\n\t        The message's author\n\t        \"\"\"\n\t        return PartialUser(\n\t            id=int(self._data[\"original_sender\"][\"id\"]),\n\t            username=self._data[\"original_sender\"][\"username\"],\n", "            http=self.http,\n\t        )\n\t    def __eq__(self, other: object) -> bool:\n\t        return isinstance(other, self.__class__) and other.id == self.id\n\t    def __repr__(self) -> str:\n\t        return f\"<Message id={self.id!r} author={self.author!r}>\"\n\tclass Message(HTTPDataclass[\"MessagePayload\"]):\n\t    \"\"\"\n\t    Represents a message sent on kick\n\t    Attributes\n", "    -----------\n\t    id: str\n\t        the message's id\n\t    is_reply: bool\n\t        If the message is replying to any message\n\t    references: `PartialMessage` | None\n\t        If the message is replying to a message, a `PartialMessage` object is returned. Otherwise None\n\t    chatroom_id: int\n\t        The id of the chatroom the message was sent in\n\t    chatroom: `Chatroom` | None\n", "        The chatroom the message was sent in.\n\t    content: str\n\t        The message's content\n\t    created_at: datetime.datetime\n\t        When the message was sent\n\t    author: `Author`\n\t        The message's author\n\t    \"\"\"\n\t    @property\n\t    def id(self) -> str:\n", "        \"\"\"\n\t        the message's id\n\t        \"\"\"\n\t        return self._data[\"id\"]\n\t    @cached_property\n\t    def is_reply(self) -> bool:\n\t        \"\"\"\n\t        If the message is replying to any message\n\t        \"\"\"\n\t        return bool(self._data.get(\"metadata\"))\n", "    @cached_property\n\t    def references(self) -> PartialMessage | None:\n\t        \"\"\"\n\t        If the message is replying to a message, a `PartialMessage` object is returned. Otherwise None\n\t        \"\"\"\n\t        data = self._data.get(\"metadata\")\n\t        if not data:\n\t            return\n\t        return PartialMessage(data=data, http=self.http)\n\t    @property\n", "    def chatroom_id(self) -> int:\n\t        \"\"\"\n\t        The id of the chatroom the message was sent in\n\t        \"\"\"\n\t        return self._data[\"chatroom_id\"]\n\t    @property\n\t    def chatroom(self) -> Chatroom | PartialChatroom | None:\n\t        \"\"\"\n\t        The chatroom the message was sent in.\n\t        \"\"\"\n", "        return self.http.client.get_chatroom(self.chatroom_id)\n\t    @property\n\t    def content(self) -> str:\n\t        \"\"\"\n\t        The message's content\n\t        \"\"\"\n\t        return self._data[\"content\"]\n\t    @cached_property\n\t    def created_at(self) -> datetime:\n\t        \"\"\"\n", "        When the message was sent\n\t        \"\"\"\n\t        return datetime.fromisoformat(self._data[\"created_at\"])\n\t    @cached_property\n\t    def author(self) -> Author:\n\t        \"\"\"\n\t        The message's author\n\t        \"\"\"\n\t        return Author(data=self._data[\"sender\"], http=self.http)\n\t    def __eq__(self, other: object) -> bool:\n", "        return isinstance(other, self.__class__) and other.id == self.id\n\t    def __repr__(self) -> str:\n\t        return f\"<Message id={self.id!r} chatroom={self.chatroom_id!r} author={self.author!r}>\"\n"]}
{"filename": "kick/leaderboard.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom .object import BaseDataclass\n\tfrom .utils import cached_property\n\tif TYPE_CHECKING:\n\t    from .types.leaderboard import GiftEntryPayload, LeaderboardPayload\n\t    from .users import AnyUser\n\t__all__ = (\"GiftLeaderboard\", \"GiftLeaderboardEntry\")\n\tclass GiftLeaderboardEntry(BaseDataclass[\"GiftEntryPayload\"]):\n\t    \"\"\"\n", "    This dataclass represents a gift leaderboard entry.\n\t    Attributes\n\t    -----------\n\t    user_id: int\n\t        The id of the user with this entry\n\t    quantity: int\n\t        The amount of subs this person has gifted\n\t    username: str\n\t        The user's username\n\t    \"\"\"\n", "    @property\n\t    def user_id(self) -> int:\n\t        \"\"\"\n\t        The id of the user with this entry\n\t        \"\"\"\n\t        return self._data[\"user_id\"]\n\t    @property\n\t    def quantity(self) -> int:\n\t        \"\"\"\n\t        The amount of subs this person has gifted\n", "        \"\"\"\n\t        return self._data[\"quantity\"]\n\t    @property\n\t    def username(self) -> str:\n\t        \"\"\"\n\t        The user's username\n\t        \"\"\"\n\t        return self._data[\"username\"]\n\t    def __repr__(self) -> str:\n\t        return f\"<GiftLeaderboardEntry uid={self.user_id!r} quantity={self.quantity!r} username={self.username!r}>\"\n", "class GiftLeaderboard(BaseDataclass[\"LeaderboardPayload\"]):\n\t    \"\"\"\n\t    This is a dataclass which reprsents the gift leaderboard for a kick streamer.\n\t    Attributes\n\t    -----------\n\t    streamer: `User`\n\t        The streamer that the leaderboard is for\n\t    this_week: list[`GiftLeaderboardEntry`]\n\t        The gift leaderboard for the current week\n\t    this_month: list[`GiftLeaderboardEntry`]\n", "        The gift leaderboard for the current month\n\t    all_time: list[`GiftLeaderboardEntry`]\n\t        The gift leaderboard for all time\n\t    \"\"\"\n\t    streamer: AnyUser\n\t    @cached_property\n\t    def this_week(self) -> list[GiftLeaderboardEntry]:\n\t        return [GiftLeaderboardEntry(data=c) for c in self._data[\"gifts_week\"]]\n\t    @cached_property\n\t    def this_month(self) -> list[GiftLeaderboardEntry]:\n", "        return [GiftLeaderboardEntry(data=c) for c in self._data[\"gifts_month\"]]\n\t    @cached_property\n\t    def all_time(self) -> list[GiftLeaderboardEntry]:\n\t        return [GiftLeaderboardEntry(data=c) for c in self._data[\"gifts\"]]\n\t    def __repr__(self) -> str:\n\t        return f\"<GiftLeaderboard streamer={self.streamer.username!r} weekly_entries={len(self.this_week)} monthly_entries={len(self.this_month)} all_time_etries={len(self.all_time)}>\"\n"]}
{"filename": "kick/object.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING, Generic, TypeVar\n\tDataT = TypeVar(\"DataT\")\n\tif TYPE_CHECKING:\n\t    from .http import HTTPClient\n\t__all__ = (\"BaseDataclass\", \"HTTPDataclass\")\n\tclass BaseDataclass(Generic[DataT]):\n\t    def __init__(self, *, data: DataT) -> None:\n\t        self._data = data\n\t    def __repr__(self) -> str:\n", "        return f\"<{self.__class__.__name__}>\"\n\tclass HTTPDataclass(Generic[DataT]):\n\t    def __init__(self, *, data: DataT, http: HTTPClient) -> None:\n\t        self._data = data\n\t        self.http = http\n\t    def __repr__(self) -> str:\n\t        return f\"<{self.__class__.__name__}>\"\n"]}
{"filename": "kick/enums.py", "chunked_list": ["from enum import Enum\n\t__all__ = (\"ChatroomChatMode\",)\n\tclass ChatroomChatMode(Enum):\n\t    \"\"\"\n\t    An enum containing possble chatroom chat mode values.\n\t    Attributes\n\t    -----------\n\t    public: `ChatroomChatMode`\n\t        The public value\n\t    privet: `ChatroomChatMode`\n", "        The privet value\n\t    \"\"\"\n\t    public = \"public\"\n\t    privet = \"privet\"\n"]}
{"filename": "kick/__init__.py", "chunked_list": ["\"\"\"\n\tKick API Wrapper\n\t~~~~~~~~~~~~~~~~~~~\n\tA basic wrapper for the Kick API.\n\t\"\"\"\n\t__version__ = \"0.0.2a\"\n\tfrom typing import Any, Literal, NamedTuple\n\tfrom .assets import *\n\tfrom .badges import *\n\tfrom .categories import *\n", "from .chatroom import *\n\tfrom .chatter import *\n\tfrom .client import *\n\tfrom .emotes import *\n\tfrom .enums import *\n\tfrom .errors import *\n\tfrom .leaderboard import *\n\tfrom .livestream import *\n\tfrom .message import *\n\tfrom .object import *\n", "from .polls import *\n\tfrom .users import *\n\tfrom .videos import *\n\tclass VersionInfo(NamedTuple):\n\t    major: int\n\t    minor: int\n\t    micro: int\n\t    releaselevel: Literal[\"alpha\", \"beta\", \"candidate\", \"final\"]\n\t    serial: int\n\t    @classmethod\n", "    def from_version(cls, ver: str):\n\t        major, minor, micro = ver.split(\".\")\n\t        releaselevel: Any = \"f\"\n\t        if not micro.isdigit():\n\t            releaselevel = micro[-1]\n\t            micro = micro.removesuffix(releaselevel)\n\t        self = cls(\n\t            major=int(major),\n\t            minor=int(minor),\n\t            micro=int(micro),\n", "            releaselevel={\n\t                \"a\": \"alpha\",\n\t                \"b\": \"beta\",\n\t                \"c\": \"candidate\",\n\t                \"f\": \"final\",\n\t            }.get(\n\t                releaselevel, \"final\"\n\t            ),  # type: ignore\n\t            serial=0,\n\t        )\n", "        return self\n\tversion_info: VersionInfo = VersionInfo.from_version(__version__)\n\tdel NamedTuple, Literal, VersionInfo, Any\n"]}
{"filename": "kick/utils.py", "chunked_list": ["from __future__ import annotations\n\timport logging\n\tfrom functools import wraps\n\tfrom typing import TYPE_CHECKING, Any, Callable, Type\n\tdef _cached_property(func: Callable):\n\t    @wraps(func)\n\t    def getter(parent: Type):\n\t        cache = getattr(parent, \"__cached_properties\", {})\n\t        if func.__name__ not in cache.keys():\n\t            cache[func.__name__] = func(parent)\n", "            parent.__cached_properties = cache\n\t        return parent.__cached_properties[func.__name__]\n\t    return property(getter)\n\tif TYPE_CHECKING:\n\t    from functools import cached_property as cached_property\n\t    from typing import TypeVar\n\t    FuncT = TypeVar(\"FuncT\", bound=Callable)\n\telse:\n\t    cached_property = _cached_property\n\t__all__ = (\"MISSING\", \"cached_property\", \"setup_logging\")\n", "class _MissingSentinel:\n\t    __slots__ = ()\n\t    def __eq__(self, other) -> bool:\n\t        return False\n\t    def __bool__(self) -> bool:\n\t        return False\n\t    def __hash__(self) -> int:\n\t        return 0\n\t    def __repr__(self):\n\t        return \"...\"\n", "MISSING: Any = _MissingSentinel()\n\tdef decorator(func: FuncT) -> FuncT:\n\t    func.__is_decorator__ = True\n\t    return func\n\tclass _ColourFormatter(logging.Formatter):\n\t    # ANSI codes are a bit weird to decipher if you're unfamiliar with them, so here's a refresher\n\t    # It starts off with a format like \\x1b[XXXm where XXX is a semicolon separated list of commands\n\t    # The important ones here relate to colour.\n\t    # 30-37 are black, red, green, yellow, blue, magenta, cyan and white in that order\n\t    # 40-47 are the same except for the background\n", "    # 90-97 are the same but \"bright\" foreground\n\t    # 100-107 are the same as the bright ones but for the background.\n\t    # 1 means bold, 2 means dim, 0 means reset, and 4 means underline.\n\t    LEVEL_COLOURS = [\n\t        (logging.DEBUG, \"\\x1b[40;1m\"),\n\t        (logging.INFO, \"\\x1b[34;1m\"),\n\t        (logging.WARNING, \"\\x1b[33;1m\"),\n\t        (logging.ERROR, \"\\x1b[31m\"),\n\t        (logging.CRITICAL, \"\\x1b[41m\"),\n\t    ]\n", "    FORMATS = {\n\t        level: logging.Formatter(\n\t            f\"\\x1b[30;1m%(asctime)s\\x1b[0m {colour}%(levelname)-8s\\x1b[0m \\x1b[35m%(name)s\\x1b[0m %(message)s\",\n\t            \"%Y-%m-%d %H:%M:%S\",\n\t        )\n\t        for level, colour in LEVEL_COLOURS\n\t    }\n\t    def format(self, record):\n\t        formatter = self.FORMATS.get(record.levelno)\n\t        if formatter is None:\n", "            formatter = self.FORMATS[logging.DEBUG]\n\t        # Override the traceback to always print in red\n\t        if record.exc_info:\n\t            text = formatter.formatException(record.exc_info)\n\t            record.exc_text = f\"\\x1b[31m{text}\\x1b[0m\"\n\t        output = formatter.format(record)\n\t        # Remove the cache layer\n\t        record.exc_text = None\n\t        return output\n\tdef setup_logging(\n", "    *,\n\t    handler: logging.Handler = MISSING,\n\t    formatter: logging.Formatter = MISSING,\n\t    level: int = MISSING,\n\t    root: bool = True,\n\t    stream_supports_colour: bool = False,\n\t) -> None:\n\t    if level is MISSING:\n\t        level = logging.INFO\n\t    if handler is MISSING:\n", "        handler = logging.StreamHandler()\n\t    if formatter is MISSING:\n\t        if (\n\t            isinstance(handler, logging.StreamHandler)\n\t            and stream_supports_colour is True\n\t        ):\n\t            formatter = _ColourFormatter()\n\t        else:\n\t            dt_fmt = \"%Y-%m-%d %H:%M:%S\"\n\t            formatter = logging.Formatter(\n", "                \"[{asctime}] [{levelname:<8}] {name}: {message}\", dt_fmt, style=\"{\"\n\t            )\n\t    if root:\n\t        logger = logging.getLogger()\n\t    else:\n\t        library, _, _ = __name__.partition(\".\")\n\t        logger = logging.getLogger(library)\n\t    handler.setFormatter(formatter)\n\t    logger.setLevel(level)\n\t    logger.addHandler(handler)\n"]}
{"filename": "kick/chatter.py", "chunked_list": ["from __future__ import annotations\n\tfrom datetime import datetime\n\tfrom typing import TYPE_CHECKING\n\tfrom .assets import Asset\n\tfrom .badges import ChatBadge\n\tfrom .users import User\n\tfrom .utils import cached_property\n\tif TYPE_CHECKING:\n\t    from .chatroom import Chatroom, PartialChatroom\n\t    from .http import HTTPClient\n", "    from .types.user import ChatterPayload\n\t__all__ = (\"Chatter\", \"PartialChatter\")\n\tclass PartialChatter:\n\t    \"\"\"\n\t    This represents a partial user.\n\t    Attributes\n\t    -----------\n\t    streamer_name: str\n\t        The streamer's name\n\t    username: str\n", "        The chatter's username\n\t    \"\"\"\n\t    def __init__(\n\t        self, *, streamer_name: str, chatter_name: str, http: HTTPClient\n\t    ) -> None:\n\t        self.streamer_name = streamer_name\n\t        self.username = chatter_name\n\t        self.http = http\n\t    async def to_user(self) -> User:\n\t        \"\"\"\n", "        |coro|\n\t        Fetches a user object for the chatter\n\t        Raises\n\t        -----------\n\t        `HTTPException`\n\t            Fetching the user failed\n\t        `NotFound`\n\t            User not found\n\t        Returns\n\t        -----------\n", "        `User`\n\t            The user\n\t        \"\"\"\n\t        data = await self.http.get_user(self.username)\n\t        user = User(data=data, http=self.http)\n\t        return user\n\t    async def ban(self, reason: str) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Permanently bans a user from a chatroom.\n", "        Parameters\n\t        -----------\n\t        reason: str\n\t            The reason for the ban\n\t        Raises\n\t        -----------\n\t        `HTTPException`\n\t            Banning the user failed\n\t        `Forbidden`\n\t            You are unauthorized from banning the user\n", "        `NotFound`\n\t            Streamer or user not found\n\t        \"\"\"\n\t        await self.http.ban_chatter(self.streamer_name, self.username, reason)\n\t    async def timeout(self, duration: int, *, reason: str) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Times out a user for a given amount of time.\n\t        Parameters\n\t        -----------\n", "        duration: int\n\t            The amount of seconds for the timeout to be\n\t        reason: str\n\t            The reason for the timeout\n\t        Raises\n\t        -----------\n\t        `HTTPException`\n\t            timing out the user failed\n\t        `Forbidden`\n\t            You are unauthorized from timing out the user\n", "        `NotFound`\n\t            Streamer or user not found\n\t        \"\"\"\n\t        await self.http.timeout_chatter(\n\t            self.streamer_name, self.username, reason, duration\n\t        )\n\t    async def unban(self) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Unbans the chatter from the chatroom\n", "        Raises\n\t        -----------\n\t        `HTTPException`\n\t            Unbanning the user failed\n\t        `Forbidden`\n\t            You are unauthorized from unbanning the user\n\t        `NotFound`\n\t            Streamer or user not found\n\t        \"\"\"\n\t        await self.http.unban_user(self.streamer_name, self.username)\n", "    async def untimeout(self) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        untimeout's the chatter\n\t        Raises\n\t        -----------\n\t        `HTTPException`\n\t            untimeouting the user failed\n\t        `Forbidden`\n\t            You are unauthorized from untimeouting the user\n", "        `NotFound`\n\t            Streamer or user not found\n\t        \"\"\"\n\t        await self.http.unban_user(self.streamer_name, self.username)\n\t    def __eq__(self, other: object) -> bool:\n\t        return isinstance(other, self.__class__) and other.username == self.username\n\t    def __str__(self) -> str:\n\t        return self.username\n\t    def __repr__(self) -> str:\n\t        return f\"<PartialChatter username={self.username!r} streamer_name={self.streamer_name!r}>\"\n", "class Chatter(PartialChatter):\n\t    \"\"\"\n\t    A dataclass which respresents a chatter on kick\n\t    Attributes\n\t    -----------\n\t    chatroom: Chatroom\n\t        The chatroom the chatter is in\n\t    id: int\n\t        The chatter's id\n\t    username: str\n", "        The chatter's username\n\t    slug: str\n\t        The chatter' slug\n\t    avatar: `Asset` | None\n\t        The chatter's avatar, if any\n\t    is_staff: bool\n\t        If the chatter is a staff member in the chatroom\n\t    is_owner: bool\n\t        If the chatter is the chatroom owner\n\t    is_mod: bool\n", "        If the chatter is a mod in the chatroom\n\t    badges: list[`ChatBadge`]\n\t        The chat badges the chatter has\n\t    following_since: datetime.datetime | None\n\t        when the chatter started following the streamer\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        *,\n\t        data: ChatterPayload,\n", "        http: HTTPClient,\n\t        chatroom: Chatroom | PartialChatroom,\n\t    ) -> None:\n\t        self._data = data\n\t        self.chatroom: Chatroom | PartialChatroom = chatroom\n\t        super().__init__(\n\t            streamer_name=chatroom.streamer_name,\n\t            chatter_name=data[\"username\"],\n\t            http=http,\n\t        )\n", "    @property\n\t    def id(self) -> int:\n\t        \"\"\"\n\t        The chatter's id\n\t        \"\"\"\n\t        return self._data[\"id\"]\n\t    @property\n\t    def slug(self) -> str:\n\t        \"\"\"\n\t        The chatter' slug\n", "        \"\"\"\n\t        return self._data[\"slug\"]\n\t    @cached_property\n\t    def avatar(self) -> Asset | None:\n\t        \"\"\"\n\t        The chatter's avatar, if any\n\t        \"\"\"\n\t        return (\n\t            None\n\t            if self._data[\"profile_pic\"] is None\n", "            else Asset(url=self._data[\"profile_pic\"], http=self.http)\n\t        )\n\t    @property\n\t    def is_staff(self) -> bool:\n\t        \"\"\"\n\t        If the chatter is a staff member in the chatroom\n\t        \"\"\"\n\t        return self._data[\"is_staff\"]\n\t    @property\n\t    def is_owner(self) -> bool:\n", "        \"\"\"\n\t        If the chatter is the chatroom owner\n\t        \"\"\"\n\t        return self._data[\"is_channel_owner\"]\n\t    @property\n\t    def is_mod(self) -> bool:\n\t        \"\"\"\n\t        If the chatter is a mod in the chatroom\n\t        \"\"\"\n\t        return self._data[\"is_moderator\"]\n", "    @cached_property\n\t    def badges(self) -> list[ChatBadge]:\n\t        \"\"\"\n\t        The chat badges the chatter has\n\t        \"\"\"\n\t        return [ChatBadge(data=c) for c in self._data[\"badges\"]]\n\t    @cached_property\n\t    def following_since(self) -> datetime | None:\n\t        \"\"\"\n\t        when the chatter started following the streamer\n", "        \"\"\"\n\t        raw = self._data[\"following_since\"]\n\t        if raw is None:\n\t            return\n\t        else:\n\t            return datetime.fromisoformat(raw)\n\t    @property\n\t    def subscribed_for(self) -> int:\n\t        \"\"\"\n\t        The amount of months the user has been subscribed for\n", "        \"\"\"\n\t        return self._data[\"subscribed_for\"]\n\t    def __eq__(self, other: object) -> bool:\n\t        return isinstance(other, self.__class__) and other.id == self.id\n\t    def __repr__(self) -> str:\n\t        return f\"<Chatter id={self.id!r} username={self.username!r} avatar={self.avatar!r} is_staff={self.is_staff!r} is_owner={self.is_owner!r} is_mod={self.is_mod!r}>\"\n"]}
{"filename": "kick/ws.py", "chunked_list": ["from __future__ import annotations\n\timport json\n\tfrom typing import TYPE_CHECKING\n\tfrom aiohttp import ClientWebSocketResponse as WebSocketResponse\n\tfrom .livestream import PartialLivestream\n\tfrom .message import Message\n\tif TYPE_CHECKING:\n\t    from .http import HTTPClient\n\t__all__ = ()\n\tclass PusherWebSocket:\n", "    def __init__(self, ws: WebSocketResponse, *, http: HTTPClient):\n\t        self.ws = ws\n\t        self.http = http\n\t        self.send_json = ws.send_json\n\t        self.close = ws.close\n\t    async def poll_event(self) -> None:\n\t        raw_msg = await self.ws.receive()\n\t        raw_data = raw_msg.json()\n\t        data = json.loads(raw_data[\"data\"])\n\t        self.http.client.dispatch(\"payload_receive\", raw_data[\"event\"], data)\n", "        self.http.client.dispatch(\"raw_payload_receive\", raw_data)\n\t        match raw_data[\"event\"]:\n\t            case \"App\\\\Events\\\\ChatMessageEvent\":\n\t                msg = Message(data=data, http=self.http)\n\t                self.http.client.dispatch(\"message\", msg)\n\t            case \"App\\\\Events\\\\StreamerIsLive\":\n\t                livestream = PartialLivestream(data=data, http=self.http)\n\t                self.http.client.dispatch(\"livestream_start\", livestream)\n\t            case \"App\\\\Events\\\\FollowersUpdated\":\n\t                user = self.http.client._watched_users[data[\"channel_id\"]]\n", "                if data[\"followed\"] is True:\n\t                    event = \"follow\"\n\t                    user._data[\"followers_count\"] += 1\n\t                else:\n\t                    event = \"unfollow\"\n\t                    user._data[\"followers_count\"] -= 1\n\t                self.http.client.dispatch(event, user)\n\t    async def start(self) -> None:\n\t        while not self.ws.closed:\n\t            await self.poll_event()\n", "    async def subscribe_to_chatroom(self, chatroom_id: int) -> None:\n\t        await self.send_json(\n\t            {\n\t                \"event\": \"pusher:subscribe\",\n\t                \"data\": {\"auth\": \"\", \"channel\": f\"chatrooms.{chatroom_id}.v2\"},\n\t            }\n\t        )\n\t    async def unsubscribe_to_chatroom(self, chatroom_id: int) -> None:\n\t        await self.send_json(\n\t            {\n", "                \"event\": \"pusher:unsubscribe\",\n\t                \"data\": {\"auth\": \"\", \"channel\": f\"chatrooms.{chatroom_id}.v2\"},\n\t            }\n\t        )\n\t    async def watch_channel(self, channel_id: int) -> None:\n\t        await self.send_json(\n\t            {\n\t                \"event\": \"pusher:subscribe\",\n\t                \"data\": {\"auth\": \"\", \"channel\": f\"channel.{channel_id}\"},\n\t            }\n", "        )\n\t    async def unwatch_channel(self, channel_id: int) -> None:\n\t        await self.send_json(\n\t            {\n\t                \"event\": \"pusher:subscribe\",\n\t                \"data\": {\"auth\": \"\", \"channel\": f\"channel.{channel_id}\"},\n\t            }\n\t        )\n"]}
{"filename": "kick/polls.py", "chunked_list": ["from __future__ import annotations\n\timport datetime\n\tfrom typing import TYPE_CHECKING, Iterator\n\tfrom .object import HTTPDataclass\n\tfrom .utils import cached_property\n\tif TYPE_CHECKING:\n\t    from .chatroom import Chatroom, PartialChatroom\n\t    from .types.chatroom import CreatePollPayload, PollOptionPayload\n\t__all__ = (\"PollOption\", \"Poll\")\n\tclass PollOption(HTTPDataclass[\"PollOptionPayload\"]):\n", "    \"\"\"\n\t    This dataclass represents a chatroom `Poll`'s option on kick.\n\t    Attributes\n\t    -----------\n\t    chatroom: `Chatroom`\n\t        The chatroom the poll is in\n\t    id: int\n\t        The option's id\n\t    label: str\n\t        The option's label\n", "    votes: int\n\t        The amount of votes the option has\n\t    \"\"\"\n\t    chatroom: Chatroom | PartialChatroom\n\t    @property\n\t    def id(self) -> int:\n\t        \"\"\"\n\t        The option's id\n\t        \"\"\"\n\t        return self._data[\"id\"]\n", "    @property\n\t    def label(self) -> str:\n\t        \"\"\"\n\t        The option's label\n\t        \"\"\"\n\t        return self._data[\"label\"]\n\t    @property\n\t    def votes(self) -> int:\n\t        \"\"\"\n\t        The amount of votes the option has\n", "        \"\"\"\n\t        return self._data[\"votes\"]\n\t    async def vote(self) -> None:\n\t        \"\"\"\n\t        |coro|\n\t        Votes for this option in the poll\n\t        Raises\n\t        -----------\n\t        NotFound\n\t            There is no poll in the current chatroom\n", "        HTTPException\n\t            Deleting the poll failed\n\t        \"\"\"\n\t        await self.http.vote_for_poll(self.chatroom.streamer_name, self.id)\n\tclass Poll(HTTPDataclass[\"CreatePollPayload\"]):\n\t    \"\"\"\n\t    This dataclass represents a poll in a chatroom on kick.\n\t    Attributes\n\t    -----------\n\t    chatroom: `Chatroom`\n", "        The chatroom the poll is in\n\t    title: str\n\t        The poll's title\n\t    options: list[`PollOption`]\n\t        The poll's options\n\t    duration: int\n\t        How long the poll will last in seconds\n\t    result_display_duration: int\n\t        How long the poll will display the results in seconds\n\t    has_voted: bool\n", "        if you've voted yet\n\t    ends_at: datetime.datetime\n\t        When the poll ends at\n\t    \"\"\"\n\t    chatroom: Chatroom | PartialChatroom\n\t    @property\n\t    def title(self) -> str:\n\t        \"\"\"\n\t        Gives you the poll's title\n\t        \"\"\"\n", "        return self._data[\"data\"][\"poll\"][\"title\"]\n\t    def _get_options(self) -> Iterator[PollOption]:\n\t        for entry in self._data[\"data\"][\"poll\"][\"options\"]:\n\t            option = PollOption(data=entry, http=self.http)\n\t            option.chatroom = self.chatroom\n\t            yield option\n\t    @cached_property\n\t    def options(self) -> list[PollOption]:\n\t        \"\"\"\n\t        The poll's options\n", "        \"\"\"\n\t        return list(self._get_options())\n\t    @property\n\t    def duration(self) -> int:\n\t        \"\"\"\n\t        How long the poll is set to last in seconds\n\t        \"\"\"\n\t        return self._data[\"data\"][\"poll\"][\"duration\"]\n\t    @property\n\t    def result_display_duration(self) -> int:\n", "        \"\"\"\n\t        How long the poll will be displayed after it ends, in seconds\n\t        \"\"\"\n\t        return self._data[\"data\"][\"poll\"][\"result_display_duration\"]\n\t    @property\n\t    def has_voted(self) -> bool:\n\t        \"\"\"\n\t        Returns if you've voted yet\n\t        \"\"\"\n\t        return self._data[\"data\"][\"poll\"][\"has_voted\"]\n", "    @cached_property\n\t    def ends_at(self) -> datetime.datetime:\n\t        \"\"\"\n\t        How long the poll is set to last in seconds\n\t        \"\"\"\n\t        now = datetime.datetime.now(datetime.UTC)\n\t        return now + datetime.timedelta(seconds=self._data[\"data\"][\"poll\"][\"remaining\"])\n\t    async def delete(self) -> None:\n\t        \"\"\"\n\t        |coro|\n", "        Deletes the current poll from the chatroom\n\t        Raises\n\t        -----------\n\t        Forbidden\n\t            You are unauthorized to delete the poll\n\t        NotFound\n\t            There is no poll in the current chatroom\n\t        HTTPException\n\t            Deleting the poll failed\n\t        \"\"\"\n", "        await self.http.delete_poll(self.chatroom.streamer_name)\n"]}
{"filename": "kick/http.py", "chunked_list": ["from __future__ import annotations\n\timport asyncio\n\timport json\n\timport logging\n\tfrom typing import TYPE_CHECKING, Any, Coroutine, Optional, TypeVar, Union\n\tfrom aiohttp import ClientConnectionError, ClientResponse, ClientSession\n\tfrom . import __version__\n\tfrom .errors import (\n\t    CloudflareBypassException,\n\t    Forbidden,\n", "    HTTPException,\n\t    InternalKickException,\n\t    LoginFailure,\n\t    NotFound,\n\t)\n\tfrom .utils import MISSING\n\tfrom .ws import PusherWebSocket\n\tif TYPE_CHECKING:\n\t    from types.emotes import EmotesPayload\n\t    from typing_extensions import Self\n", "    from .client import Client, Credentials\n\t    from .types.chatroom import (\n\t        BanChatterPayload,\n\t        ChatroomBannedWordsPayload,\n\t        ChatroomRulesPayload,\n\t        CreatePollPayload,\n\t        DeletePollPayload,\n\t        EditChatroomSettingsPayload,\n\t        GetBannedUsersPayload,\n\t        UnbanChatterPayload,\n", "    )\n\t    from .types.leaderboard import LeaderboardPayload\n\t    from .types.message import (\n\t        FetchMessagesPayload,\n\t        MessagePayload,\n\t        ReplyOriginalMessage,\n\t        ReplyOriginalSender,\n\t        V1MessageSentPayload,\n\t    )\n\t    from .types.user import ChatterPayload, ClientUserPayload, UserPayload\n", "    from .types.videos import GetVideosPayload\n\t    T = TypeVar(\"T\")\n\t    Response = Coroutine[Any, Any, T]\n\tLOGGER = logging.getLogger(__name__)\n\tNOTFOUND_SIGNATURE = \"\"\"\n\tclass=\"w-64 lg:w-[526px]\"\n\t\"\"\".strip()\n\tasync def json_or_text(response: ClientResponse, /) -> Union[dict[str, Any], str]:\n\t    text = await response.text()\n\t    try:\n", "        try:\n\t            return json.loads(text)\n\t        except json.JSONDecodeError:\n\t            pass\n\t    except KeyError:\n\t        pass\n\t    return text\n\tasync def error_or_text(data: Union[dict, str]) -> str:\n\t    if isinstance(data, dict):\n\t        if \"status\" in data:\n", "            return data[\"status\"][\"message\"]\n\t        elif \"error\" in data:\n\t            return data[\"error\"]\n\t        elif \"message\" in data:\n\t            return data[\"message\"]\n\t    return f\"{data}\"\n\tasync def error_or_nothing(data: Union[dict, str]) -> str:\n\t    if isinstance(data, dict):\n\t        return await error_or_text(data)\n\t    else:\n", "        return \"\"\n\tclass Route:\n\t    DOMAIN: str = \"https://kick.com\"\n\t    BASE: str = f\"{DOMAIN}/api/v2\"\n\t    def __init__(self, method: str, path: str) -> None:\n\t        self.path: str = path\n\t        self.method: str = method\n\t        self.url = self.BASE + self.path\n\t    @classmethod\n\t    def root(cls, method: str, path: str) -> Self:\n", "        self = cls.__new__(cls)\n\t        self.path = path\n\t        self.method = method\n\t        self.url = self.DOMAIN + path\n\t        return self\n\tclass HTTPClient:\n\t    def __init__(self, client: Client):\n\t        self.__session: ClientSession = MISSING\n\t        self.ws: PusherWebSocket = MISSING\n\t        self.client = client\n", "        self.token: str = MISSING\n\t        self.xsrf_token: str = MISSING\n\t        self.globally_locked: bool = False\n\t        self.__regex_token_task: asyncio.Task | None = None\n\t        self._credentials: Credentials | None = None\n\t        self.user_agent = f\"Kick.py V{__version__} (github.com/cibere/kick.py)\"\n\t        self.bypass_port = client._options.get(\"bypass_port\", 9090)\n\t        self.bypass_host = client._options.get(\"bypass_host\", \"http://localhost\")\n\t        self.whitelisted = client._options.get(\"whitelisted\", False)\n\t    async def regen_token_coro(self) -> None:\n", "        await asyncio.sleep(2419200)  # 28 days just to be safe\n\t        if self._credentials:\n\t            LOGGER.info(\"Attempting to renew token\")\n\t            await self.client.login(self._credentials)\n\t    async def close(self) -> None:\n\t        LOGGER.info(\"Closing HTTP Client...\")\n\t        if self.__session is not MISSING:\n\t            await self.__session.close()\n\t        if self.ws is not MISSING:\n\t            await self.ws.close()\n", "    async def login(self, credentials: Credentials) -> None:\n\t        self._credentials = credentials\n\t        LOGGER.info(\n\t            f\"Logging in using {'username' if credentials.username_was_provided else 'email'} and password\"\n\t        )\n\t        # Mobile login method is used here since more is known about\n\t        # how that works compared to the desktop version.\n\t        # As for compatibility, there is no known endpoints that\n\t        # a mobile token can not authorize at.\n\t        token_route = Route.root(\"GET\", \"/kick-token-provider\")\n", "        token_provider = await self.request(token_route)\n\t        route = Route.root(\"POST\", \"/mobile/login\")\n\t        data = {\n\t            \"email\": credentials.email,\n\t            \"password\": credentials.password,\n\t            \"isMobileRequest\": True,\n\t            token_provider[\"nameFieldName\"]: \"\",\n\t            token_provider[\"validFromFieldName\"]: token_provider[\"encryptedValidFrom\"],\n\t        }\n\t        if credentials.one_time_password is not None:\n", "            data[\"one_time_password\"] = credentials.one_time_password\n\t        res = await self.request(route, json=data)\n\t        if isinstance(res, str):\n\t            raise NotFound(\"Kick 404'd on login page\")\n\t        if res[\"2fa_required\"] is True:\n\t            two_fa_code = input(\n\t                \"[WARNING] 2FA is enabled. Either disable it or give a 2fa code.\\n> \"\n\t            )\n\t            if not two_fa_code:\n\t                raise LoginFailure(\"2FA is enabled.\")\n", "            else:\n\t                data[\"one_time_password\"] = two_fa_code\n\t                res = await self.request(route, json=data)\n\t                if res[\"2fa_required\"] is True:\n\t                    raise LoginFailure(\"2FA is enabled.\")\n\t        if \"message\" in res.keys():\n\t            raise LoginFailure(res[\"message\"])\n\t        self.token = res[\"token\"]\n\t        LOGGER.info(\"Successfully logged in\")\n\t        self.__regex_token_task = asyncio.create_task(\n", "            self.regen_token_coro(), name=\"Regen-Token\"\n\t        )\n\t    async def start(self) -> None:\n\t        LOGGER.debug(\n\t            f\"Starting HTTP client. Whitelisted: {self.whitelisted}, Bypass Port: {self.bypass_port}\"\n\t        )\n\t        if self.__session is MISSING:\n\t            self.__session = ClientSession()\n\t        actual_ws = await self.__session.ws_connect(\n\t            f\"wss://ws-us2.pusher.com/app/eb1d5f283081a78b932c?protocol=7&client=js&version=7.6.0&flash=false\"\n", "        )\n\t        self.ws = PusherWebSocket(actual_ws, http=self)\n\t        self.client.dispatch(\"ready\")\n\t        await self.ws.start()\n\t    async def request(self, route: Route, **kwargs) -> Any:\n\t        if self.__session is MISSING:\n\t            self.__session = ClientSession()\n\t        headers = kwargs.pop(\"headers\", {})\n\t        headers[\"User-Agent\"] = self.user_agent\n\t        headers[\"Accepts\"] = \"application/json\"\n", "        cookies = kwargs.pop(\"cookies\", {})\n\t        if self.xsrf_token:\n\t            headers[\"X-XSRF-TOKEN\"] = self.xsrf_token\n\t            cookies[\"XSRF-TOKEN\"] = self.xsrf_token\n\t        if self.token:\n\t            headers[\"Authorization\"] = f\"Bearer {self.token}\"\n\t        url = route.url\n\t        if \"json\" in kwargs:\n\t            headers[\"Content-Type\"] = \"application/json\"\n\t        res: ClientResponse | None = None\n", "        data: str | dict | None = None\n\t        for current_try in range(3):\n\t            while self.globally_locked is True:\n\t                await asyncio.sleep(2)\n\t            LOGGER.debug(\n\t                f\"Making request to {route.method} {url}. headers: {headers}, params: {kwargs.get('params', None)}, json: {kwargs.get('json', None)}\"\n\t            )\n\t            try:\n\t                res = await self.__session.request(\n\t                    route.method,\n", "                    url\n\t                    if self.whitelisted is True\n\t                    else f\"{self.bypass_host}:{self.bypass_port}/request?url={url}\",\n\t                    headers=headers,\n\t                    cookies=cookies,\n\t                    **kwargs,\n\t                )\n\t            except ClientConnectionError:\n\t                if self.whitelisted is True:\n\t                    raise InternalKickException(\"Could Not Connect To Kick\") from None\n", "                else:\n\t                    raise CloudflareBypassException(\n\t                        \"Could Not Connect To Bypass Script\"\n\t                    ) from None\n\t            if res is not None:\n\t                self.xsrf_token = str(\n\t                    getattr(res.cookies.get(\"XSRF-TOKEN\", MISSING), \"value\", MISSING)\n\t                )\n\t                data = await json_or_text(res)\n\t                if res.status == 429:\n", "                    self.globally_locked = True\n\t                    LOGGER.warning(\n\t                        f\"We have been ratelimited at {route.method} {route.url}. Waiting five seconds before trying again...\",\n\t                    )\n\t                    await asyncio.sleep(5)\n\t                    return await self.request(route)\n\t                else:\n\t                    self.globally_locked = False\n\t                if 300 > res.status >= 200:\n\t                    return data\n", "                match res.status:\n\t                    case 400:\n\t                        error = await error_or_text(data)\n\t                        raise HTTPException(error, res.status)\n\t                    case 403:\n\t                        raise Forbidden(await error_or_nothing(data))\n\t                    case 404:\n\t                        error = await error_or_nothing(data)\n\t                        raise NotFound(error or \"Not Found\")\n\t                    case 500:\n", "                        time = 2 * current_try\n\t                        LOGGER.warning(\n\t                            f\"API returned a 500 status code at {route.method} {route.url}. Retrying in {time} seconds\",\n\t                        )\n\t                        await asyncio.sleep(time)\n\t                        continue\n\t                    case 502:\n\t                        txt = await error_or_text(data)\n\t                        raise InternalKickException(txt)\n\t                    case other:\n", "                        raise RuntimeError(f\"Unknown status reached: {other}\")\n\t        if res is not None and data is not None:\n\t            txt = await error_or_text(data)\n\t            if res.status >= 500:\n\t                raise InternalKickException(txt)\n\t            raise HTTPException(txt, res.status)\n\t        raise RuntimeError(\"Unreachable situation occured in http handling\")\n\t    def send_message(\n\t        self, chatroom: int, content: str\n\t    ) -> Response[V1MessageSentPayload]:\n", "        # We use the V1 api here since I havn't gotten it to work with V2.\n\t        # Unfortunatly V1 only returns a confirmation, and not the message (unlike V2)\n\t        route = Route.root(\"POST\", \"/api/v1/chat-messages\")\n\t        return self.request(\n\t            route,\n\t            data={\"message\": content, \"chatroom_id\": chatroom},\n\t        )\n\t    def delete_message(self, chatroom: int, message_id: str) -> Response[Any]:\n\t        # Kick keeps 500ing on this, so not sure what to expect from it\n\t        return self.request(\n", "            Route(\"DELETE\", f\"/chatrooms/{chatroom}/messages/{message_id}\")\n\t        )\n\t    def get_user(self, streamer: str) -> Response[UserPayload]:\n\t        return self.request(Route(method=\"GET\", path=f\"/channels/{streamer}\"))\n\t    def get_chatter(self, streamer: str, chatter: str) -> Response[ChatterPayload]:\n\t        return self.request(\n\t            Route(\n\t                method=\"GET\",\n\t                path=f\"/channels/{streamer}/users/{chatter}\",\n\t            )\n", "        )\n\t    def get_messages(self, chatroom: int) -> Response[FetchMessagesPayload]:\n\t        return self.request(Route(\"GET\", f\"/channels/{chatroom}/messages\"))\n\t    def get_chatroom_rules(self, streamer: str) -> Response[ChatroomRulesPayload]:\n\t        return self.request(Route(\"GET\", f\"/channels/{streamer}/chatroom/rules\"))\n\t    def get_streamer_videos(self, streamer: str) -> Response[GetVideosPayload]:\n\t        return self.request(Route(\"GET\", f\"/channels/{streamer}/videos\"))\n\t    def get_emotes(self, streamer: str) -> Response[EmotesPayload]:\n\t        return self.request(Route.root(\"GET\", f\"/emotes/{streamer}\"))\n\t    def get_channels_banned_words(\n", "        self, streamer: str\n\t    ) -> Response[ChatroomBannedWordsPayload]:\n\t        return self.request(Route(\"GET\", f\"/channels/{streamer}/chatroom/banned-words\"))\n\t    def get_channel_gift_leaderboard(\n\t        self, streamer: str\n\t    ) -> Response[LeaderboardPayload]:\n\t        return self.request(Route.root(\"GET\", f\"/channels/{streamer}/leaderboards\"))\n\t    def get_channel_bans(self, streamer: str) -> Response[GetBannedUsersPayload]:\n\t        \"\"\"\n\t        Requires Mod\n", "        \"\"\"\n\t        return self.request(Route(\"GET\", f\"/channels/{streamer}/bans\"))\n\t    def unban_user(self, streamer: str, chatter: str) -> Response[UnbanChatterPayload]:\n\t        return self.request(Route(\"DELETE\", f\"/channels/{streamer}/bans/{chatter}\"))\n\t    def timeout_chatter(\n\t        self, streamer: str, chatter: str, reason: str, duration: int\n\t    ) -> Response[BanChatterPayload]:\n\t        return self.request(\n\t            Route(\"POST\", f\"/channels/{streamer}/bans\"),\n\t            json={\n", "                \"banned_username\": chatter,\n\t                \"permanent\": False,\n\t                \"reason\": reason,\n\t                \"duration\": duration,\n\t            },\n\t        )\n\t    def ban_chatter(\n\t        self, streamer: str, chatter: str, reason: str\n\t    ) -> Response[BanChatterPayload]:\n\t        return self.request(\n", "            Route(\"POST\", f\"/channels/{streamer}/bans\"),\n\t            json={\n\t                \"banned_username\": chatter,\n\t                \"permanent\": True,\n\t                \"reason\": reason,\n\t            },\n\t        )\n\t    def create_poll(\n\t        self,\n\t        streamer: str,\n", "        duration: int,\n\t        options: list[str],\n\t        result_display_duration: int,\n\t        title: str,\n\t    ) -> Response[CreatePollPayload]:\n\t        \"\"\"\n\t        Durations are in seconds\n\t        \"\"\"\n\t        return self.request(\n\t            Route(\"POST\", f\"/channels/{streamer}/polls\"),\n", "            json={\n\t                \"duration\": duration,\n\t                \"options\": options,\n\t                \"result_display_duration\": result_display_duration,\n\t                \"title\": title,\n\t            },\n\t        )\n\t    def delete_poll(self, streamer: str) -> Response[DeletePollPayload]:\n\t        return self.request(Route(\"DELETE\", f\"/channels/{streamer}/polls\"))\n\t    def vote_for_poll(self, streamer: str, option: int) -> Response[CreatePollPayload]:\n", "        return self.request(\n\t            Route(\"POST\", f\"/channels/{streamer}/polls/vote\"),\n\t            json={\"id\": option},\n\t        )\n\t    def get_poll(self, streamer: str) -> Response[CreatePollPayload]:\n\t        return self.request(\n\t            Route(\"GET\", f\"/channels/{streamer}/polls\"),\n\t        )\n\t    def edit_chatroom(\n\t        self,\n", "        streamer: str,\n\t        followers_only_mode: Optional[bool] = None,\n\t        emotes_only_mode: Optional[bool] = None,\n\t        subscribers_only_mode: Optional[bool] = None,\n\t        slow_mode_enabled: Optional[bool] = None,\n\t        slow_mode_interval: Optional[int] = None,\n\t        following_min_duration: Optional[int] = None,\n\t    ) -> Response[EditChatroomSettingsPayload]:\n\t        payload = {}\n\t        if followers_only_mode is not None:\n", "            payload[\"followers_mode\"] = followers_only_mode\n\t        if emotes_only_mode is not None:\n\t            payload[\"emotes_mode\"] = emotes_only_mode\n\t        if subscribers_only_mode is not None:\n\t            payload[\"subscribers_mode\"] = subscribers_only_mode\n\t        if slow_mode_enabled is not None:\n\t            payload[\"slow_mode\"] = slow_mode_enabled\n\t            if slow_mode_enabled and slow_mode_interval is not None:\n\t                payload[\"message_interval\"] = slow_mode_interval\n\t        if following_min_duration is not None:\n", "            payload[\"following_min_duration \"] = following_min_duration\n\t        if not payload:\n\t            raise ValueError(\"No valid parameters provided for chatroom editing.\")\n\t        return self.request(\n\t            Route(\"PUT\", f\"/channels/{streamer}/chatroom\"),\n\t            json=payload,\n\t        )\n\t    def reply_to_message(\n\t        self,\n\t        chatroom: int,\n", "        content: str,\n\t        original_message: ReplyOriginalMessage,\n\t        original_sender: ReplyOriginalSender,\n\t    ) -> Response[MessagePayload]:\n\t        return self.request(\n\t            Route(\"POST\", f\"/messages/send/{chatroom}\"),\n\t            json={\n\t                \"content\": content,\n\t                \"metadata\": {\n\t                    \"original_message\": original_message,\n", "                    \"original_sender\": original_sender,\n\t                },\n\t                \"type\": \"reply\",\n\t            },\n\t        )\n\t    def get_me(self) -> Response[ClientUserPayload]:\n\t        return self.request(Route.root(\"GET\", \"/api/v1/user\"))\n\t    async def get_asset(self, url: str) -> bytes:\n\t        if self.__session is MISSING:\n\t            self.__session = ClientSession()\n", "        res = await self.__session.request(\"GET\", url)\n\t        match res.status:\n\t            case 200:\n\t                return await res.read()\n\t            case 403:\n\t                raise Forbidden()\n\t            case 404:\n\t                raise NotFound(\"Asset Not Found\")\n\t            case 500:\n\t                data = await json_or_text(res)\n", "                error = await error_or_text(data)\n\t                raise InternalKickException(error)\n\t            case other:\n\t                raise HTTPException(await res.text(), other)\n"]}
{"filename": "kick/types/emotes.py", "chunked_list": ["from typing import Literal\n\tfrom typing_extensions import TypedDict\n\tfrom .user import InnerUser\n\tclass EmotePayload(TypedDict):\n\t    id: int\n\t    channel_id: int\n\t    name: str\n\t    subscribers_only: bool\n\tclass EmojiUserPayload(TypedDict):\n\t    id: int\n", "    user_id: int\n\t    slug: str\n\t    is_banned: bool\n\t    playback_url: str\n\t    name_updated_at: None  # NEED TO FIGURE THIS OUT\n\t    vod_enabled: bool\n\t    subscription_enabled: bool\n\t    emotes: list[EmotePayload]\n\t    can_host: bool\n\t    user: InnerUser\n", "class EmotesDataPayload(TypedDict):\n\t    emotes: list[EmotePayload]\n\tclass GlobalEmotesPayload(EmotesDataPayload):\n\t    name: Literal[\"Global\"]\n\t    id: Literal[\"Global\"]\n\tclass StreamerEmotesPayload(EmotesDataPayload):\n\t    name: Literal[\"Emojis\"]\n\t    id: Literal[\"Emoji\"]\n\tEmotesPayload = tuple[EmojiUserPayload, GlobalEmotesPayload, StreamerEmotesPayload]\n"]}
{"filename": "kick/types/videos.py", "chunked_list": ["from typing_extensions import TypedDict\n\tfrom .assets import AssetSrcset, AssetUrl\n\tfrom .categories import Category\n\tclass BaseVideoPayload(TypedDict):\n\t    id: int\n\t    slug: str\n\t    channel_id: int\n\t    created_at: str\n\t    session_title: str\n\t    is_live: bool\n", "    risk_level_id: None  # NEED TO FIGURE THIS OUT\n\t    source: None  # NEED TO FIGURE THIS OUT\n\t    twitch_channel: None  # NEED TO FIGURE THIS OUT\n\t    duration: int\n\t    language: str\n\t    is_mature: bool\n\t    viewer_count: int\n\t    categories: list[Category]\n\tclass LivestreamPayload(BaseVideoPayload):\n\t    tags: list  # NEED TO FIGURE THIS OUT\n", "    thumbnail: None | AssetUrl\n\tclass InnerVideoPayload(TypedDict):\n\t    id: int\n\t    live_stream_id: int\n\t    slug: str | None  # Assumed str\n\t    thumb: None  # NEED TO FIGURE THIS OUT\n\t    s3: None  # NEED TO FIGURE THIS OUT\n\t    trading_platform_id: None  # NEED TO FIGURE THIS OUT\n\t    created_at: str\n\t    updated_at: str\n", "    views: int\n\t    deleted_at: None  # NEED TO FIGURE THIS OUT\n\tclass VideoPayload(BaseVideoPayload):\n\t    video: InnerVideoPayload\n\t    thumbnail: AssetSrcset\n\tGetVideosPayload = list[VideoPayload]\n"]}
{"filename": "kick/types/chatroom.py", "chunked_list": ["from codecs import StreamWriter\n\tfrom typing_extensions import TypedDict\n\tfrom .all import StatusPayload\n\tclass ChatroomRulesDataPayload(TypedDict):\n\t    rules: str\n\tclass ChatroomRulesPayload(TypedDict):\n\t    status: StatusPayload\n\t    data: ChatroomRulesDataPayload\n\tclass DeletePollPayload(TypedDict):\n\t    status: StatusPayload\n", "    data: None\n\tclass ChatroomBannedWordsDataPayload(TypedDict):\n\t    words: list[str]\n\tclass ChatroomBannedWordsPayload(TypedDict):\n\t    status: StatusPayload\n\t    data: ChatroomBannedWordsDataPayload\n\tclass BanEntryUserPayload(TypedDict):\n\t    id: int\n\t    username: str\n\tclass BanEntryDataPayload(TypedDict):\n", "    reason: str\n\t    banned_at: str\n\t    permanent: bool\n\t    expires_at: str\n\tclass BanEntryPayload(TypedDict):\n\t    banned_user: BanEntryUserPayload\n\t    banned_by: BanEntryUserPayload\n\t    ban: BanEntryDataPayload\n\tGetBannedUsersPayload = list[BanEntryPayload]\n\tclass UnbanChatterPayload(TypedDict):\n", "    status: bool\n\t    message: str\n\tclass BanChatterDataPayload(TypedDict):\n\t    id: str\n\t    chat_id: int\n\t    banned_id: int\n\t    banner_id: int\n\t    reason: str\n\t    type: str\n\t    permanent: bool\n", "    created_at: str\n\t    expires_at: str\n\tclass BanChatterPayload(TypedDict):\n\t    status: StatusPayload\n\t    data: BanChatterDataPayload\n\tclass PollOptionPayload(TypedDict):\n\t    id: int\n\t    label: str\n\t    votes: int\n\tclass PollPayload(TypedDict):\n", "    title: str\n\t    options: list[PollOptionPayload]\n\t    duration: int\n\t    remaining: int\n\t    result_display_duration: int\n\t    has_voted: bool\n\tclass CreatePollDataPayload(TypedDict):\n\t    poll: PollPayload\n\tclass CreatePollPayload(TypedDict):\n\t    status: StatusPayload\n", "    data: CreatePollDataPayload\n\tclass ChatroomSettingPayload(TypedDict):\n\t    enabled: bool\n\tclass FollowersModeStatusPayload(ChatroomSettingPayload):\n\t    min_duration: int\n\tclass SlowModeStatusPayload(ChatroomSettingPayload):\n\t    message_interval: int\n\tclass EditChatroomSettingsPayload(TypedDict):\n\t    id: int\n\t    slow_mode: SlowModeStatusPayload\n", "    subscribers_mode: ChatroomSettingPayload\n\t    followers_mode: FollowersModeStatusPayload\n\t    emotes_mode: ChatroomSettingPayload\n"]}
{"filename": "kick/types/categories.py", "chunked_list": ["from typing_extensions import TypedDict\n\tclass InnerCategory(TypedDict):\n\t    id: int\n\t    name: str\n\t    slug: str\n\t    icon: str\n\tclass Category(TypedDict):\n\t    id: int\n\t    category_id: int\n\t    name: str\n", "    slug: str\n\t    tags: list[str]\n\t    description: str | None\n\t    deleted_at: None  # NEED TO FIGURE THIS OUT\n\t    category: InnerCategory\n"]}
{"filename": "kick/types/assets.py", "chunked_list": ["from typing_extensions import TypedDict\n\tclass AssetUrl(TypedDict):\n\t    url: str\n\tclass AssetSrcset(TypedDict):\n\t    src: str\n\t    srcset: str\n\tclass AssetOnlySrc(TypedDict):\n\t    src: str\n\tAnyAsset = AssetUrl | AssetOnlySrc | AssetSrcset\n\tAssetPayload: bytes\n"]}
{"filename": "kick/types/badges.py", "chunked_list": ["from typing_extensions import TypedDict\n\tfrom .assets import AssetSrcset\n\tclass ChatBadgePayload(TypedDict):\n\t    type: str\n\t    text: str\n\t    count: int\n\t    active: bool\n\tclass SubscriberBadgePayload(TypedDict):\n\t    id: int\n\t    channel_id: int\n", "    months: int\n\t    badge_image: AssetSrcset\n"]}
{"filename": "kick/types/all.py", "chunked_list": ["from typing_extensions import TypedDict\n\tclass StatusPayload(TypedDict):\n\t    error: bool\n\t    code: int\n\t    message: str\n"]}
{"filename": "kick/types/message.py", "chunked_list": ["from typing import Literal\n\tfrom typing_extensions import TypedDict\n\tfrom .all import StatusPayload\n\tclass AuthorIdentity(TypedDict):\n\t    color: str\n\t    badges: list  # NEED TO FIGURE THIS OUT\n\tclass AuthorPayload(TypedDict):\n\t    id: int\n\t    username: str\n\t    slug: str\n", "    identity: AuthorIdentity\n\tclass BaseMessagePayload(TypedDict):\n\t    id: str\n\t    chatroom_id: int\n\t    content: str\n\t    created_at: str\n\t    sender: AuthorPayload\n\tclass NormalMessagePayload(BaseMessagePayload):\n\t    type: Literal[\"message\"]\n\tclass ReplyOriginalSender(TypedDict):\n", "    id: str | int\n\t    username: str\n\tclass ReplyOriginalMessage(TypedDict):\n\t    id: str\n\t    content: str\n\tclass ReplyMetaData(TypedDict):\n\t    original_sender: ReplyOriginalSender\n\t    original_message: ReplyOriginalMessage\n\tclass ReplyMessagePayload(BaseMessagePayload):\n\t    type: Literal[\"reply\"]\n", "    metadata: ReplyMetaData\n\tMessagePayload = NormalMessagePayload | ReplyMessagePayload\n\tclass MessageSentPayload(TypedDict):\n\t    status: StatusPayload\n\t    data: MessagePayload\n\tclass FetchMessagesDataPayload(TypedDict):\n\t    messages: list[MessagePayload]\n\t    cursor: str\n\tclass FetchMessagesPayload(TypedDict):\n\t    status: StatusPayload\n", "    data: FetchMessagesDataPayload\n\tclass V1MessageSentPayload(StatusPayload):\n\t    ...\n"]}
{"filename": "kick/types/leaderboard.py", "chunked_list": ["from typing_extensions import TypedDict\n\tclass GiftEntryPayload(TypedDict):\n\t    user_id: int\n\t    username: str\n\t    quantity: int\n\tclass LeaderboardPayload(TypedDict):\n\t    gifts: list[GiftEntryPayload]\n\t    gifts_week: list[GiftEntryPayload]\n\t    gifts_month: list[GiftEntryPayload]\n"]}
{"filename": "kick/types/ws.py", "chunked_list": ["from typing_extensions import TypedDict\n\tfrom .assets import AssetSrcset, AssetUrl\n\tfrom .categories import Category\n\tclass PartialLivestreamPayload(TypedDict):\n\t    id: int\n\t    channel_id: int\n\t    session_title: str\n\t    source: None  # Unknown\n\t    created_at: str\n\tclass FollowersUpdatePayload(TypedDict):\n", "    followersCount: str\n\t    channel_id: int\n\t    username: None | str\n\t    created_at: int\n\t    followed: bool\n"]}
{"filename": "kick/types/user.py", "chunked_list": ["from typing_extensions import Any, TypedDict\n\tfrom .assets import AssetSrcset, AssetUrl\n\tfrom .badges import ChatBadgePayload, SubscriberBadgePayload\n\tfrom .categories import Category\n\tfrom .videos import LivestreamPayload\n\tclass InnerUser(TypedDict):\n\t    id: int\n\t    username: str\n\t    agreed_to_terms: bool\n\t    email_verified_at: str\n", "    bio: str\n\t    country: str\n\t    state: str\n\t    city: str\n\t    instagram: str\n\t    twitter: str\n\t    youtube: str\n\t    discord: str\n\t    tiktok: str\n\t    facebook: str\n", "    profile_pic: str\n\tclass ChatroomPayload(TypedDict):\n\t    id: int\n\t    chatable_type: str\n\t    channel_id: int\n\t    created_at: str\n\t    updated_at: str\n\t    chat_mode_old: str\n\t    chat_mode: str\n\t    slow_mode: bool\n", "    chatable_id: int\n\t    followers_mode: bool\n\t    subscribers_mode: bool\n\t    emotes_mode: bool\n\t    message_interval: int\n\t    following_min_duration: int\n\tclass UserPayload(TypedDict):\n\t    id: int\n\t    user_id: int\n\t    slug: str\n", "    is_banned: bool\n\t    playback_url: str\n\t    vod_enabled: bool\n\t    subscription_enabled: bool\n\t    followers_count: int\n\t    subscriber_badges: list[SubscriberBadgePayload]\n\t    banner_image: AssetUrl | None\n\t    role: None  # Unknown\n\t    muted: bool\n\t    follower_badges: list  # Unknown\n", "    offline_banner_image: AssetSrcset | None\n\t    verified: bool\n\t    can_host: bool\n\t    user: InnerUser\n\t    chatroom: ChatroomPayload\n\t    livestream: LivestreamPayload | None\n\t    recent_categories: list[Category]\n\tclass ChatterPayload(TypedDict):\n\t    id: int\n\t    username: str\n", "    slug: str\n\t    profile_pic: None | str\n\t    is_staff: bool\n\t    is_channel_owner: bool\n\t    is_moderator: bool\n\t    badges: list[ChatBadgePayload]\n\t    following_since: None | str\n\t    subscribed_for: int  # in months\n\t    banned: None  # Unknown\n\tclass ClientChatterPayload(TypedDict):\n", "    subscription: None  # Unknown\n\t    is_super_admin: bool\n\t    is_following: bool\n\t    following_since: None | str\n\t    is_broadcaster: bool\n\t    is_moderator: bool\n\t    leaderboards: Any  # Unknown\n\t    banned: None  # Unknown\n\tclass PartialUserPayload(TypedDict):\n\t    id: str | int\n", "    username: str\n\tclass ClientUserStreamerChannelsPayload(TypedDict):\n\t    id: int\n\t    user_id: int\n\t    slug: str\n\t    is_banned: bool\n\t    playback_url: None | str\n\t    name_updated_at: None  # Unknown\n\t    vod_enabled: bool\n\t    subscription_enabled: bool\n", "    can_host: bool\n\t    verified: None  # Unknown\n\tclass ClientUserPayload(TypedDict):\n\t    id: int\n\t    email: str\n\t    username: str\n\t    google_id: None  # Unknown\n\t    agreed_to_terms: bool\n\t    email_verified_at: str\n\t    bio: None | str\n", "    country: None | str\n\t    state: None | str\n\t    city: None | str\n\t    enable_live_notifications: bool\n\t    youtube: None | str\n\t    instagram: None | str\n\t    twitter: None | str\n\t    discord: None | str\n\t    tiktok: None | str\n\t    facebook: None | str\n", "    enable_onscreen_live_notifications: bool\n\t    apple_id: None  # Unknown\n\t    phone: None | int\n\t    email_updated_at: None  # Unknown\n\t    newsletter_subscribed: bool\n\t    enable_sms_promo: bool\n\t    enable_sms_security: bool\n\t    is_2fa_setup: bool\n\t    redirect: None  # Unknown\n\t    channel_can_be_updated: bool\n", "    is_live: bool\n\t    intercom_hash: None  # Unknown\n\t    streamer_channel: ClientUserStreamerChannelsPayload\n\t    roles: list  # Unknown\n\t    profilepic: str | None\n"]}
{"filename": "examples/voting_on_poll.py", "chunked_list": ["from kick import Client\n\tclient = Client()\n\t@client.event\n\tasync def on_ready():\n\t    print(\"I have successfully logged in\")\n\t    username = (\n\t        \"xqc\"  # The username/slug of the user's chat you want to send the message in\n\t    )\n\t    user = await client.fetch_user(username)\n\t    chatroom = user.chatroom\n", "    # Fetching the chatroom's poll\n\t    poll = await chatroom.fetch_poll()\n\t    # Getting the first option\n\t    option = poll.options[0]\n\t    # Voting for the first option\n\t    await option.vote()\n\t    # Refetching the poll to get an updated votes count\n\t    new_poll = await chatroom.fetch_poll()\n\t    # Getting the new first option\n\t    new_option = new_poll.options[0]\n", "    # Printing the updated vote count\n\t    print(f\"The first option now has {new_option.votes} votes.\")\n\t# You can also pass the `credentials` arg to authenticate yourself\n\t# Authentication is not required for listening to messages\n\tclient.run()\n"]}
{"filename": "examples/receive_message.py", "chunked_list": ["from kick import Client, Message\n\tclient = Client()\n\t@client.event\n\tasync def on_message(msg: Message):\n\t    print(f\"Received message by {msg.author.slug} saying {msg.content}\")\n\t@client.event\n\tasync def on_ready():\n\t    print(\"I have successfully logged in\")\n\t    username = \"xqc\"  # The username/slug of the user's chat you want to listen to\n\t    user = await client.fetch_user(username)\n", "    await user.chatroom.connect()\n\t# You can also pass the `credentials` arg to authenticate yourself\n\t# Authentication is not required for listening to messages\n\tclient.run()\n"]}
{"filename": "examples/send_message.py", "chunked_list": ["from kick import Client, Credentials\n\tclient = Client()\n\t@client.event\n\tasync def on_ready():\n\t    print(\"I have successfully logged in\")\n\t    username = (\n\t        \"xqc\"  # The username/slug of the user's chat you want to send the message in\n\t    )\n\t    user = await client.fetch_user(username)\n\t    chatroom = user.chatroom\n", "    await chatroom.send(\"Hello!\")\n\t# You have to authenticate yourself in order to send mesages\n\tcredentials = Credentials(\n\t    username=\"...\",  # you can also use the email kwarg, but not both\n\t    password=\"...\",\n\t)\n\tclient.run(credentials)\n"]}
