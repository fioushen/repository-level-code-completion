{"filename": "setup.py", "chunked_list": ["\"\"\"The setup script.\"\"\"\n\tfrom setuptools import setup\n\tsetup()\n"]}
{"filename": "bumpversion/yaml_dump.py", "chunked_list": ["\"\"\"A simple YAML dumper to avoid extra dependencies.\"\"\"\n\timport datetime\n\tfrom collections import UserDict\n\tfrom io import StringIO\n\tfrom textwrap import indent\n\tfrom typing import Any, Callable\n\tDumperFunc = Callable[[Any], str]\n\tclass YAMLDumpers(UserDict):\n\t    \"\"\"Registry of YAML dumpers.\"\"\"\n\t    def add_dumper(self, data_type: type, dumper: DumperFunc) -> None:\n", "        \"\"\"Add a YAML dumper.\"\"\"\n\t        self.data[data_type] = dumper\n\tYAML_DUMPERS = YAMLDumpers()\n\tINDENT = \"  \"\n\tdef dump(data: Any) -> str:\n\t    \"\"\"Dump a value to a string buffer.\"\"\"\n\t    data_types = type(data).__mro__\n\t    for data_type in data_types:\n\t        if data_type in YAML_DUMPERS:\n\t            return YAML_DUMPERS[data_types[0]](data)\n", "    return YAML_DUMPERS[str](str(data))\n\tdef format_str(val: str) -> str:\n\t    \"\"\"Return a YAML representation of a string.\"\"\"\n\t    val = val.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\n\", \"\\\\n\")\n\t    return f'\"{val}\"'\n\tYAML_DUMPERS.add_dumper(str, format_str)\n\tdef format_int(val: int) -> str:\n\t    \"\"\"Return a YAML representation of an int.\"\"\"\n\t    return str(val)\n\tYAML_DUMPERS.add_dumper(int, format_int)\n", "def format_float(data: float) -> str:\n\t    \"\"\"Return a YAML representation of a float.\"\"\"\n\t    inf_value = 1e300\n\t    if data != data:\n\t        value = \".nan\"\n\t    elif data == inf_value:\n\t        value = \".inf\"\n\t    elif data == -inf_value:\n\t        value = \"-.inf\"\n\t    else:\n", "        value = repr(data).lower()\n\t        # Note that in some cases `repr(data)` represents a float number\n\t        # without the decimal parts.  For instance:\n\t        #   >>> repr(1e17)\n\t        #   '1e17'\n\t        # Unfortunately, this is not a valid float representation according\n\t        # to the definition of the `!!float` tag.  We fix this by adding\n\t        # '.0' before the 'e' symbol.\n\t        if \".\" not in value and \"e\" in value:\n\t            value = value.replace(\"e\", \".0e\", 1)\n", "    return str(value)\n\tYAML_DUMPERS.add_dumper(float, format_float)\n\tdef format_bool(val: bool) -> str:\n\t    \"\"\"Return a YAML representation of a bool.\"\"\"\n\t    return \"true\" if val else \"false\"\n\tYAML_DUMPERS.add_dumper(bool, format_bool)\n\tdef format_dict(val: dict) -> str:\n\t    \"\"\"Return a YAML representation of a dict.\"\"\"\n\t    buffer = StringIO()\n\t    for key, value in sorted(val.items()):\n", "        rendered_value = dump(value).strip()\n\t        if isinstance(value, (dict, list)):\n\t            rendered_value = f\"\\n{indent(rendered_value, INDENT)}\"\n\t        else:\n\t            rendered_value = f\" {rendered_value}\"\n\t        buffer.write(f\"{key}:{rendered_value}\\n\")\n\t    return buffer.getvalue()\n\tYAML_DUMPERS.add_dumper(dict, format_dict)\n\tdef format_list(val: list) -> str:\n\t    \"\"\"Return a string representation of a value.\"\"\"\n", "    buffer = StringIO()\n\t    for item in val:\n\t        rendered_value = dump(item).strip()\n\t        if isinstance(item, dict):\n\t            rendered_value = indent(rendered_value, INDENT).strip()\n\t        if isinstance(item, list):\n\t            rendered_value = f\"\\n{indent(rendered_value, INDENT)}\"\n\t        else:\n\t            rendered_value = f\" {rendered_value}\"\n\t        buffer.write(f\"-{rendered_value}\\n\")\n", "    return buffer.getvalue()\n\tYAML_DUMPERS.add_dumper(list, format_list)\n\tdef format_none(_: None) -> str:\n\t    \"\"\"Return a YAML representation of None.\"\"\"\n\t    return \"null\"\n\tYAML_DUMPERS.add_dumper(type(None), format_none)\n\tdef format_date(val: datetime.date) -> str:\n\t    \"\"\"Return a YAML representation of a date.\"\"\"\n\t    return val.isoformat()\n\tYAML_DUMPERS.add_dumper(datetime.date, format_date)\n", "def format_datetime(val: datetime.datetime) -> str:\n\t    \"\"\"Return a string representation of a value.\"\"\"\n\t    return val.isoformat(\" \")\n\tYAML_DUMPERS.add_dumper(datetime.datetime, format_datetime)\n"]}
{"filename": "bumpversion/functions.py", "chunked_list": ["\"\"\"Generators for version parts.\"\"\"\n\timport re\n\tfrom typing import List, Optional, Union\n\tclass PartFunction:\n\t    \"\"\"Base class for a version part function.\"\"\"\n\t    first_value: str\n\t    optional_value: str\n\t    independent: bool\n\t    def bump(self, value: str) -> str:\n\t        \"\"\"Increase the value.\"\"\"\n", "        raise NotImplementedError\n\tclass NumericFunction(PartFunction):\n\t    \"\"\"\n\t    This is a class that provides a numeric function for version parts.\n\t    It simply starts with the provided first_value (0 by default) and\n\t    increases it following the sequence of integer numbers.\n\t    The optional value of this function is equal to the first value.\n\t    This function also supports alphanumeric parts, altering just the numeric\n\t    part (e.g. 'r3' --> 'r4'). Only the first numeric group found in the part is\n\t    considered (e.g. 'r3-001' --> 'r4-001').\n", "    \"\"\"\n\t    FIRST_NUMERIC = re.compile(r\"(\\D*)(\\d+)(.*)\")\n\t    def __init__(self, optional_value: Optional[str] = None, first_value: Optional[str] = None):\n\t        if first_value is not None and not self.FIRST_NUMERIC.search(str(first_value)):\n\t            raise ValueError(f\"The given first value {first_value} does not contain any digit\")\n\t        self.first_value = str(first_value or 0)\n\t        self.optional_value = optional_value or self.first_value\n\t    def bump(self, value: Union[str, int]) -> str:\n\t        \"\"\"Increase the first numerical value by one.\"\"\"\n\t        match = self.FIRST_NUMERIC.search(str(value))\n", "        if not match:\n\t            raise ValueError(f\"The given value {value} does not contain any digit\")\n\t        part_prefix, part_numeric, part_suffix = match.groups()\n\t        bumped_numeric = int(part_numeric) + 1\n\t        return \"\".join([part_prefix, str(bumped_numeric), part_suffix])\n\tclass ValuesFunction(PartFunction):\n\t    \"\"\"\n\t    This is a class that provides a values list based function for version parts.\n\t    It is initialized with a list of values and iterates through them when\n\t    bumping the part.\n", "    The default optional value of this function is equal to the first value,\n\t    but may be otherwise specified.\n\t    When trying to bump a part which has already the maximum value in the list\n\t    you get a ValueError exception.\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        values: List[str],\n\t        optional_value: Optional[str] = None,\n\t        first_value: Optional[str] = None,\n", "    ):\n\t        if not values:\n\t            raise ValueError(\"Version part values cannot be empty\")\n\t        self._values = values\n\t        if optional_value is None:\n\t            optional_value = values[0]\n\t        if optional_value not in values:\n\t            raise ValueError(f\"Optional value {optional_value} must be included in values {values}\")\n\t        self.optional_value = optional_value\n\t        if not first_value:\n", "            first_value = values[0]\n\t        if first_value not in values:\n\t            raise ValueError(f\"First value {first_value} must be included in values {values}\")\n\t        self.first_value = first_value\n\t    def bump(self, value: str) -> str:\n\t        \"\"\"Return the item after ``value`` in the list.\"\"\"\n\t        try:\n\t            return self._values[self._values.index(value) + 1]\n\t        except IndexError as e:\n\t            raise ValueError(\n", "                f\"The part has already the maximum value among {self._values} and cannot be bumped.\"\n\t            ) from e\n"]}
{"filename": "bumpversion/__main__.py", "chunked_list": ["\"\"\"Main entrypoint for module.\"\"\"\n\tfrom bumpversion.cli import cli\n\tcli()\n"]}
{"filename": "bumpversion/scm.py", "chunked_list": ["\"\"\"Version control system management.\"\"\"\n\timport logging\n\timport os\n\timport re\n\timport subprocess\n\tfrom dataclasses import dataclass\n\tfrom pathlib import Path\n\tfrom tempfile import NamedTemporaryFile\n\tfrom typing import TYPE_CHECKING, ClassVar, List, MutableMapping, Optional, Type, Union\n\tif TYPE_CHECKING:  # pragma: no-coverage\n", "    from bumpversion.config import Config\n\tfrom bumpversion.exceptions import DirtyWorkingDirectoryError, SignedTagsError\n\tlogger = logging.getLogger(__name__)\n\t@dataclass\n\tclass SCMInfo:\n\t    \"\"\"Information about the current source code manager and state.\"\"\"\n\t    tool: Optional[Type[\"SourceCodeManager\"]] = None\n\t    commit_sha: Optional[str] = None\n\t    distance_to_latest_tag: Optional[int] = None\n\t    current_version: Optional[str] = None\n", "    branch_name: Optional[str] = None\n\t    short_branch_name: Optional[str] = None\n\t    dirty: Optional[bool] = None\n\t    def __str__(self):\n\t        return self.__repr__()\n\t    def __repr__(self):\n\t        tool_name = self.tool.__name__ if self.tool else \"No SCM tool\"\n\t        return (\n\t            f\"SCMInfo(tool={tool_name}, commit_sha={self.commit_sha}, \"\n\t            f\"distance_to_latest_tag={self.distance_to_latest_tag}, current_version={self.current_version}, \"\n", "            f\"dirty={self.dirty})\"\n\t        )\n\tclass SourceCodeManager:\n\t    \"\"\"Base class for version control systems.\"\"\"\n\t    _TEST_USABLE_COMMAND: ClassVar[List[str]] = []\n\t    _COMMIT_COMMAND: ClassVar[List[str]] = []\n\t    _ALL_TAGS_COMMAND: ClassVar[List[str]] = []\n\t    @classmethod\n\t    def commit(cls, message: str, current_version: str, new_version: str, extra_args: Optional[list] = None) -> None:\n\t        \"\"\"Commit the changes.\"\"\"\n", "        extra_args = extra_args or []\n\t        with NamedTemporaryFile(\"wb\", delete=False) as f:\n\t            f.write(message.encode(\"utf-8\"))\n\t        env = os.environ.copy()\n\t        env[\"HGENCODING\"] = \"utf-8\"\n\t        env[\"BUMPVERSION_CURRENT_VERSION\"] = current_version\n\t        env[\"BUMPVERSION_NEW_VERSION\"] = new_version\n\t        try:\n\t            cmd = [*cls._COMMIT_COMMAND, f.name, *extra_args]\n\t            subprocess.run(cmd, env=env, capture_output=True, check=True)  # noqa: S603\n", "        except subprocess.CalledProcessError as exc:  # pragma: no-coverage\n\t            err_msg = f\"Failed to run {exc.cmd}: return code {exc.returncode}, output: {exc.output}\"\n\t            logger.exception(err_msg)\n\t            raise exc\n\t        finally:\n\t            os.unlink(f.name)\n\t    @classmethod\n\t    def is_usable(cls) -> bool:\n\t        \"\"\"Is the VCS implementation usable.\"\"\"\n\t        try:\n", "            result = subprocess.run(cls._TEST_USABLE_COMMAND, check=True, capture_output=True)  # noqa: S603\n\t            return result.returncode == 0\n\t        except (FileNotFoundError, PermissionError, NotADirectoryError, subprocess.CalledProcessError):\n\t            return False\n\t    @classmethod\n\t    def assert_nondirty(cls) -> None:\n\t        \"\"\"Assert that the working directory is not dirty.\"\"\"\n\t        raise NotImplementedError()\n\t    @classmethod\n\t    def latest_tag_info(cls, tag_pattern: str) -> SCMInfo:\n", "        \"\"\"Return information about the latest tag.\"\"\"\n\t        raise NotImplementedError()\n\t    @classmethod\n\t    def add_path(cls, path: Union[str, Path]) -> None:\n\t        \"\"\"Add a path to the VCS.\"\"\"\n\t        raise NotImplementedError()\n\t    @classmethod\n\t    def tag(cls, name: str, sign: bool = False, message: Optional[str] = None) -> None:\n\t        \"\"\"Create a tag of the new_version in VCS.\"\"\"\n\t        raise NotImplementedError\n", "    @classmethod\n\t    def get_all_tags(cls) -> List[str]:\n\t        \"\"\"Return all tags in VCS.\"\"\"\n\t        try:\n\t            result = subprocess.run(cls._ALL_TAGS_COMMAND, text=True, check=True, capture_output=True)  # noqa: S603\n\t            return result.stdout.splitlines()\n\t        except (FileNotFoundError, PermissionError, NotADirectoryError, subprocess.CalledProcessError):\n\t            return []\n\t    @classmethod\n\t    def commit_to_scm(\n", "        cls,\n\t        files: List[Union[str, Path]],\n\t        config: \"Config\",\n\t        context: MutableMapping,\n\t        extra_args: Optional[List[str]] = None,\n\t        dry_run: bool = False,\n\t    ) -> None:\n\t        \"\"\"Commit the files to the source code management system.\"\"\"\n\t        if not cls.is_usable():\n\t            logger.error(\"SCM tool '%s' is unusable, unable to commit.\", cls.__name__)\n", "            return\n\t        if not config.commit:\n\t            logger.info(\"Would not commit\")\n\t            return\n\t        do_commit = not dry_run\n\t        logger.info(\n\t            \"%s %s commit\",\n\t            \"Preparing\" if do_commit else \"Would prepare\",\n\t            cls.__name__,\n\t        )\n", "        for path in files:\n\t            logger.info(\n\t                \"%s changes in file '%s' to %s\",\n\t                \"Adding\" if do_commit else \"Would add\",\n\t                path,\n\t                cls.__name__,\n\t            )\n\t            if do_commit:\n\t                cls.add_path(path)\n\t        commit_message = config.message.format(**context)\n", "        logger.info(\n\t            \"%s to %s with message '%s'\",\n\t            \"Committing\" if do_commit else \"Would commit\",\n\t            cls.__name__,\n\t            commit_message,\n\t        )\n\t        if do_commit:\n\t            cls.commit(\n\t                message=commit_message,\n\t                current_version=context[\"current_version\"],\n", "                new_version=context[\"new_version\"],\n\t                extra_args=extra_args,\n\t            )\n\t    @classmethod\n\t    def tag_in_scm(cls, config: \"Config\", context: MutableMapping, dry_run: bool = False) -> None:\n\t        \"\"\"Tag the current commit in the source code management system.\"\"\"\n\t        if not config.commit:\n\t            logger.info(\"Would not tag since we are not committing\")\n\t            return\n\t        if not config.tag:\n", "            logger.info(\"Would not tag\")\n\t            return\n\t        sign_tags = config.sign_tags\n\t        tag_name = config.tag_name.format(**context)\n\t        tag_message = config.tag_message.format(**context)\n\t        existing_tags = cls.get_all_tags()\n\t        do_tag = not dry_run\n\t        if tag_name in existing_tags:\n\t            logger.warning(\"Tag '%s' already exists. Will not tag.\", tag_name)\n\t            return\n", "        logger.info(\n\t            \"%s '%s' %s in %s and %s\",\n\t            \"Tagging\" if do_tag else \"Would tag\",\n\t            tag_name,\n\t            f\"with message '{tag_message}'\" if tag_message else \"without message\",\n\t            cls.__name__,\n\t            \"signing\" if sign_tags else \"not signing\",\n\t        )\n\t        if do_tag:\n\t            cls.tag(tag_name, sign_tags, tag_message)\n", "    def __str__(self):\n\t        return self.__repr__()\n\t    def __repr__(self):\n\t        return f\"{self.__class__.__name__}\"\n\tclass Git(SourceCodeManager):\n\t    \"\"\"Git implementation.\"\"\"\n\t    _TEST_USABLE_COMMAND: ClassVar[List[str]] = [\"git\", \"rev-parse\", \"--git-dir\"]\n\t    _COMMIT_COMMAND: ClassVar[List[str]] = [\"git\", \"commit\", \"-F\"]\n\t    _ALL_TAGS_COMMAND: ClassVar[List[str]] = [\"git\", \"tag\", \"--list\"]\n\t    @classmethod\n", "    def assert_nondirty(cls) -> None:\n\t        \"\"\"Assert that the working directory is not dirty.\"\"\"\n\t        lines = [\n\t            line.strip()\n\t            for line in subprocess.check_output([\"git\", \"status\", \"--porcelain\"]).splitlines()  # noqa: S603, S607\n\t            if not line.strip().startswith(b\"??\")\n\t        ]\n\t        if lines:\n\t            joined_lines = b\"\\n\".join(lines).decode()\n\t            raise DirtyWorkingDirectoryError(f\"Git working directory is not clean:\\n\\n{joined_lines}\")\n", "    @classmethod\n\t    def latest_tag_info(cls, tag_pattern: str) -> SCMInfo:\n\t        \"\"\"Return information about the latest tag.\"\"\"\n\t        try:\n\t            # git-describe doesn't update the git-index, so we do that\n\t            subprocess.run([\"git\", \"update-index\", \"--refresh\", \"-q\"], capture_output=True)  # noqa: S603, S607\n\t        except subprocess.CalledProcessError as e:\n\t            logger.debug(\"Error when running git update-index: %s\", e.stderr)\n\t            return SCMInfo(tool=cls)\n\t        try:\n", "            # get info about the latest tag in git\n\t            # TODO: This only works if the tag name is prefixed with `v`.\n\t            #   Should allow for the configured format for the tag name.\n\t            git_cmd = [\n\t                \"git\",\n\t                \"describe\",\n\t                \"--dirty\",\n\t                \"--tags\",\n\t                \"--long\",\n\t                \"--abbrev=40\",\n", "                f\"--match={tag_pattern}\",\n\t            ]\n\t            result = subprocess.run(git_cmd, text=True, check=True, capture_output=True)  # noqa: S603\n\t            describe_out = result.stdout.strip().split(\"-\")\n\t            git_cmd = [\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"]\n\t            result = subprocess.run(git_cmd, text=True, check=True, capture_output=True)  # noqa: S603\n\t            branch_name = result.stdout.strip()\n\t            short_branch_name = re.sub(r\"([^a-zA-Z0-9]*)\", \"\", branch_name).lower()[:20]\n\t        except subprocess.CalledProcessError as e:\n\t            logger.debug(\"Error when running git describe: %s\", e.stderr)\n", "            return SCMInfo(tool=cls)\n\t        info = SCMInfo(tool=cls, branch_name=branch_name, short_branch_name=short_branch_name)\n\t        if describe_out[-1].strip() == \"dirty\":\n\t            info.dirty = True\n\t            describe_out.pop()\n\t        else:\n\t            info.dirty = False\n\t        info.commit_sha = describe_out.pop().lstrip(\"g\")\n\t        info.distance_to_latest_tag = int(describe_out.pop())\n\t        info.current_version = \"-\".join(describe_out).lstrip(\"v\")\n", "        return info\n\t    @classmethod\n\t    def add_path(cls, path: Union[str, Path]) -> None:\n\t        \"\"\"Add a path to the VCS.\"\"\"\n\t        subprocess.check_output([\"git\", \"add\", \"--update\", str(path)])  # noqa: S603, S607\n\t    @classmethod\n\t    def tag(cls, name: str, sign: bool = False, message: Optional[str] = None) -> None:\n\t        \"\"\"\n\t        Create a tag of the new_version in VCS.\n\t        If only name is given, bumpversion uses a lightweight tag.\n", "        Otherwise, it utilizes an annotated tag.\n\t        Args:\n\t            name: The name of the tag\n\t            sign: True to sign the tag\n\t            message: An optional message to annotate the tag.\n\t        \"\"\"\n\t        command = [\"git\", \"tag\", name]\n\t        if sign:\n\t            command += [\"--sign\"]\n\t        if message:\n", "            command += [\"--message\", message]\n\t        subprocess.check_output(command)  # noqa: S603\n\tclass Mercurial(SourceCodeManager):\n\t    \"\"\"Mercurial implementation.\"\"\"\n\t    _TEST_USABLE_COMMAND: ClassVar[List[str]] = [\"hg\", \"root\"]\n\t    _COMMIT_COMMAND: ClassVar[List[str]] = [\"hg\", \"commit\", \"--logfile\"]\n\t    _ALL_TAGS_COMMAND: ClassVar[List[str]] = [\"hg\", \"log\", '--rev=\"tag()\"', '--template=\"{tags}\\n\"']\n\t    @classmethod\n\t    def latest_tag_info(cls, tag_pattern: str) -> SCMInfo:\n\t        \"\"\"Return information about the latest tag.\"\"\"\n", "        current_version = None\n\t        re_pattern = tag_pattern.replace(\"*\", \".*\")\n\t        result = subprocess.run(\n\t            [\"hg\", \"log\", \"-r\", f\"tag('re:{re_pattern}')\", \"--template\", \"{latesttag}\\n\"],  # noqa: S603, S607\n\t            text=True,\n\t            check=True,\n\t            capture_output=True,\n\t        )\n\t        result.check_returncode()\n\t        if result.stdout:\n", "            current_version = result.stdout.splitlines(keepends=False)[0].lstrip(\"v\")\n\t        is_dirty = len(subprocess.check_output([\"hg\", \"status\", \"-mard\"])) != 0  # noqa: S603, S607\n\t        return SCMInfo(tool=cls, current_version=current_version, dirty=is_dirty)\n\t    @classmethod\n\t    def assert_nondirty(cls) -> None:\n\t        \"\"\"Assert that the working directory is clean.\"\"\"\n\t        lines = [\n\t            line.strip()\n\t            for line in subprocess.check_output([\"hg\", \"status\", \"-mard\"]).splitlines()  # noqa: S603, S607\n\t            if not line.strip().startswith(b\"??\")\n", "        ]\n\t        if lines:\n\t            joined_lines = b\"\\n\".join(lines).decode()\n\t            raise DirtyWorkingDirectoryError(f\"Mercurial working directory is not clean:\\n{joined_lines}\")\n\t    @classmethod\n\t    def add_path(cls, path: Union[str, Path]) -> None:\n\t        \"\"\"Add a path to the VCS.\"\"\"\n\t        pass\n\t    @classmethod\n\t    def tag(cls, name: str, sign: bool = False, message: Optional[str] = None) -> None:\n", "        \"\"\"\n\t        Create a tag of the new_version in VCS.\n\t        If only name is given, bumpversion uses a lightweight tag.\n\t        Otherwise, it utilizes an annotated tag.\n\t        Args:\n\t            name: The name of the tag\n\t            sign: True to sign the tag\n\t            message: A optional message to annotate the tag.\n\t        Raises:\n\t            SignedTagsError: If ``sign`` is ``True``\n", "        \"\"\"\n\t        command = [\"hg\", \"tag\", name]\n\t        if sign:\n\t            raise SignedTagsError(\"Mercurial does not support signed tags.\")\n\t        if message:\n\t            command += [\"--message\", message]\n\t        subprocess.check_output(command)  # noqa: S603\n\tdef get_scm_info(tag_pattern: str) -> SCMInfo:\n\t    \"\"\"Return a dict with the latest source code management info.\"\"\"\n\t    if Git.is_usable():\n", "        return Git.latest_tag_info(tag_pattern)\n\t    elif Mercurial.is_usable():\n\t        return Mercurial.latest_tag_info(tag_pattern)\n\t    else:\n\t        return SCMInfo()\n"]}
{"filename": "bumpversion/config.py", "chunked_list": ["\"\"\"Configuration management.\"\"\"\n\tfrom __future__ import annotations\n\timport itertools\n\timport logging\n\timport re\n\tfrom difflib import context_diff\n\tfrom pathlib import Path\n\tfrom typing import TYPE_CHECKING, Any, Dict, List, Optional, Union\n\tfrom bumpversion.utils import labels_for_format\n\tif TYPE_CHECKING:  # pragma: no-coverage\n", "    from bumpversion.scm import SCMInfo\n\t    from bumpversion.version_part import VersionConfig\n\tfrom pydantic import BaseModel, BaseSettings, Field\n\tfrom bumpversion.exceptions import ConfigurationError\n\tlogger = logging.getLogger(__name__)\n\tclass VersionPartConfig(BaseModel):\n\t    \"\"\"Configuration of a part of the version.\"\"\"\n\t    values: Optional[list]  # Optional. Numeric is used if missing or no items in list\n\t    optional_value: Optional[str]  # Optional.\n\t    # Defaults to first value. 0 in the case of numeric. Empty string means nothing is optional.\n", "    first_value: Optional[str]  # Optional. Defaults to first value in values\n\t    independent: bool = False\n\tclass FileConfig(BaseModel):\n\t    \"\"\"Search and replace file config.\"\"\"\n\t    filename: Optional[str]\n\t    glob: Optional[str]  # Conflicts with filename. If both are specified, glob wins\n\t    parse: Optional[str]  # If different from outer scope\n\t    serialize: Optional[List[str]]  # If different from outer scope\n\t    search: Optional[str]  # If different from outer scope\n\t    replace: Optional[str]  # If different from outer scope\n", "    ignore_missing_version: Optional[bool]\n\tclass Config(BaseSettings):\n\t    \"\"\"Bump Version configuration.\"\"\"\n\t    current_version: Optional[str]\n\t    parse: str\n\t    serialize: List[str] = Field(min_items=1)\n\t    search: str\n\t    replace: str\n\t    ignore_missing_version: bool\n\t    tag: bool\n", "    sign_tags: bool\n\t    tag_name: str\n\t    tag_message: Optional[str]\n\t    allow_dirty: bool\n\t    commit: bool\n\t    message: str\n\t    commit_args: Optional[str]\n\t    scm_info: Optional[\"SCMInfo\"]\n\t    parts: Dict[str, VersionPartConfig]\n\t    files: List[FileConfig]\n", "    class Config:\n\t        env_prefix = \"bumpversion_\"\n\t    def add_files(self, filename: Union[str, List[str]]) -> None:\n\t        \"\"\"Add a filename to the list of files.\"\"\"\n\t        filenames = [filename] if isinstance(filename, str) else filename\n\t        self.files.extend([FileConfig(filename=name) for name in filenames])  # type: ignore[call-arg]\n\t    @property\n\t    def version_config(self) -> \"VersionConfig\":\n\t        \"\"\"Return the version configuration.\"\"\"\n\t        from bumpversion.version_part import VersionConfig\n", "        return VersionConfig(self.parse, self.serialize, self.search, self.replace, self.parts)\n\tDEFAULTS = {\n\t    \"current_version\": None,\n\t    \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)\",\n\t    \"serialize\": [\"{major}.{minor}.{patch}\"],\n\t    \"search\": \"{current_version}\",\n\t    \"replace\": \"{new_version}\",\n\t    \"ignore_missing_version\": False,\n\t    \"tag\": False,\n\t    \"sign_tags\": False,\n", "    \"tag_name\": \"v{new_version}\",\n\t    \"tag_message\": \"Bump version: {current_version} → {new_version}\",\n\t    \"allow_dirty\": False,\n\t    \"commit\": False,\n\t    \"message\": \"Bump version: {current_version} → {new_version}\",\n\t    \"commit_args\": None,\n\t    \"scm_info\": None,\n\t    \"parts\": {},\n\t    \"files\": [],\n\t}\n", "CONFIG_FILE_SEARCH_ORDER = (\n\t    Path(\".bumpversion.cfg\"),\n\t    Path(\".bumpversion.toml\"),\n\t    Path(\"setup.cfg\"),\n\t    Path(\"pyproject.toml\"),\n\t)\n\tdef get_all_file_configs(config_dict: dict) -> List[FileConfig]:\n\t    \"\"\"Make sure all version parts are included.\"\"\"\n\t    defaults = {\n\t        \"parse\": config_dict[\"parse\"],\n", "        \"serialize\": config_dict[\"serialize\"],\n\t        \"search\": config_dict[\"search\"],\n\t        \"replace\": config_dict[\"replace\"],\n\t        \"ignore_missing_version\": config_dict[\"ignore_missing_version\"],\n\t    }\n\t    files = [{k: v for k, v in filecfg.items() if v} for filecfg in config_dict[\"files\"]]\n\t    for f in files:\n\t        f.update({k: v for k, v in defaults.items() if k not in f})\n\t    return [FileConfig(**f) for f in files]\n\tdef get_configuration(config_file: Union[str, Path, None] = None, **overrides) -> Config:\n", "    \"\"\"\n\t    Return the configuration based on any configuration files and overrides.\n\t    Args:\n\t        config_file: An explicit configuration file to use, otherwise search for one\n\t        **overrides: Specific configuration key-values to override in the configuration\n\t    Returns:\n\t        The configuration\n\t    \"\"\"\n\t    from bumpversion.scm import SCMInfo, get_scm_info\n\t    config_dict = DEFAULTS.copy()\n", "    parsed_config = read_config_file(config_file) if config_file else {}\n\t    # We want to strip out unrecognized key-values to avoid inadvertent issues\n\t    config_dict.update({key: val for key, val in parsed_config.items() if key in DEFAULTS.keys()})\n\t    allowed_overrides = set(DEFAULTS.keys())\n\t    config_dict.update({key: val for key, val in overrides.items() if key in allowed_overrides})\n\t    # Set any missing version parts\n\t    config_dict[\"parts\"] = get_all_part_configs(config_dict)\n\t    # Set any missing file configuration\n\t    config_dict[\"files\"] = get_all_file_configs(config_dict)\n\t    # Resolve the SCMInfo class for Pydantic's BaseSettings\n", "    Config.update_forward_refs(SCMInfo=SCMInfo)\n\t    config = Config(**config_dict)  # type: ignore[arg-type]\n\t    # Get the information about the SCM\n\t    tag_pattern = config.tag_name.replace(\"{new_version}\", \"*\")\n\t    scm_info = get_scm_info(tag_pattern)\n\t    config.scm_info = scm_info\n\t    # Update and verify the current_version\n\t    config.current_version = check_current_version(config)\n\t    return config\n\tdef get_all_part_configs(config_dict: dict) -> Dict[str, VersionPartConfig]:\n", "    \"\"\"Make sure all version parts are included.\"\"\"\n\t    serialize = config_dict[\"serialize\"]\n\t    parts = config_dict[\"parts\"]\n\t    all_labels = set(itertools.chain.from_iterable([labels_for_format(fmt) for fmt in serialize]))\n\t    return {\n\t        label: VersionPartConfig(**parts[label]) if label in parts else VersionPartConfig()  # type: ignore[call-arg]\n\t        for label in all_labels\n\t    }\n\tdef check_current_version(config: Config) -> str:\n\t    \"\"\"\n", "    Returns the current version.\n\t    If the current version is not specified in the config file, command line or env variable,\n\t    it attempts to retrieve it via a tag.\n\t    Args:\n\t        config: The current configuration dictionary.\n\t    Returns:\n\t        The version number\n\t    Raises:\n\t        ConfigurationError: If it can't find the current version\n\t    \"\"\"\n", "    current_version = config.current_version\n\t    scm_info = config.scm_info\n\t    if current_version is None and scm_info.current_version:\n\t        return scm_info.current_version\n\t    elif current_version and scm_info.current_version and current_version != scm_info.current_version:\n\t        logger.warning(\n\t            \"Specified version (%s) does not match last tagged version (%s)\",\n\t            current_version,\n\t            scm_info.current_version,\n\t        )\n", "        return current_version\n\t    elif current_version:\n\t        return current_version\n\t    raise ConfigurationError(\"Unable to determine the current version.\")\n\tdef find_config_file(explicit_file: Union[str, Path, None] = None) -> Union[Path, None]:\n\t    \"\"\"\n\t    Find the configuration file, if it exists.\n\t    If no explicit configuration file is passed, it will search in several files to\n\t    find its configuration.\n\t    Args:\n", "        explicit_file: The configuration file to explicitly use.\n\t    Returns:\n\t        The configuration file path\n\t    \"\"\"\n\t    search_paths = [Path(explicit_file)] if explicit_file else CONFIG_FILE_SEARCH_ORDER\n\t    return next(\n\t        (cfg_file for cfg_file in search_paths if cfg_file.exists() and \"bumpversion]\" in cfg_file.read_text()),\n\t        None,\n\t    )\n\tdef read_config_file(config_file: Union[str, Path, None] = None) -> Dict[str, Any]:\n", "    \"\"\"\n\t    Read the configuration file, if it exists.\n\t    If no explicit configuration file is passed, it will search in several files to\n\t    find its configuration.\n\t    Args:\n\t        config_file: The configuration file to explicitly use.\n\t    Returns:\n\t        A dictionary of read key-values\n\t    \"\"\"\n\t    if not config_file:\n", "        logger.info(\"No configuration file found.\")\n\t        return {}\n\t    logger.info(\"Reading config file %s:\", config_file)\n\t    config_path = Path(config_file)\n\t    if config_path.suffix == \".cfg\":\n\t        return read_ini_file(config_path)\n\t    elif config_path.suffix == \".toml\":\n\t        return read_toml_file(config_path)\n\t    return {}\n\tdef read_ini_file(file_path: Path) -> Dict[str, Any]:  # noqa: C901\n", "    \"\"\"\n\t    Parse an INI file and return a dictionary of sections and their options.\n\t    Args:\n\t        file_path: The path to the INI file.\n\t    Returns:\n\t        dict: A dictionary of sections and their options.\n\t    \"\"\"\n\t    import configparser\n\t    from bumpversion import autocast\n\t    # Create a ConfigParser object and read the INI file\n", "    config_parser = configparser.RawConfigParser()\n\t    if file_path.name == \"setup.cfg\":\n\t        config_parser = configparser.ConfigParser()\n\t    config_parser.read(file_path)\n\t    # Create an empty dictionary to hold the parsed sections and options\n\t    bumpversion_options: Dict[str, Any] = {\"files\": [], \"parts\": {}}\n\t    # Loop through each section in the INI file\n\t    for section_name in config_parser.sections():\n\t        if not section_name.startswith(\"bumpversion\"):\n\t            continue\n", "        section_parts = section_name.split(\":\")\n\t        num_parts = len(section_parts)\n\t        options = {key: autocast.autocast_value(val) for key, val in config_parser.items(section_name)}\n\t        if num_parts == 1:  # bumpversion section\n\t            bumpversion_options.update(options)\n\t            serialize = bumpversion_options.get(\"serialize\", [])\n\t            if \"message\" in bumpversion_options and isinstance(bumpversion_options[\"message\"], list):\n\t                bumpversion_options[\"message\"] = \",\".join(bumpversion_options[\"message\"])\n\t            if not isinstance(serialize, list):\n\t                bumpversion_options[\"serialize\"] = [serialize]\n", "        elif num_parts > 1 and section_parts[1].startswith(\"file\"):\n\t            file_options = {\n\t                \"filename\": section_parts[2],\n\t            }\n\t            file_options.update(options)\n\t            if \"replace\" in file_options and isinstance(file_options[\"replace\"], list):\n\t                file_options[\"replace\"] = \"\\n\".join(file_options[\"replace\"])\n\t            bumpversion_options[\"files\"].append(file_options)\n\t        elif num_parts > 1 and section_parts[1].startswith(\"glob\"):\n\t            file_options = {\n", "                \"glob\": section_parts[2],\n\t            }\n\t            file_options.update(options)\n\t            if \"replace\" in file_options and isinstance(file_options[\"replace\"], list):\n\t                file_options[\"replace\"] = \"\\n\".join(file_options[\"replace\"])\n\t            bumpversion_options[\"files\"].append(file_options)\n\t        elif num_parts > 1 and section_parts[1].startswith(\"part\"):\n\t            bumpversion_options[\"parts\"][section_parts[2]] = options\n\t    # Return the dictionary of sections and options\n\t    return bumpversion_options\n", "def read_toml_file(file_path: Path) -> Dict[str, Any]:\n\t    \"\"\"\n\t    Parse a TOML file and return the `bumpversion` section.\n\t    Args:\n\t        file_path: The path to the TOML file.\n\t    Returns:\n\t        dict: A dictionary of the `bumpversion` section.\n\t    \"\"\"\n\t    import tomlkit\n\t    # Load the TOML file\n", "    toml_data = tomlkit.parse(file_path.read_text()).unwrap()\n\t    return toml_data.get(\"tool\", {}).get(\"bumpversion\", {})\n\tdef update_config_file(\n\t    config_file: Union[str, Path, None], current_version: str, new_version: str, dry_run: bool = False\n\t) -> None:\n\t    \"\"\"\n\t    Update the current_version key in the configuration file.\n\t    If no explicit configuration file is passed, it will search in several files to\n\t    find its configuration.\n\t    Instead of parsing and re-writing the config file with new information, it will use\n", "    a regular expression to just replace the current_version value. The idea is it will\n\t    avoid unintentional changes (like formatting) to the config file.\n\t    Args:\n\t        config_file: The configuration file to explicitly use.\n\t        current_version: The serialized current version.\n\t        new_version: The serialized new version.\n\t        dry_run: True if the update should be a dry run.\n\t    \"\"\"\n\t    toml_current_version_regex = re.compile(\n\t        f'(?P<section_prefix>\\\\[tool\\\\.bumpversion]\\n[^[]*current_version\\\\s*=\\\\s*)(\\\\\"{current_version}\\\\\")',\n", "        re.MULTILINE,\n\t    )\n\t    cfg_current_version_regex = re.compile(\n\t        f\"(?P<section_prefix>\\\\[bumpversion]\\n[^[]*current_version\\\\s*=\\\\s*)(?P<version>{current_version})\",\n\t        re.MULTILINE,\n\t    )\n\t    if not config_file:\n\t        logger.info(\"No configuration file found to update.\")\n\t        return\n\t    config_path = Path(config_file)\n", "    existing_config = config_path.read_text()\n\t    if config_path.suffix == \".cfg\" and cfg_current_version_regex.search(existing_config):\n\t        sub_str = f\"\\\\g<section_prefix>{new_version}\"\n\t        new_config = cfg_current_version_regex.sub(sub_str, existing_config)\n\t    elif config_path.suffix == \".toml\" and toml_current_version_regex.search(existing_config):\n\t        sub_str = f'\\\\g<section_prefix>\"{new_version}\"'\n\t        new_config = toml_current_version_regex.sub(sub_str, existing_config)\n\t    else:\n\t        logger.info(\"Could not find the current version in the config file: %s.\", config_path)\n\t        return\n", "    logger.info(\n\t        \"%s to config file %s:\",\n\t        \"Would write\" if dry_run else \"Writing\",\n\t        config_path,\n\t    )\n\t    logger.info(\n\t        \"\\n\".join(\n\t            list(\n\t                context_diff(\n\t                    existing_config.splitlines(),\n", "                    new_config.splitlines(),\n\t                    fromfile=f\"before {config_path}\",\n\t                    tofile=f\"after {config_path}\",\n\t                    lineterm=\"\",\n\t                )\n\t            )\n\t        )\n\t    )\n\t    if not dry_run:\n\t        config_path.write_text(new_config)\n"]}
{"filename": "bumpversion/files.py", "chunked_list": ["\"\"\"Methods for changing files.\"\"\"\n\timport glob\n\timport logging\n\tfrom difflib import context_diff\n\tfrom typing import List, MutableMapping, Optional\n\tfrom bumpversion.config import FileConfig\n\tfrom bumpversion.exceptions import VersionNotFoundError\n\tfrom bumpversion.version_part import Version, VersionConfig\n\tlogger = logging.getLogger(__name__)\n\tclass ConfiguredFile:\n", "    \"\"\"A file to modify in a configured way.\"\"\"\n\t    def __init__(\n\t        self,\n\t        file_cfg: FileConfig,\n\t        version_config: VersionConfig,\n\t        search: Optional[str] = None,\n\t        replace: Optional[str] = None,\n\t    ) -> None:\n\t        self.path = file_cfg.filename\n\t        self.parse = file_cfg.parse or version_config.parse_regex.pattern\n", "        self.serialize = file_cfg.serialize or version_config.serialize_formats\n\t        self.search = search or file_cfg.search or version_config.search\n\t        self.replace = replace or file_cfg.replace or version_config.replace\n\t        self.ignore_missing_version = file_cfg.ignore_missing_version or False\n\t        self.version_config = VersionConfig(\n\t            self.parse, self.serialize, self.search, self.replace, version_config.part_configs\n\t        )\n\t    def contains_version(self, version: Version, context: MutableMapping) -> bool:\n\t        \"\"\"\n\t        Check whether the version is present in the file.\n", "        Args:\n\t            version: The version to check\n\t            context: The context to use\n\t        Raises:\n\t            VersionNotFoundError: if the version number isn't present in this file.\n\t        Returns:\n\t            True if the version number is in fact present.\n\t        \"\"\"\n\t        search_expression = self.search.format(**context)\n\t        if self.contains(search_expression):\n", "            return True\n\t        # the `search` pattern did not match, but the original supplied\n\t        # version number (representing the same version part values) might\n\t        # match instead.\n\t        # check whether `search` isn't customized, i.e. should match only\n\t        # very specific parts of the file\n\t        search_pattern_is_default = self.search == self.version_config.search\n\t        if search_pattern_is_default and self.contains(version.original):\n\t            # original version is present, and we're not looking for something\n\t            # more specific -> this is accepted as a match\n", "            return True\n\t        # version not found\n\t        if self.ignore_missing_version:\n\t            return False\n\t        raise VersionNotFoundError(f\"Did not find '{search_expression}' in file: '{self.path}'\")\n\t    def contains(self, search: str) -> bool:\n\t        \"\"\"Does the work of the contains_version method.\"\"\"\n\t        if not search:\n\t            return False\n\t        with open(self.path, \"rt\", encoding=\"utf-8\") as f:\n", "            search_lines = search.splitlines()\n\t            lookbehind = []\n\t            for lineno, line in enumerate(f.readlines()):\n\t                lookbehind.append(line.rstrip(\"\\n\"))\n\t                if len(lookbehind) > len(search_lines):\n\t                    lookbehind = lookbehind[1:]\n\t                if (\n\t                    search_lines[0] in lookbehind[0]\n\t                    and search_lines[-1] in lookbehind[-1]\n\t                    and search_lines[1:-1] == lookbehind[1:-1]\n", "                ):\n\t                    logger.info(\n\t                        \"Found '%s' in %s at line %s: %s\",\n\t                        search,\n\t                        self.path,\n\t                        lineno - (len(lookbehind) - 1),\n\t                        line.rstrip(),\n\t                    )\n\t                    return True\n\t        return False\n", "    def replace_version(\n\t        self, current_version: Version, new_version: Version, context: MutableMapping, dry_run: bool = False\n\t    ) -> None:\n\t        \"\"\"Replace the current version with the new version.\"\"\"\n\t        with open(self.path, \"rt\", encoding=\"utf-8\") as f:\n\t            file_content_before = f.read()\n\t            file_new_lines = f.newlines[0] if isinstance(f.newlines, tuple) else f.newlines\n\t        context[\"current_version\"] = self.version_config.serialize(current_version, context)\n\t        if new_version:\n\t            context[\"new_version\"] = self.version_config.serialize(new_version, context)\n", "        search_for = self.version_config.search.format(**context)\n\t        replace_with = self.version_config.replace.format(**context)\n\t        file_content_after = file_content_before.replace(search_for, replace_with)\n\t        if file_content_before == file_content_after and current_version.original:\n\t            search_for_original_formatted = self.version_config.search.format(current_version=current_version.original)\n\t            file_content_after = file_content_before.replace(search_for_original_formatted, replace_with)\n\t        if file_content_before != file_content_after:\n\t            logger.info(\"%s file %s:\", \"Would change\" if dry_run else \"Changing\", self.path)\n\t            logger.info(\n\t                \"\\n\".join(\n", "                    list(\n\t                        context_diff(\n\t                            file_content_before.splitlines(),\n\t                            file_content_after.splitlines(),\n\t                            fromfile=f\"before {self.path}\",\n\t                            tofile=f\"after {self.path}\",\n\t                            lineterm=\"\",\n\t                        )\n\t                    )\n\t                )\n", "            )\n\t        else:\n\t            logger.info(\"%s file %s\", \"Would not change\" if dry_run else \"Not changing\", self.path)\n\t        if not dry_run:  # pragma: no-coverage\n\t            with open(self.path, \"wt\", encoding=\"utf-8\", newline=file_new_lines) as f:\n\t                f.write(file_content_after)\n\t    def __str__(self) -> str:  # pragma: no-coverage\n\t        return self.path\n\t    def __repr__(self) -> str:  # pragma: no-coverage\n\t        return f\"<bumpversion.ConfiguredFile:{self.path}>\"\n", "def resolve_file_config(\n\t    files: List[FileConfig], version_config: VersionConfig, search: Optional[str] = None, replace: Optional[str] = None\n\t) -> List[ConfiguredFile]:\n\t    \"\"\"\n\t    Resolve the files, searching and replacing values according to the FileConfig.\n\t    Args:\n\t        files: A list of file configurations\n\t        version_config: How the version should be changed\n\t        search: The search pattern to use instead of any configured search pattern\n\t        replace: The replace pattern to use instead of any configured replace pattern\n", "    Returns:\n\t        A list of ConfiguredFiles\n\t    \"\"\"\n\t    configured_files = []\n\t    for file_cfg in files:\n\t        if file_cfg.glob:\n\t            configured_files.extend(get_glob_files(file_cfg, version_config))\n\t        else:\n\t            configured_files.append(ConfiguredFile(file_cfg, version_config, search, replace))\n\t    return configured_files\n", "def modify_files(\n\t    files: List[ConfiguredFile],\n\t    current_version: Version,\n\t    new_version: Version,\n\t    context: MutableMapping,\n\t    dry_run: bool = False,\n\t) -> None:\n\t    \"\"\"\n\t    Modify the files, searching and replacing values according to the FileConfig.\n\t    Args:\n", "        files: The list of configured files\n\t        current_version: The current version\n\t        new_version: The next version\n\t        context: The context used for rendering the version\n\t        dry_run: True if this should be a report-only job\n\t    \"\"\"\n\t    _check_files_contain_version(files, current_version, context)\n\t    for f in files:\n\t        f.replace_version(current_version, new_version, context, dry_run)\n\tdef get_glob_files(\n", "    file_cfg: FileConfig, version_config: VersionConfig, search: Optional[str] = None, replace: Optional[str] = None\n\t) -> List[ConfiguredFile]:\n\t    \"\"\"\n\t    Return a list of files that match the glob pattern.\n\t    Args:\n\t        file_cfg: The file configuration containing the glob pattern\n\t        version_config: The version configuration\n\t        search: The search pattern to use instead of any configured search pattern\n\t        replace: The replace pattern to use instead of any configured replace pattern\n\t    Returns:\n", "        A list of resolved files according to the pattern.\n\t    \"\"\"\n\t    files = []\n\t    for filename_glob in glob.glob(file_cfg.glob, recursive=True):\n\t        new_file_cfg = file_cfg.copy()\n\t        new_file_cfg.filename = filename_glob\n\t        files.append(ConfiguredFile(new_file_cfg, version_config, search, replace))\n\t    return files\n\tdef _check_files_contain_version(\n\t    files: List[ConfiguredFile], current_version: Version, context: MutableMapping\n", ") -> None:\n\t    \"\"\"Make sure files exist and contain version string.\"\"\"\n\t    logger.info(\n\t        \"Asserting files %s contain the version string...\",\n\t        \", \".join({str(f.path) for f in files}),\n\t    )\n\t    for f in files:\n\t        context[\"current_version\"] = f.version_config.serialize(current_version, context)\n\t        f.contains_version(current_version, context)\n"]}
{"filename": "bumpversion/ui.py", "chunked_list": ["\"\"\"Utilities for user interface.\"\"\"\n\tfrom click import UsageError, secho\n\tdef print_info(msg: str) -> None:\n\t    \"\"\"Echo a message to the console.\"\"\"\n\t    secho(msg)\n\tdef print_error(msg: str) -> None:\n\t    \"\"\"Raise an error and exit.\"\"\"\n\t    raise UsageError(msg)\n\tdef print_warning(msg: str) -> None:\n\t    \"\"\"Echo a warning to the console.\"\"\"\n", "    secho(f\"\\nWARNING:\\n\\n{msg}\\n\", fg=\"yellow\")\n"]}
{"filename": "bumpversion/show.py", "chunked_list": ["\"\"\"Functions for displaying information about the version.\"\"\"\n\timport dataclasses\n\tfrom io import StringIO\n\tfrom pprint import pprint\n\tfrom typing import Any, Optional\n\tfrom bumpversion.bump import get_next_version\n\tfrom bumpversion.config import Config\n\tfrom bumpversion.exceptions import BadInputError\n\tfrom bumpversion.ui import print_error, print_info\n\tfrom bumpversion.utils import get_context\n", "def output_default(value: dict) -> None:\n\t    \"\"\"Output the value with key=value or just value if there is only one item.\"\"\"\n\t    if len(value) == 1:\n\t        print_info(list(value.values())[0])\n\t    else:\n\t        buffer = StringIO()\n\t        pprint(value, stream=buffer)  # noqa: T203\n\t        print_info(buffer.getvalue())\n\tdef output_yaml(value: dict) -> None:\n\t    \"\"\"Output the value as yaml.\"\"\"\n", "    from bumpversion.yaml_dump import dump\n\t    print_info(dump(value))\n\tdef output_json(value: dict) -> None:\n\t    \"\"\"Output the value as json.\"\"\"\n\t    import json\n\t    def default_encoder(obj: Any) -> str:\n\t        if dataclasses.is_dataclass(obj):\n\t            return str(obj)\n\t        elif isinstance(obj, type):\n\t            return obj.__name__\n", "        raise TypeError(f\"Object of type {type(obj), str(obj)} is not JSON serializable\")\n\t    print_info(json.dumps(value, sort_keys=True, indent=2, default=default_encoder))\n\tOUTPUTTERS = {\n\t    \"yaml\": output_yaml,\n\t    \"json\": output_json,\n\t    \"default\": output_default,\n\t}\n\tdef resolve_name(obj: Any, name: str, default: Any = None, err_on_missing: bool = False) -> Any:\n\t    \"\"\"\n\t    Get a key or attr ``name`` from obj or default value.\n", "    Copied and modified from Django Template variable resolutions\n\t    Resolution methods:\n\t    - Mapping key lookup\n\t    - Attribute lookup\n\t    - Sequence index\n\t    Args:\n\t        obj: The object to access\n\t        name: A dotted name to the value, such as ``mykey.0.name``\n\t        default: If the name cannot be resolved from the object, return this value\n\t        err_on_missing: Raise a `BadInputError` if the name cannot be resolved\n", "    Returns:\n\t        The value at the resolved name or the default value.\n\t    Raises:\n\t        BadInputError: If we cannot resolve the name and `err_on_missing` is `True`\n\t    # noqa: DAR401\n\t    \"\"\"\n\t    lookups = name.split(\".\")\n\t    current = obj\n\t    try:  # catch-all for unexpected failures\n\t        for bit in lookups:\n", "            try:  # dictionary lookup\n\t                current = current[bit]\n\t                # ValueError/IndexError are for numpy.array lookup on\n\t                # numpy < 1.9 and 1.9+ respectively\n\t            except (TypeError, AttributeError, KeyError, ValueError, IndexError):\n\t                try:  # attribute lookup\n\t                    current = getattr(current, bit)\n\t                except (TypeError, AttributeError):\n\t                    # Reraise if the exception was raised by a @property\n\t                    if bit in dir(current):\n", "                        raise\n\t                    try:  # list-index lookup\n\t                        current = current[int(bit)]\n\t                    except (\n\t                        IndexError,  # list index out of range\n\t                        ValueError,  # invalid literal for int()\n\t                        KeyError,  # current is a dict without `int(bit)` key\n\t                        TypeError,\n\t                    ):  # un-subscript-able object\n\t                        return default\n", "        return current\n\t    except Exception as e:  # noqa: BLE001 # pragma: no cover\n\t        if err_on_missing:\n\t            raise BadInputError(f\"Could not resolve '{name}'\") from e\n\t        else:\n\t            return default\n\tdef log_list(config: Config, version_part: Optional[str], new_version: Optional[str]) -> None:\n\t    \"\"\"Output configuration with new version.\"\"\"\n\t    ctx = get_context(config)\n\t    if version_part:\n", "        version = config.version_config.parse(config.current_version)\n\t        next_version = get_next_version(version, config, version_part, new_version)\n\t        next_version_str = config.version_config.serialize(next_version, ctx)\n\t        print_info(f\"new_version={next_version_str}\")\n\t    for key, value in config.dict(exclude={\"scm_info\", \"parts\"}).items():\n\t        print_info(f\"{key}={value}\")\n\tdef do_show(*args, config: Config, format_: str = \"default\", increment: Optional[str] = None) -> None:\n\t    \"\"\"Show current version or configuration information.\"\"\"\n\t    config_dict = config.dict()\n\t    ctx = get_context(config)\n", "    if increment:\n\t        version = config.version_config.parse(config.current_version)\n\t        next_version = get_next_version(version, config, increment, None)\n\t        next_version_str = config.version_config.serialize(next_version, ctx)\n\t        config_dict[\"new_version\"] = next_version_str\n\t    try:\n\t        if \"all\" in args or not args:\n\t            show_items = config_dict\n\t        else:\n\t            show_items = {key: resolve_name(config_dict, key) for key in args}\n", "        OUTPUTTERS.get(format_, OUTPUTTERS[\"default\"])(show_items)\n\t    except BadInputError as e:\n\t        print_error(e.message)\n"]}
{"filename": "bumpversion/autocast.py", "chunked_list": ["\"\"\"\n\tAutomatically detect the true Python type of a string and cast it to the correct type.\n\tBased on https://github.com/cgreer/cgAutoCast/blob/master/cgAutoCast.py\n\t\"\"\"\n\timport contextlib\n\tfrom typing import Any\n\tdef boolify(s: str) -> bool:\n\t    \"\"\"Convert a string to a boolean.\"\"\"\n\t    if s in {\"True\", \"true\"}:\n\t        return True\n", "    if s in {\"False\", \"false\"}:\n\t        return False\n\t    raise ValueError(\"Not Boolean Value!\")\n\tdef noneify(s: str) -> None:\n\t    \"\"\"Convert a string to None.\"\"\"\n\t    if s == \"None\":\n\t        return None\n\t    raise ValueError(\"Not None Value!\")\n\tdef listify(s: str) -> list:\n\t    \"\"\"\n", "    Convert a string representation of a list into list of homogenous basic types.\n\t    Type of elements in list is determined via first element. Successive elements are\n\t    cast to that type.\n\t    Args:\n\t        s: String representation of a list.\n\t    Raises:\n\t        ValueError: If string does not represent a list.\n\t        TypeError: If string does not represent a list of homogenous basic types.\n\t    Returns:\n\t        List of homogenous basic types.\n", "    \"\"\"\n\t    if \",\" not in s and \"\\n\" not in s:\n\t        raise ValueError(\"Not a List\")\n\t    # derive the type of the variable\n\t    str_list = s.strip().split(\",\") if \",\" in s else s.strip().split(\"\\n\")\n\t    element_caster = str\n\t    for caster in (boolify, int, float, noneify, element_caster):\n\t        with contextlib.suppress(ValueError):\n\t            caster(str_list[0])  # type: ignore[operator]\n\t            element_caster = caster  # type: ignore[assignment]\n", "            break\n\t    # cast all elements\n\t    try:\n\t        return [element_caster(x) for x in str_list]\n\t    except ValueError as e:\n\t        raise TypeError(\"Autocasted list must be all same type\") from e\n\tdef autocast_value(var: Any) -> Any:\n\t    \"\"\"\n\t    Guess the string representation of the variable's type.\n\t    Args:\n", "        var: Value to autocast.\n\t    Returns:\n\t        The autocasted value.\n\t    \"\"\"\n\t    if not isinstance(var, str):  # don't need to guess non-string types\n\t        return var\n\t    # guess string representation of var\n\t    for caster in (boolify, int, float, noneify, listify):\n\t        with contextlib.suppress(ValueError):\n\t            return caster(var)  # type: ignore[operator]\n", "    return var\n"]}
{"filename": "bumpversion/__init__.py", "chunked_list": ["\"\"\"Top-level package for bump-my-version.\"\"\"\n\t__version__: str = \"0.8.0\"\n"]}
{"filename": "bumpversion/utils.py", "chunked_list": ["\"\"\"General utilities.\"\"\"\n\timport string\n\tfrom collections import ChainMap\n\tfrom dataclasses import asdict\n\tfrom typing import TYPE_CHECKING, List, Optional\n\tif TYPE_CHECKING:  # pragma: no-coverage\n\t    from bumpversion.config import Config\n\t    from bumpversion.version_part import Version\n\tdef key_val_string(d: dict) -> str:\n\t    \"\"\"Render the dictionary as a comma-delimited key=value string.\"\"\"\n", "    return \", \".join(f\"{k}={v}\" for k, v in sorted(d.items()))\n\tdef prefixed_environ() -> dict:\n\t    \"\"\"Return a dict of the environment with keys wrapped in `${}`.\"\"\"\n\t    import os\n\t    return {f\"${key}\": value for key, value in os.environ.items()}\n\tdef labels_for_format(serialize_format: str) -> List[str]:\n\t    \"\"\"Return a list of labels for the given serialize_format.\"\"\"\n\t    return [item[1] for item in string.Formatter().parse(serialize_format) if item[1]]\n\tdef get_context(\n\t    config: \"Config\", current_version: Optional[\"Version\"] = None, new_version: Optional[\"Version\"] = None\n", ") -> ChainMap:\n\t    \"\"\"Return the context for rendering messages and tags.\"\"\"\n\t    import datetime\n\t    ctx = ChainMap(\n\t        {\"current_version\": config.current_version},\n\t        {\"now\": datetime.datetime.now(), \"utcnow\": datetime.datetime.utcnow()},\n\t        prefixed_environ(),\n\t        asdict(config.scm_info),\n\t        {c: c for c in (\"#\", \";\")},\n\t    )\n", "    if current_version:\n\t        ctx.new_child({f\"current_{part}\": current_version[part].value for part in current_version})\n\t    if new_version:\n\t        ctx.new_child({f\"new_{part}\": new_version[part].value for part in new_version})\n\t    return ctx\n\tdef get_overrides(**kwargs) -> dict:\n\t    \"\"\"Return a dictionary containing only the overridden key-values.\"\"\"\n\t    return {key: val for key, val in kwargs.items() if val is not None}\n"]}
{"filename": "bumpversion/version_part.py", "chunked_list": ["\"\"\"Module for managing Versions and their internal parts.\"\"\"\n\timport logging\n\timport re\n\timport string\n\tfrom copy import copy\n\tfrom typing import Any, Dict, List, MutableMapping, Optional\n\tfrom click import UsageError\n\tfrom bumpversion.config import VersionPartConfig\n\tfrom bumpversion.exceptions import FormattingError, InvalidVersionPartError, MissingValueError\n\tfrom bumpversion.functions import NumericFunction, PartFunction, ValuesFunction\n", "from bumpversion.utils import key_val_string, labels_for_format\n\tlogger = logging.getLogger(__name__)\n\tclass VersionPart:\n\t    \"\"\"\n\t    Represent part of a version number.\n\t    Determines the PartFunction that rules how the part behaves when increased or reset\n\t    based on the configuration given.\n\t    \"\"\"\n\t    def __init__(self, config: VersionPartConfig, value: Optional[str] = None):\n\t        self._value = value\n", "        self.config = config\n\t        self.func: Optional[PartFunction] = None\n\t        if config.values:\n\t            self.func = ValuesFunction(config.values, config.optional_value, config.first_value)\n\t        else:\n\t            self.func = NumericFunction(config.optional_value, config.first_value or \"0\")\n\t    @property\n\t    def value(self) -> str:\n\t        \"\"\"Return the value of the part.\"\"\"\n\t        return self._value or self.func.optional_value\n", "    def copy(self) -> \"VersionPart\":\n\t        \"\"\"Return a copy of the part.\"\"\"\n\t        return VersionPart(self.config, self._value)\n\t    def bump(self) -> \"VersionPart\":\n\t        \"\"\"Return a part with bumped value.\"\"\"\n\t        return VersionPart(self.config, self.func.bump(self.value))\n\t    def null(self) -> \"VersionPart\":\n\t        \"\"\"Return a part with first value.\"\"\"\n\t        return VersionPart(self.config, self.func.first_value)\n\t    @property\n", "    def is_optional(self) -> bool:\n\t        \"\"\"Is the part optional?\"\"\"\n\t        return self.value == self.func.optional_value\n\t    @property\n\t    def is_independent(self) -> bool:\n\t        \"\"\"Is the part independent of the other parts?\"\"\"\n\t        return self.config.independent\n\t    def __format__(self, format_spec: str) -> str:\n\t        try:\n\t            val = int(self.value)\n", "        except ValueError:\n\t            return self.value\n\t        else:\n\t            return int.__format__(val, format_spec)\n\t    def __repr__(self) -> str:\n\t        return f\"<bumpversion.VersionPart:{self.func.__class__.__name__}:{self.value}>\"\n\t    def __eq__(self, other: Any) -> bool:\n\t        return self.value == other.value if isinstance(other, VersionPart) else False\n\tclass Version:\n\t    \"\"\"The specification of a version and its parts.\"\"\"\n", "    def __init__(self, values: Dict[str, VersionPart], original: Optional[str] = None):\n\t        self.values = values\n\t        self.original = original\n\t    def __getitem__(self, key: str) -> VersionPart:\n\t        return self.values[key]\n\t    def __len__(self) -> int:\n\t        return len(self.values)\n\t    def __iter__(self):\n\t        return iter(self.values)\n\t    def __repr__(self):\n", "        return f\"<bumpversion.Version:{key_val_string(self.values)}>\"\n\t    def __eq__(self, other: Any) -> bool:\n\t        return (\n\t            all(value == other.values[key] for key, value in self.values.items())\n\t            if isinstance(other, Version)\n\t            else False\n\t        )\n\t    def bump(self, part_name: str, order: List[str]) -> \"Version\":\n\t        \"\"\"Increase the value of the given part.\"\"\"\n\t        bumped = False\n", "        new_values = {}\n\t        for label in order:\n\t            if label not in self.values:\n\t                continue\n\t            if label == part_name:\n\t                new_values[label] = self.values[label].bump()\n\t                bumped = True\n\t            elif bumped and not self.values[label].is_independent:\n\t                new_values[label] = self.values[label].null()\n\t            else:\n", "                new_values[label] = self.values[label].copy()\n\t        if not bumped:\n\t            raise InvalidVersionPartError(f\"No part named {part_name!r}\")\n\t        return Version(new_values)\n\tclass VersionConfig:\n\t    \"\"\"\n\t    Hold a complete representation of a version string.\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n", "        parse: str,\n\t        serialize: List[str],\n\t        search: str,\n\t        replace: str,\n\t        part_configs: Optional[Dict[str, VersionPartConfig]] = None,\n\t    ):\n\t        try:\n\t            self.parse_regex = re.compile(parse, re.VERBOSE)\n\t        except re.error as e:\n\t            raise UsageError(f\"--parse '{parse}' is not a valid regex.\") from e\n", "        self.serialize_formats = serialize\n\t        self.part_configs = part_configs or {}\n\t        self.search = search\n\t        self.replace = replace\n\t    @property\n\t    def order(self) -> List[str]:\n\t        \"\"\"\n\t        Return the order of the labels in a serialization format.\n\t        Currently, order depends on the first given serialization format.\n\t        This seems like a good idea because this should be the most complete format.\n", "        Returns:\n\t            A list of version part labels in the order they should be rendered.\n\t        \"\"\"\n\t        return labels_for_format(self.serialize_formats[0])\n\t    def parse(self, version_string: Optional[str] = None) -> Optional[Version]:\n\t        \"\"\"\n\t        Parse a version string into a Version object.\n\t        Args:\n\t            version_string: Version string to parse\n\t        Returns:\n", "            A Version object representing the string.\n\t        \"\"\"\n\t        if not version_string:\n\t            return None\n\t        regexp_one_line = \"\".join([line.split(\"#\")[0].strip() for line in self.parse_regex.pattern.splitlines()])\n\t        logger.info(\n\t            \"Parsing version '%s' using regexp '%s'\",\n\t            version_string,\n\t            regexp_one_line,\n\t        )\n", "        match = self.parse_regex.search(version_string)\n\t        if not match:\n\t            logger.warning(\n\t                \"Evaluating 'parse' option: '%s' does not parse current version '%s'\",\n\t                self.parse_regex.pattern,\n\t                version_string,\n\t            )\n\t            return None\n\t        _parsed = {\n\t            key: VersionPart(self.part_configs[key], value)\n", "            for key, value in match.groupdict().items()\n\t            if key in self.part_configs\n\t        }\n\t        v = Version(_parsed, version_string)\n\t        logger.info(\"Parsed the following values: %s\", key_val_string(v.values))\n\t        return v\n\t    def _serialize(\n\t        self, version: Version, serialize_format: str, context: MutableMapping, raise_if_incomplete: bool = False\n\t    ) -> str:\n\t        \"\"\"\n", "        Attempts to serialize a version with the given serialization format.\n\t        Args:\n\t            version: The version to serialize\n\t            serialize_format: The serialization format to use, using Python's format string syntax\n\t            context: The context to use when serializing the version\n\t            raise_if_incomplete: Whether to raise an error if the version is incomplete\n\t        Raises:\n\t            FormattingError: if not serializable\n\t            MissingValueError: if not all parts required in the format have values\n\t        Returns:\n", "            The serialized version as a string\n\t        \"\"\"\n\t        values = copy(context)\n\t        for k in version:\n\t            values[k] = version[k]\n\t        # TODO dump complete context on debug level\n\t        try:\n\t            # test whether all parts required in the format have values\n\t            serialized = serialize_format.format(**values)\n\t        except KeyError as e:\n", "            missing_key = getattr(e, \"message\", e.args[0])\n\t            raise MissingValueError(\n\t                f\"Did not find key {missing_key!r} in {version!r} when serializing version number\"\n\t            ) from e\n\t        keys_needing_representation = set()\n\t        keys = list(self.order)\n\t        for i, k in enumerate(keys):\n\t            v = values[k]\n\t            if not isinstance(v, VersionPart):\n\t                # values coming from environment variables don't need\n", "                # representation\n\t                continue\n\t            if not v.is_optional:\n\t                keys_needing_representation = set(keys[: i + 1])\n\t        required_by_format = set(labels_for_format(serialize_format))\n\t        # try whether all parsed keys are represented\n\t        if raise_if_incomplete and not keys_needing_representation <= required_by_format:\n\t            missing_keys = keys_needing_representation ^ required_by_format\n\t            raise FormattingError(\n\t                f\"\"\"Could not represent '{\"', '\".join(missing_keys)}' in format '{serialize_format}'\"\"\"\n", "            )\n\t        return serialized\n\t    def _choose_serialize_format(self, version: Version, context: MutableMapping) -> str:\n\t        chosen = None\n\t        logger.debug(\"Available serialization formats: '%s'\", \"', '\".join(self.serialize_formats))\n\t        for serialize_format in self.serialize_formats:\n\t            try:\n\t                self._serialize(version, serialize_format, context, raise_if_incomplete=True)\n\t                # Prefer shorter or first search expression.\n\t                chosen_part_count = len(list(string.Formatter().parse(chosen))) if chosen else None\n", "                serialize_part_count = len(list(string.Formatter().parse(serialize_format)))\n\t                if not chosen or chosen_part_count > serialize_part_count:\n\t                    chosen = serialize_format\n\t                    logger.debug(\"Found '%s' to be a usable serialization format\", chosen)\n\t                else:\n\t                    logger.debug(\"Found '%s' usable serialization format, but it's longer\", serialize_format)\n\t            except FormattingError:\n\t                # If chosen, prefer shorter\n\t                if not chosen:\n\t                    chosen = serialize_format\n", "            except MissingValueError as e:\n\t                logger.info(e.message)\n\t                raise e\n\t        if not chosen:\n\t            raise KeyError(\"Did not find suitable serialization format\")\n\t        logger.debug(\"Selected serialization format '%s'\", chosen)\n\t        return chosen\n\t    def serialize(self, version: Version, context: MutableMapping) -> str:\n\t        \"\"\"\n\t        Serialize a version to a string.\n", "        Args:\n\t            version: The version to serialize\n\t            context: The context to use when serializing the version\n\t        Returns:\n\t            The serialized version as a string\n\t        \"\"\"\n\t        serialized = self._serialize(version, self._choose_serialize_format(version, context), context)\n\t        logger.debug(\"Serialized to '%s'\", serialized)\n\t        return serialized\n"]}
{"filename": "bumpversion/aliases.py", "chunked_list": ["\"\"\"Utilities for handling command aliases.\"\"\"\n\tfrom typing import List, Optional\n\timport rich_click as click\n\tfrom click import Context\n\tfrom rich_click.rich_group import RichGroup\n\tfrom bumpversion.ui import print_warning\n\tclass AliasedGroup(RichGroup):\n\t    \"\"\"\n\t    This following example implements a subclass of Group that accepts a prefix for a command.\n\t    If there were a command called ``push``, it would accept ``pus`` as an alias (so long as it was unique)\n", "    \"\"\"\n\t    def get_command(self, ctx: Context, cmd_name: str) -> Optional[click.Command]:\n\t        \"\"\"Given a context and a command name, this returns a Command object if it exists or returns None.\"\"\"\n\t        rv = click.Group.get_command(self, ctx, cmd_name)\n\t        if rv is not None:\n\t            return rv\n\t        matches = [x for x in self.list_commands(ctx) if x.startswith(cmd_name)]\n\t        if not matches:\n\t            args = [cmd_name, *ctx.args]\n\t            new_ctx = self.make_context(ctx.info_name, args, parent=ctx)\n", "            return click.Group.get_command(self, new_ctx, \"bump\")\n\t        elif len(matches) == 1:\n\t            return click.Group.get_command(self, ctx, matches[0])\n\t        ctx.fail(f\"Too many matches: {', '.join(sorted(matches))}\")\n\t    def resolve_command(self, ctx: Context, args: List[str]) -> tuple:\n\t        \"\"\"Find the command and make sure the full command name is returned.\"\"\"\n\t        # always return the full command name\n\t        original_args = args[:]\n\t        _, cmd, args = super().resolve_command(ctx, args)\n\t        if cmd.name == \"bump\" and args != original_args:\n", "            if \"bump\" in original_args:\n\t                original_args.remove(\"bump\")\n\t            else:\n\t                print_warning(\n\t                    \"Calling bumpversion without a subcommand is deprecated. \" \"Please use `bumpversion bump` instead\"\n\t                )\n\t            return cmd.name, cmd, original_args\n\t        return cmd.name, cmd, args\n"]}
{"filename": "bumpversion/bump.py", "chunked_list": ["\"\"\"Version changing methods.\"\"\"\n\timport logging\n\timport shlex\n\tfrom pathlib import Path\n\tfrom typing import TYPE_CHECKING, ChainMap, List, Optional\n\tif TYPE_CHECKING:  # pragma: no-coverage\n\t    from bumpversion.files import ConfiguredFile\n\t    from bumpversion.version_part import Version\n\tfrom bumpversion.config import Config, update_config_file\n\tfrom bumpversion.exceptions import ConfigurationError\n", "from bumpversion.utils import get_context, key_val_string\n\tlogger = logging.getLogger(\"bumpversion\")\n\tdef get_next_version(\n\t    current_version: \"Version\", config: Config, version_part: Optional[str], new_version: Optional[str]\n\t) -> \"Version\":\n\t    \"\"\"\n\t    Bump the version_part to the next value.\n\t    Args:\n\t        current_version: The current version\n\t        config: The current configuration\n", "        version_part: Optional part of the version to bump\n\t        new_version: Optional specific version to bump to\n\t    Returns:\n\t        The new version\n\t    Raises:\n\t        ConfigurationError: If it can't generate the next version.\n\t    \"\"\"\n\t    if new_version:\n\t        next_version = config.version_config.parse(new_version)\n\t    elif version_part:\n", "        logger.info(\"Attempting to increment part '%s'\", version_part)\n\t        next_version = current_version.bump(version_part, config.version_config.order)\n\t    else:\n\t        raise ConfigurationError(\"Unable to get the next version.\")\n\t    logger.info(\"Values are now: %s\", key_val_string(next_version.values))\n\t    return next_version\n\tdef do_bump(\n\t    version_part: Optional[str],\n\t    new_version: Optional[str],\n\t    config: Config,\n", "    config_file: Optional[Path] = None,\n\t    dry_run: bool = False,\n\t) -> None:\n\t    \"\"\"\n\t    Bump the version_part to the next value or set the version to new_version.\n\t    Args:\n\t        version_part: The version part to bump\n\t        new_version: The explicit version to set\n\t        config: The configuration to use\n\t        config_file: The configuration file to update\n", "        dry_run: True if the operation should be a dry run\n\t    \"\"\"\n\t    from bumpversion.files import modify_files, resolve_file_config\n\t    ctx = get_context(config)\n\t    version = config.version_config.parse(config.current_version)\n\t    next_version = get_next_version(version, config, version_part, new_version)\n\t    next_version_str = config.version_config.serialize(next_version, ctx)\n\t    logger.info(\"New version will be '%s'\", next_version_str)\n\t    if config.current_version == next_version_str:\n\t        logger.info(\"Version is already '%s'\", next_version_str)\n", "        return\n\t    if dry_run:\n\t        logger.info(\"Dry run active, won't touch any files.\")\n\t    ctx = get_context(config, version, next_version)\n\t    configured_files = resolve_file_config(config.files, config.version_config)\n\t    modify_files(configured_files, version, next_version, ctx, dry_run)\n\t    update_config_file(config_file, config.current_version, next_version_str, dry_run)\n\t    commit_and_tag(config, config_file, configured_files, ctx, dry_run)\n\tdef commit_and_tag(\n\t    config: Config,\n", "    config_file: Optional[Path],\n\t    configured_files: List[\"ConfiguredFile\"],\n\t    ctx: ChainMap,\n\t    dry_run: bool = False,\n\t) -> None:\n\t    \"\"\"\n\t    Commit and tag the changes, if a tool is configured.\n\t    Args:\n\t        config: The configuration\n\t        config_file: The configuration file to include in the commit, if it exists\n", "        configured_files: A list of files to commit\n\t        ctx: The context used to render the tag and tag message\n\t        dry_run: True if the operation should be a dry run\n\t    \"\"\"\n\t    if not config.scm_info.tool:\n\t        return\n\t    extra_args = shlex.split(config.commit_args) if config.commit_args else []\n\t    commit_files = {f.path for f in configured_files}\n\t    if config_file:\n\t        commit_files |= {str(config_file)}\n", "    config.scm_info.tool.commit_to_scm(list(commit_files), config, ctx, extra_args, dry_run)\n\t    config.scm_info.tool.tag_in_scm(config, ctx, dry_run)\n"]}
{"filename": "bumpversion/exceptions.py", "chunked_list": ["\"\"\"Custom exceptions for BumpVersion.\"\"\"\n\tfrom typing import Optional\n\tfrom click import Context, UsageError\n\tclass BumpVersionError(UsageError):\n\t    \"\"\"Custom base class for all BumpVersion exception types.\"\"\"\n\t    def __init__(self, message: str, ctx: Optional[Context] = None):\n\t        self.message = message\n\t        self.ctx = ctx\n\tclass FormattingError(BumpVersionError):\n\t    \"\"\"We are unable to represent a version required by a format.\"\"\"\n", "    pass\n\tclass MissingValueError(BumpVersionError):\n\t    \"\"\"A part required for a version format is empty.\"\"\"\n\t    pass\n\tclass DirtyWorkingDirectoryError(BumpVersionError):\n\t    \"\"\"The working directory is dirty, and it is not allowed.\"\"\"\n\t    pass\n\tclass SignedTagsError(BumpVersionError):\n\t    \"\"\"The VCS does not support signed tags.\"\"\"\n\t    pass\n", "class VersionNotFoundError(BumpVersionError):\n\t    \"\"\"A version number was not found in a source file.\"\"\"\n\t    pass\n\tclass InvalidVersionPartError(BumpVersionError):\n\t    \"\"\"The specified part (e.g. 'bugfix') was not found.\"\"\"\n\t    pass\n\tclass ConfigurationError(BumpVersionError):\n\t    \"\"\"A configuration key-value is missing or in the wrong type.\"\"\"\n\t    pass\n\tclass BadInputError(BumpVersionError):\n", "    \"\"\"User input was bad.\"\"\"\n\t    pass\n"]}
{"filename": "bumpversion/cli.py", "chunked_list": ["\"\"\"bump-my-version Command line interface.\"\"\"\n\timport logging\n\tfrom typing import List, Optional\n\timport rich_click as click\n\tfrom click.core import Context\n\tfrom bumpversion import __version__\n\tfrom bumpversion.aliases import AliasedGroup\n\tfrom bumpversion.bump import do_bump\n\tfrom bumpversion.config import find_config_file, get_configuration\n\tfrom bumpversion.files import modify_files, resolve_file_config\n", "from bumpversion.logging import setup_logging\n\tfrom bumpversion.show import do_show, log_list\n\tfrom bumpversion.ui import print_warning\n\tfrom bumpversion.utils import get_context, get_overrides\n\tlogger = logging.getLogger(__name__)\n\t@click.group(\n\t    cls=AliasedGroup,\n\t    invoke_without_command=True,\n\t    context_settings={\n\t        \"ignore_unknown_options\": True,\n", "        \"allow_interspersed_args\": True,\n\t    },\n\t    add_help_option=False,\n\t)\n\t@click.version_option(version=__version__)\n\t@click.pass_context\n\tdef cli(ctx: Context) -> None:\n\t    \"\"\"Version bump your Python project.\"\"\"\n\t    if ctx.invoked_subcommand is None:\n\t        ctx.invoke(bump, *ctx.args)\n", "click.rich_click.OPTION_GROUPS = {\n\t    \"bumpversion bump\": [\n\t        {\n\t            \"name\": \"Configuration\",\n\t            \"options\": [\n\t                \"--config-file\",\n\t                \"--current-version\",\n\t                \"--new-version\",\n\t                \"--parse\",\n\t                \"--serialize\",\n", "                \"--search\",\n\t                \"--replace\",\n\t                \"--no-configured-files\",\n\t                \"--ignore-missing-version\",\n\t            ],\n\t        },\n\t        {\n\t            \"name\": \"Output\",\n\t            \"options\": [\"--dry-run\", \"--verbose\"],\n\t        },\n", "        {\n\t            \"name\": \"Committing and tagging\",\n\t            \"options\": [\n\t                \"--allow-dirty\" \"--commit\",\n\t                \"--commit-args\",\n\t                \"--message\",\n\t                \"--tag\",\n\t                \"--tag-name\",\n\t                \"--tag-message\",\n\t                \"--sign-tags\",\n", "            ],\n\t        },\n\t    ]\n\t}\n\t@cli.command(context_settings={\"ignore_unknown_options\": True})\n\t@click.argument(\"args\", nargs=-1, type=str)\n\t@click.option(\n\t    \"--config-file\",\n\t    metavar=\"FILE\",\n\t    required=False,\n", "    envvar=\"BUMPVERSION_CONFIG_FILE\",\n\t    type=click.Path(exists=True),\n\t    help=\"Config file to read most of the variables from.\",\n\t)\n\t@click.option(\n\t    \"-v\",\n\t    \"--verbose\",\n\t    count=True,\n\t    required=False,\n\t    envvar=\"BUMPVERSION_VERBOSE\",\n", "    help=\"Print verbose logging to stderr. Can specify several times for more verbosity.\",\n\t)\n\t@click.option(\n\t    \"--allow-dirty/--no-allow-dirty\",\n\t    default=None,\n\t    required=False,\n\t    envvar=\"BUMPVERSION_ALLOW_DIRTY\",\n\t    help=\"Don't abort if working directory is dirty, or explicitly abort if dirty.\",\n\t)\n\t@click.option(\n", "    \"--current-version\",\n\t    metavar=\"VERSION\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_CURRENT_VERSION\",\n\t    help=\"Version that needs to be updated\",\n\t)\n\t@click.option(\n\t    \"--new-version\",\n\t    metavar=\"VERSION\",\n\t    required=False,\n", "    envvar=\"BUMPVERSION_NEW_VERSION\",\n\t    help=\"New version that should be in the files\",\n\t)\n\t@click.option(\n\t    \"--parse\",\n\t    metavar=\"REGEX\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_PARSE\",\n\t    help=\"Regex parsing the version string\",\n\t)\n", "@click.option(\n\t    \"--serialize\",\n\t    metavar=\"FORMAT\",\n\t    multiple=True,\n\t    required=False,\n\t    envvar=\"BUMPVERSION_SERIALIZE\",\n\t    help=\"How to format what is parsed back to a version\",\n\t)\n\t@click.option(\n\t    \"--search\",\n", "    metavar=\"SEARCH\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_SEARCH\",\n\t    help=\"Template for complete string to search\",\n\t)\n\t@click.option(\n\t    \"--replace\",\n\t    metavar=\"REPLACE\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_REPLACE\",\n", "    help=\"Template for complete string to replace\",\n\t)\n\t@click.option(\n\t    \"--no-configured-files\",\n\t    is_flag=True,\n\t    envvar=\"BUMPVERSION_NO_CONFIGURED_FILES\",\n\t    help=(\n\t        \"Only replace the version in files specified on the command line, \"\n\t        \"ignoring the files from the configuration file.\"\n\t    ),\n", ")\n\t@click.option(\n\t    \"--ignore-missing-version\",\n\t    is_flag=True,\n\t    envvar=\"BUMPVERSION_IGNORE_MISSING_VERSION\",\n\t    help=\"Ignore any Version Not Found errors when searching and replacing in files.\",\n\t)\n\t@click.option(\n\t    \"--dry-run\",\n\t    \"-n\",\n", "    is_flag=True,\n\t    envvar=\"BUMPVERSION_DRY_RUN\",\n\t    help=\"Don't write any files, just pretend.\",\n\t)\n\t@click.option(\n\t    \"--commit/--no-commit\",\n\t    default=None,\n\t    envvar=\"BUMPVERSION_COMMIT\",\n\t    help=\"Commit to version control\",\n\t)\n", "@click.option(\n\t    \"--tag/--no-tag\",\n\t    default=None,\n\t    envvar=\"BUMPVERSION_TAG\",\n\t    help=\"Create a tag in version control\",\n\t)\n\t@click.option(\n\t    \"--sign-tags/--no-sign-tags\",\n\t    default=None,\n\t    envvar=\"BUMPVERSION_SIGN_TAGS\",\n", "    help=\"Sign tags if created\",\n\t)\n\t@click.option(\n\t    \"--tag-name\",\n\t    metavar=\"TAG_NAME\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_TAG_NAME\",\n\t    help=\"Tag name (only works with --tag)\",\n\t)\n\t@click.option(\n", "    \"--tag-message\",\n\t    metavar=\"TAG_MESSAGE\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_TAG_MESSAGE\",\n\t    help=\"Tag message\",\n\t)\n\t@click.option(\n\t    \"-m\",\n\t    \"--message\",\n\t    metavar=\"COMMIT_MSG\",\n", "    required=False,\n\t    envvar=\"BUMPVERSION_MESSAGE\",\n\t    help=\"Commit message\",\n\t)\n\t@click.option(\n\t    \"--commit-args\",\n\t    metavar=\"COMMIT_ARGS\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_COMMIT_ARGS\",\n\t    help=\"Extra arguments to commit command\",\n", ")\n\t@click.option(\n\t    \"--list\",\n\t    \"show_list\",\n\t    is_flag=True,\n\t    help=\"List machine readable information\",\n\t)\n\tdef bump(\n\t    # version_part: str,\n\t    args: list,\n", "    config_file: Optional[str],\n\t    verbose: int,\n\t    allow_dirty: Optional[bool],\n\t    current_version: Optional[str],\n\t    new_version: Optional[str],\n\t    parse: Optional[str],\n\t    serialize: Optional[List[str]],\n\t    search: Optional[str],\n\t    replace: Optional[str],\n\t    no_configured_files: bool,\n", "    ignore_missing_version: bool,\n\t    dry_run: bool,\n\t    commit: Optional[bool],\n\t    tag: Optional[bool],\n\t    sign_tags: Optional[bool],\n\t    tag_name: Optional[str],\n\t    tag_message: Optional[str],\n\t    message: Optional[str],\n\t    commit_args: Optional[str],\n\t    show_list: bool,\n", ") -> None:\n\t    \"\"\"\n\t    Change the version.\n\t    ARGS may contain any of the following:\n\t    VERSION_PART is the part of the version to increase, e.g. `minor` .\n\t    Valid values include those given in the `--serialize` / `--parse` option.\n\t    FILES are additional file(s) to modify.\n\t    If you want to rewrite only files specified on the command line, use with the\n\t    `--no-configured-files` option.\n\t    \"\"\"\n", "    setup_logging(verbose)\n\t    logger.info(\"Starting BumpVersion %s\", __version__)\n\t    overrides = get_overrides(\n\t        allow_dirty=allow_dirty,\n\t        current_version=current_version,\n\t        parse=parse,\n\t        serialize=serialize or None,\n\t        search=search,\n\t        replace=replace,\n\t        commit=commit,\n", "        tag=tag,\n\t        sign_tags=sign_tags,\n\t        tag_name=tag_name,\n\t        tag_message=tag_message,\n\t        message=message,\n\t        commit_args=commit_args,\n\t        ignore_missing_version=ignore_missing_version,\n\t    )\n\t    found_config_file = find_config_file(config_file)\n\t    config = get_configuration(found_config_file, **overrides)\n", "    if args:\n\t        if args[0] not in config.parts.keys():\n\t            raise click.BadArgumentUsage(f\"Unknown version part: {args[0]}\")\n\t        version_part = args[0]\n\t        files = args[1:]\n\t    else:\n\t        version_part = None\n\t        files = args\n\t    if show_list:\n\t        print_warning(\"DEPRECATED: The --list option is deprecated and will be removed in a future version.\")\n", "        log_list(config, version_part, new_version)\n\t        return\n\t    config.allow_dirty = allow_dirty if allow_dirty is not None else config.allow_dirty\n\t    if not config.allow_dirty and config.scm_info.tool:\n\t        config.scm_info.tool.assert_nondirty()\n\t    if no_configured_files:\n\t        config.files = []\n\t    if files:\n\t        config.add_files(files)\n\t    do_bump(version_part, new_version, config, found_config_file, dry_run)\n", "@cli.command()\n\t@click.argument(\"args\", nargs=-1, type=str)\n\t@click.option(\n\t    \"--config-file\",\n\t    metavar=\"FILE\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_CONFIG_FILE\",\n\t    type=click.Path(exists=True),\n\t    help=\"Config file to read most of the variables from.\",\n\t)\n", "@click.option(\n\t    \"-f\",\n\t    \"--format\",\n\t    \"format_\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_FORMAT\",\n\t    type=click.Choice([\"default\", \"yaml\", \"json\"], case_sensitive=False),\n\t    default=\"default\",\n\t    help=\"Config file to read most of the variables from.\",\n\t)\n", "@click.option(\n\t    \"-i\",\n\t    \"--increment\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_INCREMENT\",\n\t    type=str,\n\t    help=\"Increment the version part and add `new_version` to the configuration.\",\n\t)\n\tdef show(args: List[str], config_file: Optional[str], format_: str, increment: Optional[str]) -> None:\n\t    \"\"\"Show current configuration information.\"\"\"\n", "    found_config_file = find_config_file(config_file)\n\t    config = get_configuration(found_config_file)\n\t    if not args:\n\t        do_show(\"all\", config=config, format_=format_, increment=increment)\n\t    else:\n\t        do_show(*args, config=config, format_=format_, increment=increment)\n\t@cli.command()\n\t@click.argument(\"files\", nargs=-1, type=str)\n\t@click.option(\n\t    \"--config-file\",\n", "    metavar=\"FILE\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_CONFIG_FILE\",\n\t    type=click.Path(exists=True),\n\t    help=\"Config file to read most of the variables from.\",\n\t)\n\t@click.option(\n\t    \"-v\",\n\t    \"--verbose\",\n\t    count=True,\n", "    required=False,\n\t    envvar=\"BUMPVERSION_VERBOSE\",\n\t    help=\"Print verbose logging to stderr. Can specify several times for more verbosity.\",\n\t)\n\t@click.option(\n\t    \"--allow-dirty/--no-allow-dirty\",\n\t    default=None,\n\t    required=False,\n\t    envvar=\"BUMPVERSION_ALLOW_DIRTY\",\n\t    help=\"Don't abort if working directory is dirty, or explicitly abort if dirty.\",\n", ")\n\t@click.option(\n\t    \"--current-version\",\n\t    metavar=\"VERSION\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_CURRENT_VERSION\",\n\t    help=\"Version that needs to be updated\",\n\t)\n\t@click.option(\n\t    \"--new-version\",\n", "    metavar=\"VERSION\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_NEW_VERSION\",\n\t    help=\"New version that should be in the files. If not specified, it will be None.\",\n\t)\n\t@click.option(\n\t    \"--parse\",\n\t    metavar=\"REGEX\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_PARSE\",\n", "    help=\"Regex parsing the version string\",\n\t)\n\t@click.option(\n\t    \"--serialize\",\n\t    metavar=\"FORMAT\",\n\t    multiple=True,\n\t    required=False,\n\t    envvar=\"BUMPVERSION_SERIALIZE\",\n\t    help=\"How to format what is parsed back to a version\",\n\t)\n", "@click.option(\n\t    \"--search\",\n\t    metavar=\"SEARCH\",\n\t    required=False,\n\t    envvar=\"BUMPVERSION_SEARCH\",\n\t    help=\"Template for complete string to search\",\n\t)\n\t@click.option(\n\t    \"--replace\",\n\t    metavar=\"REPLACE\",\n", "    required=False,\n\t    envvar=\"BUMPVERSION_REPLACE\",\n\t    help=\"Template for complete string to replace\",\n\t)\n\t@click.option(\n\t    \"--no-configured-files\",\n\t    is_flag=True,\n\t    envvar=\"BUMPVERSION_NO_CONFIGURED_FILES\",\n\t    help=(\n\t        \"Only replace the version in files specified on the command line, \"\n", "        \"ignoring the files from the configuration file.\"\n\t    ),\n\t)\n\t@click.option(\n\t    \"--ignore-missing-version\",\n\t    is_flag=True,\n\t    envvar=\"BUMPVERSION_IGNORE_MISSING_VERSION\",\n\t    help=\"Ignore any Version Not Found errors when searching and replacing in files.\",\n\t)\n\t@click.option(\n", "    \"--dry-run\",\n\t    \"-n\",\n\t    is_flag=True,\n\t    envvar=\"BUMPVERSION_DRY_RUN\",\n\t    help=\"Don't write any files, just pretend.\",\n\t)\n\tdef replace(\n\t    files: list,\n\t    config_file: Optional[str],\n\t    verbose: int,\n", "    allow_dirty: Optional[bool],\n\t    current_version: Optional[str],\n\t    new_version: Optional[str],\n\t    parse: Optional[str],\n\t    serialize: Optional[List[str]],\n\t    search: Optional[str],\n\t    replace: Optional[str],\n\t    no_configured_files: bool,\n\t    ignore_missing_version: bool,\n\t    dry_run: bool,\n", ") -> None:\n\t    \"\"\"\n\t    Replace the version in files.\n\t    FILES are additional file(s) to modify.\n\t    If you want to rewrite only files specified on the command line, use with the\n\t    `--no-configured-files` option.\n\t    \"\"\"\n\t    setup_logging(verbose)\n\t    logger.info(\"Starting BumpVersion %s\", __version__)\n\t    overrides = get_overrides(\n", "        allow_dirty=allow_dirty,\n\t        current_version=current_version,\n\t        new_version=new_version,\n\t        parse=parse,\n\t        serialize=serialize or None,\n\t        commit=False,\n\t        tag=False,\n\t        sign_tags=False,\n\t        tag_name=None,\n\t        tag_message=None,\n", "        message=None,\n\t        commit_args=None,\n\t        ignore_missing_version=ignore_missing_version,\n\t    )\n\t    found_config_file = find_config_file(config_file)\n\t    config = get_configuration(found_config_file, **overrides)\n\t    config.allow_dirty = allow_dirty if allow_dirty is not None else config.allow_dirty\n\t    if not config.allow_dirty and config.scm_info.tool:\n\t        config.scm_info.tool.assert_nondirty()\n\t    if no_configured_files:\n", "        config.files = []\n\t    if files:\n\t        config.add_files(files)\n\t    version = config.version_config.parse(config.current_version)\n\t    if new_version:\n\t        next_version = config.version_config.parse(new_version)\n\t    else:\n\t        next_version = None\n\t    ctx = get_context(config, version, next_version)\n\t    configured_files = resolve_file_config(config.files, config.version_config, search, replace)\n", "    modify_files(configured_files, version, next_version, ctx, dry_run)\n"]}
{"filename": "bumpversion/logging.py", "chunked_list": ["\"\"\"Logging configuration for bumpversion.\"\"\"\n\timport logging\n\timport click\n\tfrom rich.logging import RichHandler\n\tlogger = logging.getLogger(\"bumpversion\")\n\tVERBOSITY = {\n\t    0: logging.WARNING,\n\t    1: logging.INFO,\n\t    2: logging.DEBUG,\n\t}\n", "def setup_logging(verbose: int = 0) -> None:\n\t    \"\"\"Configure the logging.\"\"\"\n\t    logging.basicConfig(\n\t        level=VERBOSITY.get(verbose, logging.DEBUG),\n\t        format=\"%(message)s\",\n\t        datefmt=\"[%X]\",\n\t        handlers=[\n\t            RichHandler(\n\t                rich_tracebacks=True, show_level=False, show_path=False, show_time=False, tracebacks_suppress=[click]\n\t            )\n", "        ],\n\t    )\n\t    root_logger = logging.getLogger(\"\")\n\t    root_logger.setLevel(VERBOSITY.get(verbose, logging.DEBUG))\n"]}
{"filename": "tests/test_yaml.py", "chunked_list": ["\"\"\"Tests for the yaml serialization module.\"\"\"\n\tfrom pathlib import Path\n\tfrom bumpversion import yaml_dump\n\tfrom datetime import datetime, date\n\tdef test_dump_unknown():\n\t    assert yaml_dump.dump((1, 2)) == '\"(1, 2)\"'\n\tdef test_format_str():\n\t    assert yaml_dump.format_str(\"value\") == '\"value\"'\n\tdef test_format_int():\n\t    assert yaml_dump.format_int(10) == \"10\"\n", "def test_format_float():\n\t    assert yaml_dump.format_float(1.0) == \"1.0\"\n\t    assert yaml_dump.format_float(1e300) == \".inf\"\n\t    assert yaml_dump.format_float(-1e300) == \"-.inf\"\n\t    assert yaml_dump.format_float(1e17) == \"1.0e+17\"\n\t    assert yaml_dump.format_float(float(\"nan\")) == \".nan\"\n\tdef test_format_bool():\n\t    assert yaml_dump.format_bool(True) == \"true\"\n\t    assert yaml_dump.format_bool(False) == \"false\"\n\tdef test_format_dict():\n", "    test_dict = {\n\t        \"key\": \"strval\",\n\t        \"key2\": 30,\n\t        \"key3\": datetime(2023, 6, 19, 13, 45, 30),\n\t        \"key4\": date(2023, 6, 19),\n\t        \"key5\": {\"subkey\": \"subval\"},\n\t        \"key6\": [1, 2, 3],\n\t        \"key7\": None,\n\t        \"key8\": True,\n\t        \"key9\": False,\n", "        \"key10\": 1.43,\n\t    }\n\t    expected = (\n\t        'key: \"strval\"\\n'\n\t        \"key10: 1.43\\n\"\n\t        \"key2: 30\\n\"\n\t        \"key3: 2023-06-19 13:45:30\\n\"\n\t        \"key4: 2023-06-19\\n\"\n\t        \"key5:\\n\"\n\t        '  subkey: \"subval\"\\n'\n", "        \"key6:\\n\"\n\t        \"  - 1\\n\"\n\t        \"  - 2\\n\"\n\t        \"  - 3\\n\"\n\t        \"key7: null\\n\"\n\t        \"key8: true\\n\"\n\t        \"key9: false\\n\"\n\t    )\n\t    assert yaml_dump.format_dict(test_dict) == expected\n\tdef test_format_list():\n", "    assert yaml_dump.format_list([\"item\"]) == '- \"item\"\\n'\n\t    assert yaml_dump.format_list([\"item\", [\"item2\"]]) == '- \"item\"\\n-\\n  - \"item2\"\\n'\n\tdef test_dump_none_val():\n\t    assert yaml_dump.format_none(None) == \"null\"\n\tdef test_dump_date_val():\n\t    test_date = date(2023, 6, 19)\n\t    assert yaml_dump.format_date(test_date) == \"2023-06-19\"\n\tdef test_dump_datetime_val():\n\t    test_datetime = datetime(2023, 6, 19, 13, 45, 30)\n\t    assert yaml_dump.format_datetime(test_datetime) == \"2023-06-19 13:45:30\"\n"]}
{"filename": "tests/test_autocast.py", "chunked_list": ["\"\"\"Tests for the autocast module.\"\"\"\n\timport pytest\n\tfrom pytest import param\n\tfrom bumpversion import autocast\n\t@pytest.mark.parametrize(\n\t    \"value, expected\",\n\t    [\n\t        param(\"true\", True, id=\"true\"),\n\t        param(\"false\", False, id=\"false\"),\n\t        param(\"True\", True, id=\"True\"),\n", "        param(\"False\", False, id=\"False\"),\n\t    ],\n\t)\n\tdef test_boolify_valid(value: str, expected: bool) -> None:\n\t    \"\"\"Test the boolify function.\"\"\"\n\t    assert autocast.boolify(value) == expected\n\t@pytest.mark.parametrize(\n\t    \"value\",\n\t    [\n\t        param(1, id=\"int\"),\n", "        param(\"string\", id=\"str\"),\n\t    ],\n\t)\n\tdef test_boolify_invalid(value):\n\t    \"\"\"Test the boolify function.\"\"\"\n\t    with pytest.raises(ValueError):\n\t        autocast.boolify(value)\n\tdef test_noneify():\n\t    \"\"\"noneify should return None if the string is None.\"\"\"\n\t    assert autocast.noneify(\"None\") is None\n", "    with pytest.raises(ValueError):\n\t        autocast.noneify(\"0\")\n\t@pytest.mark.parametrize(\n\t    \"value,expected\",\n\t    [\n\t        param(\"1,2,3,4\", [1, 2, 3, 4], id=\"int\"),\n\t        param(\"1\\n2\\n3\\n4\", [1, 2, 3, 4], id=\"int\"),\n\t        param(\"s,t,r\", [\"s\", \"t\", \"r\"], id=\"str\"),\n\t        param(\"1.1,2,3.14\", [1.1, 2.0, 3.14], id=\"float\"),\n\t        param(\"True,False,true,false\", [True, False, True, False], id=\"bool\"),\n", "        param(\"None,None,None\", [None, None, None], id=\"none\"),\n\t        param(\"\\nNone\\nNone\\nNone\\n\", [None, None, None], id=\"none with extra newlines\"),\n\t    ],\n\t)\n\tdef test_listify_valid(value, expected):\n\t    \"\"\"Test the listify function.\"\"\"\n\t    assert autocast.listify(value) == expected\n\tdef test_listify_invalid():\n\t    \"\"\"Every element of the list should be the same type.\"\"\"\n\t    with pytest.raises(TypeError):\n", "        autocast.listify(\"True,1,None\")\n\t    with pytest.raises(ValueError):\n\t        autocast.listify(\"I am not a list\")\n\t@pytest.mark.parametrize(\n\t    \"value,expected\",\n\t    [\n\t        param(\"true\", True, id=\"true\"),\n\t        param(\"false\", False, id=\"false\"),\n\t        param(\"True\", True, id=\"True\"),\n\t        param(\"False\", False, id=\"False\"),\n", "        param(\"1,2,3,4\", [1, 2, 3, 4], id=\"int-list\"),\n\t        param(\"s,t,r\", [\"s\", \"t\", \"r\"], id=\"str-list\"),\n\t        param(\"1\", 1, id=\"int\"),\n\t        param(\"1.0\", 1.0, id=\"float\"),\n\t        param(1, 1, id=\"real-int\"),\n\t    ],\n\t)\n\tdef test_autocast_value(value, expected):\n\t    \"\"\"Test basic functionality of autocast_value.\"\"\"\n\t    assert autocast.autocast_value(value) == expected\n"]}
{"filename": "tests/test_scm.py", "chunked_list": ["\"\"\"Tests of the VCS module.\"\"\"\n\timport subprocess\n\tfrom pathlib import Path\n\timport pytest\n\tfrom pytest import param, LogCaptureFixture\n\tfrom bumpversion import scm\n\tfrom bumpversion.exceptions import DirtyWorkingDirectoryError\n\tfrom bumpversion.logging import setup_logging\n\tfrom tests.conftest import get_config_data, inside_dir\n\tdef test_git_is_usable(git_repo: Path) -> None:\n", "    \"\"\"Should return true if git is available, and it is a git repo.\"\"\"\n\t    with inside_dir(git_repo):\n\t        assert scm.Git.is_usable()\n\tdef test_git_is_not_usable(tmp_path: Path) -> None:\n\t    \"\"\"Should return false if it is not a git repo.\"\"\"\n\t    with inside_dir(tmp_path):\n\t        assert not scm.Git.is_usable()\n\tdef test_git_asserts_not_dirty(git_repo: Path) -> None:\n\t    \"\"\"If the git repo is clean, assert_notdirty should return true.\"\"\"\n\t    with inside_dir(git_repo):\n", "        scm.Git.assert_nondirty()\n\tdef test_git_asserts_dirty(git_repo: Path) -> None:\n\t    \"\"\"If the git repo has modified files, assert_notdirty should return false.\"\"\"\n\t    readme = git_repo.joinpath(\"readme.md\")\n\t    readme.touch()\n\t    with pytest.raises(DirtyWorkingDirectoryError):\n\t        with inside_dir(git_repo):\n\t            subprocess.run([\"git\", \"add\", \"readme.md\"])\n\t            scm.Git.assert_nondirty()\n\tdef test_git_latest_tag_info(git_repo: Path) -> None:\n", "    \"\"\"Should return information about the latest tag.\"\"\"\n\t    readme = git_repo.joinpath(\"readme.md\")\n\t    readme.touch()\n\t    with inside_dir(git_repo):\n\t        assert scm.Git.latest_tag_info(\"v*\") == scm.SCMInfo(tool=scm.Git)\n\t        # Add a file and tag\n\t        subprocess.run([\"git\", \"add\", \"readme.md\"])\n\t        subprocess.run([\"git\", \"commit\", \"-m\", \"first\"])\n\t        subprocess.run([\"git\", \"tag\", \"v0.1.0\"])\n\t        tag_info = scm.Git.latest_tag_info(\"v*\")\n", "        assert tag_info.commit_sha is not None\n\t        assert tag_info.current_version == \"0.1.0\"\n\t        assert tag_info.distance_to_latest_tag == 0\n\t        # Make it dirty\n\t        git_repo.joinpath(\"something.md\").touch()\n\t        subprocess.run([\"git\", \"add\", \"something.md\"])\n\t        tag_info = scm.Git.latest_tag_info(\"v*\")\n\t        assert tag_info.commit_sha is not None\n\t        assert tag_info.current_version == \"0.1.0\"\n\t        assert tag_info.distance_to_latest_tag == 0\n", "        assert tag_info.dirty is True\n\tdef test_git_detects_existing_tag(git_repo: Path, caplog: LogCaptureFixture) -> None:\n\t    \"\"\"Attempting to tag when a tag exists will do nothing.\"\"\"\n\t    # Arrange\n\t    git_repo.joinpath(\"readme.md\").touch()\n\t    git_repo.joinpath(\"something.md\").touch()\n\t    overrides = {\"current_version\": \"0.1.0\", \"commit\": True, \"tag\": True}\n\t    context = {\n\t        \"current_version\": \"0.1.0\",\n\t        \"new_version\": \"0.2.0\",\n", "    }\n\t    setup_logging(2)\n\t    with inside_dir(git_repo):\n\t        conf, version_config, current_version = get_config_data(overrides)\n\t        subprocess.run([\"git\", \"add\", \"readme.md\"])\n\t        subprocess.run([\"git\", \"commit\", \"-m\", \"first\"])\n\t        subprocess.run([\"git\", \"tag\", \"v0.1.0\"])\n\t        subprocess.run([\"git\", \"add\", \"something.md\"])\n\t        subprocess.run([\"git\", \"commit\", \"-m\", \"second\"])\n\t        subprocess.run([\"git\", \"tag\", \"v0.2.0\"])\n", "        # Act\n\t        scm.Git.tag_in_scm(config=conf, context=context)\n\t    # Assert\n\t    assert \"Will not tag\" in caplog.text\n\tdef test_hg_is_not_usable(tmp_path: Path) -> None:\n\t    \"\"\"Should return false if it is not a mercurial repo.\"\"\"\n\t    with inside_dir(tmp_path):\n\t        assert not scm.Mercurial.is_usable()\n\tdef test_hg_is_usable(hg_repo: Path) -> None:\n\t    \"\"\"Should return false if it is not a mercurial repo.\"\"\"\n", "    with inside_dir(hg_repo):\n\t        assert scm.Mercurial.is_usable()\n\t@pytest.mark.parametrize(\n\t    [\"repo\", \"scm_command\", \"scm_class\"],\n\t    [\n\t        param(\"git_repo\", \"git\", scm.Git, id=\"git\"),\n\t        param(\"hg_repo\", \"hg\", scm.Mercurial, id=\"hg\"),\n\t    ],\n\t)\n\tdef test_commit_and_tag_from_below_scm_root(repo: str, scm_command: str, scm_class: scm.SourceCodeManager, request):\n", "    # Arrange\n\t    repo_path: Path = request.getfixturevalue(repo)\n\t    version_path = repo_path / \"VERSION\"\n\t    version_path.write_text(\"30.0.3\")\n\t    sub_dir_path = repo_path / \"subdir\"\n\t    sub_dir_path.mkdir(exist_ok=True)\n\t    overrides = {\"current_version\": \"30.0.3\", \"commit\": True, \"tag\": True, \"files\": [{\"filename\": str(version_path)}]}\n\t    context = {\n\t        \"current_version\": \"30.0.3\",\n\t        \"new_version\": \"30.1.0\",\n", "    }\n\t    with inside_dir(repo_path):\n\t        conf, version_config, current_version = get_config_data(overrides)\n\t        subprocess.run([scm_command, \"add\", \"VERSION\"], check=True, capture_output=True)\n\t        subprocess.run([scm_command, \"commit\", \"-m\", \"initial commit\"], check=True, capture_output=True)\n\t        with inside_dir(sub_dir_path):\n\t            version_path.write_text(\"30.1.0\")\n\t            # Act\n\t            scm_class.commit_to_scm(files=[version_path], config=conf, context=context)\n\t            scm_class.tag_in_scm(config=conf, context=context)\n", "        # Assert\n\t        tag_info = scm_class.latest_tag_info(\"v*\")\n\t        if scm_command == \"git\":\n\t            assert tag_info.commit_sha is not None\n\t            assert tag_info.distance_to_latest_tag == 0\n\t        assert tag_info.current_version == \"30.1.0\"\n\t        assert tag_info.dirty is False\n\t# write tests for no-commit, no-tag and dry-run\n\t@pytest.mark.parametrize(\n\t    [\"repo\", \"scm_command\", \"scm_class\"],\n", "    [\n\t        param(\"git_repo\", \"git\", scm.Git, id=\"git\"),\n\t        param(\"hg_repo\", \"hg\", scm.Mercurial, id=\"hg\"),\n\t    ],\n\t)\n\t@pytest.mark.parametrize(\n\t    [\"commit\", \"tag\", \"dry_run\", \"should_commit\", \"should_tag\"],\n\t    [\n\t        param(True, True, True, False, False, id=\"dry-run-stops-commit-and-tag\"),\n\t        param(True, False, False, True, False, id=\"commit-no-tag\"),\n", "        param(False, True, False, False, False, id=\"no-commit-stops-tag\"),\n\t    ],\n\t)\n\tdef test_commit_tag_dry_run_interactions(\n\t    repo: str,\n\t    scm_command: str,\n\t    scm_class: scm.SourceCodeManager,\n\t    commit: bool,\n\t    tag: bool,\n\t    dry_run: bool,\n", "    should_commit: bool,\n\t    should_tag: bool,\n\t    caplog: LogCaptureFixture,\n\t    request,\n\t):\n\t    \"\"\"Combinations of commit, tag, dry-run and should produce the expected results.\"\"\"\n\t    # Arrange\n\t    repo_path: Path = request.getfixturevalue(repo)\n\t    version_path = repo_path / \"VERSION\"\n\t    version_path.write_text(\"30.0.3\")\n", "    overrides = {\"current_version\": \"30.0.3\", \"commit\": commit, \"tag\": tag, \"files\": [{\"filename\": str(version_path)}]}\n\t    context = {\n\t        \"current_version\": \"30.0.3\",\n\t        \"new_version\": \"30.1.0\",\n\t    }\n\t    with inside_dir(repo_path):\n\t        conf, version_config, current_version = get_config_data(overrides)\n\t        subprocess.run([scm_command, \"add\", \"VERSION\"], check=True, capture_output=True)\n\t        subprocess.run([scm_command, \"commit\", \"-m\", \"initial commit\"], check=True, capture_output=True)\n\t        version_path.write_text(\"30.1.0\")\n", "        # Act\n\t        scm_class.commit_to_scm(files=[version_path], config=conf, context=context, dry_run=dry_run)\n\t        scm_class.tag_in_scm(config=conf, context=context, dry_run=dry_run)\n\t        # Assert\n\t        if commit and dry_run:\n\t            assert \"Would commit\" in caplog.text\n\t        elif should_commit:\n\t            assert \"Committing \" in caplog.text\n\t        else:\n\t            assert \"Would not commit\" in caplog.text\n", "        if tag and dry_run:\n\t            assert \"Would tag\" in caplog.text\n\t        elif should_tag:\n\t            assert \"Tagging \" in caplog.text\n\t        else:\n\t            assert \"Would not tag\" in caplog.text\n"]}
{"filename": "tests/test_functions.py", "chunked_list": ["import pytest\n\tfrom bumpversion.functions import NumericFunction, ValuesFunction\n\t# NumericFunction\n\tdef test_numeric_init_wo_first_value():\n\t    func = NumericFunction()\n\t    assert func.first_value == \"0\"\n\tdef test_numeric_init_w_first_value():\n\t    func = NumericFunction(first_value=\"5\")\n\t    assert func.first_value == \"5\"\n\tdef test_numeric_init_non_numeric_first_value():\n", "    with pytest.raises(ValueError):\n\t        NumericFunction(first_value=\"a\")\n\tdef test_numeric_bump_simple_number():\n\t    func = NumericFunction()\n\t    assert func.bump(\"0\") == \"1\"\n\tdef test_numeric_bump_prefix_and_suffix():\n\t    func = NumericFunction()\n\t    assert func.bump(\"v0b\") == \"v1b\"\n\t# ValuesFunction\n\tdef test_values_init():\n", "    func = ValuesFunction([\"0\", \"1\", \"2\"])\n\t    assert func.optional_value == \"0\"\n\t    assert func.first_value == \"0\"\n\tdef test_values_init_w_correct_optional_value():\n\t    func = ValuesFunction([\"0\", \"1\", \"2\"], optional_value=\"1\")\n\t    assert func.optional_value == \"1\"\n\t    assert func.first_value == \"0\"\n\tdef test_values_init_w_correct_first_value():\n\t    func = ValuesFunction([\"0\", \"1\", \"2\"], first_value=\"1\")\n\t    assert func.optional_value == \"0\"\n", "    assert func.first_value == \"1\"\n\tdef test_values_init_w_correct_optional_and_first_value():\n\t    func = ValuesFunction([\"0\", \"1\", \"2\"], optional_value=\"0\", first_value=\"1\")\n\t    assert func.optional_value == \"0\"\n\t    assert func.first_value == \"1\"\n\tdef test_values_init_w_empty_values():\n\t    with pytest.raises(ValueError):\n\t        ValuesFunction([])\n\tdef test_values_init_w_incorrect_optional_value():\n\t    with pytest.raises(ValueError):\n", "        ValuesFunction([\"0\", \"1\", \"2\"], optional_value=\"3\")\n\tdef test_values_init_w_incorrect_first_value():\n\t    with pytest.raises(ValueError):\n\t        ValuesFunction([\"0\", \"1\", \"2\"], first_value=\"3\")\n\tdef test_values_bump():\n\t    func = ValuesFunction([\"0\", \"5\", \"10\"])\n\t    assert func.bump(\"0\") == \"5\"\n\tdef test_values_bump_max():\n\t    func = ValuesFunction([\"0\", \"5\", \"10\"])\n\t    with pytest.raises(ValueError):\n", "        func.bump(\"10\")\n"]}
{"filename": "tests/test_bump.py", "chunked_list": ["\"\"\"Tests for the bump module.\"\"\"\n\tfrom pathlib import Path\n\tfrom unittest.mock import MagicMock, patch\n\timport pytest\n\tfrom bumpversion import bump\n\tfrom bumpversion.exceptions import ConfigurationError\n\tfrom bumpversion.files import ConfiguredFile\n\tfrom bumpversion.scm import Git, SCMInfo\n\tfrom tests.conftest import get_config_data, inside_dir\n\t@pytest.fixture\n", "def mock_context():\n\t    return {\"current_version\": \"1.2.3\", \"new_version\": \"1.2.4\"}\n\tdef test_get_next_version_with_new_version():\n\t    \"\"\"Passing a new version should return that version.\"\"\"\n\t    # Arrange\n\t    config, version_config, current_version = get_config_data({\"current_version\": \"0.1.0\"})\n\t    version_part = \"patch\"\n\t    new_version = \"1.2.3\"\n\t    expected_next_version = version_config.parse(\"1.2.3\")\n\t    # Act\n", "    actual_next_version = bump.get_next_version(current_version, config, version_part, new_version)\n\t    # Assert\n\t    assert actual_next_version == expected_next_version\n\tdef test_get_next_version_with_version_part():\n\t    \"\"\"If a version part is provided, it should return the increment of that part.\"\"\"\n\t    # Arrange\n\t    config, version_config, current_version = get_config_data({\"current_version\": \"0.1.0\"})\n\t    version_part = \"major\"\n\t    new_version = None\n\t    expected_next_version = version_config.parse(\"1.0.0\")\n", "    # Act\n\t    actual_next_version = bump.get_next_version(current_version, config, version_part, new_version)\n\t    # Assert\n\t    assert actual_next_version == expected_next_version\n\tdef test_get_next_version_with_no_arguments():\n\t    # Arrange\n\t    current_version = MagicMock()\n\t    config = MagicMock()\n\t    version_part = None\n\t    new_version = None\n", "    # Act/Assert\n\t    with pytest.raises(ConfigurationError):\n\t        bump.get_next_version(current_version, config, version_part, new_version)\n\t@patch(\"bumpversion.files.modify_files\")\n\t@patch(\"bumpversion.bump.update_config_file\")\n\tdef test_do_bump_with_version_part(mock_update_config_file, mock_modify_files):\n\t    # Arrange\n\t    version_part = \"major\"\n\t    new_version = None\n\t    config, version_config, current_version = get_config_data(\n", "        {\"current_version\": \"1.2.3\", \"files\": [{\"filename\": \"foo.txt\"}, {\"filename\": \"bar.txt\"}]}\n\t    )\n\t    config.scm_info = SCMInfo()\n\t    dry_run = False\n\t    # Act\n\t    bump.do_bump(version_part, new_version, config, dry_run=dry_run)\n\t    # Assert\n\t    mock_modify_files.assert_called_once()\n\t    mock_update_config_file.assert_called_once()\n\t    assert {f.path for f in mock_modify_files.call_args[0][0]} == {\n", "        \"foo.txt\",\n\t        \"bar.txt\",\n\t    }\n\t    assert mock_update_config_file.call_args[0][0] is None\n\t    assert mock_update_config_file.call_args[0][1] == config.current_version\n\t    assert mock_update_config_file.call_args[0][2] == \"2.0.0\"\n\t    assert mock_update_config_file.call_args[0][3] is False\n\t@patch(\"bumpversion.files.modify_files\")\n\t@patch(\"bumpversion.bump.update_config_file\")\n\tdef test_do_bump_with_new_version(mock_update_config_file, mock_modify_files):\n", "    # Arrange\n\t    version_part = None\n\t    new_version = \"2.0.0\"\n\t    config, version_config, current_version = get_config_data(\n\t        {\n\t            \"current_version\": \"1.2.3\",\n\t        }\n\t    )\n\t    config.scm_info = SCMInfo()\n\t    dry_run = True\n", "    # Act\n\t    bump.do_bump(version_part, new_version, config, dry_run=dry_run)\n\t    # Assert\n\t    mock_modify_files.assert_called_once()\n\t    assert mock_modify_files.call_args[0][0] == []\n\t    assert mock_modify_files.call_args[0][1] == current_version\n\t    assert mock_modify_files.call_args[0][2] == version_config.parse(new_version)\n\t    mock_update_config_file.assert_called_once()\n\t    assert mock_update_config_file.call_args[0][0] is None\n\t    assert mock_update_config_file.call_args[0][1] is config.current_version\n", "    assert mock_update_config_file.call_args[0][2] == \"2.0.0\"\n\t    assert mock_update_config_file.call_args[0][3] is True\n\t@patch(\"bumpversion.files.modify_files\")\n\t@patch(\"bumpversion.bump.update_config_file\")\n\tdef test_do_bump_when_new_equals_current(mock_update_config_file, mock_modify_files, tmp_path: Path):\n\t    \"\"\"When the new version is the same as the current version, nothing should happen.\"\"\"\n\t    # Arrange\n\t    version_part = None\n\t    new_version = \"1.2.3\"\n\t    with inside_dir(tmp_path):\n", "        config, version_config, current_version = get_config_data({\"current_version\": \"1.2.3\"})\n\t        # Act\n\t        bump.do_bump(version_part, new_version, config)\n\t    # Assert\n\t    mock_modify_files.assert_not_called()\n\t    mock_update_config_file.assert_not_called()\n\tdef test_do_bump_with_no_arguments():\n\t    # Arrange\n\t    version_part = None\n\t    new_version = None\n", "    config, version_config, current_version = get_config_data({\"current_version\": \"1.2.3\"})\n\t    config.scm_info = SCMInfo()\n\t    dry_run = False\n\t    # Act/Assert\n\t    with pytest.raises(ConfigurationError):\n\t        bump.do_bump(version_part, new_version, config, dry_run=dry_run)\n\tdef test_commit_and_tag_with_no_tool():\n\t    config, version_config, current_version = get_config_data(\n\t        {\n\t            \"current_version\": \"1.2.3\",\n", "        }\n\t    )\n\t    config.scm_info = SCMInfo()\n\t    mock_context = MagicMock()\n\t    bump.commit_and_tag(config, None, [], mock_context, False)\n\tdef test_commit_and_tag_with_tool(mock_context):\n\t    config, version_config, current_version = get_config_data(\n\t        {\"current_version\": \"1.2.3\", \"files\": [{\"filename\": \"foo.txt\"}, {\"filename\": \"bar.txt\"}]}\n\t    )\n\t    config.scm_info = SCMInfo()\n", "    config.scm_info.tool = MagicMock(spec=Git)\n\t    configured_files = [ConfiguredFile(file_cfg, version_config) for file_cfg in config.files]\n\t    bump.commit_and_tag(config, None, configured_files, mock_context, False)\n\t    config.scm_info.tool.commit_to_scm.assert_called_once()\n\t    config.scm_info.tool.tag_in_scm.assert_called_once()\n\t    assert set(config.scm_info.tool.commit_to_scm.call_args[0][0]) == {\"foo.txt\", \"bar.txt\"}\n\tdef test_commit_and_tag_with_config_file(mock_context):\n\t    config, version_config, current_version = get_config_data(\n\t        {\"current_version\": \"1.2.3\", \"files\": [{\"filename\": \"foo.txt\"}, {\"filename\": \"bar.txt\"}]}\n\t    )\n", "    config.scm_info = SCMInfo()\n\t    config.scm_info.tool = MagicMock(spec=Git)\n\t    configured_files = [ConfiguredFile(file_cfg, version_config) for file_cfg in config.files]\n\t    bump.commit_and_tag(config, Path(\"pyproject.toml\"), configured_files, mock_context, False)\n\t    config.scm_info.tool.commit_to_scm.assert_called_once()\n\t    config.scm_info.tool.tag_in_scm.assert_called_once()\n\t    assert set(config.scm_info.tool.commit_to_scm.call_args[0][0]) == {\"foo.txt\", \"bar.txt\", \"pyproject.toml\"}\n"]}
{"filename": "tests/test_files.py", "chunked_list": ["\"\"\"File processing tests.\"\"\"\n\timport os\n\tfrom datetime import datetime, timezone\n\tfrom pathlib import Path\n\tfrom textwrap import dedent\n\timport pytest\n\tfrom pytest import param\n\tfrom bumpversion import exceptions, files\n\tfrom bumpversion.utils import get_context\n\tfrom bumpversion.exceptions import VersionNotFoundError\n", "from tests.conftest import get_config_data, inside_dir\n\t@pytest.mark.parametrize(\n\t    [\"glob_pattern\", \"file_list\"],\n\t    [\n\t        param(\"*.txt\", {Path(\"file1.txt\"), Path(\"file2.txt\")}, id=\"simple-glob\"),\n\t        param(\"**/*.txt\", {Path(\"file1.txt\"), Path(\"file2.txt\"), Path(\"directory/file3.txt\")}, id=\"recursive-glob\"),\n\t    ],\n\t)\n\tdef test_get_glob_files(glob_pattern: str, file_list: set, fixtures_path: Path):\n\t    \"\"\"Get glob files should return all the globbed files and nothing else.\"\"\"\n", "    overrides = {\n\t        \"current_version\": \"1.0.0\",\n\t        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)(\\.(?P<release>[a-z]+))?\",\n\t        \"serialize\": [\"{major}.{minor}.{release}\", \"{major}.{minor}\"],\n\t        \"files\": [\n\t            {\n\t                \"glob\": glob_pattern,\n\t            }\n\t        ],\n\t    }\n", "    conf, version_config, current_version = get_config_data(overrides)\n\t    with inside_dir(fixtures_path.joinpath(\"glob\")):\n\t        result = files.get_glob_files(conf.files[0], version_config)\n\t    assert len(result) == len(file_list)\n\t    for f in result:\n\t        assert Path(f.path) in file_list\n\tdef test_single_file_processed_twice(tmp_path: Path):\n\t    \"\"\"\n\t    Verify that a single file \"file2\" can be processed twice.\n\t    Use two file_ entries, both with a different suffix after\n", "    the underscore.\n\t    Employ different parse/serialize and search/replace configs\n\t    to verify correct interpretation.\n\t    \"\"\"\n\t    filepath = tmp_path.joinpath(\"file2\")\n\t    filepath.write_text(\"dots: 0.10.2\\ndashes: 0-10-2\")\n\t    overrides = {\n\t        \"current_version\": \"0.10.2\",\n\t        \"files\": [\n\t            {\n", "                \"filename\": str(filepath),\n\t                \"search\": \"dots: {current_version}\",\n\t                \"replace\": \"dots: {new_version}\",\n\t            },\n\t            {\n\t                \"filename\": str(filepath),\n\t                \"search\": \"dashes: {current_version}\",\n\t                \"replace\": \"dashes: {new_version}\",\n\t                \"parse\": r\"(?P<major>\\d+)-(?P<minor>\\d+)-(?P<patch>\\d+)\",\n\t                \"serialize\": [\"{major}-{minor}-{patch}\"],\n", "            },\n\t        ],\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    new_version = current_version.bump(\"patch\", version_config.order)\n\t    ctx = get_context(conf)\n\t    assert len(conf.files) == 2\n\t    for file_cfg in conf.files:\n\t        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n\t        cfg_file.replace_version(current_version, new_version, ctx)\n", "    assert filepath.read_text() == \"dots: 0.10.3\\ndashes: 0-10-3\"\n\tdef test_multi_file_configuration(tmp_path: Path):\n\t    full_vers_path = tmp_path / \"FULL_VERSION.txt\"\n\t    full_vers_path.write_text(\"1.0.3\")\n\t    maj_vers_path = tmp_path / \"MAJOR_VERSION.txt\"\n\t    maj_vers_path.write_text(\"1\")\n\t    readme_path = tmp_path / \"README.txt\"\n\t    readme_path.write_text(\"MyAwesomeSoftware(TM) v1.0\")\n\t    build_num_path = tmp_path / \"BUILD_NUMBER\"\n\t    build_num_path.write_text(\"1.0.3+joe+38943\")\n", "    overrides = {\n\t        \"current_version\": \"1.0.3+joe+38943\",\n\t        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)(?:\\+.*)?\",\n\t        \"serialize\": [\n\t            \"{major}.{minor}.{patch}+{$USER}+{$BUILD_NUMBER}\",\n\t            \"{major}.{minor}.{patch}\",\n\t        ],\n\t        \"files\": [\n\t            {\n\t                \"filename\": str(full_vers_path),\n", "            },\n\t            {\n\t                \"filename\": str(maj_vers_path),\n\t                \"parse\": r\"\\d+\",\n\t                \"serialize\": [\"{major}\"],\n\t            },\n\t            {\n\t                \"filename\": str(readme_path),\n\t                \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\",\n\t                \"serialize\": [\"{major}.{minor}\"],\n", "            },\n\t            {\n\t                \"filename\": str(build_num_path),\n\t                \"serialize\": [\"{major}.{minor}.{patch}+{$USER}+{$BUILD_NUMBER}\"],\n\t            },\n\t        ],\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    major_version = current_version.bump(\"major\", version_config.order)\n\t    os.environ[\"BUILD_NUMBER\"] = \"38944\"\n", "    os.environ[\"USER\"] = \"bob\"\n\t    ctx = get_context(conf)\n\t    del os.environ[\"BUILD_NUMBER\"]\n\t    del os.environ[\"USER\"]\n\t    for file_cfg in conf.files:\n\t        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n\t        cfg_file.replace_version(current_version, major_version, ctx)\n\t    assert full_vers_path.read_text() == \"2.0.0\"\n\t    assert maj_vers_path.read_text() == \"2\"\n\t    assert readme_path.read_text() == \"MyAwesomeSoftware(TM) v2.0\"\n", "    assert build_num_path.read_text() == \"2.0.0+bob+38944\"\n\t    os.environ[\"BUILD_NUMBER\"] = \"38945\"\n\t    os.environ[\"USER\"] = \"jane\"\n\t    conf.current_version = \"2.0.0+bob+38944\"\n\t    ctx = get_context(conf)\n\t    del os.environ[\"BUILD_NUMBER\"]\n\t    del os.environ[\"USER\"]\n\t    major_version = version_config.parse(conf.current_version)\n\t    major_patch_version = major_version.bump(\"patch\", version_config.order)\n\t    for file_cfg in conf.files:\n", "        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n\t        cfg_file.replace_version(major_version, major_patch_version, ctx)\n\t    assert full_vers_path.read_text() == \"2.0.1\"\n\t    assert maj_vers_path.read_text() == \"2\"\n\t    assert readme_path.read_text() == \"MyAwesomeSoftware(TM) v2.0\"\n\t    assert build_num_path.read_text() == \"2.0.1+jane+38945\"\n\tdef test_raises_correct_missing_version_string(tmp_path: Path):\n\t    full_vers_path = tmp_path / \"FULL_VERSION.txt\"\n\t    full_vers_path.write_text(\"3.1.0-rc+build.1031\")\n\t    assembly_path = tmp_path / \"AssemblyInfo.cs\"\n", "    assembly_path.write_text(\n\t        '[assembly: AssemblyFileVersion(\"3.1.0-rc+build.1031\")]\\n' '[assembly: AssemblyVersion(\"3.1.1031.0\")]'\n\t    )\n\t    csv_path = tmp_path / \"Version.csv\"\n\t    csv_path.write_text(\"1;3-1;0;rc;build.1031\")\n\t    overrides = {\n\t        \"current_version\": \"3.1.0-rc+build.1031\",\n\t        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)(-(?P<release>[0-9A-Za-z]+))?(\\+build\\.(?P<build>.[0-9A-Za-z]+))?\",\n\t        \"serialize\": [\"{major}.{minor}.{patch}-{release}+build.{build}\", \"{major}.{minor}.{patch}+build.{build}\"],\n\t        \"commit\": True,\n", "        \"message\": \"Bump version: {current_version} -> {new_version}\",\n\t        \"tag\": False,\n\t        \"tag_name\": \"{new_version}\",\n\t        \"tag_message\": \"Version {new_version}\",\n\t        \"allow_dirty\": True,\n\t        \"files\": [\n\t            {\n\t                \"filename\": str(full_vers_path),\n\t            },\n\t            {\n", "                \"filename\": str(assembly_path),\n\t                \"search\": '[assembly: AssemblyFileVersion(\"{current_version}\")]',\n\t                \"replace\": '[assembly: AssemblyFileVersion(\"{new_version}\")]',\n\t            },\n\t            {\n\t                \"filename\": str(assembly_path),\n\t                \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<build>\\d+)\\.(?P<patch>\\d+)\",\n\t                \"serialize\": [\"{major}.{minor}.{build}.{patch}\"],\n\t                \"search\": '[assembly: AssemblyVersion(\"{current_version}\")]',\n\t                \"replace\": '[assembly: AssemblyVersion(\"{new_version}\")]',\n", "            },\n\t            {\n\t                \"filename\": str(csv_path),\n\t                \"parse\": r\"(?P<major>\\d+);(?P<minor>\\d+);(?P<patch>\\d+);(?P<release>[0-9A-Za-z]+)?;(build\\.(?P<build>.[0-9A-Za-z]+))?\",\n\t                \"serialize\": [\n\t                    \"{major};{minor};{patch};{release};build.{build}\",\n\t                    \"{major};{minor};{patch};;build.{build}\",\n\t                ],\n\t                \"search\": \"1;{current_version}\",\n\t                \"replace\": \"1;{new_version}\",\n", "            },\n\t        ],\n\t        \"parts\": {\n\t            \"release\": {\"values\": [\"beta\", \"rc\", \"final\"], \"optional_value\": \"final\"},\n\t            \"build\": {\n\t                \"first_value\": 1000,\n\t                \"independent\": True,\n\t            },\n\t        },\n\t    }\n", "    conf, version_config, current_version = get_config_data(overrides)\n\t    major_version = current_version.bump(\"patch\", version_config.order)\n\t    ctx = get_context(conf)\n\t    configured_files = [files.ConfiguredFile(file_cfg, version_config) for file_cfg in conf.files]\n\t    with pytest.raises(VersionNotFoundError) as e:\n\t        files.modify_files(configured_files, current_version, major_version, ctx)\n\t        assert e.message.startswith(\"Did not find '1;3;1;0;rc;build.1031'\")\n\tdef test_search_replace_to_avoid_updating_unconcerned_lines(tmp_path: Path):\n\t    req_path = tmp_path / \"requirements.txt\"\n\t    req_path.write_text(\"Django>=1.5.6,<1.6\\nMyProject==1.5.6\")\n", "    changelog_path = tmp_path / \"CHANGELOG.md\"\n\t    changelog_path.write_text(\n\t        dedent(\n\t            \"\"\"\n\t    # https://keepachangelog.com/en/1.0.0/\n\t    ## [Unreleased]\n\t    ### Added\n\t    - Foobar\n\t    ## [0.0.1] - 2014-05-31\n\t    ### Added\n", "    - This CHANGELOG file to hopefully serve as an evolving example of a\n\t      standardized open source project CHANGELOG.\n\t    \"\"\"\n\t        )\n\t    )\n\t    overrides = {\n\t        \"current_version\": \"1.5.6\",\n\t        \"files\": [\n\t            {\n\t                \"filename\": str(req_path),\n", "                \"search\": \"MyProject=={current_version}\",\n\t                \"replace\": \"MyProject=={new_version}\",\n\t            },\n\t            {\n\t                \"filename\": str(changelog_path),\n\t                \"search\": \"## [Unreleased]\",\n\t                \"replace\": \"## [Unreleased]\\n\\n## [{new_version}] - {utcnow:%Y-%m-%d}\",\n\t            },\n\t        ],\n\t    }\n", "    conf, version_config, current_version = get_config_data(overrides)\n\t    new_version = current_version.bump(\"minor\", version_config.order)\n\t    for file_cfg in conf.files:\n\t        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n\t        cfg_file.replace_version(current_version, new_version, get_context(conf))\n\t    utc_today = datetime.now(timezone.utc).strftime(\"%Y-%m-%d\")\n\t    expected_chglog = dedent(\n\t        f\"\"\"\n\t    # https://keepachangelog.com/en/1.0.0/\n\t    ## [Unreleased]\n", "    ## [1.6.0] - {utc_today}\n\t    ### Added\n\t    - Foobar\n\t    ## [0.0.1] - 2014-05-31\n\t    ### Added\n\t    - This CHANGELOG file to hopefully serve as an evolving example of a\n\t      standardized open source project CHANGELOG.\n\t    \"\"\"\n\t    )\n\t    assert req_path.read_text() == \"Django>=1.5.6,<1.6\\nMyProject==1.6.0\"\n", "    assert changelog_path.read_text() == expected_chglog\n\tdef test_non_matching_search_does_not_modify_file(tmp_path: Path):\n\t    changelog_path = tmp_path / \"CHANGELOG.md\"\n\t    changelog_content = dedent(\n\t        \"\"\"\n\t    # Unreleased\n\t    * bullet point A\n\t    # Release v'older' (2019-09-17)\n\t    * bullet point B\n\t    \"\"\"\n", "    )\n\t    changelog_path.write_text(changelog_content)\n\t    overrides = {\n\t        \"current_version\": \"1.0.3\",\n\t        \"files\": [\n\t            {\n\t                \"filename\": str(changelog_path),\n\t                \"search\": \"Not-yet-released\",\n\t                \"replace\": \"Release v{new_version} ({now:%Y-%m-%d})\",\n\t            }\n", "        ],\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    new_version = current_version.bump(\"patch\", version_config.order)\n\t    configured_files = files.resolve_file_config(conf.files, version_config)\n\t    with pytest.raises(exceptions.VersionNotFoundError, match=\"Did not find 'Not-yet-released' in file:\"):\n\t        files.modify_files(configured_files, current_version, new_version, get_context(conf))\n\t    assert changelog_path.read_text() == changelog_content\n\tdef test_simple_replacement_in_utf8_file(tmp_path: Path):\n\t    \"\"\"Changing a file in UTF-8 should not change the non-ASCII characters.\"\"\"\n", "    # Arrange\n\t    version_path = tmp_path / \"VERSION\"\n\t    version_path.write_bytes(\"Kröt1.3.0\".encode(\"utf-8\"))\n\t    overrides = {\"current_version\": \"1.3.0\", \"files\": [{\"filename\": str(version_path)}]}\n\t    with inside_dir(tmp_path):\n\t        conf, version_config, current_version = get_config_data(overrides)\n\t        new_version = current_version.bump(\"patch\", version_config.order)\n\t    # Act\n\t    for file_cfg in conf.files:\n\t        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n", "        cfg_file.replace_version(current_version, new_version, get_context(conf))\n\t    # Assert\n\t    out = version_path.read_text()\n\t    assert out == \"Kröt1.3.1\"\n\tdef test_multi_line_search_is_found(tmp_path: Path) -> None:\n\t    \"\"\"A multiline search string is found and replaced.\"\"\"\n\t    # Arrange\n\t    alphabet_path = tmp_path / \"the_alphabet.txt\"\n\t    alphabet_path.write_text(\"A\\nB\\nC\\n\")\n\t    overrides = {\n", "        \"current_version\": \"9.8.7\",\n\t        \"search\": \"A\\nB\\nC\",\n\t        \"replace\": \"A\\nB\\nC\\n{new_version}\",\n\t        \"files\": [{\"filename\": str(alphabet_path)}],\n\t    }\n\t    with inside_dir(tmp_path):\n\t        conf, version_config, current_version = get_config_data(overrides)\n\t        new_version = current_version.bump(\"major\", version_config.order)\n\t    # Act\n\t    for file_cfg in conf.files:\n", "        cfg_file = files.ConfiguredFile(file_cfg, version_config)\n\t        cfg_file.replace_version(current_version, new_version, get_context(conf))\n\t    # Assert\n\t    assert alphabet_path.read_text() == \"A\\nB\\nC\\n10.0.0\\n\"\n\tdef test_ignore_missing_version(tmp_path: Path) -> None:\n\t    \"\"\"If the version is not found in the file, do nothing.\"\"\"\n\t    # Arrange\n\t    version_path = tmp_path / Path(\"VERSION\")\n\t    version_path.write_text(\"1.2.3\")\n\t    overrides = {\n", "        \"current_version\": \"1.2.5\",\n\t        \"ignore_missing_version\": True,\n\t        \"files\": [{\"filename\": str(version_path)}],\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    assert conf.ignore_missing_version is True\n\t    new_version = current_version.bump(\"patch\", version_config.order)\n\t    cfg_files = [files.ConfiguredFile(file_cfg, version_config) for file_cfg in conf.files]\n\t    # Act\n\t    files.modify_files(cfg_files, current_version, new_version, get_context(conf))\n", "    # Assert\n\t    assert version_path.read_text() == \"1.2.3\"\n"]}
{"filename": "tests/__init__.py", "chunked_list": ["\"\"\"Unit test package for bumpversion.\"\"\"\n"]}
{"filename": "tests/test_config.py", "chunked_list": ["\"\"\"Test configuration parsing.\"\"\"\n\timport difflib\n\timport json\n\tfrom pathlib import Path\n\tfrom textwrap import dedent\n\timport pytest\n\tfrom click.testing import CliRunner, Result\n\tfrom pytest import param\n\tfrom bumpversion import config\n\tfrom tests.conftest import inside_dir\n", "@pytest.fixture(params=[\".bumpversion.cfg\", \"setup.cfg\"])\n\tdef cfg_file(request) -> str:\n\t    \"\"\"Return both config-file styles ('.bumpversion.cfg', 'setup.cfg').\"\"\"\n\t    return request.param\n\t@pytest.fixture(\n\t    params=[\n\t        \"file\",\n\t        \"file(suffix)\",\n\t        \"file (suffix with space)\",\n\t        \"file (suffix lacking closing paren\",\n", "    ]\n\t)\n\tdef cfg_file_keyword(request):\n\t    \"\"\"Return multiple possible styles for the bumpversion:file keyword.\"\"\"\n\t    return request.param\n\t@pytest.mark.parametrize(\n\t    [\"conf_file\", \"expected_file\"],\n\t    [\n\t        param(\"basic_cfg.cfg\", \"basic_cfg_expected.json\", id=\"ini basic cfg\"),\n\t    ],\n", ")\n\tdef test_read_ini_file(conf_file: str, expected_file: str, fixtures_path: Path) -> None:\n\t    \"\"\"Parsing the config file should match the expected results.\"\"\"\n\t    result = config.read_ini_file(fixtures_path.joinpath(conf_file))\n\t    expected = json.loads(fixtures_path.joinpath(expected_file).read_text())\n\t    assert result == expected\n\t@pytest.mark.parametrize(\n\t    [\"conf_file\", \"expected_file\"],\n\t    [\n\t        param(\"basic_cfg.toml\", \"basic_cfg_expected.json\", id=\"toml basic cfg\"),\n", "    ],\n\t)\n\tdef test_read_toml_file(conf_file: str, expected_file: str, fixtures_path: Path) -> None:\n\t    \"\"\"Parsing the config file should match the expected results.\"\"\"\n\t    result = config.read_toml_file(fixtures_path.joinpath(conf_file))\n\t    expected = json.loads(fixtures_path.joinpath(expected_file).read_text())\n\t    assert result == expected\n\tdef test_independent_falsy_value_in_config_does_not_bump_independently(tmp_path: Path):\n\t    # tmp_path.joinpath(\"VERSION\").write_text(\"2.1.0-5123\")\n\t    config_file = tmp_path.joinpath(\".bumpversion.cfg\")\n", "    config_file.write_text(\n\t        dedent(\n\t            r\"\"\"\n\t        [bumpversion]\n\t        current_version: 2.1.0-5123\n\t        parse = (?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)\\-(?P<build>\\d+)\n\t        serialize = {major}.{minor}.{patch}-{build}\n\t        [bumpversion:file:VERSION]\n\t        [bumpversion:part:build]\n\t        independent = 0\n", "        \"\"\"\n\t        )\n\t    )\n\t    conf = config.get_configuration(config_file)\n\t    assert conf.parts[\"build\"].independent is False\n\tdef test_correct_interpolation_for_setup_cfg_files(tmp_path: Path, fixtures_path: Path):\n\t    \"\"\"\n\t    Reported here: https://github.com/c4urself/bump2version/issues/21.\n\t    \"\"\"\n\t    test_fixtures_path = fixtures_path.joinpath(\"interpolation\")\n", "    setup_cfg = config.get_configuration(test_fixtures_path.joinpath(\"setup.cfg\"))\n\t    bumpversion_cfg = config.get_configuration(test_fixtures_path.joinpath(\".bumpversion.cfg\"))\n\t    pyproject_toml = config.get_configuration(test_fixtures_path.joinpath(\"pyproject.toml\"))\n\t    assert setup_cfg.replace == \"{now:%m-%d-%Y} v. {new_version}\"\n\t    assert bumpversion_cfg.replace == \"{now:%m-%d-%Y} v. {new_version}\"\n\t    assert pyproject_toml.replace == \"{now:%m-%d-%Y} v. {new_version}\"\n\tdef test_file_keyword_with_suffix_is_accepted(tmp_path: Path, cfg_file: str, cfg_file_keyword: str):\n\t    cfg_file_path = tmp_path / cfg_file\n\t    cfg_file_path.write_text(\n\t        \"[bumpversion]\\n\"\n", "        \"current_version = 0.10.2\\n\"\n\t        \"new_version = 0.10.3\\n\"\n\t        \"[bumpversion:file (foobar):file2]\\n\"\n\t        \"search = version {current_version}\\n\"\n\t        \"replace = version {new_version}\\n\"\n\t        f\"[bumpversion:{cfg_file_keyword}:file2]\\n\"\n\t        \"search = The current version is {current_version}\\n\"\n\t        \"replace = The current version is {new_version}\\n\"\n\t    )\n\t    setup_cfg = config.get_configuration(cfg_file_path)\n", "    assert len(setup_cfg.files) == 2\n\t    assert all(f.filename == \"file2\" for f in setup_cfg.files)\n\tdef test_multiple_config_files(tmp_path: Path):\n\t    \"\"\"If there are multiple config files, the first one with content wins.\"\"\"\n\t    setup_cfg = tmp_path / \"setup.cfg\"\n\t    setup_cfg.write_text(\"[metadata]\\nname: just-a-name\\n\")\n\t    bumpversion_cfg = tmp_path / \".bumpversion.cfg\"\n\t    bumpversion_cfg.write_text(\"\\n\")\n\t    pyproject_toml = tmp_path / \"pyproject.toml\"\n\t    pyproject_toml.write_text(\n", "        \"[tool.bumpversion]\\n\"\n\t        'current_version = \"0.10.5\"\\n'\n\t        'parse = \"(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?\"\\n'\n\t        \"serialize = [\\n\"\n\t        '    \"{major}.{minor}.{patch}-{release}\",\\n'\n\t        '    \"{major}.{minor}.{patch}\"\\n'\n\t        \"]\\n\"\n\t    )\n\t    with inside_dir(tmp_path):\n\t        cfg_file = config.find_config_file()\n", "        cfg = config.get_configuration(cfg_file)\n\t    assert cfg.current_version == \"0.10.5\"\n\t    assert cfg.parse == \"(?P<major>\\\\d+)\\\\.(?P<minor>\\\\d+)\\\\.(?P<patch>\\\\d+)(\\\\-(?P<release>[a-z]+))?\"\n\t    assert cfg.serialize == [\"{major}.{minor}.{patch}-{release}\", \"{major}.{minor}.{patch}\"]\n\tdef test_utf8_message_from_config_file(tmp_path: Path, cfg_file):\n\t    cfg_path = tmp_path / cfg_file\n\t    initial_config = (\n\t        \"[bumpversion]\\n\"\n\t        \"current_version = 500.0.0\\n\"\n\t        \"commit = True\\n\"\n", "        \"message = Nová verze: {current_version} ☃, {new_version} ☀\\n\"\n\t    )\n\t    cfg_path.write_bytes(initial_config.encode(\"utf-8\"))\n\t    with inside_dir(tmp_path):\n\t        cfg = config.get_configuration(cfg_path)\n\t    assert cfg.message == \"Nová verze: {current_version} ☃, {new_version} ☀\"\n\tCFG_EXPECTED_DIFF = (\n\t    \"*** \\n\"\n\t    \"--- \\n\"\n\t    \"***************\\n\"\n", "    \"*** 11 ****\\n\"\n\t    \"! current_version = 1.0.0\\n\"\n\t    \"--- 11 ----\\n\"\n\t    \"! current_version = 1.0.1\\n\"\n\t)\n\tTOML_EXPECTED_DIFF = (\n\t    \"*** \\n\"\n\t    \"--- \\n\"\n\t    \"***************\\n\"\n\t    \"*** 23 ****\\n\"\n", "    '! current_version = \"1.0.0\"\\n'\n\t    \"--- 23 ----\\n\"\n\t    '! current_version = \"1.0.1\"\\n'\n\t)\n\t@pytest.mark.parametrize(\n\t    [\"cfg_file_name\", \"expected_diff\"],\n\t    [\n\t        (\".bumpversion.cfg\", CFG_EXPECTED_DIFF),\n\t        (\"setup.cfg\", CFG_EXPECTED_DIFF),\n\t        (\"pyproject.toml\", TOML_EXPECTED_DIFF),\n", "    ],\n\t)\n\tdef test_update_config_file(tmp_path: Path, cfg_file_name: str, expected_diff: str, fixtures_path: Path) -> None:\n\t    \"\"\"\n\t    Make sure only the version string is updated in the config file.\n\t    \"\"\"\n\t    cfg_path = tmp_path / cfg_file_name\n\t    orig_path = fixtures_path / f\"basic_cfg{cfg_path.suffix}\"\n\t    cfg_path.write_text(orig_path.read_text())\n\t    original_content = orig_path.read_text().splitlines(keepends=True)\n", "    config.update_config_file(cfg_path, \"1.0.0\", \"1.0.1\")\n\t    new_content = cfg_path.read_text().splitlines(keepends=True)\n\t    difference = difflib.context_diff(original_content, new_content, n=0)\n\t    assert \"\".join(difference) == expected_diff\n\tdef test_pep440_config(git_repo: Path, fixtures_path: Path):\n\t    \"\"\"\n\t    Check the PEP440 config file.\n\t    \"\"\"\n\t    from bumpversion.utils import get_context\n\t    from bumpversion.bump import get_next_version\n", "    from bumpversion import cli\n\t    import subprocess\n\t    # Arrange\n\t    cfg_path = git_repo / \"pyproject.toml\"\n\t    orig_path = fixtures_path / \"pep440.toml\"\n\t    cfg_path.write_text(orig_path.read_text())\n\t    version_path = git_repo / \"VERSION\"\n\t    version_path.write_text(\"1.0.0\")\n\t    readme_path = git_repo / \"README.md\"\n\t    runner: CliRunner = CliRunner()\n", "    with inside_dir(git_repo):\n\t        subprocess.run([\"git\", \"add\", \"VERSION\"], check=True, capture_output=True)\n\t        subprocess.run([\"git\", \"commit\", \"-m\", \"initial commit\"], check=True, capture_output=True)\n\t        subprocess.run([\"git\", \"tag\", \"v1.0.0\"], check=True, capture_output=True)\n\t        cfg = config.get_configuration(cfg_path)\n\t        ctx = get_context(cfg)\n\t        version = cfg.version_config.parse(cfg.current_version)\n\t        next_version = get_next_version(version, cfg, \"patch\", None)\n\t        next_version_str = cfg.version_config.serialize(next_version, ctx)\n\t        assert next_version_str == \"1.0.1\"\n", "        subprocess.run([\"git\", \"checkout\", \"-b\", \"my-really-LONG-branch_name\"], check=True, capture_output=True)\n\t        readme_path.write_text(\"This is my branch!\")\n\t        result: Result = runner.invoke(cli.cli, [\"bump\", \"dev_label\", \"--no-tag\"])\n\t        assert result.exit_code == 0\n\t        cfg = config.get_configuration(cfg_path)\n\t        assert cfg.current_version == \"1.0.0.dev0+myreallylongbranchna\"\n\t        # try:\n\t        #     subprocess.run([\"git\", \"add\", \"README.md\"], check=True, capture_output=True)\n\t        #     subprocess.run([\"git\", \"commit\", \"-am\", \"my branch commit\"], check=True, capture_output=True)\n\t        # except subprocess.CalledProcessError as e:\n", "        #     print(e.stdout)\n\t        #     print(e.stderr)\n\t        #     raise\n\t        # result: Result = runner.invoke(cli.cli, [\"bump\", \"dev_label\", \"--no-tag\"])\n\t        # assert result.exit_code == 0\n\t        # cfg = config.get_configuration(cfg_path)\n\t        # assert cfg.current_version == \"1.0.0.dev1+myreallylongbranchna\"\n"]}
{"filename": "tests/test_version_part.py", "chunked_list": ["from pathlib import Path\n\timport pytest\n\tfrom click import UsageError\n\tfrom pytest import LogCaptureFixture, param\n\tfrom bumpversion import config, exceptions\n\tfrom bumpversion.utils import get_context\n\tfrom bumpversion.version_part import VersionPart\n\tfrom tests.conftest import get_config_data, inside_dir\n\t@pytest.fixture(\n\t    params=[\n", "        None,\n\t        (\"0\", \"1\", \"2\"),\n\t        (\"0\", \"3\"),\n\t    ]\n\t)\n\tdef version_part_config(request):\n\t    \"\"\"Return a three-part and a two-part version part configuration.\"\"\"\n\t    if request.param is None:\n\t        return config.VersionPartConfig()\n\t    else:\n", "        return config.VersionPartConfig(values=request.param)\n\tdef test_version_part_init(version_part_config):\n\t    vp = VersionPart(version_part_config, version_part_config.first_value)\n\t    assert vp.value is not None\n\tdef test_version_part_copy(version_part_config):\n\t    vp = VersionPart(version_part_config, version_part_config.first_value)\n\t    vc = vp.copy()\n\t    assert vp.value == vc.value\n\t    assert id(vp) != id(vc)\n\tdef test_version_part_bump(version_part_config):\n", "    vp = VersionPart(version_part_config, version_part_config.first_value)\n\t    vc = vp.bump()\n\t    if version_part_config.values:\n\t        assert vc.value == str(version_part_config.values[1])\n\t    else:\n\t        assert vc.value == \"1\"\n\tdef test_version_part_check_optional_false(version_part_config):\n\t    assert not VersionPart(version_part_config, version_part_config.first_value).bump().is_optional\n\tdef test_version_part_check_optional_true(version_part_config):\n\t    assert VersionPart(version_part_config, version_part_config.first_value).is_optional\n", "def test_version_part_equality(version_part_config):\n\t    assert VersionPart(version_part_config, version_part_config.first_value) == VersionPart(\n\t        version_part_config, version_part_config.first_value\n\t    )\n\tdef test_version_part_null(version_part_config):\n\t    assert VersionPart(version_part_config, version_part_config.first_value).null() == VersionPart(\n\t        version_part_config, version_part_config.first_value\n\t    )\n\tdef test_bump_version_missing_part():\n\t    overrides = {\n", "        \"current_version\": \"1.0.0\",\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    with pytest.raises(exceptions.InvalidVersionPartError, match=\"No part named 'bugfix'\"):\n\t        current_version.bump(\"bugfix\", version_config.order)\n\tdef test_build_number_configuration():\n\t    overrides = {\n\t        \"current_version\": \"2.1.6-5123\",\n\t        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)\\-(?P<build>\\d+)\",\n\t        \"serialize\": [\"{major}.{minor}.{patch}-{build}\"],\n", "        \"parts\": {\n\t            \"build\": {\n\t                \"independent\": True,\n\t            }\n\t        },\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    build_version_bump = current_version.bump(\"build\", version_config.order)\n\t    assert build_version_bump.values[\"build\"].value == \"5124\"\n\t    assert build_version_bump.values[\"build\"].is_independent\n", "    major_version_bump = build_version_bump.bump(\"major\", version_config.order)\n\t    assert major_version_bump.values[\"build\"].value == \"5124\"\n\t    assert build_version_bump.values[\"build\"].is_independent\n\t    assert major_version_bump.values[\"major\"].value == \"3\"\n\t    build_version_bump = major_version_bump.bump(\"build\", version_config.order)\n\t    assert build_version_bump.values[\"build\"].value == \"5125\"\n\t    assert build_version_bump.values[\"build\"].is_independent\n\tdef test_serialize_with_distance_to_latest_tag():\n\t    \"\"\"Using ``distance_to_latest_tag`` in the serialization string outputs correctly.\"\"\"\n\t    from bumpversion.scm import Git, SCMInfo\n", "    overrides = {\n\t        \"current_version\": \"19.6.0\",\n\t        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+).*\",\n\t        \"serialize\": [\"{major}.{minor}.{patch}-pre{distance_to_latest_tag}\"],\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    conf.scm_info = SCMInfo(\n\t        tool=Git, commit_sha=\"1234123412341234\", distance_to_latest_tag=3, current_version=\"19.6.0\", dirty=False\n\t    )\n\t    assert version_config.serialize(current_version, get_context(conf)) == \"19.6.0-pre3\"\n", "def test_serialize_with_environment_var():\n\t    import os\n\t    os.environ[\"BUILD_NUMBER\"] = \"567\"\n\t    overrides = {\n\t        \"current_version\": \"2.3.4\",\n\t        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+).*\",\n\t        \"serialize\": [\"{major}.{minor}.{patch}-pre{$BUILD_NUMBER}\"],\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    assert version_config.serialize(current_version, get_context(conf)) == \"2.3.4-pre567\"\n", "    del os.environ[\"BUILD_NUMBER\"]\n\tdef test_serialize_with_newlines():\n\t    overrides = {\n\t        \"current_version\": \"MAJOR=31\\nMINOR=0\\nPATCH=3\\n\",\n\t        \"parse\": r\"MAJOR=(?P<major>\\d+)\\nMINOR=(?P<minor>\\d+)\\nPATCH=(?P<patch>\\d+)\\n\",\n\t        \"serialize\": [\"MAJOR={major}\\nMINOR={minor}\\nPATCH={patch}\\n\"],\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    new_version = current_version.bump(\"major\", version_config.order)\n\t    assert version_config.serialize(new_version, get_context(conf)) == \"MAJOR=32\\nMINOR=0\\nPATCH=0\\n\"\n", "@pytest.mark.parametrize(\n\t    [\"bump_type\", \"expected\"],\n\t    [\n\t        param(\"patch\", \"0.9.1\", id=\"patch\"),\n\t        param(\"minor\", \"0.10\", id=\"minor\"),\n\t        param(\"major\", \"1\", id=\"major\"),\n\t    ],\n\t)\n\tdef test_serialize_three_part(bump_type: str, expected: str):\n\t    overrides = {\n", "        \"current_version\": \"0.9\",\n\t        \"parse\": r\"(?P<major>\\d+)(\\.(?P<minor>\\d+)(\\.(?P<patch>\\d+))?)?\",\n\t        \"serialize\": [\"{major}.{minor}.{patch}\", \"{major}.{minor}\", \"{major}\"],\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    new_version = current_version.bump(bump_type, version_config.order)\n\t    assert version_config.serialize(new_version, get_context(conf)) == expected\n\t@pytest.mark.parametrize(\n\t    [\"initial\", \"bump_type\", \"expected\"],\n\t    [\n", "        param(\"1.5.dev\", \"release\", \"1.5\", id=\"release\"),\n\t        param(\"1.5\", \"minor\", \"1.6.dev\", id=\"minor\"),\n\t    ],\n\t)\n\tdef test_bump_non_numeric_parts(initial: str, bump_type: str, expected: str):\n\t    overrides = {\n\t        \"current_version\": initial,\n\t        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)(\\.(?P<release>[a-z]+))?\",\n\t        \"serialize\": [\"{major}.{minor}.{release}\", \"{major}.{minor}\"],\n\t        \"parts\": {\n", "            \"release\": {\n\t                \"optional_value\": \"gamma\",\n\t                \"values\": [\"dev\", \"gamma\"],\n\t            },\n\t        },\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    new_version = current_version.bump(bump_type, version_config.order)\n\t    assert version_config.serialize(new_version, get_context(conf)) == expected\n\t@pytest.mark.parametrize(\n", "    [\"initial\", \"bump_type\", \"expected\"],\n\t    [\n\t        param(\"1.alpha\", \"release\", \"1.beta\", id=\"alpha-to-beta-release\"),\n\t        param(\"1.beta\", \"release\", \"1\", id=\"beta-to-release\"),\n\t    ],\n\t)\n\tdef test_optional_value(initial: str, bump_type: str, expected: str):\n\t    overrides = {\n\t        \"current_version\": initial,\n\t        \"parse\": r\"(?P<num>\\d+)(\\.(?P<release>.*))?(\\.)?\",\n", "        \"serialize\": [\"{num}.{release}\", \"{num}\"],\n\t        \"parts\": {\n\t            \"release\": {\n\t                \"optional_value\": \"gamma\",\n\t                \"values\": [\"alpha\", \"beta\", \"gamma\"],\n\t            },\n\t        },\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    new_version = current_version.bump(bump_type, version_config.order)\n", "    assert version_config.serialize(new_version, get_context(conf)) == expected\n\t@pytest.mark.parametrize(\n\t    [\"initial\", \"bump_type\", \"expected\"],\n\t    [\n\t        param(\"1.0a\", \"prerel\", \"1.0b\", id=\"a-to-b-release\"),\n\t        param(\"1.0b\", \"prerelversion\", \"1.0b1\", id=\"prerelease-version\"),\n\t        param(\"1.0b1\", \"prerelversion\", \"1.0b2\", id=\"prerelease-version2\"),\n\t        param(\"1.0b2\", \"prerel\", \"1.0c\", id=\"b2-to-c-release\"),\n\t        param(\"1.0c\", \"prerel\", \"1.0rc\", id=\"c-to-rc-release\"),\n\t        param(\"1.0rc\", \"prerel\", \"1.0\", id=\"rc-to-d-release\"),\n", "        param(\"1.0\", \"minor\", \"1.1dev\", id=\"minor-release\"),\n\t        param(\"1.1dev\", \"prerel\", \"1.1a\", id=\"dev-to-a-release\"),\n\t    ],\n\t)\n\tdef test_python_pre_release_release_post_release(initial: str, bump_type: str, expected: str):\n\t    # adapted from http://legacy.python.org/dev/peps/pep-0386/#the-new-versioning-algorithm\n\t    overrides = {\n\t        \"current_version\": initial,\n\t        \"parse\": r\"\"\"^\n\t            (?P<major>\\d+)\\.(?P<minor>\\d+)   # minimum 'N.N'\n", "            (?:\n\t                (?P<prerel>[abc]|rc|dev)     # 'a' = alpha, 'b' = beta\n\t                                             # 'c' or 'rc' = release candidate\n\t                (?:\n\t                    (?P<prerelversion>\\d+(?:\\.\\d+)*)\n\t                )?\n\t            )?\n\t            (?P<postdev>(\\.post(?P<post>\\d+))?(\\.dev(?P<dev>\\d+))?)?\"\"\",\n\t        \"serialize\": [\n\t            \"{major}.{minor}{prerel}{prerelversion}\",\n", "            \"{major}.{minor}{prerel}\",\n\t            \"{major}.{minor}\",\n\t        ],\n\t        \"parts\": {\n\t            \"prerel\": {\n\t                \"optional_value\": \"d\",\n\t                \"values\": [\"dev\", \"a\", \"b\", \"c\", \"rc\", \"d\"],\n\t            },\n\t        },\n\t    }\n", "    conf, version_config, current_version = get_config_data(overrides)\n\t    new_version = current_version.bump(bump_type, version_config.order)\n\t    assert version_config.serialize(new_version, get_context(conf)) == expected\n\t@pytest.mark.parametrize(\n\t    [\"initial\", \"bump_type\", \"expected\"],\n\t    [\n\t        param(\"0.9.4\", \"major\", \"1.1.0\", id=\"first-value-1\"),\n\t    ],\n\t)\n\tdef test_part_first_value(initial: str, bump_type: str, expected: str):\n", "    overrides = {\n\t        \"current_version\": initial,\n\t        \"parts\": {\n\t            \"minor\": {\n\t                \"first_value\": \"1\",\n\t            },\n\t        },\n\t    }\n\t    conf, version_config, current_version = get_config_data(overrides)\n\t    new_version = current_version.bump(bump_type, version_config.order)\n", "    assert version_config.serialize(new_version, get_context(conf)) == expected\n\tdef test_version_part_invalid_regex_exit(tmp_path: Path) -> None:\n\t    \"\"\"A version part with an invalid regex should raise an exception.\"\"\"\n\t    # Arrange\n\t    overrides = {\n\t        \"current_version\": \"12\",\n\t        \"parse\": \"*kittens*\",\n\t    }\n\t    with inside_dir(tmp_path):\n\t        with pytest.raises(UsageError):\n", "            get_config_data(overrides)\n\tdef test_parse_doesnt_parse_current_version(tmp_path: Path, caplog: LogCaptureFixture) -> None:\n\t    \"\"\"A warning should be output when the parse regex doesn't parse the version.\"\"\"\n\t    overrides = {\"current_version\": \"12\", \"parse\": \"xxx\"}\n\t    with inside_dir(tmp_path):\n\t        get_config_data(overrides)\n\t    assert \"Evaluating 'parse' option: 'xxx' does not parse current version '12'\" in caplog.messages\n\tdef test_part_does_not_revert_to_zero_if_optional(tmp_path: Path) -> None:\n\t    \"\"\"A non-numeric part with the optional value should not revert to zero.\"\"\"\n\t    # From https://github.com/c4urself/bump2version/issues/248\n", "    # Arrange\n\t    overrides = {\n\t        \"current_version\": \"0.3.1\",\n\t        \"parse\": r\"(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)((?P<release>\\D+)(?P<build>\\d*))?\",\n\t        \"serialize\": [\n\t            \"{major}.{minor}.{patch}{release}{build}\",\n\t            \"{major}.{minor}.{patch}{release}\",\n\t            \"{major}.{minor}.{patch}\",\n\t        ],\n\t        \"parts\": {\n", "            \"release\": {\n\t                \"optional_value\": \"g\",\n\t                \"first_value\": \"g\",\n\t                \"values\": [\n\t                    \"dev\",\n\t                    \"a\",\n\t                    \"b\",\n\t                    \"g\",\n\t                ],\n\t            },\n", "        },\n\t    }\n\t    with inside_dir(tmp_path):\n\t        conf, version_config, current_version = get_config_data(overrides)\n\t    new_version = current_version.bump(\"build\", version_config.order)\n\t    assert version_config.serialize(new_version, get_context(conf)) == \"0.3.1g1\"\n"]}
{"filename": "tests/test_cli.py", "chunked_list": ["\"\"\"Tests for `bumpversion` package.\"\"\"\n\timport shutil\n\timport subprocess\n\timport traceback\n\tfrom pathlib import Path\n\timport pytest\n\tfrom click.testing import CliRunner, Result\n\tfrom pytest import param\n\tfrom bumpversion import __version__, cli\n\tfrom tests.conftest import inside_dir\n", "def test_version_displays_library_version():\n\t    \"\"\"\n\t    Arrange/Act: Run the `version` subcommand.\n\t    Assert: The output matches the library version.\n\t    \"\"\"\n\t    runner: CliRunner = CliRunner()\n\t    result: Result = runner.invoke(cli.cli, [\"--version\"])\n\t    assert __version__ in result.output.strip(), \"Version number should match library version.\"\n\tdef test_bump_no_configured_files(mocker, tmp_path):\n\t    \"\"\"\n", "    Arrange/Act: Run the `bump` subcommand with --no-configured-files.\n\t    Assert: There is no configured files specified to modify\n\t    \"\"\"\n\t    mocked_do_bump = mocker.patch(\"bumpversion.cli.do_bump\")\n\t    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n\t        result: Result = runner.invoke(\n\t            cli.cli, [\"bump\", \"--current-version\", \"1.0.0\", \"--no-configured-files\", \"patch\"]\n\t        )\n\t    if result.exit_code != 0:\n", "        print(result.output)\n\t    assert result.exit_code == 0\n\t    call_args = mocked_do_bump.call_args[0]\n\t    assert len(call_args[2].files) == 0\n\tdef test_bump_legacy(mocker, tmp_path):\n\t    \"\"\"\n\t    Arrange/Act: Run the `bump` subcommand with --no-configured-files.\n\t    Assert: There is no configured files specified to modify\n\t    \"\"\"\n\t    mocked_do_bump = mocker.patch(\"bumpversion.cli.do_bump\")\n", "    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n\t        result: Result = runner.invoke(cli.cli, [\"--current-version\", \"1.0.0\", \"--no-configured-files\", \"patch\"])\n\t    if result.exit_code != 0:\n\t        print(result.output)\n\t    assert result.exit_code == 0\n\t    call_args = mocked_do_bump.call_args[0]\n\t    assert len(call_args[2].files) == 0\n\tdef test_no_configured_files_still_file_args_work(mocker, tmp_path):\n\t    mocked_do_bump = mocker.patch(\"bumpversion.cli.do_bump\")\n", "    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n\t        result: Result = runner.invoke(\n\t            cli.cli, [\"bump\", \"--current-version\", \"1.0.0\", \"--no-configured-files\", \"patch\", \"do-this-file.txt\"]\n\t        )\n\t    if result.exit_code != 0:\n\t        print(result.output)\n\t    assert result.exit_code == 0\n\t    call_args = mocked_do_bump.call_args[0]\n\t    assert len(call_args[2].files) == 1\n", "    assert call_args[2].files[0].filename == \"do-this-file.txt\"\n\tdef test_missing_explicit_config_file(tmp_path: Path):\n\t    \"\"\"The command-line processor should raise an exception if the config file is missing.\"\"\"\n\t    with inside_dir(tmp_path):\n\t        runner: CliRunner = CliRunner()\n\t        with inside_dir(tmp_path):\n\t            result: Result = runner.invoke(cli.cli, [\"bump\", \"--config-file\", \"missing-file.cfg\"])\n\t        assert result.exit_code != 0\n\t        assert \"'missing-file.cfg' does not exist.\" in result.output\n\tdef test_cli_options_override_config(tmp_path: Path, fixtures_path: Path, mocker):\n", "    \"\"\"The command-line processor should override the config file.\"\"\"\n\t    # Arrange\n\t    config_path = tmp_path / \"this_config.toml\"\n\t    fixture_toml = fixtures_path / \"basic_cfg.toml\"\n\t    shutil.copy(fixture_toml, config_path)\n\t    runner: CliRunner = CliRunner()\n\t    mocked_do_bump = mocker.patch(\"bumpversion.cli.do_bump\")\n\t    # Act\n\t    with inside_dir(tmp_path):\n\t        result: Result = runner.invoke(\n", "            cli.cli,\n\t            [\n\t                \"bump\",\n\t                \"--config-file\",\n\t                str(config_path),\n\t                \"--current-version\",\n\t                \"1.1.0\",\n\t                \"--new-version\",\n\t                \"1.2.0\",\n\t                \"--allow-dirty\",\n", "                \"--parse\",\n\t                r\"XXX(?P<spam>\\d+);(?P<blob>\\d+);(?P<slurp>\\d+)\",\n\t                \"--serialize\",\n\t                \"XXX{spam};{blob};{slurp}\",\n\t                \"--search\",\n\t                \"my-search\",\n\t                \"--replace\",\n\t                \"my-replace\",\n\t                \"--no-commit\",\n\t                \"--no-tag\",\n", "                \"slurp\",\n\t                \"do-this-file.txt\",\n\t            ],\n\t        )\n\t    # Assert\n\t    assert result.exit_code == 0\n\t    assert mocked_do_bump.call_count == 1\n\t    assert mocked_do_bump.call_args[0][0] == \"slurp\"\n\t    assert mocked_do_bump.call_args[0][1] == \"1.2.0\"\n\t    the_config = mocked_do_bump.call_args[0][2]\n", "    assert the_config.current_version == \"1.1.0\"\n\t    assert the_config.allow_dirty\n\t    assert the_config.parse == r\"XXX(?P<spam>\\d+);(?P<blob>\\d+);(?P<slurp>\\d+)\"\n\t    assert the_config.serialize == [\"XXX{spam};{blob};{slurp}\"]\n\t    assert the_config.search == \"my-search\"\n\t    assert the_config.replace == \"my-replace\"\n\t    assert the_config.commit is False\n\t    assert the_config.tag is False\n\t    assert len(the_config.files) == 4\n\t    assert {f.filename for f in the_config.files} == {\n", "        \"setup.py\",\n\t        \"bumpversion/__init__.py\",\n\t        \"CHANGELOG.md\",\n\t        \"do-this-file.txt\",\n\t    }\n\t    assert mocked_do_bump.call_args[0][3] == config_path\n\t@pytest.mark.parametrize(\n\t    [\"repo\", \"scm_command\"],\n\t    [\n\t        param(\"git_repo\", \"git\", id=\"git\"),\n", "        param(\"hg_repo\", \"hg\", id=\"hg\"),\n\t    ],\n\t)\n\tdef test_dirty_work_dir_raises_error(repo: str, scm_command: str, request):\n\t    repo_path: Path = request.getfixturevalue(repo)\n\t    with inside_dir(repo_path):\n\t        # Arrange\n\t        repo_path.joinpath(\"dirty2\").write_text(\"i'm dirty! 1.1.1\")\n\t        subprocess.run([scm_command, \"add\", \"dirty2\"], check=True)\n\t        runner: CliRunner = CliRunner()\n", "        # Act\n\t        result: Result = runner.invoke(\n\t            cli.cli, [\"bump\", \"patch\", \"--current-version\", \"1.1.1\", \"--no-allow-dirty\", \"dirty2\"]\n\t        )\n\t    # Assert\n\t    assert result.exit_code != 0\n\t    assert \"working directory is not clean\" in result.output\n\tdef test_listing_with_version_part(tmp_path: Path, fixtures_path: Path):\n\t    \"\"\"The --list option should list the configuration with new_version..\"\"\"\n\t    # Arrange\n", "    config_path = tmp_path / \"pyproject.toml\"\n\t    toml_path = fixtures_path / \"basic_cfg.toml\"\n\t    shutil.copy(toml_path, config_path)\n\t    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n\t        result: Result = runner.invoke(cli.cli, [\"bump\", \"--list\", \"patch\"])\n\t    if result.exit_code != 0:\n\t        print(result.output)\n\t        print(result.exception)\n\t    assert result.exit_code == 0\n", "    assert set(result.output.splitlines(keepends=False)) == {\n\t        \"WARNING:\",\n\t        \"\",\n\t        \"DEPRECATED: The --list option is deprecated and will be removed in a future version.\",\n\t        \"new_version=1.0.1-dev\",\n\t        \"current_version=1.0.0\",\n\t        \"parse=(?P<major>\\\\d+)\\\\.(?P<minor>\\\\d+)\\\\.(?P<patch>\\\\d+)(\\\\-(?P<release>[a-z]+))?\",\n\t        \"serialize=['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}']\",\n\t        \"search={current_version}\",\n\t        \"replace={new_version}\",\n", "        \"ignore_missing_version=False\",\n\t        \"tag=True\",\n\t        \"sign_tags=False\",\n\t        \"tag_name=v{new_version}\",\n\t        \"tag_message=Bump version: {current_version} → {new_version}\",\n\t        \"allow_dirty=False\",\n\t        \"commit=True\",\n\t        \"message=Bump version: {current_version} → {new_version}\",\n\t        \"commit_args=None\",\n\t        (\n", "            \"files=[\"\n\t            \"{'filename': 'setup.py', 'glob': None, 'parse': \"\n\t            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n\t            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '{current_version}', \"\n\t            \"'replace': '{new_version}', 'ignore_missing_version': False}, \"\n\t            \"{'filename': 'bumpversion/__init__.py', 'glob': None, 'parse': \"\n\t            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n\t            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '{current_version}', \"\n\t            \"'replace': '{new_version}', 'ignore_missing_version': False}, \"\n\t            \"{'filename': 'CHANGELOG.md', 'glob': None, 'parse': \"\n", "            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n\t            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '**unreleased**', \"\n\t            \"'replace': '**unreleased**\\\\n**v{new_version}**', 'ignore_missing_version': False}]\"\n\t        ),\n\t    }\n\tdef test_listing_without_version_part(tmp_path: Path, fixtures_path: Path):\n\t    \"\"\"The --list option should list the configuration without new_version.\"\"\"\n\t    # Arrange\n\t    config_path = tmp_path / \"pyproject.toml\"\n\t    toml_path = fixtures_path / \"basic_cfg.toml\"\n", "    shutil.copy(toml_path, config_path)\n\t    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n\t        result: Result = runner.invoke(cli.cli, [\"bump\", \"--list\"])\n\t    if result.exit_code != 0:\n\t        print(result.output)\n\t        print(result.exception)\n\t    assert result.exit_code == 0\n\t    assert set(result.output.splitlines(keepends=False)) == {\n\t        \"WARNING:\",\n", "        \"\",\n\t        \"DEPRECATED: The --list option is deprecated and will be removed in a future version.\",\n\t        \"current_version=1.0.0\",\n\t        \"parse=(?P<major>\\\\d+)\\\\.(?P<minor>\\\\d+)\\\\.(?P<patch>\\\\d+)(\\\\-(?P<release>[a-z]+))?\",\n\t        \"serialize=['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}']\",\n\t        \"search={current_version}\",\n\t        \"replace={new_version}\",\n\t        \"ignore_missing_version=False\",\n\t        \"tag=True\",\n\t        \"sign_tags=False\",\n", "        \"tag_name=v{new_version}\",\n\t        \"tag_message=Bump version: {current_version} → {new_version}\",\n\t        \"allow_dirty=False\",\n\t        \"commit=True\",\n\t        \"message=Bump version: {current_version} → {new_version}\",\n\t        \"commit_args=None\",\n\t        (\n\t            \"files=[\"\n\t            \"{'filename': 'setup.py', 'glob': None, 'parse': \"\n\t            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n", "            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '{current_version}', \"\n\t            \"'replace': '{new_version}', 'ignore_missing_version': False}, \"\n\t            \"{'filename': 'bumpversion/__init__.py', 'glob': None, 'parse': \"\n\t            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n\t            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '{current_version}', \"\n\t            \"'replace': '{new_version}', 'ignore_missing_version': False}, \"\n\t            \"{'filename': 'CHANGELOG.md', 'glob': None, 'parse': \"\n\t            \"'(?P<major>\\\\\\\\d+)\\\\\\\\.(?P<minor>\\\\\\\\d+)\\\\\\\\.(?P<patch>\\\\\\\\d+)(\\\\\\\\-(?P<release>[a-z]+))?', 'serialize': \"\n\t            \"['{major}.{minor}.{patch}-{release}', '{major}.{minor}.{patch}'], 'search': '**unreleased**', \"\n\t            \"'replace': '**unreleased**\\\\n**v{new_version}**', 'ignore_missing_version': False}]\"\n", "        ),\n\t    }\n\tdef test_non_scm_operations_if_scm_not_installed(tmp_path: Path, monkeypatch):\n\t    \"\"\"Everything works except SCM commands if the SCM is unusable.\"\"\"\n\t    # Arrange\n\t    monkeypatch.setenv(\"PATH\", \"\")\n\t    with inside_dir(tmp_path):\n\t        version_path = tmp_path / \"VERSION\"\n\t        version_path.write_text(\"31.0.3\")\n\t        runner: CliRunner = CliRunner()\n", "        # Act\n\t        runner.invoke(cli.cli, [\"bump\", \"major\", \"--current-version\", \"31.0.3\", \"VERSION\"])\n\t    # Assert\n\t    assert version_path.read_text() == \"32.0.0\"\n\t@pytest.mark.parametrize(\n\t    [\"version_part\"],\n\t    [\n\t        param(\"charlie\", id=\"bad_version_part\"),\n\t        param(\"\", id=\"missing_version_part\"),\n\t    ],\n", ")\n\tdef test_detects_bad_or_missing_version_part(version_part: str, tmp_path: Path, monkeypatch):\n\t    \"\"\"It properly detects bad or missing version part.\"\"\"\n\t    # Arrange\n\t    monkeypatch.setenv(\"PATH\", \"\")\n\t    with inside_dir(tmp_path):\n\t        version_path = tmp_path / \"VERSION\"\n\t        version_path.write_text(\"31.0.3\")\n\t        runner: CliRunner = CliRunner()\n\t        args = [\"bump\", \"--current-version\", \"31.0.3\"]\n", "        if version_part:\n\t            args.append(version_part)\n\t        args.append(\"VERSION\")\n\t        # Act\n\t        result = runner.invoke(cli.cli, args)\n\t    # Assert\n\t    assert result.exception is not None\n\t    assert \"Unknown version part:\" in result.stdout\n\tdef test_show(tmp_path: Path, fixtures_path: Path):\n\t    \"\"\"The show subcommand should list the parts of the configuration.\"\"\"\n", "    # Arrange\n\t    config_path = tmp_path / \"pyproject.toml\"\n\t    toml_path = fixtures_path / \"basic_cfg.toml\"\n\t    shutil.copy(toml_path, config_path)\n\t    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n\t        result: Result = runner.invoke(cli.cli, [\"show\", \"current_version\"])\n\t    if result.exit_code != 0:\n\t        print(result.output)\n\t        print(result.exception)\n", "    assert result.exit_code == 0\n\t    assert result.output.splitlines(keepends=False) == [\"1.0.0\"]\n\tdef test_show_and_increment(tmp_path: Path, fixtures_path: Path):\n\t    \"\"\"The show subcommand should incrment the version and display it.\"\"\"\n\t    # Arrange\n\t    config_path = tmp_path / \"pyproject.toml\"\n\t    toml_path = fixtures_path / \"basic_cfg.toml\"\n\t    shutil.copy(toml_path, config_path)\n\t    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n", "        result: Result = runner.invoke(cli.cli, [\"show\", \"new_version\", \"--increment\", \"minor\"])\n\t    if result.exit_code != 0:\n\t        print(result.output)\n\t        print(result.exception)\n\t    assert result.exit_code == 0\n\t    assert result.output.splitlines(keepends=False) == [\"1.1.0-dev\"]\n\tdef test_show_no_args(tmp_path: Path, fixtures_path: Path):\n\t    \"\"\"The show subcommand should list the entire configuration.\"\"\"\n\t    # Arrange\n\t    config_path = tmp_path / \"pyproject.toml\"\n", "    toml_path = fixtures_path / \"basic_cfg.toml\"\n\t    expected_output = fixtures_path.joinpath(\"basic_cfg_expected.yaml\").read_text()\n\t    shutil.copy(toml_path, config_path)\n\t    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n\t        result: Result = runner.invoke(cli.cli, [\"show\", \"--format\", \"yaml\"])\n\t    if result.exit_code != 0:\n\t        print(result.output)\n\t        print(result.exception)\n\t    assert result.exit_code == 0\n", "    assert result.output.strip() == expected_output.strip()\n\tdef test_replace(mocker, tmp_path, fixtures_path):\n\t    \"\"\"The replace subcommand should replace the version in the file.\"\"\"\n\t    # Arrange\n\t    toml_path = fixtures_path / \"basic_cfg.toml\"\n\t    config_path = tmp_path / \"pyproject.toml\"\n\t    shutil.copy(toml_path, config_path)\n\t    mocked_modify_files = mocker.patch(\"bumpversion.cli.modify_files\")\n\t    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n", "        result: Result = runner.invoke(cli.cli, [\"replace\", \"--new-version\", \"1.1.0\"])\n\t    if result.exit_code != 0:\n\t        print(result.output)\n\t    assert result.exit_code == 0\n\t    call_args = mocked_modify_files.call_args[0]\n\t    configured_files = call_args[0]\n\t    assert len(configured_files) == 3\n\t    actual_filenames = {f.path for f in configured_files}\n\t    assert actual_filenames == {\"setup.py\", \"CHANGELOG.md\", \"bumpversion/__init__.py\"}\n\tdef test_replace_no_newversion(mocker, tmp_path, fixtures_path):\n", "    \"\"\"The replace subcommand should set new_version to None in the context.\"\"\"\n\t    # Arrange\n\t    toml_path = fixtures_path / \"basic_cfg.toml\"\n\t    config_path = tmp_path / \"pyproject.toml\"\n\t    shutil.copy(toml_path, config_path)\n\t    mocked_modify_files = mocker.patch(\"bumpversion.cli.modify_files\")\n\t    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n\t        result: Result = runner.invoke(cli.cli, [\"replace\"])\n\t    if result.exit_code != 0:\n", "        print(result.output)\n\t    assert result.exit_code == 0\n\t    call_args = mocked_modify_files.call_args[0]\n\t    assert call_args[2] is None\n\tdef test_replace_specific_files(mocker, git_repo, fixtures_path):\n\t    \"\"\"The replace subcommand should set the files to only the specified files.\"\"\"\n\t    # Arrange\n\t    toml_path = fixtures_path / \"basic_cfg.toml\"\n\t    config_path = git_repo / \"pyproject.toml\"\n\t    shutil.copy(toml_path, config_path)\n", "    mocked_modify_files = mocker.patch(\"bumpversion.cli.modify_files\")\n\t    runner: CliRunner = CliRunner()\n\t    with inside_dir(git_repo):\n\t        result: Result = runner.invoke(cli.cli, [\"replace\", \"--no-configured-files\", \"VERSION\"])\n\t    if result.exit_code != 0:\n\t        print(result.output)\n\t    assert result.exit_code == 0\n\t    call_args = mocked_modify_files.call_args[0]\n\t    configured_files = call_args[0]\n\t    assert len(configured_files) == 1\n", "    assert configured_files[0].path == \"VERSION\"\n\tTEST_REPLACE_CONFIG = {\n\t    \"tool\": {\n\t        \"bumpversion\": {\n\t            \"allow_dirty\": True,\n\t            \"commit\": False,\n\t            \"current_version\": \"2.17.7\",\n\t            \"files\": [],\n\t            \"message\": \"Bump version: {current_version} → {new_version}\",\n\t            \"parse\": \"(?P<major>\\\\d+)\\\\.(?P<minor>\\\\d+)\\\\.(?P<patch>\\\\d+)\",\n", "            \"parts\": {\n\t                \"major\": {},\n\t                \"minor\": {},\n\t                \"patch\": {},\n\t            },\n\t            \"replace\": \"{new_version}\",\n\t            \"search\": \"{current_version}\",\n\t            \"serialize\": [\"{major}.{minor}.{patch}\"],\n\t            \"sign_tags\": False,\n\t            \"tag\": False,\n", "            \"tag_message\": \"Bump version: {current_version} → {new_version}\",\n\t            \"tag_name\": \"v{new_version}\",\n\t        }\n\t    }\n\t}\n\tdef test_replace_search_with_plain_string(tmp_path, fixtures_path):\n\t    \"\"\"Replace should not worry if the search or replace values have version info.\"\"\"\n\t    from tomlkit import dumps\n\t    # Arrange\n\t    config_path = tmp_path / \"pyproject.toml\"\n", "    config_path.write_text(dumps(TEST_REPLACE_CONFIG))\n\t    doc_path = tmp_path / \"docs.yaml\"\n\t    doc_path.write_text(\"url: https://github.com/sampleuser/workflows/main/.github/update_mailmap.py\")\n\t    runner: CliRunner = CliRunner()\n\t    with inside_dir(tmp_path):\n\t        result: Result = runner.invoke(\n\t            cli.cli,\n\t            [\n\t                \"replace\",\n\t                \"--no-configured-files\",\n", "                \"--search\",\n\t                \"/workflows/main/\",\n\t                \"--replace\",\n\t                \"/workflows/v{current_version}/\",\n\t                \"./docs.yaml\",\n\t            ],\n\t        )\n\t    if result.exit_code != 0:\n\t        print(\"Here is the output:\")\n\t        print(result.output)\n", "        print(traceback.print_exception(result.exc_info[1]))\n\t    assert result.exit_code == 0\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["\"\"\"Testing fixtures for Pytest.\"\"\"\n\timport subprocess\n\tfrom contextlib import contextmanager\n\tfrom pathlib import Path\n\tfrom typing import Generator\n\timport pytest\n\t@pytest.fixture\n\tdef tests_path() -> Path:\n\t    \"\"\"Return the path containing the tests.\"\"\"\n\t    return Path(__file__).parent\n", "@pytest.fixture\n\tdef fixtures_path(tests_path: Path) -> Path:\n\t    \"\"\"Return the path containing the testing fixtures.\"\"\"\n\t    return tests_path / \"fixtures\"\n\t@contextmanager\n\tdef inside_dir(dirpath: Path) -> Generator:\n\t    \"\"\"\n\t    Temporarily switch to a specific directory.\n\t    Args:\n\t        dirpath: Path of the directory to switch to\n", "    \"\"\"\n\t    import os\n\t    old_path = os.getcwd()\n\t    try:\n\t        os.chdir(dirpath)\n\t        yield\n\t    finally:\n\t        os.chdir(old_path)\n\tdef get_config_data(overrides: dict) -> tuple:\n\t    \"\"\"Get the configuration, version_config and version.\"\"\"\n", "    from bumpversion import config\n\t    from bumpversion.version_part import VersionConfig\n\t    conf = config.get_configuration(config_file=\"missing\", **overrides)\n\t    version_config = VersionConfig(conf.parse, conf.serialize, conf.search, conf.replace, conf.parts)\n\t    version = version_config.parse(conf.current_version)\n\t    return conf, version_config, version\n\t@pytest.fixture\n\tdef git_repo(tmp_path: Path) -> Path:\n\t    \"\"\"Generate a simple temporary git repo and return the path.\"\"\"\n\t    subprocess.run([\"git\", \"init\"], cwd=tmp_path, check=True, capture_output=True)\n", "    return tmp_path\n\t@pytest.fixture\n\tdef hg_repo(tmp_path: Path) -> Path:\n\t    \"\"\"Generate a simple temporary mercurial repo and return the path.\"\"\"\n\t    subprocess.run([\"hg\", \"init\"], cwd=tmp_path, check=True, capture_output=True)\n\t    return tmp_path\n"]}
{"filename": "tests/test_show.py", "chunked_list": ["import shutil\n\tfrom dataclasses import dataclass\n\tfrom pathlib import Path\n\tfrom tests.conftest import get_config_data, inside_dir\n\timport pytest\n\tfrom pytest import param\n\tfrom bumpversion import show\n\tfrom bumpversion import config\n\tmapping = {\"key1\": \"value1\", \"dict-key\": {\"dict-key-key1\": \"value2-1\"}}\n\tFIXTURES_PATH = Path(__file__).parent.joinpath(\"fixtures\")\n", "@dataclass\n\tclass SimpleObj:\n\t    \"\"\"An object for testing.\"\"\"\n\t    dict_attr: dict\n\t    list_attr: list\n\t    @property\n\t    def exc(self):\n\t        return self._notavailable\n\ttest_obj = SimpleObj(dict_attr=mapping, list_attr=[\"a\", \"b\", \"c\", \"d\"])\n\t@pytest.mark.parametrize(\n", "    [\"name\", \"data\", \"expected\"],\n\t    [\n\t        param(\"key1\", mapping, \"value1\", id=\"simple mapping\"),\n\t        param(\"dict-key.dict-key-key1\", mapping, \"value2-1\", id=\"nested mapping\"),\n\t        param(\"dict_attr\", test_obj, mapping, id=\"attribute lookup\"),\n\t        param(\"list_attr.2\", test_obj, \"c\", id=\"list lookup\"),\n\t    ],\n\t)\n\tdef test_resolve_name(name: str, data, expected):\n\t    \"\"\"Test the resolve_name method gets the correct values.\"\"\"\n", "    assert show.resolve_name(data, name) == expected\n\tdef test_resolve_name_default():\n\t    \"\"\"Test a default value.\"\"\"\n\t    assert show.resolve_name(mapping, \"key3\", default=\"default\") == \"default\"\n\tdef test_resolve_name_property_error():\n\t    \"\"\"An error in a property returns default.\"\"\"\n\t    assert show.resolve_name(test_obj, \"exc\", default=\"default\") == \"default\"\n\tDEFAULT_OUTPUT = FIXTURES_PATH.joinpath(\"basic_cfg_expected.txt\").read_text().strip()\n\tYAML_OUTPUT = FIXTURES_PATH.joinpath(\"basic_cfg_expected.yaml\").read_text().strip()\n\tJSON_OUTPUT = FIXTURES_PATH.joinpath(\"basic_cfg_expected_full.json\").read_text().strip()\n", "FOUR_ARGS_DEFAULT_OUTPUT = \"{'allow_dirty': False,\\n 'current_version': '1.0.0',\\n 'sign_tags': False,\\n 'tag': True}\"\n\tFOUR_ARGS_YAML_OUTPUT = 'allow_dirty: false\\ncurrent_version: \"1.0.0\"\\nsign_tags: false\\ntag: true'\n\tFOUR_ARGS_JSON_OUTPUT = '{\"allow_dirty\": false, \"current_version\": \"1.0.0\", \"sign_tags\": false, \"tag\": true}'\n\tDOTTED_DEFAULT_OUTPUT = (\n\t    \"{'current_version': '1.0.0',\\n 'files.1.filename': 'bumpversion/__init__.py',\\n\"\n\t    \" 'parts.release.values': ['dev', 'gamma']}\"\n\t)\n\tDOTTED_YAML_OUTPUT = (\n\t    'current_version: \"1.0.0\"\\n'\n\t    'files.1.filename: \"bumpversion/__init__.py\"\\n'\n", "    \"parts.release.values:\\n\"\n\t    '  - \"dev\"\\n'\n\t    '  - \"gamma\"'\n\t)\n\tDOTTED_JSON_OUTPUT = (\n\t    '{\\n  \"current_version\": \"1.0.0\",'\n\t    '\\n  \"files.1.filename\": \"bumpversion/__init__.py\",\\n  \"parts.release.values\": [\\n    \"dev\",\\n    \"gamma\"\\n  ]\\n}'\n\t)\n\t@pytest.mark.parametrize(\n\t    [\"req_args\", \"format_\", \"expected\"],\n", "    (\n\t        param(\n\t            [],\n\t            None,\n\t            DEFAULT_OUTPUT,\n\t            id=\"no-arguments-default\",\n\t        ),\n\t        param(\n\t            [],\n\t            \"yaml\",\n", "            YAML_OUTPUT,\n\t            id=\"no-arguments-yaml\",\n\t        ),\n\t        param(\n\t            [],\n\t            \"json\",\n\t            JSON_OUTPUT,\n\t            id=\"no-arguments-json\",\n\t        ),\n\t        param(\n", "            [\"all\"],\n\t            None,\n\t            DEFAULT_OUTPUT,\n\t            id=\"all-argument-default\",\n\t        ),\n\t        param(\n\t            [\"all\", \"current_version\"],\n\t            None,\n\t            DEFAULT_OUTPUT,\n\t            id=\"all-argument-in-args-default\",\n", "        ),\n\t        param(\n\t            [\"current_version\"],\n\t            \"default\",\n\t            \"1.0.0\",\n\t            id=\"current_version\",\n\t        ),\n\t        param(\n\t            [\"current_version\", \"allow_dirty\", \"sign_tags\", \"tag\"],\n\t            \"default\",\n", "            FOUR_ARGS_DEFAULT_OUTPUT,\n\t            id=\"four_args_default\",\n\t        ),\n\t        param(\n\t            [\"files.1.filename\", \"current_version\", \"parts.release.values\"],\n\t            \"default\",\n\t            DOTTED_DEFAULT_OUTPUT,\n\t            id=\"dotted-default\",\n\t        ),\n\t        param(\n", "            [\"files.1.filename\", \"current_version\", \"parts.release.values\"],\n\t            \"yaml\",\n\t            DOTTED_YAML_OUTPUT,\n\t            id=\"dotted-yaml\",\n\t        ),\n\t        param(\n\t            [\"files.1.filename\", \"current_version\", \"parts.release.values\"],\n\t            \"json\",\n\t            DOTTED_JSON_OUTPUT,\n\t            id=\"dotted-json\",\n", "        ),\n\t    ),\n\t)\n\tdef test_do_show(\n\t    req_args: list, format_: str, expected: str, tmp_path: Path, fixtures_path: Path, capsys: pytest.CaptureFixture\n\t) -> None:\n\t    \"\"\"Test the show method.\"\"\"\n\t    config_path = tmp_path / \"pyproject.toml\"\n\t    toml_path = fixtures_path / \"basic_cfg.toml\"\n\t    shutil.copy(toml_path, config_path)\n", "    with inside_dir(tmp_path):\n\t        conf = config.get_configuration(config_file=fixtures_path.joinpath(config_path))\n\t        show.do_show(config=conf, format_=format_, *req_args)\n\t    captured = capsys.readouterr()\n\t    assert captured.out.strip() == expected\n\tdef test_do_show_increment(tmp_path: Path, fixtures_path: Path, capsys: pytest.CaptureFixture) -> None:\n\t    \"\"\"Test the show method with increment.\"\"\"\n\t    config_path = tmp_path / \"pyproject.toml\"\n\t    toml_path = fixtures_path / \"basic_cfg.toml\"\n\t    shutil.copy(toml_path, config_path)\n", "    with inside_dir(tmp_path):\n\t        conf = config.get_configuration(config_file=fixtures_path.joinpath(config_path))\n\t        show.do_show(\"current_version\", \"new_version\", config=conf, format_=\"default\", increment=\"minor\")\n\t    captured = capsys.readouterr()\n\t    assert captured.out.strip() == \"{'current_version': '1.0.0', 'new_version': '1.1.0-dev'}\"\n"]}
{"filename": "docsrc/conf.py", "chunked_list": ["\"\"\"\n\tSphinx configuration.\n\t\"\"\"\n\t# flake8: noqa\n\timport os\n\timport sys\n\tfrom datetime import date\n\tsys.path.insert(0, os.path.abspath(\"..\"))\n\timport bumpversion\n\tproject = \"bump-my-version\"\n", "copyright = f\"{date.today():%Y} Calloway Project\"\n\tauthor = \"Contributors\"\n\tversion = bumpversion.__version__\n\trelease = bumpversion.__version__\n\t# -- General configuration ---------------------------------------------\n\textensions = [\n\t    \"myst_parser\",\n\t    \"autodoc2\",\n\t    # \"sphinx.ext.autodoc\",\n\t    \"sphinx.ext.viewcode\",\n", "    \"sphinx.ext.autosummary\",\n\t    \"sphinx.ext.intersphinx\",\n\t    \"sphinx.ext.autosectionlabel\",\n\t    \"sphinx.ext.napoleon\",\n\t    \"sphinx_autodoc_typehints\",\n\t    \"sphinx.ext.coverage\",\n\t    \"sphinx.ext.githubpages\",\n\t    \"sphinx_click\",\n\t    \"sphinx_copybutton\",\n\t]\n", "autosectionlabel_prefix_document = True\n\tautosectionlabel_maxdepth = 2\n\tautodoc2_packages = [\"../bumpversion\"]\n\tautodoc2_render_plugin = \"myst\"\n\tautodoc2_output_dir = \"reference\"\n\tautodoc2_index_template = None\n\tautodoc_default_flags = [\n\t    # Make sure that any autodoc declarations show the right members\n\t    \"members\",\n\t    \"undoc-members\",\n", "    \"private-members\",\n\t]\n\tautodoc_class_signature = \"separated\"\n\tautodoc_member_order = \"bysource\"\n\tautodoc_typehints = \"description\"\n\tautosummary_generate = True\n\tnapoleon_attr_annotations = True\n\tnapoleon_include_special_with_doc = True\n\tnapoleon_include_private_with_doc = True\n\tnapoleon_include_init_with_doc = True\n", "napoleon_use_admonition_for_examples = True\n\tmyst_enable_extensions = [\n\t    \"amsmath\",\n\t    \"colon_fence\",\n\t    \"deflist\",\n\t    \"dollarmath\",\n\t    \"linkify\",\n\t    \"replacements\",\n\t    \"smartquotes\",\n\t    \"substitution\",\n", "    \"tasklist\",\n\t    \"fieldlist\",\n\t]\n\tintersphinx_mapping = {\n\t    \"python\": (\"https://docs.python.org/3\", None),\n\t}\n\ttemplates_path = [\"_templates\"]\n\tsource_suffix = [\".rst\", \".md\"]\n\tmaster_doc = \"index\"\n\tlanguage = \"en\"\n", "exclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\tpygments_style = \"sphinx\"\n\ttodo_include_todos = False\n\t# -- Options for HTML output -------------------------------------------\n\thtml_theme = \"furo\"\n\thtml_static_path = [\"_static\"]\n\thtml_css_files = [\n\t    \"css/custom.css\",\n\t]\n\thtml_theme_options = {\n", "    \"footer_icons\": [\n\t        {\n\t            \"name\": \"GitHub\",\n\t            \"url\": \"https://github.com/callowayproject/bump-my-version\",\n\t            \"html\": \"\"\"\n\t                <svg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" viewBox=\"0 0 16 16\">\n\t                    <path fill-rule=\"evenodd\" d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z\"></path>\n\t                </svg>\n\t            \"\"\",\n\t            \"class\": \"\",\n", "        },\n\t    ],\n\t}\n\thtml_title = f\"Bump My Version {release}\"\n"]}
