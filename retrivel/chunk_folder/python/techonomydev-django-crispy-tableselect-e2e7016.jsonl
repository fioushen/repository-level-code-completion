{"filename": "manage.py", "chunked_list": ["#!/usr/bin/env python\n\t\"\"\"Django's command-line utility for administrative tasks.\"\"\"\n\timport os\n\timport sys\n\tdef main():\n\t    \"\"\"Run administrative tasks.\"\"\"\n\t    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"sandbox.settings\")\n\t    try:\n\t        from django.core.management import execute_from_command_line\n\t    except ImportError as exc:\n", "        raise ImportError(\n\t            \"Couldn't import Django. Are you sure it's installed and \"\n\t            \"available on your PYTHONPATH environment variable? Did you \"\n\t            \"forget to activate a virtual environment?\"\n\t        ) from exc\n\t    execute_from_command_line(sys.argv)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/conftest.py", "chunked_list": ["import pytest\n\tfrom django_crispy_tableselect import TableSelectHelper\n\tfrom sandbox import factories, models, tables\n\t@pytest.fixture\n\tdef book_factory():\n\t    return factories.BookFactory\n\t@pytest.fixture\n\tdef author_factory():\n\t    return factories.AuthorFactory\n\t@pytest.fixture\n", "def books_tableselecthelper(book_factory):\n\t    \"\"\"Return an instance of TableSelectHelper that is operating on a collection of 10 books.\n\t    Accepts an `table_data` argument to pass your own data.\n\t    All other kwargs are passed as-is to TableSelectHelper.__init__()\n\t    \"\"\"\n\t    def inner_func(**extra_args):\n\t        qs = models.Book.objects.none()\n\t        if \"table_data\" not in extra_args:\n\t            book_factory.create_batch(10)\n\t            qs = models.Book.objects.all()\n", "        kwargs = {\n\t            \"column_name\": \"selected_books\",\n\t            \"table_class\": tables.BookTable,\n\t            \"table_data\": extra_args.pop(\"table_data\", qs),\n\t            \"label\": \"title\",\n\t            **extra_args,\n\t        }\n\t        return TableSelectHelper(**kwargs)\n\t    return inner_func\n"]}
{"filename": "tests/functional/test_column_html.py", "chunked_list": ["import django_tables2 as tables\n\timport pytest\n\tfrom bs4 import BeautifulSoup\n\tfrom django_crispy_tableselect.columns import CheckBoxColumn\n\tclass MyTable(tables.Table):\n\t    pass\n\tclass MockHelper:\n\t    allow_select_all = True\n\t    def get_accessible_label(self, *args, **kwargs):\n\t        return \"mock_label\"\n", "    def get_select_all_checkbox_attrs(self, *args, **kwargs):\n\t        return {}\n\t@pytest.mark.parametrize(\"allow_select_all\", (True, False))\n\tdef test_render_column_header_allow_select_all(allow_select_all):\n\t    \"\"\"Check that the column header renders a select-all checkbox when needed.\"\"\"\n\t    helper = MockHelper()\n\t    helper.allow_select_all = allow_select_all\n\t    table = MyTable(\n\t        data=[],\n\t        extra_columns=[\n", "            (\n\t                \"foo\",\n\t                CheckBoxColumn(\n\t                    verbose_name=\"\",\n\t                    input_name=\"test_input_name\",\n\t                    helper=helper,\n\t                    selected_values=[],\n\t                ),\n\t            )\n\t        ],\n", "    )\n\t    soup = BeautifulSoup(table.columns[\"foo\"].header, \"html.parser\")\n\t    if allow_select_all:\n\t        assert soup.select('input[type=\"checkbox\"]')\n\t    else:\n\t        assert not soup.select('input[type=\"checkbox\"]')\n\t@pytest.mark.parametrize(\"allow_select_all\", (True, False))\n\tdef test_render_column_header_always_has_narrator_element(allow_select_all):\n\t    \"\"\"Check that the column header renders always renders an invisible element used by the frontend for accessibility purposes.\"\"\"\n\t    helper = MockHelper()\n", "    helper.allow_select_all = allow_select_all\n\t    table = MyTable(\n\t        data=[],\n\t        extra_columns=[\n\t            (\n\t                \"foo\",\n\t                CheckBoxColumn(\n\t                    verbose_name=\"\",\n\t                    input_name=\"test_input_name\",\n\t                    helper=helper,\n", "                    selected_values=[],\n\t                ),\n\t            )\n\t        ],\n\t    )\n\t    soup = BeautifulSoup(table.columns[\"foo\"].header, \"html.parser\")\n\t    assert soup.select(\"[data-tableselect-narrator]\")\n"]}
{"filename": "tests/functional/__init__.py", "chunked_list": []}
{"filename": "tests/functional/test_views.py", "chunked_list": []}
{"filename": "tests/unit/test_layout.py", "chunked_list": ["from uuid import uuid4\n\timport pytest\n\tfrom django_crispy_tableselect.helpers import TableSelectHelper\n\tfrom django_crispy_tableselect.layout import TableSelect\n\tfrom sandbox.tables import BookTable\n\tclass MockHelper:\n\t    allow_select_all = True\n\t    def get_accessible_label(self, *args, **kwargs):\n\t        return \"mock_label\"\n\t    def get_select_all_checkbox_attrs(self, *args, **kwargs):\n", "        return {}\n\t@pytest.mark.django_db\n\tdef test_tableselect_media():\n\t    \"\"\"Check that the helper media is made available through the layout object.\"\"\"\n\t    helper = TableSelectHelper(\"foo\", BookTable, [], \"foo\")\n\t    assert helper.media is not None\n\t    # Create layout object and pass it the helper\n\t    layout = TableSelect(\"foo\", helper)\n\t    assert layout.media is not None\n\t    js_path = helper.media._js[0]\n", "    # Path the same static file is available\n\t    assert js_path in layout.media._js\n\tdef test_tableselect_format_value():\n\t    layout = TableSelect(\"foo\", helper=MockHelper())\n\t    # Check it removes None values\n\t    assert layout.format_value(None) == []\n\t    # Check it keeps empty strings\n\t    assert layout.format_value(\"\") == [\"\"]\n\t    # Check it casts primitives to a list with a string\n\t    assert layout.format_value(0) == [\"0\"]\n", "    # Check it casts a list of primitives to a list of strings\n\t    assert layout.format_value([1, 2]) == [\"1\", \"2\"]\n\t    # Check it casts objects to their string representation\n\t    uuid = uuid4()\n\t    assert layout.format_value([uuid]) == [str(uuid)]\n"]}
{"filename": "tests/unit/__init__.py", "chunked_list": []}
{"filename": "tests/unit/test_columns.py", "chunked_list": ["import django_tables2 as tables\n\tfrom django_crispy_tableselect.columns import CheckBoxColumn\n\tclass MyTable(tables.Table):\n\t    pass\n\tclass MockHelper:\n\t    allow_select_all = True\n\t    def get_accessible_label(self, *args, **kwargs):\n\t        return \"mock_label\"\n\t    def get_select_all_checkbox_attrs(self, *args, **kwargs):\n\t        return {}\n", "def test_td_name_attr_present():\n\t    \"\"\"Check that the correct name attribute is applied\"\"\"\n\t    data = [{\"id\": 1, \"label\": \"One\"}, {\"id\": 2, \"label\": \"Two\"}]\n\t    selected_values = [\"1\"]\n\t    table = MyTable(\n\t        data=data,\n\t        extra_columns=[\n\t            (\n\t                \"foo\",\n\t                CheckBoxColumn(\n", "                    verbose_name=\"\",\n\t                    input_name=\"test_input_name\",\n\t                    helper=MockHelper(),\n\t                    selected_values=selected_values,\n\t                ),\n\t            )\n\t        ],\n\t    )\n\t    bound_column = table.columns[\"foo\"]\n\t    assert \"td__input\" in bound_column.attrs\n", "    assert \"name\" in bound_column.attrs[\"td__input\"]\n\t    assert \"test_input_name\" in bound_column.attrs[\"td__input\"][\"name\"]\n\tdef test_custom_td_attrs():\n\t    \"\"\"Check that custom td__input attrs can be passed to the CheckboxColumn.\"\"\"\n\t    data = [{\"id\": 1, \"label\": \"One\"}, {\"id\": 2, \"label\": \"Two\"}]\n\t    selected_values = [\"1\"]\n\t    table = MyTable(\n\t        data=data,\n\t        extra_columns=[\n\t            (\n", "                \"foo\",\n\t                CheckBoxColumn(\n\t                    verbose_name=\"\",\n\t                    input_name=\"test\",\n\t                    helper=MockHelper(),\n\t                    selected_values=selected_values,\n\t                    attrs={\"td__input\": {\"injected-as-column-attr\": \"\"}},\n\t                ),\n\t            )\n\t        ],\n", "    )\n\t    bound_column = table.columns[\"foo\"]\n\t    assert \"td__input\" in bound_column.attrs\n\t    assert \"injected-as-column-attr\" in bound_column.attrs[\"td__input\"]\n\t    # name should not have been overridden\n\t    assert \"name\" in bound_column.attrs[\"td__input\"]\n\tdef test_custom_th_attrs():\n\t    \"\"\"Check that custom th__input attrs can be passed to the CheckboxColumn.\"\"\"\n\t    class MockHelperWithCustomSelectAllAttrs(MockHelper):\n\t        def get_select_all_checkbox_attrs(self, *args):\n", "            return {\"injected-by-helper\": \"\"}\n\t    data = [{\"id\": 1, \"label\": \"One\"}, {\"id\": 2, \"label\": \"Two\"}]\n\t    selected_values = [\"1\"]\n\t    table = MyTable(\n\t        data=data,\n\t        extra_columns=[\n\t            (\n\t                \"foo\",\n\t                CheckBoxColumn(\n\t                    verbose_name=\"\",\n", "                    input_name=\"test\",\n\t                    helper=MockHelperWithCustomSelectAllAttrs(),\n\t                    selected_values=selected_values,\n\t                    attrs={\"th__input\": {\"injected-as-column-attr\": \"\"}},\n\t                ),\n\t            )\n\t        ],\n\t    )\n\t    bound_column = table.columns[\"foo\"]\n\t    assert \"th__input\" in bound_column.attrs\n", "    assert \"injected-as-column-attr\" in bound_column.attrs[\"th__input\"]\n\t    assert \"injected-by-helper\" in bound_column.attrs[\"th__input\"]\n\tdef test_correct_value_attribute_used():\n\t    \"\"\"Check that the correct value attribute is applied to the right cell.\"\"\"\n\t    data = [{\"id\": 1, \"label\": \"One\"}, {\"id\": 2, \"label\": \"Two\"}]\n\t    selected_values = [\"1\"]\n\t    table = MyTable(\n\t        data=data,\n\t        extra_columns=[\n\t            (\n", "                \"id\",\n\t                CheckBoxColumn(\n\t                    verbose_name=\"\",\n\t                    input_name=\"test_input_name\",\n\t                    helper=MockHelper(),\n\t                    selected_values=selected_values,\n\t                ),\n\t            )\n\t        ],\n\t    )\n", "    cell_html = table.rows[0].get_cell(\"id\")\n\t    assert 'value=\"1\"' in cell_html\n\t    cell_html = table.rows[1].get_cell(\"id\")\n\t    assert 'value=\"2\"' in cell_html\n"]}
{"filename": "tests/unit/test_helper.py", "chunked_list": ["import django_tables2 as tables\n\timport pytest\n\tfrom django.contrib.staticfiles.finders import find\n\tfrom django.core import exceptions\n\tfrom django_crispy_tableselect import TableSelectHelper\n\tfrom django_crispy_tableselect.columns import CheckBoxColumn\n\tfrom sandbox.models import Book\n\tfrom sandbox.tables import BookTable\n\tBOOKS_DICT = [\n\t    {\"title\": \"Sans Famille\", \"id\": 123, \"author\": \"Hector Malot\"},\n", "    {\"title\": \"How to Become King\", \"id\": 456, \"author\": \"Jan Terlouw\"},\n\t]\n\tdef test_select_all_defaults_to_false():\n\t    \"\"\"Check that - when not specified - the ``allow_select_all`` option defaults to False.\"\"\"\n\t    helper = TableSelectHelper(\"foo\", table_class=BookTable, table_data=[], label=\"foo\")\n\t    assert not helper.allow_select_all\n\tdef test_helper_always_disables_orderable_option():\n\t    \"\"\"Check that the helper always returns a table with the orderable option disabled.\"\"\"\n\t    class OrderableTable(BookTable):\n\t        class Meta:\n", "            orderable = True\n\t    helper = TableSelectHelper(\n\t        \"foo\", table_class=OrderableTable, table_data=[], label=\"foo\"\n\t    )\n\t    table = helper.get_table(\"foo\", [])\n\t    # Table class enabled ordering, but the helper should have forcefully disabled it\n\t    assert not table.orderable\n\t@pytest.mark.django_db\n\tdef test_accessible_label__callable_str(books_tableselecthelper, book_factory):\n\t    \"\"\"Check that the default implementation of get_accessible_label includes the value of ``label``.\"\"\"\n", "    helper = books_tableselecthelper(table_data=BOOKS_DICT, label=str)\n\t    book = book_factory(title=\"The Witches by Roahl Dahl\")\n\t    qs = Book.objects.all()\n\t    helper = books_tableselecthelper(table_data=qs)\n\t    assert str(book) in helper.get_accessible_label(book)\n\t@pytest.mark.django_db\n\tdef test_accessible_label__callable_lambda(books_tableselecthelper, book_factory):\n\t    \"\"\"Check that the default implementation of get_accessible_label includes the value of ``label``.\"\"\"\n\t    helper = books_tableselecthelper(table_data=BOOKS_DICT, label=lambda x: x.title)\n\t    book = book_factory(title=\"The Witches by Roahl Dahl\")\n", "    qs = Book.objects.all()\n\t    helper = books_tableselecthelper(table_data=qs)\n\t    assert book.title in helper.get_accessible_label(book)\n\tdef test_accessible_label__dictionary(books_tableselecthelper):\n\t    \"\"\"Check that the default implementation of get_accessible_label includes the value of ``label``.\"\"\"\n\t    helper = books_tableselecthelper(table_data=BOOKS_DICT, label=\"title\")\n\t    assert BOOKS_DICT[0][\"title\"] in helper.get_accessible_label(BOOKS_DICT[0])\n\t    assert BOOKS_DICT[1][\"title\"] in helper.get_accessible_label(BOOKS_DICT[1])\n\t@pytest.mark.django_db\n\tdef test_accessible_label__queryset(books_tableselecthelper, book_factory):\n", "    \"\"\"Check that the default implementation of get_accessible_label includes the value of .\"\"\"\n\t    book = book_factory(title=\"The Witches by Roahl Dahl\")\n\t    qs = Book.objects.all()\n\t    helper = books_tableselecthelper(table_data=qs)\n\t    assert str(book) in helper.get_accessible_label(book)\n\tdef test_table_class_derived_from_table():\n\t    \"\"\"Check that an exception is raised when the given table class is not actually a table.\"\"\"\n\t    class NotDerivedFromTableClass:\n\t        pass\n\t    class DerivedFromTableClass(tables.Table):\n", "        pass\n\t    with pytest.raises(exceptions.ImproperlyConfigured):\n\t        TableSelectHelper(\n\t            \"foo\",\n\t            table_class=NotDerivedFromTableClass,\n\t            table_data=[],\n\t            label=\"foo\",\n\t        )\n\t    TableSelectHelper(\n\t        \"foo\", table_class=DerivedFromTableClass, table_data=[], label=\"foo\"\n", "    )\n\tdef test_media():\n\t    \"\"\"Check that the media attribute is present on the helper and that it contains a valid reference to a javascript file.\"\"\"\n\t    helper = TableSelectHelper(\"foo\", table_class=BookTable, table_data=[], label=\"foo\")\n\t    assert helper.media\n\t    assert helper.media._js\n\t    # Check that Django's staticfiles app can find the javascript file\n\t    assert find(helper.media._js[0])\n\t@pytest.mark.django_db\n\tdef test_checkbox_column(books_tableselecthelper):\n", "    \"\"\"Check that the checkbox column is added and added at the start of the table.\"\"\"\n\t    helper = books_tableselecthelper()\n\t    table = helper.get_table(\"foo\", [])\n\t    # Checkbox column is present\n\t    assert \"selected_books\" in table.columns\n\t    bound_column = table.columns[\"selected_books\"]\n\t    assert isinstance(bound_column.column, CheckBoxColumn)\n\t    # Checkbox column is first column in sequence\n\t    assert table.sequence[0] == \"selected_books\"\n\tdef test_prepare_table_data__dict(books_tableselecthelper):\n", "    \"\"\"Check that the helper prepares the table data with values necessary for the checkbox column to function.\"\"\"\n\t    data = [{\"id\": 1, \"title\": \"One\"}, {\"id\": 2, \"title\": \"Two\"}]\n\t    helper = books_tableselecthelper(\n\t        column_name=\"foo\", table_data=data, value_field=\"id\", label=\"label\"\n\t    )\n\t    prepared_data = helper.prepare_table_data(data)\n\t    assert len(prepared_data) > 0\n\t    for row in prepared_data:\n\t        assert \"foo\" in row\n\t        assert row[\"foo\"] in [1, 2]\n", "@pytest.mark.django_db\n\tdef test_prepare_table_data__queryset(books_tableselecthelper):\n\t    \"\"\"Check that the helper prepares the table data with values necessary for the checkbox column to function.\"\"\"\n\t    helper = books_tableselecthelper(column_name=\"foo\", value_field=\"id\", label=\"label\")\n\t    prepared_data = helper.prepare_table_data(helper.table_data)\n\t    assert len(prepared_data) > 0\n\t    for row in prepared_data:\n\t        assert hasattr(row, \"foo\")\n\t        assert getattr(row, \"foo\") in [x.id for x in helper.table_data]\n\t@pytest.mark.django_db\n", "def test_choices__queryset(books_tableselecthelper):\n\t    \"\"\"Check that the helper generates the expected choices tuple in the right order when given a QuerySet.\"\"\"\n\t    helper = books_tableselecthelper()\n\t    assert len(helper.choices) == len(\n\t        helper.table_data\n\t    ), \"No all table data presented as choices\"\n\t    choices = helper.choices\n\t    # The choices should follow the same ordering as the table data. Hence index-based iteration.\n\t    for idx, book in enumerate(helper.table_data):\n\t        assert choices[idx][0] == book.pk\n", "        assert choices[idx][1] == book.title\n\tdef test_choices__dictionaries(books_tableselecthelper):\n\t    \"\"\"Check that the helper generates the expected choices tuple in the right order when given a dictionary.\"\"\"\n\t    helper = books_tableselecthelper(table_data=BOOKS_DICT)\n\t    assert len(helper.choices) == len(\n\t        helper.table_data\n\t    ), \"No all table data presented as choices\"\n\t    choices = helper.choices\n\t    # The choices should follow the same ordering as the table data. Hence index-based iteration.\n\t    for idx, book in enumerate(helper.table_data):\n", "        assert choices[idx][0] == book[\"id\"]\n\t        assert choices[idx][1] == book[\"title\"]\n\tdef test_get_table_extra_columns_respected(books_tableselecthelper):\n\t    \"\"\"Check that the get_table method respects the extra_columns argument.\"\"\"\n\t    helper = books_tableselecthelper(\n\t        table_data=BOOKS_DICT,\n\t        table_kwargs={\"extra_columns\": [(\"date_created\", tables.DateColumn())]},\n\t    )\n\t    table = helper.get_table(input_name=\"foo\", selected_values=[])\n\t    assert \"date_created\" in table.columns\n", "    # It is an extra column, not a base one\n\t    assert \"date_created\" not in table.base_columns\n\tdef test_get_table_kwarg_attrs_respected(books_tableselecthelper):\n\t    \"\"\"Check that the get_table method respects the ``attrs`` key passed to table_kwargs.\"\"\"\n\t    helper = books_tableselecthelper(\n\t        table_data=BOOKS_DICT,\n\t        table_kwargs={\"attrs\": {\"needle\": \"\"}},\n\t    )\n\t    table = helper.get_table(input_name=\"foo\", selected_values=[])\n\t    assert \"needle\" in table.attrs\n", "def test_get_table_meta_attrs_respected(books_tableselecthelper):\n\t    \"\"\"Check that the get_table method respects the attrs Meta attribute.\"\"\"\n\t    class BookTableWithAttrs(BookTable):\n\t        class Meta:\n\t            attrs = {\"needle\": \"\"}\n\t    helper = books_tableselecthelper(\n\t        table_class=BookTableWithAttrs,\n\t        table_data=BOOKS_DICT,\n\t    )\n\t    table = helper.get_table(input_name=\"foo\", selected_values=[])\n", "    assert \"needle\" in table.attrs\n\tdef test_get_table__no_rows_selected(books_tableselecthelper):\n\t    \"\"\"Check that the get_table method returns a table with no checkboxes selected by default.\"\"\"\n\t    helper = books_tableselecthelper(table_data=BOOKS_DICT)\n\t    table = helper.get_table(input_name=\"foo\", selected_values=[])\n\t    for idx in range(len(helper.table_data)):\n\t        # Get the html for the cell\n\t        cell_html = table.rows[idx].get_cell(\"selected_books\")\n\t        # Should NOT contain checked attribute\n\t        assert \"checked\" not in cell_html\n", "def test_get_table__single_row_checked(books_tableselecthelper):\n\t    \"\"\"Check that the get_table method returns a table with the right rows checked when ``selected_values`` is set.\"\"\"\n\t    helper = books_tableselecthelper(table_data=BOOKS_DICT)\n\t    # Select the first row\n\t    selected_values = [str(BOOKS_DICT[0][\"id\"])]\n\t    table = helper.get_table(input_name=\"foo\", selected_values=selected_values)\n\t    cell_html = table.rows[0].get_cell(\"selected_books\")\n\t    # This is the first row and it should be checked.\n\t    # Its value is present in selected_values argument.\n\t    assert \"checked\" in cell_html\n", "    cell_html = table.rows[1].get_cell(\"selected_books\")\n\t    # This is the second row and it should NOT be checked.\n\t    # Its value is NOT present in selected_values argument.\n\t    assert \"checked\" not in cell_html\n\tdef test_table_class_meta_sequence_respected():\n\t    \"\"\"Check that the table class' Meta.sequence property is respected.\"\"\"\n\t    class SequencedBookTable(BookTable):\n\t        class Meta:\n\t            sequence = (\"author\", \"...\")\n\t    expected_sequence = (\"selected_books\", \"author\", \"...\")\n", "    helper = TableSelectHelper(\n\t        column_name=\"selected_books\",\n\t        table_class=SequencedBookTable,\n\t        table_data=[],\n\t        label=\"title\",\n\t    )\n\t    assert expected_sequence == helper._construct_sequence()\n\tdef test_table_class_kwarg_sequence_respected():\n\t    \"\"\"Check that the table class' Meta.sequence property is respected.\"\"\"\n\t    expected_sequence = (\"selected_books\", \"author\", \"...\")\n", "    helper = TableSelectHelper(\n\t        column_name=\"selected_books\",\n\t        table_class=BookTable,\n\t        table_data=[],\n\t        label=\"title\",\n\t        table_kwargs={\"sequence\": (\"author\", \"...\")},\n\t    )\n\t    assert expected_sequence == helper._construct_sequence()\n\t@pytest.mark.parametrize(\n\t    \"selected_values,expect_checked\", [([], False), ([\"1\"], False), ([\"1\", \"2\"], True)]\n", ")\n\tdef test_table_select_all_checkbox_attrs(\n\t    books_tableselecthelper, selected_values, expect_checked\n\t):\n\t    \"\"\"Check that the select_all_checkbox_attrs method only returns 'checked' when all rows are selected.\"\"\"\n\t    data = [{\"id\": 1, \"title\": \"ABC\"}, {\"id\": 2, \"title\": \"DEF\"}]\n\t    helper = books_tableselecthelper(table_data=data, allow_select_all=False)\n\t    # Never return attributes when allow_select_all is False\n\t    helper.get_select_all_checkbox_attrs(selected_values) == {}\n\t    helper = books_tableselecthelper(table_data=data, allow_select_all=True)\n", "    attrs = helper.get_select_all_checkbox_attrs(selected_values)\n\t    # Checked attribute should only be present when we expect it\n\t    assert expect_checked == bool(\"checked\" in attrs)\n"]}
{"filename": "sandbox/settings.py", "chunked_list": ["\"\"\"\n\tDjango settings for sandbox project.\n\tGenerated by 'django-admin startproject' using Django 3.2.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/3.2/topics/settings/\n\tFor the full list of settings and their values, see\n\thttps://docs.djangoproject.com/en/3.2/ref/settings/\n\t\"\"\"\n\tfrom pathlib import Path\n\t# Build paths inside the project like this: BASE_DIR / 'subdir'.\n", "BASE_DIR = Path(__file__).resolve().parent.parent\n\t# Quick-start development settings - unsuitable for production\n\t# See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/\n\t# SECURITY WARNING: keep the secret key used in production secret!\n\tSECRET_KEY = \"django-insecure-lbe!z1hp#*_)0z*x!^^sm7&rznn((^2@pko#z6suoq4(1h#zj=\"\n\t# SECURITY WARNING: don't run with debug turned on in production!\n\tDEBUG = True\n\tALLOWED_HOSTS = []\n\t# Application definition\n\tINSTALLED_APPS = [\n", "    \"django.contrib.admin\",\n\t    \"django.contrib.auth\",\n\t    \"django.contrib.contenttypes\",\n\t    \"django.contrib.sessions\",\n\t    \"django.contrib.messages\",\n\t    \"django.contrib.staticfiles\",\n\t    \"django_tables2\",\n\t    \"crispy_forms\",\n\t    \"crispy_bootstrap5\",\n\t    \"django_crispy_tableselect\",\n", "    \"sandbox\",\n\t]\n\tCRISPY_ALLOWED_TEMPLATE_PACKS = \"bootstrap5\"\n\tCRISPY_TEMPLATE_PACK = \"bootstrap5\"\n\tMIDDLEWARE = [\n\t    \"django.middleware.security.SecurityMiddleware\",\n\t    \"django.contrib.sessions.middleware.SessionMiddleware\",\n\t    \"django.middleware.common.CommonMiddleware\",\n\t    \"django.middleware.csrf.CsrfViewMiddleware\",\n\t    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n", "    \"django.contrib.messages.middleware.MessageMiddleware\",\n\t    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n\t]\n\tROOT_URLCONF = \"sandbox.urls\"\n\tTEMPLATES = [\n\t    {\n\t        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n\t        \"DIRS\": [BASE_DIR / \"sandbox\" / \"templates\"],\n\t        \"APP_DIRS\": True,\n\t        \"OPTIONS\": {\n", "            \"context_processors\": [\n\t                \"django.template.context_processors.debug\",\n\t                \"django.template.context_processors.request\",\n\t                \"django.contrib.auth.context_processors.auth\",\n\t                \"django.contrib.messages.context_processors.messages\",\n\t            ],\n\t        },\n\t    },\n\t]\n\tWSGI_APPLICATION = \"sandbox.wsgi.application\"\n", "# Database\n\t# https://docs.djangoproject.com/en/3.2/ref/settings/#databases\n\tDATABASES = {\n\t    \"default\": {\n\t        \"ENGINE\": \"django.db.backends.sqlite3\",\n\t        \"NAME\": BASE_DIR / \"db.sqlite3\",\n\t    }\n\t}\n\t# Password validation\n\t# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators\n", "AUTH_PASSWORD_VALIDATORS = [\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n\t    },\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n\t    },\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n\t    },\n", "    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n\t    },\n\t]\n\t# Internationalization\n\t# https://docs.djangoproject.com/en/3.2/topics/i18n/\n\tLANGUAGE_CODE = \"en-us\"\n\tTIME_ZONE = \"Europe/Amsterdam\"\n\tUSE_I18N = True\n\tUSE_TZ = True\n", "# Static files (CSS, JavaScript, Images)\n\t# https://docs.djangoproject.com/en/3.2/howto/static-files/\n\tSTATIC_URL = \"/static/\"\n\tSTATICFILES_DIRS = [\n\t    BASE_DIR / \"sandbox\" / \"static\",\n\t]\n\t# Default primary key field type\n\t# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field\n\tDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"\n"]}
{"filename": "sandbox/models.py", "chunked_list": ["from django.db import models\n\tclass Task(models.Model):\n\t    name = models.CharField(\"name\", max_length=50)\n\t    date_added = models.DateTimeField(\"date added\", auto_now_add=True)\n\t    date_completed = models.DateTimeField(\n\t        \"date completed\", null=True, default=None, blank=True\n\t    )\n\t    def __str__(self):\n\t        return self.name\n\tclass Book(models.Model):\n", "    title = models.CharField(max_length=192)\n\t    date_published = models.DateField()\n\t    datetime_created = models.DateTimeField(auto_now_add=True)\n\t    author = models.ForeignKey(\n\t        \"sandbox.Author\", on_delete=models.CASCADE, related_name=\"books\"\n\t    )\n\t    def __str__(self) -> str:\n\t        return self.title\n\tclass Author(models.Model):\n\t    name = models.CharField(max_length=192)\n", "    def __str__(self) -> str:\n\t        return self.name\n"]}
{"filename": "sandbox/forms.py", "chunked_list": ["import datetime\n\tfrom django import forms\n\tfrom django.utils import timezone\n\tfrom django.core.exceptions import ValidationError\n\tfrom crispy_forms.helper import FormHelper\n\tfrom crispy_forms.layout import Layout, Field, Submit\n\tfrom django_crispy_tableselect import TableSelect, TableSelectHelper, CrispyMediaMixin\n\tfrom .tables import TaskTable\n\tclass BulkCompleteTaskForm(CrispyMediaMixin, forms.Form):\n\t    date_completed = forms.DateField(\n", "        required=True,\n\t        initial=timezone.now(),\n\t        help_text=\"Must be a date in the future\",\n\t        widget=forms.widgets.SelectDateWidget()\n\t    )\n\t    select_tasks = forms.fields.MultipleChoiceField(required=True)\n\t    def __init__(self, tasks, *args, **kwargs):\n\t        super().__init__(*args, **kwargs)\n\t        table_helper = TableSelectHelper(\n\t            column_name=\"select_tasks\",\n", "            table_class=TaskTable,\n\t            table_data=tasks,\n\t            allow_select_all=True,\n\t            label=\"name\"\n\t        )\n\t        self.fields[\"select_tasks\"].choices = table_helper.choices\n\t        self.helper = FormHelper()\n\t        self.helper.form_tag = False\n\t        self.helper.layout = Layout(\n\t            Field(\"date_completed\"),\n", "            TableSelect(\"select_tasks\", helper=table_helper),\n\t            Submit(\"submit\", \"Submit\")\n\t        )\n\t    def clean_date_completed(self):\n\t        date_completed = self.cleaned_data.get(\"date_completed\")\n\t        if date_completed < datetime.date.today():\n\t            raise ValidationError(\"Date must be in the future\")\n\t        return date_completed\n"]}
{"filename": "sandbox/factories.py", "chunked_list": ["import factory\n\tfrom . import models\n\tclass AuthorFactory(factory.django.DjangoModelFactory):\n\t    class Meta:\n\t        model = models.Author\n\t    name = factory.Faker(\"name\")\n\tclass BookFactory(factory.django.DjangoModelFactory):\n\t    class Meta:\n\t        model = models.Book\n\t    title = factory.Faker(\"sentence\", nb_words=4)\n", "    date_published = factory.Faker(\"date_this_century\")\n\t    author = factory.SubFactory(AuthorFactory)\n"]}
{"filename": "sandbox/urls.py", "chunked_list": ["from django.conf import settings\n\tfrom django.conf.urls.static import static\n\tfrom django.contrib import admin\n\tfrom django.urls import include, path\n\tfrom django.views.generic import TemplateView\n\tfrom sandbox import views\n\ttasks_urls = ([path(\"table/\", views.TaskTableView.as_view(), name=\"table\"), path(\"bulk/\", views.BulkCompleteTaskView.as_view(), name=\"bulk-complete\")], \"tasks\")\n\turlpatterns = [\n\t    path(\"admin/\", admin.site.urls),\n\t    path(\"tasks/\", include(tasks_urls, namespace=\"tasks\")),\n", "    # path(\"books/\", include(books_urls, namespace=\"books\")),\n\t    path(\"\", TemplateView.as_view(template_name=\"index.html\"), name=\"index\"),\n\t] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)\n"]}
{"filename": "sandbox/views.py", "chunked_list": ["from django_tables2 import SingleTableView\n\tfrom django.urls import reverse_lazy\n\tfrom django.views.generic.list import MultipleObjectMixin\n\tfrom django.http import HttpResponseRedirect\n\tfrom formtools.wizard.views import SessionWizardView\n\tfrom sandbox.models import Task\n\tfrom sandbox.tables import TaskTable\n\tfrom sandbox.forms import BulkCompleteTaskForm\n\tclass TaskTableView(SingleTableView):\n\t    model = Task\n", "    table_class = TaskTable\n\t    template_name = \"task_table_page.html\"\n\tclass BulkCompleteTaskView(MultipleObjectMixin, SessionWizardView):\n\t    form_list = [\n\t        (\"tasks\", BulkCompleteTaskForm)\n\t    ]\n\t    model = Task\n\t    template_name = \"task_bulk_complete_page.html\"\n\t    success_url = reverse_lazy(\"tasks:bulk-complete\")\n\t    def get_form_kwargs(self, step=None):\n", "        kwargs = super().get_form_kwargs()\n\t        kwargs[\"tasks\"] = self.get_queryset()\n\t        return kwargs\n\t    def done(self, form_list, **kwargs):\n\t        data = self.get_all_cleaned_data()\n\t        task_ids = data.get('select_tasks')\n\t        date_completed = data.get('date_completed')\n\t        Task.objects.filter(id__in=task_ids).update(date_completed=date_completed)\n\t        return HttpResponseRedirect(reverse_lazy(\"tasks:bulk-complete\"))\n\t    def dispatch(self, request, *args, **kwargs):\n", "        self.object_list = self.get_queryset()\n\t        return super().dispatch(request, *args, **kwargs)\n"]}
{"filename": "sandbox/__init__.py", "chunked_list": []}
{"filename": "sandbox/tables.py", "chunked_list": ["import django_tables2 as tables\n\tfrom sandbox.models import Task, Book\n\tclass TaskTable(tables.Table):\n\t    date_added = tables.DateColumn(format=\"M d, Y\")\n\t    date_completed = tables.DateColumn(format=\"M d, Y\")\n\t    class Meta:\n\t        model = Task\n\t        fields = (\n\t            \"name\",\n\t            \"date_added\",\n", "        )\n\t        attrs = {\n\t            \"class\": \"my-table\",\n\t        }\n\tclass BookTable(tables.Table):\n\t    class Meta:\n\t        model = Book\n\t        fields = (\"title\", \"author\", \"date_published\")\n"]}
{"filename": "sandbox/asgi.py", "chunked_list": ["\"\"\"\n\tASGI config for sandbox project.\n\tIt exposes the ASGI callable as a module-level variable named ``application``.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/3.2/howto/deployment/asgi/\n\t\"\"\"\n\timport os\n\tfrom django.core.asgi import get_asgi_application\n\tos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"settings\")\n\tapplication = get_asgi_application()\n"]}
{"filename": "sandbox/admin.py", "chunked_list": ["from django.contrib import admin\n\tfrom sandbox.models import Task\n\tclass TaskAdmin(admin.ModelAdmin):\n\t    list_display = (\"name\", \"date_added\")\n\tadmin.site.register(Task, TaskAdmin)\n"]}
{"filename": "sandbox/wsgi.py", "chunked_list": ["\"\"\"\n\tWSGI config for sandbox project.\n\tIt exposes the WSGI callable as a module-level variable named ``application``.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/3.2/howto/deployment/wsgi/\n\t\"\"\"\n\timport os\n\tfrom django.core.wsgi import get_wsgi_application\n\tos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"sandbox.settings\")\n\tapplication = get_wsgi_application()\n"]}
{"filename": "sandbox/migrations/0001_initial.py", "chunked_list": ["# Generated by Django 4.2.1 on 2023-06-05 12:28\n\tfrom django.db import migrations, models\n\timport django.db.models.deletion\n\tclass Migration(migrations.Migration):\n\t    initial = True\n\t    dependencies = []\n\t    operations = [\n\t        migrations.CreateModel(\n\t            name=\"Author\",\n\t            fields=[\n", "                (\n\t                    \"id\",\n\t                    models.BigAutoField(\n\t                        auto_created=True,\n\t                        primary_key=True,\n\t                        serialize=False,\n\t                        verbose_name=\"ID\",\n\t                    ),\n\t                ),\n\t                (\"name\", models.CharField(max_length=192)),\n", "            ],\n\t        ),\n\t        migrations.CreateModel(\n\t            name=\"Task\",\n\t            fields=[\n\t                (\n\t                    \"id\",\n\t                    models.BigAutoField(\n\t                        auto_created=True,\n\t                        primary_key=True,\n", "                        serialize=False,\n\t                        verbose_name=\"ID\",\n\t                    ),\n\t                ),\n\t                (\"name\", models.CharField(max_length=50, verbose_name=\"name\")),\n\t                (\n\t                    \"date_added\",\n\t                    models.DateTimeField(auto_now_add=True, verbose_name=\"date added\"),\n\t                ),\n\t                (\n", "                    \"date_completed\",\n\t                    models.DateTimeField(\n\t                        blank=True,\n\t                        default=None,\n\t                        null=True,\n\t                        verbose_name=\"date completed\",\n\t                    ),\n\t                ),\n\t            ],\n\t        ),\n", "        migrations.CreateModel(\n\t            name=\"Book\",\n\t            fields=[\n\t                (\n\t                    \"id\",\n\t                    models.BigAutoField(\n\t                        auto_created=True,\n\t                        primary_key=True,\n\t                        serialize=False,\n\t                        verbose_name=\"ID\",\n", "                    ),\n\t                ),\n\t                (\"title\", models.CharField(max_length=192)),\n\t                (\"date_published\", models.DateField()),\n\t                (\"datetime_created\", models.DateTimeField(auto_now_add=True)),\n\t                (\n\t                    \"author\",\n\t                    models.ForeignKey(\n\t                        on_delete=django.db.models.deletion.CASCADE,\n\t                        related_name=\"books\",\n", "                        to=\"sandbox.author\",\n\t                    ),\n\t                ),\n\t            ],\n\t        ),\n\t    ]\n"]}
{"filename": "sandbox/migrations/__init__.py", "chunked_list": []}
{"filename": "src/django_crispy_tableselect/columns.py", "chunked_list": ["from __future__ import annotations\n\tfrom typing import TYPE_CHECKING\n\tfrom django.template.loader import get_template\n\tfrom django_tables2 import CheckBoxColumn as BaseCheckBoxColumn\n\tif TYPE_CHECKING:\n\t    from .helpers import TableSelectHelper\n\t__all__ = [\n\t    \"CheckBoxColumn\",\n\t]\n\tclass CheckBoxColumn(BaseCheckBoxColumn):\n", "    header_template = \"django_crispy_tableselect/checkbox_column_header.html\"\n\t    def __init__(\n\t        self,\n\t        helper: TableSelectHelper,\n\t        attrs={},\n\t        input_name=\"\",\n\t        selected_values=[],\n\t        **extra,\n\t    ):\n\t        self.helper = helper\n", "        self.input_name = input_name\n\t        self.selected_values = selected_values\n\t        update_attrs = attrs.copy()\n\t        td_input_attrs = attrs.get(\"td__input\", {})\n\t        th_input_attrs = attrs.get(\"th__input\", {})\n\t        update_attrs[\"td__input\"] = {\n\t            \"name\": input_name,\n\t            \"aria-label\": lambda **kwargs: helper.get_accessible_label(\n\t                kwargs.get(\"record\")\n\t            ),\n", "            **td_input_attrs,\n\t        }\n\t        update_attrs[\"th__input\"] = {\n\t            **self.helper.get_select_all_checkbox_attrs(selected_values),\n\t            **th_input_attrs,\n\t        }\n\t        super().__init__(update_attrs, **extra)\n\t    def is_checked(self, value, record):\n\t        return str(value) in self.selected_values\n\t    @property\n", "    def header(self):\n\t        default = {\"type\": \"checkbox\"}\n\t        general = self.attrs.get(\"input\")\n\t        specific = self.attrs.get(\"th__input\")\n\t        attrs = dict(default, **(specific or general or {}))\n\t        template = get_template(self.header_template)\n\t        return template.render(\n\t            {\"attrs\": attrs, \"enable_select_all\": self.helper.allow_select_all}\n\t        )\n"]}
{"filename": "src/django_crispy_tableselect/mixins.py", "chunked_list": ["class CrispyMediaMixin:\n\t    \"\"\"Mixin that gathers Media objects from Crispy layout objects and includes them in ``self.media``.\"\"\"\n\t    @property\n\t    def media(self):\n\t        media = super().media\n\t        # FIXME: gather media from nested layout objects too!\n\t        for field in self.helper.layout.fields:\n\t            if hasattr(field, \"media\"):\n\t                media += field.media\n\t        return media\n"]}
{"filename": "src/django_crispy_tableselect/__init__.py", "chunked_list": ["from .helpers import TableSelectHelper\n\tfrom .layout import TableSelect\n\tfrom .mixins import CrispyMediaMixin\n\t__all__ = (\"TableSelect\", \"TableSelectHelper\", \"CrispyMediaMixin\")\n"]}
{"filename": "src/django_crispy_tableselect/layout.py", "chunked_list": ["from crispy_forms import layout\n\tfrom crispy_forms.utils import TEMPLATE_PACK\n\tfrom django.template.loader import render_to_string\n\tclass TableSelect(layout.TemplateNameMixin):\n\t    template = \"django_crispy_tableselect/table_select.html\"\n\t    def __init__(\n\t        self,\n\t        name,\n\t        helper,\n\t        **kwargs,\n", "    ):\n\t        self.name = name\n\t        self.helper = helper\n\t    @property\n\t    def media(self):\n\t        # Make the helper media easily available to the form\n\t        return self.helper.media\n\t    def format_value(self, value):\n\t        \"\"\"Return selected values as a list.\"\"\"\n\t        if value is None:\n", "            return []\n\t        if not isinstance(value, (tuple, list)):\n\t            value = [value]\n\t        return [str(v) if v is not None else \"\" for v in value]\n\t    def render(self, form, context, template_pack=TEMPLATE_PACK, **kwargs):\n\t        template = self.get_template_name(template_pack)\n\t        bound_field = form[self.name]\n\t        selected_values = self.format_value(bound_field.value())\n\t        html_name = bound_field.html_name\n\t        context.update(\n", "            {\n\t                \"table\": self.helper.get_table(\n\t                    input_name=html_name, selected_values=selected_values\n\t                )\n\t            }\n\t        )\n\t        return render_to_string(template, context.flatten())\n"]}
{"filename": "src/django_crispy_tableselect/helpers.py", "chunked_list": ["from django.core.exceptions import ImproperlyConfigured\n\tfrom django.db import models\n\tfrom django.forms.widgets import Media\n\tfrom django.utils.translation import gettext_lazy as _\n\tfrom django_tables2 import Table\n\tfrom .columns import CheckBoxColumn\n\tclass TableSelectHelper:\n\t    \"\"\"Helper that houses various features related to TableSelect.\"\"\"\n\t    # Path to javascript static file\n\t    js_path = \"django_crispy_tableselect/tableselect.js\"\n", "    def __init__(\n\t        self,\n\t        column_name,\n\t        table_class,\n\t        table_data,\n\t        label,\n\t        value_field=\"id\",\n\t        *,\n\t        table_kwargs={},\n\t        allow_select_all=False,\n", "    ):\n\t        \"\"\"\n\t        Arguments:\n\t        - column_name: str -- The name of the form field. The checkbox column is added to the table using this name.\n\t        - table_class: Table -- Your table class, must inherit from ``django_tables2.Table``.\n\t        - table_data: QuerySet|Iterable -- Data to use to populate the table. Can be a django QuerySet or an iterable of objects/dictionaries.\n\t        - label: str | callable -- Field (or key in case of dict) to use from table data record to label the checkbox. If callable, it receives the object / dict and should return a string to label to checkbox with.\n\t        - value_field: str -- Field (or key in case of dict) to use from table data record as checkbox value. Defaults to 'id'.\n\t        Keyword arguments:\n\t        - table_kwargs: dict -- Any extra keyword arguments to instantiate the table class with.\n", "        - allow_select_all: bool -- Whether or not to show a 'select all' checkbox in the column header. Defaults to False.\n\t        \"\"\"\n\t        if not issubclass(table_class, Table):\n\t            msg = f\"{repr(table_class)} must be a subclass of {repr(Table)}\"\n\t            raise ImproperlyConfigured(msg)\n\t        self.column_name = column_name\n\t        self.table_class = table_class\n\t        self.table_data = table_data\n\t        self.label = label\n\t        self.value_field = value_field\n", "        self.table_kwargs = table_kwargs\n\t        self.allow_select_all = allow_select_all\n\t    @property\n\t    def choices(self):\n\t        if callable(self.label):\n\t            return [(x[self.value_field], self.label(x)) for x in self.table_data]\n\t        if (\n\t            isinstance(self.table_data, models.query.QuerySet)\n\t            and type(self.label) == str\n\t        ):\n", "            return self.table_data.values_list(self.value_field, self.label)\n\t        return [(x[self.value_field], x[self.label]) for x in self.table_data]\n\t    def get_select_all_checkbox_attrs(self, selected_values):\n\t        \"\"\"Attributes to add to the select all checkbox.\"\"\"\n\t        if not self.allow_select_all:\n\t            return {}\n\t        attrs = {}\n\t        if selected_values:\n\t            if len(selected_values) >= len(self.table_data):\n\t                # All rows are selected, checkbox should display as checked\n", "                attrs[\"checked\"] = \"\"\n\t        return attrs\n\t    def get_accessible_label(self, record):\n\t        \"\"\"Return the accessible label to associate with the form checkbox.\n\t        Uses the value specified by ``label`` as key for dictionaries or as attribute for objects.\n\t        This benefits users of assistive technology like screenreaders.\"\"\"\n\t        if isinstance(record, dict):\n\t            obj_name = record.get(self.label)\n\t        else:\n\t            obj_name = getattr(record, self.label)\n", "        return _(\"Select %(obj_name)s\") % {\"obj_name\": obj_name}\n\t    def get_value(self, record):\n\t        \"\"\"Value to use for the form checkbox.\"\"\"\n\t        if isinstance(record, dict):\n\t            return record.get(self.value_field)\n\t        return vars(record).get(self.value_field)\n\t    def prepare_table_data(self, table_data):\n\t        \"\"\"Prepare table data with values necessary for the select checkbox.\"\"\"\n\t        for row in table_data:\n\t            key = self.column_name\n", "            value = self.get_value(row)\n\t            if isinstance(row, dict):\n\t                row[key] = value\n\t            else:\n\t                setattr(row, key, value)\n\t        return table_data\n\t    def _construct_sequence(self):\n\t        \"\"\"Reconstructs the ``sequence`` argument for the table with the checkbox column in front.\"\"\"\n\t        table_kwargs = self.table_kwargs.copy()\n\t        kwarg_sequence = table_kwargs.pop(\"sequence\", ())\n", "        meta_sequence = ()\n\t        if hasattr(self.table_class, \"Meta\") and hasattr(\n\t            self.table_class.Meta, \"sequence\"\n\t        ):\n\t            meta_sequence = getattr(self.table_class.Meta, \"sequence\")\n\t        original_sequence = kwarg_sequence or meta_sequence\n\t        # Reconstruct the sequence with the checkbox column at the start\n\t        return (self.column_name, *original_sequence)\n\t    def get_attrs(self, kwarg_attrs):\n\t        \"\"\"Get ``attrs`` keyword argument to pass to the table class.\"\"\"\n", "        meta_attrs = ()\n\t        if hasattr(self.table_class, \"Meta\") and hasattr(\n\t            self.table_class.Meta, \"attrs\"\n\t        ):\n\t            meta_attrs = getattr(self.table_class.Meta, \"attrs\")\n\t        original_attrs = kwarg_attrs or meta_attrs\n\t        attrs = {\"data-tableselect\": \"\"}\n\t        attrs.update(original_attrs)\n\t        return attrs\n\t    def get_table(self, input_name, selected_values):\n", "        \"\"\"Return instance of the table class with checkbox column.\"\"\"\n\t        table_kwargs = self.table_kwargs.copy()\n\t        extra_columns = [\n\t            (\n\t                self.column_name,\n\t                CheckBoxColumn(\n\t                    verbose_name=\"\",\n\t                    input_name=input_name,\n\t                    helper=self,\n\t                    selected_values=selected_values,\n", "                ),\n\t            )\n\t        ]\n\t        extra_columns.extend(table_kwargs.pop(\"extra_columns\", []))\n\t        sequence = self._construct_sequence()\n\t        attrs = self.get_attrs(table_kwargs.pop(\"attrs\", {}))\n\t        return self.table_class(\n\t            # This table may never be ordered.\n\t            # We cannot guarantee ordering to work properly while still remembering what checkboxes are checked.\n\t            orderable=False,\n", "            data=self.prepare_table_data(self.table_data),\n\t            sequence=sequence,\n\t            extra_columns=extra_columns,\n\t            attrs=attrs,\n\t            **table_kwargs,\n\t        )\n\t    def _get_media(self):\n\t        return Media(js=[self.js_path])\n\t    media = property(_get_media)\n"]}
