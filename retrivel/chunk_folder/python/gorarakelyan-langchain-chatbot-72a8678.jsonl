{"filename": "chatbot/setup.py", "chunked_list": ["import os\n\tfrom setuptools import setup, find_packages\n\there = os.path.abspath(os.path.dirname(__file__))\n\t# Version\n\tversion_file = os.path.join(here, 'src', 'chatbot', 'VERSION')\n\twith open(version_file) as vf:\n\t    __version__ = vf.read().strip()\n\t# Requirements\n\twith open(os.path.join(here, 'requirements.txt'), 'r') as f:\n\t    requirements = f.read().splitlines()\n", "# Package info\n\tNAME = 'chatbot'\n\tDESCRIPTION = 'LangChain-based ChatBot'\n\tVERSION = __version__\n\tREQUIRES_PYTHON = '>=3.7.0'\n\tsetup(\n\t    name=NAME,\n\t    version=VERSION,\n\t    description=DESCRIPTION,\n\t    python_requires=REQUIRES_PYTHON,\n", "    install_requires=requirements,\n\t    packages=find_packages(\"src\"),\n\t    package_dir={\"\": \"src\"},\n\t    zip_safe=False,\n\t    entry_points={\n\t        'console_scripts': [\n\t            'chatbot=chatbot.cli.cli:entrypoint',\n\t        ],\n\t    },\n\t)\n"]}
{"filename": "chatbot/src/chatbot/__init__.py", "chunked_list": []}
{"filename": "chatbot/src/chatbot/chatbot/chatbot.py", "chunked_list": ["import time\n\tfrom langchain.agents import Tool\n\tfrom langchain.agents import AgentType\n\tfrom langchain.memory import ConversationBufferMemory\n\tfrom langchain.chat_models import ChatOpenAI\n\tfrom langchain.utilities import SerpAPIWrapper\n\tfrom langchain.agents import initialize_agent\n\tfrom aim import Repo\n\tfrom chatbot.chatbot.callback import AimCallbackHandler\n\tfrom chatbot_logger import Experiment, Release\n", "from chatbot.chatbot.utils import (\n\t    get_version,\n\t    get_user,\n\t)\n\tdef chatbot(serpapi_key, openai_key, dev_mode):\n\t    # Configs\n\t    model_name = 'gpt-3.5-turbo'\n\t    username = get_user()\n\t    version = get_version()\n\t    # Init experiment and release\n", "    repo = Repo.default()\n\t    try:\n\t        release = repo.containers(f'c.version == \"{version}\"', Release).first()\n\t    except:\n\t        release = Release()\n\t        release[...] = {\n\t            'version': version,\n\t            'time': time.time(),\n\t        }\n\t    experiment = None\n", "    if dev_mode:\n\t        experiment = Experiment()\n\t        experiment['release'] = release.hash\n\t        experiment['version'] = version\n\t        experiment['started'] = time.time()\n\t    # ChatBot implementation\n\t    memory = ConversationBufferMemory(memory_key=\"chat_history\")\n\t    if experiment is not None:\n\t        experiment['memory'] = memory.__dict__\n\t    search = SerpAPIWrapper(serpapi_api_key=serpapi_key)\n", "    tools = [\n\t        Tool(\n\t            name = \"Search\",\n\t            func=search.run,\n\t            description=\"useful for when you need to answer questions about current events or the current state of the world\"\n\t        ),\n\t    ]\n\t    if experiment is not None:\n\t        experiment['tools'] = [tool.__dict__ for tool in tools]\n\t    llm = ChatOpenAI(temperature=0, openai_api_key=openai_key, model_name=model_name)\n", "    if experiment is not None:\n\t        experiment['llm'] = llm.__dict__\n\t    agent_chain = initialize_agent(\n\t        tools, llm,\n\t        agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,\n\t        verbose=True,\n\t        memory=memory,\n\t        handle_parsing_errors=\"Check your output and make sure it conforms!\"\n\t    )\n\t    if experiment is not None:\n", "        experiment['agent'] = agent_chain.__dict__\n\t    # Init the callback\n\t    aim_cb = AimCallbackHandler(username, dev_mode, experiment)\n\t    aim_cb.session[...] = {\n\t        'chatbot_version': version,\n\t        'model': model_name,\n\t        'username': username,\n\t        'started': time.time(),\n\t        'available_tools': [{ 'name': tool.name, 'description': tool.description } for tool in tools],\n\t        'experiment': experiment.hash if experiment else None,\n", "        'release': release.hash,\n\t    }\n\t    # Run the bot\n\t    while True:\n\t        msg = input('Message:\\n')\n\t        response = agent_chain.run(input=msg, callbacks=[aim_cb])\n\t        # try:\n\t        #     response = agent_chain.run(input=msg, callbacks=[aim_cb])\n\t        # except ValueError as e:\n\t        #     response = str(e)\n", "        #     if not response.startswith(\"Could not parse LLM output: `\"):\n\t        #         raise e\n\t        # response = response.removeprefix(\"Could not parse LLM output: `\").removesuffix(\"`\")\n"]}
{"filename": "chatbot/src/chatbot/chatbot/__init__.py", "chunked_list": ["from chatbot.chatbot.chatbot import chatbot\n"]}
{"filename": "chatbot/src/chatbot/chatbot/utils.py", "chunked_list": ["import os\n\timport random\n\tdef get_version():\n\t    here = os.path.abspath(os.path.dirname(__file__))\n\t    version_file = os.path.join(here, '..', 'VERSION')\n\t    with open(version_file) as vf:\n\t        __version__ = vf.read().strip()\n\t    return __version__\n\tdef get_user():\n\t    usernames = ['JamesThompson', 'LisaHamilton', 'RobertFitzgerald', 'MariaGonzalez', 'DavidMorrison']\n", "    username = random.choice(usernames)\n\t    return username\n"]}
{"filename": "chatbot/src/chatbot/chatbot/callback.py", "chunked_list": ["from copy import deepcopy\n\tfrom typing import Any, Dict, List\n\tfrom langchain.callbacks.base import BaseCallbackHandler\n\tfrom langchain.schema import AgentAction, AgentFinish, LLMResult\n\tfrom aim import Repo\n\tfrom chatbot_logger import (\n\t    Session, SessionDev, SessionProd,\n\t    MessagesSequence, Message,\n\t    UserActivity, UserActions, UserAction,\n\t)\n", "from aimstack.asp import Metric\n\tclass AimCallbackHandler(BaseCallbackHandler):\n\t    def __init__(\n\t            self,\n\t            username,\n\t            dev_mode,\n\t            experiment,\n\t    ) -> None:\n\t        \"\"\"Initialize callback handler.\"\"\"\n\t        super().__init__()\n", "        self.repo = Repo.default()\n\t        self.session = None\n\t        self.messages = None\n\t        self.user_activity = None\n\t        self.user_actions = None\n\t        self.experiment = experiment\n\t        self.username = username\n\t        self.dev_mode = dev_mode\n\t        self.tokens_usage_metric = None\n\t        self.tokens_usage_input = None\n", "        self.tokens_usage_output = None\n\t        self.tokens_usage = None\n\t        self.used_tools = set()\n\t        self.start_inp = None\n\t        self.end_out = None\n\t        self.agent_actions = []\n\t        self.setup()\n\t    def setup(self, **kwargs: Any) -> None:\n\t        if self.session is not None:\n\t            return\n", "        if self.dev_mode:\n\t            self.session = SessionDev()\n\t        else:\n\t            self.session = SessionProd()\n\t        self.messages = MessagesSequence(self.session, name='messages', context={})\n\t        self.tokens_usage_input = Metric(self.session, name='token-usage-input', context={})\n\t        self.tokens_usage_output = Metric(self.session, name='token-usage-output', context={})\n\t        self.tokens_usage = Metric(self.session, name='token-usage', context={})\n\t        for cont in self.repo.containers(None, UserActivity):\n\t            if cont['username'] == self.username:\n", "                ua = cont\n\t                for seq in ua.sequences:\n\t                    user_actions = seq\n\t                    break\n\t                else:\n\t                    user_actions = UserActions(ua, name='user-actions', context={})\n\t                break\n\t        else:\n\t            ua = UserActivity()\n\t            ua['username'] = self.username\n", "            user_actions = UserActions(ua, name='user-actions', context={})\n\t        self.user_activity = ua\n\t        self.user_actions = user_actions\n\t    def on_llm_start(\n\t            self, serialized: Dict[str, Any], prompts: List[str], **kwargs: Any\n\t    ) -> None:\n\t        \"\"\"Run when LLM starts.\"\"\"\n\t        # print('LLM START')\n\t        res = deepcopy(prompts)\n\t        # print(res)\n", "    def on_llm_end(self, response: LLMResult, **kwargs: Any) -> None:\n\t        # print('LLM END')\n\t        result = deepcopy(response)\n\t        # print(result)\n\t        self.tokens_usage_input.track(result.llm_output['token_usage']['prompt_tokens'])\n\t        self.tokens_usage_output.track(result.llm_output['token_usage']['completion_tokens'])\n\t        self.tokens_usage.track(result.llm_output['token_usage']['total_tokens'])\n\t        # generated = [\n\t        #     aim.Text(generation.text)\n\t        #     for generations in result.generations\n", "        #     for generation in generations\n\t        # ]\n\t    def on_chain_start(\n\t            self, serialized: Dict[str, Any], inputs: Dict[str, Any], **kwargs: Any\n\t    ) -> None:\n\t        # print('CHAIN START')\n\t        inputs_res = deepcopy(inputs)\n\t        self.start_inp = inputs_res['input']\n\t        # print(inputs_res)\n\t    def on_chain_end(self, outputs: Dict[str, Any], **kwargs: Any) -> None:\n", "        # print('CHAIN END')\n\t        outputs_res = deepcopy(outputs)\n\t        # print(outputs_res)\n\t    def on_tool_start(\n\t            self, serialized: Dict[str, Any], input_str: str, **kwargs: Any\n\t    ) -> None:\n\t        # print('TOOL START', kwargs)\n\t        # print(input_str)\n\t        self.agent_actions.append({\n\t            'type': 'tool-start',\n", "            'input': input_str,\n\t        })\n\t    def on_tool_end(self, output: str, **kwargs: Any) -> None:\n\t        # print('TOOL END', kwargs)\n\t        # print(output)\n\t        self.agent_actions.append({\n\t            'type': 'tool-end',\n\t            'input': output,\n\t        })\n\t        self.used_tools.add(kwargs.get('name'))\n", "        self.session.used_tools = list(self.used_tools)\n\t    def on_agent_action(self, action: AgentAction, **kwargs: Any) -> Any:\n\t        # print('AGENT ACTION')\n\t        # print(action)\n\t        self.agent_actions.append({\n\t            'type': 'agent-action',\n\t            'tool': action.tool,\n\t            'tool_input': action.tool_input,\n\t        })\n\t    def on_agent_finish(\n", "            self,\n\t            finish: AgentFinish,\n\t            **kwargs: Any,\n\t    ) -> Any:\n\t        \"\"\"Run on agent end.\"\"\"\n\t        # print('AGENT FINISH')\n\t        # print(finish)\n\t        self.end_out = finish.return_values['output']\n\t        self.messages.track(Message(self.start_inp, self.end_out, self.agent_actions))\n\t        self.start_inp = None\n", "        self.end_out = None\n\t        self.agent_actions = []\n"]}
{"filename": "chatbot/src/chatbot/cli/__init__.py", "chunked_list": []}
{"filename": "chatbot/src/chatbot/cli/cli.py", "chunked_list": ["import click\n\timport os\n\tfrom dotenv import dotenv_values\n\tfrom chatbot.chatbot import chatbot\n\t@click.group()\n\tdef entrypoint():\n\t    pass\n\t@entrypoint.command\n\t@click.option('--dev', is_flag=True, default=False)\n\tdef run(dev):\n", "    # Load config\n\t    here = os.path.abspath(os.path.dirname(__file__))\n\t    config_file_path = os.path.abspath(os.path.join(here, '..', '..', '..', '.env'))\n\t    config = dotenv_values(config_file_path)\n\t    # Run the bot\n\t    chatbot(\n\t        serpapi_key=config['serpapi_key'],\n\t        openai_key=config['openai_key'],\n\t        dev_mode=dev\n\t    )\n"]}
{"filename": "chatbot_logger/setup.py", "chunked_list": ["import os\n\tfrom setuptools import setup, find_packages\n\there = os.path.abspath(os.path.dirname(__file__))\n\t# Requirements\n\twith open(os.path.join(here, 'requirements.txt'), 'r') as f:\n\t    requirements = f.read().splitlines()\n\t# Package info\n\tNAME = 'chatbot_logger'\n\tDESCRIPTION = 'A generic logger for chatbots'\n\tVERSION = '0.1.0'\n", "REQUIRES_PYTHON = '>=3.7.0'\n\tsetup(\n\t    name=NAME,\n\t    version=VERSION,\n\t    description=DESCRIPTION,\n\t    python_requires=REQUIRES_PYTHON,\n\t    install_requires=requirements,\n\t    packages=find_packages(\"src\"),\n\t    package_dir={\"\": \"src\"},\n\t    zip_safe=False\n", ")\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/__init__.py", "chunked_list": ["__aim_boards__ = 'boards'\n\tfrom chatbot_logger.logging.chat import *\n\tfrom chatbot_logger.logging.analytics import *\n\t__all__ = [\n\t    'Session', 'SessionProd', 'SessionDev',\n\t    'Experiment', 'Release',\n\t    'MessagesSequence', 'UserActivity', 'UserActions',\n\t]\n\t__aim_types__ = [\n\t    Session, SessionProd, SessionDev,\n", "    Experiment, Release,\n\t    MessagesSequence, UserActivity, UserActions,\n\t]\n\tfor aim_type in __aim_types__:\n\t    setattr(aim_type, '__aim_package__', 'chatbot_logger')\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/analytics.py", "chunked_list": ["from datetime import datetime\n\tfrom collections import Counter\n\tfrom chatbot_logger import UserActivity, SessionProd, UserActions\n\t##################\n\t# Utils\n\t##################\n\tdef get_user(username):\n\t    sessions = UserActivity.filter(f'c.username == \"{username}\"')\n\t    if sessions and len(sessions):\n\t        return sessions[0]\n", "    return None\n\tdef get_users(query = '', param = None):\n\t    sessions = UserActivity.filter(query)\n\t    sessions = sorted(sessions, key=lambda sess: sess['params'].get('username') or '', reverse=False)\n\t    if param is not None:\n\t        return [session.get(param) or session['params'].get(param) for session in sessions]\n\t    return sessions\n\tdef daily_count(unix_time_array):\n\t    # Convert the array to datetime\n\t    datetime_array = [datetime.fromtimestamp(unix_time).date() for unix_time in unix_time_array]\n", "    # Count occurrences per day\n\t    counter = Counter(datetime_array)\n\t    # Build list of tuples for output\n\t    return {\n\t        'date': [date.strftime(\"%Y-%m-%d %H:%M:%S\") for date, count in sorted(counter.items())],\n\t        'count': [count for date, count in sorted(counter.items())],\n\t    }\n\tdef hourly_count(unix_time_array):\n\t    # Convert the array to datetime\n\t    datetime_array = [datetime.fromtimestamp(unix_time).replace(minute=0, second=0) for unix_time in unix_time_array]\n", "    # Count occurrences per hour\n\t    counter = Counter(datetime_array)\n\t    # Build list of tuples for output\n\t    return {\n\t        'date': [date.strftime(\"%Y-%m-%d %H:%M:%S\") for date, count in sorted(counter.items())],\n\t        'count': [count for date, count in sorted(counter.items())],\n\t    }\n\t##################\n\tdef overview(username):\n\t    if not username:\n", "        ui.text('Pick a user')\n\t        return\n\t    user = get_user(username)\n\t    if not user:\n\t        ui.text('User not found')\n\t        return\n\t    ui.header(f'User Activity: \"{user[\"params\"].get(\"username\")}\"')\n\t    # ui.json(user)\n\tdef user_sessions(username):\n\t    user = get_user(username)\n", "    if not user:\n\t        return\n\t    all_user_sessions = SessionProd.filter(f'c.username == \"{username}\"')\n\t    ui.text(f'Sessions count: {len(all_user_sessions)}')\n\t    # ui.json(all_user_sessions)\n\t    timestamps = [session['params'].get('started') or 0 for session in all_user_sessions]\n\t    if not timestamps:\n\t        return\n\t    ui.text('Breakdown by:')\n\t    breakdown_type = ui.toggle_button(left_value='Days', right_value='Hours')\n", "    if breakdown_type == 'Hours':\n\t        data = hourly_count(timestamps)\n\t    else:\n\t        data = daily_count(timestamps)\n\t    ui.text('Visualize via:')\n\t    vis_tye = ui.toggle_button(left_value='Table', right_value='Chart')\n\t    if vis_tye == 'Table':\n\t        ui.table(data)\n\t    else:\n\t        d = []\n", "        for i in zip(data['date'], data['count']):\n\t            d.append({\n\t                'date': i[0],\n\t                'count': i[1],\n\t                'name': str(i[0]),\n\t            })\n\t        ui.bar_chart(data=d, x='date', y='count', color=['name'])\n\t##################\n\t# Page\n\t##################\n", "try:\n\t    username = state['analytics.py']['username']\n\texcept:\n\t    username = ''\n\tusername = ui.select(options=get_users('', 'username'), value=username)\n\toverview(username)\n\tuser_sessions(username)\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/production.py", "chunked_list": ["from datetime import datetime\n\timport json\n\tfrom chatbot_logger import SessionProd, MessagesSequence\n\t##################\n\t# Utils\n\t##################\n\tdef get_sessions(query = '', param = None):\n\t    sessions = SessionProd.filter(query)\n\t    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n\t    if param is not None:\n", "        return [session.get(param) for session in sessions]\n\t    return sessions\n\t##################\n\tdef sessions_overview():\n\t    search = ui.form('Search')\n\t    version = search.text_input('')\n\t    query = ''\n\t    if version:\n\t        query = f'str(c.chatbot_version).startswith(\"{version}\")'\n\t    sessions = get_sessions(query)\n", "    table = ui.table({\n\t        'session': [sess['hash'] for sess in sessions],\n\t        'version': [sess['params'].get('chatbot_version') for sess in sessions],\n\t        'model_name': [sess['params'].get('model') for sess in sessions],\n\t        'available_tools': [(str([tool['name'] for tool in sess['params']['available_tools']])) if sess['params'].get('available_tools') else '-' for sess in sessions],\n\t        'username': [sess['params'].get('username') for sess in sessions],\n\t        'time': [sess['params'].get('started') for sess in sessions],\n\t        'open': [sess['hash'] for sess in sessions],\n\t        'release': [sess['params'].get('chatbot_version') for sess in sessions],\n\t    }, {\n", "        'username': lambda x: x if x is not None else '-',\n\t        'time': lambda x: ui.text(datetime.fromtimestamp(x).strftime(\"%Y-%m-%d %H:%M:%S\") if x is not None else '-'),\n\t        'open': lambda x: ui.board_link('sessions.py', 'Open', state={'session_hash': x}),\n\t        'release': lambda x: ui.board_link('development/release.py', 'Release Page', state={'version': x}),\n\t    })\n\t    if table.focused_row:\n\t        history(table.focused_row['session'], table.focused_row['version'])\n\tdef history(session_hash, version):\n\t    if not session_hash:\n\t        return\n", "    ui.subheader(f'Session \"{session_hash}\"')\n\t    qa_sequences = MessagesSequence.filter(f's.name == \"messages\" and c.hash == \"{session_hash}\"')\n\t    qa_sequence = None\n\t    if qa_sequences and len(qa_sequences):\n\t        qa_sequence = qa_sequences[0]\n\t    if qa_sequence is not None:\n\t        ui.text(f'Session history:')\n\t        values = qa_sequence['values']\n\t        history_table = ui.table({\n\t            'question': [r['question'] for r in values],\n", "            'answer': [r['answer'] for r in values],\n\t            'index': [step for (step, _) in enumerate(values)],\n\t        })\n\t        if history_table.focused_row:\n\t            ui.text('Agent actions:')\n\t            step = history_table.focused_row['index']\n\t            ui.json(values[step])\n\t    else:\n\t        ui.text('No message history')\n\t##################\n", "# Page\n\t##################\n\tui.header('Production Monitoring')\n\tsessions_overview()\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/sessions.py", "chunked_list": ["import json\n\tfrom chatbot_logger import Session, MessagesSequence\n\tfrom asp import Metric\n\t##################\n\t# Utils\n\t##################\n\tdef get_session(session_hash):\n\t    sessions = Session.filter(f'c.hash == \"{session_hash}\"')\n\t    if sessions and len(sessions):\n\t        return sessions[0]\n", "    return None\n\tdef get_sessions(query = '', param = None):\n\t    sessions = Session.filter(query)\n\t    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n\t    if param is not None:\n\t        return [session.get(param) for session in sessions]\n\t    return sessions\n\t##################\n\tdef overview(session_hash):\n\t    if not session_hash:\n", "        ui.text('Pick a session')\n\t        return\n\t    session = get_session(session_hash)\n\t    if session is None:\n\t        ui.text('Session not found')\n\t        return\n\t    ui.header(f'Session \"{session_hash}\"')\n\t    ui.subheader('Overview')\n\t    ui.table({\n\t        'Params': [\n", "            'Model',\n\t            'Used tools',\n\t        ],\n\t        'Values': [\n\t            session['params'].get('model'),\n\t            json.dumps(session['params'].get('used_tools')),\n\t        ],\n\t    })\n\tdef history(session_hash):\n\t    if not session_hash:\n", "        return\n\t    ui.subheader('History')\n\t    qa_sequences = MessagesSequence.filter(f's.name == \"messages\" and c.hash == \"{session_hash}\"')\n\t    qa_sequence = None\n\t    if qa_sequences and len(qa_sequences):\n\t        qa_sequence = qa_sequences[0]\n\t    if qa_sequence is not None:\n\t        values = qa_sequence['values']\n\t        history_table = ui.table({\n\t            'question': [r['question'] for r in values],\n", "            'answer': [r['answer'] for r in values],\n\t            'index': [step for (step, _) in enumerate(values)],\n\t        })\n\t        if history_table.focused_row:\n\t            ui.subheader('Agent actions')\n\t            step = history_table.focused_row['index']\n\t            ui.json(values[step])\n\t    else:\n\t        ui.text('No message history')\n\tdef session_cost(session_hash):\n", "    if not session_hash:\n\t        return\n\t    ui.subheader('Tokens usage')\n\t    # Calculate cost\n\t    metrics = Metric.filter(f'c.hash == \"{session_hash}\"')\n\t    input_tokens = 0\n\t    output_tokens = 0\n\t    for metric in metrics:\n\t        if metric['name'] == 'token-usage-input':\n\t            input_tokens = sum(metric['values'])\n", "        if metric['name'] == 'token-usage-output':\n\t            output_tokens = sum(metric['values'])\n\t    input_price = input_tokens * 0.002 / 1000\n\t    output_price = output_tokens * 0.002 / 1000\n\t    total_price = input_price + output_price\n\t    ui.text(f'Total price: ${total_price}, input tokens: ${input_price}, output tokens: ${output_price}')\n\t    ui.text(f'Total count: {input_tokens+output_tokens}, input count: {input_tokens}, output count: {output_tokens}')\n\t    line_chart = ui.line_chart(metrics, x='steps', y='values')\n\t    line_chart.group('column', ['name'])\n\tdef user_info(session_hash):\n", "    if not session_hash:\n\t        return\n\t    session = get_session(session_hash)\n\t    if session is None:\n\t        return\n\t    ui.subheader('User')\n\t    username = session['params'].get('username')\n\t    if not username:\n\t        ui.text('No associated user')\n\t        return\n", "    ui.text(f'User: {username}')\n\t    ui.board_link('analytics.py', 'User page', state={\n\t        'username': username,\n\t    })\n\t##################\n\t# Page\n\t##################\n\ttry:\n\t    session_hash = state['sessions.py']['session_hash']\n\texcept:\n", "    session_hash = ''\n\tsession_hash = ui.select(options=get_sessions('', 'hash'), value=session_hash)\n\toverview(session_hash)\n\thistory(session_hash)\n\tsession_cost(session_hash)\n\tuser_info(session_hash)\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/_main.py", "chunked_list": ["ui.header('ChatBot Logger')\n\tui.subheader('Production')\n\tui.board_link('production.py', 'Overview')\n\tui.board_link('analytics.py', 'User Page')\n\tui.subheader('Chat')\n\tui.board_link('sessions.py', 'Individual Session')\n\tui.subheader('Development')\n\tui.board_link('development/_main.py', 'Overview')\n\tui.board_link('development/experiment.py', 'Experiments')\n\tui.board_link('development/release.py', 'Releases')\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/development/experiment.py", "chunked_list": ["from datetime import datetime\n\tfrom chatbot_logger import Experiment\n\t##################\n\t# Utils\n\t##################\n\tdef get_experiments(query = '', param = None):\n\t    sessions = Experiment.filter(query)\n\t    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n\t    if param is not None:\n\t        return [session.get(param) for session in sessions]\n", "    return sessions\n\tdef get_experiment(session_hash):\n\t    sessions = Experiment.filter(f'c.hash == \"{session_hash}\"')\n\t    if sessions and len(sessions):\n\t        return sessions[0]\n\t    return None\n\t##################\n\tdef experiment(exp_hash):\n\t    exp = get_experiment(exp_hash)\n\t    if not exp:\n", "        ui.text('Pick an experiment')\n\t        return\n\t    ui.header(f'Experiment \"{exp_hash}\"')\n\t    overview, memory, llm, tools, agent = ui.tabs(['Overview', 'Memory', 'LLM', 'Tools', 'Agent'])\n\t    overview.json({\n\t        'release': exp['params'].get('release'),\n\t        'version': exp['params'].get('version'),\n\t        'started': datetime.fromtimestamp(exp['params'].get('started')).strftime(\"%Y-%m-%d %H:%M:%S\") if exp['params'].get('started') else '-',\n\t    })\n\t    memory.json(exp['params'].get('memory'))\n", "    llm.json(exp['params'].get('llm'))\n\t    tools.json(exp['params'].get('tools'))\n\t    agent.json(exp['params'].get('agent'))\n\t##################\n\t# Page\n\t##################\n\ttry:\n\t    exp_hash = state['development/experiment.py']['experiment_hash']\n\texcept:\n\t    exp_hash = ''\n", "exp_hash = ui.select(options=get_experiments('', 'hash'), value=exp_hash)\n\texperiment(exp_hash)\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/development/release.py", "chunked_list": ["from datetime import datetime\n\tfrom chatbot_logger import Release, Experiment\n\t##################\n\t# Utils\n\t##################\n\tdef get_releases(query = '', param = None):\n\t    sessions = Release.filter(query)\n\t    sessions = sorted(sessions, key=lambda sess: (sess['params'].get('version') or '0.0.0').split('.'), reverse=True)\n\t    if param is not None:\n\t        return [session.get(param) or session['params'].get(param) for session in sessions]\n", "    return sessions\n\tdef get_release(release_version):\n\t    sessions = Release.filter(f'c.version == \"{release_version}\"')\n\t    if sessions and len(sessions):\n\t        return sessions[0]\n\t    return None\n\tdef get_last_experiment(release_version):\n\t    experiments = Experiment.filter(f'c.version == \"{release_version}\"')\n\t    last = None\n\t    for experiment in experiments:\n", "        if last is None or not last['params'].get('started'):\n\t            last = experiment\n\t            continue\n\t        if experiment['params'].get('started') and last['params']['started'] < experiment['params']['started']:\n\t            last = experiment\n\t    return last\n\t##################\n\tdef experiment(release_version):\n\t    if not release_version:\n\t        return\n", "    exp = get_last_experiment(release_version)\n\t    if not exp:\n\t        ui.text('No experiment')\n\t        return\n\t    ui.subheader('Experiment')\n\t    overview, memory, llm, tools, agent = ui.tabs(['Overview', 'Memory', 'LLM', 'Tools', 'Agent'])\n\t    overview.json({\n\t        'release': exp['params'].get('release'),\n\t        'version': exp['params'].get('version'),\n\t        'started': datetime.fromtimestamp(exp['params'].get('started')).strftime(\"%Y-%m-%d %H:%M:%S\") if exp['params'].get('started') else '-',\n", "    })\n\t    memory.json(exp['params'].get('memory'))\n\t    llm.json(exp['params'].get('llm'))\n\t    tools.json(exp['params'].get('tools'))\n\t    agent.json(exp['params'].get('agent'))\n\tdef release(release_version):\n\t    release = get_release(release_version)\n\t    if not release:\n\t        ui.text('Pick a release')\n\t        return\n", "    ui.subheader('Release')\n\t    ui.json(release)\n\t##################\n\t# Page\n\t##################\n\ttry:\n\t    release_version = state['development/release.py']['version']\n\texcept:\n\t    release_version = ''\n\trelease_version = ui.select(options=get_releases('', 'version'), value=release_version)\n", "release(release_version)\n\texperiment(release_version)\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/boards/development/_overview.py", "chunked_list": ["import json\n\tfrom datetime import datetime\n\tfrom chatbot_logger import Experiment, SessionDev, Release\n\t##################\n\t# Utils\n\t##################\n\tdef get_experiment(session_hash):\n\t    sessions = Experiment.filter(f'c.hash == \"{session_hash}\"')\n\t    if sessions and len(sessions):\n\t        return sessions[0]\n", "    return None\n\tdef get_experiments(query = '', param = None):\n\t    sessions = Experiment.filter(query)\n\t    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n\t    if param is not None:\n\t        return [session.get(param) for session in sessions]\n\t    return sessions\n\tdef get_sessions(query = '', param = None):\n\t    sessions = SessionDev.filter(query)\n\t    sessions = sorted(sessions, key=lambda sess: sess['params'].get('started') or 0, reverse=True)\n", "    if param is not None:\n\t        return [session.get(param) for session in sessions]\n\t    return sessions\n\tdef get_releases(query = '', param = None):\n\t    sessions = Release.filter(query)\n\t    sessions = sorted(sessions, key=lambda sess: (sess['params'].get('version') or '0.0.0').split('.'), reverse=True)\n\t    if param is not None:\n\t        return [session.get(param) for session in sessions]\n\t    return sessions\n\t##################\n", "def experiments():\n\t    ui.subheader('Experiments')\n\t    experiments = get_experiments()\n\t    if not experiments or not len(experiments):\n\t        ui.text('No experiments yet')\n\t        return\n\t    table = ui.table({\n\t        'experiment': [sess['hash'] for sess in experiments],\n\t        'version': [sess['params'].get('version') for sess in experiments],\n\t        'time': [sess['params'].get('started') for sess in experiments],\n", "        'open': [sess['hash'] for sess in experiments],\n\t    }, {\n\t        'time': lambda x: ui.text(datetime.fromtimestamp(x).strftime(\"%Y-%m-%d %H:%M:%S\") if x is not None else '-'),\n\t        'open': lambda x: ui.board_link('development/experiment.py', 'Experiment Page', state={'experiment_hash': x}),\n\t    })\n\tdef sessions_overview():\n\t    sessions = get_sessions()\n\t    if not sessions or not len(sessions):\n\t        return\n\t    ui.subheader('Dev Sessions')\n", "    table = ui.table({\n\t        'session': [sess['hash'] for sess in sessions],\n\t        'experiment': [sess['params'].get('experiment') for sess in sessions],\n\t        'version': [sess['params'].get('chatbot_version') for sess in sessions],\n\t        'model_name': [sess['params'].get('model') for sess in sessions],\n\t        'available_tools': [(str([tool['name'] for tool in sess['params']['available_tools']])) if sess['params'].get('available_tools') else '-' for sess in sessions],\n\t        'time': [sess['params'].get('started') for sess in sessions],\n\t        'open': [sess['hash'] for sess in sessions],\n\t        'release': [sess['params'].get('chatbot_version') for sess in sessions],\n\t    }, {\n", "        'time': lambda x: ui.text(datetime.fromtimestamp(x).strftime(\"%Y-%m-%d %H:%M:%S\") if x is not None else '-'),\n\t        'open': lambda x: ui.board_link('sessions.py', 'Open', state={'session_hash': x}),\n\t        'release': lambda x: ui.board_link('development/release.py', 'Release Page', state={'version': x}),\n\t    })\n\tdef releases():\n\t    releases = get_releases()\n\t    if not releases or not len(releases):\n\t        ui.text('No releases')\n\t        return\n\t    ui.subheader('Releases')\n", "    table = ui.table({\n\t        'release': [sess['hash'] for sess in releases],\n\t        'version': [sess['params'].get('version') for sess in releases],\n\t        'time': [sess['params'].get('started') for sess in releases],\n\t        'open': [sess['params'].get('version') for sess in releases],\n\t    }, {\n\t        'time': lambda x: ui.text(datetime.fromtimestamp(x).strftime(\"%Y-%m-%d %H:%M:%S\") if x is not None else '-'),\n\t        'open': lambda x: ui.board_link('development/release.py', 'Open', state={'version': x}),\n\t    })\n\t##################\n", "# Page\n\t##################\n\tui.header('Development')\n\treleases()\n\texperiments()\n\tsessions_overview()\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/logging/analytics.py", "chunked_list": ["from aim import Container, Sequence, Object\n\t@Object.alias('aim_qa_logger.UserAction')\n\tclass UserAction(Object):\n\t    AIM_NAME = 'aim_qa_logger.UserAction'\n\t    def __init__(self, action_type: str):\n\t        super().__init__()\n\t        self.storage['action_type'] = action_type\n\t    @property\n\t    def action_type(self):\n\t        return self.storage['action_type']\n", "class UserActions(Sequence[UserAction]):\n\t    pass\n\tclass UserActivity(Container):\n\t    pass\n"]}
{"filename": "chatbot_logger/src/chatbot_logger/logging/__init__.py", "chunked_list": []}
{"filename": "chatbot_logger/src/chatbot_logger/logging/chat.py", "chunked_list": ["from aim import Container, Sequence, Object\n\t@Object.alias('chatbot_logger.Message')\n\tclass Message(Object):\n\t    AIM_NAME = 'chatbot_logger.Message'\n\t    def __init__(self, question: str, answer: str, steps: list):\n\t        super().__init__()\n\t        self.storage['question'] = question\n\t        self.storage['answer'] = answer\n\t        self.storage['steps'] = steps\n\t    @property\n", "    def question(self):\n\t        return self.storage['question']\n\t    @property\n\t    def answer(self):\n\t        return self.storage['answer']\n\t    @property\n\t    def steps(self):\n\t        return self.storage['steps']\n\t    def __repr__(self):\n\t        return f'Q: \"{self.question}\" \\n A: \"{self.answer}\"'\n", "class MessagesSequence(Sequence[Message]):\n\t    pass\n\tclass Session(Container):\n\t    pass\n\tclass SessionProd(Session):\n\t    pass\n\tclass SessionDev(Session):\n\t    pass\n\tclass Experiment(Container):\n\t    pass\n", "class Release(Container):\n\t    pass\n"]}
