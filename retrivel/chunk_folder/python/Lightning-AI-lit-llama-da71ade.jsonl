{"filename": "setup.py", "chunked_list": ["import os\n\tfrom setuptools import setup, find_packages\n\t_PATH_ROOT = os.path.dirname(__file__)\n\twith open(os.path.join(_PATH_ROOT, \"README.md\"), encoding=\"utf-8\") as fo:\n\t    readme = fo.read()\n\tsetup(\n\t    name='lit-llama',\n\t    version='0.1.0',\n\t    description='Implementation of the LLaMA language model',\n\t    author='Lightning AI',\n", "    url='https://github.com/lightning-AI/lit-llama',\n\t    install_requires=[\n\t        \"torch>=2.0.0\",\n\t        \"lightning @ git+https://github.com/Lightning-AI/lightning@master\",\n\t        \"sentencepiece\",\n\t        \"bitsandbytes\",\n\t    ],\n\t    packages=find_packages(),\n\t    long_description=readme,\n\t    long_description_content_type=\"text/markdown\",\n", ")\n"]}
{"filename": "generate.py", "chunked_list": ["import sys\n\timport time\n\timport warnings\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport lightning as L\n\timport torch\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n", "from lit_llama import LLaMA, Tokenizer\n\tfrom lit_llama.utils import lazy_load, llama_model_lookup, quantization\n\t@torch.no_grad()\n\tdef generate(\n\t    model: LLaMA,\n\t    idx: torch.Tensor,\n\t    max_new_tokens: int,\n\t    *,\n\t    max_seq_length: Optional[int] = None,\n\t    temperature: float = 1.0,\n", "    top_k: Optional[int] = None,\n\t    eos_id: Optional[int] = None,\n\t) -> torch.Tensor:\n\t    \"\"\"Takes a conditioning sequence (prompt) as input and continues to generate as many tokens as requested.\n\t    The implementation of this function is modified from A. Karpathy's nanoGPT.\n\t    Args:\n\t        model: The model to use.\n\t        idx: Tensor of shape (T) with indices of the prompt sequence.\n\t        max_new_tokens: The number of new tokens to generate.\n\t        max_seq_length: The maximum sequence length allowed.\n", "        temperature: Scales the predicted logits by 1 / temperature\n\t        top_k: If specified, only sample among the tokens with the k highest probabilities\n\t        eos_id: If specified, stop generating any more token once the <eos> token is triggered\n\t    \"\"\"\n\t    # create an empty tensor of the expected final shape and fill in the current tokens\n\t    T = idx.size(0)\n\t    T_new = T + max_new_tokens\n\t    if max_seq_length is None:\n\t        max_seq_length = min(T_new, model.config.block_size)\n\t    device, dtype = idx.device, idx.dtype\n", "    # create an empty tensor of the expected final shape and fill in the current tokens\n\t    empty = torch.empty(T_new, dtype=dtype, device=device)\n\t    empty[:T] = idx\n\t    idx = empty\n\t    input_pos = torch.arange(0, T, device=device)\n\t    if idx.device.type == \"xla\":\n\t        import torch_xla.core.xla_model as xm\n\t        xm.mark_step()\n\t    # generate max_new_tokens tokens\n\t    for _ in range(max_new_tokens):\n", "        x = idx.index_select(0, input_pos).view(1, -1)\n\t        # forward\n\t        logits = model(x, max_seq_length, input_pos)\n\t        logits = logits[0, -1] / temperature\n\t        # optionally crop the logits to only the top k options\n\t        if top_k is not None:\n\t            v, _ = torch.topk(logits, min(top_k, logits.size(-1)))\n\t            logits = torch.where(logits < v[[-1]], -float(\"Inf\"), logits)\n\t        probs = torch.nn.functional.softmax(logits, dim=-1)\n\t        idx_next = torch.multinomial(probs, num_samples=1).to(dtype=dtype)\n", "        # advance\n\t        input_pos = input_pos[-1:] + 1\n\t        if idx.device.type == \"xla\":\n\t            xm.mark_step()\n\t        # concatenate the new generation\n\t        idx = idx.index_copy(0, input_pos, idx_next)\n\t        # if <eos> token is triggered, return the output (stop generation)\n\t        if idx_next == eos_id:\n\t            return idx[:input_pos]  # include the EOS token\n\t    return idx\n", "def main(\n\t    prompt: str = \"Hello, my name is\",\n\t    *,\n\t    num_samples: int = 1,\n\t    max_new_tokens: int = 50,\n\t    top_k: int = 200,\n\t    temperature: float = 0.8,\n\t    checkpoint_path: Path = Path(\"checkpoints/lit-llama/7B/lit-llama.pth\"),\n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    quantize: Optional[str] = None,\n", ") -> None:\n\t    \"\"\"Generates text samples based on a pre-trained LLaMA model and tokenizer.\n\t    Args:\n\t        prompt: The prompt string to use for generating the samples.\n\t        num_samples: The number of text samples to generate.\n\t        max_new_tokens: The number of generation steps to take.\n\t        top_k: The number of top most probable tokens to consider in the sampling process.\n\t        temperature: A value controlling the randomness of the sampling process. Higher values result in more random\n\t            samples.\n\t        checkpoint_path: The checkpoint path to load.\n", "        tokenizer_path: The tokenizer path to load.\n\t        quantize: Whether to quantize the model and using which method:\n\t            ``\"llm.int8\"``: LLM.int8() mode,\n\t            ``\"gptq.int4\"``: GPTQ 4-bit mode.\n\t    \"\"\"\n\t    assert checkpoint_path.is_file(), checkpoint_path\n\t    assert tokenizer_path.is_file(), tokenizer_path\n\t    precision = \"bf16-true\" if torch.cuda.is_available() and torch.cuda.is_bf16_supported() else \"32-true\"\n\t    fabric = L.Fabric(devices=1, precision=precision)\n\t    print(\"Loading model ...\", file=sys.stderr)\n", "    t0 = time.time()\n\t    with lazy_load(checkpoint_path) as checkpoint:\n\t        name = llama_model_lookup(checkpoint)\n\t        with fabric.init_module(empty_init=True), quantization(mode=quantize):\n\t            model = LLaMA.from_name(name)\n\t        model.load_state_dict(checkpoint)\n\t    print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n\t    model.eval()\n\t    model = fabric.setup(model)\n\t    tokenizer = Tokenizer(tokenizer_path)\n", "    encoded = tokenizer.encode(prompt, bos=True, eos=False, device=fabric.device)\n\t    prompt_length = encoded.size(0)\n\t    L.seed_everything(1234)\n\t    for i in range(num_samples):\n\t        t0 = time.perf_counter()\n\t        y = generate(model, encoded, max_new_tokens, temperature=temperature, top_k=top_k)\n\t        t = time.perf_counter() - t0\n\t        model.reset_cache()\n\t        print(tokenizer.decode(y))\n\t        tokens_generated = y.size(0) - prompt_length\n", "        print(f\"Time for inference {i + 1}: {t:.02f} sec total, {tokens_generated / t:.02f} tokens/sec\", file=sys.stderr)\n\t    if fabric.device.type == \"cuda\":\n\t        print(f\"Memory used: {torch.cuda.max_memory_reserved() / 1e9:.02f} GB\", file=sys.stderr)\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    warnings.filterwarnings(\n\t        # Triggered internally at ../aten/src/ATen/EmptyTensor.cpp:31\n\t        \"ignore\", \n\t        message=\"ComplexHalf support is experimental and many operators don't support it yet\"\n", "    )\n\t    warnings.filterwarnings(\n\t        # Triggered in bitsandbytes/autograd/_functions.py:298\n\t        \"ignore\", \n\t        message=\"MatMul8bitLt: inputs will be cast from torch.bfloat16 to float16 during quantization\",\n\t    )\n\t    CLI(main)\n"]}
{"filename": "finetune/full.py", "chunked_list": ["\"\"\"\n\tInstruction-tuning on the Alpaca dataset using a regular finetuning procedure (updating all layers).\n\tNote: If you run into a CUDA error \"Expected is_sm80 to be true, but got false\", uncomment the line\n\t`torch.backends.cuda.enable_flash_sdp(False)` in the script below (see https://github.com/Lightning-AI/lit-llama/issues/101).\n\t\"\"\"\n\timport sys\n\tfrom pathlib import Path\n\timport os\n\timport time\n\tfrom functools import partial\n", "import lightning as L\n\tfrom lightning.fabric.strategies import FSDPStrategy\n\timport numpy as np\n\timport torch\n\tfrom torch.distributed.fsdp.wrap import transformer_auto_wrap_policy\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\tfrom generate import generate\n\tfrom lit_llama.model import Block, LLaMA, LLaMAConfig\n", "from lit_llama.tokenizer import Tokenizer\n\tfrom lit_llama.utils import save_model_checkpoint\n\tfrom scripts.prepare_alpaca import generate_prompt\n\tinstruction_tuning = True\n\teval_interval = 1000\n\tsave_interval = 1000\n\teval_iters = 100\n\tlog_interval = 100\n\tdevices = 4\n\t# Hyperparameters\n", "learning_rate = 3e-5\n\tbatch_size = 128 / devices\n\tmicro_batch_size = 4\n\tgradient_accumulation_iters = batch_size // micro_batch_size\n\tassert gradient_accumulation_iters > 0\n\tepoch_size = 50000  # train dataset size\n\tnum_epochs = 5\n\tmax_iters = num_epochs * (epoch_size // micro_batch_size) // devices\n\tweight_decay = 0.0\n\tblock_size = 512\n", "warmup_iters = 100\n\tdef main(\n\t    data_dir: str = \"data/alpaca\",\n\t    pretrained_path: str = \"checkpoints/lit-llama/7B/lit-llama.pth\",\n\t    out_dir: str = \"out/full/alpaca\",\n\t):\n\t    auto_wrap_policy = partial(transformer_auto_wrap_policy, transformer_layer_cls={Block})\n\t    strategy = FSDPStrategy(auto_wrap_policy=auto_wrap_policy, activation_checkpointing=Block, limit_all_gathers=True)\n\t    fabric = L.Fabric(accelerator=\"cuda\", devices=devices, precision=\"bf16-mixed\", strategy=strategy)\n\t    fabric.launch()\n", "    fabric.seed_everything(1337 + fabric.global_rank)\n\t    if fabric.global_rank == 0:\n\t        os.makedirs(out_dir, exist_ok=True)\n\t    train_data, val_data = load_datasets(data_dir=data_dir)\n\t    config = LLaMAConfig.from_name(\"7B\")\n\t    config.block_size = block_size\n\t    checkpoint = torch.load(pretrained_path)\n\t    with fabric.device:\n\t        torch.set_default_tensor_type(torch.HalfTensor)\n\t        model = LLaMA(config).bfloat16()\n", "        torch.set_default_tensor_type(torch.FloatTensor)\n\t        model.load_state_dict(checkpoint, strict=False) \n\t    model = fabric.setup_module(model)\n\t    optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate, foreach=False)\n\t    optimizer = fabric.setup_optimizers(optimizer)\n\t    train(fabric, model, optimizer, train_data, val_data, out_dir)\n\t    # Save the final checkpoint at the end of training\n\t    save_model_checkpoint(fabric, model, os.path.join(out_dir, \"lit-llama-full-finetuned.pth\"))\n\tdef train(\n\t    fabric: L.Fabric,\n", "    model: torch.nn.Module,\n\t    optimizer: torch.optim.Optimizer,\n\t    train_data: np.ndarray,\n\t    val_data: np.ndarray,\n\t    out_dir: str,\n\t) -> None:\n\t    \"\"\"The training loop.\n\t    Loosely based on the nanoGPT implementation: https://github.com/karpathy/nanoGPT.\n\t    \"\"\"\n\t    step_count = 0\n", "    model.train()\n\t    for iter_num in range(max_iters):\n\t        is_accumulating = (iter_num + 1) % gradient_accumulation_iters != 0\n\t        if step_count <= warmup_iters:\n\t            # linear warmup\n\t            lr = learning_rate * step_count / warmup_iters\n\t            for param_group in optimizer.param_groups:\n\t                param_group['lr'] = lr\n\t        t0 = time.time()\n\t        input_ids, targets = get_batch(fabric, train_data)\n", "        with fabric.no_backward_sync(model, enabled=is_accumulating):\n\t            logits = model(input_ids)\n\t            loss = loss_fn(logits, targets)\n\t            fabric.backward(loss / gradient_accumulation_iters)\n\t        if not is_accumulating:\n\t            optimizer.step()\n\t            optimizer.zero_grad()\n\t            step_count += 1\n\t            if step_count % eval_interval == 0:\n\t                val_loss = validate(fabric, model, val_data)\n", "                fabric.print(f\"step {iter_num}: val loss {val_loss:.4f}\")\n\t                fabric.barrier()\n\t            if step_count % save_interval == 0:\n\t                print(f\"Saving weights to {out_dir}\")\n\t                save_model_checkpoint(fabric, model, os.path.join(out_dir, f\"iter-{iter_num:06d}-ckpt.pth\"))\n\t        dt = time.time() - t0\n\t        if iter_num % log_interval == 0:\n\t            fabric.print(f\"iter {iter_num}: loss {loss.item():.4f}, time: {dt*1000:.2f}ms\")\n\tdef generate_response(model, instruction):\n\t    tokenizer = Tokenizer(\"checkpoints/lit-llama/tokenizer.model\")\n", "    sample = {\"instruction\": instruction, \"input\": \"\"}\n\t    prompt = instruction\n\t    if instruction_tuning:\n\t        prompt = generate_prompt(sample)\n\t    encoded = tokenizer.encode(prompt, bos=True, eos=False, device=model.device)\n\t    output = generate(\n\t        model,\n\t        idx=encoded,\n\t        max_seq_length=block_size,\n\t        max_new_tokens=100,\n", "    )\n\t    output = tokenizer.decode(output)\n\t    return output # output.split(\"### Response:\")[1].strip()\n\t@torch.no_grad()\n\tdef validate(fabric: L.Fabric, model: torch.nn.Module, val_data: np.ndarray) -> torch.Tensor:\n\t    fabric.print(\"Validating ...\")\n\t    model.eval()\n\t    losses = torch.zeros(eval_iters)\n\t    for k in range(eval_iters):\n\t        input_ids, targets = get_batch(fabric, val_data)\n", "        logits = model(input_ids)\n\t        loss = loss_fn(logits, targets)\n\t        losses[k] = loss.item()\n\t    out = losses.mean()\n\t    # produce an example:\n\t    instruction = \"Recommend a movie for me to watch during the weekend and explain the reason.\"\n\t    output = generate_response(model, instruction)\n\t    fabric.print(instruction)\n\t    fabric.print(output)\n\t    model.train()\n", "    return out.item()\n\tdef loss_fn(logits, targets):\n\t    # shift the targets such that output n predicts token n+1\n\t    logits = logits[..., :-1, :].contiguous()\n\t    targets = targets[..., 1:].contiguous()\n\t    loss = torch.nn.functional.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\t    return loss\n\tdef get_batch(fabric: L.Fabric, data: list):\n\t    ix = torch.randint(len(data), (micro_batch_size,))\n\t    input_ids = [data[i][\"input_ids\"].type(torch.int64) for i in ix]\n", "    labels = [data[i][\"labels\"].type(torch.int64) for i in ix]\n\t    max_len = max(len(s) for s in input_ids)\n\t    def pad_right(x, pad_id):\n\t        # pad right based on the longest sequence\n\t        n = max_len - len(x)\n\t        return torch.cat((x, torch.full((n,), pad_id, dtype=x.dtype)))\n\t    x = torch.stack([pad_right(x, pad_id=0) for x in input_ids])\n\t    y = torch.stack([pad_right(x, pad_id=-1) for x in labels])\n\t    x, y = fabric.to_device((x.pin_memory(), y.pin_memory()))\n\t    return x, y\n", "def load_datasets(data_dir):\n\t    train_data = torch.load(os.path.join(data_dir, \"train.pt\"))\n\t    val_data = torch.load(os.path.join(data_dir, \"test.pt\"))\n\t    return train_data, val_data\n\tif __name__ == \"__main__\":\n\t    # Uncomment this line if you see an error: \"Expected is_sm80 to be true, but got false\"\n\t    # torch.backends.cuda.enable_flash_sdp(False)\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    from jsonargparse.cli import CLI\n\t    CLI(main)\n"]}
{"filename": "finetune/adapter_v2.py", "chunked_list": ["\"\"\"\n\tInstruction-tuning with LLaMA-Adapter v2 on the Alpaca dataset following the paper\n\tLLaMA-Adapter V2: Parameter-Efficient Visual Instruction Model\n\thttps://arxiv.org/abs/2304.15010\n\tThis script runs on a single GPU by default. You can adjust the `micro_batch_size` to fit your GPU memory.\n\tYou can finetune within 1 hour as done in the original paper using DeepSpeed Zero-2 on 8 A100 GPUs by setting the\n\tdevices variable to `devices = 8` and `micro_batch_size = 8` (or higher).\n\tNote: If you run into a CUDA error \"Expected is_sm80 to be true, but got false\", uncomment the line\n\t`torch.backends.cuda.enable_flash_sdp(False)` in the script below (see https://github.com/Lightning-AI/lit-llama/issues/101).\n\t\"\"\"\n", "import os\n\timport sys\n\timport time\n\tfrom pathlib import Path\n\timport shutil\n\timport lightning as L\n\timport numpy as np\n\timport torch\n\timport torch.nn as nn\n\t# support running without installing as a package\n", "wd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\tfrom generate import generate\n\tfrom lit_llama.adapter import LLaMA, LLaMAConfig\n\tfrom lit_llama.adapter_v2 import (\n\t    mark_only_adapter_v2_as_trainable,\n\t    add_adapter_v2_parameters_to_linear_layers,\n\t    adapter_v2_state_from_state_dict\n\t    )\n\tfrom lit_llama.tokenizer import Tokenizer\n", "from scripts.prepare_alpaca import generate_prompt\n\tfrom lightning.fabric.strategies import DeepSpeedStrategy\n\teval_interval = 600\n\tsave_interval = 1000\n\teval_iters = 100\n\tlog_interval = 1\n\tdevices = 1\n\t# Hyperparameters\n\tlearning_rate = 9e-3\n\tbatch_size = 64 / devices\n", "micro_batch_size = 4\n\tgradient_accumulation_iters = batch_size // micro_batch_size\n\tassert gradient_accumulation_iters > 0\n\tepoch_size = 50000  # train dataset size\n\tnum_epochs = 5\n\tmax_iters = num_epochs * (epoch_size // micro_batch_size) // devices\n\tweight_decay = 0.02\n\tmax_seq_length = 256  # see scripts/prepare_alpaca.py\n\twarmup_iters = 2 * (epoch_size // micro_batch_size) // devices  # 2 epoch\n\tds_config = {\n", "    \"train_micro_batch_size_per_gpu\": micro_batch_size,\n\t    \"gradient_accumulation_steps\": gradient_accumulation_iters,\n\t    \"zero_optimization\": {\"stage\": 2},\n\t}\n\tdef main(\n\t    data_dir: str = \"data/alpaca\", \n\t    pretrained_path: str = \"checkpoints/lit-llama/7B/lit-llama.pth\",\n\t    out_dir: str = \"out/adapter_v2/alpaca\",\n\t):\n\t    fabric = L.Fabric(\n", "        accelerator=\"cuda\",\n\t        devices=1,\n\t        strategy=(DeepSpeedStrategy(config=ds_config) if devices > 1 else \"auto\"),\n\t        precision=\"bf16-true\",\n\t    )\n\t    fabric.launch()\n\t    fabric.seed_everything(1337 + fabric.global_rank)\n\t    if fabric.global_rank == 0:\n\t        os.makedirs(out_dir, exist_ok=True)\n\t    train_data, val_data = load_datasets(data_dir=data_dir)\n", "    config = LLaMAConfig(block_size=max_seq_length)\n\t    if not os.path.isfile(pretrained_path):\n\t        raise FileNotFoundError(\n\t            f\"Can't find the pretrained weights at {pretrained_path}.\"\n\t            \" Please follow the instructions in the README to download them.\"\n\t        )\n\t    checkpoint = torch.load(pretrained_path)\n\t    with fabric.init_module():\n\t        model = LLaMA(config)\n\t        # strict=False because missing keys due to adapter weights not contained in state dict\n", "        model.load_state_dict(checkpoint, strict=False)\n\t    add_adapter_v2_parameters_to_linear_layers(model)\n\t    mark_only_adapter_v2_as_trainable(model)\n\t    num_params = sum([p.numel() for p in model.parameters() if p.requires_grad])\n\t    print(f\"Number of trainable parameters: {num_params}\")\n\t    optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate, weight_decay=weight_decay)\n\t    model, optimizer = fabric.setup(model, optimizer)\n\t    train(fabric, model, optimizer, train_data, val_data, out_dir)\n\t    # Save the final checkpoint at the end of training\n\t    save_model_checkpoint(fabric, model, os.path.join(out_dir, \"lit-llama-adapter-finetuned.pth\"))\n", "def train(\n\t    fabric: L.Fabric,\n\t    model: torch.nn.Module,\n\t    optimizer: torch.optim.Optimizer,\n\t    train_data: np.ndarray,\n\t    val_data: np.ndarray,\n\t    out_dir: str,\n\t) -> None:\n\t    \"\"\"The training loop.\n\t    Loosely based on the nanoGPT implementation: https://github.com/karpathy/nanoGPT.\n", "    \"\"\"\n\t    step_count = 0\n\t    for iter_num in range(max_iters):\n\t        if step_count <= warmup_iters:\n\t            # linear warmup\n\t            lr = learning_rate * step_count / warmup_iters\n\t            for param_group in optimizer.param_groups:\n\t                param_group['lr'] = lr\n\t        t0 = time.time()\n\t        input_ids, targets = get_batch(fabric, train_data)\n", "        with fabric.no_backward_sync(model, enabled=((iter_num + 1) % gradient_accumulation_iters != 0)):\n\t            logits = model(input_ids)\n\t            loss = loss_fn(logits, targets)\n\t            fabric.backward(loss / gradient_accumulation_iters)\n\t        if (iter_num + 1) % gradient_accumulation_iters == 0:\n\t            optimizer.step()\n\t            optimizer.zero_grad()\n\t            step_count += 1\n\t            if step_count % eval_interval == 0:\n\t                val_loss = validate(fabric, model, val_data)\n", "                fabric.print(f\"step {iter_num}: val loss {val_loss:.4f}\")\n\t                fabric.barrier()\n\t            if step_count % save_interval == 0:\n\t                print(f\"Saving adapter weights to {out_dir}\")\n\t                # TODO: Provide a function/script to merge the adapter weights with pretrained weights\n\t                save_model_checkpoint(fabric, model, os.path.join(out_dir, f\"iter-{iter_num:06d}.pth\"))\n\t        dt = time.time() - t0\n\t        if iter_num % log_interval == 0:\n\t            fabric.print(f\"iter {iter_num}: loss {loss.item():.4f}, time: {dt*1000:.2f}ms\")\n\tdef generate_response(model, instruction, input=\"\"):\n", "    tokenizer = Tokenizer(\"checkpoints/lit-llama/tokenizer.model\")\n\t    sample = {\"instruction\": instruction, \"input\": input}\n\t    prompt = generate_prompt(sample)\n\t    encoded = tokenizer.encode(prompt, bos=True, eos=False, device=model.device)\n\t    output = generate(\n\t        model,\n\t        idx=encoded,\n\t        max_seq_length=max_seq_length,\n\t        max_new_tokens=100,\n\t        temperature=0.8,\n", "    )\n\t    output = tokenizer.decode(output)\n\t    return output # output.split(\"### Response:\")[1].strip()\n\t@torch.no_grad()\n\tdef validate(fabric: L.Fabric, model: torch.nn.Module, val_data: np.ndarray) -> torch.Tensor:\n\t    fabric.print(\"Validating ...\")\n\t    model.eval()\n\t    losses = torch.zeros(eval_iters)\n\t    for k in range(eval_iters):\n\t        input_ids, targets = get_batch(fabric, val_data)\n", "        logits = model(input_ids)\n\t        loss = loss_fn(logits, targets)\n\t        losses[k] = loss.item()\n\t    val_loss = losses.mean()\n\t    # produce an example:\n\t    instruction = \"Recommend a movie for me to watch during the weekend and explain the reason.\"\n\t    output = generate_response(model, instruction)\n\t    fabric.print(instruction)\n\t    fabric.print(output)\n\t    model.train()\n", "    return val_loss.item()\n\tdef loss_fn(logits, targets):\n\t    # shift the targets such that output n predicts token n+1\n\t    logits = logits[..., :-1, :].contiguous()\n\t    targets = targets[..., 1:].contiguous()\n\t    loss = torch.nn.functional.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\t    return loss\n\tdef get_batch(fabric: L.Fabric, data: list):\n\t    ix = torch.randint(len(data), (micro_batch_size,))\n\t    input_ids = [data[i][\"input_ids\"].type(torch.int64) for i in ix]\n", "    labels = [data[i][\"labels\"].type(torch.int64) for i in ix]\n\t    max_len = max(len(s) for s in input_ids)\n\t    def pad_right(x, pad_id):\n\t        # pad right based on the longest sequence\n\t        n = max_len - len(x)\n\t        return torch.cat((x, torch.full((n,), pad_id, dtype=x.dtype)))\n\t    x = torch.stack([pad_right(x, pad_id=0) for x in input_ids])\n\t    y = torch.stack([pad_right(x, pad_id=-1) for x in labels])\n\t    x, y = fabric.to_device((x.pin_memory(), y.pin_memory()))\n\t    return x, y\n", "def load_datasets(data_dir):\n\t    train_data = torch.load(os.path.join(data_dir, \"train.pt\"))\n\t    val_data = torch.load(os.path.join(data_dir, \"test.pt\"))\n\t    return train_data, val_data\n\tdef save_model_checkpoint(fabric, model, file_path):\n\t    file_path = Path(file_path)\n\t    if isinstance(fabric.strategy, DeepSpeedStrategy):\n\t        from deepspeed.utils.zero_to_fp32 import get_fp32_state_dict_from_zero_checkpoint\n\t        tmp_path = file_path.with_suffix(\".tmp\")\n\t        fabric.save(tmp_path, {\"model\": model})\n", "        fabric.barrier()\n\t        if fabric.global_rank == 0:\n\t            # Create a consolidated checkpoint with the same name next to the deepspeed checkpoint\n\t            # and only keep the adapter weights\n\t            state_dict = get_fp32_state_dict_from_zero_checkpoint(tmp_path)\n\t            state_dict = adapter_v2_state_from_state_dict(state_dict)\n\t            torch.save(state_dict, file_path)\n\t            shutil.rmtree(tmp_path)\n\t    else:\n\t        state_dict = adapter_v2_state_from_state_dict(model.state_dict())\n", "        if fabric.global_rank == 0:\n\t            torch.save(state_dict, file_path)\n\t        fabric.barrier()\n\tif __name__ == \"__main__\":\n\t    # Uncomment this line if you see an error: \"Expected is_sm80 to be true, but got false\"\n\t    # torch.backends.cuda.enable_flash_sdp(False)\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    from jsonargparse.cli import CLI\n\t    CLI(main)\n"]}
{"filename": "finetune/adapter.py", "chunked_list": ["\"\"\"\n\tInstruction-tuning with LLaMA-Adapter on the Alpaca dataset following the paper\n\tLLaMA-Adapter: Efficient Fine-tuning of Language Models with Zero-init Attention\n\thttps://arxiv.org/abs/2303.16199\n\tThis script runs on a single GPU by default. You can adjust the `micro_batch_size` to fit your GPU memory.\n\tYou can finetune within 1 hour as done in the original paper using DeepSpeed Zero-2 on 8 A100 GPUs by setting the\n\tdevices variable to `devices = 8` and `micro_batch_size = 8` (or higher).\n\tNote: If you run into a CUDA error \"Expected is_sm80 to be true, but got false\", uncomment the line\n\t`torch.backends.cuda.enable_flash_sdp(False)` in the script below (see https://github.com/Lightning-AI/lit-llama/issues/101).\n\t\"\"\"\n", "import os\n\timport sys\n\timport time\n\tfrom pathlib import Path\n\timport shutil\n\timport lightning as L\n\timport numpy as np\n\timport torch\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n", "sys.path.append(str(wd))\n\tfrom generate import generate\n\tfrom lit_llama.adapter import LLaMA, LLaMAConfig, mark_only_adapter_as_trainable, adapter_state_from_state_dict\n\tfrom lit_llama.tokenizer import Tokenizer\n\tfrom scripts.prepare_alpaca import generate_prompt\n\tfrom lightning.fabric.strategies import DeepSpeedStrategy\n\tinstruction_tuning = True\n\teval_interval = 600\n\tsave_interval = 1000\n\teval_iters = 100\n", "log_interval = 1\n\tdevices = 1\n\t# Hyperparameters\n\tlearning_rate = 9e-3\n\tbatch_size = 64 / devices\n\tmicro_batch_size = 4\n\tgradient_accumulation_iters = batch_size // micro_batch_size\n\tassert gradient_accumulation_iters > 0\n\tepoch_size = 50000  # train dataset size\n\tnum_epochs = 5\n", "max_iters = num_epochs * (epoch_size // micro_batch_size) // devices\n\tweight_decay = 0.02\n\tmax_seq_length = 256  # see scripts/prepare_alpaca.py\n\twarmup_iters = 2 * (epoch_size // micro_batch_size) // devices  # 2 epochs\n\tds_config = {\n\t    \"train_micro_batch_size_per_gpu\": micro_batch_size,\n\t    \"gradient_accumulation_steps\": gradient_accumulation_iters,\n\t    \"zero_optimization\": {\"stage\": 2},\n\t}\n\tdef main(\n", "    data_dir: str = \"data/alpaca\", \n\t    pretrained_path: str = \"checkpoints/lit-llama/7B/lit-llama.pth\",\n\t    out_dir: str = \"out/adapter/alpaca\",\n\t):\n\t    fabric = L.Fabric(\n\t        accelerator=\"cuda\", \n\t        devices=devices, \n\t        strategy=(DeepSpeedStrategy(config=ds_config) if devices > 1 else \"auto\"), \n\t        precision=\"bf16-true\",\n\t    )\n", "    fabric.launch()\n\t    fabric.seed_everything(1337 + fabric.global_rank)\n\t    if fabric.global_rank == 0:\n\t        os.makedirs(out_dir, exist_ok=True)\n\t    train_data, val_data = load_datasets(data_dir=data_dir)\n\t    config = LLaMAConfig(block_size=max_seq_length)\n\t    if not os.path.isfile(pretrained_path):\n\t        raise FileNotFoundError(\n\t            f\"Can't find the pretrained weights at {pretrained_path}.\"\n\t            \" Please follow the instructions in the README to download them.\"\n", "        )\n\t    checkpoint = torch.load(pretrained_path)\n\t    with fabric.init_module():\n\t        model = LLaMA(config)\n\t        # strict=False because missing keys due to adapter weights not containted in state dict\n\t        model.load_state_dict(checkpoint, strict=False)\n\t    mark_only_adapter_as_trainable(model)\n\t    num_params = sum([p.numel() for p in model.parameters() if p.requires_grad])\n\t    print(f\"Number of trainable parameters: {num_params}\")\n\t    optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate, weight_decay=weight_decay)\n", "    model, optimizer = fabric.setup(model, optimizer)\n\t    train(fabric, model, optimizer, train_data, val_data, out_dir)\n\t    # Save the final checkpoint at the end of training\n\t    save_model_checkpoint(fabric, model, os.path.join(out_dir, \"lit-llama-adapter-finetuned.pth\"))\n\tdef train(\n\t    fabric: L.Fabric,\n\t    model: torch.nn.Module,\n\t    optimizer: torch.optim.Optimizer,\n\t    train_data: np.ndarray,\n\t    val_data: np.ndarray,\n", "    out_dir: str,\n\t) -> None:\n\t    \"\"\"The training loop.\n\t    Loosely based on the nanoGPT implementation: https://github.com/karpathy/nanoGPT.\n\t    \"\"\"\n\t    step_count = 0\n\t    for iter_num in range(max_iters):\n\t        if step_count <= warmup_iters:\n\t            # linear warmup\n\t            lr = learning_rate * step_count / warmup_iters\n", "            for param_group in optimizer.param_groups:\n\t                param_group['lr'] = lr\n\t        t0 = time.time()\n\t        input_ids, targets = get_batch(fabric, train_data)\n\t        with fabric.no_backward_sync(model, enabled=((iter_num + 1) % gradient_accumulation_iters != 0)):\n\t            logits = model(input_ids)\n\t            loss = loss_fn(logits, targets)\n\t            fabric.backward(loss / gradient_accumulation_iters)\n\t        if (iter_num + 1) % gradient_accumulation_iters == 0:\n\t            optimizer.step()\n", "            optimizer.zero_grad()\n\t            step_count += 1\n\t            if step_count % eval_interval == 0:\n\t                val_loss = validate(fabric, model, val_data)\n\t                fabric.print(f\"step {iter_num}: val loss {val_loss:.4f}\")\n\t                fabric.barrier()\n\t            if step_count % save_interval == 0:\n\t                print(f\"Saving adapter weights to {out_dir}\")\n\t                # TODO: Provide a function/script to merge the adapter weights with pretrained weights\n\t                save_model_checkpoint(fabric, model, os.path.join(out_dir, f\"iter-{iter_num:06d}.pth\"))\n", "        dt = time.time() - t0\n\t        if iter_num % log_interval == 0:\n\t            fabric.print(f\"iter {iter_num}: loss {loss.item():.4f}, time: {dt*1000:.2f}ms\")\n\tdef generate_response(model, instruction, input=\"\"):\n\t    tokenizer = Tokenizer(\"checkpoints/lit-llama/tokenizer.model\")\n\t    sample = {\"instruction\": instruction, \"input\": input}\n\t    prompt = instruction\n\t    if instruction_tuning:\n\t        prompt = generate_prompt(sample)\n\t    encoded = tokenizer.encode(prompt, bos=True, eos=False, device=model.device)\n", "    output = generate(\n\t        model,\n\t        idx=encoded,\n\t        max_seq_length=max_seq_length,\n\t        max_new_tokens=100,\n\t        temperature=0.8,\n\t    )\n\t    output = tokenizer.decode(output)\n\t    return output # output.split(\"### Response:\")[1].strip()\n\t@torch.no_grad()\n", "def validate(fabric: L.Fabric, model: torch.nn.Module, val_data: np.ndarray) -> torch.Tensor:\n\t    fabric.print(\"Validating ...\")\n\t    model.eval()\n\t    losses = torch.zeros(eval_iters)\n\t    for k in range(eval_iters):\n\t        input_ids, targets = get_batch(fabric, val_data)\n\t        logits = model(input_ids)\n\t        loss = loss_fn(logits, targets)\n\t        losses[k] = loss.item()\n\t    val_loss = losses.mean()\n", "    # produce an example:\n\t    instruction = \"Recommend a movie for me to watch during the weekend and explain the reason.\"\n\t    output = generate_response(model, instruction)\n\t    fabric.print(instruction)\n\t    fabric.print(output)\n\t    model.train()\n\t    return val_loss.item()\n\tdef loss_fn(logits, targets):\n\t    # shift the targets such that output n predicts token n+1\n\t    logits = logits[..., :-1, :].contiguous()\n", "    targets = targets[..., 1:].contiguous()\n\t    loss = torch.nn.functional.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\t    return loss\n\tdef get_batch(fabric: L.Fabric, data: list):\n\t    ix = torch.randint(len(data), (micro_batch_size,))\n\t    input_ids = [data[i][\"input_ids\"].type(torch.int64) for i in ix]\n\t    labels = [data[i][\"labels\"].type(torch.int64) for i in ix]\n\t    max_len = max(len(s) for s in input_ids)\n\t    def pad_right(x, pad_id):\n\t        # pad right based on the longest sequence\n", "        n = max_len - len(x)\n\t        return torch.cat((x, torch.full((n,), pad_id, dtype=x.dtype)))\n\t    x = torch.stack([pad_right(x, pad_id=0) for x in input_ids])\n\t    y = torch.stack([pad_right(x, pad_id=-1) for x in labels])\n\t    x, y = fabric.to_device((x.pin_memory(), y.pin_memory()))\n\t    return x, y\n\tdef load_datasets(data_dir):\n\t    train_data = torch.load(os.path.join(data_dir, \"train.pt\"))\n\t    val_data = torch.load(os.path.join(data_dir, \"test.pt\"))\n\t    return train_data, val_data\n", "def save_model_checkpoint(fabric, model, file_path):\n\t    file_path = Path(file_path)\n\t    if isinstance(fabric.strategy, DeepSpeedStrategy):\n\t        from deepspeed.utils.zero_to_fp32 import get_fp32_state_dict_from_zero_checkpoint\n\t        tmp_path = file_path.with_suffix(\".tmp\")\n\t        fabric.save(tmp_path, {\"model\": model})\n\t        fabric.barrier()\n\t        if fabric.global_rank == 0:\n\t            # Create a consolidated checkpoint with the same name next to the deepspeed checkpoint\n\t            # and only keep the adapter weights\n", "            state_dict = get_fp32_state_dict_from_zero_checkpoint(tmp_path)\n\t            state_dict = adapter_state_from_state_dict(state_dict)\n\t            torch.save(state_dict, file_path)\n\t            shutil.rmtree(tmp_path)\n\t    else:\n\t        state_dict = adapter_state_from_state_dict(model.state_dict())\n\t        if fabric.global_rank == 0:\n\t            torch.save(state_dict, file_path)\n\t        fabric.barrier()\n\tif __name__ == \"__main__\":\n", "    # Uncomment this line if you see an error: \"Expected is_sm80 to be true, but got false\"\n\t    # torch.backends.cuda.enable_flash_sdp(False)\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    from jsonargparse.cli import CLI\n\t    CLI(main)\n"]}
{"filename": "finetune/lora.py", "chunked_list": ["\"\"\"\n\tInstruction-tuning with LoRA on the Alpaca dataset.\n\tNote: If you run into a CUDA error \"Expected is_sm80 to be true, but got false\", uncomment the line\n\t`torch.backends.cuda.enable_flash_sdp(False)` in the script below (see https://github.com/Lightning-AI/lit-llama/issues/101).\n\t\"\"\"\n\timport sys\n\tfrom pathlib import Path\n\timport os\n\timport time\n\timport lightning as L\n", "import numpy as np\n\timport torch\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\tfrom generate import generate\n\tfrom lit_llama.lora import mark_only_lora_as_trainable, lora, lora_state_dict\n\tfrom lit_llama.model import LLaMA, LLaMAConfig\n\tfrom lit_llama.tokenizer import Tokenizer\n\tfrom scripts.prepare_alpaca import generate_prompt\n", "instruction_tuning = True\n\teval_interval = 100\n\tsave_interval = 100\n\teval_iters = 100\n\tlog_interval = 1\n\t# Hyperparameters\n\tlearning_rate = 3e-4\n\tbatch_size = 128\n\tmicro_batch_size = 4\n\tgradient_accumulation_iters = batch_size // micro_batch_size\n", "assert gradient_accumulation_iters > 0\n\tmax_iters = 50000 * 3 // micro_batch_size\n\tweight_decay = 0.0\n\tmax_seq_length = 256  # see scripts/prepare_alpaca.py\n\tlora_r = 8\n\tlora_alpha = 16\n\tlora_dropout = 0.05\n\twarmup_iters = 100\n\tdef main(\n\t    data_dir: str = \"data/alpaca\", \n", "    pretrained_path: str = \"checkpoints/lit-llama/7B/lit-llama.pth\",\n\t    tokenizer_path: str = \"checkpoints/lit-llama/tokenizer.model\",\n\t    out_dir: str = \"out/lora/alpaca\",\n\t):\n\t    fabric = L.Fabric(accelerator=\"cuda\", devices=1, precision=\"bf16-true\")\n\t    fabric.launch()\n\t    fabric.seed_everything(1337 + fabric.global_rank)\n\t    if fabric.global_rank == 0:\n\t        os.makedirs(out_dir, exist_ok=True)\n\t    train_data, val_data = load_datasets(data_dir=data_dir)\n", "    config = LLaMAConfig.from_name(\"7B\")\n\t    config.block_size = max_seq_length\n\t    checkpoint = torch.load(pretrained_path)\n\t    with fabric.init_module(), lora(r=lora_r, alpha=lora_alpha, dropout=lora_dropout, enabled=True):\n\t        model = LLaMA(config)\n\t        # strict=False because missing keys due to LoRA weights not contained in checkpoint state\n\t        model.load_state_dict(checkpoint, strict=False)\n\t    mark_only_lora_as_trainable(model)\n\t    optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate)\n\t    model, optimizer = fabric.setup(model, optimizer)\n", "    train(fabric, model, optimizer, train_data, val_data, tokenizer_path, out_dir)\n\t    # Save the final LoRA checkpoint at the end of training\n\t    checkpoint = lora_state_dict(model)\n\t    fabric.save(os.path.join(out_dir, \"lit-llama-lora-finetuned.pth\"), checkpoint)\n\tdef train(\n\t    fabric: L.Fabric,\n\t    model: torch.nn.Module,\n\t    optimizer: torch.optim.Optimizer,\n\t    train_data: np.ndarray,\n\t    val_data: np.ndarray,\n", "    tokenizer_path: str,\n\t    out_dir: str,\n\t) -> None:\n\t    \"\"\"The training loop.\n\t    Loosely based on the nanoGPT implementation: https://github.com/karpathy/nanoGPT.\n\t    \"\"\"\n\t    step_count = 0\n\t    for iter_num in range(max_iters):\n\t        if step_count <= warmup_iters:\n\t            # linear warmup\n", "            lr = learning_rate * step_count / warmup_iters\n\t            for param_group in optimizer.param_groups:\n\t                param_group['lr'] = lr\n\t        t0 = time.time()\n\t        input_ids, targets = get_batch(fabric, train_data)\n\t        with fabric.no_backward_sync(model, enabled=((iter_num + 1) % gradient_accumulation_iters != 0)):\n\t            logits = model(input_ids)\n\t            loss = loss_fn(logits, targets)\n\t            fabric.backward(loss / gradient_accumulation_iters)\n\t        if (iter_num + 1) % gradient_accumulation_iters == 0:\n", "            optimizer.step()\n\t            optimizer.zero_grad()\n\t            step_count += 1\n\t            if step_count % eval_interval == 0:\n\t                val_loss = validate(fabric, model, val_data, tokenizer_path)\n\t                fabric.print(f\"step {iter_num}: val loss {val_loss:.4f}\")\n\t                fabric.barrier()\n\t            if step_count % save_interval == 0:\n\t                print(f\"Saving LoRA weights to {out_dir}\")\n\t                # We are only saving the LoRA weights\n", "                # TODO: Provide a function/script to merge the LoRA weights with pretrained weights\n\t                checkpoint = lora_state_dict(model)\n\t                fabric.save(os.path.join(out_dir, f\"iter-{iter_num:06d}-ckpt.pth\"), checkpoint)\n\t        dt = time.time() - t0\n\t        if iter_num % log_interval == 0:\n\t            fabric.print(f\"iter {iter_num}: loss {loss.item():.4f}, time: {dt*1000:.2f}ms\")\n\tdef generate_response(model, instruction, tokenizer_path):\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    sample = {\"instruction\": instruction, \"input\": \"\"}\n\t    prompt = instruction\n", "    if instruction_tuning:\n\t        prompt = generate_prompt(sample)\n\t    encoded = tokenizer.encode(prompt, bos=True, eos=False, device=model.device)\n\t    output = generate(\n\t        model,\n\t        idx=encoded,\n\t        max_seq_length=max_seq_length,\n\t        max_new_tokens=100,\n\t    )\n\t    output = tokenizer.decode(output)\n", "    return output # output.split(\"### Response:\")[1].strip()\n\t@torch.no_grad()\n\tdef validate(fabric: L.Fabric, model: torch.nn.Module, val_data: np.ndarray, tokenizer_path: str) -> torch.Tensor:\n\t    fabric.print(\"Validating ...\")\n\t    model.eval()\n\t    losses = torch.zeros(eval_iters)\n\t    for k in range(eval_iters):\n\t        input_ids, targets = get_batch(fabric, val_data)\n\t        logits = model(input_ids)\n\t        loss = loss_fn(logits, targets)\n", "        losses[k] = loss.item()\n\t    out = losses.mean()\n\t    # produce an example:\n\t    instruction = \"Recommend a movie for me to watch during the weekend and explain the reason.\"\n\t    output = generate_response(model, instruction, tokenizer_path)\n\t    fabric.print(instruction)\n\t    fabric.print(output)\n\t    model.train()\n\t    return out.item()\n\tdef loss_fn(logits, targets):\n", "    # shift the targets such that output n predicts token n+1\n\t    logits = logits[..., :-1, :].contiguous()\n\t    targets = targets[..., 1:].contiguous()\n\t    loss = torch.nn.functional.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\t    return loss\n\tdef get_batch(fabric: L.Fabric, data: list):\n\t    ix = torch.randint(len(data), (micro_batch_size,))\n\t    input_ids = [data[i][\"input_ids\"].type(torch.int64) for i in ix]\n\t    labels = [data[i][\"labels\"].type(torch.int64) for i in ix]\n\t    max_len = max(len(s) for s in input_ids)\n", "    def pad_right(x, pad_id):\n\t        # pad right based on the longest sequence\n\t        n = max_len - len(x)\n\t        return torch.cat((x, torch.full((n,), pad_id, dtype=x.dtype)))\n\t    x = torch.stack([pad_right(x, pad_id=0) for x in input_ids])\n\t    y = torch.stack([pad_right(x, pad_id=-1) for x in labels])\n\t    x, y = fabric.to_device((x.pin_memory(), y.pin_memory()))\n\t    return x, y\n\tdef load_datasets(data_dir):\n\t    train_data = torch.load(os.path.join(data_dir, \"train.pt\"))\n", "    val_data = torch.load(os.path.join(data_dir, \"test.pt\"))\n\t    return train_data, val_data\n\tif __name__ == \"__main__\":\n\t    # Uncomment this line if you see an error: \"Expected is_sm80 to be true, but got false\"\n\t    # torch.backends.cuda.enable_flash_sdp(False)\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    from jsonargparse.cli import CLI\n\t    CLI(main)\n"]}
{"filename": "pretrain/redpajama.py", "chunked_list": ["import os\n\timport sys\n\timport math\n\timport glob\n\timport time\n\tfrom functools import partial\n\tfrom pathlib import Path\n\tfrom typing import Tuple, Optional\n\timport lightning as L\n\tfrom lightning.fabric.strategies import FSDPStrategy\n", "import torch\n\tfrom torch.utils.data import DataLoader\n\tfrom torch.distributed.fsdp.wrap import transformer_auto_wrap_policy\n\timport numpy as np\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\tfrom lit_llama.model import Block, LLaMA, LLaMAConfig\n\tfrom lit_llama.packed_dataset import PackedDataset, CombinedDataset\n\tfrom lit_llama.utils import save_model_checkpoint\n", "out_dir = \"out/training\"\n\tsave_interval = 1000\n\teval_interval = 1000\n\teval_iters = 100\n\tlog_interval = 1\n\t# compile = False\n\t# Hyperparameters\n\tlearning_rate = 6e-4\n\tbatch_size = 125\n\tmicro_batch_size = 5\n", "max_iters = 600000  # num_epochs * (epoch_size // micro_batch_size) // devices\n\tweight_decay = 1e-1\n\tbeta1 = 0.9\n\tbeta2 = 0.95\n\tgrad_clip = 1.0\n\tdecay_lr = True\n\twarmup_iters = 2000\n\tlr_decay_iters = max_iters\n\tmin_lr = 6e-5\n\t# Data proportions from https://arxiv.org/pdf/2302.13971.pdf Table 1\n", "data_config = [\n\t    (\"arxiv\", 2.5),\n\t    (\"book\", 4.5),\n\t    (\"c4\", 15.0),\n\t    (\"cc\", 67.0),\n\t    (\"github\", 4.5),\n\t    (\"stackexchange\", 2.0),\n\t    (\"wikipedia\", 4.5),\n\t]\n\tdef main(\n", "    devices: int = 4,\n\t    train_data_dir: Path = \"data/lit-redpajama\",\n\t    val_data_dir: Optional[Path] = None,\n\t) -> None:\n\t    auto_wrap_policy = partial(\n\t        transformer_auto_wrap_policy, transformer_layer_cls={Block}\n\t    )\n\t    strategy = FSDPStrategy(\n\t        auto_wrap_policy=auto_wrap_policy, activation_checkpointing=Block, limit_all_gathers=True\n\t    )\n", "    fabric = L.Fabric(\n\t        accelerator=\"cuda\", devices=devices, precision=\"bf16-mixed\", strategy=strategy\n\t    )\n\t    fabric.launch()\n\t    fabric.seed_everything(1337)\n\t    if fabric.global_rank == 0:\n\t        os.makedirs(out_dir, exist_ok=True)\n\t    config = LLaMAConfig.from_name(\"7B\")\n\t    train_dataloader, val_dataloader = create_dataloaders(\n\t        batch_size=micro_batch_size,\n", "        block_size=config.block_size,\n\t        fabric=fabric,\n\t        train_data_dir=train_data_dir,\n\t        val_data_dir=val_data_dir,\n\t        seed=1338,\n\t    )\n\t    if val_dataloader is None:\n\t        train_dataloader = fabric.setup_dataloaders(train_dataloader)\n\t    else:\n\t        train_dataloader, val_dataloader = fabric.setup_dataloaders(train_dataloader, val_dataloader)\n", "    with fabric.device:\n\t        torch.set_default_dtype(torch.bfloat16)\n\t        model = LLaMA(config)\n\t        model.apply(model._init_weights)\n\t        torch.set_default_dtype(torch.float32)\n\t    # if compile:\n\t    #     model = torch.compile(model)\n\t    optimizer = torch.optim.AdamW(\n\t        model.parameters(),\n\t        lr=learning_rate,\n", "        weight_decay=weight_decay,\n\t        betas=(beta1, beta2),\n\t        foreach=False,\n\t    )\n\t    model, optimizer = fabric.setup(model, optimizer)\n\t    process_batch_size = batch_size // devices\n\t    gradient_accumulation_iters = process_batch_size // micro_batch_size\n\t    train(fabric, model, optimizer, train_dataloader, val_dataloader, gradient_accumulation_iters, devices)\n\tdef train(\n\t    fabric: L.Fabric,\n", "    model: torch.nn.Module,\n\t    optimizer: torch.optim.Optimizer,\n\t    train_dataloader: DataLoader,\n\t    val_dataloader: Optional[DataLoader],\n\t    grad_accum_steps: int,\n\t    devices: int,\n\t) -> None:\n\t    \"\"\"The training loop.\n\t    Loosely based on the nanoGPT implementation: https://github.com/karpathy/nanoGPT.\n\t    \"\"\"\n", "    step_count = 0\n\t    step_time = 0.0\n\t    tokens = 0\n\t    tokens_sec = 0.0\n\t    prev_t1 = time.time()\n\t    for iter_num, train_data in enumerate(train_dataloader):\n\t        t0 = time.time()\n\t        # determine and set the learning rate for this iteration\n\t        lr = get_lr(iter_num) if decay_lr else learning_rate\n\t        for param_group in optimizer.param_groups:\n", "            param_group[\"lr\"] = lr\n\t        input_ids = train_data[:, 0 : model.config.block_size].contiguous()\n\t        targets = train_data[:, 1 : model.config.block_size + 1].contiguous()\n\t        is_accumulating = (iter_num + 1) % grad_accum_steps != 0\n\t        with fabric.no_backward_sync(model, enabled=is_accumulating):\n\t            logits = model(input_ids)\n\t            loss = torch.nn.functional.cross_entropy(\n\t                logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1\n\t            )\n\t            fabric.backward(loss / grad_accum_steps)\n", "        t1 = time.time()\n\t        if not is_accumulating:\n\t            fabric.clip_gradients(model, optimizer, max_norm=grad_clip)\n\t            optimizer.step()\n\t            optimizer.zero_grad()\n\t            step_count += 1\n\t            t1 = time.time()\n\t            if val_dataloader is not None and step_count % eval_interval == 0:\n\t                val_loss = validate(fabric, model, val_dataloader)\n\t                fabric.print(f\"step {iter_num}: val loss {val_loss:.4f}\")\n", "                fabric.barrier()\n\t                fabric.log_dict(\n\t                    {\"iter\": iter_num, \"val_loss\": val_loss, \"step\": step_count, \"lr\": lr}\n\t                )\n\t            if step_count % save_interval == 0:\n\t                fabric.print(f\"Saving checkpoint to {out_dir}\")\n\t                save_model_checkpoint(\n\t                    fabric, model, os.path.join(out_dir, f\"iter-{iter_num:06d}-ckpt.pth\")\n\t                )\n\t        dt = t1 - t0\n", "        tokens += micro_batch_size * model.config.block_size\n\t        step_time += t1 - prev_t1\n\t        prev_t1 = t1\n\t        if iter_num % log_interval == 0:\n\t            tokens_sec_str = f\"{tokens / step_time:.0f}\" if not is_accumulating else \"-\"\n\t            fabric.log_dict(\n\t                {\"iter\": iter_num, \"train_loss\": loss, \"step\": step_count, \"lr\": lr}\n\t            )\n\t            fabric.print(\n\t                    f\"iter {iter_num}: loss {loss.item():.4f}, time: {dt*1000:.2f}ms, speed: {tokens_sec_str} toks/s/device\"\n", "            )\n\t        if not is_accumulating:\n\t            tokens = 0\n\t            step_time = 0.0\n\t        if iter_num > max_iters:\n\t            break\n\t@torch.no_grad()\n\tdef validate(\n\t    fabric: L.Fabric, model: torch.nn.Module, val_dataloader: DataLoader\n\t) -> torch.Tensor:\n", "    fabric.print(\"Validating ...\")\n\t    model.eval()\n\t    losses = torch.zeros(eval_iters)\n\t    for k, val_data in enumerate(val_dataloader):\n\t        input_ids = val_data[:, 0 : model.config.block_size].contiguous()\n\t        targets = val_data[:, 1 : model.config.block_size + 1].contiguous()\n\t        logits = model(input_ids)\n\t        loss = torch.nn.functional.cross_entropy(\n\t            logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1\n\t        )\n", "        losses[k] = loss.item()\n\t    out = losses.mean()\n\t    model.train()\n\t    return out\n\tdef create_dataloader(\n\t    batch_size: int,\n\t    block_size: int,\n\t    data_dir: str,\n\t    fabric,\n\t    shuffle: bool = True,\n", "    seed: int = 12345,\n\t) -> DataLoader:\n\t    datasets = []\n\t    for prefix, _ in data_config:\n\t        filenames = glob.glob(os.path.join(data_dir, prefix + \"*\"))\n\t        dataset = PackedDataset(\n\t            filenames, n_chunks=4, block_size=block_size, shuffle=shuffle, seed=seed,\n\t            num_processes=fabric.world_size, process_rank=fabric.global_rank,\n\t        )\n\t        datasets.append(dataset)\n", "    if not datasets:\n\t        raise RuntimeError(\n\t            f\"No data found at {data_dir}. Make sure you ran prepare_redpajama.py to create the dataset.\"\n\t        )\n\t    weights = [weight for _, weight in data_config]\n\t    sum_weights = sum(weights)\n\t    weights = [el / sum_weights for el in weights]\n\t    combined_dataset = CombinedDataset(datasets=datasets, seed=seed, weights=weights)\n\t    return DataLoader(combined_dataset, batch_size=batch_size, shuffle=False, pin_memory=True)\n\tdef create_dataloaders(\n", "    batch_size: int,\n\t    block_size: int,\n\t    fabric,\n\t    train_data_dir: str = \"data/lit-redpajama\",\n\t    val_data_dir: Optional[str] = None,\n\t    seed: int = 12345,\n\t) -> Tuple[DataLoader, DataLoader]:\n\t    # Increase by one because we need the next word as well\n\t    effective_block_size = block_size + 1\n\t    train_dataloader = create_dataloader(\n", "        batch_size=batch_size,\n\t        block_size=effective_block_size,\n\t        fabric=fabric,\n\t        data_dir=train_data_dir,\n\t        shuffle=True,\n\t        seed=seed,\n\t    )\n\t    val_dataloader = (\n\t        create_dataloader(\n\t            batch_size=batch_size,\n", "            block_size=effective_block_size,\n\t            fabric=fabric,\n\t            data_dir=val_data_dir,\n\t            shuffle=False,\n\t            seed=seed,\n\t        )\n\t        if val_data_dir\n\t        else None\n\t    )\n\t    return train_dataloader, val_dataloader\n", "# learning rate decay scheduler (cosine with warmup)\n\tdef get_lr(it):\n\t    # 1) linear warmup for warmup_iters steps\n\t    if it < warmup_iters:\n\t        return learning_rate * it / warmup_iters\n\t    # 2) if it > lr_decay_iters, return min learning rate\n\t    if it > lr_decay_iters:\n\t        return min_lr\n\t    # 3) in between, use cosine decay down to min learning rate\n\t    decay_ratio = (it - warmup_iters) / (lr_decay_iters - warmup_iters)\n", "    assert 0 <= decay_ratio <= 1\n\t    coeff = 0.5 * (1.0 + math.cos(math.pi * decay_ratio))  # coeff ranges 0..1\n\t    return min_lr + coeff * (learning_rate - min_lr)\n\tif __name__ == \"__main__\":\n\t    # Uncomment this line if you see an error: \"Expected is_sm80 to be true, but got false\"\n\t    # torch.backends.cuda.enable_flash_sdp(False)\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    from jsonargparse.cli import CLI\n\t    CLI(main)\n"]}
{"filename": "pretrain/shakespeare.py", "chunked_list": ["\"\"\"\n\tThis script is a placeholder for training LLaMA from scratch.\n\tCurrently, it just trains on the Shakespeare dataset.\n\t\"\"\"\n\tfrom pathlib import Path\n\timport sys\n\timport os\n\timport time\n\tfrom functools import partial\n\tfrom typing import Tuple\n", "import lightning as L\n\tfrom lightning.fabric.strategies import FSDPStrategy\n\timport torch\n\tfrom torch.distributed.fsdp.wrap import transformer_auto_wrap_policy\n\timport numpy as np\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\tfrom lit_llama.model import Block, LLaMA, LLaMAConfig\n\tfrom lit_llama.utils import save_model_checkpoint\n", "out_dir = \"out/training\"\n\teval_interval = 2000\n\teval_iters = 200\n\tlog_interval = 1\n\t# compilation fails as it does not support torch.complex64 for RoPE\n\t# compile = False\n\t# Hyperparameters\n\tlearning_rate = 6e-4\n\tbatch_size = 2\n\tmax_iters = 600000\n", "weight_decay = 1e-1\n\tbeta1 = 0.9\n\tbeta2 = 0.95\n\tgrad_clip = 1.0\n\t# For shakespeare, choose smaller block size than vanilla LLaMA\n\tblock_size = 1024\n\tdef main() -> None:\n\t    auto_wrap_policy = partial(transformer_auto_wrap_policy, transformer_layer_cls={Block})\n\t    strategy = FSDPStrategy(auto_wrap_policy=auto_wrap_policy, activation_checkpointing=Block, limit_all_gathers=True)\n\t    fabric = L.Fabric(accelerator=\"cuda\", devices=4, precision=\"bf16-mixed\", strategy=strategy)\n", "    fabric.launch()\n\t    fabric.seed_everything(1337 + fabric.global_rank)\n\t    if fabric.global_rank == 0:\n\t        os.makedirs(out_dir, exist_ok=True)\n\t    train_data, val_data = load_datasets()\n\t    config = LLaMAConfig.from_name(\"7B\")\n\t    config.block_size = block_size\n\t    config.vocab_size = 100  # from prepare_shakespeare.py\n\t    with fabric.device:\n\t        model = LLaMA(config)\n", "    # if compile:\n\t    #     model = torch.compile(model)\n\t    model = fabric.setup_module(model)\n\t    optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate, weight_decay=weight_decay, betas=(beta1, beta2), foreach=False)\n\t    optimizer = fabric.setup_optimizers(optimizer)\n\t    train(fabric, model, optimizer, train_data, val_data)\n\tdef train(\n\t    fabric: L.Fabric,\n\t    model: torch.nn.Module,\n\t    optimizer: torch.optim.Optimizer,\n", "    train_data: np.ndarray,\n\t    val_data: np.ndarray,\n\t) -> None:\n\t    \"\"\"The training loop.\n\t    Loosely based on the nanoGPT implementation: https://github.com/karpathy/nanoGPT.\n\t    \"\"\"\n\t    iter_num = 0\n\t    while True:\n\t        # TODO: add learning rate scheduling\n\t        # evaluate the loss on train/val sets and write checkpoints\n", "        if iter_num > 0 and iter_num % eval_interval == 0:\n\t            val_loss = validate(fabric, model, val_data)\n\t            fabric.print(f\"step {iter_num}: val loss {val_loss:.4f}\")\n\t            fabric.print(f\"Saving checkpoint to {out_dir}\")\n\t            save_model_checkpoint(fabric, model, os.path.join(out_dir, f\"iter-{iter_num:06d}-ckpt.pth\"))\n\t        t0 = time.time()\n\t        input_ids, targets = get_batch(\n\t            fabric,\n\t            train_data,\n\t            block_size=model.config.block_size,  # type: ignore[union-attr,arg-type]\n", "        )\n\t        logits = model(input_ids)\n\t        loss = torch.nn.functional.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\t        fabric.backward(loss)\n\t        # TODO: Gradient clipping\n\t        # if grad_clip != 0.0:\n\t        #     fabric.clip_gradients(model, optimizer, max_norm=grad_clip)\n\t        optimizer.step()\n\t        optimizer.zero_grad()\n\t        dt = time.time() - t0\n", "        if iter_num % log_interval == 0:\n\t            fabric.print(f\"iter {iter_num}: loss {loss.item():.4f}, time: {dt*1000:.2f}ms\")\n\t        iter_num += 1\n\t        if iter_num > max_iters:\n\t            break\n\t@torch.no_grad()\n\tdef validate(fabric: L.Fabric, model: torch.nn.Module, val_data: np.ndarray) -> torch.Tensor:\n\t    fabric.print(\"Validating ...\")\n\t    model.eval()\n\t    losses = torch.zeros(eval_iters)\n", "    for k in range(eval_iters):\n\t        input_ids, targets = get_batch(\n\t            fabric,\n\t            val_data,\n\t            block_size=model.config.block_size,  # type: ignore[union-attr,arg-type]\n\t        )\n\t        logits = model(input_ids)\n\t        loss = torch.nn.functional.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\t        losses[k] = loss.item()\n\t    out = losses.mean()\n", "    model.train()\n\t    return out\n\tdef get_batch(fabric: L.Fabric, data: np.ndarray, block_size: int) -> Tuple[torch.Tensor, torch.Tensor]:\n\t    ix = torch.randint(len(data) - block_size, (batch_size,))\n\t    x = torch.stack([torch.from_numpy((data[i : i + block_size]).astype(np.int64)) for i in ix])\n\t    y = torch.stack([torch.from_numpy((data[i + 1 : i + 1 + block_size]).astype(np.int64)) for i in ix])\n\t    x, y = fabric.to_device((x.pin_memory(), y.pin_memory()))\n\t    return x, y\n\tdef load_datasets(data_dir: str = \"data/shakespeare\") -> Tuple[np.ndarray, np.ndarray]:\n\t    train_data = np.memmap(os.path.join(data_dir, \"train.bin\"), dtype=np.uint16, mode=\"r\")\n", "    val_data = np.memmap(os.path.join(data_dir, \"val.bin\"), dtype=np.uint16, mode=\"r\")\n\t    return train_data, val_data\n\tif __name__ == \"__main__\":\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    main()\n"]}
{"filename": "scripts/prepare_redpajama.py", "chunked_list": ["import json\n\timport glob\n\timport os\n\tfrom pathlib import Path\n\timport sys\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\timport numpy as np\n\tfrom tqdm import tqdm\n", "from lit_llama import Tokenizer\n\timport lit_llama.packed_dataset as packed_dataset\n\tfilenames_sample = [\n\t    \"arxiv_sample.jsonl\",\n\t    \"book_sample.jsonl\",\n\t    \"c4_sample.jsonl\",\n\t    \"cc_2019-30_sample.jsonl\",\n\t    \"cc_2020-05_sample.jsonl\",\n\t    \"cc_2021-04_sample.jsonl\",\n\t    \"cc_2022-05_sample.jsonl\",\n", "    \"cc_2023-06_sample.jsonl\",\n\t    \"github_sample.jsonl\",\n\t    \"stackexchange_sample.jsonl\",\n\t    \"wikipedia_sample.jsonl\",\n\t]\n\tfilename_sets = {\n\t    \"arxiv\": \"arxiv/arxiv*\",\n\t    \"book\": \"book/book*\",\n\t    \"c4\": \"c4/c4-train*\",\n\t    \"common_crawl\": \"common_crawl/*\",\n", "    \"github\": \"github/filtered*\",\n\t    \"stackexchange\": \"stackexchange/stackexchange*\",\n\t    \"wikipedia\": \"wikipedia/wiki*\",\n\t}\n\tdef prepare_sample(\n\t    source_path: Path,\n\t    tokenizer_path: Path,\n\t    destination_path: Path,\n\t    chunk_size: int,\n\t    match = \"\"\n", ") -> None:\n\t    \"\"\"Prepare the \"Red Pajama\" dataset. We assume tokenizer has been trained (i.e. we reuse LLaMA's tokenizer model).\"\"\"\n\t    destination_path.mkdir(parents=True, exist_ok=True)\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    for name in filenames_sample:\n\t        if match and match not in name:\n\t            continue\n\t        filepath = source_path / name\n\t        if not filepath.is_file():\n\t            raise RuntimeError(\n", "                f\"Input file not found at {filepath}. \\n\"\n\t                \"Make sure you download the data, e.g. wget -i https://data.together.xyz/redpajama-data-1T/v1.0.0/urls.txt or through \\n\"\n\t                \"https://huggingface.co/datasets/togethercomputer/RedPajama-Data-1T \\n\"\n\t                \"https://huggingface.co/datasets/togethercomputer/RedPajama-Data-1T-Sample \\n\"\n\t            )\n\t        prefix, _ = os.path.splitext(name)\n\t        builder = packed_dataset.PackedDatasetBuilder(\n\t            outdir=destination_path,\n\t            prefix=prefix,\n\t            chunk_size=chunk_size,\n", "            sep_token=tokenizer.bos_id,\n\t            dtype=\"auto\",\n\t            vocab_size=tokenizer.vocab_size,\n\t        )\n\t        print(f\"Processing {name}\")\n\t        with open(filepath, encoding=\"utf-8\") as f:\n\t            for row in tqdm(f):\n\t                text = json.loads(row)[\"text\"]\n\t                text_ids = tokenizer.encode(text)\n\t                builder.add_array(np.array(text_ids, dtype=builder.dtype))\n", "        builder.write_reminder()\n\tdef prepare_full(\n\t    source_path: Path,\n\t    tokenizer_path: Path,\n\t    destination_path: Path,\n\t    chunk_size: int,\n\t    match: str = \"\"\n\t) -> None:\n\t    \"\"\"Prepare the \"Red Pajama\" dataset. We assume tokenizer has been trained (i.e. we reuse LLaMA's tokenizer model).\"\"\"\n\t    import zstandard as zstd\n", "    destination_path.mkdir(parents=True, exist_ok=True)\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    for set_name, pattern in filename_sets.items():\n\t        if match and match not in set_name:\n\t            continue\n\t        is_cc = set_name == \"common_crawl\"\n\t        filenames = glob.glob(os.path.join(source_path, pattern), recursive=True)\n\t        if not filenames:\n\t            raise RuntimeError(\n\t                f\"No files matching {pattern} found at {source_path}. \\n\"\n", "                \"Make sure you download the data, e.g. wget -i https://data.together.xyz/redpajama-data-1T/v1.0.0/urls.txt or through \\n\"\n\t                \"https://huggingface.co/datasets/togethercomputer/RedPajama-Data-1T \\n\"\n\t                \"https://huggingface.co/datasets/togethercomputer/RedPajama-Data-1T-Sample \\n\"\n\t            )\n\t        builder = packed_dataset.PackedDatasetBuilder(\n\t            outdir=destination_path,\n\t            prefix=set_name,\n\t            chunk_size=chunk_size,\n\t            sep_token=tokenizer.bos_id,\n\t            dtype=\"auto\",\n", "            vocab_size=tokenizer.vocab_size,\n\t        )\n\t        for name in filenames:\n\t            filepath = source_path / name\n\t            print(f\"Processing {name}\")\n\t            if is_cc:\n\t                with zstd.open(open(filepath, \"rb\"), \"rt\", encoding=\"utf-8\") as f:\n\t                    for row in tqdm(f):\n\t                        text = json.loads(row)[\"text\"]\n\t                        text_ids = tokenizer.encode(text)\n", "                        builder.add_array(np.array(text_ids, dtype=builder.dtype))\n\t            else:\n\t                with open(filepath, encoding=\"utf-8\") as f:\n\t                    for row in tqdm(f):\n\t                        text = json.loads(row)[\"text\"]\n\t                        text_ids = tokenizer.encode(text)\n\t                        builder.add_array(np.array(text_ids, dtype=builder.dtype))\n\t        builder.write_reminder()\n\tdef prepare(\n\t    source_path: Path = Path(\"data/RedPajama-Data-1T-Sample\"),\n", "    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    destination_path: Path = Path(\"data/red_pajama_sample\"),\n\t    chunk_size: int = 2049 * 1024,  # 2048 block size + 1 for causal (from LLama), 1024 blocks\n\t    sample: bool = False,\n\t    match: str = \"\",\n\t) -> None:\n\t    \"\"\"Prepare the \"Red Pajama\" dataset. We assume tokenizer has been trained (i.e. we reuse LLaMA's tokenizer model).\"\"\"\n\t    if sample:\n\t        prepare_sample(\n\t            source_path=source_path,\n", "            tokenizer_path=tokenizer_path,\n\t            destination_path=destination_path,\n\t            chunk_size=chunk_size,\n\t            match=match,\n\t        )\n\t    else:\n\t        prepare_full(\n\t            source_path=source_path,\n\t            tokenizer_path=tokenizer_path,\n\t            destination_path=destination_path,\n", "            chunk_size=chunk_size,\n\t            match=match,\n\t        )\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    CLI(prepare)\n"]}
{"filename": "scripts/convert_hf_checkpoint.py", "chunked_list": ["import collections\n\timport contextlib\n\timport gc\n\timport json\n\timport shutil\n\timport sys\n\tfrom pathlib import Path\n\timport torch\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n", "sys.path.append(str(wd))\n\tfrom lit_llama.model import LLaMA, LLaMAConfig\n\tfrom lit_llama.utils import EmptyInitOnDevice, lazy_load, incremental_save\n\t@torch.no_grad()\n\tdef convert_hf_checkpoint(\n\t    *,\n\t    output_dir: Path = Path(\"checkpoints/lit-llama/7B\"),\n\t    checkpoint_dir: Path = Path(\"checkpoints/hf-llama/7B\"),\n\t    model_size: str = \"7B\",\n\t    dtype: str = \"float32\",\n", "    verify: bool = False,\n\t) -> None:\n\t    \"\"\"\n\t    Perform the reverse operation of: https://github.com/huggingface/transformers/blob/main/src/transformers/models/llama/convert_llama_weights_to_hf.py\n\t    \"\"\"\n\t    output_dir.mkdir(parents=True, exist_ok=True)\n\t    # the tokenizer is the same for all model sizes, so we store it in the parent dir\n\t    shutil.copy(checkpoint_dir / \"tokenizer.model\", output_dir.parent)\n\t    dt = getattr(torch, dtype, None)\n\t    if not isinstance(dt, torch.dtype):\n", "        raise ValueError(f\"{dtype} is not a valid dtype.\")\n\t    dtype = dt\n\t    print(\"Initializing lit-llama\")\n\t    config = LLaMAConfig.from_name(model_size)\n\t    with EmptyInitOnDevice(device=\"meta\", dtype=dtype):\n\t        model = LLaMA(config)\n\t    qkv_size = model.transformer.h[0].attn.c_attn.weight.shape[0] // 3\n\t    # initialize a new empty state dict to hold our new weights\n\t    sd_meta = model.state_dict()\n\t    sd = {}\n", "    # Load the json file containing weight mapping\n\t    pytorch_bin_map_json_path = checkpoint_dir / \"pytorch_model.bin.index.json\"\n\t    with open(pytorch_bin_map_json_path) as json_map:\n\t        bin_index = json.load(json_map)\n\t    bin_files = set(checkpoint_dir / bin for bin in bin_index[\"weight_map\"].values())\n\t    if not bin_files:\n\t        raise ValueError(f\"Expected {str(checkpoint_dir)!r} to contain .bin files\")\n\t    def permute(w):\n\t        dim = config.n_embd\n\t        w = w._load_tensor().to(dtype)\n", "        return (\n\t            w.view(config.n_head, 2, dim // config.n_head // 2, dim)\n\t            .transpose(1, 2)\n\t            .reshape(dim, dim)\n\t        )\n\t    weight_map = {\n\t        \"self_attn.o_proj.weight\": \"attn.c_proj.weight\",\n\t        \"self_attn.q_proj.weight\": \"attn.c_attn.weight\",\n\t        \"self_attn.k_proj.weight\": \"attn.c_attn.weight\",\n\t        \"self_attn.v_proj.weight\": \"attn.c_attn.weight\",\n", "        \"mlp.gate_proj.weight\": \"mlp.c_fc1.weight\",\n\t        \"mlp.up_proj.weight\": \"mlp.c_fc2.weight\",\n\t        \"mlp.down_proj.weight\": \"mlp.c_proj.weight\",\n\t        \"input_layernorm.weight\": \"rms_1.scale\",\n\t        \"post_attention_layernorm.weight\": \"rms_2.scale\",\n\t        \"model.embed_tokens.weight\": \"transformer.wte.weight\",\n\t        \"model.norm.weight\": \"transformer.ln_f.scale\",\n\t        \"lm_head.weight\": \"lm_head.weight\",\n\t    }\n\t    print(f\"Saving to disk at {output_dir}\")\n", "    unprocessed_weights = collections.defaultdict(dict)\n\t    with incremental_save(output_dir / \"lit-llama.pth\") as saver:\n\t        # for checkpoints that split the QKV across several files, we need to keep all the bin files\n\t        # open, so we use `ExitStack` to close them all together at the end\n\t        with contextlib.ExitStack() as stack:\n\t            for bin_file in bin_files:\n\t                print(\"Processing\", bin_file)\n\t                hf_weights = stack.enter_context(lazy_load(bin_file))\n\t                for name, param in hf_weights.items():\n\t                    skip = False\n", "                    if \"rotary_emb.inv_freq\" in name:\n\t                        continue\n\t                    if \"model.layers\" in name:\n\t                        block_id = int(name.split(\".\")[2])\n\t                        from_name = \".\".join(name.split(\".\")[3:])\n\t                        to_name = weight_map[from_name]\n\t                        sd_key = f\"transformer.h.{block_id}.{to_name}\"\n\t                        if \"q_proj\" in name:\n\t                            unprocessed_weights[sd_key][\"q_proj\"] = param\n\t                            skip = True\n", "                        elif \"k_proj\" in name:\n\t                            unprocessed_weights[sd_key][\"k_proj\"] = param\n\t                            skip = True\n\t                        elif \"v_proj\" in name:\n\t                            unprocessed_weights[sd_key][\"v_proj\"] = param\n\t                            skip = True\n\t                        if skip and len(unprocessed_weights[sd_key]) == 3:\n\t                            w = torch.empty(\n\t                                sd_meta[sd_key].shape, dtype=sd_meta[sd_key].dtype\n\t                            )\n", "                            w[:qkv_size] = permute(unprocessed_weights[sd_key][\"q_proj\"])\n\t                            w[qkv_size:-qkv_size] = permute(\n\t                                unprocessed_weights[sd_key][\"k_proj\"]\n\t                            )\n\t                            w[-qkv_size:] = (\n\t                                unprocessed_weights[sd_key][\"v_proj\"]\n\t                                ._load_tensor()\n\t                                .to(dtype)\n\t                            )\n\t                            sd[sd_key] = w\n", "                            del unprocessed_weights[sd_key]\n\t                            skip = False\n\t                        else:\n\t                            sd[sd_key] = param._load_tensor().to(dtype)\n\t                    else:\n\t                        sd_key = weight_map[name]\n\t                        sd[sd_key] = param._load_tensor().to(dtype)\n\t                    if not skip:\n\t                        sd[sd_key] = saver.store_early(sd[sd_key])\n\t                gc.collect()\n", "        saver.save(sd)\n\t    assert len(unprocessed_weights) == 0, f\"unexpected partial weights {list(unprocessed_weights)}\"\n\t    if verify:\n\t        try:\n\t            from transformers import LlamaForCausalLM\n\t        except ImportError:\n\t            raise ImportError(\"verify=True requires transformers to be installed, please `pip install transformers`\")\n\t        print(\"Verifying...\")\n\t        token_sample = torch.randint(0, config.vocab_size, size=(1, config.block_size), dtype=torch.int64)\n\t        out = model(token_sample)\n", "        del model\n\t        gc.collect()\n\t        print(\"Loading original model for comparison\")\n\t        model_hf = LlamaForCausalLM.from_pretrained(checkpoint_dir)\n\t        out_hf = model_hf(token_sample)[\"logits\"]\n\t        print(\"Comparing outputs\")\n\t        assert out.device.type == out_hf.device.type\n\t        assert out.dtype == out_hf.dtype\n\t        assert torch.testing.assert_close(out, out_hf)\n\tif __name__ == \"__main__\":\n", "    from jsonargparse import CLI\n\t    CLI(convert_hf_checkpoint)\n"]}
{"filename": "scripts/convert_checkpoint.py", "chunked_list": ["import gc\n\timport shutil\n\tfrom pathlib import Path\n\tfrom typing import Dict\n\timport torch\n\tfrom tqdm import tqdm\n\t\"\"\"\n\tSample usage:\n\t```bash\n\tpython -m scripts.convert_checkpoint -h\n", "python -m scripts.convert_checkpoint converted\n\t```\n\t\"\"\"\n\tdef convert_state_dict(state_dict: Dict[str, torch.Tensor], dtype: torch.dtype = torch.float32) -> Dict[str, torch.Tensor]:\n\t    converted = {}\n\t    converted[\"transformer.wte.weight\"] = state_dict[\"tok_embeddings.weight\"].to(dtype)\n\t    converted[\"lm_head.weight\"] = state_dict[\"output.weight\"].to(dtype)\n\t    converted[\"transformer.ln_f.scale\"] = state_dict[\"norm.weight\"].to(dtype)\n\t    for layer_idx in sorted(set([k.split(\".\")[1] for k in state_dict if k.startswith(\"layers\")])):\n\t        # attention\n", "        # the wq, wk, wv from the FB model are stacked in our model as c_attn\n\t        converted[f\"transformer.h.{layer_idx}.attn.c_attn.weight\"] = torch.cat(\n\t            (\n\t                state_dict[f\"layers.{layer_idx}.attention.wq.weight\"].to(dtype),\n\t                state_dict[f\"layers.{layer_idx}.attention.wk.weight\"].to(dtype),\n\t                state_dict[f\"layers.{layer_idx}.attention.wv.weight\"].to(dtype),\n\t            )\n\t        )\n\t        converted[f\"transformer.h.{layer_idx}.attn.c_proj.weight\"] = state_dict[\n\t            f\"layers.{layer_idx}.attention.wo.weight\"\n", "        ].to(dtype)\n\t        # mlp\n\t        converted[f\"transformer.h.{layer_idx}.mlp.c_fc1.weight\"] = state_dict[\n\t            f\"layers.{layer_idx}.feed_forward.w1.weight\"\n\t        ].to(dtype)\n\t        converted[f\"transformer.h.{layer_idx}.mlp.c_proj.weight\"] = state_dict[\n\t            f\"layers.{layer_idx}.feed_forward.w2.weight\"\n\t        ].to(dtype)\n\t        converted[f\"transformer.h.{layer_idx}.mlp.c_fc2.weight\"] = state_dict[\n\t            f\"layers.{layer_idx}.feed_forward.w3.weight\"\n", "        ].to(dtype)\n\t        # rms norm\n\t        converted[f\"transformer.h.{layer_idx}.rms_1.scale\"] = state_dict[f\"layers.{layer_idx}.attention_norm.weight\"].to(dtype)\n\t        converted[f\"transformer.h.{layer_idx}.rms_2.scale\"] = state_dict[f\"layers.{layer_idx}.ffn_norm.weight\"].to(dtype)\n\t    return converted\n\tshard_dims = {\n\t    \"lm_head.weight\": 0,\n\t    \"wte.weight\": 1,\n\t    \"attn.c_attn.weight\": 0,\n\t    \"attn.c_proj.weight\": 1,\n", "    \"mlp.c_fc1.weight\": 0,\n\t    \"mlp.c_fc2.weight\": 0,\n\t    \"mlp.c_proj.weight\": 1\n\t}\n\tdef meta_weights_for_nano_model(\n\t    *,\n\t    output_dir: Path = Path(\"checkpoints/lit-llama\"),\n\t    checkpoint_dir: Path = Path(\"checkpoints/llama/\"),\n\t    model_size: str = \"7B\",\n\t    dtype: str = \"float32\",\n", ") -> None:\n\t    output_dir = output_dir / model_size\n\t    checkpoint_dir = checkpoint_dir / model_size\n\t    output_dir.mkdir(parents=True, exist_ok=True)\n\t    # the tokenizer is the same for all model sizes, so we store it in the parent dir\n\t    shutil.copy(checkpoint_dir.parent / \"tokenizer.model\", output_dir.parent)\n\t    dt = getattr(torch, dtype, None)\n\t    if not isinstance(dt, torch.dtype):\n\t        raise ValueError(f\"{dtype} is not a valid dtype.\")\n\t    dtype = dt\n", "    checkpoint_files = sorted(checkpoint_dir.glob(\"*.pth\"))\n\t    checkpoint_files.sort()\n\t    n_checkpoints = len(checkpoint_files)\n\t    if n_checkpoints == 0:\n\t        raise RuntimeError(f\"No checkpoints were found at checkpoint_dir {checkpoint_dir}. `consolidated.0*.pth` files expected at that location.\")\n\t    # for the bigger models, there are multiple model-parallel checkpoints\n\t    # and we combine them into one single file\n\t    combined = None\n\t    for file in tqdm(checkpoint_files, total=n_checkpoints):\n\t        checkpoint = torch.load(file, map_location=\"cpu\")\n", "        converted = convert_state_dict(checkpoint, dtype=dtype)\n\t        if combined is None:\n\t            combined = converted\n\t            continue\n\t        for name, param in converted.items():\n\t            dim = None\n\t            for k, d in shard_dims.items():\n\t                if k in name:\n\t                    dim = d\n\t                    break\n", "            if dim is None:\n\t                # Extra check: assert that tensors are the same if not sharded\n\t                # assert torch.allclose(combined[name], param)\n\t                continue\n\t            combined[name] = torch.cat((combined[name], param), dim=dim)\n\t        del checkpoint\n\t        del converted\n\t        gc.collect()\n\t    for name, param in combined.items():\n\t        if \"c_attn\" not in name:\n", "            continue\n\t        # Turn [Q1, K1, V1, Q2, K2, V2, ...] into [Q1, Q2, ..., K1, K2, .., V1, V2, ...]\n\t        src_chunk_len = param.shape[0] // n_checkpoints\n\t        mat_len = src_chunk_len // 3\n\t        dst_chunk_len = mat_len * n_checkpoints\n\t        attn = torch.clone(param)\n\t        for i in range(n_checkpoints):\n\t            for j in range(3):\n\t                param[j * dst_chunk_len + i * mat_len: j * dst_chunk_len + (i+1) * mat_len] = \\\n\t                    attn[i * src_chunk_len + j * mat_len: i * src_chunk_len + (j+1) * mat_len]\n", "        del attn\n\t        gc.collect()\n\t    torch.save(combined, output_dir / \"lit-llama.pth\")\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    CLI(meta_weights_for_nano_model)\n"]}
{"filename": "scripts/prepare_shakespeare.py", "chunked_list": ["# MIT License\n\t# Copyright (c) 2022 Andrej Karpathy\n\t# Permission is hereby granted, free of charge, to any person obtaining a copy\n\t# of this software and associated documentation files (the \"Software\"), to deal\n\t# in the Software without restriction, including without limitation the rights\n\t# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t# copies of the Software, and to permit persons to whom the Software is\n\t# furnished to do so, subject to the following conditions:\n\t# The above copyright notice and this permission notice shall be included in all\n\t# copies or substantial portions of the Software.\n", "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\t# SOFTWARE.\n\timport sys\n\tfrom pathlib import Path\n\t# support running without installing as a package\n", "wd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\timport numpy as np\n\timport requests\n\tdef prepare(destination_path: Path = Path(\"data/shakespeare\")) -> None:\n\t    \"\"\"Prepare the \"Tiny Shakespeare\" dataset.\"\"\"\n\t    destination_path.mkdir(parents=True, exist_ok=True)\n\t    # download the tiny shakespeare dataset\n\t    input_file_path = destination_path / \"input.txt\"\n\t    if not input_file_path.exists():\n", "        data_url = \"https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt\"\n\t        with open(input_file_path, \"w\") as f:\n\t            f.write(requests.get(data_url).text)\n\t    with open(input_file_path) as f:\n\t        data = f.read()\n\t    n = len(data)\n\t    train_data = data[: int(n * 0.9)]\n\t    val_data = data[int(n * 0.9) :]\n\t    from lit_llama import Tokenizer\n\t    Tokenizer.train(input=input_file_path, destination=destination_path, vocab_size=100)\n", "    tokenizer = Tokenizer(destination_path / \"tokenizer.model\")\n\t    train_ids = tokenizer.encode(train_data)\n\t    val_ids = tokenizer.encode(val_data)\n\t    print(f\"train has {len(train_ids):,} tokens\")\n\t    print(f\"val has {len(val_ids):,} tokens\")\n\t    # export to bin files\n\t    train_ids = np.array(train_ids, dtype=np.uint16)\n\t    val_ids = np.array(val_ids, dtype=np.uint16)\n\t    train_ids.tofile(destination_path / \"train.bin\")\n\t    val_ids.tofile(destination_path / \"val.bin\")\n", "if __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    CLI(prepare)\n"]}
{"filename": "scripts/prepare_alpaca.py", "chunked_list": ["\"\"\"Implementation derived from https://github.com/tloen/alpaca-lora\"\"\"\n\timport sys\n\tfrom pathlib import Path\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\timport torch\n\timport requests\n\timport json\n\tfrom torch.utils.data import random_split\n", "from lit_llama.tokenizer import Tokenizer\n\tfrom tqdm import tqdm\n\tDATA_FILE = \"https://raw.githubusercontent.com/tloen/alpaca-lora/main/alpaca_data_cleaned_archive.json\"\n\tDATA_FILE_NAME = \"alpaca_data_cleaned_archive.json\"\n\tIGNORE_INDEX = -1\n\tdef prepare(\n\t    destination_path: Path = Path(\"data/alpaca\"), \n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    test_split_size: int = 2000,\n\t    max_seq_length: int = 256,\n", "    seed: int = 42,\n\t    mask_inputs: bool = False,  # as in alpaca-lora\n\t    data_file_name: str = DATA_FILE_NAME\n\t) -> None:\n\t    \"\"\"Prepare the Alpaca dataset for instruction tuning.\n\t    The output is a training and validation dataset saved as `train.pt` and `val.pt`,\n\t    which stores the preprocessed and tokenized prompts and labels.\n\t    \"\"\"\n\t    destination_path.mkdir(parents=True, exist_ok=True)\n\t    file_path = destination_path / data_file_name\n", "    download(file_path)\n\t    # TODO: If we don't have the Meta weights, where do we get the tokenizer from?\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    with open(file_path, \"r\") as file:\n\t        data = json.load(file)\n\t    # Partition the dataset into train and test\n\t    train_split_size = len(data) - test_split_size\n\t    train_set, test_set = random_split(\n\t        data, \n\t        lengths=(train_split_size, test_split_size),\n", "        generator=torch.Generator().manual_seed(seed),\n\t    )\n\t    train_set, test_set = list(train_set), list(test_set)\n\t    print(f\"train has {len(train_set):,} samples\")\n\t    print(f\"val has {len(test_set):,} samples\")\n\t    print(\"Processing train split ...\")\n\t    train_set = [prepare_sample(sample, tokenizer, max_seq_length, mask_inputs) for sample in tqdm(train_set)]\n\t    torch.save(train_set, file_path.parent / \"train.pt\")\n\t    print(\"Processing test split ...\")\n\t    test_set = [prepare_sample(sample, tokenizer, max_seq_length, mask_inputs) for sample in tqdm(test_set)]\n", "    torch.save(test_set, file_path.parent / \"test.pt\")\n\tdef download(file_path: Path):\n\t    \"\"\"Downloads the raw json data file and saves it in the given destination.\"\"\"\n\t    if file_path.exists():\n\t        return\n\t    with open(file_path, \"w\") as f:\n\t        f.write(requests.get(DATA_FILE).text)\n\tdef prepare_sample(example: dict, tokenizer: Tokenizer, max_length: int, mask_inputs: bool = True):\n\t    \"\"\"Processes a single sample.\n\t    Each sample in the dataset consists of:\n", "    - instruction: A string describing the task\n\t    - input: A string holding a special input value for the instruction.\n\t        This only applies to some samples, and in others this is empty.\n\t    - output: The response string\n\t    This function processes this data to produce a prompt text and a label for\n\t    supervised training. The input text is formed as a single message including all\n\t    the instruction, the input (optional) and the response.\n\t    The label/target is the same message but can optionally have the instruction + input text\n\t    masked out (mask_inputs=True).\n\t    Finally, both the prompt and the label get tokenized. If desired, all tokens\n", "    in the label that correspond to the original input prompt get masked out (default).\n\t    \"\"\"\n\t    full_prompt = generate_prompt(example)\n\t    full_prompt_and_response = full_prompt + example[\"output\"]\n\t    encoded_full_prompt = tokenize(tokenizer, full_prompt, max_length=max_length, eos=False)\n\t    encoded_full_prompt_and_response = tokenize(tokenizer, full_prompt_and_response, eos=True, max_length=max_length)\n\t    # The labels are the full prompt with response, but with the prompt masked out\n\t    labels = encoded_full_prompt_and_response.clone()\n\t    if mask_inputs:\n\t        labels[:len(encoded_full_prompt)] = IGNORE_INDEX\n", "    return {**example, \"input_ids\": encoded_full_prompt_and_response, \"input_ids_no_response\": encoded_full_prompt, \"labels\": labels}\n\tdef tokenize(tokenizer: Tokenizer, string: str, max_length: int, eos=True) -> torch.Tensor:\n\t    return tokenizer.encode(string, bos=True, eos=eos, max_length=max_length)\n\tdef generate_prompt(example):\n\t    \"\"\"Generates a standardized message to prompt the model with an instruction, optional input and a\n\t    'response' field.\"\"\"\n\t    if example[\"input\"]:\n\t        return (\n\t            \"Below is an instruction that describes a task, paired with an input that provides further context. \"\n\t            \"Write a response that appropriately completes the request.\\n\\n\"\n", "            f\"### Instruction:\\n{example['instruction']}\\n\\n### Input:\\n{example['input']}\\n\\n### Response:\"\n\t        )\n\t    return (\n\t        \"Below is an instruction that describes a task. \"\n\t        \"Write a response that appropriately completes the request.\\n\\n\"\n\t        f\"### Instruction:\\n{example['instruction']}\\n\\n### Response:\"\n\t    )\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    CLI(prepare)\n"]}
{"filename": "scripts/download.py", "chunked_list": ["import os\n\tfrom typing import Optional\n\tfrom urllib.request import urlretrieve\n\tfiles = {\n\t    \"original_model.py\": \"https://gist.githubusercontent.com/lantiga/fd36849fb1c498da949a0af635318a7b/raw/7dd20f51c2a1ff2886387f0e25c1750a485a08e1/llama_model.py\",\n\t    \"original_adapter.py\": \"https://gist.githubusercontent.com/awaelchli/546f33fcdb84cc9f1b661ca1ca18418d/raw/e81d8f35fb1fec53af1099349b0c455fc8c9fb01/original_adapter.py\",\n\t}\n\tdef download_original(wd: str) -> None:\n\t    for file, url in files.items():\n\t        filepath = os.path.join(wd, file)\n", "        if not os.path.isfile(filepath):\n\t            print(f\"Downloading original implementation to {filepath!r}\")\n\t            urlretrieve(url=url, filename=file)\n\t            print(\"Done\")\n\t        else:\n\t            print(\"Original implementation found. Skipping download.\")\n\tdef download_from_hub(repo_id: Optional[str] = None, local_dir: str = \"checkpoints/hf-llama/7B\") -> None:\n\t    if repo_id is None:\n\t        raise ValueError(\"Please pass `--repo_id=...`. You can try googling 'huggingface hub llama' for options.\")\n\t    from huggingface_hub import snapshot_download\n", "    snapshot_download(repo_id, local_dir=local_dir, local_dir_use_symlinks=False)\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    CLI(download_from_hub)\n"]}
{"filename": "scripts/prepare_any_text.py", "chunked_list": ["\"\"\"Implementation derived from https://github.com/tloen/alpaca-lora\"\"\"\n\timport sys\n\tfrom pathlib import Path\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\timport torch\n\timport requests\n\timport json\n\tfrom torch.utils.data import random_split\n", "from lit_llama.tokenizer import Tokenizer\n\tfrom tqdm import tqdm\n\tIGNORE_INDEX = -1\n\tDATA_FILE_NAME = \"input.txt\"\n\tdef prepare(\n\t    destination_path: Path = Path(\"data/any\"),\n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    test_split_ratio: float = 0.9,  # default 90% train, 10% validation\n\t    max_seq_length: int = 256,\n\t    seed: int = 42,\n", "    data_file_name: str = DATA_FILE_NAME,\n\t) -> None:\n\t    \"\"\"Prepare any dataset for finetuning (akin to Shakespheare full tuning).\n\t    The output is a training and validation dataset saved as `train.pt` and `val.pt`,\n\t    which stores the preprocessed and tokenized prompts and labels.\n\t    \"\"\"\n\t    destination_path.mkdir(parents=True, exist_ok=True)\n\t    file_path = destination_path / data_file_name\n\t    if not file_path.exists():\n\t        raise AssertionError(f\"{data_file_name} is provided by the user\")\n", "    # TODO: If we don't have the Meta weights, where do we get the tokenizer from?\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    data = []\n\t    with open(file_path, \"r\") as input_file:\n\t        for line in input_file.readlines():\n\t            data.append(line)\n\t    # Partition the dataset into train and test\n\t    train_split_size = int(len(data) * test_split_ratio)\n\t    test_split_size = len(data) - train_split_size\n\t    train_set, test_set = random_split(\n", "        data,\n\t        lengths=(train_split_size, test_split_size),\n\t        generator=torch.Generator().manual_seed(seed),\n\t    )\n\t    train_set, test_set = list(train_set), list(test_set)\n\t    print(f\"train has {len(train_set):,} samples\")\n\t    print(f\"val has {len(test_set):,} samples\")\n\t    print(\"Processing train split ...\")\n\t    train_set = [\n\t        prepare_line(line, tokenizer, max_seq_length) for line in tqdm(train_set)\n", "    ]\n\t    torch.save(train_set, file_path.parent / \"train.pt\")\n\t    print(\"Processing test split ...\")\n\t    test_set = [\n\t        prepare_line(line, tokenizer, max_seq_length) for line in tqdm(test_set)\n\t    ]\n\t    torch.save(test_set, file_path.parent / \"test.pt\")\n\tdef prepare_line(line: str, tokenizer: Tokenizer, max_length: int):\n\t    \"\"\"Processes a single sample.\n\t    This function processes the line to produce the tokenized version of it.\n", "    \"\"\"\n\t    encoded_full_prompt = tokenize(tokenizer, line, max_length=max_length, eos=False)\n\t    return {\n\t        \"input_ids\": encoded_full_prompt,\n\t        \"labels\": encoded_full_prompt,\n\t    }\n\tdef tokenize(\n\t    tokenizer: Tokenizer, string: str, max_length: int, eos=True\n\t) -> torch.Tensor:\n\t    return tokenizer.encode(string, bos=True, eos=eos, max_length=max_length)\n", "if __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    CLI(prepare)\n"]}
{"filename": "scripts/convert_lora_weights.py", "chunked_list": ["import sys\n\timport time\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport lightning as L\n\timport torch\n\timport torch.nn as nn\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n", "from lit_llama import LLaMA\n\tfrom lit_llama.utils import EmptyInitOnDevice, lazy_load, llama_model_lookup\n\tfrom lit_llama.lora import lora\n\tdef del_lora_state_dict(model: nn.Module):\n\t    base_model_dict = model.state_dict()\n\t    key_to_delete = [k for k in base_model_dict if \"lora_\" in k]\n\t    for del_key in key_to_delete:\n\t        del base_model_dict[del_key]\n\t    return base_model_dict\n\tdef lora_model_lookup(checkpoint: dict) -> int:\n", "    \"\"\"Returns the LoRA rank from the adapter checkpoint.\n\t    \"\"\"\n\t    return checkpoint[\"transformer.h.0.attn.c_attn.lora_B\"].shape[1]\n\tdef main(\n\t    accelerator: str = \"auto\",\n\t    lora_path: Optional[Path] = None,\n\t    checkpoint_path: Optional[Path] = None,\n\t    dtype: str = \"bfloat16\",\n\t) -> None:\n\t    \"\"\"Merges lora weights to base model.\n", "    Args:\n\t        accelerator: The hardware to run on. Possible choices are:\n\t            ``\"cpu\"``, ``\"cuda\"``, ``\"mps\"``, ``\"gpu\"``, ``\"tpu\"``, ``\"auto\"``.\n\t        lora_path: Path to the checkpoint with trained LoRA weights, which are the output of\n\t            `finetune_lora.py`.\n\t        checkpoint_path: The checkpoint path to load.\n\t        dtype: `torch.dtype` to work with\n\t    \"\"\"\n\t    if not lora_path:\n\t        lora_path = Path(\"out/lora/alpaca/lit-llama-lora-finetuned.pth\")\n", "    if not checkpoint_path:\n\t        checkpoint_path = Path(f\"./checkpoints/lit-llama/7B/lit-llama.pth\")\n\t    assert lora_path.is_file()\n\t    assert checkpoint_path.is_file()\n\t    fabric = L.Fabric(accelerator=accelerator, devices=1)\n\t    dt = getattr(torch, dtype, None)\n\t    if not isinstance(dt, torch.dtype):\n\t        raise ValueError(f\"{dtype} is not a valid dtype.\")\n\t    dtype = dt\n\t    print(\"Loading model ...\", file=sys.stderr)\n", "    t0 = time.time()\n\t    with (lazy_load(checkpoint_path) as pretrained_checkpoint,\n\t          lazy_load(lora_path) as lora_checkpoint):\n\t        name = llama_model_lookup(pretrained_checkpoint)\n\t        rank = lora_model_lookup(lora_checkpoint)\n\t        with EmptyInitOnDevice(\n\t                device=fabric.device, dtype=dtype\n\t        ), lora(r=rank, alpha=16, dropout=0.05, enabled=True):\n\t            model = LLaMA.from_name(name)\n\t            # 1. Load the pretrained weights\n", "            model.load_state_dict(pretrained_checkpoint, strict=False)\n\t            # 2. Load the fine-tuned lora weights\n\t            model.load_state_dict(lora_checkpoint, strict=False)\n\t    print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n\t    model.eval()\n\t    base_model_dict = del_lora_state_dict(model)\n\t    save_path = lora_path.with_stem(f\"{lora_path.stem}-lora-merged-weights\")\n\t    print(\"Saving LoRA to base model weights ...\")\n\t    torch.save(base_model_dict, save_path)\n\t    print(f\"Model saved at {save_path}\")\n", "if __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    CLI(main)"]}
{"filename": "scripts/prepare_dolly.py", "chunked_list": ["\"\"\"Implementation derived from https://github.com/tloen/alpaca-lora\"\"\"\n\timport sys\n\tfrom pathlib import Path\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\timport torch\n\timport requests\n\timport json\n\tfrom torch.utils.data import random_split\n", "from lit_llama.tokenizer import Tokenizer\n\tfrom tqdm import tqdm\n\tDATA_FILE = \"https://huggingface.co/datasets/databricks/databricks-dolly-15k/resolve/main/databricks-dolly-15k.jsonl\"\n\tDATA_FILE_NAME = \"dolly_data_cleaned.json\"\n\tIGNORE_INDEX = -1\n\tdef prepare(\n\t    destination_path: Path = Path(\"data/dolly\"), \n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    test_split_size: int = 2000,\n\t    max_seq_length: int = 1024,\n", "    seed: int = 42,\n\t    mask_inputs: bool = False,  # as in alpaca-lora\n\t) -> None:\n\t    \"\"\"Prepare the Dolly dataset for instruction tuning.\n\t    The output is a training and validation dataset saved as `train.pt` and `val.pt`,\n\t    which stores the preprocessed and tokenized prompts and labels.\n\t    \"\"\"\n\t    destination_path.mkdir(parents=True, exist_ok=True)\n\t    file_path = destination_path / DATA_FILE_NAME\n\t    download(file_path)\n", "    # TODO: If we don't have the Meta weights, where do we get the tokenizer from?\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    with open(file_path, \"r\") as file:\n\t        data = file.readlines()\n\t        data = [json.loads(line) for line in data]\n\t    for item in data:\n\t        item[\"input\"] = item.pop(\"context\")\n\t        item[\"output\"] = item.pop(\"response\")\n\t    # Partition the dataset into train and test\n\t    train_split_size = len(data) - test_split_size\n", "    train_set, test_set = random_split(\n\t        data, \n\t        lengths=(train_split_size, test_split_size),\n\t        generator=torch.Generator().manual_seed(seed),\n\t    )\n\t    train_set, test_set = list(train_set), list(test_set)\n\t    print(f\"train has {len(train_set):,} samples\")\n\t    print(f\"val has {len(test_set):,} samples\")\n\t    print(\"Processing train split ...\")\n\t    train_set = [prepare_sample(sample, tokenizer, max_seq_length, mask_inputs) for sample in tqdm(train_set)]\n", "    torch.save(train_set, file_path.parent / \"train.pt\")\n\t    print(\"Processing test split ...\")\n\t    test_set = [prepare_sample(sample, tokenizer, max_seq_length, mask_inputs) for sample in tqdm(test_set)]\n\t    torch.save(test_set, file_path.parent / \"test.pt\")\n\tdef download(file_path: Path):\n\t    \"\"\"Downloads the raw json data file and saves it in the given destination.\"\"\"\n\t    if file_path.exists():\n\t        return\n\t    with open(file_path, \"w\") as f:\n\t        f.write(requests.get(DATA_FILE).text)\n", "def prepare_sample(example: dict, tokenizer: Tokenizer, max_length: int, mask_inputs: bool = True):\n\t    \"\"\"Processes a single sample.\n\t    Each sample in the dataset consists of:\n\t    - instruction: A string describing the task\n\t    - input: A string holding a special input value for the instruction.\n\t        This only applies to some samples, and in others this is empty.\n\t    - output: The response string\n\t    This function processes this data to produce a prompt text and a label for\n\t    supervised training. The prompt text is formed as a single message including both\n\t    the instruction and the input. The label/target is the same message but with the\n", "    response attached.\n\t    Finally, both the prompt and the label get tokenized. If desired, all tokens\n\t    in the label that correspond to the original input prompt get masked out (default).\n\t    \"\"\"\n\t    full_prompt = generate_prompt(example)\n\t    full_prompt_and_response = full_prompt + example[\"output\"]\n\t    encoded_full_prompt = tokenize(tokenizer, full_prompt, max_length=max_length, eos=False)\n\t    encoded_full_prompt_and_response = tokenize(tokenizer, full_prompt_and_response, eos=True, max_length=max_length)\n\t    # The labels are the full prompt with response, but with the prompt masked out\n\t    labels = encoded_full_prompt_and_response.clone()\n", "    if mask_inputs:\n\t        labels[:len(encoded_full_prompt)] = IGNORE_INDEX\n\t    return {**example, \"input_ids\": encoded_full_prompt_and_response, \"input_ids_no_response\": encoded_full_prompt, \"labels\": labels}\n\tdef tokenize(tokenizer: Tokenizer, string: str, max_length: int, eos=True) -> torch.Tensor:\n\t    return tokenizer.encode(string, bos=True, eos=eos, max_length=max_length)\n\tdef generate_prompt(example):\n\t    \"\"\"Generates a standardized message to prompt the model with an instruction, optional input and a\n\t    'response' field.\"\"\"\n\t    if example[\"input\"]:\n\t        return (\n", "            f\"Below is an instruction that describes a task, paired with an input that provides further context. \"\n\t            \"Write a response that appropriately completes the request.\\n\\n\"\n\t            f\"### Instruction:\\n{example['instruction']}\\n\\n### Input:\\n{example['input']}\\n\\n### Response:\"\n\t        )\n\t    return (\n\t        f\"Below is an instruction that describes a task. \"\n\t        \"Write a response that appropriately completes the request.\\n\\n\"\n\t        f\"### Instruction:\\n{example['instruction']}\\n\\n### Response:\"\n\t    )\n\tif __name__ == \"__main__\":\n", "    from jsonargparse import CLI\n\t    CLI(prepare)\n"]}
{"filename": "generate/full.py", "chunked_list": ["import sys\n\timport time\n\timport warnings\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport lightning as L\n\timport torch\n\t# support running without installing as a package\n\twd = Path(__file__).absolute().parent.parent\n\tsys.path.append(str(wd))\n", "from lit_llama import LLaMA, Tokenizer\n\tfrom lit_llama.utils import quantization\n\tfrom scripts.prepare_alpaca import generate_prompt\n\tfrom generate import generate\n\tdef main(\n\t    prompt: str = \"Hello, my name is\",\n\t    *,\n\t    num_samples: int = 1,\n\t    max_new_tokens: int = 50,\n\t    top_k: int = 200,\n", "    temperature: float = 0.8,\n\t    checkpoint_path: Optional[Path] = None,\n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    model_size: str = \"7B\",\n\t    quantize: Optional[str] = None,\n\t) -> None:\n\t    \"\"\"Generates text samples based on a pre-trained LLaMA model and tokenizer.\n\t    Args:\n\t        prompt: The prompt string to use for generating the samples.\n\t        num_samples: The number of text samples to generate.\n", "        max_new_tokens: The number of generation steps to take.\n\t        top_k: The number of top most probable tokens to consider in the sampling process.\n\t        temperature: A value controlling the randomness of the sampling process. Higher values result in more random\n\t            samples.\n\t        checkpoint_path: The checkpoint path to load.\n\t        tokenizer_path: The tokenizer path to load.\n\t        model_size: The model size to load.\n\t        quantize: Whether to quantize the model and using which method:\n\t            ``\"llm.int8\"``: LLM.int8() mode,\n\t            ``\"gptq.int4\"``: GPTQ 4-bit mode.\n", "    \"\"\"\n\t    if not checkpoint_path:\n\t        checkpoint_path = Path(f\"checkpoints/lit-llama/{model_size}/lit-llama.pth\")\n\t    assert checkpoint_path.is_file(), checkpoint_path\n\t    assert tokenizer_path.is_file(), tokenizer_path\n\t    precision = \"bf16-true\" if torch.cuda.is_available() and torch.cuda.is_bf16_supported() else \"32-true\"\n\t    fabric = L.Fabric(devices=1, precision=precision)\n\t    print(\"Loading model ...\", file=sys.stderr)\n\t    t0 = time.time()\n\t    with fabric.init_module(empty_init=True), quantization(mode=quantize):\n", "        model = LLaMA.from_name(model_size)\n\t    checkpoint = torch.load(checkpoint_path)\n\t    model.load_state_dict(checkpoint)\n\t    print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n\t    model.eval()\n\t    model = fabric.setup(model)\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    sample = {\"instruction\": prompt, \"input\": input}\n\t    prompt = generate_prompt(sample)\n\t    encoded = tokenizer.encode(prompt, bos=True, eos=False, device=fabric.device)\n", "    prompt_length = encoded.size(0)\n\t    L.seed_everything(1234)\n\t    for i in range(num_samples):\n\t        t0 = time.perf_counter()\n\t        y = generate(model, encoded, max_new_tokens, temperature=temperature, top_k=top_k)\n\t        t = time.perf_counter() - t0\n\t        model.reset_cache()\n\t        print(tokenizer.decode(y))\n\t        tokens_generated = y.size(0) - prompt_length\n\t        print(f\"Time for inference {i + 1}: {t:.02f} sec total, {tokens_generated / t:.02f} tokens/sec\", file=sys.stderr)\n", "    if fabric.device.type == \"cuda\":\n\t        print(f\"Memory used: {torch.cuda.max_memory_reserved() / 1e9:.02f} GB\", file=sys.stderr)\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    warnings.filterwarnings(\n\t        # Triggered internally at ../aten/src/ATen/EmptyTensor.cpp:31\n\t        \"ignore\", \n\t        message=\"ComplexHalf support is experimental and many operators don't support it yet\"\n\t    )\n", "    warnings.filterwarnings(\n\t        # Triggered in bitsandbytes/autograd/_functions.py:298\n\t        \"ignore\", \n\t        message=\"MatMul8bitLt: inputs will be cast from torch.bfloat16 to float16 during quantization\",\n\t    )\n\t    CLI(main)\n"]}
{"filename": "generate/adapter_v2.py", "chunked_list": ["import sys\n\timport time\n\timport warnings\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport lightning as L\n\timport torch\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n", "from generate import generate\n\tfrom lit_llama import Tokenizer\n\tfrom lit_llama.adapter import LLaMA\n\tfrom lit_llama.utils import lazy_load, llama_model_lookup, quantization\n\tfrom lit_llama.adapter_v2 import add_adapter_v2_parameters_to_linear_layers\n\tfrom scripts.prepare_alpaca import generate_prompt\n\tdef main(\n\t    prompt: str = \"What food do lamas eat?\",\n\t    input: str = \"\",\n\t    adapter_path: Path = Path(\"out/adapter_v2/alpaca/lit-llama-adapter-finetuned.pth\"),\n", "    pretrained_path: Path = Path(\"checkpoints/lit-llama/7B/lit-llama.pth\"),\n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    quantize: Optional[str] = None,\n\t    max_new_tokens: int = 100,\n\t    top_k: int = 200,\n\t    temperature: float = 0.8,\n\t) -> None:\n\t    \"\"\"Generates a response based on a given instruction and an optional input.\n\t    This script will only work with checkpoints from the instruction-tuned LLaMA-Adapter model.\n\t    See `finetune_adapter_v2.py`.\n", "    Args:\n\t        prompt: The prompt/instruction (Alpaca style).\n\t        adapter_path: Path to the checkpoint with trained adapter weights, which are the output of\n\t            `finetune_adapter_v2.py`.\n\t        input: Optional input (Alpaca style).\n\t        pretrained_path: The path to the checkpoint with pretrained LLaMA weights.\n\t        tokenizer_path: The tokenizer path to load.\n\t        quantize: Whether to quantize the model and using which method:\n\t            ``\"llm.int8\"``: LLM.int8() mode,\n\t            ``\"gptq.int4\"``: GPTQ 4-bit mode.\n", "        max_new_tokens: The number of generation steps to take.\n\t        top_k: The number of top most probable tokens to consider in the sampling process.\n\t        temperature: A value controlling the randomness of the sampling process. Higher values result in more random\n\t            samples.\n\t    \"\"\"\n\t    assert adapter_path.is_file()\n\t    assert pretrained_path.is_file()\n\t    assert tokenizer_path.is_file()\n\t    precision = \"bf16-true\" if torch.cuda.is_available() and torch.cuda.is_bf16_supported() else \"32-true\"\n\t    fabric = L.Fabric(devices=1, precision=precision)\n", "    print(\"Loading model ...\", file=sys.stderr)\n\t    t0 = time.time()\n\t    with lazy_load(pretrained_path) as pretrained_checkpoint, lazy_load(adapter_path) as adapter_checkpoint:\n\t        name = llama_model_lookup(pretrained_checkpoint)\n\t        with fabric.init_module(empty_init=True), quantization(mode=quantize):\n\t            model = LLaMA.from_name(name)\n\t            add_adapter_v2_parameters_to_linear_layers(model)\n\t        # 1. Load the pretrained weights\n\t        model.load_state_dict(pretrained_checkpoint, strict=False)\n\t        # 2. Load the fine-tuned adapter weights\n", "        model.load_state_dict(adapter_checkpoint, strict=False)\n\t    print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n\t    model.eval()\n\t    model = fabric.setup(model)\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    sample = {\"instruction\": prompt, \"input\": input}\n\t    prompt = generate_prompt(sample)\n\t    encoded = tokenizer.encode(prompt, bos=True, eos=False, device=model.device)\n\t    prompt_length = encoded.size(0)\n\t    t0 = time.perf_counter()\n", "    y = generate(model, encoded, max_new_tokens, temperature=temperature, top_k=top_k, eos_id=tokenizer.eos_id)\n\t    t = time.perf_counter() - t0\n\t    model.reset_cache()\n\t    output = tokenizer.decode(y)\n\t    output = output.split(\"### Response:\")[1].strip()\n\t    print(output)\n\t    tokens_generated = y.size(0) - prompt_length\n\t    print(f\"\\n\\nTime for inference: {t:.02f} sec total, {tokens_generated / t:.02f} tokens/sec\", file=sys.stderr)\n\t    if fabric.device.type == \"cuda\":\n\t        print(f\"Memory used: {torch.cuda.max_memory_reserved() / 1e9:.02f} GB\", file=sys.stderr)\n", "if __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    warnings.filterwarnings(\n\t        # Triggered internally at ../aten/src/ATen/EmptyTensor.cpp:31\n\t        \"ignore\", \n\t        message=\"ComplexHalf support is experimental and many operators don't support it yet\"\n\t    )\n\t    CLI(main)\n"]}
{"filename": "generate/adapter.py", "chunked_list": ["import sys\n\timport time\n\timport warnings\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport lightning as L\n\timport torch\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n", "from generate import generate\n\tfrom lit_llama import Tokenizer\n\tfrom lit_llama.adapter import LLaMA\n\tfrom lit_llama.utils import lazy_load, llama_model_lookup, quantization\n\tfrom scripts.prepare_alpaca import generate_prompt\n\tdef main(\n\t    prompt: str = \"What food do lamas eat?\",\n\t    input: str = \"\",\n\t    adapter_path: Path = Path(\"out/adapter/alpaca/lit-llama-adapter-finetuned.pth\"),\n\t    pretrained_path: Path = Path(\"checkpoints/lit-llama/7B/lit-llama.pth\"),\n", "    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    quantize: Optional[str] = None,\n\t    max_new_tokens: int = 100,\n\t    top_k: int = 200,\n\t    temperature: float = 0.8,\n\t) -> None:\n\t    \"\"\"Generates a response based on a given instruction and an optional input.\n\t    This script will only work with checkpoints from the instruction-tuned LLaMA-Adapter model.\n\t    See `finetune_adapter.py`.\n\t    Args:\n", "        prompt: The prompt/instruction (Alpaca style).\n\t        adapter_path: Path to the checkpoint with trained adapter weights, which are the output of\n\t            `finetune_adapter.py`.\n\t        input: Optional input (Alpaca style).\n\t        pretrained_path: The path to the checkpoint with pretrained LLaMA weights.\n\t        tokenizer_path: The tokenizer path to load.\n\t        quantize: Whether to quantize the model and using which method:\n\t            ``\"llm.int8\"``: LLM.int8() mode,\n\t            ``\"gptq.int4\"``: GPTQ 4-bit mode.\n\t        max_new_tokens: The number of generation steps to take.\n", "        top_k: The number of top most probable tokens to consider in the sampling process.\n\t        temperature: A value controlling the randomness of the sampling process. Higher values result in more random\n\t            samples.\n\t    \"\"\"\n\t    assert adapter_path.is_file()\n\t    assert pretrained_path.is_file()\n\t    assert tokenizer_path.is_file()\n\t    precision = \"bf16-true\" if torch.cuda.is_available() and torch.cuda.is_bf16_supported() else \"32-true\"\n\t    fabric = L.Fabric(devices=1, precision=precision)\n\t    print(\"Loading model ...\", file=sys.stderr)\n", "    t0 = time.time()\n\t    with lazy_load(pretrained_path) as pretrained_checkpoint, lazy_load(adapter_path) as adapter_checkpoint:\n\t        name = llama_model_lookup(pretrained_checkpoint)\n\t        with fabric.init_module(empty_init=True), quantization(mode=quantize):\n\t            model = LLaMA.from_name(name)\n\t        # 1. Load the pretrained weights\n\t        model.load_state_dict(pretrained_checkpoint, strict=False)\n\t        # 2. Load the fine-tuned adapter weights\n\t        model.load_state_dict(adapter_checkpoint, strict=False)\n\t    print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n", "    model.eval()\n\t    model = fabric.setup(model)\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    sample = {\"instruction\": prompt, \"input\": input}\n\t    prompt = generate_prompt(sample)\n\t    encoded = tokenizer.encode(prompt, bos=True, eos=False, device=model.device)\n\t    prompt_length = encoded.size(0)\n\t    t0 = time.perf_counter()\n\t    y = generate(model, encoded, max_new_tokens, temperature=temperature, top_k=top_k, eos_id=tokenizer.eos_id)\n\t    t = time.perf_counter() - t0\n", "    model.reset_cache()\n\t    output = tokenizer.decode(y)\n\t    output = output.split(\"### Response:\")[1].strip()\n\t    print(output)\n\t    tokens_generated = y.size(0) - prompt_length\n\t    print(f\"\\n\\nTime for inference: {t:.02f} sec total, {tokens_generated / t:.02f} tokens/sec\", file=sys.stderr)\n\t    if fabric.device.type == \"cuda\":\n\t        print(f\"Memory used: {torch.cuda.max_memory_reserved() / 1e9:.02f} GB\", file=sys.stderr)\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n", "    torch.set_float32_matmul_precision(\"high\")\n\t    warnings.filterwarnings(\n\t        # Triggered internally at ../aten/src/ATen/EmptyTensor.cpp:31\n\t        \"ignore\", \n\t        message=\"ComplexHalf support is experimental and many operators don't support it yet\"\n\t    )\n\t    CLI(main)\n"]}
{"filename": "generate/lora.py", "chunked_list": ["import sys\n\timport time\n\timport warnings\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport lightning as L\n\timport torch\n\t# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n", "from generate import generate\n\tfrom lit_llama import Tokenizer, LLaMA\n\tfrom lit_llama.lora import lora\n\tfrom lit_llama.utils import lazy_load, llama_model_lookup\n\tfrom scripts.prepare_alpaca import generate_prompt\n\tlora_r = 8\n\tlora_alpha = 16\n\tlora_dropout = 0.05\n\tdef main(\n\t    prompt: str = \"What food do lamas eat?\",\n", "    input: str = \"\",\n\t    lora_path: Path = Path(\"out/lora/alpaca/lit-llama-lora-finetuned.pth\"),\n\t    pretrained_path: Path = Path(\"checkpoints/lit-llama/7B/lit-llama.pth\"),\n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    quantize: Optional[str] = None,\n\t    max_new_tokens: int = 100,\n\t    top_k: int = 200,\n\t    temperature: float = 0.8,\n\t) -> None:\n\t    \"\"\"Generates a response based on a given instruction and an optional input.\n", "    This script will only work with checkpoints from the instruction-tuned LoRA model.\n\t    See `finetune_lora.py`.\n\t    Args:\n\t        prompt: The prompt/instruction (Alpaca style).\n\t        lora_path: Path to the checkpoint with trained LoRA weights, which are the output of\n\t            `finetune_lora.py`.\n\t        input: Optional input (Alpaca style).\n\t        pretrained_path: The path to the checkpoint with pretrained LLaMA weights.\n\t        tokenizer_path: The tokenizer path to load.\n\t        quantize: Whether to quantize the model and using which method:\n", "            ``\"llm.int8\"``: LLM.int8() mode,\n\t            ``\"gptq.int4\"``: GPTQ 4-bit mode.\n\t        max_new_tokens: The number of generation steps to take.\n\t        top_k: The number of top most probable tokens to consider in the sampling process.\n\t        temperature: A value controlling the randomness of the sampling process. Higher values result in more random\n\t            samples.\n\t    \"\"\"\n\t    assert lora_path.is_file()\n\t    assert pretrained_path.is_file()\n\t    assert tokenizer_path.is_file()\n", "    if quantize is not None:\n\t        raise NotImplementedError(\"Quantization in LoRA is not supported yet\")\n\t    precision = \"bf16-true\" if torch.cuda.is_available() and torch.cuda.is_bf16_supported() else \"32-true\"\n\t    fabric = L.Fabric(devices=1, precision=precision)\n\t    print(\"Loading model ...\", file=sys.stderr)\n\t    t0 = time.time()\n\t    with lazy_load(pretrained_path) as pretrained_checkpoint, lazy_load(lora_path) as lora_checkpoint:\n\t        name = llama_model_lookup(pretrained_checkpoint)\n\t        with fabric.init_module(empty_init=True), lora(r=lora_r, alpha=lora_alpha, dropout=lora_dropout, enabled=True):\n\t            model = LLaMA.from_name(name)\n", "            # 1. Load the pretrained weights\n\t            model.load_state_dict(pretrained_checkpoint, strict=False)\n\t            # 2. Load the fine-tuned lora weights\n\t            model.load_state_dict(lora_checkpoint, strict=False)\n\t    print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n\t    model.eval()\n\t    model = fabric.setup(model)\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    sample = {\"instruction\": prompt, \"input\": input}\n\t    prompt = generate_prompt(sample)\n", "    encoded = tokenizer.encode(prompt, bos=True, eos=False, device=model.device)\n\t    t0 = time.perf_counter()\n\t    output = generate(\n\t        model,\n\t        idx=encoded,\n\t        max_new_tokens=max_new_tokens,\n\t        temperature=temperature,\n\t        top_k=top_k,\n\t        eos_id=tokenizer.eos_id\n\t    )\n", "    t = time.perf_counter() - t0\n\t    output = tokenizer.decode(output)\n\t    output = output.split(\"### Response:\")[1].strip()\n\t    print(output)\n\t    print(f\"\\n\\nTime for inference: {t:.02f} sec total, {max_new_tokens / t:.02f} tokens/sec\", file=sys.stderr)\n\t    if fabric.device.type == \"cuda\":\n\t        print(f\"Memory used: {torch.cuda.max_memory_reserved() / 1e9:.02f} GB\", file=sys.stderr)\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    torch.set_float32_matmul_precision(\"high\")\n", "    warnings.filterwarnings(\n\t        # Triggered internally at ../aten/src/ATen/EmptyTensor.cpp:31\n\t        \"ignore\", \n\t        message=\"ComplexHalf support is experimental and many operators don't support it yet\"\n\t    )\n\t    CLI(main)\n"]}
{"filename": "tests/test_prepare_shakespeare.py", "chunked_list": ["import os\n\timport subprocess\n\timport sys\n\tfrom pathlib import Path\n\twd = (Path(__file__).parent.parent / \"scripts\").absolute()\n\tdef test_prepare(tmp_path):\n\t    sys.path.append(str(wd))\n\t    import prepare_shakespeare\n\t    prepare_shakespeare.prepare(tmp_path)\n\t    assert set(os.listdir(tmp_path)) == {\"train.bin\", \"tokenizer.model\", \"tokenizer.vocab\", \"input.txt\", \"val.bin\"}\n", "def test_cli():\n\t    cli_path = wd / \"prepare_shakespeare.py\"\n\t    output = subprocess.check_output([sys.executable, cli_path, \"-h\"])\n\t    output = str(output.decode())\n\t    assert 'Prepare the \"Tiny Shakespeare\"' in output\n"]}
{"filename": "tests/test_adapter.py", "chunked_list": ["from dataclasses import asdict\n\timport pytest\n\timport sys\n\timport torch\n\t@pytest.mark.skipif(sys.platform == \"win32\", reason=\"EmptyInitOnDevice on CPU not working for Windows.\")\n\t@pytest.mark.parametrize(\"model_size\", [\"7B\", \"13B\", \"30B\", \"65B\"])\n\tdef test_config_identical(model_size, lit_llama):\n\t    import lit_llama.adapter as llama_adapter\n\t    import lit_llama.model as llama\n\t    from lit_llama.utils import EmptyInitOnDevice\n", "    llama_config = asdict(llama.LLaMAConfig.from_name(model_size))\n\t    adapter_config = asdict(llama_adapter.LLaMAConfig.from_name(model_size))\n\t    del adapter_config[\"adapter_prompt_length\"]\n\t    del adapter_config[\"adapter_start_layer\"]\n\t    assert adapter_config == llama_config\n\t    with EmptyInitOnDevice():\n\t        llama_model = llama.LLaMA.from_name(model_size)\n\t        adapter_model = llama_adapter.LLaMA.from_name(model_size)\n\t        assert llama_model.lm_head.weight.shape == adapter_model.lm_head.weight.shape\n\tdef test_adapter_load_gating_factor(lit_llama):\n", "    \"\"\"Tests backward-compatible loading of checkpoints after the `gating_factor` was extended per-head\n\t    in PR #297.\n\t    \"\"\"\n\t    import lit_llama.adapter as llama_adapter\n\t    from lit_llama.utils import lazy_load\n\t    config = llama_adapter.LLaMAConfig(n_head=4, block_size=100, n_embd=16)\n\t    attn = llama_adapter.CausalSelfAttention(config=config, block_idx=3)\n\t    # Old checkpoint format\n\t    state_dict={\n\t        \"gating_factor\": torch.tensor(0.42),  # in old checkpoints, this was a scalar\n", "        \"c_attn.weight\": torch.zeros(3 * 16, 16),\n\t        \"c_proj.weight\": torch.zeros(16, 16),\n\t        \"adapter_wte.weight\": torch.zeros(10, 16),\n\t    }\n\t    attn.load_state_dict(state_dict=state_dict)\n\t    assert torch.equal(attn.gating_factor, torch.full((1, 4, 1, 1), 0.42))\n\t    # New checkpoint format\n\t    state_dict={\n\t        \"gating_factor\": torch.tensor([0.42, 0.42, 0.42, 0.42]).reshape(1, 4, 1, 1),\n\t        \"c_attn.weight\": torch.zeros(3 * 16, 16),\n", "        \"c_proj.weight\": torch.zeros(16, 16),\n\t        \"adapter_wte.weight\": torch.zeros(10, 16),\n\t    }\n\t    attn.load_state_dict(state_dict=state_dict)\n\t    assert torch.equal(attn.gating_factor, torch.full((1, 4, 1, 1), 0.42))\n"]}
{"filename": "tests/test_generate.py", "chunked_list": ["import functools\n\timport subprocess\n\timport sys\n\tfrom contextlib import contextmanager, redirect_stdout\n\tfrom io import StringIO\n\tfrom pathlib import Path\n\tfrom unittest import mock\n\tfrom unittest.mock import Mock, call, ANY\n\timport torch\n\twd = Path(__file__).parent.parent.absolute()\n", "@functools.lru_cache(maxsize=1)\n\tdef load_generate_script():\n\t    sys.path.append(str(wd))\n\t    import generate as generate\n\t    return generate\n\tdef test_generate():\n\t    generate = load_generate_script()\n\t    from lit_llama.model import LLaMA, LLaMAConfig\n\t    T, C = 5, 3\n\t    logits = torch.randn(T, C)\n", "    input_idx = torch.randint(10, size=(T,))\n\t    config = LLaMAConfig(block_size=128, vocab_size=16, n_layer=1, n_head=4, n_embd=8)\n\t    model = LLaMA(config)\n\t    max_new_tokens = 20\n\t    multinomial_results = []\n\t    original_multinomial = torch.multinomial\n\t    def multinomial(*args, **kwargs):\n\t        out = original_multinomial(*args, **kwargs)\n\t        multinomial_results.append(out)\n\t        return out\n", "    with mock.patch(\"torch.multinomial\", multinomial):\n\t        out = generate.generate(model, input_idx, max_new_tokens, max_seq_length=10, top_k=4)\n\t    assert out.size(0) == T + max_new_tokens\n\t    multinomial_results = torch.hstack(multinomial_results)\n\t    expected = torch.cat((input_idx, multinomial_results))\n\t    assert out.shape == expected.shape\n\t    torch.testing.assert_close(out, expected)\n\t@mock.patch(\"torch.cuda.is_bf16_supported\", return_value=False)\n\tdef test_main(tmp_path, monkeypatch):\n\t    generate = load_generate_script()\n", "    checkpoint_path = tmp_path / \"ckpt\"\n\t    checkpoint_path.touch()\n\t    tokenizer_path = tmp_path / \"tokenizer\"\n\t    tokenizer_path.touch()\n\t    class FabricMock(Mock):\n\t        @property\n\t        def device(self):\n\t            return torch.device(\"cpu\")\n\t        @contextmanager\n\t        def init_module(self, empty_init):\n", "            yield\n\t    monkeypatch.setattr(generate.L, \"Fabric\", FabricMock)\n\t    model_mock = Mock()\n\t    monkeypatch.setattr(generate.LLaMA, \"from_name\", model_mock)\n\t    lookup_mock = Mock(return_value=\"1T\")\n\t    monkeypatch.setattr(generate, \"llama_model_lookup\", lookup_mock)\n\t    load_mock = Mock()\n\t    load_mock.return_value = load_mock\n\t    load_mock.__enter__ = Mock()\n\t    load_mock.__exit__ = Mock()\n", "    monkeypatch.setattr(generate.torch, \"load\", load_mock)\n\t    monkeypatch.setattr(generate, \"lazy_load\", load_mock)\n\t    tokenizer_mock = Mock()\n\t    tokenizer_mock.return_value.encode.return_value = torch.tensor([[1, 2, 3]])\n\t    tokenizer_mock.return_value.decode.return_value = \"foo bar baz\"\n\t    monkeypatch.setattr(generate, \"Tokenizer\", tokenizer_mock)\n\t    generate_mock = Mock()\n\t    generate_mock.return_value = torch.tensor([[3, 2, 1]])\n\t    monkeypatch.setattr(generate, \"generate\", generate_mock)\n\t    num_samples = 2\n", "    out = StringIO()\n\t    with redirect_stdout(out):\n\t        generate.main(\n\t            checkpoint_path=checkpoint_path,\n\t            tokenizer_path=tokenizer_path,\n\t            temperature=2.0,\n\t            top_k=2,\n\t            num_samples=num_samples,\n\t        )\n\t    model_mock.assert_called_once_with(\"1T\")\n", "    load_mock.assert_called_once_with(checkpoint_path)\n\t    tokenizer_mock.assert_called_once_with(tokenizer_path)\n\t    assert len(tokenizer_mock.return_value.decode.mock_calls) == num_samples\n\t    assert torch.allclose(tokenizer_mock.return_value.decode.call_args[0][0], generate_mock.return_value)\n\t    assert generate_mock.mock_calls == [call(ANY, ANY, 50, temperature=2.0, top_k=2)] * num_samples\n\t    # only the generated result is printed to stdout\n\t    assert out.getvalue() == \"foo bar baz\\n\" * num_samples\n\tdef test_cli():\n\t    cli_path = wd / \"generate.py\"\n\t    output = subprocess.check_output([sys.executable, cli_path, \"-h\"])\n", "    output = str(output.decode())\n\t    assert \"Generates text samples\" in output\n"]}
{"filename": "tests/test_rope.py", "chunked_list": ["import torch\n\t@torch.no_grad()\n\tdef test_rope(lit_llama, orig_llama) -> None:\n\t    torch.manual_seed(1)\n\t    bs, seq_len, n_head, n_embed = 1, 6, 2, 8\n\t    x = torch.randint(0, 10000, size=(bs, seq_len, n_head, n_embed // n_head)).float()\n\t    freqs_cis = orig_llama.precompute_freqs_cis(n_embed // n_head, seq_len)\n\t    llama_rope_cache = lit_llama.build_rope_cache(seq_len, n_embed // n_head, dtype=x.dtype, device=x.device)\n\t    torch.testing.assert_close(freqs_cis, torch.view_as_complex(llama_rope_cache))\n\t    llama_x_rope = lit_llama.apply_rope(x, llama_rope_cache)\n", "    orig_llama_x_rope, _ = orig_llama.apply_rotary_emb(x, x, freqs_cis)\n\t    torch.testing.assert_close(llama_x_rope, orig_llama_x_rope)\n"]}
{"filename": "tests/test_lora.py", "chunked_list": ["import torch\n\tdef test_lora_layer_replacement(lit_llama):\n\t    from lit_llama.lora import lora, CausalSelfAttention as LoRACausalSelfAttention\n\t    from lit_llama.model import LLaMA, LLaMAConfig\n\t    config = LLaMAConfig()\n\t    config.n_layer = 2\n\t    config.n_head = 4\n\t    config.n_embd = 8\n\t    config.block_size = 8\n\t    config.vocab_size = 8\n", "    with lora(r=8, alpha=8, dropout=0.1):\n\t        model = LLaMA(config)\n\t    assert isinstance(model.transformer.h[0].attn, LoRACausalSelfAttention)\n\t    assert isinstance(model.transformer.h[1].attn, LoRACausalSelfAttention)\n\tdef test_lora_merge_unmerge(lit_llama):\n\t    from lit_llama.lora import lora, mark_only_lora_as_trainable\n\t    from lit_llama.model import LLaMA, LLaMAConfig\n\t    config = LLaMAConfig(n_layer=1, n_head=2, n_embd=8, block_size=8, vocab_size=8)\n\t    with lora(r=8, alpha=8, dropout=0.1):\n\t        model = LLaMA(config)\n", "    initial_weight = model.transformer.h[0].attn.c_attn.weight.clone()\n\t    model.train()\n\t    assert torch.equal(model.transformer.h[0].attn.c_attn.weight, initial_weight)\n\t    # perform an update to the LoRA weights\n\t    mark_only_lora_as_trainable(model)\n\t    optimizer = torch.optim.SGD(model.parameters(), lr=1.0)\n\t    model(torch.randint(0, 8, size=(2, 4), dtype=torch.int64)).sum().backward()\n\t    optimizer.step()\n\t    optimizer.zero_grad()\n\t    # the weight remains unchanged (only lora A and B change)\n", "    assert torch.equal(model.transformer.h[0].attn.c_attn.weight, initial_weight)\n\t    # 'merge' and then 'unmerge' should neutralize themselves\n\t    weight_before = model.transformer.h[0].attn.c_attn.weight.clone()\n\t    model.eval()\n\t    assert not torch.equal(model.transformer.h[0].attn.c_attn.weight, weight_before)\n\t    model.train()\n\t    # note: numerically, `W + (A * B) - (A * B) == W` does not hold exactly\n\t    assert torch.allclose(model.transformer.h[0].attn.c_attn.weight, weight_before)\n\t    # calling eval/train multiple times in a row should not merge/unmerge multiple times\n\t    model.eval()\n", "    assert model.transformer.h[0].attn.c_attn.merged\n\t    weight_after = model.transformer.h[0].attn.c_attn.weight.clone()\n\t    model.eval()\n\t    model.eval()\n\t    assert torch.equal(model.transformer.h[0].attn.c_attn.weight, weight_after)\n\t    model.train()\n\t    assert not model.transformer.h[0].attn.c_attn.merged\n\t    weight_after = model.transformer.h[0].attn.c_attn.weight.clone()\n\t    model.train()\n\t    model.train()\n", "    assert torch.equal(model.transformer.h[0].attn.c_attn.weight, weight_after)\n"]}
{"filename": "tests/test_prepare_redpajama.py", "chunked_list": ["import json\n\timport os\n\timport subprocess\n\timport sys\n\tfrom pathlib import Path\n\tfrom unittest import mock\n\tfrom unittest.mock import Mock, call, ANY\n\twd = (Path(__file__).parent.parent / \"scripts\").absolute()\n\timport requests\n\tdef train_tokenizer(destination_path):\n", "    destination_path.mkdir(parents=True, exist_ok=True)\n\t    # download the tiny shakespeare dataset\n\t    input_file_path = destination_path / \"input.txt\"\n\t    if not input_file_path.exists():\n\t        data_url = \"https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt\"\n\t        with open(input_file_path, \"w\") as f:\n\t            f.write(requests.get(data_url).text)\n\t    from lit_llama import Tokenizer\n\t    Tokenizer.train(input=input_file_path, destination=destination_path, vocab_size=100)\n\t    return destination_path / \"tokenizer.model\"\n", "def test_prepare_sample(tmp_path):\n\t    sys.path.append(str(wd))\n\t    tokenizer_path = train_tokenizer(tmp_path)\n\t    sample_path = tmp_path / \"sample\"\n\t    source_path = sample_path / \"source\"\n\t    dest_path = sample_path / \"dest\"\n\t    source_path.mkdir(parents=True, exist_ok=True)\n\t    sample = {\n\t        \"meta\": {\"some\": \"info\"},\n\t        \"text\": \"some text\"\n", "    }\n\t    jsonl_sample = \"\\n\".join([json.dumps(el) for el in [sample] * 2])\n\t    import prepare_redpajama\n\t    for filename in prepare_redpajama.filenames_sample:\n\t        with open(source_path / filename, \"w\") as f:\n\t            f.write(jsonl_sample)\n\t    prepare_redpajama.prepare(source_path=source_path, tokenizer_path=tokenizer_path, destination_path=dest_path, sample=True)\n\t    bin_files = [el.replace(\".jsonl\", \"_0000000000.bin\") for el in prepare_redpajama.filenames_sample]\n\t    assert set(os.listdir(dest_path)) == set(bin_files)\n\t    from lit_llama import Tokenizer\n", "    from lit_llama.packed_dataset import PackedDataset\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    # artificially set block_size to fit the text\n\t    block_size = len(tokenizer.encode(\"some text\"))\n\t    for filename in bin_files:\n\t        filenames = [os.path.join(dest_path, filename)]\n\t        dataset = PackedDataset(filenames=filenames, n_chunks=1, block_size=block_size, shuffle=False)\n\t        dataset_iter = iter(dataset)\n\t        assert tokenizer.decode(next(dataset_iter)) == \"some text\"\n\t        assert tokenizer.decode(next(dataset_iter)) == \"some text\"\n", "def test_prepare_full(tmp_path):\n\t    sys.path.append(str(wd))\n\t    tokenizer_path = train_tokenizer(tmp_path)\n\t    full_path = tmp_path / \"full\"\n\t    source_path = full_path / \"source\"\n\t    dest_path = full_path / \"dest\"\n\t    source_path.mkdir(parents=True, exist_ok=True)\n\t    sample = {\n\t        \"meta\": {\"some\": \"info\"},\n\t        \"text\": \"some text\"\n", "    }\n\t    jsonl_sample = \"\\n\".join([json.dumps(el) for el in [sample] * 2])\n\t    import prepare_redpajama\n\t    arxiv_file = source_path / \"arxiv\" / \"arxiv_0.jsonl\"\n\t    arxiv_file.parent.mkdir(parents=True, exist_ok=True)\n\t    with open(arxiv_file, \"w\") as f:\n\t        f.write(jsonl_sample)\n\t    import zstandard as zstd\n\t    cc_file = source_path / \"common_crawl\" / \"cc_0.jsonl\"\n\t    cc_file.parent.mkdir(parents=True, exist_ok=True)\n", "    with zstd.open(cc_file, \"wt\", encoding=\"utf-8\") as f:\n\t        f.write(jsonl_sample)\n\t    filename_sets = {\n\t        \"arxiv\": \"arxiv/arxiv*\",\n\t        \"common_crawl\": \"common_crawl/*\",\n\t    }\n\t    with mock.patch(\"prepare_redpajama.filename_sets\", filename_sets):\n\t        prepare_redpajama.prepare(source_path=source_path, tokenizer_path=tokenizer_path, destination_path=dest_path, sample=False)\n\t        all_names = prepare_redpajama.filename_sets.keys()\n\t        bin_files = [el + \"_0000000000.bin\" for el in all_names]\n", "    assert set(os.listdir(dest_path)) == set(bin_files)\n\t    from lit_llama import Tokenizer\n\t    from lit_llama.packed_dataset import PackedDataset\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    # artificially set block_size to fit the text\n\t    block_size = len(tokenizer.encode(\"some text\"))\n\t    filenames = [os.path.join(dest_path, el) for el in bin_files]\n\t    for filename in filenames:\n\t        dataset = PackedDataset(filenames=[filename], n_chunks=1, block_size=block_size, shuffle=False)\n\t        dataset_iter = iter(dataset)\n", "        assert tokenizer.decode(next(dataset_iter)) == \"some text\"\n\t        assert tokenizer.decode(next(dataset_iter)) == \"some text\"\n\tdef test_cli():\n\t    cli_path = wd / \"prepare_redpajama.py\"\n\t    output = subprocess.check_output([sys.executable, cli_path, \"-h\"])\n\t    output = str(output.decode())\n\t    assert 'Prepare the \"Red Pajama\"' in output\n"]}
{"filename": "tests/test_adapter_v2.py", "chunked_list": ["import pytest\n\timport sys\n\t@pytest.mark.skipif(sys.platform == \"win32\", reason=\"EmptyInitOnDevice on CPU not working for Windows.\")\n\t@pytest.mark.parametrize(\"model_size\", [\"7B\", \"13B\", \"30B\", \"65B\"])\n\tdef test_config_identical(model_size, lit_llama):\n\t    import torch.nn as nn\n\t    import lit_llama.adapter as llama_adapter\n\t    from lit_llama.adapter_v2 import adapter_v2_linear_with_bias_and_scale\n\t    import lit_llama.model as llama\n\t    from lit_llama.utils import EmptyInitOnDevice\n", "    with EmptyInitOnDevice():\n\t        llama_model = llama.LLaMA.from_name(model_size)\n\t        adapter_model = llama_adapter.LLaMA.from_name(model_size)\n\t        for module in adapter_model.modules():\n\t            if isinstance(module, nn.Linear):\n\t                adapter_v2_linear_with_bias_and_scale(module)\n\t        print(adapter_model.transformer.h[2].attn.c_attn.adapter_bias)\n\t        assert not hasattr(llama_model.transformer.h[2].attn.c_attn, 'adapter_bias')\n\t        assert not hasattr(llama_model.transformer.h[2].attn.c_attn, 'adapter_scale')\n\t        assert hasattr(adapter_model.transformer.h[2].attn.c_attn, 'adapter_bias')\n", "        assert hasattr(adapter_model.transformer.h[2].attn.c_attn, 'adapter_scale')"]}
{"filename": "tests/test_model.py", "chunked_list": ["import torch\n\timport pytest\n\timport sys\n\tdef copy_mlp(llama_mlp, orig_llama_mlp) -> None:\n\t    orig_llama_mlp.w1.weight.copy_(llama_mlp.c_fc1.weight)\n\t    orig_llama_mlp.w3.weight.copy_(llama_mlp.c_fc2.weight)\n\t    orig_llama_mlp.w2.weight.copy_(llama_mlp.c_proj.weight)\n\tdef copy_attention(llama_attn, orig_llama_attn) -> None:\n\t    n_embd = llama_attn.c_attn.weight.shape[1]\n\t    orig_llama_attn.wq.weight.copy_(llama_attn.c_attn.weight[:n_embd])\n", "    orig_llama_attn.wk.weight.copy_(llama_attn.c_attn.weight[n_embd:-n_embd])\n\t    orig_llama_attn.wv.weight.copy_(llama_attn.c_attn.weight[-n_embd:])\n\t    orig_llama_attn.wo.weight.copy_(llama_attn.c_proj.weight)\n\tdef copy_block(llama_block, orig_llama_block) -> None:\n\t    orig_llama_block.attention_norm.weight.copy_(llama_block.rms_1.scale)\n\t    copy_attention(llama_block.attn, orig_llama_block.attention)\n\t    orig_llama_block.ffn_norm.weight.copy_(llama_block.rms_2.scale)\n\t    copy_mlp(llama_block.mlp, orig_llama_block.feed_forward)\n\tdef copy_weights(llama_model, orig_llama_model) -> None:\n\t    orig_llama_model.tok_embeddings.weight.copy_(llama_model.transformer.wte.weight)\n", "    for llama_block, orig_llama_block in zip(llama_model.transformer.h, orig_llama_model.layers):\n\t        copy_block(llama_block, orig_llama_block)\n\t    orig_llama_model.norm.weight.copy_(llama_model.transformer.ln_f.scale)\n\t    orig_llama_model.output.weight.copy_(llama_model.lm_head.weight)\n\t@torch.no_grad()\n\t@pytest.mark.parametrize(\"kv_cache\", (False, True))\n\tdef test_to_orig_llama(lit_llama, orig_llama, kv_cache) -> None:\n\t    block_size = 64\n\t    vocab_size = 32000\n\t    n_layer = 16\n", "    n_head = 16\n\t    n_embd = 32\n\t    batch_size = 3\n\t    llama_config = lit_llama.LLaMAConfig(\n\t        block_size=block_size, vocab_size=vocab_size, n_layer=n_layer, n_head=n_head, n_embd=n_embd\n\t    )\n\t    orig_llama_config = orig_llama.ModelArgs(\n\t        dim=n_embd,\n\t        n_layers=n_layer,\n\t        n_heads=n_head,\n", "        vocab_size=vocab_size,\n\t        norm_eps=1e-5,\n\t        max_seq_len=block_size,\n\t        max_batch_size=batch_size,\n\t    )\n\t    seq_len = orig_llama_config.max_seq_len\n\t    token_sample = torch.randint(0, orig_llama_config.vocab_size, size=(batch_size, seq_len), dtype=torch.int64)\n\t    llama_model = lit_llama.LLaMA(llama_config)\n\t    llama_model.apply(llama_model._init_weights)\n\t    orig_llama_model = orig_llama.Transformer(orig_llama_config)\n", "    copy_weights(llama_model, orig_llama_model)\n\t    orig_llama_embed = orig_llama_model.tok_embeddings(token_sample)\n\t    llama_embed = llama_model.transformer.wte(token_sample)\n\t    assert torch.allclose(orig_llama_embed, llama_embed)\n\t    llama_rope = llama_model.build_rope_cache(token_sample)\n\t    llama_mask = llama_model.build_mask_cache(token_sample)\n\t    orig_llama_mask = torch.full((1, 1, seq_len, seq_len), float(\"-inf\"))\n\t    orig_llama_mask = torch.triu(orig_llama_mask, diagonal=1)\n\t    if kv_cache:\n\t        orig_llama_block_out = orig_llama_model.layers[0](\n", "            orig_llama_embed, 0, orig_llama_model.freqs_cis[:seq_len], orig_llama_mask\n\t        )\n\t        theirs_k_cache = orig_llama_model.layers[0].attention.cache_k\n\t        theirs_v_cache = orig_llama_model.layers[0].attention.cache_v\n\t        head_size = n_embd // n_head\n\t        kv_cache_shape = (batch_size, n_head, block_size, head_size)\n\t        ours_kv_cache = torch.zeros(kv_cache_shape), torch.zeros(kv_cache_shape)\n\t        (llama_block_out, ours_kv_cache) = llama_model.transformer.h[0](\n\t            llama_embed, llama_rope, llama_mask, seq_len, torch.arange(block_size), ours_kv_cache\n\t        )\n", "        ours_k_cache = ours_kv_cache[0].permute(0, 2, 1, 3)\n\t        ours_v_cache = ours_kv_cache[1].permute(0, 2, 1, 3)\n\t        torch.testing.assert_close(ours_k_cache, theirs_k_cache)\n\t        torch.testing.assert_close(ours_v_cache, theirs_v_cache)\n\t    else:\n\t        orig_llama_block_out = orig_llama_model.layers[0](\n\t            orig_llama_embed, 0, orig_llama_model.freqs_cis[:seq_len], orig_llama_mask\n\t        )\n\t        (llama_block_out, _) = llama_model.transformer.h[0](llama_embed, llama_rope, llama_mask, seq_len)\n\t    assert torch.allclose(orig_llama_block_out, llama_block_out)\n", "    expected = orig_llama_model(token_sample, 0)\n\t    out = llama_model(token_sample)\n\t    assert torch.allclose(out, expected)\n\t@pytest.mark.skipif(not torch.cuda.is_available(), reason=\"Requires CUDA\")\n\t@torch.no_grad()\n\tdef test_bfloat16_llama_init(lit_llama, orig_llama) -> None:\n\t    from lit_llama.utils import EmptyInitOnDevice\n\t    block_size = 64\n\t    vocab_size = 32000\n\t    n_layer = 16\n", "    n_head = 16\n\t    n_embd = 32\n\t    llama_config = lit_llama.LLaMAConfig(\n\t        block_size=block_size, vocab_size=vocab_size, n_layer=n_layer, n_head=n_head, n_embd=n_embd\n\t    )\n\t    llama_model = lit_llama.LLaMA(llama_config)\n\t    llama_model.apply(llama_model._init_weights)\n\t    batch_size = 3\n\t    token_sample = torch.randint(0, vocab_size, size=(batch_size, block_size), dtype=torch.int64)\n\t    expected = llama_model(token_sample)\n", "    with EmptyInitOnDevice(device=\"cuda\", dtype=torch.bfloat16):\n\t        llama_model2 = lit_llama.LLaMA(llama_config)\n\t    llama_model2.load_state_dict(llama_model.state_dict(keep_vars=True))\n\t    out = llama_model2(token_sample.cuda()).float().cpu()\n\t    torch.testing.assert_close(out, expected, atol=5e-3, rtol=1e-3)\n\tdef copy_adapter_weights(llama_model, orig_llama_model) -> None:\n\t    # copy the gating parameter\n\t    for llama_block, orig_llama_block in zip(llama_model.transformer.h, orig_llama_model.layers):\n\t        if hasattr(llama_block.attn, \"gating_factor\"):\n\t            llama_block.attn.gating_factor.copy_(orig_llama_block.attention.gate)\n", "    # In the original model, there is one embedding layer for all blocks combined\n\t    orig_adapter_wte = orig_llama_model.adapter_query.weight.reshape(\n\t        orig_llama_model.params.adapter_layer, orig_llama_model.params.adapter_len, orig_llama_model.params.dim\n\t    )\n\t    # In ours, the embedding layer is split across the individual attention layers\n\t    index = 0\n\t    for llama_block in llama_model.transformer.h:\n\t        if hasattr(llama_block.attn, \"adapter_wte\"):\n\t            llama_block.attn.adapter_wte.weight.copy_(orig_adapter_wte[index])\n\t            index += 1\n", "def enable_gate(model):\n\t    for name, param in model.named_parameters():\n\t        if \"gating_factor\" in name or \"gate\" in name:\n\t            param.fill_(1)\n\t@torch.no_grad()\n\tdef test_adapter_parity(orig_llama_adapter):\n\t    \"\"\"Test parity between our implementation of LLaMA-Adapter and the reference code.\"\"\"\n\t    import lit_llama.adapter as lit_llama\n\t    orig_llama = orig_llama_adapter\n\t    block_size = 32\n", "    vocab_size = 100\n\t    n_layer = 2\n\t    n_head = 4\n\t    n_embd = 16\n\t    adapter_prompt_length: int = 10\n\t    adapter_start_layer: int = 0\n\t    llama_config = lit_llama.LLaMAConfig(\n\t        block_size=block_size,\n\t        vocab_size=vocab_size,\n\t        n_layer=n_layer,\n", "        n_head=n_head,\n\t        n_embd=n_embd,\n\t        adapter_prompt_length=adapter_prompt_length,\n\t        adapter_start_layer=adapter_start_layer,\n\t    )\n\t    orig_llama_config = orig_llama.ModelArgs(\n\t        dim=n_embd,\n\t        n_layers=n_layer,\n\t        n_heads=n_head,\n\t        vocab_size=vocab_size,\n", "        norm_eps=1e-5,\n\t        max_seq_len=block_size,\n\t        adapter_len=adapter_prompt_length,\n\t        adapter_layer=(n_layer - adapter_start_layer),\n\t    )\n\t    batch_size = 3\n\t    token_sample = torch.randint(\n\t        0, orig_llama_config.vocab_size, size=(batch_size, orig_llama_config.max_seq_len), dtype=torch.int64\n\t    )\n\t    llama_model = lit_llama.LLaMA(llama_config)\n", "    llama_model.apply(llama_model._init_weights)\n\t    orig_llama_model = orig_llama.Transformer(orig_llama_config)\n\t    copy_weights(llama_model, orig_llama_model)\n\t    copy_adapter_weights(llama_model, orig_llama_model)\n\t    # make the gate non-zero, otherwise the adapter is disabled and the model\n\t    # identical to regular LLaMA\n\t    enable_gate(llama_model)\n\t    enable_gate(orig_llama_model)\n\t    expected = orig_llama_model(token_sample, 0)\n\t    out = llama_model(token_sample)\n", "    assert torch.allclose(out, expected)\n\t@pytest.mark.skipif(sys.platform in (\"win32\", \"darwin\"), reason=\"torch.compile not supported on this platform\")\n\tdef test_model_compile(lit_llama):\n\t    llama_config = lit_llama.LLaMAConfig(block_size=8, vocab_size=8, n_layer=2, n_head=2, n_embd=4)\n\t    model = lit_llama.LLaMA(llama_config)\n\t    model.apply(model._init_weights)\n\t    model = torch.compile(model)\n\t    sample = torch.randint(model.config.vocab_size, size=(2, model.config.block_size), dtype=torch.int64)\n\t    for _ in range(3):\n\t        _ = model(sample)\n"]}
{"filename": "tests/test_packed_dataset.py", "chunked_list": ["import os\n\tfrom unittest.mock import MagicMock\n\timport requests\n\tfrom torch.utils.data import IterableDataset\n\tdef train_tokenizer(destination_path):\n\t    destination_path.mkdir(parents=True, exist_ok=True)\n\t    # download the tiny shakespeare dataset\n\t    input_file_path = destination_path / \"input.txt\"\n\t    if not input_file_path.exists():\n\t        data_url = \"https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt\"\n", "        with open(input_file_path, \"w\") as f:\n\t            f.write(requests.get(data_url).text)\n\t    from lit_llama import Tokenizer\n\t    Tokenizer.train(\n\t        input=input_file_path,\n\t        destination=destination_path,\n\t        vocab_size=100,\n\t    )\n\t    return destination_path / \"tokenizer.model\"\n\tdef test_packed_dataset(tmp_path):\n", "    tokenizer_path = train_tokenizer(tmp_path)\n\t    from lit_llama import Tokenizer\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    texts = [\n\t      \"The moment of truth is upon us.\",\n\t      \"Time to open the fridge.\"\n\t    ]\n\t    from lit_llama.packed_dataset import PackedDatasetBuilder, PackedDataset, HDR_SIZE\n\t    block_size = 10\n\t    n_blocks = 2\n", "    chunk_size = block_size * n_blocks\n\t    builder = PackedDatasetBuilder(\n\t        outdir=tmp_path,\n\t        prefix=\"packed_dataset\",\n\t        chunk_size=chunk_size,\n\t        sep_token=tokenizer.bos_id,\n\t        dtype=\"auto\",\n\t        vocab_size=100,\n\t    )\n\t    text_ids = []\n", "    for text in texts:\n\t        text_ids = tokenizer.encode(text)\n\t        assert text_ids[0] == tokenizer.bos_id\n\t        builder.add_array(text_ids)\n\t    filenames = builder.filenames\n\t    assert len(filenames) == 2\n\t    assert os.path.basename(filenames[0]) == \"packed_dataset_0000000000.bin\"\n\t    assert os.path.basename(filenames[1]) == \"packed_dataset_0000000001.bin\"\n\t    import numpy as np\n\t    ex_tokenized = [\n", "        tokenizer.encode(text).numpy().astype(builder.dtype)\n\t        for text in texts\n\t    ]\n\t    ex_tokenized = np.concatenate(ex_tokenized)\n\t    ex_tokenized = ex_tokenized[:2 * chunk_size]\n\t    for filename, el in zip(filenames, np.array_split(ex_tokenized, 2)):\n\t        mmap = np.memmap(filename, mode=\"r\", order=\"C\", offset=HDR_SIZE)\n\t        count = len(mmap) // np.dtype(builder.dtype).itemsize\n\t        arr = np.frombuffer(\n\t            mmap, dtype=builder.dtype, count=count, offset=0\n", "        )\n\t        where_bos = np.where(arr == tokenizer.bos_id)\n\t        # we expect two BOS tokens, one per file\n\t        assert len(where_bos) == 1\n\t        assert np.array_equal(arr, el)\n\t    dataset = PackedDataset(filenames=filenames, n_chunks=2, block_size=block_size, shuffle=False)\n\t    ex_split = np.array_split(ex_tokenized, ex_tokenized.shape[0] // block_size)\n\t    for item, el in zip(dataset, ex_split):\n\t        assert np.array_equal(item, el)\n\t    dataset = PackedDataset(filenames=filenames, n_chunks=2, block_size=block_size, seed=12345)\n", "    for i, item in enumerate(dataset):\n\t        block_idxs = iter(dataset)._block_idxs\n\t        assert np.array_equal(item, ex_split[block_idxs[i]])\n\t    dataset = PackedDataset(filenames=filenames, n_chunks=2, block_size=block_size, seed=12345, wrap=True)\n\t    for i, item in enumerate(dataset):\n\t        if i > 24:\n\t            break\n\t    dataset = PackedDataset(filenames=filenames, n_chunks=1, block_size=block_size, seed=12345)\n\t    for i, item in enumerate(dataset):\n\t        block_idxs = iter(dataset)._block_idxs\n", "        chunk_idx = i // n_blocks * n_blocks\n\t        assert np.array_equal(item, ex_split[chunk_idx + block_idxs[i % n_blocks]])\n\t    block_size_ = block_size // 2\n\t    ex_split = np.array_split(ex_tokenized, ex_tokenized.shape[0] // block_size_)\n\t    dataset = PackedDataset(filenames=filenames, n_chunks=2, block_size=block_size_, seed=12345)\n\t    for i, item in enumerate(dataset):\n\t        block_idxs = iter(dataset)._block_idxs\n\t        assert np.array_equal(item, ex_split[block_idxs[i]])\n\t    block_size_ = block_size // 3\n\t    n_chunks = 2\n", "    ex_chunks = np.split(ex_tokenized, n_chunks)\n\t    n_splits = ex_tokenized.shape[0] // n_chunks // block_size_\n\t    ex_splits = [np.split(el[:n_splits * block_size_], n_splits) for el in ex_chunks]\n\t    ex_split = sum(ex_splits, [])\n\t    dataset = PackedDataset(filenames=filenames, n_chunks=n_chunks, block_size=block_size_, seed=12345)\n\t    for i, item in enumerate(dataset):\n\t        block_idxs = iter(dataset)._block_idxs\n\t        assert np.array_equal(item, ex_split[block_idxs[i]])\n\tclass SimpleDataset(IterableDataset):\n\t    def __init__(self, start, end):\n", "        super().__init__()\n\t        self._start = start\n\t        self._end = end\n\t    def __iter__(self):\n\t        return iter(range(self._start, self._end))\n\tdef test_combined_dataset(tmp_path):\n\t    from lit_llama.packed_dataset import CombinedDataset\n\t    dataset1 = SimpleDataset(0, 10)\n\t    dataset2 = SimpleDataset(10, 20)\n\t    dataset = CombinedDataset(datasets=[dataset1, dataset2], weights=[1.0, 0.0], seed=12345)\n", "    res = [el for el in dataset]\n\t    assert res == list(range(0, 10))\n\t    dataset1 = SimpleDataset(0, 10)\n\t    dataset2 = SimpleDataset(10, 20)\n\t    dataset = CombinedDataset(datasets=[dataset1, dataset2], weights=[0.0, 1.0], seed=12345)\n\t    res = [el for el in dataset]\n\t    assert res == list(range(10, 20))\n\t    dataset1 = SimpleDataset(0, 10)\n\t    dataset2 = SimpleDataset(10, 20)\n\t    dataset = CombinedDataset(datasets=[dataset1, dataset2], weights=[0.5, 0.5], seed=12345)\n", "    res = [el for el in dataset]\n\t    assert 9 in res or 19 in res\n\t    if len(res) > 10:\n\t        assert 0 in res and 10 in res\n\tdef test_sharded_packed_dataset(monkeypatch):\n\t    import lit_llama.packed_dataset\n\t    from lit_llama.packed_dataset import PackedDataset\n\t    dataset_iterator_mock = MagicMock()\n\t    monkeypatch.setattr(lit_llama.packed_dataset, \"PackedDatasetIterator\", dataset_iterator_mock)\n\t    filenames = [str(i) for i in range(10)]\n", "    # world_size = 1, rank = 0\n\t    iter(PackedDataset(filenames=filenames, n_chunks=2, block_size=2))\n\t    assert dataset_iterator_mock.call_args[1][\"filenames\"] == filenames\n\t    dataset_iterator_mock.reset_mock()\n\t    # world_size = 2, rank = 0\n\t    iter(PackedDataset(filenames=filenames, n_chunks=2, block_size=2, num_processes=2, process_rank=0))\n\t    assert dataset_iterator_mock.call_args[1][\"filenames\"] == [\"0\", \"2\", \"4\", \"6\", \"8\"]\n\t    dataset_iterator_mock.reset_mock()\n\t    # world_size = 2, rank = 1\n\t    iter(PackedDataset(filenames=filenames, n_chunks=2, block_size=2, num_processes=2, process_rank=1))\n", "    assert dataset_iterator_mock.call_args[1][\"filenames\"] == [\"1\", \"3\", \"5\", \"7\", \"9\"]\n\t    dataset_iterator_mock.reset_mock()\n\t    # world_size = 3, rank = 0 (dataset size not cleanly divisible by world size)\n\t    iter(PackedDataset(filenames=filenames, n_chunks=2, block_size=2, num_processes=3, process_rank=0))\n\t    assert dataset_iterator_mock.call_args[1][\"filenames\"] == [\"0\", \"3\", \"6\"]\n\t    dataset_iterator_mock.reset_mock()\n\t    # world_size = 3, rank = 1 (dataset size not cleanly divisible by world size)\n\t    iter(PackedDataset(filenames=filenames, n_chunks=2, block_size=2, num_processes=3, process_rank=1))\n\t    assert dataset_iterator_mock.call_args[1][\"filenames\"] == [\"1\", \"4\", \"7\"]\n\t    dataset_iterator_mock.reset_mock()\n", "    # world_size = 3, rank = 2 (dataset size not cleanly divisible by world size)\n\t    iter(PackedDataset(filenames=filenames, n_chunks=2, block_size=2, num_processes=3, process_rank=2))\n\t    assert dataset_iterator_mock.call_args[1][\"filenames\"] == [\"2\", \"5\", \"8\"]\n"]}
{"filename": "tests/test_utils.py", "chunked_list": ["import tempfile\n\timport pathlib\n\timport torch\n\tclass ATensor(torch.Tensor):\n\t    pass\n\tdef test_lazy_load_basic(lit_llama):\n\t    import lit_llama.utils\n\t    with tempfile.TemporaryDirectory() as tmpdirname:\n\t        m = torch.nn.Linear(5, 3)\n\t        path = pathlib.Path(tmpdirname)\n", "        fn = str(path / \"test.pt\")\n\t        torch.save(m.state_dict(), fn)\n\t        with lit_llama.utils.lazy_load(fn) as sd_lazy:\n\t            assert \"NotYetLoadedTensor\" in str(next(iter(sd_lazy.values())))\n\t            m2 = torch.nn.Linear(5, 3)\n\t            m2.load_state_dict(sd_lazy)\n\t        x = torch.randn(2, 5)\n\t        actual = m2(x)\n\t        expected = m(x)\n\t        torch.testing.assert_close(actual, expected)\n", "def test_lazy_load_subclass(lit_llama):\n\t    import lit_llama.utils\n\t    with tempfile.TemporaryDirectory() as tmpdirname:\n\t        path = pathlib.Path(tmpdirname)\n\t        fn = str(path / \"test.pt\")\n\t        t = torch.randn(2, 3)[:, 1:]\n\t        sd = {\n\t            1: t,\n\t            2: torch.nn.Parameter(t),\n\t            3: torch.Tensor._make_subclass(ATensor, t),\n", "        }\n\t        torch.save(sd, fn)\n\t        with lit_llama.utils.lazy_load(fn) as sd_lazy:\n\t            for k in sd.keys():\n\t                actual = sd_lazy[k]\n\t                expected = sd[k]\n\t                torch.testing.assert_close(actual._load_tensor(), expected)\n\tdef test_incremental_write(tmp_path, lit_llama):\n\t    import lit_llama.utils\n\t    sd = {str(k): torch.randn(5, 10) for k in range(3)}\n", "    sd_expected = {k: v.clone() for k, v in sd.items()}\n\t    fn = str(tmp_path / \"test.pt\")\n\t    with lit_llama.utils.incremental_save(fn) as f:\n\t        sd[\"0\"] = f.store_early(sd[\"0\"])\n\t        sd[\"2\"] = f.store_early(sd[\"2\"])\n\t        f.save(sd)\n\t    sd_actual = torch.load(fn)\n\t    assert sd_actual.keys() == sd_expected.keys()\n\t    for k, v_expected in sd_expected.items():\n\t        v_actual = sd_actual[k]\n", "        torch.testing.assert_close(v_expected, v_actual)\n\tdef test_find_multiple(lit_llama):\n\t    from lit_llama.utils import find_multiple\n\t    assert find_multiple(17, 5) == 20\n\t    assert find_multiple(30, 7) == 35\n\t    assert find_multiple(10, 2) == 10\n\t    assert find_multiple(5, 10) == 10\n"]}
{"filename": "tests/test_rmsnorm.py", "chunked_list": ["import torch\n\t@torch.no_grad()\n\tdef test_rmsnorm(lit_llama, orig_llama) -> None:\n\t    block_size = 16\n\t    vocab_size = 16\n\t    sample = torch.rand(size=(2, block_size, vocab_size), dtype=torch.float32)\n\t    eps = 1e-6\n\t    orig_llama_rmsnorm = orig_llama.RMSNorm(vocab_size, eps=eps)(sample)\n\t    llama_rmsnorm = lit_llama.RMSNorm(vocab_size, eps=eps)(sample)\n\t    assert torch.allclose(orig_llama_rmsnorm, llama_rmsnorm)\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["import sys\n\tfrom pathlib import Path\n\timport pytest\n\twd = Path(__file__).parent.parent.absolute()\n\t@pytest.fixture()\n\tdef orig_llama():\n\t    sys.path.append(str(wd))\n\t    from scripts.download import download_original\n\t    download_original(wd)\n\t    import original_model\n", "    return original_model\n\t@pytest.fixture()\n\tdef orig_llama_adapter():\n\t    sys.path.append(str(wd))\n\t    from scripts.download import download_original\n\t    download_original(wd)\n\t    import original_adapter\n\t    return original_adapter\n\t@pytest.fixture()\n\tdef lit_llama():\n", "    # this adds support for running tests without the package installed\n\t    sys.path.append(str(wd))\n\t    import lit_llama\n\t    return lit_llama\n"]}
{"filename": "quantize/gptq.py", "chunked_list": ["# This adapts GPTQ's quantization process: https://github.com/IST-DASLab/gptq/\n\t# E. Frantar et al GPTQ: Accurate Post-training Compression for GPT, arXiv:2210.17323\n\t# portions copyright by the authors licensed under the Apache License 2.0\n\timport gc\n\timport sys\n\timport time\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport torch\n\tfrom datasets import load_dataset\n", "# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\tfrom lit_llama import LLaMA, Tokenizer\n\tfrom lit_llama.quantization import GPTQQuantizer\n\tfrom lit_llama.utils import EmptyInitOnDevice, llama_model_lookup\n\tdef get_sample_data():\n\t    traindata = load_dataset(\n\t        \"allenai/c4\",\n\t        \"allenai--c4\",\n", "        data_files={\"train\": \"en/c4-train.00000-of-01024.json.gz\"},\n\t        split=\"train\",\n\t    )\n\t    # heuristic for the data size?\n\t    txt = \"\\n\".join(\n\t        traindata[i][\"text\"] for i in torch.randperm(len(traindata))[:1000].tolist()\n\t    )\n\t    return txt\n\t@torch.no_grad()\n\tdef llama_blockwise_quantization(\n", "    model, sample_inputs, working_device, *, bits=4, groupsize=-1\n\t):\n\t    \"\"\"\n\t    This is the classic post-training quantization of all linear layers.\n\t    We quantize in order, i.e. when observing the inputs, we use the outputs of the previously quantized layers rather\n\t    than doing them all at once.\n\t    \"\"\"\n\t    print(model)\n\t    print(model.config)\n\t    print(\"Getting inputs for first block\")\n", "    model.transformer.wte.to(working_device)\n\t    sample_inputs = sample_inputs.to(working_device)\n\t    inps = model.transformer.wte(sample_inputs)\n\t    model.transformer.wte.to(\"cpu\")\n\t    torch.cuda.empty_cache()\n\t    rope_cache = model.build_rope_cache(sample_inputs)\n\t    mask_cache = model.build_mask_cache(sample_inputs)\n\t    print(\"Starting to quantize blocks\")\n\t    outs = torch.zeros_like(inps)\n\t    # better than relying on enumeration? originally the code bundled\n", "    # the two mlp fc layers\n\t    # we could automate this with a lot of hooks and another iteration\n\t    submodules_to_process = [\n\t        \"attn.c_attn\",\n\t        \"attn.c_proj\",\n\t        \"mlp.c_fc1\",\n\t        \"mlp.c_fc2\",\n\t        \"mlp.c_proj\",\n\t    ]\n\t    for i, block in enumerate(model.transformer.h):\n", "        block.to(working_device)\n\t        for name in submodules_to_process:\n\t            print(i, name, end=\" \")\n\t            t0 = time.perf_counter()\n\t            print(\"collecting stats\", end=\" \")\n\t            sys.stdout.flush()\n\t            module = block.get_submodule(name)\n\t            gptq = GPTQQuantizer(\n\t                module,\n\t                bits=bits,\n", "                groupsize=groupsize,\n\t                actorder=(groupsize == -1),\n\t            )\n\t            handle = module.register_forward_hook(gptq.collect_input_stats)\n\t            for j in range(inps.size(0)):\n\t                outs[j : j + 1], _ = block(\n\t                    inps[j : j + 1],\n\t                    rope=rope_cache,\n\t                    mask=mask_cache,\n\t                    max_seq_length=model.config.block_size\n", "                )\n\t            handle.remove()\n\t            print(\"quantizing\", end=\" \")\n\t            sys.stdout.flush()\n\t            q_module, error = gptq.quantize()\n\t            # replace the linear module with the quantized module\n\t            pname, dname = name.rsplit(\".\", 1)\n\t            setattr(block.get_submodule(pname), dname, q_module)\n\t            # cleanup in an attempt to not run out of memory\n\t            del gptq\n", "            gc.collect()\n\t            torch.cuda.empty_cache()\n\t            t1 = time.perf_counter()\n\t            print(f\"time {int(t1 - t0 + 0.5)}s quantization error {error:.1f}\")\n\t        for j in range(inps.size(0)):\n\t            outs[j : j + 1], _ = block(\n\t                inps[j : j + 1],\n\t                rope=rope_cache,\n\t                mask=mask_cache,\n\t                max_seq_length=model.config.block_size\n", "            )\n\t        block.cpu()\n\t        gc.collect()\n\t        torch.cuda.empty_cache()\n\t        # the outputs are the next block's inputs and we'll reuse the old inputs\n\t        inps, outs = outs, inps\n\t    model.transformer.ln_f.to(working_device)\n\t    for j in range(inps.size(0)):\n\t        outs[j : j + 1] = model.transformer.ln_f(inps[j : j + 1])\n\t    model.transformer.ln_f.to(\"cpu\")\n", "    inps, outs = outs, inps\n\t    model.lm_head.to(working_device)\n\t    gptq = GPTQQuantizer(\n\t        model.lm_head,\n\t        bits=bits,\n\t        groupsize=groupsize,\n\t        actorder=(groupsize == -1),\n\t    )\n\t    handle = model.lm_head.register_forward_hook(gptq.collect_input_stats)\n\t    for j in range(inps.size(0)):\n", "        model.lm_head(inps[j : j + 1])\n\t    handle.remove()\n\t    q_module, error = gptq.quantize()\n\t    model.lm_head = q_module\n\t    model.lm_head.to(\"cpu\")\n\tdef main(\n\t    *,\n\t    checkpoint_path: Path = Path(\"checkpoints/lit-llama/7B/lit-llama.pth\"),\n\t    output_path: Optional[Path] = None,\n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n", "    n_samples: int = 128,\n\t    dtype: str = \"float32\",\n\t    quantize: Optional[str] = None,\n\t) -> None:\n\t    \"\"\"Generates text samples based on a pre-trained LLaMA model and tokenizer.\n\t    Args:\n\t        checkpoint_path: The checkpoint path to load.\n\t        output_path: Path to write the quantized model's state dict to.\n\t        tokenizer_path: The tokenizer path to load.\n\t        n_samples: Number of example inputs to use for statistics (default: 128)\n", "        dtype: The dtype to use to load the model.\n\t        quantize: Mode to quantize the model to:\n\t            ``\"gptq.int4\"``: GPTQ 4-bit mode.\n\t            Note that ``\"llm.int8\"```does not need a quantization step.\n\t    \"\"\"\n\t    assert checkpoint_path.is_file()\n\t    assert tokenizer_path.is_file()\n\t    if output_path is None:\n\t        output_path = checkpoint_path.parent / \"llama-gptq.4bit.pth\"\n\t    assert output_path.parent.is_dir() and (not output_path.exists() or output_path.is_file())\n", "    device = \"cuda\"\n\t    dt = getattr(torch, dtype, None)\n\t    if not isinstance(dt, torch.dtype):\n\t        raise ValueError(f\"{dtype} is not a valid dtype.\")\n\t    dtype = dt\n\t    if quantize == \"gptq.int4\":\n\t        bits = 4\n\t    elif quantize == \"gptq.int8\":\n\t        bits = 8\n\t    else:\n", "        raise RuntimeError(f\"unknown/unsupported quantization mode {quantize}\")\n\t    # we avoid loading the entire model on the GPU and do this block by block\n\t    with EmptyInitOnDevice(\n\t        device=\"cpu\",\n\t        dtype=dtype,\n\t    ):\n\t        print(\"Loading model ...\", file=sys.stderr)\n\t        t0 = time.time()\n\t        checkpoint = torch.load(checkpoint_path)\n\t        name = llama_model_lookup(checkpoint)\n", "        model = LLaMA.from_name(name)\n\t        model.load_state_dict(checkpoint)\n\t        print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n\t    model.eval()\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    test_string = get_sample_data()\n\t    encoded_text = tokenizer.encode(\n\t        test_string,\n\t        bos=True,\n\t        eos=False,\n", "    )\n\t    block_size = 2048  # this is for compat with gptq, and indeed we get much worse beyond this (https://github.com/facebookresearch/llama/blob/57b0eb62de0636e75af471e49e2f1862d908d9d8/llama/model.py#L30)\n\t    encoded_text = encoded_text[: n_samples * block_size].reshape(n_samples, block_size)\n\t    t0 = time.perf_counter()\n\t    llama_blockwise_quantization(model, encoded_text, device, bits=bits)\n\t    t = time.perf_counter() - t0\n\t    print(\n\t        f\"\\n\\nTime for quantization: {t:.02f} sec total\",\n\t        file=sys.stderr,\n\t    )\n", "    print(\n\t        f\"Memory used: {torch.cuda.max_memory_reserved() / 1e9:.02f} GB\",\n\t        file=sys.stderr,\n\t    )\n\t    torch.save(model.state_dict(), output_path)\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    CLI(main)\n"]}
{"filename": "lit_llama/quantization.py", "chunked_list": ["import os\n\tfrom contextlib import contextmanager\n\timport warnings\n\timport math\n\timport torch\n\t# configuration for bitsandbytes before import\n\tos.environ[\"BITSANDBYTES_NOWELCOME\"] = \"1\"\n\twarnings.filterwarnings(\n\t    \"ignore\",\n\t    message=\"MatMul8bitLt: inputs will be cast from torch.float32 to float16 during quantization\",\n", ")\n\twarnings.filterwarnings(\n\t    \"ignore\",\n\t    message=\"MatMul8bitLt: inputs will be cast from torch.bfloat16 to float16 during quantization\",\n\t)\n\twarnings.filterwarnings(\n\t    \"ignore\",\n\t    message=\"The installed version of bitsandbytes was compiled without GPU support. 8-bit optimizers and GPU quantization are unavailable.\",\n\t)\n\ttry:\n", "    import bitsandbytes as bnb  # noqa: E402\n\texcept:\n\t    bnb = None\n\ttry:\n\t    import triton  # noqa: E402\n\t    import triton.language as tl  # noqa: E402\n\texcept:\n\t    triton = None\n\tif bnb is not None:\n\t    class Linear8bitLt(bnb.nn.Linear8bitLt):\n", "        \"\"\"Wraps `bnb.nn.Linear8bitLt` and enables instantiation directly on the device and\n\t        re-quantizaton when loading the state dict.\n\t        This should only be used for inference. For training, use `bnb.nn.Linear8bitLt` directly.\n\t        \"\"\"\n\t        def __init__(self, *args, **kwargs):\n\t            super().__init__(*args, **kwargs, has_fp16_weights=False, threshold=6.0)\n\t            # We quantize the initial weight here so we don't end up filling the device\n\t            # memory with float32 weights which could lead to OOM.\n\t            self._quantize_weight(self.weight.data)\n\t        def _load_from_state_dict(self, local_state_dict, *args, **kwargs):\n", "            # There is only one key that ends with `*.weight`, the other one is the bias\n\t            weight_key = next(\n\t                (name for name in local_state_dict.keys() if name.endswith(\"weight\")),\n\t                None,\n\t            )\n\t            if weight_key is None:\n\t                return\n\t            # Load the weight from the state dict and re-quantize it\n\t            weight = local_state_dict.pop(weight_key)\n\t            self._quantize_weight(weight)\n", "            # If there is a bias, let nn.Module load it\n\t            if local_state_dict:\n\t                super()._load_from_state_dict(local_state_dict, *args, **kwargs)\n\t        def _quantize_weight(self, weight: torch.Tensor) -> None:\n\t            # This code is taken and adapted from `bnb.nn.Int8Params.cuda()`\n\t            B = weight.contiguous().half().cuda()\n\t            CB, CBt, SCB, SCBt, coo_tensorB = bnb.functional.double_quant(B)\n\t            del CBt\n\t            del SCBt\n\t            self.weight.data = CB\n", "            setattr(self.weight, \"CB\", CB)\n\t            setattr(self.weight, \"SCB\", SCB)\n\tif triton is not None:\n\t    # This is adapted from the OpenAI Triton matmul example.\n\t    @triton.autotune(\n\t        configs=[\n\t            triton.Config(\n\t                {\n\t                    \"BLOCK_SIZE_M\": 128,\n\t                    \"BLOCK_SIZE_N\": 256,\n", "                    \"BLOCK_SIZE_K\": 32,\n\t                    \"GROUP_SIZE_M\": 8,\n\t                },\n\t                num_stages=3,\n\t                num_warps=8,\n\t            ),\n\t            triton.Config(\n\t                {\n\t                    \"BLOCK_SIZE_M\": 256,\n\t                    \"BLOCK_SIZE_N\": 128,\n", "                    \"BLOCK_SIZE_K\": 32,\n\t                    \"GROUP_SIZE_M\": 8,\n\t                },\n\t                num_stages=3,\n\t                num_warps=8,\n\t            ),\n\t            triton.Config(\n\t                {\n\t                    \"BLOCK_SIZE_M\": 256,\n\t                    \"BLOCK_SIZE_N\": 64,\n", "                    \"BLOCK_SIZE_K\": 32,\n\t                    \"GROUP_SIZE_M\": 8,\n\t                },\n\t                num_stages=4,\n\t                num_warps=4,\n\t            ),\n\t            triton.Config(\n\t                {\n\t                    \"BLOCK_SIZE_M\": 64,\n\t                    \"BLOCK_SIZE_N\": 256,\n", "                    \"BLOCK_SIZE_K\": 32,\n\t                    \"GROUP_SIZE_M\": 8,\n\t                },\n\t                num_stages=4,\n\t                num_warps=4,\n\t            ),\n\t            triton.Config(\n\t                {\n\t                    \"BLOCK_SIZE_M\": 128,\n\t                    \"BLOCK_SIZE_N\": 128,\n", "                    \"BLOCK_SIZE_K\": 32,\n\t                    \"GROUP_SIZE_M\": 8,\n\t                },\n\t                num_stages=4,\n\t                num_warps=4,\n\t            ),\n\t            triton.Config(\n\t                {\n\t                    \"BLOCK_SIZE_M\": 128,\n\t                    \"BLOCK_SIZE_N\": 64,\n", "                    \"BLOCK_SIZE_K\": 32,\n\t                    \"GROUP_SIZE_M\": 8,\n\t                },\n\t                num_stages=4,\n\t                num_warps=4,\n\t            ),\n\t            triton.Config(\n\t                {\n\t                    \"BLOCK_SIZE_M\": 64,\n\t                    \"BLOCK_SIZE_N\": 128,\n", "                    \"BLOCK_SIZE_K\": 32,\n\t                    \"GROUP_SIZE_M\": 8,\n\t                },\n\t                num_stages=4,\n\t                num_warps=4,\n\t            ),\n\t            triton.Config(\n\t                {\n\t                    \"BLOCK_SIZE_M\": 128,\n\t                    \"BLOCK_SIZE_N\": 32,\n", "                    \"BLOCK_SIZE_K\": 32,\n\t                    \"GROUP_SIZE_M\": 8,\n\t                },\n\t                num_stages=4,\n\t                num_warps=4,\n\t            ),\n\t            triton.Config(\n\t                {\n\t                    \"BLOCK_SIZE_M\": 64,\n\t                    \"BLOCK_SIZE_N\": 32,\n", "                    \"BLOCK_SIZE_K\": 32,\n\t                    \"GROUP_SIZE_M\": 8,\n\t                },\n\t                num_stages=5,\n\t                num_warps=2,\n\t            ),\n\t            triton.Config(\n\t                {\n\t                    \"BLOCK_SIZE_M\": 32,\n\t                    \"BLOCK_SIZE_N\": 64,\n", "                    \"BLOCK_SIZE_K\": 32,\n\t                    \"GROUP_SIZE_M\": 8,\n\t                },\n\t                num_stages=5,\n\t                num_warps=2,\n\t            ),\n\t        ],\n\t        key=[\"M\", \"N\", \"K\"],\n\t    )\n\t    @triton.jit\n", "    def linear_kernel_4bit_weight(\n\t        # Pointers to matrices\n\t        a_ptr,\n\t        b_ptr,\n\t        c_ptr,\n\t        bscales_ptr,\n\t        bzeros_ptr,\n\t        # bdequant,\n\t        # Matrix dimensions\n\t        M,\n", "        N,\n\t        K,\n\t        # The stride variables represent how much to increase the ptr by when moving by 1\n\t        # element in a particular dimension. E.g. stride_am is how much to increase a_ptr\n\t        # by to get the element one row down (A has M rows)\n\t        stride_am,\n\t        stride_ak,\n\t        stride_bk,\n\t        stride_bn,\n\t        stride_cm,\n", "        stride_cn,\n\t        # Meta-parameters\n\t        BLOCK_SIZE_M: tl.constexpr,\n\t        BLOCK_SIZE_N: tl.constexpr,\n\t        BLOCK_SIZE_K: tl.constexpr,\n\t        GROUP_SIZE_M: tl.constexpr,\n\t    ):\n\t        \"\"\"Kernel for computing the matmul C = A x B.T.\n\t        A has shape (M, K), B has shape (N, K) and C has shape (M, N)\n\t        \"\"\"\n", "        # -----------------------------------------------------------\n\t        # Map program ids `pid` to the block of C it should compute.\n\t        # This is done in a grouped ordering to promote L2 data reuse\n\t        # See above `L2 Cache Optimizations` section for details\n\t        pid = tl.program_id(axis=0)\n\t        num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n\t        num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n\t        num_pid_in_group = GROUP_SIZE_M * num_pid_n\n\t        group_id = pid // num_pid_in_group\n\t        first_pid_m = group_id * GROUP_SIZE_M\n", "        group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n\t        pid_m = first_pid_m + (pid % group_size_m)\n\t        pid_n = (pid % num_pid_in_group) // group_size_m\n\t        # ----------------------------------------------------------\n\t        # Create pointers for the first blocks of A and B.\n\t        # We will advance this pointer as we move in the K direction\n\t        # and accumulate\n\t        # a_ptrs is a block of [BLOCK_SIZE_M, BLOCK_SIZE_K] pointers\n\t        # b_ptrs is a block of [BLOCK_SIZE_K, BLOCK_SIZE_n] pointers\n\t        # see above `Pointer Arithmetics` section for details\n", "        offs_am = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n\t        offs_bn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n\t        a_mask = offs_am[:, None] < M\n\t        b_mask = offs_bn[None, :] < N\n\t        offs_k = tl.arange(0, BLOCK_SIZE_K)\n\t        a_ptrs = a_ptr + (offs_am[:, None] * stride_am + offs_k[None, :] * stride_ak)\n\t        b_ptrs = b_ptr + (\n\t            (offs_k[:, None] // 2) * stride_bk + offs_bn[None, :] * stride_bn\n\t        )\n\t        bscales_ptrs = bscales_ptr + offs_bn[None, :]\n", "        bzeros_ptrs = bzeros_ptr + offs_bn[None, :]\n\t        scale = tl.load(bscales_ptrs)\n\t        zero = tl.load(bzeros_ptrs)\n\t        # -----------------------------------------------------------\n\t        # Iterate to compute a block of the C matrix\n\t        # We accumulate into a `[BLOCK_SIZE_M, BLOCK_SIZE_N]` block\n\t        # of fp32 values for higher accuracy.\n\t        # `accumulator` will be converted back to fp16 after the loop\n\t        accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n\t        for k in range(0, K, BLOCK_SIZE_K):\n", "            # wasteful as it is to load everything twice, my attempts at avoiding it lead to slower code\n\t            b12 = tl.load(b_ptrs, mask=b_mask)\n\t            # Note that for simplicity, we don't apply a mask in K here.\n\t            a = tl.load(a_ptrs, mask=a_mask).to(tl.float32)\n\t            b = (\n\t                ((b12.to(tl.uint8) >> ((offs_k[:, None] % 2) * 4)) & 0xF).to(tl.float32)\n\t                - zero\n\t            ) * scale\n\t            accumulator += tl.dot(a, b)\n\t            # Advance the ptrs to the next K block\n", "            a_ptrs += BLOCK_SIZE_K * stride_ak\n\t            b_ptrs += (BLOCK_SIZE_K // 2) * stride_bk\n\t        c = accumulator\n\t        # -----------------------------------------------------------\n\t        # Write back the block of the output matrix C\n\t        offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n\t        offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n\t        c_ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n\t        c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n\t        tl.store(c_ptrs, c, mask=c_mask)\n", "    def qlinear_4bit_weight(inp, weight, scales, zeros):\n\t        weight = weight.t().contiguous()\n\t        c_shape = inp.shape[:-1] + weight.shape[-1:]\n\t        inp = inp.reshape(-1, inp.shape[-1]).contiguous()\n\t        # we pad the input to amortize triton compilation cost better\n\t        PAD_TO = 256\n\t        if inp.shape[0] % PAD_TO != 0:\n\t            c_crop = inp.shape[0]\n\t            new_inp_shape0 = inp.shape[0] + PAD_TO - inp.shape[0] % PAD_TO\n\t            inp2 = inp.new_empty((new_inp_shape0, inp.shape[1]))\n", "            inp2[: inp.shape[0]] = inp\n\t            inp2[inp.shape[0] :].zero_()\n\t            inp = inp2\n\t        else:\n\t            c_crop = None\n\t        assert inp.shape[1] == weight.shape[0] * 2, \"incompatible dimensions\"\n\t        assert scales.shape == (weight.shape[1], 1)\n\t        assert zeros.shape == (weight.shape[1], 1)\n\t        scales = scales.contiguous()\n\t        zeros = zeros.contiguous()\n", "        K, N = weight.shape\n\t        M, K = inp.shape\n\t        assert (\n\t            K % 32 == 0\n\t        ), \"We don't check memory-out-of-bounds with K so K must be divisible by BLOCK_SIZE_K\"\n\t        # allocates output\n\t        c = torch.empty((M, N), device=inp.device, dtype=inp.dtype)\n\t        # 1D launch kernel where each block gets its own program.\n\t        grid = lambda META: (\n\t            triton.cdiv(M, META[\"BLOCK_SIZE_M\"]) * triton.cdiv(N, META[\"BLOCK_SIZE_N\"]),\n", "        )\n\t        linear_kernel_4bit_weight[grid](\n\t            inp,\n\t            weight,\n\t            c,\n\t            scales,\n\t            zeros,\n\t            M,\n\t            N,\n\t            K,\n", "            inp.stride(0),\n\t            inp.stride(1),\n\t            weight.stride(0),\n\t            weight.stride(1),\n\t            c.stride(0),\n\t            c.stride(1),\n\t        )\n\t        return c[:c_crop].reshape(c_shape)\n\telse:\n\t    qlinear_4bit_weight = None\n", "# for correctness but with terrible perf\n\tclass ColBlockQuantizedLinear(torch.nn.Module):\n\t    def __init__(self, in_features, out_features, bias: bool, *, bits, tile_cols):\n\t        super().__init__()\n\t        self.in_features = in_features\n\t        self.out_features = out_features\n\t        self.tile_cols = tile_cols if tile_cols != -1 else self.in_features\n\t        self.bits = bits\n\t        self.entries_per_byte = 8 // bits\n\t        assert self.entries_per_byte > 0 and self.entries_per_byte * self.bits == 8\n", "        assert in_features % self.entries_per_byte == 0\n\t        self.register_buffer(\n\t            \"quant_weight\",\n\t            torch.empty(\n\t                (self.out_features, self.in_features // self.entries_per_byte),\n\t                dtype=torch.uint8,\n\t            )\n\t            .t()\n\t            .contiguous()\n\t            .t(),\n", "        )\n\t        self.register_buffer(\n\t            \"scales\",\n\t            torch.empty(\n\t                (\n\t                    self.out_features,\n\t                    (self.in_features + self.tile_cols - 1) // self.tile_cols,\n\t                )\n\t            ),\n\t        )\n", "        self.register_buffer(\"zeros\", torch.empty_like(self.scales))\n\t        assert isinstance(bias, bool)\n\t        if bias:\n\t            self.register_buffer(\"bias\", torch.empty((self.out_features,)))\n\t        else:\n\t            self.register_buffer(\"bias\", None)\n\t    def pack_weight(self, weight):\n\t        weight = weight.to(device=self.quant_weight.device, copy=True)\n\t        for j in range(self.scales.size(1)):\n\t            weight[:, j * self.tile_cols : (j + 1) * self.tile_cols] /= self.scales[\n", "                :, j : j + 1\n\t            ]\n\t            weight[:, j * self.tile_cols : (j + 1) * self.tile_cols] += self.zeros[\n\t                :, j : j + 1\n\t            ]\n\t        weight = weight.clamp_(min=0, max=2**self.bits - 1).to(dtype=torch.uint8)\n\t        self.quant_weight.zero_()\n\t        for nr in range(self.entries_per_byte):\n\t            self.quant_weight += weight[:, nr :: self.entries_per_byte] << (\n\t                nr * self.bits\n", "            )\n\t    def get_weight(self, dtype=torch.float):\n\t        weight = torch.empty(\n\t            (self.out_features, self.in_features),\n\t            device=self.quant_weight.device,\n\t            dtype=dtype,\n\t        )\n\t        mask = (1 << self.bits) - 1\n\t        for nr in range(self.entries_per_byte):\n\t            weight[:, nr :: self.entries_per_byte] = (\n", "                (self.quant_weight >> (nr * self.bits)) & mask\n\t            ).float()\n\t        self.quant_weight.to(dtype)\n\t        for j in range(self.scales.size(1)):\n\t            weight[:, j * self.tile_cols : (j + 1) * self.tile_cols] -= self.zeros[\n\t                :, j : j + 1\n\t            ]\n\t            weight[:, j * self.tile_cols : (j + 1) * self.tile_cols] *= self.scales[\n\t                :, j : j + 1\n\t            ]\n", "        return weight\n\t    def forward(self, inp):\n\t        if (\n\t            triton is not None\n\t            and self.bits == 4\n\t            and self.quant_weight.device.type == \"cuda\"\n\t            and self.zeros.shape[1] == 1\n\t            and self.quant_weight.shape[1] % 32 == 0\n\t        ):\n\t            return qlinear_4bit_weight(inp, self.quant_weight, self.scales, self.zeros)\n", "        weight = self.get_weight(dtype=inp.dtype)\n\t        return torch.nn.functional.linear(inp, weight, self.bias)\n\tclass GPTQQuantizer:\n\t    # The algorithm and code has been taken from  https://github.com/IST-DASLab/gptq/\n\t    # E. Frantar et al GPTQ: Accurate Post-training Compression for GPT, arXiv:2210.17323\n\t    # portions copyright by the authors licensed under the Apache License 2.0\n\t    # All errors are our own.\n\t    def __init__(\n\t        self,\n\t        linear_module,\n", "        *,\n\t        bits,\n\t        perchannel=True,\n\t        sym=False,\n\t        blocksize=128,\n\t        percdamp=0.01,\n\t        groupsize=-1,\n\t        actorder=False\n\t    ):\n\t        assert isinstance(linear_module, torch.nn.Linear)\n", "        self.linear_module = linear_module\n\t        self.dev = self.linear_module.weight.device\n\t        self.rows = linear_module.weight.shape[0]\n\t        self.columns = linear_module.weight.shape[1]\n\t        self.H = torch.zeros((self.columns, self.columns), device=self.dev)\n\t        self.nsamples = 0\n\t        self.bits = bits\n\t        self.maxq = 2**bits - 1\n\t        self.perchannel = perchannel\n\t        self.sym = sym\n", "        self.blocksize = blocksize\n\t        self.percdamp = percdamp\n\t        self.groupsize = groupsize\n\t        self.actorder = actorder\n\t        self.tile_cols = self.columns if groupsize == -1 else groupsize\n\t        self.scales = torch.zeros(\n\t            (self.rows, (self.columns + self.tile_cols - 1) // self.tile_cols),\n\t            dtype=self.linear_module.weight.dtype,\n\t            device=self.dev,\n\t        )\n", "        self.zeros = torch.zeros_like(self.scales)\n\t        assert not (\n\t            self.actorder and self.groupsize != -1\n\t        ), \"The permutation trick does not work for grouped quantization\"\n\t    @staticmethod\n\t    def quantize_weight(x, scale, zero, maxq):\n\t        q = torch.clamp(torch.round(x / scale) + zero, 0, maxq)\n\t        x_rec = scale * (q - zero)\n\t        return x_rec\n\t    def find_params_weight(self, x):\n", "        dev = x.device\n\t        shape = x.shape\n\t        if self.perchannel:\n\t            x = x.flatten(1)\n\t        else:\n\t            x = x.flatten().unsqueeze(0)\n\t        tmp = torch.zeros(x.shape[0], device=dev)\n\t        xmin = torch.minimum(x.min(1)[0], tmp)\n\t        xmax = torch.maximum(x.max(1)[0], tmp)\n\t        if self.sym:\n", "            xmax = torch.maximum(torch.abs(xmin), xmax)\n\t            tmp = xmin < 0\n\t            if torch.any(tmp):\n\t                xmin[tmp] = -xmax[tmp]\n\t        tmp = (xmin == 0) & (xmax == 0)\n\t        xmin[tmp] = -1\n\t        xmax[tmp] = +1\n\t        scale = (xmax - xmin) / self.maxq\n\t        if self.sym:\n\t            zero = torch.full_like(scale, (self.maxq + 1) / 2)\n", "        else:\n\t            zero = torch.round(-xmin / scale)\n\t        if not self.perchannel:\n\t            tmp = shape[0]\n\t            scale = scale.repeat(tmp)\n\t            zero = zero.repeat(tmp)\n\t        shape = [-1] + [1] * (len(shape) - 1)\n\t        scale = scale.reshape(shape)\n\t        zero = zero.reshape(shape)\n\t        return scale, zero\n", "    def collect_input_stats(self, _1, inp, _2):\n\t        inp = inp[0].detach()\n\t        self.last_inp = inp\n\t        if len(inp.shape) == 2:\n\t            inp = inp.unsqueeze(0)\n\t        tmp = inp.shape[0]\n\t        if len(inp.shape) == 3:\n\t            inp = inp.reshape((-1, inp.shape[-1]))\n\t        inp = inp.t()\n\t        self.H *= self.nsamples / (self.nsamples + tmp)\n", "        self.nsamples += tmp\n\t        # inp = inp.float()\n\t        inp = math.sqrt(2 / self.nsamples) * inp.float()\n\t        # self.H += 2 / self.nsamples * inp.matmul(inp.t())\n\t        self.H += inp.matmul(inp.t())\n\t    def quantize(self):\n\t        W = self.linear_module.weight.detach().to(dtype=torch.float, copy=True)\n\t        scale, zero = self.find_params_weight(W)\n\t        self.scales[:] = scale\n\t        self.zeros[:] = zero\n", "        H = self.H\n\t        del self.H\n\t        dead = torch.diag(H) == 0\n\t        H[dead, dead] = 1\n\t        W[:, dead] = 0\n\t        if self.actorder:\n\t            perm = torch.argsort(torch.diag(H), descending=True)\n\t            W = W[:, perm]\n\t            H = H[perm][:, perm]\n\t        Losses = torch.zeros_like(W)\n", "        Q = torch.zeros_like(W)\n\t        damp = self.percdamp * torch.mean(torch.diag(H))\n\t        diag = torch.arange(self.columns, device=self.dev)\n\t        H[diag, diag] += damp\n\t        H = torch.linalg.cholesky(H)\n\t        H = torch.cholesky_inverse(H)\n\t        H = torch.linalg.cholesky(H, upper=True)\n\t        Hinv = H\n\t        for i1 in range(0, self.columns, self.blocksize):\n\t            i2 = min(i1 + self.blocksize, self.columns)\n", "            count = i2 - i1\n\t            W1 = W[:, i1:i2].clone()\n\t            Q1 = torch.zeros_like(W1)\n\t            Err1 = torch.zeros_like(W1)\n\t            Losses1 = torch.zeros_like(W1)\n\t            Hinv1 = Hinv[i1:i2, i1:i2]\n\t            for i in range(count):\n\t                w = W1[:, i]\n\t                d = Hinv1[i, i]\n\t                if self.groupsize != -1:\n", "                    if (i1 + i) % self.groupsize == 0:\n\t                        scale, zero = self.find_params_weight(\n\t                            W[:, (i1 + i) : (i1 + i + self.groupsize)]\n\t                        )\n\t                        self.scales[:, (i1 + i) // self.groupsize] = scale\n\t                        self.zeros[:, (i1 + i) // self.groupsize] = zero\n\t                q = self.quantize_weight(w.unsqueeze(1), scale, zero, self.maxq)\n\t                q = q.squeeze(1)\n\t                assert q.dim() == 1\n\t                Q1[:, i] = q\n", "                Losses1[:, i] = (w - q) ** 2 / d**2\n\t                err1 = (w - q) / d\n\t                W1[:, i:] -= err1.unsqueeze(1).matmul(Hinv1[i, i:].unsqueeze(0))\n\t                Err1[:, i] = err1\n\t            Q[:, i1:i2] = Q1\n\t            Losses[:, i1:i2] = Losses1 / 2\n\t            W[:, i2:] -= Err1.matmul(Hinv[i1:i2, i2:])\n\t        if self.actorder:\n\t            invperm = torch.argsort(perm)\n\t            Q = Q[:, invperm]\n", "        weight = Q.reshape(self.linear_module.weight.shape).to(\n\t            self.linear_module.weight.data.dtype\n\t        )\n\t        error = torch.sum(Losses).item()\n\t        q_module = ColBlockQuantizedLinear(\n\t            self.linear_module.in_features,\n\t            self.linear_module.out_features,\n\t            self.linear_module.bias is not None,\n\t            bits=self.bits,\n\t            tile_cols=self.groupsize,\n", "        ).to(self.dev)\n\t        q_module.scales = self.scales\n\t        q_module.zeros = self.zeros\n\t        q_module.pack_weight(weight)\n\t        q_module.bias = self.linear_module.bias\n\t        return q_module, error\n"]}
{"filename": "lit_llama/model.py", "chunked_list": ["\"\"\"Full definition of a LLaMA Language Model, all of it in this single file.\n\tBased on the nanoGPT implementation: https://github.com/karpathy/nanoGPT.\n\t\"\"\"\n\t# mypy: ignore-errors\n\timport math\n\tfrom dataclasses import dataclass\n\tfrom typing import List, Optional, Tuple, Union\n\timport torch\n\timport torch.nn as nn\n\tfrom torch.nn import functional as F\n", "from typing_extensions import Self\n\tfrom lit_llama.utils import find_multiple\n\tMaskCache = torch.Tensor\n\tRoPECache = torch.Tensor\n\tKVCache = Tuple[torch.Tensor, torch.Tensor]\n\t@dataclass\n\tclass LLaMAConfig:\n\t    block_size: int = 2048\n\t    vocab_size: int = 32000\n\t    padded_vocab_size: Optional[int] = None\n", "    n_layer: int = 32\n\t    n_head: int = 32\n\t    n_embd: int = 4096\n\t    def __post_init__(self):\n\t        if self.padded_vocab_size is None:\n\t            self.padded_vocab_size = find_multiple(self.vocab_size, 64)\n\t    @classmethod\n\t    def from_name(cls, name: str) -> Self:\n\t        return cls(**llama_configs[name])\n\tllama_configs = {\n", "    \"7B\": dict(n_layer=32, n_head=32, n_embd=4096),\n\t    \"13B\": dict(n_layer=40, n_head=40, n_embd=5120),\n\t    \"30B\": dict(n_layer=60, n_head=52, n_embd=6656),\n\t    \"65B\": dict(n_layer=80, n_head=64, n_embd=8192),\n\t}\n\tclass LLaMA(nn.Module):\n\t    def __init__(self, config: LLaMAConfig) -> None:\n\t        super().__init__()\n\t        assert config.padded_vocab_size is not None\n\t        self.config = config\n", "        self.lm_head = nn.Linear(config.n_embd, config.padded_vocab_size, bias=False)\n\t        self.transformer = nn.ModuleDict(\n\t            dict(\n\t                wte=nn.Embedding(config.padded_vocab_size, config.n_embd),\n\t                h=nn.ModuleList(Block(config) for _ in range(config.n_layer)),\n\t                ln_f=RMSNorm(config.n_embd),\n\t            )\n\t        )\n\t        self.rope_cache: Optional[RoPECache] = None\n\t        self.mask_cache: Optional[MaskCache] = None\n", "        self.kv_caches: List[KVCache] = []\n\t    def _init_weights(self, module: nn.Module) -> None:\n\t        if isinstance(module, nn.Linear):\n\t            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02 / math.sqrt(2 * self.config.n_layer))\n\t        elif isinstance(module, nn.Embedding):\n\t            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02 / math.sqrt(2 * self.config.n_layer))\n\t    def forward(\n\t        self, idx: torch.Tensor, max_seq_length: Optional[int] = None, input_pos: Optional[torch.Tensor] = None\n\t    ) -> Union[torch.Tensor, Tuple[torch.Tensor, List[KVCache]]]:\n\t        B, T = idx.size()\n", "        block_size = self.config.block_size\n\t        if max_seq_length is None:\n\t            max_seq_length = block_size\n\t        assert T <= max_seq_length, f\"Cannot forward sequence of length {T}, max seq length is only {max_seq_length}\"\n\t        assert max_seq_length <= block_size, f\"Cannot attend to {max_seq_length}, block size is only {block_size}\"\n\t        assert T <= block_size, f\"Cannot forward sequence of length {T}, block size is only {block_size}\"\n\t        if self.rope_cache is None:\n\t            self.rope_cache = self.build_rope_cache(idx)\n\t        if self.mask_cache is None:\n\t            self.mask_cache = self.build_mask_cache(idx)\n", "        if input_pos is not None:\n\t            rope = self.rope_cache.index_select(0, input_pos)\n\t            mask = self.mask_cache.index_select(2, input_pos)\n\t            mask = mask[:, :, :, :max_seq_length]\n\t        else:\n\t            rope = self.rope_cache[:T]\n\t            mask = self.mask_cache[:, :, :T, :T]\n\t        # forward the model itself\n\t        x = self.transformer.wte(idx)  # token embeddings of shape (b, t, n_embd)\n\t        if input_pos is None:  # proxy for use_cache=False\n", "            for block in self.transformer.h:\n\t                x, _ = block(x, rope, mask, max_seq_length)\n\t        else:\n\t            if not self.kv_caches:\n\t                head_size = self.config.n_embd // self.config.n_head\n\t                cache_shape = (B, self.config.n_head, max_seq_length, head_size)\n\t                self.kv_caches = [\n\t                    (torch.zeros(cache_shape, device=x.device, dtype=x.dtype), torch.zeros(cache_shape, device=x.device, dtype=x.dtype))\n\t                    for _ in range(self.config.n_layer)\n\t                ]\n", "            for i, block in enumerate(self.transformer.h):\n\t                x, self.kv_caches[i] = block(x, rope, mask, max_seq_length, input_pos, self.kv_caches[i])\n\t        x = self.transformer.ln_f(x)\n\t        logits = self.lm_head(x)  # (b, t, vocab_size)\n\t        return logits\n\t    @classmethod\n\t    def from_name(cls, name: str) -> Self:\n\t        return cls(LLaMAConfig.from_name(name))\n\t    def build_rope_cache(self, idx: torch.Tensor) -> RoPECache:\n\t        return build_rope_cache(\n", "            seq_len=self.config.block_size,\n\t            n_elem=self.config.n_embd // self.config.n_head,\n\t            dtype=idx.dtype,\n\t            device=idx.device,\n\t        )\n\t    def build_mask_cache(self, idx: torch.Tensor) -> MaskCache:\n\t        ones = torch.ones((self.config.block_size, self.config.block_size), device=idx.device, dtype=torch.bool)\n\t        return torch.tril(ones).unsqueeze(0).unsqueeze(0)\n\t    def reset_cache(self) -> None:\n\t        self.kv_caches.clear()\n", "        if self.mask_cache.device.type == \"xla\":\n\t            # https://github.com/Lightning-AI/lit-parrot/pull/83#issuecomment-1558150179\n\t            self.rope_cache = None\n\t            self.mask_cache = None\n\tclass Block(nn.Module):\n\t    def __init__(self, config: LLaMAConfig) -> None:\n\t        super().__init__()\n\t        self.rms_1 = RMSNorm(config.n_embd)\n\t        self.attn = CausalSelfAttention(config)\n\t        self.rms_2 = RMSNorm(config.n_embd)\n", "        self.mlp = MLP(config)\n\t    def forward(\n\t        self,\n\t        x: torch.Tensor,\n\t        rope: RoPECache,\n\t        mask: MaskCache,\n\t        max_seq_length: int,\n\t        input_pos: Optional[torch.Tensor] = None,\n\t        kv_cache: Optional[KVCache] = None,\n\t    ) -> Tuple[torch.Tensor, Optional[KVCache]]:\n", "        h, new_kv_cache = self.attn(self.rms_1(x), rope, mask, max_seq_length, input_pos, kv_cache)\n\t        x = x + h\n\t        x = x + self.mlp(self.rms_2(x))\n\t        return x, new_kv_cache\n\tclass CausalSelfAttention(nn.Module):\n\t    def __init__(self, config: LLaMAConfig) -> None:\n\t        super().__init__()\n\t        assert config.n_embd % config.n_head == 0\n\t        # key, query, value projections for all heads, but in a batch\n\t        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd, bias=False)\n", "        # output projection\n\t        self.c_proj = nn.Linear(config.n_embd, config.n_embd, bias=False)\n\t        self.n_head = config.n_head\n\t        self.n_embd = config.n_embd\n\t        self.block_size = config.block_size\n\t    def forward(\n\t        self,\n\t        x: torch.Tensor,\n\t        rope: RoPECache,\n\t        mask: MaskCache,\n", "        max_seq_length: int,\n\t        input_pos: Optional[torch.Tensor] = None,\n\t        kv_cache: Optional[KVCache] = None,\n\t    ) -> Tuple[torch.Tensor, Optional[KVCache]]:\n\t        B, T, C = x.size()  # batch size, sequence length, embedding dimensionality (n_embd)\n\t        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n\t        q, k, v = self.c_attn(x).split(self.n_embd, dim=2)\n\t        head_size = C // self.n_head\n\t        k = k.view(B, T, self.n_head, head_size)\n\t        q = q.view(B, T, self.n_head, head_size)\n", "        v = v.view(B, T, self.n_head, head_size)\n\t        q = apply_rope(q, rope)\n\t        k = apply_rope(k, rope)\n\t        k = k.transpose(1, 2)  # (B, nh, T, hs)\n\t        q = q.transpose(1, 2)  # (B, nh, T, hs)\n\t        v = v.transpose(1, 2)  # (B, nh, T, hs)\n\t        if kv_cache is not None:\n\t            cache_k, cache_v = kv_cache\n\t            # check if reached token limit\n\t            if input_pos[-1] >= max_seq_length:\n", "                input_pos = torch.tensor(max_seq_length - 1, device=input_pos.device)\n\t                # shift 1 position to the left\n\t                cache_k = torch.roll(cache_k, -1, dims=2)\n\t                cache_v = torch.roll(cache_v, -1, dims=2)\n\t            k = cache_k.index_copy(2, input_pos, k)\n\t            v = cache_v.index_copy(2, input_pos, v)\n\t            kv_cache = k, v\n\t        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n\t        #  att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n\t        #  att = att.masked_fill(mask[:,:,:T,:T] == 0, float('-inf'))\n", "        #  att = F.softmax(att, dim=-1)\n\t        #  y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n\t        # efficient attention using Flash Attention CUDA kernels\n\t        y = F.scaled_dot_product_attention(q, k, v, attn_mask=mask, dropout_p=0.0)\n\t        y = y.transpose(1, 2).contiguous().view(B, T, C)  # re-assemble all head outputs side by side\n\t        # output projection\n\t        y = self.c_proj(y)\n\t        return y, kv_cache\n\tclass MLP(nn.Module):\n\t    def __init__(self, config: LLaMAConfig) -> None:\n", "        super().__init__()\n\t        hidden_dim = 4 * config.n_embd\n\t        n_hidden = int(2 * hidden_dim / 3)\n\t        n_hidden = find_multiple(n_hidden, 256)\n\t        self.c_fc1 = nn.Linear(config.n_embd, n_hidden, bias=False)\n\t        self.c_fc2 = nn.Linear(config.n_embd, n_hidden, bias=False)\n\t        self.c_proj = nn.Linear(n_hidden, config.n_embd, bias=False)\n\t    def forward(self, x: torch.Tensor) -> torch.Tensor:\n\t        x = F.silu(self.c_fc1(x)) * self.c_fc2(x)\n\t        x = self.c_proj(x)\n", "        return x\n\tclass RMSNorm(nn.Module):\n\t    \"\"\"Root Mean Square Layer Normalization.\n\t    Derived from https://github.com/bzhangGo/rmsnorm/blob/master/rmsnorm_torch.py. BSD 3-Clause License:\n\t    https://github.com/bzhangGo/rmsnorm/blob/master/LICENSE.\n\t    \"\"\"\n\t    def __init__(self, size: int, dim: int = -1, eps: float = 1e-5) -> None:\n\t        super().__init__()\n\t        self.scale = nn.Parameter(torch.ones(size))\n\t        self.eps = eps\n", "        self.dim = dim\n\t    def forward(self, x: torch.Tensor) -> torch.Tensor:\n\t        # NOTE: the original RMSNorm paper implementation is not equivalent\n\t        # norm_x = x.norm(2, dim=self.dim, keepdim=True)\n\t        # rms_x = norm_x * d_x ** (-1. / 2)\n\t        # x_normed = x / (rms_x + self.eps)\n\t        norm_x = torch.mean(x * x, dim=self.dim, keepdim=True)\n\t        x_normed = x * torch.rsqrt(norm_x + self.eps)\n\t        return self.scale * x_normed\n\tdef build_rope_cache(\n", "    seq_len: int, n_elem: int, dtype: torch.dtype, device: torch.device, base: int = 10000\n\t) -> RoPECache:\n\t    \"\"\"Enhanced Transformer with Rotary Position Embedding.\n\t    Derived from: https://github.com/labmlai/annotated_deep_learning_paper_implementations/blob/master/labml_nn/\n\t    transformers/rope/__init__.py. MIT License:\n\t    https://github.com/labmlai/annotated_deep_learning_paper_implementations/blob/master/license.\n\t    \"\"\"\n\t    # $\\Theta = {\\theta_i = 10000^{\\frac{2(i-1)}{d}}, i \\in [1, 2, ..., \\frac{d}{2}]}$\n\t    theta = 1.0 / (base ** (torch.arange(0, n_elem, 2, dtype=dtype, device=device) / n_elem))\n\t    # Create position indexes `[0, 1, ..., seq_len - 1]`\n", "    seq_idx = torch.arange(seq_len, dtype=dtype, device=device)\n\t    # Calculate the product of position index and $\\theta_i$\n\t    idx_theta = torch.outer(seq_idx, theta).float()\n\t    cache = torch.stack([torch.cos(idx_theta), torch.sin(idx_theta)], dim=-1)\n\t    # this is to mimic the behaviour of complex32, else we will get different results\n\t    if dtype in (torch.float16, torch.bfloat16, torch.int8):\n\t        cache = cache.half()\n\t    return cache\n\tdef apply_rope(x: torch.Tensor, rope_cache: RoPECache) -> torch.Tensor:\n\t    # truncate to support variable sizes\n", "    T = x.size(1)\n\t    rope_cache = rope_cache[:T]\n\t    # cast because the reference does\n\t    xshaped = x.float().reshape(*x.shape[:-1], -1, 2)\n\t    rope_cache = rope_cache.view(1, xshaped.size(1), 1, xshaped.size(3), 2)\n\t    x_out2 = torch.stack(\n\t        [\n\t            xshaped[..., 0] * rope_cache[..., 0] - xshaped[..., 1] * rope_cache[..., 1],\n\t            xshaped[..., 1] * rope_cache[..., 0] + xshaped[..., 0] * rope_cache[..., 1],\n\t        ],\n", "        -1,\n\t    )\n\t    x_out2 = x_out2.flatten(3)\n\t    return x_out2.type_as(x)\n"]}
{"filename": "lit_llama/tokenizer.py", "chunked_list": ["import os\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport torch\n\tfrom sentencepiece import SentencePieceProcessor, SentencePieceTrainer\n\tclass Tokenizer:\n\t    \"\"\"Tokenizer for LLaMA.\"\"\"\n\t    def __init__(self, model_path: Path) -> None:\n\t        self.processor = SentencePieceProcessor(model_file=str(model_path))\n\t        self.bos_id = self.processor.bos_id()\n", "        self.eos_id = self.processor.eos_id()\n\t        self.pad_id = self.processor.pad_id()\n\t    @property\n\t    def vocab_size(self) -> int:\n\t        return self.processor.vocab_size()\n\t    def encode(\n\t        self,\n\t        string: str,\n\t        bos: bool = True,\n\t        eos: bool = False,\n", "        max_length: int = -1,\n\t        pad: bool = False,\n\t        device: Optional[torch.device] = None\n\t    ) -> torch.Tensor:\n\t        tokens = self.processor.encode(string)\n\t        if bos:\n\t            tokens = [self.bos_id] + tokens\n\t        if eos:\n\t            tokens = tokens + [self.eos_id]\n\t        if max_length > 0:\n", "            tokens = tokens[:max_length]\n\t        if pad and len(tokens) < max_length:\n\t            tokens += [self.pad_id] * (max_length - len(tokens))\n\t        return torch.tensor(tokens, dtype=torch.int, device=device)\n\t    def decode(self, tokens: torch.Tensor) -> str:\n\t        return self.processor.decode(tokens.tolist())\n\t    @staticmethod\n\t    def train(input: str, destination: str, vocab_size=32000) -> None:\n\t        model_prefix = os.path.join(destination, \"tokenizer\")\n\t        SentencePieceTrainer.Train(input=input, model_prefix=model_prefix, vocab_size=vocab_size)\n"]}
{"filename": "lit_llama/adapter_v2.py", "chunked_list": ["import torch\n\tfrom torch import Tensor\n\timport torch.nn as nn\n\tfrom torch.nn import functional as F\n\tfrom lit_llama.adapter import LLaMA\n\tdef get_adapter_substrings():\n\t    substrings = [\"adapter_wte\", \"gating_factor\"]  # regular adapter v1 parameters\n\t    substrings.extend([\"adapter_scale\", \"adapter_bias\"])  # adapter v2: new bias and scale used in Linear\n\t    substrings.extend([\"rms_1\", \"rms_2\", \"ln_f\"])  # adapter v2: RMSNorm parameters are now trainable\n\t    return substrings\n", "def mark_only_adapter_v2_as_trainable(model: LLaMA) -> None:\n\t    \"\"\"Sets `requires_grad=False` for all non-adapter weights.\"\"\"\n\t    for name, param in model.named_parameters():\n\t        param.requires_grad = any(s in name for s in get_adapter_substrings())\n\tdef adapter_v2_state_from_state_dict(state_dict: dict) -> dict:\n\t    \"\"\"Returns the model state dict with only the adapter weights for saving.\"\"\"\n\t    return {name: param for name, param in state_dict.items()\n\t            if any(s in name for s in get_adapter_substrings())}\n\tdef adapter_v2_new_forward(self, input: Tensor) -> Tensor:\n\t    return self.adapter_scale * (\n", "        F.linear(input, self.weight, self.bias) + self.adapter_bias\n\t    )\n\tdef adapter_v2_linear_with_bias_and_scale(layer):\n\t    layer.adapter_bias = torch.nn.Parameter(torch.zeros(layer.weight.shape[0]), requires_grad=True)\n\t    layer.adapter_scale = torch.nn.Parameter(torch.ones(layer.weight.shape[0]), requires_grad=True)\n\t    bound_method = adapter_v2_new_forward.__get__(layer, layer.__class__)\n\t    setattr(layer, 'forward', bound_method)\n\t    return layer\n\tdef add_adapter_v2_parameters_to_linear_layers(model):\n\t    for module in model.modules():\n", "        if isinstance(module, nn.Linear):\n\t            adapter_v2_linear_with_bias_and_scale(module)\n"]}
{"filename": "lit_llama/__init__.py", "chunked_list": ["from lit_llama.model import LLaMAConfig, LLaMA, RMSNorm, build_rope_cache, apply_rope\n\tfrom lit_llama.tokenizer import Tokenizer\n"]}
{"filename": "lit_llama/adapter.py", "chunked_list": ["\"\"\"Implementation of the paper:\n\tLLaMA-Adapter: Efficient Fine-tuning of Language Models with Zero-init Attention\n\thttps://arxiv.org/abs/2303.16199\n\t                                                                             |              Prefix cross-attention\n\t                                                                             |\n\t  ┌─────────────────┐                                                        |               ┌──────────────────┐\n\t  ┆        x        ┆                                                        |               ┆      prefix      ┆\n\t  └─────────────────┘                                                        |               └──────────────────┘\n\t           |                                                                 |                        |\n\t           ▼                                                                 |                        ▼\n", "  ┌──────────────────┐                                                       |              ┌─────────────────────┐\n\t  ┆  self-attention  ┆ --------------------------------------------------------------┐      ┆  linear projection  ┆\n\t  └──────────────────┘                                                       |       ┆      └─────────────────────┘\n\t           |                                                                 |       ┆                |         \\\n\t           ▼                                                                 |       ▼                ▼          ▼\n\t         ╭───╮     ┌────────────────┐ ╭───╮ ┌──────────────────────────┐     |  ┌─────────┐    ┌──────────────┐  ┌────────────────┐\n\t         ┆ + ┆ ◀── ┆  gating factor ┆-┆ x ┆-┆  prefix cross-attention  ┆     |  ┆  query  ┆    ┆  prefix key  ┆  ┆  prefix value  ┆\n\t         ╰───╯     └────────────────┘ ╰───╯ └──────────────────────────┘     |  └─────────┘    └──────────────┘  └────────────────┘\n\t           |                                                                 |          \\             |           /\n\t           ▼                                                                 |           ▼            ▼          ▼\n", "                                                                             |         ┌────────────────────────────────┐\n\t                                                                             |         ┆  scaled dot-product attention  ┆\n\t                                                                             |         └────────────────────────────────┘\n\tIn order to inject learnable information from the prefix to pretrained weights we need to sum outputs from\n\tself-attention and prefix cross-attention (times gating factor). For prefix cross-attention we need `query` (from\n\tself-attention as a result of linear projection), `prefix key` and `prefix value` (from cross-attention as a result of\n\tlinear projection).\n\tThe output of prefix cross-attention is multiplied by gating factor, which is a learnable parameter that is needed to\n\tavoid potential disruption of pretrained weights caused by incorporating randomly initialized tensors. This factor is\n\tinitialized with zeros to avoid noise from the adaption prompts at the early training stage.\n", "More about it: https://lightning.ai/pages/community/article/understanding-llama-adapters/\n\tNotes about implementation: as per paper adapter's prefix is concatenated with the input, while here outputs of\n\tself-attention and prefix cross-attention are summed. Both variants are mathematically equivalent:\n\thttps://github.com/ZrrSkywalker/LLaMA-Adapter/issues/47\n\t\"\"\"\n\t# mypy: ignore-errors\n\tfrom dataclasses import dataclass\n\tfrom typing import Optional, Tuple, List, Union\n\timport torch\n\timport torch.nn as nn\n", "from torch.nn import functional as F\n\timport lit_llama.model as llama\n\tfrom lit_llama.model import build_rope_cache, apply_rope, RMSNorm, MLP, KVCache, RoPECache\n\t@dataclass\n\tclass LLaMAConfig(llama.LLaMAConfig):\n\t    adapter_prompt_length: int = 10\n\t    adapter_start_layer: int = 2\n\tclass CausalSelfAttention(nn.Module):\n\t    \"\"\"A modification of `lit_llama.model.CausalSelfAttention` that adds the attention\n\t    over the adaption prompt.\"\"\"\n", "    def __init__(self, config: LLaMAConfig, block_idx: int) -> None:\n\t        super().__init__()\n\t        assert config.n_embd % config.n_head == 0\n\t        # key, query, value projections for all heads, but in a batch\n\t        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd, bias=False)\n\t        # output projection\n\t        self.c_proj = nn.Linear(config.n_embd, config.n_embd, bias=False)\n\t        if block_idx >= config.adapter_start_layer:\n\t            # adapter embedding layer\n\t            self.adapter_wte = nn.Embedding(config.adapter_prompt_length, config.n_embd)\n", "            # a learnable gating factor (to avoid potential disruption of pretrained weights) initialized with zeros (to\n\t            # avoid noise from adaption prompts at the early training stage)\n\t            self.gating_factor = torch.nn.Parameter(torch.zeros(1, config.n_head, 1, 1))\n\t        self.n_head = config.n_head\n\t        self.n_embd = config.n_embd\n\t        self.block_size = config.block_size\n\t        self.block_idx = block_idx\n\t        self.adapter_prompt_length = config.adapter_prompt_length\n\t        self.adapter_start_layer = config.adapter_start_layer\n\t    def forward(\n", "        self,\n\t        x: torch.Tensor,\n\t        rope: RoPECache,\n\t        mask: torch.Tensor,\n\t        max_seq_length: int,\n\t        input_pos: Optional[torch.Tensor] = None,\n\t        kv_cache: Optional[KVCache] = None,\n\t        adapter_kv_cache: Optional[KVCache] = None,\n\t    ) -> Tuple[torch.Tensor, Optional[KVCache], Optional[KVCache]]:\n\t        # notation:\n", "        # - B  | batch\n\t        # - T  | time-step (sequence length)\n\t        # - C  | embeddings size (n_embd) = head size * num heads\n\t        # - hs | head size\n\t        # - nh | number of heads\n\t        B, T, C = x.size()\n\t        # instead of calculating `query`, `key` and `value` by separately multiplying input `x` with corresponding\n\t        # weight matrices do it (for all heads) in a single multiplication with a matrix of 3x size (concatenated\n\t        # weights for q, k, v) and then split the result along `embedding size` dimension\n\t        q, k, v = self.c_attn(x).split(self.n_embd, dim=2) # (B, T, 3 * C) --> 3 * (B, T, C)\n", "        # in order to move head_size (hs) dimension right after batch (B) dimension, we need to first split\n\t        # embedding size (C) dimension into num_heads (nh) and head_size (hs)\n\t        head_size = C // self.n_head\n\t        k = k.view(B, T, self.n_head, head_size)\n\t        q = q.view(B, T, self.n_head, head_size)\n\t        v = v.view(B, T, self.n_head, head_size)\n\t        # \"Unlike standard positional embeddings rotary embeddings must be applied at every layer\"\n\t        q = apply_rope(q, rope) # (B, T, nh, hs)\n\t        k = apply_rope(k, rope) # (B, T, nh, hs)\n\t        # now `key`, 'query` and `value` tensors are correctly represented: for each element in a batch (B)\n", "        # there is a number of heads (nh) and for each head there is a sequence of elements (T), each of them is\n\t        # represented by a vector of size `hs`\n\t        k = k.transpose(1, 2)  # (B, nh, T, hs)\n\t        q = q.transpose(1, 2)  # (B, nh, T, hs)\n\t        v = v.transpose(1, 2)  # (B, nh, T, hs)\n\t        if kv_cache is not None:\n\t            cache_k, cache_v = kv_cache # 2 * (B, nh, max_seq_length, hs)\n\t            # check if reached token limit\n\t            if input_pos[-1] >= max_seq_length:\n\t                # if we reached token limit and thus there is no space to put newly calculated `key` and `value`\n", "                # right next to cached ones, we need to rotate cache tensor along `max_seq_length` dimension by one\n\t                # element to the left: this will free up space for new `key` and `value`\n\t                input_pos = torch.tensor(max_seq_length - 1, device=input_pos.device)\n\t                # shift 1 position to the left\n\t                cache_k = torch.roll(cache_k, -1, dims=2)\n\t                cache_v = torch.roll(cache_v, -1, dims=2)\n\t            k = cache_k.index_copy(2, input_pos, k) # (B, nh, max_seq_length, hs)\n\t            v = cache_v.index_copy(2, input_pos, v) # (B, nh, max_seq_length, hs)\n\t            kv_cache = k, v\n\t        # efficient attention using Flash Attention CUDA kernels\n", "        # ↓ (B, nh, T, hs) @ (B, nh, T, hs).mT --> (B, nh, T, T) @ (B, nh, T, hs) --> (B, nh, T, hs)\n\t        y = F.scaled_dot_product_attention(q, k, v, attn_mask=mask, dropout_p=0.0) # (B, nh, T, hs)\n\t        # \"Adapters are applied to the topmost layers to better tune the language\n\t        # representations with higher-level semantics\".\n\t        if self.block_idx >= self.adapter_start_layer:\n\t            if adapter_kv_cache is not None:\n\t                ak, av = adapter_kv_cache # 2 * (B, nh, aT, hs)\n\t            else:\n\t                prefix = self.adapter_wte.weight.reshape(1, self.adapter_prompt_length, self.n_embd)\n\t                aT = prefix.size(1)\n", "                _, ak, av = self.c_attn(prefix).split(self.n_embd, dim=2) # (1, aT, 3 * C) --> 3 * (1, aT, C)\n\t                ak = ak.view(1, aT, self.n_head, head_size).repeat(B, 1, 1, 1).transpose(1, 2) # (B, nh, aT, hs)\n\t                av = av.view(1, aT, self.n_head, head_size).repeat(B, 1, 1, 1).transpose(1, 2) # (B, nh, aT, hs)\n\t                adapter_kv_cache = (ak, av)\n\t            # Apply cross-attention with `query`, `adapter_key`, `adapter_value` and sum the output with the output\n\t            # obtained from self-attention step. This is mathematically equivalent to concatenation of prefix and input as per paper.\n\t            amask = torch.ones(q.shape[-2], ak.shape[-2], dtype=torch.bool, device=x.device) # (T, aT)\n\t            # ↓ (B, nh, T, hs) @ (B, nh, aT, hs).mT --> (B, nh, T, aT) @ (B, nh, aT, hs) --> (B, nh, T, hs)\n\t            ay = F.scaled_dot_product_attention(q, ak, av, attn_mask=amask, dropout_p=0.0, is_causal=False) # (B, nh, T, hs)\n\t            y = y + self.gating_factor * ay\n", "        y = y.transpose(1, 2).contiguous().view(B, T, C)  # re-assemble all head outputs side by side\n\t        # output projection\n\t        y = self.c_proj(y) # (B, T, C)\n\t        return y, kv_cache, adapter_kv_cache\n\t    def _load_from_state_dict(self, state_dict, prefix, *args, **kwargs):\n\t        \"\"\"For backward compatibility with old checkpoints that have a single gating value for all heads.\"\"\"\n\t        name = prefix + \"gating_factor\"\n\t        if name in state_dict:\n\t            tensor = state_dict[name]\n\t            # in case we are loading with `utils.lazy_load()`\n", "            tensor = tensor._load_tensor() if hasattr(tensor, \"_load_tensor\") else tensor\n\t            if len(tensor.shape) < 4:\n\t                # For old checkpoints with unified gating value\n\t                state_dict[name] = tensor.reshape(1, 1, 1, 1).repeat(1, self.n_head, 1, 1)\n\t            else:\n\t                state_dict[name] = tensor\n\t        return super()._load_from_state_dict(state_dict, prefix, *args, **kwargs)\n\tclass Block(nn.Module):\n\t    \"\"\"The implementation is identical to `lit_llama.model.Block` with the exception that\n\t    we replace the attention layer where adaption is implemented.\"\"\"\n", "    def __init__(self, config: LLaMAConfig, block_idx: int) -> None:\n\t        super().__init__()\n\t        self.rms_1 = RMSNorm(config.n_embd)\n\t        self.attn = CausalSelfAttention(config, block_idx)\n\t        self.rms_2 = RMSNorm(config.n_embd)\n\t        self.mlp = MLP(config)\n\t    def forward(\n\t        self,\n\t        x: torch.Tensor,\n\t        rope: RoPECache,\n", "        mask: torch.Tensor,\n\t        max_seq_length: int,\n\t        input_pos: Optional[torch.Tensor] = None,\n\t        kv_cache: Optional[KVCache] = None,\n\t        adapter_kv_cache: Optional[KVCache] = None,\n\t    ) -> Tuple[torch.Tensor, Optional[KVCache], Optional[KVCache]]:\n\t        h, new_kv_cache, new_adapter_kv_cache = self.attn(\n\t            self.rms_1(x), rope, mask, max_seq_length, input_pos, kv_cache, adapter_kv_cache\n\t        )\n\t        x = x + h\n", "        x = x + self.mlp(self.rms_2(x))\n\t        return x, new_kv_cache, new_adapter_kv_cache\n\tclass LLaMA(llama.LLaMA):\n\t    \"\"\"The implementation is identical to `lit_llama.model.LLaMA` with the exception that\n\t    the `Block` saves the layer index and passes it down to the attention layer.\"\"\"\n\t    def __init__(self, config: LLaMAConfig) -> None:\n\t        nn.Module.__init__(self)\n\t        assert config.vocab_size is not None\n\t        assert config.block_size is not None\n\t        self.config = config\n", "        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\t        self.transformer = nn.ModuleDict(\n\t            dict(\n\t                wte=nn.Embedding(config.vocab_size, config.n_embd),\n\t                h=nn.ModuleList(Block(config, i) for i in range(config.n_layer)),\n\t                ln_f=RMSNorm(config.n_embd),\n\t            )\n\t        )\n\t        self.rope_cache: Optional[RoPECache] = None\n\t        self.mask_cache: Optional[torch.Tensor] = None\n", "        self.kv_caches: List[KVCache] = []\n\t        self.adapter_kv_caches: List[KVCache] = []\n\t    @classmethod\n\t    def from_name(cls, name: str):\n\t        return cls(LLaMAConfig.from_name(name))\n\t    def reset_cache(self) -> None:\n\t        super().reset_cache()\n\t        self.adapter_kv_caches.clear()\n\t    def forward(\n\t        self, idx: torch.Tensor, max_seq_length: Optional[int] = None, input_pos: Optional[torch.Tensor] = None\n", "    ) -> Union[torch.Tensor, Tuple[torch.Tensor, List[KVCache]]]:\n\t        B, T = idx.size()\n\t        block_size = self.config.block_size\n\t        if max_seq_length is None:\n\t            max_seq_length = block_size\n\t        assert T <= max_seq_length, f\"Cannot forward sequence of length {T}, max seq length is only {max_seq_length}\"\n\t        assert max_seq_length <= block_size, f\"Cannot attend to {max_seq_length}, block size is only {block_size}\"\n\t        assert T <= block_size, f\"Cannot forward sequence of length {T}, block size is only {block_size}\"\n\t        if self.rope_cache is None:\n\t            self.rope_cache = self.build_rope_cache(idx) # (block_size, head_size / 2, 2)\n", "        if self.mask_cache is None:\n\t            self.mask_cache = self.build_mask_cache(idx) # (1, 1, block_size, block_size)\n\t        if input_pos is not None:\n\t            rope = self.rope_cache.index_select(0, input_pos)\n\t            mask = self.mask_cache.index_select(2, input_pos)\n\t            mask = mask[:, :, :, :max_seq_length]\n\t        else:\n\t            rope = self.rope_cache[:T]\n\t            mask = self.mask_cache[:, :, :T, :T]\n\t        # forward the model itself\n", "        x = self.transformer.wte(idx)  # token embeddings of shape (B, T, n_embd)\n\t        if input_pos is None:  # proxy for use_cache=False\n\t            for block in self.transformer.h:\n\t                x, *_ = block(x, rope, mask, max_seq_length)\n\t        else:\n\t            if not self.kv_caches:\n\t                head_size = self.config.n_embd // self.config.n_head\n\t                cache_shape = (B, self.config.n_head, max_seq_length, head_size)\n\t                self.kv_caches = [\n\t                    (torch.zeros(cache_shape, device=x.device, dtype=x.dtype), torch.zeros(cache_shape, device=x.device, dtype=x.dtype))\n", "                    for _ in range(self.config.n_layer)\n\t                ]\n\t            if not self.adapter_kv_caches:\n\t                self.adapter_kv_caches = [None for _ in range(self.config.n_layer)]\n\t            for i, block in enumerate(self.transformer.h):\n\t                x, self.kv_caches[i], self.adapter_kv_caches[i] = block(\n\t                    x, rope, mask, max_seq_length, input_pos, self.kv_caches[i], self.adapter_kv_caches[i]\n\t                )\n\t        x = self.transformer.ln_f(x) # (B, T, n_embd)\n\t        logits = self.lm_head(x)  # (B, T, vocab_size)\n", "        return logits\n\tdef mark_only_adapter_as_trainable(model: LLaMA) -> None:\n\t    \"\"\"Sets `requires_grad=False` for all non-adapter weights.\"\"\"\n\t    for name, param in model.named_parameters():\n\t        param.requires_grad = \"adapter_wte\" in name or \"gating_factor\" in name\n\tdef adapter_state_from_state_dict(state_dict: dict) -> dict:\n\t    \"\"\"Returns the model state dict with only the adapter weights for saving.\"\"\"\n\t    return {name: param for name, param in state_dict.items() if \"adapter_wte\" in name or \"gating_factor\" in name}\n"]}
{"filename": "lit_llama/utils.py", "chunked_list": ["\"\"\"Utility functions for training and inference.\"\"\"\n\timport functools\n\timport pickle\n\timport warnings\n\tfrom io import BytesIO\n\tfrom pathlib import Path\n\tfrom contextlib import contextmanager\n\timport torch\n\timport torch.utils._device\n\tfrom lightning.fabric.strategies import DeepSpeedStrategy, FSDPStrategy\n", "from torch.distributed.fsdp import FullStateDictConfig\n\tfrom torch.distributed.fsdp import FullyShardedDataParallel as FSDP\n\tfrom torch.distributed.fsdp import StateDictType\n\tfrom torch.serialization import normalize_storage_type\n\tllama_model_sizes = {\n\t    4096: \"7B\",  # 7B n_embd=4096\n\t    5120: \"13B\",  # 13B n_embd=5120\n\t    6656: \"30B\",  # 30B n_embd=6656\n\t    8192: \"65B\",  # 65B n_embd=8192\n\t}\n", "def llama_model_lookup(checkpoint: dict) -> str:\n\t    \"\"\"Returns the LLaMA model name from the checkpoint.\n\t    Checks the width of the lm_head.weight matrix, as these uniquely identify the model.\n\t    \"\"\"\n\t    embedding_size = checkpoint['transformer.wte.weight'].shape[1]\n\t    return llama_model_sizes[embedding_size]\n\tdef find_multiple(n: int, k: int) -> int:\n\t    if n % k == 0:\n\t        return n\n\t    return n + k - (n % k)\n", "def save_model_checkpoint(fabric, model, file_path):\n\t    \"\"\"Handles boilerplate logic for retrieving and saving the state_dict.\n\t    This will be upstreamed to Fabric soon.\n\t    \"\"\"\n\t    file_path = Path(file_path)\n\t    if isinstance(fabric.strategy, DeepSpeedStrategy):\n\t        from deepspeed.utils.zero_to_fp32 import convert_zero_checkpoint_to_fp32_state_dict\n\t        fabric.save(file_path, {\"model\": model})\n\t        fabric.barrier()\n\t        if fabric.global_rank == 0:\n", "            # Create a consolidated checkpoint with the same name next to the deepspeed checkpoint\n\t            convert_zero_checkpoint_to_fp32_state_dict(file_path, file_path.with_suffix(\".pth\"))\n\t        return\n\t    if isinstance(fabric.strategy, FSDPStrategy):\n\t        save_policy = FullStateDictConfig(offload_to_cpu=(fabric.world_size > 1), rank0_only=True)\n\t        with FSDP.state_dict_type(model, StateDictType.FULL_STATE_DICT, save_policy):\n\t            state_dict = model._forward_module.state_dict()\n\t    else:\n\t        state_dict = model.state_dict()\n\t    if fabric.global_rank == 0:\n", "        torch.save(state_dict, file_path)\n\t    fabric.barrier()\n\tclass EmptyInitOnDevice(torch.overrides.TorchFunctionMode):\n\t    def __init__(self, device=None, dtype=None, quantization_mode=None):\n\t        \"\"\"\n\t        Create tensors with given device and dtype and don't run initialization\n\t           (but instead use \"empty tensors\", i.e. uninitialized memory).\n\t            device: `torch.device` to work with\n\t            dtype: `torch.dtype` to work with\n\t            quantization_mode: optional string, quantization mode to work with, default `None`.\n", "                 Available modes: `llm.int8` bitsnbytes LLM.int8 quantization (only on GPU)\n\t                                  `gptq.int4`, `gptq.int8`: GPTQ pre-quantized models\n\t        Example::\n\t            with EmptyInitOnDevice(\"cuda\", dtype=torch.bfloat16):\n\t               model = LLaMA.from_name('7B')\n\t            model.load_state_dict(torch.load('llama-lit/7B/lit-llama.pth'))\"\"\"\n\t        self.quantization_mode = quantization_mode\n\t        self.quantized_linear_cls = None\n\t        if self.quantization_mode == 'llm.int8':\n\t            if device.type != \"cuda\":\n", "                raise ValueError(\"Quantization is only supported on the GPU.\")\n\t            from .quantization import Linear8bitLt\n\t            self.quantized_linear_cls = Linear8bitLt\n\t        elif self.quantization_mode == 'gptq.int4':\n\t            from .quantization import ColBlockQuantizedLinear\n\t            self.quantized_linear_cls = functools.partial(ColBlockQuantizedLinear, bits=4, tile_cols=-1)\n\t        elif self.quantization_mode == 'gptq.int8':\n\t            from .quantization import ColBlockQuantizedLinear\n\t            self.quantized_linear_cls = functools.partial(ColBlockQuantizedLinear, bits=8, tile_cols=-1)\n\t        elif self.quantization_mode is not None:\n", "            raise RuntimeError(f\"unknown quantization mode {self.quantization_mode}\")\n\t        self.device = device\n\t        self.dtype = dtype\n\t    def __enter__(self):\n\t        if self.quantized_linear_cls != None:\n\t            self.torch_linear_cls = torch.nn.Linear\n\t            torch.nn.Linear = self.quantized_linear_cls\n\t        return super().__enter__()\n\t    def __exit__(self, exc_type, exc_val, exc_tb):\n\t        if self.quantized_linear_cls != None:\n", "            torch.nn.Linear = self.torch_linear_cls\n\t        return super().__exit__(exc_type, exc_val, exc_tb)\n\t    def __torch_function__(self, func, types, args=(), kwargs=None):\n\t        kwargs = kwargs or {}\n\t        if getattr(func, \"__module__\", None) == \"torch.nn.init\":\n\t            if \"tensor\" in kwargs:\n\t                return kwargs[\"tensor\"]\n\t            else:\n\t                return args[0]\n\t        if (\n", "            self.device is not None\n\t            and func in torch.utils._device._device_constructors()\n\t            and kwargs.get(\"device\") is None\n\t        ):\n\t            kwargs[\"device\"] = self.device\n\t        if (\n\t            self.dtype is not None\n\t            and func in torch.utils._device._device_constructors()\n\t            and kwargs.get(\"dtype\") is None\n\t        ):\n", "            kwargs[\"dtype\"] = self.dtype\n\t        return func(*args, **kwargs)\n\t@contextmanager\n\tdef quantization(mode: str = None):\n\t    quantized_linear_cls = None\n\t    if mode == 'llm.int8':\n\t        from .quantization import Linear8bitLt\n\t        quantized_linear_cls = Linear8bitLt\n\t    elif mode == 'gptq.int4':\n\t        from .quantization import ColBlockQuantizedLinear\n", "        quantized_linear_cls = functools.partial(ColBlockQuantizedLinear, bits=4, tile_cols=-1)\n\t    elif mode == 'gptq.int8':\n\t        from .quantization import ColBlockQuantizedLinear\n\t        quantized_linear_cls = functools.partial(ColBlockQuantizedLinear, bits=8, tile_cols=-1)\n\t    elif mode is not None:\n\t        raise ValueError(f\"Unknown quantization mode: {mode}\")\n\t    enabled = mode is not None\n\t    torch_linear_cls = torch.nn.Linear\n\t    if enabled:\n\t        torch.nn.Linear = quantized_linear_cls\n", "    yield\n\t    if enabled:\n\t        torch.nn.Linear = torch_linear_cls\n\t# this is taken from torchhacks https://github.com/lernapparat/torchhacks\n\tclass NotYetLoadedTensor:\n\t    def __init__(self, metatensor, archiveinfo, storageinfo, rebuild_args):\n\t        self.metatensor = metatensor\n\t        self.archiveinfo = archiveinfo\n\t        self.storageinfo = storageinfo\n\t        self.rebuild_args = rebuild_args\n", "    @classmethod\n\t    def rebuild_from_type_v2(cls, func, new_type, args, state, *, archiveinfo=None):\n\t        ret = func(*args)\n\t        if isinstance(ret, NotYetLoadedTensor):\n\t            old_lt = ret._load_tensor\n\t            def _load_tensor():\n\t                t = old_lt()\n\t                return torch._tensor._rebuild_from_type_v2(\n\t                    lambda: t, new_type, (), state\n\t                )\n", "            ret._load_tensor = _load_tensor\n\t            return ret\n\t        return torch._tensor._rebuild_from_type_v2(func, new_type, args, state)\n\t    @classmethod\n\t    def rebuild_parameter(\n\t        cls, data, requires_grad, backward_hooks, *, archiveinfo=None\n\t    ):\n\t        if isinstance(data, NotYetLoadedTensor):\n\t            old_lt = data._load_tensor\n\t            def _load_tensor():\n", "                t = old_lt()\n\t                return torch._utils._rebuild_parameter(t, requires_grad, backward_hooks)\n\t            data._load_tensor = _load_tensor\n\t            return data\n\t        return torch._utils._rebuild_parameter(data, requires_grad, backward_hooks)\n\t    @classmethod\n\t    def rebuild_tensor_v2(\n\t        cls,\n\t        storage,\n\t        storage_offset,\n", "        size,\n\t        stride,\n\t        requires_grad,\n\t        backward_hooks,\n\t        metadata=None,\n\t        *,\n\t        archiveinfo=None,\n\t    ):\n\t        rebuild_args = (\n\t            storage_offset,\n", "            size,\n\t            stride,\n\t            requires_grad,\n\t            backward_hooks,\n\t            metadata,\n\t        )\n\t        metatensor = torch._utils._rebuild_tensor_v2(\n\t            storage,\n\t            storage_offset,\n\t            size,\n", "            stride,\n\t            requires_grad,\n\t            backward_hooks,\n\t            metadata,\n\t        )\n\t        storageinfo = storage.archiveinfo\n\t        return NotYetLoadedTensor(metatensor, archiveinfo, storageinfo, rebuild_args)\n\t    def _load_tensor(self):\n\t        name, storage_cls, fn, device, size = self.storageinfo\n\t        dtype = self.metatensor.dtype\n", "        uts = (\n\t            self.archiveinfo.zipfile_context.zf.get_storage_from_record(\n\t                f\"data/{fn}\",\n\t                size * torch._utils._element_size(dtype),\n\t                torch.UntypedStorage,\n\t            )\n\t            ._typed_storage()\n\t            ._untyped_storage\n\t        )\n\t        with warnings.catch_warnings():\n", "            warnings.simplefilter(\"ignore\")\n\t            storage = torch.storage.TypedStorage(\n\t                wrap_storage=uts, dtype=self.metatensor.dtype, _internal=True\n\t            )\n\t        tensor = torch._utils._rebuild_tensor_v2(storage, *self.rebuild_args)\n\t        return tensor\n\t    @classmethod\n\t    def __torch_function__(cls, func, types, args=(), kwargs=None):\n\t        if kwargs is None:\n\t            kwargs = {}\n", "        loaded_args = [\n\t            (a._load_tensor() if isinstance(a, NotYetLoadedTensor) else a) for a in args\n\t        ]\n\t        res = func(*loaded_args, **kwargs)\n\t        # gc.collect would be costly here, maybe do it optionally\n\t        return res\n\t    def __getattr__(self, name):\n\t        # properties\n\t        ## TODO: device, is_...??\n\t        ## TODO: mH, mT, H, T, data, imag, real\n", "        ## name ???\n\t        if name in {\n\t            \"dtype\",\n\t            \"grad\",\n\t            \"grad_fn\",\n\t            \"layout\",\n\t            \"names\",\n\t            \"ndim\",\n\t            \"output_nr\",\n\t            \"requires_grad\",\n", "            \"retains_grad\",\n\t            \"shape\",\n\t            \"volatile\",\n\t        }:\n\t            return getattr(self.metatensor, name)\n\t        if name in {\"size\"}:\n\t            return getattr(self.metatensor, name)\n\t        # materializing with contiguous is needed for quantization\n\t        if name in {\"contiguous\"}:\n\t            return getattr(self._load_tensor(), name)\n", "        raise AttributeError(f\"{type(self)} does not have {name}\")\n\t    def __repr__(self):\n\t        return f\"NotYetLoadedTensor({repr(self.metatensor)})\"\n\tclass LazyLoadingUnpickler(pickle.Unpickler):\n\t    def __init__(self, file, zipfile_context):\n\t        super().__init__(file)\n\t        self.zipfile_context = zipfile_context\n\t    def find_class(self, module, name):\n\t        res = super().find_class(module, name)\n\t        if module == \"torch._utils\" and name == \"_rebuild_tensor_v2\":\n", "            return functools.partial(\n\t                NotYetLoadedTensor.rebuild_tensor_v2, archiveinfo=self\n\t            )\n\t        elif module == \"torch._tensor\" and name == \"_rebuild_from_type_v2\":\n\t            return functools.partial(\n\t                NotYetLoadedTensor.rebuild_from_type_v2, archiveinfo=self\n\t            )\n\t        elif module == \"torch._utils\" and name == \"_rebuild_parameter\":\n\t            return functools.partial(\n\t                NotYetLoadedTensor.rebuild_parameter, archiveinfo=self\n", "            )\n\t        return res\n\t    def persistent_load(self, pid):\n\t        name, cls, fn, device, size = pid\n\t        with warnings.catch_warnings():\n\t            warnings.simplefilter(\"ignore\")\n\t            s = torch.storage.TypedStorage(dtype=cls().dtype, device=\"meta\")\n\t        s.archiveinfo = pid\n\t        return s\n\tclass lazy_load:\n", "    def __init__(self, fn):\n\t        self.zf = torch._C.PyTorchFileReader(str(fn))\n\t        with BytesIO(self.zf.get_record(\"data.pkl\")) as pkl:\n\t            mup = LazyLoadingUnpickler(pkl, self)\n\t            self.sd = mup.load()\n\t    def __enter__(self):\n\t        return self.sd\n\t    def __exit__(self, exc_type, exc_val, exc_tb):\n\t        del self.zf  # I don't think there is a way to force closing...\n\t        self.zf = None\n", "class SavingProxyForStorage:\n\t    def __init__(self, obj, saver, protocol_version=5):\n\t        self.protocol_version = protocol_version\n\t        self.saver = saver\n\t        if not (isinstance(obj, torch.storage.TypedStorage) or torch.is_storage(obj)):\n\t            raise TypeError(f\"expected storage, not {type(obj)}\")\n\t        # this logic is taken from PyTorch 2.0+ torch/serialization.py\n\t        if isinstance(obj, torch.storage.TypedStorage):\n\t            # PT upstream wants to deprecate this eventually...\n\t            storage = obj._untyped_storage\n", "            storage_type_str = obj._pickle_storage_type()\n\t            storage_type = getattr(torch, storage_type_str)\n\t            storage_numel = obj._size()\n\t        else:\n\t            storage = obj\n\t            storage_type = normalize_storage_type(type(obj))\n\t            storage_numel = storage.nbytes()\n\t        storage_key = saver._write_storage_and_return_key(storage)\n\t        location = torch.serialization.location_tag(storage)\n\t        self.storage_info = (\n", "            \"storage\",\n\t            storage_type,\n\t            storage_key,\n\t            location,\n\t            storage_numel,\n\t        )\n\t    def __reduce_ex__(self, protocol_version):\n\t        assert False, \"this should be handled with out of band\"\n\tclass SavingProxyForTensor:\n\t    def __init__(self, tensor, saver, protocol_version=5):\n", "        self.protocol_version = protocol_version\n\t        self.reduce_ret_fn, (storage, *other_reduce_args) = tensor.__reduce_ex__(\n\t            protocol_version\n\t        )\n\t        assert isinstance(\n\t            storage, torch.storage.TypedStorage\n\t        ), \"Please check for updates\"\n\t        storage_proxy = SavingProxyForStorage(\n\t            storage, saver, protocol_version=protocol_version\n\t        )\n", "        self.reduce_args = (storage_proxy, *other_reduce_args)\n\t    def __reduce_ex__(self, protocol_version):\n\t        if protocol_version != self.protocol_version:\n\t            raise RuntimeError(\n\t                f\"Unexpected protocol version: expected {self.protocol_version}, got {protocol_version}\"\n\t            )\n\t        return self.reduce_ret_fn, self.reduce_args\n\tclass IncrementalPyTorchPickler(pickle.Pickler):\n\t    def __init__(self, saver, *args, **kwargs):\n\t        super().__init__(*args, **kwargs)\n", "        self.storage_dtypes = {}\n\t        self.saver = saver\n\t        self.id_map = {}\n\t    # this logic is taken from PyTorch 2.0+ torch/serialization.py\n\t    def persistent_id(self, obj):\n\t        # FIXME: the docs say that persistent_id should only return a string\n\t        # but torch store returns tuples. This works only in the binary protocol\n\t        # see\n\t        # https://docs.python.org/2/library/pickle.html#pickling-and-unpickling-external-objects\n\t        # https://github.com/python/cpython/blob/master/Lib/pickle.py#L527-L537\n", "        if isinstance(obj, SavingProxyForStorage):\n\t            return obj.storage_info\n\t        if isinstance(obj, torch.storage.TypedStorage) or torch.is_storage(obj):\n\t            if isinstance(obj, torch.storage.TypedStorage):\n\t                # TODO: Once we decide to break serialization FC, this case\n\t                # can be deleted\n\t                storage = obj._untyped_storage\n\t                storage_dtype = obj.dtype\n\t                storage_type_str = obj._pickle_storage_type()\n\t                storage_type = getattr(torch, storage_type_str)\n", "                storage_numel = obj._size()\n\t            else:\n\t                storage = obj\n\t                storage_dtype = torch.uint8\n\t                storage_type = normalize_storage_type(type(obj))\n\t                storage_numel = storage.nbytes()\n\t            # If storage is allocated, ensure that any other saved storages\n\t            # pointing to the same data all have the same dtype. If storage is\n\t            # not allocated, don't perform this check\n\t            if storage.data_ptr() != 0:\n", "                if storage.data_ptr() in self.storage_dtypes:\n\t                    if storage_dtype != self.storage_dtypes[storage.data_ptr()]:\n\t                        raise RuntimeError(\n\t                            \"Cannot save multiple tensors or storages that \"\n\t                            \"view the same data as different types\"\n\t                        )\n\t                else:\n\t                    self.storage_dtypes[storage.data_ptr()] = storage_dtype\n\t            storage_key = self.id_map.get(storage._cdata)\n\t            if storage_key is None:\n", "                storage_key = self.saver._write_storage_and_return_key(storage)\n\t                self.id_map[storage._cdata] = storage_key\n\t            location = torch.serialization.location_tag(storage)\n\t            return (\"storage\", storage_type, storage_key, location, storage_numel)\n\t        return None\n\tclass incremental_save:\n\t    def __init__(self, name):\n\t        self.name = name\n\t        self.zipfile = torch._C.PyTorchFileWriter(str(name))\n\t        self.has_saved = False\n", "        self.next_key = 0\n\t    def __enter__(self):\n\t        return self\n\t    def store_early(self, tensor):\n\t        if isinstance(tensor, torch.Tensor):\n\t            return SavingProxyForTensor(tensor, self)\n\t        raise TypeError(f\"can only store tensors early, not {type(tensor)}\")\n\t    def save(self, obj):\n\t        if self.has_saved:\n\t            raise RuntimeError(\"have already saved\")\n", "        # Write the pickle data for `obj`\n\t        data_buf = BytesIO()\n\t        pickler = IncrementalPyTorchPickler(self, data_buf, protocol=5)\n\t        pickler.dump(obj)\n\t        data_value = data_buf.getvalue()\n\t        self.zipfile.write_record(\"data.pkl\", data_value, len(data_value))\n\t        self.has_saved = True\n\t    def _write_storage_and_return_key(self, storage):\n\t        if self.has_saved:\n\t            raise RuntimeError(\"have already saved\")\n", "        key = self.next_key\n\t        self.next_key += 1\n\t        name = f\"data/{key}\"\n\t        if storage.device.type != \"cpu\":\n\t            storage = storage.cpu()\n\t        num_bytes = storage.nbytes()\n\t        self.zipfile.write_record(name, storage.data_ptr(), num_bytes)\n\t        return key\n\t    def __exit__(self, type, value, traceback):\n\t        self.zipfile.write_end_of_file()\n"]}
{"filename": "lit_llama/lora.py", "chunked_list": ["# Derived from https://github.com/microsoft/LoRA\n\t#  ------------------------------------------------------------------------------------------\n\t#  Copyright (c) Microsoft Corporation. All rights reserved.\n\t#  Licensed under the MIT License (MIT). See LICENSE in the repo root for license information.\n\t#  ------------------------------------------------------------------------------------------\n\tr\"\"\"\n\t    Low Ranking Adaptation for LLMs scheme.\n\t             ┌───────────────────┐\n\t             ┆         h         ┆\n\t             └───────────────────┘\n", "                       ▲\n\t                       |\n\t                       +\n\t                    /     \\\n\t    ┌─────────────────┐    ╭───────────────╮     Matrix initialization:\n\t    ┆                 ┆     \\      B      /      B = 0\n\t    ┆   pretrained    ┆      \\    r*d    /       A = N(0, sigma^2)\n\t    ┆    weights      ┆       ╰─────────╯\n\t    ┆                 ┆       |    r    |        r - rank\n\t    ┆   W e R^(d*d)   ┆       | ◀─────▶ |\n", "    ┆                 ┆       ╭─────────╮\n\t    └─────────────────┘      /     A     \\\n\t              ▲             /     d*r     \\\n\t               \\           ╰───────────────╯\n\t                \\                ▲\n\t                 \\              /\n\t                  \\            /\n\t             ┌───────────────────┐\n\t             ┆         x         ┆\n\t             └───────────────────┘\n", "With LoRA (Low Ranking Adaptation: https://arxiv.org/abs/2106.09685) instead of learning weights of size d*d,\n\twe can freeze the pretrained weights and instead learn two matrices of size d*r and r*d (they will store weight updates\n\tfor the pretrained weights): the number of parameters in this case will be reduced drastically (depending on the rank of\n\tcourse) yet after multiplication of matrices d*r and r*d we will get a matrix d*d which we can sum with frozen\n\tpretrained weights and thus fine-tune the model.\n\tThe goal of this approach is to move weight updates into a separate matrix which is decomposed with\n\ttwo matrices of a lower rank.\n\t\"\"\"\n\timport torch\n\timport torch.nn as nn\n", "import torch.nn.functional as F\n\timport math\n\tfrom typing import Dict, List\n\timport lit_llama.model as llama\n\tfrom contextlib import contextmanager\n\tfrom dataclasses import dataclass\n\tclass LoRALayer():\n\t    def __init__(\n\t        self, \n\t        r: int, \n", "        lora_alpha: int, \n\t        lora_dropout: float,\n\t        merge_weights: bool,\n\t    ):\n\t        \"\"\"Store LoRA specific attributes in a class.\n\t        Args:\n\t            r: rank of the weight update matrices. To make sense of using LoRA the rank should be smaller than the rank of\n\t                the weights of the model.  The rank can be as low as 1: https://arxiv.org/pdf/2106.09685.pdf (section 7.2)\n\t            lora_alpha: alpha is needed for scaling updates as alpha/r\n\t                \"This scaling helps to reduce the need to retune hyperparameters when we vary r\"\n", "                https://arxiv.org/pdf/2106.09685.pdf (section 4.1)\n\t            lora_dropout: dropout that is applied on the input in the LoRA branch (before multiplying by matrix A)\n\t            merge_weights: whether we want to merge pretrained weights and LoRA weight updates. This is useful if one wants to use\n\t                fine-tuned model as a standalone one (without storing LoRA weights separately) plus it helps to reduce\n\t                overhead during inference.\n\t        \"\"\"\n\t        self.r = r\n\t        self.lora_alpha = lora_alpha\n\t        # Optional dropout\n\t        if lora_dropout > 0.:\n", "            self.lora_dropout = nn.Dropout(p=lora_dropout)\n\t        else:\n\t            self.lora_dropout = lambda x: x\n\t        # Mark the weight as unmerged\n\t        self.merged = False\n\t        self.merge_weights = merge_weights\n\tclass MergedLinear(nn.Linear, LoRALayer):\n\t    # LoRA implemented in a dense layer\n\t    def __init__(\n\t        self, \n", "        # ↓ this part is for pretrained weights\n\t        in_features: int, \n\t        out_features: int, \n\t        # ↓ the remaining part is for LoRA\n\t        r: int = 0, \n\t        lora_alpha: int = 1, \n\t        lora_dropout: float = 0.,\n\t        enable_lora: List[bool] = [False],\n\t        fan_in_fan_out: bool = False,\n\t        merge_weights: bool = True,\n", "        **kwargs\n\t    ):\n\t        \"\"\"LoRA wrapper around linear class that is used for calculation of q, k and v matrices.\n\t        This class has three weight matrices:\n\t            1. Pretrained weights are stored as `self.weight` (because of the nn.Linear inheritance)\n\t            2. LoRA A matrix as `self.lora_A`\n\t            3. LoRA B matrix as `self.lora_B`\n\t        Only LoRA's A and B matrices are updated, pretrained weights stay frozen.\n\t        Args:\n\t            in_features: number of input features of the pretrained weights\n", "            out_features: number of output features of the pretrained weights\n\t            r: rank of the weight update matrices. To make sense of using LoRA the rank should be smaller than the rank of\n\t                the weights of the model.  The rank can be as low as 1: https://arxiv.org/pdf/2106.09685.pdf (section 7.2)\n\t            lora_alpha: alpha is needed for scaling updates as alpha/r\n\t                \"This scaling helps to reduce the need to retune hyperparameters when we vary r\"\n\t                https://arxiv.org/pdf/2106.09685.pdf (section 4.1)\n\t            lora_dropout: dropout that is applied on the input in the LoRA branch (before multiplying by matrix A)\n\t            enable_lora: MergeLinear class is for attention mechanism where qkv are calculated with a single weight matrix. If we\n\t                don't want to apply LoRA for all three (query, key and value) we can set it as False. For example if we want\n\t                to apply LoRA only to `query` and `value` but keep `key` without weight updates we should pass `[True,\n", "                False, True]`\n\t            fan_in_fan_out: set this to True if the layer to replace stores weight like (fan_in, fan_out).  For example, gpt-2 uses\n\t                `Conv1D` which stores weights like (fan_in, fan_out) and hence this should be set to `True`\n\t                https://github.com/huggingface/peft/blob/main/src/peft/tuners/lora.py#LL53C9-L53C112\n\t            merge_weights: whether we want to merge pretrained weights and LoRA weight updates. This is useful if one wants to use\n\t                fine-tuned model as a standalone one (without storing LoRA weight separately) plus it helps to reduce\n\t                overhead during inference.\n\t        \"\"\"\n\t        nn.Linear.__init__(self, in_features, out_features, **kwargs)\n\t        LoRALayer.__init__(self, r=r, lora_alpha=lora_alpha, lora_dropout=lora_dropout,\n", "                           merge_weights=merge_weights)\n\t        assert out_features % len(enable_lora) == 0, \\\n\t            'The length of enable_lora must divide out_features'\n\t        self.enable_lora = enable_lora\n\t        self.fan_in_fan_out = fan_in_fan_out\n\t        # Actual trainable parameters\n\t        # To better understand initialization let's imagine that we have such parameters:\n\t        # ⚬ in_features: 128 (embeddings_size)\n\t        # ⚬ out_features: 384 (3 * embedding_size)\n\t        # ⚬ r: 2\n", "        # ⚬ enable_lora: [True, False, True]\n\t        if r > 0 and any(enable_lora):\n\t            self.lora_A = nn.Parameter(\n\t                self.weight.new_zeros((r * sum(enable_lora), in_features)))  # (4, 128)\n\t            self.lora_B = nn.Parameter(\n\t                self.weight.new_zeros((out_features // len(enable_lora) * sum(enable_lora), r))  # (256, 2)\n\t            ) # weights for Conv1D with groups=sum(enable_lora)\n\t            # Notes about shapes above\n\t            # - self.lora_A has shape (4, 128): 4 because rank is 2 and LoRA is applied only to two matrices;\n\t            # 128 is the input size of the x (embedding size). (4, 128) and not (128, 4) because later on in\n", "            # F.linear function weights are automatically transposed. In addition conv1d requires channels to\n\t            # be before seq length\n\t            # - self.lora_B has shape (256, 2): 256 because LoRA is applied only to two matrices, so the output is\n\t            # 128*2; 2 tells to have two channels per group for group convolution\n\t            # Scaling:\n\t            # This balances the pretrained model`s knowledge and the new task-specific adaptation\n\t            # https://lightning.ai/pages/community/tutorial/lora-llm/\n\t            # So, set alpha to 1.0 to fully add LoRA. If the LoRA seems to have too much effect (i.e., overfitted), set\n\t            # alpha to lower value. If the LoRA seems to have too little effect, set alpha to higher than 1.0. You can\n\t            # tune these values to your needs. This value can be even slightly greater than 1.0!\n", "            # https://github.com/cloneofsimo/lora\n\t            self.scaling = self.lora_alpha / self.r\n\t            # Freezing the pre-trained weight matrix\n\t            self.weight.requires_grad = False # (384, 128)\n\t            # Compute the indices\n\t            # Indices are needed to properly pad weight updates with zeros. If we want to fine-tune queries and values,\n\t            # but not keys, then the weights update should be:\n\t            #\n\t            # [[ΔW,ΔW,ΔW, ..., 0,0,0, ..., ΔW,ΔW,ΔW,],\n\t            #  [....................................],\n", "            #  [ΔW,ΔW,ΔW, ..., 0,0,0, ..., ΔW,ΔW,ΔW,]]\n\t            #      ↑              ↑            ↑\n\t            # ________________________________________\n\t            # | query         | key       | value    |\n\t            # ----------------------------------------\n\t            self.lora_ind = self.weight.new_zeros(\n\t                (out_features, ), dtype=torch.bool\n\t            ).view(len(enable_lora), -1)  # (3, 128)\n\t            self.lora_ind[enable_lora, :] = True  # (3, 128)\n\t            self.lora_ind = self.lora_ind.view(-1)  # (384,)\n", "        self.reset_parameters()\n\t        if fan_in_fan_out:\n\t            self.weight.data = self.weight.data.T\n\t    def reset_parameters(self):\n\t        \"\"\"Reset all the weights, even including pretrained ones.\"\"\"\n\t        nn.Linear.reset_parameters(self)\n\t        if hasattr(self, 'lora_A'):\n\t            # initialize A the same way as the default for nn.Linear and B to zero\n\t            # Wondering why 'a' is equal to math.sqrt(5)?: https://github.com/pytorch/pytorch/issues/15314\n\t            nn.init.kaiming_uniform_(self.lora_A, a=math.sqrt(5))\n", "            nn.init.zeros_(self.lora_B)\n\t    def zero_pad(self, x: torch.Tensor) -> torch.Tensor:\n\t        \"\"\"Properly pad weight updates with zeros.\n\t        If, based on `self.enable_lora`, we want to fine-tune queries and values, but not keys,\n\t        then the weights update should be:\n\t        [[ΔW,ΔW,ΔW, ..., 0,0,0, ..., ΔW,ΔW,ΔW,],\n\t         [....................................],\n\t         [ΔW,ΔW,ΔW, ..., 0,0,0, ..., ΔW,ΔW,ΔW,]]\n\t            ↑              ↑            ↑\n\t        ________________________________________\n", "        | query         | key       | value    |\n\t        ----------------------------------------\n\t        Args:\n\t            x: tensor with weights update that will be padded with zeros if necessary\n\t        Returns:\n\t            A tensor with weight updates and zeros for deselected q, k or v\n\t        \"\"\"\n\t        # Let's image that:\n\t        # ⚬ input x has shape (64, 64, 256): (batch_size, sequence_length, embeddings_size)\n\t        # ⚬ embeddings_size: 128\n", "        # ⚬ self.out_features: 384 (3 * embeddings_size)\n\t        # ⚬ enable_lora: [True, False, True]\n\t        # Then x has embeddings_size of 256 (2 * 128 as enable_lora only for query and value, not keys) and expected\n\t        # embeddings_size is 384 (self.out_features), so that means that we need to pad from 256 to 384 with zeros, but\n\t        # only for key updates (this is where self.lora_ind comes in handy)\n\t        # Note: double transpose (in the beginning and in the end) is basically a guard for two-dimensional tensors\n\t        # for example when we want to merge/unmerge LoRA weights and pretrained weights\n\t        x = x.transpose(0, 1)\n\t        result = x.new_zeros((*x.shape[:-1], self.out_features))  # (64, 64, 384)\n\t        result = result.view(-1, self.out_features)  # (4096, 384)\n", "        result[:, self.lora_ind] = x.reshape(\n\t            -1, self.out_features // len(self.enable_lora) * sum(self.enable_lora)\n\t        )  # (4096, 256)\n\t        return result.view((*x.shape[:-1], self.out_features)).transpose(0, 1)  # (64, 64, 384)\n\t    def train(self, mode: bool = True):\n\t        \"\"\"Set the module into train or eval mode if `mode` is True of False respectively.\n\t        For train mode (train(True)) if weights are merged we need to subtract weights updates (LoRA_A @ LoRA_B) from\n\t        pretrained weights so we can continue training LoRA's matrices A and B and keep pretrained weights frozen.\n\t        For eval mode (train(False)) if weights are not merged we need to add weight updates to pretrained weights in\n\t        order to reduce computational overhead during inference.\n", "        Args:\n\t            mode: if True the module will be set into train mode (affects Dropout and BatchNorm), if False - eval mode.\n\t        \"\"\"\n\t        def T(w):\n\t            return w.T if self.fan_in_fan_out else w\n\t        # despite being called from nn.Linear this method will put all layers into train mode, including nn.Dropout\n\t        # of course except parameters (such as self.lora_A, self.lora_B)\n\t        nn.Linear.train(self, mode)\n\t        # if train(True) -> unmerge unless we already have them unmerged\n\t        # if train(False) -> merge unless we already have them merged\n", "        should = self.merged if mode else not self.merged\n\t        # Let's assume that:\n\t        # ⚬ self.weight.data: (384, 128) or (3 * embedding_size, embedding_size)\n\t        # ⚬ self.lora_A.data: (4, 128)\n\t        # ⚬ self.lora_B.data: (256, 2)\n\t        if self.merge_weights and should:\n\t            if self.r > 0 and any(self.enable_lora):\n\t                delta_w = F.conv1d(\n\t                    self.lora_A.data.unsqueeze(0),   # (4, 128) -> (1, 4, 128)\n\t                    self.lora_B.data.unsqueeze(-1),  # (256, 2) -> (256, 2, 1)\n", "                    groups=sum(self.enable_lora)\n\t                ).squeeze(0) # (1, 4, 128) @ (256, 2, 1) -> (1, 256, 128) -> (256, 128)\n\t                # -1: W = W - delta_W (unmerge), +1: W = W + delta_W (merge)\n\t                sign = -1 if mode else 1\n\t                self.weight.data += sign * self.zero_pad(T(delta_w * self.scaling)) # (256, 128) after zero_pad (384, 128)\n\t            self.merged = not mode\n\t    def forward(self, x: torch.Tensor) -> torch.Tensor:\n\t        \"\"\"Do the forward pass.\n\t        If LoRA's weights are merged with pretrained ones then it's a simple matrix multiplication.\n\t        If not, then multiply pretrained weights with input, apply LoRA on input and do summation.\n", "        Args:\n\t            x: input tensor of shape (batch_size, context_length, embedding_size)\n\t        Returns:\n\t            Output tensor of shape (batch_size, context_length, 3 * embedding_size)\n\t        \"\"\"\n\t        def T(w):\n\t            return w.T if self.fan_in_fan_out else w\n\t        # Let's assume that:\n\t        # ⚬ x: (64, 64, 128) or (batch_size, context_length, embedding_size)\n\t        # ⚬ self.weight: (384, 128) or (3 * embedding_size, embedding_size)\n", "        # ⚬ self.lora_A.data: (4, 128)\n\t        # ⚬ self.lora_B.data: (256, 2)\n\t        # the logic here is that the weights are merged only during inference\n\t        # so if they are merged we don't need to do anything with LoRA's A and B matrices\n\t        # but if the weights are not merged that means that the forward method is called during\n\t        # training and we need to forward pass input through pretrained weights, LoRA A and B matrices\n\t        # and do the summation (as per scheme at the top of the file)\n\t        if self.merged:\n\t            return F.linear(x, T(self.weight), bias=self.bias)\n\t        else:\n", "            # `F.linear` automatically transposes the second argument (T(self.weight) in our case)\n\t            result = F.linear(x, T(self.weight), bias=self.bias)  # (64, 64, 128) @ (384, 128) -> (64, 64, 384)\n\t            if self.r > 0:\n\t                after_A = F.linear(self.lora_dropout(x), self.lora_A)  # (64, 64, 128) @ (4, 128) -> (64, 64, 4)\n\t                # For F.conv1d:\n\t                # ⚬ input: input tensor of shape (mini-batch, in_channels, iW)\n\t                # ⚬ weight: filters of shape (out_channels, in_channels/groups, kW)\n\t                # ⚬ groups: split input into groups, in_channels should be divisible by the number of groups. Default: 1\n\t                # presumably iW - sequence width/length, kW - kernel width\n\t                after_B = F.conv1d(\n", "                    after_A.transpose(-2, -1),  # (64, 64, 4) -> (64, 4, 64)\n\t                    self.lora_B.unsqueeze(-1),  # (256, 2) -> (256, 2, 1)\n\t                    groups=sum(self.enable_lora)\n\t                ).transpose(-2, -1)  # (64, 4, 64) @ (256, 2, 1) -> (64, 256, 64) -> (64, 64, 256)\n\t                result += self.zero_pad(after_B) * self.scaling  # (64, 64, 256) after zero_pad (64, 64, 384)\n\t            return result\n\tdef mark_only_lora_as_trainable(model: nn.Module, bias: str = 'none') -> None:\n\t    \"\"\"Freeze all modules except LoRA's and depending on 'bias' value unfreezes bias weights.\n\t    Args:\n\t        model: model with LoRA layers\n", "        bias: \n\t            ``\"none\"``: all bias weights will be frozen,\n\t            ``\"lora_only\"``: only bias weight for LoRA layers will be unfrozen,\n\t            ``\"all\"``: all bias weights will be unfrozen.\n\t    Raises:\n\t        NotImplementedError: if `bias` not in [\"none\", \"lora_only\", \"all\"]\n\t    \"\"\"\n\t    # freeze all layers except LoRA's\n\t    for n, p in model.named_parameters():\n\t        if 'lora_' not in n:\n", "            p.requires_grad = False\n\t    # depending on the `bias` value unfreeze bias weights\n\t    if bias == 'none':\n\t        return\n\t    elif bias == 'all':\n\t        for n, p in model.named_parameters():\n\t            if 'bias' in n:\n\t                p.requires_grad = True\n\t    elif bias == 'lora_only':\n\t        for m in model.modules():\n", "            if isinstance(m, LoRALayer) and \\\n\t                hasattr(m, 'bias') and \\\n\t                m.bias is not None:\n\t                    m.bias.requires_grad = True\n\t    else:\n\t        raise NotImplementedError\n\tdef lora_state_dict(model: nn.Module, bias: str = 'none') -> Dict[str, torch.Tensor]:\n\t    \"\"\"Return state_dict with weights of LoRA's A and B matrices and with biases depending on the `bias` value.\n\t    Args:\n\t        model: model with LoRA layers\n", "        bias: \n\t            ``\"none\"``: state dict will not store bias weights,\n\t            ``\"lora_only\"``: state dict will store bias weights only from LoRA layers,\n\t            ``\"all\"``: state dict will store all bias weights.\n\t    Returns:\n\t        Weights and biases of LoRA layers\n\t    Raises:\n\t        NotImplementedError: if `bias` not in [\"none\", \"lora_only\", \"all\"]\n\t    \"\"\"\n\t    my_state_dict = model.state_dict()\n", "    if bias == 'none':\n\t        return {k: my_state_dict[k] for k in my_state_dict if 'lora_' in k}\n\t    elif bias == 'all':\n\t        return {k: my_state_dict[k] for k in my_state_dict if 'lora_' in k or 'bias' in k}\n\t    elif bias == 'lora_only':\n\t        to_return = {}\n\t        for k in my_state_dict:\n\t            if 'lora_' in k:\n\t                to_return[k] = my_state_dict[k]\n\t                bias_name = k.split('lora_')[0]+'bias'\n", "                if bias_name in my_state_dict:\n\t                    to_return[bias_name] = my_state_dict[bias_name]\n\t        return to_return\n\t    else:\n\t        raise NotImplementedError\n\t@dataclass\n\tclass LoRAConfig:\n\t    r: float = 0.0\n\t    alpha: float = 1.0\n\t    dropout: float = 0.0\n", "class CausalSelfAttention(llama.CausalSelfAttention):\n\t    lora_config = None\n\t    def __init__(self, config: llama.LLaMAConfig) -> None:\n\t        \"\"\"Causal self-attention with calculating qkv matrices with a single matrix* and Low Ranking Adaptation for\n\t        parameter-efficient fine-tuning.\n\t        *Instead of creating multiple heads and concatenating the result (in addition to creating separate matrices for\n\t        query, key and value for each head) we can do this in a single pass with a single weight matrix.\n\t        Args:\n\t            config: \n\t                ``\"block_size\"``: size of the context of the model,\n", "                ``\"vocab_size\"``: number of unique tokens,\n\t                ``\"padded_vocab_size\"``: padded size of the vocabulary to the nearest multiple of 64 (leads to a greater performance),\n\t                ``\"n_layer\"``: number of transformer blocks (self-attention + MLP),\n\t                ``\"n_head\"``: number of heads in multi-head attention mechanism,\n\t                ``\"n_embd\"``: size of the embedding: vector representation of each token.\n\t        \"\"\"\n\t        # Skip the parent class __init__ altogether and replace it to avoid\n\t        # useless allocations\n\t        nn.Module.__init__(self)\n\t        assert config.n_embd % config.n_head == 0\n", "        # key, query, value projections for all heads, but in a batch\n\t        self.c_attn = MergedLinear(\n\t            in_features=config.n_embd,\n\t            out_features=3 * config.n_embd,\n\t            r=self.lora_config.r,\n\t            lora_alpha=self.lora_config.alpha,\n\t            lora_dropout=self.lora_config.dropout,\n\t            enable_lora=[True, False, True],\n\t            fan_in_fan_out = False,\n\t            merge_weights=True,\n", "            bias=False)\n\t        # output projection\n\t        self.c_proj = nn.Linear(config.n_embd, config.n_embd, bias=False)\n\t        # regularization\n\t        self.n_head = config.n_head\n\t        self.n_embd = config.n_embd\n\t        self.block_size = config.block_size\n\t        self.rope_cache = None\n\t@contextmanager\n\tdef lora(r, alpha, dropout, enabled: bool = True):\n", "    \"\"\"Apply context manager under which you can instantiate the model with LoRA.\n\t    In a nutshell the code inside this function forces to use LoRA variant of causal self-attention\n\t    instead of the original one (without LoRA).\n\t    Args:\n\t        r: rank of the weight update matrices. To make sense of using LoRA the rank should be smaller than the rank of\n\t            the weights of the model.  The rank can be as low as 1: https://arxiv.org/pdf/2106.09685.pdf (section 7.2)\n\t        alpha: alpha is needed for scaling updates as alpha/r\n\t            \"This scaling helps to reduce the need to retune hyperparameters when we vary r\"\n\t            https://arxiv.org/pdf/2106.09685.pdf (section 4.1)\n\t        dropout: dropout that is applied on the input in the LoRA branch (before multiplying by matrix A)\n", "        enabled: enables/disables LoRA\n\t    \"\"\"\n\t    if not enabled:\n\t        yield\n\t        return\n\t    CausalSelfAttention.lora_config = LoRAConfig(r=r, alpha=alpha, dropout=dropout)\n\t    # when entering context manager replace link to causal self-attention class from original\n\t    # to a variant with LoRA\n\t    causal_self_attention = llama.CausalSelfAttention\n\t    llama.CausalSelfAttention = CausalSelfAttention\n", "    yield\n\t    # when exiting context manager - restore link to original causal self-attention class\n\t    llama.CausalSelfAttention = causal_self_attention\n\t    CausalSelfAttention.lora_config = None\n"]}
{"filename": "lit_llama/packed_dataset.py", "chunked_list": ["# Very loosely inspired by indexed_dataset in Fairseq, Megatron\n\t# https://github.com/NVIDIA/Megatron-LM/blob/main/megatron/data/indexed_dataset.py\n\timport os\n\timport struct\n\timport random\n\timport numpy as np\n\timport torch\n\tfrom torch.utils.data import IterableDataset, get_worker_info\n\tdtypes = {\n\t    1: np.uint8,\n", "    2: np.int8,\n\t    3: np.int16,\n\t    4: np.int32,\n\t    5: np.int64,\n\t    6: np.float32,\n\t    7: np.float64,\n\t    8: np.uint16,\n\t}\n\tdef code(dtype):\n\t    for k in dtypes.keys():\n", "        if dtypes[k] == dtype:\n\t            return k\n\t    raise ValueError(dtype)\n\tHDR_MAGIC = b\"LITPKDS\"\n\tHDR_SIZE = 24  # bytes\n\tclass PackedDataset(IterableDataset):\n\t    def __init__(self, filenames, n_chunks, block_size, seed=12345, shuffle=True, wrap=False, num_processes=1, process_rank=0):\n\t        self._filenames = filenames\n\t        self._n_chunks = n_chunks\n\t        self._block_size = block_size\n", "        self._seed = seed\n\t        self._shuffle = shuffle\n\t        self._wrap = wrap\n\t        self._num_processes = num_processes\n\t        self._process_rank = process_rank\n\t    def __iter__(self):\n\t        worker_info = get_worker_info()\n\t        num_workers = worker_info.num_workers if worker_info is not None else 1\n\t        worker_id = worker_info.id if worker_info is not None else 0\n\t        num_shards = num_workers * self._num_processes\n", "        shard_id = self._process_rank * num_workers + worker_id\n\t        max_num_files = len(self._filenames) // num_shards * num_shards\n\t        filenames = self._filenames[shard_id : max_num_files : num_shards]\n\t        return PackedDatasetIterator(\n\t            filenames=filenames,\n\t            n_chunks=self._n_chunks,\n\t            block_size=self._block_size,\n\t            seed=self._seed,\n\t            shuffle=self._shuffle,\n\t            wrap=self._wrap,\n", "        )\n\tclass PackedDatasetBuilder(object):\n\t    def __init__(\n\t        self,\n\t        outdir,\n\t        prefix,\n\t        chunk_size,\n\t        sep_token,\n\t        dtype=\"auto\",\n\t        vocab_size=None,\n", "    ):\n\t        if dtype == \"auto\":\n\t            if vocab_size is None:\n\t                raise ValueError(\"vocab_size cannot be None when dtype='auto'\")\n\t            if vocab_size is not None and vocab_size < 65500:\n\t                self._dtype = np.uint16\n\t            else:\n\t                self._dtype = np.int32\n\t        else:\n\t            self._dtype = dtype\n", "        self._counter = 0\n\t        self._chunk_size = chunk_size\n\t        self._outdir = outdir\n\t        self._prefix = prefix\n\t        self._sep_token = sep_token\n\t        self._arr = np.zeros(self._chunk_size, dtype=self._dtype)\n\t        self._arr.fill(self._sep_token)\n\t        self._idx = 0\n\t        self._version = 1\n\t        self._filenames = []\n", "    def _write_chunk(self):\n\t        filename = f\"{self._prefix}_{self._counter:010d}.bin\"\n\t        filename = os.path.join(self._outdir, filename)\n\t        with open(filename, \"wb\") as f:\n\t            f.write(HDR_MAGIC)\n\t            f.write(struct.pack(\"<Q\", self._version))\n\t            f.write(struct.pack(\"<B\", code(self._dtype)))\n\t            f.write(struct.pack(\"<Q\", self._chunk_size))\n\t            f.write(self._arr.tobytes(order=\"C\"))\n\t        self._filenames.append(filename)\n", "        self._counter += 1\n\t        self._arr.fill(self._sep_token)\n\t        self._idx = 0\n\t    @property\n\t    def dtype(self):\n\t        return self._dtype\n\t    @property\n\t    def filenames(self):\n\t        return self._filenames.copy()\n\t    def add_array(self, arr):\n", "        while self._idx + arr.shape[0] > self._chunk_size:\n\t            part_len = self._chunk_size - self._idx\n\t            self._arr[self._idx : self._idx + part_len] = arr[:part_len]\n\t            self._write_chunk()\n\t            arr = arr[part_len:]\n\t        arr_len = arr.shape[0]\n\t        self._arr[self._idx : self._idx + arr_len] = arr\n\t        self._idx += arr_len\n\t    def write_reminder(self):\n\t        self._write_chunk()\n", "class PackedDatasetIterator:\n\t    def __init__(self, filenames, n_chunks, block_size, seed, shuffle, wrap):\n\t        self._seed = seed\n\t        self._shuffle = shuffle\n\t        self._rng = np.random.default_rng(seed) if shuffle else None\n\t        self._block_idxs = None\n\t        self._wrap = wrap\n\t        # TODO: instead of filenames, we could have a single text stream\n\t        #       (or text file) with the sequence of all files to be\n\t        #       fetched/loaded.\n", "        self._filenames = filenames\n\t        self._file_idx = 0\n\t        self._n_chunks = n_chunks\n\t        self._dtype = None\n\t        self._block_size = block_size\n\t        self._n_blocks = None\n\t        self._mmaps = []\n\t        self._buffers = []\n\t        self._block_idxs = []\n\t        self._curr_idx = 0\n", "        self._load_n_chunks()\n\t    def _read_header(self, path):\n\t        with open(path, \"rb\") as f:\n\t            magic = f.read(len(HDR_MAGIC))\n\t            assert magic == HDR_MAGIC, \"File doesn't match expected format.\"\n\t            version = struct.unpack(\"<Q\", f.read(8))\n\t            assert (1,) == version\n\t            (dtype_code,) = struct.unpack(\"<B\", f.read(1))\n\t            dtype = dtypes[dtype_code]\n\t            (chunk_size,) = struct.unpack(\"<Q\", f.read(8))\n", "        return dtype, chunk_size\n\t    def _close_mmaps(self):\n\t        for mmap in self._mmaps:\n\t            mmap._mmap.close()\n\t    def _load_n_chunks(self):\n\t        self._close_mmaps()\n\t        self._mmaps = []\n\t        self._buffers = []\n\t        if self._n_chunks > len(self._filenames[self._file_idx:]):\n\t            if not self._wrap:\n", "                raise StopIteration\n\t            else:\n\t                self._file_idx = 0\n\t        for i in range(self._n_chunks):\n\t            filename = self._filenames[self._file_idx + i]\n\t            if self._dtype is None:\n\t                self._dtype, self._chunk_size = self._read_header(\n\t                    filename\n\t                )\n\t                self._n_blocks = self._chunk_size // self._block_size\n", "            # TODO: check header matches with previous files\n\t            mmap = np.memmap(filename, mode=\"r\", order=\"C\", offset=HDR_SIZE)\n\t            self._mmaps.append(mmap)\n\t            self._buffers.append(memoryview(mmap))\n\t        self._file_idx += self._n_chunks\n\t        n_all_blocks = self._n_chunks * self._n_blocks\n\t        self._block_idxs = (\n\t            self._rng.permutation(n_all_blocks)\n\t            if self._shuffle\n\t            else range(n_all_blocks)\n", "        )\n\t        self._curr_idx = 0\n\t    def __del__(self):\n\t        self._close_mmaps()\n\t        del self._mmaps\n\t        del self._buffers\n\t    def __iter__(self):\n\t        return self\n\t    def __next__(self):\n\t        if self._curr_idx >= len(self._block_idxs):\n", "            self._load_n_chunks()\n\t            # TODO: trigger fetching next next n_chunks if remote\n\t        block_idx = self._block_idxs[self._curr_idx]\n\t        chunk_id = block_idx // self._n_blocks\n\t        buffer = self._buffers[chunk_id]\n\t        elem_id = (block_idx % self._n_blocks) * self._block_size\n\t        offset = np.dtype(self._dtype).itemsize * elem_id\n\t        arr = np.frombuffer(\n\t            buffer, dtype=self._dtype, count=self._block_size, offset=offset\n\t        )\n", "        self._curr_idx += 1\n\t        return torch.from_numpy(arr.astype(np.int64))\n\tclass CombinedDataset(IterableDataset):\n\t    def __init__(self, datasets, seed, weights=None):\n\t        self._seed = seed\n\t        self._datasets = datasets\n\t        self._weights = weights\n\t        n_datasets = len(datasets)\n\t        if weights is None:\n\t            self._weights = [1 / n_datasets] * n_datasets\n", "    def __iter__(self):\n\t        return CombinedDatasetIterator(self._datasets, self._seed, self._weights)\n\tclass CombinedDatasetIterator:\n\t    def __init__(self, datasets, seed, weights):\n\t        self._datasets = [iter(el) for el in datasets]\n\t        self._weights = weights\n\t        self._rng = random.Random(seed)\n\t    def __next__(self):\n\t        dataset, = self._rng.choices(self._datasets, weights=self._weights, k=1)\n\t        return next(dataset)\n"]}
{"filename": "evaluate/full.py", "chunked_list": ["# This mimics GPTQ's evaluation metrics: https://github.com/IST-DASLab/gptq/\n\t# Thanks to E. Frantar et al GPTQ: Accurate Post-training Compression for GPT, arXiv:2210.17323\n\timport math\n\timport sys\n\timport time\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport lightning as L\n\timport torch\n\timport tqdm\n", "# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\tfrom lit_llama import LLaMA, Tokenizer\n\tfrom lit_llama.utils import EmptyInitOnDevice\n\tfrom datasets import load_dataset\n\tdef load_eval_data(dataset_name: str) -> str:\n\t    # this mimics gptq datautils\n\t    if dataset_name == \"wikitext\":\n\t        # traindata = load_dataset('wikitext', 'wikitext-2-raw-v1', split='train')\n", "        testdata = load_dataset(\"wikitext\", \"wikitext-2-raw-v1\", split=\"test\")\n\t        testdata = \"\\n\\n\".join(testdata[\"text\"])\n\t    elif dataset_name == \"ptb\":\n\t        testdata = load_dataset(\"ptb_text_only\", \"penn_treebank\", split=\"test\")\n\t        testdata = \"\\n\\n\".join(testdata[\"sentence\"])\n\t    elif dataset_name == \"c4\":\n\t        testdata = load_dataset(\n\t            \"allenai/c4\",\n\t            \"allenai--c4\",\n\t            data_files={\"validation\": \"en/c4-validation.00000-of-00008.json.gz\"},\n", "            split=\"validation\",\n\t        )\n\t        testdata = \" \".join(testdata[:1100][\"text\"])\n\t    else:\n\t        raise ValueError(\"invalid dataset name (wikitext, ptb, c4 are allowed)\")\n\t    return testdata\n\tdef main(\n\t    datasets: str = \"wikitext,ptb,c4\",\n\t    *,\n\t    # compilation fails as it does not support torch.complex64 for RoPE\n", "    # compile: bool = False,\n\t    accelerator: str = \"auto\",\n\t    checkpoint_path: Optional[Path] = None,\n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    model_size: str = \"7B\",\n\t    dtype: str = \"float32\",\n\t    quantize: Optional[str] = None,\n\t) -> None:\n\t    \"\"\"Generates text samples based on a pre-trained LLaMA model and tokenizer.\n\t    Args:\n", "        datasets: The datasets to use as a comma separated string\n\t        # compile: Whether to compile the model.\n\t        accelerator: The hardware to run on. Possible choices are:\n\t            ``\"cpu\"``, ``\"cuda\"``, ``\"mps\"``, ``\"gpu\"``, ``\"tpu\"``, ``\"auto\"``.\n\t        checkpoint_path: The checkpoint path to load.\n\t        tokenizer_path: The tokenizer path to load.\n\t        dtype: The tensor dtype for choosing the floating-point precision \n\t        quantize: Whether to quantize the model and using which method:\n\t            ``\"llm.int8\"``: LLM.int8() mode,\n\t            ``\"gptq.int4\"``: GPTQ 4-bit mode.\n", "    \"\"\"\n\t    if not checkpoint_path:\n\t        checkpoint_path = Path(f\"checkpoints/lit-llama/{model_size}/lit-llama.pth\")\n\t    assert checkpoint_path.is_file()\n\t    assert tokenizer_path.is_file()\n\t    fabric = L.Fabric(accelerator=accelerator, devices=1)\n\t    dt = getattr(torch, dtype, None)\n\t    if not isinstance(dt, torch.dtype):\n\t        raise ValueError(f\"{dtype} is not a valid dtype.\")\n\t    dtype = dt\n", "    with EmptyInitOnDevice(\n\t        device=fabric.device, dtype=dtype, quantization_mode=quantize\n\t    ):\n\t        print(\"Loading model ...\", file=sys.stderr)\n\t        t0 = time.time()\n\t        model = LLaMA.from_name(model_size)\n\t        checkpoint = torch.load(checkpoint_path)\n\t        model.load_state_dict(checkpoint)\n\t        print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n\t    model.eval()\n", "    # if compile:\n\t    #     model = torch.compile(model)\n\t    total_toks = 0\n\t    model = fabric.setup_module(model)\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    for dsname in datasets.split(\",\"):\n\t        test_string = load_eval_data(dsname)\n\t        encoded_text = tokenizer.encode(\n\t            test_string, bos=True, eos=False, device=fabric.device\n\t        )\n", "        encoded_text = encoded_text[\n\t            None, : 256 * model.config.block_size\n\t        ]  # add batch dimension, trim like gptq implementation\n\t        t0 = time.perf_counter()\n\t        nlls = 0\n\t        toks = 0\n\t        with torch.inference_mode():\n\t            block_size = 2048  # this is for compat with gptq, and indeed we get much worse beyond this (https://github.com/facebookresearch/llama/blob/57b0eb62de0636e75af471e49e2f1862d908d9d8/llama/model.py#L30)\n\t            for i in tqdm.tqdm(range(0, encoded_text.shape[1], block_size)):\n\t                inp = encoded_text[:, i : i + block_size]\n", "                logits = model(inp)[0]\n\t                nll = torch.nn.functional.cross_entropy(\n\t                    logits[:-1], inp[0, 1:].to(dtype=torch.long), reduction=\"sum\"\n\t                )\n\t                toks += inp.size(1) - 1\n\t                nlls += nll.item()\n\t        print(encoded_text.shape, logits.shape)\n\t        ppl = math.exp(nlls / toks)\n\t        print(f\"Perplexity on {dsname}: {ppl:.2f}\")\n\t        total_toks += toks\n", "    t = time.perf_counter() - t0\n\t    print(\n\t        f\"\\n\\nTime for inference: {t:.02f} sec total, {total_toks / t:.02f} tokens/sec\",\n\t        file=sys.stderr,\n\t    )\n\t    print(\n\t        f\"Memory used: {torch.cuda.max_memory_reserved() / 1e9:.02f} GB\",\n\t        file=sys.stderr,\n\t    )\n\tif __name__ == \"__main__\":\n", "    from jsonargparse import CLI\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    CLI(main)\n"]}
{"filename": "evaluate/adapter_v2.py", "chunked_list": ["# This mimics GPTQ's evaluation metrics: https://github.com/IST-DASLab/gptq/\n\t# Thanks to E. Frantar et al GPTQ: Accurate Post-training Compression for GPT, arXiv:2210.17323\n\timport math\n\timport sys\n\timport time\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport lightning as L\n\timport torch\n\timport tqdm\n", "# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\tfrom lit_llama import Tokenizer\n\tfrom lit_llama.adapter import LLaMA\n\tfrom lit_llama.utils import EmptyInitOnDevice, lazy_load, llama_model_lookup\n\tfrom lit_llama.adapter_v2 import add_adapter_v2_parameters_to_linear_layers\n\tfrom scripts.prepare_alpaca import generate_prompt\n\tfrom datasets import load_dataset\n\tdef load_eval_data(dataset_name: str) -> str:\n", "    # this mimics gptq datautils\n\t    if dataset_name == \"wikitext\":\n\t        # traindata = load_dataset('wikitext', 'wikitext-2-raw-v1', split='train')\n\t        testdata = load_dataset(\"wikitext\", \"wikitext-2-raw-v1\", split=\"test\")\n\t        testdata = \"\\n\\n\".join(testdata[\"text\"])\n\t    elif dataset_name == \"ptb\":\n\t        testdata = load_dataset(\"ptb_text_only\", \"penn_treebank\", split=\"test\")\n\t        testdata = \"\\n\\n\".join(testdata[\"sentence\"])\n\t    elif dataset_name == \"c4\":\n\t        testdata = load_dataset(\n", "            \"allenai/c4\",\n\t            \"allenai--c4\",\n\t            data_files={\"validation\": \"en/c4-validation.00000-of-00008.json.gz\"},\n\t            split=\"validation\",\n\t        )\n\t        testdata = \" \".join(testdata[:1100][\"text\"])\n\t    else:\n\t        raise ValueError(\"invalid dataset name (wikitext, ptb, c4 are allowed)\")\n\t    return testdata\n\t@torch.inference_mode()\n", "def main(\n\t    datasets: str = \"wikitext,ptb,c4\",\n\t    *,\n\t    accelerator: str = \"auto\",\n\t    adapter_path: Path = Path(\"out/adapter_v2/alpaca/lit-llama-adapter-finetuned.pth\"),\n\t    checkpoint_path: Path = Path(\"checkpoints/lit-llama/7B/lit-llama.pth\"),\n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    dtype: str = \"float32\",\n\t    quantize: Optional[str] = None,\n\t) -> None:\n", "    \"\"\"Generates text samples based on a pre-trained LLaMA model and tokenizer.\n\t    Args:\n\t        datasets: The datasets to use as a comma separated string\n\t        accelerator: The hardware to run on. Possible choices are:\n\t            ``\"cpu\"``, ``\"cuda\"``, ``\"mps\"``, ``\"gpu\"``, ``\"tpu\"``, ``\"auto\"``.\n\t        adapter_path: Path to the checkpoint with trained adapter weights, which are the output of\n\t            `finetune_adapter_v2.py`.\n\t        checkpoint_path: The checkpoint path to load.\n\t        tokenizer_path: The tokenizer path to load.\n\t        dtype: The tensor dtype for choosing the floating-point precision \n", "        quantize: Whether to quantize the model and using which method:\n\t            ``\"llm.int8\"``: LLM.int8() mode,\n\t            ``\"gptq.int4\"``: GPTQ 4-bit mode.\n\t    \"\"\"\n\t    assert adapter_path.is_file()\n\t    assert checkpoint_path.is_file()\n\t    assert tokenizer_path.is_file()\n\t    fabric = L.Fabric(accelerator=accelerator, devices=1)\n\t    dt = getattr(torch, dtype, None)\n\t    if not isinstance(dt, torch.dtype):\n", "        raise ValueError(f\"{dtype} is not a valid dtype.\")\n\t    dtype = dt\n\t    print(\"Loading model ...\", file=sys.stderr)\n\t    t0 = time.time()\n\t    with lazy_load(checkpoint_path) as pretrained_checkpoint, lazy_load(adapter_path) as adapter_checkpoint:\n\t        name = llama_model_lookup(pretrained_checkpoint)\n\t        with EmptyInitOnDevice(\n\t            device=fabric.device, dtype=dtype, quantization_mode=quantize\n\t        ):\n\t            model = LLaMA.from_name(name)\n", "            add_adapter_v2_parameters_to_linear_layers(model)\n\t        # 1. Load the pretrained weights\n\t        model.load_state_dict(pretrained_checkpoint, strict=False)\n\t        # 2. Load the fine-tuned adapter weights\n\t        model.load_state_dict(adapter_checkpoint, strict=False)\n\t    print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n\t    model.eval()\n\t    # if compile:\n\t    #     model = torch.compile(model)\n\t    total_toks = 0\n", "    model = fabric.setup_module(model)\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    for dsname in datasets.split(\",\"):\n\t        test_string = load_eval_data(dsname)\n\t        sample = {\"instruction\": test_string, \"input\": input}\n\t        test_string = generate_prompt(sample)\n\t        encoded_text = tokenizer.encode(\n\t            test_string, bos=True, eos=False, device=fabric.device\n\t        )\n\t        encoded_text = encoded_text[\n", "            None, : 256 * model.config.block_size\n\t        ]  # add batch dimension, trim like gptq implementation\n\t        t0 = time.perf_counter()\n\t        nlls = 0\n\t        toks = 0\n\t        block_size = 2048  # this is for compat with gptq, and indeed we get much worse beyond this (https://github.com/facebookresearch/llama/blob/57b0eb62de0636e75af471e49e2f1862d908d9d8/llama/model.py#L30)\n\t        for i in tqdm.tqdm(range(0, encoded_text.shape[1], block_size)):\n\t            inp = encoded_text[:, i : i + block_size]\n\t            logits = model(inp)[0]\n\t            nll = torch.nn.functional.cross_entropy(\n", "                logits[:-1], inp[0, 1:].to(dtype=torch.long), reduction=\"sum\"\n\t            )\n\t            toks += inp.size(1) - 1\n\t            nlls += nll.item()\n\t        print(encoded_text.shape, logits.shape)\n\t        ppl = math.exp(nlls / toks)\n\t        print(f\"Perplexity on {dsname}: {ppl:.2f}\")\n\t        total_toks += toks\n\t    t = time.perf_counter() - t0\n\t    print(\n", "        f\"\\n\\nTime for inference: {t:.02f} sec total, {total_toks / t:.02f} tokens/sec\",\n\t        file=sys.stderr,\n\t    )\n\t    print(\n\t        f\"Memory used: {torch.cuda.max_memory_reserved() / 1e9:.02f} GB\",\n\t        file=sys.stderr,\n\t    )\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    torch.set_float32_matmul_precision(\"high\")\n", "    CLI(main)\n"]}
{"filename": "evaluate/adapter.py", "chunked_list": ["# This mimics GPTQ's evaluation metrics: https://github.com/IST-DASLab/gptq/\n\t# Thanks to E. Frantar et al GPTQ: Accurate Post-training Compression for GPT, arXiv:2210.17323\n\timport math\n\timport sys\n\timport time\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport lightning as L\n\timport torch\n\timport tqdm\n", "# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\tfrom lit_llama import Tokenizer\n\tfrom lit_llama.adapter import LLaMA\n\tfrom lit_llama.utils import EmptyInitOnDevice, lazy_load, llama_model_lookup\n\tfrom scripts.prepare_alpaca import generate_prompt\n\tfrom datasets import load_dataset\n\tinstruction_tuning = True\n\tdef load_eval_data(dataset_name: str) -> str:\n", "    # this mimics gptq datautils\n\t    if dataset_name == \"wikitext\":\n\t        # traindata = load_dataset('wikitext', 'wikitext-2-raw-v1', split='train')\n\t        testdata = load_dataset(\"wikitext\", \"wikitext-2-raw-v1\", split=\"test\")\n\t        testdata = \"\\n\\n\".join(testdata[\"text\"])\n\t    elif dataset_name == \"ptb\":\n\t        testdata = load_dataset(\"ptb_text_only\", \"penn_treebank\", split=\"test\")\n\t        testdata = \"\\n\\n\".join(testdata[\"sentence\"])\n\t    elif dataset_name == \"c4\":\n\t        testdata = load_dataset(\n", "            \"allenai/c4\",\n\t            \"allenai--c4\",\n\t            data_files={\"validation\": \"en/c4-validation.00000-of-00008.json.gz\"},\n\t            split=\"validation\",\n\t        )\n\t        testdata = \" \".join(testdata[:1100][\"text\"])\n\t    else:\n\t        raise ValueError(\"invalid dataset name (wikitext, ptb, c4 are allowed)\")\n\t    return testdata\n\t@torch.inference_mode()\n", "def main(\n\t    datasets: str = \"wikitext,ptb,c4\",\n\t    *,\n\t    # compilation fails as it does not support torch.complex64 for RoPE\n\t    # compile: bool = False,\n\t    accelerator: str = \"auto\",\n\t    adapter_path: Path = Path(\"out/adapter/alpaca/lit-llama-adapter-finetuned.pth\"),\n\t    checkpoint_path: Path = Path(\"checkpoints/lit-llama/7B/lit-llama.pth\"),\n\t    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    dtype: str = \"float32\",\n", "    quantize: Optional[str] = None,\n\t) -> None:\n\t    \"\"\"Generates text samples based on a pre-trained LLaMA model and tokenizer.\n\t    Args:\n\t        datasets: The datasets to use as a comma separated string\n\t        # compile: Whether to compile the model.\n\t        accelerator: The hardware to run on. Possible choices are:\n\t            ``\"cpu\"``, ``\"cuda\"``, ``\"mps\"``, ``\"gpu\"``, ``\"tpu\"``, ``\"auto\"``.\n\t        adapter_path: Path to the checkpoint with trained adapter weights, which are the output of\n\t            `finetune_adapter.py`.\n", "        checkpoint_path: The checkpoint path to load.\n\t        tokenizer_path: The tokenizer path to load.\n\t        dtype: The tensor dtype for choosing the floating-point precision \n\t        quantize: Whether to quantize the model and using which method:\n\t            ``\"llm.int8\"``: LLM.int8() mode,\n\t            ``\"gptq.int4\"``: GPTQ 4-bit mode.\n\t    \"\"\"\n\t    assert adapter_path.is_file()\n\t    assert checkpoint_path.is_file()\n\t    assert tokenizer_path.is_file()\n", "    fabric = L.Fabric(accelerator=accelerator, devices=1)\n\t    dt = getattr(torch, dtype, None)\n\t    if not isinstance(dt, torch.dtype):\n\t        raise ValueError(f\"{dtype} is not a valid dtype.\")\n\t    dtype = dt\n\t    print(\"Loading model ...\", file=sys.stderr)\n\t    t0 = time.time()\n\t    with lazy_load(checkpoint_path) as pretrained_checkpoint, lazy_load(adapter_path) as adapter_checkpoint:\n\t        name = llama_model_lookup(pretrained_checkpoint)\n\t        with EmptyInitOnDevice(\n", "                device=fabric.device, dtype=dtype, quantization_mode=quantize\n\t        ):\n\t            model = LLaMA.from_name(name)\n\t        # 1. Load the pretrained weights\n\t        model.load_state_dict(pretrained_checkpoint, strict=False)\n\t        # 2. Load the fine-tuned adapter weights\n\t        model.load_state_dict(adapter_checkpoint, strict=False)\n\t    print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n\t    model.eval()\n\t    # if compile:\n", "    #     model = torch.compile(model)\n\t    total_toks = 0\n\t    model = fabric.setup_module(model)\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    for dsname in datasets.split(\",\"):\n\t        test_string = load_eval_data(dsname)\n\t        if instruction_tuning:\n\t            sample = {\"instruction\": test_string, \"input\": input}\n\t            test_string = generate_prompt(sample)\n\t        encoded_text = tokenizer.encode(\n", "            test_string, bos=True, eos=False, device=fabric.device\n\t        )\n\t        encoded_text = encoded_text[\n\t            None, : 256 * model.config.block_size\n\t        ]  # add batch dimension, trim like gptq implementation\n\t        t0 = time.perf_counter()\n\t        nlls = 0\n\t        toks = 0\n\t        block_size = 2048  # this is for compat with gptq, and indeed we get much worse beyond this (https://github.com/facebookresearch/llama/blob/57b0eb62de0636e75af471e49e2f1862d908d9d8/llama/model.py#L30)\n\t        for i in tqdm.tqdm(range(0, encoded_text.shape[1], block_size)):\n", "            inp = encoded_text[:, i : i + block_size]\n\t            logits = model(inp)[0]\n\t            nll = torch.nn.functional.cross_entropy(\n\t                logits[:-1], inp[0, 1:].to(dtype=torch.long), reduction=\"sum\"\n\t            )\n\t            toks += inp.size(1) - 1\n\t            nlls += nll.item()\n\t        print(encoded_text.shape, logits.shape)\n\t        ppl = math.exp(nlls / toks)\n\t        print(f\"Perplexity on {dsname}: {ppl:.2f}\")\n", "        total_toks += toks\n\t    t = time.perf_counter() - t0\n\t    print(\n\t        f\"\\n\\nTime for inference: {t:.02f} sec total, {total_toks / t:.02f} tokens/sec\",\n\t        file=sys.stderr,\n\t    )\n\t    print(\n\t        f\"Memory used: {torch.cuda.max_memory_reserved() / 1e9:.02f} GB\",\n\t        file=sys.stderr,\n\t    )\n", "if __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    CLI(main)\n"]}
{"filename": "evaluate/lora.py", "chunked_list": ["# This mimics GPTQ's evaluation metrics: https://github.com/IST-DASLab/gptq/\n\t# Thanks to E. Frantar et al GPTQ: Accurate Post-training Compression for GPT, arXiv:2210.17323\n\timport math\n\timport sys\n\timport time\n\tfrom pathlib import Path\n\tfrom typing import Optional\n\timport lightning as L\n\timport torch\n\timport tqdm\n", "# support running without installing as a package\n\twd = Path(__file__).parent.parent.resolve()\n\tsys.path.append(str(wd))\n\tfrom lit_llama import LLaMA, Tokenizer\n\tfrom lit_llama.utils import EmptyInitOnDevice, lazy_load, llama_model_lookup\n\tfrom lit_llama.lora import lora\n\tfrom scripts.prepare_alpaca import generate_prompt\n\tfrom datasets import load_dataset\n\tinstruction_tuning = True\n\tlora_r = 8\n", "lora_alpha = 16\n\tlora_dropout = 0.05\n\tdef load_eval_data(dataset_name: str) -> str:\n\t    # this mimics gptq datautils\n\t    if dataset_name == \"wikitext\":\n\t        # traindata = load_dataset('wikitext', 'wikitext-2-raw-v1', split='train')\n\t        testdata = load_dataset(\"wikitext\", \"wikitext-2-raw-v1\", split=\"test\")\n\t        testdata = \"\\n\\n\".join(testdata[\"text\"])\n\t    elif dataset_name == \"ptb\":\n\t        testdata = load_dataset(\"ptb_text_only\", \"penn_treebank\", split=\"test\")\n", "        testdata = \"\\n\\n\".join(testdata[\"sentence\"])\n\t    elif dataset_name == \"c4\":\n\t        testdata = load_dataset(\n\t            \"allenai/c4\",\n\t            \"allenai--c4\",\n\t            data_files={\"validation\": \"en/c4-validation.00000-of-00008.json.gz\"},\n\t            split=\"validation\",\n\t        )\n\t        testdata = \" \".join(testdata[:1100][\"text\"])\n\t    else:\n", "        raise ValueError(\"invalid dataset name (wikitext, ptb, c4 are allowed)\")\n\t    return testdata\n\tdef main(\n\t    datasets: str = \"wikitext,ptb,c4\",\n\t    *,\n\t    # compilation fails as it does not support torch.complex64 for RoPE\n\t    # compile: bool = False,\n\t    accelerator: str = \"auto\",\n\t    lora_path: Path = Path(\"out/lora/alpaca/lit-llama-lora-finetuned.pth\"),\n\t    checkpoint_path: Path = Path(\"checkpoints/lit-llama/7B/lit-llama.pth\"),\n", "    tokenizer_path: Path = Path(\"checkpoints/lit-llama/tokenizer.model\"),\n\t    dtype: str = \"float32\",\n\t    quantize: Optional[str] = None,\n\t) -> None:\n\t    \"\"\"Generates text samples based on a pre-trained LLaMA model and tokenizer\n\t       finetuned with LoRA.\n\t    Args:\n\t        datasets: The datasets to use as a comma separated string\n\t        # compile: Whether to compile the model.\n\t        accelerator: The hardware to run on. Possible choices are:\n", "            ``\"cpu\"``, ``\"cuda\"``, ``\"mps\"``, ``\"gpu\"``, ``\"tpu\"``, ``\"auto\"``.\n\t        lora_path: Path to the checkpoint with trained LoRA weights, which are the output of\n\t            `finetune_lora.py`.\n\t        checkpoint_path: The checkpoint path to load.\n\t        tokenizer_path: The tokenizer path to load.\n\t        dtype: The tensor dtype for choosing the floating-point precision \n\t        quantize: Whether to quantize the model and using which method:\n\t            ``\"llm.int8\"``: LLM.int8() mode,\n\t            ``\"gptq.int4\"``: GPTQ 4-bit mode.\n\t    \"\"\"\n", "    assert lora_path.is_file()\n\t    assert checkpoint_path.is_file()\n\t    assert tokenizer_path.is_file()\n\t    if quantize is not None:\n\t        raise NotImplementedError(\"Quantization in LoRA is not supported yet\")\n\t    fabric = L.Fabric(accelerator=accelerator, devices=1)\n\t    dt = getattr(torch, dtype, None)\n\t    if not isinstance(dt, torch.dtype):\n\t        raise ValueError(f\"{dtype} is not a valid dtype.\")\n\t    dtype = dt\n", "    print(\"Loading model ...\", file=sys.stderr)\n\t    t0 = time.time()\n\t    with lazy_load(checkpoint_path) as pretrained_checkpoint, lazy_load(lora_path) as lora_checkpoint:\n\t        name = llama_model_lookup(pretrained_checkpoint)\n\t        with EmptyInitOnDevice(\n\t                device=fabric.device, dtype=dtype, quantization_mode=quantize\n\t        ), lora(r=lora_r, alpha=lora_alpha, dropout=lora_dropout, enabled=True):\n\t            model = LLaMA.from_name(name)\n\t            # 1. Load the pretrained weights\n\t            model.load_state_dict(pretrained_checkpoint, strict=False)\n", "            # 2. Load the fine-tuned lora weights\n\t            model.load_state_dict(lora_checkpoint, strict=False)\n\t    print(f\"Time to load model: {time.time() - t0:.02f} seconds.\", file=sys.stderr)\n\t    model.eval()\n\t    # if compile:\n\t    #     model = torch.compile(model)\n\t    total_toks = 0\n\t    model = fabric.setup_module(model)\n\t    tokenizer = Tokenizer(tokenizer_path)\n\t    for dsname in datasets.split(\",\"):\n", "        test_string = load_eval_data(dsname)\n\t        if instruction_tuning:\n\t            sample = {\"instruction\": test_string, \"input\": input}\n\t            test_string = generate_prompt(sample)\n\t        encoded_text = tokenizer.encode(\n\t            test_string, bos=True, eos=False, device=fabric.device\n\t        )\n\t        encoded_text = encoded_text[\n\t            None, : 256 * model.config.block_size\n\t        ]  # add batch dimension, trim like gptq implementation\n", "        t0 = time.perf_counter()\n\t        nlls = 0\n\t        toks = 0\n\t        with torch.inference_mode():\n\t            block_size = 2048  # this is for compat with gptq, and indeed we get much worse beyond this (https://github.com/facebookresearch/llama/blob/57b0eb62de0636e75af471e49e2f1862d908d9d8/llama/model.py#L30)\n\t            for i in tqdm.tqdm(range(0, encoded_text.shape[1], block_size)):\n\t                inp = encoded_text[:, i : i + block_size]\n\t                logits = model(inp)[0]\n\t                nll = torch.nn.functional.cross_entropy(\n\t                    logits[:-1], inp[0, 1:].to(dtype=torch.long), reduction=\"sum\"\n", "                )\n\t                toks += inp.size(1) - 1\n\t                nlls += nll.item()\n\t        print(encoded_text.shape, logits.shape)\n\t        ppl = math.exp(nlls / toks)\n\t        print(f\"Perplexity on {dsname}: {ppl:.2f}\")\n\t        total_toks += toks\n\t    t = time.perf_counter() - t0\n\t    print(\n\t        f\"\\n\\nTime for inference: {t:.02f} sec total, {total_toks / t:.02f} tokens/sec\",\n", "        file=sys.stderr,\n\t    )\n\t    print(\n\t        f\"Memory used: {torch.cuda.max_memory_reserved() / 1e9:.02f} GB\",\n\t        file=sys.stderr,\n\t    )\n\tif __name__ == \"__main__\":\n\t    from jsonargparse import CLI\n\t    torch.set_float32_matmul_precision(\"high\")\n\t    CLI(main)\n"]}
