{"filename": "setup.py", "chunked_list": ["#!/usr/bin/env python\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\timport sys\n\tfrom setuptools import setup, find_packages\n\tif sys.version_info < (3, 8):\n\t    sys.exit(\"Sorry, Python < 3.8 is not supported\")\n\t# read the contents of the README file\n\twith open(\"README.rst\", encoding=\"utf-8\") as f:\n\t    README = f.read()\n\tEXTRA_EXAMPLE = [\"scipy\", \"bluepyopt\", \"emodelrunner>=1.1.5\"]\n\tsetup(\n", "    name=\"currentscape\",\n\t    author=\"Blue Brain Project, EPFL\",\n\t    use_scm_version={\n\t        \"version_scheme\": \"python-simplified-semver\",\n\t        \"local_scheme\": \"no-local-version\",\n\t    },\n\t    setup_requires=[\"setuptools_scm\"],\n\t    description=\"Module to easily plot currentscape.\",\n\t    long_description=README,\n\t    long_description_content_type=\"text/x-rst\",\n", "    url=\"https://github.com/BlueBrain/Currentscape\",\n\t    project_urls={\n\t        \"Tracker\": \"https://github.com/BlueBrain/Currentscape\",\n\t        \"Source\": \"https://github.com/BlueBrain/Currentscape\",\n\t    },\n\t    license=\"Apache 2.0\",\n\t    install_requires=[\n\t        \"numpy\",\n\t        \"matplotlib\",\n\t        \"palettable\",\n", "    ],\n\t    packages=find_packages(exclude=[\"tests\"]),\n\t    python_requires=\">=3.8\",\n\t    extras_require={\n\t        \"docs\": [\"sphinx\", \"sphinx-bluebrain-theme\"],\n\t        \"example\": EXTRA_EXAMPLE,\n\t    },\n\t    classifiers=[\n\t        \"Development Status :: 4 - Beta\",\n\t        \"Intended Audience :: Education\",\n", "        \"Intended Audience :: Science/Research\",\n\t        \"Programming Language :: Python\",\n\t        \"Programming Language :: Python :: 3\",\n\t        \"Programming Language :: Python :: 3.8\",\n\t        \"Programming Language :: Python :: 3.9\",\n\t        \"Programming Language :: Python :: 3.10\",\n\t        \"Programming Language :: Python :: 3.11\",\n\t        \"Topic :: Scientific/Engineering :: Bio-Informatics\",\n\t    ],\n\t)\n"]}
{"filename": "extra/spack/var/spack/repos/builtin/packages/py-currentscape/package.py", "chunked_list": ["# Copyright 2013-2020 Lawrence Livermore National Security, LLC and other\n\t# Spack Project Developers. See the top-level COPYRIGHT file for details.\n\t#\n\t# SPDX-License-Identifier: (Apache-2.0 OR MIT)\n\tfrom spack import *\n\tclass PyCurrentscape(PythonPackage):\n\t    \"\"\"Module to easily plot currentscape.\"\"\"\n\t    homepage = \"https://bbpcode.epfl.ch/code/#/admin/projects/cells/currentscape\"\n\t    url = \"ssh://bbpcode.epfl.ch/cells/currentscape\"\n\t    git = \"ssh://bbpcode.epfl.ch/cells/currentscape\"\n", "    version(\"develop\", branch=\"master\")\n\t    version(\"0.0.1\", tag=\"currentscape-v0.0.1\")\n\t    depends_on(\"py-setuptools\", type=\"build\")\n\t    depends_on(\"py-numpy\", type=\"run\")\n\t    depends_on(\"py-matplotlib\", type=\"run\")\n\t    depends_on(\"py-scipy\", type=\"run\")\n"]}
{"filename": "doc/source/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t#\n\t# This file only contains a selection of the most common options. For a full\n\t# list see the documentation:\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\t# -- Path setup --------------------------------------------------------------\n\t# If extensions (or modules to document with autodoc) are in another directory,\n\t# add these directories to sys.path here. If the directory is relative to the\n\t# documentation root, use os.path.abspath to make it absolute, like shown here.\n\t#\n", "# import os\n\t# import sys\n\t# sys.path.insert(0, os.path.abspath(\".\"))\n\tfrom pkg_resources import get_distribution\n\t# -- Project information -----------------------------------------------------\n\tproject = \"currentscape\"\n\t# The short X.Y version\n\tversion = get_distribution(\"currentscape\").version\n\t# The full version, including alpha/beta/rc tags\n\trelease = version\n", "# -- General configuration ---------------------------------------------------\n\t# Add any Sphinx extension module names here, as strings. They can be extensions\n\t# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\n\textensions = [\n\t    \"sphinx.ext.autodoc\",\n\t    \"sphinx.ext.autosummary\",\n\t    \"sphinx.ext.doctest\",\n\t    \"sphinx.ext.coverage\",\n\t    \"sphinx.ext.ifconfig\",\n\t    \"sphinx.ext.viewcode\",\n", "    \"sphinx.ext.napoleon\",\n\t]\n\t# Add any paths that contain templates here, relative to this directory.\n\t# templates_path = ['_templates']\n\t# List of patterns, relative to source directory, that match files and\n\t# directories to ignore when looking for source files.\n\t# This pattern also affects html_static_path and html_extra_path.\n\texclude_patterns = []\n\t# A list of ignored prefixes for module index sorting.\n\t# modindex_common_prefix = []\n", "autosummary_generate = True\n\tautodoc_default_options = {\"members\": True, \"show-inheritance\": True}\n\t# -- Options for HTML output -------------------------------------------------\n\t# The theme to use for HTML and HTML Help pages.  See the documentation for\n\t# a list of builtin themes.\n\t#\n\thtml_theme = \"sphinx-bluebrain-theme\"\n\t# Add any paths that contain custom static files (such as style sheets) here,\n\t# relative to this directory. They are copied after the builtin static files,\n\t# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n", "# html_static_path = ['_static']\n\thtml_theme_options = {\n\t    \"metadata_distribution\": \"currentscape\",\n\t}\n\thtml_title = u\"currentscape\"\n\t# If true, links to the reST sources are added to the pages.\n\thtml_show_sourcelink = False\n"]}
{"filename": "tests/test_currentscape_mapper.py", "chunked_list": ["\"\"\"Test currentscape mapper functions.\"\"\"\n\tfrom hypothesis import given, strategies as st\n\timport numpy as np\n\tfrom currentscape.mapper import (\n\t    has_common_divisor,\n\t    create_mapper,\n\t    map_colors,\n\t    map_patterns,\n\t)\n\tdef test_has_common_divisor():\n", "    \"\"\"Test has_common_divisor function.\"\"\"\n\t    assert has_common_divisor(4, 7, 7)\n\t    assert has_common_divisor(4, 5, 12)\n\t    assert not has_common_divisor(4, 5, 13)\n\t    assert not has_common_divisor(3, 7, 20)\n\tdef test_create_mapper():\n\t    \"\"\"Test create_mapper function.\"\"\"\n\t    assert create_mapper(4, 7) == 9\n\t    assert create_mapper(4, 5) == 7\n\t    assert create_mapper(6, 7) == 11\n", "def test_map_colors():\n\t    \"\"\"Test map_colors function.\"\"\"\n\t    assert map_colors(1, 4, 7) == 3\n\t    assert np.array_equal(map_colors(np.arange(5), 3, 5), [0, 2, 1, 0, 2])\n\tdef test_map_patterns():\n\t    \"\"\"Test map_patterns function.\"\"\"\n\t    assert map_patterns(13, 4, 5, 7) == 2\n\t    assert np.array_equal(map_patterns(np.arange(5), 3, 2, 5), [0, 1, 1, 1, 0])\n\t@given(\n\t    st.tuples(\n", "        # do not use overly unrealistic values.\n\t        # test can take too much time if a very large value is used.\n\t        st.integers(min_value=1, max_value=100),\n\t        st.integers(min_value=1, max_value=100),\n\t        st.integers(min_value=1, max_value=10000),\n\t    ).filter(lambda x: x[0] * x[1] >= x[2])\n\t)\n\tdef test_mapper_with_hypothesis(values):\n\t    \"\"\"Test create_mapper, map_colors and map_patterns with automatically generated input.\n\t    The mapper should behave as described in create_mapper docstring,\n", "    producing unique pairs of color / pattern.\n\t    \"\"\"\n\t    n_colors = values[0]\n\t    n_patterns = values[1]\n\t    n_currents = values[2]\n\t    mapper = create_mapper(n_colors, n_patterns)\n\t    curr_idxs = np.arange(n_currents)\n\t    colors = map_colors(curr_idxs, n_colors, mapper)\n\t    patterns = map_patterns(curr_idxs, n_colors, n_patterns, mapper)\n\t    combinations = list(zip(colors, patterns))\n", "    # This should be valid for any number as long as n_currents <= n_colors * n_patterns\n\t    assert len(combinations) == len(set(combinations))\n"]}
{"filename": "tests/test_currentscape_dataprocessing.py", "chunked_list": ["\"\"\"Test currentscape dataprocessing functions.\"\"\"\n\timport numpy as np\n\tfrom currentscape.data_processing import (\n\t    autoscale_ticks_and_ylim,\n\t    sum_chunks,\n\t    check_chunksize,\n\t    remove_zero_arrays,\n\t    reorder,\n\t    order_of_mag,\n\t    round_down_sig_digit,\n", ")\n\tdef compare_floats(n1, n2, err=1e-10):\n\t    \"\"\"Assert that two floats are closer than a given uncertainty.\"\"\"\n\t    assert (n1 - n2) / n1 < err\n\tdef test_order_of_mag():\n\t    \"\"\"Test function returning order of magnitude of a number.\"\"\"\n\t    assert order_of_mag(1234) == 1000\n\t    assert order_of_mag(0.0456) == 0.01\n\tdef test_round_down_sig_digit():\n\t    \"\"\"Test function rounding down a number to one (or more) significant digit(s).\"\"\"\n", "    assert round_down_sig_digit(0.0456) == 0.04\n\t    assert round_down_sig_digit(723) == 700\n\t    assert round_down_sig_digit(0.5) == 0.5\n\t    assert round_down_sig_digit(1234, 100) == 1200\n\tdef test_autoscale():\n\t    \"\"\"Test autoscale function.\"\"\"\n\t    config_key = \"test\"\n\t    test_dict = {\"ylim\": (0, 0), \"ticks\": [0, 0]}\n\t    c = {config_key: test_dict}\n\t    max_ = 654321\n", "    autoscale_ticks_and_ylim(c, max_, 0, config_key)\n\t    compare_floats(c[config_key][\"ylim\"][0], 0.3271605)\n\t    compare_floats(c[config_key][\"ylim\"][1], 3271605)\n\t    compare_floats(c[config_key][\"ticks\"][2], 60000)\n\t    compare_floats(c[config_key][\"ticks\"][1], 600)\n\t    compare_floats(c[config_key][\"ticks\"][0], 6)\n\t    max_ = 0.723\n\t    autoscale_ticks_and_ylim(c, 0, max_, config_key)\n\t    compare_floats(c[config_key][\"ylim\"][0], 0.0000003615)\n\t    compare_floats(c[config_key][\"ylim\"][1], 3.615)\n", "    compare_floats(c[config_key][\"ticks\"][2], 0.07)\n\t    compare_floats(c[config_key][\"ticks\"][1], 0.0007)\n\t    compare_floats(c[config_key][\"ticks\"][0], 0.000007)\n\tdef test_sum_chunks():\n\t    \"\"\"Test reshaping in sum chunks function.\"\"\"\n\t    arr1 = np.array([1, 1, 2, 2, 3, 3])\n\t    arr2 = np.array([0, 1, 2, 0, 1, 2])\n\t    arr = np.array([arr1, arr2])\n\t    assert np.array_equal(sum_chunks(arr, 1), [[1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 1, 2]])\n\t    assert np.array_equal(sum_chunks(arr, 2), [[1, 2, 3], [0.5, 1, 1.5]])\n", "    assert np.array_equal(sum_chunks(arr, 3), [[4 / 3.0, 8 / 3.0], [1, 1]])\n\tdef test_check_chunksize():\n\t    \"\"\"Test common divisor finder.\"\"\"\n\t    # chunksize < 1 case\n\t    assert check_chunksize(0, 3000) == 1\n\t    # chunksize > data size case\n\t    assert check_chunksize(3333, 3000) == 3000\n\t    # chunksize divisor of data size case\n\t    assert check_chunksize(50, 3000) == 50\n\t    # chunksize not a divisor of data size case\n", "    assert check_chunksize(49, 3000) == 40\n\tdef test_remove_zero_arrays():\n\t    \"\"\"Test remove zero array function.\"\"\"\n\t    arr = np.array([np.array([0, 1]), np.array([0, 0]), np.array([np.nan, 0])])\n\t    new_arr, new_idx = remove_zero_arrays(arr)\n\t    assert np.array_equal(new_arr, [[0, 1]])\n\t    assert new_idx == 0\n\tdef test_reorder():\n\t    \"\"\"Test reorder function.\n\t    The function removes null arrays, reorders from largest sum to smallest,\n", "    and returns reordered list and reordered indexes.\n\t    \"\"\"\n\t    arr1 = np.array([1, 1, 2, 2, 3, 3])\n\t    arr2 = np.array([0, 1, 2, 0, 1, 2])\n\t    arr3 = np.array([0, 0, 0, 0, 0, 0])\n\t    arr4 = np.array([1, 1, 2, 9, 3, 3])\n\t    arr = np.array([arr1, arr2, arr3, arr4])\n\t    new_arr, new_idx = reorder(arr)\n\t    assert np.array_equal(\n\t        new_arr, [[1, 1, 2, 9, 3, 3], [1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 1, 2]]\n", "    )\n\t    assert np.array_equal(new_idx, [3, 0, 1])\n"]}
{"filename": "tests/test_currentscape_currents.py", "chunked_list": ["\"\"\"Test currents methods.\"\"\"\n\timport numpy as np\n\tfrom currentscape.currents import Currents\n\tdef test_currents_init():\n\t    \"\"\"Test Currents constructor.\"\"\"\n\t    config = {\n\t        \"current\": {\"reorder\": False, \"black_line_thickness\": 2, \"names\": [\"Na\", \"Ca\"]},\n\t        \"currentscape\": {\"y_resolution\": 1000, \"legacy_method\": False},\n\t        \"pattern\": {\"use\": False, \"patterns\": [\"\", \"//\"]},\n\t        \"xaxis\": {\"xticks\": None},\n", "        \"colormap\": {\"n_colors\": 4},\n\t    }\n\t    currs = Currents([[0, 1], [2, 3]], config)\n\t    assert config[\"colormap\"][\"n_colors\"] == 2\n\t    assert currs.image is None\n\t    assert currs.mapper == 3\n\t    config[\"currentscape\"][\"legacy_method\"] = True\n\t    currs = Currents([[0, 1], [2, 3]], config)\n\t    assert np.array_equal(currs.data, [[0, 1], [2, 3]])\n\t    assert np.array_equal(currs.names, [\"Na\", \"Ca\"])\n", "    assert currs.mapper is None\n\t    assert currs.image is not None\n\t    config[\"pattern\"][\"use\"] = True\n\t    currs = Currents([[0, 1], [2, 3]], config)\n\t    assert config[\"colormap\"][\"n_colors\"] == 2\n\t    assert currs.image is None\n\t    assert currs.mapper == 3\n\t    # this part is a Currents.data_processing() unit test\n\t    currs = Currents([[-1, 1, -1], [-1, 0, 1], [2, 3, -4]], config)\n\t    assert np.array_equal(currs.pos_sum, [2, 4, 1])\n", "    assert np.array_equal(currs.neg_sum, [2, 0, 5])\n\t    assert np.array_equal(currs.pos_norm.idxs, [0, 1, 2])\n\t    assert np.array_equal(currs.neg_norm.idxs, [0, 1, 2])\n\t    assert np.array_equal(currs.pos_norm.data, [[0, 0.25, 0], [0, 0, 1], [1, 0.75, 0]])\n\t    assert np.array_equal(\n\t        currs.neg_norm.data, [[-0.5, 0, -0.2], [-0.5, 0, 0], [0, 0, -0.8]]\n\t    )\n\t    # test data_processing() with zero array\n\t    currs = Currents([[-1, 1, -1], [-1, 0, -3], [2, 3, 4]], config)\n\t    assert np.array_equal(currs.pos_sum, [2, 4, 4])\n", "    assert np.array_equal(currs.neg_sum, [2, 0, 4])\n\t    assert np.array_equal(currs.pos_norm.idxs, [0, 2])\n\t    assert np.array_equal(currs.neg_norm.idxs, [0, 1])\n\t    assert np.array_equal(currs.pos_norm.data, [[0, 0.25, 0], [1, 0.75, 1]])\n\t    assert np.array_equal(currs.neg_norm.data, [[-0.5, 0, -0.25], [-0.5, 0, -0.75]])\n\t    # test data_processing() with reorder\n\t    config[\"current\"][\"reorder\"] = True\n\t    currs = Currents([[-1, 1, -1], [-1, 0, -3], [2, 3, 4]], config)\n\t    assert np.array_equal(currs.pos_sum, [2, 4, 4])\n\t    assert np.array_equal(currs.neg_sum, [2, 0, 4])\n", "    assert np.array_equal(currs.pos_norm.idxs, [2, 0])\n\t    assert np.array_equal(currs.neg_norm.idxs, [1, 0])\n\t    assert np.array_equal(currs.pos_norm.data, [[1, 0.75, 1], [0, 0.25, 0]])\n\t    assert np.array_equal(currs.neg_norm.data, [[-0.5, 0, -0.75], [-0.5, 0, -0.25]])\n\tdef test_reorder_currents_and_names():\n\t    \"\"\"Test reorder_currents_and_names method.\"\"\"\n\t    config = {\n\t        \"current\": {\"reorder\": False, \"black_line_thickness\": 2, \"names\": [\"Na\", \"Ca\"]},\n\t        \"currentscape\": {\"y_resolution\": 1000, \"legacy_method\": False},\n\t        \"pattern\": {\"use\": True, \"patterns\": [\"\", \"//\"]},\n", "        \"xaxis\": {\"xticks\": None},\n\t        \"colormap\": {\"n_colors\": 4},\n\t    }\n\t    currs = Currents([[-1, 1, -1], [-1, 0, -3], [2, 3, 4]], config)\n\t    assert np.array_equal(currs.idxs, [0, 1, 2])\n\t    cnorm_pos = np.array([[0, 0.25, 0], [0, 0, 0], [1, 0.75, 1]])\n\t    cnorm_neg = np.array([[-0.5, 0, -0.75], [-0.5, 0, -0.25], [0, 0, 0]])\n\t    currs.reorder_currents_and_names(cnorm_pos, cnorm_neg)\n\t    assert np.array_equal(currs.idxs, [2, 0, 1])\n\tdef test_create_black_line():\n", "    \"\"\"Test create_black_line method.\"\"\"\n\t    config = {\n\t        \"current\": {\"reorder\": False, \"black_line_thickness\": 2, \"names\": [\"Na\", \"Ca\"]},\n\t        \"currentscape\": {\"y_resolution\": 1000, \"legacy_method\": False},\n\t        \"pattern\": {\"use\": False, \"patterns\": [\"\", \"//\"]},\n\t        \"xaxis\": {\"xticks\": None},\n\t        \"colormap\": {\"n_colors\": 4},\n\t    }\n\t    currs = Currents([[0, 1, 2], [2, 3, 4]], config)\n\t    # case line_thickness < 1\n", "    line = currs.create_black_line(10, 2)\n\t    assert np.array_equal(line, [[2, 2, 2]])\n\t    assert line.dtype == np.int8\n\t    # case line_thickness > 1 (here: 3)\n\t    line = currs.create_black_line(100, 3)\n\t    assert np.array_equal(line, [[2, 2, 2], [2, 2, 2], [2, 2, 2]])\n\t    assert line.dtype == np.int8\n\tdef test_create_cscape_image():\n\t    \"\"\"Test create_cscape_image method.\"\"\"\n\t    config = {\n", "        \"current\": {\"reorder\": False, \"black_line_thickness\": 2, \"names\": [\"Na\", \"Ca\"]},\n\t        \"currentscape\": {\"y_resolution\": 1000, \"legacy_method\": True},\n\t        \"pattern\": {\"use\": False, \"patterns\": [\"\", \"//\"]},\n\t        \"xaxis\": {\"xticks\": None},\n\t        \"colormap\": {\"n_colors\": 4},\n\t    }\n\t    currs = Currents([[-1, 1, -1], [-1, 0, -3], [2, 3, 4]], config)\n\t    # assert dtype is np.int8\n\t    image = currs.create_cscape_image(8, 2)\n\t    assert image.dtype == np.int8\n", "    assert np.array_equal(\n\t        image,\n\t        [\n\t            [2, 0, 2],  # positive curents\n\t            [2, 0, 2],\n\t            [2, 2, 2],\n\t            [2, 2, 2],\n\t            [2, 2, 2],\n\t            [2, 2, 2],\n\t            [2, 2, 2],\n", "            [2, 2, 2],\n\t            [3, 3, 3],  # black line\n\t            [0, 4, 0],  # negative currents\n\t            [0, 4, 0],\n\t            [0, 4, 1],\n\t            [0, 4, 1],\n\t            [1, 4, 1],\n\t            [1, 4, 1],\n\t            [1, 4, 1],\n\t            [1, 4, 1],\n", "        ],\n\t    )\n\t    # try with reorder\n\t    currs.idxs = [2, 0, 1]\n\t    image = currs.create_cscape_image(8, 2)\n\t    assert np.array_equal(\n\t        image,\n\t        [\n\t            [0, 1, 0],  # positive curents\n\t            [0, 1, 0],\n", "            [0, 0, 0],\n\t            [0, 0, 0],\n\t            [0, 0, 0],\n\t            [0, 0, 0],\n\t            [0, 0, 0],\n\t            [0, 0, 0],\n\t            [3, 3, 3],  # black line\n\t            [1, 4, 1],  # negative currents\n\t            [1, 4, 1],\n\t            [1, 4, 2],\n", "            [1, 4, 2],\n\t            [2, 4, 2],\n\t            [2, 4, 2],\n\t            [2, 4, 2],\n\t            [2, 4, 2],\n\t        ],\n\t    )\n"]}
{"filename": "tests/test_currentscape_datasets.py", "chunked_list": ["\"\"\"Test datasets methods.\"\"\"\n\timport numpy as np\n\tfrom currentscape.datasets import DataSet\n\tdef test_dataset_init():\n\t    \"\"\"Test Dataset constructor.\"\"\"\n\t    ds = DataSet(data=None)\n\t    assert ds.data is None\n\t    assert ds.N is None\n\t    assert ds.idxs is None\n\t    assert ds.x_size is None\n", "    ds = DataSet(data=[])\n\t    assert np.array_equal(ds.data, [])\n\t    assert ds.N == 0\n\t    assert np.array_equal(ds.idxs, [])\n\t    assert ds.x_size == 0\n\t    ds = DataSet(data=[[0, 1, 2], [1, 2, 3]])\n\t    assert isinstance(ds.data, np.ndarray)\n\t    assert np.array_equal(ds.data, [[0, 1, 2], [1, 2, 3]])\n\t    assert ds.N == 2\n\t    assert np.array_equal(ds.idxs, [0, 1])\n", "    assert ds.x_size == 3\n\t    assert np.array_equal(ds.time, [0, 1, 2])\n\t    ds = DataSet(data=None, names=[\"Ca\", \"Na\"])\n\t    assert np.array_equal(ds.names, [\"Ca\", \"Na\"])\n\t    ds = DataSet(data=None, time=[4, 5, 6])\n\t    assert np.array_equal(ds.time, [4, 5, 6])\n\t    ds = DataSet(data=None, xticks=[10, 20])\n\t    assert np.array_equal(ds.xticks, [10, 20])\n\tdef test_get_negative_data():\n\t    \"\"\"Test get_negative_data method.\"\"\"\n", "    ds = DataSet(data=[[-1, 1], [2, -3]])\n\t    assert np.array_equal(ds.get_negative_data(), [[-1, 0], [0, -3]])\n\tdef test_get_positive_data():\n\t    \"\"\"Test get_positive_data method.\"\"\"\n\t    ds = DataSet(data=[[-1, 1], [2, -3]])\n\t    assert np.array_equal(ds.get_positive_data(), [[0, 1], [2, 0]])\n\tdef test_dataset_xticks():\n\t    \"\"\"Test the DataSet function that automatically sets xticks.\"\"\"\n\t    ds0 = DataSet(data=None, time=None)\n\t    assert ds0.xticks is None\n", "    ds0 = DataSet(data=None, time=[])\n\t    assert ds0.xticks is None\n\t    ds0 = DataSet(data=None, time=[1.234])\n\t    assert np.array_equal(ds0.xticks, [1.234])\n\t    ds1 = DataSet(data=None, time=np.arange(0, 2000, 10))\n\t    assert np.array_equal(\n\t        ds1.xticks, [0.0, 250.0, 500.0, 750.0, 1000.0, 1250.0, 1500.0, 1750.0]\n\t    )\n\t    ds2 = DataSet(data=None, time=np.arange(0, 2001, 10))\n\t    assert np.array_equal(ds2.xticks, [0, 500, 1000, 1500, 2000])\n", "    ds3 = DataSet(data=None, time=np.array([0, 0.51]))\n\t    # round to avoid floating errors\n\t    ds3ticks = np.around(ds3.xticks, decimals=1)\n\t    expected_ds3 = np.around([0.0, 0.1, 0.2, 0.3, 0.4, 0.5], decimals=1)\n\t    assert np.array_equal(ds3ticks, expected_ds3)\n\t    ds4 = DataSet(data=None, time=np.arange(1002, 1055, 1))\n\t    assert np.array_equal(ds4.xticks, [1010, 1020, 1030, 1040, 1050])\n\t    ds5 = DataSet(data=None, time=np.arange(999, 1005, 1))\n\t    assert np.array_equal(ds5.xticks, [999, 1000, 1001, 1002, 1003, 1004])\n\tdef test_xticks_for_imshow():\n", "    \"\"\"Test xticks_for_imshow method.\"\"\"\n\t    ds = DataSet(data=None, time=[0, 1], xticks=[0, 1])\n\t    assert ds.xticks_for_imshow() is None\n\t    ds = DataSet(data=[[1], [2]], time=[0], xticks=[0])\n\t    assert np.array_equal(ds.xticks_for_imshow(), [0])\n\t    ds = DataSet(data=[[0, 1, 2], [2, 3, 4]], time=[1, 3], xticks=[1.5, 2.5])\n\t    assert np.array_equal(ds.xticks_for_imshow(), [0.75, 2.25])\n"]}
{"filename": "tests/test_currentscape_config_parser.py", "chunked_list": ["\"\"\"Test currentscape config parser.\"\"\"\n\tfrom logging import WARNING\n\tfrom pytest import LogCaptureFixture\n\tfrom currentscape.config_parser import check_config, replace_defaults\n\tdef test_check_config(caplog: LogCaptureFixture):\n\t    \"\"\"Test that check_config warns when discrepancy between patterns and line styles.\"\"\"\n\t    config = {\n\t        \"pattern\": {\"use\": True, \"patterns\": [\"\", \"/\", \"\\\\\"]},\n\t        \"show\": {\"all_currents\": True},\n\t        \"line\": {\"styles\": [\"solid\", (0, (1, 1))]},\n", "    }\n\t    caplog.set_level(WARNING)\n\t    check_config(config)\n\t    assert (\n\t        \"currentscape.config_parser\",\n\t        WARNING,\n\t        \"line:styles should have as many items as pattern:patterns.\",\n\t    ) in caplog.record_tuples\n\tdef test_replace_defaults():\n\t    \"\"\"Test replace_defaults function.\"\"\"\n", "    # replace non-dict\n\t    default_config = {\"test\": 1}\n\t    user_config = {\"test\": 2}\n\t    new_config = replace_defaults(default_config, user_config)\n\t    assert new_config == {\"test\": 2}\n\t    # add non-dict\n\t    default_config = {}\n\t    user_config = {\"test\": 2}\n\t    new_config = replace_defaults(default_config, user_config)\n\t    assert new_config == {\"test\": 2}\n", "    # no input\n\t    default_config = {\"test\": 1}\n\t    user_config = {}\n\t    new_config = replace_defaults(default_config, user_config)\n\t    assert new_config == {\"test\": 1}\n\t    # replace in dict\n\t    default_config = {\"test\": {\"inner\": 1}}\n\t    user_config = {\"test\": {\"inner\": 2}}\n\t    new_config = replace_defaults(default_config, user_config)\n\t    assert new_config == {\"test\": {\"inner\": 2}}\n", "    # add item to dict\n\t    default_config = {\"test\": {\"inner\": 1}}\n\t    user_config = {\"test\": {\"new\": 2}}\n\t    new_config = replace_defaults(default_config, user_config)\n\t    assert new_config == {\"test\": {\"inner\": 1, \"new\": 2}}\n"]}
{"filename": "tests/test_currentscape_from_paper.py", "chunked_list": ["\"\"\"Test that example produces a figure.\"\"\"\n\timport os\n\timport sys\n\tfrom tests.utils import cwd\n\tEXAMPLE_FOLDER = os.path.join(\"examples\", \"original_paper_plot\")\n\tsys.path.insert(0, os.path.abspath(EXAMPLE_FOLDER))\n\tdef test_example_original_paper():\n\t    with cwd(EXAMPLE_FOLDER):\n\t        from integrate_single_compartment_and_plot_currentscape import (\n\t            plot_from_original_paper,\n", "        )\n\t        _ = plot_from_original_paper(tf=2500.0, dt=1.0)\n\t    assert os.path.isfile(os.path.join(EXAMPLE_FOLDER, \"output\", \"example.png\"))\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_currentscape_ions.py", "chunked_list": ["\"\"\"Test ions methods.\"\"\"\n\timport numpy as np\n\tfrom currentscape.ions import IonConcentrations\n\tdef test_ionconcentrations_init():\n\t    \"\"\"Test IonConcentrations constructor.\"\"\"\n\t    # data is None case\n\t    config = {\n\t        \"ions\": {\"reorder\": False, \"names\": [\"Ca\", \"Na\"]},\n\t        \"pattern\": {\"use\": True, \"patterns\": [\"\", \"//\"]},\n\t        \"xaxis\": {\"xticks\": None},\n", "        \"colormap\": {\"n_colors\": 3},\n\t    }\n\t    ions = IonConcentrations(None, config)\n\t    assert ions.data is None\n\t    assert np.array_equal(ions.names, [\"Ca\", \"Na\"])\n\t    assert ions.mapper is None\n\t    # data is not None but patter use is False case\n\t    config[\"pattern\"][\"use\"] = False\n\t    ions = IonConcentrations([[1, 2], [3, 4]], config)\n\t    assert ions.mapper is None\n", "    assert np.array_equal(ions.idxs, [0, 1])\n\t    # data not None, pattern use True, and n_colors > len(data) case\n\t    config[\"pattern\"][\"use\"] = True\n\t    ions = IonConcentrations([[1, 2], [3, 4]], config)\n\t    assert ions.mapper == 3\n\t    # data not None, pattern use True, and n_colors < len(data) case\n\t    ions = IonConcentrations([[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]], config)\n\t    assert ions.mapper == 5\n\t    # data not None and reorder True\n\t    config[\"ions\"][\"reorder\"] = True\n", "    ions = IonConcentrations([[1, 2], [3, 4]], config)\n\t    assert np.array_equal(ions.idxs, [1, 0])\n"]}
{"filename": "tests/utils.py", "chunked_list": ["\"\"\"Utils.\"\"\"\n\timport os\n\tfrom contextlib import contextmanager\n\t@contextmanager\n\tdef cwd(path):\n\t    \"\"\"Cwd function that can be used in a context manager.\"\"\"\n\t    old_dir = os.getcwd()\n\t    os.chdir(path)\n\t    yield\n\t    os.chdir(old_dir)\n"]}
{"filename": "tests/test_currentscape_plotting.py", "chunked_list": ["\"\"\"Test currentscape plotting functions.\"\"\"\n\tfrom logging import WARNING\n\timport os\n\timport matplotlib\n\tmatplotlib.use(\"agg\")  # to avoid tkinter error\n\timport matplotlib.pyplot as plt\n\timport numpy as np\n\tfrom pytest import LogCaptureFixture\n\tfrom currentscape.ions import IonConcentrations\n\tfrom currentscape.plotting import (\n", "    configure_mpl_rcParams,\n\t    get_rows_tot,\n\t    get_colors,\n\t    get_colormap,\n\t    select_color,\n\t    get_colors_hatches_lines_lists,\n\t    save_figure,\n\t)\n\tdef test_configure_mpl_rcParams():\n\t    \"\"\"Test configure_mpl_rcParams function.\"\"\"\n", "    config = {\n\t        \"textsize\": 6,\n\t        \"legend\": {\"textsize\": 4, \"handlelength\": 1.4},\n\t        \"pattern\": {\"use\": False, \"linewidth\": 0.2},\n\t    }\n\t    configure_mpl_rcParams(config)\n\t    assert plt.rcParams[\"axes.labelsize\"] == 6\n\t    assert plt.rcParams[\"xtick.labelsize\"] == 6\n\t    assert plt.rcParams[\"ytick.labelsize\"] == 6\n\t    assert plt.rcParams[\"legend.fontsize\"] == 4\n", "    assert plt.rcParams[\"legend.handletextpad\"] == 0\n\t    assert plt.rcParams[\"legend.labelspacing\"] == 0\n\t    assert plt.rcParams[\"legend.handlelength\"] == 0\n\t    config[\"pattern\"][\"use\"] = True\n\t    configure_mpl_rcParams(config)\n\t    assert plt.rcParams[\"axes.labelsize\"] == 6\n\t    assert plt.rcParams[\"xtick.labelsize\"] == 6\n\t    assert plt.rcParams[\"ytick.labelsize\"] == 6\n\t    assert plt.rcParams[\"legend.fontsize\"] == 4\n\t    assert plt.rcParams[\"hatch.linewidth\"] == 0.2\n", "    assert plt.rcParams[\"legend.handlelength\"] == 1.4\n\tdef test_get_rows_tot():\n\t    \"\"\"Test get_rows_tot function.\"\"\"\n\t    config = {\n\t        \"pattern\": {\"use\": False, \"patterns\": []},\n\t        \"show\": {\"all_currents\": False, \"total_contribution\": False},\n\t        \"ions\": {\"reorder\": False, \"names\": None},\n\t        \"xaxis\": {\"xticks\": None},\n\t        \"currentscape\": {\"legacy_method\": True},\n\t    }\n", "    ions = IonConcentrations(None, config)\n\t    rows = get_rows_tot(config, ions)\n\t    assert rows == 7\n\t    config[\"pattern\"][\"use\"] = True\n\t    rows = get_rows_tot(config, ions)\n\t    assert rows == 8\n\t    config[\"pattern\"][\"use\"] = False\n\t    config[\"currentscape\"][\"legacy_method\"] = False\n\t    rows = get_rows_tot(config, ions)\n\t    assert rows == 8\n", "    config[\"pattern\"][\"use\"] = False\n\t    config[\"show\"][\"all_currents\"] = True\n\t    rows = get_rows_tot(config, ions)\n\t    assert rows == 10\n\t    config[\"show\"][\"all_currents\"] = False\n\t    config[\"show\"][\"total_contribution\"] = True\n\t    rows = get_rows_tot(config, ions)\n\t    assert rows == 10\n\t    config[\"show\"][\"total_contribution\"] = False\n\t    ions.data = [[1, 2], [3, 4]]\n", "    rows = get_rows_tot(config, ions)\n\t    assert rows == 9\n\t    config[\"pattern\"][\"use\"] = True\n\t    config[\"show\"][\"all_currents\"] = True\n\t    config[\"show\"][\"total_contribution\"] = True\n\t    rows = get_rows_tot(config, ions)\n\t    assert rows == 13\n\tdef test_get_colors():\n\t    \"\"\"Test get_colors function.\n\t    Check that matplotlib and palettable cmap are acepted.\n", "    Check the bool indicating a number of colors too big.\n\t    \"\"\"\n\t    # matplotlib, enough colors\n\t    l, cmap_too_small = get_colors(\"Set1\", 8)\n\t    assert not cmap_too_small\n\t    assert len(l) == len(set(tuple(item) for item in l))  # no duplicates\n\t    # matplotlib, not enough colors\n\t    l, cmap_too_small = get_colors(\"Set1\", 30)\n\t    assert cmap_too_small\n\t    assert len(l) > len(set(tuple(item) for item in l))  # no duplicates\n", "    # palettable, enough colors\n\t    _, cmap_too_small = get_colors(\"cartocolors.qualitative.Antique_8\", 8)\n\t    assert not cmap_too_small\n\t    # palettable, not enough colors\n\t    _, cmap_too_small = get_colors(\"cartocolors.qualitative.Antique_8\", 9)\n\t    assert cmap_too_small\n\tdef test_get_colormap(caplog: LogCaptureFixture):\n\t    \"\"\"Test get_colormap function.\n\t    Check that black and white colors are present at the end of colormap.\n\t    Check that warnings are launched.\n", "    \"\"\"\n\t    cmap = get_colormap(\n\t        cmap=\"Set1\", n_colors=6, use_patterns=False, N_curr=6, N_ion=None\n\t    )\n\t    assert len(cmap.colors) == 8\n\t    assert np.array_equal(cmap.colors[-2], [0, 0, 0, 1])\n\t    assert np.array_equal(cmap.colors[-1], [1, 1, 1, 1])\n\t    caplog.set_level(WARNING)\n\t    get_colormap(cmap=\"Set1\", n_colors=6, use_patterns=False, N_curr=30, N_ion=None)\n\t    assert (\n", "        \"currentscape.plotting\",\n\t        WARNING,\n\t        \"The number of colors in the colormap \"\n\t        \"is smaller than the number of currents. \"\n\t        \"Please, choose a colormap with more colors \"\n\t        \"or use patterns for optimal display.\",\n\t    ) in caplog.record_tuples\n\t    get_colormap(cmap=\"Set1\", n_colors=25, use_patterns=True, N_curr=30, N_ion=None)\n\t    assert (\n\t        \"currentscape.plotting\",\n", "        WARNING,\n\t        \"'n_colors' in 'colormap' in config is larger than \"\n\t        \"the number of colors in the colormap. \"\n\t        \"Please, choose a colormap with more colors \"\n\t        \"or decrease n_colors for optimal display.\",\n\t    ) in caplog.record_tuples\n\tdef test_select_color():\n\t    \"\"\"Test select_color function.\"\"\"\n\t    # colormap with 2 colors + black + white\n\t    cmap = get_colormap(\n", "        cmap=\"Set1\", n_colors=None, use_patterns=False, N_curr=2, N_ion=None\n\t    )\n\t    assert len(cmap.colors) == 4\n\t    # assert the two colors are different\n\t    assert select_color(cmap, 0, 2) != select_color(cmap, 1, 2)\n\t    # assert 3rd is black\n\t    assert np.array_equal(select_color(cmap, 2, 2), (0, 0, 0, 1))\n\t    # assert 4th is white\n\t    assert np.array_equal(select_color(cmap, 3, 2), (1, 1, 1, 1))\n\tdef to_tuple(lst):\n", "    return tuple(to_tuple(i) if isinstance(i, list) else i for i in lst)\n\tdef test_get_colors_hatches_lines_lists():\n\t    \"\"\"Test get_colors_and_hatches_lists function.\"\"\"\n\t    linestyles = [\n\t        \"solid\",\n\t        [0, [1, 1]],\n\t        [0, [2, 1]],\n\t        [0, [2, 1, 1, 1]],\n\t        [0, [2, 1, 1, 1, 1, 1]],\n\t        [0, [2, 1, 2, 1, 1, 1]],\n", "        [0, [2, 1, 2, 1, 1, 1, 1, 1]],\n\t    ]\n\t    # do not use pattern case\n\t    config = {\"pattern\": {\"use\": False}}\n\t    curr_idxs = np.arange(4)\n\t    cmap = get_colormap(\n\t        cmap=\"Set1\", n_colors=None, use_patterns=False, N_curr=4, N_ion=None\n\t    )\n\t    colors, hatches, lines = get_colors_hatches_lines_lists(\n\t        config, curr_idxs, cmap, mapper=None\n", "    )\n\t    assert len(colors) == 4\n\t    assert hatches is None\n\t    assert np.array_equal(lines, np.full(4, \"solid\"))\n\t    # use pattern case\n\t    config = {\n\t        \"pattern\": {\n\t            \"use\": True,\n\t            \"density\": 5,\n\t            \"patterns\": [\"\", \"/\", \"\\\\\", \"x\", \".\", \"o\", \"+\"],\n", "        },\n\t        \"colormap\": {\"n_colors\": 4},\n\t        \"line\": {\"styles\": linestyles},\n\t    }\n\t    cmap = get_colormap(\n\t        cmap=\"Set1\", n_colors=4, use_patterns=True, N_curr=4, N_ion=None\n\t    )\n\t    colors, hatches, lines = get_colors_hatches_lines_lists(\n\t        config, curr_idxs, cmap, mapper=9\n\t    )\n", "    assert len(colors) == 4\n\t    assert len(hatches) == 4\n\t    assert len(lines) == 4\n\t    # no repetition because N_curr <= n_colors, and N_curr <= len(patterns)\n\t    assert len(colors) == len(set(tuple(color) for color in colors))\n\t    assert len(hatches) == len(set(tuple(hatch) for hatch in hatches))\n\t    assert len(lines) == len(set(to_tuple(lines)))\n\t    # now with n_curr > n_colors, n_currs > len(patterns)\n\t    cmap = get_colormap(\n\t        cmap=\"Set1\", n_colors=4, use_patterns=True, N_curr=20, N_ion=None\n", "    )\n\t    curr_idxs = np.arange(20)\n\t    colors, hatches, lines = get_colors_hatches_lines_lists(\n\t        config, curr_idxs, cmap, mapper=9\n\t    )\n\t    assert len(colors) == 20\n\t    assert len(hatches) == 20\n\t    assert len(lines) == 20\n\t    # colors and hatches get combined with (colors[i], hatches[i])\n\t    # all combinations should be unique\n", "    combinations = []\n\t    for col, hatch in zip(colors, hatches):\n\t        combinations.append((tuple(col), hatch))\n\t    assert len(combinations) == len(set(combinations)) == 20\n\t    combinations = []\n\t    for col, line in zip(colors, lines):\n\t        combinations.append((tuple(col), to_tuple(line)))\n\t    assert len(combinations) == len(set(combinations)) == 20\n\tdef test_save_figure():\n\t    \"\"\"Test save_figure function.\"\"\"\n", "    fpath = \"tests/output/test_savefig.png\"\n\t    config = {\n\t        \"output\": {\n\t            \"dir\": \"tests/output\",\n\t            \"fname\": \"test_savefig\",\n\t            \"extension\": \"png\",\n\t            \"dpi\": 100,\n\t            \"transparent\": False,\n\t        }\n\t    }\n", "    fig = plt.figure()\n\t    save_figure(fig, config)\n\t    assert os.path.isfile(fpath)\n"]}
{"filename": "tests/test_use_case_example.py", "chunked_list": ["\"\"\"Test that example produces a figure.\"\"\"\n\timport os\n\timport subprocess\n\timport sys\n\tfrom tests.utils import cwd\n\tEXAMPLE_FOLDER = os.path.join(\"examples\", \"use_case\")\n\tsys.path.insert(0, os.path.abspath(EXAMPLE_FOLDER))\n\tdef test_extraction_and_plot():\n\t    with cwd(EXAMPLE_FOLDER):\n\t        from run import run\n", "        from plot import plot\n\t        subprocess.call([\"nrnivmodl\", \"mechanisms\"])\n\t        run()\n\t        outputs = [\n\t            \"cai.dat\",\n\t            \"i_pas.dat\",\n\t            \"ica_Ca_HVA2.dat\",\n\t            \"ica_Ca_LVAst.dat\",\n\t            \"ihcn_Ih.dat\",\n\t            \"ik_K_Pst.dat\",\n", "            \"ik_K_Tst.dat\",\n\t            \"ik_SK_E2.dat\",\n\t            \"ik_SKv3_1.dat\",\n\t            \"ina_NaTg.dat\",\n\t            \"ki.dat\",\n\t            \"nai.dat\",\n\t            \"v.dat\",\n\t        ]\n\t    for output in outputs:\n\t        assert os.path.isfile(os.path.join(EXAMPLE_FOLDER, \"python_recordings\", output))\n", "    fig = plot()\n\t    assert len(fig.axes) == 6\n"]}
{"filename": "currentscape/mapper.py", "chunked_list": ["\"\"\"Mappers.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\t# pylint: disable=deprecated-method\n\ttry:\n\t    # python 3\n\t    from math import gcd\n\texcept ImportError:\n\t    # python 2\n\t    from fractions import gcd\n\tdef has_common_divisor(n1, n2, n):\n\t    \"\"\"Return True if n has a common divisor with either n1 or n2.\"\"\"\n", "    if gcd(n, n1) == 1 and gcd(n, n2) == 1:\n\t        return False\n\t    return True\n\tdef create_mapper(n_colors, n_patterns):\n\t    \"\"\"Find a number n that will be useful to find pairs (color, pattern).\n\t    Those pairs should not have the same color in a row and the same pattern in a row.\n\t    n should work as in the following example.\n\t    Example:\n\t        for i in range(n_currents):\n\t            color = (n*i) % n_colors\n", "            pattern = ( (n*i) // n_colors) % n_patterns\n\t    Constraints:\n\t        * For two patterns to be different in a row: n>=n_patterns\n\t        * n should not have a common divisor with either n_colors or n_patterns.\n\t    \"\"\"\n\t    mapper = n_patterns\n\t    while has_common_divisor(n_colors, n_patterns, mapper):\n\t        mapper += 1\n\t    return mapper\n\tdef map_colors(curr_idxs, n_colors, mapper):\n", "    \"\"\"Get color index(es) s.t. a color / pattern index pair cannot be produced twice.\n\t    Args:\n\t        curr_idxs (int or ndarray of ints): index(es) of the current(s).\n\t            should be smaller than number of currents\n\t        n_colors (int): total number of colors\n\t        mapper (int): number used to mix colors and patterns\n\t    \"\"\"\n\t    return (mapper * curr_idxs) % n_colors\n\tdef map_patterns(curr_idxs, n_colors, n_patterns, mapper):\n\t    \"\"\"Get pattern index(es) s.t. a color / pattern index pair cannot be produced twice.\n", "    Args:\n\t        curr_idxs (int or ndarray of ints): index(es) of the current(s).\n\t            should be smaller than number of currents\n\t        n_colors (int): total number of colors\n\t        n_patterns (int): total number of patterns\n\t        mapper (int): number used to mix colors and patterns\n\t    \"\"\"\n\t    return ((mapper * curr_idxs) // n_colors) % n_patterns\n"]}
{"filename": "currentscape/voltages.py", "chunked_list": ["\"\"\"Voltages class.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\t# pylint: disable=wrong-import-position, super-with-arguments\n\timport numpy as np\n\timport matplotlib\n\tmatplotlib.use(\"agg\")  # to avoid tkinter error\n\timport matplotlib.pyplot as plt\n\tfrom currentscape.datasets import DataSet\n\tfrom currentscape.plotting import remove_ticks_and_frame, show_xgridlines\n\tclass Voltages(DataSet):\n\t    \"\"\"Class containing voltage data.\"\"\"\n", "    def __init__(self, data, c, time):\n\t        \"\"\"Constructor.\n\t        Args:\n\t            data (list): data\n\t            c (dict): config\n\t            time (list): time of the data\n\t        \"\"\"\n\t        # DataSet expect a list of lists as data\n\t        super(Voltages, self).__init__(\n\t            data=[data], names=None, time=time, xticks=c[\"xaxis\"][\"xticks\"]\n", "        )\n\t    def plot(self, c, row, rows_tot):\n\t        \"\"\"Plot voltage trace.\n\t        Args:\n\t            c (dict): config\n\t            row (int): row of subplot\n\t            rows_tot (int): total number of subplots in the figure\n\t        \"\"\"\n\t        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=2)\n\t        ax.plot(self.time, self.data[0], color=c[\"voltage\"][\"color\"], lw=c[\"lw\"])\n", "        ax.plot(\n\t            self.time,\n\t            np.ones(self.x_size) * c[\"voltage\"][\"ticks\"][0],\n\t            ls=\"dashed\",\n\t            color=\"black\",\n\t            lw=0.75,\n\t        )\n\t        ax.vlines(\n\t            1, c[\"voltage\"][\"ticks\"][0], c[\"voltage\"][\"ticks\"][-1], lw=1, color=\"black\"\n\t        )\n", "        ax.set_ylim(c[\"voltage\"][\"ylim\"])\n\t        ax.set_xlim([self.time[0], self.time[-1]])\n\t        # show x axis gridline\n\t        if c[\"show\"][\"xgridlines\"]:\n\t            show_xgridlines(ax, c, self.xticks, c[\"voltage\"][\"ylim\"])\n\t        if c[\"show\"][\"ylabels\"]:\n\t            ax.set_ylabel(c[\"voltage\"][\"units\"], labelpad=c[\"labelpad\"])\n\t        if c[\"show\"][\"yticklabels\"]:\n\t            ax.set_yticks(c[\"voltage\"][\"ticks\"])\n\t        remove_ticks_and_frame(ax)\n"]}
{"filename": "currentscape/plotting.py", "chunked_list": ["\"\"\"Plotting-related functions.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\t# pylint: disable=too-many-locals, wrong-import-position\n\timport logging\n\tfrom pathlib import Path\n\timport numpy as np\n\timport matplotlib\n\tmatplotlib.use(\"agg\")  # to avoid tkinter error\n\timport matplotlib.pyplot as plt\n\timport palettable as pltb\n\tfrom currentscape.data_processing import sum_chunks\n", "from currentscape.mapper import map_colors, map_patterns\n\tlogger = logging.getLogger(__name__)\n\tdef configure_mpl_rcParams(c):\n\t    \"\"\"Configure matplotlib rcParams.\n\t    Args:\n\t        c (dict): config\n\t    \"\"\"\n\t    # set text size\n\t    plt.rcParams[\"axes.labelsize\"] = c[\"textsize\"]\n\t    plt.rcParams[\"xtick.labelsize\"] = c[\"textsize\"]\n", "    plt.rcParams[\"ytick.labelsize\"] = c[\"textsize\"]\n\t    plt.rcParams[\"legend.fontsize\"] = c[\"legend\"][\"textsize\"]\n\t    if c[\"pattern\"][\"use\"]:\n\t        plt.rcParams[\"hatch.linewidth\"] = c[\"pattern\"][\"linewidth\"]\n\t        plt.rcParams[\"legend.handlelength\"] = c[\"legend\"][\"handlelength\"]\n\t    else:\n\t        # remove legend handles\n\t        plt.rcParams[\"legend.handletextpad\"] = 0\n\t        plt.rcParams[\"legend.labelspacing\"] = 0\n\t        plt.rcParams[\"legend.handlelength\"] = 0\n", "def get_rows_tot(c, ions):\n\t    \"\"\"Return the total number of rows cumulated by all the subplots.\n\t    Args:\n\t        c (dict): config\n\t        ions (IonConcentrations): ion concentration dataset\n\t    \"\"\"\n\t    rows_tot = 7\n\t    if not c[\"currentscape\"][\"legacy_method\"] or c[\"pattern\"][\"use\"]:\n\t        rows_tot += 1\n\t    if c[\"show\"][\"all_currents\"]:\n", "        rows_tot += 2\n\t    if ions.data is not None:\n\t        rows_tot += 1\n\t    if c[\"show\"][\"total_contribution\"]:\n\t        rows_tot += 2\n\t    return rows_tot\n\tdef get_colors_hatches_lines_lists(c, curr_idxs, cmap, mapper=None):\n\t    \"\"\"Get colors and hatches and lines lists from color indexes list.\n\t    Args:\n\t        c (dict): config\n", "        curr_idxs (ndarray of ints or int): list of indexes of currents\n\t        cmap (matplotlib.colors.Colormap): colormap\n\t        mapper (int): number used to mix colors and patterns\n\t    \"\"\"\n\t    if c[\"pattern\"][\"use\"]:\n\t        n_colors = c[\"colormap\"][\"n_colors\"]\n\t        patterns = np.array(\n\t            [x * c[\"pattern\"][\"density\"] for x in c[\"pattern\"][\"patterns\"]]\n\t        )\n\t        ls = np.array(c[\"line\"][\"styles\"], dtype=object)\n", "        colors = cmap(map_colors(curr_idxs, n_colors, mapper))\n\t        hatches = patterns[map_patterns(curr_idxs, n_colors, len(patterns), mapper)]\n\t        lines = ls[map_patterns(curr_idxs, n_colors, len(ls), mapper)]\n\t    else:\n\t        colors = cmap(curr_idxs)\n\t        hatches = None\n\t        lines = \"solid\"\n\t        if not np.isscalar(curr_idxs):\n\t            lines = np.full(curr_idxs.size, \"solid\")\n\t    return colors, hatches, lines\n", "def stackplot_with_bars(\n\t    ax,\n\t    cnorm,\n\t    inames,\n\t    cmap,\n\t    c,\n\t    N_curr,\n\t    mapper=None,\n\t    top_to_bottom=True,\n\t):\n", "    \"\"\"Plot currentscape using bars instead of imshow.\n\t    That way, hatches (patterns) can be used.\n\t    Args:\n\t        ax (matplotlib.axes): currentscape axis\n\t        cnorm (DataSet): object containing data (e.g. currents data and idxs)\n\t        inames (ndarray of ints): indexes to new name order (new_names = names[inames])\n\t        cmap (matplotlib.colors.Colormap): colormap\n\t        c (dict): config\n\t        N_curr (int): total number of currents\n\t        mapper (int): number used to mix colors and patterns\n", "        top_to_bottom (bool): if True, plot from top to bottom. if False, plot from bottom to top\n\t    Returns the size modified by sum chunks (reduced x resolution)\n\t    \"\"\"\n\t    chunksize = c[\"stackplot\"][\"x_chunksize\"]\n\t    currs = sum_chunks(np.abs(cnorm.data), chunksize)  # reduce data x resolution\n\t    imap = np.zeros(N_curr, dtype=int)\n\t    imap[inames] = np.arange(N_curr)\n\t    size = len(currs[0])\n\t    step = float(cnorm.time[-1] - cnorm.time[0]) / size\n\t    x = np.arange(cnorm.time[0], cnorm.time[-1], step)\n", "    if top_to_bottom:\n\t        # stack from the top to bottom, like in create_cscape_image func.\n\t        bottom = np.ones(size)\n\t    else:\n\t        bottom = np.zeros(size)\n\t    for idx, curr in zip(cnorm.idxs, currs):\n\t        if not np.all(curr == 0):\n\t            color, hatch, _ = get_colors_hatches_lines_lists(c, imap[idx], cmap, mapper)\n\t            if top_to_bottom:\n\t                bottom -= curr\n", "            ax.bar(\n\t                x,\n\t                curr,\n\t                color=color,\n\t                edgecolor=c[\"pattern\"][\"color\"],\n\t                linewidth=0,  # do not draw edges\n\t                width=step,  # fill all the space between two bars\n\t                hatch=hatch,\n\t                bottom=bottom,\n\t                align=\"edge\",  # Align the left edges of the bars with the x positions.\n", "                zorder=2,\n\t            )\n\t            if not top_to_bottom:\n\t                bottom += curr\n\tdef stackplot_with_fill_between(\n\t    ax,\n\t    cnorm,\n\t    inames,\n\t    cmap,\n\t    c,\n", "    N_curr,\n\t    mapper=None,\n\t    top_to_bottom=True,\n\t):\n\t    \"\"\"Plot currentscape using fill_between.\n\t    Args:\n\t        ax (matplotlib.axes): currentscape axis\n\t        cnorm (DataSet): object containing data (e.g. currents data and idxs)\n\t        inames (ndarray of ints): indexes to new name order (new_names = names[inames])\n\t        cmap (matplotlib.colors.Colormap): colormap\n", "        c (dict): config\n\t        N_curr (int): total number of currents\n\t        mapper (int): number used to mix colors and patterns\n\t        top_to_bottom (bool): if True, plot from top to bottom. if False, plot from bottom to top\n\t    \"\"\"\n\t    currs = np.abs(cnorm.data)\n\t    imap = np.zeros(N_curr, dtype=int)\n\t    imap[inames] = np.arange(N_curr)\n\t    if top_to_bottom:\n\t        # stack from the top to bottom, like in create_cscape_image func.\n", "        bottom = np.ones(cnorm.x_size)\n\t    else:\n\t        bottom = np.zeros(cnorm.x_size)\n\t    curr_stack = np.copy(bottom)\n\t    for idx, curr in zip(cnorm.idxs, currs):\n\t        if not np.all(curr == 0):\n\t            color, hatch, _ = get_colors_hatches_lines_lists(c, imap[idx], cmap, mapper)\n\t            if top_to_bottom:\n\t                curr_stack = np.copy(bottom)\n\t                bottom -= curr\n", "            else:\n\t                curr_stack += curr\n\t            ax.fill_between(\n\t                cnorm.time,\n\t                curr_stack,\n\t                bottom,\n\t                color=color,\n\t                edgecolor=c[\"pattern\"][\"color\"],\n\t                lw=0.0,\n\t                hatch=hatch,\n", "                zorder=2,\n\t            )\n\t            if not top_to_bottom:\n\t                bottom = np.copy(curr_stack)\n\tdef black_line_log_scale(ax, ylim, xlim, bl_thickness):\n\t    \"\"\"Produce a black line meant to distinguish between 2 plots in log scales.\n\t    The black line is plotted at the bottom of the upper plot.\n\t    This is a trick to avoid frames masking some of the data.\n\t    Args:\n\t        ax (matplotlib.axes): currentscape axis\n", "        ylim (list of 2 floats): limits of the y axis\n\t        xlim (list of 2 floats): limits of the x axis\n\t        bl_thickness (float): thickness of the black line separating the two plots,\n\t            in percentage of the y axis size\n\t    Returns ylim, because the bottom y limit is changing by adding the black line.\n\t    \"\"\"\n\t    # should produce a black line with a thickness approaching\n\t    # the one in the currentscape (non log scale) black line\n\t    percent_to_log = abs(ylim[1] / ylim[0]) ** (bl_thickness / 64.0)\n\t    y_bottom = ylim[0] / (percent_to_log)\n", "    ax.fill_between(\n\t        xlim,\n\t        [y_bottom, y_bottom],\n\t        [ylim[0], ylim[0]],\n\t        color=\"black\",\n\t        lw=0,\n\t        zorder=3,\n\t    )\n\t    ylim[0] = y_bottom\n\t    return ylim\n", "def remove_ticks_and_frame(ax):\n\t    \"\"\"Remove ticks (but not ytick label) and frame.\n\t    Args:\n\t        ax (matplotlib.axes): axis\n\t    \"\"\"\n\t    ax.tick_params(\n\t        axis=\"x\",  # changes apply to the x-axis\n\t        which=\"both\",  # both major and minor ticks are affected\n\t        bottom=False,  # ticks along the bottom edge are off\n\t        top=False,  # ticks along the top edge are off\n", "        labelbottom=False,  # labels along the bottom edge are off\n\t    )\n\t    ax.tick_params(\n\t        axis=\"y\",  # changes apply to the x-axis\n\t        which=\"both\",  # both major and minor ticks are affected\n\t        left=False,  # ticks along the left edge are off\n\t        right=False,  # ticks along the right edge are off\n\t        pad=0,\n\t    )\n\t    ax.spines[\"top\"].set_visible(False)\n", "    ax.spines[\"right\"].set_visible(False)\n\t    ax.spines[\"bottom\"].set_visible(False)\n\t    ax.spines[\"left\"].set_visible(False)\n\tdef remove_ticks_and_frame_for_bar_plot(ax):\n\t    \"\"\"Remove all ticks (including ytick label) and top & bottom frames.\n\t    Args:\n\t        ax (matplotlib.axes): axis\n\t    \"\"\"\n\t    ax.tick_params(\n\t        axis=\"x\",  # changes apply to the x-axis\n", "        which=\"both\",  # both major and minor ticks are affected\n\t        bottom=False,  # ticks along the bottom edge are off\n\t        top=False,  # ticks along the top edge are off\n\t        labelbottom=False,  # labels along the bottom edge are off\n\t    )\n\t    ax.tick_params(\n\t        axis=\"y\",  # changes apply to the x-axis\n\t        which=\"both\",  # both major and minor ticks are affected\n\t        left=False,  # ticks along the left edge are off\n\t        right=False,  # ticks along the right edge are off\n", "        labelleft=False,  # labels along left edge are off\n\t    )\n\t    ax.spines[\"top\"].set_visible(False)\n\t    ax.spines[\"bottom\"].set_visible(False)\n\tdef adjust(adjust_left, adjust_right, adjust_top, adjust_bottom):\n\t    \"\"\"Adjust Subplots.\n\t    Args:\n\t        adjust_left (float or None): position of the left edge of the subplots,\n\t            None to use matplotlib default\n\t        adjust_right (float or None): position of the right edge of the subplots,\n", "            None ot use matplotlib default\n\t        adjust_top (float or None): position of the top edge of the subplots,\n\t            None to use matplotlib default\n\t        adjust_bottom (float or None): position of the bottom edge of the subplots,\n\t            None to use matplotlib default\n\t    \"\"\"\n\t    plt.subplots_adjust(wspace=0, hspace=0)\n\t    if adjust_left is not None:\n\t        plt.subplots_adjust(left=adjust_left)\n\t    if adjust_right is not None:\n", "        plt.subplots_adjust(right=adjust_right)\n\t    if adjust_top is not None:\n\t        plt.subplots_adjust(top=adjust_top)\n\t    if adjust_bottom is not None:\n\t        plt.subplots_adjust(bottom=adjust_bottom)\n\tdef set_label(ax, x, y, label, textsize):\n\t    \"\"\"Set text as label on the y axis.\n\t    Args:\n\t        ax (matplotlib.axes): axis\n\t        x (float): x position of the label\n", "        y (float): y position of the label\n\t        label (str): text to be displayed as label\n\t        textsize (int): text size in pixels\n\t    \"\"\"\n\t    ax.text(\n\t        x,\n\t        y,\n\t        label,\n\t        horizontalalignment=\"right\",\n\t        verticalalignment=\"center\",\n", "        rotation=\"vertical\",\n\t        size=textsize,\n\t    )\n\tdef show_xgridlines(ax, c, xticks, ylim=None):\n\t    \"\"\"Show vertical gridlines corresponding to the x ticks.\n\t    Args:\n\t        ax (matplotlib.axes): axis\n\t        c (dict): config\n\t        xticks (list): tick positions on the x axis\n\t        ylim (list of 2 floats): limits of y axis\n", "    \"\"\"\n\t    lw = c[\"xaxis\"][\"gridline_width\"]\n\t    ls = c[\"xaxis\"][\"gridline_style\"]\n\t    color = c[\"xaxis\"][\"gridline_color\"]\n\t    # plot on top of everything else\n\t    ax.vlines(xticks, ylim[0], ylim[1], lw=lw, color=color, zorder=5, ls=ls)\n\tdef apply_labels_ticks_and_lims(\n\t    ax, c, xticks, xlim, ylim, positive=True, config_key=\"current\"\n\t):\n\t    \"\"\"Apply labels, ticks, xlim and ylim to current / ion concentration plots.\n", "    Args:\n\t        ax (matplotlib.axes): currentscape axis\n\t        c (dict): config\n\t        xticks (list): tick positions on the x axis\n\t        xlim (list of 2 floats): limits of x axis\n\t        ylim (list of 2 floats): limits of y axis (can be different from ylim from config)\n\t        positive (bool): True for positive data, False for negative data\n\t        config_key (str): key for getting data from config. Should be 'current' or 'ions'\n\t    \"\"\"\n\t    # plot the horizontal dotted lines\n", "    for tick in c[config_key][\"ticks\"]:\n\t        ax.axhline(tick, color=\"black\", ls=\":\", lw=1, zorder=1)\n\t    ax.set_yscale(\"log\")\n\t    # labels\n\t    if c[\"show\"][\"ylabels\"]:\n\t        if positive:\n\t            ax.set_ylabel(c[config_key][\"units\"], labelpad=c[\"labelpad\"])\n\t        else:\n\t            ax.set_ylabel(\"-\" + c[config_key][\"units\"], labelpad=c[\"labelpad\"])\n\t    # ticks\n", "    if c[\"show\"][\"yticklabels\"]:\n\t        ax.set_yticks(c[config_key][\"ticks\"])\n\t        ax.get_yaxis().set_major_formatter(matplotlib.ticker.FormatStrFormatter(\"%g\"))\n\t        ax.get_yaxis().set_minor_formatter(matplotlib.ticker.NullFormatter())\n\t    remove_ticks_and_frame(ax)\n\t    # show x axis gridline\n\t    if c[\"show\"][\"xgridlines\"]:\n\t        show_xgridlines(ax, c, xticks, ylim)\n\t    # somehow, set_ylim is not taken into account if it is set before set_yticks\n\t    ax.set_xlim(xlim)\n", "    if positive:\n\t        ax.set_ylim(ylim[0], ylim[1])\n\t    else:\n\t        ax.set_ylim(ylim[1], ylim[0])\n\tdef plot_x_labels(ax, c, xticks):\n\t    \"\"\"Plot x labels and x ticklabels.\n\t    Args:\n\t        ax (matplotlib.axes): axis\n\t        c (dict): config\n\t        xticks (list): tick positions on the x axis\n", "    \"\"\"\n\t    if c[\"show\"][\"xlabels\"]:\n\t        ax.set_xlabel(c[\"xaxis\"][\"units\"], labelpad=c[\"labelpad\"])\n\t    if c[\"show\"][\"xticklabels\"]:\n\t        # enable label bottom\n\t        ax.tick_params(\n\t            axis=\"x\",  # changes apply to the x-axis\n\t            which=\"both\",  # both major and minor ticks are affected\n\t            pad=0,\n\t            labelbottom=True,\n", "        )\n\t        ax.set_xticks(xticks)\n\t        ax.get_xaxis().set_major_formatter(matplotlib.ticker.FormatStrFormatter(\"%g\"))\n\tdef select_color(cmap, i, N_col):\n\t    \"\"\"Select color of the ith element when not using patterns.\n\t    There is a +2 in the formula to account for the black and white in colormap.\n\t    Args:\n\t        cmap (matplotlib.colors.Colormap): colormap\n\t        i (int): index of element (current/ion)\n\t        N_col (int): total number of elements\n", "    \"\"\"\n\t    return cmap(i / float(N_col + 2))\n\tdef get_colors(cmap, n_col):\n\t    \"\"\"Get colors from colormap, depending on maximum number of colors.\n\t    Args:\n\t        cmap (str): colormap name\n\t        n_col (int): number of colors to extract\n\t    Returns:\n\t        a list of matplotlib colors\n\t        launch_warning (bool): True to warn that colormap lacks colors\n", "    \"\"\"\n\t    # is from palettable module\n\t    if \".\" in cmap:\n\t        x = pltb\n\t        # we want to retrieve e.g. pltb.cartocolors.qualitative.Antique_8.mpl_colors\n\t        # from string \"cartocolors.qualitative.Antique_8\"\n\t        for attr in cmap.split(\".\"):\n\t            x = getattr(x, attr)\n\t        # if colormap lacks colors\n\t        if len(x.mpl_colors) < n_col:\n", "            return (\n\t                list(x.mpl_colormap(np.array(range(n_col)) / float(n_col))),\n\t                True,\n\t            )\n\t        return x.mpl_colors[:n_col], False\n\t    # is from matplotlib\n\t    new_cmap = matplotlib.cm.get_cmap(cmap, n_col)\n\t    # check number of colors\n\t    if matplotlib.cm.get_cmap(cmap).N < n_col:\n\t        return list(new_cmap(range(n_col))), True\n", "    return list(new_cmap(range(n_col))), False\n\tdef get_colormap(cmap, n_colors, use_patterns, N_curr, N_ion):\n\t    \"\"\"Get colormap according to input, and add black then white colors at the end.\n\t    The black color is used to create a black line separating currentscapes plots,\n\t    and the white color is used when there is no data (e.g. no inward or outward current).\n\t    Args:\n\t        cmap (str): colormap name\n\t        n_colors (int): number of colors to extract IF use_patterns and n_colors>N_curr\n\t        use_patterns (bool): True if currentscape plot uses bars and mixes color and pattern\n\t        N_curr (int): number of currents\n", "        N_ion (int): number of ion concentrations\n\t    \"\"\"\n\t    # choose the right number of colors for the colormap\n\t    if N_ion is not None and N_ion > N_curr:\n\t        N_max = N_ion\n\t    else:\n\t        N_max = N_curr\n\t    if use_patterns and N_max > n_colors:\n\t        N_colormap = n_colors\n\t    else:\n", "        N_colormap = N_max\n\t    # get colors from colormap\n\t    colors, launch_warning = get_colors(cmap, N_colormap)\n\t    # append black, for black line separating currentscapes\n\t    colors.append(np.array([0.0, 0.0, 0.0, 1.0]))\n\t    # append white. default color when there is no current.\n\t    colors.append(np.array([1.0, 1.0, 1.0, 1.0]))\n\t    # display warning if the colormap lacks colors\n\t    if launch_warning:\n\t        if use_patterns:\n", "            logger.warning(\n\t                \"'n_colors' in 'colormap' in config is larger than \"\n\t                \"the number of colors in the colormap. \"\n\t                \"Please, choose a colormap with more colors \"\n\t                \"or decrease n_colors for optimal display.\"\n\t            )\n\t        else:\n\t            logger.warning(\n\t                \"The number of colors in the colormap \"\n\t                \"is smaller than the number of currents. \"\n", "                \"Please, choose a colormap with more colors \"\n\t                \"or use patterns for optimal display.\"\n\t            )\n\t    return matplotlib.colors.ListedColormap(colors)\n\tdef save_figure(fig, c):\n\t    \"\"\"Save figure in output according to config file.\n\t    Args:\n\t        fig (matplotlib.figure.Figure): figure\n\t        c (dict): config\n\t    \"\"\"\n", "    Path(c[\"output\"][\"dir\"]).mkdir(parents=True, exist_ok=True)\n\t    out_path = (\n\t        f\"{Path(c['output']['dir']) / c['output']['fname']}.{c['output']['extension']}\"\n\t    )\n\t    fig.savefig(\n\t        out_path, dpi=c[\"output\"][\"dpi\"], transparent=c[\"output\"][\"transparent\"]\n\t    )\n"]}
{"filename": "currentscape/__init__.py", "chunked_list": ["\"\"\"Currentscape.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\tfrom currentscape.currentscape import plot_currentscape as plot\n"]}
{"filename": "currentscape/legends.py", "chunked_list": ["\"\"\"Legends related functions.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\t# pylint: disable=wrong-import-position\n\timport matplotlib\n\tmatplotlib.use(\"agg\")  # to avoid tkinter error\n\tfrom matplotlib.legend_handler import HandlerTuple\n\tfrom currentscape.mapper import map_colors\n\tfrom currentscape.plotting import get_colors_hatches_lines_lists, select_color\n\tdef base_legend(\n\t    ax, curr_names, bg_color, ypos, idx_names=None, handlelength=None, lines=False\n\t):\n", "    \"\"\"Returns a legend with all current names.\n\t    Args:\n\t        ax (matplotlib.axes): currentscape axis\n\t        curr_names (list of str): legend labels / current names\n\t        bg_color (color): background color for legend box\n\t        ypos (float): y-axis position of legend box. 1 is top of axis.\n\t        idx_names (ndarray of ints): indexes to new name order (new_names = names[idx_names])\n\t        handlelength (float): size of the handles.\n\t            Takes default value if None. No handles displayed if 0.\n\t        lines (bool): if True, get lines as handles. if False, get patches as handles.\n", "    \"\"\"\n\t    if idx_names is None:\n\t        idx_names = range(len(curr_names))\n\t    # create a patch (proxy artist) or a line for every current\n\t    if lines:\n\t        handles = [\n\t            matplotlib.lines.Line2D([], [], label=curr_names[i]) for i in idx_names\n\t        ]\n\t    else:\n\t        handles = [matplotlib.patches.Patch(label=curr_names[i]) for i in idx_names]\n", "    # put those patched as legend-handles into the legend\n\t    leg = ax.legend(\n\t        handles=handles,\n\t        bbox_to_anchor=(1.01, ypos),\n\t        loc=2,\n\t        borderaxespad=0.0,\n\t        facecolor=bg_color,\n\t        edgecolor=\"black\",\n\t        fancybox=False,  # disable round edges\n\t        handlelength=handlelength,\n", "    )\n\t    leg.get_frame().set_linewidth(0.5)  # set border thickness\n\t    return leg\n\tdef set_legend(ax, cmap, curr_names, bg_color, ypos, idx_names=None, handlelength=0):\n\t    \"\"\"Set each current name color-coded in legend.\n\t    Args:\n\t        ax (matplotlib.axes): currentscape axis\n\t        cmap (matplotlib.colors.Colormap): colormap\n\t        curr_names (list of str): legend labels / current names\n\t        bg_color (color): background color for legend box\n", "        ypos (float): y-axis position of legend box. 1 is top of axis.\n\t        idx_names (ndarray of ints): indexes to new name order (new_names = names[idx_names])\n\t        handlelength (float): size of the handles.\n\t            Takes default value if None. No handles displayed if 0.\n\t    \"\"\"\n\t    leg = base_legend(ax, curr_names, bg_color, ypos, idx_names, handlelength)\n\t    # set legend label color & boldness\n\t    for i_color, text in enumerate(leg.texts):\n\t        # + 2 because there is black and white at the end of cmap\n\t        text.set_color(select_color(cmap, i_color, len(curr_names)))\n", "        text.set_weight(\"bold\")\n\tdef set_legend_with_hatches(ax, cmap, mapper, c, idx_names):\n\t    \"\"\"Create legend and color each current name, and set handles color and pattern.\n\t    Args:\n\t        ax (matplotlib.axes): currentscape axis\n\t        cmap (matplotlib.colors.Colormap): colormap\n\t        mapper (int): number used to mix color and patterns\n\t        c (dict): config\n\t        idx_names (ndarray of ints): indexes to new name order (new_names = names[idx_names])\n\t    \"\"\"\n", "    curr_names = c[\"current\"][\"names\"]\n\t    bg_color = c[\"legend\"][\"bgcolor\"]\n\t    ypos = c[\"legend\"][\"ypos\"]\n\t    leg = base_legend(ax, curr_names, bg_color, ypos, idx_names)\n\t    # set legend label color & boldness, and handles color&pattern\n\t    for i_color, (text, handle) in enumerate(zip(leg.texts, leg.legendHandles)):\n\t        color, hatch, _ = get_colors_hatches_lines_lists(c, i_color, cmap, mapper)\n\t        text.set_color(color)\n\t        text.set_weight(\"bold\")\n\t        handle.set_facecolor(color)\n", "        handle.set_hatch(hatch)\n\tdef set_legend_with_lines(ax, cmap, mapper, c, idx_names, names):\n\t    \"\"\"Create legend and color each current name, and set handles color and pattern.\n\t    Args:\n\t        ax (matplotlib.axes): currentscape axis\n\t        cmap (matplotlib.colors.Colormap): colormap\n\t        mapper (int): number used to mix color and patterns\n\t        c (dict): config\n\t        idx_names (ndarray of ints): indexes to new name order (new_names = names[idx_names])\n\t        names (list of str): legend labels\n", "    \"\"\"\n\t    bg_color = c[\"legend\"][\"bgcolor\"]\n\t    ypos = c[\"legend\"][\"ypos\"]\n\t    leg = base_legend(ax, names, bg_color, ypos, idx_names, lines=True)\n\t    # set legend label color & boldness, and handles color&pattern\n\t    lw = c[\"lw\"]\n\t    for i_color, (text, handle) in enumerate(zip(leg.texts, leg.legendHandles)):\n\t        color, _, line = get_colors_hatches_lines_lists(c, i_color, cmap, mapper)\n\t        text.set_color(color)\n\t        text.set_weight(\"bold\")\n", "        handle.set_color(color)\n\t        handle.set_linestyle(line)\n\t        handle.set_linewidth(lw)\n\tdef get_handles_with_hatches_and_linestyles(c, cmap, mapper, N_curr):\n\t    \"\"\"Return handles as a list of tuples (patch, line).\n\t    With patch showing color and hatch and line showing the linestyle.\n\t    Args:\n\t        c (dict): config\n\t        cmap (matplotlib.colors.Colormap): colormap\n\t        mapper (int): number used to mix color and patterns\n", "        N_curr (int): number of currents\n\t    \"\"\"\n\t    lw = c[\"lw\"]\n\t    # create a patch (proxy artist) for every current\n\t    handles = []\n\t    for i in range(N_curr):\n\t        color, hatch, line = get_colors_hatches_lines_lists(c, i, cmap, mapper)\n\t        handles.append(\n\t            (\n\t                matplotlib.patches.Patch(facecolor=color, hatch=hatch),\n", "                matplotlib.lines.Line2D([], [], color=color, ls=line, lw=lw),\n\t            )\n\t        )\n\t    return handles\n\tdef set_legend_with_hatches_and_linestyles(ax, cmap, mapper, c, idx_names):\n\t    \"\"\"Create legend and color each current name, and set handles color and pattern.\n\t    Args:\n\t        ax (matplotlib.axes): currentscape axis\n\t        cmap (matplotlib.colors.Colormap): colormap\n\t        mapper (int): number used to mix color and patterns\n", "        c (dict): config\n\t        idx_names (ndarray of ints): indexes to new name order (new_names = names[idx_names])\n\t    \"\"\"\n\t    bg_color = c[\"legend\"][\"bgcolor\"]\n\t    ypos = c[\"legend\"][\"ypos\"]\n\t    curr_names = c[\"current\"][\"names\"]\n\t    n_col = c[\"colormap\"][\"n_colors\"]\n\t    handlelength = c[\"legend\"][\"handlelength\"]\n\t    handles = get_handles_with_hatches_and_linestyles(c, cmap, mapper, len(idx_names))\n\t    # put those patched as legend-handles into the legend\n", "    leg = ax.legend(\n\t        handles=handles,\n\t        labels=[curr_names[i] for i in idx_names],\n\t        bbox_to_anchor=(1.01, ypos),\n\t        loc=2,\n\t        borderaxespad=0.0,\n\t        facecolor=bg_color,\n\t        edgecolor=\"black\",\n\t        fancybox=False,  # disable round edges\n\t        handler_map={tuple: HandlerTuple(ndivide=None, pad=0.2)},\n", "        handlelength=2 * handlelength,\n\t    )\n\t    leg.get_frame().set_linewidth(0.5)  # set border thickness\n\t    # set legend label color & boldness, and handles color&pattern\n\t    for i_color, text in enumerate(leg.texts):\n\t        text.set_color(cmap(map_colors(i_color, n_col, mapper)))\n\t        text.set_weight(\"bold\")\n"]}
{"filename": "currentscape/config_parser.py", "chunked_list": ["\"\"\"Config-related functions.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\t# pylint: disable=too-many-statements, too-many-locals\n\timport logging\n\timport json\n\tlogger = logging.getLogger(__name__)\n\tdef check_config(c):\n\t    \"\"\"Output a warning if something is wrong with the config.\n\t    Args:\n\t        c (dict): config\n\t    \"\"\"\n", "    if (\n\t        c[\"pattern\"][\"use\"]\n\t        and c[\"show\"][\"all_currents\"]\n\t        and len(c[\"line\"][\"styles\"]) != len(c[\"pattern\"][\"patterns\"])\n\t    ):\n\t        logger.warning(\"line:styles should have as many items as pattern:patterns.\")\n\tdef replace_defaults(config, new_config):\n\t    \"\"\"Recursive fct. Replace defaults value with user input.\n\t    Args:\n\t        config (dict): default config\n", "        new_config (dict): dict containing config items to be updated\n\t    \"\"\"\n\t    for key, item in new_config.items():\n\t        if isinstance(item, dict):\n\t            item = replace_defaults(config[key], item)\n\t        config[key] = item\n\t    return config\n\tdef set_default_config(c):\n\t    \"\"\"Set non-specified values in config to default.\n\t    Args:\n", "        c (str or dict): config dict or path to json config.\n\t            values from c are added or replace those from default config.\n\t    \"\"\"\n\t    if c is None:\n\t        c = {}\n\t    elif isinstance(c, str):\n\t        with open(c, \"r\", encoding=\"utf-8\") as f:\n\t            c = json.load(f)\n\t    config = {}\n\t    show = {}\n", "    show[\"currentscape\"] = True\n\t    show[\"ylabels\"] = True\n\t    show[\"yticklabels\"] = True\n\t    show[\"xlabels\"] = False\n\t    show[\"xticklabels\"] = False\n\t    show[\"xgridlines\"] = False\n\t    show[\"legend\"] = True\n\t    show[\"all_currents\"] = False\n\t    show[\"total_contribution\"] = False\n\t    config[\"show\"] = show\n", "    current = {}\n\t    # if True, reorder currents with decreasing order of %.\n\t    current[\"reorder\"] = True\n\t    # if True, do not take into account ticks and ylim below.\n\t    current[\"autoscale_ticks_and_ylim\"] = True\n\t    # only taken into account if autoscale_ticks_and_ylim is False\n\t    current[\"ticks\"] = [5, 50, 500]\n\t    # only taken into account if autoscale_ticks_and_ylim is False\n\t    current[\"ylim\"] = (0.01, 1500)\n\t    current[\"units\"] = \"[pA]\"\n", "    # color for summed currents.\n\t    current[\"color\"] = \"black\"\n\t    # True to plot absolute currents with stackplots, False to plot them with lines\n\t    current[\"stackplot\"] = False\n\t    current[\"names\"] = None\n\t    # thickness of black line\n\t    # separating the two inward & outward currentscapes / current stackplot.\n\t    # in %age of y size of plot.\n\t    current[\"black_line_thickness\"] = 2\n\t    current[\"legacy_method\"] = False\n", "    config[\"current\"] = current\n\t    currentscape = {}\n\t    currentscape[\"in_label\"] = \"inward %\"\n\t    currentscape[\"out_label\"] = \"outward %\"\n\t    # Used with imshow.\n\t    # if too low, white pixels can appear at the bottom of currentscape plots\n\t    # because of rounding errors.\n\t    currentscape[\"y_resolution\"] = 10000\n\t    currentscape[\"legacy_method\"] = False\n\t    config[\"currentscape\"] = currentscape\n", "    ions = {}\n\t    ions[\"autoscale_ticks_and_ylim\"] = True\n\t    ions[\"ticks\"] = [0.0005, 0.05, 5]\n\t    ions[\"ylim\"] = (0.00001, 100)\n\t    ions[\"units\"] = \"[mM]\"\n\t    ions[\"reorder\"] = True\n\t    ions[\"names\"] = None\n\t    config[\"ions\"] = ions\n\t    colormap = {}\n\t    colormap[\"name\"] = \"Set1\"\n", "    # color number. Taken into account only if pattern use is True\n\t    colormap[\"n_colors\"] = 8\n\t    config[\"colormap\"] = colormap\n\t    # data along x axis are summed up into chunks when pattern use is True. Put to 1 to disable.\n\t    config[\"stackplot\"] = {\"x_chunksize\": 50}\n\t    pattern = {}\n\t    pattern[\"use\"] = False\n\t    pattern[\"patterns\"] = [\"\", \"/\", \"\\\\\", \"x\", \".\", \"o\", \"+\"]\n\t    pattern[\"density\"] = 5\n\t    pattern[\"linewidth\"] = 0.2\n", "    # since the pattern color is defined by the edgecolor,\n\t    # this parameter also changes the edgecolor of the pie charts\n\t    pattern[\"color\"] = \"black\"\n\t    config[\"pattern\"] = pattern\n\t    # is used when pattern:use and show:all_currents are True and current:stackplot is False\n\t    # Should have the same length as pattern:patterns\n\t    line = {\n\t        \"styles\": [\n\t            \"solid\",\n\t            (0, (1, 1)),\n", "            (0, (2, 1)),\n\t            (0, (2, 1, 1, 1)),\n\t            (0, (2, 1, 1, 1, 1, 1)),\n\t            (0, (2, 1, 2, 1, 1, 1)),\n\t            (0, (2, 1, 2, 1, 1, 1, 1, 1)),\n\t        ]\n\t    }\n\t    config[\"line\"] = line\n\t    voltage = {}\n\t    voltage[\"ticks\"] = (-50, -20)\n", "    voltage[\"ylim\"] = (-90, 30)\n\t    voltage[\"units\"] = \"[mV]\"\n\t    voltage[\"color\"] = \"black\"\n\t    voltage[\"horizontal_lines\"] = True\n\t    config[\"voltage\"] = voltage\n\t    xaxis = {}\n\t    xaxis[\"units\"] = \"[ms]\"\n\t    # if None, xticks are generated automatically. Can put a list of xticks to force custom xticks.\n\t    xaxis[\"xticks\"] = None\n\t    xaxis[\"gridline_width\"] = 1\n", "    xaxis[\"gridline_color\"] = \"black\"\n\t    xaxis[\"gridline_style\"] = \"--\"\n\t    config[\"xaxis\"] = xaxis\n\t    output = {}\n\t    output[\"savefig\"] = False\n\t    output[\"dir\"] = \".\"\n\t    output[\"fname\"] = \"fig\"\n\t    output[\"extension\"] = \"pdf\"\n\t    output[\"dpi\"] = 400\n\t    output[\"transparent\"] = False\n", "    config[\"output\"] = output\n\t    legend = {}\n\t    legend[\"textsize\"] = 4\n\t    legend[\"bgcolor\"] = \"lightgrey\"\n\t    # 1. : top of legend is at the same level as top of currentscape plot.\n\t    # higher value put legend higher in figure.\n\t    legend[\"ypos\"] = 1.0\n\t    # forced to 0 if pattern:use is False and current:stackplot is False\n\t    legend[\"handlelength\"] = 1.4\n\t    config[\"legend\"] = legend\n", "    adjust_ = {}\n\t    adjust_[\"left\"] = 0.15\n\t    adjust_[\"right\"] = 0.85\n\t    adjust_[\"top\"] = 0.95\n\t    adjust_[\"bottom\"] = 0.0\n\t    config[\"adjust\"] = adjust_\n\t    config[\"title\"] = None\n\t    config[\"figsize\"] = (3, 4)\n\t    config[\"labelpad\"] = 1\n\t    config[\"textsize\"] = 6\n", "    config[\"titlesize\"] = 12\n\t    config[\"lw\"] = 0.5\n\t    new_config = replace_defaults(config, c)\n\t    # for compatibility with older versions\n\t    if \"cmap\" in new_config[\"currentscape\"]:\n\t        new_config[\"colormap\"][\"name\"] = new_config[\"currentscape\"][\"cmap\"]\n\t    if \"legendtextsize\" in new_config:\n\t        new_config[\"legend\"][\"textsize\"] = new_config[\"legendtextsize\"]\n\t    if \"legendbgcolor\" in config:\n\t        new_config[\"legend\"][\"bgcolor\"] = new_config[\"legendbgcolor\"]\n", "    if \"x_chunksize\" in new_config[\"currentscape\"]:\n\t        new_config[\"stackplot\"][\"x_chunksize\"] = new_config[\"currentscape\"][\n\t            \"x_chunksize\"\n\t        ]\n\t    if \"black_line_thickness\" in new_config[\"currentscape\"]:\n\t        new_config[\"current\"][\"black_line_thickness\"] = new_config[\"currentscape\"][\n\t            \"black_line_thickness\"\n\t        ]\n\t    if \"labels\" in new_config[\"show\"]:\n\t        new_config[\"show\"][\"ylabels\"] = new_config[\"show\"][\"labels\"]\n", "    if \"ticklabels\" in new_config[\"show\"]:\n\t        new_config[\"show\"][\"yticklabels\"] = new_config[\"show\"][\"ticklabels\"]\n\t    check_config(new_config)\n\t    return new_config\n"]}
{"filename": "currentscape/ions.py", "chunked_list": ["\"\"\"Ion concentrations class.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\t# pylint: disable=wrong-import-position, super-with-arguments\n\timport numpy as np\n\timport matplotlib\n\tmatplotlib.use(\"agg\")  # to avoid tkinter error\n\timport matplotlib.pyplot as plt\n\tfrom currentscape.datasets import DataSet\n\tfrom currentscape.data_processing import reorder\n\tfrom currentscape.plotting import (\n\t    get_colors_hatches_lines_lists,\n", "    apply_labels_ticks_and_lims,\n\t    select_color,\n\t)\n\tfrom currentscape.legends import (\n\t    set_legend,\n\t    set_legend_with_lines,\n\t)\n\tfrom currentscape.mapper import create_mapper\n\tclass IonConcentrations(DataSet):\n\t    \"\"\"Class containing ion concentrations data.\"\"\"\n", "    def __init__(self, data, c, time=None):\n\t        \"\"\"Constructor.\n\t        Args:\n\t            data (list of lists): data\n\t                all lists are expected to have the same size.\n\t            c (dict): config\n\t            time (list): time of the data\n\t        Attributes:\n\t            mapper (int): number used to mix colors and patterns / linestyles\n\t        \"\"\"\n", "        reorder_ = c[\"ions\"][\"reorder\"]\n\t        use_patterns = c[\"pattern\"][\"use\"]\n\t        n_patterns = len(c[\"pattern\"][\"patterns\"])\n\t        super(IonConcentrations, self).__init__(\n\t            data=data, names=c[\"ions\"][\"names\"], time=time, xticks=c[\"xaxis\"][\"xticks\"]\n\t        )\n\t        self.mapper = None\n\t        if self.data is not None:\n\t            if reorder_:\n\t                _, self.idxs = reorder(self.data)\n", "            if use_patterns:\n\t                n_colors = min([c[\"colormap\"][\"n_colors\"], self.N])\n\t                self.mapper = create_mapper(n_colors, n_patterns)\n\t    def plot_with_linestyles(self, c, row, rows_tot, cmap):\n\t        \"\"\"Plot all the ion concentration with linestyles.\n\t        Args:\n\t            c (dict): config\n\t            row (int): row of subplot\n\t            rows_tot (int): total number of subplots in the figure\n\t            cmap (matplotlib.colors.Colormap): colormap\n", "        \"\"\"\n\t        lw = c[\"lw\"]\n\t        ylim = list(c[\"ions\"][\"ylim\"])\n\t        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=1)\n\t        x = np.arange(self.x_size)\n\t        # here, use currs.idxs to have the same colors as in currs.names\n\t        # can do it because selected_currs have same shape as self (no zero arrays removed)\n\t        for i, ion in enumerate(self.data[self.idxs]):\n\t            if not np.all(ion == 0):\n\t                color, _, linestyle = get_colors_hatches_lines_lists(\n", "                    c, i, cmap, self.mapper\n\t                )\n\t                ax.plot(x, ion, color=color, ls=linestyle, lw=lw, zorder=2)\n\t        # legend\n\t        # place legend here so that legend top is at the level of share plot top\n\t        if c[\"show\"][\"legend\"]:\n\t            set_legend_with_lines(\n\t                ax, cmap, self.mapper, c, self.idxs, c[\"ions\"][\"names\"]\n\t            )\n\t        apply_labels_ticks_and_lims(\n", "            ax,\n\t            c,\n\t            self.xticks,\n\t            [self.time[0], self.time[-1]],\n\t            ylim,\n\t            True,\n\t            \"ions\",\n\t        )\n\t    def plot(self, c, row, rows_tot, cmap):\n\t        \"\"\"Plot positive (or negative) ionic concentration.\n", "        Args:\n\t            c (dict): config\n\t            row (int): row of subplot\n\t            rows_tot (int): total number of subplots in the figure\n\t            cmap (matplotlib.colors.Colormap): colormap\n\t        \"\"\"\n\t        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=1)\n\t        # plot ion concentrations with lines.\n\t        for i, ion in enumerate(self.data[self.idxs]):\n\t            if not np.all(ion == 0):\n", "                color = select_color(cmap, i, self.N)\n\t                ax.plot(\n\t                    self.time,\n\t                    ion,\n\t                    color=color,\n\t                    ls=\"solid\",\n\t                    lw=c[\"lw\"],\n\t                    zorder=2,\n\t                )\n\t        # legend\n", "        # place legend here so that legend top is at the level of share plot top\n\t        if c[\"show\"][\"legend\"]:\n\t            set_legend(\n\t                ax,\n\t                cmap,\n\t                c[\"ions\"][\"names\"],\n\t                c[\"legend\"][\"bgcolor\"],\n\t                c[\"legend\"][\"ypos\"],\n\t                self.idxs,\n\t            )\n", "        apply_labels_ticks_and_lims(\n\t            ax,\n\t            c,\n\t            self.xticks,\n\t            [self.time[0], self.time[-1]],\n\t            list(c[\"ions\"][\"ylim\"]),\n\t            True,\n\t            \"ions\",\n\t        )\n"]}
{"filename": "currentscape/datasets.py", "chunked_list": ["\"\"\"Base class Dataset.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\timport numpy as np\n\tfrom currentscape.data_processing import round_down_sig_digit, order_of_mag\n\tclass DataSet:\n\t    \"\"\"Base class containing data and data-handling methods.\"\"\"\n\t    def __init__(self, data, names=None, time=None, xticks=None):\n\t        \"\"\"Constructor.\n\t        Args:\n\t            data (list of lists): data\n\t                all lists are expected to have the same size.\n", "            names (list of str): names corresponding to the data,\n\t                in the same order\n\t            time (list): time of the data\n\t            xticks (list): ticks on the x axis. Determined automatically if None.\n\t        Attributes:\n\t            data (ndarray of ndarray): data\n\t            names (ndarray of str): names corresponding to the data,\n\t                in the same order\n\t            time (ndarray): time of the data\n\t            N (int): size of data\n", "            x_size (int): size of one element of data\n\t            idxs (ndarray of ints): arr containing indexes after a reordering\n\t                s.t. reordered_data = self.data[self.idxs]\n\t            xticks (ndarray): ticks on the x axis. Determined automatically if None.\n\t        \"\"\"\n\t        self.data = None\n\t        self.N = None\n\t        self.x_size = None\n\t        self.idxs = None\n\t        self.names = None\n", "        self.time = None\n\t        self.xticks = None\n\t        if data is not None:\n\t            self.data = np.asarray(data)\n\t            self.N = len(self.data)\n\t            self.idxs = range(self.N)\n\t            if self.N > 0:\n\t                self.x_size = len(self.data[0])\n\t            else:\n\t                self.x_size = 0\n", "        if names is not None:\n\t            self.names = np.asarray(names)\n\t        if time is not None:\n\t            self.time = np.asarray(time)\n\t        elif self.x_size:\n\t            self.time = np.arange(self.x_size)\n\t        if xticks is not None:\n\t            self.xticks = np.asarray(xticks)\n\t        elif self.time is not None:\n\t            self.xticks = self.set_xticks()\n", "    def get_negative_data(self):\n\t        \"\"\"Returns a copy of data keeping only negative ones.\"\"\"\n\t        selected_currs = self.data.copy()\n\t        selected_currs[self.data > 0] = 0\n\t        return selected_currs\n\t    def get_positive_data(self):\n\t        \"\"\"Returns a copy of data keeping only positive ones.\"\"\"\n\t        selected_currs = self.data.copy()\n\t        selected_currs[self.data < 0] = 0\n\t        return selected_currs\n", "    def set_xticks(self):\n\t        \"\"\"Generate x ticks values depending on time.\"\"\"\n\t        if self.time is None or len(self.time) == 0:\n\t            return None\n\t        # a diff == 0 would make this function crash.\n\t        # Returning the only xticks making any sense in that case.\n\t        elif len(self.time) == 1:\n\t            return self.time.copy()\n\t        tmin = self.time[0]\n\t        tmax = self.time[-1]\n", "        diff = tmax - tmin\n\t        # order of magnitude\n\t        mag_order = order_of_mag(diff)\n\t        sig = round_down_sig_digit(diff, mag_order)\n\t        if sig / mag_order >= 5:\n\t            step = mag_order\n\t        elif sig / mag_order >= 2:\n\t            step = mag_order / 2.0\n\t        else:\n\t            step = mag_order / 4.0\n", "        if tmin == 0:\n\t            start = 0\n\t        # xticks can begin before tmin. this is corrected afterwards\n\t        else:\n\t            start = round_down_sig_digit(tmin, mag_order)\n\t        # if last step end up on tmax when the list to be returned is created\n\t        # make 'stop' higher than tmax to include tmax in returned value.\n\t        if (tmax - start) % step == 0:\n\t            stop = tmax + step / 2.0\n\t        else:\n", "            stop = tmax\n\t        xticks = np.arange(start, stop, step)\n\t        # remove values lower than the 1st time.\n\t        xticks = [x for x in xticks if x >= tmin]\n\t        return np.array(xticks)\n\t    def xticks_for_imshow(self):\n\t        \"\"\"Return xticks when the xaxis goes from 0 to x_size.\"\"\"\n\t        if self.xticks is None or self.time is None or self.x_size is None:\n\t            return None\n\t        elif len(self.time) == 1:\n", "            return self.time\n\t        tmin = self.time[0]\n\t        tmax = self.time[-1]\n\t        diff = tmax - tmin\n\t        return (self.xticks - tmin) / diff * self.x_size\n"]}
{"filename": "currentscape/data_processing.py", "chunked_list": ["\"\"\"Functions processing data.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\t# pylint: disable=too-many-statements\n\timport logging\n\tfrom math import floor, log10\n\timport numpy as np\n\tlogger = logging.getLogger(__name__)\n\tdef chunksize_warning(cs, len_curr, new_cs):\n\t    \"\"\"Warns that chunksize has been re-set.\n\t    Args:\n\t        cs (int): chunksize of data\n", "        len_curr (int): data size (length of one current list)\n\t        new_cs (int): new chunksize to be used\n\t    \"\"\"\n\t    logger.warning(\n\t        \"x-chunksize (%d) should be a divisor of data size (%d).\"\n\t        \" x-chunksize has been reset to %d.\",\n\t        cs,\n\t        len_curr,\n\t        new_cs,\n\t    )\n", "def check_chunksize(cs, len_curr):\n\t    \"\"\"Set chunksize to a divisor of the data size if not the case.\n\t    Args:\n\t        cs (int): chunksize of data to check\n\t        len_curr (int): data size (length of one current list)\n\t    \"\"\"\n\t    if cs > len_curr:\n\t        chunksize_warning(cs, len_curr, len_curr)\n\t        return len_curr\n\t    elif cs < 1:\n", "        chunksize_warning(cs, len_curr, 1)\n\t        return 1\n\t    # if chunksize is a divisor: end of loop.\n\t    # else: decrement chunksize by one and retest until a divisor is found.\n\t    i = 0\n\t    len_curr = float(len_curr)\n\t    while len_curr // (cs - i) != len_curr / (cs - i):\n\t        i += 1\n\t    if i != 0:\n\t        chunksize_warning(cs, len_curr, cs - i)\n", "    return cs - i\n\tdef sum_chunks(x, chunk_size):\n\t    \"\"\"Compute the sums of parts of an array, then divide values by chunk size.\n\t    Taken from https://stackoverflow.com/questions/18582544/sum-parts-of-numpy-array.\n\t    Args:\n\t        x (ndarray): data to sum into chunks\n\t        chunk_size (int): chunk size of the data to be output\n\t    \"\"\"\n\t    chunk_size = check_chunksize(int(chunk_size), len(x[0]))\n\t    rows, cols = x.shape\n", "    x = x.reshape(int(x.size / chunk_size), chunk_size)\n\t    x = x.sum(axis=1).reshape(rows, int(cols / chunk_size))\n\t    return x / chunk_size\n\tdef remove_zero_arrays(arr, idx=None):\n\t    \"\"\"Removes all arrays made only of zeros.\n\t    Returns new array and indexes to previous array indexes.\n\t    Args:\n\t        arr (ndarray of ndarrays): array\n\t        idx (ndarray): indices of the array\n\t    \"\"\"\n", "    if idx is None:\n\t        idx = np.arange(len(arr))\n\t    # do not take nan values into account\n\t    arr_tmp = arr[:, ~np.isnan(arr).any(axis=0)]\n\t    selection = ~np.all(arr_tmp == 0, axis=1)\n\t    return arr[selection], idx[selection]\n\tdef reordered_idx(arr):\n\t    \"\"\"Returns indexes of sorted currents %age from smaller to larger absolute summed values.\n\t    Args:\n\t        arr (ndarray of ndarrays): array\n", "    \"\"\"\n\t    # do not take nan values into account\n\t    arr = arr[:, ~np.isnan(arr).any(axis=0)]\n\t    return np.argsort(np.sum(np.abs(arr), axis=1))\n\tdef reorder(arr):\n\t    \"\"\"Remove zeros, reorder data and also return data's original indexes.\n\t    Args:\n\t        arr (ndarray of ndarrays): array\n\t    \"\"\"\n\t    arr, idx = remove_zero_arrays(arr)\n", "    new_i = reordered_idx(arr)[::-1]  # reorder from larger to smaller\n\t    arr = arr[new_i]\n\t    idx = idx[new_i]\n\t    return arr, idx\n\tdef order_of_mag(n):\n\t    \"\"\"Get order of magnitude of a (absolute value of a) number.\n\t    e.g. for 1234 -> 1000, or 0.0456 -> 0.01\n\t    Args:\n\t        n (float or int): number\n\t    \"\"\"\n", "    return pow(10, floor(log10(abs(n))))\n\tdef round_down_sig_digit(n, mag_order=None):\n\t    \"\"\"Round down to a given number (default: 1) of significant digit.\n\t    e.g. 0.0456 -> 0.04, 723 -> 700\n\t    Args:\n\t        n (float or int): number to be rounded down\n\t        mag_order (float or int): 10 to the power of the desired order of magnitude\n\t            (e.g. 1000 to round the thousands)\n\t            if None: n is rounded to 1 sig digit\n\t    \"\"\"\n", "    if mag_order is None:\n\t        mag_order = order_of_mag(n)\n\t    # when dealing with floats, floating point errors can happen (e.g. 0.5 // 0.1 -> 0.4)\n\t    # this can happen when n is already its own sig (sig = rounded down one significant digit nmb)\n\t    # (if it's bigger, usually n - sig is bigger than (float(n) - true n value) error\n\t    # so the error does not influence the result of n // mag_order when n != sig(n))\n\t    # -> if (dealing with floats) and (n == sig(n)), then return n\n\t    if mag_order < 1 and len(str(abs(n))) == len(str(mag_order)):\n\t        return n\n\t    return float(mag_order * (n // mag_order))\n", "def autoscale_ticks_and_ylim(c, pos, neg, config_key=\"current\"):\n\t    \"\"\"Autoscale ticks and ylim and put the result in config.\n\t    No need to return config, since dict are mutable in python.\n\t    Args:\n\t        c (dict): config\n\t        pos (ndarray or float): positive values or max of positive values\n\t        neg (ndarray or float): absolute values of negative values or\n\t            absolute value of minimum of negative values\n\t        config_key (str): key for getting data from config. Should be 'current' or 'ions'\n\t    \"\"\"\n", "    max_pos = np.max(pos)\n\t    max_neg = np.max(neg)\n\t    maxi = max_pos if max_pos > max_neg else max_neg\n\t    c[config_key][\"ylim\"] = (5.0 * maxi / 1e7, 5.0 * maxi)\n\t    # e.g. 0.0456 -> 0.04, 723 -> 700\n\t    sig = round_down_sig_digit(maxi)\n\t    c[config_key][\"ticks\"] = [sig * 0.00001, sig * 0.001, sig * 0.1]\n"]}
{"filename": "currentscape/currentscape.py", "chunked_list": ["\"\"\"Module to plot currentscapes.\n\tAs in https://datadryad.org/stash/dataset/doi:10.5061/dryad.d0779mb.\n\tThe main function is based on scripts from the susmentioned article,\n\tthat are under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication license.\n\t\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# pylint: disable=too-many-statements, wrong-import-position\n\timport logging\n\timport numpy as np\n\timport matplotlib\n\tmatplotlib.use(\"agg\")  # to avoid tkinter error\n", "import matplotlib.pyplot as plt\n\tfrom currentscape.data_processing import (\n\t    autoscale_ticks_and_ylim,\n\t)\n\tfrom currentscape.plotting import (\n\t    configure_mpl_rcParams,\n\t    get_colormap,\n\t    adjust,\n\t    save_figure,\n\t    get_rows_tot,\n", "    plot_x_labels,\n\t)\n\tfrom currentscape.voltages import Voltages\n\tfrom currentscape.currents import Currents\n\tfrom currentscape.ions import IonConcentrations\n\tfrom currentscape.config_parser import set_default_config\n\tlogger = logging.getLogger(__name__)\n\tdef create_figure(voltage, currs, c, ions):\n\t    \"\"\"Create the currentscape figure.\n\t    Args:\n", "        voltage (list of floats): voltage data\n\t        currs (Currents): object containing currents data\n\t        c (dict): config\n\t        ions (IonConcentrations): object containing ionic concentration data\n\t    \"\"\"\n\t    configure_mpl_rcParams(c)\n\t    use_patterns = c[\"pattern\"][\"use\"]\n\t    cmap = get_colormap(\n\t        c[\"colormap\"][\"name\"], c[\"colormap\"][\"n_colors\"], use_patterns, currs.N, ions.N\n\t    )\n", "    # get adequate ticks and ylim\n\t    # put into classes\n\t    if c[\"current\"][\"autoscale_ticks_and_ylim\"]:\n\t        autoscale_ticks_and_ylim(c, currs.pos_sum, currs.neg_sum)\n\t    if ions.data is not None and c[\"ions\"][\"autoscale_ticks_and_ylim\"]:\n\t        autoscale_ticks_and_ylim(c, np.max(ions.data), abs(np.min(ions.data)), \"ions\")\n\t    rows_tot = get_rows_tot(c, ions)\n\t    row = 0\n\t    # START PLOT\n\t    fig = plt.figure(figsize=c[\"figsize\"])\n", "    if c[\"title\"]:\n\t        fig.suptitle(c[\"title\"], fontsize=c[\"titlesize\"])\n\t    # PLOT OVERALL CONTRIBUTIONS\n\t    # plot this first.\n\t    # cannot be at the bottom, because it would plot on top of xlabels if enabled.\n\t    if c[\"show\"][\"total_contribution\"]:\n\t        currs.plot_overall_contributions(c, row, rows_tot, cmap)\n\t        row += 2\n\t    # PLOT VOLTAGE TRACE\n\t    voltage.plot(c, row, rows_tot)\n", "    row += 2\n\t    # PLOT TOTAL INWARD CURRENT IN LOG SCALE\n\t    currs.plot_sum(c, row, rows_tot, True)\n\t    row += 1\n\t    # PLOT CURRENT SHARES\n\t    if (\n\t        c[\"show\"][\"currentscape\"]\n\t        and c[\"currentscape\"][\"legacy_method\"]\n\t        and not use_patterns\n\t    ):\n", "        currs.plot_shares_with_imshow(c, row, rows_tot, cmap)\n\t        row += 3\n\t    elif c[\"show\"][\"currentscape\"]:\n\t        currs.plot_shares(c, row, rows_tot, cmap)\n\t        row += 4\n\t    # PLOT TOTAL OUTWARD CURRENT IN LOG SCALE\n\t    currs.plot_sum(c, row, rows_tot, False)\n\t    row += 1\n\t    # PLOT ALL CURRENTS\n\t    if c[\"show\"][\"all_currents\"]:\n", "        # plot all positive currents\n\t        currs.plot(c, row, rows_tot, cmap, True)\n\t        row += 1\n\t        # plot all negative currents\n\t        currs.plot(c, row, rows_tot, cmap, False)\n\t        row += 1\n\t    # PLOT IONIC CONCENTRATIONS\n\t    if ions.data is not None:\n\t        if use_patterns:\n\t            ions.plot_with_linestyles(c, row, rows_tot, cmap)\n", "        else:\n\t            ions.plot(c, row, rows_tot, cmap)\n\t        row += 1\n\t    # ADD X LABEL & X TICK LABELS\n\t    # add labels only on bottom subplot\n\t    # time is identical for every dataset here, so currs can be used, even for ions xticks.\n\t    plot_x_labels(fig.axes[-1], c, currs.xticks)\n\t    adjust(\n\t        c[\"adjust\"][\"left\"],\n\t        c[\"adjust\"][\"right\"],\n", "        c[\"adjust\"][\"top\"],\n\t        c[\"adjust\"][\"bottom\"],\n\t    )\n\t    return fig\n\tdef plot_currentscape(voltage_data, currents_data, config, ions_data=None, time=None):\n\t    \"\"\"Returns a figure containing current scapes.\n\t    Args:\n\t        voltage_data (list): voltage data\n\t        currents_data (list of lists): currents data\n\t        config (dict or str): dict or path to json file containing config\n", "        ions_data (list of lists): ion concentrations data\n\t        time (list): time data\n\t    \"\"\"\n\t    # load config and set default to unspecified terms\n\t    c = set_default_config(config)\n\t    # currenscape data processing\n\t    logger.info(\"processing data\")\n\t    voltage = Voltages(voltage_data, c, time)\n\t    currs = Currents(currents_data, c, time)\n\t    ions = IonConcentrations(ions_data, c, time)\n", "    # plot currentscape\n\t    logger.info(\"producing figure\")\n\t    fig = create_figure(voltage, currs, c, ions)\n\t    # saving matplotlib figure needs a lot of memory\n\t    # so delete data that will not be used anymore before\n\t    currs = None\n\t    voltage = None\n\t    ions = None\n\t    if c[\"output\"][\"savefig\"]:\n\t        save_figure(fig, c)\n", "    return fig\n"]}
{"filename": "currentscape/currents.py", "chunked_list": ["\"\"\"Currents class.\n\tAs in https://datadryad.org/stash/dataset/doi:10.5061/dryad.d0779mb.\n\tSome functions are based on scripts from the susmentioned article,\n\tthat are under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication license.\n\t\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n", "# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n\t# limitations under the License.\n\t# pylint: disable=wrong-import-position, super-with-arguments\n\timport math\n\timport numpy as np\n\timport matplotlib\n\tmatplotlib.use(\"agg\")  # to avoid tkinter error\n", "import matplotlib.pyplot as plt\n\tfrom currentscape.datasets import DataSet\n\tfrom currentscape.data_processing import (\n\t    reordered_idx,\n\t    reorder,\n\t    remove_zero_arrays,\n\t)\n\tfrom currentscape.plotting import (\n\t    remove_ticks_and_frame_for_bar_plot,\n\t    set_label,\n", "    apply_labels_ticks_and_lims,\n\t    stackplot_with_bars,\n\t    stackplot_with_fill_between,\n\t    black_line_log_scale,\n\t    get_colors_hatches_lines_lists,\n\t    show_xgridlines,\n\t)\n\tfrom currentscape.legends import (\n\t    set_legend_with_hatches,\n\t    set_legend_with_hatches_and_linestyles,\n", "    set_legend_with_lines,\n\t    set_legend,\n\t)\n\tfrom currentscape.mapper import create_mapper\n\tclass CurrentPlottingMixin:\n\t    \"\"\"All current plotting methods to be inherited by the Currents class.\"\"\"\n\t    def plot_sum(self, c, row, rows_tot, positive=True):\n\t        \"\"\"Plot outward or inward current sum in log scale.\n\t        Args:\n\t            c (dict): config\n", "            row (int): row of subplot\n\t            rows_tot (int): total number of subplots in the figure\n\t            positive (bool): True to plot positive currents subplot.\n\t                False to plot negative currents subplot\n\t        \"\"\"\n\t        if positive:\n\t            curr = self.pos_sum\n\t        else:\n\t            curr = self.neg_sum\n\t        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=1)\n", "        ax.fill_between(\n\t            self.time,\n\t            curr,\n\t            color=c[\"current\"][\"color\"],\n\t            lw=c[\"lw\"],\n\t            zorder=2,\n\t        )\n\t        apply_labels_ticks_and_lims(\n\t            ax,\n\t            c,\n", "            self.xticks,\n\t            [self.time[0], self.time[-1]],\n\t            list(c[\"current\"][\"ylim\"]),\n\t            positive,\n\t            \"current\",\n\t        )\n\t    def plot_shares(self, c, row, rows_tot, cmap):\n\t        \"\"\"Plot current percentages.\n\t        Args:\n\t            c (dict): config\n", "            row (int): row of subplot\n\t            rows_tot (int): total number of subplots in the figure\n\t            cmap (matplotlib.colors.Colormap): colormap\n\t        \"\"\"\n\t        # outward currents\n\t        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=2)\n\t        if c[\"currentscape\"][\"legacy_method\"]:\n\t            stackplot_with_bars(\n\t                ax, self.pos_norm, self.idxs, cmap, c, self.N, self.mapper\n\t            )\n", "        else:\n\t            stackplot_with_fill_between(\n\t                ax, self.pos_norm, self.idxs, cmap, c, self.N, self.mapper\n\t            )\n\t        # add at black line a the bottom of the plot.\n\t        # cannot use spines because with subplot_adjust(h=0),\n\t        # spines overlap on neighboor plot and hide part of the data\n\t        y_bottom = -c[\"current\"][\"black_line_thickness\"] / 100.0\n\t        ax.fill_between(\n\t            [self.time[0], self.time[-1]],\n", "            [y_bottom, y_bottom],\n\t            color=\"black\",\n\t            lw=0,\n\t        )\n\t        ylim = [y_bottom, 1]\n\t        ax.set_ylim(ylim)\n\t        ax.set_xlim([self.time[0], self.time[-1]])\n\t        remove_ticks_and_frame_for_bar_plot(ax)\n\t        # show x axis gridline\n\t        if c[\"show\"][\"xgridlines\"]:\n", "            show_xgridlines(ax, c, self.xticks, ylim)\n\t        # labels\n\t        if c[\"show\"][\"ylabels\"]:\n\t            ax.set_ylabel(c[\"currentscape\"][\"out_label\"], labelpad=c[\"labelpad\"])\n\t        # legend\n\t        # place legend here so that legend top is at the level of share plot top\n\t        if c[\"show\"][\"legend\"]:\n\t            if not c[\"pattern\"][\"use\"]:\n\t                set_legend(\n\t                    ax,\n", "                    cmap,\n\t                    c[\"current\"][\"names\"],\n\t                    c[\"legend\"][\"bgcolor\"],\n\t                    c[\"legend\"][\"ypos\"],\n\t                    self.idxs,\n\t                )\n\t            elif c[\"show\"][\"all_currents\"] and not c[\"current\"][\"stackplot\"]:\n\t                set_legend_with_hatches_and_linestyles(\n\t                    ax, cmap, self.mapper, c, self.idxs\n\t                )\n", "            else:\n\t                set_legend_with_hatches(ax, cmap, self.mapper, c, self.idxs)\n\t        # inward currents\n\t        ax = plt.subplot2grid((rows_tot, 1), (row + 2, 0), rowspan=2)\n\t        if c[\"currentscape\"][\"legacy_method\"]:\n\t            stackplot_with_bars(\n\t                ax, self.neg_norm, self.idxs, cmap, c, self.N, self.mapper\n\t            )\n\t        else:\n\t            stackplot_with_fill_between(\n", "                ax, self.neg_norm, self.idxs, cmap, c, self.N, self.mapper\n\t            )\n\t        ylim = [0, 1]\n\t        ax.set_ylim(ylim)\n\t        ax.set_xlim([self.time[0], self.time[-1]])\n\t        remove_ticks_and_frame_for_bar_plot(ax)\n\t        # show x axis gridline\n\t        if c[\"show\"][\"xgridlines\"]:\n\t            show_xgridlines(ax, c, self.xticks, ylim)\n\t        # labels\n", "        if c[\"show\"][\"ylabels\"]:\n\t            ax.set_ylabel(c[\"currentscape\"][\"in_label\"], labelpad=c[\"labelpad\"])\n\t    def plot_shares_with_imshow(self, c, row, rows_tot, cmap):\n\t        \"\"\"Plot current percentage using imshow.\n\t        Args:\n\t            c (dict): config\n\t            row (int): row of subplot\n\t            rows_tot (int): total number of subplots in the figure\n\t            cmap (matplotlib.colors.Colormap): colormap\n\t        \"\"\"\n", "        resy = c[\"currentscape\"][\"y_resolution\"]\n\t        black_line_size = int(resy * c[\"current\"][\"black_line_thickness\"] / 100.0)\n\t        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=3)\n\t        im = ax.imshow(\n\t            self.image[::1, ::1],\n\t            interpolation=\"nearest\",\n\t            aspect=\"auto\",\n\t            cmap=cmap,\n\t        )\n\t        plt.gca().xaxis.set_major_locator(plt.NullLocator())\n", "        plt.gca().yaxis.set_major_locator(plt.NullLocator())\n\t        # set limits\n\t        ylim = [2 * resy + black_line_size, 0]\n\t        ax.set_ylim(ylim)\n\t        ax.set_xlim(0, self.x_size)\n\t        # show x axis gridline\n\t        if c[\"show\"][\"xgridlines\"]:\n\t            show_xgridlines(ax, c, self.xticks_for_imshow(), ylim)\n\t        # set number of colors\n\t        # data + black for separating line + white for empty data = (N-1)+1+1\n", "        im.set_clim(0, self.N + 1)\n\t        # remove top and bottom frame that hide some data\n\t        ax.spines[\"top\"].set_visible(False)\n\t        ax.spines[\"bottom\"].set_visible(False)\n\t        # labels\n\t        if c[\"show\"][\"ylabels\"]:\n\t            # cheat to set two labels at the right places for 1 axis\n\t            set_label(\n\t                ax,\n\t                x=0,\n", "                y=3 * resy / 2,\n\t                label=c[\"currentscape\"][\"in_label\"],\n\t                textsize=c[\"textsize\"],\n\t            )\n\t            set_label(\n\t                ax,\n\t                x=0,\n\t                y=resy / 2,\n\t                label=c[\"currentscape\"][\"out_label\"],\n\t                textsize=c[\"textsize\"],\n", "            )\n\t        # legend\n\t        if c[\"show\"][\"legend\"]:\n\t            set_legend(\n\t                ax,\n\t                im.cmap,\n\t                c[\"current\"][\"names\"],\n\t                c[\"legend\"][\"bgcolor\"],\n\t                c[\"legend\"][\"ypos\"],\n\t                self.idxs,\n", "            )\n\t    def plot_with_lines(self, ax, selected_currs, c, cmap):\n\t        \"\"\"Plot all the positive (or negative) currents with lines.\n\t        Args:\n\t            ax (matplotlib.axes): current axis\n\t            selected_currs (ndarray of ndarrays): positive or negative currents data\n\t            c (dict): config\n\t            cmap (matplotlib.colors.Colormap): colormap\n\t        \"\"\"\n\t        lw = c[\"lw\"]\n", "        # here, use currs.idxs to have the same colors as in currs.names\n\t        # can do it because selected_currs have same shape as self (no zero arrays removed)\n\t        for i, curr in enumerate(selected_currs[self.idxs]):\n\t            if not np.all(curr == 0):\n\t                color, _, linestyle = get_colors_hatches_lines_lists(\n\t                    c, i, cmap, self.mapper\n\t                )\n\t                ax.plot(self.time, curr, color=color, ls=linestyle, lw=lw, zorder=2)\n\t    def plot(self, c, row, rows_tot, cmap, positive=True):\n\t        \"\"\"Plot all the positive (or negative) currents.\n", "        Args:\n\t            c (dict): config\n\t            row (int): row of subplot\n\t            rows_tot (int): total number of subplots in the figure\n\t            cmap (matplotlib.colors.Colormap): colormap\n\t            positive (bool): True to plot positive currents subplot.\n\t                False to plot negative currents subplot\n\t        \"\"\"\n\t        ylim = list(c[\"current\"][\"ylim\"])\n\t        ax = plt.subplot2grid((rows_tot, 1), (row, 0), rowspan=1)\n", "        # select currents (positive or negative)\n\t        if positive:\n\t            selected_currs = self.get_positive_data()\n\t        else:\n\t            selected_currs = np.abs(self.get_negative_data())\n\t        # plot selected currents, either with stackplot or with lines.\n\t        if c[\"current\"][\"stackplot\"]:\n\t            # create dataset from reordered selected currents\n\t            sorted_idxs = reordered_idx(selected_currs)\n\t            sel_currs = DataSet(\n", "                data=selected_currs[sorted_idxs],\n\t                names=self.names,\n\t                time=self.time,\n\t                xticks=self.xticks,\n\t            )\n\t            sel_currs.idxs = sorted_idxs\n\t            if c[\"current\"][\"legacy_method\"]:\n\t                stackplot_with_bars(\n\t                    ax, sel_currs, self.idxs, cmap, c, self.N, self.mapper, False\n\t                )\n", "            else:\n\t                stackplot_with_fill_between(\n\t                    ax, sel_currs, self.idxs, cmap, c, self.N, self.mapper, False\n\t                )\n\t        else:\n\t            self.plot_with_lines(ax, selected_currs, c, cmap)\n\t        # add black line separating positive currents from negative currents\n\t        if positive and c[\"current\"][\"stackplot\"]:\n\t            ylim = black_line_log_scale(\n\t                ax,\n", "                ylim,\n\t                [self.time[0], self.time[-1]],\n\t                c[\"current\"][\"black_line_thickness\"],\n\t            )\n\t        # show legend if not shown in currentscape\n\t        if not c[\"show\"][\"currentscape\"] and c[\"show\"][\"legend\"] and positive:\n\t            # regular colors\n\t            if not c[\"pattern\"][\"use\"]:\n\t                set_legend(\n\t                    ax,\n", "                    cmap,\n\t                    c[\"current\"][\"names\"],\n\t                    c[\"legend\"][\"bgcolor\"],\n\t                    c[\"legend\"][\"ypos\"],\n\t                    self.idxs,\n\t                )\n\t            # colors & hatches\n\t            elif c[\"current\"][\"stackplot\"]:\n\t                set_legend_with_hatches(ax, cmap, self.mapper, c, self.idxs)\n\t            # linestyles & hatches\n", "            elif c[\"show\"][\"total_contribution\"]:\n\t                set_legend_with_hatches_and_linestyles(\n\t                    ax, cmap, self.mapper, c, self.idxs\n\t                )\n\t            # linestyles only\n\t            else:\n\t                set_legend_with_lines(\n\t                    ax,\n\t                    cmap,\n\t                    self.mapper,\n", "                    c,\n\t                    self.idxs,\n\t                    c[\"current\"][\"names\"],\n\t                )\n\t        apply_labels_ticks_and_lims(\n\t            ax,\n\t            c,\n\t            self.xticks,\n\t            [self.time[0], self.time[-1]],\n\t            ylim,\n", "            positive,\n\t            \"current\",\n\t        )\n\t    def plot_overall_contribution(self, ax, data, c, cmap):\n\t        \"\"\"Plot one pie chart of either positive or negative currents contribution.\n\t        Args:\n\t            ax (matplotlib.axes): pie chart axis\n\t            data (ndarray of ndarrays): positive or negative currents data\n\t            c (dict): config\n\t            cmap (matplotlib.colors.Colormap): colormap\n", "        \"\"\"\n\t        # bar plot in polar coordinates -> pie chart\n\t        radius = 1\n\t        size = 0.5\n\t        # process data to be polar coordinates compatible\n\t        valsnorm = np.sum(data / np.sum(data) * 2 * np.pi, axis=1)\n\t        valsleft = np.cumsum(np.append(0, valsnorm[:-1]))\n\t        # current indexes\n\t        curr_idxs = np.arange(self.N)\n\t        # set colors and patterns\n", "        colors, hatches, _ = get_colors_hatches_lines_lists(\n\t            c, curr_idxs, cmap, self.mapper\n\t        )\n\t        bars = ax.bar(\n\t            x=valsleft,\n\t            width=valsnorm,\n\t            bottom=radius - size,\n\t            height=size,\n\t            color=colors,\n\t            edgecolor=c[\"pattern\"][\"color\"],\n", "            linewidth=c[\"lw\"],\n\t            align=\"edge\",\n\t        )\n\t        # for loop, because hatches cannot be passed as a list\n\t        if hatches is not None:\n\t            for bar_, hatch in zip(bars, hatches):\n\t                bar_.set_hatch(hatch)\n\t        ax.set_axis_off()\n\t    def plot_overall_contributions(self, c, row, rows_tot, cmap):\n\t        \"\"\"Plot positive and negative pie charts of currents summed over the whole simulation.\n", "        Args:\n\t            c (dict): config\n\t            row (int): row of subplot\n\t            rows_tot (int): total number of subplots in the figure\n\t            cmap (matplotlib.colors.Colormap): colormap\n\t        \"\"\"\n\t        textsize = c[\"textsize\"]\n\t        labelpad = c[\"labelpad\"]\n\t        # POSITIVE\n\t        # trick: bar plot in polar coord. to do a pie chart.\n", "        ax = plt.subplot2grid((rows_tot, 2), (row, 0), rowspan=2, polar=True)\n\t        # get positive data and reorder them\n\t        pos_data = self.get_positive_data()[self.idxs]\n\t        self.plot_overall_contribution(ax, pos_data, c, cmap)\n\t        # pi is left in x polar coordinates, 1 is height of bars -> outside pie chart\n\t        # labelpad / 4 : looks close to labelpad in regular plot, but is not rigorous\n\t        if c[\"show\"][\"ylabels\"]:\n\t            set_label(ax, math.pi, 1 + labelpad / 4.0, \"outward\", textsize)\n\t        # NEGATIVE\n\t        # trick: bar plot in polar coord. to do a pie chart.\n", "        ax = plt.subplot2grid((rows_tot, 2), (row, 1), rowspan=2, polar=True)\n\t        # get positive data and reorder them\n\t        neg_data = self.get_negative_data()[self.idxs]\n\t        self.plot_overall_contribution(ax, neg_data, c, cmap)\n\t        # pi is left in x polar coordinates, 1 is height of bars -> outside pie chart\n\t        # labelpad / 4 : looks close to labelpad in regular plot, but is not rigorous\n\t        if c[\"show\"][\"ylabels\"]:\n\t            set_label(ax, math.pi, 1 + labelpad / 4.0, \"inward\", textsize)\n\tclass Currents(CurrentPlottingMixin, DataSet):\n\t    \"\"\"Class containing current data.\"\"\"\n", "    def __init__(self, data, c, time=None):\n\t        \"\"\"Constructor.\n\t        Args:\n\t            data (list of lists): data\n\t                all lists are expected to have the same size.\n\t            c (dict): config\n\t            time (list): time of the data\n\t        Attributes:\n\t            pos_norm (ndarray of ndarrays): norm of positive data\n\t            neg_norm (ndarray of ndarrays): - norm of negative data\n", "            pos_sum (ndarray of floats): summed positive data along axis=0\n\t            neg_sum (ndarray of floats): summed negative data along axis=0\n\t            image (ndarray of ndarrays): currentscape image to be shown with imshow\n\t            mapper (int): number used to mix colors and patterns\n\t        \"\"\"\n\t        reorder_ = c[\"current\"][\"reorder\"]\n\t        resy = c[\"currentscape\"][\"y_resolution\"]\n\t        lw = c[\"current\"][\"black_line_thickness\"]\n\t        use_pattern = c[\"pattern\"][\"use\"]\n\t        n_patterns = len(c[\"pattern\"][\"patterns\"])\n", "        legacy = c[\"currentscape\"][\"legacy_method\"]\n\t        super(Currents, self).__init__(\n\t            data=data,\n\t            names=c[\"current\"][\"names\"],\n\t            time=time,\n\t            xticks=c[\"xaxis\"][\"xticks\"],\n\t        )\n\t        # self.idxs may be modified in the method below\n\t        self.pos_norm, self.neg_norm, self.pos_sum, self.neg_sum = self.data_processing(\n\t            reorder_\n", "        )\n\t        if not legacy or use_pattern:\n\t            # check this before creating mapper\n\t            # this change should persist even outside the class\n\t            if c[\"colormap\"][\"n_colors\"] > self.N:\n\t                c[\"colormap\"][\"n_colors\"] = self.N\n\t            self.image = None\n\t            self.mapper = create_mapper(c[\"colormap\"][\"n_colors\"], n_patterns)\n\t        else:\n\t            self.image = self.create_cscape_image(resy, lw)\n", "            self.mapper = None\n\t    def data_processing(self, reorder_):\n\t        \"\"\"Separate into positive and negative currents.\n\t        Remove 0s arrays. Reorder if asked. Record reordered name indexes.\n\t        Return the sum and the fraction with its reordered indexes.\n\t        Args:\n\t            reorder_ (bool): whether to reorder the currents or not\n\t        Returns: A tuple (pos_norm, neg_norm, normapos, normaneg), with\n\t            pos_norm (ndarray of ndarrays): arrays containing norm of positive currents\n\t            neg_norm (ndarray of ndarrays): arrays containing (-1)* norm of negative currents\n", "            normapos (ndarray): summed positive currents\n\t            normaneg (ndarray): summed (absolute values of) negative currents\n\t        \"\"\"\n\t        cpos = self.get_positive_data()\n\t        cneg = self.get_negative_data()\n\t        normapos = np.sum(np.abs(np.asarray(cpos)), axis=0)\n\t        normaneg = np.sum(np.abs(np.asarray(cneg)), axis=0)\n\t        # replace 0s by 1s in norma* to avoid 0/0 error.\n\t        # When norma* is 0, all values it divides are 0s, so even when replaced by 1s,\n\t        #   the result is 0.\n", "        # We want the result to be 0 in that case because there is no current.\n\t        cnorm_pos = np.abs(cpos) / [x if x != 0 else 1.0 for x in normapos]\n\t        cnorm_neg = -(np.abs(cneg) / [x if x != 0 else 1.0 for x in normaneg])\n\t        # memory optimisation\n\t        cpos = None\n\t        cneg = None\n\t        if reorder_:\n\t            cnorm_pos, cnorm_neg, idx_pos, idx_neg = self.reorder_currents_and_names(\n\t                cnorm_pos, cnorm_neg\n\t            )\n", "        else:\n\t            cnorm_pos, idx_pos = remove_zero_arrays(cnorm_pos)\n\t            cnorm_neg, idx_neg = remove_zero_arrays(cnorm_neg)\n\t        pos_norm = DataSet(cnorm_pos, time=self.time, xticks=self.xticks)\n\t        pos_norm.idxs = idx_pos\n\t        neg_norm = DataSet(cnorm_neg, time=self.time, xticks=self.xticks)\n\t        neg_norm.idxs = idx_neg\n\t        return (\n\t            pos_norm,\n\t            neg_norm,\n", "            normapos,\n\t            normaneg,\n\t        )\n\t    def reorder_currents_and_names(self, cnorm_pos, cnorm_neg):\n\t        \"\"\"Reorder positive currents, negative currents, and current names.\n\t        Reorder from overall largest contribution to smallest contribution.\n\t        Reordering the current names (for legend display) is not essential,\n\t        but is more pleasant to the eye.\n\t        Args:\n\t            cnorm_pos (ndarray of ndarrays): arrays containing norm\n", "                of positive currents\n\t            cnorm_neg (ndarray of ndarrays): arrays containing (-1)* norm\n\t                of negative currents\n\t        Returns:\n\t            trimmed and reordered positive currents array\n\t            trimmed and reordered negative currents array\n\t            indexes that currents (in the pos array) used to have in the original curr array\n\t            indexes that currents (in the neg array) used to have in the original curr array\n\t        \"\"\"\n\t        cnorm_pos, idx_pos = reorder(cnorm_pos)\n", "        cnorm_neg, idx_neg = reorder(cnorm_neg)\n\t        # for the order of names, just stack the positive and negative order,\n\t        # then removing duplicates (while conserving order).\n\t        # also stack arange in case a current is zero for all the sim -> avoid index errors later\n\t        idx_names = np.concatenate((idx_pos, idx_neg, np.arange(self.N)))\n\t        _, i = np.unique(idx_names, return_index=True)\n\t        self.idxs = idx_names[\n\t            np.sort(i)\n\t        ]  # pylint: disable=attribute-defined-outside-init\n\t        return cnorm_pos, cnorm_neg, idx_pos, idx_neg\n", "    def create_black_line(self, resy, lw):\n\t        \"\"\"Create a black line to separate inward and outward current shares.\n\t        Args:\n\t            resy (int): y-axis resolution\n\t                (must be high >>1000 or else rounding errors produce white pixels)\n\t            lw (int): black line (separating the two currentscape plots) thickness\n\t                in percentage of the plot height.\n\t        \"\"\"\n\t        line_thickness = int(resy * lw / 100.0)\n\t        if line_thickness < 1:\n", "            line = np.full((1, self.x_size), self.N, dtype=np.int8)\n\t        else:\n\t            line = np.full((line_thickness, self.x_size), self.N, dtype=np.int8)\n\t        return line\n\t    def create_cscape_image(self, resy, lw):\n\t        \"\"\"Create currentscape image.\n\t        Args:\n\t            resy (int): y-axis resolution\n\t                (must be high >>1000 or else rounding errors produce white pixels)\n\t            lw (int): black line (separating the two currentscape plots) thickness\n", "                in percentage of the plot height.\n\t        \"\"\"\n\t        # idexes to map to re-ordered current names\n\t        # interchange index and values of self.idxs (name indexes) to create imap\n\t        # that way, imap[idx] gives index in self.idxs\n\t        imap = np.zeros(self.N, dtype=int)\n\t        imap[self.idxs] = np.arange(self.N)\n\t        times = np.arange(0, self.x_size)\n\t        # using int8 not to take too much memory\n\t        impos = np.full((resy, self.x_size), self.N + 1, dtype=np.int8)\n", "        imneg = np.full((resy, self.x_size), self.N + 1, dtype=np.int8)\n\t        for t in times:\n\t            lastpercent = 0\n\t            for idx, curr in zip(self.pos_norm.idxs, self.pos_norm.data):\n\t                if curr[t] > 0:\n\t                    numcurr = imap[idx]\n\t                    percent = int(abs(curr[t]) * (resy))\n\t                    impos[lastpercent : lastpercent + percent, t] = numcurr\n\t                    lastpercent = lastpercent + percent\n\t        for t in times:\n", "            lastpercent = 0\n\t            for idx, curr in zip(self.neg_norm.idxs, self.neg_norm.data):\n\t                if curr[t] < 0:\n\t                    numcurr = imap[idx]\n\t                    percent = int(abs(curr[t]) * (resy))\n\t                    imneg[lastpercent : lastpercent + percent, t] = numcurr\n\t                    lastpercent = lastpercent + percent\n\t        # append fake data to produce a black line separating inward & outward\n\t        # cannot draw with plot, because that would hide data because of adjust (h=0)\n\t        line = self.create_black_line(resy, lw)\n", "        return np.vstack((impos, line, imneg))\n"]}
{"filename": "examples/use_case/run.py", "chunked_list": ["\"\"\"Run the cell to record currents and ionic concentrations.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\timport logging\n\tfrom pathlib import Path\n\tfrom bluepyopt import ephys\n\tfrom emodelrunner.load import load_emodel_params\n\tfrom emodelrunner.load import load_mechanisms\n\tfrom emodelrunner.load import load_unoptimized_parameters\n\tfrom emodelrunner.morphology.morphology import SSCXNrnFileMorphology\n\tfrom emodelrunner.output import write_responses\n\tfrom emodelrunner.recordings import RecordingCustom\n", "logger = logging.getLogger(__name__)\n\tdef absolute_path(path):\n\t    path_to_dir = Path( __file__ ).parent.absolute()\n\t    return str(path_to_dir / path)\n\tdef create_cell():\n\t    unopt_params_path = absolute_path(\"config/params/pyr.json\")\n\t    mechs = load_mechanisms(unopt_params_path)\n\t    params = load_unoptimized_parameters(unopt_params_path, v_init=-80, celsius=34)\n\t    morph_path = absolute_path(\n\t        \"morphology/dend-C231296A-P4B2_axon-C200897C-P2_-_Scale_x1.000_y0.975_z1.000.asc\"\n", "    )\n\t    morph = SSCXNrnFileMorphology(\n\t        morphology_path=morph_path,\n\t        do_replace_axon=True,\n\t    )\n\t    return ephys.models.CellModel(\n\t        name=\"cADpyr_L4UPC\",\n\t        morph=morph,\n\t        mechs=mechs,\n\t        params=params,\n", "    )\n\tdef create_recordings(soma_loc):\n\t    recs = []\n\t    currents = [\n\t        \"i_pas\",\n\t        \"ihcn_Ih\",\n\t        \"ica_Ca_HVA2\",\n\t        \"ica_Ca_LVAst\",\n\t        \"ik_SK_E2\",\n\t        \"ik_SKv3_1\",\n", "        \"ik_K_Pst\",\n\t        \"ik_K_Tst\",\n\t        \"ina_NaTg\",\n\t    ]\n\t    ionic_concentrations = [\"cai\", \"ki\", \"nai\"]\n\t    recs.append(RecordingCustom(name=\"v\", location=soma_loc, variable=\"v\"))\n\t    for var in currents:\n\t        recs.append(RecordingCustom(name=var, location=soma_loc, variable=var))\n\t    for var in ionic_concentrations:\n\t        recs.append(RecordingCustom(name=var, location=soma_loc, variable=var))\n", "    return recs\n\tdef create_stimuli(soma_loc):\n\t    # create step stimulus\n\t    stim = ephys.stimuli.NrnSquarePulse(\n\t        step_amplitude=0.34859375,\n\t        step_delay=70.0,\n\t        step_duration=200.0,\n\t        location=soma_loc,\n\t        total_duration=300.0,\n\t    )\n", "    # create holding stimulus\n\t    hold_stim = ephys.stimuli.NrnSquarePulse(\n\t        step_amplitude=-0.0896244038173676,\n\t        step_delay=0.0,\n\t        step_duration=300.0,\n\t        location=soma_loc,\n\t        total_duration=300.0,\n\t    )\n\t    return [stim, hold_stim]\n\tdef run():\n", "    cell = create_cell()\n\t    release_params = load_emodel_params(\n\t        params_path=absolute_path(\"config/params/final.json\"), emodel=\"cADpyr_L4UPC\"\n\t    )\n\t    sim = ephys.simulators.NrnSimulator(dt=0.025, cvode_active=False)\n\t    soma_loc = ephys.locations.NrnSeclistCompLocation(\n\t        name=\"soma\", seclist_name=\"somatic\", sec_index=0, comp_x=0.5\n\t    )\n\t    recs = create_recordings(soma_loc)\n\t    stims = create_stimuli(soma_loc)\n", "    protocol = ephys.protocols.SweepProtocol(\"step_protocol\", stims, recs, cvode_active=False)\n\t    logger.info(\"Python Recordings Running...\")\n\t    responses = protocol.run(\n\t        cell_model=cell, param_values=release_params, sim=sim, isolate=False\n\t    )\n\t    write_responses(responses, absolute_path(\"python_recordings\"))\n\t    logger.info(\"Python Recordings Done\")\n\tif __name__ == \"__main__\":\n\t    run()\n"]}
{"filename": "examples/use_case/plot.py", "chunked_list": ["\"\"\"Plot currentscape.\"\"\"\n\t# Copyright 2023 Blue Brain Project / EPFL\n\t# Licensed under the Apache License, Version 2.0 (the \"License\");\n\t# you may not use this file except in compliance with the License.\n\t# You may obtain a copy of the License at\n\t#     http://www.apache.org/licenses/LICENSE-2.0\n\t# Unless required by applicable law or agreed to in writing, software\n\t# distributed under the License is distributed on an \"AS IS\" BASIS,\n\t# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t# See the License for the specific language governing permissions and\n", "# limitations under the License.\n\tfrom pathlib import Path\n\timport numpy as np\n\timport currentscape\n\tfrom run import absolute_path\n\tdef plot():\n\t    data_dir = absolute_path(\"python_recordings\")\n\t    currs = [\n\t        \"i_pas\",\n\t        \"ihcn_Ih\",\n", "        \"ica_Ca_HVA2\",\n\t        \"ica_Ca_LVAst\",\n\t        \"ik_SK_E2\",\n\t        \"ik_SKv3_1\",\n\t        \"ik_K_Pst\",\n\t        \"ik_K_Tst\",\n\t        \"ina_NaTg\",\n\t    ]\n\t    ionic_concentrations = [\"cai\", \"ki\", \"nai\"]\n\t    # load voltage data\n", "    v_path = Path(data_dir) / \"v.dat\"\n\t    voltage = np.loadtxt(v_path)[:, 1] # load 2nd column. 1st column is time.\n\t    # load currents from files\n\t    currents = []\n\t    for curr in currs:\n\t        file_path = Path(data_dir) / f\"{curr}.dat\"\n\t        currents.append(np.loadtxt(file_path)[:, 1]) # load 2nd column. 1st column is time.\n\t    currents = np.array(currents)\n\t    # load ionic concentrations from files\n\t    ions = []\n", "    for ion in ionic_concentrations:\n\t        file_path = Path(data_dir) / f\"{ion}.dat\"\n\t        ions.append(np.loadtxt(file_path)[:, 1]) # load 2nd column. 1st column is time.\n\t    ions = np.array(ions)\n\t    # define config\n\t    # can pass a config file\n\t    # config = absolute_path(\"path/to/config\")\n\t    # can also pass config as a dictionnary\n\t    curr_names = [\"pas\", \"Ih\", \"Ca_HVA2\", \"Ca_LVAst\", \"SK_E2\", \"SKv3_1\", \"K_Pst\", \"K_Tst\", \"NaTg\"]\n\t    config = {\n", "        \"current\": {\"names\": curr_names},\n\t        \"ions\":{\"names\": [\"ca\", \"k\", \"na\"]},\n\t        \"legendtextsize\": 5,\n\t    }\n\t    # produce currentscape figure\n\t    fig = currentscape.plot(voltage, currents, config, ions)\n\t    return fig\n\tif __name__ == \"__main__\":\n\t    fig = plot()\n\t    fig.show()\n"]}
{"filename": "examples/use_case/__init__.py", "chunked_list": []}
{"filename": "examples/original_paper_plot/integrate_single_compartment_and_plot_currentscape.py", "chunked_list": ["\"\"\"Script based from https://datadryad.org/stash/dataset/doi:10.5061/dryad.d0779mb\n\t    under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication license.\n\t\"\"\"\n\t# Preliminaries and Modules\n\timport numpy as np\n\tfrom scipy.integrate import odeint\n\tfrom single_compartment import single_compartment\n\tfrom get_currents import model\n\timport currentscape\n\tdef plot_from_original_paper(t0=0.0, tf=10000.0, dt=0.1):\n", "    \"\"\"Plot currentscape using original paper data.\n\t    Args:\n\t        t0 (float): begin time of simulation (in ms)\n\t        tf (float): end time of simulation (in ms)\n\t        dt (float): time step (in ms)\n\t    \"\"\"\n\t    # specify the path to initial conditions and paramters files\n\t    config = \"config.json\"\n\t    pathtocis = (\n\t        \"parameters-and-initial-conditions/initial-conditions.txt\"\n", "    )\n\t    pathtoparameters = (\n\t        \"parameters-and-initial-conditions/model-A-name-HZFTSB.txt\"\n\t    )\n\t    # load initialconditions and parameters\n\t    y0 = np.genfromtxt(pathtocis)\n\t    parameters = np.genfromtxt(pathtoparameters)\n\t    # define temperature (set to 10 C)\n\t    temp = 10\n\t    # define integration interval and temporal resolution\n", "    t = np.arange(t0, tf, dt)\n\t    # integration is performed using odeint, a built-in python package to integrate Ordinary Differential Equations\n\t    fullsolution = odeint(\n\t        single_compartment,\n\t        y0,\n\t        t,\n\t        args=(\n\t            parameters,\n\t            temp,\n\t        ),\n", "    )\n\t    # define voltage and currents for currentscape plotting\n\t    voltage = fullsolution[:, 0]\n\t    currents = model(fullsolution, parameters, temp)\n\t    # plot currentscape (full temporal range)\n\t    fig = currentscape.plot(voltage, currents, config)\n\tif __name__ == \"__main__\":\n\t    plot_from_original_paper()\n"]}
{"filename": "examples/original_paper_plot/get_currents.py", "chunked_list": ["\"\"\"Script taken from https://datadryad.org/stash/dataset/doi:10.5061/dryad.d0779mb\n\t    under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication license.\"\"\"\n\tfrom numpy import *\n\timport numpy as np\n\t# Time constant functions\n\tdef tauX(Volt, CT, DT, AT, BT):\n\t    timeconst = CT - DT / (1.0 + np.exp((Volt + AT) / BT))\n\t    return timeconst\n\t# Special time constant function (spectau)\n\tdef spectau(Volt, CT, DT, AT, BT, AT2, BT2):\n", "    spec = CT + DT / (np.exp((Volt + AT) / BT) + np.exp((Volt + AT2) / BT2))\n\t    return spec\n\t# Ionic currents\n\t# q is the exponent of the activation variable m\n\tdef iIonic(g, m, h, q, Volt, Erev):\n\t    flux = g * pow(m, q) * h * (Volt - Erev)\n\t    return flux\n\t# Concentration dependent Ca reversal potential\n\tdef CaNernst(CaIn, temp):\n\t    R = 8.314 * pow(10, 3)  # Ideal Gas Constant (*10^3 to put into mV)\n", "    T = 273.15 + temp  # Temperature in Kelvin\n\t    z = 2.0  # Valence of Caclium Ions\n\t    Far = 96485.33  # Faraday's Constant\n\t    CaOut = 3000.0  # Outer Ca Concentration (uM)\n\t    CalRev = ((R * T) / (z * Far)) * np.log(CaOut / CaIn)\n\t    # print 'calrev ', CalRev\n\t    return CalRev\n\tdef model(v, p, temp):\n\t    reftemp = 10\n\t    V = v[:, 0]\n", "    NaM = v[:, 1]\n\t    NaH = v[:, 2]\n\t    CaTM = v[:, 3]\n\t    CaTH = v[:, 4]\n\t    CaSM = v[:, 5]\n\t    CaSH = v[:, 6]\n\t    HM = v[:, 7]\n\t    KdM = v[:, 8]\n\t    KCaM = v[:, 9]\n\t    AM = v[:, 10]\n", "    AH = v[:, 11]\n\t    IntCa = v[:, 12]\n\t    CaRev = CaNernst(IntCa, temp)\n\t    tauIntCa = p[35]  # Calcium buffer time constant (ms)\n\t    # Maximal Conductances\n\t    gNa = p[0]  # Transient Sodium Maximal Conductance\n\t    gCaT = p[1]  # Low Threshold Calcium Maximal Conductance\n\t    gCaS = p[2]  # Slow Calcium Maximal Conductance\n\t    gA = p[3]  # Transient Potassium Maximal Conductance\n\t    gKCa = p[4]  # Calcium Dependent Potassium Maximal Conductance\n", "    gKd = p[5]  # Potassium Maximal Conductance\n\t    gH = p[6]  # Hyperpolarization Activated Cation Maximal Conductance\n\t    gL = p[7]  # Leak Maximal Conductance\n\t    # p_Erev = [e_leak,e_na,e_k,e_h]\n\t    EL = p[8]  # Leak Reversal Potential\n\t    ENa = p[9]  # Sodium Reversal Potential\n\t    ECaT = CaRev  # Low Threshold Calcium Reversal Potential\n\t    ECaS = CaRev  # Slow Calcium Reversal Potential\n\t    EKd = p[10]  # Potassium Reversal Potential\n\t    EKCa = p[10]  # Calcium Dependent Potassium Reversal Potential\n", "    EA = p[10]  # Transient Potassium Reversal Potential\n\t    EH = p[11]  # Hyperpolarization Activated Cation Reversal Potential\n\t    q10_gNa = p[12]\n\t    q10_gNa_m = p[13]\n\t    q10_gNa_h = p[14]\n\t    q10_gCaT = p[15]\n\t    q10_gCaT_m = p[16]\n\t    q10_gCaT_h = p[17]\n\t    q10_gCaS = p[18]\n\t    q10_gCaS_m = p[19]\n", "    q10_gCaS_h = p[20]\n\t    q10_gA = p[21]\n\t    q10_gA_m = p[22]\n\t    q10_gA_h = p[23]\n\t    q10_gKCa = p[24]\n\t    q10_gKCa_m = p[25]\n\t    q10_gKdr = p[27]\n\t    q10_gKdr_m = p[28]\n\t    q10_gH = p[30]\n\t    q10_gH_m = p[31]\n", "    q10_g_leak = p[33]\n\t    q10_tau_Ca = p[34]\n\t    # Time Constants (ms)\n\t    tauNaM = tauX(V, 1.32, 1.26, 120.0, -25.0)\n\t    tauNaM = tauNaM * pow(q10_gNa_m, -(temp - reftemp) / 10.0)\n\t    tauNaH = tauX(V, 0.0, -0.67, 62.9, -10.0) * tauX(V, 1.50, -1.00, 34.9, 3.60)\n\t    tauNaH = tauNaH * pow(q10_gNa_h, -(temp - reftemp) / 10.0)\n\t    tauCaTM = tauX(V, 21.7, 21.3, 68.1, -20.5)\n\t    tauCaTM = tauCaTM * pow(q10_gCaT_m, -(temp - reftemp) / 10.0)\n\t    tauCaTH = tauX(V, 105.0, 89.8, 55.0, -16.9)\n", "    tauCaTH = tauCaTH * pow(q10_gCaT_h, -(temp - reftemp) / 10.0)\n\t    tauCaSM = spectau(V, 1.40, 7.00, 27.0, 10.0, 70.0, -13.0)\n\t    tauCaSM = tauCaSM * pow(q10_gCaS_m, -(temp - reftemp) / 10.0)\n\t    tauCaSH = spectau(V, 60.0, 150.0, 55.0, 9.00, 65.0, -16.0)\n\t    tauCaSH = tauCaSH * pow(q10_gCaS_h, -(temp - reftemp) / 10.0)\n\t    tauHM = tauX(V, 272.0, -1499.0, 42.2, -8.73)\n\t    tauHM = tauHM * pow(q10_gH_m, -(temp - reftemp) / 10.0)\n\t    tauKdM = tauX(V, 7.20, 6.40, 28.3, -19.2)\n\t    tauKdM = tauKdM * pow(q10_gKdr_m, -(temp - reftemp) / 10.0)\n\t    tauKCaM = tauX(V, 90.3, 75.1, 46.0, -22.7)\n", "    tauKCaM = tauKCaM * pow(q10_gKCa_m, -(temp - reftemp) / 10.0)\n\t    tauAM = tauX(V, 11.6, 10.4, 32.9, -15.2)\n\t    tauAM = tauAM * pow(q10_gA_m, -(temp - reftemp) / 10.0)\n\t    tauAH = tauX(V, 38.6, 29.2, 38.9, -26.5)\n\t    tauAH = tauAH * pow(q10_gA_h, -(temp - reftemp) / 10.0)\n\t    gNa = gNa * pow(q10_gNa, (temp - reftemp) / 10.0)\n\t    gCaT = gCaT * pow(q10_gCaT, (temp - reftemp) / 10.0)\n\t    gCaS = gCaS * pow(q10_gCaS, (temp - reftemp) / 10.0)\n\t    gA = gA * pow(q10_gA, (temp - reftemp) / 10.0)\n\t    gKCa = gKCa * pow(q10_gKCa, (temp - reftemp) / 10.0)\n", "    gKd = gKd * pow(q10_gKdr, (temp - reftemp) / 10.0)\n\t    gH = gH * pow(q10_gH, (temp - reftemp) / 10.0)\n\t    gL = gL * pow(q10_g_leak, (temp - reftemp) / 10.0)\n\t    tauIntCa = tauIntCa * pow(q10_tau_Ca, -(temp - reftemp) / 10.0)\n\t    # Ionic Currents (mV / ms)\n\t    iNa = iIonic(gNa, NaM, NaH, 3, V, ENa)\n\t    iCaT = iIonic(gCaT, CaTM, CaTH, 3, V, ECaT)\n\t    iCaS = iIonic(gCaS, CaSM, CaSH, 3, V, ECaS)\n\t    iH = iIonic(gH, HM, 1, 1, V, EH)\n\t    iKd = iIonic(gKd, KdM, 1, 4, V, EKd)\n", "    iKCa = iIonic(gKCa, KCaM, 1, 4, V, EKCa)\n\t    iA = iIonic(gA, AM, AH, 3, V, EA)\n\t    iL = iIonic(gL, 1, 1, 1, V, EL)\n\t    r = [iNa, iCaT, iCaS, iA, iKCa, iKd, iH, iL]\n\t    return r\n"]}
{"filename": "examples/original_paper_plot/__init__.py", "chunked_list": []}
{"filename": "examples/original_paper_plot/single_compartment.py", "chunked_list": ["\"\"\"Script taken from https://datadryad.org/stash/dataset/doi:10.5061/dryad.d0779mb\n\t    under the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication license.\"\"\"\n\timport numpy as np\n\tdef single_compartment(v, t, p, temp):\n\t    V = v[0]\n\t    NaM = v[1]\n\t    NaH = v[2]\n\t    CaTM = v[3]\n\t    CaTH = v[4]\n\t    CaSM = v[5]\n", "    CaSH = v[6]\n\t    HM = v[7]\n\t    KdM = v[8]\n\t    KCaM = v[9]\n\t    AM = v[10]\n\t    AH = v[11]\n\t    IntCa = v[12]\n\t    CaRev = CaNernst(IntCa, temp)\n\t    C = 1.0 * 10  #  // Capacitance (uF / cm^2)\n\t    #    // Ionic Currents (mV / ms)\n", "    #    // double caF = p.get(17);  // Current (nA) to Concentration (uM) Conversion Factor (uM / nA)\n\t    #    // double Ca0 = p.get(18);  // Background Intracellular Calcium Concentration (uM)\n\t    #    // these numbers below convert calcium current to calcium concentration and have not been measured so people change them.\n\t    caF = 0.94\n\t    Ca0 = 0.05\n\t    reftemp = 10\n\t    #     //activation timescale of imi appears to be constant (golowash92)\n\t    tauIntCa = p[35]  # // Calcium buffer time constant (ms)\n\t    #     // Equilibrium Points of Calcium Sensors\n\t    #     // p_g=[gNa, gCaT,gCaS,gA,gKCa,gKd,gH,g_leak]\n", "    #     // Fixed Maximal Conductances\n\t    gNa = p[0]  # // Transient Sodium Maximal Conductance\n\t    gCaT = p[1]  # // Low Threshold Calcium Maximal Conductance\n\t    gCaS = p[2]  # // Slow Calcium Maximal Conductance\n\t    gA = p[3]  # // Transient Potassium Maximal Conductance\n\t    gKCa = p[4]  # // Calcium Dependent Potassium Maximal Conductance\n\t    gKd = p[5]  # // Potassium Maximal Conductance\n\t    gH = p[6]  # // Hyperpolarization Activated Cation Maximal Conductance\n\t    gL = p[7]  # // Leak Maximal Conductance\n\t    EL = p[8]  #   // Leak Reversal Potential\n", "    ENa = p[9]  #  // Sodium Reversal Potential\n\t    ECaT = CaRev  #    // Low Threshold Calcium Reversal Potential\n\t    ECaS = CaRev  #   // Slow Calcium Reversal Potential\n\t    EKd = p[10]  #   // Potassium Reversal Potential\n\t    EKCa = p[10]  #  // Calcium Dependent Potassium Reversal Potential\n\t    EA = p[10]  #    // Transient Potassium Reversal Potential\n\t    EH = p[11]  #    // Hyperpolarization Activated Cation Reversal Potential\n\t    q10_gNa = p[12]\n\t    q10_gNa_m = p[13]\n\t    q10_gNa_h = p[14]\n", "    q10_gCaT = p[15]\n\t    q10_gCaT_m = p[16]\n\t    q10_gCaT_h = p[17]\n\t    q10_gCaS = p[18]\n\t    q10_gCaS_m = p[19]\n\t    q10_gCaS_h = p[20]\n\t    q10_gA = p[21]\n\t    q10_gA_m = p[22]\n\t    q10_gA_h = p[23]\n\t    q10_gKCa = p[24]\n", "    q10_gKCa_m = p[25]\n\t    q10_gKdr = p[27]\n\t    q10_gKdr_m = p[28]\n\t    q10_gH = p[30]\n\t    q10_gH_m = p[31]\n\t    q10_g_leak = p[33]\n\t    q10_tau_Ca = p[34]\n\t    #     Applied Current\n\t    Iapp = p[36]\n\t    #     Steady State Gating Variables\n", "    NaMinf = boltzSS(V, 25.5, -5.29)  # ;  // m^3\n\t    NaHinf = boltzSS(V, 48.9, 5.18)  # ;  // h\n\t    CaTMinf = boltzSS(V, 27.1, -7.20)  # ;  // m^3\n\t    CaTHinf = boltzSS(V, 32.1, 5.50)  # ;  // h\n\t    CaSMinf = boltzSS(V, 33.0, -8.1)  # ;  // m^3\n\t    CaSHinf = boltzSS(V, 60.0, 6.20)  # ;  // h\n\t    HMinf = boltzSS(V, 70.0, 6.0)  # ;  // m\n\t    KdMinf = boltzSS(V, 12.3, -11.8)  # ;  // m^4\n\t    KCaMinf = (IntCa / (IntCa + 3.0)) * boltzSS(V, 28.3, -12.6)  # ;  // m^4\n\t    AMinf = boltzSS(V, 27.2, -8.70)  # ;  // m^3\n", "    AHinf = boltzSS(V, 56.9, 4.90)  # ;  // h\n\t    # // Time Constants (ms)\n\t    tauNaM = tauX(V, 1.32, 1.26, 120.0, -25.0)\n\t    tauNaM = tauNaM * pow(q10_gNa_m, -(temp - reftemp) / 10.0)\n\t    tauNaH = tauX(V, 0.0, -0.67, 62.9, -10.0) * tauX(V, 1.50, -1.00, 34.9, 3.60)\n\t    tauNaH = tauNaH * pow(q10_gNa_h, -(temp - reftemp) / 10.0)\n\t    tauCaTM = tauX(V, 21.7, 21.3, 68.1, -20.5)\n\t    tauCaTM = tauCaTM * pow(q10_gCaT_m, -(temp - reftemp) / 10.0)\n\t    tauCaTH = tauX(V, 105.0, 89.8, 55.0, -16.9)\n\t    tauCaTH = tauCaTH * pow(q10_gCaT_h, -(temp - reftemp) / 10.0)\n", "    tauCaSM = spectau(V, 1.40, 7.00, 27.0, 10.0, 70.0, -13.0)\n\t    tauCaSM = tauCaSM * pow(q10_gCaS_m, -(temp - reftemp) / 10.0)\n\t    tauCaSH = spectau(V, 60.0, 150.0, 55.0, 9.00, 65.0, -16.0)\n\t    tauCaSH = tauCaSH * pow(q10_gCaS_h, -(temp - reftemp) / 10.0)\n\t    tauHM = tauX(V, 272.0, -1499.0, 42.2, -8.73)\n\t    tauHM = tauHM * pow(q10_gH_m, -(temp - reftemp) / 10.0)\n\t    tauKdM = tauX(V, 7.20, 6.40, 28.3, -19.2)\n\t    tauKdM = tauKdM * pow(q10_gKdr_m, -(temp - reftemp) / 10.0)\n\t    tauKCaM = tauX(V, 90.3, 75.1, 46.0, -22.7)\n\t    tauKCaM = tauKCaM * pow(q10_gKCa_m, -(temp - reftemp) / 10.0)\n", "    tauAM = tauX(V, 11.6, 10.4, 32.9, -15.2)\n\t    tauAM = tauAM * pow(q10_gA_m, -(temp - reftemp) / 10.0)\n\t    tauAH = tauX(V, 38.6, 29.2, 38.9, -26.5)\n\t    tauAH = tauAH * pow(q10_gA_h, -(temp - reftemp) / 10.0)\n\t    gNa = gNa * pow(q10_gNa, (temp - reftemp) / 10.0)\n\t    gCaT = gCaT * pow(q10_gCaT, (temp - reftemp) / 10.0)\n\t    gCaS = gCaS * pow(q10_gCaS, (temp - reftemp) / 10.0)\n\t    gA = gA * pow(q10_gA, (temp - reftemp) / 10.0)\n\t    gKCa = gKCa * pow(q10_gKCa, (temp - reftemp) / 10.0)\n\t    gH = gH * pow(q10_gH, (temp - reftemp) / 10.0)\n", "    gKd = gKd * pow(q10_gKdr, (temp - reftemp) / 10.0)\n\t    gL = gL * pow(q10_g_leak, (temp - reftemp) / 10.0)\n\t    tauIntCa = tauIntCa * pow(q10_tau_Ca, -(temp - reftemp) / 10.0)\n\t    iNa = iIonic(gNa, NaM, NaH, 3, V, ENa)\n\t    iCaT = iIonic(gCaT, CaTM, CaTH, 3, V, ECaT)\n\t    iCaS = iIonic(gCaS, CaSM, CaSH, 3, V, ECaS)\n\t    iH = iIonic(gH, HM, 1, 1, V, EH)\n\t    iKd = iIonic(gKd, KdM, 1, 4, V, EKd)\n\t    iKCa = iIonic(gKCa, KCaM, 1, 4, V, EKCa)\n\t    iA = iIonic(gA, AM, AH, 3, V, EA)\n", "    iL = iIonic(gL, 1, 1, 1, V, EL)\n\t    #    // State Equations\n\t    #    // Voltage Time Evolution: C*dV/dt = -I_ionic + I_applied; I_ionic = sum(g_i*m^q*h*(V - E_i))\n\t    # // double dV = (-(iNa + iCaT + iCaS + iH + iKd + iKCa + iA + iL) + iSyns + Iapp)/C;\n\t    # // double intrinsic_currents = iNa + iCaT + iCaS + iH + iKd + iKCa + iA + iL;\n\t    # // cout << intrinsic_currents <<endl;\n\t    dV = (-(iNa + iCaT + iCaS + iH + iKd + iKCa + iA + iL) + Iapp) / C\n\t    # // Gating Variable Time Evolution: dX/dt = (X_inf - X)/tau_X\n\t    dNaM = (NaMinf - NaM) / tauNaM\n\t    dNaH = (NaHinf - NaH) / tauNaH\n", "    dCaTM = (CaTMinf - CaTM) / tauCaTM\n\t    dCaTH = (CaTHinf - CaTH) / tauCaTH\n\t    dCaSM = (CaSMinf - CaSM) / tauCaSM\n\t    dCaSH = (CaSHinf - CaSH) / tauCaSH\n\t    dHM = (HMinf - HM) / tauHM\n\t    dKdM = (KdMinf - KdM) / tauKdM\n\t    dKCaM = (KCaMinf - KCaM) / tauKCaM\n\t    dAM = (AMinf - AM) / tauAM\n\t    dAH = (AHinf - AH) / tauAH\n\t    dIntCa = (-caF * (iCaT + iCaS) - IntCa + Ca0) / tauIntCa\n", "    y_dot = np.zeros(13)\n\t    y_dot[0] = dV\n\t    y_dot[1] = dNaM\n\t    y_dot[2] = dNaH\n\t    y_dot[3] = dCaTM\n\t    y_dot[4] = dCaTH\n\t    y_dot[5] = dCaSM\n\t    y_dot[6] = dCaSH\n\t    y_dot[7] = dHM\n\t    y_dot[8] = dKdM\n", "    y_dot[9] = dKCaM\n\t    y_dot[10] = dAM\n\t    y_dot[11] = dAH\n\t    y_dot[12] = dIntCa\n\t    return y_dot\n\tdef boltzSS(Volt, A, B):\n\t    act = 1.0 / (1.0 + np.exp((Volt + A) / B))\n\t    return act\n\t# // Time constants of activation-inactivation\n\tdef tauX(Volt, CT, DT, AT, BT):\n", "    timeconst = CT - DT / (1.0 + np.exp((Volt + AT) / BT))\n\t    return timeconst\n\t# // Some currents require a special time constant function\n\tdef spectau(Volt, CT, DT, AT, BT, AT2, BT2):\n\t    spec = CT + DT / (np.exp((Volt + AT) / BT) + np.exp((Volt + AT2) / BT2))\n\t    return spec\n\tdef iIonic(g, m, h, q, Volt, Erev):\n\t    flux = g * pow(m, q) * h * (Volt - Erev)\n\t    return flux\n\t# // Concentration dependent Ca reversal potential\n", "def CaNernst(CaIn, temp):\n\t    R = 8.314 * pow(10, 3)  # Ideal Gas Constant (*10^3 to put into mV)\n\t    T = 273.15 + temp  # Temperature in Kelvin\n\t    z = 2.0  # Valence of Calcium Ions\n\t    Far = 96485.33  # Faraday's Constant\n\t    CaOut = 3000.0  # Outer Ca Concentration (uM)\n\t    CalRev = ((R * T) / (z * Far)) * np.log10(CaOut / CaIn)\n\t    return CalRev\n"]}
