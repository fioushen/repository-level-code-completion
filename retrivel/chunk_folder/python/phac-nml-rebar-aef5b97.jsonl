{"filename": "setup.py", "chunked_list": ["from setuptools import setup\n\tdef get_version():\n\t    version = \"0.0.0\"\n\t    with open(\"rebar/__init__.py\") as ifile:\n\t        for line in ifile:\n\t            if line[:7] == \"version\":\n\t                version = line.split(\"=\")[-1].strip()[1:-1]\n\t                break\n\t    return version\n\twith open(\"README.md\", \"r\") as fh:\n", "    long_description = fh.read()\n\twith open(\"requirements.txt\", \"r\") as r:\n\t    require_list = r.read().strip().split(\"\\n\")\n\tsetup(\n\t    name=\"bio-rebar\",\n\t    version=get_version(),\n\t    author=\"Katherine Eaton\",\n\t    author_email=\"katherine.eaton@phac-aspc.gc.ca\",\n\t    description=(\"REcombination BARcode detection for SARS-CoV-2.\"),\n\t    long_description=long_description,\n", "    long_description_content_type=\"text/markdown\",\n\t    license=\"MIT\",\n\t    keywords=\"SARS-CoV-2, recombination\",\n\t    url=\"https://github.com/phac-nml/rebar\",\n\t    packages=[\"rebar\"],\n\t    install_requires=require_list,\n\t    entry_points={\n\t        \"console_scripts\": [\n\t            \"rebar = rebar.__main__:main\",\n\t        ]\n", "    },\n\t)\n"]}
{"filename": "test/test_wrappers.py", "chunked_list": ["from rebar import utils, wrappers\n\timport os\n\tdef test_dataset_sarscov2_latest(params):\n\t    \"\"\"Test function wrappers.dataset.\"\"\"\n\t    params.outdir = \"test/tmp/wrappers/dataset/sars-cov-2-latest\"\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t    wrappers.dataset(params)\n\tdef test_run_sarscov2_latest(params):\n", "    \"\"\"Test function wrappers.run.\"\"\"\n\t    params.outdir = \"test/tmp/wrappers/run\"\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    # Disable alignment, we'll use lineage list from conftest\n\t    params.alignment = None\n\t    params.dataset = \"test/tmp/wrappers/dataset/sars-cov-2-latest\"\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t    wrappers.run(params)\n\t# def test_no_lineages_or_alignment(params):\n", "#     \"\"\"Test function wrappers.run with missing lineages and alignment.\"\"\"\n\t#     params.outdir = \"test/tmp/wrappers/no_lineages_or_alignment\"\n\t#     if not os.path.exists(params.outdir):\n\t#         os.makedirs(params.outdir)\n\t#     params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t#     params.alignment = None\n\t#     params.lineages = None\n\t#     wrappers.run(params)\n"]}
{"filename": "test/__init__.py", "chunked_list": []}
{"filename": "test/test.py", "chunked_list": ["#!/usr/bin/env python3\n\timport subprocess\n\timport sys\n\timport shutil\n\timport os\n\ttmp_dir = \"test/tmp\"\n\tif os.path.exists(tmp_dir):\n\t    shutil.rmtree(tmp_dir, ignore_errors=True)\n\tcmd_str = (\n\t    \"python -m coverage run -m pytest --cov=rebar --cov-report=html --cov-report=xml\"\n", "    \" test/test_wrappers.py\"\n\t    # `test_edge_cases`` depends on `test_wrappers`` to be run first\n\t    # \" test/test_edge_cases.py\"\n\t    # `test_utils` is the biggest test suite, and takes the longest(?)\n\t    \" test/test_utils.py\"\n\t)\n\tresult = subprocess.run(cmd_str, shell=True)\n\t# I'm not 100% sure this is necessary to pass the subprocess return code\n\t# mostly, I want CI to properly fail if a test failed\n\tsys.exit(result.returncode)\n"]}
{"filename": "test/test_utils.py", "chunked_list": ["from rebar import utils\n\timport os\n\tfrom Bio import SeqIO\n\timport yaml\n\tdef test_create_logger_stdout():\n\t    \"\"\"Test function utils.create_logger to standard out.\"\"\"\n\t    utils.create_logger()\n\tdef test_create_logger_file(params):\n\t    \"\"\"Test function utils.create_logger to file.\"\"\"\n\t    params.outdir = \"test/tmp/create_logger\"\n", "    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\tdef test_download_reference_sequence(params):\n\t    \"\"\"Test function utils.download_reference_sequence.\"\"\"\n\t    params.outdir = params.dataset\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t    accession = \"MN908947.3\"\n", "    info = utils.download_reference_sequence(params, accession=accession)\n\t    fasta_path = os.path.join(params.outdir, \"reference.fasta\")\n\t    records = list(SeqIO.parse(fasta_path, \"fasta\"))\n\t    # Export info, we need this for create_dataset_yaml\n\t    info_yaml = yaml.dump(info, sort_keys=False, indent=2)\n\t    info_path = os.path.join(params.outdir, \"reference.yaml\")\n\t    with open(info_path, \"w\") as outfile:\n\t        outfile.write(info_yaml + \"\\n\")\n\t    assert len(records) == 1\n\tdef test_download_consensus_sequences(params):\n", "    \"\"\"Test function utils.download_consensus_sequences.\"\"\"\n\t    params.outdir = params.dataset\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t    info = utils.download_consensus_sequences(params)\n\t    fasta_path = os.path.join(params.outdir, \"alignment.fasta\")\n\t    records = list(SeqIO.parse(fasta_path, \"fasta\"))\n\t    # Export info, we need this for create_dataset_yaml\n\t    info_yaml = yaml.dump(info, sort_keys=False, indent=2)\n", "    info_path = os.path.join(params.outdir, \"sequences.yaml\")\n\t    with open(info_path, \"w\") as outfile:\n\t        outfile.write(info_yaml + \"\\n\")\n\t    assert len(records) > 1500\n\tdef test_create_tree(params):\n\t    \"\"\"Test function utils.create_tree.\"\"\"\n\t    params.outdir = params.dataset\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n", "    info = utils.create_tree(params)\n\t    # Export info, we need this for create_dataset_yaml\n\t    info_yaml = yaml.dump(info, sort_keys=False, indent=2)\n\t    info_path = os.path.join(params.outdir, \"tree.yaml\")\n\t    with open(info_path, \"w\") as outfile:\n\t        outfile.write(info_yaml + \"\\n\")\n\tdef test_create_barcodes(params):\n\t    \"\"\"Test function utils.create_barcodes.\"\"\"\n\t    params.outdir = params.dataset\n\t    if not os.path.exists(params.outdir):\n", "        os.makedirs(params.outdir)\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t    info = utils.create_barcodes(params)\n\t    # Export info, we need this for create_dataset_yaml\n\t    info_yaml = yaml.dump(info, sort_keys=False, indent=2)\n\t    info_path = os.path.join(params.outdir, \"barcodes.yaml\")\n\t    with open(info_path, \"w\") as outfile:\n\t        outfile.write(info_yaml + \"\\n\")\n\tdef test_create_barcodes_diagnostic(params):\n\t    \"\"\"Test function utils.create_barcodes_diagnostic.\"\"\"\n", "    params.outdir = params.dataset\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t    params.tree = os.path.join(params.outdir, \"tree.nwk\")\n\t    params.barcodes = os.path.join(params.outdir, \"barcodes.tsv\")\n\t    utils.create_barcodes_diagnostic(params)\n\tdef test_create_annotations(params):\n\t    \"\"\"Test function utils.create_annotations.\"\"\"\n\t    params.outdir = params.dataset\n", "    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t    utils.create_annotations(params)\n\tdef test_create_dataset_yaml(params):\n\t    \"\"\"\n\t    Test creating the dataset yaml from various sources.\n\t    Uses the output of download_reference_sequence, download_consensus_sequences,\n\t    create_tree, create_barcodes.\n\t    \"\"\"\n", "    params.outdir = params.dataset\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t    # Import dataset info\n\t    info = {\"name\": params.name, \"tag\": params.tag}\n\t    for source in [\"reference\", \"sequences\", \"tree\", \"barcodes\"]:\n\t        info_path = os.path.join(params.dataset, \"{}.yaml\".format(source))\n\t        with open(info_path, \"r\") as infile:\n\t            info[source] = yaml.safe_load(infile)\n", "    info_yaml = yaml.dump(info, sort_keys=False, indent=2)\n\t    info_path = os.path.join(params.outdir, \"dataset.yaml\")\n\t    with open(info_path, \"w\") as outfile:\n\t        outfile.write(info_yaml + \"\\n\")\n\tdef test_parse_alignment(params):\n\t    \"\"\"Test function utils.parse_alignment on few samples.\"\"\"\n\t    params.outdir = \"test/tmp/parse_alignment\"\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n", "    records = SeqIO.parse(params.alignment, \"fasta\")\n\t    test_lineages = [\"XA\", \"XB\"]\n\t    fasta_lines = []\n\t    for record in records:\n\t        if record.id in test_lineages:\n\t            fasta_lines.append(\">\" + record.id)\n\t            fasta_lines.append(str(record.seq))\n\t    fasta_path = os.path.join(params.outdir, \"alignment.fasta\")\n\t    with open(fasta_path, \"w\") as outfile:\n\t        outfile.write(\"\\n\".join(fasta_lines) + \"\\n\")\n", "    params.alignment = fasta_path\n\t    utils.parse_alignment(params)\n\tdef test_parse_alignment_mp(params):\n\t    \"\"\"\n\t    Test function utils.parse_alignment with multi-processing.\n\t    Uses the output of test_parse_alignment.\n\t    \"\"\"\n\t    params.outdir = \"test/tmp/parse_alignment_mp\"\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n", "    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t    params.threads = 2\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n\t    utils.parse_alignment(params)\n\tdef test_detect_recombination(params):\n\t    \"\"\"Test function utils.detect_recombination.\"\"\"\n\t    params.outdir = \"test/tmp/detect_recombination\"\n\t    if not os.path.exists(params.outdir):\n\t        os.makedirs(params.outdir)\n", "    params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t    utils.detect_recombination(params)\n"]}
{"filename": "test/conftest.py", "chunked_list": ["import os\n\timport pytest\n\tfrom rebar import utils\n\tfrom rebar.constants import (\n\t    MASK,\n\t    MAX_DEPTH,\n\t    MIN_LENGTH,\n\t    MIN_SUBS,\n\t    MIN_CONSECUTIVE,\n\t    MAX_BREAKPOINTS,\n", "    PLOT_EXT,\n\t)\n\t@pytest.fixture(scope=\"module\")\n\tdef params():\n\t    \"\"\"Return a NameSpace of generic testing params.\"\"\"\n\t    dataset = \"test/tmp/dataset/sars-cov-2-latest\"\n\t    name = \"sars-cov-2\"\n\t    tag = \"latest\"\n\t    params = utils.Namespace(\n\t        outdir=\"\",\n", "        logger=utils.create_logger(),\n\t        threads=1,\n\t        debug=True,\n\t        dataset=dataset,\n\t        reference=os.path.join(dataset, \"reference.fasta\"),\n\t        alignment=os.path.join(dataset, \"alignment.fasta\"),\n\t        tree=os.path.join(dataset, \"tree.nwk\"),\n\t        barcodes=os.path.join(dataset, \"barcodes.tsv\"),\n\t        lineage_to_clade=os.path.join(dataset, \"lineage_to_clade.tsv\"),\n\t        subs=\"test/tmp/parse_alignment/subs.tsv\",\n", "        mask=MASK,\n\t        max_depth=MAX_DEPTH,\n\t        min_length=MIN_LENGTH,\n\t        min_subs=MIN_SUBS,\n\t        min_consecutive=MIN_CONSECUTIVE,\n\t        max_breakpoints=MAX_BREAKPOINTS,\n\t        plot_ext=PLOT_EXT,\n\t        edge_cases=True,\n\t        output_all=True,\n\t        output_fasta=True,\n", "        output_tsv=True,\n\t        output_barcode=True,\n\t        output_plot=True,\n\t        output_yaml=True,\n\t        exclude_non_recomb=False,\n\t        shared=False,\n\t        # dataset\n\t        name=name,\n\t        tag=tag,\n\t        # run\n", "        lineages=\"AY.4,BA.5.2,XD,XBB.1.5.1,XBL\",\n\t        validate=True,\n\t    )\n\t    return params\n\t@pytest.fixture(scope=\"module\")\n\tdef edge_cases_expected():\n\t    \"\"\"Return dictionary of expected values for edge case lineages.\"\"\"\n\t    edge_cases_expected = {\n\t        \"XB\": {\n\t            \"min_length\": 100,\n", "        },\n\t        \"XP\": {\n\t            \"min_consecutive\": 1,\n\t            \"min_length\": 1,\n\t        },\n\t        \"XR\": {\n\t            \"min_subs\": 0,\n\t            \"min_consecutive\": 2,\n\t        },\n\t        \"XAD\": {\"min_consecutive\": 5},\n", "        \"XAE\": {\"min_consecutive\": 5},\n\t        \"XAJ\": {\n\t            \"min_length\": 4,\n\t        },\n\t        \"XAS\": {},\n\t        \"XAV\": {\n\t            \"min_subs\": 0,\n\t            \"min_consecutive\": 2,\n\t        },\n\t        \"XAY\": {\"min_length\": 200},\n", "        \"XAZ\": {\n\t            \"min_subs\": 0,\n\t            \"min_consecutive\": 1,\n\t            \"min_length\": 1,\n\t        },\n\t        \"XBC\": {\n\t            \"min_consecutive\": 2,\n\t        },\n\t        \"XBK\": {\n\t            \"min_consecutive\": 2,\n", "        },\n\t        \"XBQ\": {\n\t            \"min_consecutive\": 2,\n\t        },\n\t        \"XBZ\": {\n\t            \"min_consecutive\": 2,\n\t            \"min_length\": 300,\n\t        },\n\t    }\n\t    return edge_cases_expected\n"]}
{"filename": "test/test_edge_cases.py", "chunked_list": ["# from rebar import wrappers, genome, edge_cases, utils, constants\n\t# import os\n\t# import pandas as pd\n\t# from Bio import Phylo\n\t# def test_prep_edge_cases(params):\n\t#     \"\"\"Prepare input for function edge_cases.handle_edge_cases.\"\"\"\n\t#     params.outdir = \"test/tmp/edge_cases\"\n\t#     if not os.path.exists(params.outdir):\n\t#         os.makedirs(params.outdir)\n\t#     edge_case_recombinants = \",\".join(constants.EDGE_CASE_RECOMBINANTS)\n", "#     params.alignment = None\n\t#     params.lineages = edge_case_recombinants\n\t#     # Use the dataset created from test_wrappers\n\t#     params.dataset = \"test/tmp/wrappers/dataset/sars-cov-2-latest\"\n\t#     params.logger = utils.create_logger(os.path.join(params.outdir, \"test.log\"))\n\t#     wrappers.run(params)\n\t# # Note: I Think this needs to wait for a test_genome suite to be developed first.\n\t# def test_handle_edge_cases(params, edge_cases_expected):\n\t#     \"\"\"Test function edge_cases.handle_edge_cases.\"\"\"\n\t#     subs_path = \"test/tmp/edge_cases/subs.tsv\"\n", "#     subs_df = pd.read_csv(subs_path, sep=\"\\t\")\n\t#     barcodes_path = \"test/tmp/wrappers/dataset/sars-cov-2-latest/barcodes.tsv\"\n\t#     barcodes = pd.read_csv(barcodes_path, sep=\"\\t\")\n\t#     diagnostic_path = \"test/tmp/wrappers/dataset/sars-cov-2-latest/diagnostic.tsv\"\n\t#     diagnostic = pd.read_csv(diagnostic_path, sep=\"\\t\")\n\t#     tree_path = \"test/tmp/wrappers/dataset/sars-cov-2-latest/tree.nwk\"\n\t#     tree = Phylo.read(tree_path, \"newick\")\n\t#     recombinant_tree = [c for c in tree.find_clades(\"X\")][0]\n\t#     recombinant_lineages = [c.name for c in recombinant_tree.find_clades()]\n\t#     lineage_to_clade_path = (\n", "#         \"test/tmp/wrappers/dataset/sars-cov-2-latest/lineage_to_clade.tsv\"\n\t#     )\n\t#     lineage_to_clade = pd.read_csv(lineage_to_clade_path, sep=\"\\t\")\n\t#     edge_case_lineages = list(subs_df[\"strain\"])\n\t#     edge_case_recombinants = []\n\t#     # Debugging\n\t#     #edge_case_lineages = [\"XP\"]\n\t#     conflict = False\n\t#     for lineage in edge_case_lineages:\n\t#         # Convert type from dataframe to series for func\n", "#         subs_row = subs_df[subs_df[\"strain\"] == lineage].squeeze()\n\t#         lineage_genome = genome.Genome(\n\t#             subs_row=subs_row,\n\t#             barcodes=barcodes,\n\t#             diagnostic=diagnostic,\n\t#             lineage_to_clade=lineage_to_clade,\n\t#             tree=tree,\n\t#             recombinant_tree=recombinant_tree,\n\t#             recombinant_lineages=recombinant_lineages,\n\t#         )\n", "#         result = edge_cases.handle_edge_cases(\n\t#             genome=lineage_genome,\n\t#             barcode_summary=lineage_genome.barcode_summary,\n\t#             tree=tree,\n\t#             min_subs=params.min_subs,\n\t#             min_length=params.min_length,\n\t#             min_consecutive=params.min_consecutive,\n\t#         )\n\t#         recombinant = lineage_genome.lineage.recombinant\n\t#         if recombinant is False:\n", "#             conflict = True\n\t#             print(\"lineage: {}, no recombination detected.\".format(lineage))\n\t#             continue\n\t#         if recombinant not in edge_case_recombinants:\n\t#             edge_case_recombinants.append(recombinant)\n\t#         if recombinant not in edge_cases_expected:\n\t#             conflict = True\n\t#             print(\n\t#                 \"lineage: {}, recombinant: {} has no expected values.\".format(\n\t#                     lineage, recombinant\n", "#                 )\n\t#             )\n\t#         else:\n\t#             for param in edge_cases_expected[recombinant]:\n\t#                 expected = edge_cases_expected[recombinant][param]\n\t#                 actual = result[param]\n\t#                 if expected != actual:\n\t#                     conflict = True\n\t#                     print(\n\t#                         \"lineage: {}, param: {}, expected: {}, actual: {}\".format(\n", "#                             lineage, param, expected, actual\n\t#                         )\n\t#                     )\n\t#     for recombinant in edge_cases_expected:\n\t#         if recombinant not in edge_case_recombinants:\n\t#             print(\"recombinant: {} has no actual values.\".format(recombinant))\n\t#             conflict = True\n\t#     assert conflict is False\n"]}
{"filename": "rebar/wrappers.py", "chunked_list": ["# Standard libraries\n\timport os\n\tfrom datetime import datetime\n\timport logging\n\timport yaml\n\t# PyPI libraries\n\tfrom Bio import SeqIO, Phylo\n\t# rebar objects\n\tfrom .utils import (\n\t    download_consensus_sequences,\n", "    download_reference_sequence,\n\t    parse_alignment,\n\t    create_annotations,\n\t    create_tree,\n\t    create_barcodes,\n\t    create_barcodes_diagnostic,\n\t    detect_recombination,\n\t)\n\tfrom . import RebarError\n\t# Quiet URL fetch requests messages\n", "logging.getLogger(\"requests\").setLevel(logging.WARNING)\n\tlogging.getLogger(\"urllib3\").setLevel(logging.WARNING)\n\t# -----------------------------------------------------------------------------\n\t# Dataset Subcommand\n\t# -----------------------------------------------------------------------------\n\tdef dataset(params):\n\t    \"\"\"\n\t    Download and create the rebar data model.\n\t    Parameters\n\t    ----------\n", "        output : str\n\t            file path for output barcodes csv.\n\t        log : str\n\t            file path for output log.\n\t    \"\"\"\n\t    start_time = datetime.now()\n\t    logger = params.logger\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n\t    logger.info(str(datetime.now()) + \"\\tBEGINNING SUBCOMMAND: dataset.\")\n\t    info = {\"name\": params.name, \"tag\": params.tag}\n", "    # Initialize tag\n\t    if params.name == \"sars-cov-2\":\n\t        if params.tag == \"latest\":\n\t            create_annotations(params)\n\t            accession = \"MN908947.3\"\n\t            info[\"reference\"] = download_reference_sequence(params, accession)\n\t            info[\"sequences\"] = download_consensus_sequences(params)\n\t            info[\"tree\"] = create_tree(params)\n\t            # barcodes needs tree for clade to lineage mapping\n\t            params.tree = os.path.join(params.outdir, \"tree.nwk\")\n", "            info[\"barcodes\"] = create_barcodes(params)\n\t            # barcodes needs tree for clade to lineage mapping\n\t            params.barcodes = os.path.join(params.outdir, \"barcodes.tsv\")\n\t            create_barcodes_diagnostic(params)\n\t            # Summarize dataset in yaml file\n\t            info_yaml = yaml.dump(info, sort_keys=False, indent=2)\n\t            info_path = os.path.join(params.outdir, \"dataset.yaml\")\n\t            logger.info(\n\t                str(datetime.now()) + \"\\tExporting dataset summary: \" + info_path\n\t            )\n", "            with open(info_path, \"w\") as outfile:\n\t                outfile.write(info_yaml + \"\\n\")\n\t    # Runtime\n\t    end_time = datetime.now()\n\t    runtime = end_time - start_time\n\t    # more than an hour\n\t    if runtime.seconds > 3600:\n\t        runtime = round(runtime.seconds / 3600, 1)\n\t        units = \"hours\"\n\t    # more than a minute\n", "    elif runtime.seconds > 60:\n\t        runtime = round(runtime.seconds / 60, 1)\n\t        units = \"minutes\"\n\t    else:\n\t        runtime = round(runtime.seconds, 1)\n\t        units = \"seconds\"\n\t    # Finish\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n\t    logger.info(str(datetime.now()) + \"\\tRUNTIME: \" + str(runtime) + \" \" + units)\n\t    logger.info(str(datetime.now()) + \"\\tFINISHED SUBCOMMAND: dataset.\")\n", "# -----------------------------------------------------------------------------\n\t# Test Subcommand\n\t# -----------------------------------------------------------------------------\n\tdef run(params):\n\t    \"\"\"\n\t    Run rebar on an alignment or user-specified lineages.\n\t    \"\"\"\n\t    start_time = datetime.now()\n\t    logger = params.logger\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n", "    logger.info(str(datetime.now()) + \"\\tBEGINNING SUBCOMMAND: run.\")\n\t    # Check for either lineages or alignment\n\t    if not params.lineages and not params.alignment:\n\t        raise SystemExit(\n\t            RebarError(\n\t                \"RebarError: Either --lineages or --alignment must be specified.\"\n\t            )\n\t        )\n\t    if params.lineages and params.alignment:\n\t        raise SystemExit(\n", "            RebarError(\n\t                \"RebarError: Both --lineages and --alignment cannot be specified.\"\n\t            )\n\t        )\n\t    reference_path = os.path.join(params.dataset, \"reference.fasta\")\n\t    consensus_path = os.path.join(params.dataset, \"alignment.fasta\")\n\t    tree_path = os.path.join(params.dataset, \"tree.nwk\")\n\t    barcodes_path = os.path.join(params.dataset, \"barcodes.tsv\")\n\t    clade_path = os.path.join(params.dataset, \"lineage_to_clade.tsv\")\n\t    required_files = [reference_path, consensus_path, tree_path, barcodes_path]\n", "    # Check all dataset files exist\n\t    for file_path in required_files:\n\t        if not os.path.exists(file_path):\n\t            raise SystemExit(\n\t                RebarError(\"RebarError: Can't find dataset file \" + file_path)\n\t            )\n\t    # Search consensus sequences for target lineages\n\t    if params.lineages:\n\t        tree = Phylo.read(tree_path, \"newick\")\n\t        lineage_list_raw = params.lineages.split(\",\")\n", "        lineage_list = []\n\t        # Check for \"*\" character to imply descendants\n\t        for lineage in lineage_list_raw:\n\t            if lineage[-1] == \"*\":\n\t                lineage = lineage[:-1]\n\t                lineage_tree = next(tree.find_clades(lineage))\n\t                lineage_descendants = [c.name for c in lineage_tree.find_clades()]\n\t                for desc in lineage_descendants:\n\t                    if desc not in lineage_list:\n\t                        lineage_list.append(desc)\n", "            else:\n\t                lineage_list.append(lineage)\n\t        params.lineages = \",\".join(lineage_list)\n\t        logger.info(\n\t            str(datetime.now())\n\t            + \"\\tSearching consensus sequences for: \"\n\t            + params.lineages\n\t        )\n\t        fasta_lines = []\n\t        found_lineages = []\n", "        records = SeqIO.parse(consensus_path, \"fasta\")\n\t        for record in records:\n\t            if record.id in lineage_list:\n\t                fasta_lines.append(\">\" + str(record.id))\n\t                fasta_lines.append(str(record.seq))\n\t                found_lineages.append(record.id)\n\t        if len(fasta_lines) == 0:\n\t            raise SystemExit(\n\t                RebarError(\"RebarError: No sequences were found for input lineages.\")\n\t            )\n", "        missing_lineages = [l for l in lineage_list if l not in found_lineages]\n\t        if len(missing_lineages) > 0:\n\t            logger.info(\n\t                str(datetime.now())\n\t                + \"\\tNo sequences were found for the following lineages: \"\n\t                + \",\".join(missing_lineages)\n\t            )\n\t        alignment_path = os.path.join(params.outdir, \"alignment.fasta\")\n\t        logger.info(\n\t            str(datetime.now()) + \"\\tExporting lineage alignment to: \" + alignment_path\n", "        )\n\t        with open(alignment_path, \"w\") as outfile:\n\t            outfile.write(\"\\n\".join(fasta_lines) + \"\\n\")\n\t        params.alignment = alignment_path\n\t    # Run pipeline\n\t    params.reference = reference_path\n\t    params.barcodes = barcodes_path\n\t    params.tree = tree_path\n\t    params.lineage_to_clade = clade_path\n\t    params.subs = os.path.join(params.outdir, \"subs.tsv\")\n", "    parse_alignment(params)\n\t    params.edge_cases = True\n\t    detect_recombination(params)\n\t    # Runtime\n\t    end_time = datetime.now()\n\t    runtime = end_time - start_time\n\t    # more than an hour\n\t    if runtime.seconds > 3600:\n\t        runtime = round(runtime.seconds / 3600, 1)\n\t        units = \"hours\"\n", "    # more than a minute\n\t    elif runtime.seconds > 60:\n\t        runtime = round(runtime.seconds / 60, 1)\n\t        units = \"minutes\"\n\t    else:\n\t        runtime = round(runtime.seconds, 1)\n\t        units = \"seconds\"\n\t    # Finish\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n\t    logger.info(str(datetime.now()) + \"\\tRUNTIME: \" + str(runtime) + \" \" + units)\n", "    logger.info(str(datetime.now()) + \"\\tFINISHED SUBCOMMAND: run.\")\n"]}
{"filename": "rebar/substitution.py", "chunked_list": ["class Substitution:\n\t    def __init__(self, substitution):\n\t        self.substitution = substitution\n\t        self.coord = int(substitution[1:-1])\n\t        self.ref = substitution[0]\n\t        self.alt = substitution[-1]\n\t    def __repr__(self):\n\t        return self.substitution\n\t    def __lt__(self, other):\n\t        return self.coord < other.coord\n", "    def __le__(self, other):\n\t        return self.coord <= other.coord\n\t    def __gt__(self, other):\n\t        return self.coord > other.coord\n\t    def __ge__(self, other):\n\t        return self.coord >= other.coord\n\t    def __eq__(self, other):\n\t        return self.substitution == other.substitution\n\t    def __ne__(self, other):\n\t        return self.substitution != other.substitution\n", "    def __sub__(self, other):\n\t        return self.coord + other.coord\n\t    def __add__(self, other):\n\t        return self.coord + other.coord\n\t    def __hash__(self):\n\t        return hash(str(self))\n"]}
{"filename": "rebar/__main__.py", "chunked_list": ["#!/usr/bin/env python3\n\timport os\n\tfrom datetime import datetime\n\tfrom multiprocess import cpu_count\n\timport sys\n\tfrom .utils import create_logger\n\tfrom . import make_parser, RebarError\n\t\"\"\"\n\tStub function and module used as a setuptools entry point.\n\tBased on augur and treetime's __main__.py and setup.py\n", "\"\"\"\n\tdef main():\n\t    parser = make_parser()\n\t    params = parser.parse_args()\n\t    # If params doesn't have a log object, this is the help subcommand\n\t    if not hasattr(params, \"log\"):\n\t        return_code = params.func(params)\n\t        sys.exit(return_code)\n\t    # Check for at least one output type specified\n\t    if hasattr(params, \"output_all\"):\n", "        if (\n\t            not params.output_all\n\t            and not params.output_barcode\n\t            and not params.output_plot\n\t            and not params.output_tsv\n\t            and not params.output_yaml\n\t        ):\n\t            raise SystemExit(\n\t                RebarError(\n\t                    \"RebarError: At least one output type must be specified\"\n", "                    \" with --output-TYPE.\"\n\t                )\n\t            )\n\t    # Check for conflicting use of --debug and --threads\n\t    if params.debug and params.threads > 1:\n\t        raise SystemExit(\n\t            RebarError(\n\t                \"RebarError: Debugging mode (--debug) and multithreading mode\"\n\t                \" (--threads) are incompatible. Please specify only one or the other.\"\n\t            )\n", "        )\n\t    # Check for validate mode and missing tsv output\n\t    if hasattr(params, \"validate\"):\n\t        if params.validate and not (params.output_all or params.output_tsv):\n\t            raise SystemExit(\n\t                RebarError(\n\t                    \"RebarError: --validate requires --output-all or --output-tsv.\"\n\t                )\n\t            )\n\t    # Otherwise, run an actual analysis subcommand\n", "    # Create log directory if it doesn't increase\n\t    if params.log:\n\t        logdir = os.path.dirname(params.log)\n\t        if not os.path.exists(logdir) and logdir != \"\":\n\t            os.makedirs(logdir)\n\t    # Create log\n\t    params.logger = create_logger(params.log)\n\t    # Create output directory if it doesn't exist\n\t    if hasattr(params, \"output\"):\n\t        params.outdir = os.path.dirname(params.output)\n", "    if not os.path.exists(params.outdir) and params.outdir != \"\":\n\t        params.logger.info(\n\t            str(datetime.now()) + \"\\tCreating output directory: \" + params.outdir\n\t        )\n\t        os.makedirs(params.outdir)\n\t    # Initialize system resources for multiprocessing\n\t    available_cpus = cpu_count()\n\t    if hasattr(params, \"threads\"):\n\t        if params.threads > available_cpus:\n\t            params.threads = available_cpus\n", "        # Only print this in subcommands that use multiprocessing\n\t        # ex. not in subs or tree, so as to not confuse the user\n\t        # as to whether they can or can't use multiple threads\n\t        params.logger.info(\n\t            str(datetime.now())\n\t            + \"\\tUsing {} CPUs out of {} available.\".format(\n\t                params.threads, available_cpus\n\t            )\n\t        )\n\t    else:\n", "        params.threads = 1\n\t    # Reverse the no_edge_cases parameter\n\t    if hasattr(params, \"no_edge_cases\"):\n\t        params.edge_cases = True\n\t        if params.no_edge_cases:\n\t            params.edge_cases = False\n\t    return_code = params.func(params)\n\t    sys.exit(return_code)\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "rebar/plot.py", "chunked_list": ["#!/usr/bin/env/python3\n\timport os\n\timport logging\n\tfrom itertools import cycle\n\timport matplotlib.pyplot as plt\n\tfrom matplotlib import patches, colors\n\tlogging.getLogger(\"matplotlib.font_manager\").disabled = True\n\tEDGE_CASE_CHAR = \"â€ \"\n\tdef plot(barcodes_df, summary_df, annot_df, output, max_samples=10):\n\t    # Create output directory if it doesn't exist\n", "    outdir = os.path.dirname(output)\n\t    if not os.path.exists(outdir) and outdir != \".\" and outdir != \"\":\n\t        os.makedirs(outdir)\n\t    genome_length = int(summary_df[\"genome_length\"].values[0])\n\t    # Check if this is an edge case recombinant, annotate with footnote char\n\t    edge_case = summary_df[\"edge_case\"].values[0]\n\t    # Map parent to clade\n\t    parents_lineage = summary_df[\"parents_lineage\"].values[0]\n\t    parents_clade = summary_df[\"parents_clade_lineage\"].values[0]\n\t    lineage_to_clade = {\n", "        parents_lineage.split(\",\")[0]: parents_clade.split(\",\")[0],\n\t        parents_lineage.split(\",\")[1]: parents_clade.split(\",\")[1],\n\t    }\n\t    # Sort parents according to their region order\n\t    regions = summary_df[\"regions\"].values[0]\n\t    # Example: 261-22896|BJ.1,22942-29118|CJ.1\n\t    regions_split = regions.split(\",\")\n\t    parent_order = []\n\t    for region in regions_split:\n\t        parent = region.split(\"|\")[1]\n", "        if parent not in parent_order:\n\t            parent_order.append(parent)\n\t    # Reorder dataframe columns to have correct parent order\n\t    cols_order = [\"coord\", \"Reference\"] + parent_order + list(barcodes_df.columns[4:])\n\t    barcodes_df = barcodes_df[cols_order]\n\t    # Identify the first and second parent lineage\n\t    parent_1 = barcodes_df.columns[2]\n\t    parent_2 = barcodes_df.columns[3]\n\t    # Identify clade of each parent\n\t    parents = summary_df[\"parents_clade_lineage\"].values[0]\n", "    parent_1_clade_lineage = lineage_to_clade[parent_1]\n\t    parent_2_clade_lineage = lineage_to_clade[parent_2]\n\t    # Set up palette to distinguish parents and mutation source\n\t    cmap = plt.get_cmap(\"tab20\", 20)\n\t    palette = [colors.rgb2hex(cmap(i)) for i in range(cmap.N)]\n\t    parent_1_mut_color = palette[0]  # Blue Dark\n\t    parent_1_ref_color = palette[1]  # Blue Light\n\t    parent_2_mut_color = palette[2]  # Orange Dark\n\t    parent_2_ref_color = palette[3]  # Orange Light\n\t    ref_color = \"#c4c4c4\"\n", "    records = list(barcodes_df.columns[1:])\n\t    num_records = len(records)\n\t    # Check if we need to collapse some samples\n\t    # minus 3 for ref and two parents\n\t    if (num_records - 3) > max_samples:\n\t        uniq_data = {}\n\t        for sample in records[3:]:\n\t            sample_data = \"\".join(barcodes_df[sample])\n\t            if sample_data not in uniq_data:\n\t                uniq_data[sample_data] = {\n", "                    \"sample\": sample,\n\t                    \"count\": 1,\n\t                }\n\t            else:\n\t                uniq_data[sample_data][\"count\"] += 1\n\t        # Only keep the uniq sample data\n\t        keep_records = [\"coord\"] + records[0:3]\n\t        keep_records += [data[\"sample\"] for data in uniq_data.values()]\n\t        # Rename to indicate N = X collapse of samples\n\t        rename_records = {\n", "            data[\"sample\"]: \"{} (N = {})\".format(data[\"sample\"], data[\"count\"])\n\t            for data in uniq_data.values()\n\t        }\n\t        barcodes_df = barcodes_df[keep_records].rename(columns=rename_records)\n\t        records = list(barcodes_df.columns[1:])\n\t        num_records = len(records)\n\t    num_subs = len(barcodes_df)\n\t    # What is going to be the width and height of each sub box?\n\t    x_inc = genome_length / num_subs\n\t    # Make y size the same, so it produces squares\n", "    y_inc = x_inc\n\t    # This is the y position position to add extra space\n\t    # The first three are reference, parent_1, parent_2\n\t    y_break = 3\n\t    # -------------------------------------------------------------------------\n\t    # Plot Setup\n\t    # # Fontsize of 9 looks good for 20 subs\n\t    fs = 9\n\t    linewidth = 0.5\n\t    plt.rcParams[\"hatch.linewidth\"] = linewidth\n", "    guide_tick_intervals = 5000\n\t    target_height = 20\n\t    target_width = 20\n\t    # True matplotlib maximum\n\t    max_height = 50\n\t    max_width = 50\n\t    # Default width and height\n\t    width = 10\n\t    height = 10\n\t    if num_subs > 10:\n", "        width = num_subs\n\t        if num_subs > target_width:\n\t            width = num_subs * 0.25\n\t        if width > max_width:\n\t            width = max_width\n\t    if num_records > 5:\n\t        height = num_records\n\t        if num_records > target_height:\n\t            height = max_height\n\t        if height > max_height:\n", "            height = max_height\n\t    if width < 10:\n\t        fs = 7\n\t    else:\n\t        guide_tick_intervals = 2500\n\t    # Current height of the section for plotting\n\t    current_y = 0\n\t    # section_x = x_inc * 0.5\n\t    section_x = 0\n\t    section_label_x = -(x_inc * 0.5)\n", "    # How weight/tall substitution boxes should be\n\t    sub_box_w = x_inc * 0.8\n\t    sub_box_h = sub_box_w\n\t    fig, ax = plt.subplots(1, 1, dpi=200, figsize=(width, height))\n\t    # -----------------------------------------------------------------------------\n\t    # SECTION: REGIONS\n\t    # General section dimensions\n\t    section_y2 = current_y\n\t    section_y1 = section_y2 - y_inc\n\t    section_h = section_y2 - section_y1\n", "    section_label_y = section_y1 + (section_y2 - section_y1) / 2\n\t    section_label = \"Parents\"\n\t    # Write section label\n\t    ax.text(\n\t        section_label_x, section_label_y, \"Parents\", size=fs, ha=\"right\", va=\"center\"\n\t    )\n\t    # Parse regions from summary, use first one, should be similar except 5' 3'\n\t    regions = summary_df[\"regions\"].values[0]\n\t    regions_split = regions.split(\",\")\n\t    prev_end = None\n", "    # Example: 3796-22599|B.1.617.2\n\t    for region in regions_split:\n\t        coords = region.split(\"|\")[0]\n\t        parent = region.split(\"|\")[1]\n\t        # First region, plot from beginning\n\t        if region == regions_split[0]:\n\t            start = 0\n\t        else:\n\t            start = int(coords.split(\"-\")[0])\n\t        # Last region, plot to end\n", "        if region == regions_split[-1]:\n\t            end = genome_length\n\t        else:\n\t            end = int(coords.split(\"-\")[1])\n\t        # Adjust x coord\n\t        start += section_x\n\t        end += section_x\n\t        if parent == parent_1:\n\t            color = parent_1_mut_color\n\t        else:\n", "            color = parent_2_mut_color\n\t        # Parental region box\n\t        rect = patches.Rectangle(\n\t            (start, section_y1),\n\t            end - start,\n\t            section_h,\n\t            fill=True,\n\t            edgecolor=\"black\",\n\t            lw=linewidth,\n\t            facecolor=color,\n", "        )\n\t        ax.add_patch(rect)\n\t        text_x = start + (end - start) / 2\n\t        # Offset height of every other text label\n\t        text_y = section_y1 + (section_h * 1.5)\n\t        ax.plot([text_x, text_x], [section_y2, text_y], lw=linewidth, c=\"black\")\n\t        ax.text(text_x, text_y, parent, size=fs, ha=\"center\", va=\"bottom\")\n\t        # Breakpoints box\n\t        if prev_end:\n\t            rect = patches.Rectangle(\n", "                (prev_end, section_y1),\n\t                start - prev_end,\n\t                section_h,\n\t                fill=True,\n\t                edgecolor=\"black\",\n\t                lw=linewidth,\n\t                facecolor=ref_color,\n\t                hatch=\"////\",\n\t            )\n\t            ax.add_patch(rect)\n", "        prev_end = end\n\t    current_y = section_y1\n\t    # -----------------------------------------------------------------------------\n\t    # SECTION: GENOME ANNOTATIONS AND SUB MARKERS\n\t    # General section dimensions\n\t    section_y2 = current_y - (y_inc * 2)\n\t    section_y1 = section_y2 - y_inc\n\t    section_h = section_y2 - section_y1\n\t    section_label_y = section_y1 + (section_y2 - section_y1) / 2\n\t    section_label = \"Genome\"\n", "    # Write section label\n\t    ax.text(\n\t        section_label_x,\n\t        section_label_y,\n\t        section_label,\n\t        size=fs,\n\t        ha=\"right\",\n\t        va=\"center\",\n\t    )\n\t    # Write grey rectangle as background\n", "    rect = patches.Rectangle(\n\t        (section_x, section_y1),\n\t        genome_length,\n\t        section_h,\n\t        alpha=0.2,\n\t        fill=True,\n\t        edgecolor=\"none\",\n\t        facecolor=\"dimgrey\",\n\t    )\n\t    ax.add_patch(rect)\n", "    # Genome Annotations on top of guide rect\n\t    # Exclude the sub colors from the palette\n\t    annot_palette = cycle(palette[4:])\n\t    for i, rec in enumerate(annot_df.iterrows()):\n\t        start = rec[1][\"start\"]\n\t        # End coordinates non-inclusive\n\t        end = rec[1][\"end\"] - 1\n\t        annot_x1 = rec[1][\"start\"] + section_x\n\t        annot_x2 = end = (rec[1][\"end\"] - 1) + section_x\n\t        annot_w = annot_x2 - annot_x1\n", "        annot_c = next(annot_palette)\n\t        # Plot annotation rectangle\n\t        rect = patches.Rectangle(\n\t            (annot_x1, section_y1),\n\t            annot_w,\n\t            section_h,\n\t            alpha=1,\n\t            fill=True,\n\t            edgecolor=\"none\",\n\t            linewidth=linewidth,\n", "            facecolor=annot_c,\n\t        )\n\t        ax.add_patch(rect)\n\t        gene = rec[1][\"abbreviation\"]\n\t        text_x = annot_x1 + (annot_w * 0.5)\n\t        # Offset height of every other text label\n\t        if i % 2 == 0:\n\t            text_y = section_y1 + (section_h * 1.25)\n\t        else:\n\t            text_y = section_y1 + (section_h * 2)\n", "        ax.plot(\n\t            [text_x, text_x],\n\t            [section_y2, text_y],\n\t            ls=\"-\",\n\t            lw=linewidth,\n\t            color=\"black\",\n\t            clip_on=False,\n\t        )\n\t        ax.text(text_x, text_y, gene, size=fs, ha=\"center\", va=\"bottom\", color=\"black\")\n\t    # Add subsitution ticks\n", "    for x in list(range(0, genome_length, guide_tick_intervals)) + [genome_length]:\n\t        tick_text = str(x)\n\t        x += section_x\n\t        tick_y2 = section_y1\n\t        tick_y1 = tick_y2 - (y_inc * 0.25)\n\t        text_y = tick_y1 - (y_inc * 0.25)\n\t        ax.plot(\n\t            [x, x],\n\t            [tick_y1, tick_y2],\n\t            lw=linewidth,\n", "            color=\"black\",\n\t        )\n\t        ax.text(\n\t            x,\n\t            text_y,\n\t            str(tick_text),\n\t            size=fs - 2,\n\t            ha=\"center\",\n\t            va=\"top\",\n\t            color=\"black\",\n", "        )\n\t    # Iterate through subs to show on guide\n\t    for rec in barcodes_df.iterrows():\n\t        genome_coord = rec[1][\"coord\"] + section_x\n\t        guide_color = \"black\"\n\t        # Plot a line on the guide\n\t        ax.plot(\n\t            [genome_coord, genome_coord],\n\t            [section_y1, section_y2],\n\t            lw=linewidth,\n", "            color=guide_color,\n\t            clip_on=False,\n\t        )\n\t    current_y = section_y1\n\t    # -----------------------------------------------------------------------------\n\t    # SECTION: GUIDE TO SUB POLYGONS\n\t    section_y2 = current_y\n\t    section_y1 = current_y - (y_inc * 3)\n\t    # Starting x point for sub boxes\n\t    sub_x = section_x\n", "    # Iterate through subs, which are columns in plot\n\t    for rec in barcodes_df.iterrows():\n\t        # Adjust box coord based on width\n\t        sub_box_x = sub_x + (x_inc / 2 - sub_box_w / 2)\n\t        genome_coord = rec[1][\"coord\"] + section_x\n\t        # Draw a polygon from guide to top row of subs\n\t        # P1: Top Guide, P2: Top left of SNP box, P3: Top right of SNP box\n\t        x1 = sub_box_x\n\t        x2 = sub_box_x + sub_box_w\n\t        x3 = genome_coord\n", "        y1 = section_y1 - (y_inc - sub_box_h) / 2\n\t        y2 = section_y2\n\t        poly_coords = [[x1, y1], [x2, y1], [x3, y2]]\n\t        poly = patches.Polygon(\n\t            poly_coords,\n\t            closed=True,\n\t            alpha=0.2,\n\t            fill=True,\n\t            edgecolor=\"none\",\n\t            facecolor=\"dimgrey\",\n", "        )\n\t        ax.add_patch(poly)\n\t        sub_x += x_inc\n\t    current_y = section_y1\n\t    # -----------------------------------------------------------------------------\n\t    # SECTION: BREAKPOINT LINES AND LABELS\n\t    # General section dimensions\n\t    section_y2 = section_y2\n\t    section_y1 = section_y1\n\t    section_label_y = section_y1 + (section_y2 - section_y1) / 2.5\n", "    section_label = \"Breakpoints\"\n\t    # Next section\n\t    next_section_y1 = section_y1 - (num_records * y_inc) - (y_inc)\n\t    # Write section label\n\t    ax.text(\n\t        section_label_x,\n\t        section_label_y,\n\t        section_label,\n\t        size=fs,\n\t        ha=\"right\",\n", "        va=\"center\",\n\t    )\n\t    # Parse breakpoints from summary based on previous regions\n\t    breakpoints = summary_df[summary_df[\"regions\"] == regions][\"breakpoints\"].values[0]\n\t    breakpoints_split = breakpoints.split(\",\")\n\t    # Align bottom of breakpoints dividor with next section sub box bottom\n\t    bp_y1 = next_section_y1 + (y_inc - sub_box_h) / 2\n\t    bp_y2 = section_label_y\n\t    for i, breakpoint in enumerate(breakpoints_split):\n\t        # get region start and end\n", "        start = int(breakpoint.split(\"-\")[0]) - 1\n\t        end = int(breakpoint.split(\"-\")[1]) + 1\n\t        start_match = barcodes_df[barcodes_df[\"coord\"] == start]\n\t        end_match = barcodes_df[barcodes_df[\"coord\"] == end]\n\t        if len(start_match) == 0:\n\t            continue\n\t        start_i = start_match.index.values[0]\n\t        # End coordinates are not inclusive, move back one\n\t        end_i = end_match.index.values[0] - 1\n\t        # If start and end are adjacent coordinates, plot dashed line\n", "        if (end_i - start_i) == 0:\n\t            bp_x = section_x + ((start_i + 1) * x_inc)\n\t            ax.plot(\n\t                [bp_x, bp_x],\n\t                [bp_y1, bp_y2],\n\t                ls=\"--\",\n\t                lw=linewidth,\n\t                color=\"black\",\n\t                clip_on=False,\n\t            )\n", "        # Plot greyed, out dashed rectangle\n\t        else:\n\t            bp_box_x = (x_inc) * (start_i + 1)\n\t            bp_box_x2 = (x_inc) * (end_i + 1)\n\t            bp_box_y = bp_y1\n\t            bp_box_w = bp_box_x2 - bp_box_x\n\t            bp_box_h = (y_inc) * num_records + (y_inc)\n\t            bp_x = bp_box_x + bp_box_w / 2\n\t            # Greyed out rectangle\n\t            rect = patches.Rectangle(\n", "                (bp_box_x, bp_box_y),\n\t                bp_box_w,\n\t                bp_box_h,\n\t                alpha=0.4,\n\t                fill=True,\n\t                facecolor=\"black\",\n\t                edgecolor=\"none\",\n\t                lw=linewidth,\n\t                ls=\"--\",\n\t            )\n", "            ax.add_patch(rect)\n\t            # Dashed rectangle outline\n\t            rect = patches.Rectangle(\n\t                (bp_box_x, bp_box_y),\n\t                bp_box_w,\n\t                bp_box_h,\n\t                alpha=1,\n\t                fill=False,\n\t                facecolor=\"none\",\n\t                edgecolor=\"black\",\n", "                lw=linewidth,\n\t                ls=\"--\",\n\t            )\n\t            ax.add_patch(rect)\n\t            # Bonus little dashed tick in center\n\t            line_x = bp_x\n\t            line_y1 = bp_box_y + bp_box_h\n\t            line_y2 = bp_y2\n\t            ax.plot(\n\t                [line_x, line_x],\n", "                [line_y1, line_y2],\n\t                ls=\"--\",\n\t                lw=linewidth,\n\t                color=\"black\",\n\t                clip_on=False,\n\t            )\n\t        ax.text(\n\t            bp_x,\n\t            bp_y2,\n\t            \"Breakpoint #\" + str(i + 1),\n", "            size=fs,\n\t            ha=\"center\",\n\t            va=\"center\",\n\t            bbox=dict(\n\t                facecolor=\"white\", edgecolor=\"black\", lw=linewidth, boxstyle=\"round\"\n\t            ),\n\t        )\n\t    current_y = section_y1\n\t    # -----------------------------------------------------------------------------\n\t    # SECTION: SAMPLES AND SUBSTITUTION BOXES\n", "    # General section dimensions\n\t    section_y2 = current_y\n\t    section_y1 = section_y2 - (num_records * y_inc) - (y_inc)\n\t    # Starting x point for sub boxes, we start with iter\n\t    sub_x = section_x\n\t    # Iterate through subs, which are columns in plot\n\t    for rec_i, rec in enumerate(barcodes_df.iterrows()):\n\t        # Adjust box coord based on width\n\t        sub_box_x = sub_x + (x_inc / 2 - sub_box_w / 2)\n\t        # Identify base origins\n", "        ref_base = rec[1][\"Reference\"]\n\t        parent_1_base = rec[1][parent_1]\n\t        parent_2_base = rec[1][parent_2]\n\t        # y coordinates for substitutions box\n\t        sub_y = section_y2\n\t        # Iterate through samples, which are rows in plot\n\t        for i, label in enumerate(records):\n\t            # Adjust box coord based on height\n\t            sub_y -= y_inc\n\t            # Add extra gap after recombinant parents\n", "            if i == y_break:\n\t                sub_y -= y_inc\n\t            # Adjust box coord based on height\n\t            sub_box_y = sub_y + (y_inc / 2 - sub_box_h / 2)\n\t            base = rec[1][label]\n\t            if label == \"Reference\":\n\t                box_c = ref_color\n\t            elif base == parent_1_base:\n\t                if base == ref_base:\n\t                    box_c = parent_1_ref_color\n", "                else:\n\t                    box_c = parent_1_mut_color\n\t            elif base == parent_2_base:\n\t                if base == ref_base:\n\t                    box_c = parent_2_ref_color\n\t                else:\n\t                    box_c = parent_2_mut_color\n\t            else:\n\t                box_c = \"white\"\n\t            rect = patches.Rectangle(\n", "                (sub_box_x, sub_box_y),\n\t                sub_box_w,\n\t                sub_box_h,\n\t                alpha=0.90,\n\t                fill=True,\n\t                edgecolor=\"none\",\n\t                facecolor=box_c,\n\t            )\n\t            ax.add_patch(rect)\n\t            text_y = sub_box_y + (sub_box_h / 2)\n", "            # On the first time parsing sub, write sample label\n\t            if rec_i == 0:\n\t                # If parent, also include clade\n\t                if label == parent_1:\n\t                    label = \"{} ({})\".format(parent_1, parent_1_clade_lineage)\n\t                elif label == parent_2:\n\t                    label = \"{} ({})\".format(parent_2, parent_2_clade_lineage)\n\t                # Otherwise, we might want to append edge_case char\n\t                elif edge_case:\n\t                    label = \"{}$^{}$\".format(label, EDGE_CASE_CHAR)\n", "                ax.text(\n\t                    section_label_x,\n\t                    text_y,\n\t                    label,\n\t                    size=fs,\n\t                    ha=\"right\",\n\t                    va=\"center\",\n\t                )\n\t            text_x = sub_box_x + (sub_box_w / 2)\n\t            # Draw sub text bases\n", "            ax.text(text_x, text_y, base, size=fs, ha=\"center\", va=\"center\")\n\t        sub_x += x_inc\n\t    current_y = section_y1\n\t    # -----------------------------------------------------------------------------\n\t    # SECTION: SUBSTITUTION X AXIS TICKS\n\t    section_y2 = current_y - (y_inc * 0.25)\n\t    section_y1 = section_y2 - y_inc\n\t    tick_x = section_x + x_inc / 2\n\t    tick_y1 = section_y2\n\t    tick_y2 = section_y2 - (y_inc * 0.25)\n", "    # Iterate through subs, which are columns in plot\n\t    for rec in barcodes_df.iterrows():\n\t        genome_coord = rec[1][\"coord\"]\n\t        ax.plot([tick_x, tick_x], [tick_y1, tick_y2], lw=linewidth, c=\"black\")\n\t        ax.text(\n\t            tick_x,\n\t            tick_y2,\n\t            str(genome_coord) + \" \",\n\t            size=fs,\n\t            ha=\"center\",\n", "            va=\"top\",\n\t            rotation=90,\n\t        )\n\t        tick_x += x_inc\n\t    current_y = section_y1\n\t    # -----------------------------------------------------------------------------\n\t    # Legend\n\t    legend_colors = [\n\t        ref_color,\n\t        parent_1_mut_color,\n", "        parent_1_ref_color,\n\t        parent_2_mut_color,\n\t        parent_2_ref_color,\n\t    ]\n\t    legend_labels = [\n\t        \"Reference\",\n\t        parent_1 + \" Mutation\",\n\t        parent_1 + \" Reference\",\n\t        parent_2 + \" Mutation\",\n\t        parent_2 + \" Reference\",\n", "    ]\n\t    # General section dimensions\n\t    section_y2 = current_y - y_inc * 2\n\t    # extra inc for white space\n\t    section_y1 = section_y2 - (y_inc * len(legend_labels)) - y_inc\n\t    # extra inc for edge case label\n\t    if edge_case:\n\t        section_y1 = section_y1 - (y_inc)\n\t    section_w = section_x + (x_inc * 10)  # an estimate\n\t    section_h = section_y2 - section_y1\n", "    section_label = \"Legend\"\n\t    section_label_y = section_y1 + (section_h / 2)\n\t    # Write section label\n\t    ax.text(\n\t        section_label_x,\n\t        section_label_y,\n\t        section_label,\n\t        size=fs,\n\t        ha=\"right\",\n\t        va=\"center\",\n", "    )\n\t    # Draw Legend Frame\n\t    legend_frame = patches.Rectangle(\n\t        (section_x, section_y1),\n\t        section_w,\n\t        section_h,\n\t        edgecolor=\"black\",\n\t        lw=linewidth,\n\t        facecolor=\"none\",\n\t    )\n", "    ax.add_patch(legend_frame)\n\t    # Coordinates for section elements\n\t    legend_box_x = section_x + (x_inc * 0.5)\n\t    legend_box_y = section_y2 - (y_inc * 1.5)\n\t    legend_text_x = legend_box_x + x_inc\n\t    legend_text_y = legend_box_y + (sub_box_h / 2)\n\t    for color, label in zip(legend_colors, legend_labels):\n\t        box = patches.Rectangle(\n\t            (legend_box_x, legend_box_y),\n\t            sub_box_w,\n", "            sub_box_h,\n\t            ec=\"none\",\n\t            lw=linewidth,\n\t            fc=color,\n\t        )\n\t        ax.add_patch(box)\n\t        ax.text(legend_text_x, legend_text_y, label, size=fs, ha=\"left\", va=\"center\")\n\t        legend_box_y -= y_inc\n\t        legend_text_y -= y_inc\n\t    # Plot edge case char at box x position\n", "    if edge_case:\n\t        legend_box_x += sub_box_w / 2\n\t        legend_box_y += sub_box_h / 2\n\t        label = EDGE_CASE_CHAR\n\t        ax.text(legend_box_x, legend_box_y, label, size=fs, ha=\"center\", va=\"center\")\n\t        # Write edge case text label at text x position\n\t        label = \"Edge Case Recombinant\"\n\t        ax.text(legend_text_x, legend_text_y, label, size=fs, ha=\"left\", va=\"center\")\n\t    current_y = section_y1\n\t    # -----------------------------------------------------------------------------\n", "    # PLOT WRAPUP\n\t    # Hide the axes lines\n\t    for spine in ax.spines:\n\t        ax.spines[spine].set_visible(False)\n\t    # Remove axis labels\n\t    ax.set_xlabel(\"\")\n\t    ax.set_ylabel(\"\")\n\t    # Remove tick labels\n\t    ax.set_xticks([])\n\t    ax.set_yticks([])\n", "    # # Set the X axis limits to the genome length\n\t    x_min = 0\n\t    x_max = genome_length + x_inc\n\t    ax.set_xlim(x_min, x_max)\n\t    y_min = current_y - y_inc\n\t    y_max = y_inc\n\t    ax.set_ylim(y_min, y_max)\n\t    ax.axes.set_aspect(\"equal\")\n\t    # Export\n\t    plt.tight_layout()\n", "    plt.savefig(output)\n\t    # Close for memory management\n\t    plt.close()\n\t# # Testing code\n\t# import pandas as pd\n\t# annot_df = pd.read_csv(\"dataset/sars-cov-2-latest/annotations.tsv\", sep=\"\\t\")\n\t# barcodes_df = pd.read_csv(\n\t# \"output/controls_gisaid/barcodes/XAC_BA.2.3_BA.5.1.34_26530-27437.tsv\", sep=\"\\t\"\n\t# )\n\t# summary_df = pd.read_csv(\"output/controls_gisaid/summary.tsv\", sep=\"\\t\")\n", "# summary_df = summary_df[summary_df[\"strain\"] == \"hCoV-19/USA/CA-CDC-QDX36262131/2022\"]\n\t# plot(\n\t#     barcodes_df=barcodes_df,\n\t#     summary_df=summary_df,\n\t#     annot_df=annot_df,\n\t#     output=\"output/controls_gisaid/plots/XAC_BA.2.3_BA.5.1.34_26530-27437.png\",\n\t# )\n\t# barcodes_df = pd.read_csv(\n\t# \"output/XBB.1.16/barcodes/XBB_BJ.1_CJ.1_22897-22941.tsv\", sep=\"\\t\"\n\t# )\n", "# summary_df = pd.read_csv(\"output/XBB.1.16/summary.tsv\", sep=\"\\t\")\n\t# plot(\n\t#     barcodes_df=barcodes_df,\n\t#     summary_df=summary_df,\n\t#     annot_df=annot_df,\n\t#     output=\"output/XBB.1.16/plots/XBB_BJ.1_CJ.1_22897-22941.png\",\n\t# )\n"]}
{"filename": "rebar/genome.py", "chunked_list": ["# Standard Libraries\n\timport yaml\n\tfrom datetime import datetime\n\tfrom copy import copy\n\t# PyPI libraries\n\timport pandas as pd\n\tfrom Bio.SeqRecord import SeqRecord\n\t# rebar custom\n\tfrom . import RebarError\n\tfrom .constants import NO_DATA_CHAR, EDGE_CASE_RECOMBINANTS\n", "from .substitution import Substitution\n\tfrom .barcode import Barcode\n\tfrom .recombination import Recombination\n\tfrom .edge_cases import handle_edge_cases\n\tclass Genome:\n\t    \"\"\"\n\t    Genomes defines a genomic sample object with interface methods for parsing\n\t    features from the sequence (substitutions, deletions, missing data), summarizing\n\t    matches to lineage barcodes, and identifying recombinant parents and breakpoints.\n\t    \"\"\"\n", "    def __init__(\n\t        self,\n\t        record=None,\n\t        reference=None,\n\t        subs_row=None,\n\t        barcodes=None,\n\t        diagnostic=None,\n\t        tree=None,\n\t        recombinant_tree=None,\n\t        recombinant_lineages=None,\n", "        lineage_to_clade=None,\n\t        max_depth=1,\n\t        max_breakpoints=1,\n\t        min_subs=1,\n\t        min_length=1,\n\t        min_consecutive=1,\n\t        mask=0,\n\t        debug=False,\n\t        logger=None,\n\t        edge_cases=False,\n", "        validate=None,\n\t        dataset_info=None,\n\t    ):\n\t        \"\"\"\n\t        Genome constructor. Parses genomic features from a sequence records or\n\t        substitutions table.\n\t        Parameters\n\t        ----------\n\t        record : Bio.SeqRecord.SeqRecord\n\t            Sequence record of single sample from multiple alignment.\n", "        reference : Bio.SeqRecord.SeqRecord\n\t            Sequence record of reference genome.\n\t        subs_row : pd.core.series.Series\n\t            Row from substitutions dataframe, either from `rebar subs` subcommand\n\t            or Nextclade TSV.\n\t        barcodes : pd.core.frame.DataFrame\n\t            Dataframe of lineage barcodes, from `rebar barcodes` subcommand\n\t        \"\"\"\n\t        # Debugging option\n\t        self.debug = debug\n", "        self.logger = logger\n\t        # Generic genomic features\n\t        self.id = None\n\t        self.seq = None\n\t        self.substitutions = []\n\t        self.deletions = []\n\t        self.missing = []\n\t        self.genome_length = None\n\t        # Dataset information\n\t        self.dataset = dataset_info\n", "        # Lineage features\n\t        self.barcode_summary = None\n\t        self.lineage = Barcode()\n\t        # Recombination features\n\t        self.recombination = Recombination()\n\t        self.validate = None\n\t        # Entry point #1, from fasta alignment\n\t        if record:\n\t            self.id = record.id\n\t            self.seq = str(record.seq)\n", "            # Mask genome sequence\n\t            self.seq = \"\".join(\n\t                ([\"N\"] * mask)  # 5' masking\n\t                + [self.seq[mask:-mask]]  # in between, unmasked bases\n\t                + [\"N\"] * mask  # 3' masking\n\t            )\n\t        if reference and self.seq:\n\t            reference.seq = str(reference.seq)\n\t            # Mask genome sequence\n\t            if mask > 0:\n", "                reference.seq = \"\".join(\n\t                    ([\"N\"] * mask)  # 5' masking\n\t                    + [reference.seq[mask:-mask]]  # in between, unmasked bases\n\t                    + [\"N\"] * mask  # 3' masking\n\t                )\n\t            self.parse_sequence(reference)\n\t        # Entry point #2, from subs dataframe\n\t        if type(subs_row) == pd.core.series.Series:\n\t            self.id = subs_row[\"strain\"]\n\t            if self.debug:\n", "                self.logger.info(str(datetime.now()) + \"\\tParsing sample: \" + self.id)\n\t            self.genome_length = subs_row[\"genome_length\"]\n\t            self.substitutions = self.parse_substitutions(subs_row=subs_row)\n\t            self.deletions = self.ranges_to_coords(values=subs_row[\"deletions\"])\n\t            self.missing = self.ranges_to_coords(values=subs_row[\"missing\"])\n\t        # Check which substitutions are \"barcodes\" (lineage-defining in combination)\n\t        if type(barcodes) == pd.core.frame.DataFrame:\n\t            self.barcode_summary = self.summarise_barcodes(barcodes)\n\t        # Perform lineage and parent assignment\n\t        if (\n", "            type(self.barcode_summary) == pd.core.frame.DataFrame\n\t            and type(lineage_to_clade) == pd.core.frame.DataFrame\n\t            and type(diagnostic) == pd.core.frame.DataFrame\n\t            and tree\n\t            and recombinant_lineages\n\t            and recombinant_tree\n\t        ):\n\t            if self.debug:\n\t                self.logger.info(str(datetime.now()) + \"\\t\\t\" + \"LINEAGE ASSIGNMENT:\")\n\t            self.lineage = self.lineage_assignment(\n", "                barcode_summary=self.barcode_summary,\n\t                barcodes=barcodes,\n\t                tree=tree,\n\t                recombinant_lineages=recombinant_lineages,\n\t                recombinant_tree=recombinant_tree,\n\t                lineage_to_clade=lineage_to_clade,\n\t                diagnostic=diagnostic,\n\t                top_n=3,\n\t            )\n\t            self.lineage.set_definition()\n", "            self.parent_assignment(\n\t                barcodes=barcodes,\n\t                diagnostic=diagnostic,\n\t                tree=tree,\n\t                recombinant_lineages=recombinant_lineages,\n\t                recombinant_tree=recombinant_tree,\n\t                lineage_to_clade=lineage_to_clade,\n\t                max_depth=max_depth,\n\t                max_breakpoints=max_breakpoints,\n\t                min_subs=min_subs,\n", "                min_length=min_length,\n\t                min_consecutive=min_consecutive,\n\t                edge_cases=edge_cases,\n\t            )\n\t        # Validate\n\t        if validate and tree and recombinant_lineages:\n\t            self.validate = self.validate_recombination(tree, recombinant_lineages)\n\t    def __repr__(self):\n\t        \"\"\"\n\t        Printable representation of a Genome object.\n", "        Returns\n\t        -------\n\t        text : str\n\t            String representation.\n\t        \"\"\"\n\t        # return(self.to_yaml())\n\t        return self.id\n\t    def parse_sequence(self, reference):\n\t        \"\"\"\n\t        Parse genomic features from sequence.\n", "        Parameters\n\t        ----------\n\t        reference : Bio.SeqRecord.SeqRecord\n\t            Sequence record of reference genome.\n\t        Attributes Modified\n\t        -------\n\t        self.substitutions : list\n\t        self.deletions     : list\n\t        self.missing       : list\n\t        self.genome_length : int\n", "        \"\"\"\n\t        coord = 0\n\t        for i, bases in enumerate(zip(reference.seq, self.seq)):\n\t            r = bases[0]\n\t            s = bases[1]\n\t            # Genomic coordinates are 1 based\n\t            coord = i + 1\n\t            # Missing Data\n\t            if s == \"N\":\n\t                self.missing.append(coord)\n", "            # Deletions\n\t            elif s == \"-\":\n\t                self.deletions.append(coord)\n\t            # Substitution, missing ref data\n\t            elif r == \"N\":\n\t                continue\n\t            # Substitution, true\n\t            elif r != s:\n\t                sub = \"{ref}{coord}{alt}\".format(ref=r, coord=coord, alt=s)\n\t                self.substitutions.append(Substitution(sub))\n", "            next\n\t        self.genome_length = coord\n\t        return 0\n\t    def parse_substitutions(self, subs_row):\n\t        \"\"\"\n\t        Parse substitutions column from the subs dataframe row.\n\t        Parameters\n\t        ----------\n\t        subs_row : pd.core.series.Series\n\t            Row from substitutions dataframe, either from `rebar subs` subcommand\n", "            or Nextclade TSV.\n\t        Returns\n\t        -------\n\t        features : list\n\t            List of Substitution objects\n\t        \"\"\"\n\t        subs_str = subs_row[\"substitutions\"].split(\",\")\n\t        subs = sorted([Substitution(s) for s in set(subs_str) if s != NO_DATA_CHAR])\n\t        return subs\n\t    def summarise_barcodes(self, barcodes, barcodes_subs=None):\n", "        \"\"\"\n\t        Summarise detected barcode substitutions.\n\t        Parameters\n\t        ----------\n\t        barcodes : pd.core.frame.DataFrame\n\t            Dataframe of lineage barcodes, from `rebar barcodes` subcommand\n\t        Returns\n\t        -------\n\t        summary_df : pd.core.frame.DataFrame\n\t            Dataframe with columns 'lineage' and 'total' to summarize barcode\n", "            substitution detections.\n\t        \"\"\"\n\t        if not barcodes_subs:\n\t            barcodes_subs = [\n\t                str(s) for s in self.substitutions if str(s) in barcodes.columns\n\t            ]\n\t        else:\n\t            barcodes_subs = [\n\t                str(s) for s in barcodes_subs if str(s) in barcodes.columns\n\t            ]\n", "        # Count up barcode mutations by lineage\n\t        cols = [\"lineage\"] + barcodes_subs\n\t        df = copy(barcodes[cols])\n\t        # Count up total support for each lineage\n\t        df[\"total\"] = df[barcodes_subs].sum(axis=1)\n\t        summary_df = (\n\t            df[[\"lineage\", \"total\"]]\n\t            .query(\"total > 0\")\n\t            .sort_values(by=[\"total\", \"lineage\"], ascending=False)\n\t        )\n", "        # # Can I efficientially calculate conflicts? conflict_ref is the\n\t        # # most important, and means a sub in the lineage barcode that is\n\t        # # not in the genome\n\t        # conflict_ref_subs = [\n\t        #   c for c in barcodes.columns[1:] if c not in barcodes_subs\n\t        # ]\n\t        # print(conflict_ref_subs[0:10])\n\t        # df[\"total\"] = df[barcodes_subs].sum(axis=1)\n\t        return summary_df\n\t    def coords_to_ranges(self, attr=None, values=None):\n", "        \"\"\"\n\t        Convert list of coordinates to ranges.\n\t        Parameters\n\t        ----------\n\t        attr : str\n\t            Genome attribute name to convert (ex. deletions, missing)\n\t        Examples\n\t        --------\n\t        self.deletions = [1,2,3,10,12]\n\t        coords_to_ranges(attr=\"deletions\")\n", "        ['1-3', '10', '12']\n\t        Returns\n\t        -------\n\t        ranges : list\n\t            List of ranges in string representation.\n\t        \"\"\"\n\t        # Author: @cs95\n\t        # Source: https://stackoverflow.com/a/52302366\n\t        if attr:\n\t            values = getattr(self, attr)\n", "        elif not values:\n\t            raise SystemExit(\n\t                RebarError(\n\t                    \"RebarError: coords_to_ranges: attr or values must be specified.\"\n\t                )\n\t            )\n\t        if len(values) == 0:\n\t            return values\n\t        coords = pd.Series([str(c) for c in values])\n\t        diffs = coords.astype(int).diff().bfill().ne(1).cumsum()\n", "        ranges = (\n\t            coords.groupby(diffs)\n\t            .apply(lambda x: \"-\".join(x.values[[0, -1]]) if len(x) > 1 else x.item())\n\t            .tolist()\n\t        )\n\t        return ranges\n\t    def ranges_to_coords(self, attr=None, values=None):\n\t        \"\"\"\n\t        Convert string representation of ranges to coordinates.\n\t        Parameters\n", "        ----------\n\t        attr : str\n\t            Genome attribute name to convert (ex. deletions, missing)\n\t        values : list\n\t            List of ranges in string representation (ex. ['1-3', '10',])\n\t        Examples\n\t        --------\n\t        self.deletions = ['1-3', '10', '12']\n\t        ranges_to_coords(attr=\"deletions\")\n\t        [1,2,3,10,12]\n", "        Returns\n\t        -------\n\t        coords : list\n\t            List of coordinates as integers.\n\t        \"\"\"\n\t        if attr:\n\t            values = getattr(self, attr)\n\t        elif not values:\n\t            raise SystemExit(\n\t                RebarError(\n", "                    \"RebarError: ranges_to_coords: attr or values must be specified.\"\n\t                )\n\t            )\n\t        values_split = values.split(\",\")\n\t        coords = []\n\t        for c in values_split:\n\t            if c == NO_DATA_CHAR:\n\t                continue\n\t            c_split = [int(m) for m in c.split(\"-\")]\n\t            if len(c_split) == 1:\n", "                c = [c_split[0]]\n\t            else:\n\t                c = list(range(c_split[0], c_split[1] + 1))\n\t            coords += c\n\t        return coords\n\t    def to_dataframe(self, df_type=\"subs\"):\n\t        \"\"\"\n\t        Convert Genome object to dataframe.\n\t        Returns\n\t        -------\n", "        genome_dataframe : pd.core.frame.DataFrame\n\t            Dataframe representation of genome.\n\t        \"\"\"\n\t        if df_type == \"subs\":\n\t            genome_dataframe = pd.DataFrame(\n\t                {\n\t                    \"strain\": [self.id],\n\t                    \"substitutions\": [\",\".join([str(s) for s in self.substitutions])],\n\t                    \"deletions\": [\",\".join(self.coords_to_ranges(\"deletions\"))],\n\t                    \"missing\": [\",\".join(self.coords_to_ranges(\"missing\"))],\n", "                    \"genome_length\": self.genome_length,\n\t                }\n\t            )\n\t        else:\n\t            recombination_dict = self.recombination.to_dict()\n\t            # only write parents if recombination detected:\n\t            if not self.recombination.parent_2.name:\n\t                parents_lineage = \"\"\n\t                parents_clade = \"\"\n\t                parents_clade_lineage = \"\"\n", "            else:\n\t                parents_lineage = \"{},{}\".format(\n\t                    self.recombination.parent_1.name,\n\t                    self.recombination.parent_2.name,\n\t                )\n\t                parents_clade = \"{},{}\".format(\n\t                    self.recombination.parent_1.clade,\n\t                    self.recombination.parent_2.clade,\n\t                )\n\t                parents_clade_lineage = \"{},{}\".format(\n", "                    self.recombination.parent_1.clade_lineage,\n\t                    self.recombination.parent_2.clade_lineage,\n\t                )\n\t            genome_dataframe = pd.DataFrame(\n\t                {\n\t                    \"strain\": [self.id],\n\t                    \"lineage\": [self.lineage.name],\n\t                    \"clade\": [self.lineage.clade],\n\t                    \"clade_lineage\": [self.lineage.clade_lineage],\n\t                    \"recombinant\": [\n", "                        self.lineage.recombinant if self.lineage.recombinant else None\n\t                    ],\n\t                    \"definition\": [self.lineage.definition],\n\t                    \"validate\": [self.validate],\n\t                    \"edge_case\": [self.lineage.edge_case],\n\t                    \"parents_lineage\": parents_lineage,\n\t                    \"parents_clade\": parents_clade,\n\t                    \"parents_clade_lineage\": parents_clade_lineage,\n\t                    \"breakpoints\": recombination_dict[\"breakpoints\"],\n\t                    \"regions\": recombination_dict[\"regions\"],\n", "                    \"genome_length\": self.genome_length,\n\t                    \"dataset_name\": self.dataset[\"name\"],\n\t                    \"dataset_tag\": self.dataset[\"tag\"][0:8],\n\t                    \"barcodes_date\": self.dataset[\"barcodes\"][\"date\"],\n\t                    \"barcodes_tag\": self.dataset[\"barcodes\"][\"tag\"][0:8],\n\t                    \"tree_date\": self.dataset[\"tree\"][\"date\"],\n\t                    \"tree_tag\": self.dataset[\"tree\"][\"tag\"][0:8],\n\t                    \"sequences_date\": self.dataset[\"sequences\"][\"date\"],\n\t                    \"sequences_tag\": self.dataset[\"sequences\"][\"tag\"][0:8],\n\t                }\n", "            )\n\t        return genome_dataframe\n\t    def to_dict(self):\n\t        \"\"\"\n\t        Convert Genome object to dict.\n\t        Returns\n\t        -------\n\t        genome_dict : dict\n\t            Dictionary representation of genome.\n\t        \"\"\"\n", "        genome_dict = {\n\t            self.id: {\n\t                \"substitutions\": \",\".join([str(s) for s in self.substitutions]),\n\t                \"deletions\": \",\".join(self.coords_to_ranges(\"deletions\")),\n\t                \"missing\": \",\".join(self.coords_to_ranges(\"missing\")),\n\t                \"lineage\": self.lineage.to_dict(),\n\t                \"recombination\": self.recombination.to_dict(),\n\t            }\n\t        }\n\t        return genome_dict\n", "    def to_yaml(self, indent=2):\n\t        \"\"\"\n\t        Convert Genome object to yaml.\n\t        Returns\n\t        -------\n\t        genome_yaml : yaml\n\t            YAML representation of genome.\n\t        \"\"\"\n\t        genome_yaml = (\n\t            yaml.dump(self.to_dict(), sort_keys=False, indent=indent)\n", "            .replace(\"null\", \"\")\n\t            .replace(\"''\", \"\")\n\t            + \"\\n\"\n\t        )\n\t        return genome_yaml\n\t    def lineage_assignment(\n\t        self,\n\t        barcode_summary,\n\t        barcodes,\n\t        diagnostic,\n", "        tree,\n\t        recombinant_lineages,\n\t        recombinant_tree,\n\t        lineage_to_clade,\n\t        top_n=1,\n\t    ):\n\t        \"\"\"\n\t        Assign genome to a lineage based on the top barcode matches.\n\t        Parameters\n\t        ----------\n", "        barcode_summary : pd.core.frame.DataFrame\n\t            Dataframe of barcode counts from Barcode.search().\n\t        tree : Bio.Phylo.Tree\n\t            Phylogenetic tree of lineage nomenclature.\n\t        recombinant_lineages: list\n\t            List of recombinant lineages.\n\t        recombinant_tree: Bio.Phylo.Tree\n\t            Phylogenetic tree of the 'X' clade (recombinant MRCA)\n\t        Returns\n\t        -------\n", "        barcode : Barcode\n\t            Summary of barcode detections, supports, and conflicts.\n\t        \"\"\"\n\t        barcode = Barcode(\n\t            genome=self,\n\t            barcode_summary=barcode_summary,\n\t            barcodes=barcodes,\n\t            tree=tree,\n\t            recombinant_lineages=recombinant_lineages,\n\t            recombinant_tree=recombinant_tree,\n", "            lineage_to_clade=lineage_to_clade,\n\t            diagnostic=diagnostic,\n\t            top_n=top_n,\n\t        )\n\t        if self.debug:\n\t            lineage_str = barcode.to_yaml().replace(\"\\n\", \"\\n\" + \"\\t\" * 6)\n\t            self.logger.info(str(datetime.now()) + \"\\t\\t\\t\" + lineage_str)\n\t        return barcode\n\t    def parent_assignment(\n\t        self,\n", "        barcodes,\n\t        diagnostic,\n\t        tree,\n\t        recombinant_lineages,\n\t        recombinant_tree,\n\t        lineage_to_clade,\n\t        max_depth=1,\n\t        max_breakpoints=1,\n\t        min_subs=1,\n\t        min_length=1,\n", "        min_consecutive=1,\n\t        edge_cases=False,\n\t    ):\n\t        \"\"\"\n\t        Assign genome to a parent_1 and parent_2 based on barcode matches and conflicts.\n\t        Parameters\n\t        ----------\n\t        barcodes : pd.core.frame.DataFrame\n\t            Dataframe of lineage barcodes, from `rebar barcodes` subcommand\n\t        tree : Bio.Phylo.Tree\n", "            Phylogenetic tree of lineage nomenclature.\n\t        recombinant_lineages: list\n\t            List of recombinant lineages.\n\t        recombinant_tree: Bio.Phylo.Tree\n\t            Phylogenetic tree of the 'X' clade (recombinant MRCA)\n\t        max_depth : int\n\t            Maximum search depth of the top lineages.\n\t        min_subs : int\n\t            Minimum number of consecutive barcode subs contributed by a parent.\n\t        min_consecutive : int\n", "            Minimum number of consecutive bases contributed by a parent.\n\t        Attributes Modified\n\t        -------\n\t        self.recombination : Recombination\n\t        \"\"\"\n\t        # Skip clear non-recombinants\n\t        # We know this from the function lineage_assignment, where if the\n\t        # barcodes are a perfect match to a non-recombinant lineage.\n\t        if self.lineage.recombinant == False:\n\t            return 0\n", "        # Save a copy of the barcode summary, before we modify it\n\t        barcode_summary = copy(self.barcode_summary)\n\t        # Keep a list to exclude from parent search, ex. eventually exclude parent_1\n\t        # lineages in order to find parent_2\n\t        exclude_lineages = []\n\t        # What lineages should we exclude?\n\t        # Option 1. Definitely a recursive recombinant.\n\t        #           Exclude recombinant lineages that are NOT the known parent\n\t        if self.lineage.recursive:\n\t            exclude_lineages += self.lineage.top_lineages\n", "            lineage_path = recombinant_tree.get_path(self.lineage.recombinant)\n\t            lineage_parent = lineage_path[-2].name\n\t            exclude_lineages += [l for l in recombinant_lineages if l != lineage_parent]\n\t        # Option 2. Definitely NOT a recursive recombinant.\n\t        #           Exclude all recombinant lineages from new search.\n\t        #           Ex. XBB.1.5 is not a recursive recombinant (BA.2.10* and BA.2.75*)\n\t        #           If we remove all recombinant lineages from it's barcode summary\n\t        #           the top lineage will become BJ.1.1 (BA.2.10*)\n\t        elif not self.lineage.recursive:\n\t            exclude_lineages += recombinant_lineages\n", "        # Option 3. Potentially a recursive recombinant\n\t        #           Exclude only original backbone lineages from new search.\n\t        #           Ex. XBL is a recursive recombinant (XBB.1* and BA.2.75*)\n\t        else:\n\t            exclude_lineages += self.lineage.top_lineages\n\t        # Filter the barcodes for our next search. Sorting by total and lineage\n\t        # so that the results are consistent on re-run\n\t        barcode_summary = barcode_summary[\n\t            ~barcode_summary[\"lineage\"].isin(exclude_lineages)\n\t        ].sort_values(by=[\"total\", \"lineage\"])\n", "        # ---------------------------------------------------------------------\n\t        # EDGE CASES\n\t        # This section is for legacy detection of SARS-CoV-2 lineages, which have\n\t        # little to no diagnostic mutation/barcode support.\n\t        # num_conflicts = (\n\t        #   len(self.lineage.conflict_alt) + len(self.lineage.conflict_ref\n\t        # )\n\t        # Edge cases are for designated recombinants, so only run if the genome\n\t        # was a perfect match (no conflicts)\n\t        if edge_cases and self.lineage.recombinant in EDGE_CASE_RECOMBINANTS:\n", "            # `handle_edge_cases` will adjust these global parameters, just\n\t            #   for this genome if it's an edge case.\n\t            result = handle_edge_cases(\n\t                self, barcode_summary, tree, min_subs, min_length, min_consecutive\n\t            )\n\t            min_subs = result[\"min_subs\"]\n\t            min_length = result[\"min_length\"]\n\t            min_consecutive = result[\"min_consecutive\"]\n\t            barcode_summary = result[\"barcode_summary\"]\n\t        # ---------------------------------------------------------------------\n", "        # Assign parent_1\n\t        if self.debug:\n\t            self.logger.info(str(datetime.now()) + \"\\t\\tPARENT 1:\")\n\t        self.recombination.parent_1 = self.lineage_assignment(\n\t            barcode_summary=barcode_summary,\n\t            barcodes=barcodes,\n\t            tree=tree,\n\t            recombinant_lineages=recombinant_lineages,\n\t            recombinant_tree=recombinant_tree,\n\t            lineage_to_clade=lineage_to_clade,\n", "            diagnostic=diagnostic,\n\t        )\n\t        # If parent_1 has no conflict_refs, don't search for more parents\n\t        #     i.e. it's a perfect match, no evidence of recombination\n\t        # exception: recursive recombinants such as XBL are a perfect match\n\t        #    to their recombinant parent XBB conflict_ref\n\t        #    I'm not 100% convinced by this logic, I think the problem is more\n\t        #    generally when the recombinant lineage is extremely closely related\n\t        #    to it's parents.\n\t        if (\n", "            len(self.recombination.parent_1.conflict_ref) == 0\n\t            and not self.lineage.recursive\n\t        ):\n\t            if self.debug:\n\t                self.logger.info(\n\t                    str(datetime.now())\n\t                    + \"\\t\\t\"\n\t                    + self.recombination.parent_1.name\n\t                    + \" is a perfect match, halting recombinant search.\"\n\t                )\n", "            # Override the existing lineage assignment with parent_1?\n\t            self.lineage = self.recombination.parent_1\n\t            self.lineage.recombinant = False\n\t            return 0\n\t        # ---------------------------------------------------------------------\n\t        # Assign parent_2\n\t        # First, exclude all descendants of parent_1 from the search\n\t        parent_1_tree = next(tree.find_clades(self.recombination.parent_1.name))\n\t        parent_1_descendants = [c.name for c in parent_1_tree.find_clades()]\n\t        exclude_lineages += parent_1_descendants\n", "        # Next, restrict barcodes to only lineages with the\n\t        # conflict_alt (subs that are not in parent_1's barcode)\n\t        # keep lineages that have ANY number of these substitutions, which means\n\t        # the final retained lineages will be very permissive/sensitive.\n\t        conflict_alt_summary = self.summarise_barcodes(\n\t            barcodes=barcodes, barcodes_subs=self.recombination.parent_1.conflict_alt\n\t        )\n\t        # This is a super-detailed debugging statement.\n\t        # if self.debug:\n\t        #     df_md = conflict_alt_summary.to_markdown(index=False).replace(\n", "        #         \"\\n\", \"\\n\" + \"\\t\" * 7\n\t        #     )\n\t        #     self.logger.info(\n\t        #         str(datetime.now())\n\t        #         + \"\\t\\t\\tCONFLICT ALT (INCLUDE):\\n\"\n\t        #         + (\"\\t\") * 7 + df_md\n\t        #     )\n\t        # Remove lineages with the conflict_ref (ref bases\n\t        # where parent_1 has a mutation)\n\t        conflict_ref_summary = self.summarise_barcodes(\n", "            barcodes=barcodes, barcodes_subs=self.recombination.parent_1.conflict_ref\n\t        )\n\t        # exclude lineages that have ALL ref bases, which means the final\n\t        # retained lineages are very permissive/sensitive.\n\t        conflict_ref_summary = conflict_ref_summary[\n\t            conflict_ref_summary[\"total\"]\n\t            == len(self.recombination.parent_1.conflict_alt)\n\t        ]\n\t        exclude_lineages += list(conflict_ref_summary[\"lineage\"])\n\t        # This is a super-detailed debugging statement.\n", "        # if self.debug:\n\t        #     df_md = conflict_ref_summary.to_markdown(index=False).replace(\n\t        #         \"\\n\", \"\\n\" + \"\\t\" * 7\n\t        #     )\n\t        #     self.logger.info(\n\t        #         str(datetime.now())\n\t        #         + \"\\t\\t\\tCONFLICT REF (EXCLUDE):\\n\"\n\t        #         + (\"\\t\") * 7 + df_md\n\t        #     )\n\t        # If lineages match the conflict_alt\n", "        if len(conflict_alt_summary) > 0:\n\t            # The new barcode_summary is just lineages that will help\n\t            # us resolve these conflicts\n\t            barcode_summary = conflict_alt_summary[\n\t                ~conflict_alt_summary[\"lineage\"].isin(exclude_lineages)\n\t            ]\n\t        # No lineages match the conflict_alt, and we're allowing 0 uniq subs\n\t        elif min_subs == 0:\n\t            barcode_summary = barcode_summary[\n\t                ~barcode_summary[\"lineage\"].isin(exclude_lineages)\n", "            ]\n\t        # No lineages match, and we're NOT allowing 0 uniq subs\n\t        # Therefore, stop searching for next parents\n\t        else:\n\t            if self.debug:\n\t                self.logger.info(\n\t                    str(datetime.now())\n\t                    + \"\\t\\t\"\n\t                    + self.recombination.parent_1.name\n\t                    + \" has no lineages that match it's conflict_alt subs\"\n", "                    + \" halting recombinant search.\"\n\t                )\n\t                self.lineage.recombinant = False\n\t            return 0\n\t        # Now, we search through the barcodes\n\t        recombination_detected = False\n\t        depth = 0\n\t        # Search through the top lineages for a suitable parent 2\n\t        # Keep searching unless we max out the depth counter or find recombination\n\t        while depth < max_depth and not recombination_detected:\n", "            depth += 1\n\t            # Exclude the previous loops lineages\n\t            barcode_summary = barcode_summary[\n\t                ~barcode_summary[\"lineage\"].isin(exclude_lineages)\n\t            ]\n\t            # If we've run out of barcodes, no recombination!\n\t            if len(barcode_summary) == 0:\n\t                if self.debug:\n\t                    self.logger.info(\n\t                        str(datetime.now()) + \"\\t\\tNo more barcodes to parse.\"\n", "                    )\n\t                break\n\t            # Summarize the barcode support for the next top lineages\n\t            if self.debug:\n\t                self.logger.info(\n\t                    str(datetime.now())\n\t                    + \"\\t\\tPARENT 2 | DEPTH: {} / {}\".format(depth, max_depth)\n\t                )\n\t            # Summarize the barcode support for the next top lineages\n\t            parent_2 = self.lineage_assignment(\n", "                barcode_summary=barcode_summary,\n\t                barcodes=barcodes,\n\t                diagnostic=diagnostic,\n\t                tree=tree,\n\t                recombinant_lineages=recombinant_lineages,\n\t                recombinant_tree=recombinant_tree,\n\t                lineage_to_clade=lineage_to_clade,\n\t            )\n\t            # Detect recombination\n\t            recombination = Recombination(\n", "                genome=self,\n\t                parent_1=self.recombination.parent_1,\n\t                parent_2=parent_2,\n\t                max_breakpoints=max_breakpoints,\n\t                min_subs=min_subs,\n\t                min_length=min_length,\n\t                min_consecutive=min_consecutive,\n\t            )\n\t            recombination.depth = depth\n\t            # If recombination was detected, break free of search loop!\n", "            if len(recombination.breakpoints) > 0:\n\t                recombination_detected = True\n\t                self.recombination = recombination\n\t                # If this is not a known recombinant, mark as undesignated\n\t                if not self.lineage.recombinant:\n\t                    self.lineage.recombinant = \"undesignated\"\n\t            # Otherwise, update our exclude lineages for the next search\n\t            else:\n\t                # exclude_lineages += parent_2.top_lineages\n\t                exclude_lineages += [\n", "                    l\n\t                    for l in parent_2.top_lineages\n\t                    if l not in parent_2.outlier_lineages\n\t                ]\n\t        # No recombination detected\n\t        if not recombination_detected and not self.lineage.recombinant:\n\t            self.lineage.recombinant = False\n\t        # Both parents are the same, something has gone wrong!!\n\t        if self.recombination.parent_1.name == self.recombination.parent_2.name:\n\t            msg = \"RebarError: {} parent_1 and parent_2 are identical ({})\".format(\n", "                self.id, self.recombination.parent_1.name\n\t            )\n\t            # # has multiprocess hang complications\n\t            # raise SystemExit(RebarError(msg))\n\t            self.logger.info(str(datetime.now()) + \"\\t\\t\" + msg)\n\t        return 0\n\t    def validate_recombination(self, tree, recombinant_lineages):\n\t        # Identify which lineages are known recombinants\n\t        # ie. descended from the \"X\" recombinant MRCA node\n\t        lineages = [c.name for c in tree.find_clades()]\n", "        status = None\n\t        warn = False\n\t        if self.id in lineages:\n\t            if self.id in recombinant_lineages:\n\t                expected = \"positive\"\n\t            else:\n\t                expected = \"negative\"\n\t            # Correct positive\n\t            if self.lineage.recombinant and expected == \"positive\":\n\t                status = \"positive\"\n", "                if len(self.recombination.breakpoints) == 0:\n\t                    status += \";no_breakpoints\"\n\t                    warn = True\n\t            # Correct negative\n\t            elif not self.lineage.recombinant and expected == \"negative\":\n\t                status = \"negative\"\n\t            # False positive\n\t            elif self.lineage.recombinant and expected == \"negative\":\n\t                status = \"false_positive\"\n\t                warn = True\n", "            # False negative\n\t            elif not self.lineage.recombinant and expected == \"positive\":\n\t                status = \"false_negative\"\n\t                warn = True\n\t            msg = (\n\t                \"Validation fail for {}\".format(self.id)\n\t                + \", expected='{}'\".format(expected)\n\t                + \", actual='{}'\".format(status)\n\t            )\n\t            if warn:\n", "                self.logger.info(str(datetime.now()) + \"\\t\\tWARNING: \" + msg)\n\t                # # Full error raise\n\t                # # has multiprocess hang complications\n\t                # if self.validate_fail:\n\t                #     raise SystemExit(RebarError(\"RebarError: \" + msg))\n\t                # Just a warning\n\t                # else:\n\t                #    self.logger.info(str(datetime.now()) + \"\\t\\tWARNING: \" + msg)\n\t        return status\n\tdef genome_mp(iterator, **kwargs):\n", "    \"\"\"\n\t    Create Genome with multiprocess.\n\t    Used to control the named parameters that are passed.\n\t    \"\"\"\n\t    # When creating from FASTA, iterator is a SeqRecord\n\t    if type(iterator) == SeqRecord:\n\t        kwargs[\"record\"] = iterator\n\t    # When creating from SUBS df, iterator is a tuple\n\t    elif type(iterator) == tuple:\n\t        # First value is index, second value is series\n", "        kwargs[\"subs_row\"] = iterator[1]\n\t    # else:\n\t    #    raise RebarError(\"Unknown iterator was passed to genome_mp.\")\n\t    genome = Genome(**kwargs)\n\t    return genome\n"]}
{"filename": "rebar/recombination.py", "chunked_list": ["import yaml\n\timport pandas as pd\n\tfrom datetime import datetime\n\tfrom .barcode import Barcode\n\tfrom .substitution import Substitution\n\tclass Recombination:\n\t    def __init__(\n\t        self,\n\t        genome=None,\n\t        parent_1=None,\n", "        parent_2=None,\n\t        max_breakpoints=1,\n\t        min_subs=1,\n\t        min_length=1,\n\t        min_consecutive=1,\n\t    ):\n\t        self.parent_1 = Barcode()\n\t        self.parent_2 = Barcode()\n\t        self.breakpoints = []\n\t        self.regions = {}\n", "        self.dataframe = None\n\t        self.depth = 0\n\t        if parent_1:\n\t            self.parent_1 = parent_1\n\t        if parent_2:\n\t            self.parent_2 = parent_2\n\t        if genome and parent_1 and parent_2:\n\t            self.search(\n\t                genome,\n\t                parent_1,\n", "                parent_2,\n\t                max_breakpoints,\n\t                min_subs,\n\t                min_length,\n\t                min_consecutive,\n\t            )\n\t    def __repr__(self):\n\t        \"\"\"\n\t        Printable representation of a Recombination object.\n\t        Returns\n", "        -------\n\t        text : str\n\t            String representation.\n\t        \"\"\"\n\t        return self.to_yaml()\n\t    def to_dict(self):\n\t        recombination_dict = {\n\t            \"breakpoints\": \",\".join(self.breakpoints),\n\t            \"regions\": \",\".join(\n\t                [\n", "                    \"{}-{}|{}\".format(r[\"start\"], r[\"end\"], r[\"parent\"])\n\t                    for r in self.regions.values()\n\t                ]\n\t            ),\n\t            \"parent_1\": self.parent_1.to_dict(),\n\t            \"parent_2\": self.parent_2.to_dict(),\n\t            \"depth\": self.depth,\n\t        }\n\t        return recombination_dict\n\t    def to_yaml(self, indent=2):\n", "        \"\"\"\n\t        Convert Recombination object to yaml.\n\t        Returns\n\t        -------\n\t        genome_yaml : yaml\n\t            YAML representation.\n\t        \"\"\"\n\t        recombination_yaml = (\n\t            yaml.dump(self.to_dict(), sort_keys=False, indent=indent)\n\t            .replace(\"null\", \"\")\n", "            .replace(\"''\", \"\")\n\t            + \"\\n\"\n\t        )\n\t        return recombination_yaml\n\t    def search(\n\t        self,\n\t        genome,\n\t        parent_1,\n\t        parent_2,\n\t        max_breakpoints=1,\n", "        min_subs=1,\n\t        min_length=1,\n\t        min_consecutive=1,\n\t    ):\n\t        # ---------------------------------------------------------------------\n\t        # Initialize Barcode Dataframe\n\t        # Create a dataframe where rows are coordinates and columns are\n\t        #   coord, parent, Reference, <parent_1>, <parent_2>, <genome>\n\t        # Identify which subs are non-bi-allelic, these will wind up being\n\t        # duplicate rows, which we'll need to reconcile and collapse\n", "        all_subs = sorted(\n\t            list(set(parent_1.barcode + parent_2.barcode + genome.substitutions))\n\t        )\n\t        all_coords = [s.coord for s in all_subs]\n\t        dup_coords = set([c for c in all_coords if all_coords.count(c) > 1])\n\t        # Re-do all subs list just with parents\n\t        all_subs = sorted(list(set(parent_1.barcode + parent_2.barcode)))\n\t        parent_1_subs = [s for s in parent_1.barcode if s not in parent_2.barcode]\n\t        parent_2_subs = [s for s in parent_2.barcode if s not in parent_1.barcode]\n\t        parent_1_coords = [s.coord for s in parent_1_subs]\n", "        parent_2_coords = [s.coord for s in parent_2_subs]\n\t        genome_coords = [s.coord for s in genome.substitutions]\n\t        # Create the barcode dataframe as described.\n\t        subs_df = pd.DataFrame(\n\t            {\n\t                \"coord\": [s.coord for s in all_subs],\n\t                \"Reference\": [s.ref for s in all_subs],\n\t                parent_1.name: [\n\t                    s.alt if s in parent_1_subs else s.ref for s in all_subs\n\t                ],\n", "                parent_2.name: [\n\t                    s.alt if s in parent_2_subs else s.ref for s in all_subs\n\t                ],\n\t                genome.id: [\n\t                    \"N\"\n\t                    if s.coord in genome.missing\n\t                    else \"-\"\n\t                    if s.coord in genome.deletions\n\t                    else s.alt\n\t                    if s in genome.substitutions\n", "                    else s.ref\n\t                    for s in all_subs\n\t                ],\n\t            }\n\t        ).sort_values(by=\"coord\")\n\t        # ---------------------------------------------------------------------\n\t        # Collapse duplicate rows from non bi-allelic sites\n\t        for coord in dup_coords:\n\t            # Get base of reference\n\t            ref_base = [s.ref for s in all_subs if s.coord == coord][0]\n", "            # Get base of parent 1\n\t            parent_1_base = ref_base\n\t            if coord in parent_1_coords:\n\t                parent_1_base = [s.alt for s in parent_1_subs if s.coord == coord][0]\n\t            # Get base of parent 2\n\t            parent_2_base = ref_base\n\t            if coord in parent_2_coords:\n\t                parent_2_base = [s.alt for s in parent_2_subs if s.coord == coord][0]\n\t            # If alt's of parent1 and parent2 are same, just exclude, not helpful\n\t            if parent_1_base == parent_2_base:\n", "                # Remove the old duplicate rows\n\t                subs_df = subs_df[subs_df[\"coord\"] != coord]\n\t                continue\n\t            # Otherwise, we'll tidy up and collapse the duplicates\n\t            else:\n\t                # Get base of genomic sample\n\t                genome_base = ref_base\n\t                if coord in genome_coords:\n\t                    genome_base = [\n\t                        s.alt for s in genome.substitutions if s.coord == coord\n", "                    ][0]\n\t                elif coord in genome.missing:\n\t                    genome_base = \"N\"\n\t                elif coord in genome.deletions:\n\t                    genome_base = \"-\"\n\t                data = {\n\t                    \"coord\": [coord],\n\t                    \"Reference\": [ref_base],\n\t                    parent_1.name: [parent_1_base],\n\t                    parent_2.name: [parent_2_base],\n", "                    genome.id: [genome_base],\n\t                }\n\t                row = pd.DataFrame(data)\n\t                # Remove the old duplicate rows\n\t                subs_df = subs_df[subs_df[\"coord\"] != coord]\n\t                # Add new deduplicated row\n\t                subs_df = pd.concat([subs_df, row]).sort_values(by=\"coord\")\n\t        # Identify private genome substitutions and exclude these\n\t        private_sub_coords = list(\n\t            subs_df[\n", "                (subs_df[genome.id] != subs_df[parent_1.name])\n\t                & (subs_df[genome.id] != subs_df[parent_2.name])\n\t                & (subs_df[genome.id] != subs_df[\"Reference\"])\n\t            ][\"coord\"]\n\t        )\n\t        subs_df = subs_df[~subs_df[\"coord\"].isin(private_sub_coords)]\n\t        # ---------------------------------------------------------------------\n\t        # Annotate dataframe with parental origin\n\t        # Identify genome sub origins by parent, this is not an efficient method\n\t        genome_subs_origin = []\n", "        for rec in subs_df.iterrows():\n\t            genome_base = rec[1][genome.id]\n\t            parent_1_base = rec[1][parent_1.name]\n\t            parent_2_base = rec[1][parent_2.name]\n\t            if genome_base == parent_1_base and genome_base == parent_2_base:\n\t                origin = \"shared\"\n\t            elif genome_base == parent_1_base:\n\t                origin = parent_1.name\n\t            elif genome_base == parent_2_base:\n\t                origin = parent_2.name\n", "            genome_subs_origin.append(origin)\n\t        subs_df.insert(loc=1, column=\"parent\", value=genome_subs_origin)\n\t        # ---------------------------------------------------------------------\n\t        # Remove non-discriminating sites\n\t        # Search for genomic blocks from each parent\n\t        # Just look at the subs/barcodes that are uniq to one parent and in sample\n\t        subs_df = subs_df[(subs_df[\"parent\"] != \"shared\")]\n\t        if genome.debug:\n\t            genome.logger.info(str(datetime.now()) + \"\\t\\t\\tBARCODE DISCRIMINATING:\")\n\t            subs_md = subs_df.to_markdown(index=False)\n", "            subs_str = subs_md.replace(\"\\n\", \"\\n\" + \"\\t\" * 7)\n\t            genome.logger.info(str(datetime.now()) + \"\\t\\t\\t\\t\" + subs_str)\n\t        # Each parent must have at least x min_subs that are lineage-determining\n\t        parent_1_uniq = subs_df[\n\t            (subs_df[\"parent\"] == parent_1.name)\n\t            & (subs_df[parent_1.name] != subs_df[\"Reference\"])\n\t        ]\n\t        parent_1_num_uniq = len(parent_1_uniq)\n\t        parent_2_uniq = subs_df[\n\t            (subs_df[\"parent\"] == parent_2.name)\n", "            & (subs_df[parent_2.name] != subs_df[\"Reference\"])\n\t        ]\n\t        parent_2_num_uniq = len(parent_2_uniq)\n\t        if parent_1_num_uniq < min_subs:\n\t            if genome.debug:\n\t                genome.logger.info(\n\t                    str(datetime.now())\n\t                    + \"\\t\\t\\tInsufficient unique substitutions from parent_1: \"\n\t                    + parent_1.name\n\t                )\n", "            return None\n\t        if parent_2_num_uniq < min_subs:\n\t            if genome.debug:\n\t                genome.logger.info(\n\t                    str(datetime.now())\n\t                    + \"\\t\\t\\tInsufficient unique substitutions from parent_2: \"\n\t                    + parent_2.name\n\t                )\n\t            return None\n\t        # ---------------------------------------------------------------------\n", "        # Identify and filter parental regions\n\t        # First: 5' -> 3'\n\t        regions_5p = self.identify_regions(subs_df, genome)\n\t        regions_5p = self.filter_regions_5p(regions_5p, min_consecutive, 0)\n\t        regions_5p = self.filter_regions_5p(regions_5p, 0, min_length)\n\t        if genome.debug:\n\t            genome.logger.info(\n\t                str(datetime.now()) + \"\\t\\t\\tREGIONS 5': \" + str(regions_5p)\n\t            )\n\t        # Second: 3' to 5'\n", "        regions_3p = self.identify_regions(subs_df, genome)\n\t        regions_3p = dict(reversed(regions_3p.items()))\n\t        regions_3p = self.filter_regions_3p(regions_3p, min_consecutive, 0)\n\t        regions_3p = self.filter_regions_3p(regions_3p, 0, min_length)\n\t        regions_3p = dict(reversed(regions_3p.items()))\n\t        if genome.debug:\n\t            genome.logger.info(\n\t                str(datetime.now()) + \"\\t\\t\\tREGIONS 3': \" + str(regions_3p)\n\t            )\n\t        # Reconcile 5' vs. 3' differences, by increasing uncertainty\n", "        regions_intersect = self.intersect_regions(regions_5p, regions_3p)\n\t        # During reconciliation, it's possible that a region from 1 single parent\n\t        # got broken up into multiple adjacent sections. Put it through the\n\t        # filter again to collapse it.\n\t        regions_intersect = self.filter_regions_5p(\n\t            regions_intersect, min_consecutive, min_length\n\t        )\n\t        if genome.debug:\n\t            genome.logger.info(\n\t                str(datetime.now())\n", "                + \"\\t\\t\\tREGIONS INTERSECT: \"\n\t                + str(regions_intersect)\n\t            )\n\t        # If we're left with one filtered parental region, no recombination\n\t        if len(regions_intersect) < 2:\n\t            if genome.debug:\n\t                genome.logger.info(\n\t                    str(datetime.now()) + \"\\t\\t\\t\" + \"No breakpoints detected.\"\n\t                )\n\t            return None\n", "        # ---------------------------------------------------------------------\n\t        # Identify breakpoints\n\t        breakpoints = self.identify_breakpoints(regions_intersect)\n\t        if genome.debug:\n\t            genome.logger.info(\n\t                str(datetime.now()) + \"\\t\\t\\tBREAKPOINTS: \" + str(breakpoints)\n\t            )\n\t        if len(breakpoints) > max_breakpoints:\n\t            if genome.debug:\n\t                genome.logger.info(\n", "                    str(datetime.now()) + \"\\t\\t\\tNumber of breakpoints exceeds maximum.\"\n\t                )\n\t            return None\n\t        # Finish, update class attributes\n\t        self.dataframe = subs_df\n\t        self.regions = regions_intersect\n\t        self.breakpoints = breakpoints\n\t        return 0\n\t    def identify_regions(self, df, genome):\n\t        # Identifying parental regions\n", "        regions = {}\n\t        p_prev = None\n\t        start = 0\n\t        end = 0\n\t        for rec in df.iterrows():\n\t            p_curr = rec[1][\"parent\"]\n\t            sub = Substitution(\n\t                \"{}{}{}\".format(rec[1][\"Reference\"], rec[1][\"coord\"], rec[1][genome.id])\n\t            )\n\t            # First region\n", "            if not p_prev:\n\t                start = sub.coord\n\t                end = sub.coord\n\t                regions[start] = {\n\t                    \"start\": start,\n\t                    \"end\": end,\n\t                    \"parent\": p_curr,\n\t                    \"subs\": [sub],\n\t                }\n\t            # Same parent, region continues\n", "            elif p_curr == p_prev:\n\t                regions[start][\"end\"] = sub.coord\n\t                regions[start][\"subs\"].append(sub)\n\t            # Parent change, start of new region\n\t            elif p_curr != p_prev:\n\t                start = sub.coord\n\t                end = sub.coord\n\t                regions[start] = {\n\t                    \"start\": start,\n\t                    \"end\": end,\n", "                    \"parent\": p_curr,\n\t                    \"subs\": [sub],\n\t                }\n\t            end = sub.coord\n\t            p_prev = p_curr\n\t        return regions\n\t    def filter_regions_5p(self, regions, min_consecutive, min_length):\n\t        regions_filter = {}\n\t        prev_start = None\n\t        prev_parent = None\n", "        for start in regions:\n\t            parent = regions[start][\"parent\"]\n\t            end = regions[start][\"end\"]\n\t            subs = regions[start][\"subs\"]\n\t            num_consecutive = len(subs)\n\t            region_length = (end - start) + 1\n\t            # Option 1. First filtered region, or a different parent\n\t            if not prev_parent or prev_parent != parent:\n\t                # Is the new parental region long enough?\n\t                if num_consecutive >= min_consecutive and region_length >= min_length:\n", "                    regions_filter[start] = regions[start]\n\t                    prev_parent = parent\n\t                    prev_start = start\n\t                # Otherwise, continue to next region\n\t                else:\n\t                    continue\n\t            # Option 2. Prev parent continuation\n\t            elif prev_parent == parent:\n\t                # Update end coordinates and subs\n\t                regions_filter[prev_start][\"end\"] = end\n", "                regions_filter[prev_start][\"subs\"] += subs\n\t                continue\n\t        return regions_filter\n\t    def filter_regions_3p(self, regions, min_consecutive, min_length):\n\t        regions_filter = {}\n\t        prev_start = None\n\t        prev_parent = None\n\t        for start in regions:\n\t            parent = regions[start][\"parent\"]\n\t            end = regions[start][\"end\"]\n", "            subs = regions[start][\"subs\"]\n\t            num_consecutive = len(subs)\n\t            region_length = (end - start) + 1\n\t            # First filtered region, or different parent from previous region\n\t            if not prev_parent or prev_parent != parent:\n\t                # Is the new parental region long enough?\n\t                if num_consecutive >= min_consecutive and region_length >= min_length:\n\t                    regions_filter[start] = regions[start]\n\t                    prev_parent = parent\n\t                    prev_start = start\n", "                else:\n\t                    continue\n\t            # A region that continues the previous parent\n\t            # intermissions from other parents were skipped over\n\t            elif prev_parent == parent:\n\t                # Update the previous regions coordinates\n\t                regions_filter[start] = regions[prev_start]\n\t                regions_filter[start][\"subs\"] = sorted(\n\t                    regions_filter[prev_start][\"subs\"] + subs\n\t                )\n", "                regions_filter[start][\"start\"] = regions_filter[start][\"subs\"][0].coord\n\t                regions_filter[start][\"end\"] = regions_filter[start][\"subs\"][-1].coord\n\t                regions_filter.pop(prev_start)\n\t                prev_start = start\n\t                continue\n\t        return regions_filter\n\t    def intersect_regions(self, regions_1, regions_2):\n\t        regions_intersect = {}\n\t        for r1 in regions_1.values():\n\t            r1_parent = r1[\"parent\"]\n", "            r1_subs = set(r1[\"subs\"])\n\t            for r2 in regions_2.values():\n\t                r2_parent = r2[\"parent\"]\n\t                if r1_parent != r2_parent:\n\t                    continue\n\t                r2_subs = set(r2[\"subs\"])\n\t                subs_intersect = r1_subs.intersection(r2_subs)\n\t                if len(subs_intersect) == 0:\n\t                    continue\n\t                start = min(subs_intersect).coord\n", "                end = max(subs_intersect).coord\n\t                regions_intersect[start] = {\n\t                    \"start\": start,\n\t                    \"end\": end,\n\t                    \"parent\": r1_parent,\n\t                    \"subs\": sorted(subs_intersect),\n\t                }\n\t        # We should probably repeat this doing r2 to r1 comparisons\n\t        # because there might be r2 regions not at all contained by r1\n\t        # I need to find an exmaple or simulate to test this\n", "        return regions_intersect\n\t    def identify_breakpoints(self, regions):\n\t        breakpoints = []\n\t        prev_start_coord = None\n\t        prev_end_coord = None\n\t        for start_coord in regions:\n\t            end_coord = regions[start_coord][\"end\"]\n\t            # Skip the first record for breakpoints\n\t            if prev_start_coord:\n\t                breakpoint_start = prev_end_coord + 1\n", "                breakpoint_end = start_coord - 1\n\t                breakpoint = \"{}-{}\".format(breakpoint_start, breakpoint_end)\n\t                breakpoints.append(breakpoint)\n\t            prev_start_coord = start_coord\n\t            prev_end_coord = end_coord\n\t        return breakpoints\n"]}
{"filename": "rebar/edge_cases.py", "chunked_list": ["# The function `handle_edge_cases` is called in `genome.py` at Line 610.\n\t# The currently implemented params that can be customized for a sample are:\n\t#   1. min_consecutive\n\t#   2. min_subs\n\t#   3. min_length\n\t#   4. barcode_summary: summary of barcode matches to find parent_1\n\t# More parameters could be added as needed, with the correponding updates\n\t# added to `genome.py`\n\tdef handle_edge_cases(\n\t    genome, barcode_summary, tree, min_subs, min_length, min_consecutive\n", "):\n\t    \"\"\"\n\t    Edge case handling for recombinants with few mutations.\n\t    \"\"\"\n\t    # These are the parameters we might need to adjust in an edge case\n\t    result = {\n\t        \"min_consecutive\": min_consecutive,\n\t        \"min_subs\": min_subs,\n\t        \"min_length\": min_length,\n\t        \"barcode_summary\": barcode_summary,\n", "    }\n\t    # ---------------------------------------------------------------------\n\t    # XB: top_lineages are tied exactly B.1.631 and B.1.634\n\t    #     force the first parent to be B.1.631\n\t    #     there is maybe a small second breakpoint (~100 nuc)\n\t    if genome.lineage.recombinant in [\"XB\"]:\n\t        include_tree = next(tree.find_clades(\"B.1.631\"))\n\t        include_descendants = [c.name for c in include_tree.find_clades()]\n\t        result[\"barcode_summary\"] = barcode_summary[\n\t            barcode_summary[\"lineage\"].isin(include_descendants)\n", "        ]\n\t        result[\"min_length\"] = 100\n\t    # ---------------------------------------------------------------------\n\t    # XP: second parent (BA.2) comes from only one barcode position: A29510C\n\t    #     force first parent to be BA.2 and relax region/subs lengths\n\t    elif genome.lineage.recombinant in [\"XP\"]:\n\t        include_tree = next(tree.find_clades(\"BA.2\"))\n\t        include_descendants = [c.name for c in include_tree.find_clades()]\n\t        result[\"barcode_summary\"] = barcode_summary[\n\t            barcode_summary[\"lineage\"].isin(include_descendants)\n", "        ]\n\t        result[\"min_consecutive\"] = 1\n\t        result[\"min_length\"] = 1\n\t    # ---------------------------------------------------------------------\n\t    # XR: no diagnostic subs from second parent, only 2 consecutive barcodes\n\t    #     relax region/subs lengths\n\t    elif genome.lineage.recombinant in [\"XR\"]:\n\t        result[\"min_subs\"] = 0\n\t        result[\"min_consecutive\"] = 2\n\t    # ---------------------------------------------------------------------\n", "    # XAD, XAE: second_parent only has 1 conflict sub\n\t    #     force the first parent to be the minor parent (BA.1)\n\t    elif genome.lineage.recombinant in [\"XAD\", \"XAE\"]:\n\t        include_tree = next(tree.find_clades(\"BA.1\"))\n\t        include_descendants = [c.name for c in include_tree.find_clades()]\n\t        result[\"barcode_summary\"] = barcode_summary[\n\t            barcode_summary[\"lineage\"].isin(include_descendants)\n\t        ]\n\t        result[\"min_consecutive\"] = 5\n\t    # ---------------------------------------------------------------------\n", "    # XAJ: Parent 2 (BA.4) is tiny (120 nuc), force parent 1 to be BA.4\n\t    #      and relax min_length.\n\t    elif genome.lineage.recombinant in [\"XAJ\"]:\n\t        include_tree = next(tree.find_clades(\"BA.4\"))\n\t        include_descendants = [c.name for c in include_tree.find_clades()]\n\t        result[\"barcode_summary\"] = barcode_summary[\n\t            barcode_summary[\"lineage\"].isin(include_descendants)\n\t        ]\n\t        result[\"min_length\"] = 4\n\t    # ---------------------------------------------------------------------\n", "    # XAS: The pango designation required deletions to resolve the first parent\n\t    elif genome.lineage.recombinant in [\"XAS\"]:\n\t        include_tree = next(tree.find_clades(\"BA.4\"))\n\t        include_descendants = [c.name for c in include_tree.find_clades()]\n\t        result[\"barcode_summary\"] = barcode_summary[\n\t            barcode_summary[\"lineage\"].isin(include_descendants)\n\t        ]\n\t    # ---------------------------------------------------------------------\n\t    # XAV: no diagnostic subs from second parent, only 2 consecutive barcodes\n\t    #      BA.5.1.24 interferes\n", "    elif genome.lineage.recombinant in [\"XAV\"]:\n\t        exclude_tree = next(tree.find_clades(\"BA.5.1.24\"))\n\t        exclude_descendants = [c.name for c in exclude_tree.find_clades()]\n\t        result[\"min_subs\"] = 0\n\t        result[\"min_consecutive\"] = 2\n\t        result[\"barcode_summary\"] = barcode_summary[\n\t            ~barcode_summary[\"lineage\"].isin(exclude_descendants)\n\t        ]\n\t    # ---------------------------------------------------------------------\n\t    # XAY: Many breakpoints, some very small (200 nuc)\n", "    elif genome.lineage.recombinant in [\"XAY\"]:\n\t        result[\"min_length\"] = 200\n\t    # ---------------------------------------------------------------------\n\t    # XAZ: no diagnostic subs from BA.2, only 1 consecutive barcode from BA.2 parent\n\t    #     force the minor parent (BA.2) to be the first parent\n\t    #     this improves the search for the major parent (BA.5)\n\t    elif genome.lineage.recombinant in [\"XAZ\"]:\n\t        include_tree = next(tree.find_clades(\"BA.2\"))\n\t        include_descendants = [c.name for c in include_tree.find_clades()]\n\t        result[\"barcode_summary\"] = barcode_summary[\n", "            barcode_summary[\"lineage\"].isin(include_descendants)\n\t        ]\n\t        result[\"min_subs\"] = 0\n\t        result[\"min_consecutive\"] = 1\n\t        result[\"min_length\"] = 1\n\t    # ---------------------------------------------------------------------\n\t    # XBC: only 2 consecutive barcodes for first breakpoint\n\t    elif genome.lineage.recombinant in [\"XBC\"]:\n\t        result[\"min_consecutive\"] = 2\n\t    # ---------------------------------------------------------------------\n", "    # XBK, XBQ: only 2 consecutive barcodes\n\t    elif genome.lineage.recombinant in [\"XBK\", \"XBQ\"]:\n\t        include_tree = next(tree.find_clades(\"BA.2\"))\n\t        include_descendants = [c.name for c in include_tree.find_clades()]\n\t        result[\"barcode_summary\"] = barcode_summary[\n\t            barcode_summary[\"lineage\"].isin(include_descendants)\n\t        ]\n\t        result[\"min_consecutive\"] = 2\n\t    # ---------------------------------------------------------------------\n\t    # XBZ: only 2 consecutive barcodes, extremely short parent 2 length\n", "    elif genome.lineage.recombinant in [\"XBZ\"]:\n\t        result[\"min_consecutive\"] = 2\n\t        result[\"min_length\"] = 300\n\t    return result\n"]}
{"filename": "rebar/__init__.py", "chunked_list": ["# This code is executed when imported as a module\n\t# -----------------------------------------------------------------------------\n\t# Version\n\tversion = \"0.1.0\"\n\t# -----------------------------------------------------------------------------\n\t# Errors\n\tclass RebarError(Exception):\n\t    \"\"\"\n\t    RebarError class\n\t    Parent class for more specific errors\n", "    Raised when rebar is used incorrectly in a known way.\n\t    \"\"\"\n\t    pass\n\tclass RebarUnknownError(Exception):\n\t    \"\"\"\n\t    RebarUnknownError class\n\t    Raised when rebar is used incorrectly in a unknown way.\n\t    \"\"\"\n\t    pass\n\tclass MissingDataError(RebarError):\n", "    \"\"\"MissingDataError class raised when X is missing.\"\"\"\n\t    pass\n\t# -----------------------------------------------------------------------------\n\t# Module functions\n\tfrom .argument_parser import make_parser\n"]}
{"filename": "rebar/utils.py", "chunked_list": ["import sys\n\timport logging\n\timport os\n\tfrom datetime import datetime\n\tfrom io import StringIO\n\timport requests\n\timport urllib\n\timport functools\n\timport yaml\n\timport zstandard as zstd\n", "import pandas as pd\n\tfrom pango_aliasor.aliasor import Aliasor\n\tfrom Bio import Phylo, Entrez, SeqIO\n\tfrom Bio.Phylo.BaseTree import Clade\n\tfrom multiprocess import Pool  # Note that we are importing \"multiprocess\", no \"ing\"!\n\tfrom tqdm import tqdm\n\tfrom .genome import genome_mp\n\tfrom .substitution import Substitution\n\tfrom .constants import (\n\t    NO_DATA_CHAR,\n", "    PANGO_SEQUENCES_URL,\n\t    BARCODES_NEXTCLADE_URL,\n\t    BARCODES_USHER_URL,\n\t    BARCODE_MANUAL_EDITS,\n\t    PROBLEMATIC_LINEAGES,\n\t    LINEAGE_SUMMARY_URL,\n\t    ALIAS_KEY_URL,\n\t)\n\tfrom .export import Export\n\t# -----------------------------------------------------------------------------\n", "# Classes\n\t# -----------------------------------------------------------------------------\n\tclass Namespace:\n\t    def __init__(self, **kwargs):\n\t        self.__dict__.update(kwargs)\n\t# -----------------------------------------------------------------------------\n\t# Functions\n\t# -----------------------------------------------------------------------------\n\tdef create_logger(logfile=None):\n\t    \"\"\"\n", "    Create logging object for help messages.\n\t    Parameters\n\t    ----------\n\t        logfile : str\n\t            file path to write log to.\n\t    \"\"\"\n\t    logger = logging.getLogger()\n\t    logger.setLevel(logging.DEBUG)\n\t    # create file handler which logs even debug messages\n\t    if logfile:\n", "        handler = logging.FileHandler(logfile, \"w+\")\n\t    else:\n\t        handler = logging.StreamHandler(sys.stdout)\n\t    handler.setLevel(logging.DEBUG)\n\t    logger.addHandler(handler)\n\t    return logger\n\tdef url_header_info(url):\n\t    info = {}\n\t    # Download the file  and parse info from header\n\t    url_handle = urllib.request.urlopen(url)\n", "    headers = url_handle.info()\n\t    # Date format: Wed, 19 Apr 2023 16:19:59 GMT\n\t    file_date_str = \" \".join(headers[\"date\"].split(\" \")[1:4])\n\t    file_date = datetime.strptime(file_date_str, \"%d %b %Y\").date()\n\t    info[\"url\"] = url\n\t    info[\"date\"] = str(file_date)\n\t    info[\"tag\"] = headers[\"etag\"].replace('\"', \"\")\n\t    return info\n\tdef download_reference_sequence(params, accession):\n\t    \"\"\"\n", "    Download reference sequence from genbank.\n\t    Parameters\n\t    ----------\n\t        accession : str\n\t            Genbank nucleotide accession of reference genome.\n\t        params.logger : logging.RootLogger\n\t            logging object for messages.\n\t        params.outdir : str\n\t            output directory to write fasta sequence to.\n\t    \"\"\"\n", "    logger = params.logger\n\t    # object to hold information about downloaded files\n\t    info = {}\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n\t    logger.info(str(datetime.now()) + \"\\tDownloading reference.\")\n\t    Entrez.email = \"Your.Name.Here@example.org\"\n\t    handle = Entrez.efetch(\n\t        db=\"nucleotide\", id=accession, rettype=\"fasta\", retmode=\"text\"\n\t    )\n\t    record = SeqIO.read(handle, \"fasta\")\n", "    # Export\n\t    file_name = \"reference.fasta\"\n\t    file_path = os.path.join(params.outdir, file_name)\n\t    logger.info(str(datetime.now()) + \"\\tExporting reference: \" + file_path)\n\t    SeqIO.write(record, file_path, \"fasta\")\n\t    # Update info\n\t    info[\"accession\"] = accession\n\t    info[\"file\"] = file_path\n\t    # Finish\n\t    logger.info(str(datetime.now()) + \"\\tFinished downloading reference.\")\n", "    return info\n\tdef download_consensus_sequences(params):\n\t    \"\"\"\n\t    Download consensus sequences of designated sars-cov-2 lineages.\n\t    Sources:\n\t      - github.com/corneliusroemer/pango-sequences\n\t    Parameters\n\t    ----------\n\t        logger : logging.RootLogger\n\t            logging object for messages\n", "        outdir : str\n\t            output directory to write fasta sequences to.\n\t    \"\"\"\n\t    logger = params.logger\n\t    # object to hold information about downloaded files\n\t    info = {}\n\t    # The sequences are a .fasta.zst file, remove the .zst as we're decompressing\n\t    fasta_name = \"alignment.fasta\"\n\t    fasta_path = os.path.join(params.outdir, fasta_name)\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n", "    logger.info(str(datetime.now()) + \"\\tDownloading lineage sequences.\")\n\t    # Summarize url file info\n\t    info = url_header_info(PANGO_SEQUENCES_URL)\n\t    info[\"file\"] = fasta_name\n\t    response = requests.get(PANGO_SEQUENCES_URL, stream=True)\n\t    # Decompress the zstd format\n\t    decomp = zstd.ZstdDecompressor()\n\t    # Write decompressed contents to file (tmp)\n\t    with open(fasta_path, \"wb\") as outfile:\n\t        decomp.copy_stream(response.raw, outfile)\n", "    records = SeqIO.parse(fasta_path, \"fasta\")\n\t    logger.info(str(datetime.now()) + \"\\tApplying edge-case curation.\")\n\t    fasta_lines = []\n\t    for record in records:\n\t        for lineage in BARCODE_MANUAL_EDITS:\n\t            if record.id != lineage:\n\t                continue\n\t            for sub in BARCODE_MANUAL_EDITS[lineage]:\n\t                logger.info(\n\t                    str(datetime.now())\n", "                    + \"\\t\\tAdding \"\n\t                    + lineage\n\t                    + \" barcode \"\n\t                    + str(sub)\n\t                )\n\t                sub = Substitution(sub)\n\t                # genome coordinates are 1 based\n\t                sub_i = sub.coord - 1\n\t                record.seq = record.seq[:sub_i] + sub.alt + record.seq[sub_i + 1 :]\n\t        fasta_lines.append(\">\" + str(record.id))\n", "        fasta_lines.append(str(record.seq))\n\t    logger.info(str(datetime.now()) + \"\\tExported lineage sequences: \" + fasta_path)\n\t    with open(fasta_path, \"w\") as outfile:\n\t        outfile.write(\"\\n\".join(fasta_lines) + \"\\n\")\n\t    # Finish\n\t    logger.info(str(datetime.now()) + \"\\tFinished downloading lineage sequences.\")\n\t    return info\n\tdef create_annotations(params):\n\t    \"\"\"Create gene annotations dataframe.\"\"\"\n\t    logger = params.logger\n", "    logger.info(str(datetime.now()) + \"\\tCreating annotations.\")\n\t    annot_data = {\n\t        \"gene\": [\n\t            \"ORF1a\",\n\t            \"ORF1b\",\n\t            \"S\",\n\t            \"ORF3a\",\n\t            \"E\",\n\t            \"M\",\n\t            \"ORF6\",\n", "            \"ORF7a\",\n\t            \"ORF7b\",\n\t            \"ORF8\",\n\t            \"ORF9b\",\n\t        ],\n\t        \"abbreviation\": [\n\t            \"1a\",\n\t            \"1b\",\n\t            \"S\",\n\t            \"3a\",\n", "            \"E\",\n\t            \"M\",\n\t            \"6\",\n\t            \"7a\",\n\t            \"7b\",\n\t            \"8\",\n\t            \"9b\",\n\t        ],\n\t        \"start\": [\n\t            266,\n", "            13468,\n\t            21563,\n\t            25393,\n\t            26245,\n\t            26523,\n\t            27202,\n\t            27394,\n\t            27756,\n\t            27894,\n\t            28284,\n", "        ],\n\t        \"end\": [\n\t            13468,\n\t            21555,\n\t            25384,\n\t            26220,\n\t            26472,\n\t            27191,\n\t            27387,\n\t            27759,\n", "            27887,\n\t            28259,\n\t            28577,\n\t        ],\n\t    }\n\t    annot_df = pd.DataFrame(annot_data)\n\t    annot_path = os.path.join(params.outdir, \"annotations.tsv\")\n\t    logger.info(str(datetime.now()) + \"\\tExporting annotations: \" + annot_path)\n\t    annot_df.to_csv(annot_path, sep=\"\\t\", index=False)\n\t    # Finish\n", "    logger.info(str(datetime.now()) + \"\\tFinished creating annotations.\")\n\t    return 0\n\tdef create_barcodes(params):\n\t    \"\"\"\n\t    Create csv of lineage barcodes from nextclade and usher.\n\t    Sources:\n\t      - github.com/corneliusroemer/pango-sequences\n\t      - github.com/andersen-lab/Freyja-data\n\t    Parameters\n\t    ----------\n", "        logger : logging.RootLogger\n\t            logging object for messages\n\t        output : str\n\t            file path for output barcodes csv.\n\t    \"\"\"\n\t    info = {}\n\t    logger = params.logger\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n\t    logger.info(str(datetime.now()) + \"\\tCreating barcodes.\")\n\t    file_name = \"barcodes.tsv\"\n", "    # -------------------------------------------------------------------------\n\t    # Nextclade barcodes\n\t    logger.info(str(datetime.now()) + \"\\tDownloading Nextclade barcodes.\")\n\t    # Summarize url file info\n\t    info = url_header_info(BARCODES_NEXTCLADE_URL)\n\t    info[\"url_nextclade\"] = info[\"url\"]\n\t    r = requests.get(BARCODES_NEXTCLADE_URL)\n\t    barcodes_data = r.json()\n\t    barcodes_dict = {\n\t        lineage: barcodes_data[lineage][\"nucSubstitutions\"] for lineage in barcodes_data\n", "    }\n\t    # Mapping of lineage to clade information\n\t    lineage_to_clade = {\n\t        lineage: barcodes_data[lineage][\"nextstrainClade\"] for lineage in barcodes_data\n\t    }\n\t    # Reverse, map to clade to a lineage MRCA, for nice notation later on\n\t    clade_to_lineage = {\n\t        clade: \"Unknown\" for clade in sorted(set(lineage_to_clade.values()))\n\t    }\n\t    # We need the tree for this lookup\n", "    tree = Phylo.read(params.tree, \"newick\")\n\t    for clade in clade_to_lineage:\n\t        lineages = [l for l, c in lineage_to_clade.items() if c == clade]\n\t        # Get MRCA node of all lineages\n\t        mrca = tree.common_ancestor(lineages).name\n\t        # Add a suffix to indicate descendants\n\t        clade_to_lineage[clade] = mrca\n\t    clade_mrcas = [clade_to_lineage[c] for c in lineage_to_clade.values()]\n\t    lineage_to_clade_df = pd.DataFrame(\n\t        {\n", "            \"lineage\": list(lineage_to_clade.keys()),\n\t            \"nextstrainClade\": list(lineage_to_clade.values()),\n\t            \"nextstrainClade_lineage\": clade_mrcas,\n\t        }\n\t    )\n\t    # -------------------------------------------------------------------------\n\t    # UShER Barcodes\n\t    logger.info(str(datetime.now()) + \"\\tDownloading UShER barcodes.\")\n\t    # Summarize url file info\n\t    info = url_header_info(BARCODES_USHER_URL)\n", "    info[\"url_usher\"] = info[\"url\"]\n\t    info[\"file\"] = file_name\n\t    r = requests.get(BARCODES_USHER_URL)\n\t    barcodes_text = r.text\n\t    barcodes_usher_df = pd.read_csv(StringIO(barcodes_text), sep=\",\")\n\t    # Rename the empty first column that should be lineage\n\t    barcodes_usher_df.rename(columns={\"Unnamed: 0\": \"lineage\"}, inplace=True)\n\t    # Convert to dataframe\n\t    logger.info(str(datetime.now()) + \"\\tConverting barcodes to dataframe.\")\n\t    lineages = list(barcodes_dict.keys())\n", "    subs = [item for sublist in barcodes_dict.values() for item in sublist]\n\t    subs = [s for s in set(subs) if s != \"\"]\n\t    subs_detections = {s: [0] * len(barcodes_dict) for s in subs}\n\t    for s in subs:\n\t        for i, lineage in enumerate(lineages):\n\t            if s in barcodes_dict[lineage]:\n\t                subs_detections[s][i] = 1\n\t    barcodes_nextclade_df = pd.DataFrame(subs_detections)\n\t    barcodes_nextclade_df.insert(loc=0, column=\"lineage\", value=lineages)\n\t    # -------------------------------------------------------------------------\n", "    # UShER Barcodes\n\t    logger.info(str(datetime.now()) + \"\\tDownloading UShER barcodes.\")\n\t    r = requests.get(BARCODES_USHER_URL)\n\t    barcodes_text = r.text\n\t    barcodes_usher_df = pd.read_csv(StringIO(barcodes_text), sep=\",\")\n\t    # Rename the empty first column that should be lineage\n\t    barcodes_usher_df.rename(columns={\"Unnamed: 0\": \"lineage\"}, inplace=True)\n\t    logger.info(str(datetime.now()) + \"\\tSupplementing missing Nextclade lineages.\")\n\t    nextclade_lineages = list(barcodes_nextclade_df[\"lineage\"])\n\t    usher_lineages = list(barcodes_usher_df[\"lineage\"])\n", "    usher_uniq = [l for l in usher_lineages if l not in nextclade_lineages]\n\t    for lineage in usher_uniq:\n\t        logger.info(str(datetime.now()) + \"\\t\\tAdding UShER lineage \" + lineage + \".\")\n\t        lineage_row = pd.DataFrame({s: [0] for s in barcodes_nextclade_df.columns})\n\t        lineage_row[\"lineage\"] = lineage\n\t        barcodes_nextclade_df = pd.concat(\n\t            [barcodes_nextclade_df, lineage_row], ignore_index=True\n\t        )\n\t        lineage_i = len(barcodes_nextclade_df) - 1\n\t        df = barcodes_usher_df[barcodes_usher_df[\"lineage\"] == lineage]\n", "        detections = list(df.columns[df.apply(lambda col: col.sum() == 1)])\n\t        for sub in detections:\n\t            if sub not in barcodes_nextclade_df:\n\t                barcodes_nextclade_df[sub] = 0\n\t            barcodes_nextclade_df.at[lineage_i, sub] = 1\n\t    logger.info(str(datetime.now()) + \"\\tApplying edge-case curation.\")\n\t    for lineage in BARCODE_MANUAL_EDITS:\n\t        lineage_i = barcodes_nextclade_df[\n\t            barcodes_nextclade_df[\"lineage\"] == lineage\n\t        ].index.values[0]\n", "        for sub, value in BARCODE_MANUAL_EDITS[lineage].items():\n\t            logger.info(\n\t                str(datetime.now())\n\t                + \"\\t\\tAdding \"\n\t                + lineage\n\t                + \" barcode \"\n\t                + sub\n\t                + \"=\"\n\t                + str(value)\n\t            )\n", "            if sub not in barcodes_nextclade_df.columns:\n\t                barcodes_nextclade_df[sub] = 0\n\t            barcodes_nextclade_df.at[lineage_i, sub] = 1\n\t    # Sort columns by genomic position\n\t    subs_order = sorted([Substitution(s) for s in barcodes_nextclade_df.columns[1:]])\n\t    subs_order_str = [str(s) for s in subs_order]\n\t    cols_order = [\"lineage\"] + subs_order_str\n\t    barcodes_df = barcodes_nextclade_df[cols_order]\n\t    logger.info(\n\t        str(datetime.now())\n", "        + \"\\tRemoving problematic lineages: \"\n\t        + \",\".join(PROBLEMATIC_LINEAGES)\n\t    )\n\t    barcodes_df = barcodes_df[~barcodes_df[\"lineage\"].isin(PROBLEMATIC_LINEAGES)]\n\t    # Export\n\t    barcodes_path = os.path.join(params.outdir, file_name)\n\t    logger.info(str(datetime.now()) + \"\\tExporting barcodes: \" + barcodes_path)\n\t    barcodes_df.to_csv(barcodes_path, sep=\"\\t\", index=False)\n\t    clade_path = os.path.join(params.outdir, \"lineage_to_clade.tsv\")\n\t    logger.info(\n", "        str(datetime.now()) + \"\\tExporting lineage to clade mapping: \" + clade_path\n\t    )\n\t    lineage_to_clade_df.to_csv(clade_path, sep=\"\\t\", index=False)\n\t    # Finish\n\t    logger.info(str(datetime.now()) + \"\\tFinished creating barcodes.\")\n\t    return info\n\tdef create_barcodes_diagnostic(params):\n\t    \"\"\"\n\t    Create tsv of lineage-diagnostic barcodes.\n\t    \"\"\"\n", "    logger = params.logger\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n\t    logger.info(str(datetime.now()) + \"\\tCreating diagnostic barcodes.\")\n\t    # Import barcodes\n\t    barcodes = pd.read_csv(params.barcodes, sep=\"\\t\")\n\t    # import tree\n\t    tree = Phylo.read(params.tree, \"newick\")\n\t    diagnostic = {\n\t        \"mutation\": [],\n\t        \"coord\": [],\n", "        \"lineage\": [],\n\t        \"include_descendants\": [],\n\t    }\n\t    # Exclude the first column, which is lineage\n\t    mutations = barcodes.columns[2:]\n\t    for mutation in mutations:\n\t        sub = Substitution(mutation)\n\t        coord = sub.coord\n\t        include_descendants = False\n\t        # Identify the lineages that have this mutation\n", "        present_df = barcodes[barcodes[mutation] == 1]\n\t        # Case 1: No lineages have this mutation\n\t        if len(present_df) == 0:\n\t            continue\n\t        # Case 2: A single lineage has this mutation\n\t        elif len(present_df) == 1:\n\t            lineage = list(present_df[\"lineage\"])[0]\n\t        # Case 3: Multiple lineages have this mutation, check if monophyletic\n\t        else:\n\t            lineages = list(present_df[\"lineage\"])\n", "            # Use the first lineage as parent (barcodes df is ordered)\n\t            parent = lineages[0]\n\t            parent_tree = [c for c in tree.find_clades(parent)]\n\t            # skip if we couldn't find the lineage\n\t            if len(parent_tree) != 1:\n\t                continue\n\t            parent_tree = parent_tree[0]\n\t            children = [c.name for c in parent_tree.find_clades()]\n\t            # Check if monophyletic (found only in descendants)\n\t            monophyletic = True\n", "            for lineage in lineages:\n\t                if lineage not in children:\n\t                    monophyletic = False\n\t                    break\n\t            # If it wasn't monophyletic, continue\n\t            if not monophyletic:\n\t                continue\n\t            include_descendants = True\n\t            lineage = parent\n\t        diagnostic[\"mutation\"].append(mutation)\n", "        diagnostic[\"coord\"].append(coord)\n\t        diagnostic[\"lineage\"].append(lineage)\n\t        diagnostic[\"include_descendants\"].append(include_descendants)\n\t    # Convert dict to dataframe\n\t    diagnostic_df = pd.DataFrame(diagnostic)\n\t    # Sort by coordinate\n\t    diagnostic_df.sort_values(by=\"coord\", inplace=True)\n\t    # Export\n\t    diagnostic_path = os.path.join(params.outdir, \"diagnostic.tsv\")\n\t    logger.info(\n", "        str(datetime.now()) + \"\\tExporting diagnostic barcodes: \" + diagnostic_path\n\t    )\n\t    diagnostic_df.to_csv(diagnostic_path, sep=\"\\t\", index=False)\n\t    return 0\n\tdef create_tree(params):\n\t    \"\"\"\n\t    Create nomenclature tree of designated pango lineages.\n\t    Parameters\n\t    ----------\n\t        logger : logging.RootLogger\n", "            logging object for messages\n\t        output : str\n\t            file path for output newick tree.\n\t    \"\"\"\n\t    info = {}\n\t    logger = params.logger\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n\t    logger.info(str(datetime.now()) + \"\\tCreating tree.\")\n\t    file_name = \"tree.nwk\"\n\t    # -------------------------------------------------------------------------\n", "    # Download latest designated lineages from pango-designation\n\t    logger.info(str(datetime.now()) + \"\\tDownloading designated lineage summaries.\")\n\t    # Summarize url file info\n\t    info = url_header_info(LINEAGE_SUMMARY_URL)\n\t    info[\"file\"] = file_name\n\t    r = requests.get(LINEAGE_SUMMARY_URL)\n\t    lineage_text = r.text\n\t    # Attempt semi-structure text parsing for parents\n\t    # This is most useful for identifying recursive recombinants\n\t    recombinant_parents = {}\n", "    # Convert the text table to list\n\t    lineages = []\n\t    # This could be parallelized, but it's already extremely fast\n\t    for line in lineage_text.split(\"\\n\"):\n\t        if \"Withdrawn\" in line or line.startswith(\"Lineage\"):\n\t            continue\n\t        lineage = line.split(\"\\t\")[0]\n\t        if lineage == \"\":\n\t            continue\n\t        lineages.append(lineage)\n", "    logger.info(str(datetime.now()) + \"\\tDownloading alias key.\")\n\t    r = requests.get(ALIAS_KEY_URL)\n\t    alias_key = r.json()\n\t    recombinant_parents = {}\n\t    for lineage, parents in alias_key.items():\n\t        if len(parents) < 2:\n\t            continue\n\t        recombinant_parents[lineage] = parents\n\t    # Initialize the aliasor, which will download the latest aliases\n\t    logger.info(str(datetime.now()) + \"\\tInitialising aliases.\")\n", "    aliasor = Aliasor()\n\t    # -------------------------------------------------------------------------\n\t    # Construct Tree\n\t    logger.info(str(datetime.now()) + \"\\tConstructing lineage tree.\")\n\t    # Create a tree with a root node \"MRCA\"\n\t    tree = Clade(name=\"MRCA\", clades=[], branch_length=1)\n\t    # Add an \"X\" parent for recombinants\n\t    clade = Clade(name=\"X\", clades=[], branch_length=1)\n\t    tree.clades.append(clade)\n\t    # This can't be parallelized, sequential processing is required\n", "    for lineage in lineages:\n\t        # Identify the parent\n\t        lineage_uncompress = aliasor.uncompress(lineage)\n\t        parent_uncompress = \".\".join(lineage_uncompress.split(\".\")[0:-1])\n\t        parent = aliasor.compress(parent_uncompress)\n\t        # Manual parents setting for A and B\n\t        if lineage == \"A\":\n\t            parent = \"MRCA\"\n\t        elif lineage == \"B\":\n\t            parent = \"A\"\n", "        # Special handling for recombinants\n\t        elif lineage.startswith(\"X\") and parent == \"\":\n\t            parent = \"X\"\n\t        # Check for recursive recombinant\n\t        if lineage in recombinant_parents:\n\t            recursive_parents = [\n\t                p for p in recombinant_parents[lineage] if p.startswith(\"X\")\n\t            ]\n\t            if len(recursive_parents) > 0:\n\t                parent = recursive_parents[0]\n", "        parent_clade = [c for c in tree.find_clades(parent)]\n\t        # If we found a parent, as long as the input list is formatted correctly\n\t        # this should always be true\n\t        if len(parent_clade) == 1:\n\t            parent_clade = parent_clade[0]\n\t            clade = Clade(name=lineage, clades=[], branch_length=1)\n\t            parent_clade.clades.append(clade)\n\t    # -------------------------------------------------------------------------\n\t    # Export\n\t    tree_path = os.path.join(params.outdir, file_name)\n", "    logger.info(str(datetime.now()) + \"\\tExporting newick tree: \" + tree_path)\n\t    Phylo.write(tree, tree_path, \"newick\")\n\t    # Finish\n\t    logger.info(str(datetime.now()) + \"\\tFinished creating tree.\")\n\t    return info\n\tdef parse_alignment(params):\n\t    \"\"\"\n\t    Parse alignment for substitutions, deletions, and missing data.\n\t    Parameters\n\t    ----------\n", "        reference : str\n\t            file path to reference genome.\n\t        alignment : str\n\t            file_path to alignment.\n\t        mask : int\n\t            number of bases to mask at 5' and 3' end.\n\t        logger : logging.RootLogger\n\t            logging object for messages\n\t        threads : int\n\t            number of CPUs to use.\n", "        outdir : str\n\t            directory path for output files.\n\t    \"\"\"\n\t    logger = params.logger\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n\t    logger.info(str(datetime.now()) + \"\\tParsing substitutions from alignment.\")\n\t    # Import reference\n\t    logger.info(str(datetime.now()) + \"\\tImporting reference: \" + params.reference)\n\t    records = SeqIO.parse(params.reference, \"fasta\")\n\t    ref_rec = next(records)\n", "    # Import alignment\n\t    logger.info(str(datetime.now()) + \"\\tImporting alignment: \" + params.alignment)\n\t    num_records = len(list(SeqIO.parse(params.alignment, \"fasta\")))\n\t    records = SeqIO.parse(params.alignment, \"fasta\")\n\t    # Parse substitutions\n\t    # Process genomes in parallel, `genome_mp` is a multiprocessing wrapper\n\t    # function for the `Genome` class.\n\t    pool = Pool(params.threads)\n\t    iterator = records\n\t    task = functools.partial(\n", "        genome_mp,\n\t        reference=ref_rec,\n\t        mask=params.mask,\n\t        debug=params.debug,\n\t        logger=params.logger,\n\t    )\n\t    total = num_records\n\t    task_progress = tqdm(pool.imap(task, iterator), total=total)\n\t    task_description = (\n\t        str(datetime.now()) + \"      Parsing substitutions from alignment\"\n", "    )\n\t    task_progress.set_description(task_description, refresh=True)\n\t    genomes = list(task_progress)\n\t    # Pool memory management, don't accept anymore new tasks and wait\n\t    pool.close()\n\t    pool.join()\n\t    # Benchmark summary\n\t    task_elapsed = task_progress.format_dict[\"elapsed\"]\n\t    task_iter = task_progress.format_dict[\"total\"]\n\t    sec_per_iter = round(task_elapsed / task_iter, 5)\n", "    iter_per_sec = round(task_iter / task_elapsed, 5)\n\t    logger.info(\n\t        str(datetime.now())\n\t        + \"\\tParsing substitutions benchmark: \"\n\t        + str(sec_per_iter)\n\t        + \" s/seq, \"\n\t        + str(iter_per_sec)\n\t        + \" seq/s\"\n\t    )\n\t    # Export\n", "    subs_path = os.path.join(params.outdir, \"subs.tsv\")\n\t    logger.info(str(datetime.now()) + \"\\tExporting results to: \" + subs_path)\n\t    dfs = [genome.to_dataframe() for genome in genomes]\n\t    df = pd.concat(dfs)\n\t    df.to_csv(subs_path, sep=\"\\t\", index=False)\n\t    # Finish\n\t    logger.info(str(datetime.now()) + \"\\tFinished parsing substitutions.\")\n\t    return 0\n\tdef detect_recombination(params):\n\t    \"\"\"\n", "    Detect recombination using lineage barcodes.\n\t    Parameters\n\t    ----------\n\t        tree : str\n\t            file path of input tree newick.\n\t        barcodes : str\n\t            file path of input barcodes csv.\n\t        subs : str\n\t            file path of input subs tsv.\n\t        lineage_to_clade : str\n", "            file path of mapping lineages to clades.\n\t        logger : logging.RootLogger\n\t            logging object for messages.\n\t        threads : int\n\t            number of CPUs to use.\n\t        outdir : str\n\t            directory path for output files.\n\t    \"\"\"\n\t    logger = params.logger\n\t    logger.info(str(datetime.now()) + \"\\t\" + \"-\" * 40)\n", "    logger.info(str(datetime.now()) + \"\\tDetecting recombination.\")\n\t    # Import the dataframe from the `subs` module, or alternatively from nextclade\n\t    logger.info(str(datetime.now()) + \"\\tImporting substitutions: \" + params.subs)\n\t    subs_df = pd.read_csv(params.subs, sep=\"\\t\").fillna(NO_DATA_CHAR)\n\t    subs_df.set_index(\"strain\", inplace=True)\n\t    subs_df[\"strain\"] = subs_df.index\n\t    # Import dataset info\n\t    dataset_info_path = os.path.join(params.dataset, \"dataset.yaml\")\n\t    logger.info(str(datetime.now()) + \"\\tImporting dataset info: \" + dataset_info_path)\n\t    with open(dataset_info_path, \"r\") as infile:\n", "        dataset_info = yaml.safe_load(infile)\n\t    # Import lineage barcodes\n\t    logger.info(str(datetime.now()) + \"\\tImporting barcodes: \" + params.barcodes)\n\t    barcodes_df = pd.read_csv(params.barcodes, sep=\"\\t\")\n\t    # Import diagnostic barcodes\n\t    diagnostic_path = os.path.join(params.dataset, \"diagnostic.tsv\")\n\t    logger.info(\n\t        str(datetime.now()) + \"\\tImporting diagnostic barcodes: \" + diagnostic_path\n\t    )\n\t    diagnostic_df = pd.read_csv(diagnostic_path, sep=\"\\t\")\n", "    # Import tree\n\t    logger.info(str(datetime.now()) + \"\\tImporting tree: \" + params.tree)\n\t    tree = Phylo.read(params.tree, \"newick\")\n\t    # Import mapping of lineages to clades\n\t    logger.info(\n\t        str(datetime.now())\n\t        + \"\\tImporting lineage to clade mapping: \"\n\t        + params.lineage_to_clade\n\t    )\n\t    lineage_to_clade = pd.read_csv(params.lineage_to_clade, sep=\"\\t\")\n", "    # Identify which lineages are known recombinants\n\t    # ie. descended from the \"X\" recombinant MRCA node\n\t    recombinant_tree = [c for c in tree.find_clades(\"X\")][0]\n\t    recombinant_lineages = [c.name for c in recombinant_tree.find_clades()]\n\t    # Detect recombination in samples.\n\t    # Process genomes in parallel, `genome_mp` is a multiprocessing wrapper\n\t    # function for the `Genome` class.\n\t    pool = Pool(params.threads)\n\t    iterator = subs_df.iterrows()\n\t    total = len(subs_df)\n", "    # Debugging\n\t    # iterator = [rec for rec in subs_df.iterrows() if rec[1][\"strain\"].startswith(\"X\")]\n\t    # total = len(iterator)\n\t    task = functools.partial(\n\t        genome_mp,\n\t        debug=params.debug,\n\t        logger=params.logger,\n\t        dataset_info=dataset_info,\n\t        barcodes=barcodes_df,\n\t        diagnostic=diagnostic_df,\n", "        tree=tree,\n\t        recombinant_tree=recombinant_tree,\n\t        recombinant_lineages=recombinant_lineages,\n\t        lineage_to_clade=lineage_to_clade,\n\t        max_depth=params.max_depth,\n\t        max_breakpoints=params.max_breakpoints,\n\t        min_subs=params.min_subs,\n\t        min_consecutive=params.min_consecutive,\n\t        min_length=params.min_length,\n\t        edge_cases=params.edge_cases,\n", "        validate=params.validate,\n\t    )\n\t    task_progress = tqdm(pool.imap(task, iterator), total=total)\n\t    task_description = str(datetime.now()) + \"      Detecting recombination\"\n\t    task_progress.set_description(task_description, refresh=True)\n\t    genomes = list(task_progress)\n\t    # Pool memory management, don't accept new tasks and wait\n\t    pool.close()\n\t    pool.join()\n\t    # Benchmark summary\n", "    task_elapsed = task_progress.format_dict[\"elapsed\"]\n\t    task_iter = task_progress.format_dict[\"total\"]\n\t    sec_per_iter = round(task_elapsed / task_iter, 5)\n\t    iter_per_sec = round(task_iter / task_elapsed, 5)\n\t    logger.info(\n\t        str(datetime.now())\n\t        + \"\\tDetecting recombination benchmark: \"\n\t        + str(sec_per_iter)\n\t        + \" s/seq, \"\n\t        + str(iter_per_sec)\n", "        + \" seq/s\"\n\t    )\n\t    # -------------------------------------------------------------------------\n\t    # Pass 3: Export\n\t    logger.info(str(datetime.now()) + \"\\tPreparing to export.\")\n\t    # If requested, exclude non-recombinants from output\n\t    if params.exclude_non_recomb:\n\t        genomes = [g for g in genomes if len(g.recombination.breakpoints) > 0]\n\t    export = Export(genomes=genomes, dataset=params.dataset, outdir=params.outdir)\n\t    # YAML\n", "    if params.output_all or params.output_yaml:\n\t        outpath = os.path.join(params.outdir, \"summary.yaml\")\n\t        logger.info(str(datetime.now()) + \"\\tExporting YAML: \" + outpath)\n\t        export.to_yaml()\n\t    if params.output_all or params.output_tsv:\n\t        outpath = os.path.join(params.outdir, \"summary.tsv\")\n\t        logger.info(str(datetime.now()) + \"\\tExporting TSV: \" + outpath)\n\t        export.to_dataframe()\n\t    if params.output_all or params.output_barcode:\n\t        outpath = os.path.join(\n", "            params.outdir, \"barcodes/<recombinant>_<parent_1>_<parent_2>.tsv\"\n\t        )\n\t        logger.info(str(datetime.now()) + \"\\tExporting barcode mutations: \" + outpath)\n\t        export.to_barcodes()\n\t    # Plot\n\t    if params.output_all or params.output_plot:\n\t        outpath = os.path.join(\n\t            params.outdir,\n\t            \"plots/<recombinant>_<parent_1>_<parent_2>.\" + params.plot_ext,\n\t        )\n", "        logger.info(str(datetime.now()) + \"\\tExporting plots: \" + outpath)\n\t        export.to_plot(ext=params.plot_ext)\n\t    # Finish\n\t    logger.info(str(datetime.now()) + \"\\tFinished detecting recombination.\")\n\t    return 0\n"]}
{"filename": "rebar/constants.py", "chunked_list": ["# -----------------------------------------------------------------------------\n\t# Constants\n\t# -----------------------------------------------------------------------------\n\tNO_DATA_CHAR = \"NA\"\n\tLINEAGE_SUMMARY_URL = (\n\t    \"https://raw.githubusercontent.com/cov-lineages/pango-designation/master/\"\n\t    \"lineage_notes.txt\"\n\t)\n\tALIAS_KEY_URL = (\n\t    \"https://raw.githubusercontent.com/cov-lineages/pango-designation/master/\"\n", "    \"pango_designation/alias_key.json\"\n\t)\n\tBARCODES_USHER_URL = (\n\t    \"https://github.com/andersen-lab/Freyja-data/raw/main/usher_barcodes.csv\"\n\t)\n\tBARCODES_NEXTCLADE_URL = (\n\t    \"https://raw.githubusercontent.com/corneliusroemer/pango-sequences/\"\n\t    \"main/data/pango-consensus-sequences_summary.json\"\n\t)\n\tPANGO_SEQUENCES_URL = (\n", "    \"https://raw.githubusercontent.com/corneliusroemer/pango-sequences/\"\n\t    \"main/data/pango-consensus-sequences_genome-nuc.fasta.zst\"\n\t)\n\t# Lineages that produce undesireable results across all recombinants.\n\t# PROBLEMATIC_LINEAGES = [\"BA.2.85\"]\n\tPROBLEMATIC_LINEAGES = []\n\tBARCODE_MANUAL_EDITS = {\n\t    # This substitution is found in the UShER tree, but missing from Nextclade\n\t    \"XAE\": {\"A26530G\": 1}\n\t}\n", "MASK = 200\n\tMAX_DEPTH = 3\n\tMIN_LENGTH = 500\n\tMIN_SUBS = 1\n\tMIN_CONSECUTIVE = 3\n\tMAX_BREAKPOINTS = 10\n\tPLOT_EXT = \"png\"\n\t# These are known edge case recombinants, which generally required\n\t# more relaxed parameters.\n\tEDGE_CASE_RECOMBINANTS = [\n", "    \"XB\",\n\t    \"XP\",\n\t    \"XR\",\n\t    \"XAD\",\n\t    \"XAE\",\n\t    \"XAJ\",\n\t    \"XAS\",\n\t    \"XAV\",\n\t    \"XAY\",\n\t    \"XAZ\",\n", "    \"XBC\",\n\t    \"XBK\",\n\t    \"XBQ\",\n\t    \"XBZ\",\n\t]\n"]}
{"filename": "rebar/export.py", "chunked_list": ["import os\n\timport pandas as pd\n\tfrom .plot import plot\n\tclass Export:\n\t    def __init__(\n\t        self,\n\t        genomes,\n\t        dataset,\n\t        outdir,\n\t    ):\n", "        self.genomes = genomes\n\t        self.dataset = dataset\n\t        self.outdir = outdir\n\t        self.recombinants = self.collect_recombinants()\n\t        self.dataframe = None\n\t        self.barcodes = {}\n\t        self.alignments = {}\n\t        self.annotations = self.load_annotations(dataset)\n\t    def load_annotations(self, dataset):\n\t        \"\"\"\n", "        Load annotations dataframe from dataset path.\n\t        \"\"\"\n\t        annot_path = os.path.join(self.dataset, \"annotations.tsv\")\n\t        annot_df = pd.read_csv(annot_path, sep=\"\\t\")\n\t        return annot_df\n\t    def collect_recombinants(self):\n\t        \"\"\"\n\t        Collate genomes by recombinant and parents.\n\t        \"\"\"\n\t        recombinants = list(\n", "            set([g.lineage.recombinant for g in self.genomes if g.lineage.recombinant])\n\t        )\n\t        result = {r: {} for r in recombinants}\n\t        for recombinant in recombinants:\n\t            for genome in self.genomes:\n\t                if genome.lineage.recombinant != recombinant:\n\t                    continue\n\t                parents = [\n\t                    genome.recombination.parent_1.name,\n\t                    genome.recombination.parent_2.name,\n", "                ]\n\t                parent_2 = parents[1]\n\t                # No parent 2, no recombation\n\t                if not parent_2:\n\t                    continue\n\t                parents = \"{}_{}\".format(parents[0], parents[1])\n\t                if parents not in result[recombinant]:\n\t                    result[recombinant][parents] = {}\n\t                breakpoints_str = \"_\".join(genome.recombination.breakpoints)\n\t                if breakpoints_str not in result[recombinant][parents]:\n", "                    result[recombinant][parents][breakpoints_str] = []\n\t                result[recombinant][parents][breakpoints_str].append(genome)\n\t        return result\n\t    def to_yaml(self):\n\t        yaml_data = \"\\n\".join([genome.to_yaml() for genome in self.genomes])\n\t        file_path = os.path.join(self.outdir, \"summary.yaml\")\n\t        with open(file_path, \"w\") as outfile:\n\t            outfile.write(yaml_data + \"\\n\")\n\t    def to_dataframe(self):\n\t        dataframe = pd.DataFrame()\n", "        for genome in self.genomes:\n\t            genome_dataframe = genome.to_dataframe(df_type=\"full\")\n\t            if len(dataframe) == 0:\n\t                dataframe = genome_dataframe\n\t            else:\n\t                dataframe = pd.concat([dataframe, genome_dataframe], ignore_index=True)\n\t        file_path = os.path.join(self.outdir, \"summary.tsv\")\n\t        dataframe.to_csv(file_path, sep=\"\\t\", index=False)\n\t        self.dataframe = dataframe\n\t        return dataframe\n", "    def to_barcodes(self):\n\t        # Create output dir\n\t        outdir_barcodes = os.path.join(self.outdir, \"barcodes\")\n\t        if not os.path.exists(outdir_barcodes):\n\t            os.makedirs(outdir_barcodes)\n\t        # Process recombinant groups\n\t        for recombinant in self.recombinants:\n\t            self.barcodes[recombinant] = {}\n\t            # Process parent groups within recombinant\n\t            for parents in self.recombinants[recombinant]:\n", "                self.barcodes[recombinant][parents] = {}\n\t                parents_data = self.recombinants[recombinant][parents]\n\t                parent_1 = parents.split(\"_\")[0]\n\t                parent_2 = parents.split(\"_\")[1]\n\t                # No parent 2 means no recombination\n\t                if not parent_2:\n\t                    continue\n\t                # Process breakpoint groups within parents\n\t                for breakpoints in parents_data:\n\t                    # First pass, identify all ref and parent subs\n", "                    parent_dict = {\n\t                        \"coord\": [],\n\t                        \"Reference\": [],\n\t                        parent_1: [],\n\t                        parent_2: [],\n\t                    }\n\t                    breakpoints_data = parents_data[breakpoints]\n\t                    for genome in breakpoints_data:\n\t                        df = genome.recombination.dataframe\n\t                        # If we know this is a recombinant, but couldn't detect\n", "                        # breakpoints, skip over\n\t                        if type(df) != pd.core.frame.DataFrame:\n\t                            continue\n\t                        for rec in df.iterrows():\n\t                            coord = rec[1][\"coord\"]\n\t                            ref = rec[1][\"Reference\"]\n\t                            p1 = rec[1][parent_1]\n\t                            p2 = rec[1][parent_2]\n\t                            if coord not in parent_dict[\"coord\"]:\n\t                                parent_dict[\"coord\"].append(coord)\n", "                                parent_dict[\"Reference\"].append(ref)\n\t                                parent_dict[parent_1].append(p1)\n\t                                parent_dict[parent_2].append(p2)\n\t                    parent_df = pd.DataFrame(parent_dict).sort_values(by=[\"coord\"])\n\t                    # Second pass, add sample subs\n\t                    for genome in breakpoints_data:\n\t                        df = genome.recombination.dataframe\n\t                        bases = []\n\t                        for rec in parent_df.iterrows():\n\t                            coord = rec[1][\"coord\"]\n", "                            ref = rec[1][\"Reference\"]\n\t                            # If this coord is missing, set to ref\n\t                            base = ref\n\t                            coord_row = df[df[\"coord\"] == coord]\n\t                            if len(coord_row) == 0:\n\t                                base = ref\n\t                            else:\n\t                                base = coord_row[genome.id].values[0]\n\t                            bases.append(base)\n\t                        parent_df[genome.id] = bases\n", "                    self.barcodes[recombinant][parents][breakpoints] = parent_df\n\t                    file_path = os.path.join(\n\t                        outdir_barcodes,\n\t                        \"{}_{}_{}.tsv\".format(recombinant, parents, breakpoints),\n\t                    )\n\t                    parent_df.to_csv(file_path, sep=\"\\t\", index=False)\n\t        return self.barcodes\n\t    def to_plot(self, ext):\n\t        # Create output dir\n\t        outdir_plot = os.path.join(self.outdir, \"plots\")\n", "        if not os.path.exists(outdir_plot):\n\t            os.makedirs(outdir_plot)\n\t        # Create summary dataframe first\n\t        if type(self.dataframe) != pd.core.series.Series:\n\t            self.to_dataframe()\n\t        # Create individual barcodes\n\t        if len(self.barcodes) == 0:\n\t            self.to_barcodes()\n\t        # Process recombinant groups\n\t        for recombinant in self.recombinants:\n", "            # print(recombinant)\n\t            self.alignments[recombinant] = {}\n\t            # Process parent groups within recombinant\n\t            for parents in self.recombinants[recombinant]:\n\t                # print(\"\\t\", parents)\n\t                parents_data = self.recombinants[recombinant][parents]\n\t                # In the summary table, parents are seperated by comma\n\t                parents_csv = parents.replace(\"_\", \",\")\n\t                for breakpoints in parents_data:\n\t                    # Get barcodes and summary for this recombinant\n", "                    barcodes_df = self.barcodes[recombinant][parents][breakpoints]\n\t                    # If we know this is a recombinant, but couldn't detect\n\t                    # breakpoints, skip over\n\t                    if type(barcodes_df) != pd.core.frame.DataFrame:\n\t                        continue\n\t                    summary_df = self.dataframe[\n\t                        (self.dataframe[\"recombinant\"] == recombinant)\n\t                        & (self.dataframe[\"parents_lineage\"] == parents_csv)\n\t                        * (\n\t                            self.dataframe[\"breakpoints\"]\n", "                            == breakpoints.replace(\"_\", \",\")\n\t                        )\n\t                    ]\n\t                    output_path = os.path.join(\n\t                        self.outdir,\n\t                        \"plots\",\n\t                        \"{}_{}_{}.{}\".format(recombinant, parents, breakpoints, ext),\n\t                    )\n\t                    plot(\n\t                        barcodes_df=barcodes_df,\n", "                        summary_df=summary_df,\n\t                        annot_df=self.annotations,\n\t                        output=output_path,\n\t                    )\n\t        return 0\n"]}
{"filename": "rebar/argument_parser.py", "chunked_list": ["#!/usr/bin/env python3\n\timport argparse\n\tfrom .wrappers import dataset, run\n\tfrom . import version\n\tfrom .constants import (\n\t    MASK,\n\t    MAX_DEPTH,\n\t    MIN_LENGTH,\n\t    MIN_SUBS,\n\t    MIN_CONSECUTIVE,\n", "    MAX_BREAKPOINTS,\n\t    PLOT_EXT,\n\t)\n\tdef add_alignment_param(parser, required=False):\n\t    text = \"Path to alignment fasta.\"\n\t    parser.add_argument(\"--alignment\", required=required, type=str, help=text)\n\tdef add_barcodes_param(parser, required=False):\n\t    text = \"Input barcodes csv, from `barcodes` subcommand.\"\n\t    parser.add_argument(\"--barcodes\", required=required, type=str, help=text)\n\tdef add_dataset_param(parser, required=False):\n", "    text = \"Path to dataset directory, output of `dataset` subcommand .\"\n\t    parser.add_argument(\"--dataset\", required=required, type=str, help=text)\n\tdef add_dataset_name_param(parser, required=False):\n\t    text = \"Dataset name (Default: sars-cov-2).\"\n\t    parser.add_argument(\n\t        \"--name\", required=required, type=str, choices=[\"sars-cov-2\"], help=text\n\t    )\n\tdef add_dataset_tag_param(parser, required=False):\n\t    text = \"Dataset tag (Default: latest).\"\n\t    parser.add_argument(\n", "        \"--tag\", required=required, type=str, choices=[\"latest\"], help=text\n\t    )\n\tdef add_debug_param(parser, required=False):\n\t    text = \"Enable debugging mode.\"\n\t    parser.add_argument(\"--debug\", required=required, action=\"store_true\", help=text)\n\tdef add_no_edge_cases_param(parser, required=False):\n\t    text = \"Disable sensitive edge case handling for recombinants with few mutations.\"\n\t    parser.add_argument(\n\t        \"--no-edge-cases\", required=required, action=\"store_true\", help=text\n\t    )\n", "def add_exclude_non_recomb_param(parser, required=False):\n\t    text = \"Exclude non-recombinant samples from output files\"\n\t    parser.add_argument(\n\t        \"--exclude-non-recomb\", required=required, action=\"store_true\", help=text\n\t    )\n\tdef add_log_param(parser, required=False):\n\t    text = \"Log file path.\"\n\t    parser.add_argument(\"--log\", required=required, type=str, help=text)\n\tdef add_lineages_param(parser, required=False):\n\t    text = \"Comma-separated list of lineages to test (ex. 'XBF,XBB.1.5').\"\n", "    parser.add_argument(\"--lineages\", required=required, type=str, help=text)\n\tdef add_mask_param(parser, required=False):\n\t    text = \"Number of bases to mask at 5' and 3' end of genome (Default: {}).\".format(\n\t        MASK\n\t    )\n\t    parser.add_argument(\"--mask\", required=required, default=MASK, type=int, help=text)\n\tdef add_max_depth_param(parser, required=False):\n\t    text = \"Maximum search depth to look for parents (Default: {}).\".format(MAX_DEPTH)\n\t    parser.add_argument(\n\t        \"--max-depth\", required=required, default=MAX_DEPTH, type=int, help=text\n", "    )\n\tdef add_max_breakpoints_param(parser, required=False):\n\t    text = \"Maximum number of allowed breakpoints (Default: {}).\".format(\n\t        MAX_BREAKPOINTS\n\t    )\n\t    parser.add_argument(\n\t        \"--max-breakpoints\",\n\t        required=required,\n\t        default=MAX_BREAKPOINTS,\n\t        type=int,\n", "        help=text,\n\t    )\n\tdef add_min_consecutive_param(parser, required=False):\n\t    text = \"Minimum number of consecutive barcode positions from each parent (Default: {}).\".format(\n\t        MIN_CONSECUTIVE\n\t    )\n\t    parser.add_argument(\n\t        \"--min-consecutive\",\n\t        required=required,\n\t        default=MIN_CONSECUTIVE,\n", "        type=int,\n\t        help=text,\n\t    )\n\tdef add_min_length_param(parser, required=False):\n\t    text = \"Minimum length of regions contributed by each parent (Default: {}).\".format(\n\t        MIN_LENGTH\n\t    )\n\t    parser.add_argument(\n\t        \"--min-length\", required=required, default=MIN_LENGTH, type=int, help=text\n\t    )\n", "def add_min_subs_param(parser, required=False):\n\t    text = \"Minimum number of lineage-determining substitutions from each parent (Default: {}).\".format(\n\t        MIN_SUBS\n\t    )\n\t    parser.add_argument(\n\t        \"--min-subs\", required=required, default=MIN_SUBS, type=int, help=text\n\t    )\n\tdef add_outdir_param(parser, required=False, default=\"output\"):\n\t    text = \"Output directory for results (Default: {}).\".format(default)\n\t    parser.add_argument(\n", "        \"--outdir\", required=required, default=default, type=str, help=text\n\t    )\n\tdef add_output_all_param(parser, required=False):\n\t    text = \"Produce all possible output files.\"\n\t    parser.add_argument(\n\t        \"--output-all\", required=required, action=\"store_true\", help=text\n\t    )\n\tdef add_output_plot_param(parser, required=False):\n\t    text = \"Output snipit plots.\"\n\t    parser.add_argument(\n", "        \"--output-plot\", required=required, action=\"store_true\", help=text\n\t    )\n\tdef add_output_barcode_param(parser, required=False):\n\t    text = \"Output barcode mutations as table.\"\n\t    parser.add_argument(\n\t        \"--output-barcode\", required=required, action=\"store_true\", help=text\n\t    )\n\tdef add_output_tsv_param(parser, required=False):\n\t    text = \"Output TSV summary.\"\n\t    parser.add_argument(\n", "        \"--output-tsv\", required=required, action=\"store_true\", help=text\n\t    )\n\tdef add_output_yaml_param(parser, required=False):\n\t    text = \"Output YAML summary.\"\n\t    parser.add_argument(\n\t        \"--output-yaml\", required=required, action=\"store_true\", help=text\n\t    )\n\tdef add_reference_param(parser, required=False):\n\t    text = \"Path to reference fasta.\"\n\t    parser.add_argument(\"--reference\", required=required, type=str, help=text)\n", "def add_shared_param(parser, required=False):\n\t    text = \"Include mutations shared by all parents when exporting.\"\n\t    parser.add_argument(\"--shared\", required=required, action=\"store_true\", help=text)\n\tdef add_plot_ext_param(parser, required=False):\n\t    text = \"plot format extension for figures\"\n\t    parser.add_argument(\n\t        \"--plot-ext\",\n\t        required=required,\n\t        default=PLOT_EXT,\n\t        choices=[\"pdf\", \"png\", \"svg\"],\n", "        type=str,\n\t        help=text,\n\t    )\n\tdef add_subs_param(parser, required=False):\n\t    text = \"Input subs tsv, from `subs` subcommand.\"\n\t    parser.add_argument(\"--subs\", required=required, type=str, help=text)\n\tdef add_threads_param(parser, required=False):\n\t    text = \"Number of threads to use (Default: 1).\"\n\t    parser.add_argument(\"--threads\", required=required, type=int, default=1, help=text)\n\tdef add_tree_param(parser, required=False):\n", "    text = \"Input newick tree, from `tree` subcommand.\"\n\t    parser.add_argument(\"--tree\", required=required, type=str, help=text)\n\tdef add_validate_param(parser, required=False):\n\t    text = \"Validate lineages against expected values.\"\n\t    parser.add_argument(\"--validate\", required=required, action=\"store_true\", help=text)\n\tdef add_params(parser, subcommand=None):\n\t    parser._action_groups.pop()\n\t    required = parser.add_argument_group(\"required arguments\")\n\t    optional = parser.add_argument_group(\"optional arguments\")\n\t    if subcommand == \"dataset\":\n", "        # Mandatory\n\t        add_dataset_name_param(parser=required, required=True)\n\t        add_dataset_tag_param(parser=required, required=True)\n\t        add_outdir_param(parser=optional, required=False)\n\t        # Optional General\n\t        add_debug_param(parser=optional, required=False)\n\t        add_log_param(parser=optional, required=False)\n\t        add_threads_param(parser=optional, required=False)\n\t    elif subcommand == \"run\":\n\t        # Mandatory\n", "        add_dataset_param(parser=required, required=True)\n\t        # Mutually exclusive arguments\n\t        add_lineages_param(parser=optional, required=False)\n\t        add_alignment_param(parser=optional, required=False)\n\t        # Optional General\n\t        add_debug_param(parser=optional, required=False)\n\t        add_log_param(parser=optional, required=False)\n\t        add_outdir_param(parser=optional, required=False)\n\t        add_threads_param(parser=optional, required=False)\n\t        # Optional Specific\n", "        add_no_edge_cases_param(parser=optional, required=False)\n\t        add_mask_param(parser=optional, required=False)\n\t        add_exclude_non_recomb_param(parser=optional, required=False)\n\t        add_max_breakpoints_param(parser=optional, required=False)\n\t        add_max_depth_param(parser=optional, required=False)\n\t        add_min_length_param(parser=optional, required=False)\n\t        add_min_consecutive_param(parser=optional, required=False)\n\t        add_min_subs_param(parser=optional, required=False)\n\t        add_shared_param(parser=optional, required=False)\n\t        add_validate_param(parser=optional, required=False)\n", "        add_plot_ext_param(parser=optional, required=False)\n\t        # Optional Output\n\t        add_output_all_param(parser=optional, required=False)\n\t        add_output_plot_param(parser=optional, required=False)\n\t        add_output_barcode_param(parser=optional, required=False)\n\t        add_output_tsv_param(parser=optional, required=False)\n\t        add_output_yaml_param(parser=optional, required=False)\n\t# -----------------------------------------------------------------------------\n\tdef make_parser():\n\t    # descriptions\n", "    rebar_desc = \"rebar: REcombination BARcode detection\"\n\t    dataset_desc = \"Download and create the rebar data model.\"\n\t    run_desc = \"Run rebar on an alignment or user-specified lineages.\"\n\t    version_desc = \"Print version.\"\n\t    help_desc = \"Print subcommands.\"\n\t    parser = argparse.ArgumentParser(description=\"\", usage=rebar_desc)\n\t    rebar_subcommand_desc = (\n\t        \"\\n\\n\"\n\t        + \"\\tdataset\\t\\t\"\n\t        + dataset_desc\n", "        + \"\\n\"\n\t        + \"\\trun\\t\\t\"\n\t        + run_desc\n\t        + \"\\n\"\n\t        + \"\\thelp\\t\\t\"\n\t        + help_desc\n\t        + \"\\n\"\n\t        + \"\\tversion\\t\\t\"\n\t        + version_desc\n\t        + \"\\n\"\n", "    )\n\t    parser.set_defaults(func=lambda x: print(rebar_desc + rebar_subcommand_desc))\n\t    subparsers = parser.add_subparsers()\n\t    # help\n\t    help_parser = subparsers.add_parser(\"help\", description=help_desc)\n\t    help_parser.set_defaults(func=lambda x: print(rebar_desc + rebar_subcommand_desc))\n\t    # version\n\t    version_parser = subparsers.add_parser(\"version\", description=version_desc)\n\t    version_parser.set_defaults(func=lambda x: print(\"rebar v\" + version))\n\t    # dataset\n", "    dataset_parser = subparsers.add_parser(\"dataset\", description=dataset_desc)\n\t    add_params(dataset_parser, subcommand=\"dataset\")\n\t    dataset_parser.set_defaults(func=dataset)\n\t    # run\n\t    run_parser = subparsers.add_parser(\"run\", description=run_desc)\n\t    add_params(run_parser, subcommand=\"run\")\n\t    run_parser.set_defaults(func=run)\n\t    return parser\n"]}
{"filename": "rebar/barcode.py", "chunked_list": ["import yaml\n\timport statistics\n\timport random\n\tfrom datetime import datetime\n\timport pandas as pd\n\tfrom .substitution import Substitution\n\tfrom .constants import EDGE_CASE_RECOMBINANTS\n\tclass Barcode:\n\t    def __init__(\n\t        self,\n", "        genome=None,\n\t        barcode_summary=None,\n\t        barcodes=None,\n\t        tree=None,\n\t        recombinant_lineages=None,\n\t        recombinant_tree=None,\n\t        lineage_to_clade=None,\n\t        top_n=1,\n\t        diagnostic=None,\n\t    ):\n", "        # Initialize attributes\n\t        self.name = None\n\t        self.clade = None\n\t        self.clade_lineage = None\n\t        self.top_lineages = []\n\t        self.top_lineages_subsample = []\n\t        self.outlier_lineages = []\n\t        self.recombinant = None\n\t        self.recursive = None\n\t        self.edge_case = False\n", "        self.diagnostic = []\n\t        self.barcode = []\n\t        self.support = []\n\t        self.missing = []\n\t        self.conflict_ref = []\n\t        self.conflict_alt = []\n\t        self.definition = None\n\t        self.definition_aa = None\n\t        # Run search\n\t        if (\n", "            genome\n\t            and tree\n\t            and recombinant_lineages\n\t            and type(barcode_summary) == pd.core.frame.DataFrame\n\t            and type(barcodes) == pd.core.frame.DataFrame\n\t            and type(diagnostic) == pd.core.frame.DataFrame\n\t            and type(lineage_to_clade) == pd.core.frame.DataFrame\n\t        ):\n\t            self.search(\n\t                genome=genome,\n", "                barcode_summary=barcode_summary,\n\t                barcodes=barcodes,\n\t                tree=tree,\n\t                recombinant_lineages=recombinant_lineages,\n\t                lineage_to_clade=lineage_to_clade,\n\t                top_n=top_n,\n\t                diagnostic=diagnostic,\n\t            )\n\t        # Set recombinant status (self.recombinant and self.recursive)\n\t        if genome and recombinant_lineages and recombinant_tree:\n", "            self.set_recombinant_status(\n\t                genome=genome,\n\t                recombinant_lineages=recombinant_lineages,\n\t                recombinant_tree=recombinant_tree,\n\t            )\n\t    def __repr__(self):\n\t        text = (\n\t            \"lineage:      \"\n\t            + str(self.name)\n\t            + \"definition:      \"\n", "            + str(self.definition)\n\t            + \"clade:      \"\n\t            + str(self.clade)\n\t            + \"clade_lineage:      \"\n\t            + str(self.clade_lineage)\n\t            + \"\\ntop_lineages: \"\n\t            + str(self.top_lineages)\n\t            + \"\\ntop_lineages_subsample: \"\n\t            + str(self.top_lineages_subsample)\n\t            + \"\\noutlier_lineages: \"\n", "            + str(self.outlier_lineages)\n\t            + \"\\nbarcode:      \"\n\t            + str(self.barcode)\n\t            + \"\\ndiagnostic:      \"\n\t            + str(self.diagnostic)\n\t            + \"\\nsupport:      \"\n\t            + str(self.support)\n\t            + \"\\nmissing:      \"\n\t            + str(self.missing)\n\t            + \"\\nconflict_ref: \"\n", "            + str(self.conflict_ref)\n\t            + \"\\nconflict_alt: \"\n\t            + str(self.conflict_alt)\n\t            + \"\\nrecombinant: \"\n\t            + str(self.recombinant)\n\t            + \"\\nrecursive: \"\n\t            + str(self.recursive)\n\t            + \"\\nedge_case: \"\n\t            + str(self.edge_case)\n\t            + \"\\n\"\n", "        )\n\t        return text\n\t    def to_dict(self):\n\t        barcode_dict = {\n\t            \"lineage\": self.name,\n\t            \"definition\": self.definition,\n\t            \"clade\": self.clade,\n\t            \"clade_lineage\": self.clade_lineage,\n\t            \"top_lineages\": \",\".join(self.top_lineages),\n\t            \"top_lineages_subsample\": \",\".join(self.top_lineages_subsample),\n", "            \"outlier_lineages\": \",\".join(self.outlier_lineages),\n\t            \"barcode\": \",\".join([str(s) for s in self.barcode]),\n\t            \"support\": \",\".join([str(s) for s in self.support]),\n\t            \"missing\": \",\".join([str(s) for s in self.missing]),\n\t            \"conflict_ref\": \",\".join([str(s) for s in self.conflict_ref]),\n\t            \"conflict_alt\": \",\".join([str(s) for s in self.conflict_alt]),\n\t            \"recombinant\": str(self.recombinant),\n\t            \"recursive\": str(self.recursive),\n\t            \"edge_case\": str(self.edge_case),\n\t        }\n", "        return barcode_dict\n\t    def to_yaml(self, indent=2):\n\t        \"\"\"\n\t        Convert Barcode object to yaml.\n\t        Returns\n\t        -------\n\t        genome_yaml : yaml\n\t            YAML representation of Barcode.\n\t        \"\"\"\n\t        barcode_yaml = (\n", "            yaml.dump(self.to_dict(), sort_keys=False, indent=indent)\n\t            .replace(\"null\", \"\")\n\t            .replace(\"''\", \"\")\n\t            + \"\\n\"\n\t        )\n\t        return barcode_yaml\n\t    def search(\n\t        self,\n\t        genome,\n\t        barcode_summary,\n", "        barcodes,\n\t        recombinant_lineages,\n\t        tree,\n\t        lineage_to_clade,\n\t        diagnostic,\n\t        subsample_threshold=10,\n\t        top_n=1,\n\t    ):\n\t        # No barcode matches, stop the search\n\t        if len(barcode_summary) == 0:\n", "            return 0\n\t        # ---------------------------------------------------------------------\n\t        # Iterative Searches\n\t        # Search Method #1 : Candidate Top Lineage Matches\n\t        top_lineages = self.search_candidate_matches(barcode_summary, top_n)\n\t        if genome.debug:\n\t            msg = str(datetime.now()) + \"\\t\\t\\tsearch_candidates: \" + str(top_lineages)\n\t            genome.logger.info(msg)\n\t        # Assume all lineages are outliers to begin with, we will remove\n\t        # lineages from this list that survive all search methods.\n", "        outlier_lineages = top_lineages\n\t        # Search Method #2: Lineage-diagnostic mutations presence\n\t        top_lineages = self.search_diagnostic_mutations_presence(\n\t            genome, top_lineages, diagnostic, tree\n\t        )\n\t        if genome.debug:\n\t            msg = str(datetime.now()) + \"\\t\\t\\tsearch_diagnostic: \" + str(top_lineages)\n\t            genome.logger.info(msg)\n\t        # Search Method #3: Perfect matches (ie. no conflict_ref)\n\t        # THIS WILL DRAMATICALLY SLOW THINGS DOWN when a large number of\n", "        # top lineages are present\n\t        # top_lineages = self.search_conflict_ref(genome, top_lineages, barcodes)\n\t        # if genome.debug:\n\t        #     msg = (\n\t        #         str(datetime.now())\n\t        #         + \"\\t\\t\\tsearch_conflict_ref: \"\n\t        #         + str(top_lineages)\n\t        #     )\n\t        #     genome.logger.info(msg)\n\t        # If our top_lineages list is too long ( > subsample_threshold ), subsample\n", "        top_lineages_subsample = top_lineages\n\t        if len(top_lineages) > subsample_threshold:\n\t            max_total = barcode_summary[\"total\"].max()\n\t            max_lineages = list(\n\t                barcode_summary[\n\t                    (barcode_summary[\"lineage\"].isin(top_lineages))\n\t                    & (barcode_summary[\"total\"] == max_total)\n\t                ][\"lineage\"]\n\t            )\n\t            # Option 1: Randomly select samples, this is the preferred\n", "            #  method when a large number of samples are tied for top place\n\t            if len(max_lineages) > subsample_threshold:\n\t                random.seed(123456)\n\t                top_lineages_subsample = random.choices(\n\t                    top_lineages, k=subsample_threshold\n\t                )\n\t            # Option 2: Take top subsample_threshold samples, this is the\n\t            # preferred method when there isn't a big top tie\n\t            else:\n\t                top_lineages_subsample = top_lineages[0:subsample_threshold]\n", "        if genome.debug:\n\t            msg = (\n\t                str(datetime.now())\n\t                + \"\\t\\t\\tsearch_subsample: \"\n\t                + str(top_lineages_subsample)\n\t            )\n\t            genome.logger.info(msg)\n\t        # Search Method #3: Pairwise Distance\n\t        #   If our top_lineages are a mix of recombinants and non-recombinants\n\t        #   don't use this filter, because distances will be uninformative\n", "        #   since recombinants have pseudo-tree placements under a fake \"X\" node\n\t        top_lineages_rec = [l for l in top_lineages if l in recombinant_lineages]\n\t        top_lineages_non_rec = [l for l in top_lineages if l not in top_lineages_rec]\n\t        if len(top_lineages_rec) == 0 or len(top_lineages_non_rec) == 0:\n\t            top_lineages = self.search_pairwise_distance(top_lineages_subsample, tree)\n\t        else:\n\t            top_lineages = top_lineages_subsample\n\t        if genome.debug:\n\t            msg = str(datetime.now()) + \"\\t\\t\\tsearch_distance: \" + str(top_lineages)\n\t            genome.logger.info(msg)\n", "        # Search Method #4: Maximum Parsimony\n\t        top_lineages = self.search_maximum_parsimony(genome, top_lineages, barcodes)\n\t        if genome.debug:\n\t            msg = str(datetime.now()) + \"\\t\\t\\tsearch_parsimony: \" + str(top_lineages)\n\t            genome.logger.info(msg)\n\t            # Some whitespace before next debug info\n\t            genome.logger.info(str(datetime.now()))\n\t        # ---------------------------------------------------------------------\n\t        # Summarize Search\n\t        outlier_lineages = [l for l in outlier_lineages if l not in top_lineages]\n", "        lineage = tree.common_ancestor(top_lineages).name\n\t        clade, clade_lineage = self.convert_lineage_to_clade(\n\t            genome, lineage, lineage_to_clade\n\t        )\n\t        (\n\t            lineage_barcode,\n\t            support,\n\t            conflict_alt,\n\t            conflict_ref,\n\t            missing,\n", "        ) = self.summarise_top_lineages(genome, lineage, top_lineages, barcodes)\n\t        # ---------------------------------------------------------------------\n\t        # Update Attributes\n\t        self.name = lineage\n\t        self.definition = lineage\n\t        self.clade = clade\n\t        self.clade_lineage = clade_lineage\n\t        self.top_lineages = top_lineages\n\t        self.top_lineages_subsample = top_lineages_subsample\n\t        self.outlier_lineages = outlier_lineages\n", "        self.barcode = lineage_barcode\n\t        self.support = support\n\t        self.missing = missing\n\t        self.conflict_ref = conflict_ref\n\t        self.conflict_alt = conflict_alt\n\t        return 0\n\t    def search_candidate_matches(self, barcode_summary, top_n):\n\t        # Identify the lineage(s) with the largest number of barcode matches\n\t        # taking the top_n matches. Lineages such as XV require relaxation of\n\t        # the top_n parameter (top_n=3) because XV is NOT the lineage with\n", "        # the hightest number of matches.\n\t        #   Example: XV\n\t        #   top_n=3\n\t        #   XJ [61, yes], XV [60, yes],  XY [60, yes], XAF [59, yes], XE [58, no]\n\t        largest_totals = sorted(list(set(barcode_summary[\"total\"])))\n\t        largest_totals.reverse()\n\t        max_barcodes = largest_totals[0:top_n]\n\t        # Restrict to lineages with subs within top_n of largest total\n\t        #   Lineage: B.1.634\n\t        #   largest_total=27\n", "        #   min_subs=25\n\t        #   B.1.634 [27, yes], XB [15, no], XAY.3 [10, no], XAY.2.3 [10, no]\n\t        max_total = largest_totals[0]\n\t        min_subs = max_total - top_n - 1\n\t        max_barcodes = [t for t in largest_totals[0:top_n] if t > min_subs]\n\t        # Identify our top lineages based on the above criteria\n\t        top_lineages = list(\n\t            barcode_summary[barcode_summary[\"total\"].isin(max_barcodes)][\"lineage\"]\n\t        )\n\t        return top_lineages\n", "    def search_diagnostic_mutations_presence(\n\t        self, genome, top_lineages, diagnostic, tree\n\t    ):\n\t        # ---------------------------------------------------------------------\n\t        # Outlier Detection #1: Lineage Diagnostic Mutations\n\t        #   If a sub in genome.substitutions is diagnostic for a particular\n\t        #   lineage or its descendants, we will retain only those lineages.\n\t        #\n\t        #   Example: XBK\n\t        #     XBK.1 [88], XBK [88], XBQ [87], CJ.1 [86], CJ [86], ...\n", "        #     There are so many CJ.1 close matches, diagnostic mutations\n\t        #     helps us resolve that XBK* is actually the best match.\n\t        # if there's only one top lineage, just return that\n\t        if len(top_lineages) <= 1:\n\t            return top_lineages\n\t        keep_lineages = []\n\t        # Search for diagnostic mutations in the genome subs\n\t        for s in genome.substitutions:\n\t            s_row = diagnostic[diagnostic[\"mutation\"] == str(s)]\n\t            if len(s_row) == 0:\n", "                continue\n\t            s_lin = s_row[\"lineage\"].values[0]\n\t            s_include_desc = s_row[\"include_descendants\"].values[0]\n\t            s_top_lin = []\n\t            # Complex, descendant match\n\t            if s_include_desc:\n\t                s_desc = [c.name for c in next(tree.find_clades(s_lin)).find_clades()]\n\t                s_top_lin += [l for l in s_desc if l in top_lineages]\n\t            # Simple, exact match\n\t            elif s_lin in top_lineages:\n", "                s_top_lin.append(s_lin)\n\t            keep_lineages += s_top_lin\n\t        # Remove duplicates\n\t        keep_lineages = list(set(keep_lineages))\n\t        # If we found keepers, return those\n\t        if len(keep_lineages) > 0:\n\t            return keep_lineages\n\t        # otherwise, just return original top_lineages\n\t        else:\n\t            return top_lineages\n", "    def search_conflict_ref(self, genome, top_lineages, barcodes):\n\t        # Check if any are a perfect match (ie. no conflict_ref)\n\t        # This is needed for BM.1.1 otherwise can be a false positive\n\t        # for XBQ.\n\t        # if there's only one top lineage, just return that\n\t        if len(top_lineages) <= 1:\n\t            return top_lineages\n\t        else:\n\t            keep_lineages = []\n\t            for lin in top_lineages:\n", "                row = barcodes.query(\"lineage == @lin\")\n\t                subs = [\n\t                    Substitution(s) for s in row.columns[1:] if list(row[s])[0] == 1\n\t                ]\n\t                conflict_ref = [\n\t                    s\n\t                    for s in subs\n\t                    if s not in genome.substitutions and s.coord not in genome.missing\n\t                ]\n\t                if len(conflict_ref) == 0:\n", "                    keep_lineages.append(lin)\n\t        # If we found keepers, return those\n\t        if len(keep_lineages) > 0:\n\t            return keep_lineages\n\t        # otherwise, just return original top_lineages\n\t        else:\n\t            return top_lineages\n\t    def search_pairwise_distance(self, top_lineages, tree):\n\t        # ---------------------------------------------------------------------\n\t        # Outlier Detection #2: Pairwise-Phylogenetic Distance\n", "        #  If a lineage is too far away from the other candidate linages\n\t        #  (ie. phylogenetic outlier), we will remove it. The value of this\n\t        #  method is mainly when no diagnostic mutations are observed for\n\t        #  detection method #1.\n\t        #\n\t        #  Example: XAT\n\t        # if there's 2 or less top lineage, can't use this method\n\t        if len(top_lineages) <= 2:\n\t            return top_lineages\n\t        else:\n", "            distances_summary = {}\n\t            # Calculate all pairwise distances between lineages\n\t            # this is why we subsample, otherwise extraordinarily slow\n\t            for l1 in top_lineages:\n\t                distances = []\n\t                for l2 in top_lineages:\n\t                    if l1 == l2:\n\t                        continue\n\t                    distances.append(tree.distance(l1, l2))\n\t                # Summarize the pairwise distances for this lineage by `mean`\n", "                distances_summary[l1] = statistics.mean(distances)\n\t            # The mode of all mean distances (confusing, I know) is how\n\t            # we'll find the threshold for outliers\n\t            distances_mode = statistics.mode(distances_summary.values())\n\t            # keeper lineages are ones where there mean pairwise distance\n\t            # was less than or equal to the mode (most frequently observed distance)\n\t            keep_lineages = [\n\t                l for l, d in distances_summary.items() if d <= distances_mode\n\t            ]\n\t        # If we found keepers, return those\n", "        if len(keep_lineages) > 0:\n\t            return keep_lineages\n\t        # otherwise, just return original top_lineages\n\t        else:\n\t            return top_lineages\n\t    def search_maximum_parsimony(self, genome, top_lineages, barcodes):\n\t        # ---------------------------------------------------------------------\n\t        # Outlier Detection #3: Maximum Parsimony (ie. minimum conflicts)\n\t        # If lineages are tied for best match at this point, we will prefer the\n\t        # lineage with the least sub conflicts with the genome.substitutions.\n", "        # This is deliberately put after the pairwise-distance method, for reasons\n\t        # I need to document.\n\t        # Subsampling was already done in detection #2. But we need to exclude\n\t        # any additional outliers from it. We don't directly modify the variable\n\t        # top_lineages_subsample, because we want to display it in the end for debug.\n\t        # if there's only one top lineage, there are no outliers\n\t        if len(top_lineages) <= 1:\n\t            return top_lineages\n\t        else:\n\t            parsimony_summary = {\n", "                \"lineage\": [],\n\t                \"support\": [],\n\t                \"conflict_alt\": [],\n\t                \"conflict_ref\": [],\n\t                \"parsimony\": [],\n\t            }\n\t            for lin in top_lineages:\n\t                row = barcodes.query(\"lineage == @lin\")\n\t                subs = sorted(\n\t                    [Substitution(s) for s in row.columns[1:] if list(row[s])[0] == 1]\n", "                )\n\t                # support: sub in genome also in candidate's barcode\n\t                support = [s for s in genome.substitutions if s in subs]\n\t                # conflict_alt: sub in genome that is not in candidate's barcode\n\t                #               ie. unexpected ALT base.\n\t                conflict_alt = [s for s in genome.substitutions if s not in subs]\n\t                # conflict_ref: sub in candidate's barcode that is not in genome\n\t                #               ie. unexpected REF base.\n\t                conflict_ref = [\n\t                    s\n", "                    for s in subs\n\t                    if s not in genome.substitutions\n\t                    and s.coord not in genome.missing\n\t                    and s.coord not in genome.deletions\n\t                ]\n\t                # our parsimony score is support - conflict\n\t                parsimony_score = len(support) - (len(conflict_alt) + len(conflict_ref))\n\t                parsimony_summary[\"lineage\"].append(lin)\n\t                parsimony_summary[\"support\"].append(len(support))\n\t                parsimony_summary[\"conflict_alt\"].append(len(conflict_alt))\n", "                parsimony_summary[\"conflict_ref\"].append(len(conflict_ref))\n\t                parsimony_summary[\"parsimony\"].append(parsimony_score)\n\t            parsimony_df = pd.DataFrame(parsimony_summary).sort_values(\n\t                by=[\"support\", \"parsimony\"], ascending=True\n\t            )\n\t            # Identify maximum parsimony lineage\n\t            max_parsimony_count = parsimony_df[\"parsimony\"].max()\n\t            # Identify all the non-outliers in the subsampled lineages\n\t            keep_lineages = list(\n\t                parsimony_df[parsimony_df[\"parsimony\"] == max_parsimony_count][\n", "                    \"lineage\"\n\t                ]\n\t            )\n\t        # If we found keepers, return those\n\t        if len(keep_lineages) > 0:\n\t            return keep_lineages\n\t        # otherwise, just return original top_lineages\n\t        else:\n\t            return top_lineages\n\t    def convert_lineage_to_clade(self, genome, lineage, lineage_to_clade):\n", "        # Get clade of lineage\n\t        if lineage in list(lineage_to_clade[\"lineage\"]):\n\t            clade = lineage_to_clade[lineage_to_clade[\"lineage\"] == lineage][\n\t                \"nextstrainClade\"\n\t            ].values[0]\n\t            clade_lineage = lineage_to_clade[lineage_to_clade[\"lineage\"] == lineage][\n\t                \"nextstrainClade_lineage\"\n\t            ].values[0]\n\t        elif lineage in [\"MRCA\", \"X\"]:\n\t            clade = lineage\n", "            clade_lineage = lineage\n\t        else:\n\t            clade = None\n\t            clade_lineage = None\n\t            if genome.debug:\n\t                genome.logger.info(\n\t                    str(datetime.now())\n\t                    + \"\\t\\t\\tWARNING: unknown clade for lineage \"\n\t                    + str(lineage)\n\t                )\n", "        return clade, clade_lineage\n\t    def summarise_top_lineages(self, genome, lineage, top_lineages, barcodes):\n\t        # There might be a case where a sub conflicts with the mrca of top_lineages\n\t        # but is still found in all of the top_lineages. Don't consider these subs\n\t        # to be conflicts.\n\t        # Ex. XAJ. T15009C is a conflict for MRCA BA.2.12.1, but all top_lineages\n\t        #          (BG*) have that sub.\n\t        # Get the full barcode for the final lineage\n\t        lineage_row = barcodes[barcodes[\"lineage\"] == lineage]\n\t        # No lineages may match if it was MRCA:\n", "        lineage_barcode = []\n\t        if len(lineage_row) > 0:\n\t            lineage_barcode = [\n\t                Substitution(s)\n\t                for s in lineage_row.columns[1:]\n\t                if list(lineage_row[s])[0] == 1\n\t            ]\n\t        # Identify subs for each top lineage\n\t        top_lineages_subs = []\n\t        for lin in top_lineages:\n", "            row = barcodes[barcodes[\"lineage\"] == lin]\n\t            subs = sorted(\n\t                [Substitution(s) for s in row.columns[1:] if list(row[s])[0] == 1]\n\t            )\n\t            top_lineages_subs += subs\n\t        # Identify the subs that are shared among all\n\t        top_lineages_subs_shared = sorted(\n\t            [\n\t                s\n\t                for s in set(top_lineages_subs)\n", "                if top_lineages_subs.count(s) == len(top_lineages)\n\t            ]\n\t        )\n\t        # Get the barcode subs that were observed\n\t        support = sorted([s for s in lineage_barcode if s in genome.substitutions])\n\t        # Get the barcodes subs that were missing data\n\t        missing = sorted(\n\t            [\n\t                s\n\t                for s in lineage_barcode\n", "                if s not in genome.substitutions and s.coord in genome.missing\n\t            ]\n\t        )\n\t        # Get the barcode subs that were ref instead\n\t        conflict_ref = sorted(\n\t            [\n\t                s\n\t                for s in lineage_barcode\n\t                if s not in genome.substitutions and s.coord not in genome.missing\n\t            ]\n", "        )\n\t        # Get non-barcode subs, that were alt and unexpected\n\t        # TBD: deletions excluded?\n\t        conflict_alt = sorted(\n\t            [\n\t                s\n\t                for s in genome.substitutions\n\t                if s not in lineage_barcode and s not in top_lineages_subs_shared\n\t            ]\n\t        )\n", "        conflict_subs = sorted(conflict_ref + conflict_alt)\n\t        conflict_ref = [s for s in conflict_ref if s in conflict_subs]\n\t        conflict_alt = [s for s in conflict_alt if s in conflict_subs]\n\t        return lineage_barcode, support, conflict_alt, conflict_ref, missing\n\t    def set_recombinant_status(self, genome, recombinant_lineages, recombinant_tree):\n\t        if self.name == \"X\":\n\t            self.recombinant = \"X\"\n\t            self.recursive = False\n\t        # Option 1: Top backbone lineage is s recombinant\n\t        elif self.name in recombinant_lineages:\n", "            # Identify the generic recombinant type (XBB.1.5 = XBB)\n\t            recombinant_path = recombinant_tree.get_path(self.name)\n\t            # Move backwards up the path, until we find a parental lineage that\n\t            # starts with \"X\", because it might be an alias (\"EK\")\n\t            for c in recombinant_path[::-1]:\n\t                if c.name.startswith(\"X\"):\n\t                    self.recombinant = c.name.split(\".\")[0]\n\t                    break\n\t            # Check if this is a recursive recombinant\n\t            # Note: In the get_path method, the root is excluded\n", "            node_path = recombinant_tree.get_path(self.recombinant)\n\t            # So if node_path just has more than one clade (ex. [XBB, XBL]),\n\t            # it's recursive\n\t            if len(node_path) > 1:\n\t                self.recursive = True\n\t            # Edge case status\n\t            if self.recombinant in EDGE_CASE_RECOMBINANTS:\n\t                self.edge_case = True\n\t        # Option 2: Perfect match to non-recombinant\n\t        elif len(self.conflict_ref) == 0:\n", "            self.recombinant = False\n\t        return 0\n\t    def set_definition(self):\n\t        self.definition = self.name\n\t        if len(self.conflict_alt) > 0:\n\t            self.definition += \"+\" + \",\".join([str(s) for s in self.conflict_alt])\n"]}
