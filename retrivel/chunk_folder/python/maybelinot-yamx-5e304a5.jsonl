{"filename": "yamx/extra.py", "chunked_list": ["# not very supported pieces of functionality\n\tfrom typing import Any, Optional, Set\n\tfrom jinja2 import nodes\n\tfrom yamx.containers.data import (\n\t    Condition,\n\t    ConditionalGroup,\n\t    ConditionalMap,\n\t    ConditionalSeq,\n\t)\n\tfrom yamx.loader.utils import get_jinja_env\n", "def extract_toggles(obj: Any, toggles: Set[str] = set()):\n\t    if isinstance(obj, ConditionalMap):\n\t        for value in obj.values():\n\t            toggles |= extract_toggles(value)\n\t    elif isinstance(obj, ConditionalSeq):\n\t        for value in obj:\n\t            toggles |= extract_toggles(value)\n\t    elif isinstance(obj, ConditionalGroup):\n\t        toggles |= _extract_toggles_from_condition(obj.condition)\n\t        toggles |= extract_toggles(obj.body)\n", "        toggles |= extract_toggles(obj.else_body)\n\t        for elif_body in obj.elif_bodies or []:\n\t            toggles |= extract_toggles(elif_body)\n\t    else:\n\t        return toggles\n\t    return toggles\n\tdef _extract_toggles_from_condition(condition: Optional[Condition]) -> Set[str]:\n\t    \"\"\"This method works only for particular condition format\"\"\"\n\t    if condition is None:\n\t        return set()\n", "    env = get_jinja_env()\n\t    jinja_ast = env.parse(f\"{{% if {condition.raw_value} %}}{{% endif %}}\")\n\t    return {\n\t        _extract_toggle_from_if_node(jinja_ast.body[0].test),\n\t    }\n\tdef _extract_toggle_from_if_node(if_test_node: nodes.Call) -> str:\n\t    # we have negation in condition\n\t    if isinstance(if_test_node, nodes.Not):\n\t        return if_test_node.node.args[0].value\n\t    return if_test_node.args[0].value\n"]}
{"filename": "yamx/__init__.py", "chunked_list": ["from yamx.yamx import YAMX\n\t__all__ = [\"YAMX\"]\n"]}
{"filename": "yamx/yamx.py", "chunked_list": ["import re\n\tfrom functools import partial\n\tfrom typing import Any, Dict, Optional\n\tfrom jinja2 import meta\n\tfrom ruamel.yaml import YAML, RoundTripConstructor, RoundTripRepresenter\n\tfrom yamx.constants import (\n\t    CONDITIONAL_TAG,\n\t    DEDUPLICATOR,\n\t    DEDUPLICATOR_UPD,\n\t    DEFAULT_MAPPING_INDENT,\n", "    DEFAULT_OFFSET_INDENT,\n\t    DEFAULT_SEQUENCE_INDENT,\n\t    YAML_MAP_TAG,\n\t    YAML_SEQ_TAG,\n\t)\n\tfrom yamx.containers import (\n\t    ConditionalBlock,\n\t    ConditionalData,\n\t    ConditionalMap,\n\t    ConditionalSeq,\n", "    IndentConfig,\n\t)\n\tfrom yamx.loader import translate_config_flags, validate_content\n\tfrom yamx.loader.grouper import group_conditional_blocks\n\tfrom yamx.loader.utils import get_jinja_env\n\tfrom yamx.representer import (\n\t    translate_conditional_map_to_yaml,\n\t    translate_conditional_seq_to_yaml,\n\t)\n\tclass ConditionalRoundTripConstructor(RoundTripConstructor):\n", "    def __init__(self, *args, **kwargs):\n\t        self.yaml_constructors = self.__class__.yaml_constructors.copy()\n\t        self.yaml_multi_constructors = self.__class__.yaml_multi_constructors.copy()\n\t        super().__init__(*args, **kwargs)\n\t    def add_custom_constructor(self, tag, constructor):\n\t        self.yaml_constructors[tag] = constructor\n\t    def add_custom_multi_constructor(self, tag, constructor):\n\t        self.yaml_multi_constructors[tag] = constructor\n\tclass ConditionalRoundTripRepresenter(RoundTripRepresenter):\n\t    def __init__(self, *args, **kwargs):\n", "        self.yaml_representers = self.__class__.yaml_representers.copy()\n\t        super().__init__(*args, **kwargs)\n\t    def add_custom_representer(self, tag, representer):\n\t        self.yaml_representers[tag] = representer\n\tclass YAMX:\n\t    \"\"\"Wrapper around ruamel loader that supports conditional functionality\"\"\"\n\t    def __init__(self, yaml: Optional[YAML] = None, sort_keys: bool = True):\n\t        self.sort_keys = sort_keys\n\t        if yaml is None:\n\t            yaml = YAML(typ=[\"rt\", \"string\"])\n", "        else:\n\t            assert isinstance(yaml, YAML), \"Ruamel yaml loader/dumper is required\"\n\t            assert \"rt\" in yaml.typ, \"RoundTripLoader/RoundTripDumper is required\"\n\t        yaml.Constructor = ConditionalRoundTripConstructor\n\t        yaml.Representer = ConditionalRoundTripRepresenter\n\t        # replace default constructor of map and seq - we need to have custom object for\n\t        # each container to allow for condition modification\n\t        yaml.constructor.add_custom_constructor(YAML_MAP_TAG, _construct_map)\n\t        yaml.constructor.add_custom_constructor(YAML_SEQ_TAG, _construct_seq)\n\t        # add constructor for conditional structures, condition information is parsed out\n", "        # from the structure and saved as an attribute of ConditionalMap object\n\t        # TODO: investigate why class register has flaky behaviour\n\t        # yaml.register_class(ConditionalBlock)\n\t        yaml.constructor.add_custom_constructor(\n\t            CONDITIONAL_TAG, ConditionalBlock.from_yaml\n\t        )\n\t        self.yaml = yaml\n\t        # setup custom representer for ConditionalMap and ConditionalSeq objects\n\t        # and default indentation settings\n\t        self.indent()\n", "    def indent(\n\t        self,\n\t        mapping: int = DEFAULT_MAPPING_INDENT,\n\t        sequence: int = DEFAULT_SEQUENCE_INDENT,\n\t        offset: int = DEFAULT_OFFSET_INDENT,\n\t    ) -> None:\n\t        indent_cfg = IndentConfig(\n\t            mapping=mapping,\n\t            sequence=sequence,\n\t            offset=offset,\n", "        )\n\t        self.yaml.indent(\n\t            mapping=indent_cfg.mapping,\n\t            sequence=indent_cfg.sequence,\n\t            offset=indent_cfg.offset,\n\t        )\n\t        self.indent_cfg = indent_cfg\n\t        self._set_custom_representers()\n\t    def _set_custom_representers(self) -> None:\n\t        self.yaml.representer.add_custom_representer(\n", "            ConditionalMap,\n\t            partial(\n\t                translate_conditional_map_to_yaml,\n\t                sort_keys=self.sort_keys,\n\t                indent_cfg=self.indent_cfg,\n\t            ),\n\t        )\n\t        self.yaml.representer.add_custom_representer(\n\t            ConditionalSeq,\n\t            partial(\n", "                translate_conditional_seq_to_yaml,\n\t                sort_keys=self.sort_keys,\n\t                indent_cfg=self.indent_cfg,\n\t            ),\n\t        )\n\t    def load(self, stream) -> ConditionalData:\n\t        data = stream.read()\n\t        validate_content(data)\n\t        conf = translate_config_flags(data)\n\t        data = self.yaml.load(conf)\n", "        grouped_data = group_conditional_blocks(data)\n\t        return ConditionalData(grouped_data)\n\t    def dump(self, data: ConditionalData, stream) -> None:\n\t        self.yaml.dump(\n\t            data._data, stream, transform=self._remove_field_names_deduplicator\n\t        )\n\t    def resolve(self, data: str, context: Dict[str, Any]) -> Any:\n\t        env = get_jinja_env()\n\t        try:\n\t            ast = env.parse(data)\n", "        except Exception as e:\n\t            raise Exception(\"Failed to parse jinja syntax while resolving.\") from e\n\t        missing_variables = meta.find_undeclared_variables(ast) - set(context.keys())\n\t        if missing_variables:\n\t            raise Exception(\n\t                f\"Following context variables are not defined: {missing_variables}\"\n\t            )\n\t        template = env.from_string(ast)\n\t        return template.render(**context)\n\t    def dump_to_string(self, data, **kwargs) -> str:\n", "        raw_data = self.yaml.dump_to_string(data._data, **kwargs)\n\t        return self._remove_field_names_deduplicator(raw_data)\n\t    @staticmethod\n\t    def _remove_field_names_deduplicator(s: str) -> str:\n\t        \"\"\"Removes all occurances of key suffixes used to deduplicated keys\"\"\"\n\t        return re.sub(rf\"({DEDUPLICATOR}|{DEDUPLICATOR_UPD})\\d+\", \"\", s)\n\tdef _construct_map(self, node):\n\t    \"\"\"Default constructor of map that instantiates custom\n\t    ConditionalMap object instead of CommentedMap\"\"\"\n\t    data = ConditionalMap()\n", "    yield data\n\t    self.construct_mapping(node, data, deep=True)\n\t    self.set_collection_style(data, node)\n\tdef _construct_seq(self, node):\n\t    \"\"\"Default constructor of seq that instantiates custom\n\t    ConditionalSeq object instead of CommentedSeq\"\"\"\n\t    data = ConditionalSeq()\n\t    yield data\n\t    data.extend(self.construct_rt_sequence(node, data))\n\t    self.set_collection_style(data, node)\n"]}
{"filename": "yamx/constants.py", "chunked_list": ["from enum import Enum\n\tfrom typing import Final\n\tclass ConditionalBlockType(Enum):\n\t    if_ = \"if\"\n\t    else_ = \"else\"\n\t    elif_ = \"elif\"\n\t# TODO: make configurable to allow for other user specific jinja configurations\n\tNON_EXISTING_STR: Final[str] = \"____THIS_DOESN'T_EXIST____\"\n\t# indentetion defaults\n\tDEFAULT_MAPPING_INDENT: Final[int] = 2\n", "DEFAULT_SEQUENCE_INDENT: Final[int] = 2\n\tDEFAULT_OFFSET_INDENT: Final[int] = 0\n\t# yaml tags\n\tYAML_MAP_TAG: Final[str] = \"tag:yaml.org,2002:map\"\n\tYAML_SEQ_TAG: Final[str] = \"tag:yaml.org,2002:seq\"\n\t# conditional comment templates\n\tIF_CONDITION_TEMPLATE: Final[str] = \"{{% if {} %}}\"\n\tELIF_CONDITION_TEMPLATE: Final[str] = \"{{% elif {} %}}\"\n\tELSE_COMMENT: Final[str] = \"{% else %}\"\n\tENDIF_COMMENT: Final[str] = \"{% endif %}\"\n", "# conditional structure key constants\n\tCONDITIONAL_KEY_PREFIX: Final[str] = \"__condition__\"\n\t# conditional structure tag constants\n\tCONDITIONAL_TAG: Final[str] = \"conditional\"\n\t# conditional key deduplication\n\tDEDUPLICATOR: Final[str] = \"__deduplicator__\"\n\tDEDUPLICATOR_UPD: Final[str] = \"__deduplicator_upd__\"\n"]}
{"filename": "yamx/loader/validator.py", "chunked_list": ["from typing import Any\n\tfrom yamx.constants import (\n\t    CONDITIONAL_KEY_PREFIX,\n\t    CONDITIONAL_TAG,\n\t    DEDUPLICATOR,\n\t    DEDUPLICATOR_UPD,\n\t    NON_EXISTING_STR,\n\t)\n\tdef validate_content(data: Any) -> None:\n\t    \"\"\"Checks that internally used fields do not exist in input yaml file\"\"\"\n", "    assert all(\n\t        value not in data\n\t        for value in (\n\t            CONDITIONAL_KEY_PREFIX,\n\t            NON_EXISTING_STR,\n\t            DEDUPLICATOR,\n\t            DEDUPLICATOR_UPD,\n\t            CONDITIONAL_TAG,\n\t        )\n\t    )\n"]}
{"filename": "yamx/loader/preprocessor.py", "chunked_list": ["import io\n\tfrom typing import Dict, List, Optional, Union\n\tfrom jinja2 import nodes\n\tfrom ruamel.yaml import YAML\n\tfrom ruamel.yaml.comments import CommentedMap, CommentedSeq\n\tfrom ruamel.yaml.tag import Tag\n\tfrom yamx.constants import CONDITIONAL_KEY_PREFIX, CONDITIONAL_TAG, ConditionalBlockType\n\tfrom yamx.containers.data import Condition\n\tfrom yamx.jinja.condition import extract_condition\n\tfrom yamx.loader.utils import get_jinja_env\n", "UNIQUE_CONDITION_CNT: int = 0\n\tyaml = YAML()\n\tJINJA_ENV = get_jinja_env()\n\tdef translate_config_flags(data: str) -> str:\n\t    \"\"\"Translates config flags defined with jinja syntax into yaml-compatible configuration.\n\t    This step is required to create common interface which can be loaded and dumped as a\n\t    single operation, without any information loss.\n\t    All Conditional dict/list values are stored in newly created structure under\n\t    unique `__condition__\\\\d` key. That way deduplication of Toggled fields is ensured for mappings.\n\t    Structure itself has 3 fields:\n", "      \"data\" - all conditional data are stored under this key\n\t      \"condition\" - string with original condition\n\t      \"typ\" - type of conditional block\n\t    Example input:\n\t        '''\n\t        dictionary:\n\t          flag1: value1\n\t          # {% if defines.get('toggle') %}\n\t          flag2: value2\n\t          # {% else %}\n", "          flag2: value3\n\t          # {% endif %}\n\t        list:\n\t        - value1\n\t        # {% if defines.get('toggle') %}\n\t        - value2\n\t        # {% else %}\n\t        - value3\n\t        # {% endif %}\n\t        '''\n", "    Example output:\n\t        '''\n\t        dictionary:\n\t          flag1: value1\n\t          __condition__0: !conditional\n\t            data:\n\t                flag2: value2\n\t            typ: if\n\t            condition: defines.get('toggle')\n\t          __condition__1: !conditional\n", "            data:\n\t                flag2: value3\n\t            typ: else\n\t            condition: null\n\t        list:\n\t        - value1\n\t        - __condition__2: !conditional\n\t            data:\n\t            - value2\n\t            typ: if\n", "            condition: defines.get('toggle')\n\t        - __condition__3: !conditional\n\t            data:\n\t            - value3\n\t            typ: else\n\t            condition:\n\t        '''\n\t    \"\"\"\n\t    jinja_ast = JINJA_ENV.parse(data)\n\t    jinja_yaml_ast = _parse_jinja(jinja_ast)\n", "    return jinja_yaml_ast\n\tdef _parse_jinja(\n\t    jinja_ast: Union[nodes.Template, nodes.Output, nodes.If, nodes.TemplateData]\n\t) -> str:\n\t    # root node of jinja - just process internals\n\t    if isinstance(jinja_ast, nodes.Template):\n\t        processed = \"\".join(map(_parse_jinja, jinja_ast.body))\n\t    # intermediate node which contain conditions and plain text\n\t    elif isinstance(jinja_ast, nodes.Output):\n\t        processed = \"\".join(map(_parse_jinja, jinja_ast.nodes))\n", "    # Conditional node\n\t    elif isinstance(jinja_ast, nodes.If):\n\t        processed = _process_jinja_if_node(jinja_ast, typ=ConditionalBlockType.if_)\n\t    # simple text node - no conditions are expected inside\n\t    elif isinstance(jinja_ast, nodes.TemplateData):\n\t        processed = _remove_suffix(jinja_ast.data).rstrip(\" \")\n\t    else:\n\t        raise TypeError(f\"Unexpected jinja ast node of type {type(jinja_ast)}.\")\n\t    return processed\n\t# _remove_suffix to remove any jinja syntax comments leftovers (let's hope it will not kick us back)\n", "# NOTE: only works when jinja blocks defined with a space between `#` and a block\n\tdef _remove_suffix(s: str, suffix=\"# \") -> str:\n\t    if s.endswith(suffix):\n\t        return s[: -len(suffix)]\n\t    return s\n\tdef _process_jinja_if_node(jinja_ast: nodes.If, typ: ConditionalBlockType) -> str:\n\t    if_data = \"\".join(map(_parse_jinja, jinja_ast.body))\n\t    condition = extract_condition(jinja_ast.test, JINJA_ENV)\n\t    if_processed = _process_conditions(\n\t        if_data,\n", "        typ=typ,\n\t        condition=condition,\n\t    )\n\t    elif_processed = [\n\t        _process_jinja_if_node(elif_node, typ=ConditionalBlockType.elif_)\n\t        for elif_node in jinja_ast.elif_\n\t    ]\n\t    else_data = \"\".join(map(_parse_jinja, jinja_ast.else_))\n\t    else_processed = _process_conditions(else_data, typ=ConditionalBlockType.else_)\n\t    # filter out empty strings\n", "    processed_nodes = filter(None, [if_processed, *elif_processed, else_processed])\n\t    return \"\\n\".join(processed_nodes) + (\n\t        \"\" if typ is ConditionalBlockType.elif_ else \"\\n\"\n\t    )\n\tdef _process_conditions(\n\t    raw_data: str, typ: ConditionalBlockType, condition: Optional[Condition] = None\n\t) -> str:\n\t    \"\"\"\n\t    # here we rely on the fact that yaml structure is valid and we can:\n\t    # * load it with YAML loader\n", "    # * set dynamically generated tags based on conditions\n\t    # * dump it back to string form\n\t    \"\"\"\n\t    global UNIQUE_CONDITION_CNT\n\t    yaml_data = yaml.load(raw_data)\n\t    # in case\n\t    if yaml_data is None:\n\t        return raw_data\n\t    # TODO: cover \\t and other whitespaces\n\t    leading_spaces = len(raw_data.lstrip(\"\\n\")) - len(raw_data.lstrip(\"\\n\").lstrip(\" \"))\n", "    data = CommentedMap(\n\t        {\n\t            \"data\": yaml_data,\n\t            \"typ\": typ.value,\n\t            \"condition\": condition and condition.raw_value,\n\t        }\n\t    )\n\t    data.yaml_set_ctag(Tag(suffix=CONDITIONAL_TAG))\n\t    res_yaml_data: Union[Dict[str, CommentedMap], List[CommentedMap]]\n\t    if isinstance(yaml_data, CommentedMap):\n", "        # create unique key to separate conditional block from other fields\n\t        key = f\"{CONDITIONAL_KEY_PREFIX}{UNIQUE_CONDITION_CNT}\"\n\t        UNIQUE_CONDITION_CNT += 1\n\t        # abstraction level has to be created in order to encapsulate conditioned fields\n\t        res_yaml_data = {key: data}\n\t    elif isinstance(yaml_data, CommentedSeq):\n\t        # similar structure is created for list fields\n\t        res_yaml_data = [data]\n\t    else:\n\t        # TODO: support simple scalars\n", "        raise NotImplementedError(\n\t            f\"Conditions on {type(yaml_data)} are not supported yet. :(\"\n\t        )\n\t    string_stream = io.StringIO()\n\t    yaml.dump(res_yaml_data, stream=string_stream)\n\t    res = string_stream.getvalue()\n\t    string_stream.close()\n\t    space_indent = \" \" * leading_spaces\n\t    # add indentation in the beginning of each line\n\t    res = res.replace(\"\\n\", f\"\\n{space_indent}\")\n", "    # add indentation in the beginning\n\t    return f\"{space_indent}{res}\".rstrip()\n"]}
{"filename": "yamx/loader/grouper.py", "chunked_list": ["from typing import Any\n\tfrom yamx.constants import ConditionalBlockType\n\tfrom yamx.containers import (\n\t    ConditionalBlock,\n\t    ConditionalGroup,\n\t    ConditionalMap,\n\t    ConditionalSeq,\n\t)\n\tdef group_conditional_blocks(data: Any) -> Any:\n\t    if isinstance(data, ConditionalMap):\n", "        return _group_map_conditional_blocks(data)\n\t    elif isinstance(data, ConditionalSeq):\n\t        return _group_seq_conditional_blocks(data)\n\t    return data\n\tdef _group_seq_conditional_blocks(seq: ConditionalSeq) -> ConditionalSeq:\n\t    \"\"\"Groups ConditionalBlock items into ConditionalGroup objects\"\"\"\n\t    if len(seq) == 0:\n\t        return seq\n\t    new_seq = ConditionalSeq()\n\t    seq.copy_attributes(new_seq)\n", "    prev_item = None\n\t    for item in seq:\n\t        if not isinstance(item, ConditionalBlock):\n\t            if isinstance(item, ConditionalMap):\n\t                item = _group_map_conditional_blocks(item)\n\t            elif isinstance(item, ConditionalSeq):\n\t                item = _group_seq_conditional_blocks(item)\n\t            new_item = item\n\t        elif (\n\t            not isinstance(prev_item, ConditionalGroup)\n", "            or item.typ is ConditionalBlockType.if_\n\t        ):\n\t            new_item = ConditionalGroup(\n\t                body=group_conditional_blocks(item.data), condition=item.condition\n\t            )\n\t        # otherwise group prev item with new\n\t        else:\n\t            # TODO: update indexes of all following comments in new_seq.ca\n\t            prev_item = prev_item.with_conditional_block(\n\t                data=group_conditional_blocks(item.data),\n", "                typ=item.typ,\n\t                condition=item.condition,\n\t            )\n\t            continue\n\t        # if it's not the first item\n\t        if prev_item is not None:\n\t            new_seq.append(prev_item)\n\t        # remember prev element for following iterations\n\t        prev_item = new_item\n\t    new_seq.append(prev_item)\n", "    return new_seq\n\tdef _group_map_conditional_blocks(mapping: ConditionalMap) -> ConditionalMap:\n\t    \"\"\"Groups ConditionalBlock key-values into ConditionalGroup objects\"\"\"\n\t    if len(mapping) == 0:\n\t        return mapping\n\t    new_map = ConditionalMap()\n\t    # preserve original comment attributes\n\t    mapping.copy_attributes(new_map)\n\t    prev_item = None\n\t    for (key, value) in mapping.items():\n", "        if not isinstance(value, ConditionalBlock):\n\t            if isinstance(value, ConditionalMap):\n\t                value = _group_map_conditional_blocks(value)\n\t            elif isinstance(value, ConditionalSeq):\n\t                value = _group_seq_conditional_blocks(value)\n\t            new_item = (key, value)\n\t        elif (\n\t            not prev_item\n\t            or not isinstance(prev_item[1], ConditionalGroup)\n\t            or value.typ is ConditionalBlockType.if_\n", "        ):\n\t            new_item = (\n\t                key,\n\t                ConditionalGroup(\n\t                    body=group_conditional_blocks(value.data), condition=value.condition\n\t                ),\n\t            )\n\t        # otherwise group prev item with new\n\t        else:\n\t            # remove key of prev item from the mapping\n", "            prev_item = (\n\t                key,\n\t                prev_item[1].with_conditional_block(\n\t                    data=group_conditional_blocks(value.data),\n\t                    typ=value.typ,\n\t                    condition=value.condition,\n\t                ),\n\t            )\n\t            continue\n\t        # if it's not the first item\n", "        if prev_item is not None:\n\t            (key, value) = prev_item\n\t            new_map[key] = value\n\t        # remember prev element for following iterations\n\t        prev_item = new_item\n\t    assert isinstance(prev_item, tuple)\n\t    (key, value) = prev_item\n\t    new_map[key] = value\n\t    return new_map\n"]}
{"filename": "yamx/loader/__init__.py", "chunked_list": ["from yamx.loader.preprocessor import translate_config_flags\n\tfrom yamx.loader.validator import validate_content\n\t__all__ = [\"translate_config_flags\", \"validate_content\"]\n"]}
{"filename": "yamx/loader/utils.py", "chunked_list": ["from jinja2.sandbox import SandboxedEnvironment\n\tfrom yamx.constants import NON_EXISTING_STR\n\tdef get_jinja_env():\n\t    # TODO: make a singleton class\n\t    env = SandboxedEnvironment(\n\t        # variable parsing is disabled this way\n\t        variable_start_string=NON_EXISTING_STR,\n\t        variable_end_string=NON_EXISTING_STR,\n\t        # yaml parsing relies on this configuration\n\t        trim_blocks=True,\n", "        # strips leading spaces and tabs before jinja block\n\t        lstrip_blocks=True,\n\t        # keep new line at the end of the file\n\t        keep_trailing_newline=True,\n\t    )\n\t    env.filters = {}\n\t    env.globals = {}\n\t    return env\n"]}
{"filename": "yamx/containers/settings.py", "chunked_list": ["from attr import frozen\n\t@frozen\n\tclass IndentConfig:\n\t    mapping: int\n\t    sequence: int\n\t    offset: int\n"]}
{"filename": "yamx/containers/__init__.py", "chunked_list": ["from yamx.containers.data import (\n\t    Condition,\n\t    ConditionalBlock,\n\t    ConditionalData,\n\t    ConditionalGroup,\n\t    ConditionalMap,\n\t    ConditionalSeq,\n\t)\n\tfrom yamx.containers.settings import IndentConfig\n\t__all__ = [\n", "    \"ConditionalBlock\",\n\t    \"IndentConfig\",\n\t    \"Condition\",\n\t    \"RenderingContext\",\n\t    \"ConditionalGroup\",\n\t    \"ConditionalData\",\n\t    \"ConditionalMap\",\n\t    \"ConditionalSeq\",\n\t]\n"]}
{"filename": "yamx/containers/data.py", "chunked_list": ["from typing import Any, ClassVar, Optional, Tuple, Union\n\tfrom attr import evolve, frozen\n\tfrom ruamel.yaml.comments import CommentedMap, CommentedSeq\n\tfrom ruamel.yaml.tag import Tag\n\tfrom yamx.constants import (\n\t    CONDITIONAL_TAG,\n\t    DEDUPLICATOR_UPD,\n\t    YAML_MAP_TAG,\n\t    YAML_SEQ_TAG,\n\t    ConditionalBlockType,\n", ")\n\tCONDITIONAL_UPD_COUNTER: int = 0\n\t@frozen\n\tclass Condition:\n\t    raw_value: str\n\t@frozen\n\tclass CmpValue:\n\t    value: Any\n\t    def __lt__(self, other) -> bool:\n\t        if isinstance(other, ConditionalGroup):\n", "            return True\n\t        else:\n\t            return self.value < other.value\n\t@frozen\n\tclass ConditionalData:\n\t    \"\"\"Wrapper for loaded data\"\"\"\n\t    _data: Any\n\t    @property\n\t    def data(self) -> Any:\n\t        return self._data\n", "    def __getitem__(self, key) -> Any:\n\t        # TODO: assign method when ConditionalData is created dynamically\n\t        if isinstance(self._data, ConditionalMap):\n\t            return _get_from_conditional_map(self._data, key)\n\t        raise NotImplementedError()\n\t    def __setitem__(self, key, value) -> None:\n\t        if isinstance(value, ConditionalSelectionGroup):\n\t            global CONDITIONAL_UPD_COUNTER\n\t            dummy_block_key = f\"{DEDUPLICATOR_UPD}{CONDITIONAL_UPD_COUNTER}\"\n\t            self._data[dummy_block_key] = value.to_conditional_group(key)\n", "        else:\n\t            self._data[key] = value\n\tclass ConditionalMap(CommentedMap):\n\t    def __init__(self, *args, **kw):\n\t        super().__init__(*args, **kw)\n\t        tag = Tag(suffix=YAML_MAP_TAG)\n\t        self.yaml_set_ctag(tag)\n\tclass ConditionalSeq(CommentedSeq):\n\t    def __init__(self, *args, **kw) -> None:\n\t        tag = Tag(suffix=YAML_SEQ_TAG)\n", "        self.yaml_set_ctag(tag)\n\t        super().__init__(*args, **kw)\n\t@frozen\n\tclass ConditionalBlock:\n\t    yaml_tag: ClassVar[str] = CONDITIONAL_TAG\n\t    data: Any\n\t    typ: ConditionalBlockType\n\t    condition: Optional[Condition]\n\t    @classmethod\n\t    def to_yaml(cls, _, __):\n", "        raise NotImplementedError(f\"{cls.__name__} should never be dumped to yaml.\")\n\t    @classmethod\n\t    def from_yaml(cls, constructor, node):\n\t        data = CommentedMap()\n\t        constructor.construct_mapping(node, data, deep=True)\n\t        data[\"typ\"] = ConditionalBlockType(data[\"typ\"])\n\t        data[\"condition\"] = Condition(data[\"condition\"])\n\t        return cls(**data)\n\t@frozen\n\tclass ConditionalSelectionGroup:\n", "    condition: Optional[Condition]\n\t    # TODO: introduce type of conditional group/ subclassing\n\t    # TODO: support scalars\n\t    body: Any\n\t    # elif_bodies is None to identify elif nodes that have only body filled\n\t    elif_bodies: Tuple[\"ConditionalSelectionGroup\", ...] = tuple()\n\t    else_body: Any = None\n\t    def to_conditional_group(self, key: str) -> \"ConditionalGroup\":\n\t        elif_bodies = tuple(\n\t            ConditionalGroup(\n", "                body=ConditionalMap({key: elif_body.body}),\n\t                condition=elif_body.condition,\n\t            )\n\t            for elif_body in self.elif_bodies\n\t        )\n\t        return ConditionalGroup(\n\t            condition=self.condition,\n\t            body=ConditionalMap({key: self.body}),\n\t            elif_bodies=elif_bodies,\n\t            else_body=self.else_body and ConditionalMap({key: self.else_body}),\n", "        )\n\t@frozen\n\tclass ConditionalGroup:\n\t    condition: Optional[Condition]\n\t    # TODO: introduce type of conditional group/ subclassing\n\t    # TODO: support scalars\n\t    body: Union[ConditionalMap, ConditionalSeq]\n\t    # elif_bodies is None to identify elif nodes that have only body filled\n\t    elif_bodies: Tuple[\"ConditionalGroup\", ...] = tuple()\n\t    else_body: Optional[Union[ConditionalMap, ConditionalSeq]] = None\n", "    def __lt__(self, other) -> bool:\n\t        # compare by condition string\n\t        if isinstance(other, ConditionalGroup):\n\t            # we compare only \"if\" ConditionalGroup, not \"else\" (where condition can be empty)\n\t            assert self.condition is not None and other.condition is not None\n\t            return self.condition.raw_value < other.condition.raw_value\n\t        else:\n\t            return False\n\t    def with_conditional_block(\n\t        self,\n", "        data: Union[ConditionalMap, ConditionalSeq],\n\t        typ: ConditionalBlockType,\n\t        condition: Optional[Condition],\n\t    ) -> \"ConditionalGroup\":\n\t        \"\"\"Extends conditional group with new elif/else conditional blocks\"\"\"\n\t        if typ is ConditionalBlockType.elif_:\n\t            assert isinstance(self.elif_bodies, tuple)\n\t            elif_groups = self.elif_bodies + (\n\t                ConditionalGroup(body=data, condition=condition),\n\t            )\n", "            return evolve(self, elif_bodies=elif_groups)\n\t        elif typ is ConditionalBlockType.else_:\n\t            assert (\n\t                self.else_body is None\n\t            ), f\"Cannot set else_body to {self}, else_body is not empty.\"\n\t            return evolve(self, else_body=data)\n\t        else:\n\t            raise ValueError(f\"Unexpected conditional element of type {typ}\")\n\t    def __iter__(self):\n\t        \"\"\"custom iterator: captures all keys from conditional blocks as well\"\"\"\n", "        keys_set = set(self.body.keys())\n\t        for elif_block in self.elif_bodies:\n\t            keys_set.update(elif_block.keys())\n\t        if self.else_body:\n\t            keys_set.update(self.else_body.keys())\n\t        return iter(keys_set)\n\t    def __contains__(self, key: str) -> bool:\n\t        return key in iter(self)\n\t    def __getitem__(self, key: str) -> ConditionalSelectionGroup:\n\t        if key not in self:\n", "            raise KeyError(f'Key \"{key}\" was not found in conditional block')\n\t        def _get_from_body(body: ConditionalMap) -> CommentedMap:\n\t            return None if key not in body else body[key]\n\t        body = _get_from_body(self.body)\n\t        elif_bodies = tuple(\n\t            ConditionalSelectionGroup(\n\t                body=_get_from_body(elif_body.body),\n\t                condition=elif_body.condition,\n\t            )\n\t            for elif_body in self.elif_bodies\n", "        )\n\t        else_body = self.else_body and _get_from_body(self.else_body)\n\t        return ConditionalSelectionGroup(\n\t            # TODO: copy annotation from previous key-map\n\t            # TODO: support empty conditions\n\t            body=body,\n\t            elif_bodies=elif_bodies,\n\t            else_body=else_body,\n\t            condition=self.condition,\n\t        )\n", "def _get_from_conditional_map(data: ConditionalMap, key: str) -> Any:\n\t    res = None\n\t    for data_key, value in data.items():\n\t        if not isinstance(value, ConditionalGroup):\n\t            if not data_key == key:\n\t                continue\n\t            res = value\n\t            # TODO: move to validation of data structures?\n\t            # continue to validate for duplication\n\t            continue\n", "        # TODO: support key in value.keys()\n\t        try:\n\t            key_value = value[key]\n\t        except KeyError:\n\t            continue\n\t        if res is not None:\n\t            raise Exception(\"duplicate field in different conditional blocks found\")\n\t        res = key_value\n\t    return res\n"]}
{"filename": "yamx/jinja/condition.py", "chunked_list": ["from enum import Enum, auto\n\tfrom typing import Callable, Final, Mapping\n\tfrom attr import frozen\n\tfrom immutables import Map\n\tfrom jinja2 import Environment, nodes\n\tfrom jinja2.compiler import CodeGenerator, EvalContext, Frame\n\tfrom yamx.containers.data import Condition\n\tdef extract_condition(node: nodes.Test, env: Environment) -> Condition:\n\t    generator = CustomCodeGenerator(env, None, None)\n\t    eval_ctx = EvalContext(env, \"\")\n", "    frame = Frame(eval_ctx)\n\t    generator.visit(node, frame)\n\t    return Condition(generator.stream.getvalue().strip())\n\tclass CustomCodeGenerator(CodeGenerator):\n\t    \"\"\"Generator used to stringify expressions you can find inside if node\"\"\"\n\t    def write(self, x):\n\t        self.stream.write(x)\n\t    def visit_Name(self, node, frame):\n\t        self.write(node.name)\n\t    def visit_Const(self, node, frame):\n", "        if isinstance(node.value, str):\n\t            self.write('\"{}\"'.format(node.value))\n\t        else:\n\t            super().visit_Const(node, frame)\n\t    def visit_Getattr(self, node, frame):\n\t        if isinstance(node.node, nodes.Name):\n\t            self.write(node.node.name)\n\t            if isinstance(node.attr, nodes.Node):\n\t                self.write(\".\")\n\t                self.visit(node.attr, frame)\n", "            else:\n\t                self.write(\".\" + node.attr)\n\t        else:\n\t            self.visit(node.node, frame)\n\t            if isinstance(node.attr, nodes.Node):\n\t                self.write(\".\")\n\t                self.visit(node.attr, frame)\n\t            else:\n\t                self.write(\".\" + node.attr)\n\t    def visit_Call(self, node, frame):\n", "        self.visit(node.node, frame)\n\t        self.write(\"(\")\n\t        for idx, arg in enumerate(node.args):\n\t            self.visit(arg, frame)\n\t            if idx != len(node.args) - 1:\n\t                self.write(\",\")\n\t        self.write(\")\")\n\tdef _make_binop(\n\t    name: str, op: str\n\t) -> Callable[[\"CodeGenerator\", nodes.BinExpr, \"Frame\"], None]:\n", "    def visitor(self: \"CodeGenerator\", node: nodes.BinExpr, frame: Frame) -> None:\n\t        left_op = OPS_REGISTER.get(type(node.left).__name__, MAX_PREC_OP)\n\t        if (\n\t            OPS_REGISTER[name].precedence >= left_op.precedence\n\t            and left_op.typ == OpType.binary\n\t        ):\n\t            self.write(\"(\")\n\t            self.visit(node.left, frame)\n\t            self.write(\")\")\n\t        else:\n", "            self.visit(node.left, frame)\n\t        self.write(f\" {op} \")\n\t        right_op = OPS_REGISTER.get(type(node.right).__name__, MAX_PREC_OP)\n\t        if (\n\t            OPS_REGISTER[name].precedence > right_op.precedence\n\t            and right_op.typ == OpType.binary\n\t        ):\n\t            self.write(\"(\")\n\t            self.visit(node.right, frame)\n\t            self.write(\")\")\n", "        else:\n\t            self.visit(node.right, frame)\n\t    return visitor\n\tdef _make_unop(\n\t    name: str,\n\t    op: str,\n\t) -> Callable[[\"CodeGenerator\", nodes.UnaryExpr, \"Frame\"], None]:\n\t    def visitor(self: \"CodeGenerator\", node: nodes.UnaryExpr, frame: Frame) -> None:\n\t        inner_op = OPS_REGISTER.get(type(node.node).__name__, MIN_PREC_OP)\n\t        if OPS_REGISTER[name].precedence >= inner_op.precedence:\n", "            self.write(f\"{op} \")\n\t            self.visit(node.node, frame)\n\t        else:\n\t            self.write(f\"{op}(\")\n\t            self.visit(node.node, frame)\n\t            self.write(\")\")\n\t    return visitor\n\tclass OpType(Enum):\n\t    binary = auto()\n\t    unary = auto()\n", "    undefined = auto()\n\t@frozen\n\tclass Op:\n\t    name: str\n\t    typ: OpType\n\t    precedence: int\n\tMAX_PREC_OP = Op(\"\", OpType.undefined, 20)\n\tMIN_PREC_OP = Op(\"\", OpType.undefined, 0)\n\tOPS_REGISTER: Final[Mapping[str, Op]] = Map(\n\t    {\n", "        \"Pos\": Op(\"+\", OpType.unary, 1),\n\t        \"Neg\": Op(\"-\", OpType.unary, 1),\n\t        \"Add\": Op(\"+\", OpType.binary, 2),\n\t        \"Sub\": Op(\"-\", OpType.binary, 2),\n\t        \"Mul\": Op(\"*\", OpType.binary, 3),\n\t        \"Div\": Op(\"/\", OpType.binary, 3),\n\t        \"FloorDiv\": Op(\"//\", OpType.binary, 3),  # validate this\n\t        \"Pow\": Op(\"**\", OpType.binary, 3),  # validate this\n\t        \"Mod\": Op(\"%\", OpType.binary, 3),  # validate this\n\t        \"Not\": Op(\"not\", OpType.unary, 4),\n", "        \"Or\": Op(\"or\", OpType.binary, 5),\n\t        \"And\": Op(\"and\", OpType.binary, 6),\n\t    }\n\t)\n\tfor ast_node_name, op in OPS_REGISTER.items():\n\t    if op.typ == OpType.binary:\n\t        func = _make_binop\n\t    else:\n\t        assert op.typ == OpType.unary\n\t        func = _make_unop\n", "    setattr(CustomCodeGenerator, f\"visit_{ast_node_name}\", func(ast_node_name, op.name))\n"]}
{"filename": "yamx/jinja/__init__.py", "chunked_list": []}
{"filename": "yamx/representer/conditional_map.py", "chunked_list": ["from ruamel.yaml.nodes import MappingNode\n\tfrom yamx.containers.data import ConditionalMap\n\tfrom yamx.containers.settings import IndentConfig\n\tfrom yamx.representer.common import translate_conditional_map_to_commented_map\n\tdef translate_conditional_map_to_yaml(\n\t    representer, data: ConditionalMap, sort_keys: bool, indent_cfg: IndentConfig\n\t) -> MappingNode:\n\t    # yield from representer.represent_mapping(None, data)\n\t    cm = translate_conditional_map_to_commented_map(\n\t        data=data, sort_keys=sort_keys, indent_cfg=indent_cfg, indent=0\n", "    )\n\t    return representer.represent_mapping(data.tag.value, cm)\n"]}
{"filename": "yamx/representer/rendering.py", "chunked_list": ["from typing import Optional, Union\n\tfrom ruamel.yaml.comments import CommentedMap, CommentedSeq\n\tfrom ruamel.yaml.error import CommentMark\n\tfrom ruamel.yaml.tokens import CommentToken\n\tfrom yamx.constants import DEDUPLICATOR\n\tfrom yamx.containers.data import ConditionalMap\n\tUNIQUE_CNT: int = 0\n\tdef render_conditional_map(\n\t    cm: CommentedMap,\n\t    data: ConditionalMap,\n", "    before: Optional[str],\n\t    after: Optional[str],\n\t    indent: int,\n\t    sort_keys: bool,\n\t) -> CommentedMap:\n\t    \"\"\"\n\t    CommentedMap object has following comment attributes:\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@    cm.ca.comment    @@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n", "    cm.ca.comment: [comment1, [comment2, ...], [comment3, ...]] = None\n\t        Denote 3 types of comments:\n\t        1. single comment placed before first key-value and `-` if it's an item of commentedSeq,\n\t           new line is added at the end if missing.\n\t            type: Optional[CommentToken]\n\t        2. multi comment placed before first key-value and after `-` if it's an item of commentedSeq\n\t            type: Optional[List[CommentToken]]]\n\t        3. multi comment placed after all key-values of the mapping\n\t            type: Optional[List[CommentToken]]]\n\t        Let's see how it works on the example:\n", "        > cm = CommentedMap({\"first\":1, \"second\":2})\n\t        > mark = CommentMark(0) # mark represents indentation\n\t        > cm.ca.comment = [\n\t            CommentToken(\"# COMMENT1\", mark),\n\t            [CommentToken(\"# COMMENT2\\n\", mark)],\n\t            [CommentToken(\"# COMMENT3\\n\", mark)]\n\t        ]\n\t    NOTE: Rendering of the comment varies based on parent object annotation.\n\t    The reason is that during represenation `comment` attribute is propagated\n\t    to relevant `items` attribute of the parent object (see `items` comment attribute)\n", "    ====== CommentedSeq parent object =======\n\t        > yaml.dump_to_string(CommentedSeq(cm))\n\t        # COMMENT2\n\t        - # COMMENT1\n\t        first: 1\n\t        second: 2\n\t        # COMMENT3\n\t    ====== CommentedMap parent object =======\n\t        > yaml.dump_to_string(CommentedMap(map=cm))\n\t        map: # COMMENT1\n", "        # COMMENT2\n\t        first: 1\n\t        second: 2\n\t        # COMMENT3\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@     cm.ca.items     @@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\t    cm.ca.items: Dict[int, [comment1, [comment2, ...], comment3, [comment4,...]]] = {}\n\t        Denotes 4 types of comments attached to particular element of a key-value\n\t        1. single comment (new line is added at the end if missing)\n", "            position: right after key, but before `:`\n\t            type: Optional[CommentToken]\n\t        2. multi comment placed before key\n\t            type: Optional[List[CommentToken]]]\n\t        3. single comment (new line is added at the end if missing)\n\t            position: right after `:` if value is of type map or seq, otherwise after value\n\t            type: Optional[CommentToken]\n\t        4. multi comment (ignored if value is a scalar)\n\t            position: before value\n\t            type: Optional[List[CommentToken]]]\n", "        Key of ca.items dict is a key of key-value pair in a mapping\n\t        let's see how it works on following example:\n\t        > cm = CommentedMap({\"first\": 1})\n\t        > cm.ca.items[\"first\"] = [\n\t            CommentToken(\"# COMMENT1\", mark),\n\t            [CommentToken(\"# COMMENT2\\n\", mark)],\n\t            CommentToken(\"# COMMENT3\", mark),\n\t            [CommentToken(\"# COMMENT4\\n\", mark)],\n\t        ]\n\t        > outer_map = CommentedMap(outer=cm)\n", "        > print(yaml.dump_to_string(outer_map))\n\t        outer:\n\t        # COMMENT2\n\t        first # COMMENT1\n\t        : 1 # COMMENT3\n\t    NOTE: items annotation of parent object can CONFLICT with `comment` (see above)\n\t    annotation of a children:\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@@     cm.ca.end     @@@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n", "    doesn't seem to have any specific usage for CommentedMap\n\t    \"\"\"\n\t    global UNIQUE_CNT\n\t    # TODO: return if empty\n\t    if len(data) == 0:\n\t        raise NotImplementedError\n\t    # TODO: move sorting to different place\n\t    if sort_keys:\n\t        iter_data = enumerate(sorted(data.items(), key=lambda kv: kv[0]))\n\t    else:\n", "        iter_data = enumerate(data.items())\n\t    for idx, (data_key, data_value) in iter_data:\n\t        if data_key in cm:\n\t            # TODO: log proper warning + handle deduplicated keys\n\t            print(f\"warning: Duplicate '{data_key}' key encountered\")\n\t        prev_data_key = data_key\n\t        # to avoid keys duplication - adding unique suffix\n\t        if DEDUPLICATOR not in data_key:\n\t            # TODO: replace with hash of stable length\n\t            data_key = f\"{data_key}{DEDUPLICATOR}{UNIQUE_CNT}\"\n", "            UNIQUE_CNT += 1\n\t        # move prev comment annotation to cm\n\t        if prev_data_key in data.ca.items:\n\t            cm.ca.items.update({data_key: data.ca.items[prev_data_key]})\n\t        if idx == 0:\n\t            first_data_key = data_key\n\t        cm.update({data_key: data_value})\n\t    last_data_key = data_key\n\t    # when conditional block consist of multiple elements we need to\n\t    # attach before and after comment to different items\n", "    # first attaching before comment to the first added item\n\t    if before is not None:\n\t        _annotate_commented_map_scalar_item(\n\t            commented_data=cm,\n\t            data_key=first_data_key,\n\t            before=before,\n\t            after=None,\n\t            indent=indent,\n\t        )\n\t    # now attaching after comment to the last added item\n", "    if after is not None:\n\t        if isinstance(cm[last_data_key], CommentedMap):\n\t            # propagate after comment all the way to the outermost element of the structure\n\t            _set_after_map_comment(cm=cm[last_data_key], after=after, indent=indent)\n\t        elif isinstance(cm[last_data_key], CommentedSeq) and len(cm[last_data_key]):\n\t            _annotate_commented_seq_commented_item(\n\t                item=cm[last_data_key],\n\t                before=None,\n\t                after=after,\n\t                indent=indent,\n", "            )\n\t        else:\n\t            # otherwise value is a simple scalar - setting annotation on items attribute of a\n\t            # parent object\n\t            _annotate_commented_map_scalar_item(\n\t                commented_data=cm,\n\t                data_key=last_data_key,\n\t                before=None,\n\t                after=after,\n\t                indent=indent,\n", "            )\n\tdef _annotate_commented_map_scalar_item(\n\t    commented_data: Union[CommentedMap, CommentedSeq],\n\t    data_key: Union[str, int],\n\t    before: Optional[str],\n\t    after: Optional[str],\n\t    indent: int,\n\t) -> None:\n\t    \"\"\"Annotating simple scalar value\n\t    Comment annotations are attached to parent object ca.items structure\n", "    \"\"\"\n\t    # create comment tokens\n\t    mark = CommentMark(indent)\n\t    before_comment = before and CommentToken(f\"# {before}\\n\", mark)\n\t    # NOTE: comment is prefixed with new line as it is attached after value\n\t    after_comment = after and CommentToken(f\"\\n{' '*indent}# {after}\", mark)\n\t    prev_ca = commented_data.ca.items.get(data_key)\n\t    # item could be already annotated, let's extract the comments and merge them\n\t    if prev_ca:\n\t        # prepare after_comments\n", "        if after_comment and prev_ca[2]:\n\t            after_comments = _merge_comments(prev_ca[2], after_comment)\n\t        elif after_comment:\n\t            after_comments = after_comment\n\t        else:\n\t            after_comments = prev_ca[2]\n\t        # prepare before_comments\n\t        if before_comment is not None:\n\t            before_comments = [before_comment, *(prev_ca[1] or [])]\n\t        else:\n", "            before_comments = prev_ca[1]\n\t        new_ca = [\n\t            None,\n\t            before_comments,\n\t            after_comments,\n\t            None,\n\t        ]\n\t    else:\n\t        new_ca = [None, before_comment and [before_comment], after_comment, None]\n\t    commented_data.ca.items[data_key] = new_ca\n", "def _set_after_map_comment(cm, after: str, indent: int) -> None:\n\t    \"\"\"Recursively propagates after comment to the last map item\"\"\"\n\t    # in case CommentedMap is empty - attaching comment to cm.ca\n\t    mark = CommentMark(indent)\n\t    after_comment = CommentToken(f\"\\n{' '*indent}# {after}\", mark)\n\t    if len(cm) == 0:\n\t        cm.ca.comment = [after_comment, []]\n\t        return\n\t    # otherwise, propagating deeper\n\t    last_map_key = next(reversed(cm))\n", "    if isinstance(cm[last_map_key], CommentedMap):\n\t        _set_after_map_comment(cm[last_map_key], after, indent=indent)\n\t    elif isinstance(cm[last_map_key], CommentedSeq) and len(cm[last_map_key]):\n\t        _annotate_commented_seq_commented_item(\n\t            item=cm[last_map_key],\n\t            before=None,\n\t            after=after,\n\t            indent=indent,\n\t        )\n\t    else:\n", "        try:\n\t            cm.ca.items[last_map_key][2] = _merge_comments(\n\t                cm.ca.items[last_map_key][2], after_comment\n\t            )\n\t        except KeyError:\n\t            cm.ca.items[last_map_key] = [None, None, after_comment, None]\n\tdef _merge_comments(comment1: CommentToken, comment2: CommentToken) -> CommentToken:\n\t    \"\"\"Used to merge 2 comments into a single CommentToken object\n\t    NOTE: only single-line comments are supported\n\t    \"\"\"\n", "    assert comment1.value.startswith(\"\\n\")\n\t    assert comment2.value.startswith(\"\\n\")\n\t    indent = min(comment1.column, comment2.column)\n\t    mark = CommentMark(indent)\n\t    return CommentToken(\n\t        f\"{comment1.value}{comment2.value}\",\n\t        mark,\n\t    )\n\tdef render_conditional_seq(\n\t    cs: CommentedSeq,\n", "    data: CommentedSeq,\n\t    before: Optional[str],\n\t    after: Optional[str],\n\t    indent: int,\n\t) -> None:\n\t    \"\"\"\n\t    CommentedSeq object has following comment attributes:\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@    cs.ca.comment    @@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n", "    cs.ca.comment: [comment1, [comment2, ...], [comment3, ...]] = None\n\t        Denote 3 types of comments:\n\t        1. single comment placed right before `-` sign (new line is added at the end if missing)\n\t            type: Optional[CommentToken]\n\t        2. multi comment placed right after `-` sign\n\t            type: Optional[List[CommentToken]]]\n\t        3. multi comment placed after all elements of the sequence\n\t            type: Optional[List[CommentToken]]]\n\t            note: comment is placed only in case of non empty sequence\n\t        Let's see how it works on the example:\n", "        > cs = CommentedSeq([1,2])\n\t        > mark = CommentMark(0) # mark represents indentation\n\t        > cs.ca.comment = [\n\t            CommentToken(\"# COMMENT1\", mark),\n\t            [CommentToken(\"# COMMENT2\\n\", mark)],\n\t            [CommentToken(\"# COMMENT3\\n\", mark)]\n\t        ]\n\t    NOTE: Rendering of the comment varies based parent object annotation.\n\t    The reason is that during represenation `comment` attribute is propagated\n\t    to relevant `items` attribute of the parent object (see `items` comment attribute)\n", "    ====== CommentedSeq parent object =======\n\t        > yaml.dump_to_string(CommentedSeq(cs))\n\t        # COMMENT2\n\t        - # COMMENT1\n\t            - 1\n\t            - 2\n\t        # COMMENT3\n\t    ====== CommentedMap parent object =======\n\t        > yaml.dump_to_string(CommentedMap(list=cs))\n\t        list: # COMMENT1\n", "        # COMMENT2\n\t        - 1\n\t        - 2\n\t        # COMMENT3\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@     cs.ca.items     @@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\t    cs.ca.items: Dict[int, [comment1, [comment2, ...]]] = {}\n\t        Denotes 2 types of comments attached to particular element of a sequence\n\t        1. single comment placed after seq item value\n", "            type: Optional[CommentToken]\n\t        2. multi comment placed before `-` sign (new line is added at the end if missing)\n\t            type: Optional[List[CommentToken]]]\n\t        Key of ca.items dict is an index of an element in the list\n\t        let's see how it works on the example:\n\t        > cs = CommentedSeq([1])\n\t        > cs.ca.items[0] = [\n\t            CommentToken(\"# COMMENT1\", mark),\n\t            [CommentToken(\"# COMMENT2\\n\", mark)],\n\t        ]\n", "        > yaml.dump_to_string(CommentedSeq(cs))\n\t        # COMMENT2\n\t        - 1 # COMMENT1\n\t    NOTE: items annotation of parent object can CONFLICT with `comment` (see above)\n\t    and `end` (see below) annotations of a children:\n\t    If parent object has defined `items` annotation for particular element - following applies:\n\t    1. Any item annotation from a parent object make representer ignore 3rd comment of children\n\t    cs.ca.comment annotation\n\t        > cs = CommentedSeq([1,2])\n\t        > mark = CommentMark(0) # mark represents indentation\n", "        > cs.ca.comment = [\n\t            CommentToken(\"# COMMENT1\", mark),\n\t            [CommentToken(\"# COMMENT2\\n\", mark)],\n\t            [CommentToken(\"# COMMENT3\\n\", mark)]\n\t        ]\n\t        parent_cs = CommentedSeq([cs])\n\t        parent_cs.items[0] = [None, None]\n\t        > yaml.dump_to_string(parent_cs)\n\t        # COMMENT2\n\t        - # COMMENT1\n", "            - 1\n\t    2. Once commented structure is representer certain modifications are happening to\n\t        annotated structure:\n\t        * comment1 of cs.comment anntotation is propagated to comment1 annotation\n\t            of parent_cs.items[0]\n\t        * the same logic applies to comment2 of cs.comment and parent_cs.items[0] respectively\n\t            NOTE: Propagation is only happening to parent structure, not to the children\n\t            NOTE: Propagation doesn't happen if parent_cs.items[0] is not defined\n\t            NOTE: If both comments of parent_cs and cs are defined when attepmt to represent\n\t                    a structure ASSERTION error is raised\n", "    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@@     cs.ca.end     @@@@@@@@@@@@@@\n\t    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\t    doesn't seem to have any specific usage for CommentedSeq\n\t    \"\"\"\n\t    first_item_pos = len(cs)\n\t    last_item_pos = first_item_pos + len(data) - 1\n\t    assert first_item_pos <= last_item_pos\n\t    # NOTE: extend method will shift comment annotation of all comments with\n\t    # ids higher than last element - we should extend first, annotate after\n", "    cs.extend(data)\n\t    # now we can extend cs.ca with annotation of newly added items\n\t    # in order to do that we need to shift all indices by len of cs\n\t    cs.ca.items.update(\n\t        {first_item_pos + key: comment for key, comment in data.ca.items.items()}\n\t    )\n\t    # when conditional block consists of multiple elements we need to\n\t    # attach before and after comment to different items\n\t    # first attaching before comment to the first added item\n\t    if before is not None:\n", "        if isinstance(cs[first_item_pos], CommentedMap):\n\t            _annotate_commented_map_scalar_item(\n\t                commented_data=cs,\n\t                data_key=first_item_pos,\n\t                before=before,\n\t                after=None,\n\t                indent=indent,\n\t            )\n\t        elif isinstance(cs[first_item_pos], CommentedSeq):\n\t            _annotate_commented_seq_commented_item(\n", "                item=cs[first_item_pos],\n\t                before=before,\n\t                after=None,\n\t                indent=indent,\n\t            )\n\t        else:\n\t            # otherwise item is a simple scalar - setting annotation on items attribute of a\n\t            # parent object\n\t            _annotate_commented_seq_scalar_item(\n\t                cs=cs,\n", "                item_idx=first_item_pos,\n\t                before=before,\n\t                after=None,\n\t                indent=indent,\n\t            )\n\t    # now attaching after comment to the last added item\n\t    if after is not None:\n\t        if isinstance(cs[last_item_pos], CommentedMap):\n\t            _set_after_map_comment(cm=cs[last_item_pos], after=after, indent=indent)\n\t        elif isinstance(cs[last_item_pos], CommentedSeq) and len(cs[last_item_pos]):\n", "            _annotate_commented_seq_commented_item(\n\t                item=cs[last_item_pos],\n\t                before=None,\n\t                after=after,\n\t                indent=indent,\n\t            )\n\t        else:\n\t            # otherwise item is a simple scalar - setting annotation on items attribute of a\n\t            # parent object\n\t            _annotate_commented_seq_scalar_item(\n", "                cs=cs,\n\t                item_idx=last_item_pos,\n\t                before=None,\n\t                after=after,\n\t                indent=indent,\n\t            )\n\tdef _annotate_commented_seq_commented_item(\n\t    item: CommentedSeq, before: Optional[str], after: Optional[str], indent: int\n\t) -> None:\n\t    \"\"\"Annotating commented values\n", "    Comment annotations are attached to actual item object ca.comment structure\n\t    \"\"\"\n\t    mark = CommentMark(indent)\n\t    # create comment tokens\n\t    before_comment = before and [CommentToken(f\"# {before}\\n\", mark)]\n\t    after_comment = after and [CommentToken(f\"# {after}\\n\", mark)]\n\t    # item could be already annotated, let's extract the comments and merge them\n\t    if prev_ca := item.ca.comment:\n\t        new_ca = [\n\t            None,\n", "            # merge comments into list if it's not None\n\t            ((before_comment or []) + (prev_ca[1] or [])) or None,\n\t            ((prev_ca[2] or []) + (after_comment or [])) or None,\n\t        ]\n\t    else:\n\t        new_ca = [\n\t            None,\n\t            # put comments into list if it's not None\n\t            before_comment,\n\t            after_comment,\n", "        ]\n\t    item.ca.comment = new_ca\n\tdef _annotate_commented_seq_scalar_item(\n\t    cs: CommentedSeq,\n\t    item_idx: int,\n\t    before: Optional[str],\n\t    after: Optional[str],\n\t    indent: int,\n\t) -> None:\n\t    \"\"\"Annotating simple scalar value\n", "    Comment annotations are attached to parent object ca.items structure\n\t    \"\"\"\n\t    # create comment tokens\n\t    mark = CommentMark(indent)\n\t    before_comment = before and CommentToken(f\"# {before}\\n\", mark)\n\t    # NOTE: comment is prefixed with new line as it is attached after value\n\t    after_comment = after and CommentToken(f\"\\n{' '*indent}# {after}\", mark)\n\t    prev_ca = cs.ca.items.get(item_idx)\n\t    # item could be already annotated, let's extract the comments and merge them\n\t    if prev_ca:\n", "        # prepare after_comments\n\t        if after_comment and prev_ca[0]:\n\t            after_comments = _merge_comments(prev_ca[0], after_comment)\n\t        elif after_comment:\n\t            after_comments = after_comment\n\t        else:\n\t            after_comments = prev_ca[0]\n\t        # prepare before_comments\n\t        if before_comment is not None:\n\t            before_comments = [before_comment, *(prev_ca[1] or [])]\n", "        else:\n\t            before_comments = prev_ca[1]\n\t        new_ca = [\n\t            after_comments,\n\t            before_comments,\n\t        ]\n\t    else:\n\t        new_ca = [after_comment, before_comment and [before_comment]]\n\t    cs.ca.items[item_idx] = new_ca\n"]}
{"filename": "yamx/representer/__init__.py", "chunked_list": ["from yamx.representer.conditional_map import translate_conditional_map_to_yaml\n\tfrom yamx.representer.conditional_seq import translate_conditional_seq_to_yaml\n\t__all__ = [\"translate_conditional_map_to_yaml\", \"translate_conditional_seq_to_yaml\"]\n"]}
{"filename": "yamx/representer/conditional_seq.py", "chunked_list": ["from ruamel.yaml.nodes import SequenceNode\n\tfrom yamx.containers.data import ConditionalMap\n\tfrom yamx.containers.settings import IndentConfig\n\tfrom yamx.representer.common import translate_conditional_seq_to_commented_seq\n\tdef translate_conditional_seq_to_yaml(\n\t    representer, data: ConditionalMap, sort_keys: bool, indent_cfg: IndentConfig\n\t) -> SequenceNode:\n\t    cs = translate_conditional_seq_to_commented_seq(\n\t        data=data,\n\t        sort_keys=sort_keys,\n", "        indent_cfg=indent_cfg,\n\t        indent=0,\n\t    )\n\t    return representer.represent_sequence(data.tag.value, cs)\n"]}
{"filename": "yamx/representer/common.py", "chunked_list": ["from collections import OrderedDict\n\tfrom typing import Any, Dict, List, Optional, Tuple, Union\n\tfrom ruamel.yaml.comments import CommentedMap, CommentedSeq\n\tfrom yamx.constants import (\n\t    ELIF_CONDITION_TEMPLATE,\n\t    ELSE_COMMENT,\n\t    ENDIF_COMMENT,\n\t    IF_CONDITION_TEMPLATE,\n\t)\n\tfrom yamx.containers.data import (\n", "    CmpValue,\n\t    ConditionalGroup,\n\t    ConditionalMap,\n\t    ConditionalSeq,\n\t)\n\tfrom yamx.containers.settings import IndentConfig\n\tfrom yamx.representer.rendering import render_conditional_map, render_conditional_seq\n\tdef translate_conditional_map_to_commented_map(\n\t    data: ConditionalMap,\n\t    sort_keys: bool,\n", "    indent_cfg: IndentConfig,\n\t    indent: int,\n\t) -> CommentedMap:\n\t    \"\"\"NOTE: rendering of comments is happening inside->out\n\t    first renders inner-most nested structure\n\t    \"\"\"\n\t    if len(data) == 0:\n\t        # TODO: preserve comments\n\t        return CommentedMap()\n\t    # storing all items\n", "    # TODO: move sorting outside of translation\n\t    if sort_keys:\n\t        sorted_data = OrderedDict(\n\t            sorted(\n\t                data.items(),\n\t                key=lambda i: i[1]\n\t                if isinstance(i[1], ConditionalGroup)\n\t                else CmpValue(i[0]),\n\t            )\n\t        )\n", "        new_data = ConditionalMap()\n\t        new_data.update(sorted_data)\n\t        data.copy_attributes(data)\n\t    else:\n\t        new_data = data\n\t    cm = _render_map_comments(\n\t        data=new_data,\n\t        indent=indent,\n\t        indent_cfg=indent_cfg,\n\t        sort_keys=sort_keys,\n", "    )\n\t    return cm\n\tdef _render_map_comments(\n\t    data: ConditionalMap, indent: int, indent_cfg: IndentConfig, **kwargs\n\t) -> CommentedMap:\n\t    \"\"\"\n\t    Converts ConditionalMap structure into CommentedMap\n\t    rendering all sequence comment\n\t    kwargs contain parameters used to recursively render inner structures\n\t    such as:\n", "    :param sort_keys: {bool}\n\t    \"\"\"\n\t    cm = CommentedMap()\n\t    conditional_kwargs: Dict[str, Any] = {\n\t        \"indent\": indent,\n\t        \"indent_cfg\": indent_cfg,\n\t        **kwargs,\n\t    }\n\t    for key, value in data.items():\n\t        if not isinstance(value, ConditionalGroup):\n", "            # translate inner Conditional objects first\n\t            if isinstance(value, ConditionalMap):\n\t                # add extra indentation for inner map structures\n\t                value = translate_conditional_map_to_commented_map(\n\t                    data=value,\n\t                    indent=indent + indent_cfg.mapping,\n\t                    indent_cfg=indent_cfg,\n\t                    **kwargs,\n\t                )\n\t            elif isinstance(value, ConditionalSeq):\n", "                # don't increase indent for sequence within map, as comments\n\t                # are rendered on the same level\n\t                value = translate_conditional_seq_to_commented_seq(\n\t                    data=value, indent=indent, indent_cfg=indent_cfg, **kwargs\n\t                )\n\t            cm[key] = value\n\t            continue\n\t        conditional_group = value\n\t        # only else groups have undefined condition\n\t        assert conditional_group.condition is not None\n", "        if_comment = IF_CONDITION_TEMPLATE.format(conditional_group.condition.raw_value)\n\t        to_render: List[\n\t            Tuple[Union[ConditionalMap, ConditionalSeq], Optional[str], Optional[str]]\n\t        ] = []\n\t        # in case we have only if body\n\t        if conditional_group.else_body is None and not conditional_group.elif_bodies:\n\t            # TODO: create nice wrapper for this structure of\n\t            # tuple(data, comment_before, comment_after)\n\t            to_render.append((conditional_group.body, if_comment, ENDIF_COMMENT))\n\t        else:\n", "            to_render.append((conditional_group.body, if_comment, None))\n\t        # render elif blocks\n\t        elif_bodies_count = len(conditional_group.elif_bodies)\n\t        for idx, elif_body in enumerate(conditional_group.elif_bodies):\n\t            assert elif_body.condition is not None\n\t            before_comment = ELIF_CONDITION_TEMPLATE.format(\n\t                elif_body.condition.raw_value\n\t            )\n\t            # set after comment based if it's last elif block and\n\t            # there is no else statement in the conditional group\n", "            if (idx == elif_bodies_count - 1) and conditional_group.else_body is None:\n\t                after_comment = ENDIF_COMMENT\n\t            else:\n\t                after_comment = None\n\t            to_render.append((elif_body.body, before_comment, after_comment))\n\t        if conditional_group.else_body:\n\t            to_render.append((conditional_group.else_body, ELSE_COMMENT, ENDIF_COMMENT))\n\t        # render all conditional group blocks\n\t        for (data, before, after) in to_render:\n\t            # resolve all inner structures first\n", "            resolved_data = translate_conditional_map_to_commented_map(\n\t                data=data, **conditional_kwargs\n\t            )\n\t            # render comment on original CommentedSeq and CommentedMap objects\n\t            render_conditional_map(\n\t                cm,\n\t                data=resolved_data,\n\t                before=before,\n\t                after=after,\n\t                indent=indent,\n", "                sort_keys=kwargs[\"sort_keys\"],\n\t            )\n\t    return cm\n\tdef translate_conditional_seq_to_commented_seq(\n\t    data: ConditionalSeq,\n\t    sort_keys: bool,\n\t    indent_cfg: IndentConfig,\n\t    indent: int,\n\t) -> CommentedMap:\n\t    \"\"\"NOTE: rendering of comments is happening inside->out\n", "    first renders inner-most nested structure\n\t    \"\"\"\n\t    if not len(data):\n\t        return CommentedSeq()\n\t    # adjusting extra indentation caused by artificially created structures\n\t    cs = _render_seq_comments(\n\t        data=data, indent=indent, indent_cfg=indent_cfg, sort_keys=sort_keys\n\t    )\n\t    return cs\n\tdef _render_seq_comments(\n", "    data: ConditionalSeq, indent: int, indent_cfg: IndentConfig, **kwargs\n\t) -> CommentedSeq:\n\t    \"\"\"\n\t    Converts ConditionalSeq structure into CommentedSeq\n\t    rendering all sequence comment\n\t    kwargs contain parameters used to recursively render inner structures\n\t    such as:\n\t    :param sort_keys: {bool}\n\t    \"\"\"\n\t    cs = CommentedSeq()\n", "    conditional_kwargs: Dict[str, Any] = {\n\t        \"indent\": indent,\n\t        \"indent_cfg\": indent_cfg,\n\t        **kwargs,\n\t    }\n\t    for item in data:\n\t        if not isinstance(item, ConditionalGroup):\n\t            # TODO: propagate original comments\n\t            if isinstance(item, ConditionalMap):\n\t                # add extra indentation for inner map structures\n", "                item = translate_conditional_map_to_commented_map(\n\t                    data=item,\n\t                    indent=indent + indent_cfg.mapping,\n\t                    indent_cfg=indent_cfg,\n\t                    **kwargs,\n\t                )\n\t            elif isinstance(item, ConditionalSeq):\n\t                # add extra indentation for inner seq structures\n\t                item = translate_conditional_seq_to_commented_seq(\n\t                    data=item,\n", "                    indent=indent + indent_cfg.sequence,\n\t                    indent_cfg=indent_cfg,\n\t                    **kwargs,\n\t                )\n\t            cs.append(item)\n\t            continue\n\t        conditional_group = item\n\t        # only else groups have undefined condition\n\t        assert conditional_group.condition is not None\n\t        if_comment = IF_CONDITION_TEMPLATE.format(conditional_group.condition.raw_value)\n", "        to_render: List[\n\t            Tuple[Union[ConditionalMap, ConditionalSeq], Optional[str], Optional[str]]\n\t        ] = []\n\t        # in case we have only if body\n\t        if conditional_group.else_body is None and not conditional_group.elif_bodies:\n\t            # TODO: create nice wrapper for this structure of\n\t            # tuple(data, comment_before, comment_after)\n\t            to_render.append((conditional_group.body, if_comment, ENDIF_COMMENT))\n\t        else:\n\t            to_render.append((conditional_group.body, if_comment, None))\n", "        # render elif blocks\n\t        assert conditional_group.elif_bodies is not None\n\t        elif_bodies_count = len(conditional_group.elif_bodies)\n\t        for idx, elif_body in enumerate(conditional_group.elif_bodies):\n\t            assert elif_body.condition is not None\n\t            before_comment = ELIF_CONDITION_TEMPLATE.format(\n\t                elif_body.condition.raw_value\n\t            )\n\t            # set after comment if it's last elif block and else block is\n\t            # not present in the conditional group\n", "            if (idx == elif_bodies_count - 1) and conditional_group.else_body is None:\n\t                after_comment = ENDIF_COMMENT\n\t            else:\n\t                after_comment = None\n\t            to_render.append((elif_body.body, before_comment, after_comment))\n\t        # render else comment if exists\n\t        if conditional_group.else_body:\n\t            to_render.append((conditional_group.else_body, ELSE_COMMENT, ENDIF_COMMENT))\n\t        # TODO: merge with map processing\n\t        # render all conditional group blocks\n", "        for (data, before, after) in to_render:\n\t            # resolve all inner structures first\n\t            resolved_data = translate_conditional_seq_to_commented_seq(\n\t                data=data, **conditional_kwargs\n\t            )\n\t            render_conditional_seq(\n\t                cs,\n\t                data=resolved_data,\n\t                before=before,\n\t                after=after,\n", "                # adding extra indent based on the offset of seq items\n\t                indent=indent + indent_cfg.offset,\n\t            )\n\t    return cs\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/integration/test_getter.py", "chunked_list": ["import io\n\timport pytest\n\tfrom yamx import YAMX\n\tfrom yamx.containers.data import ConditionalData, ConditionalMap\n\t@pytest.mark.parametrize(\n\t    \"original,selection,expected\",\n\t    [\n\t        (\n\t            {},\n\t            \"\"\"\n", "field: 1\n\t{% if True %}\n\tfield2: 1\n\tfield3: 3\n\t{% else %}\n\tfield2: 2\n\t{% endif %}\n\t\"\"\",\n\t            \"\"\"\n\t# {% if True %}\n", "field3: 1\n\t# {% else %}\n\tfield3: 2\n\t# {% endif %}\"\"\",\n\t        ),\n\t        (\n\t            {\"field\": 0},\n\t            \"\"\"\n\tfield: 1\n\t{% if True %}\n", "field2: 1\n\tfield3: 3\n\t{% else %}\n\tfield2: 2\n\t{% endif %}\n\t\"\"\",\n\t            \"\"\"\n\tfield: 0\n\t# {% if True %}\n\tfield3: 1\n", "# {% else %}\n\tfield3: 2\n\t# {% endif %}\"\"\",\n\t        ),\n\t    ],\n\t)\n\tdef test_map_update_with_selection(original, selection, expected):\n\t    res_data = ConditionalData(ConditionalMap(original))\n\t    yamx = YAMX()\n\t    with io.StringIO(selection.lstrip(\"\\n\")) as input_stream:\n", "        data = yamx.load(input_stream)\n\t    res_data[\"field3\"] = data[\"field2\"]\n\t    res = yamx.dump_to_string(res_data)\n\t    assert res == expected.lstrip()\n"]}
{"filename": "tests/integration/__init__.py", "chunked_list": []}
{"filename": "tests/integration/test_extra.py", "chunked_list": ["import io\n\timport pytest\n\tfrom yamx import YAMX\n\tfrom yamx.extra import extract_toggles\n\t@pytest.mark.parametrize(\n\t    \"raw_config, expected_toggles\",\n\t    [\n\t        (\"\", []),\n\t        # list toggles\n\t        (\n", "            \"\"\"\n\t- []\n\t# {% if defines.get(\"toggle_a\") %}\n\t- value2\n\t- value3\n\t# {% endif %}\"\"\",\n\t            [\"toggle_a\"],\n\t        ),\n\t        # root level toggle\n\t        (\n", "            \"\"\"\n\tfield: []\n\t# {% if defines.get(\"toggle_a\") %}\n\tfield2: value2\n\tfield3: value3\n\t# {% endif %}\"\"\",\n\t            [\"toggle_a\"],\n\t        ),\n\t        # toggle deep in the structure\n\t        (\n", "            \"\"\"\n\tmapping:\n\t  field: []\n\t  # {% if defines.get(\"toggle_a\") %}\n\t  field2: value2\n\t  field3: value3\n\t  # {% else %}\n\t  field2: []\n\t  field3: []\n\t  # {% endif %}\"\"\",\n", "            [\"toggle_a\"],\n\t        ),\n\t        # many toggles\n\t        (\n\t            \"\"\"\n\tmapping:\n\t  field: []\n\t  # {% if defines.get(\"toggle_a\") %}\n\t  field2: value2\n\t  field3: value3\n", "  # {% endif %}\n\tlist:\n\t# {% if defines.get(\"toggle_b\") %}\n\t- 1\n\t# {% else %}\n\t- 2\n\t# {% endif %}\"\"\",\n\t            [\"toggle_a\", \"toggle_b\"],\n\t        ),\n\t        # elif toggles\n", "        (\n\t            \"\"\"\n\tmapping:\n\t  field: []\n\t  # {% if defines.get(\"toggle_a\") %}\n\t  field2: value2\n\t  # {% elif defines.get(\"toggle_b\") %}\n\t  field3: value3\n\t  # {% endif %}\n\tlist:\n", "# {% if defines.get(\"toggle_c\") %}\n\t- 1\n\t# {% elif defines.get(\"toggle_d\") %}\n\t- 2\n\t# {% endif %}\"\"\",\n\t            [\"toggle_a\", \"toggle_b\", \"toggle_c\", \"toggle_d\"],\n\t        ),\n\t    ],\n\t)\n\tdef test_toggle_extraction(raw_config, expected_toggles):\n", "    # remove leading newline\n\t    raw_config = raw_config.lstrip(\"\\n\")\n\t    cyaml = YAMX(sort_keys=False)\n\t    with io.StringIO(raw_config) as input_stream:\n\t        data = cyaml.load(input_stream)\n\t    assert extract_toggles(data.data) == set(expected_toggles)\n"]}
{"filename": "tests/integration/test_yamx.py", "chunked_list": ["import io\n\tfrom typing import Optional\n\timport pytest\n\tfrom yamx import YAMX\n\tdef _load_dump_and_compare(yaml, raw_data: str, expected: Optional[str] = None):\n\t    # remove leading newline\n\t    raw_data = raw_data.lstrip(\"\\n\")\n\t    # load\n\t    with io.StringIO(raw_data) as input_stream:\n\t        data = yaml.load(input_stream)\n", "    # dump\n\t    final_config = yaml.dump_to_string(data, add_final_eol=True)\n\t    # compare\n\t    if expected:\n\t        expected = expected.lstrip(\"\\n\")\n\t        assert final_config == expected\n\t    else:\n\t        assert final_config == raw_data\n\t@pytest.mark.parametrize(\n\t    \"raw_config\",\n", "    [\n\t        ##############\n\t        # MAP TOGGLE #\n\t        ##############\n\t        # simple data structures without toggles\n\t        \"\"\"\n\tmapping: value\n\t\"\"\",\n\t        \"\"\"\n\tlist:\n", "- value\n\t\"\"\",\n\t        \"\"\"\n\tmapping:\n\t  list:\n\t  - value\n\t\"\"\",\n\t        \"\"\"\n\tlist:\n\t- mapping: value\n", "\"\"\",\n\t        # mapping fields | single if toggle | single simple mapping value\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field1: value2\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if not toggle | single simple mapping value\n", "        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if not defines.get(\"toggle_value\") %}\n\t  field1: value2\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if toggle | multiple simple mapping values\n\t        \"\"\"\n\tmapping:\n", "  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field1: value2\n\t  field2: value3\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if toggle | single complex mapping value (map-map)\n\t        \"\"\"\n\tmapping:\n\t  field: value\n", "  # {% if defines.get(\"toggle_value\") %}\n\t  field1:\n\t    nested_mapping: value2\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if toggle | multiple complex mapping values (map-map)\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n", "  field1:\n\t    nested_mapping: value2\n\t  field2:\n\t    nested_mapping:\n\t      nested_mapping: value3\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if toggle | single complex mapping value (list)\n\t        \"\"\"\n\tmapping:\n", "  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field1:\n\t  - value2\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if toggle | single complex mapping value (list-list)\n\t        \"\"\"\n\tmapping:\n\t  field: value\n", "  # {% if defines.get(\"toggle_value\") %}\n\t  field2:\n\t  - - value3\n\t    - value4\n\t  - - value5\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if toggle | multiple complex mapping value (list/list-map-list)\n\t        \"\"\"\n\tmapping:\n", "  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field1:\n\t  - value2\n\t  field2:\n\t  - nested_list:\n\t    - value3\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if toggle | multiple complex mapping value (list-map/map-list)\n", "        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field1:\n\t  - mapping: value2\n\t  field2:\n\t    map:\n\t    - value3\n\t  # {% endif %}\n", "\"\"\",\n\t        # mapping fields | single if toggle | multiple complex mapping value (list-list/map-map)\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field1:\n\t  - - value2\n\t    - value3\n\t  field2:\n", "    map: value3\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if toggle | multiple complex mapping value (map-map/list-list)\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field2:\n\t    map: value3\n", "  field1:\n\t  - - value2\n\t    - value3\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if/else toggle | single simple map\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n", "  field2: value2\n\t  # {% else %}\n\t  field2: value3\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if not/else toggle | single simple map\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if not defines.get(\"toggle_value\") %}\n", "  field2: value2\n\t  # {% else %}\n\t  field2: value3\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if/else toggle | single simple list\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n", "  field2:\n\t  - value2\n\t  # {% else %}\n\t  field2:\n\t  - value3\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if/else toggle | single complex map\n\t        \"\"\"\n\tmapping:\n", "  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field2:\n\t    nested_mapping:\n\t      nested_mapping: value2\n\t  # {% else %}\n\t  field2:\n\t    nested_mapping:\n\t      nested_mapping: value3\n\t  # {% endif %}\n", "\"\"\",\n\t        # mapping fields | single if/else toggle | single complex list\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field2:\n\t  - - - value2\n\t      - value3\n\t  - value4\n", "  - - value5\n\t  # {% else %}\n\t  field2:\n\t  - - value6\n\t    - value7\n\t  - - - value8\n\t      - value9\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if/else toggle | multiple simple map\n", "        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field2: value2\n\t  field3: value3\n\t  field4: value4\n\t  # {% else %}\n\t  field2: value5\n\t  field3: value6\n", "  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if/else toggle | multiple simple list\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field2:\n\t  - value2\n\t  - value3\n", "  field3:\n\t  - value4\n\t  # {% else %}\n\t  field2:\n\t  - value5\n\t  - value6\n\t  field3:\n\t  - value7\n\t  - value8\n\t  # {% endif %}\n", "\"\"\",\n\t        # mapping fields | single if/else toggle | multiple complex mapping\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field2:\n\t    nested_mapping: value2\n\t  field3:\n\t    nested_mapping:\n", "      nested_mapping: value3\n\t  # {% else %}\n\t  field2:\n\t    nested_mapping:\n\t      nested_mapping: value4\n\t  field3:\n\t    nested_mapping: value5\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if/else toggle | multiple complex list\n", "        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field2:\n\t  - - - value2\n\t      - value3\n\t  - value4\n\t  - - value5\n\t  field3:\n", "  - - - value6\n\t      - value7\n\t  - - value8\n\t    - value9\n\t  # {% else %}\n\t  field2:\n\t  - - - value10\n\t      - value11\n\t  - value12\n\t  - - value13\n", "  field3:\n\t  - - - value14\n\t      - value15\n\t  - - value16\n\t    - value17\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if/else toggle | multiple simple list-map\n\t        \"\"\"\n\tmapping:\n", "  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field2: value2\n\t  field3:\n\t  - value3\n\t  - value4\n\t  # {% else %}\n\t  field2:\n\t  - value5\n\t  - value6\n", "  field3: value7\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping fields | single if/else toggle | multiple complex list-map\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field2:\n\t    nested_mapping: value2\n", "  field3:\n\t  - - value3\n\t    - value4\n\t  # {% else %}\n\t  field2:\n\t  - - - value5\n\t    - - value6\n\t  field3:\n\t    nested_mapping: value3\n\t  # {% endif %}\n", "\"\"\",\n\t        ###############\n\t        # LIST TOGGLE #\n\t        ###############\n\t        # list fields | single if toggle | single simple list value\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- value2\n", "# {% endif %}\n\t\"\"\",\n\t        # list fields | single if toggle | multiple simple list values\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- value2\n\t- value3\n\t# {% endif %}\n", "\"\"\",\n\t        # list fields | single if not toggle | multiple simple list values\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if not defines.get(\"toggle_value\") %}\n\t- value2\n\t- value3\n\t# {% endif %}\n\t\"\"\",\n", "        # list fields | single if toggle | single complex list values\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- - - value2\n\t  - - value3\n\t  - value4\n\t# {% endif %}\n\t\"\"\",\n", "        # list fields | single if toggle | multiple complex list values\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- - - value2\n\t  - - value3\n\t  - value4\n\t- - value5\n\t  - - value6\n", "    - value7\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if toggle | single simple mapping value\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- field1: value2\n\t# {% endif %}\n", "\"\"\",\n\t        # list fields | single if toggle | multiple simple mapping value\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- field1: value2\n\t- field2: value3\n\t# {% endif %}\n\t\"\"\",\n", "        # list fields | single if toggle | single complex mapping value\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- field1:\n\t    nested_mapping: value2\n\t    nested_mapping2:\n\t      nested_mapping: value3\n\t# {% endif %}\n", "\"\"\",\n\t        # list fields | single if toggle | multiple complex mapping value\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- field1:\n\t    nested_mapping: value2\n\t    nested_mapping2:\n\t      nested_mapping: value3\n", "- field2:\n\t    nested_mapping2:\n\t      nested_mapping: value3\n\t    nested_mapping: value2\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if toggle | multiple complex mapping-lists\n\t        \"\"\"\n\tlist:\n\t- value\n", "# {% if defines.get(\"toggle_value\") %}\n\t- field1:\n\t    nested_mapping:\n\t      nested_mapping: value2\n\t    nested_mapping2:\n\t    - - value3\n\t      - value4\n\t    - value5\n\t- - nested_mapping2:\n\t      nested_mapping: value6\n", "    nested_mapping: value7\n\t  - value8\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if/else toggle | single simple value\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- value2\n", "# {% else %}\n\t- value3\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if not/else toggle | single simple value\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if not defines.get(\"toggle_value\") %}\n\t- value2\n", "# {% else %}\n\t- value3\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if/else toggle | multiple simple value\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- value2\n", "- value3\n\t# {% else %}\n\t- value4\n\t- value5\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if/else toggle | single simple list\n\t        \"\"\"\n\tlist:\n\t- value\n", "# {% if defines.get(\"toggle_value\") %}\n\t- - value2\n\t  - value3\n\t# {% else %}\n\t- - value4\n\t  - value5\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if/else toggle | multiple simple list\n\t        \"\"\"\n", "list:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- - value2\n\t  - value3\n\t- - value4\n\t  - value5\n\t  - value6\n\t# {% else %}\n\t- - value7\n", "- - value8\n\t  - value9\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if/else toggle | single simple map\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- field: value2\n", "# {% else %}\n\t- field: value3\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if/else toggle | multiple simple map\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- field: value2\n", "- field2: value3\n\t# {% else %}\n\t- field: value4\n\t- field2: value5\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if/else toggle | single complex map\n\t        \"\"\"\n\tlist:\n\t- value\n", "# {% if defines.get(\"toggle_value\") %}\n\t- field2:\n\t    nested_mapping1: value2\n\t    nested_mapping2:\n\t      nested_mapping: value3\n\t# {% else %}\n\t- field2:\n\t    nested_mapping2:\n\t      nested_mapping: value4\n\t    nested_mapping1: value5\n", "# {% endif %}\n\t\"\"\",\n\t        # list fields | single if/else toggle | multiple complex map\n\t        \"\"\"\n\tlist:\n\t- value\n\t# {% if defines.get(\"toggle_value\") %}\n\t- field2:\n\t    nested_mapping1: value2\n\t    nested_mapping2:\n", "      nested_mapping: value3\n\t  field3:\n\t    nested_mapping1: value4\n\t    nested_mapping2:\n\t      nested_mapping: value5\n\t# {% else %}\n\t- field2:\n\t    nested_mapping2:\n\t      nested_mapping: value6\n\t    nested_mapping1: value7\n", "  field3:\n\t    nested_mapping1: value8\n\t    nested_mapping2:\n\t      nested_mapping: value9\n\t# {% endif %}\n\t\"\"\",\n\t        # list fields | single if/else toggle | single complex list-map\n\t        \"\"\"\n\tlist:\n\t- value\n", "# {% if defines.get(\"toggle_value\") %}\n\t- field2:\n\t  - nested_mapping1: value2\n\t    nested_mapping2:\n\t    - value3\n\t    - value4\n\t- - field3:\n\t    nested_mapping1: value5\n\t    nested_mapping2:\n\t      nested_mapping: value6\n", "# {% else %}\n\t- field2:\n\t  - - nested_mapping2:\n\t        nested_mapping: value7\n\t    - nested_mapping1: value8\n\t  field3:\n\t    nested_mapping1: value8\n\t    nested_mapping2:\n\t      nested_mapping: value9\n\t# {% endif %}\n", "\"\"\",\n\t        #####################\n\t        # MULTI MAP TOGGLES #\n\t        #####################\n\t        # mapping field | multiple if toggle | simple single value\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field1: value2\n", "  # {% endif %}\n\t  # {% if defines.get(\"toggle_value1\") %}\n\t  field2: value3\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping field | multiple if-no/if-no toggle | simple single value\n\t        \"\"\"\n\tmapping:\n\t  field: value\n\t  # {% if not defines.get(\"toggle_value\") %}\n", "  field1: value2\n\t  # {% endif %}\n\t  # {% if not defines.get(\"toggle_value\") %}\n\t  field2: value3\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping field | multiple if toggle | simple multiple value\n\t        \"\"\"\n\tmapping:\n\t  field: value\n", "  # {% if defines.get(\"toggle_value\") %}\n\t  field1: value2\n\t  field2: value3\n\t  # {% endif %}\n\t  # {% if defines.get(\"toggle_value1\") %}\n\t  field3: value4\n\t  field4: value5\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping field | multiple if toggle | complex multiple map\n", "        \"\"\"\n\tmapping:\n\t  field:\n\t    nested: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field1:\n\t    nested_map: value2\n\t  field2:\n\t    nested_map:\n\t      nested: value3\n", "  # {% endif %}\n\t  # {% if defines.get(\"toggle_value1\") %}\n\t  field2:\n\t    nested_map:\n\t      nested: value3\n\t  field1:\n\t    nested_map: value2\n\t  # {% endif %}\n\t\"\"\",\n\t        # mapping field | multiple if toggle | complex multiple map-list\n", "        \"\"\"\n\tmapping:\n\t  field:\n\t    nested: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field1:\n\t  - nested_map: value2\n\t  - - value3\n\t  field2:\n\t    nested_map:\n", "      nested:\n\t      - value4\n\t  # {% endif %}\n\t  # {% if defines.get(\"toggle_value1\") %}\n\t  field2:\n\t    nested_map:\n\t      nested:\n\t      - value5\n\t      - value6\n\t  field1:\n", "  - nested_map:\n\t    - - value7\n\t    nested_map2: value8\n\t  # {% endif %}\n\t\"\"\",\n\t        \"\"\"\n\tlist:\n\t- field:\n\t  - - nested:\n\t        map: value\n", "# {% if defines.get(\"toggle_value\") %}\n\t- value1\n\t# {% endif %}\n\t\"\"\",\n\t        # list field | multiple if toggle | complex multiple map-list\n\t        \"\"\"\n\tlist:\n\t- field:\n\t  - - nested:\n\t        map: value\n", "# {% if defines.get(\"toggle_value\") %}\n\t- field1:\n\t    nested_map: value2\n\t- - field2:\n\t    - nested:\n\t        map: value3\n\t    - nested: value4\n\t# {% endif %}\n\t# {% if defines.get(\"toggle_value1\") %}\n\t- field3:\n", "    nested_map:\n\t      nested:\n\t      - value5\n\t      - value6\n\t- field1:\n\t  - nested_map:\n\t    - - value7\n\t  nested_map2: value8\n\t# {% endif %}\n\t\"\"\",\n", "        # list-map field | multiple if/else toggle | complex multiple map-list\n\t        \"\"\"\n\tlist:\n\t- field3:\n\t    woo: woo\n\t    # {% if defines.get(\"toggle_value1\") %}\n\t    nested_map:\n\t      nested:\n\t      - value5\n\t      - value6\n", "    # {% else %}\n\t    nested_map: value7\n\t    # {% endif %}\n\t# {% if defines.get(\"toggle_value\") %}\n\t- field1:\n\t    nested_map: value2\n\t- - field2:\n\t    - nested:\n\t        map: value3\n\t    - nested: value4\n", "# {% endif %}\n\t\"\"\",\n\t        # mapping | empty lists as comment anchors\n\t        \"\"\"\n\tmapping:\n\t  field: []\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field2: value2\n\t  field3: value3\n\t  # {% else %}\n", "  field2: []\n\t  field3: []\n\t  # {% endif %}\n\t\"\"\",\n\t        # list | empty lists as comment anchors\n\t        \"\"\"\n\tlist:\n\t- []\n\t# {% if defines.get(\"toggle_value\") %}\n\t- value2\n", "- value3\n\t# {% else %}\n\t- []\n\t- []\n\t# {% endif %}\n\t\"\"\",\n\t        # mapping | empty maps as comment anchors\n\t        \"\"\"\n\tmapping:\n\t  field: {}\n", "  # {% if defines.get(\"toggle_value\") %}\n\t  field2: value2\n\t  field3: value3\n\t  # {% else %}\n\t  field2: {}\n\t  field3:\n\t    vaal: {}\n\t  # {% endif %}\n\t\"\"\",\n\t        # list | empty map as comment anchors\n", "        \"\"\"\n\tlist:\n\t- {}\n\t# {% if defines.get(\"toggle_value\") %}\n\t- value2\n\t- value3\n\t# {% else %}\n\t- {}\n\t- {}\n\t# {% endif %}\n", "\"\"\",\n\t        # simple unordered configuration\n\t        \"\"\"\n\t# {% if defines.get(\"toggle_value\") %}\n\tfield3: value3\n\tfield2: value2\n\t# {% else %}\n\tfield3: []\n\tfield2: []\n\t# {% endif %}\n", "field1: []\n\t\"\"\",\n\t        # complex unordered configuration\n\t        \"\"\"\n\tlist:\n\t- field99: value\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  field3: ''\n\t  field2:\n\t  - z: 1\n", "    a: 12\n\t    f: 4\n\t  # {% else %}\n\t  field2: []\n\t  field3: []\n\t  # {% endif %}\n\t  field1: 1\n\tfield1: []\n\t\"\"\",\n\t        # list with only toggled items\n", "        \"\"\"\n\tlist:\n\t# {% if defines.get(\"toggle_value\") %}\n\t- value1\n\t# {% else %}\n\t- value2\n\t# {% endif %}\n\t\"\"\",\n\t        # single toggled list element\n\t        \"\"\"\n", "list:\n\t-\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  - value\n\t  # {% endif %}\n\t# {% if defines.get(\"toggle_value\") %}\n\t- value\n\t# {% endif %}\n\t\"\"\",\n\t        # single toggled map\n", "        \"\"\"\n\tlist:\n\t-\n\t  # {% if defines.get(\"toggle_value\") %}\n\t  map: 1\n\t  # {% endif %}\n\t# {% if defines.get(\"toggle_value\") %}\n\t- map: 1\n\t# {% endif %}\n\t\"\"\",\n", "        # nested toggled maps\n\t        \"\"\"\n\t# {% if defines.get(\"toggle_value\") %}\n\tmap:\n\t  # {% if defines.get(\"toggle_value1\") %}\n\t  map1: value1\n\t  # {% else %}\n\t  map1: value2\n\t  # {% endif %}\n\t# {% else %}\n", "map:\n\t  # {% if defines.get(\"toggle_value1\") %}\n\t  map1: value3\n\t  # {% else %}\n\t  map1: value4\n\t  # {% endif %}\n\t# {% endif %}\n\t\"\"\",\n\t        # nested toggled seqs\n\t        \"\"\"\n", "- new_line_keeper\n\t# {% if defines.get(\"toggle_value\") %}\n\t-\n\t  # {% if defines.get(\"toggle_value1\") %}\n\t  - value1\n\t  # {% else %}\n\t  - value2\n\t  # {% endif %}\n\t# {% else %}\n\t-\n", "  # {% if defines.get(\"toggle_value1\") %}\n\t  - value3\n\t  # {% else %}\n\t  - value4\n\t  # {% endif %}\n\t# {% endif %}\n\t\"\"\",\n\t        # elif simple toggled map\n\t        \"\"\"\n\t# {% if defines.get(\"toggle_value\") %}\n", "map: value1\n\t# {% elif defines.get(\"toggle_value1\") %}\n\tmap: value2\n\t# {% elif defines.get(\"toggle_value2\") %}\n\tmap: value3\n\t# {% else %}\n\tmap: value4\n\t# {% endif %}\n\t\"\"\",\n\t        # elif complex nested toggled map\n", "        \"\"\"\n\t# {% if defines.get(\"toggle_value\") %}\n\tmap:\n\t  # {% if defines.get(\"toggle_value_nested\") %}\n\t  map1: value1\n\t  # {% else %}\n\t  map1: value2\n\t  # {% endif %}\n\t# {% elif defines.get(\"toggle_value1\") %}\n\tlist:\n", "- val\n\t# {% if defines.get(\"toggle_value_nested\") %}\n\t- value1\n\t# {% else %}\n\t- value2\n\t# {% endif %}\n\t# {% elif defines.get(\"toggle_value2\") %}\n\tmap:\n\t  map1:\n\t    map2: value\n", "# {% endif %}\n\t\"\"\",\n\t        # elif complex nested toggled seq\n\t        \"\"\"\n\tlist:\n\t- val\n\t# {% if defines.get(\"toggle_value\") %}\n\t- - - value1\n\t    - value4\n\t# {% elif defines.get(\"toggle_value1\") %}\n", "- map:\n\t    map2:\n\t      map3: value\n\t# {% elif defines.get(\"toggle_value2\") %}\n\t- - map:\n\t      map1: value\n\t# {% else %}\n\t- map:\n\t  - map1:\n\t    - value1\n", "    # {% if defines.get(\"toggle_value\") %}\n\t    - value2\n\t    # {% elif defines.get(\"toggle_value_nested\") %}\n\t    - value4\n\t    # {% endif %}\n\t# {% endif %}\n\t\"\"\",\n\t        # nested map toggles on the same level\n\t        \"\"\"\n\tmap:\n", "  # {% if defines.get(\"toggle_value\") %}\n\t  # {% if defines.get(\"nested_toggle_value\") %}\n\t  value: 1\n\t  # {% endif %}\n\t  # {% elif defines.get(\"toggle_value1\") %}\n\t  value: 2\n\t  # {% endif %}\n\t\"\"\",\n\t        # complex nested seq toggles\n\t        \"\"\"\n", "- 0\n\t# {% if defines.get(\"toggle_value\") %}\n\t-\n\t  # {% if defines.get(\"nested_toggle_value1\") %}\n\t  -\n\t    # {% if defines.get(\"nested_toggle_value0\") %}\n\t    -\n\t      # {% if defines.get(\"first_seq_element\") %}\n\t      - first\n\t      # {% endif %}\n", "      # {% if defines.get(\"nested_toggle_value2\") %}\n\t      # {% if defines.get(\"nested_toggle_value3\") %}\n\t      - innner\n\t      # {% elif defines.get(\"nested_toggle_value4\") %}\n\t      -\n\t        # {% if defines.get(\"nested_toggle_value5\") %}\n\t        # {% if defines.get(\"nested_toggle_value6\") %}\n\t        - inner1\n\t        # {% endif %}\n\t        # {% endif %}\n", "      # {% endif %}\n\t      # {% endif %}\n\t      - normal\n\t    # {% endif %}\n\t  # {% endif %}\n\t- 2\n\t# {% elif defines.get(\"toggle_value1\") %}\n\t- 3\n\t# {% endif %}\n\t\"\"\",\n", "        # complex nested map toggles\n\t        \"\"\"\n\ta0: first\n\t# {% if defines.get(\"toggle_value\") %}\n\ta1:\n\t  # {% if defines.get(\"nested_toggle_value1\") %}\n\t  a2:\n\t    # {% if defines.get(\"nested_toggle_value2\") %}\n\t    # {% if defines.get(\"nested_toggle_value3\") %}\n\t    a3: third\n", "    # {% elif defines.get(\"nested_toggle_value4\") %}\n\t    b1:\n\t      # {% if defines.get(\"nested_toggle_value5\") %}\n\t      # {% if defines.get(\"nested_toggle_value6\") %}\n\t      b2: 2\n\t      # {% endif %}\n\t      # {% endif %}\n\t    # {% endif %}\n\t    # {% endif %}\n\t  # {% endif %}\n", "# {% elif defines.get(\"toggle_value1\") %}\n\ta1: 2\n\t# {% endif %}\n\t\"\"\",\n\t        # complex nested map-list toggles\n\t        \"\"\"\n\ta0: first\n\t# {% if defines.get(\"toggle_value\") %}\n\ta1:\n\t# {% if defines.get(\"nested_toggle_value1\") %}\n", "- a2: val\n\t  # {% if defines.get(\"nested_toggle_value2\") %}\n\t  # {% if defines.get(\"nested_toggle_value3\") %}\n\t  a3: third\n\t  # {% elif defines.get(\"nested_toggle_value4\") %}\n\t  b1:\n\t  # {% if defines.get(\"nested_toggle_value5\") %}\n\t  - b2a: 1\n\t  # {% if defines.get(\"nested_toggle_value6\") %}\n\t  - b2b: 2\n", "  # {% endif %}\n\t  # {% endif %}\n\t  # {% endif %}\n\t  # {% endif %}\n\t# {% endif %}\n\t# {% elif defines.get(\"toggle_value1\") %}\n\ta1: 2\n\t# {% endif %}\n\t\"\"\",\n\t    ],\n", ")\n\tdef test_config_non_mutable(raw_config):\n\t    yamx = YAMX(sort_keys=False)\n\t    _load_dump_and_compare(yamx, raw_config)\n\t@pytest.mark.parametrize(\n\t    \"raw_config\",\n\t    [\n\t        \"key: !conditional 123\",\n\t        \"__deduplicator__: 123\",\n\t        \"__deduplicator_upd__: 123\",\n", "        \"____THIS_DOESN'T_EXIST____: 123\",\n\t        \"__condition__0: 123\",\n\t    ],\n\t)\n\tdef test_config_validate(raw_config):\n\t    input_stream = io.StringIO(raw_config)\n\t    yamx = YAMX(sort_keys=False)\n\t    with pytest.raises(AssertionError):\n\t        yamx.load(input_stream)\n\t    input_stream.close()\n", "@pytest.mark.parametrize(\n\t    \"raw_config\",\n\t    [\n\t        # no toggles\n\t        \"\"\"\n\tfields:\n\t    list_simple:\n\t     -  string\n\t     -  another_one\n\t    list_complex:\n", "     -  field: 12\n\t     -   -  1\n\t     -   -  field:12\n\t\"\"\",\n\t        # root level toggle\n\t        \"\"\"\n\tfield_1: 1\n\t# {% if defines.get(\"toggle_value\") %}\n\tfield_2: 20\n\t# {% else %}\n", "field_2: 21\n\t# {% endif %}\n\t\"\"\",\n\t        # nested map level toggle\n\t        \"\"\"\n\tfields:\n\t    field_1: 1\n\t    # {% if defines.get(\"toggle_value\") %}\n\t    field_2: 2\n\t    # {% endif %}\n", "\"\"\",\n\t        # nested list level toggle\n\t        \"\"\"\n\tlist:\n\t -  1\n\t # {% if defines.get(\"toggle_value\") %}\n\t -  2\n\t # {% endif %}\n\t\"\"\",\n\t        # nested list level toggle\n", "        \"\"\"\n\tparams:\n\t    list:\n\t     -  1\n\t     # {% if defines.get(\"toggle_value\") %}\n\t     -  2\n\t     # {% endif %}\n\t\"\"\",\n\t        # nested deep level toggle\n\t        \"\"\"\n", "params:\n\t    deeper:\n\t     -  list:\n\t         -  1\n\t         # {% if defines.get(\"toggle_value\") %}\n\t         -  2\n\t         # {% endif %}\n\t     -  3\n\t\"\"\",\n\t        # nested deep complex level toggle\n", "        \"\"\"\n\tparams:\n\t -  deeper:\n\t     -  list:\n\t         -  map:\n\t             -  1\n\t        # {% if defines.get(\"toggle_value\") %}\n\t        map:\n\t         -  1\n\t         -  2\n", "        # {% else %}\n\t        map:\n\t         -  2\n\t        # {% endif %}\n\t     -  no_list: 1\n\t\"\"\",\n\t    ],\n\t)\n\tdef test_config_indentation_settings(raw_config):\n\t    yamx = YAMX(sort_keys=False)\n", "    yamx.indent(mapping=4, sequence=4, offset=1)\n\t    _load_dump_and_compare(yamx, raw_config)\n\t@pytest.mark.parametrize(\n\t    \"raw_config, expected\",\n\t    [\n\t        (\n\t            \"\"\"\n\tparams: 1\n\tactive: false\n\t\"\"\",\n", "            \"\"\"\n\tactive: false\n\tparams: 1\n\t\"\"\",\n\t        ),\n\t        # case with toggle\n\t        (\n\t            \"\"\"\n\tmapping:\n\t  # {% if defines.get(\"toggle_a\") %}\n", "  field2:\n\t    fb: 2\n\t    fz: 3\n\t    fa: 1\n\t  field3: 123\n\t  field1: value3\n\t  # {% else %}\n\t  field1: value4\n\t  # {% endif %}\n\t  field0: []\n", "\"\"\",\n\t            \"\"\"\n\tmapping:\n\t  field0: []\n\t  # {% if defines.get(\"toggle_a\") %}\n\t  field1: value3\n\t  field2:\n\t    fa: 1\n\t    fb: 2\n\t    fz: 3\n", "  field3: 123\n\t  # {% else %}\n\t  field1: value4\n\t  # {% endif %}\n\t\"\"\",\n\t        ),\n\t        # case with multiple toggle\n\t        (\n\t            \"\"\"\n\tlist:\n", "- field3: value3\n\t  # {% if defines.get(\"toggle_b\") %}\n\t  field1: value1a\n\t  # {% else %}\n\t  field1: value1b\n\t  # {% endif %}\n\t  # {% if defines.get(\"toggle_a\") %}\n\t  field2: value2\n\t  # {% endif %}\n\t  field0: value0\n", "\"\"\",\n\t            \"\"\"\n\tlist:\n\t- field0: value0\n\t  field3: value3\n\t  # {% if defines.get(\"toggle_a\") %}\n\t  field2: value2\n\t  # {% endif %}\n\t  # {% if defines.get(\"toggle_b\") %}\n\t  field1: value1a\n", "  # {% else %}\n\t  field1: value1b\n\t  # {% endif %}\n\t\"\"\",\n\t        ),\n\t    ],\n\t)\n\tdef test_config_sort_keys(raw_config, expected):\n\t    yamx = YAMX(sort_keys=True)\n\t    _load_dump_and_compare(yamx, raw_config, expected)\n", "def test_constructor_instantiation():\n\t    yamx1 = YAMX()\n\t    yamx2 = YAMX()\n\t    yamx1.yaml.constructor.add_custom_constructor(\"test_constructor\", lambda: None)\n\t    assert \"test_constructor\" in yamx1.yaml.constructor.yaml_constructors\n\t    assert \"test_constructor\" not in yamx2.yaml.constructor.yaml_constructors\n\t@pytest.mark.parametrize(\n\t    \"raw_config, expected\",\n\t    [\n\t        # no conditions\n", "        (\n\t            \"\"\"\n\tparams: 1\n\tactive: false\n\t\"\"\",\n\t            \"\"\"\n\tparams: 1\n\tactive: false\n\t\"\"\",\n\t        ),\n", "        # non-contextual conditions\n\t        (\n\t            \"\"\"\n\t{% if False %}\n\tparams: 1\n\t{% else %}\n\tparams: 2\n\t{% endif %}\n\tactive: false\n\t\"\"\",\n", "            \"\"\"\n\tparams: 2\n\tactive: false\n\t\"\"\",\n\t        ),\n\t        # contextual conditions\n\t        (\n\t            \"\"\"\n\t{% if defines.get(\"toggle_a\") %}\n\tparams: 1\n", "{% else %}\n\tparams: 2\n\t{% endif %}\n\tactive: false\n\t\"\"\",\n\t            \"\"\"\n\tparams: 1\n\tactive: false\n\t\"\"\",\n\t        ),\n", "        # contextual elif conditions\n\t        (\n\t            \"\"\"\n\t{% if False %}\n\tparams: 1\n\t{% elif defines.get(\"toggle_a\") == False %}\n\tparams: 2\n\t{% else %}\n\tparams: 3\n\t{% endif %}\n", "active: false\n\t\"\"\",\n\t            \"\"\"\n\tparams: 3\n\tactive: false\n\t\"\"\",\n\t        ),\n\t        # nested conditions map\n\t        (\n\t            \"\"\"\n", "{% if False %}\n\tparams: 1\n\t{% else %}\n\tmap:\n\t  val: 1\n\t  {% if defines.get(\"toggle_a\") %}\n\t  params: 3\n\t  {% endif %}\n\t  val2: 2\n\t{% endif %}\n", "active: false\n\t\"\"\",\n\t            \"\"\"\n\tmap:\n\t  val: 1\n\t  params: 3\n\t  val2: 2\n\tactive: false\n\t\"\"\",\n\t        ),\n", "        # nested conditions seq\n\t        (\n\t            \"\"\"\n\t{% if False %}\n\tparams: 1\n\t{% else %}\n\tlist:\n\t- key: val\n\t-\n\t  {% if defines.get(\"toggle_a\") %}\n", "  key1: val1\n\t  {% endif %}\n\t  key2: val2\n\t{% endif %}\n\tactive: false\n\t\"\"\",\n\t            \"\"\"\n\tlist:\n\t- key: val\n\t-\n", "  key1: val1\n\t  key2: val2\n\tactive: false\n\t\"\"\",\n\t        ),\n\t    ],\n\t)\n\tdef test_resolve(raw_config, expected):\n\t    yamx = YAMX()\n\t    context = {\"defines\": {\"toggle_a\": True}}\n", "    data = yamx.resolve(raw_config, context)\n\t    assert data == expected\n\t@pytest.mark.parametrize(\n\t    \"raw_config, error_ctx\",\n\t    [\n\t        (\n\t            \"\"\"\n\t{% if defines.get(\"toggle_a\") %}\n\t\"\"\",\n\t            pytest.raises(\n", "                Exception, match=\"Failed to parse jinja syntax while resolving.\"\n\t            ),\n\t        ),\n\t        # case with multiple toggle\n\t        (\n\t            \"\"\"\n\t{% if context.get(\"toggle_a\") %}\n\ta: 1\n\t{% endif %}\n\t\"\"\",\n", "            pytest.raises(\n\t                Exception,\n\t                match=\"Following context variables are not defined: {'context'}\",\n\t            ),\n\t        ),\n\t    ],\n\t)\n\tdef test_resolve_failed(raw_config, error_ctx):\n\t    yamx = YAMX()\n\t    context = {\"defines\": {\"toggle_a\": True}}\n", "    with error_ctx:\n\t        yamx.resolve(raw_config, context)\n"]}
{"filename": "tests/integration/test_conditions.py", "chunked_list": ["import pytest\n\tfrom yamx.jinja.condition import extract_condition\n\tfrom yamx.loader.utils import get_jinja_env\n\t@pytest.mark.parametrize(\n\t    \"original_condition\",\n\t    [\n\t        # different toggle names\n\t        'defines.get(\"toggle_a\")',\n\t        'defines.get(\"toggle_b\")',\n\t        # literals\n", "        \"1\",\n\t        '\"1\"',\n\t        \"True\",\n\t        \"[]\",\n\t        '{\"a\": 1}',\n\t        \"set([1, 2])\",\n\t        # and / or conditions\n\t        \"1 and 1\",\n\t        \"1 or 1\",\n\t        # # and or with precedence\n", "        \"(1 or 1) and 1\",\n\t        \"1 or 1 and 1\",\n\t        \"1 and (1 or 1)\",\n\t        \"1 and 1 or 1\",\n\t        # # # and/or with negation\n\t        \"not 1 and 1\",\n\t        \"1 and not 1\",\n\t        \"not 1 or 1\",\n\t        \"1 or not 1\",\n\t        # unops\n", "        # # negation\n\t        \"not 1\",\n\t        \"not(1 and 1)\",\n\t        \"not(1 or 1)\",\n\t        # neg\n\t        \"- 1\",\n\t        \"-(1 and 1)\",\n\t        \"-(1 or 1)\",\n\t        \"-(1 / 1)\",\n\t        # binops\n", "        \"1 - - 1\",\n\t        \"1 - + 1\",\n\t        \"1 / not(1)\",\n\t    ],\n\t)\n\tdef test_condition_representer(original_condition):\n\t    data = f\"\"\"\n\t    pre-conditional text\n\t    {{% if {original_condition} %}}\n\t    conditional text\n", "    {{% endif %}}\n\t    postconditional text\n\t    \"\"\"\n\t    env = get_jinja_env()\n\t    jinja_ast = env.parse(data)\n\t    ast_node = jinja_ast.body[1].test\n\t    condition = extract_condition(ast_node, env)\n\t    assert condition.raw_value == original_condition\n"]}
{"filename": "tests/unit/test_dump.py", "chunked_list": ["from yamx import YAMX\n\tfrom yamx.yamx import ConditionalData\n\tdef test_dump_to_file(tmp_path):\n\t    yamx = YAMX()\n\t    file_path = f\"{tmp_path}/data.yaml\"\n\t    with open(file_path, \"w+\") as fp:\n\t        yamx.dump(ConditionalData(None), fp)\n\t    with open(file_path) as fp:\n\t        data = fp.read()\n\t    assert data == \"null\\n...\\n\"\n", "def test_dump_to_(tmp_path):\n\t    yamx = YAMX()\n\t    data = yamx.dump_to_string(ConditionalData(None))\n\t    assert data == \"null\\n...\"\n"]}
{"filename": "tests/unit/__init__.py", "chunked_list": []}
{"filename": "tests/unit/test_init.py", "chunked_list": ["import pytest\n\tfrom ruamel.yaml import YAML\n\tfrom yamx import YAMX\n\tdef test_default():\n\t    YAMX()\n\tdef test_custom_yaml():\n\t    YAMX(yaml=YAML(typ=[\"rt\", \"string\"]))\n\tdef test_missing_rt_constructor():\n\t    with pytest.raises(\n\t        AssertionError, match=\"RoundTripLoader/RoundTripDumper is required\"\n", "    ):\n\t        YAMX(yaml=YAML(typ=[\"string\"]))\n"]}
{"filename": "tests/unit/loader/test_preprocessor.py", "chunked_list": ["from unittest.mock import patch\n\timport pytest\n\tfrom yamx.loader.preprocessor import translate_config_flags\n\t@pytest.mark.parametrize(\n\t    \"raw_data,translated_data\",\n\t    [\n\t        # simple map\n\t        (\n\t            \"\"\"\n\t{% if condition %}\n", "a: 1\n\t{% endif %}\n\t\"\"\",\n\t            \"\"\"\n\t__condition__0: !<conditional>\n\t  data:\n\t    a: 1\n\t  typ: if\n\t  condition: condition\n\t\"\"\",\n", "        ),\n\t        # complex map\n\t        (\n\t            \"\"\"\n\t{% if condition1 %}\n\ta: 1\n\t{% elif condition2 %}\n\ta: 2\n\t{% elif condition3 %}\n\ta: 3\n", "{% else %}\n\ta: 4\n\t{% endif %}\n\t\"\"\",\n\t            \"\"\"\n\t__condition__0: !<conditional>\n\t  data:\n\t    a: 1\n\t  typ: if\n\t  condition: condition1\n", "__condition__1: !<conditional>\n\t  data:\n\t    a: 2\n\t  typ: elif\n\t  condition: condition2\n\t__condition__2: !<conditional>\n\t  data:\n\t    a: 3\n\t  typ: elif\n\t  condition: condition3\n", "__condition__3: !<conditional>\n\t  data:\n\t    a: 4\n\t  typ: else\n\t  condition:\n\t\"\"\",\n\t        ),\n\t        # simple list\n\t        (\n\t            \"\"\"\n", "{% if condition %}\n\t- 1\n\t{% endif %}\n\t\"\"\",\n\t            \"\"\"\n\t- !<conditional>\n\t  data:\n\t  - 1\n\t  typ: if\n\t  condition: condition\n", "\"\"\",\n\t        ),\n\t        # complex list\n\t        (\n\t            \"\"\"\n\t{% if condition1 %}\n\t- 1\n\t{% elif condition2 %}\n\t- 2\n\t{% elif condition3 %}\n", "- 3\n\t{% else %}\n\t- 4\n\t{% endif %}\n\t\"\"\",\n\t            \"\"\"\n\t- !<conditional>\n\t  data:\n\t  - 1\n\t  typ: if\n", "  condition: condition1\n\t- !<conditional>\n\t  data:\n\t  - 2\n\t  typ: elif\n\t  condition: condition2\n\t- !<conditional>\n\t  data:\n\t  - 3\n\t  typ: elif\n", "  condition: condition3\n\t- !<conditional>\n\t  data:\n\t  - 4\n\t  typ: else\n\t  condition:\n\t\"\"\",\n\t        ),\n\t    ],\n\t)\n", "@patch(\"yamx.loader.preprocessor.UNIQUE_CONDITION_CNT\", 0)\n\tdef test_translate_config_flags(raw_data, translated_data):\n\t    assert translate_config_flags(raw_data) == translated_data\n"]}
{"filename": "tests/unit/loader/__init__.py", "chunked_list": []}
{"filename": "dev/fix_ruamel_pkg_names.py", "chunked_list": ["#!/usr/bin/env python3\n\t\"\"\"\n\tWorkaround for poetry install to be able to install ruamel.yaml library\n\tand at same time we can still keep using pip-compile and output requirement txt files\n\t\"\"\"\n\timport sys\n\tTO_BE_REPLACED = {\n\t    \"ruamel-yaml-string\": \"ruamel.yaml.string\",\n\t    \"ruamel-yaml-clib\": \"ruamel.yaml.clib\",\n\t    \"ruamel-yaml\": \"ruamel.yaml\",\n", "}\n\tdef replace_in_file(file_path: str):\n\t    with open(file_path) as f:\n\t        content = f.read()\n\t    for value_to_be_replaced, new_value in TO_BE_REPLACED.items():\n\t        content = content.replace(value_to_be_replaced, new_value)\n\t    with open(file_path, \"w\") as f:\n\t        f.write(content)\n\tdef main(path: str):\n\t    replace_in_file(path)\n", "if __name__ == \"__main__\":\n\t    try:\n\t        if len(sys.argv) < 2:\n\t            raise Exception(\"Missing path namespace argument.\")\n\t        main(sys.argv[1])\n\t    except Exception as e:\n\t        print(str(e))\n\t        sys.exit(1)\n"]}
