{"filename": "test/sdf.py", "chunked_list": ["import pytest, sys\n\tsys.path.append('..')\n\tfrom sympy import Matrix\n\tfrom SymE3.core import PointH, LieGroup, LieAlgebra, SymbolicFunction, dehom, TotalFunction, exp\n\tfrom SymE3.detail import _MatrixSym\n\tdef test_sdf():\n\t    l_i = PointH(\"{l_i}\")\n\t    lhat_i = PointH(\"{\\\\hat{l}_i}\")\n\t    That_wl = LieGroup(\"{\\\\hat{T}_{wl}}\")\n\t    d = LieAlgebra(\"{\\\\delta}\")\n", "    psi = SymbolicFunction(\"{psi}\", 3, 1)\n\t    e = psi(dehom(exp(d) * That_wl * l_i))\n\t    e = e.subs(That_wl * l_i, lhat_i)\n\t    f = TotalFunction(e)\n\t    df_dd = f.diff(d)\n\t    # Compare against ground truth\n\t    lh = Matrix(_MatrixSym(lhat_i.name, 3, 1))\n\t    ps = psi.__explicit__()(lh[0], lh[1], lh[2])\n\t    fe = f.as_explicit()\n\t    c = ps\n", "    assert c.__str__() == fe.__str__()\n\t    dpsi_dlh = Matrix([ps.fdiff(1), ps.fdiff(2), ps.fdiff(3)]).transpose()\n\t    cp = lh.cross(dpsi_dlh).transpose()\n\t    jc = dpsi_dlh\n\t    jc = jc.col_insert(3, cp)\n\t    assert jc == df_dd\n"]}
{"filename": "test/photo.py", "chunked_list": ["import pytest, sys\n\tsys.path.append('..')\n\tfrom sympy import expand, symbols, Matrix, tensorcontraction\n\tfrom SymE3.core import Pixel, PointH, LieGroup, LieAlgebra, CustomFunction, SymbolicFunction, dehom, TotalFunction, exp\n\tfrom SymE3.detail import _MatrixSym\n\tdef test_photometric_alignment():\n\t    x_i = Pixel(\"{x_i}\")\n\t    p_i = PointH(\"{p_i}\")\n\t    That_rl = LieGroup(\"{\\\\hat{T}_{rl}}\")\n\t    d = LieAlgebra(\"{\\\\delta}\")\n", "    phat_i = PointH(\"{\\\\hat{p}_i}\")\n\t    def proj(p):\n\t        p_ray = p / p[2, 0]\n\t        f_x, f_y, c_x, c_y = symbols(\"f_x f_y c_x c_y\")\n\t        return Matrix([[f_x,   0, c_x],\n\t                        [  0, f_y, c_y]]) * p_ray\n\t    Pi = CustomFunction(\"Pi\", proj, 3, 2)\n\t    I_r = SymbolicFunction(\"I_r\", 2, 1)\n\t    I_l = SymbolicFunction(\"I_l\", 2, 1)\n\t    e = I_r(Pi(dehom(exp(d) * That_rl * p_i))) - I_l(x_i)\n", "    e = e.subs(That_rl * p_i, phat_i)\n\t    f = TotalFunction(e)\n\t    df_dd = f.diff(d)\n\t    # Compare against ground truth\n\t    ph = Matrix(_MatrixSym(phat_i.name, 3, 1))\n\t    x = Matrix(_MatrixSym(x_i.name, 2, 1))\n\t    pi = Pi.__explicit__()(ph).tomatrix()\n\t    il = I_l.__explicit__()(x[0], x[1])\n\t    ir = I_r.__explicit__()(pi[0], pi[1])\n\t    fe = f.as_explicit()\n", "    c = ir - il\n\t    assert c.__str__() == fe.__str__()\n\t    dpi_dph = tensorcontraction(pi.diff(ph), (1, 3)).transpose()\n\t    dir_dpi = Matrix([ir.fdiff(1), ir.fdiff(2)]).transpose()\n\t    gradpi = dir_dpi * dpi_dph\n\t    cp = ph.cross(gradpi).transpose()\n\t    jc = gradpi\n\t    jc = jc.col_insert(3, cp)\n\t    df_ddm = df_dd\n\t    for i in range(6):\n", "        jc[i] = expand(jc[i])\n\t        df_ddm[i] = expand(df_ddm[i])\n\t    assert jc == df_ddm\n"]}
{"filename": "test/icp.py", "chunked_list": ["import pytest, sys\n\tsys.path.append('..')\n\tfrom sympy import Matrix\n\tfrom SymE3.core import exp, LieAlgebra, NormalH, PointH, LieGroup, TotalFunction\n\tfrom SymE3.detail import _MatrixSym\n\tdef test_point_plane_icp():\n\t    n_ri = NormalH(\"{n_{r_i}}\")\n\t    r_i = PointH(\"{r_i}\")\n\t    l_i = PointH(\"{l_i}\")\n\t    rhat_i = PointH(\"{\\\\hat{r}_i}\")\n", "    That_rl = LieGroup(\"{\\\\hat{T}_{rl}}\")\n\t    d = LieAlgebra(\"{\\\\delta}\")\n\t    e = n_ri.transpose() * ((exp(d) * That_rl * l_i) - r_i)\n\t    e = e.subs(That_rl * l_i, rhat_i)\n\t    f = TotalFunction(e)\n\t    df_dd = f.diff(d)\n\t    # Compare against ground truth\n\t    nr = Matrix(_MatrixSym(n_ri.name, 3, 1))\n\t    r = Matrix(_MatrixSym(r_i.name, 3, 1))\n\t    rh = Matrix(_MatrixSym(rhat_i.name, 3, 1))\n", "    c = nr.transpose() * (rh - r)\n\t    fe = f.as_explicit()\n\t    assert c == fe.tomatrix()\n\t    cp = rh.cross(nr).transpose()\n\t    jc = nr.transpose()\n\t    jc = jc.col_insert(3, cp)\n\t    assert jc == df_dd\n"]}
{"filename": "test/homogeneous.py", "chunked_list": ["import pytest, sys\n\tsys.path.append('..')\n\tfrom SymE3.core import PointH, TotalFunction\n\tdef test_addition():\n\t    a = PointH(\"a\")\n\t    b = PointH(\"b\")\n\t    e = TotalFunction(a + b).as_explicit().tomatrix()\n\t    assert e[3] == 1\n\tdef test_subtraction():\n\t    a = PointH(\"a\")\n", "    b = PointH(\"b\")\n\t    e = TotalFunction(a - b).as_explicit().tomatrix()\n\t    assert e[3] == 1\n\tdef test_rmul():\n\t    a = PointH(\"a\")\n\t    e = TotalFunction(2 * a).as_explicit().tomatrix()\n\t    assert e[3] == 1\n\tdef test_mul():\n\t    a = PointH(\"a\")\n\t    e = TotalFunction(a * 2).as_explicit().tomatrix()\n", "    assert e[3] == 1\n"]}
{"filename": "test/log.py", "chunked_list": ["import pytest, sys\n\tsys.path.append('..')\n\tfrom SymE3.core import exp, LieAlgebra, LieGroup, log\n\tdef test_log():\n\t    T_i = LieGroup(\"{T_{i}}\")\n\t    deltaxi_i = LieAlgebra(\"{\\\\delta\\\\xi_{i}}\")\n\t    assert exp(log(T_i)) == T_i\n\t    assert log(exp(deltaxi_i)) == deltaxi_i\n"]}
{"filename": "test/bundle.py", "chunked_list": ["import pytest, sys\n\tsys.path.append('..')\n\tfrom sympy import symbols, Matrix\n\tfrom SymE3.core import PointH, Pixel, LieGroup, LieAlgebra, CustomFunction, TotalFunction, dehom, exp\n\tdef test_bundle_adjustment():\n\t    x_w = PointH(\"{x_w}\")\n\t    x_i = Pixel(\"{x_i}\")\n\t    That_cw = LieGroup(\"{\\\\hat{T}_{cw}}\")\n\t    d = LieAlgebra(\"{\\\\delta}\")\n\t    f_x, f_y, c_x, c_y = symbols(\"f_x f_y c_x c_y\")\n", "    def proj(p):\n\t        p_ray = p / p[2, 0]\n\t        return Matrix([[f_x,   0, c_x],\n\t                       [  0, f_y, c_y]]) * p_ray\n\t    Pi = CustomFunction(\"Pi\", proj, 3, 2)\n\t    e = x_i - Pi(dehom(exp(d) * That_cw * x_w))\n\t    f = TotalFunction(e)\n\t    fe = f.as_explicit()\n\t    df_dd = f.diff(d, dehom(x_w), f_x, f_y, c_x, c_y)\n"]}
{"filename": "test/exp.py", "chunked_list": ["import pytest, sys\n\tsys.path.append('..')\n\tfrom sympy import Array\n\tfrom SymE3.core import exp, LieAlgebra, TotalFunction\n\tdef test_exp():\n\t    d = LieAlgebra(\"{\\\\delta}\")\n\t    f = TotalFunction(exp(d))\n\t    expected = Array([[[[0, 0, 0, 1], \n\t                        [0, 0, 0, 0], \n\t                        [0, 0, 0, 0], \n", "                        [0, 0, 0, 0]]], \n\t                      [[[0, 0, 0, 0], \n\t                        [0, 0, 0, 1], \n\t                        [0, 0, 0, 0], \n\t                        [0, 0, 0, 0]]], \n\t                      [[[0, 0, 0, 0], \n\t                        [0, 0, 0, 0], \n\t                        [0, 0, 0, 1], \n\t                        [0, 0, 0, 0]]], \n\t                      [[[0, 0, 0, 0], \n", "                        [0, 0, -1, 0], \n\t                        [0, 1, 0, 0], \n\t                        [0, 0, 0, 0]]], \n\t                      [[[0, 0, 1, 0], \n\t                        [0, 0, 0, 0], \n\t                        [-1, 0, 0, 0], \n\t                        [0, 0, 0, 0]]], \n\t                      [[[0, -1, 0, 0], \n\t                        [1, 0, 0, 0], \n\t                        [0, 0, 0, 0], \n", "                        [0, 0, 0, 0]]]])\n\t    result = f.diff(d)\n\t    assert expected == result\n"]}
{"filename": "test/mirrors.py", "chunked_list": ["import pytest, sys\n\tsys.path.append('..')\n\tfrom sympy import symbols, eye, Matrix\n\tfrom SymE3.core import Plane, LieGroup, PointH, Pixel, LieAlgebra, CustomFunction, TotalFunction, dehom, exp\n\tdef test_mirrors():\n\t    T_cw = LieGroup(\"{T_{cw}}\")\n\t    T_ct = LieGroup(\"{\\hat{T}_{ct}}\")\n\t    p_t = PointH(\"{p_t}\")\n\t    phat_c = PointH(\"{\\hat{p}_{c}}\")\n\t    p_c = Pixel(\"{p_c}\")\n", "    N_w = Plane(\"{N_w}\")\n\t    d = LieAlgebra(\"{\\\\delta}\")\n\t    def proj(p):\n\t        p_ray = p / p[2, 0]\n\t        f_x, f_y, c_x, c_y = symbols(\"f_x f_y c_x c_y\")\n\t        return Matrix([[f_x,   0, c_x],\n\t                       [  0, f_y, c_y]]) * p_ray\n\t    Pi = CustomFunction(\"Pi\", proj, 3, 2)\n\t    def sym(n):\n\t        n_hat = n[0:3, :]\n", "        S = eye(4)\n\t        S[0:3, 0:3] = eye(3) - (2 * (n_hat * n_hat.transpose()))\n\t        S[0:3, 3] = 2 * n[3] * n_hat\n\t        return S\n\t    S = CustomFunction(\"S\", sym, 4, 4, 1, 4)\n\t    e = Pi(dehom(T_cw * S(N_w) * T_cw.inverse() * exp(d) * T_ct * p_t)) - p_c\n\t    e = e.subs(T_ct * p_t, phat_c)\n\t    f = TotalFunction(e)\n\t    fe = f.as_explicit()\n\t    df_dd = f.diff(d, N_w)\n"]}
{"filename": "test/embeddef.py", "chunked_list": ["import pytest, sys\n\tsys.path.append('..')\n\tfrom sympy import Matrix, symbols, zeros, eye\n\tfrom SymE3.core import Matrix3, Scalar, Point, CustomFunction, TotalFunction\n\tfrom SymE3.detail import _MatrixSym\n\tdef test_embedded_deformation():\n\t    t_z = Point(\"{t_z}\")\n\t    t_n = Point(\"{t_n}\")\n\t    g_z = Point(\"{g_z}\")\n\t    g_n = Point(\"{g_n}\")\n", "    v_s = Point(\"{v_s}\")\n\t    q_s = Point(\"{q_s}\")\n\t    w_nvs = Scalar(\"{w_{n_{(v_s)}}}\")\n\t    R_n = Matrix3(\"{R_n}\")\n\t    R_z = Matrix3(\"{R_z}\")\n\t    def rot(R):\n\t        return Matrix([[R[:, 0].dot(R[:, 1])], \n\t                       [R[:, 0].dot(R[:, 2])],\n\t                       [R[:, 1].dot(R[:, 2])],\n\t                       [R[:, 0].dot(R[:, 0]) - 1],\n", "                       [R[:, 1].dot(R[:, 1]) - 1],\n\t                       [R[:, 2].dot(R[:, 2]) - 1]])\n\t    Rot = CustomFunction(\"Rot\", rot, 3, 6, 3)\n\t    # Rotation cost\n\t    e = Rot(R_z)\n\t    f = TotalFunction(e)\n\t    # This jacobian is an element of the matrix per column in row major order\n\t    df_dRt = f.diff(R_z, t_z)\n\t    # Compare against ground truth\n\t    rz = Matrix(_MatrixSym(R_z.name, 3, 3))\n", "    rr = Rot.__explicit__()\n\t    fe = f.as_explicit()\n\t    c = rr(rz).tomatrix()\n\t    assert c == fe.tomatrix()\n\t    assert df_dRt[:, 0] == c.diff(rz[0, 0])\n\t    assert df_dRt[:, 1] == c.diff(rz[0, 1])\n\t    assert df_dRt[:, 2] == c.diff(rz[0, 2])\n\t    assert df_dRt[:, 3] == c.diff(rz[1, 0])\n\t    assert df_dRt[:, 4] == c.diff(rz[1, 1])\n\t    assert df_dRt[:, 5] == c.diff(rz[1, 2])\n", "    assert df_dRt[:, 6] == c.diff(rz[2, 0])\n\t    assert df_dRt[:, 7] == c.diff(rz[2, 1])\n\t    assert df_dRt[:, 8] == c.diff(rz[2, 2])\n\t    assert df_dRt[:, 9:] == zeros(6, 3)\n\t    # Regularization cost\n\t    e = R_z * (g_n - g_z) + g_z + t_z - (g_n + t_n)\n\t    f = TotalFunction(e)\n\t    # This jacobian is an element of the matrix per column in row major order\n\t    df_dRt = f.diff(R_z, t_z, t_n)\n\t    # Compare against ground truth\n", "    gn = Matrix(_MatrixSym(g_n.name, 3, 1))\n\t    gz = Matrix(_MatrixSym(g_z.name, 3, 1))\n\t    tn = Matrix(_MatrixSym(t_n.name, 3, 1))\n\t    tz = Matrix(_MatrixSym(t_z.name, 3, 1))\n\t    fe = f.as_explicit()\n\t    c = rz * (gn - gz) + gz + tz - (gn + tn)\n\t    assert c == fe.tomatrix()\n\t    assert df_dRt[0:3, 0:3] == Matrix([[(gn - gz).transpose()], [zeros(1, 3)], [zeros(1, 3)]])\n\t    assert df_dRt[0:3, 3:6] == Matrix([[zeros(1, 3)], [(gn - gz).transpose()], [zeros(1, 3)]])\n\t    assert df_dRt[0:3, 6:9] == Matrix([[zeros(1, 3)], [zeros(1, 3)], [(gn - gz).transpose()]])\n", "    assert df_dRt[0:3, 9:12] == eye(3, 3)\n\t    assert df_dRt[0:3, 12:15] == -eye(3, 3)\n\t    # Constraint cost\n\t    e = (w_nvs * (R_n * (v_s - g_n) + g_n + t_n)) - q_s\n\t    f = TotalFunction(e)\n\t    # This jacobian is an element of the matrix per column in row major order\n\t    df_dRt = f.diff(R_n, t_n)\n\t    # Compare against ground truth\n\t    vs = Matrix(_MatrixSym(v_s.name, 3, 1))\n\t    qs = Matrix(_MatrixSym(q_s.name, 3, 1))\n", "    rn = Matrix(_MatrixSym(R_n.name, 3, 3))\n\t    w = symbols(\"{w_{n_{(v_s)}}}\")\n\t    fe = f.as_explicit()\n\t    c = (w * (rn * (vs - gn) + gn + tn)) - qs\n\t    assert c == fe.tomatrix()\n\t    assert df_dRt[0:3, 0:3] == Matrix([[w * (vs - gn).transpose()], [zeros(1, 3)], [zeros(1, 3)]])\n\t    assert df_dRt[0:3, 3:6] == Matrix([[zeros(1, 3)], [w * (vs - gn).transpose()], [zeros(1, 3)]])\n\t    assert df_dRt[0:3, 6:9] == Matrix([[zeros(1, 3)], [zeros(1, 3)], [w * (vs - gn).transpose()]])\n\t    assert df_dRt[0:3, 9:12] == w * eye(3, 3)\n"]}
{"filename": "SymE3/numerical.py", "chunked_list": ["import random\n\tfrom sympy import MutableDenseMatrix, Symbol, Matrix, Float, eye, sin, cos\n\tfrom sophus.se3 import Se3\n\tfrom .detail import _Explicit, _MatrixSym\n\tvalues = {}\n\tdef _resetValues():\n\t    if len(values) == 0:\n\t        random.seed(0)\n\tdef _realVal(s):\n\t    if s in values:\n", "        return values[s]\n\t    else:\n\t        value = random.uniform(-1, 1)\n\t        values[s] = value\n\t        return value\n\tdef _getRealMatValue(sym, idx):\n\t    matrix = Matrix(_MatrixSym(sym.name, sym.rows, sym.cols))\n\t    row = int(idx) // int(sym.cols)\n\t    col = int(idx) % int(sym.cols)\n\t    return matrix[row, col], _realVal(matrix[row, col])\n", "def _subAndEvalReal(expression):\n\t    if isinstance(expression, _Explicit):\n\t        expression = expression.tomatrix()\n\t    sub = {}\n\t    # Recursively substitute placeholder values\n\t    def recursiveSub(subExpr):\n\t        if isinstance(subExpr, Symbol):\n\t            sub[subExpr] = _realVal(subExpr)\n\t        elif isinstance(subExpr, Matrix):\n\t            for subSym in subExpr:\n", "                recursiveSub(subSym)\n\t        else:\n\t            for subSym in subExpr.args:\n\t                recursiveSub(subSym)\n\t    recursiveSub(expression)\n\t    # If we have symbols left, they are symbolic functions and we should store their derivatives. \n\t    substituted = expression.evalf(subs=sub)\n\t    substituted = substituted.subs(sub)\n\t    funcValues = {}\n\t    def recursiveEval(subExpr):\n", "        # We have found a symbolic function, manually evaluate a placeholder continuous function\n\t        # and set that as the value of this function at the numerical point\n\t        if isinstance(subExpr, Float):\n\t            return subExpr\n\t        if hasattr(subExpr, \"inRows\") and hasattr(subExpr, \"outRows\"):\n\t            assert subExpr.inRows == len(subExpr.args)\n\t            # Ensure all parameters have a value\n\t            arguments = list(subExpr.args)\n\t            for i in range(len(arguments)):\n\t                if not isinstance(arguments[i], Float):\n", "                    arguments[i] = recursiveEval(arguments[i])\n\t            value = Float(0)\n\t            for arg in arguments:\n\t                value = value + sin(arg)\n\t            # The partial derivative of the func w.r.t. any param is just cos(param), nice!\n\t            for i in range(subExpr.inRows):\n\t                partialSym = subExpr.fdiff(i + 1)\n\t                values[partialSym] = cos(arguments[i])\n\t            funcValues[subExpr] = value\n\t            return value\n", "        else:\n\t            for subSym in subExpr.args:\n\t                recursiveEval(subSym)\n\t    if isinstance(substituted, MutableDenseMatrix):\n\t        for elem in substituted:\n\t            recursiveEval(elem)\n\t    else:\n\t        recursiveEval(substituted)\n\t    substituted = substituted.subs(funcValues)\n\t    if isinstance(substituted, Float):\n", "        return Matrix([[substituted]])\n\t    return substituted\n\tdef _exp(v, perturb):\n\t    mat = Se3.exp(v.as_mutable()).matrix()\n\t    # Work around singularity\n\t    if perturb[3, 0] == 0 and perturb[4, 0] == 0 and perturb[5, 0] == 0:\n\t        mat = eye(4)\n\t        mat[0:3, 3] = perturb[0:3, 0]\n\t    assert v.rows == 6\n\t    assert v.shape == perturb.shape\n", "    sub = {}\n\t    for i in range(6):\n\t        sub[v[i, 0]] = perturb[i, 0]\n\t    return mat.evalf(subs=sub, strict=True)\n"]}
{"filename": "SymE3/__init__.py", "chunked_list": []}
{"filename": "SymE3/core.py", "chunked_list": ["from functools import reduce\n\tfrom typing import Tuple as tTuple\n\tfrom sympy import srepr, MatrixSymbol, Symbol, MatrixExpr, Expr, Matrix, Basic, Function, preorder_traversal, eye, symbols, zeros, oo\n\tfrom sympy.core.sympify import _sympify\n\tfrom .detail import _Type, _PointH, _Point, _NormalH, _Normal, _Pixel, _Plane, _Matrix3, _LieGroup, _LieAlgebra, _ExponentialMap, _Explicit\n\tfrom .parse import _parse\n\tfrom .numerical import _subAndEvalReal, _exp, _getRealMatValue, _realVal, _resetValues\n\tclass TotalFunction:\n\t    def __init__(self, expression):\n\t        self.expression = expression\n", "        self.funcs = {}\n\t        for arg in preorder_traversal(expression):\n\t            if hasattr(arg, \"__explicit__\"):\n\t                self.funcs[type(arg).__name__] = type(arg).__explicit__()\n\t    def _repr_latex_(self):\n\t        return self.expression._repr_latex_()\n\t    def __str__(self):\n\t        return self.expression.__str__()\n\t    def __parseExpression__(self, substituteLieGroup):\n\t        exprTreeStr = srepr(self.expression)\n", "        # Convert exp to a transformation matrix when showing explicitly\n\t        if substituteLieGroup:\n\t            exprTreeStr = exprTreeStr.replace(\"exp(\", \"LieGroupFromExp(\")\n\t        # Replace any custom functions with their explicit call versions\n\t        for name in self.funcs:\n\t            exprTreeStr = exprTreeStr.replace(f\"{name}(\", f\"self.funcs[\\\"{name}\\\"](\")\n\t        # Parse the expression tree so we can make more complicated alterations\n\t        parsed = _parse(exprTreeStr)\n\t        # Custom symbolic functions are evaluated with vector parameters expanded\n\t        # These can be detected as those with a default __new__ function\n", "        for name, func in self.funcs.items():\n\t            if func.__new__ == Function.__new__:\n\t                parsed.wrapChildrenOf(f\"self.funcs[\\\"{name}\\\"]\", \"*Expand\")\n\t        # Remove superfluous parameters\n\t        parsed.removeChildrenFrom(\"Inverse\", \"Integer\")\n\t        parsed.removeChildrenFrom(\"_PixelExpr\", \"Integer\")\n\t        parsed.removeChildrenFrom(\"_PlaneExpr\", \"Integer\")\n\t        parsed.removeChildrenFrom(\"_Matrix3Expr\", \"Integer\")\n\t        parsed.removeChildrenFrom(\"_PointExpr\", \"Integer\")\n\t        parsed.removeChildrenFrom(\"_PointHExpr\", \"Integer\")\n", "        parsed.removeChildrenFrom(\"_NormalExpr\", \"Integer\")\n\t        parsed.removeChildrenFrom(\"_NormalHExpr\", \"Integer\")\n\t        parsed.removeChildrenFrom(\"_LieGroupExpr\", \"Integer\")\n\t        parsed.renameIdentifier(\"_PointExpr\", \"_Point\")\n\t        parsed.renameIdentifier(\"_NormalExpr\", \"_Normal\")\n\t        parsed.renameIdentifier(\"_PointHExpr\", \"_PointH\")\n\t        parsed.renameIdentifier(\"_NormalHExpr\", \"_NormalH\")\n\t        parsed.renameIdentifier(\"_PixelExpr\", \"_Pixel\")\n\t        parsed.renameIdentifier(\"_PlaneExpr\", \"_Plane\")\n\t        parsed.renameIdentifier(\"Symbol\", \"Scalar\")\n", "        parsed.renameIdentifier(\"_Matrix3Expr\", \"_Matrix3\")\n\t        parsed.removeIdentifierPromoteChildren(\"Str\")\n\t        parsed.removeIdentifierPromoteChildren(\"Integer\")\n\t        return parsed\n\t    def __explicit__(self, parsedExpression, expandLieGroupFromExp=False):\n\t        # Define wrapper functions that allow us to convert to non-expression quantities automatically\n\t        def _LieGroupExpr(name, *_):\n\t            return _LieGroup(name)\n\t        def LieGroupFromExp(name, *_):\n\t            if expandLieGroupFromExp:\n", "                return _LieGroup(name)\n\t            else:\n\t                return _Explicit(eye(4))\n\t        def MatMul(*args):\n\t            return reduce((lambda x, y: x * y), args)\n\t        def MatAdd(*args):\n\t            return reduce((lambda x, y: x + y), args)\n\t        def Transpose(a):\n\t            return a.transpose()\n\t        def Inverse(a):\n", "            return a.inverse()\n\t        def Rational(a, b):\n\t            return a / b\n\t        def Expand(a):\n\t            return ( a[i, 0] for i in range(a.shape[0]) )\n\t        def exp(name):\n\t            return _ExponentialMap(name)(_LieAlgebra(name))\n\t        def dehom(a):\n\t            if hasattr(a, \"type\"):\n\t                if a.type == _Type.POINTH or a.type == _Type.NORMALH:\n", "                    return _Explicit([[a[0, 0]], [a[1, 0]], [a[2, 0]]])\n\t            return a\n\t        return eval(parsedExpression.reconstruct())\n\t    def as_explicit(self):\n\t        return self.__explicit__(self.__parseExpression__(True))\n\t    def diff(self, *args):\n\t        combinedResult = None\n\t        parsedExpression = self.__parseExpression__(False)\n\t        # Substitute all exp() with the identity, assuming we're linearizing around 0.\n\t        lieAlgebras = []\n", "        lieAlgebras = parsedExpression.findIdentifiers(\"_LieAlgebraExpr\", lieAlgebras)\n\t        _resetValues()\n\t        for arg in args:\n\t            result = None\n\t            explicitExpr = self.__explicit__(parsedExpression)\n\t            if isinstance(arg, _LieAlgebraExpr):\n\t                result = explicitExpr.diff(_LieAlgebra(arg.name))\n\t            elif isinstance(arg, MatrixExpr):\n\t                result = explicitExpr.diff(TotalFunction(arg).as_explicit())\n\t            else:\n", "                result = explicitExpr.diff(arg)\n\t            for matches in lieAlgebras:\n\t                lieAlgebra =_LieAlgebra(matches.children[0].__str__().strip(\"'\").replace(\"\\\\\\\\\", \"\\\\\"))\n\t                for symbol in lieAlgebra:\n\t                    result = result.subs(symbol[0], 0)\n\t            if len(result.shape) == 4 and result != _ExponentialMap(\"\")(_LieAlgebra(\"\")).diff(_LieAlgebra(\"\")):\n\t                # This means a derivative was taken w.r.t. a matrix or vector, so we must reshape the output\n\t                # Everything is flatten using row-major ordering\n\t                rows = result.shape[0] * result.shape[1]\n\t                cols = result.shape[2] * result.shape[3]\n", "                result = result.reshape(rows, cols)\n\t            if isinstance(arg, Symbol):\n\t                result = result.transpose()\n\t            if combinedResult is not None or len(result.shape) == 2:\n\t                result = result.transpose().tomatrix()\n\t            # Perform numerical substitution and evaluation to compare to numerical jacobian\n\t            if len(result.shape) == 2:\n\t                # Evaluate the function at zero \n\t                # Bit of stateful nastiness here as this will populate the placeholder numerical \n\t                # derivatives of any supplied symbolic functions, meaning it has to be called before\n", "                # the real evaluation of the derived jacobian is called. \n\t                fx = _subAndEvalReal(self.as_explicit())\n\t                numericalJacobian = zeros(result.rows, result.cols)\n\t                # Now, perform the numerical jacobian estimation process\n\t                eps = 1e-8\n\t                for col in range(numericalJacobian.cols):\n\t                    explicitExpr = self.__explicit__(self.__parseExpression__(True),\\\n\t                            isinstance(arg, _LieAlgebraExpr))\n\t                    if isinstance(explicitExpr, _Explicit):\n\t                        explicitExpr = explicitExpr.tomatrix()\n", "                    if isinstance(arg, _LieAlgebraExpr):\n\t                        lieGroupMat = _LieGroup(arg.name).tomatrix()\n\t                        tangent = Matrix([0, 0, 0, 0, 0, 0]).transpose()\n\t                        tangent[0, col] = eps\n\t                        realValue = _exp(_LieAlgebra(arg.name).tomatrix(), tangent.transpose())\n\t                        tangent[0, col] = 0\n\t                        # Substitute the perturbed matrix values in\n\t                        for r in range(lieGroupMat.rows):\n\t                            for c in range(lieGroupMat.cols):\n\t                                explicitExpr = explicitExpr.subs(lieGroupMat[r, c], realValue[r, c])\n", "                    elif isinstance(arg, MatrixExpr):\n\t                        if isinstance(arg, dehom):\n\t                            arg = arg.args[0]\n\t                        sym, realValue = _getRealMatValue(arg, col)\n\t                        explicitExpr = explicitExpr.subs(sym, realValue + eps)\n\t                    elif isinstance(arg, Symbol):\n\t                        explicitExpr = explicitExpr.subs(arg, _realVal(arg) + eps)\n\t                    else:\n\t                        assert False\n\t                    numericalJacobian[:, col] = (_subAndEvalReal(explicitExpr) - fx) / eps\n", "                derivedJacobian = _subAndEvalReal(result)\n\t                difference = (derivedJacobian - numericalJacobian).norm(oo)\n\t                assert difference < 1e-6\n\t            if combinedResult is None:\n\t                combinedResult = result\n\t            else:\n\t                combinedResult = combinedResult.col_insert(combinedResult.cols, result)\n\t        return combinedResult\n\tdef SymbolicFunction(name, inRows, outRows):\n\t    @classmethod\n", "    def __explicit__(cls):\n\t        def fdiff(self, argindex):\n\t            paramLabel = argindex - 1\n\t            if inRows < 4:\n\t                paramLabel = [\"x\", \"y\", \"z\"][argindex - 1]\n\t            return symbols(f\"{{{{\\\\Delta}}{name}}}_{{{paramLabel}}}\")\n\t        def diff(self, *symbols, **assumptions):\n\t            if hasattr(symbols[0], \"shape\") and len(symbols[0].shape) == inRows:\n\t                return super(Function, self).diff(symbols[0].transpose(), **assumptions)\n\t            else:\n", "                return super(Function, self).diff(symbols[0], **assumptions)\n\t        return type(f\"{cls.__name__}\", (Function, ), \\\n\t                {\"fdiff\": fdiff, \"diff\": diff, \"inRows\": inRows, \"outRows\": outRows});\n\t    @property\n\t    def shape(self) -> tTuple[Expr, Expr]:\n\t        return (outRows, 1)\n\t    return type(f\"{name}\", (MatrixExpr, ), {\"shape\": shape, \"__explicit__\": __explicit__});\n\tdef CustomFunction(name, func, inRows, outRows, inCols = 1, outCols = 1):\n\t    @classmethod\n\t    def __explicit__(cls):\n", "        def new(self, p):\n\t            assert p.shape == (inRows, inCols)\n\t            if hasattr(p, \"tomatrix\"):\n\t                p = p.tomatrix()\n\t            return _Explicit(func(p))\n\t        return type(f\"{cls.__name__}\", (Function, ), {\"__new__\": new});\n\t    @property\n\t    def shape(self) -> tTuple[Expr, Expr]:\n\t        return (outRows, outCols)\n\t    return type(f\"{name}\", (MatrixExpr, ), {\"shape\": shape, \"__explicit__\": __explicit__});\n", "class exp(MatrixExpr):\n\t    def __new__(cls, *args, **kwargs):\n\t        if len(args) == 1 and isinstance(args[0], log):\n\t            return args[0].arguments[0]\n\t        arguments = args\n\t        args = map(_sympify, args)\n\t        self = Basic.__new__(cls, *args, **kwargs)\n\t        self.arguments = arguments\n\t        return self\n\t    @property\n", "    def shape(self) -> tTuple[Expr, Expr]:\n\t        return (4, 4)\n\tclass log(MatrixExpr):\n\t    def __new__(cls, *args, **kwargs):\n\t        if len(args) == 1 and isinstance(args[0], exp):\n\t            return args[0].arguments[0]\n\t        arguments = args\n\t        args = map(_sympify, args)\n\t        self = Basic.__new__(cls, *args, **kwargs)\n\t        self.arguments = arguments\n", "        return self\n\t    @property\n\t    def shape(self) -> tTuple[Expr, Expr]:\n\t        return (6, 1)\n\tclass dehom(MatrixExpr):\n\t    @property\n\t    def shape(self) -> tTuple[Expr, Expr]:\n\t        return (3, 1)\n\tdef Point(name):\n\t    return _PointExpr(name, 3, 1)\n", "def PointH(name):\n\t    return _PointHExpr(name, 4, 1)\n\tdef Normal(name):\n\t    return _NormalExpr(name, 3, 1)\n\tdef NormalH(name):\n\t    return _NormalHExpr(name, 4, 1)\n\tdef Pixel(name):\n\t    return _PixelExpr(name, 2, 1)\n\tdef Plane(name):\n\t    return _PlaneExpr(name, 4, 1)\n", "def Scalar(name):\n\t    return symbols(name)\n\tdef Matrix3(name):\n\t    return _Matrix3Expr(name, 3, 3)\n\tdef LieAlgebra(name):\n\t    return _LieAlgebraExpr(name, 6, 1)\n\tdef LieGroup(name):\n\t    return _LieGroupExpr(name, 4, 4)\n\tclass _PointExpr(MatrixSymbol):\n\t    pass\n", "class _PointHExpr(MatrixSymbol):\n\t    pass\n\tclass _NormalExpr(MatrixSymbol):\n\t    pass\n\tclass _NormalHExpr(MatrixSymbol):\n\t    pass\n\tclass _PixelExpr(MatrixSymbol):\n\t    pass\n\tclass _PlaneExpr(MatrixSymbol):\n\t    pass\n", "class _Matrix3Expr(MatrixSymbol):\n\t    pass\n\tclass _LieAlgebraExpr(MatrixSymbol):\n\t    pass\n\tclass _LieGroupExpr(MatrixSymbol):\n\t    pass\n"]}
{"filename": "SymE3/detail.py", "chunked_list": ["from enum import Enum\n\tfrom sympy import symbols, tensorproduct, tensorcontraction, transpose, Function\n\tfrom sympy.tensor.array.dense_ndim_array import ImmutableDenseNDimArray\n\tclass _Type(Enum):\n\t    POINTH, NORMALH = range(2)\n\tdef _MatrixSym(prefix, R, C):\n\t    M = []\n\t    for r in range (0, R):\n\t        Row = []\n\t        for c in range (0, C):\n", "            name = '{{{0}_{{{1}{2}}}}}'.format(prefix, r if (R > 1) else '', c if (C > 1) else '' )\n\t            Row.append(symbols(name))\n\t        M.append(Row)\n\t    return M\n\tdef _PointH(name):\n\t    vector = _MatrixSym(name, 3, 1)\n\t    vector.append([1])\n\t    result = _Explicit(vector)\n\t    result.type = _Type.POINTH\n\t    return result\n", "def _NormalH(name):\n\t    vector = _MatrixSym(name, 3, 1)\n\t    vector.append([0])\n\t    result = _Explicit(vector)\n\t    result.type = _Type.NORMALH\n\t    return result\n\tdef _Point(name):\n\t    return _Explicit(_MatrixSym(name, 3, 1))\n\tdef _Normal(name):\n\t    return _Explicit(_MatrixSym(name, 3, 1))\n", "def _Pixel(name):\n\t    return _Explicit(_MatrixSym(name, 2, 1))\n\tdef _Plane(name):\n\t    return _Explicit(_MatrixSym(name, 4, 1))\n\tdef _Matrix3(name):\n\t    return _Explicit(_MatrixSym(name, 3, 3))\n\tdef _LieAlgebra(name):\n\t    return _Explicit(_MatrixSym(name, 6, 1))\n\tdef _LieGroup(name):\n\t    syms = _MatrixSym(name, 4, 4)\n", "    syms[3][0] = 0\n\t    syms[3][1] = 0\n\t    syms[3][2] = 0\n\t    syms[3][3] = 1\n\t    return _Explicit(syms)\n\tdef _ExponentialMap(name):\n\t    def new(self, d):\n\t        assert d.shape == (6, 1)\n\t        return _Explicit([[       1, -d[5, 0],  d[4, 0], d[0, 0]], \n\t                          [ d[5, 0],        1, -d[3, 0], d[1, 0]], \n", "                          [-d[4, 0],  d[3, 0],        1, d[2, 0]], \n\t                          [       0,        0,        0,      1]])\n\t    exp = type(f\"exp_{name}\", (Function, ), {\"__new__\": new})\n\t    return exp;\n\tclass _Explicit(ImmutableDenseNDimArray):\n\t    def diff(self, *args, **kwargs):\n\t        if isinstance(args[0], list):\n\t            for symbol in args[0]:\n\t                if (isinstance(symbol, list) and (symbol[0] == 0 or symbol[0] == 1)) \\\n\t                        or (symbol == 0 or symbol == 1):\n", "                    print(\"Scalar detected in diff input, did you forget to dehom?\")\n\t        result = super().diff(*args, **kwargs)\n\t        if hasattr(args[0], \"rank\"):\n\t            # Catch the edge case where matrix differentiation doesn't work for some reason\n\t            if result.rank() != 4 and args[0].rank() == 2 and self.rank() == 2:\n\t                result = self.tomatrix().diff(args[0].tomatrix())\n\t        if result.rank() == 4 and result.shape[1] == 1 and result.shape[3] == 1:\n\t            result = tensorcontraction(result, (1, 3))\n\t        return _Explicit(result)\n\t    def __new__(cls, iterable, shape=None, **kwargs):\n", "        self = super().__new__(cls, iterable, shape, **kwargs)\n\t        self.type = None\n\t        return self\n\t    def __mul__(self, other):\n\t        result = _Explicit(tensorcontraction(tensorproduct(self, other), (1, 2)))\n\t        if hasattr(other, \"type\") and result.shape == (4, 1):\n\t            result.type = other.type\n\t        return result\n\t    def __rmul__(self, other):\n\t        result = _Explicit(super().__rmul__(other))\n", "        if hasattr(self, \"type\"):\n\t            if self.type == _Type.POINTH and result.shape == (4, 1):\n\t                explicit = result.tomatrix()\n\t                explicit[3, 0] = 1\n\t                result = _Explicit(explicit)\n\t                result.type = _Type.POINTH\n\t        return result\n\t    def __add__(self, other):\n\t        result = _Explicit(super().__add__(other))\n\t        if hasattr(self, \"type\") and hasattr(other, \"type\"):\n", "            assert self.type == other.type\n\t            if self.type == _Type.POINTH:\n\t                explicit = result.tomatrix()\n\t                explicit[3, 0] = 1\n\t                result = _Explicit(explicit)\n\t                result.type = _Type.POINTH\n\t        return result\n\t    def transpose(self):\n\t        return _Explicit(transpose(self))\n\t    def inverse(self):\n", "        return _Explicit(self.tomatrix().inv())\n"]}
{"filename": "SymE3/parse.py", "chunked_list": ["class _ParsedToken:\n\t    def __init__(self, identifier):\n\t        self.identifier = identifier\n\t        self.children = []\n\t    def hasChildren(self):\n\t        return len(self.children) > 0\n\t    def addChild(self, child):\n\t        self.children.append(child)\n\t    def removeChildrenFrom(self, parentId, childId):\n\t        if self.identifier == parentId:\n", "            self.children = [child for child in self.children if child.identifier != childId]\n\t        for child in self.children:\n\t            child.removeChildrenFrom(parentId, childId)\n\t    def wrapChildrenOf(self, parentId, wrapId):\n\t        if self.identifier == parentId:\n\t            existingChildren = self.children\n\t            self.children = []\n\t            for child in existingChildren:\n\t                token = _ParsedToken(wrapId)\n\t                token.addChild(child)\n", "                self.addChild(token)\n\t        for child in self.children:\n\t            child.wrapChildrenOf(parentId, wrapId)\n\t    def removeIdentifierPromoteChildren(self, id):\n\t        prevChildren = self.children\n\t        self.children = []\n\t        for child in prevChildren:\n\t            if child.identifier == id:\n\t                for grandchild in child.children:\n\t                    self.addChild(grandchild)\n", "            else:\n\t                self.addChild(child)\n\t        for child in self.children:\n\t            child.removeIdentifierPromoteChildren(id)\n\t    def renameIdentifier(self, src, dest):\n\t        if self.identifier == src:\n\t            self.identifier = dest\n\t        for child in self.children:\n\t            child.renameIdentifier(src, dest)\n\t    def findIdentifiers(self, id, matches):\n", "        if self.identifier == id:\n\t            matches.append(self)\n\t        for child in self.children:\n\t            matches = child.findIdentifiers(id, matches)\n\t        return matches\n\t    def reconstruct(self):\n\t        result = self.identifier\n\t        if len(self.children) > 0:\n\t            result += \"(\"\n\t        for i in range(0, len(self.children)):\n", "            result += self.children[i].reconstruct()\n\t            if i != len(self.children) - 1:\n\t                result += \", \"\n\t        if len(self.children) > 0:\n\t            result += \")\"\n\t        return result\n\t    def __repr__(self):\n\t        if len(self.children) > 0:\n\t            return f\"{self.identifier}:{self.children}\"\n\t        else:\n", "            return f\"{self.identifier}\"\n\t    def __str__(self):\n\t        return self.__repr__()\n\tdef _scanForOpeningParenthesis(input):\n\t    idx = 0\n\t    while idx < len(input):\n\t        if input[idx] == \"(\":\n\t            return idx\n\t        idx = idx + 1\n\t    return -1\n", "def _scanForClosingParenthesis(input):\n\t    stack = []\n\t    idx = 0\n\t    while idx < len(input):\n\t        if input[idx] == \"(\":\n\t            stack.append(\"(\")\n\t        elif input[idx] == \")\" and stack[-1] == \"(\":\n\t            stack.pop()\n\t        if len(stack) == 0:\n\t            return idx\n", "        idx = idx + 1\n\t    return -1\n\tdef _splitOnCommas(input):\n\t    result = []\n\t    lastStart = 0\n\t    stack = []\n\t    idx = 0\n\t    while idx < len(input):\n\t        if input[idx] == \"(\":\n\t            stack.append(\"(\")\n", "        elif input[idx] == \")\" and stack[-1] == \"(\":\n\t            stack.pop()\n\t        if len(stack) == 0 and input[idx] == \",\":\n\t            result.append(input[lastStart:idx])\n\t            lastStart = idx + 1\n\t        idx = idx + 1\n\t    result.append(input[lastStart:len(input)])\n\t    return result\n\tdef _parse(expression):\n\t    openingParenthesisIdx = _scanForOpeningParenthesis(expression)\n", "    closingParenthesisIdx = _scanForClosingParenthesis(expression[openingParenthesisIdx:]) + openingParenthesisIdx\n\t    if (openingParenthesisIdx == -1 and closingParenthesisIdx == -1) \\\n\t            or (expression.startswith(\"'\") and expression.endswith(\"'\") and expression.count(\"'\") == 2 \\\n\t            and expression.count('\"') == 0) \\\n\t            or (expression.startswith('\"') and expression.endswith('\"') and expression.count('\"') == 2 \\\n\t            and expression.count(\"'\") == 0):\n\t        return _ParsedToken(expression)\n\t    identifier = expression[0:openingParenthesisIdx]\n\t    params = _splitOnCommas(expression[openingParenthesisIdx + 1:closingParenthesisIdx])\n\t    token = _ParsedToken(identifier)\n", "    for param in params:\n\t        token.addChild(_parse(param.strip()))\n\t    assert token.reconstruct() == expression\n\t    return token\n"]}
{"filename": "sophus/cse_codegen.py", "chunked_list": ["import io\n\timport sympy\n\tdef cse_codegen(symbols):\n\t    cse_results = sympy.cse(symbols, sympy.numbered_symbols(\"c\"))\n\t    output = io.StringIO()\n\t    for helper in cse_results[0]:\n\t        output.write(\"Scalar const \")\n\t        output.write(sympy.printing.ccode(helper[1], helper[0]))\n\t        output.write(\"\\n\")\n\t    assert len(cse_results[1]) == 1\n", "    output.write(sympy.printing.ccode(cse_results[1][0], \"result\"))\n\t    output.write(\"\\n\")\n\t    output.seek(0)\n\t    return output\n"]}
{"filename": "sophus/so3.py", "chunked_list": ["import functools\n\timport unittest\n\timport sympy\n\tfrom sophus.cse_codegen import cse_codegen\n\tfrom sophus.matrix import Vector3\n\tfrom sophus.matrix import ZeroVector3\n\tfrom sophus.matrix import squared_norm\n\tfrom sophus.quaternion import Quaternion\n\tclass So3:\n\t    \"\"\" 3 dimensional group of orthogonal matrices with determinant 1 \"\"\"\n", "    def __init__(self, q):\n\t        \"\"\" internally represented by a unit quaternion q \"\"\"\n\t        self.q = q\n\t    @staticmethod\n\t    def exp(v):\n\t        \"\"\" exponential map \"\"\"\n\t        theta_sq = squared_norm(v)\n\t        theta = sympy.sqrt(theta_sq)\n\t        return So3(\n\t            Quaternion(\n", "                sympy.cos(0.5 * theta),\n\t                sympy.sin(0.5 * theta) / theta * v))\n\t    def log(self):\n\t        \"\"\" logarithmic map\"\"\"\n\t        n = sympy.sqrt(squared_norm(self.q.vec))\n\t        return 2 * sympy.atan(n / self.q.real) / n * self.q.vec\n\t    def calc_Dx_log_this(self):\n\t        return sympy.Matrix(3, 3, lambda r, c: sympy.diff(self.log()[r],\n\t                                                          self[c]))\n\t    def calc_Dx_log_exp_x_times_this_at_0(self, x):\n", "        return sympy.Matrix(3, 3, lambda r, c:\n\t                            sympy.diff((So3.exp(x)*self).log()[r], x[c])).subs(\n\t                            x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\t    def __repr__(self):\n\t        return \"So3:\" + repr(self.q)\n\t    def inverse(self):\n\t        return So3(self.q.conj())\n\t    @staticmethod\n\t    def hat(o):\n\t        return sympy.Matrix([[0, -o[2], o[1]],\n", "                             [o[2], 0, -o[0]],\n\t                             [-o[1], o[0], 0]])\n\t    \"\"\"vee-operator\n\t    It takes the 3x3-matrix representation ``Omega`` and maps it to the\n\t    corresponding vector representation of Lie algebra.\n\t    This is the inverse of the hat-operator, see above.\n\t    Precondition: ``Omega`` must have the following structure:\n\t                   |  0 -c  b |\n\t                   |  c  0 -a |\n\t                   | -b  a  0 |\n", "    \"\"\"\n\t    @staticmethod\n\t    def vee(Omega):\n\t        v = Vector3(Omega.row(2).col(1),\n\t                    Omega.row(0).col(2),\n\t                    Omega.row(1).col(0))\n\t        return v\n\t    def matrix(self):\n\t        \"\"\" returns matrix representation \"\"\"\n\t        return sympy.Matrix([[\n", "            1 - 2 * self.q.vec[1]**2 - 2 * self.q.vec[2]**2,\n\t            2 * self.q.vec[0] * self.q.vec[1] -\n\t            2 * self.q.vec[2] * self.q[3],\n\t            2 * self.q.vec[0] * self.q.vec[2] +\n\t            2 * self.q.vec[1] * self.q[3]\n\t        ], [\n\t            2 * self.q.vec[0] * self.q.vec[1] +\n\t            2 * self.q.vec[2] * self.q[3],\n\t            1 - 2 * self.q.vec[0]**2 - 2 * self.q.vec[2]**2,\n\t            2 * self.q.vec[1] * self.q.vec[2] -\n", "            2 * self.q.vec[0] * self.q[3]\n\t        ], [\n\t            2 * self.q.vec[0] * self.q.vec[2] -\n\t            2 * self.q.vec[1] * self.q[3],\n\t            2 * self.q.vec[1] * self.q.vec[2] +\n\t            2 * self.q.vec[0] * self.q[3],\n\t            1 - 2 * self.q.vec[0]**2 - 2 * self.q.vec[1]**2\n\t        ]])\n\t    def __mul__(self, right):\n\t        \"\"\" left-multiplication\n", "            either rotation concatenation or point-transform \"\"\"\n\t        if isinstance(right, sympy.Matrix):\n\t            assert right.shape == (3, 1), right.shape\n\t            return (self.q * Quaternion(0, right) * self.q.conj()).vec\n\t        elif isinstance(right, So3):\n\t            return So3(self.q * right.q)\n\t        assert False, \"unsupported type: {0}\".format(type(right))\n\t    def __getitem__(self, key):\n\t        return self.q[key]\n\t    @staticmethod\n", "    def calc_Dx_exp_x(x):\n\t        return sympy.Matrix(4, 3, lambda r, c:\n\t                            sympy.diff(So3.exp(x)[r], x[c]))\n\t    @staticmethod\n\t    def Dx_exp_x_at_0():\n\t        return sympy.Matrix([[0.5, 0.0, 0.0],\n\t                             [0.0, 0.5, 0.0],\n\t                             [0.0, 0.0, 0.5],\n\t                             [0.0, 0.0, 0.0]])\n\t    @staticmethod\n", "    def calc_Dx_exp_x_at_0(x):\n\t        return So3.calc_Dx_exp_x(x).subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\t    def calc_Dx_this_mul_exp_x_at_0(self, x):\n\t        return sympy.Matrix(4, 3, lambda r, c:\n\t                            sympy.diff((self * So3.exp(x))[r], x[c]))\\\n\t            .subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\t    def calc_Dx_exp_x_mul_this_at_0(self, x):\n\t        return sympy.Matrix(3, 4, lambda r, c:\n\t                            sympy.diff((self * So3.exp(x))[c], x[r, 0]))\\\n\t            .subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n", "    @staticmethod\n\t    def Dxi_x_matrix(x, i):\n\t        if i == 0:\n\t            return sympy.Matrix([[0, 2 * x[1], 2 * x[2]],\n\t                                 [2 * x[1], -4 * x[0], -2 * x[3]],\n\t                                 [2 * x[2], 2 * x[3], -4 * x[0]]])\n\t        if i == 1:\n\t            return sympy.Matrix([[-4 * x[1], 2 * x[0], 2 * x[3]],\n\t                                 [2 * x[0], 0, 2 * x[2]],\n\t                                 [-2 * x[3], 2 * x[2], -4 * x[1]]])\n", "        if i == 2:\n\t            return sympy.Matrix([[-4 * x[2], -2 * x[3], 2 * x[0]],\n\t                                 [2 * x[3], -4 * x[2], 2 * x[1]],\n\t                                 [2 * x[0], 2 * x[1], 0]])\n\t        if i == 3:\n\t            return sympy.Matrix([[0, -2 * x[2], 2 * x[1]],\n\t                                 [2 * x[2], 0, -2 * x[0]],\n\t                                 [-2 * x[1], 2 * x[0], 0]])\n\t    @staticmethod\n\t    def calc_Dxi_x_matrix(x, i):\n", "        return sympy.Matrix(3, 3, lambda r, c:\n\t                            sympy.diff(x.matrix()[r, c], x[i]))\n\t    @staticmethod\n\t    def Dxi_exp_x_matrix(x, i):\n\t        R = So3.exp(x)\n\t        Dx_exp_x = So3.calc_Dx_exp_x(x)\n\t        list = [Dx_exp_x[j, i] * So3.Dxi_x_matrix(R, j) for j in [0, 1, 2, 3]]\n\t        return functools.reduce((lambda a, b: a + b), list)\n\t    @staticmethod\n\t    def calc_Dxi_exp_x_matrix(x, i):\n", "        return sympy.Matrix(3, 3, lambda r, c:\n\t                            sympy.diff(So3.exp(x).matrix()[r, c], x[i]))\n\t    @staticmethod\n\t    def Dxi_exp_x_matrix_at_0(i):\n\t        v = ZeroVector3()\n\t        v[i] = 1\n\t        return So3.hat(v)\n\t    @staticmethod\n\t    def calc_Dxi_exp_x_matrix_at_0(x, i):\n\t        return sympy.Matrix(3, 3, lambda r, c:\n", "                            sympy.diff(So3.exp(x).matrix()[r, c], x[i])\n\t                            ).subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\tclass TestSo3(unittest.TestCase):\n\t    def setUp(self):\n\t        omega0, omega1, omega2 = sympy.symbols(\n\t            'omega[0], omega[1], omega[2]', real=True)\n\t        x, v0, v1, v2 = sympy.symbols('q.w() q.x() q.y() q.z()', real=True)\n\t        p0, p1, p2 = sympy.symbols('p0 p1 p2', real=True)\n\t        v = Vector3(v0, v1, v2)\n\t        self.omega = Vector3(omega0, omega1, omega2)\n", "        self.a = So3(Quaternion(x, v))\n\t        self.p = Vector3(p0, p1, p2)\n\t    def test_exp_log(self):\n\t        for o in [Vector3(0., 1, 0.5),\n\t                  Vector3(0.1, 0.1, 0.1),\n\t                  Vector3(0.01, 0.2, 0.03)]:\n\t            w = So3.exp(o).log()\n\t            for i in range(0, 3):\n\t                self.assertAlmostEqual(o[i], w[i])\n\t    def test_matrix(self):\n", "        R_foo_bar = So3.exp(self.omega)\n\t        Rmat_foo_bar = R_foo_bar.matrix()\n\t        point_bar = self.p\n\t        p1_foo = R_foo_bar * point_bar\n\t        p2_foo = Rmat_foo_bar * point_bar\n\t        self.assertEqual(sympy.simplify(p1_foo - p2_foo),\n\t                         ZeroVector3())\n\t    def test_derivatives(self):\n\t        self.assertEqual(sympy.simplify(So3.calc_Dx_exp_x_at_0(self.omega) -\n\t                                        So3.Dx_exp_x_at_0()),\n", "                         sympy.Matrix.zeros(4, 3))\n\t        for i in [0, 1, 2, 3]:\n\t            self.assertEqual(sympy.simplify(So3.calc_Dxi_x_matrix(self.a, i) -\n\t                                            So3.Dxi_x_matrix(self.a, i)),\n\t                             sympy.Matrix.zeros(3, 3))\n\t        for i in [0, 1, 2]:\n\t            self.assertEqual(sympy.simplify(\n\t                So3.Dxi_exp_x_matrix(self.omega, i) -\n\t                So3.calc_Dxi_exp_x_matrix(self.omega, i)),\n\t                sympy.Matrix.zeros(3, 3))\n", "            self.assertEqual(sympy.simplify(\n\t                So3.Dxi_exp_x_matrix_at_0(i) -\n\t                So3.calc_Dxi_exp_x_matrix_at_0(self.omega, i)),\n\t                sympy.Matrix.zeros(3, 3))\n\t    def test_codegen(self):\n\t        stream = cse_codegen(So3.calc_Dx_exp_x(self.omega))\n\t        filename = \"cpp_gencode/So3_Dx_exp_x.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n", "            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n", "        stream = cse_codegen(\n\t            self.a.calc_Dx_this_mul_exp_x_at_0(self.omega))\n\t        filename = \"cpp_gencode/So3_Dx_this_mul_exp_x_at_0.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n", "            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n\t        stream = cse_codegen(self.a.calc_Dx_log_this())\n\t        filename = \"cpp_gencode/So3_Dx_log_this.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n", "            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n", "        stream.close\n\t        stream = cse_codegen(self.a.calc_Dx_log_exp_x_times_this_at_0(\n\t                               self.omega))\n\t        filename = \"cpp_gencode/So3_Dx_log_exp_x_times_this_at_0.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n\t            file.close()\n", "        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "sophus/__init__.py", "chunked_list": []}
{"filename": "sophus/se2.py", "chunked_list": ["import functools\n\timport unittest\n\timport sympy\n\tfrom sophus.complex import Complex\n\tfrom sophus.cse_codegen import cse_codegen\n\tfrom sophus.matrix import Vector2\n\tfrom sophus.matrix import Vector3\n\tfrom sophus.matrix import ZeroVector2\n\tfrom sophus.matrix import ZeroVector3\n\tfrom sophus.matrix import proj\n", "from sophus.matrix import unproj\n\tfrom sophus.so2 import So2\n\tclass Se2:\n\t    \"\"\" 2 dimensional group of rigid body transformations \"\"\"\n\t    def __init__(self, so2, t):\n\t        \"\"\" internally represented by a unit complex number z and a translation\n\t            2-vector \"\"\"\n\t        self.so2 = so2\n\t        self.t = t\n\t    @staticmethod\n", "    def exp(v):\n\t        \"\"\" exponential map \"\"\"\n\t        theta = v[2]\n\t        so2 = So2.exp(theta)\n\t        a = so2.z.imag / theta\n\t        b = (1 - so2.z.real) / theta\n\t        t = Vector2(a * v[0] - b * v[1],\n\t                    b * v[0] + a * v[1])\n\t        return Se2(so2, t)\n\t    def log(self):\n", "        theta = self.so2.log()\n\t        halftheta = 0.5 * theta\n\t        a = -(halftheta * self.so2.z.imag) / (self.so2.z.real - 1)\n\t        V_inv = sympy.Matrix([[a, halftheta],\n\t                              [-halftheta, a]])\n\t        upsilon = V_inv * self.t\n\t        return Vector3(upsilon[0], upsilon[1], theta)\n\t    def calc_Dx_log_this(self):\n\t        return sympy.Matrix(3, 4, lambda r, c: sympy.diff(self.log()[r],\n\t                            self[c]))\n", "    def __repr__(self):\n\t        return \"Se2: [\" + repr(self.so2) + \" \" + repr(self.t)\n\t    @staticmethod\n\t    def hat(v):\n\t        upsilon = Vector2(v[0], v[1])\n\t        theta = v[2]\n\t        return So2.hat(theta).\\\n\t            row_join(upsilon).\\\n\t            col_join(sympy.Matrix.zeros(1, 3))\n\t    def matrix(self):\n", "        \"\"\" returns matrix representation \"\"\"\n\t        R = self.so2.matrix()\n\t        return (R.row_join(self.t)).col_join(sympy.Matrix(1, 3, [0, 0, 1]))\n\t    def __mul__(self, right):\n\t        \"\"\" left-multiplication\n\t            either rotation concatenation or point-transform \"\"\"\n\t        if isinstance(right, sympy.Matrix):\n\t            assert right.shape == (2, 1), right.shape\n\t            return self.so2 * right + self.t\n\t        elif isinstance(right, Se2):\n", "            return Se2(self.so2 * right.so2,\n\t                       self.t + self.so2 * right.t)\n\t        assert False, \"unsupported type: {0}\".format(type(right))\n\t    def __getitem__(self, key):\n\t        \"\"\" We use the following convention [q0, q1, q2, q3, t0, t1, t2] \"\"\"\n\t        assert (key >= 0 and key < 4)\n\t        if key < 2:\n\t            return self.so2[key]\n\t        else:\n\t            return self.t[key - 2]\n", "    @staticmethod\n\t    def calc_Dx_exp_x(x):\n\t        return sympy.Matrix(4, 3, lambda r, c:\n\t                            sympy.diff(Se2.exp(x)[r], x[c]))\n\t    @staticmethod\n\t    def Dx_exp_x_at_0():\n\t        return sympy.Matrix([[0, 0, 0],\n\t                             [0, 0, 1],\n\t                             [1, 0, 0],\n\t                             [0, 1, 0]])\n", "    def calc_Dx_this_mul_exp_x_at_0(self, x):\n\t        return sympy.Matrix(4, 3, lambda r, c:\n\t                            sympy.diff((self * Se2.exp(x))[r], x[c])). \\\n\t            subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\t    @staticmethod\n\t    def calc_Dx_exp_x_at_0(x):\n\t        return Se2.calc_Dx_exp_x(x).subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n\t    @staticmethod\n\t    def Dxi_x_matrix(x, i):\n\t        if i < 2:\n", "            return So2.Dxi_x_matrix(x, i).\\\n\t                row_join(sympy.Matrix.zeros(2, 1)).\\\n\t                col_join(sympy.Matrix.zeros(1, 3))\n\t        M = sympy.Matrix.zeros(3, 3)\n\t        M[i - 2, 2] = 1\n\t        return M\n\t    @staticmethod\n\t    def calc_Dxi_x_matrix(x, i):\n\t        return sympy.Matrix(3, 3, lambda r, c:\n\t                            sympy.diff(x.matrix()[r, c], x[i]))\n", "    @staticmethod\n\t    def Dxi_exp_x_matrix(x, i):\n\t        T = Se2.exp(x)\n\t        Dx_exp_x = Se2.calc_Dx_exp_x(x)\n\t        list = [Dx_exp_x[j, i] * Se2.Dxi_x_matrix(T, j) for j in range(0, 4)]\n\t        return functools.reduce((lambda a, b: a + b), list)\n\t    @staticmethod\n\t    def calc_Dxi_exp_x_matrix(x, i):\n\t        return sympy.Matrix(3, 3, lambda r, c:\n\t                            sympy.diff(Se2.exp(x).matrix()[r, c], x[i]))\n", "    @staticmethod\n\t    def Dxi_exp_x_matrix_at_0(i):\n\t        v = ZeroVector3()\n\t        v[i] = 1\n\t        return Se2.hat(v)\n\t    @staticmethod\n\t    def calc_Dxi_exp_x_matrix_at_0(x, i):\n\t        return sympy.Matrix(3, 3, lambda r, c:\n\t                            sympy.diff(Se2.exp(x).matrix()[r, c], x[i])\n\t                            ).subs(x[0], 0).subs(x[1], 0).limit(x[2], 0)\n", "class TestSe2(unittest.TestCase):\n\t    def setUp(self):\n\t        upsilon0, upsilon1, theta = sympy.symbols(\n\t            'upsilon[0], upsilon[1], theta',\n\t            real=True)\n\t        x, y = sympy.symbols('c[0] c[1]', real=True)\n\t        p0, p1 = sympy.symbols('p0 p1', real=True)\n\t        t0, t1 = sympy.symbols('t[0] t[1]', real=True)\n\t        self.upsilon_theta = Vector3(\n\t            upsilon0, upsilon1, theta)\n", "        self.t = Vector2(t0, t1)\n\t        self.a = Se2(So2(Complex(x, y)), self.t)\n\t        self.p = Vector2(p0, p1)\n\t    def test_exp_log(self):\n\t        for v in [Vector3(0., 1, 0.5),\n\t                  Vector3(0.1, 0.1, 0.1),\n\t                  Vector3(0.01, 0.2, 0.03)]:\n\t            w = Se2.exp(v).log()\n\t            for i in range(0, 3):\n\t                self.assertAlmostEqual(v[i], w[i])\n", "    def test_matrix(self):\n\t        T_foo_bar = Se2.exp(self.upsilon_theta)\n\t        Tmat_foo_bar = T_foo_bar.matrix()\n\t        point_bar = self.p\n\t        p1_foo = T_foo_bar * point_bar\n\t        p2_foo = proj(Tmat_foo_bar * unproj(point_bar))\n\t        self.assertEqual(sympy.simplify(p1_foo - p2_foo),\n\t                         ZeroVector2())\n\t    def test_derivatives(self):\n\t        self.assertEqual(sympy.simplify(\n", "            Se2.calc_Dx_exp_x_at_0(self.upsilon_theta) -\n\t            Se2.Dx_exp_x_at_0()),\n\t            sympy.Matrix.zeros(4, 3))\n\t        for i in range(0, 4):\n\t            self.assertEqual(sympy.simplify(Se2.calc_Dxi_x_matrix(self.a, i) -\n\t                                            Se2.Dxi_x_matrix(self.a, i)),\n\t                             sympy.Matrix.zeros(3, 3))\n\t        for i in range(0, 3):\n\t            self.assertEqual(sympy.simplify(\n\t                Se2.Dxi_exp_x_matrix(self.upsilon_theta, i) -\n", "                Se2.calc_Dxi_exp_x_matrix(self.upsilon_theta, i)),\n\t                sympy.Matrix.zeros(3, 3))\n\t            self.assertEqual(sympy.simplify(\n\t                Se2.Dxi_exp_x_matrix_at_0(i) -\n\t                Se2.calc_Dxi_exp_x_matrix_at_0(self.upsilon_theta, i)),\n\t                sympy.Matrix.zeros(3, 3))\n\t    def test_codegen(self):\n\t        stream = cse_codegen(Se2.calc_Dx_exp_x(self.upsilon_theta))\n\t        filename = \"cpp_gencode/Se2_Dx_exp_x.cpp\"\n\t        # set to true to generate codegen files\n", "        if False:\n\t            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n", "            file.close()\n\t        stream.close\n\t        stream = cse_codegen(self.a.calc_Dx_this_mul_exp_x_at_0(\n\t            self.upsilon_theta))\n\t        filename = \"cpp_gencode/Se2_Dx_this_mul_exp_x_at_0.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n", "            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n\t        stream = cse_codegen(self.a.calc_Dx_log_this())\n\t        filename = \"cpp_gencode/Se2_Dx_log_this.cpp\"\n", "        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n", "                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "sophus/so2.py", "chunked_list": ["import functools\n\timport unittest\n\timport sympy\n\tfrom sophus.complex import Complex\n\tfrom sophus.cse_codegen import cse_codegen\n\tfrom sophus.matrix import Vector2\n\tfrom sophus.matrix import ZeroVector2\n\tclass So2:\n\t    \"\"\" 2 dimensional group of orthogonal matrices with determinant 1 \"\"\"\n\t    def __init__(self, z):\n", "        \"\"\" internally represented by a unit complex number z \"\"\"\n\t        self.z = z\n\t    @staticmethod\n\t    def exp(theta):\n\t        \"\"\" exponential map \"\"\"\n\t        return So2(\n\t            Complex(\n\t                sympy.cos(theta),\n\t                sympy.sin(theta)))\n\t    def log(self):\n", "        \"\"\" logarithmic map\"\"\"\n\t        return sympy.atan2(self.z.imag, self.z.real)\n\t    def calc_Dx_log_this(self):\n\t        return sympy.diff(self.log(), self[0])\n\t    def calc_Dx_log_exp_x_times_this_at_0(self, x):\n\t        return sympy.diff((So2.exp(x)*self).log(), x).limit(x, 0)\n\t    def __repr__(self):\n\t        return \"So2:\" + repr(self.z)\n\t    @staticmethod\n\t    def hat(theta):\n", "        return sympy.Matrix([[0, -theta],\n\t                             [theta, 0]])\n\t    def matrix(self):\n\t        \"\"\" returns matrix representation \"\"\"\n\t        return sympy.Matrix([\n\t            [self.z.real, -self.z.imag],\n\t            [self.z.imag,  self.z.real]])\n\t    def __mul__(self, right):\n\t        \"\"\" left-multiplication\n\t            either rotation concatenation or point-transform \"\"\"\n", "        if isinstance(right, sympy.Matrix):\n\t            assert right.shape == (2, 1), right.shape\n\t            return self.matrix() * right\n\t        elif isinstance(right, So2):\n\t            return So2(self.z * right.z)\n\t        assert False, \"unsupported type: {0}\".format(type(right))\n\t    def __getitem__(self, key):\n\t        return self.z[key]\n\t    @staticmethod\n\t    def calc_Dx_exp_x(x):\n", "        return sympy.Matrix(2, 1, lambda r, c:\n\t                            sympy.diff(So2.exp(x)[r], x))\n\t    @staticmethod\n\t    def Dx_exp_x_at_0():\n\t        return sympy.Matrix([0, 1])\n\t    @staticmethod\n\t    def calc_Dx_exp_x_at_0(x):\n\t        return So2.calc_Dx_exp_x(x).limit(x, 0)\n\t    def calc_Dx_this_mul_exp_x_at_0(self, x):\n\t        return sympy.Matrix(2, 1, lambda r, c:\n", "                            sympy.diff((self * So2.exp(x))[r], x))\\\n\t            .limit(x, 0)\n\t    @staticmethod\n\t    def Dxi_x_matrix(x, i):\n\t        if i == 0:\n\t            return sympy.Matrix([[1, 0],\n\t                                 [0, 1]])\n\t        if i == 1:\n\t            return sympy.Matrix([[0, -1],\n\t                                 [1, 0]])\n", "    @staticmethod\n\t    def calc_Dxi_x_matrix(x, i):\n\t        return sympy.Matrix(2, 2, lambda r, c:\n\t                            sympy.diff(x.matrix()[r, c], x[i]))\n\t    @staticmethod\n\t    def Dx_exp_x_matrix(x):\n\t        R = So2.exp(x)\n\t        Dx_exp_x = So2.calc_Dx_exp_x(x)\n\t        list = [Dx_exp_x[j] * So2.Dxi_x_matrix(R, j) for j in [0, 1]]\n\t        return functools.reduce((lambda a, b: a + b), list)\n", "    @staticmethod\n\t    def calc_Dx_exp_x_matrix(x):\n\t        return sympy.Matrix(2, 2, lambda r, c:\n\t                            sympy.diff(So2.exp(x).matrix()[r, c], x))\n\t    @staticmethod\n\t    def Dx_exp_x_matrix_at_0():\n\t        return So2.hat(1)\n\t    @staticmethod\n\t    def calc_Dx_exp_x_matrix_at_0(x):\n\t        return sympy.Matrix(2, 2, lambda r, c:\n", "                            sympy.diff(So2.exp(x).matrix()[r, c], x)\n\t                            ).limit(x, 0)\n\tclass TestSo2(unittest.TestCase):\n\t    def setUp(self):\n\t        self.theta = sympy.symbols(\n\t            'theta', real=True)\n\t        x, y = sympy.symbols('c[0] c[1]', real=True)\n\t        p0, p1 = sympy.symbols('p0 p1', real=True)\n\t        self.a = So2(Complex(x, y))\n\t        self.p = Vector2(p0, p1)\n", "    def test_exp_log(self):\n\t        for theta in [0.,  0.5, 0.1]:\n\t            w = So2.exp(theta).log()\n\t            self.assertAlmostEqual(theta, w)\n\t    def test_matrix(self):\n\t        R_foo_bar = So2.exp(self.theta)\n\t        Rmat_foo_bar = R_foo_bar.matrix()\n\t        point_bar = self.p\n\t        p1_foo = R_foo_bar * point_bar\n\t        p2_foo = Rmat_foo_bar * point_bar\n", "        self.assertEqual(sympy.simplify(p1_foo - p2_foo),\n\t                         ZeroVector2())\n\t    def test_derivatives(self):\n\t        self.assertEqual(sympy.simplify(So2.calc_Dx_exp_x_at_0(self.theta) -\n\t                                        So2.Dx_exp_x_at_0()),\n\t                         sympy.Matrix.zeros(2, 1))\n\t        for i in [0, 1]:\n\t            self.assertEqual(sympy.simplify(So2.calc_Dxi_x_matrix(self.a, i) -\n\t                                            So2.Dxi_x_matrix(self.a, i)),\n\t                             sympy.Matrix.zeros(2, 2))\n", "        self.assertEqual(sympy.simplify(\n\t            So2.Dx_exp_x_matrix(self.theta) -\n\t            So2.calc_Dx_exp_x_matrix(self.theta)),\n\t            sympy.Matrix.zeros(2, 2))\n\t        self.assertEqual(sympy.simplify(\n\t            So2.Dx_exp_x_matrix_at_0() -\n\t            So2.calc_Dx_exp_x_matrix_at_0(self.theta)),\n\t            sympy.Matrix.zeros(2, 2))\n\t    def test_codegen(self):\n\t        stream = cse_codegen(So2.calc_Dx_exp_x(self.theta))\n", "        filename = \"cpp_gencode/So2_Dx_exp_x.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n", "            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n\t        stream = cse_codegen(\n\t            self.a.calc_Dx_this_mul_exp_x_at_0(self.theta))\n\t        filename = \"cpp_gencode/So2_Dx_this_mul_exp_x_at_0.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n", "            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n", "        stream = cse_codegen(self.a.calc_Dx_log_this())\n\t        filename = \"cpp_gencode/So2_Dx_log_this.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n", "            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n\t        stream = cse_codegen(self.a.calc_Dx_log_exp_x_times_this_at_0(\n\t            self.theta))\n\t        filename = \"cpp_gencode/So2_Dx_log_exp_x_times_this_at_0.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n", "            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n", "        stream.close\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "sophus/matrix.py", "chunked_list": ["import sys\n\timport sympy\n\tassert sys.version_info >= (3, 5)\n\tdef dot(left, right):\n\t    assert(isinstance(left, sympy.Matrix))\n\t    assert(isinstance(right, sympy.Matrix))\n\t    sum = 0\n\t    for c in range(0, left.cols):\n\t        for r in range(0, left.rows):\n\t            sum += left[r, c] * right[r, c]\n", "    return sum\n\tdef squared_norm(m):\n\t    assert(isinstance(m, sympy.Matrix))\n\t    return dot(m, m)\n\tdef Vector2(x, y):\n\t    return sympy.Matrix([x, y])\n\tdef ZeroVector2():\n\t    return Vector2(0, 0)\n\tdef Vector3(x, y, z):\n\t    return sympy.Matrix([x, y, z])\n", "def ZeroVector3():\n\t    return Vector3(0, 0, 0)\n\tdef Vector4(a, b, c, d):\n\t    return sympy.Matrix([a, b, c, d])\n\tdef ZeroVector4():\n\t    return Vector4(0, 0, 0, 0)\n\tdef Vector5(a, b, c, d, e):\n\t    return sympy.Matrix([a, b, c, d, e])\n\tdef ZeroVector5():\n\t    return Vector5(0, 0, 0, 0, 0)\n", "def Vector6(a, b, c, d, e, f):\n\t    return sympy.Matrix([a, b, c, d, e, f])\n\tdef ZeroVector6():\n\t    return Vector6(0, 0, 0, 0, 0, 0)\n\tdef proj(v):\n\t    m, n = v.shape\n\t    assert m > 1\n\t    assert n == 1\n\t    list = [v[i] / v[m - 1] for i in range(0, m - 1)]\n\t    r = sympy.Matrix(m - 1, 1,  list)\n", "    return r\n\tdef unproj(v):\n\t    m, n = v.shape\n\t    assert m >= 1\n\t    assert n == 1\n\t    return v.col_join(sympy.Matrix.ones(1, 1))\n"]}
{"filename": "sophus/se3.py", "chunked_list": ["import functools\n\timport unittest\n\timport sympy\n\tfrom sophus.cse_codegen import cse_codegen\n\tfrom sophus.matrix import Vector3\n\tfrom sophus.matrix import Vector6\n\tfrom sophus.matrix import ZeroVector3\n\tfrom sophus.matrix import ZeroVector6\n\tfrom sophus.matrix import proj\n\tfrom sophus.matrix import squared_norm\n", "from sophus.matrix import unproj\n\tfrom sophus.quaternion import Quaternion\n\tfrom sophus.so3 import So3\n\tclass Se3:\n\t    \"\"\" 3 dimensional group of rigid body transformations \"\"\"\n\t    def __init__(self, so3, t):\n\t        \"\"\" internally represented by a unit quaternion q and a translation\n\t            3-vector \"\"\"\n\t        assert isinstance(so3, So3)\n\t        assert isinstance(t, sympy.Matrix)\n", "        assert t.shape == (3, 1), t.shape\n\t        self.so3 = so3\n\t        self.t = t\n\t    @staticmethod\n\t    def exp(v):\n\t        \"\"\" exponential map \"\"\"\n\t        upsilon = v[0:3, :]\n\t        omega = Vector3(v[3], v[4], v[5])\n\t        so3 = So3.exp(omega)\n\t        Omega = So3.hat(omega)\n", "        Omega_sq = Omega * Omega\n\t        theta = sympy.sqrt(squared_norm(omega))\n\t        V = (sympy.Matrix.eye(3) +\n\t             (1 - sympy.cos(theta)) / (theta**2) * Omega +\n\t             (theta - sympy.sin(theta)) / (theta**3) * Omega_sq)\n\t        return Se3(so3, V * upsilon)\n\t    def log(self):\n\t        omega = self.so3.log()\n\t        theta = sympy.sqrt(squared_norm(omega))\n\t        Omega = So3.hat(omega)\n", "        half_theta = 0.5 * theta\n\t        V_inv = sympy.Matrix.eye(3) - 0.5 * Omega + (1 - theta * sympy.cos(\n\t            half_theta) / (2 * sympy.sin(half_theta))) / (theta * theta) *\\\n\t            (Omega * Omega)\n\t        upsilon = V_inv * self.t\n\t        return upsilon.col_join(omega)\n\t    def calc_Dx_log_this(self):\n\t        return sympy.Matrix(6, 7, lambda r, c: sympy.diff(self.log()[r],\n\t                            self[c]))\n\t    def __repr__(self):\n", "        return \"Se3: [\" + repr(self.so3) + \" \" + repr(self.t)\n\t    def inverse(self):\n\t        invR = self.so3.inverse()\n\t        return Se3(invR, invR * (-1 * self.t))\n\t    @staticmethod\n\t    def hat(v):\n\t        \"\"\" R^6 => R^4x4  \"\"\"\n\t        \"\"\" returns 4x4-matrix representation ``Omega`` \"\"\"\n\t        upsilon = Vector3(v[0], v[1], v[2])\n\t        omega = Vector3(v[3], v[4], v[5])\n", "        return So3.hat(omega).\\\n\t            row_join(upsilon).\\\n\t            col_join(sympy.Matrix.zeros(1, 4))\n\t    @staticmethod\n\t    def vee(Omega):\n\t        \"\"\" R^4x4 => R^6 \"\"\"\n\t        \"\"\" returns 6-vector representation of Lie algebra \"\"\"\n\t        \"\"\" This is the inverse of the hat-operator \"\"\"\n\t        head = Vector3(Omega[0, 3], Omega[1, 3], Omega[2, 3])\n\t        tail = So3.vee(Omega[0:3, 0:3])\n", "        upsilon_omega = \\\n\t            Vector6(head[0], head[1], head[2], tail[0], tail[1], tail[2])\n\t        return upsilon_omega\n\t    def matrix(self):\n\t        \"\"\" returns matrix representation \"\"\"\n\t        R = self.so3.matrix()\n\t        return (R.row_join(self.t)).col_join(sympy.Matrix(1, 4, [0, 0, 0, 1]))\n\t    def __mul__(self, right):\n\t        \"\"\" left-multiplication\n\t            either rotation concatenation or point-transform \"\"\"\n", "        if isinstance(right, sympy.Matrix):\n\t            assert right.shape == (3, 1), right.shape\n\t            return self.so3 * right + self.t\n\t        elif isinstance(right, Se3):\n\t            r = self.so3 * right.so3\n\t            t = self.t + self.so3 * right.t\n\t            return Se3(r, t)\n\t        assert False, \"unsupported type: {0}\".format(type(right))\n\t    def __getitem__(self, key):\n\t        \"\"\" We use the following convention [q0, q1, q2, q3, t0, t1, t2] \"\"\"\n", "        assert (key >= 0 and key < 7)\n\t        if key < 4:\n\t            return self.so3[key]\n\t        else:\n\t            return self.t[key - 4]\n\t    @staticmethod\n\t    def calc_Dx_exp_x(x):\n\t        return sympy.Matrix(7, 6, lambda r, c:\n\t                            sympy.diff(Se3.exp(x)[r], x[c]))\n\t    @staticmethod\n", "    def Dx_exp_x_at_0():\n\t        return sympy.Matrix([[0.0, 0.0, 0.0, 0.5, 0.0, 0.0],\n\t                             [0.0, 0.0, 0.0, 0.0, 0.5, 0.0],\n\t                             [0.0, 0.0, 0.0, 0.0, 0.0, 0.5],\n\t                             [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t                             [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n\t                             [0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n\t                             [0.0, 0.0, 1.0, 0.0, 0.0, 0.0]])\n\t    def calc_Dx_this_mul_exp_x_at_0(self, x):\n\t        return sympy.Matrix(7, 6, lambda r, c:\n", "                            sympy.diff((self * Se3.exp(x))[r], x[c])). \\\n\t            subs(x[0], 0).subs(x[1], 0).subs(x[2], 0).\\\n\t            subs(x[3], 0).subs(x[4], 0).limit(x[5], 0)\n\t    @staticmethod\n\t    def calc_Dx_exp_x_at_0(x):\n\t        return Se3.calc_Dx_exp_x(x).subs(x[0], 0).subs(x[1], 0).subs(x[2], 0).\\\n\t            subs(x[3], 0).subs(x[4], 0).limit(x[5], 0)\n\t    @staticmethod\n\t    def Dxi_x_matrix(x, i):\n\t        if i < 4:\n", "            return So3.Dxi_x_matrix(x, i).\\\n\t                row_join(sympy.Matrix.zeros(3, 1)).\\\n\t                col_join(sympy.Matrix.zeros(1, 4))\n\t        M = sympy.Matrix.zeros(4, 4)\n\t        M[i - 4, 3] = 1\n\t        return M\n\t    @staticmethod\n\t    def calc_Dxi_x_matrix(x, i):\n\t        return sympy.Matrix(4, 4, lambda r, c:\n\t                            sympy.diff(x.matrix()[r, c], x[i]))\n", "    @staticmethod\n\t    def Dxi_exp_x_matrix(x, i):\n\t        T = Se3.exp(x)\n\t        Dx_exp_x = Se3.calc_Dx_exp_x(x)\n\t        list = [Dx_exp_x[j, i] * Se3.Dxi_x_matrix(T, j) for j in range(0, 7)]\n\t        return functools.reduce((lambda a, b: a + b), list)\n\t    @staticmethod\n\t    def calc_Dxi_exp_x_matrix(x, i):\n\t        return sympy.Matrix(4, 4, lambda r, c:\n\t                            sympy.diff(Se3.exp(x).matrix()[r, c], x[i]))\n", "    @staticmethod\n\t    def Dxi_exp_x_matrix_at_0(i):\n\t        v = ZeroVector6()\n\t        v[i] = 1\n\t        return Se3.hat(v)\n\t    @staticmethod\n\t    def calc_Dxi_exp_x_matrix_at_0(x, i):\n\t        return sympy.Matrix(4, 4, lambda r, c:\n\t                            sympy.diff(Se3.exp(x).matrix()[r, c], x[i])\n\t                            ).subs(x[0], 0).subs(x[1], 0).subs(x[2], 0).\\\n", "            subs(x[3], 0).subs(x[4], 0).limit(x[5], 0)\n\tclass TestSe3(unittest.TestCase):\n\t    def setUp(self):\n\t        upsilon0, upsilon1, upsilon2, omega0, omega1, omega2 = sympy.symbols(\n\t            'upsilon[0], upsilon[1], upsilon[2], omega[0], omega[1], omega[2]',\n\t            real=True)\n\t        x, v0, v1, v2 = sympy.symbols('q.w() q.x() q.y() q.z()', real=True)\n\t        p0, p1, p2 = sympy.symbols('p0 p1 p2', real=True)\n\t        t0, t1, t2 = sympy.symbols('t[0] t[1] t[2]', real=True)\n\t        v = Vector3(v0, v1, v2)\n", "        self.upsilon_omega = Vector6(\n\t            upsilon0, upsilon1, upsilon2, omega0, omega1, omega2)\n\t        self.t = Vector3(t0, t1, t2)\n\t        self.a = Se3(So3(Quaternion(x, v)), self.t)\n\t        self.p = Vector3(p0, p1, p2)\n\t    def test_exp_log(self):\n\t        for v in [Vector6(0., 1, 0.5, 2., 1, 0.5),\n\t                  Vector6(0.1, 0.1, 0.1, 0., 1, 0.5),\n\t                  Vector6(0.01, 0.2, 0.03, 0.01, 0.2, 0.03)]:\n\t            w = Se3.exp(v).log()\n", "            for i in range(0, 3):\n\t                self.assertAlmostEqual(v[i], w[i])\n\t    def test_matrix(self):\n\t        T_foo_bar = Se3.exp(self.upsilon_omega)\n\t        Tmat_foo_bar = T_foo_bar.matrix()\n\t        point_bar = self.p\n\t        p1_foo = T_foo_bar * point_bar\n\t        p2_foo = proj(Tmat_foo_bar * unproj(point_bar))\n\t        self.assertEqual(sympy.simplify(p1_foo - p2_foo),\n\t                         ZeroVector3())\n", "    def test_derivatives(self):\n\t        self.assertEqual(sympy.simplify(\n\t            Se3.calc_Dx_exp_x_at_0(self.upsilon_omega) -\n\t            Se3.Dx_exp_x_at_0()),\n\t            sympy.Matrix.zeros(7, 6))\n\t        for i in range(0, 7):\n\t            self.assertEqual(sympy.simplify(Se3.calc_Dxi_x_matrix(self.a, i) -\n\t                                            Se3.Dxi_x_matrix(self.a, i)),\n\t                             sympy.Matrix.zeros(4, 4))\n\t        for i in range(0, 6):\n", "            self.assertEqual(sympy.simplify(\n\t                Se3.Dxi_exp_x_matrix(self.upsilon_omega, i) -\n\t                Se3.calc_Dxi_exp_x_matrix(self.upsilon_omega, i)),\n\t                sympy.Matrix.zeros(4, 4))\n\t            self.assertEqual(sympy.simplify(\n\t                Se3.Dxi_exp_x_matrix_at_0(i) -\n\t                Se3.calc_Dxi_exp_x_matrix_at_0(self.upsilon_omega, i)),\n\t                sympy.Matrix.zeros(4, 4))\n\t    def test_codegen(self):\n\t        stream = cse_codegen(self.a.calc_Dx_exp_x(self.upsilon_omega))\n", "        filename = \"cpp_gencode/Se3_Dx_exp_x.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n", "            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n\t        stream = cse_codegen(self.a.calc_Dx_this_mul_exp_x_at_0(\n\t            self.upsilon_omega))\n\t        filename = \"cpp_gencode/Se3_Dx_this_mul_exp_x_at_0.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n", "            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n\t            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n", "        stream = cse_codegen(self.a.calc_Dx_log_this())\n\t        filename = \"cpp_gencode/Se3_Dx_log_this.cpp\"\n\t        # set to true to generate codegen files\n\t        if False:\n\t            file = open(filename, \"w\")\n\t            for line in stream:\n\t                file.write(line)\n\t            file.close()\n\t        else:\n\t            file = open(filename, \"r\")\n", "            file_lines = file.readlines()\n\t            for i, line in enumerate(stream):\n\t                self.assertEqual(line, file_lines[i])\n\t            file.close()\n\t        stream.close\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "sophus/dual_quaternion.py", "chunked_list": ["import unittest\n\timport sympy\n\tfrom sophus.matrix import Vector3\n\tfrom sophus.quaternion import Quaternion\n\tclass DualQuaternion:\n\t    \"\"\" Dual quaternion class \"\"\"\n\t    def __init__(self, real_q, inf_q):\n\t        \"\"\" Dual quaternion consists of a real quaternion, and an infinitesimal\n\t            quaternion \"\"\"\n\t        self.real_q = real_q\n", "        self.inf_q = inf_q\n\t    def __mul__(self, right):\n\t        \"\"\" dual quaternion multiplication \"\"\"\n\t        return DualQuaternion(self.real_q * right.real_q,\n\t                              self.real_q * right.inf_q +\n\t                              self.inf_q * right.real_q)\n\t    def __truediv__(self, scalar):\n\t        \"\"\" scalar division \"\"\"\n\t        return DualQuaternion(self.real_q / scalar, self.inf_q / scalar)\n\t    def __repr__(self):\n", "        return \"( \" + repr(self.real_q) + \\\n\t               \" + \" + repr(self.inf_q) + \")\"\n\t    def __getitem__(self, key):\n\t        assert (key >= 0 and key < 8)\n\t        if key < 4:\n\t            return self.real_q[key]\n\t        else:\n\t            return self.inf_q[key - 4]\n\t    def squared_norm(self):\n\t        \"\"\" squared norm when considering the dual quaternion as 8-tuple \"\"\"\n", "        return self.real_q.squared_norm() + self.inf_q.squared_norm()\n\t    def conj(self):\n\t        \"\"\" dual quaternion conjugate \"\"\"\n\t        return DualQuaternion(self.real_q.conj(), self.inf_q.conj())\n\t    def inv(self):\n\t        \"\"\" dual quaternion inverse \"\"\"\n\t        return DualQuaternion(self.real_q.inv(),\n\t                              -self.real_q.inv() * self.inf_q *\n\t                              self.real_q.inv())\n\t    def simplify(self):\n", "        return DualQuaternion(self.real_q.simplify(),\n\t                              self.inf_q.simplify())\n\t    @staticmethod\n\t    def identity():\n\t        return DualQuaternion(Quaternion.identity(),\n\t                              Quaternion.zero())\n\t    def __eq__(self, other):\n\t        if isinstance(self, other.__class__):\n\t            return self.real_q == other.real_q and self.inf_q == other.inf_q\n\t        return False\n", "class TestDualQuaternion(unittest.TestCase):\n\t    def setUp(self):\n\t        w, s0, s1, s2 = sympy.symbols('w s0 s1 s2', real=True)\n\t        x, t0, t1, t2 = sympy.symbols('x t0 t1 t2', real=True)\n\t        y, u0, u1, u2 = sympy.symbols('y u0 u1 u2', real=True)\n\t        z, v0, v1, v2 = sympy.symbols('z v0 v1 v2', real=True)\n\t        s = Vector3(s0, s1, s2)\n\t        t = Vector3(t0, t1, t2)\n\t        u = Vector3(u0, u1, u2)\n\t        v = Vector3(v0, v1, v2)\n", "        self.a = DualQuaternion(Quaternion(w, s),\n\t                                Quaternion(x, t))\n\t        self.b = DualQuaternion(Quaternion(y, u),\n\t                                Quaternion(z, v))\n\t    def test_muliplications(self):\n\t        product = self.a * self.a.inv()\n\t        self.assertEqual(product.simplify(),\n\t                         DualQuaternion.identity())\n\t        product = self.a.inv() * self.a\n\t        self.assertEqual(product.simplify(),\n", "                         DualQuaternion.identity())\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "sophus/quaternion.py", "chunked_list": ["\"\"\" run with: python3 -m sophus.quaternion \"\"\"\n\timport unittest\n\timport sympy\n\tfrom sophus.matrix import Vector3\n\tfrom sophus.matrix import squared_norm\n\tclass Quaternion:\n\t    \"\"\" Quaternion class \"\"\"\n\t    def __init__(self, real, vec):\n\t        \"\"\" Quaternion consists of a real scalar, and an imaginary 3-vector \"\"\"\n\t        assert isinstance(vec, sympy.Matrix)\n", "        assert vec.shape == (3, 1), vec.shape\n\t        self.real = real\n\t        self.vec = vec\n\t    def __mul__(self, right):\n\t        \"\"\" quaternion multiplication \"\"\"\n\t        return Quaternion(self[3] * right[3] - self.vec.dot(right.vec),\n\t                          self[3] * right.vec + right[3] * self.vec +\n\t                          self.vec.cross(right.vec))\n\t    def __add__(self, right):\n\t        \"\"\" quaternion multiplication \"\"\"\n", "        return Quaternion(self[3] + right[3], self.vec + right.vec)\n\t    def __neg__(self):\n\t        return Quaternion(-self[3], -self.vec)\n\t    def __truediv__(self, scalar):\n\t        \"\"\" scalar division \"\"\"\n\t        return Quaternion(self.real / scalar, self.vec / scalar)\n\t    def __repr__(self):\n\t        return \"( \" + repr(self[3]) + \" + \" + repr(self.vec) + \"i )\"\n\t    def __getitem__(self, key):\n\t        \"\"\" We use the following convention [vec0, vec1, vec2, real] \"\"\"\n", "        assert (key >= 0 and key < 4)\n\t        if key == 3:\n\t            return self.real\n\t        else:\n\t            return self.vec[key]\n\t    def squared_norm(self):\n\t        \"\"\" squared norm when considering the quaternion as 4-tuple \"\"\"\n\t        return squared_norm(self.vec) + self.real**2\n\t    def conj(self):\n\t        \"\"\" quaternion conjugate \"\"\"\n", "        return Quaternion(self.real, -self.vec)\n\t    def inv(self):\n\t        \"\"\" quaternion inverse \"\"\"\n\t        return self.conj() / self.squared_norm()\n\t    @staticmethod\n\t    def identity():\n\t        return Quaternion(1, Vector3(0, 0, 0))\n\t    @staticmethod\n\t    def zero():\n\t        return Quaternion(0, Vector3(0, 0, 0))\n", "    def subs(self, x, y):\n\t        return Quaternion(self.real.subs(x, y), self.vec.subs(x, y))\n\t    def simplify(self):\n\t        v = sympy.simplify(self.vec)\n\t        return Quaternion(sympy.simplify(self.real),\n\t                          Vector3(v[0], v[1], v[2]))\n\t    def __eq__(self, other):\n\t        if isinstance(self, other.__class__):\n\t            return self.real == other.real and self.vec == other.vec\n\t        return False\n", "    @staticmethod\n\t    def Da_a_mul_b(a, b):\n\t        \"\"\" derivatice of quaternion muliplication wrt left multiplier a \"\"\"\n\t        v0 = b.vec[0]\n\t        v1 = b.vec[1]\n\t        v2 = b.vec[2]\n\t        y = b.real\n\t        return sympy.Matrix([[y, v2, -v1, v0],\n\t                             [-v2, y, v0, v1],\n\t                             [v1, -v0, y, v2],\n", "                             [-v0, -v1, -v2, y]])\n\t    @staticmethod\n\t    def Db_a_mul_b(a, b):\n\t        \"\"\" derivatice of quaternion muliplication wrt right multiplicand b \"\"\"\n\t        u0 = a.vec[0]\n\t        u1 = a.vec[1]\n\t        u2 = a.vec[2]\n\t        x = a.real\n\t        return sympy.Matrix([[x, -u2, u1, u0],\n\t                             [u2, x, -u0, u1],\n", "                             [-u1, u0, x, u2],\n\t                             [-u0, -u1, -u2, x]])\n\tclass TestQuaternion(unittest.TestCase):\n\t    def setUp(self):\n\t        x, u0, u1, u2 = sympy.symbols('x u0 u1 u2', real=True)\n\t        y, v0, v1, v2 = sympy.symbols('y v0 v1 v2', real=True)\n\t        u = Vector3(u0, u1, u2)\n\t        v = Vector3(v0, v1, v2)\n\t        self.a = Quaternion(x, u)\n\t        self.b = Quaternion(y, v)\n", "    def test_muliplications(self):\n\t        product = self.a * self.a.inv()\n\t        self.assertEqual(product.simplify(),\n\t                         Quaternion.identity())\n\t        product = self.a.inv() * self.a\n\t        self.assertEqual(product.simplify(),\n\t                         Quaternion.identity())\n\t    def test_derivatives(self):\n\t        d = sympy.Matrix(4, 4, lambda r, c: sympy.diff(\n\t            (self.a * self.b)[r], self.a[c]))\n", "        self.assertEqual(d,\n\t                         Quaternion.Da_a_mul_b(self.a, self.b))\n\t        d = sympy.Matrix(4, 4, lambda r, c: sympy.diff(\n\t            (self.a * self.b)[r], self.b[c]))\n\t        self.assertEqual(d,\n\t                         Quaternion.Db_a_mul_b(self.a, self.b))\n\tif __name__ == '__main__':\n\t    unittest.main()\n\t    print('hello')\n"]}
{"filename": "sophus/complex.py", "chunked_list": ["import unittest\n\timport sympy\n\tclass Complex:\n\t    \"\"\" Complex class \"\"\"\n\t    def __init__(self, real, imag):\n\t        self.real = real\n\t        self.imag = imag\n\t    def __mul__(self, right):\n\t        \"\"\" complex multiplication \"\"\"\n\t        return Complex(self.real * right.real - self.imag * right.imag,\n", "                       self.imag * right.real + self.real * right.imag)\n\t    def __add__(self, right):\n\t        return Complex(self.real + right.real, self.imag + right.imag)\n\t    def __neg__(self):\n\t        return Complex(-self.real, -self.image)\n\t    def __truediv__(self, scalar):\n\t        \"\"\" scalar division \"\"\"\n\t        return Complex(self.real / scalar, self.imag / scalar)\n\t    def __repr__(self):\n\t        return \"( \" + repr(self.real) + \" + \" + repr(self.imag) + \"i )\"\n", "    def __getitem__(self, key):\n\t        \"\"\" We use the following convention [real, imag] \"\"\"\n\t        if key == 0:\n\t            return self.real\n\t        else:\n\t            return self.imag\n\t    def squared_norm(self):\n\t        \"\"\" squared norm when considering the complex number as tuple \"\"\"\n\t        return self.real**2 + self.imag**2\n\t    def conj(self):\n", "        \"\"\" complex conjugate \"\"\"\n\t        return Complex(self.real, -self.imag)\n\t    def inv(self):\n\t        \"\"\" complex inverse \"\"\"\n\t        return self.conj() / self.squared_norm()\n\t    @staticmethod\n\t    def identity():\n\t        return Complex(1, 0)\n\t    @staticmethod\n\t    def zero():\n", "        return Complex(0, 0)\n\t    def __eq__(self, other):\n\t        if isinstance(self, other.__class__):\n\t            return self.real == other.real and self.imag == other.imag\n\t        return False\n\t    def subs(self, x, y):\n\t        return Complex(self.real.subs(x, y), self.imag.subs(x, y))\n\t    def simplify(self):\n\t        return Complex(sympy.simplify(self.real),\n\t                       sympy.simplify(self.imag))\n", "    @staticmethod\n\t    def Da_a_mul_b(a, b):\n\t        \"\"\" derivatice of complex muliplication wrt left multiplier a \"\"\"\n\t        return sympy.Matrix([[b.real, -b.imag],\n\t                             [b.imag, b.real]])\n\t    @staticmethod\n\t    def Db_a_mul_b(a, b):\n\t        \"\"\" derivatice of complex muliplication wrt right multiplicand b \"\"\"\n\t        return sympy.Matrix([[a.real, -a.imag],\n\t                             [a.imag, a.real]])\n", "class TestComplex(unittest.TestCase):\n\t    def setUp(self):\n\t        x, y = sympy.symbols('x y', real=True)\n\t        u, v = sympy.symbols('u v', real=True)\n\t        self.a = Complex(x, y)\n\t        self.b = Complex(u, v)\n\t    def test_muliplications(self):\n\t        product = self.a * self.a.inv()\n\t        self.assertEqual(product.simplify(),\n\t                         Complex.identity())\n", "        product = self.a.inv() * self.a\n\t        self.assertEqual(product.simplify(),\n\t                         Complex.identity())\n\t    def test_derivatives(self):\n\t        d = sympy.Matrix(2, 2, lambda r, c: sympy.diff(\n\t            (self.a * self.b)[r], self.a[c]))\n\t        self.assertEqual(d,\n\t                         Complex.Da_a_mul_b(self.a, self.b))\n\t        d = sympy.Matrix(2, 2, lambda r, c: sympy.diff(\n\t            (self.a * self.b)[r], self.b[c]))\n", "        self.assertEqual(d,\n\t                         Complex.Db_a_mul_b(self.a, self.b))\n\tif __name__ == '__main__':\n\t    unittest.main()\n\t    print('hello')\n"]}
