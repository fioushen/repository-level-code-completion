{"filename": "db_utils.py", "chunked_list": ["import json\n\timport sqlite3\n\t# Initialize SQLite database\n\tdef initialize_database():\n\t    with sqlite3.connect(\"meshtastic.sqlite\") as conn:\n\t        cursor = conn.cursor()\n\t        cursor.execute(\n\t            \"CREATE TABLE IF NOT EXISTS longnames (meshtastic_id TEXT PRIMARY KEY, longname TEXT)\"\n\t        )\n\t        cursor.execute(\n", "            \"CREATE TABLE IF NOT EXISTS shortnames (meshtastic_id TEXT PRIMARY KEY, shortname TEXT)\"\n\t        )\n\t        cursor.execute(\n\t            \"CREATE TABLE IF NOT EXISTS plugin_data (plugin_name TEXT, meshtastic_id TEXT, data TEXT, PRIMARY KEY (plugin_name, meshtastic_id))\"\n\t        )\n\t        conn.commit()\n\tdef store_plugin_data(plugin_name, meshtastic_id, data):\n\t    with sqlite3.connect(\"meshtastic.sqlite\") as conn:\n\t        cursor = conn.cursor()\n\t        cursor.execute(\n", "            \"INSERT OR REPLACE INTO plugin_data (plugin_name, meshtastic_id, data) VALUES (?, ?, ?) ON CONFLICT (plugin_name, meshtastic_id) DO UPDATE SET data = ?\",\n\t            (plugin_name, meshtastic_id, json.dumps(data), json.dumps(data)),\n\t        )\n\t        conn.commit()\n\tdef delete_plugin_data(plugin_name, meshtastic_id):\n\t    with sqlite3.connect(\"meshtastic.sqlite\") as conn:\n\t        cursor = conn.cursor()\n\t        cursor.execute(\n\t            \"DELETE FROM plugin_data WHERE plugin_name=? AND meshtastic_id=?\",\n\t            (plugin_name, meshtastic_id),\n", "        )\n\t        conn.commit()\n\t# Get the data for a given plugin and Meshtastic ID\n\tdef get_plugin_data_for_node(plugin_name, meshtastic_id):\n\t    with sqlite3.connect(\"meshtastic.sqlite\") as conn:\n\t        cursor = conn.cursor()\n\t        cursor.execute(\n\t            \"SELECT data FROM plugin_data WHERE plugin_name=? AND meshtastic_id=?\",\n\t            (\n\t                plugin_name,\n", "                meshtastic_id,\n\t            ),\n\t        )\n\t        result = cursor.fetchone()\n\t    return json.loads(result[0] if result else \"[]\")\n\t# Get the data for a given plugin\n\tdef get_plugin_data(plugin_name):\n\t    with sqlite3.connect(\"meshtastic.sqlite\") as conn:\n\t        cursor = conn.cursor()\n\t        cursor.execute(\n", "            \"SELECT data FROM plugin_data WHERE plugin_name=? \",\n\t            (plugin_name,),\n\t        )\n\t        return cursor.fetchall()\n\t# Get the longname for a given Meshtastic ID\n\tdef get_longname(meshtastic_id):\n\t    with sqlite3.connect(\"meshtastic.sqlite\") as conn:\n\t        cursor = conn.cursor()\n\t        cursor.execute(\n\t            \"SELECT longname FROM longnames WHERE meshtastic_id=?\", (meshtastic_id,)\n", "        )\n\t        result = cursor.fetchone()\n\t    return result[0] if result else None\n\tdef save_longname(meshtastic_id, longname):\n\t    with sqlite3.connect(\"meshtastic.sqlite\") as conn:\n\t        cursor = conn.cursor()\n\t        cursor.execute(\n\t            \"INSERT OR REPLACE INTO longnames (meshtastic_id, longname) VALUES (?, ?)\",\n\t            (meshtastic_id, longname),\n\t        )\n", "        conn.commit()\n\tdef update_longnames(nodes):\n\t    if nodes:\n\t        for node in nodes.values():\n\t            user = node.get(\"user\")\n\t            if user:\n\t                meshtastic_id = user[\"id\"]\n\t                longname = user.get(\"longName\", \"N/A\")\n\t                save_longname(meshtastic_id, longname)\n\tdef get_shortname(meshtastic_id):\n", "    with sqlite3.connect(\"meshtastic.sqlite\") as conn:\n\t        cursor = conn.cursor()\n\t        cursor.execute(\n\t            \"SELECT shortname FROM shortnames WHERE meshtastic_id=?\", (meshtastic_id,))\n\t        result = cursor.fetchone()\n\t    return result[0] if result else None\n\tdef save_shortname(meshtastic_id, shortname):\n\t    with sqlite3.connect(\"meshtastic.sqlite\") as conn:\n\t        cursor = conn.cursor()\n\t        cursor.execute(\n", "            \"INSERT OR REPLACE INTO shortnames (meshtastic_id, shortname) VALUES (?, ?)\",\n\t            (meshtastic_id, shortname),\n\t        )\n\t        conn.commit()\n\tdef update_shortnames(nodes):\n\t    if nodes:\n\t        for node in nodes.values():\n\t            user = node.get(\"user\")\n\t            if user:\n\t                meshtastic_id = user[\"id\"]\n", "                shortname = user.get(\"shortName\", \"N/A\")\n\t                save_shortname(meshtastic_id, shortname)"]}
{"filename": "plugin_loader.py", "chunked_list": ["from log_utils import get_logger\n\tlogger = get_logger(name=\"Plugins\")\n\tsorted_active_plugins = []\n\tdef load_plugins():\n\t    from plugins.health_plugin import Plugin as HealthPlugin\n\t    from plugins.map_plugin import Plugin as MapPlugin\n\t    from plugins.mesh_relay_plugin import Plugin as MeshRelayPlugin\n\t    from plugins.ping_plugin import Plugin as PingPlugin\n\t    from plugins.telemetry_plugin import Plugin as TelemetryPlugin\n\t    from plugins.weather_plugin import Plugin as WeatherPlugin\n", "    from plugins.help_plugin import Plugin as HelpPlugin\n\t    from plugins.nodes_plugin import Plugin as NodesPlugin\n\t    from plugins.drop_plugin import Plugin as DropPlugin\n\t    from plugins.debug_plugin import Plugin as DebugPlugin\n\t    global sorted_active_plugins\n\t    if sorted_active_plugins:\n\t        return sorted_active_plugins\n\t    plugins = [\n\t        HealthPlugin(),\n\t        MapPlugin(),\n", "        MeshRelayPlugin(),\n\t        PingPlugin(),\n\t        TelemetryPlugin(),\n\t        WeatherPlugin(),\n\t        HelpPlugin(),\n\t        NodesPlugin(),\n\t        DropPlugin(),\n\t        DebugPlugin(),\n\t    ]\n\t    active_plugins = []\n", "    for plugin in plugins:\n\t        if plugin.config[\"active\"]:\n\t            plugin.priority = (\n\t                plugin.config[\"priority\"]\n\t                if \"priority\" in plugin.config\n\t                else plugin.priority\n\t            )\n\t            active_plugins.append(plugin)\n\t            plugin.start()\n\t    sorted_active_plugins = sorted(active_plugins, key=lambda plugin: plugin.priority)\n", "    return sorted_active_plugins\n"]}
{"filename": "meshtastic_utils.py", "chunked_list": ["import asyncio\n\timport time\n\timport meshtastic.tcp_interface\n\timport meshtastic.serial_interface\n\tfrom typing import List\n\tfrom config import relay_config\n\tfrom log_utils import get_logger\n\tfrom db_utils import get_longname, get_shortname\n\tfrom plugin_loader import load_plugins\n\tmatrix_rooms: List[dict] = relay_config[\"matrix_rooms\"]\n", "logger = get_logger(name=\"Meshtastic\")\n\tmeshtastic_client = None\n\tdef connect_meshtastic():\n\t    global meshtastic_client\n\t    if meshtastic_client:\n\t        return meshtastic_client\n\t    # Initialize Meshtastic interface\n\t    connection_type = relay_config[\"meshtastic\"][\"connection_type\"]\n\t    retry_limit = (\n\t        relay_config[\"meshtastic\"][\"retry_limit\"]\n", "        if \"retry_limit\" in relay_config[\"meshtastic\"]\n\t        else 3\n\t    )\n\t    attempts = 1\n\t    successful = False\n\t    if connection_type == \"serial\":\n\t        serial_port = relay_config[\"meshtastic\"][\"serial_port\"]\n\t        logger.info(f\"Connecting to serial port {serial_port} ...\")\n\t        while not successful and attempts <= retry_limit:\n\t            try:\n", "                meshtastic_client = meshtastic.serial_interface.SerialInterface(\n\t                    serial_port\n\t                )\n\t                successful = True\n\t            except Exception as e:\n\t                attempts += 1\n\t                if attempts <= retry_limit:\n\t                    logger.warn(\n\t                        f\"Attempt #{attempts-1} failed. Retrying in {attempts} secs {e}\"\n\t                    )\n", "                    time.sleep(attempts)\n\t                else:\n\t                    logger.error(f\"Could not connect: {e}\")\n\t                    return None\n\t    else:\n\t        target_host = relay_config[\"meshtastic\"][\"host\"]\n\t        logger.info(f\"Connecting to host {target_host} ...\")\n\t        while not successful and attempts <= retry_limit:\n\t            try:\n\t                meshtastic_client = meshtastic.tcp_interface.TCPInterface(\n", "                    hostname=target_host\n\t                )\n\t                successful = True\n\t            except Exception as e:\n\t                attempts += 1\n\t                if attempts <= retry_limit:\n\t                    logger.warn(\n\t                        f\"Attempt #{attempts-1} failed. Retrying in {attempts} secs... {e}\"\n\t                    )\n\t                    time.sleep(attempts)\n", "                else:\n\t                    logger.error(f\"Could not connect: {e}\")\n\t                    return None\n\t    nodeInfo = meshtastic_client.getMyNodeInfo()\n\t    logger.info(\n\t        f\"Connected to {nodeInfo['user']['shortName']} / {nodeInfo['user']['hwModel']}\"\n\t    )\n\t    return meshtastic_client\n\tdef on_lost_meshtastic_connection(interface):\n\t    logger.error(\"Lost connection. Reconnecting...\")\n", "    connect_meshtastic()\n\t# Callback for new messages from Meshtastic\n\tdef on_meshtastic_message(packet, loop=None):\n\t    from matrix_utils import matrix_relay\n\t    sender = packet[\"fromId\"]\n\t    if \"text\" in packet[\"decoded\"] and packet[\"decoded\"][\"text\"]:\n\t        text = packet[\"decoded\"][\"text\"]\n\t        if \"channel\" in packet:\n\t            channel = packet[\"channel\"]\n\t        else:\n", "            if packet[\"decoded\"][\"portnum\"] == \"TEXT_MESSAGE_APP\":\n\t                channel = 0\n\t            else:\n\t                logger.debug(f\"Unknown packet\")\n\t                return\n\t        # Check if the channel is mapped to a Matrix room in the configuration\n\t        channel_mapped = False\n\t        for room in matrix_rooms:\n\t            if room[\"meshtastic_channel\"] == channel:\n\t                channel_mapped = True\n", "                break\n\t        if not channel_mapped:\n\t            logger.debug(f\"Skipping message from unmapped channel {channel}\")\n\t            return\n\t        logger.info(\n\t            f\"Processing inbound radio message from {sender} on channel {channel}\"\n\t        )\n\t        longname = get_longname(sender) or sender\n\t        shortname = get_shortname(sender) or sender\n\t        meshnet_name = relay_config[\"meshtastic\"][\"meshnet_name\"]\n", "        formatted_message = f\"[{longname}/{meshnet_name}]: {text}\"\n\t        # Plugin functionality\n\t        plugins = load_plugins()\n\t        found_matching_plugin = False\n\t        for plugin in plugins:\n\t            if not found_matching_plugin:\n\t                result = asyncio.run_coroutine_threadsafe(\n\t                    plugin.handle_meshtastic_message(\n\t                        packet, formatted_message, longname, meshnet_name\n\t                    ),\n", "                    loop=loop,\n\t                )\n\t                found_matching_plugin = result.result()\n\t                if found_matching_plugin:\n\t                    logger.debug(f\"Processed by plugin {plugin.plugin_name}\")\n\t        if found_matching_plugin:\n\t            return\n\t        logger.info(\n\t            f\"Relaying Meshtastic message from {longname} to Matrix: {formatted_message}\"\n\t        )\n", "        for room in matrix_rooms:\n\t            if room[\"meshtastic_channel\"] == channel:\n\t                asyncio.run_coroutine_threadsafe(\n\t                    matrix_relay(\n\t                        room[\"id\"],\n\t                        formatted_message,\n\t                        longname,\n\t                        shortname,\n\t                        meshnet_name,\n\t                    ),\n", "                    loop=loop,\n\t                )\n\t    else:\n\t        portnum = packet[\"decoded\"][\"portnum\"]\n\t        plugins = load_plugins()\n\t        found_matching_plugin = False\n\t        for plugin in plugins:\n\t            if not found_matching_plugin:\n\t                result = asyncio.run_coroutine_threadsafe(\n\t                    plugin.handle_meshtastic_message(\n", "                        packet, formatted_message=None, longname=None, meshnet_name=None\n\t                    ),\n\t                    loop=loop,\n\t                )\n\t                found_matching_plugin = result.result()\n\t                if found_matching_plugin:\n\t                    logger.debug(\n\t                        f\"Processed {portnum} with plugin {plugin.plugin_name}\"\n\t                    )\n"]}
{"filename": "main.py", "chunked_list": ["\"\"\"\n\tThis script connects a Meshtastic mesh network to Matrix chat rooms by relaying messages between them.\n\tIt uses Meshtastic-python and Matrix nio client library to interface with the radio and the Matrix server respectively.\n\t\"\"\"\n\timport asyncio\n\tfrom nio import (\n\t    RoomMessageText,\n\t    RoomMessageNotice,\n\t)\n\tfrom pubsub import pub\n", "from typing import List\n\tfrom db_utils import initialize_database, update_longnames, update_shortnames\n\tfrom matrix_utils import (\n\t    connect_matrix,\n\t    join_matrix_room,\n\t    on_room_message,\n\t    logger as matrix_logger,\n\t)\n\tfrom plugin_loader import load_plugins\n\tfrom config import relay_config\n", "from log_utils import get_logger\n\tfrom meshtastic_utils import (\n\t    connect_meshtastic,\n\t    on_meshtastic_message,\n\t    on_lost_meshtastic_connection,\n\t    logger as meshtastic_logger,\n\t)\n\tlogger = get_logger(name=\"M<>M Relay\")\n\tmeshtastic_interface = connect_meshtastic()\n\tmatrix_rooms: List[dict] = relay_config[\"matrix_rooms\"]\n", "matrix_access_token = relay_config[\"matrix\"][\"access_token\"]\n\tasync def main():\n\t    # Initialize the SQLite database\n\t    initialize_database()\n\t    # Load plugins early\n\t    load_plugins()\n\t    matrix_client = await connect_matrix()\n\t    matrix_logger.info(\"Connecting ...\")\n\t    try:\n\t        login_response = await matrix_client.login(matrix_access_token)\n", "    except Exception as e:\n\t        matrix_logger.error(f\"Error connecting to Matrix server: {e}\")\n\t        return\n\t    # Join the rooms specified in the config.yaml\n\t    for room in matrix_rooms:\n\t        await join_matrix_room(matrix_client, room[\"id\"])\n\t    # Register the Meshtastic message callback\n\t    meshtastic_logger.info(f\"Listening for inbound radio messages ...\")\n\t    pub.subscribe(\n\t        on_meshtastic_message, \"meshtastic.receive\", loop=asyncio.get_event_loop()\n", "    )\n\t    pub.subscribe(\n\t        on_lost_meshtastic_connection,\n\t        \"meshtastic.connection.lost\",\n\t    )\n\t    # Register the message callback\n\t    matrix_logger.info(f\"Listening for inbound matrix messages ...\")\n\t    matrix_client.add_event_callback(\n\t        on_room_message, (RoomMessageText, RoomMessageNotice)\n\t    )\n", "    # Start the Matrix client\n\t    while True:\n\t        try:\n\t            # Update longnames & shortnames\n\t            update_longnames(meshtastic_interface.nodes)\n\t            update_shortnames(meshtastic_interface.nodes)\n\t            matrix_logger.info(\"Syncing with server...\")\n\t            await matrix_client.sync_forever(timeout=30000)\n\t            matrix_logger.info(\"Sync completed.\")\n\t        except Exception as e:\n", "            matrix_logger.error(f\"Error syncing with server: {e}\")\n\t        await asyncio.sleep(60)  # Update longnames & shortnames every 60 seconds\n\tasyncio.run(main())\n"]}
{"filename": "config.py", "chunked_list": ["import yaml\n\tfrom yaml.loader import SafeLoader\n\trelay_config = {}\n\twith open(\"config.yaml\", \"r\") as f:\n\t    relay_config = yaml.load(f, Loader=SafeLoader)\n"]}
{"filename": "log_utils.py", "chunked_list": ["import logging\n\tfrom config import relay_config\n\tdef get_logger(name):\n\t    logger = logging.getLogger(name=name)\n\t    log_level = getattr(logging, relay_config[\"logging\"][\"level\"].upper())\n\t    logger.setLevel(log_level)\n\t    logger.propagate = False  # Add this line to prevent double logging\n\t    handler = logging.StreamHandler()\n\t    handler.setFormatter(\n\t        logging.Formatter(\n", "            fmt=f\"%(asctime)s %(levelname)s:%(name)s:%(message)s\",\n\t            datefmt=\"%Y-%m-%d %H:%M:%S %z\",\n\t        )\n\t    )\n\t    logger.addHandler(handler)\n\t    return logger\n"]}
{"filename": "matrix_utils.py", "chunked_list": ["import asyncio\n\timport time\n\timport re\n\timport certifi\n\timport io\n\timport ssl\n\tfrom typing import List, Union\n\tfrom nio import (\n\t    AsyncClient,\n\t    AsyncClientConfig,\n", "    MatrixRoom,\n\t    RoomMessageText,\n\t    RoomMessageNotice,\n\t    UploadResponse,\n\t)\n\tfrom config import relay_config\n\tfrom log_utils import get_logger\n\tfrom plugin_loader import load_plugins\n\tfrom meshtastic_utils import connect_meshtastic\n\tfrom PIL import Image\n", "matrix_homeserver = relay_config[\"matrix\"][\"homeserver\"]\n\tmatrix_rooms: List[dict] = relay_config[\"matrix_rooms\"]\n\tmatrix_access_token = relay_config[\"matrix\"][\"access_token\"]\n\tbot_user_id = relay_config[\"matrix\"][\"bot_user_id\"]\n\tbot_user_name = None  # Detected upon logon\n\tbot_start_time = int(\n\t    time.time() * 1000\n\t)  # Timestamp when the bot starts, used to filter out old messages\n\tlogger = get_logger(name=\"Matrix\")\n\tmatrix_client = None\n", "def bot_command(command, payload):\n\t    return f\"{bot_user_name}: !{command}\" in payload\n\tasync def connect_matrix():\n\t    global matrix_client\n\t    global bot_user_name\n\t    if matrix_client:\n\t        return matrix_client\n\t    # Create SSL context using certifi's certificates\n\t    ssl_context = ssl.create_default_context(cafile=certifi.where())\n\t    # Initialize the Matrix client with custom SSL context\n", "    config = AsyncClientConfig(encryption_enabled=False)\n\t    matrix_client = AsyncClient(\n\t        matrix_homeserver, bot_user_id, config=config, ssl=ssl_context\n\t    )\n\t    matrix_client.access_token = matrix_access_token\n\t    response = await matrix_client.get_displayname(bot_user_id)\n\t    bot_user_name = response.displayname\n\t    return matrix_client\n\tasync def join_matrix_room(matrix_client, room_id_or_alias: str) -> None:\n\t    \"\"\"Join a Matrix room by its ID or alias.\"\"\"\n", "    try:\n\t        if room_id_or_alias.startswith(\"#\"):\n\t            response = await matrix_client.room_resolve_alias(room_id_or_alias)\n\t            if not response.room_id:\n\t                logger.error(\n\t                    f\"Failed to resolve room alias '{room_id_or_alias}': {response.message}\"\n\t                )\n\t                return\n\t            room_id = response.room_id\n\t            # Update the room ID in the matrix_rooms list\n", "            for room_config in matrix_rooms:\n\t                if room_config[\"id\"] == room_id_or_alias:\n\t                    room_config[\"id\"] = room_id\n\t                    break\n\t        else:\n\t            room_id = room_id_or_alias\n\t        if room_id not in matrix_client.rooms:\n\t            response = await matrix_client.join(room_id)\n\t            if response and hasattr(response, \"room_id\"):\n\t                logger.info(f\"Joined room '{room_id_or_alias}' successfully\")\n", "            else:\n\t                logger.error(\n\t                    f\"Failed to join room '{room_id_or_alias}': {response.message}\"\n\t                )\n\t        else:\n\t            logger.debug(f\"Bot is already in room '{room_id_or_alias}'\")\n\t    except Exception as e:\n\t        logger.error(f\"Error joining room '{room_id_or_alias}': {e}\")\n\t# Send message to the Matrix room\n\tasync def matrix_relay(room_id, message, longname, shortname, meshnet_name):\n", "    matrix_client = await connect_matrix()\n\t    try:\n\t        content = {\n\t            \"msgtype\": \"m.text\",\n\t            \"body\": message,\n\t            \"meshtastic_longname\": longname,\n\t            \"meshtastic_shortname\": shortname,\n\t            \"meshtastic_meshnet\": meshnet_name,\n\t        }\n\t        await asyncio.wait_for(\n", "            matrix_client.room_send(\n\t                room_id=room_id,\n\t                message_type=\"m.room.message\",\n\t                content=content,\n\t            ),\n\t            timeout=0.5,\n\t        )\n\t        logger.info(f\"Sent inbound radio message to matrix room: {room_id}\")\n\t    except asyncio.TimeoutError:\n\t        logger.error(f\"Timed out while waiting for Matrix response\")\n", "    except Exception as e:\n\t        logger.error(f\"Error sending radio message to matrix room {room_id}: {e}\")\n\tdef truncate_message(\n\t    text, max_bytes=227\n\t):  # 227 is the maximum that we can run without an error so far.  228 throws an error.\n\t    \"\"\"\n\t    Truncate the given text to fit within the specified byte size.\n\t    :param text: The text to truncate.\n\t    :param max_bytes: The maximum allowed byte size for the truncated text.\n\t    :return: The truncated text.\n", "    \"\"\"\n\t    truncated_text = text.encode(\"utf-8\")[:max_bytes].decode(\"utf-8\", \"ignore\")\n\t    return truncated_text\n\t# Callback for new messages in Matrix room\n\tasync def on_room_message(\n\t    room: MatrixRoom, event: Union[RoomMessageText, RoomMessageNotice]\n\t) -> None:\n\t    full_display_name = \"Unknown user\"\n\t    message_timestamp = event.server_timestamp\n\t    # We do not relay the past\n", "    if message_timestamp < bot_start_time:\n\t        return\n\t    room_config = None\n\t    for config in matrix_rooms:\n\t        if config[\"id\"] == room.room_id:\n\t            room_config = config\n\t            break\n\t    # Only relay supported rooms\n\t    if not room_config:\n\t        return\n", "    text = event.body.strip()\n\t    longname = event.source[\"content\"].get(\"meshtastic_longname\")\n\t    shortname = event.source[\"content\"].get(\"meshtastic_shortname\", None)\n\t    meshnet_name = event.source[\"content\"].get(\"meshtastic_meshnet\")\n\t    suppress = event.source[\"content\"].get(\"mmrelay_suppress\")\n\t    local_meshnet_name = relay_config[\"meshtastic\"][\"meshnet_name\"]\n\t    # Do not process\n\t    if suppress:\n\t        return\n\t    if longname and meshnet_name:\n", "        full_display_name = f\"{longname}/{meshnet_name}\"\n\t        if meshnet_name != local_meshnet_name:\n\t            logger.info(f\"Processing message from remote meshnet: {text}\")\n\t            short_meshnet_name = meshnet_name[:4]\n\t            # If shortname is None, truncate the longname to 3 characters\n\t            if shortname is None:\n\t                shortname = longname[:3]           \n\t            prefix = f\"{shortname}/{short_meshnet_name}: \"\n\t            text = re.sub(\n\t                rf\"^\\[{full_display_name}\\]: \", \"\", text\n", "            )  # Remove the original prefix from the text\n\t            text = truncate_message(text)\n\t            full_message = f\"{prefix}{text}\"\n\t        else:\n\t            # This is a message from a local user, it should be ignored no log is needed\n\t            return\n\t    else:\n\t        display_name_response = await matrix_client.get_displayname(event.sender)\n\t        full_display_name = display_name_response.displayname or event.sender\n\t        short_display_name = full_display_name[:5]\n", "        prefix = f\"{short_display_name}[M]: \"\n\t        logger.debug(f\"Processing matrix message from [{full_display_name}]: {text}\")\n\t        full_message = f\"{prefix}{text}\"\n\t        text = truncate_message(text)\n\t        truncated_message = f\"{prefix}{text}\"\n\t    # Plugin functionality\n\t    plugins = load_plugins()\n\t    meshtastic_interface = connect_meshtastic()\n\t    from meshtastic_utils import logger as meshtastic_logger\n\t    found_matching_plugin = False\n", "    for plugin in plugins:\n\t        if not found_matching_plugin:\n\t            found_matching_plugin = await plugin.handle_room_message(\n\t                room, event, full_message\n\t            )\n\t            if found_matching_plugin:\n\t                logger.debug(f\"Processed by plugin {plugin.plugin_name}\")\n\t    meshtastic_channel = room_config[\"meshtastic_channel\"]\n\t    if not found_matching_plugin and event.sender != bot_user_id:\n\t        if relay_config[\"meshtastic\"][\"broadcast_enabled\"]:\n", "            meshtastic_logger.info(\n\t                f\"Relaying message from {full_display_name} to radio broadcast\"\n\t            )\n\t            meshtastic_interface.sendText(\n\t                text=full_message, channelIndex=meshtastic_channel\n\t            )\n\t        else:\n\t            logger.debug(\n\t                f\"Broadcast not supported: Message from {full_display_name} dropped.\"\n\t            )\n", "async def upload_image(\n\t    client: AsyncClient, image: Image.Image, filename: str\n\t) -> UploadResponse:\n\t    buffer = io.BytesIO()\n\t    image.save(buffer, format=\"PNG\")\n\t    image_data = buffer.getvalue()\n\t    response, maybe_keys = await client.upload(\n\t        io.BytesIO(image_data),\n\t        content_type=\"image/png\",\n\t        filename=filename,\n", "        filesize=len(image_data),\n\t    )\n\t    return response\n\tasync def send_room_image(\n\t    client: AsyncClient, room_id: str, upload_response: UploadResponse\n\t):\n\t    response = await client.room_send(\n\t        room_id=room_id,\n\t        message_type=\"m.room.message\",\n\t        content={\"msgtype\": \"m.image\", \"url\": upload_response.content_uri, \"body\": \"\"},\n", "    )\n"]}
{"filename": "plugins/ping_plugin.py", "chunked_list": ["import re\n\tfrom plugins.base_plugin import BasePlugin\n\tclass Plugin(BasePlugin):\n\t    plugin_name = \"ping\"\n\t    @property\n\t    def description(self):\n\t        return f\"Check connectivity with the relay\"\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n\t    ):\n", "        if (\n\t            \"decoded\" in packet\n\t            and \"portnum\" in packet[\"decoded\"]\n\t            and packet[\"decoded\"][\"portnum\"] == \"TEXT_MESSAGE_APP\"\n\t            and \"text\" in packet[\"decoded\"]\n\t        ):\n\t            message = packet[\"decoded\"][\"text\"]\n\t            message = message.strip()\n\t            if f\"!{self.plugin_name}\" not in message:\n\t                return\n", "            from meshtastic_utils import connect_meshtastic\n\t            meshtastic_client = connect_meshtastic()\n\t            meshtastic_client.sendText(text=\"pong!\", destinationId=packet[\"fromId\"])\n\t            return True\n\t    def get_matrix_commands(self):\n\t        return [self.plugin_name]\n\t    def get_mesh_commands(self):\n\t        return [self.plugin_name]\n\t    async def handle_room_message(self, room, event, full_message):\n\t        full_message = full_message.strip()\n", "        if not self.matches(full_message):\n\t            return False\n\t        response = await self.send_matrix_message(room.room_id, \"pong!\")\n\t        return True\n"]}
{"filename": "plugins/map_plugin.py", "chunked_list": ["import staticmaps\n\timport s2sphere\n\timport math\n\timport random\n\timport io\n\timport re\n\tfrom PIL import Image\n\tfrom nio import AsyncClient, UploadResponse\n\tfrom plugins.base_plugin import BasePlugin\n\tclass TextLabel(staticmaps.Object):\n", "    def __init__(self, latlng: s2sphere.LatLng, text: str, fontSize: int = 12) -> None:\n\t        staticmaps.Object.__init__(self)\n\t        self._latlng = latlng\n\t        self._text = text\n\t        self._margin = 4\n\t        self._arrow = 16\n\t        self._font_size = fontSize\n\t        print(self._font_size)\n\t    def latlng(self) -> s2sphere.LatLng:\n\t        return self._latlng\n", "    def bounds(self) -> s2sphere.LatLngRect:\n\t        return s2sphere.LatLngRect.from_point(self._latlng)\n\t    def extra_pixel_bounds(self) -> staticmaps.PixelBoundsT:\n\t        # Guess text extents.\n\t        tw = len(self._text) * self._font_size * 0.5\n\t        th = self._font_size * 1.2\n\t        w = max(self._arrow, tw + 2.0 * self._margin)\n\t        return (int(w / 2.0), int(th + 2.0 * self._margin + self._arrow), int(w / 2), 0)\n\t    def render_pillow(self, renderer: staticmaps.PillowRenderer) -> None:\n\t        x, y = renderer.transformer().ll2pixel(self.latlng())\n", "        x = x + renderer.offset_x()\n\t        tw, th = renderer.draw().textsize(self._text)\n\t        w = max(self._arrow, tw + 2 * self._margin)\n\t        h = th + 2 * self._margin\n\t        path = [\n\t            (x, y),\n\t            (x + self._arrow / 2, y - self._arrow),\n\t            (x + w / 2, y - self._arrow),\n\t            (x + w / 2, y - self._arrow - h),\n\t            (x - w / 2, y - self._arrow - h),\n", "            (x - w / 2, y - self._arrow),\n\t            (x - self._arrow / 2, y - self._arrow),\n\t        ]\n\t        renderer.draw().polygon(path, fill=(255, 255, 255, 255))\n\t        renderer.draw().line(path, fill=(255, 0, 0, 255))\n\t        renderer.draw().text(\n\t            (x - tw / 2, y - self._arrow - h / 2 - th / 2),\n\t            self._text,\n\t            fill=(0, 0, 0, 255),\n\t        )\n", "    def render_cairo(self, renderer: staticmaps.CairoRenderer) -> None:\n\t        x, y = renderer.transformer().ll2pixel(self.latlng())\n\t        ctx = renderer.context()\n\t        ctx.select_font_face(\"Sans\", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)\n\t        ctx.set_font_size(self._font_size)\n\t        x_bearing, y_bearing, tw, th, _, _ = ctx.text_extents(self._text)\n\t        w = max(self._arrow, tw + 2 * self._margin)\n\t        h = th + 2 * self._margin\n\t        path = [\n\t            (x, y),\n", "            (x + self._arrow / 2, y - self._arrow),\n\t            (x + w / 2, y - self._arrow),\n\t            (x + w / 2, y - self._arrow - h),\n\t            (x - w / 2, y - self._arrow - h),\n\t            (x - w / 2, y - self._arrow),\n\t            (x - self._arrow / 2, y - self._arrow),\n\t        ]\n\t        ctx.set_source_rgb(1, 1, 1)\n\t        ctx.new_path()\n\t        for p in path:\n", "            ctx.line_to(*p)\n\t        ctx.close_path()\n\t        ctx.fill()\n\t        ctx.set_source_rgb(1, 0, 0)\n\t        ctx.set_line_width(1)\n\t        ctx.new_path()\n\t        for p in path:\n\t            ctx.line_to(*p)\n\t        ctx.close_path()\n\t        ctx.stroke()\n", "        ctx.set_source_rgb(0, 0, 0)\n\t        ctx.set_line_width(1)\n\t        ctx.move_to(\n\t            x - tw / 2 - x_bearing, y - self._arrow - h / 2 - y_bearing - th / 2\n\t        )\n\t        ctx.show_text(self._text)\n\t        ctx.stroke()\n\t    def render_svg(self, renderer: staticmaps.SvgRenderer) -> None:\n\t        x, y = renderer.transformer().ll2pixel(self.latlng())\n\t        # guess text extents\n", "        tw = len(self._text) * self._font_size * 0.5\n\t        th = self._font_size * 1.2\n\t        w = max(self._arrow, tw + 2 * self._margin)\n\t        h = th + 2 * self._margin\n\t        path = renderer.drawing().path(\n\t            fill=\"#ffffff\",\n\t            stroke=\"#ff0000\",\n\t            stroke_width=1,\n\t            opacity=1.0,\n\t        )\n", "        path.push(f\"M {x} {y}\")\n\t        path.push(f\" l {self._arrow / 2} {-self._arrow}\")\n\t        path.push(f\" l {w / 2 - self._arrow / 2} 0\")\n\t        path.push(f\" l 0 {-h}\")\n\t        path.push(f\" l {-w} 0\")\n\t        path.push(f\" l 0 {h}\")\n\t        path.push(f\" l {w / 2 - self._arrow / 2} 0\")\n\t        path.push(\"Z\")\n\t        renderer.group().add(path)\n\t        renderer.group().add(\n", "            renderer.drawing().text(\n\t                self._text,\n\t                text_anchor=\"middle\",\n\t                dominant_baseline=\"central\",\n\t                insert=(x, y - self._arrow - h / 2),\n\t                font_family=\"sans-serif\",\n\t                font_size=f\"{self._font_size}px\",\n\t                fill=\"#000000\",\n\t            )\n\t        )\n", "def anonymize_location(lat, lon, radius=1000):\n\t    # Generate random offsets for latitude and longitude\n\t    lat_offset = random.uniform(-radius / 111320, radius / 111320)\n\t    lon_offset = random.uniform(\n\t        -radius / (111320 * math.cos(lat)), radius / (111320 * math.cos(lat))\n\t    )\n\t    # Apply the offsets to the location coordinates\n\t    new_lat = lat + lat_offset\n\t    new_lon = lon + lon_offset\n\t    return new_lat, new_lon\n", "def get_map(locations, zoom=None, image_size=None, anonymize=True, radius=10000):\n\t    \"\"\"\n\t    Anonymize a location to 10km by default\n\t    \"\"\"\n\t    context = staticmaps.Context()\n\t    context.set_tile_provider(staticmaps.tile_provider_OSM)\n\t    context.set_zoom(zoom)\n\t    for location in locations:\n\t        if anonymize:\n\t            new_location = anonymize_location(\n", "                lat=float(location[\"lat\"]),\n\t                lon=float(location[\"lon\"]),\n\t                radius=radius,\n\t            )\n\t            radio = staticmaps.create_latlng(new_location[0], new_location[1])\n\t        else:\n\t            radio = staticmaps.create_latlng(\n\t                float(location[\"lat\"]), float(location[\"lon\"])\n\t            )\n\t        context.add_object(TextLabel(radio, location[\"label\"], fontSize=50))\n", "    # render non-anti-aliased png\n\t    if image_size:\n\t        return context.render_pillow(image_size[0], image_size[1])\n\t    else:\n\t        return context.render_pillow(1000, 1000)\n\tasync def upload_image(client: AsyncClient, image: Image.Image) -> UploadResponse:\n\t    buffer = io.BytesIO()\n\t    image.save(buffer, format=\"PNG\")\n\t    image_data = buffer.getvalue()\n\t    response, maybe_keys = await client.upload(\n", "        io.BytesIO(image_data),\n\t        content_type=\"image/png\",\n\t        filename=\"location.png\",\n\t        filesize=len(image_data),\n\t    )\n\t    return response\n\tasync def send_room_image(\n\t    client: AsyncClient, room_id: str, upload_response: UploadResponse\n\t):\n\t    response = await client.room_send(\n", "        room_id=room_id,\n\t        message_type=\"m.room.message\",\n\t        content={\"msgtype\": \"m.image\", \"url\": upload_response.content_uri, \"body\": \"\"},\n\t    )\n\tasync def send_image(client: AsyncClient, room_id: str, image: Image.Image):\n\t    response = await upload_image(client=client, image=image)\n\t    await send_room_image(client, room_id, upload_response=response)\n\tclass Plugin(BasePlugin):\n\t    plugin_name = \"map\"\n\t    @property\n", "    def description(self):\n\t        return (\n\t            f\"Map of mesh radio nodes. Supports `zoom` and `size` options to customize\"\n\t        )\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n\t    ):\n\t        return False\n\t    def get_matrix_commands(self):\n\t        return [self.plugin_name]\n", "    def get_mesh_commands(self):\n\t        return []\n\t    async def handle_room_message(self, room, event, full_message):\n\t        full_message = full_message.strip()\n\t        if not self.matches(full_message):\n\t            return False\n\t        from matrix_utils import connect_matrix\n\t        from meshtastic_utils import connect_meshtastic\n\t        matrix_client = await connect_matrix()\n\t        meshtastic_client = connect_meshtastic()\n", "        pattern = r\"^.*:(?: !map(?: zoom=(\\d+))?(?: size=(\\d+),(\\d+))?)?$\"\n\t        match = re.match(pattern, full_message)\n\t        # Indicate this message is not meant for this plugin\n\t        if not match:\n\t            return False\n\t        zoom = match.group(1)\n\t        image_size = match.group(2, 3)\n\t        try:\n\t            zoom = int(zoom)\n\t        except:\n", "            zoom = self.config[\"zoom\"] if \"zoom\" in self.config else 8\n\t        if zoom < 0 or zoom > 30:\n\t            zoom = 8\n\t        try:\n\t            image_size = (int(image_size[0]), int(image_size[1]))\n\t        except:\n\t            image_size = (\n\t                self.config[\"image_width\"] if \"image_width\" in self.config else 1000,\n\t                self.config[\"image_height\"] if \"image_height\" in self.config else 1000,\n\t            )\n", "        if image_size[0] > 1000 or image_size[1] > 1000:\n\t            image_size = (1000, 1000)\n\t        locations = []\n\t        for node, info in meshtastic_client.nodes.items():\n\t            if \"position\" in info and \"latitude\" in info[\"position\"]:\n\t                locations.append(\n\t                    {\n\t                        \"lat\": info[\"position\"][\"latitude\"],\n\t                        \"lon\": info[\"position\"][\"longitude\"],\n\t                        \"label\": info[\"user\"][\"shortName\"],\n", "                    }\n\t                )\n\t        anonymize = self.config[\"anonymize\"] if \"anonymize\" in self.config else True\n\t        radius = self.config[\"radius\"] if \"radius\" in self.config else 1000\n\t        pillow_image = get_map(\n\t            locations=locations,\n\t            zoom=zoom,\n\t            image_size=image_size,\n\t            anonymize=anonymize,\n\t            radius=radius,\n", "        )\n\t        await send_image(matrix_client, room.room_id, pillow_image)\n\t        return True\n"]}
{"filename": "plugins/drop_plugin.py", "chunked_list": ["import re\n\tfrom haversine import haversine\n\tfrom plugins.base_plugin import BasePlugin\n\tfrom meshtastic_utils import connect_meshtastic\n\tfrom meshtastic import mesh_pb2\n\tclass Plugin(BasePlugin):\n\t    plugin_name = \"drop\"\n\t    special_node = \"!NODE_MSGS!\"\n\t    def get_position(self, meshtastic_client, node_id):\n\t        for node, info in meshtastic_client.nodes.items():\n", "            if info[\"user\"][\"id\"] == node_id:\n\t                return info[\"position\"]\n\t        return None\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n\t    ):\n\t        meshtastic_client = connect_meshtastic()\n\t        nodeInfo = meshtastic_client.getMyNodeInfo()\n\t        # Attempt message drop to packet originator if not relay\n\t        if \"fromId\" in packet and packet[\"fromId\"] != nodeInfo[\"user\"][\"id\"]:\n", "            position = self.get_position(meshtastic_client, packet[\"fromId\"])\n\t            if position and \"latitude\" in position and \"longitude\" in position:\n\t                packet_location = (\n\t                    position[\"latitude\"],\n\t                    position[\"longitude\"],\n\t                )\n\t                self.logger.debug(f\"Packet originates from: {packet_location}\")\n\t                messages = self.get_node_data(self.special_node)\n\t                unsent_messages = []\n\t                for message in messages:\n", "                    # You cannot pickup what you dropped\n\t                    if (\n\t                        \"originator\" in message\n\t                        and message[\"originator\"] == packet[\"fromId\"]\n\t                    ):\n\t                        unsent_messages.append(message)\n\t                        continue\n\t                    try:\n\t                        distance_km = haversine(\n\t                            (packet_location[0], packet_location[1]),\n", "                            message[\"location\"],\n\t                        )\n\t                    except:\n\t                        distance_km = 1000\n\t                    radius_km = (\n\t                        self.config[\"radius_km\"] if \"radius_km\" in self.config else 5\n\t                    )\n\t                    if distance_km <= radius_km:\n\t                        target_node = packet[\"fromId\"]\n\t                        self.logger.debug(f\"Sending dropped message to {target_node}\")\n", "                        meshtastic_client.sendText(\n\t                            text=message[\"text\"], destinationId=target_node\n\t                        )\n\t                    else:\n\t                        unsent_messages.append(message)\n\t                self.set_node_data(self.special_node, unsent_messages)\n\t                total_unsent_messages = len(unsent_messages)\n\t                if total_unsent_messages > 0:\n\t                    self.logger.debug(f\"{total_unsent_messages} message(s) remaining\")\n\t        # Attempt to drop a message\n", "        if (\n\t            \"decoded\" in packet\n\t            and \"portnum\" in packet[\"decoded\"]\n\t            and packet[\"decoded\"][\"portnum\"] == \"TEXT_MESSAGE_APP\"\n\t        ):\n\t            text = packet[\"decoded\"][\"text\"] if \"text\" in packet[\"decoded\"] else None\n\t            if f\"!{self.plugin_name}\" not in text:\n\t                return False\n\t            match = re.search(r\"!drop\\s+(.+)$\", text)\n\t            if not match:\n", "                return False\n\t            drop_message = match.group(1)\n\t            position = {}\n\t            for node, info in meshtastic_client.nodes.items():\n\t                if info[\"user\"][\"id\"] == packet[\"fromId\"]:\n\t                    position = info[\"position\"]\n\t            if \"latitude\" not in position or \"longitude\" not in position:\n\t                self.logger.debug(\n\t                    \"Position of dropping node is not known. Skipping ...\"\n\t                )\n", "                return True\n\t            self.store_node_data(\n\t                self.special_node,\n\t                {\n\t                    \"location\": (position[\"latitude\"], position[\"longitude\"]),\n\t                    \"text\": drop_message,\n\t                    \"originator\": packet[\"fromId\"],\n\t                },\n\t            )\n\t            self.logger.debug(f\"Dropped a message: {drop_message}\")\n", "            return True\n\t    async def handle_room_message(self, room, event, full_message):\n\t        if self.matches(full_message):\n\t            return True\n"]}
{"filename": "plugins/base_plugin.py", "chunked_list": ["import markdown\n\timport schedule\n\timport threading\n\timport time\n\tfrom abc import ABC, abstractmethod\n\tfrom log_utils import get_logger\n\tfrom config import relay_config\n\tfrom db_utils import (\n\t    store_plugin_data,\n\t    get_plugin_data,\n", "    get_plugin_data_for_node,\n\t    delete_plugin_data,\n\t)\n\tclass BasePlugin(ABC):\n\t    plugin_name = None\n\t    max_data_rows_per_node = 100\n\t    priority = 10\n\t    @property\n\t    def description(self):\n\t        return f\"\"\n", "    def __init__(self) -> None:\n\t        super().__init__()\n\t        self.logger = get_logger(f\"Plugin:{self.plugin_name}\")\n\t        self.config = {\"active\": False}\n\t        if \"plugins\" in relay_config and self.plugin_name in relay_config[\"plugins\"]:\n\t            self.config = relay_config[\"plugins\"][self.plugin_name]\n\t    def start(self):\n\t        if \"schedule\" not in self.config or (\n\t            \"at\" not in self.config[\"schedule\"]\n\t            and \"hours\" not in self.config[\"schedule\"]\n", "            and \"minutes\" not in self.config[\"schedule\"]\n\t        ):\n\t            self.logger.debug(f\"Started with priority={self.priority}\")\n\t            return\n\t        # Schedule the email-checking function to run every minute\n\t        if \"at\" in self.config[\"schedule\"] and \"hours\" in self.config[\"schedule\"]:\n\t            schedule.every(self.config[\"schedule\"][\"hours\"]).hours.at(\n\t                self.config[\"schedule\"][\"at\"]\n\t            ).do(self.background_job)\n\t        elif \"at\" in self.config[\"schedule\"] and \"minutes\" in self.config[\"schedule\"]:\n", "            schedule.every(self.config[\"schedule\"][\"minutes\"]).minutes.at(\n\t                self.config[\"schedule\"][\"at\"]\n\t            ).do(self.background_job)\n\t        elif \"hours\" in self.config[\"schedule\"]:\n\t            schedule.every(self.config[\"schedule\"][\"hours\"]).hours.do(\n\t                self.background_job\n\t            )\n\t        elif \"minutes\" in self.config[\"schedule\"]:\n\t            schedule.every(self.config[\"schedule\"][\"minutes\"]).minutes.do(\n\t                self.background_job\n", "            )\n\t        # Function to execute the scheduled tasks\n\t        def run_schedule():\n\t            while True:\n\t                schedule.run_pending()\n\t                time.sleep(1)\n\t        # Create a thread for executing the scheduled tasks\n\t        schedule_thread = threading.Thread(target=run_schedule)\n\t        # Start the thread\n\t        schedule_thread.start()\n", "        self.logger.debug(f\"Scheduled with priority={self.priority}\")\n\t    def background_job(self):\n\t        pass\n\t    def strip_raw(self, data):\n\t        if type(data) is not dict:\n\t            return data\n\t        if \"raw\" in data:\n\t            del data[\"raw\"]\n\t        for k, v in data.items():\n\t            data[k] = self.strip_raw(v)\n", "        return data\n\t    def get_matrix_commands(self):\n\t        return [self.plugin_name]\n\t    async def send_matrix_message(self, room_id, message, formatted=True):\n\t        from matrix_utils import connect_matrix\n\t        matrix_client = await connect_matrix()\n\t        return await matrix_client.room_send(\n\t            room_id=room_id,\n\t            message_type=\"m.room.message\",\n\t            content={\n", "                \"msgtype\": \"m.text\",\n\t                \"format\": \"org.matrix.custom.html\" if formatted else None,\n\t                \"body\": message,\n\t                \"formatted_body\": markdown.markdown(message),\n\t            },\n\t        )\n\t    def get_mesh_commands(self):\n\t        return []\n\t    def store_node_data(self, meshtastic_id, node_data):\n\t        data = self.get_node_data(meshtastic_id=meshtastic_id)\n", "        data = data[-self.max_data_rows_per_node :]\n\t        if type(node_data) is list:\n\t            data.extend(node_data)\n\t        else:\n\t            data.append(node_data)\n\t        store_plugin_data(self.plugin_name, meshtastic_id, data)\n\t    def set_node_data(self, meshtastic_id, node_data):\n\t        node_data = node_data[-self.max_data_rows_per_node :]\n\t        store_plugin_data(self.plugin_name, meshtastic_id, node_data)\n\t    def delete_node_data(self, meshtastic_id):\n", "        return delete_plugin_data(self.plugin_name, meshtastic_id)\n\t    def get_node_data(self, meshtastic_id):\n\t        return get_plugin_data_for_node(self.plugin_name, meshtastic_id)\n\t    def get_data(self):\n\t        return get_plugin_data(self.plugin_name)\n\t    def matches(self, payload):\n\t        from matrix_utils import bot_command\n\t        if type(payload) == str:\n\t            return bot_command(self.plugin_name, payload)\n\t        return False\n", "    @abstractmethod\n\t    async def handle_meshtastic_message(\n\t        packet, formatted_message, longname, meshnet_name\n\t    ):\n\t        print(\"Base plugin: handling Meshtastic message\")\n\t    @abstractmethod\n\t    async def handle_room_message(room, event, full_message):\n\t        print(\"Base plugin: handling room message\")\n"]}
{"filename": "plugins/nodes_plugin.py", "chunked_list": ["import re\n\timport statistics\n\tfrom plugins.base_plugin import BasePlugin\n\tfrom datetime import datetime\n\tdef get_relative_time(timestamp):\n\t    now = datetime.now()\n\t    dt = datetime.fromtimestamp(timestamp)\n\t    # Calculate the time difference between the current time and the given timestamp\n\t    delta = now - dt\n\t    # Extract the relevant components from the time difference\n", "    days = delta.days\n\t    seconds = delta.seconds\n\t    # Convert the time difference into a relative timeframe\n\t    if days > 7:\n\t        return dt.strftime(\n\t            \"%b %d, %Y\"\n\t        )  # Return the timestamp in a specific format if it's older than 7 days\n\t    elif days >= 1:\n\t        return f\"{days} days ago\"\n\t    elif seconds >= 3600:\n", "        hours = seconds // 3600\n\t        return f\"{hours} hours ago\"\n\t    elif seconds >= 60:\n\t        minutes = seconds // 60\n\t        return f\"{minutes} minutes ago\"\n\t    else:\n\t        return \"Just now\"\n\tclass Plugin(BasePlugin):\n\t    plugin_name = \"nodes\"\n\t    @property\n", "    def description(self):\n\t        return \"\"\"Show mesh radios and node data\n\t$shortname $longname / $devicemodel / $battery $voltage / $snr / $lastseen\n\t\"\"\"\n\t    def generate_response(self):\n\t        from meshtastic_utils import connect_meshtastic\n\t        meshtastic_client = connect_meshtastic()\n\t        response = f\"Nodes: {len(meshtastic_client.nodes)}\\n\"\n\t        for node, info in meshtastic_client.nodes.items():\n\t            if \"snr\" in info:\n", "                snr = f\"{info['snr']} dB\"\n\t            else:\n\t                snr = \"\"\n\t            voltage = \"?V\"\n\t            battery = \"?%\"\n\t            if \"deviceMetrics\" in info:\n\t                if \"voltage\" in info[\"deviceMetrics\"]:\n\t                    voltage = f\"{info['deviceMetrics']['voltage']}V\"\n\t                if \"batteryLevel\" in info[\"deviceMetrics\"]:\n\t                    battery = f\"{info['deviceMetrics']['batteryLevel']}%\"\n", "            response += f\"{info['user']['shortName']} {info['user']['longName']} / {info['user']['hwModel']} / {battery} {voltage} / {snr} / {get_relative_time(info['lastHeard'])}\\n\"\n\t        return response\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n\t    ):\n\t        return False\n\t    async def handle_room_message(self, room, event, full_message):\n\t        from matrix_utils import connect_matrix\n\t        full_message = full_message.strip()\n\t        if not self.matches(full_message):\n", "            return False\n\t        response = await self.send_matrix_message(\n\t            room_id=room.room_id, message=self.generate_response(), formatted=False\n\t        )\n\t        return True\n"]}
{"filename": "plugins/weather_plugin.py", "chunked_list": ["import re\n\timport requests\n\tfrom plugins.base_plugin import BasePlugin\n\tclass Plugin(BasePlugin):\n\t    plugin_name = \"weather\"\n\t    @property\n\t    def description(self):\n\t        return f\"Show weather forecast for a radio node using GPS location\"\n\t    def generate_forecast(self, latitude, longitude):\n\t        url = f\"https://api.open-meteo.com/v1/forecast?latitude={latitude}&longitude={longitude}&hourly=temperature_2m,precipitation_probability,weathercode,cloudcover&forecast_days=1&current_weather=true\"\n", "        try:\n\t            response = requests.get(url)\n\t            data = response.json()\n\t            # Extract relevant weather data\n\t            current_temp = data[\"current_weather\"][\"temperature\"]\n\t            current_weather_code = data[\"current_weather\"][\"weathercode\"]\n\t            is_day = data[\"current_weather\"][\"is_day\"]\n\t            forecast_2h_temp = data[\"hourly\"][\"temperature_2m\"][2]\n\t            forecast_2h_precipitation = data[\"hourly\"][\"precipitation_probability\"][2]\n\t            forecast_2h_weather_code = data[\"hourly\"][\"weathercode\"][2]\n", "            forecast_5h_temp = data[\"hourly\"][\"temperature_2m\"][5]\n\t            forecast_5h_precipitation = data[\"hourly\"][\"precipitation_probability\"][5]\n\t            forecast_5h_weather_code = data[\"hourly\"][\"weathercode\"][5]\n\t            def weather_code_to_text(weather_code, is_day):\n\t                weather_mapping = {\n\t                    0: \" Sunny\" if is_day else \" Clear\",\n\t                    1: \" Partly Cloudy\" if is_day else \" Clear\",\n\t                    2: \" Mostly Clear\" if is_day else \" Mostly Clear\",\n\t                    3: \" Mostly Cloudy\" if is_day else \" Mostly Clear\",\n\t                    4: \" Cloudy\" if is_day else \" Cloudy\",\n", "                    5: \" Rainy\" if is_day else \" Rainy\",\n\t                    6: \" Thunderstorm\" if is_day else \" Thunderstorm\",\n\t                    7: \" Snowy\" if is_day else \" Snowy\",\n\t                    8: \" Wintry Mix\" if is_day else \" Wintry Mix\",\n\t                    9: \" Foggy\" if is_day else \" Foggy\",\n\t                    10: \" Windy\" if is_day else \" Windy\",\n\t                    11: \" Stormy/Hail\" if is_day else \" Stormy/Hail\",\n\t                    12: \" Foggy\" if is_day else \" Foggy\",\n\t                    13: \" Foggy\" if is_day else \" Foggy\",\n\t                    14: \" Foggy\" if is_day else \" Foggy\",\n", "                    15: \" Volcanic Ash\" if is_day else \" Volcanic Ash\",\n\t                    16: \" Rainy\" if is_day else \" Rainy\",\n\t                    17: \" Foggy\" if is_day else \" Foggy\",\n\t                    18: \" Tornado\" if is_day else \" Tornado\",\n\t                }\n\t                return weather_mapping.get(weather_code, \" Unknown\")\n\t            # Generate one-line weather forecast\n\t            forecast = f\"Now: {weather_code_to_text(current_weather_code, is_day)} - {current_temp}C | \"\n\t            forecast += f\"+2h: {weather_code_to_text(forecast_2h_weather_code, is_day)} - {forecast_2h_temp}C {forecast_2h_precipitation}% | \"\n\t            forecast += f\"+5h: {weather_code_to_text(forecast_5h_weather_code, is_day)} - {forecast_5h_temp}C {forecast_5h_precipitation}%\"\n", "            return forecast\n\t        except requests.exceptions.RequestException as e:\n\t            print(f\"Error: {e}\")\n\t            return None\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n\t    ):\n\t        if (\n\t            \"decoded\" in packet\n\t            and \"portnum\" in packet[\"decoded\"]\n", "            and packet[\"decoded\"][\"portnum\"] == \"TEXT_MESSAGE_APP\"\n\t            and \"text\" in packet[\"decoded\"]\n\t        ):\n\t            message = packet[\"decoded\"][\"text\"]\n\t            message = message.strip()\n\t            if f\"!{self.plugin_name}\" not in message:\n\t                return False\n\t            from meshtastic_utils import connect_meshtastic\n\t            meshtastic_client = connect_meshtastic()\n\t            if packet[\"fromId\"] in meshtastic_client.nodes:\n", "                weather_notice = \"Cannot determine location\"\n\t                requesting_node = meshtastic_client.nodes.get(packet[\"fromId\"])\n\t                if (\n\t                    requesting_node\n\t                    and \"position\" in requesting_node\n\t                    and \"latitude\" in requesting_node[\"position\"]\n\t                    and \"longitude\" in requesting_node[\"position\"]\n\t                ):\n\t                    weather_notice = self.generate_forecast(\n\t                        latitude=requesting_node[\"position\"][\"latitude\"],\n", "                        longitude=requesting_node[\"position\"][\"longitude\"],\n\t                    )\n\t                meshtastic_client.sendText(\n\t                    text=weather_notice,\n\t                    destinationId=packet[\"fromId\"],\n\t                )\n\t            return True\n\t    def get_matrix_commands(self):\n\t        return []\n\t    def get_mesh_commands(self):\n", "        return [self.plugin_name]\n\t    async def handle_room_message(self, room, event, full_message):\n\t        return False\n"]}
{"filename": "plugins/health_plugin.py", "chunked_list": ["import re\n\timport statistics\n\tfrom plugins.base_plugin import BasePlugin\n\tclass Plugin(BasePlugin):\n\t    plugin_name = \"health\"\n\t    @property\n\t    def description(self):\n\t        return \"Show mesh health using avg battery, SNR, AirUtil\"\n\t    def generate_response(self):\n\t        from meshtastic_utils import connect_meshtastic\n", "        meshtastic_client = connect_meshtastic()\n\t        battery_levels = []\n\t        air_util_tx = []\n\t        snr = []\n\t        for node, info in meshtastic_client.nodes.items():\n\t            if \"deviceMetrics\" in info:\n\t                battery_levels.append(info[\"deviceMetrics\"][\"batteryLevel\"])\n\t                air_util_tx.append(info[\"deviceMetrics\"][\"airUtilTx\"])\n\t            if \"snr\" in info:\n\t                snr.append(info[\"snr\"])\n", "        low_battery = len([n for n in battery_levels if n <= 10])\n\t        radios = len(meshtastic_client.nodes)\n\t        avg_battery = statistics.mean(battery_levels) if battery_levels else 0\n\t        mdn_battery = statistics.median(battery_levels)\n\t        avg_air = statistics.mean(air_util_tx) if air_util_tx else 0\n\t        mdn_air = statistics.median(air_util_tx)\n\t        avg_snr = statistics.mean(snr) if snr else 0\n\t        mdn_snr = statistics.median(snr)\n\t        return f\"\"\"Nodes: {radios}\n\tBattery: {avg_battery:.1f}% / {mdn_battery:.1f}% (avg / median)\n", "Nodes with Low Battery (< 10): {low_battery}\n\tAir Util: {avg_air:.2f} / {mdn_air:.2f} (avg / median)\n\tSNR: {avg_snr:.2f} / {mdn_snr:.2f} (avg / median)\n\t\"\"\"\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n\t    ):\n\t        return False\n\t    async def handle_room_message(self, room, event, full_message):\n\t        from matrix_utils import connect_matrix\n", "        full_message = full_message.strip()\n\t        if not self.matches(full_message):\n\t            return False\n\t        response = await self.send_matrix_message(\n\t            room.room_id, self.generate_response(), formatted=False\n\t        )\n\t        return True\n"]}
{"filename": "plugins/mesh_relay_plugin.py", "chunked_list": ["import json\n\timport io\n\timport re\n\timport base64\n\timport json\n\tfrom typing import List\n\tfrom meshtastic import mesh_pb2\n\tfrom plugins.base_plugin import BasePlugin\n\tfrom config import relay_config\n\tmatrix_rooms: List[dict] = relay_config[\"matrix_rooms\"]\n", "class Plugin(BasePlugin):\n\t    plugin_name = \"mesh_relay\"\n\t    max_data_rows_per_node = 50\n\t    def normalize(self, dict_obj):\n\t        \"\"\"\n\t        Packets are either a dict, string dict or string\n\t        \"\"\"\n\t        if type(dict_obj) is not dict:\n\t            try:\n\t                dict_obj = json.loads(dict_obj)\n", "            except:\n\t                dict_obj = {\"decoded\": {\"text\": dict_obj}}\n\t        return self.strip_raw(dict_obj)\n\t    def process(self, packet):\n\t        packet = self.normalize(packet)\n\t        if \"decoded\" in packet and \"payload\" in packet[\"decoded\"]:\n\t            if type(packet[\"decoded\"][\"payload\"]) is bytes:\n\t                text = packet[\"decoded\"][\"payload\"]\n\t                packet[\"decoded\"][\"payload\"] = base64.b64encode(\n\t                    packet[\"decoded\"][\"payload\"]\n", "                ).decode(\"utf-8\")\n\t        return packet\n\t    def get_matrix_commands(self):\n\t        return []\n\t    def get_mesh_commands(self):\n\t        return []\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n\t    ):\n\t        from matrix_utils import connect_matrix\n", "        packet = self.process(packet)\n\t        matrix_client = await connect_matrix()\n\t        packet_type = packet[\"decoded\"][\"portnum\"]\n\t        if \"channel\" in packet:\n\t            channel = packet[\"channel\"]\n\t        else:\n\t            channel = 0\n\t        channel_mapped = False\n\t        for room in matrix_rooms:\n\t            if room[\"meshtastic_channel\"] == channel:\n", "                channel_mapped = True\n\t                break\n\t        if not channel_mapped:\n\t            self.logger.debug(f\"Skipping message from unmapped channel {channel}\")\n\t            return\n\t        await matrix_client.room_send(\n\t            room_id=room[\"id\"],\n\t            message_type=\"m.room.message\",\n\t            content={\n\t                \"msgtype\": \"m.text\",\n", "                \"mmrelay_suppress\": True,\n\t                \"meshtastic_packet\": json.dumps(packet),\n\t                \"body\": f\"Processed {packet_type} radio packet\",\n\t            },\n\t        )\n\t        return False\n\t    def matches(self, payload):\n\t        if type(payload) == str:\n\t            match = re.match(r\"^Processed (.+) radio packet$\", payload)\n\t            return match\n", "        return False\n\t    async def handle_room_message(self, room, event, full_message):\n\t        full_message = full_message.strip()\n\t        if not self.matches(full_message):\n\t            return False\n\t        channel = None\n\t        for room in matrix_rooms:\n\t            if room[\"id\"] == room[\"id\"]:\n\t                channel = room[\"meshtastic_channel\"]\n\t        if not channel:\n", "            self.logger.debug(f\"Skipping message from unmapped channel {channel}\")\n\t            return False\n\t        packet_json = event.source[\"content\"].get(\"meshtastic_packet\")\n\t        if not packet_json:\n\t            self.logger.debug(\"Missing embedded packet\")\n\t            return False\n\t        try:\n\t            packet = json.loads(packet_json)\n\t        except Exception as e:\n\t            self.logger.error(f\"Error processing embedded packet: {e}\")\n", "            return\n\t        from meshtastic_utils import connect_meshtastic\n\t        meshtastic_client = connect_meshtastic()\n\t        meshPacket = mesh_pb2.MeshPacket()\n\t        meshPacket.channel = channel\n\t        meshPacket.decoded.payload = base64.b64decode(packet[\"decoded\"][\"payload\"])\n\t        meshPacket.decoded.portnum = packet[\"decoded\"][\"portnum\"]\n\t        meshPacket.decoded.want_response = False\n\t        meshPacket.id = meshtastic_client._generatePacketId()\n\t        self.logger.debug(f\"Relaying packet to Radio\")\n", "        meshtastic_client._sendPacket(\n\t            meshPacket=meshPacket, destinationId=packet[\"toId\"]\n\t        )\n\t        return True\n"]}
{"filename": "plugins/telemetry_plugin.py", "chunked_list": ["import json\n\timport io\n\timport re\n\timport matplotlib.pyplot as plt\n\tfrom PIL import Image\n\tfrom datetime import datetime, timedelta\n\tfrom plugins.base_plugin import BasePlugin\n\tclass Plugin(BasePlugin):\n\t    plugin_name = \"telemetry\"\n\t    max_data_rows_per_node = 50\n", "    def commands(self):\n\t        return [\"batteryLevel\", \"voltage\", \"airUtilTx\"]\n\t    def description(self):\n\t        return f\"Graph of avg Mesh telemetry value for last 12 hours\"\n\t    def _generate_timeperiods(self, hours=12):\n\t        # Calculate the start and end times\n\t        end_time = datetime.now()\n\t        start_time = end_time - timedelta(hours=hours)\n\t        # Create a list of hourly intervals for the last 12 hours\n\t        hourly_intervals = []\n", "        current_time = start_time\n\t        while current_time <= end_time:\n\t            hourly_intervals.append(current_time)\n\t            current_time += timedelta(hours=1)\n\t        return hourly_intervals\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n\t    ):\n\t        # Support deviceMetrics only for now\n\t        if (\n", "            \"decoded\" in packet\n\t            and \"portnum\" in packet[\"decoded\"]\n\t            and packet[\"decoded\"][\"portnum\"] == \"TELEMETRY_APP\"\n\t            and \"telemetry\" in packet[\"decoded\"]\n\t            and \"deviceMetrics\" in packet[\"decoded\"][\"telemetry\"]\n\t        ):\n\t            telemetry_data = []\n\t            data = self.get_node_data(meshtastic_id=packet[\"fromId\"])\n\t            if data:\n\t                telemetry_data = data\n", "            packet_data = packet[\"decoded\"][\"telemetry\"]\n\t            telemetry_data.append(\n\t                {\n\t                    \"time\": packet_data[\"time\"],\n\t                    \"batteryLevel\": packet_data[\"deviceMetrics\"][\"batteryLevel\"],\n\t                    \"voltage\": packet_data[\"deviceMetrics\"][\"voltage\"],\n\t                    \"airUtilTx\": packet_data[\"deviceMetrics\"][\"airUtilTx\"],\n\t                }\n\t            )\n\t            self.set_node_data(meshtastic_id=packet[\"fromId\"], node_data=telemetry_data)\n", "            return False\n\t    def get_matrix_commands(self):\n\t        return [\"batteryLevel\", \"voltage\", \"airUtilTx\"]\n\t    def get_mesh_commands(self):\n\t        return []\n\t    def matches(self, payload):\n\t        from matrix_utils import bot_command\n\t        if type(payload) == str:\n\t            for option in [\"batteryLevel\", \"voltage\", \"airUtilTx\"]:\n\t                if bot_command(option, payload):\n", "                    return True\n\t        return False\n\t    async def handle_room_message(self, room, event, full_message):\n\t        full_message = full_message.strip()\n\t        if not self.matches(full_message):\n\t            return False\n\t        match = re.search(\n\t            r\":\\s+!(batteryLevel|voltage|airUtilTx)(?:\\s+(.+))?$\", full_message\n\t        )\n\t        if not match:\n", "            return False\n\t        telemetry_option = match.group(1)\n\t        node = match.group(2)\n\t        hourly_intervals = self._generate_timeperiods()\n\t        from matrix_utils import connect_matrix\n\t        matrix_client = await connect_matrix()\n\t        # Compute the hourly averages for each node\n\t        hourly_averages = {}\n\t        def calculate_averages(node_data_rows):\n\t            for record in node_data_rows:\n", "                record_time = datetime.fromtimestamp(\n\t                    record[\"time\"]\n\t                )  # Replace with your timestamp field name\n\t                telemetry_value = record[\n\t                    telemetry_option\n\t                ]  # Replace with your battery level field name\n\t                for i in range(len(hourly_intervals) - 1):\n\t                    if hourly_intervals[i] <= record_time < hourly_intervals[i + 1]:\n\t                        if i not in hourly_averages:\n\t                            hourly_averages[i] = []\n", "                        hourly_averages[i].append(telemetry_value)\n\t                        break\n\t        if node:\n\t            node_data_rows = self.get_node_data(node)\n\t            calculate_averages(node_data_rows)\n\t        else:\n\t            for node_data_json in self.get_data():\n\t                node_data_rows = json.loads(node_data_json[0])\n\t                calculate_averages(node_data_rows)\n\t        # Compute the final hourly averages\n", "        final_averages = {}\n\t        for i, interval in enumerate(hourly_intervals[:-1]):\n\t            if i in hourly_averages:\n\t                final_averages[interval] = sum(hourly_averages[i]) / len(\n\t                    hourly_averages[i]\n\t                )\n\t            else:\n\t                final_averages[interval] = 0.0\n\t        # Extract the hourly intervals and average values into separate lists\n\t        hourly_intervals = list(final_averages.keys())\n", "        average_values = list(final_averages.values())\n\t        # Convert the hourly intervals to strings\n\t        hourly_strings = [hour.strftime(\"%H\") for hour in hourly_intervals]\n\t        # Create the plot\n\t        fig, ax = plt.subplots()\n\t        ax.plot(hourly_strings, average_values)\n\t        # Set the plot title and axis labels\n\t        if node:\n\t            title = f\"{node} Hourly {telemetry_option} Averages\"\n\t        else:\n", "            title = f\"Network Hourly {telemetry_option} Averages\"\n\t        ax.set_title(title)\n\t        ax.set_xlabel(\"Hour\")\n\t        ax.set_ylabel(f\"{telemetry_option}\")\n\t        # Rotate the x-axis labels for readability\n\t        plt.xticks(rotation=45)\n\t        # Save the plot as a PIL image\n\t        buf = io.BytesIO()\n\t        fig.canvas.print_png(buf)\n\t        buf.seek(0)\n", "        img = Image.open(buf)\n\t        pil_image = Image.frombytes(mode=\"RGBA\", size=img.size, data=img.tobytes())\n\t        from matrix_utils import upload_image, send_room_image\n\t        upload_response = await upload_image(matrix_client, pil_image, \"graph.png\")\n\t        await send_room_image(matrix_client, room.room_id, upload_response)\n\t        return True\n"]}
{"filename": "plugins/debug_plugin.py", "chunked_list": ["from plugins.base_plugin import BasePlugin\n\tclass Plugin(BasePlugin):\n\t    plugin_name = \"debug\"\n\t    priority = 1\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n\t    ):\n\t        packet = self.strip_raw(packet)\n\t        self.logger.debug(f\"Packet received: {packet}\")\n\t        return False\n", "    async def handle_room_message(self, room, event, full_message):\n\t        return False\n"]}
{"filename": "plugins/help_plugin.py", "chunked_list": ["import re\n\tfrom plugins.base_plugin import BasePlugin\n\tfrom plugin_loader import load_plugins\n\tclass Plugin(BasePlugin):\n\t    plugin_name = \"help\"\n\t    @property\n\t    def description(self):\n\t        return f\"List supported relay commands\"\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n", "    ):\n\t        return False\n\t    def get_matrix_commands(self):\n\t        return [self.plugin_name]\n\t    def get_mesh_commands(self):\n\t        return []\n\t    async def handle_room_message(self, room, event, full_message):\n\t        full_message = full_message.strip()\n\t        if not self.matches(full_message):\n\t            return False\n", "        command = None\n\t        match = re.match(r\"^.*: !help\\s+(.+)$\", full_message)\n\t        if match:\n\t            command = match.group(1)\n\t        plugins = load_plugins()\n\t        if command:\n\t            reply = f\"No such command: {command}\"\n\t            for plugin in plugins:\n\t                if command in plugin.get_matrix_commands():\n\t                    reply = f\"`!{command}`: {plugin.description}\"\n", "        else:\n\t            commands = []\n\t            for plugin in plugins:\n\t                commands.extend(plugin.get_matrix_commands())\n\t            reply = \"Available commands: \" + \", \".join(commands)\n\t        response = await self.send_matrix_message(room.room_id, reply)\n\t        return True\n"]}
{"filename": "example_plugins/hello_world.py", "chunked_list": ["from plugins.base_plugin import BasePlugin\n\tclass Plugin(BasePlugin):\n\t    plugin_name = \"helloworld\"\n\t    async def handle_meshtastic_message(\n\t        self, packet, formatted_message, longname, meshnet_name\n\t    ):\n\t        self.logger.debug(\"Hello world, Meshtastic\")\n\t    async def handle_room_message(self, room, event, full_message):\n\t        self.logger.debug(\"Hello world, Matrix\")\n"]}
{"filename": "gui/config_editor.py", "chunked_list": ["import os\n\timport glob\n\timport yaml\n\timport webbrowser\n\timport tkinter as tk\n\tfrom tkinter import messagebox\n\tfrom tkinter import ttk\n\tfrom collections import OrderedDict\n\tdef create_default_config():\n\t    default_config = {\n", "        \"matrix\": {\n\t            \"homeserver\": \"\",\n\t            \"bot_user_id\": \"\",\n\t            \"access_token\": \"\"\n\t        },\n\t        \"matrix_rooms\": [],\n\t        \"logging\": {\n\t            \"level\": \"info\"\n\t        },\n\t        \"plugins\": []\n", "    }\n\t    with open(\"config.yaml\", \"w\") as f:\n\t        yaml.dump(default_config, f)\n\t    return default_config\n\tdef load_config():\n\t    try:\n\t        with open(\"config.yaml\", \"r\") as f:\n\t            return yaml.safe_load(f)\n\t    except FileNotFoundError:\n\t        return create_default_config()\n", "def validate_config():\n\t    room_ids = [frame.room_id_var.get() for frame in matrix_rooms_frames]\n\t    meshtastic_channels = [int(frame.meshtastic_channel_var.get()) for frame in matrix_rooms_frames]\n\t    if len(room_ids) != len(set(room_ids)):\n\t        messagebox.showerror(\"Error\", \"Each Matrix room must be unique. Please check the room IDs.\")\n\t        return False\n\t    if len(meshtastic_channels) != len(set(meshtastic_channels)):\n\t        messagebox.showerror(\"Error\", \"Each Meshtastic channel must be unique. Please check the channel numbers.\")\n\t        return False\n\t    return True\n", "def save_config(config):\n\t    with open(\"config.yaml\", \"w\") as f:\n\t        ordered_yaml_dump(config, f)\n\tdef update_minsize(): # Function that prevents the window from resizing too small\n\t    root.update_idletasks()\n\t    root.minsize(root.winfo_width(), root.winfo_height())\n\tclass Hyperlink(tk.Label):\n\t    def __init__(self, master=None, **kwargs):\n\t        self.default_color = kwargs.pop(\"fg\", \"blue\")\n\t        self.hover_color = kwargs.pop(\"hover_color\", \"darkblue\")\n", "        super().__init__(master, fg=self.default_color, cursor=\"hand2\", **kwargs)\n\t        self.bind(\"<Enter>\", self.on_enter)\n\t        self.bind(\"<Leave>\", self.on_leave)\n\t        self.bind(\"<Button-1>\", self.on_click)\n\t    def on_enter(self, event):\n\t        self.config(fg=self.hover_color)\n\t    def on_leave(self, event):\n\t        self.config(fg=self.default_color)\n\t    def on_click(self, event):\n\t        webbrowser.open(self.cget(\"text\"))\n", "# Functions\n\tdef ordered_yaml_dump(data, stream=None, Dumper=yaml.Dumper, **kwds):\n\t    class OrderedDumper(Dumper):\n\t        pass\n\t    def _dict_representer(dumper, data):\n\t        return dumper.represent_mapping(\n\t            yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,\n\t            data.items()\n\t        )\n\t    OrderedDumper.add_representer(OrderedDict, _dict_representer)\n", "    return yaml.dump(data, stream, OrderedDumper, **kwds)\n\tdef get_plugin_names():\n\t    plugin_files = glob.glob(\"./plugins/*_plugin.py\")\n\t    plugin_files = [p for p in plugin_files if os.path.basename(p) != \"base_plugin.py\"]\n\t    plugin_names = [os.path.basename(p)[:-10] for p in plugin_files]\n\t    return plugin_names\n\tdef create_meshtastic_frame(root):\n\t    frame = tk.LabelFrame(root, text=\"Meshtastic\", padx=5, pady=5)\n\t    frame.pack(fill=\"x\", padx=5, pady=5)\n\t    connection_types = [\"serial\", \"network\"]\n", "    connection_type_var = tk.StringVar(value=config[\"meshtastic\"][\"connection_type\"])\n\t    for i, ctype in enumerate(connection_types):\n\t        radio_button = tk.Radiobutton(frame, text=ctype, variable=connection_type_var, value=ctype)\n\t        radio_button.grid(row=0, column=i, padx=5)\n\t    serial_port_label = tk.Label(frame, text=\"Serial Port:\")\n\t    serial_port_label.grid(row=1, column=0, sticky=\"w\")\n\t    serial_port_var = tk.StringVar(value=config[\"meshtastic\"][\"serial_port\"])\n\t    serial_port_entry = tk.Entry(frame, textvariable=serial_port_var)\n\t    serial_port_entry.grid(row=1, column=1, sticky=\"ew\")\n\t    host_label = tk.Label(frame, text=\"Host:\")\n", "    host_label.grid(row=2, column=0, sticky=\"w\")\n\t    host_var = tk.StringVar(value=config[\"meshtastic\"][\"host\"])\n\t    host_entry = tk.Entry(frame, textvariable=host_var)\n\t    host_entry.grid(row=2, column=1, sticky=\"ew\")\n\t    meshnet_name_label = tk.Label(frame, text=\"Meshnet Name:\")\n\t    meshnet_name_label.grid(row=3, column=0, sticky=\"w\")\n\t    meshnet_name_var = tk.StringVar(value=config[\"meshtastic\"][\"meshnet_name\"])\n\t    meshnet_name_entry = tk.Entry(frame, textvariable=meshnet_name_var)\n\t    meshnet_name_entry.grid(row=3, column=1, sticky=\"ew\")\n\t    broadcast_enabled_label = tk.Label(frame, text=\"Broadcast Enabled:\")\n", "    broadcast_enabled_label.grid(row=4, column=0, sticky=\"w\")\n\t    broadcast_enabled_var = tk.BooleanVar(value=config[\"meshtastic\"][\"broadcast_enabled\"])\n\t    broadcast_enabled_checkbox = tk.Checkbutton(frame, variable=broadcast_enabled_var)\n\t    broadcast_enabled_checkbox.grid(row=4, column=1, sticky=\"w\")\n\t    return {\n\t        \"connection_type\": connection_type_var,\n\t        \"serial_port\": serial_port_var,\n\t        \"host\": host_var,\n\t        \"meshnet_name\": meshnet_name_var,\n\t        \"broadcast_enabled\": broadcast_enabled_var,\n", "    }\n\tdef create_logging_frame(root):\n\t    frame = tk.LabelFrame(root, text=\"Logging\", padx=5, pady=5)\n\t    frame.pack(fill=\"x\", padx=5, pady=5)\n\t    logging_options = [\"info\", \"debug\"]\n\t    logging_level_var = tk.StringVar(value=config[\"logging\"][\"level\"])\n\t    for i, level in enumerate(logging_options):\n\t        radio_button = tk.Radiobutton(frame, text=level, variable=logging_level_var, value=level)\n\t        radio_button.grid(row=0, column=i, padx=5)\n\t    return logging_level_var\n", "def create_plugins_frame(root):\n\t    frame = tk.LabelFrame(root, text=\"Plugins\", padx=5, pady=5)\n\t    frame.pack(fill=\"x\", padx=5, pady=5)\n\t    plugin_names = get_plugin_names()\n\t    plugin_vars = {}\n\t    for i, plugin in enumerate(plugin_names):\n\t        # Create a plugin-specific frame\n\t        plugin_frame = tk.LabelFrame(frame, text=plugin, padx=5, pady=5)\n\t        plugin_frame.grid(row=i, column=0, padx=5, pady=5, sticky=\"ew\")\n\t        frame.columnconfigure(0, weight=1)\n", "        active_var = tk.BooleanVar(value=config[\"plugins\"][plugin][\"active\"])\n\t        checkbox = tk.Checkbutton(plugin_frame, text=\"Active\", variable=active_var)\n\t        checkbox.grid(row=0, column=0)\n\t        plugin_vars[plugin] = {\"active\": active_var}\n\t        nested_keys = [k for k in config[\"plugins\"][plugin] if k != \"active\"]\n\t        for j, nested_key in enumerate(nested_keys):\n\t            label = tk.Label(plugin_frame, text=nested_key)\n\t            label.grid(row=0, column=2 * j + 1, padx=(10, 0))\n\t            nested_var_value = config[\"plugins\"][plugin][nested_key]\n\t            if isinstance(nested_var_value, bool):\n", "                nested_var = tk.BooleanVar(value=nested_var_value)\n\t                entry = tk.Checkbutton(plugin_frame, variable=nested_var)\n\t            else:\n\t                nested_var = tk.StringVar(value=nested_var_value)\n\t                entry = tk.Entry(plugin_frame, textvariable=nested_var, width=len(nested_var_value) + 1)  # Change the width here\n\t                entry.bind('<KeyRelease>', lambda event: update_entry_width(event, entry))\n\t            entry.grid(row=0, column=2 * j + 2)\n\t            plugin_vars[plugin][nested_key] = nested_var\n\t    return plugin_vars\n\t# Add the update_entry_width function\n", "def update_entry_width(event, entry):\n\t    if isinstance(entry, tk.Entry):\n\t        entry.config(width=len(entry.get()) + 1)\n\tdef apply_changes():\n\t    # Check if config is valid\n\t    if not validate_config():\n\t        return\n\t    # Update matrix config\n\t    for key, var in matrix_vars.items():\n\t        config[\"matrix\"][key] = var.get()\n", "    new_config = OrderedDict()\n\t    new_config[\"matrix\"] = config[\"matrix\"]\n\t    new_config[\"meshtastic\"] = config[\"meshtastic\"]\n\t    # Update matrix_rooms config\n\t    config[\"matrix_rooms\"] = []\n\t    for room_frame in matrix_rooms_frames:\n\t        room_id = room_frame.room_id_var.get()\n\t        meshtastic_channel = room_frame.meshtastic_channel_var.get()\n\t        config[\"matrix_rooms\"].append({\"id\": room_id, \"meshtastic_channel\": int(meshtastic_channel)})\n\t    # Sort matrix_rooms by meshtastic_channel and add to new_config\n", "    new_config[\"matrix_rooms\"] = sorted(config[\"matrix_rooms\"], key=lambda x: x[\"meshtastic_channel\"])\n\t    new_config[\"logging\"] = config[\"logging\"]\n\t    new_config[\"plugins\"] = config[\"plugins\"]\n\t    # Update logging config\n\t    config[\"logging\"][\"level\"] = logging_level_var.get()\n\t    # Update plugins config\n\t    for plugin, vars in plugin_vars.items():\n\t        plugin_config = {}\n\t        for k, v in vars.items():\n\t            plugin_config[k] = v.get()\n", "        config[\"plugins\"][plugin] = plugin_config\n\t    # Update meshtastic config\n\t    for key, var in meshtastic_vars.items():\n\t        if key == \"broadcast_enabled\":\n\t            config[\"meshtastic\"][key] = var.get()\n\t        else:\n\t            config[\"meshtastic\"][key] = var.get()\n\t    save_config(new_config)\n\t    root.destroy()\n\tdef add_matrix_room(room=None, meshtastic_channel=None):\n", "    if len(matrix_rooms_frames) >= 8:\n\t        messagebox.showerror(\"Error\", \"There is a maximum of 8 Meshtastic channels.\")\n\t        return\n\t    room_frame = tk.Frame(matrix_rooms_frame)\n\t    room_frame.grid(row=len(matrix_rooms_frames), column=0, padx=5, pady=5, sticky=\"ew\")\n\t    room_frame.room_id_var = tk.StringVar(value=room or \"\")\n\t    room_frame.meshtastic_channel_var = tk.StringVar(value=str(meshtastic_channel) if meshtastic_channel is not None else \"\")\n\t    room_id_label = tk.Label(room_frame, text=\"ID:\")\n\t    room_id_label.grid(row=0, column=0)\n\t    room_id_entry = tk.Entry(room_frame, textvariable=room_frame.room_id_var, width=40)\n", "    room_id_entry.grid(row=0, column=1, padx=(0, 10))\n\t    meshtastic_channel_label = tk.Label(room_frame, text=\"Meshtastic Channel:\")\n\t    meshtastic_channel_label.grid(row=0, column=2)\n\t    meshtastic_channel_entry = tk.Entry(room_frame, textvariable=room_frame.meshtastic_channel_var, width=5)\n\t    meshtastic_channel_entry.grid(row=0, column=3)\n\t    matrix_rooms_frames.append(room_frame)\n\t    update_minsize()  \n\tdef remove_matrix_room():\n\t    if len(matrix_rooms_frames) <= 1:\n\t        messagebox.showerror(\"Error\", \"There must be at least one room & channel.\")\n", "        return\n\t    if matrix_rooms_frames:\n\t        frame_to_remove = matrix_rooms_frames.pop()\n\t        frame_to_remove.destroy()\n\t        update_minsize()\n\t# GUI\n\tconfig = load_config()\n\troot = tk.Tk()\n\troot.title(\"M<>M Relay - Configuration Editor\")\n\t# Create the main tab control\n", "tab_control = ttk.Notebook(root)\n\ttab_control.pack(expand=True, fill=\"both\")\n\t# Create the Settings tab\n\tsettings_tab = ttk.Frame(tab_control)\n\ttab_control.add(settings_tab, text=\"Settings\")\n\t# Create the Plugins tab\n\tplugins_tab = ttk.Frame(tab_control)\n\ttab_control.add(plugins_tab, text=\"Plugins\")\n\t# Matrix frame\n\tmatrix_frame = tk.LabelFrame(settings_tab, text=\"Matrix\", padx=5, pady=5)\n", "matrix_frame.pack(padx=10, pady=10, fill=\"x\", expand=\"yes\")\n\tmatrix_keys = [\"homeserver\", \"bot_user_id\", \"access_token\"]\n\tmatrix_vars = {}\n\tfor i, key in enumerate(matrix_keys):\n\t    label = tk.Label(matrix_frame, text=key)\n\t    label.grid(row=i, column=0, sticky=\"w\")\n\t    var = tk.StringVar(value=config[\"matrix\"][key])\n\t    entry = tk.Entry(matrix_frame, textvariable=var, width=49)\n\t    entry.grid(row=i, column=1, sticky=\"ew\")\n\t    matrix_vars[key] = var\n", "# Add instruction label\n\tinstruction_label = tk.Label(matrix_frame, text=\"For instructions on where to find your access token, visit:\")\n\tinstruction_label.grid(row=3, column=0, columnspan=2, sticky=\"ew\")\n\t# Add hyperlink label\n\tlink_label = Hyperlink(matrix_frame, text=\"https://t2bot.io/docs/access_tokens/\")\n\tlink_label.grid(row=4, column=0, columnspan=2, sticky=\"ew\")\n\t# Create meshtastic frame\n\tmeshtastic_vars = create_meshtastic_frame(settings_tab)\n\t# Matrix rooms frame\n\tmatrix_rooms_frame = tk.LabelFrame(settings_tab, text=\"Matrix Rooms\", padx=5, pady=5)\n", "matrix_rooms_frame.pack(padx=10, pady=10, fill=\"both\", expand=\"yes\")\n\tmatrix_rooms_frames = []\n\tfor room in config[\"matrix_rooms\"]:\n\t    add_matrix_room(room[\"id\"], room[\"meshtastic_channel\"])\n\tadd_remove_frame = tk.Frame(matrix_rooms_frame)\n\tadd_remove_frame.grid(row=1000, column=0, padx=5, pady=5, sticky=\"ew\")\n\tadd_button = tk.Button(add_remove_frame, text=\"+\", command=add_matrix_room)\n\tadd_button.pack(side=\"left\")\n\tremove_button = tk.Button(add_remove_frame, text=\"-\", command=remove_matrix_room)\n\tremove_button.pack(side=\"left\")\n", "# Create logging frame\n\tlogging_level_var = create_logging_frame(settings_tab)\n\t# Create plugins frame\n\tplugin_vars = create_plugins_frame(plugins_tab)\n\t# Apply button\n\tapply_button = tk.Button(root, text=\"Save & Launch Relay\", command=apply_changes)\n\tapply_button.pack(side=\"bottom\", pady=10)\n\troot.mainloop()\n"]}
