{"filename": "setup.py", "chunked_list": ["import os\n\tfrom setuptools import setup, find_packages\n\tdef get_install_requirements():\n\t    requirements = []\n\t    requirements_file = os.path.join(\n\t        os.path.dirname(os.path.realpath(__file__)), \"requirements.txt\"\n\t    )\n\t    with open(requirements_file) as f_req:\n\t        for line in f_req:\n\t            line = line.strip()\n", "            if not line.startswith(\"#\") and len(line) > 0:\n\t                requirements.append(line)\n\t    return requirements\n\tsetup(\n\t    name=\"zeronlg\",\n\t    version=\"1.0.0\",\n\t    author=\"Bang Yang\",\n\t    author_email=\"yangbang@pku.edu.cn\",\n\t    description=\"Zero-Shot Multimodal and Multilingual Natural Language Generation\",\n\t    license=\"Apache License 2.0\",\n", "    packages=find_packages(),\n\t    python_requires=\">=3.6.0\",\n\t    install_requires=get_install_requirements(),\n\t    classifiers=[\n\t        \"Development Status :: 5 - Production/Stable\",\n\t        \"Intended Audience :: Science/Research\",\n\t        \"License :: OSI Approved :: Apache Software License\",\n\t        \"Programming Language :: Python :: 3.6\",\n\t        \"Topic :: Scientific/Engineering :: Artificial Intelligence\"\n\t    ],\n", ")\n"]}
{"filename": "configs.py", "chunked_list": ["# root paths to load raw images or videos\n\timage_video_root = {\n\t    'coco': 'data/MSCOCO',\n\t    'flickr30k': 'data/Flickr30k',\n\t    'msrvtt': 'data/MSRVTT',\n\t    'vatex': 'data/VATEX',\n\t}\n\tnum_frames = 8 # the number of frames to be uniformly sampled for each video\n\tannotation_root = 'data/annotations'\n\tcorpus_root = 'data/corpus'\n", "# generation settings for visual captioning in different languages\n\tauto_settings = {\n\t    'en': dict(\n\t        max_length=20,\n\t        min_length=3,\n\t        repetition_penalty=1.0,\n\t    ),\n\t    'zh': dict(\n\t        max_length=30,\n\t        min_length=3,\n", "        repetition_penalty=1.0,\n\t    ),\n\t    'de': dict(\n\t        max_length=15,\n\t        min_length=3,\n\t        repetition_penalty=2.0,\n\t    ),\n\t    'fr': dict(\n\t        max_length=20,\n\t        min_length=3,\n", "        repetition_penalty=2.0,\n\t    ),\n\t}\n"]}
{"filename": "infer_translate.py", "chunked_list": ["import os\n\timport time\n\timport datetime\n\timport argparse\n\timport logging\n\timport configs\n\tfrom torch.utils.data import DataLoader\n\tfrom sentence_transformers import LoggingHandler\n\tfrom zeronlg import ZeroNLG, TranslateDataset, TranslateEvaluator\n\tlogging.basicConfig(format='%(asctime)s - %(message)s',\n", "                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tlogger = logging.getLogger(__name__)\n\ttry:\n\t    ROOT = configs.annotation_translate_root\n\texcept:\n\t    ROOT = configs.annotation_root\n\tif __name__ == '__main__':\n\t    parser = argparse.ArgumentParser()\n", "    parser.add_argument('--model', type=str, required=True)\n\t    parser.add_argument('--dataset', type=str, default='flickr30k')\n\t    # Data paths and attributes\n\t    parser.add_argument('--data_root', type=str, help='If not specified, default to {ROOT}/{dataset}')\n\t    parser.add_argument('--folder_format', type=str, default='{source}-{target}')\n\t    parser.add_argument('--image_list_format', type=str, default='{mode}_images.txt',\n\t        help='To run multimodal machine translation, you should specify a file that stores relative path of images'\n\t    )\n\t    # Dataloader settings\n\t    parser.add_argument('--batch_size', type=int, default=64)\n", "    # Evaluation settings\n\t    parser.add_argument('--source', type=str, default='en', help='source language')\n\t    parser.add_argument('--target', type=str, default='zh', help='target language')\n\t    parser.add_argument('--unidirectional', action='store_true', help='if specified, only evaluating source -> target')\n\t    parser.add_argument('--no_score', action='store_true', help='do not calculate scores')\n\t    parser.add_argument('--modes', type=str, nargs='+', default=['test'], help='evaluation modes: [\"val\"], [\"test\"], [\"val\", \"test\"]')\n\t    parser.add_argument('--num_beams', type=int, default=3)\n\t    parser.add_argument('--max_length', type=int, default=128)\n\t    parser.add_argument('--min_length', type=int, default=5)\n\t    parser.add_argument('--repetition_penalty', type=float, default=1.0)\n", "    # Output settings\n\t    parser.add_argument('--output_path', type=str, help='If not specified, output_path will be ${model}/evaluations_translate/${source}-${target}')\n\t    parser.add_argument('--no_suffix_folder', action='store_true', help='If True, the suffix `evaluations_translate/${source}-${target}` will not be joined to the output path')\n\t    parser.add_argument('--print_sent', action='store_true')\n\t    args = parser.parse_args()\n\t    data_root = args.data_root or os.path.join(ROOT, args.dataset)\n\t    read_path1 = os.path.join(data_root, args.folder_format.format(source=args.source, target=args.target))\n\t    read_path2 = os.path.join(data_root, args.folder_format.format(source=args.target, target=args.source))\n\t    assert os.path.exists(read_path1) or os.path.exists(read_path2), f'{read_path1} or {read_path2} do not exist!'\n\t    read_path = read_path1 if os.path.exists(read_path1) else read_path2\n", "    if not os.path.exists(args.model):\n\t        assert args.output_path, \"you are training to load a model from hugginface hub, please specify --output_path\"\n\t    output_path = args.output_path or args.model\n\t    if not args.no_suffix_folder: \n\t        output_path = os.path.join(output_path, 'evaluations_translate', f'{args.source}-{args.target}')\n\t    os.makedirs(output_path, exist_ok=True)\n\t    logger.addHandler(logging.FileHandler(os.path.join(output_path, 'log.txt'), 'w', encoding='utf-8'))\n\t    logger.info(f'output path: {output_path}')\n\t    assert args.modes in [['val'], ['test'], ['val', 'test']]\n\t    logger.info(f'Creating model from {args.model}')\n", "    model = ZeroNLG(args.model)\n\t    # prepare evaluation settings\n\t    evaluation_settings = {\n\t        k: getattr(args, k) \n\t        for k in ['num_beams', 'max_length', 'min_length', 'repetition_penalty']\n\t    }\n\t    logger.info(f'Evaluation settings: {evaluation_settings}')\n\t    # start evaluation\n\t    start_time = time.time()\n\t    for mode in args.modes:\n", "        if args.unidirectional:\n\t            sources = [args.source]\n\t            targets = [args.target]\n\t        else:\n\t            sources = [args.source, args.target]\n\t            targets = [args.target, args.source]\n\t        for source, target in zip(sources, targets):\n\t            source_path = os.path.join(read_path, f'{mode}.{source}')\n\t            target_path = os.path.join(read_path, f'{mode}.{target}')\n\t            dataset = TranslateDataset(\n", "                source_language=source,\n\t                target_language=target,\n\t                source_path=source_path,\n\t                target_path=target_path,\n\t                logger=logger\n\t            )\n\t            loader = DataLoader(dataset, batch_size=args.batch_size, shuffle=False)\n\t            evaluator = TranslateEvaluator(\n\t                loader=loader,\n\t                evaluation_settings=evaluation_settings,\n", "                mode=mode, \n\t                logger=logger\n\t            )\n\t            evaluator(model, output_path=output_path, no_score=args.no_score, print_sent=args.print_sent)\n\t    total_time = time.time() - start_time\n\t    total_time_str = str(datetime.timedelta(seconds=int(total_time)))\n\t    print('Time {}'.format(total_time_str))\n\t'''\n\tpython infer_translate.py --model zeronlg-4langs-mt --output_path output/zeronlg-4langs-mt --dataset flickr30k --source zh --target de\n\t'''\n"]}
{"filename": "train.py", "chunked_list": ["import os\n\timport logging\n\timport torch.nn as nn\n\timport argparse\n\tfrom torch.utils.data import DataLoader\n\tfrom sentence_transformers import LoggingHandler\n\tfrom sentence_transformers.models import Pooling\n\tfrom zeronlg import Framework\n\tfrom zeronlg.losses import LossManager\n\tfrom zeronlg.datasets import PretrainDataset\n", "from zeronlg.models import Dense, Projector, Decoder, Transformer\n\tlogging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tlogger = logging.getLogger(__name__)\n\tif __name__ == '__main__':\n\t    parser = argparse.ArgumentParser()\n\t    # Model settings\n\t    parser.add_argument('--teacher_model_name', type=str, default='clip-ViT-B-32', \n", "                        choices=['clip-ViT-B-32', 'clip-ViT-B-16', 'clip-ViT-L-14'], \n\t                        help='Monolingual teacher model')\n\t    parser.add_argument('--student_model_name', type=str, default='distilbert-base-multilingual-cased',  \n\t                        help='Multilingual student model we use to imitate the teacher model\\' outputs')\n\t    parser.add_argument('--decoder_name', type=str, default='bert-base-multilingual-cased', \n\t                        help='Multilingual student model for NLG')\n\t    # Student's encoder settings\n\t    parser.add_argument('--max_seq_length', type=int, default=128, \n\t                        help='Student model max. lengths for inputs (number of word pieces)')\n\t    # Student's decoder settings\n", "    parser.add_argument('--num_hidden_layers', type=int, default=3)\n\t    parser.add_argument('--use_pretrained_decoder', action='store_true', \n\t                        help='Whether to load pre-trianed weights of the decoder; \\\n\t                              Note that we will add randomly initialized cross-attention layers to the decdoder, \\\n\t                              even if you specify `use_pretrained_decoder` to True')\n\t    parser.add_argument('--decoder_max_seq_length', type=int, default=128, \n\t                        help='Student model max. lengths for decoder inputs (number of word pieces)')\n\t    # Data settings\n\t    parser.add_argument('--train_corpus_format', type=str, default=\"data/corpus/multilingual_cc3m/4langs/cc3m_{}-{}.tsv\")\n\t    parser.add_argument('--source_language', type=str, default='en', choices=['en'], \n", "                        help='Our teacher model accepts English (en) sentences')\n\t    parser.add_argument('--target_languages', type=str, nargs='+', default=['en', 'zh', 'de', 'fr'], \n\t                        help='The languages to be learned by the student model')\n\t    parser.add_argument('--max_sentences', type=int, help='maximun number of sentences per file')\n\t    parser.add_argument('--weights', type=int, nargs='+', help='If more than one dataset is loaded with load_data: With which frequency should data be sampled from this dataset?')\n\t    parser.add_argument('--numpy_path', type=str, help='Path to a numpy file that stores sentence embeddings')\n\t    parser.add_argument('--num_workers', type=int, default=4, help='# workers to load data; only activated when `numpy_path` is specified')\n\t    # Training settings\n\t    parser.add_argument('--use_amp', action='store_true', help='Whether use automatic mixed precision (amp) to speed up training')\n\t    parser.add_argument('--seed', type=int, default=42)\n", "    parser.add_argument('--batch_size', type=int, default=32, help='Batch size for training')\n\t    parser.add_argument('--inference_batch_size', type=int, help='Batch size at inference; if not speficied, set to batch_size')\n\t    parser.add_argument('--epochs', type=int, default=3, help='Train for x epochs')\n\t    parser.add_argument('--warmup_steps', type=int, default=5000, help='Warumup steps')\n\t    parser.add_argument('--lr', type=float, default=2e-5, help='Learning rate')\n\t    parser.add_argument('--eps', type=float, default=1e-6)\n\t    parser.add_argument('--weight_decay', type=float, default=0.01)\n\t    parser.add_argument('--scheduler', type=str, default='warmupconstant', \n\t                        choices=['constantlr', 'warmupconstant', 'warmuplinear', 'warmupcosine', 'warmupcosinewithhardrestarts'])\n\t    # Output settings\n", "    parser.add_argument('--output_path', type=str, help='The exact output path to save training info and checkpoints')\n\t    parser.add_argument('--output_root', type=str, default='output/2stages')\n\t    parser.add_argument('--exp_name', type=str, default='debug', help='Experiment name; If `output_path` is not specified, the output path will be {output_root}/{exp_name}')\n\t    parser.add_argument('--log_every', type=int, default=500)\n\t    # Method-related settings\n\t    parser.add_argument('--scales', type=float, nargs='+', default=[1.0, 0.0, 0.0, 0.0], \n\t                        help='Scales of loss_mse, loss_at_teacher, loss_at_student, loss_contrastive')\n\t    parser.add_argument('--use_masking', action='store_true',\n\t                        help='Wheter to apply input corruption, i.e., randomly mask encoder\\'s input tokens')\n\t    parser.add_argument('--mask_prob', type=float, default=0.15,\n", "                        help='Probability to mask tokens')\n\t    parser.add_argument('--noise_std', type=float, default=0,\n\t                        help='Standard deviation of gaussian noise; 0 means not applying feature corruption')\n\t    parser.add_argument('--noise_prob', type=float, default=0, \n\t                        help='Probability to add gaussian noise; only activated when it is larger than 0')\n\t    parser.add_argument('--student_emb_keyname', type=str, default='sentence_embedding', \n\t                        choices=['sentence_embedding', 'token_embeddings'],\n\t                        help='If set to `sentence_embedding`, decoder will generate texts solely based on a global vector; \\\n\t                              Otherwise, decoder will base text generation on a sequence of token features. \\\n\t                              We find that set this arg to `token_embeddings` benefit machine translation a lot')\n", "    # Model settings\n\t    parser.add_argument('--no_frozen', action='store_true')\n\t    parser.add_argument('--freeze_transformer', action='store_true')\n\t    args = parser.parse_args()\n\t    if not args.inference_batch_size:\n\t        args.inference_batch_size = args.batch_size\n\t    assert len(args.scales) == 4\n\t    output_path = args.output_path or os.path.join(args.output_root, args.exp_name)\n\t    os.makedirs(output_path, exist_ok=True)\n\t    # saving training logs to {output_path}/log.txt\n", "    logger.addHandler(logging.FileHandler(os.path.join(output_path, 'log.txt'), 'w', encoding='utf-8'))\n\t    # log necessary information\n\t    logger.info(f\"Output path: {output_path}\")\n\t    logger.info(f\"Target languages: {args.target_languages}\")\n\t    logger.info(f'Loss scales: {args.scales}')\n\t    logger.info(f'Noise std: {args.noise_std} {f\"(noise prob: {args.noise_prob})\" if args.noise_prob > 0 else \"\"}')\n\t    if args.use_amp:\n\t        logger.info('Use amp for speeding up training')\n\t    if args.use_masking:\n\t        logger.info(f'Random masking: {args.use_masking} (prob: {args.mask_prob})')\n", "    ######## Teacher model ########\n\t    logger.info(f\"Load teacher model: {args.teacher_model_name}\")\n\t    teacher_model = Framework(args.teacher_model_name)\n\t    logger.info(f'Teacher model architecture: \\n {teacher_model}')\n\t    # freeze teacher model\n\t    for p in teacher_model.parameters():\n\t        p.requires_grad = False\n\t    dim_teacher = teacher_model._last_module().get_sentence_embedding_dimension()\n\t    ######## Student model ########\n\t    logger.info(f\"Create student model from {args.student_model_name}\")\n", "    if args.student_model_name in ['distilbert-base-multilingual-cased']:\n\t        # a transformer model for encoding\n\t        encoder = Transformer(\n\t            args.student_model_name, \n\t            max_seq_length=args.max_seq_length,\n\t        )\n\t        dim_enc = encoder.get_word_embedding_dimension()\n\t        pooling_model = Pooling(dim_enc)\n\t        dense_model = Dense(dim_enc, dim_teacher, bias=False, activation_function=nn.modules.linear.Identity())\n\t        modules = [encoder, pooling_model, dense_model]\n", "    else:\n\t        student_model = Framework(args.student_model_name, load_sbert_only=True)\n\t        modules = student_model.get_modules()\n\t    attend_to = []\n\t    if args.scales[1]:\n\t        attend_to.append('teacher')\n\t    if args.scales[2]:\n\t        attend_to.append('student')\n\t    if isinstance(modules[-1], Dense):\n\t        # only encoding modules included now\n", "        dim_student = modules[-1].get_sentence_embedding_dimension()\n\t        assert dim_teacher == dim_student\n\t        assert isinstance(modules[-1], Dense)\n\t        # check if we need to add decoding modules\n\t        if args.scales[1] or args.scales[2]:\n\t            if 'bert' not in args.decoder_name.lower():\n\t                raise NotImplementedError('You should take care of `num_hidden_layers`')\n\t            decoder = Decoder(\n\t                model_name_or_path=args.decoder_name,\n\t                model_args={\n", "                    'is_decoder': True, \n\t                    'add_cross_attention': True,\n\t                    'num_hidden_layers': args.num_hidden_layers},\n\t                from_pretrained=args.use_pretrained_decoder,\n\t                attend_to=attend_to,\n\t                teacher_model_name=args.teacher_model_name,\n\t                max_seq_length=args.decoder_max_seq_length,\n\t            )\n\t            dim_dec = decoder.get_word_embedding_dimension()\n\t            projector = Projector(dim_teacher, dim_dec, noise_std=args.noise_std, noise_prob=args.noise_prob, student_emb_keyname=args.student_emb_keyname)\n", "            modules.extend([projector, decoder])\n\t    else:\n\t        # both encoding and decoding modules included\n\t        assert student_model.get_module_attribute('teacher_model_name') == args.teacher_model_name\n\t        student_model.set_module_attribute(Projector, 'noise_std', args.noise_std)\n\t        # check if we need to keep decoding modules\n\t        if args.scales[1] or args.scales[2]:\n\t            student_model.set_module_attribute(Decoder, 'attend_to', attend_to)\n\t        else:\n\t            logger.info('Training does not need the decoder, ignore it')\n", "            modules = student_model.get_encoding_modules()\n\t    if args.scales[0] == 0 and not args.no_frozen:\n\t        logger.info('Freeze the multimodal encoder of the student model')\n\t        for idx, module in enumerate(modules):\n\t            if isinstance(module, Projector):\n\t                break\n\t        for module in modules[:idx]:\n\t            for p in module.parameters():\n\t                p.requires_grad = False\n\t    elif args.scales[0] == 0 and args.freeze_transformer:\n", "        logger.info('Freeze the transformer of the multimodal encoder of the student model')\n\t        module = modules[0]\n\t        assert isinstance(module, Transformer)\n\t        for p in module.parameters():\n\t            p.requires_grad = False\n\t    student_model = Framework(modules=modules, logger=logger)\n\t    student_model.set_module_attribute(Dense, 'proj_token_embs', args.student_emb_keyname == 'token_embeddings')\n\t    if args.scales[0] == 0 and args.scales[1] == 0 and args.scales[3] == 0:\n\t        logger.info('Training does not need the teacher model, set it to None')\n\t        teacher_model = None\n", "    if args.scales[0] == 0 and args.scales[2] == 0 and args.scales[3] == 0:\n\t        logger.info('Training does not need the multimodal encoder, ignore it')\n\t        student_model = Framework(modules=student_model.get_decoding_modules(), logger=logger)\n\t    logger.info(f'Student model architecture: \\n {student_model}')\n\t    logger.info(f\"Total Params: {sum(p.numel() for p in student_model.parameters())}\")\n\t    logger.info(f\"Trainable Params: {sum(p.numel() for p in student_model.parameters() if p.requires_grad)}\")\n\t    ###### Read Parallel Sentences Dataset ######\n\t    train_data = PretrainDataset( \n\t        teacher_model=teacher_model, \n\t        batch_size=args.inference_batch_size, \n", "        use_embedding_cache=True,\n\t        logger=logger,\n\t        numpy_path=args.numpy_path,\n\t    )\n\t    if not args.weights:\n\t        args.weights = [100] * len(args.target_languages)\n\t    else:\n\t        assert isinstance(args.weights, list)\n\t        if len(args.weights) == 1:\n\t            args.weights = args.weights * len(args.target_languages)\n", "        else:\n\t            assert len(args.weights) == len(args.target_languages)\n\t    for lang, weight in zip(args.target_languages, args.weights):\n\t        train_corpus = args.train_corpus_format.format(args.source_language, lang)\n\t        if lang == args.source_language:\n\t            langs=[lang]\n\t            train_corpus = train_corpus.replace(f'-{args.source_language}.', '.')\n\t            train_data.load_data(train_corpus, max_sentences=args.max_sentences, max_sentence_length=None, exclude_source=False, langs=langs, weight=weight)\n\t        else:\n\t            langs = [args.source_language, lang]\n", "            # we set exclude_source to True, because we do not want too many samples in the source language for training\n\t            train_data.load_data(train_corpus, max_sentences=args.max_sentences, max_sentence_length=None, exclude_source=True, langs=langs, weight=weight)\n\t    train_dataloader = DataLoader(train_data, shuffle=True, batch_size=args.batch_size, num_workers=args.num_workers if args.numpy_path else 0)\n\t    ###### Define the training objective ######\n\t    train_loss = LossManager(student_model, *args.scales)\n\t    ###### Start training ######\n\t    student_model.fit(train_objectives=[(train_dataloader, train_loss)],\n\t        epochs=args.epochs,\n\t        warmup_steps=args.warmup_steps,\n\t        optimizer_params= {'lr': args.lr, 'eps': args.eps},\n", "        weight_decay=args.weight_decay,\n\t        output_path=output_path,\n\t        checkpoint_path=output_path,\n\t        checkpoint_save_steps=None, # save checkpoints every epoch, rather than spcific number of steps\n\t        log_every=args.log_every,\n\t        use_amp=args.use_amp,\n\t        scheduler=args.scheduler,\n\t        seed=args.seed,\n\t        use_masking=args.use_masking,\n\t        mask_prob=args.mask_prob,\n", "    )\n"]}
{"filename": "infer_retrieval.py", "chunked_list": ["import os\n\timport time\n\timport datetime\n\timport argparse\n\timport logging\n\timport configs\n\tfrom torch.utils.data import DataLoader\n\tfrom sentence_transformers import LoggingHandler\n\tfrom zeronlg import ZeroNLG, CaptionDatasetForRetrieval, RetrievalEvaluator\n\tfrom zeronlg.utils import get_formatted_string\n", "logging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tlogger = logging.getLogger(__name__)\n\ttry:\n\t    ROOT = configs.annotation_retrieval_root\n\texcept:\n\t    ROOT = configs.annotation_root\n\tif __name__ == '__main__':\n", "    parser = argparse.ArgumentParser()\n\t    parser.add_argument('--model', type=str, required=True)\n\t    parser.add_argument('--clip_model_name', type=str)\n\t    # Data paths and attributes\n\t    parser.add_argument('--data_root', type=str, default=ROOT)\n\t    parser.add_argument('--dataset', type=str, default='coco')\n\t    parser.add_argument('--val_file', type=str, help='If not specified, use val_file_format')\n\t    parser.add_argument('--test_file', type=str, help='If not specified, use test_file_format')\n\t    parser.add_argument('--pickle_path', type=str, help='If not specified, use pickle_path_format')\n\t    parser.add_argument('--val_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/val.json'))\n", "    parser.add_argument('--test_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/test.json'))\n\t    parser.add_argument('--pickle_path_format', type=str, default=os.path.join(ROOT, '{dataset}/{clip_model_name}_{mode}.pkl'))\n\t    # Dataloader settings\n\t    parser.add_argument('--batch_size', type=int, default=64)\n\t    # Evaluation settings\n\t    parser.add_argument('--modes', type=str, nargs='+', default=['test'], help='evaluation modes: [\"val\"], [\"test\"], [\"val\", \"test\"]')\n\t    parser.add_argument('--lang', type=str, default='en', help='which language to be generated?')\n\t    parser.add_argument('--num_frames', type=int, default=configs.num_frames)\n\t    parser.add_argument('--mean_pooling', action='store_true')\n\t    # Output settings\n", "    parser.add_argument('--output_path', type=str, help='If not specified, output_path will be {model}/evaluations_retrieval/{dataset}/{lang}')\n\t    parser.add_argument('--no_suffix_folder', action='store_true', help='If True, the suffix `evaluations_retrieval/{dataset}/{lang}` will not be joined to the output path')\n\t    args = parser.parse_args()\n\t    if not os.path.exists(args.model):\n\t        assert args.output_path, \"you are training to load a model from hugginface hub, please specify --output_path\"\n\t    output_path = args.output_path or args.model\n\t    if not args.no_suffix_folder: \n\t        output_path = os.path.join(output_path, 'evaluations_retrieval', args.dataset, args.lang)\n\t    os.makedirs(output_path, exist_ok=True)\n\t    logger.addHandler(logging.FileHandler(os.path.join(output_path, 'log.txt'), 'w', encoding='utf-8'))\n", "    logger.info(f'output path: {output_path}')\n\t    assert args.modes in [['val'], ['test'], ['val', 'test']]\n\t    logger.info(f'Creating model from {args.model}')\n\t    model = ZeroNLG(args.model, args.clip_model_name)\n\t    # start evaluation\n\t    start_time = time.time()\n\t    for mode in args.modes:\n\t        ann_rpath = get_formatted_string(vars(args), f\"{mode}_file\", assigned_keys=['dataset', 'lang'])\n\t        logger.info(f'Load dataset from {ann_rpath}')\n\t        pickle_path = get_formatted_string(vars(args), 'pickle_path', assigned_kwargs=dict(\n", "            dataset=args.dataset, clip_model_name=model.clip_model_name, mode=mode,\n\t        ))\n\t        dataset = CaptionDatasetForRetrieval(\n\t            vision_root=configs.image_video_root[args.dataset],\n\t            ann_rpath=ann_rpath,\n\t            num_frames=args.num_frames,\n\t            lang=args.lang,\n\t            clip_model=model.clip_model,\n\t            pickle_path=pickle_path,\n\t            logger=logger,\n", "            mean_pooling=args.mean_pooling,\n\t        )\n\t        logger.info(f'There are {len(dataset)} vision inputs')\n\t        loader = DataLoader(\n\t            dataset,\n\t            batch_size=args.batch_size,\n\t            shuffle=False,\n\t            collate_fn=dataset.collate_fn,\n\t        )\n\t        evaluator = RetrievalEvaluator(\n", "            loader=loader,\n\t            mode=mode,\n\t            logger=logger,\n\t            # for MS-COCO dataset, we additionally run 1K test\n\t            # the original 5K test will be also run\n\t            n_fold=5 if args.dataset == 'coco' else 1, \n\t        )\n\t        evaluator(model, output_path=output_path)\n\t    total_time = time.time() - start_time\n\t    total_time_str = str(datetime.timedelta(seconds=int(total_time)))\n", "    print('Time {}'.format(total_time_str))\n\t'''\n\tpython infer_retrieval.py --model zeronlg-4langs-vc --output_path output/zeronlg-4langs-vc --dataset msrvtt --lang en --modes val test\n\t'''\n"]}
{"filename": "train_caption.py", "chunked_list": ["import os\n\timport argparse\n\timport logging\n\timport torch\n\timport numpy as np\n\timport configs\n\tfrom torch.utils.data import DataLoader\n\tfrom sentence_transformers import LoggingHandler\n\timport zeronlg\n\tfrom zeronlg import CaptionDataset, CaptionEvaluator\n", "from zeronlg.models import Projector, Decoder, CLIPModel\n\tfrom zeronlg.utils import get_formatted_string\n\tfrom zeronlg.losses import LossManager\n\tlogging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tlogger = logging.getLogger(__name__)\n\ttry:\n\t    ROOT = configs.annotation_caption_root\n", "except:\n\t    ROOT = configs.annotation_root\n\tclass Framework(zeronlg.Framework):\n\t    def smart_batching_collate(self, batch):\n\t        texts = [b['text'] for b in batch]\n\t        langs = [b['lang'] for b in batch]\n\t        embs = np.array([b['emb'] for b in batch])\n\t        features = {}\n\t        features.update(self.decoder_tokenize(texts, langs))\n\t        features['source_embedding'] = torch.FloatTensor(embs)\n", "        labels = None\n\t        return features, labels\n\tif __name__ == '__main__':\n\t    parser = argparse.ArgumentParser()\n\t    parser.add_argument('--model', type=str)\n\t    parser.add_argument('--teacher_model_name', type=str, default='clip-ViT-B-32', \n\t                    choices=['clip-ViT-B-32', 'clip-ViT-B-16', 'clip-ViT-L-14'], \n\t                    help='Monolingual teacher model')\n\t    parser.add_argument('--use_clip_tokens', type=int, help='Whether use token-level visual embeddings?')\n\t    parser.add_argument('--mean_pooling', action='store_true', help='average visual embeddings over the time axis')\n", "    parser.add_argument('--decoder_name', type=str, default='bert-base-multilingual-cased')\n\t    parser.add_argument('--num_hidden_layers', type=int, default=3)\n\t    parser.add_argument('--hidden_dropout_prob', type=float, default=0.1)\n\t    parser.add_argument('--use_pretrained_decoder', action='store_true')\n\t    parser.add_argument('--decoder_max_seq_length', type=int, default=128, help='Student model max. lengths for inputs (number of word pieces)')\n\t    parser.add_argument('--freeze_word_embs', action='store_true')\n\t    # Data paths and attributes\n\t    parser.add_argument('--dataset', type=str, default='coco')\n\t    parser.add_argument('--lang', type=str, default='en', help='Language')\n\t    parser.add_argument('--data_root', type=str, default=ROOT)\n", "    parser.add_argument('--train_file', type=str, help='If not specified, use train_file_format')\n\t    parser.add_argument('--val_file', type=str, help='If not specified, use val_file_format')\n\t    parser.add_argument('--val_gt_file', type=str, help='If not specified, use val_gt_file_format')\n\t    parser.add_argument('--test_file', type=str, help='If not specified, use test_file_format')\n\t    parser.add_argument('--test_gt_file', type=str, help='If not specified, use test_gt_file_format')\n\t    parser.add_argument('--pickle_path', type=str, help='If not specified, use pickle_path_format')\n\t    parser.add_argument('--subset', type=str)\n\t    parser.add_argument('--train_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/train.json'))\n\t    parser.add_argument('--val_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/val.json'))\n\t    parser.add_argument('--val_gt_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/val_gt.json'))\n", "    parser.add_argument('--test_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/test.json'))\n\t    parser.add_argument('--test_gt_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/test_gt.json'))\n\t    parser.add_argument('--pickle_path_format', type=str, default=os.path.join(ROOT, '{dataset}/{clip_model_name}_{mode}{postfix}.pkl'))\n\t    parser.add_argument('--subset_path_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/subsets/{subset}.json'))\n\t    # Training settings\n\t    parser.add_argument('--use_amp', action='store_true')\n\t    parser.add_argument('--epochs', type=int, default=10)\n\t    parser.add_argument('--batch_size', type=int, default=32)\n\t    parser.add_argument('--seed', type=int, default=42)\n\t    parser.add_argument('--warmup_steps', type=int, default=5000, help='Warumup steps')\n", "    parser.add_argument('--lr', type=float, default=2e-5, help='Learning rate')\n\t    parser.add_argument('--eps', type=float, default=1e-6)\n\t    parser.add_argument('--weight_decay', type=float, default=0.01)\n\t    parser.add_argument('--scheduler', type=str, default='warmupconstant', choices=['constantlr', 'warmupconstant', 'warmuplinear', 'warmupcosine', 'warmupcosinewithhardrestarts'])\n\t    parser.add_argument('--auto', action='store_true')\n\t    # Evaluation settings\n\t    parser.add_argument('--num_beams', type=int, default=3)\n\t    parser.add_argument('--max_length', type=int, default=30)\n\t    parser.add_argument('--min_length', type=int, default=5)\n\t    parser.add_argument('--repetition_penalty', type=float, default=1.0)\n", "    # Output settings\n\t    parser.add_argument('--output_path', type=str, required=True)\n\t    parser.add_argument('--log_every', type=int, default=200)\n\t    args = parser.parse_args()\n\t    os.makedirs(args.output_path, exist_ok=True)\n\t    logger.addHandler(logging.FileHandler(os.path.join(args.output_path, 'log.txt'), 'w', encoding='utf-8'))\n\t    if args.subset:\n\t        args.train_file_format = args.subset_path_format\n\t    ##############################################################################\n\t    logger.info('Creating models')\n", "    if args.model:\n\t        logger.info(f'Load the student model from {args.model}')\n\t        student_model = Framework(args.model)\n\t        student_model.set_module_attribute(Projector, 'noise_std', 0.0)\n\t        student_model.set_module_attribute(Decoder, 'attend_to', ['teacher'])\n\t        use_clip_tokens = bool(args.use_clip_tokens or student_model.get_module_attribute('use_clip_tokens', False))\n\t        student_model.set_module_attribute(Decoder, 'use_clip_tokens', use_clip_tokens)\n\t        student_model = Framework(\n\t            modules=student_model.get_decoding_modules(), \n\t            freeze_word_embeddings=args.freeze_word_embs,\n", "            logger=logger\n\t        )\n\t        teacher_model_name = student_model.get_module_attribute('teacher_model_name')\n\t        logger.info(f'Load the teacher model from {teacher_model_name}')\n\t        teacher_model = Framework(teacher_model_name)\n\t        teacher_model.set_module_attribute(CLIPModel, 'use_clip_tokens', use_clip_tokens)\n\t    else:\n\t        teacher_model_name = args.teacher_model_name\n\t        logger.info(f'Load the teacher model from {teacher_model_name}')\n\t        teacher_model = Framework(teacher_model_name)\n", "        teacher_model.set_module_attribute(CLIPModel, 'use_clip_tokens', args.use_clip_tokens)\n\t        logger.info(f'Create the randomly initialized student model')\n\t        decoder = Decoder(\n\t            model_name_or_path=args.decoder_name,\n\t            model_args={\n\t                'is_decoder': True, \n\t                'add_cross_attention': True,\n\t                'num_hidden_layers': args.num_hidden_layers,\n\t                'hidden_dropout_prob': args.hidden_dropout_prob},\n\t            from_pretrained=args.use_pretrained_decoder,\n", "            attend_to=['teacher'],\n\t            teacher_model_name=teacher_model_name,\n\t            use_clip_tokens=args.use_clip_tokens,\n\t            max_seq_length=args.decoder_max_seq_length,\n\t        )\n\t        dim_tea = teacher_model._last_module().get_sentence_embedding_dimension()\n\t        dim_dec = decoder.get_word_embedding_dimension()\n\t        projector = Projector(dim_tea, dim_dec)\n\t        student_model = Framework(modules=[projector, decoder], logger=logger)\n\t    logger.info(f'Student model architecture: \\n {student_model}')\n", "    logger.info(f\"Total Params: {sum(p.numel() for p in student_model.parameters())}\")\n\t    logger.info(f\"Trainable Params: {sum(p.numel() for p in student_model.parameters() if p.requires_grad)}\")\n\t    teacher_model.eval()\n\t    for p in teacher_model.parameters():\n\t        p.requires_grad = False\n\t    ##############################################################################\n\t    logger.info('Creating dataloaders')\n\t    loaders = []\n\t    for mode in ['train', 'val', 'test']:\n\t        ann_rpath = get_formatted_string(vars(args), f\"{mode}_file\", assigned_keys=['dataset', 'lang', 'subset'])\n", "        pickle_path = get_formatted_string(vars(args), 'pickle_path', assigned_kwargs=dict(\n\t            dataset=args.dataset, clip_model_name=teacher_model_name, mode=mode, postfix='_tokens' if student_model.get_module_attribute('use_clip_tokens', False) else ''\n\t        ))\n\t        dataset = CaptionDataset(\n\t            vision_root=configs.image_video_root[args.dataset],\n\t            ann_rpath=ann_rpath,\n\t            lang=args.lang,\n\t            clip_model=teacher_model,\n\t            pickle_path=pickle_path,\n\t            logger=logger,\n", "            mean_pooling=args.mean_pooling\n\t        )\n\t        loader = DataLoader(\n\t            dataset=dataset,\n\t            batch_size=args.batch_size,\n\t            shuffle=True if mode == 'train' else False,\n\t            collate_fn=dataset.collate_fn,\n\t            # NOTE: do not set `num_workers`, it will raise an error about `using cuda with multiprocessing`\n\t        )\n\t        logger.info(f'{mode} #data: {len(dataset)}, #batches: {len(loader)}')\n", "        loaders.append(loader)\n\t    train_loader, val_loader, test_loader = loaders\n\t    ##############################################################################\n\t    evaluation_settings = {\n\t        k: getattr(args, k) \n\t        for k in ['lang', 'num_beams', 'max_length', 'min_length', 'repetition_penalty']\n\t    }\n\t    if args.auto:\n\t        evaluation_settings.update(configs.auto_settings[args.lang])\n\t    logger.info(f'Evaluation settings: {evaluation_settings}')\n", "    gt_file_path = get_formatted_string(vars(args), \"val_gt_file\", assigned_keys=['dataset', 'lang'])\n\t    evaluator = CaptionEvaluator(\n\t        loader=val_loader,\n\t        gt_file_path=gt_file_path,\n\t        evaluation_settings=evaluation_settings,\n\t        mode='val',\n\t        logger=logger,\n\t        with_epoch=True,\n\t    )\n\t    train_loss = LossManager(student_model, loss_mse_scale=0, loss_at_teacher_scale=1)\n", "    student_model.fit(train_objectives=[(train_loader, train_loss)],\n\t        epochs=args.epochs,\n\t        evaluator=evaluator,\n\t        save_best_model=True,\n\t        warmup_steps=args.warmup_steps,\n\t        optimizer_params= {'lr': args.lr, 'eps': args.eps},\n\t        weight_decay=args.weight_decay,\n\t        output_path=args.output_path,\n\t        log_every=args.log_every,\n\t        use_amp=args.use_amp,\n", "        scheduler=args.scheduler,\n\t        seed=args.seed,\n\t    )\n\t    ##############################################################################\n\t    gt_file_path = get_formatted_string(vars(args), \"test_gt_file\", assigned_keys=['dataset', 'lang'])\n\t    evaluator = CaptionEvaluator(\n\t        loader=test_loader,\n\t        gt_file_path=gt_file_path,\n\t        evaluation_settings=evaluation_settings,\n\t        mode='test',\n", "        logger=logger,\n\t    )\n\t    student_model = Framework(args.output_path)\n\t    evaluator(student_model, os.path.join(args.output_path, 'eval'))\n\t    train_loader.dataset.save_pickle()\n\t    val_loader.dataset.save_pickle()\n\t    test_loader.dataset.save_pickle()\n"]}
{"filename": "infer_caption.py", "chunked_list": ["import os\n\timport time\n\timport datetime\n\timport argparse\n\timport logging\n\timport configs\n\tfrom torch.utils.data import DataLoader\n\tfrom sentence_transformers import LoggingHandler\n\tfrom zeronlg import ZeroNLG, CaptionDataset, CaptionEvaluator\n\tfrom zeronlg.utils import get_formatted_string\n", "logging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tlogger = logging.getLogger(__name__)\n\ttry:\n\t    ROOT = configs.annotation_caption_root\n\texcept:\n\t    ROOT = configs.annotation_root\n\tif __name__ == '__main__':\n", "    parser = argparse.ArgumentParser()\n\t    parser.add_argument('--model', type=str, required=True)\n\t    parser.add_argument('--use_clip_tokens', type=int, help='Whether use token-level visual embeddings?')\n\t    # Data paths and attributes\n\t    parser.add_argument('--data_root', type=str, default=ROOT)\n\t    parser.add_argument('--dataset', type=str, default='coco')\n\t    parser.add_argument('--val_file', type=str, help='If not specified, use val_file_format')\n\t    parser.add_argument('--val_gt_file', type=str, help='If not specified, use val_gt_file_format')\n\t    parser.add_argument('--test_file', type=str, help='If not specified, use test_file_format')\n\t    parser.add_argument('--test_gt_file', type=str, help='If not specified, use test_gt_file_format')\n", "    parser.add_argument('--pickle_path', type=str, help='If not specified, use pickle_path_format')\n\t    parser.add_argument('--val_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/val.json'))\n\t    parser.add_argument('--val_gt_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/val_gt.json'))\n\t    parser.add_argument('--test_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/test.json'))\n\t    parser.add_argument('--test_gt_file_format', type=str, default=os.path.join(ROOT, '{dataset}/{lang}/test_gt.json'))\n\t    parser.add_argument('--pickle_path_format', type=str, default=os.path.join(ROOT, '{dataset}/{clip_model_name}_{mode}{postfix}.pkl'))\n\t    # Dataloader settings\n\t    parser.add_argument('--batch_size', type=int, default=64)\n\t    # Evaluation settings\n\t    parser.add_argument('--auto', action='store_true', help='whether to use the auto_settings')\n", "    parser.add_argument('--no_score', action='store_true', help='do not calculate caption scores')\n\t    parser.add_argument('--modes', type=str, nargs='+', default=['test'], help='evaluation modes: [\"val\"], [\"test\"], [\"val\", \"test\"]')\n\t    parser.add_argument('--lang', type=str, default='en', help='which language to be generated?')\n\t    parser.add_argument('--num_beams', type=int, default=3)\n\t    parser.add_argument('--max_length', type=int, default=30)\n\t    parser.add_argument('--min_length', type=int, default=5)\n\t    parser.add_argument('--repetition_penalty', type=float, default=1.0)\n\t    parser.add_argument('--num_frames', type=int, default=configs.num_frames)\n\t    parser.add_argument('--mean_pooling', action='store_true')\n\t    # Output settings\n", "    parser.add_argument('--output_path', type=str, help='If not specified, output_path will be {model}/evaluations_caption/{dataset}/{lang}')\n\t    parser.add_argument('--no_suffix_folder', action='store_true', help='If True, the suffix `evaluations_caption/{dataset}/{lang}` will not be joined to the output path')\n\t    parser.add_argument('--print_sent', action='store_true')\n\t    args = parser.parse_args()\n\t    if not os.path.exists(args.model):\n\t        assert args.output_path, \"you are training to load a model from hugginface hub, please specify --output_path\"\n\t    output_path = args.output_path or args.model\n\t    if not args.no_suffix_folder: \n\t        output_path = os.path.join(output_path, 'evaluations_caption', args.dataset, args.lang)\n\t    os.makedirs(output_path, exist_ok=True)\n", "    logger.addHandler(logging.FileHandler(os.path.join(output_path, 'log.txt'), 'w', encoding='utf-8'))\n\t    logger.info(f'output path: {output_path}')\n\t    assert args.modes in [['val'], ['test'], ['val', 'test']]\n\t    logger.info(f'Creating model from {args.model}')\n\t    model = ZeroNLG(args.model, use_clip_tokens=args.use_clip_tokens)\n\t    # prepare evaluation settings\n\t    evaluation_settings = {\n\t        k: getattr(args, k) \n\t        for k in ['lang', 'num_beams', 'max_length', 'min_length', 'repetition_penalty']\n\t    }\n", "    if args.auto:\n\t        evaluation_settings.update(configs.auto_settings[args.lang])\n\t    logger.info(f'Evaluation settings: {evaluation_settings}')\n\t    # start evaluation\n\t    start_time = time.time()\n\t    for mode in args.modes:\n\t        ann_rpath = get_formatted_string(vars(args), f\"{mode}_file\", assigned_keys=['dataset', 'lang'])\n\t        logger.info(f'Load dataset from {ann_rpath}')\n\t        pickle_path = get_formatted_string(vars(args), 'pickle_path', assigned_kwargs=dict(\n\t            dataset=args.dataset, clip_model_name=model.clip_model_name, mode=mode, postfix='_tokens' if model.use_clip_tokens else ''\n", "        ))\n\t        dataset = CaptionDataset(\n\t            vision_root=configs.image_video_root[args.dataset],\n\t            ann_rpath=ann_rpath,\n\t            num_frames=args.num_frames,\n\t            lang=args.lang,\n\t            clip_model=model.clip_model,\n\t            pickle_path=pickle_path,\n\t            logger=logger,\n\t            mean_pooling=args.mean_pooling,\n", "        )\n\t        logger.info(f'There are {len(dataset)} vision inputs')\n\t        loader = DataLoader(\n\t            dataset,\n\t            batch_size=args.batch_size,\n\t            shuffle=False,\n\t            collate_fn=dataset.collate_fn,\n\t        )\n\t        gt_file_path = get_formatted_string(vars(args), f\"{mode}_gt_file\", assigned_keys=['dataset', 'lang'])\n\t        evaluator = CaptionEvaluator(\n", "            loader=loader,\n\t            gt_file_path=gt_file_path,\n\t            evaluation_settings=evaluation_settings,\n\t            mode=mode,\n\t            logger=logger\n\t        )\n\t        evaluator(model, output_path=output_path, no_score=args.no_score, print_sent=args.print_sent)\n\t    total_time = time.time() - start_time\n\t    total_time_str = str(datetime.timedelta(seconds=int(total_time)))\n\t    print('Time {}'.format(total_time_str))\n", "'''\n\tpython infer_caption.py --model zeronlg-4langs-vc --output_path output/zeronlg-4langs-vc --dataset msrvtt --lang en --modes val test\n\t'''\n"]}
{"filename": "zeronlg/__init__.py", "chunked_list": ["__LIBRARY_NAME__ = 'zeronlg'\n\t__version__ = \"1.0.0\"\n\t__HUGGINGFACE_HUB_NAME__ = 'yangbang18'\n\tfrom .Framework import Framework\n\tfrom .ZeroNLG import ZeroNLG\n\tfrom .losses import LossManager\n\tfrom .datasets import (\n\t    PretrainDataset, \n\t    CaptionDataset, \n\t    CaptionDatasetForRetrieval,\n", "    TranslateDataset\n\t)\n\tfrom .evaluation import (\n\t    CaptionEvaluator, \n\t    TranslateEvaluator, \n\t    RetrievalEvaluator\n\t)\n"]}
{"filename": "zeronlg/ZeroNLG.py", "chunked_list": ["import torch\n\timport torch.nn.functional as F\n\tfrom torch import nn, Tensor\n\tfrom PIL import Image\n\tfrom typing import List, Optional, Union, Dict, Any, Tuple\n\tfrom sentence_transformers.util import batch_to_device\n\tfrom . import Framework\n\tfrom .utils import process_images\n\tfrom .models import Decoder, CLIPModel\n\tSUPPORTED_TASKS = ['caption', 'translate']\n", "class ZeroNLG(nn.Module):\n\t    def __init__(self, \n\t                 multilingual_model: Union[str, Framework], \n\t                 clip_model: Union[str, Framework, None] = None, \n\t                 use_clip_tokens: Optional[bool] = None,\n\t                 load_clip_model: bool = True,\n\t                 device: Union[str, torch.device, None] = None,\n\t        ):\n\t        super().__init__()\n\t        self.use_clip_tokens = use_clip_tokens\n", "        if device is None:\n\t            device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\t        self._target_device = torch.device(device)\n\t        if type(multilingual_model) is str:\n\t            self.multilingual_model = Framework(multilingual_model, device=self.device)\n\t        else:\n\t            self.multilingual_model = multilingual_model\n\t        self.clip_model_name = None\n\t        if clip_model is None or clip_model == '':\n\t            self.clip_model_name = self.multilingual_model.get_module_attribute('teacher_model_name') \\\n", "                    or self.multilingual_model.get_module_attribute('clip_model_name')\n\t        elif type(clip_model) is str:\n\t            self.clip_model_name = clip_model\n\t        else:\n\t            assert isinstance(clip_model, Framework)\n\t            self.clip_model = clip_model\n\t        if load_clip_model:\n\t            self._load_clip_model()\n\t    def forward(self,\n\t            images: Union[str, List[str], Image.Image, List[Image.Image], None] = None,\n", "            texts: Union[str, List[str], None] = None, \n\t            image_embs: Optional[Tensor] = None,\n\t            text_embs: Optional[Tensor] = None,\n\t            num_frames: int=8,\n\t            lang: Optional[str] = None, \n\t            num_beams: int = 3,\n\t            max_length: int = 30,\n\t            min_length: int = 5,\n\t            repetition_penalty: float = 1.0,\n\t            return_all: bool = False,\n", "            attend_to: Union[str, List[str], None] = None,\n\t            task: Optional[str] = None,\n\t            **kwargs,\n\t        ) -> Union[List[str], Dict[str, Any]]:\n\t        if task:\n\t            assert task in SUPPORTED_TASKS\n\t        else:\n\t            raise ValueError(f'Please either pass the argument `task` ({SUPPORTED_TASKS}) or call the corresponding forward function')\n\t        forward_func_name = f'forward_{task}'\n\t        forward_func = getattr(self, forward_func_name, None)\n", "        assert forward_func is not None, f\"Please implement the function {forward_func_name} in ZeroNLG\"\n\t        return forward_func(\n\t            images=images,\n\t            texts=texts,\n\t            image_embs=image_embs,\n\t            text_embs=text_embs,\n\t            num_frames=num_frames,\n\t            lang=lang,\n\t            num_beams=num_beams,\n\t            max_length=max_length,\n", "            min_length=min_length,\n\t            repetition_penalty=repetition_penalty,\n\t            return_all=return_all,\n\t            attend_to=attend_to,\n\t            **kwargs\n\t        )\n\t    def forward_caption(self, \n\t            images: Union[str, List[str], Image.Image, List[Image.Image], None] = None,\n\t            image_embs: Optional[Tensor] = None,\n\t            num_frames: int = 8,\n", "            lang: Optional[str] = None, \n\t            num_beams: int = 3,\n\t            max_length: int = 30,\n\t            min_length: int = 5,\n\t            repetition_penalty: float = 1.0,\n\t            return_all: bool = False,\n\t            attend_to: Union[str, List[str], None] = None,\n\t            **kwargs\n\t        ) -> Union[List[str], Dict[str, Any]]:\n\t        # the decoder should always attend to teacher's outputs in the cross-attention layers\n", "        attend_to = ['teacher']\n\t        # prepare clip image embeddings\n\t        image_embs = self.get_image_embeddings(images, image_embs, num_frames, normalize=False, mean_pooling=False)\n\t        # we re-define multilingual model to exclude encoding modules, which are useless for visual captioning\n\t        multilingual_model = self.multilingual_model.get_decoding_model(self.device)\n\t        multilingual_model.eval()\n\t        # features that will be passed to the multilingual model\n\t        features = dict(\n\t            source_embedding=image_embs,\n\t            attend_to=attend_to,\n", "            num_beams=num_beams,\n\t            max_length=max_length,\n\t            min_length=min_length,\n\t            repetition_penalty=repetition_penalty,\n\t        )\n\t        features.update(kwargs) # kwargs for generation\n\t        features['decoder_input_ids'] = self.get_bos_input_ids(batch_size=image_embs.size(0), lang=lang)\n\t        features = batch_to_device(features, self.device)\n\t        with torch.no_grad():\n\t            outputs = multilingual_model(features)\n", "        if return_all:\n\t            return outputs\n\t        # return only the caption\n\t        return outputs['results_at_teacher']\n\t    def forward_translate(self, \n\t            texts: Union[str, List[str], Tuple[str], None] = None, \n\t            text_embs: Optional[Tensor] = None,\n\t            lang: Optional[str] = None, \n\t            num_beams: int = 3,\n\t            max_length: int = 30,\n", "            min_length: int = 5,\n\t            repetition_penalty: float = 1.0,\n\t            return_all: bool = False,\n\t            attend_to: Union[str, List[str], None] = None,\n\t            **other_generate_kwargs\n\t        ) -> Union[List[str], Dict[str, Any]]:\n\t        # by default, the decoder attend to student's output in cross-attention layers\n\t        attend_to = attend_to or ['student']\n\t        if type(attend_to) is str:\n\t            attend_to = [attend_to]\n", "        if text_embs is not None:\n\t            # given that you have provided clip's text text_embs, the decoder must attend to clip (teacher)\n\t            attend_to = ['teacher']\n\t        assert len(attend_to) == 1, 'attend_to should be one of \"teacher\", \"student\", [\"teacher\"], [\"student\"]'\n\t        assert texts is not None or text_embs is not None, \"you should specify either texts or text_embs\"\n\t        # prepare tokenized text features for the multilingual encoder\n\t        # or clip text embeddings\n\t        tokenized_features, source_embedding = {}, None\n\t        if text_embs is None:\n\t            texts = [texts] if not isinstance(texts, (list, tuple)) else texts\n", "            batch_size = len(texts)\n\t            if attend_to == ['teacher']:\n\t                # extract clip text embeddigns\n\t                self._load_clip_model() # load clip model if it has not been loaded\n\t                self.clip_model = self.clip_model.to(self.device)\n\t                self.clip_model.eval()\n\t                source_embedding = self.clip_model.encode(texts, batch_size, show_progress_bar=False, convert_to_tensor=True)\n\t            else:\n\t                tokenized_features = self.multilingual_model.tokenize(texts)\n\t        else:            \n", "            source_embedding = text_embs\n\t            batch_size = text_embs.size(0)\n\t        # re-define multilingual model if necessary\n\t        if attend_to == ['teacher']:\n\t            multilingual_model = self.multilingual_model.get_decoding_model(self.device)\n\t        else:\n\t            multilingual_model = self.multilingual_model.to(self.device)\n\t        multilingual_model.eval()\n\t        # features that will be passed to the multilingual model\n\t        features = dict(\n", "            source_embedding=source_embedding,\n\t            attend_to=attend_to,\n\t            num_beams=num_beams,\n\t            max_length=max_length,\n\t            min_length=min_length,\n\t            repetition_penalty=repetition_penalty,\n\t            **tokenized_features,\n\t        )\n\t        features.update(other_generate_kwargs)\n\t        features['decoder_input_ids'] = self.get_bos_input_ids(batch_size=batch_size, lang=lang)\n", "        features = batch_to_device(features, self.device)\n\t        with torch.no_grad():\n\t            outputs = multilingual_model(features)\n\t        if return_all:\n\t            return outputs\n\t        # return only the translated text\n\t        return outputs[f'results_at_{attend_to[0]}']\n\t    def get_image_embeddings(self,\n\t            images: Union[str, List[str], Image.Image, List[Image.Image], None] = None,\n\t            image_embs: Optional[Tensor] = None,\n", "            num_frames: int = 8,\n\t            mean_pooling: bool = False,\n\t            normalize: bool = False,\n\t            batch_size: Optional[int] = None,\n\t            **kwargs,\n\t        ) -> Tensor:\n\t        \"\"\"Extract CLIP image embeddings\"\"\"\n\t        if image_embs is None:\n\t            assert images is not None, \"you should specify either images or image_embs\"\n\t            self._load_clip_model() # load clip model if it has not been loaded\n", "            self.clip_model = self.clip_model.to(self.device)\n\t            self.clip_model.eval()\n\t            images, is_video, num_frames, num_samples = process_images(images, num_frames)\n\t            batch_size = batch_size or num_samples\n\t            image_embs = self.clip_model.encode(\n\t                images, batch_size, output_value='token_embeddings' if self.use_clip_tokens else 'sentence_embedding',\n\t                show_progress_bar=False, convert_to_tensor=True, device=self.device)\n\t            if isinstance(image_embs, list):\n\t                image_embs = torch.stack(image_embs, dim=0).to(self.device)\n\t            if is_video:\n", "                image_embs = image_embs.view(batch_size, num_frames, -1, image_embs.size(-1)).squeeze(2)\n\t        else:\n\t            image_embs = image_embs.to(self.device)\n\t            batch_size = image_embs.size(0)\n\t        if image_embs.ndim == 1:\n\t            image_embs = image_embs.unsqueeze(0)\n\t        if image_embs.ndim > 2 and mean_pooling:\n\t            # averaged over the time axis\n\t            image_embs = image_embs.mean(dim=1)\n\t        if normalize:\n", "            image_embs = F.normalize(image_embs, dim=-1)\n\t        return image_embs\n\t    def get_text_embeddings(self, \n\t            texts: Union[str, List[str], None] = None, \n\t            text_embs: Optional[Tensor] = None,\n\t            normalize: bool = False,\n\t            batch_size: Optional[int] = None,\n\t            **kwargs,\n\t        ) -> Tensor:\n\t        \"\"\"Extract CLIP text embeddings\"\"\"\n", "        # we re-define multilingual model to exclude useless decoding modules\n\t        multilingual_model = self.multilingual_model.get_encoding_model(self.device)\n\t        multilingual_model.eval()\n\t        texts = [texts] if not isinstance(texts, (list, tuple)) else texts\n\t        batch_size = batch_size or len(texts)\n\t        if text_embs is None:\n\t            text_embs = multilingual_model.encode(texts, batch_size, show_progress_bar=False, convert_to_tensor=True, device=self.device)\n\t        else:\n\t            text_embs = text_embs.to(self.device)\n\t        if text_embs.ndim == 1:\n", "            text_embs = text_embs.unsqueeze(0)\n\t        if normalize:\n\t            text_embs = F.normalize(text_embs, dim=-1)\n\t        return text_embs\n\t    def get_bos_input_ids(self, batch_size: int, lang: Optional[str] = None) -> Tensor:\n\t        for module in self.multilingual_model.get_modules():\n\t            if isinstance(module, Decoder):\n\t                return module.get_bos_input_ids(batch_size=batch_size, lang=lang)\n\t    def _load_clip_model(self):\n\t        if not hasattr(self, 'clip_model'):\n", "            try:\n\t                # in this case, the multilignual model is actually a monolingual CLIP model\n\t                print(self.multilingual_model)\n\t                assert isinstance(self.multilingual_model._first_module(), CLIPModel)\n\t                self.clip_model = self.multilingual_model.get_encoding_model(device=self.device)\n\t            except:\n\t                assert self.clip_model_name is not None, \"you are trying to use a clip model, whose name can not be obtained from the multilingual model;\\\n\t                    Maybe you should pass the argument `clip_model_name` when defining a ZeroNLG model\"\n\t                assert type(self.clip_model_name) is str\n\t                self.clip_model = Framework(self.clip_model_name, device=self.device)\n", "            self.use_clip_tokens = self.use_clip_tokens or self.multilingual_model.get_module_attribute('use_clip_tokens', False)\n\t            self.clip_model.set_module_attribute(CLIPModel, 'use_clip_tokens', self.use_clip_tokens)\n\t    @property\n\t    def device(self):\n\t        return self._target_device\n"]}
{"filename": "zeronlg/Framework.py", "chunked_list": ["import os\n\timport torch\n\timport json\n\timport time\n\timport shutil\n\timport logging\n\timport datetime\n\timport random\n\timport numpy as np\n\timport transformers\n", "import stat\n\timport tempfile\n\timport torch\n\timport torch.backends.cudnn as cudnn\n\tfrom torch import nn\n\tfrom torch.optim import Optimizer\n\tfrom torch.utils.data import DataLoader\n\tfrom tqdm.autonotebook import trange\n\tfrom collections import OrderedDict\n\tfrom distutils.dir_util import copy_tree\n", "from huggingface_hub import HfApi, HfFolder, Repository\n\tfrom typing import List, Dict, Tuple, Iterable, Type, Callable, Optional, Union\n\tfrom sentence_transformers import SentenceTransformer, LoggingHandler\n\tfrom sentence_transformers import __version__ as __sbert_version__\n\tfrom sentence_transformers.evaluation import SentenceEvaluator\n\tfrom sentence_transformers.util import batch_to_device, fullname, import_from_string\n\tfrom sentence_transformers.model_card_templates import ModelCardTemplate\n\tfrom sentence_transformers.models import Pooling\n\tfrom .models import Transformer, Projector, Decoder\n\tfrom .utils import MetricLogger, random_masking_, get_cache_folder\n", "from . import __LIBRARY_NAME__, __version__, __HUGGINGFACE_HUB_NAME__\n\tlogging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tglobal_logger = logging.getLogger(__name__)\n\tsbert_mappings = {\n\t    'sentence_transformers.models.Transformer': 'zeronlg.models.Transformer',\n\t    'sentence_transformers.models.Dense': 'zeronlg.models.Dense',\n\t    'sentence_transformers.models.CLIPModel': 'zeronlg.models.CLIPModel',\n", "    'models.Dense': 'zeronlg.models.Dense',\n\t    'models.Projector': 'zeronlg.models.Projector',\n\t    'models.Decoder': 'zeronlg.models.Decoder',\n\t}\n\tclass Framework(SentenceTransformer):\n\t    def __init__(self, \n\t                 model_name_or_path: Optional[str] = None, \n\t                 modules: Optional[Iterable[nn.Module]] = None, \n\t                 device: Optional[str] = None, \n\t                 cache_folder: Optional[str] = get_cache_folder(), \n", "                 use_auth_token: Union[bool, str, None] = None,\n\t                 tie_word_embeddings: bool = True,\n\t                 freeze_word_embeddings: bool = False,\n\t                 logger: logging.Logger = None,\n\t                 load_sbert_only: bool = False,\n\t                 ):\n\t        # check if we need to prefix `model_name_or_path` with __HUGGINGFACE_HUB_NAME__\n\t        if model_name_or_path \\\n\t            and 'zeronlg' in model_name_or_path.lower() \\\n\t            and '/' not in model_name_or_path \\\n", "            and not os.path.exists(model_name_or_path):\n\t            model_name_or_path = os.path.join(__HUGGINGFACE_HUB_NAME__, model_name_or_path)\n\t        super().__init__(model_name_or_path, modules, device, cache_folder, use_auth_token)\n\t        self.model_name_or_path = model_name_or_path\n\t        self.logger = logger or global_logger\n\t        self.load_sbert_only = load_sbert_only\n\t        if tie_word_embeddings:\n\t            self._tie_word_embeddings()\n\t        if freeze_word_embeddings:\n\t            self._freeze_word_embeddings()\n", "        #Save some model info\n\t        if '__version__' not in self._model_config:\n\t            self._model_config['__version__'] = {\n\t                'sentence_transformers': __sbert_version__,\n\t                'transformers': transformers.__version__,\n\t                'pytorch': torch.__version__,\n\t                __LIBRARY_NAME__: __version__,\n\t            }\n\t        elif __LIBRARY_NAME__ not in self._model_config['__version__']:\n\t            self._model_config['__version__'][__LIBRARY_NAME__] = __version__\n", "    def _tie_word_embeddings(self):\n\t        encoder_module, decoder_module = None, None\n\t        for module in self.get_modules():\n\t            if isinstance(module, Transformer):\n\t                encoder_module = module\n\t            if isinstance(module, Decoder):\n\t                decoder_module = module\n\t        if encoder_module is not None and decoder_module is not None:\n\t            encoder_input_word_embs = encoder_module.auto_model.get_input_embeddings()\n\t            decoder_input_word_embs = decoder_module.auto_model.get_input_embeddings()\n", "            decoder_output_word_embs = decoder_module.auto_model.get_output_embeddings()\n\t            decoder_module.auto_model._tie_or_clone_weights(decoder_input_word_embs, encoder_input_word_embs)\n\t            decoder_module.auto_model._tie_or_clone_weights(decoder_output_word_embs, encoder_input_word_embs)\n\t    def _freeze_word_embeddings(self):\n\t        for module in self.get_modules():\n\t            if isinstance(module, (Transformer, Decoder)):\n\t                for embs in [\n\t                        module.auto_model.get_input_embeddings(), \n\t                        module.auto_model.get_output_embeddings()\n\t                    ]:\n", "                    if embs is not None:\n\t                        for p in embs.parameters():\n\t                            p.requires_grad = False\n\t    def _load_sbert_model(self, model_path):\n\t        \"\"\"\n\t        Loads a full sentence-transformers model\n\t        \"\"\"\n\t        # Check if the config_sentence_transformers.json file exists (exists since v2 of the framework)\n\t        config_sentence_transformers_json_path = os.path.join(model_path, 'config_sentence_transformers.json')\n\t        if os.path.exists(config_sentence_transformers_json_path):\n", "            with open(config_sentence_transformers_json_path) as fIn:\n\t                self._model_config = json.load(fIn)\n\t            # Yang B. modification: additionally check version of zeronlg\n\t            for package_name, version in zip(['sentence_transformers', __LIBRARY_NAME__], [__sbert_version__, __version__]):\n\t                if '__version__' in self._model_config \\\n\t                    and package_name in self._model_config['__version__'] \\\n\t                    and self._model_config['__version__'][package_name] > version:\n\t                    self.logger.warning(\n\t                        f\"You try to use a {package_name} model that was created with version {self._model_config['__version__'][package_name]}, however, your version is {version}. \\\n\t                        This might cause unexpected behavior or errors.\\n\\n\\n\")\n", "        # Check if a readme exists\n\t        model_card_path = os.path.join(model_path, 'README.md')\n\t        if os.path.exists(model_card_path):\n\t            try:\n\t                with open(model_card_path, encoding='utf8') as fIn:\n\t                    self._model_card_text = fIn.read()\n\t            except:\n\t                pass\n\t        # Load the modules of sentence transformer\n\t        modules_json_path = os.path.join(model_path, 'modules.json')\n", "        with open(modules_json_path) as fIn:\n\t            modules_config = json.load(fIn)\n\t        modules = OrderedDict()\n\t        for module_config in modules_config:\n\t            # Yang B. modification: apply mappings, make it compatible to new implementations\n\t            module_type = sbert_mappings.get(module_config['type'], module_config['type'])\n\t            module_class = import_from_string(module_type)\n\t            module = module_class.load(os.path.join(model_path, module_config['path']))\n\t            modules[module_config['name']] = module\n\t        return modules\n", "    def _load_auto_model(self, model_name_or_path):\n\t        \"\"\"\n\t        Creates a simple Transformer + Mean Pooling model and returns the modules\n\t        \"\"\"\n\t        # Yang B. modification: check if we automatically load non-sbert model\n\t        if self.load_sbert_only:\n\t            raise FileNotFoundError(\"No sentence-transformers model found with name {}, and you set `load_sbert_only` to True\".format(model_name_or_path))\n\t        self.logger.warning(\"No sentence-transformers model found with name {}. Creating a new one with MEAN pooling.\".format(model_name_or_path))\n\t        transformer_model = Transformer(model_name_or_path)\n\t        pooling_model = Pooling(transformer_model.get_word_embedding_dimension(), 'mean')\n", "        return [transformer_model, pooling_model]\n\t    def set_module_attribute(self, module_class, key, value):\n\t        for module in self.get_modules():\n\t            if isinstance(module, module_class):\n\t                setattr(module, key, value)\n\t    def get_module_attribute(self, key, default_value=None):\n\t        for module in self.get_modules():\n\t            if hasattr(module, key):\n\t                return getattr(module, key)\n\t        if key == 'teacher_model_name':\n", "            if 'clip-ViT-B-32' in self.model_name_or_path:\n\t                return 'clip-ViT-B-32'\n\t            if 'clip-ViT-B-16' in self.model_name_or_path:\n\t                return 'clip-ViT-B-16'\n\t            if 'clip-ViT-L-14' in self.model_name_or_path:\n\t                return 'clip-ViT-L-14'\n\t        return default_value\n\t    def get_modules(self):\n\t        return [self._modules[_] for _ in iter(self._modules)]\n\t    def _get_specific_model(self, before=True, instances=(Projector, Decoder), device=None, return_modules_only: bool = False):\n", "        \"\"\"only keep related modules\"\"\"\n\t        modules = self.get_modules()\n\t        idx = 0\n\t        for module in modules:\n\t            if isinstance(module, instances):\n\t                break\n\t            idx += 1\n\t        device = device or self.device\n\t        if before:\n\t            # get modules < idx\n", "            if idx == 0:\n\t                return None  \n\t            if return_modules_only:\n\t                return modules[:idx]\n\t            model = Framework(modules=modules[:idx], device=device)\n\t        else:\n\t            # get modules >= idx\n\t            if idx == len(modules):\n\t                return None\n\t            if return_modules_only:\n", "                return modules[idx:]\n\t            model = Framework(modules=modules[idx:], device=device)\n\t        model.to(device)\n\t        return model\n\t    def get_encoding_model(self, device=None):\n\t        \"\"\"return a model that contains modules only related to encoding\"\"\"\n\t        return self._get_specific_model(before=True, instances=(Projector, Decoder), device=device or self._target_device)\n\t    def get_encoding_modules(self) -> List[nn.Module]:\n\t        \"\"\"return modules only related to encoding\"\"\"\n\t        return self._get_specific_model(before=True, instances=(Projector, Decoder), return_modules_only=True)\n", "    def get_decoding_model(self, device=None):\n\t        \"\"\"return a model that contains modules only related to decoding\"\"\"\n\t        return self._get_specific_model(before=False, instances=(Projector, Decoder), device=device or self._target_device)\n\t    def get_decoding_modules(self) -> List[nn.Module]:\n\t        \"\"\"return modules only related to decoding\"\"\"\n\t        return self._get_specific_model(before=False, instances=(Projector, Decoder), return_modules_only=True)\n\t    def tokenize(self, texts: Union[List[str], List[Dict], List[Tuple[str, str]]]):\n\t        module = self._first_module()\n\t        if hasattr(module, 'tokenize'):\n\t            return module.tokenize(texts)\n", "        return {}\n\t    def decoder_tokenize(self, texts: List[str], langs: Optional[List[str]]=None):\n\t        module = self._last_module()\n\t        if isinstance(module, Decoder):\n\t            return module.tokenize(texts, langs)\n\t        return {}\n\t    @property\n\t    def tokenizer(self):\n\t        \"\"\"Property to get the tokenizer that is used by this model\"\"\"\n\t        module = self._first_module()\n", "        if hasattr(module, 'tokenizer'):\n\t            return module.tokenizer\n\t        return None\n\t    @property\n\t    def decoder_tokenizer(self):\n\t        \"\"\"Property to get the decoder tokenizer that is used by this model\"\"\"\n\t        module = self._last_module()\n\t        if isinstance(module, Decoder):\n\t            return module.tokenizer\n\t        return None\n", "    @property\n\t    def device(self):\n\t        return self._target_device\n\t    def smart_batching_collate(self, batch):\n\t        \"\"\"Transforms a batch of InputExample to features requested by this model\"\"\"\n\t        texts = []\n\t        labels = []\n\t        langs = []\n\t        for example in batch:\n\t            texts.append(example.trg_text)\n", "            if example.label is not None:\n\t                labels.append(example.label)\n\t            if example.lang:\n\t                langs.append(example.lang)\n\t        labels = torch.tensor(np.array(labels)) if len(labels) else None\n\t        features = {}\n\t        # prepare input_ids, attention_mask, ...\n\t        tokenized_results = self.tokenize(texts)\n\t        # mask tokenized results if specified\n\t        if getattr(self, 'use_masking', False):\n", "            # self.use_masking and self.mask_prob is defined in Framework.fit\n\t            random_masking_(\n\t                tokenizer=self.tokenizer, \n\t                tokenized_results=tokenized_results, \n\t                mask_prob=getattr(self, 'mask_prob', 0.15)\n\t            )\n\t        features.update(tokenized_results) \n\t        # prepare decoder_input_ids, decoder_attention_mask, ...\n\t        features.update(self.decoder_tokenize(texts, langs if len(langs) else None)) \n\t        features['source_embedding'] = labels # used for decoding (optional)\n", "        return features, labels\n\t    def fit(self,\n\t            train_objectives: Iterable[Tuple[DataLoader, nn.Module]],\n\t            evaluator: SentenceEvaluator = None,\n\t            epochs: int = 1,\n\t            steps_per_epoch = None,\n\t            scheduler: str = 'WarmupLinear',\n\t            warmup_steps: int = 10000,\n\t            optimizer_class: Type[Optimizer] = torch.optim.AdamW,\n\t            optimizer_params : Dict[str, object]= {'lr': 2e-5},\n", "            weight_decay: float = 0.01,\n\t            evaluation_steps: int = 0,\n\t            output_path: str = None,\n\t            save_best_model: bool = True,\n\t            max_grad_norm: float = 1,\n\t            use_amp: bool = False,\n\t            callback: Callable[[float, int, int], None] = None,\n\t            show_progress_bar: bool = True,\n\t            checkpoint_path: str = None,\n\t            checkpoint_save_steps: int = 500,\n", "            checkpoint_save_total_limit: int = 0,\n\t            log_every: int = 500,\n\t            seed: int = 42,\n\t            use_masking: bool = False,\n\t            mask_prob: float = 0.15,\n\t            ):\n\t        \"\"\"\n\t        Train the model with the given training objective\n\t        Each training objective is sampled in turn for one batch.\n\t        We sample only as many batches from each objective as there are in the smallest one\n", "        to make sure of equal training with each dataset.\n\t        :param train_objectives: Tuples of (DataLoader, LossFunction). Pass more than one for multi-task learning\n\t        :param evaluator: An evaluator (sentence_transformers.evaluation) evaluates the model performance during training on held-out dev data. It is used to determine the best model that is saved to disc.\n\t        :param epochs: Number of epochs for training\n\t        :param steps_per_epoch: Number of training steps per epoch. If set to None (default), one epoch is equal the DataLoader size from train_objectives.\n\t        :param scheduler: Learning rate scheduler. Available schedulers: constantlr, warmupconstant, warmuplinear, warmupcosine, warmupcosinewithhardrestarts\n\t        :param warmup_steps: Behavior depends on the scheduler. For WarmupLinear (default), the learning rate is increased from o up to the maximal learning rate. After these many training steps, the learning rate is decreased linearly back to zero.\n\t        :param optimizer_class: Optimizer\n\t        :param optimizer_params: Optimizer parameters\n\t        :param weight_decay: Weight decay for model parameters\n", "        :param evaluation_steps: If > 0, evaluate the model using evaluator after each number of training steps\n\t        :param output_path: Storage path for the model and evaluation files\n\t        :param save_best_model: If true, the best model (according to evaluator) is stored at output_path\n\t        :param max_grad_norm: Used for gradient normalization.\n\t        :param use_amp: Use Automatic Mixed Precision (AMP). Only for Pytorch >= 1.6.0\n\t        :param callback: Callback function that is invoked after each evaluation.\n\t                It must accept the following three parameters in this order:\n\t                `score`, `epoch`, `steps`\n\t        :param show_progress_bar: If True, output a tqdm progress bar\n\t        :param checkpoint_path: Folder to save checkpoints during training\n", "        :param checkpoint_save_steps: Will save a checkpoint after so many steps\n\t        :param checkpoint_save_total_limit: Total number of checkpoints to store\n\t        \"\"\"\n\t        torch.manual_seed(seed)\n\t        np.random.seed(seed)\n\t        random.seed(seed)\n\t        cudnn.benchmark = True\n\t        self.use_masking = use_masking\n\t        self.mask_prob = mask_prob\n\t        ##Add info to model card\n", "        #info_loss_functions = \"\\n\".join([\"- {} with {} training examples\".format(str(loss), len(dataloader)) for dataloader, loss in train_objectives])\n\t        info_loss_functions =  []\n\t        for dataloader, loss in train_objectives:\n\t            info_loss_functions.extend(ModelCardTemplate.get_train_objective_info(dataloader, loss))\n\t        info_loss_functions = \"\\n\\n\".join([text for text in info_loss_functions])\n\t        info_fit_parameters = json.dumps({\"evaluator\": fullname(evaluator), \"epochs\": epochs, \"steps_per_epoch\": steps_per_epoch, \"scheduler\": scheduler, \"warmup_steps\": warmup_steps, \"optimizer_class\": str(optimizer_class),  \"optimizer_params\": optimizer_params, \"weight_decay\": weight_decay, \"evaluation_steps\": evaluation_steps, \"max_grad_norm\": max_grad_norm }, indent=4, sort_keys=True)\n\t        self._model_card_text = None\n\t        self._model_card_vars['{TRAINING_SECTION}'] = ModelCardTemplate.__TRAINING_SECTION__.replace(\"{LOSS_FUNCTIONS}\", info_loss_functions).replace(\"{FIT_PARAMETERS}\", info_fit_parameters)\n\t        if use_amp:\n\t            from torch.cuda.amp import autocast\n", "            scaler = torch.cuda.amp.GradScaler()\n\t        self.to(self.device)\n\t        dataloaders = [dataloader for dataloader, _ in train_objectives]\n\t        # Use smart batching\n\t        for dataloader in dataloaders:\n\t            dataloader.collate_fn = self.smart_batching_collate\n\t        loss_models = [loss for _, loss in train_objectives]\n\t        for loss_model in loss_models:\n\t            loss_model.to(self.device)\n\t        self.best_score = -9999999\n", "        if steps_per_epoch is None or steps_per_epoch == 0:\n\t            steps_per_epoch = min([len(dataloader) for dataloader in dataloaders])\n\t        num_train_steps = int(steps_per_epoch * epochs)\n\t        # Prepare optimizers\n\t        optimizers = []\n\t        schedulers = []\n\t        for loss_model in loss_models:\n\t            param_optimizer = list(loss_model.named_parameters())\n\t            no_decay = ['bias', 'LayerNorm.bias', 'LayerNorm.weight']\n\t            optimizer_grouped_parameters = [\n", "                {'params': [p for n, p in param_optimizer if not any(nd in n for nd in no_decay)], 'weight_decay': weight_decay},\n\t                {'params': [p for n, p in param_optimizer if any(nd in n for nd in no_decay)], 'weight_decay': 0.0}\n\t            ]\n\t            optimizer = optimizer_class(optimizer_grouped_parameters, **optimizer_params)\n\t            scheduler_obj = self._get_scheduler(optimizer, scheduler=scheduler, warmup_steps=warmup_steps, t_total=num_train_steps)\n\t            optimizers.append(optimizer)\n\t            schedulers.append(scheduler_obj)\n\t        global_step = 0\n\t        data_iterators = [iter(dataloader) for dataloader in dataloaders]\n\t        num_train_objectives = len(train_objectives)\n", "        skip_scheduler = False\n\t        train_start_time = time.time()\n\t        for epoch in trange(epochs, desc=\"Epoch\", disable=not show_progress_bar):\n\t            training_steps = 0\n\t            metric_logger = MetricLogger(delimiter=\"  \")\n\t            start_time = time.time()\n\t            for loss_model in loss_models:\n\t                loss_model.zero_grad()\n\t                loss_model.train()\n\t            for _ in trange(steps_per_epoch, desc=\"Iteration\", smoothing=0.05, disable=not show_progress_bar):\n", "                for train_idx in range(num_train_objectives):\n\t                    loss_model = loss_models[train_idx]\n\t                    optimizer = optimizers[train_idx]\n\t                    scheduler = schedulers[train_idx]\n\t                    data_iterator = data_iterators[train_idx]\n\t                    try:\n\t                        data = next(data_iterator)\n\t                    except StopIteration:\n\t                        data_iterator = iter(dataloaders[train_idx])\n\t                        data_iterators[train_idx] = data_iterator\n", "                        data = next(data_iterator)\n\t                    features, labels = data\n\t                    labels = labels.to(self.device) if labels is not None else None\n\t                    features = batch_to_device(features, self.device)\n\t                    if use_amp:\n\t                        with autocast():\n\t                            loss_value, loss_msg_dict = loss_model(features, labels)\n\t                        scale_before_step = scaler.get_scale()\n\t                        scaler.scale(loss_value).backward()\n\t                        scaler.unscale_(optimizer)\n", "                        torch.nn.utils.clip_grad_norm_(loss_model.parameters(), max_grad_norm)\n\t                        scaler.step(optimizer)\n\t                        scaler.update()\n\t                        skip_scheduler = scaler.get_scale() != scale_before_step\n\t                    else:\n\t                        loss_value, loss_msg_dict = loss_model(features, labels)\n\t                        loss_value.backward()\n\t                        torch.nn.utils.clip_grad_norm_(loss_model.parameters(), max_grad_norm)\n\t                        optimizer.step()\n\t                    metric_logger.update(**loss_msg_dict)\n", "                    optimizer.zero_grad()\n\t                    if not skip_scheduler:\n\t                        scheduler.step()\n\t                training_steps += 1\n\t                global_step += 1\n\t                if log_every > 0 and global_step % log_every == 0:\n\t                    self.log_training_info(metric_logger, epoch, training_steps, steps_per_epoch)\n\t                if evaluation_steps > 0 and training_steps % evaluation_steps == 0:\n\t                    self._eval_during_training(evaluator, output_path, save_best_model, epoch, training_steps, callback)\n\t                    for loss_model in loss_models:\n", "                        loss_model.zero_grad()\n\t                        loss_model.train()\n\t                    info = f\"[BEST] {self.best_score}\"\n\t                    self.logger.info(info)\n\t                if checkpoint_path is not None and checkpoint_save_steps is not None and checkpoint_save_steps > 0 and global_step % checkpoint_save_steps == 0:\n\t                    self._save_checkpoint(checkpoint_path, checkpoint_save_total_limit, global_step)\n\t            metric_logger.synchronize_between_processes()\n\t            info = f\"Averaged stats: {metric_logger.global_avg()}\"\n\t            self.logger.info(info)\n\t            time_string = 'Train epoch time: ' + str(datetime.timedelta(seconds=int(time.time() - start_time)))\n", "            self.logger.info(time_string)\n\t            self._eval_during_training(evaluator, output_path, save_best_model, epoch, -1, callback)\n\t            if checkpoint_path is not None and checkpoint_save_steps is None:\n\t                self._save_checkpoint_epoch(checkpoint_path, checkpoint_save_total_limit, epoch)\n\t        if evaluator is None and output_path is not None:   #No evaluator, but output path: save final model version\n\t            self.save(output_path)\n\t        if checkpoint_path is not None and checkpoint_save_steps is not None:\n\t            self._save_checkpoint(checkpoint_path, checkpoint_save_total_limit, global_step)\n\t        time_string = 'Train time: ' + str(datetime.timedelta(seconds=int(time.time() - train_start_time)))\n\t        self.logger.info(time_string)\n", "    def log_training_info(self, \n\t            metric_logger: MetricLogger, \n\t            epoch: int, \n\t            step: int, \n\t            steps_per_epoch: int,\n\t            delimiter: str = '  ',\n\t            ):\n\t        _msg = [\n\t            'Epoch: {epoch} [{step:' + f'{len(str(steps_per_epoch))}' + 'd} / {steps_per_epoch}]',\n\t            '{meters}',\n", "        ]\n\t        if torch.cuda.is_available():\n\t            _msg.append('max mem: {memory:.0f}')\n\t            MB = 1024.0 * 1024.0\n\t            info = delimiter.join(_msg).format(\n\t                epoch=epoch, \n\t                step=step, \n\t                steps_per_epoch=steps_per_epoch, \n\t                meters=str(metric_logger), \n\t                memory=torch.cuda.max_memory_allocated() / MB\n", "            )\n\t        else:\n\t            info = delimiter.join(_msg).format(\n\t                epoch=epoch, \n\t                step=step, \n\t                steps_per_epoch=steps_per_epoch, \n\t                meters=str(metric_logger)\n\t            )\n\t        self.logger.info(info)\n\t    def _save_checkpoint_epoch(self, checkpoint_path, checkpoint_save_total_limit, epoch):\n", "        # Store new checkpoint\n\t        self.save(os.path.join(checkpoint_path, str(epoch)))\n\t        # Delete old checkpoints\n\t        if checkpoint_save_total_limit is not None and checkpoint_save_total_limit > 0:\n\t            old_checkpoints = []\n\t            for subdir in os.listdir(checkpoint_path):\n\t                if subdir.isdigit():\n\t                    old_checkpoints.append({'epoch': int(subdir), 'path': os.path.join(checkpoint_path, subdir)})\n\t            if len(old_checkpoints) > checkpoint_save_total_limit:\n\t                old_checkpoints = sorted(old_checkpoints, key=lambda x: x['epoch'])\n", "                shutil.rmtree(old_checkpoints[0]['path'])\n\t    @staticmethod\n\t    def load(input_path):\n\t        return Framework(input_path)\n\t    def save_to_hub(self,\n\t                repo_name: str,\n\t                private: Optional[bool] = None,\n\t                commit_message: str = \"Add new ZeroNLG model.\",\n\t                local_model_path: Optional[str] = None,\n\t                exist_ok: bool = False,\n", "                replace_model_card: bool = False,\n\t                train_datasets: Optional[List[str]] = None):\n\t        \"\"\"\n\t        Uploads all elements of this Sentence Transformer to a new HuggingFace Hub repository.\n\t        Yang B. modification: \n\t        1) delete organization to avoid bugs;\n\t        :param repo_name: Repository name for your model in the Hub.\n\t        :param private: Set to true, for hosting a prive model\n\t        :param commit_message: Message to commit while pushing.\n\t        :param local_model_path: Path of the model locally. If set, this file path will be uploaded. Otherwise, the current model will be uploaded\n", "        :param exist_ok: If true, saving to an existing repository is OK. If false, saving only to a new repository is possible\n\t        :param replace_model_card: If true, replace an existing model card in the hub with the automatically created model card\n\t        :param train_datasets: Datasets used to train the model. If set, the datasets will be added to the model card in the Hub.\n\t        :return: The url of the commit of your model in the given repository.\n\t        \"\"\"\n\t        token = HfFolder.get_token()\n\t        if token is None:\n\t            raise ValueError(\"You must login to the Hugging Face hub on this computer by typing `transformers-cli login`.\")\n\t        endpoint = \"https://huggingface.co\"\n\t        repo_url = HfApi(endpoint=endpoint).create_repo(\n", "                repo_name,\n\t                token=token,\n\t                private=private,\n\t                repo_type=None,\n\t                exist_ok=exist_ok,\n\t            )\n\t        full_model_name = repo_url[len(endpoint)+1:].strip(\"/\")\n\t        with tempfile.TemporaryDirectory() as tmp_dir:\n\t            # First create the repo (and clone its content if it's nonempty).\n\t            self.logger.info(\"Create repository and clone it if it exists\")\n", "            repo = Repository(tmp_dir, clone_from=repo_url)\n\t            # If user provides local files, copy them.\n\t            if local_model_path:\n\t                copy_tree(local_model_path, tmp_dir)\n\t            else:  # Else, save model directly into local repo.\n\t                create_model_card = False # TODO: zeronlg model card\n\t                self.save(tmp_dir, model_name=full_model_name, create_model_card=create_model_card, train_datasets=train_datasets)\n\t            #Find files larger 5M and track with git-lfs\n\t            large_files = []\n\t            for root, dirs, files in os.walk(tmp_dir):\n", "                for filename in files:\n\t                    file_path = os.path.join(root, filename)\n\t                    rel_path = os.path.relpath(file_path, tmp_dir)\n\t                    if os.path.getsize(file_path) > (5 * 1024 * 1024):\n\t                        large_files.append(rel_path)\n\t            if len(large_files) > 0:\n\t                self.logger.info(\"Track files with git lfs: {}\".format(\", \".join(large_files)))\n\t                repo.lfs_track(large_files)\n\t            self.logger.info(\"Push model to the hub. This might take a while\")\n\t            push_return = repo.push_to_hub(commit_message=commit_message)\n", "            def on_rm_error(func, path, exc_info):\n\t                # path contains the path of the file that couldn't be removed\n\t                # let's just assume that it's read-only and unlink it.\n\t                try:\n\t                    os.chmod(path, stat.S_IWRITE)\n\t                    os.unlink(path)\n\t                except:\n\t                    pass\n\t            # Remove .git folder. On Windows, the .git folder might be read-only and cannot be deleted\n\t            # Hence, try to set write permissions on error\n", "            try:\n\t                for f in os.listdir(tmp_dir):\n\t                    shutil.rmtree(os.path.join(tmp_dir, f), onerror=on_rm_error)\n\t            except Exception as e:\n\t                self.logger.warning(\"Error when deleting temp folder: {}\".format(str(e)))\n\t                pass\n\t        return push_return\n"]}
{"filename": "zeronlg/losses/LossManager.py", "chunked_list": ["import torch\n\timport torch.nn.functional as F\n\tfrom torch import nn, Tensor\n\tfrom typing import Iterable, Dict, Tuple\n\tfrom ..Framework import Framework\n\tclass LossManager(nn.Module):\n\t    def __init__(self, \n\t                 model: Framework, \n\t                 loss_mse_scale: float = 1.0, \n\t                 loss_at_teacher_scale: float = 0.0, \n", "                 loss_at_student_scale: float = 0.0, \n\t                 loss_contrastive_scale: float = 0.0,\n\t                 ):\n\t        \"\"\"\n\t        :param model: Framework based on sentence-transformers\n\t        :loss_mse_scale: The scale of MSE loss between teacher's and student's sentence embeddings\n\t        :loss_at_teacher_scale: The scale of cross-entropy loss of decoding on teacher's sentence embeddings (translation)\n\t        :loss_at_teacher_scale: The scale of cross-entropy loss of decoding on student's sentence embeddings (auto-encoding)\n\t        :loss_contrastive_scale: The scale of contrastive loss between teacher's and student's sentence embeddings\n\t        \"\"\"\n", "        super(LossManager, self).__init__()\n\t        self.model = model\n\t        self.loss_fct = nn.MSELoss()\n\t        self.loss_mse_scale = loss_mse_scale\n\t        self.loss_at_teacher_scale = loss_at_teacher_scale\n\t        self.loss_at_student_scale = loss_at_student_scale\n\t        self.loss_contrastive_scale = loss_contrastive_scale\n\t        if loss_contrastive_scale > 0:\n\t            self.temp = nn.Parameter(torch.ones([]) * 0.07) # identical to CLIP\n\t    def forward(self, sentence_features: Iterable[Dict[str, Tensor]], labels: Tensor) -> Tuple[Tensor, Dict[str, float]]:\n", "        outputs = self.model(sentence_features)\n\t        loss, loss_msg_dict = 0, {}\n\t        for name in ['mse', 'at_teacher', 'at_student', 'contrastive']:\n\t            this_loss, this_dict = getattr(self, f'forward_{name}')(outputs, labels)\n\t            loss += this_loss\n\t            loss_msg_dict.update(this_dict)\n\t        return loss, loss_msg_dict\n\t    def forward_mse(self, \n\t            outputs: Dict[str, Tensor], \n\t            labels: Tensor,\n", "            name: str = 'loss_mse'\n\t            ) -> Tuple[Tensor, Dict[str, float]]:\n\t        \"\"\"\n\t        Computes the MSE loss between the computed sentence embedding and a target sentence embedding. This loss\n\t        is used when extending sentence embeddings to new languages as described in our publication\n\t        Making Monolingual Sentence Embeddings Multilingual using Knowledge Distillation: https://arxiv.org/abs/2004.09813\n\t        For an example, see the documentation on extending language models to new languages.\n\t        \"\"\"\n\t        if self.loss_mse_scale > 0:\n\t            loss = self.loss_fct(outputs['sentence_embedding'], labels)\n", "            return self.loss_mse_scale * loss, {name: loss.detach().cpu().item()}\n\t        return 0, {}\n\t    def forward_at_teacher(self, \n\t            outputs: Dict[str, Tensor], \n\t            labels: Tensor,\n\t            name: str = 'loss_at_teacher',\n\t            ) -> Tuple[Tensor, Dict[str, float]]:\n\t        if self.loss_at_teacher_scale > 0:\n\t            loss = outputs['loss_at_teacher']\n\t            return self.loss_at_teacher_scale * loss, {name: loss.detach().cpu().item()}\n", "        return 0, {}\n\t    def forward_at_student(self,\n\t            outputs: Dict[str, Tensor], \n\t            labels: Tensor,\n\t            name: str = 'loss_at_student',\n\t            ) -> Tuple[Tensor, Dict[str, float]]:\n\t        if self.loss_at_student_scale > 0:\n\t            loss = outputs['loss_at_student']\n\t            return self.loss_at_student_scale * loss, {name: loss.detach().cpu().item()}\n\t        return 0, {}\n", "    def forward_contrastive(self,\n\t            outputs: Dict[str, Tensor], \n\t            labels: Tensor,\n\t            name: str = 'loss_cl'\n\t            ) -> Tuple[Tensor, Dict[str, float]]:\n\t        if self.loss_contrastive_scale > 0:\n\t            with torch.no_grad():\n\t                self.temp.clamp_(0.001, 0.5)\n\t            feats_student = F.normalize(outputs['sentence_embedding'], dim=-1)\n\t            feats_teacher = F.normalize(labels, dim=-1)\n", "            logits_s2t = feats_student @ feats_teacher.t() / self.temp\n\t            logits_t2s = feats_teacher @ feats_student.t() / self.temp\n\t            cl_labels = torch.arange(logits_s2t.size(0), device=logits_s2t.device)\n\t            loss_s2t = F.cross_entropy(logits_s2t, cl_labels, reduction='mean')\n\t            loss_t2s = F.cross_entropy(logits_t2s, cl_labels, reduction='mean')\n\t            loss = (loss_s2t + loss_t2s) / 2\n\t            return self.loss_contrastive_scale * loss, {\n\t                name: loss.detach().cpu().item(),\n\t                'temp': self.temp.detach().cpu().item(),\n\t            }\n", "        return 0, {}\n"]}
{"filename": "zeronlg/losses/__init__.py", "chunked_list": ["from .LossManager import LossManager\n"]}
{"filename": "zeronlg/evaluation/CaptionEvaluator.py", "chunked_list": ["import os\n\timport json\n\timport torch\n\timport logging\n\tfrom tqdm import tqdm\n\tfrom torch.utils.data import DataLoader\n\tfrom sentence_transformers import LoggingHandler\n\tfrom typing import Dict, Any, Union\n\tfrom .. import Framework, ZeroNLG\n\tfrom ..datasets import CaptionDataset\n", "from ..utils import coco_caption_eval\n\tlogging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tglobal_logger = logging.getLogger(__name__)\n\tclass CaptionEvaluator:\n\t    def __init__(self, \n\t            loader: DataLoader, \n\t            gt_file_path: str, \n", "            evaluation_settings: Dict[str, Any] = {'lang': 'en'}, \n\t            mode: str = 'val', \n\t            logger: logging.Logger = None, \n\t            monitor: str = 'CIDEr', \n\t            with_epoch: bool = False, \n\t            with_steps: bool = False,\n\t            auto_save: bool = True\n\t        ):\n\t        super().__init__()\n\t        assert mode in ['val', 'test']\n", "        assert 'lang' in evaluation_settings\n\t        assert isinstance(loader.dataset, CaptionDataset)\n\t        assert loader.dataset.clip_model is not None\n\t        self.loader = loader\n\t        self.gt_file_path = gt_file_path\n\t        self.evaluation_settings = evaluation_settings\n\t        self.mode = mode\n\t        self.logger = logger or global_logger\n\t        self.monitor = monitor\n\t        self.with_epoch = with_epoch\n", "        self.with_steps = with_steps\n\t        self.auto_save = auto_save\n\t    def log(self, msg):\n\t        self.logger.info(msg)\n\t    @torch.no_grad()\n\t    def __call__(self, \n\t            model: Union[Framework, ZeroNLG, str], \n\t            output_path: str = None, \n\t            epoch: int = -1, \n\t            steps: int = -1, \n", "            no_score: bool=False, \n\t            print_sent: bool=False\n\t        ) -> float:\n\t        prefix = [self.mode]\n\t        if self.with_epoch:\n\t            prefix.append(f'epoch{epoch}')\n\t        if self.with_steps:\n\t            prefix.append(f'steps{steps}')\n\t        prefix = '_'.join(prefix)\n\t        if output_path:\n", "            result_file = os.path.join(output_path, f'{prefix}_captions.json')\n\t            detailed_scores_file = os.path.join(output_path, f'{prefix}_detailed_scores.json')\n\t            scores_file = os.path.join(output_path, f'{prefix}_scores.json')\n\t        if type(model) is str:\n\t            zeronlg = ZeroNLG(model)\n\t        elif isinstance(model, Framework):\n\t            zeronlg = ZeroNLG(\n\t                multilingual_model=model,\n\t                device=model.device,\n\t                load_clip_model=False,\n", "            )\n\t        else:\n\t            assert isinstance(model, ZeroNLG)\n\t            zeronlg = model\n\t        results = []\n\t        for batch in tqdm(self.loader):\n\t            image_ids, image_embs = batch\n\t            outputs = zeronlg.forward_caption(\n\t                image_embs=image_embs,\n\t                **self.evaluation_settings,\n", "            )\n\t            for caption, image_id in zip(outputs, image_ids):\n\t                results.append({\"image_id\": image_id, \"caption\": caption})\n\t                if print_sent:\n\t                    print(image_id, caption)\n\t        if output_path:\n\t            self.log(f'Save caption results to {result_file}')\n\t            json.dump(results, open(result_file, 'w'))\n\t        if self.auto_save:\n\t            self.loader.dataset.save_pickle()\n", "        if not no_score:\n\t            coco_test = coco_caption_eval(self.gt_file_path, result_file, eval_lang=self.evaluation_settings['lang'])\n\t            if output_path:\n\t                self.log(f'Save detailed scores to {detailed_scores_file}')\n\t                json.dump(coco_test.evalImgs, open(detailed_scores_file, 'w'))\n\t            if output_path:\n\t                self.log(f'Save scores to {scores_file}')\n\t                json.dump(coco_test.eval, open(scores_file, 'w'))\n\t            for k, v in coco_test.eval.items():\n\t                self.log(f'[{prefix}] {k} {v}')\n", "            score = coco_test.eval[self.monitor]\n\t            return score\n"]}
{"filename": "zeronlg/evaluation/RetrievalEvaluator.py", "chunked_list": ["import os\n\timport json\n\timport logging\n\timport torch\n\timport numpy as np\n\tfrom tqdm import tqdm\n\tfrom torch.utils.data import DataLoader\n\tfrom sentence_transformers import LoggingHandler\n\tfrom typing import Dict, Union, List, Any\n\tfrom .. import Framework, ZeroNLG\n", "from ..datasets import CaptionDatasetForRetrieval\n\tlogging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tglobal_logger = logging.getLogger(__name__)\n\tdef construct_gts(annotation: List[Dict[str, Any]]):\n\t    img2text = {}\n\t    text2img = {}\n\t    text_id = 0\n", "    for img_id, ann in enumerate(annotation):\n\t        assert 'caption' in ann, f'The annotation item {ann} does not contain the key `caption`'\n\t        captions = ann['caption']\n\t        if not isinstance(captions, (list, tuple)):\n\t            captions = [captions]\n\t        img2text[img_id] = []\n\t        for _ in captions:\n\t            img2text[img_id].append(text_id)\n\t            text2img[text_id] = img_id\n\t            text_id += 1\n", "    return img2text, text2img\n\t@torch.no_grad()\n\tdef retrieval_evaluation(\n\t        scores_i2t: np.ndarray, \n\t        scores_t2i: np.ndarray, \n\t        annotation: List[Dict[str, Any]],\n\t        topk: int = 10,\n\t    ):\n\t    img2text, text2img = construct_gts(annotation)\n\t    # Images->Text\n", "    ranks = np.zeros(scores_i2t.shape[0])\n\t    topk_inds_i2t = np.zeros((scores_i2t.shape[0], topk))\n\t    for index, score in enumerate(scores_i2t):\n\t        inds = np.argsort(score)[::-1]\n\t        # Score\n\t        rank = 1e20\n\t        for i in img2text[index]:\n\t            tmp = np.where(inds == i)[0][0]\n\t            if tmp < rank:\n\t                rank = tmp\n", "        ranks[index] = rank\n\t        topk_inds_i2t[index] = inds[:topk]\n\t    # Compute metrics\n\t    tr1 = 100.0 * len(np.where(ranks < 1)[0]) / len(ranks)\n\t    tr5 = 100.0 * len(np.where(ranks < 5)[0]) / len(ranks)\n\t    tr10 = 100.0 * len(np.where(ranks < 10)[0]) / len(ranks)\n\t    # Text->Images\n\t    ranks = np.zeros(scores_t2i.shape[0])\n\t    topk_inds_t2i = np.zeros((scores_t2i.shape[0], topk))\n\t    for index, score in enumerate(scores_t2i):\n", "        inds = np.argsort(score)[::-1]\n\t        ranks[index] = np.where(inds == text2img[index])[0][0]\n\t        topk_inds_t2i[index] = inds[:topk]\n\t    # Compute metrics\n\t    ir1 = 100.0 * len(np.where(ranks < 1)[0]) / len(ranks)\n\t    ir5 = 100.0 * len(np.where(ranks < 5)[0]) / len(ranks)\n\t    ir10 = 100.0 * len(np.where(ranks < 10)[0]) / len(ranks)\n\t    tr_mean = (tr1 + tr5 + tr10) / 3\n\t    ir_mean = (ir1 + ir5 + ir10) / 3\n\t    r_mean = (tr_mean + ir_mean) / 2\n", "    scores = {\n\t        'txt_r1': tr1,\n\t        'txt_r5': tr5,\n\t        'txt_r10': tr10,\n\t        'txt_r_mean': tr_mean,\n\t        'img_r1': ir1,\n\t        'img_r5': ir5,\n\t        'img_r10': ir10,\n\t        'img_r_mean': ir_mean,\n\t        'r_mean': r_mean\n", "    }\n\t    return scores, topk_inds_i2t, topk_inds_t2i\n\t@torch.no_grad()\n\tdef retrieval_evaluation_n_fold(\n\t        scores_i2t: np.ndarray, \n\t        scores_t2i: np.ndarray, \n\t        annotation: List[Dict[str, Any]],\n\t        n_fold: int = 5,\n\t    ):\n\t    n_fold_annotations = np.array_split(annotation, n_fold)\n", "    all_tr = [[], [], []]\n\t    all_ir = [[], [], []]\n\t    all_mean = [[], [], []]\n\t    i_begin, t_begin = 0, 0\n\t    for i in range(n_fold):\n\t        img2text, text2img = construct_gts(n_fold_annotations[i])\n\t        i_end = i_begin + len(img2text)\n\t        t_end = t_begin + len(text2img)\n\t        # Images->Text\n\t        ranks = np.zeros(len(img2text))\n", "        for index, score in enumerate(scores_i2t[i_begin:i_end, t_begin:t_end]):\n\t            inds = np.argsort(score)[::-1]\n\t            # Score\n\t            rank = 1e20\n\t            for i in img2text[index]:\n\t                tmp = np.where(inds == i)[0][0]\n\t                if tmp < rank:\n\t                    rank = tmp\n\t            ranks[index] = rank\n\t        # Compute metrics\n", "        tr1 = 100.0 * len(np.where(ranks < 1)[0]) / len(ranks)\n\t        tr5 = 100.0 * len(np.where(ranks < 5)[0]) / len(ranks)\n\t        tr10 = 100.0 * len(np.where(ranks < 10)[0]) / len(ranks)\n\t        all_tr[0].append(tr1)\n\t        all_tr[1].append(tr5)\n\t        all_tr[2].append(tr10)\n\t        # Text->Images\n\t        ranks = np.zeros(len(text2img))\n\t        for index, score in enumerate(scores_t2i[t_begin:t_end, i_begin:i_end]):\n\t            inds = np.argsort(score)[::-1]\n", "            ranks[index] = np.where(inds == text2img[index])[0][0]\n\t        # Compute metrics\n\t        ir1 = 100.0 * len(np.where(ranks < 1)[0]) / len(ranks)\n\t        ir5 = 100.0 * len(np.where(ranks < 5)[0]) / len(ranks)\n\t        ir10 = 100.0 * len(np.where(ranks < 10)[0]) / len(ranks)\n\t        all_ir[0].append(ir1)\n\t        all_ir[1].append(ir5)\n\t        all_ir[2].append(ir10)\n\t        tr_mean = (tr1 + tr5 + tr10) / 3\n\t        ir_mean = (ir1 + ir5 + ir10) / 3\n", "        r_mean = (tr_mean + ir_mean) / 2\n\t        all_mean[0].append(tr_mean)\n\t        all_mean[1].append(ir_mean)\n\t        all_mean[2].append(r_mean)\n\t        i_begin, t_begin = i_end, t_end\n\t    scores = {\n\t        f'{n_fold}fold_txt_r1': np.array(all_tr[0]).mean(),\n\t        f'{n_fold}fold_txt_r5': np.array(all_tr[1]).mean(),\n\t        f'{n_fold}fold_txt_r10': np.array(all_tr[2]).mean(),\n\t        f'{n_fold}fold_txt_r_mean': np.array(all_mean[0]).mean(),\n", "        f'{n_fold}fold_img_r1': np.array(all_ir[0]).mean(),\n\t        f'{n_fold}fold_img_r5': np.array(all_ir[1]).mean(),\n\t        f'{n_fold}fold_img_r10': np.array(all_ir[2]).mean(),\n\t        f'{n_fold}fold_img_r_mean': np.array(all_mean[1]).mean(),\n\t        f'{n_fold}fold_r_mean': np.array(all_mean[2]).mean()\n\t    }\n\t    return scores\n\tclass RetrievalEvaluator:\n\t    def __init__(self, \n\t            loader: DataLoader, \n", "            mode: str = 'val', \n\t            logger: logging.Logger = None, \n\t            monitor: str = 'r_mean',\n\t            with_epoch: bool = False, \n\t            with_steps: bool = False,\n\t            auto_save: bool = True,\n\t            n_fold: int = 1,\n\t        ):\n\t        super().__init__()\n\t        assert mode in ['val', 'test']\n", "        assert isinstance(loader.dataset, CaptionDatasetForRetrieval)\n\t        assert loader.dataset.clip_model is not None\n\t        self.loader = loader\n\t        self.mode = mode\n\t        self.logger = logger or global_logger\n\t        self.monitor = monitor\n\t        self.with_epoch = with_epoch\n\t        self.with_steps = with_steps\n\t        self.auto_save = auto_save\n\t        self.n_fold = n_fold\n", "    def log(self, msg):\n\t        self.logger.info(msg)\n\t    @torch.no_grad()\n\t    def __call__(self, \n\t            model: Union[Framework, ZeroNLG, str], \n\t            output_path: str = None, \n\t            epoch: int = -1, \n\t            steps: int = -1, \n\t            **kwargs,\n\t        ) -> float:\n", "        prefix = [self.mode]\n\t        if self.with_epoch:\n\t            prefix.append(f'epoch{epoch}')\n\t        if self.with_steps:\n\t            prefix.append(f'steps{steps}')\n\t        prefix = '_'.join(prefix)\n\t        if output_path:\n\t            result_i2t_file = os.path.join(output_path, f'{prefix}_i2t.npy')\n\t            result_t2i_file = os.path.join(output_path, f'{prefix}_t2i.npy')\n\t            scores_file = os.path.join(output_path, f'{prefix}_scores.json')\n", "        if type(model) is str:\n\t            zeronlg = ZeroNLG(model)\n\t        elif isinstance(model, Framework):\n\t            zeronlg = ZeroNLG(\n\t                multilingual_model=model,\n\t                device=model.device,\n\t                load_clip_model=False,\n\t            )\n\t        else:\n\t            assert isinstance(model, ZeroNLG)\n", "            zeronlg = model\n\t        all_image_embs, all_text_embs = [], []\n\t        for batch in tqdm(self.loader):\n\t            _, image_embs, texts = batch\n\t            image_embs = zeronlg.get_image_embeddings(\n\t                image_embs=image_embs,\n\t                normalize=True,\n\t                mean_pooling=True, # TODO: we now always apply mean pooling\n\t            )\n\t            text_embs = zeronlg.get_text_embeddings(\n", "                texts=texts,\n\t                normalize=True,\n\t                batch_size=image_embs.size(0),\n\t            )\n\t            all_image_embs.append(image_embs)\n\t            all_text_embs.append(text_embs)\n\t        all_image_embs = torch.cat(all_image_embs, dim=0)\n\t        all_text_embs = torch.cat(all_text_embs, dim=0)\n\t        scores_i2t = all_image_embs @ all_text_embs.t()\n\t        scores_t2i = all_text_embs @ all_image_embs.t()\n", "        scores, topk_inds_i2t, topk_inds_t2i = retrieval_evaluation(\n\t            scores_i2t=scores_i2t.cpu().numpy(),\n\t            scores_t2i=scores_t2i.cpu().numpy(),\n\t            annotation=self.loader.dataset.annotation,\n\t        )\n\t        if self.n_fold > 1:\n\t            # MSCOCO 1K test\n\t            scores.update(\n\t                retrieval_evaluation_n_fold(\n\t                    scores_i2t=scores_i2t.cpu().numpy(),\n", "                    scores_t2i=scores_t2i.cpu().numpy(),\n\t                    annotation=self.loader.dataset.annotation,\n\t                    n_fold=self.n_fold,\n\t                )\n\t            )\n\t        for k, v in scores.items():\n\t            self.log(f'[{prefix}] {k} {v}')\n\t        if output_path:\n\t            self.log(f'Save results to {result_i2t_file}, {result_t2i_file}')\n\t            np.save(result_i2t_file, topk_inds_i2t)\n", "            np.save(result_t2i_file, topk_inds_t2i)\n\t            self.log(f'Save scores to {scores_file}')\n\t            json.dump(scores, open(scores_file, 'w'))\n\t        if self.auto_save:\n\t            self.loader.dataset.save_pickle()\n\t        score = scores[self.monitor]\n\t        return score\n"]}
{"filename": "zeronlg/evaluation/__init__.py", "chunked_list": ["from .CaptionEvaluator import CaptionEvaluator\n\tfrom .TranslateEvaluator import TranslateEvaluator\n\tfrom .RetrievalEvaluator import RetrievalEvaluator"]}
{"filename": "zeronlg/evaluation/TranslateEvaluator.py", "chunked_list": ["import os\n\timport json\n\timport torch\n\timport logging\n\tfrom tqdm import tqdm\n\tfrom torch.utils.data import DataLoader\n\tfrom sentence_transformers import LoggingHandler\n\tfrom typing import Dict, Any, Union\n\tfrom .. import Framework, ZeroNLG\n\tfrom ..datasets import TranslateDataset\n", "from ..utils import translate_eval\n\tlogging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tglobal_logger = logging.getLogger(__name__)\n\tclass TranslateEvaluator:\n\t    def __init__(self, \n\t            loader: DataLoader, \n\t            evaluation_settings: Dict[str, Any] = {'lang': 'en'}, \n", "            mode: str = 'val', \n\t            logger: logging.Logger = None, \n\t            monitor: str = 'BLEU', \n\t            with_epoch: bool = False, \n\t            with_steps: bool = False,\n\t        ):\n\t        super().__init__()\n\t        assert mode in ['val', 'test']\n\t        assert isinstance(loader.dataset, TranslateDataset)\n\t        self.loader = loader\n", "        self.evaluation_settings = evaluation_settings\n\t        self.mode = mode\n\t        self.logger = logger or global_logger\n\t        self.monitor = monitor\n\t        self.with_epoch = with_epoch\n\t        self.with_steps = with_steps\n\t    def log(self, msg):\n\t        self.logger.info(msg)\n\t    @torch.no_grad()\n\t    def __call__(self, \n", "            model: Union[Framework, ZeroNLG], \n\t            output_path: str = None, \n\t            epoch: int = -1, \n\t            steps: int = -1, \n\t            no_score: bool=False, \n\t            print_sent: bool=False\n\t        ) -> float:\n\t        prefix = [self.mode]\n\t        if self.with_epoch:\n\t            prefix.append(f'epoch{epoch}')\n", "        if self.with_steps:\n\t            prefix.append(f'steps{steps}')\n\t        prefix = '_'.join(prefix)\n\t        source = self.loader.dataset.source_language\n\t        target = self.loader.dataset.target_language\n\t        self.evaluation_settings['lang'] = target\n\t        if output_path:\n\t            result_file = os.path.join(output_path, f'{prefix}_translations_{source}-{target}.json')\n\t            scores_file = os.path.join(output_path, f'{prefix}_scores_{source}-{target}.json')\n\t        if isinstance(model, Framework):\n", "            zeronlg = ZeroNLG(\n\t                multilingual_model=model,\n\t                device=model.device,\n\t                load_clip_model=False,\n\t            )\n\t        else:\n\t            assert isinstance(model, ZeroNLG)\n\t            zeronlg = model\n\t        results, gts = [], []\n\t        for batch in tqdm(self.loader):\n", "            source_sentences, target_sentences = batch\n\t            outputs = zeronlg.forward_translate(\n\t                texts=source_sentences,\n\t                **self.evaluation_settings,\n\t            )\n\t            results.extend(outputs)\n\t            gts.extend(target_sentences)\n\t            if print_sent:\n\t                for src, trg, pred in zip(source_sentences, target_sentences, outputs):\n\t                    print(f'[SRC] {src}; [TRG] {trg}; [PRED] {pred}')\n", "        if output_path:\n\t            self.log(f'Save translation results to {result_file}')\n\t            json.dump(results, open(result_file, 'w'))\n\t        if not no_score:\n\t            scores = translate_eval(gts=gts, res=results, eval_lang=target)\n\t            if output_path:\n\t                self.log(f'Save scores to {scores_file}')\n\t                json.dump(scores, open(scores_file, 'w'))\n\t            for k, v in scores.items():\n\t                self.log(f'[{prefix}] [{source} -> {target}] {k} {v}')\n", "            score = scores[self.monitor]\n\t            return score\n"]}
{"filename": "zeronlg/utils/metriclogger.py", "chunked_list": ["import time\n\timport datetime\n\timport numpy as np\n\timport torch\n\timport torch.distributed as dist\n\tfrom collections import defaultdict, deque\n\tfrom .distributed import is_dist_avail_and_initialized\n\tclass SmoothedValue(object):\n\t    \"\"\"Track a series of values and provide access to smoothed values over a\n\t    window or the global series average.\n", "    \"\"\"\n\t    def __init__(self, window_size=20, fmt=None):\n\t        if fmt is None:\n\t            fmt = \"{median:.4f} ({global_avg:.4f})\"\n\t        self.deque = deque(maxlen=window_size)\n\t        self.total = 0.0\n\t        self.count = 0\n\t        self.fmt = fmt\n\t    def update(self, value, n=1):\n\t        if np.isnan(value):\n", "            # There occurs gradient overflow in apex.amp\n\t            return\n\t        self.deque.append(value)\n\t        self.count += n\n\t        self.total += value * n\n\t    def synchronize_between_processes(self):\n\t        \"\"\"\n\t        Warning: does not synchronize the deque!\n\t        \"\"\"\n\t        if not is_dist_avail_and_initialized():\n", "            return\n\t        t = torch.tensor([self.count, self.total], dtype=torch.float64, device='cuda')\n\t        dist.barrier()\n\t        dist.all_reduce(t)\n\t        t = t.tolist()\n\t        self.count = int(t[0])\n\t        self.total = t[1]\n\t    @property\n\t    def median(self):\n\t        if len(self.deque) == 0:\n", "            return 0\n\t        d = torch.tensor(list(self.deque))\n\t        return d.median().item()\n\t    @property\n\t    def avg(self):\n\t        if len(self.deque) == 0:\n\t            return 0\n\t        d = torch.tensor(list(self.deque), dtype=torch.float32)\n\t        return d.mean().item()\n\t    @property\n", "    def global_avg(self):\n\t        if self.count == 0:\n\t            return 0\n\t        return self.total / self.count\n\t    @property\n\t    def max(self):\n\t        if len(self.deque) == 0:\n\t            return 0\n\t        return max(self.deque)\n\t    @property\n", "    def value(self):\n\t        if len(self.deque) == 0:\n\t            return 0\n\t        return self.deque[-1]\n\t    def __str__(self):\n\t        return self.fmt.format(\n\t            median=self.median,\n\t            avg=self.avg,\n\t            global_avg=self.global_avg,\n\t            max=self.max,\n", "            value=self.value)\n\tclass MetricLogger(object):\n\t    def __init__(self, delimiter=\"\\t\", window_size=1, fmt='{value:.4f}'):\n\t        self.meters = defaultdict(SmoothedValue)\n\t        self.delimiter = delimiter\n\t        self.window_size = window_size\n\t        self.fmt = fmt\n\t    def update(self, **kwargs):\n\t        for k, v in kwargs.items():\n\t            if k not in self.meters:\n", "                self.add_meter(k, SmoothedValue(window_size=self.window_size, fmt=self.fmt))\n\t            if isinstance(v, torch.Tensor):\n\t                v = v.item()\n\t            assert isinstance(v, (float, int))\n\t            self.meters[k].update(v)\n\t    def __getattr__(self, attr):\n\t        if attr in self.meters:\n\t            return self.meters[attr]\n\t        if attr in self.__dict__:\n\t            return self.__dict__[attr]\n", "        raise AttributeError(\"'{}' object has no attribute '{}'\".format(\n\t            type(self).__name__, attr))\n\t    def __str__(self):\n\t        loss_str = []\n\t        for name, meter in self.meters.items():\n\t            loss_str.append(\n\t                \"{}: {}\".format(name, str(meter))\n\t            )\n\t        return self.delimiter.join(loss_str)\n\t    def global_avg(self):\n", "        loss_str = []\n\t        for name, meter in self.meters.items():\n\t            loss_str.append(\n\t                \"{}: {:.4f}\".format(name, meter.global_avg)\n\t            )\n\t        return self.delimiter.join(loss_str)\n\t    def synchronize_between_processes(self):\n\t        for meter in self.meters.values():\n\t            meter.synchronize_between_processes()\n\t    def add_meter(self, name, meter):\n", "        self.meters[name] = meter\n\t    def log_every(self, loader, print_freq, header=None):\n\t        if not header:\n\t            header = ''\n\t        dataset_len = len(loader)\n\t        start_time = time.time()\n\t        end = time.time()\n\t        iter_time = SmoothedValue(fmt='{avg:.4f}')\n\t        data_time = SmoothedValue(fmt='{avg:.4f}')\n\t        space_fmt = ':' + str(len(str(dataset_len))) + 'd'\n", "        _msg = [\n\t            '[{0' + space_fmt + '}/{1}]',\n\t            'eta: {eta}',\n\t            '{meters}',\n\t            'time: {time}',\n\t            'data: {data}'\n\t        ]\n\t        if torch.cuda.is_available():\n\t            _msg.append('max mem: {memory:.0f}')\n\t        _msg = self.delimiter.join(_msg)\n", "        MB = 1024.0 * 1024.0\n\t        iterable = iter(loader)\n\t        total_train_steps = dataset_len\n\t        start_step = 0\n\t        for i in range(start_step, total_train_steps):\n\t            obj = next(iterable)\n\t            data_time.update(time.time() - end)\n\t            yield obj\n\t            iter_time.update(time.time() - end)\n\t            log_msg = header + \" \" + _msg\n", "            if (i % dataset_len) % print_freq == 0 or i == dataset_len - 1:\n\t                eta_seconds = iter_time.global_avg * (dataset_len - i % dataset_len)\n\t                eta_string = str(datetime.timedelta(seconds=int(eta_seconds)))\n\t                if torch.cuda.is_available():\n\t                    print(log_msg.format(\n\t                        i % dataset_len, dataset_len, eta=eta_string,\n\t                        meters=str(self),\n\t                        time=str(iter_time), data=str(data_time),\n\t                        memory=torch.cuda.max_memory_allocated() / MB))\n\t                else:\n", "                    print(log_msg.format(\n\t                        i % dataset_len, dataset_len, eta=eta_string,\n\t                        meters=str(self),\n\t                        time=str(iter_time), data=str(data_time)))\n\t            end = time.time()\n\t        total_time = time.time() - start_time\n\t        total_time_str = str(datetime.timedelta(seconds=int(total_time)))\n\t        print('{} Total time: {} ({:.4f} s / it)'.format(\n\t            header, total_time_str, total_time / dataset_len))\n"]}
{"filename": "zeronlg/utils/op_vision.py", "chunked_list": ["import requests\n\timport numpy as np\n\tfrom PIL import Image\n\tfrom typing import List, Tuple, Union\n\tdef get_uniform_frame_ids(\n\t        num_total_frames: int, \n\t        num_frames: int,\n\t    ) -> List[int]:\n\t    if num_total_frames <= num_frames:\n\t        frame_ids = [_ for _ in range(num_total_frames)]\n", "        frame_ids = frame_ids + [frame_ids[-1]] * (num_frames - num_total_frames)\n\t        return frame_ids\n\t    # there will be num_frames intervals\n\t    ids = np.linspace(0, num_total_frames, num_frames + 1)\n\t    frame_ids = []\n\t    for i in range(num_frames):\n\t        # get the middle frame index of each interval\n\t        frame_ids.append(round((ids[i] + ids[i+1]) / 2))\n\t    return frame_ids\n\tdef process_images(\n", "        images: Union[str, List[str], Image.Image, List[Image.Image], List[List[Image.Image]]], \n\t        num_frames: int = 8\n\t    ) -> Tuple[List[Image.Image], bool, int, int]:\n\t    images = [images] if not isinstance(images, list) else images\n\t    batch_size = len(images)\n\t    num_images_per_input, is_video = None, False\n\t    if type(images[0]) is str:\n\t        if images[0].startswith(\"http://\") or images[0].startswith(\"https://\"):\n\t            # load images from remote URLs\n\t            images = [Image.open(requests.get(item, stream=True).raw) for item in images]\n", "        elif images[0].endswith('.mp4') or images[0].endswith('.avi'):\n\t            # load local videos\n\t            import decord\n\t            is_video = True\n\t            frames = []\n\t            for item in images:\n\t                reader = decord.VideoReader(item)\n\t                this_frames = reader.get_batch(get_uniform_frame_ids(len(reader), num_frames)).asnumpy()\n\t                this_frames = [Image.fromarray(frame) for frame in this_frames]\n\t                frames.extend(this_frames)\n", "            images = frames\n\t        else:\n\t            # load local images\n\t            images = [Image.open(item) for item in images]\n\t    elif isinstance(images[0], list):\n\t        assert isinstance(images[0][0], Image.Image), type(images[0][0])\n\t        num_images_per_input = len(images[0])\n\t        is_video = num_images_per_input > 1\n\t        images = [images[i][j] for i in range(len(images)) for j in range(num_images_per_input)]\n\t    else:\n", "        assert isinstance(images[0], Image.Image), type(images[0])\n\t    return images, is_video, num_images_per_input or num_frames, batch_size\n"]}
{"filename": "zeronlg/utils/distributed.py", "chunked_list": ["import os\n\timport torch\n\timport torch.distributed as dist\n\tdef setup_for_distributed(is_master):\n\t    \"\"\"\n\t    This function disables printing when not in master process\n\t    \"\"\"\n\t    import builtins as __builtin__\n\t    builtin_print = __builtin__.print\n\t    def print(*args, **kwargs):\n", "        force = kwargs.pop('force', False)\n\t        if is_master or force:\n\t            builtin_print(*args, **kwargs)\n\t    __builtin__.print = print\n\tdef is_dist_avail_and_initialized():\n\t    if not dist.is_available():\n\t        return False\n\t    if not dist.is_initialized():\n\t        return False\n\t    return True\n", "def get_world_size():\n\t    if not is_dist_avail_and_initialized():\n\t        return 1\n\t    return dist.get_world_size()\n\tdef get_rank():\n\t    if not is_dist_avail_and_initialized():\n\t        return 0\n\t    return dist.get_rank()\n\tdef is_main_process():\n\t    return get_rank() == 0\n", "def save_on_master(*args, **kwargs):\n\t    if is_main_process():\n\t        torch.save(*args, **kwargs)\n\tdef init_distributed_mode(args):\n\t    if 'RANK' in os.environ and 'WORLD_SIZE' in os.environ:\n\t        args.rank = int(os.environ[\"RANK\"])\n\t        args.world_size = int(os.environ['WORLD_SIZE'])\n\t        args.gpu = int(os.environ['LOCAL_RANK'])\n\t    elif 'SLURM_PROCID' in os.environ:\n\t        args.rank = int(os.environ['SLURM_PROCID'])\n", "        args.gpu = args.rank % torch.cuda.device_count()\n\t    else:\n\t        print('Not using distributed mode')\n\t        args.distributed = False\n\t        return\n\t    args.distributed = True\n\t    torch.cuda.set_device(args.gpu)\n\t    args.dist_backend = 'nccl'\n\t    print('| distributed init (rank {}): {}'.format(\n\t        args.rank, args.dist_url), flush=True)\n", "    torch.distributed.init_process_group(backend=args.dist_backend, init_method=args.dist_url,\n\t                                         world_size=args.world_size, rank=args.rank)\n\t    torch.distributed.barrier()\n\t    setup_for_distributed(args.rank == 0)\n"]}
{"filename": "zeronlg/utils/op_text.py", "chunked_list": ["import requests\n\timport torch\n\tfrom torch import Tensor\n\tfrom PIL import Image\n\tfrom typing import List, Tuple, Union, Dict\n\tdef random_masking_(\n\t        tokenizer,\n\t        tokenized_results: Dict[str, Tensor],\n\t        mask_prob: float = 0.15,\n\t        replace_prob: float = 0.8,\n", "        random_prob: float = 0.1, \n\t    ):\n\t    \"\"\"\n\t    in-place operation to randomlly mask the input ids of tokenized results\n\t    :param tokenized_results: Obtained by tokenzier\n\t    :param mask_prob: Probability to mask a token\n\t    :param replace_prob: Probability to replace masked token with [MASK]\n\t    :param random_prob: Probability to replace masked token with a random token\n\t    \"\"\"\n\t    if len(tokenized_results) == 0:\n", "        return\n\t    input_ids = tokenized_results['input_ids']\n\t    special_tokens_mask = [tokenizer.get_special_tokens_mask(ids.tolist(), already_has_special_tokens=True) for ids in input_ids]\n\t    special_tokens_mask = torch.tensor(special_tokens_mask, dtype=torch.bool)\n\t    probability_matrix = torch.full(input_ids.shape, mask_prob)\n\t    probability_matrix.masked_fill_(special_tokens_mask, value=0.0)\n\t    masked_indices = torch.bernoulli(probability_matrix).bool()\n\t    # 80% of the time, we replace masked input tokens with tokenizer.mask_token ([MASK])\n\t    indices_replaced = torch.bernoulli(torch.full(input_ids.shape, replace_prob)).bool() & masked_indices\n\t    input_ids[indices_replaced] = tokenizer.mask_token_id\n", "    # 10% of the time, we replace masked input tokens with random word\n\t    current_prob = random_prob / (1 - replace_prob)\n\t    indices_random = torch.bernoulli(torch.full(input_ids.shape, current_prob)).bool() & masked_indices & ~indices_replaced\n\t    random_words = torch.randint(len(tokenizer), input_ids.shape, dtype=torch.long)\n\t    input_ids[indices_random] = random_words[indices_random]\n"]}
{"filename": "zeronlg/utils/__init__.py", "chunked_list": ["from .eval import coco_caption_eval, translate_eval\n\tfrom .metriclogger import MetricLogger\n\tfrom .op_text import random_masking_\n\tfrom .op_vision import get_uniform_frame_ids, process_images\n\tfrom .io import get_cache_folder, get_formatted_string\n"]}
{"filename": "zeronlg/utils/eval.py", "chunked_list": ["import os\n\timport re\n\timport jieba\n\timport string\n\timport logging\n\timport subprocess\n\timport requests\n\timport wget\n\timport psutil\n\timport time\n", "import json\n\timport socket\n\timport glob\n\timport sys\n\ttry:\n\t    from urlparse import urlparse\n\texcept ImportError:\n\t    from urllib.parse import urlparse\n\tfrom stanfordcorenlp import StanfordCoreNLP\n\tfrom pycocotools.coco import COCO\n", "from pycocoevalcap.eval import COCOEvalCap\n\tfrom pycocoevalcap.bleu.bleu import Bleu\n\tfrom pycocoevalcap.meteor.meteor import Meteor\n\tfrom pycocoevalcap.rouge.rouge import Rouge\n\tfrom pycocoevalcap.cider.cider import Cider\n\tfrom pycocoevalcap.spice.spice import Spice\n\tfrom transformers.models.bert.tokenization_bert import BasicTokenizer\n\tfrom typing import Dict\n\tfrom .io import get_cache_folder\n\tCORENLP = 'stanford-corenlp-4.5.2'\n", "class MyStanfordCoreNLP(StanfordCoreNLP):\n\t    def __init__(self, path_or_host, port=9000, memory='4g', lang='en', timeout=1500, quiet=True,\n\t                 logging_level=logging.WARNING, auto_download=True):\n\t        self.port = port\n\t        self.memory = memory\n\t        self.lang = lang\n\t        self.timeout = timeout\n\t        self.quiet = quiet\n\t        self.logging_level = logging_level\n\t        logging.basicConfig(level=self.logging_level)\n", "        # Check args\n\t        self._check_args()\n\t        if path_or_host.startswith('http'):\n\t            self.url = path_or_host + ':' + str(port)\n\t            self.path_or_host = path_or_host\n\t            logging.info('Using an existing server {}'.format(self.url))\n\t        else:\n\t            self.path_or_host = os.path.join(path_or_host, CORENLP)\n\t            # Check Java\n\t            if not subprocess.call(['java', '-version'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT) == 0:\n", "                raise RuntimeError('Java not found.')\n\t            # Check if the dir exists\n\t            if not os.path.isdir(self.path_or_host):\n\t                if auto_download:\n\t                    try:\n\t                        logging.info(f'Downloading {CORENLP} to {self.path_or_host} ...')\n\t                        zip, jars = None, []\n\t                        for url in [\n\t                            f'https://nlp.stanford.edu/software/{CORENLP}.zip',\n\t                            f'https://nlp.stanford.edu/software/{CORENLP}-models-german.jar',\n", "                            f'https://nlp.stanford.edu/software/{CORENLP}-models-french.jar',\n\t                        ]:\n\t                            fn = url.split('/')[-1]\n\t                            if fn.endswith('.jar'):\n\t                                jars.append(fn)\n\t                            else:\n\t                                assert zip is None\n\t                                assert fn.endswith('.zip')\n\t                                zip = fn\n\t                            wget.download(url, fn)\n", "                        root = os.path.dirname(self.path_or_host)\n\t                        os.system(f'mkdir -p {root}')\n\t                        os.system(f'unzip {zip} -d {root}')\n\t                        for jar in jars:\n\t                            os.system(f'mv {jar} {os.path.join(root, zip.replace(\".zip\", \"\"))}')\n\t                        os.system(f'rm {zip}')\n\t                    except:\n\t                        raise ConnectionError('can not automatically download corenlp-4.5.2')\n\t                else:\n\t                    raise IOError(str(self.path_or_host) + ' is not a directory.')\n", "            directory = os.path.normpath(self.path_or_host) + os.sep\n\t            self.class_path_dir = directory\n\t            # Check if the language specific model file exists\n\t            # We rewrite the file format compaired with the implementation in 3.9.1.1\n\t            switcher = {\n\t                'en': 'stanford-corenlp-[0-9].[0-9].[0-9]-models.jar',\n\t                'zh': 'stanford-corenlp-[0-9].[0-9].[0-9]-models-chinese.jar',\n\t                'ar': 'stanford-corenlp-[0-9].[0-9].[0-9]-models-arabic.jar',\n\t                'fr': 'stanford-corenlp-[0-9].[0-9].[0-9]-models-french.jar',\n\t                'de': 'stanford-corenlp-[0-9].[0-9].[0-9]-models-german.jar',\n", "                'es': 'stanford-corenlp-[0-9].[0-9].[0-9]-models-spanish.jar',\n\t            }\n\t            jars = {\n\t                'en': 'stanford-corenlp-x.x.x-models.jar',\n\t                'zh': 'stanford-corenlp-x.x.x-models-chinese.jar',\n\t                'ar': 'stanford-corenlp-x.x.x-models-arabic.jar',\n\t                'fr': 'stanford-corenlp-x.x.x-models-french.jar',\n\t                'de': 'stanford-corenlp-x.x.x-models-german.jar',\n\t                'es': 'stanford-corenlp-x.x.x-models-spanish.jar',\n\t            }\n", "            if len(glob.glob(directory + switcher.get(self.lang))) <= 0:\n\t                raise IOError(jars.get(\n\t                    self.lang) + ' not exists. You should download and place it in the ' + directory + ' first.')\n\t            # We disable port checking because it will raise an error when running on Mac\n\t            # # If port not set, auto select\n\t            # if self.port is None:\n\t            #     for port_candidate in range(9000, 65535):\n\t            #         if port_candidate not in [conn.laddr[1] for conn in psutil.net_connections()]:\n\t            #             self.port = port_candidate\n\t            #             break\n", "            # # Check if the port is in use\n\t            # if self.port in [conn.laddr[1] for conn in psutil.net_connections()]:\n\t            #     raise IOError('Port ' + str(self.port) + ' is already in use.')\n\t            # Start native server\n\t            logging.info('Initializing native server...')\n\t            cmd = \"java\"\n\t            java_args = \"-Xmx{}\".format(self.memory)\n\t            java_class = \"edu.stanford.nlp.pipeline.StanfordCoreNLPServer\"\n\t            class_path = '\"{}*\"'.format(directory)\n\t            args = [cmd, java_args, '-cp', class_path, java_class, '-port', str(self.port)]\n", "            args = ' '.join(args)\n\t            logging.info(args)\n\t            # Silence\n\t            with open(os.devnull, 'w') as null_file:\n\t                out_file = None\n\t                if self.quiet:\n\t                    out_file = null_file\n\t                self.p = subprocess.Popen(args, shell=True, stdout=out_file, stderr=subprocess.STDOUT)\n\t                logging.info('Server shell PID: {}'.format(self.p.pid))\n\t            self.url = 'http://localhost:' + str(self.port)\n", "        # Wait until server starts\n\t        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t        host_name = urlparse(self.url).hostname\n\t        time.sleep(1)  # OSX, not tested\n\t        while sock.connect_ex((host_name, self.port)):\n\t            logging.info('Waiting until the server is available.')\n\t            time.sleep(1)\n\t        logging.info('The server is available.')\n\t    def _request(self, annotators=None, data=None, *args, **kwargs):\n\t        if sys.version_info.major >= 3:\n", "            data = data.encode('utf-8')\n\t        properties = {'annotators': annotators, 'outputFormat': 'json'}\n\t        params = {'properties': str(properties), 'pipelineLanguage': self.lang}\n\t        if 'pattern' in kwargs:\n\t            params = {\"pattern\": kwargs['pattern'], 'properties': str(properties), 'pipelineLanguage': self.lang}\n\t        # logging.info(params)\n\t        r = requests.post(self.url, params=params, data=data, headers={'Connection': 'close'})\n\t        r_dict = json.loads(r.text)\n\t        return r_dict\n\tzh_punctuation = \"\\【.*?】+|\\《.*?》+|\\#.*?#+|[.!/_,$&%^*()<>+\"\"'?@|:~{}#]+|[——！\\，。=？、：“”‘’￥……()《》【】～]\"\n", "def tokenize_zh_sentence(text:str):\n\t    text = ' '.join(jieba.cut(text))\n\t    text = re.sub(zh_punctuation, '', text).strip()\n\t    text = re.sub(r\"\\s{2,}\", ' ', text)\n\t    return text\n\tdef tokenize_sentence(text: str, nlp: MyStanfordCoreNLP=None, punctuation=string.punctuation, do_lower_case=True):\n\t    if nlp is None:\n\t        tokenizer = BasicTokenizer(strip_accents=False, do_lower_case=do_lower_case)\n\t        tokens = tokenizer.tokenize(text)\n\t    else:\n", "        if do_lower_case:\n\t            text = text.lower()\n\t        tokens = [token for token in nlp.word_tokenize(text) if token not in punctuation]\n\t    return ' '.join(tokens)\n\tclass MyCOCOEvalCap(COCOEvalCap):\n\t    def __init__(self, coco, cocoRes, lang='zh', cache_folder=get_cache_folder()):\n\t        super().__init__(coco, cocoRes)\n\t        self.lang = lang\n\t        if self.lang != 'zh':\n\t            self.nlp = MyStanfordCoreNLP(cache_folder, lang=lang)\n", "    def evaluate(self):\n\t        imgIds = self.params['image_id']\n\t        # imgIds = self.coco.getImgIds()\n\t        gts = {}\n\t        res = {}\n\t        for imgId in imgIds:\n\t            if self.lang == 'zh':\n\t                gts[imgId] = [tokenize_zh_sentence(item['caption']) for item in self.coco.imgToAnns[imgId]]\n\t                res[imgId] = [tokenize_zh_sentence(''.join(item['caption'].split(' '))) for item in self.cocoRes.imgToAnns[imgId]]\n\t            else:\n", "                gts[imgId] = [tokenize_sentence(item['caption'], self.nlp) for item in self.coco.imgToAnns[imgId]]\n\t                res[imgId] = [tokenize_sentence(item['caption'], self.nlp) for item in self.cocoRes.imgToAnns[imgId]]\n\t        # =================================================\n\t        # Set up scorers\n\t        # =================================================\n\t        print('setting up scorers...')\n\t        scorers = [\n\t            (Bleu(4), [\"Bleu_1\", \"Bleu_2\", \"Bleu_3\", \"Bleu_4\"]),\n\t            (Meteor(),\"METEOR\"),\n\t            (Rouge(), \"ROUGE_L\"),\n", "            (Cider(), \"CIDEr\"),\n\t            # (Spice(), \"SPICE\") \n\t            # SPICE will call English-related tokenizer and NER, so we don't evaluate it on other language.\n\t        ]\n\t        # =================================================\n\t        # Compute scores\n\t        # =================================================\n\t        for scorer, method in scorers:\n\t            print('computing %s score...'%(scorer.method()))\n\t            score, scores = scorer.compute_score(gts, res)\n", "            if type(method) == list:\n\t                for sc, scs, m in zip(score, scores, method):\n\t                    self.setEval(sc, m)\n\t                    self.setImgToEvalImgs(scs, gts.keys(), m)\n\t                    print(\"%s: %0.3f\"%(m, sc))\n\t            else:\n\t                self.setEval(score, method)\n\t                self.setImgToEvalImgs(scores, gts.keys(), method)\n\t                print(\"%s: %0.3f\"%(method, score))\n\t        self.setEvalImgs()\n", "def coco_caption_eval(annotation_file, results_file, eval_lang='en', cache_folder=get_cache_folder()):\n\t    assert os.path.exists(annotation_file)\n\t    # create coco object and coco_result object\n\t    coco = COCO(annotation_file)\n\t    coco_result = coco.loadRes(results_file)\n\t    if eval_lang == 'en':\n\t        # we keep using the original evaluation toolkit for visual captioning in English\n\t        coco_eval = COCOEvalCap(coco, coco_result)\n\t    else:\n\t        coco_eval = MyCOCOEvalCap(coco, coco_result, eval_lang, cache_folder=cache_folder)\n", "    # evaluate results\n\t    # SPICE will take a few minutes the first time, but speeds up due to caching\n\t    coco_eval.evaluate()\n\t    # print output evaluation scores\n\t    for metric, score in coco_eval.eval.items():\n\t        print(f'{metric}: {score:.3f}', flush=True)\n\t    return coco_eval\n\tdef translate_eval(gts, res, eval_lang='en', cache_folder=get_cache_folder()) -> Dict[str, float]:\n\t    assert isinstance(gts, (list, tuple))\n\t    assert isinstance(res, (list, tuple))\n", "    assert len(gts) == len(res)\n\t    if eval_lang == 'zh':\n\t        gts = [[tokenize_zh_sentence(item).split()] for item in gts]\n\t        res = [tokenize_zh_sentence(''.join(item.split())).split() for item in res]\n\t    else:\n\t        nlp = MyStanfordCoreNLP(cache_folder, lang=eval_lang)\n\t        gts = [[tokenize_sentence(item, nlp).split()] for item in gts]\n\t        res = [tokenize_sentence(item, nlp).split() for item in res]\n\t    from nltk.translate.bleu_score import corpus_bleu, SmoothingFunction\n\t    score = corpus_bleu(gts, res, smoothing_function=SmoothingFunction().method1)\n", "    return {\n\t        'BLEU': score,\n\t    }\n"]}
{"filename": "zeronlg/utils/io.py", "chunked_list": ["import os\n\timport json\n\timport torch.distributed as dist\n\tfrom .distributed import (\n\t    is_dist_avail_and_initialized, \n\t    is_main_process, \n\t    get_rank, \n\t    get_world_size,\n\t)\n\tdef read_json(rpath: str):\n", "    result = []\n\t    with open(rpath, 'rt') as f:\n\t        for line in f:\n\t            result.append(json.loads(line.strip()))\n\t    return result\n\tdef write_json(result: list, wpath: str):\n\t    with open(wpath, 'wt') as f:\n\t        for res in result:\n\t            f.write(json.dumps(res) + '\\n')\n\tdef collect_result(result, filename, local_wdir, save_result=False, remove_duplicate='', do_not_collect=False):\n", "    assert isinstance(result, list)\n\t    write_json(result, os.path.join(local_wdir,'%s_rank%d.json' % (filename, get_rank())))\n\t    if is_dist_avail_and_initialized():\n\t        dist.barrier()\n\t    if do_not_collect:\n\t        return None\n\t    result = []\n\t    final_result_file = ''\n\t    if is_main_process():\n\t        # combine results from all processes\n", "        for rank in range(get_world_size()):\n\t            result += read_json(os.path.join(local_wdir, '%s_rank%d.json' % (filename, rank)))\n\t        if remove_duplicate:  # for evaluating captioning tasks\n\t            result_new = []\n\t            id_list = set()\n\t            for res in result:\n\t                if res[remove_duplicate] not in id_list:\n\t                    id_list.add(res[remove_duplicate])\n\t                    result_new.append(res)\n\t            result = result_new\n", "        if save_result:\n\t            final_result_file = os.path.join(local_wdir, '%s.json' % filename)\n\t            json.dump(result, open(final_result_file, 'w'), indent=4)\n\t            print('result file saved to %s' % final_result_file)\n\t    if is_dist_avail_and_initialized():\n\t        dist.barrier()\n\t    return final_result_file if save_result else result\n\tdef get_cache_folder(cache_folder: str=None):\n\t    if cache_folder is None:\n\t        cache_folder = os.getenv('ZERONLG_HOME')\n", "        if cache_folder is None:\n\t            try:\n\t                from torch.hub import _get_torch_home\n\t                torch_cache_home = _get_torch_home()\n\t            except ImportError:\n\t                torch_cache_home = os.path.expanduser(os.getenv('TORCH_HOME', os.path.join(os.getenv('XDG_CACHE_HOME', '~/.cache'), 'torch')))\n\t            cache_folder = os.path.join(torch_cache_home, 'zeronlg')\n\t    return cache_folder\n\tdef get_formatted_string(kwargs, key, assigned_keys=None, assigned_kwargs=None, format_key=None) -> str:\n\t    if format_key is None:\n", "        format_key = f'{key}_format'\n\t    if kwargs.get(key, None) is None:\n\t        assert format_key in kwargs\n\t        if assigned_kwargs is None:\n\t            assert assigned_keys is not None\n\t            assigned_kwargs = {k: kwargs[k] for k in assigned_keys}\n\t        return kwargs[format_key].format(**assigned_kwargs)\n\t    return kwargs[key]\n"]}
{"filename": "zeronlg/models/Transformer.py", "chunked_list": ["import os\n\timport json\n\tfrom torch import nn\n\tfrom transformers import AutoModel, AutoTokenizer, AutoConfig, T5Config\n\tfrom typing import List, Dict, Optional, Union, Tuple\n\tfrom sentence_transformers.util import snapshot_download\n\tfrom ..utils import get_cache_folder\n\tfrom .. import __LIBRARY_NAME__, __version__\n\t# Derived from sentence_transformers.models.Transformer\n\t# (https://github.com/UKPLab/sentence-transformers/blob/master/sentence_transformers/models/Transformer.py)\n", "class Transformer(nn.Module):\n\t    \"\"\"Huggingface AutoModel to generate token embeddings.\n\t    Loads the correct class, e.g. BERT / RoBERTa etc.\n\t    :param model_name_or_path: Huggingface models name (https://huggingface.co/models)\n\t    :param max_seq_length: Truncate any inputs longer than max_seq_length\n\t    :param model_args: Arguments (key, value pairs) passed to the Huggingface Transformers model\n\t    :param cache_folder: Cache folder to store/load HuggingFace transformers models\n\t    :param tokenizer_args: Arguments (key, value pairs) passed to the Huggingface Tokenizer model\n\t    :param do_lower_case: If true, lowercases the input (independent if the model is cased or not)\n\t    :param tokenizer_name_or_path: Name or path of the tokenizer. When None, then model_name_or_path is used\n", "    :param use_auth_token: HuggingFace authentication token to download private models.\n\t    \"\"\"\n\t    def __init__(self, \n\t                 model_name_or_path: str, \n\t                 max_seq_length: Optional[int] = None,\n\t                 model_args: Dict = {}, \n\t                 cache_folder: Optional[str] = None,\n\t                 tokenizer_args: Dict = {}, \n\t                 do_lower_case: bool = False,\n\t                 tokenizer_name_or_path : str = None,\n", "                 use_auth_token: Union[bool, str, None] = None\n\t                 ):\n\t        \"\"\"\n\t        Yang B. modification: \n\t        1) change the parameter `cache_dir` to `cache_folder`\n\t        2) add a new parameter `use_auth_token`\n\t        3) call sentence_transformers.util.snapshot_download to download transformers\n\t        \"\"\"\n\t        super(Transformer, self).__init__()\n\t        self.config_keys = ['max_seq_length', 'do_lower_case']\n", "        self.do_lower_case = do_lower_case\n\t        cache_folder = get_cache_folder(cache_folder)\n\t        if os.path.exists(model_name_or_path):\n\t            model_path = model_name_or_path\n\t        else:\n\t            model_path = os.path.join(cache_folder, model_name_or_path.replace('/', '_'))\n\t        if not os.path.exists(os.path.join(model_path, 'config.json')):\n\t            storage_path = snapshot_download(model_name_or_path,\n\t                            cache_dir=cache_folder,\n\t                            library_name=__LIBRARY_NAME__,\n", "                            library_version=__version__,\n\t                            ignore_files=['flax_model.msgpack', 'rust_model.ot', 'tf_model.h5'],\n\t                            use_auth_token=use_auth_token)\n\t            assert model_path == storage_path\n\t        assert os.path.exists(model_path)\n\t        config = AutoConfig.from_pretrained(model_path, **model_args)\n\t        self._load_model(model_path, config)\n\t        self.tokenizer = AutoTokenizer.from_pretrained(tokenizer_name_or_path or model_path, **tokenizer_args)\n\t        #No max_seq_length set. Try to infer from model\n\t        if max_seq_length is None:\n", "            if hasattr(self.auto_model, \"config\") and hasattr(self.auto_model.config, \"max_position_embeddings\") and hasattr(self.tokenizer, \"model_max_length\"):\n\t                max_seq_length = min(self.auto_model.config.max_position_embeddings, self.tokenizer.model_max_length)\n\t        self.max_seq_length = max_seq_length\n\t        if tokenizer_name_or_path is not None:\n\t            self.auto_model.config.tokenizer_class = self.tokenizer.__class__.__name__\n\t    def _load_model(self, model_name_or_path, config, cache_dir=None):\n\t        \"\"\"Loads the transformer model\"\"\"\n\t        if isinstance(config, T5Config):\n\t            self._load_t5_model(model_name_or_path, config, cache_dir)\n\t        else:\n", "            self.auto_model = AutoModel.from_pretrained(model_name_or_path, config=config, cache_dir=cache_dir)\n\t    def _load_t5_model(self, model_name_or_path, config, cache_dir=None):\n\t        \"\"\"Loads the encoder model from T5\"\"\"\n\t        from transformers import T5EncoderModel\n\t        T5EncoderModel._keys_to_ignore_on_load_unexpected = [\"decoder.*\"]\n\t        self.auto_model = T5EncoderModel.from_pretrained(model_name_or_path, config=config, cache_dir=cache_dir)\n\t    def __repr__(self):\n\t        return \"Transformer({}) with Transformer model: {} \".format(self.get_config_dict(), self.auto_model.__class__.__name__)\n\t    def forward(self, features):\n\t        \"\"\"Returns token_embeddings, cls_token\"\"\"\n", "        trans_features = {'input_ids': features['input_ids'], 'attention_mask': features['attention_mask']}\n\t        if 'token_type_ids' in features:\n\t            trans_features['token_type_ids'] = features['token_type_ids']\n\t        output_states = self.auto_model(**trans_features, return_dict=False)\n\t        output_tokens = output_states[0]\n\t        features.update({'token_embeddings': output_tokens, 'attention_mask': features['attention_mask']})\n\t        if self.auto_model.config.output_hidden_states:\n\t            all_layer_idx = 2\n\t            if len(output_states) < 3: #Some models only output last_hidden_states and all_hidden_states\n\t                all_layer_idx = 1\n", "            hidden_states = output_states[all_layer_idx]\n\t            features.update({'all_layer_embeddings': hidden_states})\n\t        return features\n\t    def get_word_embedding_dimension(self) -> int:\n\t        return self.auto_model.config.hidden_size\n\t    def tokenize(self, texts: Union[List[str], List[Dict], List[Tuple[str, str]]]):\n\t        \"\"\"\n\t        Tokenizes a text and maps tokens to token-ids\n\t        \"\"\"\n\t        output = {}\n", "        if isinstance(texts[0], str):\n\t            to_tokenize = [texts]\n\t        elif isinstance(texts[0], dict):\n\t            to_tokenize = []\n\t            output['text_keys'] = []\n\t            for lookup in texts:\n\t                text_key, text = next(iter(lookup.items()))\n\t                to_tokenize.append(text)\n\t                output['text_keys'].append(text_key)\n\t            to_tokenize = [to_tokenize]\n", "        else:\n\t            batch1, batch2 = [], []\n\t            for text_tuple in texts:\n\t                batch1.append(text_tuple[0])\n\t                batch2.append(text_tuple[1])\n\t            to_tokenize = [batch1, batch2]\n\t        #strip\n\t        to_tokenize = [[str(s).strip() for s in col] for col in to_tokenize]\n\t        #Lowercase\n\t        if self.do_lower_case:\n", "            to_tokenize = [[s.lower() for s in col] for col in to_tokenize]\n\t        output.update(self.tokenizer(*to_tokenize, padding=True, truncation='longest_first', return_tensors=\"pt\", max_length=self.max_seq_length))\n\t        return output\n\t    def get_config_dict(self):\n\t        return {key: self.__dict__[key] for key in self.config_keys}\n\t    def save(self, output_path: str):\n\t        self.auto_model.save_pretrained(output_path)\n\t        self.tokenizer.save_pretrained(output_path)\n\t        with open(os.path.join(output_path, 'sentence_bert_config.json'), 'w') as fOut:\n\t            json.dump(self.get_config_dict(), fOut, indent=2)\n", "    @staticmethod\n\t    def load(input_path: str):\n\t        #Old classes used other config names than 'sentence_bert_config.json'\n\t        for config_name in ['sentence_bert_config.json', 'sentence_roberta_config.json', 'sentence_distilbert_config.json', 'sentence_camembert_config.json', 'sentence_albert_config.json', 'sentence_xlm-roberta_config.json', 'sentence_xlnet_config.json']:\n\t            sbert_config_path = os.path.join(input_path, config_name)\n\t            if os.path.exists(sbert_config_path):\n\t                break\n\t        with open(sbert_config_path) as fIn:\n\t            config = json.load(fIn)\n\t        return Transformer(model_name_or_path=input_path, **config)\n"]}
{"filename": "zeronlg/models/Dense.py", "chunked_list": ["import torch\n\tfrom torch import Tensor\n\tfrom torch import nn\n\tfrom typing import Dict\n\timport os\n\timport json\n\tfrom sentence_transformers.util import fullname, import_from_string\n\t# Derived from sentence_transformers.models.Dense\n\t# (https://github.com/UKPLab/sentence-transformers/blob/master/sentence_transformers/models/Dense.py)\n\tclass Dense(nn.Module):\n", "    \"\"\"Feed-forward function with  activiation function.\n\t    This layer takes a fixed-sized sentence embedding and passes it through a feed-forward layer. Can be used to generate deep averaging networks (DAN).\n\t    :param in_features: Size of the input dimension\n\t    :param out_features: Output size\n\t    :param bias: Add a bias vector\n\t    :param activation_function: Pytorch activation function applied on output\n\t    :param init_weight: Initial value for the matrix of the linear layer\n\t    :param init_bias: Initial value for the bias of the linear layer\n\t    :param proj_token_embs: If True, project token embeddings in addition to the sentence embedding\n\t    \"\"\"\n", "    def __init__(self, \n\t                 in_features: int, \n\t                 out_features: int, \n\t                 bias: bool = True, \n\t                 activation_function=nn.Tanh(), \n\t                 init_weight: Tensor = None, \n\t                 init_bias: Tensor = None,\n\t                 proj_token_embs: bool = False,\n\t                 **kwargs,\n\t                ):\n", "        \"\"\"\n\t        Yang B. modification:\n\t        1) add a new parameter `proj_token_embs`, which allow projecting token embeddings if speficied\n\t        2) save `proj_token_embs` to config_dict\n\t        \"\"\"\n\t        super(Dense, self).__init__()\n\t        self.in_features = in_features\n\t        self.out_features = out_features\n\t        self.bias = bias\n\t        self.activation_function = activation_function\n", "        self.linear = nn.Linear(in_features, out_features, bias=bias)\n\t        if init_weight is not None:\n\t            self.linear.weight = nn.Parameter(init_weight)\n\t        if init_bias is not None:\n\t            self.linear.bias = nn.Parameter(init_bias)\n\t        self.proj_token_embs = proj_token_embs\n\t    def forward(self, features: Dict[str, Tensor]):\n\t        features.update({'sentence_embedding': self.activation_function(self.linear(features['sentence_embedding']))})\n\t        if self.proj_token_embs:\n\t            features.update({'token_embeddings': self.activation_function(self.linear(features['token_embeddings']))})\n", "        return features\n\t    def get_sentence_embedding_dimension(self) -> int:\n\t        return self.out_features\n\t    def save(self, output_path):\n\t        with open(os.path.join(output_path, 'config.json'), 'w') as fOut:\n\t            json.dump(self.get_config_dict(), fOut)\n\t        torch.save(self.state_dict(), os.path.join(output_path, 'pytorch_model.bin'))\n\t    def get_config_dict(self):\n\t        return {'in_features': self.in_features, 'out_features': self.out_features, 'bias': self.bias, 'activation_function': fullname(self.activation_function), 'proj_token_embs': self.proj_token_embs}\n\t    def __repr__(self):\n", "        return \"Dense({})\".format(self.get_config_dict())\n\t    @staticmethod\n\t    def load(input_path):\n\t        with open(os.path.join(input_path, 'config.json')) as fIn:\n\t            config = json.load(fIn)\n\t        config['activation_function'] = import_from_string(config['activation_function'])()\n\t        model = Dense(**config)\n\t        model.load_state_dict(torch.load(os.path.join(input_path, 'pytorch_model.bin'), map_location=torch.device('cpu')))\n\t        return model\n"]}
{"filename": "zeronlg/models/Decoder.py", "chunked_list": ["import os\n\timport json\n\timport torch\n\timport transformers\n\tfrom torch import nn\n\tfrom typing import List, Dict, Optional, Union\n\tfrom transformers import AutoModelForCausalLM, AutoTokenizer, AutoConfig\n\tfrom sentence_transformers.util import snapshot_download\n\tfrom ..utils import get_cache_folder\n\tfrom .. import __LIBRARY_NAME__, __version__\n", "# map a language to a specific token, \n\t# which will be used as the begin-of-sentence (BOS) token to guide the decoder\n\tLANG2TOKEN = {\n\t    'en': '[unused1]',\n\t    'zh': '[unused2]',\n\t    'de': '[unused3]',\n\t    'fr': '[unused4]',\n\t} # Note: do not modify the existing mappings in LANG2TOKEN, you can instead add new ones\n\tclass Decoder(nn.Module):\n\t    \"\"\"Huggingface AutoModelForCausalLM for decoding.\n", "    Loads the correct class, e.g. BERT / RoBERTa etc.\n\t    :param model_name_or_path: Huggingface models name (https://huggingface.co/models)\n\t    :param model_args: Arguments (key, value pairs) passed to the Huggingface Transformers model\n\t    :param max_seq_length: Truncate any inputs longer than max_seq_length\n\t    :param cache_dir: Cache dir for Huggingface Transformers to store/load models\n\t    :param tokenizer_args: Arguments (key, value pairs) passed to the Huggingface Tokenizer model\n\t    :param do_lower_case: If true, lowercases the input (independent if the model is cased or not)\n\t    :param tokenizer_name_or_path: Name or path of the tokenizer. When None, then model_name_or_path is used\n\t    :param from_pretrained: If true, load pre-trained weights (deafult to true)\n\t    :param attend_to: A list of string(s) to specify which encoder(s) will the decoder attend to,\n", "                      e.g., ['student'] means taking the newly-trained encoder's outputs as the cross-attention inputs;\n\t                            ['teacher'] means taking the (frozen) pre-trained encoder's outputs as the cross-attention inputs;\n\t                            ['student', 'teacher'] ...\n\t    :param teacher_model_name: The name of the teacher model, which will be stored into the module config and used for re-loading\n\t    \"\"\"\n\t    def __init__(self, \n\t                 model_name_or_path: str, \n\t                 model_args: Dict = {}, \n\t                 max_seq_length: Optional[int] = None,\n\t                 cache_folder: Optional[str] = None,\n", "                 tokenizer_args: Dict = {}, \n\t                 do_lower_case: bool = False,\n\t                 tokenizer_name_or_path : str = None,\n\t                 from_pretrained: bool = True,\n\t                 use_auth_token: Union[bool, str, None] = None,\n\t                 attend_to: List[str] = ['student'],\n\t                 teacher_model_name: str = None,\n\t                 use_clip_tokens: Optional[bool] = None,\n\t                 ):\n\t        super().__init__()\n", "        self.config_keys = ['max_seq_length', 'do_lower_case', 'attend_to', 'teacher_model_name', 'use_clip_tokens']\n\t        self.do_lower_case = do_lower_case\n\t        self.teacher_model_name = teacher_model_name\n\t        self.use_clip_tokens = bool(use_clip_tokens or False)\n\t        assert isinstance(attend_to, (list, tuple))\n\t        self.attend_to = list(set(attend_to))\n\t        cache_folder = get_cache_folder(cache_folder)\n\t        if os.path.exists(model_name_or_path):\n\t            model_path = model_name_or_path\n\t        else:\n", "            model_path = os.path.join(cache_folder, model_name_or_path.replace('/', '_'))\n\t        if not os.path.exists(os.path.join(model_path, 'config.json')):\n\t            storage_path = snapshot_download(model_name_or_path,\n\t                            cache_dir=cache_folder,\n\t                            library_name=__LIBRARY_NAME__,\n\t                            library_version=__version__,\n\t                            ignore_files=['flax_model.msgpack', 'rust_model.ot', 'tf_model.h5'],\n\t                            use_auth_token=use_auth_token)\n\t            assert model_path == storage_path\n\t        assert os.path.exists(model_path)\n", "        config = AutoConfig.from_pretrained(model_path, **model_args)\n\t        assert config.is_decoder is True\n\t        assert config.add_cross_attention is True\n\t        self._load_model(model_path, config, from_pretrained)\n\t        self.auto_model.prepare_inputs_for_generation = self.prepare_inputs_for_generation\n\t        self.tokenizer = AutoTokenizer.from_pretrained(tokenizer_name_or_path or model_path, **tokenizer_args)\n\t        self.vocab = self.tokenizer.get_vocab()\n\t        self.bos_token_id = self.tokenizer.bos_token_id or self.tokenizer.cls_token_id\n\t        self.eos_token_id = self.tokenizer.eos_token_id or self.tokenizer.sep_token_id\n\t        self.pad_token_id = self.tokenizer.pad_token_id\n", "        # No max_seq_length set. Try to infer from model\n\t        if max_seq_length is None:\n\t            if hasattr(self.auto_model, \"config\") and hasattr(self.auto_model.config, \"max_position_embeddings\") and hasattr(self.tokenizer, \"model_max_length\"):\n\t                max_seq_length = min(self.auto_model.config.max_position_embeddings, self.tokenizer.model_max_length)\n\t        self.max_seq_length = max_seq_length\n\t        if tokenizer_name_or_path is not None:\n\t            self.auto_model.config.tokenizer_class = self.tokenizer.__class__.__name__\n\t        # determine the behavior during generation based on the version of transformers\n\t        self.should_repeat = True\n\t        version = [int(item) for item in transformers.__version__.split('.')]\n", "        if version[0] > 4 or (version[0] == 4 and version[1] >=27):\n\t            # after 4.27.0, we should not repeat encoder's outputs by `num_beams` * `num_return_sequences` times\n\t            self.should_repeat = False\n\t    def _load_model(self, model_name_or_path, config, from_pretrained):\n\t        \"\"\"Loads the transformer model\"\"\"\n\t        if from_pretrained:\n\t            self.auto_model = AutoModelForCausalLM.from_pretrained(model_name_or_path, config=config)\n\t        else:\n\t            self.auto_model = AutoModelForCausalLM.from_config(config)\n\t    def __repr__(self):\n", "        return \"Decoder({}) with Transformer model: {} \".format(self.get_config_dict(), self.auto_model.__class__.__name__)\n\t    def get_encoder_attention_mask(self, encoder_hidden_states, features, attend_to, n_repeats=1):\n\t        encoder_attention_mask = None\n\t        if encoder_hidden_states.size(1) != 1 and attend_to == 'student':\n\t            encoder_attention_mask = features['attention_mask']\n\t        if encoder_attention_mask is not None:\n\t            encoder_attention_mask = encoder_attention_mask.repeat_interleave(n_repeats, dim=0)\n\t        return encoder_attention_mask\n\t    def prepare_encoder_hidden_states(self, states):\n\t        B = states.size(0)\n", "        D = states.size(-1)\n\t        if states.ndim == 2:\n\t            states = states.unsqueeze(1)\n\t        if states.ndim == 4:\n\t            states = states.view(B, -1, D)\n\t        return states\n\t    def forward(self, features):\n\t        \"\"\"Returns losses if self.training is True, otherwise generation results\"\"\"\n\t        attend_to = features.get('attend_to', None) or self.attend_to\n\t        if not isinstance(attend_to, (list, tuple)):\n", "            attend_to = [attend_to]\n\t        if self.training:\n\t            inputs = {\n\t                'input_ids': features['decoder_input_ids'], \n\t                'attention_mask': features.get('decoder_attention_mask', None),\n\t                'token_type_ids': features.get('decoder_token_type_ids', None),\n\t            }\n\t            inputs['labels'] = inputs['input_ids'].masked_fill(inputs['input_ids'] == self.tokenizer.pad_token_id, -100)\n\t            for at in attend_to:\n\t                assert at in ['teacher', 'student'], f\"`attend_to` == {at} is not supported during training yet\"\n", "                # if attending to the teacher's hidden states, it denotes a English -> English/Chinese/German/French process\n\t                # if attending to the student's hidden states, it denotes a auto-encoding process\n\t                source = features[f'{at}_hidden_states']\n\t                inputs['encoder_hidden_states'] = self.prepare_encoder_hidden_states(source)\n\t                inputs['encoder_attention_mask'] = self.get_encoder_attention_mask(source, features, at)\n\t                output_states = self.auto_model(**inputs, return_dict=False)\n\t                loss = output_states[0]\n\t                features.update({f'loss_at_{at}': loss})\n\t        else:\n\t            # if we do not filter those unused keys, there will be an error for transformers==4.27.1\n", "            ignore_keys = ['sentence_embedding', 'source_embedding', 'attend_to', 'decoder_input_ids', 'student_hidden_states', 'teacher_hidden_states', 'token_embeddings', 'num_frames']\n\t            generate_kwargs = {k: v for k, v in features.items() if k not in ignore_keys}\n\t            for at in attend_to:\n\t                assert at in ['student', 'teacher', 'both']\n\t                if at == 'both':\n\t                    # multimodal machine translation\n\t                    encoder_hidden_states = torch.cat([features['teacher_hidden_states'], features['student_hidden_states']], dim=1)\n\t                else:\n\t                    # visual captioning (at == 'teacher') or machine translation (at == 'student')\n\t                    encoder_hidden_states = features[f'{at}_hidden_states']\n", "                encoder_hidden_states = self.prepare_encoder_hidden_states(encoder_hidden_states)\n\t                if self.should_repeat:\n\t                    n_repeats = generate_kwargs['num_beams']\n\t                    if generate_kwargs.get('do_sample', False):\n\t                        n_repeats *= generate_kwargs.get('num_return_sequences', 1)\n\t                    encoder_hidden_states = encoder_hidden_states.repeat_interleave(n_repeats, dim=0)\n\t                else:\n\t                    n_repeats = 1\n\t                encoder_attention_mask = self.get_encoder_attention_mask(encoder_hidden_states, features, at, n_repeats=n_repeats)\n\t                inputs = {\n", "                    'input_ids': features['decoder_input_ids'], \n\t                    'encoder_hidden_states': encoder_hidden_states,\n\t                    'attention_mask': None,\n\t                    'encoder_attention_mask': encoder_attention_mask,\n\t                    'eos_token_id': self.eos_token_id,\n\t                    'pad_token_id': self.pad_token_id,\n\t                }\n\t                generate_kwargs.update(inputs)\n\t                outputs = self.auto_model.generate(**generate_kwargs)\n\t                features[f'results_at_{at}'] =  self._get_captions(outputs)\n", "        return features\n\t    def get_word_embedding_dimension(self) -> int:\n\t        return self.auto_model.config.hidden_size\n\t    def tokenize(self, texts: List[str], langs: Optional[List[str]]=None):\n\t        \"\"\"Tokenizes texts and maps tokens to token-ids\"\"\"\n\t        to_tokenize = texts\n\t        #strip\n\t        to_tokenize = [str(text).strip() for text in to_tokenize]\n\t        #Lowercase\n\t        if self.do_lower_case:\n", "            to_tokenize = [text.lower() for text in to_tokenize]\n\t        outputs = self.tokenizer(to_tokenize, padding=True, truncation='longest_first', return_tensors=\"pt\", max_length=self.max_seq_length)\n\t        for input_ids in outputs['input_ids']:\n\t            assert self.bos_token_id in input_ids\n\t            assert self.eos_token_id in input_ids\n\t        if langs:\n\t            assert len(outputs['input_ids']) == len(langs)\n\t            for input_ids, lang in zip(outputs['input_ids'], langs):\n\t                assert lang in LANG2TOKEN, f\"{lang} not in LANG2TOKEN {LANG2TOKEN.keys()}\"\n\t                lang_token_id = self.vocab.get(LANG2TOKEN[lang], None)\n", "                if not lang_token_id:\n\t                    raise NotImplementedError(f'The special token of {lang}, i.e., {LANG2TOKEN[lang]}, is not found in the vocab; You may call tokenizer.add_tokens')\n\t                index_of_bos_token_id = input_ids.numpy().tolist().index(self.bos_token_id)\n\t                # override the first bos token with lang token\n\t                input_ids[index_of_bos_token_id] = lang_token_id\n\t        return {f'decoder_{k}': v for k, v in outputs.items()}\n\t    def get_bos_input_ids(self, batch_size: int, lang: Optional[str]=None):\n\t        bos = self.bos_token_id if lang is None else self.vocab[LANG2TOKEN[lang]]\n\t        return torch.LongTensor([[bos] for _ in range(batch_size)])\n\t    def get_config_dict(self):\n", "        return {key: self.__dict__[key] for key in self.config_keys}\n\t    def save(self, output_path: str):\n\t        self.auto_model.save_pretrained(output_path)\n\t        self.tokenizer.save_pretrained(output_path)\n\t        with open(os.path.join(output_path, 'decoder_config.json'), 'w') as fOut:\n\t            json.dump(self.get_config_dict(), fOut, indent=2)\n\t    @staticmethod\n\t    def load(input_path: str):\n\t        sbert_config_path = os.path.join(input_path, 'decoder_config.json')\n\t        with open(sbert_config_path) as fIn:\n", "            config = json.load(fIn)\n\t        return Decoder(model_name_or_path=input_path, **config)\n\t    def _get_captions(self, caption_ids):\n\t        captions = []\n\t        for i, output in enumerate(caption_ids):\n\t            # skip the bos token, which can be not a special token, e.g., [unused1]\n\t            caption = self.tokenizer.decode(output[1:], skip_special_tokens=True)\n\t            captions.append(caption)\n\t        return captions\n\t    def prepare_inputs_for_generation(self, input_ids, past=None, attention_mask=None, **kwargs):\n", "        input_shape = input_ids.shape\n\t        # if model is used as a decoder in encoder-decoder model, the decoder attention mask is created on the fly\n\t        if attention_mask is None:\n\t            attention_mask = input_ids.new_ones(input_shape)\n\t        # cut decoder_input_ids if past is used\n\t        if past is not None:\n\t            input_ids = input_ids[:, -1:]\n\t        assert kwargs.get('encoder_hidden_states', None) is not None\n\t        return {\n\t            \"input_ids\": input_ids, \n", "            \"attention_mask\": attention_mask, \n\t            \"past_key_values\": past, \n\t            'encoder_hidden_states': kwargs['encoder_hidden_states'],\n\t            'encoder_attention_mask': kwargs['encoder_attention_mask'],\n\t        }\n"]}
{"filename": "zeronlg/models/__init__.py", "chunked_list": ["from .CLIPModel import CLIPModel\n\tfrom .Dense import Dense\n\tfrom .Projector import Projector\n\tfrom .Decoder import Decoder\n\tfrom .Transformer import Transformer"]}
{"filename": "zeronlg/models/CLIPModel.py", "chunked_list": ["import os\n\timport json\n\timport transformers\n\timport torch\n\tfrom torch import nn\n\tfrom PIL import Image\n\t# Adapted from sentence_transformers.models.CLIPModel\n\t# (https://github.com/UKPLab/sentence-transformers/blob/master/sentence_transformers/models/CLIPModel.py)\n\tclass CLIPModel(nn.Module):\n\t    def __init__(self,  model_name: str = \"openai/clip-vit-base-patch32\", processor_name = None, use_clip_tokens: bool = False):\n", "        \"\"\"\n\t        Yang B. modification: \n\t        1) add truncation=True and max_length=77 in CLIPModel.tokenize to avoid bugs\n\t        2) add function: get_word_embedding_dimension and get_sentence_embedding_dimension\n\t        3) add an extra argument `use_clip_tokens` to return token-level embeddings in addition to the global-level vector\n\t        4) save configs for re-loading\n\t        \"\"\"\n\t        super(CLIPModel, self).__init__()\n\t        self.config_keys = ['use_clip_tokens']\n\t        if processor_name is None:\n", "            processor_name = model_name\n\t        self.model = transformers.CLIPModel.from_pretrained(model_name)\n\t        self.processor = transformers.CLIPProcessor.from_pretrained(processor_name)\n\t        self.use_clip_tokens = use_clip_tokens\n\t    def __repr__(self):\n\t        return \"CLIPModel({})\".format(self.get_config_dict())\n\t    def forward(self, features):\n\t        image_embeds = []\n\t        text_embeds = []\n\t        if 'pixel_values' in features:\n", "            vision_outputs = self.model.vision_model(pixel_values=features['pixel_values'], return_dict=False)\n\t            last_hidden_state, pooled_output, *_ = vision_outputs\n\t            image_embeds = self.model.visual_projection(pooled_output)\n\t            if self.use_clip_tokens:\n\t                image_token_embeds = self.model.visual_projection(last_hidden_state)\n\t        if 'input_ids' in features:\n\t            text_outputs = self.model.text_model(\n\t                input_ids=features.get('input_ids'),\n\t                attention_mask=features.get('attention_mask', None),\n\t                position_ids=features.get('position_ids', None),\n", "                output_attentions=features.get('output_attentions', None),\n\t                output_hidden_states=features.get('output_hidden_states', None),\n\t                return_dict=False,\n\t            )\n\t            last_hidden_state, pooled_output, *_ = text_outputs\n\t            text_embeds = self.model.text_projection(pooled_output)\n\t            if self.use_clip_tokens:\n\t                text_token_embeds = self.model.text_projection(last_hidden_state)\n\t        sentence_embedding = []\n\t        image_features = iter(image_embeds)\n", "        text_features = iter(text_embeds)\n\t        for idx, input_type in enumerate(features['image_text_info']):\n\t            if input_type == 0:\n\t                sentence_embedding.append(next(image_features))\n\t            else:\n\t                sentence_embedding.append(next(text_features))\n\t        features['sentence_embedding'] = torch.stack(sentence_embedding).float()\n\t        if self.use_clip_tokens:\n\t            prev_input_type = None\n\t            for input_type in features['image_text_info']:\n", "                if prev_input_type is None:\n\t                    prev_input_type = input_type\n\t                else:\n\t                    assert prev_input_type == input_type\n\t            # (batch_size, num_tokens, D)\n\t            if prev_input_type == 0:\n\t                features['token_embeddings'] = image_token_embeds\n\t                features['attention_mask'] = torch.ones(*image_token_embeds.shape[:2])\n\t            else:\n\t                features['token_embeddings'] = text_token_embeds\n", "        return features\n\t    def tokenize(self, texts):\n\t        images = []\n\t        texts_values = []\n\t        image_text_info = []\n\t        for idx, data in enumerate(texts):\n\t            if isinstance(data, Image.Image):  # An Image\n\t                images.append(data)\n\t                image_text_info.append(0)\n\t            else:  # A text\n", "                texts_values.append(data)\n\t                image_text_info.append(1)\n\t        if len(texts_values) == 0:\n\t            texts_values = None\n\t        if len(images) == 0:\n\t            images = None\n\t        inputs = self.processor(text=texts_values, images=images, return_tensors=\"pt\", padding=True, truncation=True, max_length=77)\n\t        inputs['image_text_info'] = image_text_info\n\t        return inputs\n\t    def get_word_embedding_dimension(self) -> int:\n", "        return self.model.text_embed_dim\n\t    def get_sentence_embedding_dimension(self) -> int:\n\t        return self.model.projection_dim\n\t    def get_config_dict(self):\n\t        return {key: self.__dict__[key] for key in self.config_keys}\n\t    def save(self, output_path: str):\n\t        self.model.save_pretrained(output_path)\n\t        self.processor.save_pretrained(output_path)\n\t        with open(os.path.join(output_path, 'clip_config.json'), 'w') as fOut:\n\t            json.dump(self.get_config_dict(), fOut, indent=2)\n", "    @staticmethod\n\t    def load(input_path: str):\n\t        config = {}\n\t        config_path = os.path.join(input_path, 'clip_config.json')\n\t        if os.path.exists(config_path):\n\t            config = json.load(open(config_path))\n\t        return CLIPModel(model_name=input_path, **config)\n"]}
{"filename": "zeronlg/models/Projector.py", "chunked_list": ["import os\n\timport torch\n\timport json\n\timport random\n\timport torch.nn.functional as F\n\tfrom torch import nn, Tensor\n\tfrom typing import Dict\n\tclass Projector(nn.Module):\n\t    \"\"\"\n\t    This layer takes fixed-sized embedding(s) named \n", "    'sentence_embedding' (from the student model) and/or 'source_embedding' (from the teacher model) \n\t    as inputs, and outputs 'student_hidden_states' and/or 'teacher_hidden_states' respectively.\n\t    Pipeline:\n\t    1) applying L2 normalization, \n\t    2) (optional) adding gaussian noises and again applying L2 normalization,\n\t    3) applying the feed-forward process in the order of `Linear-Dropout-LayerNorm` \n\t    :param in_features: Size of the input dimension\n\t    :param out_features: Output size\n\t    :param bias: Add a bias vector\n\t    :param dropout: Probability of dropout (default to 0.1)\n", "    :param noise_std: Standard deviation of the gaussian noise (defaut to 0)\n\t    :param noise_prob: Probability to add gaussian noise (default to 0, which is equivalent to 1)\n\t    :param student_emb_keyname: Features of the specific key to be mapped to `student_hidden_states`\n\t    :param teacher_emb_keyname: Features of the specific key to be mapped to `teacher_hidden_states`\n\t    \"\"\"\n\t    def __init__(self, \n\t                 in_features: int, \n\t                 out_features: int, bias: bool = True, \n\t                 dropout: float = 0.1, \n\t                 noise_std: float = 0.0, \n", "                 noise_prob: float = 0.0, \n\t                 student_emb_keyname: str = 'sentence_embedding',\n\t                 teacher_emb_keyname: str = 'source_embedding',\n\t                 **kwargs\n\t                 ):\n\t        super(Projector, self).__init__()\n\t        self.in_features = in_features\n\t        self.out_features = out_features\n\t        self.bias = bias\n\t        self.noise_std = noise_std\n", "        self.noise_prob = noise_prob\n\t        self.dropout = dropout\n\t        self.linear = nn.Linear(in_features, out_features, bias=bias)\n\t        self.drop = nn.Dropout(dropout)\n\t        self.norm = nn.LayerNorm(out_features)\n\t        self.student_emb_keyname = student_emb_keyname\n\t        self.teacher_emb_keyname = teacher_emb_keyname\n\t    def forward(self, features: Dict[str, Tensor]):\n\t        for src_name, trg_name in zip(\n\t                [self.student_emb_keyname, self.teacher_emb_keyname], \n", "                ['student_hidden_states', 'teacher_hidden_states']\n\t            ):\n\t            if src_name in features and features[src_name] is not None:\n\t                # 1): L2 normalization\n\t                feats = F.normalize(features[src_name], dim=-1)\n\t                # 2): Gaussian noise & L2 normalization\n\t                if self.noise_std > 0 and self.training:\n\t                    if self.noise_prob == 0 or (random.random() < self.noise_prob):\n\t                        feats = feats + (torch.randn(feats.shape).to(feats.device) * self.noise_std)\n\t                        feats = F.normalize(feats, dim=-1)\n", "                # 3): Feed forward in the order of `Linear-Dropout-LayerNorm`\n\t                feats = self.norm(self.drop(self.linear(feats)))\n\t                if feats.dim() == 2:\n\t                    feats = feats.unsqueeze(1) # (batch_size, 1, out_features)\n\t                features[trg_name] = feats\n\t        return features\n\t    def get_config_dict(self):\n\t        return {\n\t            'in_features': self.in_features, \n\t            'out_features': self.out_features, \n", "            'bias': self.bias, \n\t            'noise_std': self.noise_std, \n\t            'dropout': self.dropout, \n\t            'noise_prob': self.noise_prob,\n\t            'student_emb_keyname': self.student_emb_keyname,\n\t            'teacher_emb_keyname': self.teacher_emb_keyname,\n\t        }\n\t    def save(self, output_path):\n\t        with open(os.path.join(output_path, 'config.json'), 'w') as fOut:\n\t            json.dump(self.get_config_dict(), fOut)\n", "        torch.save(self.state_dict(), os.path.join(output_path, 'pytorch_model.bin'))\n\t    def __repr__(self):\n\t        return \"Projector({})\".format(self.get_config_dict())\n\t    @staticmethod\n\t    def load(input_path):\n\t        with open(os.path.join(input_path, 'config.json')) as fIn:\n\t            config = json.load(fIn)\n\t        model = Projector(**config)\n\t        model.load_state_dict(torch.load(os.path.join(input_path, 'pytorch_model.bin'), map_location=torch.device('cpu')))\n\t        return model\n"]}
{"filename": "zeronlg/datasets/__init__.py", "chunked_list": ["from .PretrainDataset import PretrainDataset\n\tfrom .CaptionDataset import CaptionDataset, CaptionDatasetForRetrieval\n\tfrom .TranslateDataset import TranslateDataset"]}
{"filename": "zeronlg/datasets/TranslateDataset.py", "chunked_list": ["import logging\n\tfrom sentence_transformers import LoggingHandler\n\tfrom torch.utils.data import Dataset\n\tfrom typing import Optional, List\n\tlogging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tglobal_logger = logging.getLogger(__name__)\n\tclass TranslateDataset(Dataset):\n", "    def __init__(self, \n\t                 source_language: str, \n\t                 target_language: str,\n\t                 source_path: Optional[str] = None,\n\t                 target_path: Optional[str] = None,\n\t                 source_sentences: Optional[List[str]] = None, \n\t                 target_sentences: Optional[List[str]] = None,\n\t                 logger: Optional[logging.Logger] = None\n\t                 ) -> None:\n\t        self.logger = logger or global_logger\n", "        assert source_path is not None or source_sentences is not None\n\t        assert target_path is not None or target_sentences is not None\n\t        if source_sentences is None:\n\t            self.log(f'Loading source sentences ({source_language}) from {source_path}')\n\t            source_sentences = open(source_path, 'r', encoding='utf8').read().strip().split('\\n')\n\t        if target_sentences is None:\n\t            self.log(f'Loading target sentences ({target_language}) from {target_path}')\n\t            target_sentences = open(target_path, 'r', encoding='utf8').read().strip().split('\\n')\n\t        assert len(source_sentences) == len(target_sentences), \\\n\t            f\"#source sents: {len(source_sentences)}; #target sents: {target_sentences}\"\n", "        self.source_language = source_language\n\t        self.source_sentences = source_sentences\n\t        self.target_language = target_language\n\t        self.target_sentences = target_sentences\n\t    def log(self, msg):\n\t        self.logger.info(msg)\n\t    def __len__(self):\n\t        return len(self.source_sentences)\n\t    def __getitem__(self, index):\n\t        return self.source_sentences[index], self.target_sentences[index]\n"]}
{"filename": "zeronlg/datasets/PretrainDataset.py", "chunked_list": ["import os\n\timport logging\n\timport gzip\n\timport random\n\timport torch\n\timport numpy as np\n\tfrom sentence_transformers import LoggingHandler\n\tfrom torch.utils.data import Dataset\n\tfrom typing import Union, List\n\tfrom .. import Framework\n", "logging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tglobal_logger = logging.getLogger(__name__)\n\tclass InputExample:\n\t    \"\"\"\n\t    Structure for one input example\n\t    \"\"\"\n\t    def __init__(self, \n", "                 sid: str = '', \n\t                 src_text: str = None,\n\t                 trg_text: str = None,  \n\t                 label: Union[int, float, torch.Tensor, np.ndarray] = 0, \n\t                 lang: str = None, \n\t                 ):\n\t        \"\"\"\n\t        :param sid: id for the example\n\t        :param src_text: the source sentence\n\t        :param trg_text: the target sentence\n", "        :param label: the label for the target sentence\n\t        :param lang: the language of the target sentence\n\t        \"\"\"\n\t        self.sid = sid\n\t        self.src_text = src_text\n\t        self.trg_text = trg_text\n\t        self.label = label\n\t        self.lang = lang\n\t    def __str__(self):\n\t        return \"<InputExample> label: {}, src_text: {}, trg_text: {}, lang: {}\".format(\n", "            str(self.label), str(self.src_text), str(self.trg_text), str(self.lang))\n\tclass PretrainDataset(Dataset):\n\t    \"\"\"\n\t    Adapted from sentence_transformers.datasets.ParallelSentencesDataset\n\t    (https://github.com/UKPLab/sentence-transformers/blob/master/sentence_transformers/datasets/ParallelSentencesDataset.py)\n\t    This dataset reader can be used to read-in parallel sentences, i.e., it reads in a file with tab-seperated sentences with the same\n\t    sentence in different languages. For example, the file can look like this (EN\\tDE\\tES):\n\t    hello world     hallo welt  hola mundo\n\t    second sentence zweiter satz    segunda oración\n\t    The sentence in the first column will be mapped to a sentence embedding using the given the embedder. For example,\n", "    embedder is a mono-lingual sentence embedding method for English. The sentences in the other languages will also be\n\t    mapped to this English sentence embedding.\n\t    When getting a sample from the dataset, we get one sentence with the according sentence embedding for this sentence.\n\t    teacher_model can be any class that implement an encode function. The encode function gets a list of sentences and\n\t    returns a list of sentence embeddings\n\t    \"\"\"\n\t    def __init__(self, \n\t                 teacher_model: Framework, \n\t                 batch_size: int = 8, \n\t                 use_embedding_cache: bool = True, \n", "                 # Yang B. modification: add extra arguments\n\t                 target_languages: List[str]=None, \n\t                 logger: logging.Logger=None,\n\t                 numpy_path: str = None,\n\t                 ):\n\t        \"\"\"\n\t        :param teacher_model: Teacher model, that provides the sentence embeddings for the first column in the dataset file\n\t        :param batch_size: The number of sentences used for embedding extraction per iteration\n\t        :param use_embedding_cache: Cache extracted embeddins for speeding up (if the training lasts multiple epochs)\n\t        :param target_languages: Columns that are not satisfied with the specific target languages will be ignored\n", "        :param logger: If not specified, use the global logger\n\t        :param numpy_path: Path to a numpy file that stores sentence embeddings\n\t        \"\"\"\n\t        self.teacher_model = teacher_model\n\t        self.datasets = []\n\t        self.datasets_iterator = []\n\t        self.datasets_tokenized = []\n\t        self.dataset_indices = []\n\t        self.copy_dataset_indices = []\n\t        self.cache = []\n", "        self.batch_size = batch_size\n\t        self.use_embedding_cache = use_embedding_cache\n\t        self.embedding_cache = {}\n\t        self.source2index = {}\n\t        self.num_sentences = 0\n\t        self.target_languages = target_languages\n\t        self.logger = logger or global_logger\n\t        self.numpy_path = numpy_path\n\t        if self.numpy_path:\n\t            self.logger.info(f'loading embedding cache from {self.numpy_path}')\n", "            self.embedding_cache = np.load(self.numpy_path)\n\t        if target_languages:\n\t            self.logger.info(f'Target languges during training: {str(self.target_languages)}')\n\t    def load_data(self, \n\t                  filepath: str, \n\t                  weight: int = 100, \n\t                  max_sentences: int = None, \n\t                  max_sentence_length: int = None, \n\t                  # Yang B. modification: add extra arguments\n\t                  first_line_is_lang: bool = False, \n", "                  langs: List[str]=None, \n\t                  exclude_source: bool=False\n\t                  ):\n\t        \"\"\"\n\t        Reads in a tab-seperated .txt/.csv/.tsv or .gz file. The different columns contain the different translations of the sentence in the first column\n\t        :param filepath: Filepath to the file\n\t        :param weight: If more than one dataset is loaded with load_data: With which frequency should data be sampled from this dataset?\n\t        :param max_sentences: Max number of lines to be read from filepath\n\t        :param max_sentence_length: Skip the example if one of the sentences is has more characters than max_sentence_length\n\t        :param batch_size: Size for encoding parallel sentences\n", "        :param first_line_is_lang: Whether the first line is the header that indicates the languages of each column (default to False)\n\t        :param langs: The specific languages of all columns (default to None)\n\t        :param exclude_source: Whether exclude sentences in the source langugage (i.e., the first column) as targets (default to False)\n\t        :return:\n\t        \"\"\"\n\t        logger = self.logger\n\t        logger.info(\"Load \"+filepath)\n\t        parallel_sentences = []\n\t        first_line_flag = True\n\t        # Yang B. modification: record parallel languages of this data if specified\n", "        if (first_line_is_lang or langs):\n\t            if not hasattr(self, 'langs_of_data'):\n\t                self.langs_of_data = []\n\t            if langs:\n\t                self.langs_of_data.append(langs)\n\t                logger.info(f\"There are {len(langs)} langauges: {langs}\")\n\t        elif hasattr(self, 'langs_of_data'):\n\t            # it means that you have a inconsistent behavior when calling this function.\n\t            raise ValueError('You should pass `first_line_is_lang` = True or specify langs for all data')\n\t        with gzip.open(filepath, 'rt', encoding='utf8') if filepath.endswith('.gz') else open(filepath, encoding='utf8') as fIn:\n", "            count = 0\n\t            for line in fIn:\n\t                sentences = line.strip().split(\"\\t\")\n\t                # check languages\n\t                if first_line_flag and first_line_is_lang:\n\t                    first_line_flag = False\n\t                    if langs:\n\t                        assert len(langs) == len(sentences)\n\t                        for lang1, lang2 in zip(langs, sentences):\n\t                            assert lang1 == lang2\n", "                    else:\n\t                        self.langs_of_data.append(sentences)\n\t                        logger.info(f\"There are {len(sentences)} langauges: {sentences}\")\n\t                    continue\n\t                if hasattr(self, 'langs_of_data'):\n\t                    # ensure that each line has the same number of sentences as that of languages\n\t                    assert len(sentences) == len(self.langs_of_data[-1])\n\t                if max_sentence_length is not None and max_sentence_length > 0 and max([len(sent) for sent in sentences]) > max_sentence_length:\n\t                    continue\n\t                parallel_sentences.append(sentences)\n", "                count += 1\n\t                if max_sentences is not None and max_sentences > 0 and count >= max_sentences:\n\t                    break\n\t        # show statistics and an example\n\t        logger.info(f\"There are {count} lines, one of which is {parallel_sentences[0]}\")\n\t        self.add_dataset(parallel_sentences, weight, max_sentences, max_sentence_length, exclude_source)\n\t    def add_dataset(self, \n\t                    parallel_sentences: List[List[str]], \n\t                    weight: int = 100, \n\t                    max_sentences: int = None, \n", "                    max_sentence_length: int = 128, \n\t                    # Yang B. modification: add extra arguments\n\t                    exclude_source: bool = False\n\t                    ):\n\t        sentences_map = {}\n\t        for idx, sentences in enumerate(parallel_sentences):\n\t            if max_sentence_length is not None and max_sentence_length > 0 and max([len(sent) for sent in sentences]) > max_sentence_length:\n\t                continue\n\t            source_sentence = sentences[0]\n\t            self.source2index[source_sentence] = idx\n", "            if source_sentence not in sentences_map:\n\t                sentences_map[source_sentence] = set()\n\t            if hasattr(self, 'langs_of_data'):\n\t                langs = self.langs_of_data[-1]\n\t            else:\n\t                langs = [None for _ in range(len(sentences))]\n\t            # whether we exclude the source sentences as a part of targets\n\t            # we carry out this operation to avoid imbalanced language distribution\n\t            # e.g., if we add datasets of columns A-B, A-C, and A-D with `exclude_source = False`\n\t            # then A: B: C: D = 3: 1: 1: 1\n", "            start = 1 if exclude_source else 0\n\t            for i in range(start, len(sentences)):\n\t                sent = sentences[i]\n\t                lang = langs[i]\n\t                if self.target_languages and lang not in self.target_languages:\n\t                    continue\n\t                sentences_map[source_sentence].add((sent, lang))\n\t            if max_sentences is not None and max_sentences > 0 and len(sentences_map) >= max_sentences:\n\t                break\n\t        if len(sentences_map) == 0:\n", "            return\n\t        self.num_sentences += sum([len(sentences_map[sent]) for sent in sentences_map])\n\t        dataset_id = len(self.datasets)\n\t        self.datasets.append(list(sentences_map.items()))\n\t        self.datasets_iterator.append(0)\n\t        self.dataset_indices.extend([dataset_id] * weight)\n\t    def generate_data(self):\n\t        # Yang B. modification: add the language of each target sentence (if available) and the source text into the InputExample\n\t        source_sentences_list = []\n\t        target_sentences_list = []\n", "        target_languages_list = []\n\t        for data_idx in self.dataset_indices:\n\t            src_sentence, trg_sentences = self.next_entry(data_idx)\n\t            source_sentences_list.append(src_sentence)\n\t            target_sentences_list.append([item[0] for item in trg_sentences])\n\t            target_languages_list.append([item[1] for item in trg_sentences])\n\t        #Generate embeddings\n\t        src_embeddings = self.get_embeddings(source_sentences_list)\n\t        for src_sentence, src_embedding, trg_sentences, trg_languages, data_idx in zip(\n\t                source_sentences_list, \n", "                src_embeddings, \n\t                target_sentences_list, \n\t                target_languages_list, \n\t                self.dataset_indices\n\t            ):\n\t            for trg_sentence, trg_language in zip(trg_sentences, trg_languages):\n\t                self.cache.append(\n\t                    InputExample(\n\t                        src_text=src_sentence, \n\t                        trg_text=trg_sentence, \n", "                        label=src_embedding, \n\t                        lang=trg_language,\n\t                    )\n\t                )\n\t        random.shuffle(self.cache)\n\t    def next_entry(self, data_idx):\n\t        source, target_sentences = self.datasets[data_idx][self.datasets_iterator[data_idx]]\n\t        self.datasets_iterator[data_idx] += 1\n\t        if self.datasets_iterator[data_idx] >= len(self.datasets[data_idx]): #Restart iterator\n\t            self.datasets_iterator[data_idx] = 0\n", "            random.shuffle(self.datasets[data_idx])\n\t        return source, target_sentences\n\t    def get_embeddings(self, sentences):\n\t        # Yang B. modification: if we have loaded numpy file, directly return embeddings\n\t        if self.numpy_path:\n\t            embeddings = [self.embedding_cache[self.source2index[source]] for source in sentences]\n\t            return embeddings\n\t        if self.teacher_model is None:\n\t            return [None for sent in sentences]\n\t        if not self.use_embedding_cache:\n", "            return self.teacher_model.encode(sentences, batch_size=self.batch_size, show_progress_bar=False, convert_to_numpy=True)\n\t        #Use caching\n\t        new_sentences = []\n\t        for sent in sentences:\n\t            if sent not in self.embedding_cache:\n\t                new_sentences.append(sent)\n\t        if len(new_sentences) > 0:\n\t            new_embeddings = self.teacher_model.encode(new_sentences, batch_size=self.batch_size, show_progress_bar=False, convert_to_numpy=True)\n\t            for sent, embedding in zip(new_sentences, new_embeddings):\n\t                self.embedding_cache[sent] = embedding\n", "        return [self.embedding_cache[sent] for sent in sentences]\n\t    def __len__(self):\n\t        return self.num_sentences\n\t    def __getitem__(self, idx):\n\t        if len(self.cache) == 0:\n\t            self.generate_data()\n\t        return self.cache.pop()\n"]}
{"filename": "zeronlg/datasets/CaptionDataset.py", "chunked_list": ["import os\n\timport logging\n\timport torch\n\timport numpy as np\n\timport json\n\timport pickle\n\timport decord\n\tfrom sentence_transformers import LoggingHandler\n\tfrom torch.utils.data import Dataset\n\tfrom PIL import Image\n", "from .. import Framework\n\tfrom ..utils import get_uniform_frame_ids\n\tlogging.basicConfig(format='%(asctime)s - %(message)s',\n\t                    datefmt='%Y-%m-%d %H:%M:%S',\n\t                    level=logging.INFO,\n\t                    handlers=[LoggingHandler()])\n\tglobal_logger = logging.getLogger(__name__)\n\tclass CaptionDataset(Dataset):\n\t    def __init__(self, \n\t                 vision_root: str, \n", "                 ann_rpath: str, \n\t                 num_frames: int = 8, \n\t                 lang: str = None, \n\t                 clip_model: Framework = None, \n\t                 pickle_path: str = None, \n\t                 logger: logging.Logger = None, \n\t                 return_images: bool = False, \n\t                 mean_pooling: bool = False,\n\t                 ):\n\t        if return_images:\n", "            assert pickle_path is None\n\t        else:\n\t            assert clip_model is not None\n\t        self.vision_root = vision_root\n\t        self.lang = lang\n\t        self.num_frames = num_frames\n\t        self.clip_model = clip_model\n\t        self.logger = logger or global_logger\n\t        self.return_images = return_images\n\t        self.mean_pooling = mean_pooling\n", "        self.annotation = json.load(open(ann_rpath, 'r'))\n\t        assert 'image' in self.annotation[0], f'{self.annotation[0]} does not contain the key `image`'\n\t        self.pickle_path = pickle_path\n\t        self.has_been_updated = False\n\t        if pickle_path is not None and os.path.exists(pickle_path):\n\t            self.log(f'Load CLIP embs from {pickle_path}')\n\t            self.rpath2emb = pickle.load(open(pickle_path, 'rb'))\n\t        else:\n\t            self.log(f'CLIP embs does not exist: {pickle_path}')\n\t            self.rpath2emb = {}\n", "        self.rpath2images = {}\n\t    def get_item(self, image_id):\n\t        for index, ann in enumerate(self.annotation):\n\t            if ann['image_id'] == image_id:\n\t                return self.__getitem__(index)\n\t    def __len__(self):\n\t        return len(self.annotation)\n\t    def __getitem__(self, index):\n\t        out = {}\n\t        ann = self.annotation[index]\n", "        out['image_id'] = ann['image_id']\n\t        if 'caption' in ann:\n\t            out['text'] = ann['caption']\n\t        rpath = ann['image']\n\t        if rpath not in self.rpath2emb:\n\t            self.has_been_updated = True\n\t            try:\n\t                image_path = os.path.join(self.vision_root, rpath)\n\t                image = Image.open(image_path).convert('RGB')\n\t                images = [image]\n", "            except:\n\t                video_path = os.path.join(self.vision_root, rpath)\n\t                reader = decord.VideoReader(video_path)\n\t                images = reader.get_batch(get_uniform_frame_ids(len(reader), self.num_frames)).asnumpy()\n\t                images = [Image.fromarray(image) for image in images]\n\t            if self.clip_model is not None:\n\t                output_value = 'token_embeddings' if self.clip_model.get_module_attribute('use_clip_tokens', False) else 'sentence_embedding'\n\t                emb = self.clip_model.encode(images, output_value=output_value, show_progress_bar=False)\n\t                if isinstance(emb, list):\n\t                    emb = torch.stack(emb, dim=0).cpu().numpy()\n", "                out['emb'] = emb\n\t                self.rpath2emb[rpath] = emb\n\t            if self.return_images:\n\t                out['images'] = images\n\t                if self.clip_model is not None:\n\t                    self.rpath2images[rpath] = images\n\t        else:\n\t            out['emb'] = self.rpath2emb[rpath]\n\t            if self.return_images:\n\t                out['images'] = self.rpath2images[rpath]\n", "        out['lang'] = self.lang\n\t        return out\n\t    def log(self, msg):\n\t        self.logger.info(msg)\n\t    def save_pickle(self):\n\t        if self.has_been_updated and self.pickle_path is not None:\n\t            self.log(f'Save CLIP embs to {self.pickle_path}')\n\t            with open(self.pickle_path, 'wb') as wf:\n\t                pickle.dump(self.rpath2emb, wf)\n\t        self.has_been_updated = False\n", "    def collate_fn(self, batch):\n\t        out = {}\n\t        for key in batch[0].keys():\n\t            out[key] = [b[key] for b in batch]\n\t        image_ids = [b['image_id'] for b in batch]\n\t        if 'emb' in batch[0]:\n\t            embs = torch.FloatTensor(np.array([b['emb'] for b in batch]))\n\t            if self.mean_pooling:\n\t                embs = embs.mean(1, keepdims=True)\n\t            return image_ids, embs\n", "        else:\n\t            images = [b['images'] for b in batch]\n\t            return image_ids, images\n\tclass CaptionDatasetForRetrieval(CaptionDataset):\n\t    def __init__(self, \n\t                vision_root: str, \n\t                ann_rpath: str, \n\t                num_frames: int = 8, \n\t                lang: str = None, \n\t                clip_model: Framework = None, \n", "                pickle_path: str = None, \n\t                logger: logging.Logger = None, \n\t                return_images: bool = False, \n\t                mean_pooling: bool = False,\n\t                ):\n\t        super().__init__(\n\t            vision_root=vision_root, \n\t            ann_rpath=ann_rpath, \n\t            num_frames=num_frames, \n\t            lang=lang, \n", "            clip_model=clip_model, \n\t            pickle_path=pickle_path, \n\t            logger=logger, \n\t            return_images=return_images, \n\t            mean_pooling=True, # TODO: we now always apply mean pooling\n\t        )\n\t    def collate_fn(self, batch):\n\t        out = {}\n\t        for key in batch[0].keys():\n\t            out[key] = [b[key] for b in batch]\n", "        image_ids = [b['image_id'] for b in batch]\n\t        texts = []\n\t        for b in batch:\n\t            if isinstance(b['text'], (list, tuple)):\n\t                texts.extend(b['text'])\n\t            else:\n\t                texts.append(b[texts])\n\t        if 'emb' in batch[0]:\n\t            embs = torch.FloatTensor(np.array([b['emb'] for b in batch]))\n\t            if self.mean_pooling:\n", "                embs = embs.mean(1, keepdims=True)\n\t            return image_ids, embs, texts\n\t        else:\n\t            images = [b['images'] for b in batch]\n\t            return image_ids, images, texts\n"]}
{"filename": "tests/test_eval_translate.py", "chunked_list": ["import unittest\n\tfrom zeronlg.utils import translate_eval\n\tclass EvalTranslateTest(unittest.TestCase):\n\t    def test_chinese(self):\n\t        gts = ['一个女孩在舞台上唱歌']\n\t        res = ['一个女孩在唱歌']\n\t        score = translate_eval(gts, res, eval_lang='zh')\n\t        print('zh', score)\n\t    # if you run this test for the first time, it may download stanford-corenlp-4.5.2\n\t    def test_english(self):\n", "        gts = ['a girl is singing on the stage']\n\t        res = ['a girl is singing on the stage']\n\t        score = translate_eval(gts, res, eval_lang='en')\n\t        print('en', score)\n\t        assert score['BLEU'] == 1.0\n\t    def test_german(self):\n\t        gts = ['ein Mädchen singt auf der Bühne']\n\t        res = ['ein Mädchen singt']\n\t        score = translate_eval(gts, res, eval_lang='de')\n\t        print('de', score)\n", "    def test_french(self):\n\t        gts = ['Une fille chante sur scène']\n\t        res = ['Une fille chante']\n\t        score = translate_eval(gts, res, eval_lang='fr')\n\t        print('fr', score)\n\tif \"__main__\" == __name__:\n\t    unittest.main()\n"]}
{"filename": "tests/test_eval_caption.py", "chunked_list": ["import os\n\timport json\n\timport shutil\n\timport unittest\n\tfrom zeronlg.utils import coco_caption_eval\n\tfrom pathlib import Path\n\tclass EvalCaptionTest(unittest.TestCase):\n\t    def setUp(self) -> None:\n\t        self.root = Path(__file__).parent.joinpath(self.__class__.__name__)\n\t        os.makedirs(self.root, exist_ok=True)\n", "    def tearDown(self) -> None:\n\t        shutil.rmtree(self.root)\n\t    # if you run this test for the first time, it may download stanford-corenlp-3.6.0 required by the SPICE metric\n\t    def test_english(self):\n\t        annotation_file = os.path.join(self.root, 'gts.json')\n\t        with open(annotation_file, 'w') as wf:\n\t            json.dump(\n\t                {\n\t                    'annotations': [\n\t                        {\n", "                            \"image_id\": 100,\n\t                            \"caption\": \"a girl is singing on the stage\",\n\t                            \"id\": -1\n\t                        },\n\t                        {\n\t                            \"image_id\": 100,\n\t                            \"caption\": \"a beautiful girl is showing her talents\",\n\t                            \"id\": -1\n\t                        },\n\t                        {\n", "                            \"image_id\": 101,\n\t                            \"caption\": \"a boy is running on the road and wearing a red bag\",\n\t                            \"id\": -1,\n\t                        },\n\t                        {\n\t                            \"image_id\": 101,\n\t                            \"caption\": \"a black boy looks happy and runs\",\n\t                            \"id\": -1,\n\t                        },\n\t                    ],\n", "                    \"images\": [\n\t                        {'id': 100},\n\t                        {'id': 101}\n\t                    ]\n\t                }, wf\n\t            )\n\t        results_file = os.path.join(self.root, 'res.json')\n\t        with open(results_file, 'w') as wf:\n\t            json.dump([\n\t                {'image_id': 100, 'caption': 'a beautiful girl is singing'},\n", "                {'image_id': 101, 'caption': 'a handsome boy is running'}\n\t            ], wf)\n\t        coco_eval = coco_caption_eval(annotation_file, results_file, eval_lang='en')\n\t        print('en', coco_eval.eval)\n\t    def test_chinese(self):\n\t        annotation_file = os.path.join(self.root, 'gts.json')\n\t        with open(annotation_file, 'w') as wf:\n\t            json.dump(\n\t                {\n\t                    'annotations': [\n", "                        {\n\t                            \"image_id\": 100,\n\t                            \"caption\": \"一个女孩在舞台上唱歌\",\n\t                            \"id\": -1\n\t                        },\n\t                        {\n\t                            \"image_id\": 100,\n\t                            \"caption\": \"一个漂亮的女孩在展示她的才华\",\n\t                            \"id\": -1\n\t                        },\n", "                        {\n\t                            \"image_id\": 101,\n\t                            \"caption\": \"一个穿着红色书包的男孩在路上跑\",\n\t                            \"id\": -1,\n\t                        },\n\t                        {\n\t                            \"image_id\": 101,\n\t                            \"caption\": \"一个黑皮肤男孩看起来很开心并在奔跑\",\n\t                            \"id\": -1,\n\t                        },\n", "                    ],\n\t                    \"images\": [\n\t                        {'id': 100},\n\t                        {'id': 101}\n\t                    ]\n\t                }, wf\n\t            )\n\t        results_file = os.path.join(self.root, 'res.json')\n\t        with open(results_file, 'w') as wf:\n\t            json.dump([\n", "                {'image_id': 100, 'caption': '一个漂亮的女孩在唱歌'},\n\t                {'image_id': 101, 'caption': '一个帅气的男孩在奔跑'}\n\t            ], wf)\n\t        coco_eval = coco_caption_eval(annotation_file, results_file, eval_lang='zh')\n\t        print('zh', coco_eval.eval)\n\t    def test_german(self):\n\t        annotation_file = os.path.join(self.root, 'gts.json')\n\t        with open(annotation_file, 'w') as wf:\n\t            json.dump(\n\t                {\n", "                    'annotations': [\n\t                        {\n\t                            \"image_id\": 100,\n\t                            \"caption\": \"Ein Mädchen singt auf der Bühne\",\n\t                            \"id\": -1\n\t                        },\n\t                        {\n\t                            \"image_id\": 100,\n\t                            \"caption\": \"Ein schönes Mädchen zeigt ihre Talente\",\n\t                            \"id\": -1\n", "                        },\n\t                        {\n\t                            \"image_id\": 101,\n\t                            \"caption\": \"Ein Junge in einer roten Schultasche lief auf der Straße\",\n\t                            \"id\": -1,\n\t                        },\n\t                        {\n\t                            \"image_id\": 101,\n\t                            \"caption\": \"Ein schwarzhäutiger Junge sieht glücklich aus und läuft\",\n\t                            \"id\": -1,\n", "                        },\n\t                    ],\n\t                    \"images\": [\n\t                        {'id': 100},\n\t                        {'id': 101}\n\t                    ]\n\t                }, wf\n\t            )\n\t        results_file = os.path.join(self.root, 'res.json')\n\t        with open(results_file, 'w') as wf:\n", "            json.dump([\n\t                {'image_id': 100, 'caption': 'Ein schönes Mädchen singt'},\n\t                {'image_id': 101, 'caption': 'Ein hübscher Junge rennt'}\n\t            ], wf)\n\t        coco_eval = coco_caption_eval(annotation_file, results_file, eval_lang='de')\n\t        print('de', coco_eval.eval)\n\t    def test_french(self):\n\t        annotation_file = os.path.join(self.root, 'gts.json')\n\t        with open(annotation_file, 'w') as wf:\n\t            json.dump(\n", "                {\n\t                    'annotations': [\n\t                        {\n\t                            \"image_id\": 100,\n\t                            \"caption\": \"Une fille chante sur scène\",\n\t                            \"id\": -1\n\t                        },\n\t                        {\n\t                            \"image_id\": 100,\n\t                            \"caption\": \"Une belle fille montre son talent\",\n", "                            \"id\": -1\n\t                        },\n\t                        {\n\t                            \"image_id\": 101,\n\t                            \"caption\": \"Garçon dans un cartable rouge courant sur la route\",\n\t                            \"id\": -1,\n\t                        },\n\t                        {\n\t                            \"image_id\": 101,\n\t                            \"caption\": \"Un garçon à la peau noire semble heureux et court\",\n", "                            \"id\": -1,\n\t                        },\n\t                    ],\n\t                    \"images\": [\n\t                        {'id': 100},\n\t                        {'id': 101}\n\t                    ]\n\t                }, wf\n\t            )\n\t        results_file = os.path.join(self.root, 'res.json')\n", "        with open(results_file, 'w') as wf:\n\t            json.dump([\n\t                {'image_id': 100, 'caption': 'Une belle fille chantant'},\n\t                {'image_id': 101, 'caption': 'Un beau garçon qui court'}\n\t            ], wf)\n\t        coco_eval = coco_caption_eval(annotation_file, results_file, eval_lang='fr')\n\t        print('fr', coco_eval.eval)\n\tif \"__main__\" == __name__:\n\t    unittest.main()\n"]}
{"filename": "tests/test_evaluator_translate.py", "chunked_list": ["import os\n\timport shutil\n\timport unittest\n\tfrom zeronlg import TranslateDataset, TranslateEvaluator, ZeroNLG\n\tfrom torch.utils.data import DataLoader\n\tfrom pathlib import Path\n\tclass EvaluatorTranslateTest(unittest.TestCase):\n\t    def setUp(self) -> None:\n\t        self.root = Path(__file__).parent.joinpath(self.__class__.__name__)\n\t        os.makedirs(self.root, exist_ok=True)\n", "        self.model = ZeroNLG('zeronlg-4langs-vc')\n\t    def tearDown(self) -> None:\n\t        shutil.rmtree(self.root)\n\t    def test_en2zh(self):\n\t        evaluation_settings = {'lang': 'zh'}\n\t        dataset = TranslateDataset(\n\t            source_language='en',\n\t            target_language='zh',\n\t            source_sentences=['a girl is singing', 'a boy is running'],\n\t            target_sentences=['一个女孩在唱歌', '一个男孩在奔跑'],\n", "        )\n\t        loader = DataLoader(\n\t            dataset,\n\t            batch_size=2,\n\t            shuffle=False,\n\t        )\n\t        evaluator = TranslateEvaluator(\n\t            loader=loader,\n\t            evaluation_settings=evaluation_settings,\n\t            mode='val'\n", "        )\n\t        score = evaluator(\n\t            model=self.model,\n\t            output_path=self.root,\n\t            epoch=0,\n\t            steps=100,\n\t            print_sent=True\n\t        )\n\t        print(score)\n\t        loader = DataLoader(\n", "            dataset,\n\t            batch_size=1,\n\t            shuffle=False,\n\t        )\n\t        evaluator = TranslateEvaluator(\n\t            loader=loader,\n\t            evaluation_settings=evaluation_settings,\n\t            mode='val'\n\t        )\n\t        score = evaluator(\n", "            model=self.model,\n\t            output_path=self.root,\n\t            epoch=0,\n\t            steps=100,\n\t            print_sent=True\n\t        )\n\t        print(score)\n\t    def test_zh2en(self):\n\t        evaluation_settings = {'lang': 'en'}\n\t        dataset = TranslateDataset(\n", "            source_language='zh',\n\t            target_language='en',\n\t            source_sentences=['一个女孩在唱歌', '一个男孩在奔跑'],\n\t            target_sentences=['a girl is singing', 'a boy is running'],\n\t        )\n\t        loader = DataLoader(\n\t            dataset,\n\t            batch_size=2,\n\t            shuffle=False,\n\t        )\n", "        evaluator = TranslateEvaluator(\n\t            loader=loader,\n\t            evaluation_settings=evaluation_settings,\n\t            mode='val'\n\t        )\n\t        score = evaluator(\n\t            model=self.model,\n\t            output_path=self.root,\n\t            epoch=0,\n\t            steps=100,\n", "            print_sent=True\n\t        )\n\t        print(score)\n\tif \"__main__\" == __name__:\n\t    unittest.main()\n"]}
{"filename": "tests/test_evaluator_caption.py", "chunked_list": ["import os\n\timport json\n\timport shutil\n\timport unittest\n\tfrom zeronlg import CaptionDataset, CaptionEvaluator, ZeroNLG\n\tfrom torch.utils.data import DataLoader\n\tfrom pathlib import Path\n\timport wget\n\tclass EvaluatorCaptionTest(unittest.TestCase):\n\t    def setUp(self) -> None:\n", "        self.root = Path(__file__).parent.joinpath(self.__class__.__name__)\n\t        os.makedirs(self.root, exist_ok=True)\n\t        self.model = ZeroNLG('zeronlg-4langs-vc')\n\t        wget.download(\n\t            'https://img0.baidu.com/it/u=2179151004,2612321767&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500', \n\t            os.path.join(self.root, '0.jpg')\n\t        )\n\t        ann_rpath = os.path.join(self.root, 'ann.json')\n\t        with open(ann_rpath, 'w') as wf:\n\t            json.dump([{'image': '0.jpg'}], wf)\n", "        gt_file_path = os.path.join(self.root, 'gts.json')\n\t        with open(gt_file_path, 'w') as wf:\n\t            json.dump(\n\t                {\n\t                    'annotations': [\n\t                        {\n\t                            \"image_id\": 0,\n\t                            \"caption\": \"two white and cute dogs\",\n\t                            \"id\": -1\n\t                        },\n", "                    ],\n\t                    \"images\": [\n\t                        {'id': 0},\n\t                    ]\n\t                }, wf\n\t            )\n\t        evaluation_settings = {'lang': 'en'}\n\t        dataset = CaptionDataset(\n\t            vision_root=self.root,\n\t            ann_rpath=ann_rpath,\n", "            lang=evaluation_settings['lang'],\n\t            clip_model=self.model.clip_model,\n\t        )\n\t        loader = DataLoader(\n\t            dataset,\n\t            batch_size=1,\n\t            shuffle=False,\n\t            collate_fn=dataset.collate_fn\n\t        )\n\t        self.evaluator = CaptionEvaluator(\n", "            loader=loader,\n\t            gt_file_path=gt_file_path,\n\t            evaluation_settings=evaluation_settings,\n\t            mode='val'\n\t        )\n\t    def tearDown(self) -> None:\n\t        shutil.rmtree(self.root)\n\t    def test(self):\n\t        score = self.evaluator(\n\t            model=self.model,\n", "            output_path=self.root,\n\t            epoch=0,\n\t            steps=100,\n\t            print_sent=True\n\t        )\n\t        print(score)\n\tif \"__main__\" == __name__:\n\t    unittest.main()\n"]}
