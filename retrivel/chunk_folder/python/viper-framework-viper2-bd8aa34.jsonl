{"filename": "setup.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom setuptools import setup\n\tsetup()\n"]}
{"filename": "viper2/__init__.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom viper2.common.printer import Printer\n\tprinter = Printer()\n"]}
{"filename": "viper2/common/version.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tVIPER_VERSION = \"2.0\"\n"]}
{"filename": "viper2/common/arguments.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport argparse\n\tfrom typing import Optional\n\tclass ArgumentError(Exception):\n\t    pass\n\tclass ArgumentParser(argparse.ArgumentParser):\n\t    def error(self, message: str):\n\t        raise ArgumentError()\n", "    def exit(self, status: Optional[int] = 0, message: Optional[str] = None):\n\t        raise ArgumentError()\n"]}
{"filename": "viper2/common/errors.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tERROR_NO_OPEN_FILE = \"This command expects a session to a file to be open\"\n"]}
{"filename": "viper2/common/sanitize.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tdef sanitize_url(url: str) -> str:\n\t    return url.replace(\"http\", \"hxxp\").replace(\".\", \"[.]\")\n"]}
{"filename": "viper2/common/__init__.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n"]}
{"filename": "viper2/common/module.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom argparse import Namespace\n\tfrom typing import Any, Tuple\n\tfrom .arguments import ArgumentError, ArgumentParser\n\tfrom .file import FileObject\n\tclass ModuleRunError(Exception):\n\t    pass\n\tclass Module:\n", "    cmd = \"\"\n\t    description = \"\"\n\t    def __init__(self) -> None:\n\t        self.args: Namespace\n\t        self.__args_input: Tuple[Any, ...]\n\t        self.args_parser = ArgumentParser(prog=self.cmd, description=self.description)\n\t    def add_args(self, *args: Any) -> None:\n\t        self.__args_input = args\n\t    @staticmethod\n\t    def supports_file(file_object: FileObject) -> bool:\n", "        raise NotImplementedError\n\t    def run(self) -> None:\n\t        try:\n\t            self.args = self.args_parser.parse_args(self.__args_input)\n\t        except ArgumentError as exc:\n\t            raise ModuleRunError() from exc\n"]}
{"filename": "viper2/common/printer.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom typing import Any\n\tfrom rich.console import Console\n\tfrom rich.table import Table\n\tclass Printer:\n\t    def __init__(self):\n\t        self.__console = Console()\n\t    def info(self, msg: str, *args: Any) -> None:\n", "        self.__console.print(msg % args)\n\t    def warning(self, msg: str, *args: Any) -> None:\n\t        self.__console.print(f\"[yellow]WARNING: {msg % args}[/]\")\n\t    def error(self, msg: str, *args: Any) -> None:\n\t        self.__console.print(f\"[red]ERROR: {msg % args}[/]\")\n\t    def success(self, msg: str, *args: Any) -> None:\n\t        self.__console.print(f\"[green]{msg % args}[/]\")\n\t    def table(self, columns, rows) -> None:\n\t        table = Table(show_header=True, header_style=\"bold\")\n\t        for column in columns:\n", "            table.add_column(column)\n\t        for row in rows:\n\t            table.add_row(*row)\n\t        self.__console.print(table)\n"]}
{"filename": "viper2/common/file.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport binascii\n\timport hashlib\n\timport os\n\timport magic\n\t# pylint: disable=too-many-instance-attributes\n\tclass FileObject:\n\t    def __init__(self, path: str):\n", "        self.path = path\n\t        self.name = \"\"\n\t        self.size = 0\n\t        self.magic = \"\"\n\t        self.mime = \"\"\n\t        self.md5 = \"\"\n\t        self.sha1 = \"\"\n\t        self.sha256 = \"\"\n\t        self.sha512 = \"\"\n\t        self.crc32 = \"\"\n", "        self.ssdeep = \"\"\n\t        if os.path.exists(self.path) and os.path.isfile(self.path):\n\t            self.name = os.path.basename(self.path)\n\t            self.size = os.path.getsize(self.path)\n\t            self.magic = magic.from_file(self.path)\n\t            self.mime = magic.from_file(self.path, mime=True)\n\t            self.__hashes()\n\t    @property\n\t    def data(self):\n\t        with open(self.path, \"rb\") as handle:\n", "            return handle.read()\n\t    def get_chunks(self):\n\t        with open(self.path, \"rb\") as handle:\n\t            while True:\n\t                chunk = handle.read(16 * 1024)\n\t                if not chunk:\n\t                    break\n\t                yield chunk\n\t    def __hashes(self):\n\t        crc = 0\n", "        md5 = hashlib.md5()\n\t        sha1 = hashlib.sha1()\n\t        sha256 = hashlib.sha256()\n\t        sha512 = hashlib.sha512()\n\t        for chunk in self.get_chunks():\n\t            crc = binascii.crc32(chunk, crc)\n\t            md5.update(chunk)\n\t            sha1.update(chunk)\n\t            sha256.update(chunk)\n\t            sha512.update(chunk)\n", "        # pylint: disable=consider-using-f-string\n\t        self.crc32 = \"\".join(\"%02X\" % ((crc >> i) & 0xFF) for i in [24, 16, 8, 0])\n\t        self.md5 = md5.hexdigest()\n\t        self.sha1 = sha1.hexdigest()\n\t        self.sha256 = sha256.hexdigest()\n\t        self.sha512 = sha512.hexdigest()\n"]}
{"filename": "viper2/core/database.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport datetime\n\tfrom peewee import (\n\t    CharField,\n\t    DatabaseProxy,\n\t    DateTimeField,\n\t    ForeignKeyField,\n\t    IntegerField,\n", "    Model,\n\t    SqliteDatabase,\n\t    TextField,\n\t)\n\tdatabase_proxy = DatabaseProxy()\n\tclass BaseModel(Model):\n\t    class Meta:  # pylint: disable=too-few-public-methods\n\t        database = database_proxy\n\tclass File(BaseModel):\n\t    name = CharField()\n", "    size = IntegerField()\n\t    magic = CharField()\n\t    mime = CharField()\n\t    md5 = CharField()\n\t    crc32 = CharField()\n\t    sha1 = CharField()\n\t    sha256 = CharField()\n\t    sha512 = CharField()\n\t    ssdeep = CharField()\n\t    created_date = DateTimeField(default=datetime.datetime.now)\n", "    parent = ForeignKeyField(\"self\", backref=\"children\", null=True)\n\tclass Tag(BaseModel):\n\t    file = ForeignKeyField(File, backref=\"tags\")\n\t    name = CharField(unique=True)\n\tclass Note(BaseModel):\n\t    file = ForeignKeyField(File, backref=\"notes\")\n\t    title = CharField()\n\t    body = TextField()\n\tdef init_db(db_path: str) -> None:\n\t    database_proxy.initialize(SqliteDatabase(db_path))\n", "    database_proxy.create_tables([File, Tag, Note])\n"]}
{"filename": "viper2/core/projects.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport logging\n\timport os\n\tfrom .database import init_db\n\tfrom .storage import Storage\n\tlog = logging.getLogger(\"viper\")\n\tPROJECT_DEFAULT = \"default\"\n\t# pylint: disable=too-few-public-methods\n", "class Project:\n\t    def __init__(self, name: str) -> None:\n\t        self.name = name\n\t        if self.name == PROJECT_DEFAULT:\n\t            self.path = Storage().root_path\n\t        else:\n\t            self.path = os.path.join(Storage().projects_path, self.name)\n\t        if not os.path.exists(self.path):\n\t            os.makedirs(self.path)\n\t        init_db(os.path.join(self.path, \"viper.db\"))\n", "    def is_default(self) -> bool:\n\t        if self.name == PROJECT_DEFAULT:\n\t            return True\n\t        return False\n\tclass Projects:\n\t    def __init__(self) -> None:\n\t        self.current = Project(PROJECT_DEFAULT)\n\t    def open(self, name: str) -> None:\n\t        self.current = Project(name)\n\t    def close(self) -> None:\n", "        if self.current and self.current.name != PROJECT_DEFAULT:\n\t            self.current = Project(PROJECT_DEFAULT)\n\t    def list(self) -> list:\n\t        if not os.path.exists(Storage().projects_path):\n\t            return []\n\t        projects_list = []\n\t        for project_name in os.listdir(Storage().projects_path):\n\t            projects_list.append(os.path.join(Storage().projects_path, project_name))\n\t        return projects_list\n\tprojects = Projects()\n"]}
{"filename": "viper2/core/sessions.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport datetime\n\timport os\n\timport time\n\tfrom typing import List, Optional\n\tfrom viper2 import printer\n\tfrom ..common.file import FileObject\n\tfrom .database import File\n", "# pylint: disable=too-few-public-methods\n\tclass Session:\n\t    def __init__(self) -> None:\n\t        self.identifier: int\n\t        self.file: FileObject\n\t        self.created_at = datetime.datetime.fromtimestamp(time.time()).strftime(\n\t            \"%Y-%m-%d %H:%M:%S\"\n\t        )\n\tclass Sessions:\n\t    def __init__(self) -> None:\n", "        self.current: Optional[Session] = None\n\t        self.__sessions: List[Session] = []\n\t        # This is used to keep trace of the results from the last \"find\" command\n\t        # so we can reference them in other commands (primarily \"open\").\n\t        # TODO: However, this is not really the optimal place for this, as\n\t        #       this class is intended only to keep track of currently open\n\t        #       files. Find results are a little off-spec.\n\t        self.__last_find: List[File] = []\n\t    def add_find(self, results: List[File]) -> None:\n\t        self.__last_find = results\n", "    def get_find(self) -> List[File]:\n\t        return self.__last_find\n\t    def all(self) -> List[Session]:\n\t        return self.__sessions\n\t    def close(self) -> None:\n\t        self.current = None\n\t    def reset(self) -> None:\n\t        self.close()\n\t        self.__sessions = []\n\t    def switch(self, session: Session) -> None:\n", "        self.current = session\n\t    def new(self, file_path: str) -> None:\n\t        file_object = FileObject(file_path)\n\t        for session in self.__sessions:\n\t            if session.file and session.file.path == file_path:\n\t                printer.error(\n\t                    \"There is already a session open with file to path %s\",\n\t                    session.file.path,\n\t                )\n\t                return\n", "        if not os.path.exists(file_object.path):\n\t            printer.error(\"File does not exist at path %s\", file_object.path)\n\t            return\n\t        session = Session()\n\t        session.identifier = len(self.__sessions) + 1\n\t        session.file = file_object\n\t        try:\n\t            file = File.get(File.sha256 == file_object.sha256)\n\t        except File.DoesNotExist:  # pylint: disable=no-member\n\t            pass\n", "        else:\n\t            session.file.name = file.name\n\t        self.__sessions.append(session)\n\t        self.current = session\n\t        printer.success(\n\t            \"New session opened to file %s with ID %d\",\n\t            session.file.path,\n\t            session.identifier,\n\t        )\n\tsessions = Sessions()\n"]}
{"filename": "viper2/core/__init__.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n"]}
{"filename": "viper2/core/storage.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport os\n\tfrom platformdirs import user_data_dir\n\tfrom viper2 import printer\n\tfrom ..common.file import FileObject\n\tclass Storage:\n\t    def __init__(self) -> None:\n\t        self.root_path = user_data_dir(\"viper2\", \"viper2\")\n", "        self.projects_path = os.path.join(self.root_path, \"projects\")\n\t    def add_file(self, project_path: str, file_object: FileObject) -> str:\n\t        sha256 = file_object.sha256\n\t        if not sha256:\n\t            printer.error(\"The file does not have a valid sha256 hash\")\n\t            return \"\"\n\t        file_dir = os.path.join(\n\t            project_path, \"files\", sha256[0], sha256[1], sha256[2], sha256[3]\n\t        )\n\t        if not os.path.exists(file_dir):\n", "            os.makedirs(file_dir)\n\t        file_path = os.path.join(file_dir, sha256)\n\t        if os.path.exists(file_path):\n\t            printer.warning(\"The file exists already, skip\")\n\t            return file_path\n\t        with open(file_path, \"wb\") as handle:\n\t            for chunk in file_object.get_chunks():\n\t                handle.write(chunk)\n\t        printer.success(\"Successfully stored file in repository\")\n\t        return file_path\n", "    def get_file_path(self, project_path: str, sha256: str) -> str:\n\t        file_path = os.path.join(\n\t            project_path, \"files\", sha256[0], sha256[1], sha256[2], sha256[3], sha256\n\t        )\n\t        if not os.path.exists(file_path):\n\t            return \"\"\n\t        return file_path\n"]}
{"filename": "viper2/core/modules.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport importlib\n\timport inspect\n\timport os\n\timport pkgutil\n\timport shutil\n\timport sys\n\timport tempfile\n", "from pipreqs import pipreqs  # type: ignore\n\tfrom viper2 import printer\n\tfrom ..common.module import Module\n\tmodules = {}\n\tdef get_module_dependencies(module_path: str) -> list:\n\t    if not os.path.exists(module_path):\n\t        return []\n\t    imports = []\n\t    with tempfile.TemporaryDirectory() as temp_dir:\n\t        shutil.copy(module_path, os.path.join(temp_dir, os.path.basename(module_path)))\n", "        imports = pipreqs.get_all_imports(temp_dir)\n\t    return imports\n\tdef have_dependency(dependency: str) -> bool:\n\t    if dependency == \"viper\":\n\t        return True\n\t    try:\n\t        importlib.import_module(dependency)\n\t    except ModuleNotFoundError:\n\t        return False\n\t    return True\n", "def load_modules(modules_path: str) -> None:\n\t    if not modules_path:\n\t        return\n\t    if not os.path.exists(modules_path):\n\t        printer.error(\"The modules directory does not exist at path: %s\", modules_path)\n\t        return\n\t    sys.path.insert(0, modules_path)\n\t    for _, module_name, ispkg in pkgutil.iter_modules([modules_path]):\n\t        if ispkg:\n\t            continue\n", "        module_path = os.path.join(modules_path, f\"{module_name}.py\")\n\t        dependencies = get_module_dependencies(module_path)\n\t        can_import = True\n\t        for dep in dependencies:\n\t            if not have_dependency(dep):\n\t                can_import = False\n\t                printer.error(\n\t                    \"Module at path %s requires the following missing library: '%s'\",\n\t                    module_path,\n\t                    dep,\n", "                )\n\t        if not can_import:\n\t            printer.error(\"Cannot proceed importing module '%s'\", module_name)\n\t            continue\n\t        try:\n\t            module = importlib.import_module(module_name)\n\t        except ImportError as exc:\n\t            printer.error(\n\t                \"Failed to import module with name '%s': %s\", module_name, exc\n\t            )\n", "            continue\n\t        for member_name, member_object in inspect.getmembers(module):\n\t            if not inspect.isclass(member_object):\n\t                continue\n\t            if issubclass(member_object, Module) and member_object is not Module:\n\t                if not hasattr(member_object, \"cmd\"):\n\t                    printer.error(\n\t                        \"The module %s does not have a `cmd` attribute, cannot load\",\n\t                        member_name,\n\t                    )\n", "                    continue\n\t                # printer.debug(\n\t                #     \"Loaded module %s (%s)\",\n\t                #     member_object.cmd,\n\t                #     member_object.description,\n\t                # )\n\t                modules[member_object.cmd] = {\n\t                    \"class\": member_object,\n\t                    \"description\": member_object.description,\n\t                }\n", "    sys.path.remove(modules_path)\n"]}
{"filename": "viper2/ui/__init__.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport argparse\n\timport shlex\n\tfrom viper2 import printer\n\tfrom ..core.modules import load_modules, modules\n\tfrom ..core.projects import projects\n\tfrom ..core.sessions import sessions\n\tfrom .cmd import load_commands\n", "from .shell import Shell\n\tdef run(cmd: str, modules_path: str) -> None:\n\t    commands = load_commands()\n\t    load_modules(modules_path)\n\t    cmd_words = shlex.split(cmd)\n\t    cmd_name = cmd_words[0].lower().strip()\n\t    cmd_args = cmd_words[1:]\n\t    if cmd_name in commands:\n\t        cmd = commands[cmd_name][\"class\"]()\n\t        cmd.add_args(*cmd_args)\n", "        cmd.run()\n\t    elif cmd_name in modules:\n\t        mod = modules[cmd_name][\"class\"]()\n\t        mod.add_args(*cmd_args)\n\t        mod.run()\n\t    else:\n\t        printer.error('No module or command found for \"%s\"', cmd_name)\n\tdef main() -> None:\n\t    parser = argparse.ArgumentParser(\n\t        prog=\"viper\", description=\"Binary analysis and management framework\"\n", "    )\n\t    parser.add_argument(\n\t        \"-m\",\n\t        \"--modules\",\n\t        action=\"store\",\n\t        metavar=\"MODULES_PATH\",\n\t        help=\"path to a folder containing Viper modules to load\",\n\t    )\n\t    parser.add_argument(\n\t        \"-p\",\n", "        \"--project\",\n\t        action=\"store\",\n\t        metavar=\"PROJECT_NAME\",\n\t        help=\"open a project\",\n\t    )\n\t    parser.add_argument(\n\t        \"-o\",\n\t        \"--open\",\n\t        action=\"store\",\n\t        metavar=\"FILE_PATH\",\n", "        help=\"open a file\",\n\t    )\n\t    parser.add_argument(\n\t        \"-r\",\n\t        \"--run\",\n\t        action=\"store\",\n\t        metavar=\"COMMAND\",\n\t        help=\"run a command or module instead of opening the shell\",\n\t    )\n\t    args = parser.parse_args()\n", "    if args.project:\n\t        projects.open(args.project)\n\t    if args.open:\n\t        sessions.new(args.open)\n\t    if args.run:\n\t        run(cmd=args.run, modules_path=args.modules)\n\t        return\n\t    shell = Shell(modules_path=args.modules)\n\t    shell.run()\n"]}
{"filename": "viper2/ui/logo.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom rich.console import Console\n\tfrom ..common.version import VIPER_VERSION\n\tdef logo():\n\t    console = Console()\n\t    console.print(\n\t        f\"\"\"\n\t[red]  ██    ██ ██ ██████  ███████ ██████ [/]\n", "[yellow]  ██    ██ ██ ██   ██ ██      ██   ██[/]\n\t[green]  ██    ██ ██ ██████  █████   ██████ [/]\n\t[blue]   ██  ██  ██ ██      ██      ██   ██[/]\n\t[magenta]    ████   ██ ██      ███████ ██   ██[/]  [white]v{VIPER_VERSION}[/]\n\t\"\"\"\n\t    )\n"]}
{"filename": "viper2/ui/shell.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport shlex\n\timport subprocess\n\tfrom typing import List, Tuple\n\tfrom prompt_toolkit import PromptSession\n\tfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\n\tfrom prompt_toolkit.shortcuts import clear as prompt_clear\n\tfrom viper2 import printer\n", "from ..core.database import File\n\tfrom ..core.modules import load_modules, modules\n\tfrom ..core.projects import projects\n\tfrom ..core.sessions import sessions\n\tfrom .cmd import load_commands\n\tfrom .logo import logo\n\tclass Shell:\n\t    def __init__(self, modules_path: str = \"\") -> None:\n\t        self.__running: bool = True\n\t        self.__commands: dict = {}\n", "        self.__modules_path: str = modules_path\n\t        self.__modules: dict = {}\n\t    def __welcome(self) -> None:\n\t        logo()\n\t        printer.info(\n\t            \"[magenta]You have [bold]%d[/] file/s in your [bold]%s[/] project[/]\",\n\t            File.select().count(),\n\t            projects.current.name,\n\t        )\n\t    def __prompt(self) -> List[Tuple[str, str]]:\n", "        text = []\n\t        if not projects.current.is_default():\n\t            text.append((\"bold ansicyan\", f\"{projects.current.name} \"))\n\t        text.append((\"ansicyan\", \"viper \"))\n\t        if sessions.current:\n\t            text.append((\"ansigray\", sessions.current.file.name))\n\t            try:\n\t                File.get(File.sha256 == sessions.current.file.sha256)\n\t            except File.DoesNotExist:  # pylint: disable=no-member\n\t                text.append((\"ansimagenta\", \" [not stored]\"))\n", "        text.append((\"ansicyan\", \"> \"))\n\t        return text\n\t    def __expand_args(self, args: List[str]) -> List[str]:\n\t        for index, arg in enumerate(args):\n\t            if arg == \"$file\" and sessions.current:\n\t                args[index] = sessions.current.file.path\n\t        return args\n\t    def exit(self) -> None:\n\t        printer.info(\"Exiting...\")\n\t        self.__running = False\n", "    def help(self) -> None:\n\t        rows = [\n\t            [\"help\", \"Display this help message\"],\n\t            [\"clear\", \"Clear the screen\"],\n\t            [\"exit, quit\", \"Exit from the Viper shell\"],\n\t        ]\n\t        for cmd_name, cmd_properties in self.__commands.items():\n\t            rows.append([cmd_name, cmd_properties[\"description\"]])\n\t        printer.info(\"[bold]Commands:[/]\")\n\t        printer.table(columns=[\"Command\", \"Description\"], rows=rows)\n", "        print(\"\")\n\t        if len(self.__modules) == 0:\n\t            printer.info(\"No modules available\")\n\t            return\n\t        rows = []\n\t        for module_name, module_properties in self.__modules.items():\n\t            rows.append([module_name, module_properties[\"description\"]])\n\t        printer.info(\"[bold]Modules:[/]\")\n\t        printer.table(columns=[\"Module\", \"Description\"], rows=rows)\n\t    def clear(self) -> None:\n", "        prompt_clear()\n\t    def exec(self, cmd_name, cmd_args) -> None:\n\t        with subprocess.Popen([cmd_name] + cmd_args, stdout=subprocess.PIPE) as proc:\n\t            stdout, _ = proc.communicate()\n\t            print(stdout.decode())\n\t    def run(self) -> None:\n\t        self.__welcome()\n\t        self.__commands = load_commands()\n\t        load_modules(self.__modules_path)\n\t        self.__modules = modules\n", "        session: PromptSession = PromptSession()\n\t        while self.__running:\n\t            try:\n\t                self.__prompt()\n\t                cmd_string = session.prompt(\n\t                    self.__prompt(), auto_suggest=AutoSuggestFromHistory()\n\t                )\n\t            except KeyboardInterrupt:\n\t                continue\n\t            except EOFError:\n", "                self.exit()\n\t                continue\n\t            if cmd_string.strip() == \"\":\n\t                continue\n\t            cmd_words = shlex.split(cmd_string)\n\t            cmd_name = cmd_words[0].lower().strip()\n\t            cmd_args = self.__expand_args(cmd_words[1:])\n\t            if cmd_name.startswith(\"!\"):\n\t                self.exec(cmd_name[1:], cmd_args)\n\t                continue\n", "            if cmd_name in (\"exit\", \"quit\"):\n\t                self.exit()\n\t                continue\n\t            if cmd_name == \"help\":\n\t                self.help()\n\t                continue\n\t            if cmd_name == \"clear\":\n\t                self.clear()\n\t                continue\n\t            if cmd_name in self.__commands:\n", "                cmd = self.__commands[cmd_name][\"class\"]()\n\t                cmd.add_args(*cmd_args)\n\t                cmd.run()\n\t                continue\n\t            if cmd_name in self.__modules:\n\t                mod = self.__modules[cmd_name][\"class\"]()\n\t                mod.add_args(*cmd_args)\n\t                mod.run()\n\t                continue\n\t            printer.error('No command or module found for \"%s\"', cmd_name)\n"]}
{"filename": "viper2/ui/cmd/parent.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom viper2 import printer\n\tfrom viper2.common.errors import ERROR_NO_OPEN_FILE\n\tfrom viper2.core.database import File\n\tfrom viper2.core.sessions import sessions\n\tfrom .command import Command\n\tclass Parent(Command):\n\t    cmd = \"parent\"\n", "    description = \"Specify a parent to the currently open file\"\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t        subparsers = self.args_parser.add_subparsers(dest=\"subname\")\n\t        subparsers.add_parser(\"delete\", help=\"Delete the existing parent\")\n\t        add = subparsers.add_parser(\n\t            \"add\", help=\"Add a parent ot the currently open file\"\n\t        )\n\t        add.add_argument(\"parent\", help=\"SHA256 hash of the parent\")\n\t    def run(self) -> None:\n", "        super().run()\n\t        if not sessions.current:\n\t            printer.error(ERROR_NO_OPEN_FILE)\n\t            return\n\t        try:\n\t            file = File.get(File.sha256 == sessions.current.file.sha256)\n\t        except File.DoesNotExist:  # pylint: disable=no-member\n\t            printer.error(\n\t                'The currently open file is not stored, use \"store\" command first'\n\t            )\n", "            return\n\t        if self.args.subname == \"delete\":\n\t            file.parent = None\n\t            file.save()\n\t            printer.success(\"Parent successfully deleted\")\n\t        elif self.args.subname == \"add\":\n\t            if file.parent:\n\t                printer.error(\"The currently open file already has a parent!\")\n\t                return\n\t            if self.args.parent == sessions.current.file.sha256:\n", "                printer.error(\n\t                    \"The specified parent is the same as the currently open file\"\n\t                )\n\t                return\n\t            try:\n\t                parent = File.get(File.sha256 == self.args.parent)\n\t            except File.DoesNotExist:  # pylint: disable=no-member\n\t                printer.error(\n\t                    \"The specified parent with hash %s does not exist\", self.args.parent\n\t                )\n", "                return\n\t            file.parent = parent\n\t            file.save()\n\t            printer.success(\"Successfully added parent\")\n\t        else:\n\t            if not file.parent:\n\t                printer.info(\"The currently open file does not have a parent\")\n\t            else:\n\t                printer.table(\n\t                    columns=[\"Date\", \"Name\", \"SHA1\", \"Magic\", \"Tags\"],\n", "                    rows=[\n\t                        [\n\t                            str(file.parent.created_date),\n\t                            file.parent.name,\n\t                            file.parent.sha1,\n\t                            file.parent.magic,\n\t                            \", \".join(tag.name for tag in file.parent.tags),\n\t                        ]\n\t                    ],\n\t                )\n"]}
{"filename": "viper2/ui/cmd/info.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom typing import cast\n\tfrom viper2 import printer\n\tfrom viper2.common.errors import ERROR_NO_OPEN_FILE\n\tfrom viper2.common.module import Module\n\tfrom viper2.core.database import File, Tag\n\tfrom viper2.core.modules import modules\n\tfrom viper2.core.sessions import sessions\n", "from .command import Command\n\tclass Info(Command):\n\t    cmd = \"info\"\n\t    description = \"Show information on the open file\"\n\t    def run(self) -> None:\n\t        if not sessions.current:\n\t            printer.error(ERROR_NO_OPEN_FILE)\n\t            return\n\t        try:\n\t            file = File.get(File.sha256 == sessions.current.file.sha256)\n", "            tags = Tag.select().where(Tag.file == file)\n\t        except File.DoesNotExist:  # pylint: disable=no-member\n\t            tags_string = \"\"\n\t        else:\n\t            tags_string = \", \".join(tag.name for tag in list(tags))\n\t        printer.table(\n\t            columns=[\"Key\", \"Value\"],\n\t            rows=[\n\t                [\"Name\", sessions.current.file.name],\n\t                [\"Tags\", tags_string],\n", "                [\"Path\", sessions.current.file.path],\n\t                [\"Size\", str(sessions.current.file.size)],\n\t                [\"Magic\", sessions.current.file.magic],\n\t                [\"Mime\", sessions.current.file.mime],\n\t                [\"MD5\", sessions.current.file.md5],\n\t                [\"SHA1\", sessions.current.file.sha1],\n\t                [\"SHA256\", sessions.current.file.sha256],\n\t                [\"SHA512\", sessions.current.file.sha512],\n\t                [\"SSdeep\", sessions.current.file.ssdeep],\n\t                [\"CRC32\", sessions.current.file.crc32],\n", "            ],\n\t        )\n\t        supported_modules = []\n\t        for module_name, module_properties in modules.items():\n\t            mod = cast(Module, module_properties[\"class\"])\n\t            try:\n\t                if mod.supports_file(sessions.current.file):\n\t                    supported_modules.append(\n\t                        [module_name, module_properties[\"description\"]]\n\t                    )\n", "            except NotImplementedError:\n\t                pass\n\t        if len(supported_modules) > 0:\n\t            print(\"\")\n\t            printer.info(\"The following modules support the analysis of this file:\")\n\t            printer.table(columns=[\"Module\", \"Description\"], rows=supported_modules)\n"]}
{"filename": "viper2/ui/cmd/store.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom viper2 import printer\n\tfrom viper2.common.errors import ERROR_NO_OPEN_FILE\n\tfrom viper2.common.file import FileObject\n\tfrom viper2.core.database import File\n\tfrom viper2.core.projects import projects\n\tfrom viper2.core.sessions import sessions\n\tfrom viper2.core.storage import Storage\n", "from .command import Command, CommandRunError\n\tclass Store(Command):\n\t    cmd = \"store\"\n\t    description = \"Store one or multiple files in the database and the local repository\"\n\t    def add_file(self, file_object: FileObject) -> None:\n\t        try:\n\t            File.get(File.sha256 == file_object.sha256)\n\t        except File.DoesNotExist:  # pylint: disable=no-member\n\t            file = File(\n\t                name=file_object.name,\n", "                size=file_object.size,\n\t                magic=file_object.magic,\n\t                mime=file_object.mime,\n\t                md5=file_object.md5,\n\t                crc32=file_object.crc32,\n\t                sha1=file_object.sha1,\n\t                sha256=file_object.sha256,\n\t                sha512=file_object.sha512,\n\t                ssdeep=file_object.ssdeep,\n\t            )\n", "            file.save()\n\t            printer.success(\"Stored file details into database\")\n\t        storage = Storage()\n\t        if not storage.get_file_path(projects.current.path, file_object.sha256):\n\t            new_path = storage.add_file(projects.current.path, file_object)\n\t            printer.success(\"Stored file %s to %s\", file_object.name, new_path)\n\t    def run(self) -> None:\n\t        try:\n\t            super().run()\n\t        except CommandRunError:\n", "            return\n\t        if not sessions.current:\n\t            printer.error(ERROR_NO_OPEN_FILE)\n\t            return\n\t        self.add_file(sessions.current.file)\n"]}
{"filename": "viper2/ui/cmd/projects.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport os\n\timport shutil\n\timport time\n\tfrom prompt_toolkit.shortcuts import confirm\n\tfrom viper2 import printer\n\tfrom viper2.core.projects import projects\n\tfrom viper2.core.sessions import sessions\n", "from .command import Command, CommandRunError\n\tclass Projects(Command):\n\t    cmd = \"projects\"\n\t    description = \"List or switch existing projects\"\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t        group = self.args_parser.add_mutually_exclusive_group()\n\t        group.add_argument(\n\t            \"-l\", \"--list\", action=\"store_true\", help=\"list all existing projects\"\n\t        )\n", "        group.add_argument(\n\t            \"-s\",\n\t            \"--switch\",\n\t            metavar=\"PROJECT NAME\",\n\t            help=\"switch to the specified project (create one if it doesn't exist)\",\n\t        )\n\t        group.add_argument(\n\t            \"-c\",\n\t            \"--close\",\n\t            action=\"store_true\",\n", "            help=\"close the currently open project\",\n\t        )\n\t        group.add_argument(\n\t            \"-d\",\n\t            \"--delete\",\n\t            metavar=\"PROJECT NAME\",\n\t            help=\"delete the specified project\",\n\t        )\n\t    def run(self) -> None:\n\t        try:\n", "            super().run()\n\t        except CommandRunError:\n\t            return\n\t        if self.args.list:\n\t            projects_list = projects.list()\n\t            if len(projects_list) == 0:\n\t                printer.info(\"There are no projects currently\")\n\t                return\n\t            rows = []\n\t            for project_path in projects_list:\n", "                project_name = os.path.basename(project_path)\n\t                project_ct_date = time.ctime(os.path.getctime(project_path))\n\t                rows.append([project_name, project_ct_date])\n\t            printer.table(columns=[\"Project Name\", \"Creation Date\"], rows=rows)\n\t        elif self.args.switch:\n\t            # When we switch project, we reset sessions so that any previously\n\t            # open sessions are closed and removed.\n\t            sessions.reset()\n\t            projects.open(self.args.switch)\n\t            printer.success('Switched to project with name \"%s\"', self.args.switch)\n", "        elif self.args.close:\n\t            # Similarly to switch, if we close the current project, we should\n\t            # also close all active sessions.\n\t            sessions.reset()\n\t            projects.close()\n\t        elif self.args.delete:\n\t            delete = confirm(\n\t                \"Are you sure? This will permanently delete all files in that project!\"\n\t            )\n\t            if not delete:\n", "                return\n\t            if projects.current.name == self.args.delete:\n\t                projects.close()\n\t            for project_path in projects.list():\n\t                if os.path.basename(project_path) == self.args.delete:\n\t                    shutil.rmtree(project_path)\n\t                    printer.success(\n\t                        \"Successfully deleted project at path %s\", project_path\n\t                    )\n\t                    return\n", "            printer.error('Could not find a project with name \"%s\"', self.args.delete)\n\t        else:\n\t            self.args_parser.print_usage()\n"]}
{"filename": "viper2/ui/cmd/children.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom viper2 import printer\n\tfrom viper2.common.errors import ERROR_NO_OPEN_FILE\n\tfrom viper2.core.database import File\n\tfrom viper2.core.sessions import sessions\n\tfrom .command import Command\n\tclass Children(Command):\n\t    cmd = \"children\"\n", "    description = \"Get a list of the open file's children\"\n\t    def run(self) -> None:\n\t        if not sessions.current:\n\t            printer.error(ERROR_NO_OPEN_FILE)\n\t            return\n\t        try:\n\t            file = File.get(File.sha256 == sessions.current.file.sha256)\n\t        except File.DoesNotExist:  # pylint: disable=no-member\n\t            printer.error(\"The currently open file is not stored\")\n\t            return\n", "        rows = []\n\t        for child in file.children:\n\t            rows.append(\n\t                [\n\t                    str(child.created_date),\n\t                    child.name,\n\t                    child.sha1,\n\t                    child.magic,\n\t                    \", \".join(tag.name for tag in child.tags),\n\t                ]\n", "            )\n\t        if len(rows) == 0:\n\t            printer.info(\"The currently open file does not have children\")\n\t            return\n\t        printer.table(columns=[\"Date\", \"Name\", \"SHA1\", \"Magic\", \"Tags\"], rows=rows)\n"]}
{"filename": "viper2/ui/cmd/sessions.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom viper2 import printer\n\tfrom viper2.core.sessions import sessions\n\tfrom .command import Command, CommandRunError\n\tclass Sessions(Command):\n\t    cmd = \"sessions\"\n\t    description = \"List or switch sessions\"\n\t    def __init__(self) -> None:\n", "        super().__init__()\n\t        group = self.args_parser.add_mutually_exclusive_group()\n\t        group.add_argument(\n\t            \"-l\", \"--list\", action=\"store_true\", help=\"list all existing sessions\"\n\t        )\n\t        group.add_argument(\n\t            \"-s\", \"--switch\", type=int, help=\"switch to the specified session\"\n\t        )\n\t    def __list(self) -> None:\n\t        if not sessions.all():\n", "            printer.info(\"There are no open sessions\")\n\t            return\n\t        rows = []\n\t        for session in sessions.all():\n\t            current = \"\"\n\t            if session == sessions.current:\n\t                current = \"Yes\"\n\t            rows.append(\n\t                [\n\t                    str(session.identifier),\n", "                    session.file.name,\n\t                    session.file.sha1,\n\t                    session.created_at,\n\t                    current,\n\t                ]\n\t            )\n\t        printer.info(\"[bold]Open sessions:[/]\")\n\t        printer.table(columns=[\"#\", \"Name\", \"SHA1\", \"Created At\", \"Current\"], rows=rows)\n\t    def __switch(self, identifier: int) -> None:\n\t        for session in sessions.all():\n", "            if identifier == session.identifier:\n\t                sessions.switch(session)\n\t                return\n\t        printer.error(\"The specified session ID doesn't seem to exist\")\n\t    def run(self) -> None:\n\t        try:\n\t            super().run()\n\t        except CommandRunError:\n\t            return\n\t        if self.args.list:\n", "            self.__list()\n\t        elif self.args.switch:\n\t            self.__switch(self.args.switch)\n\t        else:\n\t            self.args_parser.print_usage()\n"]}
{"filename": "viper2/ui/cmd/tags.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport peewee\n\tfrom viper2 import printer\n\tfrom viper2.common.errors import ERROR_NO_OPEN_FILE\n\tfrom viper2.core.database import File, Tag\n\tfrom viper2.core.sessions import sessions\n\tfrom .command import Command, CommandRunError\n\tclass Tags(Command):\n", "    cmd = \"tags\"\n\t    description = \"Tag files in the database\"\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t        subparsers = self.args_parser.add_subparsers(dest=\"subname\")\n\t        subparsers.add_parser(\"list\", help=\"List all existing tags\")\n\t        add = subparsers.add_parser(\"add\", help=\"Add one or more tags to open file\")\n\t        add.add_argument(\n\t            \"-t\", \"--tag\", action=\"append\", help=\"Specify a tag\", required=True\n\t        )\n", "    def list(self) -> None:\n\t        tags = Tag.select(Tag.name).distinct(True)\n\t        for tag in list(tags):\n\t            print(tag.name)\n\t    def add(self, tags) -> None:\n\t        if not sessions.current:\n\t            printer.error(ERROR_NO_OPEN_FILE)\n\t            return\n\t        try:\n\t            file = File.get(File.sha256 == sessions.current.file.sha256)\n", "        except File.DoesNotExist:  # pylint: disable=no-member\n\t            printer.error(\n\t                \"The currently open file is not stored in the database, \"\n\t                'use \"store\" command first'\n\t            )\n\t            return\n\t        for tag in tags:\n\t            try:\n\t                new_tag = Tag(name=tag, file=file)\n\t                new_tag.save()\n", "            except peewee.IntegrityError:\n\t                printer.error('The tag \"%s\" already exists', tag)\n\t    def run(self) -> None:\n\t        try:\n\t            super().run()\n\t        except CommandRunError:\n\t            return\n\t        if self.args.subname == \"list\":\n\t            self.list()\n\t        elif self.args.subname == \"add\":\n", "            self.add(self.args.tag)\n"]}
{"filename": "viper2/ui/cmd/__init__.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom .about import About\n\tfrom .children import Children\n\tfrom .close import Close\n\tfrom .export import Export\n\tfrom .find import Find\n\tfrom .info import Info\n\tfrom .open import Open\n", "from .parent import Parent\n\tfrom .projects import Projects\n\tfrom .sessions import Sessions\n\tfrom .store import Store\n\tfrom .tags import Tags\n\tdef load_commands() -> dict:\n\t    return {\n\t        About.cmd: {\"class\": About, \"description\": About.description},\n\t        Children.cmd: {\"class\": Children, \"description\": Children.description},\n\t        Close.cmd: {\"class\": Close, \"description\": Close.description},\n", "        Export.cmd: {\"class\": Export, \"description\": Export.description},\n\t        Info.cmd: {\"class\": Info, \"description\": Info.description},\n\t        Find.cmd: {\"class\": Find, \"description\": Find.description},\n\t        Open.cmd: {\"class\": Open, \"description\": Open.description},\n\t        Parent.cmd: {\"class\": Parent, \"description\": Parent.description},\n\t        Projects.cmd: {\"class\": Projects, \"description\": Projects.description},\n\t        Sessions.cmd: {\"class\": Sessions, \"description\": Sessions.description},\n\t        Store.cmd: {\"class\": Store, \"description\": Store.description},\n\t        Tags.cmd: {\"class\": Tags, \"description\": Tags.description},\n\t    }\n"]}
{"filename": "viper2/ui/cmd/close.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom viper2.core.sessions import sessions\n\tfrom .command import Command\n\tclass Close(Command):\n\t    cmd = \"close\"\n\t    description = \"Close the current session\"\n\t    def run(self) -> None:\n\t        sessions.close()\n"]}
{"filename": "viper2/ui/cmd/find.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom viper2 import printer\n\tfrom viper2.core.database import File, Tag\n\tfrom viper2.core.sessions import sessions\n\tfrom .command import Command, CommandRunError\n\tclass Find(Command):\n\t    cmd = \"find\"\n\t    description = \"Find files stored in the database and local repository\"\n", "    def __init__(self) -> None:\n\t        super().__init__()\n\t        self.args_parser.add_argument(\n\t            \"key\",\n\t            nargs=\"?\",\n\t            choices=[\n\t                \"all\",\n\t                \"name\",\n\t                \"magic\",\n\t                \"mime\",\n", "                \"md5\",\n\t                \"sha1\",\n\t                \"sha256\",\n\t                \"tag\",\n\t                \"note\",\n\t                \"ssdeep\",\n\t            ],\n\t            help=\"search key\",\n\t        )\n\t        self.args_parser.add_argument(\n", "            \"value\", nargs=\"?\", help=\"search value or pattern\"\n\t        )\n\t    def run(self) -> None:\n\t        try:\n\t            super().run()\n\t        except CommandRunError:\n\t            return\n\t        match self.args.key:\n\t            case \"all\":\n\t                files = File.select().order_by(File.created_date)\n", "            case \"name\":\n\t                files = File.select().where(File.name.contains(self.args.value))\n\t            case \"magic\":\n\t                files = File.select().where(File.magic.contains(self.args.value))\n\t            case \"mime\":\n\t                files = File.select().where(File.mime.contains(self.args.value))\n\t            case \"md5\":\n\t                files = File.select().where(File.md5 == self.args.value)\n\t            case \"sha1\":\n\t                files = File.select().where(File.sha1 == self.args.value)\n", "            case \"sha256\":\n\t                files = File.select().where(File.sha256 == self.args.value)\n\t            case \"sha512\":\n\t                files = File.select().where(File.sha512 == self.args.value)\n\t            case \"tag\":\n\t                files = (\n\t                    File.select()\n\t                    .join(Tag, on=Tag.file == File.id)  # pylint: disable=no-member\n\t                    .where(Tag.name.contains(self.args.value))\n\t                )\n", "            case \"note\":\n\t                # TODO\n\t                files = []\n\t            case \"ssdeep\":\n\t                files = File.select().where(File.ssdeep.contains(self.args.value))\n\t        if len(files) == 0:\n\t            printer.info(\"No matching results\")\n\t            return\n\t        sessions.add_find(files)\n\t        rows = []\n", "        counter = 1\n\t        for file in files:\n\t            tags = \", \".join(tag.name for tag in file.tags)\n\t            rows.append(\n\t                [\n\t                    str(counter),\n\t                    str(file.created_date),\n\t                    file.name,\n\t                    file.sha1,\n\t                    file.magic,\n", "                    tags,\n\t                ]\n\t            )\n\t            counter += 1\n\t        printer.table(columns=[\"#\", \"Date\", \"Name\", \"SHA1\", \"Magic\", \"Tags\"], rows=rows)\n"]}
{"filename": "viper2/ui/cmd/open.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport os\n\tfrom viper2 import printer\n\tfrom viper2.core.projects import projects\n\tfrom viper2.core.sessions import sessions\n\tfrom viper2.core.storage import Storage\n\tfrom .command import Command, CommandRunError\n\tclass Open(Command):\n", "    cmd = \"open\"\n\t    description = \"Open a session to a file\"\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t        self.args_parser.add_argument(\n\t            \"-f\", \"--file\", action=\"store\", help=\"open the file specified at path\"\n\t        )\n\t        self.args_parser.add_argument(\n\t            \"-l\",\n\t            \"--last\",\n", "            action=\"store\",\n\t            help=\"# of a result from the last `find` command\",\n\t        )\n\t    def run(self) -> None:\n\t        try:\n\t            super().run()\n\t        except CommandRunError:\n\t            return\n\t        if self.args.file:\n\t            if not os.path.exists(self.args.file):\n", "                printer.error(\n\t                    \"The specified file at path %s does not exist\", self.args.file\n\t                )\n\t                return\n\t            sessions.new(self.args.file)\n\t        elif self.args.last:\n\t            for idx, entry in enumerate(sessions.get_find(), start=1):\n\t                if idx == int(self.args.last):\n\t                    sessions.new(\n\t                        Storage().get_file_path(\n", "                            projects.current.path, str(entry.sha256)\n\t                        )\n\t                    )\n\t                    return\n\t            printer.error(\"Did not find a last find entry with the provided #\")\n\t        else:\n\t            self.args_parser.print_usage()\n"]}
{"filename": "viper2/ui/cmd/about.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport platform\n\timport sys\n\tfrom viper2 import printer\n\tfrom viper2.common.version import VIPER_VERSION\n\tfrom .command import Command\n\tclass About(Command):\n\t    cmd = \"about\"\n", "    description = \"Show information about Viper 2\"\n\t    def run(self) -> None:\n\t        rows = []\n\t        rows.append([\"Viper Version\", VIPER_VERSION])\n\t        rows.append([\"Python executable\", sys.executable])\n\t        rows.append([\"Python Version\", platform.python_version()])\n\t        printer.table(columns=[\"Key\", \"Value\"], rows=rows)\n"]}
{"filename": "viper2/ui/cmd/export.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\timport os\n\timport shutil\n\tfrom viper2 import printer\n\tfrom viper2.common.errors import ERROR_NO_OPEN_FILE\n\tfrom viper2.core.sessions import sessions\n\tfrom .command import Command\n\tclass Export(Command):\n", "    cmd = \"export\"\n\t    description = \"Export the currently open file to a destionation path\"\n\t    def __init__(self) -> None:\n\t        super().__init__()\n\t        self.args_parser.add_argument(\n\t            \"dst\", help=\"Destination path to export the file to\"\n\t        )\n\t    def run(self) -> None:\n\t        super().run()\n\t        if not sessions.current:\n", "            printer.error(ERROR_NO_OPEN_FILE)\n\t            return\n\t        if not self.args.dst:\n\t            printer.error(\"You need to specify a destionation path\")\n\t            return\n\t        dst = self.args.dst\n\t        # If the specified destination path exists and it is a folder, we use\n\t        # the file name from the original file for the destination too.\n\t        if os.path.isdir(self.args.dst):\n\t            dst = os.path.join(self.args.dst, sessions.current.file.name)\n", "        printer.info(\"Exporting file %s to %s\", sessions.current.file.path, dst)\n\t        shutil.copy2(sessions.current.file.path, dst)\n"]}
{"filename": "viper2/ui/cmd/command.py", "chunked_list": ["# Copyright 2023 The viper2 Authors. All rights reserved.\n\t# Use of this source code is governed by a BSD-style\n\t# license that can be found in the LICENSE file.\n\tfrom argparse import Namespace\n\tfrom typing import Any, Tuple\n\tfrom viper2.common.arguments import ArgumentError, ArgumentParser\n\tclass CommandRunError(Exception):\n\t    pass\n\tclass Command:\n\t    cmd = \"\"\n", "    description = \"\"\n\t    def __init__(self) -> None:\n\t        self.args: Namespace\n\t        self.__args_input: Tuple[Any, ...]\n\t        self.args_parser = ArgumentParser(prog=self.cmd, description=self.description)\n\t    def add_args(self, *args: Any) -> None:\n\t        self.__args_input = args\n\t    def run(self) -> None:\n\t        try:\n\t            self.args = self.args_parser.parse_args(self.__args_input)\n", "        except ArgumentError as exc:\n\t            raise CommandRunError() from exc\n"]}
