{"filename": "test/test_parse_mol_block.py", "chunked_list": ["from rdfreader.parse.molblock import _parse_large_regno, get_mol_block_metadata\n\tdef test_parse_large_regno():\n\t    assert _parse_large_regno([\"\", \"M  REG     0123456    \\n\", \"\"]) == \"0123456\"\n\tdef test_get_mol_block_metadata(sample_mol_block, sample_molecule_metadata):\n\t    \"\"\"Components of this function are tested seperately, only need to test the\n\t    once for integration.\"\"\"\n\t    expected_result = sample_molecule_metadata\n\t    test_result = get_mol_block_metadata(sample_mol_block)\n\t    assert test_result == expected_result\n"]}
{"filename": "test/test_molecule.py", "chunked_list": ["from rdkit.Chem import Mol, MolFromMolBlock, MolToSmiles\n\tfrom rdfreader.chem.mol import Molecule\n\tdef assert_molecule_from_mol_block(mol: Molecule, mol_block: str):\n\t    \"\"\"Assert that a molecule object created from a mol block string has the\n\t    correct properties.\"\"\"\n\t    assert mol.rd_mol is not None\n\t    assert mol.mol_block == mol_block\n\tdef test_molecule_from_mol_block(sample_mol_block):\n\t    \"\"\"Test that the Molecule.from_mol_block method works, creating a Molecule\n\t    object from a mol block string and correctly creates class attributes.\"\"\"\n", "    mol = Molecule.from_mol_block(sample_mol_block)\n\t    assert_molecule_from_mol_block(mol, sample_mol_block)\n\tdef test_molecule_init_from_mol_block(sample_mol_block):\n\t    \"\"\"Test we can init a molecule object directly by passing a mol block\n\t    string.\"\"\"\n\t    mol = Molecule(sample_mol_block)\n\t    assert_molecule_from_mol_block(mol, sample_mol_block)\n\tdef test_create_empty_molecule():\n\t    \"\"\"Test that a Molecule object can be created without a mol block\n\t    string.\"\"\"\n", "    mol = Molecule()\n\t    assert mol.mol_block is None\n\tdef test_molecule_to_rdkit_mol(sample_molecule, sample_mol_block):\n\t    \"\"\"Test the Molecule.rd_mol property.\"\"\"\n\t    rd_mol: Mol = sample_molecule.rd_mol\n\t    # can't directly compare Mol objects, so we'll just check that it is of\n\t    # the right type and is not None\n\t    assert rd_mol is not None\n\t    assert isinstance(rd_mol, Mol)\n\tdef test_molecule_to_smiles(sample_molecule, sample_mol_block):\n", "    \"\"\"Test the output of the Molecule.smiles property.\n\t    Verifies the smiles matches that output by RDKit.\n\t    \"\"\"\n\t    rd_mol: Mol = MolFromMolBlock(sample_mol_block)\n\t    rd_smiles: str = MolToSmiles(rd_mol)\n\t    assert sample_molecule.smiles == rd_smiles\n\tdef test_molecule_metadata(sample_molecule, sample_molecule_metadata):\n\t    \"\"\"Test the Molecule.metadata property.\"\"\"\n\t    assert sample_molecule.metadata == sample_molecule_metadata\n\tdef test_molecule_from_smiles():\n", "    \"\"\"Test the Molecule.from_smiles method.\"\"\"\n\t    smiles = \"OCO\"\n\t    mol = Molecule.from_smiles(smiles)\n\t    assert mol.rd_mol is not None\n\t    assert mol.smiles == smiles\n"]}
{"filename": "test/test_write.py", "chunked_list": ["from tempfile import NamedTemporaryFile\n\tfrom rdfreader.write import write_rdf\n\tdef test_write_rdf(first_sample_rxn):\n\t    with NamedTemporaryFile(\"w+\", suffix=\"rdf\") as f:\n\t        rxn_blocks = [first_sample_rxn] * 3\n\t        write_rdf(f, rxn_blocks, [0, 1, 2])\n\t        f.seek(0)\n\t        rdf_text = f.read()\n\t        # $RXN should occur once for each reaction block\n\t        assert rdf_text.count(\"$RXN\") == len(rxn_blocks)\n", "        # first line should start with $RDFILE\n\t        assert rdf_text.startswith(\"$RDFILE\")\n"]}
{"filename": "test/test_reaction.py", "chunked_list": ["# Typing\n\tfrom unittest.mock import MagicMock\n\timport pytest\n\tfrom rdfreader.chem.reaction import Reaction\n\tdef test_reaction_from_rxn_block(sample_rxn_block, sample_rxn_block_metadata):\n\t    reaction = Reaction(sample_rxn_block)\n\t    assert isinstance(reaction, Reaction)\n\t    assert reaction.metadata == sample_rxn_block_metadata\n\t    assert reaction.rxn_block == sample_rxn_block\n\t    assert reaction.rd_rxn is not None\n", "    # TODO: check reaction properties match\n\tdef test_reaction_from_rxn_block_invalid_raises():\n\t    with pytest.raises(ValueError):\n\t        Reaction(\"invalid rxn block\")\n\tdef test_reaction_from_rxn_block_empty_raises():\n\t    with pytest.raises(ValueError):\n\t        Reaction(\"\")\n\tdef test_reaction_to_smiles(mocker, sample_rxn_block):\n\t    \"\"\"Test that the reaction_to_smiles function gets called.\"\"\"\n\t    reaction_smiles_patch: MagicMock = mocker.patch(\"rdfreader.chem.reaction.reaction_smiles\", return_value=\"CC>>CC\")\n", "    # give a dummy smiles just so the validation check within\n\t    # Reaction.from_rxn_block() passes\n\t    reaction: Reaction = Reaction(sample_rxn_block)\n\t    reaction.smiles\n\t    reaction_smiles_patch.assert_called()\n\t    # not _once because the reaction_to_smiles function is also called when\n\t    # the Reaction object is instantiated\n\tdef test_reaction_to_smiles_no_reagents(mocker, sample_rxn_block):\n\t    \"\"\"Test that the reaction_to_smiles function gets called.\"\"\"\n\t    reaction_smiles_patch: MagicMock = mocker.patch(\"rdfreader.chem.reaction.reaction_smiles\", return_value=\"CC>>CC\")\n", "    # give a dummy smiles just so the validation check within\n\t    # Reaction.from_rxn_block() passes\n\t    reaction: Reaction = Reaction(sample_rxn_block)\n\t    reaction.smiles_no_reagents\n\t    reaction_smiles_patch.assert_called()\n"]}
{"filename": "test/test_rdf.py", "chunked_list": ["from unittest.mock import MagicMock\n\timport pytest\n\tfrom pytest_mock import MockerFixture\n\tfrom rdfreader.chem.reaction import Reaction\n\tfrom rdfreader.exceptions import InvalidReactionError\n\tfrom rdfreader.rdf import RDFParser, parse_rdf_reg_num\n\t@pytest.fixture\n\tdef sample_rdf_file() -> str:\n\t    return \"test/resources/spresi-100.rdf\"\n\tdef test_parse_rdf_reg_num():\n", "    reg_num = parse_rdf_reg_num(\"$RFMT $RIREG 4620744\")\n\t    assert reg_num == \"4620744\"\n\tdef test_parse_rdf(sample_rdf_file: str):\n\t    with open(sample_rdf_file, \"r\") as f:\n\t        rdf_parser = RDFParser(f)\n\t        reactions = [reaction for reaction in rdf_parser]\n\t    assert len(reactions) == 100\n\t    # we can't test all 100 reactions in all this detail, so we'll just check the first two\n\t    expected_reaction_ids = [\"1274842\", \"808226\"]\n\t    expected_line_numbers = [3, 212]\n", "    expected_product_counts = [1, 1]\n\t    expected_reactant_counts = [3, 2]\n\t    expected_catalyst_counts = [1, 1]\n\t    expected_solvent_counts = [0, 0]\n\t    expected_other_reagent_counts = [0, 0]\n\t    for reaction, eid, lineno, product_count, reactant_count, catalyst_count, solvent_count, other_count in zip(\n\t        reactions,\n\t        expected_reaction_ids,\n\t        expected_line_numbers,\n\t        expected_product_counts,\n", "        expected_reactant_counts,\n\t        expected_catalyst_counts,\n\t        expected_solvent_counts,\n\t        expected_other_reagent_counts,\n\t    ):\n\t        assert reaction.id == eid\n\t        assert reaction.lineno == lineno\n\t        assert reaction.rdf_metadata == {\n\t            \"version\": \"1\",\n\t            \"date_stamp\": \"02/12/04 11:58\",\n", "        }\n\t        assert len(reaction.products) == product_count\n\t        assert len(reaction.reactants) == reactant_count\n\t        assert len(reaction.catalysts) == catalyst_count\n\t        assert len(reaction.solvents) == solvent_count\n\t        assert len(reaction.other_reagents) == other_count\n\t@pytest.fixture\n\tdef reaction_raise_exception(mocker: MockerFixture) -> MagicMock:\n\t    mocker.patch.object(Reaction, \"__init__\", side_effect=InvalidReactionError(\"Test exception\"))\n\tdef test_parse_rdf_catches(reaction_raise_exception: MagicMock, sample_rdf_file: str):\n", "    with open(sample_rdf_file, \"r\") as f:\n\t        rdf_parser = RDFParser(f, except_on_invalid_reaction=False)\n\t        reactions = [reaction for reaction in rdf_parser]\n\t    for reaction in reactions:\n\t        assert reaction is None\n\tdef test_parse_rdf_raises(reaction_raise_exception: MagicMock, sample_rdf_file: str):\n\t    with pytest.raises(InvalidReactionError):\n\t        with open(sample_rdf_file, \"r\") as f:\n\t            rdf_parser = RDFParser(f)\n\t            [reaction for reaction in rdf_parser]\n"]}
{"filename": "test/test_parse_utils.py", "chunked_list": ["import datetime\n\timport pytest\n\tfrom rdfreader.parse.utils import (\n\t    CTF_DEFAULT_LETTER_TO_FIELD_MAPPING,\n\t    CTF_DEFAULT_MOLBLOCK_HEADER_FORMAT_STRING,\n\t    CTF_RXNBLOCK_HEADER_FORMAT_STRING,\n\t    _default_line_item,\n\t    _parse_block_header_line,\n\t    dict_elements_to_datetime,\n\t    get_line_item,\n", "    get_whole_line_item,\n\t    make_string_python_safe,\n\t    parse_format_string,\n\t    parse_yield,\n\t)\n\tdef test_default_line_item_string():\n\t    assert _default_line_item(str) == \"\"\n\tdef test_default_line_item_string_non_default():\n\t    assert _default_line_item(str, \"default\") == \"default\"\n\tdef test_default_line_item_int():\n", "    assert _default_line_item(int) == 0\n\tdef test_default_line_item_int_non_default():\n\t    assert _default_line_item(int, 10) == 10\n\tdef test_default_line_item_float():\n\t    assert _default_line_item(float) == 0.0\n\tdef test_default_line_item_floa_non_default():\n\t    assert _default_line_item(float, 0.1) == 0.1\n\tdef test_default_line_item_other():\n\t    \"\"\"Test that None is returned when not using string, int, or float.\"\"\"\n\t    assert _default_line_item(list, None) is None\n", "def test_get_line_item_string():\n\t    assert get_line_item(\"line      \\n\", (0, 2)) == \"li\"\n\tdef test_get_line_item_empty_string():\n\t    assert get_line_item(\"\") == \"\"\n\tdef test_get_line_item_empty_string_default():\n\t    assert get_line_item(\"\", default=\"default\") == \"default\"\n\tdef test_get_line_item_int():\n\t    assert get_line_item(\"12      \\n\", (0, 2), int) == 12\n\tdef test_get_line_item_empty_int():\n\t    assert get_line_item(\"\", cast_type=int) == 0\n", "def test_get_line_item_empty_int_default():\n\t    assert get_line_item(\"\", cast_type=int, default=12) == 12\n\tdef test_get_line_item_float():\n\t    assert get_line_item(\"12      \\n\", (0, 2), float) == 12\n\tdef test_get_line_item_empty_float():\n\t    assert get_line_item(\"\", cast_type=float) == 0.0\n\tdef test_get_line_item_empty_float_default():\n\t    assert get_line_item(\"\", cast_type=float, default=12.0) == 12.0\n\tdef test_get_line_item_casting_exceptions_thrown():\n\t    with pytest.raises(ValueError):\n", "        get_line_item(\"12.0\", cast_type=int, catch_casting_exceptions=False)\n\tdef test_get_line_item_casting_exceptions_caught():\n\t    assert (\n\t        get_line_item(\n\t            \"12.0\",\n\t            cast_type=int,\n\t            catch_casting_exceptions=True,\n\t            default=\"default\",\n\t        )\n\t        == \"default\"\n", "    )\n\tdef test_parse_format_string():\n\t    format_string = \"IIIIIIPPPPPPPPPMMDDYYYYHHmmRRRRRRR\"\n\t    expected_result = {\n\t        \"I\": (0, 6),\n\t        \"P\": (6, 15),\n\t        \"M\": (15, 17),\n\t        \"D\": (17, 19),\n\t        \"Y\": (19, 23),\n\t        \"H\": (23, 25),\n", "        \"m\": (25, 27),\n\t        \"R\": (27, 34),\n\t    }\n\t    assert parse_format_string(format_string) == expected_result\n\tdef test_dict_elements_to_datetime():\n\t    \"\"\"Test that a dictionary of elements can be converted to a datetime\n\t    object.\"\"\"\n\t    elements = {\n\t        \"month\": 1,\n\t        \"day\": 2,\n", "        \"year\": 3,\n\t        \"hour\": 4,\n\t        \"minute\": 5,\n\t        \"test\": \"test\",\n\t    }\n\t    expected_result = {\n\t        \"test\": \"test\",  # ensure non-datetime elements are not modified\n\t        \"date_time\": datetime.datetime(\n\t            year=3,\n\t            month=1,\n", "            day=2,\n\t            hour=4,\n\t            minute=5,\n\t        ),\n\t    }\n\t    assert dict_elements_to_datetime(elements) == expected_result\n\tdef test_parse_block_header_line_with_molblock(sample_mol_block_lines, sample_molecule_metadata):\n\t    expected_result = sample_molecule_metadata\n\t    expected_result[\"registry_number\"] = \"RRRRRR\"\n\t    # This is the only thing that is different from the\n", "    # sample_molecule_metadata as the large regno is parsed seperately.\n\t    # comment and name are held elsewhere, delete them from the dict\n\t    del expected_result[\"comment\"]\n\t    del expected_result[\"molecule_name\"]\n\t    test_result = _parse_block_header_line(\n\t        sample_mol_block_lines[1],\n\t        CTF_DEFAULT_MOLBLOCK_HEADER_FORMAT_STRING,\n\t        CTF_DEFAULT_LETTER_TO_FIELD_MAPPING,\n\t    )\n\t    assert test_result == expected_result\n", "def test_parse_block_header_line_with_molblock_defaults():\n\t    expected_result = dict(\n\t        user_initials=\"\",\n\t        program_name=\"\",\n\t        date_time=None,\n\t        dimensional_codes=\"\",\n\t        scaling_factor_1=0,\n\t        scaling_factor_2=0.0,\n\t        energy=0.0,\n\t        registry_number=\"\",\n", "    )\n\t    test_result = _parse_block_header_line(\n\t        \"\",\n\t        CTF_DEFAULT_MOLBLOCK_HEADER_FORMAT_STRING,\n\t        CTF_DEFAULT_LETTER_TO_FIELD_MAPPING,\n\t    )\n\t    assert test_result == expected_result\n\tdef test_parse_block_header_line_with_rxnblock(sample_rxn_block_lines, sample_rxn_block_metadata):\n\t    expected_result = sample_rxn_block_metadata\n\t    for absent_key in [\n", "        \"comment\",\n\t        \"reaction_name\",\n\t        \"reactant_count\",\n\t        \"product_count\",\n\t    ]:\n\t        del expected_result[absent_key]  # not present in this line\n\t    test_result = _parse_block_header_line(\n\t        sample_rxn_block_lines[2],\n\t        CTF_RXNBLOCK_HEADER_FORMAT_STRING,\n\t        CTF_DEFAULT_LETTER_TO_FIELD_MAPPING,\n", "    )\n\t    assert test_result == expected_result\n\tdef test_parse_block_header_line_with_rxnblock_defaults():\n\t    expected_result = dict(\n\t        user_initials=\"\",\n\t        program_name=\"\",\n\t        date_time=None,\n\t        registry_number=\"\",\n\t    )\n\t    test_result = _parse_block_header_line(\n", "        \"\",\n\t        CTF_RXNBLOCK_HEADER_FORMAT_STRING,\n\t        CTF_DEFAULT_LETTER_TO_FIELD_MAPPING,\n\t    )\n\t    assert test_result == expected_result\n\tdef test_get_whole_line_item():\n\t    \"\"\"Test that a line item can be retrieved from a line.\"\"\"\n\t    line = \"line      \\n\"\n\t    assert get_whole_line_item(line) == \"line\"\n\t@pytest.mark.parametrize(\n", "    \"test_string,expected_result\",\n\t    [\n\t        (\"\", None),\n\t        (\" \", None),\n\t        (\" \\n\\r1_:;'/test`string\\n __\", \"_1_test_string\"),\n\t    ],\n\t)\n\tdef test_make_string_python_safe(test_string, expected_result):\n\t    test_result = make_string_python_safe(test_string)\n\t    assert test_result == expected_result\n", "def test_parse_yield():\n\t    test_strings = [\n\t        \"17.0-17.0\",\n\t        \"17\",\n\t        \"17-17\",\n\t        \"17.0 -- 17.0\",\n\t        \"17 - 17\",\n\t        \"17 -17\",\n\t        \"17- 17\",\n\t        \"17.0\",\n", "        \"17  17\",\n\t        \"17;17\",\n\t        \"17:17\",\n\t        \"17,17\",\n\t        \"16-18\",\n\t    ]\n\t    expected_result = 17.0\n\t    for test_string in test_strings:\n\t        assert parse_yield(test_string) == expected_result\n\tdef test_parse_yield_none():\n", "    \"\"\"Test that None is returned if the yield cannot be parsed.\"\"\"\n\t    test_strings = [\"some text\", \"-1\"]\n\t    for test_string in test_strings:\n\t        assert parse_yield(test_string) is None\n"]}
{"filename": "test/test_chem_utils.py", "chunked_list": ["import pytest\n\tfrom rdfreader.chem.mol import Molecule\n\tfrom rdfreader.chem.utils import mol_list_to_smiles, reaction_smiles\n\t@pytest.fixture\n\tdef molecule_list() -> list[Molecule]:\n\t    return [\n\t        Molecule.from_smiles(\"C\"),\n\t        Molecule.from_smiles(\"CO\"),\n\t        Molecule.from_smiles(\"OCO\"),\n\t    ]\n", "@pytest.fixture\n\tdef molecule_list_smiles() -> str:\n\t    return \"C.CO.OCO\"\n\tdef test_mol_list_to_smiles(molecule_list, molecule_list_smiles):\n\t    assert mol_list_to_smiles(molecule_list) == molecule_list_smiles\n\tdef test_reaction_to_smiles(molecule_list, molecule_list_smiles):\n\t    assert (\n\t        reaction_smiles(molecule_list, molecule_list, molecule_list)\n\t        == f\"{molecule_list_smiles}>{molecule_list_smiles}>{molecule_list_smiles}\"  # noqa: E501\n\t    )\n", "def test_reaction_to_smiles_no_reagents(molecule_list, molecule_list_smiles):\n\t    assert reaction_smiles(molecule_list, molecule_list) == f\"{molecule_list_smiles}>>{molecule_list_smiles}\"\n"]}
{"filename": "test/__init__.py", "chunked_list": []}
{"filename": "test/test_parse_rxn_block.py", "chunked_list": ["import pytest\n\tfrom rdkit.Chem import MolFromMolBlock\n\tfrom rdfreader.chem.mol import Molecule\n\tfrom rdfreader.parse.rxnblock import (\n\t    DatumParser,\n\t    get_rxn_block_metadata,\n\t    mol_blocks_from_rxn_block,\n\t    parse_dtype_string,\n\t    preprocess_datum_string,\n\t    validate_rxn_block,\n", ")\n\tdef test_get_rxn_block_metadata(sample_rxn_block, sample_rxn_block_metadata):\n\t    \"\"\"Test that the get_rxn_block_metadata function correctly parses the\n\t    sample rxn block metadata.\"\"\"\n\t    assert sample_rxn_block_metadata == get_rxn_block_metadata(sample_rxn_block)\n\t@pytest.mark.parametrize(\n\t    \"sample_dtype_string, expected_dtype_string\",\n\t    [\n\t        (\"$DTYPE RXN:VARIATION:STEPNO:SOLVENT(1):MOL:SYMBOL\", \"rxn_variation_stepno_solvent_1_mol_symbol\"),\n\t        (\"$DTYPE RXN:VARIATION:PRODUCT:YIELD\", \"rxn_variation_product_yield\"),\n", "        (\"$DTYPE RXN:CLASSIFICATION(1):MEDIUM\", \"rxn_classification_1_medium\"),\n\t        (\"$DTYPE RXN:VARIATION:LITREF:JOURNAL_ISSN\", \"rxn_variation_litref_journal_issn\"),\n\t    ],\n\t)\n\tdef test_parse_dtype_string(sample_dtype_string, expected_dtype_string):\n\t    assert expected_dtype_string == parse_dtype_string(sample_dtype_string)\n\tdef test_datum_parser_rxnblock(sample_rxn_block):\n\t    \"\"\"Test that the DatumParser parses the sample rxn block.\"\"\"\n\t    datum_parser = DatumParser(sample_rxn_block)\n\t    for parsed_dtype, datum in datum_parser:\n", "        # difficult to test this as there's such a range of datatypes and\n\t        # functions used in the parsing\n\t        # but we can at least test that what we get is the right types\n\t        assert isinstance(parsed_dtype, str)\n\t        assert isinstance(datum, (str, Molecule))\n\t@pytest.mark.parametrize(\n\t    \"expected_datum_string, sample_datum_string\",\n\t    [\n\t        (\"methanol\", \"$DATUM methanol\"),\n\t        (\"87.0-87.0\", \"$DATUM 87.0-87.0\"),\n", "        (\"384991457334703\", \"$DATUM 384991457334703\"),\n\t        (\"0040-4039\", \"$DATUM 0040-4039\"),\n\t        (\"a\\nmultiline\\nstring\", \"$DATUM a\\nmultiline\\nstring\"),\n\t    ],\n\t)\n\tdef test_preprocess_datum_string(expected_datum_string, sample_datum_string):\n\t    result = preprocess_datum_string(sample_datum_string)\n\t    assert expected_datum_string == result\n\tdef test_validate_rxn_block(sample_rxn_block):\n\t    \"\"\"Test that the validate_rxn_block function correctly validates the sample\n", "    rxn block.\"\"\"\n\t    assert validate_rxn_block(sample_rxn_block)\n\tdef test_validate_rxn_block_invalid():\n\t    \"\"\"Test that the validate_rxn_block function correctly validates the sample\n\t    rxn block.\"\"\"\n\t    assert not validate_rxn_block(\"invalid rxn block\")\n\tdef test_mol_blocks_from_rxn_block(sample_rxn_block):\n\t    \"\"\"Test that the mol_blocks_from_rxn_block function correctly parses the\n\t    sample rxn block.\"\"\"\n\t    reactant_count: int = 3\n", "    product_count: int = 1\n\t    reactants, products = mol_blocks_from_rxn_block(sample_rxn_block, reactant_count, product_count)\n\t    # verify that the correct number of mol_blocks are returned\n\t    assert len(products) == product_count\n\t    assert len(reactants) == reactant_count\n\t    # verify that the mol_blocks can be parsed\n\t    for molecules in [reactants, products]:\n\t        for mol_block in molecules:\n\t            rd_mol = MolFromMolBlock(mol_block)\n\t            assert rd_mol is not None\n"]}
{"filename": "test/conftest.py", "chunked_list": ["import datetime\n\tfrom pathlib import Path\n\tfrom typing import Any\n\timport pytest\n\tfrom pytest_mock import MockerFixture\n\tfrom pytest_mock import mocker as mocker_fixture  # noqa: F401\n\tfrom rdfreader.chem.mol import Molecule\n\t@pytest.fixture\n\tdef mocker(mocker_fixture) -> MockerFixture:  # noqa: F811\n\t    \"\"\"Wraps pytest_mock.mocker fixture to allow for easier importing.\"\"\"\n", "    return mocker_fixture\n\tdef get_sample_mol_block() -> str:\n\t    \"\"\"Load the sample mol block as a string from the test resources.\"\"\"\n\t    sample_mol_block_path = \"test/resources/sample_mol_block.txt\"\n\t    with open(sample_mol_block_path, \"r\") as f:\n\t        sample_mol_block = f.read()\n\t    return sample_mol_block\n\tdef get_rdf_path() -> Path:\n\t    \"\"\"Load the sample rdf as a string from the test resources.\"\"\"\n\t    rdf_path = Path(\"test/resources/sample_rdf.rdf\")\n", "    return rdf_path\n\t@pytest.fixture\n\tdef rdf_path() -> Path:\n\t    return get_rdf_path()\n\t@pytest.fixture\n\tdef first_sample_rxn() -> str:\n\t    \"\"\"Return the first rxn block from the sample rdf.\"\"\"\n\t    with open(\"test/resources/sample_rdf_first_rxn.rxn\", \"r\") as f:\n\t        first_sample_rxn = f.read()\n\t    return first_sample_rxn\n", "def get_sample_rdf_string() -> str:\n\t    \"\"\"Load the sample rdf as a string from the test resources.\"\"\"\n\t    sample_rdf_string_path = get_rdf_path()\n\t    with open(sample_rdf_string_path, \"r\") as f:\n\t        sample_rdf_string = f.read()\n\t    return sample_rdf_string\n\tdef get_sample_rxn_block() -> str:\n\t    \"\"\"Load the sample rxn block as a string from the test resources.\"\"\"\n\t    sample_rxn_block_path = \"test/resources/sample_rxn_block.txt\"\n\t    with open(sample_rxn_block_path, \"r\") as f:\n", "        sample_rxn_block = f.read()\n\t    return sample_rxn_block\n\t@pytest.fixture\n\tdef sample_mol_block() -> str:\n\t    return get_sample_mol_block()\n\t@pytest.fixture\n\tdef sample_mol_block_lines() -> str:\n\t    \"\"\"Return the sample mol block split into a list of lines.\"\"\"\n\t    return get_sample_mol_block().split(\"\\n\")\n\t@pytest.fixture\n", "def sample_rxn_block() -> str:\n\t    return get_sample_rxn_block()\n\t@pytest.fixture\n\tdef sample_rxn_block_lines() -> str:\n\t    \"\"\"Return the sample rxn block split into a list of lines.\"\"\"\n\t    return get_sample_rxn_block().split(\"\\n\")\n\t@pytest.fixture\n\tdef sample_molecule() -> Molecule:\n\t    \"\"\"Create a test molecule.\"\"\"\n\t    mol = Molecule()\n", "    mol.mol_block = get_sample_mol_block()\n\t    return mol\n\t@pytest.fixture\n\tdef sample_molecule_metadata() -> dict[str, Any]:\n\t    \"\"\"Return the sample mol block metadata.\"\"\"\n\t    return dict(\n\t        molecule_name=\"sample name\",\n\t        user_initials=\"II\",\n\t        program_name=\"PPPPPPPP\",\n\t        date_time=datetime.datetime(22, 5, 24, 14, 23),\n", "        dimensional_codes=\"dd\",\n\t        scaling_factor_1=12,\n\t        scaling_factor_2=1.12345678,\n\t        energy=1.2345678912,\n\t        registry_number=\"overflowing reg number\",\n\t        comment=\"sample comment\",\n\t    )\n\t@pytest.fixture\n\tdef sample_rxn_block_metadata() -> str:\n\t    \"\"\"Return sample rxn block metadata.\"\"\"\n", "    return dict(\n\t        reaction_name=\"sample reaction name\",\n\t        user_initials=\"IIIIII\",\n\t        program_name=\"PPPPPPPPP\",\n\t        date_time=datetime.datetime(2022, 5, 24, 14, 55),\n\t        registry_number=\"RRRRRRR\",\n\t        comment=\"sample reaction comment\",\n\t        product_count=1,\n\t        reactant_count=3,\n\t    )\n"]}
{"filename": "rdfreader/write.py", "chunked_list": ["from datetime import datetime\n\tfrom io import TextIOWrapper\n\tdef write_rdf(\n\t    f: TextIOWrapper,\n\t    rxn_blocks: list[str],\n\t    rxn_ids: list[str] = None,\n\t):\n\t    \"\"\"Write a RDF file from a list of reaction blocks.\n\t    Parameters\n\t    ----------\n", "    f : TextIOWrapper\n\t        The file to write to.\n\t    rxn_blocks : list[str]\n\t        The reaction blocks to write.\n\t    rxn_ids : list[str], optional\n\t        The reaction IDs to use. Defaults to None. If None, sequential 5 digit\n\t        numbers are used.\n\t    \"\"\"\n\t    # current date and time as DD/MM/YY HH:MM\n\t    datm = datetime.now().strftime(\"%d/%m/%y %H:%M\")\n", "    rdf_header = f\"$RDFILE 1\\n$DATM {datm}\\n\"\n\t    rxn_header = \"$RFMT $RIREG {}\\n\"\n\t    if rxn_ids is None:\n\t        # generate sequential 5 digit numbers\n\t        rxn_ids = [f\"{i:05d}\" for i in range(1, len(rxn_blocks) + 1)]\n\t    f.write(rdf_header)\n\t    for rxn_id, rxn_block in zip(rxn_ids, rxn_blocks):\n\t        f.write(rxn_header.format(rxn_id))\n\t        f.write(rxn_block)\n"]}
{"filename": "rdfreader/rdf.py", "chunked_list": ["# typing\n\tfrom io import TextIOWrapper\n\tfrom pathlib import Path\n\tfrom rdfreader.chem.reaction import Reaction\n\tfrom rdfreader.parse.utils import CTF_RXNBLOCK_HEADER_FORMAT_STRING\n\tdef parse_rdf_reg_num(line: str):\n\t    return line.replace(\"$RFMT $RIREG \", \"\").strip()\n\tclass RDFParser:\n\t    _header_retrieved: bool = False\n\t    lineno: int = 1\n", "    rdf_metadata: dict[str, str] = {}\n\t    def __init__(\n\t        self,\n\t        f: TextIOWrapper,\n\t        header_format_string: str = CTF_RXNBLOCK_HEADER_FORMAT_STRING,\n\t        except_on_invalid_molecule: bool = True,\n\t        except_on_invalid_reaction: bool = True,\n\t        parse_conditions: bool = True,\n\t    ):\n\t        \"\"\"\n", "        Parameters\n\t        ----------\n\t        f : TextIOWrapper\n\t            The file to parse.\n\t        header_format_string : str, optional\n\t            The format string to use to parse the header of each rxn block.\n\t        except_on_invalid_molecule : bool, optional\n\t            If True, raise an exception if a molecule is invalid.\n\t        except_on_invalid_reaction : bool, optional\n\t            If True, raise an exception if a reaction is invalid.\n", "        rdf_file_name : str, optional\n\t            The name of the rdf file.\n\t        parse_conditions : bool, optional\n\t            Whether to parse the conditions of the reaction.\n\t        \"\"\"\n\t        self.f = f\n\t        self.header_format_string = header_format_string\n\t        self.except_on_invalid_molecule = except_on_invalid_molecule\n\t        self.except_on_invalid_reaction = except_on_invalid_reaction\n\t        self.rdf_file_name = Path(f.name).name\n", "        self.parse_conditions = parse_conditions\n\t    def __iter__(self):\n\t        return self\n\t    def __next__(self):\n\t        return self.next_reaction()\n\t    def next_reaction(self):\n\t        \"\"\"Returns the next rxn block from a rdf file.\n\t        Parameters\n\t        ----------\n\t        f : TextIOWrapper\n", "            The file to parse.\n\t        Returns\n\t        -------\n\t        tuple[str, str, int]\n\t            The rxn block, the rxn id, and the line number of the start of the\n\t            rxn block.\n\t        \"\"\"\n\t        # get the next rxn block\n\t        reaction = None\n\t        rxn_block, rxn_id, start_lineno = self._next_rxn_block()\n", "        try:\n\t            reaction = Reaction(\n\t                rxn_block=rxn_block,\n\t                id=rxn_id,\n\t                rdf_metadata=self.rdf_metadata,\n\t                header_format_string=self.header_format_string,\n\t                except_on_invalid_molecule=self.except_on_invalid_molecule,\n\t                lineno=start_lineno,\n\t                rdf_file=self.rdf_file_name,\n\t            )\n", "        except Exception as e:\n\t            if self.except_on_invalid_reaction:\n\t                raise e\n\t        return reaction\n\t    def _header(self):\n\t        \"\"\"Parse the header of a RDF file.\n\t        Parameters\n\t        ----------\n\t        f : TextIOWrapper\n\t            The file to parse.\n", "        Returns\n\t        -------\n\t        dict[str, str]\n\t            The version and date of the RDF file. These are just treated as\n\t            strings as they are typically ignored and the structure of the\n\t            datetime field is not defined in the specification.\n\t        \"\"\"\n\t        if not self._header_retrieved:\n\t            self._header_retrieved = True\n\t            version = self._readline()[8:].strip()\n", "            date_stamp = self._readline()[6:].strip()\n\t            self.rdf_metadata = {\"version\": version, \"date_stamp\": date_stamp}\n\t    def _next_rxn_block(self) -> tuple[str, str, int]:\n\t        \"\"\"Returns the next rxn block from a rdf file. If the end.\n\t        Returns\n\t        -------\n\t        tuple[str, str, int]\n\t            The rxn block, the rxn id, and the line number of the start of the\n\t            rxn block.\n\t        \"\"\"\n", "        self._header()\n\t        start_lineno: int = self.lineno\n\t        line: str = self._readline()\n\t        if line == \"\":\n\t            raise StopIteration\n\t        # parse the rxn block deliminators\n\t        if line.startswith(\"$RFMT\"):\n\t            # capture the reg number\n\t            reg_no: str = parse_rdf_reg_num(line)\n\t            line: str = self._readline()\n", "        else:\n\t            #  there is a problem with the file format, raise an exception\n\t            raise Exception(f\"Invalid RDF file format. Expected $RFMT, got {line} \" f\"at line {self.lineno}\")\n\t        # capture the rxn block\n\t        rxn_block: str = \"\"\n\t        f_last_pos = self.f.tell()  # ensure f_last_pos is defined\n\t        while not line.startswith(\"$RFMT\") and not line == \"\":\n\t            f_last_pos = self.f.tell()\n\t            rxn_block += line\n\t            line: str = self._readline()\n", "        # send the file pointer back one line so it is at the start of the\n\t        # next rxn block\n\t        self.f.seek(f_last_pos)\n\t        self.lineno -= 1\n\t        return rxn_block, reg_no, start_lineno\n\t    def _readline(self):\n\t        \"\"\"Wraps f.read and increments the line number.\"\"\"\n\t        self.lineno += 1\n\t        return self.f.readline()\n"]}
{"filename": "rdfreader/__init__.py", "chunked_list": ["from rdfreader.rdf import RDFParser  # noqa F401\n"]}
{"filename": "rdfreader/exceptions.py", "chunked_list": ["class InvalidMoleculeError(Exception):\n\t    \"\"\"Raised when the mol block string is not a valid mol block string.\"\"\"\n\tclass InvalidReactionError(Exception):\n\t    \"\"\"Raised when the reaction block string is not a valid reaction block\n\t    string.\"\"\"\n"]}
{"filename": "rdfreader/chem/mol.py", "chunked_list": ["from typing import Any\n\tfrom rdkit.Chem import Mol, MolFromMolBlock, MolFromSmiles, MolToMolBlock, MolToSmiles\n\tfrom rdfreader.exceptions import InvalidMoleculeError\n\tfrom rdfreader.parse.molblock import get_mol_block_metadata\n\tclass Molecule:\n\t    def __init__(\n\t        self,\n\t        mol_block: str = None,\n\t        properties: dict[str, Any] = dict(),\n\t        except_on_invalid_molecule: bool = True,\n", "        component_type: str = None,\n\t    ):\n\t        \"\"\"Create a molecule object.\n\t        If a mol_block is provided, the molecule will be initialized with that,\n\t        otherwise the molecule will be initialized empty.\n\t        Parameters\n\t        ----------\n\t        mol_block : str\n\t            A mol block string.\n\t        properties : dict[str, Any]\n", "            A dictionary of properties.\n\t        \"\"\"\n\t        self.except_on_invalid_molecule: bool = except_on_invalid_molecule\n\t        self.properties: dict[str, Any] = properties\n\t        self.mol_block: str = mol_block  # calls mol_block setter\n\t        self.component_type: str = component_type\n\t    @property\n\t    def mol_block(self) -> str:\n\t        \"\"\"Returns the mol block string of the molecule.\n\t        Returns\n", "        -------\n\t        str\n\t            The mol block string of the molecule.\n\t        \"\"\"\n\t        return self._mol_block\n\t    @mol_block.setter\n\t    def mol_block(self, mol_block: str):\n\t        \"\"\"Set the mol block string of the molecule.\n\t        Parameters\n\t        ----------\n", "        mol_block : str\n\t            A mol block string.\n\t        \"\"\"\n\t        if not mol_block:\n\t            self._mol_block = None\n\t        else:\n\t            self._from_mol_block(mol_block)\n\t    @property\n\t    def rd_mol(self) -> Mol:\n\t        \"\"\"Return the RDKit molecule object.\"\"\"\n", "        return MolFromMolBlock(\n\t            self.mol_block,\n\t        )\n\t    @property\n\t    def smiles(self) -> str:\n\t        \"\"\"Returns the SMILES string of the molecule using RDKit.\n\t        Returns:\n\t            str: SMILES string of the molecule.\n\t        \"\"\"\n\t        try:\n", "            return MolToSmiles(self.rd_mol)\n\t        except Exception:\n\t            return None\n\t    @property\n\t    def metadata(self) -> dict[str, Any]:\n\t        \"\"\"Returns the metadata of the molecule from the mol block string.\n\t        Returns:\n\t            dict[str, Any]: The metadata of the molecule.\n\t        \"\"\"\n\t        return get_mol_block_metadata(self.mol_block)\n", "    def _from_mol_block(self, mol_block: str, properties: dict[str, Any] = dict()) -> None:\n\t        \"\"\"Initialize the molecule object with a mol block string.\n\t        Parameters\n\t        ----------\n\t        mol_block : str\n\t            A mol block string.\n\t        \"\"\"\n\t        self.properties.update(properties)\n\t        self._mol_block = mol_block\n\t        if self.except_on_invalid_molecule:\n", "            try:\n\t                assert self.rd_mol is not None\n\t            except AssertionError:\n\t                raise InvalidMoleculeError(\"mol_block is not a valid mol block string.\")\n\t    @classmethod\n\t    def from_mol_block(cls, mol_block: str, properties: dict[str, Any] = {}) -> \"Molecule\":\n\t        \"\"\"Create a Molecule object from a mol block string.\n\t        Parameters\n\t        ----------\n\t        mol_block : str\n", "            A mol block string.\n\t        Returns\n\t        -------\n\t        Molecule\n\t            A Molecule object.\n\t        \"\"\"\n\t        mol = cls()\n\t        mol._from_mol_block(mol_block, properties)\n\t        return mol\n\t    def __eq__(self, __o: object) -> bool:\n", "        \"\"\"Returns True if the molecules are equal.\n\t        Returns\n\t        -------\n\t        bool\n\t            True if the molecules are equal.\n\t        \"\"\"\n\t        if not isinstance(__o, Molecule):\n\t            return False\n\t        return self.mol_block == __o.mol_block\n\t    def __str__(self) -> str:\n", "        \"\"\"Returns the smiles string of the molecule.\n\t        Returns\n\t        -------\n\t        str\n\t            The smiles string of the molecule.\n\t        \"\"\"\n\t        return self.smiles\n\t    def __repr__(self) -> str:\n\t        return f\"Molecule(smiles={self.smiles})\"\n\t    @classmethod\n", "    def from_smiles(cls, smiles: str) -> \"Molecule\":\n\t        \"\"\"Create a Molecule object from a smiles string.\n\t        Parameters\n\t        ----------\n\t        smiles : str\n\t            A smiles string.\n\t        Returns\n\t        -------\n\t        Molecule\n\t            A Molecule object.\n", "        \"\"\"\n\t        mol_block = MolToMolBlock(MolFromSmiles(smiles))\n\t        mol = cls()\n\t        mol._from_mol_block(mol_block)\n\t        return mol\n\tclass Reactant(Molecule):\n\t    def __init__(*args, **kwargs):\n\t        super().__init__(**args, **kwargs, component_type=\"reactant\")\n\tclass Product(Molecule):\n\t    def __init__(*args, **kwargs):\n", "        super().__init__(**args, **kwargs, component_type=\"product\")\n\tclass Solvent(Molecule):\n\t    def __init__(*args, **kwargs):\n\t        super().__init__(**args, **kwargs, component_type=\"solvent\")\n\tclass Catalyst(Molecule):\n\t    def __init__(*args, **kwargs):\n\t        super().__init__(**args, **kwargs, component_type=\"catalyst\")\n"]}
{"filename": "rdfreader/chem/reaction.py", "chunked_list": ["import logging\n\tfrom typing import Any, Optional\n\tfrom rdkit.Chem.rdChemReactions import ChemicalReaction, ReactionFromSmarts\n\tfrom rdfreader.chem.mol import Molecule\n\tfrom rdfreader.chem.utils import reaction_smiles\n\tfrom rdfreader.exceptions import InvalidReactionError\n\tfrom rdfreader.parse.rxnblock import DatumParser, get_rxn_block_metadata, mol_blocks_from_rxn_block, validate_rxn_block\n\tfrom rdfreader.parse.utils import CTF_RXNBLOCK_HEADER_FORMAT_STRING\n\tlogger = logging.getLogger(__name__)\n\tclass Reaction:\n", "    def __init__(\n\t        self,\n\t        rxn_block: str = None,\n\t        id: str = None,\n\t        rdf_metadata: Optional[dict[str, Any]] = None,  # metadata from the rdf file the block was contained in,\n\t        except_on_invalid_molecule: bool = True,\n\t        header_format_string: str = CTF_RXNBLOCK_HEADER_FORMAT_STRING,\n\t        lineno: Optional[int] = None,\n\t        rdf_file: Optional[str] = None,\n\t    ):\n", "        \"\"\"Create a reaction object.\n\t        If a reaction block is provided, the reaction will be\n\t        initialized with that, otherwise the reaction will be\n\t        initialized empty.\n\t        \"\"\"\n\t        self.rxn_block = rxn_block\n\t        self.rdf_metadata = rdf_metadata\n\t        self.id = id\n\t        self.lineno = lineno\n\t        self.rdf_file = rdf_file\n", "        self.products: list[Molecule] = list()\n\t        self.reactants: list[Molecule] = list()\n\t        self.catalysts: list[Molecule] = list()\n\t        self.solvents: list[Molecule] = list()\n\t        self.other_reagents: list[Molecule] = list()\n\t        self.properties: dict[str, str] = dict()\n\t        self.metadata: dict[str, Any] = dict()\n\t        if self.rxn_block is not None:\n\t            self._from_rxn_block(\n\t                header_format_string=header_format_string,\n", "                except_on_invalid_molecule=except_on_invalid_molecule,\n\t            )\n\t    def __str__(self) -> str:\n\t        return f\"Reaction({self.id}, {self.smiles})\"\n\t    def _from_rxn_block(\n\t        self,\n\t        header_format_string: str = CTF_RXNBLOCK_HEADER_FORMAT_STRING,\n\t        except_on_invalid_molecule: bool = True,\n\t    ) -> None:\n\t        \"\"\"Initialize the reaction object from a reaction block.\n", "        Parameters\n\t        ----------\n\t        rdf_path : Path\n\t            A path to a rdf file.\n\t        \"\"\"\n\t        if not validate_rxn_block(self.rxn_block):\n\t            raise ValueError(\"Reaction block is invalid.\")\n\t        # get the headers from the rxn block.\n\t        self.metadata.update(get_rxn_block_metadata(self.rxn_block, header_format_string=header_format_string))\n\t        # get the reactants and product mol_blocks, create a molecule object\n", "        # for each, and add it to the reaction.\n\t        reactant_mol_blocks, product_mol_blocks = mol_blocks_from_rxn_block(\n\t            self.rxn_block,\n\t            self.metadata[\"reactant_count\"],\n\t            self.metadata[\"product_count\"],\n\t        )\n\t        for mol_block in reactant_mol_blocks:\n\t            self.reactants.append(\n\t                Molecule(\n\t                    mol_block,\n", "                    except_on_invalid_molecule=except_on_invalid_molecule,\n\t                )\n\t            )\n\t        for mol_block in product_mol_blocks:\n\t            self.products.append(\n\t                Molecule(\n\t                    mol_block,\n\t                    except_on_invalid_molecule=except_on_invalid_molecule,\n\t                )\n\t            )\n", "        # use functions in rdfreader/parse/rdf.py to pull out dtype/datum\n\t        # pairs from the rxn block\n\t        datum_parser = DatumParser(\n\t            self.rxn_block,\n\t        )\n\t        for dtype, datum in datum_parser:\n\t            if not isinstance(datum, Molecule):\n\t                self.properties[dtype] = datum\n\t            else:\n\t                # add to the appropriate molecule list\n", "                getattr(self, f\"{datum.component_type}s\").append(datum)\n\t        if self.rd_rxn is None:\n\t            raise ValueError(\"Invalid reaction: couldn't parse in rdkit.\")\n\t    @property\n\t    def smiles(self) -> str:\n\t        return reaction_smiles(\n\t            self.reactants,\n\t            self.products,\n\t            self.reagents,\n\t        )\n", "    @property\n\t    def smiles_no_reagents(self) -> str:\n\t        return reaction_smiles(\n\t            self.reactants,\n\t            self.products,\n\t        )\n\t    @property\n\t    def rd_rxn(self) -> ChemicalReaction:\n\t        try:\n\t            return ReactionFromSmarts(self.smiles, useSmiles=True)\n", "        except ValueError as e:\n\t            raise InvalidReactionError(f\"Invalid reaction: {e}\") from e\n\t    @property\n\t    def reagents(self) -> list[Molecule]:\n\t        \"\"\"Return a single list of all reagents.\n\t        Returns\n\t        -------\n\t        list[Molecule]\n\t            A list of all reagents.\n\t        \"\"\"\n", "        return self.catalysts + self.solvents + self.other_reagents\n"]}
{"filename": "rdfreader/chem/__init__.py", "chunked_list": []}
{"filename": "rdfreader/chem/utils.py", "chunked_list": ["from rdfreader.chem.mol import Molecule\n\tdef mol_list_to_smiles(mol_list: list[Molecule]) -> str:\n\t    \"\"\"Convert a list of molecules to a SMILES string.\n\t    Parameters\n\t    ----------\n\t    mol_list : list[Molecule]\n\t        The list of molecules to convert to a SMILES string.\n\t    Returns\n\t    -------\n\t    str\n", "        The SMILES string.\n\t    \"\"\"\n\t    return \".\".join([mol.smiles for mol in mol_list if mol.smiles is not None])\n\tdef reaction_smiles(\n\t    reactants: list[Molecule],\n\t    products: list[Molecule],\n\t    reagents: list[Molecule] = [],\n\t) -> str:\n\t    \"\"\"Create a reaction smiles string from lists of product, reactant, and\n\t    reagent molecules.\"\"\"\n", "    product_smiles = mol_list_to_smiles(products)\n\t    reactant_smiles = mol_list_to_smiles(reactants)\n\t    reagent_smiles = mol_list_to_smiles(reagents)\n\t    return \">\".join([reactant_smiles, reagent_smiles, product_smiles])\n"]}
{"filename": "rdfreader/parse/utils.py", "chunked_list": ["import datetime\n\timport logging\n\timport re\n\tfrom typing import Any, Callable, Optional\n\tlogger = logging.getLogger(__name__)\n\t# http://c4.cabrillo.edu/404/ctfile.pdf\n\tCTF_DEFAULT_MOLBLOCK_HEADER_FORMAT_STRING: str = \"IIPPPPPPPPMMDDYYHHmmddSSssssssssssEEEEEEEEEEEERRRRRR\"\n\tCTF_RXNBLOCK_HEADER_FORMAT_STRING: str = \"IIIIIIPPPPPPPPPMMDDYYYYHHmmRRRRRRR\"\n\tSPRESI_RXNBLOCK_HEADER_FORMAT_STRING: str = \"IIIIIIPPPPPPPPPPMMDDYYHHmmRRRRRRR\"\n\tCTF_COMPONENT_COUNT_FORMAT_STRING: str = \"rrrppp\"\n", "# default mapping of letter to field. This is used to map the letter in the\n\t# mol block header to the field in the metadata.\n\t# key: letter, value: tuple containing the field name, the field type and a\n\t# default value (if the field is empty). Field typle should be a castable data\n\t# type.\n\t# If the field is empty, the default value will be used.\n\tCTF_DEFAULT_LETTER_TO_FIELD_MAPPING: dict[str, tuple[str, Callable, Any]] = {\n\t    \"I\": (\"user_initials\", str, \"\"),\n\t    \"P\": (\"program_name\", str, \"\"),\n\t    \"M\": (\"month\", int, 0),\n", "    \"D\": (\"day\", int, 0),\n\t    \"Y\": (\"year\", int, 0),\n\t    \"H\": (\"hour\", int, 0),\n\t    \"m\": (\"minute\", int, 0),\n\t    \"d\": (\"dimensional_codes\", str, \"\"),\n\t    \"S\": (\"scaling_factor_1\", int, 0),\n\t    \"s\": (\"scaling_factor_2\", float, 0.0),\n\t    \"E\": (\"energy\", float, 0.0),\n\t    \"R\": (\"registry_number\", str, \"\"),\n\t    \"r\": (\"reactant_count\", int, 0),\n", "    \"p\": (\"product_count\", int, 0),\n\t}\n\tdef _default_line_item(cast_type: Callable = str, default: Any = None) -> Any:\n\t    \"\"\"Return a default value for a line item.\"\"\"\n\t    if default is not None:\n\t        return default\n\t    if cast_type in (int, float):\n\t        return cast_type(0)\n\t    if cast_type == str:\n\t        return \"\"\n", "    else:\n\t        return default\n\tdef get_line_item(\n\t    line: str,\n\t    character_index: Optional[tuple[Optional[int], Optional[int]]] = None,\n\t    cast_type: Callable = str,\n\t    default: Any = None,\n\t    catch_casting_exceptions: bool = False,\n\t) -> Any:\n\t    \"\"\"Process a line from an rdf/mol file or block.\n", "    If character_index is provided, then the characters within that slice will\n\t    be returned.\n\t    If cast_type is provided, then the characters will be cast to that type.\n\t    If the line is empty a default will be provided. For numeric types (as set\n\t    by cast_type), the default will be 0, for strings it will be an empty\n\t    string. For other types, the default will be None. This can be overridden\n\t    by providing a default.\n\t    If catch_casting_exceptions is True, then any casting exceptions will be\n\t    caught and the default will be returned.\n\t    Strips whitespace and newlines.\n", "    Parameters\n\t    ----------\n\t    line : str\n\t        A line.\n\t    character_index : tuple[int, int]\n\t        A tuple of the start and end character index.\n\t    Returns\n\t    -------\n\t    str\n\t        The line item.\n", "    \"\"\"\n\t    line = line[slice(*character_index)] if character_index else line\n\t    line = line.strip(\"\\n\")  # remove newline\n\t    line = line.strip()  # remove whitespace\n\t    if not line:\n\t        # return a default value if the line is empty\n\t        return _default_line_item(cast_type, default)\n\t    if cast_type:\n\t        try:\n\t            # attempt to cast the line to the specified type\n", "            line = cast_type(line)\n\t        except ValueError:\n\t            if catch_casting_exceptions:\n\t                # return a default value if the line cannot be cast\n\t                return _default_line_item(cast_type, default)\n\t            else:\n\t                raise\n\t    return line\n\tdef get_whole_line_item(line: str) -> str:\n\t    \"\"\"Return a data item that is from a whole line. Item must be a string.\n", "    Parameters\n\t    ----------\n\t    line : str\n\t        A line.\n\t    Returns\n\t    -------\n\t    str\n\t        The data item.\n\t    \"\"\"\n\t    return get_line_item(line, (0, len(line)), str, \"\")\n", "def parse_format_string(format_string) -> dict[str, tuple]:\n\t    \"\"\"Parses a CTF format string (http://c4.cabrillo.edu/404/ctfile.pdf) and\n\t    returns a dictionary where the key is the letter in the format string and\n\t    the value is a tuple of the start and end character index.\n\t    Parameters\n\t    ----------\n\t    format_string : str\n\t        A CTF format string.\n\t    Returns\n\t    -------\n", "    dict[str, tuple]\n\t        A dictionary of the letter in the format string and the start and end\n\t        character index as a tuple.\n\t    \"\"\"\n\t    format_string_dict = {}\n\t    last_letter = format_string[0]\n\t    current_letter_start_index = 0  # the index where the current letter started\n\t    for ii, letter in enumerate(format_string):\n\t        if letter != last_letter:\n\t            # if the letter has changed add the previous letter to the\n", "            # dictionary\n\t            format_string_dict[last_letter] = (current_letter_start_index, ii)\n\t            current_letter_start_index = ii\n\t        last_letter = letter\n\t    # add the last letter to the dictionary\n\t    format_string_dict[last_letter] = (current_letter_start_index, ii + 1)\n\t    return format_string_dict\n\tdef dict_elements_to_datetime(\n\t    dd: dict[str, Any],\n\t    date_time_key: str = \"date_time\",\n", "    delete_initial_keys: bool = True,\n\t    catch_datetime_exceptions: bool = True,\n\t) -> dict[str, Any]:\n\t    \"\"\"Search a dictionary for datetime elements and adds a a new key to the\n\t    dictionary with a datetime object.\n\t    Searches for datetime keys called: \"hour\", \"minute\", \"second\", \"day\",\n\t    \"month\", \"year\" and adds a new key called <date_time_key> with a datetime\n\t    object.\n\t    If delete_initial_keys is set, the original keys will be deleted.\n\t    If the datetime is not parseable, None will be added to the dictionary.\n", "    Parameters\n\t    ----------\n\t    dd : dict[str, Any]\n\t        A dictionary.\n\t    date_time_key : str\n\t        The key to add to the dictionary.\n\t    delete_initial_keys : bool\n\t        If True, the keys \"hour\", \"minute\", \"second\", \"day\", \"month\", \"year\"\n\t        will be deleted from the dictionary.\n\t    catch_datetime_exceptions\n", "        If True, parsing exceptions from datetime.datetime will be caught and\n\t        None will be added to the dictionary.\n\t    Returns\n\t    -------\n\t    dict[str, Any]\n\t        A dictionary with the new key added.\n\t    \"\"\"\n\t    date_time_args = {k: dd[k] for k in [\"hour\", \"minute\", \"second\", \"day\", \"month\", \"year\"] if k in dd}\n\t    if not date_time_args:\n\t        # if no datetime keys are found, return the dictionary as is\n", "        return dd\n\t    try:\n\t        dd[date_time_key] = datetime.datetime(**date_time_args)\n\t    except (ValueError, TypeError):\n\t        if catch_datetime_exceptions:\n\t            logger.warning(f\"Could not parse datetime from {dd}\")\n\t            dd[date_time_key] = None\n\t        else:\n\t            raise\n\t    if delete_initial_keys:\n", "        [dd.pop(key, None) for key in [\"hour\", \"minute\", \"second\", \"day\", \"month\", \"year\"]]\n\t    return dd\n\tdef _parse_block_header_line(\n\t    header_line: str,\n\t    header_format_string: str,\n\t    header_field_mapping: dict[str, tuple[str, Callable, Any]],\n\t) -> dict[str, Any]:\n\t    \"\"\"Parse the header line of a rxn or mol block.\n\t    Parameters\n\t    ----------\n", "    header_line : list[str]\n\t        A single line from the header.\n\t    header_format_string : str\n\t        See get_mol_block_metadata for more information.\n\t    header_field_mapping : dict[str, tuple(str, Callable, Any)]\n\t        See get_mol_block_metadata for more information.\n\t    Returns\n\t    -------\n\t    dict\n\t        A dictionary of metadata.\n", "    \"\"\"\n\t    format_string_dict = parse_format_string(header_format_string)\n\t    metadata = {}\n\t    for letter, character_index in format_string_dict.items():\n\t        if letter in header_field_mapping:\n\t            field_name = header_field_mapping[letter][0]\n\t            data_type = header_field_mapping[letter][1]\n\t            try:\n\t                default_value = header_field_mapping[letter][2]\n\t            except IndexError:\n", "                default_value = None\n\t            metadata[field_name] = get_line_item(header_line, character_index, data_type, default_value)\n\t        else:\n\t            raise ValueError(f\"The letter {letter} does not appear in the format field mapping.\")  # noqa: E501\n\t    metadata = dict_elements_to_datetime(metadata)\n\t    return metadata\n\tdef make_string_python_safe(string: str) -> str:\n\t    \"\"\"Remove/replace characters that are not allowed in python\n\t    variable/function names.\n\t    Parameters\n", "    ----------\n\t    string : str\n\t        A string.\n\t    Returns\n\t    -------\n\t    str\n\t        The python safe string.\n\t    \"\"\"\n\t    if string is None:\n\t        return None\n", "    string = string.strip()\n\t    string = string.strip(\"\\n\")\n\t    string = string.strip(\"\\r\")\n\t    if string == \"\":\n\t        return None\n\t    # remove existing underscores\n\t    # string = string.replace(\"_\", \"\")\n\t    # add a leading underscore if string starts with a number\n\t    if string[0].isdigit():\n\t        string = f\"_{string}\"\n", "    # replace all non-alphanumeric characters with an underscore\n\t    string = re.sub(r\"[^a-zA-Z0-9_]\", \"_\", string)\n\t    # replace multiple underscores with a single underscore\n\t    string = re.sub(r\"_{2,}\", \"_\", string)\n\t    # lower case the string\n\t    string = string.lower()\n\t    # remove trailing underscores\n\t    string = string.rstrip(\"_\")\n\t    return string\n\tdef parse_yield(yield_string: str) -> float:\n", "    \"\"\"Attempts to parse the yield string into a float.\n\t    If muliple numbers are detected, will return the average.\n\t    If no numbers are detected, will return None.\n\t    Parameters\n\t    ----------\n\t    yield_string : str\n\t    Returns\n\t    -------\n\t    float\n\t        Yield as a float.\n", "    \"\"\"\n\t    re_patterns = [\n\t        r\"^([0-9]+\\.?[0-9]?)$\",  # matches a single int or float\n\t        r\"^([0-9]+\\.?[0-9]?)\\s{0,}[-,;:]{0,}\\s{0,}([0-9]+\\.?[0-9]?)$\",  # matches two ints or floats separated by a dash, comma, semicolon, colon or space  # noqa: E501\n\t    ]\n\t    for re_pattern in re_patterns:\n\t        match = re.search(re_pattern, yield_string)\n\t        if match:\n\t            # get the match groups as a list\n\t            # (first match group is the whole string)\n", "            match_groups = match.groups()\n\t            # convert the match groups to floats\n\t            match_groups = [float(group) for group in match_groups]\n\t            # average the match groups\n\t            return sum(match_groups) / len(match_groups)\n\t    # if we get here, then we didn't find a match\n\t    logger.warning(f\"Could not parse yield from '{yield_string}'. Returning None.\")\n\t    return None\n"]}
{"filename": "rdfreader/parse/molblock.py", "chunked_list": ["import logging\n\tfrom typing import Any, Callable\n\tfrom rdfreader.parse.utils import (\n\t    CTF_DEFAULT_LETTER_TO_FIELD_MAPPING,\n\t    CTF_DEFAULT_MOLBLOCK_HEADER_FORMAT_STRING,\n\t    _parse_block_header_line,\n\t    get_line_item,\n\t    get_whole_line_item,\n\t)\n\tlogger = logging.getLogger(__name__)\n", "def get_mol_block_metadata(\n\t    mol_block: str,\n\t    header_format_string: str = CTF_DEFAULT_MOLBLOCK_HEADER_FORMAT_STRING,\n\t    header_field_mapping: dict[str, tuple[str, Callable, Any]] = CTF_DEFAULT_LETTER_TO_FIELD_MAPPING,\n\t) -> dict[str, Any]:\n\t    \"\"\"Extract metadata from a mol block string.\n\t    Parameters\n\t    ----------\n\t    mol_block : str\n\t        A mol block string.\n", "    header_format_string : str\n\t        The format string for the line 2 of the mol_block header. Default\n\t        value is according to the mol_block spec at\n\t        http://c4.cabrillo.edu/404/ctfile.pdf. The letters must appear in the\n\t        spec, but the order can be changed.\n\t    header_field_mapping : dict[str, tuple(str, Callable, Any)]\n\t        A dictionary which maps a letter in the header format string to a\n\t        field name. The field name is the key and the letter is the value. The\n\t        default mapping is according to the mol_block spec at\n\t        http://c4.cabrillo.edu/404/ctfile.pdf.\n", "        key: letter, value: tuple containing the field name, the field type\n\t        and a default value (if the field is empty). Field typle should be a\n\t        castable data type.\n\t        If the field is empty, the default value will be used.\n\t    Returns\n\t    -------\n\t    dict\n\t        A dictionary of metadata.\n\t    \"\"\"\n\t    metadata = {}\n", "    mol_block_lines = mol_block.split(\"\\n\")\n\t    metadata[\"molecule_name\"] = get_whole_line_item(mol_block_lines[0])\n\t    metadata.update(_parse_block_header_line(mol_block_lines[1], header_format_string, header_field_mapping))\n\t    metadata[\"comment\"] = get_whole_line_item(mol_block_lines[2])\n\t    large_regno: str = _parse_large_regno(mol_block_lines)\n\t    if large_regno is not None:\n\t        # overwrite the registry number from the header with the large\n\t        # registry number if it is present\n\t        metadata[\"registry_number\"] = large_regno\n\t    return metadata\n", "def _parse_large_regno(mol_block_lines: list[str]) -> str:\n\t    \"\"\"Searches the molblock a line beginning with M REG and returns the value\n\t    of it if present.\n\t    Parameters\n\t    ----------\n\t    mol_block_lines : list[str]\n\t        A molblock string that has been split into a list of lines.\n\t    Returns\n\t    -------\n\t    Optional[str]\n", "        The registry number. If None is returned, the registry number is not\n\t        present.\n\t    \"\"\"\n\t    for line in mol_block_lines:\n\t        if line.startswith(\"M  REG \"):\n\t            return get_line_item(line, [7, len(line)])\n\t    return None\n"]}
{"filename": "rdfreader/parse/rxnblock.py", "chunked_list": ["from __future__ import annotations\n\timport logging\n\timport re\n\tfrom typing import Any, Callable, Iterator\n\tfrom rdfreader.chem.mol import Molecule\n\tfrom rdfreader.parse.utils import (\n\t    CTF_COMPONENT_COUNT_FORMAT_STRING,\n\t    CTF_DEFAULT_LETTER_TO_FIELD_MAPPING,\n\t    CTF_RXNBLOCK_HEADER_FORMAT_STRING,\n\t    _parse_block_header_line,\n", "    get_whole_line_item,\n\t    make_string_python_safe,\n\t)\n\tlogger = logging.getLogger(__name__)\n\tdef get_rxn_block_metadata(\n\t    rxn_block: str,\n\t    header_format_string: str = CTF_RXNBLOCK_HEADER_FORMAT_STRING,\n\t    header_field_mapping: dict[str, tuple[str, Callable, Any]] = CTF_DEFAULT_LETTER_TO_FIELD_MAPPING,\n\t    reactant_product_count_format_string: str = CTF_COMPONENT_COUNT_FORMAT_STRING,  # noqa F401\n\t) -> dict[str, Any]:\n", "    \"\"\"Get the metadata from a reaction block.\n\t    Parameters\n\t    ----------\n\t    rxn_block : str\n\t        A reaction block string.\n\t    Returns\n\t    -------\n\t    dict\n\t        A dictionary of metadata.\n\t    \"\"\"\n", "    metadata = {}\n\t    rxn_block_lines: list[str] = rxn_block.split(\"\\n\")\n\t    metadata[\"reaction_name\"] = get_whole_line_item(rxn_block_lines[1])\n\t    metadata.update(_parse_block_header_line(rxn_block_lines[2], header_format_string, header_field_mapping))\n\t    metadata[\"comment\"] = get_whole_line_item(rxn_block_lines[3])\n\t    metadata.update(\n\t        _parse_block_header_line(\n\t            rxn_block_lines[4],\n\t            reactant_product_count_format_string,\n\t            header_field_mapping,\n", "        )\n\t    )\n\t    return metadata\n\tclass DatumParser:\n\t    \"\"\"Process dtype/datum pairs.\n\t    The class processes the dtype string into a callable method name and then\n\t    calls that method with the datum string to process the data.\n\t    To use: instantiate the class and then call the class as a function with\n\t    the dtype and datum strings.\n\t    Example:\n", "    >>> dp = DatumParser()\n\t    >>> dp(\"$DATUM\", \"RXNVARIATION:STEPNO:SOLVENT:MOLSYMBOL\")\n\t    \"\"\"\n\t    def __init__(self, rxn_block: str, except_on_invalid_molecule: bool = True):\n\t        self.rxn_block = rxn_block\n\t        self.except_on_invalid_molecule = except_on_invalid_molecule\n\t    def __iter__(self) -> Iterator[tuple[Any, int, str]]:\n\t        \"\"\"Iterate over the lines in the reaction block, identifying\n\t        dtype/datum pairs and returning them as a tuple.\"\"\"\n\t        dtype_string_identifier = \"$DTYPE \"\n", "        lines = self.rxn_block.split(\"\\n\")\n\t        for line_idx, line in enumerate(lines):\n\t            if line.startswith(dtype_string_identifier):\n\t                dtype_string = line\n\t                datum_string = \"\"\n\t                # capture all the following lines until we find a line that\n\t                # starts with $DTYPE again\n\t                for datum_line in lines[line_idx + 1 :]:\n\t                    if datum_line.startswith(dtype_string_identifier):\n\t                        break\n", "                    if datum_line.endswith(\"+\"):\n\t                        # if the line ends with a plus sign, it is a\n\t                        # continuation of the previous line\n\t                        datum_string += datum_line[:-1]\n\t                    else:\n\t                        datum_string += datum_line + \"\\n\"\n\t                yield self.parse_datum(dtype_string, datum_string)\n\t    def __call__(self, *args, **kwargs):\n\t        \"\"\"Wraps parse_datum method.\"\"\"\n\t        return self.parse_datum(*args, **kwargs)\n", "    def parse_datum(self, dtype: str, datum: str) -> tuple[str, str | Molecule]:\n\t        \"\"\"Process the $DATUM datum.\n\t        Parameters\n\t        ----------\n\t        dtype : str\n\t            The $DTYPE string from the reaction block.\n\t        datum : str\n\t            The corresponding datum string from the reaction block.\n\t        Returns\n\t        -------\n", "        tuple[Any, str]\n\t            A tuple of the processed datum and the parsed\n\t            dtype string.\n\t        \"\"\"\n\t        parsed_dtype = parse_dtype_string(dtype)\n\t        datum = preprocess_datum_string(datum)\n\t        # if the datum_string is a molblock:\n\t        if detect_molblock_from_datum(datum):\n\t            datum = preprocess_datum_molblock(datum)\n\t            # try and infer the type from the dtype string, etc.)\n", "            reagent_type = \"other_reagent\"\n\t            for _reagent_type in [\"catalyst\", \"solvent\"]:\n\t                if _reagent_type in parsed_dtype or _reagent_type.upper() in parsed_dtype:\n\t                    reagent_type = _reagent_type\n\t            datum = Molecule(\n\t                mol_block=datum, component_type=reagent_type, except_on_invalid_molecule=self.except_on_invalid_molecule\n\t            )\n\t        else:\n\t            datum = datum.strip()\n\t        return parsed_dtype, datum\n", "def detect_molblock_from_datum(datum: str) -> bool:\n\t    \"\"\"Tries to detect whether a datum string is a molblock.\"\"\"\n\t    if datum.startswith(\"$MFMT\"):\n\t        return True\n\t    return False\n\tdef preprocess_datum_molblock(datum: str) -> str:\n\t    \"\"\"Strips the datum down to just the molblock.\"\"\"\n\t    return \"\\n\".join(datum.splitlines()[1:])  # remove the $MFMT line\n\tdef preprocess_datum_string(datum: str) -> str:\n\t    \"\"\"Preprocess the datum string.\n", "    Parameters\n\t    ----------\n\t    datum_str : str\n\t        The datum string.\n\t    Returns\n\t    -------\n\t    str\n\t        The preprocessed datum string.\n\t    \"\"\"\n\t    re_pattern = r\"^\\$DATUM\\s?\"\n", "    datum = re.sub(re_pattern, \"\", datum)\n\t    return datum\n\tdef parse_dtype_string(dtype_string: str) -> str:\n\t    \"\"\"Parse a $dtype line from a reaction block.\n\t    Returns the contents of the dtype line, with the prefix \"$DTYPE \" removed.\n\t    Parameters\n\t    ----------\n\t    dtype_string : str\n\t        A string containing a $dtype line.\n\t    Returns\n", "    -------\n\t    str\n\t        The contents of the $dtype line.\n\t    \"\"\"\n\t    dtype_string = dtype_string.strip()  # Remove leading and trailing whitespace.\n\t    dtype_string = dtype_string.replace(\"$DTYPE \", \"\")  # Remove the $dtype tag.\n\t    dtype_string = make_string_python_safe(dtype_string)\n\t    return dtype_string\n\tdef validate_rxn_block(rxn_block: str) -> bool:\n\t    \"\"\"Validates a rxn block.\n", "    Parameters\n\t    ----------\n\t    rxn_block : str\n\t        The rxn block.\n\t    Returns\n\t    -------\n\t    bool\n\t        True if the rxn block is valid.\n\t    \"\"\"\n\t    if rxn_block.startswith(\"$RXN\"):\n", "        return True\n\t    else:\n\t        return False\n\tdef mol_blocks_from_rxn_block(rxn_block: str, reactant_count: int, product_count: int) -> tuple[list[str], list[str]]:\n\t    \"\"\"Get the mol blocks corresponding to reactants and products from the rxn\n\t    block.\n\t    Params\n\t    ------\n\t    rxn_block : str\n\t        A reaction block string.\n", "    reactant_count : int\n\t        The number of reactants in the reaction.\n\t    product_count : int\n\t        The number of products in the reaction.\n\t    Returns\n\t    -------\n\t    reactants : list[str]\n\t        The mol blocks corresponding to reactants.\n\t    products : list[str]\n\t        The mol blocks corresponding to products.\n", "    \"\"\"\n\t    reactants: list[str] = []\n\t    products: list[str] = []\n\t    start_string = \"$MOL\\n\"\n\t    end_string = \"M  END\\n\"\n\t    # mol_blocks start with \"$MOL\" and end with \"M  END\"\n\t    # so we can just split on these and get the reactants and products.\n\t    # reactants are first, then products.\n\t    mol_blocks: list[str] = rxn_block.split(start_string)\n\t    # remove the first element as it is not a molblock\n", "    mol_blocks.pop(0)\n\t    if len(mol_blocks) > reactant_count + product_count:\n\t        raise ValueError(\n\t            \"The number of mol blocks in the rxn block is greater than the number of reactants and products.\"  # noqa: E501\n\t        )\n\t    # if any element does not end with \"M END\", then remove all lines \"M END\".\n\t    # This is important to capture the end of the last molblock correctly and\n\t    # not include reaction data\n\t    for ii, mol_block in enumerate(mol_blocks):\n\t        if not mol_block.endswith(end_string):\n", "            mol_blocks[ii] = mol_block.split(end_string)[0] + end_string  # add the end string back on\n\t    # now we have the molblocks, we can split them into reactants and products\n\t    reactants = mol_blocks[:reactant_count]\n\t    products = mol_blocks[reactant_count:]\n\t    return reactants, products\n"]}
{"filename": "docs/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t#\n\t# For the full list of built-in configuration values, see the documentation:\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\t# -- Project information -----------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\tproject = \"rdfreader\"\n\tcopyright = \"2023, Adam Hardy\"\n\tauthor = \"Adam Hardy\"\n\trelease = \"0.5.1\"\n", "# -- General configuration ---------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\textensions = []\n\ttemplates_path = [\"_templates\"]\n\texclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\t# -- Options for HTML output -------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\thtml_theme = \"alabaster\"\n\thtml_static_path = [\"_static\"]\n\textensions = [\"sphinx.ext.autodoc\"]\n"]}
