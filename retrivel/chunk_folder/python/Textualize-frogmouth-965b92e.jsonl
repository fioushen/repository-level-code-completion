{"filename": "frogmouth/__main__.py", "chunked_list": ["\"\"\"The package entry point into the application.\"\"\"\n\tfrom .app import run\n\tif __name__ == \"__main__\":\n\t    run()\n"]}
{"filename": "frogmouth/__init__.py", "chunked_list": ["\"\"\"A terminal-based Markdown document viewer, written in Textual.\"\"\"\n\t__author__ = \"Textualize, Inc\"\n\t__copyright__ = \"Copyright Textualize, Inc\"\n\t__credits__ = [\"Dave Pearson\"]\n\t__maintainer__ = \"Dave Pearson\"\n\t__email__ = \"dave@textualize.io\"\n\t__version__ = \"0.9.0\"\n\t__licence__ = \"MIT\"\n"]}
{"filename": "frogmouth/widgets/viewer.py", "chunked_list": ["\"\"\"The markdown viewer itself.\"\"\"\n\tfrom __future__ import annotations\n\tfrom collections import deque\n\tfrom pathlib import Path\n\tfrom typing import Callable\n\tfrom webbrowser import open as open_url\n\tfrom httpx import URL, AsyncClient, HTTPStatusError, RequestError\n\tfrom textual import work\n\tfrom textual.app import ComposeResult\n\tfrom textual.binding import Binding\n", "from textual.containers import VerticalScroll\n\tfrom textual.message import Message\n\tfrom textual.reactive import var\n\tfrom textual.widgets import Markdown\n\tfrom typing_extensions import Final\n\tfrom .. import __version__\n\tfrom ..dialogs import ErrorDialog\n\tfrom ..utility.advertising import APPLICATION_TITLE, USER_AGENT\n\tPLACEHOLDER = f\"\"\"\\\n\t# {APPLICATION_TITLE} {__version__}\n", "Welcome to {APPLICATION_TITLE}!\n\t\"\"\"\n\tclass History:\n\t    \"\"\"Holds the browsing history for the viewer.\"\"\"\n\t    MAXIMUM_HISTORY_LENGTH: Final[int] = 256\n\t    \"\"\"The maximum number of items we'll keep in history.\"\"\"\n\t    def __init__(self, history: list[Path | URL] | None = None) -> None:\n\t        \"\"\"Initialise the history object.\"\"\"\n\t        self._history: deque[Path | URL] = deque(\n\t            history or [], maxlen=self.MAXIMUM_HISTORY_LENGTH\n", "        )\n\t        \"\"\"The list that holds the history of locations visited.\"\"\"\n\t        self._current: int = max(len(self._history) - 1, 0)\n\t        \"\"\"The current location.\"\"\"\n\t    @property\n\t    def location(self) -> Path | URL | None:\n\t        \"\"\"The current location in the history.\"\"\"\n\t        try:\n\t            return self._history[self._current]\n\t        except IndexError:\n", "            return None\n\t    @property\n\t    def current(self) -> int | None:\n\t        \"\"\"The current location in history, or None if there is no current location.\"\"\"\n\t        return None if self.location is None else self._current\n\t    @property\n\t    def locations(self) -> list[Path | URL]:\n\t        \"\"\"The locations in the history.\"\"\"\n\t        return list(self._history)\n\t    def remember(self, location: Path | URL) -> None:\n", "        \"\"\"Remember a new location in the history.\n\t        Args:\n\t            location: The location to remember.\n\t        \"\"\"\n\t        self._history.append(location)\n\t        self._current = len(self._history) - 1\n\t    def back(self) -> bool:\n\t        \"\"\"Go back in the history.\n\t        Returns:\n\t            `True` if the location changed, `False` if not.\n", "        \"\"\"\n\t        if self._current:\n\t            self._current -= 1\n\t            return True\n\t        return False\n\t    def forward(self) -> bool:\n\t        \"\"\"Go forward in the history.\n\t        Returns:\n\t            `True` if the location changed, `False` if not.\n\t        \"\"\"\n", "        if self._current < len(self._history) - 1:\n\t            self._current += 1\n\t            return True\n\t        return False\n\t    def __delitem__(self, index: int) -> None:\n\t        del self._history[index]\n\t        self._current = max(len(self._history) - 1, self._current)\n\tclass Viewer(VerticalScroll, can_focus=True, can_focus_children=True):\n\t    \"\"\"The markdown viewer class.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n", "    Viewer {\n\t        width: 1fr;\n\t        scrollbar-gutter: stable;\n\t    }\n\t    \"\"\"\n\t    BINDINGS = [\n\t        Binding(\"w,k\", \"scroll_up\", \"\", show=False),\n\t        Binding(\"s,j\", \"scroll_down\", \"\", show=False),\n\t        Binding(\"space\", \"page_down\", \"\", show=False),\n\t        Binding(\"b\", \"page_up\", \"\", show=False),\n", "    ]\n\t    \"\"\"Bindings for the Markdown viewer widget.\"\"\"\n\t    history: var[History] = var(History)\n\t    \"\"\"The browsing history.\"\"\"\n\t    viewing_location: var[bool] = var(False)\n\t    \"\"\"Is an actual location being viewed?\"\"\"\n\t    class ViewerMessage(Message):\n\t        \"\"\"Base class for viewer messages.\"\"\"\n\t        def __init__(self, viewer: Viewer) -> None:\n\t            \"\"\"Initialise the message.\n", "            Args:\n\t                viewer: The viewer sending the message.\n\t            \"\"\"\n\t            super().__init__()\n\t            self.viewer: Viewer = viewer\n\t            \"\"\"The viewer that sent the message.\"\"\"\n\t    class LocationChanged(ViewerMessage):\n\t        \"\"\"Message sent when the viewer location changes.\"\"\"\n\t    class HistoryUpdated(ViewerMessage):\n\t        \"\"\"Message sent when the history is updated.\"\"\"\n", "    def compose(self) -> ComposeResult:\n\t        \"\"\"Compose the markdown viewer.\"\"\"\n\t        yield Markdown(PLACEHOLDER)\n\t    @property\n\t    def document(self) -> Markdown:\n\t        \"\"\"The markdown document.\"\"\"\n\t        return self.query_one(Markdown)\n\t    @property\n\t    def location(self) -> Path | URL | None:\n\t        \"\"\"The location that is currently being visited.\"\"\"\n", "        return self.history.location if self.viewing_location else None\n\t    def scroll_to_block(self, block_id: str) -> None:\n\t        \"\"\"Scroll the document to the given block ID.\n\t        Args:\n\t            block_id: The ID of the block to scroll to.\n\t        \"\"\"\n\t        self.scroll_to_widget(self.document.query_one(f\"#{block_id}\"), top=True)\n\t    def _post_load(self, location: Path | URL, remember: bool = True) -> None:\n\t        \"\"\"Perform some post-load tasks.\n\t        Args:\n", "            location: The location that has been loaded.\n\t            remember: Should we remember the location in the history?\n\t        \"\"\"\n\t        # We've loaded something fresh, ensure we're at the top.\n\t        self.scroll_home(animate=False)\n\t        # If we've made it in here we are viewing an actual location.\n\t        self.viewing_location = True\n\t        # Remember the location in the history if we're supposed to.\n\t        if remember:\n\t            self.history.remember(location)\n", "            self.post_message(self.HistoryUpdated(self))\n\t        # Let anyone else know we've changed location.\n\t        self.post_message(self.LocationChanged(self))\n\t    @work(exclusive=True)\n\t    async def _local_load(self, location: Path, remember: bool = True) -> None:\n\t        \"\"\"Load a Markdown document from a local file.\n\t        Args:\n\t            location: The location to load from.\n\t            remember: Should we remember the location in th ehistory?\n\t        \"\"\"\n", "        try:\n\t            await self.document.load(location)\n\t        except OSError as error:\n\t            self.app.push_screen(\n\t                ErrorDialog(\n\t                    \"Error loading local document\",\n\t                    f\"{location}\\n\\n{error}.\",\n\t                )\n\t            )\n\t        else:\n", "            self._post_load(location, remember)\n\t    @work(exclusive=True)\n\t    async def _remote_load(self, location: URL, remember: bool = True) -> None:\n\t        \"\"\"Load a Markdown document from a URL.\n\t        Args:\n\t            location: The location to load from.\n\t            remember: Should we remember the location in the history?\n\t        \"\"\"\n\t        try:\n\t            async with AsyncClient() as client:\n", "                response = await client.get(\n\t                    location,\n\t                    follow_redirects=True,\n\t                    headers={\"user-agent\": USER_AGENT},\n\t                )\n\t        except RequestError as error:\n\t            self.app.push_screen(ErrorDialog(\"Error getting document\", str(error)))\n\t            return\n\t        try:\n\t            response.raise_for_status()\n", "        except HTTPStatusError as error:\n\t            self.app.push_screen(ErrorDialog(\"Error getting document\", str(error)))\n\t            return\n\t        # There didn't seem to be an error transporting the data, and\n\t        # neither did there seem to be an error with the resource itself. So\n\t        # at this point we should hopefully have the document's content.\n\t        # However... it's possible we've been fooled into loading up\n\t        # something that looked like it was a markdown file, but really it's\n\t        # a web-rendering of such a file; so as a final check we make sure\n\t        # we're looking at something that's plain text, or actually\n", "        # Markdown.\n\t        content_type = response.headers.get(\"content-type\", \"\")\n\t        if any(\n\t            content_type.startswith(f\"text/{sub_type}\")\n\t            for sub_type in (\"plain\", \"markdown\", \"x-markdown\")\n\t        ):\n\t            self.document.update(response.text)\n\t            self._post_load(location, remember)\n\t        else:\n\t            # Didn't look like something we could handle with the Markdown\n", "            # viewer. We could throw up an error, or we could just be nice\n\t            # to the user. Let's be nice...\n\t            open_url(str(location))\n\t    def visit(self, location: Path | URL, remember: bool = True) -> None:\n\t        \"\"\"Visit a location.\n\t        Args:\n\t            location: The location to visit.\n\t            remember: Should this visit be added to the history?\n\t        \"\"\"\n\t        # Based on the type of the location, load up the content.\n", "        if isinstance(location, Path):\n\t            self._local_load(location.expanduser().resolve(), remember)\n\t        elif isinstance(location, URL):\n\t            self._remote_load(location, remember)\n\t        else:\n\t            raise ValueError(\"Unknown location type passed to the Markdown viewer\")\n\t    def reload(self) -> None:\n\t        \"\"\"Reload the current location.\"\"\"\n\t        if self.location is not None:\n\t            self.visit(self.location, False)\n", "    def show(self, content: str) -> None:\n\t        \"\"\"Show some direct text in the viewer.\n\t        Args:\n\t            content: The text to show.\n\t        \"\"\"\n\t        self.viewing_location = False\n\t        self.document.update(content)\n\t        self.scroll_home(animate=False)\n\t    def _jump(self, direction: Callable[[], bool]) -> None:\n\t        \"\"\"Jump in a particular direction within the history.\n", "        Args:\n\t            direction: A function that jumps in the desired direction.\n\t        \"\"\"\n\t        if direction():\n\t            if self.history.location is not None:\n\t                self.visit(self.history.location, remember=False)\n\t    def back(self) -> None:\n\t        \"\"\"Go back in the viewer history.\"\"\"\n\t        self._jump(self.history.back)\n\t    def forward(self) -> None:\n", "        \"\"\"Go forward in the viewer history.\"\"\"\n\t        self._jump(self.history.forward)\n\t    def load_history(self, history: list[Path | URL]) -> None:\n\t        \"\"\"Load up a history list from the given history.\n\t        Args:\n\t            history: The history load up from.\n\t        \"\"\"\n\t        self.history = History(history)\n\t        self.post_message(self.HistoryUpdated(self))\n\t    def delete_history(self, history_id: int) -> None:\n", "        \"\"\"Delete an item from the history.\n\t        Args:\n\t            history_id: The ID of the history item to delete.\n\t        \"\"\"\n\t        try:\n\t            del self.history[history_id]\n\t        except IndexError:\n\t            pass\n\t        else:\n\t            self.post_message(self.HistoryUpdated(self))\n", "    def clear_history(self) -> None:\n\t        \"\"\"Clear down the whole of history.\"\"\"\n\t        self.load_history([])\n"]}
{"filename": "frogmouth/widgets/__init__.py", "chunked_list": ["\"\"\"The major widgets for the application.\"\"\"\n\tfrom .navigation import Navigation\n\tfrom .omnibox import Omnibox\n\tfrom .viewer import Viewer\n\t__all__ = [\"Navigation\", \"Omnibox\", \"Viewer\"]\n"]}
{"filename": "frogmouth/widgets/omnibox.py", "chunked_list": ["\"\"\"Provides the viewer's omnibox widget.\"\"\"\n\tfrom __future__ import annotations\n\tfrom pathlib import Path\n\tfrom re import compile as compile_regexp\n\tfrom typing import Type\n\tfrom webbrowser import open as open_url\n\tfrom httpx import URL\n\tfrom textual.message import Message\n\tfrom textual.reactive import var\n\tfrom textual.widgets import Input\n", "from ..utility import is_likely_url\n\tfrom ..utility.advertising import DISCORD, ORGANISATION_NAME, PACKAGE_NAME\n\tclass Omnibox(Input):\n\t    \"\"\"The command and location input widget for the viewer.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    Omnibox {\n\t        dock: top;\n\t        padding: 0;\n\t        height: 3;\n\t    }\n", "    Omnibox .input--placeholder {\n\t        color: $text 50%;\n\t    }\n\t    \"\"\"\n\t    \"\"\"Default styling for the omnibox.\"\"\"\n\t    visiting: var[str] = var(\"\")\n\t    \"\"\"The location that is being visited.\"\"\"\n\t    def watch_visiting(self) -> None:\n\t        \"\"\"Watch the visiting reactive variable.\"\"\"\n\t        self.placeholder = self.visiting or \"Enter a location or command\"\n", "        if self.visiting:\n\t            self.value = self.visiting\n\t    _ALIASES: dict[str, str] = {\n\t        \"a\": \"about\",\n\t        \"b\": \"bookmarks\",\n\t        \"bm\": \"bookmarks\",\n\t        \"bb\": \"bitbucket\",\n\t        \"c\": \"contents\",\n\t        \"cb\": \"codeberg\",\n\t        \"cd\": \"chdir\",\n", "        \"cl\": \"changelog\",\n\t        \"gh\": \"github\",\n\t        \"gl\": \"gitlab\",\n\t        \"h\": \"history\",\n\t        \"l\": \"local\",\n\t        \"obs\": \"obsidian\",\n\t        \"toc\": \"contents\",\n\t        \"q\": \"quit\",\n\t        \"?\": \"help\",\n\t    }\n", "    \"\"\"Command aliases.\"\"\"\n\t    @staticmethod\n\t    def _split_command(value: str) -> list[str]:\n\t        \"\"\"Split a value into a command and argument tail.\n\t        Args:\n\t            value: The value to split.\n\t        Returns:\n\t            A list of the command and the argument(s).\n\t        \"\"\"\n\t        command = value.split(None, 1)\n", "        return [*command, \"\"] if len(command) == 1 else command\n\t    def _is_command(self, value: str) -> bool:\n\t        \"\"\"Is the given string a known command?\n\t        Args:\n\t            value: The value to check.\n\t        Returns:\n\t            `True` if the string is a known command, `False` if not.\n\t        \"\"\"\n\t        command, *_ = self._split_command(value)\n\t        return (\n", "            getattr(self, f\"command_{self._ALIASES.get(command, command)}\", None)\n\t            is not None\n\t        )\n\t    def _execute_command(self, command: str) -> None:\n\t        \"\"\"Execute the given command.\n\t        Args:\n\t            command: The comment to execute.\n\t        \"\"\"\n\t        command, arguments = self._split_command(command)\n\t        getattr(self, f\"command_{self._ALIASES.get(command, command)}\")(\n", "            arguments.strip()\n\t        )\n\t    class LocalViewCommand(Message):\n\t        \"\"\"The local file view command.\"\"\"\n\t        def __init__(self, path: Path) -> None:\n\t            \"\"\"Initialise the local view command.\n\t            Args:\n\t                path: The path to view.\n\t            \"\"\"\n\t            super().__init__()\n", "            self.path = path\n\t            \"\"\"The path of the file to view.\"\"\"\n\t    class RemoteViewCommand(Message):\n\t        \"\"\"The remote file view command.\"\"\"\n\t        def __init__(self, url: URL) -> None:\n\t            \"\"\"Initialise the remove view command.\n\t            Args:\n\t                url: The URL of the remote file to view.\n\t            \"\"\"\n\t            super().__init__()\n", "            self.url = url\n\t            \"\"\"The URL of the file to view.\"\"\"\n\t    class LocalChdirCommand(Message):\n\t        \"\"\"Command for changing the local files directory.\"\"\"\n\t        def __init__(self, target: Path) -> None:\n\t            \"\"\"Initialise the local files chdir command.\"\"\"\n\t            super().__init__()\n\t            self.target = target\n\t            \"\"\"The target directory to change to.\"\"\"\n\t    def on_input_submitted(self, event: Input.Submitted) -> None:\n", "        \"\"\"Handle the user submitting the input.\n\t        Args:\n\t            event: The submit event.\n\t        \"\"\"\n\t        # Clean up whatever the user input.\n\t        submitted = self.value.strip()\n\t        # Now that we've got it, empty the value. We'll put it back\n\t        # depending on the outcome.\n\t        self.value = \"\"\n\t        # Work through the possible options for what the user entered.\n", "        if is_likely_url(submitted):\n\t            # It looks like it's an URL of some description so try and load\n\t            # it as such.\n\t            self.post_message(self.RemoteViewCommand(URL(submitted)))\n\t        elif (path := Path(submitted).expanduser().resolve()).exists():\n\t            # It's a match for something in the local filesystem. Is it...\n\t            if path.is_file():\n\t                # a file! Try and open it for viewing.\n\t                self.post_message(self.LocalViewCommand(path))\n\t                self.value = str(path)\n", "            elif path.is_dir():\n\t                # Nope, it's a directory. Take that to be a request to open\n\t                # the local file selection navigation pane with the\n\t                # directory as the root.\n\t                self.post_message(self.LocalChdirCommand(path))\n\t            else:\n\t                # It's something that exists in the filesystem, but it's not\n\t                # a directory or a file. Let's nope on that for now.\n\t                return\n\t        elif self._is_command(command := submitted.lower()):\n", "            # Having checked for URLs and existing filesystem things, it's\n\t            # now safe to look for commands. Having got here, it is a match\n\t            # for a command so we handle it as such.\n\t            self._execute_command(command)\n\t        else:\n\t            # Having got this far, the best thing to do now is assume that\n\t            # the user was attempting to enter a filename to view and got it\n\t            # wrong. So that they get some sort of feedback, let's attempt\n\t            # to view it anyway.\n\t            self.post_message(self.LocalViewCommand(Path(submitted)))\n", "            # Because it'll raise an error and the user may want to edit the\n\t            # input to get it right, we put the original input back in\n\t            # place.\n\t            self.value = submitted\n\t        # If we got a match above stop the event.\n\t        event.stop()\n\t    class ContentsCommand(Message):\n\t        \"\"\"The table of contents command.\"\"\"\n\t    def command_contents(self, _: str) -> None:\n\t        \"\"\"Handle the table of contents command.\"\"\"\n", "        self.post_message(self.ContentsCommand())\n\t    class LocalFilesCommand(Message):\n\t        \"\"\"The local files command.\"\"\"\n\t    def command_local(self, _: str) -> None:\n\t        \"\"\"View the local files.\"\"\"\n\t        self.post_message(self.LocalFilesCommand())\n\t    class BookmarksCommand(Message):\n\t        \"\"\"The bookmarks command.\"\"\"\n\t    def command_bookmarks(self, _: str) -> None:\n\t        \"\"\"View the bookmarks.\"\"\"\n", "        self.post_message(self.BookmarksCommand())\n\t    class QuitCommand(Message):\n\t        \"\"\"The quit command.\"\"\"\n\t    def command_quit(self, _: str) -> None:\n\t        \"\"\"The quit command.\"\"\"\n\t        self.post_message(self.QuitCommand())\n\t    class HistoryCommand(Message):\n\t        \"\"\"The history command.\"\"\"\n\t    def command_history(self, _: str) -> None:\n\t        \"\"\"The history command.\"\"\"\n", "        self.post_message(self.HistoryCommand())\n\t    class AboutCommand(Message):\n\t        \"\"\"The about command.\"\"\"\n\t    def command_about(self, _: str) -> None:\n\t        \"\"\"The about command.\"\"\"\n\t        self.post_message(self.AboutCommand())\n\t    class HelpCommand(Message):\n\t        \"\"\"The help command.\"\"\"\n\t    def command_help(self, _: str) -> None:\n\t        \"\"\"The help command.\"\"\"\n", "        self.post_message(self.HelpCommand())\n\t    def command_chdir(self, target: str) -> None:\n\t        \"\"\"The chdir command.\n\t        Args:\n\t            target: The target directory to change to.\n\t        \"\"\"\n\t        self.post_message(\n\t            self.LocalChdirCommand(Path(target or \"~\").expanduser().resolve())\n\t        )\n\t    _GUESS_BRANCH = compile_regexp(\n", "        r\"^(?P<owner>[^/ ]+)[/ ](?P<repo>[^ :]+)(?: +(?P<file>[^ ]+))?$\"\n\t    )\n\t    \"\"\"Regular expression for matching a repo and file where we'll guess the branch.\"\"\"\n\t    _SPECIFIC_BRANCH = compile_regexp(\n\t        r\"^(?P<owner>[^/ ]+)[/ ](?P<repo>[^ :]+):(?P<branch>[^ ]+)(?: +(?P<file>[^ ]+))?$\"\n\t    )\n\t    \"\"\"Regular expression for matching a repo and file where the branch is also given.\"\"\"\n\t    class ForgeCommand(Message):\n\t        \"\"\"The base git forge quick load command.\"\"\"\n\t        def __init__(\n", "            self,\n\t            owner: str,\n\t            repository: str,\n\t            branch: str | None = None,\n\t            desired_file: str | None = None,\n\t        ) -> None:\n\t            \"\"\"Initialise the git forge quick load command.\"\"\"\n\t            super().__init__()\n\t            self.owner = owner\n\t            \"\"\"The owner of the repository.\"\"\"\n", "            self.repository = repository\n\t            \"\"\"The repository.\"\"\"\n\t            self.branch: str | None = branch\n\t            \"\"\"The optional branch to attempt to pull the file from.\"\"\"\n\t            self.desired_file: str | None = desired_file\n\t            \"\"\"The optional file the user wants from the repository.\"\"\"\n\t    def _forge_quick_look(self, command: Type[ForgeCommand], tail: str) -> None:\n\t        \"\"\"Core forge quick look support method.\n\t        Args:\n\t            command: The command message to be posted.\n", "            tail: The tail of the command to be parsed.\n\t        \"\"\"\n\t        tail = tail.strip()\n\t        if hit := self._GUESS_BRANCH.match(tail):\n\t            self.post_message(\n\t                command(hit[\"owner\"], hit[\"repo\"], desired_file=hit[\"file\"])\n\t            )\n\t        elif hit := self._SPECIFIC_BRANCH.match(tail):\n\t            self.post_message(\n\t                command(\n", "                    hit[\"owner\"],\n\t                    hit[\"repo\"],\n\t                    branch=hit[\"branch\"],\n\t                    desired_file=hit[\"file\"],\n\t                )\n\t            )\n\t    class GitHubCommand(ForgeCommand):\n\t        \"\"\"The GitHub quick load command.\"\"\"\n\t    def command_github(self, tail: str) -> None:\n\t        \"\"\"The github command.\n", "        Args:\n\t            tail: The tail of the command.\n\t        \"\"\"\n\t        self._forge_quick_look(self.GitHubCommand, tail)\n\t    class GitLabCommand(ForgeCommand):\n\t        \"\"\"The GitLab quick load command.\"\"\"\n\t    def command_gitlab(self, tail: str) -> None:\n\t        \"\"\"The Gitlab command.\n\t        Args:\n\t            tail: The tail of the command.\n", "        \"\"\"\n\t        self._forge_quick_look(self.GitLabCommand, tail)\n\t    class BitBucketCommand(ForgeCommand):\n\t        \"\"\"The BitBucket quick load command.\"\"\"\n\t    def command_bitbucket(self, tail: str) -> None:\n\t        \"\"\"The BitBucket command.\n\t        Args:\n\t            tail: The tail of the command.\n\t        \"\"\"\n\t        self._forge_quick_look(self.BitBucketCommand, tail)\n", "    class CodebergCommand(ForgeCommand):\n\t        \"\"\"The Codeberg quick load command.\"\"\"\n\t    def command_codeberg(self, tail: str) -> None:\n\t        \"\"\"The Codeberg command.\n\t        Args:\n\t            tail: The tail of the command.\n\t        \"\"\"\n\t        self._forge_quick_look(self.CodebergCommand, tail)\n\t    def command_discord(self, _: str) -> None:\n\t        \"\"\"The command to visit the Textualize discord server.\"\"\"\n", "        open_url(DISCORD)\n\t    def command_changelog(self, _: str) -> None:\n\t        \"\"\"The command to show the application's own ChangeLog\"\"\"\n\t        self.command_github(f\"{ORGANISATION_NAME}/{PACKAGE_NAME} ChangeLog.md\")\n\t    def command_obsidian(self, vault: str) -> None:\n\t        \"\"\"The command to visit an obsidian vault, if one can be seen.\n\t        Args:\n\t            vault: The vault to visit.\n\t        If the vault name is empty, an attempt will be made to visit the\n\t        root level of all Obsidian vaults.\n", "        Note:\n\t            At the moment this will only work with Obsidian on macOS where\n\t            the vaults are being held in iCloud.\n\t        \"\"\"\n\t        # Right now this will only work on macOS. I've not used Obsidian on\n\t        # any other OS so I'm unsure where the vault will be stored. I'll\n\t        # add to this once I've found out.\n\t        if (\n\t            target := (\n\t                Path(\n", "                    \"~/Library/Mobile Documents/iCloud~md~obsidian/Documents\"\n\t                ).expanduser()\n\t                / vault\n\t            )\n\t        ).exists():\n\t            self.command_chdir(str(target))\n"]}
{"filename": "frogmouth/widgets/navigation.py", "chunked_list": ["\"\"\"Provides the navigation panel widget.\"\"\"\n\tfrom __future__ import annotations\n\tfrom pathlib import Path\n\tfrom textual.app import ComposeResult\n\tfrom textual.binding import Binding\n\tfrom textual.containers import Vertical\n\tfrom textual.message import Message\n\tfrom textual.reactive import var\n\tfrom textual.widgets import TabbedContent, Tabs\n\tfrom typing_extensions import Self\n", "from ..data import load_config, save_config\n\tfrom .navigation_panes.bookmarks import Bookmarks\n\tfrom .navigation_panes.history import History\n\tfrom .navigation_panes.local_files import LocalFiles\n\tfrom .navigation_panes.navigation_pane import NavigationPane\n\tfrom .navigation_panes.table_of_contents import TableOfContents\n\tclass Navigation(Vertical, can_focus=False, can_focus_children=True):\n\t    \"\"\"A navigation panel widget.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    Navigation {\n", "        width: 44;\n\t        background: $panel;\n\t        display: block;\n\t        dock: left;\n\t    }\n\t    Navigation.hidden {\n\t        display: none;\n\t    }\n\t    TabbedContent {\n\t        height: 100% !important;\n", "    }\n\t    ContentSwitcher {\n\t        height: 1fr !important;\n\t    }\n\t    \"\"\"\n\t    BINDINGS = [\n\t        Binding(\"comma,a,ctrl+left,shift+left,h\", \"previous_tab\", \"\", show=False),\n\t        Binding(\"full_stop,d,ctrl+right,shift+right,l\", \"next_tab\", \"\", show=False),\n\t        Binding(\"\\\\\", \"toggle_dock\", \"Dock left/right\"),\n\t    ]\n", "    \"\"\"Bindings local to the navigation pane.\"\"\"\n\t    popped_out: var[bool] = var(False)\n\t    \"\"\"Is the navigation popped out?\"\"\"\n\t    docked_left: var[bool] = var(True)\n\t    \"\"\"Should navigation be docked to the left side of the screen?\"\"\"\n\t    def compose(self) -> ComposeResult:\n\t        \"\"\"Compose the content of the navigation pane.\"\"\"\n\t        self.popped_out = False\n\t        # pylint:disable=attribute-defined-outside-init\n\t        self._contents = TableOfContents()\n", "        self._local_files = LocalFiles()\n\t        self._bookmarks = Bookmarks()\n\t        self._history = History()\n\t        with TabbedContent() as tabs:\n\t            self._tabs = tabs\n\t            yield self._contents\n\t            yield self._local_files\n\t            yield self._bookmarks\n\t            yield self._history\n\t    def on_mount(self) -> None:\n", "        \"\"\"Configure navigation once the DOM is set up.\"\"\"\n\t        self.docked_left = load_config().navigation_left\n\t    class Hidden(Message):\n\t        \"\"\"Message sent when the navigation is hidden.\"\"\"\n\t    def watch_popped_out(self) -> None:\n\t        \"\"\"Watch for changes to the popped out state.\"\"\"\n\t        self.set_class(not self.popped_out, \"hidden\")\n\t        if not self.popped_out:\n\t            self.post_message(self.Hidden())\n\t    def toggle(self) -> None:\n", "        \"\"\"Toggle the popped/unpopped state.\"\"\"\n\t        self.popped_out = not self.popped_out\n\t    def watch_docked_left(self) -> None:\n\t        \"\"\"Watch for changes to the left-docking status.\"\"\"\n\t        self.styles.dock = \"left\" if self.docked_left else \"right\"\n\t    @property\n\t    def table_of_contents(self) -> TableOfContents:\n\t        \"\"\"The table of contents widget.\"\"\"\n\t        return self._contents\n\t    @property\n", "    def local_files(self) -> LocalFiles:\n\t        \"\"\"The local files widget.\"\"\"\n\t        return self._local_files\n\t    @property\n\t    def bookmarks(self) -> Bookmarks:\n\t        \"\"\"The bookmarks widget.\"\"\"\n\t        return self._bookmarks\n\t    @property\n\t    def history(self) -> History:\n\t        \"\"\"The history widget.\"\"\"\n", "        return self._history\n\t    def jump_to_local_files(self, target: Path | None = None) -> Self:\n\t        \"\"\"Switch to and focus the local files pane.\n\t        Returns:\n\t            Self.\n\t        \"\"\"\n\t        if (\n\t            self.popped_out\n\t            and target is None\n\t            and self.query_one(Tabs).active == self._local_files.id\n", "        ):\n\t            self.popped_out = False\n\t        else:\n\t            self.popped_out = True\n\t            if target is not None:\n\t                self._local_files.chdir(target)\n\t            self._local_files.activate().set_focus_within()\n\t        return self\n\t    def jump_to_bookmarks(self) -> Self:\n\t        \"\"\"Switch to and focus the bookmarks pane.\n", "        Returns:\n\t            Self.\n\t        \"\"\"\n\t        if self.popped_out and self.query_one(Tabs).active == self._bookmarks.id:\n\t            self.popped_out = False\n\t        else:\n\t            self.popped_out = True\n\t            self._bookmarks.activate().set_focus_within()\n\t        return self\n\t    def jump_to_history(self) -> Self:\n", "        \"\"\"Switch to and focus the history pane.\n\t        Returns:\n\t            Self.\n\t        \"\"\"\n\t        if self.popped_out and self.query_one(Tabs).active == self._history.id:\n\t            self.popped_out = False\n\t        else:\n\t            self.popped_out = True\n\t            self._history.activate().set_focus_within()\n\t        return self\n", "    def jump_to_contents(self) -> Self:\n\t        \"\"\"Switch to and focus the table of contents pane.\n\t        Returns:\n\t            Self.\n\t        \"\"\"\n\t        if self.popped_out and self.query_one(Tabs).active == self._contents.id:\n\t            self.popped_out = False\n\t        else:\n\t            self.popped_out = True\n\t            self._contents.activate().set_focus_within()\n", "        return self\n\t    def action_previous_tab(self) -> None:\n\t        \"\"\"Switch to the previous tab in the navigation pane.\"\"\"\n\t        self.query_one(Tabs).action_previous_tab()\n\t        self.focus_tab()\n\t    def action_next_tab(self) -> None:\n\t        \"\"\"Switch to the next tab in the navigation pane.\"\"\"\n\t        self.query_one(Tabs).action_next_tab()\n\t        self.focus_tab()\n\t    def action_toggle_dock(self) -> None:\n", "        \"\"\"Toggle the dock side for the navigation.\"\"\"\n\t        config = load_config()\n\t        config.navigation_left = not config.navigation_left\n\t        save_config(config)\n\t        self.docked_left = config.navigation_left\n\t    def focus_tab(self) -> None:\n\t        \"\"\"Focus the currently active tab.\"\"\"\n\t        if active := self.query_one(Tabs).active:\n\t            self.query_one(\n\t                f\"NavigationPane#{active}\", NavigationPane\n", "            ).set_focus_within()\n"]}
{"filename": "frogmouth/widgets/navigation_panes/bookmarks.py", "chunked_list": ["\"\"\"Provides the bookmarks navigation pane.\"\"\"\n\tfrom __future__ import annotations\n\tfrom functools import partial\n\tfrom pathlib import Path\n\tfrom httpx import URL\n\tfrom rich.text import Text\n\tfrom textual.app import ComposeResult\n\tfrom textual.binding import Binding\n\tfrom textual.message import Message\n\tfrom textual.widgets import OptionList\n", "from textual.widgets.option_list import Option\n\tfrom ...data import Bookmark, load_bookmarks, save_bookmarks\n\tfrom ...dialogs import InputDialog, YesNoDialog\n\tfrom .navigation_pane import NavigationPane\n\tclass Entry(Option):\n\t    \"\"\"An entry in the bookmark list.\"\"\"\n\t    def __init__(self, bookmark: Bookmark) -> None:\n\t        super().__init__(self._as_prompt(bookmark))\n\t        self.bookmark = bookmark\n\t        \"\"\"The bookmark that this entry relates to.\"\"\"\n", "    @staticmethod\n\t    def _as_prompt(bookmark: Bookmark) -> Text:\n\t        \"\"\"Depict the bookmark as a decorated prompt.\n\t        Args:\n\t            bookmark: The bookmark to depict.\n\t        Returns:\n\t            A prompt with icon, etc.\n\t        \"\"\"\n\t        return Text.from_markup(\n\t            f\":{'page_facing_up' if isinstance(bookmark.location, Path) else 'globe_with_meridians'}: \"\n", "            f\"[bold]{bookmark.title}[/]\\n[dim]{bookmark.location}[/]\",\n\t            overflow=\"ellipsis\",\n\t        )\n\tclass Bookmarks(NavigationPane):\n\t    \"\"\"Bookmarks navigation pane.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    Bookmarks {\n\t        height: 100%;\n\t    }\n\t    Bookmarks > OptionList {\n", "        background: $panel;\n\t        border: none;\n\t        height: 1fr;\n\t    }\n\t    Bookmarks > OptionList:focus {\n\t        border: none;\n\t    }\n\t    \"\"\"\n\t    \"\"\"The default CSS for the bookmarks navigation pane.\"\"\"\n\t    BINDINGS = [\n", "        Binding(\"delete\", \"delete\", \"Delete the bookmark\"),\n\t        Binding(\"r\", \"rename\", \"Rename the bookmark\"),\n\t    ]\n\t    \"\"\"The bindings for the bookmarks navigation pane.\"\"\"\n\t    def __init__(self) -> None:\n\t        \"\"\"Initialise the bookmarks navigation pane.\"\"\"\n\t        super().__init__(\"Bookmarks\")\n\t        self._bookmarks: list[Bookmark] = load_bookmarks()\n\t        \"\"\"The internal list of bookmarks.\"\"\"\n\t    def compose(self) -> ComposeResult:\n", "        \"\"\"Compose the child widgets.\"\"\"\n\t        yield OptionList(*[Entry(bookmark) for bookmark in self._bookmarks])\n\t    def set_focus_within(self) -> None:\n\t        \"\"\"Focus the option list.\"\"\"\n\t        self.query_one(OptionList).focus(scroll_visible=False)\n\t    def _bookmarks_updated(self) -> None:\n\t        \"\"\"Handle the bookmarks being updated.\"\"\"\n\t        # It's slightly costly, but currently there's no easier way to do\n\t        # this; and really it's not going to be that frequent. Here we nuke\n\t        # the content of the OptionList and rebuild it based on the actual\n", "        # list of bookmarks.\n\t        bookmarks = self.query_one(OptionList)\n\t        old_position = bookmarks.highlighted\n\t        bookmarks.clear_options()\n\t        for bookmark in self._bookmarks:\n\t            bookmarks.add_option(Entry(bookmark))\n\t        save_bookmarks(self._bookmarks)\n\t        bookmarks.highlighted = old_position\n\t    def add_bookmark(self, title: str, location: Path | URL) -> None:\n\t        \"\"\"Add a new bookmark.\n", "        Args:\n\t            title: The title of the bookmark.\n\t            location: The location of the bookmark.\n\t        \"\"\"\n\t        self._bookmarks.append(Bookmark(title, location))\n\t        self._bookmarks = sorted(self._bookmarks, key=lambda bookmark: bookmark.title)\n\t        self._bookmarks_updated()\n\t    class Goto(Message):\n\t        \"\"\"Message that requests that the viewer goes to a given bookmark.\"\"\"\n\t        def __init__(self, bookmark: Bookmark) -> None:\n", "            \"\"\"Initialise the bookmark goto message.\n\t            Args:\n\t                bookmark: The bookmark to go to.\n\t            \"\"\"\n\t            super().__init__()\n\t            self.bookmark = bookmark\n\t    def on_option_list_option_selected(self, event: OptionList.OptionSelected) -> None:\n\t        \"\"\"Handle an entry in the bookmarks being selected.\n\t        Args:\n\t            event: The event to handle.\n", "        \"\"\"\n\t        event.stop()\n\t        assert isinstance(event.option, Entry)\n\t        self.post_message(self.Goto(event.option.bookmark))\n\t    def delete_bookmark(self, bookmark: int, delete_it: bool) -> None:\n\t        \"\"\"Delete a given bookmark.\n\t        Args:\n\t            bookmark: The bookmark to delete.\n\t            delete_it: Should it be deleted?\n\t        \"\"\"\n", "        if delete_it:\n\t            del self._bookmarks[bookmark]\n\t            self._bookmarks_updated()\n\t    def action_delete(self) -> None:\n\t        \"\"\"Delete the highlighted bookmark.\"\"\"\n\t        if (bookmark := self.query_one(OptionList).highlighted) is not None:\n\t            self.app.push_screen(\n\t                YesNoDialog(\n\t                    \"Delete bookmark\",\n\t                    \"Are you sure you want to delete the bookmark?\",\n", "                ),\n\t                partial(self.delete_bookmark, bookmark),\n\t            )\n\t    def rename_bookmark(self, bookmark: int, new_name: str) -> None:\n\t        \"\"\"Rename the current bookmark.\n\t        Args:\n\t            bookmark: The location of the bookmark to rename.\n\t            new_name: The input dialog result that is the new name.\n\t        \"\"\"\n\t        self._bookmarks[bookmark] = Bookmark(\n", "            new_name, self._bookmarks[bookmark].location\n\t        )\n\t        self._bookmarks_updated()\n\t    def action_rename(self) -> None:\n\t        \"\"\"Rename the highlighted bookmark.\"\"\"\n\t        if (bookmark := self.query_one(OptionList).highlighted) is not None:\n\t            self.app.push_screen(\n\t                InputDialog(\n\t                    \"Bookmark title:\",\n\t                    self._bookmarks[bookmark].title,\n", "                ),\n\t                partial(self.rename_bookmark, bookmark),\n\t            )\n"]}
{"filename": "frogmouth/widgets/navigation_panes/table_of_contents.py", "chunked_list": ["\"\"\"Provides the table of contents navigation pane.\"\"\"\n\tfrom textual.app import ComposeResult\n\tfrom textual.widgets import Markdown, Tree\n\tfrom textual.widgets.markdown import MarkdownTableOfContents\n\tfrom .navigation_pane import NavigationPane\n\tclass TableOfContents(NavigationPane):\n\t    \"\"\"Markdown document table of contents navigation pane.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    TableOfContents {\n\t        height: 100%;\n", "    }\n\t    TableOfContents > MarkdownTableOfContents {\n\t        background: $panel;\n\t        border: none;\n\t    }\n\t    TableOfContents > MarkdownTableOfContents > Tree {\n\t        width: 1fr;\n\t        background: $panel;\n\t        padding: 0;\n\t    }\n", "    TableOfContents > MarkdownTableOfContents > Tree:focus .tree--cursor, TableOfContents > MarkdownTableOfContents > Tree .tree--cursor {\n\t        background: $accent 50%;\n\t        color: $text;\n\t    }\n\t    \"\"\"\n\t    def __init__(self) -> None:\n\t        \"\"\"Initialise the table of contents navigation pane.\"\"\"\n\t        super().__init__(\"Contents\")\n\t    def set_focus_within(self) -> None:\n\t        \"\"\"Ensure the tree in the table of contents is focused.\"\"\"\n", "        self.query_one(\"MarkdownTableOfContents > Tree\", Tree).focus(\n\t            scroll_visible=False\n\t        )\n\t    def compose(self) -> ComposeResult:\n\t        \"\"\"Compose the child widgets.\"\"\"\n\t        # Note the use of a throwaway Markdown object. Textual 0.24\n\t        # introduced a requirement for MarkdownTableOfContents to take a\n\t        # reference to a Markdown document; this is a problem if you're\n\t        # composing the ToC in a location somewhere unrelated to the\n\t        # document itself, such that you can't guarantee the order in which\n", "        # they're compose. I'm not using the ToC in a way that's\n\t        # tightly-coupled to the document, neither am I using multiple ToCs\n\t        # and documents. So... we make one and ignore it.\n\t        #\n\t        # https://github.com/Textualize/textual/issues/2516\n\t        yield MarkdownTableOfContents(Markdown())\n\t    def on_table_of_contents_updated(\n\t        self, event: Markdown.TableOfContentsUpdated\n\t    ) -> None:\n\t        \"\"\"Handle a table of contents update event.\n", "        Args:\n\t            event: The table of content update event to handle.\n\t        \"\"\"\n\t        self.query_one(\n\t            MarkdownTableOfContents\n\t        ).table_of_contents = event.table_of_contents\n"]}
{"filename": "frogmouth/widgets/navigation_panes/history.py", "chunked_list": ["\"\"\"Provides the history navigation pane.\"\"\"\n\tfrom __future__ import annotations\n\tfrom functools import partial\n\tfrom pathlib import Path\n\tfrom httpx import URL\n\tfrom rich.text import Text\n\tfrom textual.app import ComposeResult\n\tfrom textual.binding import Binding\n\tfrom textual.message import Message\n\tfrom textual.widgets import OptionList\n", "from textual.widgets.option_list import Option\n\tfrom ...dialogs import YesNoDialog\n\tfrom .navigation_pane import NavigationPane\n\tclass Entry(Option):\n\t    \"\"\"An entry in the history.\"\"\"\n\t    def __init__(self, history_id: int, location: Path | URL) -> None:\n\t        \"\"\"Initialise the history entry item.\n\t        Args:\n\t            history_id: The ID of the item of history.\n\t            location: The location being added to history.\n", "        \"\"\"\n\t        super().__init__(self._as_prompt(location))\n\t        self.history_id = history_id\n\t        \"\"\"The ID of the item of history.\"\"\"\n\t        self.location = location\n\t        \"\"\"The location for his entry in the history.\"\"\"\n\t    @staticmethod\n\t    def _as_prompt(location: Path | URL) -> Text:\n\t        \"\"\"Depict the location as a decorated prompt.\n\t        Args:\n", "            location: The location to depict.\n\t        Returns:\n\t            A prompt with icon, etc.\n\t        \"\"\"\n\t        if isinstance(location, Path):\n\t            return Text.from_markup(\n\t                f\":page_facing_up: [bold]{location.name}[/]\\n[dim]{location.parent}[/]\",\n\t                overflow=\"ellipsis\",\n\t            )\n\t        return Text.from_markup(\n", "            f\":globe_with_meridians: [bold]{Path(location.path).name}[/]\"\n\t            f\"\\n[dim]{Path(location.path).parent}\\n{location.host}[/]\",\n\t            overflow=\"ellipsis\",\n\t        )\n\tclass History(NavigationPane):\n\t    \"\"\"History navigation pane.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    History {\n\t        height: 100%;\n\t    }\n", "    History > OptionList {\n\t        background: $panel;\n\t        border: none;\n\t        height: 1fr;\n\t    }\n\t    History > OptionList:focus {\n\t        border: none;\n\t    }\n\t    \"\"\"\n\t    BINDINGS = [\n", "        Binding(\"delete\", \"delete\", \"Delete the history item\"),\n\t        Binding(\"backspace\", \"clear\", \"Clean the history\"),\n\t    ]\n\t    \"\"\"The bindings for the history navigation pane.\"\"\"\n\t    def __init__(self) -> None:\n\t        \"\"\"Initialise the history navigation pane.\"\"\"\n\t        super().__init__(\"History\")\n\t    def compose(self) -> ComposeResult:\n\t        \"\"\"Compose the child widgets.\"\"\"\n\t        yield OptionList()\n", "    def set_focus_within(self) -> None:\n\t        \"\"\"Focus the option list.\"\"\"\n\t        self.query_one(OptionList).focus(scroll_visible=False)\n\t    def update_from(self, locations: list[Path | URL]) -> None:\n\t        \"\"\"Update the history from the given list of locations.\n\t        Args:\n\t            locations: A list of locations to update the history with.\n\t        This call removes any existing history and sets it to the given\n\t        value.\n\t        \"\"\"\n", "        option_list = self.query_one(OptionList).clear_options()\n\t        for history_id, location in reversed(list(enumerate(locations))):\n\t            option_list.add_option(Entry(history_id, location))\n\t    class Goto(Message):\n\t        \"\"\"Message that requests the viewer goes to a given location.\"\"\"\n\t        def __init__(self, location: Path | URL) -> None:\n\t            \"\"\"Initialise the history goto message.\n\t            Args:\n\t                location: The location to go to.\n\t            \"\"\"\n", "            super().__init__()\n\t            self.location = location\n\t            \"\"\"The location to go to.\"\"\"\n\t    def on_option_list_option_selected(self, event: OptionList.OptionSelected) -> None:\n\t        \"\"\"Handle an entry in the history being selected.\n\t        Args:\n\t            event: The event to handle.\n\t        \"\"\"\n\t        event.stop()\n\t        assert isinstance(event.option, Entry)\n", "        self.post_message(self.Goto(event.option.location))\n\t    class Delete(Message):\n\t        \"\"\"Message that requests the viewer to delete an item of history.\"\"\"\n\t        def __init__(self, history_id: int) -> None:\n\t            \"\"\"initialise the history delete message.\n\t            args:\n\t                history_id: The ID of the item of history to delete.\n\t            \"\"\"\n\t            super().__init__()\n\t            self.history_id = history_id\n", "            \"\"\"The ID of the item of history to delete.\"\"\"\n\t    def delete_history(self, history_id: int, delete_it: bool) -> None:\n\t        \"\"\"Delete a given history entry.\n\t        Args:\n\t            history_id: The ID of the item of history to delete.\n\t            delete_it: Should it be deleted?\n\t        \"\"\"\n\t        if delete_it:\n\t            self.post_message(self.Delete(history_id))\n\t    def action_delete(self) -> None:\n", "        \"\"\"Delete the highlighted item from history.\"\"\"\n\t        history = self.query_one(OptionList)\n\t        if (item := history.highlighted) is not None:\n\t            assert isinstance(entry := history.get_option_at_index(item), Entry)\n\t            self.app.push_screen(\n\t                YesNoDialog(\n\t                    \"Delete history entry?\",\n\t                    \"Are you sure you want to delete the history entry?\",\n\t                ),\n\t                partial(self.delete_history, entry.history_id),\n", "            )\n\t    class Clear(Message):\n\t        \"\"\"Message that requests that the history be cleared.\"\"\"\n\t    def clear_history(self, clear_it: bool) -> None:\n\t        \"\"\"Perform a history clear.\n\t        Args:\n\t            clear_it: Should it be cleared?\n\t        \"\"\"\n\t        if clear_it:\n\t            self.post_message(self.Clear())\n", "    def action_clear(self) -> None:\n\t        \"\"\"Clear out the whole history.\"\"\"\n\t        self.app.push_screen(\n\t            YesNoDialog(\n\t                \"Clear history?\",\n\t                \"Are you sure you want to clear everything out of history?\",\n\t            ),\n\t            self.clear_history,\n\t        )\n"]}
{"filename": "frogmouth/widgets/navigation_panes/__init__.py", "chunked_list": ["\"\"\"Provides the panes that go into the main navigation area.\"\"\"\n\tfrom .bookmarks import Bookmarks\n\tfrom .history import History\n\tfrom .local_files import LocalFiles\n\tfrom .table_of_contents import TableOfContents\n\t__all__ = [\n\t    \"Bookmarks\",\n\t    \"History\",\n\t    \"LocalFiles\",\n\t    \"TableOfContents\",\n", "]\n"]}
{"filename": "frogmouth/widgets/navigation_panes/navigation_pane.py", "chunked_list": ["\"\"\"Provides a base class for all navigation panes.\"\"\"\n\tfrom textual.widgets import TabbedContent, TabPane\n\tfrom typing_extensions import Self\n\tclass NavigationPane(TabPane):\n\t    \"\"\"Base class for panes within the navigation sidebar.\"\"\"\n\t    def set_focus_within(self) -> None:\n\t        \"\"\"Set the focus on the correct child within the navigation pane.\"\"\"\n\t    def activate(self) -> Self:\n\t        \"\"\"Activate the navigation pane.\n\t        Returns:\n", "            Self.\n\t        \"\"\"\n\t        assert self.parent is not None\n\t        if self.id is not None and isinstance(self.parent.parent, TabbedContent):\n\t            self.parent.parent.active = self.id\n\t        return self\n"]}
{"filename": "frogmouth/widgets/navigation_panes/local_files.py", "chunked_list": ["\"\"\"Provides the local files navigation pane.\"\"\"\n\tfrom __future__ import annotations\n\tfrom pathlib import Path\n\tfrom typing import Iterable\n\tfrom httpx import URL\n\tfrom textual.app import ComposeResult\n\tfrom textual.message import Message\n\tfrom textual.widgets import DirectoryTree\n\tfrom ...utility import maybe_markdown\n\tfrom .navigation_pane import NavigationPane\n", "class FilteredDirectoryTree(DirectoryTree):  # pylint:disable=too-many-ancestors\n\t    \"\"\"A `DirectoryTree` filtered for the markdown viewer.\"\"\"\n\t    def filter_paths(self, paths: Iterable[Path]) -> Iterable[Path]:\n\t        \"\"\"Filter the directory tree for the Markdown viewer.\n\t        Args:\n\t            paths: The paths to be filtered.\n\t        Returns:\n\t            The parts filtered for the Markdown viewer.\n\t        The filtered set will include all filesystem entries that aren't\n\t        hidden (in a Unix sense of hidden) which are either a directory or a\n", "        file that looks like it could be a Markdown document.\n\t        \"\"\"\n\t        try:\n\t            return [\n\t                path\n\t                for path in paths\n\t                if not path.name.startswith(\".\")\n\t                and path.is_dir()\n\t                or (path.is_file() and maybe_markdown(path))\n\t            ]\n", "        except PermissionError:\n\t            return []\n\tclass LocalFiles(NavigationPane):\n\t    \"\"\"Local file picking navigation pane.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    LocalFiles {\n\t        height: 100%;\n\t    }\n\t    LocalFiles > DirectoryTree {\n\t        background: $panel;\n", "        width: 1fr;\n\t    }\n\t    LocalFiles > DirectoryTree:focus .tree--cursor, LocalFiles > DirectoryTree .tree--cursor {\n\t        background: $accent 50%;\n\t        color: $text;\n\t    }\n\t    \"\"\"\n\t    def __init__(self) -> None:\n\t        \"\"\"Initialise the local files navigation pane.\"\"\"\n\t        super().__init__(\"Local\")\n", "    def compose(self) -> ComposeResult:\n\t        \"\"\"Compose the child widgets.\"\"\"\n\t        yield FilteredDirectoryTree(Path(\"~\").expanduser())\n\t    def chdir(self, path: Path) -> None:\n\t        \"\"\"Change the filesystem view to the given directory.\n\t        Args:\n\t            path: The path to change to.\n\t        \"\"\"\n\t        self.query_one(FilteredDirectoryTree).path = path\n\t    def set_focus_within(self) -> None:\n", "        \"\"\"Focus the directory tree..\"\"\"\n\t        self.query_one(DirectoryTree).focus(scroll_visible=False)\n\t    class Goto(Message):\n\t        \"\"\"Message that requests the viewer goes to a given location.\"\"\"\n\t        def __init__(self, location: Path | URL) -> None:\n\t            \"\"\"Initialise the history goto message.\n\t            Args:\n\t                location: The location to go to.\n\t            \"\"\"\n\t            super().__init__()\n", "            self.location = location\n\t            \"\"\"The location to go to.\"\"\"\n\t    def on_directory_tree_file_selected(\n\t        self, event: DirectoryTree.FileSelected\n\t    ) -> None:\n\t        \"\"\"Handle a file being selected in the directory tree.\n\t        Args:\n\t            event: The direct tree selection event.\n\t        \"\"\"\n\t        event.stop()\n", "        self.post_message(self.Goto(Path(event.path)))\n"]}
{"filename": "frogmouth/data/data_directory.py", "chunked_list": ["\"\"\"Provides a function for working out the data directory location.\"\"\"\n\tfrom pathlib import Path\n\tfrom xdg import xdg_data_home\n\tfrom ..utility.advertising import ORGANISATION_NAME, PACKAGE_NAME\n\tdef data_directory() -> Path:\n\t    \"\"\"Get the location of the data directory.\n\t    Returns:\n\t        The location of the data directory.\n\t    Note:\n\t        As a side effect, if the directory doesn't exist it will be created.\n", "    \"\"\"\n\t    (target_directory := xdg_data_home() / ORGANISATION_NAME / PACKAGE_NAME).mkdir(\n\t        parents=True, exist_ok=True\n\t    )\n\t    return target_directory\n"]}
{"filename": "frogmouth/data/bookmarks.py", "chunked_list": ["\"\"\"Provides code for saving and loading bookmarks.\"\"\"\n\tfrom __future__ import annotations\n\tfrom json import JSONEncoder, dumps, loads\n\tfrom pathlib import Path\n\tfrom typing import Any, NamedTuple\n\tfrom httpx import URL\n\tfrom ..utility import is_likely_url\n\tfrom .data_directory import data_directory\n\tclass Bookmark(NamedTuple):\n\t    \"\"\"A bookmark.\"\"\"\n", "    title: str\n\t    \"\"\"The title of the bookmark.\"\"\"\n\t    location: Path | URL\n\t    \"\"\"The location of the bookmark.\"\"\"\n\tdef bookmarks_file() -> Path:\n\t    \"\"\"Get the location of the bookmarks file.\n\t    Returns:\n\t        The location of the bookmarks file.\n\t    \"\"\"\n\t    return data_directory() / \"bookmarks.json\"\n", "class BookmarkEncoder(JSONEncoder):\n\t    \"\"\"JSON encoder for the bookmark data.\"\"\"\n\t    def default(self, o: object) -> Any:\n\t        \"\"\"Handle the Path and URL values.\n\t        Args:\n\t            o: The object to handle.\n\t        Return:\n\t            The encoded object.\n\t        \"\"\"\n\t        return str(o) if isinstance(o, (Path, URL)) else o\n", "def save_bookmarks(bookmarks: list[Bookmark]) -> None:\n\t    \"\"\"Save the given bookmarks.\n\t    Args:\n\t        bookmarks: The bookmarks to save.\n\t    \"\"\"\n\t    bookmarks_file().write_text(dumps(bookmarks, indent=4, cls=BookmarkEncoder))\n\tdef load_bookmarks() -> list[Bookmark]:\n\t    \"\"\"Load the bookmarks.\n\t    Returns:\n\t        The bookmarks.\n", "    \"\"\"\n\t    return (\n\t        [\n\t            Bookmark(\n\t                title, URL(location) if is_likely_url(location) else Path(location)\n\t            )\n\t            for (title, location) in loads(bookmarks.read_text())\n\t        ]\n\t        if (bookmarks := bookmarks_file()).exists()\n\t        else []\n", "    )\n"]}
{"filename": "frogmouth/data/config.py", "chunked_list": ["\"\"\"Provides code for loading/saving configuration.\"\"\"\n\tfrom __future__ import annotations\n\tfrom dataclasses import asdict, dataclass, field\n\tfrom functools import lru_cache\n\tfrom json import dumps, loads\n\tfrom pathlib import Path\n\tfrom xdg import xdg_config_home\n\tfrom ..utility.advertising import ORGANISATION_NAME, PACKAGE_NAME\n\t@dataclass\n\tclass Config:\n", "    \"\"\"The markdown viewer configuration.\"\"\"\n\t    light_mode: bool = False\n\t    \"\"\"Should we run in light mode?\"\"\"\n\t    markdown_extensions: list[str] = field(default_factory=lambda: [\".md\", \".markdown\"])\n\t    \"\"\"What Markdown extensions will we look for?\"\"\"\n\t    navigation_left: bool = True\n\t    \"\"\"Should navigation be docked to the left side of the screen?\"\"\"\n\tdef config_file() -> Path:\n\t    \"\"\"Get the path to the configuration file.\n\t    Returns:\n", "        The path to the configuration file.\n\t    Note:\n\t        As a side-effect, the configuration directory will be created if it\n\t        does not exist.\n\t    \"\"\"\n\t    (config_dir := xdg_config_home() / ORGANISATION_NAME / PACKAGE_NAME).mkdir(\n\t        parents=True, exist_ok=True\n\t    )\n\t    return config_dir / \"configuration.json\"\n\tdef save_config(config: Config) -> Config:\n", "    \"\"\"Save the given configuration to storage.\n\t    Args:\n\t        config: The configuration to save.\n\t    Returns:\n\t        The configuration.\n\t    \"\"\"\n\t    # Ensure any cached copy of the config is cleaned up.\n\t    load_config.cache_clear()\n\t    # Dump the given config to storage.\n\t    config_file().write_text(dumps(asdict(config), indent=4))\n", "    # Finally, load it up again. This is to make sure that the updated\n\t    # version is in the cache.\n\t    return load_config()\n\t@lru_cache(maxsize=None)\n\tdef load_config() -> Config:\n\t    \"\"\"Load the configuration from storage.\n\t    Returns:\n\t        The configuration.\n\t    Note:\n\t        As a side-effect, if the configuration doesn't exist a default one\n", "        will be saved to storage.\n\t        This function is designed so that it's safe and low-cost to\n\t        repeatedly call it. The configuration is cached and will only be\n\t        loaded from storage when necessary.\n\t    \"\"\"\n\t    source_file = config_file()\n\t    return (\n\t        Config(**loads(source_file.read_text()))\n\t        if source_file.exists()\n\t        else save_config(Config())\n", "    )\n"]}
{"filename": "frogmouth/data/history.py", "chunked_list": ["\"\"\"Provides code for saving and loading the history.\"\"\"\n\tfrom __future__ import annotations\n\tfrom json import JSONEncoder, dumps, loads\n\tfrom pathlib import Path\n\tfrom typing import Any\n\tfrom httpx import URL\n\tfrom ..utility import is_likely_url\n\tfrom .data_directory import data_directory\n\tdef history_file() -> Path:\n\t    \"\"\"Get the location of the history file.\n", "    Returns:\n\t        The location of the history file.\n\t    \"\"\"\n\t    return data_directory() / \"history.json\"\n\tclass HistoryEncoder(JSONEncoder):\n\t    \"\"\"JSON encoder for the history data.\"\"\"\n\t    def default(self, o: object) -> Any:\n\t        \"\"\"Handle the Path and URL values.\n\t        Args:\n\t            o: The object to handle.\n", "        Return:\n\t            The encoded object.\n\t        \"\"\"\n\t        return str(o) if isinstance(o, (Path, URL)) else o\n\tdef save_history(history: list[Path | URL]) -> None:\n\t    \"\"\"Save the given history.\n\t    Args:\n\t        history: The history to save.\n\t    \"\"\"\n\t    history_file().write_text(dumps(history, indent=4, cls=HistoryEncoder))\n", "def load_history() -> list[Path | URL]:\n\t    \"\"\"Load the history.\n\t    Returns:\n\t        The history.\n\t    \"\"\"\n\t    return (\n\t        [\n\t            URL(location) if is_likely_url(location) else Path(location)\n\t            for location in loads(history.read_text())\n\t        ]\n", "        if (history := history_file()).exists()\n\t        else []\n\t    )\n"]}
{"filename": "frogmouth/data/__init__.py", "chunked_list": ["\"\"\"Provides tools for saving and loading application data.\"\"\"\n\tfrom .bookmarks import Bookmark, load_bookmarks, save_bookmarks\n\tfrom .config import Config, load_config, save_config\n\tfrom .history import load_history, save_history\n\t__all__ = [\n\t    \"Bookmark\",\n\t    \"Config\",\n\t    \"load_bookmarks\",\n\t    \"load_config\",\n\t    \"load_history\",\n", "    \"save_bookmarks\",\n\t    \"save_config\",\n\t    \"save_history\",\n\t]\n"]}
{"filename": "frogmouth/utility/type_tests.py", "chunked_list": ["\"\"\"Support code for testing files for their potential type.\"\"\"\n\tfrom functools import singledispatch\n\tfrom pathlib import Path\n\tfrom typing import Any\n\tfrom httpx import URL\n\tfrom ..data.config import load_config\n\t@singledispatch\n\tdef maybe_markdown(resource: Any) -> bool:\n\t    \"\"\"Does the given resource look like it's a Markdown file?\n\t    Args:\n", "        resource: The resource to test.\n\t    Returns:\n\t        `True` if the resources looks like a Markdown file, `False` if not.\n\t    \"\"\"\n\t    del resource\n\t    return False\n\t@maybe_markdown.register\n\tdef _(resource: Path) -> bool:\n\t    return resource.suffix.lower() in load_config().markdown_extensions\n\t@maybe_markdown.register\n", "def _(resource: str) -> bool:\n\t    return maybe_markdown(Path(resource))\n\t@maybe_markdown.register\n\tdef _(resource: URL) -> bool:\n\t    return maybe_markdown(resource.path)\n\tdef is_likely_url(candidate: str) -> bool:\n\t    \"\"\"Does the given value look something like a URL?\n\t    Args:\n\t        candidate: The candidate to check.\n\t    Returns:\n", "        `True` if the string is likely a URL, `False` if not.\n\t    \"\"\"\n\t    # Quick and dirty for now.\n\t    url = URL(candidate)\n\t    return url.is_absolute_url and url.scheme in (\"http\", \"https\")\n"]}
{"filename": "frogmouth/utility/advertising.py", "chunked_list": ["\"\"\"Provides the 'branding' for the application.\"\"\"\n\tfrom typing_extensions import Final\n\tfrom .. import __version__\n\tORGANISATION_NAME: Final[str] = \"textualize\"\n\t\"\"\"The organisation name to use when creating namespaced resources.\"\"\"\n\tORGANISATION_TITLE: Final[str] = \"Textualize\"\n\t\"\"\"The organisation title.\"\"\"\n\tORGANISATION_URL: Final[str] = \"https://www.textualize.io/\"\n\t\"\"\"The organisation URL.\"\"\"\n\tPACKAGE_NAME: Final[str] = \"frogmouth\"\n", "\"\"\"The name of the package.\"\"\"\n\tAPPLICATION_TITLE: Final[str] = \"Frogmouth\"\n\t\"\"\"The title of the application.\"\"\"\n\tUSER_AGENT: Final[str] = f\"{PACKAGE_NAME} v{__version__}\"\n\t\"\"\"The user agent to use when making web requests.\"\"\"\n\tDISCORD: Final[str] = \"https://discord.gg/Enf6Z3qhVr\"\n\t\"\"\"The link to the Textualize Discord server.\"\"\"\n\tTEXTUAL_URL: Final[str] = \"https://textual.textualize.io/\"\n\t\"\"\"The URL people should visit to find out more about Textual.\"\"\"\n"]}
{"filename": "frogmouth/utility/__init__.py", "chunked_list": ["\"\"\"General utility and support code.\"\"\"\n\tfrom .forge import (\n\t    build_raw_bitbucket_url,\n\t    build_raw_codeberg_url,\n\t    build_raw_github_url,\n\t    build_raw_gitlab_url,\n\t)\n\tfrom .type_tests import is_likely_url, maybe_markdown\n\t__all__ = [\n\t    \"build_raw_bitbucket_url\",\n", "    \"build_raw_codeberg_url\",\n\t    \"build_raw_github_url\",\n\t    \"build_raw_gitlab_url\",\n\t    \"is_likely_url\",\n\t    \"maybe_markdown\",\n\t]\n"]}
{"filename": "frogmouth/utility/forge.py", "chunked_list": ["\"\"\"Code for getting files from a forge.\"\"\"\n\tfrom __future__ import annotations\n\tfrom httpx import URL, AsyncClient, HTTPStatusError, RequestError\n\tfrom .advertising import USER_AGENT\n\tasync def build_raw_forge_url(\n\t    url_format: str,\n\t    owner: str,\n\t    repository: str,\n\t    branch: str | None = None,\n\t    desired_file: str | None = None,\n", ") -> URL | None:\n\t    \"\"\"Attempt to get raw forge URL for the given file.\n\t    Args:\n\t        owner: The owner of the repository to look in.\n\t        repository: The repository to look in.\n\t        branch: The optional branch to look in.\n\t        desired_file: Optional name of the file to go looking for.\n\t    Returns:\n\t        The URL for the file, or `None` if none could be guessed.\n\t    If the branch isn't supplied then `main` and `master` will be tested.\n", "    If the target file isn't supplied it's assumed that `README.md` is the\n\t    target.\n\t    \"\"\"\n\t    desired_file = desired_file or \"README.md\"\n\t    async with AsyncClient() as client:\n\t        for test_branch in (branch,) if branch else (\"main\", \"master\"):\n\t            url = url_format.format(\n\t                owner=owner,\n\t                repository=repository,\n\t                branch=test_branch,\n", "                file=desired_file,\n\t            )\n\t            try:\n\t                response = await client.head(\n\t                    url,\n\t                    follow_redirects=True,\n\t                    headers={\"user-agent\": USER_AGENT},\n\t                )\n\t            except RequestError:\n\t                # We've failed to even make the request, there's no point in\n", "                # trying to build anything here.\n\t                return None\n\t            try:\n\t                response.raise_for_status()\n\t                return URL(url)\n\t            except HTTPStatusError:\n\t                pass\n\t    return None\n\tasync def build_raw_github_url(\n\t    owner: str,\n", "    repository: str,\n\t    branch: str | None = None,\n\t    desired_file: str | None = None,\n\t) -> URL | None:\n\t    \"\"\"Attempt to get the GitHub raw URL for the given file.\n\t    Args:\n\t        owner: The owner of the repository to look in.\n\t        repository: The repository to look in.\n\t        branch: The optional branch to look in.\n\t        desired_file: Optional name of the file to go looking for.\n", "    Returns:\n\t        The URL for the file, or `None` if none could be guessed.\n\t    If the branch isn't supplied then `main` and `master` will be tested.\n\t    If the target file isn't supplied it's assumed that `README.md` is the\n\t    target.\n\t    \"\"\"\n\t    return await build_raw_forge_url(\n\t        \"https://raw.githubusercontent.com/{owner}/{repository}/{branch}/{file}\",\n\t        owner,\n\t        repository,\n", "        branch,\n\t        desired_file,\n\t    )\n\tasync def build_raw_gitlab_url(\n\t    owner: str,\n\t    repository: str,\n\t    branch: str | None = None,\n\t    desired_file: str | None = None,\n\t) -> URL | None:\n\t    \"\"\"Attempt to get the GitLab raw URL for the given file.\n", "    Args:\n\t        owner: The owner of the repository to look in.\n\t        repository: The repository to look in.\n\t        branch: The optional branch to look in.\n\t        desired_file: Optional name of the file to go looking for.\n\t    Returns:\n\t        The URL for the file, or `None` if none could be guessed.\n\t    If the branch isn't supplied then `main` and `master` will be tested.\n\t    If the target file isn't supplied it's assumed that `README.md` is the\n\t    target.\n", "    \"\"\"\n\t    return await build_raw_forge_url(\n\t        \"https://gitlab.com/{owner}/{repository}/-/raw/{branch}/{file}\",\n\t        owner,\n\t        repository,\n\t        branch,\n\t        desired_file,\n\t    )\n\tasync def build_raw_bitbucket_url(\n\t    owner: str,\n", "    repository: str,\n\t    branch: str | None = None,\n\t    desired_file: str | None = None,\n\t) -> URL | None:\n\t    \"\"\"Attempt to get the BitBucket raw URL for the given file.\n\t    Args:\n\t        owner: The owner of the repository to look in.\n\t        repository: The repository to look in.\n\t        branch: The optional branch to look in.\n\t        desired_file: Optional name of the file to go looking for.\n", "    Returns:\n\t        The URL for the file, or `None` if none could be guessed.\n\t    If the branch isn't supplied then `main` and `master` will be tested.\n\t    If the target file isn't supplied it's assumed that `README.md` is the\n\t    target.\n\t    \"\"\"\n\t    return await build_raw_forge_url(\n\t        \"https://bitbucket.org/{owner}/{repository}/raw/{branch}/{file}\",\n\t        owner,\n\t        repository,\n", "        branch,\n\t        desired_file,\n\t    )\n\tasync def build_raw_codeberg_url(\n\t    owner: str,\n\t    repository: str,\n\t    branch: str | None = None,\n\t    desired_file: str | None = None,\n\t) -> URL | None:\n\t    \"\"\"Attempt to get the Codeberg raw URL for the given file.\n", "    Args:\n\t        owner: The owner of the repository to look in.\n\t        repository: The repository to look in.\n\t        branch: The optional branch to look in.\n\t        desired_file: Optional name of the file to go looking for.\n\t    Returns:\n\t        The URL for the file, or `None` if none could be guessed.\n\t    If the branch isn't supplied then `main` and `master` will be tested.\n\t    If the target file isn't supplied it's assumed that `README.md` is the\n\t    target.\n", "    \"\"\"\n\t    return await build_raw_forge_url(\n\t        \"https://codeberg.org/{owner}/{repository}/raw//branch/{branch}/{file}\",\n\t        owner,\n\t        repository,\n\t        branch,\n\t        desired_file,\n\t    )\n"]}
{"filename": "frogmouth/dialogs/yes_no_dialog.py", "chunked_list": ["\"\"\"Provides a dialog for getting a yes/no response from the user.\"\"\"\n\tfrom __future__ import annotations\n\tfrom textual.app import ComposeResult\n\tfrom textual.binding import Binding\n\tfrom textual.containers import Center, Horizontal, Vertical\n\tfrom textual.screen import ModalScreen\n\tfrom textual.widgets import Button, Static\n\tclass YesNoDialog(ModalScreen[bool]):\n\t    \"\"\"A dialog for asking a user a yes/no question.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n", "    YesNoDialog {\n\t        align: center middle;\n\t    }\n\t    YesNoDialog > Vertical {\n\t        background: $panel;\n\t        height: auto;\n\t        width: auto;\n\t        border: thick $primary;\n\t    }\n\t    YesNoDialog > Vertical > * {\n", "        width: auto;\n\t        height: auto;\n\t    }\n\t    YesNoDialog Static {\n\t        width: auto;\n\t    }\n\t    YesNoDialog .spaced {\n\t        padding: 1;\n\t    }\n\t    YesNoDialog #question {\n", "        min-width: 100%;\n\t        border-top: solid $primary;\n\t        border-bottom: solid $primary;\n\t    }\n\t    YesNoDialog Button {\n\t        margin-right: 1;\n\t    }\n\t    YesNoDialog #buttons {\n\t        width: 100%;\n\t        align-horizontal: right;\n", "        padding-right: 1;\n\t    }\n\t    \"\"\"\n\t    \"\"\"The default CSS for the yes/no dialog.\"\"\"\n\t    BINDINGS = [\n\t        Binding(\"left,up\", \"focus_previous\", \"\", show=False),\n\t        Binding(\"right,down\", \"focus_next\", \"\", show=False),\n\t        Binding(\"escape\", \"app.pop_screen\", \"\", show=False),\n\t    ]\n\t    \"\"\"Bindings for the yes/no dialog.\"\"\"\n", "    def __init__(  # pylint:disable=too-many-arguments\n\t        self,\n\t        title: str,\n\t        question: str,\n\t        yes_label: str = \"Yes\",\n\t        no_label: str = \"No\",\n\t        yes_first: bool = True,\n\t    ) -> None:\n\t        \"\"\"Initialise the yes/no dialog.\n\t        Args:\n", "            requester: The widget requesting the input.\n\t            title: The title for the dialog.\n\t            question: The question to ask.\n\t            yes_label: The optional label for the yes button.\n\t            no_label: The optional label for the no button.\n\t            yes_first: Should the yes button come first?\n\t            cargo: Any cargo value for the question.\n\t            id: The ID for the dialog.\n\t        \"\"\"\n\t        super().__init__()\n", "        self._title = title\n\t        \"\"\"The title for the dialog.\"\"\"\n\t        self._question = question\n\t        \"\"\"The question to ask the user.\"\"\"\n\t        self._aye = yes_label\n\t        \"\"\"The label for the yes button.\"\"\"\n\t        self._naw = no_label\n\t        \"\"\"The label for the no button.\"\"\"\n\t        self._aye_first = yes_first\n\t        \"\"\"Should the positive button come first?\"\"\"\n", "    def compose(self) -> ComposeResult:\n\t        \"\"\"Compose the content of the dialog.\"\"\"\n\t        with Vertical():\n\t            with Center():\n\t                yield Static(self._title, classes=\"spaced\")\n\t            yield Static(self._question, id=\"question\", classes=\"spaced\")\n\t            with Horizontal(id=\"buttons\"):\n\t                aye = Button(self._aye, id=\"yes\")\n\t                naw = Button(self._naw, id=\"no\")\n\t                if self._aye_first:\n", "                    aye.variant = \"primary\"\n\t                    yield aye\n\t                    yield naw\n\t                else:\n\t                    naw.variant = \"primary\"\n\t                    yield naw\n\t                    yield aye\n\t    def on_mount(self) -> None:\n\t        \"\"\"Configure the dialog once the DOM is ready.\"\"\"\n\t        self.query(Button).first().focus()\n", "    def on_button_pressed(self, event: Button.Pressed) -> None:\n\t        \"\"\"Handle a button being pressed on the dialog.\n\t        Args:\n\t            event: The event to handle.\n\t        \"\"\"\n\t        self.dismiss(event.button.id == \"yes\")\n"]}
{"filename": "frogmouth/dialogs/help_dialog.py", "chunked_list": ["\"\"\"The main help dialog for the application.\"\"\"\n\timport webbrowser\n\tfrom textual.app import ComposeResult\n\tfrom textual.binding import Binding\n\tfrom textual.containers import Center, Vertical, VerticalScroll\n\tfrom textual.screen import ModalScreen\n\tfrom textual.widgets import Button, Markdown\n\tfrom typing_extensions import Final\n\tfrom .. import __version__\n\tfrom ..utility.advertising import APPLICATION_TITLE\n", "HELP: Final[\n\t    str\n\t] = f\"\"\"\\\n\t# {APPLICATION_TITLE} v{__version__} Help\n\tWelcome to {APPLICATION_TITLE} Help!\n\t{APPLICATION_TITLE} was built with [Textual](https://github.com/Textualize/textual).\n\t## Navigation keys\n\t| Key | Command |\n\t| -- | -- |\n\t| `/` | Focus the address bar (`ctrl+u` to clear address bar) |\n", "| `Escape` | Return to address bar / clear address bar / quit |\n\t| `Ctrl+n` | Show/hide the navigation |\n\t| `Ctrl+b` | Show the bookmarks |\n\t| `Ctrl+l` | Show the local file browser |\n\t| `Ctrl+t` | Show the table of contents |\n\t| `Ctrl+y` | Show the history |\n\t| `Ctrl+left` | Go backward in history |\n\t| `Ctrl+right` | Go forward in history |\n\t## General keys\n\t| Key | Command |\n", "| -- | -- |\n\t| `Ctrl+d` | Add the current document to the bookmarks |\n\t| `Ctrl+r` | Reload the current document |\n\t| `Ctrl+q` | Quit the application |\n\t| `F1` | This help |\n\t| `F2` | Details about {APPLICATION_TITLE} |\n\t| `F10` | Toggle dark/light theme |\n\t## Commands\n\tPress `/` or click the address bar, then enter any of the following commands:\n\t| Command | Aliases | Arguments | Command |\n", "| -- | -- | -- | -- |\n\t| `about` | `a` | | Show details about the application |\n\t| `bookmarks` | `b`, `bm` | | Show the bookmarks list |\n\t| `bitbucket` | `bb` | `<repo-info>` | View a file on BitBucket (see below) |\n\t| `codeberg` | `cb` | `<repo-info>` | View a file on Codeberg (see below) |\n\t| `changelog` | `cl` | | View the Frogmouth ChangeLog |\n\t| `chdir` | `cd` | `<dir>` | Switch the local file browser to a new directory |\n\t| `contents` | `c`, `toc` | | Show the table of contents for the document |\n\t| `discord` | | | Visit the Textualize Discord server |\n\t| `github` | `gh` | `<repo-info>` | View a file on GitHub (see below) |\n", "| `gitlab` | `gl` | `<repo-info>` | View a file on GitLab (see below) |\n\t| `help` | `?` | | Show this document |\n\t| `history` | `h` | | Show the history |\n\t| `local` | `l` | | Show the local file browser |\n\t| `quit` | `q` | | Quit the viewer |\n\t## Git forge quick view\n\tThe git forge quick view command can be used to quickly view a file on a git\n\tforge such as GitHub or GitLab. Various forms of specifying the repository,\n\tbranch and file are supported. For example:\n\t- `<owner>`/`<repo>`\n", "- `<owner>`/`<repo>` `<file>`\n\t- `<owner>` `<repo>`\n\t- `<owner>` `<repo>` `<file>`\n\t- `<owner>`/`<repo>`:`<branch>`\n\t- `<owner>`/`<repo>`:`<branch>` `<file>`\n\t- `<owner>` `<repo>`:`<branch>`\n\t- `<owner>` `<repo>`:`<branch>` `<file>`\n\tAnywhere where `<file>` is omitted it is assumed `README.md` is desired.\n\tAnywhere where `<branch>` is omitted a test is made for the desired file on\n\tfirst a `main` and then a `master` branch.\n", "\"\"\"\n\t\"\"\"The main help text for the application.\"\"\"\n\tclass HelpDialog(ModalScreen[None]):\n\t    \"\"\"Modal dialog that shows the application's help.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    HelpDialog {\n\t        align: center middle;\n\t    }\n\t    HelpDialog > Vertical {\n\t        border: thick $primary 50%;\n", "        width: 80%;\n\t        height: 80%;\n\t        background: $boost;\n\t    }\n\t    HelpDialog > Vertical > VerticalScroll {\n\t        height: 1fr;\n\t        margin: 1 2;\n\t    }\n\t    HelpDialog > Vertical > Center {\n\t        padding: 1;\n", "        height: auto;\n\t    }\n\t    \"\"\"\n\t    BINDINGS = [\n\t        Binding(\"escape,f1\", \"dismiss(None)\", \"\", show=False),\n\t    ]\n\t    \"\"\"Bindings for the help dialog.\"\"\"\n\t    def compose(self) -> ComposeResult:\n\t        \"\"\"Compose the help screen.\"\"\"\n\t        with Vertical():\n", "            with VerticalScroll():\n\t                yield Markdown(HELP)\n\t            with Center():\n\t                yield Button(\"Close\", variant=\"primary\")\n\t    def on_mount(self) -> None:\n\t        \"\"\"Configure the help screen once the DOM is ready.\"\"\"\n\t        # It seems that some things inside Markdown can still grab focus;\n\t        # which might not be right. Let's ensure that can't happen here.\n\t        self.query_one(Markdown).can_focus_children = False\n\t        self.query_one(\"Vertical > VerticalScroll\").focus()\n", "    def on_button_pressed(self) -> None:\n\t        \"\"\"React to button press.\"\"\"\n\t        self.dismiss(None)\n\t    def on_markdown_link_clicked(self, event: Markdown.LinkClicked) -> None:\n\t        \"\"\"A link was clicked in the help.\n\t        Args:\n\t            event: The link click event to handle.\n\t        \"\"\"\n\t        webbrowser.open(event.href)\n"]}
{"filename": "frogmouth/dialogs/text_dialog.py", "chunked_list": ["\"\"\"Provides a base modal dialog for showing text to the user.\"\"\"\n\tfrom rich.text import TextType\n\tfrom textual.app import ComposeResult\n\tfrom textual.binding import Binding\n\tfrom textual.containers import Center, Vertical\n\tfrom textual.screen import ModalScreen\n\tfrom textual.widgets import Button, Static\n\tfrom textual.widgets._button import ButtonVariant\n\tclass TextDialog(ModalScreen[None]):\n\t    \"\"\"Base modal dialog for showing information.\"\"\"\n", "    DEFAULT_CSS = \"\"\"\n\t    TextDialog {\n\t        align: center middle;\n\t    }\n\t    TextDialog Center {\n\t        width: 100%;\n\t    }\n\t    TextDialog > Vertical {\n\t        background: $boost;\n\t        min-width: 30%;\n", "        width: auto;\n\t        height: auto;\n\t        border: round $primary;\n\t    }\n\t    TextDialog Static {\n\t        width: auto;\n\t    }\n\t    TextDialog .spaced {\n\t        padding: 1 4;\n\t    }\n", "    TextDialog #message {\n\t        min-width: 100%;\n\t    }\n\t    \"\"\"\n\t    \"\"\"Default CSS for the base text modal dialog.\"\"\"\n\t    BINDINGS = [\n\t        Binding(\"escape\", \"dismiss(None)\", \"\", show=False),\n\t    ]\n\t    \"\"\"Bindings for the base text modal dialog.\"\"\"\n\t    def __init__(self, title: TextType, message: TextType) -> None:\n", "        \"\"\"Initialise the dialog.\n\t        Args:\n\t            title: The title for the dialog.\n\t            message: The message to show.\n\t        \"\"\"\n\t        super().__init__()\n\t        self._title = title\n\t        self._message = message\n\t    @property\n\t    def button_style(self) -> ButtonVariant:\n", "        \"\"\"The style for the dialog's button.\"\"\"\n\t        return \"primary\"\n\t    def compose(self) -> ComposeResult:\n\t        \"\"\"Compose the content of the modal dialog.\"\"\"\n\t        with Vertical():\n\t            with Center():\n\t                yield Static(self._title, classes=\"spaced\")\n\t            yield Static(self._message, id=\"message\", classes=\"spaced\")\n\t            with Center(classes=\"spaced\"):\n\t                yield Button(\"OK\", variant=self.button_style)\n", "    def on_mount(self) -> None:\n\t        \"\"\"Configure the dialog once the DOM has loaded.\"\"\"\n\t        self.query_one(Button).focus()\n\t    def on_button_pressed(self) -> None:\n\t        \"\"\"Handle the OK button being pressed.\"\"\"\n\t        self.dismiss(None)\n"]}
{"filename": "frogmouth/dialogs/__init__.py", "chunked_list": ["\"\"\"Provides useful dialogs for the application.\"\"\"\n\tfrom .error import ErrorDialog\n\tfrom .help_dialog import HelpDialog\n\tfrom .information import InformationDialog\n\tfrom .input_dialog import InputDialog\n\tfrom .yes_no_dialog import YesNoDialog\n\t__all__ = [\n\t    \"ErrorDialog\",\n\t    \"InformationDialog\",\n\t    \"InputDialog\",\n", "    \"HelpDialog\",\n\t    \"YesNoDialog\",\n\t]\n"]}
{"filename": "frogmouth/dialogs/input_dialog.py", "chunked_list": ["\"\"\"Provides a modal dialog for getting a value from the user.\"\"\"\n\tfrom __future__ import annotations\n\tfrom textual import on\n\tfrom textual.app import ComposeResult\n\tfrom textual.binding import Binding\n\tfrom textual.containers import Horizontal, Vertical\n\tfrom textual.screen import ModalScreen\n\tfrom textual.widgets import Button, Input, Label\n\tclass InputDialog(ModalScreen[str]):\n\t    \"\"\"A modal dialog for getting a single input from the user.\"\"\"\n", "    DEFAULT_CSS = \"\"\"\n\t    InputDialog {\n\t        align: center middle;\n\t    }\n\t    InputDialog > Vertical {\n\t        background: $panel;\n\t        height: auto;\n\t        width: auto;\n\t        border: thick $primary;\n\t    }\n", "    InputDialog > Vertical > * {\n\t        width: auto;\n\t        height: auto;\n\t    }\n\t    InputDialog Input {\n\t        width: 40;\n\t        margin: 1;\n\t    }\n\t    InputDialog Label {\n\t        margin-left: 2;\n", "    }\n\t    InputDialog Button {\n\t        margin-right: 1;\n\t    }\n\t    InputDialog #buttons {\n\t        width: 100%;\n\t        align-horizontal: right;\n\t        padding-right: 1;\n\t    }\n\t    \"\"\"\n", "    \"\"\"The default styling for the input dialog.\"\"\"\n\t    BINDINGS = [\n\t        Binding(\"escape\", \"app.pop_screen\", \"\", show=False),\n\t    ]\n\t    \"\"\"Bindings for the dialog.\"\"\"\n\t    def __init__(self, prompt: str, initial: str | None = None) -> None:\n\t        \"\"\"Initialise the input dialog.\n\t        Args:\n\t            prompt: The prompt for the input.\n\t            initial: The initial value for the input.\n", "        \"\"\"\n\t        super().__init__()\n\t        self._prompt = prompt\n\t        \"\"\"The prompt to display for the input.\"\"\"\n\t        self._initial = initial\n\t        \"\"\"The initial value to use for the input.\"\"\"\n\t    def compose(self) -> ComposeResult:\n\t        \"\"\"Compose the child widgets.\"\"\"\n\t        with Vertical():\n\t            with Vertical(id=\"input\"):\n", "                yield Label(self._prompt)\n\t                yield Input(self._initial or \"\")\n\t            with Horizontal(id=\"buttons\"):\n\t                yield Button(\"OK\", id=\"ok\", variant=\"primary\")\n\t                yield Button(\"Cancel\", id=\"cancel\")\n\t    def on_mount(self) -> None:\n\t        \"\"\"Set up the dialog once the DOM is ready.\"\"\"\n\t        self.query_one(Input).focus()\n\t    @on(Button.Pressed, \"#cancel\")\n\t    def cancel_input(self) -> None:\n", "        \"\"\"Cancel the input operation.\"\"\"\n\t        self.app.pop_screen()\n\t    @on(Input.Submitted)\n\t    @on(Button.Pressed, \"#ok\")\n\t    def accept_input(self) -> None:\n\t        \"\"\"Accept and return the input.\"\"\"\n\t        if value := self.query_one(Input).value.strip():\n\t            self.dismiss(value)\n"]}
{"filename": "frogmouth/dialogs/information.py", "chunked_list": ["\"\"\"Provides an information dialog.\"\"\"\n\tfrom .text_dialog import TextDialog\n\tclass InformationDialog(TextDialog):\n\t    \"\"\"Modal dialog that shows information.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    InformationDialog > Vertical {\n\t        border: thick $primary 50%;\n\t    }\n\t    \"\"\"\n"]}
{"filename": "frogmouth/dialogs/error.py", "chunked_list": ["\"\"\"Provides an error dialog.\"\"\"\n\tfrom textual.widgets._button import ButtonVariant\n\tfrom .text_dialog import TextDialog\n\tclass ErrorDialog(TextDialog):\n\t    \"\"\"Modal dialog for showing errors.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    ErrorDialog > Vertical {\n\t        background: $error 15%;\n\t        border: thick $error 50%;\n\t    }\n", "    ErrorDialog #message {\n\t        border-top: solid $panel;\n\t        border-bottom: solid $panel;\n\t    }\n\t    \"\"\"\n\t    @property\n\t    def button_style(self) -> ButtonVariant:\n\t        \"\"\"The style for the dialog's button.\"\"\"\n\t        return \"error\"\n"]}
{"filename": "frogmouth/screens/main.py", "chunked_list": ["\"\"\"The main screen for the application.\"\"\"\n\tfrom __future__ import annotations\n\tfrom functools import partial\n\tfrom pathlib import Path\n\tfrom typing import Awaitable, Callable\n\tfrom webbrowser import open as open_url\n\tfrom httpx import URL\n\tfrom textual.app import ComposeResult\n\tfrom textual.binding import Binding\n\tfrom textual.containers import Horizontal\n", "from textual.events import Paste\n\tfrom textual.screen import Screen\n\tfrom textual.widgets import Footer, Markdown\n\tfrom .. import __version__\n\tfrom ..data import load_config, load_history, save_config, save_history\n\tfrom ..dialogs import ErrorDialog, HelpDialog, InformationDialog, InputDialog\n\tfrom ..utility import (\n\t    build_raw_bitbucket_url,\n\t    build_raw_codeberg_url,\n\t    build_raw_github_url,\n", "    build_raw_gitlab_url,\n\t    is_likely_url,\n\t    maybe_markdown,\n\t)\n\tfrom ..utility.advertising import (\n\t    APPLICATION_TITLE,\n\t    ORGANISATION_NAME,\n\t    ORGANISATION_TITLE,\n\t    ORGANISATION_URL,\n\t    PACKAGE_NAME,\n", "    TEXTUAL_URL,\n\t)\n\tfrom ..widgets import Navigation, Omnibox, Viewer\n\tfrom ..widgets.navigation_panes import Bookmarks, History, LocalFiles\n\tclass Main(Screen[None]):  # pylint:disable=too-many-public-methods\n\t    \"\"\"The main screen for the application.\"\"\"\n\t    DEFAULT_CSS = \"\"\"\n\t    .focusable {\n\t        border: blank;\n\t    }\n", "    .focusable:focus {\n\t        border: heavy $accent !important;\n\t    }\n\t    Screen Tabs {\n\t        border: blank;\n\t        height: 5;\n\t    }\n\t    Screen Tabs:focus {\n\t        border: heavy $accent !important;\n\t        height: 5;\n", "    }\n\t    Screen TabbedContent TabPane {\n\t        padding: 0 1;\n\t        border: blank;\n\t    }\n\t    Screen TabbedContent TabPane:focus-within {\n\t        border: heavy $accent !important;\n\t    }\n\t    \"\"\"\n\t    BINDINGS = [\n", "        Binding(\"/,:\", \"omnibox\", \"Omnibox\", show=False),\n\t        Binding(\"ctrl+b\", \"bookmarks\", \"\", show=False),\n\t        Binding(\"ctrl+d\", \"bookmark_this\", \"\", show=False),\n\t        Binding(\"ctrl+l\", \"local_files\", \"\", show=False),\n\t        Binding(\"ctrl+left\", \"backward\", \"\", show=False),\n\t        Binding(\"ctrl+right\", \"forward\", \"\", show=False),\n\t        Binding(\"ctrl+r\", \"reload\", \"\", show=False),\n\t        Binding(\"ctrl+t\", \"table_of_contents\", \"\", show=False),\n\t        Binding(\"ctrl+y\", \"history\", \"\", show=False),\n\t        Binding(\"escape\", \"escape\", \"\", show=False),\n", "        Binding(\"f1\", \"help\", \"Help\"),\n\t        Binding(\"f2\", \"about\", \"About\"),\n\t        Binding(\"ctrl+n\", \"navigation\", \"Navigation\"),\n\t        Binding(\"ctrl+q\", \"app.quit\", \"Quit\"),\n\t        Binding(\"f10\", \"toggle_theme\", \"\", show=False),\n\t    ]\n\t    \"\"\"The keyboard bindings for the main screen.\"\"\"\n\t    def __init__(self, initial_location: str | None = None) -> None:\n\t        \"\"\"Initialise the main screen.\n\t        Args:\n", "            initial_location: The initial location to view.\n\t        \"\"\"\n\t        super().__init__()\n\t        self._initial_location = initial_location\n\t    def compose(self) -> ComposeResult:\n\t        \"\"\"Compose the main screen.\n\t        Returns:\n\t            The result of composing the screen.\n\t        \"\"\"\n\t        yield Omnibox(classes=\"focusable\")\n", "        with Horizontal():\n\t            yield Navigation()\n\t            yield Viewer(classes=\"focusable\")\n\t        yield Footer()\n\t    def visit(self, location: Path | URL, remember: bool = True) -> None:\n\t        \"\"\"Visit the given location.\n\t        Args:\n\t            location: The location to visit.\n\t            remember: Should the visit be added to the history?\n\t        \"\"\"\n", "        # If the location we've been given looks like it is markdown, be it\n\t        # locally in the filesystem or out on the web...\n\t        if maybe_markdown(location):\n\t            # ...attempt to visit it in the viewer.\n\t            self.query_one(Viewer).visit(location, remember)\n\t        elif isinstance(location, Path):\n\t            # So, it's not Markdown, but it *is* a Path of some sort. If the\n\t            # resource seems to exist...\n\t            if location.exists():\n\t                # ...ask the OS to open it.\n", "                open_url(f\"file:///{location.absolute()}\")\n\t            else:\n\t                # It's a Path but it doesn't exist, there's not much else we\n\t                # can do with it.\n\t                self.app.push_screen(\n\t                    ErrorDialog(\n\t                        \"Does not exist\",\n\t                        f\"Unable to open {location} because it does not exist.\",\n\t                    )\n\t                )\n", "        else:\n\t            # By this point all that's left is it's a URL that, on the\n\t            # surface, doesn't look like a Markdown file. Let's hand off to\n\t            # the operating system anyway.\n\t            open_url(str(location), new=2, autoraise=True)\n\t    async def on_mount(self) -> None:\n\t        \"\"\"Set up the main screen once the DOM is ready.\"\"\"\n\t        # Currently Textual's Markdown can steal focus, which gets confusing\n\t        # as it's not obvious *what* is focused. So let's stop it from\n\t        # allowing the content to get focus.\n", "        #\n\t        # https://github.com/Textualize/textual/issues/2380\n\t        self.query_one(Markdown).can_focus_children = False\n\t        # Load up any history that might be saved.\n\t        if history := load_history():\n\t            self.query_one(Viewer).load_history(history)\n\t        # If we've not been tasked to start up looking at a very specific\n\t        # location (in other words if no location was passed on the command\n\t        # line), and if there is some history...\n\t        if self._initial_location is None and history:\n", "            # ...start up revisiting the last location the user was looking\n\t            # at.\n\t            self.query_one(Viewer).visit(history[-1], remember=False)\n\t            self.query_one(Omnibox).value = str(history[-1])\n\t        elif self._initial_location is not None:\n\t            # Seems there is an initial location; so let's start up looking\n\t            # at that.\n\t            (omnibox := self.query_one(Omnibox)).value = self._initial_location\n\t            await omnibox.action_submit()\n\t    def on_navigation_hidden(self) -> None:\n", "        \"\"\"React to the navigation sidebar being hidden.\"\"\"\n\t        self.query_one(Viewer).focus()\n\t    def on_omnibox_local_view_command(self, event: Omnibox.LocalViewCommand) -> None:\n\t        \"\"\"Handle the omnibox asking us to view a particular file.\n\t        Args:\n\t            event: The local view command event.\n\t        \"\"\"\n\t        self.visit(event.path)\n\t    def on_omnibox_remote_view_command(self, event: Omnibox.RemoteViewCommand) -> None:\n\t        \"\"\"Handle the omnibox asking us to view a particular URL.\n", "        Args:\n\t            event: The remote view command event.\n\t        \"\"\"\n\t        self.visit(event.url)\n\t    def on_omnibox_contents_command(self) -> None:\n\t        \"\"\"Handle being asked to show the table of contents.\"\"\"\n\t        self.action_table_of_contents()\n\t    def on_omnibox_local_files_command(self) -> None:\n\t        \"\"\"Handle being asked to view the local files picker.\"\"\"\n\t        self.action_local_files()\n", "    def on_omnibox_bookmarks_command(self) -> None:\n\t        \"\"\"Handle being asked to view the bookmarks.\"\"\"\n\t        self.action_bookmarks()\n\t    def on_omnibox_local_chdir_command(self, event: Omnibox.LocalChdirCommand) -> None:\n\t        \"\"\"Handle being asked to view a new directory in the local files picker.\n\t        Args:\n\t            event: The chdir command event to handle.\n\t        \"\"\"\n\t        if not event.target.exists():\n\t            self.app.push_screen(\n", "                ErrorDialog(\"No such directory\", f\"{event.target} does not exist.\")\n\t            )\n\t        elif not event.target.is_dir():\n\t            self.app.push_screen(\n\t                ErrorDialog(\"Not a directory\", f\"{event.target} is not a directory.\")\n\t            )\n\t        else:\n\t            self.query_one(Navigation).jump_to_local_files(event.target)\n\t    def on_omnibox_history_command(self) -> None:\n\t        \"\"\"Handle being asked to view the history.\"\"\"\n", "        self.action_history()\n\t    async def _from_forge(\n\t        self,\n\t        forge: str,\n\t        event: Omnibox.ForgeCommand,\n\t        builder: Callable[[str, str, str | None, str | None], Awaitable[URL | None]],\n\t    ) -> None:\n\t        \"\"\"Build a URL for getting a file from a given forge.\n\t        Args:\n\t            forge: The display name of the forge.\n", "            event: The event that contains the request information for the file.\n\t            builder: The function that builds the URL.\n\t        \"\"\"\n\t        if url := await builder(\n\t            event.owner, event.repository, event.branch, event.desired_file\n\t        ):\n\t            self.visit(url)\n\t        else:\n\t            self.app.push_screen(\n\t                ErrorDialog(\n", "                    f\"Unable to work out a {forge} URL\",\n\t                    f\"After trying a few options it hasn't been possible to work out the {forge} URL.\\n\\n\"\n\t                    \"Perhaps the file you're after is on an unusual branch, or the spelling is wrong?\",\n\t                )\n\t            )\n\t    async def on_omnibox_git_hub_command(self, event: Omnibox.GitHubCommand) -> None:\n\t        \"\"\"Handle a GitHub file shortcut command.\n\t        Args:\n\t            event: The GitHub shortcut command event to handle.\n\t        \"\"\"\n", "        await self._from_forge(\"GitHub\", event, build_raw_github_url)\n\t    async def on_omnibox_git_lab_command(self, event: Omnibox.GitLabCommand) -> None:\n\t        \"\"\"Handle a GitLab file shortcut command.\n\t        Args:\n\t            event: The GitLab shortcut command event to handle.\n\t        \"\"\"\n\t        await self._from_forge(\"GitLab\", event, build_raw_gitlab_url)\n\t    async def on_omnibox_bit_bucket_command(\n\t        self, event: Omnibox.BitBucketCommand\n\t    ) -> None:\n", "        \"\"\"Handle a BitBucket shortcut command.\n\t        Args:\n\t            event: The BitBucket shortcut command event to handle.\n\t        \"\"\"\n\t        await self._from_forge(\"BitBucket\", event, build_raw_bitbucket_url)\n\t    async def on_omnibox_codeberg_command(self, event: Omnibox.CodebergCommand) -> None:\n\t        \"\"\"Handle a Codeberg shortcut command.\n\t        Args:\n\t            event: The Codeberg shortcut command event to handle.\n\t        \"\"\"\n", "        await self._from_forge(\"Codeberg\", event, build_raw_codeberg_url)\n\t    def on_omnibox_about_command(self) -> None:\n\t        \"\"\"Handle being asked to show the about dialog.\"\"\"\n\t        self.action_about()\n\t    def on_omnibox_help_command(self) -> None:\n\t        \"\"\"Handle being asked to show the help document.\"\"\"\n\t        self.action_help()\n\t    def on_omnibox_quit_command(self) -> None:\n\t        \"\"\"Handle being asked to quit.\"\"\"\n\t        self.app.exit()\n", "    def on_local_files_goto(self, event: LocalFiles.Goto) -> None:\n\t        \"\"\"Visit a local file in the viewer.\n\t        Args:\n\t            event: The local file visit request event.\n\t        \"\"\"\n\t        self.visit(event.location)\n\t    def on_history_goto(self, event: History.Goto) -> None:\n\t        \"\"\"Handle a request to go to a location from history.\n\t        Args:\n\t            event: The event to handle.\n", "        \"\"\"\n\t        self.visit(\n\t            event.location, remember=event.location != self.query_one(Viewer).location\n\t        )\n\t    def on_history_delete(self, event: History.Delete) -> None:\n\t        \"\"\"Handle a request to delete an item from history.\n\t        Args:\n\t            event: The event to handle.\n\t        \"\"\"\n\t        self.query_one(Viewer).delete_history(event.history_id)\n", "    def on_history_clear(self) -> None:\n\t        \"\"\"handle a request to clear down all of history.\"\"\"\n\t        self.query_one(Viewer).clear_history()\n\t    def on_bookmarks_goto(self, event: Bookmarks.Goto) -> None:\n\t        \"\"\"Handle a request to go to a bookmark.\n\t        Args:\n\t            event: The event to handle.\n\t        \"\"\"\n\t        self.visit(event.bookmark.location)\n\t    def on_viewer_location_changed(self, event: Viewer.LocationChanged) -> None:\n", "        \"\"\"Update for the location being changed.\n\t        Args:\n\t            event: The location change event.\n\t        \"\"\"\n\t        # Update the omnibox with whatever is appropriate for the new location.\n\t        self.query_one(Omnibox).visiting = (\n\t            str(event.viewer.location) if event.viewer.location is not None else \"\"\n\t        )\n\t        # Having safely arrived at a new location, that implies that we want\n\t        # to focus on the viewer.\n", "        self.query_one(Viewer).focus()\n\t    def on_viewer_history_updated(self, event: Viewer.HistoryUpdated) -> None:\n\t        \"\"\"Handle the viewer updating the history.\n\t        Args:\n\t            event: The history update event.\n\t        \"\"\"\n\t        self.query_one(Navigation).history.update_from(event.viewer.history.locations)\n\t        save_history(event.viewer.history.locations)\n\t    def on_markdown_table_of_contents_updated(\n\t        self, event: Markdown.TableOfContentsUpdated\n", "    ) -> None:\n\t        \"\"\"Handle the table of contents of the document being updated.\n\t        Args:\n\t            event: The table of contents update event to handle.\n\t        \"\"\"\n\t        # We don't handle this, the navigation pane does. Bounce the event\n\t        # over there.\n\t        self.query_one(Navigation).table_of_contents.on_table_of_contents_updated(event)\n\t    def on_markdown_table_of_contents_selected(\n\t        self, event: Markdown.TableOfContentsSelected\n", "    ) -> None:\n\t        \"\"\"Handle the user selecting something from the table of contents.\n\t        Args:\n\t            event: The table of contents selection event to handle.\n\t        \"\"\"\n\t        self.query_one(Viewer).scroll_to_block(event.block_id)\n\t    def on_markdown_link_clicked(self, event: Markdown.LinkClicked) -> None:\n\t        \"\"\"Handle a link being clicked in the Markdown document.\n\t        Args:\n\t            event: The Markdown link click event to handle.\n", "        \"\"\"\n\t        # We'll be using the current location to help work out some relative\n\t        # things.\n\t        current_location = self.query_one(Viewer).location\n\t        # If the link we're to handle obviously looks like URL...\n\t        if is_likely_url(event.href):\n\t            # ...handle it as such. No point in trying to do anything else.\n\t            self.visit(URL(event.href))\n\t        elif isinstance(current_location, URL):\n\t            # Seems we're currently visiting a remote location, and the href\n", "            # looks like a simple file path, so let's make a best effort to\n\t            # visit the file at the remote location.\n\t            self.visit(current_location.copy_with().join(event.href))\n\t        elif (local_file := Path(event.href)).exists():\n\t            # It looks like a local file and it exists...\n\t            self.visit(local_file)\n\t        elif (\n\t            isinstance(current_location, Path)\n\t            and (local_file := (current_location.parent / Path(event.href)))\n\t            .absolute()\n", "            .exists()\n\t        ):\n\t            # It looks like a local file, and tested relative to the\n\t            # document we found it exists in the local filesystem, so let's\n\t            # assume that's what we're supposed to handle.\n\t            self.visit(local_file)\n\t        else:\n\t            # Yeah, not sure *what* this link is. Rather than silently fail,\n\t            # let's let the user know we don't know how to process this.\n\t            self.app.push_screen(\n", "                ErrorDialog(\n\t                    \"Unable to handle link\",\n\t                    f\"Unable to work out how to handle this link:\\n\\n{event.href}\",\n\t                )\n\t            )\n\t    def on_paste(self, event: Paste) -> None:\n\t        \"\"\"Handle a paste event.\n\t        Args:\n\t            event: The paste event.\n\t        This method is here to capture paste events that look like the name\n", "        of a local file (later I may add URL support too). The main purpose\n\t        of this is to handle drag/drop into the terminal.\n\t        \"\"\"\n\t        if (candidate_file := Path(event.text)).exists():\n\t            self.visit(candidate_file)\n\t    def action_navigation(self) -> None:\n\t        \"\"\"Toggle the availability of the navigation sidebar.\"\"\"\n\t        self.query_one(Navigation).toggle()\n\t    def action_escape(self) -> None:\n\t        \"\"\"Process the escape key.\"\"\"\n", "        # Escape is designed to work backwards out of the application. If\n\t        # the viewer is focused, the omnibox gets focused, if omnibox has\n\t        # focus but it isn't empty, it gets emptied, if it's empty we exit\n\t        # the application. The idea being that folk who use this often want\n\t        # to build up muscle memory on the keyboard will know to camp on the\n\t        # escape key until they get to where they want to be.\n\t        if (omnibox := self.query_one(Omnibox)).has_focus:\n\t            if omnibox.value:\n\t                omnibox.value = \"\"\n\t            else:\n", "                self.app.exit()\n\t        else:\n\t            if self.query(\"Navigation:focus-within\"):\n\t                self.query_one(Navigation).popped_out = False\n\t            omnibox.focus()\n\t    def action_omnibox(self) -> None:\n\t        \"\"\"Jump to the omnibox.\"\"\"\n\t        self.query_one(Omnibox).focus()\n\t    def action_table_of_contents(self) -> None:\n\t        \"\"\"Display and focus the table of contents pane.\"\"\"\n", "        self.query_one(Navigation).jump_to_contents()\n\t    def action_local_files(self) -> None:\n\t        \"\"\"Display and focus the local files selection pane.\"\"\"\n\t        self.query_one(Navigation).jump_to_local_files()\n\t    def action_bookmarks(self) -> None:\n\t        \"\"\"Display and focus the bookmarks selection pane.\"\"\"\n\t        self.query_one(Navigation).jump_to_bookmarks()\n\t    def action_history(self) -> None:\n\t        \"\"\"Display and focus the history pane.\"\"\"\n\t        self.query_one(Navigation).jump_to_history()\n", "    def action_backward(self) -> None:\n\t        \"\"\"Go backward in the history.\"\"\"\n\t        self.query_one(Viewer).back()\n\t    def action_forward(self) -> None:\n\t        \"\"\"Go forward in the history.\"\"\"\n\t        self.query_one(Viewer).forward()\n\t    def action_help(self) -> None:\n\t        \"\"\"Show the help.\"\"\"\n\t        self.app.push_screen(HelpDialog())\n\t    def action_about(self) -> None:\n", "        \"\"\"Show the about dialog.\"\"\"\n\t        self.app.push_screen(\n\t            InformationDialog(\n\t                f\"{APPLICATION_TITLE} [b dim]v{__version__}\",\n\t                f\"Built with [@click=app.visit('{TEXTUAL_URL}')]Textual[/] \"\n\t                f\"by [@click=app.visit('{ORGANISATION_URL}')]{ORGANISATION_TITLE}[/].\\n\\n\"\n\t                f\"[@click=app.visit('https://github.com/{ORGANISATION_NAME}/{PACKAGE_NAME}')]\"\n\t                f\"https://github.com/{ORGANISATION_NAME}/{PACKAGE_NAME}[/]\",\n\t            )\n\t        )\n", "    def add_bookmark(self, location: Path | URL, bookmark: str) -> None:\n\t        \"\"\"Handle adding the bookmark.\n\t        Args:\n\t            location: The location to bookmark.\n\t            bookmark: The bookmark to add.\n\t        \"\"\"\n\t        self.query_one(Navigation).bookmarks.add_bookmark(bookmark, location)\n\t    def action_bookmark_this(self) -> None:\n\t        \"\"\"Add a bookmark for the currently-viewed file.\"\"\"\n\t        location = self.query_one(Viewer).location\n", "        # Only allow bookmarking if we're actually viewing something that\n\t        # can be bookmarked.\n\t        if not isinstance(location, (Path, URL)):\n\t            self.app.push_screen(\n\t                ErrorDialog(\n\t                    \"Not a bookmarkable location\",\n\t                    \"The current view can't be bookmarked.\",\n\t                )\n\t            )\n\t            return\n", "        # To make a bookmark, we need a title and a location. We've got a\n\t        # location; let's make the filename the default title.\n\t        title = (location if isinstance(location, Path) else Path(location.path)).name\n\t        # Give the user a chance to edit the title.\n\t        self.app.push_screen(\n\t            InputDialog(\"Bookmark title:\", title),\n\t            partial(self.add_bookmark, location),\n\t        )\n\t    def action_toggle_theme(self) -> None:\n\t        \"\"\"Toggle the light/dark mode theme.\"\"\"\n", "        config = load_config()\n\t        config.light_mode = not config.light_mode\n\t        save_config(config)\n\t        # pylint:disable=attribute-defined-outside-init\n\t        self.app.dark = not config.light_mode\n\t    def action_reload(self) -> None:\n\t        \"\"\"Reload the current document.\"\"\"\n\t        self.query_one(Viewer).reload()\n"]}
{"filename": "frogmouth/screens/__init__.py", "chunked_list": ["\"\"\"The screens for the application.\"\"\"\n\tfrom .main import Main\n\t__all__ = [\"Main\"]\n"]}
{"filename": "frogmouth/app/app.py", "chunked_list": ["\"\"\"The main application class for the viewer.\"\"\"\n\tfrom argparse import ArgumentParser, Namespace\n\tfrom webbrowser import open as open_url\n\tfrom textual import __version__ as textual_version  # pylint: disable=no-name-in-module\n\tfrom textual.app import App\n\tfrom .. import __version__\n\tfrom ..data import load_config\n\tfrom ..screens import Main\n\tfrom ..utility.advertising import APPLICATION_TITLE, PACKAGE_NAME\n\tclass MarkdownViewer(App[None]):\n", "    \"\"\"The main application class.\"\"\"\n\t    TITLE = APPLICATION_TITLE\n\t    \"\"\"The main title for the application.\"\"\"\n\t    def __init__(self, cli_args: Namespace) -> None:\n\t        \"\"\"Initialise the application.\n\t        Args:\n\t            cli_args: The command line arguments.\n\t        \"\"\"\n\t        super().__init__()\n\t        self._args = cli_args\n", "        self.dark = not load_config().light_mode\n\t    def on_mount(self) -> None:\n\t        \"\"\"Set up the application after the DOM is ready.\"\"\"\n\t        self.push_screen(Main(\" \".join(self._args.file) if self._args.file else None))\n\t    def action_visit(self, url: str) -> None:\n\t        \"\"\"Visit the given URL, via the operating system.\n\t        Args:\n\t            url: The URL to visit.\n\t        \"\"\"\n\t        open_url(url)\n", "def get_args() -> Namespace:\n\t    \"\"\"Parse and return the command line arguments.\n\t    Returns:\n\t        The result of parsing the arguments.\n\t    \"\"\"\n\t    # Create the parser object.\n\t    parser = ArgumentParser(\n\t        prog=PACKAGE_NAME,\n\t        description=f\"{APPLICATION_TITLE} -- A Markdown viewer for the terminal.\",\n\t        epilog=f\"v{__version__}\",\n", "    )\n\t    # Add --version\n\t    parser.add_argument(\n\t        \"-v\",\n\t        \"--version\",\n\t        help=\"Show version information.\",\n\t        action=\"version\",\n\t        version=f\"%(prog)s {__version__} (Textual v{textual_version})\",\n\t    )\n\t    # The remainder is the file to view.\n", "    parser.add_argument(\"file\", help=\"The Markdown file to view\", nargs=\"*\")\n\t    # Finally, parse the command line.\n\t    return parser.parse_args()\n\tdef run() -> None:\n\t    \"\"\"Run the application.\"\"\"\n\t    MarkdownViewer(get_args()).run()\n"]}
{"filename": "frogmouth/app/__init__.py", "chunked_list": ["\"\"\"The main application code.\"\"\"\n\tfrom .app import run\n\t__all__ = [\"run\"]\n"]}
