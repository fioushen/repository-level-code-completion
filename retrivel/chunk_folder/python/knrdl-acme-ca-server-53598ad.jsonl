{"filename": "app/main.py", "chunked_list": ["__version__ = '0.0.0'  # replaced during build, do not change\n\tfrom contextlib import asynccontextmanager\n\tfrom pathlib import Path\n\tfrom fastapi import FastAPI, HTTPException, Request, status\n\tfrom fastapi.exception_handlers import http_exception_handler\n\tfrom fastapi.exceptions import RequestValidationError\n\tfrom fastapi.openapi.docs import get_swagger_ui_html\n\tfrom fastapi.responses import JSONResponse\n\tfrom fastapi.staticfiles import StaticFiles\n\tfrom pydantic import ValidationError\n", "import acme\n\timport ca\n\timport db\n\timport db.migrations\n\timport web\n\tfrom acme.exceptions import ACMEException\n\tfrom config import settings\n\t@asynccontextmanager\n\tasync def lifespan(app: FastAPI):\n\t    await db.connect()\n", "    await db.migrations.run()\n\t    await ca.init()\n\t    await acme.start_cronjobs()\n\t    yield\n\t    await db.disconnect()\n\tapp = FastAPI(\n\t    lifespan=lifespan, version=__version__, redoc_url=None, docs_url=None,\n\t    title=settings.web.app_title, description=settings.web.app_description)\n\tapp.add_middleware(\n\t    web.middleware.SecurityHeadersMiddleware,\n", "    content_security_policy={\n\t        '/acme/': \"base-uri 'self'; default-src 'none';\",\n\t        '/endpoints': \"base-uri 'self'; default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; frame-src 'none'; img-src 'self' data:;\",\n\t        '/': \"base-uri 'self'; default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self'; frame-src 'none'; img-src 'self' data:;\"\n\t    })\n\tif settings.web.enabled:\n\t    @app.get('/endpoints', tags=['web'])\n\t    async def swagger_ui_html():\n\t        return get_swagger_ui_html(\n\t            openapi_url='/openapi.json',\n", "            title=app.title,\n\t            swagger_favicon_url='favicon.png',\n\t            swagger_css_url='libs/swagger-ui.css',\n\t            swagger_js_url='libs/swagger-ui-bundle.js'\n\t        )\n\t@app.exception_handler(RequestValidationError)\n\t@app.exception_handler(HTTPException)\n\t@app.exception_handler(ACMEException)\n\t@app.exception_handler(Exception)\n\tasync def acme_exception_handler(request: Request, exc: Exception):\n", "    # custom exception handler for acme specific response format\n\t    if request.url.path.startswith('/acme/') or isinstance(exc, ACMEException):\n\t        if isinstance(exc, ACMEException):\n\t            return await exc.as_response()\n\t        elif isinstance(exc, ValidationError):\n\t            return await ACMEException(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, type='malformed', detail=exc.json()).as_response()\n\t        elif isinstance(exc, HTTPException):\n\t            return await ACMEException(status_code=exc.status_code, type='serverInternal', detail=str(exc.detail)).as_response()\n\t        else:\n\t            return await ACMEException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, type='serverInternal', detail=str(exc)).as_response()\n", "    else:\n\t        if isinstance(exc, HTTPException):\n\t            return await http_exception_handler(request, exc)\n\t        else:\n\t            return JSONResponse({'detail': str(exc)}, status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)\n\tapp.include_router(acme.router)\n\tapp.include_router(acme.directory_router.api)  # serve acme directory under /acme/directory and /directory\n\tapp.include_router(ca.router)\n\tif settings.web.enabled:\n\t    app.include_router(web.router)\n", "    if Path('/app/web/www').exists():\n\t        app.mount('/', StaticFiles(directory='/app/web/www'), name='static')\n"]}
{"filename": "app/config.py", "chunked_list": ["from datetime import timedelta\n\tfrom typing import Any, Literal, Optional, Pattern\n\tfrom pydantic import AnyHttpUrl, BaseSettings, EmailStr, PostgresDsn, SecretStr, root_validator\n\tfrom logger import logger\n\tclass WebSettings(BaseSettings):\n\t    enabled: bool = True\n\t    enable_public_log: bool = False\n\t    app_title: str = 'ACME CA Server'\n\t    app_description: str = 'Self hosted ACME CA Server'\n\t    class Config:\n", "        env_prefix = 'web_'\n\tclass CaSettings(BaseSettings):\n\t    enabled: bool = True\n\t    cert_lifetime: timedelta = timedelta(days=60)\n\t    crl_lifetime: timedelta = timedelta(days=7)\n\t    # encryption of private keys in database\n\t    encryption_key: Optional[SecretStr]\n\t    class Config:\n\t        env_prefix = 'ca_'\n\t    @root_validator(pre=False)\n", "    def valid_check(cls, values: dict[str, Any]) -> dict[str, Any]:\n\t        if values['enabled']:\n\t            if not values['encryption_key']:\n\t                from cryptography.fernet import Fernet\n\t                raise Exception('Env Var ca_encryption_key is missing, use this freshly generated key: ' + Fernet.generate_key().decode())\n\t            if values['cert_lifetime'].days < 1:\n\t                raise Exception('Cert lifetime for internal CA must be at least one day, not: ' + str(values['cert_lifetime']))\n\t            if values['crl_lifetime'].days < 1:\n\t                raise Exception('CRL lifetime for internal CA must be at least one day, not: ' + str(values['crl_lifetime']))\n\t        return values\n", "class MailSettings(BaseSettings):\n\t    enabled: bool = False\n\t    host: Optional[str] = None\n\t    port: Optional[int] = None\n\t    username: Optional[str] = None\n\t    password: Optional[SecretStr] = None\n\t    encryption: Literal['tls', 'starttls', 'plain'] = 'tls'\n\t    sender: Optional[EmailStr] = None\n\t    notify_on_account_creation: bool = True\n\t    warn_before_cert_expires: timedelta | Literal[False] = timedelta(days=20)\n", "    notify_when_cert_expired: bool = True\n\t    class Config:\n\t        env_prefix = 'mail_'\n\t    @root_validator(pre=True)\n\t    def sanitize_values(cls, values):\n\t        if 'warn_before_cert_expires' in values:  # not in values if default value\n\t            if (values['warn_before_cert_expires'] or '').lower().strip() in ('', 'false', '0', '-1'):\n\t                values['warn_before_cert_expires'] = False\n\t        return values\n\t    @root_validator(pre=False)\n", "    def valid_check(cls, values: dict[str, Any]) -> dict[str, Any]:\n\t        if values['enabled'] and (not values['host'] or not values['sender']):\n\t            raise Exception('Mail parameters (mail_host, mail_sender) are missing as SMTP is enabled')\n\t        if (values['username'] and not values['password']) or (not values['username'] and values['password']):\n\t            raise Exception('Either no mail auth must be specifid or username and password must be provided')\n\t        if values['enabled'] and not values['port']:\n\t            values['port'] = {'tls': 465, 'starttls': 587, 'plain': 25}[values['encryption']]\n\t        return values\n\tclass AcmeSettings(BaseSettings):\n\t    terms_of_service_url: AnyHttpUrl = None\n", "    mail_target_regex: Pattern = r'[^@]+@[^@]+\\.[^@]+'\n\t    target_domain_regex: Pattern = r'[^\\*]+\\.[^\\.]+'  # disallow wildcard\n\t    class Config:\n\t        env_prefix = 'acme_'\n\tclass Settings(BaseSettings):\n\t    external_url: AnyHttpUrl\n\t    db_dsn: PostgresDsn\n\t    acme: AcmeSettings = AcmeSettings()\n\t    ca: CaSettings = CaSettings()\n\t    mail: MailSettings = MailSettings()\n", "    web: WebSettings = WebSettings()\n\tsettings = Settings()\n\tlogger.info(f'Settings: {settings.dict()}')\n\tif settings.external_url.scheme != 'https':\n\t    logger.warning('Env Var \"external_url\" is not HTTPS. This is insecure!')\n\tif settings.mail.warn_before_cert_expires and settings.ca.enabled and settings.mail.enabled:\n\t    if settings.mail.warn_before_cert_expires >= settings.ca.cert_lifetime:\n\t        raise Exception('Env var web_warn_before_cert_expires cannot be greater than ca_cert_lifetime')\n\t    if settings.mail.warn_before_cert_expires.days > settings.ca.cert_lifetime.days / 2:\n\t        logger.warning('Env var mail_warn_before_cert_expires should be more than half of the cert lifetime')\n"]}
{"filename": "app/logger.py", "chunked_list": ["import logging\n\tlogger = logging.getLogger('uvicorn')\n"]}
{"filename": "app/ca/model.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom cryptography import x509\n\t@dataclass\n\tclass SignedCertInfo:\n\t    cert: x509.Certificate\n\t    cert_chain_pem: str\n"]}
{"filename": "app/ca/__init__.py", "chunked_list": ["import asyncio\n\tfrom pathlib import Path\n\tfrom cryptography import x509\n\tfrom cryptography.hazmat.primitives import serialization\n\tfrom fastapi import APIRouter, Response\n\tfrom pydantic import constr\n\timport db\n\tfrom acme.certificate.service import SerialNumberConverter\n\tfrom config import settings\n\tfrom logger import logger\n", "router = APIRouter(prefix='/ca', tags=['ca'])\n\tif settings.ca.enabled:\n\t    from cryptography.fernet import Fernet\n\t    from . import cronjob\n\t    from .service import build_crl_sync\n\t    @router.get('/{serial_number}/crl', response_class=Response, responses={\n\t        200: {'content': {'application/pkix-crl': {}}}\n\t    })\n\t    async def download_crl(serial_number: constr(regex='^[0-9A-F]+$')):\n\t        async with db.transaction(readonly=True) as sql:\n", "            crl_pem = await sql.value('select crl_pem from cas where serial_number = $1', serial_number)\n\t        return Response(content=crl_pem, media_type='application/pkix-crl')\n\t    async def init():\n\t        if Path('/import/ca.pem').is_file() and Path('/import/ca.key').is_file():\n\t            with open('/import/ca.key', 'rb') as f:\n\t                ca_key_bytes = f.read()\n\t            ca_key = serialization.load_pem_private_key(ca_key_bytes, None)\n\t            f = Fernet(settings.ca.encryption_key.get_secret_value())\n\t            ca_key_enc = f.encrypt(ca_key_bytes)\n\t            with open('/import/ca.pem', 'rb') as f:\n", "                ca_cert_bytes = f.read()\n\t            ca_cert = x509.load_pem_x509_certificate(ca_cert_bytes, None)\n\t            serial_number = SerialNumberConverter.int2hex(ca_cert.serial_number)\n\t            async with db.transaction(readonly=True) as sql:\n\t                revocations = [record async for record in sql('select serial_number, revoked_at from certificates where revoked_at is not null')]\n\t            crl, crl_pem = await asyncio.to_thread(build_crl_sync, ca_key=ca_key, ca_cert=ca_cert, revocations=revocations)\n\t            async with db.transaction() as sql:\n\t                await sql.exec('update cas set active = false')\n\t                await sql.exec(\"\"\"\n\t                    insert into cas (serial_number, cert_pem, key_pem_enc, active, crl_pem)\n", "                        values ($1, $2, $3, true, $4)\n\t                    on conflict (serial_number) do update set active = true, crl_pem = $4\n\t                \"\"\", serial_number, ca_cert_bytes.decode(), ca_key_enc, crl_pem)\n\t            logger.info('Successfully imported CA provided in /import folder')\n\t        else:\n\t            async with db.transaction() as sql:\n\t                ok = await sql.value('select count(serial_number)=1 from cas where active=true')\n\t            if not ok:\n\t                raise Exception('internal ca is enabled but no CA certificate is registered and active. Please import one first.')\n\t        await cronjob.start()\n", "else:\n\t    async def init():\n\t        logger.info('Builtin CA is disabled, relying on custom CA implementation')\n"]}
{"filename": "app/ca/service.py", "chunked_list": ["# this file can be overwritten to provide a custom ca implementation\n\t# the methods sign_csr() and revoke_cert() must be implemented with matching function signatures\n\t# set env var CA_ENABLED=False when providing a custom ca implementation\n\timport asyncio\n\tfrom datetime import datetime\n\tfrom cryptography import x509\n\tfrom cryptography.fernet import Fernet\n\tfrom cryptography.hazmat.primitives import hashes, serialization\n\tfrom cryptography.hazmat.primitives.asymmetric.types import PrivateKeyTypes\n\timport db\n", "from acme.certificate.service import SerialNumberConverter\n\tfrom config import settings\n\tfrom .model import SignedCertInfo\n\tasync def sign_csr(csr: x509.CertificateSigningRequest, subject_domain: str, san_domains: list[str]) -> SignedCertInfo:\n\t    \"\"\"\n\t    csr: the parsed csr object\n\t    subject_domain: the main requested domain name\n\t    san_domains: the alternative (additional) requested domain names\n\t    \"\"\"\n\t    if not settings.ca.enabled:\n", "        raise Exception('internal ca is not enabled (env var CA_ENABLED)! Please provide a custom ca implementation')\n\t    ca_cert, ca_key = await load_active_ca()\n\t    cert, cert_chain_pem = await asyncio.to_thread(generate_cert_sync,\n\t                                                   ca_key=ca_key, ca_cert=ca_cert, csr=csr, subject_domain=subject_domain, san_domains=san_domains)\n\t    return SignedCertInfo(cert=cert, cert_chain_pem=cert_chain_pem)\n\tasync def revoke_cert(serial_number: str, revocations: set[tuple[str, datetime]]) -> None:\n\t    if not settings.ca.enabled:\n\t        raise Exception('internal ca is not enabled (env var CA_ENABLED)! Please provide a custom ca implementation')\n\t    ca_cert, ca_key = await load_active_ca()\n\t    crl, crl_pem = await asyncio.to_thread(build_crl_sync, ca_key=ca_key, ca_cert=ca_cert, revocations=revocations)\n", "    async with db.transaction() as sql:\n\t        await sql.exec('update cas set crl_pem = $1 where active = true', crl_pem)\n\tasync def load_active_ca():\n\t    async with db.transaction(readonly=True) as sql:\n\t        cert_pem, key_pem_enc = await sql.record('select cert_pem, key_pem_enc from cas where active = true')\n\t    return await asyncio.to_thread(load_ca_sync, cert_pem=cert_pem, key_pem_enc=key_pem_enc)\n\tdef load_ca_sync(*, cert_pem, key_pem_enc):\n\t    f = Fernet(settings.ca.encryption_key.get_secret_value())\n\t    key_pem = f.decrypt(key_pem_enc)\n\t    ca_key = serialization.load_pem_private_key(key_pem, None)\n", "    ca_cert = x509.load_pem_x509_certificate(cert_pem.encode(), None)\n\t    return ca_cert, ca_key\n\tdef generate_cert_sync(*, ca_key: PrivateKeyTypes, ca_cert: x509.Certificate,\n\t                       csr: x509.CertificateSigningRequest, subject_domain: str, san_domains: list[str]):\n\t    ca_id = SerialNumberConverter.int2hex(ca_cert.serial_number)\n\t    cert_builder = x509.CertificateBuilder(\n\t        issuer_name=ca_cert.subject,\n\t        subject_name=x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, subject_domain)]),\n\t        serial_number=x509.random_serial_number(),\n\t        not_valid_before=datetime.utcnow(),\n", "        not_valid_after=datetime.utcnow() + settings.ca.cert_lifetime,\n\t        public_key=csr.public_key()\n\t    ) \\\n\t        .add_extension(x509.BasicConstraints(ca=False, path_length=None), critical=True) \\\n\t        .add_extension(x509.CRLDistributionPoints(distribution_points=[x509.DistributionPoint(full_name=[\n\t            x509.UniformResourceIdentifier(settings.external_url.removesuffix('/') + f'/ca/{ca_id}/crl')\n\t        ], relative_name=None, reasons=None, crl_issuer=None)]), critical=True) \\\n\t        .add_extension(x509.SubjectAlternativeName(general_names=[x509.DNSName(domain) for domain in san_domains]), critical=False)\n\t    cert = cert_builder.sign(private_key=ca_key, algorithm=hashes.SHA512(),)\n\t    cert_pem = cert.public_bytes(serialization.Encoding.PEM)\n", "    ca_cert_pem = ca_cert.public_bytes(serialization.Encoding.PEM)\n\t    cert_chain_pem = (cert_pem + ca_cert_pem).decode()\n\t    return cert, cert_chain_pem\n\tdef build_crl_sync(*, ca_key: PrivateKeyTypes, ca_cert: x509.Certificate, revocations: set[tuple[str, datetime]]):\n\t    now = datetime.utcnow()\n\t    builder = x509.CertificateRevocationListBuilder(\n\t        last_update=now,\n\t        next_update=now + settings.ca.crl_lifetime,\n\t        issuer_name=ca_cert.subject\n\t    )\n", "    for serial_number, revoked_at in revocations:\n\t        revoked_cert = x509.RevokedCertificateBuilder() \\\n\t            .serial_number(SerialNumberConverter.hex2int(serial_number)) \\\n\t            .revocation_date(revoked_at) \\\n\t            .build()\n\t        builder = builder.add_revoked_certificate(revoked_cert)\n\t    crl = builder.sign(private_key=ca_key, algorithm=hashes.SHA512())\n\t    crl_pem = crl.public_bytes(encoding=serialization.Encoding.PEM).decode()\n\t    return crl, crl_pem\n"]}
{"filename": "app/ca/cronjob.py", "chunked_list": ["import asyncio\n\timport db\n\tfrom logger import logger\n\tfrom .service import build_crl_sync, load_ca_sync\n\tasync def start():\n\t    async def run():\n\t        while True:\n\t            try:\n\t                async with db.transaction(readonly=True) as sql:\n\t                    cas = [record async for record in sql('select serial_number, cert_pem, key_pem_enc from cas')]\n", "                for sn, cert_pem, key_pem_enc in cas:\n\t                    ca_cert, ca_key = await asyncio.to_thread(load_ca_sync, cert_pem=cert_pem, key_pem_enc=key_pem_enc)\n\t                    # todo: maybe also include expired certs\n\t                    async with db.transaction(readonly=True) as sql:\n\t                        revocations = [record async for record in sql('select serial_number, revoked_at from certificates where revoked_at is not null')]\n\t                    crl, crl_pem = await asyncio.to_thread(build_crl_sync, ca_key=ca_key, ca_cert=ca_cert, revocations=revocations)\n\t                    async with db.transaction() as sql:\n\t                        await sql.exec('update cas set crl_pem = $1 where serial_number = $2', crl_pem, sn)\n\t            except Exception:\n\t                logger.error('could not rebuild crl', exc_info=True)\n", "            finally:\n\t                await asyncio.sleep(12 * 60 * 60)  # rebuild crl every 12h\n\t    asyncio.create_task(run())\n"]}
{"filename": "app/acme/__init__.py", "chunked_list": ["import asyncio\n\tfrom typing import Any\n\tfrom fastapi import APIRouter\n\tfrom fastapi.responses import JSONResponse\n\tfrom .account import router as account_router\n\tfrom .authorization import router as authorization_router\n\tfrom .certificate import cronjob as certificate_cronjob\n\tfrom .certificate import router as certificate_router\n\tfrom .challenge import router as challenge_router\n\tfrom .directory import router as directory_router\n", "from .nonce import cronjob as nonce_cronjob\n\tfrom .nonce import router as nonce_router\n\tfrom .order import router as order_router\n\tclass ACMEResponse(JSONResponse):\n\t    def render(self, content: dict[str, Any] | None) -> bytes:\n\t        return super().render(  # remove null fields from responses\n\t            {k: v for k, v in content.items() if v is not None}\n\t            if content is not None else None\n\t        )\n\trouter = APIRouter(prefix='/acme', default_response_class=ACMEResponse)\n", "router.include_router(account_router.api)\n\trouter.include_router(authorization_router.api)\n\trouter.include_router(certificate_router.api)\n\trouter.include_router(challenge_router.api)\n\trouter.include_router(directory_router.api)\n\trouter.include_router(nonce_router.api)\n\trouter.include_router(order_router.api)\n\tasync def start_cronjobs():\n\t    await asyncio.gather(\n\t        certificate_cronjob.start(),\n", "        nonce_cronjob.start()\n\t    )\n"]}
{"filename": "app/acme/middleware.py", "chunked_list": ["import json\n\tfrom typing import Any, Generic, Literal, Optional, TypeVar, Union\n\timport jwcrypto.jwk\n\timport jwcrypto.jws\n\tfrom fastapi import Body, Header, Request, Response, status\n\tfrom jwcrypto.common import base64url_decode\n\tfrom pydantic import AnyHttpUrl, BaseModel, constr, root_validator\n\tfrom pydantic.generics import GenericModel\n\timport db\n\tfrom config import settings\n", "from .exceptions import ACMEException\n\tfrom .nonce import service as nonce_service\n\tclass RsaJwk(BaseModel):\n\t    n: constr(min_length=1)\n\t    e: constr(min_length=1)\n\t    kty: Literal['RSA']\n\tclass EcJwk(BaseModel):\n\t    crv: Literal['P-256']\n\t    x: constr(min_length=1)\n\t    y: constr(min_length=1)\n", "    kty: Literal['EC']\n\tPayloadT = TypeVar('PayloadT')\n\tclass RequestData(GenericModel, Generic[PayloadT]):\n\t    payload: PayloadT\n\t    key: jwcrypto.jwk.JWK\n\t    account_id: Optional[str]  # None if account does not exist\n\t    new_nonce: str\n\tclass Protected(BaseModel):\n\t    # see https://www.rfc-editor.org/rfc/rfc8555#section-6.2\n\t    alg: Literal['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512']\n", "    jwk: Optional[Union[RsaJwk, EcJwk]]  # new user\n\t    kid: Optional[str]  # existing user\n\t    nonce: constr(min_length=1)\n\t    url: AnyHttpUrl\n\t    @root_validator\n\t    def valid_check(cls, values: dict[str, Any]) -> dict[str, Any]:\n\t        if not values.get('jwk') and not values.get('kid'):\n\t            raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='malformed', detail='either jwk or kid must be set')\n\t        if values.get('jwk') and values.get('kid'):\n\t            raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='malformed', detail='the fields jwk and kid are mutually exclusive')\n", "        return values\n\tclass SignedRequest:\n\t    def __init__(self, payload_model: BaseModel = None, *,\n\t                 allow_new_account: bool = False, allow_blocked_account: bool = False):\n\t        self.allow_new_account = allow_new_account\n\t        self.allow_blocked_account = allow_blocked_account\n\t        self.payload_model = payload_model\n\t    @staticmethod\n\t    def _schemeless_url(url: str):\n\t        if url.startswith('https://'):\n", "            return url.removeprefix('https://')\n\t        if url.startswith('http://'):\n\t            return url.removeprefix('http://')\n\t        return url\n\t    async def __call__(\n\t        self, request: Request, response: Response,\n\t        content_type: str = Header(..., regex=r'^application/jose\\+json$', description='Content Type must be \"application/jose+json\"'),\n\t        protected: constr(min_length=1) = Body(...), signature: constr(min_length=1) = Body(...), payload: constr(min_length=0) = Body(...)\n\t    ):\n\t        protected_data = Protected(**json.loads(base64url_decode(protected)))\n", "        # Scheme might be different because of reverse proxy forwarding\n\t        if self._schemeless_url(protected_data.url) != self._schemeless_url(str(request.url)):\n\t            raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='unauthorized', detail='Requested URL does not match with actually called URL')\n\t        if protected_data.kid:  # account exists\n\t            base_url = f'{settings.external_url}/acme/accounts/'\n\t            if not protected_data.kid.startswith(base_url):\n\t                raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='malformed', detail=f'JWS invalid: kid must start with: \"{base_url}\"')\n\t            account_id = protected_data.kid.split('/')[-1]\n\t            if account_id:\n\t                async with db.transaction(readonly=True) as sql:\n", "                    if self.allow_blocked_account:\n\t                        key_data = await sql.value('select jwk from accounts where id = $1', account_id)\n\t                    else:\n\t                        key_data = await sql.value(\"select jwk from accounts where id = $1 and status = 'valid'\", account_id)\n\t            else:\n\t                key_data = None\n\t            if not key_data:\n\t                raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='accountDoesNotExist', detail='unknown, deactived or revoked account')\n\t            key = jwcrypto.jwk.JWK()\n\t            key.import_key(**key_data)\n", "        elif self.allow_new_account:\n\t            account_id = None\n\t            key = jwcrypto.jwk.JWK()\n\t            key.import_key(**protected_data.jwk.dict())\n\t        else:\n\t            raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='accountDoesNotExist', detail='unknown account. not accepting new accounts')\n\t        jws = jwcrypto.jws.JWS()\n\t        if 'none' in jws.allowed_algs:\n\t            raise Exception('\"none\" is a forbidden JWS algorithm!')\n\t        try:\n", "            # signature is checked here\n\t            jws.deserialize(await request.body(), key)\n\t        except jwcrypto.jws.InvalidJWSSignature:\n\t            raise ACMEException(status_code=status.HTTP_403_FORBIDDEN, type='unauthorized', detail='signature check failed')\n\t        if self.payload_model and payload:\n\t            payload_data = self.payload_model(**json.loads(base64url_decode(payload)))\n\t        else:\n\t            payload_data = None\n\t        new_nonce = await nonce_service.refresh(protected_data.nonce)\n\t        response.headers['Replay-Nonce'] = new_nonce\n", "        # use append because there can be multiple Link-Headers with different rel targets\n\t        response.headers.append('Link', f'<{settings.external_url}/acme/directory>;rel=\"index\"')\n\t        return RequestData[self.payload_model](payload=payload_data, key=key, account_id=account_id, new_nonce=new_nonce)\n"]}
{"filename": "app/acme/exceptions.py", "chunked_list": ["from typing import Literal\n\tfrom fastapi import status\n\tfrom fastapi.responses import JSONResponse\n\tfrom config import settings\n\tAcmeExceptionTypes = Literal[\n\t    'accountDoesNotExist',\n\t    'alreadyRevoked',\n\t    'badCSR',\n\t    'badNonce',\n\t    'badPublicKey',\n", "    'badRevocationReason',\n\t    'badSignatureAlgorithm',\n\t    'caa',\n\t    'compound',\n\t    'connection',\n\t    'dns',\n\t    'externalAccountRequired',\n\t    'incorrectResponse',\n\t    'invalidContact',\n\t    'malformed',\n", "    'orderNotReady',\n\t    'rateLimited',\n\t    'rejectedIdentifier',\n\t    'serverInternal',\n\t    'tls',\n\t    'unauthorized',\n\t    'unsupportedContact',\n\t    'unsupportedIdentifier',\n\t    'userActionRequired'\n\t]\n", "class ACMEException(Exception):\n\t    exc_type: AcmeExceptionTypes\n\t    detail: str\n\t    headers: dict[str, str]\n\t    status_code: int\n\t    new_nonce: str | None\n\t    def __init__(\n\t        self, *, type: AcmeExceptionTypes, detail: str = '',  # noqa: A002 (allow shadowing builtin \"type\")\n\t        status_code: int = status.HTTP_400_BAD_REQUEST, new_nonce: str | None = None\n\t    ) -> None:\n", "        self.headers = {'Link': f'<{settings.external_url}/acme/directory>;rel=\"index\"'}\n\t        # when a new nonce is already created it should also be used in the exception case\n\t        # however if there is none yet, a new one gets generated in as_response()\n\t        self.new_nonce = new_nonce\n\t        self.exc_type = type\n\t        self.detail = detail\n\t        self.status_code = status_code\n\t    @property\n\t    def value(self):\n\t        return {'type': 'urn:ietf:params:acme:error:' + self.exc_type, 'detail': self.detail}\n", "    async def as_response(self):\n\t        if not self.new_nonce:\n\t            from .nonce.service import generate as generate_nonce  # import here to prevent circular import\n\t            self.new_nonce = await generate_nonce()\n\t        return JSONResponse(\n\t            status_code=self.status_code,\n\t            content=self.value,\n\t            headers=dict(self.headers, **{'Replay-Nonce': self.new_nonce}),\n\t            media_type='application/problem+json'\n\t        )\n", "    def __repr__(self) -> str:\n\t        return f'ACME-Exception({self.value})'\n"]}
{"filename": "app/acme/authorization/router.py", "chunked_list": ["from typing import Annotated, Literal, Optional\n\tfrom fastapi import APIRouter, Depends, status\n\tfrom pydantic import BaseModel\n\timport db\n\tfrom config import settings\n\tfrom ..exceptions import ACMEException\n\tfrom ..middleware import RequestData, SignedRequest\n\tclass UpdateAuthzPayload(BaseModel):\n\t    status: Optional[Literal['deactivated']]\n\tapi = APIRouter(tags=['acme:authorization'])\n", "@api.post('/authorizations/{authz_id}')\n\tasync def view_or_update_authorization(\n\t    authz_id: str,\n\t    data: Annotated[RequestData[Optional[UpdateAuthzPayload]],\n\t                    Depends(SignedRequest(Optional[UpdateAuthzPayload]))]\n\t):\n\t    async with db.transaction(readonly=True) as sql:\n\t        record = await sql.record(\"\"\"\n\t            select authz.status, ord.status, ord.expires_at, authz.domain, chal.id, chal.token, chal.status, chal.validated_at\n\t            from authorizations authz\n", "            join challenges chal on chal.authz_id = authz.id\n\t            join orders ord on authz.order_id = ord.id\n\t            where authz.id = $1 and ord.account_id = $2\n\t        \"\"\", authz_id, data.account_id)\n\t    if record:\n\t        authz_status, order_status, expires_at, domain, chal_id, chal_token, chal_status, chal_validated_at = record\n\t        if data.payload and data.payload.status == 'deactivated':  # deactivate authz\n\t            if authz_status in ['pending', 'valid'] and order_status in ['pending', 'ready']:\n\t                async with db.transaction() as sql:\n\t                    await sql.exec(\"\"\"\n", "                        update orders set status='invalid', error=row('unauthorized','authorization deactivated')\n\t                        where id = (select order_id from authorizations where id = $1)\n\t                    \"\"\", authz_id)\n\t                    authz_status = await sql.value(\"update authorizations set status = 'deactivated' where id = $1 returning status\", authz_id)\n\t        chal = {\n\t            'type': 'http-01',\n\t            'url': f'{settings.external_url}/acme/challenges/{chal_id}',\n\t            'token': chal_token,\n\t            'status': chal_status,\n\t            'validated': chal_validated_at\n", "        }\n\t        return {\n\t            'status': authz_status,\n\t            'expires': expires_at,\n\t            'identifier': {'type': 'dns', 'value': domain},\n\t            'challenges': [{k: v for k, v in chal.items() if v is not None}],\n\t        }\n\t    else:\n\t        raise ACMEException(status_code=status.HTTP_404_NOT_FOUND, type='malformed', detail='specified authorization not found for current account', new_nonce=data.new_nonce)\n\t@api.post('/new-authz')\n", "async def new_pre_authz(data: Annotated[RequestData, Depends(SignedRequest())]):\n\t    raise ACMEException(status_code=status.HTTP_403_FORBIDDEN, type='unauthorized', detail='pre authorization is not supported', new_nonce=data.new_nonce)\n"]}
{"filename": "app/acme/directory/router.py", "chunked_list": ["from fastapi import APIRouter\n\tfrom config import settings\n\tapi = APIRouter(tags=['acme:directory'])\n\t@api.get('/directory')\n\tasync def get_directory():\n\t    meta = {'website': settings.external_url}\n\t    if settings.acme.terms_of_service_url:\n\t        meta['termsOfService'] = settings.acme.terms_of_service_url\n\t    return {\n\t        'newNonce': f'{settings.external_url}/acme/new-nonce',\n", "        'newAccount': f'{settings.external_url}/acme/new-account',\n\t        'newOrder': f'{settings.external_url}/acme/new-order',\n\t        'revokeCert': f'{settings.external_url}/acme/revoke-cert',\n\t        'keyChange': f'{settings.external_url}/acme/key-change',\n\t        # newAuthz: is not supported\n\t        'meta': meta\n\t    }\n"]}
{"filename": "app/acme/challenge/router.py", "chunked_list": ["from typing import Annotated\n\tfrom fastapi import APIRouter, Depends, Response, status\n\timport db\n\tfrom config import settings\n\tfrom logger import logger\n\tfrom ..exceptions import ACMEException\n\tfrom ..middleware import RequestData, SignedRequest\n\tfrom . import service\n\tapi = APIRouter(tags=['acme:challenge'])\n\t@api.post('/challenges/{chal_id}')\n", "async def verify_challenge(response: Response, chal_id: str, data: Annotated[RequestData, Depends(SignedRequest())]):\n\t    must_solve_challenge = False\n\t    async with db.transaction() as sql:\n\t        record = await sql.record(\"\"\"\n\t            select chal.authz_id, chal.error, chal.status, authz.status, authz.domain, chal.validated_at, chal.token, ord.id, ord.status from challenges chal\n\t            join authorizations authz on authz.id = chal.authz_id\n\t            join orders ord on authz.order_id = ord.id\n\t            where chal.id = $1 and ord.account_id = $2 and ord.expires_at > now()\n\t        \"\"\", chal_id, data.account_id)\n\t        if not record:\n", "            raise ACMEException(status_code=status.HTTP_404_NOT_FOUND, type='malformed', detail='specified challenge not available for current account', new_nonce=data.new_nonce)\n\t        authz_id, chal_err, chal_status, authz_status, domain, chal_validated_at, token, order_id, order_status = record\n\t        if order_status == 'invalid':\n\t            await sql.exec(\"\"\"update authorizations set status = 'invalid' where id = $1\"\"\", authz_id)\n\t            await sql.value(\"\"\"\n\t                update challenges set status = 'invalid', error=row('unauthorized','order failed') where id = $1 and status <> 'invalid'\n\t            \"\"\", chal_id)\n\t            chal_status = 'invalid'\n\t        if chal_status == 'pending' and order_status == 'pending':\n\t            if authz_status == 'pending':\n", "                must_solve_challenge = True\n\t                chal_status = await sql.value(\"\"\"update challenges set status = 'processing' where id = $1 returning status\"\"\", chal_id)\n\t            else:\n\t                await sql.value(\"\"\"\n\t                    update challenges set status='invalid', error=row('unauthorized','authorization failed') where id = $1 and status <> 'invalid'\n\t                \"\"\", chal_id)\n\t                chal_status = 'invalid'\n\t    if chal_err:\n\t        acme_error = ACMEException(type=chal_err.get('type'), detail=chal_err.get('detail'), new_nonce=data.new_nonce)\n\t    else:\n", "        acme_error = None\n\t    # use append because there can be multiple Link-Headers with different rel targets\n\t    response.headers.append('Link', f'<{settings.external_url}/authorization/{authz_id}>;rel=\"up\"')\n\t    if must_solve_challenge:\n\t        try:\n\t            await service.check_challenge_is_fulfilled(domain=domain, token=token, jwk=data.key, new_nonce=data.new_nonce)\n\t            err = False\n\t        except ACMEException as e:\n\t            err = e\n\t        except Exception as e:\n", "            err = ACMEException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, type='serverInternal', detail=str(e), new_nonce=data.new_nonce)\n\t            logger.warning('challenge failed for %s (account: %s)', domain, data.account_id, exc_info=True)\n\t        if err is False:\n\t            async with db.transaction() as sql:\n\t                chal_status, chal_validated_at = await sql.record(\"\"\"\n\t                    update challenges set validated_at=now(), status = 'valid'\n\t                    where id = $1 and status='processing' returning status, validated_at\n\t                \"\"\", chal_id)\n\t                await sql.exec(\"\"\"\n\t                    update authorizations set status = 'valid' where id = $1 and status = 'pending'\n", "                \"\"\", authz_id)\n\t                await sql.exec(\"\"\"\n\t                    update orders set status='ready' where id = $1 and status='pending' and\n\t                    (select count(id) from authorizations where order_id = $1 and status <> 'valid') = 0\n\t                \"\"\", order_id)  # set order to ready if all authzs are valid\n\t        else:\n\t            acme_error = err\n\t            async with db.transaction() as sql:\n\t                chal_status = await sql.value(\"\"\"\n\t                    update challenges set status = 'invalid', error=row($2,$3) where id = $1 returning status\n", "                \"\"\", chal_id, err.exc_type, err.detail)\n\t                await sql.exec(\"update authorizations set status = 'invalid' where id = $1\", authz_id)\n\t                await sql.exec(\"\"\"\n\t                    update orders set status = 'invalid', error=row('unauthorized', 'challenge failed') where id = $1\n\t                \"\"\", order_id)\n\t    return {\n\t        'type': 'http-01',\n\t        'url': f'{settings.external_url}/acme/challenges/{chal_id}',\n\t        'status': chal_status,\n\t        'validated': chal_validated_at,\n", "        'token': token,\n\t        'error': acme_error.value if acme_error else None\n\t    }\n"]}
{"filename": "app/acme/challenge/service.py", "chunked_list": ["import asyncio\n\timport httpx\n\timport jwcrypto.jwk\n\tfrom fastapi import status\n\tfrom ..exceptions import ACMEException\n\tasync def check_challenge_is_fulfilled(*, domain: str, token: str, jwk: jwcrypto.jwk.JWK, new_nonce: str = None):\n\t    for _ in range(3):  # 3x retry\n\t        err = True\n\t        try:\n\t            async with httpx.AsyncClient(\n", "                timeout=10,\n\t                # only http 1.0/1.1 is required, not https\n\t                verify=False, http1=True, http2=False,  # noqa: S501 (https is intentionally disabled)\n\t                # todo: redirects are forbidden for now, but RFC states redirects should be supported\n\t                follow_redirects=False,\n\t                trust_env=False  # do not load proxy information from env vars\n\t            ) as client:\n\t                res = await client.get(f'http://{domain}:80/.well-known/acme-challenge/{token}')\n\t                if res.status_code == 200 and res.text.rstrip() == f'{token}.{jwk.thumbprint()}':\n\t                    err = False\n", "                else:\n\t                    err = ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='incorrectResponse', detail='presented token does not match challenge', new_nonce=new_nonce)\n\t        except httpx.ConnectTimeout:\n\t            err = ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='connection', detail='timeout', new_nonce=new_nonce)\n\t        except httpx.ConnectError:\n\t            err = ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='dns', detail='could not resolve address', new_nonce=new_nonce)\n\t        except Exception:\n\t            err = ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='serverInternal', detail='could not validate challenge', new_nonce=new_nonce)\n\t        if err is False:\n\t            return  # check successful\n", "        await asyncio.sleep(3)\n\t    raise err\n"]}
{"filename": "app/acme/order/router.py", "chunked_list": ["import asyncio\n\timport secrets\n\tfrom datetime import datetime\n\tfrom typing import Annotated, Literal, Optional\n\tfrom fastapi import APIRouter, Depends, Response, status\n\tfrom jwcrypto.common import base64url_decode\n\tfrom pydantic import BaseModel, conlist, constr\n\timport db\n\tfrom ca import service as ca_service\n\tfrom config import settings\n", "from logger import logger\n\tfrom ..certificate.service import SerialNumberConverter, check_csr\n\tfrom ..exceptions import ACMEException\n\tfrom ..middleware import RequestData, SignedRequest\n\tclass NewOrderDomain(BaseModel):\n\t    type: Literal['dns']  # noqa: A003 (allow shadowing builtin \"type\")\n\t    value: constr(regex=f'^{settings.acme.target_domain_regex.pattern}$')\n\tclass NewOrderPayload(BaseModel):\n\t    identifiers: conlist(NewOrderDomain, min_items=1)\n\t    notBefore: Optional[datetime] = None\n", "    notAfter: Optional[datetime] = None\n\tclass FinalizeOrderPayload(BaseModel):\n\t    csr: constr(min_length=1, max_length=1 * 1024**2)\n\tdef order_response(\n\t    *, status: str, expires_at: datetime, domains: list[str], authz_ids: list[str], order_id: str, error: Optional[ACMEException] = None,\n\t        not_valid_before: Optional[datetime] = None, not_valid_after: Optional[datetime] = None, cert_serial_number: Optional[str] = None):\n\t    return {\n\t        'status': status,\n\t        'expires': expires_at,\n\t        'identifiers': [{'type': 'dns', 'value': domain} for domain in domains],\n", "        'authorizations': [f'{settings.external_url}/acme/authorizations/{authz_id}' for authz_id in authz_ids],\n\t        'finalize': f'{settings.external_url}/acme/orders/{order_id}/finalize',\n\t        'error': error.value if error else None,\n\t        'notBefore': not_valid_before,\n\t        'notAfter': not_valid_after,\n\t        'certificate': f'{settings.external_url}/acme/certificates/{cert_serial_number}' if cert_serial_number else None\n\t    }\n\tapi = APIRouter(tags=['acme:order'])\n\t@api.post('/new-order', status_code=201)\n\tasync def submit_order(response: Response, data: Annotated[RequestData[NewOrderPayload], Depends(SignedRequest(NewOrderPayload))]):\n", "    if data.payload.notBefore is not None or data.payload.notAfter is not None:\n\t        raise ACMEException(type='malformed',\n\t                            detail='Parameter notBefore and notAfter may not be specified as the constraints might cannot be enforced.',\n\t                            new_nonce=data.new_nonce)\n\t    domains: list[str] = [identifier.value for identifier in data.payload.identifiers]\n\t    def generate_tokens_sync(domains):\n\t        order_id = secrets.token_urlsafe(16)\n\t        authz_ids = {domain: secrets.token_urlsafe(16) for domain in domains}\n\t        chal_ids = {domain: secrets.token_urlsafe(16) for domain in domains}\n\t        chal_tkns = {domain: secrets.token_urlsafe(32) for domain in domains}\n", "        return order_id, authz_ids, chal_ids, chal_tkns\n\t    order_id, authz_ids, chal_ids, chal_tkns = await asyncio.to_thread(generate_tokens_sync, domains)\n\t    async with db.transaction() as sql:\n\t        order_status, expires_at = await sql.record(\"\"\"\n\t            insert into orders (id, account_id) values ($1, $2)\n\t            returning status, expires_at\n\t        \"\"\", order_id, data.account_id)\n\t        await sql.execmany(\"\"\"insert into authorizations (id, order_id, domain) values ($1, $2, $3)\"\"\",\n\t                           *[(authz_ids[domain], order_id, domain) for domain in domains])\n\t        await sql.execmany(\"\"\"insert into challenges (id, authz_id, token) values ($1, $2, $3)\"\"\",\n", "                           *[(chal_ids[domain], authz_ids[domain], chal_tkns[domain]) for domain in domains])\n\t    response.headers['Location'] = f'{settings.external_url}/acme/orders/{order_id}'\n\t    return order_response(\n\t        status=order_status,\n\t        expires_at=expires_at,\n\t        domains=domains,\n\t        authz_ids=authz_ids.values(),\n\t        order_id=order_id\n\t    )\n\t@api.post('/orders/{order_id}')\n", "async def view_order(order_id: str, data: Annotated[RequestData, Depends(SignedRequest())]):\n\t    async with db.transaction(readonly=True) as sql:\n\t        record = await sql.record(\"\"\"\n\t            select status, expires_at, error from orders where id = $1 and account_id = $2\n\t        \"\"\", order_id, data.account_id)\n\t        if not record:\n\t            raise ACMEException(status_code=status.HTTP_404_NOT_FOUND, type='malformed', detail='specified order not found for current account', new_nonce=data.new_nonce)\n\t        order_status, expires_at, err = record\n\t        authzs = [row async for row in sql('select id, domain from authorizations where order_id = $1', order_id)]\n\t        cert_record = await sql.record('select serial_number, not_valid_before, not_valid_after from certificates where order_id = $1', order_id)\n", "    if cert_record:\n\t        cert_sn, not_valid_before, not_valid_after = cert_record\n\t    if err:\n\t        acme_error = ACMEException(type=err.get('type'), detail=err.get('detail'), new_nonce=data.new_nonce)\n\t    else:\n\t        acme_error = None\n\t    return order_response(\n\t        status=order_status,\n\t        expires_at=expires_at,\n\t        domains=[domain for _, domain in authzs],\n", "        authz_ids=[authz_id for authz_id, _ in authzs],\n\t        order_id=order_id,\n\t        not_valid_before=not_valid_before if cert_record else None,\n\t        not_valid_after=not_valid_after if cert_record else None,\n\t        cert_serial_number=cert_sn if cert_record else None,\n\t        error=acme_error\n\t    )\n\t@api.post('/orders/{order_id}/finalize')\n\tasync def finalize_order(order_id: str, data: Annotated[RequestData[FinalizeOrderPayload], Depends(SignedRequest(FinalizeOrderPayload))]):\n\t    async with db.transaction(readonly=True) as sql:\n", "        record = await sql.record(\"\"\"\n\t            select status, expires_at, expires_at <= now() as is_expired from orders ord\n\t            where ord.id = $1 and ord.account_id = $2\n\t        \"\"\", order_id, data.account_id)\n\t    if not record:\n\t        raise ACMEException(status_code=status.HTTP_404_NOT_FOUND, type='malformed', detail='Unknown order for specified account.', new_nonce=data.new_nonce)\n\t    order_status, expires_at, is_expired = record\n\t    if order_status != 'ready':\n\t        raise ACMEException(status_code=status.HTTP_403_FORBIDDEN, type='orderNotReady', detail=f'order status is: {order_status}', new_nonce=data.new_nonce)\n\t    if is_expired:\n", "        async with db.transaction() as sql:\n\t            await sql.exec(\"\"\"\n\t                update orders set status='invalid', error=row('unauthorized','order expired') where id = $1 and status <> 'invalid'\n\t            \"\"\", order_id)\n\t            await sql.exec(\"update authorizations set status='expired' where order_id = $1\", order_id)\n\t        raise ACMEException(status_code=status.HTTP_403_FORBIDDEN, type='orderNotReady', detail='order expired', new_nonce=data.new_nonce)\n\t    else:\n\t        async with db.transaction() as sql:\n\t            await sql.exec(\"update orders set status='processing' where id = $1 and status = 'ready'\", order_id)\n\t    async with db.transaction(readonly=True) as sql:\n", "        records = [(authz_id, domain) async for authz_id, domain, *_ in sql(\"\"\"\n\t            select id, domain from authorizations where order_id = $1 and status = 'valid'\n\t        \"\"\", order_id)]\n\t    domains = [domain for authz_id, domain in records]\n\t    authz_ids = [authz_id for authz_id, domain in records]\n\t    csr_bytes = base64url_decode(data.payload.csr)\n\t    csr, csr_pem, subject_domain, san_domains = await check_csr(csr_bytes, ordered_domains=domains, new_nonce=data.new_nonce)\n\t    try:\n\t        signed_cert = await ca_service.sign_csr(csr, subject_domain, san_domains)\n\t        err = False\n", "    except ACMEException as e:\n\t        err = e\n\t    except Exception as e:\n\t        err = ACMEException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, type='serverInternal', detail=str(e), new_nonce=data.new_nonce)\n\t        logger.warning('sign csr failed (account: %s)', data.account_id, exc_info=True)\n\t    if err is False:\n\t        cert_sn = SerialNumberConverter.int2hex(signed_cert.cert.serial_number)\n\t        async with db.transaction() as sql:\n\t            not_valid_before, not_valid_after = await sql.record(\"\"\"\n\t                insert into certificates (serial_number, csr_pem, chain_pem, order_id, not_valid_before, not_valid_after)\n", "                values ($1, $2, $3, $4, $5, $6) returning not_valid_before, not_valid_after\n\t            \"\"\", cert_sn, csr_pem, signed_cert.cert_chain_pem, order_id, signed_cert.cert.not_valid_before, signed_cert.cert.not_valid_after)\n\t            order_status = await sql.value(\"\"\"\n\t                update orders set status='valid' where id = $1 and status='processing' returning status\n\t            \"\"\", order_id)\n\t    else:\n\t        cert_sn = not_valid_before = not_valid_after = None\n\t        async with db.transaction() as sql:\n\t            order_status = await sql.value(\"\"\"\n\t                update orders set status='invalid', error=row($2,$3) where id = $1 returning status\n", "            \"\"\", order_id, err.exc_type, err.detail)\n\t    return order_response(\n\t        status=order_status, expires_at=expires_at, domains=domains, authz_ids=authz_ids, order_id=order_id,\n\t        not_valid_before=not_valid_before, not_valid_after=not_valid_after, cert_serial_number=cert_sn, error=err\n\t    )\n"]}
{"filename": "app/acme/nonce/router.py", "chunked_list": ["from fastapi import APIRouter, Response\n\tfrom config import settings\n\tfrom .service import generate\n\tapi = APIRouter(tags=['acme:nonce'])\n\t@api.head('/new-nonce', status_code=200)\n\t@api.get('/new-nonce', status_code=204)\n\tasync def get_nonce(response: Response):\n\t    response.headers['Replay-Nonce'] = await generate()\n\t    response.headers['Cache-Control'] = 'no-store'\n\t    response.headers['Link'] = f'<{settings.external_url}/acme/directory>;rel=\"index\"'\n"]}
{"filename": "app/acme/nonce/service.py", "chunked_list": ["import secrets\n\tfrom fastapi import status\n\timport db\n\tfrom ..exceptions import ACMEException\n\tasync def generate() -> str:\n\t    nonce = secrets.token_urlsafe(32)\n\t    async with db.transaction() as sql:\n\t        await sql.exec('insert into nonces (id) values ($1)', nonce)\n\t    return nonce\n\tasync def refresh(nonce: str) -> str:\n", "    new_nonce = secrets.token_urlsafe(32)\n\t    async with db.transaction() as sql:\n\t        old_nonce_ok = await sql.exec('delete from nonces where id = $1', nonce) == 'DELETE 1'\n\t        await sql.exec('insert into nonces (id) values ($1)', new_nonce)\n\t    if not old_nonce_ok:\n\t        raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='badNonce', detail='old nonce is worng', new_nonce=new_nonce)\n\t    return new_nonce\n"]}
{"filename": "app/acme/nonce/cronjob.py", "chunked_list": ["import asyncio\n\timport db\n\tfrom logger import logger\n\tasync def start():\n\t    async def run():\n\t        while True:\n\t            try:\n\t                async with db.transaction() as sql:\n\t                    await sql.exec('delete from nonces where expires_at < now()')\n\t            except Exception:\n", "                logger.error('could not purge old nonces', exc_info=True)\n\t            finally:\n\t                await asyncio.sleep(1 * 60 * 60)\n\t    asyncio.create_task(run())\n"]}
{"filename": "app/acme/account/router.py", "chunked_list": ["import secrets\n\tfrom typing import Annotated, Literal, Optional\n\tfrom fastapi import APIRouter, Depends, Response, status\n\tfrom pydantic import BaseModel, conlist, constr\n\timport db\n\timport mail\n\tfrom config import settings\n\tfrom logger import logger\n\tfrom ..exceptions import ACMEException\n\tfrom ..middleware import RequestData, SignedRequest\n", "tosAgreedType = Literal[True] if settings.acme.terms_of_service_url else bool\n\tcontactType = conlist(\n\t    constr(strip_whitespace=True, to_lower=True, regex=f'^mailto:{settings.acme.mail_target_regex.pattern}$'),\n\t    min_items=1, max_items=1\n\t)\n\tclass NewOrViewAccountPayload(BaseModel):\n\t    contact: list[str] = None\n\t    termsOfServiceAgreed: bool = None\n\t    onlyReturnExisting: bool = False\n\tclass NewAccountPayload(BaseModel):\n", "    contact: contactType\n\t    termsOfServiceAgreed: tosAgreedType = None\n\t    onlyReturnExisting: Literal[False] = False\n\t    @property\n\t    def mail_addr(self) -> str:\n\t        return self.contact[0].removeprefix('mailto:')\n\tclass UpdateAccountPayload(BaseModel):\n\t    status: Optional[Literal['deactivated']]\n\t    contact: Optional[contactType]\n\t    @property\n", "    def mail_addr(self) -> str | None:\n\t        if self.contact:\n\t            return self.contact[0].removeprefix('mailto:')\n\tapi = APIRouter(tags=['acme:account'])\n\t@api.post('/new-account')\n\tasync def create_or_view_account(\n\t    response: Response,\n\t    data: Annotated[RequestData[NewOrViewAccountPayload], Depends(SignedRequest(NewOrViewAccountPayload, allow_new_account=True))]\n\t):\n\t    \"\"\"\n", "    https://www.rfc-editor.org/rfc/rfc8555.html#section-7.3\n\t    \"\"\"\n\t    jwk_json: dict = data.key.export(as_dict=True)\n\t    async with db.transaction() as sql:\n\t        result = await sql.record(\n\t            'select id, mail, status from accounts where jwk=$1 and (id=$2 or $2::text is null)',\n\t            jwk_json, data.account_id)\n\t    account_exists = bool(result)\n\t    if account_exists:\n\t        account_id, account_status, mail_addr = result['id'], result['status'], result['mail']\n", "    else:\n\t        if data.payload.onlyReturnExisting:\n\t            raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='accountDoesNotExist', detail='Account does not exist', new_nonce=data.new_nonce)\n\t        else:  # create new account\n\t            # NewAccountPayload contains more checks than NewOrViewAccountPayload\n\t            payload = NewAccountPayload(**data.payload.dict())\n\t            mail_addr = payload.mail_addr\n\t            account_id = secrets.token_urlsafe(16)\n\t            async with db.transaction() as sql:\n\t                account_status = await sql.value(\"\"\"\n", "                    insert into accounts (id, mail, jwk) values ($1, $2, $3)\n\t                    returning status\n\t                \"\"\", account_id, mail_addr, jwk_json)\n\t            try:\n\t                await mail.send_new_account_info_mail(mail_addr)\n\t            except Exception:\n\t                logger.error('could not send new account mail to \"%s\"', mail_addr, exc_info=True)\n\t    response.status_code = 200 if account_exists else 201\n\t    response.headers['Location'] = f'{settings.external_url}/acme/accounts/{account_id}'\n\t    return {\n", "        'status': account_status,\n\t        'contact': ['mailto:' + mail_addr],\n\t        'orders': f'{settings.external_url}/acme/accounts/{account_id}/orders'\n\t    }\n\t@api.post('/key-change')\n\tasync def change_key(data: Annotated[RequestData, Depends(SignedRequest())]):\n\t    raise ACMEException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, type='serverInternal', detail='not implemented', new_nonce=data.new_nonce)  # todo\n\t@api.post('/accounts/{acc_id}')\n\tasync def view_or_update_account(\n\t        acc_id: str,\n", "        data: Annotated[RequestData[UpdateAccountPayload],\n\t                        Depends(SignedRequest(UpdateAccountPayload, allow_blocked_account=True))]\n\t):\n\t    if acc_id != data.account_id:\n\t        raise ACMEException(status_code=status.HTTP_403_FORBIDDEN, type='unauthorized', detail='wrong kid', new_nonce=data.new_nonce)\n\t    if data.payload.contact:\n\t        async with db.transaction() as sql:\n\t            await sql.exec(\"update accounts set mail=$1 where id = $2 and status = 'valid'\", data.payload.mail_addr, acc_id)\n\t        try:\n\t            await mail.send_new_account_info_mail(data.payload.mail_addr)\n", "        except Exception:\n\t            logger.error('could not send new account mail to \"%s\"', data.payload.mail_addr, exc_info=True)\n\t    if data.payload.status == 'deactivated':  # https://www.rfc-editor.org/rfc/rfc8555#section-7.3.6\n\t        async with db.transaction() as sql:\n\t            await sql.exec(\"update accounts set status='deactivated' where id = $1\", acc_id)\n\t            await sql.exec(\"\"\"\n\t                update orders set status='invalid', error=row('unauthorized','account deactived') where account_id = $1 and status <> 'invalid'\n\t            \"\"\", acc_id)\n\t    async with db.transaction(readonly=True) as sql:\n\t        account_status, mail_addr = await sql.record('select status, mail from accounts where id = $1', acc_id)\n", "    return {\n\t        'status': account_status,\n\t        'contact': ['mailto:' + mail_addr],\n\t        'orders': f'{settings.external_url}/acme/accounts/{acc_id}/orders'\n\t    }\n\t@api.post('/accounts/{acc_id}/orders', tags=['acme:order'])\n\tasync def view_orders(acc_id: str, data: Annotated[RequestData, Depends(SignedRequest())]):\n\t    if acc_id != data.account_id:\n\t        raise ACMEException(status_code=status.HTTP_403_FORBIDDEN, type='unauthorized', detail='wrong account id provided', new_nonce=data.new_nonce)\n\t    async with db.transaction(readonly=True) as sql:\n", "        orders = [order_id async for order_id, *_ in sql(\"select id from orders where account_id = $1 and status <> 'invalid'\", acc_id)]\n\t    return {\n\t        'orders': [f'{settings.external_url}/acme/orders/{order_id}' for order_id in orders]\n\t    }\n"]}
{"filename": "app/acme/certificate/router.py", "chunked_list": ["from typing import Annotated, Optional\n\tfrom fastapi import APIRouter, Depends, Header, Response, status\n\tfrom jwcrypto.common import base64url_decode\n\tfrom pydantic import BaseModel, constr\n\timport db\n\tfrom ca import service as ca_service\n\tfrom ..exceptions import ACMEException\n\tfrom ..middleware import RequestData, SignedRequest\n\tfrom .service import SerialNumberConverter, parse_cert\n\tclass RevokeCertPayload(BaseModel):\n", "    certificate: constr(min_length=1, max_length=1 * 1024**2)\n\t    reason: Optional[int]  # not evaluated\n\tapi = APIRouter(tags=['acme:certificate'])\n\t@api.post('/certificates/{serial_number}', response_class=Response, responses={\n\t    200: {'content': {'application/pem-certificate-chain': {}}}\n\t})\n\tasync def download_cert(\n\t    response: Response, serial_number: constr(regex='^[0-9A-F]+$'),\n\t    data: Annotated[RequestData, Depends(SignedRequest())],\n\t    accept: str = Header(default='*/*', regex=r'(application/pem\\-certificate\\-chain|\\*/\\*)', description='Certificates are only supported as \"application/pem-certificate-chain\"')\n", "):\n\t    async with db.transaction(readonly=True) as sql:\n\t        pem_chain = await sql.value(\"\"\"\n\t            select cert.chain_pem from certificates cert\n\t            join orders ord on cert.order_id = ord.id\n\t            where cert.serial_number = $1 and ord.account_id = $2\n\t        \"\"\", serial_number, data.account_id)\n\t    if not pem_chain:\n\t        raise ACMEException(status_code=status.HTTP_404_NOT_FOUND, type='malformed', detail='specified certificate not found for current account', new_nonce=data.new_nonce)\n\t    return Response(content=pem_chain, headers=response.headers, media_type='application/pem-certificate-chain')\n", "@api.post('/revoke-cert')\n\tasync def revoke_cert(data: Annotated[RequestData[RevokeCertPayload], Depends(SignedRequest(RevokeCertPayload, allow_new_account=True))]):\n\t    \"\"\"\n\t    https://www.rfc-editor.org/rfc/rfc8555#section-7.6\n\t    \"\"\"\n\t    # this request might use account id or the account public key\n\t    jwk_json: dict = data.key.export(as_dict=True)\n\t    cert_bytes = base64url_decode(data.payload.certificate)\n\t    cert = await parse_cert(cert_bytes)\n\t    serial_number = SerialNumberConverter.int2hex(cert.serial_number)\n", "    async with db.transaction(readonly=True) as sql:\n\t        ok = await sql.value(\"\"\"\n\t            select true from certificates c\n\t                join orders o on o.id = c.order_id\n\t                join accounts a on a.id = o.account_id\n\t            where\n\t                c.serial_number = $1 and c.revoked_at is null and\n\t                ($2::text is null or (a.id = $2::text and a.status='valid')) and a.jwk=$3\n\t        \"\"\", serial_number, data.account_id, jwk_json)\n\t    if not ok:\n", "        raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='alreadyRevoked', detail='cert already revoked or not accessible', new_nonce=data.new_nonce)\n\t    async with db.transaction(readonly=True) as sql:\n\t        revocations = [(sn, rev_at) async for sn, rev_at in sql('select serial_number, revoked_at from certificates where revoked_at is not null')]\n\t        revoked_at = await sql.value('select now()')\n\t    revocations = set(revocations)\n\t    revocations.add((serial_number, revoked_at))\n\t    await ca_service.revoke_cert(serial_number=serial_number, revocations=revocations)\n\t    async with db.transaction() as sql:\n\t        await sql.exec(\"\"\"\n\t            update certificates set revoked_at = $2 where serial_number = $1 and revoked_at is null\n", "        \"\"\", serial_number, revoked_at)\n"]}
{"filename": "app/acme/certificate/service.py", "chunked_list": ["import asyncio\n\tfrom cryptography import x509\n\tfrom cryptography.hazmat.primitives import serialization\n\tfrom fastapi import status\n\tfrom ..exceptions import ACMEException\n\tclass SerialNumberConverter:\n\t    @staticmethod\n\t    def int2hex(number: int):\n\t        return hex(number)[2:].upper()\n\t    @staticmethod\n", "    def hex2int(number: str):\n\t        return int(number, 16)\n\tasync def check_csr(csr_der: bytes, ordered_domains: list[str], new_nonce: str = None):\n\t    \"\"\"\n\t    check csr and return contained values\n\t    \"\"\"\n\t    csr = await asyncio.to_thread(x509.load_der_x509_csr, csr_der)\n\t    csr_pem_job = asyncio.to_thread(csr.public_bytes, serialization.Encoding.PEM)\n\t    if not csr.is_signature_valid:\n\t        raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='badCSR', detail='invalid signature', new_nonce=new_nonce)\n", "    sans = csr.extensions.get_extension_for_oid(\n\t        x509.oid.ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n\t    ).value.get_values_for_type(x509.DNSName)\n\t    csr_domains = set(sans)\n\t    subject_candidates = csr.subject.get_attributes_for_oid(x509.oid.NameOID.COMMON_NAME)\n\t    if subject_candidates:\n\t        subject_domain = subject_candidates[0].value\n\t        csr_domains.add(subject_domain)\n\t    elif not sans:\n\t        raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='badCSR', detail='subject and SANs cannot be both empty', new_nonce=new_nonce)\n", "    else:\n\t        subject_domain = sans[0]\n\t    if csr_domains != set(ordered_domains):\n\t        raise ACMEException(status_code=status.HTTP_400_BAD_REQUEST, type='badCSR', detail='domains in CSR does not match validated domains in ACME order', new_nonce=new_nonce)\n\t    csr_pem: str = (await csr_pem_job).decode()\n\t    return csr, csr_pem, subject_domain, csr_domains\n\tasync def parse_cert(cert_der: bytes):\n\t    cert = await asyncio.to_thread(x509.load_der_x509_certificate, cert_der)\n\t    return cert\n"]}
{"filename": "app/acme/certificate/cronjob.py", "chunked_list": ["import asyncio\n\timport db\n\timport mail\n\tfrom config import settings\n\tfrom logger import logger\n\tasync def start():\n\t    async def run():\n\t        while True:\n\t            try:\n\t                async with db.transaction(readonly=True) as sql:\n", "                    results = [record async for record in sql(\"\"\"\n\t                        with\n\t                            expiring_domains as (\n\t                                select authz.domain, acc.mail, cert.serial_number, cert.not_valid_after from certificates cert\n\t                                    join orders ord on cert.order_id = ord.id\n\t                                    join accounts acc on ord.account_id = acc.id\n\t                                    join authorizations authz on authz.order_id = ord.id\n\t                                where acc.status = 'valid' and ord.status = 'valid' and cert.revoked_at is null and (\n\t                                    ($1::interval is not null and cert.not_valid_after > now() and cert.not_valid_after < now() + $1 and not cert.user_informed_cert_will_expire)\n\t                                    or\n", "                                    (cert.not_valid_after < now() and not cert.user_informed_cert_has_expired)\n\t                                )\n\t                                order by authz.domain\n\t                            ),\n\t                            newest_domains as (\n\t                                select authz.domain, max(cert.not_valid_after) as not_valid_after from orders ord\n\t                                    join authorizations authz on authz.order_id = ord.id\n\t                                    join certificates cert on cert.order_id = ord.id\n\t                                    join expiring_domains exp on exp.domain = authz.domain\n\t                                group by authz.domain\n", "                            )\n\t                        select expd.mail, expd.serial_number, expd.not_valid_after, expd.not_valid_after < now() as is_expired, array_agg(expd.domain) as domains\n\t                            from expiring_domains expd\n\t                            join newest_domains newd on expd.domain = newd.domain and expd.not_valid_after = newd.not_valid_after\n\t                        group by expd.mail, expd.serial_number, expd.not_valid_after\n\t                            having array_length(array_agg(expd.domain), 1) > 0\n\t                    \"\"\", settings.mail.warn_before_cert_expires)]\n\t                for mail_addr, serial_number, expires_at, is_expired, domains in results:\n\t                    if not is_expired and settings.mail.warn_before_cert_expires:\n\t                        try:\n", "                            await mail.send_certs_will_expire_warn_mail(receiver=mail_addr, domains=domains, expires_at=expires_at, serial_number=serial_number)\n\t                            ok = True\n\t                        except Exception:\n\t                            logger.error('could not send_certs_will_expire_warn_mail for \"%s\"', mail_addr, exc_info=True)\n\t                            ok = False\n\t                        if ok:\n\t                            async with db.transaction() as sql:\n\t                                await sql.exec('update certificates set user_informed_cert_will_expire=true where serial_number=$1', serial_number)\n\t                    if is_expired and settings.mail.notify_when_cert_expired:\n\t                        try:\n", "                            await mail.send_certs_expired_info_mail(receiver=mail_addr, domains=domains, expires_at=expires_at, serial_number=serial_number)\n\t                            ok = True\n\t                        except Exception:\n\t                            logger.error('could not send_certs_expired_info_mail for \"%s\"', mail_addr, exc_info=True)\n\t                            ok = False\n\t                        if ok:\n\t                            async with db.transaction() as sql:\n\t                                await sql.exec('update certificates set user_informed_cert_has_expired=true where serial_number=$1', serial_number)\n\t            except Exception:\n\t                logger.error('could not inform about expiring certificates', exc_info=True)\n", "            finally:\n\t                await asyncio.sleep(1 * 60 * 60)\n\t    if settings.mail.notify_when_cert_expired or settings.mail.warn_before_cert_expires:\n\t        asyncio.create_task(run())\n"]}
{"filename": "app/db/__init__.py", "chunked_list": ["import json\n\tfrom typing import Any\n\timport asyncpg\n\tfrom pydantic import BaseModel\n\tfrom config import settings\n\tfrom logger import logger\n\t_pool: asyncpg.pool.Pool = None\n\tasync def connect():\n\t    global _pool\n\t    _pool = await asyncpg.create_pool(min_size=0, max_size=20, dsn=settings.db_dsn, init=init_connection, server_settings={'application_name': settings.web.app_title})\n", "async def disconnect():\n\t    global _pool\n\t    await _pool.close()\n\tasync def init_connection(conn: asyncpg.Connection):\n\t    await conn.set_type_codec('jsonb', encoder=_encode_json, decoder=json.loads, schema='pg_catalog')\n\tdef _encode_json(payload: Any) -> str:\n\t    if isinstance(payload, BaseModel):\n\t        return payload.json()\n\t    else:\n\t        return json.dumps(payload)\n", "class transaction:\n\t    readonly = False\n\t    def __init__(self, readonly=False) -> None:\n\t        self.readonly = readonly\n\t    async def __aenter__(self, *args, **kwargs):\n\t        self.conn: asyncpg.Connection = await _pool.acquire()\n\t        self.trans: asyncpg.connection.transaction = self.conn.transaction(readonly=self.readonly)\n\t        await self.trans.start()\n\t        return self\n\t    async def __call__(self, *args):\n", "        \"\"\"fetch response for query\"\"\"\n\t        async for rec in self.conn.cursor(*args):\n\t            yield rec\n\t    async def record(self, *args):\n\t        \"\"\"fetch first response row for query\"\"\"\n\t        return await self.conn.fetchrow(*args)\n\t    async def value(self, *args):\n\t        \"\"\"fetch first value from frist response row for query\"\"\"\n\t        return await self.conn.fetchval(*args)\n\t    async def exec(self, *args):  # noqa: A003 (allow shadowing builtin \"type\")\n", "        \"\"\"execute command\"\"\"\n\t        return await self.conn.execute(*args)\n\t    async def execmany(self, command: str, *args):\n\t        \"\"\"execute command with many records\"\"\"\n\t        return await self.conn.executemany(command, args)\n\t    async def __aexit__(self, exc_type, exc_val, exc_tb):\n\t        if exc_type:\n\t            logger.debug('Transaction rollback. Reason: %s %s', exc_type, exc_val, exc_tb)\n\t            await self.trans.rollback()\n\t        else:\n", "            await self.trans.commit()\n\t        await _pool.release(self.conn)\n"]}
{"filename": "app/db/migrations/__init__.py", "chunked_list": ["from pathlib import Path\n\timport db\n\tfrom logger import logger\n\tasync def run():\n\t    async with db.transaction() as sql:\n\t        await sql.exec(\"\"\"\n\t            create table if not exists migrations (\n\t                dummy_id integer unique default 1 check (dummy_id = 1), -- there should only be one row\n\t                migration int not null default 0,\n\t                migrated_at timestamptz not null default now()\n", "            );\n\t            insert into migrations (migration) values (default) on conflict do nothing;\n\t        \"\"\")\n\t        dirty = False\n\t        while True:\n\t            cur_level = await sql.value('select migration from migrations')\n\t            next_level = cur_level + 1\n\t            cur_file = Path('db/migrations') / f'{cur_level:0>3}.sql'\n\t            next_file = Path('db/migrations') / f'{next_level:0>3}.sql'\n\t            if not next_file.is_file():\n", "                break\n\t            logger.info(f'Running migration: {next_file.name}')\n\t            with open(next_file) as f:\n\t                await sql.exec(f.read())\n\t            await sql.exec('update migrations set migration=$1', next_level)\n\t            dirty = True\n\t        if dirty:\n\t            logger.info(f'Finished database migrations (current level: {cur_file.name})')\n\t        else:\n\t            logger.info(f'Database migrations are up to date (current level: {cur_file.name})')\n"]}
{"filename": "app/mail/__init__.py", "chunked_list": ["from datetime import datetime\n\tfrom email.mime.text import MIMEText\n\tfrom typing import Literal\n\tfrom aiosmtplib import SMTP\n\tfrom jinja2 import Environment, FileSystemLoader\n\tfrom config import settings\n\tfrom logger import logger\n\ttemplate_engine = Environment(loader=FileSystemLoader('mail/templates'), enable_async=True, autoescape=True)\n\tdefault_params = {\n\t    'app_title': settings.web.app_title,\n", "    'app_desc': settings.web.app_description,\n\t    'web_url': settings.external_url,\n\t    'acme_url': settings.external_url + '/acme/directory'\n\t}\n\tTemplates = Literal[\n\t    'cert-expired-info', 'cert-expires-warning', 'new-account-info']\n\tasync def send_mail(receiver: str, template: Templates, subject_vars: dict = None, body_vars: dict = None):\n\t    subject_vars = subject_vars or {}\n\t    subject_vars.update(**default_params)\n\t    body_vars = body_vars or {}\n", "    body_vars.update(**default_params)\n\t    subject_job = template_engine.get_template(template + '/subject.txt')\\\n\t        .render_async(subject_vars)\n\t    body_job = template_engine.get_template(template + '/body.html')\\\n\t        .render_async(body_vars)\n\t    message = MIMEText(await body_job, 'html', 'utf-8')\n\t    message['From'] = settings.mail.sender\n\t    message['To'] = receiver\n\t    message['Subject'] = await subject_job\n\t    if settings.mail.enabled:\n", "        auth = {}\n\t        if settings.mail.username and settings.mail.password:\n\t            auth = {'username': settings.mail.username, 'password': settings.mail.password.get_secret_value()}\n\t        async with SMTP(\n\t            hostname=settings.mail.host, port=settings.mail.port, **auth,\n\t            use_tls=settings.mail.encryption == 'tls', start_tls=settings.mail.encryption == 'starttls'\n\t        ) as client:\n\t            await client.send_message(message)\n\t    else:\n\t        logger.debug('sending mails is disabled, not sending: ' + str(message))\n", "async def send_new_account_info_mail(receiver: str):\n\t    await send_mail(receiver, 'new-account-info')\n\tasync def send_certs_will_expire_warn_mail(*, receiver: str, domains: list[str], expires_at: datetime, serial_number: str):\n\t    await send_mail(receiver, 'cert-expires-warning', body_vars={\n\t        'domains': domains,\n\t        'expires_at': expires_at,\n\t        'serial_number': serial_number,\n\t        'expires_in_days': (expires_at.replace(tzinfo=None) - datetime.utcnow()).days\n\t    })\n\tasync def send_certs_expired_info_mail(*, receiver: str, domains: list[str], expires_at: datetime, serial_number: str):\n", "    await send_mail(receiver, 'cert-expired-info', body_vars={\n\t        'domains': domains,\n\t        'expires_at': expires_at,\n\t        'serial_number': serial_number\n\t    })\n"]}
{"filename": "app/web/router.py", "chunked_list": ["from typing import Literal\n\tfrom fastapi import APIRouter, HTTPException, Response, status\n\tfrom fastapi.responses import HTMLResponse\n\tfrom jinja2 import Environment, FileSystemLoader\n\tfrom pydantic import constr\n\timport db\n\tfrom config import settings\n\ttemplate_engine = Environment(loader=FileSystemLoader('web/templates'), enable_async=True, autoescape=True)\n\tdefault_params = {\n\t    'app_title': settings.web.app_title,\n", "    'app_desc': settings.web.app_description,\n\t    'web_url': settings.external_url,\n\t    'acme_url': settings.external_url + '/acme/directory',\n\t}\n\tapi = APIRouter(tags=['web'])\n\t@api.get('/', response_class=HTMLResponse)\n\tasync def index():\n\t    return await template_engine.get_template('index.html').render_async(**default_params)\n\tif settings.web.enable_public_log:\n\t    @api.get('/certificates', response_class=HTMLResponse)\n", "    async def certificate_log():\n\t        async with db.transaction(readonly=True) as sql:\n\t            certs = [record async for record in sql(\"\"\"\n\t                select\n\t                    serial_number, not_valid_before, not_valid_after, revoked_at,\n\t                    (not_valid_after > now() and revoked_at is null) as is_valid,\n\t                    (not_valid_after - not_valid_before) as lifetime,\n\t                    (now() - not_valid_before) as age,\n\t                    array((select domain from authorizations authz where authz.order_id = cert.order_id order by domain)) as domains\n\t                from certificates cert\n", "                group by serial_number\n\t                order by not_valid_after desc\n\t            \"\"\")]\n\t        return await template_engine.get_template('cert-log.html').render_async(**default_params, certs=certs)\n\t    @api.get('/certificates/{serial_number}', response_class=Response, responses={\n\t        200: {'content': {'application/pem-certificate-chain': {}}}\n\t    })\n\t    async def download_certificate(serial_number: constr(regex='^[0-9A-F]+$')):\n\t        async with db.transaction(readonly=True) as sql:\n\t            pem_chain = await sql.value('select chain_pem from certificates where serial_number = $1', serial_number)\n", "        if not pem_chain:\n\t            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='unknown certificate')\n\t        return Response(content=pem_chain, media_type='application/pem-certificate-chain')\n\t    @api.get('/domains', response_class=HTMLResponse)\n\t    async def domain_log(domainfilter: str = '', status: Literal['all', 'valid', 'invalid'] = 'all'):\n\t        async with db.transaction(readonly=True) as sql:\n\t            domains = [record async for record in sql(\"\"\"\n\t                with data as (\n\t                    select\n\t                        authz.domain as domain_name,\n", "                        min(cert.not_valid_before) as first_requested_at,\n\t                        max(cert.not_valid_after) as expires_at,\n\t                        (max(cert.not_valid_after) FILTER (WHERE revoked_at is null)) > now() AS is_valid\n\t                    from orders ord\n\t                    join authorizations authz on authz.order_id = ord.id\n\t                    join certificates cert on cert.order_id = ord.id\n\t                    where ($1::text = '' or authz.domain ilike '%' || $1::text || '%')\n\t                    group by authz.domain\n\t                )\n\t                select * from data\n", "                where ($2 = 'all' or ($2 = 'valid' and is_valid) or ($2 = 'invalid' and not is_valid))\n\t                order by domain_name\n\t            \"\"\", domainfilter.replace('*', '%'), status)]\n\t        return await template_engine.get_template('domain-log.html').render_async(**default_params, domains=domains, status=status, domainfilter=domainfilter)\n\telse:\n\t    @api.get('/certificates')\n\t    async def certificate_log():\n\t        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail='This page is disabled')\n\t    @api.get('/domains')\n\t    async def domain_log():\n", "        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail='This page is disabled')\n"]}
{"filename": "app/web/__init__.py", "chunked_list": ["from . import middleware  # noqa: F401 (import required as module export)\n\tfrom . import router as router_module\n\trouter = router_module.api\n"]}
{"filename": "app/web/middleware.py", "chunked_list": ["from fastapi import FastAPI, Request, Response\n\tfrom starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint\n\tclass SecurityHeadersMiddleware(BaseHTTPMiddleware):\n\t    \"\"\"Add security headers to all responses.\"\"\"\n\t    def __init__(self, app: FastAPI, *,\n\t                 content_security_policy: dict[str, str] = None,\n\t                 permissions_policy: dict[str, str] = None\n\t                 ) -> None:\n\t        super().__init__(app)\n\t        self.csp = content_security_policy\n", "        self.pp = permissions_policy\n\t    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:\n\t        \"\"\"Dispatch of the middleware.\n\t        :param request: Incoming request\n\t        :param call_next: Function to process the request\n\t        :return: Return response coming from processed request\n\t        \"\"\"\n\t        headers = {\n\t            'Cross-Origin-Opener-Policy': 'same-origin',\n\t            'Referrer-Policy': 'strict-origin-when-cross-origin',\n", "            'X-Content-Type-Options': 'nosniff',\n\t            'X-Frame-Options': 'DENY',\n\t            'X-XSS-Protection': '1; mode=block',\n\t            'Strict-Transport-Security': 'max-age=31536000',\n\t        }\n\t        if self.csp:\n\t            matches = [\n\t                path for path in self.csp.keys() if request.url.path.startswith(path)]\n\t            if matches:\n\t                best_match = sorted(matches, key=len, reverse=True)[0]\n", "                headers['Content-Security-Policy'] = self.csp[best_match]\n\t        if self.pp:\n\t            matches = [\n\t                path for path in self.pp.keys() if request.url.path.startswith(path)]\n\t            if matches:\n\t                best_match = sorted(matches, key=len, reverse=True)[0]\n\t                headers['Permissions-Policy'] = self.pp[best_match]\n\t        response = await call_next(request)\n\t        response.headers.update(headers)\n\t        return response\n"]}
