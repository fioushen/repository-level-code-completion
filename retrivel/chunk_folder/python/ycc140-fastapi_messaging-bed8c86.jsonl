{"filename": "__init__.py", "chunked_list": []}
{"filename": "OrderService/run.py", "chunked_list": ["#!/usr/bin/env python\n\t# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-20 22:57:08\n\t     $Rev: 24\n", "\"\"\"\n\t# Third party modules\n\timport uvicorn\n\t# Local modules\n\tfrom src.web.main import app\n\tif __name__ == \"__main__\":\n\t    uv_config = {'app': 'src.web.main:app', 'port': 8000,\n\t                 'log_level': app.level, 'reload': True,\n\t                 'log_config': {\"disable_existing_loggers\": False, \"version\": 1}}\n\t    uvicorn.run(**uv_config)\n"]}
{"filename": "OrderService/queue_test_sender.py", "chunked_list": ["#!/usr/bin/env python\n\t# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-25 00:01:55\n\t     $Rev: 41\n", "\"\"\"\n\t# BUILTIN modules\n\timport asyncio\n\t# Local modules\n\tfrom src.config.setup import config\n\tfrom src.tools.rabbit_client import RabbitClient\n\t# Constants\n\tSERVICE = 'TestService'\n\tCLIENT = RabbitClient(config.rabbit_url)\n\t# ---------------------------------------------------------\n", "#\n\tasync def sender():\n\t    for idx in range(1, 11):\n\t        msg = {\"title\": f\"message no {idx}\"}\n\t        await CLIENT.send_message(msg, SERVICE)\n\t        print(f'Sent message: {msg}')\n\t# ---------------------------------------------------------\n\tif __name__ == \"__main__\":\n\t    asyncio.run(sender())\n"]}
{"filename": "OrderService/redis_order_viewer.py", "chunked_list": ["#!/usr/bin/env python\n\t# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-25 00:01:55\n\t     $Rev: 41\n", "\"\"\"\n\t# BUILTIN modules\n\timport json\n\timport asyncio\n\timport argparse\n\tfrom pprint import pprint\n\t# Third party modules\n\tfrom aioredis import from_url\n\t# Local modules\n\tfrom src.config.setup import config\n", "# ---------------------------------------------------------\n\t#\n\tasync def viewer(args: argparse.Namespace):\n\t    \"\"\" Show cached Redis order.\n\t    :param args: Command line arguments.\n\t    \"\"\"\n\t    client = from_url(config.redis_url)\n\t    if response := await client.get(args.order_id):\n\t        pprint(json.loads(response.decode()), width=120)\n\t    else:\n", "        print(f'NOT CACHED: {args.order_id}')\n\t# ---------------------------------------------------------\n\tif __name__ == \"__main__\":\n\t    Form = argparse.ArgumentDefaultsHelpFormatter\n\t    description = 'A utility script that let you view cached order data.'\n\t    parser = argparse.ArgumentParser(description=description, formatter_class=Form)\n\t    parser.add_argument(\"order_id\", type=str, help=\"Specify Order ID\")\n\t    arguments = parser.parse_args()\n\t    asyncio.run(viewer(arguments))\n"]}
{"filename": "OrderService/__init__.py", "chunked_list": []}
{"filename": "OrderService/queue_test_receiver.py", "chunked_list": ["#!/usr/bin/env python\n\t# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-25 00:01:55\n\t     $Rev: 41\n", "\"\"\"\n\t# BUILTIN modules\n\timport asyncio\n\timport contextlib\n\t# Local modules\n\tfrom src.config.setup import config\n\tfrom src.tools.rabbit_client import RabbitClient\n\t# Constants\n\tSERVICE = 'TestService'\n\t# ---------------------------------------------------------\n", "#\n\tasync def process_incoming_message(message: dict):\n\t    print(f'Received: {message}')\n\t# ---------------------------------------------------------\n\t#\n\tasync def receiver():\n\t    print('Started RabbitMQ message queue subscription...')\n\t    client = RabbitClient(config.rabbit_url, SERVICE, process_incoming_message)\n\t    connection = await asyncio.create_task(client.consume())\n\t    try:\n", "        # Wait until terminate\n\t        await asyncio.Future()\n\t    finally:\n\t        await connection.close()\n\t# ---------------------------------------------------------\n\tif __name__ == \"__main__\":\n\t    with contextlib.suppress(KeyboardInterrupt):\n\t        asyncio.run(receiver())\n"]}
{"filename": "OrderService/db_url_creator.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-24 23:50:19\n\t     $Rev: 40\n\t\"\"\"\n", "# BUILTIN modules\n\timport asyncio\n\t# Local modules\n\tfrom src.repository.db import Engine\n\t# Constants\n\tURLS = {'CustomerService': 'http://127.0.0.1:8002',\n\t        'DeliveryService': 'http://127.0.0.1:8003',\n\t        'KitchenService': 'http://127.0.0.1:8004',\n\t        'PaymentService': 'http://127.0.0.1:8001'}\n\t# ---------------------------------------------------------\n", "#\n\tasync def creator():\n\t    \"\"\" Insert URL in api_db.service_urls collection.\n\t    Drop the collection if it already exists, before the insertion.\n\t    \"\"\"\n\t    await Engine.connect_to_mongo()\n\t    await Engine.db.service_urls.drop()\n\t    print(\"Dropped api_db.service_urls collection.\")\n\t    response = [{'_id': key, 'url': item} for key, item in URLS.items()]\n\t    await Engine.db.service_urls.insert_many(response)\n", "    result = await Engine.db.service_urls.count_documents({})\n\t    print(result, \"MicroService URLs are inserted in api_db.service_urls.\")\n\t    await Engine.close_mongo_connection()\n\t# ---------------------------------------------------------\n\tif __name__ == \"__main__\":\n\t    asyncio.run(creator())\n"]}
{"filename": "OrderService/redis_url_cleaner.py", "chunked_list": ["#!/usr/bin/env python\n\t# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-25 00:01:55\n\t     $Rev: 41\n", "\"\"\"\n\t# BUILTIN modules\n\timport asyncio\n\t# Third party modules\n\tfrom aioredis import from_url\n\t# Local modules\n\tfrom src.config.setup import config\n\t# Constants\n\tURLS = {'PaymentService': 'http://127.0.0.1:8001',\n\t        'KitchenService': 'http://127.0.0.1:8004',\n", "        'DeliveryService': 'http://127.0.0.1:8003',\n\t        'CustomerService': 'http://127.0.0.1:8002'}\n\t# ---------------------------------------------------------\n\t#\n\tasync def cleaner():\n\t    client = from_url(config.redis_url)\n\t    for key in URLS:\n\t        await client.delete(key)\n\t# ---------------------------------------------------------\n\tif __name__ == \"__main__\":\n", "    asyncio.run(cleaner())\n"]}
{"filename": "OrderService/response_test_sender.py", "chunked_list": ["#!/usr/bin/env python\n\t# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-25 00:01:55\n\t     $Rev: 41\n", "\"\"\"\n\t# BUILTIN modules\n\timport asyncio\n\timport argparse\n\t# Local modules\n\tfrom src.config.setup import config\n\tfrom src.tools.rabbit_client import RabbitClient\n\t# Constants\n\tPAYLOAD = {\n\t    \"DeliveryService\": {\n", "        \"delivery_id\": \"76d019f-5937-4a14-8091-1d9f18666c93\",\n\t        \"metadata\":\n\t            {\n\t                \"receiver\": \"OrderService\",\n\t                \"customer_id\": \"f2861560-e9ed-4463-955f-0c55c3b416fb\"\n\t            }\n\t    },\n\t    \"KitchenService\": {\n\t        \"kitchen_id\": \"b4d7bb48-7b56-45c8-9eb3-dc6e96c09172\",\n\t        \"metadata\":\n", "            {\n\t                \"receiver\": \"OrderService\",\n\t                \"customer_id\": \"f2861560-e9ed-4463-955f-0c55c3b416fb\"\n\t            }\n\t    }\n\t}\n\t\"\"\" Service response payload messages. \"\"\"\n\t# ---------------------------------------------------------\n\t#\n\tdef _build_message(pid: int, order_id: str) -> dict:\n", "    \"\"\" Build response message\n\t    :param pid: Payload ID\n\t    :param order_id: Order ID\n\t    :return: response message.\n\t    \"\"\"\n\t    message = None\n\t    match pid:\n\t        case 1:\n\t            message = PAYLOAD['DeliveryService']\n\t            message['status'] = 'driverAvailable'\n", "        case 2:\n\t            message = PAYLOAD['KitchenService']\n\t            message['status'] = 'cookingMeal'\n\t        case 3:\n\t            message = PAYLOAD['KitchenService']\n\t            message['status'] = 'cookingDone'\n\t        case 4:\n\t            message = PAYLOAD['KitchenService']\n\t            message['status'] = 'pickedUp'\n\t        case 5:\n", "            message = PAYLOAD['DeliveryService']\n\t            message['status'] = 'inTransit'\n\t        case 6:\n\t            message = PAYLOAD['DeliveryService']\n\t            message['status'] = 'delivered'\n\t    message['metadata']['order_id'] = order_id\n\t    return message\n\t# ---------------------------------------------------------\n\t#\n\tasync def sender(args: argparse.Namespace):\n", "    \"\"\" Send RabbitMQ payload test message.\n\t    :param args: Command line arguments.\n\t    \"\"\"\n\t    client = RabbitClient(config.rabbit_url)\n\t    message = _build_message(args.pid, args.order_id)\n\t    await client.send_message(message, message['metadata']['receiver'])\n\t    print(f\"message sent to '{message['metadata']['receiver']}'\\n{message}\")\n\t# ---------------------------------------------------------\n\tif __name__ == \"__main__\":\n\t    Form = argparse.ArgumentDefaultsHelpFormatter\n", "    description = 'A utility script that let you start the app choosing topic or queue handling.'\n\t    parser = argparse.ArgumentParser(description=description, formatter_class=Form)\n\t    parser.add_argument(\"order_id\", type=str, help=\"Specify Order ID\")\n\t    parser.add_argument(\"pid\", type=int, choices=list(range(1, 7)),\n\t                        help=\"Specify payload ID\")\n\t    arguments = parser.parse_args()\n\t    asyncio.run(sender(arguments))\n"]}
{"filename": "OrderService/src/tools/rabbit_client.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-30 17:41:49\n\t     $Rev: 50\n\t\"\"\"\n", "# BUILTIN modules\n\timport asyncio\n\tfrom typing import Callable, Optional\n\t# Third party modules\n\timport ujson as json\n\tfrom aio_pika import connect, connect_robust, Message, DeliveryMode\n\tfrom aio_pika.abc import AbstractIncomingMessage, AbstractRobustConnection\n\t# -----------------------------------------------------------------------------\n\t#\n\tclass RabbitClient:\n", "    \"\"\" This class handles the communication with the RabbitMQ server.\n\t    Note: the queue mechanism is implemented to take advantage of good\n\t    horizontal message scaling when needed.\n\t    Both Publisher and Consumer async handling is implemented.\n\t    \"\"\"\n\t    rabbit_url: str = None\n\t    # ---------------------------------------------------------\n\t    #\n\t    def __init__(self, rabbit_url: str, service: Optional[str] = None,\n\t                 incoming_message_handler: Optional[Callable] = None):\n", "        \"\"\" The class initializer.\n\t        :param rabbit_url: RabbitMQ's connection string.\n\t        :param service: Name of receiving service (when using consume).\n\t        :param incoming_message_handler: Incoming message callback method.\n\t        \"\"\"\n\t        # Unique parameters.\n\t        self.rabbit_url = rabbit_url\n\t        self.service_name = service\n\t        self.message_handler = incoming_message_handler\n\t    # ---------------------------------------------------------\n", "    #\n\t    async def _process_incoming_message(self, message: AbstractIncomingMessage):\n\t        \"\"\" Processing incoming message from RabbitMQ.\n\t        :param message: Received message.\n\t        \"\"\"\n\t        if body := message.body:\n\t            await self.message_handler(json.loads(body))\n\t        await message.ack()\n\t    # ---------------------------------------------------------\n\t    #\n", "    async def consume(self) -> AbstractRobustConnection:\n\t        \"\"\" Setup message listener with the current running asyncio loop. \"\"\"\n\t        loop = asyncio.get_running_loop()\n\t        # Perform receive connection.\n\t        connection = await connect_robust(loop=loop, url=self.rabbit_url)\n\t        # Creating receive channel and setting quality of service.\n\t        channel = await connection.channel()\n\t        # To make sure the load is evenly distributed between the workers.\n\t        await channel.set_qos(1)\n\t        # Creating a receive queue.\n", "        queue = await channel.declare_queue(name=self.service_name, durable=True)\n\t        # Start consumption of existing and future messages.\n\t        await queue.consume(self._process_incoming_message, no_ack=False)\n\t        return connection\n\t    # ---------------------------------------------------------\n\t    #\n\t    @classmethod\n\t    async def send_message(cls, message: dict, queue: str):\n\t        \"\"\" Send message to RabbitMQ Publisher queue.\n\t        If the topic is defined, topic message routing is used, otherwise\n", "        queue message routing is used.\n\t        :param message: Message to be sent.\n\t        :param queue: Message queue to use for message sending.\n\t        :raise AssertionError: Parameters 'topic' and 'queue' are mutually exclusive.\n\t        \"\"\"\n\t        connection = await connect(url=cls.rabbit_url)\n\t        channel = await connection.channel()\n\t        message_body = Message(\n\t            content_type='application/json',\n\t            body=json.dumps(message, ensure_ascii=False).encode(),\n", "            delivery_mode=DeliveryMode.PERSISTENT)\n\t        await channel.default_exchange.publish(\n\t            routing_key=queue, message=message_body)\n"]}
{"filename": "OrderService/src/tools/custom_logging.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-25 17:47:36\n\t     $Rev: 42\n\t\"\"\"\n", "# BUILTIN modules\n\timport sys\n\timport logging\n\tfrom typing import cast\n\tfrom types import FrameType\n\t# Third party modules\n\tfrom loguru import logger\n\t# ---------------------------------------------------------\n\t#\n\tclass InterceptHandler(logging.Handler):\n", "    \"\"\" Logs to loguru from Python logging module. \"\"\"\n\t    def emit(self, record: logging.LogRecord):\n\t        try:\n\t            level = logger.level(record.levelname).name\n\t        except ValueError:\n\t            level = str(record.levelno)\n\t        frame, depth = logging.currentframe(), 2\n\t        while frame.f_code.co_filename == logging.__file__:\n\t            frame = cast(FrameType, frame.f_back)\n\t            depth += 1\n", "        logger.opt(\n\t            depth=depth,\n\t            exception=record.exc_info).log(\n\t            level,\n\t            record.getMessage()\n\t        )\n\t# ---------------------------------------------------------\n\t#\n\tdef create_unified_logger(log_level: str) -> tuple:\n\t    \"\"\" Return unified Loguru logger object.\n", "    :return: unified Loguru logger object.\n\t    \"\"\"\n\t    level = log_level\n\t    # Remove all existing loggers.\n\t    logger.remove()\n\t    # Create a basic Loguru logging config.\n\t    logger.add(\n\t        diagnose=True,\n\t        backtrace=True,\n\t        sink=sys.stderr,\n", "        level=level.upper(),\n\t    )\n\t    # Prepare to incorporate python standard logging.\n\t    seen = set()\n\t    logging.basicConfig(handlers=[InterceptHandler()], level=0)\n\t    for logger_name in logging.root.manager.loggerDict.keys():\n\t        if logger_name not in seen:\n\t            seen.add(logger_name.split(\".\")[0])\n\t            mod_logger = logging.getLogger(logger_name)\n\t            mod_logger.handlers = [InterceptHandler(level=level.upper())]\n", "            mod_logger.propagate = False\n\t    return level, logger.bind(request_id=None, method=None)\n"]}
{"filename": "OrderService/src/business/response_handler.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-04-01 17:51:19\n\t     $Rev: 55\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom uuid import UUID\n\t# Third party modules\n\tfrom loguru import logger\n\tfrom httpx import AsyncClient, ConnectTimeout\n\t# Local modules\n\tfrom ..config.setup import config\n\tfrom ..repository.url_cache import UrlCache\n\tfrom .schemas import KitchenPayload, DeliveryPayload\n\tfrom ..repository.order_data_adapter import OrdersRepository\n", "from ..repository.models import Status, OrderModel, StateUpdateSchema\n\t# ------------------------------------------------------------------------\n\t#\n\tclass OrderResponseLogic:\n\t    \"\"\"\n\t    This class implements the OrderService business logic layer\n\t    for RabbitMQ response messages.\n\t    \"\"\"\n\t    # ---------------------------------------------------------\n\t    #\n", "    def __init__(self, cache: UrlCache, repository: OrdersRepository):\n\t        \"\"\" The class initializer.\n\t        :param repository: Data layer handler object.\n\t        \"\"\"\n\t        self.cache = cache\n\t        self.repo = repository\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def _update_order_in_db(self, order: OrderModel):\n\t        \"\"\" Update Order in DB.\n", "        :param order: Current Order.\n\t        \"\"\"\n\t        successful = await self.repo.update(order)\n\t        if not successful:\n\t            errmsg = f\"Failed updating {order.id=} in api_db.orders\"\n\t            raise RuntimeError(errmsg)\n\t        log = getattr(logger, ('error' if order.status == 'paymentFailed' else 'info'))\n\t        log(f'Stored {order.status=} in DB for {order.id=}.')\n\t    # ---------------------------------------------------------\n\t    #\n", "    async def _handle_successful_payment(self, message: dict, order: OrderModel):\n\t        \"\"\" Payment was successful so get Customer Address and request DeliveryService work.\n\t        :param message: PaymentService response message.\n\t        :param order: Current Order.\n\t        \"\"\"\n\t        try:\n\t            root = await self.cache.get('CustomerService')\n\t            # Get Customer Address information.\n\t            async with AsyncClient() as client:\n\t                service = 'CustomerService'\n", "                url = f\"{root}/v1/customers/{order.customer_id}/address\"\n\t                resp = await client.get(url=url, timeout=config.url_timeout)\n\t            if resp.status_code != 200:\n\t                errmsg = f\"Failed {service} POST request for URL {url} - \" \\\n\t                         f\"[{resp.status_code}: {resp.json()['detail']}].\"\n\t                raise RuntimeError(errmsg)\n\t            payload = DeliveryPayload(metadata=message['metadata'],\n\t                                      address=resp.json(), **order.dict())\n\t            root = await self.cache.get('DeliveryService')\n\t            # Request DeliveryService work.\n", "            async with AsyncClient() as client:\n\t                service = 'DeliveryService'\n\t                url = f\"{root}/v1/deliveries\"\n\t                resp = await client.post(url=url, json=payload.dict(),\n\t                                         timeout=config.url_timeout)\n\t            if resp.status_code != 202:\n\t                errmsg = f\"Failed {service} POST request for URL {url} - \" \\\n\t                         f\"[{resp.status_code}: {resp.json()['detail']}].\"\n\t                raise RuntimeError(errmsg)\n\t            data = resp.json()\n", "            order.status = data['status']\n\t            order.delivery_id = data['delivery_id']\n\t            order.updated.append(StateUpdateSchema(status=order.status))\n\t            await self._update_order_in_db(order)\n\t        except ConnectTimeout:\n\t            errmsg = f'No connection with {service} on URL {url}'\n\t            raise ConnectionError(errmsg)\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def _handle_delivery_ready(self, message: dict, order: OrderModel):\n", "        \"\"\" Delivery is ready for pickup so request KitchenService work.\n\t        :param message: DeliveryService metadata response message.\n\t        :param order: Current Order.\n\t        \"\"\"\n\t        payload = KitchenPayload(metadata=message['metadata'], **order.dict())\n\t        try:\n\t            root = await self.cache.get('KitchenService')\n\t            # Request KitchenService work.\n\t            async with AsyncClient() as client:\n\t                url = f\"{root}/v1/kitchen\"\n", "                resp = await client.post(url=url, json=payload.dict(),\n\t                                         timeout=config.url_timeout)\n\t            if resp.status_code != 202:\n\t                errmsg = f\"Failed KitchenService POST request for URL {url} \" \\\n\t                         f\"- [{resp.status_code}: {resp.json()['detail']}].\"\n\t                raise RuntimeError(errmsg)\n\t            data = resp.json()\n\t            order.status = data['status']\n\t            order.kitchen_id = data['kitchen_id']\n\t            order.updated.append(StateUpdateSchema(status=order.status))\n", "            await self._update_order_in_db(order)\n\t        except ConnectTimeout:\n\t            errmsg = f'No connection with KitchenService on URL {url}'\n\t            raise ConnectionError(errmsg)\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def process_response(self, message: dict):\n\t        \"\"\" Process response message data.\n\t        Implemented business logic:\n\t          - Every received message state is updated in DB.\n", "          - When status is 'paymentPaid':\n\t              - Trigger DeliveryService work.\n\t          - When status is 'driverAvailable':\n\t              - Trigger KitchenService work.\n\t        :param message: Response message data.\n\t        \"\"\"\n\t        status = message['status']\n\t        order_id = UUID(message['metadata']['order_id'])\n\t        try:\n\t            # Read specified Order from DB.\n", "            order = await self.repo.read(order_id)\n\t            if not order:\n\t                raise RuntimeError(f'{order_id=} is unknown')\n\t            order.status = status\n\t            order.updated.append(StateUpdateSchema(status=order.status))\n\t            await self._update_order_in_db(order)\n\t            if status == Status.PAID:\n\t                await self._handle_successful_payment(message, order)\n\t            elif status == Status.DRAV:\n\t                await self._handle_delivery_ready(message, order)\n", "        except RuntimeError as why:\n\t            logger.error(f'{why}')\n\t        except ConnectionError as why:\n\t            logger.critical(f'{why}')\n\t        except BaseException as why:\n\t            logger.critical(f'Failed processing response {status=} => {why}')\n"]}
{"filename": "OrderService/src/business/schemas.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-04-02 14:01:36\n\t     $Rev: 57\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom uuid import UUID\n\t# Third party modules\n\tfrom pydantic import BaseModel, validator\n\t# Local modules\n\tfrom ..repository.models import OrderItems, Status\n\t# ---------------------------------------------------------\n\t#\n\tclass MetadataSchema(BaseModel):\n\t    \"\"\" Representation of Order metadata in the system. \"\"\"\n", "    receiver: str\n\t    order_id: str\n\t    customer_id: str\n\t    @validator('*', pre=True)\n\t    def decode_values(cls, value):\n\t        \"\"\" Decode UUID value into a str. \"\"\"\n\t        return str(value) if isinstance(value, UUID) else value\n\t# ---------------------------------------------------------\n\t#\n\tclass PaymentPayload(OrderItems):\n", "    \"\"\" Representation of a payment payload in the system. \"\"\"\n\t    metadata: MetadataSchema\n\t# ---------------------------------------------------------\n\t#\n\tclass PaymentResponse(BaseModel):\n\t    \"\"\" Representation of a payment response in the system. \"\"\"\n\t    metadata: MetadataSchema\n\t    status: Status\n\t# ---------------------------------------------------------\n\t#\n", "class KitchenPayload(OrderItems):\n\t    \"\"\" Representation of a Kitchen payload in the system. \"\"\"\n\t    metadata: MetadataSchema\n\t# ---------------------------------------------------------\n\t#\n\tclass CustomerAddressSchema(BaseModel):\n\t    \"\"\" Representation of Customer Address Information in the system. \"\"\"\n\t    name: str\n\t    city: str\n\t    street: str\n", "    zipcode: str\n\t# ---------------------------------------------------------\n\t#\n\tclass DeliveryPayload(OrderItems):\n\t    \"\"\" Representation of a Delivery payload in the system. \"\"\"\n\t    metadata: MetadataSchema\n\t    address: CustomerAddressSchema\n"]}
{"filename": "OrderService/src/business/request_handler.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-30 13:14:04\n\t     $Rev: 48\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom datetime import datetime\n\tfrom typing import Optional, List\n\t# Third party modules\n\tfrom pydantic import UUID4\n\tfrom fastapi import HTTPException\n\tfrom httpx import AsyncClient, ConnectTimeout\n\t# Local modules\n\tfrom ..config.setup import config\n\tfrom ..repository.url_cache import UrlCache\n", "from ..web.api.schemas import OrderResponse\n\tfrom .schemas import PaymentPayload, MetadataSchema\n\tfrom ..repository.order_data_adapter import OrdersRepository\n\tfrom ..repository.models import Status, OrderItems, OrderModel, StateUpdateSchema\n\t# ------------------------------------------------------------------------\n\t#\n\tclass OrderApiLogic:\n\t    \"\"\"\n\t    This class implements the OrderService web API business logic layer.\n\t    \"\"\"\n", "    # ---------------------------------------------------------\n\t    #\n\t    def __init__(\n\t            self,\n\t            id: UUID4,\n\t            created: datetime,\n\t            items: OrderItems,\n\t            repository: OrdersRepository,\n\t            updated: List[StateUpdateSchema],\n\t            status: Status, customer_id: UUID4,\n", "            kitchen_id: Optional[UUID4] = None,\n\t            delivery_id: Optional[UUID4] = None,\n\t    ):\n\t        \"\"\" The class initializer.\n\t        :param id: Order id.\n\t        :param created: Order created timestamp.\n\t        :param items: Ordered items.\n\t        :param status: Current order status.\n\t        :param customer_id: The individual that created the order.\n\t        :param kitchen_id: Does not exist before the scheduled state.\n", "        :param delivery_id: Does not exist before the dispatched state.\n\t        \"\"\"\n\t        self._id = id\n\t        self.items = items\n\t        self._status = status\n\t        self.updated = updated\n\t        self._created = created\n\t        self.kitchen_id = kitchen_id\n\t        self.delivery_id = delivery_id\n\t        self.customer_id = customer_id\n", "        # Initialize objects.\n\t        self.repo = repository\n\t        self.cache = UrlCache(config.redis_url)\n\t    # ---------------------------------------------------------\n\t    #\n\t    @property\n\t    def id(self) -> UUID4:\n\t        \"\"\" Return order id.\n\t        :return: order id.\n\t        \"\"\"\n", "        return self._id\n\t    # ---------------------------------------------------------\n\t    #\n\t    @property\n\t    def created(self) -> datetime:\n\t        \"\"\" Return current order creation time.\n\t        :return: datetime when the order was created.\n\t        \"\"\"\n\t        return self._created\n\t    # ---------------------------------------------------------\n", "    #\n\t    @property\n\t    def status(self) -> Status:\n\t        \"\"\" Return current order status.\n\t        :return: current status\n\t        \"\"\"\n\t        return self._status\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def _pay(self) -> None:\n", "        \"\"\" Trigger payment of ordered items.\n\t        :raise HTTPException [400]: when PaymentService response code != 202.\n\t        :raise HTTPException [500]: when connection with PaymentService failed.\n\t        \"\"\"\n\t        meta = MetadataSchema(order_id=self.id,\n\t                              customer_id=self.customer_id,\n\t                              receiver=f'{config.service_name}')\n\t        payment = PaymentPayload(metadata=meta, **self.dict())\n\t        try:\n\t            root = await self.cache.get('PaymentService')\n", "            async with AsyncClient() as client:\n\t                url = f\"{root}/v1/payments\"\n\t                response = await client.post(url=url,\n\t                                             json=payment.dict(),\n\t                                             timeout=config.url_timeout)\n\t            if response.status_code != 202:\n\t                errmsg = f\"Failed PaymentService POST request for URL {url} with Order ID \"  \\\n\t                         f\"{self.id} - [{response.status_code}: {response.json()['detail']}].\"\n\t                raise HTTPException(status_code=400, detail=errmsg)\n\t        except ConnectTimeout:\n", "            errmsg = f'No connection with PaymentService on URL {url}'\n\t            raise HTTPException(status_code=500, detail=errmsg)\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def _reimburse(self) -> None:\n\t        \"\"\" Trigger reimbursement of cancelled order items.\n\t        :raise HTTPException [400]: when PaymentService response code != 202.\n\t        :raise HTTPException [500]: when connection with PaymentService failed.\n\t        \"\"\"\n\t        meta = MetadataSchema(order_id=self.id,\n", "                              customer_id=self.customer_id,\n\t                              receiver=f'{config.service_name}')\n\t        payment = PaymentPayload(metadata=meta, **self.dict())\n\t        try:\n\t            root = await self.cache.get('PaymentService')\n\t            async with AsyncClient() as client:\n\t                url = f\"{root}/v1/payments/reimburse\"\n\t                response = await client.post(url=url,\n\t                                             json=payment.dict(),\n\t                                             timeout=config.url_timeout)\n", "            if response.status_code != 202:\n\t                errmsg = f\"Failed PaymentService POST request for URL {url} with Order ID \"  \\\n\t                         f\"{self.id} - [{response.status_code}: {response.json()['detail']}].\"\n\t                raise HTTPException(status_code=400, detail=errmsg)\n\t        except ConnectTimeout:\n\t            errmsg = f'No connection with PaymentService on URL {url}'\n\t            raise HTTPException(status_code=500, detail=errmsg)\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def create(self) -> OrderResponse:\n", "        \"\"\" Charge the Customers Credit Card and create a new order in DB.\n\t        :raise HTTPException [400]: when PaymentService response code != 202.\n\t        :raise HTTPException [500]: when connection with PaymentService failed.\n\t        :raise HTTPException [400]: when create order in DB api_db.orders failed.\n\t        \"\"\"\n\t        await self._pay()\n\t        # Create a new Order document in DB.\n\t        db_order = OrderModel(**self.dict())\n\t        successful = await self.repo.create(db_order)\n\t        if not successful:\n", "            errmsg = f\"Create failed for {self.id=} in api_db.orders\"\n\t            raise HTTPException(status_code=400, detail=errmsg)\n\t        return OrderResponse(**db_order.dict())\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def cancel(self) -> OrderResponse:\n\t        \"\"\" Cancel current order.\n\t        NOTE: this can only be done before a driver is available (status DRAV).\n\t        :raise HTTPException [400]: when cancel request came too late.\n\t        :raise HTTPException [400]: when Order update in DB api_db.orders failed.\n", "        \"\"\"\n\t        await self._reimburse()\n\t        if self.status != Status.DESC:\n\t            errmsg = f'Could not cancel order with id {self.id} and {self.status=}'\n\t            raise HTTPException(status_code=400, detail=errmsg)\n\t        # Prepare order update.\n\t        db_order = OrderModel(**self.dict())\n\t        db_order.status = Status.ORCA\n\t        db_order.updated.append(StateUpdateSchema(status=db_order.status))\n\t        # Update Order status in DB.\n", "        successful = await self.repo.update(db_order)\n\t        if not successful:\n\t            errmsg = f\"Failed updating {self.id=} in api_db.orders\"\n\t            raise HTTPException(status_code=400, detail=errmsg)\n\t        return OrderResponse(**db_order.dict())\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def delete(self) -> None:\n\t        \"\"\" Delete current order.\n\t        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n", "        \"\"\"\n\t        response = await self.repo.delete(self.id)\n\t        if response.deleted_count == 0:\n\t            errmsg = f\"{self.id=} not found in api_db.orders\"\n\t            raise HTTPException(status_code=404, detail=errmsg)\n\t    # ---------------------------------------------------------\n\t    #\n\t    def dict(self) -> dict:\n\t        \"\"\" Return essential class parameters using base class types.\n\t        :return: Base class types representation of the class.\n", "        \"\"\"\n\t        return {\n\t            'id': str(self.id),\n\t            'items': self.items,\n\t            'status': self.status,\n\t            'created': str(self.created),\n\t            'customer_id': str(self.customer_id),\n\t            'kitchen_id': (str(self.kitchen_id) if self.kitchen_id else None),\n\t            'delivery_id': (str(self.delivery_id) if self.delivery_id else None),\n\t            'updated': list(map(lambda elem: {'status': elem['status'],\n", "                                              'when': str(elem['when'])}, self.updated))}\n"]}
{"filename": "OrderService/src/repository/models.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-04-01 17:51:19\n\t     $Rev: 55\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom enum import Enum\n\tfrom uuid import uuid4\n\tfrom datetime import datetime\n\tfrom typing import Optional, Callable, List\n\t# Third party modules\n\tfrom pydantic import (BaseModel, BaseConfig,\n\t                      Field, UUID4, conlist, conint)\n\t# Local modules\n\tfrom .documentation import (order_documentation as order_doc)\n", "# ---------------------------------------------------------\n\t#\n\tclass Status(str, Enum):\n\t    \"\"\" Order status changes.\n\t    CREA -> PAID/FAIL -> DISC -> DRAV -> SHED -> COOK -> PROD -> PICK -> TRAN -> DONE\n\t    An Order can be cancelled before DRAV status has been reached (finding an available\n\t    driver sometimes take time, so the Customer is unwilling to wait any longer).\n\t    \"\"\"\n\t    CREA = 'created'            # OrderService\n\t    ORCA = 'orderCancelled'     # OrderService\n", "    PAID = 'paymentPaid'        # PaymentService\n\t    REIM = 'reimbursed'         # PaymentService\n\t    FAIL = 'paymentFailed'      # PaymentService\n\t    DESC = 'deliveryScheduled'  # DeliveryService\n\t    DRAV = 'driverAvailable'    # DeliveryService\n\t    SHED = 'cookingScheduled'   # KitchenService\n\t    COOK = 'cookingMeal'        # KitchenService\n\t    PROD = 'cookingDone'        # KitchenService\n\t    PICK = 'pickedUp'           # KitchenService\n\t    TRAN = 'inTransit'          # DeliveryService\n", "    DONE = 'delivered'          # DeliveryService\n\t# ---------------------------------------------------------\n\t#\n\tclass Products(str, Enum):\n\t    \"\"\" Representation of valid products in the system. \"\"\"\n\t    lasagna = 'Lasagna'\n\t    cheese_burger = 'Double Cheeseburger'\n\t    veil = 'Veil with glazed onions and blue cheese'\n\t    vego_salad = 'Vegetarian Salad with healthy produce'\n\tclass OrderItem(BaseModel):\n", "    \"\"\" Required order item parameters. \"\"\"\n\t    product: Products\n\t    quantity: Optional[conint(ge=1, strict=True)] = 1\n\tclass OrderItems(BaseModel):\n\t    \"\"\" A list of the ordered items. \"\"\"\n\t    items: conlist(OrderItem, min_items=1)\n\t# ------------------------------------------------------------------------\n\t#\n\tclass MongoBase(BaseModel):\n\t    \"\"\"\n", "    Class that handles conversions between MongoDB '_id' key\n\t    and our own 'id' key.\n\t    MongoDB uses `_id` as an internal default index key.\n\t    We can use that to our advantage.\n\t    \"\"\"\n\t    class Config(BaseConfig):\n\t        \"\"\" basic config. \"\"\"\n\t        orm_mode = True\n\t        allow_population_by_field_name = True\n\t    # noinspection PyArgumentList\n", "    @classmethod\n\t    def from_mongo(cls, data: dict) -> Callable:\n\t        \"\"\" Convert \"_id\" (str object) into \"id\" (UUID object). \"\"\"\n\t        if not data:\n\t            return data\n\t        mongo_id = data.pop('_id', None)\n\t        return cls(**dict(data, id=mongo_id))\n\t    def to_mongo(self, **kwargs) -> dict:\n\t        \"\"\" Convert \"id\" (UUID object) into \"_id\" (str object). \"\"\"\n\t        parsed = self.dict(**kwargs)\n", "        if '_id' not in parsed and 'id' in parsed:\n\t            parsed['_id'] = str(parsed.pop('id'))\n\t        return parsed\n\t# ---------------------------------------------------------\n\t#\n\tclass StateUpdateSchema(BaseModel):\n\t    \"\"\" Representation of an Order status history in the system. \"\"\"\n\t    status: Status = Field(**order_doc['status'])\n\t    when: datetime = Field(default_factory=datetime.utcnow, **order_doc['when'])\n\tclass OrderUpdateModel(MongoBase):\n", "    \"\"\" Representation of an Order in the system. \"\"\"\n\t    items: conlist(OrderItem, min_items=1)\n\t    customer_id: UUID4 = Field(**order_doc['customer_id'])\n\t    kitchen_id: Optional[UUID4] = Field(**order_doc['kitchen_id'])\n\t    delivery_id: Optional[UUID4] = Field(**order_doc['delivery_id'])\n\t    status: Status = Field(default=Status.CREA, **order_doc['status'])\n\t    updated: Optional[List[StateUpdateSchema]] = Field(**order_doc['updated'])\n\t    created: datetime = Field(default_factory=datetime.utcnow, **order_doc['created'])\n\tclass OrderModel(OrderUpdateModel):\n\t    \"\"\" Representation of an Order in the system. \"\"\"\n", "    id: UUID4 = Field(default_factory=uuid4)\n\t# ---------------------------------------------------------\n\t#\n\tdef dict_of(payload: OrderModel) -> dict:\n\t    \"\"\"  Return a dict representation of an OrderModel that json.dumps will accept.\n\t    All datatime and UUID objects are converted to str.\n\t    :param payload: Current Order object.\n\t    :return: Serializable dict representation of an Order.\n\t    \"\"\"\n\t    return {\n", "        key: (\n\t            # This row converts datetime values to str within a list of dicts.\n\t            list(map(lambda elem: {'status': elem['status'],\n\t                                   'when': str(elem['when'])}, value))\n\t            if key == 'updated'\n\t            # This row handles values that don't need a conversion.\n\t            else value if key in {'items', 'status'}\n\t            # This row converts all base (not in a structure) UUID and datetime values to str.\n\t            else str(value) if value else None)\n\t        # Iterate over all elements in the payload.\n", "        for key, value in payload.dict().items()}\n"]}
{"filename": "OrderService/src/repository/db.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-20 22:57:08\n\t     $Rev: 24\n\t\"\"\"\n", "# Third party modules\n\tfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase\n\t# Local program modules\n\tfrom ..config.setup import config\n\t# ---------------------------------------------------------\n\t#\n\tclass Engine:\n\t    \"\"\" MongoDb database async engine class.\n\t    :type db: C{motor.motor_asyncio.AsyncIOMotorDatabase}\n\t    :ivar db: AsyncIOMotorDatabase class instance.\n", "    :type connection: C{motor.motor_asyncio.AsyncIOMotorClient}\n\t    :ivar connection: AsyncIOMotorClient class instance.\n\t    \"\"\"\n\t    db: AsyncIOMotorDatabase = None\n\t    connection: AsyncIOMotorClient = None\n\t    # ---------------------------------------------------------\n\t    #\n\t    @classmethod\n\t    async def connect_to_mongo(cls):\n\t        \"\"\" Initialize DB connection to MongoDb and database.\n", "        Setting server connection timeout to 5 (default is 30) seconds.\n\t        \"\"\"\n\t        cls.connection = AsyncIOMotorClient(config.mongo_url,\n\t                                            uuidRepresentation='standard',\n\t                                            serverSelectionTimeoutMS=5000)\n\t        cls.db = cls.connection.api_db\n\t    # ---------------------------------------------------------\n\t    #\n\t    @classmethod\n\t    async def close_mongo_connection(cls):\n", "        \"\"\" Close DB connection. \"\"\"\n\t        cls.connection.close()\n"]}
{"filename": "OrderService/src/repository/documentation.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-21 22:20:47\n\t     $Rev: 27\n\t\"\"\"\n", "order_documentation = {\n\t    \"status\": {'description': 'Order workflow status.'},\n\t    \"updated\": {'example': [{\"`2023-03-10T12:15:23.123234`\", \"paymentPaid\"}],\n\t                'default': [], 'description': 'Order status change history.'},\n\t    \"when\": {'example': \"`2023-03-10T12:15:23.123234`\",\n\t             'description': 'Timestamp for the Order status change.'},\n\t    \"created\": {'example': \"`2023-03-10T12:15:23.123234`\",\n\t                'description': 'Timestamp when the Order was created.'},\n\t    \"id\": {'example': \"`dbb86c27-2eed-410d-881e-ad47487dd228`\",\n\t           'description': '**Order ID**: A unique identifier for an existing Order.'},\n", "    \"kitchen_id\": {'default': None, 'example': 'b76d019f-5937-4a14-8091-1d9f18666c93',\n\t                   'description': 'Kitchen ID for the Order meal being produced.'},\n\t    \"delivery_id\": {'default': None, 'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n\t                    'description': 'Delivery ID for the Order during delivered.'},\n\t    \"customer_id\": {'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n\t                    'description': 'Customer ID for the person that created the Order.'},\n\t}\n"]}
{"filename": "OrderService/src/repository/url_cache.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-24 23:18:27\n\t     $Rev: 38\n\t\"\"\"\n", "# Third party modules\n\tfrom aioredis import from_url\n\t# Local modules\n\tfrom .db import Engine\n\t# Constants\n\tEXPIRE = 60*60*24\n\t\"\"\" Redis keys expire after 24h. \"\"\"\n\t# ------------------------------------------------------------------------\n\t#\n\tclass UrlCache:\n", "    \"\"\" This class handles Redis URL cache.\n\t    Is automatically populated from MongoDB api_db.service_urls collection.\n\t    \"\"\"\n\t    # ---------------------------------------------------------\n\t    #\n\t    def __init__(self, url: str):\n\t        \"\"\"  The class initializer.\n\t        :param url: Redis connection URL.\n\t        \"\"\"\n\t        self.client = from_url(url)\n", "    # ---------------------------------------------------------\n\t    #\n\t    async def get(self, key: str) -> str:\n\t        \"\"\" Get MicroService URL from Redis.\n\t        Populate from MongoDB api_db.service_urls collection if needed.\n\t        All URL Keys expire after 24h in the cache.\n\t        :param key: MicroService name.\n\t        :return: MicroService URL.\n\t        \"\"\"\n\t        value = await self.client.get(key)\n", "        if not value:\n\t            value = await Engine.db.service_urls.find_one({\"_id\": key})\n\t            await self.client.set(key, value['url'], ex=EXPIRE)\n\t        return value.decode() if isinstance(value, bytes) else value['url']\n"]}
{"filename": "OrderService/src/repository/order_data_adapter.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-24 23:18:27\n\t     $Rev: 38\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom typing import List\n\t# Third party modules\n\timport ujson\n\tfrom pydantic import UUID4\n\tfrom aioredis import from_url\n\tfrom pymongo import DESCENDING\n\tfrom pymongo.results import DeleteResult\n\t# Local modules\n\tfrom .db import Engine\n", "from ..config.setup import config\n\tfrom .models import OrderModel, OrderUpdateModel, dict_of\n\t# Constants\n\tEXPIRE = 60*30\n\t\"\"\" Order objects expire after 30 minutes. \"\"\"\n\t# ------------------------------------------------------------------------\n\t#\n\tclass OrdersRepository:\n\t    \"\"\" This class implements the data layer adapter (the CRUD operations).\n\t    The Order object is cached in Redis. This is handled by the read, update\n", "    and delete methods.\n\t    \"\"\"\n\t    client = from_url(config.redis_url)\n\t    # ---------------------------------------------------------\n\t    #\n\t    @staticmethod\n\t    async def _read(key: UUID4) -> OrderModel:\n\t        \"\"\" Read Order for matching index key from DB collection api_db.orders.\n\t        :param key: Index key.\n\t        :return: Found Order.\n", "        \"\"\"\n\t        response = await Engine.db.orders.find_one({\"_id\": str(key)})\n\t        return OrderModel.from_mongo(response)\n\t    # ---------------------------------------------------------\n\t    #\n\t    @staticmethod\n\t    async def _update(payload: OrderModel) -> bool:\n\t        \"\"\" Update Order in DB collection api_db.orders.\n\t        :param payload: Updated Order payload.\n\t        :return: DB update result.\n", "        \"\"\"\n\t        base = OrderUpdateModel(**payload.dict()).to_mongo()\n\t        response = await Engine.db.orders.update_one({\"_id\": str(payload.id)},\n\t                                                     {\"$set\": {**base}})\n\t        return response.raw_result['updatedExisting']\n\t    # ---------------------------------------------------------\n\t    #\n\t    @staticmethod\n\t    async def connection_info() -> dict:\n\t        \"\"\" Return DB connection information.\n", "        :return: DB connection information.\n\t        \"\"\"\n\t        return await Engine.connection.server_info()\n\t    # ---------------------------------------------------------\n\t    #\n\t    @staticmethod\n\t    async def create(payload: OrderModel) -> bool:\n\t        \"\"\" Create Order in DB collection api_db.orders.\n\t        :param payload: New Order payload.\n\t        :return: DB create result.\n", "        \"\"\"\n\t        response = await Engine.db.orders.insert_one(payload.to_mongo())\n\t        return response.acknowledged\n\t    # ---------------------------------------------------------\n\t    #\n\t    @staticmethod\n\t    async def read_all() -> List[OrderModel]:\n\t        \"\"\" Read all existing Orders in DB collection api_db.orders.\n\t        Sorted on creation timestamp in descending order.\n\t        :return: List of found Orders.\n", "        \"\"\"\n\t        result = []\n\t        async for item in Engine.db.orders.find({}).sort('created', DESCENDING):\n\t            result.append(OrderModel.from_mongo(item))\n\t        return result\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def read(self, key: UUID4) -> OrderModel:\n\t        \"\"\"\n\t        Read Order for matching index key from the cache. If it does not exist\n", "        there, read it from DB collection api_db.orders and update the cache.\n\t        :param key: Index key.\n\t        :return: Found Order.\n\t        \"\"\"\n\t        value = await self.client.get(str(key))\n\t        if not value:\n\t            payload = await self._read(key)\n\t            value = ujson.dumps(dict_of(payload))\n\t            await self.client.set(str(key), value, ex=EXPIRE)\n\t        return OrderModel(**ujson.loads(value))\n", "    # ---------------------------------------------------------\n\t    #\n\t    async def update(self, payload: OrderModel) -> bool:\n\t        \"\"\" Update Order in DB collection api_db.orders and in the cache.\n\t        :param payload: Updated Order payload.\n\t        :return: DB update result.\n\t        \"\"\"\n\t        response = await self._update(payload)\n\t        if response:\n\t            value = ujson.dumps(dict_of(payload))\n", "            await self.client.set(str(payload.id), value, ex=EXPIRE)\n\t        return response\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def delete(self, key: UUID4) -> DeleteResult:\n\t        \"\"\"\n\t        Delete Order for matching index key from DB collection api_db.orders\n\t        and the cache.\n\t        :param key: Index key.\n\t        :return: DB delete result.\n", "        \"\"\"\n\t        response = await Engine.db.orders.delete_one({\"_id\": str(key)})\n\t        if response.deleted_count == 1:\n\t            await self.client.delete(str(key))\n\t        return response\n"]}
{"filename": "OrderService/src/config/setup.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-04-01 21:09:57\n\t     $Rev: 56\n\t\"\"\"\n", "# BUILTIN modules\n\timport site\n\t# Third party modules\n\tfrom dotenv import load_dotenv\n\tfrom pydantic import BaseSettings\n\t# Constants\n\tMISSING_SECRET = '>>> missing SECRETS file <<<'\n\t\"\"\" Error message for missing secrets file. \"\"\"\n\tMISSING_ENV = '>>> missing ENV value <<<'\n\t\"\"\" Error message for missing values in the .env file. \"\"\"\n", "# ---------------------------------------------------------\n\t#\n\tclass Configuration(BaseSettings):\n\t    \"\"\" Configuration parameters. \"\"\"\n\t    # OpenAPI documentation.\n\t    name: str = MISSING_ENV\n\t    version: str = MISSING_ENV\n\t    # Service parameters.\n\t    service_name: str = MISSING_ENV\n\t    service_log_level: str = MISSING_ENV\n", "    # External resource parameters.\n\t    url_timeout: tuple = (1.0, 5.0)\n\t    mongo_url: str = MISSING_SECRET\n\t    redis_url: str = MISSING_SECRET\n\t    rabbit_url: str = MISSING_SECRET\n\t    # Handles both local and Docker environments.\n\t    class Config:\n\t        secrets_dir = f'{site.USER_BASE}/secrets'\n\t# ---------------------------------------------------------\n\t# Note that the \".env\" file is always implicitly loaded.\n", "load_dotenv()\n\tconfig = Configuration()\n\t\"\"\" Configuration parameters instance. \"\"\"\n"]}
{"filename": "OrderService/src/web/main.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-30 17:38:58\n\t     $Rev: 49\n\t\"\"\"\n", "# BUILTIN modules\n\timport asyncio\n\tfrom pathlib import Path\n\tfrom contextlib import asynccontextmanager\n\t# Third party modules\n\tfrom fastapi import FastAPI\n\tfrom fastapi.responses import JSONResponse\n\tfrom fastapi.staticfiles import StaticFiles\n\t# Local modules\n\tfrom .api import api\n", "from ..config.setup import config\n\tfrom ..repository.db import Engine\n\tfrom .health_manager import HealthManager\n\tfrom ..repository.url_cache import UrlCache\n\tfrom ..tools.custom_logging import create_unified_logger\n\tfrom ..business.response_handler import OrderResponseLogic\n\tfrom .api.documentation import (servers, license_info,\n\t                                tags_metadata, description)\n\tfrom ..repository.order_data_adapter import OrdersRepository\n\tfrom .api.schemas import HealthSchema, ValidStatus, HealthStatusError\n", "from ..tools.rabbit_client import AbstractRobustConnection, RabbitClient\n\t# ---------------------------------------------------------\n\t#\n\tclass Service(FastAPI):\n\t    connection: AbstractRobustConnection = None\n\t    def __init__(self, *args, **kwargs):\n\t        \"\"\" This class adds RabbitMQ message consumption and unified logging.\n\t        :param args: named arguments.\n\t        :param kwargs: key-value pair arguments.\n\t        \"\"\"\n", "        super().__init__(*args, **kwargs)\n\t        self.rabbit_client = RabbitClient(config.rabbit_url,\n\t                                          config.service_name,\n\t                                          self.process_response_message)\n\t        self.level, self.logger = create_unified_logger(\n\t            config.service_log_level\n\t        )\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def process_response_message(self, message: dict):\n", "        \"\"\" Send response message to a separate asyncio task for processing.\n\t        Note that the message is discarded when:\n\t          - required metadata structure is missing in the message.\n\t          - status is unknown.\n\t        :param message: MicroService response message.\n\t        \"\"\"\n\t        try:\n\t            if 'metadata' not in message:\n\t                raise RuntimeError('Message is discarded since it is '\n\t                                   'missing required metadata structure.')\n", "            # Verify that message status is valid.\n\t            ValidStatus(status=message.get('status'))\n\t            worker = OrderResponseLogic(repository=OrdersRepository(),\n\t                                        cache=UrlCache(config.redis_url))\n\t            await asyncio.create_task(worker.process_response(message))\n\t        except RuntimeError as why:\n\t            self.logger.error(f'{why}')\n\t        except ValueError as why:\n\t            raw = f'{why}'.split('\\n')\n\t            errmsg = ' '.join([item.split('(type=')[0].strip()\n", "                               for item in raw[1:]])\n\t            self.logger.error(f\"Message is discarded since {errmsg}.\")\n\t# ---------------------------------------------------------\n\t#\n\t@asynccontextmanager\n\tasync def lifespan(service: Service):\n\t    await startup(service)\n\t    yield\n\t    await shutdown(service)\n\t# ---------------------------------------------------------\n", "app = Service(\n\t    servers=servers,\n\t    lifespan=lifespan,\n\t    title=config.name,\n\t    version=config.version,\n\t    description=description,\n\t    license_info=license_info,\n\t    openapi_tags=tags_metadata,\n\t)\n\tapp.include_router(api.router)\n", "# Needed for OpenAPI Markdown images to be displayed.\n\tstatic_path = Path(__file__).parent.parent.parent.parent / 'design_docs'\n\tapp.mount(\"/static\", StaticFiles(directory=static_path))\n\t# ---------------------------------------------------------\n\t#\n\t@app.get(\n\t    '/health',\n\t    response_model=HealthSchema,\n\t    tags=[\"health check endpoint\"],\n\t    responses={500: {\"model\": HealthStatusError}},\n", ")\n\tasync def health_check() -> HealthSchema:\n\t    \"\"\" **Health check endpoint.** \"\"\"\n\t    content = await HealthManager(app.connection,\n\t                                  UrlCache(config.redis_url),\n\t                                  OrdersRepository()).get_status()\n\t    response_code = (200 if content.status else 500)\n\t    return JSONResponse(status_code=response_code, content=content.dict())\n\t# ---------------------------------------------------------\n\t#\n", "async def startup(service: Service):\n\t    \"\"\" Initialize RabbitMQ and DB connection. \"\"\"\n\t    service.logger.info('Establishing RabbitMQ message queue consumer...')\n\t    service.connection = await asyncio.create_task(\n\t        service.rabbit_client.consume()\n\t    )\n\t    service.logger.info('Establishing MongoDB connection...')\n\t    await Engine.connect_to_mongo()\n\t# ---------------------------------------------------------\n\t#\n", "async def shutdown(service: Service):\n\t    \"\"\" Close RabbitMQ and DB connection. \"\"\"\n\t    if service.connection:\n\t        service.logger.info('Disconnecting from RabbitMQ...')\n\t        await service.connection.close()\n\t    if Engine.connection:\n\t        service.logger.info('Disconnecting from MongoDB...')\n\t        await Engine.close_mongo_connection()\n"]}
{"filename": "OrderService/src/web/health_manager.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-23 19:52:08\n\t     $Rev: 36\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom typing import List\n\t# Third party modules\n\tfrom loguru import logger\n\tfrom httpx import AsyncClient, ConnectTimeout\n\t# local modules\n\tfrom ..config.setup import config\n\tfrom ..repository.url_cache import UrlCache\n\tfrom ..tools.rabbit_client import AbstractRobustConnection\n\tfrom ..web.api.schemas import ResourceSchema, HealthSchema\n", "from ..repository.order_data_adapter import OrdersRepository\n\t# Constants\n\tURLS = {'PaymentService', 'KitchenService',\n\t        'DeliveryService', 'CustomerService'}\n\t\"\"\" Used internal MicroService(s). \"\"\"\n\t# -----------------------------------------------------------------------------\n\t#\n\tclass HealthManager:\n\t    \"\"\" This class handles health status reporting on used resources. \"\"\"\n\t    # ---------------------------------------------------------\n", "    #\n\t    def __init__(self, connection: AbstractRobustConnection,\n\t                 cache: UrlCache, repository: OrdersRepository):\n\t        \"\"\" Class initializer.\n\t        :param cache: Redis URL cache.\n\t        :param repository: Data layer handler object.\n\t        :param connection: RabbitMQ's connection object.\n\t        \"\"\"\n\t        self.cache = cache\n\t        self.repo = repository\n", "        self.connection = connection\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def _get_mongo_status(self) -> List[ResourceSchema]:\n\t        \"\"\" Return MongoDb connection status.\n\t        :return: MongoDb connection status.\n\t        \"\"\"\n\t        try:\n\t            status = True\n\t            await self.repo.connection_info()\n", "        except BaseException as why:\n\t            logger.critical(f'MongoDB: {why}')\n\t            status = False\n\t        return [ResourceSchema(name='MongoDb', status=status)]\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def _get_rabbit_status(self) -> List[ResourceSchema]:\n\t        \"\"\" Return RabbitMQ connection status.\n\t        :return: RabbitMQ connection status.\n\t        \"\"\"\n", "        try:\n\t            status = not self.connection.is_closed\n\t        except BaseException as why:\n\t            logger.critical(f'RabbitMQ: {why}')\n\t            status = False\n\t        return [ResourceSchema(name='RabbitMQ', status=status)]\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def _get_service_status(self) -> List[ResourceSchema]:\n\t        \"\"\" Return RabbitMQ connection status.\n", "        :return: Service connection status.\n\t        \"\"\"\n\t        result = []\n\t        async with AsyncClient() as client:\n\t            for service in URLS:\n\t                try:\n\t                    root = await self.cache.get(service)\n\t                    url = f'{root}/health'\n\t                    status = False\n\t                    # Request used Microservice health status.\n", "                    response = await client.get(url=url, timeout=(1.0, 5.0))\n\t                    if response.status_code == 200:\n\t                        status = response.json()['status']\n\t                except ConnectTimeout:\n\t                    logger.critical(f'No connection with {service} on URL {url}')\n\t                result.append(ResourceSchema(name=service, status=status))\n\t        return result\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def get_status(self) -> HealthSchema:\n", "        \"\"\" Return Health status for used resources.\n\t        :return: Service health status.\n\t        \"\"\"\n\t        resource_items = []\n\t        resource_items += await self._get_mongo_status()\n\t        resource_items += await self._get_rabbit_status()\n\t        resource_items += await self._get_service_status()\n\t        total_status = all(key.status for key in resource_items)\n\t        return HealthSchema(status=total_status,\n\t                            version=config.version,\n", "                            name=config.service_name,\n\t                            resources=resource_items)\n"]}
{"filename": "OrderService/src/web/api/schemas.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-04-01 17:51:19\n\t     $Rev: 55\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom datetime import datetime\n\tfrom typing import Optional, List\n\t# Third party modules\n\tfrom pydantic import (BaseModel, Field, UUID4)\n\t# Local modules\n\tfrom ..api.documentation import resource_example\n\tfrom ...repository.models import Status, OrderItems\n\tfrom ...repository.documentation import order_documentation as order_doc\n\t# -----------------------------------------------------------------------------\n", "#\n\tclass NotFoundError(BaseModel):\n\t    \"\"\" Define model for a http 404 exception (Not Found). \"\"\"\n\t    detail: str = \"Order not found in DB\"\n\tclass FailedUpdateError(BaseModel):\n\t    \"\"\" Define model for a http 400 exception (Unprocessable Entity). \"\"\"\n\t    detail: str = \"Failed updating Order in DB\"\n\tclass ConnectError(BaseModel):\n\t    \"\"\" Define model for a http 500 exception (INTERNAL_SERVER_ERROR). \"\"\"\n\t    detail: str = \"Failed to connect to internal MicroService\"\n", "class HealthStatusError(BaseModel):\n\t    \"\"\" Define model for a http 500 exception (INTERNAL_SERVER_ERROR). \"\"\"\n\t    detail: str = \"HEALTH: resource connection(s) are down\"\n\t# ---------------------------------------------------------\n\t#\n\tclass OrderPayload(OrderItems):\n\t    \"\"\" Payload parameters required when creating an order. \"\"\"\n\t    customer_id: UUID4 = Field(**order_doc['customer_id'])\n\t# ---------------------------------------------------------\n\t#\n", "class OrderResponse(OrderItems):\n\t    \"\"\" Expected default order response parameters. \"\"\"\n\t    id: UUID4 = Field(**order_doc['id'])\n\t    status: Status = Field(**order_doc['status'])\n\t    created: datetime = Field(**order_doc['created'])\n\t    customer_id: UUID4 = Field(**order_doc['customer_id'])\n\t    kitchen_id: Optional[UUID4] = Field(**order_doc['kitchen_id'])\n\t    delivery_id: Optional[UUID4] = Field(**order_doc['delivery_id'])\n\t# ------------------------------------------------------------------------\n\t#\n", "class ValidStatus(BaseModel):\n\t    \"\"\" Used for validation of received status responses. \"\"\"\n\t    status: Status\n\t# -----------------------------------------------------------------------------\n\t#\n\tclass ResourceSchema(BaseModel):\n\t    \"\"\" Representation of a  health resources response.\n\t    :ivar name: Resource name.\n\t    :ivar status: Resource status\n\t    \"\"\"\n", "    name: str\n\t    status: bool\n\t# -----------------------------------------------------------------------------\n\t#\n\tclass HealthSchema(BaseModel):\n\t    \"\"\" Representation of a  health response.\n\t    :ivar name: Service name.\n\t    :ivar status: Overall health status\n\t    :ivar version: Service version.\n\t    :ivar resources: Status for individual resources..\n", "    \"\"\"\n\t    status: bool\n\t    version: str\n\t    name: str\n\t    resources: List[ResourceSchema]\n\t    class Config:\n\t        schema_extra = {\"example\": resource_example}\n"]}
{"filename": "OrderService/src/web/api/api.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-30 12:13:57\n\t     $Rev: 47\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom typing import List\n\t# Third party modules\n\tfrom pydantic import UUID4\n\tfrom fastapi.responses import Response\n\tfrom fastapi import APIRouter, status\n\t# Local modules\n\tfrom .order_api_adapter import OrdersApi\n\tfrom .documentation import order_id_documentation\n\tfrom ...repository.order_data_adapter import OrdersRepository\n", "from .schemas import (OrderPayload, OrderResponse,\n\t                      NotFoundError, FailedUpdateError, ConnectError)\n\t# Constants\n\trouter = APIRouter(prefix=f\"/v1/orders\", tags=[f\"Orders\"])\n\t\"\"\" Order API endpoint router. \"\"\"\n\t# ---------------------------------------------------------\n\t#\n\t@router.post(\n\t    '',\n\t    response_model=OrderResponse,\n", "    status_code=status.HTTP_202_ACCEPTED,\n\t    responses={\n\t        500: {'model': ConnectError},\n\t        400: {\"model\": FailedUpdateError}}\n\t)\n\tasync def create_order(payload: OrderPayload) -> OrderResponse:\n\t    \"\"\" **Create a new Order in the DB and trigger a payment.** \"\"\"\n\t    service = OrdersApi(OrdersRepository())\n\t    return await service.create_order(payload)\n\t# ---------------------------------------------------------\n", "#\n\t@router.post(\n\t    \"/{order_id}/cancel\",\n\t    response_model=OrderResponse,\n\t    status_code=status.HTTP_202_ACCEPTED,\n\t    responses={\n\t        500: {'model': ConnectError},\n\t        404: {\"model\": NotFoundError},\n\t        400: {\"model\": FailedUpdateError}}\n\t)\n", "async def cancel_order(order_id: UUID4 = order_id_documentation) -> OrderResponse:\n\t    \"\"\"\n\t    **Cancel Order for matching order_id in the DB and trigger a reimbursement.**\n\t    \"\"\"\n\t    service = OrdersApi(OrdersRepository())\n\t    return await service.cancel_order(order_id)\n\t# ---------------------------------------------------------\n\t#\n\t@router.get(\n\t    \"\",\n", "    response_model=List[OrderResponse]\n\t)\n\tasync def get_all_orders() -> List[OrderResponse]:\n\t    \"\"\" **Read all Orders from the DB sorted on created timestamp.** \"\"\"\n\t    service = OrdersApi(OrdersRepository())\n\t    return await service.list_orders()\n\t# ---------------------------------------------------------\n\t#\n\t@router.get(\n\t    \"/{order_id}\",\n", "    response_model=OrderResponse,\n\t    responses={404: {\"model\": NotFoundError}},\n\t)\n\tasync def get_order(order_id: UUID4 = order_id_documentation) -> OrderResponse:\n\t    \"\"\" **Read Order for matching order_id from the DB.** \"\"\"\n\t    service = OrdersApi(OrdersRepository())\n\t    return await service.get_order(order_id)\n\t# ---------------------------------------------------------\n\t#\n\t@router.delete(\n", "    \"/{order_id}\",\n\t    status_code=status.HTTP_204_NO_CONTENT,\n\t    responses={404: {\"model\": NotFoundError}},\n\t    response_description='Order was successfully deleted in the DB.'\n\t)\n\tasync def delete_order(order_id: UUID4 = order_id_documentation) -> Response:\n\t    \"\"\" **Delete Order for matching order_id from the DB.** \"\"\"\n\t    service = OrdersApi(OrdersRepository())\n\t    await service.delete_order(order_id)\n\t    return Response(status_code=status.HTTP_204_NO_CONTENT)\n"]}
{"filename": "OrderService/src/web/api/documentation.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-04-02 14:01:36\n\t     $Rev: 57\n\t\"\"\"\n", "from fastapi import Path\n\t# Local modules\n\tfrom ...config.setup import config\n\torder_id_documentation = Path(\n\t    ...,\n\t    description='**Order ID**: *Example `dbb86c27-2eed-410d-881e-ad47487dd228`*. '\n\t                'A unique identifier for an existing Order.',\n\t)\n\tresource_example = {\n\t    \"status\": True,\n", "    \"version\": f\"{config.version}\",\n\t    \"name\": f\"{config.service_name}\",\n\t    \"resources\": [\n\t        {\n\t            \"name\": \"MongoDb\",\n\t            \"status\": True\n\t        },\n\t        {\n\t            \"name\": \"RabbitMq\",\n\t            \"status\": True\n", "        },\n\t        {\n\t            \"name\": \"PaymentService\",\n\t            \"status\": True\n\t        },\n\t        {\n\t            \"name\": \"KitchenService\",\n\t            \"status\": True\n\t        },\n\t        {\n", "            \"name\": \"DeliveryService\",\n\t            \"status\": True\n\t        },\n\t        {\n\t            \"name\": \"CustomerService\",\n\t            \"status\": True\n\t        },\n\t    ]\n\t}\n\ttags_metadata = [\n", "    {\n\t        \"name\": \"Orders\",\n\t        \"description\": f\"The ***{config.service_name}*** handle Orders for the Fictitious Company.\",\n\t    }\n\t]\n\tlicense_info = {\n\t    \"name\": \"License: Apache 2.0\",\n\t    \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",\n\t}\n\tservers = [\n", "    {\n\t        \"url\": \"http://127.0.0.1:8000\",\n\t        \"description\": \"URL for local development and testing\"\n\t    },\n\t    {\n\t        \"url\": \"https://coffeemesh-staging.com\",\n\t        \"description\": \"staging server for testing purposes only\"\n\t    },\n\t    {\n\t        \"url\": \"https://coffeemesh.com\",\n", "        \"description\": \"main production server\"\n\t    },\n\t]\n\tdescription = \"\"\"\n\t<img width=\"65%\" align=\"right\" src=\"/static/order_container_diagram.png\"/>\n\t**An example on how to use FastAPI and RabbitMQ asynchronously to create a RESTful API for responses that \n\ttakes a bit more time to process.** \n\tThis service implements a Facade pattern to simplify the complexity between the MicroServices in the system \n\tand the WEB GUI program (it only has to work against one API).\n\tThe OrderService handles multiple status updates from several services during the lifecycle of an Order. These \n", "responses are asynchronous events spread out over time and to be able to handle this type of dynamic the RabbitMQ \n\tmessage broker is used. The RabbitMQ queue routing technique is used since it is designed to scale with the growing \n\tneeds of the service.\n\tThe key to this design is that a metadata structure is part of every message that is sent between the services in \n\tthe system. This `MetaDataSchema` structure is described in the Schemas section for the \n\t[PaymentService](http://127.0.0.1:8001/docs). \n\t<br>**The following HTTP status codes are returned:**\n\t  * `200:` Successful GET response.\n\t  * `202:` Successful POST response.\n\t  * `204:` Successful DELETE response.\n", "  * `400:` Failed updating Order in DB.\n\t  * `404:` Order not found in DB.\n\t  * `422:` Validation error, supplied parameter(s) are incorrect.\n\t  * `500:` Failed to connect to internal MicroService.\n\t  * `500:` Failed Health response.\n\t<br><br>\n\t---\n\t\"\"\"\n"]}
{"filename": "OrderService/src/web/api/order_api_adapter.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-30 13:14:04\n\t     $Rev: 48\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom typing import List\n\t# Third party modules\n\tfrom pydantic import UUID4\n\tfrom fastapi import HTTPException\n\t# Local modules\n\tfrom ...repository.models import OrderModel\n\tfrom .schemas import OrderResponse, OrderPayload\n\tfrom ...business.request_handler import OrderApiLogic\n\tfrom ...repository.order_data_adapter import OrdersRepository\n", "# ------------------------------------------------------------------------\n\t#\n\tclass OrdersApi:\n\t    \"\"\"\n\t    This class implements the web API layer adapter.\n\t    \"\"\"\n\t    # ---------------------------------------------------------\n\t    #\n\t    def __init__(self, repository: OrdersRepository):\n\t        \"\"\" The class initializer.\n", "        :param repository: Data layer handler object.\n\t        \"\"\"\n\t        self.repo = repository\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def _order_of(self, order_id: UUID4) -> OrderModel:\n\t        \"\"\" Return specified order.\n\t        :param order_id: Order id for order to find.\n\t        :return: Found Order object.\n\t        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n", "        \"\"\"\n\t        db_order = await self.repo.read(order_id)\n\t        if not db_order:\n\t            errmsg = f\"{order_id=} not found in DB api_db.orders\"\n\t            raise HTTPException(status_code=404, detail=errmsg)\n\t        return db_order\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def list_orders(self) -> List[OrderResponse]:\n\t        \"\"\" List all existing orders in DB api_db.orders.\n", "        Sorted on creation timestamp in descending order.\n\t        :return: List of found orders.\n\t        \"\"\"\n\t        return await self.repo.read_all()\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def get_order(self, order_id: UUID4) -> OrderResponse:\n\t        \"\"\" Return specified order.\n\t        :param order_id: Order id for order to find.\n\t        :return: Found Order object.\n", "        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n\t        \"\"\"\n\t        db_order = await self._order_of(order_id)\n\t        return OrderResponse(**db_order.dict())\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def create_order(self, payload: OrderPayload) -> OrderResponse:\n\t        \"\"\" Create a new order in DB and make a payment request.\n\t        :param payload: Incoming Order request.\n\t        :return: Created Order object.\n", "        :raise HTTPException [400]: when PaymentService response code != 202.\n\t        :raise HTTPException [500]: when connection with PaymentService failed.\n\t        :raise HTTPException [400]: when create order in DB api_db.orders failed.\n\t        \"\"\"\n\t        db_order = OrderModel(**payload.dict())\n\t        order = OrderApiLogic(repository=self.repo, **db_order.dict())\n\t        return await order.create()\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def cancel_order(self, order_id: UUID4) -> OrderResponse:\n", "        \"\"\" Cancel specified order.\n\t        :param order_id: id for order to cancel.\n\t        :return: Found Order object.\n\t        :raise HTTPException [400]: when failed to update DB api_db.orders.\n\t        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n\t        \"\"\"\n\t        db_order = await self._order_of(order_id)\n\t        order = OrderApiLogic(repository=self.repo, **db_order.dict())\n\t        return await order.cancel()\n\t    # ---------------------------------------------------------\n", "    #\n\t    async def delete_order(self, order_id: UUID4) -> None:\n\t        \"\"\" Delete specified order.\n\t        :param order_id: id for order to delete.\n\t        :raise HTTPException [404]: when Order not found in DB api_db.orders.\n\t        \"\"\"\n\t        db_order = await self._order_of(order_id)\n\t        order = OrderApiLogic(repository=self.repo, **db_order.dict())\n\t        await order.delete()\n"]}
{"filename": "PaymentService/run.py", "chunked_list": ["#!/usr/bin/env python\n\t# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-20 22:57:08\n\t     $Rev: 24\n", "\"\"\"\n\t# Third party modules\n\timport uvicorn\n\t# Local modules\n\tfrom src.web.main import app\n\tif __name__ == \"__main__\":\n\t    uv_config = {'app': 'src.web.main:app', 'port': 8001,\n\t                 'log_level': app.level, 'reload': True,\n\t                 'log_config': {\"disable_existing_loggers\": False, \"version\": 1}}\n\t    uvicorn.run(**uv_config)\n"]}
{"filename": "PaymentService/__init__.py", "chunked_list": []}
{"filename": "PaymentService/src/__init__.py", "chunked_list": []}
{"filename": "PaymentService/src/tools/rabbit_client.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-30 17:41:49\n\t     $Rev: 50\n\t\"\"\"\n", "# BUILTIN modules\n\timport asyncio\n\tfrom typing import Callable, Optional\n\t# Third party modules\n\timport ujson as json\n\tfrom aio_pika import connect, connect_robust, Message, DeliveryMode\n\tfrom aio_pika.abc import AbstractIncomingMessage, AbstractRobustConnection\n\t# -----------------------------------------------------------------------------\n\t#\n\tclass RabbitClient:\n", "    \"\"\" This class handles the communication with the RabbitMQ server.\n\t    Note: the queue mechanism is implemented to take advantage of good\n\t    horizontal message scaling when needed.\n\t    Both Publisher and Consumer async handling is implemented.\n\t    \"\"\"\n\t    rabbit_url: str = None\n\t    # ---------------------------------------------------------\n\t    #\n\t    def __init__(self, rabbit_url: str, service: Optional[str] = None,\n\t                 incoming_message_handler: Optional[Callable] = None):\n", "        \"\"\" The class initializer.\n\t        :param rabbit_url: RabbitMQ's connection string.\n\t        :param service: Name of receiving service (when using consume).\n\t        :param incoming_message_handler: Incoming message callback method.\n\t        \"\"\"\n\t        # Unique parameters.\n\t        self.rabbit_url = rabbit_url\n\t        self.service_name = service\n\t        self.message_handler = incoming_message_handler\n\t    # ---------------------------------------------------------\n", "    #\n\t    async def _process_incoming_message(self, message: AbstractIncomingMessage):\n\t        \"\"\" Processing incoming message from RabbitMQ.\n\t        :param message: Received message.\n\t        \"\"\"\n\t        if body := message.body:\n\t            await self.message_handler(json.loads(body))\n\t        await message.ack()\n\t    # ---------------------------------------------------------\n\t    #\n", "    async def consume(self) -> AbstractRobustConnection:\n\t        \"\"\" Setup message listener with the current running asyncio loop. \"\"\"\n\t        loop = asyncio.get_running_loop()\n\t        # Perform receive connection.\n\t        connection = await connect_robust(loop=loop, url=self.rabbit_url)\n\t        # Creating receive channel and setting quality of service.\n\t        channel = await connection.channel()\n\t        # To make sure the load is evenly distributed between the workers.\n\t        await channel.set_qos(1)\n\t        # Creating a receive queue.\n", "        queue = await channel.declare_queue(name=self.service_name, durable=True)\n\t        # Start consumption of existing and future messages.\n\t        await queue.consume(self._process_incoming_message, no_ack=False)\n\t        return connection\n\t    # ---------------------------------------------------------\n\t    #\n\t    @classmethod\n\t    async def send_message(cls, message: dict, queue: str):\n\t        \"\"\" Send message to RabbitMQ Publisher queue.\n\t        If the topic is defined, topic message routing is used, otherwise\n", "        queue message routing is used.\n\t        :param message: Message to be sent.\n\t        :param queue: Message queue to use for message sending.\n\t        :raise AssertionError: Parameters 'topic' and 'queue' are mutually exclusive.\n\t        \"\"\"\n\t        connection = await connect(url=cls.rabbit_url)\n\t        channel = await connection.channel()\n\t        message_body = Message(\n\t            content_type='application/json',\n\t            body=json.dumps(message, ensure_ascii=False).encode(),\n", "            delivery_mode=DeliveryMode.PERSISTENT)\n\t        await channel.default_exchange.publish(\n\t            routing_key=queue, message=message_body)\n"]}
{"filename": "PaymentService/src/tools/custom_logging.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-25 17:47:36\n\t     $Rev: 42\n\t\"\"\"\n", "# BUILTIN modules\n\timport sys\n\timport logging\n\tfrom typing import cast\n\tfrom types import FrameType\n\t# Third party modules\n\tfrom loguru import logger\n\t# ---------------------------------------------------------\n\t#\n\tclass InterceptHandler(logging.Handler):\n", "    \"\"\" Logs to loguru from Python logging module. \"\"\"\n\t    def emit(self, record: logging.LogRecord):\n\t        try:\n\t            level = logger.level(record.levelname).name\n\t        except ValueError:\n\t            level = str(record.levelno)\n\t        frame, depth = logging.currentframe(), 2\n\t        while frame.f_code.co_filename == logging.__file__:\n\t            frame = cast(FrameType, frame.f_back)\n\t            depth += 1\n", "        logger.opt(\n\t            depth=depth,\n\t            exception=record.exc_info).log(\n\t            level,\n\t            record.getMessage()\n\t        )\n\t# ---------------------------------------------------------\n\t#\n\tdef create_unified_logger(log_level: str) -> tuple:\n\t    \"\"\" Return unified Loguru logger object.\n", "    :return: unified Loguru logger object.\n\t    \"\"\"\n\t    level = log_level\n\t    # Remove all existing loggers.\n\t    logger.remove()\n\t    # Create a basic Loguru logging config.\n\t    logger.add(\n\t        diagnose=True,\n\t        backtrace=True,\n\t        sink=sys.stderr,\n", "        level=level.upper(),\n\t    )\n\t    # Prepare to incorporate python standard logging.\n\t    seen = set()\n\t    logging.basicConfig(handlers=[InterceptHandler()], level=0)\n\t    for logger_name in logging.root.manager.loggerDict.keys():\n\t        if logger_name not in seen:\n\t            seen.add(logger_name.split(\".\")[0])\n\t            mod_logger = logging.getLogger(logger_name)\n\t            mod_logger.handlers = [InterceptHandler(level=level.upper())]\n", "            mod_logger.propagate = False\n\t    return level, logger.bind(request_id=None, method=None)\n"]}
{"filename": "PaymentService/src/business/schemas.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-21 22:20:47\n\t     $Rev: 27\n\t\"\"\"\n", "# Third party modules\n\tfrom pydantic import BaseModel, Field\n\t# Local modules\n\tfrom ..repository.models import Status\n\tfrom ..web.api.schemas import MetadataSchema\n\t# ---------------------------------------------------------\n\t#\n\tclass PaymentResponse(BaseModel):\n\t    \"\"\" Representation of a Payment Response in the system. \"\"\"\n\t    metadata: MetadataSchema\n", "    status: Status = Field(send_example=Status.PAID)\n"]}
{"filename": "PaymentService/src/business/payment_handler.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-04-01 17:51:19\n\t     $Rev: 55\n\t\"\"\"\n", "# BUILTIN modules\n\timport contextlib\n\tfrom uuid import UUID, uuid4\n\t# Third party modules\n\tfrom loguru import logger\n\tfrom fastapi import HTTPException\n\tfrom httpx import AsyncClient, ConnectError, ConnectTimeout\n\t# Local modules\n\tfrom ..config.setup import config\n\tfrom .schemas import PaymentResponse\n", "from ..repository.url_cache import UrlCache\n\tfrom ..repository.models import PaymentModel\n\tfrom ..tools.rabbit_client import RabbitClient\n\tfrom ..repository.payment_data_adapter import PaymentsRepository\n\tfrom ..web.api.schemas import BillingCallback, BillingPayload, PaymentPayload\n\t# -----------------------------------------------------------------------------\n\t#\n\tclass PaymentLogic:\n\t    \"\"\"\n\t    This class implements the PaymentService business logic layer.\n", "    \"\"\"\n\t    # ---------------------------------------------------------\n\t    #\n\t    def __init__(self, repository: PaymentsRepository,\n\t                 cache: UrlCache, client: RabbitClient):\n\t        \"\"\" The class initializer.\n\t        :param repository: Data layer handler object.\n\t        :param cache: Redis URL cache.\n\t        :param client: RabbitMQ client.\n\t        \"\"\"\n", "        self.cache = cache\n\t        self.client = client\n\t        self.repo = repository\n\t    # ---------------------------------------------------------\n\t    #\n\t    @staticmethod\n\t    async def _charge_credit_card(payload: BillingPayload) -> UUID:\n\t        \"\"\" Simulate doing the Credit Card billing.\n\t        :param payload: Data needed for Billing.\n\t        :return: Credit Card Company transaction ID.\n", "        :raise RuntimeError: when Post response status != 202.\n\t        \"\"\"\n\t        # Fake the billing work (URL is fake, so it will never connect).\n\t        with contextlib.suppress(ConnectError):\n\t            async with AsyncClient() as client:\n\t                url = \"http://fakeCreditCardCompany.com/billings\"\n\t                resp = await client.post(url=url, json=payload.dict(),\n\t                                         timeout=config.url_timeout)\n\t            if resp.status_code != 202:\n\t                errmsg = f\"Failed sending POST request to Credit Card Company \" \\\n", "                             f\"URL {url} - [{resp.status_code}: {resp.text}].\"\n\t                raise RuntimeError(errmsg)\n\t        logger.info(f\"Sent Billing request with caller_id '{payload.caller_id}'.\")\n\t        # This should be something like: return resp.json()['tracking_id']\n\t        # but since we fake it, we need an id.\n\t        return uuid4()\n\t    # ---------------------------------------------------------\n\t    #\n\t    @staticmethod\n\t    async def _reimburse_credit_card(payload: BillingPayload) -> None:\n", "        \"\"\" Simulate doing the Credit Card reimbursement.\n\t        :param payload: Data needed for reimbursement.\n\t        :raise RuntimeError: when Post response status != 202.\n\t        \"\"\"\n\t        # Fake the reimbursement work (URL is fake, so it will never connect).\n\t        with contextlib.suppress(ConnectError):\n\t            async with AsyncClient() as client:\n\t                url = \"http://fakeCreditCardCompany.com/billings/reimburse\"\n\t                resp = await client.post(url=url, json=payload.dict(),\n\t                                         timeout=config.url_timeout)\n", "            if resp.status_code != 202:\n\t                errmsg = f\"Failed sending POST request to Credit Card Company \" \\\n\t                             f\"URL {url} - [{resp.status_code}: {resp.text}].\"\n\t                raise RuntimeError(errmsg)\n\t        logger.info(f\"Sent reimbursement request with caller_id '{payload.caller_id}'.\")\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def process_payment_request(self, payload: PaymentPayload):\n\t        \"\"\" Process payment request.\n\t         Implemented logic:\n", "           - Get customer billing data and amount-to-pay from the CustomerService.\n\t           - Send the payment request to the external Credit Card Company.\n\t           - Store payment in DB collection api_db.payments.\n\t        :param payload: Payment request data.\n\t        :raise HTTPException [500]: when processing request failed.\n\t        :raise HTTPException [400]: when HTTP POST response != 201 or 202.\n\t        :raise HTTPException [500]: when connection with CustomerService failed.\n\t        \"\"\"\n\t        url = None\n\t        try:\n", "            meta = payload.metadata\n\t            root = await self.cache.get('CustomerService')\n\t            items = [item.dict() for item in payload.items]\n\t            # Get Customer Credit Card information.\n\t            async with AsyncClient() as client:\n\t                url = f\"{root}/v1/customers/{meta.customer_id}/billing\"\n\t                resp = await client.post(url=url, json=items,\n\t                                         timeout=config.url_timeout)\n\t            if resp.status_code != 201:\n\t                errmsg = f\"Failed CustomerService POST request for URL \" \\\n", "                         f\"{url} - [{resp.status_code}: {resp.json()['detail']}].\"\n\t                raise RuntimeError(errmsg)\n\t            # Charge the Customer credit card.\n\t            url = \"http://fictitious.com/v1/payments/callback\"\n\t            billing = BillingPayload(caller_id=meta.order_id,\n\t                                     callback_url=url, **resp.json())\n\t            trans_id = await self._charge_credit_card(billing)\n\t            # Store payment in DB.\n\t            payment = PaymentModel(metadata=meta,\n\t                                   id=meta.order_id,\n", "                                   transaction_id=trans_id)\n\t            await self.repo.create(payment)\n\t        except RuntimeError as why:\n\t            logger.error(f'{why}')\n\t            raise HTTPException(status_code=400, detail=f'{why}')\n\t        except ConnectTimeout:\n\t            errmsg = f'No connection with CustomerService on URL {url}'\n\t            logger.critical(errmsg)\n\t            raise HTTPException(status_code=500, detail=errmsg)\n\t        except BaseException as why:\n", "            logger.critical(f'Failed processing payment request => {why}')\n\t            raise HTTPException(status_code=500, detail=f'{why}')\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def process_reimbursement_request(self, payload: PaymentPayload):\n\t        \"\"\" Process reimbursement request.\n\t         Implemented logic:\n\t           - Get customer billing data and amount-to-reimburse from the CustomerService.\n\t           - Send the reimbursement request to the external Credit Card Company.\n\t           - Update payment status in DB collection api_db.payments.\n", "        :param payload: Reimbursement request data.\n\t        :raise HTTPException [500]: when processing request failed.\n\t        :raise HTTPException [400]: when HTTP POST response != 201 or 202.\n\t        :raise HTTPException [500]: when connection with CustomerService failed.\n\t        \"\"\"\n\t        url = None\n\t        try:\n\t            meta = payload.metadata\n\t            root = await self.cache.get('CustomerService')\n\t            items = [item.dict() for item in payload.items]\n", "            # Get Customer Credit Card information.\n\t            async with AsyncClient() as client:\n\t                url = f\"{root}/v1/customers/{meta.customer_id}/billing\"\n\t                resp = await client.post(url=url, json=items,\n\t                                         timeout=config.url_timeout)\n\t            if resp.status_code != 201:\n\t                errmsg = f\"Failed CustomerService POST request for URL \" \\\n\t                         f\"{url} - [{resp.status_code}: {resp.json()['detail']}].\"\n\t                raise RuntimeError(errmsg)\n\t            # Reimburse the Customer credit card.\n", "            url = \"http://fictitious.com/v1/payments/callback\"\n\t            billing = BillingPayload(caller_id=meta.order_id,\n\t                                     callback_url=url, **resp.json())\n\t            await self._reimburse_credit_card(billing)\n\t        except RuntimeError as why:\n\t            logger.error(f'{why}')\n\t            raise HTTPException(status_code=400, detail=f'{why}')\n\t        except ConnectTimeout:\n\t            errmsg = f'No connection with CustomerService on URL {url}'\n\t            logger.critical(errmsg)\n", "            raise HTTPException(status_code=500, detail=errmsg)\n\t        except BaseException as why:\n\t            logger.critical(f'Failed processing payment request => {why}')\n\t            raise HTTPException(status_code=500, detail=f'{why}')\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def process_response(self, payload: BillingCallback) -> BillingCallback:\n\t        \"\"\" Process payment/reimbursement callback response.\n\t         Implemented logic:\n\t           - Extract payment Order from DB using payload caller_id.\n", "           - Store updated billing data in DB collection api_db.payments.\n\t           - Send the billing response to the metadata requester using RabbitMQ.\n\t        :param payload: Payment callback response data.\n\t        :return: Received payload.\n\t        :raise HTTPException [404]: when caller_id does not exist in DB.\n\t        \"\"\"\n\t        try:\n\t            payment = await self.repo.read(payload.caller_id)\n\t            if not payment:\n\t                errmsg = f\"Caller ID '{payload.caller_id}' does \" \\\n", "                         f\"not exist in DB api_db.payments.\"\n\t                raise RuntimeError(errmsg)\n\t            # Prepare payment response.\n\t            response = PaymentResponse(status=payload.status, metadata=payment.metadata)\n\t            # Update payment in DB.\n\t            payment.status = payload.status\n\t            await self.repo.update(payment)\n\t            # Send response message to requester.\n\t            await self.client.send_message(message=response.dict(),\n\t                                           queue=payment.metadata.receiver)\n", "            logger.info(f\"Sent Payment response to {payment.metadata.receiver} \"\n\t                        f\"with status '{payload.status}' for Order '{payload.caller_id}'.\")\n\t            return payload\n\t        except RuntimeError as why:\n\t            logger.error(f'{why}')\n\t            raise HTTPException(status_code=404, detail=f'{why}')\n"]}
{"filename": "PaymentService/src/repository/models.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-29 19:37:08\n\t     $Rev: 45\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom uuid import UUID\n\tfrom enum import Enum\n\tfrom typing import Callable\n\tfrom datetime import datetime\n\t# Third party modules\n\tfrom pydantic import BaseModel, BaseConfig, Field, UUID4, validator\n\t# Local modules\n\tfrom .documentation import payment_documentation as pay_doc\n\tfrom ..web.api.documentation import (metadata_example,\n", "                                     metadata_documentation as meta_doc)\n\t# ---------------------------------------------------------\n\t#\n\tclass MetadataSchema(BaseModel):\n\t    \"\"\" Representation of Order metadata in the system. \"\"\"\n\t    receiver: str = Field(**meta_doc['receiver'])\n\t    order_id: str = Field(**meta_doc['order_id'])\n\t    customer_id: str = Field(**meta_doc['customer_id'])\n\t    class Config:\n\t        schema_extra = {\"example\": metadata_example}\n", "    @validator('*', pre=True)\n\t    def decode_values(cls, value):\n\t        \"\"\" Decode UUID value into a str. \"\"\"\n\t        return str(value) if isinstance(value, UUID) else value\n\t# ---------------------------------------------------------\n\t#\n\tclass Status(str, Enum):\n\t    \"\"\" Payment result status. \"\"\"\n\t    PEND = 'pending'\n\t    REIM = 'reimbursed'\n", "    PAID = 'paymentPaid'\n\t    FAIL = 'paymentFailed'\n\t# ------------------------------------------------------------------------\n\t#\n\tclass MongoBase(BaseModel):\n\t    \"\"\"\n\t    Class that handles conversions between MongoDB '_id' key\n\t    and our own 'id' key.\n\t    MongoDB uses `_id` as an internal default index key.\n\t    We can use that to our advantage.\n", "    \"\"\"\n\t    class Config(BaseConfig):\n\t        \"\"\" basic config. \"\"\"\n\t        orm_mode = True\n\t        allow_population_by_field_name = True\n\t    # noinspection PyArgumentList\n\t    @classmethod\n\t    def from_mongo(cls, data: dict) -> Callable:\n\t        \"\"\" Convert \"_id\" (str object) into \"id\" (UUID object). \"\"\"\n\t        if not data:\n", "            return data\n\t        mongo_id = data.pop('_id', None)\n\t        return cls(**dict(data, id=mongo_id))\n\t    def to_mongo(self, **kwargs) -> dict:\n\t        \"\"\" Convert \"id\" (UUID object) into \"_id\" (str object). \"\"\"\n\t        parsed = self.dict(**kwargs)\n\t        if '_id' not in parsed and 'id' in parsed:\n\t            parsed['_id'] = str(parsed.pop('id'))\n\t        return parsed\n\t# ---------------------------------------------------------\n", "#\n\tclass PaymentUpdateModel(MongoBase):\n\t    \"\"\" Representation of an Order in the system. \"\"\"\n\t    metadata: MetadataSchema\n\t    transaction_id: UUID4 = Field(**pay_doc['transaction_id'])\n\t    status: Status = Field(default=Status.PEND, **pay_doc['status'])\n\t    created: datetime = Field(default_factory=datetime.utcnow, **pay_doc['created'])\n\t# ---------------------------------------------------------\n\t#\n\tclass PaymentModel(PaymentUpdateModel):\n", "    \"\"\" Representation of a Payment in the system. \"\"\"\n\t    id: UUID4 = Field(**pay_doc['id'])\n"]}
{"filename": "PaymentService/src/repository/payment_data_adapter.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-23 19:52:08\n\t     $Rev: 36\n\t\"\"\"\n", "# Third party modules\n\tfrom pydantic import UUID4\n\t# Local modules\n\tfrom .db import Engine\n\tfrom .models import (PaymentModel, PaymentUpdateModel)\n\t# ------------------------------------------------------------------------\n\t#\n\tclass PaymentsRepository:\n\t    \"\"\"\n\t    This class implements the PaymentService data layer adapter (the CRUD operations).\n", "    \"\"\"\n\t    # ---------------------------------------------------------\n\t    #\n\t    @staticmethod\n\t    async def connection_info() -> dict:\n\t        \"\"\" Return DB connection information.\n\t        :return: DB connection information.\n\t        \"\"\"\n\t        return await Engine.connection.server_info()\n\t    # ---------------------------------------------------------\n", "    #\n\t    @staticmethod\n\t    async def create(payload: PaymentModel) -> bool:\n\t        \"\"\" Create Payment in DB collection api_db.payments.\n\t        :param payload: New Payment payload.\n\t        :return: DB create result.\n\t        \"\"\"\n\t        response = await Engine.db.payments.insert_one(payload.to_mongo())\n\t        return response.acknowledged\n\t    # ---------------------------------------------------------\n", "    #\n\t    @staticmethod\n\t    async def read(key: UUID4) -> PaymentModel:\n\t        \"\"\" Read Payment for matching index key from DB collection api_db.payments.\n\t        :param key: Index key.\n\t        :return: Found Payment.\n\t        \"\"\"\n\t        response = await Engine.db.payments.find_one({\"_id\": str(key)})\n\t        return PaymentModel.from_mongo(response)\n\t    # ---------------------------------------------------------\n", "    #\n\t    @staticmethod\n\t    async def update(payload: PaymentModel) -> bool:\n\t        \"\"\" Update Payment in DB collection api_db.payments.\n\t        :param payload: Updated Order payload.\n\t        :return: DB update result.\n\t        \"\"\"\n\t        base = PaymentUpdateModel(**payload.dict()).to_mongo()\n\t        response = await Engine.db.payments.update_one({\"_id\": str(payload.id)},\n\t                                                       {\"$set\": {**base}})\n", "        return response.raw_result['updatedExisting']\n"]}
{"filename": "PaymentService/src/repository/db.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-21 02:16:53\n\t     $Rev: 26\n\t\"\"\"\n", "# Third party modules\n\tfrom motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase\n\t# Local program modules\n\tfrom ..config.setup import config\n\t# ---------------------------------------------------------\n\t#\n\tclass Engine:\n\t    \"\"\" MongoDb database async engine class.\n\t    :type db: C{motor.motor_asyncio.AsyncIOMotorDatabase}\n\t    :ivar db: AsyncIOMotorDatabase class instance.\n", "    :type connection: C{motor.motor_asyncio.AsyncIOMotorClient}\n\t    :ivar connection: AsyncIOMotorClient class instance.\n\t    \"\"\"\n\t    db: AsyncIOMotorDatabase = None\n\t    connection: AsyncIOMotorClient = None\n\t    # ---------------------------------------------------------\n\t    #\n\t    @classmethod\n\t    async def connect_to_mongo(cls):\n\t        \"\"\" Initialize DB connection to MongoDb and database.\n", "        Setting server connection timeout to 5 (default is 30) seconds.\n\t        \"\"\"\n\t        cls.connection = AsyncIOMotorClient(config.mongo_url,\n\t                                            uuidRepresentation='standard',\n\t                                            serverSelectionTimeoutMS=5000)\n\t        cls.db = cls.connection.api_db\n\t    # ---------------------------------------------------------\n\t    #\n\t    @classmethod\n\t    async def close_mongo_connection(cls):\n", "        \"\"\" Close DB connection. \"\"\"\n\t        cls.connection.close()\n"]}
{"filename": "PaymentService/src/repository/documentation.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-21 22:20:47\n\t     $Rev: 27\n\t\"\"\"\n", "payment_documentation = {\n\t    \"receiver\": {'example': 'OrderService',\n\t                 'description': 'Requesting service.'},\n\t    \"status\": {'description': 'Payment workflow status.'},\n\t    \"created\": {'example': \"`2023-03-10T12:15:23.123234`\",\n\t                'description': 'Timestamp when the Payment was created.'},\n\t    \"id\": {'example': \"`dbb86c27-2eed-410d-881e-ad47487dd228`\",\n\t           'description': 'Order ID: A unique identifier for an existing Order.'},\n\t    \"transaction_id\": {'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n\t                       'description': 'Transaction ID for the Credit Card company for the current Order.'},\n", "}\n"]}
{"filename": "PaymentService/src/repository/url_cache.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-24 23:18:27\n\t     $Rev: 38\n\t\"\"\"\n", "# Third party modules\n\tfrom aioredis import from_url\n\t# Local modules\n\tfrom .db import Engine\n\t# Constants\n\tEXPIRE = 60*60*24\n\t\"\"\" Redis keys expire after 24h. \"\"\"\n\t# ------------------------------------------------------------------------\n\t#\n\tclass UrlCache:\n", "    \"\"\" This class handles Redis URL cache.\n\t    Is automatically populated from MongoDB api_db.service_urls collection.\n\t    \"\"\"\n\t    # ---------------------------------------------------------\n\t    #\n\t    def __init__(self, url: str):\n\t        \"\"\"  The class initializer.\n\t        :param url: Redis connection URL.\n\t        \"\"\"\n\t        self.client = from_url(url)\n", "    # ---------------------------------------------------------\n\t    #\n\t    async def get(self, key: str) -> str:\n\t        \"\"\" Get MicroService URL from Redis.\n\t        Populate from MongoDB api_db.service_urls collection if needed.\n\t        All URL Keys expire after 24h in the cache.\n\t        :param key: MicroService name.\n\t        :return: MicroService URL.\n\t        \"\"\"\n\t        value = await self.client.get(key)\n", "        if not value:\n\t            value = await Engine.db.service_urls.find_one({\"_id\": key})\n\t            await self.client.set(key, value['url'], ex=EXPIRE)\n\t        return value.decode() if isinstance(value, bytes) else value['url']\n"]}
{"filename": "PaymentService/src/config/setup.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-04-01 21:09:57\n\t     $Rev: 56\n\t\"\"\"\n", "# BUILTIN modules\n\timport site\n\t# Third party modules\n\tfrom dotenv import load_dotenv\n\tfrom pydantic import BaseSettings\n\t# Constants\n\tMISSING_SECRET = '>>> missing SECRETS file <<<'\n\t\"\"\" Error message for missing secrets file. \"\"\"\n\tMISSING_ENV = '>>> missing ENV value <<<'\n\t\"\"\" Error message for missing values in the .env file. \"\"\"\n", "# ---------------------------------------------------------\n\t#\n\tclass Configuration(BaseSettings):\n\t    \"\"\" Configuration parameters. \"\"\"\n\t    # OpenAPI documentation.\n\t    name: str = MISSING_ENV\n\t    version: str = MISSING_ENV\n\t    # Service parameters.\n\t    service_name: str = MISSING_ENV\n\t    service_log_level: str = MISSING_ENV\n", "    # External resource parameters.\n\t    url_timeout: tuple = (1.0, 5.0)\n\t    mongo_url: str = MISSING_SECRET\n\t    redis_url: str = MISSING_SECRET\n\t    rabbit_url: str = MISSING_SECRET\n\t    # Handles both local and Docker environments.\n\t    class Config:\n\t        secrets_dir = f'{site.USER_BASE}/secrets'\n\t# ---------------------------------------------------------\n\t# Note that the \".env\" file is always implicitly loaded.\n", "load_dotenv()\n\tconfig = Configuration()\n\t\"\"\" Configuration parameters instance. \"\"\"\n"]}
{"filename": "PaymentService/src/web/main.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-29 19:37:08\n\t     $Rev: 45\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom pathlib import Path\n\tfrom contextlib import asynccontextmanager\n\t# Third party modules\n\tfrom fastapi import FastAPI\n\tfrom fastapi.responses import JSONResponse\n\tfrom fastapi.staticfiles import StaticFiles\n\t# Local modules\n\tfrom .api import api\n\tfrom ..config.setup import config\n", "from ..repository.db import Engine\n\tfrom .health_manager import HealthManager\n\tfrom ..repository.url_cache import UrlCache\n\tfrom .api.schemas import HealthSchema, HealthStatusError\n\tfrom ..tools.custom_logging import create_unified_logger\n\tfrom .api.documentation import (servers, license_info,\n\t                                tags_metadata, description)\n\tfrom ..repository.payment_data_adapter import PaymentsRepository\n\t# ---------------------------------------------------------\n\t#\n", "class Service(FastAPI):\n\t    def __init__(self, *args, **kwargs):\n\t        \"\"\" This class adds RabbitMQ message consumption and unified logging.\n\t        :param args: named arguments.\n\t        :param kwargs: key-value pair arguments.\n\t        \"\"\"\n\t        super().__init__(*args, **kwargs)\n\t        self.level, self.logger = create_unified_logger(config.service_log_level)\n\t# ---------------------------------------------------------\n\t#\n", "@asynccontextmanager\n\tasync def lifespan(service: Service):\n\t    await startup(service)\n\t    yield\n\t    await shutdown(service)\n\t# ---------------------------------------------------------\n\tapp = Service(\n\t    servers=servers,\n\t    lifespan=lifespan,\n\t    title=config.name,\n", "    version=config.version,\n\t    description=description,\n\t    license_info=license_info,\n\t    openapi_tags=tags_metadata,\n\t)\n\tapp.include_router(api.router)\n\t# Needed for OpenAPI Markdown images to be displayed.\n\tstatic_path = Path(__file__).parent.parent.parent.parent / 'design_docs'\n\tapp.mount(\"/static\", StaticFiles(directory=static_path))\n\t# ---------------------------------------------------------\n", "#\n\t@app.get(\n\t    '/health',\n\t    response_model=HealthSchema,\n\t    tags=[\"health check endpoint\"],\n\t    responses={500: {\"model\": HealthStatusError}},\n\t)\n\tasync def health_check() -> HealthSchema:\n\t    \"\"\" **Health check endpoint.** \"\"\"\n\t    content = await HealthManager(UrlCache(config.redis_url),\n", "                                  PaymentsRepository()).get_status()\n\t    response_code = (200 if content.status else 500)\n\t    return JSONResponse(status_code=response_code, content=content.dict())\n\t# ---------------------------------------------------------\n\t#\n\tasync def startup(service: Service):\n\t    \"\"\" Initialize MongoDB connection. \"\"\"\n\t    service.logger.info('Establishing MongoDB connection...')\n\t    await Engine.connect_to_mongo()\n\t# ---------------------------------------------------------\n", "#\n\tasync def shutdown(service: Service):\n\t    \"\"\" Close MongoDB connection. \"\"\"\n\t    service.logger.info('Disconnecting from MongoDB...')\n\t    await Engine.close_mongo_connection()\n"]}
{"filename": "PaymentService/src/web/health_manager.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-23 19:52:08\n\t     $Rev: 36\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom typing import List\n\t# Third party modules\n\tfrom loguru import logger\n\tfrom httpx import AsyncClient, ConnectTimeout\n\t# local modules\n\tfrom ..config.setup import config\n\tfrom ..repository.url_cache import UrlCache\n\tfrom ..web.api.schemas import ResourceSchema, HealthSchema\n\tfrom ..repository.payment_data_adapter import PaymentsRepository\n", "# Constants\n\tURLS = {'CustomerService'}\n\t\"\"\" Used internal MicroService(s). \"\"\"\n\t# -----------------------------------------------------------------------------\n\t#\n\tclass HealthManager:\n\t    \"\"\"\n\t    This class handles PaymentService health status reporting on used resources.\n\t    \"\"\"\n\t    # ---------------------------------------------------------\n", "    #\n\t    def __init__(self, cache: UrlCache, repository: PaymentsRepository):\n\t        \"\"\" The class initializer.\n\t        :param cache: Redis URL cache.\n\t        :param repository: Data layer handler object.\n\t        \"\"\"\n\t        self.cache = cache\n\t        self.repo = repository\n\t    # ---------------------------------------------------------\n\t    #\n", "    async def _get_mongo_status(self) -> List[ResourceSchema]:\n\t        \"\"\" Return MongoDb connection status.\n\t        :return: MongoDb connection status.\n\t        \"\"\"\n\t        try:\n\t            status = True\n\t            await self.repo.connection_info()\n\t        except BaseException as why:\n\t            logger.critical(f'MongoDB: {why}')\n\t            status = False\n", "        return [ResourceSchema(name='MongoDb', status=status)]\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def _get_service_status(self) -> List[ResourceSchema]:\n\t        \"\"\" Return RabbitMQ connection status.\n\t        :return: Service connection status.\n\t        \"\"\"\n\t        result = []\n\t        async with AsyncClient() as client:\n\t            for service in URLS:\n", "                try:\n\t                    root = await self.cache.get(service)\n\t                    url = f'{root}/health'\n\t                    status = False\n\t                    # Request used Microservice health status.\n\t                    response = await client.get(url=url, timeout=(1.0, 5.0))\n\t                    if response.status_code == 200:\n\t                        status = response.json()['status']\n\t                except ConnectTimeout:\n\t                    logger.critical(f'No connection with {service} on URL {url}')\n", "                result.append(ResourceSchema(name=service, status=status))\n\t        return result\n\t    # ---------------------------------------------------------\n\t    #\n\t    async def get_status(self) -> HealthSchema:\n\t        \"\"\" Return Health status for used resources.\n\t        :return: Service health status.\n\t        \"\"\"\n\t        resource_items = []\n\t        resource_items += await self._get_mongo_status()\n", "        resource_items += await self._get_service_status()\n\t        total_status = all(key.status for key in resource_items)\n\t        return HealthSchema(status=total_status,\n\t                            version=config.version,\n\t                            name=config.service_name,\n\t                            resources=resource_items)\n"]}
{"filename": "PaymentService/src/web/api/schemas.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-29 19:37:08\n\t     $Rev: 45\n\t\"\"\"\n", "# BUILTIN modules\n\tfrom enum import Enum\n\tfrom typing import List, Optional\n\t# Third party modules\n\tfrom pydantic import (BaseModel, conint, conlist,\n\t                      AnyHttpUrl, Field, UUID4, PositiveFloat)\n\t# Local modules\n\tfrom ...repository.models import Status, MetadataSchema\n\tfrom .documentation import (resource_example, billing_example,\n\t                            metadata_documentation as meta_doc,\n", "                            callback_documentation as callback)\n\t# ---------------------------------------------------------\n\t#\n\tclass ApiError(BaseModel):\n\t    \"\"\" Define model for a http 400 exception (Unprocessable Entity). \"\"\"\n\t    detail: str = \"Failed internal Microservice API call\"\n\tclass ConnectError(BaseModel):\n\t    \"\"\" Define model for a http 500 exception (INTERNAL_SERVER_ERROR). \"\"\"\n\t    detail: str = \"Failed to connect to internal MicroService\"\n\tclass HealthStatusError(BaseModel):\n", "    \"\"\" Define model for a http 500 exception (INTERNAL_SERVER_ERROR). \"\"\"\n\t    detail: str = \"HEALTH: resource connection(s) are down\"\n\t# ---------------------------------------------------------\n\t#\n\tclass Products(str, Enum):\n\t    \"\"\" Representation of valid products in the system. \"\"\"\n\t    lasagna = 'Lasagna'\n\t    cheese_burger = 'Double Cheeseburger'\n\t    veil = 'Veil with glazed onions and blue cheese'\n\t    vego_salad = 'Vegetarian Salad with healthy produce'\n", "class OrderItem(BaseModel):\n\t    \"\"\" Required order item parameters. \"\"\"\n\t    product: Products\n\t    quantity: Optional[conint(ge=1, strict=True)] = 1\n\tclass OrderItems(BaseModel):\n\t    \"\"\" A list of the ordered items. \"\"\"\n\t    items: conlist(OrderItem, min_items=1)\n\t# ---------------------------------------------------------\n\t#\n\tclass PaymentPayload(OrderItems):\n", "    \"\"\" Representation of a payment payload in the system. \"\"\"\n\t    metadata: MetadataSchema\n\t# ---------------------------------------------------------\n\t#\n\tclass PaymentAcknowledge(BaseModel):\n\t    \"\"\" Representation of a payment Acknowledge response in the system. \"\"\"\n\t    status: str = 'requestReceived'\n\t    order_id: UUID4 = Field(**meta_doc['order_id'])\n\t# ---------------------------------------------------------\n\t#\n", "class CreditCardSchema(BaseModel):\n\t    \"\"\" Representation of Credit Card Billing Information in the system. \"\"\"\n\t    CVV: str\n\t    Bank: str\n\t    Name: str\n\t    Expiry: str\n\t    Address: str\n\t    Country: str\n\t    MoneyRange: str\n\t    CardNumber: str\n", "    IssuingNetwork: str\n\t    class Config:\n\t        schema_extra = {\"example\": billing_example}\n\t# ---------------------------------------------------------\n\t#\n\tclass BillingPayload(BaseModel):\n\t    \"\"\" Representation of an external Billing payload in the system. \"\"\"\n\t    callback_url: AnyHttpUrl\n\t    billing_info: CreditCardSchema\n\t    amount: PositiveFloat = Field(example=9.54)\n", "    caller_id: str = Field(**callback['caller_id'])\n\t# ---------------------------------------------------------\n\t#\n\tclass BillingCallback(BaseModel):\n\t    \"\"\" Representation of an external Billing Callback in the system. \"\"\"\n\t    status: Status = Field(**callback['status'])\n\t    caller_id: UUID4 = Field(**callback['caller_id'])\n\t    transaction_id: UUID4 = Field(**callback['transaction_id'])\n\t# -----------------------------------------------------------------------------\n\t#\n", "class ResourceSchema(BaseModel):\n\t    \"\"\" Representation of a  health resources response.\n\t    :ivar name: Resource name.\n\t    :ivar status: Resource status\n\t    \"\"\"\n\t    name: str\n\t    status: bool\n\t# -----------------------------------------------------------------------------\n\t#\n\tclass HealthSchema(BaseModel):\n", "    \"\"\" Representation of a  health response.\n\t    :ivar name: Service name.\n\t    :ivar version: Service version.\n\t    :ivar status: Overall health status\n\t    :ivar resources: Status for individual resources..\n\t    \"\"\"\n\t    name: str\n\t    version: str\n\t    status: bool\n\t    resources: List[ResourceSchema]\n", "    class Config:\n\t        schema_extra = {\"example\": resource_example}\n"]}
{"filename": "PaymentService/src/web/api/api.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-31 20:31:23\n\t     $Rev: 53\n\t\"\"\"\n", "# Third party modules\n\tfrom fastapi import APIRouter, status\n\t# Local modules\n\tfrom ...config.setup import config\n\tfrom ...repository.url_cache import UrlCache\n\tfrom ...tools.rabbit_client import RabbitClient\n\tfrom ...business.payment_handler import PaymentLogic\n\tfrom .schemas import (PaymentAcknowledge, BillingCallback,\n\t                      ApiError, ConnectError, PaymentPayload)\n\tfrom ...repository.payment_data_adapter import PaymentsRepository\n", "# Constants\n\trouter = APIRouter(prefix=f\"/v1/payments\", tags=[f\"Payments\"])\n\t\"\"\" Payments API endpoint router. \"\"\"\n\t# ---------------------------------------------------------\n\t#\n\t@router.post(\n\t    '',\n\t    response_model=PaymentAcknowledge,\n\t    status_code=status.HTTP_202_ACCEPTED,\n\t    responses={\n", "        400: {\"model\": ApiError},\n\t        500: {'model': ConnectError}}\n\t)\n\tasync def create_payment(payload: PaymentPayload) -> PaymentAcknowledge:\n\t    \"\"\" **Process payment request.** \"\"\"\n\t    worker = PaymentLogic(repository=PaymentsRepository(),\n\t                          cache=UrlCache(config.redis_url),\n\t                          client=RabbitClient(config.rabbit_url))\n\t    await worker.process_payment_request(payload)\n\t    return PaymentAcknowledge(order_id=payload.metadata.order_id)\n", "# ---------------------------------------------------------\n\t#\n\t@router.post(\n\t    '/reimburse',\n\t    response_model=PaymentAcknowledge,\n\t    status_code=status.HTTP_202_ACCEPTED,\n\t    responses={\n\t        400: {\"model\": ApiError},\n\t        500: {'model': ConnectError}}\n\t)\n", "async def reimburse_payment(payload: PaymentPayload) -> PaymentAcknowledge:\n\t    \"\"\" **Process reimbursement request.** \"\"\"\n\t    worker = PaymentLogic(repository=PaymentsRepository(),\n\t                          cache=UrlCache(config.redis_url),\n\t                          client=RabbitClient(config.rabbit_url))\n\t    await worker.process_reimbursement_request(payload)\n\t    return PaymentAcknowledge(order_id=payload.metadata.order_id)\n\t# ---------------------------------------------------------\n\t#\n\t@router.post(\n", "    '/callback',\n\t    response_model=BillingCallback,\n\t    status_code=status.HTTP_201_CREATED,\n\t)\n\tasync def billing_response(payload: BillingCallback) -> BillingCallback:\n\t    \"\"\" **Process callback response.** \"\"\"\n\t    worker = PaymentLogic(repository=PaymentsRepository(),\n\t                          cache=UrlCache(config.redis_url),\n\t                          client=RabbitClient(config.rabbit_url))\n\t    return await worker.process_response(payload)\n"]}
{"filename": "PaymentService/src/web/api/documentation.py", "chunked_list": ["# -*- coding: utf-8 -*-\n\t\"\"\"\n\tCopyright: Wilde Consulting\n\t  License: Apache 2.0\n\tVERSION INFO::\n\t    $Repo: fastapi_messaging\n\t  $Author: Anders Wiklund\n\t    $Date: 2023-03-31 18:44:42\n\t     $Rev: 51\n\t\"\"\"\n", "# Local modules\n\tfrom ...config.setup import config\n\tresource_example = {\n\t    \"status\": True,\n\t    \"version\": f\"{config.version}\",\n\t    \"name\": f\"{config.service_name}\",\n\t    \"resources\": [\n\t        {\n\t            \"name\": \"MongoDb\",\n\t            \"status\": True\n", "        },\n\t        {\n\t            \"name\": \"CustomerService\",\n\t            \"status\": True\n\t        },\n\t    ]\n\t}\n\tbilling_example = {\n\t        \"IssuingNetwork\": \"MASTERCARD\",\n\t        \"CardNumber\": \"5485848512008744\",\n", "        \"Bank\": \"NORDEA BANK AB\",\n\t        \"Name\": \"Barirah Chou\",\n\t        \"Address\": \"Stallstigen 30\",\n\t        \"Country\": \"SWEDEN\",\n\t        \"MoneyRange\": \"$804\",\n\t        \"CVV\": \"808\",\n\t        \"Expiry\": \"07/2030\",\n\t}\n\tmetadata_example = {\n\t    \"receiver\": \"OrderService\",\n", "    \"order_id\": 'b76d019f-5937-4a14-8091-1d9f18666c93',\n\t    \"customer_id\": 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n\t}\n\tmetadata_documentation = {\n\t    \"receiver\": {'example': 'OrderService',\n\t                 'description': 'Requesting service.'},\n\t    \"order_id\": {'example': 'b76d019f-5937-4a14-8091-1d9f18666c93',\n\t                 'description': 'Order ID of the Order currently being handled.'},\n\t    \"customer_id\": {'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n\t                    'description': 'Customer ID for the Order currently being handled.'},\n", "}\n\tcallback_documentation = {\n\t    \"status\": {'example': 'paymentPaid',\n\t               'description': 'Credit Card billing/reimburse result.'},\n\t    \"caller_id\": {'example': 'b76d019f-5937-4a14-8091-1d9f18666c93',\n\t                  'description': 'Internal Order ID of the billed Order.'},\n\t    \"transaction_id\": {'example': 'f2861560-e9ed-4463-955f-0c55c3b416fb',\n\t                       'description': 'Credit Card company transaction ID.'},\n\t}\n\ttags_metadata = [\n", "    {\n\t        \"name\": \"Payments\",\n\t        \"description\": f\"The ***{config.service_name}*** handle payments for the \"\n\t                       f\"following Credit Cards: `VISA`, `Mastercard`, `Eurocard`.\",\n\t    }\n\t]\n\tlicense_info = {\n\t    \"name\": \"License: Apache 2.0\",\n\t    \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",\n\t}\n", "servers = [\n\t    {\n\t        \"url\": \"http://127.0.0.1:8001\",\n\t        \"description\": \"URL for local development and testing\"\n\t    },\n\t    {\n\t        \"url\": \"https://coffeemesh-staging.com\",\n\t        \"description\": \"staging server for testing purposes only\"\n\t    },\n\t    {\n", "        \"url\": \"https://coffeemesh.com\",\n\t        \"description\": \"main production server\"\n\t    },\n\t]\n\tdescription = \"\"\"\n\t<img width=\"65%\" align=\"right\" src=\"/static/order_container_diagram.png\"/>\n\t**An example on how to use FastAPI and RabbitMQ to create a RESTful API for responses that takes some time to \n\tprocess.** \n\tThis service handles Customer Credit Card payments using external Credit Card Companies. Required payload is \n\t `PaymentPayload` and the response is `PaymentResponse`. Both schemas are described in detail under Schemas below.\n", "<br>**The following HTTP status codes are returned:**\n\t  * `200:` Successful Health response.\n\t  * `201:` Successful POST callback response.\n\t  * `202:` Successful POST response.\n\t  * `400:` Failed internal Microservice API call.\n\t  * `422:` Validation error, supplied payload is incorrect.\n\t  * `500:` Failed to connect to internal MicroService.\n\t  * `500:` Failed Health response.\n\t<br><br>\n\t---\n", "\"\"\"\n"]}
