{"filename": "settings.py", "chunked_list": ["\"\"\"\n\tNetORC configuration file.\n\tWe have kept the default connection and secret parameters used by modules in this file.\n\tThis is not best practice, we recommend overriding these using a .env or a secret manager, see: <link>\n\t\"\"\"\n\timport os\n\tfrom pydantic import BaseSettings, RedisDsn, DirectoryPath, PostgresDsn\n\tclass Settings(BaseSettings):\n\t    \"\"\"NetORC settings management\"\"\"\n\t    # Header key used for authentication.\n", "    api_key_header = \"netorc-x-token\"\n\t    # We recommend changing the postgres db credentials.\n\t    database: PostgresDsn = \"postgresql://netorc:netorc123@netorc-postgres:5432/netorc\"\n\t    # We recommend changing the redis credentials.\n\t    redis: RedisDsn = \"redis://netorc-redis:6379\"  # TODO: redis or rediss\n\t    # Check this is the correct timezone.\n\t    timezone: str = \"Europe/London\"\n\t    utc: bool = True\n\t    # Censors celery configuration, passwords, api keys.\n\t    # We do NOT recommend to change this setting.\n", "    censored: bool = True\n\t    # Tasks can be queued with a priority.\n\t    # This is \"best effort\" and does not guarantee a faster execution.\n\t    # We do NOT recommend to change this setting.\n\t    priority_levels: int = 10  # 0-9\n\t    # Log outputs\n\t    log_console: bool = True\n\t    log_file: bool = True\n\t    log_syslog: bool = True\n\t    # The default log level is set to info.\n", "    # To change this value, see: https://docs.python.org/3/library/logging.html#logging-levels\n\t    log_level: int = 20\n\t    log_format: str = \"%(asctime)s %(levelname)s: %(message)s\"\n\t    # Syslog messages are sent using UDP, for TCP, see <link>.\n\t    # LOG_USER facility.\n\t    syslog_server: str = \"localhost\"\n\t    syslog_port: int = 514\n\t    # Default task directory.\n\t    task_dir: DirectoryPath = \"worker/tasks\"\n\t    class Config:\n", "        \"\"\"Modify the behaviour of settings management\"\"\"\n\t        env_file = \".env\"\n\t        env_file_encoding = \"utf-8\"\n\tsettings = Settings()\n\ttasks = [\n\t    (str(settings.task_dir) + \"/\" + x).replace(\"/\", \".\").strip(\".py\")\n\t    for x in os.listdir(str(settings.task_dir))\n\t    if not x.startswith(\"__\") and x.endswith(\".py\")\n\t]\n"]}
{"filename": "manage.py", "chunked_list": ["\"\"\"\n\tmanage.py\n\t\"\"\"\n\timport argparse\n\timport getpass\n\tfrom core.db import tables, migrate\n\tfrom core.security import secret\n\tfrom core.security.user import create_user\n\tdef main():\n\t    parser = argparse.ArgumentParser()\n", "    parser.add_argument(\"action\", choices=[\"migrate\", \"createsuperuser\"])\n\t    args = parser.parse_args()\n\t    if args.action == \"migrate\":\n\t        migrate.migrate()\n\t    if args.action == \"createsuperuser\":\n\t        superuser = tables.User()\n\t        superuser.username = input(\"Username: \")\n\t        while True:\n\t            password = getpass.getpass(prompt=\"Password: \")\n\t            if not secret.validator(password):\n", "                print(\"Password does not meet security requirements, please try again.\")\n\t            else:\n\t                superuser.password = password\n\t                break\n\t        while True:\n\t            api_key = getpass.getpass(prompt=\"API key: \")\n\t            if not secret.validator(api_key):\n\t                print(\"API key does not meet security requirements, please try again.\")\n\t            else:\n\t                superuser.api_key = api_key\n", "                break\n\t        try:\n\t            db_superuser = create_user(superuser)\n\t            print(f\"User: {db_superuser.username}, created.\")\n\t        except Exception:\n\t            raise\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "tests/test_manage.py", "chunked_list": []}
{"filename": "tests/test_settings.py", "chunked_list": []}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/core/test_db.py", "chunked_list": []}
{"filename": "tests/core/test_redis.py", "chunked_list": []}
{"filename": "tests/core/__init__.py", "chunked_list": []}
{"filename": "tests/worker/test_lock.py", "chunked_list": ["from core.task.decorators import lock_task\n\tdef test_lock_task():\n\t    @lock_task\n\t    def example():\n\t        return True\n\t    assert example(task_lock_key=\"netorc_test\")\n\t    assert example()\n"]}
{"filename": "tests/worker/__init__.py", "chunked_list": []}
{"filename": "core/__init__.py", "chunked_list": []}
{"filename": "core/task/lock.py", "chunked_list": ["\"\"\"\n\ttask_lock.py\n\t\"\"\"\n\timport time\n\timport uuid\n\timport redis\n\tfrom core.addons.exceptions import TaskLockAddError\n\tfrom core.metrics.logging import logger\n\tfrom settings import settings\n\tclass TaskLock:\n", "    \"\"\"Distributed lock mechanism to Add/Remove lock on a task\"\"\"\n\t    def __init__(self, task_lock_key: str = None, timeout: int = 30):\n\t        try:\n\t            self.conn = redis.from_url(settings.redis)\n\t            self.conn.ping()\n\t            logger.info(\"Connected to redis instance: %s\", settings.redis)\n\t        except redis.exceptions.ConnectionError as exc:\n\t            logger.critical(\n\t                \"An exception occurred connecting to redis instance: %s\",\n\t                settings.redis,\n", "            )\n\t            raise exc\n\t        self.task_lock_key = \"lock:\" + task_lock_key\n\t        self.uid = str(uuid.uuid4())\n\t        self.timeout = timeout\n\t    def add(self):\n\t        \"\"\"Add the lock\n\t        :returns: True\n\t        \"\"\"\n\t        end = time.time() + self.timeout\n", "        while time.time() < end:\n\t            try:\n\t                if self.conn.setnx(self.task_lock_key, self.uid):\n\t                    logger.info(\"Added %s with uid: %s\", self.task_lock_key, self.uid)\n\t                    return True\n\t                time.sleep(0.01)\n\t            except Exception as exc:\n\t                logger.error(\n\t                    \"An exception occurred adding %s with uid %s\",\n\t                    self.task_lock_key,\n", "                    self.uid,\n\t                )\n\t                raise exc\n\t        raise TaskLockAddError\n\t    def remove(self):\n\t        \"\"\"Remove the lock\n\t        :returns: True\n\t        \"\"\"\n\t        pipe = self.conn.pipeline(True)\n\t        while True:\n", "            try:\n\t                pipe.watch(self.task_lock_key)\n\t                if self.conn.get(self.task_lock_key).decode(\"utf-8\") == self.uid:\n\t                    pipe.multi()\n\t                    pipe.delete(self.task_lock_key)\n\t                    pipe.execute()\n\t                    logger.info(\"Removed %s with uid: %s\", self.task_lock_key, self.uid)\n\t                    return True\n\t                pipe.unwatch()\n\t                break\n", "            except redis.exceptions.WatchError as exc:\n\t                logger.critical(\n\t                    \"Key changed during transaction, failed to remove %s with uid: %s\",\n\t                    self.task_lock_key,\n\t                    self.uid,\n\t                )\n\t                raise exc\n"]}
{"filename": "core/task/decorators.py", "chunked_list": ["\"\"\"\n\tdecorators.py\n\t\"\"\"\n\tfrom functools import wraps\n\tfrom core.addons.exceptions import TaskLockAddError\n\tfrom core.metrics.logging import logger\n\tfrom core.task.lock import TaskLock\n\tdef lock_task(func):\n\t    \"\"\"Applied to tasks which require synchronous execution.\n\t    Workers will acquire a lock on the task before execution.\n", "    \"\"\"\n\t    @wraps(func)\n\t    def wrapper(*args, **kwargs):\n\t        if \"task_lock_key\" in kwargs:\n\t            task_lock_key = kwargs.get(\"task_lock_key\")\n\t            logger.debug(\n\t                \"Found task lock key for %s, using: %s as key\",\n\t                func.__name__,\n\t                task_lock_key,\n\t            )\n", "            kwargs.pop(\"task_lock_key\")\n\t        else:\n\t            task_lock_key = func.__name__\n\t            logger.debug(\n\t                \"No task lock key found for %s, using: %s as key\",\n\t                func.__name__,\n\t                task_lock_key,\n\t            )\n\t        try:\n\t            try:\n", "                lock = TaskLock(task_lock_key)\n\t            except Exception as exc:\n\t                raise exc\n\t            lock.add()\n\t        except TaskLockAddError as exc:\n\t            logger.error(\n\t                \"Unable to add lock for task: %s, with key: %s\",\n\t                func.__name__,\n\t                task_lock_key,\n\t            )\n", "            raise exc\n\t        try:\n\t            return func(*args, **kwargs)\n\t        except Exception as exc:\n\t            logger.error(\"An exception occurred when executing: %s\", func.__name__)\n\t            raise exc\n\t        finally:\n\t            try:\n\t                lock.remove()\n\t            except Exception as exc:\n", "                raise exc\n\t    return wrapper\n\tdef queue_task(func, priority: int = 0, *args, **kwargs):\n\t    \"\"\"Applied to tasks. Allows the calling of a Celery task\n\t    and its arguments to be abstracted.\n\t    \"\"\"\n\t    @wraps(func)\n\t    def wrapper():\n\t        try:\n\t            getattr(func, \"apply_async\")\n", "        except Exception as exc:\n\t            logger.error(\n\t                \"Function %s is not a celery task, have you missed a decorator?\",\n\t                func.__name__,\n\t            )\n\t            raise exc\n\t        try:\n\t            task = func.apply_async(args=[*args], kwargs={**kwargs}, priority=priority)\n\t            return task\n\t        except Exception as exc:\n", "            logger.error(\"An exception occurred when queuing: %s\", func.__name__)\n\t            raise exc\n\t    return wrapper()\n"]}
{"filename": "core/task/__init__.py", "chunked_list": []}
{"filename": "core/security/secret.py", "chunked_list": ["def validator(secret: str) -> bool:\n\t    \"\"\"\n\t    Validates a secret string meets security conditions.\n\t    Args:\n\t        secret: string.\n\t    Returns:\n\t        False, if a condition is not met.\n\t        True, if all conditions are met.\n\t    \"\"\"\n\t    special_characters = \"!#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\"\n", "    if len(secret) <= 8:\n\t        return False\n\t    if not any(x.isupper() for x in secret):\n\t        return False\n\t    if not any(x.isdigit() for x in secret):\n\t        return False\n\t    if not any(x in special_characters for x in secret):\n\t        return False\n\t    return True\n"]}
{"filename": "core/security/__init__.py", "chunked_list": []}
{"filename": "core/security/user.py", "chunked_list": ["from typing import Callable\n\tfrom passlib.hash import pbkdf2_sha256\n\tfrom core import db\n\tfrom core.db.tables import User\n\tfrom core.metrics.logging import logger\n\tdef create_user(user: User, session: Callable = db.get_session):\n\t    \"\"\"\n\t    Creates a new database user based on User object.\n\t    Hashes user password and api key using SHA256.\n\t    Args:\n", "        user: User object\n\t        session: database session\n\t    Returns:\n\t        user: database user object\n\t    \"\"\"\n\t    user.password = pbkdf2_sha256.hash(user.password)\n\t    user.api_key = pbkdf2_sha256.hash(user.api_key)\n\t    with session() as _session:\n\t        try:\n\t            _session.add(user)\n", "            _session.commit()\n\t            logger.info(\"User: %s, created\", user.username)\n\t            return user\n\t        except Exception as exc:\n\t            raise\n"]}
{"filename": "core/metrics/__init__.py", "chunked_list": []}
{"filename": "core/metrics/logging.py", "chunked_list": ["\"\"\"\n\tlogger.py\n\t\"\"\"\n\timport logging.handlers\n\tfrom settings import settings\n\tlogger = logging.getLogger(__name__)\n\tlogger.setLevel(settings.log_level)\n\tformatter = logging.Formatter(settings.log_format)\n\tif settings.log_console is True:\n\t    console = logging.StreamHandler()\n", "    console.setFormatter(formatter)\n\t    logger.addHandler(console)\n\tif settings.log_file is True:\n\t    file = logging.handlers.RotatingFileHandler(\n\t        filename=\"logs/netorc.log\", mode=\"w\", maxBytes=10000000, backupCount=5\n\t    )\n\t    file.setFormatter(formatter)\n\t    logger.addHandler(file)\n\tif settings.log_syslog is True:\n\t    syslog = logging.handlers.SysLogHandler(\n", "        address=(settings.syslog_server, settings.syslog_port)\n\t    )\n\t    syslog.setFormatter(formatter)\n\t    logger.addHandler(syslog)\n"]}
{"filename": "core/addons/__init__.py", "chunked_list": []}
{"filename": "core/addons/celery.py", "chunked_list": ["\"\"\"\n\tcelery.py\n\t\"\"\"\n\tfrom celery import Celery\n\tfrom settings import settings, tasks\n\tcelery = Celery(include=tasks)\n\t# Time\n\tcelery.conf.timezone = settings.timezone\n\tcelery.conf.enable_utc = settings.utc\n\t# Broker & Backend\n", "celery.conf.broker_url = settings.redis\n\tcelery.conf.result_backend = settings.redis\n\t# Censored\n\tcelery.conf.humanize(with_defaults=False, censored=settings.censored)\n\tcelery.conf.table(with_defaults=False, censored=settings.censored)\n\t# Priorities\n\tcelery.conf.broker_transport_options = {\n\t    \"priority_steps\": list(range(settings.priority_levels)),\n\t    \"sep\": \":\",\n\t    \"queue_order_strategy\": \"priority\",\n", "}\n\tif __name__ == \"__main__\":\n\t    celery.start()\n"]}
{"filename": "core/addons/exceptions.py", "chunked_list": ["\"\"\"\n\texceptions.py\n\t\"\"\"\n\tclass APIError(Exception):\n\t    def __init__(\n\t            self,\n\t            status_code: int,\n\t            code: str,\n\t            reason: str,\n\t            message: str = None,\n", "            reference_error: str = None,\n\t    ):\n\t        self.status_code = status_code\n\t        self.code = code\n\t        self.reason = reason\n\t        self.message = message\n\t        self.reference_error = reference_error\n\tclass TaskLockAddError(Exception):\n\t    def __init__(self):\n\t        self.message = (\n", "            \"Unable to add lock to task. A task using the same key is running.\"\n\t        )\n\t        super().__init__(self.message)\n"]}
{"filename": "core/db/models.py", "chunked_list": ["\"\"\"\n\tmodels.py\n\t\"\"\"\n\tfrom datetime import datetime\n\tfrom typing import Optional\n\tfrom sqlmodel import SQLModel\n\tclass UserCreate(SQLModel):\n\t    firstname: Optional[str]\n\t    lastname: Optional[str]\n\t    email: Optional[str]\n", "    username: str\n\t    password: str\n\t    api_key: str\n\tclass UserRead(SQLModel):\n\t    firstname: Optional[str]\n\t    lastname: Optional[str]\n\t    email: Optional[str]\n\t    username: str\n\t    created: datetime\n\t    last_updated: datetime\n"]}
{"filename": "core/db/__init__.py", "chunked_list": ["from contextlib import contextmanager\n\tfrom sqlmodel import create_engine, Session\n\tfrom settings import settings\n\tengine = create_engine(settings.database, echo=True)\n\tdef require_db_session():\n\t    with Session(engine) as session:\n\t        try:\n\t            yield session\n\t        except Exception:\n\t            session.rollback()\n", "            raise\n\t        finally:\n\t            session.close()\n\t@contextmanager\n\tdef get_session():\n\t    with Session(engine) as session:\n\t        try:\n\t            yield session\n\t        except Exception:\n\t            session.rollback()\n", "            raise\n\t        finally:\n\t            session.close()\n"]}
{"filename": "core/db/tables.py", "chunked_list": ["\"\"\"\n\ttables.py\n\t\"\"\"\n\tfrom datetime import datetime\n\tfrom typing import Optional\n\tfrom sqlmodel import Field, SQLModel\n\tclass User(SQLModel, table=True):\n\t    username: str = Field(index=True, primary_key=True)\n\t    firstname: Optional[str]\n\t    lastname: Optional[str]\n", "    email: Optional[str]\n\t    password: str\n\t    api_key: str\n\t    created: datetime = Field(default_factory=datetime.utcnow, nullable=False)\n\t    last_updated: datetime = Field(default_factory=datetime.utcnow, nullable=False)\n\tclass Service(SQLModel, table=True):\n\t    id: str = Field(primary_key=True)\n\t    name: str = Field(index=True)\n\t    description: str = Field(max_length=256, default=None)\n\t    service_type: Optional[str] = Field(default=None, foreign_key=\"servicetype.name\", nullable=True)\n", "    service_resource: Optional[str] = Field(default=None)\n\t    category: str  # Customer facing or resource facing services\n\t    state: str = Field(index=True)  # States include, inactive, active and terminated\n\t    start_date: datetime\n\t    end_date: datetime = Field(default=None)\n\t    href: str\n\tclass ServiceType(SQLModel, table=True):\n\t    id: str = Field(primary_key=True)\n\t    name: str = Field(index=True, unique=True)\n\t    description: str = Field(max_length=256, default=None)\n", "    version: Optional[int] = Field(default=None)  # Service specific version\n\t    href: str\n"]}
{"filename": "core/db/migrate.py", "chunked_list": ["from sqlmodel import SQLModel\n\tfrom core import db\n\tfrom core.metrics.logging import logger\n\tdef migrate() -> bool:\n\t    try:\n\t        SQLModel.metadata.create_all(db.engine)\n\t        logger.info(\"Successfully migrated tables to database\")\n\t        return True\n\t    except Exception as exc:\n\t        logger.error(\"Error migrating tables to database: %s\", exc)\n", "        raise\n"]}
{"filename": "api/main.py", "chunked_list": ["from fastapi import FastAPI, Request\n\tfrom fastapi.responses import JSONResponse, HTMLResponse\n\tfrom fastapi.staticfiles import StaticFiles\n\tfrom api.services import service, admin\n\tfrom core.addons.exceptions import APIError\n\tfastapi = FastAPI(title=\"NetORC\", version=\"pre-release\")\n\t# from api.headers import require_general_authentication_header\n\t# dependencies=[require_general_authentication_header]\n\tfastapi.include_router(service.router)\n\tfastapi.include_router(admin.router)\n", "fastapi.mount(\"/static\", StaticFiles(directory=\"api/landing/page\"))\n\t@fastapi.exception_handler(APIError)\n\tasync def exception_handler(request: Request, exc: APIError):\n\t    \"\"\"\n\t    Exception handler for APIError. Ensures meaningful errors are sent to users/systems.\n\t    Args:\n\t        request: The request object.\n\t        exc: APIException object.\n\t    Returns:\n\t        A json response body using attributes of the exc object.\n", "    \"\"\"\n\t    # Optional attributes\n\t    if None not in (\n\t            exc.message,\n\t            exc.reference_error,\n\t    ):\n\t        return JSONResponse(\n\t            status_code=exc.status_code,\n\t            content={\n\t                \"code\": exc.code,\n", "                \"reason\": exc.reason,\n\t                \"message\": exc.message,\n\t                \"status\": exc.status_code,\n\t                \"referenceError\": exc.reference_error,\n\t            },\n\t        )\n\t    # Mandatory attributes\n\t    return JSONResponse(\n\t        status_code=exc.status_code,\n\t        content={\"code\": exc.code, \"reason\": exc.reason},\n", "    )\n\t@fastapi.get(\"/\", response_class=HTMLResponse)\n\tasync def landing_page():\n\t    with open(\"api/landing/page/html/landing.html\", \"r\") as html:\n\t        return html.read()\n"]}
{"filename": "api/headers.py", "chunked_list": ["from typing import Any\n\tfrom fastapi import Response, Depends, Security\n\tfrom fastapi.security.api_key import APIKeyHeader\n\tfrom passlib.hash import pbkdf2_sha256\n\tfrom sqlmodel import Session, select\n\tfrom core.addons.exceptions import APIError\n\tfrom core.db import require_db_session\n\tfrom core.db.tables import User\n\tfrom settings import settings\n\tasync def general_http_headers(response: Response) -> Any:\n", "    \"\"\"\n\t    Adds keys,values to response headers. E.g, Cache-Control\n\t    Args:\n\t        response: starlette response object\n\t    Returns:\n\t        None\n\t    \"\"\"\n\t    response.headers[\"cache-control\"] = \"no-cache, no-store\"\n\trequire_general_http_headers = Depends(general_http_headers)\n\tapi_key_header = APIKeyHeader(name=settings.api_key_header, auto_error=False)\n", "def general_authentication_header(api_key: str = Security(api_key_header),\n\t                                  session: Session = Depends(require_db_session)) -> Any:\n\t    \"\"\"\n\t    Retrieves api key in request header and checks api key exists in user db.\n\t    Args:\n\t        api_key: request api key\n\t        session: db session dependency.\n\t    Raises:\n\t        APIException: 401 and 500 status codes.\n\t    \"\"\"\n", "    try:\n\t        if not api_key:\n\t            raise APIError(status_code=401, code=\"General Authentication Header\", reason=\"Unauthorised request\")\n\t        query = select(User)\n\t        result = session.exec(query).all()\n\t        check = [x.api_key for x in result if\n\t                 x.api_key.startswith(\"$pbkdf2-sha256\") and pbkdf2_sha256.verify(api_key, x.api_key)]\n\t        if not check:\n\t            raise APIError(status_code=401, code=\"General Authentication Header\", reason=\"Unauthorised request\")\n\t    except APIError:\n", "        raise\n\t    except Exception as exc:\n\t        raise APIError(status_code=500, code=\"General Authentication Header\", reason=\"Runtime error occurred\") from exc\n\trequire_general_authentication_header = Depends(general_authentication_header)\n"]}
{"filename": "api/__init__.py", "chunked_list": []}
{"filename": "api/services/__init__.py", "chunked_list": []}
{"filename": "api/services/admin.py", "chunked_list": ["from typing import List\n\tfrom fastapi import APIRouter, Depends\n\tfrom sqlmodel import Session, select\n\tfrom core import db\n\tfrom core.addons.exceptions import APIError\n\tfrom core.db.models import UserRead, UserCreate\n\tfrom core.db.tables import User\n\tfrom core.security.user import create_user\n\trouter = APIRouter(prefix=\"/api/admin/v1\", tags=[\"Administration\"])\n\t@router.get(\"/users\", response_model=List[UserRead])\n", "def get_users(username: str = None, session: Session = Depends(db.require_db_session)) -> list:\n\t    \"\"\"\n\t    Returns a list of user/'s from the db.\n\t    Args:\n\t        username: an optional username filter.\n\t        session: db session dependency.\n\t    Returns:\n\t        Dictionary/s enclosed in a list containing attributes for a user/s.\n\t    Raises:\n\t        APIException: 500 status code.\n", "    \"\"\"\n\t    try:\n\t        if username is not None:\n\t            user = session.get(User, username)\n\t            if not user:\n\t                raise APIError(status_code=404, code=\"Get Users\", reason=\"User not found\")\n\t            return [user]\n\t        query = select(User)\n\t        result = session.exec(query)\n\t        users = [x for x in result]\n", "        if not users:\n\t            raise APIError(status_code=404, code=\"Get Users\", reason=\"No users found\")\n\t    except APIError:\n\t        raise\n\t    except Exception as exc:\n\t        raise APIError(status_code=500, code=\"Get Users\", reason=\"Runtime error occurred\") from exc\n\t@router.post(\"/users\", response_model=UserRead)\n\tdef post_users(user_create: UserCreate):\n\t    \"\"\"\n\t    Creates new users.\n", "    Args:\n\t        user_create: UserCreate object.\n\t    Returns:\n\t        db_user: database User object.\n\t    Raises:\n\t        APIException: 500 status code.\n\t    \"\"\"\n\t    user = User()\n\t    user_data = user_create.dict(exclude_unset=True)\n\t    for k, v in user_data.items():\n", "        setattr(user, k, v)\n\t    try:\n\t        db_user = create_user(user)\n\t        return db_user\n\t    except Exception as exc:\n\t        raise APIError(status_code=500, code=\"Post User\", reason=\"Runtime error occurred\") from exc\n\t@router.patch(\"/users\")\n\tdef patch_users():\n\t    pass\n\t@router.delete(\"/users\")\n", "def delete_users():\n\t    pass\n"]}
{"filename": "api/services/service.py", "chunked_list": ["\"\"\"\n\tservice.py\n\t\"\"\"\n\tfrom typing import List\n\tfrom fastapi import APIRouter, Depends\n\tfrom sqlmodel import Session, select\n\tfrom core.addons.exceptions import APIError\n\tfrom core.db import require_db_session\n\tfrom core.db.tables import Service\n\trouter = APIRouter(\n", "    prefix=\"/api/services/v1\",\n\t    tags=[\"Services\"],\n\t)\n\t@router.get(\"/service\", response_model=List[Service])\n\tdef get_services(id: str = None, session: Session = Depends(require_db_session)) -> list:\n\t    \"\"\"\n\t    Returns a list of service/'s from the db.\n\t    Args:\n\t        id: an optional service id filter.\n\t        session: db session dependency.\n", "    Returns:\n\t        A list of dictionary/s containing attributes for a service.\n\t    Raises:\n\t        APIException: 500 status code.\n\t    \"\"\"\n\t    try:\n\t        if id is not None:\n\t            service = session.get(Service, id)\n\t            if not service:\n\t                raise APIError(status_code=404, code=\"Get Services\", reason=\"Service not found\")\n", "            return [service]\n\t        query = select(Service)\n\t        result = session.exec(query)\n\t        services = [x for x in result]\n\t        if not services:\n\t            raise APIError(status_code=404, code=\"Get Services\", reason=\"No services found\")\n\t        return services\n\t    except APIError:\n\t        raise\n\t    except Exception as exc:\n", "        raise APIError(status_code=500, code=\"Get Services\", reason=\"Runtime error occurred\") from exc\n\t@router.post(\"/service\", response_model=List[Service])\n\tasync def post_services(service: Service) -> list:\n\t    \"\"\"\n\t    Creates new service/s. The service/s is added to the db once the task completes.\n\t    Args:\n\t    Returns:\n\t    Raises:\n\t    \"\"\"\n\t    return []\n", "@router.patch(\"/service/{id}\", response_model=Service)\n\tasync def patch_services(id: int) -> list:\n\t    \"\"\"\n\t    Amend a service. The service is updated in the db once the task completes.\n\t    Args:\n\t    Returns:\n\t    Raises:\n\t    \"\"\"\n\t    return []\n\t@router.delete(\"/service/{id}\", response_model=Service)\n", "async def delete_services(id: int) -> list:\n\t    \"\"\"\n\t    Remove a service. The service is deleted in the db once the task completes.\n\t    Args:\n\t    Returns:\n\t    Raises:\n\t    \"\"\"\n\t    return []\n"]}
{"filename": "worker/__init__.py", "chunked_list": []}
{"filename": "worker/tasks/example.py", "chunked_list": ["\"\"\"\n\texample.py\n\t`lock_task` can be used to ensure tasks are executed\n\tsynchronously with each worker obtaining the lock before \n\texecuting the task. \n\tfor more information, see <link>\n\t\"\"\"\n\timport time\n\tfrom core.addons.celery import celery\n\tfrom core.task.decorators import lock_task\n", "@celery.task()\n\t@lock_task\n\tdef example_task() -> None:\n\t    print(\"Starting task\")\n\t    time.sleep(2)\n\t    print(\"Finished task\")\n\t    return 8\n"]}
{"filename": "worker/tasks/__init__.py", "chunked_list": []}
