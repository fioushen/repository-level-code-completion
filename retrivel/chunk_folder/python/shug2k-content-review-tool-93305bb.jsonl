{"filename": "cr-backend/manage.py", "chunked_list": ["#!/usr/bin/env python\n\t\"\"\"Django's command-line utility for administrative tasks.\"\"\"\n\timport os\n\timport sys\n\tdef main():\n\t    \"\"\"Run administrative tasks.\"\"\"\n\t    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'cr.settings')\n\t    try:\n\t        from django.core.management import execute_from_command_line\n\t    except ImportError as exc:\n", "        raise ImportError(\n\t            \"Couldn't import Django. Are you sure it's installed and \"\n\t            \"available on your PYTHONPATH environment variable? Did you \"\n\t            \"forget to activate a virtual environment?\"\n\t        ) from exc\n\t    execute_from_command_line(sys.argv)\n\tif __name__ == '__main__':\n\t    main()\n"]}
{"filename": "cr-backend/cr/settings.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\t\"\"\"\n\tDjango settings for cr project.\n\tGenerated by 'django-admin startproject' using Django 4.2.2.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/4.2/topics/settings/\n\tFor the full list of settings and their values, see\n\thttps://docs.djangoproject.com/en/4.2/ref/settings/\n\t\"\"\"\n", "from pathlib import Path\n\t# Build paths inside the project like this: BASE_DIR / 'subdir'.\n\tBASE_DIR = Path(__file__).resolve().parent.parent\n\t# Quick-start development settings - unsuitable for production\n\t# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/\n\t# SECURITY WARNING: keep the secret key used in production secret!\n\tSECRET_KEY = \"django-insecure-9-m1*9j-4nfl-2sish!7lwxno98=uor^$70#-7i&w#5-iudysb\"\n\t# SECURITY WARNING: don't run with debug turned on in production!\n\tDEBUG = True\n\tALLOWED_HOSTS = []\n", "# Application definition\n\tINSTALLED_APPS = [\n\t    \"api.apps.ApiConfig\",\n\t    \"corsheaders\",\n\t    \"django.contrib.admin\",\n\t    \"django.contrib.auth\",\n\t    \"django.contrib.contenttypes\",\n\t    \"django.contrib.sessions\",\n\t    \"django.contrib.messages\",\n\t    \"django.contrib.staticfiles\",\n", "]\n\tMIDDLEWARE = [\n\t    \"corsheaders.middleware.CorsMiddleware\",\n\t    \"django.middleware.security.SecurityMiddleware\",\n\t    \"django.contrib.sessions.middleware.SessionMiddleware\",\n\t    \"django.middleware.common.CommonMiddleware\",\n\t    #'django.middleware.csrf.CsrfViewMiddleware',\n\t    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n\t    \"django.contrib.messages.middleware.MessageMiddleware\",\n\t    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n", "]\n\tROOT_URLCONF = \"cr.urls\"\n\tTEMPLATES = [\n\t    {\n\t        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n\t        \"DIRS\": [],\n\t        \"APP_DIRS\": True,\n\t        \"OPTIONS\": {\n\t            \"context_processors\": [\n\t                \"django.template.context_processors.debug\",\n", "                \"django.template.context_processors.request\",\n\t                \"django.contrib.auth.context_processors.auth\",\n\t                \"django.contrib.messages.context_processors.messages\",\n\t            ],\n\t        },\n\t    },\n\t]\n\tWSGI_APPLICATION = \"cr.wsgi.application\"\n\tCORS_ORIGIN_ALLOW_ALL = True\n\t# Database\n", "# https://docs.djangoproject.com/en/4.2/ref/settings/#databases\n\tDATABASES = {\n\t    \"default\": {\n\t        \"ENGINE\": \"django.db.backends.postgresql\",\n\t        \"NAME\": \"cr\",\n\t        \"USER\": \"admin\",\n\t        \"PASSWORD\": \"admin\",\n\t        \"HOST\": \"localhost\",\n\t        \"PORT\": \"5432\",\n\t    }\n", "}\n\t# Password validation\n\t# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators\n\tAUTH_PASSWORD_VALIDATORS = [\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n\t    },\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n\t    },\n", "    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n\t    },\n\t    {\n\t        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n\t    },\n\t]\n\t# Internationalization\n\t# https://docs.djangoproject.com/en/4.2/topics/i18n/\n\tLANGUAGE_CODE = \"en-us\"\n", "TIME_ZONE = \"America/Los_Angeles\"\n\tUSE_I18N = True\n\tUSE_TZ = True\n\t# Static files (CSS, JavaScript, Images)\n\t# https://docs.djangoproject.com/en/4.2/howto/static-files/\n\tSTATIC_URL = \"static/\"\n\t# Default primary key field type\n\t# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field\n\tDEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"\n"]}
{"filename": "cr-backend/cr/urls.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\t\"\"\"\n\tURL configuration for cr project.\n\tThe `urlpatterns` list routes URLs to views. For more information please see:\n\t    https://docs.djangoproject.com/en/4.2/topics/http/urls/\n\tExamples:\n\tFunction views\n\t    1. Add an import:  from my_app import views\n\t    2. Add a URL to urlpatterns:  path('', views.home, name='home')\n", "Class-based views\n\t    1. Add an import:  from other_app.views import Home\n\t    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\n\tIncluding another URLconf\n\t    1. Import the include() function: from django.urls import include, path\n\t    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\t\"\"\"\n\tfrom django.contrib import admin\n\tfrom django.urls import include, path\n\turlpatterns = [\n", "    path(\"\", include(\"api.urls\")),\n\t    path(\"admin/\", admin.site.urls),\n\t]\n"]}
{"filename": "cr-backend/cr/__init__.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n"]}
{"filename": "cr-backend/cr/asgi.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\t\"\"\"\n\tASGI config for cr project.\n\tIt exposes the ASGI callable as a module-level variable named ``application``.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/4.2/howto/deployment/asgi/\n\t\"\"\"\n\timport os\n\tfrom django.core.asgi import get_asgi_application\n", "os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"cr.settings\")\n\tapplication = get_asgi_application()\n"]}
{"filename": "cr-backend/cr/wsgi.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\t\"\"\"\n\tWSGI config for cr project.\n\tIt exposes the WSGI callable as a module-level variable named ``application``.\n\tFor more information on this file, see\n\thttps://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/\n\t\"\"\"\n\timport os\n\tfrom django.core.wsgi import get_wsgi_application\n", "os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"cr.settings\")\n\tapplication = get_wsgi_application()\n"]}
{"filename": "cr-backend/tests/test_review_routes.py", "chunked_list": ["import pytest\n\timport json\n\tfrom api.models import DecisionTreeCR, ReviewCR\n\t@pytest.mark.django_db\n\tdef test_get_review_route(client, text_review):\n\t    response = client.get(\"/review/\" + str(text_review.id))\n\t    data = json.loads(response.content)\n\t    assert response.status_code == 200\n\t    assert data[\"entity_id\"] == text_review.entity_id\n\t    assert data[\"entity_type\"] == \"text\"\n", "    assert data[\"entity_content\"] == text_review.entity_content\n\t    assert data[\"user_id\"] == text_review.user_id\n\t    assert data[\"user_email\"] == text_review.user_email\n\t    assert data[\"user_phone_number\"] == text_review.user_phone_number\n\t    assert data[\"queue_id\"] == text_review.queue.id\n\t    assert data[\"prev_review_id\"] is None\n\t    assert data[\"next_review_id\"] is None\n\t    assert (\n\t        data[\"decision_tree\"][\"start_question_tag\"]\n\t        == DecisionTreeCR.default_decision_tree()[\"start_question_tag\"]\n", "    )\n\t@pytest.mark.django_db\n\tdef test_get_review_route_pulls_tree(client, text_review_q2, base_decision_tree):\n\t    response = client.get(\"/review/\" + str(text_review_q2.id))\n\t    data = json.loads(response.content)\n\t    assert response.status_code == 200\n\t    # assumes queue_2 has base_decision_tree (see conftest.py for setup)\n\t    assert (\n\t        data[\"decision_tree\"][\"start_question_tag\"]\n\t        == base_decision_tree.tree[\"start_question_tag\"]\n", "    )\n\t@pytest.mark.django_db\n\tdef test_get_review_route_has_next(client, text_review, image_review):\n\t    response = client.get(\"/review/\" + str(text_review.id))\n\t    data = json.loads(response.content)\n\t    # note: the following is dependent on image_review being created after text_review\n\t    assert response.status_code == 200\n\t    assert data[\"prev_review_id\"] is None\n\t    assert data[\"next_review_id\"] == image_review.id\n\t@pytest.mark.django_db\n", "def test_get_review_route_has_prev(client, text_review, image_review):\n\t    response = client.get(\"/review/\" + str(image_review.id))\n\t    data = json.loads(response.content)\n\t    # note: the following is dependent on image_review being created after text_review\n\t    assert response.status_code == 200\n\t    assert data[\"prev_review_id\"] == text_review.id\n\t    assert data[\"next_review_id\"] is None\n\t@pytest.mark.django_db\n\tdef test_get_review_route_wrong_review(client, text_review):\n\t    response = client.get(\"/review/\" + str(text_review.id + 102315))\n", "    assert response.status_code == 404\n\t    assert (\n\t        response.content.decode()\n\t        == f\"Review ID {text_review.id + 102315} does not exist on this server\"\n\t    )\n\t@pytest.mark.django_db\n\tdef test_create_review_route(client, queue_1):\n\t    response = client.post(\n\t        \"/create-review\",\n\t        {\n", "            \"entity_id\": \"123\",\n\t            \"entity_type\": \"image\",\n\t            \"entity_content\": \"http://www.image.com/something\",\n\t            \"queue_name\": queue_1.name,\n\t        },\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 200\n\t    review = ReviewCR.objects.get(entity_id=\"123\")\n\t    assert review.entity_type == \"image\"\n", "    assert review.entity_content == \"http://www.image.com/something\"\n\t    assert review.queue.id == queue_1.id\n\t@pytest.mark.django_db\n\tdef test_create_review_route_wrong_entity_type(client, queue_1):\n\t    response = client.post(\n\t        \"/create-review\",\n\t        {\n\t            \"entity_id\": \"125\",\n\t            \"entity_type\": \"img\",\n\t            \"entity_content\": \"http://www.image.com/something\",\n", "            \"queue_name\": queue_1.name,\n\t        },\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n\t    assert \"'img' is not a valid choice\" in response.content.decode()\n\t@pytest.mark.django_db\n\tdef test_create_review_route_content_not_url_for_image(client, queue_1):\n\t    response = client.post(\n\t        \"/create-review\",\n", "        {\n\t            \"entity_id\": \"125\",\n\t            \"entity_type\": \"image\",\n\t            \"entity_content\": \"Some random text\",\n\t            \"queue_name\": queue_1.name,\n\t        },\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n\t    assert (\n", "        response.content.decode()\n\t        == \"For entity_type 'image', entity_content must be a valid URL!\"\n\t    )\n\t@pytest.mark.django_db\n\tdef test_create_review_route_missing_queue(client, queue_1):\n\t    response = client.post(\n\t        \"/create-review\",\n\t        {\n\t            \"entity_id\": \"125\",\n\t            \"entity_type\": \"image\",\n", "            \"entity_content\": \"Some random text\",\n\t        },\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n\t    assert (\n\t        response.content.decode()\n\t        == \"Review requires an entity_type, entity_content, and queue_name\"\n\t    )\n\t@pytest.mark.django_db\n", "def test_create_review_route_wrong_queue(client, queue_1):\n\t    response = client.post(\n\t        \"/create-review\",\n\t        {\n\t            \"entity_id\": \"125\",\n\t            \"entity_type\": \"image\",\n\t            \"entity_content\": \"Some random text\",\n\t            \"queue_name\": \"Random queue\",\n\t        },\n\t        content_type=\"application/json\",\n", "    )\n\t    assert response.status_code == 400\n\t    assert response.content.decode() == \"queue 'Random queue' does not exist!\"\n\t@pytest.mark.django_db\n\tdef test_modify_review_route(client, text_review, queue_2):\n\t    response = client.post(\n\t        \"/modify-review/\" + str(text_review.id),\n\t        {\n\t            \"entity_id\": \"128\",\n\t            \"entity_type\": \"image\",\n", "            \"entity_content\": \"http://www.image.com/test\",\n\t            \"user_id\": \"100\",\n\t            \"user_name\": \"Jane Doe\",\n\t            \"user_email\": \"jane@doe.com\",\n\t            \"user_phone_number\": \"+17771234567\",\n\t            \"queue_name\": queue_2.name,\n\t        },\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 200\n", "    review = ReviewCR.objects.get(id=text_review.id)\n\t    assert review.entity_id == \"128\"\n\t    assert review.entity_type == \"image\"\n\t    assert review.entity_content == \"http://www.image.com/test\"\n\t    assert review.user_id == \"100\"\n\t    assert review.user_name == \"Jane Doe\"\n\t    assert review.user_email == \"jane@doe.com\"\n\t    assert review.user_phone_number == \"+17771234567\"\n\t    assert review.queue.id == queue_2.id\n\t@pytest.mark.django_db\n", "def test_modify_review_route_wrong_queue(client, text_review):\n\t    response = client.post(\n\t        \"/modify-review/\" + str(text_review.id),\n\t        {\n\t            \"queue_name\": \"Random Queue\",\n\t        },\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n\t    assert response.content.decode() == \"queue 'Random Queue' does not exist!\"\n", "@pytest.mark.django_db\n\tdef test_modify_review_route_missing_review(client):\n\t    response = client.post(\n\t        \"/modify-review/104\",\n\t        {\n\t            \"entity_id\": \"111\",\n\t        },\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n", "    assert response.content.decode() == \"Review 104 does not exist!\"\n\t@pytest.mark.django_db\n\tdef test_modify_review_route_validate_entity_type(client, text_review):\n\t    response = client.post(\n\t        \"/modify-review/\" + str(text_review.id),\n\t        {\n\t            \"entity_type\": \"img\",\n\t        },\n\t        content_type=\"application/json\",\n\t    )\n", "    assert response.status_code == 400\n\t    assert \"is not a valid choice.\" in response.content.decode()\n\t@pytest.mark.django_db\n\tdef test_modify_review_route_image_needs_url(client, text_review):\n\t    response = client.post(\n\t        \"/modify-review/\" + str(text_review.id),\n\t        {\n\t            \"entity_type\": \"image\",\n\t        },\n\t        content_type=\"application/json\",\n", "    )\n\t    assert response.status_code == 400\n\t    assert (\n\t        response.content.decode()\n\t        == \"For entity_type 'image', entity_content must be a valid URL!\"\n\t    )\n\t@pytest.mark.django_db\n\tdef test_review_result_route(client, text_review):\n\t    response = client.post(\n\t        \"/review/\" + str(text_review.id) + \"/store-result\",\n", "        {\n\t            \"questions_with_answers\": [\n\t                {\"questionTag\": \"is_violating\", \"answerTag\": \"yes\"}\n\t            ]\n\t        },\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 200\n\t@pytest.mark.django_db\n\tdef test_review_result_route_wrong_review(client, text_review):\n", "    response = client.post(\n\t        \"/review/\" + str(text_review.id + 102636) + \"/store-result\",\n\t        {\n\t            \"questions_with_answers\": [\n\t                {\"questionTag\": \"is_violating\", \"answerTag\": \"yes\"}\n\t            ]\n\t        },\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n", "    assert (\n\t        response.content.decode() == f\"Review {text_review.id+102636} does not exist!\"\n\t    )\n\t@pytest.mark.django_db\n\tdef test_review_result_route_malformed_input(client, text_review):\n\t    response = client.post(\n\t        \"/review/\" + str(text_review.id) + \"/store-result\",\n\t        {\"questions_with_answers\": {\"questionTag\": \"is_violating\", \"answerTag\": \"yes\"}},\n\t        content_type=\"application/json\",\n\t    )\n", "    assert response.status_code == 400\n\t    assert (\n\t        response.content.decode()\n\t        == \"Request requires questions_with_answers in list format\"\n\t    )\n\t@pytest.mark.django_db\n\tdef test_delete_review_route(client, text_review):\n\t    pre_delete_review = ReviewCR.objects.filter(id=text_review.id).first()\n\t    assert pre_delete_review is not None\n\t    response = client.post(\n", "        \"/delete-review/\" + str(text_review.id),\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 200\n\t    post_delete_review = ReviewCR.objects.filter(id=text_review.id).first()\n\t    assert post_delete_review is None\n\t@pytest.mark.django_db\n\tdef test_delete_review_route_wrong_id(client, text_review):\n\t    response = client.post(\n\t        \"/delete-review/16239\",\n", "        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n\t    assert response.content.decode() == \"Review 16239 does not exist!\"\n"]}
{"filename": "cr-backend/tests/test_decision_tree_routes.py", "chunked_list": ["import pytest\n\tfrom api.models import DecisionTreeCR\n\t@pytest.fixture\n\tdef basic_violating_json_tree():\n\t    return {\n\t        \"start_question_tag\": \"is_violating\",\n\t        \"questions\": [\n\t            {\n\t                \"tag\": \"is_violating\",\n\t                \"text\": \"Is this content violating?\",\n", "                \"answers\": [\n\t                    {\n\t                        \"tag\": \"yes\",\n\t                        \"text\": \"Yes\",\n\t                        \"decision\": \"yes_violating\",\n\t                    },\n\t                    {\n\t                        \"tag\": \"no\",\n\t                        \"text\": \"No\",\n\t                        \"decision\": \"no_violating\",\n", "                    },\n\t                ],\n\t            },\n\t        ],\n\t    }\n\t@pytest.mark.django_db\n\tdef test_create_decision_tree_route(client, basic_violating_json_tree):\n\t    response = client.post(\n\t        \"/create-decision-tree\",\n\t        {\"name\": \"Basic violating\", \"tree\": basic_violating_json_tree},\n", "        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 200\n\t@pytest.mark.django_db\n\tdef test_create_decision_tree_route_empty_tree(client):\n\t    response = client.post(\n\t        \"/create-decision-tree\",\n\t        {\"name\": \"Basic violating\", \"tree\": {}},\n\t        content_type=\"application/json\",\n\t    )\n", "    assert response.status_code == 400\n\t    assert response.content.decode() == \"('tree', ['This field cannot be blank.'])\"\n\t@pytest.mark.django_db\n\tdef test_create_decision_tree_route_duplicate_name(\n\t    client, basic_violating_json_tree, base_decision_tree\n\t):\n\t    response = client.post(\n\t        \"/create-decision-tree\",\n\t        {\"name\": base_decision_tree.name, \"tree\": basic_violating_json_tree},\n\t        content_type=\"application/json\",\n", "    )\n\t    assert response.status_code == 400\n\t    assert \"with this Name already exists\" in response.content.decode()\n\t@pytest.mark.django_db\n\tdef test_modify_decision_tree_route(client, base_decision_tree):\n\t    response = client.post(\n\t        \"/modify-decision-tree/\" + base_decision_tree.name,\n\t        {\"name\": \"Test Decision Tree\"},\n\t        content_type=\"application/json\",\n\t    )\n", "    assert response.status_code == 200\n\t    updated_decision_tree = DecisionTreeCR.objects.get(id=base_decision_tree.id)\n\t    assert updated_decision_tree.name == \"Test Decision Tree\"\n\t@pytest.mark.django_db\n\tdef test_modify_decision_tree_route_wrong_name(client, base_decision_tree):\n\t    response = client.post(\n\t        \"/modify-decision-tree/\" + base_decision_tree.name + \"_random\",\n\t        {\"name\": \"Test Decision Tree\"},\n\t        content_type=\"application/json\",\n\t    )\n", "    assert response.status_code == 400\n\t    assert (\n\t        response.content.decode()\n\t        == f\"Decision tree '{base_decision_tree.name + '_random'}' does not exist!\"\n\t    )\n\t@pytest.mark.django_db\n\tdef test_delete_decision_tree_route(client, base_decision_tree):\n\t    pre_delete_decision_tree = DecisionTreeCR.objects.filter(\n\t        id=base_decision_tree.id\n\t    ).first()\n", "    assert pre_delete_decision_tree is not None\n\t    response = client.post(\n\t        \"/delete-decision-tree/\" + base_decision_tree.name,\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 200\n\t    post_delete_decision_tree = DecisionTreeCR.objects.filter(\n\t        id=base_decision_tree.id\n\t    ).first()\n\t    assert post_delete_decision_tree is None\n", "@pytest.mark.django_db\n\tdef test_delete_decision_tree_route_wrong_name(client, base_decision_tree):\n\t    response = client.post(\n\t        \"/delete-decision-tree/\" + base_decision_tree.name + \"_random\",\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n\t    assert (\n\t        response.content.decode()\n\t        == f\"Decision tree '{base_decision_tree.name+'_random'}' does not exist!\"\n", "    )\n"]}
{"filename": "cr-backend/tests/test_validators.py", "chunked_list": ["import pytest\n\tfrom django.core.exceptions import ValidationError\n\tfrom api import model_validators\n\tclass TestDecisionTreeValidator:\n\t    answer_1 = {\n\t        \"tag\": \"ans1\",\n\t        \"text\": \"Answer 1\",\n\t        \"decision\": None,\n\t        \"next_question_tag\": \"q2\",\n\t    }\n", "    answer_2 = {\n\t        \"tag\": \"ans2\",\n\t        \"text\": \"Answer 2\",\n\t        \"decision\": \"decision1\",\n\t        \"next_question_tag\": None,\n\t    }\n\t    answer_3 = {\n\t        \"tag\": \"ans3\",\n\t        \"text\": \"Answer 3\",\n\t        \"decision\": \"decision2\",\n", "        \"next_question_tag\": None,\n\t    }\n\t    answer_4 = {\n\t        \"tag\": \"ans4\",\n\t        \"text\": \"Answer 4\",\n\t        \"decision\": \"decision3\",\n\t        \"next_question_tag\": None,\n\t    }\n\t    question_1 = {\n\t        \"tag\": \"q1\",\n", "        \"text\": \"Question 1\",\n\t        \"answers\": [answer_1, answer_2],\n\t    }\n\t    question_2 = {\n\t        \"tag\": \"q2\",\n\t        \"text\": \"Question 2\",\n\t        \"answers\": [answer_3, answer_4],\n\t    }\n\t    def test_valid(self):\n\t        decision_tree = {\n", "            \"start_question_tag\": \"q1\",\n\t            \"questions\": [self.question_1, self.question_2],\n\t        }\n\t        model_validators.DecisionTreeValidator.validate_tree(decision_tree)\n\t    def test_miss_start(self):\n\t        decision_tree = {\n\t            \"questions\": [self.question_1, self.question_2],\n\t        }\n\t        with pytest.raises(ValidationError, match=\"missing value\"):\n\t            model_validators.DecisionTreeValidator.validate_tree(decision_tree)\n", "    def test_wrong_start(self):\n\t        decision_tree = {\n\t            \"start_question_tag\": \"w1\",\n\t            \"questions\": [self.question_1, self.question_2],\n\t        }\n\t        with pytest.raises(ValidationError, match=\"not in decision tree\"):\n\t            model_validators.DecisionTreeValidator.validate_tree(decision_tree)\n\t    def test_has_cycle(self):\n\t        question_2_loop = {\n\t            \"tag\": \"q2\",\n", "            \"text\": \"Question 2\",\n\t            \"answers\": [self.answer_1, self.answer_2],\n\t        }\n\t        decision_tree = {\n\t            \"start_question_tag\": \"q1\",\n\t            \"questions\": [self.question_1, question_2_loop],\n\t        }\n\t        with pytest.raises(ValidationError, match=\"decision tree has a cycle\"):\n\t            model_validators.DecisionTreeValidator.validate_tree(decision_tree)\n\t# the cycle testing is more complex, so adding some test cases here\n", "class TestGraphIntegrity:\n\t    def test_topo_sort_base(self):\n\t        start_node = \"q1\"\n\t        g = {\n\t            \"q1\": [\"q2\", \"q3\"],\n\t            \"q2\": [\"q3\", \"q5\"],\n\t            \"q3\": [\"q4\", \"q5\"],\n\t            \"q4\": [],\n\t            \"q5\": [],\n\t        }\n", "        expected_order = [\"q1\", \"q2\", \"q3\", \"q5\", \"q4\"]\n\t        returned_order = model_validators.DecisionTreeValidator.topo_sort(start_node, g)\n\t        for e, r in zip(expected_order, returned_order):\n\t            assert e == r\n\t    def test_topo_sort_small_cycle(self):\n\t        start_node = \"q1\"\n\t        g = {\n\t            \"q1\": [\"q2\"],\n\t            \"q2\": [\"q1\"],\n\t        }\n", "        expected_order = [\"q1\", \"q2\", \"q2\"]\n\t        returned_order = model_validators.DecisionTreeValidator.topo_sort(start_node, g)\n\t        for e, r in zip(expected_order, returned_order):\n\t            assert e == r\n\t    def test_topo_sort_med_cycle(self):\n\t        start_node = \"q1\"\n\t        g = {\n\t            \"q1\": [\"q2\", \"q3\"],\n\t            \"q2\": [\"q3\", \"q5\"],\n\t            \"q3\": [\"q4\", \"q1\"],\n", "            \"q4\": [\"q5\"],\n\t            \"q5\": [],\n\t        }\n\t        expected_order = [\"q1\", \"q2\", \"q3\", \"q4\", \"q5\", \"q1\"]\n\t        returned_order = model_validators.DecisionTreeValidator.topo_sort(start_node, g)\n\t        for e, r in zip(expected_order, returned_order):\n\t            assert e == r\n"]}
{"filename": "cr-backend/tests/conftest.py", "chunked_list": ["import pytest\n\tfrom api.models import QueueCR, DecisionTreeCR, ReviewCR\n\t@pytest.fixture\n\tdef base_decision_tree():\n\t    return DecisionTreeCR.objects.create(\n\t        name=\"test2\",\n\t        tree={\n\t            \"start_question_tag\": \"q1\",\n\t            \"questions\": [\n\t                {\n", "                    \"tag\": \"q1\",\n\t                    \"text\": \"Question 1\",\n\t                    \"answers\": [\n\t                        {\n\t                            \"tag\": \"a1\",\n\t                            \"text\": \"Answer 1\",\n\t                        },\n\t                        {\n\t                            \"tag\": \"a2\",\n\t                            \"text\": \"Answer 2\",\n", "                        },\n\t                    ],\n\t                }\n\t            ],\n\t        },\n\t    )\n\t@pytest.fixture\n\tdef queue_1():\n\t    return QueueCR.objects.create(\n\t        name=\"Test Queue 1\",\n", "    )\n\t@pytest.fixture\n\tdef queue_2(base_decision_tree):\n\t    return QueueCR.objects.create(\n\t        name=\"Test Queue 2\",\n\t        decision_tree=base_decision_tree,\n\t    )\n\t@pytest.fixture\n\tdef text_review(queue_1):\n\t    return ReviewCR.objects.create(\n", "        entity_id=\"1\",\n\t        entity_type=\"text\",\n\t        entity_content=\"Testing out\",\n\t        entity_create_time=\"2023-01-01 12:00:01Z\",\n\t        user_id=\"10\",\n\t        user_name=\"John Doe\",\n\t        user_email=\"john@doe.com\",\n\t        user_phone_number=\"+15555555555\",\n\t        queue=queue_1,\n\t    )\n", "@pytest.fixture\n\tdef text_review_q2(queue_2):\n\t    return ReviewCR.objects.create(\n\t        entity_id=\"2\",\n\t        entity_type=\"text\",\n\t        entity_content=\"Testing out queue 2 with tree\",\n\t        entity_create_time=\"2023-01-03 12:00:01Z\",\n\t        queue=queue_2,\n\t    )\n\t@pytest.fixture\n", "def image_review(queue_1):\n\t    return ReviewCR.objects.create(\n\t        entity_id=\"3\",\n\t        entity_type=\"image\",\n\t        entity_content=\"http://www.image.com/test\",\n\t        entity_create_time=\"2023-02-01 01:00:01Z\",\n\t        queue=queue_1,\n\t    )\n"]}
{"filename": "cr-backend/tests/test_queue_routes.py", "chunked_list": ["import pytest\n\timport json\n\tfrom api.models import QueueCR\n\t@pytest.mark.django_db\n\tdef test_queues_route(client, queue_1, queue_2):\n\t    response = client.get(\"/queues\")\n\t    data = json.loads(response.content)\n\t    assert response.status_code == 200\n\t    assert data[\"queues\"][0][\"name\"] == queue_1.name\n\t    assert data[\"queues\"][1][\"name\"] == queue_2.name\n", "@pytest.mark.django_db\n\tdef test_create_queue_route_no_tree(client):\n\t    response = client.post(\n\t        \"/create-queue\", {\"name\": \"test1\"}, content_type=\"application/json\"\n\t    )\n\t    assert response.status_code == 200\n\t@pytest.mark.django_db\n\tdef test_create_queue_route_with_tree(client, base_decision_tree):\n\t    response = client.post(\n\t        \"/create-queue\",\n", "        {\"name\": \"test1\", \"decision_tree_name\": \"test2\"},\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 200\n\t@pytest.mark.django_db\n\tdef test_create_queue_route_wrong_tree(client):\n\t    response = client.post(\n\t        \"/create-queue\",\n\t        {\"name\": \"test1\", \"decision_tree_name\": \"test2\"},\n\t        content_type=\"application/json\",\n", "    )\n\t    assert response.status_code == 400\n\t    assert response.content.decode() == \"decision tree 'test2' does not exist!\"\n\t@pytest.mark.django_db\n\tdef test_modify_queue_route(client, queue_1, base_decision_tree):\n\t    assert queue_1.decision_tree is None\n\t    response = client.post(\n\t        \"/modify-queue/\" + queue_1.name,\n\t        {\"decision_tree_name\": base_decision_tree.name},\n\t        content_type=\"application/json\",\n", "    )\n\t    assert response.status_code == 200\n\t    updated_queue_1 = QueueCR.objects.get(id=queue_1.id)\n\t    assert updated_queue_1.decision_tree is not None\n\t@pytest.mark.django_db\n\tdef test_modify_queue_route_wrong_queue(client, queue_1, base_decision_tree):\n\t    response = client.post(\n\t        \"/modify-queue/\" + queue_1.name + \"_random\",\n\t        {\"decision_tree_name\": base_decision_tree.name},\n\t        content_type=\"application/json\",\n", "    )\n\t    assert response.status_code == 400\n\t    assert (\n\t        response.content.decode()\n\t        == f\"Queue '{queue_1.name+'_random'}' does not exist! Please create it first\"\n\t    )\n\t@pytest.mark.django_db\n\tdef test_modify_queue_route_wrong_tree(client, queue_1):\n\t    response = client.post(\n\t        \"/modify-queue/\" + queue_1.name,\n", "        {\"decision_tree_name\": \"tree1\"},\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n\t    assert response.content.decode() == f\"decision tree 'tree1' does not exist!\"\n\t@pytest.mark.django_db\n\tdef test_modify_queue_route_non_unique_name(client, queue_1, queue_2):\n\t    response = client.post(\n\t        \"/modify-queue/\" + queue_1.name,\n\t        {\"name\": queue_2.name},\n", "        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n\t    assert (\n\t        response.content.decode()\n\t        == f\"Queue name '{queue_2.name}' already exists! Please use a different name\"\n\t    )\n\t@pytest.mark.django_db\n\tdef test_delete_queue_route(client, queue_1):\n\t    pre_delete_queue_1 = QueueCR.objects.filter(id=queue_1.id).first()\n", "    assert pre_delete_queue_1 is not None\n\t    response = client.post(\n\t        \"/delete-queue/\" + queue_1.name,\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 200\n\t    post_delete_queue_1 = QueueCR.objects.filter(id=queue_1.id).first()\n\t    assert post_delete_queue_1 is None\n\t@pytest.mark.django_db\n\tdef test_delete_queue_route_wrong_name(client, queue_1):\n", "    response = client.post(\n\t        \"/delete-queue/\" + queue_1.name + \"_random\",\n\t        content_type=\"application/json\",\n\t    )\n\t    assert response.status_code == 400\n\t    assert (\n\t        response.content.decode() == f\"Queue '{queue_1.name+'_random'}' does not exist!\"\n\t    )\n"]}
{"filename": "cr-backend/api/model_validators.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\timport validators\n\tfrom dacite import from_dict\n\tfrom django.core.exceptions import ValidationError\n\tfrom .modules import DecisionTree, QuestionsWithAnswers, construct_tree_graph\n\tclass DecisionTreeValidator:\n\t    @staticmethod\n\t    @staticmethod\n\t    def missing_questions(g: dict[str, list[str]]) -> list[str]:\n", "        all_nodes = set([node for node in g.keys()])\n\t        missing_nodes = set()\n\t        for next_nodes in g.values():\n\t            for next_node in next_nodes:\n\t                if next_node not in all_nodes:\n\t                    missing_nodes.add(next_node)\n\t        return list(missing_nodes)\n\t    @staticmethod\n\t    def extra_questions(start_node: str, g: dict[str, list[str]]) -> list[str]:\n\t        visited_nodes = set([start_node])\n", "        for next_nodes in g.values():\n\t            for next_node in next_nodes:\n\t                visited_nodes.add(next_node)\n\t        all_nodes = set([node for node in g.keys()])\n\t        unconnected_nodes = []\n\t        for node in all_nodes:\n\t            if node not in visited_nodes:\n\t                unconnected_nodes.append(node)\n\t        return unconnected_nodes\n\t    @staticmethod\n", "    def topo_dfs(\n\t        node: str, g: dict[str, list[str]], visited: set[str], stack: list[str]\n\t    ) -> None:\n\t        visited.add(node)\n\t        next_nodes = g[node]\n\t        for n in next_nodes:\n\t            if n not in visited:\n\t                DecisionTreeValidator.topo_dfs(n, g, visited, stack)\n\t        stack.append(node)\n\t    @staticmethod\n", "    def topo_sort(start_node: str, g: dict[str, list[str]]) -> list[str]:\n\t        visited = set()\n\t        stack = []\n\t        DecisionTreeValidator.topo_dfs(start_node, g, visited, stack)\n\t        return list(reversed(stack))\n\t    @staticmethod\n\t    def has_cycle(start_node: str, g: dict[str, list[str]]) -> str | None:\n\t        # check for self loops\n\t        for node, next_nodes in g.items():\n\t            for n_node in next_nodes:\n", "                if n_node == node:\n\t                    return node\n\t        sorted_nodes = DecisionTreeValidator.topo_sort(start_node, g)\n\t        node_set = set()\n\t        for node in sorted_nodes:\n\t            if node in node_set:\n\t                return node\n\t            node_set.add(node)\n\t        return None\n\t    @staticmethod\n", "    def validate_tree(tree: dict) -> None:\n\t        # check overall structure\n\t        try:\n\t            tree_obj = from_dict(data_class=DecisionTree, data=tree)\n\t        except Exception as e:\n\t            raise ValidationError(e)\n\t        # check if questions have unique IDs\n\t        question_set = set()\n\t        for question in tree_obj.questions:\n\t            if question.tag in question_set:\n", "                raise ValidationError(\n\t                    f\"Question tag {question.tag} appears multiple times! Please make question tags unique in the tree\"\n\t                )\n\t            question_set.add(question.tag)\n\t            if len(question.answers) == 0:\n\t                raise ValidationError(\n\t                    f\"Question {question.tag} has no answers! Please add answers to this question\"\n\t                )\n\t            if len(question.text) == 0:\n\t                raise ValidationError(\n", "                    f\"Question {question.tag} has no text! Please add text to this question\"\n\t                )\n\t        # check if start question is in question set\n\t        if tree_obj.start_question_tag not in question_set:\n\t            raise ValidationError(\n\t                f\"Start question {tree_obj.start_question_tag} not in decision tree!\"\n\t            )\n\t        # validate the graph for missing questions, extra questions, cycles\n\t        question_graph = construct_tree_graph(tree_obj)\n\t        missing_qs = DecisionTreeValidator.missing_questions(question_graph)\n", "        if len(missing_qs) > 0:\n\t            raise ValidationError(\n\t                f\"Questions {missing_qs} are linked in tree, but not defined!\"\n\t            )\n\t        extra_qs = DecisionTreeValidator.extra_questions(\n\t            tree_obj.start_question_tag, question_graph\n\t        )\n\t        if len(extra_qs) > 0:\n\t            raise ValidationError(\n\t                f\"Questions f{extra_qs} are in tree, but cannot be reached!\"\n", "            )\n\t        cycle_node = DecisionTreeValidator.has_cycle(\n\t            tree_obj.start_question_tag, question_graph\n\t        )\n\t        if cycle_node is not None:\n\t            raise ValidationError(\n\t                f\"Your decision tree has a cycle! Question {cycle_node} appears multiple times. Please remove any cycles\"\n\t            )\n\tclass ReviewValidator:\n\t    @staticmethod\n", "    def validate_entity_type_and_content(entity_type: str, entity_content: str) -> None:\n\t        if entity_type == \"image\":\n\t            is_url = validators.url(entity_content)\n\t            if not is_url:\n\t                raise ValidationError(\n\t                    \"For entity_type 'image', entity_content must be a valid URL!\"\n\t                )\n\t    @staticmethod\n\t    def validate_questions_with_answers(questions_with_answers: dict) -> None:\n\t        # null or empty is valid here\n", "        if questions_with_answers is None or len(questions_with_answers) == 0:\n\t            return\n\t        try:\n\t            from_dict(data_class=QuestionsWithAnswers, data=questions_with_answers)\n\t        except Exception as e:\n\t            raise ValidationError(e)\n"]}
{"filename": "cr-backend/api/models.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\tfrom django.db import models\n\tfrom . import model_validators\n\tclass DecisionTreeCR(models.Model):\n\t    create_time = models.DateTimeField(auto_now_add=True)\n\t    update_time = models.DateTimeField(auto_now=True)\n\t    name = models.CharField(max_length=128, unique=True, db_index=True)\n\t    tree = models.JSONField(\n\t        validators=[model_validators.DecisionTreeValidator.validate_tree]\n", "    )\n\t    def save(self, *args, **kwargs):\n\t        self.full_clean()\n\t        super().save(*args, **kwargs)\n\t    @staticmethod\n\t    def default_decision_tree():\n\t        return {\n\t            \"start_question_tag\": \"is_violating\",\n\t            \"questions\": [\n\t                {\n", "                    \"tag\": \"is_violating\",\n\t                    \"text\": \"Is this content violating?\",\n\t                    \"answers\": [\n\t                        {\"tag\": \"yes\", \"text\": \"Yes\", \"decision\": \"yes_violating\"},\n\t                        {\"tag\": \"no\", \"text\": \"No\", \"decision\": \"no_violating\"},\n\t                    ],\n\t                }\n\t            ],\n\t        }\n\tclass QueueCR(models.Model):\n", "    create_time = models.DateTimeField(auto_now_add=True)\n\t    update_time = models.DateTimeField(auto_now=True)\n\t    name = models.CharField(max_length=128, unique=True, db_index=True)\n\t    decision_tree = models.ForeignKey(\n\t        DecisionTreeCR, on_delete=models.CASCADE, default=None, blank=True, null=True\n\t    )\n\t    prioritization_function = models.JSONField(default=None, blank=True, null=True)\n\tclass ReviewCR(models.Model):\n\t    class EntityTypeChoices(models.TextChoices):\n\t        TEXT = \"text\", \"Text\"\n", "        IMAGE = \"image\", \"Image\"\n\t    def save(self, *args, **kwargs):\n\t        self.full_clean()\n\t        model_validators.ReviewValidator.validate_entity_type_and_content(\n\t            self.entity_type, self.entity_content\n\t        )\n\t        super().save(*args, **kwargs)\n\t    create_time = models.DateTimeField(auto_now_add=True)\n\t    update_time = models.DateTimeField(auto_now=True)\n\t    entity_id = models.CharField(max_length=128, default=None, blank=True, null=True)\n", "    entity_type = models.CharField(max_length=128, choices=EntityTypeChoices.choices)\n\t    entity_content = models.TextField()\n\t    entity_create_time = models.DateTimeField(default=None, blank=True, null=True)\n\t    entity_metadata = models.JSONField(default=None, blank=True, null=True)\n\t    user_id = models.CharField(max_length=128, default=None, blank=True, null=True)\n\t    user_name = models.CharField(max_length=128, default=None, blank=True, null=True)\n\t    user_email = models.CharField(max_length=128, default=None, blank=True, null=True)\n\t    user_phone_number = models.CharField(\n\t        max_length=128, default=None, blank=True, null=True\n\t    )\n", "    user_metadata = models.JSONField(default=None, blank=True, null=True)\n\t    queue = models.ForeignKey(QueueCR, on_delete=models.CASCADE)\n\t    questions_with_answers = models.JSONField(\n\t        default=None,\n\t        blank=True,\n\t        null=True,\n\t        validators=[model_validators.ReviewValidator.validate_questions_with_answers],\n\t    )\n\t    score = models.FloatField(default=None, blank=True, null=True)\n"]}
{"filename": "cr-backend/api/urls.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\tfrom django.urls import path\n\tfrom . import routes\n\turlpatterns = [\n\t    # Queues\n\t    path(\"queues\", routes.QueueRoutes.get_queues),\n\t    path(\"create-queue\", routes.QueueRoutes.create_queue),\n\t    path(\"modify-queue/<str:queue_name>\", routes.QueueRoutes.modify_queue),\n\t    path(\"delete-queue/<str:queue_name>\", routes.QueueRoutes.delete_queue),\n", "    path(\"queue/<int:queue_id>\", routes.QueueRoutes.get_reviews_for_queue),\n\t    # Reviews\n\t    path(\"review/<int:review_id>\", routes.ReviewRoutes.get_review),\n\t    path(\n\t        \"review/<int:review_id>/store-result\", routes.ReviewRoutes.store_review_result\n\t    ),\n\t    path(\"create-review\", routes.ReviewRoutes.create_review),\n\t    path(\"modify-review/<int:review_id>\", routes.ReviewRoutes.modify_review),\n\t    path(\"delete-review/<int:review_id>\", routes.ReviewRoutes.delete_review),\n\t    # Decision Trees\n", "    path(\"create-decision-tree\", routes.DecisionTreeRoutes.create_decision_tree),\n\t    path(\n\t        \"modify-decision-tree/<str:decision_tree_name>\",\n\t        routes.DecisionTreeRoutes.modify_decision_tree,\n\t    ),\n\t    path(\n\t        \"delete-decision-tree/<str:decision_tree_name>\",\n\t        routes.DecisionTreeRoutes.delete_decision_tree,\n\t    ),\n\t]\n"]}
{"filename": "cr-backend/api/__init__.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n"]}
{"filename": "cr-backend/api/apps.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\tfrom django.apps import AppConfig\n\tclass ApiConfig(AppConfig):\n\t    default_auto_field = \"django.db.models.BigAutoField\"\n\t    name = \"api\"\n"]}
{"filename": "cr-backend/api/admin.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\tfrom django.contrib import admin\n\t# Register your models here.\n"]}
{"filename": "cr-backend/api/modules.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\t# this should probably eventually be a folder, but it only has a couple of functions\n\t# so making a file for now\n\tfrom dataclasses import dataclass\n\tfrom django.core.exceptions import ValidationError\n\t@dataclass\n\tclass Answer:\n\t    tag: str\n\t    text: str\n", "    decision: str | None\n\t    next_question_tag: str | None\n\t@dataclass\n\tclass Question:\n\t    tag: str\n\t    text: str\n\t    answers: list[Answer]\n\t@dataclass\n\tclass DecisionTree:\n\t    start_question_tag: str\n", "    questions: list[Question]\n\t@dataclass\n\tclass QuestionsWithAnswers:\n\t    question_answer_map: dict[str, str]\n\t    decisions: list[str]\n\tdef construct_tree_graph(tree: DecisionTree) -> dict[str, list[str]]:\n\t    g = {}\n\t    for question in tree.questions:\n\t        g[question.tag] = []\n\t        for answer in question.answers:\n", "            if answer.next_question_tag:\n\t                g[question.tag].append(answer.next_question_tag)\n\t    return g\n\tdef convert_questions_with_answers(\n\t    questions_with_answers_fe: list[dict[str, str]], tree: DecisionTree\n\t) -> QuestionsWithAnswers:\n\t    question_answer_map = {}\n\t    decisions = []\n\t    try:\n\t        for item in questions_with_answers_fe:\n", "            question_answer_map[item[\"questionTag\"]] = item[\"answerTag\"]\n\t            for q in tree.questions:\n\t                if q.tag == item[\"questionTag\"]:\n\t                    for a in q.answers:\n\t                        if a.tag == item[\"answerTag\"]:\n\t                            if a.decision is not None:\n\t                                decisions.append(a.decision)\n\t    except KeyError as e:\n\t        return ValidationError(e)\n\t    return QuestionsWithAnswers(\n", "        question_answer_map=question_answer_map, decisions=decisions\n\t    )\n"]}
{"filename": "cr-backend/api/routes.py", "chunked_list": ["\"\"\"\n\tCopyright 2023, Sagnik Ghosh\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t    http://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n", "limitations under the License.\n\t\"\"\"\n\timport bisect\n\timport json\n\tfrom dataclasses import asdict\n\tfrom dacite import from_dict\n\tfrom django.core.exceptions import ObjectDoesNotExist, ValidationError\n\tfrom django.db import IntegrityError\n\tfrom django.http import (\n\t    JsonResponse,\n", "    HttpResponse,\n\t    HttpRequest,\n\t    HttpResponseNotAllowed,\n\t    HttpResponseBadRequest,\n\t    HttpResponseNotFound,\n\t)\n\tfrom api.models import QueueCR, DecisionTreeCR, ReviewCR\n\tfrom .modules import DecisionTree, convert_questions_with_answers\n\tclass QueueRoutes:\n\t    @staticmethod\n", "    def get_queues(request: HttpRequest) -> JsonResponse:\n\t        if request.method != \"GET\":\n\t            return HttpResponseNotAllowed([\"GET\"])\n\t        queues = QueueCR.objects.all().order_by(\"name\")\n\t        queue_array = [\n\t            {\n\t                \"id\": q.id,\n\t                \"name\": q.name,\n\t                \"item_count\": ReviewCR.objects.filter(\n\t                    queue_id=q.id, questions_with_answers__isnull=True\n", "                ).count(),\n\t            }\n\t            for q in queues\n\t        ]\n\t        return JsonResponse({\"queues\": queue_array})\n\t    @staticmethod\n\t    def create_queue(request: HttpRequest) -> HttpResponse:\n\t        if request.method != \"POST\":\n\t            return HttpResponseNotAllowed([\"POST\"])\n\t        request_data = json.loads(request.body)\n", "        try:\n\t            QueueCR.objects.create(\n\t                name=request_data[\"name\"],\n\t                decision_tree=DecisionTreeCR.objects.get(\n\t                    name=request_data[\"decision_tree_name\"]\n\t                )\n\t                if \"decision_tree_name\" in request_data\n\t                else None,\n\t                prioritization_function=request_data.get(\"prioritization_function\"),\n\t            )\n", "        except ObjectDoesNotExist:\n\t            return HttpResponseBadRequest(\n\t                f\"decision tree '{request_data['decision_tree_name']}' does not exist!\"\n\t            )\n\t        return HttpResponse(\"OK\")\n\t    @staticmethod\n\t    def modify_queue(request: HttpRequest, queue_name: str) -> HttpResponse:\n\t        if request.method != \"POST\":\n\t            return HttpResponseNotAllowed([\"POST\"])\n\t        request_data = json.loads(request.body)\n", "        try:\n\t            queue = QueueCR.objects.get(name=queue_name)\n\t        except ObjectDoesNotExist:\n\t            return HttpResponseBadRequest(\n\t                f\"Queue '{queue_name}' does not exist! Please create it first\"\n\t            )\n\t        if \"name\" in request_data:\n\t            queue.name = request_data[\"name\"]\n\t        if \"decision_tree_name\" in request_data:\n\t            try:\n", "                queue.decision_tree = DecisionTreeCR.objects.get(\n\t                    name=request_data[\"decision_tree_name\"]\n\t                )\n\t            except ObjectDoesNotExist:\n\t                return HttpResponseBadRequest(\n\t                    f\"decision tree '{request_data['decision_tree_name']}' does not exist!\"\n\t                )\n\t        if \"prioritization_function\" in request_data:\n\t            queue.prioritization_function = request_data[\"prioritization_function\"]\n\t        try:\n", "            queue.save()\n\t        except IntegrityError:\n\t            return HttpResponseBadRequest(\n\t                f\"Queue name '{request_data['name']}' already exists! Please use a different name\"\n\t            )\n\t        return HttpResponse(\"OK\")\n\t    @staticmethod\n\t    def delete_queue(request: HttpRequest, queue_name: str) -> HttpResponse:\n\t        if request.method != \"POST\":\n\t            return HttpResponseNotAllowed([\"POST\"])\n", "        try:\n\t            queue = QueueCR.objects.get(name=queue_name)\n\t        except ObjectDoesNotExist:\n\t            return HttpResponseBadRequest(f\"Queue '{queue_name}' does not exist!\")\n\t        queue.delete()\n\t        return HttpResponse(\"OK\")\n\t    @staticmethod\n\t    def get_reviews_for_queue(request: HttpRequest, queue_id: int) -> JsonResponse:\n\t        if request.method != \"GET\":\n\t            return HttpResponseNotAllowed([\"GET\"])\n", "        reviews = ReviewCR.objects.filter(\n\t            queue_id=queue_id, questions_with_answers__isnull=True\n\t        ).order_by(\"create_time\")\n\t        review_array = [\n\t            {\"id\": r.id, \"entity_id\": r.entity_id, \"entity_type\": r.entity_type}\n\t            for r in reviews\n\t        ]\n\t        return JsonResponse({\"reviews\": review_array})\n\tclass ReviewRoutes:\n\t    @staticmethod\n", "    def get_review_response(\n\t        review: ReviewCR,\n\t        prev_review_id: int | None = None,\n\t        next_review_id: int | None = None,\n\t    ) -> JsonResponse:\n\t        return JsonResponse(\n\t            {\n\t                \"entity_id\": review.entity_id,\n\t                \"entity_type\": review.entity_type,\n\t                \"entity_content\": review.entity_content,\n", "                \"entity_create_time\": review.entity_create_time,\n\t                \"entity_metadata\": review.entity_metadata,\n\t                \"user_id\": review.user_id,\n\t                \"user_name\": review.user_name,\n\t                \"user_email\": review.user_email,\n\t                \"user_phone_number\": review.user_phone_number,\n\t                \"user_metadata\": review.user_metadata,\n\t                \"queue_id\": review.queue_id,\n\t                \"prev_review_id\": prev_review_id,\n\t                \"next_review_id\": next_review_id,\n", "                \"decision_tree\": review.queue.decision_tree.tree\n\t                if review.queue.decision_tree\n\t                else DecisionTreeCR.default_decision_tree(),\n\t            }\n\t        )\n\t    @staticmethod\n\t    def get_review(request: HttpRequest, review_id: int) -> JsonResponse:\n\t        if request.method != \"GET\":\n\t            return HttpResponseNotAllowed([\"GET\"])\n\t        try:\n", "            review = ReviewCR.objects.get(id=review_id)\n\t        except ObjectDoesNotExist:\n\t            return HttpResponseNotFound(\n\t                f\"Review ID {review_id} does not exist on this server\"\n\t            )\n\t        next_review_id = None\n\t        prev_review_id = None\n\t        queue_reviews = list(\n\t            ReviewCR.objects.filter(\n\t                queue_id=review.queue.id, questions_with_answers__isnull=True\n", "            ).order_by(\"create_time\")\n\t        )\n\t        prev_review_idx = bisect.bisect_left(\n\t            queue_reviews, review.create_time, key=lambda x: x.create_time\n\t        )\n\t        if prev_review_idx > 0:\n\t            prev_review_id = queue_reviews[prev_review_idx - 1].id\n\t        next_review_idx = bisect.bisect(\n\t            queue_reviews, review.create_time, key=lambda x: x.create_time\n\t        )\n", "        if next_review_idx < len(queue_reviews):\n\t            next_review_id = queue_reviews[next_review_idx].id\n\t        return ReviewRoutes.get_review_response(review, prev_review_id, next_review_id)\n\t    @staticmethod\n\t    def create_review(request: HttpRequest) -> HttpResponse:\n\t        if request.method != \"POST\":\n\t            return HttpResponseNotAllowed([\"POST\"])\n\t        request_data = json.loads(request.body)\n\t        if (\n\t            \"entity_type\" not in request_data\n", "            or \"entity_content\" not in request_data\n\t            or \"queue_name\" not in request_data\n\t        ):\n\t            return HttpResponseBadRequest(\n\t                \"Review requires an entity_type, entity_content, and queue_name\"\n\t            )\n\t        try:\n\t            ReviewCR.objects.create(\n\t                entity_id=request_data.get(\"entity_id\"),\n\t                entity_type=request_data[\"entity_type\"],\n", "                entity_content=request_data[\"entity_content\"],\n\t                entity_create_time=request_data.get(\"entity_create_time\"),\n\t                entity_metadata=request_data.get(\"entity_metadata\"),\n\t                user_id=request_data.get(\"user_id\"),\n\t                user_name=request_data.get(\"user_name\"),\n\t                user_email=request_data.get(\"user_email\"),\n\t                user_phone_number=request_data.get(\"user_phone_number\"),\n\t                user_metadata=request_data.get(\"user_metadata\"),\n\t                queue=QueueCR.objects.get(name=request_data[\"queue_name\"]),\n\t            )\n", "        except ValidationError as e:\n\t            return HttpResponseBadRequest(e)\n\t        except ObjectDoesNotExist:\n\t            return HttpResponseBadRequest(\n\t                f\"queue '{request_data['queue_name']}' does not exist!\"\n\t            )\n\t        return HttpResponse(\"OK\")\n\t    @staticmethod\n\t    def modify_review(request: HttpRequest, review_id: int) -> HttpResponse:\n\t        if request.method != \"POST\":\n", "            return HttpResponseNotAllowed([\"POST\"])\n\t        request_data = json.loads(request.body)\n\t        try:\n\t            review = ReviewCR.objects.get(id=review_id)\n\t        except ObjectDoesNotExist:\n\t            return HttpResponseBadRequest(f\"Review {review_id} does not exist!\")\n\t        if \"entity_id\" in request_data:\n\t            review.entity_id = request_data[\"entity_id\"]\n\t        if \"entity_type\" in request_data:\n\t            review.entity_type = request_data[\"entity_type\"]\n", "        if \"entity_content\" in request_data:\n\t            review.entity_content = request_data[\"entity_content\"]\n\t        if \"entity_create_time\" in request_data:\n\t            review.entity_create_time = request_data[\"entity_create_time\"]\n\t        if \"entity_metadata\" in request_data:\n\t            review.entity_metadata = request_data[\"entity_metadata\"]\n\t        if \"user_id\" in request_data:\n\t            review.user_id = request_data[\"user_id\"]\n\t        if \"user_name\" in request_data:\n\t            review.user_name = request_data[\"user_name\"]\n", "        if \"user_email\" in request_data:\n\t            review.user_email = request_data[\"user_email\"]\n\t        if \"user_phone_number\" in request_data:\n\t            review.user_phone_number = request_data[\"user_phone_number\"]\n\t        if \"user_metadata\" in request_data:\n\t            review.user_metadata = request_data[\"user_metadata\"]\n\t        if \"queue_name\" in request_data:\n\t            try:\n\t                review.queue = QueueCR.objects.get(name=request_data[\"queue_name\"])\n\t            except ObjectDoesNotExist:\n", "                return HttpResponseBadRequest(\n\t                    f\"queue '{request_data['queue_name']}' does not exist!\"\n\t                )\n\t        try:\n\t            review.save()\n\t        except ValidationError as e:\n\t            return HttpResponseBadRequest(e)\n\t        return HttpResponse(\"OK\")\n\t    @staticmethod\n\t    def store_review_result(request: HttpRequest, review_id: int) -> HttpResponse:\n", "        if request.method != \"POST\":\n\t            return HttpResponseNotAllowed([\"POST\"])\n\t        request_data = json.loads(request.body)\n\t        try:\n\t            review = ReviewCR.objects.get(id=review_id)\n\t        except ObjectDoesNotExist:\n\t            return HttpResponseBadRequest(f\"Review {review_id} does not exist!\")\n\t        decision_tree = (\n\t            review.queue.decision_tree.tree\n\t            if review.queue.decision_tree\n", "            else DecisionTreeCR.default_decision_tree()\n\t        )\n\t        if \"questions_with_answers\" not in request_data or not isinstance(\n\t            request_data[\"questions_with_answers\"], list\n\t        ):\n\t            return HttpResponseBadRequest(\n\t                \"Request requires questions_with_answers in list format\"\n\t            )\n\t        try:\n\t            review.questions_with_answers = asdict(\n", "                convert_questions_with_answers(\n\t                    request_data[\"questions_with_answers\"],\n\t                    from_dict(data_class=DecisionTree, data=decision_tree),\n\t                )\n\t            )\n\t        except ValidationError as e:\n\t            return HttpResponseBadRequest(e)\n\t        try:\n\t            review.save()\n\t        except ValidationError as e:\n", "            return HttpResponseBadRequest(e)\n\t        return HttpResponse(\"OK\")\n\t    @staticmethod\n\t    def delete_review(request: HttpRequest, review_id: int) -> HttpResponse:\n\t        if request.method != \"POST\":\n\t            return HttpResponseNotAllowed([\"POST\"])\n\t        try:\n\t            review = ReviewCR.objects.get(id=review_id)\n\t        except ObjectDoesNotExist:\n\t            return HttpResponseBadRequest(f\"Review {review_id} does not exist!\")\n", "        review.delete()\n\t        return HttpResponse(\"OK\")\n\tclass DecisionTreeRoutes:\n\t    @staticmethod\n\t    def create_decision_tree(request: HttpRequest) -> HttpResponse:\n\t        if request.method != \"POST\":\n\t            return HttpResponseNotAllowed([\"POST\"])\n\t        request_data = json.loads(request.body)\n\t        try:\n\t            DecisionTreeCR.objects.create(\n", "                name=request_data[\"name\"],\n\t                tree=request_data[\"tree\"],\n\t            )\n\t        except ValidationError as e:\n\t            return HttpResponseBadRequest(e)\n\t        return HttpResponse(\"OK\")\n\t    @staticmethod\n\t    def modify_decision_tree(\n\t        request: HttpRequest, decision_tree_name: str\n\t    ) -> HttpResponse:\n", "        if request.method != \"POST\":\n\t            return HttpResponseNotAllowed([\"POST\"])\n\t        request_data = json.loads(request.body)\n\t        try:\n\t            decision_tree = DecisionTreeCR.objects.get(name=decision_tree_name)\n\t        except ObjectDoesNotExist:\n\t            return HttpResponseBadRequest(\n\t                f\"Decision tree '{decision_tree_name}' does not exist!\"\n\t            )\n\t        if \"name\" in request_data:\n", "            decision_tree.name = request_data[\"name\"]\n\t        if \"decision_tree\" in request_data:\n\t            decision_tree.tree = request_data[\"decision_tree\"]\n\t        try:\n\t            decision_tree.save()\n\t        except ValidationError as e:\n\t            return HttpResponseBadRequest(e)\n\t        return HttpResponse(\"OK\")\n\t    @staticmethod\n\t    def delete_decision_tree(\n", "        request: HttpRequest, decision_tree_name: str\n\t    ) -> HttpResponse:\n\t        if request.method != \"POST\":\n\t            return HttpResponseNotAllowed([\"POST\"])\n\t        try:\n\t            decision_tree = DecisionTreeCR.objects.get(name=decision_tree_name)\n\t        except ObjectDoesNotExist:\n\t            return HttpResponseBadRequest(\n\t                f\"Decision tree '{decision_tree_name}' does not exist!\"\n\t            )\n", "        decision_tree.delete()\n\t        return HttpResponse(\"OK\")\n"]}
{"filename": "cr-backend/api/migrations/0001_initial.py", "chunked_list": ["# Generated by Django 4.2.2 on 2023-07-05 05:59\n\timport api.model_validators\n\tfrom django.db import migrations, models\n\timport django.db.models.deletion\n\tclass Migration(migrations.Migration):\n\t    initial = True\n\t    dependencies = []\n\t    operations = [\n\t        migrations.CreateModel(\n\t            name=\"DecisionTreeCR\",\n", "            fields=[\n\t                (\n\t                    \"id\",\n\t                    models.BigAutoField(\n\t                        auto_created=True,\n\t                        primary_key=True,\n\t                        serialize=False,\n\t                        verbose_name=\"ID\",\n\t                    ),\n\t                ),\n", "                (\"create_time\", models.DateTimeField(auto_now_add=True)),\n\t                (\"update_time\", models.DateTimeField(auto_now=True)),\n\t                (\"name\", models.CharField(db_index=True, max_length=128, unique=True)),\n\t                (\n\t                    \"tree\",\n\t                    models.JSONField(\n\t                        validators=[\n\t                            api.model_validators.DecisionTreeValidator.validate_tree\n\t                        ]\n\t                    ),\n", "                ),\n\t            ],\n\t        ),\n\t        migrations.CreateModel(\n\t            name=\"QueueCR\",\n\t            fields=[\n\t                (\n\t                    \"id\",\n\t                    models.BigAutoField(\n\t                        auto_created=True,\n", "                        primary_key=True,\n\t                        serialize=False,\n\t                        verbose_name=\"ID\",\n\t                    ),\n\t                ),\n\t                (\"create_time\", models.DateTimeField(auto_now_add=True)),\n\t                (\"update_time\", models.DateTimeField(auto_now=True)),\n\t                (\"name\", models.CharField(db_index=True, max_length=128, unique=True)),\n\t                (\n\t                    \"prioritization_function\",\n", "                    models.JSONField(blank=True, default=None, null=True),\n\t                ),\n\t                (\n\t                    \"decision_tree\",\n\t                    models.ForeignKey(\n\t                        blank=True,\n\t                        default=None,\n\t                        null=True,\n\t                        on_delete=django.db.models.deletion.CASCADE,\n\t                        to=\"api.decisiontreecr\",\n", "                    ),\n\t                ),\n\t            ],\n\t        ),\n\t        migrations.CreateModel(\n\t            name=\"ReviewCR\",\n\t            fields=[\n\t                (\n\t                    \"id\",\n\t                    models.BigAutoField(\n", "                        auto_created=True,\n\t                        primary_key=True,\n\t                        serialize=False,\n\t                        verbose_name=\"ID\",\n\t                    ),\n\t                ),\n\t                (\"create_time\", models.DateTimeField(auto_now_add=True)),\n\t                (\"update_time\", models.DateTimeField(auto_now=True)),\n\t                (\n\t                    \"entity_id\",\n", "                    models.CharField(\n\t                        blank=True, default=None, max_length=128, null=True\n\t                    ),\n\t                ),\n\t                (\n\t                    \"entity_type\",\n\t                    models.CharField(\n\t                        choices=[(\"text\", \"Text\"), (\"image\", \"Image\")], max_length=128\n\t                    ),\n\t                ),\n", "                (\"entity_content\", models.TextField()),\n\t                (\n\t                    \"entity_create_time\",\n\t                    models.DateTimeField(blank=True, default=None, null=True),\n\t                ),\n\t                (\n\t                    \"entity_metadata\",\n\t                    models.JSONField(blank=True, default=None, null=True),\n\t                ),\n\t                (\n", "                    \"user_id\",\n\t                    models.CharField(\n\t                        blank=True, default=None, max_length=128, null=True\n\t                    ),\n\t                ),\n\t                (\n\t                    \"user_name\",\n\t                    models.CharField(\n\t                        blank=True, default=None, max_length=128, null=True\n\t                    ),\n", "                ),\n\t                (\n\t                    \"user_email\",\n\t                    models.CharField(\n\t                        blank=True, default=None, max_length=128, null=True\n\t                    ),\n\t                ),\n\t                (\n\t                    \"user_phone_number\",\n\t                    models.CharField(\n", "                        blank=True, default=None, max_length=128, null=True\n\t                    ),\n\t                ),\n\t                (\n\t                    \"user_metadata\",\n\t                    models.JSONField(blank=True, default=None, null=True),\n\t                ),\n\t                (\n\t                    \"questions_with_answers\",\n\t                    models.JSONField(blank=True, default=None, null=True),\n", "                ),\n\t                (\"score\", models.FloatField(blank=True, default=None, null=True)),\n\t                (\n\t                    \"queue\",\n\t                    models.ForeignKey(\n\t                        on_delete=django.db.models.deletion.CASCADE, to=\"api.queuecr\"\n\t                    ),\n\t                ),\n\t            ],\n\t        ),\n", "    ]\n"]}
{"filename": "cr-backend/api/migrations/__init__.py", "chunked_list": []}
{"filename": "cr-backend/api/migrations/0002_alter_reviewcr_questions_with_answers.py", "chunked_list": ["# Generated by Django 4.2.2 on 2023-07-05 23:43\n\timport api.model_validators\n\tfrom django.db import migrations, models\n\tclass Migration(migrations.Migration):\n\t    dependencies = [\n\t        ('api', '0001_initial'),\n\t    ]\n\t    operations = [\n\t        migrations.AlterField(\n\t            model_name='reviewcr',\n", "            name='questions_with_answers',\n\t            field=models.JSONField(blank=True, default=None, null=True, validators=[api.model_validators.ReviewValidator.validate_questions_with_answers]),\n\t        ),\n\t    ]\n"]}
