{"filename": "setup.py", "chunked_list": ["__author__ = 'deadblue'\n\tfrom setuptools import setup\n\tsetup()\n"]}
{"filename": "py115/types.py", "chunked_list": ["__author__ = 'deadblue'\n\tfrom datetime import datetime\n\tfrom enum import IntEnum\n\tfrom py115._internal import oss, utils\n\tclass AppType(IntEnum):\n\t    \"\"\"App to login.\"\"\"\n\t    Web = 0\n\t    \"\"\"Login as web\"\"\"\n\t    Mac = 1\n\t    \"\"\"Login as MAC app\"\"\"\n", "    Linux = 2\n\t    \"\"\"Login as Linux app\"\"\"\n\t    Windows = 3\n\t    \"\"\"Login as Windows app\"\"\"\n\tclass _Base:\n\t    \"\"\"Base clase for all types.\"\"\"\n\t    def __repr__(self) -> str:\n\t        cls_name = type(self).__name__\n\t        attrs = ', '.join([\n\t            f'{k}={v}' for k, v in self.__dict__.items()\n", "        ])\n\t        return f'{cls_name}({attrs})'\n\tclass Credential(_Base):\n\t    \"\"\"Credential contains required information to identify user.\n\t    Args:\n\t        uid (str): The \"UID\" value in cookies.\n\t        cid (str): The \"CID\" value in cookies.\n\t        seid (str): The \"SEID\" value in cookies.\n\t    \"\"\"\n\t    _uid: str = None\n", "    _cid: str = None\n\t    _seid: str = None\n\t    def __init__(self, uid: str = None, cid: str = None, seid: str = None) -> None:\n\t        self._uid = uid\n\t        self._cid = cid\n\t        self._seid = seid\n\t    @classmethod\n\t    def from_dict(cls, d: dict):\n\t        \"\"\"Create Credential from a dict object.\n\t        Args:\n", "            d (dict): Dict object.\n\t        Returns:\n\t            py115.types.Credential: Credential object.\n\t        \"\"\"\n\t        if len(d) == 0 or not ('UID' in d and 'CID' in d and 'SEID' in d):\n\t            return None\n\t        return Credential(\n\t            uid=d.get('UID'),\n\t            cid=d.get('CID'),\n\t            seid=d.get('SEID')\n", "        )\n\t    def to_dict(self) -> dict:\n\t        \"\"\"Convert credential object to dict object.\n\t        Returns:\n\t            dict: Dict object.\n\t        \"\"\"\n\t        return {\n\t            'UID': self._uid,\n\t            'CID': self._cid,\n\t            'SEID': self._seid,\n", "        }\n\tclass File(_Base):\n\t    \"\"\"File represents a cloud file or directory.\"\"\"\n\t    file_id: str\n\t    \"\"\"Unique ID of the file on cloud.\"\"\"\n\t    parent_id: str\n\t    \"\"\"File ID of the parent directory.\"\"\"\n\t    name: str\n\t    \"\"\"Base name.\"\"\"\n\t    size: int\n", "    \"\"\"Size in bytes.\"\"\"\n\t    modified_time: datetime\n\t    \"\"\"Last modified datetime.\"\"\"\n\t    sha1: str\n\t    \"\"\"SHA-1 hash of the file in HEX encoding.\"\"\"\n\t    pickcode: str\n\t    \"\"\"Pickcode to download the file.\"\"\"\n\t    is_dir: bool\n\t    \"\"\"Is file a directory.\"\"\"\n\t    @classmethod\n", "    def _create(cls, raw: dict):\n\t        category_id = raw.get('cid')\n\t        file_id = raw.get('fid')\n\t        parent_id = raw.get('pid')\n\t        r = cls()\n\t        r.is_dir = file_id is None\n\t        r.name = raw.get('n')\n\t        if 'te' in raw:\n\t            r.modified_time = utils.parse_datetime_str(raw.get('te'))\n\t        else:\n", "            r.modified_time = utils.parse_datetime_str(raw.get('t'))\n\t        if r.is_dir:\n\t            r.file_id = category_id\n\t            r.parent_id = parent_id\n\t            r.size, r.sha1, r.pickcode = 0, None, None\n\t        else:\n\t            r.file_id = file_id\n\t            r.parent_id = category_id\n\t            r.size = raw.get('s')\n\t            r.sha1 = raw.get('sha')\n", "            r.pickcode = raw.get('pc')\n\t        return r\n\t    def __str__(self) -> str:\n\t        if self.is_dir:\n\t            return f'{self.name}/'\n\t        else:\n\t            return self.name\n\tclass DownloadTicket(_Base):\n\t    \"\"\"\n\t    DownloadTicket contains required parameters to download a file from \n", "    cloud storage.\n\t    Please check examples for detail usage.\n\t    \"\"\"\n\t    file_name: str\n\t    \"\"\"Base name of the file.\"\"\"\n\t    file_size: int\n\t    \"\"\"Size of the file.\"\"\"\n\t    url: str\n\t    \"\"\"Download URL.\"\"\"\n\t    headers: dict\n", "    \"\"\"Required headers that should be used with download URL.\"\"\"\n\tclass PlayTicket(_Base):\n\t    url: str\n\t    \"\"\"Download URL.\"\"\"\n\t    headers: dict\n\t    \"\"\"Required headers that should be used with download URL.\"\"\"\n\tclass UploadTicket(_Base):\n\t    \"\"\"\n\t    UploadTicket contains required parameters to upload a file to \n\t    cloud storage.\n", "    Please check examples for detial usage.\n\t    \"\"\"\n\t    is_done: bool\n\t    \"\"\"Is file already uploaded.\"\"\"\n\t    oss_endpoint: str\n\t    \"\"\"OSS endpoint address.\"\"\"\n\t    oss_token: dict\n\t    \"\"\"OSS token\"\"\"\n\t    bucket_name: str\n\t    \"\"\"OSS bucket name.\"\"\"\n", "    object_key: str\n\t    \"\"\"OSS object key.\"\"\"\n\t    headers: dict\n\t    \"\"\"Required headers that should be used in upload.\"\"\"\n\t    expiration: datetime\n\t    \"\"\"Expiration time of this ticket.\"\"\"\n\t    @classmethod\n\t    def _create(cls, raw: dict, token: dict):\n\t        r = cls()\n\t        r.is_done = raw['done']\n", "        if not r.is_done:\n\t            r.oss_endpoint = oss.ENDPOINT\n\t            r.oss_token = {\n\t                'access_key_id': token.get('access_key_id'),\n\t                'access_key_secret': token.get('access_key_secret'),\n\t                'security_token': token.get('security_token')\n\t            }\n\t            r.bucket_name = raw.get('bucket')\n\t            r.object_key = raw.get('object')\n\t            r.headers = {\n", "                'x-oss-callback': oss.encode_header_value(raw.get('callback')),\n\t                'x-oss-callback-var': oss.encode_header_value(raw.get('callback_var'))\n\t            }\n\t            r.expiration = token.get('expiration')\n\t        return r\n\t    def is_valid(self) -> bool:\n\t        \"\"\"Check whether the ticket is valid.\n\t        Returns:\n\t            bool: Valid flag.\n\t        \"\"\"\n", "        return datetime.now() < self.expiration\n\tclass TaskStatus(IntEnum):\n\t    Running = 1\n\t    \"\"\"Task is running.\"\"\"\n\t    Complete = 2\n\t    \"\"\"Task is complete.\"\"\"\n\t    Failed = -1\n\t    \"\"\"Task is failed.\"\"\"\n\t    Unknown = 0\n\t    \"\"\"Unknown status?\"\"\"\n", "class Task(_Base):\n\t    \"\"\"Task represents an offline task.\"\"\"\n\t    task_id: str\n\t    \"\"\"Unique ID of the task.\"\"\"\n\t    name: str\n\t    \"\"\"Task name.\"\"\"\n\t    size: int\n\t    \"\"\"Total size to be downloaded.\"\"\"\n\t    created_time: datetime\n\t    \"\"\"Task created time.\"\"\"\n", "    percent: float\n\t    \"\"\"Precentage of the download, 0~100.\"\"\"\n\t    file_id: str\n\t    \"\"\"Downloaded file ID of the task, may be None if the task does not finish.\"\"\"\n\t    file_is_dir: bool\n\t    \"\"\"Is the downloaded file a directory.\"\"\"\n\t    status: TaskStatus\n\t    \"\"\"Task status.\"\"\"\n\t    @classmethod\n\t    def _create(cls, raw: dict):\n", "        r = cls()\n\t        r.task_id = raw.get('info_hash')\n\t        r.name = raw.get('name')\n\t        r.size = raw.get('size', -1)\n\t        r.created_time = utils.make_datetime(raw.get('add_time', 0))\n\t        r.precent = float(raw.get('percentDone', 0))\n\t        r.status = TaskStatus(raw.get('status', 0))\n\t        file_id = raw.get('file_id', '')\n\t        del_file_id = raw.get('delete_file_id', '')\n\t        r.file_id = del_file_id\n", "        r.file_is_dir = file_id != '' and file_id == del_file_id\n\t        return r\n\t    def is_complete(self) -> bool:\n\t        \"\"\"Check is task complete.\"\"\"\n\t        return self.status == TaskStatus.Complete\n\t    def is_failed(self) -> bool:\n\t        \"\"\"Check is task failed.\"\"\"\n\t        return self.status == TaskStatus.Failed\n\t    def is_running(self) -> bool:\n\t        \"\"\"Check is task still running.\"\"\"\n", "        return self.status == TaskStatus.Running"]}
{"filename": "py115/cloud.py", "chunked_list": ["__author__ = 'deadblue'\n\timport typing\n\tfrom py115._internal.protocol.client import Client\n\tfrom py115._internal.api import qrcode, upload, version\n\tfrom py115 import login, services\n\tfrom py115.types import AppType, Credential\n\t_app_names = [\n\t    'web', 'mac', 'linux', 'windows'\n\t]\n\tclass Cloud(login._Handler):\n", "    \"\"\"115 cloud service.\n\t    Args:\n\t        credential (py115.types.Credential): Credential object.\n\t        protocol_kwargs (dict): Settings for underlying protocol client.\n\t    \"\"\"\n\t    _app_ver: str = None\n\t    _client: Client = None\n\t    _upload_helper: upload.Helper = None\n\t    def __init__(\n\t            self, \n", "            credential: Credential = None, \n\t            protocol_kwargs: dict = None\n\t        ) -> None:\n\t        # Config protocol client\n\t        protocol_kwargs = protocol_kwargs or {}\n\t        self._client = Client(**protocol_kwargs)\n\t        # Get latest app version\n\t        self._app_ver = self._client.execute_api(version.GetApi())\n\t        self._client.setup_user_agent(\n\t            app_version=self._app_ver\n", "        )\n\t        # Set credential\n\t        if credential is not None:\n\t            self.import_credential(credential)\n\t    def import_credential(self, credential: Credential) -> bool:\n\t        \"\"\"Import credential to cloud instance.\n\t        Args:\n\t            credential (py115.types.Credential): Credential object to identity user.\n\t        Return:\n\t            bool: Is credential valid.\n", "        \"\"\"\n\t        self._client.import_cookies(credential.to_dict())\n\t        return self._on_login()\n\t    def export_credentail(self) -> typing.Union[Credential, None]:\n\t        \"\"\"Export current credentail from cloud instance.\n\t        Return:\n\t            py115.types.Credential: Credential object, or None when credential is invalid.\n\t        \"\"\"\n\t        # TODO: Check credential before return.\n\t        return Credential.from_dict(\n", "            self._client.export_cookies()\n\t        )\n\t    def qrcode_login(self, app_type: AppType) -> login.QrcodeSession:\n\t        \"\"\"Start QRcode login session.\n\t        Args:\n\t            app_type (py115.types.AppType): App to login.\n\t        Returns:\n\t            py115.login.QrcodeSession: QRcode login session.\n\t        \"\"\"\n\t        app_name = _app_names[app_type.value]\n", "        token = self._client.execute_api(qrcode.TokenApi(app_name))\n\t        return login.QrcodeSession._create(\n\t            client=self._client,\n\t            handler=self,\n\t            app_name=app_name,\n\t            uid=token.get('uid'), \n\t            time=token.get('time'),\n\t            sign=token.get('sign')\n\t        )\n\t    def _on_login(self) -> bool:\n", "        try:\n\t            user_id, user_key = self._client.execute_api(upload.InfoApi())\n\t            self._upload_helper = upload.Helper(\n\t                self._app_ver, user_id, user_key\n\t            )\n\t            return True\n\t        except:\n\t            return False\n\t    def offline(self) -> services.OfflineService:\n\t        \"\"\"Get offline service.\n", "        Return:\n\t            py115.services.OfflineService: Offline service instance.\n\t        \"\"\"\n\t        return services.OfflineService._create(\n\t            client=self._client, \n\t            app_ver=self._app_ver, \n\t            user_id=self._upload_helper.user_id\n\t        )\n\t    def storage(self) -> services.StorageService:\n\t        \"\"\"Get storage service.\n", "        Return:\n\t            py115.services.StorageService: Storage service instance.\n\t        \"\"\"\n\t        return services.StorageService._create(\n\t            client=self._client,\n\t            uh=self._upload_helper\n\t        )\n"]}
{"filename": "py115/__init__.py", "chunked_list": ["__author__ = 'deadblue'\n\t\"\"\"\n\tPython SDK for 115 cloud storage service.\n\tExample:\n\timport py115\n\timport py115.types\n\tcloud = py115.connect(py115.types.Credential(\n\t    uid='', cid='', seid=''\n\t))\n\tstorage = cloud.storage()\n", "for file in storage.list():\n\t    print(f'File: {file.name}')\n\t\"\"\"\n\tVERSION = '0.0.3'\n\timport py115.cloud\n\timport py115.types\n\tdef connect(\n\t        credential: py115.types.Credential = None,\n\t        protocol_kwargs: dict=  None\n\t) -> py115.cloud.Cloud:\n", "    \"\"\"Connect to 115 cloud.\n\t    Args:\n\t        credential (py115.types.Credential): \n\t            Credential data to identity user.\n\t        protocol_kwargs (dict): \n\t            Keyword arguments for underlying protocol client.\n\t    Return:\n\t        py115.cloud.Cloud: Cloud instance.\n\t    \"\"\"\n\t    return py115.cloud.Cloud(\n", "        credential=credential, \n\t        protocol_kwargs=protocol_kwargs\n\t    )\n"]}
{"filename": "py115/login.py", "chunked_list": ["__author__ = 'deadblue'\n\timport logging\n\tfrom py115._internal.api import qrcode\n\tfrom py115._internal.protocol.client import Client\n\t_logger = logging.getLogger(__name__)\n\tclass _Handler:\n\t    def _on_login(self) -> bool:\n\t        return True\n\tclass QrcodeSession:\n\t    \"\"\"QRcode login session.\"\"\"\n", "    _client: Client\n\t    _handler: _Handler\n\t    _app_name: str\n\t    _uid: str\n\t    _time: int\n\t    _sign: str\n\t    image_data: bytes\n\t    \"\"\"QRcode image data\"\"\"\n\t    @classmethod\n\t    def _create(cls, client: Client, handler: _Handler, app_name: str, uid: str, time: int, sign: str):\n", "        s = cls()\n\t        s._client = client\n\t        s._handler = handler\n\t        s._app_name = app_name\n\t        s._uid = uid\n\t        s._time = time\n\t        s._sign = sign\n\t        s.image_data = client.fetch(qrcode.get_image_url(app_name, uid))\n\t        return s\n\t    def poll(self) -> bool:\n", "        \"\"\"Poll QRcode status.\n\t        This method will block until login is done, or QRcode is invalid.\n\t        Returns:\n\t            bool: Is login succeeded.\n\t        \"\"\"\n\t        while True:\n\t            # Query QRcode status\n\t            status = self._client.execute_api(qrcode.StatusApi(\n\t                uid=self._uid,\n\t                time=self._time,\n", "                sign=self._sign\n\t            ))\n\t            if status == 2:\n\t                # Allowed, start login\n\t                self._client.execute_api(qrcode.LoginApi(\n\t                    app_name=self._app_name,\n\t                    uid=self._uid\n\t                ))\n\t                return self._handler._on_login()\n\t            elif status < 0:\n", "                # Canceled or Expired\n\t                return False\n\t            else:\n\t                # Waiting or Scanned\n\t                _logger.debug('Continue waiting, status: %d', status)\n"]}
{"filename": "py115/services.py", "chunked_list": ["__author__ = 'deadblue'\n\timport os\n\timport os.path\n\timport typing\n\tfrom py115._internal.api import offline, file, dir, space, upload\n\tfrom py115._internal.protocol.client import Client\n\tfrom py115 import types\n\t_CLEAR_FLAG_MAPPING = {\n\t    types.TaskStatus.Complete: 1,\n\t    types.TaskStatus.Failed: 2,\n", "    types.TaskStatus.Running: 3\n\t}\n\tclass OfflineService:\n\t    \"\"\"Offline task manager.\"\"\"\n\t    _client: Client = None\n\t    _app_ver: str = None\n\t    _user_id: str = None\n\t    @classmethod\n\t    def _create(cls, client: Client, app_ver: str, user_id: str):\n\t        s = cls()\n", "        s._client = client\n\t        s._app_ver = app_ver\n\t        s._user_id = user_id\n\t        return s\n\t    def list(self) -> typing.Generator[types.Task, None, None]:\n\t        \"\"\"Get all tasks.\n\t        Yields:\n\t            py115.types.Task: Task object\n\t        \"\"\"\n\t        spec = offline.ListApi()\n", "        while True:\n\t            result = self._client.execute_api(spec)\n\t            for t in result['tasks']:\n\t                yield types.Task._create(t)\n\t            page, page_count = result['page'], result['page_count']\n\t            if page < page_count:\n\t                spec.set_page(page + 1)\n\t            else:\n\t                break\n\t    def add_url(self, *urls: str) -> typing.Iterable[types.Task]:\n", "        \"\"\"Create task(s) from download URL.\n\t        Args:\n\t            *urls (str): Download URL, can be a http/ftp/ed2k/magnet link.\n\t        Return:\n\t            Iterable[py115.types.Task]: Task list for the download URLs.\n\t        \"\"\"\n\t        if len(urls) == 0:\n\t            return []\n\t        add_results = self._client.execute_api(offline.AddUrlsApi(\n\t            self._app_ver, self._user_id, urls\n", "        ))\n\t        return [types.Task._create(r) for r in add_results]\n\t    def delete(self, *task_ids: str):\n\t        \"\"\"Delete task(s).\n\t        Args:\n\t            *task_ids (str): The ID of tasks you wants to delete.\n\t        \"\"\"\n\t        if len(task_ids) == 0:\n\t            return\n\t        self._client.execute_api(offline.DeleteApi(task_ids))\n", "    def clear(self, status: types.TaskStatus = types.TaskStatus.Complete):\n\t        \"\"\"Clear tasks.\n\t        Args:\n\t            status (py115.types.TaskStatus): \n\t                Tasks in given status will be cleared. Set status to None to \n\t                clear all tasks.\n\t        \"\"\"\n\t        if status is None:\n\t            # Clear all tasks\n\t            flag = 1\n", "        else:\n\t            # Default to clear complete tasks.\n\t            flag = _CLEAR_FLAG_MAPPING.get(status, 0)\n\t        self._client.execute_api(offline.ClearApi(flag))\n\tclass StorageService:\n\t    \"\"\"Cloud file/directory manager.\n\t    \"\"\"\n\t    _client: Client = None\n\t    _upload_helper: upload.Helper = None\n\t    @classmethod\n", "    def _create(cls, client: Client, uh: upload.Helper):\n\t        s = cls()\n\t        s._client = client\n\t        s._upload_helper = uh\n\t        return s\n\t    def space(self) -> typing.Tuple[int, int]:\n\t        \"\"\"\n\t        Get total size and used size of the storage.\n\t        Returns:\n\t            Tuple[int, int]: Total size and used size in byte.\n", "        \"\"\"\n\t        result = self._client.execute_api(space.GetApi())\n\t        if result is not None:\n\t            total = int(result['all_total']['size'])\n\t            used = int(result['all_use']['size'])\n\t            return (total, used)\n\t        else:\n\t            return (0, 0)\n\t    def list(self, dir_id: str = '0') -> typing.Generator[types.File, None, None]:\n\t        \"\"\"Get files under a directory.\n", "        Args:\n\t            dir_id (str): Directory ID to list, default is \"0\" which means root directory.\n\t        Yields:\n\t            py115.types.File: File object under the directory.\n\t        \"\"\"\n\t        spec = file.ListApi(dir_id)\n\t        while True:\n\t            result = self._client.execute_api(spec)\n\t            for f in result['files']:\n\t                yield types.File._create(f)\n", "            next_offset = result['offset'] + len(result['files'])\n\t            if next_offset >= result['count']:\n\t                break\n\t            else:\n\t                spec.set_offset(next_offset)\n\t    def search(self, keyword: str, dir_id: str = '0'):\n\t        \"\"\"Recursively search files under a directory.\n\t        Args:\n\t            keyword (str): Keyword to search files.\n\t            dir_id (str): Directory ID to search.\n", "        Yields:\n\t            py115.types.File: File object whose name contains the keyword.\n\t        \"\"\"\n\t        spec = file.SearchApi(keyword=keyword, dir_id=dir_id)\n\t        while True:\n\t            result = self._client.execute_api(spec)\n\t            for f in result['files']:\n\t                yield types.File._create(f)\n\t            next_offset = result['offset'] + len(result['files'])\n\t            if next_offset >= result['count']:\n", "                break\n\t            else:\n\t                spec.set_offset(next_offset)\n\t    def move(self, target_dir_id: str, *file_ids: str):\n\t        \"\"\"Move files to a directory.\n\t        Args:\n\t            target_dir_id (str): ID of target directory where to move files.\n\t            *file_ids (str): ID of files to be moved.\n\t        \"\"\"\n\t        if len(file_ids) == 0:\n", "            return\n\t        self._client.execute_api(file.MoveApi(target_dir_id, file_ids))\n\t    def rename(self, file_id: str, new_name: str):\n\t        \"\"\"Rename file.\n\t        Args:\n\t            file_id (str): ID of file to be renamed.\n\t            new_name (str): New name for the file.\n\t        \"\"\"\n\t        self._client.execute_api(file.RenameApi(file_id, new_name))\n\t    def delete(self, *file_ids: str):\n", "        \"\"\"Delete files.\n\t        Args:\n\t            *file_ids (str): ID of files to be deleted.\n\t        \"\"\"\n\t        if len(file_ids) == 0:\n\t            return\n\t        self._client.execute_api(file.DeleteApi(file_ids))\n\t    def make_dir(self, parent_id: str, name: str) -> types.File:\n\t        \"\"\"Make new directory under a directory.\n\t        Args:\n", "            parent_id (str): ID of parent directory where to make new directory.\n\t            name (str): Name for the new directory.\n\t        Return:\n\t            py115.types.File: File object of the created directory.\n\t        \"\"\"\n\t        result = self._client.execute_api(dir.AddApi(parent_id, name))\n\t        result['pid'] = parent_id\n\t        return types.File._create(result)\n\t    def request_download(self, pickcode: str) -> types.DownloadTicket:\n\t        \"\"\"Download file from cloud storage.\n", "        Args:\n\t            pickcode (str): Pick code of file.\n\t        Returns:\n\t            py115.types.DownloadTicket: A ticket contains all required fields to \n\t            download file from cloud.\n\t        \"\"\"\n\t        result = self._client.execute_api(file.DownloadApi(pickcode))\n\t        if result is None or 'url' not in result:\n\t            return None\n\t        ticket = types.DownloadTicket()\n", "        ticket.url = result['url']\n\t        ticket.file_name = result.get('file_name')\n\t        ticket.file_size = result.get('file_size')\n\t        # Required headers for downloading\n\t        cookies = self._client.export_cookies(url=result['url'])\n\t        ticket.headers = {\n\t            'User-Agent': self._client.user_agent,\n\t            'Cookie': '; '.join([\n\t                f'{k}={v}' for k, v in cookies.items()\n\t            ])\n", "        }\n\t        return ticket\n\t    def request_play(self, pickcode: str) -> types.PlayTicket:\n\t        \"\"\"Play a video file on cloud, returns required parameters as a ticket.\n\t        Args:\n\t            pickcode (str): Pick code of file.\n\t        Returns:\n\t            py115.types.PlayTicket: A ticket contains all required fields to \n\t            play the media file on cloud.\n\t        \"\"\"\n", "        ticket = types.PlayTicket()\n\t        ticket.url = self._client.execute_api(file.VideoApi(pickcode=pickcode))\n\t        # Prepare headers for playing\n\t        cookies = self._client.export_cookies(url=ticket.url)\n\t        ticket.headers = {\n\t            'User-Agent': self._client.user_agent,\n\t            'Cookie': '; '.join([\n\t                f'{k}={v}' for k, v in cookies.items()\n\t            ])\n\t        }\n", "        return ticket\n\t    def request_upload(self, dir_id: str, file_path: str) -> types.UploadTicket:\n\t        \"\"\"Upload local file to cloud storage.\n\t        Args:\n\t            dir_id (str): ID of directory where to store the file.\n\t            file_path (str): Path of the local file.\n\t        Return:\n\t            py115.types.UploadTicket: A ticket contains all required fields to\n\t            upload file to cloud, should be used with aliyun-oss-python-sdk.\n\t        \"\"\"\n", "        if not os.path.exists(file_path):\n\t            return None\n\t        file_name = os.path.basename(file_path)\n\t        with open(file_path, 'rb') as file_io:\n\t            return self.request_upload_data(dir_id, file_name, file_io)\n\t    def request_upload_data(\n\t            self, \n\t            dir_id: str, \n\t            save_name: str, \n\t            data_io: typing.BinaryIO, \n", "        ) -> types.UploadTicket:\n\t        \"\"\"Upload data as a file to cloud storage.\n\t        Args:\n\t            dir_id (str): ID of directory where to store the file.\n\t            save_name (str): File name to be saved.\n\t            data_io (BinaryIO): IO stream of data.\n\t        Return:\n\t            py115.types.UploadTicket: A ticket contains all required fields to\n\t            upload file to cloud, should be used with aliyun-oss-python-sdk.\n\t        \"\"\"\n", "        if not (data_io.readable() and data_io.seekable()):\n\t            return None\n\t        init_result = self._client.execute_api(upload.InitApi(\n\t            target_id=f'U_1_{dir_id}',\n\t            file_name=save_name,\n\t            file_io=data_io,\n\t            helper=self._upload_helper\n\t        ))\n\t        token_result = None\n\t        if not init_result['done']:\n", "            token_result = self._client.execute_api(upload.TokenApi())\n\t        return types.UploadTicket._create(init_result, token_result)\n"]}
{"filename": "py115/_internal/__init__.py", "chunked_list": ["__author__ = 'deadblue'\n"]}
{"filename": "py115/_internal/utils.py", "chunked_list": ["__author__ = 'deadblue'\n\timport datetime\n\timport pytz\n\t_tz_cst = pytz.FixedOffset(480)\n\tdef parse_datetime_str(s: str) -> datetime.datetime:\n\t    if '-' in s:\n\t        t = datetime.datetime.strptime(\n\t            s, '%Y-%m-%d %H:%M'\n\t        )\n\t        t.replace(tzinfo=_tz_cst)\n", "        return t\n\t    else:\n\t        return  datetime.datetime.fromtimestamp(\n\t            float(s), tz=_tz_cst\n\t        )\n\tdef make_datetime(ts: int) -> datetime.datetime:\n\t    return datetime.datetime.fromtimestamp(\n\t        float(ts), tz=_tz_cst\n\t    )\n"]}
{"filename": "py115/_internal/oss.py", "chunked_list": ["__author__ = 'deadblue'\n\timport base64\n\tENDPOINT='https://oss-cn-shenzhen.aliyuncs.com'\n\tdef encode_header_value(v: str) -> str:\n\t    return base64.b64encode(v.encode()).decode()\n"]}
{"filename": "py115/_internal/crypto/_xor.py", "chunked_list": ["__author__ = 'deadblue'\n\t_key_seed = bytes([\n\t    0xf0, 0xe5, 0x69, 0xae, 0xbf, 0xdc, 0xbf, 0x8a,\n\t    0x1a, 0x45, 0xe8, 0xbe, 0x7d, 0xa6, 0x73, 0xb8,\n\t    0xde, 0x8f, 0xe7, 0xc4, 0x45, 0xda, 0x86, 0xc4,\n\t    0x9b, 0x64, 0x8b, 0x14, 0x6a, 0xb4, 0xf1, 0xaa,\n\t    0x38, 0x01, 0x35, 0x9e, 0x26, 0x69, 0x2c, 0x86,\n\t    0x00, 0x6b, 0x4f, 0xa5, 0x36, 0x34, 0x62, 0xa6,\n\t    0x2a, 0x96, 0x68, 0x18, 0xf2, 0x4a, 0xfd, 0xbd,\n\t    0x6b, 0x97, 0x8f, 0x4d, 0x8f, 0x89, 0x13, 0xb7,\n", "    0x6c, 0x8e, 0x93, 0xed, 0x0e, 0x0d, 0x48, 0x3e,\n\t    0xd7, 0x2f, 0x88, 0xd8, 0xfe, 0xfe, 0x7e, 0x86,\n\t    0x50, 0x95, 0x4f, 0xd1, 0xeb, 0x83, 0x26, 0x34,\n\t    0xdb, 0x66, 0x7b, 0x9c, 0x7e, 0x9d, 0x7a, 0x81,\n\t    0x32, 0xea, 0xb6, 0x33, 0xde, 0x3a, 0xa9, 0x59,\n\t    0x34, 0x66, 0x3b, 0xaa, 0xba, 0x81, 0x60, 0x48,\n\t    0xb9, 0xd5, 0x81, 0x9c, 0xf8, 0x6c, 0x84, 0x77,\n\t    0xff, 0x54, 0x78, 0x26, 0x5f, 0xbe, 0xe8, 0x1e,\n\t    0x36, 0x9f, 0x34, 0x80, 0x5c, 0x45, 0x2c, 0x9b,\n\t    0x76, 0xd5, 0x1b, 0x8f, 0xcc, 0xc3, 0xb8, 0xf5,\n", "])\n\tclient_key = bytes([\n\t    0x78, 0x06, 0xad, 0x4c, 0x33, 0x86, 0x5d, 0x18, 0x4c, 0x01, 0x3f, 0x46,\n\t])\n\tdef derive_key(source: bytes, size: int) -> bytes:\n\t    key = bytearray(size)\n\t    for i in range(size):\n\t        key[i] = (source[i] + _key_seed[size * i]) & 0xff\n\t        key[i] ^= _key_seed[size * (size - i - 1)]\n\t    return bytes(key)\n", "def transform(key: bytes, data: bytearray):\n\t    key_size, data_size = len(key), len(data)\n\t    mod_size = data_size % 4\n\t    for i in range(data_size):\n\t        if i < mod_size:\n\t            data[i] ^= key[i % key_size]\n\t        else:\n\t            data[i] ^= key[(i - mod_size) % key_size]\n\t    return\n"]}
{"filename": "py115/_internal/crypto/_rsa.py", "chunked_list": ["__author__ = 'deadblue'\n\timport secrets\n\tclass Cipher():\n\t    def __init__(self, n: bytes, e: int) -> None:\n\t        self._n = int.from_bytes(n, 'big')\n\t        self._e = e\n\t        self._key_len = len(n)\n\t    def _encrypt_slice(self, segment: bytes) -> bytes:\n\t        # Make pad\n\t        pad_size = self._key_len - len(segment)\n", "        pad_buf = bytearray(pad_size)\n\t        pad_buf[0], pad_buf[1] = 0, 2\n\t        for i in range(pad_size - 3):\n\t            pad_buf[2 + i] = secrets.randbelow(0xff) + 1\n\t        pad_buf[-1] = 0\n\t        msg = int.from_bytes(pad_buf + segment, 'big')\n\t        return pow(msg, self._e, self._n).to_bytes(self._key_len, 'big')\n\t    def encrypt(self, plaintext: bytes) -> bytes:\n\t        ciphertext = bytearray()\n\t        remain_size = len(plaintext)\n", "        while remain_size > 0:\n\t            slice_size = self._key_len - 11\n\t            if slice_size > remain_size:\n\t                slice_size = remain_size\n\t            ciphertext.extend(\n\t                self._encrypt_slice(plaintext[:slice_size])\n\t            )\n\t            plaintext = plaintext[slice_size:]\n\t            remain_size -= slice_size\n\t        return bytes(ciphertext)\n", "    def _decrypt_slice(self, segment: bytes) -> bytes:\n\t        msg = int.from_bytes(segment, 'big')\n\t        ret = pow(msg, self._e, self._n).to_bytes(self._key_len, 'big')\n\t        for i, b in enumerate(ret):\n\t            if i != 0 and b == 0:\n\t                ret = ret[i+1:]\n\t                break\n\t        return ret\n\t    def decrypt(self, ciphertext: bytes) -> bytearray:\n\t        plaintext = bytearray()\n", "        remain_size = len(ciphertext)\n\t        while remain_size > 0:\n\t            slice_size = self._key_len\n\t            if slice_size > remain_size:\n\t                slice_size = remain_size\n\t            plaintext.extend(\n\t                self._decrypt_slice(ciphertext[:slice_size])\n\t            )\n\t            ciphertext = ciphertext[slice_size:]\n\t            remain_size -= slice_size\n", "        return plaintext\n"]}
{"filename": "py115/_internal/crypto/__init__.py", "chunked_list": ["__author__ = 'deadblue'\n"]}
{"filename": "py115/_internal/crypto/ec115.py", "chunked_list": ["__author__ = 'deadblue'\n\timport binascii\n\timport logging\n\timport random\n\timport struct\n\tfrom Crypto.Cipher import AES\n\tfrom Crypto.PublicKey import ECC\n\timport lz4.block\n\t_server_pub_key = bytes([\n\t    0x04, 0x57, 0xa2, 0x92, 0x57, 0xcd, 0x23, 0x20, \n", "    0xe5, 0xd6, 0xd1, 0x43, 0x32, 0x2f, 0xa4, 0xbb, \n\t    0x8a, 0x3c, 0xf9, 0xd3, 0xcc, 0x62, 0x3e, 0xf5, \n\t    0xed, 0xac, 0x62, 0xb7, 0x67, 0x8a, 0x89, 0xc9, \n\t    0x1a, 0x83, 0xba, 0x80, 0x0d, 0x61, 0x29, 0xf5, \n\t    0x22, 0xd0, 0x34, 0xc8, 0x95, 0xdd, 0x24, 0x65, \n\t    0x24, 0x3a, 0xdd, 0xc2, 0x50, 0x95, 0x3b, 0xee, \n\t    0xba,\n\t])\n\t_curve_name = 'P-224'\n\t_crc_salt = b'^j>WD3Kr?J2gLFjD4W2y@'\n", "_logger = logging.getLogger(__name__)\n\tclass Cipher:\n\t    def __init__(self) -> None:\n\t        # Load server public key\n\t        server_key = ECC.import_key(\n\t            encoded=_server_pub_key, curve_name=_curve_name\n\t        )\n\t        # Generate client key\n\t        client_key = ECC.generate(curve=_curve_name)\n\t        # Export client public key\n", "        self._pub_key = b'\\x1d' + client_key.public_key().export_key(\n\t            format='SEC1', compress=True\n\t        )\n\t        # ECDH key exchange\n\t        shared_secret = (server_key.pointQ * client_key.d).x.to_bytes(28, 'big')\n\t        self._aes_key = shared_secret[:16]\n\t        self._aes_iv = shared_secret[-16:]\n\t    def encode_token(self, timestamp: int) -> str:\n\t        token = bytearray(struct.pack(\n\t            '<15sBII15sBI',\n", "            self._pub_key[:15], 0, 115, timestamp,\n\t            self._pub_key[15:], 0, 1\n\t        ))\n\t        r1, r2 = random.randint(0, 0xff), random.randint(0, 0xff)\n\t        for i in range(len(token)):\n\t            if i < 24:\n\t                token[i] = token[i] ^ r1\n\t            else:\n\t                token[i] = token[i] ^ r2\n\t        # Calculate and append CRC32 checksum\n", "        checksum = binascii.crc32(_crc_salt + token) & 0xffffffff\n\t        token += struct.pack('<I', checksum)\n\t        # Base64 encode\n\t        return binascii.b2a_base64(token, newline=False).decode()\n\t    def encode(self, data: bytes) -> bytes:\n\t        pad_size = AES.block_size - len(data) % AES.block_size\n\t        if pad_size != AES.block_size:\n\t            data += b'\\x00' * pad_size\n\t        encrypter = AES.new(\n\t            key=self._aes_key,\n", "            mode=AES.MODE_CBC,\n\t            iv=self._aes_iv\n\t        )\n\t        return encrypter.encrypt(data)\n\t    def decode(self, data: bytes) -> bytes:\n\t        ciphertext, tail = data[:-12], bytearray(data[-12:])\n\t        # Decrypt\n\t        decrypter = AES.new(\n\t            key = self._aes_key, \n\t            mode = AES.MODE_CBC, \n", "            iv = self._aes_iv\n\t        )\n\t        plaintext = decrypter.decrypt(ciphertext)\n\t        # Get uncompress size\n\t        for i in range(4):\n\t            tail[i] = tail[i] ^ tail[7]\n\t        dst_size, = struct.unpack('<I', tail[:4])\n\t        # Decompress\n\t        buf = []\n\t        while dst_size > 0:\n", "            uncompressed_size = dst_size\n\t            if uncompressed_size > 8192:\n\t                uncompressed_size = 8192\n\t            src_size, = struct.unpack('<H', plaintext[:2])\n\t            buf.append(lz4.block.decompress(\n\t                plaintext[2:src_size+2], uncompressed_size\n\t            ))\n\t            # Move to next block\n\t            plaintext = plaintext[src_size+2:]\n\t            dst_size -= uncompressed_size\n", "        return buf[0] if len(buf) == 0 else b''.join(buf)\n"]}
{"filename": "py115/_internal/crypto/m115.py", "chunked_list": ["__author__ = 'deadblue'\n\timport base64\n\timport secrets\n\tfrom py115._internal.crypto import _rsa, _xor\n\t_ras_n = [\n\t    0x86, 0x86, 0x98, 0x0c, 0x0f, 0x5a, 0x24, 0xc4, \n\t    0xb9, 0xd4, 0x30, 0x20, 0xcd, 0x2c, 0x22, 0x70, \n\t    0x3f, 0xf3, 0xf4, 0x50, 0x75, 0x65, 0x29, 0x05, \n\t    0x8b, 0x1c, 0xf8, 0x8f, 0x09, 0xb8, 0x60, 0x21, \n\t    0x36, 0x47, 0x71, 0x98, 0xa6, 0xe2, 0x68, 0x31, \n", "    0x49, 0x65, 0x9b, 0xd1, 0x22, 0xc3, 0x35, 0x92, \n\t    0xfd, 0xb5, 0xad, 0x47, 0x94, 0x4a, 0xd1, 0xea, \n\t    0x4d, 0x36, 0xc6, 0xb1, 0x72, 0xaa, 0xd6, 0x33, \n\t    0x8c, 0x3b, 0xb6, 0xac, 0x62, 0x27, 0x50, 0x2d, \n\t    0x01, 0x09, 0x93, 0xac, 0x96, 0x7d, 0x1a, 0xef, \n\t    0x00, 0xf0, 0xc8, 0xe0, 0x38, 0xde, 0x2e, 0x4d, \n\t    0x3b, 0xc2, 0xec, 0x36, 0x8a, 0xf2, 0xe9, 0xf1, \n\t    0x0a, 0x6f, 0x1e, 0xda, 0x4f, 0x72, 0x62, 0xf1, \n\t    0x36, 0x42, 0x0c, 0x07, 0xc3, 0x31, 0xb8, 0x71, \n\t    0xbf, 0x13, 0x9f, 0x74, 0xf3, 0x01, 0x0e, 0x3c, \n", "    0x4f, 0xe5, 0x7d, 0xf3, 0xaf, 0xb7, 0x16, 0x83, \n\t]\n\t_rsa_e = 0x10001\n\t_cipher = _rsa.Cipher(_ras_n, _rsa_e)\n\tdef generate_key() -> bytes:\n\t    return secrets.token_bytes(16)\n\tdef encode(key: bytes, input: str) -> str:\n\t    input_data = bytearray(input.encode())\n\t    _xor.transform(\n\t        key=_xor.derive_key(key, 4),\n", "        data=input_data\n\t    )\n\t    input_data.reverse()\n\t    _xor.transform(\n\t        key=_xor.client_key,\n\t        data=input_data\n\t    )\n\t    # Prepend key\n\t    input_data = key + input_data\n\t    return base64.b64encode(\n", "        _cipher.encrypt(input_data)\n\t    ).decode()\n\tdef decode(key: bytes, input: str) -> str:\n\t    input_data = bytearray( base64.b64decode(input) )\n\t    plaintext = _cipher.decrypt(input_data)\n\t    server_key, plaintext = plaintext[:16], plaintext[16:]\n\t    _xor.transform(\n\t        key=_xor.derive_key(server_key, 12),\n\t        data=plaintext\n\t    )\n", "    plaintext.reverse()\n\t    _xor.transform(\n\t        key=_xor.derive_key(key, 4),\n\t        data=plaintext\n\t    )\n\t    return plaintext.decode()\n"]}
{"filename": "py115/_internal/protocol/client.py", "chunked_list": ["__author__ = 'deadblue'\n\timport json\n\timport logging\n\timport time\n\timport warnings\n\tfrom urllib.parse import urlparse\n\tfrom urllib3.exceptions import InsecureRequestWarning\n\timport requests\n\tfrom py115._internal.crypto import ec115\n\tfrom py115._internal.protocol.api import ApiSpec, RetryException\n", "_logger = logging.getLogger(__name__)\n\tclass Client:\n\t    def __init__(self, **kwargs) -> None:\n\t        self._ecc = ec115.Cipher()\n\t        self._session = requests.Session()\n\t        # Configure session\n\t        self._user_agent = 'Mozilla/5.0'\n\t        self._session.headers.update({\n\t            'User-Agent': self._user_agent\n\t        })\n", "        # Flow control\n\t        self._next_request_time = 0.0\n\t        # Protocol client settings\n\t        proxy_addr = kwargs.pop('proxy', None)\n\t        if proxy_addr is not None and isinstance(proxy_addr, str):\n\t            self._session.proxies = {\n\t                'http': proxy_addr,\n\t                'https': proxy_addr\n\t            }\n\t        verify = kwargs.pop('verify', None)\n", "        if verify is not None and isinstance(verify, bool):\n\t            self._session.verify = verify\n\t            if not verify:\n\t                warnings.simplefilter('ignore', category=InsecureRequestWarning)\n\t    def import_cookies(self, cookies: dict):\n\t        for name, value in cookies.items():\n\t            self._session.cookies.set(\n\t                name, value,\n\t                domain='.115.com',\n\t                path='/'\n", "            )\n\t    def export_cookies(self, url: str = None) -> dict:\n\t        req_domain, req_path = '.115.com', '/'\n\t        if url is not None:\n\t            result = urlparse(url)\n\t            req_domain = f'.{result.hostname}'\n\t            req_path = f'{result.path}/'\n\t        cookie_dict = {}\n\t        for cookie in self._session.cookies:\n\t            # Check domain\n", "            cookie_domain = cookie.domain\n\t            if not cookie_domain.startswith('.'):\n\t                cookie_domain = f'.{cookie_domain}'\n\t            if not req_domain.endswith(cookie_domain): continue\n\t            # Check path\n\t            cookie_path = cookie.path\n\t            if not cookie_path.endswith('/'):\n\t                cookie_path = f'{cookie_path}/'\n\t            if not req_path.startswith(cookie_path): continue\n\t            # Add cookie to dict\n", "            cookie_dict[cookie.name] = cookie.value\n\t        return cookie_dict\n\t    def setup_user_agent(self, app_version: str):\n\t        self._user_agent = 'Mozilla/5.0 115Desktop/%s' % app_version\n\t        self._session.headers.update({\n\t            'User-Agent': self._user_agent\n\t        })\n\t    @property\n\t    def user_agent(self) -> str:\n\t        return self._user_agent\n", "    def execute_api(self, spec: ApiSpec):\n\t        while True:\n\t            try:\n\t                return self._execute_api_internal(spec)\n\t            except RetryException:\n\t                pass\n\t    def _execute_api_internal(self, spec: ApiSpec):\n\t        if spec.use_ec:\n\t            spec.update_qs({\n\t                'k_ec': self._ecc.encode_token(int(time.time()))\n", "            })\n\t        data = spec.payload\n\t        # Flow control\n\t        wait_time = self._next_request_time - time.time()\n\t        if wait_time > 0:\n\t            time.sleep(wait_time)\n\t        try:\n\t            if data is None:\n\t                resp = self._session.get(url=spec.url, params=spec.qs)\n\t            else:\n", "                if spec.use_ec:\n\t                    data = self._ecc.encode(data)\n\t                resp = self._session.post(\n\t                    url=spec.url, \n\t                    params=spec.qs, \n\t                    data=data,\n\t                    headers={\n\t                        'Content-Type': 'application/x-www-form-urlencoded'\n\t                    }\n\t                )\n", "        finally:\n\t            self._next_request_time = time.time() + spec.get_delay()\n\t        if spec.use_ec:\n\t            result = json.loads(self._ecc.decode(resp.content))\n\t        else:\n\t            result = resp.json()\n\t        _logger.debug('API result: %r', result)\n\t        return spec.parse_result(result)\n\t    def fetch(self, url: str) -> bytes:\n\t        resp = self._session.get(url)\n", "        return resp.content\n"]}
{"filename": "py115/_internal/protocol/api.py", "chunked_list": ["__author__ = 'deadblue'\n\timport random\n\timport typing\n\timport urllib.parse\n\tclass ApiException(Exception):\n\t    def __init__(self, code: int, *args: object) -> None:\n\t        super().__init__(*args)\n\t        self._code = code\n\t    @property\n\t    def error_code(self) -> int:\n", "        return self._code\n\tclass RetryException(Exception):\n\t    def __init__(self, *args: object) -> None:\n\t        super().__init__(*args)\n\t_ERROR_CODE_FIELDS = [\n\t    'errcode', 'errNo', 'errno', 'code'\n\t]\n\tdef find_error_code(result: dict) -> int:\n\t    if result.get('state', False):\n\t        return 0\n", "    for field in _ERROR_CODE_FIELDS:\n\t        if field not in result:\n\t            continue\n\t        ec = result[field]\n\t        if isinstance(ec, int) and ec > 0:\n\t            return ec\n\t    return -1\n\tdef _flat_params(params: dict) -> dict:\n\t    flatted_params = {}\n\t    for key, value in params.items():\n", "        if isinstance(value, typing.Dict):\n\t            for sub_k, sub_v in value.items():\n\t                sub_k = '%s[%s]' % (key, sub_k)\n\t                flatted_params[sub_k], str(sub_v)\n\t        elif isinstance(value, (typing.List, typing.Tuple)):\n\t            for sub_i, sub_v in enumerate(value):\n\t                sub_k = '%s[%d]' % (key, sub_i)\n\t                flatted_params[sub_k] = str(sub_v)\n\t        else:\n\t            flatted_params[key] = str(value)\n", "    return flatted_params\n\tclass ApiSpec:\n\t    def __init__(self, url: str, use_ec: bool = False) -> None:\n\t        self._url = url\n\t        self._use_ec = use_ec\n\t        self._qs = {}\n\t        self._form = {}\n\t    @property\n\t    def url(self) -> str:\n\t        return self._url\n", "    @property\n\t    def use_ec(self) -> bool:\n\t        return self._use_ec\n\t    @property\n\t    def qs(self) -> dict:\n\t        return self._qs\n\t    @property\n\t    def payload(self) -> bytes:\n\t        if len(self._form) > 0:\n\t            return urllib.parse.urlencode(self._form).encode()\n", "        else:\n\t            return None\n\t    def update_qs(self, params: dict):\n\t        if self._qs is None:\n\t            self._qs = _flat_params(params)\n\t        else:\n\t            self._qs.update(_flat_params(params))\n\t    def update_from(self, params: dict):\n\t        if self._form is None:\n\t            self._form = _flat_params(params)\n", "        else:\n\t            self._form.update(_flat_params(params))\n\t    def parse_result(self, result: dict) -> typing.Any:\n\t        if 'data' in result:\n\t            return result['data']\n\t        error_code = find_error_code(result)\n\t        if error_code == 0:\n\t            return None\n\t        else:\n\t            raise ApiException(error_code)\n", "    def get_delay(self) -> float:\n\t        return random.randint(100, 500) / 1000.0\n"]}
{"filename": "py115/_internal/protocol/__init__.py", "chunked_list": ["__author__ = 'deadblue'\n"]}
{"filename": "py115/_internal/api/offline.py", "chunked_list": ["__author__ = 'deadblue'\n\timport typing\n\tfrom py115._internal.api import m115\n\tfrom py115._internal.protocol import api\n\tclass ListApi(api.ApiSpec):\n\t    def __init__(self, page: int = 1) -> None:\n\t        super().__init__('https://lixian.115.com/lixian/', True)\n\t        self.update_qs({\n\t            'ct': 'lixian',\n\t            'ac': 'task_lists',\n", "            'page': page\n\t        })\n\t    def set_page(self, page: int):\n\t        self.update_qs({\n\t            'page': page\n\t        })\n\t    def parse_result(self, result: dict) -> typing.Any:\n\t        error_code = api.find_error_code(result)\n\t        if error_code != 0:\n\t            raise api.ApiException(error_code)\n", "        tasks = result.get('tasks', None)\n\t        return {\n\t            'page_count': result.get('page_count', 1),\n\t            'page': result.get('page', 1),\n\t            'task_count': result.get('count', 0),\n\t            'tasks': tasks or []\n\t        }\n\tclass DeleteApi(api.ApiSpec):\n\t    def __init__(self, task_ids: typing.Iterable[str]) -> None:\n\t        super().__init__('https://lixian.115.com/lixian/', True)\n", "        self.update_qs({\n\t            'ct': 'lixian',\n\t            'ac': 'task_del'\n\t        })\n\t        self.update_from({\n\t            'hash': task_ids,\n\t            'flag': '0',\n\t        })\n\tclass ClearApi(api.ApiSpec):\n\t    def __init__(self, flag: int) -> None:\n", "        super().__init__('https://lixian.115.com/lixian/', True)\n\t        self.update_qs({\n\t            'ct': 'lixian',\n\t            'ac': 'task_clear'\n\t        })\n\t        self.update_from({\n\t            'flag': flag\n\t        })\n\tclass AddUrlsApi(m115.M115ApiSpec):\n\t    def __init__(self, app_ver: str, user_id: int, urls: typing.Iterable[str], **kwargs) -> None:\n", "        super().__init__('https://lixian.115.com/lixianssp/', True)\n\t        self.update_qs({\n\t            'ac': 'add_task_urls'\n\t        })\n\t        params = {\n\t            'ac': 'add_task_urls',\n\t            'app_ver': app_ver,\n\t            'uid': user_id,\n\t            'url': urls\n\t        }\n", "        save_dir_id = kwargs.pop('save_dir_id', None)\n\t        if save_dir_id is not None:\n\t            params['wp_path_id'] = save_dir_id\n\t        self.update_from(params)\n\t    def parse_result(self, result: dict):\n\t        result = super().parse_result(result)\n\t        return result['result']\n"]}
{"filename": "py115/_internal/api/version.py", "chunked_list": ["__author__ = 'deadblue'\n\tfrom py115._internal.protocol.api import ApiSpec\n\tclass GetApi(ApiSpec):\n\t    def __init__(self) -> None:\n\t        super().__init__('https://appversion.115.com/1/web/1.0/api/chrome')\n\t    def parse_result(self, result: dict) -> str:\n\t        return result['data']['linux_115']['version_code']\n"]}
{"filename": "py115/_internal/api/space.py", "chunked_list": ["__author__ = 'deadblue'\n\tfrom py115._internal.protocol import api\n\tclass GetApi(api.ApiSpec):\n\t    def __init__(self) -> None:\n\t        super().__init__('https://webapi.115.com/files/index_info')\n\t    def parse_result(self, result: dict):\n\t        data = super().parse_result(result)\n\t        return data.get('space_info', None)\n"]}
{"filename": "py115/_internal/api/upload.py", "chunked_list": ["__author__ = 'deadblue'\n\timport datetime\n\timport hashlib\n\timport io\n\timport logging\n\timport time\n\timport typing\n\tfrom py115._internal.protocol import api\n\t_logger = logging.getLogger(__name__)\n\t_token_salt = 'Qclm8MGWUv59TnrR0XPg'\n", "class Helper:\n\t    _app_ver: str = None\n\t    _user_id: str = None\n\t    _user_key: str = None\n\t    _user_hash: str = None\n\t    def __init__(self, app_ver: str, user_id: int, user_key: str) -> None:\n\t        self._app_ver = app_ver\n\t        self._user_id = str(user_id)\n\t        self._user_key = user_key\n\t        self._user_hash = hashlib.md5(\n", "            self._user_id.encode()\n\t        ).hexdigest()\n\t    @property\n\t    def app_version(self) -> str:\n\t        return self._app_ver\n\t    @property\n\t    def user_id(self) -> str:\n\t        return self._user_id\n\t    def calc_sig(self, file_id: str, target_id: str) -> str:\n\t        h1 = hashlib.sha1(\n", "            f'{self._user_id}{file_id}{target_id}0'.encode()\n\t        ).hexdigest().lower()\n\t        return hashlib.sha1(\n\t            f'{self._user_key}{h1}000000'.encode()\n\t        ).hexdigest().upper()\n\t    def calc_token(\n\t            self, \n\t            file_id: str,\n\t            file_size: int,\n\t            timestamp: int,\n", "            sign_key: str = '',\n\t            sign_val: str = ''\n\t        ) -> str:\n\t        token_data = ''.join([\n\t            _token_salt, file_id, str(file_size), sign_key, sign_val, \n\t            self._user_id, str(timestamp), self._user_hash, self._app_ver\n\t        ]).encode()\n\t        return hashlib.md5(token_data).hexdigest().lower()\n\tclass InfoApi(api.ApiSpec):\n\t    def __init__(self) -> None:\n", "        super().__init__('https://proapi.115.com/app/uploadinfo')\n\t    def parse_result(self, result: dict) -> typing.Tuple[int, str]:\n\t        err_code = api.find_error_code(result)\n\t        if err_code != 0:\n\t            raise api.ApiException(err_code)\n\t        return result.get('user_id'), result.get('userkey')\n\tclass InitApi(api.ApiSpec):\n\t    _helper: Helper = None\n\t    _file_io: typing.BinaryIO = None\n\t    def __init__(\n", "            self, \n\t            target_id: str, \n\t            file_name: str, \n\t            file_io: typing.BinaryIO,\n\t            helper: Helper\n\t        ) -> None:\n\t        super().__init__('https://uplb.115.com/4.0/initupload.php', True)\n\t        self._file_io = file_io\n\t        self._helper = helper\n\t        now = int(time.time())\n", "        file_size, file_hash = _digest_file(file_io)\n\t        self.update_from({\n\t            'appid': '0',\n\t            'appversion': helper.app_version,\n\t            'userid': helper.user_id,\n\t            'filename': file_name,\n\t            'filesize': file_size,\n\t            'fileid': file_hash,\n\t            'target': target_id,\n\t            'sig': helper.calc_sig(file_hash, target_id),\n", "            't': now,\n\t            'token': helper.calc_token(file_hash, file_size, now)\n\t        })\n\t    def parse_result(self, result: dict):\n\t        status = result['status']\n\t        if status == 7:\n\t            sign_key = result['sign_key']\n\t            sign_val = _digest_file_range(self._file_io, result['sign_check'])\n\t            now = int(time.time())\n\t            self.update_from({\n", "                'sign_key': sign_key,\n\t                'sign_val': sign_val,\n\t                't': now,\n\t                'token': self._helper.calc_token(\n\t                    self._form['fileid'], \n\t                    self._form['filesize'],\n\t                    now, sign_key, sign_val\n\t                )\n\t            })\n\t            raise api.RetryException()\n", "        elif status == 2:\n\t            return  {\n\t                'done': True\n\t            }\n\t        elif status == 1:\n\t            return {\n\t                'done': False,\n\t                'bucket': result['bucket'],\n\t                'object': result['object'],\n\t                'callback': result['callback']['callback'],\n", "                'callback_var': result['callback']['callback_var']\n\t            }\n\t        else:\n\t            _logger.warning('Unexpected upload init status: %d', status)\n\t            return None\n\tdef _digest_file(r: typing.BinaryIO) -> typing.Tuple[int, str]:\n\t    h = hashlib.sha1()\n\t    while True:\n\t        chunk = r.read(4096)\n\t        if len(chunk) == 0: break\n", "        h.update(chunk)\n\t    file_size = r.tell()\n\t    file_hash = h.hexdigest().upper()\n\t    return file_size, file_hash\n\tdef _digest_file_range(r: typing.BinaryIO, check_range: str) :\n\t    tmp = [int(x) for x in check_range.split('-')]\n\t    start, length = tmp[0], tmp[1] - tmp[0] + 1\n\t    r.seek(start, io.SEEK_SET)\n\t    return hashlib.sha1(\n\t        r.read(length)\n", "    ).hexdigest().upper()\n\tclass TokenApi(api.ApiSpec):\n\t    def __init__(self) -> None:\n\t        super().__init__('https://uplb.115.com/3.0/gettoken.php')\n\t    def parse_result(self, result: dict):\n\t        if result.get('StatusCode' '') == '200':\n\t            return {\n\t                'access_key_id': result['AccessKeyId'],\n\t                'access_key_secret': result['AccessKeySecret'],\n\t                'security_token': result['SecurityToken'],\n", "                'expiration': datetime.datetime.strptime(\n\t                    result['Expiration'], '%Y-%m-%dT%H:%M:%SZ'\n\t                )\n\t            }\n\t        return None\n"]}
{"filename": "py115/_internal/api/__init__.py", "chunked_list": ["__author__ = 'deadblue'\n"]}
{"filename": "py115/_internal/api/dir.py", "chunked_list": ["__author__ = 'deadblue'\n\tfrom py115._internal.protocol import api\n\tclass AddApi(api.ApiSpec):\n\t    def __init__(self, parent_id: str, dir_name: str) -> None:\n\t        super().__init__('https://webapi.115.com/files/add')\n\t        self.update_from({\n\t            'pid': parent_id,\n\t            'cname': dir_name\n\t        })\n\t    def parse_result(self, result: dict) -> dict:\n", "        err_code = api.find_error_code(result)\n\t        if err_code != 0:\n\t            raise api.ApiException(err_code)\n\t        return {\n\t            'cid': result.get('cid'),\n\t            'n': result.get('cname')\n\t        }\n\tclass SortApi(api.ApiSpec):\n\t    def __init__(self, dir_id: str, order: str, asc: bool = False) -> None:\n\t        super().__init__('https://webapi.115.com/files/order')\n", "        self.update_from({\n\t            'file_id': dir_id,\n\t            'user_order': order,\n\t            'user_asc': '1' if asc else '0',\n\t            'fc_mix': '0'\n\t        })\n"]}
{"filename": "py115/_internal/api/file.py", "chunked_list": ["__author__ = 'deadblue'\n\timport time\n\timport typing\n\tfrom py115._internal.api import m115\n\tfrom py115._internal.protocol import api\n\tclass ListApi(api.ApiSpec):\n\t    def __init__(self, dir_id: str) -> None:\n\t        super().__init__(None)\n\t        self.update_qs({\n\t            'aid': '1',\n", "            'cid': dir_id,\n\t            'o': 'user_ptime',\n\t            'asc': '0',\n\t            'offset': '0',\n\t            'limit': '115',\n\t            'show_dir': '1',\n\t            'snap': '0',\n\t            'natsort': '1',\n\t            'format': 'json',\n\t        })\n", "    @property\n\t    def url(self) -> str:\n\t        order = self._qs.get('o')\n\t        if order == 'file_name':\n\t            return 'https://aps.115.com/natsort/files.php'\n\t        else:\n\t            return 'https://webapi.115.com/files'\n\t    def parse_result(self, result: dict) -> dict:\n\t        if result.get('state', False):\n\t            return {\n", "                'count': result.get('count'),\n\t                'offset': result.get('offset'),\n\t                'files': result.get('data')\n\t            }\n\t        else:\n\t            err_code = api.find_error_code(result)\n\t            if err_code == 20130827:\n\t                self._qs.update({\n\t                    'o': result['order'],\n\t                    'asc': result['is_asc'],\n", "                })\n\t                raise api.RetryException()\n\t            else:\n\t                raise api.ApiException(err_code)\n\t    def set_offset(self, offset: int):\n\t        self.update_qs({\n\t            'offset': str(offset)\n\t        })\n\tclass SearchApi(api.ApiSpec):\n\t    def __init__(self, keyword: str, dir_id: str) -> None:\n", "        super().__init__('https://webapi.115.com/files/search')\n\t        self.update_qs({\n\t            'aid': '1',\n\t            'cid': dir_id,\n\t            'offset': '0',\n\t            'limit': '115',\n\t            'format': 'json',\n\t            'search_value': keyword\n\t        })\n\t    def parse_result(self, result: dict) -> dict:\n", "        if result.get('state', False):\n\t            return {\n\t                'count': result.get('count'),\n\t                'offset': result.get('offset'),\n\t                'files': result.get('data')\n\t            }\n\t        else:\n\t            raise api.ApiException(api.find_error_code(result))\n\t    def set_offset(self, offset: int):\n\t        self.update_qs({\n", "            'offset': str(offset)\n\t        })\n\tclass DeleteApi(api.ApiSpec):\n\t    def __init__(self, file_ids: typing.Iterable[str]) -> None:\n\t        super().__init__('https://webapi.115.com/rb/delete')\n\t        self.update_from({\n\t            'fid': file_ids,\n\t            'ignore_warn': '1'\n\t        })\n\tclass MoveApi(api.ApiSpec):\n", "    def __init__(self, parent_id: str, file_ids: typing.Iterable[str]) -> None:\n\t        super().__init__('https://webapi.115.com/files/move')\n\t        self.update_from({\n\t            'pid': parent_id,\n\t            'fid': file_ids\n\t        })\n\tclass RenameApi(api.ApiSpec):\n\t    def __init__(self, file_id: str, new_name: str) -> None:\n\t        super().__init__('https://webapi.115.com/files/batch_rename')\n\t        key = 'files_new_name[%s]' % file_id\n", "        self.update_from({\n\t            key: new_name\n\t        })\n\tclass DownloadApi(m115.M115ApiSpec):\n\t    def __init__(self, pickcode: str) -> None:\n\t        super().__init__('https://proapi.115.com/app/chrome/downurl', True)\n\t        self.update_qs({\n\t            't': int(time.time())\n\t        })\n\t        self.update_from({\n", "            'pickcode': pickcode\n\t        })\n\t    def parse_result(self, result: dict):\n\t        result = super().parse_result(result)\n\t        if len(result) == 0:\n\t            return None\n\t        file_id, down_info = result.popitem()\n\t        if 'url' in down_info and isinstance(down_info['url'], dict):\n\t            return {\n\t                'file_id': file_id,\n", "                'file_name': down_info['file_name'],\n\t                'fize_size': int(down_info['file_size']),\n\t                'url': down_info['url']['url'].replace('http://', 'https://')\n\t            }\n\t        else:\n\t            return None\n\tclass VideoApi(api.ApiSpec):\n\t    def __init__(self, pickcode: str) -> None:\n\t        super().__init__('https://webapi.115.com/files/video', False)\n\t        self.update_qs({'pickcode': pickcode})\n", "    def parse_result(self, result: dict) -> str:\n\t        err_code = api.find_error_code(result)\n\t        if err_code != 0:\n\t            raise api.ApiException(code=err_code)\n\t        return result.get('video_url')\n"]}
{"filename": "py115/_internal/api/user.py", "chunked_list": ["__author__ = 'deadblue'\n\tfrom py115._internal.protocol.api import ApiSpec\n\tclass GetApi(ApiSpec):\n\t    def __init__(self) -> None:\n\t        super().__init__('https://my.115.com/?ct=ajax&ac=nav')\n"]}
{"filename": "py115/_internal/api/m115.py", "chunked_list": ["__author__ = 'deadblue'\n\timport json\n\timport urllib\n\tfrom py115._internal.crypto import m115\n\tfrom py115._internal.protocol import api\n\tclass M115ApiSpec(api.ApiSpec):\n\t    def __init__(self, url: str, use_ec: bool = False) -> None:\n\t        super().__init__(url, use_ec)\n\t        self._m_key = m115.generate_key()\n\t    @property\n", "    def payload(self) -> bytes:\n\t        data = m115.encode(self._m_key, json.dumps(self._form))\n\t        return urllib.parse.urlencode({\n\t            'data': data\n\t        }).encode()\n\t    def parse_result(self, result: dict):\n\t        data = super().parse_result(result)\n\t        # M115 decode\n\t        return json.loads(m115.decode(self._m_key, data))\n"]}
{"filename": "py115/_internal/api/qrcode.py", "chunked_list": ["__author__ = 'deadblue'\n\timport time as timelib\n\timport typing\n\tfrom py115._internal.protocol import api\n\t_app_id_mapping = {\n\t    'web': 0,\n\t    'mac': 7,\n\t    'linux': 7,\n\t    'windows': 7,\n\t}\n", "class _BaseApi(api.ApiSpec):\n\t    def parse_result(self, result: dict) -> typing.Any:\n\t        if result.get('state', 0) != 1:\n\t            raise api.ApiException(code=result.get('code'))\n\t        return result.get('data')\n\tclass TokenApi(_BaseApi):\n\t    def __init__(self, app_name: str) -> None:\n\t        super().__init__(\n\t            f'https://qrcodeapi.115.com/api/1.0/{app_name}/1.0/token', True\n\t        )\n", "class StatusApi(_BaseApi):\n\t    def __init__(self, uid: str, time: int, sign: str) -> None:\n\t        super().__init__('https://qrcodeapi.115.com/get/status/', False)\n\t        self.update_qs({\n\t            'uid': uid,\n\t            'time': time,\n\t            'sign': sign,\n\t            '_': int(timelib.time())\n\t        })\n\t    def parse_result(self, result: dict) -> int:\n", "        code = result.get('code', 0)\n\t        if code == 40199002:\n\t            return -9\n\t        elif code != 0:\n\t            raise api.ApiException(code)\n\t        result_data = result.get('data', {})\n\t        return result_data.get('status', 0)\n\tclass LoginApi(_BaseApi):\n\t    def __init__(self, app_name: str, uid: str) -> None:\n\t        super().__init__(\n", "            f'https://passportapi.115.com/app/1.0/{app_name}/1.0/login/qrcode', True\n\t        )\n\t        self.update_from({\n\t            'account': uid,\n\t            'app': app_name\n\t        })\n\tdef get_image_url(app_name: str, uid: str) -> str:\n\t    app_id = _app_id_mapping.get(app_name, 0)\n\t    return f'https://qrcodeapi.115.com/api/1.0/{app_name}/1.0/qrcode?qrfrom=1&client={app_id}d&uid={uid}'\n"]}
{"filename": "docs/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t#\n\t# For the full list of built-in configuration values, see the documentation:\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\timport sys\n\timport os\n\tsys.path.insert(0, os.path.abspath(\"..\"))\n\timport py115\n\t# -- Project information -----------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n", "project = 'PY115'\n\tcopyright = '2023, deadblue'\n\tauthor = 'deadblue'\n\trelease = '0.0.1'\n\t# -- General configuration ---------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\textensions = [\n\t    'sphinx.ext.autodoc',\n\t    'sphinx.ext.napoleon',\n\t    'sphinx_rtd_theme'\n", "]\n\ttemplates_path = ['_templates']\n\texclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n\t# Extension configurations\n\tautodoc_member_order = 'bysource'\n\tautodoc_typehints = 'description'\n\tnapoleon_numpy_docstring = False\n\t# -- Options for HTML output -------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\thtml_theme = 'sphinx_rtd_theme'\n", "html_static_path = ['_static']\n"]}
