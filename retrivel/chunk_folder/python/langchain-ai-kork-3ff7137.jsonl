{"filename": "tests/test_interpreter.py", "chunked_list": ["from typing import Any\n\timport pytest\n\tfrom kork import ast\n\tfrom kork.ast_printer import AstPrinter\n\tfrom kork.environment import Environment\n\tfrom kork.exceptions import KorkRunTimeException\n\tfrom kork.interpreter import run_interpreter\n\t# TODO: Determine why mypy is not recognizing the import.\n\tfrom kork.parser import parse  # type: ignore[attr-defined]\n\tdef set_up_environment() -> Environment:\n", "    \"\"\"Prepopulate an environment with some symbols.\"\"\"\n\t    environment = Environment(\n\t        parent=None,\n\t        variables={},\n\t    )\n\t    environment.set_symbol(\n\t        \"add\",\n\t        ast.ExternFunctionDef(\n\t            name=\"add\",\n\t            params=ast.ParamList(\n", "                params=[\n\t                    ast.Param(name=\"a\", type_=\"number\"),\n\t                    ast.Param(name=\"b\", type_=\"number\"),\n\t                ]\n\t            ),\n\t            return_type=\"number\",\n\t        ).add_implementation(lambda a, b: a + b),\n\t    )\n\t    environment.set_symbol(\n\t        \"time\",\n", "        ast.ExternFunctionDef(\n\t            name=\"time\",\n\t            params=ast.ParamList(params=[]),\n\t            return_type=\"number\",\n\t        ).add_implementation(lambda: 1.0),\n\t    )\n\t    return environment\n\t@pytest.mark.parametrize(\n\t    \"code, value\",\n\t    [\n", "        # Int\n\t        (\"var x = 1\", 1),\n\t        # None\n\t        (\"var x = null\", None),\n\t        # Scientific\n\t        (\"var x = 1e2\", 100),\n\t        (\"var x = 1E2\", 100),\n\t        (\"var x = 1E-2\", 0.01),\n\t        # String\n\t        ('var x = \"hello\"', \"hello\"),\n", "        # Float\n\t        (\"var x = 5.0\", 5.0),\n\t        (\"var x = 5.0 + 2\", 7.0),\n\t        (\"var x = 5\\nvar x = 2\", 2.0),\n\t        (\"var x = 5;var x = 2\", 2.0),\n\t        (\"var x = add(1,2)\", 3.0),\n\t        (\"var x = time()\", 1.0),\n\t        # Add\n\t        (\"var x = 1 + 1\", 2),\n\t        # Subtract\n", "        (\"var x = 2 - 3\", -1),\n\t        # Unary minus\n\t        (\"var x = -3\", -3),\n\t        # Divide\n\t        (\"var x = 6 / 3\", 2),\n\t        # Multiply\n\t        (\"var x = 2 * 3\", 6),\n\t        # Operator precedence\n\t        (\"var x = 1 + 3 * 3\", 10),\n\t        # Grouping\n", "        (\"var x = (1 + 1) * 3\", 6),\n\t        # List\n\t        ('var x = [1.0,2,\"3\"]', [1.0, 2, \"3\"]),\n\t        # Variable declaration and assignment\n\t        (\"var x = 1\\nx=2\", 2),\n\t        # Comments\n\t        (\"var x = 1 # comment\", 1),\n\t        (\"var x = 1 // Also a comment\", 1),\n\t        # Sum with identifiers\n\t        (\"var x = 2\\nvar x = 1 + x\", 3),\n", "        (\"var x = 2\\nvar x = 1 / x\", 0.5),\n\t        (\"var y = 1\\nvar z = 2\\nvar x = y + z\", 3),\n\t        (\"var y = 1\\nvar z = 2\\nvar x = y * z\", 2),\n\t        # Add binary operators\n\t        (\"var x = 1 + 1\", 2),\n\t        (\"var x = 1 - 1\", 0),\n\t        (\"var x = 1 * 3\", 3),\n\t        (\"var x = 8 / 2\", 4),\n\t        (\"var x = 9 % 3\", 0),\n\t        (\"var x = 9 % 5\", 4),\n", "        # unary rule\n\t        (\"var x = --3\", 3),\n\t        # Take powers\n\t        (\"var x = 2 ** 4\", 16),\n\t        (\"var x = 2 ^ 4\", 16),\n\t        (\"var x = 2 ^ -1\", 0.5),\n\t        (\"var x = 2 ^ -add(2, 2)\", 1 / 16),\n\t        (\"var x = 2 ^ +add(2, 2)\", 16),\n\t        (\"var y = 3; var x = 2 ^ y\", 8),\n\t        (\"var y = 3; var z = 2; var x = z ^ y\", 8),\n", "        (\"var y = 3; var z = 2; var x = z ** y\", 8),\n\t        # Add binary operators involving primary and function call\n\t        (\"var z = 2\\nvar x = 1 + add(z, z)\", 5),\n\t        # Add binary operators involving function calls\n\t        (\"var z = 2\\nvar x = add(z, z) * add(z, z)\", 16),\n\t        # Repeat tests but with semi-colons\n\t        # Sum with identifiers\n\t        (\"var x = 2; x = 1 + x;\", 3),\n\t        (\"var x = 2; x = 1 / x;\", 0.5),\n\t        (\"var y = 1; z = 2; x = y + z;\", 3),\n", "        (\"var y = 1; z = 2; x = y * z;\", 2),\n\t        # Add binary operators involving primary and function call\n\t        (\"var z = 2; x = 1 + add(z, z);\", 5),\n\t        # Add binary operators involving function calls\n\t        (\"var z = 2; x = add(z, z) * add(z, z);\", 16),\n\t    ],\n\t)\n\tdef test_interpreter(code: str, value: Any) -> None:\n\t    \"\"\"Run program and verify value of `x` symbol is as expected.\"\"\"\n\t    result = run_interpreter(code, environment=set_up_environment())\n", "    assert result[\"environment\"].get_symbol(\"x\") == value\n\tdef test_interpreter_extern_func_declaration() -> None:\n\t    \"\"\"Test that an extern function declaration is added to the environment.\"\"\"\n\t    result = run_interpreter(\"extern fn meow(x : int, y:int) -> int\")\n\t    env = result[\"environment\"]\n\t    extern_fn_declaration = env.get_symbol(\"meow\")\n\t    assert isinstance(extern_fn_declaration, ast.ExternFunctionDef)\n\t    # Verify that the function cannot be called.\n\t    result = run_interpreter(\"meow(1,2)\", environment=env)\n\t    assert isinstance(result[\"errors\"][0], KorkRunTimeException)\n", "    env.set_symbol(\"meow\", extern_fn_declaration.add_implementation(lambda x, y: x + y))\n\t    result = run_interpreter(\"var x = meow(1,2)\", environment=env)\n\t    assert result[\"environment\"].get_symbol(\"x\") == 3\n\tdef test_cannot_invoke_undefined_variable() -> None:\n\t    \"\"\"Test exception is raised when referencing an undefined variable.\"\"\"\n\t    result = run_interpreter(\"var x = y\")\n\t    assert isinstance(result[\"errors\"][0], KorkRunTimeException)\n\tdef test_function_definition() -> None:\n\t    \"\"\"Test unimplemented features raise exception.\"\"\"\n\t    result = run_interpreter(\"def fn meow(x : int, y:int) -> int {}\")\n", "    assert isinstance(result[\"errors\"][0], KorkRunTimeException)\n\tdef test_function_invocation() -> None:\n\t    \"\"\"Test unimplemented features raise exception.\"\"\"\n\t    environment = Environment(parent=None, variables={})\n\t    environment.set_symbol(\n\t        \"meow\",\n\t        ast.FunctionDef(\n\t            name=\"meow\",\n\t            body=[],\n\t            params=ast.ParamList(\n", "                params=[\n\t                    ast.Param(name=\"a\", type_=\"number\"),\n\t                    ast.Param(name=\"b\", type_=\"number\"),\n\t                ]\n\t            ),\n\t            return_type=\"number\",\n\t        ),\n\t    )\n\t    result = run_interpreter(\"var x = meow(1,2)\", environment=environment)\n\t    run_interpreter(\"fn meow(x : int, y:int) -> int {}\\nmeow(1,2)\")\n", "    assert isinstance(result[\"errors\"][0], KorkRunTimeException)\n\t@pytest.mark.parametrize(\n\t    \"code, expected\",\n\t    [\n\t        (\"var x = 5\", \"var x = 5\"),\n\t        (\"var x = 5\\t\\t\\t\\nadd(2,3  )\", \"var x = 5\\nadd(2, 3)\"),\n\t        # Verify whitespace insensitivity\n\t        (\"extern fn add(x : int, y:int)->int\", \"extern fn add(x: int, y: int) -> int\"),\n\t        (\n\t            \"extern fn add  (x : int, y:int) -> int\",\n", "            \"extern fn add(x: int, y: int) -> int\",\n\t        ),\n\t        (\"fn add(x : int, y:int) -> int {}\", \"fn add(x: int, y: int) -> int {\\n}\"),\n\t        ('var x = [\"a\", [], 1, 2.0, null]', 'var x = [\"a\", [], 1, 2.0, null]'),\n\t        (\"var x = []; var z = 1;\", \"var x = []\\nvar z = 1\"),\n\t    ],\n\t)\n\tdef test_ast_parsing_and_printing(code: str, expected: str) -> None:\n\t    \"\"\"Test parsing of code into an AST and then printing it back as code.\"\"\"\n\t    program = parse(code)\n", "    assert AstPrinter().visit(program) == expected\n"]}
{"filename": "tests/test_examples.py", "chunked_list": ["from kork.ast_printer import AstPrinter\n\tfrom kork.examples import c_, format_examples, r_\n\tdef add_(x: int, y: int) -> int:\n\t    \"\"\"Add two numbers.\"\"\"\n\t    return x + y\n\tdef test_format_examples() -> None:\n\t    \"\"\"Test format examples.\"\"\"\n\t    examples = [\n\t        (\n\t            \"Add 1 and 2\",\n", "            r_(c_(add_, 1, 2)),\n\t        ),\n\t    ]\n\t    formatted_examples = format_examples(\n\t        language_name=\"meow\",\n\t        examples=examples,\n\t        ast_printer=AstPrinter(),\n\t    )\n\t    assert formatted_examples == [\n\t        (\n", "            \"Add 1 and 2\",\n\t            \"<code>var result = add_(1, 2)</code>\",\n\t        ),\n\t    ]\n"]}
{"filename": "tests/test_foreign_functions.py", "chunked_list": ["from typing import Any, Literal, Mapping, Sequence, Union\n\tfrom kork.ast import ExternFunctionDef, Param, ParamList\n\tfrom kork.foreign_funcs import to_extern_func_def\n\t# Do not type the function below. We're testing initialization of the retriever.\n\tdef foo():  # type: ignore\n\t    pass\n\tdef bar(x: int) -> int:\n\t    \"\"\"Add one to x.\"\"\"\n\t    return x + 1\n\tdef zoo(x: Mapping[str, Any], q: Sequence[Union[Literal[\"a\"], Literal[\"b\"]]]) -> Any:\n", "    \"\"\"Add one to x.\"\"\"\n\t    pass\n\tdef test_to_extern_func_def() -> None:\n\t    \"\"\"Test conversion of a python function into an extern function definition.\"\"\"\n\t    assert to_extern_func_def(foo) == ExternFunctionDef(\n\t        name=\"foo\",\n\t        params=ParamList(params=[]),\n\t        # If the source function is un-typed, we assume\n\t        # that the return type is Any.\n\t        return_type=\"Any\",\n", "        implementation=foo,\n\t        doc_string=\"\",\n\t    )\n\t    assert to_extern_func_def(bar) == ExternFunctionDef(\n\t        name=\"bar\",\n\t        params=ParamList(params=[Param(name=\"x\", type_=\"int\")]),\n\t        return_type=\"int\",\n\t        implementation=bar,\n\t        doc_string=\"Add one to x.\",\n\t    )\n", "    assert to_extern_func_def(zoo) == ExternFunctionDef(\n\t        name=\"zoo\",\n\t        params=ParamList(\n\t            params=[\n\t                Param(name=\"x\", type_=\"Mapping[str, Any]\"),\n\t                Param(\n\t                    name=\"q\",\n\t                    type_=\"Sequence[Union[Literal['a'], Literal['b']]]\",\n\t                ),\n\t            ]\n", "        ),\n\t        return_type=\"Any\",\n\t        implementation=zoo,\n\t        doc_string=\"Add one to x.\",\n\t    )\n"]}
{"filename": "tests/test_ast.py", "chunked_list": ["from kork.ast import _to_snake_case\n\tdef test_snake_case() -> None:\n\t    assert _to_snake_case(\"Number\") == \"number\"\n\t    assert _to_snake_case(\"NumberWoof\") == \"number_woof\"\n"]}
{"filename": "tests/test_prompt_adapter.py", "chunked_list": ["from langchain.prompts import PromptTemplate\n\tfrom kork.prompt_adapter import FewShotPromptValue, FewShotTemplate\n\tdef test_few_shot_template() -> None:\n\t    \"\"\"Test few shot template.\"\"\"\n\t    prompt_template = PromptTemplate(\n\t        template=\"meow\\n\\n\",\n\t        input_variables=[],\n\t    )\n\t    few_shot_template = FewShotTemplate(\n\t        instruction_template=prompt_template,\n", "        examples=[(\"foo\", \"bar\")],\n\t        input_variables=[\"query\"],\n\t    )\n\t    prompt_value = few_shot_template.format_prompt(query=\"query\")\n\t    assert isinstance(prompt_value, FewShotPromptValue)\n\t    # Test to_string()\n\t    assert (\n\t        prompt_value.to_string()\n\t        == \"meow\\n\\nInput: foo\\n\\nOutput: bar\\n\\nInput: query\\n\\nOutput:\"\n\t    )\n", "    # Test to_messages()\n\t    messages = prompt_value.to_messages()\n\t    assert len(messages) == 4\n\t    assert messages[0].content == \"meow\"\n\t    assert messages[1].content == \"foo\"\n\t    assert messages[2].content == \"bar\"\n\t    assert messages[3].content == \"query\"\n\tdef test_few_shot_template_with_no_examples() -> None:\n\t    \"\"\"Test few shot template without any examples\"\"\"\n\t    prompt_template = PromptTemplate(\n", "        template=\"meow\\n\\n\",\n\t        input_variables=[],\n\t    )\n\t    few_shot_template = FewShotTemplate(\n\t        instruction_template=prompt_template,\n\t        examples=[],\n\t        input_variables=[\"query\"],\n\t    )\n\t    prompt_value = few_shot_template.format_prompt(query=\"query\")\n\t    assert isinstance(prompt_value, FewShotPromptValue)\n", "    # Test to_string()\n\t    assert prompt_value.to_string() == \"meow\\n\\nInput: query\\n\\nOutput:\"\n\t    # Test to_messages()\n\t    messages = prompt_value.to_messages()\n\t    assert len(messages) == 2\n\t    assert messages[0].content == \"meow\"\n\t    assert messages[1].content == \"query\"\n"]}
{"filename": "tests/test_chain.py", "chunked_list": ["from kork import AstPrinter, CodeChain, SimpleContextRetriever, run_interpreter\n\tfrom kork.examples import SimpleExampleRetriever\n\tfrom kork.exceptions import KorkRunTimeException, LLMParseException\n\tfrom kork.parser import parse  # type: ignore\n\tfrom .utils import ToyChatModel\n\tdef test_code_chain() -> None:\n\t    \"\"\"Test the code chain.\"\"\"\n\t    example_retriever = SimpleExampleRetriever(examples=[(\"Add 1 and 2\", \"add_(1, 2)\")])\n\t    llm = ToyChatModel(response=\"<code>var x = 1</code>\")\n\t    chain = CodeChain(\n", "        llm=llm,\n\t        retriever=SimpleContextRetriever(),\n\t        interpreter=run_interpreter,\n\t        ast_printer=AstPrinter(),\n\t        example_retriever=example_retriever,\n\t    )\n\t    response = chain(inputs={\"query\": \"blah\"})\n\t    # Why does the chain return a `query` key?\n\t    assert sorted(response) == [\"code\", \"environment\", \"errors\", \"query\", \"raw\"]\n\t    env = response.pop(\"environment\")\n", "    assert response == {\n\t        \"query\": \"blah\",\n\t        \"code\": \"var x = 1\",\n\t        \"errors\": [],\n\t        \"raw\": \"<code>var x = 1</code>\",\n\t    }\n\t    assert env.get_symbol(\"x\") == 1\n\tdef test_bad_program() -> None:\n\t    \"\"\"Test the code chain.\"\"\"\n\t    example_retriever = SimpleExampleRetriever(examples=[(\"Add 1 and 2\", \"add_(1, 2)\")])\n", "    llm = ToyChatModel(response=\"<code>\\nINVALID PROGRAM\\n</code>\")\n\t    chain = CodeChain(\n\t        llm=llm,\n\t        retriever=SimpleContextRetriever(),\n\t        interpreter=run_interpreter,\n\t        ast_printer=AstPrinter(),\n\t        example_retriever=example_retriever,\n\t    )\n\t    response = chain(inputs={\"query\": \"blah\"})\n\t    # Why does the chain return a `query` key?\n", "    assert sorted(response) == [\"code\", \"environment\", \"errors\", \"query\", \"raw\"]\n\t    assert response[\"raw\"] == \"<code>\\nINVALID PROGRAM\\n</code>\"\n\t    assert response[\"code\"] == \"\\nINVALID PROGRAM\\n\"\n\t    assert response[\"environment\"] is None\n\t    assert response[\"errors\"] is not None\n\t    assert isinstance(response[\"errors\"][0], KorkRunTimeException)\n\tdef test_llm_output_missing_program() -> None:\n\t    \"\"\"Test the code chain with llm response that's missing code.\"\"\"\n\t    llm = ToyChatModel(response=\"oops.\")\n\t    example_retriever = SimpleExampleRetriever(examples=[(\"Add 1 and 2\", \"add_(1, 2)\")])\n", "    chain = CodeChain(\n\t        llm=llm,\n\t        retriever=SimpleContextRetriever(),\n\t        interpreter=run_interpreter,\n\t        ast_printer=AstPrinter(),\n\t        example_retriever=example_retriever,\n\t    )\n\t    response = chain(inputs={\"query\": \"blah\"})\n\t    # Why does the chain return a `query` key?\n\t    assert sorted(response) == [\"code\", \"environment\", \"errors\", \"query\", \"raw\"]\n", "    assert response[\"raw\"] == \"oops.\"\n\t    assert response[\"code\"] == \"\"\n\t    assert response[\"environment\"] is None\n\t    errors = response[\"errors\"]\n\t    assert len(errors) == 1\n\t    assert isinstance(response[\"errors\"][0], LLMParseException)\n\tdef test_from_defaults_instantiation() -> None:\n\t    \"\"\"Test from default instantiation.\"\"\"\n\t    llm = ToyChatModel(response=\"<code>\\nvar x = 1;\\n</code>\")\n\t    chain = CodeChain.from_defaults(llm=llm)\n", "    response = chain(inputs={\"query\": \"blah\"})\n\t    # Why does the chain return a `query` key?\n\t    assert sorted(response) == [\"code\", \"environment\", \"errors\", \"query\", \"raw\"]\n\t    assert response[\"environment\"].get_symbol(\"x\") == 1\n\t    # Instantiate with sequence of examples and foreign functions\n\t    def _do() -> int:\n\t        \"\"\"Do something\"\"\"\n\t        return 1\n\t    # Verify that we can instantiate\n\t    examples = [(\"Add 1 and 2\", parse(\"add_(1, 2)\"))]\n", "    chain2 = CodeChain.from_defaults(\n\t        llm=llm, examples=examples, context=[_do], language_name=\"kork\"\n\t    )\n\t    assert isinstance(chain2.context_retriever, SimpleContextRetriever)\n\t    external_func_defs = chain2.context_retriever.retrieve(\"[anything]\")\n\t    # Check foreign funcs\n\t    assert len(external_func_defs) == 1\n\t    assert external_func_defs[0].name == \"_do\"\n\t    # Check examples\n\t    assert isinstance(chain2.example_retriever, SimpleExampleRetriever)\n", "    assert chain2.example_retriever.retrieve(\"[anything]\") == [\n\t        # Please note that an input formatted was applied by default to the example\n\t        (\"```text\\nAdd 1 and 2\\n```\", \"<code>add_(1, 2)</code>\")\n\t    ]\n"]}
{"filename": "tests/test_retrieval.py", "chunked_list": ["from kork.ast import ExternFunctionDef, ParamList\n\tfrom kork.retrieval import SimpleContextRetriever\n\tdef foo() -> None:\n\t    \"\"\"Do nothing.\"\"\"\n\tdef bar(x: int) -> int:\n\t    \"\"\"Add one to x.\"\"\"\n\t    return x + 1\n\tdef test_simple_retriever() -> None:\n\t    \"\"\"Test simple retriever\"\"\"\n\t    external_func = ExternFunctionDef(\n", "        name=\"meow\",\n\t        params=ParamList(params=[]),\n\t        return_type=\"int\",\n\t        implementation=None,\n\t    )\n\t    simple_retriever = SimpleContextRetriever.from_functions([foo, bar, external_func])\n\t    external_func_defs = simple_retriever.retrieve(\"does not matter\")\n\t    assert len(external_func_defs) == 3\n\t    assert external_func_defs[0].name == \"foo\"\n\t    assert external_func_defs[1].name == \"bar\"\n", "    assert external_func_defs[2].name == \"meow\"\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/utils.py", "chunked_list": ["from typing import Any, List, Optional\n\tfrom langchain.chat_models.base import BaseChatModel\n\tfrom langchain.schema import AIMessage, BaseMessage, ChatGeneration, ChatResult\n\tfrom pydantic import Extra\n\tclass ToyChatModel(BaseChatModel):\n\t    response: str\n\t    class Config:\n\t        \"\"\"Configuration for this pydantic object.\"\"\"\n\t        extra = Extra.forbid\n\t        arbitrary_types_allowed = True\n", "    def _generate(\n\t        self, messages: List[BaseMessage], stop: Optional[List[str]] = None\n\t    ) -> ChatResult:\n\t        message = AIMessage(content=self.response)\n\t        generation = ChatGeneration(message=message)\n\t        return ChatResult(generations=[generation])\n\t    async def _agenerate(\n\t        self, messages: List[BaseMessage], stop: Optional[List[str]] = None\n\t    ) -> Any:\n\t        \"\"\"Async version of _generate.\"\"\"\n", "        message = AIMessage(content=self.response)\n\t        generation = ChatGeneration(message=message)\n\t        return ChatResult(generations=[generation])\n"]}
{"filename": "tests/test_environment.py", "chunked_list": ["import pytest\n\tfrom kork import ast\n\tfrom kork.environment import Environment\n\tfrom kork.exceptions import KorkRunTimeException\n\tdef test_accessing_variables() -> None:\n\t    \"\"\"Test the instantiation of the environment.\"\"\"\n\t    env = Environment()\n\t    with pytest.raises(KorkRunTimeException):\n\t        env.get_symbol(\"x\")\n\t    env.set_symbol(\"x\", 1)\n", "    assert env.get_symbol(\"x\") == 1\n\tdef test_clone() -> None:\n\t    \"\"\"Test env cloning.\"\"\"\n\t    env = Environment()\n\t    env.set_symbol(\"x\", 1)\n\t    new_env = env.clone()\n\t    env.set_symbol(\"y\", 2)\n\t    new_env.set_symbol(\"z\", 3)\n\t    assert env.variables == {\"x\": 1, \"y\": 2}\n\t    assert new_env.variables == {\"x\": 1, \"z\": 3}\n", "def test_list_external_functions() -> None:\n\t    \"\"\"Test list external functions.\"\"\"\n\t    env = Environment()\n\t    assert env.list_external_functions() == []\n\t    func = ast.ExternFunctionDef(\n\t        name=\"foo\", params=ast.ParamList([]), return_type=\"Any\"\n\t    )\n\t    env.set_symbol(\"foo\", func)\n\t    assert env.list_external_functions() == [func]\n"]}
{"filename": "tests/test_utils.py", "chunked_list": ["from kork.utils import unwrap_code, unwrap_tag, wrap_in_tag\n\tdef test_unwrap_tag() -> None:\n\t    \"\"\"Test unwrap_tag.\"\"\"\n\t    # Test with an empty string\n\t    assert unwrap_tag(\"\", \"\") is None\n\t    # Test with a string that doesn't contain the tag\n\t    assert unwrap_tag(\"table\", \"This is some text.\") is None\n\t    # Test with a string that does contain the tag\n\t    assert unwrap_tag(\"table\", \"<table>hello</table>\") == \"hello\"\n\t    # Test with a string that does contain the tag and some stuff before and after\n", "    assert unwrap_tag(\"table\", \"prefix<table>hello</table>suffix\") == \"hello\"\n\tdef test_wrap_in_tag() -> None:\n\t    \"\"\"Test wrap_in_tag.\"\"\"\n\t    assert wrap_in_tag(\"table\", \"hello\") == \"<table>hello</table>\"\n\tdef test_unwrap_code() -> None:\n\t    \"\"\"Unwrap code.\"\"\"\n\t    assert unwrap_code(\"python\", \"\") is None\n\t    assert unwrap_code(\"python\", \"```python\\nprint('hello')\\n```\") == \"print('hello')\"\n"]}
{"filename": "kork/version.py", "chunked_list": ["\"\"\"Get the version of the package.\"\"\"\n\tfrom importlib import metadata\n\ttry:\n\t    __version__ = metadata.version(\"kork\")\n\texcept metadata.PackageNotFoundError:\n\t    __version__ = \"local\"\n"]}
{"filename": "kork/ast_printer.py", "chunked_list": ["import abc\n\tfrom typing import Any, Union\n\tfrom kork import ast\n\tclass AbstractAstPrinter(ast.Visitor, abc.ABC):\n\t    @abc.abstractmethod\n\t    def visit(\n\t        self, element: Union[ast.Stmt, ast.Expr], pretty_print: bool = False\n\t    ) -> str:\n\t        \"\"\"Entry-point for printing the AST.\"\"\"\n\tclass AstPrinter(AbstractAstPrinter):\n", "    \"\"\"Default AST Printer implementation.\"\"\"\n\t    def visit(\n\t        self, element: Union[ast.Stmt, ast.Expr], pretty_print: bool = False\n\t    ) -> str:\n\t        \"\"\"Entry-point for printing the AST.\"\"\"\n\t        data = {\n\t            \"call_depth\": 0,\n\t            \"pretty_print\": pretty_print,\n\t        }\n\t        return element.accept(self, **data)\n", "    def visit_program(self, program: ast.Program, **data: Any) -> str:\n\t        \"\"\"Print a program.\"\"\"\n\t        return \"\\n\".join(stmt.accept(self, **data) for stmt in program.stmts)\n\t    def visit_extern_function_def(\n\t        self, extern_function_def: ast.ExternFunctionDef, **data: Any\n\t    ) -> str:\n\t        \"\"\"Print an extern function definition.\"\"\"\n\t        code = [\n\t            f\"extern fn {extern_function_def.name}\",\n\t            \"(\",\n", "            extern_function_def.params.accept(self, **data),\n\t            \")\",\n\t            \" -> \",\n\t            extern_function_def.return_type,\n\t        ]\n\t        if extern_function_def.doc_string:\n\t            # TODO: This is hacky for prototyping, will need to have a better\n\t            # way to represent the doc string.\n\t            doc_string = extern_function_def.doc_string.strip().split(\"\\n\")[0]\n\t            code.append(f\" // {doc_string}\")\n", "        return \"\".join(code)\n\t    def visit_function_call(self, call: ast.FunctionCall, **data: Any) -> str:\n\t        \"\"\"Print a function call.\"\"\"\n\t        data[\"call_depth\"] += 1\n\t        if data[\"pretty_print\"]:\n\t            call_str = f\"{call.name}(\\n\"\n\t            call_str += \",\\n\".join(\n\t                \"    \" * data[\"call_depth\"] + arg.accept(self, **data)\n\t                for arg in call.args\n\t            )\n", "            call_str += \"\\n\" + \"    \" * (data[\"call_depth\"] - 1) + \")\"\n\t        else:\n\t            call_str = (\n\t                f\"{call.name}(\"\n\t                f\"{', '.join(arg.accept(self, **data) for arg in call.args)}\"\n\t                f\")\"\n\t            )\n\t        return call_str\n\t    def visit_function_def(self, function_def: ast.FunctionDef, **data: Any) -> str:\n\t        \"\"\"Print a function definition.\"\"\"\n", "        signature = [\n\t            f\"fn {function_def.name}\",\n\t            \"(\",\n\t            function_def.params.accept(self, **data),\n\t            \")\",\n\t            \" -> \",\n\t            function_def.return_type,\n\t        ]\n\t        code = [\" {\"]\n\t        for stmt in function_def.body:\n", "            code.append(stmt.accept(self, **data))\n\t        code.append(\"}\")\n\t        return \"\".join(signature) + \"\\n\".join(code)\n\t    def visit_variable(self, variable: ast.Variable, **data: Any) -> str:\n\t        \"\"\"Print a variable.\"\"\"\n\t        return variable.name\n\t    def visit_var_decl(self, var_decl: ast.VarDecl, **data: Any) -> str:\n\t        \"\"\"Print a variable declaration.\"\"\"\n\t        return f\"var {var_decl.name} = {var_decl.value.accept(self, **data)}\"\n\t    def visit_assign(self, assign: ast.Assign, **data: Any) -> str:\n", "        \"\"\"Print an assignment.\"\"\"\n\t        return f\"{assign.name} = {assign.value.accept(self, **data)}\"\n\t    def visit_literal(self, literal: ast.Literal, **data: Any) -> str:\n\t        \"\"\"Print a literal.\"\"\"\n\t        value = literal.value\n\t        if isinstance(value, type(None)):\n\t            return \"null\"\n\t        elif isinstance(value, bool):\n\t            return str(value).lower()\n\t        elif isinstance(value, str):\n", "            return f'\"{value}\"'\n\t        elif isinstance(value, (float, int)):\n\t            return str(value)\n\t        else:\n\t            raise AssertionError(f\"Unknown literal type: {type(value)}\")\n\t    def visit_param_list(self, param_list: ast.ParamList, **data: Any) -> str:\n\t        \"\"\"Print a parameter list.\"\"\"\n\t        return \", \".join(param.accept(self, **data) for param in param_list.params)\n\t    def visit_param(self, param: ast.Param, **data: Any) -> str:\n\t        \"\"\"Print a parameter.\"\"\"\n", "        return f\"{param.name}: {param.type_}\"\n\t    def visit_list_(self, list_: ast.List_, **data: Any) -> str:\n\t        \"\"\"Print a list.\"\"\"\n\t        return (\n\t            f\"[{', '.join(element.accept(self, **data) for element in list_.elements)}]\"\n\t        )\n\t    def visit_unary(self, unary: ast.Unary, **data: Any) -> str:\n\t        \"\"\"Visit a unary expression.\"\"\"\n\t        return f\"{unary.operator}{unary.right.accept(self, **data)}\"\n\t    def visit_grouping(self, grouping: ast.Grouping, **data: Any) -> str:\n", "        return f\"({grouping.expr.accept(self, **data)})\"\n\t    def visit_binary(self, binary: ast.Binary, **data: Any) -> str:\n\t        \"\"\"Print a binary expression.\"\"\"\n\t        return (\n\t            f\"{binary.left.accept(self, **data)} \"\n\t            f\"{binary.operator} {binary.right.accept(self, **data)}\"\n\t        )\n"]}
{"filename": "kork/environment.py", "chunked_list": ["from __future__ import annotations\n\timport copy\n\timport dataclasses\n\tfrom dataclasses import field\n\tfrom typing import Any, Dict, List, Mapping, Optional, Sequence\n\tfrom kork import ast\n\tfrom kork.exceptions import KorkRunTimeException\n\t@dataclasses.dataclass\n\tclass Environment:\n\t    \"\"\"Environment for storing variables and function definitions.\"\"\"\n", "    parent: Optional[Environment] = None\n\t    variables: Dict[str, Any] = field(default_factory=dict)\n\t    def get_symbol(self, name: str) -> Any:\n\t        \"\"\"Get a symbol from the environment.\n\t        Args:\n\t            name: symbol name to lookup\n\t        Returns:\n\t            SymbolValue for the given symbol if it exists, otherwise raises an error\n\t        \"\"\"\n\t        if name in self.variables:\n", "            return self.variables[name]\n\t        elif self.parent:\n\t            return self.parent.get_symbol(name)\n\t        else:\n\t            raise KorkRunTimeException(f\"Variable `{name}` not found\")\n\t    def set_symbol(self, name: str, value: Any) -> Any:\n\t        \"\"\"Set a symbol in the environment.\"\"\"\n\t        # TODO: We need to determine whether want the variable to be\n\t        #       declared prior to be being set.\n\t        #       At the moment, this allows for `x = 1` without having to declare the\n", "        #       variable.\n\t        self.variables[name] = value\n\t        return value\n\t    def clone(self) -> Environment:\n\t        \"\"\"Clone a root level environment, with deep copy on variables.\n\t        Cloning functionality is provided because the environment is\n\t        a mutable variable.\n\t        Biggest danger is mutating the variables dict which the caller\n\t        may retain a reference to.\n\t        TODO(Eugene): Refactor to make this less dangerous.\n", "        \"\"\"\n\t        if self.parent is not None:\n\t            raise AssertionError(\"Cannot clone an environment with a parent.\")\n\t        return Environment(parent=None, variables=copy.deepcopy(self.variables))\n\t    def list_external_functions(self) -> List[ast.ExternFunctionDef]:\n\t        \"\"\"Get a list of the externally defined foreign functions.\"\"\"\n\t        return [\n\t            func\n\t            for func in self.variables.values()\n\t            if isinstance(func, ast.ExternFunctionDef)\n", "        ]\n\tdef create_environment(\n\t    extern_function_defs: Sequence[ast.ExternFunctionDef],\n\t    external_variables: Optional[Mapping[str, Any]] = None,\n\t) -> Environment:\n\t    \"\"\"Create a new environment with pre-populated state.\"\"\"\n\t    variables: Dict[str, Any] = {func.name: func for func in extern_function_defs}\n\t    environment = Environment(parent=None, variables=variables)\n\t    if external_variables:\n\t        for name, value in external_variables.items():\n", "            # At the moment, let's not clone the variable so that it can be\n\t            # mutated if the goal is to do mutation.\n\t            environment.set_symbol(name, value)\n\t    return environment\n"]}
{"filename": "kork/parser.py", "chunked_list": ["# type:ignore[no-untyped-def]\n\t\"\"\"Kork's default AST parser.\n\tKork uses Lark to parse the AST. The grammar follows closely\n\tthe one used in Crafting Interpreters for the Lox Programming Language.\n\thttps://craftinginterpreters.com/appendix-i.html#expressions\n\tThe grammar and parser were clobbered together in a few hours of work.\n\tIf you deeply care about language design, please forgive any transgressions,\n\tand feel free to help improve the grammar/parser/interpreter.\n\t\"\"\"\n\tfrom typing import cast\n", "from lark import Lark, Transformer, v_args\n\tfrom kork import ast\n\tGRAMMAR = \"\"\"\n\t    program: statement+\n\t    statement: function_decl\n\t              | extern_function_decl\n\t              | var_decl\n\t              | expr\n\t    function_decl: \"fn\" CNAME \"(\" [params] \")\" \"->\" type block\n\t    extern_function_decl: \"extern\" \"fn\" CNAME \"(\" [params] \")\" \"->\" type\n", "    var_decl: (\"let\" | \"const\" | \"var\") CNAME \"=\" expr [\";\"]\n\t    params: param (\",\" param)*\n\t    param: CNAME \":\" type\n\t    type: CNAME\n\t    block: \"{\" [statement+] \"}\"\n\t    ?expr: assignment\n\t    ?assignment: CNAME \"=\" expr [\";\"] -> variable_assign\n\t        | term\n\t    !?term: term \"+\" factor -> binary\n\t        | term \"-\" factor -> binary\n", "        | factor\n\t    !?factor: factor \"*\" unary -> binary\n\t        | factor \"/\" unary -> binary\n\t        | factor \"%\" unary -> binary\n\t        | unary\n\t    !?unary: \"-\" unary -> unary_r\n\t        | \"+\" unary -> unary_r\n\t        | power\n\t    !?power: call \"**\" unary -> binary\n\t        | call \"^\" unary -> binary\n", "        | call\n\t    ?call: CNAME \"(\" [args] \")\" -> function_call\n\t        | primary\n\t    ?primary: numbers\n\t        | list\n\t        | string\n\t        | \"true\" -> true\n\t        | \"false\" -> false\n\t        | \"null\" -> null\n\t        | \"(\" expr \")\" -> group\n", "        | CNAME -> identifier\n\t    ?numbers: SIGNED_NUMBER (\"E\"|\"e\") SIGNED_NUMBER -> scientific\n\t        | SIGNED_NUMBER -> number\n\t    args: expr (\",\" expr)*\n\t    string: ESCAPED_STRING\n\t    list: \"[\" [args] \"]\"\n\t    %import common.CNAME\n\t    %import common.SIGNED_NUMBER\n\t    %import common.ESCAPED_STRING\n\t    %import common.WS\n", "    %ignore WS\n\t    %ignore /#.*/\n\t    %ignore /\\/\\/.*/\n\t\"\"\"\n\t# mypy: ignore-errors\n\t@v_args(inline=True)\n\tclass AstParser(Transformer):\n\t    \"\"\"An ast parser for the given language.\"\"\"\n\t    def program(self, *items) -> ast.Program:\n\t        \"\"\"Create a program from the given statements.\"\"\"\n", "        return ast.Program(stmts=items)\n\t    def function_decl(self, name, params, return_type, block) -> ast.FunctionDef:\n\t        \"\"\"Function declaration from the given name, params, return type and block.\"\"\"\n\t        return ast.FunctionDef(\n\t            name=str(name),\n\t            params=params,\n\t            return_type=return_type,\n\t            body=block,\n\t        )\n\t    def extern_function_decl(self, name, params, return_type) -> ast.ExternFunctionDef:\n", "        \"\"\"Extern function declaration from the given name, params and return type.\"\"\"\n\t        return ast.ExternFunctionDef(\n\t            name=str(name),\n\t            params=params or ast.ParamList(params=[]),\n\t            return_type=return_type,\n\t        )\n\t    def statement(self, item) -> ast.Stmt:\n\t        \"\"\"Create a statement from the given item.\"\"\"\n\t        return item\n\t    def var_decl(self, name, value) -> ast.VarDecl:\n", "        \"\"\"Variable declaration from the given name and value.\"\"\"\n\t        return ast.VarDecl(\n\t            name=str(name),\n\t            value=value,\n\t        )\n\t    def params(self, *items) -> ast.ParamList:\n\t        \"\"\"Create a param list from the given items.\"\"\"\n\t        return ast.ParamList(params=items or [])\n\t    def unary_r(self, operator, right) -> ast.Unary:\n\t        \"\"\"Create a unary from the given operator and left.\"\"\"\n", "        op = str(operator)\n\t        if op not in {\"+\", \"-\"}:\n\t            raise ValueError(f\"Unknown operator: {op}.\")\n\t        return ast.Unary(operator=str(operator), right=right)\n\t    def binary(self, left, operator, right) -> ast.Binary:\n\t        \"\"\"Create a binary from the given left, operator and right.\"\"\"\n\t        op = str(operator)\n\t        if op not in {\"+\", \"-\", \"*\", \"/\", \"**\", \"//\", \"%\", \"^\"}:\n\t            raise ValueError(f\"Unknown operator: {op}.\")\n\t        return ast.Binary(left=left, operator=str(operator), right=right)\n", "    def param(self, name, type_) -> ast.Param:\n\t        \"\"\"Create a param from the given name and type.\"\"\"\n\t        return ast.Param(\n\t            name=str(name),\n\t            type_=type_,\n\t        )\n\t    def type(self, name):\n\t        \"\"\"Create a type from the given name.\"\"\"\n\t        return str(name)\n\t    def block(self, *statements):\n", "        \"\"\"Create a block from the given statements.\"\"\"\n\t        return statements or []\n\t    def group(self, expr) -> ast.Grouping:\n\t        \"\"\"Create a group from the given expression.\"\"\"\n\t        return ast.Grouping(expr=expr)\n\t    def function_call(self, name, args) -> ast.FunctionCall:\n\t        \"\"\"Create a function call from the given name and args.\"\"\"\n\t        return ast.FunctionCall(name=str(name), args=args or [])\n\t    def identifier(self, name) -> ast.Variable:\n\t        \"\"\"Create a variable reference from the given name.\"\"\"\n", "        return ast.Variable(\n\t            name=str(name),\n\t        )\n\t    def variable_assign(self, name, value) -> ast.Assign:\n\t        \"\"\"Create a variable assignment from the given name and value.\"\"\"\n\t        return ast.Assign(\n\t            name=str(name),\n\t            value=value,\n\t        )\n\t    def expr(self, item) -> ast.Expr:\n", "        \"\"\"Create an expression from the given item.\"\"\"\n\t        return item\n\t    def args(self, *items):\n\t        \"\"\"Create an argument list for a function from the given items.\"\"\"\n\t        return items or []\n\t    def list(self, items) -> ast.List_:\n\t        \"\"\"Create a list literal from the given items.\"\"\"\n\t        return ast.List_(\n\t            elements=items or [],\n\t        )\n", "    def true(self) -> ast.Literal:\n\t        \"\"\"Create a true literal.\"\"\"\n\t        return ast.Literal(value=True)\n\t    def false(self) -> ast.Literal:\n\t        \"\"\"Create a false literal.\"\"\"\n\t        return ast.Literal(value=False)\n\t    def null(self) -> ast.Literal:\n\t        \"\"\"Create a null literal.\"\"\"\n\t        return ast.Literal(value=None)\n\t    def number(self, item) -> ast.Literal:\n", "        try:\n\t            return ast.Literal(value=int(item))\n\t        except ValueError:\n\t            return ast.Literal(value=float(item))\n\t    def scientific(self, coefficient, exponent) -> ast.Literal:\n\t        return ast.Literal(value=coefficient * 10**exponent)\n\t    def string(self, item) -> ast.Literal:\n\t        return ast.Literal(\n\t            value=str(item[1:-1]),\n\t        )\n", "ast_parser = Lark(GRAMMAR, parser=\"lalr\", transformer=AstParser(), start=\"program\")\n\t# PUBLIC API\n\tdef parse(source: str) -> ast.Program:\n\t    \"\"\"Parse the given source code into an AST.\"\"\"\n\t    return cast(ast.Program, ast_parser.parse(source))\n"]}
{"filename": "kork/chain.py", "chunked_list": ["\"\"\"Implementation of a programming chain.\"\"\"\n\tfrom __future__ import annotations\n\tfrom typing import (\n\t    Any,\n\t    Callable,\n\t    Dict,\n\t    List,\n\t    Mapping,\n\t    Optional,\n\t    Sequence,\n", "    Tuple,\n\t    TypedDict,\n\t    Union,\n\t    cast,\n\t)\n\tfrom langchain import LLMChain\n\tfrom langchain.chains.base import Chain\n\tfrom langchain.prompts import PromptTemplate\n\ttry:\n\t    from langchain.base_language import BaseLanguageModel\n", "except ImportError:\n\t    from langchain.schema import BaseLanguageModel\n\tfrom pydantic import Extra\n\tfrom kork import ast\n\tfrom kork.ast_printer import AbstractAstPrinter, AstPrinter\n\tfrom kork.environment import Environment, create_environment\n\tfrom kork.examples import (\n\t    AbstractExampleRetriever,\n\t    InputFormatter,\n\t    SimpleExampleRetriever,\n", "    format_examples,\n\t    format_text,\n\t)\n\tfrom kork.exceptions import LLMParseException\n\tfrom kork.interpreter import InterpreterResult, run_interpreter\n\tfrom kork.prompt_adapter import FewShotTemplate\n\tfrom kork.retrieval import AbstractContextRetriever, FuncLike, SimpleContextRetriever\n\tfrom kork.utils import unwrap_tag\n\t_INSTRUCTION_PROMPT = \"\"\"\\\n\tYou are programming in a language called \"{language_name}\".\n", "You are an expert programmer and must follow the instructions below exactly.\n\tYour goal is to translate a user query into a corresponding and valid {language_name}\n\tprogram.\n\t{external_functions_block}\n\tDo not assume that any other functions except for the ones listed above exist.\n\tWrap the program in <code> and </code> tags.\n\tStore the solution to the query in a variable called \"result\".\n\tHere is a sample valid program:\n\t<code>\n\tvar x = 1 # Assign 1 to the variable x\n", "var result = 1 + 2 # Calculate the sum of 1 + 2 and assign to result\n\tvar result = x # Assign the value of x to result\n\t</code>\n\tGuidelines:\n\t- Do not use operators, instead invoke appropriate external functions.\n\t- Do not declare functions, do not use loops, do not use conditionals.\n\t- Solve the problem only using variable declarations and function invocations.\n\tBegin!\n\t\"\"\"\n\t# PUBLIC API\n", "DEFAULT_INSTRUCTION_PROMPT = PromptTemplate(\n\t    input_variables=[\n\t        \"language_name\",\n\t        \"external_functions_block\",\n\t    ],\n\t    template=_INSTRUCTION_PROMPT,\n\t)\n\tclass CodeResult(TypedDict):\n\t    \"\"\"Result of a code chain.\"\"\"\n\t    errors: Sequence[Exception]\n", "    raw: str\n\t    code: str\n\t    environment: Optional[Environment]  # Returned on success\n\t# PUBLIC API\n\tExampleTuple = Tuple[str, ast.Program]\n\tclass CodeChain(Chain):\n\t    \"\"\"A coding chain.\"\"\"\n\t    llm: BaseLanguageModel\n\t    \"\"\"The language model to use for the coding chain.\"\"\"\n\t    interpreter: Callable[[str, Environment], InterpreterResult]\n", "    \"\"\"The interpreter to use for the coding chain.\"\"\"\n\t    ast_printer: AbstractAstPrinter\n\t    \"\"\"The AST printer to use for the coding chain.\"\"\"\n\t    context_retriever: Optional[AbstractContextRetriever] = None\n\t    \"\"\"Context to inject into the environment and prompt.\n\t    At the moment, this context is limited to external functions.\n\t    \"\"\"\n\t    example_retriever: Optional[AbstractExampleRetriever] = None\n\t    \"\"\"Examples that should be added to the prompt.\"\"\"\n\t    instruction_template: PromptTemplate = DEFAULT_INSTRUCTION_PROMPT\n", "    \"\"\"Template for the instruction prompt.\"\"\"\n\t    input_key: str = \"query\"\n\t    # Smirking kat language\n\t    language_name: str = \"ðŸ˜¼\"\n\t    input_formatter: InputFormatter = \"triple_quotes\"\n\t    \"\"\"The smirking kat programming language; aka Kork; aka ðŸ˜¼\"\"\"\n\t    class Config:\n\t        \"\"\"Configuration for this pydantic object.\"\"\"\n\t        extra = Extra.allow\n\t        arbitrary_types_allowed = True\n", "    @property\n\t    def input_keys(self) -> List[str]:\n\t        \"\"\"Will be whatever keys the prompt expects.\n\t        :meta private:\n\t        \"\"\"\n\t        return [self.input_key]\n\t    @property\n\t    def output_keys(self) -> List[str]:\n\t        \"\"\"Output keys to return.\n\t        :meta private:\n", "        \"\"\"\n\t        return [\"raw\", \"errors\", \"code\", \"environment\"]\n\t    def prepare_context(\n\t        self, query: str, variables: Optional[Mapping[str, Any]] = None\n\t    ) -> Tuple[Environment, FewShotTemplate]:\n\t        \"\"\"Get the pre-populated environment and the few shot template.\n\t        Args:\n\t            query: The query to prepare the context for.\n\t            variables: Any variables that should be added to the context.\n\t        Returns:\n", "            The prepopulated environment and a pre-formatted few shot template.\n\t        \"\"\"\n\t        if self.context_retriever:\n\t            external_function_definitions = self.context_retriever.retrieve(query)\n\t        else:\n\t            external_function_definitions = []\n\t        environment = create_environment(external_function_definitions, variables)\n\t        if self.example_retriever:\n\t            formatted_examples = self.example_retriever.retrieve(query)\n\t        else:\n", "            formatted_examples = []\n\t        external_functions = \"\\n\".join(\n\t            [\n\t                self.ast_printer.visit(func_declaration)\n\t                for func_declaration in environment.list_external_functions()\n\t            ]\n\t        )\n\t        input_variables = self.instruction_template.input_variables\n\t        formatting_variables = {}\n\t        if \"language_name\" in input_variables:\n", "            formatting_variables[\"language_name\"] = self.language_name\n\t        if external_functions:\n\t            external_functions_block = (\n\t                \"You have access to the following external functions:\\n\\n\"\n\t                f\"```{self.language_name}\\n\"\n\t                f\"{external_functions}\\n\"\n\t                \"```\\n\"\n\t            )\n\t        else:\n\t            external_functions_block = \"Do not assume any functions exist.\\n\"\n", "        if \"external_functions_block\" in input_variables:\n\t            formatting_variables[\"external_functions_block\"] = external_functions_block\n\t        prompt = self.instruction_template.partial(\n\t            **formatting_variables,\n\t        )\n\t        return environment, FewShotTemplate(\n\t            instruction_template=prompt,\n\t            examples=formatted_examples,\n\t            input_variables=[\"query\"],\n\t        )\n", "    def _call(self, inputs: Dict[str, str]) -> CodeResult:  # type: ignore\n\t        \"\"\"Call the chain.\"\"\"\n\t        # Note not using original query!!\n\t        # We remove the leading and trailing whitespace from the query\n\t        # to make things a bit more robust.\n\t        query = inputs[self.input_key].strip()\n\t        variables: Mapping[str, Any] = cast(\n\t            Mapping[str, Any], inputs.get(\"variables\", {})\n\t        )\n\t        if not isinstance(variables, dict):\n", "            raise TypeError(\n\t                f\"Variables must be a dictionary, got {type(variables)} instead.\"\n\t            )\n\t        environment, few_shot_template = self.prepare_context(query, variables)\n\t        chain = LLMChain(\n\t            prompt=few_shot_template,\n\t            llm=self.llm,\n\t        )\n\t        formatted_query = format_text(query, self.input_formatter)\n\t        llm_output = cast(str, chain.predict_and_parse(query=formatted_query))\n", "        code = unwrap_tag(\"code\", llm_output)\n\t        if not code:\n\t            return {\n\t                \"errors\": [\n\t                    LLMParseException(\n\t                        \"Could not find code block. Please make sure the code \"\n\t                        \"is wrapped in a code block.\"\n\t                    )\n\t                ],\n\t                \"raw\": llm_output,\n", "                \"code\": \"\",\n\t                \"environment\": None,\n\t            }\n\t        interpreter_result = self.interpreter(code, environment)\n\t        if interpreter_result[\"errors\"]:\n\t            return {\n\t                \"errors\": interpreter_result[\"errors\"],\n\t                \"raw\": llm_output,\n\t                \"code\": code,\n\t                \"environment\": None,\n", "            }\n\t        return {\n\t            \"errors\": [],\n\t            \"raw\": llm_output,\n\t            \"code\": code,\n\t            \"environment\": interpreter_result[\"environment\"],\n\t        }\n\t    @property\n\t    def _chain_type(self) -> str:\n\t        \"\"\"Used for serialization.\"\"\"\n", "        return \"code_chain\"\n\t    @classmethod\n\t    def from_defaults(\n\t        cls,\n\t        *,\n\t        llm: BaseLanguageModel,\n\t        interpreter: Callable[[str, Environment], InterpreterResult] = run_interpreter,\n\t        ast_printer: AbstractAstPrinter = AstPrinter(),\n\t        context: Union[AbstractContextRetriever, Sequence[FuncLike], None] = None,\n\t        examples: Union[AbstractExampleRetriever, Sequence[ExampleTuple], None] = None,\n", "        instruction_template: PromptTemplate = DEFAULT_INSTRUCTION_PROMPT,\n\t        input_key: str = \"query\",\n\t        # Smirking kat language\n\t        language_name: str = \"ðŸ˜¼\",\n\t        input_formatter: InputFormatter = \"markdown_text\",\n\t    ) -> CodeChain:\n\t        \"\"\"Create a code chain from pre-configured defaults.\n\t        Args:\n\t            llm: The language model to use for coding\n\t            interpreter: The interpreter that will be used to execute the program\n", "            ast_printer: An ast printer that can print the AST as a text string\n\t            context: Either a list of functions or a context retriever.\n\t                               The list of functions can be a mixture of python\n\t                               callables and Kork external functions.\n\t                               All python functions will be converted into Kork\n\t                               external functions, and everything passed into\n\t                               the default context retriever.\n\t            examples: An example retriever or a list of examples.\n\t                       If a list of examples, a simple example retriever\n\t                       will be created.\n", "            instruction_template: Use to customize the instruction components of\n\t                                  the prompt.\n\t            language_name: The language name to use for the prompt.\n\t            input_formatter: A formatting that will be applied to the input part\n\t                             of each example tuple, if passing in a list of examples.\n\t            input_key: The input key to use.\n\t        Returns:\n\t            A code chain\n\t        \"\"\"\n\t        if isinstance(examples, (AbstractExampleRetriever, type(None))):\n", "            _example_retriever = examples\n\t        elif isinstance(examples, Sequence):\n\t            formatted_examples = format_examples(\n\t                language_name,\n\t                examples,\n\t                ast_printer,\n\t                input_formatter=input_formatter,\n\t            )\n\t            _example_retriever = SimpleExampleRetriever(examples=formatted_examples)\n\t        else:\n", "            raise TypeError(\n\t                f\"example_retriever must be of type `AbstractExampleRetriever` or \"\n\t                f\"`Sequence[ExampleTuple]`. Got {type(examples)} instead.\"\n\t            )\n\t        if isinstance(context, (AbstractContextRetriever, type(None))):\n\t            _context_retriever = context\n\t        elif isinstance(context, Sequence):\n\t            _context_retriever = SimpleContextRetriever.from_functions(context)\n\t        else:\n\t            raise TypeError(\n", "                f\"context_retriever must be of type `AbstractContextRetriever` or \"\n\t                f\"`Sequence[FunctionDefinition]`. Got {type(context)} \"\n\t                f\"instead.\"\n\t            )\n\t        return cls(\n\t            llm=llm,\n\t            interpreter=interpreter,\n\t            ast_printer=ast_printer,\n\t            context_retriever=_context_retriever,\n\t            example_retriever=_example_retriever,\n", "            instruction_template=instruction_template,\n\t            input_key=input_key,\n\t            language_name=language_name,\n\t            input_formatter=input_formatter,\n\t        )\n"]}
{"filename": "kork/__init__.py", "chunked_list": ["from kork import ast\n\tfrom kork.ast_printer import AstPrinter\n\tfrom kork.chain import CodeChain\n\tfrom kork.environment import Environment\n\tfrom kork.examples import (\n\t    AbstractExampleRetriever,\n\t    SimpleExampleRetriever,\n\t    c_,\n\t    format_examples,\n\t    r_,\n", ")\n\tfrom kork.exceptions import KorkException\n\tfrom kork.interpreter import InterpreterResult, run_interpreter\n\tfrom kork.retrieval import AbstractContextRetriever, SimpleContextRetriever\n\t__all__ = [\n\t    \"CodeChain\",\n\t    \"ast\",\n\t    \"AstPrinter\",\n\t    \"KorkException\",\n\t    \"InterpreterResult\",\n", "    \"run_interpreter\",\n\t    \"AbstractContextRetriever\",\n\t    \"SimpleContextRetriever\",\n\t    \"Environment\",\n\t    \"c_\",\n\t    \"r_\",\n\t    \"format_examples\",\n\t    \"AbstractExampleRetriever\",\n\t    \"SimpleExampleRetriever\",\n\t]\n"]}
{"filename": "kork/utils.py", "chunked_list": ["import re\n\tfrom typing import Optional\n\tdef wrap_in_tag(tag_name: str, content: str) -> str:\n\t    \"\"\"Wrap the content in an HTML style tag.\"\"\"\n\t    return f\"<{tag_name}>{content}</{tag_name}>\"\n\tdef unwrap_tag(tag_name: str, text: str) -> Optional[str]:\n\t    \"\"\"Extract content located inside a tag.\"\"\"\n\t    pattern = f\"<{tag_name}>(.*?)</{tag_name}>\"\n\t    content = re.compile(pattern, re.DOTALL)\n\t    match = content.search(text)\n", "    if match:\n\t        return match.group(1)\n\t    else:\n\t        return None\n\tdef unwrap_code(language_name: str, text: str) -> Optional[str]:\n\t    \"\"\"Extract code located inside a code tag.\"\"\"\n\t    pattern = f\"```{language_name}\\n(.*?)\\n```\"\n\t    content = re.compile(pattern, re.DOTALL)\n\t    match = content.search(text)\n\t    if match:\n", "        return match.group(1)\n\t    else:\n\t        return None\n"]}
{"filename": "kork/examples.py", "chunked_list": ["\"\"\"Interface to specify kork examples easily.\"\"\"\n\timport abc\n\tfrom typing import Any, Callable, List, Literal, Sequence, Tuple, Union\n\tfrom kork import ast\n\tfrom kork.ast_printer import AbstractAstPrinter\n\tfrom kork.foreign_funcs import to_kork_function_call\n\tfrom kork.utils import wrap_in_tag\n\tdef _add_result_variable(expr: ast.Expr) -> ast.Program:\n\t    \"\"\"Assembles a solution from a program.\"\"\"\n\t    stmt = ast.VarDecl(name=\"result\", value=expr)\n", "    return ast.Program(stmts=[stmt])\n\t# PUBLIC API\n\t# Use to denote different types of formatters for the input.\n\tInputFormatter = Union[\n\t    Literal[\"text_prefix\"],\n\t    Literal[\"triple_quotes\"],\n\t    Literal[\"markdown_text\"],\n\t    None,\n\t    Callable[[str], str],\n\t]\n", "def format_text(text: str, input_formatter: InputFormatter = None) -> str:\n\t    \"\"\"An encoder for the input text.\n\t    Args:\n\t        text: the text to encode\n\t        input_formatter: the formatter to use for the input\n\t            * None: use for single sentences or single paragraphs, no formatting\n\t            * triple_quotes: surround input with \\\"\\\"\\\", use for long text\n\t            * text_prefix: same as triple_quote but with `TEXT: ` prefix\n\t            * Callable: user provided function\n\t    Returns:\n", "        The encoded text if it was encoded\n\t    \"\"\"\n\t    if input_formatter == \"text_prefix\":\n\t        return 'Text: \"\"\"\\n' + text + '\\n\"\"\"'\n\t    elif input_formatter == \"triple_quotes\":\n\t        return '\"\"\"\\n' + text + '\\n\"\"\"'\n\t    elif input_formatter == \"markdown_text\":\n\t        return \"```text\\n\" + text + \"\\n```\"\n\t    elif input_formatter is None:\n\t        return text\n", "    else:\n\t        raise NotImplementedError(\n\t            f'No support for input encoding \"{input_formatter}\". '\n\t            ' Use one of \"long_text\" or None.'\n\t        )\n\t# Alias to create a kork function call\n\tdef c_(name: Callable, *args: Any) -> ast.FunctionCall:\n\t    \"\"\"Create a kork function call.\"\"\"\n\t    return to_kork_function_call(name, *args)\n\t# Alias to assign the expression to a variable called `result`\n", "def r_(expr: ast.Expr) -> ast.Program:\n\t    \"\"\"Assign last program expression to a result variable.\"\"\"\n\t    return _add_result_variable(expr)\n\tdef format_examples(\n\t    language_name: str,\n\t    examples: Sequence[Tuple[str, ast.Program]],\n\t    ast_printer: AbstractAstPrinter,\n\t    input_formatter: InputFormatter = None,\n\t) -> List[Tuple[str, str]]:\n\t    \"\"\"Format examples.\"\"\"\n", "    formatted_examples = []\n\t    for example_input, desired_output in examples:\n\t        formatted_input = format_text(example_input, input_formatter=input_formatter)\n\t        formatted_examples.append(\n\t            (\n\t                formatted_input,\n\t                wrap_in_tag(\"code\", ast_printer.visit(desired_output)),\n\t            )\n\t        )\n\t    return formatted_examples\n", "class AbstractExampleRetriever(abc.ABC):\n\t    \"\"\"Abstract interface for an example retriever.\n\t    An example interface must implement the `retrieve` method which\n\t    returns a list of relevant examples based on the given query.\n\t    \"\"\"\n\t    @abc.abstractmethod\n\t    def retrieve(self, query: str) -> List[Tuple[str, str]]:\n\t        \"\"\"Retrieve examples.\"\"\"\n\tclass SimpleExampleRetriever(AbstractExampleRetriever):\n\t    \"\"\"Simple example retriever.\n", "    Simple example that returns the examples it was initialized with.\n\t    Supports initialization from a list of programs.\n\t    Example:\n\t    .. code-block:: python\n\t        from kork import SimpleExampleRetriever, AstPrinter, c_, r_\n\t        simple_example_retriever = SimpleExampleRetriever.from_programs(\n\t            language_name=\"kork\",\n\t            examples=[\n\t                (\"add 1 2\", r_(c_(add, 1, 2))),\n\t                (\"add 1 2 3\", r_(c_(add, 1, 2, 3))),\n", "                ],\n\t            ast_printer=AstPrinter(),\n\t        )\n\t        examples = simple_example_retriever.retrieve(\"add 1 2\")\n\t    \"\"\"\n\t    def __init__(\n\t        self,\n\t        examples: Sequence[Tuple[str, str]],\n\t    ) -> None:\n\t        \"\"\"Initialize the retriever with a list of examples.\"\"\"\n", "        self._examples = examples\n\t    def retrieve(self, query: str) -> List[Tuple[str, str]]:\n\t        \"\"\"Retrieve examples that best match the given query.\"\"\"\n\t        return list(self._examples)\n\t    @classmethod\n\t    def from_programs(\n\t        cls,\n\t        language_name: str,\n\t        examples: Sequence[Tuple[str, ast.Program]],\n\t        ast_printer: AbstractAstPrinter,\n", "    ) -> \"SimpleExampleRetriever\":\n\t        \"\"\"Create a simple example retriever from programs.\n\t        Args:\n\t            language_name: The language name to use for the markdown code blocks.\n\t            examples: A sequence of tuples of the form (query, desired program).\n\t            ast_printer: The ast printer to use to format the desired output.\n\t        Returns:\n\t            A simple example retriever.\n\t        \"\"\"\n\t        return cls(\n", "            examples=format_examples(\n\t                language_name=language_name,\n\t                examples=examples,\n\t                ast_printer=ast_printer,\n\t            )\n\t        )\n"]}
{"filename": "kork/display.py", "chunked_list": ["\"\"\"Utils for displaying chain results in a notebook.\"\"\"\n\timport base64\n\timport math\n\tfrom html import escape\n\tfrom io import BytesIO\n\tfrom typing import Any, Optional, Sequence, TypedDict, Union\n\tfrom kork.ast_printer import AstPrinter\n\tfrom kork.chain import CodeResult\n\tfrom kork.parser import parse  # type: ignore\n\ttry:\n", "    from PIL.Image import Image\n\texcept ImportError:\n\t    Image = None\n\tdef image_base64(image: Image) -> str:\n\t    \"\"\"Get a base64 representation of an image.\"\"\"\n\t    with BytesIO() as buffer:\n\t        image.save(buffer, \"jpeg\")\n\t        return base64.b64encode(buffer.getvalue()).decode()\n\tdef as_img_tag(image: Image) -> str:\n\t    \"\"\"Get an HTML representation of an image.\"\"\"\n", "    return f'<img src=\"data:image/jpeg;base64,{image_base64(image)}\">'\n\tclass HtmlResult(TypedDict):\n\t    \"\"\"A result that can be displayed in a notebook.\"\"\"\n\t    query: str\n\t    errors: str\n\t    raw: str\n\t    code: str\n\t    result: str\n\t    expected: str\n\t    correct: str\n", "class _NoExpectedAnswer:\n\t    \"\"\"A sentinel class to indicate that there is no expected answer.\"\"\"\n\tNO_EXPECTED_ANSWER = _NoExpectedAnswer()\n\tdef as_html_dict(\n\t    code_result: CodeResult,\n\t    query: Optional[str] = None,\n\t    expected_answer: Optional[Any] = None,\n\t    result_key: str = \"result\",\n\t    pretty_print: bool = True,\n\t) -> HtmlResult:\n", "    \"\"\"Use to generate a dict that can be easily displayed in an IPython notebook.\"\"\"\n\t    from IPython import display as ipy_display\n\t    code = code_result[\"code\"].strip()\n\t    if pretty_print:\n\t        try:\n\t            code = AstPrinter().visit(parse(code), pretty_print=True)\n\t        except Exception:\n\t            # This is display code. Broad exception handling OK for now\n\t            # we can make the code more robust later.\n\t            code = code\n", "    else:\n\t        code = code\n\t    if code:\n\t        _code = ipy_display.Code(data=code)._repr_html_().strip().replace(\"\\n\", \"<br/>\")\n\t    else:\n\t        _code = code\n\t    env = code_result[\"environment\"]\n\t    result = env.variables.get(result_key, \"\") if env else \"\"\n\t    if expected_answer is NO_EXPECTED_ANSWER:\n\t        _correct = \"N/A\"\n", "    else:\n\t        if isinstance(expected_answer, (float, int)) and isinstance(\n\t            result, (float, int)\n\t        ):\n\t            correct = math.isclose(expected_answer, result)\n\t        else:\n\t            correct = bool(expected_answer == result)\n\t        _correct = \"âœ…\" if correct else \"â›”\"\n\t    query = query or code_result.get(\"query\", \"\")  # type: ignore\n\t    if Image and isinstance(result, Image):\n", "        _result = as_img_tag(result)\n\t    else:\n\t        _result = escape(str(result).strip())\n\t    _expected = (\n\t        \"\" if expected_answer is NO_EXPECTED_ANSWER else escape(str(expected_answer))\n\t    )\n\t    return {\n\t        \"query\": escape(str(query)),\n\t        \"errors\": escape(str(code_result[\"errors\"])),\n\t        \"raw\": escape(str(code_result[\"raw\"])).replace(\"\\n\", \"<br/>\"),\n", "        \"code\": _code,\n\t        \"result\": _result,\n\t        \"expected\": _expected,\n\t        \"correct\": _correct,\n\t    }\n\tdef display_html_results(\n\t    html_results: Union[Sequence[HtmlResult], HtmlResult],\n\t    columns: Optional[Sequence[str]] = None,\n\t) -> Any:\n\t    \"\"\"Display a sequence of HTML results as a table.\"\"\"\n", "    import pandas as pd\n\t    from IPython import display\n\t    _results = html_results if isinstance(html_results, list) else [html_results]\n\t    _columns = (\n\t        columns\n\t        if columns\n\t        else [\"query\", \"code\", \"result\", \"expected\", \"correct\", \"errors\", \"raw\"]\n\t    )\n\t    df = pd.DataFrame(_results, columns=_columns)\n\t    if \"query\" in df.columns:\n", "        df[\"query\"] = df[\"query\"].str.wrap(40)\n\t        df[\"query\"] = df[\"query\"].str.replace(\"\\n\", \"<br/>\")\n\t    df = df.style.set_properties(**{\"text-align\": \"left\"})\n\t    return display.HTML(df.to_html(escape=False, index=False))\n\tdef display_code_result(\n\t    code_result: CodeResult,\n\t    query: Optional[str] = None,\n\t    expected_answer: Optional[Any] = NO_EXPECTED_ANSWER,\n\t    columns: Optional[Sequence[str]] = None,\n\t    result_key: str = \"result\",\n", ") -> Any:\n\t    \"\"\"Display a code result as a table.\"\"\"\n\t    return display_html_results(\n\t        as_html_dict(\n\t            code_result,\n\t            query=query,\n\t            expected_answer=expected_answer,\n\t            result_key=result_key,\n\t        ),\n\t        columns=columns,\n", "    )\n"]}
{"filename": "kork/interpreter.py", "chunked_list": ["from typing import Any, Optional, Sequence, TypedDict, Union\n\tfrom lark.exceptions import LarkError\n\tfrom kork import ast\n\tfrom kork.environment import Environment\n\tfrom kork.exceptions import KorkRunTimeException\n\t# TODO: Determine why mypy is not recognizing the import.\n\tfrom kork.parser import parse  # type: ignore[attr-defined]\n\tclass Interpreter(ast.Visitor):\n\t    \"\"\"Kork's default interpreter.\"\"\"\n\t    def __init__(self, program: ast.Program, environment: Environment) -> None:\n", "        \"\"\"Initialize the interpreter.\"\"\"\n\t        self.program = program\n\t        self.environment = environment\n\t        self.last_expression_value: Any = None\n\t    def intepret(self) -> None:\n\t        \"\"\"Interpret the program.\"\"\"\n\t        self.program.accept(self)\n\t    def visit_program(self, program: ast.Program) -> None:\n\t        \"\"\"Visit a program.\"\"\"\n\t        for stmt in program.stmts:\n", "            stmt.accept(self)\n\t    def visit_extern_function_def(\n\t        self, extern_function_def: ast.ExternFunctionDef\n\t    ) -> None:\n\t        \"\"\"Visit an external function definition.\"\"\"\n\t        self.environment.variables[extern_function_def.name] = extern_function_def\n\t    def visit_function_call(self, call: ast.FunctionCall) -> Any:\n\t        \"\"\"Visit a function call.\"\"\"\n\t        function = self.environment.get_symbol(call.name)\n\t        args = [arg.accept(self) for arg in call.args]\n", "        if isinstance(function, ast.ExternFunctionDef):\n\t            if function.implementation is None:\n\t                raise KorkRunTimeException(\"External function has not been linked yet.\")\n\t            try:\n\t                return function.implementation(*args)\n\t            except Exception as e:\n\t                raise KorkRunTimeException(\n\t                    \"Encountered an exception while invoking an external function \"\n\t                    f\"`{call.name}` with arguments: `{args}`.\"\n\t                    f\"Details: {e}\"\n", "                )\n\t        elif isinstance(function, ast.FunctionDef):\n\t            raise KorkRunTimeException(\"Function definition is unimplemented.\")\n\t        else:\n\t            raise KorkRunTimeException(f\"Cannot call {call.name}.\")\n\t    def visit_function_def(self, function_def: ast.FunctionDef) -> None:\n\t        \"\"\"Visit a function definition.\"\"\"\n\t        self.environment.variables[function_def.name] = function_def\n\t    def visit_variable(self, variable: ast.Variable) -> Any:\n\t        \"\"\"Visit a variable.\"\"\"\n", "        return self.environment.get_symbol(variable.name)\n\t    def visit_var_decl(self, var_decl: ast.VarDecl) -> None:\n\t        \"\"\"Visit a variable declaration.\"\"\"\n\t        self.environment.variables[var_decl.name] = var_decl.value.accept(self)\n\t    def visit_unary(self, unary: ast.Unary) -> Any:\n\t        \"\"\"Visit a unary expression.\"\"\"\n\t        operator = unary.operator\n\t        right = unary.right.accept(self)\n\t        if operator == \"-\":\n\t            return -right\n", "        elif operator == \"+\":\n\t            return right\n\t        else:\n\t            raise ValueError(f\"Unknown operator {operator}.\")\n\t    def visit_binary(self, binary: ast.Binary) -> Any:\n\t        \"\"\"Visit a binary expression.\"\"\"\n\t        left = binary.left.accept(self)\n\t        right = binary.right.accept(self)\n\t        operator = binary.operator\n\t        if operator == \"+\":\n", "            return left + right\n\t        elif operator == \"-\":\n\t            return left - right\n\t        elif operator == \"*\":\n\t            return left * right\n\t        elif operator == \"/\":\n\t            return left / right\n\t        elif operator == \"**\":\n\t            return left**right\n\t        elif operator == \"%\":\n", "            return left % right\n\t        elif (\n\t            operator == \"^\"\n\t        ):  # Please note that we do not follow python convention here\n\t            return left**right  # Duplicating `**` operator\n\t        else:\n\t            raise ValueError(f\"Unknown operator {operator}.\")\n\t    def visit_grouping(self, grouping: ast.Grouping) -> Any:\n\t        \"\"\"Visit a grouping.\"\"\"\n\t        return grouping.expr.accept(self)\n", "    def visit_assign(self, assign: ast.Assign) -> None:\n\t        \"\"\"Visit an assignment.\"\"\"\n\t        self.environment.variables[assign.name] = assign.value.accept(self)\n\t    def visit_literal(self, literal: ast.Literal) -> Union[int, float, bool, str, None]:\n\t        \"\"\"Visit a number.\"\"\"\n\t        return literal.value\n\t    def visit_list_(self, list_: ast.List_) -> list:\n\t        \"\"\"Visit a list.\"\"\"\n\t        return [element.accept(self) for element in list_.elements]\n\t# PUBLIC API\n", "class InterpreterResult(TypedDict):\n\t    \"\"\"Use this to return the result of the interpreter.\"\"\"\n\t    environment: Environment\n\t    errors: Sequence[Exception]\n\tdef run_interpreter(\n\t    code: str, environment: Optional[Environment] = None\n\t) -> InterpreterResult:\n\t    \"\"\"Run the interpreter with the given code.\n\t    Args:\n\t        code: The code to run\n", "        environment: The environment to run the code in\n\t    Returns:\n\t        the final environment after running the code (this will likely change)\n\t    \"\"\"\n\t    # TODO(Eugene): May want to refactor to avoid cloning here without introducing\n\t    #                mutability associated bugs.\n\t    environment = (\n\t        environment.clone() if environment else Environment(parent=None, variables={})\n\t    )\n\t    try:\n", "        program = parse(code)\n\t        interpreter = Interpreter(program, environment)\n\t        interpreter.intepret()\n\t    except (\n\t        LarkError,\n\t        KorkRunTimeException,\n\t        ValueError,\n\t        ZeroDivisionError,\n\t        TypeError,\n\t    ) as e:\n", "        return InterpreterResult(\n\t            environment=environment,\n\t            errors=[e],\n\t        )\n\t    return InterpreterResult(\n\t        environment=interpreter.environment,\n\t        errors=[],\n\t    )\n"]}
{"filename": "kork/ast.py", "chunked_list": ["\"\"\"The AST for the language.\n\tThe AST is a bit messy right now in terms of what's a statement vs. an expression,\n\tand will likely need to be cleaned up a bit in the near future.\n\t\"\"\"\n\tfrom __future__ import annotations\n\timport abc\n\timport dataclasses\n\tfrom typing import Any, Callable, Optional, Sequence, TypeVar, Union\n\tT = TypeVar(\"T\")\n\tclass Visitor(abc.ABC):\n", "    \"\"\"Abstract visitor interface.\"\"\"\n\tdef _to_snake_case(name: str) -> str:\n\t    \"\"\"Convert a name into snake_case.\"\"\"\n\t    snake_case = \"\"\n\t    for i, char in enumerate(name):\n\t        if char.isupper() and i != 0:\n\t            snake_case += \"_\" + char.lower()\n\t        else:\n\t            snake_case += char.lower()\n\t    return snake_case\n", "@dataclasses.dataclass(frozen=True)\n\tclass Expr(abc.ABC):\n\t    \"\"\"Abstract expression.\"\"\"\n\t    def accept(self, visitor: Visitor, **kwargs: Any) -> Any:\n\t        \"\"\"Accept implementation for a visitor.\"\"\"\n\t        return getattr(visitor, f\"visit_{_to_snake_case(self.__class__.__name__)}\")(\n\t            self, **kwargs\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass Literal(Expr):\n", "    \"\"\"A literal expression.\"\"\"\n\t    value: Union[float, int, bool, None, str]\n\t@dataclasses.dataclass(frozen=True)\n\tclass Grouping(Expr):\n\t    \"\"\"A grouping expression.\"\"\"\n\t    expr: Expr\n\t@dataclasses.dataclass(frozen=True)\n\tclass Unary(Expr):\n\t    \"\"\"A unary expression.\"\"\"\n\t    operator: str\n", "    right: Expr\n\t@dataclasses.dataclass(frozen=True)\n\tclass Binary(Expr):\n\t    \"\"\"A binary expression.\"\"\"\n\t    left: Expr\n\t    operator: str\n\t    right: Expr\n\t@dataclasses.dataclass(frozen=True)\n\tclass Assign(Expr):\n\t    \"\"\"Assignment statement for a variable.\"\"\"\n", "    name: str\n\t    value: Expr\n\t@dataclasses.dataclass(frozen=True)\n\tclass Variable(Expr):\n\t    \"\"\"Variable reference.\"\"\"\n\t    name: str\n\t@dataclasses.dataclass(frozen=True)\n\tclass List_(Expr):\n\t    \"\"\"List literal.\"\"\"\n\t    elements: Sequence[Expr]\n", "@dataclasses.dataclass(frozen=True)\n\tclass Stmt(abc.ABC):\n\t    \"\"\"Abstract statement.\"\"\"\n\t    def accept(self, visitor: Visitor, **kwargs: Any) -> Any:\n\t        \"\"\"Accept implementation for a visitor.\"\"\"\n\t        return getattr(visitor, f\"visit_{_to_snake_case(self.__class__.__name__)}\")(\n\t            self, **kwargs\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass Param(Stmt):\n", "    \"\"\"Represent a function parameter.\"\"\"\n\t    name: str\n\t    type_: str\n\t@dataclasses.dataclass(frozen=True)\n\tclass ParamList(Stmt):\n\t    \"\"\"Represent a list of function parameters.\"\"\"\n\t    params: Sequence[Param]\n\t@dataclasses.dataclass(frozen=True)\n\tclass FunctionDef(Stmt):\n\t    \"\"\"Represent a function definition with an implementation.\"\"\"\n", "    name: str\n\t    params: ParamList\n\t    body: Sequence[Union[Stmt, Expr]]\n\t    # This is just an annotation so it's a string.\n\t    return_type: str\n\t@dataclasses.dataclass(frozen=True)\n\tclass ExternFunctionDef(Stmt):\n\t    \"\"\"External function definition.\"\"\"\n\t    name: str\n\t    params: ParamList\n", "    # This is just an annotation so it's a string.\n\t    return_type: str\n\t    implementation: Optional[Callable] = None\n\t    doc_string: str = \"\"\n\t    def add_implementation(self, implementation: Callable) -> \"ExternFunctionDef\":\n\t        \"\"\"Add an implementation to an external function definition.\"\"\"\n\t        if self.implementation is not None:\n\t            raise ValueError(\"Cannot add implementation to an already implemented func\")\n\t        return ExternFunctionDef(\n\t            name=self.name,\n", "            params=self.params,\n\t            return_type=self.return_type,\n\t            implementation=implementation,\n\t        )\n\t@dataclasses.dataclass(frozen=True)\n\tclass FunctionCall(Expr):\n\t    \"\"\"Represent a function call.\"\"\"\n\t    name: str  # Name of function being invoked\n\t    args: Sequence[Expr]  # Arguments to the function call\n\t@dataclasses.dataclass(frozen=True)\n", "class VarDecl(Stmt):\n\t    \"\"\"Represent a variable declaration.\"\"\"\n\t    name: str  # Name of variable\n\t    value: Expr  # Expression to assign to the variable\n\t@dataclasses.dataclass(frozen=True)\n\tclass Program(Stmt):\n\t    \"\"\"Represent a program.\"\"\"\n\t    stmts: Sequence[Union[Stmt, Expr]]\n"]}
{"filename": "kork/prompt_adapter.py", "chunked_list": ["\"\"\"A prompt adapter to allow working with both regular LLMs and Chat LLMs.\n\tThe prompt adapter supports breaking the prompt into:\n\t1) Instruction Section\n\t2) (Optional) Example Section\n\t\"\"\"\n\tfrom typing import Any, Callable, List, Sequence, Tuple\n\tfrom langchain import BasePromptTemplate, PromptTemplate\n\tfrom langchain.schema import BaseMessage, HumanMessage, PromptValue, SystemMessage\n\tfrom pydantic import Extra\n\tclass FewShotPromptValue(PromptValue):\n", "    \"\"\"Integration with langchain prompt format.\"\"\"\n\t    string: Callable[[], str]\n\t    messages: Callable[[], List[BaseMessage]]\n\t    class Config:\n\t        \"\"\"Configuration for this pydantic object.\"\"\"\n\t        extra = Extra.forbid\n\t        arbitrary_types_allowed = True\n\t    def to_string(self) -> str:\n\t        \"\"\"Format the prompt to a string.\"\"\"\n\t        return self.string()\n", "    def to_messages(self) -> List[BaseMessage]:\n\t        \"\"\"Get materialized messages.\"\"\"\n\t        return self.messages()\n\tclass FewShotTemplate(BasePromptTemplate):\n\t    \"\"\"Code prompt template.\"\"\"\n\t    instruction_template: PromptTemplate\n\t    examples: Sequence[Tuple[str, str]] = ()\n\t    @property\n\t    def _prompt_type(self) -> str:\n\t        \"\"\"Get the prompt type.\"\"\"\n", "        return \"FewShotTemplate\"\n\t    def format_prompt(self, **kwargs: Any) -> PromptValue:\n\t        \"\"\"Format the prompt.\"\"\"\n\t        if len(self.input_variables) != 1:\n\t            raise AssertionError(\n\t                f\"Expected 1 input variable, got {len(self.input_variables)}\"\n\t            )\n\t        query_key = self.input_variables[0]\n\t        query = kwargs[query_key]\n\t        def _lazy_string() -> str:\n", "            \"\"\"Lazy string.\"\"\"\n\t            return self.to_string(query)\n\t        def _lazy_messages() -> List[BaseMessage]:\n\t            \"\"\"Lazy messages.\"\"\"\n\t            return self.to_messages(query)\n\t        return FewShotPromptValue(\n\t            string=_lazy_string,\n\t            messages=_lazy_messages,\n\t        )\n\t    def format(self, **kwargs: Any) -> str:\n", "        \"\"\"Deprecated format method.\"\"\"\n\t        raise NotImplementedError()\n\t    def to_string(self, query: str) -> str:\n\t        \"\"\"Format the prompt to a string.\"\"\"\n\t        instruction_section = self.instruction_template.format()\n\t        examples_block = \"\"\n\t        for input_example, output_example in self.examples:\n\t            examples_block += f\"Input: {input_example}\\n\\nOutput: {output_example}\\n\\n\"\n\t        return instruction_section + examples_block + f\"Input: {query}\\n\\nOutput:\"\n\t    def to_messages(self, query: str) -> List[BaseMessage]:\n", "        \"\"\"Get materialized messages.\"\"\"\n\t        instruction_segment = self.instruction_template.format().strip()\n\t        messages: List[BaseMessage] = [SystemMessage(content=instruction_segment)]\n\t        for input_example, output_example in self.examples:\n\t            messages.append(HumanMessage(content=input_example.strip()))\n\t            messages.append(SystemMessage(content=output_example.strip()))\n\t        messages.append(HumanMessage(content=query.strip()))\n\t        return messages\n"]}
{"filename": "kork/foreign_funcs.py", "chunked_list": ["\"\"\"API to import foreign functions.\"\"\"\n\timport inspect\n\timport sys\n\timport types\n\timport typing\n\tfrom typing import Any, Callable, List, Mapping, Tuple, TypedDict\n\tfrom kork import ast\n\tPY_VERSION = (sys.version_info.major, sys.version_info.minor)\n\tclass FunctionInfo(TypedDict):\n\t    \"\"\"Information about a function.\"\"\"\n", "    name: str\n\t    args: List[Tuple[str, Any, Any]]\n\t    return_type: Any\n\t    docstring: str\n\tdef _type_repr(obj: Any) -> str:\n\t    \"\"\"Return the repr() of an object, special-casing types (internal helper).\n\t    If obj is a type, we return a shorter version than the default\n\t    type.__repr__, based on the module and qualified name, which is\n\t    typically enough to uniquely identify a type.  For everything\n\t    else, we fall back on repr(obj).\n", "    \"\"\"\n\t    if PY_VERSION >= (3, 9):\n\t        # Ignoring type for passing mypy testing with Python 3.8\n\t        if isinstance(obj, types.GenericAlias):  # type: ignore[attr-defined]\n\t            return repr(obj)\n\t    if isinstance(obj, type):\n\t        if obj.__module__ == \"builtins\":\n\t            return obj.__qualname__\n\t        return f\"{obj.__module__}.{obj.__qualname__}\"\n\t    if obj is ...:\n", "        return \"...\"\n\t    if isinstance(obj, types.FunctionType):\n\t        return obj.__name__\n\t    return repr(obj)\n\tdef _type_repr_wrapper(obj: Any) -> str:\n\t    \"\"\"A hack to remove all references to `typing.` in type strings.\n\t    There's likely a much better solution, but this will do for prototyping.\n\t    Args:\n\t        obj (Any): The object to get the type string of.\n\t    Returns:\n", "        str: The type string of the object.\n\t    \"\"\"\n\t    return _type_repr(obj).replace(\"typing.\", \"\")\n\tdef _get_stringified_type(type_hints: Mapping[str, Any], arg_name: str) -> str:\n\t    \"\"\"Get string version of an argument type from a mapping of type hints.\n\t    Args:\n\t        type_hints (Mapping[str, Any]): Mapping of argument names to types.\n\t        arg_name (str): Name of the argument or `return` for the return type.\n\t    Returns:\n\t        str: String representation of the type if it exists, otherwise Any.\n", "    \"\"\"\n\t    if arg_name in type_hints:\n\t        return _type_repr_wrapper(type_hints[arg_name])\n\t    else:\n\t        return \"Any\"\n\tdef _get_function_info(func: Callable) -> FunctionInfo:\n\t    \"\"\"Extract information about a function.\n\t    Args:\n\t        func (callable): The function to get information about.\n\t    Returns:\n", "        A dictionary with the following keys:\n\t            - name: The name of the function.\n\t            - args: A list of tuples containing the name and type of each argument.\n\t            - return_type: The type of the value returned by the function.\n\t            - docstring: The docstring of the function.\n\t    \"\"\"\n\t    # Get the name of the function\n\t    name = func.__name__\n\t    try:\n\t        # Get information about the function's arguments\n", "        type_hints = typing.get_type_hints(func)\n\t    except ValueError:\n\t        type_hints = {}\n\t    try:\n\t        signature = inspect.signature(func)\n\t        args = []\n\t        for arg_name, param in signature.parameters.items():\n\t            arg_type = _get_stringified_type(type_hints, arg_name)\n\t            arg_default = (\n\t                param.default if param.default != inspect.Parameter.empty else None\n", "            )\n\t            args.append((arg_name, arg_type, arg_default))\n\t        # Get the return type of the function\n\t        return_type = _get_stringified_type(type_hints, \"return\")\n\t    except ValueError:  # TODO: Exception is too broad, limit to correct scope\n\t        return_type = \"Any\"\n\t        args = []\n\t    # Get the docstring of the function\n\t    docstring = func.__doc__\n\t    # Construct and return a dictionary with the function information\n", "    return {\n\t        \"name\": name,\n\t        \"args\": args,\n\t        \"return_type\": return_type,\n\t        \"docstring\": docstring.strip() if docstring else \"\",\n\t    }\n\tdef _convert_to_kork_expr(value: Any) -> ast.Expr:\n\t    \"\"\"Convert mixed-expression value to a kork expression.\n\t    This function converts a potentially mixed python, kork expression\n\t    into a pure kork expression.\n", "    Args:\n\t        value (Any): The value to convert.\n\t    Returns:\n\t        An `kork` expression.\n\t    \"\"\"\n\t    if isinstance(value, ast.Expr):\n\t        # If it's already a kork expression, return as is\n\t        return value\n\t    elif isinstance(value, (int, float, bool, type(None), str)):\n\t        return ast.Literal(value=value)\n", "    elif isinstance(value, (list, tuple)):\n\t        return ast.List_(elements=[_convert_to_kork_expr(v) for v in value])\n\t    else:\n\t        raise ValueError(f\"Cannot convert {value} to an `kork` expression.\")\n\t# PUBLIC API\n\tdef to_extern_func_def(func: Callable) -> ast.ExternFunctionDef:\n\t    \"\"\"Convert a python function to a kork external function definition.\"\"\"\n\t    func_info = _get_function_info(func)\n\t    params = [\n\t        ast.Param(name=arg_name, type_=arg_type)\n", "        for arg_name, arg_type, _ in func_info[\"args\"]\n\t    ]\n\t    return ast.ExternFunctionDef(\n\t        name=func_info[\"name\"],\n\t        params=ast.ParamList(params=params),\n\t        return_type=func_info[\"return_type\"],\n\t        implementation=func,\n\t        doc_string=func_info[\"docstring\"],\n\t    )\n\tdef to_kork_function_call(func: Callable, *args: Any) -> ast.FunctionCall:\n", "    \"\"\"Convert a python function call to a kork function call.\"\"\"\n\t    return ast.FunctionCall(\n\t        name=func.__name__,\n\t        args=[_convert_to_kork_expr(arg) for arg in args],\n\t    )\n"]}
{"filename": "kork/retrieval.py", "chunked_list": ["\"\"\"Logic that attempts to surface the most relevant information for writing code.\"\"\"\n\tfrom __future__ import annotations\n\timport abc\n\timport dataclasses\n\tfrom typing import Callable, Sequence, Union\n\tfrom kork import ast\n\tfrom kork.foreign_funcs import to_extern_func_def\n\t@dataclasses.dataclass(frozen=True)\n\tclass AbstractContextRetriever(abc.ABC):\n\t    \"\"\"Abstract interface for retrieving programming context.\"\"\"\n", "    @abc.abstractmethod\n\t    def retrieve(self, query: str) -> Sequence[ast.ExternFunctionDef]:\n\t        \"\"\"Retrieve the external function definitions.\"\"\"\n\tFuncLike = Union[ast.ExternFunctionDef, Callable]\n\t@dataclasses.dataclass(frozen=True)\n\tclass SimpleContextRetriever(AbstractContextRetriever):\n\t    \"\"\"Retrieve information as was provided without any filtering or re-ranking.\"\"\"\n\t    external_functions: Sequence[ast.ExternFunctionDef] = tuple()\n\t    def __post_init__(self) -> None:\n\t        \"\"\"Validate the external functions.\"\"\"\n", "        for func in self.external_functions:\n\t            if not isinstance(func, ast.ExternFunctionDef):\n\t                raise ValueError(\n\t                    \"SimpleRetriever only accepts ExternFunctionDef objects in \"\n\t                    f\"the external_functions list. Got: {func}\"\n\t                )\n\t    def retrieve(self, query: str) -> Sequence[ast.ExternFunctionDef]:\n\t        \"\"\"Retrieve the external function definitions.\"\"\"\n\t        return self.external_functions\n\t    @classmethod\n", "    def from_functions(cls, mixed_funcs: Sequence[FuncLike]) -> SimpleContextRetriever:\n\t        \"\"\"Create a simple retrieval from a sequence of functions.\n\t        Args:\n\t            mixed_funcs: A sequence of functions or external function definitions.\n\t        Returns:\n\t            A simple retriever.\n\t        \"\"\"\n\t        external_functions = []\n\t        for func in mixed_funcs:\n\t            if isinstance(func, ast.ExternFunctionDef):\n", "                external_functions.append(func)\n\t            else:\n\t                external_functions.append(to_extern_func_def(func))\n\t        return cls(external_functions=external_functions)\n"]}
{"filename": "kork/exceptions.py", "chunked_list": ["\"\"\"Definitions for custom Kork exceptions.\"\"\"\n\tclass KorkException(Exception):\n\t    \"\"\"Generic Kork exception.\"\"\"\n\tclass LLMParseException(KorkException):\n\t    \"\"\"Failed to parse LLM output.\"\"\"\n\tclass KorkSyntaxException(KorkException):\n\t    \"\"\"Exceptions raised during syntax parsing.\"\"\"\n\tclass KorkInterpreterException(KorkException):\n\t    \"\"\"Exceptions raised during interpretation.\"\"\"\n\tclass KorkRunTimeException(KorkInterpreterException):\n", "    \"\"\"An exception that is raised during Kork interpreter runtime.\"\"\"\n"]}
{"filename": "docs/source/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t#\n\t# This file only contains a selection of the most common options. For a full\n\t# list see the documentation:\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\t# -- Path setup --------------------------------------------------------------\n\t# If extensions (or modules to document with autodoc) are in another directory,\n\t# add these directories to sys.path here. If the directory is relative to the\n\t# documentation root, use os.path.abspath to make it absolute, like shown here.\n\t#\n", "# import os\n\t# import sys\n\t# sys.path.insert(0, os.path.abspath('.'))\n\t# -- Project information -----------------------------------------------------\n\timport pathlib\n\timport sys\n\tfrom typing import List\n\timport toml\n\tROOT_FOLDER = str(pathlib.Path(__file__).parent.parent.parent)\n\t# Add the project root to the path\n", "sys.path.insert(0, ROOT_FOLDER)\n\twith open(\"../../pyproject.toml\") as f:\n\t    data = toml.load(f)\n\tproject = \"Kork\"\n\tcopyright = \"2023, Langchain AI\"\n\tauthor = \"Langchain AI\"\n\tversion = data[\"tool\"][\"poetry\"][\"version\"]\n\trelease = version\n\thtml_title = project + \" \" + version\n\t# -- General configuration ---------------------------------------------------\n", "# Add any Sphinx extension module names here, as strings. They can be\n\t# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n\t# ones.\n\textensions = [\n\t    \"sphinx.ext.autodoc\",\n\t    \"sphinx.ext.autodoc.typehints\",\n\t    \"sphinx.ext.autosummary\",\n\t    \"sphinx.ext.napoleon\",\n\t    \"sphinx.ext.viewcode\",\n\t    \"myst_nb\",\n", "    \"sphinx_copybutton\",\n\t    \"IPython.sphinxext.ipython_console_highlighting\",\n\t]\n\tsource_suffix = [\".ipynb\", \".html\", \".md\", \".rst\"]\n\t# Add any paths that contain templates here, relative to this directory.\n\ttemplates_path = [\"_templates\"]\n\t# List of patterns, relative to source directory, that match files and\n\t# directories to ignore when looking for source files.\n\t# This pattern also affects html_static_path and html_extra_path.\n\texclude_patterns: List[str] = []\n", "# -- Options for HTML output -------------------------------------------------\n\t# The theme to use for HTML and HTML Help pages.  See the documentation for\n\t# a list of builtin themes.\n\t#\n\thtml_theme = \"sphinx_book_theme\"\n\thtml_theme_options = {\n\t    \"path_to_docs\": \"docs\",\n\t    \"repository_url\": \"https://github.com/langchain-ai/kork\",\n\t    \"home_page_in_toc\": True,\n\t    \"show_navbar_depth\": 2,\n", "    \"use_sidenotes\": True,\n\t    \"use_repository_button\": True,\n\t}\n\thtml_context = {\n\t    \"display_github\": True,  # Integrate GitHub\n\t    \"github_user\": \"langchain-ai\",  # Username\n\t    \"github_repo\": \"kork\",  # Repo name\n\t    \"github_version\": \"main\",  # Version\n\t    \"conf_py_path\": \"/docs/\",  # Path in the checkout to the docs root\n\t}\n", "# Add any paths that contain custom static files (such as style sheets) here,\n\t# relative to this directory. They are copied after the builtin static files,\n\t# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n\thtml_static_path = [\"_static\"]\n\t# These paths are either relative to html_static_path\n\t# or fully qualified paths (eg. https://...)\n\thtml_css_files = [\n\t    \"css/custom.css\",\n\t]\n\thtml_logo = \"_static/parrot.png\"\n", "nb_execution_mode = \"off\"\n\tautosummary_generate = True\n"]}
