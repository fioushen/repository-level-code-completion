{"filename": "setup.py", "chunked_list": ["from setuptools import setup, find_packages\n\twith open(\"README.md\", \"r\") as fh:\n\t    long_description = fh.read()\n\tsetup(\n\t    name=\"citrusdb\",\n\t    version=\"0.5.1\",\n\t    author=\"Debabrata Mondal\",\n\t    author_email=\"debabrata.js@protonmail.com\",\n\t    description=\"(distributed) vector database\",\n\t    long_description=long_description,\n", "    long_description_content_type=\"text/markdown\",\n\t    url=\"https://github.com/0xDebabrata/citrus\",\n\t    packages=(\n\t        find_packages(\n\t            exclude=[\"demo\"]\n\t        ) +\n\t        [\"citrusdb.db.index\", \"citrusdb.db.sqlite\", \"citrusdb.db.postgres\"]\n\t    ),\n\t    include_package_data=True,\n\t    install_requires=[\n", "        \"numpy\",\n\t        \"hnswlib\",\n\t        \"openai\",\n\t        \"psycopg[c]\",\n\t        \"psycopg[pool]\"\n\t    ],\n\t    classifiers=[\n\t        \"Programming Language :: Python :: 3\",\n\t        \"License :: OSI Approved :: Apache Software License\",\n\t        \"Operating System :: OS Independent\",\n", "    ],\n\t    python_requires='>=3.7',\n\t)\n"]}
{"filename": "citrusdb/__init__.py", "chunked_list": ["from typing import Any, Dict, Optional\n\tdef Client(\n\t    persist_directory: Optional[str] = None,\n\t    database_type: Optional[str] = \"sqlite\",\n\t    **kwargs\n\t):\n\t    from citrusdb.api.local import LocalAPI\n\t    return LocalAPI(persist_directory, database_type=database_type, **kwargs)\n"]}
{"filename": "citrusdb/test/recall.py", "chunked_list": ["import hnswlib\n\timport citrusdb\n\timport numpy as np\n\tnum_vectors = 10000\n\tdim = 1536\n\tk = 50\n\tdata = np.random.rand(num_vectors, dim).astype(np.float32)\n\tcitrus_client = citrusdb.Client()\n\tcitrus_client.create_index(\n\t    max_elements=num_vectors,\n", "    M=128,\n\t    ef_construction=400\n\t)\n\tcitrus_client.set_ef(400)\n\tbf_index = hnswlib.BFIndex(space='cosine', dim=dim)\n\tbf_index.init_index(max_elements=num_vectors)\n\tcitrus_client.add(\n\t    ids=[i for i in range(0, num_vectors)],\n\t    embedding=data\n\t)\n", "bf_index.add_items(data)\n\tquery_embedding = np.random.rand(10, dim).astype(np.float32)\n\tresults_citrus, distances_citrus = citrus_client.query(query_embeddings=query_embedding, k=k)\n\tresults_bf, distances_bf = bf_index.knn_query(query_embedding, k=k)\n\t# Measure recall\n\tcorrect = 0\n\tfor i in range(10):\n\t    for label in results_citrus[i]:\n\t        for correct_label in results_bf[i]:\n\t            if label == correct_label:\n", "                correct += 1\n\t                break\n\tprint(\"recall is :\", float(correct)/(k * 10))\n"]}
{"filename": "citrusdb/utils/types.py", "chunked_list": ["from numpy import float32\n\tfrom numpy._typing import NDArray\n\tfrom typing import List, Optional, TypedDict\n\tID = str\n\tIDs = List[ID]\n\tclass Document(TypedDict):\n\t    id: int\n\t    text: Optional[str]\n\t    embedding: Optional[NDArray[float32]]\n"]}
{"filename": "citrusdb/utils/__init__.py", "chunked_list": []}
{"filename": "citrusdb/utils/utils.py", "chunked_list": ["import os\n\tfrom typing import Dict, Optional, Tuple\n\tdef convert_row_to_dict(row: Tuple, include: Dict):\n\t    returning_dict = {\"id\": row[1]}\n\t    if include[\"document\"]:\n\t        returning_dict[\"document\"] = row[2]\n\t        if include[\"metadata\"]:\n\t            returning_dict[\"metadata\"] = row[3]\n\t    elif include[\"metadata\"]:\n\t        returning_dict[\"metadata\"] = row[2]\n", "    return returning_dict\n\tdef ensure_valid_path(persist_directory: str, file_name: Optional[str] = None) -> bool:\n\t    \"\"\"\n\t    Creates required directories if they do not exist.\n\t    If only persist_directory is passed, returns True.\n\t    When file_name is passed, function returns boolean based on whether the\n\t    file can be found in given path.\n\t    \"\"\"\n\t    # Ensure directory exists\n\t    if not (os.path.isdir(persist_directory)):\n", "        os.makedirs(persist_directory)\n\t    if file_name is None:\n\t        return True\n\t    if os.path.exists(\n\t        os.path.join(persist_directory, file_name)\n\t    ):\n\t        return True\n\t    else:\n\t        return False\n"]}
{"filename": "citrusdb/db/__init__.py", "chunked_list": ["from abc import ABC, abstractmethod\n\tfrom typing import Any, Dict, List, Tuple, Optional\n\tfrom citrusdb.utils.types import IDs\n\tclass BaseDB(ABC):\n\t    @abstractmethod\n\t    def create_index(\n\t        self,\n\t        name: str,\n\t        max_elements: int,\n\t        M: int,\n", "        ef_construction: int,\n\t        allow_replace_deleted: bool,\n\t        dimensions: Optional[int] = 1536,\n\t    ):\n\t        pass\n\t    @abstractmethod\n\t    def delete_vectors_from_index(\n\t        self,\n\t        index_id: int,\n\t        ids: IDs\n", "    ) -> List[int]:\n\t        pass\n\t    @abstractmethod\n\t    def filter_vectors(self, index_name: str, filters: List[Dict]) -> List:\n\t        pass\n\t    @abstractmethod\n\t    def get_indices(self) -> List[Any]:\n\t        pass\n\t    @abstractmethod\n\t    def get_index_details(\n", "        self,\n\t        name: str\n\t    ) -> Optional[Tuple[int, str, int, int, int, int, int, bool]]:\n\t        pass\n\t    @abstractmethod\n\t    def get_vector_ids_of_results(\n\t        self,\n\t        name: str,\n\t        results: List[List[int]],\n\t        include: Dict\n", "    ) -> List[List[Dict]]:\n\t        pass\n\t    @abstractmethod\n\t    def insert_to_index(\n\t        self,\n\t        data\n\t    ) -> List[int]:\n\t        pass\n\t    @abstractmethod\n\t    def update_ef(\n", "        self,\n\t        name: str,\n\t        ef: int\n\t    ):\n\t        pass\n"]}
{"filename": "citrusdb/db/index/__init__.py", "chunked_list": []}
{"filename": "citrusdb/db/index/hnswlib.py", "chunked_list": ["import hnswlib\n\tclass HnswIndex:\n\t    _id: str\n\t    _index: hnswlib.Index\n\t    def __init__(self, id, space=\"cosine\", dim=1536):\n\t        self._id = id\n\t        self._index = hnswlib.Index(space=space, dim=dim)\n\t    def init_index(\n\t        self, max_elements=1000, M=64, ef_construction=200, allow_replace_deleted=False\n\t    ):\n", "        self._index.init_index(max_elements, M, ef_construction, allow_replace_deleted)\n\t    def add_items(self, data, ids, replace_deleted=False):\n\t        max_elements = self._index.max_elements\n\t        curr_elements = self._index.element_count\n\t        # Increase index size\n\t        if curr_elements + len(data) > max_elements:\n\t            new_size = max(curr_elements + len(data), 2 * max_elements)\n\t            self._index.resize_index(new_size)\n\t        self._index.add_items(data, ids, replace_deleted)\n\t    def knn_query(self, query_embeddings, k=1, filter_function=None):\n", "        labels, distances = self._index.knn_query(query_embeddings, k, filter=filter_function)\n\t        return labels, distances\n\t    def set_ef(self, ef: int):\n\t        self._index.set_ef(ef)\n\t    def get_dimension(self):\n\t        return self._index.dim\n\t    def load_index(self, path: str, allow_replace_deleted=False):\n\t        self._index.load_index(path, allow_replace_deleted=allow_replace_deleted)\n\t    def mark_deleted(self, label: int):\n\t        self._index.mark_deleted(label)\n", "    def save_index(self, path: str):\n\t        self._index.save_index(path)\n\t    def get_status(self):\n\t        print(\"Max elements\", self._index.max_elements)\n\t        print(\"Current elements\", self._index.element_count)\n"]}
{"filename": "citrusdb/db/postgres/query_builder.py", "chunked_list": ["from psycopg import Connection, sql\n\tfrom typing import Dict, List\n\tclass QueryBuilder:\n\t    _con: Connection\n\t    def __init__(self, connection):\n\t        self._con = connection\n\t    def build_query(self, filters):\n\t        # Building the base SQL query\n\t        sql_query = f\"SELECT d.vector_id, d.id, d.index_id, d.text FROM index_data d JOIN index_manager m ON m.index_id = d.index_id WHERE m.name = %s\"\n\t        # Adding the filter criteria to the SQL query\n", "        if filters:\n\t            sql_query += \" AND \"\n\t            conditions = []\n\t            for filter in filters:\n\t                field = filter[\"field\"]\n\t                operator = filter[\"operator\"]\n\t                value = filter[\"value\"]\n\t                # ->> returns text in postgres\n\t                #if isinstance(value, int) or isinstance(value, float):\n\t                #    condition = f\"metadata ->> '{field}' {operator} '{value}'\"\n", "                #else:\n\t                #    condition = f\"metadata ->> '{field}' {operator} '{value}'\"\n\t                condition = f\"metadata ->> '{field}' {operator} '{value}'\"\n\t                conditions.append(condition)\n\t            sql_query += \" AND \".join(conditions)\n\t        return sql.SQL(sql_query)\n\t    def execute_query(self, index_name: str, filters: List[Dict]):\n\t        with self._con.cursor() as cur:\n\t            # Building and executing the query\n\t            sql_query = self.build_query(filters)\n", "            parameters = (index_name,)\n\t            cur.execute(sql_query, parameters)\n\t            return cur.fetchall()\n"]}
{"filename": "citrusdb/db/postgres/db.py", "chunked_list": ["from psycopg_pool import ConnectionPool\n\tfrom psycopg import sql\n\tfrom typing import Any, Dict, List, Optional, Tuple\n\tfrom citrusdb.db import BaseDB\n\timport citrusdb.db.postgres.queries as queries\n\tfrom citrusdb.db.postgres.query_builder import QueryBuilder\n\tfrom citrusdb.utils.types import IDs\n\tfrom citrusdb.utils.utils import convert_row_to_dict\n\tclass PostgresDB(BaseDB):\n\t    _pool: ConnectionPool\n", "    def __init__(\n\t        self,\n\t        **kwargs: Dict[str, Any]\n\t    ):\n\t        # Setup connection pool\n\t        self._pool = ConnectionPool(kwargs=kwargs)\n\t        # Create index_manager and index_data table if they don't exist already\n\t        with self._pool.connection() as conn:\n\t            with conn.cursor() as cur:\n\t                cur.execute(queries.CREATE_INDEX_MANAGER_TABLE)\n", "                cur.execute(queries.CREATE_INDEX_DATA_TABLE)\n\t                conn.commit()\n\t    def create_index(\n\t        self,\n\t        name: str,\n\t        max_elements: int,\n\t        M: int,\n\t        ef_construction: int,\n\t        allow_replace_deleted: bool,\n\t        dimensions: Optional[int] = 1536,\n", "    ):\n\t        ef = ef_construction\n\t        parameters = (name, dimensions, max_elements, M, ef, ef_construction, allow_replace_deleted)\n\t        # Create new index entry to postgres db\n\t        with self._pool.connection() as conn:\n\t            with conn.cursor() as cur:\n\t                cur.execute(queries.INSERT_INDEX_TO_MANAGER, parameters)\n\t                conn.commit()\n\t    def delete_vectors_from_index(\n\t        self,\n", "        index_id: int,\n\t        ids: IDs\n\t    ):\n\t        \"\"\"\n\t        Delete vectors with given list of IDs from specific index\n\t        index_id: ID of index where the elements belong\n\t        ids: List of IDs to be deleted\n\t        \"\"\"\n\t        vector_ids = []\n\t        parameters = [ids, index_id]\n", "        with self._pool.connection() as conn:\n\t            with conn.cursor() as cur:\n\t                for vector_id in cur.execute(queries.DELETE_VECTORS_FROM_INDEX, parameters):\n\t                    vector_ids.append(vector_id[0])\n\t                conn.commit()\n\t        return vector_ids\n\t    def filter_vectors(self, index_name: str, filters: List[Dict]):\n\t        \"\"\"\n\t        Get list of IDs of vectors that match filters.\n\t        index_name: Name of index where the elements belong\n", "        filters: List of filters to be applied\n\t        \"\"\"\n\t        with self._pool.connection() as conn:\n\t            query_builder = QueryBuilder(conn)\n\t            res = query_builder.execute_query(index_name, filters)\n\t            allowed_ids = []\n\t            for row in res:\n\t                allowed_ids.append(row[0])\n\t            return allowed_ids\n\t    def get_indices(self):\n", "        \"\"\"\n\t        Get all index details\n\t        \"\"\"\n\t        with self._pool.connection() as conn:\n\t            with conn.cursor() as cur:\n\t                cur.execute(queries.GET_ALL_INDEX_DETAILS)\n\t                return cur.fetchall()\n\t    def get_index_details(\n\t        self,\n\t        name: str\n", "    ) -> Optional[Tuple[int, str, int, int, int, int, int, bool]]:\n\t        \"\"\"\n\t        Get specific index details\n\t        name: Name of index to fetch\n\t        \"\"\"\n\t        parameters = (name,)\n\t        with self._pool.connection() as conn:\n\t            with conn.cursor() as cur:\n\t                cur.execute(queries.GET_INDEX_DETAILS_BY_NAME, parameters)\n\t                return cur.fetchone()\n", "    def get_vector_ids_of_results(\n\t        self,\n\t        name: str,\n\t        results: List[List[int]],\n\t        include: Dict\n\t    ):\n\t        \"\"\"\n\t        Get user facing IDs of results\n\t        name: Name of index\n\t        results: List of list of integer HNSW labels\n", "        \"\"\"\n\t        index_details = self.get_index_details(name)\n\t        if not(index_details):\n\t            return\n\t        cols = [sql.Identifier(\"id\")]\n\t        if include[\"document\"]:\n\t            cols.append(sql.Identifier(\"text\"))\n\t            if include[\"metadata\"]:\n\t                cols.append(sql.Identifier(\"metadata\"))\n\t        elif include[\"metadata\"]:\n", "            cols.append(sql.Identifier(\"metadata\"))\n\t        returning_list = []\n\t        unordered_rows_list = []\n\t        index_id = index_details[0]\n\t        with self._pool.connection() as conn:\n\t            with conn.cursor() as cur:\n\t                data = []\n\t                for ids in results:\n\t                    ids_list = []\n\t                    for id in ids:\n", "                        ids_list.append(int(id))\n\t                    data.append([ids_list, index_id])\n\t                query = sql.SQL(queries.GET_VECTOR_IDS_OF_RESULTS).format(\n\t                    sql.SQL(\", \").join(cols)\n\t                )\n\t                cur.executemany(\n\t                    query,\n\t                    data,\n\t                    returning=True\n\t                )\n", "                while True:\n\t                    rows = cur.fetchall()\n\t                    unordered_rows_list.append(rows)\n\t                    if not cur.nextset():\n\t                        break;\n\t                conn.commit()\n\t        # Order rows according to order of id in ids list\n\t        for i, ids in enumerate(results):\n\t            unordered_rows = unordered_rows_list[i]\n\t            ordered_rows = []\n", "            for id in ids:\n\t                low = 0; high = len(unordered_rows) - 1\n\t                while (low <= high):\n\t                    mid = low + (high - low)//2\n\t                    curr_vector_id = unordered_rows[mid][0]\n\t                    if curr_vector_id == id:\n\t                        ordered_rows.append(\n\t                            convert_row_to_dict(\n\t                                row=unordered_rows[mid],\n\t                                include=include\n", "                            )\n\t                        )\n\t                        break\n\t                    elif curr_vector_id < id:\n\t                        low = mid + 1\n\t                    else:\n\t                        high = mid - 1\n\t            returning_list.append(ordered_rows)\n\t        return returning_list\n\t    def insert_to_index(\n", "        self,\n\t        data\n\t    ):\n\t        \"\"\"\n\t        Insert vectors to index\n\t        data: Tuple of tuples corresponding to each row\n\t        \"\"\"\n\t        vector_ids = []\n\t        with self._pool.connection() as conn:\n\t            with conn.cursor() as cur:\n", "                cur.executemany(queries.INSERT_DATA_TO_INDEX, data, returning=True)\n\t                while True:\n\t                    vector_ids.append(cur.fetchone()[0])        # type: ignore\n\t                    if not cur.nextset():\n\t                        break;\n\t                conn.commit()\n\t        return vector_ids\n\t    def update_ef(\n\t        self,\n\t        name: str,\n", "        ef: int\n\t    ):\n\t        \"\"\"\n\t        Update ef for an index\n\t        name: Name of index to be updated\n\t        ef: New ef value\n\t        \"\"\"\n\t        parameters = (ef, name)\n\t        with self._pool.connection() as conn:\n\t            with conn.cursor() as cur:\n", "                cur.execute(queries.UPDATE_EF, parameters)\n\t                conn.commit()\n"]}
{"filename": "citrusdb/db/postgres/queries.py", "chunked_list": ["CREATE_INDEX_MANAGER_TABLE = '''\n\tCREATE TABLE IF NOT EXISTS index_manager (\n\t    index_id BIGSERIAL PRIMARY KEY,\n\t    name TEXT NOT NULL UNIQUE,\n\t    dimensions INTEGER NOT NULL,\n\t    max_elements INTEGER NOT NULL,\n\t    m INTEGER NOT NULL,\n\t    ef INTEGER NOT NULL,\n\t    ef_construction INTEGER NOT NULL,\n\t    allow_replace_deleted BOOLEAN NOT NULL\n", ");\n\t'''\n\tCREATE_INDEX_DATA_TABLE = '''\n\tCREATE TABLE IF NOT EXISTS index_data (\n\t    vector_id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n\t    id text NOT NULL,\n\t    index_id BIGINT,\n\t    text TEXT,\n\t    embedding JSONB NOT NULL,\n\t    metadata JSONB,\n", "    UNIQUE(id, index_id),\n\t    FOREIGN KEY(index_id) REFERENCES index_manager(index_id) ON DELETE CASCADE\n\t);\n\t'''\n\tDELETE_VECTORS_FROM_INDEX = '''\n\tDELETE FROM index_data\n\tWHERE id = ANY(%s) AND index_id = %s\n\tRETURNING vector_id\n\t'''\n\tGET_ALL_INDEX_DETAILS = '''\n", "SELECT index_id, name, dimensions, max_elements, m, ef, ef_construction, allow_replace_deleted\n\tFROM index_manager\n\t'''\n\tGET_INDEX_DETAILS_BY_NAME = '''\n\tSELECT index_id, name, dimensions, max_elements, m, ef, ef_construction, allow_replace_deleted\n\tFROM index_manager\n\tWHERE name = %s\n\t'''\n\tGET_VECTOR_IDS_OF_RESULTS = '''\n\tSELECT vector_id, {}\n", "FROM index_data\n\tWHERE vector_id = ANY(%s) AND index_id = %s\n\tORDER BY vector_id ASC\n\t'''\n\tINSERT_DATA_TO_INDEX = '''\n\tINSERT INTO index_data\n\t(id, index_id, text, embedding, metadata)\n\tVALUES(%s, %s, %s, %s, %s)\n\tON CONFLICT(id, index_id)\n\tDO UPDATE SET id = %s, index_id = %s, text = %s, embedding = %s, metadata = %s\n", "RETURNING vector_id\n\t'''\n\tINSERT_INDEX_TO_MANAGER = '''\n\tINSERT INTO index_manager\n\t(name, dimensions, max_elements, m, ef, ef_construction, allow_replace_deleted)\n\tVALUES (%s, %s, %s, %s, %s, %s, %s);\n\t'''\n\tUPDATE_EF = '''\n\tUPDATE index_manager\n\tSET ef = %s\n", "WHERE name = %s\n\t'''\n"]}
{"filename": "citrusdb/db/sqlite/query_builder.py", "chunked_list": ["import sqlite3\n\tfrom typing import Dict, List\n\tclass QueryBuilder:\n\t    _con: sqlite3.Connection\n\t    def __init__(self, connection):\n\t        self._con = connection\n\t    def build_query(self, index_name, filters):\n\t        # Building the base SQL query\n\t        sql_query = f\"SELECT d.vector_id, d.id, d.index_id, d.text FROM index_data d JOIN index_manager m ON m.index_id = d.index_id WHERE m.name = '{index_name}'\"\n\t        # Adding the filter criteria to the SQL query\n", "        if filters:\n\t            sql_query += \" AND \"\n\t            conditions = []\n\t            for filter in filters:\n\t                field = filter[\"field\"]\n\t                operator = filter[\"operator\"]\n\t                value = filter[\"value\"]\n\t                if isinstance(value, int) or isinstance(value, float):\n\t                    condition = f\"metadata ->> '{field}' {operator} {value}\"\n\t                else:\n", "                    condition = f\"metadata ->> '{field}' {operator} '{value}'\"\n\t                conditions.append(condition)\n\t            sql_query += \" AND \".join(conditions)\n\t        return sql_query\n\t    def execute_query(self, index_name: str, filters: List[Dict]):\n\t        cursor = self._con.cursor()\n\t        # Building and executing the query\n\t        sql_query = self.build_query(index_name, filters)\n\t        cursor.execute(sql_query)\n\t        results = cursor.fetchall()\n", "        return results\n"]}
{"filename": "citrusdb/db/sqlite/db.py", "chunked_list": ["import os\n\timport sqlite3\n\tfrom typing import Dict, List, Optional, Tuple\n\tfrom citrusdb.db import BaseDB\n\tfrom citrusdb.utils.types import IDs\n\tfrom citrusdb.utils.utils import convert_row_to_dict, ensure_valid_path\n\timport citrusdb.db.sqlite.queries as queries\n\tfrom citrusdb.db.sqlite.query_builder import QueryBuilder\n\tclass SQLiteDB(BaseDB):\n\t    _con: sqlite3.Connection\n", "    def __init__(\n\t        self,\n\t        persist_directory: str,\n\t    ):\n\t        ensure_valid_path(persist_directory)\n\t        self._con = sqlite3.connect(\n\t            os.path.join(\n\t                persist_directory, \"citrus.db\"\n\t            )\n\t        )\n", "        cur = self._con.cursor()\n\t        cur.execute(\"PRAGMA foreign_keys = ON\")    # Enable foreign keys\n\t        cur.executescript(f'''\n\t        BEGIN;\n\t        {queries.CREATE_INDEX_MANAGER_TABLE}\n\t        {queries.CREATE_INDEX_DATA_TABLE}\n\t        END;\n\t        ''')\n\t        cur.close()\n\t    def create_index(\n", "        self,\n\t        name: str,\n\t        max_elements: int,\n\t        M: int,\n\t        ef_construction: int,\n\t        allow_replace_deleted: bool,\n\t        dimensions: Optional[int] = 1536,\n\t    ):\n\t        cur = self._con.cursor()\n\t        ef = ef_construction\n", "        parameters = (name, dimensions, max_elements, M, ef, ef_construction, allow_replace_deleted)\n\t        cur.execute(queries.INSERT_INDEX_TO_MANAGER, parameters)\n\t        self._con.commit()\n\t        cur.close()\n\t    def delete_vectors_from_index(\n\t        self,\n\t        index_id: int,\n\t        ids: IDs\n\t    ):\n\t        cur = self._con.cursor()\n", "        query = queries.DELETE_VECTORS_FROM_INDEX.format(\", \".join(\"?\" * len(ids)))\n\t        parameters = tuple(ids) + (index_id,)\n\t        cur.execute(query, parameters)\n\t        rows = cur.fetchall()\n\t        self._con.commit()\n\t        cur.close()\n\t        vector_ids = [row[0] for row in rows]\n\t        return vector_ids\n\t    def filter_vectors(self, index_name: str, filters: List[Dict]):\n\t        query_builder = QueryBuilder(self._con)\n", "        res = query_builder.execute_query(index_name, filters)\n\t        allowed_ids = []\n\t        for row in res:\n\t            allowed_ids.append(row[0])\n\t        return allowed_ids\n\t    def get_indices(self):\n\t        \"\"\"\n\t        Fetch all index details from index_manager table.\n\t        Returns a list of tuples where each one corresponds to an index.\n\t        \"\"\"\n", "        cur = self._con.cursor()\n\t        res = cur.execute(queries.GET_ALL_INDEX_DETAILS)\n\t        rows = res.fetchall()\n\t        cur.close()\n\t        return rows\n\t    def get_index_details(\n\t        self,\n\t        name: str\n\t    ) -> Optional[Tuple[int, str, int, int, int, int, int, bool]]:\n\t        cur = self._con.cursor()\n", "        parameters = (name,)\n\t        res = cur.execute(queries.GET_INDEX_DETAILS_BY_NAME, parameters)\n\t        row = res.fetchone()\n\t        cur.close()\n\t        return row\n\t    def get_vector_ids_of_results(\n\t        self,\n\t        name: str,\n\t        results: List[List[int]],\n\t        include: Dict\n", "    ) -> List[List[Dict]]:\n\t        cols = \"id\"\n\t        if include[\"document\"]:\n\t            cols += \", text\"\n\t            if include[\"metadata\"]:\n\t                cols += \", metadata\"\n\t        elif include[\"metadata\"]:\n\t            cols += \", metadata\"\n\t        returning_list = []\n\t        index_details = self.get_index_details(name)\n", "        index_id = index_details[0]                 # type: ignore\n\t        cur = self._con.cursor()\n\t        for ids in results:\n\t            query = queries.GET_VECTOR_IDS_OF_RESULTS.format(cols, \", \".join(\"?\" * len(ids)))\n\t            parameters = ()\n\t            for id in ids:\n\t                parameters += (int(id),)\n\t            parameters += (index_id,)\n\t            res = cur.execute(query, parameters)\n\t            unordered_rows = res.fetchall()         # Rows not ordered according to similarity score\n", "            # Order rows according to order of id in ids list\n\t            ordered_rows = []\n\t            for id in ids:\n\t                low = 0; high = len(unordered_rows) - 1\n\t                while (low <= high):\n\t                    mid = low + (high - low)//2\n\t                    curr_vector_id = unordered_rows[mid][0]\n\t                    if curr_vector_id == id:\n\t                        ordered_rows.append(\n\t                            convert_row_to_dict(\n", "                                row=unordered_rows[mid],\n\t                                include=include\n\t                            )\n\t                        )\n\t                        break\n\t                    elif curr_vector_id < id:\n\t                        low = mid + 1\n\t                    else:\n\t                        high = mid - 1\n\t            returning_list.append(ordered_rows)\n", "        cur.close()\n\t        return returning_list\n\t    def insert_to_index(\n\t        self,\n\t        data\n\t    ):\n\t        cur = self._con.cursor()\n\t        vector_ids = []\n\t        for row in data:\n\t            res = cur.execute(queries.INSERT_DATA_TO_INDEX, row)\n", "            vector_ids.append(res.fetchone()[0])\n\t        self._con.commit()\n\t        cur.close()\n\t        return vector_ids\n\t    def update_ef(\n\t        self,\n\t        name: str,\n\t        ef: int\n\t    ):\n\t        cur = self._con.cursor()\n", "        parameters = (ef, name)\n\t        cur.execute(queries.UPDATE_EF, parameters)\n\t        self._con.commit()\n\t        cur.close()\n"]}
{"filename": "citrusdb/db/sqlite/__init__.py", "chunked_list": []}
{"filename": "citrusdb/db/sqlite/queries.py", "chunked_list": ["CREATE_INDEX_MANAGER_TABLE = '''\n\tCREATE TABLE IF NOT EXISTS index_manager (\n\t    index_id INTEGER PRIMARY KEY AUTOINCREMENT,\n\t    name TEXT NOT NULL UNIQUE,\n\t    dimensions INTEGER NOT NULL,\n\t    max_elements INTEGER NOT NULL,\n\t    m INTEGER NOT NULL,\n\t    ef INTEGER NOT NULL,\n\t    ef_construction INTEGER NOT NULL,\n\t    allow_replace_deleted INTEGER NOT NULL\n", ");\n\t'''\n\tCREATE_INDEX_DATA_TABLE = '''\n\tCREATE TABLE IF NOT EXISTS index_data (\n\t    vector_id INTEGER PRIMARY KEY AUTOINCREMENT,\n\t    id TEXT NOT NULL,\n\t    index_id INTEGER,\n\t    text TEXT,\n\t    embedding BLOB NOT NULL,\n\t    metadata TEXT,\n", "    UNIQUE(id, index_id),\n\t    FOREIGN KEY(index_id) REFERENCES index_manager(index_id) ON DELETE CASCADE\n\t);\n\t'''\n\tDELETE_VECTORS_FROM_INDEX = '''\n\tDELETE FROM index_data\n\tWHERE id IN ({}) AND index_id = ?\n\tRETURNING vector_id\n\t'''\n\tGET_ALL_INDEX_DETAILS = '''\n", "SELECT index_id, name, dimensions, max_elements, m, ef, ef_construction, allow_replace_deleted\n\tFROM index_manager\n\t'''\n\tGET_INDEX_DETAILS_BY_NAME = '''\n\tSELECT index_id, name, dimensions, max_elements, m, ef, ef_construction, allow_replace_deleted\n\tFROM index_manager\n\tWHERE name = ?\n\t'''\n\tGET_VECTOR_IDS_OF_RESULTS = '''\n\tSELECT vector_id, {}\n", "FROM index_data\n\tWHERE vector_id IN ({}) AND index_id = ?\n\tORDER BY vector_id ASC\n\t'''\n\tINSERT_DATA_TO_INDEX = '''\n\tINSERT INTO index_data\n\t(id, index_id, text, embedding, metadata)\n\tVALUES(?, ?, ?, ?, ?)\n\tON CONFLICT(id, index_id)\n\tDO UPDATE SET id = ?, index_id = ?, text = ?, embedding = ?, metadata = ?\n", "RETURNING vector_id\n\t'''\n\tINSERT_INDEX_TO_MANAGER = '''\n\tINSERT INTO index_manager\n\t(name, dimensions, max_elements, m, ef, ef_construction, allow_replace_deleted)\n\tVALUES (?, ?, ?, ?, ?, ?, ?);\n\t'''\n\tUPDATE_EF = '''\n\tUPDATE index_manager\n\tSET ef = ?\n", "WHERE name = ?\n\t'''\n"]}
{"filename": "citrusdb/api/local.py", "chunked_list": ["import enum\n\timport os\n\timport json\n\tfrom typing import Any, Dict, List, Optional\n\tfrom numpy import float32\n\tfrom numpy._typing import NDArray\n\timport shutil\n\tfrom citrusdb.api.index import Index\n\tfrom citrusdb.db import BaseDB\n\tfrom citrusdb.db.postgres.db import PostgresDB\n", "from citrusdb.db.sqlite.db import SQLiteDB\n\tfrom citrusdb.utils.types import IDs\n\tclass LocalAPI:\n\t    _db: Dict[str, Index] \n\t    _SQLClient: BaseDB\n\t    persist_directory: Optional[str]\n\t    _TEMP_DIRECTORY = \"citrus_temp\"\n\t    def __init__(\n\t        self,\n\t        persist_directory: Optional[str] = None,\n", "        database_type: Optional[str] = \"sqlite\",\n\t        **kwargs: Optional[Dict[str, Any]]\n\t    ):\n\t        self._db = {}\n\t        self.persist_directory = persist_directory\n\t        if not(persist_directory) and os.path.isdir(self._TEMP_DIRECTORY):\n\t            # Cleanup previous sqlite data\n\t            shutil.rmtree(self._TEMP_DIRECTORY)\n\t        if persist_directory and (database_type == \"pg\" or database_type == \"postgres\"):\n\t            self._SQLClient = PostgresDB(**kwargs)\n", "        else:\n\t            self._SQLClient = SQLiteDB(persist_directory if persist_directory else self._TEMP_DIRECTORY)\n\t    def create_index(\n\t        self,\n\t        name: str,\n\t        max_elements: int = 1000,\n\t        M: int = 64,\n\t        ef_construction: int = 200,\n\t        allow_replace_deleted: bool = False,\n\t    ):\n", "        if not(self._SQLClient.get_index_details(name)):\n\t            self._SQLClient.create_index(\n\t                name,\n\t                max_elements,\n\t                M,\n\t                ef_construction,\n\t                allow_replace_deleted\n\t            )\n\t        self._db[name] = Index(\n\t            name=name,\n", "            max_elements=max_elements,\n\t            persist_directory=self.persist_directory,\n\t            M=M,\n\t            ef_construction=ef_construction,\n\t            allow_replace_deleted=allow_replace_deleted\n\t        )\n\t    def add(\n\t        self,\n\t        index: str,\n\t        ids: IDs,\n", "        documents: Optional[List[str]] = None,\n\t        embeddings: Optional[NDArray[float32]] = None,\n\t        metadatas: Optional[List[Dict]] = None\n\t    ):\n\t        \"\"\"\n\t        Insert embeddings/text documents\n\t        index: Name of index\n\t        ids: Unique ID for each element\n\t        documents: List of strings to index\n\t        embeddings: List of embeddings to index\n", "        metadatas: Additional metadata for each vector\n\t        \"\"\"\n\t        if embeddings is None and documents is None:\n\t            raise ValueError(\"Please provide either embeddings or documents.\")\n\t        index_details = self._SQLClient.get_index_details(index)\n\t        if index_details is None:\n\t            raise ValueError(f\"Index with name '{index}' does not exist.\")\n\t        if (documents is not None) and (embeddings is None):\n\t            from citrusdb.embedding.openai import get_embeddings\n\t            embeddings = get_embeddings(documents)\n", "        if embeddings is not None:\n\t            embedding_dim = len(embeddings[0])\n\t            index_id = index_details[0]\n\t            index_dim = index_details[2]\n\t            replace_deleted = True if index_details[7] else False\n\t            # Check whether the dimensions are equal\n\t            if embedding_dim != index_dim:\n\t                raise ValueError(\n\t                        f\"Embedding dimenstion ({embedding_dim}) and index \"\n\t                        + f\"dimension ({index_dim}) do not match.\"\n", "                        )\n\t            # Ensure no of ids = no of embeddings\n\t            if len(ids) != len(embeddings):\n\t                raise ValueError(f\"Number of embeddings\" + \" and ids are different.\")\n\t            data = []\n\t            for i in range(len(ids)):\n\t                row = (\n\t                    ids[i],\n\t                    index_id,\n\t                    None if documents is None else documents[i],\n", "                    json.dumps(embeddings[i].tolist()),\n\t                    None if metadatas is None else json.dumps(metadatas[i])\n\t                )\n\t                data.append(row + row)\n\t            # Insert data into DB\n\t            hnsw_labels = self._SQLClient.insert_to_index(data)\n\t            # Index vectors\n\t            self._db[index].add(\n\t                ids=hnsw_labels,\n\t                embeddings=embeddings,\n", "                replace_deleted=replace_deleted\n\t            )\n\t    def delete_vectors(\n\t        self,\n\t        index: str,\n\t        ids: IDs\n\t    ):\n\t        index_details = self._SQLClient.get_index_details(index)\n\t        if index_details is None:\n\t            raise ValueError(f\"Could not find index: {index}\")\n", "        index_id = index_details[0]\n\t        hnsw_labels = self._SQLClient.delete_vectors_from_index(\n\t            index_id=index_id,\n\t            ids=ids\n\t        )\n\t        self._db[index].delete_vectors(hnsw_labels)\n\t    def reload_indices(self):\n\t        \"\"\"\n\t        Load all indices from disk to memory\n\t        \"\"\"\n", "        indices = self._SQLClient.get_indices()\n\t        for index in indices:\n\t            index_name = index[1]\n\t            # Load index\n\t            self.create_index(\n\t                name=index_name,\n\t                max_elements=index[3],\n\t                M=index[4],\n\t                ef_construction=index[6],\n\t                allow_replace_deleted=index[7]\n", "            )\n\t            # Set ef value\n\t            self._db[index_name].set_ef(index[5])\n\t    def set_ef(self, index: str, ef: int):\n\t        index_details = self._SQLClient.get_index_details(index)\n\t        if index_details is None:\n\t            raise ValueError(f\"Could not find index: {index}\")\n\t        self._SQLClient.update_ef(index, ef)\n\t        self._db[index].set_ef(ef)\n\t    def query(\n", "        self,\n\t        index: str,\n\t        documents: Optional[List[str]] = None,\n\t        query_embeddings: Optional[NDArray[float32]] = None,\n\t        k=1,\n\t        filters: Optional[List[Dict]] = None,\n\t        include: List[str] = []\n\t    ):\n\t        allowed_ids = []\n\t        if filters is not None:\n", "            allowed_ids = self._SQLClient.filter_vectors(index, filters)\n\t        filter_function = lambda label: label in allowed_ids\n\t        included_columns = {\"id\": True, \"document\": False, \"metadata\": False}\n\t        if \"document\" in include:\n\t            included_columns[\"document\"] = True\n\t        if \"metadata\" in include:\n\t            included_columns[\"metadata\"] = True\n\t        flag = 1\n\t        for key in self._db.keys():\n\t            if key == index:\n", "                flag = 0\n\t                results, distances = self._db[key].query(\n\t                    documents=documents,\n\t                    query_embeddings=query_embeddings,\n\t                    k=k,\n\t                    filter_function=None if filters is None else filter_function\n\t                )\n\t                elements = self._SQLClient.get_vector_ids_of_results(\n\t                    name=index,\n\t                    results=results,\n", "                    include=included_columns\n\t                )\n\t                for i, rows in enumerate(elements):\n\t                    for j, row in enumerate(rows):\n\t                        row[\"distance\"] = distances[i][j]\n\t                return elements\n\t        if flag:\n\t            raise ValueError(f\"Could not find index: {index}\")\n\t    def get_status(self, index: str):\n\t        flag = 1\n", "        for key in self._db.keys():\n\t            if key == index:\n\t                flag = 0\n\t                self._db[key].get_status()\n\t        if flag:\n\t            raise ValueError(f\"Could not find index: {index}\")\n"]}
{"filename": "citrusdb/api/__init__.py", "chunked_list": []}
{"filename": "citrusdb/api/index.py", "chunked_list": ["import os\n\timport pickle\n\tfrom typing import Any, List, Optional\n\tfrom numpy import float32\n\tfrom numpy._typing import NDArray\n\tfrom citrusdb.db.index.hnswlib import HnswIndex\n\tfrom citrusdb.utils.types import IDs\n\tfrom citrusdb.utils.utils import ensure_valid_path\n\tclass Index:\n\t    _db: HnswIndex\n", "    _parameters: dict\n\t    def __init__(\n\t        self,\n\t        name: str,\n\t        max_elements: int = 1000,\n\t        persist_directory: Optional[str] = None,\n\t        M: int = 64,\n\t        ef_construction: int = 200,\n\t        allow_replace_deleted: bool = False,\n\t    ):\n", "        self._db = HnswIndex(id=name)\n\t        self._parameters = {\n\t            \"index_name\": name,\n\t            \"max_elements\": max_elements,\n\t            \"persist_directory\": persist_directory,\n\t            \"M\": M,\n\t            \"ef_construction\": ef_construction,\n\t            \"allow_replace_deleted\": allow_replace_deleted,\n\t        }\n\t        if persist_directory:\n", "            self._load_params()\n\t            if ensure_valid_path(persist_directory, str(self._parameters[\"index_name\"])):\n\t                self._db.load_index(\n\t                    os.path.join(\n\t                        persist_directory, str(self._parameters[\"index_name\"])\n\t                    ),\n\t                    allow_replace_deleted=bool(\n\t                        self._parameters[\"allow_replace_deleted\"]\n\t                    ),\n\t                )\n", "            else:\n\t                self._db.init_index(\n\t                    max_elements=max_elements,\n\t                    M=M,\n\t                    ef_construction=ef_construction,\n\t                    allow_replace_deleted=allow_replace_deleted,\n\t                )\n\t                self._save()\n\t        else:\n\t            self._db.init_index(\n", "                max_elements=max_elements,\n\t                M=M,\n\t                ef_construction=ef_construction,\n\t                allow_replace_deleted=allow_replace_deleted,\n\t            )\n\t    def add(\n\t        self,\n\t        ids: List[int],\n\t        embeddings: Optional[NDArray[float32]],\n\t        replace_deleted: bool,\n", "    ):\n\t        self._db.add_items(embeddings, ids, replace_deleted)\n\t        if self._parameters[\"persist_directory\"]:\n\t            self._save()\n\t    def _load_params(self):\n\t        if ensure_valid_path(self._parameters[\"persist_directory\"], \".citrus_params\"):\n\t            filename = os.path.join(\n\t                self._parameters[\"persist_directory\"], \".citrus_params\"\n\t            )\n\t            with open(filename, \"rb\") as f:\n", "                self._parameters = pickle.load(f)\n\t    def delete_vectors(self, ids: List[int]):\n\t        for id in ids:\n\t            self._db.mark_deleted(id)\n\t        if self._parameters[\"persist_directory\"]:\n\t            self._save()\n\t    def _save(self):\n\t        self._db.save_index(\n\t            os.path.join(\n\t                self._parameters[\"persist_directory\"], self._parameters[\"index_name\"]\n", "            )\n\t        )\n\t        self._save_params()\n\t    def _save_params(self):\n\t        output_file = os.path.join(\n\t            self._parameters[\"persist_directory\"], \".citrus_params\"\n\t        )\n\t        with open(output_file, \"wb\") as f:\n\t            pickle.dump(self._parameters, f)\n\t    def set_ef(self, ef: int):\n", "        self._db.set_ef(ef)\n\t    def query(\n\t        self,\n\t        documents: Optional[List[str]] = None,\n\t        query_embeddings: Optional[NDArray[float32]] = None,\n\t        k=1,\n\t        filter_function=None\n\t    ):\n\t        if query_embeddings is None and documents is None:\n\t            raise ValueError(\"Please provide either an embedding\" + \" or a document.\")\n", "        if documents is not None:\n\t            from citrusdb.embedding.openai import get_embeddings\n\t            embeddings = get_embeddings(documents)\n\t            query_embeddings = embeddings\n\t        return self._db.knn_query(query_embeddings, k, filter_function)\n\t    def get_status(self):\n\t        self._db.get_status()\n\t    def get_dimension(self):\n\t        return self._db.get_dimension()\n\t    def get_replace_deleted(self):\n", "        return self._parameters[\"allow_replace_deleted\"]\n"]}
{"filename": "citrusdb/embedding/openai.py", "chunked_list": ["import os\n\timport numpy as np\n\timport openai\n\tfrom typing import List\n\topenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\tdef get_embeddings(data: List[str], model=\"text-embedding-ada-002\"):\n\t    strings = [text.replace(\"\\n\", \" \") for text in data]\n\t    response = openai.Embedding.create(model=model, input=strings)\n\t    return np.array([result[\"embedding\"] for result in response[\"data\"]], dtype=np.float32)\n"]}
{"filename": "citrusdb/embedding/__init__.py", "chunked_list": []}
{"filename": "demo/demo.py", "chunked_list": ["import citrusdb\n\timport json\n\t# Instantiate citrusdb\n\tcitrus = citrusdb.Client()\n\t# Create index\n\tcitrus.create_index(\n\t    name=\"pokemon\",\n\t    max_elements=50,\n\t)\n\tpokemons = []\n", "documents = []\n\tids = []\n\twith open(\"demo/pokemon.jsonl\", \"r\") as f:\n\t    for line in f:\n\t        pokemon = json.loads(line)\n\t        pokemons.append(pokemon)\n\t        documents.append(pokemon[\"info\"][\"description\"])\n\t        ids.append(pokemon[\"info\"][\"id\"])\n\t# Insert documents to index\n\tcitrus.add(\"pokemon\", ids, documents=documents)\n", "citrus.get_status(\"pokemon\")\n\tcitrus.delete_vectors(\"pokemon\", [\"143\"])\n\t# Query with a text input\n\tres = citrus.query(\n\t    \"pokemon\",\n\t    documents=[\"Likes to sleep\"],\n\t    k=5\n\t)\n\tdef find_pokemon(id):\n\t    for pokemon in pokemons:\n", "        if (pokemon[\"info\"][\"id\"] == int(id)):\n\t            print(format(pokemon))\n\t            break\n\tdef format(pokemon):\n\t    return f\"\"\"Name: {pokemon[\"name\"]}\n\tPokedex ID: {pokemon[\"info\"][\"id\"]}\n\tType: {pokemon[\"info\"][\"type\"]}\n\tDescription: {pokemon[\"info\"][\"description\"]}\n\t\"\"\"\n\tif res:\n", "    ids_list, distances = res\n\t    # Print results\n\t    for ids in ids_list:\n\t        for id in ids:\n\t            find_pokemon(id)\n"]}
