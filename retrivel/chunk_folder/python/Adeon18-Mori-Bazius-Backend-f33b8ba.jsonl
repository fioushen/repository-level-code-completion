{"filename": "app/APIGetawayService/main.py", "chunked_list": ["import sys\n\timport os\n\tsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))) # I LOVE PYTHON\n\timport uvicorn\n\tfrom controller.gateway_controller import App\n\tif __name__ == '__main__':\n\t    app = App()\n\t    uvicorn.run(app.app, port=9000, host='0.0.0.0')\n"]}
{"filename": "app/APIGetawayService/controller/gateway_controller.py", "chunked_list": ["from fastapi import FastAPI\n\tfrom service.gateway_service import GatewayService\n\tfrom common.game_data.stats import Stats\n\tfrom common.game_data.resources import Resources\n\tfrom common.game_data.user import User\n\tfrom common.game_data.guild import GuildCreation, Member\n\tclass App:\n\t    def __init__(self):\n\t        self.app = FastAPI()\n\t        self.service = GatewayService()\n", "        # HANGLING REGISTRATION VALIDATION ETC\n\t        @self.app.post(\"/register\")\n\t        async def game_register_post(user_data: User):\n\t            return self.service.handle_register_operation(user_data)\n\t        @self.app.post(\"/login\")\n\t        async def game_login_post(user_data: User):\n\t            return self.service.handle_login_operation(user_data)\n\t        # HANDLING GAME DATA\n\t        @self.app.get(\"/game_data/stats\")\n\t        async def game_data_stats(player_id: int):\n", "            return self.service.get_game_stats(player_id)\n\t        @self.app.post(\"/game_data/stats\")\n\t        async def game_data_set_stats(player_id: int, stats: Stats):\n\t            return self.service.set_game_stats(player_id, stats)\n\t        @self.app.get(\"/game_data/resources\")\n\t        async def game_data_resources(player_id: int):\n\t            return self.service.get_game_resources(player_id)\n\t        @self.app.post(\"/game_data/resources\")\n\t        async def game_data_set_resources(player_id: int, resources: Resources):\n\t            return self.service.set_game_resources(player_id, resources)\n", "        @self.app.get(\"/game_data/leaderboard\")\n\t        async def game_data_leaderboard(limit: int):\n\t            return self.service.get_game_leaderboard(limit)\n\t        @self.app.get(\"/game_data/average\")\n\t        async def game_data_average(player_id: int):\n\t            return self.service.get_game_data_average(player_id)\n\t        # HANDLING GUILDS\n\t        @self.app.get(\"/guilds\")\n\t        async def get_guilds(limit: int):\n\t            return self.service.get_guilds(limit)\n", "        @self.app.get(\"/members\")\n\t        async def get_members(gid: str):\n\t            return self.service.get_members(gid)\n\t        @self.app.get(\"/guild\")\n\t        async def get_guild_by_member(player_id: int):\n\t            return self.service.get_guild_by_member(player_id)\n\t        @self.app.post(\"/guilds/new\")\n\t        async def create_guild(new_guild: GuildCreation):\n\t            print(new_guild)\n\t            return self.service.create_guild(dict(new_guild))\n", "        @self.app.post(\"/guilds/members/new\")\n\t        async def join_guild(member: Member):\n\t            return self.service.join_guild(member)\n\t        @self.app.delete(\"/guilds/leave\")\n\t        async def leave_guild(gid: str, player_id: int):\n\t            return self.service.leave_guild(gid, player_id)\n\t        @self.app.delete(\"/guilds/delete\")\n\t        async def delete_guild(gid: str):\n\t            return self.service.delete_guild(gid)\n"]}
{"filename": "app/APIGetawayService/controller/__init__.py", "chunked_list": []}
{"filename": "app/APIGetawayService/service/__init__.py", "chunked_list": []}
{"filename": "app/APIGetawayService/service/gateway_service.py", "chunked_list": ["from common.game_data.stats import Stats\n\tfrom common.game_data.resources import Resources\n\tfrom common.game_data.user import User\n\tfrom common.game_data.guild import GuildCreation, Member\n\tfrom kafka import KafkaProducer\n\timport requests\n\timport consul\n\timport json\n\timport random\n\tKAFKA_SERVER = 'kafka-server:9092'\n", "GAME_DATA_TOPIC = 'game-data'\n\tGAME_STATS_TOPIC = 'game-stats'\n\tREGISTER_SERVICE_URL = 'http://register-service:8080/user/'\n\tLOGIN_SERVICE_URL = 'http://login-service:8080/login/user/'\n\tVALIDATION_SERVICE_URL = 'http://validation-service:8080/c/'\n\tSTATS_GAME_DATA_URL = 'http://game_data:8000/stats?player_id='\n\tRESOURCES_GAME_DATA_URL = 'http://game_data:8000/resources?player_id='\n\tLEADERBOARD_URL = \"http://game_data:8000/leaderboard?limit=\"\n\tAVERAGE_GAME_DATA_URL = 'http://game_data:8000/resources?player_id='\n\t# Guilds service urls\n", "GUILDS_URL = \"http://guilds-service:6969/guilds?limit={}\"\n\tGUILD_MEMBERS_URL = \"http://guilds-service:6969/members?gid={}\"\n\tGUILD_BY_MEMBER_URL = \"http://guilds-service:6969/guild?player_id={}\"\n\tCREATE_GUILD_URL = \"http://guilds-service:6969/guilds/new\"\n\tJOIN_GUILD_URL = \"http://guilds-service:6969/guilds/members/new\"\n\tLEAVE_GUILD_URL = \"http://guilds-service:6969/guilds/leave?gid={}&player_id={}\"\n\tDELETE_GUILD_URL = \"http://guilds-service:6969/guilds/delete?gid={}\"\n\tclass GatewayService:\n\t    def __init__(self):\n\t        self.producer = KafkaProducer(bootstrap_servers=[KAFKA_SERVER])\n", "        self.consul_service = consul.Consul(host=\"consul\")\n\t    # Returns a boolean whether the validation was successful\n\t    def verify_request(self, uid: str, token: str):\n\t        url, port = self.get_address(\"validation\")\n\t        response = requests.post(\n\t            url=f\"http://{url}:{port}/validate\", json={\"uid\": uid, \"token\": token})\n\t        if response.text == \"true\":\n\t            return True\n\t        return False\n\t    def get_address(self, service_name):\n", "        consul_info = self.consul_service.health.service(service_name)[1]\n\t        address = random.choice(consul_info)[\"Service\"][\"Address\"]\n\t        port = random.choice(consul_info)[\"Service\"][\"Port\"]\n\t        return address, port\n\t    def handle_register_operation(self, user_data: User):\n\t        response = requests.post(\n\t            url=REGISTER_SERVICE_URL, json={\"username\": user_data.username, \"password\": user_data.password})\n\t        return response.json()\n\t    def handle_login_operation(self, user_data: User):\n\t        response = requests.post(\n", "            url=LOGIN_SERVICE_URL, json=dict(user_data))\n\t        return response.json()\n\t    def get_game_resources(self, player_id: int):\n\t        url, port = self.get_address(\"game-data\")\n\t        response = requests.get(url=f'http://{url}:{port}/resources?player_id=' + str(player_id))\n\t        return response.json()\n\t    def set_game_resources(self, player_id: int, resources: Resources):\n\t        # Verify the sender\n\t        if (not self.verify_request(resources.player_id, resources.token)):\n\t            print(\"Bad token: \" + resources.token, flush=True)\n", "            return {\"success\": False}\n\t        resources.token = None\n\t        # sync for now\n\t        metadata = self.producer.send(GAME_DATA_TOPIC, json.dumps(\n\t            resources.dict()).encode()).get(timeout=10)\n\t        return {\"success\": True, \"topic\": metadata.topic}\n\t    def get_game_stats(self, player_id: int):\n\t        url, port = self.get_address(\"game-data\")\n\t        response = requests.get(url=f\"http://{url}:{port}/stats?player_id=\" + str(player_id))\n\t        return response.json()\n", "    def set_game_stats(self, player_id: int, stats: Stats):\n\t        # Verify the sender\n\t        if (not self.verify_request(stats.player_id, stats.token)):\n\t            print(\"Bad token: \" + stats.token, flush=True)\n\t            return {\"success\": False}\n\t        stats.token = None\n\t        # set gata in game_data\n\t        metadata = self.producer.send(GAME_STATS_TOPIC, json.dumps(\n\t            stats.dict()).encode()).get(timeout=10)\n\t        return {\"success\": True, \"topic\": metadata.topic}\n", "    def get_game_leaderboard(self, limit):\n\t        url, port = self.get_address(\"game-data\")\n\t        response = requests.get(url=f\"http://{url}:{port}/leaderboard?limit={limit}\")\n\t        return response.json()\n\t    def get_game_data_average(self, player_id: int):\n\t        url, port = self.get_address(\"game-data\")\n\t        response = requests.get(url=f'http://{url}:{port}/average?player_id=' + str(player_id))\n\t        return response.json()\n\t    def get_guilds(self, limit: int):\n\t        response = requests.get(GUILDS_URL.format(limit))\n", "        return response.json()\n\t    def get_members(self, gid: str):\n\t        response = requests.get(GUILD_MEMBERS_URL.format(gid))\n\t        return response.json()\n\t    def get_guild_by_member(self, player_id: int):\n\t        response = requests.get(GUILD_BY_MEMBER_URL.format(player_id))\n\t        return response.json()\n\t    def create_guild(self, new_guild: GuildCreation):\n\t        print(new_guild)\n\t        response = requests.post(CREATE_GUILD_URL, json=new_guild)\n", "        return response.json()\n\t    def join_guild(self, member: Member):\n\t        response = requests.post(JOIN_GUILD_URL, json=member.dict())\n\t        return response.json()\n\t    def leave_guild(self, gid: str, player_id: int):\n\t        response = requests.delete(LEAVE_GUILD_URL.format(gid, player_id))\n\t        return response.json()\n\t    def delete_guild(self, gid: str):\n\t        response = requests.delete(DELETE_GUILD_URL.format(gid))\n\t        return response.json()\n"]}
{"filename": "app/game_data_service/main.py", "chunked_list": ["import sys\n\timport os\n\tsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))) # I LOVE PYTHON\n\tfrom fastapi import FastAPI\n\tfrom contextlib import asynccontextmanager\n\tfrom service.game_data_service import GameDataService\n\tfrom common.game_data.stats import Stats\n\tfrom common.game_data.resources import Resources\n\tservice = GameDataService.new_service_with_cassandra()\n\t@asynccontextmanager\n", "async def lifespan(app: FastAPI):\n\t    # Startup\n\t    service.create_consume_data_task()\n\t    service.create_consume_stats_task()\n\t    yield\n\t    # Shutdown\n\t    await service.shutdown_consumers()\n\tapp = FastAPI(lifespan=lifespan)\n\t@app.get(\"/stats\")\n\tasync def stats(player_id: int):\n", "    return service.get_stats(player_id)\n\t@app.post(\"/stats\")\n\tasync def update_stats(player_id: int, stats: Stats):\n\t    service.set_stats(player_id, stats)\n\t    return stats\n\t@app.get(\"/resources\")\n\tasync def resources(player_id: int):\n\t    return service.get_resources(player_id)\n\t@app.post(\"/resources\")\n\tasync def update_resources(player_id: int, resources: Resources):\n", "    service.set_resources(player_id, resources)\n\t    return resources\n\t@app.get(\"/leaderboard\")\n\tasync def leaderboard(limit: int):\n\t    return service.get_leaderboard(limit)\n\t@app.get(\"/average\")\n\tasync def average_resources(player_id: int):\n\t    return service.get_average_resources(player_id)\n\t@app.get(\"/health\")\n\tdef healthcheck():\n", "    return True"]}
{"filename": "app/game_data_service/repository/__init__.py", "chunked_list": []}
{"filename": "app/game_data_service/repository/cassandra_repository.py", "chunked_list": ["import os\n\timport json\n\tfrom collections import namedtuple\n\tfrom common.game_data.stats import Stats\n\tfrom cassandra.cluster import Cluster\n\tfrom repository.game_data_repository import GameDataRepository\n\tfrom common.game_data.resources import Resources\n\tfrom common.game_data.stats import Stats\n\tclass CassandraRepository(GameDataRepository):\n\t    def __init__(self) -> None:\n", "        cassandra_endpoint = os.getenv(\"CASSANDRA_ENDPOINT\", \"localhost\")\n\t        cassandra_port = os.getenv(\"CASSANDRA_PORT\", 9042)\n\t        self.cassandra_client = Cluster([cassandra_endpoint], port=cassandra_port)\n\t        self.session = self.cassandra_client.connect()\n\t    def get_stats(self, player_id: int) -> dict:\n\t        query = f\"\"\"\n\t        SELECT * FROM hunters.player_stats_by_player_id\n\t        WHERE player_id = {player_id}\n\t        \"\"\"\n\t        res = self.session.execute(query)\n", "        json = []\n\t        for row in res:\n\t            result = {}\n\t            for column in row._fields:\n\t                result[column] = getattr(row, column)\n\t            json.append(result)\n\t            break\n\t        return json[0] if len(json) > 0 else {}\n\t    def get_resources(self, player_id: int) -> dict:\n\t        query = f\"\"\"\n", "        SELECT * FROM hunters.game_data_by_player_id\n\t        WHERE player_id = {player_id}\n\t        \"\"\"\n\t        res = self.session.execute(query)\n\t        json = []\n\t        for row in res:\n\t            result = {}\n\t            for column in row._fields:\n\t                result[column] = getattr(row, column)\n\t            json.append(result)\n", "            break\n\t        return json[0] if len(json) > 0 else {}\n\t    def set_stats(self, player_id: int, stats: Stats):\n\t        stats_to_update = dict(((key, value) for key, value in vars(stats).items() if value is not None))\n\t        keys_to_update = list(stats_to_update.keys())\n\t        values_to_update = [stats_to_update[key] for key in keys_to_update]\n\t        if \"player_id\" not in stats_to_update:\n\t            keys_to_update.insert(0, \"player_id\")\n\t            values_to_update.insert(0, player_id)\n\t        query = f\"\"\"\n", "        INSERT INTO hunters.player_stats_by_player_id \n\t        ({\", \".join(keys_to_update)}) VALUES ({\", \".join([\"?\" for _ in values_to_update])})\n\t        \"\"\"\n\t        query = self.session.prepare(query)\n\t        self.session.execute(query, values_to_update)\n\t    def set_resources(self, player_id: int, resources: Resources):\n\t        resources_to_update = dict(((key, value) for key, value in vars(resources).items() if value is not None))\n\t        keys_to_update = list(resources_to_update.keys())\n\t        values_to_update = [resources_to_update[key] for key in keys_to_update]\n\t        if \"player_id\" not in resources_to_update:\n", "            keys_to_update.insert(0, \"player_id\")\n\t            values_to_update.insert(0, player_id)\n\t        query = f\"\"\"\n\t        INSERT INTO hunters.game_data_by_player_id \n\t        ({\", \".join(keys_to_update)}) VALUES ({\", \".join([\"?\" for _ in values_to_update])})\n\t        \"\"\"\n\t        query = self.session.prepare(query)\n\t        self.session.execute(query, values_to_update)\n\t    def delete_stats(self, stats: Stats):\n\t        query = f\"\"\"\n", "        DELETE FROM hunters.player_stats_by_player_id WHERE player_id = {stats.player_id}\n\t        \"\"\"\n\t        res = self.session.execute(query)\n\t    def get_leaderboard(self, limit: int):\n\t        query = f\"\"\"\n\t        SELECT * FROM hunters.player_stats_by_player_id\n\t        \"\"\"\n\t        result_set = self.session.execute(query)\n\t        # This is stupid, but it doesn't work any other way\n\t        column_names = result_set.column_names\n", "        Row = namedtuple('Row', column_names)\n\t        leaderboard_data = []\n\t        for row in result_set:\n\t            row_data = Row(*row)\n\t            leaderboard_data.append(row_data._asdict())\n\t        leaderboard_data = sorted(leaderboard_data, key=lambda x: x[\"power\"], reverse=True)\n\t        if limit is not None:\n\t            leaderboard_data = leaderboard_data[:limit]\n\t        return leaderboard_data\n\t    def get_average_resources(self, player_id: int):\n", "        query = f\"\"\"\n\t        SELECT * FROM hunters.average_growth_by_player_id WHERE player_id = {player_id}\n\t        \"\"\"\n\t        res = self.session.execute(query)\n\t        json = []\n\t        for row in res:\n\t            result = {}\n\t            for column in row._fields:\n\t                result[column] = getattr(row, column)\n\t            json.append(result)\n", "            break\n\t        return json[0] if len(json) > 0 else {}\n"]}
{"filename": "app/game_data_service/repository/game_data_repository.py", "chunked_list": ["from common.game_data.resources import Resources\n\tfrom common.game_data.stats import Stats\n\tclass GameDataRepository:\n\t    def __init__(self) -> None:\n\t        pass\n\t    def get_stats(self, player_id: int):\n\t        pass\n\t    def get_resources(self, player_id: int):\n\t        pass\n\t    def set_stats(self, player_id: int, stats: Stats):\n", "        pass\n\t    def set_resources(self, player_id: int, resources: Resources):\n\t        pass\n\t    def delete_stats(self, stats: Stats):\n\t        pass\n\t    def get_leaderboard(self, limit: int):\n\t        pass\n\t    def get_average_resources(self, player_id: int):\n\t        pass"]}
{"filename": "app/game_data_service/service/game_data_service.py", "chunked_list": ["from aiokafka import AIOKafkaConsumer\n\timport asyncio\n\timport os\n\timport consul\n\timport socket\n\tfrom repository.game_data_repository import GameDataRepository\n\tfrom repository.cassandra_repository import CassandraRepository\n\tfrom common.game_data.resources import Resources\n\tfrom common.game_data.stats import Stats\n\tclass GameDataService:\n", "    def __init__(self, repo: GameDataRepository) -> None:\n\t        self.repo = repo\n\t        kafka_address = os.getenv(\"KAFKA_ADDRESS\", \"localhost:29092\")\n\t        self.consul_service = consul.Consul(host=\"consul\")\n\t        hostname = socket.gethostname()\n\t        self.id = os.environ[\"SERVICE_ID\"]\n\t        check = consul.Check.http(f\"http://{hostname}:8000/health\", \"10s\", \"2s\", \"20s\")\n\t        self.name = \"game-data\"\n\t        self.consul_service.agent.service.register(self.name, service_id=self.name + self.id, address=hostname,\n\t                                                   port=8000, check=check)\n", "        self.event_loop = asyncio.get_event_loop()\n\t        self.data_consumer = AIOKafkaConsumer(\"game-data\", loop=self.event_loop, bootstrap_servers=kafka_address, group_id=\"game_data_consumer\", auto_offset_reset=\"earliest\", enable_auto_commit=True)\n\t        self.stats_consumer = AIOKafkaConsumer(\"game-stats\", loop=self.event_loop, bootstrap_servers=kafka_address, group_id=\"game_data_consumer\", auto_offset_reset=\"earliest\", enable_auto_commit=True)\n\t    def new_service_with_cassandra():\n\t        return GameDataService(CassandraRepository())\n\t    def get_stats(self, player_id: int) -> Stats:\n\t        stats = self.repo.get_stats(player_id)\n\t        return Stats.parse_obj(stats)\n\t    def get_resources(self, player_id: int) -> Resources:\n\t        resources = self.repo.get_resources(player_id)\n", "        return Resources.parse_obj(resources)\n\t    def set_stats(self, player_id: int, stats: Stats):\n\t        old_stats = self.get_stats(stats.player_id)\n\t        if stats.power is not None and old_stats.power is not None and old_stats.power != stats.power:\n\t            for field_name, field_val in vars(stats).items():\n\t                if not callable(field_val) and field_val is None:\n\t                    setattr(stats, field_name, getattr(old_stats, field_name))\n\t            self.delete_stats(old_stats)\n\t        self.repo.set_stats(stats.player_id, stats)\n\t    def set_resources(self, player_id: int, resources: Resources):\n", "        self.repo.set_resources(player_id, resources)\n\t    def delete_stats(self, stats: Stats):\n\t        self.repo.delete_stats(stats)\n\t    async def consume_data(self):\n\t        await self.data_consumer.start()\n\t        try:\n\t            async for msg in self.data_consumer:\n\t                print(f\"consumed data: {msg.value.decode('utf-8')}\")\n\t                resources = Resources.parse_raw(msg.value)\n\t                self.set_resources(resources.player_id, resources)\n", "        finally:\n\t            await self.data_consumer.stop()\n\t    async def consume_stats(self):\n\t        await self.stats_consumer.start()\n\t        try:\n\t            async for msg in self.stats_consumer:\n\t                print(f\"consumed stats: {msg.value.decode('utf-8')}\")\n\t                stats = Stats.parse_raw(msg.value)\n\t                self.set_stats(stats.player_id, stats)\n\t        finally:\n", "            await self.stats_consumer.stop()\n\t    def create_consume_stats_task(self):\n\t        self.event_loop.create_task(self.consume_stats())\n\t    def create_consume_data_task(self):\n\t        self.event_loop.create_task(self.consume_data())\n\t    async def shutdown_consumers(self):\n\t        await self.data_consumer.stop()\n\t        await self.stats_consumer.stop()\n\t    def get_leaderboard(self, limit: int):\n\t        return self.repo.get_leaderboard(limit)\n", "    def get_average_resources(self, player_id: int):\n\t        return self.repo.get_average_resources(player_id)\n"]}
{"filename": "app/game_data_service/service/__init__.py", "chunked_list": []}
{"filename": "app/SnapshotService/main.py", "chunked_list": ["import asyncio\n\timport sys\n\timport os\n\tsys.path.append(os.path.abspath(os.path.join(\n\t    os.path.dirname(__file__), '..')))  # I LOVE PYTHON\n\tfrom service.snapshot_service import SnapShotService\n\tfrom contextlib import asynccontextmanager\n\tfrom fastapi import FastAPI\n\tservice = SnapShotService()\n\t@asynccontextmanager\n", "async def lifespan(app: FastAPI):\n\t    # Startup\n\t    asyncio.get_event_loop().create_task(service.make_stat_snapshot())\n\t    asyncio.get_event_loop().create_task(service.make_resource_snapshot())\n\t    asyncio.get_event_loop().create_task(service.delete_old_stat_snapshot())\n\t    asyncio.get_event_loop().create_task(service.delete_old_resource_snapshot())\n\t    yield\n\tapp = FastAPI(lifespan=lifespan)\n\t@app.get(\"/logged_stats\")\n\tasync def logged_stats(player_id: int, last_minutes: int):\n", "    return service.get_last_N_minute_stats(player_id, last_minutes)\n\t@app.get(\"/logged_resources\")\n\tasync def logged_resources(player_id: int, last_minutes: int):\n\t    return service.get_last_N_minute_resources(player_id, last_minutes)\n\tif __name__ == \"__main__\":\n\t    import uvicorn\n\t    uvicorn.run(app, host=\"0.0.0.0\", port=9010)\n"]}
{"filename": "app/SnapshotService/repository/snapshot_service_repository.py", "chunked_list": ["import os\n\tfrom collections import namedtuple\n\tfrom cassandra.cluster import Cluster\n\tclass SnapshotServiceRepository():\n\t    def __init__(self) -> None:\n\t        cassandra_endpoint = os.getenv(\"CASSANDRA_ENDPOINT\", \"localhost\")\n\t        cassandra_port = os.getenv(\"CASSANDRA_PORT\", 9042)\n\t        self.cassandra_client = Cluster(\n\t            [cassandra_endpoint], port=cassandra_port)\n\t        self.session = self.cassandra_client.connect()\n", "    def get_last_stat_logs_player_id_range(self, player_id: int, start_time: str, end_time: str) -> dict:\n\t        query = f\"\"\"\n\t        SELECT * FROM hunters.player_stats_by_player_id_and_time_logs WHERE player_id = {player_id} AND time < '{end_time}' AND time > '{start_time}'\"\"\"\n\t        res = self.session.execute(query)\n\t        json = []\n\t        for row in res:\n\t            result = {}\n\t            for column in row._fields:\n\t                result[column] = getattr(row, column)\n\t            json.append(result)\n", "        return json\n\t    def get_last_resource_logs_player_id_range(self, player_id: int, start_time: str, end_time: str) -> dict:\n\t        query = f\"\"\"\n\t        SELECT * FROM hunters.game_data_by_player_id_and_time_logs WHERE player_id = {player_id} AND time < '{end_time}' AND time > '{start_time}'\"\"\"\n\t        res = self.session.execute(query)\n\t        json = []\n\t        for row in res:\n\t            result = {}\n\t            for column in row._fields:\n\t                result[column] = getattr(row, column)\n", "            json.append(result)\n\t        return json\n\t    # Get stats for all players\n\t    def get_all_stats(self) -> dict:\n\t        query = f\"\"\"\n\t        SELECT * FROM hunters.player_stats_by_player_id\"\"\"\n\t        res = self.session.execute(query)\n\t        json = []\n\t        for row in res:\n\t            result = {}\n", "            for column in row._fields:\n\t                result[column] = getattr(row, column)\n\t            json.append(result)\n\t        return json\n\t    # Get resources for all players\n\t    def get_all_resources(self) -> dict:\n\t        query = f\"\"\"\n\t        SELECT * FROM hunters.game_data_by_player_id\"\"\"\n\t        res = self.session.execute(query)\n\t        json = []\n", "        for row in res:\n\t            result = {}\n\t            for column in row._fields:\n\t                result[column] = getattr(row, column)\n\t            json.append(result)\n\t        return json\n\t    # Insert all data updated with time into the logs\n\t    # TODO: Make it a batch insert\n\t    def add_stat_snapshot(self, stat_list: list):\n\t        for stat_entry in stat_list:\n", "            keys_to_update = list(stat_entry.keys())\n\t            values_to_update = [stat_entry[key] for key in keys_to_update]\n\t            query = f\"\"\"\n\t            INSERT INTO hunters.player_stats_by_player_id_and_time_logs\n\t            ({\", \".join(keys_to_update)}) VALUES ({\", \".join([\"?\" for _ in values_to_update])})\n\t            \"\"\"\n\t            query = self.session.prepare(query)\n\t            self.session.execute(query, values_to_update)\n\t    # Insert all data updated with time into the logs\n\t    # TODO: Make it a batch insert\n", "    def add_resource_snapshot(self, res_list: list):\n\t        for stat_entry in res_list:\n\t            keys_to_update = list(stat_entry.keys())\n\t            values_to_update = [stat_entry[key] for key in keys_to_update]\n\t            query = f\"\"\"\n\t            INSERT INTO hunters.game_data_by_player_id_and_time_logs\n\t            ({\", \".join(keys_to_update)}) VALUES ({\", \".join([\"?\" for _ in values_to_update])})\n\t            \"\"\"\n\t            query = self.session.prepare(query)\n\t            self.session.execute(query, values_to_update)\n", "    def delete_old_stats_snapshots(self, time: str):\n\t        query = f\"\"\"\n\t        SELECT player_id FROM hunters.player_stats_by_player_id\"\"\"\n\t        res = self.session.execute(query)\n\t        for row in res:\n\t            for column in row._fields:\n\t                pid = getattr(row, column)\n\t            query = f\"\"\"\n\t            DELETE FROM hunters.player_stats_by_player_id_and_time_logs WHERE player_id = {pid} AND time < '{time}'\n\t            \"\"\"\n", "            res = self.session.execute(query)\n\t    def delete_old_resource_snapshots(self, time: str):\n\t        query = f\"\"\"\n\t        SELECT player_id FROM hunters.game_data_by_player_id\"\"\"\n\t        res = self.session.execute(query)\n\t        for row in res:\n\t            for column in row._fields:\n\t                pid = getattr(row, column)\n\t            query = f\"\"\"\n\t            DELETE FROM hunters.game_data_by_player_id_and_time_logs WHERE player_id = {pid} AND time < '{time}'\n", "            \"\"\"\n\t            res = self.session.execute(query)\n"]}
{"filename": "app/SnapshotService/service/snapshot_service.py", "chunked_list": ["import asyncio\n\timport sys\n\timport os\n\tsys.path.append(os.path.abspath(os.path.join(\n\t    os.path.dirname(__file__), '..')))  # I LOVE PYTHON\n\tfrom repository.snapshot_service_repository import SnapshotServiceRepository\n\tfrom contextlib import asynccontextmanager\n\tfrom fastapi import FastAPI\n\tfrom datetime import datetime, timedelta\n\tclass SnapShotService:\n", "    def __init__(self):\n\t        self.repo = SnapshotServiceRepository()\n\t    def get_last_N_minute_stats(self, player_id: int, N: int):\n\t        current_time = datetime.now()\n\t        end_time = current_time.strftime(\"%Y-%m-%d-%H-%M\")\n\t        time_minus_N = current_time - timedelta(minutes=N)\n\t        start_time = time_minus_N.strftime(\"%Y-%m-%d-%H-%M\")\n\t        return self.repo.get_last_stat_logs_player_id_range(player_id, start_time, end_time)\n\t    def get_last_N_minute_resources(self, player_id: int, N: int):\n\t        current_time = datetime.now()\n", "        end_time = current_time.strftime(\"%Y-%m-%d-%H-%M\")\n\t        time_minus_N = current_time - timedelta(minutes=N)\n\t        start_time = time_minus_N.strftime(\"%Y-%m-%d-%H-%M\")\n\t        return self.repo.get_last_resource_logs_player_id_range(player_id, start_time, end_time)\n\t    async def make_stat_snapshot(self):\n\t        while True:\n\t            current_time = datetime.now()\n\t            time_string = current_time.strftime(\"%Y-%m-%d-%H-%M\")\n\t            # Add your processing logic here\n\t            stats = self.repo.get_all_stats()\n", "            for stat in stats:\n\t                stat[\"time\"] = time_string\n\t            self.repo.add_stat_snapshot(stats)\n\t            print(\"Added stats snapshit at \" + time_string)\n\t            await asyncio.sleep(120)  # Sleep for 2 minutes (120 seconds)\n\t    async def make_resource_snapshot(self):\n\t        while True:\n\t            current_time = datetime.now()\n\t            time_string = current_time.strftime(\"%Y-%m-%d-%H-%M\")\n\t            # Add your processing logic here\n", "            resources = self.repo.get_all_resources()\n\t            for res in resources:\n\t                res[\"time\"] = time_string\n\t            self.repo.add_resource_snapshot(resources)\n\t            print(\"Added resource snapshit at \" + time_string)\n\t            await asyncio.sleep(120)  # Sleep for 2 minutes (120 seconds)\n\t    async def delete_old_stat_snapshot(self):\n\t        while True:\n\t            current_time = datetime.now()\n\t            time_minus_N = current_time - timedelta(minutes=120)\n", "            time = time_minus_N.strftime(\"%Y-%m-%d-%H-%M\")\n\t            self.repo.delete_old_stats_snapshots(time)\n\t            print(\"Deleted stat snapshots that are older than 120 mins\")\n\t            await asyncio.sleep(7200)  # Sleep for 2 hours (7200 seconds)\n\t    async def delete_old_resource_snapshot(self):\n\t        while True:\n\t            current_time = datetime.now()\n\t            time_minus_N = current_time - timedelta(minutes=120)\n\t            time = time_minus_N.strftime(\"%Y-%m-%d-%H-%M\")\n\t            self.repo.delete_old_resource_snapshots(time)\n", "            print(\"Deleted resource snapshots that are older than 120 mins\")\n\t            await asyncio.sleep(7200)  # Sleep for 2 hours (7200 seconds)"]}
{"filename": "app/GuildsService/__init__.py", "chunked_list": []}
{"filename": "app/GuildsService/models/guild.py", "chunked_list": ["from uuid import uuid4\n\tfrom pydantic import BaseModel, Field\n\tfrom typing import Union\n\tclass Guild(BaseModel):\n\t    name: str\n\t    description: str\n\t    num_members: int\n\t    limit_members: int\n\tclass Member(BaseModel):\n\t    gid: Union[str, None]\n", "    player_id: int\n\t    player_name: str\n\tclass GuildCreation(BaseModel):\n\t    name: str\n\t    description: str\n\t    num_members: int = 0\n\t    limit_members: int\n\t    player_id: int\n\t    player_name: str\n\tif __name__ == \"__main__\":\n", "    a = GuildCreation(name=\"name\", description=\"description\", limit_members=20, player_id=1, player_name=\"name\")\n\t    print(a)\n\t    print(Guild(**a.dict()))"]}
{"filename": "app/GuildsService/models/__init__.py", "chunked_list": []}
{"filename": "app/GuildsService/controller/guilds_controller.py", "chunked_list": ["from service.guilds_service import GuildsService\n\tfrom models.guild import Guild, Member, GuildCreation\n\tfrom fastapi import FastAPI\n\timport uvicorn\n\tclass GuildsController:\n\t    def __init__(self):\n\t        self.app = FastAPI()\n\t        self.service = GuildsService()\n\t        @self.app.get(\"/guilds\")\n\t        async def get_guilds(limit: int):\n", "            r = await self.service.get_guilds(limit)\n\t            return r\n\t        @self.app.get(\"/members\")\n\t        async def get_members(gid: str):\n\t            r = await self.service.get_members(gid)\n\t            return r\n\t        @self.app.get(\"/guild\")\n\t        async def get_guild_by_member(player_id: int):\n\t            return await self.service.get_guild_by_member(player_id)\n\t        @self.app.post(\"/guilds/new\")\n", "        async def create_guild(new_guild: GuildCreation):\n\t            gid = await self.service.create_guild(new_guild)\n\t            if gid:\n\t                member = Member(gid=gid, player_id=new_guild.player_id, player_name=new_guild.player_name)\n\t                await self.service.join_guild(member)\n\t                return member\n\t        @self.app.post(\"/guilds/members/new\")\n\t        async def join_guild(member: Member):\n\t            await self.service.join_guild(member)\n\t            return member\n", "        @self.app.delete(\"/guilds/leave\")\n\t        async def leave_guild(gid: str, player_id: int):\n\t            await self.service.leave_guild(gid, player_id)\n\t            return True\n\t        @self.app.delete(\"/guilds/delete\")\n\t        async def delete_guild(gid: str):\n\t            await self.service.delete_guild(gid)\n\t            return gid\n\tcontroller = GuildsController()\n\tif __name__ == \"__main__\":\n", "    uvicorn.run(controller.app, host=\"0.0.0.0\", port=6969)\n"]}
{"filename": "app/GuildsService/controller/__init__.py", "chunked_list": []}
{"filename": "app/GuildsService/service/guilds_service.py", "chunked_list": ["from pymongo import MongoClient\n\tfrom bson.objectid import ObjectId\n\tfrom models.guild import Guild, Member, GuildCreation\n\tfrom fastapi import HTTPException\n\tfrom typing import Union\n\tclass GuildsService:\n\t    def __init__(self):\n\t        self.client = MongoClient(\"mongodb\", 27017)\n\t        db = self.client[\"guilds\"]\n\t        self.guilds = db['guilds']\n", "        self.members = db['members']\n\t    async def get_guilds(self, limit: int):\n\t        guilds = list(self.guilds.find())[:limit]\n\t        if guilds:\n\t            for doc in guilds:\n\t                doc[\"_id\"] = str(doc[\"_id\"])\n\t        return guilds\n\t        # return {\"guilds\": guilds}\n\t    async def get_members(self, gid: str):\n\t        members = list(self.members.find({\"gid\": gid}))\n", "        if members:\n\t            for member in members:\n\t                member.pop(\"_id\", None)\n\t        return members\n\t    async def get_guild_by_member(self, player_id: int):\n\t        entry = self.members.find_one({\"player_id\": player_id})\n\t        if entry:\n\t            guild = self.guilds.find_one({\"_id\": ObjectId(entry[\"gid\"])})\n\t            guild[\"_id\"] = str(guild[\"_id\"])  # parse hex\n\t            return guild\n", "    async def create_guild(self, guild: GuildCreation):\n\t        result = self.guilds.insert_one(Guild(**guild.dict()).dict())\n\t        if result.acknowledged:\n\t            return str(result.inserted_id)\n\t    async def join_guild(self, member: Member):\n\t        # member_exists = self.members.find_one(member.dict())\n\t        # if member_exists:\n\t        #     return False\n\t        # guild = self.guilds.find_one({\"_id\": ObjectId(member.gid)})\n\t        # if not guild:\n", "        #     return False\n\t        self.members.insert_one(member.dict())\n\t        self.guilds.update_one({\"_id\": ObjectId(member.gid)}, {\"$inc\": {\"num_members\": 1}})\n\t        return True\n\t    async def leave_guild(self, gid: str, player_id: int):\n\t        self.guilds.update_one({\"_id\": ObjectId(gid)}, {\"$inc\": {\"num_members\": -1}})\n\t        self.members.delete_one({\"gid\": gid, \"player_id\": player_id})\n\t        guild = self.guilds.find_one({\"_id\": ObjectId(gid)})\n\t        # if not guild:\n\t        #     return False\n", "        if guild[\"num_members\"] == 0:\n\t            await self.delete_guild(gid)\n\t        return True\n\t    async def delete_guild(self, gid: str):\n\t        self.guilds.delete_one({\"_id\": ObjectId(gid)})\n\t        self.members.delete_many({\"gid\": gid})\n\t        return True\n"]}
{"filename": "app/GuildsService/service/__init__.py", "chunked_list": []}
{"filename": "app/common/game_data/guild.py", "chunked_list": ["from uuid import uuid4\n\tfrom pydantic import BaseModel, Field\n\tfrom typing import Union\n\tclass Guild(BaseModel):\n\t    name: str\n\t    description: str\n\t    num_members: int\n\t    limit_members: int\n\tclass Member(BaseModel):\n\t    gid: Union[str, None]\n", "    player_id: int\n\t    player_name: str\n\tclass GuildCreation(BaseModel):\n\t    name: str\n\t    description: str\n\t    num_members: int = 0\n\t    limit_members: int\n\t    player_id: int\n\t    player_name: str\n\tif __name__ == \"__main__\":\n", "    a = GuildCreation(name=\"name\", description=\"description\", limit_members=20, player_id=1, player_name=\"name\")\n\t    print(a)\n\t    print(Guild(**a.dict()))"]}
{"filename": "app/common/game_data/__init__.py", "chunked_list": []}
{"filename": "app/common/game_data/user.py", "chunked_list": ["from pydantic import BaseModel\n\tfrom typing import Union\n\timport datetime\n\tclass User(BaseModel):\n\t    username: Union[str, None] = None\n\t    password: Union[str, None] = None\n\t    uid: Union[int, None] = None\n\t    created_on: Union[datetime.datetime, None] = None\n\tclass UserValidationData(BaseModel):\n\t    uid: Union[str, None] = None\n", "    token: Union[str, None] = None\n"]}
{"filename": "app/common/game_data/stats.py", "chunked_list": ["from pydantic import BaseModel\n\tclass Stats(BaseModel):\n\t    player_id: int | None = None\n\t    token: str | None = None\n\t    player_name: str | None = None\n\t    level: int | None = None\n\t    power: int | None = None\n\t    exp: int | None = None\n\t    hunters: int | None = None\n\t    masters: int | None = None\n"]}
{"filename": "app/common/game_data/resources.py", "chunked_list": ["from pydantic import BaseModel\n\tclass Resources(BaseModel):\n\t    player_id: int | None = None\n\t    token: str | None = None\n\t    player_name: str | None = None\n\t    # Utils\n\t    monster_bone: int | None = None\n\t    leather_scraps: int | None = None\n\t    oil: int | None = None\n\t    # Armor\n", "    armor: int | None = None\n\t    mastercrafted_armor: int | None = None\n\t    # Swords\n\t    silver_sword: int | None = None\n\t    kingslayers_silver_sword: int | None = None\n\t    steel_sword: int | None = None\n\t    kingslayers_steel_sword: int | None = None\n\t    # Diamonds\n\t    diamond_dust: int | None = None\n\t    diamond: int | None = None\n", "    # Ingots\n\t    dark_steel_ingot: int | None = None\n\t    meteorite_silver_ingot: int | None = None\n\t    green_gold_ingot: int | None = None\n\t    # Potions\n\t    swallow_potion: int | None = None\n\t    # Ores\n\t    dark_steel_ore: int | None = None\n\t    meteorite_silver_ore: int | None = None\n\t    green_gold_ore: int | None = None\n", "    # Herbs\n\t    arenaria: int | None = None\n\t    nostrix: int | None = None\n\t    wolfsbane: int | None = None\n"]}
{"filename": "app/StatsProcessing/stats_processing.py", "chunked_list": ["import time\n\tfrom pyspark.sql import SparkSession\n\tfrom pyspark.sql.functions import avg, col, lag\n\tfrom pyspark.sql.window import Window\n\tspark = SparkSession.builder\\\n\t    .appName(\"CassandraTableReader\") \\\n\t    .config(\"spark.cassandra.connection.host\",\"cassandra-node-1\")\\\n\t    .config(\"spark.cassandra.connection.port\",\"9042\")\\\n\t    .getOrCreate()\n\tdef hourly_job():\n", "    df = spark.read\\\n\t    .format(\"org.apache.spark.sql.cassandra\")\\\n\t    .options(table=\"game_data_by_player_id_and_time_logs\", keyspace=\"hunters\")\\\n\t    .load()\n\t    # Calculate average growth for each column\n\t    columns = [\n\t        \"monster_bone\", \"leather_scraps\", \"oil\",\n\t        \"armor\", \"mastercrafted_armor\",\n\t        \"silver_sword\", \"kingslayers_silver_sword\",\n\t        \"steel_sword\", \"kingslayers_steel_sword\",\n", "        \"diamond_dust\", \"diamond\",\n\t        \"dark_steel_ingot\", \"meteorite_silver_ingot\", \"green_gold_ingot\",\n\t        \"swallow_potion\",\n\t        \"dark_steel_ore\", \"meteorite_silver_ore\", \"green_gold_ore\",\n\t        \"arenaria\", \"nostrix\", \"wolfsbane\"\n\t    ]\n\t    growth_df = df.withColumn(\"previous_player_id\", lag(\"player_id\").over(Window.orderBy(\"time\")))\n\t    for column in columns:\n\t        growth_column = \"growth_\" + column\n\t        growth_df = growth_df.withColumn(growth_column, col(column) - lag(col(column)).over(Window.partitionBy(\"player_id\").orderBy(\"time\")))\n", "    growth_df = growth_df.filter(growth_df.previous_player_id.isNotNull()).drop(\"previous_player_id\")\n\t    avg_growth_df = growth_df.groupBy(\"player_id\").agg(*[avg(col).alias(\"avg_\" + col) for col in growth_df.columns if col.startswith(\"growth_\")])\n\t    # Write avg_growth_df to Cassandra table, replacing old values\n\t    avg_growth_df.write\\\n\t        .format(\"org.apache.spark.sql.cassandra\")\\\n\t        .options(table=\"average_growth_by_player_id\", keyspace=\"hunters\")\\\n\t        .mode(\"overwrite\")\\\n\t        .option(\"confirm.truncate\", \"true\")\\\n\t        .save()\n\twhile True:\n", "    hourly_job()\n\t    # Sleep for 1 minute\n\t    time.sleep(60)\n\t    # # Sleep for 1 hour\n\t    # time.sleep(3600)\n\tspark.stop()"]}
{"filename": "app/tests/test_to_test.py", "chunked_list": ["import unittest\n\tdef add_numbers(a, b):\n\t    return a + b\n\tclass TestAddNumbers(unittest.TestCase):\n\t    def test_add_positive_numbers(self):\n\t        result = add_numbers(2, 3)\n\t        self.assertEqual(result, 5)\n\t    def test_add_negative_numbers(self):\n\t        result = add_numbers(-2, -3)\n\t        self.assertEqual(result, -5)\n", "    def test_add_zero(self):\n\t        result = add_numbers(0, 0)\n\t        self.assertEqual(result, 0)\n\tif __name__ == '__main__':\n\t    unittest.main()\n"]}
{"filename": "app/RegistrationLoginValidation/ValidationService/ValidationService.py", "chunked_list": ["from User import User\n\tfrom ValidationRepositoryInMemory import ValidationRepositoryInMemory\n\tfrom ValidationRepositoryHaz import ValidationRepositoryHaz\n\timport secrets\n\timport consul\n\timport os\n\timport socket\n\tclass ValidationService:\n\t    def __init__(self):\n\t        self.repository = ValidationRepositoryHaz()\n", "        self.consul_service = consul.Consul(host=\"consul\")\n\t        hostname = socket.gethostname()\n\t        self.id = os.environ[\"SERVICE_ID\"]\n\t        check = consul.Check.http(f\"http://{hostname}:8080/health\", \"10s\", \"2s\", \"20s\")\n\t        self.name = \"validation\"\n\t        self.consul_service.agent.service.register(self.name, service_id=self.name + self.id, address=hostname,\n\t                                                   port=8080, check=check)\n\t        self.repository.add_map_name(self.consul_service.kv.get('map-name')[1][\"Value\"].decode('utf-8'))\n\t    def log_user(self, uid):\n\t        token = secrets.token_hex(20)\n", "        self.repository.add_user_token(uid, token)\n\t        return token\n\t    def validate_user(self, uid, token):\n\t        stored_token = self.repository.get_user_token(uid)\n\t        return token == stored_token and stored_token != \"none\"\n"]}
{"filename": "app/RegistrationLoginValidation/ValidationService/User.py", "chunked_list": ["from pydantic import BaseModel\n\tfrom typing import Union\n\timport datetime\n\tclass User(BaseModel):\n\t    username: str\n\t    password: str\n\t    uid: Union[int, None] = None\n\t    created_on: Union[datetime.datetime, None] = None\n\tclass UidTok(BaseModel):\n\t    uid: int\n", "    token: str"]}
{"filename": "app/RegistrationLoginValidation/ValidationService/ValidationRepositoryHaz.py", "chunked_list": ["import hazelcast\n\tclass ValidationRepositoryHaz:\n\t    def __init__(self):\n\t        self.logged_users = None\n\t        self.client = hazelcast.HazelcastClient(cluster_members=[\"hazelcast1\"])\n\t    def add_user_token(self, uid, token):\n\t        self.logged_users.lock(uid)\n\t        self.logged_users.put(uid, token).result()\n\t        self.logged_users.unlock(uid)\n\t    def add_map_name(self, map_name: str):\n", "        self.logged_users = self.client.get_map(map_name)\n\t    def get_user_token(self, uid):\n\t        return self.logged_users.get(uid).result() if self.logged_users.contains_key(uid).result() else \"none\"\n"]}
{"filename": "app/RegistrationLoginValidation/ValidationService/ValidationController.py", "chunked_list": ["from fastapi import FastAPI\n\timport uvicorn\n\tfrom User import UidTok\n\tfrom ValidationService import ValidationService\n\tfrom pydantic import BaseModel\n\tclass LoginController:\n\t    def __init__(self):\n\t        self.app = FastAPI()\n\t        self.service = ValidationService()\n\t        @self.app.post(\"/log/{uid}\")\n", "        def post_user(uid: int):\n\t            token = self.service.log_user(uid)\n\t            return token\n\t        @self.app.post(\"/validate\")\n\t        def validate_user(user: UidTok) -> bool:\n\t            res = self.service.validate_user(user.uid, user.token)\n\t            return res\n\t        @self.app.get(\"/health\")\n\t        def health_check():\n\t            return True\n", "controller = LoginController()\n\tif __name__ == \"__main__\":\n\t    uvicorn.run(controller.app, port=8080, host=\"0.0.0.0\")\n"]}
{"filename": "app/RegistrationLoginValidation/ValidationService/ValidationRepositoryInMemory.py", "chunked_list": ["class ValidationRepositoryInMemory:\n\t    def __init__(self):\n\t        self.logged_users = dict()\n\t    def add_user_token(self, uid, token):\n\t        self.logged_users[uid] = token\n\t    def get_user_token(self, uid):\n\t        return self.logged_users[uid] if uid in self.logged_users.keys() else \"none\"\n"]}
{"filename": "app/RegistrationLoginValidation/LoginService/LoginController.py", "chunked_list": ["from fastapi import FastAPI\n\timport uvicorn\n\tfrom User import User\n\tfrom LoginService import LoginService\n\tfrom fastapi import FastAPI, HTTPException\n\tclass LoginController:\n\t    def __init__(self):\n\t        self.app = FastAPI()\n\t        self.service = LoginService()\n\t        @self.app.post(\"/login/user/\")\n", "        def login_user(user: User):\n\t            logged_user = self.service.try_login_user(user)\n\t            return logged_user\n\tcontroller = LoginController()\n\tif __name__ == \"__main__\":\n\t    uvicorn.run(controller.app, port=8080, host=\"0.0.0.0\")\n"]}
{"filename": "app/RegistrationLoginValidation/LoginService/LoginService.py", "chunked_list": ["from User import User, UidTok\n\tfrom LoginRepositoryPostgress import LoginRepositoryPostgress\n\tfrom fastapi import HTTPException\n\timport requests\n\timport random\n\timport consul\n\tclass LoginService:\n\t    def __init__(self):\n\t        self.repository = LoginRepositoryPostgress()\n\t        self.consul_service = consul.Consul(host=\"consul\")\n", "    def try_login_user(self, user: User) -> UidTok:\n\t        uid = self.repository.get_user_uid(user)\n\t        if uid is not None:\n\t            uid = uid[0]\n\t            print(f\"user exists, uid {uid}\")\n\t            url, port = self.get_address(\"validation\")\n\t            response = requests.post(url=f\"http://{url}:{port}/log/\" + str(uid))\n\t            token = response.text\n\t            print(token)\n\t            return UidTok(uid=uid, token=token)\n", "        else:\n\t            print(\"incorrect credentials\")\n\t            raise HTTPException(status_code=401, detail=\"Invalid Credentials\")\n\t    def get_address(self, service_name):\n\t        consul_info = self.consul_service.health.service(service_name)[1]\n\t        address = random.choice(consul_info)[\"Service\"][\"Address\"]\n\t        port = random.choice(consul_info)[\"Service\"][\"Port\"]\n\t        return address, port\n"]}
{"filename": "app/RegistrationLoginValidation/LoginService/User.py", "chunked_list": ["from pydantic import BaseModel\n\tfrom typing import Union\n\timport datetime\n\tclass User(BaseModel):\n\t    username: str\n\t    password: str\n\t    uid: Union[int, None] = None\n\t    created_on: Union[datetime.datetime, None] = None\n\tclass UidTok(BaseModel):\n\t    uid: int\n", "    token: str"]}
{"filename": "app/RegistrationLoginValidation/LoginService/LoginRepositoryPostgress.py", "chunked_list": ["from User import User\n\timport psycopg2\n\tclass LoginRepositoryPostgress:\n\t    def __init__(self):\n\t        self.conn = psycopg2.connect(database=\"users\",\n\t                                     host=\"postgresql\",\n\t                                     user=\"admin\",\n\t                                     password=\"admin\",\n\t                                     port=\"5432\")\n\t        self.cursor = self.conn.cursor()\n", "        print(\"connected\")\n\t    def get_user_uid(self, user: User):\n\t        self.cursor.execute(f\"SELECT * FROM users WHERE username='{user.username}' AND password='{user.password}'\")\n\t        res = self.cursor.fetchone()\n\t        return res\n"]}
{"filename": "app/RegistrationLoginValidation/RegisterService/User.py", "chunked_list": ["from pydantic import BaseModel\n\tfrom typing import Union\n\timport datetime\n\tclass User(BaseModel):\n\t    username: str\n\t    password: str\n\t    uid: Union[int, None] = None\n\t    created_on: Union[datetime.datetime, None] = None\n\tclass UidTok(BaseModel):\n\t    uid: int\n", "    token: str"]}
{"filename": "app/RegistrationLoginValidation/RegisterService/RegisterService.py", "chunked_list": ["from User import User, UidTok\n\tfrom RegisterRepositoryPostgress import RegisterRepositoryPostgress\n\timport requests\n\tfrom fastapi import HTTPException\n\timport random\n\timport consul\n\tclass RegisterService:\n\t    def __init__(self):\n\t        self.repository = RegisterRepositoryPostgress()\n\t        self.consul_service = consul.Consul(host=\"consul\")\n", "    def get_user(self, uid: int) -> User:\n\t        result = self.repository.get_user(uid)\n\t        print(result)\n\t        user = User(uid=result[0], username=result[1], password=result[2], created_on=result[3])\n\t        return user\n\t    def add_user(self, user: User) -> UidTok:\n\t        res = self.repository.register_user(user)\n\t        uid = res[0]\n\t        url, port = self.get_address(\"validation\")\n\t        response = requests.post(url=f\"http://{url}:{port}/log/\" + str(uid))\n", "        if response.status_code != 200:\n\t            raise HTTPException(status_code=response.status_code, detail=response.text)\n\t        token = response.text\n\t        print(f\"{uid}: {token}\")\n\t        return UidTok(uid=uid, token=token)\n\t    def delete_user(self, uid):\n\t        pass\n\t    def get_address(self, service_name):\n\t        consul_info = self.consul_service.health.service(service_name)[1]\n\t        address = random.choice(consul_info)[\"Service\"][\"Address\"]\n", "        port = random.choice(consul_info)[\"Service\"][\"Port\"]\n\t        return address, port\n"]}
{"filename": "app/RegistrationLoginValidation/RegisterService/RegisterRepositoryPostgress.py", "chunked_list": ["from User import User\n\timport psycopg2\n\tfrom fastapi import HTTPException\n\tclass RegisterRepositoryPostgress:\n\t    def __init__(self):\n\t        self.conn = psycopg2.connect(database=\"users\",\n\t                                     host=\"postgresql\",\n\t                                     user=\"admin\",\n\t                                     password=\"admin\",\n\t                                     port=\"5432\")\n", "        self.cursor = self.conn.cursor()\n\t        print(\"connected\")\n\t    def register_user(self, user: User):\n\t        self.cursor.execute(f\"SELECT exists (SELECT 1 FROM users WHERE username='{user.username}')\")\n\t        if self.cursor.fetchone()[0]:\n\t            raise HTTPException(status_code=409, detail=\"user already exists\")\n\t        self.cursor.execute(\n\t            f\"INSERT INTO users(username, password, created_on) VALUES ('{user.username}', '{str(user.password)}',\\\n\t             current_timestamp) RETURNING uid\")\n\t        self.conn.commit()\n", "        return self.cursor.fetchone()\n\t    def del_user(self, uid):\n\t        pass\n\t    def get_user(self, uid):\n\t        self.cursor.execute(f\"SELECT * FROM users WHERE uid={uid}\")\n\t        self.conn.commit()\n\t        return self.cursor.fetchone()\n"]}
{"filename": "app/RegistrationLoginValidation/RegisterService/RegisterController.py", "chunked_list": ["from fastapi import FastAPI\n\timport uvicorn\n\tfrom User import User, UidTok\n\tfrom RegisterService import RegisterService\n\tclass RegisterController:\n\t    def __init__(self):\n\t        self.app = FastAPI()\n\t        self.service = RegisterService()\n\t        @self.app.get(\"/user/{uid}\")\n\t        def get_user(uid: int) -> User:\n", "            user = self.service.get_user(uid)\n\t            return user\n\t        @self.app.post(\"/user\")\n\t        def post_user(user: User) -> UidTok:\n\t            uid_tok = self.service.add_user(user)\n\t            return uid_tok\n\tcontroller = RegisterController()\n\tif __name__ == \"__main__\":\n\t    uvicorn.run(controller.app, port=8080, host=\"0.0.0.0\")\n"]}
