{"filename": "tests/test_query.py", "chunked_list": ["import pytest\n\tfrom tests.conftest import FirstEntity, SecondEntity\n\tfrom xtdb.query import InvalidField, Query\n\tdef test_basic_field_where_clause():\n\t    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n\t    assert (\n\t        query.format()\n\t        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n\t    [ FirstEntity :FirstEntity/name \"test\" ]\n\t    [ FirstEntity :type \"FirstEntity\" ]]}}\"\"\"\n", "    )\n\t    query = query.limit(4)\n\t    assert (\n\t        query.format()\n\t        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n\t    [ FirstEntity :FirstEntity/name \"test\" ]\n\t    [ FirstEntity :type \"FirstEntity\" ]] :limit 4}}\"\"\"\n\t    )\n\t    query = query.offset(0)\n\t    assert (\n", "        query.format()\n\t        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n\t    [ FirstEntity :FirstEntity/name \"test\" ]\n\t    [ FirstEntity :type \"FirstEntity\" ]] :limit 4 :offset 0}}\"\"\"\n\t    )\n\t    query = query.timeout(40)\n\t    assert (\n\t        query.format()\n\t        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n\t    [ FirstEntity :FirstEntity/name \"test\" ]\n", "    [ FirstEntity :type \"FirstEntity\" ]] :limit 4 :offset 0 :timeout 40}}\"\"\"\n\t    )\n\t    query = query.order_by([(\"FirstEntity/name\", \"asc\")])\n\t    assert (\n\t        query.format()\n\t        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n\t    [ FirstEntity :FirstEntity/name \"test\" ]\n\t    [ FirstEntity :type \"FirstEntity\" ]] :order-by [[FirstEntity/name :asc]] :limit 4 :offset 0 :timeout 40}}\"\"\"\n\t    )\n\tdef test_reference_field_where_clause():\n", "    query = Query(FirstEntity).where(SecondEntity, first_entity=FirstEntity)\n\t    assert (\n\t        query.format()\n\t        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n\t    [ FirstEntity :type \"FirstEntity\" ]\n\t    [ SecondEntity :SecondEntity/first_entity FirstEntity ]]}}\"\"\"\n\t    )\n\tdef test_remove_duplicates():\n\t    query = Query(FirstEntity).where(SecondEntity, first_entity=FirstEntity)\n\t    assert query == query.where(SecondEntity, first_entity=FirstEntity)\n", "def test_invalid_fields_name():\n\t    with pytest.raises(InvalidField) as ctx:\n\t        Query(FirstEntity).where(FirstEntity, wrong=FirstEntity)\n\t    assert ctx.exconly() == 'xtdb.exceptions.InvalidField: \"wrong\" is not a field of FirstEntity'\n\t    with pytest.raises(InvalidField) as ctx:\n\t        Query(FirstEntity).where(FirstEntity, abc=\"def\")\n\t    assert ctx.exconly() == 'xtdb.exceptions.InvalidField: \"abc\" is not a field of FirstEntity'\n\tdef test_escaping_quotes():\n\t    query = Query(FirstEntity).where(SecondEntity, first_entity=FirstEntity).where(FirstEntity, name='test \" name')\n\t    assert (\n", "        query.format()\n\t        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n\t    [ FirstEntity :FirstEntity/name \"test \\\\\" name\" ]\n\t    [ FirstEntity :type \"FirstEntity\" ]\n\t    [ SecondEntity :SecondEntity/first_entity FirstEntity ]]}}\"\"\"\n\t    )\n\tdef test_invalid_field_types():\n\t    with pytest.raises(InvalidField) as ctx:\n\t        Query(FirstEntity).where(SecondEntity, test=InvalidField)\n\t    assert ctx.exconly() == 'xtdb.exceptions.InvalidField: \"test\" is not a field of SecondEntity'\n", "    with pytest.raises(InvalidField) as ctx:\n\t        Query(FirstEntity).where(FirstEntity, name=FirstEntity)\n\t    assert ctx.exconly() == 'xtdb.exceptions.InvalidField: \"name\" is not a relation of FirstEntity'\n\tdef test_allow_string_for_foreign_keys():\n\t    query = Query(FirstEntity).where(SecondEntity, first_entity=\"FirstEntity|internet\")\n\t    assert (\n\t        query.format()\n\t        == \"\"\"{:query {:find [(pull FirstEntity [*])] :where [\n\t    [ FirstEntity :type \"FirstEntity\" ]\n\t    [ SecondEntity :SecondEntity/first_entity \"FirstEntity|internet\" ]]}}\"\"\"\n", "    )\n"]}
{"filename": "tests/test_datalog.py", "chunked_list": ["import pytest\n\tfrom xtdb.datalog import (\n\t    Expression,\n\t    Find,\n\t    In,\n\t    Limit,\n\t    NotJoin,\n\t    OrderBy,\n\t    OrJoin,\n\t    Sample,\n", "    Sum,\n\t    Timeout,\n\t    Where,\n\t    WherePredicate,\n\t    _BaseAggregate,\n\t)\n\tfrom xtdb.exceptions import XTDBException\n\tdef test_where_clauses():\n\t    statement = Where(\"a\", \"b\", \"c\")\n\t    assert statement.compile() == \":where [[ a :b c ]]\"\n", "    statement = Where(\"a\", \"b\")\n\t    assert statement.compile() == \":where [[ a :b  ]]\"\n\t    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\")\n\t    assert statement.compile() == \":where [ [ 1 :2 3 ] [ a :b c ]]\"\n\t    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"1\", \"2\", \"3\")\n\t    assert statement.compile() == \":where [ [ 1 :2 3 ] [ a :b c ]]\"\n\t    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"x\", \"y\", \"z\")\n\t    assert statement.compile() == \":where [ [ 1 :2 3 ] [ a :b c ] [ x :y z ]]\"\n\t    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"1\", \"2\", \"3\") & Where(\"a\", \"b\", \"c\")\n\t    assert statement.compile() == \":where [ [ 1 :2 3 ] [ a :b c ]]\"\n", "    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"x\", \"y\", \"z\")\n\t    assert statement.compile() == \":where [ [ 1 :2 3 ] [ a :b c ] [ x :y z ]]\"\n\t    assert str(statement) == statement.compile()\n\tdef test_or_clauses():\n\t    statement = Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\")\n\t    assert statement.compile() == \":where [(or [ 1 :2 3 ] [ a :b c ])]\"\n\t    statement = Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\") | Where(\"1\", \"2\", \"3\")\n\t    assert statement.compile() == \":where [(or [ 1 :2 3 ] [ a :b c ])]\"\n\tdef test_not_clauses():\n\t    statement = ~Where(\"a\", \"b\", \"c\")\n", "    assert statement.compile() == \":where [(not [ a :b c ])]\"\n\t    statement = ~(Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\"))\n\t    assert statement.compile() == \":where [(not [ 1 :2 3 ] [ a :b c ])]\"\n\t    statement = ~(Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") & Where(\"x\", \"y\"))\n\t    assert statement.compile() == \":where [(not [ 1 :2 3 ] [ a :b c ] [ x :y  ])]\"\n\tdef test_where_or_clauses():\n\t    statement = Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") | Where(\"x\", \"y\", \"z\") & Where(\"9\", \"8\", \"7\")\n\t    assert statement.compile() == \":where [(or (and [ 1 :2 3 ] [ a :b c ]) (and [ 9 :8 7 ] [ x :y z ]))]\"\n\t    statement = Where(\"a\", \"b\", \"c\") & (Where(\"1\", \"2\", \"3\") | Where(\"x\", \"y\", \"z\"))\n\t    assert statement.compile() == \":where [ (or [ 1 :2 3 ] [ x :y z ]) [ a :b c ]]\"\n", "    # The & operator takes precedence over the | operator\n\t    statement = (Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\")) & Where(\"x\", \"y\", \"z\")\n\t    assert statement.compile() == \":where [ (or [ 1 :2 3 ] [ a :b c ]) [ x :y z ]]\"\n\t    statement = (Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\")) & (Where(\"x\", \"y\", \"z\") | Where(\"9\", \"8\", \"7\"))\n\t    assert statement.compile() == \":where [ (or [ 1 :2 3 ] [ a :b c ]) (or [ 9 :8 7 ] [ x :y z ])]\"\n\t    with pytest.raises(XTDBException):\n\t        Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\") | Where(\"x\", \"y\", \"z\")\n\t    with pytest.raises(XTDBException):\n\t        Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\") & Where(\"x\", \"y\", \"z\")\n\tdef test_find_clauses():\n", "    statement = Find(\"a\")\n\t    assert statement.compile() == \":find [a]\"\n\t    statement = Find(\"a\") & Find(\"b\")\n\t    assert statement.compile() == \":find [ a b]\"\n\t    statement = Find(\"pull(*)\") & Find(\"b\") & Find(Expression(\"(sum ?heads)\"))\n\t    assert statement.compile() == \":find [ pull(*) b (sum ?heads)]\"\n\t    with pytest.raises(XTDBException) as ctx:\n\t        Find(\"pull(*)\") | Find(\"b\")\n\t    assert ctx.exconly() == \"xtdb.exceptions.XTDBException: Cannot use | on query keys\"\n\tdef test_aggregates():\n", "    statement = Find(\"a\") & Find(_BaseAggregate(\"sum\", \"field\"))\n\t    assert statement.compile() == \":find [ a (sum field)]\"\n\t    statement = Find(\"a\") & Find(_BaseAggregate(\"sample\", \"field\", \"12\"))\n\t    assert statement.compile() == \":find [ a (sample 12 field)]\"\n\t    with pytest.raises(XTDBException) as ctx:\n\t        Find(\"a\") & Find(_BaseAggregate(\"wrong\", \"field\"))\n\t    assert ctx.exconly() == \"xtdb.exceptions.XTDBException: Invalid aggregate function\"\n\t    with pytest.raises(XTDBException) as ctx:\n\t        Find(\"a\") & Find(_BaseAggregate(\"rand\", \"field\"))\n\t    assert ctx.exconly() == \"xtdb.exceptions.XTDBException: Invalid arguments to aggregate, it needs one argument: N\"\n", "def test_concrete_aggregates():\n\t    statement = Find(\"a\") & Sum(\"field\")\n\t    assert statement.compile() == \":find [ a (sum field)]\"\n\t    statement = Find(\"a\") & Sum(\"field\") & Sum(\"field\")\n\t    assert statement.compile() == \":find [ a (sum field) (sum field)]\"\n\t    statement = Find(\"a\") & Sample(\"field\", 12)\n\t    assert statement.compile() == \":find [ a (sample 12 field)]\"\n\t    with pytest.raises(XTDBException):\n\t        Sample(\"field\", 12) | Sum(\"field\")\n\tdef test_find_where():\n", "    statement = Find(\"a\") & Where(\"a\", \"b\", \"c\")\n\t    assert statement.compile() == \"{:query {:find [a] :where [[ a :b c ]]}}\"\n\t    statement = Find(\"a\") & (Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\"))\n\t    assert statement.compile() == \"{:query {:find [a] :where [ [ 1 :2 3 ] [ a :b c ]]}}\"\n\t    statement = Find(\"a\") & (Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\"))\n\t    assert statement.compile() == \"{:query {:find [a] :where [(or [ 1 :2 3 ] [ a :b c ])]}}\"\n\t    statement = Find(\"a\") & Find(\"b\") & (Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\"))\n\t    assert statement.compile() == \"{:query {:find [ a b] :where [(or [ 1 :2 3 ] [ a :b c ])]}}\"\n\t    statement = (\n\t        Find(\"a\")\n", "        & Sample(\"field\", 12)\n\t        & Sum(\"field\")\n\t        & ((Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\")) & Where(\"x\", \"y\", \"z\"))\n\t    )\n\t    assert (\n\t        statement.compile()\n\t        == \"{:query {:find [ a (sample 12 field) (sum field)] :where [ (or [ 1 :2 3 ] [ a :b c ]) [ x :y z ]]}}\"\n\t    )\n\t    statement = Sum(\"a\") & Where(\"a\", \"b\", \"c\")\n\t    assert statement.compile() == \"{:query {:find [(sum a)] :where [[ a :b c ]]}}\"\n", "    statement = Sum(\"a\") & Sum(\"b\") & Where(\"a\", \"b\", \"c\")\n\t    assert statement.compile() == \"{:query {:find [ (sum a) (sum b)] :where [[ a :b c ]]}}\"\n\tdef test_find_where_not():\n\t    statement = Sum(\"a\") & Sum(\"b\") & ~(Where(\"a\", \"b\", \"c\") & Where(\"x\", \"y\", \"z\"))\n\t    assert statement.compile() == \"{:query {:find [ (sum a) (sum b)] :where [(not [ a :b c ] [ x :y z ])]}}\"\n\tdef test_find_where_in_complete():\n\t    statement = Find(\"a\") & Where(\"a\", \"b\", \"c\") & Limit(2) & Timeout(29) & OrderBy([(\"b\", \"asc\")]) & In(\"c\", \"d\")\n\t    # Scalar binding\n\t    assert (\n\t        statement.compile()\n", "        == '{:query {:find [a] :where [[ a :b c ]] :in [c] :order-by [[b :asc]] :limit 2 :timeout 29} :in-args [\"d\"]}'\n\t    )\n\t    # Collection binding\n\t    statement = Find(\"a\") & Where(\"a\", \"b\", \"c\") & Limit(2) & OrderBy([(\"b\", \"asc\")]) & In([\"c\", \"...\"], [\"d\", \"e\"])\n\t    assert (\n\t        statement.compile()\n\t        == '{:query {:find [a] :where [[ a :b c ]] :in [[c ...]] :order-by [[b :asc]] :limit 2} :in-args [[\"d\" \"e\"]]}'\n\t    )\n\t    # Tuple binding\n\t    statement = Find(\"a\") & Where(\"a\", \"b\", \"c\") & Limit(2) & OrderBy([(\"b\", \"asc\")]) & In([\"c\", \"z\"], [\"d\", \"e\"])\n", "    assert (\n\t        statement.compile()\n\t        == '{:query {:find [a] :where [[ a :b c ]] :in [[c z]] :order-by [[b :asc]] :limit 2} :in-args [[\"d\" \"e\"]]}'\n\t    )\n\t    # Relation binding\n\t    statement = Find(\"a\") & Where(\"a\", \"b\", \"c\") & Limit(2) & In([[\"c\", \"z\"]], [[\"d\", \"e\"], [\"f\", \"g\"]])\n\t    assert (\n\t        statement.compile()\n\t        == '{:query {:find [a] :where [[ a :b c ]] :in [[[c z]]] :limit 2} :in-args [[[\"d\" \"e\"] [\"f\" \"g\"]]]}'\n\t    )\n", "def test_find_where_wrong_order():\n\t    with pytest.raises(XTDBException):\n\t        Find(\"a\") & Where(\"a\", \"b\", \"c\") & Where(\"1\", \"2\", \"3\")\n\t    with pytest.raises(XTDBException):\n\t        Where(\"a\", \"b\", \"c\") & Find(\"a\")\n\t    with pytest.raises(XTDBException):\n\t        (Where(\"a\", \"b\", \"c\") | Where(\"1\", \"2\", \"3\")) & Find(\"a\")\n\tdef test_in():\n\t    statement = In([\"field\", \"other-field\"], [\"value\", \"other-value\"])\n\t    assert statement.compile() == \" :in [[field other-field]]\"\n", "    assert statement.compile_values() == ' :in-args [[\"value\" \"other-value\"]]'\n\t    statement = In([\"field\", \"...\"], [\"value\", \"other-value\"])\n\t    assert statement.compile() == \" :in [[field ...]]\"\n\t    assert statement.compile_values() == ' :in-args [[\"value\" \"other-value\"]]'\n\tdef test_order_by():\n\t    statement = OrderBy([(\"field_name\", \"asc\"), (\"test-name\", \"desc\")])\n\t    assert statement.compile() == \" :order-by [[field_name :asc] [test-name :desc]]\"\n\t    with pytest.raises(XTDBException):\n\t        OrderBy([(\"field_name\", \"asc\"), (\"test-name\", \"esc\")])\n\tdef test_where_predicate():\n", "    statement = WherePredicate(\"odd?\", \"b\")\n\t    assert statement.compile() == \":where [[ (odd? b) ]]\"\n\t    statement = WherePredicate(\"+\", \"1\", \"2\", \"b\")\n\t    assert statement.compile() == \":where [[ (+ 1 2 b) ]]\"\n\t    # From the docs\n\t    statement = WherePredicate(\"identity\", \"2\", bind=\"x\") & WherePredicate(\"+\", \"x\", \"2\", bind=\"y\")\n\t    assert statement.compile() == \":where [ [ (+ x 2) y] [ (identity 2) x]]\"\n\t    statement = Find(\"a\") & (Where(\"a\", \"b\", \"c\") & WherePredicate(\"odd?\", \"c\"))\n\t    assert statement.compile() == \"{:query {:find [a] :where [ [ (odd? c) ] [ a :b c ]]}}\"\n\tdef test_range_predicate():\n", "    # From the docs\n\t    statement = WherePredicate(\">\", 18, \"a\")\n\t    assert statement.compile() == \":where [[ (> 18 a) ]]\"\n\tdef test_unification_predicate():\n\t    # From the docs\n\t    statement = WherePredicate(\"==\", \"a\", \"a2\")\n\t    assert statement.compile() == \":where [[ (== a a2) ]]\"\n\t    # From the docs\n\t    statement = WherePredicate(\"!=\", \"a\", \"a2\")\n\t    assert statement.compile() == \":where [[ (!= a a2) ]]\"\n", "def test_not_join():\n\t    # From the docs\n\t    statement = Where(\"e\", \"xt/id\") & (NotJoin(\"e\") & Where(\"e\", \"last-name\", \"n\"))\n\t    assert statement.compile() == \":where [ (not-join [e] [ e :last-name n ]) [ e :xt/id  ]]\"\n\t    statement = Where(\"e\", \"xt/id\") & (NotJoin(\"e\") & (Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\")))\n\t    assert statement.compile() == \":where [ (not-join [e]  [ e :last-name n ] [ e :name n ]) [ e :xt/id  ]]\"\n\t    statement = Where(\"e\", \"xt/id\") & (NotJoin(\"e\") & Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\"))\n\t    assert statement.compile() == \":where [ (not-join [e] [ e :last-name n ] [ e :name n ]) [ e :xt/id  ]]\"\n\t    statement = Where(\"e\", \"xt/id\") & NotJoin(\"e\") & Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\")\n\t    assert statement.compile() == \":where [ (not-join [e] ) [ e :last-name n ] [ e :name n ] [ e :xt/id  ]]\"\n", "def test_or_join():\n\t    statement = Where(\"e\", \"xt/id\") & (OrJoin(\"e\") & Where(\"e\", \"last-name\", \"n\"))\n\t    assert statement.compile() == \":where [ (or-join [e] [ e :last-name n ]) [ e :xt/id  ]]\"\n\t    statement = Where(\"e\", \"xt/id\") & (OrJoin(\"e\") & (Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\")))\n\t    assert statement.compile() == \":where [ (or-join [e]  [ e :last-name n ] [ e :name n ]) [ e :xt/id  ]]\"\n\t    statement = Where(\"e\", \"xt/id\") & (OrJoin(\"e\") & Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\"))\n\t    assert statement.compile() == \":where [ (or-join [e] [ e :last-name n ] [ e :name n ]) [ e :xt/id  ]]\"\n\t    statement = Where(\"e\", \"xt/id\") & OrJoin(\"e\") & Where(\"e\", \"last-name\", \"n\") & Where(\"e\", \"name\", \"n\")\n\t    assert statement.compile() == \":where [ (or-join [e] ) [ e :last-name n ] [ e :name n ] [ e :xt/id  ]]\"\n"]}
{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/test_orm.py", "chunked_list": ["from tests.conftest import FirstEntity, SecondEntity\n\tdef test_proper_dict_format():\n\t    entity = FirstEntity(name=\"test\")\n\t    d = entity.dict()\n\t    assert d == {\n\t        \"xt/id\": entity.id,\n\t        \"type\": \"FirstEntity\",\n\t        \"FirstEntity/name\": \"test\",\n\t    }\n\t    assert FirstEntity.from_dict(d).name == entity.name\n", "    entity2 = SecondEntity(first_entity=entity, age=12)\n\t    d2 = entity2.dict()\n\t    assert d2 == {\n\t        \"xt/id\": entity2.id,\n\t        \"type\": \"SecondEntity\",\n\t        \"SecondEntity/first_entity\": entity.id,\n\t        \"SecondEntity/age\": 12,\n\t    }\n\t    assert SecondEntity.from_dict(d2).age == entity2.age\n\t    assert SecondEntity.from_dict(d2).first_entity == entity2.first_entity.id\n"]}
{"filename": "tests/test_transaction.py", "chunked_list": ["import json\n\tfrom xtdb.session import Operation, OperationType, Transaction\n\tdef test_transaction_json(valid_time):\n\t    transaction = Transaction()\n\t    transaction.add(Operation(type=OperationType.MATCH, value={\"xt/id\": \"value\"}, valid_time=valid_time))\n\t    transaction.add(Operation(type=OperationType.DELETE, value=\"value\", valid_time=valid_time))\n\t    transaction.add(Operation(type=OperationType.PUT, value={\"xt/id\": \"value\"}, valid_time=valid_time))\n\t    transaction.add(Operation(type=OperationType.EVICT, value=\"value\", valid_time=valid_time))\n\t    assert json.loads(transaction.json()) == json.loads(\n\t        f\"\"\"{{\"tx-ops\": [\n", "        [\"match\", \"value\", {{\"xt/id\": \"value\"}}, \"{valid_time.isoformat()}\"],\n\t        [\"delete\", \"value\", \"{valid_time.isoformat()}\"],\n\t        [\"put\", {{\"xt/id\": \"value\"}}, \"{valid_time.isoformat()}\"],\n\t        [\"evict\", \"value\", \"{valid_time.isoformat()}\"]\n\t]}}\"\"\"\n\t    )\n\tdef test_transaction_json_with_methods(valid_time):\n\t    transaction = Transaction()\n\t    transaction.add(Operation.match({\"xt/id\": \"value\"}, valid_time))\n\t    transaction.add(Operation.delete(\"value\", valid_time))\n", "    transaction.add(Operation.put({\"xt/id\": \"value\"}, valid_time))\n\t    transaction.add(Operation.evict(\"value\", valid_time))\n\t    assert json.loads(transaction.json()) == json.loads(\n\t        f\"\"\"{{\"tx-ops\": [\n\t        [\"match\", \"value\", {{\"xt/id\": \"value\"}}, \"{valid_time.isoformat()}\"],\n\t        [\"delete\", \"value\", \"{valid_time.isoformat()}\"],\n\t        [\"put\", {{\"xt/id\": \"value\"}}, \"{valid_time.isoformat()}\"],\n\t        [\"evict\", \"value\", \"{valid_time.isoformat()}\"]\n\t]}}\"\"\"\n\t    )\n"]}
{"filename": "tests/conftest.py", "chunked_list": ["import os\n\tfrom dataclasses import dataclass\n\tfrom datetime import datetime, timezone\n\timport pytest\n\tfrom requests.adapters import HTTPAdapter\n\tfrom urllib3 import Retry\n\tfrom xtdb.orm import Base\n\tfrom xtdb.session import XTDBSession\n\t@dataclass\n\tclass FirstEntity(Base):\n", "    name: str\n\t@dataclass\n\tclass SecondEntity(Base):\n\t    age: int\n\t    first_entity: FirstEntity\n\t@dataclass\n\tclass ThirdEntity(Base):\n\t    first_entity: FirstEntity\n\t    second_entity: SecondEntity\n\t@dataclass\n", "class FourthEntity(Base):\n\t    third_entity: ThirdEntity\n\t    value: float\n\t@pytest.fixture\n\tdef valid_time() -> datetime:\n\t    return datetime.now(timezone.utc)\n\t@pytest.fixture\n\tdef xtdb_session() -> XTDBSession:\n\t    session = XTDBSession(os.environ[\"XTDB_URI\"])\n\t    session.client._session.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=5, backoff_factor=1)))\n", "    return session\n"]}
{"filename": "tests/integration/test_xtdb_session.py", "chunked_list": ["import os\n\tfrom datetime import datetime, timedelta, timezone\n\timport pytest\n\tfrom tests.conftest import FirstEntity, FourthEntity, SecondEntity, ThirdEntity\n\tfrom xtdb.datalog import Count, Find, In, Limit, Sum, Timeout, Where\n\tfrom xtdb.exceptions import XTDBException\n\tfrom xtdb.orm import Fn\n\tfrom xtdb.query import Query, Var\n\tfrom xtdb.session import XTDBSession\n\tif os.environ.get(\"CI\") != \"1\":\n", "    pytest.skip(\"Needs XTDB container.\", allow_module_level=True)\n\t#\n\t# def test_status(xtdb_session: XTDBSession):\n\tdef test_query_no_results(xtdb_session: XTDBSession):\n\t    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n\t    result = xtdb_session.query(query)\n\t    assert result == []\n\tdef test_query_simple_filter(xtdb_session: XTDBSession):\n\t    entity = FirstEntity(name=\"test\")\n\t    xtdb_session.put(entity)\n", "    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n\t    result = xtdb_session.query(query)\n\t    assert result == []\n\t    xtdb_session.commit()\n\t    query = Query(FirstEntity).where(FirstEntity, name=\"wrong\")\n\t    result = xtdb_session.query(query)\n\t    assert result == []\n\t    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n\t    result = xtdb_session.query(query)\n\t    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n", "    result = xtdb_session.query(query, tx_time=datetime.now(timezone.utc) - timedelta(seconds=1))\n\t    assert result == []\n\t    result = xtdb_session.query(query, tx_id=-1)\n\t    assert result == []\n\t    result = xtdb_session.query(query, tx_id=0)\n\t    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\t    result = xtdb_session.query(query.timeout(200), tx_id=0)\n\t    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\t    result = xtdb_session.query(query.limit(0), tx_id=0)\n\t    assert result == []\n", "    xtdb_session.client.sync()\n\t    xtdb_session.delete(entity)\n\t    xtdb_session.commit()\n\tdef test_match(xtdb_session: XTDBSession, valid_time: datetime):\n\t    entity = FirstEntity(name=\"test\")\n\t    second_entity = FirstEntity(name=\"test2\")\n\t    xtdb_session.put(entity)\n\t    xtdb_session.put(second_entity)\n\t    xtdb_session.commit()\n\t    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n", "    result = xtdb_session.query(query)\n\t    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\t    xtdb_session.delete(entity)\n\t    xtdb_session.commit()\n\t    third_entity = FirstEntity(name=\"test3\")\n\t    xtdb_session.put(third_entity)\n\t    xtdb_session.match(entity)  # transaction will fail because `entity` is not matched\n\t    xtdb_session.commit()\n\t    query = Query(FirstEntity).where(FirstEntity, name=\"test3\")\n\t    assert xtdb_session.query(query) == []\n", "    xtdb_session.put(third_entity)\n\t    xtdb_session.match(second_entity)  # transaction will succeed because `second_entity` is matched\n\t    xtdb_session.commit()\n\t    assert xtdb_session.query(query)[0].dict() == {\n\t        \"FirstEntity/name\": \"test3\",\n\t        \"type\": \"FirstEntity\",\n\t        \"xt/id\": third_entity.id,\n\t    }\n\t    assert xtdb_session.query(query, valid_time=valid_time) == []\n\t    xtdb_session.delete(second_entity)\n", "    xtdb_session.delete(third_entity)\n\t    xtdb_session.commit()\n\tdef test_deleted_and_evicted(xtdb_session: XTDBSession, valid_time: datetime):\n\t    entity = FirstEntity(name=\"test\")\n\t    xtdb_session.put(entity, valid_time)\n\t    xtdb_session.commit()\n\t    xtdb_session.delete(entity)\n\t    xtdb_session.commit()\n\t    query = Query(FirstEntity).where(FirstEntity, name=\"test\")\n\t    result = xtdb_session.query(query)\n", "    assert result == []\n\t    result_entity = xtdb_session.query(query, valid_time=valid_time)[0].dict()\n\t    assert result_entity == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": entity.id}\n\t    xtdb_session.evict(entity)\n\t    xtdb_session.commit()\n\t    result = xtdb_session.query(query)\n\t    assert result == []\n\t    result = xtdb_session.query(query, valid_time=valid_time)\n\t    assert result == []\n\tdef test_query_not_empty_on_reference_filter_for_entity(xtdb_session: XTDBSession):\n", "    test = FirstEntity(name=\"test\")\n\t    second1 = SecondEntity(first_entity=test, age=1)\n\t    second2 = SecondEntity(first_entity=test, age=2)\n\t    xtdb_session.put(test)\n\t    xtdb_session.put(second1)\n\t    xtdb_session.put(second2)\n\t    xtdb_session.commit()\n\t    query = Query(FirstEntity).where(SecondEntity, age=1).where(SecondEntity, first_entity=FirstEntity)\n\t    result = xtdb_session.query(query)\n\t    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": test.id}\n", "    query = query.where(FirstEntity, name=\"test\")\n\t    result = xtdb_session.query(query)\n\t    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": test.id}\n\t    xtdb_session.delete(test)\n\t    xtdb_session.delete(second1)\n\t    xtdb_session.delete(second2)\n\t    xtdb_session.commit()\n\tdef test_deep_queries(xtdb_session: XTDBSession):\n\t    test = FirstEntity(name=\"test\")\n\t    second = SecondEntity(first_entity=test, age=1)\n", "    second2 = SecondEntity(first_entity=test, age=4)\n\t    third = ThirdEntity(second_entity=second2, first_entity=test)\n\t    fourth = FourthEntity(third_entity=third, value=15.3)\n\t    xtdb_session.put(test)\n\t    xtdb_session.put(second)\n\t    xtdb_session.put(second2)\n\t    xtdb_session.put(third)\n\t    xtdb_session.put(fourth)\n\t    xtdb_session.commit()\n\t    query = Query(SecondEntity)\n", "    result = xtdb_session.query(query)\n\t    assert len(result) == 2\n\t    results = [x.dict() for x in result]\n\t    assert {\n\t        \"SecondEntity/age\": 4,\n\t        \"type\": \"SecondEntity\",\n\t        \"xt/id\": second2.id,\n\t        \"SecondEntity/first_entity\": test.id,\n\t    } in results\n\t    assert {\n", "        \"SecondEntity/age\": 1,\n\t        \"type\": \"SecondEntity\",\n\t        \"xt/id\": second.id,\n\t        \"SecondEntity/first_entity\": test.id,\n\t    } in results\n\t    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).avg(Var(\"age\"))\n\t    avg_result = xtdb_session.client.query(query)\n\t    assert avg_result == [[2.5]]\n\t    query = (\n\t        Query(SecondEntity)\n", "        .where(FourthEntity, third_entity=ThirdEntity, value=15.3)\n\t        .where(ThirdEntity, second_entity=SecondEntity)\n\t    )\n\t    result = xtdb_session.query(query)\n\t    assert result[0].dict() == {\n\t        \"SecondEntity/age\": 4,\n\t        \"type\": \"SecondEntity\",\n\t        \"xt/id\": second2.id,\n\t        \"SecondEntity/first_entity\": test.id,\n\t    }\n", "    attribute_stats = xtdb_session.client.get_attribute_stats()\n\t    assert attribute_stats == {\n\t        \"FourthEntity/third_entity\": 1,\n\t        \"FourthEntity/value\": 1,\n\t        \"SecondEntity/age\": 4,\n\t        \"SecondEntity/first_entity\": 4,\n\t        \"FirstEntity/name\": 8,\n\t        \"ThirdEntity/second_entity\": 1,\n\t        \"ThirdEntity/first_entity\": 1,\n\t        \"type\": 14,\n", "        \"xt/id\": 14,\n\t    }\n\t    xtdb_session.delete(fourth)\n\t    xtdb_session.delete(third)\n\t    xtdb_session.delete(second2)\n\t    xtdb_session.delete(second)\n\t    xtdb_session.delete(test)\n\t    xtdb_session.commit()\n\tdef test_aggregates(xtdb_session: XTDBSession):\n\t    test = FirstEntity(name=\"test\")\n", "    second = SecondEntity(first_entity=test, age=1)\n\t    second2 = SecondEntity(first_entity=test, age=4)\n\t    xtdb_session.put(test)\n\t    xtdb_session.put(second)\n\t    xtdb_session.put(second2)\n\t    xtdb_session.commit()\n\t    query = Query(SecondEntity).count(SecondEntity)\n\t    with pytest.raises(XTDBException):\n\t        xtdb_session.query(query)\n\t    count_result = xtdb_session.client.query(query)\n", "    assert count_result == [[2]]\n\t    count_result = xtdb_session.client.query(query.count(SecondEntity))\n\t    assert count_result == [[2, 2]]\n\t    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).avg(Var(\"age\"))\n\t    avg_result = xtdb_session.client.query(query)\n\t    assert avg_result == [[2.5]]\n\t    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).sum(Var(\"age\"))\n\t    sum_result = xtdb_session.client.query(query)\n\t    assert sum_result == [[5]]\n\t    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).min(Var(\"age\"))\n", "    min_result = xtdb_session.client.query(query)\n\t    assert min_result == [[1]]\n\t    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).max(Var(\"age\"))\n\t    max_result = xtdb_session.client.query(query)\n\t    assert max_result == [[4]]\n\t    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).median(Var(\"age\"))\n\t    median_result = xtdb_session.client.query(query)\n\t    assert median_result == [[2.5]]\n\t    query = Query(SecondEntity).where(SecondEntity, age=Var(\"age\")).variance(Var(\"age\"))\n\t    variance_result = xtdb_session.client.query(query)\n", "    assert variance_result == [[2.25]]  # As the average is 2.5, the variance is sqrt((1 - 2.5)^2 * (4 - 2.5)^2) = 2.25\n\t    xtdb_session.delete(second2)\n\t    xtdb_session.delete(second)\n\t    xtdb_session.delete(test)\n\t    xtdb_session.commit()\n\tdef test_query_empty_on_reference_filter_for_wrong_entity(xtdb_session: XTDBSession):\n\t    test = FirstEntity(name=\"test\")\n\t    test2 = FirstEntity(name=\"test2\")\n\t    second = SecondEntity(first_entity=test2, age=12)\n\t    xtdb_session.put(test)\n", "    xtdb_session.put(test2)\n\t    xtdb_session.put(second)\n\t    xtdb_session.commit()\n\t    query = Query(FirstEntity).where(FirstEntity, name=\"test\").where(SecondEntity, age=12)  # No foreign key\n\t    result = xtdb_session.query(query)\n\t    assert result[0].dict() == {\"FirstEntity/name\": \"test\", \"type\": \"FirstEntity\", \"xt/id\": test.id}\n\t    query = query.where(SecondEntity, first_entity=FirstEntity)  # Add foreign key constraint\n\t    assert xtdb_session.query(query) == []\n\t    assert len(xtdb_session.query(Query(FirstEntity))) == 2\n\t    xtdb_session.delete(test)\n", "    xtdb_session.delete(test2)\n\t    xtdb_session.delete(second)\n\t    xtdb_session.commit()\n\tdef test_submit_and_trigger_fn(xtdb_session: XTDBSession):\n\t    test = FirstEntity(name=\"test\")\n\t    second = SecondEntity(first_entity=test, age=12)\n\t    increment_age_fn = Fn(\n\t        function=\"(fn [ctx eid] (let [db (xtdb.api/db ctx) entity (xtdb.api/entity db eid)] \"\n\t        \"[[:xtdb.api/put (update entity :SecondEntity/age inc)]]))\",\n\t        identifier=\"increment_age\",\n", "    )\n\t    xtdb_session.put(test)\n\t    xtdb_session.put(second)\n\t    xtdb_session.put(increment_age_fn)\n\t    xtdb_session.commit()\n\t    result = xtdb_session.get(second.id)\n\t    assert result[\"SecondEntity/age\"] == 12\n\t    with pytest.raises(XTDBException):\n\t        xtdb_session.get(second.id, tx_time=datetime.now(timezone.utc) - timedelta(seconds=10))\n\t    xtdb_session.fn(increment_age_fn, second.id)\n", "    xtdb_session.commit()\n\t    result = xtdb_session.get(second.id)\n\t    assert result[\"SecondEntity/age\"] == 13\n\t    xtdb_session.fn(increment_age_fn, second.id)\n\t    xtdb_session.fn(increment_age_fn, second.id)\n\t    xtdb_session.commit()\n\t    result = xtdb_session.get(second.id)\n\t    assert result[\"SecondEntity/age\"] == 15\n\t    xtdb_session.delete(test)\n\t    xtdb_session.delete(second)\n", "    xtdb_session.delete(increment_age_fn)\n\t    xtdb_session.commit()\n\tdef test_get_entity_history(xtdb_session: XTDBSession):\n\t    test = FirstEntity(name=\"test\")\n\t    xtdb_session.put(test, datetime(1000, 10, 10))\n\t    xtdb_session.commit()\n\t    test.name = \"new name\"\n\t    xtdb_session.put(test, datetime(1000, 10, 10))\n\t    xtdb_session.commit()\n\t    test.name = \"new name 2\"\n", "    xtdb_session.put(test, datetime(1000, 10, 11))\n\t    xtdb_session.commit()\n\t    result = xtdb_session.client.get_entity_history(test.id)\n\t    assert len(result) == 2\n\t    assert list(result[0].keys()) == [\"txTime\", \"txId\", \"validTime\", \"contentHash\"]\n\t    assert list(result[1].keys()) == [\"txTime\", \"txId\", \"validTime\", \"contentHash\"]\n\t    assert result[0][\"validTime\"] == \"1000-10-10T00:00:00Z\"\n\t    assert result[1][\"validTime\"] == \"1000-10-11T00:00:00Z\"\n\t    assert xtdb_session.client.get_entity_history(test.id, sort_order=\"desc\")[1] == result[0]\n\t    assert len(xtdb_session.client.get_entity_history(test.id, start_tx_id=result[1][\"txId\"])) == 1\n", "    assert len(xtdb_session.client.get_entity_history(test.id, end_tx_id=result[1][\"txId\"])) == 1\n\t    assert len(xtdb_session.client.get_entity_history(test.id, start_valid_time=datetime(1000, 10, 10, 10))) == 1\n\t    assert len(xtdb_session.client.get_entity_history(test.id, end_valid_time=datetime(1000, 10, 10, 10))) == 1\n\t    result = xtdb_session.client.get_entity_history(test.id, with_docs=True, with_corrections=True)\n\t    assert len(result) == 3\n\t    assert list(result[0].keys()) == [\"txTime\", \"txId\", \"validTime\", \"contentHash\", \"doc\"]\n\t    assert result[0][\"doc\"][\"xt/id\"] == test.id\n\t    assert result[0][\"doc\"][\"FirstEntity/name\"] == \"test\"\n\t    assert result[1][\"doc\"][\"FirstEntity/name\"] == \"new name\"\n\t    assert result[2][\"doc\"][\"FirstEntity/name\"] == \"new name 2\"\n", "    xtdb_session.delete(test)\n\t    xtdb_session.commit()\n\tdef test_get_entity_transactions(xtdb_session: XTDBSession):\n\t    test = FirstEntity(name=\"test\")\n\t    xtdb_session.put(test, datetime(1000, 10, 10))\n\t    xtdb_session.commit()\n\t    test.name = \"new name\"\n\t    xtdb_session.put(test, datetime(1000, 10, 10))\n\t    xtdb_session.commit()\n\t    test.name = \"new name 2\"\n", "    xtdb_session.put(test, datetime(1000, 10, 11))\n\t    xtdb_session.commit()\n\t    result = xtdb_session.client.get_entity_transactions(test.id)\n\t    assert list(result.keys()) == [\"id\", \"contentHash\", \"validTime\", \"txTime\", \"txId\"]\n\t    assert result[\"validTime\"] == \"1000-10-11T00:00:00Z\"\n\t    result = xtdb_session.client.get_entity_transactions(test.id, tx_id=result[\"txId\"] - 1)\n\t    assert result[\"validTime\"] == \"1000-10-10T00:00:00Z\"\n\t    # TODO: check transaction time\n\t    result = xtdb_session.client.get_entity_transactions(test.id, valid_time=datetime(1000, 10, 10))\n\t    assert result[\"validTime\"] == \"1000-10-10T00:00:00Z\"\n", "    xtdb_session.delete(test)\n\t    xtdb_session.commit()\n\tdef test_transaction_api(xtdb_session: XTDBSession):\n\t    test = FirstEntity(name=\"test\")\n\t    second = SecondEntity(first_entity=test, age=1)\n\t    second2 = SecondEntity(first_entity=test, age=4)\n\t    xtdb_session.put(test)\n\t    xtdb_session.put(second)\n\t    xtdb_session.put(second2)\n\t    xtdb_session.commit()\n", "    result = xtdb_session.client.get_transaction_log()\n\t    assert len(result) == 30\n\t    assert list(result[0].keys()) == [\"txId\", \"txTime\", \"txEvents\"]\n\t    result = xtdb_session.client.get_transaction_log(10)\n\t    assert len(result) == 20\n\t    result = xtdb_session.client.get_transaction_log(10, True)\n\t    assert len(result) == 20\n\t    assert list(result[0].keys()) == [\"txId\", \"txTime\", \"txOps\"]\n\t    result = xtdb_session.client.get_transaction_committed(10)\n\t    assert result == {\"txCommitted?\": True}\n", "    result = xtdb_session.client.get_latest_completed_transaction()\n\t    assert result[\"txId\"] == 30\n\t    result = xtdb_session.client.get_latest_submitted_transaction()\n\t    assert result[\"txId\"] == 30\n\t    result = xtdb_session.client.get_active_queries()\n\t    assert result == []\n\t    query = Query(SecondEntity).where(SecondEntity, age=1)\n\t    xtdb_session.query(query)\n\t    result = xtdb_session.client.get_recent_queries()\n\t    assert result[0][\"error\"] is None\n", "    assert (\n\t        result[0][\"query\"] == \"{:find [(pull SecondEntity [*])], :where [[SecondEntity :SecondEntity/age 1] \"\n\t        '[SecondEntity :type \"SecondEntity\"]]}'\n\t    )\n\t    result = xtdb_session.client.get_slowest_queries()\n\t    assert result == []\n\t    xtdb_session.delete(second2)\n\t    xtdb_session.delete(second)\n\t    xtdb_session.delete(test)\n\t    xtdb_session.commit()\n", "def test_query_limit_timeout_where_in(xtdb_session: XTDBSession):\n\t    with xtdb_session:\n\t        entity = FirstEntity(name=\"test\")\n\t        xtdb_session.put(entity)\n\t    query = (\n\t        Find(\"FirstEntity\")\n\t        & Where(\"FirstEntity\", \"FirstEntity/name\", \"name\")\n\t        & Limit(2)\n\t        & Timeout(29)\n\t        & In(\"name\", \"test\")\n", "    )\n\t    result = xtdb_session.client.query(query)\n\t    assert result == [[entity.id]]\n\t    with xtdb_session:\n\t        xtdb_session.delete(entity)\n\tdef test_sum_count_where_with_exceptions(xtdb_session: XTDBSession):\n\t    with xtdb_session:\n\t        entity = FirstEntity(name=\"test\")\n\t        second = FirstEntity(name=\"test2\")\n\t        third = SecondEntity(age=3, first_entity=entity)\n", "        fourth = SecondEntity(age=5, first_entity=entity)\n\t        xtdb_session.put(entity)\n\t        xtdb_session.put(second)\n\t        xtdb_session.put(third)\n\t        xtdb_session.put(fourth)\n\t    result = xtdb_session.client.query(Count(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n\t    assert result == [[2]]\n\t    result = xtdb_session.client.query(Sum(\"age\") & Where(\"x\", \"SecondEntity/age\", \"age\"))\n\t    assert result == [[8]]\n\t    with pytest.raises(XTDBException):\n", "        xtdb_session.client.query(Sum(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n\t    with pytest.raises(XTDBException):\n\t        xtdb_session.client.query(Sum(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n\t    with pytest.raises(XTDBException):\n\t        xtdb_session.client.query(Sum(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n\t    result = xtdb_session.client.query(Count(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n\t    assert result == [[2]]\n\t    with pytest.raises(XTDBException):\n\t        xtdb_session.client.query(Sum(\"x\") & Where(\"x\", \"type\", '\"FirstEntity\"'))\n\t    with xtdb_session:\n", "        xtdb_session.delete(entity)\n\t        xtdb_session.delete(second)\n\t        xtdb_session.delete(third)\n\t        xtdb_session.delete(fourth)\n"]}
{"filename": "tests/integration/__init__.py", "chunked_list": []}
{"filename": "xtdb/__main__.py", "chunked_list": ["import json\n\timport os\n\timport sys\n\tfrom xtdb.session import XTDBClient\n\tif __name__ == \"__main__\":\n\t    output = XTDBClient(os.environ[\"XTDB_URI\"]).query(sys.stdin.read())\n\t    sys.stdout.write(json.dumps(output))\n"]}
{"filename": "xtdb/query.py", "chunked_list": ["\"\"\"\n\tA module containing the logic to generate XTDB queries using the ORM models.\n\t\"\"\"\n\tfrom dataclasses import dataclass\n\tfrom typing import List, Literal, Optional, Tuple, Type, Union\n\tfrom xtdb.datalog import (\n\t    Avg,\n\t    Clause,\n\t    Count,\n\t    CountDistinct,\n", "    Distinct,\n\t    Find,\n\t    Limit,\n\t    Max,\n\t    Median,\n\t    Min,\n\t    Offset,\n\t    Or,\n\t    OrderBy,\n\t    Rand,\n", "    Sample,\n\t    Stddev,\n\t    Sum,\n\t    Timeout,\n\t    Variance,\n\t    Where,\n\t)\n\tfrom xtdb.exceptions import InvalidField\n\tfrom xtdb.orm import TYPE_FIELD, Base\n\t@dataclass\n", "class Var:\n\t    val: str\n\t    def __str__(self):\n\t        return f\"?{self.val}\"\n\t@dataclass\n\tclass Query:\n\t    \"\"\"\n\t    Example usage:\n\t    >>> query = Query(Object1).where(Object1, name=\"test\")\n\t    >>> query = query.where(Object2, object_one_reference=Object1)\n", "    >>> query.format()\n\t    '\n\t    {:query {:find [(pull Object1 [*])] :where [\n\t        [ Object1 :Object1/name \"test\" ]\n\t        [ Object2 :Object2/object_one_reference Object1 ]\n\t    ]}}\n\t    '\n\t    \"\"\"\n\t    result_type: Type[Base]\n\t    _find: Optional[Clause] = None\n", "    _where: Optional[Clause] = None\n\t    _limit: Optional[Limit] = None\n\t    _order_by: Optional[OrderBy] = None\n\t    _offset: Optional[Offset] = None\n\t    _timeout: Optional[Timeout] = None\n\t    _preserved_return_type: bool = True\n\t    def where(self, object_type: Type[Base], **kwargs) -> \"Query\":\n\t        for field_name, value in kwargs.items():\n\t            self._where_field_is(object_type, field_name, value)\n\t        return self\n", "    def format(self) -> str:\n\t        return self._compile(separator=\"\\n    \")\n\t    def count(self, var: Union[Type[Base], Var]) -> \"Query\":\n\t        self._preserved_return_type = False\n\t        if isinstance(var, Var):\n\t            self._find = self._find & Count(str(var))\n\t            return self\n\t        self._find = self._find & Count(var.alias())\n\t        return self\n\t    def avg(self, var: Var) -> \"Query\":\n", "        self._preserved_return_type = False\n\t        self._find = self._find & Avg(str(var))\n\t        return self\n\t    def max(self, var: Var) -> \"Query\":\n\t        self._preserved_return_type = False\n\t        self._find = self._find & Max(str(var))\n\t        return self\n\t    def min(self, var: Var) -> \"Query\":\n\t        self._preserved_return_type = False\n\t        self._find = self._find & Min(str(var))\n", "        return self\n\t    def count_distinct(self, var: Var) -> \"Query\":\n\t        self._preserved_return_type = False\n\t        self._find = self._find & CountDistinct(str(var))\n\t        return self\n\t    def sum(self, var: Var) -> \"Query\":\n\t        self._preserved_return_type = False\n\t        self._find = self._find & Sum(str(var))\n\t        return self\n\t    def median(self, var: Var) -> \"Query\":\n", "        self._preserved_return_type = False\n\t        self._find = self._find & Median(str(var))\n\t        return self\n\t    def variance(self, var: Var) -> \"Query\":\n\t        self._preserved_return_type = False\n\t        self._find = self._find & Variance(str(var))\n\t        return self\n\t    def stddev(self, var: Var) -> \"Query\":\n\t        self._preserved_return_type = False\n\t        self._find = self._find & Stddev(str(var))\n", "        return self\n\t    def distinct(self, var: Var) -> \"Query\":\n\t        self._preserved_return_type = False\n\t        self._find = self._find & Distinct(str(var))\n\t        return self\n\t    def rand(self, var: Var, N: int) -> \"Query\":\n\t        self._preserved_return_type = False\n\t        self._find = self._find & Rand(str(var), N)\n\t        return self\n\t    def sample(self, var: Var, N: int) -> \"Query\":\n", "        self._preserved_return_type = False\n\t        self._find = self._find & Sample(str(var), N)\n\t        return self\n\t    def order_by(self, fields: List[Tuple[str, Literal[\"asc\", \"desc\"]]]) -> \"Query\":\n\t        self._order_by = OrderBy(fields)\n\t        return self\n\t    def limit(self, limit: int) -> \"Query\":\n\t        self._limit = Limit(limit)\n\t        return self\n\t    def offset(self, offset: int) -> \"Query\":\n", "        self._offset = Offset(offset)\n\t        return self\n\t    def timeout(self, timeout: int) -> \"Query\":\n\t        self._timeout = Timeout(timeout)\n\t        return self\n\t    def _where_field_is(\n\t        self, object_type: Type[Base], field_name: str, value: Union[Type[Base], Var, str, None]\n\t    ) -> None:\n\t        if field_name not in object_type.fields():\n\t            raise InvalidField(f'\"{field_name}\" is not a field of {object_type.alias()}')\n", "        if isinstance(value, str):\n\t            value = value.replace('\"', r\"\\\"\")\n\t            return self._add_where_statement(object_type, field_name, f'\"{value}\"')\n\t        if isinstance(value, (int, float, bool, Var)):\n\t            return self._add_where_statement(object_type, field_name, f\"{str(value).lower()}\")\n\t        if value is None:\n\t            return self._add_where_statement(object_type, field_name, \"nil\")\n\t        # TODO: support for list and dict?\n\t        if not isinstance(value, type):\n\t            raise InvalidField(f\"value '{value}' should be a string or a Base Type\")\n", "        if not issubclass(value, Base):\n\t            raise InvalidField(f\"{value} is not an Base Type\")\n\t        if field_name not in object_type.relations():\n\t            raise InvalidField(f'\"{field_name}\" is not a relation of {object_type.alias()}')\n\t        if object_type.subclasses():\n\t            return self._add_or_statement(object_type, field_name, value.alias())\n\t        self._add_where_statement(object_type, field_name, value.alias())\n\t    def _add_where_statement(self, object_type: Type[Base], field_name: str, to_alias: str) -> None:\n\t        self._where = self._where & Where(object_type.alias(), f\"{object_type.alias()}/{field_name}\", to_alias)\n\t    def _add_or_statement(self, object_type: Type[Base], field_name: str, to_alias: str) -> None:\n", "        clauses = [\n\t            Where(object_type.alias(), f\"{sc.alias()}/{field_name}\", to_alias) for sc in object_type.subclasses()\n\t        ]\n\t        self._where = self._where & Or(clauses)  # type: ignore\n\t    def _compile(self, *, separator=\" \") -> str:\n\t        where = self._where & Where(self.result_type.alias(), TYPE_FIELD, f'\"{self.result_type.alias()}\"')\n\t        find = Find(f\"(pull {self.result_type.alias()} [*])\") if self._find is None else self._find\n\t        find_where = find & where & self._order_by & self._limit & self._offset & self._timeout\n\t        return find_where.compile(separator=separator)\n\t    def __str__(self) -> str:\n", "        return self._compile()\n\t    def __eq__(self, other):\n\t        return str(self) == str(other)\n"]}
{"filename": "xtdb/__init__.py", "chunked_list": []}
{"filename": "xtdb/session.py", "chunked_list": ["\"\"\"\n\tA module containing all logic related to connecting to an XTDB node and managing transactional scope.\n\t\"\"\"\n\timport json\n\timport logging\n\tfrom dataclasses import dataclass, field\n\tfrom datetime import datetime, timezone\n\tfrom enum import Enum\n\tfrom json import JSONDecodeError\n\tfrom typing import Any, Dict, List, Literal, Optional, Type, Union\n", "from requests import HTTPError, Response, Session\n\tfrom requests.adapters import DEFAULT_POOLBLOCK, DEFAULT_POOLSIZE, HTTPAdapter\n\tfrom requests.exceptions import ConnectionError\n\tfrom urllib3 import Retry\n\tfrom xtdb.datalog import Clause, FindWhere\n\tfrom xtdb.exceptions import XTDBException\n\tfrom xtdb.orm import Base, Fn\n\tfrom xtdb.query import Query\n\tlogger = logging.getLogger(\"XTDB\")\n\t@dataclass\n", "class XTDBStatus:\n\t    version: Optional[str]\n\t    revision: Optional[str]\n\t    indexVersion: Optional[int]\n\t    consumerState: Optional[str]\n\t    kvStore: Optional[str]\n\t    estimateNumKeys: Optional[int]\n\t    size: Optional[int]\n\tclass OperationType(Enum):\n\t    PUT = \"put\"\n", "    DELETE = \"delete\"\n\t    MATCH = \"match\"\n\t    EVICT = \"evict\"\n\t    FN = \"fn\"\n\t@dataclass\n\tclass Operation:\n\t    type: OperationType\n\t    value: Union[str, Dict[str, Any]]\n\t    valid_time: Optional[datetime] = field(default_factory=lambda: datetime.now(timezone.utc))\n\t    def to_list(self):\n", "        if self.valid_time is None:\n\t            self.valid_time = datetime.now(timezone.utc)\n\t        if self.type is OperationType.MATCH:\n\t            return [self.type.value, self.value[\"xt/id\"], self.value, self.valid_time.isoformat()]\n\t        if self.type is OperationType.FN:\n\t            return [self.type.value, self.value[\"identifier\"], *self.value[\"args\"]]\n\t        if self.type is OperationType.PUT and \"xt/fn\" in self.value:\n\t            return [self.type.value, self.value]\n\t        return [self.type.value, self.value, self.valid_time.isoformat()]\n\t    @classmethod\n", "    def put(cls, document: Dict, valid_time: Optional[datetime] = None) -> \"Operation\":\n\t        return cls(OperationType.PUT, document, valid_time)\n\t    @classmethod\n\t    def delete(cls, pk: str, valid_time: Optional[datetime] = None) -> \"Operation\":\n\t        return cls(OperationType.DELETE, pk, valid_time)\n\t    @classmethod\n\t    def match(cls, document: Dict, valid_time: Optional[datetime] = None) -> \"Operation\":\n\t        return cls(OperationType.MATCH, document, valid_time)\n\t    @classmethod\n\t    def evict(cls, pk: str, valid_time: Optional[datetime] = None) -> \"Operation\":\n", "        return cls(OperationType.EVICT, pk, valid_time)\n\t    @classmethod\n\t    def fn(cls, identifier: str, *args) -> \"Operation\":\n\t        return cls(OperationType.FN, {\"identifier\": identifier, \"args\": args})\n\t@dataclass\n\tclass Transaction:\n\t    operations: List[Operation] = field(default_factory=list)\n\t    def add(self, operation: Operation):\n\t        self.operations.append(operation)\n\t    def json(self, **kwargs):\n", "        return json.dumps({\"tx-ops\": [op.to_list() for op in self.operations]}, **kwargs)\n\tclass XTDBClient:\n\t    def __init__(\n\t        self,\n\t        base_url: str,\n\t        pool_connections: int = DEFAULT_POOLSIZE,\n\t        pool_maxsize: int = DEFAULT_POOLSIZE,\n\t        pool_block: bool = DEFAULT_POOLBLOCK,\n\t        retries: int = 6,\n\t        backoff_factor: float = 0.5,\n", "    ):\n\t        self.base_url = base_url\n\t        self.adapter = HTTPAdapter(\n\t            pool_connections=pool_connections,\n\t            pool_maxsize=pool_maxsize,\n\t            pool_block=pool_block,\n\t            max_retries=Retry(total=retries, backoff_factor=backoff_factor, connect=3),\n\t        )\n\t        self._session = self.get_session()\n\t    def get_session(self) -> Session:\n", "        session = Session()\n\t        session.mount(\"http://\", self.adapter)\n\t        session.mount(\"https://\", self.adapter)\n\t        session.headers[\"Accept\"] = \"application/json\"\n\t        session.hooks[\"response\"] = self._verify_response\n\t        logger.debug(\"Initialized new HTTP session\")\n\t        return session\n\t    def refresh(self):\n\t        self._session = self.get_session()\n\t    @staticmethod\n", "    def _verify_response(response: Response, *args, **kwargs) -> None:\n\t        logger.debug('\"%s %s\" %s', response.request.method, response.request.url, response.status_code)\n\t        try:\n\t            response.raise_for_status()\n\t        except HTTPError as e:\n\t            logger.exception(\"Request failed\")\n\t            raise XTDBException from e\n\t    def status(self) -> XTDBStatus:\n\t        return XTDBStatus(**self._session.get(f\"{self.base_url}/status\").json())\n\t    def get_entity(\n", "        self,\n\t        eid: str,\n\t        *,\n\t        valid_time: Optional[datetime] = None,\n\t        tx_time: Optional[datetime] = None,\n\t        tx_id: Optional[int] = None,\n\t    ) -> Dict:\n\t        params = self._format_parameter(\"eid\", eid)\n\t        params = self._format_parameter(\"valid-time\", valid_time, params)\n\t        params = self._format_parameter(\"tx-time\", tx_time, params)\n", "        params = self._format_parameter(\"tx-id\", tx_id, params)\n\t        res = self._session.get(f\"{self.base_url}/entity\", params=params)\n\t        return res.json()\n\t    def get_entity_transactions(\n\t        self,\n\t        eid: str,\n\t        *,\n\t        valid_time: Optional[datetime] = None,\n\t        tx_time: Optional[datetime] = None,\n\t        tx_id: Optional[int] = None,\n", "    ) -> Dict:\n\t        params = self._format_parameter(\"eid\", eid)\n\t        params = self._format_parameter(\"valid-time\", valid_time, params)\n\t        params = self._format_parameter(\"tx-time\", tx_time, params)\n\t        params = self._format_parameter(\"tx-id\", tx_id, params)\n\t        return self._session.get(f\"{self.base_url}/entity-tx\", params=params).json()\n\t    def get_entity_history(\n\t        self,\n\t        eid: str,\n\t        *,\n", "        sort_order: Literal[\"asc\", \"desc\"] = \"asc\",\n\t        with_corrections: bool = False,\n\t        with_docs: bool = False,\n\t        start_valid_time: Optional[datetime] = None,\n\t        start_tx_time: Optional[datetime] = None,\n\t        start_tx_id: Optional[int] = None,\n\t        end_valid_time: Optional[datetime] = None,\n\t        end_tx_time: Optional[datetime] = None,\n\t        end_tx_id: Optional[int] = None,\n\t    ) -> Dict:\n", "        params = self._format_parameter(\"eid\", eid)\n\t        params = self._format_parameter(\"history\", True, params)\n\t        params = self._format_parameter(\"sort-order\", sort_order, params)\n\t        params = self._format_parameter(\"with-corrections\", with_corrections, params)\n\t        params = self._format_parameter(\"with-docs\", with_docs, params)\n\t        params = self._format_parameter(\"start-valid-time\", start_valid_time, params)\n\t        params = self._format_parameter(\"start-tx-time\", start_tx_time, params)\n\t        params = self._format_parameter(\"start-tx-id\", start_tx_id, params)\n\t        params = self._format_parameter(\"end-valid-time\", end_valid_time, params)\n\t        params = self._format_parameter(\"end-tx-time\", end_tx_time, params)\n", "        params = self._format_parameter(\"end-tx-id\", end_tx_id, params)\n\t        return self._session.get(f\"{self.base_url}/entity\", params=params).json()\n\t    def get_attribute_stats(self):\n\t        return self._session.get(f\"{self.base_url}/attribute-stats\").json()\n\t    def sync(self, timeout: Optional[int] = None):\n\t        return self._session.get(f\"{self.base_url}/sync\", params=self._format_parameter(\"timeout\", timeout)).json()\n\t    def query(\n\t        self,\n\t        query: Union[str, Query, Clause],\n\t        *,\n", "        valid_time: Optional[datetime] = None,\n\t        tx_time: Optional[datetime] = None,\n\t        tx_id: Optional[int] = None,\n\t        tries: int = 0,\n\t    ) -> Union[List, Dict]:\n\t        if not isinstance(query, (str, Query)) and not issubclass(type(query), FindWhere):\n\t            raise XTDBException(\"Cannot query using incomplete clause\")\n\t        params = self._format_parameter(\"valid-time\", valid_time)\n\t        params = self._format_parameter(\"tx-time\", tx_time, params)\n\t        params = self._format_parameter(\"tx-id\", tx_id, params)\n", "        try:\n\t            return self._session.post(\n\t                f\"{self.base_url}/query\", str(query), params=params, headers={\"Content-Type\": \"application/edn\"}\n\t            ).json()\n\t        except JSONDecodeError as e:\n\t            if e.msg == \"Expecting value\":\n\t                # Empty bodies are returned when you do strange queries such as Sum(x) where x is not numerical.\n\t                raise XTDBException(\"Bad XTDB response: query probably failed\") from e\n\t            raise\n\t        except ConnectionError:\n", "            if tries > 0:\n\t                raise\n\t            # Bad queries cleave connections in a bad state, which is fixed by creating a new requests.Session()\n\t            self.refresh()\n\t            return self.query(query, valid_time=valid_time, tx_time=tx_time, tx_id=tx_id, tries=1)\n\t    def await_transaction(self, tx_id: int, timeout: Optional[int] = None) -> None:\n\t        params = self._format_parameter(\"timeout\", timeout)\n\t        params = self._format_parameter(\"tx-id\", tx_id, params)\n\t        self._session.get(f\"{self.base_url}/await-tx\", params=params)\n\t    def await_transaction_time(self, tx_time: datetime, timeout: Optional[int] = None) -> None:\n", "        params = self._format_parameter(\"tx-time\", tx_time)\n\t        params = self._format_parameter(\"timeout\", timeout, params)\n\t        self._session.get(f\"{self.base_url}/await-tx-time\", params=params)\n\t    def get_transaction_log(self, after_tx_id: Optional[int] = None, with_ops: Optional[bool] = None):\n\t        params = self._format_parameter(\"after-tx-id\", after_tx_id)\n\t        params = self._format_parameter(\"with-ops?\", with_ops, params)\n\t        return self._session.get(f\"{self.base_url}/tx-log\", params=params).json()\n\t    def submit_tx(self, transaction: Union[Transaction, List], tries: int = 0) -> None:\n\t        if isinstance(transaction, list):\n\t            transaction = Transaction(operations=transaction)\n", "        try:\n\t            res = self._session.post(\n\t                f\"{self.base_url}/submit-tx\", transaction.json(), headers={\"Content-Type\": \"application/json\"}\n\t            )\n\t        except ConnectionError:\n\t            if tries > 0:\n\t                raise\n\t            # Bad queries cleave connections in a bad state, which is fixed by creating a new requests.Session()\n\t            self.refresh()\n\t            return self.submit_tx(transaction, tries=1)\n", "        self.await_transaction(res.json()[\"txId\"])\n\t    def get_transaction_committed(self, tx_id: int):\n\t        return self._session.get(f\"{self.base_url}/tx-committed\", params=self._format_parameter(\"tx-id\", tx_id)).json()\n\t    def get_latest_completed_transaction(self):\n\t        return self._session.get(f\"{self.base_url}/latest-completed-tx\").json()\n\t    def get_latest_submitted_transaction(self):\n\t        return self._session.get(f\"{self.base_url}/latest-submitted-tx\").json()\n\t    def get_active_queries(self):\n\t        return self._session.get(f\"{self.base_url}/active-queries\").json()\n\t    def get_recent_queries(self):\n", "        return self._session.get(f\"{self.base_url}/recent-queries\").json()\n\t    def get_slowest_queries(self):\n\t        return self._session.get(f\"{self.base_url}/slowest-queries\").json()\n\t    @staticmethod\n\t    def _format_parameter(\n\t        key: str, parameter: Union[None, datetime, int, str, bool], current_params: Optional[Dict] = None\n\t    ) -> Dict:\n\t        if current_params is None:\n\t            current_params = {}\n\t        if isinstance(parameter, datetime):\n", "            current_params[key] = parameter.isoformat()\n\t        if isinstance(parameter, (int, str, bool)):\n\t            current_params[key] = str(parameter).lower()\n\t        return current_params\n\tclass XTDBSession:\n\t    def __init__(self, base_url: str):\n\t        self.client = XTDBClient(base_url)\n\t        self._transaction = Transaction()\n\t    def __enter__(self):\n\t        return self\n", "    def __exit__(self, _exc_type: Type[Exception], _exc_value: str, _exc_traceback: str) -> None:\n\t        self.commit()\n\t    def query(self, query: Query, **kwargs) -> List[Base]:\n\t        if not query._preserved_return_type:\n\t            raise XTDBException(\n\t                \"XTDBSession.query() only supports queries with preserved return types. Use XTDBClient.query() instead.\"\n\t            )\n\t        result = self.client.query(query, **kwargs)\n\t        return [query.result_type.from_dict(document[0]) for document in result]\n\t    def get(self, eid: str, **kwargs) -> Dict:\n", "        return self.client.get_entity(eid, **kwargs)\n\t    def put(self, document: Base, valid_time: Optional[datetime] = None) -> None:\n\t        self._transaction.add(Operation.put(document.dict(), valid_time))\n\t    def delete(self, document: Base, valid_time: Optional[datetime] = None) -> None:\n\t        self._transaction.add(Operation.delete(document.id, valid_time))\n\t    def match(self, document: Base, valid_time: Optional[datetime] = None) -> None:\n\t        self._transaction.add(Operation.match(document.dict(), valid_time))\n\t    def evict(self, document: Base, valid_time: Optional[datetime] = None) -> None:\n\t        self._transaction.add(Operation.evict(document.id, valid_time))\n\t    def fn(self, function: Fn, *args) -> None:\n", "        self._transaction.add(Operation.fn(function.identifier, *args))\n\t    def commit(self) -> None:\n\t        if operation_count := len(self._transaction.operations) == 0:\n\t            return\n\t        try:\n\t            self.client.submit_tx(self._transaction)\n\t            logger.debug(\"Committed %s operations\", operation_count)\n\t        finally:\n\t            self._transaction = Transaction()\n"]}
{"filename": "xtdb/orm.py", "chunked_list": ["\"\"\"\n\tThis module contains base classes for the creation of ORM models.\n\t\"\"\"\n\timport uuid\n\tfrom dataclasses import asdict, dataclass\n\tfrom typing import Dict, List, Type\n\tTYPE_FIELD = \"type\"\n\t@dataclass\n\tclass Base:\n\t    @property\n", "    def id(self):\n\t        if not hasattr(self, \"_pk_proxy\"):\n\t            self._pk_proxy = str(uuid.uuid4())\n\t        return self._pk_proxy\n\t    @classmethod\n\t    def fields(cls):\n\t        return cls.__dataclass_fields__\n\t    @classmethod\n\t    def relations(cls) -> List[str]:\n\t        return [key for key, value in cls.fields().items() if issubclass(value.type, Base)]\n", "    @classmethod\n\t    def subclasses(cls) -> List[Type[\"Base\"]]:\n\t        return cls.__subclasses__()\n\t    @classmethod\n\t    def alias(cls):\n\t        return cls.__name__\n\t    def dict(self) -> Dict:\n\t        result = {\"xt/id\": self.id, \"type\": self.alias()}\n\t        for key, value in asdict(self).items():\n\t            if issubclass(self.fields().get(key).type, Base):\n", "                field = self.__getattribute__(key)\n\t                # Foreign keys are not always hydrated\n\t                result[f\"{self.alias()}/{key}\"] = field.id if isinstance(field, Base) else field\n\t            else:\n\t                result[f\"{self.alias()}/{key}\"] = value\n\t        return result\n\t    @classmethod\n\t    def from_dict(cls, document: Dict) -> \"Base\":\n\t        doc = {key.replace(f\"{cls.alias()}/\", \"\"): value for key, value in document.items()}\n\t        pk = doc.pop(\"xt/id\")\n", "        del doc[\"type\"]\n\t        instance = cls(**doc)\n\t        instance._pk_proxy = pk\n\t        return instance\n\t@dataclass\n\tclass Fn(Base):\n\t    function: str\n\t    identifier: str\n\t    @property\n\t    def id(self):\n", "        return self.identifier\n\t    def dict(self) -> Dict:\n\t        return {\"xt/id\": self.identifier, \"xt/fn\": self.function}\n"]}
{"filename": "xtdb/exceptions.py", "chunked_list": ["\"\"\"\n\tException documentation. Note: all exceptions from the package inherit from the XTDBException class.\n\t\"\"\"\n\tclass XTDBException(Exception):\n\t    \"\"\"Base exception for XTDB errors.\"\"\"\n\tclass InvalidField(XTDBException):\n\t    \"\"\"Exception indicating an invalid field was passed during query creation in the ORM.\"\"\"\n"]}
{"filename": "xtdb/datalog.py", "chunked_list": ["\"\"\"\n\tThe Datalog module contains all logic to declaratively create XTDB queries.\n\t\"\"\"\n\tfrom typing import Any, List, Literal, Optional, Tuple, Union\n\tfrom xtdb.exceptions import XTDBException\n\tclass Clause:\n\t    commutative = True\n\t    idempotent = True\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        raise NotImplementedError\n", "    def format(self) -> str:\n\t        return self.compile(separator=\"\\n    \")\n\t    def _collect(self, *, separator=\" \") -> List:\n\t        return [self.compile(root=False, separator=separator)]\n\t    def __str__(self) -> str:\n\t        return self.compile()\n\t    def __and__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n\t        if other is None:\n\t            return self\n\t        return self._and(other)\n", "    def _and(self, other: \"Clause\") -> \"Clause\":\n\t        if issubclass(type(other), Find):\n\t            raise XTDBException(\"Cannot perform a where-find. User find-where instead.\")\n\t        return And([self, other])\n\t    def __or__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n\t        if other is None:\n\t            return self\n\t        return self._or(other)\n\t    def _or(self, other: \"Clause\") -> \"Clause\":\n\t        raise NotImplementedError\n", "    def __ror__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n\t        if other is None:\n\t            return self\n\t        raise NotImplementedError\n\t    def __rand__(self, other: Optional[\"Clause\"]) -> \"Clause\":\n\t        if other is None:\n\t            return self\n\t        raise NotImplementedError\n\t    def __invert__(self):\n\t        raise NotImplementedError\n", "class And(Clause):\n\t    def __init__(self, clauses: List[Clause], query_section: str = \"where\"):\n\t        self.clauses = clauses\n\t        self.query_section = query_section\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        compiled_clauses = self._collect(separator=separator)\n\t        expression = separator + separator.join(compiled_clauses)\n\t        if root:\n\t            return f\":{self.query_section} [{expression}]\"\n\t        return expression\n", "    def _collect(self, *, separator=\" \") -> List:\n\t        collected = []\n\t        for clause in self.clauses:\n\t            collected.extend(clause._collect(separator=separator))\n\t        if all(clause.idempotent for clause in self.clauses):\n\t            collected = list(set(collected))\n\t        if all(clause.commutative for clause in self.clauses):\n\t            collected = sorted(collected)\n\t        return collected\n\t    def _or(self, other: Clause) -> \"Clause\":\n", "        if isinstance(other, (Where, WherePredicate)):\n\t            raise XTDBException(\"Cannot | on a single where, use & instead\")\n\t        return Or([self, other])\n\t    def _and(self, other: Clause) -> Clause:\n\t        if self.query_section != \"find\" and issubclass(type(other), Find):\n\t            raise XTDBException(\"Cannot perform a where-find. User find-where instead.\")\n\t        if self.query_section == \"find\" and isinstance(other, And) and other.query_section != \"find\":\n\t            return FindWhere(self, other)\n\t        if self.query_section == \"find\" and isinstance(other, (Where, Or, Not, NotJoin, WherePredicate)):\n\t            return FindWhere(self, other)\n", "        return And(self.clauses + [other], self.query_section)\n\t    def __invert__(self):\n\t        return Not(self.clauses)\n\tclass Or(Clause):\n\t    def __init__(self, clauses: List[Clause]):\n\t        self.clauses = clauses\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        collected = []\n\t        for clause in self.clauses:\n\t            if isinstance(clause, And):\n", "                collected.append(f\"(and{clause.compile(root=False, separator=separator)})\")\n\t            else:\n\t                collected.append(clause.compile(root=False, separator=separator))\n\t        if all(clause.idempotent for clause in self.clauses):\n\t            collected = list(set(collected))\n\t        if all(clause.commutative for clause in self.clauses):\n\t            collected = sorted(collected)\n\t        if root:\n\t            return f\":where [(or{separator}{separator.join(collected)})]\"\n\t        return f\"(or{separator}{separator.join(collected)})\"\n", "    def _or(self, other: Clause) -> Clause:\n\t        return Or(self.clauses + [other])\n\t    def __invert__(self):\n\t        raise XTDBException(\"Cannot use ~ on or clauses\")\n\tclass Not(Clause):\n\t    def __init__(self, clauses: List[Clause]):\n\t        self.clauses = clauses\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        collected = []\n\t        for clause in self.clauses:\n", "            collected.append(clause.compile(root=False, separator=separator))\n\t        if all(clause.idempotent for clause in self.clauses):\n\t            collected = list(set(collected))\n\t        if all(clause.commutative for clause in self.clauses):\n\t            collected = sorted(collected)\n\t        if root:\n\t            return f\":where [(not{separator}{separator.join(collected)})]\"\n\t        return f\"(not{separator}{separator.join(collected)})\"\n\t    def _or(self, other: Clause) -> Clause:\n\t        return Or(self.clauses + [other])\n", "    def __invert__(self):\n\t        return And(self.clauses)\n\tclass NotJoin(Clause):\n\t    def __init__(self, variable: str, clauses: Optional[List] = None):\n\t        self.variable = variable\n\t        self.clauses = clauses or []\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        collected = []\n\t        for clause in self.clauses:\n\t            collected.append(clause.compile(root=False, separator=separator))\n", "        if all(clause.idempotent for clause in self.clauses):\n\t            collected = list(set(collected))\n\t        if all(clause.commutative for clause in self.clauses):\n\t            collected = sorted(collected)\n\t        if root:\n\t            return f\":where [(not-join{separator}[{self.variable}] {separator.join(collected)})]\"\n\t        return f\"(not-join{separator}[{self.variable}] {separator.join(collected)})\"\n\t    def _and(self, other: Clause) -> Clause:\n\t        return NotJoin(self.variable, self.clauses + [other])\n\t    def __invert__(self):\n", "        raise XTDBException(\"Cannot use ~ on not-join\")\n\tclass OrJoin(Clause):\n\t    def __init__(self, variable: str, clauses: Optional[List] = None):\n\t        self.variable = variable\n\t        self.clauses = clauses or []\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        collected = []\n\t        for clause in self.clauses:\n\t            collected.append(clause.compile(root=False, separator=separator))\n\t        if all(clause.idempotent for clause in self.clauses):\n", "            collected = list(set(collected))\n\t        if all(clause.commutative for clause in self.clauses):\n\t            collected = sorted(collected)\n\t        if root:\n\t            return f\":where [(or-join{separator}[{self.variable}] {separator.join(collected)})]\"\n\t        return f\"(or-join{separator}[{self.variable}] {separator.join(collected)})\"\n\t    def _and(self, other: Clause) -> Clause:\n\t        return OrJoin(self.variable, self.clauses + [other])\n\t    def __invert__(self):\n\t        raise XTDBException(\"Cannot use ~ on or-join\")\n", "class Where(Clause):\n\t    def __init__(self, document: str, field: str, value: Any = \"\"):\n\t        self.document = document\n\t        self.field = field\n\t        self.value = value\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        if root:\n\t            return f\":where [[ {self.document} :{self.field} {self.value} ]]\"\n\t        return f\"[ {self.document} :{self.field} {self.value} ]\"\n\t    def _or(self, other: Clause) -> Clause:\n", "        if isinstance(other, And):\n\t            raise XTDBException(\"Cannot | on a single where, use & instead\")\n\t        return Or([self, other])\n\t    def __invert__(self):\n\t        return Not([self])\n\tclass WherePredicate(Clause):\n\t    def __init__(self, operation: str, *args, bind: Optional[str] = None):\n\t        self.args = args\n\t        self.operation = operation\n\t        self.bind = bind\n", "    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        bind = self.bind or \"\"\n\t        if root:\n\t            return f\":where [[ ({self.operation} {' '.join([str(arg) for arg in self.args])}) {bind}]]\"\n\t        return f\"[ ({self.operation} {' '.join(self.args)}) {bind}]\"\n\t    def _or(self, other: Clause) -> Clause:\n\t        if isinstance(other, And):\n\t            raise XTDBException(\"Cannot | on a single predicate, use & instead\")\n\t        return Or([self, other])\n\t    def __invert__(self):\n", "        return Not([self])\n\tclass Expression:\n\t    def __init__(self, statement: str):\n\t        self.statement = statement\n\t    def __str__(self):\n\t        return self.statement\n\tclass _BaseAggregate(Expression):\n\t    supported_aggregates = [\"sum\", \"min\", \"max\", \"count\", \"avg\", \"median\", \"variance\", \"stddev\", \"distinct\"]\n\t    supported_aggregates_with_arg = [\"rand\", \"sample\"]\n\t    def __init__(self, function: str, expression: str, *args):\n", "        if function not in self.supported_aggregates + self.supported_aggregates_with_arg:\n\t            raise XTDBException(\"Invalid aggregate function\")\n\t        if function in self.supported_aggregates:\n\t            super().__init__(f\"({function} {expression})\")\n\t        if function in self.supported_aggregates_with_arg:\n\t            if len(args) != 1:\n\t                raise XTDBException(\"Invalid arguments to aggregate, it needs one argument: N\")\n\t            super().__init__(f\"({function} {' '.join(args)} {expression})\")\n\tclass QueryKey(Clause):\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n", "        raise NotImplementedError\n\t    def _or(self, other: Clause) -> Clause:\n\t        raise XTDBException(\"Cannot use | on query keys\")\n\t    def _and(self, other: Clause) -> Clause:\n\t        return And([self, other])\n\t    def __invert__(self):\n\t        raise XTDBException(\"Cannot use ~ on query keys\")\n\tclass Find(QueryKey):\n\t    commutative = False\n\t    idempotent = False\n", "    def __init__(self, expression: Union[str, Expression]):\n\t        self.expression = expression\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        if root:\n\t            return f\":find [{self.expression}]\"\n\t        return str(self.expression)\n\t    def _and(self, other: Clause) -> Clause:\n\t        if isinstance(other, And) and other.query_section != \"find\":\n\t            return FindWhere(self, other)\n\t        if isinstance(other, (Where, Or, Not, WherePredicate)):\n", "            return FindWhere(self, other)\n\t        return And([self, other], \"find\")\n\tclass In(QueryKey):\n\t    def __init__(self, in_args: Union[str, List[str], List[List[str]]], values: Union[str, List[str], List[List[str]]]):\n\t        if not in_args:\n\t            raise XTDBException(\"No in_arg supplied: cannot be empty\")\n\t        if not values:\n\t            raise XTDBException(\"No values supplied: cannot be empty\")\n\t        self.in_args = in_args\n\t        self.values = values\n", "    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        if isinstance(self.in_args, str):\n\t            return f\" :in [{self.in_args}]\"\n\t        if isinstance(self.in_args[0], str):\n\t            expression = \" \".join([in_arg for in_arg in self.in_args if isinstance(in_arg, str)])\n\t            return f\" :in [[{expression}]]\"\n\t        nested_args = [\" \".join(in_arg) for in_arg in self.in_args if isinstance(in_arg, List)]\n\t        expression = \" \".join(nested_args)\n\t        return f\" :in [[[{expression}]]]\"\n\t    def compile_values(self) -> str:\n", "        if not isinstance(self.values, List):\n\t            return f' :in-args [\"{self.values}\"]'\n\t        if not isinstance(self.values[0], List):\n\t            expression = \" \".join([f'\"{value}\"' for value in self.values])\n\t            return f\" :in-args [[{expression}]]\"\n\t        nested_values = [\"[\" + \" \".join([f'\"{value}\"' for value in values]) + \"]\" for values in self.values]\n\t        expression = \" \".join(nested_values)\n\t        return f\" :in-args [[{expression}]]\"\n\tclass OrderBy(QueryKey):\n\t    def __init__(self, fields: List[Tuple[str, Literal[\"asc\", \"desc\"]]]):\n", "        if not all([field[1] in [\"asc\", \"desc\"] for field in fields]):\n\t            raise XTDBException(\"Only 'asc' and 'desc' allowed as ordering functions.\")\n\t        self.fields = fields\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        expression = \" \".join([self.compile_field(field) for field in self.fields])\n\t        return f\" :order-by [{expression}]\"\n\t    def compile_field(self, field: Tuple[str, Literal[\"asc\", \"desc\"]]):\n\t        return f\"[{field[0]} :{field[1]}]\"\n\tclass Limit(QueryKey):\n\t    def __init__(self, limit: int):\n", "        self.limit = limit\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        return f\" :limit {self.limit}\"\n\tclass Offset(QueryKey):\n\t    def __init__(self, offset: int):\n\t        self.offset = offset\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        return f\" :offset {self.offset}\"\n\tclass Timeout(QueryKey):\n\t    def __init__(self, timeout: int):\n", "        self.timeout = timeout\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        return f\" :timeout {self.timeout}\"\n\tclass FindWhere(QueryKey):\n\t    def __init__(\n\t        self,\n\t        find: Clause,\n\t        where: Clause,\n\t        in_args: Optional[In] = None,\n\t        order_by: Optional[OrderBy] = None,\n", "        limit: Optional[Limit] = None,\n\t        offset: Optional[Offset] = None,\n\t        timeout: Optional[Timeout] = None,\n\t    ):\n\t        self.find = find\n\t        self.where = where\n\t        self.in_args = in_args\n\t        self.order_by = order_by\n\t        self.limit = limit\n\t        self.offset = offset\n", "        self.timeout = timeout\n\t    def compile(self, root: bool = True, *, separator=\" \") -> str:\n\t        q = f\"{{:query {{{self.find.compile(separator=separator)} {self.where.compile(separator=separator)}\"\n\t        if self.in_args is not None:\n\t            q += self.in_args.compile(separator=separator)\n\t        if self.order_by is not None:\n\t            q += self.order_by.compile(separator=separator)\n\t        if self.limit is not None:\n\t            q += self.limit.compile(separator=separator)\n\t        if self.offset is not None:\n", "            q += self.offset.compile(separator=separator)\n\t        if self.timeout is not None:\n\t            q += self.timeout.compile(separator=separator)\n\t        if self.in_args is not None:\n\t            return q + f\"}}{self.in_args.compile_values()}}}\"\n\t        return q + \"}}\"\n\t    def _and(self, other: Clause) -> Clause:\n\t        if isinstance(other, In):\n\t            return FindWhere(self.find, self.where, other, self.order_by, self.limit, self.offset, self.timeout)\n\t        if isinstance(other, OrderBy):\n", "            return FindWhere(self.find, self.where, self.in_args, other, self.limit, self.offset, self.timeout)\n\t        if isinstance(other, Limit):\n\t            return FindWhere(self.find, self.where, self.in_args, self.order_by, other, self.offset, self.timeout)\n\t        if isinstance(other, Offset):\n\t            return FindWhere(self.find, self.where, self.in_args, self.order_by, self.limit, other, self.timeout)\n\t        if isinstance(other, Timeout):\n\t            return FindWhere(self.find, self.where, self.in_args, self.order_by, self.limit, self.offset, other)\n\t        raise XTDBException(\"And operator is not supported for find-where clauses\")\n\tdef _build_find_aggregation_class(name: str):\n\t    class Extended(Find):\n", "        def __init__(self, expression: str):\n\t            super().__init__(_BaseAggregate(name, expression))\n\t    return Extended\n\tdef _build_find_aggregation_class_with_argument(name: str):\n\t    class Extended(Find):\n\t        def __init__(self, expression: str, N: int):\n\t            super().__init__(_BaseAggregate(name, expression, str(N)))\n\t    return Extended\n\t# Dynamically create classes extending the Find clause but do aggregations\n\tSum = _build_find_aggregation_class(\"sum\")\n", "Min = _build_find_aggregation_class(\"min\")\n\tMax = _build_find_aggregation_class(\"max\")\n\tCount = _build_find_aggregation_class(\"count\")\n\tCountDistinct = _build_find_aggregation_class(\"count-distinct\")\n\tAvg = _build_find_aggregation_class(\"avg\")\n\tMedian = _build_find_aggregation_class(\"median\")\n\tVariance = _build_find_aggregation_class(\"variance\")\n\tStddev = _build_find_aggregation_class(\"stddev\")\n\tDistinct = _build_find_aggregation_class(\"distinct\")\n\tRand = _build_find_aggregation_class_with_argument(\"rand\")\n", "Sample = _build_find_aggregation_class_with_argument(\"sample\")\n"]}
{"filename": "examples/cities/queries_without_orm.py", "chunked_list": ["import os\n\tfrom pprint import pprint\n\tfrom xtdb.datalog import Find, Where\n\tfrom xtdb.session import XTDBClient\n\tclient = XTDBClient(os.environ[\"XTDB_URI\"])\n\tprint(\"\\nCountry of the user named bA\\n\")\n\tquery = Find(\"(pull Country [*])\") & (\n\t    Where(\"City\", \"City/country\", \"Country\")\n\t    & Where(\"Country\", \"type\", '\"Country\"')\n\t    & Where(\"User\", \"User/city\", \"City\")\n", "    & Where(\"User\", \"User/name\", '\"bA\"')\n\t)\n\tresult = client.query(query)\n\tpprint(result)\n"]}
{"filename": "examples/cities/models.py", "chunked_list": ["from dataclasses import dataclass\n\tfrom xtdb.orm import Base\n\t@dataclass\n\tclass Country(Base):\n\t    name: str\n\t@dataclass\n\tclass City(Base):\n\t    country: Country\n\t    population: int\n\t    name: str\n", "@dataclass\n\tclass User(Base):\n\t    city: City\n\t    country: Country\n\t    name: str\n"]}
{"filename": "examples/cities/seed.py", "chunked_list": ["import os\n\timport random\n\tfrom pathlib import Path\n\tfrom models import City, Country, User\n\tfrom xtdb.session import XTDBSession\n\tcountries = [\n\t    \"Andorra\",\n\t    \"Afghanistan\",\n\t    \"Antigua and Barbuda\",\n\t    \"Albania\",\n", "    \"Armenia\",\n\t    \"Angola\",\n\t    \"Argentina\",\n\t    \"Austria\",\n\t    \"Australia\",\n\t    \"Azerbaijan\",\n\t    \"Barbados\",\n\t    \"Bangladesh\",\n\t    \"Belgium\",\n\t    \"Burkina Faso\",\n", "    \"Bulgaria\",\n\t    \"Bahrain\",\n\t    \"Burundi\",\n\t    \"Benin\",\n\t    \"Brunei Darussalam\",\n\t    \"Bolivia\",\n\t    \"Brazil\",\n\t    \"Bahamas\",\n\t    \"Bhutan\",\n\t    \"Botswana\",\n", "    \"Belarus\",\n\t    \"Belize\",\n\t    \"Canada\",\n\t    \"Democratic Republic of the Congo\",\n\t    \"Republic of the Congo\",\n\t    \"d'Ivoire\",\n\t    \"Chile\",\n\t    \"Cameroon\",\n\t    \"People's Republic of China\",\n\t    \"Colombia\",\n", "    \"Costa Rica\",\n\t    \"Cuba\",\n\t    \"Cape Verde\",\n\t    \"Cyprus\",\n\t    \"Czech Republic\",\n\t    \"Germany\",\n\t    \"Djibouti\",\n\t    \"Denmark\",\n\t    \"Dominica\",\n\t    \"Dominican Republic\",\n", "    \"Ecuador\",\n\t    \"Estonia\",\n\t    \"Egypt\",\n\t    \"Eritrea\",\n\t    \"Ethiopia\",\n\t    \"Finland\",\n\t    \"Fiji\",\n\t    \"France\",\n\t    \"Gabon\",\n\t    \"Georgia\",\n", "    \"Ghana\",\n\t    \"The Gambia\",\n\t    \"Guinea\",\n\t    \"Greece\",\n\t    \"Guatemala\",\n\t    \"Haiti\",\n\t    \"Guinea-Bissau\",\n\t    \"Guyana\",\n\t    \"Honduras\",\n\t    \"Hungary\",\n", "    \"Indonesia\",\n\t    \"Ireland\",\n\t    \"Israel\",\n\t    \"India\",\n\t    \"Iraq\",\n\t    \"Iran\",\n\t    \"Iceland\",\n\t    \"Italy\",\n\t    \"Jamaica\",\n\t    \"Jordan\",\n", "    \"Japan\",\n\t    \"Kenya\",\n\t    \"Kyrgyzstan\",\n\t    \"Kiribati\",\n\t    \"North Korea\",\n\t    \"South Korea\",\n\t    \"Kuwait\",\n\t    \"Lebanon\",\n\t    \"Liechtenstein\",\n\t    \"Liberia\",\n", "    \"Lesotho\",\n\t    \"Lithuania\",\n\t    \"Luxembourg\",\n\t    \"Latvia\",\n\t    \"Libya\",\n\t    \"Madagascar\",\n\t    \"Marshall Islands\",\n\t    \"Macedonia\",\n\t    \"Mali\",\n\t    \"Myanmar\",\n", "    \"Mongolia\",\n\t    \"Mauritania\",\n\t    \"Malta\",\n\t    \"Mauritius\",\n\t    \"Maldives\",\n\t    \"Malawi\",\n\t    \"Mexico\",\n\t    \"Malaysia\",\n\t    \"Mozambique\",\n\t    \"Namibia\",\n", "    \"Niger\",\n\t    \"Nigeria\",\n\t    \"Nicaragua\",\n\t    \"Netherlands\",\n\t    \"Norway\",\n\t    \"Nepal\",\n\t    \"Nauru\",\n\t    \"New Zealand\",\n\t    \"Oman\",\n\t    \"Panama\",\n", "    \"Peru\",\n\t    \"Papua New Guinea\",\n\t    \"Philippines\",\n\t    \"Pakistan\",\n\t    \"Poland\",\n\t    \"Portugal\",\n\t    \"Palau\",\n\t    \"Paraguay\",\n\t    \"Qatar\",\n\t    \"Romania\",\n", "    \"Russia\",\n\t    \"Rwanda\",\n\t    \"Saudi Arabia\",\n\t    \"Solomon Islands\",\n\t    \"Seychelles\",\n\t    \"Sudan\",\n\t    \"Sweden\",\n\t    \"Singapore\",\n\t    \"Slovenia\",\n\t    \"Slovakia\",\n", "    \"Sierra Leone\",\n\t    \"San Marino\",\n\t    \"Senegal\",\n\t    \"Somalia\",\n\t    \"Suriname\",\n\t    \"Syria\",\n\t    \"Togo\",\n\t    \"Thailand\",\n\t    \"Tajikistan\",\n\t    \"Turkmenistan\",\n", "    \"Tunisia\",\n\t    \"Tonga\",\n\t    \"Turkey\",\n\t    \"Trinidad and Tobago\",\n\t    \"Tuvalu\",\n\t    \"Tanzania\",\n\t    \"Ukraine\",\n\t    \"Uganda\",\n\t    \"United States\",\n\t    \"Uruguay\",\n", "    \"Uzbekistan\",\n\t    \"Vatican City\",\n\t    \"Venezuela\",\n\t    \"Vietnam\",\n\t    \"Vanuatu\",\n\t    \"Yemen\",\n\t    \"Zambia\",\n\t    \"Zimbabwe\",\n\t    \"Algeria\",\n\t    \"Bosnia and Herzegovina\",\n", "    \"Cambodia\",\n\t    \"Central African Republic\",\n\t    \"Chad\",\n\t    \"Comoros\",\n\t    \"Croatia\",\n\t    \"East Timor\",\n\t    \"El Salvador\",\n\t    \"Equatorial Guinea\",\n\t    \"Grenada\",\n\t    \"Kazakhstan\",\n", "    \"Laos\",\n\t    \"Federated States of Micronesia\",\n\t    \"Moldova\",\n\t    \"Monaco\",\n\t    \"Montenegro\",\n\t    \"Morocco\",\n\t    \"Saint Kitts and Nevis\",\n\t    \"Saint Lucia\",\n\t    \"Saint Vincent and the Grenadines\",\n\t    \"Samoa\",\n", "    \"Serbia\",\n\t    \"South Africa\",\n\t    \"Spain\",\n\t    \"Sri Lanka\",\n\t    \"Swaziland\",\n\t    \"Switzerland\",\n\t    \"United Arab Emirates\",\n\t    \"United Kingdom\",\n\t]\n\tdef main():\n", "    cities = [\n\t        [city.split(\",\")[0], int(city.split(\",\")[1]), city.split(\",\")[2]]\n\t        for city in (Path() / \"cities.csv\").read_text().splitlines()[1:]\n\t    ]\n\t    country_map = {}\n\t    xtdb_session = XTDBSession(os.environ[\"XTDB_URI\"])\n\t    with xtdb_session:\n\t        for country in countries:\n\t            country_entity = Country(name=country)\n\t            xtdb_session.put(country_entity)\n", "            country_map[country] = country_entity\n\t    city_map = {}\n\t    with xtdb_session:\n\t        for name, population, country_name in cities:\n\t            city_entity = City(name=name, population=population, country=country_map[str(country_name)])\n\t            xtdb_session.put(city_entity)\n\t            city_map[name] = city_entity\n\t    alfabet = \"abcdefghijklmnopqrstuvwxyz\"\n\t    alfabet += alfabet.upper()\n\t    with xtdb_session:\n", "        for x in alfabet:\n\t            for y in alfabet:\n\t                city = list(city_map.values())[random.randint(0, len(city_map) - 1)]\n\t                xtdb_session.put(User(name=x + y, city=city, country=city.country))\n\tif __name__ == \"__main__\":\n\t    main()\n"]}
{"filename": "examples/cities/__init__.py", "chunked_list": []}
{"filename": "examples/cities/queries.py", "chunked_list": ["import os\n\tfrom pprint import pprint\n\tfrom models import City, Country, User\n\tfrom xtdb.query import Query\n\tfrom xtdb.session import XTDBSession\n\tsession = XTDBSession(os.environ[\"XTDB_URI\"])\n\tprint(\"\\nCountry of the user named bA\\n\")\n\tresult = session.query(Query(Country).where(City, country=Country).where(User, city=City, name=\"bA\"))\n\tprint(Query(Country).where(City, country=Country).where(User, city=City, name=\"bA\"))\n\tpprint(result)\n", "print(\"\\nCity of the user named bA\\n\")\n\tresult = session.query(Query(City).where(City, country=Country).where(User, city=City, name=\"bA\"))\n\tpprint(result)\n\tprint(\"\\n2 users in Ireland\\n\")\n\tresult = session.query(\n\t    Query(User).where(City, country=Country).where(User, city=City).where(Country, name=\"Ireland\").limit(2)\n\t)\n\tpprint(result)\n\tprint(\"\\nAll cities in Ireland\\n\")\n\tresult = session.query(Query(City).where(City, country=Country).where(Country, name=\"Ireland\"))\n", "pprint(result)\n"]}
{"filename": "docs/source/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t#\n\t# For the full list of built-in configuration values, see the documentation:\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\timport subprocess\n\tbranch = subprocess.check_output([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"]).decode(\"utf-8\")\n\tcommit_date = subprocess.check_output([\"git\", \"log\", \"--format=#%h %cs\", \"-n 1\"]).decode(\"utf-8\")\n\t# -- Project information -----------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\tproject = \"XTDB-Python\"\n", "copyright = \"Donny Peeters (MIT License)\"\n\tauthor = \"Donny Peeters\"\n\tversion = branch\n\trelease = version\n\t# -- General configuration ---------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\textensions = [\n\t    \"sphinx.ext.napoleon\",\n\t    \"sphinx.ext.viewcode\",\n\t    \"sphinx.ext.githubpages\",\n", "    \"sphinx.ext.autosectionlabel\",\n\t    \"sphinx.ext.autodoc\",\n\t    \"sphinx.ext.autosummary\",\n\t    \"sphinx_rtd_theme\",\n\t    \"myst_parser\",\n\t]\n\tmyst_enable_extensions = [\"tasklist\"]\n\ttemplates_path = [\"_templates\"]\n\t# -- Options for HTML output -------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n", "html_theme = \"sphinx_rtd_theme\"\n\thtml_logo = \"_static/logo.png\"\n\thtml_favicon = \"_static/favicon.svg\"\n\thtml_context = {\n\t    \"display_github\": True,\n\t    \"github_user\": \"DonnyPe\",\n\t    \"github_repo\": \"xtdb-py\",\n\t    \"github_version\": \"main\",\n\t    \"conf_py_path\": \"/docs/source/\",\n\t}\n", "html_static_path = [\"_static\"]\n"]}
