{"filename": "tests/__init__.py", "chunked_list": []}
{"filename": "tests/conftest.py", "chunked_list": ["\"\"\"Test fixtures\"\"\"\n\t# Standard library\n\tfrom pathlib import Path\n\timport sys\n\t# External modules\n\timport pytest\n\t@pytest.fixture\n\tdef test_data_dir():\n\t    \"\"\"Returns the test data directory\"\"\"\n\t    return Path(sys.modules[__name__.split('.')[0]].__file__).parent / 'test_data'\n", "@pytest.fixture\n\tdef ctim_test_data_dir(test_data_dir):\n\t    \"\"\"CTIM test data directory\"\"\"\n\t    return test_data_dir / 'ctim'\n\t@pytest.fixture\n\tdef jpss_test_data_dir(test_data_dir):\n\t    \"\"\"JPSS test data directory\"\"\"\n\t    return test_data_dir / 'jpss'\n\t@pytest.fixture\n\tdef clarreo_test_data_dir(test_data_dir):\n", "    \"\"\"CLARREO test data directory\"\"\"\n\t    return test_data_dir / 'clarreo'\n\t@pytest.fixture\n\tdef suda_test_data_dir(test_data_dir):\n\t    \"\"\"SUDA test data directory\"\"\"\n\t    return test_data_dir / 'suda'\n"]}
{"filename": "tests/integration/test_socket_parsing.py", "chunked_list": ["\"\"\"Mock socket streaming and listener that decodes on the fly\"\"\"\n\t# Standard\n\tfrom multiprocessing import Process\n\timport random\n\timport socket\n\timport time\n\t# Installed\n\timport bitstring\n\timport pytest\n\t# Local\n", "from space_packet_parser.xtcedef import XtcePacketDefinition\n\tfrom space_packet_parser.parser import PacketParser\n\tdef send_data(sender: socket.socket, file: str):\n\t    \"\"\"Send data from a file as bytes via a socket with random chunk sizes and random waits between sending chunks\n\t    Parameters\n\t    ----------\n\t    sender : socket.socket\n\t        Socket over which to send the data.\n\t    file : str\n\t        File to send as bytes over a socket connection\n", "    \"\"\"\n\t    # Read binary file\n\t    with open(file, 'rb') as fh:\n\t        stream = bitstring.ConstBitStream(fh)\n\t        while stream.pos < len(stream):\n\t            time.sleep(random.random() * .1)  # Random sleep up to 1s\n\t            # Send binary data to socket in random chunk sizes\n\t            min_n_bytes = 4096\n\t            max_n_bytes = 4096*2\n\t            random_n_bytes = int(random.random()) * (max_n_bytes - min_n_bytes)\n", "            n_bits_to_send = 8 * (min_n_bytes + random_n_bytes)\n\t            if stream.pos + n_bits_to_send > len(stream):\n\t                n_bits_to_send = len(stream) - stream.pos\n\t            chunk_to_send = stream[stream.pos:stream.pos + n_bits_to_send]\n\t            sender.send(chunk_to_send.bytes)\n\t            stream.pos += n_bits_to_send\n\t        print(\"\\nFinished sending data.\")\n\tdef test_parsing_from_socket(jpss_test_data_dir):\n\t    # Create packet def\n\t    xdef = XtcePacketDefinition(jpss_test_data_dir / 'jpss1_geolocation_xtce_v1.xml')\n", "    # Create packet parser\n\t    parser = PacketParser(packet_definition=xdef)\n\t    # Create socket\n\t    sender, receiver = socket.socketpair()\n\t    receiver.settimeout(3)\n\t    file = jpss_test_data_dir / 'J01_G011_LZ_2021-04-09T00-00-00Z_V01.DAT1'\n\t    p = Process(target=send_data, args=(sender, file,))\n\t    p.start()\n\t    packet_generator = parser.generator(receiver, buffer_read_size_bytes=4096, show_progress=True)\n\t    with pytest.raises(socket.timeout):\n", "        packets = []\n\t        for p in packet_generator:\n\t            packets.append(p)\n\t    assert len(packets) == 7200\n"]}
{"filename": "tests/integration/test_bufferedreader_parsing.py", "chunked_list": ["\"\"\"Integration test for parsing JPSS packets\"\"\"\n\t# Installed\n\timport bitstring\n\t# Local\n\tfrom space_packet_parser import xtcedef\n\tfrom space_packet_parser import parser\n\tdef test_jpss_xtce_packet_parsing(jpss_test_data_dir):\n\t    \"\"\"Test parsing a real XTCE document\"\"\"\n\t    jpss_xtce = jpss_test_data_dir / 'jpss1_geolocation_xtce_v1.xml'\n\t    jpss_definition = xtcedef.XtcePacketDefinition(xtce_document=jpss_xtce)\n", "    assert isinstance(jpss_definition, xtcedef.XtcePacketDefinition)\n\t    jpss_parser = parser.PacketParser(jpss_definition)\n\t    jpss_packet_file = jpss_test_data_dir / 'J01_G011_LZ_2021-04-09T00-00-00Z_V01.DAT1'\n\t    with jpss_packet_file.open('rb') as binary_data:\n\t        jpss_packet_generator = jpss_parser.generator(binary_data, show_progress=True)\n\t        n_packets = 0\n\t        for jpss_packet in jpss_packet_generator:\n\t            assert isinstance(jpss_packet, parser.Packet)\n\t            assert jpss_packet.header['PKT_APID'].raw_value == 11\n\t            assert jpss_packet.header['VERSION'].raw_value == 0\n", "            n_packets += 1\n\t        assert n_packets == 7200\n"]}
{"filename": "tests/integration/__init__.py", "chunked_list": []}
{"filename": "tests/integration/test_csv_based_parsing/__init__.py", "chunked_list": []}
{"filename": "tests/integration/test_csv_based_parsing/test_ctim_parsing.py", "chunked_list": ["\"\"\"Test parsing of CTIM packet data\"\"\"\n\t# Installed\n\timport bitstring\n\t# Local\n\tfrom space_packet_parser import csvdef, parser\n\tdef test_csv_packet_definition_parsing(ctim_test_data_dir):\n\t    \"\"\"Test parsing a real csv document\"\"\"\n\t    test_csv_file = ctim_test_data_dir / 'ct_tlm.csv'\n\t    csv_pkt_def = csvdef.CsvPacketDefinition(test_csv_file)\n\t    test_packet_file = ctim_test_data_dir / 'ccsds_2021_155_14_39_51'\n", "    pkt_binary_data = bitstring.ConstBitStream(filename=test_packet_file)\n\t    parser_inst = parser.PacketParser(csv_pkt_def)\n\t    pkt_gen = parser_inst.generator(pkt_binary_data, show_progress=True)\n\t    packets = list(pkt_gen)\n\t    assert(len(packets) == 1499)\n\t    assert(packets[159].header['PKT_APID'].raw_value == 34)\n\t    assert(packets[159].data['SHCOARSE'].raw_value == 481168702)\n"]}
{"filename": "tests/integration/test_xtce_based_parsing/test_jpss_parsing.py", "chunked_list": ["\"\"\"Integration test for parsing JPSS packets\"\"\"\n\t# Local\n\tfrom space_packet_parser import xtcedef\n\tfrom space_packet_parser import parser\n\tdef test_jpss_xtce_packet_parsing(jpss_test_data_dir):\n\t    \"\"\"Test parsing a real XTCE document\"\"\"\n\t    jpss_xtce = jpss_test_data_dir / 'jpss1_geolocation_xtce_v1.xml'\n\t    jpss_definition = xtcedef.XtcePacketDefinition(xtce_document=jpss_xtce)\n\t    assert isinstance(jpss_definition, xtcedef.XtcePacketDefinition)\n\t    jpss_parser = parser.PacketParser(jpss_definition)\n", "    jpss_packet_file = jpss_test_data_dir / 'J01_G011_LZ_2021-04-09T00-00-00Z_V01.DAT1'\n\t    with jpss_packet_file.open('rb') as binary_data:\n\t        jpss_packet_generator = jpss_parser.generator(binary_data, show_progress=True)\n\t        n_packets = 0\n\t        for jpss_packet in jpss_packet_generator:\n\t            assert isinstance(jpss_packet, parser.Packet)\n\t            assert jpss_packet.header['PKT_APID'].raw_value == 11\n\t            assert jpss_packet.header['VERSION'].raw_value == 0\n\t            n_packets += 1\n\t        assert n_packets == 7200\n"]}
{"filename": "tests/integration/test_xtce_based_parsing/test_suda_parsing.py", "chunked_list": ["\"\"\"Integration tests on SUDA data\n\tThe packet definition used here is intended for IDEX, which is basically a rebuild of the SUDA instrument.\n\tThe data used here is SUDA data but the fields are parsed using IDEX naming conventions.\n\t\"\"\"\n\t# Installed\n\timport bitstring\n\t# Local\n\tfrom space_packet_parser import xtcedef\n\tfrom space_packet_parser import parser\n\tdef parse_hg_waveform(waveform_raw: str):\n", "    \"\"\"Parse a binary string representing a high gain waveform\"\"\"\n\t    w = bitstring.ConstBitStream(bin=waveform_raw)\n\t    ints = []\n\t    while w.pos < len(w):\n\t        w.read('bits:2')  # skip 2. We use bits instead of pad for bitstring 3.0.0 compatibility\n\t        ints += w.readlist(['uint:10']*3)\n\t    return ints\n\tdef parse_lg_waveform(waveform_raw: str):\n\t    \"\"\"Parse a binary string representing a low gain waveform\"\"\"\n\t    w = bitstring.ConstBitStream(bin=waveform_raw)\n", "    ints = []\n\t    while w.pos < len(w):\n\t        w.read('bits:8')  # skip 2\n\t        ints += w.readlist(['uint:12']*2)\n\t    return ints\n\tdef parse_waveform_data(waveform: str, scitype: int):\n\t    \"\"\"Parse the binary string that represents a waveform\"\"\"\n\t    print(f'Parsing waveform for scitype={scitype}')\n\t    if scitype in (2, 4, 8):\n\t        return parse_hg_waveform(waveform)\n", "    else:\n\t        return parse_lg_waveform(waveform)\n\tdef test_suda_xtce_packet_parsing(suda_test_data_dir):\n\t    \"\"\"Test parsing a real XTCE document\"\"\"\n\t    suda_xtce = suda_test_data_dir / 'suda_combined_science_definition.xml'\n\t    suda_definition = xtcedef.XtcePacketDefinition(xtce_document=suda_xtce)\n\t    assert isinstance(suda_definition, xtcedef.XtcePacketDefinition)\n\t    suda_parser = parser.PacketParser(suda_definition)\n\t    suda_packet_file = suda_test_data_dir / 'sciData_2022_130_17_41_53.spl'\n\t    with suda_packet_file.open('rb') as suda_binary_data:\n", "        suda_packet_generator = suda_parser.generator(suda_binary_data,\n\t                                                      skip_header_bits=32,\n\t                                                      show_progress=True)\n\t        for suda_packet in suda_packet_generator:\n\t            assert isinstance(suda_packet, parser.Packet)\n\t            assert suda_packet.header['PKT_APID'].raw_value == 1425, \"APID is not as expected.\"\n\t            assert suda_packet.header['VERSION'].raw_value == 0, \"CCSDS header VERSION incorrect.\"\n\t        suda_binary_data.pos = 0\n\t        suda_packet_generator = suda_parser.generator(suda_binary_data,\n\t                                                      skip_header_bits=32)\n", "        try:\n\t            p = next(suda_packet_generator)\n\t            while True:\n\t                if 'IDX__SCIFETCHTYPE' in p.data:\n\t                    scitype = p.data['IDX__SCIFETCHTYPE'].raw_value\n\t                    print(scitype)\n\t                    if scitype == 1:  # beginning of an event\n\t                        data = {}\n\t                        event_header = p\n\t                        # Each time we encounter a new scitype, we create a new array.\n", "                        p = next(suda_packet_generator)\n\t                        scitype = p.data['IDX__SCIFETCHTYPE'].raw_value\n\t                        print(scitype, end=\", \")\n\t                        data[scitype] = p.data['IDX__SCIFETCHRAW'].raw_value\n\t                        while True:\n\t                            # If we run into the end of the file, this will raise StopIteration\n\t                            p_next = next(suda_packet_generator)\n\t                            next_scitype = p_next.data['IDX__SCIFETCHTYPE'].raw_value\n\t                            print(next_scitype, end=\", \")\n\t                            if next_scitype == scitype:\n", "                                # If the scitype is the same as the last packet, then concatenate them\n\t                                data[scitype] += p_next.data['IDX__SCIFETCHRAW'].raw_value\n\t                            else:\n\t                                # Otherwise check if we are at the end of the event (next scitype==1)\n\t                                if next_scitype == 1:\n\t                                    break\n\t                                scitype = next_scitype\n\t                                data[scitype] = p_next.data['IDX__SCIFETCHRAW'].raw_value\n\t                        p = p_next\n\t                        # If you have more than one event in a file (i.e. scitype 1, 2, 4, 8, 16, 32, 64),\n", "                        # this loop would continue.\n\t                        # For this example, we only have one full event so we have already hit a StopIteration by\n\t                        # this point.\n\t        except StopIteration:\n\t            print(\"\\nEncountered the end of the binary file.\")\n\t            pass\n\t    expectations = {\n\t        2: {'len': 8193, 'mean': 511.8518247284267},\n\t        4: {'len': 8193, 'mean': 510.84450140363725},\n\t        8: {'len': 8193, 'mean': 510.99353106310264},\n", "        16: {'len': 512, 'mean': 2514.470703125},\n\t        32: {'len': 512, 'mean': 1989.7421875},\n\t        64: {'len': 512, 'mean': 2078.119140625}\n\t    }\n\t    # Parse the waveforms according to the scitype present (HG/LG channels encode waveform data differently)\n\t    for scitype, waveform in data.items():\n\t        data[scitype] = parse_waveform_data(waveform, scitype)\n\t        print(f\"{len(data[scitype])} points\")\n\t        mean = sum(data[scitype]) / len(data[scitype])\n\t        print(f\"mean value = {mean}\")\n", "        assert len(data[scitype]) == expectations[scitype]['len'], \"Length of parsed waveform data does not match.\"\n\t        assert mean == expectations[scitype]['mean'], \"Mean value does not match expectation\"\n\t    assert set(data.keys()) == {2, 4, 8, 16, 32, 64}, \"Missing a scitype value.\"\n"]}
{"filename": "tests/integration/test_xtce_based_parsing/__init__.py", "chunked_list": []}
{"filename": "tests/integration/test_xtce_based_parsing/test_inheritance_restrictions.py", "chunked_list": ["\"\"\"Test RestrictionCriteria being used creatively with JPSS data\"\"\"\n\t# Installed\n\timport bitstring\n\t# Local\n\tfrom space_packet_parser import xtcedef\n\tfrom space_packet_parser import parser\n\tdef test_jpss_xtce_packet_parsing(jpss_test_data_dir):\n\t    \"\"\"Test parsing a real XTCE document\"\"\"\n\t    jpss_xtce = jpss_test_data_dir / 'contrived_inheritance_structure.xml'\n\t    jpss_definition = xtcedef.XtcePacketDefinition(xtce_document=jpss_xtce)\n", "    assert isinstance(jpss_definition, xtcedef.XtcePacketDefinition)\n\t    jpss_parser = parser.PacketParser(jpss_definition)\n\t    jpss_packet_file = jpss_test_data_dir / 'J01_G011_LZ_2021-04-09T00-00-00Z_V01.DAT1'\n\t    with jpss_packet_file.open('rb') as binary_data:\n\t        jpss_packet_generator = jpss_parser.generator(binary_data)\n\t        for _ in range(3):  # Iterate through 3 packets and check that the parsed APID remains the same\n\t            jpss_packet = next(jpss_packet_generator)\n\t            assert isinstance(jpss_packet, parser.Packet)\n\t            assert jpss_packet.header['PKT_APID'].raw_value == 11\n\t            assert jpss_packet.header['VERSION'].raw_value == 0\n", "        jpss_packet_generator.close()\n"]}
{"filename": "tests/unit/test_csvdef.py", "chunked_list": ["\"\"\"Tests for the CSV based packet definition\"\"\"\n\t# Installed\n\timport bitstring\n\timport pytest\n\t# Local\n\tfrom space_packet_parser import csvdef, xtcedef, parser\n\tfrom space_packet_parser.csvdef import CsvPacketDefinition\n\t@pytest.mark.parametrize(\n\t    ('dtype_str', 'name', 'expectation'),\n\t    [\n", "        ('U11', 'test_uint', xtcedef.IntegerParameterType(name='test_uint',\n\t                                                          encoding=xtcedef.IntegerDataEncoding(11, 'unsigned'),\n\t                                                          unit='foo')),\n\t        ('U5', 'test_uint', xtcedef.IntegerParameterType(name='test_uint',\n\t                                                         encoding=xtcedef.IntegerDataEncoding(5, 'unsigned'),\n\t                                                         unit='foo')),\n\t        ('UINT11', 'test_uint', xtcedef.IntegerParameterType(name='test_uint',\n\t                                                             encoding=xtcedef.IntegerDataEncoding(11, 'unsigned'),\n\t                                                             unit='foo')),\n\t        ('D3', 'test_discrete', xtcedef.IntegerParameterType(name='test_discrete',\n", "                                                             encoding=xtcedef.IntegerDataEncoding(3, 'unsigned'),\n\t                                                             unit='foo')),\n\t        ('INT16', 'test_uint', xtcedef.IntegerParameterType(name='test_uint',\n\t                                                            encoding=xtcedef.IntegerDataEncoding(16, 'signed'),\n\t                                                            unit='foo')),\n\t        ('I16', 'test_uint', xtcedef.IntegerParameterType(name='test_uint',\n\t                                                          encoding=xtcedef.IntegerDataEncoding(16, 'signed'),\n\t                                                          unit='foo')),\n\t        ('F16', 'test_flt', xtcedef.FloatParameterType(name='test_flt',\n\t                                                       encoding=xtcedef.FloatDataEncoding(16),\n", "                                                       unit='foo')),\n\t        ('Float16', 'test_flt', xtcedef.FloatParameterType(name='test_flt',\n\t                                                           encoding=xtcedef.FloatDataEncoding(16),\n\t                                                           unit='foo')),\n\t        ('C12', 'test_str', xtcedef.StringParameterType(name='test_str',\n\t                                                        encoding=xtcedef.StringDataEncoding(fixed_length=12),\n\t                                                        unit='foo'))\n\t    ]\n\t)\n\tdef test_get_param_type_from_str(dtype_str: str, name, expectation):\n", "    actual = csvdef.CsvPacketDefinition.get_param_type_from_str(dtype=dtype_str,\n\t                                                                param_type_name=name,\n\t                                                                unit='foo')\n\t    assert (actual == expectation)\n\t# TODO: Test the elements of\n\tdef test_csv_packet_definition(ctim_test_data_dir):\n\t    \"\"\"Test parsing a real csv document\"\"\"\n\t    test_csv_file = ctim_test_data_dir / 'ct_tlm.csv'\n\t    csv_pkt_def = CsvPacketDefinition(test_csv_file)\n\t    assert isinstance(csv_pkt_def, CsvPacketDefinition)\n", "    test_packet_file = ctim_test_data_dir / 'ccsds_2021_155_14_39_51'\n\t    pkt_binary_data = bitstring.ConstBitStream(filename=test_packet_file)\n\t    parser_inst = parser.PacketParser(csv_pkt_def)\n\t    pkt_gen = parser_inst.generator(pkt_binary_data)\n\t    packet = next(pkt_gen)\n\t    assert isinstance(packet, parser.Packet)\n"]}
{"filename": "tests/unit/__init__.py", "chunked_list": []}
{"filename": "tests/unit/test_parser.py", "chunked_list": ["\"\"\"Tests for space_packet_parser.parser\"\"\"\n\t# Installed\n\timport bitstring\n\timport pytest\n\t# Local\n\tfrom space_packet_parser import parser\n\t@pytest.mark.parametrize(\n\t    ('name', 'raw_value', 'unit', 'derived_value', 'valid'),\n\t    [\n\t        ('TEST', 0, 'smoots', 10, True),\n", "        ('TEST', 10, None, None, True),\n\t        (None, 10, 'foo', 10, False),\n\t        ('TEST', None, None, None, False)\n\t    ]\n\t)\n\tdef test_parsed_data_item(name, raw_value, unit, derived_value, valid):\n\t    \"\"\"Test ParsedDataItem\"\"\"\n\t    if valid:\n\t        pdi = parser.ParsedDataItem(name, raw_value, unit, derived_value)\n\t    else:\n", "        with pytest.raises(ValueError):\n\t            pdi = parser.ParsedDataItem(name, raw_value, unit, derived_value)\n"]}
{"filename": "tests/unit/test_xtcedef.py", "chunked_list": ["\"\"\"Tests for space_packet_parser.xtcedef\"\"\"\n\timport bitstring\n\timport pytest\n\tfrom xml.etree import ElementTree\n\tfrom space_packet_parser import xtcedef, parser\n\tTEST_NAMESPACE = {'xtce': 'http://www.omg.org/space/xtce'}\n\tdef test_attr_comparable():\n\t    \"\"\"Test abstract class that allows comparisons based on all non-callable attributes\"\"\"\n\t    class TestClass(xtcedef.AttrComparable):\n\t        \"\"\"Test Class\"\"\"\n", "        def __init__(self, public, private, dunder):\n\t            self.public = public\n\t            self._private = private\n\t            self.__dunder = dunder  # Dundered attributes are ignored (they get mangled by class name on construction)\n\t        @property\n\t        def entertained(self):\n\t            \"\"\"Properties are compared\"\"\"\n\t            return 10 * self.public\n\t        def ignored(self, x):\n\t            \"\"\"Methods are ignored\"\"\"\n", "            return 2*x\n\t    a = TestClass(1, 2, 9)\n\t    a.__doc__ = \"foobar\"  # Ignored dunder method\n\t    b = TestClass(1, 2, 10)\n\t    assert a == b\n\t    a.public += 1  # Change an attribute that _does_ get compared\n\t    with pytest.raises(AssertionError):\n\t        assert a == b\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'test_parsed_data', 'current_parsed_value', 'expected_comparison_result'),\n", "    [\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"==\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n\t         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 678)}, None, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"eq\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n", "         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 668)}, None, False),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"!=\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n\t         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 678)}, None, False),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"neq\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n", "         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 658)}, None, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"&lt;\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n\t         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 679)}, None, False),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"lt\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n", "         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 670)}, None, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"&gt;\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n\t         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 678)}, None, False),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"gt\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n", "         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 679)}, None, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"&lt;=\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n\t         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 660)}, None, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"leq\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n", "         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 690)}, None, False),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"&gt;=\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n\t         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 660)}, None, False),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"geq\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n", "         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 690)}, None, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"==\" value=\"678\" parameterRef=\"MSN__PARAM\" useCalibratedValue=\"false\"/>\n\t\"\"\",\n\t         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 678, None, 690)}, None, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"==\" value=\"678\" parameterRef=\"MSN__PARAM\" useCalibratedValue=\"true\"/>\n\t\"\"\",\n", "         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 3, None, 678)}, None, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"==\" value=\"foostring\" parameterRef=\"MSN__PARAM\" useCalibratedValue=\"false\"/>\n\t\"\"\",\n\t         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 'foostring', None, 'calibratedfoostring')}, None, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"==\" value=\"3.14\" parameterRef=\"MSN__PARAM\"/>\n\t\"\"\",\n", "         {'MSN__PARAM': parser.ParsedDataItem('MSN__PARAM', 1, None, 3.14)}, None, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"==\" value=\"3.0\" parameterRef=\"REFERENCE_TO_OWN_RAW_VAL\"/>\n\t\"\"\",\n\t         {}, 3.0, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"==\" value=\"3\" parameterRef=\"REFERENCE_TO_OWN_RAW_VAL\"/>\n\t\"\"\",\n", "         {}, 3, True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"==\" value=\"foostr\" parameterRef=\"REFERENCE_TO_OWN_RAW_VAL\"/>\n\t\"\"\",\n\t         {}, \"foostr\", True),\n\t        (\"\"\"\n\t<xtce:Comparison xmlns:xtce=\"http://www.omg.org/space/xtce\" \n\t    comparisonOperator=\"==\" value=\"3.0\" parameterRef=\"REFERENCE_TO_OWN_RAW_VAL\"/>\n\t\"\"\",\n", "         {}, 3, xtcedef.ComparisonError(\"Fails to parse a float string 3.0 into an int\")),\n\t    ]\n\t)\n\tdef test_comparison(xml_string, test_parsed_data, current_parsed_value, expected_comparison_result):\n\t    \"\"\"Test Comparison object\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expected_comparison_result, Exception):\n\t        with pytest.raises(type(expected_comparison_result)):\n\t            comparison = xtcedef.Comparison.from_match_criteria_xml_element(element, TEST_NAMESPACE)\n\t            comparison.evaluate(test_parsed_data, current_parsed_value)\n", "    else:\n\t        comparison = xtcedef.Comparison.from_match_criteria_xml_element(element, TEST_NAMESPACE)\n\t        assert comparison.evaluate(test_parsed_data, current_parsed_value) == expected_comparison_result\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'test_parsed_data', 'expected_condition_result'),\n\t    [\n\t        (\"\"\"\n\t<xtce:Condition xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:ParameterInstanceRef parameterRef=\"P1\"/>\n\t    <xtce:ComparisonOperator>&gt;=</xtce:ComparisonOperator>\n", "    <xtce:ParameterInstanceRef parameterRef=\"P2\"/>\n\t</xtce:Condition>\n\t\"\"\",\n\t         {'P1': parser.ParsedDataItem('P1', 4, None, 700),\n\t          'P2': parser.ParsedDataItem('P2', 3, None, 678)}, True),\n\t        (\"\"\"\n\t<xtce:Condition xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:ParameterInstanceRef parameterRef=\"P1\"/>\n\t    <xtce:ComparisonOperator>&gt;=</xtce:ComparisonOperator>\n\t    <xtce:Value>4</xtce:Value>\n", "</xtce:Condition>\n\t\"\"\",\n\t         {'P1': parser.ParsedDataItem('P1', 4, None, 700)}, True),\n\t        (\"\"\"\n\t<xtce:Condition xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:ParameterInstanceRef parameterRef=\"P1\"/>\n\t    <xtce:ComparisonOperator>==</xtce:ComparisonOperator>\n\t    <xtce:ParameterInstanceRef parameterRef=\"P2\"/>\n\t</xtce:Condition>\n\t\"\"\",\n", "         {'P1': parser.ParsedDataItem('P1', 4, None, 700),\n\t          'P2': parser.ParsedDataItem('P2', 3, None, 678)}, False),\n\t        (\"\"\"\n\t<xtce:Condition xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:ParameterInstanceRef parameterRef=\"P1\" useCalibratedValue=\"false\"/>\n\t    <xtce:ComparisonOperator>==</xtce:ComparisonOperator>\n\t    <xtce:ParameterInstanceRef parameterRef=\"P2\" useCalibratedValue=\"false\"/>\n\t</xtce:Condition>\n\t\"\"\",\n\t         {'P1': parser.ParsedDataItem('P1', 'abcd', None),\n", "          'P2': parser.ParsedDataItem('P2', 'abcd', None)}, True),\n\t        (\"\"\"\n\t<xtce:Condition xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:ParameterInstanceRef parameterRef=\"P1\"/>\n\t    <xtce:ComparisonOperator>==</xtce:ComparisonOperator>\n\t    <xtce:ParameterInstanceRef parameterRef=\"P2\"/>\n\t</xtce:Condition>\n\t\"\"\",\n\t         {'P1': parser.ParsedDataItem('P1', 1, None, 3.14),\n\t          'P2': parser.ParsedDataItem('P2', 180, None, 3.14)}, True),\n", "    ]\n\t)\n\tdef test_condition(xml_string, test_parsed_data, expected_condition_result):\n\t    \"\"\"Test Condition object\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    condition = xtcedef.Condition.from_match_criteria_xml_element(element, TEST_NAMESPACE)\n\t    assert condition.evaluate(test_parsed_data, None) == expected_condition_result\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'test_parsed_data', 'expected_result'),\n\t    [\n", "        (\"\"\"\n\t<xtce:BooleanExpression xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:ORedConditions>\n\t        <xtce:Condition>\n\t            <xtce:ParameterInstanceRef parameterRef=\"P\"/>\n\t            <xtce:ComparisonOperator>==</xtce:ComparisonOperator>\n\t            <xtce:Value>100</xtce:Value>\n\t        </xtce:Condition>\n\t        <xtce:ANDedConditions>\n\t            <xtce:Condition>\n", "                <xtce:ParameterInstanceRef parameterRef=\"P2\"/>\n\t                <xtce:ComparisonOperator>&lt;=</xtce:ComparisonOperator>\n\t                <xtce:ParameterInstanceRef parameterRef=\"P3\"/>\n\t            </xtce:Condition>\n\t            <xtce:Condition>\n\t                <xtce:ParameterInstanceRef parameterRef=\"P4\"/>\n\t                <xtce:ComparisonOperator>!=</xtce:ComparisonOperator>\n\t                <xtce:Value>99</xtce:Value>\n\t            </xtce:Condition>\n\t        </xtce:ANDedConditions>\n", "    </xtce:ORedConditions>\n\t</xtce:BooleanExpression>\n\t\"\"\",\n\t         {'P': parser.ParsedDataItem('P', 4, None, 0),\n\t          'P2': parser.ParsedDataItem('P2', 4, None, 700),\n\t          'P3': parser.ParsedDataItem('P3', 4, None, 701),\n\t          'P4': parser.ParsedDataItem('P4', 4, None, 98)}, True),\n\t        (\"\"\"\n\t<xtce:BooleanExpression xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:ANDedConditions>\n", "        <xtce:Condition>\n\t            <xtce:ParameterInstanceRef parameterRef=\"P\"/>\n\t            <xtce:ComparisonOperator>==</xtce:ComparisonOperator>\n\t            <xtce:Value>100</xtce:Value>\n\t        </xtce:Condition>\n\t        <xtce:Condition>\n\t            <xtce:ParameterInstanceRef parameterRef=\"P0\"/>\n\t            <xtce:ComparisonOperator>&gt;=</xtce:ComparisonOperator>\n\t            <xtce:ParameterInstanceRef parameterRef=\"P1\"/>\n\t        </xtce:Condition>\n", "        <xtce:ORedConditions>\n\t            <xtce:Condition>\n\t                <xtce:ParameterInstanceRef parameterRef=\"P2\"/>\n\t                <xtce:ComparisonOperator>&lt;=</xtce:ComparisonOperator>\n\t                <xtce:ParameterInstanceRef parameterRef=\"P3\"/>\n\t            </xtce:Condition>\n\t            <xtce:Condition>\n\t                <xtce:ParameterInstanceRef parameterRef=\"P4\"/>\n\t                <xtce:ComparisonOperator>!=</xtce:ComparisonOperator>\n\t                <xtce:Value>99</xtce:Value>\n", "            </xtce:Condition>\n\t        </xtce:ORedConditions>\n\t    </xtce:ANDedConditions>\n\t</xtce:BooleanExpression>\n\t\"\"\",\n\t         {'P': parser.ParsedDataItem('P', 4, None, 100),\n\t          'P0': parser.ParsedDataItem('P0', 4, None, 678),\n\t          'P1': parser.ParsedDataItem('P1', 4, None, 500),\n\t          'P2': parser.ParsedDataItem('P2', 4, None, 700),\n\t          'P3': parser.ParsedDataItem('P3', 4, None, 701),\n", "          'P4': parser.ParsedDataItem('P4', 4, None, 99)}, True),\n\t    ]\n\t)\n\tdef test_boolean_expression(xml_string, test_parsed_data, expected_result):\n\t    \"\"\"Test BooleanExpression object\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expected_result, Exception):\n\t        with pytest.raises(type(expected_result)):\n\t            xtcedef.BooleanExpression.from_match_criteria_xml_element(element, TEST_NAMESPACE)\n\t    else:\n", "        expression = xtcedef.BooleanExpression.from_match_criteria_xml_element(element, TEST_NAMESPACE)\n\t        assert expression.evaluate(test_parsed_data, current_parsed_value=None) == expected_result\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'test_parsed_data', 'expected_lookup_result'),\n\t    [\n\t        (\"\"\"\n\t<xtce:DiscreteLookup value=\"10\" xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:Comparison useCalibratedValue=\"false\" parameterRef=\"P1\" value=\"1\"/>\n\t</xtce:DiscreteLookup>\n\t\"\"\",\n", "         {'P1': parser.ParsedDataItem('P1', 1, None, 678)}, 10),\n\t        (\"\"\"\n\t<xtce:DiscreteLookup value=\"10\" xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:Comparison useCalibratedValue=\"false\" parameterRef=\"P1\" value=\"1\"/>\n\t</xtce:DiscreteLookup>\n\t\"\"\",\n\t         {'P1': parser.ParsedDataItem('P1', 0, None, 678)}, None),\n\t        (\"\"\"\n\t<xtce:DiscreteLookup value=\"11\" xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:ComparisonList>\n", "        <xtce:Comparison comparisonOperator=\"&gt;=\" value=\"678\" parameterRef=\"MSN__PARAM1\"/>\n\t        <xtce:Comparison comparisonOperator=\"&lt;\" value=\"4096\" parameterRef=\"MSN__PARAM2\"/>\n\t    </xtce:ComparisonList>\n\t</xtce:DiscreteLookup>\n\t\"\"\",\n\t         {\n\t             'MSN__PARAM1': parser.ParsedDataItem('MSN__PARAM1', 3, None, 680),\n\t             'MSN__PARAM2': parser.ParsedDataItem('MSN__PARAM2', 3, None, 3000)\n\t         }, 11),\n\t    ]\n", ")\n\tdef test_discrete_lookup(xml_string, test_parsed_data, expected_lookup_result):\n\t    \"\"\"Test DiscreteLookup object\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    discrete_lookup = xtcedef.DiscreteLookup.from_discrete_lookup_xml_element(element, TEST_NAMESPACE)\n\t    assert discrete_lookup.evaluate(test_parsed_data, current_parsed_value=None) == expected_lookup_result\n\t# ----------------\n\t# Calibrator Tests\n\t# ----------------\n\t@pytest.mark.parametrize(\n", "    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n\t<xtce:ContextCalibrator xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:ContextMatch>\n\t        <xtce:ComparisonList>\n\t            <xtce:Comparison comparisonOperator=\"&gt;=\" value=\"678\" parameterRef=\"EXI__FPGAT\"/>\n\t            <xtce:Comparison comparisonOperator=\"&lt;\" value=\"4096\" parameterRef=\"EXI__FPGAT\"/>\n\t        </xtce:ComparisonList>\n\t    </xtce:ContextMatch>\n", "    <xtce:Calibrator>\n\t        <xtce:PolynomialCalibrator>\n\t            <xtce:Term exponent=\"0\" coefficient=\"0.5\"/>\n\t            <xtce:Term exponent=\"1\" coefficient=\"1.5\"/>\n\t            <xtce:Term exponent=\"2\" coefficient=\"-0.045\"/>\n\t            <xtce:Term exponent=\"3\" coefficient=\"1.25\"/>\n\t            <xtce:Term exponent=\"4\" coefficient=\"2.5E-3\"/>\n\t        </xtce:PolynomialCalibrator>\n\t    </xtce:Calibrator>\n\t</xtce:ContextCalibrator>\n", "\"\"\",\n\t         xtcedef.ContextCalibrator(\n\t             match_criteria=[\n\t                 xtcedef.Comparison(required_value='678', referenced_parameter='EXI__FPGAT', operator='>=',\n\t                                    use_calibrated_value=True),\n\t                 xtcedef.Comparison(required_value='4096', referenced_parameter='EXI__FPGAT', operator='<',\n\t                                    use_calibrated_value=True),\n\t             ],\n\t             calibrator=xtcedef.PolynomialCalibrator(coefficients=[\n\t                 xtcedef.PolynomialCoefficient(coefficient=0.5, exponent=0),\n", "                 xtcedef.PolynomialCoefficient(coefficient=1.5, exponent=1),\n\t                 xtcedef.PolynomialCoefficient(coefficient=-0.045, exponent=2),\n\t                 xtcedef.PolynomialCoefficient(coefficient=1.25, exponent=3),\n\t                 xtcedef.PolynomialCoefficient(coefficient=0.0025, exponent=4)\n\t             ]))),\n\t        (\"\"\"\n\t<xtce:ContextCalibrator xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:ContextMatch>\n\t        <xtce:Comparison comparisonOperator=\"!=\" value=\"3.14\" parameterRef=\"EXI__FPGAT\"/>\n\t    </xtce:ContextMatch>\n", "    <xtce:Calibrator>\n\t        <xtce:PolynomialCalibrator>\n\t            <xtce:Term exponent=\"0\" coefficient=\"0.5\"/>\n\t            <xtce:Term exponent=\"1\" coefficient=\"1.5\"/>\n\t            <xtce:Term exponent=\"2\" coefficient=\"-0.045\"/>\n\t            <xtce:Term exponent=\"3\" coefficient=\"1.25\"/>\n\t            <xtce:Term exponent=\"4\" coefficient=\"2.5E-3\"/>\n\t        </xtce:PolynomialCalibrator>\n\t    </xtce:Calibrator>\n\t</xtce:ContextCalibrator>\n", "\"\"\",\n\t         xtcedef.ContextCalibrator(\n\t             match_criteria=[\n\t                 xtcedef.Comparison(required_value='3.14', referenced_parameter='EXI__FPGAT', operator='!=',\n\t                                    use_calibrated_value=True),\n\t             ],\n\t             calibrator=xtcedef.PolynomialCalibrator(coefficients=[\n\t                 xtcedef.PolynomialCoefficient(coefficient=0.5, exponent=0),\n\t                 xtcedef.PolynomialCoefficient(coefficient=1.5, exponent=1),\n\t                 xtcedef.PolynomialCoefficient(coefficient=-0.045, exponent=2),\n", "                 xtcedef.PolynomialCoefficient(coefficient=1.25, exponent=3),\n\t                 xtcedef.PolynomialCoefficient(coefficient=0.0025, exponent=4)\n\t             ])))\n\t    ]\n\t)\n\tdef test_context_calibrator(xml_string, expectation):\n\t    \"\"\"Test parsing a ContextCalibrator from an XML element\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    result = xtcedef.ContextCalibrator.from_context_calibrator_xml_element(element, TEST_NAMESPACE)\n\t    assert result == expectation\n", "@pytest.mark.parametrize(\n\t    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n\t<xtce:SplineCalibrator xmlns:xtce=\"http://www.omg.org/space/xtce\" order=\"zero\" extrapolate=\"true\">\n\t    <xtce:SplinePoint raw=\"1\" calibrated=\"10\"/>\n\t    <xtce:SplinePoint raw=\"2.7\" calibrated=\"100.948\"/>\n\t    <xtce:SplinePoint raw=\"3\" calibrated=\"5E2\"/>\n\t</xtce:SplineCalibrator> \n\t\"\"\",\n", "         xtcedef.SplineCalibrator(order=0, extrapolate=True, points=[\n\t             xtcedef.SplinePoint(raw=1, calibrated=10),\n\t             xtcedef.SplinePoint(raw=2.7, calibrated=100.948),\n\t             xtcedef.SplinePoint(raw=3, calibrated=500),\n\t         ])),\n\t        (\"\"\"\n\t<xtce:SplineCalibrator xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:SplinePoint raw=\"1\" calibrated=\"10\"/>\n\t    <xtce:SplinePoint raw=\"2.7\" calibrated=\"100.948\"/>\n\t    <xtce:SplinePoint raw=\"3\" calibrated=\"5E2\"/>\n", "</xtce:SplineCalibrator> \n\t\"\"\",\n\t         xtcedef.SplineCalibrator(order=0, extrapolate=False, points=[\n\t             xtcedef.SplinePoint(raw=1, calibrated=10),\n\t             xtcedef.SplinePoint(raw=2.7, calibrated=100.948),\n\t             xtcedef.SplinePoint(raw=3, calibrated=500),\n\t         ])),\n\t        ]\n\t)\n\tdef test_spline_calibrator(xml_string: str, expectation):\n", "    \"\"\"Test parsing a StringDataEncoding from an XML string\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expectation, Exception):\n\t        with pytest.raises(type(expectation)):\n\t            xtcedef.SplineCalibrator.from_calibrator_xml_element(element, TEST_NAMESPACE)\n\t    else:\n\t        result = xtcedef.SplineCalibrator.from_calibrator_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n\t    ('xq', 'order', 'extrapolate', 'expectation'),\n", "    [\n\t        # Zero order\n\t        (-10, 0, True, 0.),\n\t        (-10, 0, False, xtcedef.CalibrationError()),\n\t        (-1, 0, True, 0.),\n\t        (-1, 0, False, 0.),\n\t        (1.5, 0, False, 3.),\n\t        (5., 0, False, xtcedef.CalibrationError()),\n\t        (5., 0, True, 2.),\n\t        # First order\n", "        (-10, 1, True, -27.),\n\t        (-10, 1, False, xtcedef.CalibrationError()),\n\t        (-1, 1, True, 0.),\n\t        (-1, 1, False, 0.),\n\t        (1.5, 1, False, 2.25),\n\t        (5., 1, False, xtcedef.CalibrationError()),\n\t        (5., 1, True, 0.5),\n\t    ],\n\t)\n\tdef test_spline_calibrator_calibrate(xq, order, extrapolate, expectation):\n", "    \"\"\"Test spline default_calibrator interpolation routines\"\"\"\n\t    spline_points = [\n\t        xtcedef.SplinePoint(-1., 0.),\n\t        xtcedef.SplinePoint(0., 3.),\n\t        xtcedef.SplinePoint(2., 2),\n\t    ]\n\t    calibrator = xtcedef.SplineCalibrator(spline_points, order=order, extrapolate=extrapolate)\n\t    if isinstance(expectation, Exception):\n\t        with pytest.raises(type(expectation)):\n\t            calibrator.calibrate(xq)\n", "    else:\n\t        result = calibrator.calibrate(xq)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n\t<xtce:PolynomialCalibrator xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:Term exponent=\"0\" coefficient=\"0.5\"/>\n\t    <xtce:Term exponent=\"1\" coefficient=\"1.5\"/>\n", "    <xtce:Term exponent=\"2\" coefficient=\"-0.045\"/>\n\t    <xtce:Term exponent=\"3\" coefficient=\"1.25\"/>\n\t    <xtce:Term exponent=\"4\" coefficient=\"2.5E-3\"/>\n\t</xtce:PolynomialCalibrator> \n\t\"\"\",\n\t         xtcedef.PolynomialCalibrator(coefficients=[\n\t             xtcedef.PolynomialCoefficient(coefficient=0.5, exponent=0),\n\t             xtcedef.PolynomialCoefficient(coefficient=1.5, exponent=1),\n\t             xtcedef.PolynomialCoefficient(coefficient=-0.045, exponent=2),\n\t             xtcedef.PolynomialCoefficient(coefficient=1.25, exponent=3),\n", "             xtcedef.PolynomialCoefficient(coefficient=0.0025, exponent=4),\n\t         ])),\n\t        ]\n\t)\n\tdef test_polynomial_calibrator(xml_string: str, expectation):\n\t    \"\"\"Test parsing a StringDataEncoding from an XML string\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expectation, Exception):\n\t        with pytest.raises(type(expectation)):\n\t            xtcedef.PolynomialCalibrator.from_calibrator_xml_element(element, TEST_NAMESPACE)\n", "    else:\n\t        result = xtcedef.PolynomialCalibrator.from_calibrator_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n\t    ('xq', 'expectation'),\n\t    [\n\t        (-10., 101.5),\n\t        (0., 1.5),\n\t        (50, 2501.5)\n\t    ],\n", ")\n\tdef test_polynomial_calibrator_calibrate(xq, expectation):\n\t    \"\"\"Test polynomial default_calibrator interpolation routines\"\"\"\n\t    polynomial_coefficients = [\n\t        xtcedef.PolynomialCoefficient(1.5, 0),\n\t        xtcedef.PolynomialCoefficient(0, 1),\n\t        xtcedef.PolynomialCoefficient(1., 2)\n\t    ]\n\t    calibrator = xtcedef.PolynomialCalibrator(polynomial_coefficients)\n\t    if isinstance(expectation, Exception):\n", "        with pytest.raises(type(expectation)):\n\t            calibrator.calibrate(xq)\n\t    else:\n\t        result = calibrator.calibrate(xq)\n\t        assert result == expectation\n\t# ------------------\n\t# DataEncoding Tests\n\t# ------------------\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'expectation'),\n", "    [\n\t        (\"\"\"\n\t<xtce:StringDataEncoding encoding=\"utf-16-be\" xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:SizeInBits>\n\t        <xtce:TerminationChar>0058</xtce:TerminationChar>\n\t    </xtce:SizeInBits>\n\t</xtce:StringDataEncoding>\n\t\"\"\",\n\t         xtcedef.StringDataEncoding(termination_character='0058', encoding='utf-16-be')),\n\t        (\"\"\"\n", "<xtce:StringDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:SizeInBits>\n\t        <xtce:Fixed>\n\t            <xtce:FixedValue>17</xtce:FixedValue>\n\t        </xtce:Fixed>\n\t    </xtce:SizeInBits>\n\t</xtce:StringDataEncoding>\n\t\"\"\",\n\t         xtcedef.StringDataEncoding(fixed_length=17)),\n\t        (\"\"\"\n", "<xtce:StringDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:SizeInBits>\n\t        <xtce:Fixed>\n\t            <xtce:DynamicValue>\n\t                <xtce:ParameterInstanceRef parameterRef=\"SizeFromThisParameter\"/>\n\t                <xtce:LinearAdjustment intercept=\"25\" slope=\"8\"/> \n\t            </xtce:DynamicValue> \n\t        </xtce:Fixed>\n\t    </xtce:SizeInBits>\n\t</xtce:StringDataEncoding>\n", "\"\"\",\n\t         xtcedef.StringDataEncoding(dynamic_length_reference='SizeFromThisParameter',\n\t                                    length_linear_adjuster=object())),\n\t        (\"\"\"\n\t<xtce:StringDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:SizeInBits>\n\t        <xtce:Fixed>\n\t            <xtce:DiscreteLookupList>\n\t                <xtce:DiscreteLookup value=\"10\">\n\t                    <xtce:Comparison parameterRef=\"P1\" value=\"1\"/>\n", "                </xtce:DiscreteLookup>\n\t                <xtce:DiscreteLookup value=\"25\">\n\t                    <xtce:Comparison parameterRef=\"P1\" value=\"2\"/>\n\t                </xtce:DiscreteLookup>\n\t            </xtce:DiscreteLookupList> \n\t        </xtce:Fixed>\n\t    </xtce:SizeInBits>\n\t</xtce:StringDataEncoding>\n\t\"\"\",\n\t         xtcedef.StringDataEncoding(\n", "             discrete_lookup_length=[\n\t                 xtcedef.DiscreteLookup([xtcedef.Comparison('1', 'P1')], 10),\n\t                 xtcedef.DiscreteLookup([xtcedef.Comparison('2', 'P1')], 25)\n\t             ])),\n\t        (\"\"\"\n\t<xtce:StringDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:SizeInBits>\n\t        <xtce:Fixed>\n\t            <xtce:InvalidTag>9000</xtce:InvalidTag>\n\t        </xtce:Fixed>\n", "    </xtce:SizeInBits>\n\t</xtce:StringDataEncoding>\n\t\"\"\",\n\t         xtcedef.ElementNotFoundError())\n\t        ]\n\t)\n\tdef test_string_data_encoding(xml_string: str, expectation):\n\t    \"\"\"Test parsing a StringDataEncoding from an XML string\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expectation, Exception):\n", "        with pytest.raises(type(expectation)):\n\t            xtcedef.StringDataEncoding.from_data_encoding_xml_element(element, TEST_NAMESPACE)\n\t    else:\n\t        result = xtcedef.StringDataEncoding.from_data_encoding_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n\t<xtce:IntegerDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\" sizeInBits=\"4\" encoding=\"unsigned\"/>\n", "\"\"\",\n\t         xtcedef.IntegerDataEncoding(size_in_bits=4, encoding='unsigned')),\n\t        (\"\"\"\n\t<xtce:IntegerDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\" sizeInBits=\"16\" encoding=\"unsigned\">\n\t    <xtce:DefaultCalibrator>\n\t        <xtce:PolynomialCalibrator>\n\t            <xtce:Term exponent=\"1\" coefficient=\"1.215500e-02\"/>\n\t            <xtce:Term exponent=\"0\" coefficient=\"2.540000e+00\"/>\n\t        </xtce:PolynomialCalibrator>\n\t    </xtce:DefaultCalibrator>\n", "</xtce:IntegerDataEncoding>\n\t\"\"\",\n\t         xtcedef.IntegerDataEncoding(\n\t             size_in_bits=16, encoding='unsigned',\n\t             default_calibrator=xtcedef.PolynomialCalibrator([\n\t                 xtcedef.PolynomialCoefficient(0.012155, 1), xtcedef.PolynomialCoefficient(2.54, 0)\n\t             ]))),\n\t        (\"\"\"\n\t<xtce:IntegerDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\" sizeInBits=\"12\" encoding=\"unsigned\">\n\t    <xtce:ContextCalibratorList>\n", "        <xtce:ContextCalibrator>\n\t            <xtce:ContextMatch>\n\t                <xtce:ComparisonList>\n\t                    <xtce:Comparison comparisonOperator=\"&gt;=\" value=\"0\" parameterRef=\"MSN__PARAM\"/>\n\t                    <xtce:Comparison comparisonOperator=\"&lt;\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t                </xtce:ComparisonList>\n\t            </xtce:ContextMatch>\n\t            <xtce:Calibrator>\n\t                <xtce:PolynomialCalibrator>\n\t                    <xtce:Term exponent=\"0\" coefficient=\"142.998\"/>\n", "                    <xtce:Term exponent=\"1\" coefficient=\"-0.349712\"/>\n\t                </xtce:PolynomialCalibrator>\n\t            </xtce:Calibrator>\n\t        </xtce:ContextCalibrator>\n\t        <xtce:ContextCalibrator>\n\t            <xtce:ContextMatch>\n\t                <xtce:ComparisonList>\n\t                    <xtce:Comparison comparisonOperator=\"&gt;=\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t                    <xtce:Comparison comparisonOperator=\"&lt;=\" value=\"4096\" parameterRef=\"MSN__PARAM\"/>\n\t                </xtce:ComparisonList>\n", "            </xtce:ContextMatch>\n\t            <xtce:Calibrator>\n\t                <xtce:PolynomialCalibrator>\n\t                    <xtce:Term exponent=\"0\" coefficient=\"100.488\"/>\n\t                    <xtce:Term exponent=\"1\" coefficient=\"-0.110197\"/>\n\t                </xtce:PolynomialCalibrator>\n\t            </xtce:Calibrator>\n\t        </xtce:ContextCalibrator>\n\t    </xtce:ContextCalibratorList>\n\t    </xtce:IntegerDataEncoding>\n", "\"\"\",\n\t         xtcedef.IntegerDataEncoding(size_in_bits=12, encoding='unsigned',\n\t                                     default_calibrator=None,\n\t                                     context_calibrators=[\n\t                                         xtcedef.ContextCalibrator(\n\t                                             match_criteria=[xtcedef.Comparison(required_value='0', operator=\">=\",\n\t                                                                                referenced_parameter='MSN__PARAM'),\n\t                                                             xtcedef.Comparison(required_value='678', operator=\"<\",\n\t                                                                                referenced_parameter='MSN__PARAM')],\n\t                                             calibrator=xtcedef.PolynomialCalibrator(\n", "                                                 coefficients=[xtcedef.PolynomialCoefficient(142.998, 0),\n\t                                                               xtcedef.PolynomialCoefficient(-0.349712, 1)])),\n\t                                         xtcedef.ContextCalibrator(\n\t                                             match_criteria=[xtcedef.Comparison(required_value='678', operator=\">=\",\n\t                                                                                referenced_parameter='MSN__PARAM'),\n\t                                                             xtcedef.Comparison(required_value='4096', operator=\"<=\",\n\t                                                                                referenced_parameter='MSN__PARAM')],\n\t                                             calibrator=xtcedef.PolynomialCalibrator(\n\t                                                 coefficients=[xtcedef.PolynomialCoefficient(100.488, 0),\n\t                                                               xtcedef.PolynomialCoefficient(-0.110197, 1)]))\n", "                                     ])),\n\t    ]\n\t)\n\tdef test_integer_data_encoding(xml_string: str, expectation):\n\t    \"\"\"Test parsing an IntegerDataEncoding from an XML string\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expectation, Exception):\n\t        with pytest.raises(type(expectation)):\n\t            xtcedef.IntegerDataEncoding.from_data_encoding_xml_element(element, TEST_NAMESPACE)\n\t    else:\n", "        result = xtcedef.IntegerDataEncoding.from_data_encoding_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n\t<xtce:FloatDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\" sizeInBits=\"4\" encoding=\"IEEE-754\"/>\n\t\"\"\",\n\t         xtcedef.FloatDataEncoding(size_in_bits=4, encoding='IEEE-754')),\n\t        (\"\"\"\n", "<xtce:FloatDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\" sizeInBits=\"16\">\n\t    <xtce:DefaultCalibrator>\n\t        <xtce:PolynomialCalibrator>\n\t            <xtce:Term exponent=\"1\" coefficient=\"1.215500e-02\"/>\n\t            <xtce:Term exponent=\"0\" coefficient=\"2.540000e+00\"/>\n\t        </xtce:PolynomialCalibrator>\n\t    </xtce:DefaultCalibrator>\n\t</xtce:FloatDataEncoding>\n\t\"\"\",\n\t         xtcedef.FloatDataEncoding(\n", "             size_in_bits=16, encoding='IEEE-754',\n\t             default_calibrator=xtcedef.PolynomialCalibrator([\n\t                 xtcedef.PolynomialCoefficient(0.012155, 1), xtcedef.PolynomialCoefficient(2.54, 0)\n\t             ]))),\n\t        (\"\"\"\n\t<xtce:FloatDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\" sizeInBits=\"16\">\n\t    <xtce:ContextCalibratorList>\n\t        <xtce:ContextCalibrator>\n\t            <xtce:ContextMatch>\n\t                <xtce:ComparisonList>\n", "                    <xtce:Comparison comparisonOperator=\"&gt;=\" value=\"0\" parameterRef=\"MSN__PARAM\"/>\n\t                    <xtce:Comparison comparisonOperator=\"&lt;\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t                </xtce:ComparisonList>\n\t            </xtce:ContextMatch>\n\t            <xtce:Calibrator>\n\t                <xtce:PolynomialCalibrator>\n\t                    <xtce:Term exponent=\"0\" coefficient=\"142.998\"/>\n\t                    <xtce:Term exponent=\"1\" coefficient=\"-0.349712\"/>\n\t                </xtce:PolynomialCalibrator>\n\t            </xtce:Calibrator>\n", "        </xtce:ContextCalibrator>\n\t        <xtce:ContextCalibrator>\n\t            <xtce:ContextMatch>\n\t                <xtce:ComparisonList>\n\t                    <xtce:Comparison comparisonOperator=\"&gt;=\" value=\"678\" parameterRef=\"MSN__PARAM\"/>\n\t                    <xtce:Comparison comparisonOperator=\"&lt;=\" value=\"4096\" parameterRef=\"MSN__PARAM\"/>\n\t                </xtce:ComparisonList>\n\t            </xtce:ContextMatch>\n\t            <xtce:Calibrator>\n\t                <xtce:PolynomialCalibrator>\n", "                    <xtce:Term exponent=\"0\" coefficient=\"100.488\"/>\n\t                    <xtce:Term exponent=\"1\" coefficient=\"-0.110197\"/>\n\t                </xtce:PolynomialCalibrator>\n\t            </xtce:Calibrator>\n\t        </xtce:ContextCalibrator>\n\t    </xtce:ContextCalibratorList>\n\t    <xtce:DefaultCalibrator>\n\t        <xtce:PolynomialCalibrator>\n\t            <xtce:Term exponent=\"1\" coefficient=\"1.215500e-02\"/>\n\t            <xtce:Term exponent=\"0\" coefficient=\"2.540000e+00\"/>\n", "        </xtce:PolynomialCalibrator>\n\t    </xtce:DefaultCalibrator>\n\t</xtce:FloatDataEncoding>\n\t\"\"\",\n\t         xtcedef.FloatDataEncoding(\n\t             size_in_bits=16, encoding='IEEE-754',\n\t             default_calibrator=xtcedef.PolynomialCalibrator([\n\t                 xtcedef.PolynomialCoefficient(0.012155, 1), xtcedef.PolynomialCoefficient(2.54, 0)\n\t             ]),\n\t             context_calibrators=[\n", "                 xtcedef.ContextCalibrator(\n\t                     match_criteria=[xtcedef.Comparison(required_value='0', operator=\">=\",\n\t                                                        referenced_parameter='MSN__PARAM'),\n\t                                     xtcedef.Comparison(required_value='678', operator=\"<\",\n\t                                                        referenced_parameter='MSN__PARAM')],\n\t                     calibrator=xtcedef.PolynomialCalibrator(\n\t                         coefficients=[xtcedef.PolynomialCoefficient(142.998, 0),\n\t                                       xtcedef.PolynomialCoefficient(-0.349712, 1)])),\n\t                 xtcedef.ContextCalibrator(\n\t                     match_criteria=[xtcedef.Comparison(required_value='678', operator=\">=\",\n", "                                                        referenced_parameter='MSN__PARAM'),\n\t                                     xtcedef.Comparison(required_value='4096', operator=\"<=\",\n\t                                                        referenced_parameter='MSN__PARAM')],\n\t                     calibrator=xtcedef.PolynomialCalibrator(\n\t                         coefficients=[xtcedef.PolynomialCoefficient(100.488, 0),\n\t                                       xtcedef.PolynomialCoefficient(-0.110197, 1)]))\n\t             ]\n\t         )),\n\t    ]\n\t)\n", "def test_float_data_encoding(xml_string: str, expectation):\n\t    \"\"\"Test parsing an FloatDataEncoding from an XML string\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expectation, Exception):\n\t        with pytest.raises(type(expectation)):\n\t            xtcedef.FloatDataEncoding.from_data_encoding_xml_element(element, TEST_NAMESPACE)\n\t    else:\n\t        result = xtcedef.FloatDataEncoding.from_data_encoding_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n", "    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n\t<xtce:BinaryDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:SizeInBits>\n\t        <xtce:FixedValue>256</xtce:FixedValue>\n\t    </xtce:SizeInBits>\n\t</xtce:BinaryDataEncoding>\n\t\"\"\",\n\t         xtcedef.BinaryDataEncoding(fixed_size_in_bits=256)),\n", "        (\"\"\"\n\t<xtce:BinaryDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:SizeInBits>\n\t        <xtce:DynamicValue>\n\t            <xtce:ParameterInstanceRef parameterRef=\"SizeFromThisParameter\"/>\n\t            <xtce:LinearAdjustment intercept=\"25\" slope=\"8\"/>\n\t        </xtce:DynamicValue>\n\t    </xtce:SizeInBits>\n\t</xtce:BinaryDataEncoding>\n\t\"\"\",\n", "         xtcedef.BinaryDataEncoding(\n\t             size_reference_parameter='SizeFromThisParameter',\n\t             linear_adjuster=lambda x: 25 + 8*x)),\n\t        (\"\"\"\n\t<xtce:BinaryDataEncoding xmlns:xtce=\"http://www.omg.org/space/xtce\">\n\t    <xtce:SizeInBits>\n\t        <xtce:DiscreteLookupList>\n\t            <xtce:DiscreteLookup value=\"10\">\n\t                <xtce:Comparison parameterRef=\"P1\" value=\"1\"/>\n\t            </xtce:DiscreteLookup>\n", "            <xtce:DiscreteLookup value=\"25\">\n\t                <xtce:Comparison parameterRef=\"P1\" value=\"2\"/>\n\t            </xtce:DiscreteLookup>\n\t        </xtce:DiscreteLookupList>\n\t    </xtce:SizeInBits>\n\t</xtce:BinaryDataEncoding>\n\t\"\"\",\n\t         xtcedef.BinaryDataEncoding(size_discrete_lookup_list=[\n\t                 xtcedef.DiscreteLookup([xtcedef.Comparison('1', 'P1')], 10),\n\t                 xtcedef.DiscreteLookup([xtcedef.Comparison('2', 'P1')], 25)\n", "             ])),\n\t    ]\n\t)\n\tdef test_binary_data_encoding(xml_string: str, expectation):\n\t    \"\"\"Test parsing an BinaryDataEncoding from an XML string\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expectation, Exception):\n\t        with pytest.raises(type(expectation)):\n\t            xtcedef.BinaryDataEncoding.from_data_encoding_xml_element(element, TEST_NAMESPACE)\n\t    else:\n", "        result = xtcedef.BinaryDataEncoding.from_data_encoding_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t# -------------------\n\t# ParameterType Tests\n\t# -------------------\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n\t<xtce:StringParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_STRING_Type\">\n", "    <xtce:UnitSet/>\n\t    <xtce:StringDataEncoding>\n\t        <xtce:SizeInBits>\n\t            <xtce:Fixed>\n\t                <xtce:FixedValue>40</xtce:FixedValue>\n\t            </xtce:Fixed>\n\t        </xtce:SizeInBits>\n\t    </xtce:StringDataEncoding>\n\t</xtce:StringParameterType> \n\t\"\"\",\n", "         xtcedef.StringParameterType(name='TEST_STRING_Type',\n\t                                     encoding=xtcedef.StringDataEncoding(fixed_length=40))),\n\t        (\"\"\"\n\t<xtce:StringParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_STRING_Type\">\n\t    <xtce:StringDataEncoding>\n\t        <xtce:SizeInBits>\n\t            <xtce:LeadingSize sizeInBitsOfSizeTag=\"17\"/>\n\t        </xtce:SizeInBits>\n\t    </xtce:StringDataEncoding>\n\t</xtce:StringParameterType> \n", "\"\"\",\n\t         xtcedef.StringParameterType(name='TEST_STRING_Type',\n\t                                     encoding=xtcedef.StringDataEncoding(leading_length_size=17))),\n\t        (\"\"\"\n\t<xtce:StringParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_STRING_Type\">\n\t    <xtce:StringDataEncoding>\n\t        <xtce:SizeInBits>\n\t            <xtce:TerminationChar>00</xtce:TerminationChar>\n\t        </xtce:SizeInBits>\n\t    </xtce:StringDataEncoding>\n", "</xtce:StringParameterType> \n\t\"\"\",\n\t         xtcedef.StringParameterType(name='TEST_STRING_Type',\n\t                                     encoding=xtcedef.StringDataEncoding(termination_character='00'))),\n\t    ]\n\t)\n\tdef test_string_parameter_type(xml_string: str, expectation):\n\t    \"\"\"Test parsing an StringParameterType from an XML string\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expectation, Exception):\n", "        with pytest.raises(type(expectation)):\n\t            xtcedef.StringParameterType.from_parameter_type_xml_element(element, TEST_NAMESPACE)\n\t    else:\n\t        result = xtcedef.StringParameterType.from_parameter_type_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n\t    ('parameter_type', 'parsed_data', 'packet_data', 'expected'),\n\t    [\n\t        # Fixed length test\n\t        (xtcedef.StringParameterType(\n", "            'TEST_STRING',\n\t            xtcedef.StringDataEncoding(fixed_length=3,\n\t                                       length_linear_adjuster=lambda x: 8*x)),\n\t         {},  # Don't need parsed_data for leading length parsing\n\t         # This is still 123X456 but with 011 prepended (a 3-bit representation of the number 3)\n\t         '0b00110001001100100011001101011000001101000011010100110110',\n\t         '123'),\n\t        # Dynamic reference length\n\t        (xtcedef.StringParameterType(\n\t            'TEST_STRING',\n", "            xtcedef.StringDataEncoding(dynamic_length_reference='STR_LEN',\n\t                                       use_calibrated_value=False,\n\t                                       length_linear_adjuster=lambda x: 8*x)),\n\t         {'STR_LEN': parser.ParsedDataItem('STR_LEN', 8, None)},\n\t         '0b01000010010000010100010000100000010101110100111101001100010001100100011101000001010100100100001001000001',\n\t         'BAD WOLF'),\n\t        # Discrete lookup test\n\t        (xtcedef.StringParameterType(\n\t            'TEST_STRING',\n\t            xtcedef.StringDataEncoding(discrete_lookup_length=[\n", "                xtcedef.DiscreteLookup([\n\t                    xtcedef.Comparison(7, 'P1', '>'),\n\t                    xtcedef.Comparison(99, 'P2', '==', use_calibrated_value=False)\n\t                ], lookup_value=8)\n\t            ], length_linear_adjuster=lambda x: 8*x)),\n\t         {'P1': parser.ParsedDataItem('P1', 7, None, 7.55), 'P2': parser.ParsedDataItem('P2', 99, None, 100)},\n\t         '0b01000010010000010100010000100000010101110100111101001100010001100100011101000001010100100100001001000001',\n\t         'BAD WOLF'),\n\t        # Termination character tests\n\t        (xtcedef.StringParameterType(\n", "            'TEST_STRING',\n\t            xtcedef.StringDataEncoding(encoding='utf-8',\n\t                                       termination_character='58')),\n\t         {},  # Don't need parsed_data for termination character\n\t         # 123X456, termination character is X\n\t         '0b00110001001100100011001101011000001101000011010100110110',\n\t         '123'),\n\t        (xtcedef.StringParameterType(\n\t            'TEST_STRING',\n\t            xtcedef.StringDataEncoding(encoding='utf-16-le',\n", "                                       termination_character='5800')),\n\t         {},  # Don't need parsed_data for termination character\n\t         # 123X456, termination character is X\n\t         '0b0011000100000000001100100000000000110011000000000101100000000000001101000000000000110101000000000011011000000000',\n\t         '123'),\n\t        (xtcedef.StringParameterType(\n\t            'TEST_STRING',\n\t            xtcedef.StringDataEncoding(encoding='utf-16-be',\n\t                                       termination_character='0058')),\n\t         {},  # Don't need parsed_data for termination character\n", "         '0b0000000000110001000000000011001000000000001100110000000001011000000000000011010000000000001101010000000000110110',\n\t         '123'),\n\t        # Leading length test\n\t        (xtcedef.StringParameterType(\n\t            'TEST_STRING',\n\t            xtcedef.StringDataEncoding(leading_length_size=5)),\n\t         {},  # Don't need parsed_data for leading length parsing\n\t         # This is still 123X456 but with 011 prepended (a 3-bit representation of the number 3)\n\t         '0b1100000110001001100100011001101011000001101000011010100110110',\n\t         '123'),\n", "    ]\n\t)\n\tdef test_string_parameter_parsing(parameter_type, parsed_data, packet_data, expected):\n\t    \"\"\"Test parsing a string parameter\"\"\"\n\t    raw, _ = parameter_type.parse_value(bitstring.ConstBitStream(packet_data), parsed_data)\n\t    assert raw == expected\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n", "<xtce:IntegerParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_INT_Type\">\n\t    <xtce:UnitSet>\n\t        <xtce:Unit>smoot</xtce:Unit>\n\t    </xtce:UnitSet>\n\t    <xtce:IntegerDataEncoding sizeInBits=\"16\" encoding=\"unsigned\"/>\n\t</xtce:IntegerParameterType>\n\t\"\"\",\n\t         xtcedef.IntegerParameterType(name='TEST_INT_Type', unit='smoot',\n\t                                      encoding=xtcedef.IntegerDataEncoding(size_in_bits=16, encoding='unsigned'))),\n\t        (\"\"\"\n", "<xtce:IntegerParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_INT_Type\">\n\t    <xtce:UnitSet>\n\t        <xtce:Unit>smoot</xtce:Unit>\n\t    </xtce:UnitSet>\n\t    <xtce:IntegerDataEncoding sizeInBits=\"16\" encoding=\"unsigned\">\n\t        <xtce:DefaultCalibrator>\n\t            <xtce:PolynomialCalibrator>\n\t                <xtce:Term exponent=\"0\" coefficient=\"2772.24\"/>\n\t                <xtce:Term exponent=\"1\" coefficient=\"-41.6338\"/>\n\t                <xtce:Term exponent=\"2\" coefficient=\"-0.185486\"/>\n", "            </xtce:PolynomialCalibrator>\n\t        </xtce:DefaultCalibrator>\n\t    </xtce:IntegerDataEncoding>\n\t</xtce:IntegerParameterType>\n\t\"\"\",\n\t         xtcedef.IntegerParameterType(name='TEST_INT_Type', unit='smoot',\n\t                                      encoding=xtcedef.IntegerDataEncoding(\n\t                                       size_in_bits=16, encoding='unsigned',\n\t                                       default_calibrator=xtcedef.PolynomialCalibrator([\n\t                                           xtcedef.PolynomialCoefficient(2772.24, 0),\n", "                                           xtcedef.PolynomialCoefficient(-41.6338, 1),\n\t                                           xtcedef.PolynomialCoefficient(-0.185486, 2)\n\t                                       ])\n\t                                   ))),\n\t        (\"\"\"\n\t<xtce:IntegerParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_INT_Type\">\n\t    <xtce:UnitSet>\n\t        <xtce:Unit>smoot</xtce:Unit>\n\t    </xtce:UnitSet>\n\t    <xtce:IntegerDataEncoding sizeInBits=\"16\" encoding=\"unsigned\">\n", "        <xtce:DefaultCalibrator>\n\t            <xtce:SplineCalibrator order=\"zero\">\n\t                <xtce:SplinePoint raw=\"1\" calibrated=\"10\"/>\n\t                <xtce:SplinePoint raw=\"2\" calibrated=\"100\"/>\n\t                <xtce:SplinePoint raw=\"3\" calibrated=\"500\"/>\n\t            </xtce:SplineCalibrator>\n\t        </xtce:DefaultCalibrator>\n\t    </xtce:IntegerDataEncoding>\n\t</xtce:IntegerParameterType>\n\t\"\"\",\n", "         xtcedef.IntegerParameterType(name='TEST_INT_Type', unit='smoot',\n\t                                      encoding=xtcedef.IntegerDataEncoding(\n\t                                       size_in_bits=16, encoding='unsigned',\n\t                                       default_calibrator=xtcedef.SplineCalibrator(\n\t                                           order=0, extrapolate=False,\n\t                                           points=[\n\t                                               xtcedef.SplinePoint(raw=1, calibrated=10),\n\t                                               xtcedef.SplinePoint(raw=2, calibrated=100),\n\t                                               xtcedef.SplinePoint(raw=3, calibrated=500),\n\t                                           ]\n", "                                       )))),\n\t    ]\n\t)\n\tdef test_integer_parameter_type(xml_string: str, expectation):\n\t    \"\"\"Test parsing an IntegerParameterType from an XML string\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expectation, Exception):\n\t        with pytest.raises(type(expectation)):\n\t            xtcedef.IntegerParameterType.from_parameter_type_xml_element(element, TEST_NAMESPACE)\n\t    else:\n", "        result = xtcedef.IntegerParameterType.from_parameter_type_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n\t    ('parameter_type', 'parsed_data', 'packet_data', 'expected'),\n\t    [\n\t        (xtcedef.IntegerParameterType('TEST_INT', xtcedef.IntegerDataEncoding(16, 'unsigned')),\n\t         {}, '0b1000000000000000', 32768),\n\t        (xtcedef.IntegerParameterType('TEST_INT', xtcedef.IntegerDataEncoding(16, 'signed')),\n\t         {}, '0b1111111111010110', -42),\n\t        (xtcedef.IntegerParameterType(\n", "            'TEST_INT',\n\t            xtcedef.IntegerDataEncoding(\n\t                16, 'signed',\n\t                context_calibrators=[\n\t                    xtcedef.ContextCalibrator([\n\t                        xtcedef.Condition(left_param='PKT_APID', operator='==',\n\t                                          right_value=1101, left_use_calibrated_value=False,\n\t                                          right_use_calibrated_value=False)],\n\t                        xtcedef.PolynomialCalibrator([xtcedef.PolynomialCoefficient(5, 0),\n\t                                                      xtcedef.PolynomialCoefficient(2, 1)]))\n", "                ])),\n\t         {'PKT_APID': parser.ParsedDataItem('PKT_APID', 1101)}, '0b1111111111010110', -79),\n\t    ]\n\t)\n\tdef test_integer_parameter_parsing(parameter_type, parsed_data, packet_data, expected):\n\t    \"\"\"Testing parsing an integer parameters\"\"\"\n\t    raw, derived = parameter_type.parse_value(bitstring.ConstBitStream(packet_data), parsed_data)\n\t    if derived:\n\t        assert derived == expected\n\t    else:\n", "        assert raw == expected\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n\t<xtce:FloatParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_INT_Type\">\n\t    <xtce:UnitSet>\n\t        <xtce:Unit>smoot</xtce:Unit>\n\t    </xtce:UnitSet>\n\t    <xtce:IntegerDataEncoding sizeInBits=\"16\" encoding=\"unsigned\"/>\n", "</xtce:FloatParameterType>\n\t\"\"\",\n\t         xtcedef.FloatParameterType(name='TEST_INT_Type', unit='smoot',\n\t                                    encoding=xtcedef.IntegerDataEncoding(size_in_bits=16, encoding='unsigned'))),\n\t        (\"\"\"\n\t<xtce:FloatParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_INT_Type\">\n\t    <xtce:UnitSet>\n\t        <xtce:Unit>smoot</xtce:Unit>\n\t    </xtce:UnitSet>\n\t    <xtce:IntegerDataEncoding sizeInBits=\"16\" encoding=\"unsigned\">\n", "        <xtce:DefaultCalibrator>\n\t            <xtce:PolynomialCalibrator>\n\t                <xtce:Term exponent=\"0\" coefficient=\"2772.24\"/>\n\t                <xtce:Term exponent=\"1\" coefficient=\"-41.6338\"/>\n\t                <xtce:Term exponent=\"2\" coefficient=\"-0.185486\"/>\n\t            </xtce:PolynomialCalibrator>\n\t        </xtce:DefaultCalibrator>\n\t    </xtce:IntegerDataEncoding>\n\t</xtce:FloatParameterType>\n\t\"\"\",\n", "         xtcedef.FloatParameterType(name='TEST_INT_Type', unit='smoot',\n\t                                    encoding=xtcedef.IntegerDataEncoding(\n\t                                     size_in_bits=16, encoding='unsigned',\n\t                                     default_calibrator=xtcedef.PolynomialCalibrator([\n\t                                         xtcedef.PolynomialCoefficient(2772.24, 0),\n\t                                         xtcedef.PolynomialCoefficient(-41.6338, 1),\n\t                                         xtcedef.PolynomialCoefficient(-0.185486, 2)\n\t                                     ])\n\t                                    ))),\n\t        (\"\"\"\n", "<xtce:FloatParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_INT_Type\">\n\t    <xtce:UnitSet>\n\t        <xtce:Unit>smoot</xtce:Unit>\n\t    </xtce:UnitSet>\n\t    <xtce:IntegerDataEncoding sizeInBits=\"16\" encoding=\"unsigned\">\n\t        <xtce:DefaultCalibrator>\n\t            <xtce:SplineCalibrator>\n\t                <xtce:SplinePoint raw=\"1\" calibrated=\"10\"/>\n\t                <xtce:SplinePoint raw=\"2\" calibrated=\"100\"/>\n\t                <xtce:SplinePoint raw=\"3\" calibrated=\"500\"/>\n", "            </xtce:SplineCalibrator>\n\t        </xtce:DefaultCalibrator>\n\t    </xtce:IntegerDataEncoding>\n\t</xtce:FloatParameterType>\n\t\"\"\",\n\t         xtcedef.FloatParameterType(name='TEST_INT_Type', unit='smoot',\n\t                                    encoding=xtcedef.IntegerDataEncoding(\n\t                                     size_in_bits=16, encoding='unsigned',\n\t                                     default_calibrator=xtcedef.SplineCalibrator(\n\t                                         order=0, extrapolate=False,\n", "                                         points=[\n\t                                             xtcedef.SplinePoint(raw=1, calibrated=10.),\n\t                                             xtcedef.SplinePoint(raw=2, calibrated=100.),\n\t                                             xtcedef.SplinePoint(raw=3, calibrated=500.),\n\t                                         ]\n\t                                     )))),\n\t    ]\n\t)\n\tdef test_float_parameter_type(xml_string: str, expectation):\n\t    \"\"\"Test parsing an FloatParameterType from an XML string\"\"\"\n", "    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expectation, Exception):\n\t        with pytest.raises(type(expectation)):\n\t            xtcedef.FloatParameterType.from_parameter_type_xml_element(element, TEST_NAMESPACE)\n\t    else:\n\t        result = xtcedef.FloatParameterType.from_parameter_type_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n\t    ('parameter_type', 'parsed_data', 'packet_data', 'expected'),\n\t    [\n", "        (xtcedef.FloatParameterType('TEST_FLOAT', xtcedef.FloatDataEncoding(32)),\n\t         {}, '0b01000000010010010000111111010000', 3.14159),\n\t        (xtcedef.FloatParameterType(\n\t            'TEST_FLOAT',\n\t            xtcedef.IntegerDataEncoding(\n\t                16, 'signed',\n\t                context_calibrators=[\n\t                    xtcedef.ContextCalibrator([\n\t                        xtcedef.Condition(left_param='PKT_APID', operator='==',\n\t                                          right_value=1101, left_use_calibrated_value=False,\n", "                                          right_use_calibrated_value=False)],\n\t                        xtcedef.PolynomialCalibrator([xtcedef.PolynomialCoefficient(5.6, 0),\n\t                                                      xtcedef.PolynomialCoefficient(2.1, 1)]))\n\t                ])),\n\t         {'PKT_APID': parser.ParsedDataItem('PKT_APID', 1101)}, '0b1111111111010110', -82.600000),\n\t    ]\n\t)\n\tdef test_float_parameter_parsing(parameter_type, parsed_data, packet_data, expected):\n\t    \"\"\"Test parsing float parameters\"\"\"\n\t    raw, derived = parameter_type.parse_value(bitstring.ConstBitStream(packet_data), parsed_data)\n", "    if derived:\n\t        # NOTE: These results are rounded due to the imprecise storage of floats\n\t        assert round(derived, 5) == expected\n\t    else:\n\t        assert round(raw, 5) == expected\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n\t<xtce:EnumeratedParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_ENUM_Type\">\n", "    <xtce:UnitSet/>\n\t    <xtce:IntegerDataEncoding sizeInBits=\"2\" encoding=\"unsigned\"/>\n\t    <xtce:EnumerationList>\n\t        <xtce:Enumeration label=\"BOOT_POR\" value=\"0\"/>\n\t        <xtce:Enumeration label=\"BOOT_RETURN\" value=\"1\"/>\n\t        <xtce:Enumeration label=\"OP_LOW\" value=\"2\"/>\n\t        <xtce:Enumeration label=\"OP_HIGH\" value=\"3\"/>\n\t    </xtce:EnumerationList>\n\t</xtce:EnumeratedParameterType>\n\t\"\"\",\n", "         xtcedef.EnumeratedParameterType(name='TEST_ENUM_Type',\n\t                                         encoding=xtcedef.IntegerDataEncoding(size_in_bits=2, encoding='unsigned'),\n\t                                         enumeration={'BOOT_POR': 0, 'BOOT_RETURN': 1, 'OP_LOW': 2, 'OP_HIGH': 3})),\n\t    ]\n\t)\n\tdef test_enumerated_parameter_type(xml_string: str, expectation):\n\t    \"\"\"Test parsing an EnumeratedParameterType from an XML string\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n\t    if isinstance(expectation, Exception):\n\t        with pytest.raises(type(expectation)):\n", "            xtcedef.EnumeratedParameterType.from_parameter_type_xml_element(element, TEST_NAMESPACE)\n\t    else:\n\t        result = xtcedef.EnumeratedParameterType.from_parameter_type_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n\t    ('parameter_type', 'parsed_data', 'packet_data', 'expected'),\n\t    [\n\t        (xtcedef.EnumeratedParameterType('TEST_ENUM', xtcedef.IntegerDataEncoding(16, 'unsigned'), {'NOMINAL': 32768}),\n\t         {}, '0b1000000000000000', 'NOMINAL'),\n\t        (xtcedef.EnumeratedParameterType(\n", "            'TEST_FLOAT',\n\t            xtcedef.IntegerDataEncoding(16, 'signed'),  {'VAL_LOW': -42}),\n\t         {}, '0b1111111111010110', 'VAL_LOW'),\n\t    ]\n\t)\n\tdef test_enumerated_parameter_parsing(parameter_type, parsed_data, packet_data, expected):\n\t    \"\"\"\"Test parsing enumerated parameters\"\"\"\n\t    raw, derived = parameter_type.parse_value(bitstring.ConstBitStream(packet_data), parsed_data)\n\t    if derived:\n\t        # NOTE: These results are rounded due to the imprecise storage of floats\n", "        assert derived == expected\n\t    else:\n\t        assert raw == expected\n\t@pytest.mark.parametrize(\n\t    ('xml_string', 'expectation'),\n\t    [\n\t        (\"\"\"\n\t<xtce:BinaryParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_PARAM_Type\">\n\t    <xtce:UnitSet>\n\t        <xtce:Unit>smoot</xtce:Unit>\n", "    </xtce:UnitSet>\n\t    <xtce:BinaryDataEncoding>\n\t        <xtce:SizeInBits>\n\t            <xtce:FixedValue>256</xtce:FixedValue>\n\t        </xtce:SizeInBits>\n\t    </xtce:BinaryDataEncoding>\n\t</xtce:BinaryParameterType>\n\t\"\"\",\n\t         xtcedef.BinaryParameterType(name='TEST_PARAM_Type', unit='smoot',\n\t                                     encoding=xtcedef.BinaryDataEncoding(fixed_size_in_bits=256))),\n", "        (\"\"\"\n\t<xtce:BinaryParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_PARAM_Type\">\n\t    <xtce:UnitSet/>\n\t    <xtce:BinaryDataEncoding>\n\t        <xtce:SizeInBits>\n\t            <xtce:FixedValue>128</xtce:FixedValue>\n\t        </xtce:SizeInBits>\n\t    </xtce:BinaryDataEncoding>\n\t</xtce:BinaryParameterType>\n\t\"\"\",\n", "         xtcedef.BinaryParameterType(name='TEST_PARAM_Type', unit=None,\n\t                                     encoding=xtcedef.BinaryDataEncoding(fixed_size_in_bits=128))),\n\t        (\"\"\"\n\t<xtce:BinaryParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_PARAM_Type\">\n\t    <xtce:UnitSet/>\n\t    <xtce:BinaryDataEncoding>\n\t        <xtce:SizeInBits>\n\t            <xtce:DynamicValue>\n\t                <xtce:ParameterInstanceRef useCalibratedValue=\"false\" parameterRef=\"SizeFromThisParameter\"/>\n\t                <xtce:LinearAdjustment intercept=\"25\" slope=\"8\"/>\n", "            </xtce:DynamicValue>\n\t        </xtce:SizeInBits>\n\t    </xtce:BinaryDataEncoding>\n\t</xtce:BinaryParameterType>\n\t\"\"\",\n\t         xtcedef.BinaryParameterType(name='TEST_PARAM_Type',\n\t                                     encoding=xtcedef.BinaryDataEncoding(\n\t                                         size_reference_parameter='SizeFromThisParameter',\n\t                                         use_calibrated_value=False,\n\t                                         linear_adjuster=lambda x: x))),\n", "        (\"\"\"\n\t<xtce:BinaryParameterType xmlns:xtce=\"http://www.omg.org/space/xtce\" name=\"TEST_PARAM_Type\">\n\t    <xtce:UnitSet/>\n\t    <xtce:BinaryDataEncoding>\n\t        <xtce:SizeInBits>\n\t            <xtce:DynamicValue>\n\t                <xtce:ParameterInstanceRef parameterRef=\"SizeFromThisParameter\"/>\n\t            </xtce:DynamicValue>\n\t        </xtce:SizeInBits>\n\t    </xtce:BinaryDataEncoding>\n", "</xtce:BinaryParameterType>\n\t\"\"\",\n\t         xtcedef.BinaryParameterType(name='TEST_PARAM_Type', unit=None,\n\t                                     encoding=xtcedef.BinaryDataEncoding(\n\t                                         size_reference_parameter='SizeFromThisParameter'))),\n\t    ]\n\t)\n\tdef test_binary_parameter_type(xml_string: str, expectation):\n\t    \"\"\"Test parsing an BinaryParameterType from an XML string\"\"\"\n\t    element = ElementTree.fromstring(xml_string)\n", "    if isinstance(expectation, Exception):\n\t        with pytest.raises(type(expectation)):\n\t            xtcedef.BinaryParameterType.from_parameter_type_xml_element(element, TEST_NAMESPACE)\n\t    else:\n\t        result = xtcedef.BinaryParameterType.from_parameter_type_xml_element(element, TEST_NAMESPACE)\n\t        assert result == expectation\n\t@pytest.mark.parametrize(\n\t    ('parameter_type', 'parsed_data', 'packet_data', 'expected'),\n\t    [\n\t        # fixed size\n", "        (xtcedef.BinaryParameterType(\n\t            'TEST_BIN',\n\t            xtcedef.BinaryDataEncoding(fixed_size_in_bits=16)),\n\t         {},\n\t         '0b0011010000110010010100110000000001001011000000000100100100000000',\n\t         '0011010000110010'),\n\t        # discrete lookup list size\n\t        (xtcedef.BinaryParameterType(\n\t            'TEST_BIN',\n\t            xtcedef.BinaryDataEncoding(size_discrete_lookup_list=[\n", "                xtcedef.DiscreteLookup([\n\t                    xtcedef.Comparison(required_value=7.4, referenced_parameter='P1',\n\t                                       operator='==', use_calibrated_value=True)\n\t                ], lookup_value=2)\n\t            ], linear_adjuster=lambda x: 8*x)),\n\t         {'P1': parser.ParsedDataItem('P1', 1, None, 7.4)},\n\t         '0b0011010000110010010100110000000001001011000000000100100100000000',\n\t         '0011010000110010'),\n\t        # dynamic size reference to other parameter\n\t        (xtcedef.BinaryParameterType(\n", "            'TEST_BIN',\n\t            xtcedef.BinaryDataEncoding(size_reference_parameter='BIN_LEN',\n\t                                       use_calibrated_value=False, linear_adjuster=lambda x: 8*x)),\n\t         {'BIN_LEN': parser.ParsedDataItem('BIN_LEN', 2, None)},\n\t         '0b0011010000110010010100110000000001001011000000000100100100000000',\n\t         '0011010000110010'),\n\t    ]\n\t)\n\tdef test_binary_parameter_parsing(parameter_type, parsed_data, packet_data, expected):\n\t    \"\"\"Test parsing binary parameters\"\"\"\n", "    raw, _ = parameter_type.parse_value(bitstring.ConstBitStream(packet_data), parsed_data)\n\t    assert raw == expected\n\t# ---------------\n\t# Parameter Tests\n\t# ---------------\n\tdef test_parameter():\n\t    \"\"\"Test Parameter\"\"\"\n\t    xtcedef.Parameter(name='TEST_INT',\n\t                      parameter_type=xtcedef.IntegerParameterType(\n\t                       name='TEST_INT_Type',\n", "                       unit='floops',\n\t                       encoding=xtcedef.IntegerDataEncoding(size_in_bits=16, encoding='unsigned')))\n"]}
{"filename": "space_packet_parser/parser.py", "chunked_list": ["\"\"\"Module for parsing CCSDS packets using packet definitions\"\"\"\n\t# Standard\n\tfrom collections import namedtuple\n\timport datetime as dt\n\timport io\n\timport logging\n\timport socket\n\timport time\n\tfrom typing import BinaryIO, Tuple\n\timport warnings\n", "# Installed\n\timport bitstring\n\t# Local\n\tfrom space_packet_parser import xtcedef, csvdef\n\tlogger = logging.getLogger(__name__)\n\tCcsdsPacketHeaderElement = namedtuple('CcsdsPacketHeaderElement', ['name', 'format_string'])\n\tCCSDS_HEADER_DEFINITION = [\n\t    CcsdsPacketHeaderElement('VERSION', 'uint:3'),\n\t    CcsdsPacketHeaderElement('TYPE', 'uint:1'),\n\t    CcsdsPacketHeaderElement('SEC_HDR_FLG', 'uint:1'),\n", "    CcsdsPacketHeaderElement('PKT_APID', 'uint:11'),\n\t    CcsdsPacketHeaderElement('SEQ_FLGS', 'uint:2'),\n\t    CcsdsPacketHeaderElement('SRC_SEQ_CTR', 'uint:14'),\n\t    CcsdsPacketHeaderElement('PKT_LEN', 'uint:16')\n\t]\n\tCCSDS_HEADER_LENGTH_BITS = 48\n\tPacket = namedtuple('Packet', ['header', 'data'])\n\tclass ParsedDataItem(xtcedef.AttrComparable):\n\t    \"\"\"Representation of a parsed parameter\"\"\"\n\t    def __init__(self, name: str, raw_value: any, unit: str = None, derived_value: float or str = None):\n", "        \"\"\"Constructor\n\t        Parameters\n\t        ----------\n\t        name : str\n\t            Parameter name\n\t        unit : str\n\t            Parameter units\n\t        raw_value : any\n\t            Raw representation of the parsed value. May be lots of different types but most often an integer\n\t        derived_value : float or str\n", "            May be a calibrated value or an enum lookup\n\t        \"\"\"\n\t        if name is None or raw_value is None:\n\t            raise ValueError(\"Invalid ParsedDataItem. Must define name and raw_value.\")\n\t        self.name = name\n\t        self.raw_value = raw_value\n\t        self.unit = unit\n\t        self.derived_value = derived_value\n\t    def __repr__(self):\n\t        return (f\"{self.__class__.__name__}(\"\n", "                f\"{self.name}, raw={self.raw_value}, derived={self.derived_value}, unit={self.unit}\"\n\t                f\")\")\n\tclass UnrecognizedPacketTypeError(Exception):\n\t    \"\"\"Error raised when we can't figure out which kind of packet we are dealing with based on the header\"\"\"\n\t    def __init__(self, *args, partial_data: dict = None):\n\t        \"\"\"\n\t        Parameters\n\t        ----------\n\t        partial_data : dict, Optional\n\t            Data parsed so far (for debugging at higher levels)\n", "        \"\"\"\n\t        super().__init__(*args)\n\t        self.partial_data = partial_data\n\tclass PacketParser:\n\t    \"\"\"Class for parsing CCSDS packets\"\"\"\n\t    def __init__(self,\n\t                 packet_definition: xtcedef.XtcePacketDefinition or csvdef.CsvPacketDefinition,\n\t                 word_size: int = None):\n\t        \"\"\"Constructor\n\t        Parameters\n", "        ----------\n\t        packet_definition: xtcedef.XtcePacketDefinition or csvdef.CsvPacketDefinition\n\t            The packet definition object to use for parsing incoming data.\n\t        word_size: int, Optional\n\t            Number of bits per word. If set, binary parameters are assumed to end on a word boundary and any unused bits\n\t            at the end of each binary parameter are skipped. Default is no word boundary enforcement. Typical usecase\n\t            is 32bit words.\n\t        \"\"\"\n\t        self.packet_definition = packet_definition\n\t        self.word_size = word_size\n", "    @staticmethod\n\t    def _parse_header(packet_data: bitstring.ConstBitStream,\n\t                      start_position: int = None,\n\t                      reset_cursor: bool = False) -> dict:\n\t        \"\"\"Parses the CCSDS standard header.\n\t        Parameters\n\t        ----------\n\t        packet_data : bitstring.ConstBitStream\n\t            Binary data stream of packet data.\n\t        start_position : int\n", "            Position from which to start parsing. If not provided, will start whenever the cursor currently is.\n\t        reset_cursor : bool\n\t            If True, upon parsing the header data, reset the cursor to the original position in the stream.\n\t            This still applies even if start_position is specified. start_position will be used only for parsing the\n\t            header and then the cursor will be returned to the location it was at before this function was called.\n\t        Returns\n\t        -------\n\t        header : dict\n\t            Dictionary of header items.\n\t        \"\"\"\n", "        original_cursor_position = packet_data.pos\n\t        if start_position:\n\t            packet_data.pos = start_position\n\t        header = {\n\t            item.name: ParsedDataItem(name=item.name, unit=None, raw_value=packet_data.read(item.format_string))\n\t            for item in CCSDS_HEADER_DEFINITION\n\t        }\n\t        if reset_cursor:\n\t            packet_data.pos = original_cursor_position\n\t        return header\n", "    @staticmethod\n\t    def _total_packet_bits_from_pkt_len(pkt_len: int):\n\t        \"\"\"Calculate the total length of a CCSDS packet in bits based on the PKT_LEN field in its header.\n\t        Parameters\n\t        ----------\n\t        pkt_len : int\n\t            PKT_LEN value from CCSDS header\n\t        Returns\n\t        -------\n\t        : int\n", "            Length, in bits of the packet\n\t        \"\"\"\n\t        # 4.1.3.5.3 The length count C shall be expressed as:\n\t        #   C = (Total Number of Octets in the Packet Data Field)  1\n\t        # We also just reparsed the CCSDS header though as well, so that's an additional 6 octets\n\t        return 8 * (pkt_len + 1 + 6)\n\t    def _determine_packet_by_restrictions(self, parsed_header: dict) -> Tuple[str, list]:\n\t        \"\"\"Examines a dictionary representation of a CCSDS header and determines which packet type applies.\n\t        This packet type must be unique. If the header data satisfies the restrictions for more than one packet\n\t        type definition, an exception is raised.\n", "        Parameters\n\t        ----------\n\t        parsed_header : dict\n\t            Pre-parsed header data in dictionary form for evaluating restriction criteria.\n\t            NOTE: Restriction criteria can ONLY be evaluated against header items. There is no reasonable way to\n\t            start parsing all the BaseContainer inheritance restrictions without assuming that all restrictions will\n\t            be based on header items, which can be parsed ahead of time due to the consistent nature of a CCSDS header.\n\t        Returns\n\t        -------\n\t        : str\n", "            Name of packet definition.\n\t        : list\n\t            A list of Parameter objects\n\t        \"\"\"\n\t        warnings.warn(\"The '_determine_packet_by_restrictions' method is deprecated.\", DeprecationWarning)\n\t        flattened_containers = self.packet_definition.flattened_containers\n\t        meets_requirements = []\n\t        for container_name, flattened_container in flattened_containers.items():\n\t            try:\n\t                checks = [\n", "                    criterion.evaluate(parsed_header)\n\t                    for criterion in flattened_container.restrictions\n\t                ]\n\t            except AttributeError as err:\n\t                raise ValueError(\"Hitherto unparsed parameter name found in restriction criteria for container \"\n\t                                 f\"{container_name}. Because we can't parse packet data until we know the type, \"\n\t                                 \"only higher up parameters (e.g. APID) are permitted as container \"\n\t                                 \"restriction criteria.\") from err\n\t            if all(checks):\n\t                meets_requirements.append(container_name)\n", "        if len(meets_requirements) == 1:\n\t            name = meets_requirements.pop()\n\t            return name, flattened_containers[name].entry_list\n\t        if len(meets_requirements) > 1:\n\t            raise UnrecognizedPacketTypeError(\n\t                \"Found more than one possible packet definition based on restriction criteria. \"\n\t                f\"{meets_requirements}\", partial_data=parsed_header)\n\t        if len(meets_requirements) < 1:\n\t            raise UnrecognizedPacketTypeError(\n\t                \"Header does not allow any packet definitions based on restriction criteria. \"\n", "                \"Unable to choose a packet type to parse. \"\n\t                \"Note: Restricting container inheritance based on non-header data items is not possible in a \"\n\t                \"general way and is not supported by this package.\", partial_data=parsed_header)\n\t    @staticmethod\n\t    def parse_packet(packet_data: bitstring.ConstBitStream,\n\t                     containers: dict,\n\t                     root_container_name: str = \"CCSDSPacket\",\n\t                     **parse_value_kwargs) -> Packet:\n\t        \"\"\"Parse binary packet data according to the self.packet_definition object\n\t        Parameters\n", "        ----------\n\t        packet_data : bitstring.BitString\n\t            Binary packet data to parse into Packets\n\t        containers : dict\n\t            Dictionary of named containers, including their inheritance information.\n\t        root_container_name : str, Optional\n\t            Default is CCSDSPacket. Any root container may be specified.\n\t        Returns\n\t        -------\n\t        Packet\n", "            A Packet object container header and data attributes.\n\t        \"\"\"\n\t        def _parse_parameter(p: xtcedef.Parameter):\n\t            parsed_value, derived_value = p.parameter_type.parse_value(\n\t                packet_data, parsed_data=parsed_items, **parse_value_kwargs)\n\t            parsed_items[p.name] = ParsedDataItem(\n\t                name=p.name,\n\t                unit=p.parameter_type.unit,\n\t                raw_value=parsed_value,\n\t                derived_value=derived_value\n", "            )\n\t        def _parse_sequence_container(sc: xtcedef.SequenceContainer):\n\t            for e in sc.entry_list:\n\t                if isinstance(e, xtcedef.SequenceContainer):\n\t                    _parse_sequence_container(e)\n\t                else:\n\t                    _parse_parameter(e)\n\t        parsed_items = {}\n\t        current_container: xtcedef.SequenceContainer = containers[root_container_name]\n\t        while True:\n", "            for entry in current_container.entry_list:\n\t                if isinstance(entry, xtcedef.Parameter):\n\t                    _parse_parameter(entry)\n\t                elif isinstance(entry, xtcedef.SequenceContainer):\n\t                    _parse_sequence_container(entry)\n\t            valid_inheritors = []\n\t            for inheritor_name in current_container.inheritors:\n\t                if all(rc.evaluate(parsed_items) for rc in containers[inheritor_name].restriction_criteria):\n\t                    valid_inheritors.append(inheritor_name)\n\t            if len(valid_inheritors) == 1:\n", "                # Set the unique valid inheritor as the next current_container\n\t                current_container = containers[valid_inheritors[0]]\n\t                continue\n\t            if len(valid_inheritors) == 0:\n\t                if current_container.abstract is True:\n\t                    raise UnrecognizedPacketTypeError(\n\t                        f\"Detected an abstract container with no valid inheritors by restriction criteria. This might \"\n\t                        f\"mean this packet type is not accounted for in the provided packet definition. \"\n\t                        f\"APID={parsed_items['PKT_APID'].raw_value}.\",\n\t                        partial_data=parsed_items)\n", "                break\n\t            raise UnrecognizedPacketTypeError(\n\t                f\"Multiple valid inheritors, {valid_inheritors} are possible for {current_container}.\",\n\t                partial_data=parsed_items)\n\t        header = dict(list(parsed_items.items())[:7])\n\t        user_data = dict(list(parsed_items.items())[7:])\n\t        return Packet(header, user_data)\n\t    @staticmethod\n\t    def legacy_parse_packet(packet_data: bitstring.ConstBitStream, entry_list: list, **parse_value_kwargs) -> Packet:\n\t        \"\"\"Parse binary packet data according to the self.flattened_containers property\n", "        Parameters\n\t        ----------\n\t        packet_data : bitstring.BitString\n\t            Binary packet data to parse into Packets\n\t        entry_list : list\n\t            List of Parameter objects\n\t        Returns\n\t        -------\n\t        Packet\n\t            A Packet object container header and data attributes.\n", "        \"\"\"\n\t        warnings.warn(\"The 'legacy_parse_packet' method is deprecated.\", DeprecationWarning)\n\t        header = {}\n\t        for parameter in entry_list[0:7]:\n\t            parsed_value, _ = parameter.parameter_type.parse_value(packet_data, header)\n\t            header[parameter.name] = ParsedDataItem(\n\t                name=parameter.name,\n\t                unit=parameter.parameter_type.unit,\n\t                raw_value=parsed_value\n\t            )\n", "        user_data = {}\n\t        for parameter in entry_list[7:]:\n\t            combined_parsed_data = {**header}\n\t            combined_parsed_data.update(user_data)\n\t            parsed_value, derived_value = parameter.parameter_type.parse_value(\n\t                packet_data, parsed_data=combined_parsed_data, **parse_value_kwargs)\n\t            user_data[parameter.name] = ParsedDataItem(\n\t                name=parameter.name,\n\t                unit=parameter.parameter_type.unit,\n\t                raw_value=parsed_value,\n", "                derived_value=derived_value\n\t            )\n\t        return Packet(header=header, data=user_data)\n\t    @staticmethod\n\t    def print_progress(current_bits: int, total_bits: int or None,\n\t                       start_time_ns: int, current_packets: int,\n\t                       end: str = '\\r', log: bool = False):\n\t        \"\"\"Prints a progress bar, including statistics on parsing rate.\n\t        Parameters\n\t        ----------\n", "        current_bits : int\n\t            Number of bits parsed so far.\n\t        total_bits : int\n\t            Number of total bits to parse (if known)\n\t        current_packets : int\n\t            Number of packets parsed so far.\n\t        start_time_ns : int\n\t            Start time on system clock, in nanoseconds.\n\t        end : str\n\t            Print function end string. Default is `\\\\r` to create a dynamically updating loading bar.\n", "        log : bool\n\t            If True, log the progress bar at INFO level.\n\t        \"\"\"\n\t        progress_char = \"=\"\n\t        bar_length = 20\n\t        if total_bits is not None:  # If we actually have an endpoint (i.e. not using a socket)\n\t            percentage = int((current_bits / total_bits) * 100)  # Percent Completed Calculation\n\t            progress = int((bar_length * current_bits) / total_bits)  # Progress Done Calculation\n\t        else:\n\t            percentage = \"???\"\n", "            progress = 0\n\t        elapsed_ns = time.time_ns() - start_time_ns\n\t        delta = dt.timedelta(microseconds=elapsed_ns / 1E3)\n\t        kbps = int(current_bits * 1E6 / elapsed_ns)\n\t        pps = int(current_packets * 1E9 / elapsed_ns)\n\t        info_str = f\"[Elapsed: {delta}, \" \\\n\t                   f\"Parsed {current_bits} bits ({current_packets} packets) \" \\\n\t                   f\"at {kbps}kb/s ({pps}pkts/s)]\"\n\t        loadbar = f\"Progress: [{progress*progress_char:{bar_length}}]{percentage}% {info_str}\"\n\t        print(loadbar, end=end)\n", "        if log is True:\n\t            logger.info(loadbar)\n\t    def generator(self,\n\t                  binary_data: bitstring.ConstBitStream or BinaryIO or socket.socket,\n\t                  parse_bad_pkts: bool = True,\n\t                  skip_header_bits: int = 0,\n\t                  root_container_name=\"CCSDSPacket\",\n\t                  ccsds_headers_only: bool = False,\n\t                  yield_unrecognized_packet_errors: bool = False,\n\t                  show_progress: bool = False,\n", "                  buffer_read_size_bytes: int = 4096):\n\t        \"\"\"Create and return a Packet generator that reads from a ConstBitStream or a filelike object or a socket.\n\t        Creating a generator object to return allows the user to create\n\t        many generators from a single Parser and reduces memory usage.\n\t        Parameters\n\t        ----------\n\t        binary_data : bitstring.ConstBitStream or BinaryIO or socket.socket\n\t            Binary data source to parse into Packets.\n\t        parse_bad_pkts : bool, Optional\n\t            Default True.\n", "            If True, when the generator encounters a packet with an incorrect length it will still yield the packet\n\t            (the data will likely be invalid). If False, the generator will still write a debug log message but will\n\t            otherwise silently skip the bad packet.\n\t        skip_header_bits : int, Optional\n\t            If provided, the parser skips this many bits at the beginning of every packet. This allows dynamic stripping\n\t            of additional header data that may be prepended to packets.\n\t        root_container_name : str, Optional\n\t            The name of the root level (lowest level of container inheritance) SequenceContainer. This SequenceContainer\n\t            is assumed to be inherited by every possible packet structure in the XTCE document and is the starting\n\t            point for parsing. Default is 'CCSDSPacket'.\n", "        ccsds_headers_only : bool, Optional\n\t            If True, only parses the packet headers (does not use the provided packet definition).\n\t        yield_unrecognized_packet_errors : bool, Optional\n\t            If False, UnrecognizedPacketTypeErrors are caught silently and parsing continues to the next packet.\n\t            If True, the generator will yield an UnrecognizedPacketTypeError in the event of an unrecognized\n\t            packet. Note: These exceptions are not raised by default but are instead returned so that the generator\n\t            can continue. You can raise the exceptions if desired. Leave this as False unless you need to examine the\n\t            partial data from unrecognized packets.\n\t        show_progress : bool, Optional\n\t            If True, prints a status bar. Note that for socket sources, the percentage will be zero until the generator\n", "            ends.\n\t        buffer_read_size_bytes : int, Optional\n\t            Number of bytes to read from e.g. a BufferedReader or socket binary data source on each read attempt.\n\t            Default is 4096 bytes.\n\t        Yields\n\t        -------\n\t        : Packet or UnrecognizedPacketTypeError\n\t            Generator yields Packet objects containing the parsed packet data for each subsequent packet.\n\t            If yield_unrecognized_packet_errors is True, it will yield an unraised exception object,\n\t            which can be raised or used for debugging purposes.\n", "        \"\"\"\n\t        def fill_read_buffer(source: bitstring.ConstBitStream or BinaryIO or socket.socket,\n\t                             buffer: bitstring.BitStream,\n\t                             read_size_bytes: int) -> int:\n\t            \"\"\"Read data from a source and add it to an existing buffer (BitStream).\n\t            Parameters\n\t            ----------\n\t            source : bitstring.ConstBitStream or BinaryIO or socket.socket\n\t                Source of data.\n\t            buffer : bitstring.BitStream\n", "                A reference to a rotating buffer to which the new data is appended. Mutating this changes the data\n\t                available to the caller by reference so we don't return it.\n\t            read_size_bytes : int\n\t                Max number of bytes to read from the source per read attempt. For sockets, this should be a small\n\t                power of 2 (e.g. 4096) due to networking and hardware conventions. For a file or ConstBitStream object\n\t                this could be set to the full size of the data but a large value will increase memory utilization\n\t                when parsing large data sources all at once.\n\t            Returns\n\t            -------\n\t            result : int\n", "                Number of bits added to the buffer. Note that the buffer may still have nonzero length from previous\n\t                data even when this returns zero.\n\t            \"\"\"\n\t            if isinstance(source, io.BufferedIOBase):\n\t                new_bytes = source.read(read_size_bytes)\n\t                buffer += new_bytes\n\t                return len(new_bytes)*8\n\t            if isinstance(source, socket.socket):\n\t                new_bytes = source.recv(read_size_bytes)\n\t                buffer += new_bytes  # Append BitStream with newly read bytes\n", "                return len(new_bytes)*8\n\t            if isinstance(source, bitstring.ConstBitStream):\n\t                new_bits = source[source.pos:source.pos + read_size_bytes * 8]\n\t                assert isinstance(new_bits, bitstring.ConstBitStream)\n\t                source.pos += len(new_bits)  # This way we never overshoot the end of the data\n\t                buffer += new_bits\n\t                return len(new_bits)\n\t            raise ValueError(f\"Unrecognized data source: {source}\")\n\t        # ========\n\t        # Start of generator\n", "        # ========\n\t        if isinstance(binary_data, bitstring.ConstBitStream):\n\t            total_length_bits = len(binary_data)\n\t            logger.info(\n\t                f\"Creating packet generator from pre-loaded ConstBitStream. Total length is {total_length_bits}\")\n\t        elif isinstance(binary_data, io.BufferedIOBase):\n\t            total_length_bits = 8 * binary_data.seek(0, io.SEEK_END)  # This is probably preferable to len\n\t            binary_data.seek(0, 0)\n\t            logger.info(f\"Creating packet generator from a filelike object, {binary_data}. \"\n\t                        f\"Total length is {total_length_bits}bits\")\n", "        else:  # It's a socket and we don't know how much data we will get\n\t            logger.info(\"Creating packet generator to read from a socket. Total length to parse is unknown.\")\n\t            total_length_bits = None  # We don't know how long it is\n\t        # ========\n\t        # Packet loop. Each iteration of this loop yields a ParsedPacket object\n\t        # ========\n\t        start_time = time.time_ns()\n\t        n_bits_parsed = 0  # Keep track of how many bits we have parsed\n\t        n_packets_parsed = 0  # Keep track of how many packets we have parsed\n\t        read_buffer = bitstring.BitStream()  # Not const because it's a rotating buffer\n", "        while True:\n\t            if total_length_bits and n_bits_parsed == total_length_bits:\n\t                break  # Exit if we know the length and we've reached it\n\t            if show_progress is True:\n\t                self.print_progress(current_bits=n_bits_parsed, total_bits=total_length_bits,\n\t                                    start_time_ns=start_time, current_packets=n_packets_parsed)\n\t            # Fill buffer enough to parse a header\n\t            while len(read_buffer) < skip_header_bits + CCSDS_HEADER_LENGTH_BITS:\n\t                result = fill_read_buffer(binary_data, read_buffer,\n\t                                          read_size_bytes=buffer_read_size_bytes)\n", "                if not result:  # If there is verifiably no more data to add, break\n\t                    break\n\t            read_buffer.pos += skip_header_bits\n\t            header = self._parse_header(read_buffer, reset_cursor=True)\n\t            specified_total_packet_length_bits = self._total_packet_bits_from_pkt_len(header['PKT_LEN'].raw_value)\n\t            n_packets_parsed += 1  # Consider it a counted packet once we've parsed the header\n\t            if ccsds_headers_only is True:\n\t                # Trim read buffer (this also reduces memory usage over time for reading a ConstBitStream)\n\t                n_bits_parsed += skip_header_bits + specified_total_packet_length_bits\n\t                read_buffer = read_buffer[specified_total_packet_length_bits + skip_header_bits:]\n", "                yield Packet(header=header, data=None)\n\t                continue\n\t            # Based on PKT_LEN fill buffer enough to read a full packet\n\t            while len(read_buffer) < skip_header_bits + specified_total_packet_length_bits:\n\t                result = fill_read_buffer(binary_data, read_buffer,\n\t                                          read_size_bytes=buffer_read_size_bytes)\n\t                if not result:  # If there is verifiably no more data to add, break\n\t                    break\n\t            try:\n\t                if isinstance(self.packet_definition, xtcedef.XtcePacketDefinition):\n", "                    packet = self.parse_packet(read_buffer,\n\t                                               self.packet_definition.named_containers,\n\t                                               root_container_name=root_container_name,\n\t                                               word_size=self.word_size)\n\t                else:\n\t                    _, parameter_list = self._determine_packet_by_restrictions(header)\n\t                    packet = self.legacy_parse_packet(read_buffer, parameter_list, word_size=self.word_size)\n\t            except UnrecognizedPacketTypeError as e:\n\t                # Regardless of whether we handle the error, we still want to chop the read_buffer in preparation\n\t                # for parsing the next packet\n", "                n_bits_parsed += skip_header_bits + specified_total_packet_length_bits\n\t                read_buffer = read_buffer[skip_header_bits + specified_total_packet_length_bits:]\n\t                logger.debug(f\"Unrecognized error on packet with APID {header['PKT_APID'].raw_value}'\")\n\t                if yield_unrecognized_packet_errors is True:\n\t                    # Yield the caught exception without raising it (raising ends generator)\n\t                    yield e\n\t                # Continue to next packet\n\t                continue\n\t            if packet.header['PKT_LEN'].raw_value != header['PKT_LEN'].raw_value:\n\t                raise ValueError(f\"Hardcoded header parsing found a different packet length \"\n", "                                 f\"{header['PKT_LEN'].raw_value} than the definition-based parsing found \"\n\t                                 f\"{packet.header['PKT_LEN'].raw_value}. This might be because the CCSDS header is \"\n\t                                 f\"incorrectly represented in your packet definition document.\")\n\t            actual_length_parsed = read_buffer.pos - skip_header_bits\n\t            if actual_length_parsed != specified_total_packet_length_bits:\n\t                logger.warning(f\"Parsed packet length \"\n\t                               f\"({actual_length_parsed}b) did not match \"\n\t                               f\"length specified in header ({specified_total_packet_length_bits}b). \"\n\t                               f\"Updating bit string position to correct position \"\n\t                               \"indicated by CCSDS header.\")\n", "                if not parse_bad_pkts:\n\t                    logger.warning(\"Skipping (not yielding) bad packet because parse_bad_pkts is falsy.\")\n\t                    continue\n\t            n_bits_parsed += skip_header_bits + specified_total_packet_length_bits\n\t            read_buffer = read_buffer[specified_total_packet_length_bits + skip_header_bits:]\n\t            yield packet\n\t        if show_progress is True:\n\t            self.print_progress(current_bits=n_bits_parsed, total_bits=total_length_bits,\n\t                                start_time_ns=start_time, current_packets=n_packets_parsed,\n\t                                end=\"\\n\", log=True)\n"]}
{"filename": "space_packet_parser/xtcedef.py", "chunked_list": ["\"\"\"Module for parsing XTCE xml files to specify packet format\"\"\"\n\t# Standard\n\tfrom abc import ABCMeta\n\tfrom collections import namedtuple\n\timport inspect\n\timport logging\n\tfrom pathlib import Path\n\tfrom typing import Tuple\n\timport warnings\n\tfrom xml.etree import ElementTree\n", "# Installed\n\timport bitstring\n\tlogger = logging.getLogger(__name__)\n\t# TODO: Improve exceptions for specific failure modes\n\t# Exceptions\n\tclass ElementNotFoundError(Exception):\n\t    \"\"\"Exception for missing XML element\"\"\"\n\t    pass\n\tclass ComparisonError(Exception):\n\t    \"\"\"Exception for problems performing comparisons\"\"\"\n", "    pass\n\tclass FormatStringError(Exception):\n\t    \"\"\"Error indicating a problem determining how to parse a variable length string.\"\"\"\n\t    pass\n\tclass DynamicLengthBinaryParameterError(Exception):\n\t    \"\"\"Exception to raise when we try to parse a dynamic length binary field as fixed length\"\"\"\n\t    pass\n\tclass CalibrationError(Exception):\n\t    \"\"\"For errors encountered during value calibration\"\"\"\n\t    pass\n", "# Common comparable mixin\n\tclass AttrComparable(metaclass=ABCMeta):\n\t    \"\"\"Generic class that provides a notion of equality based on all non-callable, non-dunder attributes\"\"\"\n\t    def __eq__(self, other):\n\t        if not isinstance(other, self.__class__):\n\t            raise NotImplementedError(f\"No method to compare {type(other)} with {self.__class__}\")\n\t        compare = inspect.getmembers(self, lambda a: not inspect.isroutine(a))\n\t        compare = [attr[0] for attr in compare\n\t                   if not (attr[0].startswith('__') or attr[0].startswith(f'_{self.__class__.__name__}__'))]\n\t        for attr in compare:\n", "            if getattr(self, attr) != getattr(other, attr):\n\t                print(f'Mismatch was in {attr}. {getattr(self, attr)} != {getattr(other, attr)}')\n\t                return False\n\t        return True\n\t# Matching logical objects\n\tclass MatchCriteria(AttrComparable, metaclass=ABCMeta):\n\t    \"\"\"<xtce:MatchCriteriaType>\n\t    This class stores criteria for performing logical operations based on parameter values\n\t    Classes that inherit from this ABC include those that represent <xtce:Comparison>, <xtce:ComparisonList>,\n\t    <xtce:BooleanExpression> (not supported), and <xtce:CustomAlgorithm> (not supported)\n", "    \"\"\"\n\t    # Valid operator representations in XML. Note: the XTCE spec only allows for &gt; style representations of < and >\n\t    #   Python's XML parser doesn't appear to support &eq; &ne; &le; or &ge;\n\t    # We have implemented support for bash-style comparisons just in case.\n\t    _valid_operators = {\n\t        \"==\": \"==\", \"eq\": \"==\",  # equal to\n\t        \"!=\": \"!=\", \"neq\": \"!=\",  # not equal to\n\t        \"&lt;\": \"<\", \"lt\": \"<\",  # less than\n\t        \"&gt;\": \">\", \"gt\": \">\",  # greater than\n\t        \"&lt;=\": \"<=\", \"leq\": \"<=\",  # less than or equal to\n", "        \"&gt;=\": \">=\", \"geq\": \">=\",  # greater than or equal to\n\t    }\n\t    @classmethod\n\t    def from_match_criteria_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Abstract classmethod to create a match criteria object from an XML element.\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            XML element\n\t        ns : dict\n", "            XML namespace dict\n\t        Returns\n\t        -------\n\t        : cls\n\t        \"\"\"\n\t        raise NotImplementedError()\n\t    def evaluate(self, parsed_data: dict, current_parsed_value: int or float = None) -> bool:\n\t        \"\"\"Evaluate match criteria down to a boolean.\n\t        Parameters\n\t        ----------\n", "        parsed_data : dict\n\t            Dictionary of parsed parameter data so far. Used to evaluate truthyness of the match criteria.\n\t        current_parsed_value : any, Optional\n\t            Uncalibrated value that is currently being matched (e.g. as a candidate for calibration).\n\t            Used to resolve comparisons that reference their own raw value as a condition.\n\t        Returns\n\t        -------\n\t        : bool\n\t            Truthyness of this match criteria based on parsed_data values.\n\t        \"\"\"\n", "        raise NotImplementedError()\n\tclass Comparison(MatchCriteria):\n\t    \"\"\"<xtce:Comparison>\"\"\"\n\t    def __init__(self, required_value: any, referenced_parameter: str,\n\t                 operator: str = \"==\", use_calibrated_value: bool = True):\n\t        \"\"\"Constructor\n\t        Parameters\n\t        ----------\n\t        operator : str\n\t            String representation of the comparison operation. e.g. \"<=\" or \"leq\"\n", "        required_value : any\n\t            Value with which to compare the referenced parameter using the operator. This value is dynamically\n\t            coerced to the referenced parameter type during evaluation.\n\t        referenced_parameter : str\n\t            Name of the parameter to compare with the value.\n\t        use_calibrated_value : bool\n\t            Whether or not to calibrate the value before performing the comparison.\n\t        \"\"\"\n\t        self.required_value = required_value\n\t        self.referenced_parameter = referenced_parameter\n", "        self.operator = operator\n\t        self.use_calibrated_value = use_calibrated_value\n\t        self._validate()\n\t    def __repr__(self):\n\t        return f\"<{self.__class__.__name__} {self.referenced_parameter}{self.operator}{self.required_value}>\"\n\t    def _validate(self):\n\t        \"\"\"Validate state as logically consistent.\n\t        Returns\n\t        -------\n\t        None\n", "        \"\"\"\n\t        if not (self.operator in self._valid_operators or self.operator in self._valid_operators.values()):\n\t            raise ValueError(f\"Unrecognized operator syntax {self.operator}. \"\n\t                             f\"Must be one of \"\n\t                             f\"{set(list(self._valid_operators.values()) + list(self._valid_operators.keys()))}\")\n\t    @classmethod\n\t    def from_match_criteria_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Create\n\t        Parameters\n\t        ----------\n", "        element : ElementTree.Element\n\t            XML element\n\t        ns : dict\n\t            XML namespace dict\n\t        Returns\n\t        -------\n\t        : cls\n\t        \"\"\"\n\t        use_calibrated_value = True  # Default\n\t        if 'useCalibratedValue' in element.attrib:\n", "            use_calibrated_value = element.attrib['useCalibratedValue'].lower() == 'true'\n\t        value = element.attrib['value']\n\t        parameter_name = element.attrib['parameterRef']\n\t        operator = '=='\n\t        if 'comparisonOperator' in element.attrib:\n\t            operator = element.attrib['comparisonOperator']\n\t        return cls(value, parameter_name, operator=operator, use_calibrated_value=use_calibrated_value)\n\t    def evaluate(self, parsed_data: dict, current_parsed_value: int or float = None) -> bool:\n\t        \"\"\"Evaluate comparison down to a boolean. If the parameter to compare is not present in the parsed_data dict,\n\t        we assume that we are comparing against the current raw value in current_parsed_value.\n", "        Parameters\n\t        ----------\n\t        parsed_data : dict\n\t            Dictionary of parsed parameter data so far. Used to evaluate truthyness of the match criteria.\n\t        current_parsed_value : int or float\n\t            Optional. Uncalibrated value that is currently a candidate for calibration and so has not yet been added\n\t            to the parsed_data dict. Used to resolve calibrator conditions that reference their own\n\t            raw value as a comparate.\n\t        Returns\n\t        -------\n", "        : bool\n\t            Truthyness of this match criteria based on parsed_data values.\n\t        \"\"\"\n\t        if self.referenced_parameter in parsed_data:\n\t            if self.use_calibrated_value:\n\t                parsed_value = parsed_data[self.referenced_parameter].derived_value\n\t                if not parsed_value:\n\t                    raise ComparisonError(f\"Comparison {self} was instructed to useCalibratedValue (the default)\"\n\t                                          f\"but {self.referenced_parameter} does not appear to have a derived value.\")\n\t            else:\n", "                parsed_value = parsed_data[self.referenced_parameter].raw_value\n\t        elif current_parsed_value is not None:\n\t            # Assume then that the comparison is a reference to its own uncalibrated value\n\t            parsed_value = current_parsed_value\n\t            if self.use_calibrated_value:\n\t                warnings.warn(\"Performing a comparison against a current value (e.g. a Comparison within a \"\n\t                              \"context calibrator contains a reference to its own uncalibrated value but use_\"\n\t                              \"calibrated_value is set to true. This is nonsensical. Using the uncalibrated value...\")\n\t        else:\n\t            raise ValueError(\"Attempting to resolve a Comparison expression but the referenced parameter does not \"\n", "                             \"appear in the parsed data so far and no current raw value was passed \"\n\t                             \"to compare with.\")\n\t        operator = (self.operator\n\t                    if self.operator in self._valid_operators.values()\n\t                    else self._valid_operators[self.operator])\n\t        t_comparate = type(parsed_value)\n\t        try:\n\t            required_value = t_comparate(self.required_value)\n\t        except ValueError as err:\n\t            raise ComparisonError(f\"Unable to coerce {self.required_value} of type {type(self.required_value)} to \"\n", "                                  f\"type {t_comparate} for comparison evaluation.\") from err\n\t        if required_value is None or parsed_value is None:\n\t            raise ValueError(f\"Error in Comparison. Cannot compare {required_value} with {parsed_value}. \"\n\t                             \"Neither should be None.\")\n\t        if isinstance(required_value, str):\n\t            parsed_value = f\"'{parsed_value}'\"\n\t            required_value = f\"'{required_value}'\"\n\t        return eval(f\"{parsed_value} {operator} {required_value}\")\n\tclass Condition(MatchCriteria):\n\t    \"\"\"<xtce:Condition>\n", "    Note: This xtce model doesn't actually inherit from MatchCriteria in the UML model\n\t    but it's functionally close enough that we inherit the class here.\n\t    \"\"\"\n\t    def __init__(self, left_param: str, operator: str, right_param: str = None, right_value=None,\n\t                 left_use_calibrated_value: bool = True, right_use_calibrated_value: bool = True):\n\t        \"\"\"Constructor\n\t        Parameters\n\t        ----------\n\t        left_param : str\n\t            Parameter name on the LH side of the comparison\n", "        operator : str\n\t            Member of MatchCriteria._valid_operators.\n\t        right_param : str\n\t            Parameter name on the RH side of the comparison.\n\t        right_value: any, Optional\n\t            Used in case of comparison with a fixed xtce:Value on the RH side.\n\t        left_use_calibrated_value : bool, Optional\n\t            Default is True. If False, comparison is made against the uncalibrated value.\n\t        right_use_calibrated_value: bool, Optional\n\t            Default is True. If False, comparison is made against the uncalibrated value.\n", "        \"\"\"\n\t        self.left_param = left_param\n\t        self.right_param = right_param\n\t        self.right_value = right_value\n\t        self.operator = operator\n\t        self.right_use_calibrated_value = right_use_calibrated_value\n\t        self.left_use_calibrated_value = left_use_calibrated_value\n\t        self._validate()\n\t    def _validate(self):\n\t        \"\"\"Check that the instantiated object actually makes logical sense.\n", "        Returns\n\t        -------\n\t        None\n\t        \"\"\"\n\t        if not (self.operator in self._valid_operators or self.operator in self._valid_operators.values()):\n\t            raise ValueError(f\"Unrecognized operator syntax {self.operator}. \"\n\t                             f\"Must be one of \"\n\t                             f\"{set(list(self._valid_operators.values()) + list(self._valid_operators.keys()))}\")\n\t        if self.right_param and self.right_value:\n\t            raise ComparisonError(f\"Received both a right_value and a right_param reference to Condition {self}.\")\n", "        if self.right_value and self.right_use_calibrated_value:\n\t            raise ComparisonError(f\"Unable to use calibrated form of a fixed value in Condition {self}.\")\n\t    @staticmethod\n\t    def _parse_parameter_instance_ref(element: ElementTree.Element):\n\t        \"\"\"Parse an xtce:ParameterInstanceRef element\n\t        Parameters\n\t        ----------\n\t        element: ElementTree.Element\n\t            xtce:ParameterInstanceRef element\n\t        Returns\n", "        -------\n\t        parameter_name: str\n\t            Name of referenced parameter\n\t        use_calibrated_value: bool\n\t            Whether to use the calibrated form of the referenced parameter\n\t        \"\"\"\n\t        parameter_name = element.attrib['parameterRef']\n\t        use_calibrated_value = True  # Default\n\t        if 'useCalibratedValue' in element.attrib:\n\t            use_calibrated_value = element.attrib['useCalibratedValue'].lower() == 'true'\n", "        return parameter_name, use_calibrated_value\n\t    @classmethod\n\t    def from_match_criteria_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Classmethod to create a Condition object from an XML element.\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            XML element\n\t        ns : dict\n\t            XML namespace dict\n", "        Returns\n\t        -------\n\t        : cls\n\t        \"\"\"\n\t        operator = element.find('xtce:ComparisonOperator', ns).text\n\t        params = element.findall('xtce:ParameterInstanceRef', ns)\n\t        if len(params) == 1:\n\t            left_param, use_calibrated_value = cls._parse_parameter_instance_ref(params[0])\n\t            right_value = element.find('xtce:Value', ns).text\n\t            return cls(left_param, operator, right_value=right_value,\n", "                       left_use_calibrated_value=use_calibrated_value,\n\t                       right_use_calibrated_value=False)\n\t        if len(params) == 2:\n\t            left_param, left_use_calibrated_value = cls._parse_parameter_instance_ref(params[0])\n\t            right_param, right_use_calibrated_value = cls._parse_parameter_instance_ref(params[1])\n\t            return cls(left_param, operator, right_param=right_param,\n\t                       left_use_calibrated_value=left_use_calibrated_value,\n\t                       right_use_calibrated_value=right_use_calibrated_value)\n\t        raise ValueError(f'Failed to parse a Condition element {element}. '\n\t                             'See 3.4.3.4.2 of XTCE Green Book CCSDS 660.1-G-2')\n", "    def evaluate(self, parsed_data: dict, current_parsed_value: int or float = None) -> bool:\n\t        \"\"\"Evaluate match criteria down to a boolean.\n\t        Parameters\n\t        ----------\n\t        parsed_data : dict\n\t            Dictionary of parsed parameter data so far. Used to evaluate truthyness of the match criteria.\n\t        current_parsed_value : int or float, Optional\n\t            Current value being parsed. NOTE: This is currently ignored. See the TODO item below.\n\t        Returns\n\t        -------\n", "        : bool\n\t            Truthyness of this match criteria based on parsed_data values.\n\t        \"\"\"\n\t        def _get_parsed_value(parameter_name: str, use_calibrated: bool):\n\t            \"\"\"Retrieves the previously parsed value from the passed in parsed_data\"\"\"\n\t            try:\n\t                return parsed_data[parameter_name].derived_value if use_calibrated \\\n\t                    else parsed_data[parameter_name].raw_value\n\t            except KeyError as e:\n\t                raise ComparisonError(f\"Attempting to perform a Condition evaluation on {self.left_param} but \"\n", "                                      \"the referenced parameter does not appear in the hitherto parsed data passed to \"\n\t                                      \"the evaluate method. If you intended a comparison against the raw value of the \"\n\t                                      \"parameter currently being parsed, unfortunately that is not currently supported.\"\n\t                                      ) from e\n\t        # TODO: Consider allowing one of the parameters to be the parameter currently being evaluated.\n\t        #    This isn't explicitly provided for in the XTCE spec but it seems reasonable to be able to\n\t        #    perform conditionals against the current raw value of a parameter, e.g. while determining if it\n\t        #    should be calibrated. Note that only one of the parameters can be used this way and it must reference\n\t        #    an uncalibrated value so the logic and error handling must be done carefully.\n\t        left_value = _get_parsed_value(self.left_param, self.left_use_calibrated_value)\n", "        # Convert XML operator representation to a python-compatible operator (e.g. '&gt;' to '>')\n\t        operator = (self.operator\n\t                    if self.operator in self._valid_operators.values()\n\t                    else self._valid_operators[self.operator])\n\t        if self.right_param is not None:\n\t            right_value = _get_parsed_value(self.right_param, self.right_use_calibrated_value)\n\t        elif self.right_value is not None:\n\t            t_left_param = type(left_value)  # Coerce right value xml representation to correct type\n\t            right_value = t_left_param(self.right_value)\n\t        else:\n", "            raise ValueError(f\"Error when evaluating condition {self}. Neither right_param nor right_value is set.\")\n\t        if left_value is None or right_value is None:\n\t            raise ComparisonError(f\"Error comparing {left_value} and {right_value}. Neither should be None.\")\n\t        if isinstance(left_value, str):\n\t            left_value = f\"'{left_value}'\"\n\t            right_value = f\"'{right_value}'\"\n\t        return eval(f\"{left_value} {operator} {right_value}\")\n\tAnded = namedtuple('Anded', ['conditions', 'ors'])\n\tOred = namedtuple('Ored', ['conditions', 'ands'])\n\tclass BooleanExpression(MatchCriteria):\n", "    \"\"\"<xtce:BooleanExpression>\"\"\"\n\t    def __init__(self, expression: Condition or Anded or Ored):\n\t        self.expression = expression\n\t    @classmethod\n\t    def from_match_criteria_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Abstract classmethod to create a match criteria object from an XML element.\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t           XML element\n", "        ns : dict\n\t           XML namespace dict\n\t        Returns\n\t        -------\n\t        : cls\n\t        \"\"\"\n\t        def _parse_anded(anded_el: ElementTree.Element):\n\t            \"\"\"Create an Anded object from an xtce:ANDedConditions element\n\t            Parameters\n\t            ----------\n", "            anded_el: ElementTree.Element\n\t                xtce:ANDedConditions element\n\t            Returns\n\t            -------\n\t            : Anded\n\t            \"\"\"\n\t            conditions = [Condition.from_match_criteria_xml_element(el, ns)\n\t                          for el in anded_el.findall('xtce:Condition', ns)]\n\t            anded_ors = [_parse_ored(anded_or) for anded_or in anded_el.findall('xtce:ORedConditions', ns)]\n\t            return Anded(conditions, anded_ors)\n", "        def _parse_ored(ored_el: ElementTree.Element):\n\t            \"\"\"Create an Ored object from an xtce:ARedConditions element\n\t            Parameters\n\t            ----------\n\t            ored_el: ElementTree.Element\n\t                xtce:ORedConditions element\n\t            Returns\n\t            -------\n\t            : Ored\n\t            \"\"\"\n", "            conditions = [Condition.from_match_criteria_xml_element(el, ns)\n\t                          for el in ored_el.findall('xtce:Condition', ns)]\n\t            ored_ands = [_parse_anded(ored_and) for ored_and in ored_el.findall('xtce:ANDedConditions', ns)]\n\t            return Ored(conditions, ored_ands)\n\t        if element.find('xtce:Condition', ns) is not None:\n\t            condition = Condition.from_match_criteria_xml_element(element.find('xtce:Condition', ns), ns)\n\t            return cls(expression=condition)\n\t        if element.find('xtce:ANDedConditions', ns) is not None:\n\t            return cls(expression=_parse_anded(element.find('xtce:ANDedConditions', ns)))\n\t        if element.find('xtce:ORedConditions', ns) is not None:\n", "            return cls(expression=_parse_ored(element.find('xtce:ORedConditions', ns)))\n\t        raise ValueError(f\"Failed to parse {element}\")\n\t    def evaluate(self, parsed_data: dict, **kwargs) -> bool:\n\t        \"\"\"Evaluate the criteria in the BooleanExpression down to a single boolean.\n\t        Parameters\n\t        ----------\n\t        parsed_data : dict\n\t            Dictionary of parsed parameter data so far. Used to evaluate truthyness of the match criteria.\n\t        Returns\n\t        -------\n", "        : bool\n\t            Truthyness of this match criteria based on parsed_data values.\n\t        \"\"\"\n\t        def _or(ored: Ored):\n\t            for condition in ored.conditions:\n\t                if condition.evaluate(parsed_data) is True:\n\t                    return True\n\t            for anded in ored.ands:\n\t                if _and(anded):\n\t                    return True\n", "            return False\n\t        def _and(anded: Anded):\n\t            for condition in anded.conditions:\n\t                if condition.evaluate(parsed_data) is False:\n\t                    return False\n\t            for ored in anded.ors:\n\t                if not _or(ored):\n\t                    return False\n\t            return True\n\t        if isinstance(self.expression, Condition):\n", "            return self.expression.evaluate(parsed_data)\n\t        if isinstance(self.expression, Anded):\n\t            return _and(self.expression)\n\t        if isinstance(self.expression, Ored):\n\t            return _or(self.expression)\n\t        raise ValueError(f\"Error evaluating an unknown expression {self.expression}.\")\n\tclass DiscreteLookup(AttrComparable):\n\t    \"\"\"<xtce:DiscreteLookup>\"\"\"\n\t    def __init__(self, match_criteria: list, lookup_value: int or float):\n\t        \"\"\"Constructor\n", "        Parameters\n\t        ----------\n\t        match_criteria : list\n\t            List of criteria to determine if the lookup value should be returned during evaluation.\n\t        lookup_value : int or float\n\t            Value to return from the lookup if the criteria evaluate true\n\t        \"\"\"\n\t        self.match_criteria = match_criteria\n\t        self.lookup_value = lookup_value\n\t    @classmethod\n", "    def from_discrete_lookup_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Create a DiscreteLookup object from an <xtce:DiscreteLookup> XML element\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            <xtce:DiscreteLookup> XML element from which to parse the DiscreteLookup object.\n\t        ns : dict\n\t            Namespace dict for XML parsing\n\t        Returns\n\t        -------\n", "        : cls\n\t        \"\"\"\n\t        lookup_value = float(element.attrib['value'])\n\t        if element.find('xtce:ComparisonList', ns) is not None:\n\t            match_criteria = [Comparison.from_match_criteria_xml_element(el, ns)\n\t                              for el in element.findall('xtce:ComparisonList/xtce:Comparison', ns)]\n\t        elif element.find('xtce:Comparison', ns) is not None:\n\t            match_criteria = [Comparison.from_match_criteria_xml_element(\n\t                element.find('xtce:Comparison', ns), ns)]\n\t        else:\n", "            raise NotImplementedError(\"Only Comparison and ComparisonList are implemented for DiscreteLookup.\")\n\t        return cls(match_criteria, lookup_value)\n\t    def evaluate(self, parsed_data: dict, current_parsed_value: int or float = None):\n\t        \"\"\"Evaluate the lookup to determine if it is valid.\n\t        Parameters\n\t        ----------\n\t        parsed_data : dict\n\t            Data parsed so far (for referencing during criteria evaluation).\n\t        current_parsed_value: int or float, Optional\n\t            If referenced parameter in criterion isn't in parsed_data dict, we assume we are comparing against this\n", "            currently parsed value.\n\t        Returns\n\t        -------\n\t        : any\n\t            Return the lookup value if the match criteria evaluate true. Return None otherwise.\n\t        \"\"\"\n\t        if all(criterion.evaluate(parsed_data, current_parsed_value) for criterion in self.match_criteria):\n\t            # If the parsed data so far satisfy all the match criteria\n\t            return self.lookup_value\n\t        return None\n", "# Calibrator definitions\n\tclass Calibrator(AttrComparable, metaclass=ABCMeta):\n\t    \"\"\"Abstract base class for XTCE calibrators\"\"\"\n\t    @classmethod\n\t    def from_calibrator_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Abstract classmethod to create a default_calibrator object from an XML element.\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            XML element\n", "        ns : dict\n\t            XML namespace dict\n\t        Returns\n\t        -------\n\t        cls\n\t        \"\"\"\n\t        return NotImplemented\n\t    def calibrate(self, uncalibrated_value: int):\n\t        \"\"\"Takes an integer-encoded value and returns a calibrated version.\n\t        Returns\n", "        -------\n\t        : int or float\n\t            Calibrated value\n\t        \"\"\"\n\t        raise NotImplementedError\n\tSplinePoint = namedtuple('SplinePoint', ['raw', 'calibrated'])\n\tclass SplineCalibrator(Calibrator):\n\t    \"\"\"<xtce:SplineCalibrator>\"\"\"\n\t    _order_mapping = {'zero': 0, 'first': 1, 'second': 2, 'third': 3}\n\t    def __init__(self, points: list, order: int = 0, extrapolate: bool = False):\n", "        \"\"\"Constructor\n\t        Parameters\n\t        ----------\n\t        points : list\n\t            List of SplinePoint objects. These points are sorted by their raw values on instantiation.\n\t        order : int\n\t            Spline order. Only zero and first order splines are supported.\n\t        extrapolate : bool\n\t            Whether or not to allow extrapolation outside the bounds of the spline points. If False, raises an\n\t            error when calibrate is called for a query point outside the bounds of the spline points.\n", "        \"\"\"\n\t        if order > 1:\n\t            raise NotImplementedError(\"Spline calibrators of order > 1 are not implemented. Consider contributing \"\n\t                                      \"if you need this functionality. It does not appear to be commonly used but \"\n\t                                      \"it probably would not be too hard to implement.\")\n\t        self.order = order\n\t        self.points = sorted(points, key=lambda point: point.raw)  # Sort points before storing\n\t        self.extrapolate = extrapolate\n\t    @classmethod\n\t    def from_calibrator_xml_element(cls, element: ElementTree.Element, ns: dict):\n", "        \"\"\"Create a spline default_calibrator object from an <xtce:SplineCalibrator> XML element.\"\"\"\n\t        point_elements = element.findall('xtce:SplinePoint', ns)\n\t        spline_points = [\n\t            SplinePoint(raw=float(p.attrib['raw']), calibrated=float(p.attrib['calibrated']))\n\t            for p in point_elements\n\t        ]\n\t        order = int(cls._order_mapping[element.attrib['order']]) if 'order' in element.attrib else 0\n\t        extrapolate = element.attrib['extrapolate'].lower() == 'true' if 'extrapolate' in element.attrib else False\n\t        return cls(order=order, points=spline_points, extrapolate=extrapolate)\n\t    def calibrate(self, uncalibrated_value: float):\n", "        \"\"\"Take an integer-encoded value and returns a calibrated version according to the spline points.\n\t        Parameters\n\t        ----------\n\t        uncalibrated_value : float\n\t            Query point.\n\t        Returns\n\t        -------\n\t        : float\n\t            Calibrated value\n\t        \"\"\"\n", "        if self.order == 0:\n\t            return self._zero_order_spline_interp(uncalibrated_value)\n\t        if self.order == 1:\n\t            return self._first_order_spline_interp(uncalibrated_value)\n\t        raise NotImplementedError(f\"SplineCalibrator is not implemented for spline order {self.order}.\")\n\t    def _zero_order_spline_interp(self, query_point: float):\n\t        \"\"\"Abstraction for zero order spline interpolation. If extrapolation is set to a truthy value, we use\n\t        the nearest point to extrapolate outside the range of the given spline points. Within the range of spline\n\t        points, we use nearest lower point interpolation.\n\t        Parameters\n", "        ----------\n\t        query_point : float\n\t            Query point.\n\t        Returns\n\t        -------\n\t        : float\n\t            Calibrated value.\n\t        \"\"\"\n\t        x = [float(p.raw) for p in self.points]\n\t        y = [float(p.calibrated) for p in self.points]\n", "        if min(x) <= query_point <= max(x):\n\t            first_greater = [p.raw > query_point for p in self.points].index(True)\n\t            return y[first_greater - 1]\n\t        if query_point > max(x) and self.extrapolate:\n\t            return y[-1]\n\t        if query_point < min(x) and self.extrapolate:\n\t            return y[0]\n\t        raise CalibrationError(f\"Extrapolation is set to a falsy value ({self.extrapolate}) but query value \"\n\t                               f\"{query_point} falls outside the range of spline points {self.points}\")\n\t    def _first_order_spline_interp(self, query_point: float):\n", "        \"\"\"Abstraction for first order spline interpolation. If extrapolation is set to a truthy value, we use the\n\t        end points to make a linear function and use it to extrapolate.\n\t        Parameters\n\t        ----------\n\t        query_point : float\n\t            Query point.\n\t        Returns\n\t        -------\n\t        float\n\t            Calibrated value.\n", "        \"\"\"\n\t        def linear_func(xq: float, x0: float, x1: float, y0: float, y1: float):\n\t            \"\"\"Evaluate a linear function through points (x0, y0), (x1, y1) at point xq\n\t            Parameters\n\t            ----------\n\t            xq : float\n\t            x0 : float\n\t            x1 : float\n\t            y0 : float\n\t            y1 : float\n", "            Returns\n\t            -------\n\t            yq : float\n\t                Interpolated point\n\t            \"\"\"\n\t            slope = (y1 - y0) / (x1 - x0)\n\t            return (slope * (xq - x0)) + y0\n\t        x = [p.raw for p in self.points]\n\t        y = [p.calibrated for p in self.points]\n\t        if min(x) <= query_point <= max(x):\n", "            first_greater = [p.raw > query_point for p in self.points].index(True)\n\t            return linear_func(query_point,\n\t                               x[first_greater - 1], x[first_greater],\n\t                               y[first_greater - 1], y[first_greater])\n\t        if query_point > max(x) and self.extrapolate:\n\t            return linear_func(query_point, x[-2], x[-1], y[-2], y[-1])\n\t        if query_point < min(x) and self.extrapolate:\n\t            return linear_func(query_point, x[0], x[1], y[0], y[1])\n\t        raise CalibrationError(f\"Extrapolation is set to a falsy value ({self.extrapolate}) but query value \"\n\t                               f\"{query_point} falls outside the range of spline points {self.points}\")\n", "PolynomialCoefficient = namedtuple('PolynomialCoefficient', ['coefficient', 'exponent'])\n\tclass PolynomialCalibrator(Calibrator):\n\t    \"\"\"<xtce:PolynomialCalibrator>\"\"\"\n\t    def __init__(self, coefficients: list):\n\t        \"\"\"Constructor\n\t        Parameters\n\t        ----------\n\t        coefficients : list\n\t            List of PolynomialCoefficient objects that define the polynomial.\n\t        \"\"\"\n", "        self.coefficients = coefficients  # Coefficients should be a list of PolynomialCoefficients\n\t    @classmethod\n\t    def from_calibrator_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Create a polynomial default_calibrator object from an <xtce:PolynomialCalibrator> XML element.\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            <xtce:PolynomialCalibrator> XML element\n\t        ns : dict\n\t            Namespace dict\n", "        Returns\n\t        -------\n\t        \"\"\"\n\t        terms = element.findall('xtce:Term', ns)\n\t        coefficients = [\n\t            PolynomialCoefficient(coefficient=float(term.attrib['coefficient']), exponent=int(term.attrib['exponent']))\n\t            for term in terms\n\t        ]\n\t        return cls(coefficients=coefficients)\n\t    def calibrate(self, uncalibrated_value: float):\n", "        \"\"\"Evaluate the polynomial defined by object coefficients at the specified uncalibrated point.\n\t        Parameters\n\t        ----------\n\t        uncalibrated_value : float\n\t            Query point.\n\t        Returns\n\t        -------\n\t        float\n\t            Calibrated value\n\t        \"\"\"\n", "        return sum(a * (uncalibrated_value ** n) for a, n in self.coefficients)\n\tclass MathOperationCalibrator(Calibrator):\n\t    \"\"\"<xtce:MathOperationCalibrator>\"\"\"\n\t    err_msg = \"The MathOperationCalibrator element is not supported in this package but pull requests are welcome!\"\n\t    def __init__(self):\n\t        \"\"\"Constructor\n\t        Not implemented.\n\t        \"\"\"\n\t        raise NotImplementedError(self.err_msg)\n\t    @classmethod\n", "    def from_calibrator_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Create a math operation default_calibrator from an <xtce:MathOperationCalibrator> XML element.\"\"\"\n\t        raise NotImplementedError(cls.err_msg)\n\t    def calibrate(self, uncalibrated_value: int):\n\t        \"\"\"Stub\n\t        Parameters\n\t        ----------\n\t        uncalibrated_value\n\t        Returns\n\t        -------\n", "        \"\"\"\n\t        raise NotImplementedError(self.err_msg)\n\tclass ContextCalibrator(AttrComparable):\n\t    \"\"\"<xtce:ContextCalibrator>\"\"\"\n\t    def __init__(self, match_criteria: list, calibrator: Calibrator):\n\t        \"\"\"Constructor\n\t        Parameters\n\t        ----------\n\t        match_criteria : MatchCriteria or list\n\t            Object representing the logical operations to be performed to determine whether to use this\n", "            default_calibrator. This can be a Comparison, a ComparsonList (a list of Comparison objects),\n\t            a BooleanExpression (not supported), or a CustomAlgorithm (not supported)\n\t        calibrator : Calibrator\n\t            Calibrator to use if match criteria evaluates to True\n\t        \"\"\"\n\t        self.match_criteria = match_criteria\n\t        self.calibrator = calibrator\n\t    @staticmethod\n\t    def get_context_match_criteria(element: ElementTree.Element, ns: dict):\n\t        \"\"\"Parse contextual requirements from a Comparison, ComparisonList, or BooleanExpression\n", "        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            <xtce:ContextCalibrator> XML element from which to parse the ContextCalibrator object.\n\t        ns : dict\n\t            Namespace dict for XML parsing\n\t        Returns\n\t        -------\n\t        : list\n\t            List of Comparisons that can be evaluated to determine whether this calibrator should be used.\n", "        \"\"\"\n\t        context_match_element = element.find('xtce:ContextMatch', ns)\n\t        if context_match_element.find('xtce:ComparisonList', ns) is not None:\n\t            return [Comparison.from_match_criteria_xml_element(el, ns)\n\t                    for el in context_match_element.findall('xtce:ComparisonList/xtce:Comparison', ns)]\n\t        if context_match_element.find('xtce:Comparison', ns) is not None:\n\t            return [Comparison.from_match_criteria_xml_element(\n\t                context_match_element.find('xtce:Comparison', ns), ns)]\n\t        # TODO: Implement handling of BooleanExpression\n\t        raise NotImplementedError(\"ContextCalibrator doesn't contain Comparison on ComparisonList. This probably\"\n", "                                  \"means the match criteria is an unsupported type (BooleanExpression or \"\n\t                                  \"CustomAlgorithm).\")\n\t    @classmethod\n\t    def from_context_calibrator_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Create a ContextCalibrator object from an <xtce:ContextCalibrator> XML element\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            <xtce:ContextCalibrator> XML element from which to parse the ContextCalibrator object.\n\t        ns : dict\n", "            Namespace dict for XML parsing\n\t        Returns\n\t        -------\n\t        : cls\n\t        \"\"\"\n\t        match_criteria = cls.get_context_match_criteria(element, ns)\n\t        if element.find('xtce:Calibrator/xtce:SplineCalibrator', ns) is not None:\n\t            calibrator = SplineCalibrator.from_calibrator_xml_element(\n\t                element.find('xtce:Calibrator/xtce:SplineCalibrator', ns), ns)\n\t        elif element.find('xtce:Calibrator/xtce:PolynomialCalibrator', ns):\n", "            calibrator = PolynomialCalibrator.from_calibrator_xml_element(\n\t                element.find('xtce:Calibrator/xtce:PolynomialCalibrator', ns), ns)\n\t        else:\n\t            raise NotImplementedError(\n\t                \"Unsupported default_calibrator type. space_packet_parser only supports Polynomial and Spline\"\n\t                \"calibrators for ContextCalibrators.\")\n\t        return cls(match_criteria=match_criteria, calibrator=calibrator)\n\t    def calibrate(self, parsed_value):\n\t        \"\"\"Wrapper method for the internal Calibrator.calibrate\n\t        Parameters\n", "        ----------\n\t        parsed_value : int or float\n\t            Uncalibrated value.\n\t        Returns\n\t        -------\n\t        : int or float\n\t            Calibrated value\n\t        \"\"\"\n\t        return self.calibrator.calibrate(parsed_value)\n\t# DataEncoding definitions\n", "class DataEncoding(AttrComparable, metaclass=ABCMeta):\n\t    \"\"\"Abstract base class for XTCE data encodings\"\"\"\n\t    @classmethod\n\t    def from_data_encoding_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Abstract classmethod to create a data encoding object from an XML element.\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            XML element\n\t        ns : dict\n", "            XML namespace dict\n\t        Returns\n\t        -------\n\t        cls\n\t        \"\"\"\n\t        return NotImplemented\n\t    @staticmethod\n\t    def get_default_calibrator(data_encoding_element: ElementTree.Element, ns: dict):\n\t        \"\"\"Gets the default_calibrator for the data encoding element\n\t        Parameters\n", "        ----------\n\t        data_encoding_element : ElementTree.Element\n\t            The data encoding element which should contain the default_calibrator\n\t        ns : dict\n\t            XML namespace dict\n\t        Returns\n\t        -------\n\t        Calibrator\n\t        \"\"\"\n\t        for calibrator in [SplineCalibrator, PolynomialCalibrator, MathOperationCalibrator]:\n", "            # Try to find each type of data encoding element. If we find one, we assume it's the only one.\n\t            element = data_encoding_element.find(f\"xtce:DefaultCalibrator/xtce:{calibrator.__name__}\", ns)\n\t            if element is not None:\n\t                return calibrator.from_calibrator_xml_element(element, ns)\n\t        return None\n\t    @staticmethod\n\t    def get_context_calibrators(data_encoding_element: ElementTree.Element, ns: dict) -> list or None:\n\t        \"\"\"Get the context default_calibrator(s) for the data encoding element\n\t        Parameters\n\t        ----------\n", "        data_encoding_element : ElementTree.Element\n\t            XML element\n\t        ns : dict\n\t            XML namespace dict\n\t        Returns\n\t        -------\n\t        : list\n\t            List of ContextCalibrator objects.\n\t        \"\"\"\n\t        if data_encoding_element.find('xtce:ContextCalibratorList', ns):\n", "            context_calibrators_elements = data_encoding_element.findall(\n\t                'xtce:ContextCalibratorList/xtce:ContextCalibrator', ns)\n\t            return [ContextCalibrator.from_context_calibrator_xml_element(el, ns)\n\t                    for el in context_calibrators_elements]\n\t        return None\n\t    @staticmethod\n\t    def _get_linear_adjuster(parent_element: ElementTree.Element, ns: dict) -> callable or None:\n\t        \"\"\"Examine a parent (e.g. a <xtce:DynamicValue>) element and find a LinearAdjustment if present,\n\t        creating and returning a function that evaluates the adjustment.\n\t        Parameters\n", "        ----------\n\t        parent_element : ElementTree.Element\n\t            Parent element which may contain a LinearAdjustment\n\t        ns : dict\n\t            XML namespace dict\n\t        Returns\n\t        -------\n\t        adjuster : callable\n\t            Function object that adjusts a SizeInBits value by a linear function\n\t        \"\"\"\n", "        linear_adjustment_element = parent_element.find('xtce:LinearAdjustment', ns)\n\t        if linear_adjustment_element is not None:\n\t            slope = (int(linear_adjustment_element.attrib['slope'])\n\t                     if 'slope' in linear_adjustment_element.attrib else 0)\n\t            intercept = (int(linear_adjustment_element.attrib['intercept'])\n\t                         if 'intercept' in linear_adjustment_element.attrib else 0)\n\t            def adjuster(x: int) -> int:\n\t                \"\"\"Perform a linear adjustment to a size parameter\n\t                Parameters\n\t                ----------\n", "                x : int\n\t                    Unadjusted size parameter.\n\t                Returns\n\t                -------\n\t                : int\n\t                    Adjusted size parameter\n\t                \"\"\"\n\t                adjusted = (slope * float(x)) + intercept\n\t                if not adjusted.is_integer():\n\t                    raise ValueError(f\"Error when adjusting a value with a LinearAdjustment. Got y=mx + b as \"\n", "                                     f\"{adjusted}={slope}*{x}+{intercept} returned a float. \"\n\t                                     f\"Should have been an int.\")\n\t                return int(adjusted)\n\t            return adjuster\n\t        return None\n\t    def _get_format_string(self, packet_data: bitstring.ConstBitStream, parsed_data: dict):\n\t        \"\"\"Infer a bitstring format string, possibly using previously parsed data. This is called by parse_value only\n\t        so it's private.\n\t        Parameters\n\t        ----------\n", "        parsed_data: dict\n\t            Dictionary of previously parsed data items for use in determining the format string if necessary.\n\t        Returns\n\t        -------\n\t        : str\n\t            Format string in the bitstring format. e.g. uint:16\n\t        \"\"\"\n\t        raise NotImplementedError()\n\t    def parse_value(self, packet_data: bitstring.ConstBitStream, parsed_data: dict, **kwargs):\n\t        \"\"\"Parse a value from packet data, possibly using previously parsed data items to inform parsing.\n", "        Parameters\n\t        ----------\n\t        packet_data: bitstring.ConstBitStream\n\t            Binary data coming up next in the packet.\n\t        parsed_data: dict\n\t            Previously parsed data items from which to infer parsing details (e.g. length of a field).\n\t        Returns\n\t        -------\n\t        : any\n\t            Raw value\n", "        : any\n\t            Calibrated value\n\t        \"\"\"\n\t        raise NotImplementedError()\n\tclass StringDataEncoding(DataEncoding):\n\t    \"\"\"<xtce:StringDataEncoding>\"\"\"\n\t    def __init__(self, encoding: str = 'utf-8',\n\t                 termination_character: str = None,\n\t                 fixed_length: int = None,\n\t                 leading_length_size: int = None,\n", "                 dynamic_length_reference: str = None,\n\t                 use_calibrated_value: bool = True,\n\t                 discrete_lookup_length: list = None,\n\t                 length_linear_adjuster: callable = None):\n\t        \"\"\"Constructor\n\t        Only one of termination_character, fixed_length, or leading_length_size should be set. Setting more than one\n\t        is nonsensical.\n\t        TODO: implement ByteOrderList to inform endianness.\n\t         This can also relax the requirements on the encoding spec since utf-16-le is redundant if endianness\n\t         comes from the ByteOrderList\n", "        Parameters\n\t        ----------\n\t        encoding : str\n\t            One of 'utf-8', 'utf-16-le', or 'utf-16-be'. Describes how to read the characters in the string.\n\t        termination_character : str\n\t            A single hexadecimal character, represented as a string. Must be encoded in the same encoding as the string\n\t            itself. For example, for a utf-8 encoded string, the hex string must be two hex characters (one byte).\n\t            For a utf-16-* encoded string, the hex representation of the termination character must be four characters\n\t            (two bytes).\n\t        fixed_length : int\n", "            Fixed length of the string, in bits.\n\t        leading_length_size : int\n\t            Fixed size in bits of a leading field that contains the length of the subsequent string.\n\t        dynamic_length_reference : str\n\t            Name of referenced parameter for dynamic length. May be combined with a linear_adjuster\n\t        use_calibrated_value: bool\n\t            Whether to use the calibrated value on the referenced parameter in dynamic_length_reference.\n\t            Default is True.\n\t        discrete_lookup_length : DiscreteLookup\n\t            DiscreteLookup object with which to determine string length from another parameter.\n", "        length_linear_adjuster : callable\n\t            Function that linearly adjusts a size. e.g. if the size reference parameter gives a length in bytes, the\n\t            linear adjuster should multiply by 8 to give the size in bits.\n\t        \"\"\"\n\t        if encoding not in ['utf-8', 'utf-16-le', 'utf-16-be']:\n\t            raise ValueError(\n\t                f\"Got encoding={encoding}. Encoding must be one of utf-8, utf-16-le, or utf-16-be (note that\"\n\t                f\"endianness must be specified for utf-16 encoding.\")\n\t        self.encoding = encoding\n\t        if termination_character and len(bytes.fromhex(termination_character).decode(encoding).encode('utf-8')) != 1:\n", "            raise ValueError(f\"Termination character {termination_character} appears to be malformed. Expected a \"\n\t                             f\"hex string representation of a single character, e.g. '58' for character 'X' in utf-8 \"\n\t                             f\"or '5800' for character 'X' in utf-16-le. Note that variable-width encoding is not \"\n\t                             f\"yet supported in any encoding.\")\n\t        self.termination_character = termination_character  # Always in hex, per 4.3.2.2.5.5.4 of XTCE spec\n\t        self.fixed_length = fixed_length\n\t        self.leading_length_size = leading_length_size\n\t        self.dynamic_length_reference = dynamic_length_reference\n\t        self.use_calibrated_value = use_calibrated_value\n\t        self.discrete_lookup_length = discrete_lookup_length\n", "        self.length_linear_adjuster = length_linear_adjuster\n\t    def _get_format_string(self, packet_data: bitstring.ConstBitStream, parsed_data: dict):\n\t        \"\"\"Infer a bitstring format string\n\t        Parameters\n\t        ----------\n\t        parsed_data: dict\n\t            Dictionary of previously parsed data items for use in determining the format string if necessary.\n\t        packet_data: bitstring.ConstBitStream\n\t            Packet data, which can be used to determine the string length from a leading value\n\t            or from a termination character.\n", "        Returns\n\t        -------\n\t        : str or None\n\t            Format string in the bitstring format. e.g. uint:16\n\t        : int or None\n\t            Number of bits to skip after parsing the string\n\t        \"\"\"\n\t        skip_bits_after = 0  # Gets modified if we have a termination character\n\t        if self.fixed_length:\n\t            strlen_bits = self.fixed_length\n", "        elif self.leading_length_size is not None:  # strlen_bits is determined from a preceding integer\n\t            leading_strlen_bitstring_format = f\"uint:{self.leading_length_size}\"\n\t            strlen_bits = packet_data.read(leading_strlen_bitstring_format)\n\t        elif self.discrete_lookup_length is not None:\n\t            for discrete_lookup in self.discrete_lookup_length:\n\t                strlen_bits = discrete_lookup.evaluate(parsed_data)\n\t                if strlen_bits is not None:\n\t                    break\n\t            else:\n\t                raise ValueError('List of discrete lookup values being used for determining length of '\n", "                                 f'string {self} found no matches based on {parsed_data}.')\n\t        elif self.dynamic_length_reference is not None:\n\t            if self.use_calibrated_value is True:\n\t                strlen_bits = parsed_data[self.dynamic_length_reference].derived_value\n\t            else:\n\t                strlen_bits = parsed_data[self.dynamic_length_reference].raw_value\n\t            strlen_bits = int(strlen_bits)\n\t        elif self.termination_character is not None:\n\t            print(f\"hex termination character: {self.termination_character}\")\n\t            termination_char_utf8_bytes = bytes.fromhex(self.termination_character)\n", "            print(f\"bytes termination character (utf-8): {termination_char_utf8_bytes}, \"\n\t                  f\"len={len(termination_char_utf8_bytes)}\")\n\t            if self.encoding in ['utf-16-le', 'utf-16-be']:\n\t                bytes_per_char = 2\n\t            elif self.encoding == 'utf-8':\n\t                bytes_per_char = 1\n\t            else:\n\t                raise ValueError(\n\t                    f\"Got encoding={self.encoding}. Encoding must be one of utf-8, utf-16-le, or utf-16-be (note that\"\n\t                    f\"endianness must be specified for utf-16 encoding.\")\n", "            bits_per_byte = 8\n\t            look_ahead_n_bytes = 0\n\t            while look_ahead_n_bytes <= len(packet_data) - packet_data.pos:\n\t                print(f\"looking ahead {look_ahead_n_bytes} bytes\")\n\t                look_ahead = packet_data.peek(f'bytes:{look_ahead_n_bytes}')  # Outputs UTF-8 encoded byte string\n\t                look_ahead = look_ahead.decode('utf-8').encode(self.encoding)  # Force specified encoding\n\t                print(f\"string so far: {look_ahead}\")\n\t                if termination_char_utf8_bytes in look_ahead:\n\t                    print('Found termination character.')\n\t                    # Implicit assumption of one termination character in specified encoding\n", "                    tclen_bits = bytes_per_char * bits_per_byte\n\t                    strlen_bits = (look_ahead_n_bytes * bits_per_byte) - tclen_bits\n\t                    skip_bits_after = tclen_bits\n\t                    break\n\t                look_ahead_n_bytes += bytes_per_char\n\t            else:\n\t                raise ValueError(f\"Reached end of binary string without finding \"\n\t                                 f\"termination character {self.termination_character}.\")\n\t        else:\n\t            raise ValueError(\"Unable to parse StringParameterType. \"\n", "                             \"Didn't contain any way to constrain the length of the string.\")\n\t        if self.length_linear_adjuster is not None:\n\t            strlen_bits = self.length_linear_adjuster(strlen_bits)\n\t        return f\"bytes:{strlen_bits // 8}\", skip_bits_after\n\t    def parse_value(self, packet_data: bitstring.ConstBitStream, parsed_data: dict, **kwargs):\n\t        \"\"\"Parse a value from packet data, possibly using previously parsed data items to inform parsing.\n\t        Parameters\n\t        ----------\n\t        packet_data: bitstring.ConstBitStream\n\t            Binary data coming up next in the packet.\n", "        parsed_data: dict, Optional\n\t            Previously parsed data items from which to infer parsing details (e.g. length of a field).\n\t        Returns\n\t        -------\n\t        : any\n\t            Parsed value\n\t        : any\n\t            Calibrated value\n\t        \"\"\"\n\t        bitstring_format, skip_bits_after = self._get_format_string(packet_data, parsed_data)\n", "        parsed_value = packet_data.read(bitstring_format)\n\t        packet_data.pos += skip_bits_after  # Allows skip over termination character\n\t        return parsed_value.decode(self.encoding), None\n\t    @classmethod\n\t    def from_data_encoding_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Create a data encoding object from an <xtce:StringDataEncoding> XML element.\n\t        Strings in XTCE can be described in three ways:\n\t        1. Using a termination character that marks the end of the string.\n\t        2. Using a fixed length, which may be derived from referenced parameter either directly or via a discrete lookup table.\n\t        3. Using a leading size field that describes the size of the following string.\n", "        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            XML element\n\t        ns : dict\n\t            XML namespace dict\n\t        Returns\n\t        -------\n\t        cls\n\t        \"\"\"\n", "        try:\n\t            encoding = element.attrib['encoding']\n\t        except KeyError:\n\t            encoding = 'utf-8'\n\t        try:\n\t            termination_character = element.find('xtce:SizeInBits/xtce:TerminationChar', ns).text\n\t            return cls(termination_character=termination_character, encoding=encoding)\n\t        except AttributeError:\n\t            pass\n\t        try:\n", "            leading_length_size = int(\n\t                element.find('xtce:SizeInBits/xtce:LeadingSize', ns).attrib['sizeInBitsOfSizeTag'])\n\t            return cls(leading_length_size=leading_length_size, encoding=encoding)\n\t        except AttributeError:\n\t            pass\n\t        fixed_element = element.find('xtce:SizeInBits/xtce:Fixed', ns)\n\t        discrete_lookup_list_element = fixed_element.find('xtce:DiscreteLookupList', ns)\n\t        if discrete_lookup_list_element is not None:\n\t            discrete_lookup_list = [DiscreteLookup.from_discrete_lookup_xml_element(el, ns)\n\t                                    for el in discrete_lookup_list_element.findall('xtce:DiscreteLookup', ns)]\n", "            return cls(encoding=encoding,\n\t                       discrete_lookup_length=discrete_lookup_list)\n\t        try:\n\t            dynamic_value_element = fixed_element.find('xtce:DynamicValue', ns)\n\t            referenced_parameter = dynamic_value_element.find('xtce:ParameterInstanceRef', ns).attrib['parameterRef']\n\t            use_calibrated_value = True\n\t            if 'useCalibratedValue' in dynamic_value_element.find('xtce:ParameterInstanceRef', ns).attrib:\n\t                use_calibrated_value = dynamic_value_element.find(\n\t                    'xtce:ParameterInstanceRef', ns).attrib['useCalibratedValue'].lower() == \"true\"\n\t            linear_adjuster = cls._get_linear_adjuster(dynamic_value_element, ns)\n", "            return cls(encoding=encoding,\n\t                       dynamic_length_reference=referenced_parameter, use_calibrated_value=use_calibrated_value,\n\t                       length_linear_adjuster=linear_adjuster)\n\t        except AttributeError:\n\t            pass\n\t        try:\n\t            fixed_length = int(fixed_element.find('xtce:FixedValue', ns).text)\n\t            return cls(fixed_length=fixed_length, encoding=encoding)\n\t        except AttributeError:\n\t            pass\n", "        raise ElementNotFoundError(f\"Failed to parse StringDataEncoding for element {ElementTree.tostring(element)}\")\n\tclass NumericDataEncoding(DataEncoding, metaclass=ABCMeta):\n\t    \"\"\"Abstract class that is inherited by IntegerDataEncoding and FloatDataEncoding\"\"\"\n\t    def __init__(self, size_in_bits: int, encoding: str,\n\t                 default_calibrator: Calibrator = None, context_calibrators: list = None):\n\t        \"\"\"Constructor\n\t        # TODO: Implement ByteOrderList to inform endianness\n\t        Parameters\n\t        ----------\n\t        size_in_bits : int\n", "            Size of the integer\n\t        encoding : str\n\t            String indicating the type of encoding for the integer. FSW seems to use primarily 'signed' and 'unsigned',\n\t            though 'signed' is not actually a valid specifier according to XTCE. 'twosCompliment' [sic] should be used\n\t            instead, though we support the unofficial 'signed' specifier here.\n\t            For supported specifiers, see XTCE spec 4.3.2.2.5.6.2\n\t        default_calibrator : Calibrator\n\t            Optional Calibrator object, containing information on how to transform the integer-encoded data, e.g. via\n\t            a polynomial conversion or spline interpolation.\n\t        context_calibrators : list\n", "            List of ContextCalibrator objects, containing match criteria and corresponding calibrators to use in\n\t            various scenarios, based on other parameters.\n\t        \"\"\"\n\t        self.size_in_bits = size_in_bits\n\t        self.encoding = encoding\n\t        self.default_calibrator = default_calibrator\n\t        self.context_calibrators = context_calibrators\n\t    def parse_value(self, packet_data: bitstring.ConstBitStream, parsed_data: dict, **kwargs):\n\t        \"\"\"Parse a value from packet data, possibly using previously parsed data items to inform parsing.\n\t        Parameters\n", "        ----------\n\t        packet_data: bitstring.ConstBitStream\n\t            Binary data coming up next in the packet.\n\t        parsed_data: dict, Optional\n\t            Previously parsed data items from which to infer parsing details (e.g. length of a field).\n\t        Returns\n\t        -------\n\t        : any\n\t            Parsed value\n\t        : any\n", "            Calibrated value\n\t        \"\"\"\n\t        bitstring_format = self._get_format_string(packet_data, parsed_data)\n\t        parsed_value = packet_data.read(bitstring_format)\n\t        # Attempt to calibrate\n\t        calibrated_value = parsed_value  # Provides a fall through in case we have no calibrators\n\t        if self.context_calibrators:\n\t            for calibrator in self.context_calibrators:\n\t                match_criteria = calibrator.match_criteria\n\t                if all(criterion.evaluate(parsed_data, parsed_value) for criterion in match_criteria):\n", "                    # If the parsed data so far satisfy all the match criteria\n\t                    calibrated_value = calibrator.calibrate(parsed_value)\n\t                    return parsed_value, calibrated_value\n\t        if self.default_calibrator:  # If no context calibrators or if none apply and there is a default\n\t            calibrated_value = self.default_calibrator.calibrate(parsed_value)\n\t        # Ultimate fallthrough\n\t        return parsed_value, calibrated_value\n\tclass IntegerDataEncoding(NumericDataEncoding):\n\t    \"\"\"<xtce:IntegerDataEncoding>\"\"\"\n\t    def _get_format_string(self, packet_data: bitstring.ConstBitStream, parsed_data: dict):\n", "        \"\"\"Infer a bitstring format string\n\t        Returns\n\t        -------\n\t        str\n\t            Format string in the bitstring format. e.g. uint:16\n\t        \"\"\"\n\t        if self.encoding == 'unsigned':\n\t            base = 'uint'\n\t        elif self.encoding == 'signed':\n\t            base = 'int'\n", "        elif self.encoding in ('twosCompliment', 'twosComplement'):  # [sic]\n\t            base = 'int'\n\t        else:\n\t            raise NotImplementedError(f\"Unrecognized encoding {self.encoding}. \"\n\t                                      f\"Only signed and unsigned have been implemented.\")\n\t        return f\"{base}:{self.size_in_bits}\"\n\t    @classmethod\n\t    def from_data_encoding_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Create a data encoding object from an <xtce:IntegerDataEncoding> XML element.\n\t        Parameters\n", "        ----------\n\t        element : ElementTree.Element\n\t            XML element\n\t        ns : dict\n\t            XML namespace dict\n\t        Returns\n\t        -------\n\t        : cls\n\t        \"\"\"\n\t        size_in_bits = int(element.attrib['sizeInBits'])\n", "        encoding = element.attrib['encoding']\n\t        calibrator = cls.get_default_calibrator(element, ns)\n\t        context_calibrators = cls.get_context_calibrators(element, ns)\n\t        return cls(size_in_bits=size_in_bits, encoding=encoding,\n\t                   default_calibrator=calibrator, context_calibrators=context_calibrators)\n\tclass FloatDataEncoding(NumericDataEncoding):\n\t    \"\"\"<xtce:FloatDataEncoding>\"\"\"\n\t    _supported_encodings = ['IEEE-754', 'MIL-1750A']\n\t    def __init__(self, size_in_bits: int, encoding: str = 'IEEE-754',\n\t                 default_calibrator: Calibrator = None, context_calibrators: list = None):\n", "        \"\"\"Constructor\n\t        # TODO: Implement MIL-1650A encoding option\n\t        # TODO: support ByteOrderList to inform endianness. Currently we assume big-endian always.\n\t        Parameters\n\t        ----------\n\t        size_in_bits : int\n\t            Size of the encoded value, in bits.\n\t        encoding : str\n\t            Encoding method of the float data. Must be either 'IEEE-754' or 'MIL-1750A'. Defaults to IEEE-754.\n\t        default_calibrator : Calibrator\n", "            Optional Calibrator object, containing information on how to transform the data, e.g. via\n\t            a polynomial conversion or spline interpolation.\n\t        context_calibrators : list\n\t            List of ContextCalibrator objects, containing match criteria and corresponding calibrators to use in\n\t            various scenarios, based on other parameters.\n\t        \"\"\"\n\t        if encoding not in self._supported_encodings:\n\t            raise ValueError(f\"Invalid encoding type {encoding} for float data. \"\n\t                             f\"Must be one of {self._supported_encodings}.\")\n\t        if encoding == 'MIL-1750A':\n", "            raise NotImplementedError(\"MIL-1750A encoded floats are not supported by this library yet.\")\n\t        super().__init__(size_in_bits, encoding=encoding,\n\t                         default_calibrator=default_calibrator, context_calibrators=context_calibrators)\n\t    def _get_format_string(self, packet_data: bitstring.ConstBitStream, parsed_data: dict):\n\t        \"\"\"Infer a bitstring format string\n\t        Returns\n\t        -------\n\t        str\n\t            Format string in the bitstring format. e.g. uint:16\n\t        \"\"\"\n", "        return f\"floatbe:{self.size_in_bits}\"\n\t    @classmethod\n\t    def from_data_encoding_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Create a data encoding object from an <xtce:FloatDataEncoding> XML element.\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            XML element\n\t        ns : dict\n\t            XML namespace dict\n", "        Returns\n\t        -------\n\t        : cls\n\t        \"\"\"\n\t        size_in_bits = int(element.attrib['sizeInBits'])\n\t        if 'encoding' in element.attrib:\n\t            encoding = element.attrib['encoding']\n\t        else:\n\t            encoding = 'IEEE-754'\n\t        default_calibrator = cls.get_default_calibrator(element, ns)\n", "        context_calibrators = cls.get_context_calibrators(element, ns)\n\t        return cls(size_in_bits=size_in_bits, encoding=encoding,\n\t                   default_calibrator=default_calibrator, context_calibrators=context_calibrators)\n\tclass BinaryDataEncoding(DataEncoding):\n\t    \"\"\"<xtce:BinaryDataEncoding>\"\"\"\n\t    def __init__(self, fixed_size_in_bits: int = None,\n\t                 size_reference_parameter: str = None, use_calibrated_value: bool = True,\n\t                 size_discrete_lookup_list: list = None,\n\t                 linear_adjuster: callable = None):\n\t        \"\"\"Constructor\n", "        Parameters\n\t        ----------\n\t        fixed_size_in_bits : int\n\t            Fixed size for the binary field, in bits.\n\t        size_reference_parameter : str\n\t            Name of a parameter to reference for the binary field length, in bits. Note that space often specifies these\n\t            fields in byte length, not bit length. This should be taken care of by a LinearAdjuster element that simply\n\t            instructs the value to be multiplied by 8 but that hasn't historically been implemented unfortunately.\n\t        use_calibrated_value: bool, Optional\n\t            Default True. If False, the size_reference_parameter is examined for its raw value.\n", "        size_discrete_lookup_list: list\n\t            List of DiscreteLookup objects by which to determine the length of the binary data field. This suffers from\n\t            the same bit/byte conversion problem as size_reference_parameter.\n\t        linear_adjuster : callable\n\t            Function that linearly adjusts a size. e.g. if the size reference parameter gives a length in bytes, the\n\t            linear adjuster should multiply by 8 to give the size in bits.\n\t        \"\"\"\n\t        self.fixed_size_in_bits = fixed_size_in_bits\n\t        self.size_reference_parameter = size_reference_parameter\n\t        self.use_calibrated_value = use_calibrated_value\n", "        self.size_discrete_lookup_list = size_discrete_lookup_list\n\t        self.linear_adjuster = linear_adjuster\n\t    def _get_format_string(self, packet_data: bitstring.ConstBitStream, parsed_data: dict):\n\t        \"\"\"Infer a bitstring format string\n\t        Returns\n\t        -------\n\t        : str or None\n\t            Format string in the bitstring format. e.g. bin:1024\n\t        \"\"\"\n\t        if self.fixed_size_in_bits is not None:\n", "            len_bits = self.fixed_size_in_bits\n\t        elif self.size_reference_parameter is not None:\n\t            field_length_reference = self.size_reference_parameter\n\t            if self.use_calibrated_value:\n\t                len_bits = parsed_data[field_length_reference].derived_value\n\t            else:\n\t                len_bits = parsed_data[field_length_reference].raw_value\n\t        elif self.size_discrete_lookup_list is not None:\n\t            for discrete_lookup in self.size_discrete_lookup_list:\n\t                len_bits = discrete_lookup.evaluate(parsed_data)\n", "                if len_bits is not None:\n\t                    break\n\t            else:\n\t                raise ValueError('List of discrete lookup values being used for determining length of '\n\t                                 f'string {self} found no matches based on {parsed_data}.')\n\t        else:\n\t            raise ValueError(\"Unable to parse BinaryDataEncoding. \"\n\t                             \"No fixed size, dynamic size, or dynamic lookup size were provided.\")\n\t        if self.linear_adjuster is not None:\n\t            len_bits = self.linear_adjuster(len_bits)\n", "        return f\"bin:{len_bits}\"\n\t    def parse_value(self, packet_data: bitstring.ConstBitStream, parsed_data: dict, word_size: int = None, **kwargs):\n\t        \"\"\"Parse a value from packet data, possibly using previously parsed data items to inform parsing.\n\t        Parameters\n\t        ----------\n\t        packet_data: bitstring.ConstBitStream\n\t            Binary data coming up next in the packet.\n\t        parsed_data: dict, Optional\n\t            Previously parsed data items from which to infer parsing details (e.g. length of a field).\n\t        word_size : int, Optional\n", "            Word size for encoded data. This is used to ensure that the cursor ends up at the end of the last word\n\t            and ready to parse the next data field.\n\t        Returns\n\t        -------\n\t        : any\n\t            Parsed value\n\t        : any\n\t            Calibrated value\n\t        \"\"\"\n\t        bitstring_format = self._get_format_string(packet_data, parsed_data)\n", "        parsed_value = packet_data.read(bitstring_format)\n\t        if word_size:\n\t            cursor_position_in_word = packet_data.pos % word_size\n\t            if cursor_position_in_word != 0:\n\t                logger.debug(f\"Adjusting cursor position to the end of a {word_size} bit word.\")\n\t                packet_data.pos += word_size - cursor_position_in_word\n\t        return parsed_value, None\n\t    @classmethod\n\t    def from_data_encoding_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Create a data encoding object from an <xtce:BinaryDataEncoding> XML element.\n", "        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            XML element\n\t        ns : dict\n\t            XML namespace dict\n\t        Returns\n\t        -------\n\t        : cls\n\t        \"\"\"\n", "        fixed_value_element = element.find('xtce:SizeInBits/xtce:FixedValue', ns)\n\t        if fixed_value_element is not None:\n\t            fixed_size_in_bits = int(fixed_value_element.text)\n\t            return cls(fixed_size_in_bits=fixed_size_in_bits)\n\t        dynamic_value_element = element.find('xtce:SizeInBits/xtce:DynamicValue', ns)\n\t        if dynamic_value_element is not None:\n\t            param_inst_ref = dynamic_value_element.find('xtce:ParameterInstanceRef', ns)\n\t            referenced_parameter = param_inst_ref.attrib['parameterRef']\n\t            use_calibrated_value = True\n\t            if 'useCalibratedValue' in param_inst_ref.attrib:\n", "                use_calibrated_value = param_inst_ref.attrib['useCalibratedValue'].lower() == \"true\"\n\t            linear_adjuster = cls._get_linear_adjuster(dynamic_value_element, ns)\n\t            return cls(size_reference_parameter=referenced_parameter,\n\t                       use_calibrated_value=use_calibrated_value, linear_adjuster=linear_adjuster)\n\t        discrete_lookup_list_element = element.find('xtce:SizeInBits/xtce:DiscreteLookupList', ns)\n\t        if discrete_lookup_list_element is not None:\n\t            discrete_lookup_list = [DiscreteLookup.from_discrete_lookup_xml_element(el, ns)\n\t                                    for el in discrete_lookup_list_element.findall('xtce:DiscreteLookup', ns)]\n\t            return cls(size_discrete_lookup_list=discrete_lookup_list)\n\t        raise ValueError(\"Tried parsing a binary parameter length using Fixed, Dynamic, and DiscreteLookupList \"\n", "                         \"but failed. See 3.4.5 of the XTCE Green Book CCSDS 660.1-G-2.\")\n\t# ParameterType definitions\n\tclass ParameterType(AttrComparable, metaclass=ABCMeta):\n\t    \"\"\"Abstract base class for XTCE parameter types\"\"\"\n\t    def __init__(self, name: str, encoding: DataEncoding, unit: str = None):\n\t        \"\"\"Constructor\n\t        Parameters\n\t        ----------\n\t        name : str\n\t            Parameter type name. Usually something like 'MSN__PARAM_Type'\n", "        encoding : DataEncoding\n\t            How the data is encoded. e.g. IntegerDataEncoding, StringDataEncoding, etc.\n\t        unit : str\n\t            String describing the unit for the stored value.\n\t        \"\"\"\n\t        self.name = name\n\t        self.unit = unit\n\t        self.encoding = encoding\n\t    def __repr__(self):\n\t        module = self.__class__.__module__\n", "        qualname = self.__class__.__qualname__\n\t        return f\"<{module}.{qualname} {self.name}>\"\n\t    @classmethod\n\t    def from_parameter_type_xml_element(cls, element: ElementTree.Element, ns: dict):\n\t        \"\"\"Create an IntegerParameterType from an <xtce:IntegerParameterType> XML element.\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            The XML element from which to create the object.\n\t        ns: dict\n", "            XML namespace dict\n\t        Returns\n\t        -------\n\t        : IntegerParameterType\n\t        \"\"\"\n\t        name = element.attrib['name']\n\t        unit = cls.get_units(element, ns)\n\t        encoding = cls.get_data_encoding(element, ns)\n\t        return cls(name, encoding, unit)\n\t    @staticmethod\n", "    def get_units(parameter_type_element: ElementTree.Element, ns: dict) -> str or None:\n\t        \"\"\"Finds the units associated with a parameter type element and parsed them to return a unit string.\n\t        We assume only one <xtce:Unit> but this could be extended to support multiple units.\n\t        See section 4.3.2.2.4 of CCSDS 660.1-G-1\n\t        Parameters\n\t        ----------\n\t        parameter_type_element : ElementTree.Element\n\t            The parameter type element\n\t        ns : dict\n\t            XML namespace dictionary\n", "        Returns\n\t        -------\n\t        : str or None\n\t        \"\"\"\n\t        units = parameter_type_element.findall('xtce:UnitSet/xtce:Unit', ns)\n\t        # TODO: Implement multiple unit elements for compound unit definitions\n\t        assert len(units) <= 1, f\"Found {len(units)} <xtce:Unit> elements in a single <xtce:UnitSet>.\" \\\n\t                                f\"This is supported in the standard but is rarely used \" \\\n\t                                f\"and is not yet supported by this library.\"\n\t        if units:\n", "            return \" \".join([u.text for u in units])\n\t        return None\n\t    @staticmethod\n\t    def get_data_encoding(parameter_type_element: ElementTree.Element, ns: dict) -> DataEncoding or None:\n\t        \"\"\"Finds the data encoding XML element associated with a parameter type XML element and parses\n\t        it, returning an object representation of the data encoding.\n\t        Parameters\n\t        ----------\n\t        parameter_type_element : ElementTree.Element\n\t            The parameter type element\n", "        ns : dict\n\t            XML namespace dictionary\n\t        Returns\n\t        -------\n\t        : DataEncoding or None\n\t        \"\"\"\n\t        for data_encoding in [StringDataEncoding, IntegerDataEncoding, FloatDataEncoding, BinaryDataEncoding]:\n\t            # Try to find each type of data encoding element. If we find one, we assume it's the only one.\n\t            element = parameter_type_element.find(f\"xtce:{data_encoding.__name__}\", ns)\n\t            if element is not None:\n", "                return data_encoding.from_data_encoding_xml_element(element, ns)\n\t    def parse_value(self, packet_data: bitstring.ConstBitStream, parsed_data: dict, **kwargs):\n\t        \"\"\"Using the parameter type definition and associated data encoding, parse a value from a bit stream starting\n\t        at the current cursor position.\n\t        Parameters\n\t        ----------\n\t        packet_data : bitstring.ConstBitStream\n\t            Binary packet data with cursor at the beginning of this parameter's data field.\n\t        parsed_data: dict\n\t            Previously parsed data to inform parsing.\n", "        Returns\n\t        -------\n\t        parsed_value : any\n\t            Resulting parsed data value.\n\t        \"\"\"\n\t        return self.encoding.parse_value(packet_data, parsed_data, **kwargs)\n\tclass StringParameterType(ParameterType):\n\t    \"\"\"<xtce:StringParameterType>\"\"\"\n\t    def __init__(self, name: str, encoding: StringDataEncoding, unit: str = None):\n\t        \"\"\"Constructor\n", "        Parameters\n\t        ----------\n\t        name : str\n\t            Parameter type name. Usually something like 'MSN__PARAM_Type'\n\t        encoding : StringDataEncoding\n\t            Must be a StringDataEncoding object since strings can't be encoded other ways.\n\t        unit : str\n\t            String describing the unit for the stored value.\n\t        \"\"\"\n\t        if not isinstance(encoding, StringDataEncoding):\n", "            raise ValueError(\"StringParameterType may only be instantiated with a StringDataEncoding encoding.\")\n\t        super().__init__(name=name, encoding=encoding, unit=unit)\n\t        self.encoding = encoding  # Clarifies to static analysis tools that self.encoding is type StringDataEncoding\n\tclass IntegerParameterType(ParameterType):\n\t    \"\"\"<xtce:IntegerParameterType>\"\"\"\n\t    pass\n\tclass FloatParameterType(ParameterType):\n\t    \"\"\"<xtce:FloatParameterType>\"\"\"\n\t    pass\n\tclass EnumeratedParameterType(ParameterType):\n", "    \"\"\"<xtce:EnumeratedParameterType>\"\"\"\n\t    def __init__(self, name: str, encoding: DataEncoding, enumeration: dict, unit: str or None = None):\n\t        \"\"\"Constructor\n\t        Parameters\n\t        ----------\n\t        name : str\n\t            Parameter type name.\n\t        unit : str\n\t            Unit string for stored value.\n\t        encoding : DataEncoding\n", "            How the data is encoded. e.g. IntegerDataEncoding.\n\t        enumeration : dict\n\t            Lookup with label:value pairs matching encoded values to their enum labels.\n\t        \"\"\"\n\t        super().__init__(name=name, encoding=encoding, unit=unit)\n\t        self.enumeration = enumeration\n\t    def __repr__(self):\n\t        return f\"<{self.__class__.__name__} {self.name}>\"\n\t    @classmethod\n\t    def from_parameter_type_xml_element(cls, element: ElementTree.Element, ns: dict):\n", "        \"\"\"Create an EnumeratedParameterType from an <xtce:EnumeratedParameterType> XML element.\n\t        Overrides ParameterType.from_parameter_type_xml_element\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            The XML element from which to create the object.\n\t        ns: dict\n\t            XML namespace dict\n\t        Returns\n\t        -------\n", "        : EnumeratedParameterType\n\t        \"\"\"\n\t        name = element.attrib['name']\n\t        unit = cls.get_units(element, ns)\n\t        encoding = cls.get_data_encoding(element, ns)\n\t        enumeration = cls.get_enumeration_list_contents(element, ns)\n\t        return cls(name, encoding, enumeration=enumeration, unit=unit)\n\t    @staticmethod\n\t    def get_enumeration_list_contents(element: ElementTree.Element, ns: dict) -> dict:\n\t        \"\"\"Finds the <xtce:EnumerationList> element child of an <xtce:EnumeratedParameterType> and parses it,\n", "        returning a dict. This method is confusingly named as if it might return a list. Sorry, XML and python\n\t        semantics are not always compatible. It's called an enumeration list because the XML element is called\n\t        <xtce:EnumerationList> but it contains key value pairs, so it's best represeneted as a dict.\n\t        Parameters\n\t        ----------\n\t        element : ElementTree.Element\n\t            The XML element from which to search for EnumerationList tags\n\t        ns : dict\n\t            XML namespace dict\n\t        Returns\n", "        -------\n\t        : dict\n\t        \"\"\"\n\t        enumeration_list = element.find('xtce:EnumerationList', ns)\n\t        if enumeration_list is None:\n\t            raise ValueError(\"An EnumeratedParameterType must contain an EnumerationList.\")\n\t        return {\n\t            el.attrib['label']: int(el.attrib['value'])\n\t            for el in enumeration_list.iterfind('xtce:Enumeration', ns)\n\t        }\n", "    def parse_value(self, packet_data: bitstring.ConstBitStream, parsed_data: dict, **kwargs):\n\t        \"\"\"Using the parameter type definition and associated data encoding, parse a value from a bit stream starting\n\t        at the current cursor position.\n\t        Parameters\n\t        ----------\n\t        packet_data : bitstring.ConstBitStream\n\t            Binary packet data with cursor at the beginning of this parameter's data field.\n\t        parsed_data : dict\n\t            Previously parsed data\n\t        Returns\n", "        -------\n\t        parsed_value : int\n\t            Raw encoded value\n\t        derived_value : str\n\t            Resulting enum label associated with the (usually integer-)encoded data value.\n\t        \"\"\"\n\t        raw, _ = super().parse_value(packet_data, parsed_data, **kwargs)\n\t        # Note: The enum lookup only operates on raw values. This is specified in 4.3.2.4.3.6 of the XTCE spec \"\n\t        # CCSDS 660.1-G-2\n\t        try:\n", "            label = next(key for key, value in self.enumeration.items() if value == raw)\n\t        except StopIteration as exc:\n\t            raise ValueError(f\"Failed to find raw value {raw} in enum lookup list {self.enumeration}.\") from exc\n\t        return raw, label\n\tclass BinaryParameterType(ParameterType):\n\t    \"\"\"<xtce:BinaryParameterType>\"\"\"\n\t    def __init__(self, name: str, encoding: BinaryDataEncoding, unit: str = None):\n\t        \"\"\"Constructor\n\t        Parameters\n\t        ----------\n", "        name : str\n\t            Parameter type name. Usually something like 'MSN__PARAM_Type'\n\t        encoding : BinaryDataEncoding\n\t            Must be a BinaryDataEncoding object since binary data can't be encoded other ways.\n\t        unit : str\n\t            String describing the unit for the stored value.\n\t        \"\"\"\n\t        if not isinstance(encoding, BinaryDataEncoding):\n\t            raise ValueError(\"BinaryParameterType may only be instantiated with a BinaryDataEncoding encoding.\")\n\t        super().__init__(name=name, encoding=encoding, unit=unit)\n", "        self.encoding = encoding\n\tclass Parameter:\n\t    \"\"\"<xtce:Parameter>\"\"\"\n\t    def __init__(self, name: str, parameter_type: ParameterType):\n\t        \"\"\"Constructor\n\t        Parameters\n\t        ----------\n\t        name : str\n\t            Parameter name. Typically something like MSN__PARAMNAME\n\t        parameter_type : ParameterType\n", "            Parameter type object that describes how the parameter is stored.\n\t        \"\"\"\n\t        self.name = name\n\t        self.parameter_type = parameter_type\n\t    def __repr__(self):\n\t        module = self.__class__.__module__\n\t        qualname = self.__class__.__qualname__\n\t        return f\"<{module}.{qualname} {self.name}>\"\n\tclass SequenceContainer:\n\t    \"\"\"<xtce:SequenceContainer>\"\"\"\n", "    def __init__(self,\n\t                 name: str,\n\t                 entry_list: list,\n\t                 short_description: str = None,\n\t                 long_description: str = None,\n\t                 base_container_name: str = None,\n\t                 restriction_criteria: list = None,\n\t                 abstract: bool = False,\n\t                 inheritors: list = None):\n\t        \"\"\"Object representation of <xtce:SequenceContainer>\n", "        Parameters\n\t        ----------\n\t        name : str\n\t            Container name\n\t        entry_list : list\n\t            List of Parameter objects\n\t        long_description : str\n\t            Long description of the container\n\t        base_container_name : str\n\t            Name of the base container from which this may inherit if restriction criteria are met.\n", "        restriction_criteria : list\n\t            A list of MatchCriteria elements that evaluate to determine whether the SequenceContainer should\n\t            be included.\n\t        abstract : bool\n\t            True if container has abstract=true attribute. False otherwise.\n\t        inheritors : list, Optional\n\t            List of SequenceContainer objects that may inherit this one's entry list if their restriction criteria\n\t            are met. Any SequenceContainers with this container as base_container_name should be listed here.\n\t        \"\"\"\n\t        self.name = name\n", "        self.entry_list = entry_list  # List of Parameter objects, found by reference\n\t        self.short_description = short_description\n\t        self.long_description = long_description\n\t        self.base_container_name = base_container_name\n\t        self.restriction_criteria = restriction_criteria if restriction_criteria else []\n\t        self.abstract = abstract\n\t        self.inheritors = inheritors if inheritors else []\n\t    def __repr__(self):\n\t        module = self.__class__.__module__\n\t        qualname = self.__class__.__qualname__\n", "        return f\"<{module}.{qualname} {self.name}>\"\n\tFlattenedContainer = namedtuple('FlattenedContainer', ['entry_list', 'restrictions'])\n\tclass XtcePacketDefinition:\n\t    \"\"\"Object representation of the XTCE definition of a CCSDS packet object\"\"\"\n\t    _default_namespace = {'xtce': 'http://www.omg.org/space/xtce'}\n\t    _tag_to_type_template = {\n\t        '{{{xtce}}}StringParameterType': StringParameterType,\n\t        '{{{xtce}}}IntegerParameterType': IntegerParameterType,\n\t        '{{{xtce}}}FloatParameterType': FloatParameterType,\n\t        '{{{xtce}}}EnumeratedParameterType': EnumeratedParameterType,\n", "        '{{{xtce}}}BinaryParameterType': BinaryParameterType,\n\t    }\n\t    def __init__(self, xtce_document: str or Path, ns: dict = None):\n\t        \"\"\"Instantiate an object representation of a CCSDS packet definition, according to a format specified in an XTCE\n\t        XML document. The parser iteratively builds sequences of parameters according to the\n\t        SequenceContainers specified in the XML document's ContainerSet element. The notions of container inheritance\n\t        (via BaseContainer) and nested container (by including a SequenceContainer within a SequenceContainer) are\n\t        supported. Exclusion of containers based on topLevelPacket in AncillaryData is not supported, so all\n\t        containers are examined and returned.\n\t        Parameters\n", "        ----------\n\t        xtce_document : str or Path\n\t            Path to XTCE XML document containing packet definition.\n\t        ns : dict\n\t            Optional different namespace than the default xtce namespace.\n\t        \"\"\"\n\t        self._sequence_container_cache = {}  # Lookup for parsed sequence container objects\n\t        self._parameter_cache = {}  # Lookup for parsed parameter objects\n\t        self.ns = ns or self._default_namespace\n\t        self.type_tag_to_object = {k.format(**self.ns): v for k, v in\n", "                                   self._tag_to_type_template.items()}\n\t        self.tree = ElementTree.parse(xtce_document)\n\t        for sequence_container in self.container_set.iterfind('xtce:SequenceContainer', self.ns):\n\t            self._sequence_container_cache[\n\t                sequence_container.attrib['name']\n\t            ] = self.parse_sequence_container_contents(sequence_container)\n\t        for name, sc in self._sequence_container_cache.items():\n\t            if sc.base_container_name:\n\t                self._sequence_container_cache[sc.base_container_name].inheritors.append(name)\n\t    def __getitem__(self, item):\n", "        return self._sequence_container_cache[item]\n\t    def parse_sequence_container_contents(self, sequence_container: ElementTree.Element) -> SequenceContainer:\n\t        \"\"\"Parses the list of parameters in a SequenceContainer element, recursively parsing nested SequenceContainers\n\t        to build an entry list of parameters that flattens the nested structure to derive a sequential ordering of\n\t        expected parameters for each SequenceContainer. Note that this also stores entry lists for containers that are\n\t        not intended to stand alone.\n\t        Parameters\n\t        ----------\n\t        sequence_container : ElementTree.Element\n\t            The SequenceContainer element to parse.\n", "        Returns\n\t        -------\n\t        : SequenceContainer\n\t            SequenceContainer containing an entry_list of SequenceContainers and Parameters\n\t            in the order expected in a packet.\n\t        \"\"\"\n\t        entry_list = []  # List to house Parameters for the current SequenceContainer\n\t        try:\n\t            base_container, restriction_criteria = self._get_container_base_container(sequence_container)\n\t            base_sequence_container = self.parse_sequence_container_contents(base_container)\n", "            #base_sequence_container.restriction_criteria = restriction_criteria\n\t            base_container_name = base_sequence_container.name\n\t            # Prepend the base container. This is necessary for handling multiple inheritance.\n\t            #entry_list.insert(0, base_sequence_container)\n\t        except ElementNotFoundError:\n\t            base_container_name = None\n\t            restriction_criteria = None\n\t        container_contents = sequence_container.find('xtce:EntryList', self.ns).findall('*', self.ns)\n\t        for entry in container_contents:\n\t            if entry.tag == '{{{xtce}}}ParameterRefEntry'.format(**self.ns):  # pylint: disable=consider-using-f-string\n", "                parameter_name = entry.attrib['parameterRef']\n\t                # If we've already parsed this parameter in a different container\n\t                if parameter_name in self._parameter_cache:\n\t                    entry_list.append(self._parameter_cache[parameter_name])\n\t                else:\n\t                    parameter_element = self._find_parameter(parameter_name)\n\t                    parameter_type_name = parameter_element.attrib['parameterTypeRef']\n\t                    parameter_type_element = self._find_parameter_type(parameter_type_name)\n\t                    parameter_type_class = self.type_tag_to_object[parameter_type_element.tag]\n\t                    parameter_object = Parameter(\n", "                        name=parameter_name,\n\t                        parameter_type=parameter_type_class.from_parameter_type_xml_element(\n\t                            parameter_type_element, self.ns))\n\t                    entry_list.append(parameter_object)\n\t                    self._parameter_cache[parameter_name] = parameter_object\n\t            elif entry.tag == '{{{xtce}}}ContainerRefEntry'.format(**self.ns):  # pylint: disable=consider-using-f-string\n\t                nested_container = self._find_container(name=entry.attrib['containerRef'])\n\t                entry_list.append(self.parse_sequence_container_contents(nested_container))\n\t        short_description = sequence_container.attrib['shortDescription'] if (\n\t                'shortDescription' in sequence_container.attrib\n", "        ) else None\n\t        long_description = sequence_container.find('xtce:LongDescription', self.ns).text if (\n\t                sequence_container.find('xtce:LongDescription', self.ns) is not None\n\t        ) else None\n\t        return SequenceContainer(name=sequence_container.attrib['name'],\n\t                                 entry_list=entry_list,\n\t                                 base_container_name=base_container_name,\n\t                                 restriction_criteria=restriction_criteria,\n\t                                 abstract=self._is_abstract_container(sequence_container),\n\t                                 short_description=short_description,\n", "                                 long_description=long_description)\n\t    @property\n\t    def named_containers(self):\n\t        \"\"\"Property accessor that returns the dict cache of SequenceContainer objecs\"\"\"\n\t        return self._sequence_container_cache\n\t    @property\n\t    def flattened_containers(self):\n\t        \"\"\"Accesses a flattened, generic representation of non-abstract packet definitions along with their\n\t        aggregated inheritance\n\t        restrictions.\n", "        Returns\n\t        -------\n\t        : dict\n\t            A modified form of the _sequence_container_cache, flattened out to eliminate nested sequence containers\n\t            and with all restriction logic aggregated together for easy comparisons.\n\t            {\n\t            \"PacketNameA\": {\n\t            FlattenedContainer(\n\t            entry_list=[Parameter, Parameter, ...],\n\t            restrictions={\"ParameterName\": value, \"OtherParamName\": value, ...}\n", "            )\n\t            },\n\t            \"PacketNameB\": {\n\t            FlattenedContainer(\n\t            entry_list=[Parameter, Parameter, ...],\n\t            restrictions={\"ParameterName\": value, \"OtherParamName\": value, ...}\n\t            )\n\t            }, ...\n\t            }\n\t        \"\"\"\n", "        def flatten_container(sequence_container: SequenceContainer):\n\t            \"\"\"Flattens the representation of a SequenceContainer object into a list of Parameters (in order) and\n\t            an aggregated dictionary of restriction criteria where the keys are Parameter names and the values are the\n\t            required values of those parameters in order to adopt the SequenceContainer's definition.\n\t            Parameters\n\t            ----------\n\t            sequence_container : SequenceContainer\n\t                SequenceContainer object to flatten, recursively.\n\t            Returns\n\t            -------\n", "            : list\n\t                List of Parameters, in order.\n\t            : dict\n\t                Dictionary of required Parameter values in order to use this definition.\n\t            \"\"\"\n\t            aggregated_entry_list = []\n\t            aggregated_restrictions = []\n\t            for entry in sequence_container.entry_list:\n\t                if isinstance(entry, SequenceContainer):\n\t                    if entry.restriction_criteria:\n", "                        aggregated_restrictions += entry.restriction_criteria\n\t                    entry_list, restrictions = flatten_container(entry)\n\t                    aggregated_entry_list += entry_list\n\t                    aggregated_restrictions += restrictions\n\t                elif isinstance(entry, Parameter):\n\t                    aggregated_entry_list.append(entry)\n\t            return aggregated_entry_list, aggregated_restrictions\n\t        return {\n\t            name: FlattenedContainer(*flatten_container(sc))\n\t            for name, sc in self._sequence_container_cache.items()\n", "            if not sc.abstract\n\t        }\n\t    @property\n\t    def container_set(self):\n\t        \"\"\"Property that returns the <xtce:ContainerSet> element, containing all the sequence container elements.\"\"\"\n\t        return self.tree.getroot().find('xtce:TelemetryMetaData/xtce:ContainerSet', self.ns)\n\t    @property\n\t    def parameter_type_set(self):\n\t        \"\"\"Property that returns the <xtce:ParameterTypeSet> element, containing all parameter type elements.\"\"\"\n\t        return self.tree.getroot().find('xtce:TelemetryMetaData/xtce:ParameterTypeSet', self.ns)\n", "    @property\n\t    def parameter_set(self):\n\t        \"\"\"Property that returns the <xtce:ParameterSet> element, containing all parameter elements.\"\"\"\n\t        return self.tree.getroot().find('xtce:TelemetryMetaData/xtce:ParameterSet', self.ns)\n\t    @staticmethod\n\t    def _is_abstract_container(container_element: ElementTree.Element) -> bool:\n\t        \"\"\"Determine in a SequenceContainer element is abstract\n\t        Parameters\n\t        ----------\n\t        container_element : ElementTree.Element\n", "            SequenceContainer element to examine\n\t        Returns\n\t        -------\n\t        : bool\n\t            True if SequenceContainer element has the attribute abstract=true. False otherwise.\n\t        \"\"\"\n\t        if 'abstract' in container_element.attrib:\n\t            return container_element.attrib['abstract'].lower() == 'true'\n\t        return False\n\t    def _find_container(self, name: str) -> ElementTree.Element:\n", "        \"\"\"Finds an XTCE container <xtce:SequenceContainer> by name.\n\t        Parameters\n\t        ----------\n\t        name : str\n\t            Name of the container to find\n\t        Returns\n\t        -------\n\t        : ElementTree.Element\n\t        \"\"\"\n\t        matches = self.container_set.findall(f\"./xtce:SequenceContainer[@name='{name}']\", self.ns)\n", "        assert len(matches) == 1, f\"Found {len(matches)} matching container_set with name {name}. \" \\\n\t                                  f\"Container names are expected to exist and be unique.\"\n\t        return matches[0]\n\t    def _find_parameter(self, name: str) -> ElementTree.Element:\n\t        \"\"\"Finds an XTCE Parameter in the tree.\n\t        Parameters\n\t        ----------\n\t        name : str\n\t            Name of the parameter to find\n\t        Returns\n", "        -------\n\t        : ElementTree.Element\n\t        \"\"\"\n\t        matches = self.parameter_set.findall(f\"./xtce:Parameter[@name='{name}']\", self.ns)\n\t        assert len(matches) == 1, f\"Found {len(matches)} matching parameters with name {name}. \" \\\n\t                                  f\"Parameter names are expected to exist and be unique.\"\n\t        return matches[0]\n\t    def _find_parameter_type(self, name: str) -> ElementTree.Element:\n\t        \"\"\"Finds an XTCE ParameterType in the tree.\n\t        Parameters\n", "        ----------\n\t        name : str\n\t            Name of the parameter type to find\n\t        Returns\n\t        -------\n\t        : ElementTree.Element\n\t        \"\"\"\n\t        matches = self.parameter_type_set.findall(f\"./*[@name='{name}']\", self.ns)\n\t        assert len(matches) == 1, f\"Found {len(matches)} matching parameter types with name {name}. \" \\\n\t                                  f\"Parameter type names are expected to exist and be unique.\"\n", "        return matches[0]\n\t    def _get_container_base_container(self, container_element: ElementTree.Element) -> Tuple[ElementTree.Element, list]:\n\t        \"\"\"Examines the container_element and returns information about its inheritance.\n\t        Parameters\n\t        ----------\n\t        container_element : ElementTree.Element\n\t            The container element for which to find its base container.\n\t        Returns\n\t        -------\n\t        : ElementTree.Element\n", "            The base container element of the input container_element.\n\t        : list\n\t            The restriction criteria for the inheritance.\n\t        \"\"\"\n\t        base_container_element = container_element.find('xtce:BaseContainer', self.ns)\n\t        if base_container_element is None:\n\t            raise ElementNotFoundError(\n\t                f\"Container element {container_element} does not have a BaseContainer child element.\")\n\t        restriction_criteria_element = base_container_element.find('xtce:RestrictionCriteria', self.ns)\n\t        if restriction_criteria_element is not None:\n", "            comparison_list_element = restriction_criteria_element.find('xtce:ComparisonList', self.ns)\n\t            single_comparison_element = restriction_criteria_element.find('xtce:Comparison', self.ns)\n\t            boolean_expression_element = restriction_criteria_element.find('xtce:BooleanExpression', self.ns)\n\t            custom_algorithm_element = restriction_criteria_element.find('xtce:CustomAlgorithm', self.ns)\n\t            if custom_algorithm_element is not None:\n\t                raise NotImplementedError(\"Detected a CustomAlgorithm in a RestrictionCriteria element. \"\n\t                                          \"This is not implemented.\")\n\t            if comparison_list_element is not None:\n\t                comparisons = comparison_list_element.findall('xtce:Comparison', self.ns)\n\t                restrictions = [Comparison.from_match_criteria_xml_element(comp, self.ns) for comp in comparisons]\n", "            elif single_comparison_element is not None:\n\t                restrictions = [Comparison.from_match_criteria_xml_element(single_comparison_element, self.ns)]\n\t            elif boolean_expression_element is not None:\n\t                restrictions = [BooleanExpression.from_match_criteria_xml_element(boolean_expression_element, self.ns)]\n\t            else:\n\t                raise ValueError(\"Detected a RestrictionCriteria element containing no \"\n\t                                 \"Comparison, ComparisonList, BooleanExpression or CustomAlgorithm.\")\n\t            # TODO: Implement NextContainer support inside RestrictionCriteria. This might make the parser much\n\t            #    more complicated.\n\t        else:\n", "            restrictions = []\n\t        return self._find_container(base_container_element.attrib['containerRef']), restrictions\n"]}
{"filename": "space_packet_parser/csvdef.py", "chunked_list": ["\"\"\"module for handling CSV-defined packet definitions\"\"\"\n\t# Standard\n\timport csv\n\timport re\n\tfrom collections import namedtuple\n\tfrom pathlib import Path\n\t# Local\n\tfrom space_packet_parser.xtcedef import Comparison, Parameter, IntegerDataEncoding, FloatDataEncoding, StringDataEncoding, \\\n\t    IntegerParameterType, FloatParameterType, StringParameterType\n\tFlattenedContainer = namedtuple('FlattenedContainer', ['entry_list', 'restrictions'])\n", "class CsvPacketDefinition:\n\t    \"\"\"Object representation of a space csv definition of a CCSDS packet object\"\"\"\n\t    def __init__(self, csv_def_filepath: str or Path, add_checksum=False):\n\t        \"\"\"Instantiate an object representation of a CCSDS packet definition, from a telemetry packet\n\t        definition csv file. The definition for this format is not as rigorously defined anywhere to my\n\t        knowledge. The definition has been determined from looking at existing files and referring to\n\t        the following confluence page:\n\t        https://confluence.space.colorado.edu/display/OSWHOME/space+CSV+to+XTCE+Conversion.\n\t        Parameters\n\t        ----------\n", "        csv_def_filepath : str or Path\n\t            Path to csv file containing packet definition.\n\t        \"\"\"\n\t        # TODO: Add configurable checksum length or just have the check_sum_param passed in directly?\n\t        if add_checksum:\n\t            check_sum_type = self.get_param_type_from_str('U16', 'CHECKSUM_Type')\n\t            self.check_sum_param = Parameter('CHECKSUM', check_sum_type)\n\t        else:\n\t            self.check_sum_param = None\n\t        self._csv_def_filepath = csv_def_filepath\n", "        self._csv_def = self.read_and_format_csv_file()\n\t        self._flattened_containers = self.gen_flattened_containers()\n\t    def read_and_format_csv_file(self):\n\t        \"\"\"Read in csv file and generate a list of RowTuples with each entry representing one row\n\t        from the file. Also rename any columns to conform to the expected names if needed.\n\t        Returns\n\t        -------\n\t        : list of RowTuple\n\t            A list containing all the rows, in order, from the CSV definition file.\n\t        \"\"\"\n", "        with open(self._csv_def_filepath, encoding='utf-8') as csv_file:\n\t            csv_reader = csv.DictReader(csv_file)\n\t            csv_reader = self.fix_column_names(csv_reader)\n\t            csv_def = list(csv_reader)\n\t        RowTuple = namedtuple('csv_row', csv_def[0].keys())\n\t        def get_tuple_for_row(row_dict):\n\t            row_tuple = RowTuple(**row_dict)\n\t            return row_tuple\n\t        csv_def = list(map(get_tuple_for_row, csv_def))\n\t        return csv_def\n", "    def fix_column_names(self, csv_reader):\n\t        \"\"\"Checks the names of some required columns and changes them to allow for uniform processing.\n\t        Parameters\n\t        ----------\n\t        csv_reader : csv.DictReader\n\t            The DictReader generated from reading in the csv CCSDS definition.\n\t        Returns\n\t        -------\n\t        : csv.DictReader\n\t            The input DictReader with any non standard column names replaced.\n", "        \"\"\"\n\t        # TODO: Unify this with the header_name_mappings kwarg used in Parser to allow the user to specify this\n\t        #   on the fly\n\t        # The definition allows the packet name to be labeled as 'Packet' or 'Container'. We will rename\n\t        # this column as 'Container' for consistency with the rest of the container oriented code.\n\t        if 'Packet' in csv_reader.fieldnames:\n\t            # rename packet column to container\n\t            csv_reader.fieldnames[csv_reader.fieldnames.index('Packet')] = 'Container'\n\t        if 'Container' not in csv_reader.fieldnames:\n\t            raise ValueError(\"According to definition the csv file must contain either Packet or Container column\")\n", "        if 'Type' in csv_reader.fieldnames:\n\t            csv_reader.fieldnames[csv_reader.fieldnames.index('Type')] = 'DataType'\n\t            # rename packet column to container\n\t        if 'DataType' not in csv_reader.fieldnames:\n\t            raise ValueError(\"According to definition the csv file must contain either Type or DataType column\")\n\t        if 'APID' not in csv_reader.fieldnames:\n\t            raise NotImplementedError(\n\t                \"APID must be one of the columns in the csv file format, other variations are note yet supported\")\n\t        return csv_reader\n\t    def gen_flattened_containers(self):\n", "        # FIXME: Recommend changing this method to a @property getter instead.\n\t        \"\"\"Generates a dict of flattened containers from the csv definition.\n\t        Returns\n\t        -------\n\t        : dict\n\t            A dict of FlattenedContainer namedtuples.\n\t        \"\"\"\n\t        container_column = [row.Container for row in self._csv_def]\n\t        uniq_container_names = list(dict.fromkeys(container_column))\n\t        flattened_containers = {}\n", "        for container_name in uniq_container_names:\n\t            next_container = [row for row in self._csv_def if row.Container == container_name]\n\t            flatten_container = self.gen_flattened_container(next_container)\n\t            flattened_containers[container_name] = flatten_container\n\t        return flattened_containers\n\t    def gen_flattened_container(self, container) -> FlattenedContainer:\n\t        \"\"\"Convert the csv definition for a single container type into a FlattenedContainer\n\t        containing the restrictions and entry list for this container type.\n\t        Parameters\n\t        ----------\n", "        container : list of RowTuple\n\t            A list containing all the rows, in order, from the CSV definition\n\t            pertaining to a single container type.\n\t        Returns\n\t        -------\n\t        : FlattenedContainer\n\t            A namedtuple containing an entry list and restrictions.\n\t            FlattenedContainer(\n\t            entry_list=[Parameter, Parameter, ...],\n\t            restrictions={\"ParameterName\": value, \"OtherParamName\": value, ...}\n", "            )\n\t        \"\"\"\n\t        entry_list = self.gen_entry_list(container)\n\t        restrictions = self.gen_restrictions(container)\n\t        return FlattenedContainer(entry_list, restrictions)\n\t    def gen_restrictions(self, container, pkt_apid_header_name='PKT_APID'):\n\t        \"\"\" Determines and generates a dict of restrictions for a container type.\n\t        Note: the only restriction currently supported is PKT_APID.\n\t        Parameters\n\t        ----------\n", "        container : dict of RowTuple\n\t            A list containing all the rows, in order, from the CSV definition\n\t            pertaining to a single container type.\n\t        pkt_apid_header_name : str\n\t            The string used in the packet header describing the APID for the CCSDS packet.\n\t        Returns\n\t        -------\n\t        : dict\n\t            A dict containing the restrictions for the container parameter\n\t        \"\"\"\n", "        last_apid = container[0].APID\n\t        for row in container:\n\t            next_apid = row.APID\n\t            if next_apid != last_apid:\n\t                raise NotImplementedError('The only container restriction currently support is APID and there must be '\n\t                                          'a one to one correlation between Container names and APIDs')\n\t            last_apid = next_apid\n\t        restrictions = [\n\t            Comparison(required_value=last_apid, referenced_parameter=pkt_apid_header_name, use_calibrated_value=False)\n\t        ]\n", "        return restrictions\n\t    def gen_entry_list(self, container: list):\n\t        \"\"\"Generates a list of Parameters for the given container. Each Parameter corresponds to one\n\t        telemetry item for the container.\n\t        Parameters\n\t        ----------\n\t        container : list of RowTuple\n\t            A list containing all the rows, in order, from the CSV definition\n\t            pertaining to a single container type.\n\t        Returns\n", "        -------\n\t        : list of Parameters\n\t            A list of Parameter objects with each Parameter corresponding to one telemetry\n\t            item from the container input\n\t        \"\"\"\n\t        pkt_entry_list = []\n\t        for row in container:\n\t            param_type_name = row.ItemName + '_Type'\n\t            param_type = self.get_param_type_from_str(row.DataType, param_type_name)\n\t            param = Parameter(row.ItemName, param_type)\n", "            pkt_entry_list.append(param)\n\t        if self.check_sum_param is not None:\n\t            pkt_entry_list.append(self.check_sum_param)\n\t        return pkt_entry_list\n\t    @staticmethod\n\t    def get_param_type_from_str(dtype, param_type_name, unit=None):\n\t        \"\"\"Determines the ParameterType to use for a given CSV data type format string.\n\t        Parameters\n\t        ----------\n\t        dtype : str\n", "            A string defining the data encoding of a telemetry item.\n\t            Examples:\n\t            'U8' - unsigned 8-bit integer\n\t            'F16' - 16-bit float\n\t            'C64' - 64 byte character array\n\t        param_type_name : str\n\t            Name to be given to the created ParameterType\n\t        unit : str or None\n\t            Name of the units for the created ParameterType\n\t        Returns\n", "        -------\n\t        : ParameterType\n\t            A ParameterType corresponding to the input variables\n\t        \"\"\"\n\t        # All data types must be a string starting with all letters and ending with integers ie 'U12' or 'Float8'\n\t        split_i = re.search('[0-9]', dtype).start()\n\t        if split_i is None:\n\t            raise NotImplementedError(\"According to definition derived types may not specify a bit size. \"\n\t                                      \"This is not currently supported\")\n\t        dtype_size = int(dtype[split_i:])\n", "        dtype_str = dtype[:split_i]\n\t        if dtype_str[0] == 'U':\n\t            encoding = IntegerDataEncoding(dtype_size, 'unsigned')\n\t            paramType = IntegerParameterType(name=param_type_name, encoding=encoding, unit=unit)\n\t        elif dtype_str[0] == 'I':\n\t            encoding = IntegerDataEncoding(dtype_size, 'signed')\n\t            paramType = IntegerParameterType(name=param_type_name, encoding=encoding, unit=unit)\n\t        elif dtype_str[0] == 'D':\n\t            encoding = IntegerDataEncoding(dtype_size, 'unsigned')  # TODO: Should this be converted to discrete values?\n\t            paramType = IntegerParameterType(name=param_type_name, encoding=encoding, unit=unit)\n", "        elif dtype_str[0] == 'F':\n\t            encoding = FloatDataEncoding(dtype_size)\n\t            paramType = FloatParameterType(name=param_type_name, encoding=encoding, unit=unit)\n\t        elif dtype_str[0] == 'C':\n\t            encoding = StringDataEncoding(fixed_length=dtype_size)\n\t            paramType = StringParameterType(name=param_type_name, encoding=encoding, unit=unit)\n\t        else:\n\t            raise NotImplementedError(\"This dtype not yet supported\")\n\t        return paramType\n\t    @property\n", "    def flattened_containers(self):\n\t        \"\"\"Accesses a flattened, generic representation of non-abstract packet definitions along with their\n\t        aggregated inheritance\n\t        restrictions.\n\t        Returns\n\t        -------\n\t        : dict\n\t            A modified form of the _sequence_container_cache, flattened out to eliminate nested sequence containers\n\t            and with all restriction logic aggregated together for easy comparisons.\n\t        \"\"\"\n", "        return self._flattened_containers\n"]}
{"filename": "space_packet_parser/__init__.py", "chunked_list": []}
{"filename": "examples/parsing_and_plotting_idex_waveforms_from_socket.py", "chunked_list": ["\"\"\"Example of parsing and plotting IDEX data from a socket\n\tThis is basically a rudimentary quickview tool. It demonstrates how this library can be used, in conjunction with\n\tother tools like matplotlib to parse, organize, and plot data coming through a socket. The low level packet parsing\n\tis done based on the XTCE definition for IDEX but there is significant additional logic that parses and concatenates\n\tthe binary blob fields of the packets, which contain the science data arrays.\n\tThe packet definition used here is intended for IDEX, which is basically a rebuild of the idex instrument.\n\tThe data used here is IDEX data but the fields are parsed using IDEX naming conventions.\n\tNote: This example requires the matplotlib library which is not part of the base dependency spec for space_packet_parser.\n\t\"\"\"\n\t# Standard\n", "from multiprocessing import Process\n\tfrom pathlib import Path\n\timport random\n\timport socket\n\timport time\n\t# Installed\n\timport bitstring\n\timport matplotlib.pyplot as plt\n\t# Local\n\tfrom space_packet_parser import xtcedef\n", "from space_packet_parser import parser\n\tdef send_data(sender: socket.socket, file: Path):\n\t    \"\"\"Send data from a file as bytes via a socket with random chunk sizes and random waits between sending chunks\n\t    Parameters\n\t    ----------\n\t    sender : socket.socket\n\t        Socket over which to send the data.\n\t    file : Path\n\t        File to send as bytes over a socket connection\n\t    \"\"\"\n", "    # Read binary file\n\t    with file.open('rb') as fh:\n\t        stream = bitstring.ConstBitStream(fh)\n\t        while stream.pos < len(stream):\n\t            time.sleep(random.random() * .1)  # Random sleep up to 1s\n\t            # Send binary data to socket in random chunk sizes\n\t            random_n_bytes = random.randint(1024, 2048)\n\t            n_bits_to_send = 8 * random_n_bytes\n\t            if stream.pos + n_bits_to_send > len(stream):\n\t                n_bits_to_send = len(stream) - stream.pos\n", "            chunk_to_send = stream[stream.pos:stream.pos + n_bits_to_send]\n\t            print(f\"Sending {len(chunk_to_send)} bytes\")\n\t            sender.send(chunk_to_send.bytes)\n\t            stream.pos += n_bits_to_send\n\t        print(\"\\nFinished sending data.\")\n\tdef parse_hg_waveform(waveform_raw: str):\n\t    \"\"\"Parse a binary string representing a high gain waveform\"\"\"\n\t    w = bitstring.ConstBitStream(bin=waveform_raw)\n\t    ints = []\n\t    while w.pos < len(w):\n", "        w.read('pad:2')  # skip 2. Note: for old versions of bitstring, use bits:2, not pad:2.\n\t        ints += w.readlist(['uint:10']*3)\n\t    return ints\n\tdef parse_lg_waveform(waveform_raw: str):\n\t    \"\"\"Parse a binary string representing a low gain waveform\"\"\"\n\t    w = bitstring.ConstBitStream(bin=waveform_raw)\n\t    ints = []\n\t    while w.pos < len(w):\n\t        w.read('pad:8')  # skip 8\n\t        ints += w.readlist(['uint:12']*2)\n", "    return ints\n\tdef parse_waveform_data(waveform: str, scitype: int):\n\t    \"\"\"Parse the binary string that represents a waveform\"\"\"\n\t    print(f'Parsing waveform for scitype={scitype}')\n\t    if scitype in (2, 4, 8):\n\t        return parse_hg_waveform(waveform)\n\t    else:\n\t        return parse_lg_waveform(waveform)\n\tdef plot_full_event(data: dict):\n\t    \"\"\"Plot a full event (6 channels)\"\"\"\n", "    fix, ax = plt.subplots(nrows=6)\n\t    for i, (s0t, d) in enumerate(data.items()):\n\t        ax[i].plot(d)\n\t        ax[i].set_ylabel(s0t)\n\t    plt.show()\n\tif __name__ == \"__main__\":\n\t    \"\"\"Parse IDEX data\"\"\"\n\t    idex_test_data_dir = Path(\"../tests/test_data/idex\")\n\t    idex_xtce = idex_test_data_dir / 'idex_combined_science_definition.xml'\n\t    idex_definition = xtcedef.XtcePacketDefinition(xtce_document=idex_xtce)\n", "    assert isinstance(idex_definition, xtcedef.XtcePacketDefinition)\n\t    idex_parser = parser.PacketParser(idex_definition)\n\t    idex_packet_file = idex_test_data_dir / 'sciData_2023_052_14_45_05'\n\t    sender, receiver = socket.socketpair()\n\t    receiver.settimeout(3)\n\t    file = '/Users/game1390/Workspace/space/space_packet_parser/tests/test_data/jpss/J01_G011_LZ_2021-04-09T00-00-00Z_V01.DAT1'\n\t    p = Process(target=send_data, args=(sender, idex_packet_file,))\n\t    p.start()\n\t    # Create a packet generator that listens to a socket\n\t    idex_packet_generator = idex_parser.generator(receiver)\n", "    try:\n\t        p = next(idex_packet_generator)\n\t        print(p)\n\t        while True:\n\t            if 'IDX__SCI0TYPE' in p.data:\n\t                scitype = p.data['IDX__SCI0TYPE'].raw_value\n\t                print(scitype)\n\t                if scitype == 1:  # This packet marks the beginning of an \"event\"\n\t                    data = {}\n\t                    event_header = p\n", "                    # Each time we encounter a new scitype, that represents a new channel so we create a new array.\n\t                    # A single channel of data may be spread between multiple packets, which must be concatenated.\n\t                    p = next(idex_packet_generator)\n\t                    scitype = p.data['IDX__SCI0TYPE'].raw_value\n\t                    print(scitype, end=\", \")\n\t                    data[scitype] = p.data['IDX__SCI0RAW'].raw_value\n\t                    while True:\n\t                        # If we run into the end of the file, this will raise StopIteration and break both while loops\n\t                        p_next = next(idex_packet_generator)\n\t                        next_scitype = p_next.data['IDX__SCI0TYPE'].raw_value\n", "                        print(next_scitype, end=\", \")\n\t                        if next_scitype == scitype:\n\t                            # If the scitype is the same as the last packet, then concatenate them\n\t                            data[scitype] += p_next.data['IDX__SCI0RAW'].raw_value\n\t                        else:\n\t                            # Otherwise check if we are at the end of the event (next scitype==1)\n\t                            if next_scitype == 1:\n\t                                break\n\t                            scitype = next_scitype\n\t                            data[scitype] = p_next.data['IDX__SCI0RAW'].raw_value\n", "                    p = p_next\n\t                    # If you have more than one complete event in a file (i.e. scitype 1, 2, 4, 8, 16, 32, 64),\n\t                    # this loop would continue.\n\t                    # For this example, we only have one full event so we have already hit a StopIteration by\n\t                    # this point.\n\t                # We denote channels by their scitype value (2, 4, 8, 16, 32, 64) and parse the waveform binary blob\n\t                # data using functions defined above.\n\t                data = {scitype: parse_waveform_data(waveform, scitype) for scitype, waveform in data.items()}\n\t                plot_full_event(data)\n\t    except StopIteration:\n", "        data = {scitype: parse_waveform_data(waveform, scitype) for scitype, waveform in data.items()}\n\t        plot_full_event(data)\n\t        print(\"\\nEncountered the end of the binary file.\")\n\t        pass\n"]}
{"filename": "docs/source/conf.py", "chunked_list": ["# Configuration file for the Sphinx documentation builder.\n\t#\n\t# For the full list of built-in configuration values, see the documentation:\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\t# -- Project information -----------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n\tproject = 'space_packet_parser'\n\tcopyright = '2023 University of Colorado'\n\tauthor = 'Gavin Medley, Michael Chambliss'\n\t# -- General configuration ---------------------------------------------------\n", "# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration\n\textensions = [\n\t    \"myst_parser\",\n\t    \"sphinx.ext.napoleon\",\n\t    \"autoapi.extension\"\n\t]\n\tautoapi_type = 'python'\n\tautoapi_dirs = ['../../space_packet_parser']\n\ttemplates_path = ['_templates']\n\texclude_patterns = []\n", "source_suffix = {\n\t    '.rst': 'restructuredtext',\n\t    '.txt': 'markdown',\n\t    '.md': 'markdown',\n\t}\n\t# -- Options for HTML output -------------------------------------------------\n\t# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output\n\thtml_theme = 'sphinx_rtd_theme'\n\thtml_static_path = [\"_static\"]\n\thtml_logo = \"_static/logo-no-background.png\""]}
